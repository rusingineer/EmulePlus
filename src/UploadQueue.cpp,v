head	1.231;
access;
symbols
	PublicRelease_1_2e:1.227
	Interim_Release_1-2e_RC1:1.226
	PublicRelease_1_2d:1.223
	Interim_Release_1-2d_RC1:1.223
	Interim_Release_1-2d_beta1:1.223
	PublicRelease_1_2c:1.216
	Interim_Release_1-2c_RC1:1.216
	Interim_Release_1-2c_beta1:1.213
	PublicRelease_1_2b:1.212
	Interim_Release_1-2b_RC1:1.212
	PublicRelease_1_2a:1.206
	Interim_Release_1-2a_RC1:1.206
	Interim_Release_1-2a_beta2:1.203
	Interim_Release_1-2a_beta1:1.203
	PublicRelease_1_2:1.197
	Interim_Release_1-2_RC1:1.197
	Interim_Release_1-2_beta1:1.197
	PublicRelease_1_1g:1.196
	Interim_Release_1-1g_RC3:1.196
	Interim_Release_1-1g_RC2:1.196
	Interim_Release_1-1g_RC1:1.196
	Interim_Release_1-1g_beta2:1.194
	Interim_Release_1-1g_beta1:1.187
	PublicRelease_1_1f:1.184
	Interim_Release_1-1f_RC1:1.184
	PublicRelease_1_1e:1.184
	Interim_Release_1-1e_RC2:1.184
	Interim_Release_1-1e_RC1:1.184
	Interim_Release_1-1e_beta1:1.182
	PublicRelease_1_1d:1.180
	Interim_Release_1-1d_RC1:1.180
	PublicRelease_1_1c:1.180
	Interim_Release_1-1c_RC1:1.179
	Interim_Release_1-1c_beta2:1.178
	Interim_Release_1-1c_beta1:1.178
	PublicRelease_1_1b:1.175
	Interim_Release_1-1b_RC1:1.175
	PublicRelease_1_1a:1.171
	Interim_Release_1-1a_RC2:1.171
	Interim_Release_1-1a_RC1:1.169
	Interim_Release_1-1a_beta2:1.167
	Interim_Release_1-1a_beta1:1.167
	PublicRelease_1_1:1.165
	Interim_Release_1-1_beta1:1.165
	PublicRelease_1o:1.163
	Interim_Release_1o_RC1:1.162
	Interim_Release_1o_beta1:1.161
	PublicRelease_1n:1.161
	Interim_Release_1n_RC2:1.161
	Interim_Release_1n_RC1:1.161
	Interim_Release_1n_beta2:1.152
	Interim_Release_1n_beta1:1.149
	PublicRelease_1m:1.146
	Interim_Release_1m_beta1:1.146
	PublicRelease_1l:1.146
	Interim_Release_1l_RC3:1.144
	Interim_Release_1l_RC2:1.143
	Interim_Release_1l_RC1:1.143
	Interim_Release_1l_beta2:1.142
	Interim_Release_1l_beta1:1.138
	PublicRelease_1k:1.130
	Interim_Release_1k_RC4:1.130
	Interim_1k_RC3:1.130
	Interim_1k_RC2:1.126
	Interim_Release_1k_RC1:1.124
	Interim_Release_1k_beta5:1.120
	Intrerim_Release_1k_beta4:1.120
	Interim_Release_1k_beta1:1.112
	PublicRelease_1j:1.102
	Interim_Release_1J_RC3:1.102
	Interim_Release_1j_RC3:1.102
	Interim_Release_1j_RC2:1.99
	Interim_Release_1j_RC1:1.98
	Interim_Release_1j_beta2:1.98
	Interim_Release_1j_beta1:1.98
	PublicRelease_1i:1.93
	Interim_Release_1i_RC6:1.93
	Interim_Release_1i_RC3:1.93
	Interim_Release_1i_RC2:1.93
	Interim_Release_1i_RC1:1.93
	Interim_Release_1i_beta3:1.93
	Interim_Release_1i_beta2:1.92
	Interim_Release_1i_beta1:1.82
	PublicRelease_1h:1.76
	Interim_Release_1h_rc2:1.75
	Interim_Release_1h_RC1:1.75
	Interim_Release_1h_beta2:1.74
	Interim_Release_1h_beta1_now:1.66
	Interim_Release_1h_beta1:1.66
	PublicRelease_1g:1.58
	Interim_Release_1g_RC6_Final:1.58
	Interim_Release_1g_RC6:1.58
	Interim_Release_1g_RC5:1.55
	Interim_Release_1g_RC4:1.55
	Interim_Release_1g_RC3:1.53
	Interim_Release_1g_beta2:1.48
	Interim_Release_1g_beta1:1.45
	Interim_Release_1f_RC4:1.43
	Interim_Release_1f_RC3:1.43
	Interim_Release_1f_RC2:1.41
	Interim_Release_1f_RC:1.41
	Interim_Release_1f_beta2:1.41
	Interim_Release_1f_beta1:1.40
	PublicRelease_1e:1.39
	Interim_Release_1e_RC2:1.39
	Interim_Release_1e_RC:1.39
	Interim_Release_1e_beta3:1.39
	Interim_Release_1e_beta2:1.39
	Interim_Release_1e_beta2_before_kuchin:1.39
	Interim_Release_1e_beta1:1.39
	PublicRelease_1c:1.35
	featurestest:1.34.0.2
	Interim_Release_1c_RC:1.34
	Interim_Release_1c_beta2:1.32
	Interim_Release_1c_beta1:1.30
	threaded_downloadqueue:1.30.0.2
	PublicRelease_1b:1.26
	Interim_Release_1b_beta2:1.26
	Interim_Release_1b_beta1:1.26
	proxydeadlake:1.22.0.4
	PublicRelease_1a:1.22
	Interim_Release_1a_beta2:1.22
	BerkeleyDb:1.22.0.2
	Interim_Release_1a_beta1:1.22
	PublicRelease_1:1.17
	goldfish:1.16
	eMulePlus_1_RC2:1.15
	eMulePlus_26b_1RC1:1.14
	PreRelease_26b_i0e:1.14
	before_26d_merge:1.13
	Interim_Release_26b_i0d:1.11
	Interim_Release_26b_i0c:1.9
	Interim_Release_26b_i0b:1.9
	Interim_Release_26b_i0a:1.9
	systraydlg:1.8.0.4
	plus26based:1.8.0.2
	Interim_Release_25b_i0b:1.8
	Proxy_Dev:1.8
	Interim_Release_25b_i0a:1.5.2.1
	proxytest:1.5.2.1.0.2
	official_sockets:1.5.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.231
date	2009.10.28.04.35.00;	author aw3;	state Exp;
branches;
next	1.230;

1.230
date	2009.07.19.14.48.38;	author aw3;	state Exp;
branches;
next	1.229;

1.229
date	2009.07.15.02.23.05;	author aw3;	state Exp;
branches;
next	1.228;

1.228
date	2009.04.29.03.14.16;	author aw3;	state Exp;
branches;
next	1.227;

1.227
date	2009.04.08.04.05.38;	author aw3;	state Exp;
branches;
next	1.226;

1.226
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.225;

1.225
date	2008.11.03.05.45.24;	author aw3;	state Exp;
branches;
next	1.224;

1.224
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.223;

1.223
date	2008.02.16.04.29.50;	author aw3;	state Exp;
branches;
next	1.222;

1.222
date	2008.02.09.12.28.05;	author eklmn;	state Exp;
branches;
next	1.221;

1.221
date	2008.01.31.22.50.31;	author eklmn;	state Exp;
branches;
next	1.220;

1.220
date	2008.01.23.05.13.19;	author aw3;	state Exp;
branches;
next	1.219;

1.219
date	2007.12.16.16.35.41;	author eklmn;	state Exp;
branches;
next	1.218;

1.218
date	2007.12.15.13.19.13;	author eklmn;	state Exp;
branches;
next	1.217;

1.217
date	2007.12.12.20.15.32;	author eklmn;	state Exp;
branches;
next	1.216;

1.216
date	2007.07.23.03.49.04;	author aw3;	state Exp;
branches;
next	1.215;

1.215
date	2007.07.14.04.08.55;	author aw3;	state Exp;
branches;
next	1.214;

1.214
date	2007.07.08.22.31.19;	author kush_eplus;	state Exp;
branches;
next	1.213;

1.213
date	2007.02.17.05.41.21;	author aw3;	state Exp;
branches;
next	1.212;

1.212
date	2007.01.17.03.02.03;	author aw3;	state Exp;
branches;
next	1.211;

1.211
date	2007.01.08.05.58.30;	author aw3;	state Exp;
branches;
next	1.210;

1.210
date	2006.11.23.05.27.33;	author aw3;	state Exp;
branches;
next	1.209;

1.209
date	2006.11.21.12.09.41;	author eklmn;	state Exp;
branches;
next	1.208;

1.208
date	2006.11.16.05.51.47;	author aw3;	state Exp;
branches;
next	1.207;

1.207
date	2006.11.13.17.07.27;	author eklmn;	state Exp;
branches;
next	1.206;

1.206
date	2006.08.01.02.54.15;	author aw3;	state Exp;
branches;
next	1.205;

1.205
date	2006.07.29.01.55.52;	author aw3;	state Exp;
branches;
next	1.204;

1.204
date	2006.07.13.12.05.19;	author aw3;	state Exp;
branches;
next	1.203;

1.203
date	2006.04.29.21.59.57;	author eklmn;	state Exp;
branches;
next	1.202;

1.202
date	2006.04.27.18.25.00;	author dongato;	state Exp;
branches;
next	1.201;

1.201
date	2006.04.22.21.58.08;	author aw3;	state Exp;
branches;
next	1.200;

1.200
date	2006.04.16.23.52.29;	author kush_eplus;	state Exp;
branches;
next	1.199;

1.199
date	2006.04.14.15.11.27;	author aw3;	state Exp;
branches;
next	1.198;

1.198
date	2006.04.04.22.28.40;	author kush_eplus;	state Exp;
branches;
next	1.197;

1.197
date	2006.01.16.01.41.13;	author kush_eplus;	state Exp;
branches;
next	1.196;

1.196
date	2005.11.27.22.11.51;	author eklmn;	state Exp;
branches;
next	1.195;

1.195
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.194;

1.194
date	2005.11.26.19.06.53;	author aw3;	state Exp;
branches;
next	1.193;

1.193
date	2005.11.26.10.01.21;	author eklmn;	state Exp;
branches;
next	1.192;

1.192
date	2005.11.23.04.00.32;	author aw3;	state Exp;
branches;
next	1.191;

1.191
date	2005.11.04.06.49.51;	author aw3;	state Exp;
branches;
next	1.190;

1.190
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.189;

1.189
date	2005.09.11.02.56.44;	author aw3;	state Exp;
branches;
next	1.188;

1.188
date	2005.08.28.08.28.56;	author eklmn;	state Exp;
branches;
next	1.187;

1.187
date	2005.08.22.16.51.40;	author eklmn;	state Exp;
branches;
next	1.186;

1.186
date	2005.08.18.21.32.44;	author eklmn;	state Exp;
branches;
next	1.185;

1.185
date	2005.08.04.03.34.41;	author aw3;	state Exp;
branches;
next	1.184;

1.184
date	2005.06.19.05.02.40;	author aw3;	state Exp;
branches;
next	1.183;

1.183
date	2005.06.17.15.20.09;	author eklmn;	state Exp;
branches;
next	1.182;

1.182
date	2005.05.23.20.57.08;	author aw3;	state Exp;
branches;
next	1.181;

1.181
date	2005.05.17.17.01.53;	author eklmn;	state Exp;
branches;
next	1.180;

1.180
date	2005.02.26.22.44.00;	author aw3;	state Exp;
branches;
next	1.179;

1.179
date	2005.02.20.20.29.35;	author aw3;	state Exp;
branches;
next	1.178;

1.178
date	2005.01.28.01.47.24;	author aw3;	state Exp;
branches;
next	1.177;

1.177
date	2005.01.19.19.37.26;	author eklmn;	state Exp;
branches;
next	1.176;

1.176
date	2004.12.27.22.37.17;	author eklmn;	state Exp;
branches;
next	1.175;

1.175
date	2004.12.22.08.26.16;	author aw3;	state Exp;
branches;
next	1.174;

1.174
date	2004.12.20.19.28.08;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2004.12.19.22.12.03;	author aw3;	state Exp;
branches;
next	1.172;

1.172
date	2004.12.19.13.43.28;	author eklmn;	state Exp;
branches;
next	1.171;

1.171
date	2004.12.02.06.55.13;	author aw3;	state Exp;
branches;
next	1.170;

1.170
date	2004.12.01.16.10.16;	author eklmn;	state Exp;
branches;
next	1.169;

1.169
date	2004.11.26.18.59.51;	author aw3;	state Exp;
branches;
next	1.168;

1.168
date	2004.11.26.06.40.15;	author eklmn;	state Exp;
branches;
next	1.167;

1.167
date	2004.11.05.18.43.39;	author eklmn;	state Exp;
branches;
next	1.166;

1.166
date	2004.10.24.01.20.56;	author eklmn;	state Exp;
branches;
next	1.165;

1.165
date	2004.10.18.18.09.50;	author aw3;	state Exp;
branches;
next	1.164;

1.164
date	2004.10.08.04.35.58;	author aw3;	state Exp;
branches;
next	1.163;

1.163
date	2004.09.28.03.42.04;	author aw3;	state Exp;
branches;
next	1.162;

1.162
date	2004.09.25.07.25.28;	author aw3;	state Exp;
branches;
next	1.161;

1.161
date	2004.08.21.11.42.56;	author eklmn;	state Exp;
branches;
next	1.160;

1.160
date	2004.08.15.22.18.37;	author aw3;	state Exp;
branches;
next	1.159;

1.159
date	2004.08.15.21.06.03;	author eklmn;	state Exp;
branches;
next	1.158;

1.158
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.157;

1.157
date	2004.08.11.08.37.38;	author eklmn;	state Exp;
branches;
next	1.156;

1.156
date	2004.08.10.19.25.47;	author eklmn;	state Exp;
branches;
next	1.155;

1.155
date	2004.08.07.16.40.32;	author eklmn;	state Exp;
branches;
next	1.154;

1.154
date	2004.08.07.12.02.34;	author eklmn;	state Exp;
branches;
next	1.153;

1.153
date	2004.08.07.11.46.58;	author eklmn;	state Exp;
branches;
next	1.152;

1.152
date	2004.08.07.08.51.54;	author eklmn;	state Exp;
branches;
next	1.151;

1.151
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.150;

1.150
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2004.07.18.18.31.31;	author eklmn;	state Exp;
branches;
next	1.148;

1.148
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.147;

1.147
date	2004.06.30.13.38.43;	author dongato;	state Exp;
branches;
next	1.146;

1.146
date	2004.06.10.10.22.21;	author dongato;	state Exp;
branches;
next	1.145;

1.145
date	2004.06.09.22.54.16;	author dongato;	state Exp;
branches;
next	1.144;

1.144
date	2004.06.07.13.48.39;	author netwolf1;	state Exp;
branches;
next	1.143;

1.143
date	2004.05.24.19.14.17;	author syrus77;	state Exp;
branches;
next	1.142;

1.142
date	2004.05.21.18.37.19;	author dongato;	state Exp;
branches;
next	1.141;

1.141
date	2004.05.20.03.28.32;	author kush_eplus;	state Exp;
branches;
next	1.140;

1.140
date	2004.05.19.12.08.46;	author netwolf1;	state Exp;
branches;
next	1.139;

1.139
date	2004.05.12.08.30.32;	author netwolf1;	state Exp;
branches;
next	1.138;

1.138
date	2004.05.06.01.39.09;	author katsyonak;	state Exp;
branches;
next	1.137;

1.137
date	2004.05.03.10.57.14;	author netwolf1;	state Exp;
branches;
next	1.136;

1.136
date	2004.05.01.05.31.28;	author aw3;	state Exp;
branches;
next	1.135;

1.135
date	2004.04.18.13.17.29;	author bavariansnail;	state Exp;
branches;
next	1.134;

1.134
date	2004.04.17.19.58.59;	author dongato;	state Exp;
branches;
next	1.133;

1.133
date	2004.04.17.03.28.36;	author aw3;	state Exp;
branches;
next	1.132;

1.132
date	2004.04.12.16.24.24;	author dongato;	state Exp;
branches;
next	1.131;

1.131
date	2004.04.12.00.36.15;	author aw3;	state Exp;
branches;
next	1.130;

1.130
date	2004.04.03.17.41.18;	author dongato;	state Exp;
branches;
next	1.129;

1.129
date	2004.04.03.13.21.14;	author dongato;	state Exp;
branches;
next	1.128;

1.128
date	2004.04.03.12.45.35;	author dongato;	state Exp;
branches;
next	1.127;

1.127
date	2004.04.01.15.14.21;	author dongato;	state Exp;
branches;
next	1.126;

1.126
date	2004.03.30.19.21.34;	author aw3;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.30.07.27.17;	author eklmn;	state Exp;
branches;
next	1.124;

1.124
date	2004.03.28.12.01.12;	author dongato;	state Exp;
branches;
next	1.123;

1.123
date	2004.03.28.07.01.15;	author dongato;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.27.21.20.31;	author dongato;	state Exp;
branches;
next	1.121;

1.121
date	2004.03.27.19.39.45;	author dongato;	state Exp;
branches;
next	1.120;

1.120
date	2004.03.18.12.53.38;	author kush_eplus;	state Exp;
branches;
next	1.119;

1.119
date	2004.03.18.03.44.12;	author kush_eplus;	state Exp;
branches;
next	1.118;

1.118
date	2004.03.17.02.46.48;	author kush_eplus;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.23.16.44.45;	author kush_eplus;	state Exp;
branches;
next	1.116;

1.116
date	2004.02.23.15.28.48;	author dongato;	state Exp;
branches;
next	1.115;

1.115
date	2004.02.23.14.42.40;	author kush_eplus;	state Exp;
branches;
next	1.114;

1.114
date	2004.02.23.13.33.24;	author kush_eplus;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.23.10.51.25;	author dongato;	state Exp;
branches;
next	1.112;

1.112
date	2004.02.20.00.22.26;	author kush_eplus;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.19.14.04.00;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2004.02.19.00.29.35;	author netwolf1;	state Exp;
branches;
next	1.109;

1.109
date	2004.02.13.16.13.35;	author netwolf1;	state Exp;
branches;
next	1.108;

1.108
date	2004.02.12.18.41.18;	author syrus77;	state Exp;
branches;
next	1.107;

1.107
date	2004.02.09.23.10.53;	author netwolf1;	state Exp;
branches;
next	1.106;

1.106
date	2004.02.07.01.26.46;	author netwolf1;	state Exp;
branches;
next	1.105;

1.105
date	2004.01.30.20.33.57;	author eklmn;	state Exp;
branches;
next	1.104;

1.104
date	2004.01.29.00.25.52;	author dongato;	state Exp;
branches;
next	1.103;

1.103
date	2004.01.28.20.41.52;	author dongato;	state Exp;
branches;
next	1.102;

1.102
date	2004.01.23.13.39.07;	author dongato;	state Exp;
branches;
next	1.101;

1.101
date	2004.01.21.12.45.40;	author kuchin;	state Exp;
branches;
next	1.100;

1.100
date	2004.01.16.19.46.50;	author eklmn;	state Exp;
branches;
next	1.99;

1.99
date	2004.01.11.05.09.57;	author dongato;	state Exp;
branches;
next	1.98;

1.98
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.97;

1.97
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.96;

1.96
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.21.00.13.46;	author netwolf1;	state Exp;
branches;
next	1.94;

1.94
date	2003.12.18.21.52.47;	author dongato;	state Exp;
branches;
next	1.93;

1.93
date	2003.10.26.14.00.53;	author morevit;	state Exp;
branches;
next	1.92;

1.92
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.91;

1.91
date	2003.10.23.19.08.54;	author uid124029;	state Exp;
branches;
next	1.90;

1.90
date	2003.10.21.17.05.12;	author netwolf1;	state Exp;
branches;
next	1.89;

1.89
date	2003.10.20.13.20.05;	author morevit;	state Exp;
branches;
next	1.88;

1.88
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.87;

1.87
date	2003.10.17.10.29.07;	author morevit;	state Exp;
branches;
next	1.86;

1.86
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.85;

1.85
date	2003.10.08.12.56.35;	author morevit;	state Exp;
branches;
next	1.84;

1.84
date	2003.10.08.01.53.33;	author morevit;	state Exp;
branches;
next	1.83;

1.83
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.82;

1.82
date	2003.09.29.14.55.46;	author morevit;	state Exp;
branches;
next	1.81;

1.81
date	2003.09.22.22.25.45;	author eklmn;	state Exp;
branches;
next	1.80;

1.80
date	2003.09.22.16.42.00;	author morevit;	state Exp;
branches;
next	1.79;

1.79
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.78;

1.78
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.77;

1.77
date	2003.09.19.00.13.38;	author morevit;	state Exp;
branches;
next	1.76;

1.76
date	2003.09.17.12.30.14;	author dongato;	state Exp;
branches;
next	1.75;

1.75
date	2003.09.11.10.04.10;	author dongato;	state Exp;
branches;
next	1.74;

1.74
date	2003.09.04.14.38.16;	author dongato;	state Exp;
branches;
next	1.73;

1.73
date	2003.09.03.08.07.13;	author kuchin;	state Exp;
branches;
next	1.72;

1.72
date	2003.09.03.00.16.14;	author emoulari;	state Exp;
branches;
next	1.71;

1.71
date	2003.08.31.13.20.46;	author emoulari;	state Exp;
branches;
next	1.70;

1.70
date	2003.08.30.11.23.26;	author emoulari;	state Exp;
branches;
next	1.69;

1.69
date	2003.08.26.18.30.48;	author eklmn;	state Exp;
branches;
next	1.68;

1.68
date	2003.08.24.15.55.18;	author bond006;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	1.66;

1.66
date	2003.08.16.17.57.38;	author eklmn;	state Exp;
branches;
next	1.65;

1.65
date	2003.08.10.16.42.03;	author kuchin;	state Exp;
branches;
next	1.64;

1.64
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.63;

1.63
date	2003.08.06.11.48.26;	author syrus77;	state Exp;
branches;
next	1.62;

1.62
date	2003.07.31.15.02.19;	author puritynn666;	state Exp;
branches;
next	1.61;

1.61
date	2003.07.30.12.29.31;	author kuchin;	state Exp;
branches;
next	1.60;

1.60
date	2003.07.29.13.16.53;	author bond006;	state Exp;
branches;
next	1.59;

1.59
date	2003.07.27.19.30.08;	author forcha;	state Exp;
branches;
next	1.58;

1.58
date	2003.07.18.14.51.29;	author eklmn;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.16.22.31.26;	author syrus77;	state Exp;
branches;
next	1.56;

1.56
date	2003.07.12.17.43.55;	author syrus77;	state Exp;
branches;
next	1.55;

1.55
date	2003.07.08.05.08.11;	author eklmn;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.07.21.47.45;	author syrus77;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.21.20.52.54;	author eklmn;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.19.16.48.05;	author partyckip;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.11.18.35.45;	author eklmn;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.10.09.36.48;	author kuchin;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.09.15.14.38;	author kuchin;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.08.10.59.15;	author eklmn;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.08.07.36.58;	author partyckip;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.05.01.22.32;	author netwolf1;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.30.21.26.59;	author partyckip;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.27.04.24.12;	author partyckip;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.22.01.51.02;	author netwolf1;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.20.20.46.32;	author netwolf1;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.09.11.57.06;	author kuchin;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.04.10.05.33;	author kuchin;	state Exp;
branches;
next	1.39;

1.39
date	2003.04.07.14.53.04;	author partyckip;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.29.14.18.45;	author partyckip;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.29.12.58.57;	author partyckip;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.25.12.39.37;	author cax2;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.23.09.55.24;	author kuchin;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.22.09.32.21;	author dongato;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2003.03.21.18.55.17;	author dongato;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.20.18.09.35;	author cax2;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.19.01.02.31;	author cax2;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.14.16.24.22;	author partyckip;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.14.15.27.25;	author obaldin;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.14.10.16.00;	author cax2;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.12.16.53.03;	author cax2;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.03.22.09.51;	author moosetea;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.03.20.37.13;	author dongato;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.03.03.23.51;	author dongato;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.02.18.29.42;	author lord_kiron;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.23.12.35.46;	author obaldin;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.21.13.11.01;	author lord_kiron;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.21.12.52.00;	author lord_kiron;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.21.12.47.37;	author lord_kiron;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.21.10.38.45;	author lord_kiron;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.23.21.20;	author cax2;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.19.19.00.12;	author obaldin;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.16.22.01.51;	author lord_kiron;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.15.15.36.24;	author lord_kiron;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.12.21.24.11;	author obaldin;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.12.20.18.24;	author obaldin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.02.03.39.55;	author cax2;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2003.02.01.14.45.39;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.31.21.17.43;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.24.22.07.52;	author maverick65;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.01.24.14.07.51;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.17.00.45;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches;
next	;

1.5.2.1
date	2003.01.28.16.54.35;	author cax2;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.01.31.16.30.17;	author obaldin;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.02.02.02.36.28;	author cax2;	state Exp;
branches;
next	;

1.8.2.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.34.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.231
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "UploadQueue.h"
#include "updownclient.h"
#include "SharedFileList.h"
#include "packets.h"
#include "emule.h"
#include "KnownFile.h"
#include "ServerList.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#include "ListenSocket.h"
#endif
#include "MMServer.h"
#include <share.h>
#include <io.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MINNUMBEROFTRICKLEUPLOADS 2
#define UQ_DELAY_CORRECTION		200		//max. delay to start correction (in ms)

static uint32	g_iCounter;

VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg,UINT_PTR idEvent,DWORD dwTime);
UINT SaveSourcesThread(HANDLE lpArg);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUploadQueue::CUploadQueue() : waitinglist(100)
{
	EMULE_TRY

	m_hTimer = SetTimer(NULL, 141, 100, TimerProc);
	if (!m_hTimer)
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T(__FUNCTION__) _T(": Fatal Error, failed to create Timer"));
	m_dwDataRate = 0;
	m_dwBannedCount = 0;
	g_iCounter = 0;

//	Extended Upload stats
	m_iULSessionSuccessful = 0;
	m_iULSessionSuccessfulFullChunk = 0;
	for (int i=0; i<ETS_TERMINATOR; i++)
	{
		m_iULSessionSuccessfulPartChunk[i] = 0;
		m_iULSessionFailed[i] = 0;
	}
	m_iULSessionFailedNoDataForRemoteClient = 0;

	m_iTotalUploadTime = 0;
	m_dwSumUpDataOverheadInDeque = 0;
	m_nUpDataRateMSOverhead = 0;
	m_nUpDataRateOverhead = 0;
	m_nUpDataOverheadSourceExchange = 0;
	m_nUpDataOverheadFileRequest = 0;
	m_nUpDataOverheadOther = 0;
	m_nUpDataOverheadServer = 0;
	m_nUpDataOverheadSourceExchangePackets = 0;
	m_nUpDataOverheadFileRequestPackets = 0;
	m_nUpDataOverheadOtherPackets = 0;
	m_nUpDataOverheadServerPackets = 0;

	m_iLeftOverBandwidth = 0;

	m_guessedMaxLANBandwidth = 3000;

	m_lastGaveDataTick = ::GetTickCount();
	m_dwLastScheduledBackupTick = ::GetTickCount();

	m_pSaveThread = NULL;
//	Create event responsible for thread termination
	m_hQuitEvent = ::CreateEvent(NULL, TRUE, FALSE, NULL);
	if (m_hQuitEvent)
	{
	//	Create lower priority thread that will do the "job"
		m_pSaveThread = AfxBeginThread(SaveSourcesThread, reinterpret_cast<LPVOID>(this),
										THREAD_PRIORITY_BELOW_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(),
										CREATE_SUSPENDED);
		if (m_pSaveThread != NULL)
		{
		//	Disable self termination, because we plan to wait for thread termination
			m_pSaveThread->m_bAutoDelete = FALSE;
			m_pSaveThread->ResumeThread();
		}
		else
			AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Error creating SourcesSaveThread"));
	}
	else
	{
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Error creating SourcesSaveThread"));
	}

	m_strUploadLogFilePath.Format(_T("%supload.log"), g_App.m_pPrefs->GetAppDir());
#if 1 //code left for smooth migration, delete in v1.3
	if (GetTextFileFormat(m_strUploadLogFilePath) == tffANSI)
	{
		CString strBackupFile(m_strUploadLogFilePath);

		strBackupFile += _T(".ansi");

		_tremove(strBackupFile);
		_trename(m_strUploadLogFilePath, strBackupFile);
	}
#endif

	::InitializeCriticalSection(&m_csUploadQueueList);

	EMULE_CATCH2
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::AddClientToUploadQueue(CUpDownClient *pClient)
{
	EMULE_TRY

	CUpDownClient	*pNewSource;

// Select next client or use given client
	if (!pClient)
	{
		POSITION		toadd = 0, pos1, pos2;
		CUpDownClient	*pSource, *pLowIdClient = NULL;
		uint32			dwScore, dwBestScore = 0, dwBestLowIdScore = 0, dwCurTick = ::GetTickCount();

		for (pos1 = waitinglist.GetHeadPosition(); (pos2 = pos1) != NULL;)
		{
			pSource = waitinglist.GetNext(pos1);

		// Clear dead clients
			ASSERT(pSource->GetLastUpRequest());

		// Remove "?" from queue
			if ( (dwCurTick - pSource->GetLastUpRequest() > MAX_PURGEQUEUETIME)
				|| !g_App.m_pSharedFilesList->GetFileByID(pSource->m_reqFileHash) )
			{
				RemoveFromWaitingQueue(pos2, true);
#ifdef OLD_SOCKETS_ENABLED
				if (!pSource->m_pRequestSocket)
				{
					if (pSource->Disconnected())
						pSource = NULL;
				}
#endif //OLD_SOCKETS_ENABLED
				continue;
			}
			if ((dwScore = pSource->GetScore()) > dwBestScore)
			{
				if (!pSource->HasLowID()
#ifdef OLD_SOCKETS_ENABLED
					|| (pSource->m_pRequestSocket && pSource->m_pRequestSocket->IsConnected())
#endif //OLD_SOCKETS_ENABLED
				)
				{
				//	Client is a HighID or a currently connected to us LowID client
					dwBestScore = dwScore;
					toadd = pos2;
				}
				else if (!pSource->IsAddNextConnect())
				{
				//	Client is a LowID client that is not ready to go (not connected),
				//	compare it with the best not ready client
					if (dwScore > dwBestLowIdScore)
					{
						dwBestLowIdScore = dwScore;
						pLowIdClient = waitinglist.GetAt(pos2);
					}
				}
			}
		}
	//	The best not ready client may be better than the best ready client,
	//	so we need to check against that client
		if ((dwBestLowIdScore > dwBestScore) && (pLowIdClient != NULL))
			pLowIdClient->SetAddNextConnect(true);

		if (!toadd)
			return;

		pNewSource = waitinglist.GetAt(toadd);
		RemoveFromWaitingQueue(toadd, true);
		g_App.m_pMDlg->m_wndTransfer.UpdateUploadHeader();
	}
	else
		pNewSource = pClient;

	if (!g_App.m_pClientList->IsValidClient(pNewSource))
		return;

// Never upload to already downloading client
	if (IsDownloading(pNewSource))
		return;

// Tell the client that we are now ready to upload
#ifdef OLD_SOCKETS_ENABLED
	if (!pNewSource->IsHandshakeFinished())
	{
		pNewSource->SetUploadState(US_CONNECTING);
	//	Exceeding number of open TCP connections (TooManySockets) here
	//	by one is fine, as we don't invite to upload queue too often
		if (!pNewSource->TryToConnect(true))
			return;
	}
	else
	{
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ, 0);
		g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
		pNewSource->m_pRequestSocket->SendPacket(packet, true);
		pNewSource->SetUploadState(US_UPLOADING);
		pNewSource->SetLastGotULData();
	}
#endif //OLD_SOCKETS_ENABLED

	pNewSource->SetUpStartTime();
	pNewSource->ResetSessionUp();
	pNewSource->ResetCompressionGain();
	pNewSource->SetAddNextConnect(false);
	EnterCriticalSection(&m_csUploadQueueList);
	m_UploadingList.push_back(pNewSource);
	LeaveCriticalSection(&m_csUploadQueueList);
// clear the information about active clients, if their number in upload queue was changed
	m_activeClientsDeque.clear();
	m_activeClientsSortedVector.clear();

// Statistic
	CKnownFile	*pReqPartFile = g_App.m_pSharedFilesList->GetFileByID((uchar*)pNewSource->m_reqFileHash);

	if (pReqPartFile)
		pReqPartFile->statistic.AddAccepted();

	g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.AddClient(pNewSource);

	EMULE_CATCH
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::Process()
{
	EMULE_TRY

	ClientList CopyUploadQueueList;
	ClientList::const_iterator cIt;
	vector<uint32>::iterator vecIt;
	DWORD curTick = ::GetTickCount();
	sint32 usedBandwidthThisCall = 0;		// Keeps track of how much bandwidth we use this call
	int timeSinceLastGaveDataMs;
	int QtyLANClients = 0;					//LANCAST - number of LAN clients in current iteration

// After 49 days tick wraps around. I think this still handles it. (Yeah right! As if we wouldn't have crashed by then :))
	timeSinceLastGaveDataMs = curTick - m_lastGaveDataTick;

// Get a copy of Upload Queue for current iteration to prevent any interference during data upload
	GetCopyUploadQueueList(&CopyUploadQueueList);

//	There are timeout delays which can be up to 25 seconds (instead of 100ms)
//	As we can't return time back as well as put more data than the physical capacity,
//	we shouldn't try to keep average upload limit in this case to avoid high upload traffic
//	peaks (as it significantly influence downloading as well as other network applications)
//	So we will try to keep the limit and avoid high peaks
	if (timeSinceLastGaveDataMs > UQ_DELAY_CORRECTION)
	{
		int	iRateFor100ms = (g_App.m_pPrefs->GetMaxUpload() * 1024) / 100;
		int	iLeftCorrection = (iRateFor100ms * (timeSinceLastGaveDataMs - UQ_DELAY_CORRECTION + 100)) / 100;

	//	Adjust left over according passed time
		if (m_iLeftOverBandwidth >= 0)
		{
			m_iLeftOverBandwidth -= iLeftCorrection;
		//	Reserve 50ms data boost to be prepared for next delays
			iLeftCorrection = -(iRateFor100ms * (UQ_DELAY_CORRECTION - 150)) / 100;

			if (m_iLeftOverBandwidth < iLeftCorrection)
				m_iLeftOverBandwidth = iLeftCorrection;
		}
		else
			m_iLeftOverBandwidth += iLeftCorrection;
	//	There will be a boost later, so no need to add something to it
		if (m_iLeftOverBandwidth > 0)
			m_iLeftOverBandwidth = 0;
	//	Behave like there was a small delay to reduce peaks
		timeSinceLastGaveDataMs = UQ_DELAY_CORRECTION;
	}

// There's some saved bandwidth that we want to try to spend this round.
// curMaxULRatems keeps track of how much data we want to spend.
	sint32 realMaxULRatems = static_cast<sint32>(
		g_App.m_pPrefs->GetMaxUpload() * 1024u / 10u * static_cast<uint32>(timeSinceLastGaveDataMs) / 1000u );
	sint32 curMaxULRatems = realMaxULRatems + m_iLeftOverBandwidth;
	sint32 allowedBandwidthThisCall = min(curMaxULRatems, realMaxULRatems+MAXFRAGSIZE);

// Which active slot are we giving data each loop
	uint32 dwSlotCounter = 0;
	EnumBlockSendResult eSendResult = BSR_BUSY;

// The loop that gives the fully activated connections data.
	cIt = CopyUploadQueueList.begin();
	while ( (cIt != CopyUploadQueueList.end()) && (allowedBandwidthThisCall > usedBandwidthThisCall)
		&& (eSendResult == BSR_BUSY || eSendResult == BSR_FAILED_CLIENT_LEFT_UQ || eSendResult == BSR_FAILED_NO_REQUESTED_BLOCKS) )
	{
	// Only allow this connection to take what has not already been taken
	// by the other connections above it in the list.
		uint32 allowedThisIteration = allowedBandwidthThisCall-usedBandwidthThisCall;

	// Get the client. Note! Also updates ulpos as a side effect.
		CUpDownClient* cur_client = *cIt;

	// Give data to the upload, if it wants it. Remember how much data we have given this call.
	// The connection wont take any data if it hasn't emptied its buffer since we last gave it data (BSR_BUSY).
	// variable 'eSendResult' is updated by this method (it is a ref EnumBlockSendResult&)

	// LANCAST - Increment LanCount
		if (cur_client->IsOnLAN())
			QtyLANClients++;
		else
			usedBandwidthThisCall += cur_client->SendBlockData(allowedThisIteration, eSendResult);

	//	Count only the non-LAN clients, who are really active
	//	1) the client is transferring (BSR_BUSY)
	//	2) the client will transfer (BSR_OK or BSR_OK_WANTS_MORE_BANDWIDTH)
		if (!cur_client->IsOnLAN() &&
			(eSendResult == BSR_BUSY || eSendResult == BSR_OK || eSendResult == BSR_OK_WANTS_MORE_BANDWIDTH))
		{
			dwSlotCounter++;
		}
		cIt++;
	}

#define MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS 2540
// Trickle the unneeded uploads (just give them enough to not time out)
// These downloads are kept connected, in a ready-to-go state, just in case
// one of the fully activated uploads completes/timeouts/ends.
// As soon as there's a little bandwidth leftover, the first one of these
// uploads will go to fully activated state
	for (; cIt != CopyUploadQueueList.end(); cIt++)
	{
	// Get the client. Note! Also updates trickle_client_pos as a side effect.
		CUpDownClient* cur_client = *cIt;

		if (cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick)
		{
			// It's more than 3 seconds since this connection got any data.
			// Feed it a mercy package to prevent it from timing out.
			EnumBlockSendResult eTempSendResult;

			// LANCAST - Increment LanCount
			if (cur_client->IsOnLAN())
				QtyLANClients++;
			else
				usedBandwidthThisCall += cur_client->SendBlockData(MAXFRAGSIZE, eTempSendResult);
		}
	}

// Since we don't save bandwidth for the trickles above, we may
// have used to much bandwidth.
// We may also have used to little bandwidth this round, in that
// case it is saved to the next round.
	m_iLeftOverBandwidth = curMaxULRatems-usedBandwidthThisCall;

// We don't want to long peaks. Don't save to much bandwidth (about a second should be OK)
// Always make sure we can save enough to get a packet through
	sint32 limitSave = MAXFRAGSIZE; // max(realMaxULRatems*10, MAXFRAGSIZE+realMaxULRatems*4);
	if (m_iLeftOverBandwidth > limitSave)
		m_iLeftOverBandwidth = limitSave;

//	Save number of active clients for statistics into the list & sorted vector
	m_activeClientsDeque.push_back(dwSlotCounter);
	vecIt = m_activeClientsSortedVector.begin();
	while (vecIt != m_activeClientsSortedVector.end() && *(vecIt) < dwSlotCounter)
		vecIt++;
	m_activeClientsSortedVector.insert(vecIt, dwSlotCounter);

	if (m_activeClientsDeque.size() > 50)
	{
		uint32 dwRemovedValue = m_activeClientsDeque.front();

		m_activeClientsDeque.pop_front();
		vecIt = m_activeClientsSortedVector.begin();
		while (vecIt != m_activeClientsSortedVector.end() && *(vecIt) != dwRemovedValue)
			vecIt++;
		if (vecIt != m_activeClientsSortedVector.end())
			m_activeClientsSortedVector.erase(vecIt);
	}

//	Control the number of the clients in UL queue
	uint32 dwNumOfULClients = m_UploadingList.size();
	uint32 dwWantedNumberOfTotalUploads = dwNumOfULClients;

// Since the algorithm clears the info about active clients, if one of the client entered or leaved the upload queue. It's required to
// collect some information for new client set. Therefore the number of client will be not changed during 2 sec
	uint32 dwVectorSize = m_activeClientsSortedVector.size();
	if (dwVectorSize > 20)
	{
	//	Use a sorted vector of active clients to get median if enough data was collected
		dwWantedNumberOfTotalUploads = m_activeClientsSortedVector[(dwVectorSize >> 1)] + MINNUMBEROFTRICKLEUPLOADS;
	}

// Add or remove connections as needed. Mostly, this is controlled by the number of fully active uploads.
// note: the client addition placed after queue due to following reason:
// 1) incorrect counting of fresh added client as active
// 2) prevent an influence of the client addition on the upload process due to delay
	if (CanAcceptNewClient(dwNumOfULClients)
		&& waitinglist.GetCount() > 0
		&& dwWantedNumberOfTotalUploads > dwNumOfULClients)
	{
	//	There's not enough open uploads. Open more another one.
		AddClientToUploadQueue();
	}

// Save sent bytes for speed calculations
	if (m_averageTickList.empty() || curTick- m_averageTickList.front() >= UL_QUEUE_DATARATE_SAMPLE_TIME)
	{
		m_averageDataRateList.push_front(g_App.stat_sessionSentBytes);
		m_averageTickList.push_front(curTick);

	// Remove anything older than 40 seconds
		while (curTick-m_averageTickList.back() > 40000)
		{
			m_averageDataRateList.pop_back();
			m_averageTickList.pop_back();
		}

	//	recalculate the average speed after list update
		if (m_averageDataRateList.size() > 1)
			m_dwDataRate = static_cast<uint32>(static_cast<double>(m_averageDataRateList.front()-m_averageDataRateList.back())*1000.0 / (m_averageTickList.front()-m_averageTickList.back()));
		else
			m_dwDataRate = 0;
	}
// Save time to be able to calculate how long between each call
	m_lastGaveDataTick = curTick;

// LANCAST - If we have more than one LAN user were going to upload to them.
// note: an upload for LAN client is placed after speed measurements to prevent statistic disturbance
	if (QtyLANClients > 0)
	{
		bool clientWasReady = false;
		cIt = CopyUploadQueueList.begin();

		for (; cIt != CopyUploadQueueList.end(); cIt++)
		{
		// Get the client. Note! Also updates activeClientsListPos as a side effect.
			CUpDownClient* cur_client = *cIt;
			EnumBlockSendResult eTempSendResult = BSR_BUSY;

		// LANCAST - Just Count LAN Clients
			if (cur_client->IsOnLAN())
				cur_client->SendBlockData(m_guessedMaxLANBandwidth, eTempSendResult);

			if (eTempSendResult == BSR_OK_WANTS_MORE_BANDWIDTH)
				clientWasReady = true;
		}

		if (clientWasReady == false)
		{
			if (m_guessedMaxLANBandwidth > 3000)
				m_guessedMaxLANBandwidth -= 2000;
			else
				m_guessedMaxLANBandwidth = 1000;
		}
		else
		{
			m_guessedMaxLANBandwidth += 2000;
		}
	}

#ifdef OLD_SOCKETS_ENABLED
// enkeyDEV(th1) -L2HAC- lowid side, automatic callback phase
	if (g_App.m_pServerConnect->IsConnected() && g_App.m_pServerConnect->IsLowID())
	{
		for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
		{
			CUpDownClient* pSource = waitinglist.GetNext(pos);

			if ( pSource->IsL2HACEnabled() && pSource->GetLastL2HACExecution() && pSource->GetL2HACTime()
				 && (curTick - pSource->GetLastL2HACExecution()) > pSource->GetL2HACTime() )
			{
				if ( g_App.m_pListenSocket->TooManySockets()
					 && !(pSource->m_pRequestSocket && pSource->m_pRequestSocket->IsConnected()) )
				{
					 pSource->SetLastL2HACExecution(curTick - pSource->GetL2HACTime() + static_cast<uint32>(static_cast<double>(rand()) / RAND_MAX * 300000.0));
				}
				else
				{
					pSource->DisableL2HAC();
					if (!pSource->HasLowID() && pSource->GetL2HACTime())
						pSource->TryToConnect();
				}
			}
		}
	}
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUploadQueue::CanAcceptNewClient(uint32 dwNumOfUploads)
{
	EMULE_TRY

//	Check if we can allow a new client to start downloading from us
	if (dwNumOfUploads < MIN_UP_CLIENTS_ALLOWED)
		return true;
	else if (dwNumOfUploads >= MAX_UP_CLIENTS_ALLOWED)
		return false;

	if (dwNumOfUploads < (uint32)(g_App.m_pPrefs->GetMaxUpload()*1024/(UPLOAD_LOW_CLIENT_DR*10))+1)
		return true;

	EMULE_CATCH

//	Nope
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUploadQueue::~CUploadQueue()
{
	KillTimer(0, m_hTimer);

	if (m_pSaveThread != NULL)
	{
	//	Request thread termination
		SetEvent(m_hQuitEvent);

	//	Wait for thread termination
		if (::WaitForSingleObject(m_pSaveThread->m_hThread, 1000000) == WAIT_TIMEOUT)
		{
			TRACE("Thread known.met thread did not exited on time");
		}
	//	Delete thread object manually, because self termination was disabled
		delete m_pSaveThread;
	}

	if (m_hQuitEvent != NULL)
		::CloseHandle(m_hQuitEvent);

	::DeleteCriticalSection(&m_csUploadQueueList);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
POSITION CUploadQueue::GetWaitingClient(CUpDownClient* client)
{
	EMULE_TRY

	return waitinglist.Find(client);

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CUploadQueue::GetWaitingClientByIP_UDP(uint32 dwIP, uint16 uPort, bool *pbMultipleIPs)
{
	EMULE_TRY

	CUpDownClient	*pSrc, *pMatchingIPClient;
	unsigned		uiMatches = 0;

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
	{
		pSrc = waitinglist.GetNext(pos);
		if (dwIP == pSrc->GetIP())
		{
			if (uPort == pSrc->GetUDPPort())
				return pSrc;
			if (pbMultipleIPs != NULL)
			{
				pMatchingIPClient = pSrc;
				uiMatches++;
			}
		}
	}

	if (pbMultipleIPs != NULL)
	{
		*pbMultipleIPs = (uiMatches > 1);
	//	UDP packets reception when remote client is behind UDP portmapping router
		if (uiMatches == 1)
			return pMatchingIPClient;
	}

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::AddClientToWaitingQueue(CUpDownClient* client, bool bIgnoreTimelimit)
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
//	If we're connected to the server, and we're LOWID, and the client is on a remote server and is not downloading
//	and is not a friend and the queue is longer than 50...
	if ( g_App.m_pServerConnect->IsConnected()
		&& g_App.m_pServerConnect->IsLowID()
		&& !g_App.m_pServerConnect->IsLocalServer(client->GetServerIP(),client->GetServerPort())
		&& client->GetDownloadState() == DS_NONE
		&& !client->IsFriend()
		&& GetWaitingUserCount() > 50 )
	{
		return;
	}
#endif //OLD_SOCKETS_ENABLED

//	Filtering invalid eMule clients
	if ( client->GetMuleVersion() == 0 && client->GetVersion() == 0
		&& (client->GetClientSoft() == SO_EMULE || client->GetClientSoft() == SO_PLUS || client->GetClientSoft() == SO_OLDEMULE) )
	{
		return;
	}

//	L2HAC- lowid side
	client->SetLastL2HACExecution();
	if (!client->HasLowID() && client->GetL2HACTime()) client->EnableL2HAC();

//	LANCAST - We ignore any ban LAN clients may have
	if (!bIgnoreTimelimit && !client->IsOnLAN())
	{
		if (client->IsBanned())
		{
			if (::GetTickCount() - client->GetBanTime() > g_App.m_pPrefs->BadClientBanTime())
				client->UnBan();
			else
				return;
		}
	}

//	Try to add client to our upload queue
	POSITION			pos1, pos2;
	CUpDownClient		*pSource;
	const uint32		dwCurrentTime = ::GetTickCount();
	const uint32		dwWaitingListCount = static_cast<uint32>(waitinglist.GetCount());
	bool				bIsQueueFull = (dwWaitingListCount >= (g_App.m_pPrefs->GetQueueSize() + m_dwBannedCount));

	for (pos1 = waitinglist.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		pSource = waitinglist.GetNext(pos1);

	//	Check if client already exists
		if (pSource == client)
		{
		//	Special care is given to LowID clients which missed their upload slot
		//	due to the saving bandwidth on callbacks
			if (client->IsAddNextConnect())
			{
				uint32	dwNumOfULClients = m_UploadingList.size();

			//	One extra slot can be created to accommodate LowID users, as such users
			//	could be skipped when it was actually their turn to get an upload slot
				if ((dwNumOfULClients == 0) || CanAcceptNewClient(--dwNumOfULClients))
				{
					client->SetAddNextConnect(false);
					RemoveFromWaitingQueue(client, true);
					AddClientToUploadQueue(client);
					return;
				}
			}
			client->SendRankingInfo();
			g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(client);
			return;
		}
		else if (client->Compare(pSource) != 0) // Another client with same ip or hash
		{
			EIdentState eClientIdentState = client->m_pCredits->GetCurrentIdentState(client->GetIP());
			EIdentState eSourceIdentState = pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP());

			if (eClientIdentState == IS_IDENTIFIED)
			{
				if (eSourceIdentState != IS_IDENTIFIED)
				{
					AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("New identified client %s and client in list %s have the same userhash or IP, removed '%s'"),
									client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware(), pSource->GetUserName() );
				}
				else
				{
					AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("New identified client %s and identified client in list %s have the same Userhash or IP, removed '%s'"),
									client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware(), pSource->GetUserName());
				}
				RemoveFromWaitingQueue(pos2, true);
			}
			else	//eClientIdentState != IS_IDENTIFIED
			{
				if (eSourceIdentState == IS_IDENTIFIED)
				{
					AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("New client %s and indentified client in list %s have the same userhash or IP, don't let '%s' enter waiting queue"),
									client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware(), client->GetUserName() );
				}
				else
				{
					AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("New client %s and client in list %s have the same userhash or IP, removed both"),
									client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware() );
					RemoveFromWaitingQueue(pos2, true);
				}
				return;
			}

#ifdef OLD_SOCKETS_ENABLED
			if (pSource->m_pRequestSocket == NULL)
			{
				if (!pSource->Disconnected(false))
					delete pSource;	// get rid of the source if it wasn't deleted while disconnecting
			}
#endif //OLD_SOCKETS_ENABLED
			return;
		}

	//	If client does not exist in UL queue & the queue is full we will not be able to add new client,
	//	therefore we need to check if one of the client can be already removed from the queue due to timeout
	//	(no response from client during MAX_PURGEQUEUETIME)
		if (bIsQueueFull && (dwCurrentTime - pSource->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
		{
			RemoveFromWaitingQueue(pos2,true);
#ifdef OLD_SOCKETS_ENABLED
			if (!pSource->m_pRequestSocket)
			{
				if (pSource->Disconnected())
					pSource = NULL;
			}
#endif //OLD_SOCKETS_ENABLED
		//	Since one place now is free, set full status to false
			bIsQueueFull = false;
		}
	}

	if (client->IsDownloading())
	{
	//	He's already downloading and wants probably only another file
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ, 0);
		g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		client->m_pRequestSocket->SendPacket(packet,true);
#endif //OLD_SOCKETS_ENABLED
		client->SetLastGotULData();
		return;
	}

//	If queue is not full we can add a client
	if (!bIsQueueFull)
	{
	//	In order to have proper wait time it's needed to set time here for the case
	//	when client will be added directly to the UL-queue
		client->SetWaitStartTime();

	//	Bypass the queue (to avoid sending unrequired Queue Ranking to save traffic)
	//	- for LanCast users 
	//	- when upload queue has less than minimal number of users
		if (client->IsOnLAN() ||
			(waitinglist.IsEmpty() && !client->IsBanned() && (m_UploadingList.size() < MIN_UP_CLIENTS_ALLOWED)))
		{
			AddClientToUploadQueue(client);
		}
		else
		{
			client->SetUploadState(US_ONUPLOADQUEUE);
			waitinglist.AddTail(client);
			client->SendRankingInfo();
			g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.AddClient(client);
			g_App.m_pMDlg->m_wndTransfer.UpdateUploadHeader();
		}
	}

	EMULE_CATCH
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUploadQueue::RemoveFromUploadQueue(CUpDownClient* client, EnumEndTransferSession eReason, bool updatewindow )
{
	if (client == NULL)
		return false;

	EMULE_TRY

	EnterCriticalSection(&m_csUploadQueueList);
	uint32 dwPrevClientsNum = m_UploadingList.size();
	m_UploadingList.remove(client);
	bool bClientRemoved = (dwPrevClientsNum != m_UploadingList.size());
	LeaveCriticalSection(&m_csUploadQueueList);

	if (bClientRemoved)
	{
		client->SetAddNextConnect(false);
	// clear the information about active clients, if their number in upload queue was changed
		m_activeClientsDeque.clear();
		m_activeClientsSortedVector.clear();

		if (updatewindow)
			g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.RemoveClient(client);

	// Update stats: if client got some bytes from us the session will be succesfull, otherwise failed
		if (client->GetTransferredUp())
		{
			m_iULSessionSuccessful++;

			if (client->GetTransferredUp() >= PARTSZ32)
				m_iULSessionSuccessfulFullChunk++;
			else
				m_iULSessionSuccessfulPartChunk[eReason]++;
		//	As we transfer something we need to update a upload time
			m_iTotalUploadTime += client->GetUpStartTimeDelay() / 1000;
		}
		else
		{
			if (client->IsThereDataForRemoteClient())
				m_iULSessionFailed[eReason]++;
			else
			{
				m_iULSessionFailedNoDataForRemoteClient++;
				AddLogLine(LOG_FL_DBG, _T("%u Failed upload session with the client %s"), m_iULSessionFailedNoDataForRemoteClient, client->GetClientNameWithSoftware());
			}
		}

		if (g_App.m_pPrefs->LogUploadToFile())
		{
			FILE	*pLogFile = _tfsopen(m_strUploadLogFilePath, _T("ab"), _SH_DENYWR);

			if (pLogFile != NULL)
			{
				COleDateTime	currentTime(COleDateTime::GetCurrentTime());
				CString			strLogLine;
				CKnownFile		*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(client->m_reqFileHash);

				if (pKnownFile == NULL)
					pKnownFile = g_App.m_pKnownFilesList->FindKnownFileByID(client->m_reqFileHash);

				strLogLine.Format( _T("%s,\"%s\",%s,%s,\"%s\",%u,%u,%u,%s,%s,%s,%s,%s\r\n"),
									currentTime.Format(_T("%c")),
									client->GetUserName(),
									HashToString(client->GetUserHash()),
									client->GetFullSoftVersionString(),
									(pKnownFile) ? pKnownFile->GetFileName() : _T(""),
									client->GetSessionUp(),
									client->GetCurrentlyUploadingPart(),
									(client->GetUpStartTimeDelay()/1000),
									YesNoStr(client->IsFriend()),
									YesNoStr(client->IsCommunity()),
									YesNoStr(client->IsOnLAN()),
									YesNoStr(client->HasLowID()),
									(client->GetSessionUp() >= PARTSZ32) ?
									GetResString(IDS_IDENTOK).MakeLower() :
									g_App.m_pMDlg->m_dlgStatistics.GetUpEndReason(eReason) );
#ifdef _UNICODE
			//	Write the Unicode BOM in the beginning if file was created
				if (_filelength(_fileno(pLogFile)) == 0)
					fputwc(0xFEFF, pLogFile);
#endif
				_fputts(strLogLine, pLogFile);
				fclose(pLogFile);
			}
		}

		client->SetUploadState(US_NONE);
	//	Flush sent blocks -- when you stop upload or the socket won't be able to send
		client->FlushSendBlocks();
		client->ClearUploadBlockRequests();

		return true;
	}

	EMULE_CATCH

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUploadQueue::GetAverageUpTime()
{
	if (m_iULSessionSuccessful)
	{
		return m_iTotalUploadTime/m_iULSessionSuccessful;
	}
	return 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUploadQueue::RemoveFromWaitingQueue(CUpDownClient* client, bool updatewindow)
{
	EMULE_TRY

	POSITION pos = waitinglist.Find(client);
	if (pos)
	{
		RemoveFromWaitingQueue(pos, updatewindow);

		if (updatewindow)
			g_App.m_pMDlg->m_wndTransfer.UpdateUploadHeader();
		client->SetAddNextConnect(false);

		return true;
	}

	EMULE_CATCH

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::RemoveFromWaitingQueue(POSITION pos, bool updatewindow)
{
	EMULE_TRY

	CUpDownClient* todelete = waitinglist.GetAt(pos);
	waitinglist.RemoveAt(pos);

	if (todelete == NULL)
		return;

	if (todelete->IsBanned())
		todelete->UnBan();

	if (updatewindow)
		g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.RemoveClient(todelete);

	todelete->SetUploadState(US_NONE);

	EMULE_CATCH
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::DeleteAll()
{
	EMULE_TRY

	waitinglist.RemoveAll();
	m_UploadingList.clear();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint16 CUploadQueue::GetWaitingPosition(CUpDownClient *client)
{
	EMULE_TRY

	if (!IsOnUploadQueue(client))
		return 0;

	unsigned	uiRank = 1;

	if (client->IsBanned())
	{
		uiRank = waitinglist.GetCount();
	}
	else
	{
		uint32 dwClientScore = client->GetScore();

		for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
		{
			if (waitinglist.GetNext(pos)->GetScore() > dwClientScore)
				uiRank++;
		}
	}
	return static_cast<uint16>(uiRank);

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::CompUpDataRateOverhead()
{
	EMULE_TRY

//	update the deque & sum
	m_UpDataOverheadDeque.push_back(m_nUpDataRateMSOverhead);
	m_dwSumUpDataOverheadInDeque += m_nUpDataRateMSOverhead;

//	reset the value
	m_nUpDataRateMSOverhead = 0;

//	check deque length
	while (m_UpDataOverheadDeque.size() > 150)
	{
		m_dwSumUpDataOverheadInDeque -= m_UpDataOverheadDeque.front();
		m_UpDataOverheadDeque.pop_front();
	}

//	calculate average value
	if (m_UpDataOverheadDeque.size() > 10)
		m_nUpDataRateOverhead = 10*m_dwSumUpDataOverheadInDeque/m_UpDataOverheadDeque.size();
	else
		m_nUpDataRateOverhead = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	NOPRM(hwnd); NOPRM(uMsg); NOPRM(idEvent); NOPRM(dwTime);
	EMULE_TRY

//	Don't do anything if the app is shutting down - can cause unhandled exceptions
	if (!g_App.m_pMDlg->IsRunning())
		return;

	g_App.m_pUploadQueue->Process();
	g_App.m_pDownloadQueue->Process();
	g_App.m_pUploadQueue->CompUpDataRateOverhead();
	g_App.m_pDownloadQueue->CompDownDataRateOverhead();

	g_iCounter++;

//	Every second (be aware that every divisor of g_iCounter-modulo has to be a multiple of 10 inside)
	if (g_iCounter % 10 == 0)
	{
#ifdef OLD_SOCKETS_ENABLED
		if (g_App.m_pServerConnect->IsConnecting())
		{
			g_App.m_pServerConnect->TryAnotherConnectionRequest();
		}
#endif

		if (g_App.m_pPrefs->IsWatchClipboard4ED2KLinks())
		{
			g_App.m_pMDlg->m_dlgSearch.SearchClipBoard();
		}

		g_App.m_pMDlg->m_dlgStatistics.UpdateConnectionsStatus();

	//	Every 2 seconds
		if ((g_iCounter & 3) == 0)
		{
#ifdef OLD_SOCKETS_ENABLED
			if (g_App.m_pServerConnect->IsConnecting())
				g_App.m_pServerConnect->CheckForTimeout();
#endif

			g_App.m_pMDlg->m_dlgStatistics.UpdateConnectionStats((double)g_App.m_pUploadQueue->GetDataRate()/1024.0, static_cast<double>(g_App.m_pDownloadQueue->GetDataRate())/1024.0);
		}

	//	Display graphs
		if (g_App.m_pPrefs->GetTrafficOMeterInterval() > 0)
		{
			if (g_iCounter % ((uint32)g_App.m_pPrefs->GetTrafficOMeterInterval() * 10) == 0)
			{
				g_App.m_pMDlg->m_dlgStatistics.SetCurrentRate(g_App.m_pUploadQueue->GetDataRate(), g_App.m_pDownloadQueue->GetDataRate());
			}
		}

	//	Display stats
		if (g_App.m_pMDlg->m_pdlgActive == &g_App.m_pMDlg->m_dlgStatistics && g_App.m_pMDlg->IsWindowVisible())
		{
			if ( (g_App.m_pPrefs->GetStatsInterval() != 0) &&
				(g_iCounter % ((uint32)g_App.m_pPrefs->GetStatsInterval() * 10) == 0) )
			{
				g_App.m_pMDlg->m_dlgStatistics.ShowStatistics();
			}
		}

	//	Save rates every second
		g_App.m_pMDlg->m_dlgStatistics.RecordRate();

#ifdef OLD_SOCKETS_ENABLED
	//	Mobilemule sockets
		g_App.m_pMMServer->Process();
#endif

	//	Every 5 seconds
		if (g_iCounter % 50 == 0)
		{
#ifdef _DEBUG
			if (!AfxCheckMemory())
				g_App.AddLogLine(LOG_FL_EMBEDFMT, RGB_PINK_TXT _T("** ") RGB_LOG_ERROR_TXT _T("Memory corruption detected") RGB_PINK_TXT _T(" **"));
#endif

#ifdef OLD_SOCKETS_ENABLED
			g_App.m_pListenSocket->Process();
#endif
			g_App.m_pSharedFilesList->Process();	// files publishing

			g_App.OnlineSig();
			g_App.m_pMDlg->ShowTransferRate();

		//	Every 90 seconds
			if (g_iCounter % 900 == 0)
			{
			//	Auto Sources per File
				if (g_App.m_pPrefs->IsAutoSourcesEnabled())
				{
					g_App.m_pDownloadQueue->SetAutoSourcesPerFile();
				}
			//	Save emfriends.met (internal 25 minute interval)
				g_App.m_pFriendList->Process();
			}

		//	Every minute
			if (g_iCounter % 600 == 0)
			{
			//	Every 5 minutes
				if (g_iCounter % 3000 == 0)
				{
				//	This function does NOT update the tree!
					g_App.m_pPrefs->SaveIniPreferences();
				}

			//	Server keepalive
				g_App.m_pServerConnect->KeepConnectionAlive();

			//	Save clients.met (internal 18 minute interval)
				g_App.m_pClientCreditList->Process();

			//	Save server.met (internal 17 minute interval)
				g_App.m_pServerList->Process();

			//	Scheduled Backup
				if (g_App.m_pPrefs->IsScheduledBackup() && g_App.m_pPrefs->GetScheduledBackupInterval() != 0)
				{
					if (::GetTickCount() > (g_App.m_pUploadQueue->m_dwLastScheduledBackupTick) + g_App.m_pPrefs->GetScheduledBackupInterval() * 3600000)
					{
						g_App.m_pMDlg->RunBackupNow(true);
						g_App.m_pUploadQueue->m_dwLastScheduledBackupTick = ::GetTickCount();
						CLoggable::AddLogLine(LOG_FL_DBG, _T("Scheduled backup performed"));
					}
				}

			//	Scheduler Shift check
				if (g_App.m_pPrefs->IsSCHEnabled())
				{
					CTime curr_t = CTime::GetCurrentTime();
					uint32 secs = curr_t.GetSecond() + 60*curr_t.GetMinute() + 60*60*curr_t.GetHour();

				//	We shouldn't subtract 60 seconds because data type is unsigned
					if (secs+60 > g_App.m_pPrefs->GetSCHShift1() && secs < g_App.m_pPrefs->GetSCHShift1()+60)
					{
					//	Switching to shift1 speeds
						g_App.m_pUploadQueue->SCHShift1UploadCheck();
						g_App.m_pPrefs->SetMaxUpload(g_App.m_pPrefs->GetSCHShift1Upload());
						g_App.m_pPrefs->SetMaxDownload(g_App.m_pPrefs->GetSCHShift1Download());
						g_App.m_pPrefs->SetMaxConnections(g_App.m_pPrefs->GetSCHShift1conn());
						g_App.m_pPrefs->SetMaxDownloadConperFive(g_App.m_pPrefs->GetSCHShift15sec());
					//	Sending message for scheduler shift 1
						CString MessageText;
						MessageText.Format( _T("SCHEDULER: switching to Shift 1 (Max Upload:%.1f Max Download:%.1f Max Connections:%i Max In 5 secs:%i)"),
											static_cast<double>(g_App.m_pPrefs->GetSCHShift1Upload()) / 10.0,
											static_cast<double>(g_App.m_pPrefs->GetSCHShift1Download()) / 10.0,
											g_App.m_pPrefs->GetSCHShift1conn(),
											g_App.m_pPrefs->GetSCHShift15sec() );
						g_App.m_pMDlg->SendMail(MessageText, g_App.m_pPrefs->GetUseSchedulerNotifier(), g_App.m_pPrefs->IsSMTPInfoEnabled());
						g_App.m_pMDlg->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_App.m_pPrefs->GetUseSchedulerNotifier());
						CLoggable::AddLogLine(LOG_FL_DBG, MessageText);
					}
				//	We shouldn't subtract 60 seconds because data type is unsigned
					else if (secs+60 > g_App.m_pPrefs->GetSCHShift2() && secs < g_App.m_pPrefs->GetSCHShift2()+60)
					{
						int dayOfWeek = curr_t.GetDayOfWeek();
						if ( (dayOfWeek==2 && g_App.m_pPrefs->IsSCHExceptMon())
							|| (dayOfWeek==3 && g_App.m_pPrefs->IsSCHExceptTue())
							|| (dayOfWeek==4 && g_App.m_pPrefs->IsSCHExceptWed())
							|| (dayOfWeek==5 && g_App.m_pPrefs->IsSCHExceptThu())
							|| (dayOfWeek==6 && g_App.m_pPrefs->IsSCHExceptFri())
							|| (dayOfWeek==7 && g_App.m_pPrefs->IsSCHExceptSat())
							|| (dayOfWeek==1 && g_App.m_pPrefs->IsSCHExceptSun()) )
						{
							CLoggable::AddLogLine(LOG_FL_DBG, _T("SCHEDULER: day excepted!"));
						}
						else
						{
						//	Switching to shift2 speeds
							g_App.m_pUploadQueue->SCHShift2UploadCheck();
							g_App.m_pPrefs->SetMaxUpload(g_App.m_pPrefs->GetSCHShift2Upload());
							g_App.m_pPrefs->SetMaxDownload(g_App.m_pPrefs->GetSCHShift2Download());
							g_App.m_pPrefs->SetMaxConnections(g_App.m_pPrefs->GetSCHShift2conn());
							g_App.m_pPrefs->SetMaxDownloadConperFive(g_App.m_pPrefs->GetSCHShift25sec());
						//	Sending message for scheduler shift 2
							CString MessageText;
							MessageText.Format( _T("SCHEDULER: switching to Shift 2 (Max Upload:%.1f Max Download:%.1f Max Connections:%i Max In 5 secs:%i)"),
												static_cast<double>(g_App.m_pPrefs->GetSCHShift2Upload()) / 10.0,
												static_cast<double>(g_App.m_pPrefs->GetSCHShift2Download()) / 10.0,
												g_App.m_pPrefs->GetSCHShift2conn(),
												g_App.m_pPrefs->GetSCHShift25sec() );
							g_App.m_pMDlg->SendMail(MessageText, g_App.m_pPrefs->GetUseSchedulerNotifier(), g_App.m_pPrefs->IsSMTPInfoEnabled());
							g_App.m_pMDlg->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_App.m_pPrefs->GetUseSchedulerNotifier());
							CLoggable::AddLogLine(LOG_FL_DBG, MessageText);
						}
					}
				}
			}
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, const uchar* filehash)
{
	EMULE_TRY

	for (ClientList::const_iterator cIt = m_UploadingList.begin(); cIt != m_UploadingList.end(); cIt++)
	{
		CUpDownClient	*pPotentialSource = *cIt;

		if (md4cmp(pPotentialSource->m_reqFileHash, filehash) == 0)
			srclist->AddTail(pPotentialSource);
	}

	POSITION pos = waitinglist.GetHeadPosition();

	while (pos)
	{
		CUpDownClient	   *pPotentialSource = waitinglist.GetNext(pos);

		if (md4cmp(pPotentialSource->m_reqFileHash, filehash) == 0)
			srclist->AddTail(pPotentialSource);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetUploadFilePartsAvailability() returns availability of file parts reported by downloaders
//		Params:
//			pdwStatuses   - array to be filled (must be zero initialized by caller);
//			dwPartCnt     - number of file parts (array size);
//			pbyteFileHash - file hash to process.
void CUploadQueue::GetUploadFilePartsAvailability(uint32 *pdwStatuses, uint32 dwPartCnt, const byte *pbyteFileHash)
{
	EMULE_TRY

	CTypedPtrList<CPtrList, CUpDownClient*> srclist;
	CUpDownClient	*pClient;
	const byte		*pbyteUpStatus;

	FindSourcesForFileById(&srclist, pbyteFileHash);

	for (POSITION pos = srclist.GetHeadPosition(); pos != NULL;)
	{
		pClient = srclist.GetNext(pos);
		if ( (pClient->GetAvailUpPartCount() != 0) &&
			((pbyteUpStatus = pClient->GetUpPartStatus()) != NULL) &&
			(pClient->GetUpPartCount() == dwPartCnt) )
		{
			for (uint32 i = 0; i < dwPartCnt; i++)
				pdwStatuses[i] += pbyteUpStatus[i];
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
UINT SaveSourcesThread(HANDLE lpArg)
{
#ifdef EP_SPIDERWEB
//	Setup Structured Exception handler for the this thread
	_set_se_translator(StructuredExceptionHandler);
#endif

	g_App.m_pPrefs->InitThreadLocale();

	HANDLE	hTermEv = (reinterpret_cast<CUploadQueue*>(lpArg))->m_hQuitEvent;

//	Do the work every 30 minutes or quit by terminating event
	while (::WaitForSingleObject(hTermEv, 30*60*1000) == WAIT_TIMEOUT)
	{
	//	Check to avoid rare crash on exit as m_pKnownFilesList is deleted before m_pUploadQueue
		if (g_App.m_pKnownFilesList == NULL)
			break;
	//	Save the information to the drive
		g_App.m_pKnownFilesList->Save();
	}

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::SCHShift1UploadCheck()
{
	if (g_App.m_pPrefs->GetSCHShift1Upload() != 0)
	{
		g_App.m_pPrefs->SetSCHShift1Download(TieUploadDownload(g_App.m_pPrefs->GetSCHShift1Upload(), g_App.m_pPrefs->GetSCHShift1Download()));
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::SCHShift2UploadCheck()
{
	if (g_App.m_pPrefs->GetSCHShift2Upload() != 0)
	{
		g_App.m_pPrefs->SetSCHShift2Download(TieUploadDownload(g_App.m_pPrefs->GetSCHShift2Upload(), g_App.m_pPrefs->GetSCHShift2Download()));
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
POSITION CUploadQueue::GetHeadPosition(void)
{
	return waitinglist.GetHeadPosition();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CUploadQueue::GetNext(POSITION& pos)
{
	return waitinglist.GetNext(pos);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUploadQueue::IsDownloading(CUpDownClient* pClient)
{
	for (ClientList::const_iterator cIt = m_UploadingList.begin(); cIt != m_UploadingList.end(); cIt++)
	{
		if (pClient == *cIt)
			return true;
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create a copy of Upload Queue for current iteration to prevent any interference during data upload
void CUploadQueue::GetCopyUploadQueueList(ClientList *pCopy)
{
	EnterCriticalSection(&m_csUploadQueueList);

	pCopy->insert(pCopy->begin(), m_UploadingList.begin(), m_UploadingList.end());

	LeaveCriticalSection(&m_csUploadQueueList);
}
@


1.230
log
@Fixed UDP packets reception when remote client is behind UDP portmapping router (from original).
@
text
@d27 1
@


1.229
log
@Encryption preparations.
@
text
@d579 1
a579 1
			else if (pbMultipleIPs != NULL)
d590 1
@


1.228
log
@Save the whole preferences.ini periodically (not only statistics values) {muleteer};
Removed some unused H-files.
@
text
@d2 1
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
a46 2
//	TODO rewrite the whole networkcode, use overlapped sockets

d565 1
a565 1
CUpDownClient* CUploadQueue::GetWaitingClientByIPAndUDPPort(uint32 dwIP, uint16 dwPort)
d569 3
d574 12
a585 1
		CUpDownClient* pSource = waitinglist.GetNext(pos);
d587 5
a591 2
		if (dwIP == pSource->GetIP() && dwPort == pSource->GetUDPPort())
			return pSource;
@


1.227
log
@Reduced H-file dependency.
@
text
@a28 2
#include "ini2.h"
#include "math.h"
d1084 1
a1084 1
					g_App.m_pPrefs->SaveStats();
@


1.226
log
@Simplified logging system implementation.
@
text
@d25 1
@


1.225
log
@Reduced H-file dependency.
@
text
@d57 1
a57 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T(__FUNCTION__) _T(": Fatal Error, failed to create Timer"));
d108 1
a108 1
			AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Error creating SourcesSaveThread"));
d112 1
a112 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Error creating SourcesSaveThread"));
d669 1
a669 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("New identified client %s and client in list %s have the same userhash or IP, removed '%s'"),
d674 1
a674 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("New identified client %s and identified client in list %s have the same Userhash or IP, removed '%s'"),
d683 1
a683 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("New client %s and indentified client in list %s have the same userhash or IP, don't let '%s' enter waiting queue"),
d688 1
a688 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("New client %s and client in list %s have the same userhash or IP, removed both"),
d805 1
a805 1
				AddDebugLogLine(_T("%u Failed upload session with the client %s"), m_iULSessionFailedNoDataForRemoteClient, client->GetClientNameWithSoftware());
d1055 1
a1055 1
				g_App.AddLogLine(false, RGB_PINK_TXT _T("** ") RGB_LOG_ERROR_TXT _T("Memory corruption detected") RGB_PINK_TXT _T(" **"));
d1104 1
a1104 1
						CLoggable::AddDebugLogLine(_T("Scheduled backup performed"));
d1132 1
a1132 1
						CLoggable::AddDebugLogLine(MessageText);
d1146 1
a1146 1
							CLoggable::AddDebugLogLine(_T("SCHEDULER: day excepted!"));
d1165 1
a1165 1
							CLoggable::AddDebugLogLine(MessageText);
@


1.224
log
@Reduced H-file dependency.
@
text
@d21 1
d55 1
a55 1
	m_hTimer = SetTimer(NULL,141,100,TimerProc);	// KuSh: in msdn : "If the hWnd parameter is NULL, this parameter is ignored", so 141 is unused
@


1.223
log
@Fixed ANSI logs backup on first Unicode startup.
@
text
@d20 1
d23 1
a23 1
#include "knownfile.h"
@


1.222
log
@call the statistic update directly
@
text
@d119 1
a119 1
		m_strUploadLogFilePath += _T(".ansi");
@


1.221
log
@changed the intialization of thread locale
@
text
@d1036 1
a1036 1
				g_App.m_pMDlg->ShowStatistics();
@


1.220
log
@Proper share mode for open files (before other applications could write to a file while we were reading);
Suppressed compiler warnings; Preparations for comprehensive exception handling.
@
text
@d1236 2
@


1.219
log
@fixed paste & copy errors (thanks to KuSh)
@
text
@d25 1
a25 1
#endif //OLD_SOCKETS_ENABLED
d29 1
d347 1
a347 1
// Theese downloads are kept connected, in a ready-to-go state, just in case
d809 1
a809 1
			FILE	*pLogFile = _tfopen(m_strUploadLogFilePath, _T("ab"));
d927 1
a927 1
	uint16 uRank = 1;
d931 1
a931 1
		uRank = waitinglist.GetCount();
d940 1
a940 1
				uRank++;
d943 1
a943 1
	return uRank;
d979 1
d1231 5
@


1.218
log
@correction after review
@
text
@d121 1
a121 1
		_trename(m_strUploadLogFilePath, m_strUploadLogFilePath + _T(".ansi"));
@


1.217
log
@added unicode support for log files (emule, debug, upload, download, status, backup)
@
text
@d113 1
d116 3
a118 1
		CString strBackupFile = m_strUploadLogFilePath + _T(".ansi");
d123 1
d833 2
a834 2
										GetResString(IDS_IDENTOK).MakeLower() :
										g_App.m_pMDlg->m_dlgStatistics.GetUpEndReason(eReason) );
d836 1
a836 1
			//	Write the Unicode BOM at the begining if file was created
@


1.216
log
@Loop optimization by cached returned value.
@
text
@d29 1
d113 7
d804 1
a804 1
			FILE	*pLogFile = _tfopen(m_strUploadLogFilePath, _T("at"));
d815 1
a815 1
				strLogLine.Format( _T("%s,\"%s\",%s,%s,\"%s\",%u,%u,%u,%s,%s,%s,%s,%s\n"),
d831 5
@


1.215
log
@Removed macro ROUND() -- not really required here.
@
text
@d1191 1
d1199 2
a1200 1
			(pClient->m_pbyteUpPartStatuses != NULL) && (pClient->GetUpPartCount() == dwPartCnt) )
d1203 1
a1203 1
				pdwStatuses[i] += pClient->m_pbyteUpPartStatuses[i];
@


1.214
log
@fix time disappearing at midnight
@
text
@d483 1
a483 1
					 pSource->SetLastL2HACExecution(curTick - pSource->GetL2HACTime() + static_cast<uint32>(ROUND((static_cast<double>(rand())/RAND_MAX)*300000.0)));
@


1.213
log
@Removed limitation of the uploading by the score;
Don't calculate score for downloading sources;
Removed unused class members;
Removed unrequired preferences parameter.
@
text
@d808 1
a808 1
									currentTime.Format(),
@


1.212
log
@Make sure that a dropped source is always deleted after identification collision (before in some cases it could stay in the Known Clients List forever).
@
text
@d18 1
a18 1
#include "StdAfx.h"
d47 1
a47 1
CUploadQueue::CUploadQueue(CPreferences* in_prefs) : waitinglist(100)
a50 1
	m_pAppPrefs = in_prefs;
a53 1
	m_iEstMaxDataRate = 2000;
a82 1
	m_guessedMaxBandwidth = 300;
d152 1
a152 1
			if ((dwScore = pSource->GetScore(false)) > dwBestScore)
a891 17
bool CUploadQueue::CheckForTimeOver(CUpDownClient* client)
{
	EMULE_TRY

	uint32 score = client->GetScore(true);

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
	{
		if (score < waitinglist.GetNext(pos)->GetScore(false))
			return true;
	}

	EMULE_CATCH

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d902 1
a902 1
uint16 CUploadQueue::GetWaitingPosition(CUpDownClient* client)
d917 1
a917 1
		uint32 dwClientScore = client->GetScore(false);
d919 1
a919 1
		for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
d921 1
a921 1
			if (waitinglist.GetNext(pos)->GetScore(false) > dwClientScore)
a964 1
	{
a965 1
	}
d999 1
a999 1
			g_App.m_pMDlg->m_dlgStatistics.UpdateConnectionStats((double)g_App.m_pUploadQueue->GetDataRate()/1024, static_cast<double>(g_App.m_pDownloadQueue->GetDataRate())/1024.0);
d1005 1
a1005 1
			if (g_iCounter % ((uint32)(g_App.m_pPrefs->GetTrafficOMeterInterval()) * 10) == 0)
d1014 2
a1015 1
			if (g_App.m_pPrefs->GetStatsInterval() > 0)
d1017 1
a1017 4
				if (g_iCounter % ((uint32)(g_App.m_pPrefs->GetStatsInterval()) * 10) == 0)
				{
					g_App.m_pMDlg->ShowStatistics();
				}
@


1.211
log
@Fixed ability to keep connection after cancel transfer reception.
@
text
@d686 2
a687 2
				if (pSource->Disconnected())
					pSource = NULL;
@


1.210
log
@Comments.
@
text
@d671 1
a671 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("New client %s and indentified  client in list %s have the same userhash or IP, don't let '%s' enter waiting queue"),
d832 2
@


1.209
log
@protect the waiting time with SUI
@
text
@d405 2
a406 2
// note: the client addition placed anfer queue due to following reason:
// 1) incorrect counting of fresh added client client as active
d726 2
a727 2
	//	In order to have proper wait time it's need to set the time here for the case when client will be
	//	added direct to UL-queue
@


1.208
log
@Modified constructors to avoid potential compiling issue due to type collision.
@
text
@d607 1
a607 1
			if (GetTickCount() - client->GetBanTime() > g_App.m_pPrefs->BadClientBanTime())
d726 4
d740 1
a741 2
			client->SetWaitStartTime();
			client->SetUploadState(US_ONUPLOADQUEUE);
@


1.207
log
@corrected text in debug lines...
@
text
@d213 1
a213 1
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
d714 1
a714 1
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
@


1.206
log
@Lost merge for 'Faster plot statistics processing for WebServer and MobileMule' (thanks KuSh).
@
text
@d657 1
a657 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s and %s have the same userhash or IP, removed '%s'"),
d662 1
a662 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Identified client %s and %s have the same Userhash or IP, removed '%s'"),
d671 1
a671 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s and %s have the same userhash or IP, don't let '%s' enter waiting queue"),
d676 1
a676 1
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s and %s have the same userhash or IP, removed both"),
@


1.205
log
@Minor improvement.
@
text
@d1024 1
a1024 1
				g_App.m_pMDlg->m_dlgStatistics.SetCurrentRate((static_cast<double>(g_App.m_pUploadQueue->GetDataRate()))/1024.0,((double)g_App.m_pDownloadQueue->GetDataRate())/1024);
@


1.204
log
@Faster insertion to uploading (bypassing upload queue) when queue is empty (slightly reduced traffic);
Fixed insertion to uploading -- too many socket connections blocked some even already connected sources.
@
text
@d780 2
a793 4
	// If we transfer something we need to update a upload time
		if (client->GetTransferredUp())
			m_iTotalUploadTime += client->GetUpStartTimeDelay() / 1000;

@


1.203
log
@send the packets only if handshaking is finished to prevent a connection drop
@
text
@d121 1
a121 1
void CUploadQueue::AddClientToUploadQueue(CUpDownClient* pClient)
d124 1
a124 4
#ifdef OLD_SOCKETS_ENABLED
	if (g_App.m_pListenSocket->TooManySockets())
		return;
#endif //OLD_SOCKETS_ENABLED
a194 1
	{
a195 1
	}
d206 2
d215 1
a215 1
		pNewSource->m_pRequestSocket->SendPacket(packet,true);
d621 1
a621 1
	for (pos1 = waitinglist.GetHeadPosition(); (pos2 = pos1) != NULL; )
a702 1
				{
a703 1
				}
d726 6
a731 2
	//	LANCAST - Lan users bypass the queue
		if (client->IsOnLAN())
d733 1
@


1.202
log
@Fixed an issue with Scheduller code
@
text
@d208 1
a208 1
	if (!pNewSource->m_pRequestSocket || !pNewSource->m_pRequestSocket->IsConnected())
@


1.201
log
@Large file size support preparations.
@
text
@d1114 2
a1115 1
					if (secs > g_App.m_pPrefs->GetSCHShift1()-60 && secs < g_App.m_pPrefs->GetSCHShift1()+60)
d1134 2
a1135 1
					else if (secs > g_App.m_pPrefs->GetSCHShift2()-60 && secs < g_App.m_pPrefs->GetSCHShift2()+60)
@


1.200
log
@Improved string processing.
@
text
@d776 1
a776 1
			if (client->GetTransferredUp() >= PARTSIZE)
d822 1
a822 1
									(client->GetSessionUp() >= PARTSIZE) ?
@


1.199
log
@Minor optimization;
Increased granularity to check for server connection timeout -- check every 2 secs
instead of every second (no need to be so precise here).
@
text
@d1055 1
a1055 3
			{
				g_App.AddLogLine(false, RGB_PINK + _T("** ") + RGB_LOG_ERROR + _T("Memory corruption detected") + RGB_PINK + _T(" **"));
			}
@


1.198
log
@new email notifier code (adapted from original) - fully UNICODE ready;
option to send email notification messages in subject
@
text
@d1010 3
d1014 2
a1015 4
		if (g_App.m_pServerConnect->IsConnecting())
		{
			g_App.m_pServerConnect->CheckForTimeout();
		}
a1017 3
	//	Every 2 seconds
		if (g_iCounter % 20 == 0)
		{
@


1.197
log
@UNICODE preparation (first shot)
@
text
@a27 1
#include "Smtp.h"
d69 1
a69 1
	
d411 1
a411 1
	if (CanAcceptNewClient(dwNumOfULClients) 
d441 1
a441 1
// LANCAST - If we have more than one LAN user were going to upload to them. 
d627 1
a627 1
 
d767 1
a767 1
	
d822 2
a823 2
									(client->GetSessionUp() >= PARTSIZE) ? 
										GetResString(IDS_IDENTOK).MakeLower() : 
d1133 1
a1133 1
						g_App.m_pSMTPConnection->SendMail(MessageText, g_App.m_pPrefs->GetUseSchedulerNotifier(), g_App.m_pPrefs->IsSMTPInfoEnabled());
d1165 1
a1165 1
							g_App.m_pSMTPConnection->SendMail(MessageText, g_App.m_pPrefs->GetUseSchedulerNotifier(), g_App.m_pPrefs->IsSMTPInfoEnabled());
@


1.196
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d799 1
a799 1
			FILE *LogFile = _tfopen(m_strUploadLogFilePath, "a");
d801 1
a801 1
			if (LogFile != NULL)
d805 1
a805 1
				CKnownFile		*pKnownFile = g_App.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
d808 1
a808 1
					pKnownFile = g_App.m_pKnownFilesList->FindKnownFileByID((uchar*)client->m_reqFileHash);
d826 2
a827 2
				_fputts(strLogLine, LogFile);
				fclose(LogFile);
@


1.195
log
@renamed 3 variables
@
text
@d99 1
a99 1
										THREAD_PRIORITY_BELOW_NORMAL + g_App.g_pPrefs->GetMainProcessPriority(),
d115 1
a115 1
	m_strUploadLogFilePath.Format(_T("%supload.log"), g_App.g_pPrefs->GetAppDir());
d273 1
a273 1
		int	iRateFor100ms = (g_App.g_pPrefs->GetMaxUpload() * 1024) / 100;
d298 1
a298 1
		g_App.g_pPrefs->GetMaxUpload() * 1024u / 10u * static_cast<uint32>(timeSinceLastGaveDataMs) / 1000u );
d516 1
a516 1
	if (dwNumOfUploads < (uint32)(g_App.g_pPrefs->GetMaxUpload()*1024/(UPLOAD_LOW_CLIENT_DR*10))+1)
d611 1
a611 1
			if (GetTickCount() - client->GetBanTime() > g_App.g_pPrefs->BadClientBanTime())
d623 1
a623 1
	bool				bIsQueueFull = (dwWaitingListCount >= (g_App.g_pPrefs->GetQueueSize() + m_dwBannedCount));
d797 1
a797 1
		if (g_App.g_pPrefs->LogUploadToFile())
d1004 1
a1004 1
		if (g_App.g_pPrefs->IsWatchClipboard4ED2KLinks())
d1025 1
a1025 1
		if (g_App.g_pPrefs->GetTrafficOMeterInterval() > 0)
d1027 1
a1027 1
			if (g_iCounter % ((uint32)(g_App.g_pPrefs->GetTrafficOMeterInterval()) * 10) == 0)
d1036 1
a1036 1
			if (g_App.g_pPrefs->GetStatsInterval() > 0)
d1038 1
a1038 1
				if (g_iCounter % ((uint32)(g_App.g_pPrefs->GetStatsInterval()) * 10) == 0)
d1075 1
a1075 1
				if (g_App.g_pPrefs->IsAutoSourcesEnabled())
d1090 1
a1090 1
					g_App.g_pPrefs->SaveStats();
d1103 1
a1103 1
				if (g_App.g_pPrefs->IsScheduledBackup() && g_App.g_pPrefs->GetScheduledBackupInterval() != 0)
d1105 1
a1105 1
					if (::GetTickCount() > (g_App.m_pUploadQueue->m_dwLastScheduledBackupTick) + g_App.g_pPrefs->GetScheduledBackupInterval() * 3600000)
d1114 1
a1114 1
				if (g_App.g_pPrefs->IsSCHEnabled())
d1119 1
a1119 1
					if (secs > g_App.g_pPrefs->GetSCHShift1()-60 && secs < g_App.g_pPrefs->GetSCHShift1()+60)
d1123 4
a1126 4
						g_App.g_pPrefs->SetMaxUpload(g_App.g_pPrefs->GetSCHShift1Upload());
						g_App.g_pPrefs->SetMaxDownload(g_App.g_pPrefs->GetSCHShift1Download());
						g_App.g_pPrefs->SetMaxConnections(g_App.g_pPrefs->GetSCHShift1conn());
						g_App.g_pPrefs->SetMaxDownloadConperFive(g_App.g_pPrefs->GetSCHShift15sec());
d1130 6
a1135 6
											static_cast<double>(g_App.g_pPrefs->GetSCHShift1Upload()) / 10.0,
											static_cast<double>(g_App.g_pPrefs->GetSCHShift1Download()) / 10.0,
											g_App.g_pPrefs->GetSCHShift1conn(),
											g_App.g_pPrefs->GetSCHShift15sec() );
						g_App.m_pSMTPConnection->SendMail(MessageText, g_App.g_pPrefs->GetUseSchedulerNotifier(), g_App.g_pPrefs->IsSMTPInfoEnabled());
						g_App.m_pMDlg->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_App.g_pPrefs->GetUseSchedulerNotifier());
d1138 1
a1138 1
					else if (secs > g_App.g_pPrefs->GetSCHShift2()-60 && secs < g_App.g_pPrefs->GetSCHShift2()+60)
d1141 7
a1147 7
						if ( (dayOfWeek==2 && g_App.g_pPrefs->IsSCHExceptMon())
							|| (dayOfWeek==3 && g_App.g_pPrefs->IsSCHExceptTue())
							|| (dayOfWeek==4 && g_App.g_pPrefs->IsSCHExceptWed())
							|| (dayOfWeek==5 && g_App.g_pPrefs->IsSCHExceptThu())
							|| (dayOfWeek==6 && g_App.g_pPrefs->IsSCHExceptFri())
							|| (dayOfWeek==7 && g_App.g_pPrefs->IsSCHExceptSat())
							|| (dayOfWeek==1 && g_App.g_pPrefs->IsSCHExceptSun()) )
d1155 4
a1158 4
							g_App.g_pPrefs->SetMaxUpload(g_App.g_pPrefs->GetSCHShift2Upload());
							g_App.g_pPrefs->SetMaxDownload(g_App.g_pPrefs->GetSCHShift2Download());
							g_App.g_pPrefs->SetMaxConnections(g_App.g_pPrefs->GetSCHShift2conn());
							g_App.g_pPrefs->SetMaxDownloadConperFive(g_App.g_pPrefs->GetSCHShift25sec());
d1162 6
a1167 6
												static_cast<double>(g_App.g_pPrefs->GetSCHShift2Upload()) / 10.0,
												static_cast<double>(g_App.g_pPrefs->GetSCHShift2Download()) / 10.0,
												g_App.g_pPrefs->GetSCHShift2conn(),
												g_App.g_pPrefs->GetSCHShift25sec() );
							g_App.m_pSMTPConnection->SendMail(MessageText, g_App.g_pPrefs->GetUseSchedulerNotifier(), g_App.g_pPrefs->IsSMTPInfoEnabled());
							g_App.m_pMDlg->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_App.g_pPrefs->GetUseSchedulerNotifier());
d1251 1
a1251 1
	if (g_App.g_pPrefs->GetSCHShift1Upload() != 0)
d1253 1
a1253 1
		g_App.g_pPrefs->SetSCHShift1Download(TieUploadDownload(g_App.g_pPrefs->GetSCHShift1Upload(), g_App.g_pPrefs->GetSCHShift1Download()));
d1259 1
a1259 1
	if (g_App.g_pPrefs->GetSCHShift2Upload() != 0)
d1261 1
a1261 1
		g_App.g_pPrefs->SetSCHShift2Download(TieUploadDownload(g_App.g_pPrefs->GetSCHShift2Upload(), g_App.g_pPrefs->GetSCHShift2Download()));
@


1.194
log
@I think that we need to punish for such kind of mistakes.
@
text
@d99 1
a99 1
										THREAD_PRIORITY_BELOW_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(),
d115 1
a115 1
	m_strUploadLogFilePath.Format(_T("%supload.log"), g_eMuleApp.m_pGlobPrefs->GetAppDir());
d126 1
a126 1
	if (g_eMuleApp.m_pListenSocket->TooManySockets())
d147 1
a147 1
				|| !g_eMuleApp.m_pSharedFilesList->GetFileByID(pSource->m_reqFileHash) )
d193 1
a193 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d198 1
a198 1
	if (!g_eMuleApp.m_pClientList->IsValidClient(pNewSource))
d218 1
a218 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d237 1
a237 1
	CKnownFile	*pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pNewSource->m_reqFileHash);
d242 1
a242 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.AddClient(pNewSource);
d273 1
a273 1
		int	iRateFor100ms = (g_eMuleApp.m_pGlobPrefs->GetMaxUpload() * 1024) / 100;
d298 1
a298 1
		g_eMuleApp.m_pGlobPrefs->GetMaxUpload() * 1024u / 10u * static_cast<uint32>(timeSinceLastGaveDataMs) / 1000u );
d423 1
a423 1
		m_averageDataRateList.push_front(g_eMuleApp.stat_sessionSentBytes);
d478 1
a478 1
	if (g_eMuleApp.m_pServerConnect->IsConnected() && g_eMuleApp.m_pServerConnect->IsLowID())
d487 1
a487 1
				if ( g_eMuleApp.m_pListenSocket->TooManySockets()
d516 1
a516 1
	if (dwNumOfUploads < (uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_LOW_CLIENT_DR*10))+1)
d584 3
a586 3
	if ( g_eMuleApp.m_pServerConnect->IsConnected()
		&& g_eMuleApp.m_pServerConnect->IsLowID()
		&& !g_eMuleApp.m_pServerConnect->IsLocalServer(client->GetServerIP(),client->GetServerPort())
d611 1
a611 1
			if (GetTickCount() - client->GetBanTime() > g_eMuleApp.m_pGlobPrefs->BadClientBanTime())
d623 1
a623 1
	bool				bIsQueueFull = (dwWaitingListCount >= (g_eMuleApp.m_pGlobPrefs->GetQueueSize() + m_dwBannedCount));
d649 1
a649 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(client);
d721 1
a721 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d741 2
a742 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(client);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d770 1
a770 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.RemoveClient(client);
d797 1
a797 1
		if (g_eMuleApp.m_pGlobPrefs->LogUploadToFile())
d805 1
a805 1
				CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
d808 1
a808 1
					pKnownFile = g_eMuleApp.m_pKnownFilesList->FindKnownFileByID((uchar*)client->m_reqFileHash);
d825 1
a825 1
										g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason) );
d861 1
a861 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d886 1
a886 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(todelete);
d982 1
a982 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d987 4
a990 4
	g_eMuleApp.m_pUploadQueue->Process();
	g_eMuleApp.m_pDownloadQueue->Process();
	g_eMuleApp.m_pUploadQueue->CompUpDataRateOverhead();
	g_eMuleApp.m_pDownloadQueue->CompDownDataRateOverhead();
d998 1
a998 1
		if (g_eMuleApp.m_pServerConnect->IsConnecting())
d1000 1
a1000 1
			g_eMuleApp.m_pServerConnect->TryAnotherConnectionRequest();
d1004 1
a1004 1
		if (g_eMuleApp.m_pGlobPrefs->IsWatchClipboard4ED2KLinks())
d1006 1
a1006 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.SearchClipBoard();
d1009 1
a1009 1
		g_eMuleApp.m_pdlgEmule->m_dlgStatistics.UpdateConnectionsStatus();
d1012 1
a1012 1
		if (g_eMuleApp.m_pServerConnect->IsConnecting())
d1014 1
a1014 1
			g_eMuleApp.m_pServerConnect->CheckForTimeout();
d1021 1
a1021 1
			g_eMuleApp.m_pdlgEmule->m_dlgStatistics.UpdateConnectionStats((double)g_eMuleApp.m_pUploadQueue->GetDataRate()/1024, static_cast<double>(g_eMuleApp.m_pDownloadQueue->GetDataRate())/1024.0);
d1025 1
a1025 1
		if (g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval() > 0)
d1027 1
a1027 1
			if (g_iCounter % ((uint32)(g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()) * 10) == 0)
d1029 1
a1029 1
				g_eMuleApp.m_pdlgEmule->m_dlgStatistics.SetCurrentRate((static_cast<double>(g_eMuleApp.m_pUploadQueue->GetDataRate()))/1024.0,((double)g_eMuleApp.m_pDownloadQueue->GetDataRate())/1024);
d1034 1
a1034 1
		if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_dlgStatistics && g_eMuleApp.m_pdlgEmule->IsWindowVisible())
d1036 1
a1036 1
			if (g_eMuleApp.m_pGlobPrefs->GetStatsInterval() > 0)
d1038 1
a1038 1
				if (g_iCounter % ((uint32)(g_eMuleApp.m_pGlobPrefs->GetStatsInterval()) * 10) == 0)
d1040 1
a1040 1
					g_eMuleApp.m_pdlgEmule->ShowStatistics();
d1046 1
a1046 1
		g_eMuleApp.m_pdlgEmule->m_dlgStatistics.RecordRate();
d1050 1
a1050 1
		g_eMuleApp.m_pMMServer->Process();
d1059 1
a1059 1
				g_eMuleApp.AddLogLine(false, RGB_PINK + _T("** ") + RGB_LOG_ERROR + _T("Memory corruption detected") + RGB_PINK + _T(" **"));
d1064 1
a1064 1
			g_eMuleApp.m_pListenSocket->Process();
d1066 1
a1066 1
			g_eMuleApp.m_pSharedFilesList->Process();	// files publishing
d1068 2
a1069 2
			g_eMuleApp.OnlineSig();
			g_eMuleApp.m_pdlgEmule->ShowTransferRate();
d1075 1
a1075 1
				if (g_eMuleApp.m_pGlobPrefs->IsAutoSourcesEnabled())
d1077 1
a1077 1
					g_eMuleApp.m_pDownloadQueue->SetAutoSourcesPerFile();
d1080 1
a1080 1
				g_eMuleApp.m_pFriendList->Process();
d1090 1
a1090 1
					g_eMuleApp.m_pGlobPrefs->SaveStats();
d1094 1
a1094 1
				g_eMuleApp.m_pServerConnect->KeepConnectionAlive();
d1097 1
a1097 1
				g_eMuleApp.m_pClientCreditList->Process();
d1100 1
a1100 1
				g_eMuleApp.m_pServerList->Process();
d1103 1
a1103 1
				if (g_eMuleApp.m_pGlobPrefs->IsScheduledBackup() && g_eMuleApp.m_pGlobPrefs->GetScheduledBackupInterval() != 0)
d1105 1
a1105 1
					if (::GetTickCount() > (g_eMuleApp.m_pUploadQueue->m_dwLastScheduledBackupTick) + g_eMuleApp.m_pGlobPrefs->GetScheduledBackupInterval() * 3600000)
d1107 2
a1108 2
						g_eMuleApp.m_pdlgEmule->RunBackupNow(true);
						g_eMuleApp.m_pUploadQueue->m_dwLastScheduledBackupTick = ::GetTickCount();
d1114 1
a1114 1
				if (g_eMuleApp.m_pGlobPrefs->IsSCHEnabled())
d1119 1
a1119 1
					if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift1()-60 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift1()+60)
d1122 5
a1126 5
						g_eMuleApp.m_pUploadQueue->SCHShift1UploadCheck();
						g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload());
						g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download());
						g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn());
						g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec());
d1130 6
a1135 6
											static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()) / 10.0,
											static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()) / 10.0,
											g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn(),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec() );
						g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
						g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier());
d1138 1
a1138 1
					else if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift2()-60 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift2()+60)
d1141 7
a1147 7
						if ( (dayOfWeek==2 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptMon())
							|| (dayOfWeek==3 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptTue())
							|| (dayOfWeek==4 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptWed())
							|| (dayOfWeek==5 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptThu())
							|| (dayOfWeek==6 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptFri())
							|| (dayOfWeek==7 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSat())
							|| (dayOfWeek==1 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSun()) )
d1154 5
a1158 5
							g_eMuleApp.m_pUploadQueue->SCHShift2UploadCheck();
							g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload());
							g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download());
							g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn());
							g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec());
d1162 6
a1167 6
												static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()) / 10.0,
												static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()) / 10.0,
												g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn(),
												g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec() );
							g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
							g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier());
d1240 1
a1240 1
		if (g_eMuleApp.m_pKnownFilesList == NULL)
d1243 1
a1243 1
		g_eMuleApp.m_pKnownFilesList->Save();
d1251 1
a1251 1
	if (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() != 0)
d1253 1
a1253 1
		g_eMuleApp.m_pGlobPrefs->SetSCHShift1Download(TieUploadDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(), g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()));
d1259 1
a1259 1
	if (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() != 0)
d1261 1
a1261 1
		g_eMuleApp.m_pGlobPrefs->SetSCHShift2Download(TieUploadDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(), g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()));
@


1.193
log
@added LowID field in upload.log
@
text
@d810 1
a810 1
				strLogLine.Format( _T("%s,\"%s\",%s,%s,\"%s\",%u,%u,%u,%s,%s,%s,%s\n"),
@


1.192
log
@Unicode corrections {KuSh}.
@
text
@d822 1
@


1.191
log
@Improved LowID users handling in waiting queue to minimize unfare waiting time;
Removed unused code related to unlimited upload; Formatting.
@
text
@d55 1
a55 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT __FUNCTION__ _T(": Fatal Error, failed to create Timer"));
d59 1
a59 1
	g_iCounter=0;
@


1.190
log
@One more step to integrate eklmn's SSDQ.
@
text
@d129 1
a129 3
	POSITION toadd = 0;
	uint32	dwScore, dwBestScore = 0;
	CUpDownClient* pNewSource;
d134 3
a136 2
		POSITION pos1, pos2;
		CUpDownClient* pSource;
d140 1
a140 1
			pSource  = waitinglist.GetNext(pos1);
d146 1
a146 1
			if ( (::GetTickCount() - pSource->GetLastUpRequest() > MAX_PURGEQUEUETIME)
d149 1
a149 1
				RemoveFromWaitingQueue(pos2,true);
d159 3
a161 2
		// Finished clearing
			else if ( ((dwScore = pSource->GetScore(false)) > dwBestScore) && (!pSource->HasLowID()
d163 1
a163 1
				|| (pSource->m_pRequestSocket && pSource->m_pRequestSocket->IsConnected())
d165 16
a180 4
				) )
			{
				dwBestScore = dwScore;
				toadd = pos2;
d183 5
d228 1
d405 1
a405 1
		dwWantedNumberOfTotalUploads = m_activeClientsSortedVector[(dwVectorSize >> 1)] + MINNUMBEROFTRICKLEUPLOADS;;
d506 1
a506 1
bool CUploadQueue::CanAcceptNewClient(uint32 numberOfUploads)
d511 1
a511 1
	if (numberOfUploads < MIN_UP_CLIENTS_ALLOWED)
d513 1
a513 1
	else if (numberOfUploads >= MAX_UP_CLIENTS_ALLOWED)
d516 2
a517 13
//	Now the final check
	if (g_eMuleApp.m_pGlobPrefs->GetMaxUpload() == UNLIMITED)
	{
		if (numberOfUploads < (GetDataRate()/UPLOAD_CLIENT_DATARATE))
			return true;
	}
	else
	{
		if (numberOfUploads < (uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_LOW_CLIENT_DR*10))+1)
			return true;
	}
//	Nope
	return false;
d632 16
d764 1
d857 1
a857 1
		RemoveFromWaitingQueue(pos,updatewindow);
d861 1
@


1.189
log
@Some eklmn's modifications with improvement.
@
text
@d58 1
a58 1
	m_iBannedCount = 0;
a569 19
void CUploadQueue::UpdateBanCount()
{
	EMULE_TRY

	int count=0;

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
	{
		CUpDownClient	   *pSource = waitinglist.GetNext(pos);

		if (pSource->IsBanned())
			count++;
	}

	SetBanCount(count);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d616 1
a616 1
	bool				bIsQueueFull = (dwWaitingListCount >= (g_eMuleApp.m_pGlobPrefs->GetQueueSize() + m_iBannedCount));
@


1.188
log
@fixed indefication of the client IP identiifcatio has more higher priority as Userhash.
@
text
@d650 4
a653 1
			if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
d655 11
a665 3
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s and %s have the same userhash or IP, removed '%s'"),
								 client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware(), pSource->GetUserName() );
				RemoveFromWaitingQueue(pos2,true);
d667 1
a667 1
			else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) == IS_IDENTIFIED)
d669 11
a679 2
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s and %s have the same userhash or IP, removed '%s'"),
								 client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware(), client->GetUserName() );
d682 1
a682 13
			else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
			{
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s and %s have the same userhash or IP, removed both"),
								 client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware() );
				RemoveFromWaitingQueue(pos2,true);
				return;
			}
			else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) == IS_IDENTIFIED)
			{
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Identified client %s and %s have the same Userhash or IP, removed '%s'"),
								 client->GetClientNameWithSoftware(), pSource->GetClientNameWithSoftware(), pSource->GetUserName());
				RemoveFromWaitingQueue(pos2,true);
			}
d790 3
d794 1
a794 1
			m_iTotalUploadTime += client->GetUpStartTimeDelay()/1000;
d796 1
a796 1
			if (g_eMuleApp.m_pGlobPrefs->LogUploadToFile())
d798 24
a821 29
				FILE *LogFile = _tfopen(m_strUploadLogFilePath, "a");

				if (LogFile != NULL)
				{
					COleDateTime	currentTime(COleDateTime::GetCurrentTime());
					CString			strLogLine;
					CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);

					if (!pKnownFile)
						pKnownFile = g_eMuleApp.m_pKnownFilesList->FindKnownFileByID((uchar*)client->m_reqFileHash);

					strLogLine.Format( _T("%s,\"%s\",%s,%s,\"%s\",%u,%u,%u,%s,%s,%s,%s\n"),
										currentTime.Format(),
										client->GetUserName(),
										HashToString(client->GetUserHash()),
										client->GetFullSoftVersionString(),
										(pKnownFile) ? pKnownFile->GetFileName() : _T(""),
										client->GetSessionUp(),
										client->GetCurrentlyUploadingPart(),
										(client->GetUpStartTimeDelay()/1000),
										YesNoStr(client->IsFriend()),
										YesNoStr(client->IsCommunity()),
										YesNoStr(client->IsOnLAN()),
										(client->GetSessionUp() >= PARTSIZE) ? 
											GetResString(IDS_IDENTOK).MakeLower() : 
											g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason) );
					_fputts(strLogLine, LogFile);
					fclose(LogFile);
				}
@


1.187
log
@changed output of last requested part in upload.log. the value 65535 is used if user did not request the blocks
@
text
@d648 1
a648 1
		else if (client->Compare(pSource)) // Another client with same ip or hash
@


1.186
log
@added user hash to upload log
@
text
@a793 1
					uint32			iPartNum = client->GetCurrentlyUploadingPart();
d805 1
a805 1
										(iPartNum != 0xFFFF) ? iPartNum : 0,
@


1.185
log
@Slightly cleaned a mess of including one H-file into another.
@
text
@d799 1
a799 1
					strLogLine.Format( _T("%s,\"%s\",%s,\"%s\",%u,%u,%u,%s,%s,%s,%s\n"),
d802 1
@


1.184
log
@Unified way to display client name and version; Improved string processing.
@
text
@d29 1
@


1.183
log
@added statistic that show the number of failed DL sessions in case that remote client has nothing to request
@
text
@d54 1
a54 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("%s: Fatal Error, failed to create Timer"), __FUNCTION__);
d107 1
a107 1
			AddDebugLogLine(RGB_LOG_ERROR + _T("Error creating SourcesSaveThread"));
d111 1
a111 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("Error creating SourcesSaveThread"));
d309 3
a311 3
	// count only the non-LAN clients, who are real active
	// 1) the client is transfering (BSR_BUSY)
	// 2) the client will transfer (BSR_OK or BSR_OK_WANTS_MORE_BANDWIDTH)
d357 1
a357 1
// Save number of active clients for statistics into the lilst & sorted vector
d360 1
a360 1
	while (vecIt != m_activeClientsSortedVector.end() && *(vecIt) < dwSlotCounter )
d376 1
a376 1
// control the number off the clients in UL queue.
d381 1
a381 1
// collect some information for new client set. Therefore the number of client will be not changed udring 2 sec
d385 1
a385 1
	// user a sorted vector of active clients to get median, if enought data was collected
d651 2
a652 3
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
								 client->GetUserName(), client->GetClientNameAndVersionString(), 
								 pSource->GetUserName(), pSource->GetClientNameAndVersionString(), pSource->GetUserName() );
d657 2
a658 3
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
								 client->GetUserName(), client->GetClientNameAndVersionString(),
								 pSource->GetUserName(), pSource->GetClientNameAndVersionString(), client->GetUserName() );
d663 2
a664 3
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed both"),
								 client->GetUserName(), client->GetClientNameAndVersionString(),
								 pSource->GetUserName(), pSource->GetClientNameAndVersionString() );
d670 2
a671 3
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Identified client '%s' (%s) and '%s' (%s) have the same Userhash or IP, removed '%s'"),
								 client->GetUserName(), client->GetClientNameAndVersionString(),
								 pSource->GetUserName(), pSource->GetClientNameAndVersionString(), pSource->GetUserName());
d771 1
a771 1
			m_iULSessionFailed[eReason]++;
d775 1
a775 1
				AddDebugLogLine(_T("%u Failed upload session with the client '%s' (%s)."), m_iULSessionFailedNoDataForRemoteClient, client->GetUserName(), client->GetClientNameAndVersionString());
d801 1
a801 1
										client->GetClientNameAndVersionString(),
@


1.182
log
@Some preparations for new publishing algorithm;
Slightly reduced main timer processing overhead;
Reduced check precision to save friend list to gain some performance
(no need to be so precise for that).
@
text
@d68 2
d774 1
d776 5
@


1.181
log
@name corretions according our name convetion
@
text
@d1038 1
a1038 1
		#ifdef _DEBUG
d1043 1
a1043 1
		#endif
d1045 1
a1045 1
		#ifdef OLD_SOCKETS_ENABLED
d1047 2
a1048 1
		#endif
a1051 8
		}

	//	Every 5 minutes
		if (g_iCounter % 3000 == 0)
		{
		//	This function does NOT update the tree!
			g_eMuleApp.m_pGlobPrefs->SaveStats();
		}
d1053 2
a1054 5
	//	Every 90 seconds
		if (g_iCounter % 900 == 0)
		{
		//	Auto Sources per File 
			if (g_eMuleApp.m_pGlobPrefs->IsAutoSourcesEnabled())
d1056 7
a1062 1
				g_eMuleApp.m_pDownloadQueue->SetAutoSourcesPerFile();
a1063 1
		}
d1065 9
a1073 5
	//	Every minute
		if (g_iCounter % 600 == 0)
		{
		//	Server keepalive
			g_eMuleApp.m_pServerConnect->KeepConnectionAlive();
d1075 2
a1076 2
		//	Save clients.met (internal 18 minute interval)
			g_eMuleApp.m_pClientCreditList->Process();
d1078 2
a1079 2
		//	Save server.met (internal 17 minute interval)
			g_eMuleApp.m_pServerList->Process();
d1081 2
a1082 2
		//	Save emfriends.met (internal 25 minute interval)
			g_eMuleApp.m_pFriendList->Process();
d1084 2
a1085 4
		//	Scheduled Backup
			if (g_eMuleApp.m_pGlobPrefs->IsScheduledBackup() && g_eMuleApp.m_pGlobPrefs->GetScheduledBackupInterval() != 0)
			{
				if (::GetTickCount() > (g_eMuleApp.m_pUploadQueue->m_dwLastScheduledBackupTick) + g_eMuleApp.m_pGlobPrefs->GetScheduledBackupInterval() * 3600000)
d1087 6
a1092 3
					g_eMuleApp.m_pdlgEmule->RunBackupNow(true);
					g_eMuleApp.m_pUploadQueue->m_dwLastScheduledBackupTick = ::GetTickCount();
					CLoggable::AddDebugLogLine(_T("Scheduled backup performed"));
a1093 1
			}
d1095 5
a1099 5
		//	Scheduler Shift check
			if (g_eMuleApp.m_pGlobPrefs->IsSCHEnabled())
			{
				CTime curr_t = CTime::GetCurrentTime();
				uint32 secs = curr_t.GetSecond() + 60*curr_t.GetMinute() + 60*60*curr_t.GetHour();
d1101 1
a1101 33
				if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift1()-60 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift1()+60)
				{
				//	Switching to shift1 speeds
					g_eMuleApp.m_pUploadQueue->SCHShift1UploadCheck();
					g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload());
					g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download());
					g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn());
					g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec());
				//	Sending message for scheduler shift 1
					CString MessageText;
					MessageText.Format( _T("SCHEDULER: switching to Shift 1 (Max Upload:%.1f Max Download:%.1f Max Connections:%i Max In 5 secs:%i)"),
										static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()) / 10.0,
										static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()) / 10.0,
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec() );
					g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
					g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier());
					CLoggable::AddDebugLogLine(MessageText);
				}
				else if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift2()-60 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift2()+60)
				{
					int dayOfWeek = curr_t.GetDayOfWeek();
					if ( (dayOfWeek==2 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptMon())
						 || (dayOfWeek==3 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptTue())
						 || (dayOfWeek==4 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptWed())
						 || (dayOfWeek==5 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptThu())
						 || (dayOfWeek==6 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptFri())
						 || (dayOfWeek==7 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSat())
						 || (dayOfWeek==1 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSun()) )
	               	{
	                   	CLoggable::AddDebugLogLine(_T("SCHEDULER: day excepted!"));
					}
					else
d1103 7
a1109 7
					//	Switching to shift2 speeds
						g_eMuleApp.m_pUploadQueue->SCHShift2UploadCheck();
						g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload());
						g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download());
						g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn());
						g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec());
					//	Sending message for scheduler shift 2
d1111 5
a1115 5
						MessageText.Format( _T("SCHEDULER: switching to Shift 2 (Max Upload:%.1f Max Download:%.1f Max Connections:%i Max In 5 secs:%i)"),
											static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()) / 10.0,
											static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()) / 10.0,
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn(),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec() );
d1120 33
@


1.180
log
@Fixed auto resume from stand-by {Mikelke/al37919}.
@
text
@d788 1
a788 1
					CKnownFile		*m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
d791 2
a792 2
					if (!m_pReqPartFile)
						m_pReqPartFile = g_eMuleApp.m_pKnownFilesList->FindKnownFileByID((uchar*)client->m_reqFileHash);
d798 1
a798 1
										(m_pReqPartFile) ? m_pReqPartFile->GetFileName() : _T(""),
@


1.179
log
@Fixed score comparison bugs committed on Jan 20 'Removed GetScore() unused parameter' {xalbux}.
@
text
@a89 2
//	Create timer to save known sources every 30 minutes
	m_hSaveSTimer	=	::CreateWaitableTimer(NULL, FALSE, NULL);
d92 1
a92 1
	if (m_hSaveSTimer && m_hQuitEvent)
a532 2
	if (m_hSaveSTimer != NULL)
		::CloseHandle(m_hSaveSTimer);
d1216 1
a1216 8
	HANDLE hTimer = (reinterpret_cast<CUploadQueue*>(lpArg))->m_hSaveSTimer;
	HANDLE hArr[2] = { hTimer, (reinterpret_cast<CUploadQueue*>(lpArg))->m_hQuitEvent };
	LARGE_INTEGER llDueTime;

//	The first timer timeout (30 minutes)
	llDueTime.QuadPart = (LONGLONG)-30*60*10000000;
//	Set timer to signal every 30 minutes
	::SetWaitableTimer(hTimer, &llDueTime, 30*60*1000, NULL, NULL, TRUE);
d1218 2
a1219 1
	for (;;)
a1220 6
	//	Wait for timer signal or event requesting to quit
		DWORD dwRC = ::WaitForMultipleObjects(sizeof(hArr)/sizeof(hArr[0]), hArr, FALSE, INFINITE);

	//	Request to quit
		if (dwRC != WAIT_OBJECT_0)
			break;
@


1.178
log
@Overflow of upload client bandwidth calculation (for upload limits > 1048 KBytes/s) {cvictor}.
@
text
@d160 1
a160 1
			else if ( ((dwScore = pSource->GetScore(true)) > dwBestScore) && (!pSource->HasLowID()
d883 1
a883 1
	uint32 score = client->GetScore(true,true);
d887 1
a887 1
		if (score < waitinglist.GetNext(pos)->GetScore(true,false))
@


1.177
log
@separate active clients & invited to upload if socket is busy
@
text
@d278 2
a279 1
	sint32 realMaxULRatems = (g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024*timeSinceLastGaveDataMs)/10000;
@


1.176
log
@reworked control over number of clients in upload queue
@
text
@d37 1
a243 22
// control the number off the clients in UL queue.
	uint32 dwNumOfULClients = m_UploadingList.size();
	uint32 dwWantedNumberOfTotalUploads = dwNumOfULClients;

// Since the algorithm clears the info about active clients, if one of the client entered or leaved the upload queue. It's required to
// collect some information for new client set. Therefore the number of client will be not changed udring 2 sec
	uint32 dwVectorSize = m_activeClientsSortedVector.size();
	if (dwVectorSize > 20)
	{
	// user a sorted vector of active clients to get median, if enought data was collected
		dwWantedNumberOfTotalUploads = m_activeClientsSortedVector[(dwVectorSize >> 1)] + MINNUMBEROFTRICKLEUPLOADS;;
	}

// Add or remove connections as needed. Mostly, this is controlled by the number of fully active uploads.
	if (CanAcceptNewClient(dwNumOfULClients) 
		&& waitinglist.GetCount() > 0
		&& dwWantedNumberOfTotalUploads > dwNumOfULClients)
	{
	//	There's not enough open uploads. Open more another one.
		AddClientToUploadQueue();
	}

a251 1
#define UQ_DELAY_CORRECTION		200		//max. delay to start correction (in ms)
d375 25
@


1.175
log
@Fixed rare uploading drops due to incorrect feeding of the main slots
(no data was given to other slots if some main slot was without requested blocks);
Fixed uploading drops caused by computation overflow;
Fixed extremely high uploading rate peaks caused by system load.
@
text
@d36 2
a79 2
	m_MaxActiveClients = 0;

d212 3
d234 1
d243 3
a245 3
// Normal case for limited upload.
	uint32		tempMaxActiveClients = 0;
	deque<uint32>::iterator it;
d247 4
a250 1
	for (it = m_activeClientsDeque.begin(); it != m_activeClientsDeque.end(); ++it) 
d252 2
a253 4
		uint32 activeClientsSnapshot = *it;

		if (activeClientsSnapshot > tempMaxActiveClients)
			tempMaxActiveClients = activeClientsSnapshot;
d256 4
a259 19
	m_MaxActiveClients = tempMaxActiveClients;

#define MINNUMBEROFTRICKLEUPLOADS 2
// How many slots should be open? Trickle slots included (at least 2 trickles, 30% of total, and no slot is expected to use more than UPLOAD_CLIENT_DATARATE*2 in average, whichever number is largest)
	uint32 dwWantedNumberOfTotalUploads = max((uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_CLIENT_DATARATE*20)),
												m_MaxActiveClients + MINNUMBEROFTRICKLEUPLOADS);
	dwWantedNumberOfTotalUploads = max(dwWantedNumberOfTotalUploads, m_MaxActiveClients * 1.3);

	CUpDownClient	*lastClient = (m_UploadingList.empty()) ? NULL : m_UploadingList.back();

#define MINWAITBEFOREOPENANOTHERSLOTMS 1000

	uint32 dwNumOfULClients = m_UploadingList.size();

// Add or remove connections as needed. Mostly, this is controlled by the number of
// fully active uploads.
	if ( CanAcceptNewClient(dwNumOfULClients) &&
		(waitinglist.GetCount() > 0) && (dwWantedNumberOfTotalUploads > dwNumOfULClients) &&
		((lastClient == NULL) || (lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS)) )
a263 22
	else if (dwNumOfULClients > MIN_UP_CLIENTS_ALLOWED 
		&&  CanAcceptNewClient(dwNumOfULClients - 1) == false)
	{
	// There's to many open uploads (propably due to the user changing
	// the upload limit to a lower value). Remove the last opened upload and put
	// it back on the waitinglist. When it is put back, it get
	// to keep its waiting time. This means it is likely to soon be
	// choosen for upload again.
		if (!lastClient->IsOnLAN() && lastClient->GetUpStartTimeDelay() > 3*1000)
		{
		// Remove from upload list.
			g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(lastClient, ETS_TIMEOUT, true);

		// add to queue again. This is almost the same as in method
		//    g_eMuleApp.m_pUploadQueue->AddClientToQueue(lastClient,true);
			waitinglist.AddTail(lastClient);
			lastClient->SetUploadState(US_ONUPLOADQUEUE);
			lastClient->SendRankingInfo();
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(lastClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
		}
	}
d305 1
a305 1
	uint32 slotcounter = 0;
d330 5
a334 2
	// don't count the client as active, if during the data send client was removed from the UL queue
		if (eSendResult != BSR_FAILED_CLIENT_LEFT_UQ)
d336 1
a336 1
			slotcounter++;
d378 11
a388 3
// Save number of active clients for statistics
	m_activeClientsDeque.push_back(slotcounter);
	if (m_activeClientsDeque.size() > 35)
d390 6
d753 4
@


1.174
log
@Fixed upload attempt loss during completing of the same file;
Speed up of candidate source selection from the waiting queue.
@
text
@d137 1
a137 1
		for (pos1 = waitinglist.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d179 1
a179 1
  	if (!g_eMuleApp.m_pClientList->IsValidClient(pNewSource))
d300 30
d343 1
a343 1
		&& (eSendResult == BSR_BUSY || eSendResult == BSR_FAILED_CLIENT_LEFT_UQ) )
d409 1
a409 2
	while (m_activeClientsDeque.size() > 35)
	{
a410 1
	}
@


1.173
log
@Changed inteface for the previous "UL queue improvement" to reduce performance loss.
@
text
@d128 1
a128 1
	uint32	bestscore = 0;
d159 1
a159 1
			else if ( (pSource->GetScore(true) > bestscore) && (!pSource->IsBanned())  && (!pSource->HasLowID()
d165 1
a165 1
				bestscore = pSource->GetScore(true);
d184 2
a185 8
// Never upload to a banned & already downloading client
	if (IsDownloading(pNewSource) || pNewSource->IsBanned(true))
		return;

// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour
// (the existence of the requested file will be done in AddClientToQueue)
	CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pNewSource->m_reqFileHash);
	if (m_pReqPartFile->IsPartFile() && ((CPartFile*)m_pReqPartFile)->GetStatus() == PS_COMPLETING)
d214 4
a217 2
	if (m_pReqPartFile)
		m_pReqPartFile->statistic.AddAccepted();
@


1.172
log
@improvement for UL queue:
1) used STL
2) fixed access to the queue from WebServer
@
text
@d231 3
a233 1
	ClientList* pCopyUploadQueueList = NULL;
a235 3

	EMULE_TRY

d259 1
a259 1
	sint32 wantedNumberOfTotalUploads = max((uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_CLIENT_DATARATE*20)),
d261 1
a261 3
	wantedNumberOfTotalUploads = max(wantedNumberOfTotalUploads, m_MaxActiveClients*1.3);

	CUpDownClient	   *lastClient = NULL;
d263 1
a263 2
	if (!m_UploadingList.empty())
		lastClient = m_UploadingList.back();
d271 3
a273 4
	if (CanAcceptNewClient(dwNumOfULClients) 
		&& waitinglist.GetCount() > 0
		&& wantedNumberOfTotalUploads > dwNumOfULClients
		&& (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS))
d302 1
a302 1
	pCopyUploadQueueList = GetCopyUploadQueueList();
d315 23
a337 5
	if (pCopyUploadQueueList)
	{
		cIt = pCopyUploadQueueList->begin();
		while (cIt != pCopyUploadQueueList->end() && (allowedBandwidthThisCall > usedBandwidthThisCall) 
			&& (eSendResult == BSR_BUSY || eSendResult == BSR_FAILED_CLIENT_LEFT_UQ) )
d339 1
a339 24
		// Only allow this connection to take what has not already been taken
		// by the other connections above it in the list.
			uint32 allowedThisIteration = allowedBandwidthThisCall-usedBandwidthThisCall;

		// Get the client. Note! Also updates ulpos as a side effect.
			CUpDownClient* cur_client = *cIt;

		// Give data to the upload, if it wants it. Remember how much data we have given this call.
		// The connection wont take any data if it hasn't emptied its buffer since we last gave it data (BSR_BUSY).
		// variable 'eSendResult' is updated by this method (it is a ref EnumBlockSendResult&)

		// LANCAST - Increment LanCount
			if (cur_client->IsOnLAN())
				QtyLANClients++;
			else
				usedBandwidthThisCall += cur_client->SendBlockData(allowedThisIteration, eSendResult);

		// don't count the client as active, if during the data send client was removed from the UL queue
			if (eSendResult != BSR_FAILED_CLIENT_LEFT_UQ)
			{
				slotcounter++;
			}

			cIt++;
d341 2
d350 6
a355 1
		while (cIt != pCopyUploadQueueList->end())
d357 3
a359 2
		// Get the client. Note! Also updates trickle_client_pos as a side effect.
			CUpDownClient* cur_client = *cIt;
d361 5
a365 14
			if (cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick)
			{
				// It's more than 3 seconds since this connection got any data.
				// Feed it a mercy package to prevent it from timing out.
				EnumBlockSendResult eTempSendResult;

				// LANCAST - Increment LanCount
				if (cur_client->IsOnLAN())
					QtyLANClients++;
				else
					usedBandwidthThisCall += cur_client->SendBlockData(MAXFRAGSIZE, eTempSendResult);
			}

			cIt++;
d412 1
a412 2

	if (pCopyUploadQueueList && QtyLANClients > 0)
d415 1
a415 1
		cIt = pCopyUploadQueueList->begin();
d417 1
a417 1
		while (cIt != pCopyUploadQueueList->end())
a428 2

			cIt++;
a471 2

	safe_delete(pCopyUploadQueueList);
d1152 1
a1152 3
	ClientList::const_iterator cIt;

	for ( cIt = m_UploadingList.begin( ); cIt != m_UploadingList.end( ); cIt++ )
d1154 1
a1154 1
		CUpDownClient* pPotentialSource = *cIt;
d1258 1
a1258 3
	list <CUpDownClient*>::const_iterator cIt;

	for ( cIt = m_UploadingList.begin( ); cIt != m_UploadingList.end( ); cIt++ )
a1262 1

d1267 1
a1267 1
ClientList* CUploadQueue::GetCopyUploadQueueList()
d1269 3
a1271 1
	ClientList* pCopyUploadQueueList = NULL;
a1272 10
	EnterCriticalSection(&m_csUploadQueueList);
	try 
	{
		pCopyUploadQueueList = new ClientList(m_UploadingList);
	}
	catch (CException * error)
	{
		g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(error));
		error->Delete();
	}
a1273 2

	return pCopyUploadQueueList;
@


1.171
log
@Corrected indent.
@
text
@d216 1
a216 1
	uploadinglist.AddTail(pNewSource);
d231 4
a236 1
	DWORD curTick = ::GetTickCount();
a239 2
	POSITION posULSlot = NULL;
	CTypedPtrList<CPtrList, CUpDownClient*> CopyUploadQueueList;
a263 1
	POSITION			lastpos = uploadinglist.GetTailPosition();
d266 2
a267 4
	if (lastpos != NULL)
	{
		lastClient = uploadinglist.GetAt(lastpos);
	}
d271 2
d275 1
a275 1
	if (CanAcceptNewClient(uploadinglist.GetCount()) 
d277 1
a277 1
		&& wantedNumberOfTotalUploads > uploadinglist.GetCount() 
d283 2
a284 2
	else if (uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED 
		&&  CanAcceptNewClient(uploadinglist.GetCount()-1) == false)
d306 2
a307 4
// Create a copy of Upload Queue for current iteration to prevent any interference during data upload
	EnterCriticalSection(&m_csUploadQueueList);
	CopyUploadQueueList.AddTail(&uploadinglist);
	LeaveCriticalSection(&m_csUploadQueueList);
d320 28
a347 20
	posULSlot = CopyUploadQueueList.GetHeadPosition();
	while (posULSlot != NULL && (allowedBandwidthThisCall > usedBandwidthThisCall) 
		&& (eSendResult == BSR_BUSY || eSendResult == BSR_FAILED_CLIENT_LEFT_UQ) )
	{
	// Only allow this connection to take what has not already been taken
	// by the other connections above it in the list.
		uint32 allowedThisIteration = allowedBandwidthThisCall-usedBandwidthThisCall;

	// Get the client. Note! Also updates ulpos as a side effect.
		CUpDownClient* cur_client = CopyUploadQueueList.GetNext(posULSlot);

	// Give data to the upload, if it wants it. Remember how much data we have given this call.
	// The connection wont take any data if it hasn't emptied its buffer since we last gave it data (BSR_BUSY).
	// variable 'eSendResult' is updated by this method (it is a ref EnumBlockSendResult&)

	// LANCAST - Increment LanCount
		if (cur_client->IsOnLAN())
			QtyLANClients++;
		else
			usedBandwidthThisCall += cur_client->SendBlockData(allowedThisIteration, eSendResult);
d349 1
a349 4
	// don't count the client as active, if during the data send client was removed from the UL queue
		if (eSendResult != BSR_FAILED_CLIENT_LEFT_UQ)
		{
			slotcounter++;
a350 1
	}
d358 4
a361 4
	while (posULSlot != NULL)
	{
	// Get the client. Note! Also updates trickle_client_pos as a side effect.
		CUpDownClient* cur_client = CopyUploadQueueList.GetNext(posULSlot);
d363 12
a374 5
		if (cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick)
		{
			// It's more than 3 seconds since this connection got any data.
			// Feed it a mercy package to prevent it from timing out.
			EnumBlockSendResult eTempSendResult;
d376 1
a376 5
			// LANCAST - Increment LanCount
			if (cur_client->IsOnLAN())
				QtyLANClients++;
			else
				usedBandwidthThisCall += cur_client->SendBlockData(MAXFRAGSIZE, eTempSendResult);
d423 2
a424 1
	if (QtyLANClients > 0)
d427 1
a427 1
		POSITION pos = CopyUploadQueueList.GetHeadPosition();
d429 1
a429 1
		while (pos != NULL)
d432 1
a432 1
			CUpDownClient* cur_client = CopyUploadQueueList.GetNext(pos);
d441 2
d486 2
d752 5
a756 2
	POSITION removed_pos = 0;
	removed_pos = uploadinglist.Find(client);
d758 1
a758 1
	if (removed_pos)
a759 4
		EnterCriticalSection(&m_csUploadQueueList);
		uploadinglist.RemoveAt(removed_pos);
		LeaveCriticalSection(&m_csUploadQueueList);

d900 1
a900 1
	uploadinglist.RemoveAll();
d1168 1
a1168 1
	POSITION pos = uploadinglist.GetHeadPosition();
d1170 1
a1170 1
	while (pos)
d1172 1
a1172 1
		CUpDownClient	   *pPotentialSource = uploadinglist.GetNext(pos);
d1178 1
a1178 1
	pos = waitinglist.GetHeadPosition();
d1274 32
@


1.170
log
@faster & correct request of banned client  position in the waiting queue
@
text
@d913 2
a914 2
	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
	{
@


1.169
log
@Detailed file parts information.
@
text
@d903 9
a911 2
	uint16 rank = 1;
	uint32 myscore = client->GetScore(false);
d915 3
a917 2
		if (waitinglist.GetNext(pos)->GetScore(false) > myscore)
			rank++;
d919 1
a919 1
	return rank;
@


1.168
log
@some code preparation
@
text
@d1174 28
@


1.167
log
@1) improved ZZ upload process
2) fixed possible upload break at last block in part
@
text
@a77 3
	for (int i = 0;i != 35;i++)
		activeClients_list.AddHead((int)0);

d245 1
a245 1
	POSITION	activeClientsListPos = activeClients_list.GetHeadPosition();
d247 1
a247 1
	while (activeClientsListPos != NULL)
d249 1
a249 1
		uint32 activeClientsSnapshot = activeClients_list.GetNext(activeClientsListPos);
d388 5
a392 2
	activeClients_list.RemoveHead();
	activeClients_list.AddTail(slotcounter);
@


1.166
log
@removed doubled code (the server check will be already done by processing of OP_HELLO packet)
@
text
@d118 2
d218 1
d220 1
d237 1
d239 3
a241 3

// LANCAST - We count lanclients
	int QtyLANClients = 0;
d246 3
a248 2
// Keeps track of how much bandwidth we use this call
    sint32 usedBandwidthThisCall = 0;
d250 1
a250 2
// How much data should be given each round?
	if (g_eMuleApp.m_pGlobPrefs->GetMaxUpload() == UNLIMITED)
d252 1
a252 14
	// Special case for unlimited upload
		if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount())
		{
			AddClientToUploadQueue();
		}

		bool clientWasReady = false;

		POSITION pos = uploadinglist.GetHeadPosition();
		while (pos != NULL)
		{
		// Get the client. Note! Also updates activeClientsListPos as a side effect
			CUpDownClient* cur_client = uploadinglist.GetNext(pos);
			bool tempWantsMoreBandwidth;
d254 2
a255 23
		// LANCAST - Just Count LAN Clients
			if (cur_client->IsOnLAN())
				QtyLANClients++;
			else
				usedBandwidthThisCall += cur_client->SendBlockData(m_guessedMaxBandwidth-usedBandwidthThisCall, tempWantsMoreBandwidth);

			if (tempWantsMoreBandwidth == true)
				clientWasReady = true;
		}

		if (clientWasReady == false)
		{
			if (m_guessedMaxBandwidth > 300)
				m_guessedMaxBandwidth -= 200;
			else
				m_guessedMaxBandwidth = 100;
		}
		else
		{
			m_guessedMaxBandwidth += 200;
		}

		m_MaxActiveClients = uploadinglist.GetCount();
a256 5
	else
	{
	// Normal case for limited upload.
		uint32		tempMaxActiveClients = 0;
		POSITION	activeClientsListPos = activeClients_list.GetHeadPosition();
d258 1
a258 10
		while (activeClientsListPos != NULL)
		{
			uint32 activeClientsSnapshot = activeClients_list.GetNext(activeClientsListPos);

			if (activeClientsSnapshot > tempMaxActiveClients)
				tempMaxActiveClients = activeClientsSnapshot;
		}

		m_MaxActiveClients = tempMaxActiveClients;
		sint32 realMaxULRatems = (g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024*timeSinceLastGaveDataMs)/10000;
d261 4
a264 4
	// How many slots should be open? Trickle slots included (at least 2 trickles, 30% of total, and no slot is expected to use more than UPLOAD_CLIENT_DATARATE*2 in average, whichever number is largest)
		sint32 wantedNumberOfTotalUploads = max((uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_CLIENT_DATARATE*20)),
													m_MaxActiveClients + MINNUMBEROFTRICKLEUPLOADS);
		wantedNumberOfTotalUploads = max(wantedNumberOfTotalUploads, m_MaxActiveClients*1.3);
d266 2
a267 2
		POSITION			lastpos = uploadinglist.GetTailPosition();
		CUpDownClient	   *lastClient = NULL;
d269 4
a272 4
		if (lastpos != NULL)
		{
			lastClient = uploadinglist.GetAt(lastpos);
		}
d276 30
a305 31
	// Add or remove connections as needed. Mostly, this is controlled by the number of
	// fully active uploads.
		if (CanAcceptNewClient(uploadinglist.GetCount()) 
			&& waitinglist.GetCount() > 0
			&& wantedNumberOfTotalUploads > uploadinglist.GetCount() 
			&& (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS))
		{
		//	There's not enough open uploads. Open more another one.
			AddClientToUploadQueue();
		}
		else if (uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED 
			&&  CanAcceptNewClient(uploadinglist.GetCount()-1) == false)
		{
		// There's to many open uploads (propably due to the user changing
		// the upload limit to a lower value). Remove the last opened upload and put
		// it back on the waitinglist. When it is put back, it get
		// to keep its waiting time. This means it is likely to soon be
		// choosen for upload again.
			if (!lastClient->IsOnLAN() && lastClient->GetUpStartTimeDelay() > 3*1000)
			{
			// Remove from upload list.
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(lastClient, ETS_TIMEOUT, true);

			// add to queue again. This is almost the same as in method
			//    g_eMuleApp.m_pUploadQueue->AddClientToQueue(lastClient,true);
				waitinglist.AddTail(lastClient);
				lastClient->SetUploadState(US_ONUPLOADQUEUE);
				lastClient->SendRankingInfo();
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(lastClient);
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
			}
d307 1
d309 36
a344 9
	// There's some saved bandwidth that we want to try to spend this round.
	// curMaxULRatems keeps track of how much data we want to spend.
		sint32 curMaxULRatems = realMaxULRatems + m_iLeftOverBandwidth;
		sint32 allowedBandwidthThisCall = min(curMaxULRatems, realMaxULRatems+MAXFRAGSIZE);

	// Which active slot are we giving data each loop
		uint32 slotcounter = 0;

		bool wantsMoreBandWidth = false;
d346 2
a347 3
		POSITION ulpos = uploadinglist.GetHeadPosition();
	// The loop that gives the fully activated connections data.
		while (ulpos != NULL && (allowedBandwidthThisCall > usedBandwidthThisCall) && wantsMoreBandWidth == false)
d349 3
a351 3
		// Only allow this connection to take what has not already been taken
		// by the other connections above it in the list.
			uint32 allowedThisIteration = allowedBandwidthThisCall-usedBandwidthThisCall;
d353 16
a368 6
		// Get the client. Note! Also updates ulpos as a side effect.
		    CUpDownClient* cur_client = uploadinglist.GetNext(ulpos);

		// Give data to the upload, if it wants it. Remember how much data we have given this call.
		// The connection wont take any data if it hasn't emptied its buffer since we last gave it data.
		// variable wantsMoreBandWidth is updated by this method (it is a ref bool&)
d370 1
a370 1
		// LANCAST - Increment LanCount
d374 1
a374 3
				usedBandwidthThisCall += cur_client->SendBlockData(allowedThisIteration, wantsMoreBandWidth);

			slotcounter++;
d376 1
d378 5
a382 7
#define MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS 2540
	// Trickle the unneeded uploads (just give them enough to not time out)
	// Theese downloads are kept connected, in a ready-to-go state, just in case
	// one of the fully activated uploads completes/timeouts/ends.
	// As soon as there's a little bandwidth leftover, the first one of these
	// uploads will go to fully activated state
		POSITION trickle_client_pos = uploadinglist.FindIndex(slotcounter);
d384 5
a388 4
		while (trickle_client_pos != NULL)
		{
		// Get the client. Note! Also updates trickle_client_pos as a side effect.
			CUpDownClient* cur_client = uploadinglist.GetNext(trickle_client_pos);
d390 3
a392 30
			if (cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick)
			{
				// It's more than 3 seconds since this connection got any data.
				// Feed it a mercy package to prevent it from timing out.
				bool tempWantsMoreData = false;

				// LANCAST - Increment LanCount
				if (cur_client->IsOnLAN())
					QtyLANClients++;
				else
					usedBandwidthThisCall += cur_client->SendBlockData(MAXFRAGSIZE, tempWantsMoreData);
			}
		}

	// Since we don't save bandwidth for the trickles above, we may
	// have used to much bandwidth.
	// We may also have used to little bandwidth this round, in that
	// case it is saved to the next round.
		m_iLeftOverBandwidth = curMaxULRatems-usedBandwidthThisCall;

	// We don't want to long peaks. Don't save to much bandwidth (about a second should be OK)
	// Always make sure we can save enough to get a packet through
		sint32 limitSave = MAXFRAGSIZE; // max(realMaxULRatems*10, MAXFRAGSIZE+realMaxULRatems*4);
		if (m_iLeftOverBandwidth > limitSave)
			m_iLeftOverBandwidth = limitSave;

	// Save number of active clients for statistics
		activeClients_list.RemoveHead();
		activeClients_list.AddTail(slotcounter);
	}
d416 2
a417 2
// LANCAST - If we have more than one LAN user were going to upload to them
// Were going to try uploading the way plus way.......
d421 1
a421 1
		POSITION pos = uploadinglist.GetHeadPosition();
d426 2
a427 2
			CUpDownClient* cur_client = uploadinglist.GetNext(pos);
			bool tempWantsMoreBandwidth = false;
d431 1
a431 1
				cur_client->SendBlockData(m_guessedMaxLANBandwidth, tempWantsMoreBandwidth);
d433 1
a433 1
			if (tempWantsMoreBandwidth == true)
d532 2
d747 1
d749 1
d1210 1
a1210 1

a1217 21

bool CUploadQueue::IsFileUploading (CPartFile* check_file)
{
	EMULE_TRY

	CUpDownClient* pSource;

	for(POSITION pos = uploadinglist.GetHeadPosition(); pos != NULL; )
	{
		pSource = uploadinglist.GetNext(pos);

		if (pSource->m_pReqPartFile == check_file)
			return true;
	}

	return false;

	EMULE_CATCH

	return true;
}
@


1.165
log
@Unified method for speed check.
@
text
@a736 18
//	Use some information from client & add clients server to list.
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && client->GetServerIP() && client->GetServerPort())
	{
	//	If the server isn't already in our server list ...
		if ( (client->GetServerIP() != 0) && !g_eMuleApp.m_pServerList->GetServerByIP(client->GetServerIP(), client->GetServerPort()))
		{
			in_addr		addhost;

			addhost.S_un.S_addr = client->GetServerIP();

			CServer		*pServer = new CServer(client->GetServerPort(), CString(inet_ntoa(addhost)));

			pServer->SetListName(pServer->GetAddress());
			if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(pServer, true))
				delete pServer;
		}
	}

@


1.164
log
@Fractional upload/download limits (min 1 KB/s, granularity 0.1 KB/s).
@
text
@a1254 2
	EMULE_TRY

d1257 1
a1257 5
		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() < 40 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*3 < g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()))
			g_eMuleApp.m_pGlobPrefs->SetSCHShift1Download(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*3);

		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() < 100 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*4 < g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()))
			g_eMuleApp.m_pGlobPrefs->SetSCHShift1Download(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*4);
a1258 2

	EMULE_CATCH
a1262 2
	EMULE_TRY

d1265 1
a1265 5
		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() < 40 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*3 < g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()))
			g_eMuleApp.m_pGlobPrefs->SetSCHShift2Download(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*3);

		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() < 100 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*4 < g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()))
			g_eMuleApp.m_pGlobPrefs->SetSCHShift2Download(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*4);
a1266 2

	EMULE_CATCH
@


1.163
log
@Fixed extremely rare crash on exit {reported by Fixue - DK}.
@
text
@d301 1
a301 1
		sint32 realMaxULRatems = (g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024*timeSinceLastGaveDataMs)/1000;
d305 1
a305 1
		sint32 wantedNumberOfTotalUploads = max((uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_CLIENT_DATARATE*2)),
d534 1
a534 1
		if (numberOfUploads < (uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/UPLOAD_LOW_CLIENT_DR)+1)
d1148 3
a1150 3
					MessageText.Format( _T("SCHEDULER: switching to Shift 1 (Max Upload:%i Max Download:%i Max Connections:%i Max In 5 secs:%i)"),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download(),
d1180 3
a1182 3
						MessageText.Format( _T("SCHEDULER: switching to Shift 2 (Max Upload:%i Max Download:%i Max Connections:%i Max In 5 secs:%i)"),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download(),
d1259 1
a1259 1
		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() < 4 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*3 < g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()))
d1262 1
a1262 1
		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() < 10 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*4 < g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()))
d1275 1
a1275 1
		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() < 4 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*3 < g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()))
d1278 1
a1278 1
		if (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() < 10 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*4 < g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()))
@


1.162
log
@Own client type for eMule Plus clients; Removed unused class variables.
@
text
@d1243 3
@


1.161
log
@optimized datarate calcualtion for UL queue, removed unneeded code
@
text
@a53 1
	m_iDataRateAvg = 0;
d637 1
a637 1
		&& (client->GetClientSoft() == SO_EMULE || client->GetClientSoft() == SO_OLDEMULE) )
@


1.160
log
@List granuality is returned back.
@
text
@d53 1
a53 1
	m_iDataRate = 0;
a89 1
	m_lastCalculatedDataRateTick = 0;
d240 1
a240 1
    timeSinceLastGaveDataMs = curTick - m_lastGaveDataTick;
d252 1
a252 1
        }
d254 1
a254 1
        bool clientWasReady = false;
d256 6
a261 6
	    POSITION pos = uploadinglist.GetHeadPosition();
	    while (pos != NULL)
	    {
        // Get the client. Note! Also updates activeClientsListPos as a side effect
		    CUpDownClient* cur_client = uploadinglist.GetNext(pos);
            bool tempWantsMoreBandwidth;
d269 15
a283 31
            if (tempWantsMoreBandwidth == true)
                clientWasReady = true;
	    }

	    if (clientWasReady == false)
	    {
            if (m_guessedMaxBandwidth > 300)
		        m_guessedMaxBandwidth -= 200;
            else
                m_guessedMaxBandwidth = 100;
	    }
	    else
	    {
		    m_guessedMaxBandwidth += 200;
	    }

        m_MaxActiveClients = uploadinglist.GetCount();
    }
    else
    {
    // Normal case for limited upload.
        uint32		tempMaxActiveClients = 0;
        POSITION	activeClientsListPos = activeClients_list.GetHeadPosition();

        while (activeClientsListPos != NULL)
        {
            uint32 activeClientsSnapshot = activeClients_list.GetNext(activeClientsListPos);

            if (activeClientsSnapshot > tempMaxActiveClients)
                tempMaxActiveClients = activeClientsSnapshot;
        }
d285 18
a302 2
        m_MaxActiveClients = tempMaxActiveClients;
	    sint32 realMaxULRatems = (g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024*timeSinceLastGaveDataMs)/1000;
a304 1

d306 3
a308 2
        sint32 wantedNumberOfTotalUploads = max((uint32)(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024/(UPLOAD_CLIENT_DATARATE*2)), m_MaxActiveClients + MINNUMBEROFTRICKLEUPLOADS);
        wantedNumberOfTotalUploads = max(wantedNumberOfTotalUploads, m_MaxActiveClients*1.3);
d311 1
a311 1
        CUpDownClient	   *lastClient = NULL;
d313 4
a316 4
        if (lastpos != NULL)
        {
            lastClient = uploadinglist.GetAt(lastpos);
        }
d320 6
a325 5
    // Add or remove connections as needed. Mostly, this is controlled by the number of
    // fully active uploads.
		if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount() > 0
		&& wantedNumberOfTotalUploads > uploadinglist.GetCount() 
		&& (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS))
d344 6
a349 6
	        //    g_eMuleApp.m_pUploadQueue->AddClientToQueue(lastClient,true);
		        waitinglist.AddTail(lastClient);
		        lastClient->SetUploadState(US_ONUPLOADQUEUE);
		        lastClient->SendRankingInfo();
		        g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(lastClient);
		        g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d363 7
a369 7
        POSITION ulpos = uploadinglist.GetHeadPosition();
    // The loop that gives the fully activated connections data.
        while (ulpos != NULL && (allowedBandwidthThisCall > usedBandwidthThisCall) && wantsMoreBandWidth == false)
        {
        // Only allow this connection to take what has not already been taken
        // by the other connections above it in the list.
            uint32 allowedThisIteration = allowedBandwidthThisCall-usedBandwidthThisCall;
d371 1
a371 1
        // Get the client. Note! Also updates ulpos as a side effect.
d374 3
a376 3
        // Give data to the upload, if it wants it. Remember how much data we have given this call.
        // The connection wont take any data if it hasn't emptied its buffer since we last gave it data.
        // variable wantsMoreBandWidth is updated by this method (it is a ref bool&)
d384 2
a385 2
            slotcounter++;
	    }
d388 19
a406 17
    // Trickle the unneeded uploads (just give them enough to not time out)
    // Theese downloads are kept connected, in a ready-to-go state, just in case
    // one of the fully activated uploads completes/timeouts/ends.
    // As soon as there's a little bandwidth leftover, the first one of these
    // uploads will go to fully activated state
        POSITION trickle_client_pos = uploadinglist.FindIndex(slotcounter);
        while (trickle_client_pos != NULL)
        {
        // Get the client. Note! Also updates trickle_client_pos as a side effect.
	        CUpDownClient* cur_client = uploadinglist.GetNext(trickle_client_pos);

            if (cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick)
            {
            // It's more than 3 seconds since this connection got any data.
            // Feed it a mercy package to prevent it from timing out.
                bool tempWantsMoreData = false;
			// LANCAST - Increment LanCount
d411 2
a412 2
            }
        }
d414 16
a429 16
    // Since we don't save bandwidth for the trickles above, we may
    // have used to much bandwidth.
    // We may also have used to little bandwidth this round, in that
    // case it is saved to the next round.
        m_iLeftOverBandwidth = curMaxULRatems-usedBandwidthThisCall;

    // We don't want to long peaks. Don't save to much bandwidth (about a second should be OK)
    // Always make sure we can save enough to get a packet through
        sint32 limitSave = MAXFRAGSIZE; // max(realMaxULRatems*10, MAXFRAGSIZE+realMaxULRatems*4);
        if (m_iLeftOverBandwidth > limitSave)
            m_iLeftOverBandwidth = limitSave;

    // Save number of active clients for statistics
   	    activeClients_list.RemoveHead();
	    activeClients_list.AddTail(slotcounter);
    }
d432 1
a432 1
	if (m_averageTickList.empty() || curTick- m_averageTickList.front() >= 500)
d440 1
a440 1
   			m_averageDataRateList.pop_back();
d443 6
d451 1
a451 1
    m_lastGaveDataTick = curTick;
d457 2
a458 2
        bool clientWasReady = false;
	    POSITION pos = uploadinglist.GetHeadPosition();
d460 5
a464 5
	    while (pos != NULL)
	    {
        // Get the client. Note! Also updates activeClientsListPos as a side effect.
		    CUpDownClient* cur_client = uploadinglist.GetNext(pos);
            bool tempWantsMoreBandwidth = false;
d470 15
a484 15
            if (tempWantsMoreBandwidth == true)
                clientWasReady = true;
	    }

	    if (clientWasReady == false)
	    {
            if (m_guessedMaxLANBandwidth > 3000)
		        m_guessedMaxLANBandwidth -= 2000;
            else
               m_guessedMaxLANBandwidth = 1000;
	    }
	    else
	    {
		    m_guessedMaxLANBandwidth += 2000;
	    }
d490 1
a490 1
{
a598 28
uint32	CUploadQueue::GetDataRateShown()
{
	if (m_averageDataRateList.size() > 9)
	{
		deque<uint64>::iterator dr = m_averageDataRateList.begin();
		deque<DWORD>::iterator tick = m_averageTickList.begin();
		advance(dr,9);
		advance(tick,9);
		return (uint32)( (m_averageDataRateList.front() - (*dr))*1000.0f/(m_averageTickList.front() - (*tick)) );
	}
	else
		return GetDataRate();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32	CUploadQueue::GetDataRate()
{
// Calculate average data rate
    if (GetTickCount()-m_lastCalculatedDataRateTick > 1000)
    {
        if (m_averageDataRateList.size() > 1)
	        m_iDataRate = static_cast<uint32>(static_cast<double>(m_averageDataRateList.front()-m_averageDataRateList.back())*1000.0 / (m_averageTickList.front()-m_averageTickList.back()));
        else
            m_iDataRate = 0;
    }

    return m_iDataRate;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d1048 1
a1048 1
				g_eMuleApp.m_pdlgEmule->m_dlgStatistics.SetCurrentRate((static_cast<double>(g_eMuleApp.m_pUploadQueue->GetDataRateShown()))/1024.0,((double)g_eMuleApp.m_pDownloadQueue->GetDataRate())/1024);
@


1.159
log
@minor name correction
@
text
@d44 1
a44 1
CUploadQueue::CUploadQueue(CPreferences* in_prefs)
d588 1
a588 1
	return 0;
@


1.158
log
@rollback of old waiting queue
@
text
@d638 1
a638 1
void CUploadQueue::AddClientToQueue(CUpDownClient* client, bool bIgnoreTimelimit)
@


1.157
log
@fixed output in UL log
@
text
@d126 17
d144 2
a145 2
	CUpDownClient* pNewUploadClient = NULL;
	CKnownFile* m_pReqPartFile = NULL;
d147 26
a172 6
//	since waiting queue is sorted by score, we take the client with best score from the top
	if (pClient != NULL)
	{
		pNewUploadClient = pClient;
		m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pNewUploadClient->m_reqFileHash);
		if (m_pReqPartFile->IsPartFile() && ((CPartFile*)m_pReqPartFile)->GetStatus() == PS_COMPLETING)
d174 4
d180 1
a180 11
	{
		pNewUploadClient = GetClientWithBestWaitingScore();
		// if we don't found any client just return
		if (pNewUploadClient == NULL)
			return;
		else
		{
		//	remember the file that client requested
			m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pNewUploadClient->m_reqFileHash);
		}
	}
d182 1
a182 1
	if (!g_eMuleApp.m_pClientList->IsValidClient(pNewUploadClient))
d188 7
a194 1
	if (IsDownloading(pNewUploadClient) || pNewUploadClient->IsBanned(true))
d199 1
a199 1
	if (!pNewUploadClient->m_pRequestSocket || !pNewUploadClient->m_pRequestSocket->IsConnected())
d201 2
a202 2
		pNewUploadClient->SetUploadState(US_CONNECTING);
		if (!pNewUploadClient->TryToConnect(true))
d209 3
a211 3
		pNewUploadClient->m_pRequestSocket->SendPacket(packet,true);
		pNewUploadClient->SetUploadState(US_UPLOADING);
		pNewUploadClient->SetLastGotULData();
d215 4
a218 4
	pNewUploadClient->SetUpStartTime();
	pNewUploadClient->ResetSessionUp();
	pNewUploadClient->ResetCompressionGain();
	uploadinglist.AddTail(pNewUploadClient);
d224 1
a224 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.AddClient(pNewUploadClient);
d228 1
d250 1
a250 1
		if (CanAcceptNewClient(uploadinglist.GetCount()) && m_waitingList.size())
d323 1
a323 1
	if (CanAcceptNewClient(uploadinglist.GetCount()) && m_waitingList.size() > 0
d342 1
d344 6
a349 2
				if (lastClient->m_pReqPartFile != NULL)
					g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(lastClient, false);
d482 2
a483 4
	{
		ClientList::iterator clientIt;

		for (clientIt = m_waitingList.begin(); clientIt != m_waitingList.end(); clientIt++)
d485 1
a485 1
			CUpDownClient* pClientInQueue = *clientIt;
d487 2
a488 2
			if ( pClientInQueue->IsL2HACEnabled() && pClientInQueue->GetLastL2HACExecution() && pClientInQueue->GetL2HACTime()
				 && (curTick - pClientInQueue->GetLastL2HACExecution()) > pClientInQueue->GetL2HACTime() )
d491 1
a491 1
					 && !(pClientInQueue->m_pRequestSocket && pClientInQueue->m_pRequestSocket->IsConnected()) )
d493 1
a493 1
					 pClientInQueue->SetLastL2HACExecution(curTick - pClientInQueue->GetL2HACTime() + static_cast<uint32>(ROUND((static_cast<double>(rand())/RAND_MAX)*300000.0)));
d497 3
a499 3
					pClientInQueue->DisableL2HAC();
					if (!pClientInQueue->HasLowID() && pClientInQueue->GetL2HACTime())
						pClientInQueue->TryToConnect();
d563 11
d578 1
a578 3
	ClientList::iterator clientIt;

	for (clientIt = m_waitingList.begin(); clientIt != m_waitingList.end(); clientIt++)
d580 1
a580 1
		CUpDownClient* pClientInQueue = *clientIt;
d582 2
a583 2
		if (dwIP == pClientInQueue->GetIP() && dwPort == pClientInQueue->GetUDPPort())
			return pClientInQueue;
d588 1
a588 1
	return NULL;
d623 114
a736 2
	ClientList::iterator clientIt;
	uint32 dwCount=0;
d738 19
d758 2
a759 1
	for (clientIt = m_waitingList.begin(); clientIt != m_waitingList.end(); clientIt++)
d761 6
a766 1
		CUpDownClient* pClientInQueue = *clientIt;
d768 6
a773 2
		if (pClientInQueue->IsBanned())
			dwCount++;
d776 28
a803 1
	SetBanCount(dwCount);
d807 1
a807 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d889 1
a889 1

d899 21
a919 1
bool CUploadQueue::IsULPermitedByWaitingScore(CUpDownClient* pClient)
d921 10
a930 2
	bool bIsULPermited = false;
	CUpDownClient* pBestClient = m_waitingList.front();
d932 15
a946 1
	if (pClient->GetWaitingScore() >= pBestClient->GetWaitingScore())
d948 2
a949 1
		bIsULPermited = true;
d952 3
a954 1
	return bIsULPermited;
d961 1
a961 1
	m_waitingList.clear();
d967 22
d1218 27
d1324 1
a1324 1
void CUploadQueue::CheckAndAddClientToWaitingQueue(CUpDownClient* pClient)
d1326 1
a1326 97
	EMULE_TRY

	const int iWaitingUsers = GetWaitingUserCount();

//	check if queue is full
	if (iWaitingUsers > g_eMuleApp.m_pGlobPrefs->GetQueueSize() && !pClient->IsFriend())
		return;

#ifdef OLD_SOCKETS_ENABLED
//	If we're connected to the server, and we're LOWID, and the client is on a remote server and is not downloading
//	and is not a friend and the queue is longer than 50...
	if ( g_eMuleApp.m_pServerConnect->IsConnected()
		&& g_eMuleApp.m_pServerConnect->IsLowID()
		&& !g_eMuleApp.m_pServerConnect->IsLocalServer(pClient->GetServerIP(), pClient->GetServerPort())
		&& pClient->GetDownloadState() == DS_NONE
		&& !pClient->IsFriend()
		&& iWaitingUsers > 50 )
	{
		return;
	}
#endif //OLD_SOCKETS_ENABLED

//	L2HAC- lowid side
	pClient->SetLastL2HACExecution();
	if (!pClient->HasLowID() && pClient->GetL2HACTime()) pClient->EnableL2HAC();

//	LANCAST - We ignore any ban LAN clients may have
	if (!pClient->IsOnLAN())
	{
		if (pClient->IsBanned())
		{
			if (GetTickCount() - pClient->GetBanTime() > g_eMuleApp.m_pGlobPrefs->BadClientBanTime())
				pClient->UnBan();
			else
				return;
		}
	}

//	if client is not on the queue, then assume we add him to queue now,
//	i.e. set start wait time to current tick
	if (pClient->GetPosInWaitingQueue() == 0)
	{
		pClient->SetWaitStartTime();
	}

//	if client is has same score & he inside the queue just return
	uint32 dwPrevWaitingScore = pClient->GetWaitingScore();
	uint32 dwNewWaitingScore = pClient->CalculateWaitingScore();

	if (pClient->GetPosInWaitingQueue() != 0 
		&& dwPrevWaitingScore == dwNewWaitingScore)
	{
		return;
	}

//	add client to waiting queue
	bool bIsClientInserted = AddClientToWaitingQueue(pClient);

//	Use some information from client & add clients server to list.
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && pClient->GetServerIP() && pClient->GetServerPort())
	{
	//	If the server isn't already in our server list ...
		if ( (pClient->GetServerIP() != 0) && !g_eMuleApp.m_pServerList->GetServerByIP(pClient->GetServerIP(), pClient->GetServerPort()))
		{
			in_addr		addhost;

			addhost.S_un.S_addr = pClient->GetServerIP();

			CServer		*pServer = new CServer(pClient->GetServerPort(), CString(inet_ntoa(addhost)));

			pServer->SetListName(pServer->GetAddress());
			if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(pServer, true))
				delete pServer;
		}
	}

	if (pClient->IsDownloading())
	{
	//	He's already downloading and wants probably only another file
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		pClient->m_pRequestSocket->SendPacket(packet,true);
#endif //OLD_SOCKETS_ENABLED
		pClient->SetLastGotULData();
	}
//	LANCAST - Lan users bypass the queue
	else if (pClient->IsOnLAN())
	{
		AddClientToUploadQueue(pClient);
	}
	else if (bIsClientInserted)
	{
		pClient->SendRankingInfo();
	}

	EMULE_CATCH
d1329 1
a1329 1
bool CUploadQueue::AddClientToWaitingQueue(CUpDownClient* pClient, bool bCheckDeadClients)
d1331 1
a1331 207
	EMULE_TRY

//	put the client in the sorted queue
	const uint32 dwCurrentTime = ::GetTickCount();
	uint16 uPositionInQueue = 0;
	uint16 uPositionInsertedClientInQueue = 0;
	ClientDeque DisconnectedClientsDeque;
	bool bIsClientInserted = false;
	bool bIsClientRemoved = false;
	bool bRequiredWQUpdate = false;

	CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);

	if (m_waitingList.empty())
	{
		m_waitingList.push_back(pClient);
		pClient->SetPosInWaitingQueue(1);
		bIsClientInserted = true;
	}
	else
	{
		ClientList::iterator clientWasInsertedIt = m_waitingList.end();
		ClientList::iterator clientIt = m_waitingList.begin();

		while (clientIt != m_waitingList.end())
		{
			CUpDownClient* pClientInQueue = *clientIt;

		//	Check if client already exists
			if (!bIsClientRemoved && pClientInQueue == pClient)
			{
			//	remove the client, without postion update, cause client will be reinserted
				clientIt = m_waitingList.erase(clientIt);
			//	mark that client was removed
				bIsClientRemoved = true;
				continue;
			}
			else if (bCheckDeadClients 
				&&!bIsClientRemoved 
				&& pClient->Compare(pClientInQueue)) // Another client with same ip or hash
			{
				if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) == IS_IDENTIFIED 
					&& pClientInQueue->m_pCredits->GetCurrentIdentState(pClientInQueue->GetIP()) != IS_IDENTIFIED)
				{
					AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
									pClient->GetUserName(), pClient->GetClientNameAndVersionString(),
									pClientInQueue->GetUserName(), pClientInQueue->GetClientNameAndVersionString(), pClientInQueue->GetUserName() );
				//	remove the client from the queue
					clientIt = m_waitingList.erase(clientIt);
					pClientInQueue->SetPosInWaitingQueue(0);
				//	update the GUI
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				}
				else if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) != IS_IDENTIFIED 
					&& pClientInQueue->m_pCredits->GetCurrentIdentState(pClientInQueue->GetIP()) == IS_IDENTIFIED)
				{
					AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
									pClient->GetUserName(), pClient->GetClientNameAndVersionString(),
									pClientInQueue->GetUserName(), pClientInQueue->GetClientNameAndVersionString(), pClient->GetUserName() );
				//	if client wa already inserted, then use save position to remove him
					if (bIsClientInserted)
					{
						clientIt = m_waitingList.erase(clientWasInsertedIt);
						pClient->SetPosInWaitingQueue(0);
						uPositionInQueue = --uPositionInsertedClientInQueue;
						bIsClientRemoved = true;
					}
				//	otherwise just prevent client from reinsertion
					else
						bIsClientInserted = true;
				}
				else if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) != IS_IDENTIFIED 
					&& pClientInQueue->m_pCredits->GetCurrentIdentState(pClientInQueue->GetIP()) != IS_IDENTIFIED)
				{
					AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed both"),
									pClient->GetUserName(), pClient->GetClientNameAndVersionString(),
									pClientInQueue->GetUserName(), pClientInQueue->GetClientNameAndVersionString() );
					clientIt = m_waitingList.erase(clientIt);
					pClientInQueue->SetPosInWaitingQueue(0);
				//	update the GUI
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				//	if client wa already inserted, then use save position to remove him
					if (bIsClientInserted)
					{
						clientIt = m_waitingList.erase(clientWasInsertedIt);
						pClient->SetPosInWaitingQueue(0);
						uPositionInQueue = --uPositionInsertedClientInQueue;
						
					}
				//	otherwise just prevent client from reinsertion
					else
						bIsClientInserted = true;
					bIsClientRemoved = true;
				}
				else if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) == IS_IDENTIFIED 
					&& pClientInQueue->m_pCredits->GetCurrentIdentState(pClientInQueue->GetIP()) == IS_IDENTIFIED)
				{
					AddDebugLogLine( RGB_LOG_DIMMED + _T("Identified client '%s' (%s) and '%s' (%s) have the same Userhash or IP, removed '%s'"),
									pClient->GetUserName(), pClient->GetClientNameAndVersionString(),
									pClientInQueue->GetUserName(), pClientInQueue->GetClientNameAndVersionString(), pClientInQueue->GetUserName());
				//	remove the client from the queue
					clientIt = m_waitingList.erase(clientIt);
					pClientInQueue->SetPosInWaitingQueue(0);
				//	update the GUI
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				}
				else
				{
				//	remove the client from the queue
					clientIt = m_waitingList.erase(clientIt);
					pClientInQueue->SetPosInWaitingQueue(0);
				//	update the GUI
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				}

				bRequiredWQUpdate = true;

	#ifdef OLD_SOCKETS_ENABLED
				if (pClientInQueue->m_pRequestSocket == NULL)
				{
					DisconnectedClientsDeque.push_back(pClientInQueue);
				}
	#endif //OLD_SOCKETS_ENABLED
				continue;
			}

		//	dead client check (no response from client during MAX_PURGEQUEUETIME)
			if (bCheckDeadClients &&
				(dwCurrentTime - pClientInQueue->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
			{
				clientIt = m_waitingList.erase(clientIt);
				pClientInQueue->SetPosInWaitingQueue(0);
			//	update the GUI
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				bRequiredWQUpdate = true;
	#ifdef OLD_SOCKETS_ENABLED
				if (!pClientInQueue->m_pRequestSocket)
				{
					DisconnectedClientsDeque.push_back(pClientInQueue);
				}
	#endif //OLD_SOCKETS_ENABLED
				continue;
			}
			uPositionInQueue++;
		//	if the client is not LAN client & is not inserted
			if (!pClient->IsOnLAN() && !bIsClientInserted)
			{
				if (pClientInQueue->GetWaitingScore() < pClient->GetWaitingScore())
				{
					clientWasInsertedIt = m_waitingList.insert(clientIt, pClient);
					pClient->SetUploadState(US_ONUPLOADQUEUE);
					pClientInQueue = pClient;
					bIsClientInserted = true;
				//	remember inserted  iterator position
					clientIt = clientWasInsertedIt;
					uPositionInsertedClientInQueue = uPositionInQueue;
				}
			}

			if (bRequiredWQUpdate || bIsClientRemoved || bIsClientInserted)
			{
				pClientInQueue->SetPosInWaitingQueue(uPositionInQueue);
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClientInQueue);
			}
		//	update iterator
			clientIt++;
		}

	//	if scan of the list was done but client was not inserted, then client should be added at the end of queue
		if (!bIsClientInserted)
		{
			m_waitingList.push_back(pClient);
			uPositionInQueue++;
			pClient->SetPosInWaitingQueue(uPositionInQueue);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
			bIsClientInserted = true;
		}
	}

	lockWQueue.Unlock();

//	disconnect the clients outside the lock
	while (!DisconnectedClientsDeque.empty())
	{
		CUpDownClient* pDiconnectedClient = DisconnectedClientsDeque.front();

		pDiconnectedClient->Disconnected();
		DisconnectedClientsDeque.pop_front();
	}

//	if client was not removed before reinsertion, then it's a new client. so ad him to the GUI list
	if (bIsClientInserted && !bIsClientRemoved)
	{
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(pClient);
	}

//	check if some client was deleted due timeout or new client was inserted
	if (bRequiredWQUpdate || bIsClientInserted)
	{
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
	}

	return bIsClientInserted;

	EMULE_CATCH

	return false;
a1333 273
bool CUploadQueue::RemoveClientFromWaitingQueue(CUpDownClient* pClient)
{
	EMULE_TRY

	uint16 uPositionInQueue = 0;
	bool bIsClientRemoved = false;
	uint32 dwBannedCount=0;


	if (!m_waitingList.empty())
	{
		CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);

		ClientList::iterator clientIt = m_waitingList.begin();

		while (clientIt != m_waitingList.end())
		{
			CUpDownClient* pClientInQueue = *clientIt;

			if (!bIsClientRemoved && pClientInQueue == pClient)
			{
			//	remove the client
				clientIt = m_waitingList.erase(clientIt);
			//	mark that client was removed
				bIsClientRemoved = true;
			//	set the queue position to 0 (clien is outside the queue now)
				pClientInQueue->SetPosInWaitingQueue(0);
			//	update the client state
				pClientInQueue->SetUploadState(US_NONE);
			//	update the GUI
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				continue;
			}

			uPositionInQueue++;
		//	update the position for the rest of clients
			pClientInQueue->SetPosInWaitingQueue(uPositionInQueue);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClientInQueue);
		//	count the banned clients
			if (pClientInQueue->IsBanned())
				dwBannedCount++;
		//	update iterator
			clientIt++;
		}

		lockWQueue.Unlock();

		if (bIsClientRemoved 
			|| dwBannedCount != GetBanCount() )
		{
			SetBanCount(dwBannedCount);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
		}
	}

	return bIsClientRemoved;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::UpdateClientInWaitingQueue(CUpDownClient* pClient)
{
//	calculate the waiting score of  new client
//	if client is inside the queue and has same score just return
	uint32 dwPrevWaitingScore = pClient->GetWaitingScore();

	if (pClient->GetPosInWaitingQueue() != 0 
		&& dwPrevWaitingScore == pClient->CalculateWaitingScore())
	{
		return;
	}

//	put the client in the sorted queue
	ClientDeque DisconnectedClientsDeque;
	const uint32 dwCurrentTime = ::GetTickCount();
	uint16 uPositionInQueue = 0;
	bool bIsClientInserted = false;
	bool bIsClientRemoved = false;
	bool bRequiredWQUpdate = false;

	if (!m_waitingList.empty())
	{
		CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);

		ClientList::iterator clientIt = m_waitingList.begin();

		while (clientIt != m_waitingList.end())
		{
			CUpDownClient* pClientInQueue = *clientIt;

		//	Check if client already exists
			if (!bIsClientRemoved && pClientInQueue == pClient)
			{
			//	remove the client, without postion update, cause client will be reinserted
				clientIt = m_waitingList.erase(clientIt);
			//	mark that client was removed
				bIsClientRemoved = true;
				continue;
			}

		//	dead client check (no response from client during MAX_PURGEQUEUETIME)
			if ((dwCurrentTime - pClientInQueue->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
			{
				clientIt = m_waitingList.erase(clientIt);
				pClientInQueue->SetPosInWaitingQueue(0);
			//	update the GUI
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				bRequiredWQUpdate = true;
#ifdef OLD_SOCKETS_ENABLED
				if (!pClientInQueue->m_pRequestSocket)
				{
					DisconnectedClientsDeque.push_back(pClientInQueue);
				}
#endif //OLD_SOCKETS_ENABLED
				continue;
			}
		//	update position i the queue
			uPositionInQueue++;
		//	if the client is not LAN client & is not inserted
			if (!bIsClientInserted)
			{
				if (pClientInQueue->GetWaitingScore() < pClient->GetWaitingScore())
				{
					clientIt = m_waitingList.insert(clientIt, pClient);
					pClient->SetPosInWaitingQueue(uPositionInQueue);
					pClient->SendRankingInfo();
					pClientInQueue = pClient;
					bIsClientInserted = true;
				}
			}

			if (bRequiredWQUpdate || bIsClientRemoved || bIsClientInserted)
			{
				pClientInQueue->SetPosInWaitingQueue(uPositionInQueue);
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClientInQueue);
			}
		//	update iterator
			clientIt++;
		}

	//	if scan of the list was done but client was not inserted, then client should be added at the end of queue
		if (!bIsClientInserted)
		{
			m_waitingList.push_back(pClient);
			uPositionInQueue++;
			pClient->SetPosInWaitingQueue(uPositionInQueue);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
		}

		lockWQueue.Unlock();

	//	disconnect the clients outside the lock
		while (!DisconnectedClientsDeque.empty())
		{
			CUpDownClient* pDisconnectedClient = DisconnectedClientsDeque.front();

			pDisconnectedClient->Disconnected();
			DisconnectedClientsDeque.pop_front();
		}

	//	check if some client was deleted due timeout
		if (bRequiredWQUpdate)
		{
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
		}
	}

}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CUploadQueue::GetClientWithBestWaitingScore()
{
	EMULE_TRY

	CKnownFile* m_pReqPartFile = NULL;
	CUpDownClient* pClientWithBestWaitingScore = NULL;
	uint16 uPositionInQueue = 0;
	bool bIsClientRemoved = false;

	if (!m_waitingList.empty())
	{
		CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);

		ClientList::iterator clientIt = m_waitingList.begin();

		while (clientIt != m_waitingList.end())
		{
			CUpDownClient* pClientInQueue = *clientIt;

			// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour
			// since is not fair to throw client from waiting queue, we gonna leave him in the queue & go to the next client
			if (!bIsClientRemoved)
			{
				m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pClientInQueue->m_reqFileHash);
			//	if we don't have the file that this client requested before, the we return him as client best score client
			//	in order to provide him last chance request another file
				if (m_pReqPartFile == NULL
					|| ( !m_pReqPartFile->IsPartFile() 
						|| ((CPartFile*)m_pReqPartFile)->GetStatus() != PS_COMPLETING))
				{
				//	remember the client
					pClientWithBestWaitingScore = pClientInQueue;
				//	remove the client
					clientIt = m_waitingList.erase(clientIt);
				//	mark that client was removed
					bIsClientRemoved = true;
				//	set the queue position to 0 (clien is outside the queue now)
					pClientInQueue->SetPosInWaitingQueue(0);
				//	update the client state
					pClientInQueue->SetUploadState(US_NONE);
				//	update the GUI
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
					continue;
				}
			}
		//	update the position for the rest of clients
			uPositionInQueue++;
			pClientInQueue->SetPosInWaitingQueue(uPositionInQueue);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClientInQueue);

		//	update iterator
			clientIt++;
		}

		lockWQueue.Unlock();

	//	update the GUI
		if (bIsClientRemoved)
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
	}


	return pClientWithBestWaitingScore;

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::GetSourcesFromWaitingQueueByFileID(ClientDeque* pSourcesDeque, const uchar* filehash)
{
	EMULE_TRY

	ClientList::iterator clientIt;

	for (clientIt = m_waitingList.begin(); clientIt != m_waitingList.end(); clientIt++)
	{
		CUpDownClient* pPotentialSource = *clientIt;

		if (md4cmp(pPotentialSource->m_reqFileHash, filehash) == 0)
			pSourcesDeque->push_back(pPotentialSource);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::GetSourcesFromUploadQueueByFileID(ClientDeque* pSourcesDeque, const uchar* filehash)
{
	EMULE_TRY

	POSITION pos = uploadinglist.GetHeadPosition();

	while (pos != NULL)
	{
		CUpDownClient	   *pPotentialSource = uploadinglist.GetNext(pos);

		if (md4cmp(pPotentialSource->m_reqFileHash, filehash) == 0)
			pSourcesDeque->push_back(pPotentialSource);
	}

	EMULE_CATCH
}
@


1.156
log
@1) the agressivity check moved in ListenSocket
2) optimized client addition to the waiting queue
@
text
@d646 1
a646 1
										client->GetTransferredUp(),
d652 3
a654 3
										(client->GetTransferredUp() >= PARTSIZE) ? 
										 GetResString(IDS_IDENTOK).MakeLower() : 
										 g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason) );
@


1.155
log
@1) locked was moved (thanks Aw3)
2) update of bancount under lock was changed
3) some name changes, which can lead to unpredictable problems
@
text
@d196 2
a197 2
    DWORD curTick = ::GetTickCount();
    int timeSinceLastGaveDataMs;
d289 2
a290 2
        // There's not enough open uploads. Open more another one.
            AddClientToUploadQueue();
d292 2
a293 2
		else if (uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED &&
                CanAcceptNewClient(uploadinglist.GetCount()-1) == false)
d295 6
a300 6
        // There's to many open uploads (propably due to the user changing
        // the upload limit to a lower value). Remove the last opened upload and put
        // it back on the waitinglist. When it is put back, it get
        // to keep its waiting time. This means it is likely to soon be
        // choosen for upload again.
            if (!lastClient->IsOnLAN() && lastClient->GetUpStartTimeDelay() > 3*1000)
d302 7
a308 2
	        // Remove from upload list.
		        g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(lastClient, ETS_TIMEOUT, true);
d310 4
a313 9
	        // add to queue again. This is almost the same as in method
	        	g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(lastClient);
            }
        }

    // There's some saved bandwidth that we want to try to spend this round.
    // curMaxULRatems keeps track of how much data we want to spend.
        sint32 curMaxULRatems = realMaxULRatems + m_iLeftOverBandwidth;
        sint32 allowedBandwidthThisCall = min(curMaxULRatems, realMaxULRatems+MAXFRAGSIZE);
d315 2
a316 2
    // Which active slot are we giving data each loop
        uint32 slotcounter = 0;
d318 1
a318 1
        bool wantsMoreBandWidth = false;
d1012 1
a1012 1
void CUploadQueue::AddClientToWaitingQueue(CUpDownClient* pClient)
d1016 5
a1020 1
	const uint32 dwCurrentTime = ::GetTickCount();
d1030 1
a1030 1
		&& GetWaitingUserCount() > 50 )
a1049 1
		pClient->AddRequestCount(pClient->m_reqFileHash);
d1069 48
d1118 1
d1152 3
a1154 1
			else if (!bIsClientRemoved && pClient->Compare(pClientInQueue)) // Another client with same ip or hash
d1242 2
a1243 1
			if ((dwCurrentTime - pClientInQueue->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
d1265 1
d1305 6
d1317 1
a1317 7
//	Use some information from client & add clients server to list.
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && pClient->GetServerIP() && pClient->GetServerPort())
	{
	//	If the server isn't already in our server list ...
		if ( (pClient->GetServerIP() != 0) && !g_eMuleApp.m_pServerList->GetServerByIP(pClient->GetServerIP(), pClient->GetServerPort()))
		{
			in_addr		addhost;
d1319 1
a1319 1
			addhost.S_un.S_addr = pClient->GetServerIP();
d1321 1
a1321 37
			CServer		*pServer = new CServer(pClient->GetServerPort(), CString(inet_ntoa(addhost)));

			pServer->SetListName(pServer->GetAddress());
			if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(pServer, true))
				delete pServer;
		}
	}

	if (pClient->IsDownloading())
	{
	//	He's already downloading and wants probably only another file
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		pClient->m_pRequestSocket->SendPacket(packet,true);
#endif //OLD_SOCKETS_ENABLED
		pClient->SetLastGotULData();
	}
//	LANCAST - Lan users bypass the queue
	else if (pClient->IsOnLAN())
	{
		AddClientToUploadQueue(pClient);
	}
	else if (bIsClientInserted)
	{
		pClient->SetUploadState(US_ONUPLOADQUEUE);
		pClient->SendRankingInfo();
	//	if client was not removed before reinsertion, then it's a new client
		if (!bIsClientRemoved)
		{
//			pClient->SetWaitStartTime();
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
		}
	}

	EMULE_CATCH
@


1.154
log
@correction after merge, no influence to the code
@
text
@d1069 1
d1074 2
a1083 3
		CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);

		ClientDeque DisconnectedClientsDeque;
d1236 1
d1238 1
a1238 1
		lockWQueue.Unlock();
d1240 4
a1243 4
	//	disconnect the clients outside the lock
		while (!DisconnectedClientsDeque.empty())
		{
			CUpDownClient* pClient = DisconnectedClientsDeque.front();
d1245 2
a1246 3
			pClient->Disconnected();
			DisconnectedClientsDeque.pop_front();
		}
d1310 2
a1328 3
			//	unban the client
				if (pClientInQueue->IsBanned())
					pClientInQueue->UnBan();
d1342 3
d1351 4
a1354 1
		if (bIsClientRemoved)
d1356 1
d1460 1
a1460 1
			CUpDownClient* pClient = DisconnectedClientsDeque.front();
d1462 1
a1462 1
			pClient->Disconnected();
@


1.153
log
@fixed bug :) blame on me & thanks to DopeFish
@
text
@a1013 2
//	calcualte a client score
{
a1302 1
}
@


1.152
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d1496 5
a1500 1
				if (!m_pReqPartFile->IsPartFile() || ((CPartFile*)m_pReqPartFile)->GetStatus() != PS_COMPLETING)
a1507 3
				//	unban the client
					if (pClientInQueue->IsBanned())
						pClientInQueue->UnBan();
@


1.151
log
@SSWQ
@
text
@a932 27
void CUploadQueue::FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, const uchar* filehash)
{
	EMULE_TRY

	POSITION pos = uploadinglist.GetHeadPosition();

	while (pos)
	{
		CUpDownClient	   *pPotentialSource = uploadinglist.GetNext(pos);

		if (md4cmp(pPotentialSource->m_reqFileHash, filehash) == 0)
			srclist->AddTail(pPotentialSource);
	}

	ClientList::iterator clientIt;

	for (clientIt = m_waitingList.begin(); clientIt != m_waitingList.end(); clientIt++)
	{
		CUpDownClient* pPotentialSource = *clientIt;

		if (md4cmp(pPotentialSource->m_reqFileHash, filehash) == 0)
			srclist->AddTail(pPotentialSource);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d958 1
a958 1

a1067 2
	CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);

d1083 3
d1183 1
a1183 4
					if (pClientInQueue->Disconnected())
					{
						pClientInQueue = NULL;
					}
d1200 1
a1200 4
					if (pClientInQueue->Disconnected())
					{
						pClientInQueue = NULL;
					}
d1239 4
a1242 2
	//	check if some client was deleted due timeout
		if (bRequiredWQUpdate)
d1244 4
a1247 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d1251 5
a1255 1
	lockWQueue.Unlock();
d1314 5
a1318 1
	CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);
d1320 3
a1322 1
	ClientList::iterator clientIt = m_waitingList.begin();
d1324 17
a1340 3
	while (clientIt != m_waitingList.end())
	{
		CUpDownClient* pClientInQueue = *clientIt;
d1342 6
a1347 17
		if (!bIsClientRemoved && pClientInQueue == pClient)
		{
		//	remove the client
			clientIt = m_waitingList.erase(clientIt);
		//	mark that client was removed
			bIsClientRemoved = true;
		//	unban the client
			if (pClientInQueue->IsBanned())
				pClientInQueue->UnBan();
		//	set the queue position to 0 (clien is outside the queue now)
			pClientInQueue->SetPosInWaitingQueue(0);
		//	update the client state
			pClientInQueue->SetUploadState(US_NONE);
		//	update the GUI
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
			continue;
d1350 4
a1353 6
		uPositionInQueue++;
	//	update the position for the rest of clients
		pClientInQueue->SetPosInWaitingQueue(uPositionInQueue);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClientInQueue);
	//	update iterator
		clientIt++;
d1376 1
d1414 1
a1414 4
					if (pClientInQueue->Disconnected())
					{
						pClientInQueue = NULL;
					}
d1451 17
a1469 5
//	check if some client was deleted due timeout
	if (bRequiredWQUpdate)
	{
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
	}
d1481 3
a1483 1
	CSingleLock lockWQueue(&m_csWaitingQueue, TRUE);
d1485 1
a1485 1
	ClientList::iterator clientIt = m_waitingList.begin();
d1487 3
a1489 3
	while (clientIt != m_waitingList.end())
	{
		CUpDownClient* pClientInQueue = *clientIt;
d1491 3
a1493 6
		// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour
		// since is not fair to throw client from waiting queue, we gonna leave him in the queue & go to the next client
		if (!bIsClientRemoved)
		{
			m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pClientInQueue->m_reqFileHash);
			if (!m_pReqPartFile->IsPartFile() || ((CPartFile*)m_pReqPartFile)->GetStatus() != PS_COMPLETING)
d1495 20
a1514 17
			//	remember the client
				pClientWithBestWaitingScore = pClientInQueue;
			//	remove the client
				clientIt = m_waitingList.erase(clientIt);
			//	mark that client was removed
				bIsClientRemoved = true;
			//	unban the client
				if (pClientInQueue->IsBanned())
					pClientInQueue->UnBan();
			//	set the queue position to 0 (clien is outside the queue now)
				pClientInQueue->SetPosInWaitingQueue(0);
			//	update the client state
				pClientInQueue->SetUploadState(US_NONE);
			//	update the GUI
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(pClientInQueue);
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
				continue;
d1516 7
a1523 4
	//	update the position for the rest of clients
		uPositionInQueue++;
		pClientInQueue->SetPosInWaitingQueue(uPositionInQueue);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClientInQueue);
d1525 5
a1529 2
	//	update iterator
		clientIt++;
d1532 1
@


1.150
log
@Preparations for new client version report code.
@
text
@d44 1
a44 1
CUploadQueue::CUploadQueue(CPreferences* in_prefs) : waitinglist(100)
d123 1
a123 1
void CUploadQueue::AddUpNextClient(CUpDownClient* directadd)
a125 7
#ifdef OLD_SOCKETS_ENABLED
	if (g_eMuleApp.m_pListenSocket->TooManySockets())
		return;
#endif //OLD_SOCKETS_ENABLED
	POSITION toadd = 0;
	uint32	bestscore = 0;
	CUpDownClient* pNewSource;
d127 12
a138 2
// Select next client or use given client
	if (!directadd)
d140 5
a144 4
		POSITION pos1, pos2;
		CUpDownClient* pSource;

		for (pos1 = waitinglist.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d146 2
a147 29
			pSource  = waitinglist.GetNext(pos1);

		// Clear dead clients
			ASSERT(pSource->GetLastUpRequest());

		// Remove "?" from queue
			if ( (::GetTickCount() - pSource->GetLastUpRequest() > MAX_PURGEQUEUETIME)
				|| !g_eMuleApp.m_pSharedFilesList->GetFileByID(pSource->m_reqFileHash) )
			{
				RemoveFromWaitingQueue(pos2,true);
#ifdef OLD_SOCKETS_ENABLED
				if (!pSource->m_pRequestSocket)
				{
					if (pSource->Disconnected())
						pSource = NULL;
				}
#endif //OLD_SOCKETS_ENABLED
				continue;
			}
		// Finished clearing
			else if ( (pSource->GetScore(true) > bestscore) && (!pSource->IsBanned())  && (!pSource->HasLowID()
#ifdef OLD_SOCKETS_ENABLED
				|| (pSource->m_pRequestSocket && pSource->m_pRequestSocket->IsConnected())
#endif //OLD_SOCKETS_ENABLED
				) )
			{
				bestscore = pSource->GetScore(true);
				toadd = pos2;
			}
a148 6
		if (!toadd)
			return;

		pNewSource = waitinglist.GetAt(toadd);
		RemoveFromWaitingQueue(toadd, true);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
a149 2
	else
		pNewSource = directadd;
d151 1
a151 1
  	if (!g_eMuleApp.m_pClientList->IsValidClient(pNewSource))
d157 1
a157 7
	if (IsDownloading(pNewSource) || pNewSource->IsBanned(true))
		return;

// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour
// (the existence of the requested file will be done in AddClientToQueue)
	CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pNewSource->m_reqFileHash);
	if (m_pReqPartFile->IsPartFile() && ((CPartFile*)m_pReqPartFile)->GetStatus() == PS_COMPLETING)
d162 1
a162 1
	if (!pNewSource->m_pRequestSocket || !pNewSource->m_pRequestSocket->IsConnected())
d164 2
a165 2
		pNewSource->SetUploadState(US_CONNECTING);
		if (!pNewSource->TryToConnect(true))
d172 3
a174 3
		pNewSource->m_pRequestSocket->SendPacket(packet,true);
		pNewSource->SetUploadState(US_UPLOADING);
		pNewSource->SetLastGotULData();
d178 4
a181 4
	pNewSource->SetUpStartTime();
	pNewSource->ResetSessionUp();
	pNewSource->ResetCompressionGain();
	uploadinglist.AddTail(pNewSource);
d187 1
a187 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.AddClient(pNewSource);
d191 1
a191 1

d212 1
a212 1
        if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount())
d214 1
a214 1
		    AddUpNextClient();
d285 3
a287 3
        if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount() > 0 &&
           wantedNumberOfTotalUploads > uploadinglist.GetCount() &&
           (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS))
d290 1
a290 1
            AddUpNextClient();
d306 1
a306 6
	        //    g_eMuleApp.m_pUploadQueue->AddClientToQueue(lastClient,true);
		        waitinglist.AddTail(lastClient);
		        lastClient->SetUploadState(US_ONUPLOADQUEUE);
		        lastClient->SendRankingInfo();
		        g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(lastClient, false);
		        g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d440 3
a442 1
		for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
d444 1
a444 1
			CUpDownClient* pSource = waitinglist.GetNext(pos);
d446 2
a447 2
			if ( pSource->IsL2HACEnabled() && pSource->GetLastL2HACExecution() && pSource->GetL2HACTime()
				 && (curTick - pSource->GetLastL2HACExecution()) > pSource->GetL2HACTime() )
d450 1
a450 1
					 && !(pSource->m_pRequestSocket && pSource->m_pRequestSocket->IsConnected()) )
d452 1
a452 1
					 pSource->SetLastL2HACExecution(curTick - pSource->GetL2HACTime() + static_cast<uint32>(ROUND((static_cast<double>(rand())/RAND_MAX)*300000.0)));
d456 3
a458 3
					pSource->DisableL2HAC();
					if (!pSource->HasLowID() && pSource->GetL2HACTime())
						pSource->TryToConnect();
d521 2
a522 2

POSITION CUploadQueue::GetWaitingClient(CUpDownClient* client)
d526 1
a526 1
	return waitinglist.Find(client);
d528 1
a528 10
	EMULE_CATCH

	return 0;
}

CUpDownClient* CUploadQueue::GetWaitingClientByIP_UDP(uint32 dwIP, uint16 dwPort)
{
	EMULE_TRY

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
d530 1
a530 1
		CUpDownClient* pSource = waitinglist.GetNext(pos);
d532 2
a533 2
		if (dwIP == pSource->GetIP() && dwPort == pSource->GetUDPPort())
			return pSource;
d538 1
a538 1
	return 0;
d540 1
a540 1

d554 1
a554 1

d568 1
a568 2


d573 2
a574 9
	int count=0;

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
	{
		CUpDownClient	   *pSource = waitinglist.GetNext(pos);

		if (pSource->IsBanned())
			count++;
	}
a575 1
	SetBanCount(count);
d577 1
a577 16
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUploadQueue::AddClientToQueue(CUpDownClient* client, bool bIgnoreTimelimit)
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
//	If we're connected to the server, and we're LOWID, and the client is on a remote server and is not downloading
//	and is not a friend and the queue is longer than 50...
	if ( g_eMuleApp.m_pServerConnect->IsConnected()
		&& g_eMuleApp.m_pServerConnect->IsLowID()
		&& !g_eMuleApp.m_pServerConnect->IsLocalServer(client->GetServerIP(),client->GetServerPort())
		&& client->GetDownloadState() == DS_NONE
		&& !client->IsFriend()
		&& GetWaitingUserCount() > 50 )
d579 1
a579 10
		return;
	}
#endif //OLD_SOCKETS_ENABLED

//	Check if file was requested with OP_SETREQFILEID, OP_FILEREQUEST or OP_STARTUPLOADREQ
	CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);

//	If file wasn't requested
	if (!m_pReqPartFile)
		return;
d581 2
a582 25
//	Filtering invalid eMule clients
	if ( client->GetMuleVersion() == 0 && client->GetVersion() == 0
		&& (client->GetClientSoft() == SO_EMULE || client->GetClientSoft() == SO_OLDEMULE) )
	{
		return;
	}

	client->AddAskedCount();
	client->SetLastUpRequest();

//	L2HAC- lowid side
	client->SetLastL2HACExecution();
	if (!client->HasLowID() && client->GetL2HACTime()) client->EnableL2HAC();

//	LANCAST - We ignore any ban LAN clients may have
	if (!bIgnoreTimelimit && !client->IsOnLAN())
	{
		if (client->IsBanned())
		{
			if (GetTickCount() - client->GetBanTime() > g_eMuleApp.m_pGlobPrefs->BadClientBanTime())
				client->UnBan();
			else
				return;
		}
		client->AddRequestCount(client->m_reqFileHash);
d585 1
a585 124
//	Try to add client to our upload queue
	POSITION			pos1, pos2;
	CUpDownClient		   *pSource;
	const uint32			dwCurrentTime = ::GetTickCount();
	const uint32			dwWaitingListCount = static_cast<uint32>(waitinglist.GetCount());
	bool					bIsQueueFull = (dwWaitingListCount >= (g_eMuleApp.m_pGlobPrefs->GetQueueSize() + m_iBannedCount));

	for (pos1 = waitinglist.GetHeadPosition(); (pos2 = pos1) != NULL; )
	{
		pSource = waitinglist.GetNext(pos1);

	//	Check if client already exists
		if (pSource == client)
		{
			client->SendRankingInfo();
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(client);
			return;
		}
		else if (client->Compare(pSource)) // Another client with same ip or hash
		{
			if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
			{
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
								 client->GetUserName(), client->GetClientNameAndVersionString(), pSource->GetUserName(), pSource->GetClientNameAndVersionString(), pSource->GetUserName() );
				RemoveFromWaitingQueue(pos2,true);
			}
			else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) == IS_IDENTIFIED)
			{
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
								 client->GetUserName(), client->GetClientNameAndVersionString(), pSource->GetUserName(), pSource->GetClientNameAndVersionString(), client->GetUserName() );
				return;
			}
			else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
			{
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed both"),
								 client->GetUserName(), client->GetClientNameAndVersionString(), pSource->GetUserName(), pSource->GetClientNameAndVersionString() );
				RemoveFromWaitingQueue(pos2,true);
				return;
			}
			else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) == IS_IDENTIFIED)
			{
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Identified client '%s' (%s) and '%s' (%s) have the same Userhash or IP, removed '%s'"),
								 client->GetUserName(), client->GetClientNameAndVersionString(), pSource->GetUserName(), pSource->GetClientNameAndVersionString(), pSource->GetUserName());
				RemoveFromWaitingQueue(pos2,true);
			}
#ifdef OLD_SOCKETS_ENABLED
			if (pSource->m_pRequestSocket == NULL)
			{
				if (pSource->Disconnected())
					pSource = NULL;
			}
#endif //OLD_SOCKETS_ENABLED
			return;
		}

	//	If client does not exist in UL queue & the queue is full we will not be able to add new client,
	//	therefore we need to check if one of the client can be already removed from the queue due to timeout
	//	(no response from client during MAX_PURGEQUEUETIME)
		if (bIsQueueFull && (dwCurrentTime - pSource->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
		{
			RemoveFromWaitingQueue(pos2,true);
#ifdef OLD_SOCKETS_ENABLED
			if (!pSource->m_pRequestSocket)
			{
				if (pSource->Disconnected())
				{
					pSource = NULL;
				}
			}
#endif //OLD_SOCKETS_ENABLED
		//	Since one place now is free, set full status to false
			bIsQueueFull = false;
		}
	}

//	Use some information from client & add clients server to list.
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && client->GetServerIP() && client->GetServerPort())
	{
	//	If the server isn't already in our server list ...
		if ( (client->GetServerIP() != 0) && !g_eMuleApp.m_pServerList->GetServerByIP(client->GetServerIP(), client->GetServerPort()))
		{
			in_addr		addhost;

			addhost.S_un.S_addr = client->GetServerIP();

			CServer		*pServer = new CServer(client->GetServerPort(), CString(inet_ntoa(addhost)));

			pServer->SetListName(pServer->GetAddress());
			if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(pServer, true))
				delete pServer;
		}
	}

//	Statistic values
	if (m_pReqPartFile)
		m_pReqPartFile->statistic.AddRequest();

	if (client->IsDownloading())
	{
	//	He's already downloading and wants probably only another file
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		client->m_pRequestSocket->SendPacket(packet,true);
#endif //OLD_SOCKETS_ENABLED
		client->SetLastGotULData();
		return;
	}

//	If queue is not full we can add a client
	if (!bIsQueueFull)
	{
	//	LANCAST - Lan users bypass the queue
		if (client->IsOnLAN())
			AddUpNextClient(client);
		else
		{
			waitinglist.AddTail(client);
			client->SetUploadState(US_ONUPLOADQUEUE);
			client->SendRankingInfo();
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(client);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
		}
	}
d680 2
a681 22

bool CUploadQueue::RemoveFromWaitingQueue(CUpDownClient* client, bool updatewindow)
{
	EMULE_TRY

	POSITION pos = waitinglist.Find(client);
	if (pos)
	{
		RemoveFromWaitingQueue(pos,updatewindow);

		if (updatewindow)
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();

		return true;
	}

	EMULE_CATCH

	return false;
}

void CUploadQueue::RemoveFromWaitingQueue(POSITION pos, bool updatewindow)
d683 2
a684 4
	EMULE_TRY

	CUpDownClient* todelete = waitinglist.GetAt(pos);
	waitinglist.RemoveAt(pos);
d686 1
a686 23
	if (todelete == NULL)
		return;

	if (todelete->IsBanned())
		todelete->UnBan();

	if (updatewindow)
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.RemoveClient(todelete);

	todelete->SetUploadState(US_NONE);

	EMULE_CATCH
}



bool CUploadQueue::CheckForTimeOver(CUpDownClient* client)
{
	EMULE_TRY

	uint32 score = client->GetScore(true,true);

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL;)
d688 1
a688 2
		if (score < waitinglist.GetNext(pos)->GetScore(true,false))
			return true;
d691 1
a691 3
	EMULE_CATCH

	return false;
d693 1
a693 2


d698 1
a698 1
	waitinglist.RemoveAll();
a702 22

uint16 CUploadQueue::GetWaitingPosition(CUpDownClient* client)
{
	EMULE_TRY

	if (!IsOnUploadQueue(client))
		return 0;

	uint16 rank = 1;
	uint32 myscore = client->GetScore(false);

	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
	{
		if (waitinglist.GetNext(pos)->GetScore(false) > myscore)
			rank++;
	}
	return rank;

	EMULE_CATCH

	return 0;
}
d947 1
a947 1
	pos = waitinglist.GetHeadPosition();
d949 1
a949 1
	while (pos)
d951 1
a951 1
		CUpDownClient	   *pPotentialSource = waitinglist.GetNext(pos);
d1039 440
a1478 1
POSITION CUploadQueue::GetHeadPosition(void)
d1480 55
a1534 1
	return waitinglist.GetHeadPosition();
d1537 1
a1537 1
CUpDownClient* CUploadQueue::GetNext(POSITION& pos)
d1539 13
a1551 1
	return waitinglist.GetNext(pos);
d1554 16
@


1.149
log
@speed optimization of overhead calculation
@
text
@d713 1
a713 1
								 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource), pSource->GetUserName() );
d719 1
a719 1
								 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource), client->GetUserName() );
d725 1
a725 1
								 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource) );
d732 1
a732 1
								 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource), pSource->GetUserName());
d872 1
a872 1
										GetClientNameAndVersionString(client),
@


1.148
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@d67 1
d594 2
a595 2
		list<uint64>::iterator dr = m_averageDataRateList.begin();
		list<DWORD>::iterator tick = m_averageTickList.begin();
d1001 1
a1001 1

d1006 3
a1008 1
	m_AvarageUDRO_list.AddTail(m_nUpDataRateMSOverhead);
d1010 1
a1010 4
	if (m_AvarageUDRO_list.GetCount() > 150)
		m_AvarageUDRO_list.RemoveAt(m_AvarageUDRO_list.GetHeadPosition());

	m_nUpDataRateOverhead = 0;
d1013 6
a1018 2
	for (POSITION pos = m_AvarageUDRO_list.GetHeadPosition(); pos != NULL; )
		m_nUpDataRateOverhead += m_AvarageUDRO_list.GetNext(pos);
d1020 3
a1022 2
	if (m_AvarageUDRO_list.GetCount() > 10)
		m_nUpDataRateOverhead = 10*m_nUpDataRateOverhead/m_AvarageUDRO_list.GetCount();
d1346 1
a1346 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////@


1.147
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a1033 1
	g_eMuleApp.m_pClientList->ResetAllValueCaches();
d1036 1
a1036 1
    g_eMuleApp.m_pUploadQueue->CompUpDataRateOverhead();
@


1.146
log
@Minor changes
@
text
@d51 1
a51 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Fatal Error, failed to create Timer"), __FUNCTION__);
d110 1
a110 1
			AddDebugLogLine(false, RGB_LOG_ERROR + _T("Error creating SourcesSaveThread"));
d114 1
a114 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Error creating SourcesSaveThread"));
d711 2
a712 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
														 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource), pSource->GetUserName() );
d717 2
a718 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed '%s'"),
														 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource), client->GetUserName() );
d723 2
a724 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' (%s) and '%s' (%s) have the same userhash or IP, removed both"),
														 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource) );
d730 2
a731 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Identified client '%s' (%s) and '%s' (%s) have the same Userhash or IP, removed '%s'"),
														 client->GetUserName(), GetClientNameAndVersionString(client), pSource->GetUserName(), GetClientNameAndVersionString(pSource), pSource->GetUserName());
d1158 1
a1158 1
					CLoggable::AddDebugLogLine(false, "Scheduled backup performed");
d1185 1
a1185 1
					CLoggable::AddDebugLogLine(false, MessageText);
d1198 1
a1198 1
	                   	CLoggable::AddDebugLogLine(false, CString("SCHEDULER: day excepted!"));
d1217 1
a1217 1
						CLoggable::AddDebugLogLine(false, MessageText);
@


1.145
log
@Fixes
@
text
@d834 1
a834 1
	// Update stats: if client got some byte s from us the session will succesfull, otherwise failed
d862 1
a862 2
				//	CKnownFile		*m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
					CKnownFile		*m_pReqPartFile = g_eMuleApp.m_pKnownFilesList->FindKnownFileByID((uchar*)client->m_reqFileHash);
d865 3
d872 1
a872 1
										m_pReqPartFile->GetFileName(),
@


1.144
log
@Added client version info to debug log messages.
@
text
@d825 1
a826 1
	removed_pos = uploadinglist.Find(client);
d838 1
d862 2
a863 1
					CKnownFile		*m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
@


1.143
log
@[speedup] more precise timing of server keepalive; now once a minute instead of 5
[slowdown] saving of met-files not called every second but also every minute
@
text
@d711 2
a712 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' and '%s' have the same userhash or IP, removed '%s'"),
														 client->GetUserName(), pSource->GetUserName(), pSource->GetUserName() );
d717 2
a718 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' and '%s' have the same userhash or IP, removed '%s'"),
														 client->GetUserName(), pSource->GetUserName(), client->GetUserName() );
d723 2
a724 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' and '%s' have the same userhash or IP, removed both"),
														 client->GetUserName(), pSource->GetUserName() );
d730 2
a731 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Identified client '%s' and '%s' have the same Userhash or IP, removed '%s'"),
														 client->GetUserName(), pSource->GetUserName(), pSource->GetUserName());
@


1.142
log
@Final DebugLog formating and changes
@
text
@d1020 1
a1020 1
VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg,UINT_PTR idEvent,DWORD dwTime)
d1024 1
a1024 1
// Don't do anything if the app is shutting down - can cause unhandled exceptions
d1026 1
d1028 1
d1035 1
d1038 2
a1039 1
	if (g_iCounter % 10 == 0) // 1 second
a1040 3
		g_eMuleApp.m_pClientCreditList->Process();
		g_eMuleApp.m_pServerList->Process();
		g_eMuleApp.m_pFriendList->Process();
d1043 1
d1045 2
a1046 1
#endif //OLD_SOCKETS_ENABLED
d1057 1
d1059 2
a1060 1
#endif //OLD_SOCKETS_ENABLED
d1062 3
a1064 1
		if (g_iCounter % 20 == 0) // 2 seconds
d1066 1
d1068 2
a1069 2
	// Display graphs
		if (g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()>0)
d1072 1
d1074 1
d1077 2
a1078 2
	// Display stats
		if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_dlgStatistics && g_eMuleApp.m_pdlgEmule->IsWindowVisible() )
d1080 1
a1080 1
			if (g_eMuleApp.m_pGlobPrefs->GetStatsInterval()>0)
d1083 1
d1085 1
d1088 2
a1089 1
	// Save rates every second
d1091 1
d1093 1
a1093 1
	// mobilemule sockets
d1095 1
a1095 1
#endif //OLD_SOCKETS_ENABLED
d1097 2
a1098 1
		if (g_iCounter % 50 == 0) // 5 seconds
d1100 6
a1105 4
			#ifdef _DEBUG
				if (!AfxCheckMemory())
					g_eMuleApp.AddLogLine(false, RGB_PINK + _T("** ") + RGB_LOG_ERROR + _T("Memory corruption detected") + RGB_PINK + _T(" **"));
			#endif
d1109 1
a1109 1
		#endif //OLD_SOCKETS_ENABLED
d1115 2
a1116 1
		if (g_iCounter % 3000 == 0) // 5 minutes
d1118 2
a1119 2
			g_eMuleApp.m_pGlobPrefs->SaveStats(); // This function does NOT update the tree!
			g_eMuleApp.m_pServerConnect->KeepConnectionAlive();
d1121 2
a1122 1
// Auto Sources per File every 90 seconds
d1125 1
d1132 2
a1133 2
//	Scheduled Backup
		if (g_eMuleApp.m_pGlobPrefs->IsScheduledBackup() && g_eMuleApp.m_pGlobPrefs->GetScheduledBackupInterval() != 0)
d1135 14
a1148 1
			if (::GetTickCount() > (g_eMuleApp.m_pUploadQueue->m_dwLastScheduledBackupTick) + g_eMuleApp.m_pGlobPrefs->GetScheduledBackupInterval() * 3600000)
d1150 6
a1155 3
				g_eMuleApp.m_pdlgEmule->RunBackupNow(true);
				g_eMuleApp.m_pUploadQueue->m_dwLastScheduledBackupTick = ::GetTickCount();
				CLoggable::AddDebugLogLine(false, "Scheduled backup performed");
a1156 1
		}
d1158 2
a1159 4
		// Scheduler Shift check
		if(g_iCounter % 600 == 0)
		{
			if(g_eMuleApp.m_pGlobPrefs->IsSCHEnabled())
d1164 1
a1164 1
				if(secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift1()-60 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift1()+60)
d1166 1
a1166 1
				// Switching to shift1 speeds
d1172 1
a1172 1
				// Sending message for scheduler shift 1
d1185 1
a1185 1
	                			int dayOfWeek = curr_t.GetDayOfWeek();
d1198 1
a1198 1
					// Switching to shift2 speeds
d1204 1
a1204 1
					// Sending message for scheduler shift 2
@


1.141
log
@comment
@
text
@d51 1
a51 1
		AddDebugLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_TIMERCREATEFAILED));
d114 1
a114 1
		AddDebugLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_TIMERCREATEFAILED));
a182 1
		AddDebugLogLine(false, _T("AddUpNextClient(): client not in ClientList"));
d711 2
a712 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),pSource->GetUserName() );
d717 2
a718 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),client->GetUserName() );
d723 2
a724 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),"both" );
d730 2
a731 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s"),client->GetUserName(),pSource->GetUserName(),pSource->GetUserName());
@


1.140
log
@Check also port, not only IP on remote client UDP file reask + some more exception handling + minor changes
@
text
@d49 1
a49 1
	m_hTimer = SetTimer(NULL,141,100,TimerProc); //TODO: What event is 141?
@


1.139
log
@Support for external antivirus program + removed SUI preferences + minor changes
@
text
@d573 1
a573 1
CUpDownClient* CUploadQueue::GetWaitingClientByIP_UDP(uint32 dwIP, uint16 dwport)
d581 1
a581 1
		if (dwIP == pSource->GetIP())
@


1.138
log
@added tooltips to the Server list
@
text
@d710 1
a710 1
			if (g_eMuleApp.m_pGlobPrefs->IsSecureIdentEnabled())
d712 13
a724 21
				if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
				{
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),pSource->GetUserName() );
					RemoveFromWaitingQueue(pos2,true);
				}
				else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) == IS_IDENTIFIED)
				{
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),client->GetUserName() );
					return;
				}
				else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
				{
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),"both" );
					RemoveFromWaitingQueue(pos2,true);
					return;
				}
				else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) == IS_IDENTIFIED)
				{
					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s"),client->GetUserName(),pSource->GetUserName(),pSource->GetUserName());
					RemoveFromWaitingQueue(pos2,true);
				}
d726 1
a726 1
			else
d728 1
a728 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),pSource->GetUserName(),pSource->GetUserName() );
a730 1

@


1.137
log
@added Scheduled Backup feature
@
text
@d878 3
a880 3
										GetResString((client->IsFriend()) ? IDS_YES : IDS_NO),
										GetResString((client->IsCommunity()) ? IDS_YES : IDS_NO),
										GetResString((client->IsOnLAN()) ? IDS_YES : IDS_NO),
@


1.136
log
@Reworked file completion algorithm to eliminate file locking in completing state.
@
text
@d90 1
d1117 13
a1129 1
	// Scheduler Shift check
@


1.135
log
@auto max sources per file
@
text
@a891 6
	// Report the PartFile that UL is finished
		if (client->pUploadingPartFile)
		{
			client->pUploadingPartFile->SetFileUpload(false);
			client->pUploadingPartFile = NULL;
		}
@


1.134
log
@Removed an unneeded value
@
text
@d1114 8
a1121 1

@


1.133
log
@Increase granularity for long lists (that reduces memory fragmentation and slightly reduces memory usage).
@
text
@d869 1
a869 1
					strLogLine.Format( _T("%s,\"%s\",%s,%u,\"%s\",%u,%u,%u,%s,%s,%s,%s\n"),
a872 1
										client->GetScore(false, client->IsDownloading(), false),
@


1.132
log
@Minor formating changes, some more upload log and fix for clipboard monitoring
@
text
@d44 1
a44 1
CUploadQueue::CUploadQueue(CPreferences* in_prefs)
@


1.131
log
@minor improvements
@
text
@d869 1
a869 1
					strLogLine.Format( _T("%s,\"%s\",%s,\"%s\",%u,%u,%u,%s,%s,%s\n"),
d873 1
d880 1
@


1.130
log
@Final format?
@
text
@d700 1
a700 1
	//	Check if client already exist
d750 1
a750 1
	//	therefore we need to check if one of the client can be allready removed from the queue due to timeout 
d877 2
a878 2
										client->IsFriend() ? GetResString(IDS_YES) : GetResString(IDS_NO),
										client->IsCommunity() ? GetResString(IDS_YES) : GetResString(IDS_NO),
@


1.129
log
@*** empty log message ***
@
text
@d869 1
a869 1
					strLogLine.Format( _T("%s,\"%s\",%s,%u,\"%s\",%u,%u,%s,%s,%s\n"),
d873 1
a874 1
										m_pReqPartFile->GetFileName(),
@


1.128
log
@Changes to Upload Log, enabled addsource for second client on same computer (different port) and other minor changes
@
text
@d869 1
a869 1
					strLogLine.Format( _T("%s,%s,\"%s\",%u,\"%s\",%u,%u,%s,%s,%s\n"),
d877 2
d880 2
a881 3
										GetResString(IDS_IDENTOK).MakeLower() : g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason),
										client->IsFriend() ? GetResString(IDS_YES) : GetResString(IDS_NO),
										client->IsCommunity() ? GetResString(IDS_YES) : GetResString(IDS_NO) );
@


1.127
log
@Removed status messages that shouldn't be there
@
text
@d867 1
d869 12
a880 8
					strLogLine.Format( GetResString(IDS_UPLOAD_LOG_LINE), 
											 currentTime.Format(),
											 client->GetUserName(),
											 CastItoXBytes(client->GetTransferredUp()),
											 m_pReqPartFile->GetFileName(),
											 CastSecondsToHM((client->GetUpStartTimeDelay())/1000),
											 (client->GetTransferredUp() >= PARTSIZE) ? 
											 GetResString(IDS_IDENTOK).MakeLower() : g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason) );
@


1.126
log
@minor improvements
@
text
@d1133 1
a1133 1
					CLoggable::AddDebugLogLine(true, MessageText);
d1146 1
a1146 1
	                   	CLoggable::AddDebugLogLine(true, CString("SCHEDULER: day excepted!"));
d1165 1
a1165 1
						CLoggable::AddDebugLogLine(true, MessageText);
@


1.125
log
@0 IP check before server addition
@
text
@a859 3
				COleDateTime	currentTime(COleDateTime::GetCurrentTime());
				CString			strLogLine;

d864 3
a866 1
					CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
d868 1
a868 1
					strLogLine.AppendFormat( GetResString(IDS_UPLOAD_LOG_LINE), 
@


1.124
log
@Minor change...
@
text
@d773 1
a773 1
		if (!g_eMuleApp.m_pServerList->GetServerByIP(client->GetServerIP(), client->GetServerPort()))
@


1.123
log
@indication of completed chunks with an * in Shared Files list
@
text
@d876 1
a876 1
											 GetResString(IDS_IDENTOK) : g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason) );
@


1.122
log
@Changed the Upload log... It seems I found something strange while doing this. :/
@
text
@d875 2
a876 1
											 g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetUpEndReason(eReason) );
@


1.121
log
@Updated preferences dialogs.
Added upload log file (should be tested).
@
text
@d867 9
a875 6
					strLogLine.AppendFormat(currentTime.Format());
					strLogLine.AppendFormat(": Client %s downloaded %s from file %s in %s \n", 
									client->GetUserName(),
									CastItoXBytes(client->GetTransferredUp()),
									client->pUploadingPartFile->GetFileName(),
									CastSecondsToHM((client->GetUpStartTimeDelay())/1000) );
@


1.120
log
@Better & more usefull cleaning of DeadClients from WaitingQueue with some additions and optimisations thanks to eklmn
@
text
@d116 2
d855 1
d858 21
@


1.119
log
@list processing optimization
@
text
@d687 1
a687 1
//	Check for double and remove dead clients from queue
d689 4
a692 3
	CUpDownClient	   *pSource;
	uint32				dwCurrentTime;
	uint32				dwWaitingListCount = static_cast<uint32>(waitinglist.GetCount());
d696 1
a696 1
		pSource	= waitinglist.GetNext(pos1);
d698 1
a698 1
	//	Don't add double clients
d746 19
d767 1
a767 1
// Add clients server to list.
d770 13
a782 7
		in_addr host;
		host.S_un.S_addr = client->GetServerIP();
		CString s(inet_ntoa(host));
		CServer* srv = new CServer(client->GetServerPort(), s);
		srv->SetListName(srv->GetAddress());
		if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(srv, true))
			delete srv;
d785 3
a787 6
// Statistic values
	if (m_pReqPartFile) m_pReqPartFile->statistic.AddRequest();

// TODO find better ways to cap the list
	if ((uint32)waitinglist.GetCount() >= (g_eMuleApp.m_pGlobPrefs->GetQueueSize()+m_iBannedCount))
		return;
d791 1
a791 1
	// He's already downloading and wants probably only another file
d801 2
a802 4
// LANCAST - Lan users bypass the queue
	if (client->IsOnLAN())
		AddUpNextClient(client);
	else
d804 11
a814 5
		waitinglist.AddTail(client);
		client->SetUploadState(US_ONUPLOADQUEUE);
		client->SendRankingInfo();
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.AddClient(client);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
@


1.118
log
@list processing optimization, reduce cpu load when updating or sorting the Waiting Queue
@
text
@d641 1
a641 1
//		and is not a friend and the queue is longer than 50...
d653 1
a653 1
// Check if file was requested with OP_SETREQFILEID, OP_FILEREQUEST or OP_STARTUPLOADREQ
d656 1
a656 1
// If file wasn't requested
d660 1
a660 1
// Filtering invalid eMule clients
d670 1
a670 1
// L2HAC- lowid side
d674 1
a674 1
// LANCAST - We ignore any ban LAN clients may have
d687 7
a693 3
// Check for double
	POSITION	pos1,pos2;
	for (pos1 = waitinglist.GetHeadPosition(); (pos2 = pos1) != NULL;)
d695 1
a695 1
		CUpDownClient* cur_client= waitinglist.GetNext(pos1);
d697 2
a698 1
		if (cur_client == client) // Already on queue
d704 1
a704 1
		else if (client->Compare(cur_client)) // Another client with same ip or hash
d708 1
a708 1
				if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) != IS_IDENTIFIED)
d710 1
a710 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d713 1
a713 1
				else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) == IS_IDENTIFIED)
d715 1
a715 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );
d718 1
a718 1
				else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) != IS_IDENTIFIED)
d720 1
a720 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),"both" );
d724 1
a724 1
				else if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) == IS_IDENTIFIED)
d726 1
a726 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s"),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName());
d732 1
a732 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d737 1
a737 1
			if (cur_client->m_pRequestSocket == NULL)
d739 2
a740 2
				if (cur_client->Disconnected())
					cur_client = NULL;
@


1.117
log
@formatting and 4spaces tab alignments
@
text
@a1115 29
CUpDownClient* CUploadQueue::GetNextClient(CUpDownClient* lastclient)
{
	EMULE_TRY

	if (waitinglist.IsEmpty())
		return NULL;

	if (lastclient == NULL)
		return waitinglist.GetHead();

	POSITION pos = waitinglist.Find(lastclient);

	if (pos == NULL)
	{
		TRACE("Error: CServerList::GetNextClient");
		return waitinglist.GetHead();
	}
	waitinglist.GetNext(pos);

	if (pos == NULL)
		return NULL;
	else
		return waitinglist.GetAt(pos);

	EMULE_CATCH

	return NULL;
}

d1221 11
@


1.116
log
@Changed UploadQueue.cpp TimerProc with kuchin suggestion
@
text
@d135 1
a135 1
		
d139 1
a139 1
			
d173 1
a173 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader(); 
d185 1
a185 1
	if (IsDownloading(pNewSource) || pNewSource->IsBanned(true))	
d188 1
a188 1
// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour 
d193 1
a193 1
	
d211 1
a211 1
	
d216 1
a216 1
	
d220 1
a220 1
	
d287 3
a289 3
        uint32 tempMaxActiveClients = 0;
        POSITION activeClientsListPos = activeClients_list.GetHeadPosition();
  
d307 2
a308 2
		POSITION lastpos = uploadinglist.GetTailPosition();
        CUpDownClient* lastClient = NULL;
d311 1
d313 1
d319 3
a321 3
        if ( CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount() > 0 &&
             wantedNumberOfTotalUploads > uploadinglist.GetCount() &&
             (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS) )
d326 2
a327 2
		else if ( uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED &&
                  CanAcceptNewClient(uploadinglist.GetCount()-1) == false )
d335 1
a335 1
			{   
d413 1
a413 1
        
d442 1
a442 1
// Were going to try uploading the way plus way....... 
d563 1
a563 1
	return waitinglist.Find(client); 
d589 1
a589 1
	if(m_averageDataRateList.size() > 9)
d645 1
a645 1
		&& client->GetDownloadState() == DS_NONE 
d661 1
a661 1
	if( client->GetMuleVersion() == 0 && client->GetVersion() == 0
d697 1
a697 1
			return;			
d710 1
a710 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d723 1
a723 1
				} 
d725 1
a725 1
			else 
d730 1
a730 1
			
d756 1
a756 1
	
d792 1
a792 1
	
d801 1
a801 1
		
d818 1
a818 1
		
d991 1
d993 1
d1006 1
a1006 1
		if(g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()>0) 
d1028 1
a1028 1
		if (g_iCounter % 50 == 0) // 5 seconds 
d1068 1
a1068 1
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(), 
d1075 2
a1076 2
				} 
				else if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift2()-60 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift2()+60) 
d1088 2
a1089 2
					} 
					else 
d1100 1
a1100 1
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(), 
d1135 1
a1135 1
	if (!pos)
d1192 1
a1192 1
		g_eMuleApp.m_pKnownFilesList->Save();	
@


1.115
log
@reverted a buggy thing in my last change
@
text
@d36 1
a36 5

static uint32	g_iCounter, g_iSec, g_iStatSave;
// -khaos--+++> Added g_iUpdateConnStats...
static uint32	g_iGraph, g_iStats, g_iUpdateConnStats;
// <-----khaos-
d77 1
a77 4
	g_iStatSave=0;
	// -khaos--+++>
	g_iUpdateConnStats=0;
	// <-----khaos-
d123 2
a124 1
	if (g_eMuleApp.m_pListenSocket->TooManySockets()) return;
d128 1
a128 1
	CUpDownClient* newclient;
d134 3
a136 3
		CUpDownClient* cur_client;

		for (pos1 = waitinglist.GetHeadPosition();( pos2 = pos1 ) != NULL; )
d138 2
a139 2
			cur_client  = waitinglist.GetNext(pos1);

d141 1
a141 1
			ASSERT(cur_client->GetLastUpRequest());
d144 2
a145 2
			if ( (::GetTickCount() - cur_client->GetLastUpRequest() > MAX_PURGEQUEUETIME)
				|| !g_eMuleApp.m_pSharedFilesList->GetFileByID(cur_client->m_reqFileHash) )
d149 1
a149 1
				if (!cur_client->m_pRequestSocket)
d151 2
a152 2
					if (cur_client->Disconnected())
						cur_client = NULL;
d158 1
a158 1
			else if ( (cur_client->GetScore(true) > bestscore) && (!cur_client->IsBanned())  && (!cur_client->HasLowID()
d160 1
a160 1
				|| (cur_client->m_pRequestSocket && cur_client->m_pRequestSocket->IsConnected())
d164 1
a164 1
				bestscore = cur_client->GetScore(true);
d170 2
a171 1
		newclient = waitinglist.GetAt(toadd);
d173 1
a173 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d176 1
a176 1
		newclient = directadd;
d178 1
a178 1
  	if (!g_eMuleApp.m_pClientList->IsValidClient(newclient))
d185 1
a185 1
	if (IsDownloading(newclient) || newclient->IsBanned(true))
d188 1
a188 1
// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour
d190 1
a190 1
	CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)newclient->m_reqFileHash);
d193 1
a193 1

d196 1
a196 1
	if (!newclient->m_pRequestSocket || !newclient->m_pRequestSocket->IsConnected())
d198 2
a199 2
		newclient->SetUploadState(US_CONNECTING);
		if (!newclient->TryToConnect(true))
d206 3
a208 3
		newclient->m_pRequestSocket->SendPacket(packet,true);
		newclient->SetUploadState(US_UPLOADING);
		newclient->SetLastGotULData();
d211 6
a216 6

	newclient->SetUpStartTime();
	newclient->ResetSessionUp();
	newclient->ResetCompressionGain();
	uploadinglist.AddTail(newclient);

d220 2
a221 2

	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.AddClient(newclient);
d287 3
a289 3
        uint32		tempMaxActiveClients = 0;
        POSITION	activeClientsListPos = activeClients_list.GetHeadPosition();

d308 1
a309 1
        CUpDownClient* lastClient = NULL;
a310 1
        {
a311 1
        }
d317 3
a319 3
        if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount() > 0 &&
           wantedNumberOfTotalUploads > uploadinglist.GetCount() &&
           (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS))
d324 2
a325 2
		else if (uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED &&
                CanAcceptNewClient(uploadinglist.GetCount()-1) == false)
d333 1
a333 1
			{
d411 1
a411 1

d440 1
a440 1
// Were going to try uploading the way plus way.......
d479 4
a482 5
			CUpDownClient* cur_client = waitinglist.GetNext(pos);
			if (cur_client->IsL2HACEnabled()
				&& cur_client->GetLastL2HACExecution()
				&& cur_client->GetL2HACTime()
				&& (curTick - cur_client->GetLastL2HACExecution()) > cur_client->GetL2HACTime())
d484 5
a488 2
				if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(cur_client->m_pRequestSocket && cur_client->m_pRequestSocket->IsConnected()) )
					cur_client->SetLastL2HACExecution(curTick - cur_client->GetL2HACTime() + static_cast<uint32>(ROUND((static_cast<double>(rand())/RAND_MAX)*300000.0)));
d491 3
a493 3
					cur_client->DisableL2HAC();
					if (!cur_client->HasLowID() && cur_client->GetL2HACTime())
					cur_client->TryToConnect();
d561 1
a561 1
	return waitinglist.Find(client);
d572 1
a572 1
	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
d574 4
a577 3
		CUpDownClient* cur_client = waitinglist.GetNext(pos);
		if (dwIP == cur_client->GetIP())
			return cur_client;
d587 1
a587 1
	if (m_averageDataRateList.size() > 9)
d604 1
a604 1
        if (m_averageDataRateList.size() >1)
d618 1
a618 1
	int	count=0;
d620 1
a620 1
	for (POSITION pos = waitinglist.GetHeadPosition(); pos != NULL; )
d622 1
a622 1
		CUpDownClient	   *cur_client = waitinglist.GetNext(pos);
d624 1
a624 1
		if (cur_client->IsBanned())
d627 1
d643 1
a643 1
		&& client->GetDownloadState() == DS_NONE
d659 2
a660 1
	if (client->GetMuleVersion() == 0 && client->GetVersion() == 0 && (client->GetClientSoft() == SO_EMULE || client->GetClientSoft() == SO_OLDEMULE))
d684 1
a685 1

d687 1
a687 2

	for (pos1 = waitinglist.GetHeadPosition(); (pos2 = pos1) != NULL; )
d690 1
d695 1
a695 1
			return;
d708 1
a708 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );
d721 1
a721 1
				}
d723 1
a723 1
			else
d728 1
a728 1

d754 1
a754 1

d790 1
a790 1

d799 1
a799 1

d816 1
a816 1

d873 1
d978 1
a978 1
	if (g_iCounter >= 10) // One second
a979 1
		g_iCounter=0;
d984 1
a984 1
		if ( g_eMuleApp.m_pServerConnect->IsConnecting())
a988 1
		{
a989 1
		}
d994 2
a995 1
		if (g_eMuleApp.m_pServerConnect->IsConnecting()) g_eMuleApp.m_pServerConnect->CheckForTimeout();
d998 1
a998 5
		g_iUpdateConnStats++;

		if (g_iUpdateConnStats>=2) // 2 seconds
		{
			g_iUpdateConnStats=0;
a999 1
		}
d1002 1
a1002 1
		if (g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval() > 0)
d1004 1
a1004 5
			g_iGraph++;

			if (g_iGraph >= (uint32)(g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()) )
			{
				g_iGraph=0;
a1005 1
			}
d1007 2
a1010 1
		// Display stats
d1013 1
a1013 5
				g_iStats++;

				if (g_iStats >= (uint32)(g_eMuleApp.m_pGlobPrefs->GetStatsInterval()) )
				{
					g_iStats=0;
a1014 1
				}
d1024 1
a1024 3
		g_iSec++;

		if (g_iSec>=5) // 5 seconds
a1030 1
			g_iSec = 0;
d1034 1
d1039 1
a1039 2
		g_iStatSave++;
		if (g_iStatSave>=300) // 5 minutes
d1041 1
a1041 5
			g_iStatSave=0;

		// This function does NOT update the tree!
			g_eMuleApp.m_pGlobPrefs->SaveStats();

d1046 1
a1046 1
		if (g_eMuleApp.m_pGlobPrefs->IsSCHEnabled())
d1048 4
a1051 2
			CTime curr_t = CTime::GetCurrentTime();
			uint32 secs = curr_t.GetSecond() + 60*curr_t.GetMinute() + 60*60*curr_t.GetHour();
d1053 1
a1053 33
			if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift1()-120 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift1()+120)
			{
			// Switching to shift1 speeds
				g_eMuleApp.m_pUploadQueue->SCHShift1UploadCheck();
				g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload());
				g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download());
				g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn());
				g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec());
			// Sending message for scheduler shift 1
				CString MessageText;
				MessageText.Format( _T("SCHEDULER: switching to Shift 1 (Max Upload:%i Max Download:%i Max Connections:%i Max In 5 secs:%i)"),
									g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(),
									g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download(),
									g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn(),
									g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec() );
				g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
				g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier());
				CLoggable::AddDebugLogLine(true, MessageText);
			}
			else if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift2()-120 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift2()+120)
			{
                			int dayOfWeek = curr_t.GetDayOfWeek();
				if ((dayOfWeek==2 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptMon())
					|| (dayOfWeek==3 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptTue())
					|| (dayOfWeek==4 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptWed())
					|| (dayOfWeek==5 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptThu())
					|| (dayOfWeek==6 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptFri())
					|| (dayOfWeek==7 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSat())
					|| (dayOfWeek==1 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSun()))
                			{
                    			CLoggable::AddDebugLogLine(true, CString("SCHEDULER: day excepted!"));
				}
				else
d1055 7
a1061 7
				// Switching to shift2 speeds
					g_eMuleApp.m_pUploadQueue->SCHShift2UploadCheck();
					g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload());
					g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download());
					g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn());
					g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec());
				// Sending message for scheduler shift 2
d1063 5
a1067 5
					MessageText.Format( _T("SCHEDULER: switching to Shift 2 (Max Upload:%i Max Download:%i Max Connections:%i Max In 5 secs:%i)"),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec() );
d1071 33
d1149 1
a1149 1
		CUpDownClient	   *potential = uploadinglist.GetNext(pos);
d1151 2
a1152 2
		if (md4cmp(potential->m_reqFileHash, filehash) == 0)
			srclist->AddTail(potential);
d1159 1
a1159 1
		CUpDownClient	   *potential = waitinglist.GetNext(pos);
d1161 2
a1162 2
		if (md4cmp(potential->m_reqFileHash, filehash) == 0)
			srclist->AddTail(potential);
d1188 1
a1188 1
		g_eMuleApp.m_pKnownFilesList->Save();
d1190 1
d1230 2
a1231 1
	CUpDownClient* cur_client;
d1234 3
a1236 2
		cur_client = uploadinglist.GetNext(pos);
		if (cur_client->m_pReqPartFile == check_file)
d1241 1
d1243 1
@


1.114
log
@formatting;
optimzations in UploadQueue.cpp;
removing doubled ';'
@
text
@d1150 1
d1152 1
a1152 3
	CUpDownClient	   *pClient = waitinglist.GetNext(pos);

	if (pos == NULL)
d1155 1
a1155 1
		return pClient;
@


1.113
log
@Change on Scheduler shift
@
text
@d141 2
a142 2
		
		for (pos1 = waitinglist.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d144 2
a145 3
			waitinglist.GetNext(pos1);
			cur_client  = waitinglist.GetAt(pos2);
			
d155 1
a155 1
				if(!cur_client->m_pRequestSocket)
d166 1
a166 1
				|| (cur_client->m_pRequestSocket && cur_client->m_pRequestSocket->IsConnected()) 
d178 1
a178 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader(); 
d183 1
a183 1
  	if(!g_eMuleApp.m_pClientList->IsValidClient(newclient))
d190 1
a190 1
	if (IsDownloading(newclient) || newclient->IsBanned(true)) 	
d193 1
a193 1
// Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour 
d198 1
a198 1
	
d216 1
a216 1
	
d221 1
a221 1
	
d225 1
a225 1
	
d248 1
a248 1
	if(g_eMuleApp.m_pGlobPrefs->GetMaxUpload() == UNLIMITED)
d251 1
a251 1
        if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount()) 
d271 1
a271 1
            if(tempWantsMoreBandwidth == true)
d277 1
a277 1
            if(m_guessedMaxBandwidth > 300)
d292 4
a295 3
        uint32 tempMaxActiveClients = 0;
        POSITION activeClientsListPos = activeClients_list.GetHeadPosition();
        while(activeClientsListPos != NULL)
d297 1
a297 1
            uint32 activeClientsSnapshot = activeClients_list.GetAt(activeClientsListPos);
d299 1
a299 1
            if(activeClientsSnapshot > tempMaxActiveClients)
a300 2

            activeClients_list.GetNext(activeClientsListPos);
d315 2
a316 1
        if(lastpos != NULL) {
d324 1
a324 1
        if(CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount() > 0 &&
d326 1
a326 1
           (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS)) 
d331 2
a332 2
		else if(uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED &&
                CanAcceptNewClient(uploadinglist.GetCount()-1) == false) 
d339 2
a340 2
            if(!lastClient->IsOnLAN() && lastClient->GetUpStartTimeDelay() > 3*1000)
			{   
d400 1
a400 1
            if(cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick)
d418 1
a418 1
        
d422 1
a422 1
        if(m_iLeftOverBandwidth > limitSave)
d431 1
a431 1
	if(m_averageTickList.empty() || curTick- m_averageTickList.front()>=500)
d437 1
a437 1
		while(curTick-m_averageTickList.back() > 40000)
d447 1
a447 1
// Were going to try uploading the way plus way....... 
d463 1
a463 1
            if(tempWantsMoreBandwidth == true)
d469 1
a469 1
            if(m_guessedMaxLANBandwidth > 3000)
d484 1
a484 1
		for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos))
d486 1
a486 1
			CUpDownClient* cur_client = waitinglist.GetAt(pos);
d566 1
a566 1
	return waitinglist.Find(client); 
d577 2
a578 2
	//v- eklmn: optimization: don't call waitinglist.GetNext(pos) many times
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;) {
d582 1
a582 1
        }
d591 1
a591 1
	if(m_averageDataRateList.size() >9)
d593 2
a594 2
		list<uint64>::iterator dr=m_averageDataRateList.begin();
		list<DWORD>::iterator tick=m_averageTickList.begin();
d606 1
a606 1
    if(GetTickCount()-m_lastCalculatedDataRateTick > 1000)
d608 1
a608 1
        if(m_averageDataRateList.size() >1)
d622 3
a624 2
	int count=0;
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos))
d626 3
a628 2
		CUpDownClient* cur_client= waitinglist.GetAt(pos);
		if(cur_client->IsBanned())
d646 1
a646 1
		&& client->GetDownloadState() == DS_NONE 
d662 2
a663 1
	if(client->GetMuleVersion()==0 && client->GetVersion()==0 && (client->GetClientSoft()==SO_EMULE || client->GetClientSoft()==SO_OLDEMULE)) {
d687 4
a690 1
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos))
d692 1
a692 1
		CUpDownClient* cur_client= waitinglist.GetAt(pos);
d697 1
a697 1
			return;			
d706 1
a706 1
					RemoveFromWaitingQueue(pos,true);
d710 1
a710 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d716 1
a716 1
					RemoveFromWaitingQueue(pos,true);
d722 2
a723 2
					RemoveFromWaitingQueue(pos,true);	
				} 
d725 1
a725 1
			else 
d728 1
a728 1
				RemoveFromWaitingQueue(pos,true);	
d730 1
a730 1
			
d756 1
a756 1
	
d792 1
a792 1
	
d801 1
a801 1
		
d818 1
a818 1
		
d842 1
a842 1
	if(m_iULSessionSuccessful)
d875 1
a875 1
	if(todelete == NULL)
d878 1
a878 1
	if(todelete->IsBanned())
d897 1
a897 1
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos))
d899 1
a899 1
		if (score < waitinglist.GetAt(pos)->GetScore(true,false))
d929 1
a929 1
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos))
d931 1
a931 1
		if (waitinglist.GetAt(pos)->GetScore(false) > myscore)
d953 2
a954 2
	for (POSITION pos = m_AvarageUDRO_list.GetHeadPosition();pos != 0;m_AvarageUDRO_list.GetNext(pos))
		m_nUpDataRateOverhead += m_AvarageUDRO_list.GetAt(pos);
d956 1
a956 1
	if(m_AvarageUDRO_list.GetCount() > 10)
d986 1
a986 1
		if( g_eMuleApp.m_pServerConnect->IsConnecting())
d1010 1
a1010 1
		if(g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()>0) 
d1014 1
a1014 1
			if (g_iGraph >= (uint32)(g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()) ) 
d1020 1
a1020 1
		if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_dlgStatistics && g_eMuleApp.m_pdlgEmule->IsWindowVisible() )  
d1023 1
a1023 1
			if (g_eMuleApp.m_pGlobPrefs->GetStatsInterval()>0) 
d1027 1
a1027 1
				if (g_iStats >= (uint32)(g_eMuleApp.m_pGlobPrefs->GetStatsInterval()) ) 
d1043 1
a1043 1
		if (g_iSec>=5) // 5 seconds 
d1062 1
a1062 1
			
d1070 1
a1070 1
		if(g_eMuleApp.m_pGlobPrefs->IsSCHEnabled())
d1075 1
a1075 1
			if(secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift1()-120 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift1()+120)
d1086 1
a1086 1
									g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(), 
d1093 2
a1094 2
			} 
			else if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift2()-120 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift2()+120) 
d1097 6
a1102 6
				if ((dayOfWeek==2 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptMon()) 
					|| (dayOfWeek==3 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptTue()) 
					|| (dayOfWeek==4 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptWed()) 
					|| (dayOfWeek==5 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptThu()) 
					|| (dayOfWeek==6 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptFri()) 
					|| (dayOfWeek==7 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSat()) 
d1106 2
a1107 2
				} 
				else 
d1118 1
a1118 1
										g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(), 
d1140 1
a1140 1
	if (!lastclient)
d1145 1
a1145 1
	if (!pos)
a1149 1
	waitinglist.GetNext(pos);
d1151 3
a1153 1
	if (!pos)
d1156 1
a1156 1
		return waitinglist.GetAt(pos);
d1163 1
a1163 1
void CUploadQueue::FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, const uchar* filehash) 
d1167 1
a1167 2
	POSITION pos;
	pos = uploadinglist.GetHeadPosition();
d1169 1
a1169 1
	while(pos)
d1171 3
a1173 2
		CUpDownClient *potential = uploadinglist.GetNext(pos);
		if(md4cmp(potential->m_reqFileHash, filehash) == 0)
d1179 1
a1179 1
	while(pos)
d1181 3
a1183 2
		CUpDownClient *potential = waitinglist.GetNext(pos);
		if(md4cmp(potential->m_reqFileHash, filehash) == 0)
d1210 1
a1210 1
		g_eMuleApp.m_pKnownFilesList->Save();	
d1219 1
a1219 1
	if(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() != 0)
d1221 1
a1221 1
		if(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() < 4 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*3 < g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()))
d1224 1
a1224 1
		if(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload() < 10 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload()*4 < g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download()))
d1235 1
a1235 1
	if(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() != 0)
d1237 1
a1237 1
		if(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() < 4 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*3 < g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()))
d1240 1
a1240 1
		if(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload() < 10 && (g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload()*4 < g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download()))
d1252 1
a1252 1
	for(POSITION pos = uploadinglist.GetHeadPosition(); pos != NULL; uploadinglist.GetNext(pos))
d1254 1
a1254 1
		cur_client = uploadinglist.GetAt(pos);
d1258 1
a1258 1
		
@


1.112
log
@formatting;
little optimiZation of the DownloadList sorting code;
fixed sorting of ETA, AVG ETA, TimeRemaining, AvgTimeRemaining columns;
changed and fixed new option 'Show paused and stopped files last', it works and now with all column sort
@
text
@d136 1
a136 1
	// select next client or use given client
d147 1
a147 1
			// clear dead clients
d150 1
d152 1
a152 1
				|| !g_eMuleApp.m_pSharedFilesList->GetFileByID(cur_client->m_reqFileHash) )   // InterCeptor (remove "?" from queue) - readded by DonGato
d162 1
a162 1
				continue;	// eklmn: bugfix(17): upload fix(jump to next client)
d164 1
a164 1
			// finished clearing
d179 1
a179 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader(); // changed by FoRcHa
a183 2
	// obaldin: bug found by dr.clone, but it could be deeper
  	// let's check of client existence in ClientList
d190 1
a190 1
	//SyruS: never upload to a banned & already downloading client
d194 2
a195 2
	// eklmn: Don't accept clients if requested file is in PS_COMPLETING state to prevent unpredictable behaviour 
	// (the existence of the requested file will be done in AddClientToQueue)
d200 1
a200 1
	// tell the client that we are now ready to upload
d205 1
a205 1
		if (!newclient->TryToConnect(true))	// SLUGFILLER: SafeDisconnect
d214 1
a214 1
		newclient->SetLastGotULData();	//eklmn: set Upload Timer
a217 4
/*
	if(ASK_FOR_PARTS_ON_UPLOAD)
		newclient->SendFileRequestForUpload();
*/
d220 1
a220 1
	newclient->ResetCompressionGain(); 	// Add show compression
d223 1
a223 2
	// statistic
	//CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)newclient->m_reqFileHash);
d239 1
a239 1
	// LANCAST (moosetea) - We count lanclients
d242 1
a242 1
    // after 49 days tick wraps around. I think this still handles it. (Yeah right! As if we wouldn't have crashed by then :))
d245 1
a245 1
    // Keeps track of how much bandWidth we use this call
d248 4
a251 4
    // How much data should be given each round?
	if(g_eMuleApp.m_pGlobPrefs->GetMaxUpload() == UNLIMITED) {
        // Special case for unlimited upload

d260 3
a262 2
	    while (pos != NULL){
            // Get the client. Note! Also updates activeClientsListPos as a side effect.
d266 1
a266 1
			// LANCAST (moosetea) - Just Count LAN Clients
d272 1
a272 1
            if(tempWantsMoreBandwidth == true) {
a273 1
            }
d276 3
a278 2
	    if (clientWasReady == false){
            if(m_guessedMaxBandwidth > 300) {
d280 1
a280 1
            } else {
d282 3
a284 2
            }
	    } else {
d289 4
a292 3
    } else {
        // Normal case for limited upload.

d295 2
a296 1
        while(activeClientsListPos != NULL) {
d299 1
a299 1
            if(activeClientsSnapshot > tempMaxActiveClients) {
a300 1
            }
d304 1
a305 1

d310 1
a310 1
        // How many slots should be open? Trickle slots included (at least 2 trickles, 30% of total, and no slot is expected to use more than UPLOAD_CLIENT_DATARATE*2 in average, whichever number is largest)
d323 2
a324 3
        // Add or remove connections as needed. Mostly, this is controlled by the number of
        // fully active uploads.

d329 1
a329 1
            // There's not enough open uploads. Open more another one.
d335 5
a339 5
            // There's to many open uploads (propably due to the user changing
            // the upload limit to a lower value). Remove the last opened upload and put
            // it back on the waitinglist. When it is put back, it get
            // to keep its waiting time. This means it is likely to soon be
            // choosen for upload again.
d342 1
a342 1
		        // Remove from upload list.
d345 2
a346 2
		        // add to queue again. This is almost the same as in method
		        //    g_eMuleApp.m_pUploadQueue->AddClientToQueue(lastClient,true);
d355 2
a356 2
        // There's some saved bandwidth that we want to try to spend this round.
        // curMaxULRatems keeps track of how much data we want to spend.
a357 1

d360 1
a360 1
        // Which active slot are we giving data each loop
d366 5
a370 4
        // The loop that gives the fully activated connections data.
        while (ulpos != NULL && /*slotcounter < activeClients &&*/ (allowedBandwidthThisCall > usedBandwidthThisCall) && wantsMoreBandWidth == false) {
            // Only allow this connection to take what has not already been taken
            // by the other connections above it in the list.
d373 1
a373 1
            // Get the client. Note! Also updates ulpos as a side effect.
d376 3
a378 3
            // Give data to the upload, if it wants it. Remember how much data we have given this call.
            // The connection wont take any data if it hasn't emptied its buffer since we last gave it data.
            // variable wantsMoreBandWidth is updated by this method (it is a ref bool&)
d380 1
a380 1
			// LANCAST (moosetea) - Increment LanCount
d390 5
a394 5
        // Trickle the unneeded uploads (just give them enough to not time out)
        // Theese downloads are kept connected, in a ready-to-go state, just in case
        // one of the fully activated uploads completes/timeouts/ends.
        // As soon as there's a little bandwidth leftover, the first one of these
        // uploads will go to fully activated state
d396 3
a398 2
        while (trickle_client_pos != NULL){
            // Get the client. Note! Also updates trickle_client_pos as a side effect.
d401 4
a404 3
            if(cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < curTick) {
                // It's more than 3 seconds since this connection got any data.
                // Feed it a mercy package to prevent it from timing out.
d406 1
a406 1
				// LANCAST (moosetea) - Increment LanCount
d414 4
a417 4
        // Since we don't save bandwidth for the trickles above, we may
        // have used to much bandwidth.
        // We may also have used to little bandwidth this round, in that
        // case it is saved to the next round.
d420 2
a421 2
        // We don't want to long peaks. Don't save to much bandwidth (about a second should be OK)
        // Always make sure we can save enough to get a packet through
d423 1
a423 1
        if(m_iLeftOverBandwidth > limitSave) {
a424 1
        }
d426 1
a426 1
        // Save number of active clients for statistics
d431 2
a432 4
    // Save sent bytes for speed calculations
	//Cax2 - refactored these lists: easier access to a subset of the data, and less memory usage!

	if(m_averageTickList.empty() || curTick- m_averageTickList.front()>=500)	//Cax2 - update no faster than every .5 sec
d437 1
a437 1
		// remove anything older than 40  seconds
d444 1
a444 1
    // Save time to be able to calculate how long between each call
d447 4
a450 4
	// LANCAST (moosetea) - If we have more than one LAN user were going to upload to them
	// Were going to try uploading the way plus way....... 
	if (QtyLANClients > 0){

d452 1
d454 3
a456 3
	    POSITION pos = uploadinglist.GetHeadPosition();
	    while (pos != NULL){
            // Get the client. Note! Also updates activeClientsListPos as a side effect.
d460 1
a460 1
			// LANCAST (moosetea) - Just Count LAN Clients
a465 1
      
d468 3
a470 2
	    if (clientWasReady == false){
            if(m_guessedMaxLANBandwidth > 3000) {
d472 1
a472 1
            } else {
d474 3
a476 2
            }
	    } else {
a478 1

a480 1
	// START enkeyDEV(th1) -L2HAC- lowid side, automatic callback phase
d482 1
a504 1
	// END enkeyDEV(th1) -L2HAC-
a573 14
/*POSITION CUploadQueue::GetWaitingClientByID(CUpDownClient* client)
{
	EMULE_TRY

	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos)){
		if (client->Compare(waitinglist.GetAt(pos)))
			return pos;
	}

	EMULE_CATCH

	return 0;
}*/

d590 1
a590 2
/*
POSITION CUploadQueue::GetDownloadingClient(CUpDownClient* client)
d592 1
a592 15
	EMULE_TRY

	for (POSITION pos = uploadinglist.GetHeadPosition();pos != 0;uploadinglist.GetNext(pos)){
		if (client == uploadinglist.GetAt(pos))
			return pos;
	}

	EMULE_CATCH

	return 0;
}
*/
uint32	CUploadQueue::GetDataRateShown()		//Cax2 -  roughly 5 seconds sample rate: more immediate data rate feedback.
{
	if(m_averageDataRateList.size() >9)		//Cax2 - do we have those '5 seconds'? (can be messed up by program freezes, etc)
d606 4
a609 3
    // Calculate average data rate
    if(GetTickCount()-m_lastCalculatedDataRateTick > 1000) {
        if(m_averageDataRateList.size() >1) {
d611 1
a611 1
        } else {
a612 1
        }
d624 2
a625 1
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos)){
d643 1
a643 1
	  && g_eMuleApp.m_pServerConnect->IsLowID()
d647 2
a648 1
		&& GetWaitingUserCount() > 50)
d650 1
d653 1
a653 1
	//eklmn: check if file was requested with OP_SETREQFILEID, OP_FILEREQUEST or OP_STARTUPLOADREQ
d656 1
a656 1
	// if file wasn't requested
d660 1
a660 1
	//(filtering invalid eMule clients)
d668 1
a668 1
	// L2HAC- lowid side
d672 6
a677 4
	// LANCAST (moosetea) - We ignore any ban LAN clients may have :)
	if (!bIgnoreTimelimit && !client->IsOnLAN()){
		if (client->IsBanned()){
			if (GetTickCount() - client->GetBanTime() > g_eMuleApp.m_pGlobPrefs->BadClientBanTime()){
a678 1
			}
d684 3
a686 2
	// check for double
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos)){
d688 2
a689 1
		if (cur_client == client){	//already on queue
d694 2
a695 7
/* MERGE26
		// changing back, to avoid hack/mldonkey problems
		else if (client->GetIP() == cur_client->GetIP() || !memcmp(cur_client->GetUserHash(),client->GetUserHash(),16) ) {
		//else if ((client->GetIP() == cur_client->GetIP() && client->GetUserPort() == cur_client->GetUserPort())|| !memcmp(cur_client->GetUserHash(),client->GetUserHash(),16)){ // Lord KiRon
*/
		else if ( client->Compare(cur_client) ) {
			// another client with same ip or hash
a697 1
			
a698 1
			
d702 2
a703 2
				} else
				if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) == IS_IDENTIFIED)
d707 2
a708 2
				} else
				if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) != IS_IDENTIFIED)
d713 2
a714 3
				} else
			// EC - Can this happen? Maybe client tries to re-enter queue
				if (client->m_pCredits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && cur_client->m_pCredits->GetCurrentIdentState(cur_client->GetIP()) == IS_IDENTIFIED)
d719 2
a720 1
			} else 
a735 1
	// done
d737 3
a739 7
/*
	if(ASK_FOR_PARTS_ON_UPLOAD)
		client->SendFileRequestForUpload();
*/

	// Add clients server to list.
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && client->GetServerIP() && client->GetServerPort()){	//SyruS (0.29c)
a746 2
		/*else
			AddLogLine(false, _T("Added new server: %s:%d"), srv->GetFullIP(), srv->GetPort());*/
d749 1
a749 2
	// statistic values
	//CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->m_reqFileHash);
d752 1
a752 1
	// TODO find better ways to cap the list
d755 4
a758 2
	if (client->IsDownloading()){
		// he's already downloading and wants probably only another file
d764 1
a764 1
		client->SetLastGotULData();	//eklmn: set Upload Timer
d767 2
a768 1
	// LANCAST (moosetea) - Lan users bypass the queue
d800 1
a800 2
		//eklmn: Update a a stats
		//           if client got some byte s from us the session will succesfull, otherwise failed
d814 1
a814 1
		// eklmn: if we transfer something we need to update a upload time
d821 1
a821 1
		//report the PartFile that UL is finished
d837 1
a837 1
	if( m_iULSessionSuccessful )
d849 2
a850 1
	if (pos){
d852 1
d854 2
a855 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader(); // changed by FoRcHa
a870 1
	{
a871 1
	}
d873 1
a873 2
	if( todelete->IsBanned() )
	{
a874 1
	}
a876 1
	{
a877 1
	}
d890 4
a893 2
	uint32 score = client->GetScore(true,true); //Maella - Less CPU usage
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos)){
d920 1
d923 3
a925 1
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos)){
d941 1
d944 1
d947 1
d963 1
a963 1
	// Barry - Don't do anything if the app is shutting down - can cause unhandled exceptions
d974 1
a974 2
	// one second
	if (g_iCounter >= 10)
a995 1
		// -khaos--+++> Update connection stats...
d997 2
a998 2
		// 2 seconds
		if (g_iUpdateConnStats>=2) 
a1002 1
		// <-----khaos-
d1004 1
a1004 1
		// display graphs
d1017 1
a1017 1
			// display stats
d1029 1
a1029 1
		//save rates every second
a1030 1
		// mobilemule sockets
d1032 1
d1037 2
a1038 2
		// 5 seconds
		if (g_iSec>=5) 
a1041 1
				{
a1042 2
//					AfxDebugBreak();
				}
d1049 2
a1050 5
			g_eMuleApp.OnlineSig(); // Added By Bouc7 
			g_eMuleApp.m_pdlgEmule->ShowTransferRate();	// eklmn: bugfix(11): crazy output in statusbar (update only tray or window)
		//	TODO - Cax2 - need to refresh 'stuck' clients
		//	if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_dlgStatistics)
		//		g_eMuleApp.m_pdlgEmule->ShowStatistics();
d1058 1
a1058 1
			// This function does NOT update the tree!
d1062 1
d1064 26
a1089 2
			// obaldin/DonGato - Scheduler check
			if(g_eMuleApp.m_pGlobPrefs->IsSCHEnabled())
d1091 12
a1102 4
				CTime curr_t = CTime::GetCurrentTime();
				uint32 secs = curr_t.GetSecond() + 60*curr_t.GetMinute() + 60*60*curr_t.GetHour();

				if(secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift1()-120 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift1()+120)
d1104 7
a1110 7
					// switching to shift1 speeds
					g_eMuleApp.m_pUploadQueue->SCHShift1UploadCheck();
					g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload());
					g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download());
					g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn());
					g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec());
					// Purity - Sending message for scheduler shift 1
d1112 5
a1116 5
					MessageText.Format( _T("SCHEDULER: switching to Shift 1 (Max Upload:%i Max Download:%i Max Connections:%i Max In 5 secs:%i)"),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(), 
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn(),
										g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec() );
a1119 33
				} 
				else if (secs > g_eMuleApp.m_pGlobPrefs->GetSCHShift2()-120 && secs < g_eMuleApp.m_pGlobPrefs->GetSCHShift2()+120) 
				{
                    			int dayOfWeek = curr_t.GetDayOfWeek();
					if ((dayOfWeek==2 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptMon()) 
						|| (dayOfWeek==3 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptTue()) 
						|| (dayOfWeek==4 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptWed()) 
						|| (dayOfWeek==5 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptThu()) 
						|| (dayOfWeek==6 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptFri()) 
						|| (dayOfWeek==7 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSat()) 
						|| (dayOfWeek==1 && g_eMuleApp.m_pGlobPrefs->IsSCHExceptSun()))
                    			{
                        			CLoggable::AddDebugLogLine(true, CString("SCHEDULER: day excepted!"));
					} 
					else 
					{
						// switching to shift2 speeds
						g_eMuleApp.m_pUploadQueue->SCHShift2UploadCheck();
						g_eMuleApp.m_pGlobPrefs->SetMaxUpload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload());
						g_eMuleApp.m_pGlobPrefs->SetMaxDownload(g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download());
						g_eMuleApp.m_pGlobPrefs->SetMaxConnections(g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn());
						g_eMuleApp.m_pGlobPrefs->SetMaxDownloadConperFive(g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec());
						// Purity - Sending message for scheduler shift 2
						CString MessageText;
						MessageText.Format( _T("SCHEDULER: switching to Shift 2 (Max Upload:%i Max Download:%i Max Connections:%i Max In 5 secs:%i)"),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(), 
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download(),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn(),
											g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec() );
						g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
						g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SCHEDULER, false, g_eMuleApp.m_pGlobPrefs->GetUseSchedulerNotifier());
						CLoggable::AddDebugLogLine(true, MessageText);
					}
d1134 1
d1137 1
d1139 3
a1141 1
	if (!pos){
d1146 1
a1161 1
	
d1163 3
a1165 1
	while(pos) {
d1172 3
a1174 1
	while(pos) {
@


1.111
log
@Improved and corrected implementation of saving thread
@
text
@a1218 1

@


1.110
log
@added "Watch clipboard for ed2k links"
@
text
@a52 1
	m_bExiting	=	FALSE;
d85 1
a85 1
    for (int i = 0;i != 35;i++)
d88 1
a88 1
    m_MaxActiveClients = 0;
d90 1
a90 1
    m_iLeftOverBandwidth = 0;
d92 1
a92 1
    m_guessedMaxBandwidth = 300;
d95 2
a96 2
    m_lastGaveDataTick = ::GetTickCount();
    m_lastCalculatedDataRateTick = 0;
d98 6
a103 3
	// Create timer to save known sources each 30 min 
	m_hSaveSTimer	=	::CreateWaitableTimer(NULL,FALSE,NULL);
	if ( m_hSaveSTimer )
d106 4
a109 4
		m_pSaveThread = AfxBeginThread( SaveSourcesThread,
										(LPVOID)this,
										THREAD_PRIORITY_NORMAL+g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority() );
		if ( ! m_pSaveThread )
d111 5
a115 2
			::CloseHandle(m_hSaveSTimer);
			m_hSaveSTimer	=	NULL;
a116 1
		}
d544 2
a545 1
CUploadQueue::~CUploadQueue(){
d547 2
a548 1
	if ( m_hSaveSTimer )
d550 5
a554 19
		m_pSaveThread->SuspendThread();
		__int64         qwDueTime;
		LARGE_INTEGER   liDueTime;
		qwDueTime = -1;         // Copy the relative time into a LARGE_INTEGER.
		liDueTime.LowPart  = (DWORD) ( qwDueTime & 0xFFFFFFFF );
		liDueTime.HighPart = (LONG)  ( qwDueTime >> 32 );
		// re-Set the timer to me inworked each second
		::SetWaitableTimer(m_hSaveSTimer,&liDueTime,1,NULL,NULL,TRUE);
		// Set the thread to Get more CPU to finish fast
		m_pSaveThread->SetThreadPriority(THREAD_PRIORITY_HIGHEST+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority());
		HANDLE hArr[2];
		hArr[0]	=	m_hSaveSTimer;
		hArr[1]	=	m_pSaveThread->m_hThread;
		// set thread to exit 
		m_bExiting	=	TRUE;
		// Resume the thread
		m_pSaveThread->ResumeThread();
		// Wait until thread finishes 10000 sec - this should be enough
		if ( WaitForMultipleObjects(2,hArr,TRUE,10000000) == WAIT_TIMEOUT )
d558 2
d561 5
a867 3

		// Save() is called in SaveSourcesThread every 30 min now (and on exit of course), no need to do it here too
		// g_eMuleApp.m_pKnownFilesList->Save();
d1220 1
a1220 1

d1223 16
a1238 22
	HANDLE hTimer;
	hTimer	=	((CUploadQueue*)lpArg)->m_hSaveSTimer;
	if ( !hTimer )
	{
		return -1;
	}
    __int64         qwDueTime;
     LARGE_INTEGER   liDueTime;
    qwDueTime = -30*60*1000;         // Copy the relative time into a LARGE_INTEGER.
    liDueTime.LowPart  = (DWORD) ( qwDueTime & 0xFFFFFFFF );
    liDueTime.HighPart = (LONG)  ( qwDueTime >> 32 );
	// Set timer to signal each 30 min 
	::SetWaitableTimer(hTimer,&liDueTime,30*60*1000,NULL,NULL,TRUE);
	bool bFirstRun	=	true;
	while (!(((CUploadQueue*)lpArg)->m_bExiting) )
	{
		// Wait for timer signal 
		::WaitForSingleObject(hTimer,INFINITE);
		// If eMule supposed to exit
		if ( (((CUploadQueue*)lpArg)->m_bExiting) )
		{
			// break and finish the thread
d1240 1
a1240 9
		}
		// avoid running right away
		if ( bFirstRun )
		{
			bFirstRun	=	false;
			continue;
		}
		SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority());
		// process (save) sources each 30 min
a1241 1
		SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority());
a1242 2
	// Close timer also to signal that we finished
	::CloseHandle(hTimer);
@


1.109
log
@removed MOBILE_MULE and JUMPSTART defines + minor improvements (thx aw3)
@
text
@d1018 1
a1018 1
	        g_eMuleApp.m_pClientCreditList->Process();
d1026 5
@


1.108
log
@removed old #define KEEP_BANNED_CLIENTS
@
text
@a1070 1
#ifdef MOBILE_MULE
a1071 1
#endif //MOBILE_MULE
@


1.107
log
@BUGFIX: decision whether to compress packets was case sensitive + added some more file extension + some other changes
@
text
@d913 1
d915 2
a918 6
#if KEEP_BANNED_CLIENTS
		//SyruS don't unban and remove from queue
		if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("(NOT YET) Keeping banned client '%s' in waitingqueue"), todelete->GetUserName());
		//1st idea (dont use yet)... return;
#endif
d923 1
d925 2
@


1.106
log
@avoid some not necessary disc writes
@
text
@d62 2
a63 5
//	sumavgdata = 0;				// enkeyDEV(Ottavio84) -Accurate speed measurement-
//	sendtimestamp = GetTickCount();	// enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
//	bDataRateMaxed = false; 		// Tarod [LoneStar]
//	lasttimechecked = GetTickCount() ;
	//eklmn: Extended Upload stats
d254 2
a255 1
        if (CanAcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount()) {
d327 2
a328 1
           (lastClient == NULL || lastClient->GetUpStartTimeDelay() > MINWAITBEFOREOPENANOTHERSLOTMS)) {
d331 4
a334 2
        } else if(uploadinglist.GetCount() > MIN_UP_CLIENTS_ALLOWED &&
                CanAcceptNewClient(uploadinglist.GetCount()-1) == false) {
d340 2
a341 1
            if(!lastClient->IsOnLAN() && lastClient->GetUpStartTimeDelay() > 3*1000) {   
a695 1
	//end (filtering invalid eMule clients) // Mr Faber / netwolf
d700 1
a700 1
	// START enkeyDEV(th1) -L2HAC- lowid side
a702 1
	// END enkeyDEV(th1) -L2HAC-
a808 4
	//if (waitinglist.IsEmpty() && CanAcceptNewClient())
	//	AddUpNextClient(client);
	//else{

d812 2
a813 1
	else{
@


1.105
log
@recommit for "Completion Fix" with Aw3 correction
@
text
@d873 2
a874 2
		// Added by Tarod -saves known.met file to avoid loosing it by accident
		g_eMuleApp.m_pKnownFilesList->Save();
a1012 6

	//--- xrmb:statsautosave ---
	//--- it might be not the best idea to do this here :) ---
	//g_eMuleApp.m_pKnownFilesList->Process();		//Cax2 moved back to SaveSourcesThread() - this function is deprecated! :P
	//--- :xrmb ---
	
d1103 1
a1103 1
		if (g_iStatSave>=60) 
a1104 1
			// Time to save our cumulative statistics.
a1106 2
			// -khaos--+++>
			// CPreferences::SaveStats() in Preferences.cpp
a1108 1
			// <-----khaos-
a1258 1
		//g_eMuleApp.m_pKnownFilesList->Process();			//Cax2 - no more need for that..
@


1.104
log
@Optimized scheduler code on startup
@
text
@d866 6
a871 6
//		//report the PartFile that UL is finished
//		if (client->pUploadingPartFile)
//		{
//			client->pUploadingPartFile->SetFileUpload(false);
//			client->pUploadingPartFile = NULL;
//		}
@


1.103
log
@fix for Scheduler shift on restart / fix for Preallocate handling of exceptions / eklmn fix for ICR
@
text
@d1138 5
a1142 2
					MessageText.Format( _T("Switching to Shift 1 (MaxU:%i MaxD:%i MaxC:%i Max5:%i)"), g_eMuleApp.m_pGlobPrefs->GetSCHShift1Upload(), 
										g_eMuleApp.m_pGlobPrefs->GetSCHShift1Download(), g_eMuleApp.m_pGlobPrefs->GetSCHShift1conn(), g_eMuleApp.m_pGlobPrefs->GetSCHShift15sec() );
d1158 1
a1158 1
                        			CLoggable::AddDebugLogLine(true, CString("Day excepted!"));
d1170 5
a1174 2
						MessageText.Format( _T("Switching to Shift 2 (MaxU:%i MaxD:%i MaxC:%i Max5:%i)"), g_eMuleApp.m_pGlobPrefs->GetSCHShift2Upload(), 
											g_eMuleApp.m_pGlobPrefs->GetSCHShift2Download(), g_eMuleApp.m_pGlobPrefs->GetSCHShift2conn(), g_eMuleApp.m_pGlobPrefs->GetSCHShift25sec() );
@


1.102
log
@Reverted completion 'fix' by eklmn so we can release 1j this month
@
text
@d1138 2
a1139 1
					MessageText.Format(CString("Switching to Shift 1"));
d1142 1
a1142 1
					CLoggable::AddDebugLogLine(true, CString("Switching to Shift 1"));
d1167 2
a1168 1
						MessageText.Format(CString("Switching to Shift 2"));
d1171 1
a1171 1
						CLoggable::AddDebugLogLine(true, CString("Switching to Shift 2"));
@


1.101
log
@eklmn's changes
@
text
@d866 6
a871 6
		//report the PartFile that UL is finished
		if (client->pUploadingPartFile)
		{
			client->pUploadingPartFile->SetFileUpload(false);
			client->pUploadingPartFile = NULL;
		}
@


1.100
log
@new way of syncronization by file completion
@
text
@d867 1
a867 2
		CPartFile* pUploadedFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(client->m_reqFileHash);
		if (pUploadedFile && client->bPartFileIsUploading == true)
d869 2
a870 2
			pUploadedFile->SetFileUpload(false);
			client->bPartFileIsUploading = false;
@


1.99
log
@Fixed debuglog problem with a SourceSaver change.
Reinstated removal of ? clients on queue.
@
text
@d865 9
@


1.98
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d149 3
a151 2
			if (::GetTickCount() - cur_client->GetLastUpRequest() > MAX_PURGEQUEUETIME)
			{  
@


1.97
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d56 1
a56 1
		AddDebugLogLine(false, RGB_RED + GetResString(IDS_ERR_TIMERCREATEFAILED));
d114 1
a114 1
			AddDebugLogLine(false, RGB_RED + _T("Error creating SourcesSaveThread"));
d119 1
a119 1
		AddDebugLogLine(false, RGB_RED + GetResString(IDS_ERR_TIMERCREATEFAILED));
d735 1
a735 1
					AddDebugLogLine(false, RGB_BLUE_GRAY + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d740 1
a740 1
					AddDebugLogLine(false, RGB_BLUE_GRAY + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d745 1
a745 1
					AddDebugLogLine(false, RGB_BLUE_GRAY + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),"both" );
d752 1
a752 1
					AddDebugLogLine(false, RGB_BLUE_GRAY + _T("-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s"),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName());
d757 1
a757 1
				AddDebugLogLine(false, RGB_BLUE_GRAY + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d913 1
a913 1
			AddDebugLogLine(false, RGB_BLUE_GRAY + _T("(NOT YET) Keeping banned client '%s' in waitingqueue"), todelete->GetUserName());
d1083 1
a1083 1
					g_eMuleApp.AddLogLine(false, RGB_PINK + _T("** ") + RGB_RED + _T("Memory corruption detected") + RGB_PINK + _T(" **"));
@


1.96
log
@Added some colors to the logs...
@
text
@d56 1
a56 1
		AddDebugLogLine(false,_T("<COLOR=255,0,0>") + GetResString(IDS_ERR_TIMERCREATEFAILED));
d114 1
a114 1
			AddDebugLogLine(false,_T("<COLOR=255,0,0>Error creating SourcesSaveThread"));
d119 1
a119 1
		AddDebugLogLine(false,_T("<COLOR=255,0,0>") + GetResString(IDS_ERR_TIMERCREATEFAILED));
d185 1
a185 1
		AddDebugLogLine(false,_T("AddUpNextClient(): client not in ClientList"));
d735 1
a735 1
					AddDebugLogLine(false,_T("<COLOR=102,102,153>") + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d740 1
a740 1
					AddDebugLogLine(false,_T("<COLOR=102,102,153>") + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d745 1
a745 1
					AddDebugLogLine(false,_T("<COLOR=102,102,153>") + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),"both" );
d752 1
a752 1
					AddDebugLogLine(false,"<COLOR=102,102,153>-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s",client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName());
d757 1
a757 1
				AddDebugLogLine(false,_T("<COLOR=102,102,153>") + GetResString(IDS_SAMEUSERHASH),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d788 1
a788 1
			AddLogLine(false,"Added new server: %s:%d", srv->GetFullIP(), srv->GetPort());*/
d913 1
a913 1
			AddDebugLogLine(false, _T("<COLOR=102,102,153>(NOT YET) Keeping banned client '%s' in waitingqueue"), todelete->GetUserName());
d1083 1
a1083 1
					g_eMuleApp.AddLogLine(false,"<COLOR=255,0,255>**<COLOR=255,0,0> Memory corruption detected <COLOR=255,0,255>**");
d1132 1
a1132 1
					CLoggable::AddDebugLogLine(true,CString("Switching to Shift 1"));
d1145 1
a1145 1
                        			CLoggable::AddDebugLogLine(true,CString("Day excepted!"));
d1160 1
a1160 1
						CLoggable::AddDebugLogLine(true,CString("Switching to Shift 2"));
@


1.95
log
@fix for statistics tree update delay not obeyed (#481)
@
text
@d56 1
a56 1
		AddDebugLogLine(false,IDS_ERR_TIMERCREATEFAILED);
d114 1
a114 1
			AddDebugLogLine(false,_T("Error creating SourcesSaveThread"));
d119 1
a119 1
		AddDebugLogLine(false,IDS_ERR_TIMERCREATEFAILED);
d735 1
a735 1
					AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d740 1
a740 1
					AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d745 1
a745 1
					AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),"both" );
d752 1
a752 1
					AddDebugLogLine(false,"-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s",client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName());
d757 2
a758 2
			AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
			RemoveFromWaitingQueue(pos,true);	
d913 1
a913 1
			AddDebugLogLine(false, _T("(NOT YET) Keeping banned client '%s' in waitingqueue"), todelete->GetUserName());
d1083 1
a1083 1
					g_eMuleApp.AddLogLine(false,"** Memory corruption detected **");
@


1.94
log
@Keep-Alive for server connections
@
text
@d1015 2
a1016 1
	if (g_iCounter >= 10){
d1035 2
a1036 1
		if (g_iUpdateConnStats>=2) {
d1047 2
a1048 1
			if (g_iGraph >= (uint32)(g_eMuleApp.m_pGlobPrefs->GetTrafficOMeterInterval()) ) {
d1053 2
a1054 1
		if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_dlgStatistics && g_eMuleApp.m_pdlgEmule->IsWindowVisible() )  {
d1056 2
a1057 1
			if (g_eMuleApp.m_pGlobPrefs->GetStatsInterval()>0) {
d1060 2
a1061 1
				if (g_iStats >= (uint32)(g_eMuleApp.m_pGlobPrefs->GetStatsInterval()) ) {
d1078 2
a1079 1
		if (g_iSec>=5) {
d1095 2
a1096 2
			if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_dlgStatistics)
				g_eMuleApp.m_pdlgEmule->ShowStatistics();
@


1.93
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d1104 2
@


1.92
log
@Formatting, comments, and name changes.
@
text
@d491 1
a491 1
					cur_client->SetLastL2HACExecution(curTick - cur_client->GetL2HACTime() + (uint32)ROUND(((float)rand()/RAND_MAX)*300000));
d641 1
a641 1
	        m_iDataRate = (uint32)(((float)(m_averageDataRateList.front()-m_averageDataRateList.back()))*1000 / (m_averageTickList.front()-m_averageTickList.back()));
d1036 1
a1036 1
			g_eMuleApp.m_pdlgEmule->m_dlgStatistics.UpdateConnectionStats((float)g_eMuleApp.m_pUploadQueue->GetDataRate()/1024, (float)g_eMuleApp.m_pDownloadQueue->GetDataRate()/1024);
d1047 1
a1047 1
				g_eMuleApp.m_pdlgEmule->m_dlgStatistics.SetCurrentRate(((float)g_eMuleApp.m_pUploadQueue->GetDataRateShown())/1024,((float)g_eMuleApp.m_pDownloadQueue->GetDataRate())/1024);
@


1.91
log
@1) "fixed" bug 0000295
2) some otimization in upload
3) don't upload the file if it has a status COMPLETING
@
text
@d45 1
a45 1
//TODO rewrite the whole networkcode, use overlapped sockets
d1087 1
a1087 1
			//TODO - Cax2 - need to refresh 'stuck' clients
@


1.90
log
@minor log change
@
text
@d134 1
d136 2
a137 1
	if (!directadd){
d139 4
a142 1
		for (pos1 = waitinglist.GetHeadPosition();( pos2 = pos1 ) != NULL;){
d144 2
a145 1
			CUpDownClient* cur_client =	waitinglist.GetAt(pos2);
d147 1
a147 1
			ASSERT(cur_client->GetLastUpRequest()); 
d149 2
a150 2
			if (GetTickCount() - cur_client->GetLastUpRequest() > MAX_PURGEQUEUETIME
					|| !g_eMuleApp.m_pSharedFilesList->GetFileByID(cur_client->m_reqFileHash)) {   // [InterCeptor (remove "?" from queue) 15.11.02]
d162 1
a162 2
			else if ( (cur_client->GetScore(true) > bestscore) && (!cur_client->IsBanned()) 
				&& (!cur_client->HasLowID()
d166 2
a167 1
				) ){
d181 5
a185 1
	if (IsDownloading(newclient) || newclient->IsBanned(true)) {	//SyruS never upload to a banned client
d188 11
d201 2
a202 1
	if (!newclient->m_pRequestSocket || !newclient->m_pRequestSocket->IsConnected()){
d207 2
a208 1
	else{
a215 7
  // obaldin: bug found by dr.clone, but it could be deeper
  // let's put in the check for now
  if(!g_eMuleApp.m_pClientList->IsValidClient(newclient))
  {
    AddDebugLogLine(false,_T("AddUpNextClient(): client not in ClientList"));
    return;
  }
d227 1
a227 1
	CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)newclient->m_reqFileHash);
d682 1
d685 2
a686 2
//	Don't accept clients if requested file is in completing state
	if (m_pReqPartFile != NULL && m_pReqPartFile->IsPartFile() && ((CPartFile*)m_pReqPartFile)->GetStatus() == PS_COMPLETING)
@


1.89
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d718 1
a718 1
					AddDebugLogLine(true,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d723 1
a723 1
					AddDebugLogLine(true,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d728 1
a728 1
					AddDebugLogLine(true,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),"both" );
d735 1
a735 1
					AddDebugLogLine(true,"-->Two Identified clients (%s) and (%s)  have the same Userhash or IP, Removing %s",client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName());
@


1.88
log
@no message
@
text
@d144 1
a144 1
					|| !g_eMuleApp.m_pSharedFilesList->GetFileByID(cur_client->reqfileid)) {   // [InterCeptor (remove "?" from queue) 15.11.02]
d211 3
a213 3
	CKnownFile* reqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)newclient->reqfileid);
	if (reqfile)
		reqfile->statistic.AddAccepted();
d253 1
a253 1
			if (cur_client->isOnLAN())
d322 1
a322 1
            if(!lastClient->isOnLAN() && lastClient->GetUpStartTimeDelay() > 3*1000) {   
d362 1
a362 1
			if (cur_client->isOnLAN())
d386 1
a386 1
				if (cur_client->isOnLAN())
d442 1
a442 1
			if (cur_client->isOnLAN())
d666 1
a666 1
	CKnownFile* reqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->reqfileid);
d669 1
a669 1
	if (reqfile != NULL && reqfile->IsPartFile() && ((CPartFile*)reqfile)->GetStatus() == PS_COMPLETING)
d687 1
a687 1
	if (!bIgnoreTimelimit && !client->isOnLAN()){
d695 1
a695 1
		client->AddRequestCount(client->reqfileid);
d715 1
a715 1
				if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && cur_client->credits->GetCurrentIdentState(cur_client->GetIP()) != IS_IDENTIFIED)
d721 1
a721 1
				if (client->credits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && cur_client->credits->GetCurrentIdentState(cur_client->GetIP()) == IS_IDENTIFIED)
d726 1
a726 1
				if (client->credits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED && cur_client->credits->GetCurrentIdentState(cur_client->GetIP()) != IS_IDENTIFIED)
d733 1
a733 1
				if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED && cur_client->credits->GetCurrentIdentState(cur_client->GetIP()) == IS_IDENTIFIED)
d775 2
a776 2
	//CKnownFile* reqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)client->reqfileid);
	if (reqfile) reqfile->statistic.AddRequest();
d796 1
a796 1
	if (client->isOnLAN())
d1177 1
a1177 1
		if(md4cmp(potential->reqfileid, filehash) == 0)
d1184 1
a1184 1
		if(md4cmp(potential->reqfileid, filehash) == 0)
d1275 1
a1275 1
		if (cur_client->reqfile == check_file)
@


1.87
log
@no message
@
text
@d148 4
a151 1
					cur_client->Disconnected();
d745 5
a749 2
			if (!cur_client->m_pRequestSocket)
				cur_client->Disconnected();	
@


1.86
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d147 1
a147 1
				if(!cur_client->socket)
d156 1
a156 1
				|| (cur_client->socket && cur_client->socket->IsConnected()) 
d177 1
a177 1
	if (!newclient->socket || !newclient->socket->IsConnected()){
d185 1
a185 1
		newclient->socket->SendPacket(packet,true);
d471 1
a471 1
				if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(cur_client->socket && cur_client->socket->IsConnected()) )
d742 1
a742 1
			if (!cur_client->socket)
d780 1
a780 1
		client->socket->SendPacket(packet,true);
d1051 5
a1055 1
				if (!AfxCheckMemory()) AfxDebugBreak();
@


1.85
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d212 1
a212 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.AddClient(newclient);
d328 1
a328 1
		        g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.AddClient(lastClient, false);
d699 1
a699 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(client);
d796 1
a796 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.AddClient(client);
d818 1
a818 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.RemoveClient(client);
d897 1
a897 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RemoveClient(todelete);
@


1.84
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d183 1
a183 1
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ,0);
d777 1
a777 1
		Packet* packet = new Packet(OP_ACCEPTUPLOADREQ,0);
@


1.83
log
@Formatting, comments, and name changes.
@
text
@d184 1
a184 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d778 1
a778 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
@


1.82
log
@Formatting, comments, and name changes.
@
text
@d192 1
a192 1
  if(!g_eMuleApp.m_pClientList->Debug_IsValidClient(newclient))
d762 1
a762 1
		if (!g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.AddServer(srv, true))
@


1.81
log
@Access Violation fixed
@
text
@d411 1
a411 1
	if(average_tick_list.empty() || curTick- average_tick_list.front()>=500)	//Cax2 - update no faster than every .5 sec
d413 2
a414 2
		average_dr_list.push_front(g_eMuleApp.stat_sessionSentBytes);
		average_tick_list.push_front(curTick);
d417 1
a417 1
		while(curTick-average_tick_list.back() > 40000)
d419 2
a420 2
   			average_dr_list.pop_back();
			average_tick_list.pop_back();
d605 1
a605 1
	if(average_dr_list.size() >9)		//Cax2 - do we have those '5 seconds'? (can be messed up by program freezes, etc)
d607 2
a608 2
		list<uint64>::iterator dr=average_dr_list.begin();
		list<DWORD>::iterator tick=average_tick_list.begin();
d611 1
a611 1
		return (uint32)( (average_dr_list.front() - (*dr))*1000.0f/(average_tick_list.front() - (*tick)) );
d621 2
a622 2
        if(average_dr_list.size() >1) {
	        m_iDataRate = (uint32)(((float)(average_dr_list.front()-average_dr_list.back()))*1000 / (average_tick_list.front()-average_tick_list.back()));
@


1.80
log
@Formatting, comments, and name changes.
@
text
@d725 1
a725 1
					AddDebugLogLine(true,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),'both' );
@


1.79
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d999 1
a999 1
			g_eMuleApp.m_pServerConnect->TryAnotherConnectionrequest();
@


1.78
log
@Second batch of name changes
@
text
@d19 1
a19 1
#include "uploadqueue.h"
d24 1
a24 1
#include "listensocket.h"
d109 1
a109 1
										THREAD_PRIORITY_NORMAL+theApp.glob_prefs->GetMainProcessPriority() );
d129 1
a129 1
	if (theApp.listensocket->TooManySockets()) return;
d144 1
a144 1
					|| !theApp.sharedfiles->GetFileByID(cur_client->reqfileid)) {   // [InterCeptor (remove "?" from queue) 15.11.02]
d167 1
a167 1
		theApp.emuledlg->transferwnd.UpdateUploadHeader(); // changed by FoRcHa
d184 1
a184 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d192 1
a192 1
  if(!theApp.clientlist->Debug_IsValidClient(newclient))
d208 1
a208 1
	CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)newclient->reqfileid);
d212 1
a212 1
	theApp.emuledlg->transferwnd.m_wndUploadList.AddClient(newclient);
d234 1
a234 1
	if(theApp.glob_prefs->GetMaxUpload() == UNLIMITED) {
d287 1
a287 1
	    sint32 realMaxULRatems = (theApp.glob_prefs->GetMaxUpload()*1024*timeSinceLastGaveDataMs)/1000;
d292 1
a292 1
        sint32 wantedNumberOfTotalUploads = max((uint32)(theApp.glob_prefs->GetMaxUpload()*1024/(UPLOAD_CLIENT_DATARATE*2)), m_MaxActiveClients + MINNUMBEROFTRICKLEUPLOADS);
d321 1
a321 1
		        theApp.uploadqueue->RemoveFromUploadQueue(lastClient, ETS_TIMEOUT, true);
d324 1
a324 1
		        //    theApp.uploadqueue->AddClientToQueue(lastClient,true);
d328 2
a329 2
		        theApp.emuledlg->transferwnd.m_wndQueueList.AddClient(lastClient, false);
		        theApp.emuledlg->transferwnd.UpdateUploadHeader();
d413 1
a413 1
		average_dr_list.push_front(theApp.stat_sessionSentBytes);
d461 1
a461 1
	if (theApp.serverconnect->IsConnected() && theApp.serverconnect->IsLowID())
d471 1
a471 1
				if (theApp.listensocket->TooManySockets() && !(cur_client->socket && cur_client->socket->IsConnected()) )
d499 1
a499 1
	if (theApp.glob_prefs->GetMaxUpload() == UNLIMITED)
d506 1
a506 1
		if (numberOfUploads < (uint32)(theApp.glob_prefs->GetMaxUpload()*1024/UPLOAD_LOW_CLIENT_DR)+1)
d531 1
a531 1
		m_pSaveThread->SetThreadPriority(THREAD_PRIORITY_HIGHEST+ theApp.glob_prefs->GetMainProcessPriority());
d654 3
a656 3
	if ( theApp.serverconnect->IsConnected()
	  && theApp.serverconnect->IsLowID()
		&& !theApp.serverconnect->IsLocalServer(client->GetServerIP(),client->GetServerPort())
d663 1
a663 1
	CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)client->reqfileid);
d686 1
a686 1
			if (GetTickCount() - client->GetBanTime() > theApp.glob_prefs->BadClientBanTime()){
d699 1
a699 1
			theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(client);
d709 1
a709 1
			if (theApp.glob_prefs->IsSecureIdentEnabled())
d756 1
a756 1
	if (theApp.glob_prefs->GetAddServersFromConn() && client->GetServerIP() && client->GetServerPort()){	//SyruS (0.29c)
d762 1
a762 1
		if (!theApp.emuledlg->serverwnd.serverlistctrl.AddServer(srv, true))
d769 1
a769 1
	//CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)client->reqfileid);
d773 1
a773 1
	if ((uint32)waitinglist.GetCount() >= (theApp.glob_prefs->GetQueueSize()+m_iBannedCount))
d778 1
a778 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d796 2
a797 2
		theApp.emuledlg->transferwnd.m_wndQueueList.AddClient(client);
		theApp.emuledlg->transferwnd.UpdateUploadHeader();
d803 1
a803 1
bool CUploadQueue::RemoveFromUploadQueue(CUpDownClient* client, eEndTransferSession eReason, bool updatewindow )
d818 1
a818 1
			theApp.emuledlg->transferwnd.m_wndUploadList.RemoveClient(client);
d842 1
a842 1
		theApp.knownfiles->Save();
d868 1
a868 1
			theApp.emuledlg->transferwnd.UpdateUploadHeader(); // changed by FoRcHa
d889 1
a889 1
		if (!theApp.glob_prefs->GetCMNotLog())
d897 1
a897 1
		theApp.emuledlg->transferwnd.m_wndQueueList.RemoveClient(todelete);
d975 1
a975 1
	if (!theApp.emuledlg->IsRunning())
d978 3
a980 3
	theApp.clientlist->ResetAllValueCaches();
	theApp.uploadqueue->Process();
	theApp.downloadqueue->Process();
d984 1
a984 1
	//theApp.knownfiles->Process();		//Cax2 moved back to SaveSourcesThread() - this function is deprecated! :P
d987 2
a988 2
    theApp.uploadqueue->CompUpDataRateOverhead();
	theApp.downloadqueue->CompDownDataRateOverhead();
d994 3
a996 3
	        theApp.clientcredits->Process();
		theApp.serverlist->Process();
		theApp.friendlist->Process();
d998 2
a999 2
		if( theApp.serverconnect->IsConnecting())
			theApp.serverconnect->TryAnotherConnectionrequest();
d1002 1
a1002 1
		theApp.emuledlg->statisticswnd.UpdateConnectionsStatus();
d1005 1
a1005 1
		if (theApp.serverconnect->IsConnecting()) theApp.serverconnect->CheckForTimeout();
d1013 1
a1013 1
			theApp.emuledlg->statisticswnd.UpdateConnectionStats((float)theApp.uploadqueue->GetDataRate()/1024, (float)theApp.downloadqueue->GetDataRate()/1024);
d1018 1
a1018 1
		if(theApp.glob_prefs->GetTrafficOMeterInterval()>0) 
d1022 1
a1022 1
			if (g_iGraph >= (uint32)(theApp.glob_prefs->GetTrafficOMeterInterval()) ) {
d1024 1
a1024 1
				theApp.emuledlg->statisticswnd.SetCurrentRate(((float)theApp.uploadqueue->GetDataRateShown())/1024,((float)theApp.downloadqueue->GetDataRate())/1024);
d1027 1
a1027 1
		if (theApp.emuledlg->activewnd == &theApp.emuledlg->statisticswnd && theApp.emuledlg->IsWindowVisible() )  {
d1029 1
a1029 1
			if (theApp.glob_prefs->GetStatsInterval()>0) {
d1032 1
a1032 1
				if (g_iStats >= (uint32)(theApp.glob_prefs->GetStatsInterval()) ) {
d1034 1
a1034 1
					theApp.emuledlg->ShowStatistics();
d1039 1
a1039 1
		theApp.emuledlg->statisticswnd.RecordRate();
d1043 1
a1043 1
		theApp.mmserver->Process();
d1056 1
a1056 1
			theApp.listensocket->Process();
d1058 2
a1059 2
			theApp.OnlineSig(); // Added By Bouc7 
			theApp.emuledlg->ShowTransferRate();	// eklmn: bugfix(11): crazy output in statusbar (update only tray or window)
d1061 2
a1062 2
			if (theApp.emuledlg->activewnd == &theApp.emuledlg->statisticswnd)
				theApp.emuledlg->ShowStatistics();
d1074 1
a1074 1
			theApp.glob_prefs->SaveStats();
d1078 1
a1078 1
			if(theApp.glob_prefs->IsSCHEnabled())
d1083 1
a1083 1
				if(secs > theApp.glob_prefs->GetSCHShift1()-120 && secs < theApp.glob_prefs->GetSCHShift1()+120)
d1086 5
a1090 5
					theApp.uploadqueue->SCHShift1UploadCheck();
					theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetSCHShift1Upload());
					theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetSCHShift1Download());
					theApp.glob_prefs->SetMaxConnections(theApp.glob_prefs->GetSCHShift1conn());
					theApp.glob_prefs->SetMaxDownloadConperFive(theApp.glob_prefs->GetSCHShift15sec());
d1094 2
a1095 2
					theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetUseSchedulerNotifier(), theApp.glob_prefs->IsSMTPInfoEnabled());
					theApp.emuledlg->ShowNotifier(MessageText, TBN_SCHEDULER, false, theApp.glob_prefs->GetUseSchedulerNotifier());
d1098 1
a1098 1
				else if (secs > theApp.glob_prefs->GetSCHShift2()-120 && secs < theApp.glob_prefs->GetSCHShift2()+120) 
d1101 7
a1107 7
					if ((dayOfWeek==2 && theApp.glob_prefs->IsSCHExceptMon()) 
						|| (dayOfWeek==3 && theApp.glob_prefs->IsSCHExceptTue()) 
						|| (dayOfWeek==4 && theApp.glob_prefs->IsSCHExceptWed()) 
						|| (dayOfWeek==5 && theApp.glob_prefs->IsSCHExceptThu()) 
						|| (dayOfWeek==6 && theApp.glob_prefs->IsSCHExceptFri()) 
						|| (dayOfWeek==7 && theApp.glob_prefs->IsSCHExceptSat()) 
						|| (dayOfWeek==1 && theApp.glob_prefs->IsSCHExceptSun()))
d1114 5
a1118 5
						theApp.uploadqueue->SCHShift2UploadCheck();
						theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetSCHShift2Upload());
						theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetSCHShift2Download());
						theApp.glob_prefs->SetMaxConnections(theApp.glob_prefs->GetSCHShift2conn());
						theApp.glob_prefs->SetMaxDownloadConperFive(theApp.glob_prefs->GetSCHShift25sec());
d1122 2
a1123 2
						theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetUseSchedulerNotifier(), theApp.glob_prefs->IsSMTPInfoEnabled());
						theApp.emuledlg->ShowNotifier(MessageText, TBN_SCHEDULER, false, theApp.glob_prefs->GetUseSchedulerNotifier());
d1214 1
a1214 1
		SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL+ theApp.glob_prefs->GetMainProcessPriority());
d1216 3
a1218 3
		//theApp.knownfiles->Process();			//Cax2 - no more need for that..
		theApp.knownfiles->Save();	
		SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority());
d1229 1
a1229 1
	if(theApp.glob_prefs->GetSCHShift1Upload() != 0)
d1231 2
a1232 2
		if(theApp.glob_prefs->GetSCHShift1Upload() < 4 && (theApp.glob_prefs->GetSCHShift1Upload()*3 < theApp.glob_prefs->GetSCHShift1Download()))
			theApp.glob_prefs->SetSCHShift1Download(theApp.glob_prefs->GetSCHShift1Upload()*3);
d1234 2
a1235 2
		if(theApp.glob_prefs->GetSCHShift1Upload() < 10 && (theApp.glob_prefs->GetSCHShift1Upload()*4 < theApp.glob_prefs->GetSCHShift1Download()))
			theApp.glob_prefs->SetSCHShift1Download(theApp.glob_prefs->GetSCHShift1Upload()*4);
d1245 1
a1245 1
	if(theApp.glob_prefs->GetSCHShift2Upload() != 0)
d1247 2
a1248 2
		if(theApp.glob_prefs->GetSCHShift2Upload() < 4 && (theApp.glob_prefs->GetSCHShift2Upload()*3 < theApp.glob_prefs->GetSCHShift2Download()))
			theApp.glob_prefs->SetSCHShift2Download(theApp.glob_prefs->GetSCHShift2Upload()*3);
d1250 2
a1251 2
		if(theApp.glob_prefs->GetSCHShift2Upload() < 10 && (theApp.glob_prefs->GetSCHShift2Upload()*4 < theApp.glob_prefs->GetSCHShift2Download()))
			theApp.glob_prefs->SetSCHShift2Download(theApp.glob_prefs->GetSCHShift2Upload()*4);
@


1.77
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d37 3
a39 3
static uint32 counter, sec,statsave;
// -khaos--+++> Added iupdateconnstats...
static uint32 igraph, istats, iupdateconnstats;
d41 1
d47 1
d52 1
a52 1
	app_prefs = in_prefs;
d54 2
a55 2
	h_timer = SetTimer(0,141,100,TimerProc);
	if (!h_timer)
d57 5
a61 5
	estadataRate = 2000;
	dataRate = 0;
	dataRateave = 0;
	bannedcount = 0;
	counter=0;
d67 2
a68 2
	ULSession_Successful = 0;
	ULSession_Successful_FullChunk  = 0;
d71 2
a72 2
		ULSession_Successful_PartChunk[i]  = 0;
		ULSession_Failed[i] = 0;
d74 1
a74 1
	totaluploadtime = 0;
d85 1
a85 1
	statsave=0;
d87 1
a87 1
	iupdateconnstats=0;
d94 1
a94 1
    leftoverBandwidth = 0;
d101 1
d106 4
a109 2
		// Creade lower prioraty thread that will do the "job"
		m_pSaveThread	=	AfxBeginThread(SaveSourcesThread,(LPVOID)this,THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority());
d124 1
a124 1

d237 1
a237 1
        if (AcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount()) {
d307 1
a307 1
        if(AcceptNewClient(uploadinglist.GetCount()) && waitinglist.GetCount() > 0 &&
d313 1
a313 1
                AcceptNewClient(uploadinglist.GetCount()-1) == false) {
d335 1
a335 1
        sint32 curMaxULRatems = realMaxULRatems + leftoverBandwidth;
d394 1
a394 1
        leftoverBandwidth = curMaxULRatems-usedBandwidthThisCall;
d399 2
a400 2
        if(leftoverBandwidth > limitSave) {
            leftoverBandwidth = limitSave;
d487 2
a488 1
bool CUploadQueue::AcceptNewClient(uint32 numberOfUploads)
d492 1
a492 1
	// check if we can allow a new client to start downloading form us
d498 3
a500 2
	//now the final check
	if (theApp.glob_prefs->GetMaxUpload() == UNLIMITED){
d503 3
a505 1
	} else {
d509 1
a509 1
	//nope
d514 1
a514 1
	//nope
d517 1
a517 1

d519 1
a519 1
	KillTimer(0, h_timer);
d603 1
a603 1
uint32	CUploadQueue::GetDataRateShown()		//Cax2 -  roughly 5 seconds sample rate: more immediate dataRate feedback.
d619 1
a619 1
    // Calculate average dataRate
d622 1
a622 1
	        dataRate = (uint32)(((float)(average_dr_list.front()-average_dr_list.back()))*1000 / (average_tick_list.front()-average_tick_list.back()));
d624 1
a624 1
            dataRate = 0;
d628 1
a628 1
    return dataRate;
d646 1
a646 1

d652 4
a655 1
	if (theApp.serverconnect->IsConnected() && theApp.serverconnect->IsLowID()
d662 1
d664 3
a666 2
	// don't accept clients if requested file is in completing state
	if (reqfile && reqfile->IsPartFile() && ((CPartFile*)reqfile)->GetStatus() == PS_COMPLETING)
d773 1
a773 1
	if ((uint32)waitinglist.GetCount() >= (theApp.glob_prefs->GetQueueSize()+bannedcount))
d785 1
a785 1
	//if (waitinglist.IsEmpty() && AcceptNewClient())
d802 1
a802 1

d805 2
a806 1
	if (!client) return false;
d824 1
a824 1
			ULSession_Successful++;
d826 1
a826 1
				ULSession_Successful_FullChunk++;
d828 1
a828 1
				ULSession_Successful_PartChunk[eReason]++;
d832 1
a832 1
			ULSession_Failed[eReason]++;
d836 2
a837 1
		if( client->GetTransferredUp()) totaluploadtime += client->GetUpStartTimeDelay()/1000;
d842 1
a842 1
		// theApp.knownfiles->Save(); // <- Origin of duplicated values in known.met?
a843 1

d847 1
d853 3
a855 2
	if( ULSession_Successful ){
		return totaluploadtime/ULSession_Successful;
d969 1
a969 1

d989 1
a989 1
	counter++;
d992 2
a993 2
	if (counter >= 10){
		counter=0;
d1009 1
a1009 1
		iupdateconnstats++;
d1011 2
a1012 2
		if (iupdateconnstats>=2) {
			iupdateconnstats=0;
d1020 1
a1020 1
			igraph++;
d1022 2
a1023 2
			if (igraph >= (uint32)(theApp.glob_prefs->GetTrafficOMeterInterval()) ) {
				igraph=0;
d1030 1
a1030 1
				istats++;
d1032 2
a1033 2
				if (istats >= (uint32)(theApp.glob_prefs->GetStatsInterval()) ) {
					istats=0;
d1047 1
a1047 1
		sec++;
d1049 1
a1049 1
		if (sec>=5) {
d1054 1
a1054 1
			sec = 0;
d1065 2
a1066 2
		statsave++;
		if (statsave>=60) 
d1069 1
a1069 1
			statsave=0;
d1133 1
a1133 1

@


1.76
log
@*** empty log message ***
@
text
@d55 3
a57 3
	estadatarate = 2000;
	datarate = 0;
	datarateave = 0;
d65 2
a66 2
	ULSession_Successfull = 0;
	ULSession_Successfull_FullChunk  = 0;
d69 1
a69 1
		ULSession_Successfull_PartChunk[i]  = 0;
d74 1
a74 1
	m_nUpDatarateOverhead = 0;
d494 1
a494 1
		if (numberOfUploads < (GetDatarate()/UPLOAD_CLIENT_DATARATE))
d594 1
a594 1
uint32	CUploadQueue::GetDatarateShown()		//Cax2 -  roughly 5 seconds sample rate: more immediate datarate feedback.
d605 1
a605 1
		return GetDatarate();
d608 1
a608 1
uint32	CUploadQueue::GetDatarate()
d610 1
a610 1
    // Calculate average datarate
d613 1
a613 1
	        datarate = (uint32)(((float)(average_dr_list.front()-average_dr_list.back()))*1000 / (average_tick_list.front()-average_tick_list.back()));
d615 1
a615 1
            datarate = 0;
d619 1
a619 1
    return datarate;
d807 1
a807 1
		if (client->GetTransferedUp())
d809 3
a811 3
			ULSession_Successfull++;
			if (client->GetTransferedUp() >= PARTSIZE)
				ULSession_Successfull_FullChunk++;
d813 1
a813 1
				ULSession_Successfull_PartChunk[eReason]++;
d821 1
a821 1
		if( client->GetTransferedUp()) totaluploadtime += client->GetUpStartTimeDelay()/1000;
d837 2
a838 2
	if( ULSession_Successfull ){
		return totaluploadtime/ULSession_Successfull;
d933 1
a933 1
void CUploadQueue::CompUpDatarateOverhead()
d940 1
a940 1
	m_nUpDatarateOverhead = 0;
d943 1
a943 1
		m_nUpDatarateOverhead += m_AvarageUDRO_list.GetAt(pos);
d946 1
a946 1
		m_nUpDatarateOverhead = 10*m_nUpDatarateOverhead/m_AvarageUDRO_list.GetCount();
d948 1
a948 1
		m_nUpDatarateOverhead = 0;
d970 2
a971 2
    theApp.uploadqueue->CompUpDatarateOverhead();
	theApp.downloadqueue->CompDownDatarateOverhead();
d996 1
a996 1
			theApp.emuledlg->statisticswnd.UpdateConnectionStats((float)theApp.uploadqueue->GetDatarate()/1024, (float)theApp.downloadqueue->GetDatarate()/1024);
d1007 1
a1007 1
				theApp.emuledlg->statisticswnd.SetCurrentRate(((float)theApp.uploadqueue->GetDatarateShown())/1024,((float)theApp.downloadqueue->GetDatarate())/1024);
@


1.75
log
@Server connection minor changes & update to Light Template
@
text
@d826 1
a826 1
		theApp.knownfiles->Save();
@


1.74
log
@Fixes to statistics
@
text
@d981 1
a981 1
		if( theApp.serverconnect->IsConnecting() && !theApp.serverconnect->IsSingleConnect() )
@


1.73
log
@Update for new sockets
@
text
@d38 3
a40 1
static uint32 igraph, istats;
d84 3
d990 9
@


1.72
log
@Same SUI Client enters queue twice remove already-in-queue client
@
text
@d118 1
d120 1
@


1.71
log
@SUI Clients are shown with a green name now instead of a check in the icon
@
text
@d694 1
a694 1
					AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d699 1
a699 1
					AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),client->GetUserName() );		
d704 1
a704 1
					AddDebugLogLine(false,IDS_SAMEUSERHASH,client->GetUserName(),cur_client->GetUserName(),'both' );
d708 1
a708 1
			// EC - Can this happen?
d711 2
a712 1
					AddDebugLogLine(false,"-->Two Identified clients have the same Userhash or IP,");
@


1.70
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d711 1
a711 1
					AddDebugLogLine(false,"-->Two Identified clients have the same Userhash or IP, please report this to eMule Plus forums");
@


1.69
log
@access violation
@
text
@d118 1
a118 1

d688 27
d717 2
@


1.68
log
@built in compiler switch for mobileMule
@
text
@d645 1
a645 1
	if (reqfile->IsPartFile() && ((CPartFile*)reqfile)->GetStatus() == PS_COMPLETING)
@


1.67
log
@*** empty log message ***
@
text
@d979 1
d981 1
@


1.66
log
@extended Upload Session statistic
@
text
@d200 1
a200 1
	theApp.emuledlg->transferwnd.uploadlistctrl.AddClient(newclient);
d316 1
a316 1
		        theApp.emuledlg->transferwnd.queuelistctrl.AddClient(lastClient, false);
d678 1
a678 1
			theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(client);
d745 1
a745 1
		theApp.emuledlg->transferwnd.queuelistctrl.AddClient(client);
d766 1
a766 1
			theApp.emuledlg->transferwnd.uploadlistctrl.RemoveClient(client);
d843 1
a843 1
		theApp.emuledlg->transferwnd.queuelistctrl.RemoveClient(todelete);
@


1.65
log
@Preparing for new sockets
@
text
@d62 8
a69 2
	successfullupcount = 0;
	failedupcount = 0;
d175 1
d309 1
a309 1
		        theApp.uploadqueue->RemoveFromUploadQueue(lastClient, true, false);
d731 1
d752 1
a752 1
bool CUploadQueue::RemoveFromUploadQueue(CUpDownClient* client, bool updatewindow, bool performFailedCheck)
d754 2
d758 23
a780 16
	for (POSITION pos = uploadinglist.GetHeadPosition();pos != 0;uploadinglist.GetNext(pos)){
		if (client == uploadinglist.GetAt(pos)){
			if (updatewindow)
				theApp.emuledlg->transferwnd.uploadlistctrl.RemoveClient(uploadinglist.GetAt(pos));
			uploadinglist.RemoveAt(pos);
			if( client->GetTransferedUp() || performFailedCheck == false ){
				successfullupcount++;
				totaluploadtime += client->GetUpStartTimeDelay()/1000;
			} else if(client->HasBlocks() || client->GetUploadState() != US_UPLOADING) {
				failedupcount++;
			}
			client->SetUploadState(US_NONE);
			client->ClearUploadBlockRequests();
			// Added by Tarod -saves known.met file to avoid loosing it by accident
			theApp.knownfiles->Save();
			return true;
d782 10
a794 1

d800 2
a801 2
	if( successfullupcount ){
		return totaluploadtime/successfullupcount;
@


1.64
log
@new statistic (khaos based)
@
text
@d952 1
d954 1
@


1.63
log
@BUGFIX: never upload to a banned client
@
text
@d975 1
a976 5
			CString buffer;
			CString fullpath;
			fullpath.Format(_T("%spreferences.ini"),theApp.glob_prefs->GetAppDir());
			CIni ini( fullpath );
			ini.SetDefaultCategory(_T("Statistics"));
d978 5
a982 2
			buffer.Format(_T("%I64Lu"),theApp.stat_sessionReceivedBytes+theApp.glob_prefs->GetTotalDownloaded());
			ini.SetString(_T("TotalDownloadedBytes"),buffer);
d984 2
a985 7
			buffer.Format(_T("%I64Lu"),theApp.stat_sessionSentBytes+theApp.glob_prefs->GetTotalUploaded());
			ini.SetString(_T("TotalUploadedBytes"),buffer);

			ini.SaveAndClose();

            // obaldin/DonGato - Scheduler check
            if(theApp.glob_prefs->IsSCHEnabled())
d987 2
a988 2
                CTime curr_t = CTime::GetCurrentTime();
                uint32 secs = curr_t.GetSecond() + 60*curr_t.GetMinute() + 60*60*curr_t.GetHour();
d990 1
a990 1
                if(secs > theApp.glob_prefs->GetSCHShift1()-120 && secs < theApp.glob_prefs->GetSCHShift1()+120)
d992 6
a997 6
                    // switching to shift1 speeds
                    theApp.uploadqueue->SCHShift1UploadCheck();
                    theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetSCHShift1Upload());
                    theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetSCHShift1Download());
           	        theApp.glob_prefs->SetMaxConnections(theApp.glob_prefs->GetSCHShift1conn());
           	        theApp.glob_prefs->SetMaxDownloadConperFive(theApp.glob_prefs->GetSCHShift15sec());
d1004 1
a1004 1
                } 
d1007 14
a1020 12
                    int dayOfWeek = curr_t.GetDayOfWeek();
                    if ((dayOfWeek==2 && theApp.glob_prefs->IsSCHExceptMon()) ||
						(dayOfWeek==3 && theApp.glob_prefs->IsSCHExceptTue()) ||
						(dayOfWeek==4 && theApp.glob_prefs->IsSCHExceptWed()) ||
						(dayOfWeek==5 && theApp.glob_prefs->IsSCHExceptThu()) ||
						(dayOfWeek==6 && theApp.glob_prefs->IsSCHExceptFri()) ||
						(dayOfWeek==7 && theApp.glob_prefs->IsSCHExceptSat()) ||
                    	(dayOfWeek==1 && theApp.glob_prefs->IsSCHExceptSun()))
                    {
                        CLoggable::AddDebugLogLine(true,CString("Day excepted!"));
                    } else {
	                    // switching to shift2 speeds
d1022 4
a1025 4
        	            theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetSCHShift2Upload());
            	        theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetSCHShift2Download());
            	        theApp.glob_prefs->SetMaxConnections(theApp.glob_prefs->GetSCHShift2conn());
            	        theApp.glob_prefs->SetMaxDownloadConperFive(theApp.glob_prefs->GetSCHShift25sec());
d1031 4
a1034 4
                	    CLoggable::AddDebugLogLine(true,CString("Switching to Shift 2"));
                	}
                }
            }
@


1.62
log
@eMailNotifier and PopUp CleanUp
@
text
@d154 1
a154 1
	if (IsDownloading(newclient)) {
@


1.61
log
@Purity's changes
@
text
@d1005 4
a1008 7
					if(theApp.glob_prefs->IsSMTPInfoEnabled())
					{
						CSMTPConnection mail;
						CString txt;
						txt.Format(CString("Switching to Shift 1"));
						mail.SendMuleMessage(txt);
					}
d1031 4
a1034 7
						if(theApp.glob_prefs->IsSMTPInfoEnabled())
						{
							CSMTPConnection mail;
							CString txt;
							txt.Format(CString("Switching to Shift 2"));
							mail.SendMuleMessage(txt);
						}
@


1.60
log
@changed INI file interface + little bugfix
@
text
@d28 1
d951 2
d1004 8
d1033 8
@


1.59
log
@*** empty log message ***
@
text
@d976 2
a977 1
			CIni ini( fullpath, _T("eMule") );
d980 1
a980 1
			ini.WriteString(_T("TotalDownloadedBytes"),buffer ,_T("Statistics"));
d983 3
a985 1
			ini.WriteString(_T("TotalUploadedBytes"),buffer ,_T("Statistics"));
@


1.58
log
@completing bug (eMule cann't complete a file, if file is uploaded)
@
text
@d76 1
a76 1
		activeClients_list.AddHead((uint32)0);
@


1.57
log
@precheck server's ip & port from clients before adding them //SyruS (0.29c)
@
text
@d630 2
a631 1
		&& client->GetDownloadState() == DS_NONE && !client->IsFriend()
d635 4
d710 1
a710 1
	CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)client->reqfileid);
d1150 17
@


1.56
log
@first steps of keeping banned clients alive so that re-banning isn't so often
@
text
@d692 1
a692 1
	if (theApp.glob_prefs->GetAddServersFromConn()){
@


1.55
log
@SafeConnect from SlugFiller
@
text
@d358 1
a358 1
            if(cur_client->GetLastGotULData() + MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS < ::GetTickCount()) {
d800 7
d808 2
@


1.54
log
@little optimizing: reusing curTick instead of ::GetTickCount() in L2HAC-loop
@
text
@d160 2
a161 1
		newclient->TryToConnect(true);
@


1.53
log
@speed optimization (GetDownloadingClient(client) is obsolet)
@
text
@d448 1
a448 1
				&& (::GetTickCount() - cur_client->GetLastL2HACExecution()) > cur_client->GetL2HACTime())
d451 1
a451 1
					cur_client->SetLastL2HACExecution(::GetTickCount() - cur_client->GetL2HACTime() + (uint32)ROUND(((float)rand()/RAND_MAX)*300000));
@


1.52
log
@unicode cleanup
@
text
@d131 1
d153 1
a153 1
	if (IsDownloading(newclient)){
d551 6
a556 4
	for (POSITION pos = waitinglist.GetHeadPosition();pos != 0;waitinglist.GetNext(pos)){
		if (dwIP == waitinglist.GetAt(pos)->GetIP())
			return waitinglist.GetAt(pos);
	}
d563 1
d577 1
a577 1

@


1.51
log
@improved output in statusbar (update only tray or window) v2
@
text
@d172 1
a172 1
    AddDebugLogLine(false,"AddUpNextClient(): client not in ClientList");
d690 2
a691 1
		CServer* srv = new CServer(client->GetServerPort(), inet_ntoa(host));
d956 2
a957 2
			fullpath.Format("%spreferences.ini",theApp.glob_prefs->GetAppDir());
			CIni ini( fullpath, "eMule" );
d959 2
a960 2
			buffer.Format("%I64Lu",theApp.stat_sessionReceivedBytes+theApp.glob_prefs->GetTotalDownloaded());
			ini.WriteString("TotalDownloadedBytes",buffer ,"Statistics");
d962 2
a963 2
			buffer.Format("%I64Lu",theApp.stat_sessionSentBytes+theApp.glob_prefs->GetTotalUploaded());
			ini.WriteString("TotalUploadedBytes",buffer ,"Statistics");
@


1.50
log
@Preparing for new sockets
@
text
@a933 1

d939 1
a939 1
#ifdef OLD_SOCKETS_ENABLED
d941 1
a941 1
#endif //OLD_SOCKETS_ENABLED
d943 1
a943 1
			theApp.emuledlg->ShowTransferRate();
d945 2
a946 3
            if (theApp.emuledlg->activewnd == &theApp.emuledlg->statisticswnd) {
				theApp.emuledlg->ShowStatistics(); 
			}
a947 3

		if(theApp.glob_prefs->GetShowToolbarSpeedMeter())	// speedmeter needs more updates
			theApp.emuledlg->ShowTransferRate(false);		// FoRcHa
@


1.49
log
@Preparing for new sockets
@
text
@d438 1
a448 1
#ifdef OLD_SOCKETS_ENABLED
a456 1
#endif //OLD_SOCKETS_ENABLED
d460 1
d622 1
d628 1
d896 1
d899 1
d903 1
d905 1
@


1.48
log
@bugfix #295 in this function isn't required
@
text
@d23 1
d25 1
d127 1
d130 1
d134 5
a138 1
				&& (!cur_client->HasLowID() || (cur_client->socket && cur_client->socket->IsConnected()) ) ){
d156 1
d167 1
d448 1
d457 1
d670 1
d673 1
d707 1
d709 1
d934 1
d936 1
@


1.47
log
@converted to new logger methods
@
text
@d684 2
a685 21

	// DbT:StartUploadReq
	if(!reqfile){
		theApp.uploadqueue->RemoveFromWaitingQueue(client,true);
		return;
	}
	if(reqfile->IsPartFile()){
		if(!((CPartFile*)reqfile)->HasParts()){
			theApp.uploadqueue->RemoveFromWaitingQueue(client,true);
			return;
		}
	} else {
		if(!reqfile->HasParts()){
			theApp.uploadqueue->RemoveFromWaitingQueue(client,true);
			return;
		}
	}
	// DbT:End

		if (reqfile)
			reqfile->statistic.AddRequest();
@


1.46
log
@DoubleT: bug #295 fixed (bypass part blocking on opcode StartUploadReq)
@
text
@d49 1
a49 1
		AddDebugLogLine(false,GetResString(IDS_ERR_TIMERCREATEFAILED));
d100 1
a100 1
		AddDebugLogLine(false,GetResString(IDS_ERR_TIMERCREATEFAILED));
d656 1
a656 1
			AddDebugLogLine(false,CString(GetResString(IDS_SAMEUSERHASH)),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
@


1.45
log
@code cleanup
@
text
@d684 19
@


1.44
log
@coverted code from char * to CString
@
text
@d1014 1
a1014 1
void CUploadQueue::FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, uchar* filehash) 
@


1.43
log
@minor changes
@
text
@d935 2
a936 2
			char* fullpath = new char[strlen(theApp.glob_prefs->GetAppDir())+16];
			sprintf(fullpath,"%spreferences.ini",theApp.glob_prefs->GetAppDir());
d938 1
a938 3
			delete[] fullpath;
			fullpath=NULL;

@


1.42
log
@minor fixes and improvements
@
text
@d1025 1
a1025 1
		if(memcmp(potential->reqfileid, filehash, 16) == 0)
d1032 1
a1032 1
		if(memcmp(potential->reqfileid, filehash, 16) == 0)
@


1.41
log
@L2HAC by EnkeyDev
@
text
@d534 1
a534 1
CUpDownClient* CUploadQueue::GetWaitingClientByIP(uint32 dwIP)
@


1.40
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d427 24
d624 6
@


1.39
log
@reverted some changes
@
text
@d591 7
@


1.38
log
@use app shutdown mutex
@
text
@a815 1
	CSingleLock lock(&theApp.shutdownMutex, TRUE);	//[TwoBottle Mod]
@


1.37
log
@changed bizarre KillTimer arg
@
text
@d816 1
@


1.36
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d457 1
a457 1
	KillTimer(0,141);
@


1.35
log
@Moved one log line to debug log
@
text
@d377 1
a377 1
	//Cax2 - refactored 'avarage_dr_list' to allow to easily  pick out a subset of the list 
d379 1
a379 1
	if(average_tick_list.IsEmpty() || curTick >= average_tick_list.GetHead()+500)	//Cax2 - update no faster than every .5 sec
d381 2
a382 1
		average_dr_list.AddHead(theApp.stat_sessionSentBytes);
d384 2
a385 5
		// Save time beetween each speed snapshot
		average_tick_list.AddHead(curTick);

		// remove anything older than 40  seconds - Cax2: will need to rethink this - it won't be an average if the program freezes...
		while(curTick-average_tick_list.GetTail() > 40000)
d387 2
a388 2
   			average_dr_list.RemoveTail();
			average_tick_list.RemoveTail();
d540 8
a547 2
	if(average_dr_list.GetSize() >9)		//Cax2 - do we have those '5 seconds'? (can be messed up by program freezes, etc)
		return (uint32)((average_dr_list.GetHead()-average_dr_list.GetAt(average_dr_list.FindIndex(9)))*1000.0f/(average_tick_list.GetHead()-average_tick_list.GetAt(average_tick_list.FindIndex(9))));
d556 2
a557 2
        if(average_dr_list.GetSize() >1) {
	        datarate = (uint32)(((float)(average_dr_list.GetHead()-average_dr_list.GetTail()))*1000 / (average_tick_list.GetHead()-average_tick_list.GetTail()));
@


1.34
log
@Corrected scheduler
@
text
@d162 1
a162 1
    AddLogLine(false,"AddUpNextClient(): client not in ClientList");
@


1.34.2.1
log
@27a partial merge
@
text
@a110 1
	POSITION toaddlow = 0; // VQB - LowID Slot Patch
a111 1
	uint32  bestlowscore = 0;   // VQB - LowID Slot Patch
d121 3
a123 1
			if ((::GetTickCount() - cur_client->GetLastUpRequest() > MAX_PURGEQUEUETIME) /* || !theApp.sharedfiles->GetFileByID(cur_client->GetUploadFileID())*/ ){
d129 2
a130 1
			else if ( (cur_client->GetScore(true) > bestscore) && !cur_client->IsBanned()){ // VQB removed redundant cond now covered in GetScore
a133 4
			else if ( (cur_client->GetScore(false) > bestlowscore) && !cur_client->IsBanned() && !cur_client->AddNextConnect){
				bestlowscore = cur_client->GetScore(false);
				toaddlow = pos2;
			}
a136 6
		// VQB LowID Slot Patch -- mark LowID to add next connect
		if (bestlowscore > bestscore){
			newclient = waitinglist.GetAt(toaddlow);
			newclient->AddNextConnect = true;
		}
		// VQB end
d176 1
a176 1
	CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)newclient->GetUploadFileID());
d487 25
d526 14
d598 1
a598 1
		client->AddRequestCount(client->GetUploadFileID());
a603 9
// VQB LowID Slot Patch -- note:  should add limit so only if #slots < UL -or- UL+1 for Low UL (?)
			if (client->AddNextConnect && (uploadinglist.GetCount() < theApp.glob_prefs->GetMaxUpload())){
				client->AddNextConnect = false;
				RemoveFromWaitingQueue(client, true);
				AddUpNextClient(client);
//				theApp.emuledlg->AddLogLine(false,"Added Low ID User On Reconnect"); // VQB:  perhaps only add to debug log?
				return;
			}
// VQB end
d642 1
a642 1
	CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)client->GetUploadFileID());
d750 2
a751 2
	for(POSITION pos = waitinglist.GetHeadPosition();pos;){
		if(score < waitinglist.GetNext(pos)->GetScore(true,false))
d841 1
a841 1
		if (theApp.glob_prefs->WatchClipboard4ED2KLinks()) theApp.emuledlg->searchwnd.SearchClipBoard();		
d984 1
a984 1
		if(memcmp(potential->GetUploadFileID(), filehash, 16) == 0)
d991 1
a991 1
		if(memcmp(potential->GetUploadFileID(), filehash, 16) == 0)
@


1.34.2.2
log
@27c
@
text
@d123 1
a123 1
			if ((::GetTickCount() - cur_client->GetLastUpRequest() > MAX_PURGEQUEUETIME) || !theApp.sharedfiles->GetFileByID(cur_client->GetUploadFileID()) ){
d171 1
a171 1
    AddDebugLogLine(false,"AddUpNextClient(): client not in ClientList");
d496 1
a496 1
CUpDownClient* CUploadQueue::GetWaitingClientByIP_UDP(uint32 dwIP, uint16 dwPort)
d501 1
a501 1
		if (dwIP == waitinglist.GetAt(pos)->GetIP() && dwPort == waitinglist.GetAt(pos)->GetUDPPort())
d898 1
a898 1
           	        theApp.glob_prefs->SetMaxConsPerFive(theApp.glob_prefs->GetSCHShift15sec());
d919 1
a919 1
            	        theApp.glob_prefs->SetMaxConsPerFive(theApp.glob_prefs->GetSCHShift25sec());
@


1.33
log
@Updated Night Shift to Scheduller (needs more testing and a new icon from DrSiRiUs... coming!)
@
text
@d912 1
a912 1
                if(secs > theApp.glob_prefs->GetSCHShift1() && secs < theApp.glob_prefs->GetSCHShift1()+120)
d922 1
a922 1
				else if (secs > theApp.glob_prefs->GetSCHShift2() && secs < theApp.glob_prefs->GetSCHShift2()+120) 
@


1.32
log
@bugfix: less resource usage, fixed bug #131
@
text
@d906 2
a907 2
            // obaldin - check for night/day shift
            if(theApp.glob_prefs->IsNSEnabled())
d912 1
a912 1
                if(secs > theApp.glob_prefs->GetNSStart() && secs < theApp.glob_prefs->GetNSStart()+120)
d914 7
a920 5
                    // switching to night shift speeds
                    theApp.uploadqueue->NSNightUploadCheck();
                    theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetNSNightUpload());
                    theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetNSNightDownload());
					CLoggable::AddDebugLogLine(true,CString("Switching to night shift"));
d922 1
a922 1
				else if (secs > theApp.glob_prefs->GetNSEnd() && secs < theApp.glob_prefs->GetNSEnd()+120) 
d925 7
a931 1
                    if ((dayOfWeek==1 && theApp.glob_prefs->IsNSExceptSun()) || (dayOfWeek==7 && theApp.glob_prefs->IsNSExceptSat()))
d933 1
a933 1
                        CLoggable::AddDebugLogLine(true,CString("Weekend! :)"));
d935 7
a941 5
	                    // switching to day shift speeds
						theApp.uploadqueue->NSDayUploadCheck();
        	            theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetNSDayUpload());
            	        theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetNSDayDownload());
                	    CLoggable::AddDebugLogLine(true,CString("Switching to day shift"));
d1042 1
a1042 1
void CUploadQueue::NSNightUploadCheck()
d1046 1
a1046 1
	if(theApp.glob_prefs->GetNSNightUpload() != 0)
d1048 2
a1049 2
		if(theApp.glob_prefs->GetNSNightUpload() < 4 && (theApp.glob_prefs->GetNSNightUpload()*3 < theApp.glob_prefs->GetNSNightDownload()))
			theApp.glob_prefs->SetNSNightDownload(theApp.glob_prefs->GetNSNightUpload()*3);
d1051 2
a1052 2
		if(theApp.glob_prefs->GetNSNightUpload() < 10 && (theApp.glob_prefs->GetNSNightUpload()*4 < theApp.glob_prefs->GetNSNightDownload()))
			theApp.glob_prefs->SetNSNightDownload(theApp.glob_prefs->GetNSNightUpload()*4);
d1058 1
a1058 1
void CUploadQueue::NSDayUploadCheck()
d1062 1
a1062 1
	if(theApp.glob_prefs->GetNSDayUpload() != 0)
d1064 2
a1065 2
		if(theApp.glob_prefs->GetNSDayUpload() < 4 && (theApp.glob_prefs->GetNSDayUpload()*3 < theApp.glob_prefs->GetNSDayDownload()))
			theApp.glob_prefs->SetNSDayDownload(theApp.glob_prefs->GetNSDayUpload()*3);
d1067 2
a1068 2
		if(theApp.glob_prefs->GetNSDayUpload() < 10 && (theApp.glob_prefs->GetNSDayUpload()*4 < theApp.glob_prefs->GetNSDayDownload()))
			theApp.glob_prefs->SetNSDayDownload(theApp.glob_prefs->GetNSDayUpload()*4);
@


1.31
log
@minor bugfixes, plus bugfix for bug #34
@
text
@d376 9
a384 12
    // Save used bandwidth for speed calculations
	//avarage_dr_list.AddTail(usedBandwidthThisCall);
	avarage_dr_list.AddTail(theApp.stat_sessionSentBytes);

    // Save time beetween each speed snapshot
    avarage_tick_list.AddTail(curTick);

    // don't save more than 40 secs of data
    while(curTick-avarage_tick_list.GetHead() > 40*1000) {
   	    avarage_dr_list.RemoveHead();
        avarage_tick_list.RemoveHead();
    }
d386 7
d540 23
d851 1
a851 2
				theApp.emuledlg->statisticswnd.SetCurrentRate(((float)theApp.uploadqueue->GetDatarate())/1024,((float)theApp.downloadqueue->GetDatarate())/1024);
				theApp.emuledlg->ShowTransferRate();
d880 1
@


1.30
log
@converted to new logging method
@
text
@d619 1
a619 1
	if ((uint32)waitinglist.GetCount() > (theApp.glob_prefs->GetQueueSize()+bannedcount))
@


1.29
log
@*** empty log message ***
@
text
@d49 1
a49 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_TIMERCREATEFAILED));
d95 1
a95 1
			theApp.emuledlg->AddDebugLogLine(false,_T("Error creating SourcesSaveThread"));
d100 1
a100 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_TIMERCREATEFAILED));
d162 1
a162 1
    theApp.emuledlg->AddLogLine(false,"AddUpNextClient(): client not in ClientList");
d588 1
a588 1
			theApp.emuledlg->AddDebugLogLine(false,CString(GetResString(IDS_SAMEUSERHASH)),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() );
d611 1
a611 1
			theApp.emuledlg->AddLogLine(false,"Added new server: %s:%d", srv->GetFullIP(), srv->GetPort());*/
d891 1
a891 1
                    theApp.emuledlg->AddDebugLogLine(true,CString("Switching to night shift"));
d898 1
a898 1
                        theApp.emuledlg->AddDebugLogLine(true,CString("Weekend! :)"));
d904 1
a904 1
                	    theApp.emuledlg->AddDebugLogLine(true,CString("Switching to day shift"));
@


1.28
log
@bugfix for bugs 47, 53, & 62 ! :P
@
text
@d158 7
@


1.27
log
@bugfix: server connect timeout, averaged file rating
@
text
@d790 1
a790 1
	//theApp.knownfiles->Process();	//moved to SaveSourcesThread()
d989 2
a990 1
		theApp.knownfiles->Process();
@


1.26
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d790 1
a790 1
	//theApp.knownfiles->Process();
@


1.25
log
@Night Shift completed (sat/sun exceptions).
@
text
@d81 2
d121 1
d185 3
d209 6
a214 1
		    usedBandwidthThisCall += cur_client->SendBlockData(m_guessedMaxBandwidth-usedBandwidthThisCall, tempWantsMoreBandwidth);
d267 1
d280 1
a280 1
            if(lastClient->GetUpStartTimeDelay() > 3*1000) {
d318 6
a323 1
		    usedBandwidthThisCall += cur_client->SendBlockData(allowedThisIteration, wantsMoreBandWidth);
d342 6
a347 2
                bool tempWantsMoreData;
                usedBandwidthThisCall += cur_client->SendBlockData(MAXFRAGSIZE, tempWantsMoreData);
d385 33
d555 2
a556 1
	if (!bIgnoreTimelimit){
d624 5
d634 1
a634 1
	//}
@


1.24
log
@Night Shift (in cooperation with obaldin :P)
@
text
@d815 3
a817 3
                CTime t = CTime::GetCurrentTime();
                uint32 secs = t.GetSecond() + 60*t.GetMinute() + 60*60*t.GetHour();
                bool switched = false;
d828 11
a838 5
                    // switching to day shift speeds
					theApp.uploadqueue->NSDayUploadCheck();
                    theApp.glob_prefs->SetMaxUpload(theApp.glob_prefs->GetNSDayUpload());
                    theApp.glob_prefs->SetMaxDownload(theApp.glob_prefs->GetNSDayDownload());
                    theApp.emuledlg->AddDebugLogLine(true,CString("Switching to day shift"));
@


1.23
log
@Priority control
@
text
@d811 24
d929 33
a961 1
}@


1.22
log
@better handling of friends
@
text
@d88 1
a88 1
		m_pSaveThread	=	AfxBeginThread(SaveSourcesThread,(LPVOID)this,THREAD_PRIORITY_NORMAL);
d406 1
a406 1
		m_pSaveThread->SetThreadPriority(THREAD_PRIORITY_HIGHEST);
d897 1
a897 1
		SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_BELOW_NORMAL);
d900 1
a900 1
		SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);
@


1.21
log
@the famous zz upload system! :)
@
text
@d650 1
a650 1
/*
a654 11
	if (theApp.glob_prefs->TransferFullChunks())
	{
		if( client->GetUpStartTimeDelay() > 3600000 ) // Try to keep the clients from downloading for ever.
			return true;
// For some reason, some clients can continue to download after a chunk size.
// Are they redownloading the same chunk over and over????
		if( client->GetSessionUp() > 10485760 ) 
			return true;
	}
	else
	{
d660 1
a660 1
        }
d665 1
a665 1
*/
@


1.20
log
@*** empty log message ***
@
text
@a51 1
	dataratems = 0;
d55 4
a58 4
	sumavgdata = 0;				// enkeyDEV(Ottavio84) -Accurate speed measurement-
	sendtimestamp = GetTickCount();	// enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
	bDataRateMaxed = false; 		// Tarod [LoneStar]
	lasttimechecked = GetTickCount() ;
d73 10
a82 4
	// enkeyDEV(Ottavio84) -Accurate speed measurement-
	TransferredData newitem = {0,GetTickCount()};
	for (int i = 0;i != 400;i++)
		avarage_dr_list.AddHead(newitem);
d179 181
a359 19
	// START - enkeyDEV(Ottavio84) -Accurate speed measurement-
	sumavgdata -= avarage_dr_list.RemoveHead().datalen;
	TransferredData newitem = {dataratems, ::GetTickCount()};
	avarage_dr_list.AddTail(newitem);
	sumavgdata += dataratems;

	float deltat = (float)(avarage_dr_list.GetTail().timestamp - avarage_dr_list.GetHead().timestamp) / 1000.0;
	if (deltat > 0.0) 
        	datarate = (uint32)((float)sumavgdata / deltat);
	else
		datarate = 0;
	// END - enkeyDEV(Ottavio84) -Accurate speed measurement-
	dataratems = 0;
	if (AcceptNewClient() && waitinglist.GetCount()) {
		AddUpNextClient();
		uLastUploadStart = GetTickCount(); // Added by Tarod [LoneStar]
	}
	if (!uploadinglist.GetCount())
		return;
d361 2
a362 31
	int16 clientsrdy = 0;
	for (POSITION pos = uploadinglist.GetHeadPosition();pos != 0;uploadinglist.GetNext(pos)){
		CUpDownClient* cur_client = uploadinglist.GetAt(pos);
		if ( (cur_client->socket) && (!cur_client->socket->IsBusy()) && cur_client->HasBlocks())
			clientsrdy++;
	}
	if (!clientsrdy){
		estadatarate -= 200;
		bDataRateMaxed = true; // Added by Tarod [LoneStar]
		if (estadatarate < 100)
			estadatarate = 100;
		clientsrdy++;
	}
	else{
		// START - enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
		int timediff = GetTickCount() - sendtimestamp;
		sendtimestamp = GetTickCount();
		estadatarate += 200;
		int maxrate = app_prefs->GetMaxUpload() * timediff; // kB/s == B/ms 
		// END - enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
		bDataRateMaxed = false; // Added by Tarod [LoneStar]
		if (estadatarate > maxrate)
			estadatarate = maxrate;
	}
	uint32 sendperclient = estadatarate/clientsrdy;
	POSITION pos1,pos2;
	for (pos1 = uploadinglist.GetHeadPosition();( pos2 = pos1 ) != NULL; ){
		uploadinglist.GetNext(pos1);
		CUpDownClient* cur_client = uploadinglist.GetAt(pos2);
		dataratems += cur_client->SendBlockData(sendperclient);
	}
d366 1
a366 1
bool CUploadQueue::AcceptNewClient()
d371 1
a371 2
	uint32 uploadCount=uploadinglist.GetCount();	//Cax2 less CPU usage
	if (uploadCount < MIN_UP_CLIENTS_ALLOWED)
d373 1
a373 1
	else if (uploadCount >= MAX_UP_CLIENTS_ALLOWED)
d375 7
a381 4
	//now the final check + Tarod's/LoneStar Upload throttle
	if (theApp.glob_prefs->GetMaxUpload() == UNLIMITED)
	{
		if (uploadCount < (datarate/UPLOAD_CLIENT_DATARATE))
d384 2
a385 15
	else
	{
		uint16 nMaxSlots = MIN_UP_CLIENTS_ALLOWED;      // obaldin: the previous version had a logical flaw
		if (theApp.glob_prefs->GetMaxUpload() > 10){    //          let's see if this one holds water
			nMaxSlots += (uint16)ceil((float)((theApp.glob_prefs->GetMaxUpload() - 10)*1024) / UPLOAD_CLIENT_DATARATE);
		}
		if (uploadCount < (datarate/UPLOAD_CHECK_CLIENT_DR) && uploadCount < nMaxSlots )
			if (bDataRateMaxed) 
			{
				if (GetTickCount() - uLastUploadStart > UPLOAD_CLIENT_THRESHOLD)
					return true;
			}
			else
				return false;
	}
d566 3
a568 3
	if (waitinglist.IsEmpty() && AcceptNewClient())
		AddUpNextClient(client);
	else{
d574 1
a574 1
	}
d579 1
a579 1
bool CUploadQueue::RemoveFromUploadQueue(CUpDownClient* client, bool updatewindow)
d588 1
a588 1
			if( client->GetTransferedUp() ){
d591 2
a593 2
			else
				failedupcount++;
d650 1
d676 1
d768 1
a768 1
				theApp.emuledlg->statisticswnd.SetCurrentRate((float)theApp.uploadqueue->GetDatarate()/1024,(float)theApp.downloadqueue->GetDatarate()/1024);
@


1.19
log
@*** empty log message ***
@
text
@d83 1
a83 1
		m_pSaveThread	=	AfxBeginThread(SaveSourcesThread,(LPVOID)this,THREAD_PRIORITY_BELOW_NORMAL);
d273 1
a273 1
		qwDueTime = -5 * 10000000;         // Copy the relative time into a LARGE_INTEGER.
d757 1
a757 1
    qwDueTime = -5 * 10000000;         // Copy the relative time into a LARGE_INTEGER.
d762 1
a762 1
	bool bExit = false;
d773 7
d782 1
@


1.18
log
@*** empty log message ***
@
text
@d288 4
a291 1
		WaitForMultipleObjects(2,hArr,TRUE,10000000);
@


1.17
log
@Tweeked Save known.met file thread to  exit faster so eMule exits faster
@
text
@d46 1
d83 1
a83 1
		m_pSaveThread	=	AfxBeginThread(SaveSourcesThread,(LPVOID)m_hSaveSTimer,THREAD_PRIORITY_BELOW_NORMAL);
d283 2
d747 1
a747 1
	hTimer	=	lpArg;
d760 1
a760 1
	while (!bExit )
d765 1
a765 1
		if ( !theApp.emuledlg->IsRunning() )
@


1.16
log
@bugfixes: sort in search window, unknown % in stats, dowload speed at startup updated search layout
@
text
@d269 1
d277 2
d282 4
a285 2
		// Wait until thread finishes 100 sec - this should be enough
		WaitForMultipleObjects(2,hArr,TRUE,100000);
@


1.15
log
@tiny old bug with queue size and bannedcount
@
text
@d365 1
a365 1
			if (::GetTickCount() - client->GetBanTime() > theApp.glob_prefs->BadClientBanTime()){
@


1.14
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d419 1
a419 1
	if ((uint32)waitinglist.GetCount() > (theApp.glob_prefs->GetQueueSize()-bannedcount))	// SeeWen
@


1.13
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d155 1
a155 2
	if (theApp.glob_prefs->TransferFullChunks())
	newclient->ClearSessionUp(); 	// VQB UL Session Clear
d516 11
d532 1
a532 1

d580 1
a580 1
		m_nUpDatarateOverhead /= (m_AvarageUDRO_list.GetCount()/10);
d612 4
d675 1
@


1.12
log
@*** empty log message ***
@
text
@d27 7
@


1.11
log
@another go at upload throttle
@
text
@d30 1
d70 17
d261 15
d584 1
a584 1
	theApp.knownfiles->Process();
d712 35
@


1.10
log
@more 26b merges
@
text
@d232 1
a232 1
				return true;
@


1.9
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d60 4
d120 1
a120 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d385 1
a385 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
a547 1
	theApp.clientcredits->Process();
d561 1
@


1.8
log
@bugfixes & control panel updates
@
text
@d56 4
d116 1
a116 1
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d121 1
d124 1
a124 1

d219 1
a219 1
			nMaxSlots += (uint16)ceil((((theApp.glob_prefs->GetMaxUpload() - 10)*1024) / UPLOAD_CLIENT_DATARATE)) ;
d252 1
a252 1
POSITION CUploadQueue::GetWaitingClientByID(CUpDownClient* client)
d264 1
a264 1
}
d338 1
d342 2
d354 1
d357 1
d381 1
a381 1
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d513 1
a513 1
void CUploadQueue::CompDatarateOverhead()
d551 2
a552 2
    theApp.uploadqueue->CompDatarateOverhead();
	theApp.downloadqueue->CompDatarateOverhead();
d557 3
a559 1
		counter = 0 ; // i_a
d574 1
a574 1
		if (theApp.emuledlg->activewnd == &theApp.emuledlg->statisticswnd) { 
@


1.8.2.1
log
@initial upgrade to .26
@
text
@a55 4
	m_nUpDataOverheadSourceExchange = 0;
	m_nUpDataOverheadFileRequest = 0;
	m_nUpDataOverheadOther = 0;
	m_nUpDataOverheadServer = 0;
d112 1
a112 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
a116 1
/*
d119 1
a119 1
*/
d214 1
a214 1
			nMaxSlots += (uint16)ceil((float)((theApp.glob_prefs->GetMaxUpload() - 10)*1024) / UPLOAD_CLIENT_DATARATE);
d247 1
a247 1
/*POSITION CUploadQueue::GetWaitingClientByID(CUpDownClient* client)
d259 1
a259 1
}*/
a332 1
/* MERGE26
a335 2
*/
		else if ( client->Compare(cur_client) ) {
a345 1
/*
a347 1
*/
d371 1
a371 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d503 1
a503 1
void CUploadQueue::CompUpDatarateOverhead()
d541 2
a542 2
    theApp.uploadqueue->CompUpDatarateOverhead();
	theApp.downloadqueue->CompDownDatarateOverhead();
d547 1
a547 3
		counter=0;

		theApp.emuledlg->statisticswnd.UpdateConnectionsStatus();
d552 2
a553 1
		if (theApp.glob_prefs->GetTrafficOMeterInterval()>0) {
d562 1
a562 1
		if (theApp.emuledlg->activewnd == &theApp.emuledlg->statisticswnd && theApp.emuledlg->IsWindowVisible() )  {
a575 1
		
d597 2
a598 1
		if (statsave>=60) {
d617 2
a618 1
CUpDownClient* CUploadQueue::GetNextClient(CUpDownClient* lastclient){
d641 2
a642 1
void CUploadQueue::FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, uchar* filehash) {
@


1.7
log
@Updates to Preferences (and enabling/disabling options in code because of that)
@
text
@d121 1
d350 1
a350 1
	if (theApp.glob_prefs->AddServersFromClient()){
@


1.6
log
@attempt at fixing upload slots
@
text
@d121 1
a121 2
	if (theApp.glob_prefs->TransferFullChunks())
		newclient->ClearSessionUp(); 	// VQB UL Session Clear
d216 1
a216 1
			if (theApp.glob_prefs->IsThrottleUploadEnabled() && bDataRateMaxed) 
@


1.5
log
@updated to .25b codebase
@
text
@d205 1
a205 1
	if (!theApp.glob_prefs->IsThrottleUploadEnabled() && theApp.glob_prefs->GetMaxUpload() == UNLIMITED)
d212 2
a213 4
		uint16 nMaxSlots = 0;
		if (theApp.glob_prefs->GetMaxUpload() > 10)
		{
			nMaxSlots += 4;
d216 1
a216 3
		else
			nMaxSlots = MIN_UP_CLIENTS_ALLOWED;
		if (uploadCount < (datarate/UPLOAD_CHECK_CLIENT_DR) && uploadCount <= nMaxSlots )
@


1.5.2.1
log
@updating this branch...
@
text
@@


1.5.2.2
log
@attempt at fixing upload slots
@
text
@d205 1
a205 1
	if (theApp.glob_prefs->GetMaxUpload() == UNLIMITED)
d212 4
a215 2
		uint16 nMaxSlots = MIN_UP_CLIENTS_ALLOWED;      // obaldin: the previous version had a logical flaw
		if (theApp.glob_prefs->GetMaxUpload() > 10){    //          let's see if this one holds water
d218 3
a220 1
		if (uploadCount < (datarate/UPLOAD_CHECK_CLIENT_DR) && uploadCount < nMaxSlots )
@


1.5.2.3
log
@updated control panes, and assorted bugfixes
@
text
@d217 1
a217 1
			if (bDataRateMaxed) 
d350 1
a350 1
	if (theApp.glob_prefs->GetAddServersFromConn()){
@


1.4
log
@*** empty log message ***
@
text
@d38 1
a38 1
        h_timer = SetTimer(0,141,100,TimerProc); // i_a
d341 1
a341 1
			//DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("Client '%s' and '%s' have the same userhash or IP - removed '%s'"),client->GetUserName(),cur_client->GetUserName(),cur_client->GetUserName() ));
d544 3
d592 1
a592 1
            		if (theApp.emuledlg->activewnd == &theApp.emuledlg->statisticswnd)
d594 1
@


1.3
log
@final port to .25b!
@
text
@d33 4
a36 1
CUploadQueue::CUploadQueue(CPreferences* in_prefs){
d61 2
d65 4
a68 1
void CUploadQueue::AddUpNextClient(CUpDownClient* directadd){
d133 1
d136 4
a139 1
void CUploadQueue::Process(){
d191 2
d196 2
d229 3
d240 4
a243 1
POSITION CUploadQueue::GetWaitingClient(CUpDownClient* client){
d245 4
d251 4
a254 1
POSITION CUploadQueue::GetWaitingClientByID(CUpDownClient* client){
d259 3
d265 4
a268 1
CUpDownClient* CUploadQueue::GetWaitingClientByIP(uint32 dwIP){
d273 3
d279 4
a282 1
POSITION CUploadQueue::GetDownloadingClient(CUpDownClient* client){
d287 3
d293 4
a296 1
void CUploadQueue::UpdateBanCount(){
d304 2
d308 4
a311 1
void CUploadQueue::AddClientToQueue(CUpDownClient* client, bool bIgnoreTimelimit){
d388 2
d392 4
a395 1
bool CUploadQueue::RemoveFromUploadQueue(CUpDownClient* client, bool updatewindow){
d414 3
d420 2
a421 1
uint32 CUploadQueue::GetAverageUpTime(){
d428 4
a431 1
bool CUploadQueue::RemoveFromWaitingQueue(CUpDownClient* client, bool updatewindow){
d439 4
a442 2
	else
		return false;
d445 4
a448 1
void CUploadQueue::RemoveFromWaitingQueue(POSITION pos, bool updatewindow){	
d451 2
d458 2
d463 4
a466 1
bool CUploadQueue::CheckForTimeOver(CUpDownClient* client){
d472 3
d478 4
a481 1
void CUploadQueue::DeleteAll(){
d484 2
d488 4
a491 1
uint16 CUploadQueue::GetWaitingPosition(CUpDownClient* client){
d501 4
d507 4
a510 1
void CUploadQueue::CompDatarateOverhead(){
d523 2
a524 1
	return;
d527 3
a529 1
VOID CALLBACK TimerProc(HWND hwnd, UINT uMsg,UINT_PTR idEvent,DWORD dwTime){
d613 2
d617 4
a620 1
CUpDownClient* CUploadQueue::GetNextClient(CUpDownClient* lastclient){
d622 1
a622 1
		return 0;
d635 4
d641 4
a644 1
void CUploadQueue::FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, uchar* filehash) {
d660 2
@


1.2
log
@port to .25 b codebase...
@
text
@d417 1
a417 1
	this->m_AvarageUDRO_list.AddTail(m_nUpDataRateMSOverhead);
@


1.1
log
@*** empty log message ***
@
text
@d35 1
a35 1
        h_timer = ::SetTimer(0,141,100,TimerProc); // i_a
d37 1
a37 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_TIMERCREATEFAILED));
d45 1
a45 1
	sendtimestamp = ::GetTickCount();	// enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
d47 1
a47 1
	lasttimechecked = ::GetTickCount() ;
d51 2
d55 1
a55 1
	TransferredData newitem = {0,::GetTickCount()};
d72 2
a73 2
			if (::GetTickCount() - cur_client->GetLastUpRequest() > MAX_PURGEQUEUETIME
					|| theApp.sharedfiles->GetFileByID(cur_client->reqfileid) == (CKnownFile*)NULL) {   // Modified by Tarod [InterCeptor (remove "?" from queue) 15.11.02]
d104 1
d323 1
d416 16
d433 5
@

