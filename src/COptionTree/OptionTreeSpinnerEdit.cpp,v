head	1.2;
access;
symbols
	PublicRelease_1_2e:1.2
	Interim_Release_1-2e_RC1:1.2
	PublicRelease_1_2d:1.2
	Interim_Release_1-2d_RC1:1.2
	Interim_Release_1-2d_beta1:1.2
	PublicRelease_1_2c:1.2
	Interim_Release_1-2c_RC1:1.2
	Interim_Release_1-2c_beta1:1.2
	PublicRelease_1_2b:1.2
	Interim_Release_1-2b_RC1:1.2
	PublicRelease_1_2a:1.2
	Interim_Release_1-2a_RC1:1.2
	Interim_Release_1-2a_beta2:1.2
	Interim_Release_1-2a_beta1:1.2
	PublicRelease_1_2:1.2
	Interim_Release_1-2_RC1:1.2
	Interim_Release_1-2_beta1:1.2
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.1
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1
	PublicRelease_1i:1.1
	Interim_Release_1i_RC6:1.1
	Interim_Release_1i_RC3:1.1
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.2
date	2004.03.18.18.07.09;	author eklmn;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.34.02;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.17.33.01;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.2
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@// COptionTree
//
// License
// -------
// This code is provided "as is" with no expressed or implied warranty.
// 
// You may use this code in a commercial product with or without acknowledgement.
// However you may not sell this code or any modification of this code, this includes 
// commercial libraries and anything else for profit.
//
// I would appreciate a notification of any bugs or bug fixes to help the control grow.
//
// History:
// --------
//	See License.txt for full history information.
//
//
// Copyright (c) 1999-2002 
// ComputerSmarts.net 
// mattrmiller@@computersmarts.net

#include "stdafx.h"
#include "OptionTreeSpinnerEdit.h"

// Added Headers
#include "OptionTree.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COptionTreeSpinnerEdit

COptionTreeSpinnerEdit::COptionTreeSpinnerEdit()
{
	// Initialize variables
	m_otSpinnerButton = NULL;
}

COptionTreeSpinnerEdit::~COptionTreeSpinnerEdit()
{
}


BEGIN_MESSAGE_MAP(COptionTreeSpinnerEdit, CEdit)
	//{{AFX_MSG_MAP(COptionTreeSpinnerEdit)
	ON_WM_KEYDOWN()
	ON_WM_CREATE()
	ON_WM_CONTEXTMENU()
	ON_WM_KILLFOCUS()
	ON_WM_SETFOCUS()
	ON_CONTROL_REFLECT(EN_CHANGE, OnTextChange)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COptionTreeSpinnerEdit message handlers

void COptionTreeSpinnerEdit::SetOwnerSpinner(COptionTreeSpinnerButton *otSpinnerButton)
{
	// Save pointer
	m_otSpinnerButton = otSpinnerButton;
}

void COptionTreeSpinnerEdit::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// Find what key was presed
	if (nChar == VK_UP)
	{
		m_otSpinnerButton->SendMessage(OT_NOTIFY_UP, 0, 0);
	}
	else if (nChar == VK_DOWN)
	{
		m_otSpinnerButton->SendMessage(OT_NOTIFY_DOWN, 0, 0);
	}

	CEdit::OnKeyDown(nChar, nRepCnt, nFlags);
}

BOOL COptionTreeSpinnerEdit::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	// User edit
	if(m_otSpinnerButton != NULL)
	{
		// -- No user edit
		if (m_otSpinnerButton->GetOption(OT_EDIT_USEREDIT) == FALSE)
		{
			// -- -- No paste or cut
			if (LOWORD(wParam) == WM_PASTE || LOWORD(wParam) == WM_CUT)
			{
				return FALSE;
			}
		}
		// -- User edit
		else
		{
			switch (LOWORD(wParam))
			{
				case EM_UNDO:
				case WM_CUT:
				case WM_COPY:
				case WM_CLEAR:
				case WM_PASTE:
					return SendMessage(LOWORD(wParam));

				case OT_MES_NSELECTALL:
					return SendMessage(EM_SETSEL, 0, -1);

				default:
					return CEdit::OnCommand(wParam, lParam);
			}
		}
	}

	return FALSE;
}

int COptionTreeSpinnerEdit::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	// Create edit
	if (CEdit::OnCreate(lpCreateStruct) == -1)
	{
		return -1;
	}
	
	
	return 0;
}

void COptionTreeSpinnerEdit::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    // Declare variables
	CMenu mMenu;
	BOOL bReadOnly;
	DWORD dwFlags;
	int nSelStart, nSelEnd;
	int nLen;

	// Make sure we have options
	if (m_otSpinnerButton == NULL)
	{
		return;
	}

    // Crete menu
	mMenu.CreatePopupMenu();

    // Get read only
	bReadOnly = GetStyle() & ES_READONLY;
	
	// Get selection
	GetSel(nSelStart, nSelEnd);

	// Get window length
	nLen = GetWindowTextLength();

	// Insert Undo
	if (m_otSpinnerButton->GetOption(OT_EDIT_USEREDIT) == TRUE)
	{
		dwFlags = CanUndo() && !bReadOnly ? 0 : MF_GRAYED | MF_DISABLED;
	}
	else
	{
		dwFlags = MF_GRAYED | MF_DISABLED;
	}
    mMenu.InsertMenu(0, MF_BYPOSITION | dwFlags, EM_UNDO, OT_MES_UNDO);
	
	// Insert seperator
    mMenu.InsertMenu(1, MF_BYPOSITION | MF_SEPARATOR);

    // Insert copy
	if (nSelStart == nSelEnd)
	{
		dwFlags = MF_GRAYED | MF_DISABLED;
	}
	else
	{
		dwFlags = 0;
	}
    mMenu.InsertMenu(2, MF_BYPOSITION | dwFlags, WM_COPY, OT_MES_COPY);

	// Insert cut and clear
	if (m_otSpinnerButton->GetOption(OT_EDIT_USEREDIT) == TRUE)
	{
		if (nSelStart == nSelEnd || bReadOnly == TRUE)
		{
			dwFlags = MF_GRAYED | MF_DISABLED;
		}
		else
		{
			dwFlags = 0;
		}
	}
	else
	{
		dwFlags = MF_GRAYED | MF_DISABLED;
	}
    mMenu.InsertMenu(2, MF_BYPOSITION | dwFlags, WM_CUT, OT_MES_CUT);
    mMenu.InsertMenu(4, MF_BYPOSITION | dwFlags, WM_CLEAR, OT_MES_DELETE);

    // Insert paste
	if (m_otSpinnerButton->GetOption(OT_EDIT_USEREDIT) == TRUE)
	{
		if (IsClipboardFormatAvailable(CF_TEXT) == FALSE || bReadOnly == TRUE)
		{
			dwFlags = MF_GRAYED | MF_DISABLED;
		}
		else
		{
			dwFlags = 0;
		}
	}
	else
	{
		dwFlags = MF_GRAYED | MF_DISABLED;
	}
    mMenu.InsertMenu(4, MF_BYPOSITION | dwFlags, WM_PASTE, OT_MES_PASTE);

	// Insert seperator
    mMenu.InsertMenu(6, MF_BYPOSITION | MF_SEPARATOR);

    // Insert select all
    mMenu.InsertMenu(7, MF_BYPOSITION | dwFlags, OT_MES_NSELECTALL, OT_MES_SELECTALL);

    // Show menu
	mMenu.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);	
}

void COptionTreeSpinnerEdit::OnKillFocus(CWnd* pNewWnd) 
{
	// Make sure we have options
	if (m_otSpinnerButton != NULL)
	{
		// -- If new focus is not parent then sent message to item to commit
		if (pNewWnd->GetSafeHwnd() != m_otSpinnerButton->GetSafeHwnd())
		{
			::PostMessage(m_otSpinnerButton->GetSafeHwnd(), OT_NOTIFY_COMMITCHANGES, NULL, NULL);
		}			
	}
	
	CEdit::OnKillFocus(pNewWnd);	
}

void COptionTreeSpinnerEdit::OnSetFocus(CWnd* pOldWnd) 
{
	CEdit::OnSetFocus(pOldWnd);	
}

void COptionTreeSpinnerEdit::OnTextChange() 
{
	// Force spinner button redraw
	::PostMessage(m_otSpinnerButton->GetSafeHwnd(), OT_NOTIFY_FORCEREDRAW, NULL, NULL);	
}

BOOL COptionTreeSpinnerEdit::PreTranslateMessage(MSG* pMsg) 
{

	return CEdit::PreTranslateMessage(pMsg);
}

void COptionTreeSpinnerEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// Disallow user edit
	if(m_otSpinnerButton != NULL)
	{
		// -- No user edit
		if (m_otSpinnerButton->GetOption(OT_EDIT_USEREDIT) == FALSE)
		{
			return;
		}
	}
			
		
	
	CEdit::OnChar(nChar, nRepCnt, nFlags);
}
@


1.1
log
@*** empty log message ***
@
text
@d230 1
a230 1
	mMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON, point.x, point.y, this);	
@


1.1.4.1
log
@updating this branch...
@
text
@@

