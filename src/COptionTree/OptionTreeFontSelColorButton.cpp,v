head	1.1;
access;
symbols
	PublicRelease_1_2e:1.1
	Interim_Release_1-2e_RC1:1.1
	PublicRelease_1_2d:1.1
	Interim_Release_1-2d_RC1:1.1
	Interim_Release_1-2d_beta1:1.1
	PublicRelease_1_2c:1.1
	Interim_Release_1-2c_RC1:1.1
	Interim_Release_1-2c_beta1:1.1
	PublicRelease_1_2b:1.1
	Interim_Release_1-2b_RC1:1.1
	PublicRelease_1_2a:1.1
	Interim_Release_1-2a_RC1:1.1
	Interim_Release_1-2a_beta2:1.1
	Interim_Release_1-2a_beta1:1.1
	PublicRelease_1_2:1.1
	Interim_Release_1-2_RC1:1.1
	Interim_Release_1-2_beta1:1.1
	PublicRelease_1_1g:1.1
	Interim_Release_1-1g_RC3:1.1
	Interim_Release_1-1g_RC2:1.1
	Interim_Release_1-1g_RC1:1.1
	Interim_Release_1-1g_beta2:1.1
	Interim_Release_1-1g_beta1:1.1
	PublicRelease_1_1f:1.1
	Interim_Release_1-1f_RC1:1.1
	PublicRelease_1_1e:1.1
	Interim_Release_1-1e_RC2:1.1
	Interim_Release_1-1e_RC1:1.1
	Interim_Release_1-1e_beta1:1.1
	PublicRelease_1_1d:1.1
	Interim_Release_1-1d_RC1:1.1
	PublicRelease_1_1c:1.1
	Interim_Release_1-1c_RC1:1.1
	Interim_Release_1-1c_beta2:1.1
	Interim_Release_1-1c_beta1:1.1
	PublicRelease_1_1b:1.1
	Interim_Release_1-1b_RC1:1.1
	PublicRelease_1_1a:1.1
	Interim_Release_1-1a_RC2:1.1
	Interim_Release_1-1a_RC1:1.1
	Interim_Release_1-1a_beta2:1.1
	Interim_Release_1-1a_beta1:1.1
	PublicRelease_1_1:1.1
	Interim_Release_1-1_beta1:1.1
	PublicRelease_1o:1.1
	Interim_Release_1o_RC1:1.1
	Interim_Release_1o_beta1:1.1
	PublicRelease_1n:1.1
	Interim_Release_1n_RC2:1.1
	Interim_Release_1n_RC1:1.1
	PublicRelease_1m:1.1
	Interim_Release_1m_beta1:1.1
	PublicRelease_1l:1.1
	Interim_Release_1l_RC3:1.1
	Interim_Release_1l_RC2:1.1
	Interim_Release_1l_RC1:1.1
	Interim_Release_1l_beta2:1.1
	Interim_Release_1l_beta1:1.1
	PublicRelease_1k:1.1
	Interim_Release_1k_RC4:1.1
	Interim_1k_RC3:1.1
	Interim_1k_RC2:1.1
	Interim_Release_1k_RC1:1.1
	Interim_Release_1k_beta5:1.1
	Intrerim_Release_1k_beta4:1.1
	Interim_Release_1k_beta1:1.1
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1
	PublicRelease_1i:1.1
	Interim_Release_1i_RC6:1.1
	Interim_Release_1i_RC3:1.1
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.1
date	2003.01.21.18.34.01;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.17.32.55;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.1
log
@*** empty log message ***
@
text
@// COptionTree
//
// License
// -------
// This code is provided "as is" with no expressed or implied warranty.
// 
// You may use this code in a commercial product with or without acknowledgement.
// However you may not sell this code or any modification of this code, this includes 
// commercial libraries and anything else for profit.
//
// I would appreciate a notification of any bugs or bug fixes to help the control grow.
//
// History:
// --------
//	See License.txt for full history information.
//
//
// Copyright (c) 1999-2002 
// ComputerSmarts.net 
// mattrmiller@@computersmarts.net

#include "stdafx.h"
#include "OptionTreeFontSelColorButton.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// Static
void AFXAPI DDX_ColorButton(CDataExchange *pDX, int nIDC, COLORREF& crColor)
{
	// Declare variables
    HWND hWndCtrl = pDX->PrepareCtrl(nIDC);

	// Validate
    ASSERT (hWndCtrl != NULL);                
    
    COptionTreeFontSelColorButton* pColorButton = (COptionTreeFontSelColorButton*) CWnd::FromHandle(hWndCtrl);
    if (pDX->m_bSaveAndValidate)
    {
		crColor = pColorButton->GetColor();
    }
    else
    {
		pColorButton->SetColor(crColor);
    }
}
const int g_ciArrowSizeX = 4 ;
const int g_ciArrowSizeY = 2 ;


IMPLEMENT_DYNCREATE(COptionTreeFontSelColorButton, CButton)


COptionTreeFontSelColorButton::COptionTreeFontSelColorButton(): _Inherited()
{
	// Initialize variables
	m_crColor = CLR_DEFAULT;
	m_crDefaultColor = ::GetSysColor(COLOR_APPWORKSPACE);
	m_strDefaultText = _T("Automatic");
	m_strCustomText = _T("More Colors...");
	m_bPopupActive = FALSE;
	m_bTrackSelection = FALSE;
}


COptionTreeFontSelColorButton::~COptionTreeFontSelColorButton()
{
}

BEGIN_MESSAGE_MAP(COptionTreeFontSelColorButton, CButton)
    //{{AFX_MSG_MAP(COptionTreeFontSelColorButton)
    ON_CONTROL_REFLECT_EX(BN_CLICKED, OnClicked)
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    ON_MESSAGE(OT_COLOR_SELENDOK, OnSelEndOK)
    ON_MESSAGE(OT_COLOR_SELENDCANCEL, OnSelEndCancel)
    ON_MESSAGE(OT_COLOR_SELCHANGE, OnSelChange)
END_MESSAGE_MAP()


COLORREF COptionTreeFontSelColorButton::GetColor() const
{
	return m_crColor;
}


void COptionTreeFontSelColorButton::SetColor(COLORREF crColor)
{
	// Save color
	m_crColor = crColor;

	// Force redraw
	if (::IsWindow(m_hWnd)) 
	{
        RedrawWindow();
	}
}

COLORREF COptionTreeFontSelColorButton::GetDefaultColor() const
{
	return m_crDefaultColor;
}

void COptionTreeFontSelColorButton::SetDefaultColor(COLORREF crColor)
{
	m_crDefaultColor = crColor;
}

void COptionTreeFontSelColorButton::SetCustomText(LPCTSTR tszText)
{
	m_strCustomText = tszText;
}

void COptionTreeFontSelColorButton::SetDefaultText(LPCTSTR tszText)
{
	m_strDefaultText = tszText;
}

void COptionTreeFontSelColorButton::SetTrackSelection(BOOL bTrack)
{
	m_bTrackSelection = bTrack;
}

BOOL COptionTreeFontSelColorButton::GetTrackSelection() const
{
	return m_bTrackSelection;
}

void COptionTreeFontSelColorButton::PreSubclassWindow() 
{
	// Owner drawn
    ModifyStyle(0, BS_OWNERDRAW);      

	// Subclass
    _Inherited::PreSubclassWindow();
}


long COptionTreeFontSelColorButton::OnSelEndOK(UINT lParam, long wParam)
{
	// Active popup
	m_bPopupActive = FALSE;

	// Declare variables
    COLORREF crOldColor = m_crColor;
	CWnd *pParent = GetParent();
	
	// Get new color
	m_crColor = (COLORREF)lParam;

	// Send messages to parent    
    if (pParent) 
	{
        pParent->SendMessage(OT_COLOR_CLOSEUP, lParam, (WPARAM) GetDlgCtrlID());
        pParent->SendMessage(OT_COLOR_SELENDOK, lParam, (WPARAM) GetDlgCtrlID());
    }
    if (crOldColor != m_crColor)
	{
        if (pParent) pParent->SendMessage(OT_COLOR_SELCHANGE, m_crColor, (WPARAM) GetDlgCtrlID());
	}

    return TRUE;
}

long COptionTreeFontSelColorButton::OnSelEndCancel(UINT lParam, long wParam)
{
	// Active popup
	m_bPopupActive = FALSE;
	
	// Get new color
	m_crColor = (COLORREF)lParam;

	// Declare variables
    CWnd *pParent = GetParent();

	// Send messages to parent  
    if (pParent) 
	{
        pParent->SendMessage(OT_COLOR_CLOSEUP, lParam, (WPARAM) GetDlgCtrlID());
        pParent->SendMessage(OT_COLOR_SELENDCANCEL, lParam, (WPARAM) GetDlgCtrlID());
    }

    return TRUE;
}

long COptionTreeFontSelColorButton::OnSelChange(UINT lParam, long /*wParam*/)
{
    // Track selection
	if (m_bTrackSelection) 
	{
		// Get new color
		m_crColor = (COLORREF)lParam;
	}

	// Force redraw
	if (::IsWindow(m_hWnd)) 
	{
        RedrawWindow();
	}

	// Declare variables
    CWnd *pParent = GetParent();

	// Send messages to parent  
    if (pParent) 
	{
		pParent->SendMessage(OT_COLOR_SELCHANGE, lParam, (WPARAM) GetDlgCtrlID());
	}

    return TRUE;
}

int COptionTreeFontSelColorButton::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    // Create
	if (CButton::OnCreate(lpCreateStruct) == -1)
	{
        return -1;
	}

    return 0;
}

BOOL COptionTreeFontSelColorButton::OnClicked()
{
	// Active popup
	m_bPopupActive = TRUE;

	// Declare variables
    CRect rDraw;
	CWnd *pParent = GetParent();

	// Get window rectangle
    GetWindowRect(rDraw);

    new COptionTreeColorPopUp(CPoint(rDraw.left, rDraw.bottom), m_crColor, m_crDefaultColor, this, m_strDefaultText, m_strCustomText);

	// Send messages to parent  
    if (pParent)
	{
        pParent->SendMessage(OT_COLOR_DROPDOWN, (LPARAM)m_crColor, (WPARAM) GetDlgCtrlID());
	}

    return TRUE;
}

void COptionTreeFontSelColorButton::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct) 
{
	// Validate
	ASSERT(lpDrawItemStruct);

	// Declare variables
	CDC* pDC  = CDC::FromHandle(lpDrawItemStruct->hDC);
	UINT state = lpDrawItemStruct->itemState;
    CRect rDraw = lpDrawItemStruct->rcItem;
	CRect rArrow;
	UINT uFrameState;

	// Active popup
	if (m_bPopupActive)
	{
		state |= ODS_SELECTED | ODS_FOCUS;
	}

	// Frame state
	uFrameState = DFCS_BUTTONPUSH | DFCS_ADJUSTRECT;

	// Selected
	if (state & ODS_SELECTED)
	{
		uFrameState |= DFCS_PUSHED;
	}

	// Disabled
	if (state & ODS_DISABLED)
	{
		uFrameState |= DFCS_INACTIVE;
	}
	
	// Draw frame
	pDC->DrawFrameControl(&rDraw, DFC_BUTTON, uFrameState);


	// Offset rectangle if selected
	if (state & ODS_SELECTED)
	{
		rDraw.OffsetRect(1,1);
	}

	// Draw focus
	if (state & ODS_FOCUS) 
    {
		RECT rFocus = {rDraw.left, rDraw.top, rDraw.right - 1, rDraw.bottom};
  
        pDC->DrawFocusRect(&rFocus);
    }
	rDraw.DeflateRect(::GetSystemMetrics(SM_CXEDGE), ::GetSystemMetrics(SM_CYEDGE));

	// Draw arrow
	rArrow.left = rDraw.right - g_ciArrowSizeX - ::GetSystemMetrics(SM_CXEDGE) /2;
	rArrow.right = rArrow.left + g_ciArrowSizeX;
	rArrow.top = (rDraw.bottom + rDraw.top)/2 - g_ciArrowSizeY / 2;
	rArrow.bottom = (rDraw.bottom + rDraw.top)/2 + g_ciArrowSizeY / 2;
	DrawArrow(pDC, &rArrow, 0,(state & ODS_DISABLED) ? ::GetSysColor(COLOR_GRAYTEXT) : RGB(0,0,0));
	rDraw.right = rArrow.left - ::GetSystemMetrics(SM_CXEDGE)/2;

	// Draw seperator
	pDC->DrawEdge(&rDraw, EDGE_ETCHED, BF_RIGHT);
	rDraw.right -= (::GetSystemMetrics(SM_CXEDGE) * 2) + 1 ;
				  
	// Draw color
	if ((state & ODS_DISABLED) == 0)
	{
		pDC->FillSolidRect(&rDraw, (m_crColor == CLR_DEFAULT) ? m_crDefaultColor : m_crColor);

		::FrameRect(pDC->m_hDC, &rDraw, (HBRUSH)::GetStockObject(BLACK_BRUSH));
	}
}


void COptionTreeFontSelColorButton::DrawArrow(CDC* pDC, RECT* pRect, int nDirection, COLORREF crArrow)
{
	POINT ptsArrow[3];

	switch (nDirection)
	{
		// -- Down
		case 0 :
		{
			ptsArrow[0].x = pRect->left;
			ptsArrow[0].y = pRect->top;
			ptsArrow[1].x = pRect->right;
			ptsArrow[1].y = pRect->top;
			ptsArrow[2].x = (pRect->left + pRect->right)/2;
			ptsArrow[2].y = pRect->bottom;
			break;
		}

		// -- Up
		case 1 :
		{
			ptsArrow[0].x = pRect->left;
			ptsArrow[0].y = pRect->bottom;
			ptsArrow[1].x = pRect->right;
			ptsArrow[1].y = pRect->bottom;
			ptsArrow[2].x = (pRect->left + pRect->right)/2;
			ptsArrow[2].y = pRect->top;
			break;
		}
		
		// -- Left
		case 2 :
		{
			ptsArrow[0].x = pRect->right;
			ptsArrow[0].y = pRect->top;
			ptsArrow[1].x = pRect->right;
			ptsArrow[1].y = pRect->bottom;
			ptsArrow[2].x = pRect->left;
			ptsArrow[2].y = (pRect->top + pRect->bottom)/2;
			break;
		}

		// -- Right
		case 3 :
		{
			ptsArrow[0].x = pRect->left;
			ptsArrow[0].y = pRect->top;
			ptsArrow[1].x = pRect->left;
			ptsArrow[1].y = pRect->bottom;
			ptsArrow[2].x = pRect->right;
			ptsArrow[2].y = (pRect->top + pRect->bottom)/2;
			break;
		}
	}
	
	// Draw
	CBrush brsArrow(crArrow);
	CPen penArrow(PS_SOLID, 1 , crArrow);
	CBrush* pOldBrush = pDC->SelectObject(&brsArrow);
	CPen*   pOldPen   = pDC->SelectObject(&penArrow);	
	pDC->SetPolyFillMode(WINDING);
	pDC->Polygon(ptsArrow, 3);
	pDC->SelectObject(pOldBrush);
	pDC->SelectObject(pOldPen);
}
@


1.1.4.1
log
@updating this branch...
@
text
@@

