head	1.34;
access;
symbols
	PublicRelease_1_2e:1.34
	Interim_Release_1-2e_RC1:1.34
	PublicRelease_1_2d:1.33
	Interim_Release_1-2d_RC1:1.33
	Interim_Release_1-2d_beta1:1.33
	PublicRelease_1_2c:1.32
	Interim_Release_1-2c_RC1:1.32
	Interim_Release_1-2c_beta1:1.32
	PublicRelease_1_2b:1.32
	Interim_Release_1-2b_RC1:1.32
	PublicRelease_1_2a:1.30
	Interim_Release_1-2a_RC1:1.30
	Interim_Release_1-2a_beta2:1.30
	Interim_Release_1-2a_beta1:1.30
	PublicRelease_1_2:1.30
	Interim_Release_1-2_RC1:1.30
	Interim_Release_1-2_beta1:1.29
	PublicRelease_1_1g:1.29
	Interim_Release_1-1g_RC3:1.29
	Interim_Release_1-1g_RC2:1.29
	Interim_Release_1-1g_RC1:1.29
	Interim_Release_1-1g_beta2:1.27
	Interim_Release_1-1g_beta1:1.27
	PublicRelease_1_1f:1.27
	Interim_Release_1-1f_RC1:1.27
	PublicRelease_1_1e:1.27
	Interim_Release_1-1e_RC2:1.27
	Interim_Release_1-1e_RC1:1.27
	Interim_Release_1-1e_beta1:1.27
	PublicRelease_1_1d:1.27
	Interim_Release_1-1d_RC1:1.27
	PublicRelease_1_1c:1.27
	Interim_Release_1-1c_RC1:1.27
	Interim_Release_1-1c_beta2:1.27
	Interim_Release_1-1c_beta1:1.27
	PublicRelease_1_1b:1.27
	Interim_Release_1-1b_RC1:1.27
	PublicRelease_1_1a:1.26
	Interim_Release_1-1a_RC2:1.26
	Interim_Release_1-1a_RC1:1.25
	Interim_Release_1-1a_beta2:1.25
	Interim_Release_1-1a_beta1:1.19
	PublicRelease_1_1:1.19
	Interim_Release_1-1_beta1:1.19
	PublicRelease_1o:1.19
	Interim_Release_1o_RC1:1.19
	Interim_Release_1o_beta1:1.19
	PublicRelease_1n:1.19
	Interim_Release_1n_RC2:1.19
	Interim_Release_1n_RC1:1.19
	Interim_Release_1n_beta2:1.19
	Interim_Release_1n_beta1:1.19
	PublicRelease_1m:1.19
	Interim_Release_1m_beta1:1.19
	PublicRelease_1l:1.19
	Interim_Release_1l_RC3:1.19
	Interim_Release_1l_RC2:1.19
	Interim_Release_1l_RC1:1.19
	Interim_Release_1l_beta2:1.19
	Interim_Release_1l_beta1:1.19
	PublicRelease_1k:1.19
	Interim_Release_1k_RC4:1.19
	Interim_1k_RC3:1.19
	Interim_1k_RC2:1.19
	Interim_Release_1k_RC1:1.19
	Interim_Release_1k_beta5:1.19
	Intrerim_Release_1k_beta4:1.19
	Interim_Release_1k_beta1:1.18
	PublicRelease_1j:1.17
	Interim_Release_1J_RC3:1.17
	Interim_Release_1j_RC3:1.17
	Interim_Release_1j_RC2:1.17
	Interim_Release_1j_RC1:1.17
	Interim_Release_1j_beta2:1.17
	Interim_Release_1j_beta1:1.17
	PublicRelease_1i:1.17
	Interim_Release_1i_RC6:1.17
	Interim_Release_1i_RC3:1.17
	Interim_Release_1i_RC2:1.17
	Interim_Release_1i_RC1:1.15
	Interim_Release_1i_beta3:1.15
	Interim_Release_1i_beta2:1.13
	Interim_Release_1i_beta1:1.12
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.8
	Interim_Release_1h_RC1:1.8
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.8
	Interim_Release_1h_beta1:1.8
	PublicRelease_1g:1.8
	Interim_Release_1g_RC6_Final:1.8
	Interim_Release_1g_RC6:1.8
	Interim_Release_1g_RC5:1.8
	Interim_Release_1g_RC4:1.8
	Interim_Release_1g_RC3:1.8
	Interim_Release_1g_beta2:1.7
	Interim_Release_1g_beta1:1.7
	Interim_Release_1f_RC4:1.7
	Interim_Release_1f_RC3:1.7
	Interim_Release_1f_RC2:1.6
	Interim_Release_1f_RC:1.6
	Interim_Release_1f_beta2:1.6
	Interim_Release_1f_beta1:1.6
	PublicRelease_1e:1.6
	Interim_Release_1e_RC2:1.6
	Interim_Release_1e_RC:1.6
	Interim_Release_1e_beta3:1.6
	Interim_Release_1e_beta2:1.6
	Interim_Release_1e_beta2_before_kuchin:1.6
	Interim_Release_1e_beta1:1.6
	PublicRelease_1c:1.6
	featurestest:1.6.0.8
	Interim_Release_1c_RC:1.6
	Interim_Release_1c_beta2:1.6
	Interim_Release_1c_beta1:1.6
	threaded_downloadqueue:1.6.0.6
	PublicRelease_1b:1.6
	Interim_Release_1b_beta2:1.6
	Interim_Release_1b_beta1:1.6
	proxydeadlake:1.6.0.4
	PublicRelease_1a:1.6
	Interim_Release_1a_beta2:1.6
	BerkeleyDb:1.6.0.2
	Interim_Release_1a_beta1:1.6
	PublicRelease_1:1.6
	goldfish:1.6
	eMulePlus_1_RC2:1.5
	eMulePlus_26b_1RC1:1.5
	PreRelease_26b_i0e:1.5
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.34
date	2008.11.24.03.13.33;	author aw3;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.16.05.15.55;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2006.12.14.02.01.44;	author aw3;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.13.18.24.03;	author eklmn;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.05.03.30.18;	author aw3;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.16.06.09.15;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.28.19.01.20;	author aw3;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.21.23.51.55;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.19.00.29.33;	author aw3;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.18.06.57.49;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.17.05.47.39;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.16.22.41.52;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.15.19.05.48;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2004.02.25.04.46.32;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.15.18.24.17;	author eklmn;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.12.02.59.48;	author katsyonak;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.29.14.14.17;	author morevit;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.21.22.05.12;	author morevit;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.19.14.42.45;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.11.18.27.05;	author eklmn;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.20.20.38.09;	author netwolf1;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.20.14.28.53;	author dongato;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.18.19.10.35;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.17.19.29.45;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.16.22.01.45;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.14.14.21;	author cax2;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.17.59.08;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.34
log
@WebServer: improved download progress bar representation for large files {DonGato}.
@
text
@#include "stdafx.h"
#include "emule.h"
#include "BarShader.h"
#include "math.h"
#include "otherfunctions.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#ifndef M_PI_2
#define M_PI_2     1.57079632679489661923
#endif

#ifndef PI
#define PI 3.14159265358979323846264338328
#endif

#define HALF(X) (((X) + 1) / 2)

CBarShader::CBarShader(uint32 dwHeight, uint32 dwWidth, COLORREF crColor /*= 0*/, uint64 qwFileSize /*= 1*/)
{
	m_iWidth = dwWidth;
	m_iHeight = dwHeight;
	m_qwFileSize = 0;
	m_Spans.SetAt(0, crColor);
	m_Spans.SetAt(qwFileSize, 0);
	m_pdblModifiers = NULL;
	m_bIsPreview = false;
	m_used3dlevel = 0;
	SetFileSize(qwFileSize);
}

CBarShader::~CBarShader(void)
{
	delete[] m_pdblModifiers;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Must not be called when m_used3dlevel = 0 (flat)
void CBarShader::BuildModifiers()
{
	if (m_pdblModifiers != NULL)
	{
		delete[] m_pdblModifiers;
		m_pdblModifiers = NULL; // 'new' may throw an exception
	}

	// New property page slider to control depth of gradient

	// Depth must be at least 2
	// 2 gives greatest depth, the higher the value, the flatter the appearance
	// m_pdblModifiers[dwCount-1] will always be 1, m_pdblModifiers[0] depends on the value of depth
	static const double dDepths[5] = { 5.5, 4.0, 3.0, 2.50, 2.25 };		//aqua bar - smoother gradient jumps...
	double	depth = dDepths[((m_used3dlevel > 5) ? (256 - m_used3dlevel) : m_used3dlevel) - 1];
	uint32	dwCount = HALF(static_cast<uint32>(m_iHeight));
	double piOverDepth = PI / depth;
	double base = PI / 2 - piOverDepth;
	double increment = piOverDepth / (dwCount - 1);

	m_pdblModifiers = new double[dwCount];
	for (uint32 i = 0; i < dwCount; i++, base += increment)
		m_pdblModifiers[i] = sin(base);
}

void CBarShader::SetWidth(int width)
{
	if(m_iWidth != width) {
		m_iWidth = width;
		if (m_qwFileSize)
			m_dblPixelsPerByte = (double)m_iWidth / m_qwFileSize;
		else
			m_dblPixelsPerByte = 0.0;
		if (m_iWidth)
			m_dblBytesPerPixel = (double)m_qwFileSize / m_iWidth;
		else
			m_dblBytesPerPixel = 0.0;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CBarShader::SetFileSize(uint64 qwFileSize)
{
	if (m_qwFileSize != qwFileSize)
	{
		m_qwFileSize = qwFileSize;
		if (m_qwFileSize)
			m_dblPixelsPerByte = static_cast<double>(m_iWidth) / m_qwFileSize;
		else
			m_dblPixelsPerByte = 0.0;
		if (m_iWidth)
			m_dblBytesPerPixel = static_cast<double>(m_qwFileSize) / m_iWidth;
		else
			m_dblBytesPerPixel = 0.0;
	}
}

void CBarShader::SetHeight(int height)
{
	if(m_iHeight != height)
 	{
		m_iHeight = height;

		if ((m_used3dlevel = g_App.m_pPrefs->Get3DDepth()) != 0)
			BuildModifiers();
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CBarShader::FillRange(uint64 qwStart, uint64 qwEnd, COLORREF crColor)
{
	if(qwEnd > m_qwFileSize)
		qwEnd = m_qwFileSize;

	if(qwStart >= qwEnd)
		return;
	POSITION endprev, endpos = m_Spans.FindFirstKeyAfter(qwEnd + 1ui64);

	if ((endprev = endpos) != NULL)
		m_Spans.GetPrev(endpos);
	else
		endpos = m_Spans.GetTailPosition();

	ASSERT(endpos != NULL);

	COLORREF endcolor = m_Spans.GetValueAt(endpos);

	if ((endcolor == crColor) && (m_Spans.GetKeyAt(endpos) <= qwEnd) && (endprev != NULL))
		endpos = endprev;
	else
		endpos = m_Spans.SetAt(qwEnd, endcolor);

	for (POSITION pos = m_Spans.FindFirstKeyAfter(qwStart); pos != endpos;)
	{
		POSITION pos1 = pos;
		m_Spans.GetNext(pos);
		m_Spans.RemoveAt(pos1);
	}

	m_Spans.GetPrev(endpos);

	if ((endpos == NULL) || (m_Spans.GetValueAt(endpos) != crColor))
		m_Spans.SetAt(qwStart, crColor);
}

void CBarShader::Fill(COLORREF crColor)
{
	m_Spans.RemoveAll();
	m_Spans.SetAt(0, crColor);
	m_Spans.SetAt(m_qwFileSize, 0);
}

void CBarShader::DrawPreview(CDC* dc, int iLeft, int iTop, byte previewLevel)
{
	m_bIsPreview = true;
	m_used3dlevel = previewLevel;
	if (previewLevel != 0)
		BuildModifiers();
	Draw(dc, iLeft, iTop, (previewLevel == 0));
	m_bIsPreview = false;
}

void CBarShader::Draw(CDC* dc, int iLeft, int iTop, bool bFlat)
{
	COLORREF crLastColor = ~0u, crPrevBkColor = dc->GetBkColor();
	POSITION pos = m_Spans.GetHeadPosition();
	RECT rectSpan;
	rectSpan.top = iTop;
	rectSpan.bottom = iTop + m_iHeight;
	rectSpan.right = iLeft;

	sint64 iBytesInOnePixel = static_cast<sint64>(m_dblBytesPerPixel + 0.5);
	uint64 qwStart = 0;
	COLORREF crColor = m_Spans.GetNextValue(pos);

	iLeft += m_iWidth;
	while ((pos != NULL) && (rectSpan.right < iLeft)) {
		uint64 qwSpan = m_Spans.GetKeyAt(pos) - qwStart;
		int iPixels = static_cast<int>(qwSpan * m_dblPixelsPerByte + 0.5);

		if(iPixels > 0) {
			rectSpan.left = rectSpan.right;
			rectSpan.right += iPixels;
			FillRect(dc, &rectSpan, crLastColor = crColor, bFlat);

			qwStart += static_cast<uint64>(iPixels * m_dblBytesPerPixel + 0.5);
		} else {
			double dblWeight, dRed = 0, dGreen = 0, dBlue = 0;
			uint32 dwRed, dwGreen, dwBlue;
			uint64 qwLast = qwStart, qwEnd = qwStart + iBytesInOnePixel;

			do {
				dblWeight = (min(m_Spans.GetKeyAt(pos), qwEnd) - qwLast) * m_dblPixelsPerByte;
				dRed   += GetRValue(crColor) * dblWeight;
				dGreen += GetGValue(crColor) * dblWeight;
				dBlue  += GetBValue(crColor) * dblWeight;
				if ((qwLast = m_Spans.GetKeyAt(pos)) >= qwEnd)
					break;
				crColor = m_Spans.GetValueAt(pos);
				m_Spans.GetNext(pos);
			} while(pos != NULL);
			rectSpan.left = rectSpan.right;
			rectSpan.right++;

		//	Saturation
			dwRed = static_cast<uint32>(dRed);
			if (dwRed > 255)
				dwRed = 255;
			dwGreen = static_cast<uint32>(dGreen);
			if (dwGreen > 255)
				dwGreen = 255;
			dwBlue = static_cast<uint32>(dBlue);
			if (dwBlue > 255)
				dwBlue = 255;

			FillRect(dc, &rectSpan, crLastColor = RGB(dwRed, dwGreen, dwBlue), bFlat);
			qwStart += iBytesInOnePixel;
		}
		while((pos != NULL) && (m_Spans.GetKeyAt(pos) <= qwStart))
			crColor = m_Spans.GetNextValue(pos);
	}
	if ((rectSpan.right < iLeft) && (crLastColor != ~0))
	{
		rectSpan.left = rectSpan.right;
		rectSpan.right = iLeft;
		FillRect(dc, &rectSpan, crLastColor, bFlat);
	}
	dc->SetBkColor(crPrevBkColor);	//restore previous background color
}

void CBarShader::FillRect(CDC *dc, LPCRECT rectSpan, COLORREF crColor, bool bFlat)
{
	if(!crColor || bFlat)
		dc->FillSolidRect(rectSpan, crColor);
	else
	{
		if ((m_used3dlevel != g_App.m_pPrefs->Get3DDepth() && !m_bIsPreview) || m_pdblModifiers == NULL)
		{
			m_used3dlevel = g_App.m_pPrefs->Get3DDepth();
			BuildModifiers();
		}

		double	dblRed = GetRValue(crColor), dblGreen = GetGValue(crColor), dblBlue = GetBValue(crColor);
		double	dAdd, dMod;

		if (m_used3dlevel > 5)		//Cax2 aqua bar
		{
			dMod = 1.0 - .025 * (256 - m_used3dlevel);		//variable central darkness - from 97.5% to 87.5% of the original colour...
			dAdd = 255;

			dblRed = dMod * dblRed - dAdd;
			dblGreen = dMod * dblGreen - dAdd;
			dblBlue = dMod * dblBlue - dAdd;
		}
		else
			dAdd = 0;

		RECT		rect;
		int			iTop = rectSpan->top, iBot = rectSpan->bottom;
		double		*pdCurr = m_pdblModifiers, *pdLimit = pdCurr + HALF(m_iHeight);

		rect.right = rectSpan->right;
		rect.left = rectSpan->left;

		for (; pdCurr < pdLimit; pdCurr++)
		{
			crColor = RGB( static_cast<int>(dAdd + dblRed * *pdCurr),
				static_cast<int>(dAdd + dblGreen * *pdCurr),
				static_cast<int>(dAdd + dblBlue * *pdCurr) );
			rect.top = iTop++;
			rect.bottom = iTop;
			dc->FillSolidRect(&rect, crColor);

			rect.bottom = iBot--;
			rect.top = iBot;
		//	Fast way to fill, background color is already set inside previous FillSolidRect
			dc->ExtTextOut(0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static TCHAR ColorToChar(COLORREF crColor)
{
	unsigned	uiComponent;

	uiComponent = GetGValue(crColor);	//yellow (highest priority from user point of view)
	if (uiComponent != 0)
		return _T('8');
	uiComponent = GetRValue(crColor);	//red (high priority to stress it among blue ones)
	if (uiComponent > 100)
		return _T('7');
	return static_cast<TCHAR>(GetBValue(crColor) + _T('0'));	//0 - black, 1-6 blue
}

void CBarShader::GenerateWSBar(CString *pstrBar)
{
	POSITION	pos = m_Spans.GetHeadPosition();
	TCHAR		cColCode, *pcBarPos = pstrBar->GetBuffer(m_iWidth);
	const TCHAR	*const pcBarEnd = pcBarPos + m_iWidth;
	sint64		iBytesInOnePixel = static_cast<sint64>(m_dblBytesPerPixel + 0.5);
	uint64		qwStart = 0;
	COLORREF	crLastColor = ~0u, crColor = m_Spans.GetNextValue(pos);

	while ((pos != NULL) && (pcBarPos < pcBarEnd))
	{
		uint64 qwSpan = m_Spans.GetKeyAt(pos) - qwStart;
		int iPixels = static_cast<int>(qwSpan * m_dblPixelsPerByte + 0.5);

		if (iPixels > 0)
		{
			qwStart += static_cast<uint64>(iPixels * m_dblBytesPerPixel + 0.5);
			cColCode = ColorToChar(crLastColor = crColor);
			do {
				*pcBarPos++ = cColCode;
			} while(--iPixels > 0);
		}
		else
		{
			double dblWeight, dRed = 0, dGreen = 0, dBlue = 0;
			uint32 dwRed, dwGreen, dwBlue;
			uint64 qwLast = qwStart, qwEnd = qwStart + iBytesInOnePixel;

			do {
				dblWeight = (min(m_Spans.GetKeyAt(pos), qwEnd) - qwLast) * m_dblPixelsPerByte;
				dRed   += GetRValue(crColor) * dblWeight;
				dGreen += GetGValue(crColor) * dblWeight;
				dBlue  += GetBValue(crColor) * dblWeight;
				if ((qwLast = m_Spans.GetKeyAt(pos)) >= qwEnd)
					break;
				crColor = m_Spans.GetValueAt(pos);
				m_Spans.GetNext(pos);
			} while(pos != NULL);

		//	Saturation
			dwRed = static_cast<uint32>(dRed);
			if (dwRed > 255)
				dwRed = 255;
			dwGreen = static_cast<uint32>(dGreen);
			if (dwGreen > 255)
				dwGreen = 255;
			dwBlue = static_cast<uint32>(dBlue + 0.5);
			if (dwBlue > 6)
				dwBlue = 6;

			*pcBarPos++ = ColorToChar(crLastColor = RGB(dwRed, dwGreen, dwBlue));
			qwStart += iBytesInOnePixel;
		}
		while((pos != NULL) && (m_Spans.GetKeyAt(pos) <= qwStart))
			crColor = m_Spans.GetNextValue(pos);
	}
	if ((pcBarPos < pcBarEnd) && (crLastColor != ~0))
	{
		cColCode = ColorToChar(crLastColor);
		do {
			*pcBarPos = cColCode;
		} while(++pcBarPos < pcBarEnd);
	}
	pstrBar->ReleaseBufferSetLength(m_iWidth);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.33
log
@Suppressed compiler warning.
@
text
@d190 1
a190 1
			double dRed = 0, dGreen = 0, dBlue = 0;
d195 1
a195 1
				double	dblWeight = (min(m_Spans.GetKeyAt(pos), qwEnd) - qwLast) * m_dblPixelsPerByte;
d284 79
@


1.32
log
@Rolled previous unconscious modification back -- I suggest developers to read the code first, as we have better things to do instead of breaking and fixing...
@
text
@d167 1
a167 1
	COLORREF crLastColor = ~0, crPrevBkColor = dc->GetBkColor();
@


1.31
log
@prevent an access out off array...
@
text
@d57 1
a57 1
	double	depth = dDepths[((m_used3dlevel > 5) ? 5 : m_used3dlevel) - 1];
@


1.30
log
@Make progress bar ready for 64-bit file size.
@
text
@d57 1
a57 1
	double	depth = dDepths[((m_used3dlevel > 5) ? (256 - m_used3dlevel) : m_used3dlevel) - 1];
@


1.29
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d23 1
a23 1
CBarShader::CBarShader(uint32 dwHeight, uint32 dwWidth, COLORREF crColor /*= 0*/, uint32 dwFileSize /*= 1*/)
d27 1
a27 1
	m_dwFileSize = 0;
d29 1
a29 1
	m_Spans.SetAt(dwFileSize, 0);
d33 1
a33 1
	SetFileSize(dwFileSize);
d72 2
a73 2
		if (m_dwFileSize)
			m_dblPixelsPerByte = (double)m_iWidth / m_dwFileSize;
d77 1
a77 1
			m_dblBytesPerPixel = (double)m_dwFileSize / m_iWidth;
d84 1
a84 1
void CBarShader::SetFileSize(uint32 dwFileSize)
d86 1
a86 1
	if (m_dwFileSize != dwFileSize)
d88 3
a90 3
		m_dwFileSize = dwFileSize;
		if (m_dwFileSize)
			m_dblPixelsPerByte = static_cast<double>(m_iWidth) / m_dwFileSize;
d94 1
a94 1
			m_dblBytesPerPixel = static_cast<double>(m_dwFileSize) / m_iWidth;
d112 1
a112 1
void CBarShader::FillRange(uint32 start, uint32 end, COLORREF crColor)
d114 2
a115 2
	if(end > m_dwFileSize)
		end = m_dwFileSize;
d117 1
a117 1
	if(start >= end)
d119 1
a119 1
	POSITION endprev, endpos = m_Spans.FindFirstKeyAfter(end+1);
d130 1
a130 1
	if ((endcolor == crColor) && (m_Spans.GetKeyAt(endpos) <= end) && (endprev != NULL))
d133 1
a133 1
		endpos = m_Spans.SetAt(end, endcolor);
d135 1
a135 1
	for (POSITION pos = m_Spans.FindFirstKeyAfter(start); pos != endpos; )
d141 1
a141 1
	
d145 1
a145 1
		m_Spans.SetAt(start, crColor);
d152 1
a152 1
	m_Spans.SetAt(m_dwFileSize, 0);
d174 2
a175 2
	int iBytesInOnePixel = static_cast<int>(m_dblBytesPerPixel + 0.5);
	uint32 start = 0;
d180 2
a181 2
		uint32 uSpan = m_Spans.GetKeyAt(pos) - start;
		int iPixels = static_cast<int>(uSpan * m_dblPixelsPerByte + 0.5);
d188 1
a188 1
			start += static_cast<int>(iPixels * m_dblBytesPerPixel + 0.5);
d191 2
a192 1
			uint32 dwRed, dwGreen, dwBlue, dwLast = start, dwEnd = start + iBytesInOnePixel;
d195 1
a195 1
				double	dblWeight = (min(m_Spans.GetKeyAt(pos), dwEnd) - dwLast) * m_dblPixelsPerByte;
d199 1
a199 1
				if ((dwLast = m_Spans.GetKeyAt(pos)) >= dwEnd)
d219 1
a219 1
			start += iBytesInOnePixel;
d221 1
a221 1
		while((pos != NULL) && (m_Spans.GetKeyAt(pos) <= start))
@


1.28
log
@renamed 3 variables
@
text
@d106 1
a106 1
		if ((m_used3dlevel = g_App.g_pPrefs->Get3DDepth()) != 0)
d238 1
a238 1
		if ((m_used3dlevel != g_App.g_pPrefs->Get3DDepth() && !m_bIsPreview) || m_pdblModifiers == NULL)
d240 1
a240 1
			m_used3dlevel = g_App.g_pPrefs->Get3DDepth();
@


1.27
log
@Fixed crash while progress bar drawing {XAVI}; Minor optimization.
@
text
@d106 1
a106 1
		if ((m_used3dlevel = g_eMuleApp.m_pGlobPrefs->Get3DDepth()) != 0)
d238 1
a238 1
		if ((m_used3dlevel != g_eMuleApp.m_pGlobPrefs->Get3DDepth() && !m_bIsPreview) || m_pdblModifiers == NULL)
d240 1
a240 1
			m_used3dlevel = g_eMuleApp.m_pGlobPrefs->Get3DDepth();
@


1.26
log
@Added protection to correctly check 3DDepth parameter
(there could be memory access outside boundaries).
@
text
@d42 1
a50 3
	if (!m_bIsPreview) 
		m_used3dlevel = g_eMuleApp.m_pGlobPrefs->Get3DDepth();

d55 1
a55 1
	// m_pdblModifiers[count-1] will always be 1, m_pdblModifiers[0] depends on the value of depth
d58 1
a58 1
	int count = HALF(m_iHeight);
d61 1
a61 1
	double increment = piOverDepth / (count - 1);
d63 2
a64 2
	m_pdblModifiers = new double[count];
	for (int i = 0; i < count; i++, base += increment)
d106 2
a107 1
		BuildModifiers();
d155 1
a155 1
void CBarShader::DrawPreview(CDC* dc, int iLeft, int iTop, byte previewLevel)		//Cax2 aqua bar
d159 2
a160 1
	BuildModifiers();
d239 2
d242 1
@


1.25
log
@Fixed several rare progress bar glitches
(there were glitches for small file sizes and rare glitch of oversaturated color);
BarShader optimization to speed up progress bar drawing.
@
text
@d58 2
a59 2
	static const double dDepthes[5] = { 5.5, 4.0, 3.0, 2.50, 2.25 };		//aqua bar - smoother gradient jumps...
	double	depth = dDepthes[((m_used3dlevel > 10) ? (256 - m_used3dlevel) : m_used3dlevel) - 1];
d244 1
a244 1
		if (m_used3dlevel > 10)		//Cax2 aqua bar
@


1.24
log
@Optimized progress bar to properly merge neighbor segments for faster drawing.
@
text
@d53 1
a53 1
	// Barry - New property page slider to control depth of gradient
d58 2
a59 2
	double	depths[5] = { 1.5, 3.0, 4.0, 4.50, 4.75 };		//Cax2 aqua bar - smoother gradient jumps...
	double	depth = 7 - depths[((m_used3dlevel>10)?256-m_used3dlevel:m_used3dlevel) -1];		//Cax2 aqua bar
d61 2
a62 2
	double piOverDepth = PI/depth;
	double base = piOverDepth * (depth / 2 - 1);
d66 2
a67 2
	for (int i = 0; i < count; i++)
		m_pdblModifiers[i] = static_cast<double>(sin(base + i * increment));
d167 1
a167 1
	COLORREF crPrevBkColor = dc->GetBkColor();
d176 1
a176 1
	COLORREF m_crColor = m_Spans.GetNextValue(pos);
d178 2
a179 1
	while(pos != NULL && rectSpan.right < (iLeft + m_iWidth)) {
d182 1
d186 1
a186 1
			FillRect(dc, &rectSpan, m_crColor, bFlat);
d190 3
a192 5
			double dblRed = 0;
			double dblGreen = 0;
			double dblBlue = 0;
			uint32 iEnd = start + iBytesInOnePixel;
			int iLast = start;
d194 5
a198 5
				double	dblWeight = (min(m_Spans.GetKeyAt(pos), iEnd) - iLast) * m_dblPixelsPerByte;
				dblRed   += GetRValue(m_crColor) * dblWeight;
				dblGreen += GetGValue(m_crColor) * dblWeight;
				dblBlue  += GetBValue(m_crColor) * dblWeight;
				if(m_Spans.GetKeyAt(pos) > iEnd)
d200 1
a200 2
				iLast = m_Spans.GetKeyAt(pos);
				m_crColor = m_Spans.GetValueAt(pos);
d205 13
a217 1
			FillRect(dc, &rectSpan, dblRed, dblGreen, dblBlue, bFlat);
d220 8
a227 2
		while(pos != NULL && m_Spans.GetKeyAt(pos) < start)
			m_crColor = m_Spans.GetNextValue(pos);
a236 13
		FillRect(dc, rectSpan, GetRValue(crColor), GetGValue(crColor), GetBValue(crColor), false);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CBarShader::FillRect(CDC *dc, LPCRECT rectSpan, double dblRed, double dblGreen, double dblBlue, bool bFlat) 
{
	COLORREF crColor;

	if (bFlat)
	{
		crColor = RGB(static_cast<int>(dblRed + .5), static_cast<int>(dblGreen + .5), static_cast<int>(dblBlue + .5));
		dc->FillSolidRect(rectSpan, crColor);
	} 
	else 
d241 2
a242 1
		double	dblRed1, dblRed2, dblBlue1, dblBlue2, dblGreen1, dblGreen2;
d246 2
a247 7
			dblBlue2 = 1.0 - .025 * (256 - m_used3dlevel);		//variable central darkness - from 97.5% to 87.5% of the original colour...

			dblRed1 = dblGreen1 = dblBlue1 = 255;

			//dblRed1=(255 + dblRed)/2;

			dblRed2 = dblBlue2 * dblRed - dblRed1;
d249 3
a251 7
			//dblGreen1=(255 + dblGreen)/2;

			dblGreen2 = dblBlue2 * dblGreen - dblGreen1;

			//dblBlue1=(255 + dblBlue)/2;

			dblBlue2 = dblBlue2 * dblBlue - dblBlue1;
d254 1
a254 6
		{
			dblRed1 = dblGreen1 = dblBlue1 = .5;
			dblRed2 = dblRed;
			dblGreen2 = dblGreen;
			dblBlue2 = dblBlue;
		}
d265 3
a267 3
			crColor = RGB( static_cast<int>(dblRed1 + dblRed2 * *pdCurr),
				static_cast<int>(dblGreen1 + dblGreen2 * *pdCurr),
				static_cast<int>(dblBlue1 + dblBlue2 * *pdCurr) );
@


1.23
log
@Improved BarShader constructor/destructor.
@
text
@d120 1
a120 1
	POSITION endpos = m_Spans.FindFirstKeyAfter(end+1);
d122 1
a122 1
	if (endpos)
a129 1
	endpos = m_Spans.SetAt(end, endcolor);
d131 7
a137 1
	for (POSITION pos = m_Spans.FindFirstKeyAfter(start+1); pos != endpos; ) {
d145 1
a145 1
	if (m_Spans.GetValueAt(endpos) != crColor)
@


1.22
log
@Minor correction for the previous change.
@
text
@d23 1
a23 1
CBarShader::CBarShader(uint32 dwHeight, uint32 dwWidth, uint32 dwFileSize /*= 1*/)
d28 2
a29 1
	m_Spans.SetAt(0, 0);
d31 1
a31 1
	m_bIsPreview=false;
a38 1
	m_Spans.RemoveAll();
a40 3
void CBarShader::Reset() {
	Fill(0);
}
@


1.21
log
@Improved BarShader to speed up progress bar drawing.
@
text
@d165 1
d210 1
@


1.20
log
@Fixed progress bar for 1 byte files; Improved BarShared constructor.
@
text
@a16 1
// Barry
d35 2
a36 1
CBarShader::~CBarShader(void) {
d73 2
a74 1
void CBarShader::SetWidth(int width) {
d147 2
a148 1
void CBarShader::Fill(COLORREF crColor) {
d172 3
a174 3
	uint32 start = 0;//bsCurrent->m_dwStartOffset;
	COLORREF m_crColor = m_Spans.GetValueAt(pos);
	m_Spans.GetNext(pos);
d206 2
a207 4
		while(pos != NULL && m_Spans.GetKeyAt(pos) < start) {
			m_crColor = m_Spans.GetValueAt(pos);
			m_Spans.GetNext(pos);
		}
d211 1
a211 1
void CBarShader::FillRect(CDC *dc, LPRECT rectSpan, COLORREF crColor, bool bFlat)
d214 1
a214 6
	{
		CBrush gdiBrush(crColor);
		CBrush* pOldBrush = dc->SelectObject(&gdiBrush);	//eklmn: select a new brush
		dc->FillRect(rectSpan, &gdiBrush);
		dc->SelectObject(pOldBrush);		//eklmn: recover an old brush
	}
d219 1
a219 1
void CBarShader::FillRect(CDC *dc, LPRECT rectSpan, double dblRed, double dblGreen, double dblBlue, bool bFlat) 
d221 3
a223 2
	CBrush		   *pOldBrush;
	if (bFlat) 
d225 2
a226 6
		COLORREF crColor = RGB(static_cast<int>(dblRed + .5), static_cast<int>(dblGreen + .5), static_cast<int>(dblBlue + .5));

		CBrush		gdiBrush(crColor);
		pOldBrush = dc->SelectObject(&gdiBrush);
		dc->FillRect(rectSpan, &gdiBrush);
		dc->SelectObject(pOldBrush);
d233 1
a233 6
		RECT		rect = *rectSpan;

		int		iTop = rect.top;
		int		iBot = rect.bottom;
		int		iMax = HALF(m_iHeight);
		double	dblRed1,dblRed2,dblBlue1,dblBlue2,dblGreen1,dblGreen2;
d260 9
a268 1
		for (int i = 0; i < iMax; i++) 
d270 11
a280 13
			CBrush		cbNew(RGB( static_cast<int>(dblRed1 + dblRed2*m_pdblModifiers[i]),
								   static_cast<int>(dblGreen1 + dblGreen2*m_pdblModifiers[i]),
								   static_cast<int>(dblBlue1 + dblBlue2*m_pdblModifiers[i]) ));

			pOldBrush = dc->SelectObject(&cbNew);
			rect.top = iTop + i;
			rect.bottom = iTop + i + 1;
			dc->FillRect(&rect, &cbNew);

			rect.top = iBot - i - 1;
			rect.bottom = iBot - i;
			dc->FillRect(&rect, &cbNew);
			dc->SelectObject(pOldBrush);
@


1.19
log
@minor memory copy improvements
@
text
@d1 1
a1 1
#include "StdAfx.h"
d3 1
a3 1
#include "barshader.h"
d24 1
a24 1
CBarShader::CBarShader(uint32 height, uint32 width) 
d26 3
a28 3
	m_iWidth = width;
	m_iHeight = height;
	m_dwFileSize = 1;
d33 1
d154 1
a154 1
	m_bIsPreview=true;
d157 2
a158 2
	Draw( dc, iLeft, iTop, (previewLevel==0));
	m_bIsPreview=false;
d161 2
a162 1
void CBarShader::Draw(CDC* dc, int iLeft, int iTop, bool bFlat) {
d211 2
a212 1
void CBarShader::FillRect(CDC *dc, LPRECT rectSpan, COLORREF crColor, bool bFlat) {
@


1.18
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d238 1
a238 3
		RECT		rect;

		memcpy2(&rect, rectSpan, sizeof(RECT));
@


1.17
log
@forgotten variable init & type correction
@
text
@d151 1
a151 1
void CBarShader::DrawPreview(CDC* dc, int iLeft, int iTop, uint8 previewLevel)		//Cax2 aqua bar
@


1.16
log
@speed improvements on the bar shader (from official v0.30c) + possible division by zero bug fix
@
text
@d24 2
a25 1
CBarShader::CBarShader(uint32 height, uint32 width) {
d32 1
d53 1
a53 1
		m_used3dlevel=g_eMuleApp.m_pGlobPrefs->Get3DDepth();
d154 1
a154 1
	m_used3dlevel=previewLevel;
@


1.15
log
@Formatting, comments, and name changes.
@
text
@d28 1
a28 1
	m_FirstSpan = new BarSpan(0, 1);
d35 1
a35 2
	m_FirstSpan->DeleteUpTo(NULL);
	delete m_FirstSpan;
d45 1
d47 2
d69 15
d90 18
a107 2
		m_dblPixelsPerByte = static_cast<double>(m_iWidth) / m_dwFileSize;
		m_dblBytesPerPixel = static_cast<double>(m_dwFileSize) / m_iWidth;
d110 1
d119 1
d121 4
a124 18
	BarSpan *bsPrev, *bsStart, *bsEnd;
	bsPrev = bsStart = m_FirstSpan;
	while(bsStart->next != NULL && bsStart->m_dwEndOffset < start)
		bsStart = bsStart->next;

	//place new span, unless it's the same color
	BarSpan *bsNew;

	//case 0, same color
	if(bsStart->m_crColor == crColor) {

		//same color, ends before end.
		if(bsStart->m_dwEndOffset > end)
			return;

		//case 1, same color, ends after end.
		bsNew = bsStart;
		bsNew->m_dwEndOffset = end;
d126 1
a126 3
	}
	
	else if(bsStart->m_dwStartOffset == start) {
d128 2
a129 16
		//case 2, begins at start, ends before end.
		if(bsStart->m_dwEndOffset > end) {
			//the 'ol switcheroo
			bsNew = new BarSpan(bsStart, end, bsStart->m_dwEndOffset, bsStart->m_crColor);
			bsStart->m_dwEndOffset = end;
			bsStart->m_crColor = crColor;
			return;
		}

		//case 3, begins at start, ends after end.
		else {
			//hostile takeover
			bsNew = bsStart;
			bsNew->m_dwEndOffset = end;
			bsNew->m_crColor = crColor;
		}
d131 4
d136 2
d139 2
a140 28
	else if(bsStart->m_dwStartOffset < start) {

		//case 4, begins after start, ends before end
		if(bsStart->m_dwEndOffset > end) {
			bsNew = new BarSpan(bsStart, start, end, crColor);
			bsNew = new BarSpan(bsNew, end, bsStart->m_dwEndOffset, bsStart->m_crColor);
			bsStart->m_dwEndOffset = start;
			return;
		}

		//case 5, begins after start, ends after end
		else {
			bsNew = new BarSpan(bsStart, start, end, crColor);
			bsStart->m_dwEndOffset = start;
		}
	} else {
		ASSERT(FALSE);//should never get here
		return;
	}

	bsEnd = bsNew->next;
	while(bsEnd != NULL && bsEnd->m_dwEndOffset <= end)
		bsEnd = bsEnd->next;

	if(bsEnd != NULL)
		bsEnd->m_dwStartOffset = end;

	bsNew->DeleteUpTo(bsEnd);
d144 3
a146 4
	m_FirstSpan->DeleteUpTo(NULL);
	m_FirstSpan->m_dwStartOffset = 0;
	m_FirstSpan->m_dwEndOffset = m_dwFileSize;
	m_FirstSpan->m_crColor = crColor;
d159 1
a159 1
	BarSpan *bsCurrent = m_FirstSpan;
d167 4
a170 2
	while(bsCurrent != NULL && rectSpan.right < (iLeft + m_iWidth)) {
		uint32 uSpan = bsCurrent->m_dwEndOffset - start;
d175 1
a175 1
			FillRect(dc, &rectSpan, bsCurrent->m_crColor, bFlat);
d185 5
a189 5
				double	dblWeight = (min(bsCurrent->m_dwEndOffset, iEnd) - iLast) * m_dblPixelsPerByte;
				dblRed   += GetRValue(bsCurrent->m_crColor) * dblWeight;
				dblGreen += GetGValue(bsCurrent->m_crColor) * dblWeight;
				dblBlue  += GetBValue(bsCurrent->m_crColor) * dblWeight;
				if(bsCurrent->m_dwEndOffset > iEnd)
d191 4
a194 3
				iLast = bsCurrent->m_dwEndOffset;
				bsCurrent = bsCurrent->next;
			} while(bsCurrent != NULL);
d200 4
a203 2
		while(bsCurrent != NULL && bsCurrent->m_dwEndOffset < start)
			bsCurrent = bsCurrent->next;
a220 1
	COLORREF		crColor;
a221 1

d224 1
a224 1
		crColor = RGB(static_cast<int>(dblRed + .5), static_cast<int>(dblGreen + .5), static_cast<int>(dblBlue + .5));
a226 1

@


1.14
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d88 1
a88 1
	while(bsStart->next != NULL && bsStart->end < start)
d98 1
a98 1
		if(bsStart->end > end)
d103 1
a103 1
		bsNew->end = end;
d107 1
a107 1
	else if(bsStart->start == start) {
d110 1
a110 1
		if(bsStart->end > end) {
d112 2
a113 2
			bsNew = new BarSpan(bsStart, end, bsStart->end, bsStart->m_crColor);
			bsStart->end = end;
d122 1
a122 1
			bsNew->end = end;
d128 1
a128 1
	else if(bsStart->start < start) {
d131 1
a131 1
		if(bsStart->end > end) {
d133 2
a134 2
			bsNew = new BarSpan(bsNew, end, bsStart->end, bsStart->m_crColor);
			bsStart->end = start;
d141 1
a141 1
			bsStart->end = start;
d149 1
a149 1
	while(bsEnd != NULL && bsEnd->end <= end)
d153 1
a153 1
		bsEnd->start = end;
d160 2
a161 2
	m_FirstSpan->start = 0;
	m_FirstSpan->end = m_dwFileSize;
d182 1
a182 1
	uint32 start = 0;//bsCurrent->start;
d184 1
a184 1
		uint32 uSpan = bsCurrent->end - start;
d199 1
a199 1
				double	dblWeight = (min(bsCurrent->end, iEnd) - iLast) * m_dblPixelsPerByte;
d203 1
a203 1
				if(bsCurrent->end > iEnd)
d205 1
a205 1
				iLast = bsCurrent->end;
d213 1
a213 1
		while(bsCurrent != NULL && bsCurrent->end < start)
@


1.13
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d27 1
a27 1
	m_uFileSize = 1;
d29 2
a30 2
	m_Modifiers = NULL;
	m_IsPreview=false;
d34 1
a34 1
	delete[] m_Modifiers;
d42 5
d48 1
a48 4
void CBarShader::BuildModifiers() {
	if(m_Modifiers != NULL)
		delete[] m_Modifiers;
	if(!m_IsPreview) 
d55 3
a57 3
	// m_Modifiers[count-1] will always be 1, m_Modifiers[0] depends on the value of depth
	float depths[5] = { 1.5f, 3.0f, 4.0f, 4.50f, 4.75f };		//Cax2 aqua bar - smoother gradient jumps...
	float depth = 7 - depths[((m_used3dlevel>10)?256-m_used3dlevel:m_used3dlevel) -1];		//Cax2 aqua bar
d63 1
a63 1
	m_Modifiers = new float[count];
d65 1
a65 1
		m_Modifiers[i] = (float)(sin(base + i * increment));
d67 8
a74 6

void CBarShader::SetFileSize(uint32 fileSize) {
	if(m_uFileSize != fileSize) {
		m_uFileSize = fileSize;
		m_dPixelsPerByte = (double)m_iWidth / m_uFileSize;
		m_dBytesPerPixel = (double)m_uFileSize / m_iWidth;
d77 5
a81 4

void CBarShader::FillRange(uint32 start, uint32 end, COLORREF crColor) {
	if(end > m_uFileSize)
		end = m_uFileSize;
d161 1
a161 1
	m_FirstSpan->end = m_uFileSize;
d167 1
a167 1
	m_IsPreview=true;
d171 1
a171 1
	m_IsPreview=false;
d181 1
a181 1
	int iBytesInOnePixel = (int)(m_dBytesPerPixel + 0.5f);
d185 1
a185 1
		int iPixels = (int)(uSpan * m_dPixelsPerByte + 0.5f);
d191 1
a191 1
			start += (int)(iPixels * m_dBytesPerPixel + 0.5f);
d193 3
a195 3
			float fRed = 0;
			float fGreen = 0;
			float fBlue = 0;
d199 4
a202 4
				float fWeight = (min(bsCurrent->end, iEnd) - iLast) * m_dPixelsPerByte;
				fRed   += GetRValue(bsCurrent->m_crColor) * fWeight;
				fGreen += GetGValue(bsCurrent->m_crColor) * fWeight;
				fBlue  += GetBValue(bsCurrent->m_crColor) * fWeight;
d210 1
a210 1
			FillRect(dc, &rectSpan, fRed, fGreen, fBlue, bFlat);
d229 5
d235 1
a235 6
void CBarShader::FillRect(CDC *dc, LPRECT rectSpan, float fRed, float fGreen,
						  float fBlue, bool bFlat) 
{
	COLORREF crColor;
	CBrush* pOldBrush;
	if(bFlat) 
d237 1
a237 5
		crColor = RGB((int)(fRed + .5f), (int)(fGreen + .5f), (int)(fBlue + .5f));
		CBrush gdiBrush(crColor);
		pOldBrush = dc->SelectObject(&gdiBrush);	//eklmn: select a new brush
		dc->FillRect(rectSpan, &gdiBrush);
		dc->SelectObject(pOldBrush);		//eklmn: recover an old brush
d239 1
d241 3
d247 1
a247 1
		if (( m_used3dlevel!=g_eMuleApp.m_pGlobPrefs->Get3DDepth()&& !m_IsPreview) || m_Modifiers == NULL)
d249 3
a251 1
		RECT rect;
d253 7
a259 5
		int iTop = rect.top;
		int iBot = rect.bottom;
		int iMax = HALF(m_iHeight);
		float red1,red2,blue1,blue2,green1,green2;
		if (m_used3dlevel>10)		//Cax2 aqua bar
d261 15
a275 8
			blue2=1-.025*(256-m_used3dlevel);		//variable central darkness - from 97.5% to 87.5% of the original colour...
			red1=green1=blue1=255;
			//red1=(255 + fRed)/2;
			red2=blue2*fRed-red1;
			//green1=(255 + fGreen)/2;
			green2=blue2*fGreen-green1;
			//blue1=(255 + fBlue)/2;
			blue2=blue2*fBlue-blue1;
d279 4
a282 4
			red1=green1=blue1=.5f;
			red2=fRed;
			green2=fGreen;
			blue2=fBlue;
d284 1
a284 1
		for(int i = 0; i < iMax; i++) 
d286 5
a290 2
			CBrush cbNew(RGB((int)(red1 + red2*m_Modifiers[i]), (int)(green1 + green2*m_Modifiers[i]), (int)(blue1 + blue2*m_Modifiers[i])));
			pOldBrush = dc->SelectObject(&cbNew);	//eklmn: select a new brush in device context
d298 1
a298 1
			dc->SelectObject(pOldBrush);	//eklmn: recover a previous state
d302 1
@


1.12
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d5 1
a5 1
#include "memcpy_amd.h"
@


1.11
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d215 6
a220 1
		dc->FillRect(rectSpan, &CBrush(crColor));
d229 3
a231 1
	if(bFlat) {
d233 4
a236 1
		dc->FillRect(rectSpan, &CBrush(crColor));
d238 4
a241 1
	} else {
d268 2
a269 1
		for(int i = 0; i < iMax; i++) {
d271 1
d279 1
@


1.10
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d232 1
a232 5
		#ifndef AMD
		memcpy(&rect, rectSpan, sizeof(RECT));
		#else
		memcpy_amd(&rect, rectSpan, sizeof(RECT));
		#endif
@


1.9
log
@Second batch of name changes
@
text
@d47 1
a47 1
		m_used3dlevel=theApp.glob_prefs->Get3DDepth();
d229 1
a229 1
		if (( m_used3dlevel!=theApp.glob_prefs->Get3DDepth()&& !m_IsPreview) || m_Modifiers == NULL)
@


1.8
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d74 1
a74 1
void CBarShader::FillRange(uint32 start, uint32 end, COLORREF color) {
d90 1
a90 1
	if(bsStart->color == color) {
d107 1
a107 1
			bsNew = new BarSpan(bsStart, end, bsStart->end, bsStart->color);
d109 1
a109 1
			bsStart->color = color;
d118 1
a118 1
			bsNew->color = color;
d127 2
a128 2
			bsNew = new BarSpan(bsStart, start, end, color);
			bsNew = new BarSpan(bsNew, end, bsStart->end, bsStart->color);
d135 1
a135 1
			bsNew = new BarSpan(bsStart, start, end, color);
d153 1
a153 1
void CBarShader::Fill(COLORREF color) {
d157 1
a157 1
	m_FirstSpan->color = color;
d184 1
a184 1
			FillRect(dc, &rectSpan, bsCurrent->color, bFlat);
d195 3
a197 3
				fRed   += GetRValue(bsCurrent->color) * fWeight;
				fGreen += GetGValue(bsCurrent->color) * fWeight;
				fBlue  += GetBValue(bsCurrent->color) * fWeight;
d213 3
a215 3
void CBarShader::FillRect(CDC *dc, LPRECT rectSpan, COLORREF color, bool bFlat) {
	if(!color || bFlat)
		dc->FillRect(rectSpan, &CBrush(color));
d217 1
a217 1
		FillRect(dc, rectSpan, GetRValue(color), GetGValue(color), GetBValue(color), false);
d223 1
a223 1
	COLORREF color;
d225 2
a226 2
		color = RGB((int)(fRed + .5f), (int)(fGreen + .5f), (int)(fBlue + .5f));
		dc->FillRect(rectSpan, &CBrush(color));
@


1.7
log
@minor fixes and improvements
@
text
@d5 1
d232 1
d234 3
@


1.6
log
@Code clean up and double check wit official code.
@
text
@d139 1
@


1.5
log
@minor improvements
@
text
@a11 2


@


1.4
log
@minor bugfixes + aqua bars! :)
@
text
@d31 1
d47 2
a48 1
	m_used3dlevel=theApp.glob_prefs->Get3DDepth();
d55 2
a56 1
	int depth = (7-((m_used3dlevel>10)?abs(m_used3dlevel-256):m_used3dlevel));		//Cax2 innie bar
d59 1
a59 1
	double base = piOverDepth * ((depth / 2.0) - 1);
d160 9
d229 1
a229 1
		if (m_Modifiers == NULL || m_used3dlevel!=theApp.glob_prefs->Get3DDepth())
d239 15
a253 6
			red1=(255 + fRed)/2;
			red2=.8*fRed-red1;
			green1=(255 + fGreen)/2;
			green2=.8*fGreen-green1;
			blue1=(255 + fBlue)/2;
			blue2=.8*fBlue-blue1;
d256 1
a256 7
			if (m_used3dlevel>10)		//Cax2 aqua bar
			{
				color=RGB((int)(red1 + red2*m_Modifiers[i]), (int)(green1 + green2*m_Modifiers[i]), (int)(blue1 + blue2*m_Modifiers[i]));
			}
			else
				color=RGB((int)(fRed * m_Modifiers[i] + .5f), (int)(fGreen * m_Modifiers[i] + .5f), (int)(fBlue * m_Modifiers[i] + .5f));
			CBrush cbNew(color);
@


1.3
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d46 1
a47 1
	m_used3dlevel=theApp.glob_prefs->Get3DDepth();
d53 1
a53 2
	
	int depth = (7-theApp.glob_prefs->Get3DDepth());
d209 3
a211 1
						  float fBlue, bool bFlat) {
d213 1
a213 1
		COLORREF color = RGB((int)(fRed + .5f), (int)(fGreen + .5f), (int)(fBlue + .5f));
d224 10
d235 7
a241 2
			CBrush cbNew(RGB((int)(fRed * m_Modifiers[i] + .5f), (int)(fGreen * m_Modifiers[i] + .5f), (int)(fBlue * m_Modifiers[i] + .5f)));
			
@


1.2
log
@*** empty log message ***
@
text
@d6 8
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d2 1
d10 5
a22 1
	BuildModifiers();
d39 8
d48 4
d53 2
a54 4
	double perLine = M_PI_2 / (count + 0.55);
	for(int i = 0; i < count; i++) {
		m_Modifiers[i] = (float)(sin((perLine * (i + 0.55))));
	}
d208 2
@

