head	1.5;
access;
symbols
	PublicRelease_1_2e:1.5
	Interim_Release_1-2e_RC1:1.5
	PublicRelease_1_2d:1.5
	Interim_Release_1-2d_RC1:1.5
	Interim_Release_1-2d_beta1:1.5
	PublicRelease_1_2c:1.5
	Interim_Release_1-2c_RC1:1.5
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.3
	Interim_Release_1o_RC1:1.3
	Interim_Release_1o_beta1:1.3
	PublicRelease_1n:1.3
	Interim_Release_1n_RC2:1.3
	Interim_Release_1n_RC1:1.3
	Interim_Release_1n_beta2:1.3
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.3
	Interim_Release_1l_RC1:1.3
	Interim_Release_1l_beta2:1.3
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.3
	Interim_Release_1k_RC4:1.3
	Interim_1k_RC3:1.3
	Interim_1k_RC2:1.3
	Interim_Release_1k_RC1:1.3
	Interim_Release_1k_beta5:1.3
	Intrerim_Release_1k_beta4:1.3
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.3
	Interim_Release_1i_RC2:1.3
	Interim_Release_1i_RC1:1.3
	Interim_Release_1i_beta3:1.3
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.3
	Interim_Release_1g_beta1:1.3
	Interim_Release_1f_RC4:1.3
	Interim_Release_1f_RC3:1.3
	Interim_Release_1f_RC2:1.3
	Interim_Release_1f_RC:1.3
	Interim_Release_1f_beta2:1.3
	Interim_Release_1f_beta1:1.3
	PublicRelease_1e:1.3
	Interim_Release_1e_RC2:1.3
	Interim_Release_1e_RC:1.3
	Interim_Release_1e_beta3:1.3
	Interim_Release_1e_beta2:1.3
	Interim_Release_1e_beta2_before_kuchin:1.3
	Interim_Release_1e_beta1:1.3
	PublicRelease_1c:1.3
	featurestest:1.3.0.8
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.6
	PublicRelease_1b:1.3
	Interim_Release_1b_beta2:1.3
	Interim_Release_1b_beta1:1.3
	proxydeadlake:1.3.0.4
	PublicRelease_1a:1.3
	Interim_Release_1a_beta2:1.3
	BerkeleyDb:1.3.0.2
	Interim_Release_1a_beta1:1.3
	PublicRelease_1:1.3
	goldfish:1.3
	eMulePlus_1_RC2:1.3
	eMulePlus_26b_1RC1:1.3
	PreRelease_26b_i0e:1.3
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.3
	systraydlg:1.1.0.2;
locks; strict;
comment	@// @;


1.5
date	2007.04.03.19.01.35;	author kush_eplus;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.05.23.10.07;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.13.18.52.40;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.12.17.06.28;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.05.23.16.43;	author forcha;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.02.05.23.16.43;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Remove unrequired initialization;
Minor code cleanup.
@
text
@// TrayMenuBtn.cpp : implementation file
//

#include "stdafx.h"
#include "TrayMenuBtn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTrayMenuBtn

CTrayMenuBtn::CTrayMenuBtn()
{
	m_bMouseOver = false;
	m_bNoHover = false;
	m_bUseIcon = false;
	m_bParentCapture = false;
	m_hIcon = NULL;
	m_nBtnID = 0;
	m_sIcon.cx = 0;
	m_sIcon.cy = 0;
}

CTrayMenuBtn::~CTrayMenuBtn()
{
	if (m_hIcon != NULL)
		DestroyIcon(m_hIcon);
}


BEGIN_MESSAGE_MAP(CTrayMenuBtn, CWnd)
	//{{AFX_MSG_MAP(CTrayMenuBtn)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrayMenuBtn message handlers

void CTrayMenuBtn::OnMouseMove(UINT nFlags, CPoint point) 
{
	CRect	rClient;

	GetClientRect(rClient);

	if ( point.x >= rClient.left && point.x <= rClient.right
		&& point.y >= rClient.top && point.y <= rClient.bottom )
	{
		SetCapture();

		if (!m_bNoHover)
			m_bMouseOver = true;
		Invalidate();
	}
	else
	{
		CWnd	*pParent;

		if (m_bParentCapture && (pParent = GetParent()) != NULL)
			pParent->SetCapture();
		else
			ReleaseCapture();

		m_bMouseOver = false;
		Invalidate();
	}
	
	CWnd::OnMouseMove(nFlags, point);
}

void CTrayMenuBtn::OnLButtonUp(UINT nFlags, CPoint point) 
{
	CRect	rClient;

	GetClientRect(rClient);

	if (point.x >= rClient.left && point.x <= rClient.right
		&& point.y >= rClient.top && point.y <= rClient.bottom )
	{
		CWnd	*pParent = GetParent();

		if (pParent != NULL)
			pParent->PostMessage(WM_COMMAND, MAKEWPARAM(m_nBtnID, BN_CLICKED), reinterpret_cast<LPARAM>(m_hWnd));
	}
	else
	{
		ReleaseCapture();
		m_bMouseOver = false;
		Invalidate();
	}		
	
	CWnd::OnLButtonUp(nFlags, point);
}

void CTrayMenuBtn::OnPaint() 
{
	CPaintDC	dc(this); // device context for painting
	CRect		rClient;

	GetClientRect(rClient);

	CDC	MemDC;

	MemDC.CreateCompatibleDC(&dc);

	CBitmap	MemBMP, *pOldBMP;

	MemBMP.CreateCompatibleBitmap(&dc, rClient.Width(), rClient.Height());
	pOldBMP = MemDC.SelectObject(&MemBMP);

	CFont	*pOldFONT = NULL;

	if (m_cfFont.GetSafeHandle())
		pOldFONT = MemDC.SelectObject(&m_cfFont);

	BOOL	bEnabled = IsWindowEnabled();

	if (m_bMouseOver && bEnabled)
	{	
		FillRect(MemDC.m_hDC, rClient, GetSysColorBrush(COLOR_HIGHLIGHT));
		MemDC.SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
	}
	else
	{
		FillRect(MemDC.m_hDC, rClient, GetSysColorBrush(COLOR_BTNFACE));
		MemDC.SetTextColor(GetSysColor(COLOR_BTNTEXT));
	}

	int	iLeftOffset = 0;

	if (m_bUseIcon)
	{		
		MemDC.DrawState(
				CPoint(2, (rClient.Height() >> 1) - (m_sIcon.cy >> 1)),
				CSize(16, 16), m_hIcon, DST_ICON | DSS_NORMAL, reinterpret_cast<HBRUSH>(NULL) );
		iLeftOffset = m_sIcon.cx + 4;
	}

	MemDC.SetBkMode(TRANSPARENT);

	CRect	rText(0, 0, 0, 0);

	MemDC.DrawText(m_strText, rText, DT_CALCRECT | DT_SINGLELINE | DT_LEFT);

	CPoint	pt(rClient.left + 2 + iLeftOffset, (rClient.Height() >> 1) - (rText.Height() >> 1));
	CPoint	sz(rText.Width(), rText.Height());

	MemDC.DrawState( pt, sz, m_strText, DST_TEXT | (bEnabled ? DSS_NORMAL : DSS_DISABLED), 
		FALSE, m_strText.GetLength(), reinterpret_cast<HBRUSH>(NULL) );

	dc.BitBlt(0, 0, rClient.Width(), rClient.Height(), &MemDC, 0, 0, SRCCOPY);
	MemDC.SelectObject(pOldBMP);

	if (pOldFONT != NULL)
		MemDC.SelectObject(pOldFONT);
}
@


1.4
log
@Removed unused class member; Faster constructor; Removed rand() initialization.
@
text
@d16 1
a16 1
CTrayMenuBtn::CTrayMenuBtn() : m_strText(_T(""))
d30 1
a30 1
	if(m_hIcon)
d48 2
a49 1
	CRect rClient;
d52 2
a53 2
	if(point.x >= rClient.left && point.x <= rClient.right &&
		point.y >= rClient.top && point.y <= rClient.bottom)
d57 1
a57 1
		if(!m_bNoHover)
d63 4
a66 8
		if(m_bParentCapture)
		{
			CWnd *pParent = GetParent();
			if(pParent)
				pParent->SetCapture();
			else
				ReleaseCapture();
		}
d79 2
a80 1
	CRect rClient;
d83 2
a84 2
	if(point.x >= rClient.left && point.x <= rClient.right &&
		point.y >= rClient.top && point.y <= rClient.bottom)
d86 4
a89 3
		CWnd *pParent = GetParent();
		if(pParent)
			pParent->PostMessage(WM_COMMAND, MAKEWPARAM(m_nBtnID,BN_CLICKED), (long)m_hWnd);
d103 3
a105 3
	CPaintDC dc(this); // device context for painting
		
	CRect rClient;
d108 2
a109 1
	CDC MemDC;
d111 3
a113 1
	CBitmap MemBMP, *pOldBMP;
d116 4
a119 2
	CFont *pOldFONT = NULL;
	if(m_cfFont.GetSafeHandle())
d122 1
a122 1
	BOOL bEnabled = IsWindowEnabled();
d124 1
a124 1
	if(m_bMouseOver && bEnabled)
d135 3
a137 2
	int iLeftOffset = 0;
	if(m_bUseIcon)
d139 3
a141 1
		MemDC.DrawState(CPoint(2,rClient.Height()/2-m_sIcon.cy/2),CSize(16,16),m_hIcon,DST_ICON|DSS_NORMAL,(CBrush*)NULL);
a145 7
	CRect rText(0,0,0,0);
	MemDC.DrawText(m_strText, rText, DT_CALCRECT|DT_SINGLELINE|DT_LEFT);
	//CPoint pt((rClient.Width()>>1)-(rText.Width()>>1),(rClient.Height()>>1)-(rText.Height()>>1));
	CPoint pt(rClient.left+2+iLeftOffset, rClient.Height()/2-rText.Height()/2);
	CPoint sz(rText.Width(),rText.Height());
	MemDC.DrawState(pt, sz, m_strText, DST_TEXT | (bEnabled ? DSS_NORMAL : DSS_DISABLED), 
						FALSE, m_strText.GetLength(), (CBrush*)NULL);  			
d147 11
a157 1
	dc.BitBlt(0,0,rClient.Width(),rClient.Height(),&MemDC,0,0,SRCCOPY);
d159 2
a160 1
	if(pOldFONT)
@


1.3
log
@*** empty log message ***
@
text
@d16 1
a16 1
CTrayMenuBtn::CTrayMenuBtn()
a17 1
	m_bBold = false;
d23 1
a23 1
	m_nBtnID = rand();
a25 1
	m_strText = "";
@


1.2
log
@new systray menu + small bugfix
@
text
@d92 1
a92 1
			pParent->SendMessage(WM_COMMAND, MAKEWPARAM(m_nBtnID,BN_CLICKED), (long)m_hWnd);
@


1.1
log
@file TrayMenuBtn.cpp was initially added on branch systraydlg.
@
text
@d1 153
@


1.1.2.1
log
@*** empty log message ***
@
text
@a0 153
// TrayMenuBtn.cpp : implementation file
//

#include "stdafx.h"
#include "TrayMenuBtn.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTrayMenuBtn

CTrayMenuBtn::CTrayMenuBtn()
{
	m_bBold = false;
	m_bMouseOver = false;
	m_bNoHover = false;
	m_bUseIcon = false;
	m_bParentCapture = false;
	m_hIcon = NULL;
	m_nBtnID = rand();
	m_sIcon.cx = 0;
	m_sIcon.cy = 0;
	m_strText = "";
}

CTrayMenuBtn::~CTrayMenuBtn()
{
	if(m_hIcon)
		DestroyIcon(m_hIcon);
}


BEGIN_MESSAGE_MAP(CTrayMenuBtn, CWnd)
	//{{AFX_MSG_MAP(CTrayMenuBtn)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrayMenuBtn message handlers

void CTrayMenuBtn::OnMouseMove(UINT nFlags, CPoint point) 
{
	CRect rClient;
	GetClientRect(rClient);

	if(point.x >= rClient.left && point.x <= rClient.right &&
		point.y >= rClient.top && point.y <= rClient.bottom)
	{
		SetCapture();

		if(!m_bNoHover)
			m_bMouseOver = true;
		Invalidate();
	}
	else
	{
		if(m_bParentCapture)
		{
			CWnd *pParent = GetParent();
			if(pParent)
				pParent->SetCapture();
			else
				ReleaseCapture();
		}
		else
			ReleaseCapture();

		m_bMouseOver = false;
		Invalidate();
	}
	
	CWnd::OnMouseMove(nFlags, point);
}

void CTrayMenuBtn::OnLButtonUp(UINT nFlags, CPoint point) 
{
	CRect rClient;
	GetClientRect(rClient);

	if(point.x >= rClient.left && point.x <= rClient.right &&
		point.y >= rClient.top && point.y <= rClient.bottom)
	{
		CWnd *pParent = GetParent();
		if(pParent)
			pParent->SendMessage(WM_COMMAND, MAKEWPARAM(m_nBtnID,BN_CLICKED), (long)m_hWnd);
	}
	else
	{
		ReleaseCapture();
		m_bMouseOver = false;
		Invalidate();
	}		
	
	CWnd::OnLButtonUp(nFlags, point);
}

void CTrayMenuBtn::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
		
	CRect rClient;
	GetClientRect(rClient);

	CDC MemDC;
	MemDC.CreateCompatibleDC(&dc);
	CBitmap MemBMP, *pOldBMP;
	MemBMP.CreateCompatibleBitmap(&dc, rClient.Width(), rClient.Height());
	pOldBMP = MemDC.SelectObject(&MemBMP);
	CFont *pOldFONT = NULL;
	if(m_cfFont.GetSafeHandle())
		pOldFONT = MemDC.SelectObject(&m_cfFont);

	BOOL bEnabled = IsWindowEnabled();

	if(m_bMouseOver && bEnabled)
	{	
		FillRect(MemDC.m_hDC, rClient, GetSysColorBrush(COLOR_HIGHLIGHT));
		MemDC.SetTextColor(GetSysColor(COLOR_HIGHLIGHTTEXT));
	}
	else
	{
		FillRect(MemDC.m_hDC, rClient, GetSysColorBrush(COLOR_BTNFACE));
		MemDC.SetTextColor(GetSysColor(COLOR_BTNTEXT));
	}

	int iLeftOffset = 0;
	if(m_bUseIcon)
	{		
		MemDC.DrawState(CPoint(2,rClient.Height()/2-m_sIcon.cy/2),CSize(16,16),m_hIcon,DST_ICON|DSS_NORMAL,(CBrush*)NULL);
		iLeftOffset = m_sIcon.cx + 4;
	}

	MemDC.SetBkMode(TRANSPARENT);
	CRect rText(0,0,0,0);
	MemDC.DrawText(m_strText, rText, DT_CALCRECT|DT_SINGLELINE|DT_LEFT);
	//CPoint pt((rClient.Width()>>1)-(rText.Width()>>1),(rClient.Height()>>1)-(rText.Height()>>1));
	CPoint pt(rClient.left+2+iLeftOffset, rClient.Height()/2-rText.Height()/2);
	CPoint sz(rText.Width(),rText.Height());
	MemDC.DrawState(pt, sz, m_strText, DST_TEXT | (bEnabled ? DSS_NORMAL : DSS_DISABLED), 
						FALSE, m_strText.GetLength(), (CBrush*)NULL);  			

	dc.BitBlt(0,0,rClient.Width(),rClient.Height(),&MemDC,0,0,SRCCOPY);
	MemDC.SelectObject(pOldBMP);
	if(pOldFONT)
		MemDC.SelectObject(pOldFONT);
}
@

