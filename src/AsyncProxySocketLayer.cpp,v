head	1.22;
access;
symbols
	PublicRelease_1_2e:1.21
	Interim_Release_1-2e_RC1:1.21
	PublicRelease_1_2d:1.17
	Interim_Release_1-2d_RC1:1.17
	Interim_Release_1-2d_beta1:1.17
	PublicRelease_1_2c:1.15
	Interim_Release_1-2c_RC1:1.15
	Interim_Release_1-2c_beta1:1.15
	PublicRelease_1_2b:1.15
	Interim_Release_1-2b_RC1:1.14
	PublicRelease_1_2a:1.14
	Interim_Release_1-2a_RC1:1.14
	Interim_Release_1-2a_beta2:1.14
	Interim_Release_1-2a_beta1:1.14
	PublicRelease_1_2:1.14
	Interim_Release_1-2_RC1:1.14
	Interim_Release_1-2_beta1:1.13
	PublicRelease_1_1g:1.13
	Interim_Release_1-1g_RC3:1.13
	Interim_Release_1-1g_RC2:1.13
	Interim_Release_1-1g_RC1:1.13
	Interim_Release_1-1g_beta2:1.13
	Interim_Release_1-1g_beta1:1.13
	PublicRelease_1_1f:1.13
	Interim_Release_1-1f_RC1:1.13
	PublicRelease_1_1e:1.13
	Interim_Release_1-1e_RC2:1.13
	Interim_Release_1-1e_RC1:1.13
	Interim_Release_1-1e_beta1:1.13
	PublicRelease_1_1d:1.13
	Interim_Release_1-1d_RC1:1.13
	PublicRelease_1_1c:1.13
	Interim_Release_1-1c_RC1:1.13
	Interim_Release_1-1c_beta2:1.13
	Interim_Release_1-1c_beta1:1.13
	PublicRelease_1_1b:1.13
	Interim_Release_1-1b_RC1:1.13
	PublicRelease_1_1a:1.13
	Interim_Release_1-1a_RC2:1.13
	Interim_Release_1-1a_RC1:1.13
	Interim_Release_1-1a_beta2:1.13
	Interim_Release_1-1a_beta1:1.13
	PublicRelease_1_1:1.13
	Interim_Release_1-1_beta1:1.13
	PublicRelease_1o:1.13
	Interim_Release_1o_RC1:1.13
	Interim_Release_1o_beta1:1.13
	PublicRelease_1n:1.13
	Interim_Release_1n_RC2:1.13
	Interim_Release_1n_RC1:1.13
	Interim_Release_1n_beta2:1.13
	Interim_Release_1n_beta1:1.13
	PublicRelease_1m:1.13
	Interim_Release_1m_beta1:1.13
	PublicRelease_1l:1.13
	Interim_Release_1l_RC3:1.13
	Interim_Release_1l_RC2:1.13
	Interim_Release_1l_RC1:1.13
	Interim_Release_1l_beta2:1.13
	Interim_Release_1l_beta1:1.13
	PublicRelease_1k:1.13
	Interim_Release_1k_RC4:1.13
	Interim_1k_RC3:1.13
	Interim_1k_RC2:1.13
	Interim_Release_1k_RC1:1.13
	Interim_Release_1k_beta5:1.13
	Intrerim_Release_1k_beta4:1.13
	Interim_Release_1k_beta1:1.13
	PublicRelease_1j:1.12
	Interim_Release_1J_RC3:1.12
	Interim_Release_1j_RC3:1.12
	Interim_Release_1j_RC2:1.12
	Interim_Release_1j_RC1:1.12
	Interim_Release_1j_beta2:1.12
	Interim_Release_1j_beta1:1.12
	PublicRelease_1i:1.12
	Interim_Release_1i_RC6:1.12
	Interim_Release_1i_RC3:1.12
	Interim_Release_1i_RC2:1.12
	Interim_Release_1i_RC1:1.12
	Interim_Release_1i_beta3:1.11
	Interim_Release_1i_beta2:1.11
	Interim_Release_1i_beta1:1.9
	PublicRelease_1h:1.6
	Interim_Release_1h_rc2:1.6
	Interim_Release_1h_RC1:1.6
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.6
	Interim_Release_1h_beta1:1.6
	PublicRelease_1g:1.6
	Interim_Release_1g_RC6_Final:1.6
	Interim_Release_1g_RC6:1.6
	Interim_Release_1g_RC5:1.6
	Interim_Release_1g_RC4:1.6
	Interim_Release_1g_RC3:1.6
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.14
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.12
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.10
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.8
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.1
	proxytest:1.1.2.1.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@// @;


1.22
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2009.03.01.20.45.48;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.29.04.36.40;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.17.05.01.21;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.18.18.29.04;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.16.18.32.29;	author fuxie-dk;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.14.05.22.39;	author fuxie-dk;	state Exp;
branches;
next	1.15;

1.15
date	2007.02.01.03.56.48;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.15.05.33.21;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.01.14.27.35;	author syrus77;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.25.01.09.10;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.22.16.30.32;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.21.22.05.12;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.21.13.47.06;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.15.09.10.04;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.14.18.08.22;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.11.18.27.05;	author eklmn;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.04.10.05.32;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.15.36.56;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.56;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Fast byte swap for ntohl and ntohs.
@
text
@/*CAsyncProxySocketLayer by Tim Kosse (Tim.Kosse@@gmx.de)
                 Version 1.6 (2003-03-26)
--------------------------------------------------------

Introduction:
-------------

This class is layer class for CAsyncSocketEx. With this class you
can connect through SOCKS4/5 and HTTP 1.1 proxies. This class works
as semi-transparent layer between CAsyncSocketEx and the actual socket.
This class is used in FileZilla, a powerful open-source FTP client.
It can be found under http://sourceforge.net/projects/filezilla
For more information about SOCKS4/5 goto
http://www.socks.nec.com/socksprot.html
For more information about HTTP 1.1 goto http://www.rfc-editor.org
and search for RFC2616

How to use?
-----------

You don't have to change much in you already existing code to use
CAsyncProxySocketLayer.
To use it, create an instance of CAsyncProxySocketLayer, call SetProxy
and attach it to a CAsyncSocketEx instance.
You have to process OnLayerCallback in you CAsyncSocketEx instance as it will
receive all layer nofications.
The following notifications are sent:

//Error codes
PROXYERROR_NOERROR 0
PROXYERROR_NOCONN 1 //Can't connect to proxy server, use GetLastError for more information
PROXYERROR_REQUESTFAILED 2 //Request failed, can't send data
PROXYERROR_AUTHREQUIRED 3 //Authentication required
PROXYERROR_AUTHTYPEUNKNOWN 4 //Authtype unknown or not supported
PROXYERROR_AUTHFAILED 5  //Authentication failed
PROXYERROR_AUTHNOLOGON 6
PROXYERROR_CANTRESOLVEHOST 7

//Status messages
PROXYSTATUS_LISTENSOCKETCREATED 8 //Called when a listen socket was created successfully. Unlike the normal listen function,
								//a socksified socket has to connect to the proxy to negotiate the details with the server
								//on which the listen socket will be created
								//The two parameters will contain the ip and port of the listen socket on the server.

If you want to use CAsyncProxySocketLayer to create a listen socket, you
have to use this overloaded function:
BOOL PrepareListen(unsigned long serverIp);
serverIP is the IP of the server you are already connected
through the SOCKS proxy. You can't use listen sockets over a
SOCKS proxy without a primary connection. Listen sockets are only
supported by SOCKS proxies, this won't work with HTTP proxies.
When the listen socket is created successfully, the PROXYSTATUS_LISTENSOCKETCREATED
notification is sent. The parameters  will tell you the ip and the port of the listen socket.
After it you have to handle the OnAccept message and accept the
connection.
Be carful when calling Accept: rConnected socket will NOT be filled! Instead use the instance which created the
listen socket, it will handle the data connection.
If you want to accept more than one connection, you have to create a listing socket for each of them!

Description of important functions and their parameters:
--------------------------------------------------------

void SetProxy(int nProxyType);
void SetProxy(int nProxyType, const CStringA& strProxyHost, int nProxyPort);
void SetProxy(int nProxyType, const CStringA& strProxyHost, int nProxyPort, const CStringA& strProxyUser, const CStringA& strProxyPass);

Call one of this functions to set the proxy type.
Parametes:
- nProxyType specifies the Proxy Type.
- ProxyHost and nProxyPort specify the address of the proxy
- ProxyUser and ProxyPass are only available for SOCKS5 proxies.

supported proxy types:
PROXYTYPE_NOPROXY
PROXYTYPE_SOCKS4
PROXYTYPE_SOCKS4A
PROXYTYPE_SOCKS5
PROXYTYPE_HTTP11

There are also some other functions:

GetProxyPeerName
Like GetPeerName of CAsyncSocket, but returns the address of the
server connected through the proxy.	If using proxies, GetPeerName
only returns the address of the proxy.

int GetProxyType();
Returns the used proxy

const int GetLastProxyError() const;
Returns the last proxy error

License
-------

Feel free to use this class, as long as you don't claim that you wrote it
and this copyright notice stays intact in the source files.
If you use this class in commercial applications, please send a short message
to tim.kosse@@gmx.de

Version history
---------------

- 1.6 got rid of MFC
- 1.5 released CAsyncSocketExLayer version
- 1.4 added UNICODE support
- 1.3 added basic HTTP1.1 authentication
      fixed memory leak in SOCKS5 code
	  OnSocksOperationFailed will be called after Socket has been closed
      fixed some minor bugs
- 1.2 renamed into CAsyncProxySocketLayer
      added HTTP1.1 proxy support
- 1.1 fixes all known bugs, mostly with SOCKS5 authentication
- 1.0 initial release
*/

#include "stdafx.h"
#include "AsyncProxySocketLayer.h"
#include "CBase64coding.hpp"
#include "emule.h"
#include "otherfunctions.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Konstruktion/Destruktion
//////////////////////////////////////////////////////////////////////

CAsyncProxySocketLayer::CAsyncProxySocketLayer()
{
	m_nProxyOpID = 0;
	m_nProxyOpState = 0;
	m_pRecvBuffer = 0;
	m_nRecvBufferPos = 0;
	m_nProxyPeerIP = 0;
	m_uProxyPeerPort = 0;
	m_pProxyPeerHost = NULL;
	m_pStrBuffer = NULL;
	m_ProxyData.nProxyType = PROXYTYPE_NOPROXY;
}

CAsyncProxySocketLayer::~CAsyncProxySocketLayer()
{
	delete[] m_pProxyPeerHost;
	ClearBuffer();
}

/////////////////////////////////////////////////////////////////////////////
// Member-Funktion CAsyncProxySocketLayer

void CAsyncProxySocketLayer::SetProxy(int nProxyType)
{
	//Validate the parameters
	ASSERT(nProxyType == PROXYTYPE_NOPROXY);

	m_ProxyData.nProxyType = nProxyType;
}

void CAsyncProxySocketLayer::SetProxy(int nProxyType, const CStringA& strProxyHost, int ProxyPort)
{
	//Validate the parameters
	ASSERT(nProxyType == PROXYTYPE_SOCKS4  ||
		   nProxyType == PROXYTYPE_SOCKS4A ||
		   nProxyType == PROXYTYPE_SOCKS5  ||
		   nProxyType == PROXYTYPE_HTTP11);
	ASSERT(!m_nProxyOpID);
	ASSERT(!strProxyHost.IsEmpty());
	ASSERT(ProxyPort > 0);
	ASSERT(ProxyPort <= 65535);

	m_ProxyData.nProxyType = nProxyType;
	m_ProxyData.strProxyHost = strProxyHost;
	m_ProxyData.nProxyPort = ProxyPort;
	m_ProxyData.bUseLogon = false;
}

void CAsyncProxySocketLayer::SetProxy(int nProxyType, const CStringA& strProxyHost, int ProxyPort,
									  const CStringA& strProxyUser, const CStringA& strProxyPass)
{
	//Validate the parameters
	ASSERT(nProxyType == PROXYTYPE_SOCKS5 || nProxyType == PROXYTYPE_HTTP11);
	ASSERT(!m_nProxyOpID);
	ASSERT(!strProxyHost.IsEmpty());
	ASSERT(ProxyPort > 0);
	ASSERT(ProxyPort <= 65535);

	m_ProxyData.nProxyType = nProxyType;
	m_ProxyData.strProxyHost = strProxyHost;
	m_ProxyData.nProxyPort = ProxyPort;
	m_ProxyData.bUseLogon = true;
	m_ProxyData.strProxyUser = strProxyUser;
	m_ProxyData.strProxyPass = strProxyPass;
}

static CStringA GetSocks4Error(UINT ver, UINT cd)
{
	if (ver != 0)
	{
		CStringA strError;
		strError.Format("Unknown protocol version: %u", ver);
		return strError;
	}

	switch (cd)
	{
		case 90: return "";
		case 91: return "Request rejected or failed";
		case 92: return "Failed to connect to 'identd'";
		case 93: return "'identd' user-id error";
		default:
		{
			CStringA strError;
			strError.Format("Unknown command: %u", cd);
			return strError;
		}
	}
}

static CStringA GetSocks5Error(UINT rep)
{
	switch (rep)
	{
		case 0x00: return "";
		case 0x01: return "General SOCKS server failure";
		case 0x02: return "Connection not allowed by ruleset";
		case 0x03: return "Network unreachable";
		case 0x04: return "Host unreachable";
		case 0x05: return "Connection refused";
		case 0x06: return "TTL expired";
		case 0x07: return "Command not supported";
		case 0x08: return "Address type not supported";
		default:
		{
			CStringA strError;
			strError.Format("Unknown reply: %u", rep);
			return strError;
		}
	}
}

void CAsyncProxySocketLayer::OnReceive(int nErrorCode) 
{
	EMULE_TRY

	if (m_nProxyOpID == 0)
	{
		TriggerEvent(FD_READ, nErrorCode, TRUE);
		return;
	}
	if (nErrorCode)
		TriggerEvent(FD_READ, nErrorCode, TRUE);

	if (m_nProxyOpState == 0) //We should not receive a response yet!
		return;

	if (m_ProxyData.nProxyType == PROXYTYPE_SOCKS4 || m_ProxyData.nProxyType == PROXYTYPE_SOCKS4A)
	{
		if (   m_nProxyOpState == 1 // Response to initial connect or bind request
			|| m_nProxyOpState == 2)// Response (2nd) to bind request
		{
			if (!m_pRecvBuffer)
				m_pRecvBuffer = new char[8];
			int numread = ReceiveNext(m_pRecvBuffer + m_nRecvBufferPos, 8 - m_nRecvBufferPos);
			if (numread == SOCKET_ERROR)
			{
				int nErrorCode = WSAGetLastError();
				if (nErrorCode != WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
					else
						TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
					Reset();
					ClearBuffer();
				}
				return;
			}
			m_nRecvBufferPos += numread;

			//                +----+----+----+----+----+----+----+----+
			//                | VN | CD | DSTPORT |      DSTIP        |
			//                +----+----+----+----+----+----+----+----+
			// # of bytes:       1    1      2              4
			//
			// VN is the version of the reply code and should be 0. CD is the result
			// code with one of the following values:
			//
			//        90: request granted
			//        91: request rejected or failed
			//        92: request rejected becasue SOCKS server cannot connect to
			//            identd on the client
			//        93: request rejected because the client program and identd
			//            report different user-ids
			if (m_nRecvBufferPos == 8)
			{
				if (m_pRecvBuffer[0] != 0 || m_pRecvBuffer[1] != 90)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0, (LPARAM)(LPCSTR)GetSocks4Error(m_pRecvBuffer[0], m_pRecvBuffer[1]));
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					Reset();
					ClearBuffer();
					return;
				}
				// Proxy SHOULD answer with DSTPORT and DSTIP. Most proxies do, but some answer with 0.0.0.0:0
				if ( (m_nProxyOpID == PROXYOP_CONNECT && m_nProxyOpState == 1) ||
					 (m_nProxyOpID == PROXYOP_BIND  && m_nProxyOpState == 2) )
				{
					int nOpIDEvent = m_nProxyOpID == PROXYOP_CONNECT ? FD_CONNECT : FD_ACCEPT;
					ClearBuffer();
					Reset();
					TriggerEvent(nOpIDEvent, 0, TRUE);
					TriggerEvent(FD_READ, 0, TRUE);
					TriggerEvent(FD_WRITE, 0, TRUE);
					return;
				}
				else if (m_nProxyOpID == PROXYOP_BIND && m_nProxyOpState == 1)
				{
					// Listen socket created
					m_nProxyOpState = 2;
					u_long ip = *(u_long*)&m_pRecvBuffer[4];

					if (ip == 0)
					{
						// No IP returned, use the IP of the proxy server
						SOCKADDR SockAddr = {0};
						int SockAddrLen = sizeof(SockAddr);
						if (GetPeerName(&SockAddr, &SockAddrLen))
						{
							ip = ((LPSOCKADDR_IN)&SockAddr)->sin_addr.S_un.S_addr;
						}
						else
						{
							DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
							if (m_nProxyOpID == PROXYOP_CONNECT)
								TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
							else
								TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
							Reset();
							ClearBuffer();
							return;
						}
					}
					t_ListenSocketCreatedStruct data;
					data.ip = ip;
					data.nPort = *(u_short*)&m_pRecvBuffer[2];
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYSTATUS_LISTENSOCKETCREATED, 0, (LPARAM)&data);
					// Wait for 2nd response to bind request
				}
				ClearBuffer();
			}
		}
	}
	else if (m_ProxyData.nProxyType == PROXYTYPE_SOCKS5)
	{
		if (   m_nProxyOpState == 1 // Response to initialization request
			|| m_nProxyOpState == 2)// Response to authentication request
		{
			if (!m_pRecvBuffer)
				m_pRecvBuffer = new char[2];
			int numread = ReceiveNext(m_pRecvBuffer + m_nRecvBufferPos, 2 - m_nRecvBufferPos);
			if (numread == SOCKET_ERROR)
			{
				int nErrorCode = WSAGetLastError();
				if (nErrorCode != WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
					else
						TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
					Reset();
				}
				return;
			}
			m_nRecvBufferPos += numread;

			if (m_nRecvBufferPos == 2)
			{
				bool bIniReqFailed = m_nProxyOpState == 1 && m_pRecvBuffer[0] != 5;  // Response to initialization request
				bool bAuthReqFailed = m_nProxyOpState == 2 && m_pRecvBuffer[1] != 0; // Response to authentication request
				if (bIniReqFailed || bAuthReqFailed)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, bAuthReqFailed ? PROXYERROR_AUTHFAILED : PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					Reset();
					ClearBuffer();
					return;
				}

				if (m_nProxyOpState == 1 && m_pRecvBuffer[1] != 0) // Authentication needed
				{
					if (m_pRecvBuffer[1] != 2)
					{ // Unknown authentication type
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_AUTHTYPEUNKNOWN, 0);
						if (m_nProxyOpID == PROXYOP_CONNECT)
							TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
						else
							TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
						Reset();
						ClearBuffer();
						return;
					}

					if (!m_ProxyData.bUseLogon)
					{
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_AUTHNOLOGON, 0);
						if (m_nProxyOpID == PROXYOP_CONNECT)
							TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
						else
							TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
						Reset();
						ClearBuffer();
						return;
					}

					// Send authentication
					//
					// RFC 1929 - Username/Password Authentication for SOCKS V5
					//
					// +----+------+----------+------+----------+
					// |VER | ULEN |  UNAME   | PLEN |  PASSWD  |
					// +----+------+----------+------+----------+
					// | 1  |  1   | 1 to 255 |  1   | 1 to 255 |
					// +----+------+----------+------+----------+
					//
					// The VER field contains the current version of the subnegotiation,
					// which is X'01'. The ULEN field contains the length of the UNAME field
					// that follows. The UNAME field contains the username as known to the
					// source operating system. The PLEN field contains the length of the
					// PASSWD field that follows. The PASSWD field contains the password
					// association with the given UNAME.

					char cBuff[1 + 1 + 255 + 1 + 255];
					int iLen = _snprintf(cBuff, _countof(cBuff), "\x01%c%s%c%s", 
						m_ProxyData.strProxyUser.GetLength(), m_ProxyData.strProxyUser, 
						m_ProxyData.strProxyPass.GetLength(), m_ProxyData.strProxyPass);

					int res = SendNext(cBuff, iLen);
					if (res == SOCKET_ERROR || res < iLen)
					{
						int nErrorCode = WSAGetLastError();
						if ((nErrorCode != WSAEWOULDBLOCK) || res < iLen)
						{
							DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
							if (m_nProxyOpID == PROXYOP_CONNECT)
								TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
							else
								TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
							Reset();
							return;
						}
					}
					ClearBuffer();
					m_nProxyOpState = 2;
					return;
				}

				// Send connection request
				const char* pszAsciiProxyPeerHost;
				int iLenAsciiProxyPeerHost;
				if (m_nProxyPeerIP == 0)
				{
					pszAsciiProxyPeerHost = m_pProxyPeerHost;
					iLenAsciiProxyPeerHost = strlen(pszAsciiProxyPeerHost);
				}
				else
				{
					pszAsciiProxyPeerHost = 0;
					iLenAsciiProxyPeerHost = 0;
				}
				char* pcReq = (char*)_alloca(10 + 1 + iLenAsciiProxyPeerHost);
				pcReq[0] = 5;
				pcReq[1] = (m_nProxyOpID == PROXYOP_CONNECT) ? 1 : 2;
				pcReq[2] = 0;
				int iReqLen = 3;
				if (m_nProxyPeerIP) {
					pcReq[iReqLen++] = 1;
					*(u_long*)&pcReq[iReqLen] = m_nProxyPeerIP;
					iReqLen += 4;
				}
				else {
					pcReq[iReqLen++] = 3;
					pcReq[iReqLen++] = (char)iLenAsciiProxyPeerHost;
					memcpy(&pcReq[iReqLen], pszAsciiProxyPeerHost, iLenAsciiProxyPeerHost);
					iReqLen += iLenAsciiProxyPeerHost;
				}
				*(u_short*)&pcReq[iReqLen] = m_uProxyPeerPort;
				iReqLen += 2;

				int res = SendNext(pcReq, iReqLen);
				if (res == SOCKET_ERROR || res < iReqLen)
				{
					int nErrorCode = WSAGetLastError();
					if ((nErrorCode != WSAEWOULDBLOCK) || res < iReqLen)
					{
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
						if (m_nProxyOpID == PROXYOP_CONNECT)
							TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
						else
							TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
						Reset();
						return;
					}
				}
				m_nProxyOpState = 3;
				ClearBuffer();
			}
		}
		else if (  m_nProxyOpState == 3  // Response to connection or bind request
			    || m_nProxyOpState == 4) // Response (2nd) to bind request
		{
			if (!m_pRecvBuffer)
				m_pRecvBuffer = new char[10];
			int numread = ReceiveNext(m_pRecvBuffer + m_nRecvBufferPos, 10 - m_nRecvBufferPos);
			if (numread == SOCKET_ERROR)
			{
				int nErrorCode = WSAGetLastError();
				if (nErrorCode != WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
					else
						TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
					Reset();
				}
				return;
			}
			m_nRecvBufferPos += numread;

			if (m_nRecvBufferPos == 10)
			{
				if (m_pRecvBuffer[0] != 5 || m_pRecvBuffer[1] != 0)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0, (LPARAM)(LPCSTR)GetSocks5Error(m_pRecvBuffer[1]));
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					Reset();
					ClearBuffer();
					return;
				}

				if ( (m_nProxyOpID == PROXYOP_CONNECT && m_nProxyOpState == 3) ||
					 (m_nProxyOpID == PROXYOP_BIND && m_nProxyOpState == 4) )
				{
					int nOpIDEvent = m_nProxyOpID == PROXYOP_CONNECT ? FD_CONNECT : FD_ACCEPT;
					Reset();
					ClearBuffer();
					TriggerEvent(nOpIDEvent, 0, TRUE);
					TriggerEvent(FD_READ, 0, TRUE);
					TriggerEvent(FD_WRITE, 0, TRUE);
					return;
				}
				else if (m_nProxyOpID == PROXYOP_BIND && m_nProxyOpState == 3)
				{
					// Listen socket created
					if (m_pRecvBuffer[3] != 1)
					{ // Check which kind of address the response contains
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0, (LPARAM)"Unexpected ATYP received");
						if (m_nProxyOpID == PROXYOP_CONNECT)
							TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
						else
							TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
						Reset();
						ClearBuffer();
						return;
					}

					m_nProxyOpState = 4;
					t_ListenSocketCreatedStruct data;
					data.ip = *(u_long*)&m_pRecvBuffer[4];
					data.nPort = *(u_short*)&m_pRecvBuffer[8];
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYSTATUS_LISTENSOCKETCREATED, 0, (LPARAM)&data);
					// Wait for 2nd response to bind request
				}
				ClearBuffer();
			}
		}
	}
	else if (m_ProxyData.nProxyType == PROXYTYPE_HTTP11)
	{
		ASSERT(m_nProxyOpID == PROXYOP_CONNECT);
		char buffer[9]={0};
		for(;;)
		{
			int numread = ReceiveNext(buffer, m_pStrBuffer?1:8);
			if (numread==SOCKET_ERROR)
			{
				int nError=WSAGetLastError();
				if (nError!=WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					Reset();
					ClearBuffer();
					TriggerEvent(FD_CONNECT, nError, TRUE );
				}
				return;
			}
			//Response begins with HTTP/
			if (!m_pStrBuffer)
			{
				m_pStrBuffer = new char[strlen(buffer) + 1];
				strcpy(m_pStrBuffer, buffer);
			}
			else
			{
				char *tmp = m_pStrBuffer;
				m_pStrBuffer = new char[strlen(tmp) + strlen(buffer) + 1];
				strcpy(m_pStrBuffer, tmp);
				strcpy(m_pStrBuffer + strlen(tmp), buffer);
				delete [] tmp;
			}
			memzero(buffer, 9);
			const char start[] = "HTTP/";
			if (memcmp(start, m_pStrBuffer, (strlen(start)>strlen(m_pStrBuffer)) ? strlen(m_pStrBuffer) : strlen(start)))
			{
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0, (LPARAM)"No valid HTTP reponse");
				Reset();
				ClearBuffer();
				TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
				return;
			}
			char *pos = strstr(m_pStrBuffer, "\r\n");
			if (pos)
			{
				char *pos2 = strstr(m_pStrBuffer, " ");
				if (!pos2 || *(pos2+1)!='2' || pos2>pos)
				{
					char *tmp = new char[pos-m_pStrBuffer + 1];
					tmp[pos-m_pStrBuffer] = 0;
					strncpy(tmp, m_pStrBuffer, pos-m_pStrBuffer);
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0, (LPARAM)tmp);
					delete [] tmp;
					Reset();
					ClearBuffer();
					TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE );
					return;
				}
			}
			if (strlen(m_pStrBuffer)>3 && !memcmp(m_pStrBuffer+strlen(m_pStrBuffer)-4, "\r\n\r\n", 4)) //End of the HTTP header
			{
				Reset();
				ClearBuffer();
				TriggerEvent(FD_CONNECT, 0, TRUE);
				TriggerEvent(FD_READ, 0, TRUE);
				TriggerEvent(FD_WRITE, 0, TRUE);
				return;
			}
		}
	}
	EMULE_CATCH
}

BOOL CAsyncProxySocketLayer::Connect(LPCSTR lpszHostAddress, UINT nHostPort)
{
	ASSERT(lpszHostAddress != NULL);
	EMULE_TRY

	if (!m_ProxyData.nProxyType)
		//Connect normally because there is no proxy
		return ConnectNext(lpszHostAddress, nHostPort);

	//Translate the host address
	SOCKADDR_IN sockAddr = {0};
	sockAddr.sin_addr.s_addr = inet_addr(lpszHostAddress);
	if (sockAddr.sin_addr.s_addr == INADDR_NONE)
	{
		LPHOSTENT lphost = gethostbyname(lpszHostAddress);

		if (lphost != NULL)
			sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
		else
		{
			// Can't resolve hostname
			if (m_ProxyData.nProxyType == PROXYTYPE_SOCKS4A || 
				m_ProxyData.nProxyType == PROXYTYPE_SOCKS5 ||
				m_ProxyData.nProxyType == PROXYTYPE_HTTP11)
			{	//Can send domain names to proxy

				//Conect to proxy server
				BOOL res = ConnectNext(m_ProxyData.strProxyHost, m_ProxyData.nProxyPort);
				if (!res)
				{
					int nErrorCode = WSAGetLastError();
					if (nErrorCode != WSAEWOULDBLOCK)
					{
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, nErrorCode);
						return FALSE;
					}
				}
				m_uProxyPeerPort = fast_htons((u_short)nHostPort);
				m_nProxyPeerIP = 0;
				delete[] m_pProxyPeerHost;
				m_pProxyPeerHost = NULL; // 'new' may throw an exception
				m_pProxyPeerHost = new char[strlen(lpszHostAddress) + 1];
				strcpy(m_pProxyPeerHost, lpszHostAddress);
				m_nProxyOpID = PROXYOP_CONNECT;
				return TRUE;
			}
			else
			{
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_CANTRESOLVEHOST, 0);
				WSASetLastError(WSAEINVAL);
				return FALSE;
			}
		}
	}
	sockAddr.sin_family = AF_INET;
	sockAddr.sin_port = fast_htons((u_short)nHostPort);

	BOOL res = CAsyncProxySocketLayer::Connect((SOCKADDR*)&sockAddr, sizeof(sockAddr));
	if (res || WSAGetLastError() == WSAEWOULDBLOCK)
	{
		delete[] m_pProxyPeerHost;
		m_pProxyPeerHost = NULL; // 'new' may throw an exception
		m_pProxyPeerHost = new char[strlen(lpszHostAddress) + 1];
		strcpy(m_pProxyPeerHost, lpszHostAddress);
	}
	return res;
	EMULE_CATCH	
	return FALSE;
}

BOOL CAsyncProxySocketLayer::Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	EMULE_TRY
	if (!m_ProxyData.nProxyType)
		//Connect normally because there is no proxy
		return ConnectNext(lpSockAddr, nSockAddrLen );
	
	LPSOCKADDR_IN sockAddr = (LPSOCKADDR_IN)lpSockAddr;

	//Save server details
	m_nProxyPeerIP = sockAddr->sin_addr.S_un.S_addr;
	m_uProxyPeerPort = sockAddr->sin_port;
	delete[] m_pProxyPeerHost;
	m_pProxyPeerHost = NULL;

	m_nProxyOpID = PROXYOP_CONNECT;

	BOOL res = ConnectNext(m_ProxyData.strProxyHost, m_ProxyData.nProxyPort);
	if (!res)
	{
		int nErrorCode = WSAGetLastError();
		if (nErrorCode != WSAEWOULDBLOCK)
		{
			DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, nErrorCode);
			return FALSE;
		}
	}

	return res;
	EMULE_CATCH
	return FALSE;
}

void CAsyncProxySocketLayer::OnConnect(int nErrorCode) 
{
	EMULE_TRY
	if (m_ProxyData.nProxyType == PROXYTYPE_NOPROXY)
	{
		TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
		return;
	}
	if (m_nProxyOpID == 0)
	{
		ASSERT(0);
		return;
	}

	if (nErrorCode)
	{ // Can't connect to proxy
		DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, nErrorCode);
		if (m_nProxyOpID == PROXYOP_CONNECT)
			TriggerEvent(FD_CONNECT, nErrorCode, TRUE);
		else
			TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
		Reset();
		ClearBuffer();
		return;
	}

	if (m_nProxyOpID == PROXYOP_CONNECT || m_nProxyOpID == PROXYOP_BIND)
	{
		if (m_nProxyOpState)
			return; // Somehow OnConnect has been called more than once

		ASSERT(m_ProxyData.nProxyType != PROXYTYPE_NOPROXY);
		ClearBuffer();

		if (m_ProxyData.nProxyType == PROXYTYPE_SOCKS4 || m_ProxyData.nProxyType == PROXYTYPE_SOCKS4A)
		{
			const char* pszAsciiProxyPeerHost;
			int iSizeAsciiProxyPeerHost;
			if (m_nProxyPeerIP == 0)
			{
				pszAsciiProxyPeerHost = m_pProxyPeerHost;
				iSizeAsciiProxyPeerHost = strlen(pszAsciiProxyPeerHost) + 1;
			}
			else {
				pszAsciiProxyPeerHost = 0;
				iSizeAsciiProxyPeerHost = 0;
			}

			// SOCKS 4
			// ---------------------------------------------------------------------------
			//            +----+----+----+----+----+----+----+----+----+----+....+----+
			//            | VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|
			//            +----+----+----+----+----+----+----+----+----+----+....+----+
			//# of bytes:   1    1      2              4           variable       1

			char* pcReq = (char*)_alloca(9 + iSizeAsciiProxyPeerHost);
			pcReq[0] = 4;											// VN: 4
			pcReq[1] = (m_nProxyOpID == PROXYOP_CONNECT) ? 1 : 2;	// CD: 1=CONNECT, 2=BIND
			*(u_short*)&pcReq[2] = m_uProxyPeerPort;				// DSTPORT

			int iReqLen = 4 + 4 + 1;
			if (m_nProxyPeerIP == 0)
			{
				ASSERT(m_ProxyData.nProxyType == PROXYTYPE_SOCKS4A);
				ASSERT(strcmp(pszAsciiProxyPeerHost, "") != 0);
				ASSERT(iSizeAsciiProxyPeerHost > 0);

				// For version 4A, if the client cannot resolve the destination host's
				// domain name to find its IP address, it should set the first three bytes
				// of DSTIP to NULL and the last byte to a non-zero value. (This corresponds
				// to IP address 0.0.0.x, with x nonzero.)

				// DSTIP: Set the IP to 0.0.0.x (x is nonzero)
				pcReq[4] = 0;
				pcReq[5] = 0;
				pcReq[6] = 0;
				pcReq[7] = 1;

				pcReq[8] = 0;	// Terminating NUL-byte for USERID

				// Following the NULL byte terminating USERID, the client must send the 
				// destination domain name and termiantes it with another NULL byte. 

				// Add hostname (including terminating NUL-byte)
				memcpy(&pcReq[9], pszAsciiProxyPeerHost, iSizeAsciiProxyPeerHost);
				iReqLen += iSizeAsciiProxyPeerHost;
			}
			else
			{
				*(u_long*)&pcReq[4] = m_nProxyPeerIP;	// DSTIP
				pcReq[8] = 0;							// Terminating NUL-byte for USERID
			}

			int res = SendNext(pcReq, iReqLen);
			if (res == SOCKET_ERROR)
			{
				int nErrorCode = WSAGetLastError();
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
				if (m_nProxyOpID == PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, (nErrorCode == WSAEWOULDBLOCK) ? WSAECONNABORTED : nErrorCode, TRUE);
				else
					TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
				Reset();
				ClearBuffer();
				return;
			}
			else if (res < iReqLen)
			{
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
				if (m_nProxyOpID == PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
				else
					TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
				Reset();
				ClearBuffer();
				return;
			}
		}
		else if (m_ProxyData.nProxyType == PROXYTYPE_SOCKS5)
		{
			// SOCKS 5
			// -------------------------------------------------------------------------------------------
			// The client connects to the server, and sends a version identifier/method selection message:
			//                +----+----------+----------+
			//                |VER | NMETHODS | METHODS  |
			//                +----+----------+----------+
			//                | 1  |    1     | 1 to 255 |
			//                +----+----------+----------+
			//
			// The values currently defined for METHOD are:
			//
			//       o  X'00' NO AUTHENTICATION REQUIRED
			//       o  X'01' GSSAPI
			//       o  X'02' USERNAME/PASSWORD
			//       o  X'03' to X'7F' IANA ASSIGNED
			//       o  X'80' to X'FE' RESERVED FOR PRIVATE METHODS
			//       o  X'FF' NO ACCEPTABLE METHODS

			int iReqLen;
			char acReq[4];
			acReq[0] = 5;		// VER: 5
			if (m_ProxyData.bUseLogon) {
				acReq[1] = 2;	// NMETHODS: 2
				acReq[2] = 2;	// METHOD #1: 2 (USERNAME/PASSWORD)
				acReq[3] = 0;	// METHOD #2: 0 (NO AUTHENTICATION)
				iReqLen = 4;
			}
			else {
				acReq[1] = 1;	// NMETHODS: 1
				acReq[2] = 0;	// METHOD #1: 0 (NO AUTHENTICATION)
				iReqLen = 3;
			}

			int res = SendNext(acReq, iReqLen);
			
			if (res == SOCKET_ERROR)
			{
				int nErrorCode = WSAGetLastError();
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
				if (m_nProxyOpID == PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, (nErrorCode == WSAEWOULDBLOCK) ? WSAECONNABORTED : nErrorCode, TRUE);
				else
					TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
				Reset();
				ClearBuffer();
				return;
			}
			else if (res < iReqLen)
			{
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
				if (m_nProxyOpID == PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
				else
					TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
				Reset();
				ClearBuffer();
				return;
			}
		}
		else if (m_ProxyData.nProxyType == PROXYTYPE_HTTP11)
		{
			const char* pszHost;
			if (m_pProxyPeerHost && m_pProxyPeerHost[0] != '\0')
				pszHost = m_pProxyPeerHost;
			else
				pszHost = inet_ntoa(*(in_addr*)&m_nProxyPeerIP);

			UINT nProxyPeerPort = fast_ntohs((u_short)m_uProxyPeerPort);
			char szHttpReq[4096];
			int iHttpReqLen;

			if (!m_ProxyData.bUseLogon)
			{
				// "Host" field is a MUST for HTTP/1.1 according RFC 2161
				iHttpReqLen = _snprintf(szHttpReq, _countof(szHttpReq),
					"CONNECT %s:%u HTTP/1.1\r\n"
					"Host: %s:%u\r\n"
					"\r\n",
					pszHost, nProxyPeerPort, pszHost, nProxyPeerPort);
			}
			else
			{
				char szUserPass[512];
				int iUserPassLen = _snprintf(szUserPass, _countof(szUserPass), "%s:%s", m_ProxyData.strProxyUser, m_ProxyData.strProxyPass);

				char szUserPassBase64[2048];
				CBase64Coding base64coding;
				if (!base64coding.Encode(szUserPass, iUserPassLen, szUserPassBase64)) {
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID == PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					Reset();
					ClearBuffer();
					return;
				}

				// "Host" field is a MUST for HTTP/1.1 according RFC 2161
				iHttpReqLen = _snprintf(szHttpReq, _countof(szHttpReq), 
					"CONNECT %s:%u HTTP/1.1\r\n"
					"Host: %s:%u\r\n"
					"Authorization: Basic %s\r\n"
					"Proxy-Authorization: Basic %s\r\n"
					"\r\n",
					pszHost, nProxyPeerPort, pszHost, nProxyPeerPort, szUserPassBase64, szUserPassBase64);
			}

			int iSent = SendNext(szHttpReq, iHttpReqLen);
			if (iSent == SOCKET_ERROR)
			{
				int nErrorCode = WSAGetLastError();
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, nErrorCode);
				if (m_nProxyOpID == PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, (nErrorCode == WSAEWOULDBLOCK) ? WSAECONNABORTED : nErrorCode, TRUE);
				else
					TriggerEvent(FD_ACCEPT, nErrorCode, TRUE);
				Reset();
				ClearBuffer();
				return;
			}
			else if (iSent < iHttpReqLen)
			{
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
				if (m_nProxyOpID == PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
				else
					TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
				Reset();
				ClearBuffer();
				return;
			}
			m_nProxyOpState++;
			return;
		}
		else
			ASSERT(0);

		//Now we'll wait for the response, handled in OnReceive
		m_nProxyOpState++;
	}
	EMULE_CATCH
}

void CAsyncProxySocketLayer::ClearBuffer()
{
	delete[] m_pStrBuffer;
	m_pStrBuffer = NULL;
	delete[] m_pRecvBuffer;
	m_pRecvBuffer = 0;
	m_nRecvBufferPos = 0;
}

BOOL CAsyncProxySocketLayer::Listen(int nConnectionBacklog)
{
	EMULE_TRY
	if (GetProxyType() == PROXYTYPE_NOPROXY)
		return ListenNext(nConnectionBacklog);

	//Connect to proxy server
	BOOL res = ConnectNext(m_ProxyData.strProxyHost, m_ProxyData.nProxyPort);
	if (!res)
	{
		int nErrorCode = WSAGetLastError();
		if (nErrorCode != WSAEWOULDBLOCK)
		{
			DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, nErrorCode);
			return FALSE;
		}
	}
	m_uProxyPeerPort = 0;
	m_nProxyPeerIP = (unsigned int)nConnectionBacklog;
	m_nProxyOpID = PROXYOP_BIND;
	return TRUE;

	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncProxySocketLayer::GetPeerName(CString &rPeerAddress, UINT &rPeerPort)
{
	EMULE_TRY
	if (m_ProxyData.nProxyType == PROXYTYPE_NOPROXY)
		return GetPeerNameNext(rPeerAddress, rPeerPort);

	if (GetLayerState() == LAYERSTATE_NOTSOCK)
	{
		WSASetLastError(WSAENOTSOCK);
		return FALSE;
	}
	else if (GetLayerState() != LAYERSTATE_CONNECTED)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}
	else if (!m_nProxyPeerIP || !m_uProxyPeerPort)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}

	ASSERT(m_ProxyData.nProxyType);
	BOOL res = GetPeerNameNext(rPeerAddress, rPeerPort);
	if (res)
	{
		rPeerPort = fast_ntohs((u_short)m_uProxyPeerPort);
		rPeerAddress.Format(_T("%u.%u.%u.%u"), m_nProxyPeerIP&0xff, (m_nProxyPeerIP>>8)&0xff, (m_nProxyPeerIP>>16)&0xff, m_nProxyPeerIP>>24);
	}
	return res;
	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncProxySocketLayer::GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
{
	EMULE_TRY
	if (m_ProxyData.nProxyType == PROXYTYPE_NOPROXY)
		return GetPeerNameNext(lpSockAddr, lpSockAddrLen);

	if (GetLayerState() == LAYERSTATE_NOTSOCK)
	{
		WSASetLastError(WSAENOTSOCK);
		return FALSE;
	}
	else if (GetLayerState() != LAYERSTATE_CONNECTED)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}
	else if (!m_nProxyPeerIP || !m_uProxyPeerPort)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}

	ASSERT(m_ProxyData.nProxyType);
	BOOL res = GetPeerNameNext(lpSockAddr, lpSockAddrLen);
	if (res)
	{
		LPSOCKADDR_IN addr = (LPSOCKADDR_IN)lpSockAddr;
		addr->sin_port = (u_short)m_uProxyPeerPort;
		addr->sin_addr.S_un.S_addr = m_nProxyPeerIP;		
	}
	return res;
	EMULE_CATCH
	return FALSE;
}

int CAsyncProxySocketLayer::GetProxyType() const
{
	return m_ProxyData.nProxyType;
}

void CAsyncProxySocketLayer::Close()
{
	EMULE_TRY
	m_ProxyData.strProxyHost.Empty();
	m_ProxyData.strProxyUser.Empty();
	m_ProxyData.strProxyPass.Empty();
	delete[] m_pProxyPeerHost;
	m_pProxyPeerHost = NULL;
	ClearBuffer();
	Reset();
	CloseNext();
	EMULE_CATCH
}

void CAsyncProxySocketLayer::Reset()
{
	m_nProxyOpState = 0;
	m_nProxyOpID = 0;	
}

int CAsyncProxySocketLayer::Send(const void* lpBuf, int nBufLen, int nFlags) 
{
	if (m_nProxyOpID)
	{
		WSASetLastError(WSAEWOULDBLOCK);
		return SOCKET_ERROR;
	}

	return SendNext(lpBuf, nBufLen, nFlags);
}

int CAsyncProxySocketLayer::Receive(void* lpBuf, int nBufLen, int nFlags) 
{
	if (m_nProxyOpID)
	{
		WSASetLastError(WSAEWOULDBLOCK);
		return SOCKET_ERROR;
	}

	return ReceiveNext(lpBuf, nBufLen, nFlags);
}

BOOL CAsyncProxySocketLayer::PrepareListen(unsigned long ip)
{
	EMULE_TRY
	if (GetLayerState() != LAYERSTATE_NOTSOCK && GetLayerState() != LAYERSTATE_UNCONNECTED)
		return FALSE;
	m_nProxyPeerIP = ip;
	return TRUE;
	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncProxySocketLayer::Accept( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr /*=NULL*/, int* lpSockAddrLen /*=NULL*/ )
{
	EMULE_TRY
	if (!m_ProxyData.nProxyType)
		return AcceptNext(rConnectedSocket, lpSockAddr, lpSockAddrLen);

	GetPeerName(lpSockAddr, lpSockAddrLen);
	return TRUE;
	EMULE_CATCH
	return FALSE;
}

CString GetProxyError(UINT nError)
{
	CString	strError;
	uint32	dwResStrId = 0;

	if (nError == PROXYERROR_NOERROR)
		strError = _T("No proxy error");
	else if (nError == PROXYERROR_NOCONN)
		dwResStrId = IDS_ERRORMSG_PROXY_NOCONN;
	else if (nError == PROXYERROR_REQUESTFAILED)
		dwResStrId = IDS_ERRORMSG_PROXY_REQUESTFAILED;
	else if (nError == PROXYERROR_AUTHREQUIRED)
		dwResStrId = IDS_ERRORMSG_PROXY_AUTHNOLOGON;
	else if (nError == PROXYERROR_AUTHTYPEUNKNOWN)
		dwResStrId = IDS_ERRORMSG_PROXY_AUTHTYPEUNKNOWN;
	else if (nError == PROXYERROR_AUTHFAILED)
		dwResStrId = IDS_ERRORMSG_PROXY_AUTHFAILED;
	else if (nError == PROXYERROR_AUTHNOLOGON)
		dwResStrId = IDS_ERRORMSG_PROXY_AUTHNOLOGON;
	else if (nError == PROXYERROR_CANTRESOLVEHOST)
		dwResStrId = IDS_ERRORMSG_PROXY_CANTRESOLVEHOST;
	else if (nError == PROXYSTATUS_LISTENSOCKETCREATED)
		dwResStrId = IDS_STATUS_PROXY_SOCKETCREATED;
	else
		strError.Format(_T("Proxy-Error: %u"), nError);

	if (dwResStrId != 0)
		GetResString(&strError, dwResStrId);
	return strError;
}
@


1.21
log
@Minor updates according to last version original changes.
@
text
@d957 1
a957 1
			UINT nProxyPeerPort = ntohs((u_short)m_uProxyPeerPort);
d1095 1
a1095 1
		rPeerPort = ntohs((u_short)m_uProxyPeerPort);
@


1.20
log
@Some local functions were made static.
@
text
@a118 1
#include "atlconv.h" //Unicode<->Ascii conversion macros declared here
@


1.19
log
@Faster (intrinsic) htonl and htons implementation.
@
text
@d200 1
a200 1
CStringA GetSocks4Error(UINT ver, UINT cd)
d224 1
a224 1
CStringA GetSocks5Error(UINT rep)
@


1.18
log
@Suppressed compiler warnings.
@
text
@d705 1
a705 1
				m_uProxyPeerPort = htons((u_short)nHostPort);
d723 1
a723 1
	sockAddr.sin_port = htons((u_short)nHostPort);
@


1.17
log
@Removed dupe IDS_ERRORMSG_PROXY_AUTHREQUIRED
@
text
@d141 1
a141 1
	m_nProxyPeerPort = 0;
d499 1
a499 1
				*(u_short*)&pcReq[iReqLen] = m_nProxyPeerPort;
d705 1
a705 1
				m_nProxyPeerPort = htons((u_short)nHostPort);
d749 1
a749 1
	m_nProxyPeerPort = sockAddr->sin_port;
d829 1
a829 1
			*(u_short*)&pcReq[2] = m_nProxyPeerPort;				// DSTPORT
d958 1
a958 1
			UINT nProxyPeerPort = ntohs((u_short)m_nProxyPeerPort);
d1061 1
a1061 1
	m_nProxyPeerPort = 0;
d1086 1
a1086 1
	else if (!m_nProxyPeerIP || !m_nProxyPeerPort)
d1096 1
a1096 1
		rPeerPort = ntohs((u_short)m_nProxyPeerPort);
d1120 1
a1120 1
	else if (!m_nProxyPeerIP || !m_nProxyPeerPort)
d1131 1
a1131 1
		addr->sin_port = (u_short)m_nProxyPeerPort;
@


1.16
log
@Localized proxy errors [Aw3];
Fixed authentication configuration for SOCK5 proxy [Aw3].
@
text
@d1221 1
a1221 1
		dwResStrId = IDS_ERRORMSG_PROXY_AUTHREQUIRED;
@


1.15
log
@Fixed proxy HTTP 1.1 error reporting {vgi2007}.
@
text
@d1211 3
d1215 1
a1215 1
		return _T("No proxy error");
d1217 1
a1217 1
		return _T("Proxy connection failed");
d1219 1
a1219 1
		return _T("Proxy request failed");
d1221 1
a1221 1
		return _T("Proxy authentication required");
d1223 1
a1223 1
		return _T("Proxy authentication not supported");
d1225 1
a1225 1
		return _T("Proxy authentication failed");
d1227 1
a1227 1
		return _T("Proxy authentication required");
d1229 1
a1229 1
		return _T("Proxy hostname not resolved");
d1231 2
a1232 3
		return _T("Proxy listen socket created");
	else{
		CString strError;
d1234 4
a1237 2
		return strError;
	}
@


1.14
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues;
Fixed bug in proxy SOCKS 5 authentication (from original);
Applied a couple of optimizations for proxy support (from original) (except HTTP 1.1 which I didn't update).
@
text
@d631 1
a631 1
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, (int)_T("No valid HTTP reponse"));
d634 1
a634 1
				TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE );
d646 1
a646 1
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, (int)tmp);
@


1.13
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d9 1
a9 1
can connect through SOCKS4/5 and HTTP 1.1 proxies. This class works 
d13 1
a13 1
For more information about SOCKS4/5 goto 
d48 1
a48 1
serverIP is the IP of the server you are already connected 
d50 1
a50 1
SOCKS proxy without a primary connection. Listen sockets are only 
d54 1
a54 1
After it you have to handle the OnAccept message and accept the 
d64 3
a66 3
void SetProxy(int nProxyType, const char * pProxyHost, int nProxyPort);
void SetProxy(int nProxyType, const char * pProxyHost, int nProxyPort, const char *pProxyUser, const char * pProxyPass);
	
d84 1
a84 1
server connected through the proxy.	If using proxies, GetPeerName 
d136 6
a141 7
	m_nProxyOpID=0;
	m_nProxyOpState=0;
	m_pRecvBuffer=0;
	m_nRecvBufferPos=0;
	m_ProxyData.nProxyType=0;
	m_nProxyPeerIp=0;
	m_nProxyPeerPort=0;
d144 1
a144 4
	m_ProxyData.pProxyHost = NULL;
	m_ProxyData.pProxyUser = NULL;
	m_ProxyData.pProxyPass = NULL;
	m_pProxyPeerHost = NULL;
d149 1
a149 4
	delete [] m_ProxyData.pProxyHost;
	delete [] m_ProxyData.pProxyUser;
	delete [] m_ProxyData.pProxyPass;
	delete [] m_pProxyPeerHost;
d154 1
a154 1
// Member-Funktion CAsyncProxySocketLayer 
a157 1
	EMULE_TRY
d159 3
a161 3
	ASSERT(nProxyType==PROXYTYPE_NOPROXY);
	m_ProxyData.nProxyType=nProxyType;
	EMULE_CATCH
d164 1
a164 1
void CAsyncProxySocketLayer::SetProxy(int nProxyType, const char * pProxyHost, int ProxyPort)
a165 1
	EMULE_TRY
d167 4
a170 4
	ASSERT(nProxyType==PROXYTYPE_SOCKS4  || 
		   nProxyType==PROXYTYPE_SOCKS4A || 
		   nProxyType==PROXYTYPE_SOCKS5  || 
		   nProxyType==PROXYTYPE_HTTP11);
d172 3
a174 10
	ASSERT(pProxyHost && *pProxyHost);
	ASSERT(ProxyPort>0);
	ASSERT(ProxyPort<=65535);

	delete [] m_ProxyData.pProxyHost;
	delete [] m_ProxyData.pProxyUser;
	delete [] m_ProxyData.pProxyPass;
	m_ProxyData.pProxyHost = NULL; // 'new' may throw an exception
	m_ProxyData.pProxyUser = NULL;
	m_ProxyData.pProxyPass = NULL;
d177 3
a179 5
	m_ProxyData.pProxyHost = new char[_tcslen(pProxyHost)+1];
	_tcscpy(m_ProxyData.pProxyHost, pProxyHost);
	m_ProxyData.nProxyPort=ProxyPort;
	m_ProxyData.bUseLogon=FALSE;
	EMULE_CATCH
d182 2
a183 1
void CAsyncProxySocketLayer::SetProxy(int nProxyType, const char * pProxyHost, int ProxyPort, const char * pProxyUser, const char * pProxyPass)
a184 1
	EMULE_TRY
d186 1
a186 1
	ASSERT(nProxyType==PROXYTYPE_SOCKS5 || nProxyType==PROXYTYPE_HTTP11);
d188 3
a190 10
	ASSERT(pProxyHost && *pProxyHost);
	ASSERT(ProxyPort>0);
	ASSERT(ProxyPort<=65535);

	delete [] m_ProxyData.pProxyHost;
	delete [] m_ProxyData.pProxyUser;
	delete [] m_ProxyData.pProxyPass;
	m_ProxyData.pProxyHost = NULL; // 'new' may throw an exception
	m_ProxyData.pProxyUser = NULL;
	m_ProxyData.pProxyPass = NULL;
d193 10
a202 4
	m_ProxyData.pProxyHost = new char[_tcslen(pProxyHost)+1];
	_tcscpy(m_ProxyData.pProxyHost, pProxyHost);
	m_ProxyData.nProxyPort=ProxyPort;
	if (pProxyUser)
d204 3
a206 2
		m_ProxyData.pProxyUser = new TCHAR[_tcslen(pProxyUser)+1];
		_tcscpy(m_ProxyData.pProxyUser, pProxyUser);
d208 2
a209 1
	if (pProxyPass)
d211 32
a242 2
		m_ProxyData.pProxyPass = new TCHAR[_tcslen(pProxyPass)+1];
		_tcscpy(m_ProxyData.pProxyPass, pProxyPass);
a243 2
	m_ProxyData.bUseLogon=TRUE;
	EMULE_CATCH
d249 2
a250 2
	//Here we handle the responses from the SOCKS proxy
	if (!m_nProxyOpID)
a255 1
	{
d257 2
a258 3
	}
	if (!m_nProxyOpState) //We should not receive a response yet!
	{ //Ignore it
d260 2
a261 2
	}
	if (m_ProxyData.nProxyType==PROXYTYPE_SOCKS4 || m_ProxyData.nProxyType==PROXYTYPE_SOCKS4A)
d263 2
a264 1
		if (m_nProxyOpState==1) //Both for PROXYOP_CONNECT and PROXYOP_BIND
d267 10
a276 9
				m_pRecvBuffer=new char[8];
			int numread=ReceiveNext(m_pRecvBuffer+m_nRecvBufferPos, 8-m_nRecvBufferPos);				
			if (numread==SOCKET_ERROR)
			{
				if (WSAGetLastError()!=WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
d278 1
a278 1
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
d284 17
a300 2
			m_nRecvBufferPos+=numread;
			if (m_nRecvBufferPos==8)
d302 1
a302 1
				if (m_pRecvBuffer[1]!=90 || m_pRecvBuffer[0]!=0)
d304 2
a305 2
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
						if (m_nProxyOpID==PROXYOP_CONNECT)
d313 3
a315 1
				if (m_nProxyOpID==PROXYOP_CONNECT)
d317 1
a317 1
					//OK, we are connected with the remote server
d320 1
a320 1
					TriggerEvent(FD_CONNECT, 0, TRUE);
d325 1
a325 1
				else
d327 10
a336 11
					//Listen socket created
					m_nProxyOpState++;
					unsigned long ip;
					int port;
					memcpy2(&ip,&m_pRecvBuffer[4],4);
					if (!ip)
					{ //No IP return, use the IP of the proxy server
						SOCKADDR SockAddr;
						memzero(&SockAddr, sizeof(SockAddr));
						int SockAddrLen=sizeof(SockAddr);
						if (GetPeerName(&SockAddr, &SockAddrLen ))
d338 1
a338 1
							ip=((LPSOCKADDR_IN)&SockAddr)->sin_addr.S_un.S_addr;
d343 1
a343 1
							if (m_nProxyOpID==PROXYOP_CONNECT)
a351 1
					memcpy2(&port,&m_pRecvBuffer[2],2);
d353 4
a356 3
					data.ip=ip;
					data.nPort=port;
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYSTATUS_LISTENSOCKETCREATED, (int)&data);
d361 5
a365 1
		else if (m_nProxyOpID==2)
d368 10
a377 9
				m_pRecvBuffer=new char[8];
			int numread=ReceiveNext(m_pRecvBuffer+m_nRecvBufferPos,8-m_nRecvBufferPos);				
			if (numread==SOCKET_ERROR)
			{
				if (WSAGetLastError()!=WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
d379 1
a379 1
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
a380 1
					ClearBuffer();
d384 3
a386 2
			m_nRecvBufferPos+=numread;
			if (m_nRecvBufferPos==8)
d388 3
a390 1
				if (m_pRecvBuffer[1]!=90 || m_pRecvBuffer[0]!=0)
d392 2
a393 2
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
d401 2
a402 34
				//Connection to remote server established
				ClearBuffer();
				Reset();
				TriggerEvent(FD_ACCEPT, 0, TRUE);
				TriggerEvent(FD_READ, 0, TRUE);
				TriggerEvent(FD_WRITE, 0, TRUE);
			}
		}
	}
	else if (m_ProxyData.nProxyType==PROXYTYPE_SOCKS5)
	{	
		if (m_nProxyOpState==1) //Get respone to initialization message
		{
			if (!m_pRecvBuffer)
				m_pRecvBuffer=new char[2];
			int numread=ReceiveNext(m_pRecvBuffer+m_nRecvBufferPos,2-m_nRecvBufferPos);				
			if (numread==SOCKET_ERROR)
			{
				if (WSAGetLastError()!=WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
					Reset();
				}
				return;
			}
			m_nRecvBufferPos+=numread;
			if (m_nRecvBufferPos==2)
			{
				
				if (m_pRecvBuffer[0]!=5)
d404 2
a405 13
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					Reset();
					ClearBuffer();
					return;
				}
				if (m_pRecvBuffer[1])
				{ //Auth needed
					if (m_pRecvBuffer[1]!=2)
					{ //Unknown auth type
d407 1
a407 1
						if (m_nProxyOpID==PROXYOP_CONNECT)
d415 1
a415 1
					
d419 1
a419 1
						if (m_nProxyOpID==PROXYOP_CONNECT)
d427 25
a451 14
					//Send authentication
					LPCSTR lpszAsciiUser = m_ProxyData.pProxyUser;
					LPCSTR lpszAsciiPass = m_ProxyData.pProxyPass;
					ASSERT(strlen(lpszAsciiUser)<=255);
					ASSERT(strlen(lpszAsciiPass)<=255);
					unsigned char *buffer = new unsigned char[3 + (lpszAsciiUser?strlen(lpszAsciiUser):0) + (lpszAsciiPass?strlen(lpszAsciiPass):0) + 1];
					sprintf((char *)buffer, "  %s %s", lpszAsciiUser?lpszAsciiUser:"", lpszAsciiPass?lpszAsciiPass:"");
					buffer[0]=1;
					buffer[1]=static_cast<unsigned char>(strlen(lpszAsciiUser));
					buffer[2+strlen(lpszAsciiUser)]=static_cast<unsigned char>(strlen(lpszAsciiPass));
					int len=3+strlen(lpszAsciiUser)+strlen(lpszAsciiPass);
					int res=SendNext(buffer,len);
					delete [] buffer;
					if (res==SOCKET_ERROR || res<len)
d453 2
a454 1
						if ((WSAGetLastError()!=WSAEWOULDBLOCK) || res<len)
d456 3
a458 3
							DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
							if (m_nProxyOpID==PROXYOP_CONNECT)
								TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
d460 1
a460 1
								TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
d466 1
a466 1
					m_nProxyOpState++;
d469 5
a473 29
			}
			//No auth needed
			//Send connection request
			LPCSTR lpszAsciiHost = m_pProxyPeerHost?m_pProxyPeerHost:"";
			char *command=new char[10 + strlen(lpszAsciiHost) + 1];
			memzero(command, 10 + strlen(lpszAsciiHost) + 1);
			command[0]=5;
			command[1]=(m_nProxyOpID==PROXYOP_CONNECT)?1:2;
			command[2]=0;
			command[3]=m_nProxyPeerIp?1:3;
			int len=4;
			if (m_nProxyPeerIp)
			{
				memcpy2(&command[len],&m_nProxyPeerIp,4);
				len+=4;
			}
			else
			{
				command[len]=strlen(lpszAsciiHost);
				strcpy(&command[len+1],lpszAsciiHost);
				len+=strlen(lpszAsciiHost)+1;
			}
			memcpy2(&command[len],&m_nProxyPeerPort,2);
			len+=2;
			int res=SendNext(command,len);
			delete [] command;
			if (res==SOCKET_ERROR || res<len)
			{
				if ( ( WSAGetLastError()!=WSAEWOULDBLOCK) || res<len)
d475 2
a476 7
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
					Reset();
					return;
d478 1
a478 13
			}
			m_nProxyOpState+=2;
			ClearBuffer();
			return;
		}
		else if (m_nProxyOpState==2)
		{//Response to the auth request
			if (!m_pRecvBuffer)
				m_pRecvBuffer=new char[2];
			int numread=ReceiveNext(m_pRecvBuffer+m_nRecvBufferPos, 2-m_nRecvBufferPos);
			if (numread==SOCKET_ERROR)
			{
				if (WSAGetLastError()!=WSAEWOULDBLOCK)
d480 2
a481 6
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
					Reset();
d483 15
a497 15
				return;
			}
			m_nRecvBufferPos+=numread;
			if (m_nRecvBufferPos==2)
			{
				if (m_pRecvBuffer[1]!=0)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_AUTHFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					Reset();
					ClearBuffer();
					return;
d499 5
a503 9
				LPCSTR lpszAsciiHost = m_pProxyPeerHost?m_pProxyPeerHost:"";
				char *command=new char[10+strlen(lpszAsciiHost) + 1];
				memzero(command,10 + strlen(lpszAsciiHost) + 1);
				command[0]=5;
				command[1]=(m_nProxyOpID==PROXYOP_CONNECT)?1:2;
				command[2]=0;
				command[3]=m_nProxyPeerIp?1:3;
				int len=4;
				if (m_nProxyPeerIp)
d505 2
a506 16
					memcpy2(&command[len],&m_nProxyPeerIp,4);
					len+=4;
				}
				else
				{
					command[len]=strlen(lpszAsciiHost);
					strcpy(&command[len+1],lpszAsciiHost);
					len+=strlen(lpszAsciiHost)+1;
				}
				memcpy2(&command[len],&m_nProxyPeerPort,2);
				len+=2;
				int res=SendNext(command,len);
				delete [] command;
				if (res==SOCKET_ERROR || res<len)
				{
					if ((WSAGetLastError()!=WSAEWOULDBLOCK) || res<len)
d508 3
a510 3
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
						if (m_nProxyOpID==PROXYOP_CONNECT)
							TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
d512 1
a512 1
							TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
d517 1
a517 1
				m_nProxyOpState++;
a518 1
				return;				
d521 3
a523 2
		else if (m_nProxyOpState==3)
		{//Response to the connection request
d525 10
a534 12
			{
				m_pRecvBuffer=new char[10];
				m_nRecvBufferLen=5;
			}
			int numread=ReceiveNext(m_pRecvBuffer+m_nRecvBufferPos,m_nRecvBufferLen-m_nRecvBufferPos);				
			if (numread==SOCKET_ERROR)
			{
				if (WSAGetLastError()!=WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
d536 1
a536 1
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
d541 3
a543 2
			m_nRecvBufferPos+=numread;
			if (m_nRecvBufferPos==m_nRecvBufferLen)
d545 1
a545 2
				//Check for errors
				if (m_pRecvBuffer[1]!=0 || m_pRecvBuffer[0]!=5)
d547 2
a548 2
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
d556 3
a558 16
				if (m_nRecvBufferLen==5)
				{ //Check which kind of address the response contains
					if (m_pRecvBuffer[3]==1)
						m_nRecvBufferLen=10;
					else
					{
						char *tmp=new char[m_nRecvBufferLen+=m_pRecvBuffer[4]+2];
						memcpy2(tmp,m_pRecvBuffer,5);
						delete [] m_pRecvBuffer;
						m_pRecvBuffer=tmp;
						m_nRecvBufferLen+=m_pRecvBuffer[4]+2;
					}
					return;
				}
				
				if (m_nProxyOpID==PROXYOP_CONNECT)
d560 1
a560 1
					//OK, we are connected with the remote server
d563 1
a563 1
					TriggerEvent(FD_CONNECT, 0, TRUE);
d566 1
d568 1
a568 1
				else
d570 14
a583 7
					//Listen socket created
					m_nProxyOpState++;
					unsigned long ip;
					int port;
					ASSERT(m_pRecvBuffer[3]==1);
					memcpy2(&ip,&m_pRecvBuffer[4],4);
					memcpy2(&port,&m_pRecvBuffer[8],2);
d585 4
a588 3
					data.ip=ip;
					data.nPort=port;
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYSTATUS_LISTENSOCKETCREATED, (int)&data);
a592 43
		else if (m_nProxyOpState==4)
		{
			if (!m_pRecvBuffer)
				m_pRecvBuffer=new char[10];
			int numread=ReceiveNext(m_pRecvBuffer+m_nRecvBufferPos,10-m_nRecvBufferPos);				
			if (numread==SOCKET_ERROR)
			{
				if (WSAGetLastError()!=WSAEWOULDBLOCK)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAGetLastError(), TRUE);
					else
						TriggerEvent(FD_ACCEPT, WSAGetLastError(), TRUE);
					Reset();
				}
				return;
			}
			m_nRecvBufferPos+=numread;
			if (m_nRecvBufferPos==10)
			{
				if (m_pRecvBuffer[1]!=0)
				{
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
					if (m_nProxyOpID==PROXYOP_CONNECT)
						TriggerEvent(FD_CONNECT, WSAECONNABORTED, TRUE);
					else
					{
						VERIFY(m_nProxyOpID==PROXYOP_LISTEN);
						TriggerEvent(FD_ACCEPT, WSAECONNABORTED, TRUE);
					}
					Reset();
					ClearBuffer();
					return;
				}
				//Connection to remote server established
				ClearBuffer();
				Reset();
				TriggerEvent(FD_ACCEPT, 0, TRUE);
				TriggerEvent(FD_READ, 0, TRUE);
				TriggerEvent(FD_WRITE, 0, TRUE);
			}
		}
d594 1
a594 1
	if (m_ProxyData.nProxyType==PROXYTYPE_HTTP11)
d596 1
a596 1
		ASSERT (m_nProxyOpID==PROXYOP_CONNECT);
d668 1
a668 1
BOOL CAsyncProxySocketLayer::Connect( LPCTSTR lpszHostAddress, UINT nHostPort )
d670 1
d672 1
a676 2
	USES_CONVERSION;
	
d678 2
a679 10
	ASSERT(lpszHostAddress != NULL);

	SOCKADDR_IN sockAddr;
	memzero(&sockAddr, sizeof(sockAddr));

	LPCSTR lpszAscii = T2A((LPTSTR)lpszHostAddress);
	sockAddr.sin_family = AF_INET;
	sockAddr.sin_addr.s_addr = inet_addr(lpszAscii);

		
d682 2
a683 2
		LPHOSTENT lphost;
		lphost = gethostbyname(lpszAscii);
d688 5
a692 5
			//Can't resolve hostname
			if (m_ProxyData.nProxyType==PROXYTYPE_SOCKS4A || 
				m_ProxyData.nProxyType==PROXYTYPE_SOCKS5 || 
				m_ProxyData.nProxyType==PROXYTYPE_HTTP11)
			{ //Can send domain names to proxy
d695 1
a695 1
				BOOL res=ConnectNext(m_ProxyData.pProxyHost, m_ProxyData.nProxyPort);
d698 2
a699 1
					if (WSAGetLastError()!=WSAEWOULDBLOCK)
d701 1
a701 1
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, WSAGetLastError());
d705 3
a707 3
				m_nProxyPeerPort=htons((u_short)nHostPort);
				m_nProxyPeerIp=0;
				delete [] m_pProxyPeerHost;
d709 1
a709 1
				m_pProxyPeerHost = new char[strlen(lpszHostAddress)+1];
d711 1
a711 1
				m_nProxyOpID=PROXYOP_CONNECT;
d722 2
d725 2
a726 3
	sockAddr.sin_port = htons((u_short)nHostPort);
	BOOL res=CAsyncProxySocketLayer::Connect((SOCKADDR*)&sockAddr, sizeof(sockAddr));
	if (res || WSAGetLastError()==WSAEWOULDBLOCK)
d728 1
a728 1
		delete [] m_pProxyPeerHost;
d730 1
a730 1
		m_pProxyPeerHost = new char[strlen(lpszHostAddress)+1];
d738 1
a738 1
BOOL CAsyncProxySocketLayer::Connect( const SOCKADDR* lpSockAddr, int nSockAddrLen )
d745 1
a745 1
	LPSOCKADDR_IN sockAddr=(LPSOCKADDR_IN)lpSockAddr;
d748 3
a750 3
	m_nProxyPeerIp=sockAddr->sin_addr.S_un.S_addr;
	m_nProxyPeerPort=sockAddr->sin_port;
	delete [] m_pProxyPeerHost;
d753 1
a753 1
	m_nProxyOpID=PROXYOP_CONNECT;
d755 1
a755 1
	BOOL res = ConnectNext(m_ProxyData.pProxyHost, m_ProxyData.nProxyPort);
d758 2
a759 1
		if (WSAGetLastError()!=WSAEWOULDBLOCK)
d761 1
a761 1
			DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, WSAGetLastError());
d774 1
a774 1
	if (m_ProxyData.nProxyType==PROXYTYPE_NOPROXY)
d779 1
a779 2
	ASSERT(m_nProxyOpID);
	if (!m_nProxyOpID)
d781 1
a781 1
		//This should not happen
d783 1
a783 1
	};
d786 1
a786 1
	{ //Can't connect to proxy
d788 1
a788 1
		if (m_nProxyOpID==PROXYOP_CONNECT)
d796 2
a797 1
	if (m_nProxyOpID==PROXYOP_CONNECT || m_nProxyOpID==PROXYOP_LISTEN)
d800 3
a802 3
			//Somehow OnConnect has been called more than once
			return;
		ASSERT(m_ProxyData.nProxyType!=PROXYTYPE_NOPROXY);
d804 53
a856 23
		//Send the initial request
		if (m_ProxyData.nProxyType==PROXYTYPE_SOCKS4 || m_ProxyData.nProxyType==PROXYTYPE_SOCKS4A)
		{ //SOCKS4 proxy
			//Send request
			LPCSTR lpszAscii = m_pProxyPeerHost?m_pProxyPeerHost:"";
			char *command=new char [9 + strlen(lpszAscii) + 1];
			memzero(command, 9 + strlen(lpszAscii) + 1);
			int len=9;
			command[0]=4;
			command[1]=(m_nProxyOpID==PROXYOP_CONNECT)?1:2; //CONNECT or BIND request
			memcpy2(&command[2],&m_nProxyPeerPort,2); //Copy target address
			if (!m_nProxyPeerIp)
			{
				ASSERT(m_ProxyData.nProxyType==PROXYTYPE_SOCKS4A);
				ASSERT(strcmp(lpszAscii, ""));
				//Set the IP to 0.0.0.x (x is nonzero)
				command[4]=0;
				command[5]=0;
				command[6]=0;
				command[7]=1;
				//Add host as URL
				strcpy(&command[9],lpszAscii);
				len+=strlen(lpszAscii)+1;
a858 5
				memcpy2(&command[4],&m_nProxyPeerIp,4);
			int res=SendNext(command,len); //Send command
			delete [] command;
			int nErrorCode=WSAGetLastError();
			if (res==SOCKET_ERROR)//nErrorCode!=WSAEWOULDBLOCK)
d860 11
a870 3
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
				if (m_nProxyOpID==PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, (nErrorCode==WSAEWOULDBLOCK)?WSAECONNABORTED:nErrorCode, TRUE);
d877 1
a877 1
			else if (res<len)
d880 1
a880 1
				if (m_nProxyOpID==PROXYOP_CONNECT)
d889 36
a924 12
		else if (m_ProxyData.nProxyType==PROXYTYPE_SOCKS5)
		{ //SOCKS5 proxy
			//Send initialization request
			unsigned char command[10];
			memzero(command, 10);
			command[0]=5;
			//CAsyncProxySocketLayer supports to logon types: No logon and 
			//cleartext username/password (if set) logon
			command[1]=m_ProxyData.bUseLogon?2:1; //Number of logon types
			command[2]=m_ProxyData.bUseLogon?2:0; //2=user/pass, 0=no logon
			int len=m_ProxyData.bUseLogon?4:3; //length of request
			int res=SendNext(command,len);
d926 1
a926 2
			int nErrorCode=WSAGetLastError();
			if (res==SOCKET_ERROR)//nErrorCode!=WSAEWOULDBLOCK)
d928 4
a931 3
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
				if (m_nProxyOpID==PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, (nErrorCode==WSAEWOULDBLOCK)?WSAECONNABORTED:nErrorCode, TRUE);
d938 1
a938 1
			else if (res<len)
d941 1
a941 1
				if (m_nProxyOpID==PROXYOP_CONNECT)
d950 1
a950 1
		else if (m_ProxyData.nProxyType==PROXYTYPE_HTTP11)
d952 3
a954 8
			char str[4096]; //This should be large enough
			
			char * pHost = NULL;
			if (m_pProxyPeerHost && *m_pProxyPeerHost)
			{
				pHost = new char[strlen(m_pProxyPeerHost)+1];
				strcpy(pHost, m_pProxyPeerHost);
			}
d956 7
d964 6
a969 2
				pHost = new char[16];
				sprintf(pHost, "%d.%d.%d.%d", m_nProxyPeerIp%256, (m_nProxyPeerIp>>8) % 256, (m_nProxyPeerIp>>16) %256, m_nProxyPeerIp>>24);
a970 3
			if (!m_ProxyData.bUseLogon)
				sprintf(str, "CONNECT %s:%d HTTP/1.1\r\nHost: %s:%d\r\n\r\n", pHost, ntohs(m_nProxyPeerPort),
					pHost, ntohs(m_nProxyPeerPort));
d973 2
a974 2
				sprintf(str, "CONNECT %s:%d HTTP/1.1\r\nHost: %s:%d\r\n", pHost, ntohs(m_nProxyPeerPort),
					pHost, ntohs(m_nProxyPeerPort));
d976 1
a976 4
				char userpass[4096];
				sprintf(userpass, "%s:%s", m_ProxyData.pProxyUser?m_ProxyData.pProxyUser:"", m_ProxyData.pProxyPass?m_ProxyData.pProxyPass:"");
				char base64str[4096];
				
d978 1
a978 2
				if (!base64coding.Encode(userpass, strlen(userpass), base64str))
				{
d980 1
a980 1
					if (m_nProxyOpID==PROXYOP_CONNECT)
a985 1
					delete [] pHost;
d988 18
a1005 15
				strcat(str, "Authorization: Basic ");
				strcat(str, base64str);
				strcat(str, "\r\nProxy-Authorization: Basic ");
				strcat(str, base64str);
				strcat(str, "\r\n\r\n");
			}
			delete [] pHost;

			int numsent=SendNext(str, strlen(str) );
			int nErrorCode=WSAGetLastError();
			if (numsent==SOCKET_ERROR)//nErrorCode!=WSAEWOULDBLOCK)
			{
				DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, 0);
				if (m_nProxyOpID==PROXYOP_CONNECT)
					TriggerEvent(FD_CONNECT, (nErrorCode==WSAEWOULDBLOCK)?WSAECONNABORTED:nErrorCode, TRUE);
d1012 1
a1012 1
			else if (  numsent < static_cast<int>( strlen(str) )  )
d1015 1
a1015 1
				if (m_nProxyOpID==PROXYOP_CONNECT)
d1027 2
a1028 1
			ASSERT(FALSE);
d1037 1
a1037 2
	EMULE_TRY
	delete [] m_pStrBuffer;
d1039 3
a1041 9
	if (m_pRecvBuffer)
	{
		delete [] m_pRecvBuffer;
		m_pRecvBuffer=0;
	}
	m_nRecvBufferLen=0;
	m_nRecvBufferPos=0;

	EMULE_CATCH
d1044 1
a1044 1
BOOL CAsyncProxySocketLayer::Listen( int nConnectionBacklog)
d1047 1
a1047 1
	if (GetProxyType()==PROXYTYPE_NOPROXY)
d1051 1
a1051 1
	BOOL res=ConnectNext(m_ProxyData.pProxyHost, m_ProxyData.nProxyPort);
d1054 2
a1055 1
		if (WSAGetLastError()!=WSAEWOULDBLOCK)
d1057 1
a1057 1
			DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, WSAGetLastError());
d1061 3
a1063 4
	m_nProxyPeerPort=0;
	m_nProxyPeerIp=(unsigned int)nConnectionBacklog;
	
	m_nProxyOpID=PROXYOP_LISTEN;
d1065 1
d1073 1
a1073 1
	if (m_ProxyData.nProxyType==PROXYTYPE_NOPROXY)
d1076 1
a1076 1
	if (GetLayerState()==LAYERSTATE_NOTSOCK)
d1081 1
a1081 1
	else if (GetLayerState()!=LAYERSTATE_CONNECTED)
d1086 1
a1086 1
	else if (!m_nProxyPeerIp || !m_nProxyPeerPort)
d1093 1
a1093 1
	BOOL res=GetPeerNameNext( rPeerAddress, rPeerPort );
d1096 2
a1097 2
		rPeerPort=ntohs(m_nProxyPeerPort);
		rPeerAddress.Format(_T("%d.%d.%d.%d"), m_nProxyPeerIp%256,(m_nProxyPeerIp>>8)%256,(m_nProxyPeerIp>>16)%256, m_nProxyPeerIp>>24);
d1104 1
a1104 1
BOOL CAsyncProxySocketLayer::GetPeerName( SOCKADDR* lpSockAddr, int* lpSockAddrLen )
d1107 1
a1107 1
	if (m_ProxyData.nProxyType==PROXYTYPE_NOPROXY)
d1110 1
a1110 1
	if (GetLayerState()==LAYERSTATE_NOTSOCK)
d1115 1
a1115 1
	else if (GetLayerState()!=LAYERSTATE_CONNECTED)
d1120 1
a1120 1
	else if (!m_nProxyPeerIp || !m_nProxyPeerPort)
d1127 1
a1127 1
	BOOL res=GetPeerNameNext(lpSockAddr,lpSockAddrLen);
d1130 3
a1132 3
		LPSOCKADDR_IN addr=(LPSOCKADDR_IN)lpSockAddr;
		addr->sin_port=m_nProxyPeerPort;
		addr->sin_addr.S_un.S_addr=m_nProxyPeerIp;		
a1140 1
	EMULE_TRY
a1141 2
	EMULE_CATCH
	return 0;
d1147 4
a1150 7
	delete [] m_ProxyData.pProxyHost;
	delete [] m_ProxyData.pProxyUser;
	delete [] m_ProxyData.pProxyPass;
	delete [] m_pProxyPeerHost;
	m_ProxyData.pProxyHost = NULL;
	m_ProxyData.pProxyUser = NULL;
	m_ProxyData.pProxyPass = NULL;
d1160 2
a1161 4
	EMULE_TRY
	m_nProxyOpState=0;
	m_nProxyOpID=0;	
	EMULE_CATCH
a1163 1

a1165 1
	EMULE_TRY
a1172 2
	EMULE_CATCH
	return 0;
a1176 1
	EMULE_TRY
a1183 2
	EMULE_CATCH
	return 0;
d1189 1
a1189 1
	if (GetLayerState()!=LAYERSTATE_NOTSOCK && GetLayerState()!=LAYERSTATE_UNCONNECTED)
d1191 1
a1191 1
	m_nProxyPeerIp=ip;
d1212 1
a1212 1
		return _T("No error");
d1214 1
a1214 1
		return _T("Can't connect to proxy server");
d1216 1
a1216 1
		return _T("Request failed, can't send data");
d1218 1
a1218 1
		return _T("Authentication required");
d1220 1
a1220 1
		return _T("Authtype unknown or not supported");
d1222 1
a1222 1
		return _T("Authentication failed");
d1224 1
a1224 1
		return _T("AuthNoLogon");
d1226 1
a1226 1
		return _T("Can't resolve host");
d1228 1
a1228 1
		return _T("Listen socket created");
d1231 1
a1231 1
		strError.Format("Error: %u", nError);
@


1.12
log
@fix for proxy-authenticaion (an old one) bug was reintroduced by layer-upgrade
@
text
@d307 1
a307 1
						memset2(&SockAddr,0,sizeof(SockAddr));
d470 2
a471 2
			char *command=new char[10+strlen(lpszAsciiHost)+1];
			memset2(command,0,10+strlen(lpszAsciiHost)+1);
d542 2
a543 2
				char *command=new char[10+strlen(lpszAsciiHost)+1];
				memset2(command,0,10+strlen(lpszAsciiHost)+1);
d736 1
a736 1
			memset2(buffer, 0, 9);
d790 1
a790 1
	memset2(&sockAddr,0,sizeof(sockAddr));
d923 2
a924 2
			char *command=new char [9+strlen(lpszAscii)+1];
			memset2(command,0,9+strlen(lpszAscii)+1);
d974 1
a974 1
			memset2(command,0,10);
@


1.11
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d443 1
a443 1
					buffer[0]=5;
@


1.10
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d307 1
a307 1
						memset(&SockAddr,0,sizeof(SockAddr));
d471 1
a471 1
			memset(command,0,10+strlen(lpszAsciiHost)+1);
d543 1
a543 1
				memset(command,0,10+strlen(lpszAsciiHost)+1);
d736 1
a736 1
			memset(buffer, 0, 9);
d790 1
a790 1
	memset(&sockAddr,0,sizeof(sockAddr));
d924 1
a924 1
			memset(command,0,9+strlen(lpszAscii)+1);
d974 1
a974 1
			memset(command,0,10);
@


1.9
log
@Empy Incoming dir for category fix, Official fix [Katsyonak], WS templates updated for file status icons.
@
text
@d122 1
a122 1
#include "memcpy_amd.h"
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d2 1
a2 1
                 Version 1.5 (2002-11-01)
d64 2
a65 2
void SetProxy(int nProxyType, CString ProxyHost, int nProxyPort);
void SetProxy(int nProxyType, CString ProxyHost, int nProxyPort,CString ProxyUser, CString ProxyPass);
d93 8
d104 1
d143 6
a148 1
	m_ProxyPeerHost="";
d153 4
d172 1
a172 1
void CAsyncProxySocketLayer::SetProxy(int nProxyType, CString ProxyHost, int ProxyPort)
d181 1
a181 2
	m_ProxyData.nProxyType=nProxyType;
	ASSERT(ProxyHost!="");
d184 11
a194 1
	m_ProxyData.ProxyHost=ProxyHost;
d200 1
a200 1
void CAsyncProxySocketLayer::SetProxy(int nProxyType, CString ProxyHost, int ProxyPort, CString ProxyUser, CString ProxyPass)
d206 1
a206 2
	m_ProxyData.nProxyType=nProxyType;
	ASSERT(ProxyHost!="");
d209 11
a219 1
	m_ProxyData.ProxyHost=ProxyHost;
d221 10
a230 2
	m_ProxyData.ProxyUser=ProxyUser;
	m_ProxyData.ProxyPass=ProxyPass;
a237 1
	USES_CONVERSION;
d437 2
a438 2
					LPCSTR lpszAsciiUser = T2CA(m_ProxyData.ProxyUser);
					LPCSTR lpszAsciiPass = T2CA(m_ProxyData.ProxyPass);
d441 3
a443 3
					unsigned char *buffer=new unsigned char[3+strlen(lpszAsciiUser)+strlen(lpszAsciiPass)+1];
					sprintf((char *)buffer,"  %s %s",lpszAsciiUser,lpszAsciiPass);
					buffer[0]=1;	//tim2k /netwolf
d469 1
a469 1
			LPCSTR lpszAsciiHost=T2CA(m_ProxyPeerHost);
d541 1
a541 1
				LPCSTR lpszAsciiHost=T2CA(m_ProxyPeerHost);
a651 4
					if (ip == 0) 
					{
						ip = inet_addr(m_ProxyData.ProxyHost);
					}
d653 1
a653 1
					data.nPort = port & 0xFFFF;
d709 1
a709 1
			int numread=ReceiveNext(buffer,m_strBuffer==""?8:1);
d723 13
a735 1
			m_strBuffer+=buffer;
d737 2
a738 3
			CString start=_T("HTTP/");
			start=start.Left(m_strBuffer.GetLength());
			if (start!=m_strBuffer.Left(start.GetLength()))
d746 2
a747 2
			int pos=m_strBuffer.Find(_T("\r\n"));
			if (pos!=-1)
d749 2
a750 2
				int pos2=m_strBuffer.Find(_T(" "));
				if (pos2==-1 || m_strBuffer[pos2+1]!='2' || pos2>pos)
d752 5
a756 1
					DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_REQUESTFAILED, (int)(LPCTSTR)m_strBuffer.Left(pos));
d763 1
a763 1
			if (m_strBuffer.Right(4)=="\r\n\r\n") //End of the HTTP header
d792 1
a792 1
	LPCSTR lpszAscii = CT2CA(lpszHostAddress);
d812 1
a812 1
				BOOL res=ConnectNext(m_ProxyData.ProxyHost,m_ProxyData.nProxyPort);
d817 1
a817 1
						DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, 0);
d823 4
a826 1
				m_ProxyPeerHost=lpszHostAddress;
d842 6
a847 1
		m_ProxyPeerHost=lpszHostAddress;
d865 3
a867 1
	m_ProxyPeerHost="";
d870 1
a870 1
	BOOL res=ConnectNext(m_ProxyData.ProxyHost,m_ProxyData.nProxyPort);
d875 1
a875 1
			DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, 0);
d899 1
a899 1
	USES_CONVERSION;
d902 1
a902 1
		DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, 0);
d922 1
a922 1
			LPCSTR lpszAscii=T2CA(m_ProxyPeerHost);
d932 1
a932 1
				ASSERT(m_ProxyPeerHost!="");
d1009 1
a1009 1
			CString str;
d1011 6
a1016 3
			CString Host;
			if (m_ProxyPeerHost!="")
				Host=m_ProxyPeerHost;
d1018 4
a1021 1
				Host.Format( _T("%d.%d.%d.%d"), m_nProxyPeerIp%256, (m_nProxyPeerIp>>8) % 256, (m_nProxyPeerIp>>16) %256, m_nProxyPeerIp>>24);
d1023 2
a1024 2
				str.Format(_T("CONNECT %s:%d HTTP/1.1\r\nHost: %s:%d\r\n\r\n"), Host, ntohs(m_nProxyPeerPort),
					Host, ntohs(m_nProxyPeerPort));
d1027 6
a1032 8
				str.Format(_T("CONNECT %s:%d HTTP/1.1\r\nHost: %s:%d\r\n"), Host, ntohs(m_nProxyPeerPort),
					Host, ntohs(m_nProxyPeerPort));
				CString userpass=m_ProxyData.ProxyUser+_T(":")+m_ProxyData.ProxyPass;
				CString base64str;
				CByteArray array;
				LPCSTR lpszAscii = T2CA(userpass);	
				for (UINT i=0;i<strlen(lpszAscii);i++)
					array.Add(lpszAscii[i]);
d1035 1
a1035 1
				if (!base64coding.Encode(array,base64str))
d1044 1
d1047 5
a1051 2
				str+=_T("Authorization: Basic ")+base64str+_T("\r\n");
				str+=_T("Proxy-Authorization: Basic ")+base64str+_T("\r\n\r\n");
d1053 3
a1055 2
			LPCSTR lpszAscii = T2CA(str);
			int numsent=SendNext(lpszAscii, strlen(lpszAscii) );
d1068 1
a1068 1
			else if (  numsent < static_cast<int>( strlen(lpszAscii) )  )
d1093 2
a1094 1
	m_strBuffer="";
d1113 1
a1113 1
	BOOL res=ConnectNext(m_ProxyData.ProxyHost,m_ProxyData.nProxyPort);
d1118 1
a1118 1
			DoLayerCallback(LAYERCALLBACK_LAYERSPECIFIC, PROXYERROR_NOCONN, 0);
a1163 34
 
BOOL CAsyncProxySocketLayer::GetPeerName( ULONG& rPeerIP, UINT& rPeerPort )
{
	EMULE_TRY
	if (m_ProxyData.nProxyType==PROXYTYPE_NOPROXY)
		return GetPeerNameNext(rPeerIP, rPeerPort);

	if (GetLayerState()==LAYERSTATE_NOTSOCK)
	{
		WSASetLastError(WSAENOTSOCK);
		return FALSE;
	}
	else if (GetLayerState()!=LAYERSTATE_CONNECTED)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}
	else if (!m_nProxyPeerIp || !m_nProxyPeerPort)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}

	ASSERT(m_ProxyData.nProxyType);
	BOOL res=GetPeerNameNext( rPeerIP, rPeerPort );
	if (res)
	{
		rPeerPort=ntohs(m_nProxyPeerPort);
		rPeerIP = m_nProxyPeerIp;
	}
	return res;
	EMULE_CATCH
	return FALSE;
}
d1211 8
d1256 1
a1266 1
	m_nProxyPeerPort = 3855;
d1283 27
@


1.7
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d1063 1
a1063 1
	if (GetLayerState()==notsock)
d1068 1
a1068 1
	else if (GetLayerState()!=connected)
d1097 1
a1097 1
	if (GetLayerState()==notsock)
d1102 1
a1102 1
	else if (GetLayerState()!=connected)
d1131 1
a1131 1
	if (GetLayerState()==notsock)
d1136 1
a1136 1
	else if (GetLayerState()!=connected)
d1216 1
a1216 1
	if (GetLayerState()!=notsock && GetLayerState()!=unconnected)
@


1.6
log
@unicode cleanup
@
text
@d260 1
a260 5
					#ifndef AMD
					memcpy(&ip,&m_pRecvBuffer[4],4);
					#else
					memcpy_amd(&ip,&m_pRecvBuffer[4],4);
					#endif
d282 1
a282 5
					#ifndef AMD
					memcpy(&port,&m_pRecvBuffer[2],2);
					#else
					memcpy_amd(&port,&m_pRecvBuffer[2],2);
					#endif
d436 1
a436 5
				#ifndef AMD
				memcpy(&command[len],&m_nProxyPeerIp,4);
				#else
				memcpy_amd(&command[len],&m_nProxyPeerIp,4);
				#endif
d445 1
a445 5
			#ifndef AMD
			memcpy(&command[len],&m_nProxyPeerPort,2);
			#else
			memcpy_amd(&command[len],&m_nProxyPeerPort,2);
			#endif
d508 1
a508 5
					#ifndef AMD
					memcpy(&command[len],&m_nProxyPeerIp,4);
					#else
					memcpy_amd(&command[len],&m_nProxyPeerIp,4);
					#endif
d517 1
a517 5
				#ifndef AMD
				memcpy(&command[len],&m_nProxyPeerPort,2);
				#else
				memcpy_amd(&command[len],&m_nProxyPeerPort,2);
				#endif
d582 1
a582 5
						#ifndef AMD
						memcpy(tmp,m_pRecvBuffer,5);
						#else
						memcpy_amd(tmp,m_pRecvBuffer,5);
						#endif
d606 2
a607 7
					#ifndef AMD
					memcpy(&ip,&m_pRecvBuffer[4],4);
					memcpy(&port,&m_pRecvBuffer[8],2);
					#else
					memcpy_amd(&ip,&m_pRecvBuffer[4],4);
					memcpy_amd(&port,&m_pRecvBuffer[8],2);
					#endif
d864 1
a864 5
			#ifndef AMD
			memcpy(&command[2],&m_nProxyPeerPort,2); //Copy target address
			#else
			memcpy_amd(&command[2],&m_nProxyPeerPort,2); //Copy target address
			#endif
d879 1
a879 5
				#ifndef AMD
				memcpy(&command[4],&m_nProxyPeerIp,4);
				#else
				memcpy_amd(&command[4],&m_nProxyPeerIp,4);
				#endif
@


1.5
log
@unicode cleanup
@
text
@d402 2
a403 2
					LPCTSTR lpszAsciiUser=T2CA(m_ProxyData.ProxyUser);
					LPCTSTR lpszAsciiPass=T2CA(m_ProxyData.ProxyPass);
d434 1
a434 1
			LPCTSTR lpszAsciiHost=T2CA(m_ProxyPeerHost);
d514 1
a514 1
				LPCTSTR lpszAsciiHost=T2CA(m_ProxyPeerHost);
d771 1
a771 1
	LPCTSTR lpszAscii = T2A((LPTSTR)lpszHostAddress);
d891 1
a891 1
			LPCTSTR lpszAscii=T2CA(m_ProxyPeerHost);
d1003 1
a1003 1
				LPCTSTR lpszAscii = T2CA(userpass);	
d1022 1
a1022 1
			LPCTSTR lpszAscii = T2CA(str);
@


1.4
log
@unicode cleanup
@
text
@d402 2
a403 2
					LPCSTR lpszAsciiUser=T2CA(m_ProxyData.ProxyUser);
					LPCSTR lpszAsciiPass=T2CA(m_ProxyData.ProxyPass);
d434 1
a434 1
			LPCSTR lpszAsciiHost=T2CA(m_ProxyPeerHost);
d514 1
a514 1
				LPCSTR lpszAsciiHost=T2CA(m_ProxyPeerHost);
d771 1
a771 1
	LPCSTR lpszAscii = T2A((LPTSTR)lpszHostAddress);
d891 1
a891 1
			LPCSTR lpszAscii=T2CA(m_ProxyPeerHost);
d1003 1
a1003 1
				LPCSTR lpszAscii = T2CA(userpass);	
d1022 1
a1022 1
			LPCSTR lpszAscii = T2CA(str);
@


1.3
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d719 1
a719 1
			CString start="HTTP/";
d1000 1
a1000 1
				CString userpass=m_ProxyData.ProxyUser+":"+m_ProxyData.ProxyPass;
d1019 2
a1020 2
				str+=_T("Authorization: Basic "+base64str+"\r\n");
				str+=_T("Proxy-Authorization: Basic "+base64str+"\r\n\r\n");
@


1.2
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d113 1
d260 1
d262 3
d286 1
d288 3
d444 1
d446 3
d457 1
d459 3
d524 1
d526 3
d537 1
d539 3
d606 1
d608 3
d634 1
d637 4
d897 1
d899 3
d916 1
d918 3
d1276 1
a1276 1
}@


1.1
log
@Maverick's proxy support
@
text
@d399 1
a399 1
					buffer[0]=5;
@


1.1.2.1
log
@updating this branch...
@
text
@@

