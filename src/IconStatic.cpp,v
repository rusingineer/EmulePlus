head	1.9;
access;
symbols
	PublicRelease_1_2e:1.9
	Interim_Release_1-2e_RC1:1.9
	PublicRelease_1_2d:1.8
	Interim_Release_1-2d_RC1:1.8
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.7
	Interim_Release_1-2c_RC1:1.7
	Interim_Release_1-2c_beta1:1.5
	PublicRelease_1_2b:1.5
	Interim_Release_1-2b_RC1:1.5
	PublicRelease_1_2a:1.5
	Interim_Release_1-2a_RC1:1.5
	Interim_Release_1-2a_beta2:1.5
	Interim_Release_1-2a_beta1:1.5
	PublicRelease_1_2:1.5
	Interim_Release_1-2_RC1:1.5
	Interim_Release_1-2_beta1:1.5
	PublicRelease_1_1g:1.5
	Interim_Release_1-1g_RC3:1.5
	Interim_Release_1-1g_RC2:1.5
	Interim_Release_1-1g_RC1:1.5
	Interim_Release_1-1g_beta2:1.5
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	Interim_Release_1n_beta1:1.4
	PublicRelease_1m:1.4
	Interim_Release_1m_beta1:1.4
	PublicRelease_1l:1.4
	Interim_Release_1l_RC3:1.4
	Interim_Release_1l_RC2:1.4
	Interim_Release_1l_RC1:1.4
	Interim_Release_1l_beta2:1.4
	Interim_Release_1l_beta1:1.4
	PublicRelease_1k:1.4
	Interim_Release_1k_RC4:1.4
	Interim_1k_RC3:1.4
	Interim_1k_RC2:1.4
	Interim_Release_1k_RC1:1.4
	Interim_Release_1k_beta5:1.4
	Intrerim_Release_1k_beta4:1.4
	Interim_Release_1k_beta1:1.4
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.3
	Interim_Release_1i_RC2:1.3
	Interim_Release_1i_RC1:1.3
	Interim_Release_1i_beta3:1.3
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.14
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.2
	threaded_downloadqueue:1.2.0.12
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.10
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.8
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.9
date	2008.10.17.04.52.33;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2008.03.03.04.46.28;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.30.00.13.49;	author kush_eplus;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.08.22.32.02;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.06.23.40.22;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.04.23.59.59;	author kush_eplus;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.14.18.08.22;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.17.23.28;	author kuchin;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.18;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.11;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Minor improvement to avoid similar calls.
@
text
@//this file is part of eMule
//Copyright (C)2002-2006 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "IconStatic.h"
#include "ThemeHelperST.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CIconStatic

CIconStatic::CIconStatic()
	: m_pTheme(NULL), m_uiIconID(0)
{
}

CIconStatic::~CIconStatic()
{
	if (m_MemBMP.GetSafeHandle() != NULL)
		m_MemBMP.DeleteObject();
}

BEGIN_MESSAGE_MAP(CIconStatic, CStatic)
	ON_WM_SYSCOLORCHANGE()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CIconStatic::Init(UINT uiIconID, CThemeHelperST *pTheme)
{
	m_uiIconID = uiIconID;
	m_pTheme = pTheme;

	Draw();
}

/////////////////////////////////////////////////////////////////////////////
void CIconStatic::SetText(const CString &strText)
{
	m_strText = strText;

	Draw();
}

/////////////////////////////////////////////////////////////////////////////
void CIconStatic::Draw()
{
//	If this function is called for the first time and we did not yet call 'SetWindowText', we take
//	the window label which is already specified for the window (the label which comes from the resource)
	CString	strText;

	GetWindowText(strText);
	SetWindowText(_T(""));
	if (!strText.IsEmpty() && m_strText.IsEmpty())
		m_strText = strText;

	CRect	rRect;

	GetClientRect(rRect);

	CDC		MemDC, *pDC = GetDC();
	CBitmap	*pOldBMP;

	MemDC.CreateCompatibleDC(pDC);

	CFont		*pOldFont = MemDC.SelectObject(GetFont());
	CRect		rCaption(0, 0, 0, 0);
	HTHEME		hTheme = NULL;
	LPOLESTR	oleTxt = NULL;
	int			iTxtLen = 0;

	if (m_pTheme != NULL && m_pTheme->IsThemeActive() && m_pTheme->IsAppThemed())
	{
		if ((hTheme = m_pTheme->OpenThemeData(GetSafeHwnd(), L"BUTTON")) != NULL)
		{
			USES_CONVERSION;

			oleTxt = CT2OLE(m_strText);
			iTxtLen = ocslen(oleTxt);
			m_pTheme->GetThemeTextExtent( hTheme, MemDC.m_hDC, BP_GROUPBOX, GBS_NORMAL, oleTxt, iTxtLen, 
				DT_SINGLELINE | DT_LEFT | DT_NOPREFIX, NULL, &rCaption );
		}
	}
	else
		MemDC.DrawText(m_strText, rCaption, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_NOPREFIX);

	if (rCaption.Height() < 16)
		rCaption.bottom = rCaption.top + 16;
	rCaption.right += 25;
	if (rRect.Width() >= 16 && rCaption.Width() > rRect.Width() - 16)
		rCaption.right = rCaption.left + rRect.Width() - 16;

	if (m_MemBMP.GetSafeHandle())
		m_MemBMP.DeleteObject();
	m_MemBMP.CreateCompatibleBitmap(pDC, rCaption.Width(), rCaption.Height());
	pOldBMP = MemDC.SelectObject(&m_MemBMP);

	MemDC.FillSolidRect(rCaption, GetSysColor(COLOR_BTNFACE));

	if (m_uiIconID != 0)
	{
		HICON	hIcon = (HICON)::LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uiIconID), IMAGE_ICON, 16,16, 0);

		DrawState(MemDC.m_hDC, NULL, NULL, (LPARAM)hIcon, NULL, 3, 0, 16, 16, DST_ICON | DSS_NORMAL);
		DestroyIcon(hIcon);

		rCaption.left += 22;
	}
	
	if (hTheme != NULL)
	{
		m_pTheme->DrawThemeText( hTheme, MemDC.m_hDC, BP_GROUPBOX, GBS_NORMAL, oleTxt, iTxtLen, 
			DT_SINGLELINE | DT_LEFT | DT_NOPREFIX | DT_END_ELLIPSIS, NULL, &rCaption ); 
		m_pTheme->CloseThemeData(hTheme);
	}
	else
	{
		MemDC.SetTextColor(pDC->GetTextColor());
		MemDC.DrawText(m_strText, rCaption, DT_SINGLELINE | DT_LEFT | DT_NOPREFIX | DT_END_ELLIPSIS);
	}

	MemDC.SelectObject(pOldBMP);
	MemDC.SelectObject(pOldFont);

	if (m_wndPicture.m_hWnd == NULL)
		m_wndPicture.Create(NULL, WS_CHILD | WS_VISIBLE | SS_BITMAP, CRect(0, 0, 0, 0), this);
	m_wndPicture.SetWindowPos(NULL, rRect.left + 8, rRect.top, rCaption.Width() + 22, rCaption.Height(), SWP_SHOWWINDOW);
	m_wndPicture.SetBitmap(m_MemBMP);

	CWnd	*pParent = GetParent();

	if (pParent == NULL)
		pParent = GetDesktopWindow();

	CRect	r;

	GetWindowRect(r);
	r.bottom = r.top + 20;
	pParent->ScreenToClient(&r);
	pParent->RedrawWindow(r);

	ReleaseDC(pDC);
}

void CIconStatic::OnSysColorChange()
{
	CStatic::OnSysColorChange();
	if (m_uiIconID != 0)
		Draw();
}
@


1.8
log
@Formatting; Removed unrequired include; Declare conversion macro only when it's required.
@
text
@d157 2
a158 2
	GetParent()->ScreenToClient(&r);
	GetParent()->RedrawWindow(r);
@


1.7
log
@Fixed Icon Static controls when used with certain themes {Vladimir (SV)}
@
text
@a20 1
#include "atlconv.h"
a65 2
	USES_CONVERSION;

d94 3
a96 1
			oleTxt = CT2OLE(m_strText); 
d129 1
a129 1
    {
@


1.6
log
@#include moved to C-file.
@
text
@d1 2
a2 1
// IconStatic.cpp
d4 13
a22 13
#ifdef THEMEAPI
#include <tmschema.h>
#else
#define	NO_THEMEAPI_FOUND

#define	BP_PUSHBUTTON	0x00000001
#define	PBS_NORMAL	0x00000001
#define	PBS_HOT		0x00000002
#define	PBS_PRESSED	0x00000003
#define	PBS_DISABLED	0x00000004
#define	PBS_DEFAULTED	0x00000005
#endif

d33 1
a34 2
	m_pTheme = NULL;
	m_nIconID = 0;
d39 1
a39 1
	if(m_MemBMP.GetSafeHandle())
d44 1
a44 3
	//{{AFX_MSG_MAP(CIconStatic)
		ON_WM_SYSCOLORCHANGE()
	//}}AFX_MSG_MAP
d48 10
a57 1
void CIconStatic::Init(UINT nIconID, CThemeHelperST *pTheme)
d59 1
a59 1
	USES_CONVERSION; // FoRcHa
d61 11
a71 2
	m_nIconID = nIconID;
	m_pTheme = pTheme;
a72 3
// If this function is called for the first time and we did not yet call 'SetWindowText', we take
// take the window label which is already specified for the window (the label which comes from the resource)
	CString strText;
d78 2
a79 1
	CRect rRect;
d82 3
a84 3
	CDC *pDC = GetDC();
	CDC MemDC;
	CBitmap *pOldBMP;
d87 18
a104 1
	CFont *pOldFont = MemDC.SelectObject(GetFont());
a105 2
	CRect rCaption(0,0,0,0);
	MemDC.DrawText(m_strText, rCaption, DT_CALCRECT);
d109 1
a109 1
	if (rCaption.Width() > rRect.Width() - 16)
a117 4
	HICON hIcon = (HICON)::LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_nIconID), IMAGE_ICON, 16,16, 0);
	DrawState(MemDC.m_hDC, NULL, NULL, (LPARAM)hIcon, NULL, 3, 0, 16, 16, DST_ICON | DSS_NORMAL);
	DestroyIcon(hIcon);
	rCaption.left += 22;
d119 6
a124 1
///////////////////////////////////
d126 1
a126 4
	BOOL bDefaultDraw = FALSE;
	if(m_pTheme == NULL || m_pTheme->IsAppThemed() == FALSE)
	{
		bDefaultDraw = TRUE;
d128 5
a132 11
	else
	{
		HTHEME	hTheme;

		if((hTheme = m_pTheme->OpenThemeData(GetSafeHwnd(), L"BUTTON")) != 0)
		{
/*
		BSTR str = A2WBSTR(m_strText); // FoRcHa
		m_pTheme->DrawThemeText(hTheme, MemDC.m_hDC, 4, 1, str, 
			m_strText.GetLength(), DT_WORDBREAK | DT_CENTER | DT_WORD_ELLIPSIS, 
			NULL, &rCaption);
a133 10
		SysFreeString(str); // FoRcHa
*/
			LPOLESTR oleText = CT2OLE(m_strText);
			m_pTheme->DrawThemeText(hTheme, MemDC.m_hDC, 4, 1, oleText, ocslen (oleText),
				DT_WORDBREAK | DT_CENTER | DT_WORD_ELLIPSIS, NULL, &rCaption);
		}
		else
		{
			bDefaultDraw = TRUE;
		}
d135 1
a135 2

	if (bDefaultDraw)
d138 1
a138 1
		MemDC.DrawText(m_strText, rCaption, DT_SINGLELINE | DT_LEFT | DT_END_ELLIPSIS);
d145 2
a146 2
		m_wndPicture.Create(NULL, WS_CHILD | WS_VISIBLE | SS_BITMAP, CRect(0,0,0,0), this);
	m_wndPicture.SetWindowPos(NULL, rRect.left+8, rRect.top, rCaption.Width()+22, rCaption.Height(), SWP_SHOWWINDOW);
d149 2
a150 1
	CWnd *pParent = GetParent();
d154 2
a155 1
	CRect r;
a163 6
void CIconStatic::SetText(const CString &strText)
{
	m_strText = strText;
	Init(m_nIconID, m_pTheme);
}

d167 2
a168 1
	Init(m_nIconID, m_pTheme);
@


1.5
log
@Clean-up; Remove unused services; Applied some corrections for Unicode.
@
text
@d6 1
@


1.4
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d1 1
a1 1
// IconStatic.cpp: Implementierungsdatei
d8 1
a8 1
#ifdef	THEMEAPI
d33 1
a33 2
	m_strText = "";
	m_nIconID = 0;     // i_a 
d38 1
a38 1
	if(m_MemBMP.GetSafeHandle()) // FoRcHa
a41 1

d49 1
a49 2
// Behandlungsroutinen für Nachrichten CIconStatic 
bool CIconStatic::Init(UINT nIconID, CThemeHelperST *pTheme)
d56 3
a58 1
	CString strText;	
d61 1
a61 1
	if(strText != "")
d69 1
a69 1
	CBitmap *pOldBMP; // FoRcHa
d72 1
a72 1
	CFont *pOldFont = MemDC.SelectObject(GetFont()); // FoRcHa
d76 1
a76 1
	if(rCaption.Height() < 16)
d79 1
a79 1
	if(rCaption.Width() > rRect.Width() - 16)
d82 1
a82 2
	// FoRcHa
	if(m_MemBMP.GetSafeHandle())
d88 2
a89 5
	HICON hIcon = (HICON)::LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_nIconID), IMAGE_ICON, 16,16, 0); // FoRcHa
	DrawState(MemDC.m_hDC, NULL, NULL, 
        // i_a: long --> LPARAM -- reduce number of warnings in VC7 
	// FoRcHa
        (LPARAM)hIcon, NULL, 3, 0, 16, 16, DST_ICON | DSS_NORMAL);
d92 3
a94 3
	
///////////////////////////////////		
	
d102 1
a102 2
		HTHEME	hTheme = NULL;
		int		iStateId = 0;
d104 2
a105 3
		hTheme = m_pTheme->OpenThemeData(GetSafeHwnd(), L"BUTTON");
		if(hTheme)
		{			
d113 4
a116 5
*/		// pooz
		LPOLESTR oleText = CT2OLE(m_strText);
		m_pTheme->DrawThemeText(hTheme, MemDC.m_hDC, 4, 1, oleText, ocslen (oleText), 
			DT_WORDBREAK | DT_CENTER | DT_WORD_ELLIPSIS, NULL, &rCaption);
		// end pooz
d119 1
a119 1
		{	
d122 1
a122 1
	} 
d131 3
a133 3
	MemDC.SelectObject(pOldFont); // FoRcHa
	
	if(m_wndPicture.m_hWnd == NULL)
a134 2
	
	m_wndPicture.GetBitmap();
d136 1
a136 1
	m_wndPicture.SetBitmap(m_MemBMP); // FoRcHa
d139 1
a139 1
	if(pParent == NULL)
d141 1
a141 1
	
d148 1
a148 2
	ReleaseDC(pDC); // FoRcHa
	return true;
d151 1
a151 1
bool CIconStatic::SetText(CString strText)
d154 1
a154 1
	return Init(m_nIconID, m_pTheme);
d157 1
a157 8
bool CIconStatic::SetIcon(UINT nIconID)
{
	return Init(nIconID, m_pTheme);
}



void CIconStatic::OnSysColorChange() 
d160 1
a160 1
	Init(m_nIconID, m_pTheme);	
a161 10

#ifdef	NO_THEMEAPI_FOUND
#undef	NO_THEMEAPI_FOUND
#undef	BP_PUSHBUTTON
#undef	PBS_NORMAL
#undef	PBS_HOT
#undef	PBS_PRESSED
#undef	PBS_DISABLED
#undef	PBS_DEFAULTED
#endif@


1.3
log
@unicode cleanup
@
text
@d55 1
a55 1
		
d106 1
a106 1
    	{
@


1.2
log
@*** empty log message ***
@
text
@d61 1
a61 1
	SetWindowText("");
d121 1
a121 1
		LPOLESTR oleText = T2OLE(m_strText);
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d113 15
a127 9
			BSTR str = A2WBSTR(m_strText); // FoRcHa
			m_pTheme->DrawThemeText(hTheme, MemDC.m_hDC, 4, 1, str, 
						m_strText.GetLength(), DT_WORDBREAK | DT_CENTER | DT_WORD_ELLIPSIS, 
							NULL, &rCaption);
			m_pTheme->CloseThemeData(hTheme);
			SysFreeString(str); // FoRcHa
	}
	else
	{	
@

