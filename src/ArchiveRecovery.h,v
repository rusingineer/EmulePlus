head	1.10;
access;
symbols
	PublicRelease_1_2e:1.10
	Interim_Release_1-2e_RC1:1.10
	PublicRelease_1_2d:1.9
	Interim_Release_1-2d_RC1:1.9
	Interim_Release_1-2d_beta1:1.9
	PublicRelease_1_2c:1.9
	Interim_Release_1-2c_RC1:1.9
	Interim_Release_1-2c_beta1:1.8
	PublicRelease_1_2b:1.8
	Interim_Release_1-2b_RC1:1.8
	PublicRelease_1_2a:1.8
	Interim_Release_1-2a_RC1:1.8
	Interim_Release_1-2a_beta2:1.8
	Interim_Release_1-2a_beta1:1.7
	PublicRelease_1_2:1.6
	Interim_Release_1-2_RC1:1.6
	Interim_Release_1-2_beta1:1.6
	PublicRelease_1_1g:1.6
	Interim_Release_1-1g_RC3:1.6
	Interim_Release_1-1g_RC2:1.6
	Interim_Release_1-1g_RC1:1.6
	Interim_Release_1-1g_beta2:1.6
	Interim_Release_1-1g_beta1:1.6
	PublicRelease_1_1f:1.6
	Interim_Release_1-1f_RC1:1.6
	PublicRelease_1_1e:1.6
	Interim_Release_1-1e_RC2:1.6
	Interim_Release_1-1e_RC1:1.6
	Interim_Release_1-1e_beta1:1.6
	PublicRelease_1_1d:1.6
	Interim_Release_1-1d_RC1:1.6
	PublicRelease_1_1c:1.6
	Interim_Release_1-1c_RC1:1.6
	Interim_Release_1-1c_beta2:1.6
	Interim_Release_1-1c_beta1:1.5
	PublicRelease_1_1b:1.3
	Interim_Release_1-1b_RC1:1.3
	PublicRelease_1_1a:1.3
	Interim_Release_1-1a_RC2:1.3
	Interim_Release_1-1a_RC1:1.3
	Interim_Release_1-1a_beta2:1.3
	Interim_Release_1-1a_beta1:1.3
	PublicRelease_1_1:1.3
	Interim_Release_1-1_beta1:1.3
	PublicRelease_1o:1.3
	Interim_Release_1o_RC1:1.3
	Interim_Release_1o_beta1:1.3
	PublicRelease_1n:1.3
	Interim_Release_1n_RC2:1.3
	Interim_Release_1n_RC1:1.3
	Interim_Release_1n_beta2:1.3
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.3
	Interim_Release_1l_RC1:1.3
	Interim_Release_1l_beta2:1.3
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.3
	Interim_Release_1k_RC4:1.3
	Interim_1k_RC3:1.3
	Interim_1k_RC2:1.3
	Interim_Release_1k_RC1:1.3
	Interim_Release_1k_beta5:1.3
	Intrerim_Release_1k_beta4:1.3
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.3
	Interim_Release_1i_RC2:1.3
	Interim_Release_1i_RC1:1.3
	Interim_Release_1i_beta3:1.3
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.3
	Interim_Release_1g_beta1:1.3
	Interim_Release_1f_RC4:1.3
	Interim_Release_1f_RC3:1.3
	Interim_Release_1f_RC2:1.3
	Interim_Release_1f_RC:1.3
	Interim_Release_1f_beta2:1.3
	Interim_Release_1f_beta1:1.3
	PublicRelease_1e:1.3
	Interim_Release_1e_RC2:1.3
	Interim_Release_1e_RC:1.3
	Interim_Release_1e_beta3:1.3
	Interim_Release_1e_beta2:1.3
	Interim_Release_1e_beta2_before_kuchin:1.3
	Interim_Release_1e_beta1:1.3
	PublicRelease_1c:1.3
	featurestest:1.3.0.4
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.2
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.1
	proxytest:1.1.2.1.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@ * @;


1.10
date	2008.09.29.04.49.35;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2007.03.18.15.37.19;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.05.11.55.54;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.17.07.04.20;	author aw3;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.03.19.48.07;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.19.17.10.12;	author netwolf1;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.06.19.00.59;	author netwolf1;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.14.15.59.53;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.12.20.18.20;	author obaldin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.14.18.00;	author cax2;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.55;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Applied minor corrections from original.
@
text
@//this file is part of eMule
//Copyright (C)2002-2006 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#pragma once

#include "Loggable.h"

class CPartFile;
struct Gap_Struct;

#define ZIP_LOCAL_HEADER_MAGIC		0x04034b50
#define ZIP_LOCAL_HEADER_EXT_MAGIC	0x08074b50
#define ZIP_CD_MAGIC				0x02014b50
#define ZIP_END_CD_MAGIC			0x06054b50
#define ZIP_COMMENT					"Recovered by eMule Plus"

#define RAR_HEAD_FILE 0x74

#pragma pack(1)
struct ZIP_Entry
{
	uint32	header;
	uint16	versionToExtract;
	uint16	generalPurposeFlag;
	uint16	compressionMethod;
	uint16	lastModFileTime;
	uint16	lastModFileDate;
	uint32	crc32;
	uint32	lenCompressed;
	uint32	lenUncompressed;
	uint16	lenFilename;
	uint16	lenExtraField;
	BYTE	*filename;
	BYTE	*extraField;
	BYTE	*compressedData;
};
#pragma pack()

#pragma pack(1)
struct ZIP_CentralDirectory
{
	uint32	header;
	uint16	versionMadeBy;
	uint16	versionToExtract;
	uint16	generalPurposeFlag;
	uint16	compressionMethod;
	uint16	lastModFileTime;
	uint16	lastModFileDate;
	uint32	crc32;
	uint32	lenCompressed;
	uint32	lenUncompressed;
	uint16	lenFilename;
	uint16	lenExtraField;
	uint16	lenComment;
	uint16	diskNumberStart;
	uint16	internalFileAttributes;
	uint32	externalFileAttributes;
	uint32	relativeOffsetOfLocalHeader;
	BYTE	*filename;
	BYTE	*extraField;
	BYTE	*comment;
};
#pragma pack()

#pragma pack(1)
struct RAR_BlockFile
{
	RAR_BlockFile()
	{
		EXT_DATE = NULL;
		EXT_DATE_SIZE = 0;
	}
	~RAR_BlockFile()
	{
		delete[] EXT_DATE;
	}

	// This indicates the position in the input file just after the filename
	ULONGLONG offsetData; 
	// This indicates how much of the block is after this offset
	uint32 dataLength;

	uint16	HEAD_CRC;
	BYTE	HEAD_TYPE;
	uint16	HEAD_FLAGS;
	uint16	HEAD_SIZE;
	uint32	PACK_SIZE;
	uint32	UNP_SIZE;
	BYTE	HOST_OS;
	uint32	FILE_CRC;
	uint32	FTIME;
	BYTE	UNP_VER;
	BYTE	METHOD;
	uint16	NAME_SIZE;
	uint32	ATTR;
	uint32	HIGH_PACK_SIZE;
	uint32	HIGH_UNP_SIZE;
	BYTE	*FILE_NAME;
	BYTE	*EXT_DATE;
	uint32	EXT_DATE_SIZE;
	BYTE	SALT[8];
};
#pragma pack()

struct ThreadParam
{
	CPartFile *partFile;
	CTypedPtrList<CPtrList, Gap_Struct*> *filled;
};

class CArchiveRecovery : public CLoggable
{
public:
	static void recover(CPartFile *partFile);

private:
	CArchiveRecovery(void); // Just use static recover method

	static UINT AFX_CDECL run(LPVOID lpParam);
	static bool performRecovery(CPartFile *partFile, CTypedPtrList<CPtrList, Gap_Struct*> *filled);

	static int recoverZip(CFile *zipInput, CFile *zipOutput, CTypedPtrList<CPtrList, Gap_Struct*> *filled, bool fullSize);
	static int recoverRar(CFile *rarInput, CFile *rarOutput, CTypedPtrList<CPtrList, Gap_Struct*> *filled);

	static bool scanForZipMarker(CFile *input, uint32 marker, uint32 available);
	static bool processZipEntry(CFile *zipInput, CFile *zipOutput, uint32 available, CTypedPtrList<CPtrList, ZIP_CentralDirectory*> *centralDirectoryEntries);
	static bool readZipCentralDirectory(CFile *zipInput, CTypedPtrList<CPtrList, ZIP_CentralDirectory*> *centralDirectoryEntries, CTypedPtrList<CPtrList, Gap_Struct*> *filled);

	static RAR_BlockFile *scanForRarFileHeader(CFile *input, uint64 qwAvailable);
	static bool validateRarFileBlock(RAR_BlockFile *block);
	static void writeRarBlock(CFile *input, CFile *output, RAR_BlockFile *block);

	static bool CopyFile(CPartFile *partFile, CTypedPtrList<CPtrList, Gap_Struct*> *filled, CString tempFileName);
	static void DeleteMemory(ThreadParam *tp);
	static bool IsFilled(uint64 start, uint64 end, CTypedPtrList<CPtrList, Gap_Struct*> *filled);

	static uint16 readUInt16(CFile *input);
	static uint32 readUInt32(CFile *input);
	static uint16 calcUInt16(BYTE *input);
	static uint32 calcUInt32(BYTE *input);
	static void writeUInt16(CFile *output, uint16 val);
	static void writeUInt32(CFile *output, uint32 val);
};
@


1.9
log
@Corrected report in the log about archive preview recovery status {Fuxie - DK};
Removed unused parameter.
@
text
@d64 1
a64 1
	uint32	lenUnompressed;
@


1.8
log
@Large file size support preparations.
@
text
@a121 1
	bool preview;
d127 1
a127 1
	static void recover(CPartFile *partFile, bool preview = false);
d133 1
a133 1
	static bool performRecovery(CPartFile *partFile, CTypedPtrList<CPtrList, Gap_Struct*> *filled, bool preview);
d135 2
a136 2
	static bool recoverZip(CFile *zipInput, CFile *zipOutput, CTypedPtrList<CPtrList, Gap_Struct*> *filled, bool fullSize);
	static bool recoverRar(CFile *rarInput, CFile *rarOutput, CTypedPtrList<CPtrList, Gap_Struct*> *filled);
@


1.7
log
@Reduced H-file dependency;
Added support for previewing encrypted and solid RAR archives (adapted from original).
@
text
@d143 1
a143 1
	static RAR_BlockFile *scanForRarFileHeader(CFile *input, uint32 available);
d149 1
a149 1
	static bool IsFilled(uint32 start, uint32 end, CTypedPtrList<CPtrList, Gap_Struct*> *filled);
@


1.6
log
@More ifdefs for v2
@
text
@d2 1
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
a16 1

a18 4
#ifndef NEW_SOCKETS_ENGINE
#include "emule.h"
#endif //NEW_SOCKETS_ENGINE
#include "PartFile.h"
d21 3
a30 6
#define RAR_START_OF_FILE {	\
0x52, 0x61, 0x72, 0x21, 0x1a, 0x07, 0x00, 0x08, 0x1A, 0x73, 0x02, 0x00, 0x3B, 0x00, 0x00, 0x00, \
0x00, 0x00, 0x00, 0x00, 0xCA, 0x44, 0x75, 0x00, 0x00, 0x2E, 0x00, 0x12, 0x00, 0x14, 0x34, 0x2B, \
0x4A, 0x08, 0x15, 0x48, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x01, 0x0A, 0x2B, 0xF9, 0x0E, 0xE2, 0xC1, \
0x32, 0xFB, 0x9E, 0x04, 0x10, 0x50, 0xD7, 0xFE, 0xCD, 0x75, 0x87, 0x9C, 0x28, 0x85, 0xDF, 0xA3, \
0x97, 0xE0 }
d32 1
a32 1
#pragma pack(1) //???
d79 1
a79 1
struct RAR_BlockFile 
d81 10
d95 1
a95 1
    
d112 3
@


1.5
log
@Fixed mem leak.
@
text
@d20 1
d22 1
@


1.4
log
@Minor string change (eMule -> eMule Plus).
@
text
@d126 2
a127 2
	static DWORD WINAPI CArchiveRecovery::run(LPVOID lpParam);
	static bool CArchiveRecovery::performRecovery(CPartFile *partFile, CTypedPtrList<CPtrList, Gap_Struct*> *filled, bool preview);
@


1.3
log
@converted to new logging method
@
text
@d28 1
a28 1
#define ZIP_COMMENT					"Recovered by eMule"
@


1.2
log
@more 26b merges
@
text
@d22 1
d118 1
a118 1
class CArchiveRecovery
@


1.1
log
@port to .25b codebase
@
text
@d37 1
d55 1
d57 1
d81 1
d83 1
d108 1
@


1.1.2.1
log
@updating this branch...
@
text
@@

