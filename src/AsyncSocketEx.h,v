head	1.8;
access;
symbols
	PublicRelease_1_2e:1.7
	Interim_Release_1-2e_RC1:1.7
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.7
	Interim_Release_1-2c_RC1:1.7
	Interim_Release_1-2c_beta1:1.7
	PublicRelease_1_2b:1.7
	Interim_Release_1-2b_RC1:1.7
	PublicRelease_1_2a:1.7
	Interim_Release_1-2a_RC1:1.7
	Interim_Release_1-2a_beta2:1.7
	Interim_Release_1-2a_beta1:1.7
	PublicRelease_1_2:1.7
	Interim_Release_1-2_RC1:1.7
	Interim_Release_1-2_beta1:1.6
	PublicRelease_1_1g:1.6
	Interim_Release_1-1g_RC3:1.6
	Interim_Release_1-1g_RC2:1.6
	Interim_Release_1-1g_RC1:1.6
	Interim_Release_1-1g_beta2:1.6
	Interim_Release_1-1g_beta1:1.6
	PublicRelease_1_1f:1.6
	Interim_Release_1-1f_RC1:1.6
	PublicRelease_1_1e:1.6
	Interim_Release_1-1e_RC2:1.6
	Interim_Release_1-1e_RC1:1.6
	Interim_Release_1-1e_beta1:1.6
	PublicRelease_1_1d:1.6
	Interim_Release_1-1d_RC1:1.6
	PublicRelease_1_1c:1.6
	Interim_Release_1-1c_RC1:1.6
	Interim_Release_1-1c_beta2:1.6
	Interim_Release_1-1c_beta1:1.6
	PublicRelease_1_1b:1.6
	Interim_Release_1-1b_RC1:1.6
	PublicRelease_1_1a:1.6
	Interim_Release_1-1a_RC2:1.6
	Interim_Release_1-1a_RC1:1.6
	Interim_Release_1-1a_beta2:1.6
	Interim_Release_1-1a_beta1:1.6
	PublicRelease_1_1:1.6
	Interim_Release_1-1_beta1:1.6
	PublicRelease_1o:1.6
	Interim_Release_1o_RC1:1.6
	Interim_Release_1o_beta1:1.6
	PublicRelease_1n:1.6
	Interim_Release_1n_RC2:1.6
	Interim_Release_1n_RC1:1.6
	Interim_Release_1n_beta2:1.6
	Interim_Release_1n_beta1:1.6
	PublicRelease_1m:1.6
	Interim_Release_1m_beta1:1.6
	PublicRelease_1l:1.6
	Interim_Release_1l_RC3:1.6
	Interim_Release_1l_RC2:1.6
	Interim_Release_1l_RC1:1.6
	Interim_Release_1l_beta2:1.6
	Interim_Release_1l_beta1:1.6
	PublicRelease_1k:1.6
	Interim_Release_1k_RC4:1.6
	Interim_1k_RC3:1.6
	Interim_1k_RC2:1.6
	Interim_Release_1k_RC1:1.6
	Interim_Release_1k_beta5:1.6
	Intrerim_Release_1k_beta4:1.6
	Interim_Release_1k_beta1:1.6
	PublicRelease_1j:1.6
	Interim_Release_1J_RC3:1.6
	Interim_Release_1j_RC3:1.6
	Interim_Release_1j_RC2:1.6
	Interim_Release_1j_RC1:1.6
	Interim_Release_1j_beta2:1.6
	Interim_Release_1j_beta1:1.6
	PublicRelease_1i:1.6
	Interim_Release_1i_RC6:1.6
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.6
	Interim_Release_1i_beta3:1.6
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.5
	PublicRelease_1h:1.4
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.4
	Interim_Release_1h_beta1_now:1.4
	Interim_Release_1h_beta1:1.4
	PublicRelease_1g:1.4
	Interim_Release_1g_RC6_Final:1.4
	Interim_Release_1g_RC6:1.4
	Interim_Release_1g_RC5:1.4
	Interim_Release_1g_RC4:1.4
	Interim_Release_1g_RC3:1.4
	Interim_Release_1g_beta2:1.4
	Interim_Release_1g_beta1:1.4
	Interim_Release_1f_RC4:1.4
	Interim_Release_1f_RC3:1.4
	Interim_Release_1f_RC2:1.4
	Interim_Release_1f_RC:1.4
	Interim_Release_1f_beta2:1.4
	Interim_Release_1f_beta1:1.4
	PublicRelease_1e:1.4
	Interim_Release_1e_RC2:1.4
	Interim_Release_1e_RC:1.4
	Interim_Release_1e_beta3:1.4
	Interim_Release_1e_beta2:1.4
	Interim_Release_1e_beta2_before_kuchin:1.3
	Interim_Release_1e_beta1:1.3
	PublicRelease_1c:1.3
	featurestest:1.3.0.4
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.2
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.10
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.8
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.1
	proxytest:1.1.2.1.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@ * @;


1.8
date	2011.09.05.19.27.29;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2006.02.15.05.25.53;	author aw3;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.12.22.39.04;	author dongato;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.30.10.20.52;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.22.12.41.50;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.14.16.17.13;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.14.12.45.16;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.15.36.57;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.8
log
@dynIP server filtering from original.
@
text
@/*CAsyncSocketEx by Tim Kosse (Tim.Kosse@@gmx.de)
            Version 1.2 (2003-03-28)
--------------------------------------------------------

Introduction:
-------------

CAsyncSocketEx is a replacement for the MFC class CAsyncSocket.
This class was written because CAsyncSocket is not the fastest WinSock
wrapper and it's very hard to add new functionality to CAsyncSocket
derived classes. This class offers the same functionality as CAsyncSocket.
Also, CAsyncSocketEx offers some enhancements which were not possible with
CAsyncSocket without some tricks.

How do I use it?
----------------
Basically exactly like CAsyncSocket.
To use CAsyncSocketEx, just replace all occurrences of CAsyncSocket in your
code with CAsyncSocketEx. If you did not enhance CAsyncSocket yourself in
any way, you won't have to change anything else in your code.

Why is CAsyncSocketEx faster?
-----------------------------

CAsyncSocketEx is slightly faster when dispatching notification event messages.
First have a look at the way CAsyncSocket works. For each thread that uses
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with
the handle of that window. Until here, CAsyncSocketEx works the same way.
But CAsyncSocket uses only one window message (WM_SOCKET_NOTIFY) for all
sockets within one thread. When the window receive WM_SOCKET_NOTIFY, wParam
contains the socket handle and the window looks up an CAsyncSocket instance
using a map. CAsyncSocketEx works differently. It's helper window uses a
wide range of different window messages (WM_USER through 0xBFFF) and passes
a different message to WSAAsyncSelect for each socket. When a message in
the specified range is received, CAsyncSocketEx looks up the pointer to a
CAsyncSocketEx instance in an Array using the index of message - WM_USER.
As you can see, CAsyncSocketEx uses the helper window in a more efficient
way, as it don't have to use the slow maps to lookup it's own instance.
Still, speed increase is not very much, but it may be noticeable when using
a lot of sockets at the same time.
Please note that the changes do not affect the raw data throughput rate,
CAsyncSocketEx only dispatches the notification messages faster.

What else does CAsyncSocketEx offer?
------------------------------------

CAsyncSocketEx offers a flexible layer system. One example is the proxy layer.
Just create an instance of the proxy layer, configure it and add it to the layer
chain of your CAsyncSocketEx instance. After that, you can connect through
proxies.
Benefit: You don't have to change much to use the layer system.
Another layer that is currently in development is the SSL layer to establish
SSL encrypted connections.

License
-------

Feel free to use this class, as long as you don't claim that you wrote it
and this copyright notice stays intact in the source files.
If you use this class in commercial applications, please send a short message
to tim.kosse@@gmx.de
*/
#pragma once

#define FD_FORCEREAD (1 << 15)

#include "Loggable.h"

#if defined(USE_SHARED_MFC) && (_MFC_VER==0x0700)
// See also: KB article Q316312 - BUG: Mfc70.lib Does Not Export AfxGetModuleThreadState
#define _afxSockThreadState AfxGetModuleState()->m_thread.GetDataNA()
#else
#define _afxSockThreadState AfxGetModuleThreadState()
#endif
#define _AFX_SOCK_THREAD_STATE AFX_MODULE_THREAD_STATE

class CAsyncSocketExHelperWindow;

#define WM_SOCKETEX_TRIGGER		(WM_USER + 0x101 + 0)				// 0x0501
#define WM_SOCKETEX_GETHOST		(WM_USER + 0x101 + 1)				// 0x0502
#define WM_SOCKETEX_NOTIFY		(WM_USER + 0x101 + 2)				// 0x0503
#define MAX_SOCKETS				(0xBFFF - WM_SOCKETEX_NOTIFY + 1)	// 0xBAFD 47869d


#ifndef NOLAYERS
class CAsyncSocketExLayer;
#endif //NOLAYERS
class CCriticalSectionWrapper;
class CAsyncSocketEx: public CLoggable
{
public:
	///////////////////////////////////////
	//Functions that imitate CAsyncSocket//
	///////////////////////////////////////

	//Construction
	//------------

	//Constructs a CAsyncSocketEx object.
	CAsyncSocketEx();
	virtual ~CAsyncSocketEx();

	//Creates a socket.
	BOOL Create(UINT nSocketPort = 0, int nSocketType = SOCK_STREAM,
				long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT |	FD_CONNECT | FD_CLOSE,
				LPCSTR lpszSocketAddress = NULL);


	//Attributes
	//----------

	//Attaches a socket handle to a CAsyncSocketEx object.
	BOOL Attach(SOCKET hSocket, long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

	//Detaches a socket handle from a CAsyncSocketEx object.
	SOCKET Detach();

	//Gets the error status for the last operation that failed.
	static int GetLastError();

	//Gets the address of the peer socket to which the socket is connected.
#ifdef _AFX
	BOOL GetPeerName(CString& rPeerAddress, UINT& rPeerPort);
#endif
	BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);

	//Gets the local name for a socket.
#ifdef _AFX
	BOOL GetSockName(CString& rSocketAddress, UINT& rSocketPort);
#endif
	BOOL GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);

	//Retrieves a socket option.
	BOOL GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel = SOL_SOCKET);

	//Sets a socket option.
	BOOL SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel = SOL_SOCKET);


	//Operations
	//----------

	//Accepts a connection on the socket.
	virtual BOOL Accept(CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);

	//Requests event notification for the socket.
	BOOL AsyncSelect(long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

	//Associates a local address with the socket.
	BOOL Bind(UINT nSocketPort, LPCSTR lpszSocketAddress);
	BOOL Bind(const SOCKADDR* lpSockAddr, int nSockAddrLen);

	//Closes the socket.
	virtual void Close();

	//Establishes a connection to a peer socket.
	virtual BOOL Connect(LPCSTR lpszHostAddress, UINT nHostPort);
	virtual BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);

	//Controls the mode of the socket.
	BOOL IOCtl(long lCommand, DWORD* lpArgument);

	//Establishes a socket to listen for incoming connection requests.
	BOOL Listen(int nConnectionBacklog = 5);

	//Receives data from the socket.
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

	//Sends data to a connected socket.
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);

	//Disables Send and/or Receive calls on the socket.
	BOOL ShutDown(int nHow = sends);
	enum { receives = 0, sends = 1, both = 2 };

	//Overridable Notification Functions
	//----------------------------------

	//Notifies a listening socket that it can accept pending connection requests by calling Accept.
	virtual void OnAccept(int nErrorCode);

	//Notifies a socket that the socket connected to it has closed.
	virtual void OnClose(int nErrorCode);

	//Notifies a connecting socket that the connection attempt is complete, whether successfully or in error.
	virtual void OnConnect(int nErrorCode);

	//Notifies a listening socket that there is data to be retrieved by calling Receive.
	virtual void OnReceive(int nErrorCode);

	//Notifies a socket that it can send data by calling Send.
	virtual void OnSend(int nErrorCode);

	virtual BOOL OnHostNameResolved(const SOCKADDR_IN *pSockAddr);

	////////////////////////
	//Additional functions//
	////////////////////////

#ifndef NOLAYERS
	//Resets layer chain.
	virtual void RemoveAllLayers();

	//Attaches a new layer to the socket.
	BOOL AddLayer(CAsyncSocketExLayer *pLayer);
#endif //NOLAYERS

	//Returns the handle of the socket.
	SOCKET GetSocketHandle();

	//Trigers an event on the socket
	// Any combination of FD_READ, FD_WRITE, FD_CLOSE, FD_ACCEPT, FD_CONNECT and FD_FORCEREAD is valid for lEvent.
	BOOL TriggerEvent(long lEvent);

protected:
	//Strucure to hold the socket data
	struct t_AsyncSocketExData
	{
		SOCKET hSocket; //Socket handle
		int nSocketIndex; //Index of socket, required by CAsyncSocketExHelperWindow
	} m_SocketData;

	//If using layers, only the events specified with m_lEvent will send to the event handlers.
	long m_lEvent;

	//AsyncGetHostByName
	char *m_pAsyncGetHostByNameBuffer; //Buffer for hostend structure
	HANDLE m_hAsyncGetHostByNameHandle; //TaskHandle
	int m_nAsyncGetHostByNamePort; //Port to connect to

	//Returns the handle of the helper window
	HWND GetHelperWindowHandle();

	//Attaches socket handle to helper window
	void AttachHandle(SOCKET hSocket);

	//Detaches socket handle to helper window
	void DetachHandle(SOCKET hSocket);

	//Critical section for thread synchronization
	static CCriticalSectionWrapper m_sGlobalCriticalSection;

	//Pointer to the data of the local thread
	struct t_AsyncSocketExThreadData
	{
		CAsyncSocketExHelperWindow *m_pHelperWindow;
		int nInstanceCount;
		DWORD nThreadId;
	} *m_pLocalAsyncSocketExThreadData;

	//List of the data structures for all threads
	static struct t_AsyncSocketExThreadDataList
	{
		t_AsyncSocketExThreadDataList *pNext;
		t_AsyncSocketExThreadData *pThreadData;
	} *m_spAsyncSocketExThreadDataList;

	//Initializes Thread data and helper window, fills m_pLocalAsyncSocketExThreadData
	BOOL InitAsyncSocketExInstance();

	//Destroys helper window after last instance of CAsyncSocketEx in current thread has been closed
	void FreeAsyncSocketExInstance();

#ifndef NOLAYERS
	//Layer chain
	CAsyncSocketExLayer *m_pFirstLayer;
	CAsyncSocketExLayer *m_pLastLayer;

	friend CAsyncSocketExLayer;

	//Called by the layers to notify application of some events
	virtual int OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nCode, WPARAM wParam, LPARAM lParam);
#endif //NOLAYERS

	friend CAsyncSocketExHelperWindow;
};

#ifndef NOLAYERS
#define LAYERCALLBACK_STATECHANGE	0
#define LAYERCALLBACK_LAYERSPECIFIC	1
#endif //NOLAYERS
@


1.7
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues.
@
text
@d194 2
@


1.6
log
@Katsyonak update
@
text
@d30 1
a30 1
sockets within one thread. When the window recieve WM_SOCKET_NOTIFY, wParam
a62 5

#if !defined(AFX_ASYNCSOCKETEX_H__AA9E4531_63B1_442F_9A71_09B2FEEDF34E__INCLUDED_)
#define AFX_ASYNCSOCKETEX_H__AA9E4531_63B1_442F_9A71_09B2FEEDF34E__INCLUDED_

#if _MSC_VER > 1000
a63 1
#endif // _MSC_VER > 1000
d65 1
a65 1
#define FD_FORCEREAD (1<<15)
a66 1
#include "winsock.h"
d79 4
a82 4
#define WM_SOCKETEX_TRIGGER		(WM_USER+0x101+0)				// 0x0501
#define WM_SOCKETEX_GETHOST		(WM_USER+0x101+1)				// 0x0502
#define WM_SOCKETEX_NOTIFY		(WM_USER+0x101+2)				// 0x0503
#define MAX_SOCKETS				(0xBFFF-WM_SOCKETEX_NOTIFY+1)	// 0xBAFD 47869d
d106 1
a106 1
				LPCTSTR lpszSocketAddress = NULL );
d110 1
a110 1
	//---------
d113 1
a113 3
	BOOL Attach( SOCKET hSocket,
				long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT |
				FD_CONNECT | FD_CLOSE );
d116 1
a116 1
	SOCKET Detach( );
d123 1
a123 1
	BOOL GetPeerName( CString& rPeerAddress, UINT& rPeerPort );
d125 1
a125 1
	BOOL GetPeerName( SOCKADDR* lpSockAddr, int* lpSockAddrLen );
d129 1
a129 1
	BOOL GetSockName( CString& rSocketAddress, UINT& rSocketPort );
d131 1
a131 1
	BOOL GetSockName( SOCKADDR* lpSockAddr, int* lpSockAddrLen );
d144 1
a144 1
	virtual BOOL Accept( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL );
d147 1
a147 1
	BOOL AsyncSelect( long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE );
d150 1
a150 1
	BOOL Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress);
d157 2
a158 2
	virtual BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	virtual BOOL Connect( const SOCKADDR* lpSockAddr, int nSockAddrLen );
d161 1
a161 1
	BOOL IOCtl( long lCommand, DWORD* lpArgument );
d164 1
a164 1
	BOOL Listen( int nConnectionBacklog = 5 );
d173 1
a173 1
	BOOL ShutDown( int nHow = sends );
d270 1
a270 1
	virtual int OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);
d277 2
a278 2
#define LAYERCALLBACK_STATECHANGE 0
#define LAYERCALLBACK_LAYERSPECIFIC 1
a279 2

#endif // !defined(AFX_ASYNCSOCKETEX_H__AA9E4531_63B1_442F_9A71_09B2FEEDF34E__INCLUDED_)
@


1.5
log
@Official code merge (katsyonak)
@
text
@d8 3
a10 3
CAsyncSocketEx is a replacement for the MFC class CAsyncSocket. 
This class was written because CAsyncSocket is not the fastest WinSock 
wrapper and it's very hard to add new functionality to CAsyncSocket 
d27 1
a27 1
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with 
d34 1
a34 1
a different message to WSAAsyncSelect for each socket. When a message in 
d37 1
a37 1
As you can see, CAsyncSocketEx uses the helper window in a more efficient 
d41 1
a41 1
Please note that the changes do not affect the raw data throughput rate, 
d96 1
a96 1
class CAsyncSocketEx : public CLoggable
d115 1
a115 1
	
d117 1
a117 1
	//---------	
d120 1
a120 1
	BOOL Attach( SOCKET hSocket, 
d123 1
a123 1
	
d147 1
a147 1
	
d164 1
a164 1
	
d174 1
a174 1
	
d177 1
a177 1
	
d181 1
a181 1
	//Disables Send and/or Receive calls on the socket.	
a184 10
	//By Maverick
	int ReceiveFrom(void* lpBuf, int nBufLen,
		CString& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
	int ReceiveFrom(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags = 0)
		{ return ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags); }
	int SendTo(const void* lpBuf, int nBufLen,
		UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
	int SendTo(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags = 0)
		{ return SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags); }
d190 1
a190 1
	
d202 1
a202 2
	
	virtual void CAsyncSocketEx::OnOutOfBandData(int nErrorEode);
d249 1
a249 1
	
d264 1
a264 1
	
a270 9
	//By Maverick
	CAsyncSocketEx* PASCAL LookupHandle(SOCKET hSocket, BOOL bDead = FALSE);
	void PASCAL DoCallBack(WPARAM wParam, LPARAM lParam);
	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);

d281 1
a281 1
	
@


1.4
log
@Upgrade to 0.28a
@
text
@d2 1
a2 1
            Version 1.1 (2002-11-01)
d75 5
d81 1
d86 6
d95 2
a96 1
class CAsyncSocketEx : public CLoggable 
d112 1
a112 2
				long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT |
							FD_CONNECT | FD_CLOSE, 
d116 1
a116 1
	//Atributes
a132 1
	BOOL GetPeerName( ULONG& rPeerIP, UINT& rPeerPort );
d244 5
d256 1
a256 1
	void PASCAL DetachHandle(SOCKET hSocket);
d259 1
a259 1
	static CRITICAL_SECTION m_sGlobalCriticalSection;
@


1.3
log
@converted to new logging method
@
text
@d243 1
a243 2
	//static CRITICAL_SECTION m_sGlobalCriticalSection;
	static CMutex m_sGlobalMutex;
@


1.2
log
@*** empty log message ***
@
text
@d74 1
d83 1
a83 1
class CAsyncSocketEx  
@


1.1
log
@Maverick's proxy support
@
text
@d242 2
a243 1
	static CRITICAL_SECTION m_sGlobalCriticalSection;
@


1.1.2.1
log
@updating this branch...
@
text
@@

