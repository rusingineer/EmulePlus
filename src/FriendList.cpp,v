head	1.45;
access;
symbols
	PublicRelease_1_2e:1.45
	Interim_Release_1-2e_RC1:1.45
	PublicRelease_1_2d:1.44
	Interim_Release_1-2d_RC1:1.44
	Interim_Release_1-2d_beta1:1.44
	PublicRelease_1_2c:1.44
	Interim_Release_1-2c_RC1:1.44
	Interim_Release_1-2c_beta1:1.43
	PublicRelease_1_2b:1.43
	Interim_Release_1-2b_RC1:1.43
	PublicRelease_1_2a:1.43
	Interim_Release_1-2a_RC1:1.43
	Interim_Release_1-2a_beta2:1.43
	Interim_Release_1-2a_beta1:1.43
	PublicRelease_1_2:1.42
	Interim_Release_1-2_RC1:1.42
	Interim_Release_1-2_beta1:1.42
	PublicRelease_1_1g:1.42
	Interim_Release_1-1g_RC3:1.42
	Interim_Release_1-1g_RC2:1.42
	Interim_Release_1-1g_RC1:1.42
	Interim_Release_1-1g_beta2:1.40
	Interim_Release_1-1g_beta1:1.40
	PublicRelease_1_1f:1.40
	Interim_Release_1-1f_RC1:1.40
	PublicRelease_1_1e:1.40
	Interim_Release_1-1e_RC2:1.40
	Interim_Release_1-1e_RC1:1.40
	Interim_Release_1-1e_beta1:1.40
	PublicRelease_1_1d:1.39
	Interim_Release_1-1d_RC1:1.39
	PublicRelease_1_1c:1.39
	Interim_Release_1-1c_RC1:1.39
	Interim_Release_1-1c_beta2:1.39
	Interim_Release_1-1c_beta1:1.37
	PublicRelease_1_1b:1.37
	Interim_Release_1-1b_RC1:1.37
	PublicRelease_1_1a:1.37
	Interim_Release_1-1a_RC2:1.37
	Interim_Release_1-1a_RC1:1.37
	Interim_Release_1-1a_beta2:1.37
	Interim_Release_1-1a_beta1:1.37
	PublicRelease_1_1:1.37
	Interim_Release_1-1_beta1:1.37
	PublicRelease_1o:1.37
	Interim_Release_1o_RC1:1.37
	Interim_Release_1o_beta1:1.37
	PublicRelease_1n:1.37
	Interim_Release_1n_RC2:1.37
	Interim_Release_1n_RC1:1.37
	Interim_Release_1n_beta2:1.36
	Interim_Release_1n_beta1:1.35
	PublicRelease_1m:1.33
	Interim_Release_1m_beta1:1.33
	PublicRelease_1l:1.33
	Interim_Release_1l_RC3:1.33
	Interim_Release_1l_RC2:1.33
	Interim_Release_1l_RC1:1.33
	Interim_Release_1l_beta2:1.33
	Interim_Release_1l_beta1:1.32
	PublicRelease_1k:1.31
	Interim_Release_1k_RC4:1.31
	Interim_1k_RC3:1.31
	Interim_1k_RC2:1.31
	Interim_Release_1k_RC1:1.31
	Interim_Release_1k_beta5:1.31
	Intrerim_Release_1k_beta4:1.31
	Interim_Release_1k_beta1:1.30
	PublicRelease_1j:1.28
	Interim_Release_1J_RC3:1.28
	Interim_Release_1j_RC3:1.28
	Interim_Release_1j_RC2:1.28
	Interim_Release_1j_RC1:1.28
	Interim_Release_1j_beta2:1.28
	Interim_Release_1j_beta1:1.28
	PublicRelease_1i:1.25
	Interim_Release_1i_RC6:1.25
	Interim_Release_1i_RC3:1.25
	Interim_Release_1i_RC2:1.25
	Interim_Release_1i_RC1:1.25
	Interim_Release_1i_beta3:1.25
	Interim_Release_1i_beta2:1.23
	Interim_Release_1i_beta1:1.19
	PublicRelease_1h:1.16
	Interim_Release_1h_rc2:1.16
	Interim_Release_1h_RC1:1.16
	Interim_Release_1h_beta2:1.16
	Interim_Release_1h_beta1_now:1.14
	Interim_Release_1h_beta1:1.14
	PublicRelease_1g:1.14
	Interim_Release_1g_RC6_Final:1.14
	Interim_Release_1g_RC6:1.14
	Interim_Release_1g_RC5:1.14
	Interim_Release_1g_RC4:1.14
	Interim_Release_1g_RC3:1.14
	Interim_Release_1g_beta2:1.14
	Interim_Release_1g_beta1:1.10
	Interim_Release_1f_RC4:1.10
	Interim_Release_1f_RC3:1.10
	Interim_Release_1f_RC2:1.9
	Interim_Release_1f_RC:1.9
	Interim_Release_1f_beta2:1.9
	Interim_Release_1f_beta1:1.9
	PublicRelease_1e:1.9
	Interim_Release_1e_RC2:1.9
	Interim_Release_1e_RC:1.9
	Interim_Release_1e_beta3:1.9
	Interim_Release_1e_beta2:1.9
	Interim_Release_1e_beta2_before_kuchin:1.9
	Interim_Release_1e_beta1:1.9
	PublicRelease_1c:1.9
	featurestest:1.9.0.2
	Interim_Release_1c_RC:1.9
	Interim_Release_1c_beta2:1.9
	Interim_Release_1c_beta1:1.7
	threaded_downloadqueue:1.7.0.2
	PublicRelease_1b:1.5
	Interim_Release_1b_beta2:1.5
	Interim_Release_1b_beta1:1.5
	proxydeadlake:1.5.0.4
	PublicRelease_1a:1.5
	Interim_Release_1a_beta2:1.5
	BerkeleyDb:1.5.0.2
	Interim_Release_1a_beta1:1.5
	PublicRelease_1:1.5
	goldfish:1.5
	eMulePlus_1_RC2:1.4
	eMulePlus_26b_1RC1:1.4
	PreRelease_26b_i0e:1.4
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.45
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.23.03.45.19;	author aw3;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.42;

1.42
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.41;

1.41
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.04.02.56.37;	author aw3;	state Exp;
branches;
next	1.39;

1.39
date	2005.02.12.21.49.57;	author aw3;	state Exp;
branches;
next	1.38;

1.38
date	2005.02.07.04.58.21;	author aw3;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.35;

1.35
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.05.21.04.49;	author aw3;	state Exp;
branches;
next	1.33;

1.33
date	2004.05.19.10.34.22;	author netwolf1;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.04.09.45.35;	author netwolf1;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.25.17.58.55;	author kush_eplus;	state Exp;
branches;
next	1.30;

1.30
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.07.01.26.46;	author netwolf1;	state Exp;
branches;
next	1.28;

1.28
date	2003.12.24.01.21.13;	author katsyonak;	state Exp;
branches;
next	1.27;

1.27
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.26;

1.26
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.26.10.54.37;	author katsyonak;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.15.14.15.33;	author morevit;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.08.15.39.48;	author morevit;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.23.19.01.32;	author netwolf1;	state Exp;
branches;
next	1.18;

1.18
date	2003.09.22.16.44.45;	author morevit;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.08.18.06.18;	author partyckip;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.06.20.37.17;	author partyckip;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.06.20.04.35;	author partyckip;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.20.20.46.27;	author netwolf1;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.17.12.12.34;	author recdvst;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.17.05.59.30;	author recdvst;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.14.16.24.17;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.12.17.25.41;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.20.14.29.01;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.09.18.39.41;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.18;	author cax2;	state Exp;
branches
	1.1.4.1
	1.1.6.1;
next	;

1.1.4.1
date	2003.01.28.16.54.09;	author cax2;	state Exp;
branches;
next	;

1.1.6.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Simplified logging system implementation.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "FriendList.h"
#include "updownclient.h"
#include "Friend.h"
#include "emule.h"
#include "SafeFile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define EMFRIENDS_MET_FILENAME	_T("emfriends.met")

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFriendList::CFriendList(void)
{
	LoadList();
	m_nLastSaved = ::GetTickCount();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFriendList::~CFriendList(void)
{
	SaveList();
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL; )
		delete m_listFriends.GetNext(pos);
	m_listFriends.RemoveAll();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	LoadList() loads the users friends list from the "emfriends.met" file.
bool CFriendList::LoadList()
{
	CFriend				*pFriend = NULL;
	CSafeBufferedFile	file;

	try
	{
		CString	strFileName = g_App.m_pPrefs->GetConfigDir() + EMFRIENDS_MET_FILENAME;

		if (!file.Open(strFileName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyWrite))
			return false;

		byte	header;

		file.Read(&header, 1);
		if (header != MET_HEADER)
		{
			file.Close();
			return false;
		}
		uint32	nFriendsNumber;

		file.Read(&nFriendsNumber, 4);
		for (uint32 i = 0; i < nFriendsNumber; i++)
		{
			pFriend = new CFriend();
			pFriend->LoadFromFile(file);
			m_listFriends.AddTail(pFriend);
		}
		file.Close();
		return true;
	}
	catch (CFileException * error)
	{
		OUTPUT_DEBUG_TRACE();
		if (error->m_cause == CFileException::endOfFile)
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_EMFRIENDSINVALID);
		else
		{
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_READEMFRIENDS, GetErrorMessage(error));
		}
		error->Delete();
		g_App.m_pMDlg->DisableAutoBackup();

		return false;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFriendList::SaveList()
{
	m_nLastSaved = ::GetTickCount();
	CStdioFile file;
	CString strFileName = g_App.m_pPrefs->GetConfigDir() + EMFRIENDS_MET_FILENAME;

	if (!file.Open(strFileName, CFile::modeCreate | CFile::modeWrite | CFile::typeBinary | CFile::shareDenyWrite))
		return;
	byte header = MET_HEADER;
	file.Write(&header, 1);
	uint32 nRecordsNumber = m_listFriends.GetCount();
	file.Write(&nRecordsNumber, 4);
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL;)
	{
		m_listFriends.GetNext(pos)->WriteToFile(file);
	}
	file.Close();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFriend* CFriendList::SearchFriend(const uchar *abyUserHash, uint32 m_dwIP, uint16 m_uPort) const {

	POSITION pos = m_listFriends.GetHeadPosition();

	while (pos != NULL)
	{
		CFriend *pFriend = m_listFriends.GetNext(pos);
	//	To avoid that an unwanted clients becomes a friend, we have to distinguish between friends with
	//	a userhash and friends which are identified by IP + port only.
		if (pFriend->m_dwHasHash)
		{
		//	Check for a friend which has the same userhash as the specified one
			if (!md4cmp(pFriend->GetUserHash(), abyUserHash))
				return pFriend;
		}
		else
		{
			if (pFriend->m_dwLastUsedIP == m_dwIP && pFriend->m_nLastUsedPort == m_uPort)
				return pFriend;
		}
	}
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFriendList::RefreshFriend(CFriend *pFriend) const
{
	if (m_pctlFriendList != NULL && ::IsWindow(m_pctlFriendList->m_hWnd))
		m_pctlFriendList->RefreshFriend(pFriend);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFriendList::ShowFriends() const
{
	if (!m_pctlFriendList)
	{
		ASSERT (false);
		return;
	}
	m_pctlFriendList->DeleteAllItems();
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL; )
	{
		CFriend * cur_friend = m_listFriends.GetNext(pos);
		m_pctlFriendList->AddFriend(cur_friend);
	}
}

//Added this to work with the IRC.. Probably a better way to do it.. But wanted this in the release..
bool CFriendList::AddFriend(uchar t_m_abyUserhash[16], uint32 tm_dwLastSeen, uint32 tm_dwLastUsedIP, uint32 tm_nLastUsedPort, uint32 tm_dwLastChatted, CString tm_strName, uint32 tm_dwHasHash)
{
	// client must have an IP (HighID) or a hash
	if (tm_dwLastUsedIP<16777216 && tm_dwHasHash==0)
		return false;
	if ( tm_dwLastUsedIP && IsAlreadyFriend(tm_dwLastUsedIP, tm_nLastUsedPort))
		return false;
	CFriend* Record = new CFriend(t_m_abyUserhash, tm_dwLastSeen, tm_dwLastUsedIP, tm_nLastUsedPort, tm_dwLastChatted, tm_strName, tm_dwHasHash);
	m_listFriends.AddTail(Record);
	ShowFriends();
	return true;
}

//	Added for the friends function in the IRC..
bool CFriendList::IsAlreadyFriend(uint32 tm_dwLastUsedIP, uint32 tm_nLastUsedPort)
{
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL; )
	{
		CFriend * cur_friend = m_listFriends.GetNext(pos);
		if (cur_friend->m_dwLastUsedIP == tm_dwLastUsedIP && cur_friend->m_nLastUsedPort == tm_nLastUsedPort)
		{
			return true;
		}
	}
	return false;
}

bool CFriendList::AddFriend(CUpDownClient *pClient)
{
	if (pClient->IsFriend())
		return false;
	// client must have an IP (HighID) or a hash
	if (pClient->HasLowID() && !pClient->HasValidHash())
		return false;
	CFriend* NewFriend = new CFriend(pClient);
	pClient->m_pFriend = NewFriend;
	m_listFriends.AddTail(NewFriend);
	if (m_pctlFriendList)
		m_pctlFriendList->AddFriend(NewFriend);

	g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
	g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.UpdateClient(pClient);
	g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
	g_App.m_pDownloadList->UpdateSource(pClient);
	return true;
}

void CFriendList::RemoveFriend(CFriend *pToDel)
{
	POSITION pos = m_listFriends.Find(pToDel);
	if (!pos)
	{
		ASSERT (false);
		return;
	}

	pToDel->SetLinkedClient(NULL);

	if (m_pctlFriendList)
		m_pctlFriendList->RemoveFriend(pToDel);
	m_listFriends.RemoveAt(pos);
	delete pToDel;
}

void CFriendList::RemoveFriend(CUpDownClient *pClient)
{
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL;)
	{
		CFriend	*pFriend = m_listFriends.GetNext(pos);
		if (pFriend->m_dwLastUsedIP == pClient->GetIP() && pFriend->m_nLastUsedPort == pClient->GetUserPort())
		{
			RemoveFriend(pFriend);
			g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
			g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.UpdateClient(pClient);
			g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
			g_App.m_pDownloadList->UpdateSource(pClient);
			break;
		}
	}
}

void CFriendList::Process()
{
	if (::GetTickCount() - m_nLastSaved > MIN2MS(25))	// save every 25 minutes
		SaveList();
}@


1.44
log
@Reduced #include dependency.
@
text
@d85 1
a85 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_EMFRIENDSINVALID));
d88 1
a88 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_READEMFRIENDS), GetErrorMessage(error));
@


1.43
log
@Reduced H-file dependency.
@
text
@d23 1
@


1.42
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d20 2
@


1.41
log
@renamed 3 variables
@
text
@d53 1
a53 1
		CString	strFileName = g_App.g_pPrefs->GetConfigDir() + EMFRIENDS_MET_FILENAME;
d98 1
a98 1
	CString strFileName = g_App.g_pPrefs->GetConfigDir() + EMFRIENDS_MET_FILENAME;
@


1.40
log
@Fixed friend state update in known clients list when state is changed in download list.
@
text
@d53 1
a53 1
		CString	strFileName = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + EMFRIENDS_MET_FILENAME;
d88 1
a88 1
		g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d98 1
a98 1
	CString strFileName = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + EMFRIENDS_MET_FILENAME;
d199 4
a202 4
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(pClient);
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
	g_eMuleApp.m_pDownloadList->UpdateSource(pClient);
d231 4
a234 4
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
			g_eMuleApp.m_pDownloadList->UpdateSource(pClient);
@


1.39
log
@Faster loading and saving of configuration files;
Removed friend list saving to emfriends.met on friend addition and removal to increase performance
(now it is saved only by 25 min timer and on closure).
@
text
@d186 1
a186 1
bool CFriendList::AddFriend(CUpDownClient* pClient)
d198 1
a198 1
//	MOREVIT - I'm betting we don't need the throttle if we use the message queue
d201 1
d206 1
a206 1
void CFriendList::RemoveFriend(CFriend* todel)
d208 1
a208 1
	POSITION pos = m_listFriends.Find(todel);
d215 1
a215 1
	todel->SetLinkedClient(NULL);
d218 1
a218 1
		m_pctlFriendList->RemoveFriend(todel);
d220 1
a220 1
	delete todel;
d223 1
a223 1
void CFriendList::RemoveFriend(CUpDownClient* pClient)
d225 1
a225 1
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL; )
d227 2
a228 2
		CFriend * cur_friend = m_listFriends.GetNext(pos);
		if (cur_friend->m_dwLastUsedIP == pClient->GetIP() && cur_friend->m_nLastUsedPort == pClient->GetUserPort())
d230 1
a230 1
			RemoveFriend(cur_friend);
d233 1
@


1.38
log
@Several friend class members were moved from public to private section.
@
text
@d18 1
a18 1
#include "StdAfx.h"
d48 2
a49 2
	CFriend	* pFriend = NULL;
	CSafeFile	file;
d53 1
a53 1
		CString	strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir()) + CString(EMFRIENDS_MET_FILENAME);
d55 1
a55 1
		if (!file.Open(strFileName.GetBuffer(), CFile::modeRead | CFile::osSequentialScan | CFile::shareDenyWrite))
d97 2
a98 2
	CFile file;
	CString strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir()) + CString(EMFRIENDS_MET_FILENAME);
d100 1
a100 1
	if (!file.Open(strFileName.GetBuffer(), CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite))
d106 1
a106 1
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL; )
a168 1
	SaveList();
a197 1
	SaveList();
a219 1
	SaveList();
d241 1
a241 1
		this->SaveList();
@


1.37
log
@rollback of old waiting queue
@
text
@d125 1
a125 1
			if (!md4cmp(pFriend->m_abyUserhash, abyUserHash))
d215 3
a217 5
	if (todel->m_pLinkedClient)
	{
		todel->m_pLinkedClient->m_pFriend = NULL;
		todel->m_pLinkedClient = NULL;
	}
@


1.36
log
@SSWQ
@
text
@d200 1
a200 3
//	update the client position in waiting queue
	g_eMuleApp.m_pUploadQueue->UpdateClientInWaitingQueue(pClient);
//	upadte the GUI lists
a217 2
	//	update the client position in waiting queue
		g_eMuleApp.m_pUploadQueue->UpdateClientInWaitingQueue(todel->m_pLinkedClient);
@


1.35
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@d200 3
a202 1
//	MOREVIT - I'm betting we don't need the throttle if we use the message queue
d220 2
@


1.34
log
@More file sharing corrections to allow read-only access for other applications (official).
@
text
@d201 2
a202 2
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.PostMessage(WM_QL_REFRESHCLIENT, 0, reinterpret_cast<LPARAM>(pClient));
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.PostMessage(WM_UL_REFRESHCLIENT, 0, reinterpret_cast<LPARAM>(pClient));
d235 2
a236 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.PostMessage(WM_QL_REFRESHCLIENT, 0, reinterpret_cast<LPARAM>(pClient));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.PostMessage(WM_UL_REFRESHCLIENT, 0, reinterpret_cast<LPARAM>(pClient));
@


1.33
log
@Prevent unwanted clients from becoming friends;
Fix for possible crash due to corrupt comment packet;
Fix for delayed remote answer to hashset request.
@
text
@d55 1
a55 1
		if (!file.Open(strFileName.GetBuffer(), CFile::modeRead | CFile::osSequentialScan))
d99 2
a100 1
	if (!file.Open(strFileName.GetBuffer(), CFile::modeCreate | CFile::modeWrite))
@


1.32
log
@Disable scheduled backup and backup on exit if a file corruption is detected on start + minor changes
@
text
@d112 5
a116 4
CFriend* CFriendList::LinkFriend(uchar* abyUserHash, uint32 m_dwIp, uint16 m_uPort)
{
	CFriend * backup_friend = NULL;
	for (POSITION pos = m_listFriends.GetHeadPosition(); pos != NULL; )
d118 10
a127 4
		CFriend * cur_friend = m_listFriends.GetNext(pos);
		if (cur_friend->m_dwLastUsedIP == m_dwIp && cur_friend->m_nLastUsedPort == m_uPort)
			backup_friend = cur_friend;
		if (cur_friend->m_dwHasHash && !md4cmp(cur_friend->m_abyUserhash, abyUserHash))
d129 2
a130 7
			cur_friend->m_dwLastSeen = time(NULL);
			if (cur_friend->m_pLinkedClient)
			{
				cur_friend->m_pLinkedClient->m_pFriend = NULL;
				cur_friend->m_pLinkedClient = NULL;
			}
			return cur_friend;
d133 1
a133 1
	return backup_friend;
d136 1
a136 1
void CFriendList::RefreshFriend(CFriend *pFriend)
d142 1
a142 1
void CFriendList::ShowFriends()
@


1.31
log
@list processing optimization
@
text
@d88 2
@


1.30
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d40 2
a41 2
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos))
		delete m_listFriends.GetAt(pos);
d103 1
a103 1
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos))
d105 1
a105 1
		m_listFriends.GetAt(pos)->WriteToFile(file);
d113 1
a113 1
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos))
d115 1
a115 1
		CFriend * cur_friend = m_listFriends.GetAt(pos);
d146 1
a146 1
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos))
d148 1
a148 1
		CFriend * cur_friend = m_listFriends.GetAt(pos);
d171 1
a171 1
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos))
d173 1
a173 1
		CFriend * cur_friend = m_listFriends.GetAt(pos);
d224 1
a224 1
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos))
d226 1
a226 1
		CFriend * cur_friend = m_listFriends.GetAt(pos);
@


1.29
log
@avoid some not necessary disc writes
@
text
@d58 1
a58 1
		uint8	header;
d99 1
a99 1
	uint8 header = MET_HEADER;
@


1.28
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@a53 1
	//CString strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetAppDir()) + CString("emfriends.met");
a96 1
//CString strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetAppDir()) + CString("emfriends.met");
d240 1
a240 1
	if (::GetTickCount() - m_nLastSaved > 300000)
@


1.27
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d83 1
a83 1
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_EMFRIENDSINVALID));
d86 1
a86 1
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_READEMFRIENDS), GetErrorMessage(error));
@


1.26
log
@Added some colors to the logs...
@
text
@d83 1
a83 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_EMFRIENDSINVALID));
d86 1
a86 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_READEMFRIENDS), GetErrorMessage(error));
@


1.25
log
@Formatting, comments, and name changes.
@
text
@d83 1
a83 1
			AddLogLine(true, IDS_ERR_EMFRIENDSINVALID);
d86 1
a86 1
			AddLogLine(true, IDS_ERR_READEMFRIENDS, GetErrorMessage(error));
@


1.24
log
@Fixed a bug where clients without an IP or hash could be added as a friends  (from official)
@
text
@d112 1
a112 1
CFriend* CFriendList::LinkFriend(uchar* abyUserHash, uint32 m_dwIp, uint16 m_nPort)
d118 1
a118 1
		if (cur_friend->m_dwLastUsedIP == m_dwIp && cur_friend->m_nLastUsedPort == m_nPort)
d136 2
a137 2
	if (m_wndOutput != NULL && ::IsWindow(m_wndOutput->m_hWnd))
		m_wndOutput->RefreshFriend(pFriend);
d142 1
a142 1
	if (!m_wndOutput)
d147 1
a147 1
	m_wndOutput->DeleteAllItems();
d151 1
a151 1
		m_wndOutput->AddFriend(cur_friend);
d194 2
a195 2
	if (m_wndOutput)
		m_wndOutput->AddFriend(NewFriend);
d217 2
a218 2
	if (m_wndOutput)
		m_wndOutput->RemoveFriend(todel);
@


1.23
log
@no message
@
text
@d156 1
a156 1
void CFriendList::AddFriend(uchar t_m_abyUserhash[16], uint32 tm_dwLastSeen, uint32 tm_dwLastUsedIP, uint32 tm_nLastUsedPort, uint32 tm_dwLastChatted, CString tm_strName, uint32 tm_dwHasHash)
d158 6
a163 4
	if (IsAlreadyFriend(tm_dwLastUsedIP, tm_nLastUsedPort))
		return;
	CFriend* Record = 0;
	Record = new CFriend(t_m_abyUserhash, tm_dwLastSeen, tm_dwLastUsedIP, tm_nLastUsedPort, tm_dwLastChatted, tm_strName, tm_dwHasHash);
d167 1
d184 1
a184 1
void CFriendList::AddFriend(CUpDownClient* pClient)
d187 4
a190 1
		return;
d201 1
@


1.22
log
@More fixes for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@d24 1
a24 1
static char THIS_FILE[]=__FILE__;
d48 1
a48 1
	CFriend		*pFriend = NULL;
d53 2
a54 2
		CString		strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir()) + CString(EMFRIENDS_MET_FILENAME);
		//CString strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetAppDir()) + CString("emfriends.met");
d56 1
a56 1
		if (!file.Open(strFileName.GetBuffer(),CFile::modeRead|CFile::osSequentialScan))
d59 1
a59 1
		uint8		header;
d61 1
a61 1
		file.Read(&header,1);
d67 1
a67 1
		uint32		nFriendsNumber;
d69 1
a69 1
		file.Read(&nFriendsNumber,4);
d72 1
a72 1
			pFriend =  new CFriend();
d79 1
a79 1
	catch(CFileException *error)
d83 1
a83 1
			AddLogLine(true,IDS_ERR_EMFRIENDSINVALID);
d86 1
a86 1
			AddLogLine(true,IDS_ERR_READEMFRIENDS,GetErrorMessage(error));
d95 1
a95 1
	m_nLastSaved = ::GetTickCount(); 
d98 2
a99 2
	//CString strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetAppDir()) + CString("emfriends.met");
	if (!file.Open(strFileName.GetBuffer(),CFile::modeCreate|CFile::modeWrite))
d102 1
a102 1
	file.Write(&header,1);
d104 3
a106 2
	file.Write(&nRecordsNumber,4);
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos)){
d112 7
a118 5
CFriend* CFriendList::LinkFriend(uchar* abyUserHash, uint32 m_dwIp, uint16 m_nPort){
	CFriend* backup_friend = NULL;
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos)){
		CFriend* cur_friend = m_listFriends.GetAt(pos);
		if( cur_friend->m_dwLastUsedIP == m_dwIp && cur_friend->m_nLastUsedPort == m_nPort )
d120 2
a121 1
		if (cur_friend->m_dwHasHash && !md4cmp(cur_friend->m_abyUserhash, abyUserHash)){
d123 4
a126 3
			if (cur_friend->m_LinkedClient){
				cur_friend->m_LinkedClient->m_Friend = NULL;
				cur_friend->m_LinkedClient = NULL;
d133 5
a137 4

void CFriendList::RefreshFriend(CFriend* torefresh){
	if (m_wndOutput)
		m_wndOutput->RefreshFriend(torefresh);
d139 6
a144 4

void CFriendList::ShowFriends(){
	if (!m_wndOutput){
		ASSERT ( false );
d148 4
a151 3
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos)){
		CFriend* cur_friend = m_listFriends.GetAt(pos);
		m_wndOutput->AddFriend(cur_friend);	
d156 3
a158 2
void CFriendList::AddFriend( uchar t_m_abyUserhash[16], uint32 tm_dwLastSeen, uint32 tm_dwLastUsedIP, uint32 tm_nLastUsedPort, uint32 tm_dwLastChatted, CString tm_strName, uint32 tm_dwHasHash){
	if(IsAlreadyFriend(tm_dwLastUsedIP, tm_nLastUsedPort))
d160 2
a161 2
	CFriend* Record = 0; 
	Record = new CFriend( t_m_abyUserhash, tm_dwLastSeen, tm_dwLastUsedIP, tm_nLastUsedPort, tm_dwLastChatted, tm_strName, tm_dwHasHash );
d167 8
a174 5
// Added for the friends function in the IRC..
bool CFriendList::IsAlreadyFriend( uint32 tm_dwLastUsedIP, uint32 tm_nLastUsedPort ){
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos)){
		CFriend* cur_friend = m_listFriends.GetAt(pos);
		if ( cur_friend->m_dwLastUsedIP == tm_dwLastUsedIP && cur_friend->m_nLastUsedPort == tm_nLastUsedPort ){
d181 2
a182 1
void CFriendList::AddFriend(CUpDownClient* pClient){
d186 1
a186 1
	pClient->m_Friend = NewFriend;
d189 1
a189 1
		m_wndOutput->AddFriend(NewFriend);	
a190 5
#ifndef ASYNC_UI_UPDATES
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(pClient);
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateSourceItem(pClient);
#else
d192 2
a193 2
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.PostMessage(WM_QL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.PostMessage(WM_UL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
a194 1
#endif ASYNC_UI_UPDATES
d197 2
a198 1
void CFriendList::RemoveFriend(CFriend* todel){
d200 3
a202 2
	if (!pos){
		ASSERT ( false );
d205 4
a208 3
	if (todel->m_LinkedClient){
		todel->m_LinkedClient->m_Friend = NULL;
		todel->m_LinkedClient = NULL;
d221 1
a221 1
		CFriend* cur_friend = m_listFriends.GetAt(pos);
d225 2
a226 8
		#ifndef ASYNC_UI_UPDATES
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateSourceItem(pClient);
		#else
		//	MOREVIT - I'm betting we don't need the throttle if we use the message queue
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.PostMessage(WM_QL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.PostMessage(WM_UL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
a227 1
		#endif ASYNC_UI_UPDATES
@


1.21
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d180 1
a180 1
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateItem(pClient);
d217 1
a217 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateItem(pClient);
@


1.20
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d178 3
a180 3
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(pClient);
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.RefreshClient(pClient);
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(pClient);
d183 3
a185 3
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.PostMessage(WM_QL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.PostMessage(WM_UL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.PostMessage(WM_DL_UPDATESOURCEITEM,0,reinterpret_cast<LPARAM>(pClient));
d215 3
a217 3
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.RefreshClient(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(pClient);
d220 3
a222 3
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.PostMessage(WM_QL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.PostMessage(WM_UL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(pClient));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.PostMessage(WM_DL_UPDATESOURCEITEM,0,reinterpret_cast<LPARAM>(pClient));
@


1.19
log
@cleanup (friendslot)
@
text
@d168 2
a169 2
void CFriendList::AddFriend(CUpDownClient* toadd){
	if (toadd->IsFriend())
d171 2
a172 2
	CFriend* NewFriend = new CFriend(toadd);
	toadd->m_Friend = NewFriend;
d177 10
a186 3
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(toadd);
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.RefreshClient(toadd);
    g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(toadd);
d206 1
a206 1
void CFriendList::RemoveFriend(CUpDownClient* toadd)
d211 1
a211 1
		if (cur_friend->m_dwLastUsedIP == toadd->GetIP() && cur_friend->m_nLastUsedPort == toadd->GetUserPort())
d214 10
a223 3
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(toadd);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.RefreshClient(toadd);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(toadd);
@


1.18
log
@Formatting, comments, and name changes.
@
text
@a188 1
		todel->m_LinkedClient->SetFriendSlot(false);
a210 9
		}
	}
}

void CFriendList::RemoveAllFriendSlots(){
	for (POSITION pos = m_listFriends.GetHeadPosition();pos != 0;m_listFriends.GetNext(pos)){
		CFriend* cur_friend = m_listFriends.GetAt(pos);
		if (cur_friend->m_LinkedClient){
			cur_friend->m_LinkedClient->SetFriendSlot(false);
@


1.17
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d30 3
a32 1
CFriendList::CFriendList(void){
d36 1
a36 1

d44 6
d51 3
a53 5
bool CFriendList::LoadList(){
	CFriend* Record = 0; 
	CSafeFile file;
	try {
		CString strFileName = CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir()) + CString(EMFRIENDS_MET_FILENAME);
d55 1
d58 3
a60 1
		uint8 header;
d62 2
a63 1
		if (header != MET_HEADER){
d67 8
a74 6
		uint32 nRecordsNumber;
		file.Read(&nRecordsNumber,4);
		for (uint32 i = 0; i < nRecordsNumber; i++) {
			Record =  new CFriend();
			Record->LoadFromFile(file);
			m_listFriends.AddTail(Record);
d79 2
a80 1
	catch(CFileException* error){
d84 2
a85 1
		else{
d92 3
a94 2

void CFriendList::SaveList(){
d110 1
a110 1

@


1.16
log
@Implemented ConfigDir
@
text
@d19 1
a19 1
#include "friendlist.h"
d47 2
a48 2
		CString strFileName = CString(theApp.glob_prefs->GetConfigDir()) + CString(EMFRIENDS_MET_FILENAME);
		//CString strFileName = CString(theApp.glob_prefs->GetAppDir()) + CString("emfriends.met");
d82 2
a83 2
	CString strFileName = CString(theApp.glob_prefs->GetConfigDir()) + CString(EMFRIENDS_MET_FILENAME);
	//CString strFileName = CString(theApp.glob_prefs->GetAppDir()) + CString("emfriends.met");
d162 3
a164 3
    theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(toadd);
    theApp.emuledlg->transferwnd.m_wndUploadList.RefreshClient(toadd);
    theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(toadd);
d193 3
a195 3
			theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(toadd);
			theApp.emuledlg->transferwnd.m_wndUploadList.RefreshClient(toadd);
			theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(toadd);
@


1.15
log
@*** empty log message ***
@
text
@d28 2
d47 2
a48 1
		CString strFileName = CString(theApp.glob_prefs->GetAppDir()) + CString("emfriends.met");
d82 2
a83 1
	CString strFileName = CString(theApp.glob_prefs->GetAppDir()) + CString("emfriends.met");
@


1.14
log
@converted to helper function GetErrorMessage
@
text
@d158 3
a160 3
    theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(toadd);
    theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(toadd);
    theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(toadd);
d189 3
a191 3
			theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(toadd);
			theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(toadd);
			theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(toadd);
@


1.13
log
@converted to new logger methods
@
text
@d69 1
a69 3
			char buffer[150];
			error->GetErrorMessage(buffer,150);
			AddLogLine(true,IDS_ERR_READEMFRIENDS,buffer);
@


1.12
log
@code cleanup
@
text
@d67 1
a67 1
			AddLogLine(true,GetResString(IDS_ERR_EMFRIENDSINVALID));
d71 1
a71 1
			AddLogLine(true,GetResString(IDS_ERR_READEMFRIENDS),buffer);
@


1.11
log
@code cleanup
@
text
@d89 1
a89 1
		m_listFriends.GetAt(pos)->WriteToFile(&file);
@


1.10
log
@minor fixes and improvements
@
text
@d58 1
a58 1
			Record->LoadFromFile(&file);
@


1.9
log
@now updates friend icon when removing
@
text
@d56 1
a56 1
		for (uint32 i = 0; i != nRecordsNumber; i++) {
d100 2
a101 3
		if (!memcmp(cur_friend->m_abyUserhash, abyUserHash,16)){
			CTime lwtime;
			cur_friend->m_dwLastSeen = mktime(lwtime.GetLocalTm());
@


1.8
log
@various bugfixes for "friends"
@
text
@d192 3
@


1.7
log
@converted to new logging method
@
text
@d132 2
d182 13
@


1.6
log
@fix for bug No. 0000001
@
text
@d67 1
a67 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_EMFRIENDSINVALID));
d71 1
a71 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_READEMFRIENDS),buffer);
@


1.5
log
@Code clean up and double check wit official code.
@
text
@d159 3
@


1.4
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@a27 1

@


1.3
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d31 1
d80 1
d188 6
@


1.2
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d22 7
@


1.1
log
@*** empty log message ***
@
text
@d128 1
d150 1
d168 1
@


1.1.6.1
log
@initial upgrade to .26
@
text
@a127 1
	SaveList();
a148 1
	SaveList();
a165 1
	SaveList();
@


1.1.4.1
log
@updating this branch...
@
text
@@

