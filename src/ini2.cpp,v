head	1.29;
access;
symbols
	PublicRelease_1_2e:1.26
	Interim_Release_1-2e_RC1:1.26
	PublicRelease_1_2d:1.26
	Interim_Release_1-2d_RC1:1.26
	Interim_Release_1-2d_beta1:1.25
	PublicRelease_1_2c:1.18
	Interim_Release_1-2c_RC1:1.18
	Interim_Release_1-2c_beta1:1.17
	PublicRelease_1_2b:1.17
	Interim_Release_1-2b_RC1:1.17
	PublicRelease_1_2a:1.17
	Interim_Release_1-2a_RC1:1.17
	Interim_Release_1-2a_beta2:1.17
	Interim_Release_1-2a_beta1:1.17
	PublicRelease_1_2:1.16
	Interim_Release_1-2_RC1:1.16
	Interim_Release_1-2_beta1:1.16
	PublicRelease_1_1g:1.16
	Interim_Release_1-1g_RC3:1.16
	Interim_Release_1-1g_RC2:1.16
	Interim_Release_1-1g_RC1:1.16
	Interim_Release_1-1g_beta2:1.16
	Interim_Release_1-1g_beta1:1.16
	PublicRelease_1_1f:1.16
	Interim_Release_1-1f_RC1:1.16
	PublicRelease_1_1e:1.16
	Interim_Release_1-1e_RC2:1.16
	Interim_Release_1-1e_RC1:1.16
	Interim_Release_1-1e_beta1:1.16
	PublicRelease_1_1d:1.16
	Interim_Release_1-1d_RC1:1.16
	PublicRelease_1_1c:1.16
	Interim_Release_1-1c_RC1:1.16
	Interim_Release_1-1c_beta2:1.16
	Interim_Release_1-1c_beta1:1.16
	PublicRelease_1_1b:1.16
	Interim_Release_1-1b_RC1:1.16
	PublicRelease_1_1a:1.16
	Interim_Release_1-1a_RC2:1.16
	Interim_Release_1-1a_RC1:1.16
	Interim_Release_1-1a_beta2:1.16
	Interim_Release_1-1a_beta1:1.16
	PublicRelease_1_1:1.16
	Interim_Release_1-1_beta1:1.16
	PublicRelease_1o:1.16
	Interim_Release_1o_RC1:1.16
	Interim_Release_1o_beta1:1.16
	PublicRelease_1n:1.15
	Interim_Release_1n_RC2:1.15
	Interim_Release_1n_RC1:1.15
	Interim_Release_1n_beta2:1.15
	Interim_Release_1n_beta1:1.15
	PublicRelease_1m:1.15
	Interim_Release_1m_beta1:1.15
	PublicRelease_1l:1.15
	Interim_Release_1l_RC3:1.15
	Interim_Release_1l_RC2:1.15
	Interim_Release_1l_RC1:1.15
	Interim_Release_1l_beta2:1.15
	Interim_Release_1l_beta1:1.15
	PublicRelease_1k:1.15
	Interim_Release_1k_RC4:1.15
	Interim_1k_RC3:1.15
	Interim_1k_RC2:1.15
	Interim_Release_1k_RC1:1.15
	Interim_Release_1k_beta5:1.15
	Intrerim_Release_1k_beta4:1.15
	Interim_Release_1k_beta1:1.14
	PublicRelease_1j:1.13
	Interim_Release_1J_RC3:1.13
	Interim_Release_1j_RC3:1.13
	Interim_Release_1j_RC2:1.13
	Interim_Release_1j_RC1:1.13
	Interim_Release_1j_beta2:1.13
	Interim_Release_1j_beta1:1.13
	PublicRelease_1i:1.13
	Interim_Release_1i_RC6:1.13
	Interim_Release_1i_RC3:1.13
	Interim_Release_1i_RC2:1.13
	Interim_Release_1i_RC1:1.13
	Interim_Release_1i_beta3:1.13
	Interim_Release_1i_beta2:1.13
	Interim_Release_1i_beta1:1.12
	PublicRelease_1h:1.11
	Interim_Release_1h_rc2:1.11
	Interim_Release_1h_RC1:1.11
	Interim_Release_1h_beta2:1.11
	Interim_Release_1h_beta1_now:1.10
	Interim_Release_1h_beta1:1.9
	PublicRelease_1g:1.6
	Interim_Release_1g_RC6_Final:1.6
	Interim_Release_1g_RC6:1.6
	Interim_Release_1g_RC5:1.6
	Interim_Release_1g_RC4:1.6
	Interim_Release_1g_RC3:1.6
	Interim_Release_1g_beta2:1.3
	Interim_Release_1g_beta1:1.3
	Interim_Release_1f_RC4:1.3
	Interim_Release_1f_RC3:1.3
	Interim_Release_1f_RC2:1.3
	Interim_Release_1f_RC:1.3
	Interim_Release_1f_beta2:1.3
	Interim_Release_1f_beta1:1.3
	PublicRelease_1e:1.3
	Interim_Release_1e_RC2:1.3
	Interim_Release_1e_RC:1.3
	Interim_Release_1e_beta3:1.3
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.2
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.29
date	2010.07.06.00.58.12;	author aw3;	state Exp;
branches;
next	1.28;

1.28
date	2009.05.05.03.44.57;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.01.04.18.08;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2008.04.07.03.34.13;	author aw3;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.20.15.04.22;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.11.04.20.08;	author aw3;	state Exp;
branches;
next	1.23;

1.23
date	2007.12.01.23.18.05;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2007.12.01.10.38.07;	author eklmn;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.12.23.50.27;	author fuxie-dk;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.31.18.27.29;	author fuxie-dk;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.18.14.48.33;	author fuxie-dk;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.27.06.21.19;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.05.03.19.23;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2004.09.20.07.14.55;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2004.03.14.21.10.11;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.11.04.13.01;	author katsyonak;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.21.21.33.08;	author bavariansnail;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.24.22.43.04;	author bond006;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.18.17.29.54;	author bond006;	state Exp;
branches;
next	1.9;

1.9
date	2003.08.06.16.46.33;	author eklmn;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.29.22.14.44;	author zegzav;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.29.13.16.53;	author bond006;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.11.18.27.14;	author eklmn;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.09.20.57.48;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.04.24.15.36.45;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.19.06.27.27;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.25;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.40;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Minor formatting.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// Ini2.cpp: Ini-File-Interface by bond006 <rene.landgrebe@@gmx.de>
// ****************************************************************
// This new interface replaces the old interface which was too slow

#include "stdafx.h"
#include "ini2.h"
#include "otherfunctions.h"
#include "StringConversion.h"

CIni::CIni(const CString &strFileName, int iMode/*=0*/)
	: m_strDefCategory(_T("")), m_strFileBuffer(_T(""))
	, m_strDefCatBraces(_T("")), m_strDefCatBracesCR(_T(""))
	, m_strInternXchg(_T(""))
{
	OpenFile(strFileName, iMode);
	ReadData(iMode);
	m_strInternXchg.Preallocate(128);
}

CIni::~CIni()
{
	CloseFile();
}

void CIni::OpenFile(const CString &strFileName, int iMode)
{
	if (m_hFile == CFile::hFileNull)
		Open( strFileName, (iMode & INI_MODE_READONLY) ? (CFile::modeRead | CFile::shareDenyWrite) :
			(CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyWrite) );
}

void CIni::CloseFile()
{
	if (m_hFile != CFile::hFileNull)
		Close();
}

void CIni::ReadData(int iMode)
{
	if (m_hFile != CFile::hFileNull)
	{
		char tempBuffer[131072]; // change this value to support larger files than 128KB
		uint32 dwOffset = 0;
		ECodingFormat eCF = cfLocalCodePage;

		memzero(tempBuffer, sizeof(tempBuffer));

		uint32 dwRead = Read(tempBuffer, sizeof(tempBuffer) - 1);

		if (dwRead > 3 && HAS_BOM(&tempBuffer[0]))
		{
			eCF = cfUTF8withBOM;
			dwOffset = 3;
		//	Drop extra end of line as we explicitly add it while saving
			while (tempBuffer[dwOffset] == '\r' || tempBuffer[dwOffset] == '\n')
				dwOffset++;
		}

		if ((eCF == cfLocalCodePage) && ((iMode & INI_MODE_ANSIONLY) == 0))
		{
		//	Since original eMule does not convert all potential Unicode strings into UTF8
		//	(e.g. path, message filter) it could be that ini file contains string entries
		//	in mixed format (some in UTF8 while others in ANSI). So we need to verify the format
		//	for every entry in INI file. The verification is based on following assumptions:
		//	1) the entry name is ASCII characters
		//	2) value of the entry in ANSI or UTF8 format
			const char *const pcSep = "\n";
			char *pcToken = strtok(tempBuffer, pcSep);
			CString strToken;

			m_strFileBuffer.Preallocate(dwRead);

			while (pcToken != NULL)
			{
				if (IsUTF8(pcToken))
					MB2Str(cfUTF8, &strToken, pcToken);
				else
					MB2Str(cfLocalCodePage, &strToken, pcToken);

				if (!strToken.IsEmpty())
					m_strFileBuffer.Append(strToken);
				m_strFileBuffer.AppendChar(_T('\n'));

				pcToken = strtok(NULL, pcSep);
			}
		}
		else
			MB2Str(eCF, &m_strFileBuffer, &tempBuffer[dwOffset], (dwRead - dwOffset));

		// Cut off blank lines at the end of the file
		m_strFileBuffer.TrimRight(_T("\r\n"));
	}
}

void CIni::SaveAndClose()
{
	if (m_hFile != CFile::hFileNull)
	{
		SetLength(0);
		m_strFileBuffer.TrimRight(_T("\r\n"));

	//	For backward compatibility save the ini with BOM only if Unicode is used
		ECodingFormat eCF = cfLocalCodePage;
		static const char s_acBOMHeader[5] = {0xEFu, 0xBBu, 0xBFu, '\r', '\n'};  

		if (IsUTF8Required(m_strFileBuffer))
		{
			eCF = cfUTF8;
		//	Here end-of-line is added not to break standard Windows ini file parser (which is used by other clients)
			Write(s_acBOMHeader, ARRSIZE(s_acBOMHeader));
		}
		WriteStr2MB(eCF, m_strFileBuffer, *this);
	}

	CloseFile();
}

void CIni::AddCategory(const CString &strCategoryName)
{	//	strCategoryName is in "[Name]" format
	if (!CategoryExist(strCategoryName))
	{
		if (!m_strFileBuffer.IsEmpty())
			m_strFileBuffer += _T("\r\n");
		m_strFileBuffer += strCategoryName;
	}
}

void CIni::SetDefaultCategory(const CString& strCategoryName)
{
	m_strDefCategory = strCategoryName;
	m_strDefCatBraces.Format(_T("[%s]"), m_strDefCategory);
	m_strDefCatBracesCR.Format(_T("\r\n[%s]"), m_strDefCategory);

	AddCategory(m_strDefCatBraces);
}

void CIni::SetDefaultCategory(const TCHAR *pcCategoryName)
{
	m_strDefCategory = pcCategoryName;
	m_strDefCatBraces.Format(_T("[%s]"), m_strDefCategory);
	m_strDefCatBracesCR.Format(_T("\r\n[%s]"), m_strDefCategory);

	AddCategory(m_strDefCatBraces);
}

void CIni::DeleteCategory(const CString& strCategoryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');

	if (CategoryExist(catSearchString))
	{
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			catSearchString = _T("\r\n[");
			catSearchString += strCategoryName;
			catSearchString += _T(']');

			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		int nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() + 1));

		if (nCatLastCharPos < 0)
			nCatLastCharPos = m_strFileBuffer.GetLength();
		else
			nCatLastCharPos += 2;

		m_strFileBuffer.Delete(nCatFirstCharPos, (nCatLastCharPos - nCatFirstCharPos));
	}
}

void CIni::DeleteEntry(const CString& strCategoryName, const CString &strEntryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');

	if (EntryExist(catSearchString, strEntryName))
	{
		int nEntryFirstCharPos, nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			catSearchString = _T("\r\n[");
			catSearchString += strCategoryName;
			catSearchString += _T(']');

			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		CString entrySearchString = _T("\r\n");
		entrySearchString += strEntryName;
		entrySearchString += _T('=');

		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() + 1));
		nEntryFirstCharPos += 2;

		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

		if (nEntryLastCharPos < 0)
			nEntryLastCharPos = m_strFileBuffer.GetLength();
		else
			nEntryLastCharPos += 2; // remove entry including "\r\n"

		m_strFileBuffer.Delete(nEntryFirstCharPos, (nEntryLastCharPos - nEntryFirstCharPos));
	}
}

__declspec(noinline) const CString& CIni::GetString(const TCHAR *pcEntryName, const TCHAR *pcValue)
{
	GetValue(pcEntryName, &m_strInternXchg);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		m_strInternXchg = pcValue;
	return m_strInternXchg;
}

__declspec(noinline) void CIni::GetString(CString *pstrOut, const TCHAR *pcEntryName, const TCHAR *pcValue)
{
	GetValue(pcEntryName, pstrOut);
	if (pstrOut->IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		*pstrOut = pcValue;
}

__declspec(noinline) double CIni::GetDouble(const TCHAR *pcEntryName, double defValue)
{
	GetValue(pcEntryName, &m_strInternXchg);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		return defValue;
	else
		return _tstof(m_strInternXchg);
}

__declspec(noinline) int CIni::GetInt(const TCHAR *pcEntryName, int defValue)
{
	GetValue(pcEntryName, &m_strInternXchg);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		return defValue;
	else
		return _tstoi(m_strInternXchg);
}

uint32 CIni::GetUInt32(const TCHAR *pcEntryName, uint32 defValue)
{
	return static_cast<uint32>(GetInt(pcEntryName, defValue));
}

uint16 CIni::GetUInt16(const TCHAR *pcEntryName, int iDefVal)
{
	return static_cast<uint16>(GetInt(pcEntryName, iDefVal));
}

__declspec(noinline) uint64 CIni::GetUInt64(const TCHAR *pcEntryName, uint64 defValue)
{
	GetValue(pcEntryName, &m_strInternXchg);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		return defValue;
	else
		return _tstoi64(m_strInternXchg);
}

WORD CIni::GetWORD(const TCHAR *pcEntryName, WORD defValue)
{
	return static_cast<WORD>(GetUInt32(pcEntryName, defValue));
}

__declspec(noinline) bool CIni::GetBool(const TCHAR *pcEntryName, bool defValue)
{
	GetValue(pcEntryName, &m_strInternXchg);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		return defValue;
	else
		return (_tstoi(m_strInternXchg) != 0);
}

void CIni::SetString(const TCHAR *pcEntryName, const CString& strValue)
{
	SetValue(pcEntryName, strValue);
}

void CIni::SetDouble(const TCHAR *pcEntryName, double dValue)
{
	m_strInternXchg.Format(_T("%g"), dValue);
	SetValue(pcEntryName, m_strInternXchg);
}

void CIni::SetInt(const TCHAR *pcEntryName, int iValue)
{
	m_strInternXchg.Format(_T("%d"), iValue);
	SetValue(pcEntryName, m_strInternXchg);
}

void CIni::SetUInt32(const TCHAR *pcEntryName, uint32 dwValue)
{
	m_strInternXchg.Format(_T("%u"), dwValue);
	SetValue(pcEntryName, m_strInternXchg);
}

void CIni::SetUInt64(const TCHAR *pcEntryName, uint64 qwValue)
{
	m_strInternXchg.Format(_T("%I64u"), qwValue);
	SetValue(pcEntryName, m_strInternXchg);
}

void CIni::SetWORD(const TCHAR *pcEntryName, WORD wValue)
{
	SetUInt32(pcEntryName, wValue);
}

void CIni::SetBool(const TCHAR *pcEntryName, bool bValue)
{
	m_strInternXchg = (bValue) ? _T("1") : _T("0");
	SetValue(pcEntryName, m_strInternXchg);
}

void CIni::GetArray(CString *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int nPos = 0;
	int nLastPos = 0;
	int nEscapePos = 0;

//	Using escape characters for "\" and "," in strings
	if (temp.Find(_T('\\')) >= 0)
	{
		for (unsigned ui = 0; ui < uiElements; ui++)
		{
			nLastPos = nPos;
			nPos = temp.Find(_T(','), nLastPos);
			nEscapePos = temp.Find(_T('\\'), nLastPos);

			if(nPos==(-2))
				pToArray[ui] = _T("");

			if(nEscapePos==(-1) && nPos!=(-2))
			{
				if(nPos == (-1))
				{
					pToArray[ui] = temp.Mid(nLastPos, (temp.GetLength() - nLastPos));
					nPos = -2;
				}
				else
				{
					pToArray[ui] = (nPos >= 0) ? temp.Mid(nLastPos, (nPos - nLastPos)) : _T("");
					nPos++;
				}
			}
			else if(nEscapePos!=(-1) && nPos!=(-2))
			{
				if(nPos < nEscapePos)
				{
					if(nPos == (-1))
					{
						pToArray[ui] = temp.Mid(nLastPos, (temp.GetLength() - nLastPos));
						nPos = -2;
					}
					else
					{
						pToArray[ui] = (nPos >= 0) ? temp.Mid(nLastPos, (nPos - nLastPos)) : _T("");
						nPos++;
					}
				}
				else
				{
					int saveBegPos = nLastPos;

					while(nPos > nEscapePos && nEscapePos != (-1))
					{
						nLastPos = nEscapePos + 2;
						nPos = temp.Find(_T(','), nLastPos);
						nEscapePos = temp.Find(_T('\\'), nLastPos);
					}

					if(nPos == (-1))
					{
						pToArray[ui] = temp.Mid(saveBegPos,(temp.GetLength() - saveBegPos));
						nPos = -2;
					}
					else
					{
						pToArray[ui] = (nPos >= 0) ? temp.Mid(saveBegPos,(nPos - saveBegPos)) : _T("");
						nPos++;
					}
				}
			}

			pToArray[ui].Replace(_T("\\,"), _T(","));
			pToArray[ui].Replace(_T("\\\\"), _T("\\"));
		}
	}
	else
	{
		for (unsigned ui = 0; ui < uiElements; ui++)
			pToArray[ui] = (nPos >= 0) ? temp.Tokenize(_T(","), nPos) : _T("");
	}
}

void CIni::GetArray(double *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int iPos = 0;

//	Different delimiter is used as comma is a decimal-point in some languages
	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? _tstof(temp.Tokenize(_T("|"), iPos)) : 0.;
}

void CIni::GetArray(int *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int iPos = 0;

	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? _tstoi(temp.Tokenize(_T(","), iPos)) : 0;
}

void CIni::GetArray(WORD *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int iPos = 0;

	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? (WORD)_tstoi(temp.Tokenize(_T(","), iPos)) : 0;
}

void CIni::GetArray(bool *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int iPos = 0;

	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (((iPos >= 0) ? _tstoi(temp.Tokenize(_T(","), iPos)) : 0) != 0);
}

void CIni::GetArray(byte *pToArray, unsigned uiElements, const TCHAR *pcEntryName, const byte *pDefArray/*=NULL*/)
{
	CString temp = GetString(pcEntryName, _T(""));

	byte	byteVal;
	int		iPos = 0;

	for (unsigned ui = 0; ui < uiElements; ui++)
	{
		if ((iPos >= 0) && ((byteVal = (byte)_tstoi(temp.Tokenize(_T(","), iPos)), iPos) >= 0))
			pToArray[ui] = byteVal;
		else
			pToArray[ui] = (pDefArray != NULL) ? pDefArray[ui] : 0;
	}
}

void CIni::SetArray(CString *pInArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	m_strInternXchg.Truncate(0);
	for (unsigned ui = 0; ui < uiElements; ui++)
	{
	//	Using escape characters for "\" and "," in strings
		pInArray[ui].Replace(_T("\\"), _T("\\\\"));
		pInArray[ui].Replace(_T(","), _T("\\,"));

		m_strInternXchg += pInArray[ui];
		if ((ui + 1) != uiElements)
			m_strInternXchg += _T(",");
	}
	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetArray(const double *pInArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	m_strInternXchg.Truncate(0);

//	Different delimiter is used as comma is a decimal-point in some languages
	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(((ui + 1) != uiElements) ? _T("%g|") : _T("%g"), pInArray[ui]);

	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetArray(const int *pInArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	m_strInternXchg.Truncate(0);

	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(((ui + 1) != uiElements) ? _T("%d,") : _T("%d"), pInArray[ui]);

	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetArray(const WORD *pInArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	m_strInternXchg.Truncate(0);

	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(((ui + 1) != uiElements) ? _T("%u,") : _T("%u"), pInArray[ui]);

	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetArray(const bool *pInArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	TCHAR	acStr[2];

	m_strInternXchg.Truncate(0);

	acStr[1] = _T(',');
	for (unsigned ui = 0; ui < uiElements; ui++)
	{
		acStr[0] = (pInArray[ui]) ? _T('1') : _T('0');
		m_strInternXchg.Append(acStr, ((ui + 1) != uiElements) ? 2 : 1);
	}

	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetArray(const byte *pInArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	m_strInternXchg.Truncate(0);

	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(((ui + 1) != uiElements) ? _T("%u,") : _T("%u"), pInArray[ui]);

	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetValue(const TCHAR *pcEntryName, const CString &strValue)
{
	CString	strEntryName(pcEntryName);

	if (EntryExist(m_strDefCatBraces, pcEntryName))
	{
		int nValueFirstCharPos, nEntryFirstCharPos, nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBraces);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBracesCR, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		CString entrySearchString = _T("\r\n");
		entrySearchString += strEntryName;
		entrySearchString += _T('=');

		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
		nEntryFirstCharPos += 2;
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

		if (nEntryLastCharPos < 0)
			nEntryLastCharPos = m_strFileBuffer.GetLength();

		nValueFirstCharPos = nEntryFirstCharPos + strEntryName.GetLength() + 1;

		// Delete an existing value and insert a new value
		m_strFileBuffer.Delete(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
		m_strFileBuffer.Insert(nValueFirstCharPos, strValue);
	}
	else if (CategoryExist(m_strDefCatBraces))
	{
		int nCatLastCharPos, nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBraces);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBracesCR, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));

		CString entryString;

		strEntryName += _T('=');
		strEntryName += strValue;

		if (nCatLastCharPos < 0)
		{
			nCatLastCharPos = m_strFileBuffer.GetLength();
			entryString = _T("\r\n");
			entryString += strEntryName;
		}
		else
		{
			nCatLastCharPos += 2;
			entryString = strEntryName;
			entryString += _T("\r\n");
		}

		m_strFileBuffer.Insert(nCatLastCharPos, entryString);
	}
}

void CIni::GetValue(const TCHAR *pcEntryName, CString *pstrOut)
{
	CString	strEntryName(pcEntryName);

	if (ValueExist(m_strDefCatBraces, strEntryName))
	{
		int nValueFirstCharPos, nEntryFirstCharPos, nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBraces);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBracesCR, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		CString entrySearchString = _T("\r\n");
		entrySearchString += strEntryName;
		entrySearchString += _T('=');

		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
		nEntryFirstCharPos += 2;
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

		if (nEntryLastCharPos < 0)
			nEntryLastCharPos = m_strFileBuffer.GetLength();

		nValueFirstCharPos = nEntryFirstCharPos + strEntryName.GetLength() + 1;

		*pstrOut = m_strFileBuffer.Mid(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
	}
	else
		*pstrOut = _T("");
}

bool CIni::CategoryExist(const CString &strCategoryName)
{	//	strCategoryName is in "[Name]" format
	int iFindPos = m_strFileBuffer.Find(strCategoryName);

	if (iFindPos < 0)
		return false;

	// Check if the category is valid
	if (iFindPos != 0)
	{
		CString	catSearchString(_T("\r\n"));

		catSearchString += strCategoryName;
		iFindPos -= 2;
		iFindPos = m_strFileBuffer.Find(catSearchString, iFindPos);

		if (iFindPos < 0)
			return false;
	}

	return true;
}

bool CIni::EntryExist(const CString &strCategoryName, const TCHAR *pcEntryName)
{	//	strCategoryName is in "[Name]" format
	int nEntryFirstCharPos, nCatFirstCharPos, nCatLastCharPos;

	if ((nCatFirstCharPos = m_strFileBuffer.Find(strCategoryName)) < 0)
		return false;	// Category does not exist

	// Check if the category is valid
	if (nCatFirstCharPos != 0)
	{
		CString	catSearchString(_T("\r\n"));

		catSearchString += strCategoryName;
		nCatFirstCharPos -= 2;
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);

		if (nCatFirstCharPos < 0)
			return false;

		nCatFirstCharPos += 2;
	}

	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() - 1));

	if (nCatLastCharPos < 0)
		// No following category exists - end of category is end of file
		nCatLastCharPos = m_strFileBuffer.GetLength();
	else
		nCatLastCharPos += 2;

	CString entrySearchString = _T("\r\n");
	entrySearchString += pcEntryName;
	entrySearchString += _T('=');

	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() - 1));
	
	if (nEntryFirstCharPos >= 0)
		nEntryFirstCharPos += 2;
	else
		return false;

	if (nEntryFirstCharPos < nCatFirstCharPos || nEntryFirstCharPos > nCatLastCharPos)
		// The entry we're searching for does not exist in the given category
		return false;

	return true;
}

bool CIni::ValueExist(const CString &strCategoryName, const CString &strEntryName)
{	//	strCategoryName is in "[Name]" format
	int nEntryFirstCharPos, nCatFirstCharPos, nCatLastCharPos;

	if ((nCatFirstCharPos = m_strFileBuffer.Find(strCategoryName)) < 0)
		return false;	// Category does not exist

	// Check if the category is valid
	if (nCatFirstCharPos != 0)
	{
		CString	catSearchString(_T("\r\n"));

		catSearchString += strCategoryName;
		nCatFirstCharPos -= 2;
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);

		if (nCatFirstCharPos < 0)
			return false;

		nCatFirstCharPos += 2;
	}

	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() - 1));

	if (nCatLastCharPos < 0)
		// No following category exists - end of category is end of file
		nCatLastCharPos = m_strFileBuffer.GetLength();
	else
		nCatLastCharPos += 2;

	CString entrySearchString = _T("\r\n");
	entrySearchString += strEntryName;
	entrySearchString += _T('=');

	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() - 1));

	if (nEntryFirstCharPos >= 0)
		nEntryFirstCharPos += 2;
	else
		return false;

	if(nEntryFirstCharPos < nCatFirstCharPos || nEntryFirstCharPos > nCatLastCharPos)
		// The entry we're searching for does not exist in the given category
		return false;

	int nEndOfLine = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

	if (nEndOfLine < 0)
		nEndOfLine = m_strFileBuffer.GetLength();

	if ((nEntryFirstCharPos + strEntryName.GetLength() + 1) == nEndOfLine)
		return false;

	return true;
}
@


1.28
log
@Added default value to be used while reading byte array from ini file.
@
text
@d64 1
a64 1
		uint32 dwReaded = Read(tempBuffer, sizeof(tempBuffer) - 1);
d66 1
a66 1
		if (dwReaded > 3 && HAS_BOM(&tempBuffer[0]))
d78 1
a78 1
		//	(e.g. path, message filter) it could be that ini file contains string etries
d87 1
a87 1
			m_strFileBuffer.Preallocate(dwReaded);
d104 1
a104 1
			MB2Str(eCF, &m_strFileBuffer, &tempBuffer[dwOffset], (dwReaded - dwOffset));
@


1.27
log
@Added support for byte arrays; Replaced slow TrimRight(); Slightly faster bool array preparation.
@
text
@d466 1
a466 1
void CIni::GetArray(byte *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d470 2
a471 1
	int iPos = 0;
d474 6
a479 1
		pToArray[ui] = (iPos >= 0) ? (byte)_tstoi(temp.Tokenize(_T(","), iPos)) : 0;
@


1.26
log
@Added new service for uint16.
@
text
@d350 1
a350 1
	// bugfix: using escape characters for "\" and "," in strings - 08/25/03
d466 11
a476 1
void CIni::SetArray(CString *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d481 10
a490 3
		// bugfix: using escape characters for "\" and "," in strings - 08/25/03
		pToArray[ui].Replace(_T("\\"), _T("\\\\"));
		pToArray[ui].Replace(_T(","), _T("\\,"));
d492 7
a498 4
		m_strInternXchg += pToArray[ui];
		m_strInternXchg += _T(",");
	}
	m_strInternXchg.TrimRight(_T(','));
d503 1
a503 1
void CIni::SetArray(const double *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
a506 1
//	Different delimiter is used as comma is a decimal-point in some languages
d508 1
a508 2
		m_strInternXchg.AppendFormat(_T("%g|"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T('|'));
d513 1
a513 1
void CIni::SetArray(const int *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d518 1
a518 2
		m_strInternXchg.AppendFormat(_T("%d,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d523 1
a523 1
void CIni::SetArray(const WORD *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d525 2
d529 1
d531 4
a534 2
		m_strInternXchg.AppendFormat(_T("%u,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d539 1
a539 1
void CIni::SetArray(const bool *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d544 1
a544 2
		m_strInternXchg.AppendFormat(_T("%d,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
@


1.25
log
@Fixed migration of transfer window divider settings into preferenes.ini which didn't work when comma was a decimal delimiter {glaskrug} -- NB! current transfer window divider setting will be reset to default;
Faster strings operations by means of different trick to empty internal buffer string without reallocation.
@
text
@d274 5
@


1.24
log
@Optimized ini interface for reading string values to avoid unrequired memory reallocations.
@
text
@d426 1
d428 1
a428 1
		pToArray[ui] = (iPos >= 0) ? _tstof(temp.Tokenize(_T(","), iPos)) : 0.;
d463 1
a463 1
	m_strInternXchg = _T("");
d480 1
a480 1
	m_strInternXchg = _T("");
d482 1
d484 2
a485 2
		m_strInternXchg.AppendFormat(_T("%g,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d492 1
a492 1
	m_strInternXchg = _T("");
d503 1
a503 1
	m_strInternXchg = _T("");
d514 1
a514 1
	m_strInternXchg = _T("");
@


1.23
log
@Minor formatting.
@
text
@d238 1
a238 1
	GetValue(pcEntryName);
d244 7
d253 1
a253 1
	GetValue(pcEntryName);
d262 1
a262 1
	GetValue(pcEntryName);
d276 1
a276 1
	GetValue(pcEntryName);
d290 1
a290 1
	GetValue(pcEntryName);
d591 1
a591 1
void CIni::GetValue(const TCHAR *pcEntryName)
d621 1
a621 1
		m_strInternXchg = m_strFileBuffer.Mid(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
d624 1
a624 1
		m_strInternXchg = _T("");
@


1.22
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d106 1
a106 1
		// Cut off blank lines at the begin and the end of the file
@


1.21
log
@Removed unused float services; Const added for some prototypes [Aw3].
@
text
@d24 1
d26 1
a26 1
CIni::CIni(const CString &strFileName, bool bReadOnly/*false*/)
d31 2
a32 2
	OpenFile(strFileName, bReadOnly);
	ReadData();
d41 1
a41 1
void CIni::OpenFile(const CString &strFileName, bool bReadOnly)
d44 1
a44 1
		Open( strFileName, (bReadOnly) ? (CFile::modeRead | CFile::shareDenyWrite) :
d54 1
a54 1
void CIni::ReadData()
d59 3
a62 2
		Read(tempBuffer, sizeof(tempBuffer));
		m_strFileBuffer = tempBuffer;
d64 43
a106 1
		// Cut off blank lines at the end of the file
d117 12
a128 1
		Write(m_strFileBuffer, m_strFileBuffer.GetLength());
@


1.20
log
@Optimized to reduce numerous memory allocations; Reorganized handling of the category name to avoid useless overhead; Disabled unrolling of some extensivaly used functions to save on space as our compiler seems to be stutid enough to unroll huge functions when global optimization is in use; Corrected removal of ini category which was leaving extra empty line in the file (could be tested by Comment/Erase in Share Files list removing comment not for last category in fileinfo.ini) [Aw3].
@
text
@a197 9
float CIni::GetFloat(const TCHAR *pcEntryName, float defValue)
{
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		return defValue;
	else
		return (float)_tstof(m_strInternXchg);
}

a245 6
void CIni::SetFloat(const TCHAR *pcEntryName, float fValue)
{
	m_strInternXchg.Format(_T("%g"),fValue);
	SetValue(pcEntryName, m_strInternXchg);
}

a367 10
void CIni::GetArray(float *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int iPos = 0;

	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? (float)_tstof(temp.Tokenize(_T(","), iPos)) : 0.f;
}

d415 1
a415 12
void CIni::SetArray(double *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
{
	m_strInternXchg = _T("");

	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(_T("%g,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));

	SetString(pcEntryName, m_strInternXchg);
}

void CIni::SetArray(float *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d426 1
a426 1
void CIni::SetArray(int *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d437 1
a437 1
void CIni::SetArray(WORD *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d448 1
a448 1
void CIni::SetArray(bool *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d636 1
a636 1
bool CIni::ValueExist(const CString &strCategoryName, const CString& strEntryName)
@


1.19
log
@Extended INI interface to allow opening only in read-only mode (this way file isn't created when it didn't exist before) [Aw3].
@
text
@d1 1
a1 1
//	this file is part of eMule Plus
d27 2
d32 1
d79 3
a81 3
void CIni::AddCategory(const CString& strCategoryName)
{
	if(!CategoryExist(strCategoryName))
d83 1
a83 1
		if(m_strFileBuffer.GetLength()!=0)
a84 2

		m_strFileBuffer += _T('[');
a85 1
		m_strFileBuffer += _T(']');
d91 3
a93 1
	AddCategory(strCategoryName);
d95 1
a95 1
	m_strDefCategory = strCategoryName;
d101 2
d104 1
a104 1
	AddCategory(m_strDefCategory);
d109 5
a113 1
	if(CategoryExist(strCategoryName))
a114 4
		CString catSearchString = _T("[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

d118 1
a118 1
		if(nCatFirstCharPos!=0)
d125 1
a125 1
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
d133 2
d142 5
a146 1
	if(EntryExist(strCategoryName,strEntryName))
d148 1
a148 6
		CString catSearchString = _T("[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

		int nEntryFirstCharPos;
		int nEntryLastCharPos;
d181 1
a181 1
CString CIni::GetString(const TCHAR *pcEntryName, const CString& defValue)
d183 4
a186 6
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return strTemp;
d189 1
a189 1
double CIni::GetDouble(const TCHAR *pcEntryName, double defValue)
d191 2
a192 3
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
d195 1
a195 1
		return _tstof(strTemp);
d200 2
a201 3
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
d204 1
a204 1
		return (float)_tstof(strTemp);
d207 1
a207 1
int CIni::GetInt(const TCHAR *pcEntryName, int defValue)
d209 2
a210 3
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
d213 1
a213 1
		return _tstoi(strTemp);
d218 1
a218 6
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return _tstoi(strTemp);
d221 1
a221 1
uint64 CIni::GetUInt64(const TCHAR *pcEntryName, uint64 defValue)
d223 2
a224 3
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
d227 1
a227 1
		return _tstoi64(strTemp);
d235 1
a235 1
bool CIni::GetBool(const TCHAR *pcEntryName, bool defValue)
d237 2
a238 3
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
d241 1
a241 1
		return (_tstoi(strTemp) != 0);
d251 2
a252 4
	CString strValue;
	strValue.Format(_T("%g"),dValue);

	SetValue(pcEntryName, strValue);
d257 2
a258 4
	CString strValue;
	strValue.Format(_T("%g"),fValue);

	SetValue(pcEntryName, strValue);
d261 1
a261 1
void CIni::SetInt(const TCHAR *pcEntryName, int nValue)
d263 2
a264 4
	CString strValue;
	strValue.Format(_T("%d"),nValue);

	SetValue(pcEntryName, strValue);
d267 1
a267 1
void CIni::SetUInt32(const TCHAR *pcEntryName, uint32 nValue)
d269 2
a270 4
	CString strValue;
	strValue.Format(_T("%u"), nValue);

	SetValue(pcEntryName, strValue);
d273 1
a273 1
void CIni::SetUInt64(const TCHAR *pcEntryName, uint64 nValue)
d275 2
a276 4
	CString strValue;
	strValue.Format(_T("%I64u"),nValue);

	SetValue(pcEntryName, strValue);
d286 2
a287 3
	CString strValue = (bValue) ? _T("1") : _T("0");

	SetValue(pcEntryName, strValue);
d290 1
a290 1
void CIni::GetArray(CString* pToArray, int nElements, const TCHAR *pcEntryName)
d301 1
a301 1
		for(int i = 0; i < nElements; i++)
d308 1
a308 1
				pToArray[i] = _T("");
d314 1
a314 1
					pToArray[i] = temp.Mid(nLastPos, (temp.GetLength() - nLastPos));
d319 1
a319 1
					pToArray[i] = (nPos >= 0) ? temp.Mid(nLastPos,(nPos - nLastPos)) : _T("");
d329 1
a329 1
						pToArray[i] = temp.Mid(nLastPos,(temp.GetLength() - nLastPos));
d334 1
a334 1
						pToArray[i] = (nPos >= 0) ? temp.Mid(nLastPos,(nPos - nLastPos)) : _T("");
d351 1
a351 1
						pToArray[i] = temp.Mid(saveBegPos,(temp.GetLength() - saveBegPos));
d356 1
a356 1
						pToArray[i] = (nPos >= 0) ? temp.Mid(saveBegPos,(nPos - saveBegPos)) : _T("");
d362 2
a363 2
			pToArray[i].Replace(_T("\\,"),_T(","));
			pToArray[i].Replace(_T("\\\\"),_T("\\"));
d368 2
a369 2
		for(int i = 0; i < nElements; i++)
			pToArray[i] = (nPos >= 0) ? temp.Tokenize(_T(","), nPos) : _T("");
d373 1
a373 1
void CIni::GetArray(double* pToArray, int nElements, const TCHAR *pcEntryName)
d377 1
a377 1
	int nPos = 0;
d379 2
a380 2
	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? _tstof(temp.Tokenize(_T(","), nPos)) : 0.;
d383 1
a383 1
void CIni::GetArray(float* pToArray, int nElements, const TCHAR *pcEntryName)
d387 1
a387 1
	int nPos = 0;
d389 2
a390 2
	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? (float)_tstof(temp.Tokenize(_T(","),nPos)) : 0.f;
d393 1
a393 1
void CIni::GetArray(int* pToArray, int nElements, const TCHAR *pcEntryName)
d397 1
a397 1
	int nPos = 0;
d399 2
a400 2
	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? _tstoi(temp.Tokenize(_T(","),nPos)) : 0;
d403 1
a403 1
void CIni::GetArray(WORD* pToArray, int nElements, const TCHAR *pcEntryName)
d407 1
a407 1
	int nPos = 0;
d409 2
a410 2
	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? (WORD)_tstoi(temp.Tokenize(_T(","),nPos)) : 0;
d413 1
a413 1
void CIni::GetArray(bool* pToArray, int nElements, const TCHAR *pcEntryName)
d417 1
a417 1
	int token, nPos = 0;
d419 2
a420 5
	for(int i=0;i<nElements;i++)
	{
		token = (nPos >= 0) ? _tstoi(temp.Tokenize(_T(","),nPos)) : 0;
		pToArray[i] = (token != 0);
	}
d423 1
a423 1
void CIni::SetArray(CString* pToArray, int nElements, const TCHAR *pcEntryName)
d425 2
a426 3
	CString temp;

	for(int i=0;i<nElements;i++)
d429 2
a430 2
		pToArray[i].Replace(_T("\\"),_T("\\\\"));
		pToArray[i].Replace(_T(","),_T("\\,"));
d432 2
a433 2
		temp += pToArray[i];
		temp += _T(",");
d435 1
d437 1
a437 3
	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
d440 1
a440 1
void CIni::SetArray(double* pToArray, int nElements, const TCHAR *pcEntryName)
d442 1
a442 4
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%g,"), pToArray[i]);
d444 3
a446 1
	temp.TrimRight(_T(','));
d448 1
a448 1
	SetString(pcEntryName, temp);
d451 1
a451 1
void CIni::SetArray(float* pToArray, int nElements, const TCHAR *pcEntryName)
d453 1
a453 1
	CString temp;
d455 3
a457 2
	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%g,"), pToArray[i]);
d459 1
a459 3
	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
d462 1
a462 1
void CIni::SetArray(int* pToArray, int nElements, const TCHAR *pcEntryName)
d464 1
a464 4
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%d,"), pToArray[i]);
d466 3
a468 1
	temp.TrimRight(_T(','));
d470 1
a470 1
	SetString(pcEntryName, temp);
d473 1
a473 1
void CIni::SetArray(WORD* pToArray, int nElements, const TCHAR *pcEntryName)
d475 1
a475 1
	CString temp;
d477 3
a479 2
	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%u,"), pToArray[i]);
d481 1
a481 3
	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
d484 1
a484 1
void CIni::SetArray(bool* pToArray, int nElements, const TCHAR *pcEntryName)
d486 1
a486 4
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%d,"), pToArray[i]);
d488 3
a490 1
	temp.TrimRight(_T(','));
d492 1
a492 1
	SetString(pcEntryName, temp);
d497 1
a497 1
	CString	strEntryName = pcEntryName;
d499 1
a499 1
	if (EntryExist(m_strDefCategory, pcEntryName))
d501 2
a502 8
		CString catSearchString = _T("[");
		catSearchString += m_strDefCategory;
		catSearchString += _T(']');

		int nValueFirstCharPos;
		int nEntryFirstCharPos;
		int nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
a506 4
			catSearchString = _T("\r\n[");
			catSearchString += m_strDefCategory;
			catSearchString += _T(']');

d508 1
a508 1
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
d529 1
a529 1
	else
d531 4
a534 1
		if(CategoryExist(m_strDefCategory))
d536 4
a539 17
			CString catSearchString = _T("[");
			catSearchString += m_strDefCategory;
			catSearchString += _T(']');

			int nCatLastCharPos, nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

			// Check if the category is valid
			if (nCatFirstCharPos != 0)
			{
				catSearchString = _T("\r\n[");
				catSearchString += m_strDefCategory;
				catSearchString += _T(']');

				nCatFirstCharPos -= 2;
				nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
				nCatFirstCharPos += 2;
			}
d541 1
a541 1
			nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
d543 1
a543 1
			CString entryString;
d545 2
a546 2
			strEntryName += _T('=');
			strEntryName += strValue;
d548 12
a559 12
			if (nCatLastCharPos < 0)
			{
				nCatLastCharPos = m_strFileBuffer.GetLength();
				entryString = _T("\r\n");
				entryString += strEntryName;
			}
			else
			{
				nCatLastCharPos += 2;
				entryString = strEntryName;
				entryString += _T("\r\n");
			}
d561 1
a561 2
			m_strFileBuffer.Insert(nCatLastCharPos, entryString);
		}
d565 1
a565 1
CString CIni::GetValue(const TCHAR *pcEntryName)
d567 1
a567 1
	CString	strEntryName = pcEntryName;
d569 1
a569 1
	if (ValueExist(m_strDefCategory, strEntryName))
d571 2
a572 8
		CString catSearchString = _T("[");
		catSearchString += m_strDefCategory;
		catSearchString += _T(']');

		int nValueFirstCharPos;
		int nEntryFirstCharPos;
		int nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
a576 4
			catSearchString = _T("\r\n[");
			catSearchString += m_strDefCategory;
			catSearchString += _T(']');

d578 1
a578 1
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
d595 1
a595 1
		return m_strFileBuffer.Mid(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
d598 1
a598 1
		return _T("");
d601 3
a603 7
bool CIni::CategoryExist(const CString& strCategoryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');

	int nFindPos = m_strFileBuffer.Find(catSearchString);
d605 1
a605 1
	if (nFindPos < 0)
d609 1
a609 1
	if (nFindPos != 0)
d611 2
a612 1
		catSearchString = _T("\r\n[");
d614 2
a615 1
		catSearchString += _T(']');
d617 1
a617 4
		nFindPos -= 2;
		nFindPos = m_strFileBuffer.Find(catSearchString, nFindPos);

		if (nFindPos < 0)
d625 2
a626 4
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');
d628 2
a629 7
	int nEntryFirstCharPos;
	int nCatFirstCharPos;
	int nCatLastCharPos;

	if ((nCatFirstCharPos = m_strFileBuffer.Find(catSearchString)) < 0)
		// Category does not exist
		return false;
d634 2
a635 1
		catSearchString = _T("\r\n[");
a636 2
		catSearchString += _T(']');

d646 1
a646 1
	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() + 1));
d658 1
a658 1
	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() + 1));
d672 3
a674 5
bool CIni::ValueExist(const CString& strCategoryName, const CString& strEntryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');
d676 1
a676 5
	int nEntryFirstCharPos;
	int nCatFirstCharPos;
	int nCatLastCharPos;

	if ((nCatFirstCharPos = m_strFileBuffer.Find(catSearchString)) < 0)
d682 2
a683 1
		catSearchString = _T("\r\n[");
a684 2
		catSearchString += _T(']');

d694 1
a694 1
	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() + 1));
d706 1
a706 1
	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() + 1));
@


1.18
log
@Suppressed level 4 warnings.
@
text
@d1 16
d25 2
a26 1
CIni::CIni(const CString &strFileName) : m_strDefCategory(_T(""))
d28 1
a28 1
	OpenFile(strFileName);
d37 1
a37 1
void CIni::OpenFile(const CString& strFileName)
d39 3
a41 2
	if(m_hFile == CFile::hFileNull)
		Open(strFileName, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyWrite);
d46 1
a46 1
	if(m_hFile!=CFile::hFileNull)
d52 1
a52 1
	if(m_hFile!=CFile::hFileNull)
d66 1
a66 1
	if(m_hFile!=CFile::hFileNull)
d70 1
a70 1
		Write(m_strFileBuffer,m_strFileBuffer.GetLength());
@


1.17
log
@Minor optimization; Formatting.
@
text
@d23 1
a23 1
		BOOL bRetCode = Open(strFileName, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyWrite);
@


1.16
log
@Faster processing of ini-file settings and preferences values.
@
text
@d22 1
a22 1
	if(m_hFile==CFile::hFileNull)
d38 1
a38 1
		Read(tempBuffer,sizeof(tempBuffer));
d107 1
a107 1
		int nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["),(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d109 2
a110 2
		if(nCatLastCharPos == (-1))
			nCatLastCharPos = (m_strFileBuffer.GetLength());
d112 1
a112 1
		m_strFileBuffer.Delete(nCatFirstCharPos,(nCatLastCharPos - nCatFirstCharPos));
d124 3
a126 4
		int nEntryFirstCharPos = 0;
		int nEntryLastCharPos = 0;
		int nCatFirstCharPos = 0;
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
d129 1
a129 1
		if(nCatFirstCharPos!=0)
d136 1
a136 1
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
d144 1
a144 1
		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d147 1
a147 1
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"),nEntryFirstCharPos);
d149 1
a149 1
		if(nEntryLastCharPos==(-1))
d154 1
a154 1
		m_strFileBuffer.Delete(nEntryFirstCharPos,(nEntryLastCharPos - nEntryFirstCharPos));
d299 1
a299 1
	if(temp.Find(_T('\\')) != (-1))
d301 1
a301 1
		for(int i=0;i<nElements;i++)
d314 1
a314 1
					pToArray[i] = temp.Mid(nLastPos,(temp.GetLength() - nLastPos));
d368 2
a369 2
		for(int i=0;i<nElements;i++)
			pToArray[i] = (nPos >= 0) ? temp.Tokenize(_T(","),nPos) : _T("");
d380 1
a380 1
		pToArray[i] = (nPos >= 0) ? _tstof(temp.Tokenize(_T(","),nPos)) : 0.;
d515 4
a518 6
		int nValueFirstCharPos = 0;
		int nEntryFirstCharPos = 0;
		int nEntryLastCharPos = 0;
		int nCatFirstCharPos = 0;

		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
d521 1
a521 1
		if(nCatFirstCharPos!=0)
d536 1
a536 1
		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
d538 1
a538 1
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"),nEntryFirstCharPos);
d540 1
a540 1
		if(nEntryLastCharPos==(-1))
d546 2
a547 2
		m_strFileBuffer.Delete(nValueFirstCharPos,(nEntryLastCharPos - nValueFirstCharPos));
		m_strFileBuffer.Insert(nValueFirstCharPos,strValue);
d557 1
a557 4
			int nCatFirstCharPos = 0;
			int nCatLastCharPos = 0;

			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
d560 1
a560 1
			if(nCatFirstCharPos!=0)
d571 1
a571 1
			nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["),(nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
d578 1
a578 1
			if(nCatLastCharPos==(-1))
d591 1
a591 1
			m_strFileBuffer.Insert(nCatLastCharPos,entryString);
d606 4
a609 6
		int nValueFirstCharPos = 0;
		int nEntryFirstCharPos = 0;
		int nEntryLastCharPos = 0;
		int nCatFirstCharPos = 0;

		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
d612 1
a612 1
		if(nCatFirstCharPos!=0)
d627 1
a627 1
		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
d629 1
a629 1
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"),nEntryFirstCharPos);
d631 1
a631 1
		if(nEntryLastCharPos==(-1))
d636 1
a636 1
		return m_strFileBuffer.Mid(nValueFirstCharPos,(nEntryLastCharPos - nValueFirstCharPos));
d650 1
a650 1
	if(nFindPos==(-1))
d654 1
a654 1
	if(nFindPos!=0)
d661 1
a661 1
		nFindPos = m_strFileBuffer.Find(catSearchString,nFindPos);
d663 1
a663 1
		if(nFindPos==(-1))
d676 3
a678 4
	int nEntryFirstCharPos = 0;
	int nCatFirstCharPos = 0;
	int nCatLastCharPos = 0;
	nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
d680 1
a680 1
	if(nCatFirstCharPos==(-1))
d685 1
a685 1
	if(nCatFirstCharPos!=0)
d692 1
a692 1
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
d694 1
a694 1
		if(nCatFirstCharPos==(-1))
d700 1
a700 1
	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["),(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d702 1
a702 1
	if(nCatLastCharPos==(-1))
d712 1
a712 1
	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d714 1
a714 1
	if(nEntryFirstCharPos!=(-1))
d719 1
a719 1
	if(nEntryFirstCharPos<nCatFirstCharPos || nEntryFirstCharPos>nCatLastCharPos)
d732 3
a734 4
	int nEntryFirstCharPos = 0;
	int nCatFirstCharPos = 0;
	int nCatLastCharPos = 0;
	nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);
d736 2
a737 3
	if(nCatFirstCharPos==(-1))
		// Category does not exist
		return false;
d740 1
a740 1
	if(nCatFirstCharPos!=0)
d747 1
a747 1
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
d749 1
a749 1
		if(nCatFirstCharPos==(-1))
d755 1
a755 1
	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["),(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d757 1
a757 1
	if(nCatLastCharPos==(-1))
d767 1
a767 1
	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d769 1
a769 1
	if(nEntryFirstCharPos!=(-1))
d774 1
a774 1
	if(nEntryFirstCharPos<nCatFirstCharPos || nEntryFirstCharPos>nCatLastCharPos)
d778 1
a778 1
	int nEndOfLine = m_strFileBuffer.Find(_T("\r\n"),nEntryFirstCharPos);
d780 1
a780 1
	if(nEndOfLine==(-1))
d783 1
a783 1
	if((nEntryFirstCharPos + strEntryName.GetLength() + 1) == nEndOfLine)
@


1.15
log
@Improved string processing
@
text
@a3 1
// Last Update: 08/24/2003
d9 1
a9 1
CIni::CIni(const CString& strFileName)
d11 1
a11 4
	m_strFileName=strFileName;
	m_strDefCategory=_T("");

	OpenFile();
d20 1
a20 1
void CIni::OpenFile()
d23 1
a23 1
		BOOL bRetCode = Open((LPCTSTR)m_strFileName,CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyWrite);
d65 1
a65 1
		m_strFileBuffer += _T("[");
d67 1
a67 1
		m_strFileBuffer += _T("]");
d73 8
d82 1
a82 7
	if(!CategoryExist(strCategoryName))
	{
		AddCategory(strCategoryName);
		m_strDefCategory = strCategoryName;
	}
	else
		m_strDefCategory = strCategoryName;
d91 1
a91 1
		catSearchString += _T("]");
d100 1
a100 1
			catSearchString += _T("]");
d122 1
a122 1
		catSearchString += _T("]");
d134 1
a134 1
			catSearchString += _T("]");
d143 1
a143 1
		entrySearchString += _T("=");
d159 1
a159 1
CString CIni::GetString(const CString& strEntryName, const CString& defValue, const CString& strCategoryName)
d161 1
a161 2
	CString finalCatName;
	CString temp;
d163 1
a163 12
	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}

	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d166 1
a166 1
		return temp;
d169 1
a169 1
double CIni::GetDouble(const CString& strEntryName, double defValue, const CString& strCategoryName)
d171 1
a171 13
	CString finalCatName;
	CString temp;

	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}
d173 1
a173 1
	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d176 1
a176 1
		return _tstof(temp);
d179 1
a179 1
float CIni::GetFloat(const CString& strEntryName, float defValue, const CString& strCategoryName)
d181 1
a181 13
	CString finalCatName;
	CString temp;

	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}
d183 1
a183 1
	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d186 1
a186 1
		return (float)_tstof(temp);
d189 1
a189 1
int CIni::GetInt(const CString& strEntryName, int defValue, const CString& strCategoryName)
d191 1
a191 2
	CString finalCatName;
	CString temp;
d193 1
a193 12
	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}

	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d196 1
a196 1
		return _tstoi(temp);
d199 1
a199 1
uint32 CIni::GetUInt32(const CString& strEntryName, uint32 defValue, const CString& strCategoryName)
d201 1
a201 2
	CString finalCatName;
	CString temp;
d203 1
a203 12
	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}

	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d206 1
a206 1
		return _tstoi(temp);
d209 1
a209 1
uint64 CIni::GetUInt64(const CString& strEntryName, uint64 defValue, const CString& strCategoryName)
d211 1
a211 2
	CString finalCatName;
	CString temp;
d213 1
a213 12
	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}

	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d216 1
a216 1
		return _tstoi64(temp);
d219 1
a219 1
WORD CIni::GetWORD(const CString& strEntryName, WORD defValue, const CString& strCategoryName)
d221 1
a221 18
	CString finalCatName;
	CString temp;

	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}

	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
		return defValue;
	else
		return (WORD)_tstoi(temp);
d224 1
a224 1
bool CIni::GetBool(const CString& strEntryName, bool defValue, const CString& strCategoryName)
d226 1
a226 2
	CString finalCatName;
	CString temp;
d228 1
a228 12
	if(strCategoryName!=_T(""))
	{
		finalCatName = strCategoryName;
		temp = GetValue(finalCatName,strEntryName);
	}
	else
	{
		finalCatName = m_strDefCategory;
		temp = GetValue(finalCatName,strEntryName);
	}

	if(temp==_T("") && EntryExist(finalCatName,strEntryName)==false)
d231 1
a231 1
		return (_tstoi(temp)!=0);
d234 1
a234 1
void CIni::SetString(const CString& strEntryName, const CString& strValue, const CString& strCategoryName)
d236 1
a236 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d239 1
a239 1
void CIni::SetDouble(const CString& strEntryName, double dValue, const CString& strCategoryName)
d244 1
a244 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d247 1
a247 1
void CIni::SetFloat(const CString& strEntryName, float fValue, const CString& strCategoryName)
d252 1
a252 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d255 1
a255 1
void CIni::SetInt(const CString& strEntryName, int nValue, const CString& strCategoryName)
d260 1
a260 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d263 1
a263 2

void CIni::SetUInt32(const CString& strEntryName, uint32 nValue, const CString& strCategoryName)
d266 1
a266 1
	strValue.Format(_T("%I32u"),nValue);
d268 1
a268 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d271 1
a271 1
void CIni::SetUInt64(const CString& strEntryName, uint64 nValue, const CString& strCategoryName)
d276 1
a276 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d279 1
a279 2

void CIni::SetWORD(const CString& strEntryName, WORD wValue, const CString& strCategoryName)
d281 1
a281 7
	CString strValue;
	strValue.Format(_T("%u"),wValue);

	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d284 1
a284 1
void CIni::SetBool(const CString& strEntryName, bool bValue, const CString& strCategoryName)
d286 1
a286 2
	CString strValue;
	strValue.Format(_T("%d"),bValue);
d288 1
a288 4
	if(strCategoryName!=_T(""))
		SetValue(strCategoryName,strEntryName,strValue);
	else
		SetValue(m_strDefCategory,strEntryName,strValue);
d291 1
a291 1
void CIni::GetArray(CString* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d293 1
a293 6
	CString temp;
	
	if(strCategoryName==_T(""))
		temp = GetString(strEntryName,_T(""),m_strDefCategory);
	else
		temp = GetString(strEntryName,_T(""),strCategoryName);
d374 1
a374 1
void CIni::GetArray(double* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d376 1
a376 6
	CString temp;
	
	if(strCategoryName==_T(""))
		temp = GetString(strEntryName,_T(""),m_strDefCategory);
	else
		temp = GetString(strEntryName,_T(""),strCategoryName);
d384 1
a384 1
void CIni::GetArray(float* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d386 1
a386 6
	CString temp;
	
	if(strCategoryName==_T(""))
		temp = GetString(strEntryName,_T(""),m_strDefCategory);
	else
		temp = GetString(strEntryName,_T(""),strCategoryName);
d394 1
a394 1
void CIni::GetArray(int* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d396 1
a396 6
	CString temp;
	
	if(strCategoryName==_T(""))
		temp = GetString(strEntryName,_T(""),m_strDefCategory);
	else
		temp = GetString(strEntryName,_T(""),strCategoryName);
d404 1
a404 1
void CIni::GetArray(WORD* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d406 1
a406 6
	CString temp;
	
	if(strCategoryName==_T(""))
		temp = GetString(strEntryName,_T(""),m_strDefCategory);
	else
		temp = GetString(strEntryName,_T(""),strCategoryName);
d414 1
a414 1
void CIni::GetArray(bool* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d416 1
a416 6
	CString temp;
	
	if(strCategoryName==_T(""))
		temp = GetString(strEntryName,_T(""),m_strDefCategory);
	else
		temp = GetString(strEntryName,_T(""),strCategoryName);
d418 1
a418 2
	int token = 0;
	int nPos = 0;
d422 2
a423 6
		token = (nPos >= 0) ? _tstoi(temp.Tokenize(_T(","),nPos)) : false;

		if(token!=0)
			pToArray[i] = true;
		else
			pToArray[i] = false;
d427 1
a427 1
void CIni::SetArray(CString* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d429 1
a429 1
	CString temp = _T("");
d443 1
a443 4
	if(strCategoryName==_T(""))
		SetString(strEntryName,temp,m_strDefCategory);
	else
		SetString(strEntryName,temp,strCategoryName);
d446 1
a446 1
void CIni::SetArray(double* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d448 1
a448 2
	CString temp = _T("");
	CString strValue = _T("");
d450 2
a451 6
	for(int i=0;i<nElements;i++)
	{
		strValue.Format(_T("%g"),pToArray[i]);
		temp += strValue;
		temp += _T(',');
	}
d455 1
a455 4
	if(strCategoryName==_T(""))
		SetString(strEntryName,temp,m_strDefCategory);
	else
		SetString(strEntryName,temp,strCategoryName);
d458 1
a458 1
void CIni::SetArray(float* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d460 1
a460 2
	CString temp = _T("");
	CString strValue = _T("");
d462 2
a463 6
	for(int i=0;i<nElements;i++)
	{
		strValue.Format(_T("%g"),pToArray[i]);
		temp += strValue;
		temp += _T(',');
	}
d467 1
a467 4
	if(strCategoryName==_T(""))
		SetString(strEntryName,temp,m_strDefCategory);
	else
		SetString(strEntryName,temp,strCategoryName);
d470 1
a470 1
void CIni::SetArray(int* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d472 1
a472 2
	CString temp = _T("");
	CString strValue = _T("");
d474 2
a475 6
	for(int i=0;i<nElements;i++)
	{
		strValue.Format(_T("%d"),pToArray[i]);
		temp += strValue;
		temp += _T(',');
	}
d479 1
a479 4
	if(strCategoryName==_T(""))
		SetString(strEntryName,temp,m_strDefCategory);
	else
		SetString(strEntryName,temp,strCategoryName);
d482 1
a482 1
void CIni::SetArray(WORD* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d484 1
a484 2
	CString temp = _T("");
	CString strValue = _T("");
d486 2
a487 6
	for(int i=0;i<nElements;i++)
	{
		strValue.Format(_T("%u"),pToArray[i]);
		temp += strValue;
		temp += _T(',');
	}
d491 1
a491 4
	if(strCategoryName==_T(""))
		SetString(strEntryName,temp,m_strDefCategory);
	else
		SetString(strEntryName,temp,strCategoryName);
d494 1
a494 1
void CIni::SetArray(bool* pToArray, int nElements, const CString& strEntryName, const CString& strCategoryName)
d496 1
a496 2
	CString temp = _T("");
	CString strValue = _T("");
d498 2
a499 6
	for(int i=0;i<nElements;i++)
	{
		strValue.Format(_T("%d"),pToArray[i]);
		temp += strValue;
		temp += _T(',');
	}
d503 1
a503 4
	if(strCategoryName==_T(""))
		SetString(strEntryName,temp,m_strDefCategory);
	else
		SetString(strEntryName,temp,strCategoryName);
d506 1
a506 1
void CIni::SetValue(const CString& strCategoryName, const CString& strEntryName, const CString& strValue)
d508 3
a510 1
	if(EntryExist(strCategoryName,strEntryName))
d513 2
a514 2
		catSearchString += strCategoryName;
		catSearchString += _T("]");
d527 2
a528 2
			catSearchString += strCategoryName;
			catSearchString += _T("]");
d537 1
a537 1
		entrySearchString += _T("=");
d539 1
a539 1
		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d554 1
a554 1
		if(CategoryExist(strCategoryName))
d557 2
a558 2
			catSearchString += strCategoryName;
			catSearchString += _T("]");
d569 2
a570 2
				catSearchString += strCategoryName;
				catSearchString += _T("]");
d577 3
a579 1
			nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["),(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d581 2
a582 1
			CString entryString = _T("");
a588 2
				entryString += _T("=");
				entryString += strValue;
a593 2
				entryString += _T("=");
				entryString += strValue;
d602 1
a602 1
CString CIni::GetValue(const CString& strCategoryName, const CString& strEntryName)
d604 3
a606 1
	if(ValueExist(strCategoryName,strEntryName))
d609 2
a610 2
		catSearchString += strCategoryName;
		catSearchString += _T("]");
d623 2
a624 2
			catSearchString += strCategoryName;
			catSearchString += _T("]");
d633 1
a633 1
		entrySearchString += _T("=");
d635 1
a635 1
		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString,(nCatFirstCharPos + strCategoryName.GetLength() + 1));
d654 1
a654 1
	catSearchString += _T("]");
d666 1
a666 1
		catSearchString += _T("]");
d678 1
a678 1
bool CIni::EntryExist(const CString& strCategoryName, const CString& strEntryName)
d682 1
a682 1
	catSearchString += _T("]");
d698 1
a698 1
		catSearchString += _T("]");
d718 2
a719 2
	entrySearchString += strEntryName;
	entrySearchString += _T("=");
d739 1
a739 1
	catSearchString += _T("]");
d755 1
a755 1
		catSearchString += _T("]");
d776 1
a776 1
	entrySearchString += _T("=");
d798 1
a798 1
}@


1.14
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d438 1
a438 1
	if(temp.Find(_T("\\")) != (-1))
d443 2
a444 2
			nPos = temp.Find(_T(","),nLastPos);
			nEscapePos = temp.Find(_T("\\"),nLastPos);
d484 2
a485 2
						nPos = temp.Find(_T(","),nLastPos);
						nEscapePos = temp.Find(_T("\\"),nLastPos);
d609 1
a609 1
	temp.TrimRight(_T(","));
d626 1
a626 1
		temp += _T(",");
d629 1
a629 1
	temp.TrimRight(_T(","));
d646 1
a646 1
		temp += _T(",");
d649 1
a649 1
	temp.TrimRight(_T(","));
d666 1
a666 1
		temp += _T(",");
d669 1
a669 1
	temp.TrimRight(_T(","));
d686 1
a686 1
		temp += _T(",");
d689 1
a689 1
	temp.TrimRight(_T(","));
d706 1
a706 1
		temp += _T(",");
d709 1
a709 1
	temp.TrimRight(_T(","));
@


1.13
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d41 1
a41 1
		memset2(tempBuffer,0,sizeof(tempBuffer));
@


1.12
log
@allow shared read of preferences.ini to avoid multiple instances problems (fast adding of multiple links)
@
text
@d8 1
d41 1
a41 1
		memset(tempBuffer,0,sizeof(tempBuffer));
@


1.11
log
@BUGFIX: Now using escape characters for string arrays to prevent errors!
@
text
@d26 1
a26 1
		BOOL bRetCode = Open((LPCTSTR)m_strFileName,CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite);
@


1.10
log
@bugfix: CIni::GetUInt64() uses now _tstoi64() for convertion instead of _tstoi32()
@
text
@d2 1
a2 1
// ***************************************************************
d4 1
a4 2
// It supports up to 256KByte large ini files at the moment!
// Date: 07/29/2003
a6 1
#include "types.h"
d39 1
a39 1
		char tempBuffer[262144]; // change this value to support larger files!
a40 1

d433 66
d500 9
a508 2
	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? temp.Tokenize(_T(","),nPos) : _T("");
d600 4
@


1.9
log
@added new types uint32 & uint64
@
text
@d292 1
a292 1
		return _tstoi(temp);
@


1.8
log
@small bugfix
@
text
@d8 1
d251 44
d379 24
@


1.7
log
@changed INI file interface + little bugfix
@
text
@d369 1
a369 1
		pToArray[i] = temp.Tokenize(_T(","),nPos);
d384 1
a384 1
		pToArray[i] = _tstof(temp.Tokenize(_T(","),nPos));
d399 1
a399 1
		pToArray[i] = (float)_tstof(temp.Tokenize(_T(","),nPos));
d414 1
a414 1
		pToArray[i] = _tstoi(temp.Tokenize(_T(","),nPos));
d429 1
a429 1
		pToArray[i] = (WORD)_tstoi(temp.Tokenize(_T(","),nPos));
d446 1
a446 1
		token = _tstoi(temp.Tokenize(_T(","),nPos));
@


1.6
log
@unicode cleanup
@
text
@d1 5
a5 3
// Ini.cpp: Implementierung der Klasse CIni.
//
//////////////////////////////////////////////////////////////////////
d8 1
a8 2
#include "Ini2.h"
#include "memcpy_amd.h"
d10 8
a17 127
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// If the IniFilename contains no path,
// the module-directory will be add to the FileName,
// to avoid storing in the windows-directory
/*static*/ void CIni::AddModulPath(CString& strFileName,BOOL bModulPath /*= TRUE*/)
{
   TCHAR drive[_MAX_DRIVE];
   TCHAR dir[_MAX_DIR];
   TCHAR fname[_MAX_FNAME];
   TCHAR ext[_MAX_EXT];

   _tsplitpath( strFileName, drive, dir, fname, ext );
   if( ! drive[0]  )
   {
      //PathCanonicalize(..) doesn't work with for all Plattforms !
      CString strModule;
      if( bModulPath )
      {
         GetModuleFileName(NULL,strModule.GetBuffer(MAX_INI_BUFFER),MAX_INI_BUFFER);
         strModule.ReleaseBuffer();
      }
      else
      {
         GetCurrentDirectory(MAX_INI_BUFFER,strModule.GetBuffer(MAX_INI_BUFFER));
         strModule.ReleaseBuffer();
         // fix by "cpp@@world-online.no"
         strModule.TrimRight('\\');
         strModule.TrimRight('/');
         strModule += "\\";
      }
      strModule.ReleaseBuffer();
      _tsplitpath( strModule, drive, dir, fname, ext );
      strModule = drive;
      strModule+= dir;
      strModule+= strFileName;
      strFileName = strModule;
   }
}
/*static*/ CString CIni::GetDefaultSection()
{
   return AfxGetAppName();
}
/*static*/ CString CIni::GetDefaultIniFile(BOOL bModulPath /*= TRUE*/)
{
   TCHAR drive[_MAX_DRIVE];
   TCHAR dir[_MAX_DIR];
   TCHAR fname[_MAX_FNAME];
   TCHAR ext[_MAX_EXT];
   CString strTemp;
   CString strApplName;
   GetModuleFileName(NULL,strTemp.GetBuffer(MAX_INI_BUFFER),MAX_INI_BUFFER);
   strTemp.ReleaseBuffer();
   _tsplitpath( strTemp, drive, dir, fname, ext );
   strTemp = fname; //"ApplName"
   strTemp += ".ini";  //"ApplName.ini"
   if( bModulPath )
   {
      strApplName  = drive;
      strApplName += dir;
      strApplName += strTemp;
   }
   else
   {
      GetCurrentDirectory(MAX_INI_BUFFER,strApplName.GetBuffer(MAX_INI_BUFFER));
      strApplName.ReleaseBuffer();
      strApplName.TrimRight('\\');
      strApplName.TrimRight('/');
      strApplName += "\\";
      strApplName += strTemp;
   }
   return strApplName;
}
//////////////////////////////////////////////////////////////////////
// Konstruktion/Destruktion
//////////////////////////////////////////////////////////////////////
// Creates/Use file : "Drive:\ApplPath\ApplName.ini"
CIni::CIni(BOOL bModulPath /*= TRUE*/):
   m_bModulPath(bModulPath)
{
   m_strFileName = GetDefaultIniFile(m_bModulPath);
   m_strSection  = GetDefaultSection();
}
CIni::CIni(const CIni& ini, BOOL bModulPath /*= TRUE*/):
   m_bModulPath(ini.m_bModulPath)
{
   if(ini.m_strFileName.IsEmpty())
      m_strFileName = GetDefaultIniFile(m_bModulPath);
   else
	  m_strFileName = ini.m_strFileName;

   AddModulPath(m_strFileName,m_bModulPath);
   
   if(ini.m_strSection.IsEmpty())
      m_strSection = GetDefaultSection();
   else
	 m_strSection = ini.m_strSection;
}
CIni::CIni(const CString& strFileName, BOOL bModulPath /*= TRUE*/):	
   m_bModulPath(bModulPath)
{
   if(strFileName.IsEmpty())
      m_strFileName = GetDefaultIniFile(m_bModulPath);
   else
      m_strFileName = strFileName;
   AddModulPath(m_strFileName,bModulPath);
   m_strSection = GetDefaultSection();
}
CIni::CIni(const CString& strFileName, const CString& strSection, BOOL bModulPath /*= TRUE*/):
   m_bModulPath(bModulPath)
{
   if(strFileName.IsEmpty())
      m_strFileName = GetDefaultIniFile(m_bModulPath);
   else
      m_strFileName = strFileName;

   AddModulPath(m_strFileName,bModulPath);
   
   if(strSection.IsEmpty())
      m_strSection = GetDefaultSection();
   else
	  m_strSection = strSection;
}	
d21 1
d23 2
a24 4
//////////////////////////////////////////////////////////////////////
// Zugriff auf Quelle/Ziel von IO-Operationen
//////////////////////////////////////////////////////////////////////
void CIni::SetFileName(const CString& strFileName)
d26 2
a27 2
	m_strFileName = strFileName;
   AddModulPath(m_strFileName);
d29 2
a30 1
void CIni::SetSection(const CString& strSection)
d32 2
a33 1
	m_strSection = strSection;
d36 1
a36 1
CString CIni::GetFileName() const
d38 11
a48 1
	return m_strFileName;
d50 2
a51 1
CString CIni::GetSection() const
d53 8
a60 1
	return m_strSection;
a61 3
//////////////////////////////////////////////////////////////////////
// 
//////////////////////////////////////////////////////////////////////
d63 6
d70 4
a73 6
void CIni::Init( LPCTSTR strFileName, LPCTSTR strSection/* = NULL*/)
{
	if(strSection != NULL)
		m_strSection = strSection;
	if(strFileName != NULL)
		m_strFileName = strFileName;
d75 2
a76 1
CString CIni::GetString(const CString& strEntry,LPCTSTR strDefault/*=NULL*/,LPCTSTR strSection/* = NULL*/)
d78 6
a83 2
	if(strDefault == NULL)
		return CString(GetLPCTSTR(strEntry,strSection,_T("")));
d85 1
a85 1
		return CString(GetLPCTSTR(strEntry,strSection,strDefault));
d87 2
a88 22
double CIni::GetDouble(const CString& strEntry,double fDefault/* = 0.0*/,LPCTSTR strSection/* = NULL*/)
{
	CString strDefault;
	strDefault.Format(_T("%g"),fDefault);
	GetLPCTSTR(strEntry,strSection,strDefault);
	return _tstof(m_chBuffer);
}
float CIni::GetFloat(const CString& strEntry,float fDefault/* = 0.0*/, LPCTSTR strSection/* = NULL*/)
{
	CString strDefault;
	strDefault.Format(_T("%g"),fDefault);
	GetLPCTSTR(strEntry,strSection,strDefault);
	return (float)_tstof(m_chBuffer);
}
int CIni::GetInt(const CString& strEntry,int nDefault/* = 0*/,LPCTSTR strSection/* = NULL*/)
{
	CString strDefault;
	strDefault.Format(_T("%d"),nDefault);
	GetLPCTSTR(strEntry,strSection,strDefault);
	return _tstoi(m_chBuffer);
}
WORD CIni::GetWORD(const CString& strEntry,WORD nDefault/* = 0*/,LPCTSTR strSection/* = NULL*/)
d90 5
a94 15
	CString strDefault;
	strDefault.Format(_T("%u"),nDefault);
	GetLPCTSTR(strEntry,strSection,strDefault);
	return (WORD)_tstoi(m_chBuffer);
}
BOOL CIni::GetBool(const CString& strEntry,BOOL bDefault/* = FALSE*/,LPCTSTR strSection/* = NULL*/)
{
	CString strDefault;
	strDefault.Format(_T("%d"),bDefault);
	GetLPCTSTR(strEntry,strSection,strDefault);
	return ( _tstoi(m_chBuffer) != 0 );
}
CPoint CIni::GetPoint(const CString& strEntry,	CPoint ptDefault, LPCTSTR strSection)
{
	CPoint ptReturn=ptDefault;
d96 1
a96 2
	CString strDefault;
	strDefault.Format(_T("(%d,%d)"),ptDefault.x, ptDefault.y);
d98 6
a103 2
	CString strPoint = GetString(strEntry,strDefault);
	_stscanf(strPoint,_T("(%d,%d)"), &ptReturn.x, &ptReturn.y);
d105 4
a108 5
	return ptReturn;
}
CRect CIni::GetRect(const CString& strEntry, CRect rectDefault, LPCTSTR strSection)
{
	CRect rectReturn=rectDefault;
d110 1
a110 3
	CString strDefault;
	//old version :strDefault.Format(_T("(%d,%d,%d,%d)"),rectDefault.top,rectDefault.left,rectDefault.bottom,rectDefault.right);
	strDefault.Format(_T("%d,%d,%d,%d"),rectDefault.left,rectDefault.top,rectDefault.right,rectDefault.bottom);
d112 2
a113 1
	CString strRect = GetString(strEntry,strDefault);
d115 2
a116 6
   //new Version found
   if( 4==_stscanf(strRect,_T("%d,%d,%d,%d"),&rectDefault.left,&rectDefault.top,&rectDefault.right,&rectDefault.bottom))
	   return rectReturn;
   //old Version found
   _stscanf(strRect,_T("(%d,%d,%d,%d)"), &rectReturn.top,&rectReturn.left,&rectReturn.bottom,&rectReturn.right);
	return rectReturn;
d118 2
a119 1
COLORREF CIni::GetColRef(const CString& strEntry, COLORREF crDefault, LPCTSTR strSection)
d121 26
a146 3
	int temp[3]={	GetRValue(crDefault),
					GetGValue(crDefault),
					GetBValue(crDefault)};
d148 2
a149 2
	CString strDefault;
	strDefault.Format(_T("RGB(%hd,%hd,%hd)"),temp[0],temp[1],temp[2]);
d151 1
a151 2
	CString strColRef = GetString(strEntry,strDefault);
	_stscanf(strColRef,_T("RGB(%d,%d,%d)"), temp, temp+1, temp+2);
d153 7
a159 1
	return RGB(temp[0],temp[1],temp[2]);
d161 2
a162 2
	
void CIni::WriteString(const CString& strEntry,const CString& str, LPCTSTR strSection/* = NULL*/)
d164 18
a181 3
	if(strSection != NULL) 
		m_strSection = strSection;
	WritePrivateProfileString(m_strSection,strEntry,str,m_strFileName);
d183 2
a184 1
void CIni::WriteDouble(const CString& strEntry,double f, LPCTSTR strSection/*= NULL*/)
d186 18
a203 5
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("%g"),f);
		WritePrivateProfileString(m_strSection,strEntry,strBuffer,m_strFileName);
d205 2
a206 1
void CIni::WriteFloat(const CString& strEntry,float f, LPCTSTR strSection/* = NULL*/)
d208 18
a225 5
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("%g"),f);
		WritePrivateProfileString(m_strSection,strEntry,strBuffer,m_strFileName);
d227 2
a228 1
void CIni::WriteInt(const CString& strEntry,int n, LPCTSTR strSection/* = NULL*/)
d230 18
a247 5
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("%d"),n);
		WritePrivateProfileString(m_strSection,strEntry,strBuffer,m_strFileName);
d249 2
a250 1
void CIni::WriteWORD(const CString& strEntry,WORD n, LPCTSTR strSection/* = NULL*/)
d252 18
a269 5
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("%u"),n);
		WritePrivateProfileString(m_strSection,strEntry,strBuffer,m_strFileName);
d271 2
a272 1
void CIni::WriteBool(const CString& strEntry,BOOL b, LPCTSTR strSection/* = NULL*/)
d274 2
a275 35
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("%d"),b);
		WritePrivateProfileString(m_strSection, strEntry, strBuffer, m_strFileName);
}
void CIni::WritePoint(const CString& strEntry,const CPoint& pt, LPCTSTR strSection)
{
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("(%d,%d)"),pt.x,pt.y);
	Write(m_strFileName,m_strSection,strEntry,strBuffer);
}
void CIni::WriteRect(const CString& strEntry,const CRect& rect, LPCTSTR strSection)
{
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("(%d,%d,%d,%d)"),rect.top,rect.left,rect.bottom,rect.right);
	Write(m_strFileName,m_strSection,strEntry,strBuffer);
}
void CIni::WriteColRef(const CString& strEntry,COLORREF cr, LPCTSTR strSection)
{
	if(strSection != NULL) 
		m_strSection = strSection;
	CString strBuffer;
	strBuffer.Format(_T("RGB(%d,%d,%d)"),GetRValue(cr), GetGValue(cr), GetBValue(cr));
	Write(m_strFileName,m_strSection,strEntry,strBuffer);
}
char* CIni::GetLPCTSTR(const CString& strEntry, LPCTSTR strSection, LPCTSTR strDefault)
{
	// evtl Section neu setzen
	if(strSection != NULL)
		m_strSection = strSection;
d277 5
a281 3
	CString temp;
	if(strDefault == NULL)
		temp = Read(m_strFileName,m_strSection,strEntry,CString());
d283 4
a286 1
		temp = Read(m_strFileName,m_strSection,strEntry,strDefault);
d288 4
a291 5
	#ifndef AMD
	return (char*)memcpy(m_chBuffer,(LPCTSTR)temp,temp.GetLength()+1);// '+1' damit die Null am Ende mit kopiert wird
	#else
	return (char*)memcpy_amd(m_chBuffer,(LPCTSTR)temp,temp.GetLength()+1);// '+1' damit die Null am Ende mit kopiert wird
	#endif
d293 2
a294 1
void CIni::SerGetString(	BOOL bGet,CString &	str,const CString& strEntry,LPCTSTR strSection,LPCTSTR strDefault)
d296 2
a297 2
	if(bGet)
		str = GetString(strEntry,strDefault/*=NULL*/,strSection/* = NULL*/);
d299 1
a299 1
		WriteString(strEntry,str, strSection/* = NULL*/);
d301 2
a302 1
void CIni::SerGetDouble(	BOOL bGet,double&	f,	const CString& strEntry,LPCTSTR strSection/* = NULL*/,double fDefault/* = 0.0*/)
d304 5
a308 2
	if(bGet)
		f = GetDouble(strEntry,fDefault/*=NULL*/,strSection/* = NULL*/);
d310 1
a310 1
		WriteDouble(strEntry,f, strSection/* = NULL*/);
d312 2
a313 1
void CIni::SerGetFloat(		BOOL bGet,float	&	f,	const CString& strEntry, LPCTSTR strSection/* = NULL*/,float fDefault/* = 0.0*/)
d315 5
a319 2
	if(bGet)
		f = GetFloat(strEntry,fDefault/*=NULL*/,strSection/* = NULL*/);
d321 1
a321 1
		WriteFloat(strEntry,f, strSection/* = NULL*/);
d323 2
a324 1
void CIni::SerGetInt(		BOOL bGet,int	&	n,	const CString& strEntry,LPCTSTR strSection/* = NULL*/,int nDefault/* = 0*/)
d326 5
a330 2
	if(bGet)
		n = GetInt(strEntry,nDefault/*=NULL*/,strSection/* = NULL*/);
d332 1
a332 1
		WriteInt(strEntry,n, strSection/* = NULL*/);
d334 2
a335 1
void CIni::SerGetDWORD(		BOOL bGet,DWORD	&	n,	const CString& strEntry,LPCTSTR strSection/* = NULL*/,DWORD nDefault/* = 0*/)
d337 5
a341 2
	if(bGet)
		n = (DWORD)GetInt(strEntry,nDefault/*=NULL*/,strSection/* = NULL*/);
d343 1
a343 1
		WriteInt(strEntry,n, strSection/* = NULL*/);
d345 2
a346 1
void CIni::SerGetBool(		BOOL bGet,BOOL	&	b,	const CString& strEntry,LPCTSTR strSection/* = NULL*/,BOOL bDefault/* = FALSE*/)
d348 5
a352 2
	if(bGet)
		b = GetBool(strEntry,bDefault/*=NULL*/,strSection/* = NULL*/);
d354 1
a354 1
		WriteBool(strEntry,b, strSection/* = NULL*/);
d357 1
a357 1
void CIni::SerGetPoint(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCTSTR strSection,	CPoint ptDefault)
d359 4
a362 2
	if(bGet)
		pt = GetPoint(strEntry,ptDefault,strSection);
d364 6
a369 1
		WritePoint(strEntry,pt, strSection);
d371 2
a372 1
void CIni::SerGetRect(		BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCTSTR strSection,	CRect rectDefault)
d374 4
a377 2
	if(bGet)
		rect = GetRect(strEntry,rectDefault,strSection);
d379 6
a384 1
		WriteRect(strEntry,rect, strSection);
d386 2
a387 1
void CIni::SerGetColRef(	BOOL bGet,COLORREF	& cr,	const CString& strEntry,	LPCTSTR strSection,	COLORREF crDefault)
d389 4
a392 2
	if(bGet)
		cr = GetColRef(strEntry,crDefault,strSection);
d394 6
a399 1
		WriteColRef(strEntry,cr, strSection);
d401 2
a402 3
// berladene Methoden //////////////////////////////////////////////////////////////////////////////////////////////////77
// Einfache Typen /////////////////////////////////////////////////////////////////////////////////////////////////////////
void		CIni::SerGet(	BOOL bGet,CString	& str,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	LPCTSTR strDefault/*= NULL*/)
d404 11
a414 1
   SerGetString(bGet,str,strEntry,strSection,strDefault);
d416 2
a417 1
void		CIni::SerGet(	BOOL bGet,double	& f,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	double fDefault/* = 0.0*/)
d419 11
a429 1
   SerGetDouble(bGet,f,strEntry,strSection,fDefault);
d431 2
a432 1
void		CIni::SerGet(	BOOL bGet,float		& f,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	float fDefault/* = 0.0*/)
d434 19
a452 1
   SerGetFloat(bGet,f,strEntry,strSection,fDefault);
d454 2
a455 1
void		CIni::SerGet(	BOOL bGet,int		& n,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	int nDefault/* = 0*/)
d457 14
a470 1
   SerGetInt(bGet,n,strEntry,strSection,nDefault);
d472 2
a473 1
void		CIni::SerGet(	BOOL bGet,short		& n,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	int nDefault/* = 0*/)
d475 16
a490 3
   int nTemp = n;
   SerGetInt(bGet,nTemp,strEntry,strSection,nDefault);
   n = nTemp;
d492 2
a493 1
void		CIni::SerGet(	BOOL bGet,DWORD		& n,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	DWORD nDefault/* = 0*/)
d495 16
a510 1
   SerGetDWORD(bGet,n,strEntry,strSection,nDefault);
d512 2
a513 1
void		CIni::SerGet(	BOOL bGet,WORD		& n,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	DWORD nDefault/* = 0*/)
d515 16
a530 8
   DWORD dwTemp = n;
   SerGetDWORD(bGet,dwTemp,strEntry,strSection,nDefault);
   n = dwTemp;
}
//	void		SerGet(	BOOL bGet,BOOL		& b,	CString strEntry,	LPCTSTR strSection = NULL,	BOOL bDefault = FALSE);
void		CIni::SerGet(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	CPoint ptDefault/* = CPoint(0,0)*/)
{
   SerGetPoint(bGet,pt,strEntry,strSection,ptDefault);
a531 5
void		CIni::SerGet(	BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCTSTR strSection/*= NULL*/,	CRect rectDefault/* = CRect(0,0,0,0)*/)
{
   SerGetRect(bGet,rect,strEntry,strSection,rectDefault);
}
//	void		SerGet(	BOOL bGet,COLORREF	& cr,	CString strEntry,	LPCTSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));
d533 1
a533 4
// berladene Methoden ////////////////////////////////////////////////////////////////////////////////////////////
// ARRAYS /////////////////////////////////////////////////////////////////////////////////////////////////////////
// Entries werden durch Unterstrich + Index ergenzt////////////////////////////////////////////////////////////////
void CIni::SerGet(BOOL bGet, CString *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, LPCTSTR Default/*=NULL*/)
d535 2
a536 10
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, ar[i]);
				if(ar[i].GetLength() == 0)
					ar[i] = Default;
			}
d538 5
a542 8
		} else {
			strBuffer = ar[0];
			for(int i = 1; i < nCount; i++) {
				strBuffer.AppendChar(',');
				strBuffer.Append(ar[i]);
			}
			WriteString(strEntry, strBuffer, strSection);
		}
d544 7
d553 1
a553 1
void CIni::SerGet(BOOL bGet, double *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, double Default/* = 0.0*/)
d555 2
a556 13
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = _tstof(strTemp);
			}
d558 5
a562 10
		} else {
			CString strTemp;
			strBuffer.Format(_T("%g"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%g"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
		}
d564 7
d572 2
a573 1
void CIni::SerGet(BOOL bGet, float *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, float Default/* = 0.0*/)
d575 19
a593 13
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = (float)_tstof(strTemp);
			}
d595 3
a597 9
		} else {
			CString strTemp;
			strBuffer.Format(_T("%g"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%g"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
d599 17
d617 44
a660 15
}
void CIni::SerGet(BOOL bGet, int *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, int Default/* = 0*/)
{
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = _tstoi(strTemp);
d663 1
a663 9
		} else {
			CString strTemp;
			strBuffer.Format(_T("%d"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%d"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
d667 2
a668 1
void CIni::SerGet(BOOL bGet, unsigned char *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, unsigned char Default/* = 0*/)
d670 37
a706 13
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = (unsigned char)_tstoi(strTemp);
			}
d708 1
a708 10
		} else {
			CString strTemp;
			strBuffer.Format(_T("%d"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%d"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
		}
d710 2
d713 2
a714 1
void CIni::SerGet(BOOL bGet, short *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, int Default/* = 0*/)
d716 18
a733 13
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = (short)_tstoi(strTemp);
			}
d735 2
a736 10
		} else {
			CString strTemp;
			strBuffer.Format(_T("%d"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%d"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
		}
d738 2
d741 2
a742 1
void CIni::SerGet(BOOL bGet, DWORD *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, DWORD Default/* = 0*/)
d744 25
a768 13
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = (DWORD)_tstoi(strTemp);
			}
d770 1
a770 10
		} else {
			CString strTemp;
			strBuffer.Format(_T("%d"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%d"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
		}
d772 25
d798 2
a799 1
void CIni::SerGet(BOOL bGet, WORD *ar, int nCount, const CString& strEntry, LPCTSTR strSection/*=NULL*/, DWORD Default/* = 0*/)
d801 25
a825 13
	if(nCount > 0) {
		CString strBuffer;
		if(bGet) {
			strBuffer = GetString(strEntry, _T(""), strSection);
			CString strTemp;
			int nOffset = 0;
			for(int i = 0; i < nCount; i++) {
				nOffset = Parse(strBuffer, nOffset, strTemp);
				if(strTemp.GetLength() == 0)
					ar[i] = Default;
				else
					ar[i] = (WORD)_tstoi(strTemp);
			}
d827 1
a827 10
		} else {
			CString strTemp;
			strBuffer.Format(_T("%d"), ar[0]);
			for(int i = 1; i < nCount; i++) {
				strTemp.Format(_T("%d"), ar[i]);
				strBuffer.AppendChar(',');
				strBuffer.Append(strTemp);
			}
			WriteString(strEntry, strBuffer, strSection);
		}
a828 21
}
void		CIni::SerGet(	BOOL bGet,CPoint	* ar,	   int nCount, const CString& strEntry,	LPCTSTR strSection/*=NULL*/,	CPoint Default/* = CPoint(0,0)*/)
{
   CString strBuffer;
   for( int i=0 ; i<nCount ; i++)
   {
      strBuffer.Format(_T("_%i"),i);
      strBuffer = strEntry + strBuffer;
      SerGet(bGet,ar[i],strBuffer,strSection,Default);
   }
}
void		CIni::SerGet(	BOOL bGet,CRect	* ar,	   int nCount, const CString& strEntry,	LPCTSTR strSection/*=NULL*/,	CRect Default/* = CRect(0,0,0,0)*/)
{
   CString strBuffer;
   for( int i=0 ; i<nCount ; i++)
   {
      strBuffer.Format(_T("_%i"),i);
      strBuffer = strEntry + strBuffer;
      SerGet(bGet,ar[i],strBuffer,strSection,Default);
   }
}
d830 1
a830 1
int			CIni::Parse(const CString &strIn, int nOffset, CString &strOut) {
d832 5
a836 2
	strOut.Empty();
	int nLength = strIn.GetLength();
d838 3
a840 3
	if(nOffset < nLength) {
		if(nOffset != 0 && strIn[nOffset] == ',')
			nOffset++;
d842 1
a842 3
		while(nOffset < nLength) {
			if(!isspace(strIn[nOffset]))
				break;
d844 8
a851 2
			nOffset++;
		}
d853 1
a853 2
		while(nOffset < nLength) {
			strOut += strIn[nOffset];
d855 2
a856 3
			if(strIn[++nOffset] == ',')
				break;
		}
d858 2
a859 4
		strOut.Trim();
	}
	return nOffset;
}
d861 2
a862 22
//////////////////////////////////////////////////////////////////////
// statische Methoden
//////////////////////////////////////////////////////////////////////
CString CIni::Read(const CString& strFileName, const CString& strSection, const CString& strEntry, const CString& strDefault)
{
	CString strReturn;
	GetPrivateProfileString(strSection,
							strEntry,
							strDefault,
							strReturn.GetBufferSetLength(MAX_INI_BUFFER),
							MAX_INI_BUFFER,
							strFileName);
	strReturn.ReleaseBuffer();
	return strReturn;
}
void CIni::Write(const CString& strFileName, const CString& strSection, const CString& strEntry, const CString& strValue)
{
	WritePrivateProfileString(strSection,
							strEntry,
							strValue,
							strFileName);
}
@


1.5
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d176 1
a176 1
		return CString(GetLPCSTR(strEntry,strSection,_T("")));
d178 1
a178 1
		return CString(GetLPCSTR(strEntry,strSection,strDefault));
d184 2
a185 2
	GetLPCSTR(strEntry,strSection,strDefault);
	return atof(m_chBuffer);
d191 2
a192 2
	GetLPCSTR(strEntry,strSection,strDefault);
	return (float)atof(m_chBuffer);
d198 2
a199 2
	GetLPCSTR(strEntry,strSection,strDefault);
	return atoi(m_chBuffer);
d205 2
a206 2
	GetLPCSTR(strEntry,strSection,strDefault);
	return (WORD)atoi(m_chBuffer);
d212 2
a213 2
	GetLPCSTR(strEntry,strSection,strDefault);
	return ( atoi(m_chBuffer) != 0 );
d329 1
a329 1
char* CIni::GetLPCSTR(const CString& strEntry, LPCTSTR strSection, LPCTSTR strDefault)
@


1.4
log
@unicode cleanup
@
text
@d7 1
d341 1
d343 3
@


1.3
log
@Various fixes (see changelog+)
@
text
@d19 4
a22 4
   char drive[_MAX_DRIVE];
   char dir[_MAX_DIR];
   char fname[_MAX_FNAME];
   char ext[_MAX_EXT];
d24 1
a24 1
   _splitpath( strFileName, drive, dir, fname, ext );
d44 1
a44 1
      _splitpath( strModule, drive, dir, fname, ext );
d57 4
a60 4
   char drive[_MAX_DRIVE];
   char dir[_MAX_DIR];
   char fname[_MAX_FNAME];
   char ext[_MAX_EXT];
d65 1
a65 1
   _splitpath( strTemp, drive, dir, fname, ext );
d165 1
a165 1
void CIni::Init( LPCSTR strFileName, LPCSTR strSection/* = NULL*/)
d172 1
a172 1
CString CIni::GetString(const CString& strEntry,LPCSTR strDefault/*=NULL*/,LPCSTR strSection/* = NULL*/)
d175 1
a175 1
		return CString(GetLPCSTR(strEntry,strSection,""));
d179 1
a179 1
double CIni::GetDouble(const CString& strEntry,double fDefault/* = 0.0*/,LPCSTR strSection/* = NULL*/)
d182 1
a182 1
	strDefault.Format("%g",fDefault);
d186 1
a186 1
float CIni::GetFloat(const CString& strEntry,float fDefault/* = 0.0*/, LPCSTR strSection/* = NULL*/)
d189 1
a189 1
	strDefault.Format("%g",fDefault);
d193 1
a193 1
int CIni::GetInt(const CString& strEntry,int nDefault/* = 0*/,LPCSTR strSection/* = NULL*/)
d196 1
a196 1
	strDefault.Format("%d",nDefault);
d200 1
a200 1
WORD CIni::GetWORD(const CString& strEntry,WORD nDefault/* = 0*/,LPCSTR strSection/* = NULL*/)
d203 1
a203 1
	strDefault.Format("%u",nDefault);
d207 1
a207 1
BOOL CIni::GetBool(const CString& strEntry,BOOL bDefault/* = FALSE*/,LPCSTR strSection/* = NULL*/)
d210 1
a210 1
	strDefault.Format("%d",bDefault);
d214 1
a214 1
CPoint CIni::GetPoint(const CString& strEntry,	CPoint ptDefault, LPCSTR strSection)
d219 1
a219 1
	strDefault.Format("(%d,%d)",ptDefault.x, ptDefault.y);
d222 1
a222 1
	sscanf(strPoint,"(%d,%d)", &ptReturn.x, &ptReturn.y);
d226 1
a226 1
CRect CIni::GetRect(const CString& strEntry, CRect rectDefault, LPCSTR strSection)
d231 2
a232 2
	//old version :strDefault.Format("(%d,%d,%d,%d)",rectDefault.top,rectDefault.left,rectDefault.bottom,rectDefault.right);
	strDefault.Format("%d,%d,%d,%d",rectDefault.left,rectDefault.top,rectDefault.right,rectDefault.bottom);
d237 1
a237 1
   if( 4==sscanf(strRect,"%d,%d,%d,%d",&rectDefault.left,&rectDefault.top,&rectDefault.right,&rectDefault.bottom))
d240 1
a240 1
   sscanf(strRect,"(%d,%d,%d,%d)", &rectReturn.top,&rectReturn.left,&rectReturn.bottom,&rectReturn.right);
d243 1
a243 1
COLORREF CIni::GetColRef(const CString& strEntry, COLORREF crDefault, LPCSTR strSection)
d250 1
a250 1
	strDefault.Format("RGB(%hd,%hd,%hd)",temp[0],temp[1],temp[2]);
d253 1
a253 1
	sscanf(strColRef,"RGB(%d,%d,%d)", temp, temp+1, temp+2);
d258 1
a258 1
void CIni::WriteString(const CString& strEntry,const CString& str, LPCSTR strSection/* = NULL*/)
d264 1
a264 1
void CIni::WriteDouble(const CString& strEntry,double f, LPCSTR strSection/*= NULL*/)
d269 1
a269 1
	strBuffer.Format("%g",f);
d272 1
a272 1
void CIni::WriteFloat(const CString& strEntry,float f, LPCSTR strSection/* = NULL*/)
d277 1
a277 1
	strBuffer.Format("%g",f);
d280 1
a280 1
void CIni::WriteInt(const CString& strEntry,int n, LPCSTR strSection/* = NULL*/)
d285 1
a285 1
	strBuffer.Format("%d",n);
d288 1
a288 1
void CIni::WriteWORD(const CString& strEntry,WORD n, LPCSTR strSection/* = NULL*/)
d293 1
a293 1
	strBuffer.Format("%u",n);
d296 1
a296 1
void CIni::WriteBool(const CString& strEntry,BOOL b, LPCSTR strSection/* = NULL*/)
d301 1
a301 1
	strBuffer.Format("%d",b);
d304 1
a304 1
void CIni::WritePoint(const CString& strEntry,const CPoint& pt, LPCSTR strSection)
d309 1
a309 1
	strBuffer.Format("(%d,%d)",pt.x,pt.y);
d312 1
a312 1
void CIni::WriteRect(const CString& strEntry,const CRect& rect, LPCSTR strSection)
d317 1
a317 1
	strBuffer.Format("(%d,%d,%d,%d)",rect.top,rect.left,rect.bottom,rect.right);
d320 1
a320 1
void CIni::WriteColRef(const CString& strEntry,COLORREF cr, LPCSTR strSection)
d325 1
a325 1
	strBuffer.Format("RGB(%d,%d,%d)",GetRValue(cr), GetGValue(cr), GetBValue(cr));
d328 1
a328 1
char* CIni::GetLPCSTR(const CString& strEntry, LPCSTR strSection, LPCSTR strDefault)
d342 1
a342 1
void CIni::SerGetString(	BOOL bGet,CString &	str,const CString& strEntry,LPCSTR strSection,LPCSTR strDefault)
d349 1
a349 1
void CIni::SerGetDouble(	BOOL bGet,double&	f,	const CString& strEntry,LPCSTR strSection/* = NULL*/,double fDefault/* = 0.0*/)
d356 1
a356 1
void CIni::SerGetFloat(		BOOL bGet,float	&	f,	const CString& strEntry, LPCSTR strSection/* = NULL*/,float fDefault/* = 0.0*/)
d363 1
a363 1
void CIni::SerGetInt(		BOOL bGet,int	&	n,	const CString& strEntry,LPCSTR strSection/* = NULL*/,int nDefault/* = 0*/)
d370 1
a370 1
void CIni::SerGetDWORD(		BOOL bGet,DWORD	&	n,	const CString& strEntry,LPCSTR strSection/* = NULL*/,DWORD nDefault/* = 0*/)
d377 1
a377 1
void CIni::SerGetBool(		BOOL bGet,BOOL	&	b,	const CString& strEntry,LPCSTR strSection/* = NULL*/,BOOL bDefault/* = FALSE*/)
d385 1
a385 1
void CIni::SerGetPoint(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCSTR strSection,	CPoint ptDefault)
d392 1
a392 1
void CIni::SerGetRect(		BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCSTR strSection,	CRect rectDefault)
d399 1
a399 1
void CIni::SerGetColRef(	BOOL bGet,COLORREF	& cr,	const CString& strEntry,	LPCSTR strSection,	COLORREF crDefault)
d408 1
a408 1
void		CIni::SerGet(	BOOL bGet,CString	& str,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	LPCSTR strDefault/*= NULL*/)
d412 1
a412 1
void		CIni::SerGet(	BOOL bGet,double	& f,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	double fDefault/* = 0.0*/)
d416 1
a416 1
void		CIni::SerGet(	BOOL bGet,float		& f,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	float fDefault/* = 0.0*/)
d420 1
a420 1
void		CIni::SerGet(	BOOL bGet,int		& n,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	int nDefault/* = 0*/)
d424 1
a424 1
void		CIni::SerGet(	BOOL bGet,short		& n,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	int nDefault/* = 0*/)
d430 1
a430 1
void		CIni::SerGet(	BOOL bGet,DWORD		& n,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	DWORD nDefault/* = 0*/)
d434 1
a434 1
void		CIni::SerGet(	BOOL bGet,WORD		& n,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	DWORD nDefault/* = 0*/)
d440 2
a441 2
//	void		SerGet(	BOOL bGet,BOOL		& b,	CString strEntry,	LPCSTR strSection = NULL,	BOOL bDefault = FALSE);
void		CIni::SerGet(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	CPoint ptDefault/* = CPoint(0,0)*/)
d445 1
a445 1
void		CIni::SerGet(	BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCSTR strSection/*= NULL*/,	CRect rectDefault/* = CRect(0,0,0,0)*/)
d449 1
a449 1
//	void		SerGet(	BOOL bGet,COLORREF	& cr,	CString strEntry,	LPCSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));
d454 1
a454 1
void CIni::SerGet(BOOL bGet, CString *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, LPCSTR Default/*=NULL*/)
d459 1
a459 1
			strBuffer = GetString(strEntry, "", strSection);
d478 1
a478 1
void CIni::SerGet(BOOL bGet, double *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, double Default/* = 0.0*/)
d483 1
a483 1
			strBuffer = GetString(strEntry, "", strSection);
d491 1
a491 1
					ar[i] = atof(strTemp);
d496 1
a496 1
			strBuffer.Format("%g", ar[0]);
d498 1
a498 1
				strTemp.Format("%g", ar[i]);
d506 1
a506 1
void CIni::SerGet(BOOL bGet, float *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, float Default/* = 0.0*/)
d511 1
a511 1
			strBuffer = GetString(strEntry, "", strSection);
d519 1
a519 1
					ar[i] = (float)atof(strTemp);
d524 1
a524 1
			strBuffer.Format("%g", ar[0]);
d526 1
a526 1
				strTemp.Format("%g", ar[i]);
d534 1
a534 1
void CIni::SerGet(BOOL bGet, int *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, int Default/* = 0*/)
d539 1
a539 1
			strBuffer = GetString(strEntry, "", strSection);
d547 1
a547 1
					ar[i] = atoi(strTemp);
d552 1
a552 1
			strBuffer.Format("%d", ar[0]);
d554 1
a554 1
				strTemp.Format("%d", ar[i]);
d562 1
a562 1
void CIni::SerGet(BOOL bGet, unsigned char *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, unsigned char Default/* = 0*/)
d567 1
a567 1
			strBuffer = GetString(strEntry, "", strSection);
d575 1
a575 1
					ar[i] = (unsigned char)atoi(strTemp);
d580 1
a580 1
			strBuffer.Format("%d", ar[0]);
d582 1
a582 1
				strTemp.Format("%d", ar[i]);
d590 1
a590 1
void CIni::SerGet(BOOL bGet, short *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, int Default/* = 0*/)
d595 1
a595 1
			strBuffer = GetString(strEntry, "", strSection);
d603 1
a603 1
					ar[i] = (short)atoi(strTemp);
d608 1
a608 1
			strBuffer.Format("%d", ar[0]);
d610 1
a610 1
				strTemp.Format("%d", ar[i]);
d618 1
a618 1
void CIni::SerGet(BOOL bGet, DWORD *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, DWORD Default/* = 0*/)
d623 1
a623 1
			strBuffer = GetString(strEntry, "", strSection);
d631 1
a631 1
					ar[i] = (DWORD)atoi(strTemp);
d636 1
a636 1
			strBuffer.Format("%d", ar[0]);
d638 1
a638 1
				strTemp.Format("%d", ar[i]);
d646 1
a646 1
void CIni::SerGet(BOOL bGet, WORD *ar, int nCount, const CString& strEntry, LPCSTR strSection/*=NULL*/, DWORD Default/* = 0*/)
d651 1
a651 1
			strBuffer = GetString(strEntry, "", strSection);
d659 1
a659 1
					ar[i] = (WORD)atoi(strTemp);
d664 1
a664 1
			strBuffer.Format("%d", ar[0]);
d666 1
a666 1
				strTemp.Format("%d", ar[i]);
d674 1
a674 1
void		CIni::SerGet(	BOOL bGet,CPoint	* ar,	   int nCount, const CString& strEntry,	LPCSTR strSection/*=NULL*/,	CPoint Default/* = CPoint(0,0)*/)
d679 1
a679 1
      strBuffer.Format("_%i",i);
d684 1
a684 1
void		CIni::SerGet(	BOOL bGet,CRect	* ar,	   int nCount, const CString& strEntry,	LPCSTR strSection/*=NULL*/,	CRect Default/* = CRect(0,0,0,0)*/)
d689 1
a689 1
      strBuffer.Format("_%i",i);
@


1.2
log
@small code optimizations in parameters passing
@
text
@d235 1
a235 1
	int nRead = 0;
@


1.1
log
@*** empty log message ***
@
text
@d95 2
a96 4
CIni::CIni(CIni const& Ini, BOOL bModulPath /*= TRUE*/):
	m_strFileName(Ini.m_strFileName),
	m_strSection(Ini.m_strSection),
   m_bModulPath(Ini.m_bModulPath)
d98 1
a98 1
   if(m_strFileName.IsEmpty())
d100 3
d104 2
a105 1
   if(m_strSection.IsEmpty())
d107 2
d110 1
a110 2
CIni::CIni(CString const& strFileName, BOOL bModulPath /*= TRUE*/):
	m_strFileName(strFileName),
d113 1
a113 1
   if(m_strFileName.IsEmpty())
d115 2
d120 1
a120 3
CIni::CIni(CString const& strFileName, CString const& strSection, BOOL bModulPath /*= TRUE*/):
	m_strFileName(strFileName),
	m_strSection(strSection),
d123 1
a123 1
   if(m_strFileName.IsEmpty())
d125 3
d129 2
a130 1
   if(m_strSection.IsEmpty())
d132 3
a134 1
}
d142 1
a142 1
void CIni::SetFileName(CString const& strFileName)
d147 1
a147 1
void CIni::SetSection(CString const& strSection)
d152 1
a152 1
CString const& CIni::GetFileName() const
d156 1
a156 1
CString const& CIni::GetSection() const
d172 1
a172 1
CString CIni::GetString(CString strEntry,LPCSTR strDefault/*=NULL*/,LPCSTR strSection/* = NULL*/)
d179 1
a179 1
double CIni::GetDouble(CString strEntry,double fDefault/* = 0.0*/,LPCSTR strSection/* = NULL*/)
d186 1
a186 1
float CIni::GetFloat(CString strEntry,float fDefault/* = 0.0*/, LPCSTR strSection/* = NULL*/)
d193 1
a193 1
int CIni::GetInt(CString strEntry,int nDefault/* = 0*/,LPCSTR strSection/* = NULL*/)
d200 1
a200 1
WORD CIni::GetWORD(CString strEntry,WORD nDefault/* = 0*/,LPCSTR strSection/* = NULL*/)
d207 1
a207 1
BOOL CIni::GetBool(CString strEntry,BOOL bDefault/* = FALSE*/,LPCSTR strSection/* = NULL*/)
d214 1
a214 1
CPoint CIni::GetPoint(CString strEntry,	CPoint ptDefault, LPCSTR strSection)
d226 1
a226 1
CRect CIni::GetRect(CString strEntry, CRect rectDefault, LPCSTR strSection)
d243 1
a243 1
COLORREF CIni::GetColRef(CString strEntry, COLORREF crDefault, LPCSTR strSection)
d258 1
a258 1
void CIni::WriteString(CString strEntry,CString	str, LPCSTR strSection/* = NULL*/)
d264 1
a264 1
void CIni::WriteDouble(CString strEntry,double f, LPCSTR strSection/*= NULL*/)
d272 1
a272 1
void CIni::WriteFloat(CString strEntry,float f, LPCSTR strSection/* = NULL*/)
d280 1
a280 1
void CIni::WriteInt(CString strEntry,int n, LPCSTR strSection/* = NULL*/)
d288 1
a288 1
void CIni::WriteWORD(CString strEntry,WORD n, LPCSTR strSection/* = NULL*/)
d296 1
a296 1
void CIni::WriteBool(CString strEntry,BOOL b, LPCSTR strSection/* = NULL*/)
d304 1
a304 1
void CIni::WritePoint(CString strEntry,CPoint pt, LPCSTR strSection)
d312 1
a312 1
void CIni::WriteRect(CString strEntry,CRect rect, LPCSTR strSection)
d320 1
a320 1
void CIni::WriteColRef(CString strEntry,COLORREF cr, LPCSTR strSection)
d328 1
a328 1
char* CIni::GetLPCSTR(CString strEntry, LPCSTR strSection, LPCSTR strDefault)
d342 1
a342 1
void CIni::SerGetString(	BOOL bGet,CString &	str,CString strEntry,LPCSTR strSection,LPCSTR strDefault)
d349 1
a349 1
void CIni::SerGetDouble(	BOOL bGet,double&	f,	CString strEntry,LPCSTR strSection/* = NULL*/,double fDefault/* = 0.0*/)
d356 1
a356 1
void CIni::SerGetFloat(		BOOL bGet,float	&	f,	CString strEntry, LPCSTR strSection/* = NULL*/,float fDefault/* = 0.0*/)
d363 1
a363 1
void CIni::SerGetInt(		BOOL bGet,int	&	n,	CString strEntry,LPCSTR strSection/* = NULL*/,int nDefault/* = 0*/)
d370 1
a370 1
void CIni::SerGetDWORD(		BOOL bGet,DWORD	&	n,	CString strEntry,LPCSTR strSection/* = NULL*/,DWORD nDefault/* = 0*/)
d377 1
a377 1
void CIni::SerGetBool(		BOOL bGet,BOOL	&	b,	CString strEntry,LPCSTR strSection/* = NULL*/,BOOL bDefault/* = FALSE*/)
d385 1
a385 1
void CIni::SerGetPoint(	BOOL bGet,CPoint	& pt,	CString strEntry,	LPCSTR strSection,	CPoint ptDefault)
d392 1
a392 1
void CIni::SerGetRect(		BOOL bGet,CRect		& rect,	CString strEntry,	LPCSTR strSection,	CRect rectDefault)
d399 1
a399 1
void CIni::SerGetColRef(	BOOL bGet,COLORREF	& cr,	CString strEntry,	LPCSTR strSection,	COLORREF crDefault)
d408 1
a408 1
void		CIni::SerGet(	BOOL bGet,CString	& str,	CString strEntry,	LPCSTR strSection/*= NULL*/,	LPCSTR strDefault/*= NULL*/)
d412 1
a412 1
void		CIni::SerGet(	BOOL bGet,double	& f,	CString strEntry,	LPCSTR strSection/*= NULL*/,	double fDefault/* = 0.0*/)
d416 1
a416 1
void		CIni::SerGet(	BOOL bGet,float		& f,	CString strEntry,	LPCSTR strSection/*= NULL*/,	float fDefault/* = 0.0*/)
d420 1
a420 1
void		CIni::SerGet(	BOOL bGet,int		& n,	CString strEntry,	LPCSTR strSection/*= NULL*/,	int nDefault/* = 0*/)
d424 1
a424 1
void		CIni::SerGet(	BOOL bGet,short		& n,	CString strEntry,	LPCSTR strSection/*= NULL*/,	int nDefault/* = 0*/)
d430 1
a430 1
void		CIni::SerGet(	BOOL bGet,DWORD		& n,	CString strEntry,	LPCSTR strSection/*= NULL*/,	DWORD nDefault/* = 0*/)
d434 1
a434 1
void		CIni::SerGet(	BOOL bGet,WORD		& n,	CString strEntry,	LPCSTR strSection/*= NULL*/,	DWORD nDefault/* = 0*/)
d441 1
a441 1
void		CIni::SerGet(	BOOL bGet,CPoint	& pt,	CString strEntry,	LPCSTR strSection/*= NULL*/,	CPoint ptDefault/* = CPoint(0,0)*/)
d445 1
a445 1
void		CIni::SerGet(	BOOL bGet,CRect		& rect,	CString strEntry,	LPCSTR strSection/*= NULL*/,	CRect rectDefault/* = CRect(0,0,0,0)*/)
d454 1
a454 1
void CIni::SerGet(BOOL bGet, CString *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, LPCSTR Default/*=NULL*/)
d478 1
a478 1
void CIni::SerGet(BOOL bGet, double *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, double Default/* = 0.0*/)
d506 1
a506 1
void CIni::SerGet(BOOL bGet, float *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, float Default/* = 0.0*/)
d534 1
a534 1
void CIni::SerGet(BOOL bGet, int *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, int Default/* = 0*/)
d562 1
a562 1
void CIni::SerGet(BOOL bGet, unsigned char *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, unsigned char Default/* = 0*/)
d590 1
a590 1
void CIni::SerGet(BOOL bGet, short *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, int Default/* = 0*/)
d618 1
a618 1
void CIni::SerGet(BOOL bGet, DWORD *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, DWORD Default/* = 0*/)
d646 1
a646 1
void CIni::SerGet(BOOL bGet, WORD *ar, int nCount, CString strEntry, LPCSTR strSection/*=NULL*/, DWORD Default/* = 0*/)
d674 1
a674 1
void		CIni::SerGet(	BOOL bGet,CPoint	* ar,	   int nCount, CString strEntry,	LPCSTR strSection/*=NULL*/,	CPoint Default/* = CPoint(0,0)*/)
d684 1
a684 1
void		CIni::SerGet(	BOOL bGet,CRect	* ar,	   int nCount, CString strEntry,	LPCSTR strSection/*=NULL*/,	CRect Default/* = CRect(0,0,0,0)*/)
d695 1
a695 1
int			CIni::Parse(CString &strIn, int nOffset, CString &strOut) {
d726 1
a726 1
CString CIni::Read(CString const& strFileName, CString const& strSection, CString const& strEntry, CString const& strDefault)
d738 1
a738 1
void CIni::Write(CString const& strFileName, CString const& strSection, CString const& strEntry, CString const& strValue)
@


1.1.4.1
log
@updating this branch...
@
text
@@

