head	1.568;
access;
symbols
	PublicRelease_1_2e:1.567
	Interim_Release_1-2e_RC1:1.567
	PublicRelease_1_2d:1.562
	Interim_Release_1-2d_RC1:1.562
	Interim_Release_1-2d_beta1:1.555
	PublicRelease_1_2c:1.547
	Interim_Release_1-2c_RC1:1.547
	Interim_Release_1-2c_beta1:1.543
	PublicRelease_1_2b:1.540
	Interim_Release_1-2b_RC1:1.540
	PublicRelease_1_2a:1.540
	Interim_Release_1-2a_RC1:1.540
	Interim_Release_1-2a_beta2:1.532
	Interim_Release_1-2a_beta1:1.528
	PublicRelease_1_2:1.524
	Interim_Release_1-2_RC1:1.524
	Interim_Release_1-2_beta1:1.522
	PublicRelease_1_1g:1.519
	Interim_Release_1-1g_RC3:1.519
	Interim_Release_1-1g_RC2:1.519
	Interim_Release_1-1g_RC1:1.519
	Interim_Release_1-1g_beta2:1.517
	Interim_Release_1-1g_beta1:1.507
	PublicRelease_1_1f:1.500
	Interim_Release_1-1f_RC1:1.500
	PublicRelease_1_1e:1.500
	Interim_Release_1-1e_RC2:1.500
	Interim_Release_1-1e_RC1:1.499
	Interim_Release_1-1e_beta1:1.496
	PublicRelease_1_1d:1.491
	Interim_Release_1-1d_RC1:1.491
	PublicRelease_1_1c:1.490
	Interim_Release_1-1c_RC1:1.490
	Interim_Release_1-1c_beta2:1.488
	Interim_Release_1-1c_beta1:1.488
	PublicRelease_1_1b:1.482
	Interim_Release_1-1b_RC1:1.482
	PublicRelease_1_1a:1.481
	Interim_Release_1-1a_RC2:1.480
	Interim_Release_1-1a_RC1:1.480
	Interim_Release_1-1a_beta2:1.480
	Interim_Release_1-1a_beta1:1.479
	PublicRelease_1_1:1.474
	Interim_Release_1-1_beta1:1.473
	PublicRelease_1o:1.470
	Interim_Release_1o_RC1:1.470
	Interim_Release_1o_beta1:1.469
	PublicRelease_1n:1.467
	Interim_Release_1n_RC2:1.465
	Interim_Release_1n_RC1:1.465
	Interim_Release_1n_beta2:1.461
	Interim_Release_1n_beta1:1.454
	PublicRelease_1m:1.448
	Interim_Release_1m_beta1:1.445
	PublicRelease_1l:1.440
	Interim_Release_1l_RC3:1.439
	Interim_Release_1l_RC2:1.437
	Interim_Release_1l_RC1:1.434
	Interim_Release_1l_beta2:1.432
	Interim_Release_1l_beta1:1.422
	PublicRelease_1k:1.404
	Interim_Release_1k_RC4:1.404
	Interim_1k_RC3:1.404
	Interim_1k_RC2:1.403
	Interim_Release_1k_RC1:1.403
	Interim_Release_1k_beta5:1.402
	Intrerim_Release_1k_beta4:1.402
	Interim_Release_1k_beta1:1.393
	PublicRelease_1j:1.360
	Interim_Release_1J_RC3:1.359
	Interim_Release_1j_RC3:1.359
	Interim_Release_1j_RC2:1.350
	Interim_Release_1j_RC1:1.347
	Interim_Release_1j_beta2:1.347
	Interim_Release_1j_beta1:1.344
	PublicRelease_1i:1.341
	Interim_Release_1i_RC6:1.341
	Interim_Release_1i_RC3:1.332
	Interim_Release_1i_RC2:1.328
	Interim_Release_1i_RC1:1.317
	Interim_Release_1i_beta3:1.311
	Interim_Release_1i_beta2:1.300
	Interim_Release_1i_beta1:1.264
	PublicRelease_1h:1.225
	Interim_Release_1h_rc2:1.225
	Interim_Release_1h_RC1:1.221
	Interim_Release_1h_beta2:1.214
	Interim_Release_1h_beta1_now:1.190
	Interim_Release_1h_beta1:1.190
	PublicRelease_1g:1.174
	Interim_Release_1g_RC6_Final:1.174
	Interim_Release_1g_RC6:1.169
	Interim_Release_1g_RC5:1.168
	Interim_Release_1g_RC4:1.166
	Interim_Release_1g_RC3:1.163
	Interim_Release_1g_beta2:1.150
	Interim_Release_1g_beta1:1.146
	Interim_Release_1f_RC4:1.142
	Interim_Release_1f_RC3:1.139
	Interim_Release_1f_RC2:1.130
	Interim_Release_1f_RC:1.130
	Interim_Release_1f_beta2:1.129
	Interim_Release_1f_beta1:1.125
	PublicRelease_1e:1.123
	Interim_Release_1e_RC2:1.123
	Interim_Release_1e_RC:1.122
	Interim_Release_1e_beta3:1.119
	Interim_Release_1e_beta2:1.119
	Interim_Release_1e_beta2_before_kuchin:1.119
	Interim_Release_1e_beta1:1.119
	PublicRelease_1c:1.114
	featurestest:1.114.0.2
	Interim_Release_1c_RC:1.114
	Interim_Release_1c_beta2:1.112
	Interim_Release_1c_beta1:1.105
	threaded_downloadqueue:1.103.0.2
	PublicRelease_1b:1.94
	Interim_Release_1b_beta2:1.94
	Interim_Release_1b_beta1:1.86
	proxydeadlake:1.79.0.2
	PublicRelease_1a:1.77
	Interim_Release_1a_beta2:1.69
	BerkeleyDb:1.64.0.2
	Interim_Release_1a_beta1:1.60
	PublicRelease_1:1.49
	goldfish:1.49
	eMulePlus_1_RC2:1.47
	eMulePlus_26b_1RC1:1.43
	PreRelease_26b_i0e:1.42
	before_26d_merge:1.35
	Interim_Release_26b_i0d:1.28
	Interim_Release_26b_i0c:1.22
	Interim_Release_26b_i0b:1.21
	Interim_Release_26b_i0a:1.21
	systraydlg:1.14.0.4
	plus26based:1.14.0.2
	Interim_Release_25b_i0b:1.14
	Proxy_Dev:1.12
	Interim_Release_25b_i0a:1.9.2.3
	proxytest:1.9.2.1.0.2
	official_sockets:1.9.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.568
date	2009.05.14.03.10.30;	author aw3;	state Exp;
branches;
next	1.567;

1.567
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.566;

1.566
date	2008.11.07.05.26.17;	author aw3;	state Exp;
branches;
next	1.565;

1.565
date	2008.11.03.05.58.27;	author aw3;	state Exp;
branches;
next	1.564;

1.564
date	2008.09.02.02.57.14;	author aw3;	state Exp;
branches;
next	1.563;

1.563
date	2008.08.13.13.22.49;	author kush_eplus;	state Exp;
branches;
next	1.562;

1.562
date	2008.04.16.19.44.17;	author eklmn;	state Exp;
branches;
next	1.561;

1.561
date	2008.04.05.20.22.49;	author eklmn;	state Exp;
branches;
next	1.560;

1.560
date	2008.04.05.09.49.08;	author eklmn;	state Exp;
branches;
next	1.559;

1.559
date	2008.03.10.04.08.34;	author aw3;	state Exp;
branches;
next	1.558;

1.558
date	2008.03.04.19.46.18;	author kush_eplus;	state Exp;
branches;
next	1.557;

1.557
date	2008.03.03.21.29.21;	author kush_eplus;	state Exp;
branches;
next	1.556;

1.556
date	2008.02.25.04.30.11;	author aw3;	state Exp;
branches;
next	1.555;

1.555
date	2007.12.29.05.48.24;	author aw3;	state Exp;
branches;
next	1.554;

1.554
date	2007.12.19.21.04.46;	author aw3;	state Exp;
branches;
next	1.553;

1.553
date	2007.12.16.20.22.01;	author aw3;	state Exp;
branches;
next	1.552;

1.552
date	2007.12.02.17.54.59;	author aw3;	state Exp;
branches;
next	1.551;

1.551
date	2007.12.01.11.17.50;	author eklmn;	state Exp;
branches;
next	1.550;

1.550
date	2007.10.31.18.14.40;	author fuxie-dk;	state Exp;
branches;
next	1.549;

1.549
date	2007.10.24.19.09.35;	author fuxie-dk;	state Exp;
branches;
next	1.548;

1.548
date	2007.09.27.14.26.26;	author fuxie-dk;	state Exp;
branches;
next	1.547;

1.547
date	2007.07.08.22.31.18;	author kush_eplus;	state Exp;
branches;
next	1.546;

1.546
date	2007.07.08.00.11.57;	author aw3;	state Exp;
branches;
next	1.545;

1.545
date	2007.04.27.12.05.26;	author aw3;	state Exp;
branches;
next	1.544;

1.544
date	2007.03.19.19.14.59;	author kush_eplus;	state Exp;
branches;
next	1.543;

1.543
date	2007.02.15.20.13.59;	author eklmn;	state Exp;
branches;
next	1.542;

1.542
date	2007.02.14.02.12.48;	author aw3;	state Exp;
branches;
next	1.541;

1.541
date	2007.02.08.03.58.47;	author aw3;	state Exp;
branches;
next	1.540;

1.540
date	2006.09.18.13.24.28;	author aw3;	state Exp;
branches;
next	1.539;

1.539
date	2006.09.06.05.54.41;	author aw3;	state Exp;
branches;
next	1.538;

1.538
date	2006.07.19.04.33.20;	author aw3;	state Exp;
branches;
next	1.537;

1.537
date	2006.07.13.03.56.33;	author aw3;	state Exp;
branches;
next	1.536;

1.536
date	2006.07.12.17.40.41;	author kush_eplus;	state Exp;
branches;
next	1.535;

1.535
date	2006.07.04.04.42.57;	author aw3;	state Exp;
branches;
next	1.534;

1.534
date	2006.07.01.17.16.08;	author aw3;	state Exp;
branches;
next	1.533;

1.533
date	2006.06.24.02.40.21;	author aw3;	state Exp;
branches;
next	1.532;

1.532
date	2006.05.27.02.46.29;	author aw3;	state Exp;
branches;
next	1.531;

1.531
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.530;

1.530
date	2006.05.21.06.13.02;	author aw3;	state Exp;
branches;
next	1.529;

1.529
date	2006.05.13.04.40.28;	author aw3;	state Exp;
branches;
next	1.528;

1.528
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.527;

1.527
date	2006.04.09.01.31.16;	author aw3;	state Exp;
branches;
next	1.526;

1.526
date	2006.04.07.19.28.37;	author eklmn;	state Exp;
branches;
next	1.525;

1.525
date	2006.03.18.04.46.35;	author aw3;	state Exp;
branches;
next	1.524;

1.524
date	2006.02.14.04.31.05;	author aw3;	state Exp;
branches;
next	1.523;

1.523
date	2006.02.05.03.50.38;	author aw3;	state Exp;
branches;
next	1.522;

1.522
date	2006.01.25.05.23.50;	author aw3;	state Exp;
branches;
next	1.521;

1.521
date	2006.01.22.15.07.47;	author eklmn;	state Exp;
branches;
next	1.520;

1.520
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.519;

1.519
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.518;

1.518
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.517;

1.517
date	2005.11.25.05.11.43;	author aw3;	state Exp;
branches;
next	1.516;

1.516
date	2005.10.23.23.38.33;	author aw3;	state Exp;
branches;
next	1.515;

1.515
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.514;

1.514
date	2005.09.26.00.29.07;	author aw3;	state Exp;
branches;
next	1.513;

1.513
date	2005.09.18.19.56.03;	author aw3;	state Exp;
branches;
next	1.512;

1.512
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.511;

1.511
date	2005.09.13.05.54.39;	author aw3;	state Exp;
branches;
next	1.510;

1.510
date	2005.09.11.01.01.16;	author aw3;	state Exp;
branches;
next	1.509;

1.509
date	2005.08.26.03.57.35;	author aw3;	state Exp;
branches;
next	1.508;

1.508
date	2005.08.25.11.57.47;	author aw3;	state Exp;
branches;
next	1.507;

1.507
date	2005.08.21.03.05.13;	author aw3;	state Exp;
branches;
next	1.506;

1.506
date	2005.08.20.04.36.38;	author aw3;	state Exp;
branches;
next	1.505;

1.505
date	2005.08.17.18.49.43;	author eklmn;	state Exp;
branches;
next	1.504;

1.504
date	2005.08.14.19.02.19;	author aw3;	state Exp;
branches;
next	1.503;

1.503
date	2005.08.11.05.19.37;	author aw3;	state Exp;
branches;
next	1.502;

1.502
date	2005.08.11.03.50.42;	author aw3;	state Exp;
branches;
next	1.501;

1.501
date	2005.08.10.05.20.40;	author eklmn;	state Exp;
branches;
next	1.500;

1.500
date	2005.07.09.06.04.05;	author aw3;	state Exp;
branches;
next	1.499;

1.499
date	2005.06.19.05.09.32;	author aw3;	state Exp;
branches;
next	1.498;

1.498
date	2005.06.13.04.10.10;	author aw3;	state Exp;
branches;
next	1.497;

1.497
date	2005.06.11.14.38.36;	author aw3;	state Exp;
branches;
next	1.496;

1.496
date	2005.05.21.20.15.50;	author aw3;	state Exp;
branches;
next	1.495;

1.495
date	2005.05.10.04.01.32;	author aw3;	state Exp;
branches;
next	1.494;

1.494
date	2005.05.07.15.40.38;	author aw3;	state Exp;
branches;
next	1.493;

1.493
date	2005.04.14.03.17.55;	author aw3;	state Exp;
branches;
next	1.492;

1.492
date	2005.04.11.02.25.00;	author aw3;	state Exp;
branches;
next	1.491;

1.491
date	2005.03.06.17.38.13;	author aw3;	state Exp;
branches;
next	1.490;

1.490
date	2005.02.22.22.28.06;	author aw3;	state Exp;
branches;
next	1.489;

1.489
date	2005.02.18.19.16.56;	author aw3;	state Exp;
branches;
next	1.488;

1.488
date	2005.01.24.17.19.50;	author aw3;	state Exp;
branches;
next	1.487;

1.487
date	2005.01.21.09.32.26;	author kush_eplus;	state Exp;
branches;
next	1.486;

1.486
date	2005.01.19.21.10.45;	author netwolf1;	state Exp;
branches;
next	1.485;

1.485
date	2005.01.16.00.34.58;	author netwolf1;	state Exp;
branches;
next	1.484;

1.484
date	2005.01.07.03.43.01;	author netwolf1;	state Exp;
branches;
next	1.483;

1.483
date	2005.01.06.18.56.01;	author netwolf1;	state Exp;
branches;
next	1.482;

1.482
date	2004.12.13.05.25.08;	author aw3;	state Exp;
branches;
next	1.481;

1.481
date	2004.12.10.00.40.16;	author aw3;	state Exp;
branches;
next	1.480;

1.480
date	2004.11.08.21.08.19;	author aw3;	state Exp;
branches;
next	1.479;

1.479
date	2004.11.06.04.47.39;	author aw3;	state Exp;
branches;
next	1.478;

1.478
date	2004.11.02.17.08.17;	author aw3;	state Exp;
branches;
next	1.477;

1.477
date	2004.10.28.15.24.23;	author aw3;	state Exp;
branches;
next	1.476;

1.476
date	2004.10.27.21.25.04;	author aw3;	state Exp;
branches;
next	1.475;

1.475
date	2004.10.26.21.13.59;	author aw3;	state Exp;
branches;
next	1.474;

1.474
date	2004.10.20.16.11.45;	author aw3;	state Exp;
branches;
next	1.473;

1.473
date	2004.10.02.15.20.06;	author eklmn;	state Exp;
branches;
next	1.472;

1.472
date	2004.09.30.13.12.42;	author eklmn;	state Exp;
branches;
next	1.471;

1.471
date	2004.09.30.13.00.48;	author eklmn;	state Exp;
branches;
next	1.470;

1.470
date	2004.09.25.07.32.25;	author aw3;	state Exp;
branches;
next	1.469;

1.469
date	2004.09.13.22.47.17;	author aw3;	state Exp;
branches;
next	1.468;

1.468
date	2004.09.12.20.40.52;	author aw3;	state Exp;
branches;
next	1.467;

1.467
date	2004.09.10.20.32.40;	author eklmn;	state Exp;
branches;
next	1.466;

1.466
date	2004.09.10.05.16.41;	author eklmn;	state Exp;
branches;
next	1.465;

1.465
date	2004.08.28.04.51.50;	author aw3;	state Exp;
branches;
next	1.464;

1.464
date	2004.08.23.19.55.08;	author aw3;	state Exp;
branches;
next	1.463;

1.463
date	2004.08.17.14.06.16;	author aw3;	state Exp;
branches;
next	1.462;

1.462
date	2004.08.15.08.12.25;	author eklmn;	state Exp;
branches;
next	1.461;

1.461
date	2004.08.07.09.04.44;	author eklmn;	state Exp;
branches;
next	1.460;

1.460
date	2004.08.07.08.51.53;	author eklmn;	state Exp;
branches;
next	1.459;

1.459
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.458;

1.458
date	2004.08.04.04.14.35;	author aw3;	state Exp;
branches;
next	1.457;

1.457
date	2004.08.03.03.47.19;	author aw3;	state Exp;
branches;
next	1.456;

1.456
date	2004.07.24.06.57.22;	author aw3;	state Exp;
branches;
next	1.455;

1.455
date	2004.07.22.23.44.33;	author aw3;	state Exp;
branches;
next	1.454;

1.454
date	2004.07.16.19.08.06;	author dongato;	state Exp;
branches;
next	1.453;

1.453
date	2004.07.05.23.23.41;	author dongato;	state Exp;
branches;
next	1.452;

1.452
date	2004.07.05.20.50.57;	author dongato;	state Exp;
branches;
next	1.451;

1.451
date	2004.06.29.22.33.23;	author dongato;	state Exp;
branches;
next	1.450;

1.450
date	2004.06.27.02.56.11;	author dongato;	state Exp;
branches;
next	1.449;

1.449
date	2004.06.26.14.31.43;	author dongato;	state Exp;
branches;
next	1.448;

1.448
date	2004.06.23.17.17.06;	author dropf;	state Exp;
branches;
next	1.447;

1.447
date	2004.06.22.17.31.28;	author aw3;	state Exp;
branches;
next	1.446;

1.446
date	2004.06.22.17.04.03;	author katsyonak;	state Exp;
branches;
next	1.445;

1.445
date	2004.06.21.08.42.44;	author katsyonak;	state Exp;
branches;
next	1.444;

1.444
date	2004.06.17.23.43.02;	author aw3;	state Exp;
branches;
next	1.443;

1.443
date	2004.06.17.12.32.10;	author netwolf1;	state Exp;
branches;
next	1.442;

1.442
date	2004.06.17.06.36.34;	author katsyonak;	state Exp;
branches;
next	1.441;

1.441
date	2004.06.16.22.25.44;	author aw3;	state Exp;
branches;
next	1.440;

1.440
date	2004.06.09.04.53.00;	author aw3;	state Exp;
branches;
next	1.439;

1.439
date	2004.06.07.12.29.05;	author dropf;	state Exp;
branches;
next	1.438;

1.438
date	2004.06.06.11.02.03;	author katsyonak;	state Exp;
branches;
next	1.437;

1.437
date	2004.06.02.21.06.36;	author aw3;	state Exp;
branches;
next	1.436;

1.436
date	2004.06.01.22.30.45;	author aw3;	state Exp;
branches;
next	1.435;

1.435
date	2004.05.29.08.39.48;	author bavariansnail;	state Exp;
branches;
next	1.434;

1.434
date	2004.05.24.11.28.53;	author netwolf1;	state Exp;
branches;
next	1.433;

1.433
date	2004.05.23.10.11.58;	author dongato;	state Exp;
branches;
next	1.432;

1.432
date	2004.05.21.00.51.48;	author kush_eplus;	state Exp;
branches;
next	1.431;

1.431
date	2004.05.19.16.03.21;	author netwolf1;	state Exp;
branches;
next	1.430;

1.430
date	2004.05.19.05.59.51;	author dongato;	state Exp;
branches;
next	1.429;

1.429
date	2004.05.18.21.29.43;	author kush_eplus;	state Exp;
branches;
next	1.428;

1.428
date	2004.05.18.21.07.43;	author katsyonak;	state Exp;
branches;
next	1.427;

1.427
date	2004.05.15.00.34.17;	author aw3;	state Exp;
branches;
next	1.426;

1.426
date	2004.05.12.09.28.16;	author netwolf1;	state Exp;
branches;
next	1.425;

1.425
date	2004.05.12.08.30.29;	author netwolf1;	state Exp;
branches;
next	1.424;

1.424
date	2004.05.11.02.41.13;	author aw3;	state Exp;
branches;
next	1.423;

1.423
date	2004.05.07.04.56.18;	author aw3;	state Exp;
branches;
next	1.422;

1.422
date	2004.05.05.19.33.32;	author aw3;	state Exp;
branches;
next	1.421;

1.421
date	2004.05.05.17.17.43;	author netwolf1;	state Exp;
branches;
next	1.420;

1.420
date	2004.05.05.15.38.39;	author netwolf1;	state Exp;
branches;
next	1.419;

1.419
date	2004.05.04.14.45.23;	author dropf;	state Exp;
branches;
next	1.418;

1.418
date	2004.05.04.06.09.33;	author aw3;	state Exp;
branches;
next	1.417;

1.417
date	2004.05.03.09.59.44;	author netwolf1;	state Exp;
branches;
next	1.416;

1.416
date	2004.04.30.09.06.11;	author katsyonak;	state Exp;
branches;
next	1.415;

1.415
date	2004.04.29.11.59.45;	author netwolf1;	state Exp;
branches;
next	1.414;

1.414
date	2004.04.28.19.47.17;	author aw3;	state Exp;
branches;
next	1.413;

1.413
date	2004.04.26.14.23.38;	author katsyonak;	state Exp;
branches;
next	1.412;

1.412
date	2004.04.26.07.45.01;	author katsyonak;	state Exp;
branches;
next	1.411;

1.411
date	2004.04.25.20.00.46;	author katsyonak;	state Exp;
branches;
next	1.410;

1.410
date	2004.04.25.15.04.28;	author katsyonak;	state Exp;
branches;
next	1.409;

1.409
date	2004.04.25.14.26.30;	author katsyonak;	state Exp;
branches;
next	1.408;

1.408
date	2004.04.23.22.13.42;	author katsyonak;	state Exp;
branches;
next	1.407;

1.407
date	2004.04.16.08.39.13;	author dongato;	state Exp;
branches;
next	1.406;

1.406
date	2004.04.12.18.59.01;	author dongato;	state Exp;
branches;
next	1.405;

1.405
date	2004.04.12.15.09.16;	author aw3;	state Exp;
branches;
next	1.404;

1.404
date	2004.04.02.16.54.55;	author eklmn;	state Exp;
branches;
next	1.403;

1.403
date	2004.03.24.20.55.50;	author dongato;	state Exp;
branches;
next	1.402;

1.402
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.401;

1.401
date	2004.03.14.21.10.11;	author aw3;	state Exp;
branches;
next	1.400;

1.400
date	2004.03.13.05.33.35;	author aw3;	state Exp;
branches;
next	1.399;

1.399
date	2004.03.09.02.17.36;	author katsyonak;	state Exp;
branches;
next	1.398;

1.398
date	2004.03.06.19.50.59;	author eklmn;	state Exp;
branches;
next	1.397;

1.397
date	2004.02.25.17.58.54;	author kush_eplus;	state Exp;
branches;
next	1.396;

1.396
date	2004.02.25.04.46.32;	author aw3;	state Exp;
branches;
next	1.395;

1.395
date	2004.02.24.12.47.52;	author kush_eplus;	state Exp;
branches;
next	1.394;

1.394
date	2004.02.23.03.36.18;	author aw3;	state Exp;
branches;
next	1.393;

1.393
date	2004.02.20.17.10.29;	author aw3;	state Exp;
branches;
next	1.392;

1.392
date	2004.02.20.14.17.33;	author dongato;	state Exp;
branches;
next	1.391;

1.391
date	2004.02.20.00.22.25;	author kush_eplus;	state Exp;
branches;
next	1.390;

1.390
date	2004.02.18.21.33.34;	author aw3;	state Exp;
branches;
next	1.389;

1.389
date	2004.02.18.13.48.45;	author kush_eplus;	state Exp;
branches;
next	1.388;

1.388
date	2004.02.18.02.14.15;	author aw3;	state Exp;
branches;
next	1.387;

1.387
date	2004.02.17.13.36.01;	author dongato;	state Exp;
branches;
next	1.386;

1.386
date	2004.02.17.01.58.30;	author kush_eplus;	state Exp;
branches;
next	1.385;

1.385
date	2004.02.16.23.17.07;	author aw3;	state Exp;
branches;
next	1.384;

1.384
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.383;

1.383
date	2004.02.15.03.41.59;	author kush_eplus;	state Exp;
branches;
next	1.382;

1.382
date	2004.02.15.00.56.50;	author kush_eplus;	state Exp;
branches;
next	1.381;

1.381
date	2004.02.14.21.35.25;	author kush_eplus;	state Exp;
branches;
next	1.380;

1.380
date	2004.02.12.21.23.19;	author dongato;	state Exp;
branches;
next	1.379;

1.379
date	2004.02.12.10.38.01;	author morevit;	state Exp;
branches;
next	1.378;

1.378
date	2004.02.11.23.32.38;	author aw3;	state Exp;
branches;
next	1.377;

1.377
date	2004.02.11.03.52.43;	author aw3;	state Exp;
branches;
next	1.376;

1.376
date	2004.02.08.22.42.02;	author kush_eplus;	state Exp;
branches;
next	1.375;

1.375
date	2004.02.05.11.56.05;	author morevit;	state Exp;
branches;
next	1.374;

1.374
date	2004.02.04.23.59.58;	author kush_eplus;	state Exp;
branches;
next	1.373;

1.373
date	2004.02.04.19.05.42;	author morevit;	state Exp;
branches;
next	1.372;

1.372
date	2004.02.04.13.40.57;	author kush_eplus;	state Exp;
branches;
next	1.371;

1.371
date	2004.02.03.21.43.00;	author syrus77;	state Exp;
branches;
next	1.370;

1.370
date	2004.02.03.14.28.05;	author kush_eplus;	state Exp;
branches;
next	1.369;

1.369
date	2004.02.03.07.46.33;	author kush_eplus;	state Exp;
branches;
next	1.368;

1.368
date	2004.02.02.21.28.45;	author katsyonak;	state Exp;
branches;
next	1.367;

1.367
date	2004.02.02.08.43.01;	author kush_eplus;	state Exp;
branches;
next	1.366;

1.366
date	2004.02.01.22.09.58;	author dongato;	state Exp;
branches;
next	1.365;

1.365
date	2004.02.01.21.43.17;	author eklmn;	state Exp;
branches;
next	1.364;

1.364
date	2004.02.01.16.33.45;	author netwolf1;	state Exp;
branches;
next	1.363;

1.363
date	2004.02.01.14.20.43;	author dongato;	state Exp;
branches;
next	1.362;

1.362
date	2004.01.31.07.24.00;	author eklmn;	state Exp;
branches;
next	1.361;

1.361
date	2004.01.27.04.59.50;	author kush_eplus;	state Exp;
branches;
next	1.360;

1.360
date	2004.01.26.04.46.10;	author kush_eplus;	state Exp;
branches;
next	1.359;

1.359
date	2004.01.23.05.24.06;	author kush_eplus;	state Exp;
branches;
next	1.358;

1.358
date	2004.01.21.23.20.45;	author dongato;	state Exp;
branches;
next	1.357;

1.357
date	2004.01.21.17.54.29;	author dongato;	state Exp;
branches;
next	1.356;

1.356
date	2004.01.21.13.02.28;	author dongato;	state Exp;
branches;
next	1.355;

1.355
date	2004.01.19.21.21.54;	author eklmn;	state Exp;
branches;
next	1.354;

1.354
date	2004.01.19.18.21.28;	author dropf;	state Exp;
branches;
next	1.353;

1.353
date	2004.01.16.22.03.10;	author eklmn;	state Exp;
branches;
next	1.352;

1.352
date	2004.01.14.23.13.26;	author eklmn;	state Exp;
branches;
next	1.351;

1.351
date	2004.01.14.17.47.53;	author netwolf1;	state Exp;
branches;
next	1.350;

1.350
date	2004.01.13.11.58.28;	author netwolf1;	state Exp;
branches;
next	1.349;

1.349
date	2004.01.11.14.13.09;	author dongato;	state Exp;
branches;
next	1.348;

1.348
date	2004.01.11.00.51.57;	author netwolf1;	state Exp;
branches;
next	1.347;

1.347
date	2004.01.04.22.24.38;	author dongato;	state Exp;
branches;
next	1.346;

1.346
date	2004.01.02.10.39.40;	author dongato;	state Exp;
branches;
next	1.345;

1.345
date	2003.12.31.03.01.57;	author syrus77;	state Exp;
branches;
next	1.344;

1.344
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.343;

1.343
date	2003.12.18.14.34.03;	author dongato;	state Exp;
branches;
next	1.342;

1.342
date	2003.12.10.15.40.22;	author dongato;	state Exp;
branches;
next	1.341;

1.341
date	2003.11.30.17.52.44;	author eklmn;	state Exp;
branches;
next	1.340;

1.340
date	2003.11.29.23.36.33;	author katsyonak;	state Exp;
branches;
next	1.339;

1.339
date	2003.11.27.13.57.18;	author eklmn;	state Exp;
branches;
next	1.338;

1.338
date	2003.11.24.04.55.03;	author katsyonak;	state Exp;
branches;
next	1.337;

1.337
date	2003.11.23.13.33.37;	author katsyonak;	state Exp;
branches;
next	1.336;

1.336
date	2003.11.21.19.32.58;	author katsyonak;	state Exp;
branches;
next	1.335;

1.335
date	2003.11.20.20.07.24;	author katsyonak;	state Exp;
branches;
next	1.334;

1.334
date	2003.11.20.09.56.46;	author katsyonak;	state Exp;
branches;
next	1.333;

1.333
date	2003.11.19.18.56.38;	author katsyonak;	state Exp;
branches;
next	1.332;

1.332
date	2003.11.19.17.03.07;	author katsyonak;	state Exp;
branches;
next	1.331;

1.331
date	2003.11.19.00.20.01;	author katsyonak;	state Exp;
branches;
next	1.330;

1.330
date	2003.11.18.23.24.20;	author katsyonak;	state Exp;
branches;
next	1.329;

1.329
date	2003.11.18.22.59.12;	author katsyonak;	state Exp;
branches;
next	1.328;

1.328
date	2003.11.17.13.55.51;	author dongato;	state Exp;
branches;
next	1.327;

1.327
date	2003.11.16.22.05.24;	author katsyonak;	state Exp;
branches;
next	1.326;

1.326
date	2003.11.16.14.59.02;	author syrus77;	state Exp;
branches;
next	1.325;

1.325
date	2003.11.15.00.21.46;	author syrus77;	state Exp;
branches;
next	1.324;

1.324
date	2003.11.14.17.55.05;	author dongato;	state Exp;
branches;
next	1.323;

1.323
date	2003.11.13.12.32.48;	author katsyonak;	state Exp;
branches;
next	1.322;

1.322
date	2003.11.12.23.39.16;	author katsyonak;	state Exp;
branches;
next	1.321;

1.321
date	2003.11.12.14.26.04;	author kuchin;	state Exp;
branches;
next	1.320;

1.320
date	2003.11.11.21.36.56;	author dropf;	state Exp;
branches;
next	1.319;

1.319
date	2003.11.05.22.37.19;	author dongato;	state Exp;
branches;
next	1.318;

1.318
date	2003.11.05.01.07.20;	author katsyonak;	state Exp;
branches;
next	1.317;

1.317
date	2003.11.04.20.15.32;	author dropf;	state Exp;
branches;
next	1.316;

1.316
date	2003.11.04.18.08.24;	author dongato;	state Exp;
branches;
next	1.315;

1.315
date	2003.11.03.15.50.27;	author dongato;	state Exp;
branches;
next	1.314;

1.314
date	2003.11.01.17.59.29;	author morevit;	state Exp;
branches;
next	1.313;

1.313
date	2003.11.01.04.17.10;	author morevit;	state Exp;
branches;
next	1.312;

1.312
date	2003.10.31.19.43.58;	author morevit;	state Exp;
branches;
next	1.311;

1.311
date	2003.10.30.02.44.37;	author morevit;	state Exp;
branches;
next	1.310;

1.310
date	2003.10.29.22.13.31;	author dropf;	state Exp;
branches;
next	1.309;

1.309
date	2003.10.29.14.14.17;	author morevit;	state Exp;
branches;
next	1.308;

1.308
date	2003.10.28.21.58.17;	author morevit;	state Exp;
branches;
next	1.307;

1.307
date	2003.10.28.21.32.10;	author morevit;	state Exp;
branches;
next	1.306;

1.306
date	2003.10.27.13.32.42;	author dongato;	state Exp;
branches;
next	1.305;

1.305
date	2003.10.27.00.13.46;	author dongato;	state Exp;
branches;
next	1.304;

1.304
date	2003.10.26.15.57.06;	author morevit;	state Exp;
branches;
next	1.303;

1.303
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.302;

1.302
date	2003.10.24.21.16.28;	author dongato;	state Exp;
branches;
next	1.301;

1.301
date	2003.10.24.21.10.04;	author morevit;	state Exp;
branches;
next	1.300;

1.300
date	2003.10.24.01.21.19;	author morevit;	state Exp;
branches;
next	1.299;

1.299
date	2003.10.22.20.36.33;	author dongato;	state Exp;
branches;
next	1.298;

1.298
date	2003.10.21.17.49.19;	author dongato;	state Exp;
branches;
next	1.297;

1.297
date	2003.10.21.16.13.17;	author dongato;	state Exp;
branches;
next	1.296;

1.296
date	2003.10.21.14.33.57;	author dongato;	state Exp;
branches;
next	1.295;

1.295
date	2003.10.21.10.44.57;	author morevit;	state Exp;
branches;
next	1.294;

1.294
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.293;

1.293
date	2003.10.20.14.27.53;	author dongato;	state Exp;
branches;
next	1.292;

1.292
date	2003.10.20.13.19.58;	author morevit;	state Exp;
branches;
next	1.291;

1.291
date	2003.10.17.22.26.20;	author morevit;	state Exp;
branches;
next	1.290;

1.290
date	2003.10.17.21.53.30;	author morevit;	state Exp;
branches;
next	1.289;

1.289
date	2003.10.17.18.11.26;	author morevit;	state Exp;
branches;
next	1.288;

1.288
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.287;

1.287
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.286;

1.286
date	2003.10.15.14.15.32;	author morevit;	state Exp;
branches;
next	1.285;

1.285
date	2003.10.15.12.35.56;	author dongato;	state Exp;
branches;
next	1.284;

1.284
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.283;

1.283
date	2003.10.13.15.07.45;	author morevit;	state Exp;
branches;
next	1.282;

1.282
date	2003.10.11.18.01.06;	author morevit;	state Exp;
branches;
next	1.281;

1.281
date	2003.10.11.16.35.33;	author morevit;	state Exp;
branches;
next	1.280;

1.280
date	2003.10.10.04.12.21;	author dongato;	state Exp;
branches;
next	1.279;

1.279
date	2003.10.09.11.55.02;	author morevit;	state Exp;
branches;
next	1.278;

1.278
date	2003.10.08.15.39.47;	author morevit;	state Exp;
branches;
next	1.277;

1.277
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.276;

1.276
date	2003.10.08.01.53.31;	author morevit;	state Exp;
branches;
next	1.275;

1.275
date	2003.10.07.20.50.01;	author dongato;	state Exp;
branches;
next	1.274;

1.274
date	2003.10.07.13.11.46;	author dongato;	state Exp;
branches;
next	1.273;

1.273
date	2003.10.07.11.36.32;	author dongato;	state Exp;
branches;
next	1.272;

1.272
date	2003.10.06.23.42.59;	author dongato;	state Exp;
branches;
next	1.271;

1.271
date	2003.10.06.21.57.05;	author puritynn666;	state Exp;
branches;
next	1.270;

1.270
date	2003.10.06.17.01.02;	author dongato;	state Exp;
branches;
next	1.269;

1.269
date	2003.10.06.16.52.37;	author dongato;	state Exp;
branches;
next	1.268;

1.268
date	2003.10.06.14.59.25;	author dongato;	state Exp;
branches;
next	1.267;

1.267
date	2003.10.06.14.45.00;	author morevit;	state Exp;
branches;
next	1.266;

1.266
date	2003.10.06.13.24.11;	author dongato;	state Exp;
branches;
next	1.265;

1.265
date	2003.10.05.22.22.44;	author dongato;	state Exp;
branches;
next	1.264;

1.264
date	2003.10.05.06.22.51;	author dongato;	state Exp;
branches;
next	1.263;

1.263
date	2003.10.05.00.32.35;	author dongato;	state Exp;
branches;
next	1.262;

1.262
date	2003.10.04.22.16.23;	author morevit;	state Exp;
branches;
next	1.261;

1.261
date	2003.10.04.16.54.07;	author dongato;	state Exp;
branches;
next	1.260;

1.260
date	2003.10.03.23.19.22;	author morevit;	state Exp;
branches;
next	1.259;

1.259
date	2003.10.03.22.20.51;	author dongato;	state Exp;
branches;
next	1.258;

1.258
date	2003.10.03.21.38.45;	author dongato;	state Exp;
branches;
next	1.257;

1.257
date	2003.10.03.13.42.05;	author morevit;	state Exp;
branches;
next	1.256;

1.256
date	2003.10.03.00.11.51;	author dongato;	state Exp;
branches;
next	1.255;

1.255
date	2003.10.02.15.32.59;	author dongato;	state Exp;
branches;
next	1.254;

1.254
date	2003.10.02.14.25.59;	author dongato;	state Exp;
branches;
next	1.253;

1.253
date	2003.10.02.11.08.27;	author dongato;	state Exp;
branches;
next	1.252;

1.252
date	2003.10.01.20.07.58;	author netwolf1;	state Exp;
branches;
next	1.251;

1.251
date	2003.10.01.16.38.45;	author morevit;	state Exp;
branches;
next	1.250;

1.250
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.249;

1.249
date	2003.09.30.19.53.17;	author morevit;	state Exp;
branches;
next	1.248;

1.248
date	2003.09.28.16.26.10;	author morevit;	state Exp;
branches;
next	1.247;

1.247
date	2003.09.28.13.55.07;	author dongato;	state Exp;
branches;
next	1.246;

1.246
date	2003.09.27.00.31.22;	author morevit;	state Exp;
branches;
next	1.245;

1.245
date	2003.09.26.23.38.42;	author morevit;	state Exp;
branches;
next	1.244;

1.244
date	2003.09.24.16.44.50;	author morevit;	state Exp;
branches;
next	1.243;

1.243
date	2003.09.23.23.36.24;	author dongato;	state Exp;
branches;
next	1.242;

1.242
date	2003.09.23.22.45.49;	author dongato;	state Exp;
branches;
next	1.241;

1.241
date	2003.09.23.21.04.23;	author morevit;	state Exp;
branches;
next	1.240;

1.240
date	2003.09.23.20.26.30;	author dongato;	state Exp;
branches;
next	1.239;

1.239
date	2003.09.23.19.36.58;	author dongato;	state Exp;
branches;
next	1.238;

1.238
date	2003.09.23.16.52.49;	author morevit;	state Exp;
branches;
next	1.237;

1.237
date	2003.09.23.13.50.34;	author dongato;	state Exp;
branches;
next	1.236;

1.236
date	2003.09.22.20.01.03;	author dongato;	state Exp;
branches;
next	1.235;

1.235
date	2003.09.22.15.46.15;	author morevit;	state Exp;
branches;
next	1.234;

1.234
date	2003.09.22.00.50.55;	author morevit;	state Exp;
branches;
next	1.233;

1.233
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.232;

1.232
date	2003.09.21.22.05.14;	author morevit;	state Exp;
branches;
next	1.231;

1.231
date	2003.09.21.13.00.46;	author morevit;	state Exp;
branches;
next	1.230;

1.230
date	2003.09.20.20.47.40;	author bavariansnail;	state Exp;
branches;
next	1.229;

1.229
date	2003.09.20.15.24.30;	author morevit;	state Exp;
branches;
next	1.228;

1.228
date	2003.09.19.18.02.06;	author syrus77;	state Exp;
branches;
next	1.227;

1.227
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.226;

1.226
date	2003.09.18.13.55.03;	author netwolf1;	state Exp;
branches;
next	1.225;

1.225
date	2003.09.16.15.52.46;	author dongato;	state Exp;
branches;
next	1.224;

1.224
date	2003.09.15.14.26.31;	author dongato;	state Exp;
branches;
next	1.223;

1.223
date	2003.09.14.13.48.42;	author dongato;	state Exp;
branches;
next	1.222;

1.222
date	2003.09.12.16.05.53;	author dongato;	state Exp;
branches;
next	1.221;

1.221
date	2003.09.10.02.40.11;	author dongato;	state Exp;
branches;
next	1.220;

1.220
date	2003.09.09.21.36.01;	author dongato;	state Exp;
branches;
next	1.219;

1.219
date	2003.09.08.01.27.06;	author dongato;	state Exp;
branches;
next	1.218;

1.218
date	2003.09.07.19.21.08;	author dongato;	state Exp;
branches;
next	1.217;

1.217
date	2003.09.07.12.51.12;	author dongato;	state Exp;
branches;
next	1.216;

1.216
date	2003.09.07.05.20.38;	author dongato;	state Exp;
branches;
next	1.215;

1.215
date	2003.09.06.02.19.22;	author dongato;	state Exp;
branches;
next	1.214;

1.214
date	2003.09.03.19.44.20;	author dongato;	state Exp;
branches;
next	1.213;

1.213
date	2003.09.01.10.01.51;	author dongato;	state Exp;
branches;
next	1.212;

1.212
date	2003.08.31.23.19.16;	author dongato;	state Exp;
branches;
next	1.211;

1.211
date	2003.08.31.20.48.05;	author dongato;	state Exp;
branches;
next	1.210;

1.210
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.209;

1.209
date	2003.08.31.13.20.46;	author emoulari;	state Exp;
branches;
next	1.208;

1.208
date	2003.08.30.12.55.15;	author netwolf1;	state Exp;
branches;
next	1.207;

1.207
date	2003.08.30.11.23.25;	author emoulari;	state Exp;
branches;
next	1.206;

1.206
date	2003.08.27.19.46.16;	author syrus77;	state Exp;
branches;
next	1.205;

1.205
date	2003.08.24.11.51.23;	author dongato;	state Exp;
branches;
next	1.204;

1.204
date	2003.08.24.11.04.23;	author forcha;	state Exp;
branches;
next	1.203;

1.203
date	2003.08.23.23.28.51;	author forcha;	state Exp;
branches;
next	1.202;

1.202
date	2003.08.23.21.45.31;	author dongato;	state Exp;
branches;
next	1.201;

1.201
date	2003.08.23.19.52.03;	author forcha;	state Exp;
branches;
next	1.200;

1.200
date	2003.08.23.16.38.14;	author forcha;	state Exp;
branches;
next	1.199;

1.199
date	2003.08.23.14.03.49;	author dongato;	state Exp;
branches;
next	1.198;

1.198
date	2003.08.23.10.59.19;	author forcha;	state Exp;
branches;
next	1.197;

1.197
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.196;

1.196
date	2003.08.22.23.48.29;	author dongato;	state Exp;
branches;
next	1.195;

1.195
date	2003.08.21.01.19.56;	author dongato;	state Exp;
branches;
next	1.194;

1.194
date	2003.08.20.20.57.28;	author dongato;	state Exp;
branches;
next	1.193;

1.193
date	2003.08.20.13.51.55;	author dongato;	state Exp;
branches;
next	1.192;

1.192
date	2003.08.20.01.56.31;	author dongato;	state Exp;
branches;
next	1.191;

1.191
date	2003.08.19.17.32.46;	author dongato;	state Exp;
branches;
next	1.190;

1.190
date	2003.08.18.11.49.33;	author dongato;	state Exp;
branches;
next	1.189;

1.189
date	2003.08.17.21.48.42;	author dongato;	state Exp;
branches;
next	1.188;

1.188
date	2003.08.17.16.11.54;	author dongato;	state Exp;
branches;
next	1.187;

1.187
date	2003.08.15.15.07.12;	author forcha;	state Exp;
branches;
next	1.186;

1.186
date	2003.08.10.18.29.08;	author zegzav;	state Exp;
branches;
next	1.185;

1.185
date	2003.08.10.01.25.40;	author dongato;	state Exp;
branches;
next	1.184;

1.184
date	2003.08.10.00.33.24;	author dongato;	state Exp;
branches;
next	1.183;

1.183
date	2003.08.03.16.51.07;	author dongato;	state Exp;
branches;
next	1.182;

1.182
date	2003.08.03.13.51.24;	author dongato;	state Exp;
branches;
next	1.181;

1.181
date	2003.07.30.08.54.47;	author emoulari;	state Exp;
branches;
next	1.180;

1.180
date	2003.07.30.08.38.13;	author emoulari;	state Exp;
branches;
next	1.179;

1.179
date	2003.07.29.11.40.57;	author moosetea;	state Exp;
branches;
next	1.178;

1.178
date	2003.07.29.09.09.04;	author dongato;	state Exp;
branches;
next	1.177;

1.177
date	2003.07.28.23.13.42;	author moosetea;	state Exp;
branches;
next	1.176;

1.176
date	2003.07.28.20.40.59;	author dongato;	state Exp;
branches;
next	1.175;

1.175
date	2003.07.27.23.16.07;	author dongato;	state Exp;
branches;
next	1.174;

1.174
date	2003.07.24.20.08.41;	author eklmn;	state Exp;
branches;
next	1.173;

1.173
date	2003.07.24.17.15.49;	author eklmn;	state Exp;
branches;
next	1.172;

1.172
date	2003.07.23.22.05.22;	author netwolf1;	state Exp;
branches;
next	1.171;

1.171
date	2003.07.22.16.40.00;	author eklmn;	state Exp;
branches;
next	1.170;

1.170
date	2003.07.21.15.56.36;	author eklmn;	state Exp;
branches;
next	1.169;

1.169
date	2003.07.16.23.12.52;	author syrus77;	state Exp;
branches;
next	1.168;

1.168
date	2003.07.12.14.10.37;	author dongato;	state Exp;
branches;
next	1.167;

1.167
date	2003.07.12.07.42.07;	author eklmn;	state Exp;
branches;
next	1.166;

1.166
date	2003.07.07.22.13.26;	author syrus77;	state Exp;
branches;
next	1.165;

1.165
date	2003.07.05.11.53.08;	author dongato;	state Exp;
branches;
next	1.164;

1.164
date	2003.07.02.22.35.21;	author syrus77;	state Exp;
branches;
next	1.163;

1.163
date	2003.07.02.15.56.19;	author eklmn;	state Exp;
branches;
next	1.162;

1.162
date	2003.06.29.20.17.12;	author syrus77;	state Exp;
branches;
next	1.161;

1.161
date	2003.06.28.18.55.30;	author dongato;	state Exp;
branches;
next	1.160;

1.160
date	2003.06.28.18.17.24;	author eklmn;	state Exp;
branches;
next	1.159;

1.159
date	2003.06.28.15.43.23;	author dongato;	state Exp;
branches;
next	1.158;

1.158
date	2003.06.28.01.23.44;	author dongato;	state Exp;
branches;
next	1.157;

1.157
date	2003.06.27.12.35.36;	author syrus77;	state Exp;
branches;
next	1.156;

1.156
date	2003.06.27.01.23.59;	author syrus77;	state Exp;
branches;
next	1.155;

1.155
date	2003.06.22.13.40.41;	author syrus77;	state Exp;
branches;
next	1.154;

1.154
date	2003.06.19.07.47.47;	author partyckip;	state Exp;
branches;
next	1.153;

1.153
date	2003.06.14.00.48.56;	author netwolf1;	state Exp;
branches;
next	1.152;

1.152
date	2003.06.13.17.15.57;	author eklmn;	state Exp;
branches;
next	1.151;

1.151
date	2003.06.11.18.27.06;	author eklmn;	state Exp;
branches;
next	1.150;

1.150
date	2003.06.09.00.31.11;	author syrus77;	state Exp;
branches;
next	1.149;

1.149
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.148;

1.148
date	2003.06.06.00.42.42;	author syrus77;	state Exp;
branches;
next	1.147;

1.147
date	2003.06.05.20.49.50;	author syrus77;	state Exp;
branches;
next	1.146;

1.146
date	2003.06.01.08.59.01;	author kuchin;	state Exp;
branches;
next	1.145;

1.145
date	2003.05.31.17.14.28;	author partyckip;	state Exp;
branches;
next	1.144;

1.144
date	2003.05.30.21.26.57;	author partyckip;	state Exp;
branches;
next	1.143;

1.143
date	2003.05.27.23.03.06;	author partyckip;	state Exp;
branches;
next	1.142;

1.142
date	2003.05.24.20.42.00;	author syrus77;	state Exp;
branches;
next	1.141;

1.141
date	2003.05.24.18.03.55;	author syrus77;	state Exp;
branches;
next	1.140;

1.140
date	2003.05.23.12.58.18;	author netwolf1;	state Exp;
branches;
next	1.139;

1.139
date	2003.05.20.20.46.26;	author netwolf1;	state Exp;
branches;
next	1.138;

1.138
date	2003.05.20.15.40.44;	author netwolf1;	state Exp;
branches;
next	1.137;

1.137
date	2003.05.20.10.20.37;	author dongato;	state Exp;
branches;
next	1.136;

1.136
date	2003.05.18.13.29.13;	author kuchin;	state Exp;
branches;
next	1.135;

1.135
date	2003.05.18.11.40.31;	author obaldin;	state Exp;
branches;
next	1.134;

1.134
date	2003.05.17.13.49.57;	author syrus77;	state Exp;
branches;
next	1.133;

1.133
date	2003.05.16.01.14.45;	author syrus77;	state Exp;
branches;
next	1.132;

1.132
date	2003.05.15.22.03.54;	author syrus77;	state Exp;
branches;
next	1.131;

1.131
date	2003.05.14.23.32.31;	author netwolf1;	state Exp;
branches;
next	1.130;

1.130
date	2003.05.13.16.55.41;	author moosetea;	state Exp;
branches;
next	1.129;

1.129
date	2003.05.09.23.07.44;	author moosetea;	state Exp;
branches;
next	1.128;

1.128
date	2003.05.08.17.08.25;	author netwolf1;	state Exp;
branches;
next	1.127;

1.127
date	2003.05.06.23.11.20;	author moosetea;	state Exp;
branches;
next	1.126;

1.126
date	2003.05.05.12.25.03;	author kuchin;	state Exp;
branches;
next	1.125;

1.125
date	2003.05.04.12.30.57;	author dongato;	state Exp;
branches;
next	1.124;

1.124
date	2003.05.04.10.05.32;	author kuchin;	state Exp;
branches;
next	1.123;

1.123
date	2003.04.27.14.48.23;	author kuchin;	state Exp;
branches;
next	1.122;

1.122
date	2003.04.26.19.46.44;	author lord_kiron;	state Exp;
branches;
next	1.121;

1.121
date	2003.04.26.17.39.14;	author lord_kiron;	state Exp;
branches;
next	1.120;

1.120
date	2003.04.25.21.57.10;	author lord_kiron;	state Exp;
branches;
next	1.119;

1.119
date	2003.03.30.12.10.20;	author moosetea;	state Exp;
branches;
next	1.118;

1.118
date	2003.03.28.10.19.08;	author dongato;	state Exp;
branches;
next	1.117;

1.117
date	2003.03.28.02.05.02;	author recdvst;	state Exp;
branches;
next	1.116;

1.116
date	2003.03.27.09.40.13;	author recdvst;	state Exp;
branches;
next	1.115;

1.115
date	2003.03.25.12.39.34;	author cax2;	state Exp;
branches;
next	1.114;

1.114
date	2003.03.22.01.13.59;	author cax2;	state Exp;
branches
	1.114.2.1;
next	1.113;

1.113
date	2003.03.21.18.55.16;	author dongato;	state Exp;
branches;
next	1.112;

1.112
date	2003.03.21.06.45.35;	author partyckip;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.19.18.34.48;	author cax2;	state Exp;
branches;
next	1.110;

1.110
date	2003.03.19.18.09.26;	author cax2;	state Exp;
branches;
next	1.109;

1.109
date	2003.03.17.20.02.35;	author lord_kiron;	state Exp;
branches;
next	1.108;

1.108
date	2003.03.17.05.59.30;	author recdvst;	state Exp;
branches;
next	1.107;

1.107
date	2003.03.16.01.53.14;	author recdvst;	state Exp;
branches;
next	1.106;

1.106
date	2003.03.15.19.50.54;	author dongato;	state Exp;
branches;
next	1.105;

1.105
date	2003.03.15.01.07.52;	author obaldin;	state Exp;
branches;
next	1.104;

1.104
date	2003.03.15.00.51.54;	author obaldin;	state Exp;
branches;
next	1.103;

1.103
date	2003.03.14.18.13.11;	author cax2;	state Exp;
branches;
next	1.102;

1.102
date	2003.03.14.16.24.16;	author partyckip;	state Exp;
branches;
next	1.101;

1.101
date	2003.03.13.21.35.15;	author partyckip;	state Exp;
branches;
next	1.100;

1.100
date	2003.03.13.10.48.32;	author recdvst;	state Exp;
branches;
next	1.99;

1.99
date	2003.03.13.07.03.41;	author recdvst;	state Exp;
branches;
next	1.98;

1.98
date	2003.03.13.06.23.50;	author recdvst;	state Exp;
branches;
next	1.97;

1.97
date	2003.03.11.00.34.10;	author cax2;	state Exp;
branches;
next	1.96;

1.96
date	2003.03.10.23.04.14;	author cax2;	state Exp;
branches;
next	1.95;

1.95
date	2003.03.10.20.10.08;	author cax2;	state Exp;
branches;
next	1.94;

1.94
date	2003.03.08.19.27.12;	author dongato;	state Exp;
branches;
next	1.93;

1.93
date	2003.03.08.17.33.31;	author dongato;	state Exp;
branches;
next	1.92;

1.92
date	2003.03.08.12.09.41;	author recdvst;	state Exp;
branches;
next	1.91;

1.91
date	2003.03.08.02.26.22;	author kuchin;	state Exp;
branches;
next	1.90;

1.90
date	2003.03.06.21.01.51;	author obaldin;	state Exp;
branches;
next	1.89;

1.89
date	2003.03.06.18.54.33;	author dongato;	state Exp;
branches;
next	1.88;

1.88
date	2003.03.06.02.09.46;	author dongato;	state Exp;
branches;
next	1.87;

1.87
date	2003.03.06.02.00.55;	author dongato;	state Exp;
branches;
next	1.86;

1.86
date	2003.03.05.11.23.43;	author recdvst;	state Exp;
branches;
next	1.85;

1.85
date	2003.03.03.19.15.41;	author lord_kiron;	state Exp;
branches;
next	1.84;

1.84
date	2003.03.03.19.03.05;	author cax2;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.01.12.48.29;	author dongato;	state Exp;
branches;
next	1.82;

1.82
date	2003.02.28.21.00.25;	author dongato;	state Exp;
branches;
next	1.81;

1.81
date	2003.02.28.16.53.20;	author cax2;	state Exp;
branches;
next	1.80;

1.80
date	2003.02.28.14.20.08;	author cax2;	state Exp;
branches;
next	1.79;

1.79
date	2003.02.28.02.38.07;	author dongato;	state Exp;
branches;
next	1.78;

1.78
date	2003.02.28.00.53.23;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2003.02.27.21.16.58;	author dongato;	state Exp;
branches;
next	1.76;

1.76
date	2003.02.27.20.53.33;	author cax2;	state Exp;
branches;
next	1.75;

1.75
date	2003.02.27.19.53.18;	author cax2;	state Exp;
branches;
next	1.74;

1.74
date	2003.02.27.19.15.48;	author cax2;	state Exp;
branches;
next	1.73;

1.73
date	2003.02.27.16.01.02;	author dongato;	state Exp;
branches;
next	1.72;

1.72
date	2003.02.27.12.11.24;	author kuchin;	state Exp;
branches;
next	1.71;

1.71
date	2003.02.27.10.53.45;	author dongato;	state Exp;
branches;
next	1.70;

1.70
date	2003.02.27.10.06.32;	author kuchin;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.26.18.36.21;	author kuchin;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.26.15.07.43;	author dongato;	state Exp;
branches;
next	1.67;

1.67
date	2003.02.25.18.07.59;	author cax2;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.25.14.46.28;	author kuchin;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.25.11.46.29;	author kuchin;	state Exp;
branches;
next	1.64;

1.64
date	2003.02.25.02.34.36;	author dongato;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2003.02.24.22.01.58;	author forcha;	state Exp;
branches;
next	1.62;

1.62
date	2003.02.24.21.01.21;	author dongato;	state Exp;
branches;
next	1.61;

1.61
date	2003.02.24.20.09.38;	author dongato;	state Exp;
branches;
next	1.60;

1.60
date	2003.02.24.18.06.07;	author cax2;	state Exp;
branches;
next	1.59;

1.59
date	2003.02.24.17.20.11;	author kuchin;	state Exp;
branches;
next	1.58;

1.58
date	2003.02.24.16.15.01;	author kuchin;	state Exp;
branches;
next	1.57;

1.57
date	2003.02.24.16.06.46;	author kuchin;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.24.15.04.28;	author kuchin;	state Exp;
branches;
next	1.55;

1.55
date	2003.02.24.11.49.32;	author kuchin;	state Exp;
branches;
next	1.54;

1.54
date	2003.02.24.11.10.19;	author kuchin;	state Exp;
branches;
next	1.53;

1.53
date	2003.02.23.18.21.18;	author kuchin;	state Exp;
branches;
next	1.52;

1.52
date	2003.02.23.16.12.02;	author forcha;	state Exp;
branches;
next	1.51;

1.51
date	2003.02.21.13.29.44;	author kuchin;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.21.12.46.55;	author kuchin;	state Exp;
branches;
next	1.49;

1.49
date	2003.02.21.04.46.03;	author cax2;	state Exp;
branches;
next	1.48;

1.48
date	2003.02.20.23.21.16;	author cax2;	state Exp;
branches;
next	1.47;

1.47
date	2003.02.20.07.25.21;	author cax2;	state Exp;
branches;
next	1.46;

1.46
date	2003.02.19.20.53.06;	author cax2;	state Exp;
branches;
next	1.45;

1.45
date	2003.02.19.10.11.38;	author dongato;	state Exp;
branches;
next	1.44;

1.44
date	2003.02.19.00.47.01;	author dongato;	state Exp;
branches;
next	1.43;

1.43
date	2003.02.18.19.58.57;	author dongato;	state Exp;
branches;
next	1.42;

1.42
date	2003.02.18.18.12.03;	author dongato;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.18.14.52.38;	author dongato;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.17.22.09.44;	author obaldin;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.17.20.34.55;	author obaldin;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.17.17.43.13;	author lord_kiron;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.17.14.58.45;	author kuchin;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.16.22.21.04;	author lord_kiron;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.15.15.15.06;	author dongato;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.14.20.10.33;	author obaldin;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.14.16.35.13;	author lord_kiron;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.14.15.33.34;	author lord_kiron;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.14.14.55.32;	author lord_kiron;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.13.18.43.14;	author lord_kiron;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.13.18.27.41;	author lord_kiron;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.13.17.45.39;	author cax2;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.12.20.18.21;	author obaldin;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.11.22.50.43;	author lord_kiron;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.11.19.46.09;	author lord_kiron;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.11.17.52.16;	author kuchin;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.10.20.37.20;	author cax2;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.10.19.24.47;	author cax2;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.10.19.13.20;	author obaldin;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.10.15.34.20;	author obaldin;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.09.18.39.41;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.07.08.00.30;	author lord_kiron;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.06.21.13.55;	author lord_kiron;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.02.14.58.52;	author obaldin;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2003.02.02.10.47.20;	author cax2;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.02.03.39.55;	author cax2;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.30.11.07.34;	author cax2;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.29.14.37.04;	author cax2;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.26.23.46.43;	author cax2;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2003.01.26.21.36.59;	author cax2;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.26.15.21.47;	author cax2;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.24.18.30.31;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.24.15.53.18;	author obaldin;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.01.42.30;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.17.55.23;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches;
next	;

1.9.2.1
date	2003.01.28.16.54.04;	author cax2;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.01.29.13.38.25;	author cax2;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.01.30.14.53.37;	author cax2;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.02.02.02.36.26;	author cax2;	state Exp;
branches;
next	1.9.2.5;

1.9.2.5
date	2003.02.02.10.26.46;	author cax2;	state Exp;
branches;
next	;

1.14.2.1
date	2003.02.05.17.03.12;	author obaldin;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2003.02.06.15.56.14;	author obaldin;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.02.06.22.56.22;	author obaldin;	state Exp;
branches;
next	1.14.2.4;

1.14.2.4
date	2003.02.08.13.37.04;	author obaldin;	state Exp;
branches;
next	1.14.2.5;

1.14.2.5
date	2003.02.08.22.16.21;	author obaldin;	state Exp;
branches;
next	;

1.64.2.1
date	2003.02.28.22.44.54;	author obaldin;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2003.03.01.20.59.35;	author obaldin;	state Exp;
branches;
next	;

1.114.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.114.2.2;

1.114.2.2
date	2003.03.23.09.12.47;	author recdvst;	state Exp;
branches;
next	1.114.2.3;

1.114.2.3
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.568
log
@Save sorting directions for all GUI lists; Unified list sort initialization and click processing;
Simplified list arrow configuration interface.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "Preferences.h"
#include "emule.h"
#include "DownloadListCtrl.h"
#include "MemDC.h"
#include "TitleMenu.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "updownclient.h"
#include "opcodes.h"
#include "Details\ClientDetails.h"
#include "Details\FileDetails.h"
#include "CommentDialogLst.h"
#include "KeyboardShortcut.h"
#include "InputBox.h"
#include "IP2Country.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define DLC_DT_TEXT (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS)
#define DLC_BARUPDATE 512

BEGIN_MESSAGE_MAP(CDownloadListCtrl, CMuleListCtrl)
	ON_NOTIFY_REFLECT(LVN_ITEMACTIVATE, OnItemActivate)
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnListModified)
	ON_NOTIFY_REFLECT(LVN_INSERTITEM, OnListModified)
	ON_NOTIFY_REFLECT(LVN_DELETEITEM, OnListModified)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMDblclkDownloadlist)
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
	ON_WM_SIZE()
	ON_WM_KEYUP()
	ON_WM_KEYDOWN()
	ON_WM_KILLFOCUS()
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CDownloadListCtrl, CMuleListCtrl)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadListCtrl::CDownloadListCtrl()
{
	m_bShowSrc = false;
	SetGeneralPurposeFind(true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadListCtrl::~CDownloadListCtrl()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::Init()
{
	static const uint16 s_auIconResID[] =
	{
		IDI_DCS1,
		IDI_DCS2,
		IDI_DCS3,
		IDI_DCS4,
		IDI_DCS5,
		IDI_LISTMINUS,
		IDI_LISTNONE,
		IDI_LISTPLUS,
		IDI_RATING_NO,
		IDI_RATING_EXCELLENT,
		IDI_RATING_GOOD,
		IDI_RATING_FAIR,
		IDI_RATING_POOR,
		IDI_RATING_FAKE,
		IDI_A4AFAUTO,

		IDI_STATUS_COMPLETE,
		IDI_STATUS_COMPLETING,
		IDI_STATUS_DOWNLOADING,
		IDI_STATUS_ERRONEOUS,
		IDI_STATUS_HASHING,
		IDI_STATUS_PAUSED,
		IDI_STATUS_STALLED,
		IDI_STATUS_STOPPED,
		IDI_STATUS_WAITING,
		IDI_STATUS_WAITINGHASH
	};
	static const uint16 s_auColHdr[][2] =
	{
		{ LVCFMT_LEFT,  260 },	// DLCOL_FILENAME
		{ LVCFMT_RIGHT,  60 },	// DLCOL_SIZE
		{ LVCFMT_RIGHT,  65 },	// DLCOL_TRANSFERRED
		{ LVCFMT_RIGHT,  65 },	// DLCOL_COMPLETED
		{ LVCFMT_RIGHT,  65 },	// DLCOL_SPEED
		{ LVCFMT_LEFT,  170 },	// DLCOL_PROGRESS
		{ LVCFMT_RIGHT,  50 },	// DLCOL_NUMSOURCES
		{ LVCFMT_LEFT,   55 },	// DLCOL_PRIORITY
		{ LVCFMT_LEFT,   70 },	// DLCOL_STATUS
		{ LVCFMT_LEFT,  110 },	// DLCOL_REMAINING
		{ LVCFMT_LEFT,  110 },	// DLCOL_REMAININGTIME
		{ LVCFMT_RIGHT,  60 },	// DLCOL_ULDLRATIO
		{ LVCFMT_RIGHT,  60 },	// DLCOL_QLRATING
		{ LVCFMT_LEFT,  110 },	// DLCOL_LASTSEENCOMPLETE
		{ LVCFMT_LEFT,  220 },	// DLCOL_LASTRECEIVED
		{ LVCFMT_LEFT,  100 },	// DLCOL_CATEGORY
		{ LVCFMT_LEFT,  110 },	// DLCOL_WAITED
		{ LVCFMT_RIGHT, 100 },	// DLCOL_AVGSPEED
		{ LVCFMT_RIGHT, 100 },	// DLCOL_AVGREMTIME
		{ LVCFMT_RIGHT, 100 },	// DLCOL_ETA
		{ LVCFMT_RIGHT, 100 }	// DLCOL_AVGETA
	};

	EMULE_TRY

	CImageList		ilDummyImageList;

	ilDummyImageList.Create(1, 17, g_App.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
	SetImageList(&ilDummyImageList, LVSIL_SMALL);
	ASSERT((GetStyle() & LVS_SHAREIMAGELISTS) == 0);
	ilDummyImageList.Detach();

	SetStyle();
	SetColors();

	m_bSmartFilter = false;

	FilterNoSources();

	ModifyStyle(LVS_SINGLESEL, 0);

	memzero(m_iColumnMaxWidths, sizeof(m_iColumnMaxWidths));
//	Index of the column being measured. -1 for none.
	m_iMeasuringColumn = -1;

	for (unsigned ui = 0; ui < ARRSIZE(s_auColHdr); ui++)
		InsertColumn(ui, _T(""), static_cast<int>(s_auColHdr[ui][0]), static_cast<int>(s_auColHdr[ui][1]));

	m_imageList.Create(16, 16, g_App.m_iDfltImageListColorFlags|ILC_MASK, ARRSIZE(s_auIconResID), 0);
	m_imageList.SetBkColor(CLR_NONE);
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ARRSIZE(s_auIconResID));

	Localize();

	LoadSettings(CPreferences::TABLE_DOWNLOAD);

//	Sort dialog
	if (g_App.m_pPrefs->DoUseSort())
	{
		SortInit(DL_OVERRIDESORT);
	}
	else
	{
	//	Use preferred sort order from preferences
		int		iSortCode = g_App.m_pPrefs->GetColumnSortCode(CPreferences::TABLE_DOWNLOAD);
		uint32	dwSortCode = (iSortCode & 0xFF) | (MLC_DONTSORT << 24) |
			((g_App.m_pPrefs->GetColumnSortCode(CPreferences::TABLE_DOWNLOAD2) & 0xFF) << 16);

		SetSortArrow(iSortCode & MLC_COLUMNMASK, (iSortCode & MLC_SORTDESC) ? 0 : 1);
		SortItems(SortProc, dwSortCode);
	}

	m_iCurTabIndex = 0; // All tab
	m_eCurTabCat = CAT_ALL;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::Localize()
{
	static const uint16 s_auResTbl[] =
	{
		IDS_DL_FILENAME,
		IDS_DL_SIZE,
		IDS_DL_TRANSF,
		IDS_SF_COMPLETED,
		IDS_DL_SPEED,
		IDS_DL_PROGRESS,
		IDS_DL_SOURCES,
		IDS_PRIORITY,
		IDS_STATUS,
		IDS_DL_REMAINS,
		IDS_DLCOL_REMAININGTIME,
		IDS_DL_ULDL,
		IDS_RATING,
		IDS_LASTSEENCOMPLETE,
		IDS_LASTRECEPTION,
		IDS_CAT,
		IDS_WAITED,
		IDS_DLCOL_AVGSPEED,
		IDS_DLCOL_AVGREMTIME,
		IDS_DLCOL_ETA,
		IDS_DLCOL_AVGETA
	};

	EMULE_TRY

	if (GetSafeHwnd())
	{
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
		CString		strRes;
		HDITEM		hdi;

		hdi.mask = HDI_TEXT;

		for (unsigned ui = 0; ui < ARRSIZE(s_auResTbl); ui++)
		{
			::GetResString(&strRes, static_cast<UINT>(s_auResTbl[ui]));
			hdi.pszText = const_cast<LPTSTR>(strRes.GetString());
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
		}

		ShowFilesCount();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AddFileItem() adds part file item 'pFileItem' to the display it if it should be visible.
void CDownloadListCtrl::AddFileItem(CPartFileDLItem *pFileItem)
{
	EMULE_TRY

//	TODO: Make this asynchronous

//	If the file belongs to the currently displayed category, add it to the end of the list control (emule .30a)
	if (CCat::FileBelongsToGivenCat(pFileItem->GetFile(),m_eCurTabCat))
	{
		ListInsertFileItem(pFileItem, GetItemCount());
	}

	if (m_bSmartFilter)
	{
		AutoSetSourceFilters(pFileItem);
	}

	ShowFilesCount();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AddSourceItem() adds source item 'pSourceItem' to the display it if it should be visible.
void CDownloadListCtrl::AddSourceItem(CSourceDLItem *pSourceItem)
{
	EMULE_TRY

	CPartFileDLItem	   *pParentFileItem = pSourceItem->GetParentFileItem();

	if (pParentFileItem == NULL || !pParentFileItem->m_bSrcsAreVisible)
		return;

//
//	Find the position of the next file item displayed or the end of the list
//
	int		iItem = ListGetFileItemIndex(pParentFileItem);
	int		iNumListItems = GetItemCount();

	if (iItem < 0)
		iItem = 0;
	while (iItem+1 < iNumListItems)
	{
		CPartFileDLItem	   *pFileItem = dynamic_cast<CPartFileDLItem*>(ListGetItemAt(iItem+1));

		if (pFileItem != NULL)
			break;
		iItem++;
	}

	if (!IsSourceFiltered(pSourceItem))
		ListInsertSourceItem(pSourceItem,iItem+1);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RemoveSourceItem() removes the source item 'pSourceItem' from the list. If an error occurs,
//		the method does nothing.
void CDownloadListCtrl::RemoveSourceItem(CSourceDLItem *pSourceItem)
{
	EMULE_TRY

	if (pSourceItem != NULL && ::IsWindow(GetSafeHwnd()) && g_App.m_pMDlg->IsRunning())
	{
		const int		iItem = ListGetSourceItemIndex(pSourceItem);

		if (iItem != -1)
		{
			pSourceItem->SetVisibility(false);
			DeleteItem(iItem);
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsSourceFiltered() returns true if the spec'd source should be removed
//		from the DownloadList window according to the current source filter.
bool CDownloadListCtrl::IsSourceFiltered(CSourceDLItem *pSourceItem)
{
#ifdef OLD_SOCKETS_ENABLED
	bool				bShowNewSource = true;
	CPartFileDLItem	   *pFileItem = pSourceItem->GetParentFileItem();

//	If the source item's parent part file isn't expanded, don't show it.
	if (!pFileItem->m_bSrcsAreVisible)
	{
		bShowNewSource = false;
	}
	else
	{
		CUpDownClient	*pSource = pSourceItem->GetSource();

		EnumDLQState	ds = pSource->GetDownloadState();

	//	If we're filtering out uploading sources and the source is uploading...
		if ( !(pFileItem->m_bShowUploadingSources && m_bShowUploadingSources)
		  && ds == DS_DOWNLOADING )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources which have us on their upload queues
	//		and the source has issued us an upload queue rank...
		if ( !(pFileItem->m_bShowOnQueueSources && m_bShowOnQueueSources)
		  && ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() > 0 )
		{
			bShowNewSource = false;
		}
	//	If we're NOT filtering out sources which has us on their upload queues
	//		but we're smart filtering and the source has issued us an upload
	//		rank above the preference...
		if ( m_bSmartFilter
		  && (pFileItem->m_bShowOnQueueSources && m_bShowOnQueueSources)
		  && ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() > g_App.m_pPrefs->GetSmartFilterMaxQueueRank())
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources which report a full upload queue
	//		and the source returned 0 for our upload queue rank...
		if ( !(pFileItem->m_bShowFullQueueSources && m_bShowFullQueueSources)
		  && ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() == 0 )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources that are connected and this source is connected...
		if ( !(pFileItem->m_bShowConnectedSources && m_bShowConnectedSources)
		  && ds == DS_CONNECTED)
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources that are connecting and this source is connecting or connecting via server...
		if ( !(pFileItem->m_bShowConnectingSources && m_bShowConnectingSources)
		  && (ds == DS_CONNECTING || ds == DS_WAITCALLBACK) )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources with no needed parts and this source has
	//		no needed parts...
		if ( !(pFileItem->m_bShowNNPSources && m_bShowNNPSources)
		  && ds == DS_NONEEDEDPARTS )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources we couldn't connect to because we didn't
	//		have a free connection and that's the case for this source...
		if ( !(pFileItem->m_bShowWaitForFileReqSources && m_bShowWaitForFileReqSources)
		  && ds == DS_WAIT_FOR_FILE_REQUEST )
		{
			bShowNewSource = false;
		}
	//	If we have a Low ID and we're filtering out sources with a Low ID and
	//		this source does...
		if ( !(pFileItem->m_bShowLowToLowIDSources && m_bShowLowToLowIDSources)
		  && ds == DS_LOWTOLOWID )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out LowID client on another server
		if ( !(pFileItem->m_bShowLowIDOnOtherSrvSources && m_bShowLowIDOnOtherSrvSources)
		  && ds == DS_LOWID_ON_OTHER_SERVER )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out banned clients and this source has been banned, i.e. we banned him in
	//	our upload queue...
		if ( !(pFileItem->m_bShowBannedSources && m_bShowBannedSources)
		  && pSource->IsBanned() )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources with an error condition (?) and this
	//		source has one...
		if ( !(pFileItem->m_bShowErrorSources && m_bShowErrorSources)
		  && ds == DS_ERROR )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out sources for which we have an active request for
	//		a file other than the source item's parent...
		if ( !(pFileItem->m_bShowA4AFSources && m_bShowA4AFSources)
		  && pSourceItem->IsAskedForAnotherFile() )
		{
			bShowNewSource = false;
		}
	//	If we're filtering out unknown (?) sources and this source is unknown...
		if ( !(pFileItem->m_bShowUnknownSources && m_bShowUnknownSources)
		  && ds == DS_NONE )
		{
			bShowNewSource = false;
		}
	}

	return !bShowNewSource;
#else
	return false;
#endif //OLD_SOCKETS_ENABLED
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::RemoveFileItem(CPartFileDLItem *pFileItem)
{
	EMULE_TRY

	if (!g_App.m_pMDlg->IsRunning() || pFileItem == NULL)
		return;

//	If the InfoList is displaying this file...
	if ( g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_FILE
	  && g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetFile() == pFileItem->GetFile() )
	{
	//	...Set it to display nothing
		g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
	}

	int			iFilePos = ListGetFileItemIndex(pFileItem);

//	Remove the file item from the list
	if (iFilePos != -1)
	{
		pFileItem->SetVisibility(false);
		DeleteItem(iFilePos);
	}

	ShowFilesCount();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::UpdateSourceItem(CSourceDLItem *pSourceItem)
{
	EMULE_TRY

	if (pSourceItem != NULL && ::IsWindow(GetSafeHwnd()) && g_App.m_pMDlg->IsRunning())
	{
		int		iSourcePos = ListGetSourceItemIndex(pSourceItem);

		if (iSourcePos != -1)
		{
			bool	bDontUpdate = false;

			if (pSourceItem != NULL && IsSourceFiltered(pSourceItem))
			{
				HideSourceItem(pSourceItem);
				bDontUpdate = true;
			}
			if (!bDontUpdate)
			{
				if (pSourceItem != NULL)
					pSourceItem->ResetUpdateTimer();
				Update(iSourcePos);
			}
		}
	//	If we didn't find the source item in the list...
		else
		{
		//	If it's a source, check to see if it should be shown now
			if (pSourceItem != NULL)
			{
				if (!IsSourceFiltered(pSourceItem))
					ShowSourceItem(pSourceItem);
			}
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::UpdateFileItems()
{
	CDownloadList::PartFileItemVector	*pvecFileItems = g_App.m_pDownloadList->GetFileItems();

	for (uint32 i = 0; i < pvecFileItems->size(); i++)
	{
		UpdateFileItem((*pvecFileItems)[i]);
	}

	delete pvecFileItems;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::UpdateSourceItems(CPartFileDLItem *pFileItem/*=NULL*/)
{
	CDownloadList::SourceItemVector	*pvecSourceItems;

//	If no part file item was specified, update all source items
	if (pFileItem == NULL)
		pvecSourceItems = g_App.m_pDownloadList->GetSourceItems();
	else
		pvecSourceItems = pFileItem->GetSources();

	for (uint32 i = 0; i < pvecSourceItems->size(); i++)
		UpdateSourceItem((*pvecSourceItems)[i]);

	delete pvecSourceItems;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::UpdateFileItem(CPartFileDLItem *pFileItem)
{
	EMULE_TRY

//	MOREVIT - The "running" check is probably superfluous here now that we're checking the window
//	If the file item isn't null and the window hasn't been destroyed (e.g. during shutdown)...
	if (pFileItem != NULL && ::IsWindow(GetSafeHwnd()) && g_App.m_pMDlg->IsRunning())
	{
		int		iFilePos = ListGetFileItemIndex(pFileItem);

	//	If we found the file item in the list...
		if (iFilePos != -1)
		{
			pFileItem->ResetUpdateTimer();
			Update(iFilePos);
			if (m_bSmartFilter)
				AutoSetSourceFilters(pFileItem);
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	DrawFileItem() draws column 'nColumn' of the list row for part file 'pFileItem' in the
//		rectangle 'lpRect' in device context 'dc'. If 'm_iMeasuringColumn' is nonzero then
//		the width of drawing is measured and 'm_iColumnMaxWidths' is updated for that column
//		but nothing is drawn.
void CDownloadListCtrl::DrawFileItem(CDC *dc, int nColumn, LPRECT lpRect, CPartFileDLItem *pFileItem)
{
//	TODO: Put these constants somewhere sensible!
#define OFFSET_PLUSMINUS	18
#define OFFSET_STATUSICON	18
#define OFFSET_FILETYPEICON	19
#define OFFSET_RATINGICON	10
	EMULE_TRY

	if (IsColumnHidden(nColumn))
		return;

	RECT	r = *lpRect;
	int		iPadding = dc->GetTextExtent(_T(" "), 1).cx * 2;
	int		iWidth = (3 * iPadding)/2;
	bool	bMeasuring = (m_iMeasuringColumn >= 0);
	UINT	iCalcFlag = (bMeasuring) ? ((DLC_DT_TEXT | DT_CALCRECT) & ~DT_END_ELLIPSIS) : DLC_DT_TEXT;

	if (IsRightToLeftLanguage())
		iCalcFlag |= DT_RTLREADING;

	if (lpRect->left < lpRect->right)
	{
		CString			buffer;
		CPartFile		*pPartFile = pFileItem->GetFile();

		switch (nColumn)
		{
			case DLCOL_FILENAME:
			{
				POINT	point = { r.left, r.top + 1 };
				int		iIcon;
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

			//	Draw the old-style +/- box
				iIcon = ( pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0
						  &&  !(eFileStatus == PS_COMPLETING || eFileStatus == PS_COMPLETE || eFileStatus == PS_STOPPED) )
					  ? (pFileItem->m_bSrcsAreVisible ? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS)
					  : DL_ICON_LISTNONE;
				if (!bMeasuring)
					m_imageList.Draw(dc, iIcon, point, ILD_NORMAL);
				else
					iWidth += OFFSET_PLUSMINUS;
				r.left += OFFSET_PLUSMINUS;
				point.x += OFFSET_PLUSMINUS;

				if (g_App.m_pPrefs->ShowFullFileStatusIcons())
				{
				//	Draw the status icon
					switch (pPartFile->GetPartFileStatusID())
					{
						case PS_COMPLETING:
							iIcon = DL_ICON_STATUS_COMPLETING;
							break;
						case PS_COMPLETE:
							iIcon = DL_ICON_STATUS_COMPLETE;
							break;
						case PS_DOWNLOADING:
							iIcon = DL_ICON_STATUS_DOWNLOADING;
							break;
						case PS_WAITINGFORSOURCE:
							iIcon = DL_ICON_STATUS_WAITING;
							break;
						case PS_WAITINGFORHASH:
							iIcon = DL_ICON_STATUS_WAITINGHASH;
							break;
						case PS_HASHING:
							iIcon = DL_ICON_STATUS_HASHING;
							break;
						case PS_PAUSED:
							iIcon = DL_ICON_STATUS_PAUSED;
							break;
						case PS_STALLED:
							iIcon = DL_ICON_STATUS_STALLED;
							break;
						case PS_STOPPED:
							iIcon = DL_ICON_STATUS_STOPPED;
							break;
						case PS_ERROR:
						default:
							iIcon = DL_ICON_STATUS_ERRONEOUS;
							break;
					}
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, point, ILD_NORMAL);
					else
						iWidth += OFFSET_STATUSICON;
					r.left += OFFSET_STATUSICON;

				//	Show that a file is A4AF auto
					if (pPartFile == g_App.m_pDownloadQueue->GetA4AFAutoFile() && !bMeasuring)
						m_imageList.Draw(dc, DL_ICON_A4AFAUTO, point, ILD_TRANSPARENT);
				}

			//	File Type
				if (g_App.m_pPrefs->ShowFileTypeIcon())
				{
					if (!bMeasuring)
					{
						int		iImage = g_App.GetFileTypeSystemImageIdx(pPartFile->GetFileName());

						if (g_App.GetSystemImageList() != NULL)
							::ImageList_Draw(g_App.GetSystemImageList(), iImage, dc->GetSafeHdc(), r.left, r.top+1, ILD_TRANSPARENT);
						r.left += OFFSET_FILETYPEICON;
					}
					else
						iWidth += OFFSET_FILETYPEICON;
				}

			//	Comments/ratings
				if (g_App.m_pPrefs->ShowRatingIcons())
				{
					if ((pPartFile->HasComment() || pPartFile->HasRating()) && !bMeasuring)
					{
						iIcon = DL_ICON_RATING_NO;

						if (pPartFile->HasRating())
						{
							switch (pPartFile->GetRating())
							{
								case PF_RATING_NONE:
								default:
									iIcon = DL_ICON_RATING_NO;
									break;
								case PF_RATING_FAKE:
									iIcon = DL_ICON_RATING_FAKE;
									break;
								case PF_RATING_POOR:
									iIcon = DL_ICON_RATING_POOR;
									break;
								case PF_RATING_GOOD:
									iIcon = DL_ICON_RATING_GOOD;
									break;
								case PF_RATING_FAIR:
									iIcon = DL_ICON_RATING_FAIR;
									break;
								case PF_RATING_EXCELLENT:
									iIcon = DL_ICON_RATING_EXCELLENT;
									break;
							}
						}
						m_imageList.Draw(dc, iIcon, CPoint(r.left - 4, r.top + 2), ILD_NORMAL);
					}
					r.left += OFFSET_RATINGICON;
					iWidth += OFFSET_RATINGICON;
				}

			//	Finally, the file title. First set the color
				COLORREF	crOldTxtColor;
				COLORREF	cr = (pPartFile->IsFakesDotRar() ? g_App.m_pPrefs->GetFakeListDownloadColor() : CCat::GetCatColorByID(pPartFile->GetCatID()));
				bool		bRestoreColor = true;	// Not restoring the color _may_ make the rest of the
													//	row the same color. Don't count on it.
				cr = (cr > 0) ? cr : (::GetSysColor(COLOR_WINDOWTEXT));

				if ((eFileStatus == PS_PAUSED) || (eFileStatus == PS_STOPPED))
				{
					if (g_App.m_pPrefs->ShowPausedGray())
					{
						cr = ::GetSysColor(COLOR_GRAYTEXT);
						bRestoreColor = false;
					}
					else
					{
					//	TODO: This might be worth pulling out into its own function (as I see others have already done)
						uint32	dwR, dwG, dwB, dwGray = 0x60;
						const uint32	dwGrayBuffer = 0x40, dwGrayLimit = 0xFF - dwGrayBuffer;

					//	"gray" the color
						dwR = GetRValue(cr);
						dwB = GetBValue(cr);
						dwG = GetGValue(cr);

					//	Make sure we don't wash the color out TOO much
						if (dwR + dwGray >= dwGrayLimit && dwB + dwGray >= dwGrayLimit && dwG + dwGray >= dwGrayLimit)
							dwGray -= dwGrayBuffer;
						if ((dwR += dwGray)> 0xFF)
							dwR = 0xFF;
						if ((dwB += dwGray) > 0xFF)
							dwB = 0xFF;
						if ((dwG += dwGray) > 0xFF)
							dwG = 0xFF;

						cr = RGB(dwR, dwG, dwB);
					}
				}

				crOldTxtColor = dc->SetTextColor(cr);

			//	Draw the file name
				buffer = pPartFile->GetFileName();
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;

			//	Restore the original color
				if (bRestoreColor)
					dc->SetTextColor(crOldTxtColor);
				break;
			}
			case DLCOL_SIZE:
				buffer = CastItoXBytes(pPartFile->GetFileSize());
				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_TRANSFERRED:
				buffer = CastItoXBytes(pPartFile->GetTransferred());
				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_COMPLETED:
				buffer = CastItoXBytes(pPartFile->GetCompletedSize());
				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_SPEED:
			{
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					uint32		dwAvgDataRate, dwDataRate = pPartFile->GetDataRate();

					if (dwDataRate > 10)
						buffer.Format(_T("%.1f"), dwDataRate / 1024.0f);
					if (g_App.m_pPrefs->GetShowAverageDataRate())
					{
						dwAvgDataRate = pPartFile->GetAvgDataRate(true);
						if (dwAvgDataRate > 10)
							buffer.AppendFormat(_T(" (%.2f)"), dwAvgDataRate / 1024.0f);
					}
				}
				else if (g_App.m_pPrefs->GetShowAverageDataRate())
					buffer.Format(_T("[%.2f]"), pPartFile->GetAvgDataRate(false)/1024.0f);

				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring && buffer.GetLength() != 0)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_PROGRESS:
			{
				if (!bMeasuring)
				{
					r.bottom--;
					r.top++;

					int		iBarWidth = r.right - r.left;
					int		iBarHeight = r.bottom - r.top;

					if (pFileItem->GetBitmap() == (HBITMAP)NULL)
						VERIFY(pFileItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL));

					CDC			cdcStatus;
					HGDIOBJ		hOldBitmap;

					cdcStatus.CreateCompatibleDC(dc);

					int		cx = pFileItem->GetBitmap().GetBitmapDimension().cx;
					DWORD	dwTicks = GetTickCount();

					if (pFileItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iBarWidth || pFileItem->GetUpdateTimer() != 0)
					{
						pFileItem->GetBitmap().DeleteObject();
						pFileItem->GetBitmap().CreateCompatibleBitmap(dc,  iBarWidth, iBarHeight);
						pFileItem->GetBitmap().SetBitmapDimension(iBarWidth,  iBarHeight);
						hOldBitmap = cdcStatus.SelectObject(pFileItem->GetBitmap());

						RECT rec_status;
						rec_status.left = 0;
						rec_status.top = 0;
						rec_status.bottom = iBarHeight;
						rec_status.right = iBarWidth;
						pPartFile->DrawStatusBar(&cdcStatus,  &rec_status, g_App.m_pPrefs->UseFlatBar());

						pFileItem->SetUpdateTimer(dwTicks + (rand() % 128));
					}
					else
						hOldBitmap = cdcStatus.SelectObject(pFileItem->GetBitmap());

					dc->BitBlt(r.left, r.top, iBarWidth, iBarHeight, &cdcStatus, 0, 0, SRCCOPY);
					cdcStatus.SelectObject(hOldBitmap);

					if (g_App.m_pPrefs->GetUseDwlPercentage())
					{
					//	BEGIN Display percent in progress bar
						COLORREF	crOld = dc->SetTextColor(RGB(255,255,255));
						int			iOldBkMode = dc->SetBkMode(TRANSPARENT);
						double		dblPercentCompleted = floor(pPartFile->GetPercentCompleted() * 10.0) / 10.0;
						int			iOldLeft = r.left;

						buffer.Format( (floor(dblPercentCompleted) == dblPercentCompleted) ?
							_T("%.f%%") : _T("%.1f%%"), dblPercentCompleted);
						r.left += ((iBarWidth - dc->GetTextExtent(buffer).cx) / 2);

						EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

						if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
							r.top += (g_App.m_pPrefs->UseFlatBar()) ? 3 : 2; // Just a little down

						dc->DrawText(buffer, &r, DLC_DT_TEXT);
						r.left = iOldLeft;
						dc->SetBkMode(iOldBkMode);
						dc->SetTextColor(crOld);
					}
				}
			//	Since the progress bar drawing is conformant, we'll just hardcode a reasonable width
				else
					iWidth += 300;
				break;
			}
			case DLCOL_NUMSOURCES:
			{
				uint32		dwSourcesCount = static_cast<uint32>(pPartFile->GetSourceCount());
				uint32		dwNotCurrentSourcesCount = pPartFile->GetNotCurrentSourcesCount();

				if (dwNotCurrentSourcesCount != 0)
					buffer.Format(_T("%u/%u"), dwSourcesCount - dwNotCurrentSourcesCount, dwSourcesCount);
				else
					buffer.Format(_T("%u"), dwSourcesCount);

				uint32		dwA4AFSourcesCount = static_cast<uint32>(pPartFile->GetSrcA4AFCount());

				if (g_App.m_pPrefs->IsA4AFCountEnabled() && (dwA4AFSourcesCount != 0))
				{
					buffer.AppendFormat(_T("+%u"), dwA4AFSourcesCount);
				}
				buffer.AppendFormat(_T(" (%u)"), pPartFile->GetTransferringSrcCount());

				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_PRIORITY:
			{
				UINT		dwResStrId;

				if (pPartFile->IsAutoPrioritized())
				{
					pPartFile->UpdateDownloadAutoPriority();

					switch (pPartFile->GetPriority())
					{
						default:
						case PR_LOW:
							dwResStrId = IDS_PRIOAUTOLOW;
							break;
						case PR_NORMAL:
							dwResStrId = IDS_PRIOAUTONORMAL;
							break;
						case PR_HIGH:
							dwResStrId = IDS_PRIOAUTOHIGH;
							break;
					}
				}
				else
				{
					switch (pPartFile->GetPriority())
					{
						default:
						case PR_LOW:
							dwResStrId = IDS_PRIOLOW;
							break;
						case PR_NORMAL:
							dwResStrId = IDS_PRIONORMAL;
							break;
						case PR_HIGH:
							dwResStrId = IDS_PRIOHIGH;
							break;
					}
				}
				GetResString(&buffer, dwResStrId);
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_STATUS:
				buffer = pPartFile->GetPartFileStatus();
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_REMAINING:
			{
				uint64	qwRemaining = pPartFile->GetFileSize() - pPartFile->GetCompletedSize();

				buffer = CastItoXBytes(qwRemaining);

				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					double		dRemainingPercent = 100.1 - pPartFile->GetPercentCompleted();

					if (dRemainingPercent > 100.0)
						dRemainingPercent = 100.0;
					else if (qwRemaining == 0)
						dRemainingPercent = 0.0;

					dRemainingPercent = floor(dRemainingPercent * 10.0) / 10.0;

					buffer.AppendFormat( (floor(dRemainingPercent) == dRemainingPercent) ?
						_T(" [%.f%%]") : _T(" [%.1f%%]"), dRemainingPercent );
				}
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_REMAININGTIME:
			{
				sint32		restTime;
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					restTime = pPartFile->GetTimeRemaining();
					buffer.Format(_T("%s"), CastSecondsToHM(restTime));

					if (g_App.m_pPrefs->GetShowAverageDataRate())
					{
						restTime = pPartFile->GetTimeRemaining(true);
						buffer.AppendFormat(_T(" (%s)"), CastSecondsToHM(restTime));
					}
				}
				else
				{
					restTime = static_cast<sint32>(pPartFile->GetFlushTimeSpan().GetTotalSeconds());
					buffer.Format(_T("[%s / %s]"), CastItoXBytes(pPartFile->GetSessionTransferred()), CastSecondsToHM(restTime));
				}
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_LASTSEENCOMPLETE:
				if (pPartFile->lastseencomplete == NULL)
				{
					GetResString(&buffer, IDS_NEVER);
					dc->DrawText(buffer, &r, iCalcFlag);
				}
				else
				{
					CTime			ctTime(pPartFile->lastseencomplete);
					SYSTEMTIME		st;

					ctTime.GetAsSystemTime(st);
					COleDateTime    odtTime(st);
					dc->DrawText(odtTime.Format(_T("%c")), &r, iCalcFlag);
				}
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_LASTRECEIVED:
				if (pPartFile->GetTransferred() == 0)
				{
					GetResString(&buffer, IDS_NEVER);
					dc->DrawText(buffer, &r, iCalcFlag);
				}
				else
				{
					CTime			ctTime(pPartFile->GetLastDownTransfer());
					SYSTEMTIME		st;

					ctTime.GetAsSystemTime(st);
					COleDateTime    odtTime(st);
					dc->DrawText(odtTime.Format(_T("%c")), &r, iCalcFlag);
				}
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_CATEGORY:
				if (pPartFile->GetCatID() == 0)
					GetResString(&buffer, IDS_CAT_UNCATEGORIZED);
				else
				{
					CCat	*pCat = CCat::GetCatByID(pPartFile->GetCatID());

					if (pCat != NULL)
						buffer = pCat->GetTitle();
					else
					{
						pPartFile->SetCatID(CAT_NONE);
						GetResString(&buffer, IDS_CAT_UNCATEGORIZED);
					}
				}
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_WAITED:
			{
				CTimeSpan	ts = CTime::GetCurrentTime() - pPartFile->GetLastDownTransfer();
				uint32		dwWaitedSecs = static_cast<uint32>(ts.GetTotalSeconds());

				if (dwWaitedSecs >= 15)
					buffer = ::CastSecondsToHM(dwWaitedSecs);
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_AVGSPEED:
			{
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					uint32		iDataRate = pPartFile->GetAvgDataRate(true);

					if (iDataRate > 10)
						buffer.Format(_T("%.2f"), iDataRate / 1024.0f);
				}
				else
					buffer.Format(_T("%.2f"), pPartFile->GetAvgDataRate(false) / 1024.0f);
				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring && buffer.GetLength() != 0)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_AVGREMTIME:
			{
				sint32		iRemainingTime;
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					iRemainingTime = pPartFile->GetTimeRemaining(true);
					buffer.AppendFormat(_T("%s"), CastSecondsToHM(iRemainingTime));
				}
				dc->DrawText(buffer, &r, DT_RIGHT | iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_ETA:
			{
				sint32		iRemainingTime;
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					iRemainingTime = pPartFile->GetTimeRemaining();

					if (iRemainingTime != -1)
					{
						CTime			ctTime;
						SYSTEMTIME		st;

						ctTime = CTime::GetCurrentTime();
						ctTime += CTimeSpan(iRemainingTime);
						ctTime.GetAsSystemTime(st);

						COleDateTime	odtTime(st);

						dc->DrawText(odtTime.Format(_T("%c")), &r, DT_RIGHT | iCalcFlag);
						if (bMeasuring)
							iWidth += r.right - r.left + 1;
					}
				}
				else
					dc->DrawText(buffer, &r, iCalcFlag);
				break;
			}
			case DLCOL_AVGETA:
			{
				sint32		iRemainingTime;
				EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

				if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
				{
					iRemainingTime = pPartFile->GetTimeRemaining(true);

					if (iRemainingTime != -1)
					{
						CTime			ctTime;
						SYSTEMTIME		st;

						ctTime = CTime::GetCurrentTime();
						ctTime += CTimeSpan(iRemainingTime);
						ctTime.GetAsSystemTime(st);

						COleDateTime	odtTime(st);

						dc->DrawText(odtTime.Format(_T("%c")), &r, DT_RIGHT | iCalcFlag);
						if (bMeasuring)
							iWidth += r.right - r.left + 1;
					}
				}
				else
					dc->DrawText(buffer, &r, iCalcFlag);
				break;
			}
			default:
				break;
		}
		if (bMeasuring)
		{
		//	Pin the column widths at some reasonable value
			if (iWidth < 40 && iWidth != 0)
				iWidth = 40;
			if (iWidth > m_iColumnMaxWidths[m_iMeasuringColumn])
				m_iColumnMaxWidths[m_iMeasuringColumn] = iWidth;
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	DrawSourceItem() draws column 'nColumn' of the list row for source 'pSourceItem' in the
//		rectangle 'lpRect' in device context 'dc'. If 'm_iMeasuringColumn' is nonzero then
//		the width of drawing is measured and 'm_iColumnMaxWidths' is updated for that column
//		but nothing is drawn.
void CDownloadListCtrl::DrawSourceItem(CDC *dc, int nColumn, LPRECT lpRect, CSourceDLItem *pSourceItem)
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
	if (IsColumnHidden(nColumn))
		return;

	int		iPadding = dc->GetTextExtent(_T(" "), 1).cx * 2;
	int		iWidth = (3 * iPadding)/2;
	bool	bMeasuring = (m_iMeasuringColumn >= 0);
	UINT	iCalcFlag = (bMeasuring) ? ((DLC_DT_TEXT | DT_CALCRECT) & ~DT_END_ELLIPSIS) : DLC_DT_TEXT;

	if (lpRect->left < lpRect->right)
	{
		CString				buffer;
		CUpDownClient	   *pSource = pSourceItem->GetSource();
		CString				sDownloadState;
		try
		{
			sDownloadState = pSource->GetDownloadStateAsString();
		}
		catch(...)
		{
		}
		EnumDLQState	eDownloadState = pSource->GetDownloadState();
		CString			sClientName;

		try
		{
			sClientName = pSource->GetUserName();
		}
		catch(...)
		{
		}
		uint32				nTransferredDown = pSource->GetTransferredDown();
		bool				bCredits = pSource->m_pCredits != NULL && pSource->m_pCredits != (CClientCredits*)-1;
		bool				bIsA4AF = pSourceItem->IsAskedForAnotherFile();
		RECT				r = *lpRect;

 		CString		status;

		switch (nColumn)
		{
			case DLCOL_FILENAME:
			{
				RECT			r2 = r;

				r2.left += OFFSET_PLUSMINUS;
				iWidth += OFFSET_PLUSMINUS;
				POINT		point = {r2.left, r2.top + 1};

				if (!bMeasuring)
				{
					if (!bIsA4AF)
					{
						switch (eDownloadState)
						{
							case DS_CONNECTING:
							case DS_CONNECTED:
							case DS_WAITCALLBACK:
							case DS_WAIT_FOR_FILE_REQUEST:
								m_imageList.Draw(dc, DL_ICON_DCS3, point, ILD_NORMAL);
								break;
							case DS_ONQUEUE:
							case DS_LOWID_ON_OTHER_SERVER:
								m_imageList.Draw(dc, DL_ICON_DCS2, point, ILD_NORMAL);
								break;
							case DS_DOWNLOADING:
							case DS_REQHASHSET:
								m_imageList.Draw(dc, DL_ICON_DCS1, point, ILD_NORMAL);
								break;
							case DS_NONEEDEDPARTS:
							case DS_LOWTOLOWID:
								m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL);
								break;
							default:
								m_imageList.Draw(dc, DL_ICON_DCS5, point, ILD_NORMAL);
						}
					}
					else
					{
						m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL);
						if (g_App.m_pPrefs->IsA4AFStringEnabled())
						{
							try
							{
								status = pSource->m_pReqPartFile->GetFileName();
							}
							catch(...)
							{
							}
						}
						else
							GetResString(&status, IDS_ASKED4ANOTHERFILE);
					}
				}
				r2.left += 20;
				point.x += 20;
				iWidth += 20;

				if (!bMeasuring)
				{
					int		iImgLstIdx = CLIENT_IMGLST_PLAIN;

				//	Select corresponding image list depending on client properties
					if (pSource->IsBanned())
						iImgLstIdx = CLIENT_IMGLST_BANNED;
					else if (pSource->IsFriend())
						iImgLstIdx = CLIENT_IMGLST_FRIEND;
					else if (pSource->GetRemoteBaseModifier() >= 1.1)
						iImgLstIdx = CLIENT_IMGLST_CREDITDOWN;

				//	Display Client icon
					g_App.m_pMDlg->m_clientImgLists[iImgLstIdx].Draw(dc, pSource->GetClientIconIndex(), point, ILD_NORMAL);

					if (g_App.m_pPrefs->ShowRatingIcons() && !g_App.m_pIP2Country->ShowCountryFlag())
					{
						r2.left += OFFSET_RATINGICON;
						iWidth += OFFSET_RATINGICON;
					}
				}

				CString strBuffer1;
				if (sClientName.IsEmpty())
					strBuffer1.Format(_T("[%s]"), GetResString(IDS_UNKNOWN));
				else
					strBuffer1 = sClientName;
				if (!status.IsEmpty())
					strBuffer1.AppendFormat(_T(" (%s)"), status);

			//	Different color for A4AF sources
				COLORREF crOldTxtColor;

				if (bIsA4AF)
					crOldTxtColor = dc->SetTextColor(GetSysColor(COLOR_GRAYTEXT));

				r2.left += 20;
				iWidth += 20;
				if (g_App.m_pIP2Country->ShowCountryFlag())
				{
					point.x += 20;
					point.y += 2;
					g_App.m_pIP2Country->GetFlagImageList()->Draw(dc, pSource->GetCountryIndex(), point, ILD_NORMAL);
					r2.left += 22;
					iWidth += 22;
				}
				dc->DrawText(strBuffer1, &r2, iCalcFlag);

				if (bMeasuring)
					iWidth += r2.right - r2.left + 1;
				if (bIsA4AF)
					dc->SetTextColor(crOldTxtColor);
				break;
			}
			case DLCOL_SIZE:
				break;

			case DLCOL_TRANSFERRED:
				if (!bIsA4AF && nTransferredDown && !g_App.m_pPrefs->IsTransferredOnCompleted())
				{
					buffer = CastItoXBytes(nTransferredDown);
					dc->DrawText(buffer, &r, iCalcFlag | DT_RIGHT);
					if (bMeasuring)
						iWidth += r.right - r.left + 1;
				}
				break;

			case DLCOL_COMPLETED:
				if (!bIsA4AF && nTransferredDown && g_App.m_pPrefs->IsTransferredOnCompleted())
				{
					buffer = CastItoXBytes(nTransferredDown);
					dc->DrawText(buffer, &r, iCalcFlag | DT_RIGHT);
					if (bMeasuring)
						iWidth += r.right - r.left + 1;
				}
				break;

			case DLCOL_SPEED:
				if (!bIsA4AF)
				{
					uint32	dwDownloadDataRate = pSource->GetDownloadDataRate();

					if (dwDownloadDataRate != 0)
						buffer.Format(_T("%.1f"), dwDownloadDataRate / 1024.0);
					dc->DrawText(buffer, &r, iCalcFlag | DT_RIGHT);
					if (bMeasuring && !buffer.IsEmpty())
						iWidth += r.right - r.left + 1;
				}
				break;

			case DLCOL_PROGRESS:
			{
				if (!bMeasuring)
				{
					lpRect->bottom--;
					lpRect->top++;

					int iWidth = lpRect->right - lpRect->left;
					int iHeight = lpRect->bottom - lpRect->top;
					if (pSourceItem->GetBitmap() == (HBITMAP)NULL)
						VERIFY(pSourceItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL));
					CDC cdcStatus;
					HGDIOBJ hOldBitmap;
					cdcStatus.CreateCompatibleDC(dc);
					int cx = pSourceItem->GetBitmap().GetBitmapDimension().cx;
					DWORD dwTicks = GetTickCount();
					if (pSourceItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !pSourceItem->GetUpdateTimer())
					{
						pSourceItem->GetBitmap().DeleteObject();
						pSourceItem->GetBitmap().CreateCompatibleBitmap(dc,  iWidth, iHeight);
						pSourceItem->GetBitmap().SetBitmapDimension(iWidth,  iHeight);
						hOldBitmap = cdcStatus.SelectObject(pSourceItem->GetBitmap());

						RECT rec_status;
						rec_status.left = 0;
						rec_status.top = 0;
						rec_status.bottom = iHeight;
						rec_status.right = iWidth;
						try
						{
							pSource->DrawStatusBar(&cdcStatus,  &rec_status,(pSourceItem->IsAskedForAnotherFile()), g_App.m_pPrefs->UseFlatBar());
						}
						catch(...)
						{
						//	in case client has been deleted meanwhile
						}

						pSourceItem->SetUpdateTimer(dwTicks + (rand() % 128));
					} else
						hOldBitmap = cdcStatus.SelectObject(pSourceItem->GetBitmap());

					dc->BitBlt(lpRect->left, lpRect->top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY);
					cdcStatus.SelectObject(hOldBitmap);

					lpRect->bottom++;
					lpRect->top--;
				}
				else
					iWidth = 300;
				break;
			}
			case DLCOL_NUMSOURCES:
				buffer = pSource->GetFullSoftVersionString();
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bMeasuring)
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_PRIORITY:
			{
				bool		bIsColorChanged = false;
				uint32		dwRemoteQueueRank = static_cast<uint32>(pSource->GetRemoteQueueRank());

				if ( pSource->IsEmuleClient() && !pSourceItem->IsAskedForAnotherFile() &&
					(eDownloadState == DS_ONQUEUE || eDownloadState == DS_LOWID_ON_OTHER_SERVER) )
				{
					if (dwRemoteQueueRank == 0)
					{
						GetResString(&buffer, IDS_QUEUEFULL);
					}
					else
					{
						int		iDifference = pSource->GetDifference();

						if (iDifference == static_cast<int>(dwRemoteQueueRank))
						{
						//	Initial QR -- just one QR was received
							buffer.Format(_T("QR: %u"), dwRemoteQueueRank);
						}
						else if (iDifference == 0)
						{
							dc->SetTextColor((COLORREF)RGB(5,65,195));
							bIsColorChanged = true;
							buffer.Format(_T("QR: %u"), dwRemoteQueueRank);
						}
						else
						{
							dc->SetTextColor((COLORREF)((iDifference < 0) ? RGB(10,160,70) : RGB(190,60,60)));
							bIsColorChanged = true;
							buffer.Format(_T("QR: %u (%+i)"), dwRemoteQueueRank, iDifference);
						}
					}
				}
				dc->DrawText(buffer, &r, iCalcFlag);
				if (bIsColorChanged)
					dc->SetTextColor(m_crWindowText);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_STATUS:
			{
				r.left += 6;

				dc->DrawText(sDownloadState, &r, iCalcFlag);
				if (bMeasuring && !sDownloadState.IsEmpty())
					iWidth += r.right - r.left + 1 + 6;
				break;
			}
			case DLCOL_REMAINING:
			{
				uint32		dwCurrPart, dwRemainingSize = pSource->GetRemainingSizeForCurrentPart(&dwCurrPart);

				if (dwRemainingSize != 0 && pSourceItem->GetParentFile() == pSource->m_pReqPartFile)
				{
					buffer.Format(_T("%u: %s"), dwCurrPart, CastItoXBytes(dwRemainingSize));
				}
				dc->DrawText(buffer, &r, iCalcFlag | DT_LEFT);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_REMAININGTIME:
			{
				uint32		dwSeconds = pSource->GetRemainingTimeForCurrentPart();

				if (dwSeconds != 0 && pSourceItem->GetParentFile() == pSource->m_pReqPartFile)
				{
					buffer = ::CastSecondsToHM(dwSeconds);
				}
				dc->DrawText(buffer, &r, iCalcFlag | DT_LEFT);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_ULDLRATIO:
				if (bCredits)
					buffer.Format(_T("%0.1f"), pSource->GetRemoteBaseModifier());
				dc->DrawText(buffer, &r, iCalcFlag | DT_RIGHT);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_QLRATING:
				if (bCredits)
					buffer.Format(_T("%u"), pSource->GetRemoteRatio());
				dc->DrawText(buffer, &r, iCalcFlag | DT_RIGHT);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;

			case DLCOL_LASTSEENCOMPLETE:
			case DLCOL_LASTRECEIVED:
			case DLCOL_CATEGORY:
				break;

			case DLCOL_WAITED:
			{
				if ( ((eDownloadState == DS_ONQUEUE) || (eDownloadState == DS_LOWID_ON_OTHER_SERVER))
					&& pSource->GetRemoteQueueRank() != 0 )
				{
					buffer = ::CastSecondsToHM(pSource->GetDLQueueWaitTime() / 1000);
				}
				else
					buffer = _T("-");

				dc->DrawText(buffer, &r, iCalcFlag | DT_RIGHT);
				if (bMeasuring && !buffer.IsEmpty())
					iWidth += r.right - r.left + 1;
				break;
			}
			case DLCOL_AVGSPEED:
			case DLCOL_AVGREMTIME:
			case DLCOL_ETA:
			case DLCOL_AVGETA:
				break;
		}
		if (bMeasuring)
		{
		//	Pin the column widths at some reasonable value
			if (iWidth < 40 && iWidth != 0)
				iWidth = 40;
			if (iWidth > m_iColumnMaxWidths[m_iMeasuringColumn])
				m_iColumnMaxWidths[m_iMeasuringColumn] = iWidth;
		}
	}
#endif //OLD_SOCKETS_ENABLED
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	EMULE_TRY

	if (!g_App.m_pMDlg->IsRunning() || !lpDrawItemStruct->itemData)
		return;

	CDC				   *odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	CMuleCtrlItem	   *pItem = reinterpret_cast<CMuleCtrlItem*>(lpDrawItemStruct->itemData);
	CPartFileDLItem	   *pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
	CSourceDLItem	   *pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
	BOOL				bCtrlFocused = ((GetFocus() == this) || (GetStyle() & LVS_SHOWSELALWAYS));
	COLORREF			crBk, crWinBk;

	crWinBk = crBk = GetBkColor();
	if (pFileItem != NULL && (lpDrawItemStruct->itemState & ODS_SELECTED))
		crBk = (bCtrlFocused) ? m_crHighlight : m_crNoHighlight;

	CMemDC			dc(odc, &lpDrawItemStruct->rcItem, crWinBk, crBk);
	CFont			*pOldFont = dc->SelectObject(GetFont());
	COLORREF		crOldTextColor = dc->SetTextColor(m_crWindowText);
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();

	RECT				cur_rec = lpDrawItemStruct->rcItem;

//	If we're just measuring...
	if (m_iMeasuringColumn >= 0)
	{
		if (pFileItem != NULL)
		{
		//	MOREVIT - This is a tough one. We REALLY ought to figure some way
		//		to separate the measuring and drawing routines but as they
		//		require largely the same code and we want to avoid duplication
		//		at all costs, there's no easy way ATM.
			DrawFileItem(dc, m_iMeasuringColumn, &cur_rec, pFileItem);
		}
		else if (pSourceItem != NULL)
		{
			DrawSourceItem(dc, m_iMeasuringColumn, &cur_rec, pSourceItem);
		}
		return;
	}

	bool		bNotLast = (lpDrawItemStruct->itemID + 1) != static_cast<ULONG>(GetItemCount());
	bool		bNotFirst = lpDrawItemStruct->itemID != 0;
	int			tree_start=0;
	int			tree_end=0;

	int			iOffset = dc->GetTextExtent(_T(" "), 1).cx * 2;
	int			iNumColumns = pHeaderCtrl->GetItemCount();

	cur_rec.right = cur_rec.left - iOffset;
	cur_rec.left += iOffset/2;

	if (pFileItem != NULL)
	{
		for (int iCurrent = 0; iCurrent < iNumColumns; iCurrent++)
		{
			int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
			int		cx = CListCtrl::GetColumnWidth(iColumn);

			if (iColumn == DLCOL_PROGRESS)
			{
				int		iNextLeft = cur_rec.left + cx;

			//	Set up tree vars
				cur_rec.left = cur_rec.right + iOffset;
				cur_rec.right = cur_rec.left + min(8, cx);
				tree_start = cur_rec.left + 1;
				tree_end = cur_rec.right;

			//	Normal column stuff
				cur_rec.left = cur_rec.right + 1;
				cur_rec.right = tree_start + cx - iOffset;
				DrawFileItem(dc, DLCOL_PROGRESS, &cur_rec, pFileItem);
				cur_rec.left = iNextLeft;
			}
			else
			{
				cur_rec.right += cx;
				DrawFileItem(dc, iColumn, &cur_rec, pFileItem);
				cur_rec.left += cx;
			}
		}
	}
	else if (pSourceItem != NULL)
	{
		for (int iCurrent = 0; iCurrent < iNumColumns; iCurrent++)
		{
			int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
			int		cx = CListCtrl::GetColumnWidth(iColumn);

			if (iColumn == DLCOL_PROGRESS)
			{
				int		iNextLeft = cur_rec.left + cx;

			//	Set up tree vars
				cur_rec.left = cur_rec.right + iOffset;
				cur_rec.right = cur_rec.left + min(8, cx);
				tree_start = cur_rec.left + 1;
				tree_end = cur_rec.right;
			//	Normal column stuff
				cur_rec.left = cur_rec.right + 1;
				cur_rec.right = tree_start + cx - iOffset;
				DrawSourceItem(dc, DLCOL_PROGRESS, &cur_rec, pSourceItem);
				cur_rec.left = iNextLeft;
			}
			else
			{
			//	Space of two columns can be used for source name
				if (iColumn == DLCOL_FILENAME)
				{
					int		iNextColumn = pHeaderCtrl->OrderToIndex(iCurrent + 1);

					if (iNextColumn == DLCOL_SIZE)
					{
						cx += CListCtrl::GetColumnWidth(iNextColumn);
						iCurrent++;
					}
				}

				cur_rec.right += cx;
				DrawSourceItem(dc, iColumn, &cur_rec, pSourceItem);
				cur_rec.left += cx;
			}
		}
	}

//	Draw rectangle around selected item(s)
	if ((lpDrawItemStruct->itemState & ODS_SELECTED) && (pFileItem != NULL))
	{
		RECT	rOutline = lpDrawItemStruct->rcItem;
		CBrush	FrmBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine);

		rOutline.left++;
		rOutline.right--;

	//	This code tries to draw correct cursor frame around several selected items;
	//	This method works incorrectly when a user selected files and later deselected something...
		if (bNotFirst && (GetItemState(lpDrawItemStruct->itemID - 1, LVIS_SELECTED)))
		{
			CMuleCtrlItem	   *pPrevItem = ListGetItemAt(lpDrawItemStruct->itemID - 1);

			if (typeid(*pPrevItem) == typeid(CPartFileDLItem))
				rOutline.top--;
		}
		if (bNotLast && (GetItemState(lpDrawItemStruct->itemID + 1, LVIS_SELECTED)))
		{
			CMuleCtrlItem	   *pNextItem = ListGetItemAt(lpDrawItemStruct->itemID + 1);

			if (typeid(*pNextItem) == typeid(CPartFileDLItem))
				rOutline.bottom++;
		}
		dc->FrameRect(&rOutline, &FrmBrush);
	}
//	Draw focus rectangle around non-highlightable items when they have the focus
	else if (((lpDrawItemStruct->itemState & ODS_FOCUS) == ODS_FOCUS) && (GetFocus() == this))
	{
		RECT	focus_rec = lpDrawItemStruct->rcItem;
		CBrush	FrmBrush(m_crNoFocusLine);

		focus_rec.left++;
		focus_rec.right--;
		dc->FrameRect(&focus_rec, &FrmBrush);
	}

//	Draw tree last so it draws over selected and focus (looks better)
	if (tree_start < tree_end)
	{
	//	Set new bounds
		RECT tree_rect;
		tree_rect.top    = lpDrawItemStruct->rcItem.top;
		tree_rect.bottom = lpDrawItemStruct->rcItem.bottom;
		tree_rect.left   = tree_start;
		tree_rect.right  = tree_end;
		dc->SetBoundsRect(&tree_rect, DCB_DISABLE);

	//	Gather some information
		CMuleCtrlItem	   *pItem2 = ListGetItemAt(lpDrawItemStruct->itemID + 1);
		CSourceDLItem	   *pSourceItem2 = dynamic_cast<CSourceDLItem*>(pItem2);

		bool hasNext = bNotLast && pSourceItem2 != NULL;
		bool isOpenRoot = hasNext && pFileItem != NULL;
		bool isChild = pSourceItem != NULL;
	//	Might as well calculate these now
		int treeCenter = tree_start + 3;
		int middle = (cur_rec.top + cur_rec.bottom + 1) / 2;

	//	Set up a new pen for drawing the tree
		CPen pn, *oldpn;
		pn.CreatePen(PS_SOLID, 1, dc->GetTextColor());
		oldpn = dc->SelectObject(&pn);

		if (isChild)
		{
		//	Draw the line to the status bar
			dc->MoveTo(tree_end, middle);
			dc->LineTo(tree_start + 3, middle);

		//	Draw the line to the child node
			if (hasNext)
			{
				dc->MoveTo(treeCenter, middle);
				dc->LineTo(treeCenter, cur_rec.bottom + 1);
			}
		}
		else if (isOpenRoot)
		{
		//	Draw circle
			RECT	circle_rec;
			CBrush	FrmBrush(dc->GetTextColor());
			COLORREF crBk = dc->GetBkColor();
			circle_rec.top    = middle - 2;
			circle_rec.bottom = middle + 3;
			circle_rec.left   = treeCenter - 2;
			circle_rec.right  = treeCenter + 3;
			dc->FrameRect(&circle_rec, &FrmBrush);
			dc->SetPixelV(circle_rec.left,      circle_rec.top,    crBk);
			dc->SetPixelV(circle_rec.right - 1, circle_rec.top,    crBk);
			dc->SetPixelV(circle_rec.left,      circle_rec.bottom - 1, crBk);
			dc->SetPixelV(circle_rec.right - 1, circle_rec.bottom - 1, crBk);
		//	Draw the line to the child node
			if (hasNext)
			{
				dc->MoveTo(treeCenter, middle + 3);
				dc->LineTo(treeCenter, cur_rec.bottom + 1);
			}
		}
	//	Draw the line back up to parent node
		if (bNotFirst && isChild)
		{
			dc->MoveTo(treeCenter, middle);
			dc->LineTo(treeCenter, cur_rec.top - 1);
		}
		dc->SelectObject(oldpn);	//	Put the old pen back
	}

//	Put the original objects back
	if (pOldFont)
		dc->SelectObject(pOldFont);
	if (crOldTextColor)
		dc->SetTextColor(crOldTextColor);
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::HideSources(CPartFile *pPartFile)
{
	EMULE_TRY

	SetRedraw(false);

//	For each item in the list control...
	for (int i = 0; i < GetItemCount();)
	{
		CMuleCtrlItem		*pItem = ListGetItemAt(i);
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

	//	If it's a source item belonging to 'pPartFile'...
		if (pSourceItem != NULL && pSourceItem->GetParentFile() == pPartFile)
		{
			pSourceItem->GetParentFileItem()->m_bSrcsAreVisible = false;
			pSourceItem->ResetUpdateTimer();
			pSourceItem->GetBitmap().DeleteObject();
			pSourceItem->SetVisibility(false);
			DeleteItem(i);
		}
		else
		{
			i++;
		}
	}
	if (m_bShowSrc)
	{
		m_bShowSrc = false;
	//	For each item in the list...
		for (int i = 0; i < GetItemCount(); i++)
		{
			CMuleCtrlItem	   *pItem = ListGetItemAt(i);

		//	If there's a source item left...
			if (typeid(*pItem) == typeid(CSourceDLItem))
			{
				m_bShowSrc = true;
				break;
			}
		}
	}
	SetRedraw(true);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnItemActivate(NMHDR *pNMHDR, LRESULT *pResult)
{
	EMULE_TRY

	LPNMITEMACTIVATE	pNMIA = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);

	ExpandCollapseItem(pNMIA->iItem, EXPAND_COLLAPSE);
	*pResult = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ExpandCollapseItem(int iItem,enum EnumExpandType expand,bool bCollapseSource)
{
	EMULE_TRY

	if (iItem == -1)
		return;

	CMuleCtrlItem	   *pItem = ListGetItemAt(iItem);
	CSourceDLItem	   *pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
	CPartFileDLItem	   *pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

	if (bCollapseSource && pSourceItem != NULL && pSourceItem->GetParentFileItem() != NULL)
	{
	//	To collapse/expand files when one of its source is selected
		CPartFileDLItem	   *pParentFileItem = pSourceItem->GetParentFileItem();

		iItem = ListGetFileItemIndex(pParentFileItem);

		if (iItem == -1)
			return;

		pFileItem = pParentFileItem;
	}

	if (pFileItem != NULL)
	{
		CPartFile		*pPartFile = pFileItem->GetFile();

		if (pPartFile == NULL)
			return;

	//	If the source branch is disabled and the parent file isn't completing...
		if (pFileItem->m_bSrcsAreVisible == false && pPartFile->GetStatus() != PS_COMPLETING)
		{
			if (expand == EXPAND_ONLY || expand == EXPAND_COLLAPSE)
			{
				m_bShowSrc = true;

				SetRedraw(false);

				pFileItem->m_bSrcsAreVisible = true;

			//	Get the sources items for this file item
				CPartFileDLItem::SourceItemVector	   *pvecSourceItems = pFileItem->GetSources();

				int		iNumSourceItems = pvecSourceItems->size();
				int		iNumAdded = 0;

				for (int i = 0; i < iNumSourceItems; i++)
				{
					if (!IsSourceFiltered((*pvecSourceItems)[i]))
					{
						iNumAdded++;
						ListInsertSourceItem((*pvecSourceItems)[i], iItem + 1);
					}
				}

				delete pvecSourceItems;

				pFileItem->m_bSrcsAreVisible = iNumAdded > 0;

				SetRedraw(true);
			}
		}
	//	If the file is currently showing sources, has no sources, or is completing...
		else
		{
			if (expand == EXPAND_COLLAPSE || expand == COLLAPSE_ONLY)
			{
				if (GetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED) != (LVIS_SELECTED | LVIS_FOCUSED))
				{
					SetItemState(iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
					SetSelectionMark(iItem);
					EnsureVisible(iItem, FALSE /*bPartialOK*/);
				}
				HideSources(pPartFile);
			}
		}

		UpdateFileItem(pFileItem);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CDownloadListCtrl::OnWndMsg(UINT iMessage,WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
	BOOL		bHandled = TRUE;

	EMULE_TRY

	switch (iMessage)
	{
		case WM_DL_REFRESH:
		{
			static DWORD		dwNextRefreshTime = 0;
			uint32		dwCurrTick = ::GetTickCount();

			if (dwCurrTick > dwNextRefreshTime)
			{
				dwNextRefreshTime = dwCurrTick + 1000;

				CDownloadList::PartFileItemVector	   *pvecDirtyFileItems = g_App.m_pDownloadList->GetDirtyFiles();

				if (pvecDirtyFileItems != NULL)
				{
					int		iNumDirtyFileItems = pvecDirtyFileItems->size();

					for (int i = 0; i < iNumDirtyFileItems; i++)
					{
						UpdateFileItem((*pvecDirtyFileItems)[i]);
					}

					delete pvecDirtyFileItems;
				}

				CDownloadList::SourceItemVector	   *pvecDirtySources = g_App.m_pDownloadList->GetDirtySources();

				if (pvecDirtySources != NULL)
				{
					int		iNumDirtySources = pvecDirtySources->size();

					for (int i = 0; i < iNumDirtySources; i++)
					{
						UpdateSourceItem((*pvecDirtySources)[i]);
					}

					delete pvecDirtySources;
				}
			}
			break;
		}
		default:
		{
			bHandled = FALSE;
			break;
		}
	}

	EMULE_CATCH

	if (!bHandled)
		bHandled = CMuleListCtrl::OnWndMsg(iMessage, wParam, lParam, pResult);

	return bHandled;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	NOPRM(pWnd);
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
	CTitleMenu		menuFile;
	CTitleMenu		menuSourceFilter;
	CMenu			menuAdvanced;
	CMenu			menuPriority;
	CMenu			menuED2K;
	CMenu			menuWeb;

//	If at least one item is selected...
	if (!ListSelectionIsEmpty())
	{
		POSITION			pos = GetFirstSelectedItemPosition();
		CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(pos)));
		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
		CPartFile			*pPartFile = NULL;

	//	If the selected item is a file...
		if (pFileItem != NULL)
			pPartFile = pFileItem->GetFile();

		if (pPartFile != NULL)
		{
		//	Switch the info list header to display the selected file.
			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_FILE, pPartFile);

		//	Create the "File" menu
			menuFile.CreatePopupMenu();
			menuFile.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));
		//	Create/build the priority sub-menu
			menuPriority.CreateMenu();

			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();
			bool		bFileDone = ((eFileStatus == PS_COMPLETE) || (eFileStatus == PS_COMPLETING));
			UINT		uFlagIfDone = MF_STRING | ((bFileDone) ? MF_GRAYED : MF_ENABLED);
			bool		bJustOne = (GetSelectedCount() == 1);

			if (!bFileDone)
			{
				bool		bTmpFlag = (bJustOne && !pPartFile->IsAutoPrioritized());

				menuPriority.AppendMenu( MF_STRING |
					((bTmpFlag && pPartFile->GetPriority() == PR_LOW) ? MF_CHECKED : MF_UNCHECKED),
					MP_PRIOLOW, GetResString(IDS_PRIOLOW) );
				menuPriority.AppendMenu( MF_STRING |
					((bTmpFlag && pPartFile->GetPriority() == PR_NORMAL) ? MF_CHECKED : MF_UNCHECKED),
					MP_PRIONORMAL, GetResString(IDS_PRIONORMAL) );
				menuPriority.AppendMenu( MF_STRING |
					((bTmpFlag && pPartFile->GetPriority() == PR_HIGH) ? MF_CHECKED : MF_UNCHECKED),
					MP_PRIOHIGH, GetResString(IDS_PRIOHIGH) );
				menuPriority.AppendMenu( MF_STRING |
					((bJustOne && pPartFile->IsAutoPrioritized()) ? MF_CHECKED : MF_UNCHECKED),
					MP_PRIOAUTO, GetResString(IDS_PRIOAUTO) );
			}

		//	Create/build the ED2K sub-menu
			menuED2K.CreateMenu();
			menuED2K.AppendMenu(MF_STRING,MP_GETED2KLINK, GetStringFromShortcutCode(IDS_DL_LINK1, SCUT_LINK, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetStringFromShortcutCode(IDS_DL_LINK2, SCUT_LINK_HTML, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetStringFromShortcutCode(IDS_CREATESOURCELINK, SCUT_LINK_SOURCE, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING, MP_GETHASH, GetStringFromShortcutCode(IDS_COPYHASH, SCUT_LINK_HASH, SSP_TAB_PREFIX));

		//	Create/build the source filter sub-menu
			menuSourceFilter.CreateMenu();
			menuSourceFilter.AddMenuTitle(GetResString(IDS_SRCFILTERMENU_SHOWING));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowUploadingSources?MF_CHECKED:0),MP_SRCFILTER_UPLOADING,GetResString(IDS_SRCFILTERMENU_UPLOADING));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowOnQueueSources?MF_CHECKED:0),MP_SRCFILTER_ONQUEUE,GetResString(IDS_SRCFILTERMENU_ONQUEUE));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowFullQueueSources?MF_CHECKED:0),MP_SRCFILTER_FULLQUEUE,GetResString(IDS_SRCFILTERMENU_FULLQUEUE));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowConnectedSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTED,GetResString(IDS_SRCFILTERMENU_CONNECTED));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowConnectingSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTING,GetResString(IDS_SRCFILTERMENU_CONNECTING));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowNNPSources?MF_CHECKED:0),MP_SRCFILTER_NNP,GetResString(IDS_NONEEDEDPARTS));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowWaitForFileReqSources?MF_CHECKED:0),MP_SRCFILTER_WAITFILEREQ,GetResString(IDS_WAITFILEREQ));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowLowToLowIDSources?MF_CHECKED:0),MP_SRCFILTER_LOWTOLOWID,GetResString(IDS_SRCFILTERMENU_LOWIDTOLOWID));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowLowIDOnOtherSrvSources?MF_CHECKED:0),MP_SRCFILTER_OTHERSRVLOWID,GetResString(IDS_ANOTHER_SERVER_LOWID));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowBannedSources?MF_CHECKED:0),MP_SRCFILTER_BANNED,GetResString(IDS_SRCFILTERMENU_BANNED));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowErrorSources?MF_CHECKED:0),MP_SRCFILTER_ERROR,GetResString(IDS_SRCFILTERMENU_ERROR));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowA4AFSources?MF_CHECKED:0),MP_SRCFILTER_A4AF,GetResString(IDS_SRCFILTERMENU_A4AF));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowUnknownSources?MF_CHECKED:0),MP_SRCFILTER_UNKNOWN,GetResString(IDS_UNKNOWN));

			menuSourceFilter.AppendMenu(MF_SEPARATOR);

			menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_SHOWALL,GetResString(IDS_SRCFILTERMENU_SHOWALL));
			menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_HIDEALL,GetResString(IDS_SRCFILTERMENU_HIDEALL));

		//	Create/build the advanced sub-menu
			menuAdvanced.CreateMenu();
			menuAdvanced.AppendMenu(MF_STRING | ((bJustOne && bFileDone) ? MF_GRAYED : MF_ENABLED),
				MP_DOCLEANUP, GetStringFromShortcutCode(IDS_DOCLEANUP, SCUT_FILE_NAMECLEANUP, SSP_TAB_PREFIX));
			menuAdvanced.AppendMenu(MF_STRING|
				(!bFileDone ? ( (pPartFile->IsAlternativeOutputDir()) ? MF_CHECKED : MF_UNCHECKED) : MF_GRAYED),
				MP_CHANGEDIR, GetResString(IDS_CHANGEDIR));
			menuAdvanced.AppendMenu( MF_STRING |
				((bJustOne && !pPartFile->IsLastBlockComplete() && !pPartFile->IsPreallocated()) ? MF_ENABLED : MF_GRAYED),
				MP_PREALLOCATE, GetStringFromShortcutCode(IDS_DL_PREALLOCATE, SCUT_DL_PREALLOC, SSP_TAB_PREFIX) );
			menuAdvanced.AppendMenu(MF_STRING|(bFileDone && !g_App.m_pPrefs->GetAVPath().IsEmpty() && g_App.m_pPrefs->IsAVEnabled() ? MF_ENABLED:MF_GRAYED), MP_AV_SCAN, GetResString(IDS_AV_SCAN));

			bool	bOneNotDone = (bJustOne && !bFileDone);

			menuAdvanced.AppendMenu( MF_STRING |
				( (bOneNotDone && pPartFile->AllowGet1stLast()) ?
				((pPartFile->GetMovieMode() != 0) ? MF_CHECKED : MF_UNCHECKED) : MF_GRAYED ),
				MP_MOVIE, GetResString(IDS_MOVIE) );

			menuAdvanced.AppendMenu(MF_SEPARATOR);
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED), MP_ALL_A4AF_TO_HERE, GetStringFromShortcutCode(IDS_ALL_A4AF_TO_HERE, SCUT_DL_A4AF, SSP_TAB_PREFIX));
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED), MP_ALL_A4AF_SAMECAT, GetStringFromShortcutCode(IDS_ALL_A4AF_SAMECAT, SCUT_DL_A4AFSAMECAT, SSP_TAB_PREFIX));
			menuAdvanced.AppendMenu( MF_STRING | ( (bOneNotDone) ?
				( (pPartFile == g_App.m_pDownloadQueue->GetA4AFAutoFile()) ?
				MF_CHECKED : MF_UNCHECKED ) : (MF_GRAYED | MF_UNCHECKED) ), MP_ALL_A4AF_AUTO, GetStringFromShortcutCode(IDS_TREE_DL_A4AF_AUTO, SCUT_DL_A4AFAUTO, SSP_TAB_PREFIX) );
			menuAdvanced.AppendMenu( MF_STRING | ((bOneNotDone) ? MF_ENABLED : MF_GRAYED),
				MP_ALL_A4AF_TO_OTHER, GetStringFromShortcutCode(IDS_ALL_A4AF_TO_OTHER, SCUT_DL_A4AFOTHER, SSP_TAB_PREFIX) );

		//	Create/build the web services sub-menu
			menuWeb.CreateMenu();

			UINT		dwWebServicesEmptyFlag = MF_STRING | ((UpdateURLMenu(menuWeb) == 0) ? MF_GRAYED : 0);
		//	Create/build the category assignment sub-menu
			CTitleMenu	catMenu;

			catMenu.CreatePopupMenu();
			catMenu.AddMenuTitle(GetResString(IDS_CAT));

		//	If there are only predefined cats, gray the assign menu
			UINT	dwNoUserCatsFlag = MF_STRING | MF_GRAYED;

			if (!bFileDone && (CCat::GetNumCats() > CCat::GetNumPredefinedCats()))
			{
				CString	strBuffer;
				int		iFileCatIndex = CCat::GetUserCatIndexByID(pPartFile->GetCatID());

				dwNoUserCatsFlag = MF_STRING;
				for (int i = 0; i < CCat::CatIndexToUserCatIndex(CCat::GetNumCats()); i++)
				{
					if (i == 0)
						GetResString(&strBuffer, IDS_CAT_UNASSIGN);
					else
					{
						strBuffer = CCat::GetCatByUserIndex(i)->GetTitle();
						strBuffer.Replace(_T("&"), _T("&&"));
					}
					catMenu.AppendMenu( MF_STRING | (iFileCatIndex == i ? MF_CHECKED : 0),
						MP_ASSIGNCAT + i, strBuffer );
				}
			}

		//	Build the File menu
			menuFile.AppendMenu(MF_STRING|((eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED), MP_CLEARCOMPLETED, GetStringFromShortcutCode(IDS_DL_CLEAR, SCUT_DL_CLEAR, SSP_TAB_PREFIX));
			menuFile.AppendMenu(MF_SEPARATOR);
		//	Add the category sub-menu
			menuFile.AppendMenu(dwNoUserCatsFlag|MF_POPUP, (UINT_PTR)catMenu.m_hMenu, GetResString(IDS_CAT_ASSIGN));
		//	Add the priority sub-menu
			menuFile.AppendMenu(uFlagIfDone|MF_POPUP, (UINT_PTR)menuPriority.m_hMenu, GetResString(IDS_PRIORITY));

			menuFile.AppendMenu(MF_STRING|(!bFileDone ? MF_ENABLED : MF_GRAYED),MP_CANCEL, GetStringFromShortcutCode(IDS_MAIN_BTN_CANCEL, SCUT_DL_CANCEL, SSP_TAB_PREFIX));

			menuFile.AppendMenu( MF_STRING |
				((eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone) ? MF_ENABLED:MF_GRAYED),
				MP_STOP, GetStringFromShortcutCode(IDS_STOP_VERB, SCUT_DL_STOP, SSP_TAB_PREFIX) );

			menuFile.AppendMenu( MF_STRING |
				((eFileStatus != PS_PAUSED && eFileStatus != PS_ERROR && !bFileDone) ? MF_ENABLED:MF_GRAYED),
				MP_PAUSE, GetStringFromShortcutCode(IDS_PAUSE_VERB, SCUT_DL_PAUSE, SSP_TAB_PREFIX) );

			menuFile.AppendMenu( MF_STRING |
				((eFileStatus == PS_PAUSED || eFileStatus == PS_STOPPED) ? MF_ENABLED:MF_GRAYED),
				MP_RESUME, GetStringFromShortcutCode(IDS_RESUME, SCUT_DL_RESUME, SSP_TAB_PREFIX) );

			if (bJustOne && eFileStatus == PS_ERROR)
				menuFile.AppendMenu(MF_STRING, MP_INITIALIZE, GetResString(IDS_DL_INITIALIZE));

			menuFile.AppendMenu(MF_SEPARATOR);

			menuFile.AppendMenu( MF_STRING |
				((bJustOne && eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED),
				MP_OPEN, GetStringFromShortcutCode(IDS_OPENFILE, SCUT_FILE_OPEN, SSP_TAB_PREFIX) );

			menuFile.AppendMenu( MF_STRING |
				((bJustOne && eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED),
				MP_OPENFOLDER, GetStringFromShortcutCode(IDS_OPENFOLDER, SCUT_FILE_OPENDIR, SSP_TAB_PREFIX) );

			menuFile.AppendMenu( MF_STRING |
				((bJustOne && pPartFile->PreviewAvailable()) ? MF_ENABLED : MF_GRAYED),
				MP_PREVIEW, GetStringFromShortcutCode(IDS_PREVIEW_VERB, SCUT_DL_PREVIEW, SSP_TAB_PREFIX) );

			menuFile.AppendMenu( MF_STRING | ((bJustOne) ? MF_ENABLED : MF_GRAYED), MP_METINFO,
				GetStringFromShortcutCode(IDS_DL_INFO, SCUT_FILE_DETAILS, SSP_TAB_PREFIX) );

			menuFile.AppendMenu( MF_STRING |
				((bJustOne && (pPartFile->HasComment() || pPartFile->HasRating())) /*&& !bFileDone*/ ? MF_ENABLED : MF_GRAYED),
				MP_VIEWFILECOMMENTS, GetStringFromShortcutCode(IDS_CMT_SHOWALL, SCUT_FILE_COMMENTS, SSP_TAB_PREFIX) );

			menuFile.AppendMenu(MF_SEPARATOR);
		//	Add the source-filter sub-menu
			menuFile.AppendMenu(MF_STRING|MF_POPUP,reinterpret_cast<UINT_PTR>(menuSourceFilter.m_hMenu), GetResString(IDS_SRCFILTERMENU_TITLE));
		//	Add the advanced sub-menu
			menuFile.AppendMenu(MF_STRING|MF_POPUP, (UINT_PTR)menuAdvanced.m_hMenu, GetResString(IDS_PW_ADVANCED));
		//	Add the ED2K sub-menu
			menuFile.AppendMenu(MF_STRING|MF_POPUP, (UINT_PTR)menuED2K.m_hMenu, GetResString(IDS_ED2KLINKFIX));
		//	Add the web services sub-menu
			menuFile.AppendMenu(dwWebServicesEmptyFlag|MF_POPUP, (UINT_PTR)menuWeb.m_hMenu, GetResString(IDS_WEBSERVICES));

			menuFile.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);
		}
	//	If the selected item isn't a file...
		else
		{
			CSourceDLItem			*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
			const CUpDownClient		*pSource = pSourceItem->GetSource();
			CTitleMenu		menuClient;

			if (pSource != NULL)
				g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, const_cast<CUpDownClient*>(pSource));

		//	Create the client menu
			menuClient.CreatePopupMenu();
			menuClient.AddMenuTitle(GetResString(IDS_CLIENTS));

			menuClient.AppendMenu(MF_STRING, MP_DETAIL, GetStringFromShortcutCode(IDS_SHOWDETAILS, SCUT_SRC_DETAILS, SSP_TAB_PREFIX));
			if (pSource->IsFriend())
				menuClient.AppendMenu(MF_STRING, MP_REMOVEFRIEND, GetStringFromShortcutCode(IDS_REMOVEFRIEND, SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
			else
				menuClient.AppendMenu(MF_STRING, MP_ADDFRIEND, GetStringFromShortcutCode(IDS_ADDFRIEND, SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING, MP_MESSAGE, GetStringFromShortcutCode(IDS_SEND_MSG, SCUT_SRC_MSG, SSP_TAB_PREFIX));
			menuClient.AppendMenu( MF_STRING | ((pSource && pSource->GetViewSharedFilesSupport()) ? MF_ENABLED : MF_GRAYED),
				MP_SHOWLIST, GetStringFromShortcutCode(IDS_VIEWFILES, SCUT_SRC_SHAREDFILES, SSP_TAB_PREFIX) );
			if (pSourceItem->IsAskedForAnotherFile())
				menuClient.AppendMenu(MF_STRING, MP_DOWNNOW, GetResString(IDS_DOWNLOAD_A4AF));

			menuClient.SetDefaultItem((g_App.m_pPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
			menuClient.TrackPopupMenuEx(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this, NULL);
		}
	}
//	If there's no selection (i.e. right-click on empty space in download list)...
	else
	{
		menuFile.CreatePopupMenu();
		menuFile.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));

		menuFile.AppendMenu(MF_STRING, MP_CLEARALLCOMPLETED, GetStringFromShortcutCode(IDS_TREE_DL_CLEAR_ALL_COMPLETED, SCUT_DL_CLEARALL, SSP_TAB_PREFIX));
		menuFile.AppendMenu(MF_SEPARATOR);

	//	Create/build the source filter sub-menu
		menuSourceFilter.CreateMenu();
		menuSourceFilter.AddMenuTitle(GetResString(IDS_SRCFILTERMENU_SHOWING));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUploadingSources?MF_CHECKED:0),MP_SRCFILTER_UPLOADING,GetResString(IDS_SRCFILTERMENU_UPLOADING));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowOnQueueSources?MF_CHECKED:0),MP_SRCFILTER_ONQUEUE,GetResString(IDS_SRCFILTERMENU_ONQUEUE));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowFullQueueSources?MF_CHECKED:0),MP_SRCFILTER_FULLQUEUE,GetResString(IDS_SRCFILTERMENU_FULLQUEUE));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectedSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTED,GetResString(IDS_SRCFILTERMENU_CONNECTED));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectingSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTING,GetResString(IDS_SRCFILTERMENU_CONNECTING));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowNNPSources?MF_CHECKED:0),MP_SRCFILTER_NNP,GetResString(IDS_NONEEDEDPARTS));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowWaitForFileReqSources?MF_CHECKED:0),MP_SRCFILTER_WAITFILEREQ,GetResString(IDS_WAITFILEREQ));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowLowToLowIDSources?MF_CHECKED:0),MP_SRCFILTER_LOWTOLOWID,GetResString(IDS_SRCFILTERMENU_LOWIDTOLOWID));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowLowIDOnOtherSrvSources?MF_CHECKED:0),MP_SRCFILTER_OTHERSRVLOWID,GetResString(IDS_ANOTHER_SERVER_LOWID));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowBannedSources?MF_CHECKED:0),MP_SRCFILTER_BANNED,GetResString(IDS_SRCFILTERMENU_BANNED));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowErrorSources?MF_CHECKED:0),MP_SRCFILTER_ERROR,GetResString(IDS_SRCFILTERMENU_ERROR));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowA4AFSources?MF_CHECKED:0),MP_SRCFILTER_A4AF,GetResString(IDS_SRCFILTERMENU_A4AF));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUnknownSources?MF_CHECKED:0),MP_SRCFILTER_UNKNOWN,GetResString(IDS_UNKNOWN));

		menuSourceFilter.AppendMenu(MF_SEPARATOR);

		menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_SHOWALL,GetResString(IDS_SRCFILTERMENU_SHOWALL));
		menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_HIDEALL,GetResString(IDS_SRCFILTERMENU_HIDEALL));

		menuSourceFilter.AppendMenu(MF_SEPARATOR);

		menuSourceFilter.AppendMenu(MF_STRING|(m_bSmartFilter?MF_CHECKED:0),MP_SMARTFILTER,GetResString(IDS_SRCFILTERMENU_SMARTFILTER));
	//	Add the source-filter sub-menu
		menuFile.AppendMenu(MF_STRING|MF_POPUP,reinterpret_cast<UINT_PTR>(menuSourceFilter.m_hMenu), GetResString(IDS_SRCFILTERMENU_TITLE));

		menuFile.TrackPopupMenuEx(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this, NULL);
	}

//	Menu objects are destroyed in their destructor

#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CDownloadListCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	NOPRM(lParam);
	EMULE_TRY

//	Commands which don't depend on selection
	switch (wParam)
	{
		case MP_CLEARALLCOMPLETED:
		{
			SetRedraw(false);
			g_App.m_pDownloadList->ClearCompleted(CAT_NONE);
			SetRedraw(true);
			return true;
		}
	}

	if (!ListSelectionIsEmpty())
	{
	//	Construct a list of all the selected part files
		CTypedPtrList<CPtrList, CPartFile*>			selectedList;
		CTypedPtrList<CPtrList, CPartFileDLItem*>	selectedItemList;
		UINT		iNumSelected = GetSelectedCount();
		int			iIndex;
		POSITION	pos = GetFirstSelectedItemPosition();
		CMuleCtrlItem		*pItem = NULL;

		if (pos != NULL)
		{
			POSITION	posTmp = pos;

			if ((iIndex = GetNextSelectedItem(posTmp)) >= 0)
				pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(iIndex));
		}

		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

		while (pos != NULL)
		{
			if ((iIndex = GetNextSelectedItem(pos)) >= 0)
			{
				if (typeid(*ListGetItemAt(iIndex)) == typeid(CPartFileDLItem))
				{
					selectedItemList.AddTail(dynamic_cast<CPartFileDLItem*>(ListGetItemAt(iIndex)));
					selectedList.AddTail(ListGetItemAt(iIndex)->GetFile());
				}
			}
		}
	//	If there's at least one part file item selected...
		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pItem->GetFile();

			switch (wParam)
			{
				case MP_CANCEL:
				//	For multiple selections
					if (iNumSelected > 0)
					{
						CString		strFileList = GetResString((iNumSelected == 1) ? IDS_Q_CANCELDL2 : IDS_Q_CANCELDL);
						bool		bIsValidDelete = false;

						for (pos = selectedList.GetHeadPosition(); pos != NULL; selectedList.GetNext(pos))
						{
							EnumPartFileStatuses	eFileStatus = selectedList.GetAt(pos)->GetStatus();

							if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
							{
								bIsValidDelete = true;
								if (iNumSelected < 50)	// a number is used to limit messagebox size
								{
									strFileList += _T("\n");
									strFileList += selectedList.GetAt(pos)->GetFileName();
								}
							}
						}

						if (bIsValidDelete && AfxMessageBox(strFileList, MB_ICONQUESTION|MB_YESNO) == IDYES)
						{
							SetRedraw(false);

							while (!selectedList.IsEmpty())
							{
								HideSources(selectedList.GetHead());
								switch(selectedList.GetHead()->GetStatus())
								{
									case PS_WAITINGFORHASH:
									case PS_HASHING:
									case PS_COMPLETING:
									case PS_COMPLETE:
										break;
									case PS_STOPPED:
									case PS_PAUSED:
									default:
										if (selectedList.GetHead()->IsFakesDotRar())
										{
											g_App.m_pPrefs->SetDLingFakeListVersion(0);
											g_App.m_pPrefs->SetDLingFakeListLink(_T(""));
										}
										selectedList.GetHead()->DeleteFile();
										break;
								}
								selectedList.RemoveHead();
							}

							SetRedraw(true);
							g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
						}
					}
					break;

				case MP_PRIOHIGH:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							selectedList.GetHead()->SetAutoPriority(false);
							selectedList.GetHead()->SetPriority(PR_HIGH);
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
					{
						pPartFile->SetAutoPriority(false);
						pPartFile->SetPriority(PR_HIGH);
					}
					break;

				case MP_PRIOLOW:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							selectedList.GetHead()->SetAutoPriority(false);
							selectedList.GetHead()->SetPriority(PR_LOW);
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
					{
						pPartFile->SetAutoPriority(false);
						pPartFile->SetPriority(PR_LOW);
					}
					break;

				case MP_PRIONORMAL:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							selectedList.GetHead()->SetAutoPriority(false);
							selectedList.GetHead()->SetPriority(PR_NORMAL);
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
					{
						pPartFile->SetAutoPriority(false);
						pPartFile->SetPriority(PR_NORMAL);
					}
					break;

				case MP_PRIOAUTO:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							selectedList.GetHead()->SetAutoPriority(true);
							selectedList.GetHead()->SetPriority(PR_HIGH);
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
					{
						pPartFile->SetAutoPriority(true);
						pPartFile->SetPriority(PR_HIGH);
					}
					break;

				case MP_PAUSE:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							selectedList.GetHead()->PauseFile();
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
						pPartFile->PauseFile();
					break;

				case MP_RESUME:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							selectedList.GetHead()->ResumeFile();
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
						pPartFile->ResumeFile();
					break;

				case MP_INITIALIZE:
					if (iNumSelected == 1)
					{
						pPartFile->LoadPartFile(pPartFile->GetTempDir(), pPartFile->GetPartMetFileName());
						if (pPartFile->GetRawStatus() == PS_READY)
							g_App.m_pSharedFilesList->SafeAddKnownFile(pPartFile);
					}
					break;

				case MP_PREALLOCATE:
					if (iNumSelected == 1)
					{
						if (!pPartFile->IsLastBlockComplete())
							pPartFile->AllocateNeededSpace();
					}
					break;

				case MP_RENAME:
				{
					CString		strTemp;

					GetResString(&strTemp, IDS_RENAME);

					InputBox	inputbox(strTemp, pPartFile->GetFileName(), true);

					inputbox.DoModal();
					strTemp = inputbox.GetInput();
					if (!inputbox.WasCancelled() && !strTemp.IsEmpty())
					{
						EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

					//	As the dialog could be opened for a while we need to check status once again
						if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
						{
							pPartFile->SetFileName(strTemp);
							pPartFile->SavePartFile();
							pPartFile->UpdateDisplayedInfo();
							g_App.m_pSharedFilesList->UpdateItem((CKnownFile*)pPartFile);
							g_App.m_pMDlg->m_wndTransfer.UpdateInfoHeader();
						}
					}
					break;
				}
				case MP_STOP:
					if (iNumSelected > 1)
					{
						SetRedraw(false);
						while(!selectedList.IsEmpty())
						{
							CPartFile *selected = selectedList.GetHead();
							HideSources(selected);
							selected->StopFile();
							selectedList.RemoveHead();
						}
						SetRedraw(true);
					}
					else
					{
						HideSources(pPartFile);
						pPartFile->StopFile();
					}
					break;

				case MP_CLEARCOMPLETED:
					SetRedraw(false);
					if (iNumSelected > 1)
					{
						while(!selectedList.IsEmpty())
						{
							CPartFile *pSelected = selectedList.GetHead();
							g_App.m_pDownloadList->ClearCompleted(pSelected);
							selectedList.RemoveHead();
						}
					}
					else
						g_App.m_pDownloadList->ClearCompleted(pPartFile);
					SetRedraw(true);
					break;

				case MP_METINFO:
				{
					CFileDetails		dialog(IDS_FD_TITLE, pPartFile, this, 0);

					dialog.DoModal();
					break;
				}
				case MP_METINFOSOURCES:
				{
					CFileDetails		dialog(IDS_FD_TITLE, pPartFile, this, 2);

					dialog.DoModal();
					break;
				}
				case MP_GETED2KLINK:
					if (iNumSelected > 1)
					{
						CString str;
						while(!selectedList.IsEmpty())
						{
							str += selectedList.GetHead()->CreateED2kLink();
							selectedList.RemoveHead();
							if (!selectedList.IsEmpty())
								str += _T("\r\n");
						}
						g_App.CopyTextToClipboard(str);
					}
					else
						g_App.CopyTextToClipboard(pPartFile->CreateED2kLink());
					break;

				case MP_GETHTMLED2KLINK:
					if (iNumSelected > 1)
					{
						CString str;
						while(!selectedList.IsEmpty())
						{
							str += selectedList.GetHead()->CreateHTMLED2kLink();
							selectedList.RemoveHead();
							if (!selectedList.IsEmpty())
								str += _T("\r\n");
						}
						g_App.CopyTextToClipboard(str);
					}
					else
						g_App.CopyTextToClipboard(pPartFile->CreateHTMLED2kLink());
					break;

				case MP_GETSOURCEED2KLINK:
					if (iNumSelected > 1)
					{
						CString str;
						while(!selectedList.IsEmpty())
						{
							str += selectedList.GetHead()->CreateED2KSourceLink(7, 20);
							selectedList.RemoveHead();
							if (!selectedList.IsEmpty())
								str += _T("\r\n");
						}
						g_App.CopyTextToClipboard(str);
					}
					else
						g_App.CopyTextToClipboard(pPartFile->CreateED2KSourceLink(7, 20));
					break;

				case MP_GETHASH:
					if (iNumSelected > 0)
					{
						CString str;

						while (!selectedList.IsEmpty())
						{
							str += HashToString(selectedList.RemoveHead()->GetFileHash());
							if (!selectedList.IsEmpty())
								str += _T("\r\n");
						}
						g_App.CopyTextToClipboard(str);
					}
					break;

				case MP_OPEN:
					if (iNumSelected == 1)
						ShellOpenFile(pPartFile->GetFilePath());
					break;

				case MP_PREVIEW:
					if (iNumSelected == 1)
						pPartFile->PreviewFile();
					break;

				case MP_VIEWFILECOMMENTS:
				{
					CCommentDialogLst dialog(pPartFile);
					dialog.DoModal();
					break;
				}
				case MP_CHANGEDIR:
				{
					CString		strDir = pPartFile->GetOutputDir();

					if (strDir.GetLength() == 2)
						strDir += _T('\\');
					CString newpath = BrowseFolder(g_App.m_pMDlg->m_hWnd, GetResString(IDS_SELECTOUTPUTDIR), strDir);
					if (newpath.GetLength() == 3)
						newpath.Remove(_T('\\'));
					if (iNumSelected > 1)
					{
						while (!selectedList.IsEmpty())
						{
							CPartFile		*pPFTmp = selectedList.RemoveHead();

							if (newpath.CompareNoCase(pPFTmp->GetOutputDir()) != 0)
							{
								pPFTmp->SetAlternativeOutputDir(&newpath);
								pPFTmp->SaveSettingsFile();
							}
						}
					}
					if (newpath.CompareNoCase(strDir) != 0)
					{
						pPartFile->SetAlternativeOutputDir(&newpath);
						pPartFile->SaveSettingsFile();
						pPartFile->GetOutputDir();
					}
					break;
				}
				case MP_DOCLEANUP:
					while (!selectedList.IsEmpty())
					{
						CPartFile* selFile = selectedList.GetHead();
						EnumPartFileStatuses	eFileStatus = selFile->GetStatus();

						if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
						{
							selFile->SetFileName(CleanupFilename(selFile->GetFileName()));
							selFile->SavePartFile();
							selFile->UpdateDisplayedInfo();
							g_App.m_pSharedFilesList->UpdateItem((CKnownFile*)selFile);
						}
						selectedList.RemoveHead();
					}
					break;

				case MP_ALL_A4AF_TO_HERE:
					pPartFile->DownloadAllA4AF();
					break;

				case MP_ALL_A4AF_SAMECAT:
					pPartFile->DownloadAllA4AF(true);
					break;

				case MP_ALL_A4AF_AUTO:
					if (g_App.m_pDownloadQueue->GetA4AFAutoFile() == pPartFile)
					//	Current pPartFile is A4AF auto => User want to switch it off
						g_App.m_pDownloadQueue->SetA4AFAutoFile(NULL);
					else
					//	Another pPartFile is A4AF auto => switch to new pPartFile
						g_App.m_pDownloadQueue->SetA4AFAutoFile(pPartFile);
					break;

				case MP_ALL_A4AF_TO_OTHER:
				{
					ClientList	clientListCopy;

					SetRedraw(false);

					pPartFile->GetCopySourceLists(SLM_ALLOWED_TO_A4AF_SWAP, &clientListCopy);
					for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
					{
						(*cIt)->SwapToAnotherFile(NULL);
					}
					SetRedraw(true);
					break;
				}
				case MP_MOVIE:
				{
					EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

					if ((eFileStatus != PS_COMPLETE) && (eFileStatus != PS_COMPLETING))
						pPartFile->GetFirstLastChunk4Preview();
					break;
				}
				case MP_OPENFOLDER:
					if (iNumSelected == 1)
						ShellOpenFile(pPartFile->GetPath());
					break;

				case MP_AV_SCAN:
				{
					CString	strBuffer = g_App.m_pPrefs->GetAVParams();

					while (!selectedList.IsEmpty())
					{
						if (!selectedList.GetHead()->IsPartFile())
						{
							strBuffer += _T(" \"");
							strBuffer += ConcatFullPath(selectedList.GetHead()->GetPath(), selectedList.GetHead()->GetFileName());
							strBuffer += _T('\"');
						}
						selectedList.RemoveHead();
					}
					ShellExecute(NULL, _T("open"), g_App.m_pPrefs->GetAVPath(), strBuffer, NULL, SW_SHOW);
					break;
				}
				case MP_SRCFILTER_UPLOADING:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowUploadingSources = !selectedItemList.GetHead()->m_bShowUploadingSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_ONQUEUE:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowOnQueueSources = !selectedItemList.GetHead()->m_bShowOnQueueSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_FULLQUEUE:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowFullQueueSources = !selectedItemList.GetHead()->m_bShowFullQueueSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_CONNECTED:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowConnectedSources = !selectedItemList.GetHead()->m_bShowConnectedSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_CONNECTING:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowConnectingSources = !selectedItemList.GetHead()->m_bShowConnectingSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_NNP:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowNNPSources = !selectedItemList.GetHead()->m_bShowNNPSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_WAITFILEREQ:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowWaitForFileReqSources = !selectedItemList.GetHead()->m_bShowWaitForFileReqSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_LOWTOLOWID:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowLowToLowIDSources = !selectedItemList.GetHead()->m_bShowLowToLowIDSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_OTHERSRVLOWID:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowLowIDOnOtherSrvSources = !selectedItemList.GetHead()->m_bShowLowIDOnOtherSrvSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_BANNED:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowBannedSources = !selectedItemList.GetHead()->m_bShowBannedSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_ERROR:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowErrorSources = !selectedItemList.GetHead()->m_bShowErrorSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_A4AF:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowA4AFSources = !selectedItemList.GetHead()->m_bShowA4AFSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_UNKNOWN:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->m_bShowUnknownSources = !selectedItemList.GetHead()->m_bShowUnknownSources;
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_HIDEALL:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->FilterAllSources();
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				case MP_SRCFILTER_SHOWALL:
					if (iNumSelected > 0)
					{
						while (!selectedItemList.IsEmpty())
						{
							selectedItemList.GetHead()->FilterNoSources();
							selectedItemList.RemoveHead();
						}
						UpdateSourceItems();
					}
					break;

				default:
				//	Web services
					if (wParam <= MP_WEBURL + 64 && wParam >= MP_WEBURL)
						RunURL(pPartFile, g_App.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
				//	Assign/Unassign to/from Category
					else if (wParam >= MP_ASSIGNCAT && wParam <= MP_LASTASSIGNCAT)
					{
						while (!selectedList.IsEmpty())
						{
							CPartFile	*pSelectedFile = selectedList.GetHead();
							int			iUserCatIdx = wParam - MP_ASSIGNCAT;

							if (iUserCatIdx != 0)
								pSelectedFile->SetCatID(CCat::GetCatIDByUserIndex(iUserCatIdx));
							else
								pSelectedFile->SetCatID(CAT_NONE);
							selectedList.RemoveHead();
						}
					//	Hide the pPartFile if it's not in the displayed category
						ChangeCategoryByIndex(m_iCurTabIndex);
					//	Redraw the pPartFile in its new color assuming it is visible
						g_App.m_pDownloadList->UpdateFile(pPartFile);
					//	Update the category file counts
						g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
					}
					break;
			}
		}
	//	If a source item is selected...
		else
		{
			CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
#ifdef OLD_SOCKETS_ENABLED
			CUpDownClient		*pSource = pSourceItem->GetSource();

			switch (wParam)
			{
				case MP_SHOWLIST:
					pSource->RequestSharedFileList();
					break;
				case MP_MESSAGE:
					g_App.m_pMDlg->m_wndChat.StartSession(pSource);
					break;
				case MP_ADDFRIEND:
					g_App.m_pFriendList->AddFriend(pSource);
					break;
				case MP_REMOVEFRIEND:
					g_App.m_pFriendList->RemoveFriend(pSource);
					break;
				case MP_DETAIL:
				{
					CClientDetails		dialog(IDS_CD_TITLE, pSource, this, 0);

					dialog.DoModal();
					break;
				}
				case MP_DOWNNOW:
				{
					CPartFile		*pParentFile = pSourceItem->GetParentFile();

					pSource->SwapToAnotherFile(pParentFile);
					break;
				}
			}
#endif //OLD_SOCKETS_ENABLED
		}
	}
//	If nothing was selected in the list...
	else
	{
		switch (wParam)
		{
			case MP_SRCFILTER_UPLOADING:
				m_bShowUploadingSources = !m_bShowUploadingSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_ONQUEUE:
				m_bShowOnQueueSources = !m_bShowOnQueueSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_FULLQUEUE:
				m_bShowFullQueueSources = !m_bShowFullQueueSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_CONNECTED:
				m_bShowConnectedSources = !m_bShowConnectedSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_CONNECTING:
				m_bShowConnectingSources = !m_bShowConnectingSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_NNP:
				m_bShowNNPSources = !m_bShowNNPSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_WAITFILEREQ:
				m_bShowWaitForFileReqSources = !m_bShowWaitForFileReqSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_LOWTOLOWID:
				m_bShowLowToLowIDSources = !m_bShowLowToLowIDSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_OTHERSRVLOWID:
				m_bShowLowIDOnOtherSrvSources = !m_bShowLowIDOnOtherSrvSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_BANNED:
				m_bShowBannedSources = !m_bShowBannedSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_ERROR:
				m_bShowErrorSources = !m_bShowErrorSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_A4AF:
				m_bShowA4AFSources = !m_bShowA4AFSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_UNKNOWN:
				m_bShowUnknownSources = !m_bShowUnknownSources;
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_HIDEALL:
				FilterAllSources();
				UpdateSourceItems();
				break;

			case MP_SRCFILTER_SHOWALL:
				FilterNoSources();
				UpdateSourceItems();
				break;

			case MP_SMARTFILTER:
				m_bSmartFilter = !m_bSmartFilter;
			//	If we're turning smart filtering on...
				if (m_bSmartFilter)
				{
				//	Just update file items so the appropriate sources are shown.
					UpdateFileItems();
				}
			//	If we're turning smart filtering off...
				else
				{
				//	Reset the source filters on all file items and update them.
					ResetSourceFiltersForAllFiles();
				}
				break;
		}
	}

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader)
{
	EMULE_TRY

	int		iColumn = pHeader->iItem;

	m_iColumnMaxWidths[iColumn] = 0;
	m_iMeasuringColumn = iColumn;
	Invalidate();
	UpdateWindow();
	m_iMeasuringColumn = -1;
	if (m_iColumnMaxWidths[iColumn] != 0)
		SetColumnWidth(iColumn, m_iColumnMaxWidths[iColumn]);
	else
		CMuleListCtrl::OnNMDividerDoubleClick(pHeader);
	Invalidate();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnColumnClick(NMHDR *pNMHDR, LRESULT *pResult)
{
	EMULE_TRY

	NM_LISTVIEW	*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);
	int			iMsk = 1, iSubItem = pNMListView->iSubItem;
	byte		*pbyteSortAscending;
	bool		bIsCtrl = GetAsyncKeyState(VK_CONTROL) < 0;
	unsigned	uiSortOrder;
	uint32		dwSortCode;

	if (!bIsCtrl)
	{
		pbyteSortAscending = g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD);
	// Reverse sorting direction for the same column and keep the same if column was changed
		if (static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
			pbyteSortAscending[iSubItem] = static_cast<byte>((pbyteSortAscending[iSubItem] + 1) & iMsk);

		SetSortArrow(iSubItem, uiSortOrder = pbyteSortAscending[iSubItem] & iMsk);
		g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD, iSubItem);
		dwSortCode = (m_dwParamSort & ~0xFF) | iSubItem | ((uiSortOrder & 1) ? MLC_SORTASC : MLC_SORTDESC) | (MLC_DONTSORT << 24);
	}
	else
	{
		pbyteSortAscending = g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2);
	// Reverse sorting direction for the same column and keep the same if column was changed
		if (static_cast<int>((m_dwParamSort >> 16) & MLC_COLUMNMASK) == iSubItem)
			pbyteSortAscending[iSubItem] = static_cast<byte>((pbyteSortAscending[iSubItem] + 1) & iMsk);

		SetSortArrow(iSubItem, uiSortOrder = pbyteSortAscending[iSubItem] & iMsk);
		g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD2, iSubItem);
		dwSortCode = (m_dwParamSort & ~0xFF0000) | ((iSubItem | ((uiSortOrder & 1) ? MLC_SORTASC : MLC_SORTDESC)) << 16) | (MLC_DONTSORT << 24);
	}

	SortItems(SortProc, dwSortCode);

	EMULE_CATCH

	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CDownloadListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSortCode)
{
	EMULE_TRY

	CMuleCtrlItem		*pItem1 = reinterpret_cast<CMuleCtrlItem*>(lParam1);
	CPartFileDLItem		*pFileItem1 = dynamic_cast<CPartFileDLItem*>(pItem1);
	CSourceDLItem		*pSourceItem1 = dynamic_cast<CSourceDLItem*>(pItem1);
	CMuleCtrlItem		*pItem2 = reinterpret_cast<CMuleCtrlItem*>(lParam2);
	CPartFileDLItem		*pFileItem2 = dynamic_cast<CPartFileDLItem*>(pItem2);
	CSourceDLItem		*pSourceItem2 = dynamic_cast<CSourceDLItem*>(pItem2);
	int					iFileSortItem = 0;
	int					iSourceSortItem = 0;
	int					iSourceSortItem2 = -1;
	int					iFileSortMod = 1;
	int					iSourceSortMod = 1;
	int					iSourceSortMod2 = 1;
	DWORD				dwFilesSortCode = lParamSortCode & 0xFF;
	DWORD				dwSourceSortCode = (lParamSortCode >> 16) & 0xFF;
	DWORD				dwSourceSortCode2 = (lParamSortCode >> 24) & 0xFF;
	bool				bSortSourceCol2 = false;

//	Extract the sort items and sort flags from the sort code
	if ((dwFilesSortCode & MLC_SORTDESC) != 0)
		iFileSortMod = -1;
	iFileSortItem = dwFilesSortCode & MLC_COLUMNMASK;

	if ((dwSourceSortCode & MLC_SORTDESC) != 0)
		iSourceSortMod = -1;
	iSourceSortItem = dwSourceSortCode & MLC_COLUMNMASK;

	if (dwSourceSortCode2 != MLC_DONTSORT)
	{
		bSortSourceCol2 = true;
		if ((dwSourceSortCode2 & MLC_SORTDESC) != 0)
			iSourceSortMod2 = -1;
		iSourceSortItem2 = dwSourceSortCode2 & MLC_COLUMNMASK;
	}

	int		iCompare;

//	Files vs source?
	if (pFileItem1 != NULL && pSourceItem2 != NULL)
	{
		CPartFile	*pPartFile1 = pFileItem1->GetFile();
		CPartFile	*pPartFile2 = pSourceItem2->GetParentFile();

		if (pPartFile1 != pPartFile2)
			iCompare = Compare(pPartFile1, pPartFile2, iFileSortItem, iFileSortMod);
		else
			iCompare = -1;
	}
	else if (pSourceItem1 != NULL && pFileItem2 != NULL)
	{
		CPartFile	*pPartFile1 = pSourceItem1->GetParentFile();
		CPartFile	*pPartFile2 = pFileItem2->GetFile();

		if (pPartFile1 != pPartFile2)
			iCompare = Compare(pPartFile1, pPartFile2, iFileSortItem, iFileSortMod);
		else
			iCompare = 1;
	}
	else
	{
	//	Both files? (!)
		if (pFileItem1 != NULL)
		{
			CPartFile	*pPartFile1 = pFileItem1->GetFile();
			CPartFile	*pPartFile2 = pFileItem2->GetFile();

			iCompare = Compare(pPartFile1, pPartFile2, iFileSortItem, iFileSortMod);
		}
	//	Both sources...
		else
		{
			iCompare = Compare(pSourceItem1->GetParentFile(), pSourceItem2->GetParentFile(),iFileSortItem, iFileSortMod);

		//	If the sources aren't for the same file...
			if (iCompare != 0)
				return iCompare;

		//	A4AF clients kept separate, unless sorting for name
			if ( (pSourceItem1->IsAskedForAnotherFile() || pSourceItem2->IsAskedForAnotherFile())
			  && iSourceSortItem != DLCOL_FILENAME )
			{
				int		n = 0;

				if (pSourceItem1->IsAskedForAnotherFile() && !pSourceItem2->IsAskedForAnotherFile())
					n = 1;
				if (!pSourceItem1->IsAskedForAnotherFile() && pSourceItem2->IsAskedForAnotherFile())
					n = -1;
			//	Always at the end, unless sort by source - then bIsA4AF always at the top
				if (n != 0)
				{
					iCompare = /*(iFileSortItem == DLCOL_PROGRESS) ? -n : n*/ n;
				}
				else
				{
#ifdef OLD_SOCKETS_ENABLED
					iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem, !bSortSourceCol2) * iSourceSortMod;
					if (bSortSourceCol2 && iCompare == 0)
					{
						iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem2) * iSourceSortMod2;
					}
#endif //OLD_SOCKETS_ENABLED
				}
			}
			else
			{
#ifdef OLD_SOCKETS_ENABLED
				iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem, !bSortSourceCol2) * iSourceSortMod;
				if (bSortSourceCol2 && iCompare == 0)
				{
					iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem2) * iSourceSortMod2;
				}
#endif //OLD_SOCKETS_ENABLED
			}
		}
	}

	return iCompare;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::SetStyle()
{
	EMULE_TRY

	SetExtendedStyle(LVS_EX_FULLROWSELECT);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::SortInit(int override)
{
	EMULE_TRY

	uint32	dwSortCode = m_dwParamSort;

//	Major override, wipe old sorting order...
	if (override)
	{
		DWORD	dwFilesSortCode = g_App.m_pPrefs->GetDownloadSortCol();
		DWORD	dwSourceSortCode = g_App.m_pPrefs->GetSrcSortCol1();
		DWORD	dwSourceSortCode2 = (g_App.m_pPrefs->DoUseSrcSortCol2()) ? g_App.m_pPrefs->GetSrcSortCol2() : MLC_DONTSORT;
		int		iSortColumn, iSortAscending;
		byte	*pbyteSortAscending = g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2);

		dwSortCode = (dwSourceSortCode2 << 24) | (dwSourceSortCode << 16) | dwFilesSortCode;
		iSortAscending = (dwFilesSortCode & MLC_SORTDESC) ? 0 : 1;
		iSortColumn = dwFilesSortCode & MLC_COLUMNMASK;

		if (dwSourceSortCode2 != MLC_DONTSORT)
			pbyteSortAscending[dwSourceSortCode2 & MLC_COLUMNMASK] = (dwSourceSortCode2 & MLC_SORTDESC) ? 0 : 1;
		pbyteSortAscending[dwSourceSortCode & MLC_COLUMNMASK] = (dwSourceSortCode & MLC_SORTDESC) ? 0 : 1;
		g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD2, dwSourceSortCode & MLC_COLUMNMASK);
		g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD)[iSortColumn] = static_cast<byte>(iSortAscending);
		g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD, iSortColumn);
		SetSortArrow(iSortColumn, iSortAscending);
	}
	SortItems(SortProc, dwSortCode);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnListModified(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pResult);
	EMULE_TRY

	NM_LISTVIEW *pNMListView = (NM_LISTVIEW*)pNMHDR;

//	This works because true is equal to 1 and false equal to 0
	BOOL notLast = pNMListView->iItem + 1 != GetItemCount();
	BOOL notFirst = pNMListView->iItem != 0;

	CRect rcViewRect;
	GetViewRect(&rcViewRect);
	CRect rcItemRect;
	GetItemRect(pNMListView->iItem,&rcItemRect,LVIR_BOUNDS);
	CRect rcIntersection;
	rcIntersection.IntersectRect(rcViewRect,rcItemRect);
	if (!rcIntersection.IsRectEmpty())
	{
		RedrawItems(pNMListView->iItem - notFirst, pNMListView->iItem + notLast);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Compare() compares the two part files 'file1' and 'file2' by column 'lParamSort' and returns
//		-1, 0, or 1 for <, ==, or > respectively.
/*static*/ int CDownloadListCtrl::Compare(CPartFile *file1, CPartFile *file2, LPARAM lParamSortItem, WPARAM wParamSortMod)
{
	int		iCompare = 0;

	EMULE_TRY

	if (file1 == NULL || file2 == NULL)
		return 0;

	if (g_App.m_pPrefs->DoPausedStoppedLast())
	{
		EnumPartFileStatuses	eFileStatus;
		int	iRank1 = 0, iRank2 = 0;

		eFileStatus = file1->GetStatus();
		iRank1 |= (eFileStatus == PS_PAUSED) ? 1 : 0;
		iRank1 |= (eFileStatus == PS_STOPPED) ? 2 : 0;

		eFileStatus = file2->GetStatus();
		iRank2 |= (eFileStatus == PS_PAUSED) ? 1 : 0;
		iRank2 |= (eFileStatus == PS_STOPPED) ? 2 : 0;

		iCompare = iRank1 - iRank2;
		if (iCompare != 0)
			return iCompare;
	}

	switch (lParamSortItem)
	{
		case DLCOL_FILENAME:
		{
		//	Funny, but we might not have a filename yet..
		//	See below
			break;
		}
		case DLCOL_SIZE:
			iCompare = CompareInt64(file1->GetFileSize(), file2->GetFileSize());
			break;

		case DLCOL_TRANSFERRED:
			iCompare = CompareInt64(file1->GetTransferred(), file2->GetTransferred());
			break;

		case DLCOL_COMPLETED:
			iCompare = CompareInt64(file1->GetCompletedSize(), file2->GetCompletedSize());
			break;

		case DLCOL_SPEED:
			iCompare = CompareUnsigned(file1->GetDataRate(), file2->GetDataRate());
			if (iCompare == 0)
				iCompare = CompareUnsigned(file1->GetAvgDataRate(), file2->GetAvgDataRate());
			break;

		case DLCOL_PROGRESS:
		{
			double		dblComp = file1->GetPercentCompleted() - file2->GetPercentCompleted();

			if (dblComp > .00000000001)
				iCompare = 1;
			else if (dblComp < -.00000000001)
				iCompare = -1;
			break;
		}
		case DLCOL_NUMSOURCES:
			iCompare = file1->GetSourceCount() - file2->GetSourceCount();
			if (iCompare == 0)
				iCompare = file2->GetNotCurrentSourcesCount() - file1->GetNotCurrentSourcesCount();
			break;

		case DLCOL_PRIORITY:
			iCompare = file1->GetPriority() - file2->GetPriority();
			if (iCompare == 0)
				iCompare = static_cast<int>(file1->IsAutoPrioritized()) - static_cast<int>(file2->IsAutoPrioritized());
			break;

		case DLCOL_STATUS:
			iCompare = file1->GetPartFileStatusRang() - file2->GetPartFileStatusRang();
			break;

		case DLCOL_REMAINING:
			iCompare = CompareInt64( file1->GetFileSize() - file1->GetCompletedSize(),
				file2->GetFileSize() - file2->GetCompletedSize() );
			break;

		case DLCOL_REMAININGTIME:
		case DLCOL_ETA:
		{
			int		time1 = file1->GetTimeRemaining();
			int		time2 = file2->GetTimeRemaining();

			time1 = time1 == -1 ? INT_MAX : time1;	// -1 time indicates "unknown". Compare as if "never".
			time2 = time2 == -1 ? INT_MAX : time2;
			iCompare = (time1 > time2) ? 1 : ((time1 < time2) ? -1 : 0);

		//	If no remaining time sort by remaining average time asc.
			if (iCompare == 0)
			{
				time1 = file1->GetTimeRemaining(true);
				time2 = file2->GetTimeRemaining(true);

				time1 = time1 == -1 ? INT_MAX : time1;	// -1 time indicates "unknown". Compare as if "never".
				time2 = time2 == -1 ? INT_MAX : time2;

				iCompare = (time1 > time2) ? 1 : ((time1 < time2) ? -1 : 0);
			}
		//	If no remaining average time sort by remaining size asc. Leave completed files last...
			if (iCompare == 0)
			{
				EnumPartFileStatuses	eFileStatus = file1->GetStatus();

				time1 = ((eFileStatus == PS_COMPLETING) || (eFileStatus == PS_COMPLETE));
				eFileStatus = file2->GetStatus();
				time2 = ((eFileStatus == PS_COMPLETING) || (eFileStatus == PS_COMPLETE));

				if (!time1 && time2)
					iCompare = -1;
				else if (time1 && !time2)
					iCompare = 1;
				else if (!time1 && !time2)
					iCompare = CompareInt64( file1->GetFileSize() - file1->GetCompletedSize(),
						file2->GetFileSize() - file2->GetCompletedSize() );
			}
			break;
		}
		case DLCOL_LASTSEENCOMPLETE:
			if (file1->lastseencomplete > file2->lastseencomplete)
				iCompare = 1;
			else if (file1->lastseencomplete < file2->lastseencomplete)
				iCompare = -1;
			break;

		case DLCOL_LASTRECEIVED:
		{
			bool	bTransferred2 = (file2->GetTransferred() != 0);

			if (file1->GetTransferred() != 0)
			{
				if (bTransferred2)
				{
					CTime	ct1 = file1->GetLastDownTransfer();
					CTime	ct2 = file2->GetLastDownTransfer();

					if (ct1 > ct2)
						iCompare = 1;
					else if (ct1 < ct2)
						iCompare = -1;
				}
				else
					iCompare = 1;
			}
			else if (bTransferred2)
				iCompare = -1;
			break;
		}
		case DLCOL_CATEGORY:
		{
			CCat		*pCat1 = CCat::GetCatByID(file1->GetCatID());
			CCat		*pCat2 = CCat::GetCatByID(file2->GetCatID());
			CString		strFile1CatTitle = pCat1 == NULL ? _T("") : pCat1->GetTitle();
			CString		strFile2CatTitle = pCat2 == NULL ? _T("") : pCat2->GetTitle();

			if (strFile1CatTitle > strFile2CatTitle)
				iCompare = 1;
			else if (strFile1CatTitle < strFile2CatTitle)
				iCompare = -1;
			break;
		}
		case DLCOL_WAITED:
		{
			CTimeSpan	ts1 = CTime::GetCurrentTime() - file1->GetLastDownTransfer();
			CTimeSpan	ts2 = CTime::GetCurrentTime() - file2->GetLastDownTransfer();

			iCompare = (ts1 > ts2) ? 1 : ((ts1 < ts2) ? -1 : 0);
			break;
		}
		case DLCOL_AVGSPEED:
			iCompare = CompareUnsigned(file1->GetAvgDataRate(), file2->GetAvgDataRate());
			if (iCompare == 0)
				iCompare = CompareUnsigned(file1->GetDataRate(), file2->GetDataRate());
			break;

		case DLCOL_AVGREMTIME:
		case DLCOL_AVGETA:
		{
			int		time1 = file1->GetTimeRemaining(true);
			int		time2 = file2->GetTimeRemaining(true);

			time1 = time1 == -1 ? INT_MAX : time1;	// -1 time indicates "unknown". Compare as if "never".
			time2 = time2 == -1 ? INT_MAX : time2;
			iCompare = (time1 > time2) ? 1 : ((time1 < time2) ? -1 : 0);

		//	If no remaining average time sort by remaining average time asc.
			if (iCompare == 0)
			{
				time1 = file1->GetTimeRemaining();
				time2 = file2->GetTimeRemaining();

				time1 = time1 == -1 ? INT_MAX : time1;	// -1 time indicates "unknown". Compare as if "never".
				time2 = time2 == -1 ? INT_MAX : time2;

				iCompare = (time1 > time2) ? 1 : ((time1 < time2) ? -1 : 0);
			}
		//	If no remaining time sort by remaining size asc. Leave completed files last...
			if (iCompare == 0)
			{
				time1 = (file1->IsCompleting() || !file1->IsPartFile());
				time2 = (file2->IsCompleting() || !file2->IsPartFile());

				if (!time1 && time2)
					iCompare = -1;
				else if (time1 && !time2)
					iCompare = 1;
				else if (!time1 && !time2)
					iCompare = CompareInt64( file1->GetFileSize() - file1->GetCompletedSize(),
						file2->GetFileSize() - file2->GetCompletedSize() );
			}
			break;
		}
	}

	if (iCompare == 0)
	{
		iCompare = file1->CmpFileNames(file2->GetFileName());
		if (lParamSortItem == DLCOL_FILENAME)
			iCompare *= wParamSortMod;
	}
	else
	{
		iCompare *= wParamSortMod;
	}

	EMULE_CATCH

	return iCompare;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Compare() compares the two sources 'pClient1' and 'pClient2' by column 'lParamSort' and returns
//		-1, 0, or 1 for <, ==, or > respectively.
/*static*/ int CDownloadListCtrl::Compare( CUpDownClient *pClient1,CUpDownClient *pClient2, LPARAM lParamSort,
										   bool bDisambiguate/*=true*/ )
{
	int		iCompare = 0;

	EMULE_TRY

	if (pClient1==NULL||pClient2==NULL)
		return 0;

	switch (lParamSort)
	{
		case DLCOL_FILENAME:
			break;	//	See below

		case DLCOL_TRANSFERRED:
			if (!g_App.m_pPrefs->IsTransferredOnCompleted())
				iCompare = CompareUnsigned(pClient1->GetTransferredDown(), pClient2->GetTransferredDown());
			break;

		case DLCOL_COMPLETED:
			if (g_App.m_pPrefs->IsTransferredOnCompleted())
			    iCompare = CompareUnsigned(pClient1->GetTransferredDown(), pClient2->GetTransferredDown());
			break;

		case DLCOL_SPEED:
			iCompare = CompareUnsigned(pClient1->GetDownloadDataRate(), pClient2->GetDownloadDataRate());
			break;

		case DLCOL_PROGRESS:
			iCompare = (pClient1->GetAvailablePartCount() - pClient2->GetAvailablePartCount());
			break;

		case DLCOL_NUMSOURCES:
			if ((iCompare = (pClient1->GetClientSoft() - pClient2->GetClientSoft())) == 0)
			{
				if ((iCompare = (pClient2->GetVersion() - pClient1->GetVersion())) == 0)
				{
					if (!pClient1->IsModStringEmpty())
						iCompare = (!pClient2->IsModStringEmpty()) ?
							_tcsicmp(pClient1->GetModString(), pClient2->GetModString()) : -1;
					else if (!pClient2->IsModStringEmpty())
						iCompare = 1;
				}
			}
			break;

		case DLCOL_PRIORITY:
		{
			bool	bShowQRForClient1 = pClient1->GetDownloadState() == DS_ONQUEUE || pClient1->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER;
			bool	bShowQRForClient2 = pClient2->GetDownloadState() == DS_ONQUEUE || pClient2->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER;

			if (!bShowQRForClient1 || !bShowQRForClient2)
			{
				if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN)
				{
					iCompare = (pClient1->GetClientSoft() - pClient2->GetClientSoft());
				}
				else if (pClient1->GetDownloadState()==DS_DOWNLOADING || pClient2->GetDownloadState()==DS_DOWNLOADING)
				{
					iCompare = (pClient1->GetDownloadState()==DS_DOWNLOADING)?((pClient2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2;
				}
				else
				{
					iCompare = (bShowQRForClient1) ? -1 : ((bShowQRForClient2) ? 1 : 0);
				}
			}
			else if (pClient1->IsEmuleClient() && pClient2->IsEmuleClient())
			{
				if (!pClient1->IsRemoteQueueFull())
					iCompare = (!pClient2->IsRemoteQueueFull()) ? (pClient1->GetRemoteQueueRank() - pClient2->GetRemoteQueueRank()) : -1;
				else
					iCompare = (pClient2->IsRemoteQueueFull()) ? 0 : 1;
			}
			else
				iCompare = (pClient1->IsEmuleClient()) ? -1:((pClient2->IsEmuleClient()) ? 1:0);
			break;
		}
		case DLCOL_STATUS:
			iCompare = pClient1->GetDownloadStateAsString().Compare(pClient2->GetDownloadStateAsString());
			break;

		case DLCOL_ULDLRATIO:
		case DLCOL_QLRATING:
		{
			if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN)
			{
				iCompare = (pClient1->GetClientSoft() - pClient2->GetClientSoft());
			}
			else
			{
				if (pClient1->m_pCredits != NULL)
				{
					if (pClient2->m_pCredits != NULL)
					{
						if (lParamSort == DLCOL_ULDLRATIO)
							iCompare = (pClient1->GetRemoteBaseModifier() < pClient2->GetRemoteBaseModifier()) ? -1 : 1;
						else
							iCompare = pClient1->GetRemoteRatio() - pClient2->GetRemoteRatio();
					}
					else
					{
						iCompare = 1;
					}
				}
				else if (pClient2->m_pCredits != NULL)
				{
					iCompare = -1;
				}
			}
			break;
		}
		case DLCOL_LASTSEENCOMPLETE:
		case DLCOL_LASTRECEIVED:
		case DLCOL_CATEGORY:
			break;

		case DLCOL_WAITED:
		{
			uint32	dwWaited1, dwWaited2;

			if ((pClient1->GetDownloadState() == DS_ONQUEUE) || (pClient1->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER))
				dwWaited1 = pClient1->GetDLQueueWaitTime();
			else
				dwWaited1 = INT_MAX;
			if ((pClient2->GetDownloadState() == DS_ONQUEUE) || (pClient2->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER))
				dwWaited2 = pClient2->GetDLQueueWaitTime();
			else
				dwWaited2 = INT_MAX;
			iCompare = ((dwWaited1 < dwWaited2) ? -1 : ((dwWaited1 > dwWaited2) ? 1 : 0));
			break;
		}
		case DLCOL_AVGSPEED:
		case DLCOL_AVGREMTIME:
		case DLCOL_ETA:
		case DLCOL_AVGETA:
			break;

		case DLCOL_REMAINING:
		{
			uint32	dwDummy;

			iCompare = pClient1->GetRemainingSizeForCurrentPart(&dwDummy) - pClient2->GetRemainingSizeForCurrentPart(&dwDummy);
			break;
		}
		case DLCOL_REMAININGTIME:
			iCompare = pClient1->GetRemainingTimeForCurrentPart() - pClient2->GetRemainingTimeForCurrentPart();
			break;
	}

	if (iCompare == 0 && bDisambiguate)
	{
		CString		strName1, strName2;

		try
		{
			strName1 = pClient1->GetUserName();
		}
		catch(...)
		{
			strName1.Empty();
		}
		try
		{
			strName2 = pClient2->GetUserName();
		}
		catch(...)
		{
			strName2.Empty();
		}
		if (strName1.IsEmpty() || strName2.IsEmpty())
			iCompare = (strName1.IsEmpty()) ? ((strName2.IsEmpty()) ? 0 : 1) : -1;
		else
			iCompare = _tcsicmp(strName1, strName2);
	}
	EMULE_CATCH
	return iCompare;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnNMClick(NMHDR *pNMHDR, LRESULT *pResult)
{
	EMULE_TRY

//	Reset selection in UL, CL or QL list
	POSITION posSelClient = NULL;

	switch (g_App.m_pMDlg->m_wndTransfer.m_nActiveWnd)
	{
		case MPW_UPLOADLIST:
			posSelClient = g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.GetFirstSelectedItemPosition();
			while (posSelClient != NULL)
			{
				int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.GetNextSelectedItem(posSelClient);
				g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.SetItemState(iSelClientListIndex, 0, LVIS_SELECTED);
			}
			break;

		case MPW_UPLOADQUEUELIST:
			posSelClient = g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.GetFirstSelectedItemPosition();
			while (posSelClient != NULL)
			{
				int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.GetNextSelectedItem(posSelClient);
				g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.SetItemState(iSelClientListIndex, 0, LVIS_SELECTED);
			}
			break;

		case MPW_UPLOADCLIENTLIST:
			posSelClient = g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.GetFirstSelectedItemPosition();
			while (posSelClient != NULL)
			{
				int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.GetNextSelectedItem(posSelClient);
				g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.SetItemState(iSelClientListIndex, 0, LVIS_SELECTED);
			}
			break;
	}
	RefreshInfo();

	DWORD pos = GetMessagePos();
	CPoint pt((int)(short)LOWORD(pos), (int)(short)HIWORD(pos));
	ScreenToClient(&pt);

	posSelClient = GetFirstSelectedItemPosition();

	if (posSelClient != NULL)
	{
		int		iItemIndex = GetNextSelectedItem(posSelClient);
		CRect	r;

		GetItemRect(iItemIndex, &r, LVIR_BOUNDS);

		if (r.PtInRect(pt))
		{
			CMuleCtrlItem	*pListItem = ListGetItemAt(iItemIndex);
			CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pListItem);

		//	Process only if it is a file item
			if (pFileItem != NULL)
			{
				bool	pProcessed = false;
				CRect	rTestedArea(r.left + 3, r.top + 1, r.left + 18, r.top + 16);

			//	[+]/[-]
				if (rTestedArea.PtInRect(pt))
				{
					OnItemActivate(pNMHDR, pResult);
				}
				rTestedArea.SetRect(r.left + OFFSET_PLUSMINUS + 3, r.top, r.left + OFFSET_PLUSMINUS + 19, r.bottom);
			//	File Status
				if (g_App.m_pPrefs->ShowFullFileStatusIcons())
				{
					if (rTestedArea.PtInRect(pt))
					{
						CPartFile *pPartFile = pListItem->GetFile();

						if (pPartFile != NULL)
						{
							switch (pPartFile->GetStatus())
							{
								case PS_PAUSED:
								case PS_STOPPED:
									pPartFile->ResumeFile();
									break;
								case PS_COMPLETE:
									g_App.m_pDownloadList->ClearCompleted(pPartFile);
									break;
								case PS_ERROR:
								{
									pPartFile->LoadPartFile(pPartFile->GetTempDir(), pPartFile->GetPartMetFileName());
									if (pPartFile->GetRawStatus() == PS_READY)
										g_App.m_pSharedFilesList->SafeAddKnownFile(pPartFile);
									break;
								}
							}
							pProcessed = true;
						}
					}
					rTestedArea.OffsetRect(OFFSET_STATUSICON, 0);
				}
			//	File Type Icon
				if (!pProcessed && g_App.m_pPrefs->ShowFileTypeIcon())
				{
					if (rTestedArea.PtInRect(pt))
					{
						CPartFile	*pPartFile = pListItem->GetFile();

						if (pPartFile != NULL)
						{
							CFileDetails FileDetailsDlg(IDS_FD_TITLE, pPartFile, this, 0);
							FileDetailsDlg.DoModal();
						}
						pProcessed = true;
					}
					rTestedArea.OffsetRect(OFFSET_FILETYPEICON, 0);
				}
			//	Rating
				if (!pProcessed)
				{
					rTestedArea.SetRect(rTestedArea.left - 1, rTestedArea.top + 2, rTestedArea.left + 7, r.bottom - 2);
					if (rTestedArea.PtInRect(pt))
					{
						CPartFile	*pPartFile = pListItem->GetFile();

						if (pPartFile != NULL && (pPartFile->HasComment() || pPartFile->HasRating()))
						{
							CCommentDialogLst CommentDlg(pPartFile);
							CommentDlg.DoModal();
						}
					}
				}
			}
		}
	}

	*pResult = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnNMDblclkDownloadlist(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pNMHDR);
	EMULE_TRY

	POSITION	posSelClient = GetFirstSelectedItemPosition();

	if (posSelClient != NULL)
	{
		CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(posSelClient)));
		CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
		CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

	// 	Doubleclick opens completed files
		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pFileItem->GetFile();

			if (pPartFile->GetStatus() == PS_COMPLETE)
				ShellOpenFile(pPartFile->GetFilePath());
		}
		else if (pSourceItem != NULL)
		{
#ifdef OLD_SOCKETS_ENABLED
			CUpDownClient		*pSource = pSourceItem->GetSource();

			if (g_App.m_pPrefs->GetDetailsOnClick())
			{
				CClientDetails		dialog(IDS_CD_TITLE, pSource, this, 0);

				dialog.DoModal();
			}
			else
			{
				g_App.m_pMDlg->m_wndChat.StartSession(pSource);
			}
#endif //OLD_SOCKETS_ENABLED
		}
	}

	*pResult = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnSize(UINT nType, int cx, int cy)
{
	CListCtrl::OnSize(nType, cx, cy);
	Invalidate();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::RestartWaitingDownloads()
{
	EMULE_TRY

	CTypedPtrList<CPtrList, CPartFile*>		selectedList;

	int			iNumItems = GetItemCount();

//	Get initial sources from server if we dont have our MaxSourcesPerFile Limit reached
	for (int i = 0; i < iNumItems; i++)
	{
		CMuleCtrlItem		*pItem = ListGetItemAt(i);
		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

		if ( pFileItem != NULL && !pFileItem->GetFile()->IsPaused()
		     && pFileItem->GetFile()->GetSourceCount() <= g_App.m_pPrefs->GetMaxSourcePerFile() )
		{
			selectedList.AddTail(pFileItem->GetFile());
	 	}
	}

	for (POSITION pos = selectedList.GetHeadPosition(); pos != NULL; )
		selectedList.GetNext(pos)->GetSourcesAfterServerConnect();

	AddLogLine(LOG_FL_SBAR, IDS_NEWSERVERCONNECT, g_App.m_pPrefs->GetMaxSourcePerFile());

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	EMULE_TRY

	RefreshInfo();

	if (nChar == VK_CONTROL)
		SetSortArrow(m_dwParamSort & MLC_COLUMNMASK, (m_dwParamSort & MLC_SORTDESC) ? 0 : 1);

	CMuleListCtrl::OnKeyUp(nChar, nRepCnt, nFlags);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ShowAllUploadingSources()
{
	EMULE_TRY

	CDownloadList::PartFileItemVector	   *pvecFileItems = g_App.m_pDownloadList->GetFileItems();

	for (uint32 i = 0; i < pvecFileItems->size(); i++)
	{
		CPartFileDLItem		*pFileItem = (*pvecFileItems)[i];

		if (pFileItem != NULL)
		{
			pFileItem->m_bSrcsAreVisible = true;
			pFileItem->FilterAllSources();
		//	Unfilter just uploading sources
			pFileItem->m_bShowUploadingSources = true;
			UpdateSourceItems();
		}
	}

	delete pvecFileItems;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	EMULE_TRY

	bool	bHandled = false;

	POSITION		posSelClient = GetFirstSelectedItemPosition();
	int				iClientListIndex = GetNextSelectedItem(posSelClient);

	switch (nChar)
	{
		case VK_ADD:
		{
		//	Update header arrow only on the first press and don't on repeated events
			if ((nFlags & 0x4000) == 0)
			{
				if (::GetAsyncKeyState(VK_CONTROL) >= 0)
				{
					ExpandCollapseItem(iClientListIndex, EXPAND_ONLY, true);
					bHandled = true;
				}
			}
			break;
		}
		case VK_SUBTRACT:
		{
			ExpandCollapseItem(iClientListIndex, COLLAPSE_ONLY, true);
			bHandled = true;
			break;
		}
		case VK_CONTROL:
		{
		//	Update header arrow only on the first press and don't on repeated events
			if ((nFlags & 0x4000) == 0)
			{
				int			iSrcSortItem = (m_dwParamSort >> 16) & MLC_COLUMNMASK;
				bool		bSortSrcAscending = (m_dwParamSort & (MLC_SORTDESC << 16)) ? false : true;
				unsigned	iSrcSortCode2 = (m_dwParamSort >> 24);

				if (iSrcSortCode2 == MLC_DONTSORT)
					SetSortArrow(iSrcSortItem, bSortSrcAscending, 0);
				else
				{
					SetSortArrow(iSrcSortItem, bSortSrcAscending, 1);
					SetSortArrow(iSrcSortCode2 & MLC_COLUMNMASK, (iSrcSortCode2 & MLC_SORTDESC) ? false : true, 2);
				}
			}
			break;
		}
	}

	if (!bHandled)
		CMuleListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnKillFocus(CWnd *pNewWnd)
{
//	If Ctrl is pressed return back the list header arrow
	if (::GetAsyncKeyState(VK_CONTROL) < 0)
		SetSortArrow(m_dwParamSort & MLC_COLUMNMASK, (m_dwParamSort & MLC_SORTDESC) ? 0 : 1);

	CWnd::OnKillFocus(pNewWnd);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::RefreshInfo(void)
{
	EMULE_TRY

	if (GetFocus() == this)
	{
		POSITION	posSelClient = GetFirstSelectedItemPosition();
		if (posSelClient == NULL)
		{
	 		g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
		}
		else
		{
			CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(posSelClient)));
			CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
			CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

			if (pFileItem != NULL)
			{
				const CPartFile		*pPartFile = pFileItem->GetFile();

	 			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_FILE,const_cast<CPartFile*>(pPartFile));
			}
			else if (pSourceItem != NULL)
			{
#ifdef OLD_SOCKETS_ENABLED
				const CUpDownClient	*pSource = pSourceItem->GetSource();

	 			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,const_cast<CUpDownClient*>(pSource));
#endif //OLD_SOCKETS_ENABLED
			}
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ShowFilesCount() updates the display of the number of downloading files.
void CDownloadListCtrl::ShowFilesCount()
{
	g_App.m_pMDlg->m_wndTransfer.UpdateDownloadHeader();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ShowSelectedFileOrUserDetails()
{
	EMULE_TRY

	POINT		point;

	::GetCursorPos(&point);

	CPoint		p = point;

	ScreenToClient(&p);

	int			it = HitTest(p);

	SetSelectionMark(it);

	if (it == -1)
		return;

	CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetSelectionMark()));
	CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
	CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

	if (pFileItem != NULL)
	{
		CPartFile		*pPartFile = pFileItem->GetFile();
		CFileDetails		dialog(IDS_FD_TITLE, pPartFile, this, 1);

		dialog.DoModal();
	}
	else if (pSourceItem != NULL)
	{
#ifdef OLD_SOCKETS_ENABLED
		CUpDownClient		*pSource = pSourceItem->GetSource();
		CClientDetails		dialog(IDS_CD_TITLE, pSource, this, 0);
		dialog.DoModal();
#endif //OLD_SOCKETS_ENABLED
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ChangeCategory() changes the currently displayed category given a category ID.
void CDownloadListCtrl::ChangeCategoryByID(EnumCategories eNewCatID)
{
	int		iNewCatIndex = 0;

	iNewCatIndex = CCat::GetCatIndexByID(eNewCatID);

	if (iNewCatIndex == -1)
		iNewCatIndex = m_iCurTabIndex;

	ChangeCategoryByIndex(iNewCatIndex);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ChangeCategoryByIndex() changes the currently displayed category given a category (i.e. tab) index.
void CDownloadListCtrl::ChangeCategoryByIndex(int iNewCatIdx)
{
	SetRedraw(FALSE);

	m_iCurTabIndex = iNewCatIdx;
	m_eCurTabCat = CCat::GetCatIDByIndex(iNewCatIdx);

//	Remove all displayed files with a different cat and show the correct ones
	CDownloadList::PartFileItemVector	   *pvecPartFileItems = g_App.m_pDownloadList->GetFileItems();
	uint32									iNumFiles = pvecPartFileItems->size();

	for (uint32 i = 0; i < iNumFiles; i++)
	{
		CPartFileDLItem		*pFileItem = (*pvecPartFileItems)[i];

		if (!CCat::FileBelongsToGivenCat(pFileItem->GetFile(),m_eCurTabCat))
			HideFileItem(pFileItem);
		else
			ShowFileItem(pFileItem);
	}
	delete pvecPartFileItems;

	SortInit(0);
	SetRedraw(TRUE);

	ShowFilesCount();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::HideSourceItem(CSourceDLItem *pSourceItem)
{
//	Find entry in list and update object
	int		iSourceIndex = ListGetSourceItemIndex(pSourceItem);

	if (iSourceIndex != -1)
	{
		pSourceItem->SetVisibility(false);
		DeleteItem(iSourceIndex);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::HideFileItem(CPartFileDLItem *pFileItem)
{
	EMULE_TRY

	HideSources(pFileItem->GetFile());

	int		iFileIndex = ListGetFileItemIndex(pFileItem);

	if (iFileIndex != -1)
	{
		pFileItem->SetVisibility(false);
		DeleteItem(iFileIndex);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ShowFileItem(CPartFileDLItem *pFileItem)
{
	EMULE_TRY

	int		iFileIndex = ListGetFileItemIndex(pFileItem);

	if (iFileIndex == -1)
	{
		ListInsertFileItem(pFileItem,GetItemCount());
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ShowSourceItem(CSourceDLItem *pSourceItem)
{
	EMULE_TRY

	int		iSourceIndex = ListGetSourceItemIndex(pSourceItem);

//	If the source item isn't already in the list...
	if (iSourceIndex == -1)
	{
		CPartFileDLItem	   *pParentFileItem = pSourceItem->GetParentFileItem();
	//	Find the position of the next file item or the end of the list
		int					iParentFileIndex = ListGetFileItemIndex(pParentFileItem);

	// if parent file exists in the list then insert(attach) the sources
		if (iParentFileIndex > -1)
		{
			int				iInsertionIndex = iParentFileIndex;

		//	Until we hit the end of the list or the next item is a file item...
			do
			{
				iInsertionIndex++;
			}
			while ( iInsertionIndex < GetItemCount()
					&& typeid(*ListGetItemAt(iInsertionIndex)) != typeid(CPartFileDLItem));

			ListInsertSourceItem(pSourceItem,iInsertionIndex);
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult)
{
	NMLVDISPINFO	*pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);

	// Although we have an owner drawn listview control we store the text for the primary item in the listview, to be
	// capable of quick searching those items via the keyboard. Because our listview items may change their contents,
	// we do this via a text callback function. The listview control will send us the LVN_DISPINFO notification if
	// it needs to know the contents of the primary item.
	//
	// But, the listview control sends this notification all the time, even if we do not search for an item. At least
	// this notification is only sent for the visible items and not for all items in the list. Though, because this
	// function is invoked *very* often, no *NOT* put any time consuming code here in.

	if ((pDispInfo->item.mask & LVIF_TEXT) != 0)
	{
	//	Check for own search request, the rest of the flood comes from list control
	//	and isn't used as list is drawn by us
		if (pDispInfo->item.cchTextMax == ML_SEARCH_SZ)
		{
			CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(pDispInfo->item.lParam);
			CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

			if (pFileItem != NULL && pFileItem->GetFile() != NULL)
			{
				switch (pDispInfo->item.iSubItem)
				{
					case DLCOL_FILENAME:
						_tcsncpy(pDispInfo->item.pszText, pFileItem->GetFile()->GetFileName(), pDispInfo->item.cchTextMax);
						pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
						break;
					default:
						pDispInfo->item.pszText[0] = _T('\0');
						break;
				}
			}
			else
			{
#ifdef OLD_SOCKETS_ENABLED
				CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

				if (pSourceItem != NULL && pSourceItem->GetParentFile() != NULL)
				{
					switch (pDispInfo->item.iSubItem)
					{
						case DLCOL_FILENAME:
							_tcsncpy(pDispInfo->item.pszText, pSourceItem->GetSource()->GetUserName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						case DLCOL_NUMSOURCES:
							_tcsncpy(pDispInfo->item.pszText, pSourceItem->GetSource()->GetFullSoftVersionString(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						default:
							pDispInfo->item.pszText[0] = _T('\0');
							break;
					}
				}
#else
				pDispInfo->item.pszText[0] = _T('\0');
#endif //OLD_SOCKETS_ENABLED
			}
		}
		else if (pDispInfo->item.cchTextMax != 0)
			pDispInfo->item.pszText[0] = _T('\0');
	}
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	List methods
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ListInsertFileItem(CPartFileDLItem *pFileItem, int iPos)
{
	InsertItem(LVIF_PARAM | LVIF_TEXT, iPos, LPSTR_TEXTCALLBACK, 0, 0, 0, reinterpret_cast<LPARAM>(pFileItem));
	pFileItem->SetVisibility(true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ListInsertSourceItem(CSourceDLItem *pSourceItem, int iPos)
{
	InsertItem(LVIF_PARAM | LVIF_TEXT, iPos, LPSTR_TEXTCALLBACK, 0, 0, 0, reinterpret_cast<LPARAM>(pSourceItem));
	pSourceItem->SetVisibility(true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ListGetFileItemIndex() returns the list index of 'pFileItem' or -1 if it isn't in the list.
int CDownloadListCtrl::ListGetFileItemIndex(CPartFileDLItem *pFileItem)
{
	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = reinterpret_cast<LPARAM>(pFileItem);

	return FindItem(&find);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ListGetSourceItemIndex() returns the list index of 'pSourceItem' or -1 if it isn't in the list.
int CDownloadListCtrl::ListGetSourceItemIndex(CSourceDLItem *pSourceItem)
{
	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = reinterpret_cast<LPARAM>(pSourceItem);

	return FindItem(&find);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ListGetItemAt() returns the list item at index 'iIndex'.
CMuleCtrlItem *CDownloadListCtrl::ListGetItemAt(int iIndex)
{
	return reinterpret_cast<CMuleCtrlItem*>(GetItemData(iIndex));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	PostRefreshMessage() puts a message into the list control's message queue telling it it needs to
//	refresh dirty files and sources and then immediately returns.
void CDownloadListCtrl::PostRefreshMessage()
{
	if (::IsWindow(GetSafeHwnd()) && g_App.m_app_state != CEmuleApp::APP_STATE_SHUTTINGDOWN)
	{
		MSG		msg;

	//	If there's no refresh message already in the message queue... (don't want to flood it)
		if (!::PeekMessage(&msg, m_hWnd, WM_DL_REFRESH, WM_DL_REFRESH, PM_NOREMOVE))
		{
			PostMessage(WM_DL_REFRESH, 0, 0);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FilterNoSources() turns off filtering for all source types.
void CDownloadListCtrl::FilterNoSources()
{
	m_bShowUploadingSources = true;
	m_bShowOnQueueSources = true;
	m_bShowFullQueueSources = true;
	m_bShowConnectedSources = true;
	m_bShowConnectingSources = true;
	m_bShowNNPSources = true;
	m_bShowWaitForFileReqSources = true;
	m_bShowLowToLowIDSources = true;
	m_bShowLowIDOnOtherSrvSources = true;
	m_bShowBannedSources = true;
	m_bShowErrorSources = true;
	m_bShowA4AFSources = true;
	m_bShowUnknownSources = true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FilterAllSources() turns on filtering for all source types.
void CDownloadListCtrl::FilterAllSources()
{
	m_bShowUploadingSources = false;
	m_bShowOnQueueSources = false;
	m_bShowFullQueueSources = false;
	m_bShowConnectedSources = false;
	m_bShowConnectingSources = false;
	m_bShowNNPSources = false;
	m_bShowWaitForFileReqSources = false;
	m_bShowLowToLowIDSources = false;
	m_bShowLowIDOnOtherSrvSources = false;
	m_bShowBannedSources = false;
	m_bShowErrorSources = false;
	m_bShowA4AFSources = false;
	m_bShowUnknownSources = false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CDownloadListCtrl::PreTranslateMessage(MSG* pMsg)
{
	if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
	{
		int			iMessage = 0;
		short		nCode = GetCodeFromPressedKeys(pMsg);

		if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_DEFSORT))
		{
			if (g_App.m_pPrefs->DoUseSort())
				SortInit(DL_OVERRIDESORT);
		}
		else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_CLEARALL))
		{
			iMessage = MP_CLEARALLCOMPLETED;
		}
		else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_SHOWALL))
		{
			ShowAllUploadingSources();
		}
		else
		{
			POSITION	posSelClient = GetFirstSelectedItemPosition();

			if (posSelClient != NULL)
			{
				CMuleCtrlItem	   *pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(posSelClient)));
				CPartFileDLItem	   *pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

			//	If the selected item is a file...
				if (pFileItem != NULL)
				{
					CPartFile			   *pPartFile = pFileItem->GetFile();
					EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();
					bool					bJustOne  = (GetSelectedCount() == 1);
					bool					bFileDone = (eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING);

					if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_CANCEL))
					{
						if (!bFileDone)
							iMessage = MP_CANCEL;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_STOP))
					{
						if ((eFileStatus != PS_STOPPED) && (eFileStatus != PS_ERROR) && !bFileDone)
							iMessage = MP_STOP;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_PAUSE))
					{
						if ((eFileStatus != PS_PAUSED) && (eFileStatus != PS_STOPPED) && (eFileStatus != PS_ERROR) && !bFileDone)
							iMessage = MP_PAUSE;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_RESUME))
					{
						if ((eFileStatus == PS_PAUSED || eFileStatus == PS_STOPPED))
							iMessage = MP_RESUME;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_FILE_OPEN))
					{
						if (bJustOne && (eFileStatus == PS_COMPLETE))
							iMessage = MP_OPEN;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_FILE_OPENDIR))
					{
						if (bJustOne && (eFileStatus == PS_COMPLETE))
							iMessage = MP_OPENFOLDER;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_PREVIEW))
					{
						if (bJustOne && pPartFile->PreviewAvailable())
							iMessage = MP_PREVIEW;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_FILE_RENAME))
					{
						if (bJustOne && !bFileDone)
							iMessage = MP_RENAME;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_FILE_COMMENTS))
					{
						if (bJustOne && (pPartFile->HasComment() || pPartFile->HasRating()))
							iMessage = MP_VIEWFILECOMMENTS;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_FILE_DETAILS))
					{
						if (bJustOne)
							iMessage = MP_METINFO;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_FD_SOURCES))
					{
						if (bJustOne)
							iMessage = MP_METINFOSOURCES;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_CLEAR))
					{
						iMessage = MP_CLEARCOMPLETED;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_PREALLOC))
					{
						if (bJustOne && !pPartFile->IsLastBlockComplete() && !pPartFile->IsPreallocated())
							iMessage = MP_PREALLOCATE;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_A4AF))
					{
						if (bJustOne && !bFileDone)
							iMessage = MP_ALL_A4AF_TO_HERE;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_A4AFAUTO))
					{
						if (bJustOne && !bFileDone)
							iMessage = MP_ALL_A4AF_AUTO;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_A4AFOTHER))
					{
						if (bJustOne && !bFileDone)
							iMessage = MP_ALL_A4AF_TO_OTHER;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK))
						iMessage = MP_GETED2KLINK;
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK_HTML))
						iMessage = MP_GETHTMLED2KLINK;
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK_SOURCE))
						iMessage = MP_GETSOURCEED2KLINK;
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK_HASH))
						iMessage = MP_GETHASH;
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_FILE_NAMECLEANUP))
					{
						if (!bJustOne || !bFileDone)
							iMessage = MP_DOCLEANUP;
					}
					else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_DL_A4AFSAMECAT))
					{
						if (bJustOne && !bFileDone)
							iMessage = MP_ALL_A4AF_SAMECAT;
					}
				}
			//	If the selected item is a source...
				else
				{
					CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

					if (pSourceItem != NULL)
						iMessage = GetClientListActionFromShortcutCode(nCode, pSourceItem->GetSource());
				}
			}
		}
		if (iMessage > 0)
		{
			PostMessage(WM_COMMAND, static_cast<WPARAM>(iMessage));
			return TRUE;
		}
	}

	return CMuleListCtrl::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AutoSetSourceFilters() automatically sets the source filters for a file based on its current state.
//	It is used for the "smart filtering" feature.
void CDownloadListCtrl::AutoSetSourceFilters(CPartFileDLItem *pFileItem)
{
	CPartFile			   *pPartFile = pFileItem->GetFile();
	EnumPartFileStatuses	eStatus = static_cast<_EnumPartFileStatuses>(pPartFile->GetPartFileStatusID());

//	If the file is downloading, show only uploading sources.
	if (eStatus == PS_DOWNLOADING)
	{
		pFileItem->FilterAllSources();
		pFileItem->m_bShowUploadingSources = true;
		if (g_App.m_pPrefs->GetSmartFilterShowOnQueue())
		{	//additionaly show "on queue" sources if enabled
			pFileItem->m_bShowOnQueueSources = true;
		}
	}
//	If the file is waiting, show only the sources whose upload queue we're on...
	else if (eStatus == PS_WAITINGFORSOURCE || eStatus == PS_STALLED)
	{
		pFileItem->FilterAllSources();
	//	If the file has no "on queue" sources, show only connecting/asking sources
		if (pPartFile->GetOnQueueSrcCount() == 0)
		{
			pFileItem->m_bShowConnectingSources = true;
			pFileItem->m_bShowConnectedSources = true;
		}
		else
		{
			pFileItem->m_bShowOnQueueSources = true;
		}
	}
	else
	{
		pFileItem->FilterNoSources();
	}
	UpdateSourceItems(pFileItem);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::ResetSourceFiltersForAllFiles()
{
	CDownloadList::PartFileItemVector	*pvecFileItems = g_App.m_pDownloadList->GetFileItems();

	for (uint32 i = 0; i < pvecFileItems->size(); i++)
	{
		(*pvecFileItems)[i]->FilterNoSources();
		UpdateFileItem((*pvecFileItems)[i]);
	}

	delete pvecFileItems;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.567
log
@Simplified logging system implementation.
@
text
@d19 1
a64 6
	m_iCurrentSortItem = DLCOL_FILENAME;
	m_bSortAscending = true;
	m_iSourceSortItem = DLCOL_FILENAME;
	m_bSortSourcesAscending = true;
	m_iSourceSortItem2 = -1;
	m_bSortSourcesAscending2 = true;
a65 1
	memzero(&m_byteSortAscending, sizeof(m_byteSortAscending));
d170 3
a172 15
		m_iCurrentSortItem = g_App.m_pPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD);
		m_bSortAscending = g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD);
		m_iSourceSortItem = g_App.m_pPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD2);
		m_bSortSourcesAscending = g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2);

		m_byteSortAscending[m_iCurrentSortItem] =
			(m_byteSortAscending[m_iCurrentSortItem] & ~1) | ((m_bSortAscending) ? 1 : 0);
		m_byteSortAscending[m_iSourceSortItem] =
			(m_byteSortAscending[m_iSourceSortItem] & ~2) | ((m_bSortSourcesAscending) ? 2 : 0);

		SetSortArrow(m_iCurrentSortItem, m_bSortAscending);

		uint32	dwSortCode =
			m_iCurrentSortItem | (m_bSortAscending ? MLC_SORTASC : MLC_SORTDESC) |
			((m_iSourceSortItem | (m_bSortSourcesAscending ? MLC_SORTASC : MLC_SORTDESC)) << 16);
d174 1
d3171 2
a3172 2
	int			iSubItem = pNMListView->iSubItem;
	byte		byteSortOrder = m_byteSortAscending[iSubItem];
d3174 2
d3179 1
d3182 1
a3182 4
			m_byteSortAscending[iSubItem] = byteSortOrder = static_cast<byte>(~(byteSortOrder ^ ~1));

		m_bSortAscending = (byteSortOrder & 1) ? true : false;
		SetSortArrow(m_iCurrentSortItem = iSubItem, m_bSortAscending);
d3184 1
d3186 1
a3186 1
		g_App.m_pPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD, m_bSortAscending);
d3190 1
d3193 1
a3193 4
			m_byteSortAscending[iSubItem] = byteSortOrder = static_cast<byte>(~(byteSortOrder ^ ~2));

		m_bSortSourcesAscending = (byteSortOrder & 2) ? true : false;
		SetSortArrow(m_iSourceSortItem = iSubItem, m_bSortSourcesAscending);
d3195 1
d3197 1
a3197 1
		g_App.m_pPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2, m_bSortSourcesAscending);
a3198 6
	m_iSourceSortItem2 = -1;

	uint32	dwSortCode =
		m_iCurrentSortItem | (m_bSortAscending ? MLC_SORTASC : MLC_SORTDESC) |
		((m_iSourceSortItem | (m_bSortSourcesAscending ? MLC_SORTASC : MLC_SORTDESC)) << 16) |
		(MLC_DONTSORT << 24);
a3229 1
	{
a3230 1
	}
a3233 1
	{
a3234 1
	}
a3240 1
		{
a3241 1
		}
a3284 1
			{
d3286 1
a3286 1
			}
a3293 1
				{
a3294 1
				}
a3295 1
				{
a3296 1
				}
d3351 5
a3355 4
		DWORD		dwFilesSortCode = g_App.m_pPrefs->GetDownloadSortCol();
		DWORD		dwSourceSortCode = g_App.m_pPrefs->GetSrcSortCol1();
		bool		bUseSourceSort2 = g_App.m_pPrefs->DoUseSrcSortCol2();
		DWORD		dwSourceSortCode2 = bUseSourceSort2 ? g_App.m_pPrefs->GetSrcSortCol2() : MLC_DONTSORT;
d3358 2
a3359 16
		m_bSortAscending = (dwFilesSortCode & MLC_SORTDESC) == 0;
		m_bSortSourcesAscending = (dwSourceSortCode & MLC_SORTDESC) == 0;
		m_iCurrentSortItem = dwFilesSortCode & MLC_COLUMNMASK;
		m_iSourceSortItem = dwSourceSortCode & MLC_COLUMNMASK;
		m_iSourceSortItem2 = bUseSourceSort2 ? (dwSourceSortCode2 & MLC_COLUMNMASK) : -1;

		if (bUseSourceSort2)
		{
			m_bSortSourcesAscending2 = (dwSourceSortCode2 & MLC_SORTDESC) == 0;
			m_byteSortAscending[m_iSourceSortItem2] =
				(m_byteSortAscending[m_iSourceSortItem2] & ~2) | ((m_bSortSourcesAscending2) ? 2 : 0);
		}
		m_byteSortAscending[m_iCurrentSortItem] =
			(m_byteSortAscending[m_iCurrentSortItem] & ~1) | ((m_bSortAscending) ? 1 : 0);
		m_byteSortAscending[m_iSourceSortItem] =
			(m_byteSortAscending[m_iSourceSortItem] & ~2) | ((m_bSortSourcesAscending) ? 2 : 0);
d3361 7
a3367 1
		SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
d4044 1
a4044 3
	{
		SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
	}
d4111 6
a4116 2
				if (m_iSourceSortItem2 == -1)
					SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending);
d4119 2
a4120 2
					SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending, 1);
					SetSortArrow(m_iSourceSortItem2, m_bSortSourcesAscending2, 2);
d4137 1
a4137 3
	{
		SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
	}
@


1.566
log
@Extended <Ctrl-+> processing to auto-resize list columns on the transfer window.
@
text
@d4073 1
a4073 1
	AddLogLine(true, IDS_NEWSERVERCONNECT, g_App.m_pPrefs->GetMaxSourcePerFile());
@


1.565
log
@Simplified column resize interface; Minor generic optimization; Reduced H-file dependency.
@
text
@d4136 1
d4138 1
a4138 13
				else
				{
					int		iItemCount = GetHeaderCtrl()->GetItemCount();
					NMHEADER	Hdr;

					for (int i = 0; i < iItemCount; i++)
					{
						if (!IsColumnHidden(i))
						{
							Hdr.iItem = i;
							OnNMDividerDoubleClick(&Hdr);
						}
					}
a4140 1
			bHandled = true;
a4154 1
				{
a4155 1
				}
d4158 2
a4159 2
					SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending,1);
					SetSortArrow(m_iSourceSortItem2, m_bSortSourcesAscending2,2);
@


1.564
log
@Allow search by file, hash, country and client software in source lists on transfer page (by client software in the download source list; by file and country in the upload and wait lists; by client software, hash and country in the known client list);
Fixed recently broken search in the transfer pane lists;
Increased transfer page list performance by not processing meaningless list control GetDispInfo requests;
Removed several ridiculous dynamic casts to improve list performance;
Reshuffled context command parsing for better performance.
@
text
@a17 3
// DownloadListCtrl.cpp : implementation file
//

d23 1
d1201 1
a1201 1
	if (IsColumnHidden(nColumn) || (pSourceItem == NULL))
d1875 1
a1875 1
	ExpandCollapseItem(pNMIA->iItem,EXPAND_COLLAPSE);
d3163 1
a3163 1
BOOL CDownloadListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader, LRESULT *pResult)
d3175 1
a3175 3
	{
		SetColumnWidth(iColumn,m_iColumnMaxWidths[iColumn]);
	}
d3177 1
a3177 3
	{
		CMuleListCtrl::OnNMDividerDoubleClick(pHeader,pResult);
	}
a3180 2

	return *pResult = TRUE;
d3863 1
a3863 1
//	Reset selection in UL, CL or QL lists
d3870 1
a3870 1
			if (posSelClient != NULL)
d3872 2
a3873 5
				while (posSelClient != NULL)
				{
					int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.GetNextSelectedItem(posSelClient);
					g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.SetItemState(iSelClientListIndex, (UINT)~LVIS_SELECTED, LVIS_SELECTED);
				}
d3876 1
d3879 1
a3879 1
			if (posSelClient != NULL)
d3881 2
a3882 5
				while (posSelClient != NULL)
				{
					int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.GetNextSelectedItem(posSelClient);
					g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.SetItemState(iSelClientListIndex, (UINT)~LVIS_SELECTED, LVIS_SELECTED);
				}
d3885 1
d3888 1
a3888 1
			if (posSelClient != NULL)
d3890 2
a3891 5
				while (posSelClient != NULL)
				{
					int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.GetNextSelectedItem(posSelClient);
					g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.SetItemState(iSelClientListIndex, (UINT)~LVIS_SELECTED, LVIS_SELECTED);
				}
a4139 2

					LRESULT		lDummy;
d4147 1
a4147 1
							OnNMDividerDoubleClick(&Hdr, &lDummy);
@


1.563
log
@Fixed crash caused by invalid pointers casting {Nestor};
Optimized use of dynamic casting (thanks Aw3);
Minor code cleanup.
@
text
@a773 1
			{
d779 1
a779 1
			}
a780 1
			{
d786 1
a786 1
			}
a787 1
			{
d793 1
a793 1
			}
a895 1
				{
a896 1
				}
a897 1
				{
a898 1
				}
a909 1
				{
a910 1
				}
a957 1
			{
d963 1
a963 1
			}
a1017 1
			{
d1035 1
a1035 1
			}
a1036 1
			{
d1054 1
a1054 1
			}
a1055 1
			{
a1056 1
				{
a1057 1
				}
a1062 1
					{
a1063 1
					}
d1074 1
a1074 1
			}
a2365 28
		//	Web services
			if (wParam >= MP_WEBURL && wParam <= MP_WEBURL + 64)
			{
				RunURL(pPartFile, g_App.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
			}

		//	Assign/Unassign to/from Category
			if (wParam >= MP_ASSIGNCAT && wParam <= MP_LASTASSIGNCAT)
			{
				while (!selectedList.IsEmpty())
				{
					CPartFile	*pSelectedFile = selectedList.GetHead();
					int			iUserCatIdx = wParam - MP_ASSIGNCAT;

					if (iUserCatIdx != 0)
						pSelectedFile->SetCatID(CCat::GetCatIDByUserIndex(iUserCatIdx));
					else
						pSelectedFile->SetCatID(CAT_NONE);
					selectedList.RemoveHead();
				}
			//	Hide the pPartFile if it's not in the displayed category
				ChangeCategoryByIndex(m_iCurTabIndex);
			//	Redraw the pPartFile in its new color assuming it is visible
				g_App.m_pDownloadList->UpdateFile(pPartFile);
			//	Update the category file counts
				g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
			}

a2368 1
				{
d2423 1
a2423 1
				}
d2442 1
d2461 1
d2480 1
d2499 1
a2511 1
					{
a2512 1
					}
d2514 1
a2526 1
					{
a2527 1
					}
d2529 1
d2592 1
a2604 1
					{
a2605 1
					}
d2608 1
a2636 1
					{
a2637 1
					}
d2639 1
a2653 1
					{
a2654 1
					}
d2656 1
a2657 1
				{
a2670 1
					{
a2671 1
					}
d2673 1
a2673 1
				}
d2992 27
d4430 1
a4430 1
	if ((pDispInfo->item.mask & (LVIF_TEXT | LVIF_PARAM)) == (LVIF_TEXT | LVIF_PARAM))
d4432 3
a4434 4
		CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(pDispInfo->item.lParam);
		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

		if (pFileItem != NULL && pFileItem->GetFile() != NULL)
d4436 2
a4437 19
			switch (pDispInfo->item.iSubItem)
			{
				case 0:
					if (pDispInfo->item.cchTextMax > 0)
					{
						_tcsncpy(pDispInfo->item.pszText, pFileItem->GetFile()->GetFileName(), pDispInfo->item.cchTextMax);
						pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
					}
					break;
				default:
				//	Shouldn't happen
					pDispInfo->item.pszText[0] = _T('\0');
					break;
			}
		}
		else
		{
#ifdef OLD_SOCKETS_ENABLED
			CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4439 1
a4439 1
			if (pSourceItem != NULL && pSourceItem->GetParentFile() != NULL)
d4443 3
a4445 6
					case 0:
						if (!pSourceItem->GetSource()->IsUserNameEmpty() && (pDispInfo->item.cchTextMax > 0))
						{
							_tcsncpy(pDispInfo->item.pszText, pSourceItem->GetSource()->GetUserName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
						}
a4447 1
					//	Shouldn't happen
d4452 24
d4477 1
a4477 1
			pDispInfo->item.pszText[0] = _T('\0');
d4479 1
d4481 2
a4486 1

a4487 1

d4491 1
a4491 3
	CMuleCtrlItem		*pItem = dynamic_cast<CMuleCtrlItem*>(pFileItem);

	InsertItem(LVIF_PARAM|LVIF_TEXT,iPos,LPSTR_TEXTCALLBACK,0,0,0,reinterpret_cast<LPARAM>(pItem));
d4497 1
a4497 3
	CMuleCtrlItem		*pItem = dynamic_cast<CMuleCtrlItem*>(pSourceItem);

	InsertItem(LVIF_PARAM|LVIF_TEXT,iPos,LPSTR_TEXTCALLBACK,0,0,0,reinterpret_cast<LPARAM>(pItem));
d4507 1
a4507 1
	find.lParam = reinterpret_cast<LPARAM>(dynamic_cast<CMuleCtrlItem*>(pFileItem));
d4518 1
a4518 1
	find.lParam = reinterpret_cast<LPARAM>(dynamic_cast<CMuleCtrlItem*>(pSourceItem));
@


1.562
log
@removed duplicated GetuserName() method
@
text
@d4441 1
a4441 1
    NMLVDISPINFO* pDispInfo = (NMLVDISPINFO*)pNMHDR;
d4452 1
a4452 1
	if (pDispInfo->item.mask & LVIF_TEXT)
a4455 1
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4474 1
a4474 1
		else if (pSourceItem != NULL && pSourceItem->GetParentFile() != NULL)
d4477 3
a4479 1
			switch (pDispInfo->item.iSubItem)
d4481 14
a4494 11
				case 0:
					if (!pSourceItem->GetSource()->IsUserNameEmpty() && (pDispInfo->item.cchTextMax > 0))
					{
						_tcsncpy(pDispInfo->item.pszText, pSourceItem->GetSource()->GetUserName(), pDispInfo->item.cchTextMax);
						pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
					}
					break;
				default:
				//	Shouldn't happen
					pDispInfo->item.pszText[0] = _T('\0');
					break;
d4500 2
a4501 6
		else
		{
			ASSERT(0);
		}
    }
    *pResult = 0;
@


1.561
log
@rolled back last changes.
@
text
@d1245 1
a1245 1
			pSource->GetUserName(&sClientName);
d3866 1
a3866 1
			pClient1->GetUserName(&strName1);
d3874 1
a3874 1
			pClient2->GetUserName(&strName2);
@


1.560
log
@changed the handlig of embedded GUI list header
@
text
@a165 2
	InitHeader();

d234 1
d244 1
a244 1
			m_pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d1617 1
d1645 1
a1645 1
	int			iNumColumns = m_pHeaderCtrl->GetItemCount();
d1654 1
a1654 1
			int		iColumn = m_pHeaderCtrl->OrderToIndex(iCurrent);
d1685 1
a1685 1
			int		iColumn = m_pHeaderCtrl->OrderToIndex(iCurrent);
d1708 1
a1708 1
					int		iNextColumn = m_pHeaderCtrl->OrderToIndex(iCurrent + 1);
d4176 1
a4176 1
					int		iItemCount = m_pHeaderCtrl->GetItemCount();
@


1.559
log
@Optimized setting title for client/file details dialog and selection of default property page,
@
text
@d166 2
a235 1
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
d245 1
a245 1
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
a1617 1
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
d1645 1
a1645 1
	int			iNumColumns = pHeaderCtrl->GetItemCount();
d1654 1
a1654 1
			int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
d1685 1
a1685 1
			int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
d1708 1
a1708 1
					int		iNextColumn = pHeaderCtrl->OrderToIndex(iCurrent + 1);
d4176 1
a4176 1
					int		iItemCount = GetHeaderCtrl()->GetItemCount();
@


1.558
log
@A better way to fix priority sorting (thanks Aw3).
@
text
@d2655 1
a2655 1
					CFileDetails		dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
d2662 1
a2662 1
					CFileDetails		dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
a2663 1
					dialog.SetActivePage(2);
d3066 1
a3066 1
					CClientDetails		dialog(GetResString(IDS_CD_TITLE), pSource, this, 0);
d4004 1
a4004 1
							CFileDetails FileDetailsDlg(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
d4063 1
a4063 1
				CClientDetails		dialog(GetResString(IDS_CD_TITLE), pSource, this, 0);
d4305 1
a4306 2
		CFileDetails		dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
		dialog.SetActivePage(1);
d4313 1
a4313 1
		CClientDetails		dialog(GetResString(IDS_CD_TITLE), pSource, this, 0);
@


1.557
log
@Fix priority sorting.
@
text
@d3543 3
a3545 2
			iCompare = (file1->GetPriority() << 1 | (file1->IsAutoPrioritized() ? 1 : 0))
				- (file2->GetPriority() << 1 | (file2->IsAutoPrioritized() ? 1 : 0));
@


1.556
log
@IDS_SRCFILTERMENU_NONEEDEDPARTS replaced with IDS_NONEEDEDPARTS.
@
text
@d3543 2
a3544 1
			iCompare = file1->GetPriority() - file2->GetPriority();
@


1.555
log
@Optimized string shortcut representation.
@
text
@d2121 1
a2121 1
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowNNPSources?MF_CHECKED:0),MP_SRCFILTER_NNP,GetResString(IDS_SRCFILTERMENU_NONEEDEDPARTS));
d2300 1
a2300 1
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowNNPSources?MF_CHECKED:0),MP_SRCFILTER_NNP,GetResString(IDS_SRCFILTERMENU_NONEEDEDPARTS));
@


1.554
log
@Added up to 20 sources to a link created with sources.
@
text
@d2108 4
a2111 4
			menuED2K.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1) + GetStringFromShortcutCode(SCUT_LINK, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2) + GetStringFromShortcutCode(SCUT_LINK_HTML, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK) + GetStringFromShortcutCode(SCUT_LINK_SOURCE, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING, MP_GETHASH, GetResString(IDS_COPYHASH) + GetStringFromShortcutCode(SCUT_LINK_HASH, SSP_TAB_PREFIX));
d2138 1
a2138 1
				MP_DOCLEANUP, GetResString(IDS_DOCLEANUP) + GetStringFromShortcutCode(SCUT_FILE_NAMECLEANUP, SSP_TAB_PREFIX));
d2144 1
a2144 1
				MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE) + GetStringFromShortcutCode(SCUT_DL_PREALLOC, SSP_TAB_PREFIX) );
d2155 2
a2156 2
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED), MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + GetStringFromShortcutCode(SCUT_DL_A4AF, SSP_TAB_PREFIX));
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED), MP_ALL_A4AF_SAMECAT, GetResString(IDS_ALL_A4AF_SAMECAT) + GetStringFromShortcutCode(SCUT_DL_A4AFSAMECAT, SSP_TAB_PREFIX));
d2159 1
a2159 1
				MF_CHECKED : MF_UNCHECKED ) : (MF_GRAYED | MF_UNCHECKED) ), MP_ALL_A4AF_AUTO, GetResString(IDS_TREE_DL_A4AF_AUTO) + GetStringFromShortcutCode(SCUT_DL_A4AFAUTO, SSP_TAB_PREFIX) );
d2161 1
a2161 1
				MP_ALL_A4AF_TO_OTHER, GetResString(IDS_ALL_A4AF_TO_OTHER) + GetStringFromShortcutCode(SCUT_DL_A4AFOTHER, SSP_TAB_PREFIX) );
d2197 1
a2197 1
			menuFile.AppendMenu(MF_STRING|((eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED), MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(SCUT_DL_CLEAR, SSP_TAB_PREFIX));
d2204 1
a2204 1
			menuFile.AppendMenu(MF_STRING|(!bFileDone ? MF_ENABLED : MF_GRAYED),MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL) + GetStringFromShortcutCode(SCUT_DL_CANCEL, SSP_TAB_PREFIX));
d2208 1
a2208 1
				MP_STOP, GetResString(IDS_STOP_VERB) + GetStringFromShortcutCode(SCUT_DL_STOP, SSP_TAB_PREFIX) );
d2212 1
a2212 1
				MP_PAUSE, GetResString(IDS_PAUSE_VERB) + GetStringFromShortcutCode(SCUT_DL_PAUSE, SSP_TAB_PREFIX) );
d2216 1
a2216 1
				MP_RESUME, GetResString(IDS_RESUME) + GetStringFromShortcutCode(SCUT_DL_RESUME, SSP_TAB_PREFIX) );
d2225 1
a2225 1
				MP_OPEN, GetResString(IDS_OPENFILE) + GetStringFromShortcutCode(SCUT_FILE_OPEN, SSP_TAB_PREFIX) );
d2229 1
a2229 1
				MP_OPENFOLDER, GetResString(IDS_OPENFOLDER) + GetStringFromShortcutCode(SCUT_FILE_OPENDIR, SSP_TAB_PREFIX) );
d2233 1
a2233 1
				MP_PREVIEW, GetResString(IDS_PREVIEW_VERB) + GetStringFromShortcutCode(SCUT_DL_PREVIEW, SSP_TAB_PREFIX) );
d2236 1
a2236 1
				GetResString(IDS_DL_INFO) + GetStringFromShortcutCode(SCUT_FILE_DETAILS, SSP_TAB_PREFIX) );
d2240 1
a2240 1
				MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + GetStringFromShortcutCode(SCUT_FILE_COMMENTS, SSP_TAB_PREFIX) );
d2268 1
a2268 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(SCUT_SRC_DETAILS, SSP_TAB_PREFIX));
d2270 1
a2270 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + GetStringFromShortcutCode(SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
d2272 2
a2273 2
				menuClient.AppendMenu(MF_STRING, MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + GetStringFromShortcutCode(SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING, MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(SCUT_SRC_MSG, SSP_TAB_PREFIX));
d2275 1
a2275 1
				MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(SCUT_SRC_SHAREDFILES, SSP_TAB_PREFIX) );
d2289 1
a2289 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARALLCOMPLETED, GetResString(IDS_TREE_DL_CLEAR_ALL_COMPLETED) + GetStringFromShortcutCode(SCUT_DL_CLEARALL, SSP_TAB_PREFIX));
@


1.553
log
@Corrected download list file selection after collapsing by keyboard to make item always visible {glaskrug};
Minor optimization to draw A4AF icon.
@
text
@d2711 1
a2711 1
							str += selectedList.GetHead()->CreateED2KSourceLink(7, 10);
d2720 1
a2720 1
						g_App.CopyTextToClipboard(pPartFile->CreateED2KSourceLink(7, 10));
@


1.552
log
@Fixed download list file selection after collapsing by keyboard {glaskrug} (taken from original).
@
text
@d662 4
a667 5
			//	Show that a file is A4AF auto
				if ( g_App.m_pPrefs->ShowFullFileStatusIcons()
					&& pPartFile == g_App.m_pDownloadQueue->GetA4AFAutoFile() && !bMeasuring )
					m_imageList.Draw(dc, DL_ICON_A4AFAUTO, point, ILD_TRANSPARENT);

d1973 1
@


1.551
log
@removed the set of ODA_SELECT action on item drawing
@
text
@d1726 1
a1726 1
	if ( (lpDrawItemStruct->itemState & ODS_SELECTED) && pFileItem != NULL )
d1970 5
@


1.550
log
@Suppressed compiler warnings; Shortened category services [Aw3].
@
text
@d1612 1
a1612 1
	if (pFileItem != NULL && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d1726 1
a1726 2
	if ( (lpDrawItemStruct->itemAction | ODA_SELECT)
	  && (lpDrawItemStruct->itemState & ODS_SELECTED) && pFileItem != NULL )
@


1.549
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d1020 1
a1020 1
					restTime = pPartFile->GetFlushTimeSpan().GetTotalSeconds();
d1096 1
a1096 1
				long		lWaitedSeconds = ts.GetTotalSeconds();
d1098 2
a1099 4
				if (lWaitedSeconds >= 15)
				{
					buffer = ::CastSecondsToHM(lWaitedSeconds);
				}
d1241 2
a1242 2
		byte				nDownloadState = pSource->GetDownloadState();
		CString				sClientName;
d1272 1
a1272 1
						switch (nDownloadState)
d1471 1
a1471 1
					(nDownloadState == DS_ONQUEUE || nDownloadState == DS_LOWID_ON_OTHER_SERVER) )
d1565 1
a1565 1
				if ( ((nDownloadState == DS_ONQUEUE) || (nDownloadState == DS_LOWID_ON_OTHER_SERVER))
d1568 1
a1568 3
					uint32		iSeconds = pSource->GetDLQueueWaitTime() / 1000.0;

					buffer = ::CastSecondsToHM(iSeconds);
d2175 1
a2175 1
				int		iFileCatIndex = CCat::CatIndexToUserCatIndex(CCat::GetCatIndexByID(pPartFile->GetCatID()));
d2184 1
a2184 1
						strBuffer = CCat::GetCatByIndex(CCat::UserCatIndexToCatIndex(i))->GetTitle();
d2390 2
a2391 6
					CPartFile	   *pSelectedFile = selectedList.GetHead();
					byte			iUserCatIndex = wParam - MP_ASSIGNCAT;

					if (iUserCatIndex != 0)
					{
						byte		iCatIndex = CCat::UserCatIndexToCatIndex(iUserCatIndex);
d2393 2
a2394 2
						pSelectedFile->SetCatID(CCat::GetCatIDByIndex(iCatIndex));
					}
a2395 1
					{
a2396 1
					}
d3223 1
a3223 1
			m_byteSortAscending[iSubItem] = byteSortOrder = ~(byteSortOrder ^ ~1);
d3235 1
a3235 1
			m_byteSortAscending[iSubItem] = byteSortOrder = ~(byteSortOrder ^ ~2);
d4331 1
a4331 1
void CDownloadListCtrl::ChangeCategoryByIndex(byte iNewCatIndex)
d4335 2
a4336 2
	m_iCurTabIndex = iNewCatIndex;
	m_eCurTabCat = CCat::GetCatIDByIndex(iNewCatIndex);
@


1.548
log
@Some formatting.
@
text
@d159 1
a159 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auColHdr); ui++)
d162 1
a162 1
	m_imageList.Create(16, 16, g_App.m_iDfltImageListColorFlags|ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
d164 1
a164 1
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ELEMENT_COUNT(s_auIconResID));
d240 1
a240 1
		for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auResTbl); ui++)
d1483 1
a1483 1
						if (iDifference == dwRemoteQueueRank)
d1644 1
a1644 1
	bool		bNotLast = lpDrawItemStruct->itemID + 1 != GetItemCount();
d1734 1
d1755 1
a1755 1
		dc->FrameRect(&rOutline, &CBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine));
d1760 2
a1761 1
		RECT focus_rec = lpDrawItemStruct->rcItem;
d1765 1
a1765 1
		dc->FrameRect(&focus_rec, &CBrush(m_crNoFocusLine));
d1811 2
a1812 1
			RECT circle_rec;
d1818 1
a1818 1
			dc->FrameRect(&circle_rec, &CBrush(dc->GetTextColor()));
d2049 1
d2332 1
d3232 1
a3232 1
		if ((m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
d3244 1
a3244 1
		if (((m_dwParamSort >> 16) & MLC_COLUMNMASK) == iSubItem)
d3454 1
d3910 1
a3910 1
					g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d3921 1
a3921 1
					g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d3932 1
a3932 1
					g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d4042 1
@


1.547
log
@fix time disappearing at midnight
@
text
@d653 1
a655 2
						default:
							iIcon = DL_ICON_STATUS_ERRONEOUS;
d696 1
a713 2
								default:
									iIcon = DL_ICON_RATING_NO;
@


1.546
log
@Simplified DrawText code -- no logic changed.
@
text
@d1044 1
a1044 1
					dc->DrawText(odtTime.Format(), &r, iCalcFlag);
d1064 1
a1064 1
					dc->DrawText(odtTime.Format(), &r, iCalcFlag);
d1162 1
a1162 1
						dc->DrawText(odtTime.Format(), &r, DT_RIGHT | iCalcFlag);
d1191 1
a1191 1
						dc->DrawText(odtTime.Format(), &r, DT_RIGHT | iCalcFlag);
@


1.545
log
@Fixed active "Assign to category" menu for complete files {Vladimir (SV)};
Fixed active "Web Services" menu in the download list when it's empty and there're some user defined categories.
@
text
@d767 1
a767 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d779 1
a779 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d787 1
a787 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d795 1
a795 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d820 1
a820 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d885 1
a885 1
						dc->DrawText(buffer, buffer.GetLength(), &r, DLC_DT_TEXT);
d918 1
a918 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d964 1
a964 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d972 1
a972 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d999 1
a999 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1025 1
a1025 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1035 1
a1035 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1055 1
a1055 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1090 1
a1090 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1104 1
a1104 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1122 1
a1122 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d1137 1
a1137 1
				dc->DrawText(buffer, buffer.GetLength(), &r, DT_RIGHT | iCalcFlag);
d1168 1
a1168 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1197 1
a1197 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1367 1
a1367 1
				dc->DrawText(strBuffer1, strBuffer1.GetLength(), &r2, iCalcFlag);
d1382 1
a1382 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
d1392 1
a1392 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
d1405 1
a1405 1
					dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
d1464 1
a1464 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1504 1
a1504 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag);
d1515 1
a1515 1
				dc->DrawText(sDownloadState, sDownloadState.GetLength(), &r, iCalcFlag);
d1528 1
a1528 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_LEFT);
d1541 1
a1541 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_LEFT);
d1549 1
a1549 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
d1557 1
a1557 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
d1579 1
a1579 1
				dc->DrawText(buffer, buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
@


1.544
log
@fix multimonitor control positionning and mouse click handling
@
text
@d2153 1
a2153 1
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED),MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + GetStringFromShortcutCode(SCUT_DL_A4AF, SSP_TAB_PREFIX));
d2174 1
a2174 1
			if (CCat::GetNumCats() > CCat::GetNumPredefinedCats())
d2177 1
a2179 4
				dwWebServicesEmptyFlag = MF_STRING;

				int		iFileCatIndex = CCat::CatIndexToUserCatIndex(CCat::GetCatIndexByID(pPartFile->GetCatID()));

a2182 1
					{
a2183 1
					}
d2195 1
a2195 1
			menuFile.AppendMenu(MF_STRING|((eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED),MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(SCUT_DL_CLEAR, SSP_TAB_PREFIX));
d2198 1
a2198 1
			menuFile.AppendMenu(dwNoUserCatsFlag|MF_POPUP,(UINT_PTR)catMenu.m_hMenu, GetResString(IDS_CAT_ASSIGN));
d2244 1
a2244 1
			menuFile.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)menuAdvanced.m_hMenu, GetResString(IDS_PW_ADVANCED));
d2246 1
a2246 1
			menuFile.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)menuED2K.m_hMenu, GetResString(IDS_ED2KLINKFIX));
d2248 1
a2248 1
			menuFile.AppendMenu(dwWebServicesEmptyFlag|MF_POPUP,(UINT_PTR)menuWeb.m_hMenu, GetResString(IDS_WEBSERVICES));
@


1.543
log
@removed unused structure
@
text
@d3941 1
a3941 1
	CPoint pt(LOWORD(pos), HIWORD(pos));
@


1.542
log
@Improve string processing;
Minor optimization and formatting for the client part of the download list.
@
text
@a1513 1
				POINT		point = {r.left, r.top + 1};
@


1.541
log
@Dropped generation of .dir files (importing is still supported).
@
text
@d560 1
a560 2
			if (pFileItem != NULL)
				pFileItem->ResetUpdateTimer();
a562 1
			{
a563 1
			}
d1104 2
a1105 2
				dc->DrawText(buffer,(int)_tcslen(buffer),&r, iCalcFlag);
				if (bMeasuring && buffer.GetLength() != 0)
a1245 1
		double				dblRemoteBaseModifier = pSource->GetRemoteBaseModifier();
a1255 1
		uint32				nDownloadDataRate = pSource->GetDownloadDataRate();
d1315 1
a1315 1
  					}
d1330 1
a1330 1
					else if (dblRemoteBaseModifier >= 1.1)
d1345 1
a1345 3
				{
					strBuffer1.Format(_T("[%s]"),GetResString(IDS_UNKNOWN));
				}
a1346 1
				{
a1347 1
				}
a1348 1
				{
a1349 1
				}
d1367 1
a1367 1
				dc->DrawText(strBuffer1,strBuffer1.GetLength(),&r2, iCalcFlag);
d1376 1
a1376 9
			{
#ifdef LATER
			//	MOREVIT: - display last part size
			//	TODO: (bug - want the CURRENT part)
				uint16		iLastPart = pSource->GetLastDownPartAsked();

				if (iLastPart != 0xFFFF && nDownloadState == DS_DOWNLOADING)
				{
					uint32		iPartSize = pSourceItem->GetFile()->GetPartSize(iLastPart);
a1377 11
					buffer = CastItoXBytes(iPartSize);
				}
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
				if (bMeasuring && !buffer.IsEmpty())
				{
					iWidth += r.right - r.left + 1;
				}
			//	:MOREVIT
#endif LATER
				break;
			}
a1378 1
			{
d1387 1
a1387 1
			}
a1388 1
			{
d1397 1
a1397 1
			}
a1398 1
			{
d1401 6
a1406 7
					if (nDownloadDataRate != 0)
					{
						buffer.Format(_T("%.1f"), nDownloadDataRate/1024.0f);
					}
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
					if (bMeasuring && buffer.GetLength() != 0)
					{
a1407 1
					}
d1410 1
a1410 1
			}
d1463 2
a1464 4
			{
				CString clientVerString = pSource->GetFullSoftVersionString();

				dc->DrawText(clientVerString,clientVerString.GetLength(),&r, iCalcFlag);
d1468 1
a1468 1
			}
a1505 1
				{
a1506 1
				}
a1507 1
				{
a1508 1
				}
d1516 1
a1516 1
				dc->DrawText(sDownloadState,sDownloadState.GetLength(),&r, iCalcFlag);
a1517 1
				{
a1518 1
				}
d1527 1
a1527 1
					buffer.Format(_T("%u: %s"), dwCurrPart, static_cast<LPCTSTR>(CastItoXBytes(dwRemainingSize)));
d1529 1
a1529 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_LEFT);
a1530 1
				{
a1531 1
				}
d1542 1
a1542 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_LEFT);
a1543 1
				{
a1544 1
				}
d1549 2
a1550 4
				{
					buffer.Format(_T("%0.1f"), dblRemoteBaseModifier);
				}
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
a1551 1
				{
a1552 1
				}
d1554 1
a1559 1
				{
a1560 1
				}
d1562 1
a1563 1
				break;
a1564 1
				break;
d1567 1
d1580 1
a1580 1
				dc->DrawText(buffer,buffer.GetLength(), &r, iCalcFlag | DT_RIGHT);
a1585 1
				break;
a1586 1
				break;
a1587 1
				break;
d1608 1
a1608 3
	if (!g_App.m_pMDlg->IsRunning())
		return;
	if (!lpDrawItemStruct->itemData)
@


1.540
log
@Added filename cleanup shortcut {Towelie};
Alternative file destination directory was moved to .part.settings (.part.dir is kept for a while for smooth up/downgrade) {Fuxie - DK};
Improved string processing; Slightly faster processing for file shortcuts.
@
text
@a2838 3
#if 1//temp migration of prev.setting -- remove in v1.2c
								pPFTmp->SavePartFile();
#endif
a2845 3
#if 1//temp migration of prev.setting -- remove in v1.2c
						pPartFile->SavePartFile();
#endif
@


1.539
log
@Renamed APP_STATE_SHUTINGDOWN -> APP_STATE_SHUTTINGDOWN.
@
text
@d2193 2
a2194 1
			menuAdvanced.AppendMenu(MF_STRING|((bJustOne && bFileDone) ? MF_GRAYED:MF_ENABLED),MP_DOCLEANUP, GetResString(IDS_DOCLEANUP));
d2839 1
d2841 2
d2849 1
d2851 2
d2865 1
a2865 1
							selFile->SetFileName(CleanupFilename(selFile->GetFileName()).GetBuffer());
a4701 1
				CSourceDLItem	   *pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4798 5
d4810 1
a4810 1
				else if (pSourceItem != NULL)
d4812 1
a4812 1
					CUpDownClient	   *pSource = pSourceItem->GetSource();
d4814 2
a4815 1
					iMessage = GetClientListActionFromShortcutCode(nCode, pSource);
@


1.538
log
@Fixed display of Waited Time in remove queue for 'Another Server LowID' sources;
Formatting.
@
text
@d4619 1
a4619 1
	if (::IsWindow(GetSafeHwnd()) && g_App.m_app_state != CEmuleApp::APP_STATE_SHUTINGDOWN)
@


1.537
log
@Simplified code.
@
text
@d1261 1
a1261 2
		bool				bNeverAskedBefore = pSource->GetLastSrcReqTime() == 0;
		bool				bCredits = pSource->m_pCredits != (CClientCredits*)NULL && pSource->m_pCredits != (CClientCredits*)-1;
d1413 1
a1413 1
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
a1414 1
					{
a1415 1
					}
d1424 1
a1424 1
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
a1425 1
					{
a1426 1
					}
a1502 1
				{
a1503 1
				}
d1622 1
a1622 1
				if ( nDownloadState == DS_ONQUEUE
d1632 1
a1632 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
a1633 1
				{
a1634 1
				}
d3892 1
a3892 2
			uint32		iWaitSeconds1 = pClient1->GetDLQueueWaitTime();
			uint32		iWaitSeconds2 = pClient2->GetDLQueueWaitTime();
d3894 9
a3902 5
			if (pClient1->GetDownloadState() != DS_ONQUEUE)
				iWaitSeconds1 = INT_MAX;
			if (pClient2->GetDownloadState() != DS_ONQUEUE)
				iWaitSeconds2 = INT_MAX;
			iCompare = ((iWaitSeconds1 < iWaitSeconds2) ? -1 : ((iWaitSeconds1 > iWaitSeconds2) ? 1 : 0));
@


1.536
log
@UNICODE preparations; optimizations; formattings.
@
text
@a2227 2
			int	iURLCnt;

a2228 3
			UpdateURLMenu(menuWeb, &iURLCnt);

			UINT	dwWebServicesEmptyFlag = MF_STRING | ((iURLCnt == 0) ? MF_GRAYED : 0);
d2230 1
@


1.535
log
@Formatting.
@
text
@d2211 1
a2211 1
			bool		bOneNotDone = (bJustOne && !bFileDone);
d2228 1
a2228 1
			int		iNumWebServiceURLs;
d2231 1
a2231 1
			UpdateURLMenu(menuWeb,iNumWebServiceURLs);
d2233 1
a2233 1
			UINT			dwWebServicesEmptyFlag = MF_STRING | ((iNumWebServiceURLs == 0) ? MF_GRAYED : 0);
d2236 1
a2236 1
			CTitleMenu		catMenu;
d2242 1
a2242 1
			UINT			dwNoUserCatsFlag = MF_STRING | MF_GRAYED;
@


1.534
log
@Disabled renaming of file completed while renaming in download list {Vladimir (SV)}.
@
text
@a455 1
	{
a456 1
	}
a467 1
//
a510 1
				{
a511 1
				}
d533 1
a533 1
	CDownloadList::SourceItemVector	   *pvecSourceItems = NULL;
a536 1
	{
a537 1
	}
a538 1
	{
a539 1
	}
a1976 1
	{
a1977 1
	}
a1982 2
	int		iNumAdded = 0;

d2018 1
d2025 1
a2025 1
						ListInsertSourceItem((*pvecSourceItems)[i], iItem+1);
d3840 1
a3840 1
				if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN )
d4605 1
a4605 3
	int iItem = FindItem(&find);

	return iItem;
d4616 1
a4616 3
	int		iItem = FindItem(&find);

	return iItem;
@


1.533
log
@Improved string processing.
@
text
@d2693 11
a2703 5
						pPartFile->SetFileName(strTemp);
						pPartFile->SavePartFile();
						pPartFile->UpdateDisplayedInfo();
						g_App.m_pSharedFilesList->UpdateItem((CKnownFile*)pPartFile);
						g_App.m_pMDlg->m_wndTransfer.UpdateInfoHeader();
@


1.532
log
@Large file size support preparations.
@
text
@a2682 1
					InputBox	inputbox;
d2686 3
a2688 2
					inputbox.SetLabels(strTemp, pPartFile->GetFileName());
					inputbox.SetEditFilenameMode();
@


1.531
log
@Large file size support preparations.
@
text
@d3596 1
a3596 1
			iCompare = CompareUnsigned(file1->GetTransferred(), file2->GetTransferred());
a3704 1
			{
a3705 1
			}
@


1.530
log
@Fixed sorting of erroneous files under 'Show paused and stopped files last' {Fuxie - DK}
(erroneous file are excluded from stopped/paused group);
Simplified/speeded up processing of partfile status.
@
text
@d991 1
a991 1
				uint32	dwRemaining = pPartFile->GetFileSize() - pPartFile->GetCompletedSize();
d993 1
a993 1
				buffer = CastItoXBytes(dwRemaining);
d999 1
a999 1
					double		dblRemainingPercent = 100.1 - pPartFile->GetPercentCompleted();
d1001 4
a1004 4
					if (dblRemainingPercent > 100.0)
						dblRemainingPercent = 100.0;
					else if (dwRemaining == 0)
						dblRemainingPercent = 0.0;
d1006 1
a1006 1
					dblRemainingPercent = floor(dblRemainingPercent * 10.0) / 10.0;
d1008 2
a1009 2
					buffer.AppendFormat( (floor(dblRemainingPercent) == dblRemainingPercent) ?
						_T(" [%.f%%]") : _T(" [%.1f%%]"), dblRemainingPercent );
d3592 1
a3592 1
			iCompare = CompareUnsigned(file1->GetFileSize(), file2->GetFileSize());
d3600 1
a3600 1
			iCompare = CompareUnsigned(file1->GetCompletedSize(), file2->GetCompletedSize());
d3634 2
a3635 2
			iCompare = CompareUnsigned( file1->GetFileSize()-file1->GetCompletedSize(),
										file2->GetFileSize()-file2->GetCompletedSize() );
d3673 2
a3674 2
					iCompare = CompareUnsigned( file1->GetFileSize()-file1->GetCompletedSize(),
												file2->GetFileSize()-file2->GetCompletedSize() );
d3769 2
a3770 2
					iCompare = CompareUnsigned( file1->GetFileSize() - file1->GetCompletedSize(),
												file2->GetFileSize() - file2->GetCompletedSize() );
@


1.529
log
@Renamed DS_LOWTOLOWIP -> DS_LOWTOLOWID.
@
text
@d2668 1
a2668 1
						if (pPartFile->GetStatus(true) == PS_READY)
d3567 1
d3570 8
a3577 10
		if (file1->IsPartFile() && !file1->IsCompleting())
		{
			iRank1 |= (file1->IsPaused()) ? 1 : 0;
			iRank1 |= (file1->IsStopped()) ? 2 : 0;
		}
		if (file2->IsPartFile() && !file2->IsCompleting())
		{
			iRank2 |= (file2->IsPaused()) ? 1 : 0;
			iRank2 |= (file2->IsStopped()) ? 2 : 0;
		}
d4066 1
a4066 1
									if (pPartFile->GetStatus(true) == PS_READY)
@


1.528
log
@Reduced H-file dependency.
@
text
@d406 1
a406 1
		  && ds == DS_LOWTOLOWIP )
d1308 1
a1308 1
							case DS_LOWTOLOWIP:
@


1.527
log
@Renamed IDS_QL_RATING into IDS_RATING.
@
text
@d24 2
d29 2
a30 2
#include ".\Details\ClientDetails.h"
#include ".\Details\FileDetails.h"
a41 2
// CDownloadListCtrl

a44 1
//#region message map
a59 1
//#endregion
d2037 1
a2037 1
						ListInsertSourceItem((*pvecSourceItems)[i],iItem+1);
@


1.526
log
@fixed source sorting when more than one client with status "Queue Full" exist
@
text
@d221 1
a221 1
		IDS_QL_RATING,
@


1.525
log
@Added shortcut for "Download from all A4AF sources (same category)" {Fuxie - DK};
Optimized path processing while running a comple file by double-click.
@
text
@d3866 2
a3867 2
				if (!pClient1->IsRemoteQueueFull() && !pClient2->IsRemoteQueueFull())
					iCompare = pClient1->GetRemoteQueueRank() - pClient2->GetRemoteQueueRank();
d3869 1
a3869 1
					iCompare = (pClient1->IsRemoteQueueFull()) ? 1 : -1;
d3872 1
a3872 1
				iCompare = pClient1->IsEmuleClient() ? -1: 1;
@


1.524
log
@Corrected list declaration (from original); Formatting.
@
text
@d2234 1
a2234 1
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED),MP_ALL_A4AF_SAMECAT, GetResString(IDS_ALL_A4AF_SAMECAT));
d4137 1
a4137 6
			{
				CString		strBuffer;

				strBuffer.Format(_T("%s\\%s"), pPartFile->GetPath(), pPartFile->GetFileName());
				ShellOpenFile(strBuffer);
			}
a4164 2
	EMULE_TRY

a4166 2

	EMULE_CATCH
d4817 5
@


1.523
log
@Removed not required image list cleanups (list is cleaned automatically in its destructor).
@
text
@d63 1
a63 1
IMPLEMENT_DYNAMIC(CDownloadListCtrl, CListBox)
d265 1
a265 1
		ListInsertFileItem(pFileItem,GetItemCount());
d1724 2
a1725 2
	BOOL		bNotLast = lpDrawItemStruct->itemID + 1 != GetItemCount();
	BOOL		bNotFirst = lpDrawItemStruct->itemID != 0;
d1861 3
a1863 3
		BOOL hasNext = bNotLast && pSourceItem2 != NULL;
		BOOL isOpenRoot = hasNext && pFileItem != NULL;
		BOOL isChild = pSourceItem != NULL;
a2015 1
		{
a2016 1
		}
@


1.522
log
@Renamed IDS_LASTCHANGE into IDS_LASTRECEPTION;
Removed duplicate string IDS_FD_LASTCHANGE & IDS_LASTSEENCOMPL.
@
text
@a80 5
	EMULE_TRY

	m_imageList.DeleteImageList();

	EMULE_CATCH
@


1.521
log
@fixed a flaw in ShowSourceItem() for the case when file doesn't exist
@
text
@d228 1
a228 1
		IDS_LASTCHANGE,
@


1.520
log
@UNICODE preparation (first shot)
@
text
@a4517 1
		int					iInsertionIndex = 0;
d4519 2
a4520 5
		if (iParentFileIndex > 0)
			iInsertionIndex = iParentFileIndex;
	//	Until we hit the end of the list or the next item is a file item...
		while ( iInsertionIndex+1 < GetItemCount()
				&& typeid(*ListGetItemAt(iInsertionIndex+1)) != typeid(CPartFileDLItem))
d4522 11
a4532 1
			iInsertionIndex++;
a4533 1
		ListInsertSourceItem(pSourceItem,iInsertionIndex+1);
@


1.519
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d250 1
a250 1
			hdi.pszText = (LPSTR)strRes.GetString();
@


1.518
log
@renamed 3 variables
@
text
@d178 1
a178 1
	if (g_App.g_pPrefs->DoUseSort())
d185 4
a188 4
		m_iCurrentSortItem = g_App.g_pPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD);
		m_bSortAscending = g_App.g_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD);
		m_iSourceSortItem = g_App.g_pPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD2);
		m_bSortSourcesAscending = g_App.g_pPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2);
d373 1
a373 1
		  && ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() > g_App.g_pPrefs->GetSmartFilterMaxQueueRank())
d639 1
a639 1
				if (g_App.g_pPrefs->ShowFullFileStatusIcons())
d685 1
a685 1
				if ( g_App.g_pPrefs->ShowFullFileStatusIcons()
d690 1
a690 1
				if (g_App.g_pPrefs->ShowFileTypeIcon())
d705 1
a705 1
				if (g_App.g_pPrefs->ShowRatingIcons())
d745 1
a745 1
				COLORREF	cr = (pPartFile->IsFakesDotRar() ? g_App.g_pPrefs->GetFakeListDownloadColor() : CCat::GetCatColorByID(pPartFile->GetCatID()));
d752 1
a752 1
					if (g_App.g_pPrefs->ShowPausedGray())
d829 1
a829 1
					if (g_App.g_pPrefs->GetShowAverageDataRate())
d836 1
a836 1
				else if (g_App.g_pPrefs->GetShowAverageDataRate())
d877 1
a877 1
						pPartFile->DrawStatusBar(&cdcStatus,  &rec_status, g_App.g_pPrefs->UseFlatBar());
d887 1
a887 1
					if (g_App.g_pPrefs->GetUseDwlPercentage())
d902 1
a902 1
							r.top += (g_App.g_pPrefs->UseFlatBar()) ? 3 : 2; // Just a little down
d931 1
a931 1
				if (g_App.g_pPrefs->IsA4AFCountEnabled() && (dwA4AFSourcesCount != 0))
d1033 1
a1033 1
					if (g_App.g_pPrefs->GetShowAverageDataRate())
d1325 1
a1325 1
						if (g_App.g_pPrefs->IsA4AFStringEnabled())
d1358 1
a1358 1
					if (g_App.g_pPrefs->ShowRatingIcons() && !g_App.m_pIP2Country->ShowCountryFlag())
d1427 1
a1427 1
				if (!bIsA4AF && nTransferredDown && !g_App.g_pPrefs->IsTransferredOnCompleted())
d1440 1
a1440 1
				if (!bIsA4AF && nTransferredDown && g_App.g_pPrefs->IsTransferredOnCompleted())
d1497 1
a1497 1
							pSource->DrawStatusBar(&cdcStatus,  &rec_status,(pSourceItem->IsAskedForAnotherFile()), g_App.g_pPrefs->UseFlatBar());
d2230 1
a2230 1
			menuAdvanced.AppendMenu(MF_STRING|(bFileDone && !g_App.g_pPrefs->GetAVPath().IsEmpty() && g_App.g_pPrefs->IsAVEnabled() ? MF_ENABLED:MF_GRAYED), MP_AV_SCAN, GetResString(IDS_AV_SCAN));
d2373 1
a2373 1
			menuClient.SetDefaultItem((g_App.g_pPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
d2554 2
a2555 2
											g_App.g_pPrefs->SetDLingFakeListVersion(0);
											g_App.g_pPrefs->SetDLingFakeListLink(_T(""));
d2941 1
a2941 1
					CString	strBuffer = g_App.g_pPrefs->GetAVParams();
d2953 1
a2953 1
					ShellExecute(NULL, _T("open"), g_App.g_pPrefs->GetAVPath(), strBuffer, NULL, SW_SHOW);
d3325 2
a3326 2
		g_App.g_pPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD, iSubItem);
		g_App.g_pPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD, m_bSortAscending);
d3337 2
a3338 2
		g_App.g_pPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD2, iSubItem);
		g_App.g_pPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2, m_bSortSourcesAscending);
d3509 4
a3512 4
		DWORD		dwFilesSortCode = g_App.g_pPrefs->GetDownloadSortCol();
		DWORD		dwSourceSortCode = g_App.g_pPrefs->GetSrcSortCol1();
		bool		bUseSourceSort2 = g_App.g_pPrefs->DoUseSrcSortCol2();
		DWORD		dwSourceSortCode2 = bUseSourceSort2 ? g_App.g_pPrefs->GetSrcSortCol2() : MLC_DONTSORT;
d3574 1
a3574 1
	if (g_App.g_pPrefs->DoPausedStoppedLast())
d3820 1
a3820 1
			if (!g_App.g_pPrefs->IsTransferredOnCompleted())
d3825 1
a3825 1
			if (g_App.g_pPrefs->IsTransferredOnCompleted())
d4056 1
a4056 1
				if (g_App.g_pPrefs->ShowFullFileStatusIcons())
d4087 1
a4087 1
				if (!pProcessed && g_App.g_pPrefs->ShowFileTypeIcon())
d4156 1
a4156 1
			if (g_App.g_pPrefs->GetDetailsOnClick())
d4200 1
a4200 1
		     && pFileItem->GetFile()->GetSourceCount() <= g_App.g_pPrefs->GetMaxSourcePerFile() )
d4209 1
a4209 1
	AddLogLine(true, IDS_NEWSERVERCONNECT, g_App.g_pPrefs->GetMaxSourcePerFile());
d4710 1
a4710 1
		if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_DEFSORT))
d4712 1
a4712 1
			if (g_App.g_pPrefs->DoUseSort())
d4715 1
a4715 1
		else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_CLEARALL))
d4719 1
a4719 1
		else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_SHOWALL))
d4741 1
a4741 1
					if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_CANCEL))
d4746 1
a4746 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_STOP))
d4751 1
a4751 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_PAUSE))
d4756 1
a4756 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_RESUME))
d4761 1
a4761 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_FILE_OPEN))
d4766 1
a4766 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_FILE_OPENDIR))
d4771 1
a4771 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_PREVIEW))
d4776 1
a4776 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_FILE_RENAME))
d4781 1
a4781 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_FILE_COMMENTS))
d4786 1
a4786 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_FILE_DETAILS))
d4791 1
a4791 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_FD_SOURCES))
d4796 1
a4796 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_CLEAR))
d4800 1
a4800 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_PREALLOC))
d4805 1
a4805 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_A4AF))
d4810 1
a4810 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_A4AFAUTO))
d4815 1
a4815 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_DL_A4AFOTHER))
d4820 1
a4820 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK))
d4822 1
a4822 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK_HTML))
d4824 1
a4824 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK_SOURCE))
d4826 1
a4826 1
					else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK_HASH))
d4860 1
a4860 1
		if (g_App.g_pPrefs->GetSmartFilterShowOnQueue())
@


1.517
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d148 1
a148 1
	ilDummyImageList.Create(1, 17, g_eMuleApp.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
d169 1
a169 1
	m_imageList.Create(16, 16, g_eMuleApp.m_iDfltImageListColorFlags|ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
d178 1
a178 1
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())
d185 4
a188 4
		m_iCurrentSortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD);
		m_bSortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD);
		m_iSourceSortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD2);
		m_bSortSourcesAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2);
d322 1
a322 1
	if (pSourceItem != NULL && ::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_pdlgEmule->IsRunning())
d373 1
a373 1
		  && ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() > g_eMuleApp.m_pGlobPrefs->GetSmartFilterMaxQueueRank())
d462 1
a462 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning() || pFileItem == NULL)
d468 2
a469 2
	if ( g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_FILE
	  && g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetFile() == pFileItem->GetFile() )
d472 1
a472 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d494 1
a494 1
	if (pSourceItem != NULL && ::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_pdlgEmule->IsRunning())
d533 1
a533 1
	CDownloadList::PartFileItemVector	*pvecFileItems = g_eMuleApp.m_pDownloadList->GetFileItems();
d550 1
a550 1
		pvecSourceItems = g_eMuleApp.m_pDownloadList->GetSourceItems();
d569 1
a569 1
	if (pFileItem != NULL && ::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_pdlgEmule->IsRunning())
d639 1
a639 1
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d685 2
a686 2
				if ( g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons()
					&& pPartFile == g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() && !bMeasuring )
d690 1
a690 1
				if (g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
d694 1
a694 1
						int		iImage = g_eMuleApp.GetFileTypeSystemImageIdx(pPartFile->GetFileName());
d696 2
a697 2
						if (g_eMuleApp.GetSystemImageList() != NULL)
							::ImageList_Draw(g_eMuleApp.GetSystemImageList(), iImage, dc->GetSafeHdc(), r.left, r.top+1, ILD_TRANSPARENT);
d705 1
a705 1
				if (g_eMuleApp.m_pGlobPrefs->ShowRatingIcons())
d745 1
a745 1
				COLORREF	cr = (pPartFile->IsFakesDotRar() ? g_eMuleApp.m_pGlobPrefs->GetFakeListDownloadColor() : CCat::GetCatColorByID(pPartFile->GetCatID()));
d752 1
a752 1
					if (g_eMuleApp.m_pGlobPrefs->ShowPausedGray())
d829 1
a829 1
					if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
d836 1
a836 1
				else if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
d877 1
a877 1
						pPartFile->DrawStatusBar(&cdcStatus,  &rec_status, g_eMuleApp.m_pGlobPrefs->UseFlatBar());
d887 1
a887 1
					if (g_eMuleApp.m_pGlobPrefs->GetUseDwlPercentage())
d902 1
a902 1
							r.top += (g_eMuleApp.m_pGlobPrefs->UseFlatBar()) ? 3 : 2; // Just a little down
d931 1
a931 1
				if (g_eMuleApp.m_pGlobPrefs->IsA4AFCountEnabled() && (dwA4AFSourcesCount != 0))
d1033 1
a1033 1
					if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
d1325 1
a1325 1
						if (g_eMuleApp.m_pGlobPrefs->IsA4AFStringEnabled())
d1356 1
a1356 1
					g_eMuleApp.m_pdlgEmule->m_clientImgLists[iImgLstIdx].Draw(dc, pSource->GetClientIconIndex(), point, ILD_NORMAL);
d1358 1
a1358 1
					if (g_eMuleApp.m_pGlobPrefs->ShowRatingIcons() && !g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d1387 1
a1387 1
				if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d1391 1
a1391 1
					g_eMuleApp.m_pIP2Country->GetFlagImageList()->Draw(dc, pSource->GetCountryIndex(), point, ILD_NORMAL);
d1427 1
a1427 1
				if (!bIsA4AF && nTransferredDown && !g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
d1440 1
a1440 1
				if (!bIsA4AF && nTransferredDown && g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
d1497 1
a1497 1
							pSource->DrawStatusBar(&cdcStatus,  &rec_status,(pSourceItem->IsAskedForAnotherFile()), g_eMuleApp.m_pGlobPrefs->UseFlatBar());
d1688 1
a1688 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d2089 1
a2089 1
				CDownloadList::PartFileItemVector	   *pvecDirtyFileItems = g_eMuleApp.m_pDownloadList->GetDirtyFiles();
d2103 1
a2103 1
				CDownloadList::SourceItemVector	   *pvecDirtySources = g_eMuleApp.m_pDownloadList->GetDirtySources();
d2161 1
a2161 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_FILE, pPartFile);
d2230 1
a2230 1
			menuAdvanced.AppendMenu(MF_STRING|(bFileDone && !g_eMuleApp.m_pGlobPrefs->GetAVPath().IsEmpty() && g_eMuleApp.m_pGlobPrefs->IsAVEnabled() ? MF_ENABLED:MF_GRAYED), MP_AV_SCAN, GetResString(IDS_AV_SCAN));
d2243 1
a2243 1
				( (pPartFile == g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile()) ?
d2356 1
a2356 1
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, const_cast<CUpDownClient*>(pSource));
d2373 1
a2373 1
			menuClient.SetDefaultItem((g_eMuleApp.m_pGlobPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
d2434 1
a2434 1
			g_eMuleApp.m_pDownloadList->ClearCompleted(CAT_NONE);
d2479 1
a2479 1
				RunURL(pPartFile, g_eMuleApp.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
d2505 1
a2505 1
				g_eMuleApp.m_pDownloadList->UpdateFile(pPartFile);
d2507 1
a2507 1
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d2554 2
a2555 2
											g_eMuleApp.m_pGlobPrefs->SetDLingFakeListVersion(0);
											g_eMuleApp.m_pGlobPrefs->SetDLingFakeListLink(_T(""));
d2564 1
a2564 1
							g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d2678 1
a2678 1
							g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(pPartFile);
d2705 2
a2706 2
						g_eMuleApp.m_pSharedFilesList->UpdateItem((CKnownFile*)pPartFile);
						g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d2736 1
a2736 1
							g_eMuleApp.m_pDownloadList->ClearCompleted(pSelected);
d2742 1
a2742 1
						g_eMuleApp.m_pDownloadList->ClearCompleted(pPartFile);
d2772 1
a2772 1
						g_eMuleApp.CopyTextToClipboard(str);
d2776 1
a2776 1
						g_eMuleApp.CopyTextToClipboard(pPartFile->CreateED2kLink());
d2790 1
a2790 1
						g_eMuleApp.CopyTextToClipboard(str);
d2794 1
a2794 1
						g_eMuleApp.CopyTextToClipboard(pPartFile->CreateHTMLED2kLink());
d2809 1
a2809 1
						g_eMuleApp.CopyTextToClipboard(str);
d2813 1
a2813 1
						g_eMuleApp.CopyTextToClipboard(pPartFile->CreateED2KSourceLink(7, 10));
d2828 1
a2828 1
						g_eMuleApp.CopyTextToClipboard(str);
d2854 1
a2854 1
					CString newpath = BrowseFolder(g_eMuleApp.m_pdlgEmule->m_hWnd, GetResString(IDS_SELECTOUTPUTDIR), strDir);
d2889 1
a2889 1
							g_eMuleApp.m_pSharedFilesList->UpdateItem((CKnownFile*)selFile);
d2904 1
a2904 1
					if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == pPartFile)
d2906 1
a2906 1
						g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(NULL);
d2909 1
a2909 1
						g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(pPartFile);
d2941 1
a2941 1
					CString	strBuffer = g_eMuleApp.m_pGlobPrefs->GetAVParams();
d2953 1
a2953 1
					ShellExecute(NULL, _T("open"), g_eMuleApp.m_pGlobPrefs->GetAVPath(), strBuffer, NULL, SW_SHOW);
d3150 1
a3150 1
					g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(pSource);
d3153 1
a3153 1
					g_eMuleApp.m_pFriendList->AddFriend(pSource);
d3156 1
a3156 1
					g_eMuleApp.m_pFriendList->RemoveFriend(pSource);
d3325 2
a3326 2
		g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD, iSubItem);
		g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD, m_bSortAscending);
d3337 2
a3338 2
		g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD2, iSubItem);
		g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2, m_bSortSourcesAscending);
d3509 4
a3512 4
		DWORD		dwFilesSortCode = g_eMuleApp.m_pGlobPrefs->GetDownloadSortCol();
		DWORD		dwSourceSortCode = g_eMuleApp.m_pGlobPrefs->GetSrcSortCol1();
		bool		bUseSourceSort2 = g_eMuleApp.m_pGlobPrefs->DoUseSrcSortCol2();
		DWORD		dwSourceSortCode2 = bUseSourceSort2 ? g_eMuleApp.m_pGlobPrefs->GetSrcSortCol2() : MLC_DONTSORT;
d3574 1
a3574 1
	if (g_eMuleApp.m_pGlobPrefs->DoPausedStoppedLast())
d3820 1
a3820 1
			if (!g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
d3825 1
a3825 1
			if (g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
d3987 1
a3987 1
	switch (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_nActiveWnd)
d3990 1
a3990 1
			posSelClient = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.GetFirstSelectedItemPosition();
d3995 2
a3996 2
					int iSelClientListIndex = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.GetNextSelectedItem(posSelClient);
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d4001 1
a4001 1
			posSelClient = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.GetFirstSelectedItemPosition();
d4006 2
a4007 2
					int iSelClientListIndex = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.GetNextSelectedItem(posSelClient);
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d4012 1
a4012 1
			posSelClient = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.GetFirstSelectedItemPosition();
d4017 2
a4018 2
					int iSelClientListIndex = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.GetNextSelectedItem(posSelClient);
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d4056 1
a4056 1
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d4071 1
a4071 1
									g_eMuleApp.m_pDownloadList->ClearCompleted(pPartFile);
d4077 1
a4077 1
										g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(pPartFile);
d4087 1
a4087 1
				if (!pProcessed && g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
d4156 1
a4156 1
			if (g_eMuleApp.m_pGlobPrefs->GetDetailsOnClick())
d4164 1
a4164 1
				g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(pSource);
d4200 1
a4200 1
		     && pFileItem->GetFile()->GetSourceCount() <= g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() )
d4209 1
a4209 1
	AddLogLine(true, IDS_NEWSERVERCONNECT, g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
d4234 1
a4234 1
	CDownloadList::PartFileItemVector	   *pvecFileItems = g_eMuleApp.m_pDownloadList->GetFileItems();
d4344 1
a4344 1
	 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d4356 1
a4356 1
	 			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_FILE,const_cast<CPartFile*>(pPartFile));
d4363 1
a4363 1
	 			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,const_cast<CUpDownClient*>(pSource));
d4375 1
a4375 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateDownloadHeader();
d4443 1
a4443 1
	CDownloadList::PartFileItemVector	   *pvecPartFileItems = g_eMuleApp.m_pDownloadList->GetFileItems();
d4655 1
a4655 1
	if (::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_app_state != CEmuleApp::APP_STATE_SHUTINGDOWN)
d4710 1
a4710 1
		if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_DEFSORT))
d4712 1
a4712 1
			if (g_eMuleApp.m_pGlobPrefs->DoUseSort())
d4715 1
a4715 1
		else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_CLEARALL))
d4719 1
a4719 1
		else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_SHOWALL))
d4741 1
a4741 1
					if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_CANCEL))
d4746 1
a4746 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_STOP))
d4751 1
a4751 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_PAUSE))
d4756 1
a4756 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_RESUME))
d4761 1
a4761 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_FILE_OPEN))
d4766 1
a4766 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_FILE_OPENDIR))
d4771 1
a4771 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_PREVIEW))
d4776 1
a4776 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_FILE_RENAME))
d4781 1
a4781 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_FILE_COMMENTS))
d4786 1
a4786 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_FILE_DETAILS))
d4791 1
a4791 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_FD_SOURCES))
d4796 1
a4796 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_CLEAR))
d4800 1
a4800 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_PREALLOC))
d4805 1
a4805 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_A4AF))
d4810 1
a4810 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_A4AFAUTO))
d4815 1
a4815 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_DL_A4AFOTHER))
d4820 1
a4820 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK))
d4822 1
a4822 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK_HTML))
d4824 1
a4824 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK_SOURCE))
d4826 1
a4826 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK_HASH))
d4860 1
a4860 1
		if (g_eMuleApp.m_pGlobPrefs->GetSmartFilterShowOnQueue())
d4889 1
a4889 1
	CDownloadList::PartFileItemVector	*pvecFileItems = g_eMuleApp.m_pDownloadList->GetFileItems();
@


1.516
log
@Removed Fake check/report context menu items.
@
text
@d406 1
a406 1
		  && ds == DS_TOOMANYCONNS )
a1302 1
							case DS_TOOMANYCONNS:
@


1.515
log
@One more step to integrate eklmn's SSDQ.
@
text
@a2223 3
			menuAdvanced.AppendMenu(MF_STRING|(bJustOne ? MF_ENABLED:MF_GRAYED),MP_FAKE_CHECK,GetResString(IDS_FAKE_CHECK));
			menuAdvanced.AppendMenu(MF_STRING|(bJustOne ? MF_ENABLED:MF_GRAYED),MP_FAKE_REPORT,GetResString(IDS_FAKE_REPORT));
			menuAdvanced.AppendMenu(MF_SEPARATOR);
a2837 10
				case MP_FAKE_REPORT:
					if (iNumSelected == 1)
						RunURL(pPartFile, _T("http://donkeyfakes.gambri.net/report.php?link=ed2k://|file|#filename|#filesize|#hashid|/"));
					break;

				case MP_FAKE_CHECK:
					if (iNumSelected == 1)
						RunURL(pPartFile, _T("http://donkeyfakes.gambri.net/index.php?action=search&hash=#hashid"));
					break;

@


1.514
log
@Unified processing of part and temporary file names.
@
text
@d417 6
d1308 1
d2211 1
d2401 1
d3066 12
d3235 5
d4692 1
d4710 1
@


1.513
log
@Corrected sorting by progress in some rare cases {gotrek};
Slightly faster sorting by progress.
@
text
@d2829 1
a2829 1
						ShellOpenFile(pPartFile->GetFullName());
@


1.512
log
@Some eklmn's modifications.
@
text
@d3611 4
a3614 3
			if (dblComp < .01 && dblComp > -.01)
				break;	// iCompare = 0;
			iCompare = (dblComp > 0) ? 1 : -1;
@


1.511
log
@One more step to integrate eklmn's SSDQ; Formatting;
Changed return type of GetNotCurrentSourcesCount.
@
text
@d405 1
a405 1
		if ( !(pFileItem->m_bShowTooManyConnSources && m_bShowTooManyConnSources)
d417 2
a418 1
	//	If we're filtering out banned clients and this source has been banned...
d420 1
a420 1
		  && ds == DS_BANNED )
d1298 1
d2202 1
a2202 1
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowTooManyConnSources?MF_CHECKED:0),MP_SRCFILTER_TOOMANYCONN,GetResString(IDS_SRCFILTERMENU_TOOMANYCONN));
d2391 1
a2391 1
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowTooManyConnSources?MF_CHECKED:0),MP_SRCFILTER_TOOMANYCONN,GetResString(IDS_SRCFILTERMENU_TOOMANYCONN));
d3033 1
a3033 1
				case MP_SRCFILTER_TOOMANYCONN:
d3038 1
a3038 1
							selectedItemList.GetHead()->m_bShowTooManyConnSources = !selectedItemList.GetHead()->m_bShowTooManyConnSources;
d3204 2
a3205 2
			case MP_SRCFILTER_TOOMANYCONN:
				m_bShowTooManyConnSources = !m_bShowTooManyConnSources;
d4663 1
a4663 1
	m_bShowTooManyConnSources = true;
d4680 1
a4680 1
	m_bShowTooManyConnSources = false;
@


1.510
log
@IDS_UNKNOWN substitutes IDS_SRCFILTERMENU_UNKNOWN.
@
text
@d911 1
a911 1
				uint32		dwNotCurrentSourcesCount = static_cast<uint32>(pPartFile->GetNotCurrentSourcesCount());
d1526 2
a1527 1
				if (pSource->IsEmuleClient() && !pSourceItem->IsAskedForAnotherFile() && nDownloadState == DS_ONQUEUE)
d1550 1
a1550 8
							if (iDifference < 0)
							{
								dc->SetTextColor((COLORREF)RGB(10,160,70));
							}
							else
							{
								dc->SetTextColor((COLORREF)RGB(190,60,60));
							}
d3802 2
a3803 4
		{
		//	See below
			break;
		}
a3804 1
		{
d3806 1
a3806 1
			    iCompare = CompareUnsigned(pClient1->GetTransferredDown(), pClient2->GetTransferredDown());
d3808 1
a3808 1
		}
a3809 1
		{
d3813 1
a3813 1
		}
a3814 1
		{
d3817 1
a3817 1
		}
a3818 1
		{
d3821 1
a3821 1
		}
a3822 1
		{
d3835 1
a3835 1
		}
d3838 4
a3841 1
			if (pClient1->GetDownloadState()!=DS_ONQUEUE || pClient2->GetDownloadState()!=DS_ONQUEUE)
d3853 1
a3853 1
					iCompare = (pClient1->GetDownloadState()!=DS_ONQUEUE)?((pClient2->GetDownloadState()!=DS_ONQUEUE)?0:1):-1;
a3867 1
		{
d3870 1
a3870 1
		}
a3903 1
		{
d3905 1
a3905 1
		}
a3908 1
			byte		ds1 = pClient1->GetDownloadState();
a3909 1
			byte		ds2 = pClient2->GetDownloadState();
d3911 1
a3911 2
			if (ds1 != DS_ONQUEUE)
			{
d3913 1
a3913 3
			}
			if (ds2 != DS_ONQUEUE)
			{
a3914 1
			}
a3921 1
		{
d3923 1
a3923 1
		}
a3931 1
		{
a3933 1
		}
@


1.509
log
@Removed logging of a complete file run by double-click in the download list.
@
text
@d2211 1
a2211 1
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowUnknownSources?MF_CHECKED:0),MP_SRCFILTER_UNKNOWN,GetResString(IDS_SRCFILTERMENU_UNKNOWN));
d2400 1
a2400 1
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUnknownSources?MF_CHECKED:0),MP_SRCFILTER_UNKNOWN,GetResString(IDS_SRCFILTERMENU_UNKNOWN));
@


1.508
log
@Corrections for SSDQ integration.
@
text
@a4153 1
				AddLogLine(false, _T("%s"), strBuffer);
@


1.507
log
@IDS_DL_STOP renamed into IDS_STOP_VERB;
IDS_DL_PAUSE renamed into IDS_PAUSE_VERB;
IDS_DL_RESUME renamed into IDS_RESUME;
IDS_DL_PREVIEW renamed into IDS_PREVIEW_VERB.
@
text
@d1526 1
a1526 1
				if ( pSource->IsEmuleClient() && !pSourceItem->IsAskedForAnotherFile() && nDownloadState == DS_ONQUEUE)
d2927 1
a2927 1
					pPartFile->GetCopySourceList(DS_CONNECTING, DS_LAST_QUEUED_STATE, &clientListCopy);
@


1.506
log
@IDS_DL_OPEN renamed into IDS_OPENFILE.
@
text
@d2302 1
a2302 1
				MP_STOP, GetResString(IDS_DL_STOP) + GetStringFromShortcutCode(SCUT_DL_STOP, SSP_TAB_PREFIX) );
d2306 1
a2306 1
				MP_PAUSE, GetResString(IDS_DL_PAUSE) + GetStringFromShortcutCode(SCUT_DL_PAUSE, SSP_TAB_PREFIX) );
d2310 1
a2310 1
				MP_RESUME, GetResString(IDS_DL_RESUME) + GetStringFromShortcutCode(SCUT_DL_RESUME, SSP_TAB_PREFIX) );
d2327 1
a2327 1
				MP_PREVIEW, GetResString(IDS_DL_PREVIEW) + GetStringFromShortcutCode(SCUT_DL_PREVIEW, SSP_TAB_PREFIX) );
@


1.505
log
@new way of queue handling
@
text
@d2319 1
a2319 1
				MP_OPEN, GetResString(IDS_DL_OPEN) + GetStringFromShortcutCode(SCUT_FILE_OPEN, SSP_TAB_PREFIX) );
@


1.504
log
@IDS_TREE_DL_A4AF_AUTO is used for context menu to simplify processing.
@
text
@d1526 1
a1526 1
				if ( !pSourceItem->IsAskedForAnotherFile() && nDownloadState == DS_ONQUEUE)
d1528 1
a1528 3
				// show the QR status only if the cliet sent us OP_QUEUERANKING packet, i.e. remote client support
				// eMule protocol
					if (pSource->IsQueueRankReceived())
d1530 12
a1541 1
						if (dwRemoteQueueRank == 0)
d1543 3
a1545 1
							GetResString(&buffer, IDS_QUEUEFULL);
d1549 1
a1549 8
							int		iDifference = pSource->GetDifference();

							if (iDifference == dwRemoteQueueRank)
							{
							//	Initial QR -- just one QR was received
								buffer.Format(_T("QR: %u"), dwRemoteQueueRank);
							}
							else if (iDifference == 0)
d1551 1
a1551 3
								dc->SetTextColor((COLORREF)RGB(5,65,195));
								bIsColorChanged = true;
								buffer.Format(_T("QR: %u"), dwRemoteQueueRank);
d1555 1
a1555 10
								if (iDifference < 0)
								{
									dc->SetTextColor((COLORREF)RGB(10,160,70));
								}
								else
								{
									dc->SetTextColor((COLORREF)RGB(190,60,60));
								}
								bIsColorChanged = true;
								buffer.Format(_T("QR: %u (%+i)"), dwRemoteQueueRank, iDifference);
d1557 2
a1560 6
				// sometimes an eMule clies does not send us a QR (perphas he wants to save a bandwidth on clients outside the waiting queue)
				// in this case the QR is unknow what can be interpreted as "Queue Full"
					else if (pSource->IsEmuleClient())
					{
						GetResString(&buffer, IDS_QUEUEFULL);
					}
d3868 2
a3869 12
				if (pClient1->IsQueueRankReceived())
				{
					if (pClient2->IsQueueRankReceived())
					{
						if (!pClient1->IsRemoteQueueFull())
							iCompare = pClient2->IsRemoteQueueFull() ? -1: (pClient1->GetRemoteQueueRank() - pClient2->GetRemoteQueueRank());
						else
							iCompare = 1;
					}
					else
						iCompare = pClient1->IsRemoteQueueFull() ? 0: -1;
				}
d3871 1
a3871 3
				{
					iCompare = pClient2->IsQueueRankReceived() ? (pClient2->IsRemoteQueueFull() ? 0: 1) : 0; 
				}
@


1.503
log
@Simplified transition to eklmn's SSDQ.
@
text
@a2252 5

			CString		strBuffer = GetResString(IDS_ALL_A4AF_TO_HERE);

			strBuffer.AppendFormat(_T(" (%s)%s"), GetResString(IDS_PRIOAUTO).MakeLower(),
				GetStringFromShortcutCode(SCUT_DL_A4AFAUTO, SSP_TAB_PREFIX));
d2255 1
a2255 1
				MF_CHECKED : MF_UNCHECKED ) : (MF_GRAYED | MF_UNCHECKED) ), MP_ALL_A4AF_AUTO, strBuffer );
d2278 2
@


1.502
log
@Copy file hash to clipboard (context menu and shortcut) {DoubleT};
Removed colon from MP_CLEARALLCOMPLETED; Formatting.
@
text
@d2936 7
d2944 1
a2944 13
						SetRedraw(false);

						for (int sl=0; sl < SOURCESSLOTS; sl++)
						{
							if (!pPartFile->m_srcLists[sl].IsEmpty())
							{
								for (pos = pPartFile->m_srcLists[sl].GetHeadPosition(); pos != NULL; )
								{
									pPartFile->m_srcLists[sl].GetNext(pos)->SwapToAnotherFile(NULL);
								}
							}
						}
						SetRedraw(true);
d2946 1
d2948 1
@


1.501
log
@1. QR highlighting
2. output "Queue Full" if eMule client did not send QR
3. possible download abort
@
text
@d2206 1
d2397 1
a2397 4
		CString strClearAllCompleted = GetResString(IDS_TREE_DL_CLEAR_ALL_COMPLETED);
		strClearAllCompleted.Replace(_T(":"), _T(""));

		menuFile.AppendMenu(MF_STRING,MP_CLEARALLCOMPLETED, strClearAllCompleted + GetStringFromShortcutCode(SCUT_DL_CLEARALL, SSP_TAB_PREFIX));
d2694 1
d2702 1
d2830 15
a2845 1
				{
a2846 1
					{
a2847 1
					}
d2849 1
a2849 1
				}
a2850 1
				{
a2851 1
					{
a2852 1
					}
d2854 2
a2855 3
				}
 				case MP_FAKE_CHECK:
				{
a2856 1
					{
a2857 1
					}
d2859 1
a2859 1
				}
a2860 1
				{
a2861 1
					{
a2862 1
					}
d2864 1
a2864 1
				}
d2917 1
d2919 1
a2919 3
					{
						pPartFile->DownloadAllA4AF();
					}
d2921 1
d2923 1
a2923 3
					{
						pPartFile->DownloadAllA4AF(true);
					}
d2925 1
d2927 6
a2932 8
					{
						if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == pPartFile)
						//	Current pPartFile is A4AF auto => User want to switch it off
							g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(NULL);
						else
						//	Another pPartFile is A4AF auto => switch to new pPartFile
							g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(pPartFile);
					}
d2934 1
a2960 1
				{
a2961 1
					{
a2962 1
					}
d2964 1
a2964 1
				}
a2982 1
				{
d2993 1
a2993 1
				}
a2994 1
				{
d3005 1
a3005 1
				}
a3006 1
				{
d3017 1
a3017 1
				}
a3018 1
				{
d3029 1
a3029 1
				}
a3030 1
				{
d3041 1
a3041 1
				}
a3042 1
				{
d3053 1
a3053 1
				}
a3054 1
				{
d3065 1
a3065 1
				}
a3066 1
				{
d3077 1
a3077 1
				}
a3078 1
				{
d3089 1
a3089 1
				}
a3090 1
				{
d3101 1
a3101 1
				}
a3102 1
				{
d3113 1
a3113 1
				}
a3114 1
				{
d3125 1
a3125 1
				}
a3126 1
				{
d3137 1
a3137 1
				}
a3138 1
				{
a3148 1
				}
a4854 1
					{
a4855 1
					}
a4856 1
					{
a4857 1
					}
a4858 1
					{
d4860 2
a4861 1
					}
@


1.500
log
@Fixed Change Destination Directory for multiple files {Capitan Hispania}.
@
text
@d1526 1
a1526 2
				if ( (pSource->IsEmuleClient() || dwRemoteQueueRank)
					&& (nDownloadState == DS_ONQUEUE) && !pSourceItem->IsAskedForAnotherFile() )
d1528 3
a1530 1
					if (pSource->IsRemoteQueueFull())
d1532 5
a1536 5
						GetResString(&buffer, IDS_QUEUEFULL);
					}
					else
					{
						if (dwRemoteQueueRank)
d1566 6
d3900 1
a3900 5
			else if ((pClient1->GetRemoteQueueRank()>0 && pClient2->GetRemoteQueueRank()>0))
			{
				iCompare = pClient1->GetRemoteQueueRank() - pClient2->GetRemoteQueueRank();
			}
			else if (pClient1->GetRemoteQueueRank()==0 && pClient2->GetRemoteQueueRank()==0)
d3902 1
a3902 1
				if ((!pClient1->IsEmuleClient() && !pClient2->IsEmuleClient()))
d3904 9
a3912 1
					iCompare = 0;
d3916 1
a3916 2
				//	"Queue full" or " "
					iCompare = (pClient1->IsEmuleClient())?((pClient2->IsEmuleClient())?0:-1):2;
d3920 1
a3920 10
			{
				if ((!pClient1->IsEmuleClient() && !pClient2->IsEmuleClient()))
				{
					iCompare = 0;
				}
				else
				{
					iCompare = (pClient1->GetRemoteQueueRank()==0)?((pClient2->GetRemoteQueueRank()==0)?0:2):-1;
				}
			}
@


1.499
log
@Faster remote client name handling.
@
text
@d2870 1
a2870 1
					if (newpath.CompareNoCase(strDir) != 0)
d2872 1
a2872 1
						if (iNumSelected > 1)
d2874 3
a2876 1
							while (!selectedList.IsEmpty())
d2878 2
a2879 3
								selectedList.GetHead()->SetAlternativeOutputDir(&newpath);
								selectedList.GetHead()->SavePartFile();
								selectedList.RemoveHead();
d2882 3
d3500 1
a3500 1
	    }
d3503 1
a3503 1
   	return iCompare;
@


1.498
log
@Some Unicode corrections; Removed unrequired list cleanups.
@
text
@d1263 1
a1263 1
			sClientName = pSource->GetUserName();
d1512 1
a1512 1
				CString clientVerString = pSource->GetClientNameAndVersionString();
d1587 1
a1587 1
			    break;
d4004 1
a4004 1
			strName1 = pClient1->GetUserName();
d4012 1
a4012 1
			strName2 = pClient2->GetUserName();
d4624 1
a4624 1
					if (!pSourceItem->GetSource()->GetUserName().IsEmpty() && pDispInfo->item.cchTextMax > 0)
d4627 1
a4627 1
						pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
@


1.497
log
@Unified and regrouped shortcuts.
@
text
@d1542 1
a1542 1
								buffer.Format("QR: %u", dwRemoteQueueRank);
d1548 1
a1548 1
								buffer.Format("QR: %u", dwRemoteQueueRank);
d1561 1
a1561 1
								buffer.Format("QR: %u (%+i)", dwRemoteQueueRank, iDifference);
d2813 1
a2813 1
								str += "\r\n";
d2970 1
a2970 1
					ShellExecute(NULL, "open", g_eMuleApp.m_pGlobPrefs->GetAVPath(), strBuffer, NULL, SW_SHOW);
a3194 2
	//	Cleanup multiselection
		selectedList.RemoveAll();
a4258 2
	selectedList.RemoveAll();

@


1.496
log
@More space for data in upload pane lists (reduced column margins);
Corrected multiple selection cursor glitch caused by changes in previous revision {katsyonak}.
@
text
@d2196 3
a2198 3
			menuED2K.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1) + GetStringFromShortcutCode(IndexDLED2KLink, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2) + GetStringFromShortcutCode(IndexDLED2kLinkHtml, SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK) + GetStringFromShortcutCode(IndexDLED2kLinkSource, SSP_TAB_PREFIX));
d2232 1
a2232 1
				MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE) + GetStringFromShortcutCode(IndexDLPreallocate, SSP_TAB_PREFIX) );
d2243 1
a2243 1
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED),MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + GetStringFromShortcutCode(IndexDLA4AF, SSP_TAB_PREFIX));
d2249 1
a2249 1
				GetStringFromShortcutCode(IndexDLA4AFAuto, SSP_TAB_PREFIX));
d2254 1
a2254 1
				MP_ALL_A4AF_TO_OTHER, GetResString(IDS_ALL_A4AF_TO_OTHER) + GetStringFromShortcutCode(IndexDLA4AFOther, SSP_TAB_PREFIX) );
d2297 1
a2297 1
			menuFile.AppendMenu(MF_STRING|((eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED),MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(IndexDLClear, SSP_TAB_PREFIX));
d2304 1
a2304 1
			menuFile.AppendMenu(MF_STRING|(!bFileDone ? MF_ENABLED : MF_GRAYED),MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL) + GetStringFromShortcutCode(IndexDLCancel, SSP_TAB_PREFIX));
d2308 1
a2308 1
				MP_STOP, GetResString(IDS_DL_STOP) + GetStringFromShortcutCode(IndexDLStop, SSP_TAB_PREFIX) );
d2312 1
a2312 1
				MP_PAUSE, GetResString(IDS_DL_PAUSE) + GetStringFromShortcutCode(IndexDLPause, SSP_TAB_PREFIX) );
d2316 1
a2316 1
				MP_RESUME, GetResString(IDS_DL_RESUME) + GetStringFromShortcutCode(IndexDLResume, SSP_TAB_PREFIX) );
d2325 1
a2325 1
				MP_OPEN, GetResString(IDS_DL_OPEN) + GetStringFromShortcutCode(IndexDLOpen, SSP_TAB_PREFIX) );
d2329 1
a2329 1
				MP_OPENFOLDER, GetResString(IDS_OPENFOLDER) + GetStringFromShortcutCode(IndexDLOpenFolder, SSP_TAB_PREFIX) );
d2333 1
a2333 1
				MP_PREVIEW, GetResString(IDS_DL_PREVIEW) + GetStringFromShortcutCode(IndexDLPreview, SSP_TAB_PREFIX) );
d2336 1
a2336 1
				GetResString(IDS_DL_INFO) + GetStringFromShortcutCode(IndexDLDetails, SSP_TAB_PREFIX) );
d2340 1
a2340 1
				MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + GetStringFromShortcutCode(IndexDLComments, SSP_TAB_PREFIX) );
d2368 1
a2368 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(IndexULDetails, SSP_TAB_PREFIX));
d2370 1
a2370 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + GetStringFromShortcutCode(IndexULFriend, SSP_TAB_PREFIX));
d2372 2
a2373 2
				menuClient.AppendMenu(MF_STRING, MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + GetStringFromShortcutCode(IndexULFriend, SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING, MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(IndexULMessage, SSP_TAB_PREFIX));
d2375 1
a2375 1
				MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(IndexULFiles, SSP_TAB_PREFIX) );
d2392 1
a2392 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARALLCOMPLETED, strClearAllCompleted + GetStringFromShortcutCode(IndexDLClearAll, SSP_TAB_PREFIX));
d4760 1
a4760 1
		if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLUseDefaultSort))
d4765 1
a4765 1
		else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClearAll))
d4769 1
a4769 1
		else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLShowAllUp))
d4791 1
a4791 1
					if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLCancel))
d4796 1
a4796 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLStop))
d4801 1
a4801 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPause))
d4806 1
a4806 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLResume))
d4811 1
a4811 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpen))
d4816 1
a4816 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpenFolder))
d4821 1
a4821 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreview))
d4826 1
a4826 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLRename))
d4831 1
a4831 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLComments))
d4836 1
a4836 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetails))
d4841 1
a4841 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetailsSources))
d4846 1
a4846 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear))
d4850 1
a4850 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreallocate))
d4855 1
a4855 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF))
d4860 1
a4860 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFAuto))
d4865 1
a4865 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFOther))
d4870 1
a4870 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2KLink))
d4874 1
a4874 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkHtml))
d4878 1
a4878 1
					else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkSource))
@


1.495
log
@Faster drawing of some list elements.
@
text
@d1700 1
d1702 1
d1704 1
a1704 3
		odc->SetBkColor((bCtrlFocused) ? m_crHighlight : m_crNoHighlight);
	else
		odc->SetBkColor(GetBkColor());
d1706 1
a1706 1
	CMemDC			dc(odc,&CRect(lpDrawItemStruct->rcItem));
d1736 1
a1736 1
	int			iOffset = dc->GetTextExtent(_T(" "), 1 ).cx * 2;
d1739 1
a1739 2
	cur_rec.right = cur_rec.left;
	cur_rec.right -= iOffset;
a1770 1

d1797 1
a1797 1
#ifndef LATER
d1808 1
a1808 1
#endif
d1815 1
a1815 1
//
a1816 1
//
d1820 1
a1820 1
		RECT outline_rec = lpDrawItemStruct->rcItem;
d1822 2
a1823 3
		dc->FrameRect(&outline_rec, &CBrush(GetBkColor()));
		outline_rec.left++;
		outline_rec.right--;
d1825 2
d1832 1
a1832 1
				outline_rec.top--;
d1839 1
a1839 1
				outline_rec.bottom++;
d1841 1
a1841 1
		dc->FrameRect(&outline_rec, &CBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine));
a3203 1
			{
d3207 1
a3207 1
			}
a3208 1
			{
d3212 1
a3212 1
			}
a3213 1
			{
d3217 1
a3217 1
			}
a3218 1
			{
d3222 1
a3222 1
			}
a3223 1
			{
d3227 1
a3227 1
			}
a3228 1
			{
d3232 1
a3232 1
			}
a3233 1
			{
d3237 1
a3237 1
			}
a3238 1
			{
d3242 1
a3242 1
			}
a3243 1
			{
d3247 1
a3247 1
			}
a3248 1
			{
d3252 1
a3252 1
			}
a3253 1
			{
d3257 1
a3257 1
			}
a3258 1
			{
d3262 1
a3262 1
			}
a3263 1
			{
d3267 1
a3267 1
			}
a3268 1
			{
d3272 1
a3272 1
			}
a3273 1
			{
a3287 1
			}
@


1.494
log
@Fixed sorting issues when 'Show paused and stopped files last' is enabled {muleteer};
Faster sorting by Progress and Avg.ETA columns.
@
text
@d1702 1
a1702 6
	{
		if (bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	}
d1825 1
a1825 8
		outline_rec.top--;
		outline_rec.bottom++;
		CBrush brush(GetBkColor());
		CBrush* pOldBrush = dc->SelectObject(&brush);
		dc->FrameRect(&outline_rec, &brush);
		dc->SelectObject(pOldBrush);
		outline_rec.top++;
		outline_rec.bottom--;
a1835 1

d1843 1
a1843 15

		if (bCtrlFocused)
		{
			CBrush fBrush(m_crFocusLine);
			CBrush* pOldfBrush = dc->SelectObject(&fBrush);
			dc->FrameRect(&outline_rec, &fBrush);
			dc->SelectObject(pOldfBrush);
		}
		else
		{
			CBrush nfBrush(m_crNoFocusLine);
			CBrush* pOldnfBrush = dc->SelectObject(&nfBrush);
			dc->FrameRect(&outline_rec, &nfBrush);
			dc->SelectObject(pOldnfBrush);
		}
d1848 5
a1852 9
		RECT focus_rec;
		focus_rec.top    = lpDrawItemStruct->rcItem.top;
		focus_rec.bottom = lpDrawItemStruct->rcItem.bottom;
		focus_rec.left   = lpDrawItemStruct->rcItem.left + 1;
		focus_rec.right  = lpDrawItemStruct->rcItem.right - 1;
		CBrush nfBrush(m_crNoFocusLine);
		CBrush* pOldnfBrush = dc->SelectObject(&nfBrush);
		dc->FrameRect(&focus_rec, &nfBrush);
		dc->SelectObject(pOldnfBrush);
d1904 1
a1904 4
			CBrush brush(dc->GetTextColor());
			CBrush* pOldBrush = dc->SelectObject(&brush);
			dc->FrameRect(&circle_rec, &brush);
			dc->SelectObject(pOldBrush);
d1922 1
a1922 4

	//	Put the old pen back
		dc->SelectObject(oldpn);
		pn.DeleteObject();
@


1.493
log
@Fixed context menu launched by hot key in download list could be for incorrect list item;
Fixed some shortcut actions could be for wrong download list item {DopeFish};
Some optimization to process download list commands and context menu.
@
text
@d3646 1
a3646 3
	bool	bIsFile1ReallyPaused = file1->IsPaused() && !file1->IsCompleting();
	bool	bIsFile2ReallyPaused = file2->IsPaused() && !file2->IsCompleting();
	if (g_eMuleApp.m_pGlobPrefs->DoPausedStoppedLast() && (bIsFile1ReallyPaused || bIsFile2ReallyPaused))
d3648 3
a3650 1
		if (!bIsFile1ReallyPaused || (!file1->IsStopped() && file2->IsStopped()))
d3652 2
a3653 1
			return -1;
d3655 1
a3655 1
		else if (!bIsFile2ReallyPaused || (!file2->IsStopped() && file1->IsStopped()))
d3657 2
a3658 1
			return 1;
d3660 3
d3674 1
a3674 5
		{
			if (file1->GetFileSize() < file2->GetFileSize())
				iCompare = -1;
			else if (file1->GetFileSize() > file2->GetFileSize())
				iCompare = 1;
d3676 1
a3676 1
		}
a3677 1
		{
d3680 1
a3680 1
		}
a3681 1
		{
d3684 1
a3684 1
		}
a3685 1
		{
d3690 1
a3690 1
		}
d3696 2
a3697 2
				dblComp = 0.0;
			iCompare = (dblComp > 0) ? 1 : ((dblComp < 0) ? -1 : 0);
a3700 1
		{
d3705 1
a3705 1
		}
a3706 1
		{
d3709 1
a3709 1
		}
a3710 1
		{
d3713 1
a3713 1
		}
a3714 1
		{
d3718 1
a3718 1
		}
a3759 1
		{
d3765 1
a3765 1
		}
d3817 1
d3842 2
a3843 5
				EnumPartFileStatuses	eFileStatus = file1->GetStatus();

				time1 = ((eFileStatus == PS_COMPLETING) || (eFileStatus == PS_COMPLETE));
				eFileStatus = file2->GetStatus();
				time2 = ((eFileStatus == PS_COMPLETING) || (eFileStatus == PS_COMPLETE));
d3850 2
a3851 2
					iCompare = CompareUnsigned( file1->GetFileSize()-file1->GetCompletedSize(),
												file2->GetFileSize()-file2->GetCompletedSize() );
@


1.492
log
@Some optimizations for download list processing and drawing.
@
text
@d2190 2
a2191 1
		CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
d2193 1
a2193 2
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
		const CPartFile		*cpPartFile = NULL;
d2197 3
a2200 6
			cpPartFile = pFileItem->GetFile();
		}
		if (cpPartFile != NULL)
		{
			CPartFile			   *pPartFile = const_cast<CPartFile*>(cpPartFile);

d2317 1
a2317 1
				int		iFileCatIndex = CCat::CatIndexToUserCatIndex(CCat::GetCatIndexByID(cpPartFile->GetCatID()));
d2396 1
a2488 4
		CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

d2490 2
d2493 1
a2493 1
		int			iIndex = -1;
d2495 9
d2505 1
a2505 2
		CTypedPtrList<CPtrList, CPartFile*>			selectedList;
		CTypedPtrList<CPtrList, CPartFileDLItem*>	selectedItemList;
d2509 1
a2509 2
			iIndex = GetNextSelectedItem(pos);
			if (iIndex > -1)
d2564 1
a2564 1
						CString		strFileList;
d2574 5
a2578 2
								if (iNumSelected < 50)	// MOREVIT - Why 50? Who's ass did this come out of?
									strFileList.Append("\n"+CString(selectedList.GetAt(pos)->GetFileName()));
d2582 1
a2582 3
						CString		strQuestion = GetResString((iNumSelected == 1) ? IDS_Q_CANCELDL2 : IDS_Q_CANCELDL);

						if (bIsValidDelete && AfxMessageBox(strQuestion + strFileList,MB_ICONQUESTION|MB_YESNO) == IDYES)
a2594 1
										selectedList.RemoveHead();
a2604 1
										selectedList.RemoveHead();
d2607 1
d2736 10
d2747 5
a2751 17
						InputBox	inputbox;
						CString		strTemp;

						GetResString(&strTemp, IDS_RENAME);
						inputbox.SetLabels(strTemp, pPartFile->GetFileName());
						inputbox.SetEditFilenameMode();
						inputbox.DoModal();
						strTemp = inputbox.GetInput();
						if (!inputbox.WasCancelled() && !strTemp.IsEmpty())
						{
							pPartFile->SetFileName(strTemp);
							pPartFile->SavePartFile();
							pPartFile->UpdateDisplayedInfo();
							g_eMuleApp.m_pSharedFilesList->UpdateItem((CKnownFile*)pPartFile);
							g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
						}
						break;
d2753 2
d3199 1
d4504 1
a4504 1
    ScreenToClient(&p);
d4506 1
a4506 1
    int			it = HitTest(p);
d4510 1
a4510 1
    if (it == -1)
d4513 1
a4513 1
	CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
d4663 1
a4663 1
    if (pDispInfo->item.mask & LVIF_TEXT)
d4665 1
a4665 1
        CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(pDispInfo->item.lParam);
@


1.491
log
@Faster sorting by file name.
@
text
@d595 3
d599 1
a599 1
	int		iPadding = dc->GetTextExtent(_T(" "), 1 ).cx * 2;
d602 1
a602 10
	UINT	iCalcFlag = 0;

	if (bMeasuring)
	{
		iCalcFlag = (DLC_DT_TEXT | DT_CALCRECT) & ~DT_END_ELLIPSIS;
	}
	else
	{
		iCalcFlag = DLC_DT_TEXT;
	}
a606 3
	if (IsColumnHidden(nColumn))
		return;

d618 1
d622 1
a622 1
						  &&  !(pPartFile->GetStatus() == PS_COMPLETING || pPartFile->GetStatus() == PS_COMPLETE || pPartFile->GetStatus() == PS_STOPPED) )
a735 1
			//
d737 1
a737 1
                COLORREF	crOldTxtColor;
d743 1
a743 1
				if (pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED)
d753 2
a754 5
						byte		r,g,b;
						const byte	grayAmount = 0x60;
						const byte	grayBuffer = 0x40;
						const byte	grayLimit = 0xFF - grayBuffer;
						byte		gray = grayAmount;
d757 3
a759 3
						r = GetRValue(cr);
						b = GetBValue(cr);
						g = GetGValue(cr);
d762 8
a769 16
						if (r + gray >= grayLimit && b + gray >= grayLimit && g + gray >= grayLimit)
						{
							gray -= grayBuffer;
						}
						if (r + gray <= 0xFF)
							r += gray;
						else
							r = 0xFF;
						if (b + gray <= 0xFF)
							b += gray;
						else
							b = 0xFF;
						if (g + gray <= 0xFF)
							g += gray;
						else
							g = 0xFF;
d771 1
a771 1
						cr = RGB(r,g,b);
d778 2
a779 1
				dc->DrawText(pPartFile->GetFileName(), (int)_tcslen(pPartFile->GetFileName()),&r, iCalcFlag);
a780 1
				{
d782 1
a782 1
				}
d791 1
a791 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d799 1
a799 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d807 1
a807 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d814 3
a816 1
				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d818 1
a818 2
					uint32		dwDataRate = pPartFile->GetDataRate();
					uint32		dwAvgDataRate = 0;
d820 2
d823 1
a824 4

					if (dwDataRate > 10)
					{
						buffer.Format(_T("%.1f"), dwDataRate/1024.0f);
d826 1
a826 7
						{
							buffer.AppendFormat(_T(" (%.2f)"), dwAvgDataRate/1024.0f);
						}
					}
					else if (dwAvgDataRate > 10)
					{
						buffer.Format(_T("(%.2f)"), dwAvgDataRate/1024.0f);
a829 1
				{
d831 2
a832 2
				}
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
a833 1
				{
a834 1
				}
a836 1
			//#region Progress Bar
d877 1
a877 1
					dc->BitBlt(r.left, r.top, iBarWidth, iBarHeight,  &cdcStatus, 0, 0, SRCCOPY);
d891 6
a896 4
						if (pPartFile->GetStatus() != PS_COMPLETE && pPartFile->GetStatus() != PS_COMPLETING)
						{
							(g_eMuleApp.m_pGlobPrefs->UseFlatBar()) ? r.top += 3 : r.top += 2; // Just a little down
						}
a907 1
			//#endregion
d930 1
a930 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d984 1
a984 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
d991 1
a991 2
#ifdef TEST
				uint32		remains;
d993 1
a993 1
				remains = pPartFile->GetFileSize() - pPartFile->GetCompletedSize();
d995 1
a995 3
				if (remains < 0)
					remains = 0;
				buffer = CastItoXBytes(remains);
d997 1
a997 29
				if (pPartFile->GetStatus()==PS_COMPLETING || pPartFile->GetStatus()==PS_COMPLETE)
				{
					buffer.Empty();
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
				}
				else
				{
					double	saved = 100.0 - pPartFile->GetPercentCompleted();

				//	TODO: This might be faster using tabstops.
					r.right -= (57 + 5);
					dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);

					buffer.Format( _T("[%3.1f%%]"),saved);
					r = *lpRect;
					r.right -= 5;
					r.left = r.right - 57 /*measured*/;
					dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
				}
#else
				uint32		iRemaining;

				iRemaining = pPartFile->GetFileSize() - pPartFile->GetCompletedSize();

				if (iRemaining < 0)
					iRemaining = 0;
				buffer = CastItoXBytes(iRemaining);

				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d1001 1
a1001 2
					if ( dblRemainingPercent > 100.0 )
					{
d1003 1
a1003 3
					}
					else if ( iRemaining == 0 )
					{
a1004 1
					}
d1008 2
a1009 8
					if (floor(dblRemainingPercent) == dblRemainingPercent)
					{
						buffer.AppendFormat(_T(" [%.f%%]"), dblRemainingPercent);
					}
					else
					{
						buffer.AppendFormat(_T(" [%.1f%%]"), dblRemainingPercent);
					}
d1011 1
a1011 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
a1013 1
#endif TEST
d1019 1
d1021 1
a1021 1
				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d1037 1
a1037 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
d1123 3
a1125 1
				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d1130 1
a1130 1
						buffer.Format(_T("%.2f"), iDataRate/1024.0f);
d1133 2
a1134 2
					buffer.Format(_T("%.2f"), pPartFile->GetAvgDataRate(false)/1024.0f);
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d1142 1
d1144 1
a1144 1
				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d1149 1
a1149 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d1157 1
d1159 1
a1159 1
				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d1180 1
a1180 3
				{
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
				}
d1186 1
d1188 1
a1188 1
				if (pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE)
d1209 1
a1209 3
				{
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
				}
d1237 4
a1240 1
	int		iPadding = dc->GetTextExtent(_T(" "), 1 ).cx * 2;
d1243 1
a1243 16
	UINT	iCalcFlag = 0;

	if (bMeasuring)
	{
		iCalcFlag = (DLC_DT_TEXT | DT_CALCRECT) & ~DT_END_ELLIPSIS;
	}
	else
	{
		iCalcFlag = DLC_DT_TEXT;
	}

	if (IsColumnHidden(nColumn))
		return;

	if (pSourceItem == NULL)
		return;
a1257 1

d2566 3
a2568 1
							if (selectedList.GetAt(pos)->GetStatus() != PS_COMPLETING && selectedList.GetAt(pos)->GetStatus() != PS_COMPLETE)
d2927 3
a2929 1
						if (selFile->GetStatus() != PS_COMPLETING && selFile->GetStatus() != PS_COMPLETE)
d2977 4
a2980 2
					if (!(pPartFile->GetStatus()==PS_COMPLETE) && !(pPartFile->GetStatus()==PS_COMPLETING))
					{
a2981 1
					}
d2983 1
a3639 1
	{
a3640 1
	}
d3745 5
a3749 2
				time1 = (file1->GetStatus() == PS_COMPLETING || file1->GetStatus() == PS_COMPLETE);
				time2 = (file2->GetStatus() == PS_COMPLETING || file2->GetStatus() == PS_COMPLETE);
a3751 1
				{
a3752 1
				}
a3753 1
				{
a3754 1
				}
a3755 1
				{
a3757 1
				}
d3763 1
a3763 2
		    if (file1->lastseencomplete > file2->lastseencomplete)
			{
d3765 1
a3765 3
			}
		    else if (file1->lastseencomplete < file2->lastseencomplete)
			{
a3766 1
			}
d3844 5
a3848 2
				time1 = (file1->GetStatus() == PS_COMPLETING || file1->GetStatus() == PS_COMPLETE);
				time2 = (file2->GetStatus() == PS_COMPLETING || file2->GetStatus() == PS_COMPLETE);
a3850 1
				{
a3851 1
				}
a3852 1
				{
a3853 1
				}
a3854 1
				{
a3856 1
				}
@


1.490
log
@Reduced system load caused by constant download list update when <+> key is kept pressed;
Changed all columns automatically resize code (<Ctrl>-<+>) to reuse already exists code.
@
text
@d3952 1
a3952 1
		iCompare = _tcsicmp(file1->GetFileName(),file2->GetFileName());
a3953 1
		{
a3954 2
		}

@


1.489
log
@Removed unused get-time calls.
@
text
@d4471 2
a4472 1
			if ((::GetAsyncKeyState(VK_CONTROL) & 0x8000) == 0)
d4474 3
a4476 7
				ExpandCollapseItem(iClientListIndex, EXPAND_ONLY, true);
			}
			else
			{
				int		iItemCount = GetHeaderCtrl()->GetItemCount();

				for (int i = 0; i < iItemCount; i++)
d4478 1
a4478 5
					m_iColumnMaxWidths[i] = 0;
					m_iMeasuringColumn = i;
					Invalidate();
					UpdateWindow();
				}
d4480 2
a4481 1
				m_iMeasuringColumn = -1;
d4483 9
a4491 9
				SetRedraw(false);

				for (int i = 0; i < iItemCount; i++)
					if (!IsColumnHidden(i))
						SetColumnWidth(i, (m_iColumnMaxWidths[i] > 0) ? m_iColumnMaxWidths[i] : LVSCW_AUTOSIZE_USEHEADER);

				SetRedraw(true);

				Invalidate();
@


1.488
log
@Corrected remaining chunk time and size display at the end of the chunk.
@
text
@d2205 2
a2206 1
			static DWORD		dwLastRefreshTime = 0;
d2208 1
a2208 1
			if (::GetTickCount() > dwLastRefreshTime + 1000)
d2210 2
a2238 2

				dwLastRefreshTime = ::GetTickCount();
d4871 1
a4871 2
		//	... then post one with the current time so we know how long the request has been pending when we get it.
			PostMessage(WM_DL_REFRESH,0,static_cast<LPARAM>(::GetCurrentTime()));
@


1.487
log
@fixed hidden column appears when hitting 'CTRL+' (there's still a bug with the recent 'folder' column addition but it was there before and i can't figure out the problem)
@
text
@d1673 1
a1673 1
				uint32		dwRemainingSize = pSource->GetRemainingSizeForCurrentPart();
d1677 1
a1677 3
					buffer.Format( _T("%u: %s"),
									pSource->GetLastDownPartAsked(),
									static_cast<LPCTSTR>(CastItoXBytes(dwRemainingSize)) );
d4138 3
a4140 1
			iCompare = pClient1->GetRemainingSizeForCurrentPart() - pClient2->GetRemainingSizeForCurrentPart();
@


1.486
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d121 21
a141 21
		{ LVCFMT_LEFT,  260 },	//DLCOL_FILENAME
		{ LVCFMT_RIGHT,  60 },	//DLCOL_SIZE
		{ LVCFMT_RIGHT,  65 },	//DLCOL_TRANSFERRED
		{ LVCFMT_RIGHT,  65 },	//DLCOL_COMPLETED
		{ LVCFMT_RIGHT,  65 },	//DLCOL_SPEED
		{ LVCFMT_LEFT,  170 },	//DLCOL_PROGRESS
		{ LVCFMT_RIGHT,  50 },	//DLCOL_NUMSOURCES
		{ LVCFMT_LEFT,   55 },	//DLCOL_PRIORITY
		{ LVCFMT_LEFT,   70 },	//DLCOL_STATUS
		{ LVCFMT_LEFT,  110 },	//DLCOL_REMAINING
		{ LVCFMT_LEFT,  110 },	//DLCOL_REMAININGTIME
		{ LVCFMT_RIGHT,  60 },	//DLCOL_ULDLRATIO
		{ LVCFMT_RIGHT,  60 },	//DLCOL_QLRATING
		{ LVCFMT_LEFT,  110 },	//DLCOL_LASTSEENCOMPLETE
		{ LVCFMT_LEFT,  220 },	//DLCOL_LASTRECEIVED
		{ LVCFMT_LEFT,  100 },	//DLCOL_CATEGORY
		{ LVCFMT_LEFT,  110 },	//DLCOL_WAITED
		{ LVCFMT_RIGHT, 100 },	//DLCOL_AVGSPEED
		{ LVCFMT_RIGHT, 100 },	//DLCOL_AVGREMTIME
		{ LVCFMT_RIGHT, 100 },	//DLCOL_ETA
		{ LVCFMT_RIGHT, 100 }	//DLCOL_AVGETA
d1421 1
a1421 1
				// Select corresponding image list depending on client properties
d1673 1
a1673 1
				uint32 dwRemainingSize = pSource->GetRemainingSizeForCurrentPart();
d1677 3
a1679 3
					buffer.Format(_T("%u: %s"),
								pSource->GetLastDownPartAsked(),
								static_cast<LPCTSTR>(CastItoXBytes(dwRemainingSize)) );
d1731 2
a1732 2
				if (nDownloadState == DS_ONQUEUE 
					&& pSource->GetRemoteQueueRank() != 0)
d2244 1
d2247 1
d2564 1
d2569 1
d3875 1
d3877 1
d4091 1
a4091 1
							iCompare = (pClient1->GetRemoteBaseModifier() < pClient2->GetRemoteBaseModifier())?-1:1;
d4096 1
d4098 1
d4101 1
d4103 1
a4107 1
			break;
a4108 1
			break;
d4110 1
d4112 1
a4131 1
			break;
a4132 1
			break;
a4133 1
			break;
d4135 1
d4137 1
d4152 1
a4152 1
		CString		sName1, sName2;
d4155 3
a4157 1
		{ sName1 = pClient1->GetUserName(); }
d4159 3
a4161 1
		{ sName1.Empty(); }
d4163 3
a4165 1
		{ sName2 = pClient2->GetUserName(); }
d4167 5
a4171 3
		{ sName2.Empty(); }
		if (sName1.IsEmpty() || sName2.IsEmpty())
			iCompare = (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0 : 1) : -1;
d4173 1
a4173 1
			iCompare = _tcsicmp(sName1, sName2);
d4470 28
a4497 1
			ExpandCollapseItem(iClientListIndex, EXPAND_ONLY, true);
d4532 1
a4532 1
void CDownloadListCtrl::OnKillFocus(CWnd *pNewWnd) 
d4936 3
a4938 3
				CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(posSelClient)));
				CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
				CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4943 4
a4946 4
					CPartFile* pPartFile = pFileItem->GetFile();
					EnumPartFileStatuses eFileStatus = pPartFile->GetStatus();
					bool bJustOne  = (GetSelectedCount() == 1);
					bool bFileDone = (eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING);
d5043 1
a5043 1
					CUpDownClient	*pSource = pSourceItem->GetSource();
@


1.485
log
@Add sources possibly received from global search (official).
Added missing translations in case countryflag.dll / ip-to-country.cvs is not found.
Notifier informs if a new version is available (not annoying, but still more likely
 to be noticed than just a log line).
Added 'Folder' column to Shared files window.
Prevent adding install/working dirs (\Webserver, \Db...) to Shared files.
+ some other minor changes/fixes.
@
text
@d148 1
a148 1
	ilDummyImageList.Create(1, 17, ILC_COLOR32 | ILC_MASK, 1, 1);
d169 1
a169 1
	m_imageList.Create(16, 16, ILC_COLOR32|ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
@


1.484
log
@Added output folder to Downloadlist tooltips.
Added context menu indicator if alternative destination folder is used.
@
text
@a1987 1
		BOOL isExpandable = !isChild && pItem->GetFile()->GetSourceCount() > 0;
@


1.483
log
@No more renaming attempts once a file is complete.
@
text
@d2351 3
a2353 1
			menuAdvanced.AppendMenu(MF_STRING|(!bFileDone ? MF_ENABLED:MF_GRAYED),MP_CHANGEDIR, GetResString(IDS_CHANGEDIR));
@


1.482
log
@Removed unused code.
@
text
@d4940 1
a4940 1
						if (bJustOne)
@


1.481
log
@Fixed 'Get first/last chunks for preview' menu item processing
(splitting from preview setting as they're not related).
@
text
@d2822 1
a2822 1
							pPartFile->UpdateDisplayedInfo(true);
d3007 1
a3007 1
							selFile->UpdateDisplayedInfo(true);
@


1.480
log
@Removed non-working code;
Fixed sorting sources by 'UL/DL Ratio' in the download list;
Faster sources sorting in the download list.
@
text
@d2360 1
a2360 1
				( (bOneNotDone && !pPartFile->PreviewAvailable() && !pPartFile->IsArchive()) ?
@


1.479
log
@Inform a remote client when 'See my share = No one' to save traffic (original).
@
text
@a1352 1
		bool				bIsRemoteInfoAvail = pSource->IsRemoteInfoAvaiable();
a1353 1
		uint16				nRemoteRatio = pSource->GetRemoteRatio();
d1704 1
a1704 1
				if (bIsRemoteInfoAvail || bCredits)
d1715 3
a1717 5
				if (bIsRemoteInfoAvail || bCredits)
				{
					buffer.Format(_T("%ld"), nRemoteRatio);
				}
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
d4073 1
a4073 1
			if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN )
d4079 1
a4079 4
				bool	isValid1 = (pClient1->IsRemoteInfoAvaiable()|| pClient1->m_pCredits);
				bool	isValid2 = (pClient2->IsRemoteInfoAvaiable()|| pClient2->m_pCredits);

				if ( lParamSort==10 && isValid1 && isValid2)
d4081 9
a4089 5
					iCompare = (pClient1->GetRemoteBaseModifier() <pClient2->GetRemoteBaseModifier())?-1:1;
				}
				else if (isValid1 && isValid2)
				{
					iCompare = pClient1->GetRemoteRatio() - pClient2->GetRemoteRatio();
d4091 1
a4091 6
				else if (isValid1)
				{
					iCompare = 1;
				}
				else if (isValid2)
				{
a4092 5
				}
				else
				{
					iCompare = 0;
				}
@


1.478
log
@Renamed string IDS_INFLST_FILE_LASTSEENCOMPLETE -> IDS_LASTSEENCOMPLETE.
@
text
@d2497 4
a2500 3
				menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + GetStringFromShortcutCode(IndexULFriend, SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(IndexULMessage, SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(IndexULFiles, SSP_TAB_PREFIX));
d2502 1
a2502 1
				menuClient.AppendMenu(MF_STRING,MP_DOWNNOW, GetResString(IDS_DOWNLOAD_A4AF)); // Ambdribant
@


1.477
log
@Probable solution for crashes reported by users crash dumps.
@
text
@d227 1
a227 1
		IDS_INFLST_FILE_LASTSEENCOMPLETE,
@


1.476
log
@Corrected parameter definition.
@
text
@d2204 1
a2204 1
	BOOL		bHandled = FALSE;
a2245 1
			bHandled = true;
d2248 3
d2256 1
a2256 3
	{
		bHandled = CMuleListCtrl::OnWndMsg(iMessage,wParam,lParam,pResult);
	}
@


1.475
log
@Faster image lists icon loading; reduced memory usage.
@
text
@d4835 1
a4835 1
		if (!::PeekMessage(&msg,m_hWnd,WM_DL_REFRESH,WM_DL_REFRESH,false))
@


1.474
log
@Fixed sorting of 'Last Reception' column.
@
text
@d169 1
a169 1
	m_imageList.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
@


1.473
log
@added sorting for remaining size & time; corrected DL limit
@
text
@d3855 3
a3857 1
			if (file1->GetFileDate() > file2->GetFileDate())
d3859 12
a3870 1
				iCompare = 1;
d3872 1
a3872 2
			else if (file1->GetFileDate() < file2->GetFileDate())
			{
a3873 1
			}
@


1.472
log
@small but important fix :)
@
text
@d1675 7
a1681 13
			//	get requested part
				uint16		uLastPart = pSource->GetLastDownPartAsked();
				CPartFile*	pReqFile = pSourceItem->GetParentFile();

				if (pReqFile != NULL && pReqFile == pSource->m_pReqPartFile 
					&& nDownloadState == DS_DOWNLOADING 
					&& uLastPart != 0xFFFF)
				{
					uint32		dwPartSize = pReqFile->GetPartLeftToDLSize(uLastPart);

					buffer.Format( _T("%s (Part %i)"),
								static_cast<LPCTSTR>(CastItoXBytes(dwPartSize)),
								uLastPart);
d1692 3
a1694 8
			//	get requested part
				uint16		uLastPart = pSource->GetLastDownPartAsked();
				CPartFile*	pReqFile = pSourceItem->GetParentFile();

				if (pReqFile != NULL && pReqFile == pSource->m_pReqPartFile 
					&& nDownloadState == DS_DOWNLOADING 
					&& uLastPart != 0xFFFF 
					&& nDownloadDataRate != 0)
a1695 3
					uint32		dwPartSize = pReqFile->GetPartLeftToDLSize(uLastPart);
					uint32		dwSeconds = dwPartSize / nDownloadDataRate;

d4129 10
@


1.471
log
@show the remaining size & time for the sources
@
text
@d1679 3
a1681 1
				if (nDownloadState == DS_DOWNLOADING && pReqFile != NULL && uLastPart != 0xFFFF)
d1702 4
a1705 2
				if (nDownloadState == DS_DOWNLOADING && pReqFile != NULL
					&&  uLastPart != 0xFFFF && nDownloadDataRate != 0)
@


1.470
log
@Own client type for eMule Plus clients.
@
text
@d1675 3
a1677 4
#ifdef LATER
			//	MOREVIT: - display last part remaining
			//	TODO: (bug - we want the CURRENT part)
				uint16		iLastPart = pSource->GetCurrentlyDownloadingPart();
d1679 1
a1679 1
				if (iLastPart != 0xFFFF && nDownloadState == DS_DOWNLOADING)
d1681 1
a1681 1
					uint32		iPartSize = pSourceItem->GetFile()->GetPartLeftToDLSize(iLastPart);
d1684 2
a1685 2
								static_cast<LPCTSTR>(CastItoXBytes(iPartSize)),
								pSource->GetLastDownPartAsked() );
a1691 1
#endif LATER
d1696 3
a1698 4
#ifdef LATER
			//	MOREVIT: - display last part remaining time
			//	TODO: (bug - we want the CURRENT part)
				uint16		iLastPart = pSource->GetCurrentlyDownloadingPart();
d1700 2
a1701 1
				if (iLastPart != 0xFFFF && nDownloadState == DS_DOWNLOADING && nDownloadDataRate != 0)
d1703 2
a1704 2
					uint32		iPartSize = pSourceItem->GetFile()->GetPartLeftToDLSize(iLastPart);
					uint32		seconds = iPartSize / nDownloadDataRate;
d1706 1
a1706 1
					buffer = ::CastSecondsToHM(seconds);
a1712 1
#endif LATER
@


1.469
log
@MP_DELETE is replaced by MP_CANCEL.
@
text
@a1338 1
		EnumClientTypes		nClientSoft = pSource->GetClientSoft();
d4013 1
a4013 8
				uint32 dwPlus1 = pClient1->GetPlusVersion();
				uint32 dwPlus2 = pClient2->GetPlusVersion();

				if (dwPlus1 != 0)
					iCompare = (dwPlus2 != 0) ? (dwPlus2 - dwPlus1) : -1;
				else if (dwPlus2 != 0)
					iCompare = 1;
				else
d4015 5
a4019 8
					if ((iCompare = (pClient2->GetVersion() - pClient1->GetVersion())) == 0)
					{
						if (!pClient1->IsModStringEmpty())
							iCompare = (!pClient2->IsModStringEmpty()) ?
								_tcsicmp(pClient1->GetModString(), pClient2->GetModString()) : -1;
						else if (!pClient2->IsModStringEmpty())
							iCompare = 1;
					}
d4030 1
a4030 1
					iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft());
d4080 1
a4080 1
				iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft());
@


1.468
log
@Removed old unused code.
@
text
@a2650 1
				case MP_DELETE:
@


1.467
log
@fixed issue with delayed update of +/-
@
text
@a74 1
	m_dwSortTime = 0;
a3661 2
	m_dwSortTime = ::GetTickCount();

@


1.466
log
@fixed file selection with keyboard, if sources are opened
@
text
@d2210 2
@


1.465
log
@Faster sorting by client software and user name;
Faster client software version processing; Fixed eMule Plus identification;
Completely reworked remote clients version detection.
@
text
@a1797 5
	if (m_bShowSrc && m_dwSortTime + 1000 < ::GetTickCount())
	{
		SortInit(0);
	}

a2209 2

		SortInit(0);
@


1.464
log
@Removed unused code.
@
text
@d4021 1
a4021 1
			if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN )
d4023 8
a4030 5
				iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft());		//Cax2 append all unknown ones at the end
			}
			else if (pClient1->GetClientSoft() == pClient2->GetClientSoft())
			{
				if (pClient1->IsEmuleClient())
d4032 7
a4038 12
					uint32 plus1=(pClient1->GetPlusVersion()<0x2600)?pClient1->GetPlusVersion():0;
					uint32 plus2=(pClient2->GetPlusVersion()<0x2600)?pClient2->GetPlusVersion():0;
					if (plus1 && plus2)
						iCompare = plus2 - plus1;
					else if (plus1 || plus2)
						iCompare = (plus1) ? -1 : 1;
					else if (pClient1->GetMuleVersion() == pClient2->GetMuleVersion())
					{
						if (!pClient1->GetModVersion().IsEmpty() && !pClient2->GetModVersion().IsEmpty())
							iCompare = _tcsicmp(pClient1->GetModVersion(), pClient2->GetModVersion());
						else if (!pClient1->GetModVersion().IsEmpty() || !pClient2->GetModVersion().IsEmpty())
							iCompare = (pClient1->GetModVersion().IsEmpty()) ? 1 : -1;
a4039 2
					else
						iCompare = pClient2->GetMuleVersion() - pClient1->GetMuleVersion();
a4040 8
				else
				{
					iCompare = pClient2->GetVersion() - pClient1->GetVersion();
				}
			}
			else
			{
				iCompare = pClient1->GetClientSoft() - pClient2->GetClientSoft();
d4169 1
a4169 1
		{ sName1 = CString(pClient1->GetUserName()); }
d4173 1
a4173 1
		{ sName2 = CString(pClient2->GetUserName()); }
@


1.463
log
@lphant client support.
@
text
@a1340 15
		uint32				nVersion;

		switch (nClientSoft)
		{
			case SO_EMULE:
			case SO_LMULE:
			case SO_OLDEMULE:
			case SO_AMULE:
			case SO_SHAREAZA:
			case SO_LPHANT:
				nVersion= pSource->GetMuleVersion();
				break;
			default:
				nVersion= pSource->GetVersion();
		}
@


1.462
log
@caching of part size in part status vector
@
text
@d1350 1
@


1.461
log
@3) corrected measurement of time on remote queue
@
text
@d1698 1
a1698 1
					uint32		iPartSize = pSourceItem->GetFile()->GetBytesInPart(iLastPart,true);
d1721 1
a1721 1
					uint32		iPartSize = pSourceItem->GetFile()->GetBytesInPart(iLastPart,true);
@


1.460
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d1764 2
a1765 1
				if (nDownloadState == DS_ONQUEUE)
d1771 3
@


1.459
log
@Preparations for new client version report code.
@
text
@d1766 1
a1766 1
					uint32		iSeconds = pSource->GetQueueWaitTime() / 1000.0;
d4160 1
a4160 1
			uint32		iWaitSeconds1 = pClient1->GetQueueWaitTime();
d4162 1
a4162 1
			uint32		iWaitSeconds2 = pClient2->GetQueueWaitTime();
@


1.458
log
@Final fix for lost Sources sorting indicator(s) in download list; Faster shortcuts handling.
@
text
@d1612 1
a1612 1
				CString clientVerString = GetClientNameAndVersionString(pSource);
@


1.457
log
@'Clear All completed downloads' shortcut didn't work [reported by JoeSchmoe];
Fixed 'Show All Uploading Sources' shortcut processing
(it didn't work if nothing was selected in the list);
Faster shortcuts handling.
@
text
@d59 1
d2354 3
a2356 3
			menuED2K.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2KLink),SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkHtml),SSP_TAB_PREFIX));
			menuED2K.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkSource),SSP_TAB_PREFIX));
d2388 1
a2388 1
				MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreallocate),SSP_TAB_PREFIX) );
d2399 1
a2399 1
			menuAdvanced.AppendMenu(MF_STRING|((bOneNotDone) ? MF_ENABLED : MF_GRAYED),MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF),SSP_TAB_PREFIX));
d2405 1
a2405 1
				GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFAuto), SSP_TAB_PREFIX));
d2410 1
a2410 1
				MP_ALL_A4AF_TO_OTHER, GetResString(IDS_ALL_A4AF_TO_OTHER) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFOther),SSP_TAB_PREFIX) );
d2453 1
a2453 1
			menuFile.AppendMenu(MF_STRING|((eFileStatus == PS_COMPLETE) ? MF_ENABLED : MF_GRAYED),MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear),SSP_TAB_PREFIX));
d2460 1
a2460 1
			menuFile.AppendMenu(MF_STRING|(!bFileDone ? MF_ENABLED : MF_GRAYED),MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLCancel),SSP_TAB_PREFIX));
d2464 1
a2464 1
				MP_STOP, GetResString(IDS_DL_STOP) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLStop),SSP_TAB_PREFIX) );
d2468 1
a2468 1
				MP_PAUSE, GetResString(IDS_DL_PAUSE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPause),SSP_TAB_PREFIX) );
d2472 1
a2472 1
				MP_RESUME, GetResString(IDS_DL_RESUME) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLResume),SSP_TAB_PREFIX) );
d2481 1
a2481 1
				MP_OPEN, GetResString(IDS_DL_OPEN) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpen),SSP_TAB_PREFIX) );
d2485 1
a2485 1
				MP_OPENFOLDER, GetResString(IDS_OPENFOLDER) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpenFolder),SSP_TAB_PREFIX) );
d2489 1
a2489 1
				MP_PREVIEW, GetResString(IDS_DL_PREVIEW) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreview),SSP_TAB_PREFIX) );
d2492 1
a2492 1
				GetResString(IDS_DL_INFO) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetails),SSP_TAB_PREFIX) );
d2496 1
a2496 1
				MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLComments),SSP_TAB_PREFIX) );
d2523 1
a2523 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails),SSP_TAB_PREFIX));
d2525 1
a2525 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend),SSP_TAB_PREFIX));
d2527 3
a2529 3
				menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend),SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage),SSP_TAB_PREFIX));
			menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles),SSP_TAB_PREFIX));
d2546 1
a2546 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARALLCOMPLETED, strClearAllCompleted + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClearAll),SSP_TAB_PREFIX));
a2902 1
					SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
a2910 2

					SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
a4524 8
		case 'F':
		{
			if (GetKeyState(VK_CONTROL) & 0x8000)
			{
				SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
			}
			break;
		}
d4533 11
@


1.456
log
@Faster client icon drawing in the lists;
Unified processing of client icon images; Minor optimization.
@
text
@d2585 1
a2585 1
BOOL CDownloadListCtrl::OnCommand(WPARAM wParam,LPARAM lParam )
d2589 10
a3345 5
			case MP_CLEARALLCOMPLETED:
				SetRedraw(false);
				g_eMuleApp.m_pDownloadList->ClearCompleted(CAT_NONE);
				SetRedraw(true);
				break;
d4914 2
a4915 3
		int 			iMessage = 0;
		short 		nCode = GetCodeFromPressedKeys(pMsg);
		POSITION 	posSelClient = GetFirstSelectedItemPosition();
d4922 1
a4922 1
		else if (posSelClient != NULL)
d4924 9
a4932 3
			CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(posSelClient)));
			CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
			CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4934 1
a4934 2
		//	If the selected item is a file...
			if (pFileItem != NULL)
d4936 3
a4938 4
				CPartFile* pPartFile = pFileItem->GetFile();
				EnumPartFileStatuses eFileStatus = pPartFile->GetStatus();
				bool bJustOne  = (GetSelectedCount() == 1);
				bool bFileDone = (eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING);
d4940 2
a4941 1
				if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLCancel) && !bFileDone)
d4943 96
a5038 1
					iMessage = MP_CANCEL;
d5040 2
a5041 2
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLStop) &&
						  eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone )
d5043 3
a5045 87
					iMessage = MP_STOP;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPause) &&
						  eFileStatus != PS_PAUSED && eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone )
				{
					iMessage = MP_PAUSE;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLResume) &&
						  (eFileStatus == PS_PAUSED || eFileStatus == PS_STOPPED) )
				{
					iMessage = MP_RESUME;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpen) &&
						  bJustOne && eFileStatus == PS_COMPLETE )
				{
					iMessage = MP_OPEN;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpenFolder) &&
						  bJustOne && eFileStatus == PS_COMPLETE )
				{
					iMessage = MP_OPENFOLDER;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreview) &&
						  bJustOne && pPartFile->PreviewAvailable() )
				{
					iMessage = MP_PREVIEW;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLRename) && bJustOne)
				{
					iMessage = MP_RENAME;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLComments) &&
					      bJustOne && (pPartFile->HasComment() || pPartFile->HasRating()) )
				{
					iMessage = MP_VIEWFILECOMMENTS;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetails) && bJustOne)
				{
					iMessage = MP_METINFO;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetailsSources) && bJustOne)
				{
					iMessage = MP_METINFOSOURCES;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear))
				{
					iMessage = MP_CLEARCOMPLETED;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClearAll))
				{
					iMessage = MP_CLEARALLCOMPLETED;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLShowAllUp))
				{
					ShowAllUploadingSources();
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreallocate) &&
						  bJustOne && !pPartFile->IsLastBlockComplete() && !pPartFile->IsPreallocated() )
				{
					iMessage = MP_PREALLOCATE;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF) &&
						  bJustOne && !bFileDone )
				{
					iMessage = MP_ALL_A4AF_TO_HERE;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFAuto) &&
						  bJustOne && !bFileDone )
				{
					iMessage = MP_ALL_A4AF_AUTO;
				}
				else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFOther) &&
						  bJustOne && !bFileDone )
				{
					iMessage = MP_ALL_A4AF_TO_OTHER;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2KLink))
				{
					iMessage = MP_GETED2KLINK;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkHtml))
				{
					iMessage = MP_GETHTMLED2KLINK;
				}
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkSource))
				{
					iMessage = MP_GETSOURCEED2KLINK;
d5048 5
a5052 13
		//	If the selected item is a source...
			else if (pSourceItem != NULL)
			{
				CUpDownClient	*pSource = pSourceItem->GetSource();

				iMessage = GetClientListActionFromShortcutCode(nCode, pSource);
			}

			if (iMessage > 0)
			{
				PostMessage(WM_COMMAND, static_cast<WPARAM>(iMessage));
				return TRUE;
			}
@


1.455
log
@Corrected several list column labels; Unified list column creature;
Set list column labels only in one place to avoid future incorrections.
@
text
@d27 2
a28 2
#include ".\\Details\\ClientDetails.h"
#include ".\\Details\\FileDetails.h"
a91 7
		IDI_NORMAL,
		IDI_COMPROT,
		IDI_MLDONKEY,
		IDI_EDONKEYHYBRID,
		IDI_CREDIT_DOWNESTIMATED,
		IDI_FRIEND_ONLY,
		IDI_BANNED_ONLY,
a105 5
		IDI_UNKNOWN,
		IDI_AMULE,
		IDI_LMULE,
		IDI_SHAREAZA,
		IDI_SECUREHASH,
d626 1
a626 1
				int		iIcon = 0;
d706 1
a706 1
			    if (g_eMuleApp.m_pGlobPrefs->ShowRatingIcons())
d714 2
a715 2
				        	switch (pPartFile->GetRating())
				        	{
a1354 2
		bool				bIsBanned = pSource->IsBanned();
		bool				bIsFriend = pSource->IsFriend();
d1436 7
a1442 37
					// Display client icon
					switch (nClientSoft)
					{
						case SO_AMULE:
								m_imageList.Draw(dc, DL_ICON_AMULE, point, ILD_NORMAL);
							break;
						case SO_LMULE:
								m_imageList.Draw(dc, DL_ICON_LMULE, point, ILD_NORMAL);
							break;
						case SO_SHAREAZA:
								m_imageList.Draw(dc, DL_ICON_SHAREAZA, point, ILD_NORMAL);
							break;
						case SO_EDONKEYHYBRID:
								m_imageList.Draw(dc, DL_ICON_EDONKEYHYBRID, point, ILD_NORMAL);
							break;
						case SO_MLDONKEY:
								m_imageList.Draw(dc, DL_ICON_MLDONKEY, point, ILD_NORMAL);
							break;
						case SO_EMULE:
						case SO_OLDEMULE:
							if (pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
									m_imageList.Draw(dc, DL_ICON_SECUREHASH, point, ILD_NORMAL);
							else
									m_imageList.Draw(dc, DL_ICON_COMPROT, point, ILD_NORMAL);
							break;
						case SO_EDONKEY:
								m_imageList.Draw(dc, DL_ICON_NORMAL, point, ILD_NORMAL);
							break;
						default:
								m_imageList.Draw(dc, DL_ICON_UNKNOWN, point, ILD_NORMAL);
							break;
					}
				//	Display any Extra Overlay icons
					if (bIsBanned)
						m_imageList.Draw(dc, DL_ICON_BANNED_ONLY, point, ILD_TRANSPARENT);
					else if (bIsFriend)
						m_imageList.Draw(dc, DL_ICON_FRIEND_ONLY, point, ILD_TRANSPARENT);
d1444 4
a1447 1
						m_imageList.Draw(dc, DL_ICON_CREDIT_DOWNESTIMATED, point, ILD_TRANSPARENT);
d1476 2
d1483 2
a1484 7
					r2.left += 42;
					iWidth += 42;
				}
				else
				{
					r2.left += 20;
					iWidth += 20;
@


1.454
log
@'Download from all A4AF sources (same category)' feature
@
text
@d29 1
a29 1
#include "commentdialoglst.h"
d131 24
d172 1
a172 1
	ModifyStyle(LVS_SINGLESEL,0);
d178 2
a179 21
	InsertColumn(DLCOL_FILENAME,GetResString(IDS_DL_FILENAME),LVCFMT_LEFT, 260);
	InsertColumn(DLCOL_SIZE,GetResString(IDS_DL_SIZE),LVCFMT_RIGHT, 60);
	InsertColumn(DLCOL_TRANSFERRED,GetResString(IDS_DL_TRANSF),LVCFMT_RIGHT, 65);
	InsertColumn(DLCOL_COMPLETED,GetResString(IDS_SF_COMPLETED),LVCFMT_RIGHT, 65);
	InsertColumn(DLCOL_SPEED,GetResString(IDS_DL_SPEED),LVCFMT_RIGHT, 65);
	InsertColumn(DLCOL_PROGRESS,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT, 170);
	InsertColumn(DLCOL_NUMSOURCES,GetResString(IDS_DL_SOURCES),LVCFMT_RIGHT, 50);
	InsertColumn(DLCOL_PRIORITY,GetResString(IDS_PRIORITY),LVCFMT_LEFT, 55);
	InsertColumn(DLCOL_STATUS,GetResString(IDS_STATUS),LVCFMT_LEFT, 70);
	InsertColumn(DLCOL_REMAINING,GetResString(IDS_DL_REMAINS),LVCFMT_LEFT, 110);
	InsertColumn(DLCOL_REMAININGTIME,GetResString(IDS_DLCOL_REMAININGTIME),LVCFMT_LEFT, 110);
	InsertColumn(DLCOL_ULDLRATIO,GetResString(IDS_DL_ULDL),LVCFMT_RIGHT,60);
	InsertColumn(DLCOL_QLRATING,GetResString(IDS_QL_RATING),LVCFMT_RIGHT,60);
	InsertColumn(DLCOL_LASTSEENCOMPLETE, GetResString(IDS_INFLST_FILE_LASTSEENCOMPLETE), LVCFMT_LEFT, 110);
	InsertColumn(DLCOL_LASTRECEIVED, GetResString(IDS_FD_LASTCHANGE), LVCFMT_LEFT, 220);
	InsertColumn(DLCOL_CATEGORY, GetResString(IDS_CAT), LVCFMT_LEFT, 100);
	InsertColumn(DLCOL_WAITED,GetResString(IDS_WAITED),LVCFMT_LEFT,110);
	InsertColumn(DLCOL_AVGSPEED,GetResString(IDS_DLCOL_AVGSPEED),LVCFMT_RIGHT,100);
	InsertColumn(DLCOL_AVGREMTIME,GetResString(IDS_DLCOL_AVGREMTIME),LVCFMT_RIGHT,100);
	InsertColumn(DLCOL_ETA,GetResString(IDS_DLCOL_ETA),LVCFMT_RIGHT,100);
	InsertColumn(DLCOL_AVGETA,GetResString(IDS_DLCOL_AVGETA),LVCFMT_RIGHT,100);
d185 2
d236 1
a236 1
		IDS_TIME,
@


1.453
log
@Some changes...
@
text
@d2436 1
d2440 1
a2440 1
			strBuffer.AppendFormat(_T(" (%s)%s"), GetResString(IDS_PRIOAUTO),
d3081 5
@


1.452
log
@WebServer: added Get First/Last chunk for Preview
@
text
@d711 1
a711 1
			    if (!g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons())
d1483 1
a1483 1
					if (!g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons() && !g_eMuleApp.m_pIP2Country->ShowCountryFlag())
@


1.451
log
@Changed the size of the last part checking for avi files
@
text
@d2578 4
a2581 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARALLCOMPLETED, GetResString(IDS_REMOVEALLSEARCH) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClearAll),SSP_TAB_PREFIX));
d3110 1
a3110 28
						if (pPartFile->GetMovieMode())
						{
							pPartFile->SetMovieMode(0);
							pPartFile->SaveSettingsFile();
						}
						else
						{
							if (pPartFile->IsAviMovie())
							{
								int iPartCount = pPartFile->GetPartCount();

								if(pPartFile->GetPartSize(iPartCount-1) < (pPartFile->GetFileSize()*0.01))
									pPartFile->SetMovieMode(7);
								else
									pPartFile->SetMovieMode(1);
							}
							else if (pPartFile->IsMpgMovie())
							{
								if (pPartFile->GetFileSize() < 209715200)
									pPartFile->SetMovieMode(4);
								else
									pPartFile->SetMovieMode(5);
							}
							else
								pPartFile->SetMovieMode(0);

							pPartFile->SaveSettingsFile();
						}
@


1.450
log
@Minor changes for movie preview
@
text
@d3118 1
a3118 1
								if(pPartFile->GetPartSize(iPartCount-1) < PARTSIZE/2)
@


1.449
log
@Ops!... forgot beta 1 and Movie Preview change
@
text
@d3120 1
a3120 1
								else if (pPartFile->GetFileSize() < 209715200)
a3121 2
								else
									pPartFile->SetMovieMode(2);
@


1.448
log
@Now Report Fake and Check Fake both work correctly with Mozilla/Firefox, updated fakecheck links in webservices.dat
@
text
@d3111 3
a3113 1
						} else {
d3116 5
a3120 1
								if (selectedList.GetHead()->GetFileSize() < 209715200)
d3127 1
a3127 1
								if (selectedList.GetHead()->GetFileSize() < 209715200)
d3134 1
@


1.447
log
@Fixed CPU load caused by pressing Ctrl in download pane.
@
text
@d3006 1
a3006 1
						ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/report.php?link="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d3014 1
a3014 1
						ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/index.php?action=search&ed2k="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
@


1.446
log
@Expanded [+]/[-] test area by 3 pixels from each side + minor change
@
text
@d4557 2
a4558 1
			if (m_iSourceSortItem2 == -1)
d4560 9
a4568 6
				SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending);
			}
			else
			{
				SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending,1);
				SetSortArrow(m_iSourceSortItem2, m_bSortSourcesAscending2,2);
@


1.445
log
@minor changes
@
text
@d4321 1
a4321 1
				CRect	rTestedArea(r.left + 6, r.top + 4, r.left + 15, r.top + 13);
@


1.444
log
@Just variable renaming.
@
text
@d4321 1
a4321 1
				CRect	rTestedArea(r);
a4323 5
				rTestedArea.left += 2;
				rTestedArea.top += 2;
				rTestedArea.right = rTestedArea.left + OFFSET_PLUSMINUS;
				rTestedArea.bottom = rTestedArea.top + 16;

d4328 1
d4330 1
a4330 1
				else if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
a4331 3
					rTestedArea.left = rTestedArea.right;
					rTestedArea.right += OFFSET_STATUSICON;

d4358 1
a4362 4

					rTestedArea.left = rTestedArea.right;
					rTestedArea.right += OFFSET_FILETYPEICON;

d4374 1
d4379 1
a4379 3
					rTestedArea.left = rTestedArea.right;
					rTestedArea.right += OFFSET_RATINGICON;

@


1.443
log
@Updated URLs for fake check/report.
@
text
@d217 1
a217 1
	static const uint16 s_anResTbl[] =
d246 3
a248 3
		CHeaderCtrl	   *pHeaderCtrl = GetHeaderCtrl();
		CString			strRes;
		HDITEM			hdi;
d252 1
a252 1
		for (unsigned ui = 0; ui < ELEMENT_COUNT(s_anResTbl); ui++)
d254 1
a254 1
			::GetResString(&strRes, static_cast<UINT>(s_anResTbl[ui]));
@


1.442
log
@Fixed a crash on exit + minor change
@
text
@d3006 1
a3006 1
						ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/report/index.php?link2="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d3014 1
a3014 1
						ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/fakecheck/update/fakecheck.php?ed2k="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
@


1.441
log
@Faster list header localizations; Improved resource string loading; Formatting.
@
text
@d743 1
a743 4

						POINT	point = {r.left - 4, r.top + 3};

						m_imageList.Draw(dc, iIcon, point, ILD_NORMAL);
@


1.440
log
@Fixed 'Return to Default sort' shortcut processing (it didn't work if nothing was
selected in the list; it worked even if sort settings were disabled);
Fixed list sorting direction while switching <thanks xrmb>;
Improved string processing; Removed unused code and class member.
@
text
@d217 25
d247 1
d252 6
a257 106
		CString			strRes;

		strRes = GetResString(IDS_DL_FILENAME);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(0, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_SIZE);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(1, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_TRANSF);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(2, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_SF_COMPLETED);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(3, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_SPEED);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(4, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_PROGRESS);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(5, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_SOURCES);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(6, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_PRIORITY);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(7, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_STATUS);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(8, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_REMAINS);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(9, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_TIME);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(10, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_ULDL);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(11, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_QL_RATING);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(12, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_INFLST_FILE_LASTSEENCOMPLETE);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(13, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_LASTCHANGE);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(14, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_CAT);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(15, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_WAITED);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(16, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DLCOL_AVGSPEED);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(17, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DLCOL_AVGREMTIME);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(18, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DLCOL_ETA);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(19, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DLCOL_AVGETA);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(20, &hdi);
		strRes.ReleaseBuffer();
d976 2
d984 1
d986 1
a986 1
							dc->DrawText(GetResString(IDS_PRIOAUTOLOW),GetResString(IDS_PRIOAUTOLOW).GetLength(),&r, iCalcFlag);
d989 1
a989 1
							dc->DrawText(GetResString(IDS_PRIOAUTONORMAL),GetResString(IDS_PRIOAUTONORMAL).GetLength(),&r, iCalcFlag);
d992 1
a992 1
							dc->DrawText(GetResString(IDS_PRIOAUTOHIGH),GetResString(IDS_PRIOAUTOHIGH).GetLength(),&r, iCalcFlag);
d1000 1
d1002 1
a1002 1
							dc->DrawText(GetResString(IDS_PRIOLOW),GetResString(IDS_PRIOLOW).GetLength(),&r, iCalcFlag);
d1005 1
a1005 1
							dc->DrawText(GetResString(IDS_PRIONORMAL),GetResString(IDS_PRIONORMAL).GetLength(),&r, iCalcFlag);
d1008 1
a1008 1
							dc->DrawText(GetResString(IDS_PRIOHIGH),GetResString(IDS_PRIOHIGH).GetLength(),&r, iCalcFlag);
d1012 2
d1124 2
a1125 2
					buffer = GetResString(IDS_NEVER);
					dc->DrawText(buffer,(int)_tcslen(buffer),&r, iCalcFlag);
d1144 2
a1145 2
					buffer = GetResString(IDS_NEVER);
					dc->DrawText(buffer,(int)_tcslen(buffer),&r, iCalcFlag);
d1164 1
a1164 1
					buffer = GetResString(IDS_CAT_UNCATEGORIZED);
d1177 1
a1177 1
						buffer = GetResString(IDS_CAT_UNCATEGORIZED);
d1180 1
a1180 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
d1430 1
a1430 1
								status.Format(_T("%s"),pSource->m_pReqPartFile->GetFileName());
d1437 1
a1437 1
							status = GetResString(IDS_ASKED4ANOTHERFILE);
d1500 1
a1500 1
					strBuffer1.Format(_T("%s"), sClientName);
d1670 1
a1670 1
						buffer = GetResString(IDS_QUEUEFULL);
d1705 1
a1705 1
				dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
a2758 1
						break;
d2760 5
a2764 2
					pPartFile->SetAutoPriority(false);
					pPartFile->SetPriority(PR_HIGH);
a2776 1
						break;
d2778 5
a2782 2
					pPartFile->SetAutoPriority(false);
					pPartFile->SetPriority(PR_LOW);
a2794 1
						break;
d2796 5
a2800 2
					pPartFile->SetAutoPriority(false);
					pPartFile->SetPriority(PR_NORMAL);
a2812 1
						break;
d2814 5
a2818 2
					pPartFile->SetAutoPriority(true);
					pPartFile->SetPriority(PR_HIGH);
a2829 1
						break;
d2831 4
a2834 1
					pPartFile->PauseFile();
a2845 1
						break;
d2847 4
a2850 1
					pPartFile->ResumeFile();
d2853 1
a2853 1
					if (iNumSelected > 1)
d2855 3
a2857 1
						break;
a2858 3
					pPartFile->LoadPartFile(pPartFile->GetTempDir(), pPartFile->GetPartMetFileName());
					if (pPartFile->GetStatus(true) == PS_READY)
						g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(pPartFile);
d2861 1
a2861 1
					if (iNumSelected > 1)
d2863 2
a2864 1
						break;
a2865 2
					if (!pPartFile->IsLastBlockComplete())
						pPartFile->AllocateNeededSpace();
a2898 1
						break;
d2900 5
a2904 2
					HideSources(pPartFile);
					pPartFile->StopFile();
a2915 2
						SetRedraw(true);
						break;
d2917 4
a2920 1
					g_eMuleApp.m_pDownloadList->ClearCompleted(pPartFile);
a2952 1
						break;
d2954 4
a2957 1
					g_eMuleApp.CopyTextToClipboard(pPartFile->CreateED2kLink());
a2970 1
						break;
d2972 4
a2975 1
					g_eMuleApp.CopyTextToClipboard(pPartFile->CreateHTMLED2kLink());
a2989 1
						break;
d2991 4
a2994 1
					g_eMuleApp.CopyTextToClipboard(pPartFile->CreateED2KSourceLink(7, 10));
d2999 1
a2999 1
					if (iNumSelected > 1)
d3001 1
a3001 1
						break;
a3002 1
					ShellOpenFile(pPartFile->GetFullName());
d3005 1
a3005 1
  				case MP_FAKE_REPORT:
d3007 1
a3007 1
					if (iNumSelected > 1)
d3009 1
a3009 1
						break;
a3010 1
					ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/report/index.php?link2="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d3015 1
a3015 1
					if (iNumSelected > 1)
d3017 1
a3017 1
						break;
a3018 1
					ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/fakecheck/update/fakecheck.php?ed2k="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d3023 1
a3023 1
					if (iNumSelected > 1)
d3025 1
a3025 1
						break;
a3026 1
					pPartFile->PreviewFile();
d3137 1
a3137 1
					if (iNumSelected > 1)
d3139 1
a3139 1
						break;
a3140 1
					ShellOpenFile(pPartFile->GetPath());
@


1.439
log
@fixed bug that could set your fakelist version to 0 when cancelling a download while downloading fakes.rar (thanks Syrus)
@
text
@a73 1
	m_dwLastSortCode = DLCOL_FILENAME;
d75 1
d181 1
a181 1
//
d189 1
a189 1
	//	Barry - Use preferred sort order from preferences
d195 5
d201 6
a206 3
		m_dwLastSortCode = m_iCurrentSortItem + (m_bSortAscending ? MLC_SORTASC : MLC_SORTDESC)
						+ ((m_iSourceSortItem + (m_bSortSourcesAscending ? MLC_SORTASC : MLC_SORTDESC)) << 16);
		SortItems(SortProc, m_dwLastSortCode);
d1917 1
a1917 1
		SortInit(false);
a2284 6
	//	Restore the sort index that was there before opening the files if advanced sort
		if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && !m_bShowSrc)
		{
			m_iFilesSortIndex = m_dwLastSortCode;
		}

d2333 1
a2333 1
		SortInit(false);
d2927 5
a2931 4
						InputBox inputbox;
						CString strTitle=GetResString(IDS_RENAME);
						strTitle.Remove('&');
						inputbox.SetLabels(strTitle ,pPartFile->GetFileName());
d2934 2
a2935 2
						CString strNewName=inputbox.GetInput();
						if (!inputbox.WasCancelled() && strNewName.GetLength()>0)
d2937 1
a2937 1
							pPartFile->SetFileName(strNewName);
a2942 1

d3589 4
a3592 3
	NM_LISTVIEW		*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);

	bool	bIsCtrl = GetAsyncKeyState(VK_CONTROL) < 0;
d3596 8
a3603 18
		m_bSortAscending = (m_iCurrentSortItem != pNMListView->iSubItem) ? true : !m_bSortAscending;
		m_iCurrentSortItem = pNMListView->iSubItem;
		SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
	}
	else
	{
		m_bSortSourcesAscending = (m_iSourceSortItem != pNMListView->iSubItem) ? true : !m_bSortSourcesAscending;
		m_iSourceSortItem = pNMListView->iSubItem;
		SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending);
	}
	m_iSourceSortItem2 = -1;
	m_dwLastSortCode = m_iCurrentSortItem + (m_bSortAscending ? MLC_SORTASC : MLC_SORTDESC)
					+ ((m_iSourceSortItem + (m_bSortSourcesAscending ? MLC_SORTASC : MLC_SORTDESC)) << 16)
					+ (MLC_DONTSORT << 24);
	SortItems(SortProc, m_dwLastSortCode);
	if (!bIsCtrl)
	{
		g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD, m_iCurrentSortItem);
d3608 8
a3615 1
		g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD2, m_iSourceSortItem);
d3618 8
d3645 1
a3645 1
    int					iFileSortMod = 1;
d3783 4
a3787 3
		override = DL_OVERRIDESORT;
//	Major override, wipe old sorting order...
	if (override == DL_OVERRIDESORT)
d3794 1
a3794 1
		m_dwLastSortCode = (dwSourceSortCode2 << 24) | (dwSourceSortCode << 16) | dwFilesSortCode;
a3796 1
		m_bSortSourcesAscending2 = bUseSourceSort2 ? (dwSourceSortCode2 & MLC_SORTDESC) == 0 : true;
d3800 12
d3814 1
a3814 1
	SortItems(&SortProc, m_dwLastSortCode);
d4774 1
a4774 1
	SortInit(false);
d5027 6
a5032 1
		if (posSelClient != NULL)
d5044 1
a5044 1
				bool bFileDone = (eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING );
a5108 4
				else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLUseDefaultSort))
				{
					SortInit(DL_OVERRIDESORT);
				}
@


1.438
log
@Raised percent in 3D progress bar by one pixel
@
text
@d2797 5
a2803 2
										g_eMuleApp.m_pGlobPrefs->SetDLingFakeListVersion(0);
										g_eMuleApp.m_pGlobPrefs->SetDLingFakeListLink(_T(""));
@


1.437
log
@Provide parameters and then file names for antivirus applications should be more compatible.
@
text
@d997 1
a997 1
							r.top += 3; // Just a little down
d1191 1
d1211 1
@


1.436
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d3192 1
a3192 1
					CString	strBuffer;
d3198 2
a3200 2
							strBuffer += ConcatFullPath(selectedList.GetHead()->GetPath(), selectedList.GetHead()->GetFileName());
							strBuffer += _T("\" ");
a3203 1
					strBuffer += g_eMuleApp.m_pGlobPrefs->GetAVParams();
@


1.435
log
@another auto A4AF bugfix
@
text
@d114 1
a114 1
		IDI_CDONKEY,
d1413 1
a1413 1
			case SO_CDONKEY:
d1507 2
a1508 2
						case SO_CDONKEY:
								m_imageList.Draw(dc, DL_ICON_CDONKEY, point, ILD_NORMAL);
@


1.434
log
@Fix for 'Download links from CB' popup if links were created from DLqueue + minor link output improvements.
@
text
@d3146 1
a3146 1
									pPartFile->m_srcLists[sl].GetNext(pos)->SwapToAnotherFile(NULL, false);
@


1.433
log
@Removed Drop SuperCompressed blocks feature from GUI
@
text
@d2995 1
a2995 1
							str += selectedList.GetHead()->CreateED2kLink() + "\r\n";
d2997 2
d3011 1
a3011 1
							str += selectedList.GetHead()->CreateHTMLED2kLink() + "\r\n";
d3013 2
d3021 18
a3180 18
				case MP_GETSOURCEED2KLINK:
				{
					if (iNumSelected > 1)
					{
						CString str;
						while(!selectedList.IsEmpty())
						{
							str += selectedList.GetHead()->CreateED2KSourceLink(7, 10);
							selectedList.RemoveHead();
							if (!selectedList.IsEmpty())
								str += "\r\n";
						}
						g_eMuleApp.CopyTextToClipboard(str);
						break;
					}
					g_eMuleApp.CopyTextToClipboard(pPartFile->CreateED2KSourceLink(7, 10));
					break;
				}
@


1.432
log
@fix bug that let the Sources SortItem displayed when hitting CTRL-F
@
text
@d756 1
a756 1
			//	DropF START - Show that a file is A4AF auto
a759 1
			//	DropF END
a2501 3
			menuAdvanced.AppendMenu( uFlagIfDone |
				(pPartFile->GetDiscardSuperCompressed() ? MF_CHECKED : MF_UNCHECKED),
				MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED) );
d2756 1
a2756 1
				case MPG_DELETE:
a3158 12
				case MP_DROP_SUPERCOMPRESSED:
					while(!selectedList.IsEmpty())
					{
						CPartFile* selFile = selectedList.GetHead();
						if (!(selFile->GetStatus()==PS_COMPLETE) && !(selFile->GetStatus()==PS_COMPLETING))
						{
							selFile->SetDiscardSuperCompressed(!selFile->GetDiscardSuperCompressed());
							selFile->SaveSettingsFile();
						}
						selectedList.RemoveHead();
					}
					break;
@


1.431
log
@Fixed bugs with AV-support; reverted unneeded changes, removed redundant try/catch (thanks to Aw3 !)
@
text
@d4597 1
a4597 1
	switch(nChar)
d4600 1
d4604 1
a4604 1

d4606 1
d4610 1
a4610 1

d4624 8
@


1.430
log
@Formatting and old code removal
@
text
@d3208 6
a3213 2
						strBuffer += ConcatFullPath(selectedList.GetHead()->GetPath(), selectedList.GetHead()->GetFileName());
						strBuffer += _T(' ');
@


1.429
log
@left click processing optimization on PartFile in DownloadList
@
text
@a1442 5
	// DonGato: code to be able to stop the debug client when the 'unknown' scenario occurs
		if (bIsA4AF && !pSource->m_pReqPartFile && nDownloadState == DS_NONE)
			bool bIsUnknown = true;

	//	Lord KiRon - just make compiler happy :)
a1450 18
			/*
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
				{
					r2.left += OFFSET_STATUSICON;
					iWidth += OFFSET_STATUSICON;
				}
				if (g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
				{
					r2.left += OFFSET_FILETYPEICON;
					iWidth += OFFSET_FILETYPEICON;
				}
				if (!g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons())
				{
					r2.left += OFFSET_RATINGICON;
					iWidth += OFFSET_RATINGICON;
				}
			*/

a1486 1
							//Cax2 - get local file name
d1569 1
a1569 1
				if(bIsA4AF)
d1673 1
a1673 1
					if(pSourceItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !pSourceItem->GetUpdateTimer())
d2076 1
a2076 1
			CBrush* pOldfBrush = dc->SelectObject(&fBrush);	//eklmn: select a new brush
d2078 1
a2078 1
			dc->SelectObject(pOldfBrush);	//eklmn: recover an old brush
d2083 1
a2083 1
			CBrush* pOldnfBrush = dc->SelectObject(&nfBrush);	//eklmn: select a new brush
d2085 1
a2085 1
			dc->SelectObject(pOldnfBrush);	//eklmn: recover an old brush
d2105 1
a2105 1
		//set new bounds
d2113 1
a2113 1
		//gather some information
d2121 1
a2121 1
		//might as well calculate these now
d2125 1
a2125 1
		//set up a new pen for drawing the tree
d2130 1
a2130 1
		if(isChild)
d2132 1
a2132 1
			//draw the line to the status bar
d2136 2
a2137 2
			//draw the line to the child node
			if(hasNext)
d2142 4
a2145 2
		} else if(isOpenRoot) {
			//draw circle
d2160 2
a2161 2
			//draw the line to the child node
			if(hasNext)
d2167 2
a2168 2
		//draw the line back up to parent node
		if(bNotFirst && isChild)
d2174 1
a2174 1
		//put the old pen back
d2179 1
a2179 1
	//put the original objects back
d2423 1
a2423 1
		//
a2426 1
		//
a2429 1
		//
d2455 1
a2455 1
		//
d2461 1
a2461 1
		//
d2482 1
a2482 1
		//
d2517 1
a2517 1
		//
d2525 1
a2525 1
		//
d2557 1
a2557 1
		//
d2624 1
a2624 1
		//
a2651 1
	//
d2698 1
a2698 1
	//
a2723 1
		//
d2729 1
a2729 1
		//
d2814 1
a2814 1
					if(iNumSelected > 1)
d2830 1
a2830 1
					if(iNumSelected > 1)
d2846 1
a2846 1
					if(iNumSelected > 1)
d2862 1
a2862 1
					if(iNumSelected > 1)
d2878 1
a2878 1
					if(iNumSelected > 1)
d2892 1
a2892 1
					if(iNumSelected > 1)
d2906 1
a2906 1
					if(iNumSelected > 1)
d2915 1
a2915 1
					if(iNumSelected > 1)
d2919 1
a2919 1
					if(!pPartFile->IsLastBlockComplete())
a2941 1

d2943 1
a2943 1
					if(iNumSelected > 1)
d2961 1
a2961 1
					if(iNumSelected > 1)
d2994 1
a2994 1
					if(iNumSelected > 1)
a3002 1
						//AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
d3008 1
a3008 1
					if(iNumSelected > 1)
a3016 1
						//AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
d3023 1
a3023 1
					if(iNumSelected > 1)
a3029 2

				//FakeCheck
d3032 1
a3032 1
					if(iNumSelected > 1)
d3041 1
a3041 1
					if(iNumSelected > 1)
a3047 1

d3050 1
a3050 1
					if(iNumSelected > 1)
d3085 1
a3085 1
						pPartFile->GetOutputDir();	//SyruS: for what is this good? It's not in the loop above...
d3111 1
a3111 1
							//current pPartFile is A4AF auto => User want to switch it off
d3114 1
a3114 1
							//another pPartFile is A4AF auto => switch to new pPartFile
a3117 1

a3134 1

a3162 1

a3174 1

d3177 1
a3177 1
					if(iNumSelected > 1)
d3184 1
a3184 1
							if(!selectedList.IsEmpty())
a3187 1
						//AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
a3192 1

d3195 1
a3195 1
					if(iNumSelected > 1)
a3215 1

a3551 1

d3648 1
a3648 1
//
a3649 1
//
d3715 1
a3715 1
		//Cax2: A4AF clients kept separate, unless sorting for name
d3729 2
a3730 1
				if (n != 0)			//always at the end, unless sort by source - then bIsA4AF always at the top
d3781 2
a3782 1
	if (override == DL_OVERRIDESORT) //major override, wipe old sorting order...
d3809 1
a3809 1
	//this works because true is equal to 1 and false equal to 0
a3812 1
	// Lord KiRon
a3822 2
	// Lord KiRon - end
	//RedrawItems(pNMListView->iItem - notFirst, pNMListView->iItem + notLast);
d3856 1
a3856 1
		case DLCOL_FILENAME: //filename asc
d3858 1
a3858 1
		//	Obaldin: funny, but we might not have a filename yet..
d3896 1
a3896 1
		case DLCOL_NUMSOURCES: //sources asc
d3903 1
a3903 1
		case DLCOL_PRIORITY: //priority asc
d3908 1
a3908 1
		case DLCOL_STATUS: //Status asc
d3913 1
a3913 1
		case DLCOL_REMAINING: //Remaining size asc
d3919 1
a3919 1
		case DLCOL_REMAININGTIME: //Remaining Time asc
d3962 1
a3962 1
		case DLCOL_LASTSEENCOMPLETE: //Last seen complete asc
d3968 1
a3968 1
		    else if(file1->lastseencomplete < file2->lastseencomplete)
d4156 1
a4156 1
			if (pClient1->GetDownloadState()!=DS_ONQUEUE || pClient2->GetDownloadState()!=DS_ONQUEUE)	//Cax2 QR gaps bugfix
d4158 1
a4158 1
				if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
d4160 1
a4160 1
					iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft());							//Cax2 append all unknown ones at the end
d4162 1
a4162 1
				else if (pClient1->GetDownloadState()==DS_DOWNLOADING || pClient2->GetDownloadState()==DS_DOWNLOADING)		//Cax2 QR gaps bugfix
d4164 1
a4164 1
					iCompare = (pClient1->GetDownloadState()==DS_DOWNLOADING)?((pClient2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2; //Cax2 QR gaps bugfix
d4168 1
a4168 1
					iCompare = (pClient1->GetDownloadState()!=DS_ONQUEUE)?((pClient2->GetDownloadState()!=DS_ONQUEUE)?0:1):-1;		//Cax2 now should show properly...
d4183 2
a4184 1
					iCompare = (pClient1->IsEmuleClient())?((pClient2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
d4200 1
a4200 1
		case DLCOL_STATUS: //Status column - Lord KiRon
d4205 4
a4208 4
		case DLCOL_ULDLRATIO: // UL/DL column - Maverick
		case DLCOL_QLRATING: // Ratio column - Maverick
		{	//Cax2 - faster this way & less code to go wrong...
			if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN )	//Cax2 append all unknown ones at the end
d4210 1
a4210 1
				iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft());					//Cax2 append all unknown ones at the end
d4217 1
a4217 1
				if ( lParamSort==10 && isValid1 && isValid2)											//Cax2 - bugfix after reCDVst changes
d4219 1
a4219 1
					iCompare = (pClient1->GetRemoteBaseModifier() <pClient2->GetRemoteBaseModifier())?-1:1;	//Cax2 - has to return an integer!
d4221 1
a4221 1
				else if (isValid1 && isValid2)																//Cax2 - it's got to be lParamSort==11 after reCDVst changes
d4287 1
a4287 1
			iCompare = (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0 : 1) : -1;	//Cax2 append all unknown ones at the end
d4464 2
a4465 1
		if (pFileItem != NULL)		//Cax2: doubleclick opens completed files
d4478 1
a4478 1
		else if (pSourceItem != NULL)	//client  options
a4511 2
// Original by deltHF and Rod modified by Tarod
// After that modded by Vorlost too
d4520 1
a4520 1
//	Vorlost - get initial sources from server if we dont have our MaxSourcesPerFile Limit reached
d4547 1
a4547 1
	RefreshInfo();	//refresh an info in InfoList
d4683 1
a4683 1
	SetSelectionMark(it);   // display selection mark correctly!
a4827 8
	/*TRACE("CDownloadListCtrl::OnGetDispInfo iItem=%d iSubItem=%d", pDispInfo->item.iItem, pDispInfo->item.iSubItem);
	if (pDispInfo->item.mask & LVIF_TEXT)
		TRACE(" LVIF_TEXT");
	if (pDispInfo->item.mask & LVIF_IMAGE)
		TRACE(" LVIF_IMAGE");
	if (pDispInfo->item.mask & LVIF_STATE)
		TRACE(" LVIF_STATE");
	TRACE("\n");*/
d4856 1
a4856 1
					// shouldn't happen
d4874 1
a4874 1
					// shouldn't happen
d4943 1
a4943 1
//		refresh dirty files and sources and then immediately returns.
d5007 1
a5007 1
			//	if the selected item is a file...
d5115 1
a5115 1
		//	if the selected item is a source...
d5135 1
a5135 1
//		It is used for the "smart filtering" feature.
@


1.428
log
@Tooltips string improvements
@
text
@d1456 2
a1457 1
/*				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d1471 2
a1472 1
				}*/				
d4385 10
a4394 16
	// Get indexes of the first and last visible items in
	// the listview control.
	int index = GetTopIndex();
	int last_visible_index = index + GetCountPerPage();
	if(last_visible_index > GetItemCount())
		last_visible_index = GetItemCount();

	// Loop until number visible items has been reached.
	while(index <= last_visible_index)
	{
		// Get the bounding rectangle of an item. If the mouse
		// location is within the bounding rectangle of the item,
		// you know you have found the item that was being clicked.
		CRect r;
		GetItemRect(index, &r, LVIR_BOUNDS);
		if(r.PtInRect(pt))
d4396 1
a4396 1
			CMuleCtrlItem		*pListItem = ListGetItemAt(index);
d4399 5
a4403 2
			if (pFileItem == NULL)			// if it isn't a file we're done
				break;
d4405 5
a4409 8
		// [+]/[-]
			CRect rPlusMinus(r);
			rPlusMinus.left += 2;
			rPlusMinus.top += 2;
			rPlusMinus.right = rPlusMinus.left + OFFSET_PLUSMINUS;
			rPlusMinus.bottom = rPlusMinus.top + 16;
			if(rPlusMinus.PtInRect(pt))
				OnItemActivate(pNMHDR, pResult);
d4411 6
a4416 10
		// File Status
			if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
			{
				CRect rFileStatus(r);
				rFileStatus.left += 2;
				rFileStatus.left += OFFSET_PLUSMINUS;
				rFileStatus.top += 2;
				rFileStatus.right = rFileStatus.left + OFFSET_STATUSICON;
				rFileStatus.bottom = rFileStatus.top + 16;
				if(rFileStatus.PtInRect(pt))
d4418 2
a4419 1
					CPartFile *pPartFile = pListItem->GetFile();
d4421 3
a4423 2
					if (pPartFile == NULL)
						return;
d4425 21
a4445 3
					if((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED))
					{
						pPartFile->ResumeFile();
d4447 9
a4455 1
					else if (pPartFile->GetStatus() == PS_COMPLETE)
d4457 8
a4464 7
						g_eMuleApp.m_pDownloadList->ClearCompleted(pPartFile);
					}
					else if (pPartFile->GetStatus() == PS_ERROR)
					{
						pPartFile->LoadPartFile(pPartFile->GetTempDir(), pPartFile->GetPartMetFileName());
						if (pPartFile->GetStatus(true) == PS_READY)
							g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(pPartFile);
d4467 5
a4471 1
			}
d4473 3
a4475 18
		// File Type Icon
			if (g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
			{
				CRect rFileTypeIcon(r);
				rFileTypeIcon.left += 2;
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
					rFileTypeIcon.left += OFFSET_STATUSICON;
				rFileTypeIcon.left += OFFSET_PLUSMINUS;
				rFileTypeIcon.top += 2;
				rFileTypeIcon.right = rFileTypeIcon.left + OFFSET_FILETYPEICON;
				rFileTypeIcon.bottom = rFileTypeIcon.top + 16;
				if(rFileTypeIcon.PtInRect(pt))
				{
					CPartFile *pPartFile = pListItem->GetFile();
					CFileDetails dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
					dialog.DoModal();
				}
			}
d4477 6
a4482 20
		// Rating
			CRect rRating(r);
			rRating.left += 2;
			if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
				rRating.left += OFFSET_STATUSICON;
			rRating.left += OFFSET_PLUSMINUS;
			if (g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
				rRating.left += OFFSET_FILETYPEICON;
			rRating.top += 2;
			rRating.right = rRating.left + OFFSET_RATINGICON;
			rRating.bottom = rRating.top + 16;
			if(rRating.PtInRect(pt))
			{
				CPartFile *pPartFile = pListItem->GetFile();
				if(!pPartFile)
					return;
				if(pPartFile->HasComment()||pPartFile->HasRating())
				{
					CCommentDialogLst dlg(pPartFile);
					dlg.DoModal();
a4484 1
			break;
a4485 3

		// Get the next item in listview control.
		index++;
@


1.427
log
@Corrected display of '&' in Category submenu and on Search category tabs;
Improved string processing.
@
text
@d167 2
a168 6
	CString lsctitle = GetResString(IDS_LASTSEENCOMPL);
	lsctitle.Remove(':');
	InsertColumn(DLCOL_LASTSEENCOMPLETE, lsctitle,LVCFMT_LEFT, 110);
	lsctitle = GetResString(IDS_FD_LASTCHANGE);
	lsctitle.Remove(':');
	InsertColumn(DLCOL_LASTRECEIVED, lsctitle, LVCFMT_LEFT, 220);
d285 1
a285 2
		strRes = GetResString(IDS_LASTSEENCOMPL);
		strRes.Remove(':');
d290 1
a290 2
		strRes = GetResString(IDS_FD_LASTCHANGE);
		strRes.Remove(':');
@


1.426
log
@Open file details (Transfer panel) on middle mouse click (so now we can access all 3 panels directly (filetype icon click, shortcuts, mbutton click))
@
text
@d2572 9
d2582 1
a2582 4
										MP_ASSIGNCAT + i,
										(i == 0)
									  ? GetResString(IDS_CAT_UNASSIGN)
									  : CCat::GetCatByIndex(CCat::UserCatIndexToCatIndex(i))->GetTitle() );
d3250 2
a3251 1
						strBuffer += ConcatFullPath(selectedList.GetHead()->GetPath(), selectedList.GetHead()->GetFileName()) +_T(" ");
@


1.425
log
@Support for external antivirus program + removed SUI preferences + minor changes
@
text
@d4746 1
@


1.424
log
@Show default context menu item in client lists (thanks xrmb for the idea).
@
text
@d2521 1
d3238 13
@


1.423
log
@Totally reworked country information feature to minimaze memory usage.
@
text
@d2660 1
@


1.422
log
@Fixed potential crash created by changes in 1.420.
@
text
@d1604 1
a1604 1
					g_eMuleApp.m_pIP2Country->GetFlagImageList()->Draw(dc, pSource->GetCountryFlagIndex(), point, ILD_NORMAL);
@


1.421
log
@Find in lists
@
text
@d4505 2
a4506 2
				strBuffer.Format(_T("%s\\%s"),pPartFile->GetPath(), pPartFile->GetFileName());
				AddLogLine(false, strBuffer);
@


1.420
log
@Middle mouse button click opens details of selected client or file
@
text
@d76 1
@


1.419
log
@new FakeCheck autoupdate system
@
text
@d4321 1
a4321 1
	//eklmn: reset a selection in UL, CL or QL lists
d4505 1
a4505 1
				AddLogLine(false, _T("%s\\%s"),pPartFile->GetPath(), pPartFile->GetFileName());
d4702 1
a4702 1
void CDownloadListCtrl::ShowSelectedFileDetails()
d4729 2
a4730 11
		if ((pPartFile->HasComment() || pPartFile->HasRating()) && p.x < 13) // 13????? FOR SHAME :P
		{
			CCommentDialogLst		dialog(pPartFile);

			dialog.DoModal();
		}
		else
		{
			CFileDetails		dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
			dialog.DoModal();
		}
@


1.418
log
@Improve image list filling.
@
text
@d827 1
a827 1
				COLORREF	cr = CCat::GetCatColorByID(pPartFile->GetCatID());
d2822 2
@


1.417
log
@minor changes (Partfile --> PartFile...)
@
text
@d89 42
d149 1
a149 4
	for (int i = 0; i < DLCOL_NUMCOLUMNS; i++)
	{
		m_iColumnMaxWidths[i] = 0;
	}
d181 1
a181 39
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_DOWNESTIMATED),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_A4AFAUTO),16,16));

    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_COMPLETE),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_COMPLETING),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_DOWNLOADING),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_ERRONEOUS),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_HASHING),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_PAUSED),16,16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_STALLED),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_STOPPED),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_WAITING),16,16));
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_STATUS_WAITINGHASH),16,16));
	LoadImgLstIcon(NULL,0,0); //Destroy last icon
@


1.416
log
@better string processing
@
text
@d718 1
a718 1
					switch (pPartFile->GetPartfileStatusID())
d1085 1
a1085 1
				buffer = pPartFile->GetPartfileStatus();
d3930 1
a3930 1
			iCompare = file1->getPartfileStatusRang() - file2->getPartfileStatusRang();
d5185 1
a5185 1
	EnumPartFileStatuses	eStatus = static_cast<_EnumPartFileStatuses>(pPartFile->GetPartfileStatusID());
@


1.415
log
@'Open containing folder' added to download list context menu + minor changes
@
text
@d880 1
a880 1
					iWidth += r.right-r.left+1;
d995 1
d999 1
a999 8

						SIZE TextSize;
						GetTextExtentPoint32(*dc, buffer, buffer.GetLength(), &TextSize);

						int			iOldLeft = r.left;

						r.left += ((iBarWidth - TextSize.cx) / 2);

a1004 1

d1104 1
a1104 1
					buffer = _T("");
d4300 1
a4300 1
		{ sName1 = _T(""); }
d4304 1
a4304 1
		{ sName2 = _T(""); }
@


1.414
log
@Deleted icon top & bottom transparent margins to save memory & speed up drawing;
Better drawing method.
@
text
@d124 3
a126 5
// PLUS -----------------------------------------------------------------------
	InsertColumn(DLCOL_REMAININGTIME,GetResString(IDS_DLCOL_REMAININGTIME),LVCFMT_LEFT, 110); // should be est. time or ETA
	InsertColumn(DLCOL_ULDLRATIO,GetResString(IDS_DL_ULDL),LVCFMT_RIGHT,60);		//netwolf 05.05.03 (right justified)
	InsertColumn(DLCOL_QLRATING,GetResString(IDS_QL_RATING),LVCFMT_RIGHT,60);	//netwolf 05.05.03 (right justified)
//-----------------------------------------------------------------------------
d698 1
a698 1
			case DLCOL_FILENAME:		// file name
a1044 7
//				Can someone explain why we're updating this in the GUI?
//
//				if (((CKnownFile*)pPartFile)->IsAutoPrioritized())
//				{
//					((CKnownFile*)pPartFile)->UpdateUploadAutoPriority();
//				}

d1570 1
a1570 1
					// Display any Extra Overlay icons
d1599 1
a1599 1
			//	DonGato: different color for A4AF sources
d1674 1
a1674 1
			case DLCOL_SPEED:		// speed
d1690 1
a1690 1
			case DLCOL_PROGRESS:		// file info
d1741 1
a1741 1
			case DLCOL_NUMSOURCES:		// sources
d1744 1
a1744 1
				// [/Lord KiRon]
d1752 1
a1752 1
			case DLCOL_PRIORITY:		// prio
d1808 1
a1808 1
			case DLCOL_STATUS:		// status
d1820 1
a1820 1
			case DLCOL_REMAINING:		// remaining size
d1843 1
a1843 1
			case DLCOL_REMAININGTIME:	// remaining time
d1865 1
a1865 1
			case DLCOL_ULDLRATIO: // UL/DL Ratio Maverick
d1876 1
a1876 1
			case DLCOL_QLRATING: // Ratio total Maverick
a1989 1
//	offset was 4, now it's the standard 2 spaces
d2307 2
a2308 1
		if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && !m_bShowSrc)		//Cax2 - restore the sort index that was there before opening the files if advanced sort
d2599 1
a2599 1
				((eFileStatus != PS_PAUSED /*&& eFileStatus != PS_STOPPED*/ && eFileStatus != PS_ERROR && !bFileDone) ? MF_ENABLED:MF_GRAYED),
d2616 4
d3229 11
d5092 5
@


1.413
log
@minor changes
@
text
@d1617 2
a1618 1
					g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pSource->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
@


1.412
log
@increased icon/username spacing to 2 pixels + minor improvement
@
text
@a1592 3
				r2.left += 20;
				point.x += 20;
				iWidth += 20;
a1593 1
				//CString sName;
d1616 1
d1618 7
a1624 2
					r2.left += 22;
					iWidth += 22;
d1630 1
a1630 1
				if(bIsA4AF)
@


1.411
log
@reduced the space between flag and user name + minor fix in client details
@
text
@d702 1
a702 1
				POINT	ipoint = { r.left, r.top + 1 };
d711 1
a711 1
					m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d715 1
a715 1
				ipoint.x += OFFSET_PLUSMINUS;
d756 1
a756 1
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d765 1
a765 1
					m_imageList.Draw(dc, DL_ICON_A4AFAUTO, ipoint, ILD_TRANSPARENT);
d817 1
a817 1
						POINT	point = {r.left - 4,r.top + 3};
a1467 1
 		POINT		point;
d1494 2
a1497 2
					POINT		point = {r2.left, r2.top + 1};

d1542 1
a1544 2
				POINT point2= {r2.left,r2.top + 1};

d1551 1
a1551 1
								m_imageList.Draw(dc, DL_ICON_CDONKEY, point2, ILD_NORMAL);
d1554 1
a1554 1
								m_imageList.Draw(dc, DL_ICON_LMULE, point2, ILD_NORMAL);
d1557 1
a1557 1
								m_imageList.Draw(dc, DL_ICON_SHAREAZA, point2, ILD_NORMAL);
d1560 1
a1560 1
								m_imageList.Draw(dc, DL_ICON_EDONKEYHYBRID, point2, ILD_NORMAL);
d1563 1
a1563 1
								m_imageList.Draw(dc, DL_ICON_MLDONKEY, point2, ILD_NORMAL);
d1568 1
a1568 1
									m_imageList.Draw(dc, DL_ICON_SECUREHASH, point2, ILD_NORMAL);
d1570 1
a1570 1
									m_imageList.Draw(dc, DL_ICON_COMPROT, point2, ILD_NORMAL);
d1573 1
a1573 1
								m_imageList.Draw(dc, DL_ICON_NORMAL, point2, ILD_NORMAL);
d1576 1
a1576 1
								m_imageList.Draw(dc, DL_ICON_UNKNOWN, point2, ILD_NORMAL);
d1581 1
a1581 1
						m_imageList.Draw(dc, DL_ICON_BANNED_ONLY, point2, ILD_TRANSPARENT);
d1583 1
a1583 1
						m_imageList.Draw(dc, DL_ICON_FRIEND_ONLY, point2, ILD_TRANSPARENT);
d1585 1
a1585 1
						m_imageList.Draw(dc, DL_ICON_CREDIT_DOWNESTIMATED, point2, ILD_TRANSPARENT);
d1594 1
d1620 3
a1622 4
					POINT point3 = {r2.left,r2.top + 1};
					g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pSource->GetCountryFlagIndex(), point3, CSize(18,16), CPoint(0,0), ILD_NORMAL);
					r2.left += 20;
					iWidth += 20;
d1815 1
d1817 1
a1817 2
				point.x = r.left;
				point.y = r.top + 1;
d1825 1
a1825 1

d4911 1
a4911 1
					if (pSourceItem->GetSource()->GetUserName() != _T("") && pDispInfo->item.cchTextMax > 0)
@


1.410
log
@minor changes
@
text
@d817 1
a817 1
						POINT	point = {r.left-4,r.top+3};
d1427 1
a1427 1
		uint32				nVersion;	//Cax2 - version nr bugfix
d1475 2
d1479 1
a1479 1
					r.left += OFFSET_STATUSICON;
d1484 1
a1484 1
					r.left += OFFSET_FILETYPEICON;
d1489 1
a1489 1
					r.left += OFFSET_RATINGICON;
d1491 3
a1493 2
				}
*/				r.left += OFFSET_PLUSMINUS;
a1494 2
				point.x = r.left;
				point.y = r.top + 1;
d1497 2
d1542 1
a1542 1
				r.left += 20;
d1545 1
a1545 1
				POINT point2= {r.left,r.top + 1};
d1591 1
a1591 1
						r.left += OFFSET_RATINGICON;
d1595 1
a1595 2

				r.left += 20;
d1621 1
a1621 1
					POINT point3 = {r.left,r.top + 1};
d1623 2
a1624 2
					r.left += 25;
					iWidth += 25;
d1626 1
a1626 1
				dc->DrawText(strBuffer1,strBuffer1.GetLength(),&r, iCalcFlag);
d1629 1
a1629 1
					iWidth += r.right - r.left + 1;
d1677 1
a1677 1
						iWidth += r.right-r.left+1;
d1819 1
a1819 1
				point.y = r.top+1;
d1892 1
a1892 1
					iWidth += r.right-r.left+1;
@


1.409
log
@some more changes
@
text
@d695 1
a695 1
		CString			buffer = _T("");
d1417 1
a1417 1
		CString				sDownloadState = _T("");
d1442 1
a1442 1
		bool				bIsBanned = pSource->IsBanned(); //katsyonak 07/07/03
d1445 1
a1445 1
		CString				sClientName = _T("");
d1469 1
a1469 1
 		CString		status = _T("");
d1493 1
a1493 1
				point.y = r.top+1;
a1538 1

d1542 1
a1542 1
				POINT point2= {r.left,r.top+1};
a1577 1

a1622 9
					/*POINT point3 = {r.left,r.top + 1};
					g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pSource->GetCountryFlagIndex(), point3, CSize(18,16), CPoint(0,0), ILD_NORMAL);
					r.left += 20;
					SIZE TextSize;
					GetTextExtentPoint32(*dc, _T("N/A  "), 5, &TextSize);
					CString strBuffer2 = pSource->GetCountryName();
					strBuffer2 += _T("  ");
					dc->DrawText(strBuffer2,strBuffer2.GetLength(),&r, iCalcFlag);
					r.left += TextSize.cx;*/
d1648 1
a1648 1
					iWidth += r.right-r.left+1;
d1662 1
a1662 1
						iWidth += r.right-r.left+1;
d1691 1
a1691 1
						iWidth += r.right-r.left+1;
d1754 1
a1754 1
					iWidth += r.right-r.left+1;
d1810 1
a1810 1
					iWidth += r.right-r.left+1;
d1822 1
a1822 1
					iWidth += r.right-r.left+1 + 6;
d1844 1
a1844 1
					iWidth += r.right-r.left+1;
d1866 1
a1866 1
					iWidth += r.right-r.left+1;
d1879 1
a1879 1
					iWidth += r.right-r.left+1;
d1910 1
a1910 1
					iWidth += r.right-r.left+1;
d2795 1
a2795 1
						CString		strFileList = _T("");
d4911 1
a4911 1
					if (pSourceItem->GetSource()->GetUserName() != "" && pDispInfo->item.cchTextMax > 0)
@


1.408
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d1580 2
a1581 8
					if (!g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons())
					{
						r.left += OFFSET_RATINGICON;
						iWidth += OFFSET_RATINGICON;
					}

				// Display any Extra Overlay icons
					if (bIsBanned) //katsyonak 07/07/03
d1587 6
d1623 4
d1633 1
a1633 1
					r.left += TextSize.cx;
d1638 1
a1638 1
					iWidth += r.right-r.left+1;
@


1.407
log
@Fix for Clear All (completed)
@
text
@d32 1
d1599 1
a1599 1
				CString buffer1;
d1602 1
a1602 1
					buffer1.Format(_T("[%s]"),GetResString(IDS_UNKNOWN));
d1606 1
a1606 1
					buffer1.Format(_T("%s"), sClientName);
d1610 1
a1610 1
					buffer1.AppendFormat(_T(" (%s)"), status);
d1618 15
a1632 1
				dc->DrawText(buffer1,buffer1.GetLength(),&r, iCalcFlag);
a1633 1
				{
a1634 1
				}
@


1.406
log
@Modified Clear Completed
@
text
@d2585 1
a2585 1
			menuFile.AppendMenu(MF_STRING|(bFileDone ? MF_ENABLED : MF_GRAYED),MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear),SSP_TAB_PREFIX));
a2996 5
				case MP_CLEARALLCOMPLETED:
					SetRedraw(false);
					g_eMuleApp.m_pDownloadList->ClearCompleted(CAT_NONE);
					SetRedraw(true);
					break;
d3454 2
a3455 1
			case MP_CLEARCOMPLETED:
d3457 1
@


1.405
log
@Corrected colors for non-standard color scheme.
@
text
@d2585 1
a2585 1
			menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear),SSP_TAB_PREFIX));
d2670 1
a2670 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear),SSP_TAB_PREFIX));
d2983 16
d4412 1
a4412 1
						g_eMuleApp.m_pDownloadList->ClearCompleted(pPartFile->GetFileHash());
d5106 4
@


1.404
log
@move SetRedraw in ChangeCategoryByIndex() to prevet list redraw before items will be sorted
@
text
@d1800 1
a1800 1
					dc->SetTextColor((COLORREF)RGB(0,0,0));
@


1.403
log
@On file rename update Details panel header
@
text
@d4765 1
d4767 1
a4767 1
	SortInit(false);
@


1.402
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d2958 1
@


1.401
log
@Improved string processing
@
text
@d2636 1
a2636 1
			menuFile.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
d2701 1
a2701 1
		menuFile.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.400
log
@Improved string processing
@
text
@d2802 1
a2802 1
						CString		strQuestion;
a2803 8
						if (iNumSelected == 1)
						{
							strQuestion=GetResString(IDS_Q_CANCELDL2);
						}
						else
						{
							strQuestion=GetResString(IDS_Q_CANCELDL);
						}
d2821 1
a2824 3
									default:
										selectedList.GetHead()->DeleteFile();
										selectedList.RemoveHead();
d3080 5
a3084 4
					CString dir = pPartFile->GetOutputDir();
					if (dir.GetLength() == 2)
						dir.Format("%s\\", dir);
					CString newpath = BrowseFolder(g_eMuleApp.m_pdlgEmule->m_hWnd, GetResString(IDS_SELECTOUTPUTDIR), dir);
d3087 1
a3087 1
					if (newpath.CompareNoCase(dir) != 0)
d3181 1
a3181 1
                case MP_DROP_SUPERCOMPRESSED:
d4538 1
a4538 1
	   	}
a4540 2
	iNumItems = selectedList.GetCount();

@


1.399
log
@KuSh fix for sorting completing files when 'Show paused and stopped files last' is enabled ; Updated default IRC server to 'irc.freshirc.com' ; Show attempted file send source on IRC.
@
text
@d3095 1
a3095 1
						newpath.Replace("\\", "");
@


1.398
log
@replaced "TrackPopupMenu" to "TrackPopupMenuEx"
@
text
@d3847 3
a3849 1
	if (g_eMuleApp.m_pGlobPrefs->DoPausedStoppedLast() && (file1->IsPaused() || file2->IsPaused()))
d3851 1
a3851 1
		if (!file1->IsPaused() || (!file1->IsStopped() && file2->IsStopped()))
d3855 1
a3855 1
		else if (!file2->IsPaused() || (!file2->IsStopped() && file1->IsStopped()))
@


1.397
log
@list processing optimization
@
text
@d2661 1
a2661 1
			menuClient.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.396
log
@minor memory copy improvements
@
text
@d3151 1
a3151 1
								for (POSITION pos = pPartFile->m_srcLists[sl].GetHeadPosition(); pos != NULL; )
d4310 1
a4310 1
			if (posSelClient)
d4312 1
a4312 1
				while (posSelClient)
d4321 1
a4321 1
			if (posSelClient)
d4323 1
a4323 1
				while (posSelClient)
d4332 1
a4332 1
			if (posSelClient)
d4334 1
a4334 1
				while (posSelClient)
d4472 1
a4472 1
	if (posSelClient)
d5033 1
a5033 1
		if (posSelClient)
@


1.395
log
@minor improvments
@
text
@a1948 1
	RECT				cur_rec;
d1965 1
a1965 1
	memcpy2(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
d2078 1
a2078 2
		RECT outline_rec;
		memcpy2(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
@


1.394
log
@Improved context menu creation;
Multiple link copy to clipboard is more compatible;
Priority submenu is disabled for complete files.
@
text
@d1770 1
a1770 7
							if (iDifference < 0)
							{
								dc->SetTextColor((COLORREF)RGB(10,160,70));
								bIsColorChanged = true;
								buffer.Format("QR: %u (%+i)", dwRemoteQueueRank, iDifference);
							}
							else if (iDifference == dwRemoteQueueRank)
d1783 8
a1790 1
								dc->SetTextColor((COLORREF)RGB(190,60,60));
d1799 1
d1801 1
@


1.393
log
@Fixed compilation error added in 1.391
@
text
@a2429 1
	CTitleMenu		menuClient;
a2452 4
			bool					bFileDone = ( pPartFile->GetStatus() == PS_COMPLETE
											   || pPartFile->GetStatus() == PS_COMPLETING );
			bool					bJustOne = (GetSelectedCount() == 1);
			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();
a2456 1
			UINT		uFlagIfDone  = bFileDone ? MF_GRAYED:MF_ENABLED;
d2464 23
a2486 9
			menuPriority.AppendMenu(MF_STRING|uFlagIfDone,MP_PRIOLOW, GetResString(IDS_PRIOLOW));
			menuPriority.AppendMenu(MF_STRING|uFlagIfDone,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
			menuPriority.AppendMenu(MF_STRING|uFlagIfDone,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
			menuPriority.AppendMenu(MF_STRING|uFlagIfDone,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));

			menuPriority.CheckMenuItem(MP_PRIOLOW,(bJustOne && !pPartFile->IsAutoPrioritized() && pPartFile->GetPriority() == PR_LOW)? MF_CHECKED:MF_UNCHECKED);
			menuPriority.CheckMenuItem(MP_PRIONORMAL,(bJustOne && !pPartFile->IsAutoPrioritized() && pPartFile->GetPriority() == PR_NORMAL)? MF_CHECKED:MF_UNCHECKED);
			menuPriority.CheckMenuItem(MP_PRIOHIGH,(bJustOne && !pPartFile->IsAutoPrioritized() && pPartFile->GetPriority() == PR_HIGH)? MF_CHECKED:MF_UNCHECKED);
			menuPriority.CheckMenuItem(MP_PRIOAUTO, (bJustOne && pPartFile->IsAutoPrioritized())? MF_CHECKED:MF_UNCHECKED);
d2522 11
a2532 13
			menuAdvanced.AppendMenu(MF_STRING,MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreallocate),SSP_TAB_PREFIX));
			menuAdvanced.EnableMenuItem(MP_PREALLOCATE, ( bJustOne
													   && !pPartFile->IsLastBlockComplete()
													   && !pPartFile->IsPreallocated() ) ? MF_ENABLED : MF_GRAYED );
			menuAdvanced.AppendMenu(MF_STRING,MP_MOVIE, GetResString(IDS_MOVIE));
			if (bJustOne && !pPartFile->PreviewAvailable() && !pPartFile->IsArchive() && !bFileDone)
			{
				menuAdvanced.CheckMenuItem(MP_MOVIE,(pPartFile->GetMovieMode() != 0)?MF_CHECKED:MF_UNCHECKED);
			}
			else
			{
				menuAdvanced.EnableMenuItem(MP_MOVIE, MF_GRAYED);
			}
d2534 14
a2547 22
			menuAdvanced.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED));
			menuAdvanced.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, pPartFile->GetDiscardSuperCompressed() ? MF_CHECKED : MF_UNCHECKED);
			menuAdvanced.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, (bFileDone ? MF_GRAYED : MF_ENABLED));
			menuAdvanced.AppendMenu(MF_STRING|((bJustOne && !bFileDone) ? MF_ENABLED : MF_GRAYED),MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF),SSP_TAB_PREFIX));

			CString		strBuffer;

			strBuffer.Format(_T("%s (%s)"), GetResString(IDS_ALL_A4AF_TO_HERE), GetResString(IDS_PRIOAUTO));
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,strBuffer + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFAuto),SSP_TAB_PREFIX));

			if (bJustOne && !bFileDone)
			{
				menuAdvanced.CheckMenuItem(MP_ALL_A4AF_AUTO, (pPartFile == g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile()) ? MF_CHECKED : MF_UNCHECKED);
				menuAdvanced.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_ENABLED);
			}
			else
			{
				menuAdvanced.CheckMenuItem(MP_ALL_A4AF_AUTO, MF_UNCHECKED);
				menuAdvanced.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_GRAYED);
			}
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_OTHER, GetResString(IDS_ALL_A4AF_TO_OTHER) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFOther),SSP_TAB_PREFIX));
			menuAdvanced.EnableMenuItem(MP_ALL_A4AF_TO_OTHER, (bJustOne && !bFileDone) ? MF_ENABLED : MF_GRAYED);
d2555 1
a2555 3
			UINT			iWebServicesEmptyFlag = 0;

			iWebServicesEmptyFlag = (iNumWebServiceURLs == 0) ? MF_GRAYED : MF_STRING;
a2557 1
			UINT			iNoUserCatsFlag = 0;
a2558 2
			int				iNumPredefinedCats = CCat::GetNumPredefinedCats();
			int				iFileCatIndex = CCat::CatIndexToUserCatIndex(CCat::GetCatIndexByID(cpPartFile->GetCatID()));
d2562 5
a2566 1
			if (CCat::GetNumCats() > iNumPredefinedCats)
d2568 5
a2572 1
				iWebServicesEmptyFlag = MF_STRING;
a2581 5
			else
			{
			//	If there are only predefined cats, gray the assign menu
				iNoUserCatsFlag = MF_GRAYED;
			}
d2587 1
a2587 1
			menuFile.AppendMenu(iNoUserCatsFlag|MF_POPUP,(UINT_PTR)catMenu.m_hMenu, GetResString(IDS_CAT_ASSIGN) );
d2589 1
a2589 1
			menuFile.AppendMenu(MF_STRING|MF_POPUP|MF_ENABLED,(UINT_PTR)menuPriority.m_hMenu, GetResString(IDS_PRIORITY));
d2593 11
a2603 8
			menuFile.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLStop),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_STOP,((eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone ) ? MF_ENABLED:MF_GRAYED));

			menuFile.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPause),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_PAUSE,((eFileStatus != PS_PAUSED /*&& eFileStatus != PS_STOPPED*/ && eFileStatus != PS_ERROR && !bFileDone) ? MF_ENABLED:MF_GRAYED));

			menuFile.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLResume),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_RESUME,((eFileStatus == PS_PAUSED || eFileStatus == PS_STOPPED) ? MF_ENABLED:MF_GRAYED));
d2606 1
a2606 1
				menuFile.AppendMenu(MF_STRING,MP_INITIALIZE, GetResString(IDS_DL_INITIALIZE));
d2610 14
a2623 11
			menuFile.AppendMenu(MF_STRING,MP_OPEN, GetResString(IDS_DL_OPEN) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpen),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_OPEN,((bJustOne && eFileStatus == PS_COMPLETE) ? MF_ENABLED:MF_GRAYED));

			menuFile.AppendMenu(MF_STRING,MP_PREVIEW, GetResString(IDS_DL_PREVIEW) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreview),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_PREVIEW,((bJustOne && pPartFile->PreviewAvailable()) ? MF_ENABLED:MF_GRAYED));

			menuFile.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetails),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_METINFO,(bJustOne)?MF_ENABLED:MF_GRAYED);

			menuFile.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLComments),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_VIEWFILECOMMENTS,(bJustOne && (pPartFile->HasComment() || pPartFile->HasRating())) /*&& !bFileDone*/ ?MF_ENABLED:MF_GRAYED);
d2633 1
a2633 1
			menuFile.AppendMenu(iWebServicesEmptyFlag|MF_POPUP,(UINT_PTR)menuWeb.m_hMenu, GetResString(IDS_WEBSERVICES));
d2635 1
a2635 7
			menuFile.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
			menuPriority.DestroyMenu();
			menuED2K.DestroyMenu();
			menuAdvanced.DestroyMenu();
			menuSourceFilter.DestroyMenu();
			menuWeb.DestroyMenu();
			menuFile.DestroyMenu();
d2641 1
a2660 1
			menuClient.DestroyMenu();
a2700 2
		menuSourceFilter.DestroyMenu();
		menuFile.DestroyMenu();
d2702 3
d3018 1
a3018 1
							str += selectedList.GetHead()->CreateED2kLink() + "\n";
d3033 1
a3033 1
							str += selectedList.GetHead()->CreateHTMLED2kLink() + "\n";
d3212 1
a3212 1
								str += "\n";
@


1.392
log
@Now if you click over the File Type icon the file details dialog is shown
@
text
@d3840 1
a3860 2
	int		iCompare = 0;

@


1.391
log
@formatting;
little optimiZation of the DownloadList sorting code;
fixed sorting of ETA, AVG ETA, TimeRemaining, AvgTimeRemaining columns;
changed and fixed new option 'Show paused and stopped files last', it works and now with all column sort
@
text
@d4383 1
a4385 1
			// File Status
d4416 20
a4435 1
		// rating
d4451 1
a4451 1
				if(pPartFile->HasComment()||pPartFile->HasRating())		//Cax2 - bugfix!
@


1.390
log
@Slight improvement of DL draw
@
text
@d3836 3
a3838 3
//	CompareFiles() compares the names of 'pFile1' and 'pFile2' and their statuses (Paused or Stopped)
//  and returns -1 for <, 0 for ==, and 1 for >
/*static*/ int CDownloadListCtrl::CompareFiles(CPartFile* pFile1, CPartFile* pFile2)
d3840 4
a3843 1
	if (g_eMuleApp.m_pGlobPrefs->DoPausedStoppedLast() && (pFile1->IsPaused() || pFile2->IsPaused()))
d3845 6
a3850 1
		if (!pFile1->IsPaused() || pFile2->IsStopped())
d3854 1
a3854 1
		else if (pFile1->IsStopped() || !pFile2->IsPaused())
a3859 7
	return _tcsicmp(pFile1->GetFileName(),pFile2->GetFileName());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Compare() compares the two part files 'file1' and 'file2' by column 'lParamSort' and returns
//		-1, 0, or 1 for <, ==, or > respectively.
/*static*/ int CDownloadListCtrl::Compare(CPartFile *file1, CPartFile *file2, LPARAM lParamSortItem, WPARAM wParamSortMod)
{
a3861 6
	EMULE_TRY

	if (file1 == NULL || file2 == NULL)
	{
		return 0;
	}
d3872 1
a3872 3
			if (file1->GetFileSize() ==  file2->GetFileSize())
				iCompare = 0;
			else if (file1->GetFileSize() < file2->GetFileSize())
d3874 1
a3874 1
			else
d3928 1
d3937 1
a3937 5
			int		tmp1 = file1->GetTimeRemaining(true);
			int		tmp2 = file2->GetTimeRemaining(true);

			tmp1 = tmp1 == -1 ? INT_MAX : tmp1;	// -1 time indicates "unknown". Compare as if "never".
			tmp2 = tmp2 == -1 ? INT_MAX : tmp2;
d3940 7
a3946 1
				iCompare = (tmp1 > tmp2) ? 1 : ((tmp1 < tmp2) ? -1 : 0);
d3948 2
a3949 4
			//if no remaining time sort by remaining size asc. Leave completed files last...
			tmp1=(file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE);
			tmp2=(file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE);
			if ((tmp1) && (tmp2))
d3951 16
a3966 9
				iCompare = 0;
			}
			if (tmp2)
			{
				iCompare = -1;
			}
			if (tmp1)
			{
				iCompare = 1;
a3979 4
		    else
			{
				iCompare = 0;
			}
a3991 4
			else
			{
				iCompare = 0;
			}
a4004 2
			else
				iCompare = 0;
d4021 1
d4030 1
a4030 5
			int		tmp1 = file1->GetTimeRemaining();
			int		tmp2 = file2->GetTimeRemaining();

			tmp1 = tmp1 == -1 ? INT_MAX : tmp1;	// -1 time indicates "unknown". Compare as if "never".
			tmp2 = tmp2 == -1 ? INT_MAX : tmp2;
d4033 2
a4034 23
				iCompare = (tmp1 > tmp2) ? 1 : ((tmp1 < tmp2) ? -1 : 0);
			}
			//if no remaining time sort by remaining size asc. Leave completed files last...
			tmp1=(file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE);
			tmp2=(file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE);
			if ((tmp1) && (tmp2))
			{
				iCompare = 0;
			}
			if (tmp2)
			{
				iCompare = -1;
			}
			if (tmp1)
			{
				iCompare = 1;
			}
			break;
		}
		case DLCOL_ETA:
		{
			int		time1 = file1->GetTimeRemaining();
			int		time2 = file2->GetTimeRemaining();
d4036 2
a4037 6
			time1 = time1 == -1 ? INT_MAX : time1;	// -1 time indicates "unknown". Compare as if "never".
			time2 = time2 == -1 ? INT_MAX : time2;
			iCompare = (time1 > time2) ? 1 : ((time1 < time2) ? -1 : 0);

			int		tmp1 = file1->GetTimeRemaining(true);
			int		tmp2 = file2->GetTimeRemaining(true);
d4039 3
d4044 2
a4045 25
				tmp1 = tmp1 == -1 ? INT_MAX : tmp1;	// -1 time indicates "unknown". Compare as if "never".
				tmp2 = tmp2 == -1 ? INT_MAX : tmp2;
				iCompare = (tmp1 > tmp2) ? 1 : ((tmp1 < tmp2) ? -1 : 0);
			}
			//if no remaining time sort by remaining size asc. Leave completed files last...
			tmp1=(file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE);
			tmp2=(file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE);
			if ((tmp1) && (tmp2))
			{
				iCompare = 0;
			}
			if (tmp2)
			{
				iCompare = -1;
			}
			if (tmp1)
			{
				iCompare = 1;
			}
			break;
		}
		case DLCOL_AVGETA:
		{
			int		time1 = file1->GetTimeRemaining(true);
			int		time2 = file2->GetTimeRemaining(true);
d4047 13
a4059 27
			time1 = time1 == -1 ? INT_MAX : time1;	// -1 time indicates "unknown". Compare as if "never".
			time2 = time2 == -1 ? INT_MAX : time2;
			iCompare = (time1 > time2) ? 1 : ((time1 < time2) ? -1 : 0);

			int		tmp1 = file1->GetTimeRemaining();
			int		tmp2 = file2->GetTimeRemaining();

			if (iCompare == 0)
			{
				tmp1 = tmp1 == -1 ? INT_MAX : tmp1;	// -1 time indicates "unknown". Compare as if "never".
				tmp2 = tmp2 == -1 ? INT_MAX : tmp2;
				iCompare = (tmp1 > tmp2) ? 1 : ((tmp1 < tmp2) ? -1 : 0);
			}
			//if no remaining time sort by remaining size asc. Leave completed files last...
			tmp1=(file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE);
			tmp2=(file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE);
			if ((tmp1) && (tmp2))
			{
				iCompare = 0;
			}
			if (tmp2)
			{
				iCompare = -1;
			}
			if (tmp1)
			{
				iCompare = 1;
d4066 8
a4073 1
		iCompare = CompareFiles(file1,file2);
d4075 1
d4077 1
@


1.389
log
@formatting, removed some ending space and minor changes
removed some menus memleak in sharedctrl
fixed new 'LATER' code
changed new paused/stopped file sorting
removed a space not meant to be there in french.rcu
update changelog
@
text
@a1454 1
		bool				bIsEmuleClient = pSource->IsEmuleClient();
d1757 1
a1757 1
				if ( (bIsEmuleClient || dwRemoteQueueRank)
@


1.388
log
@Improved Source Number display
@
text
@d793 18
a810 18
									case PF_RATING_NONE:
										iIcon = DL_ICON_RATING_NO;
										break;
									case PF_RATING_FAKE:
										iIcon = DL_ICON_RATING_FAKE;
										break;
									case PF_RATING_POOR:
										iIcon = DL_ICON_RATING_POOR;
										break;
									case PF_RATING_GOOD:
										iIcon = DL_ICON_RATING_GOOD;
										break;
									case PF_RATING_FAIR:
										iIcon = DL_ICON_RATING_FAIR;
										break;
									case PF_RATING_EXCELLENT:
										iIcon = DL_ICON_RATING_EXCELLENT;
										break;
d812 1
a812 1
								iIcon=DL_ICON_RATING_NO;
d815 2
a816 1
						POINT	point= {r.left-4,r.top+3};
d832 1
a832 1
				if (pPartFile->GetStatus()==PS_PAUSED || pPartFile->GetStatus()==PS_STOPPED)
d2471 4
a2474 8
			menuPriority.AppendMenu(MF_STRING,MP_PRIOLOW, GetResString(IDS_PRIOLOW));
			menuPriority.EnableMenuItem(MP_PRIOLOW,uFlagIfDone);
			menuPriority.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
			menuPriority.EnableMenuItem(MP_PRIONORMAL,uFlagIfDone);
			menuPriority.AppendMenu(MF_STRING,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
			menuPriority.EnableMenuItem(MP_PRIOHIGH,uFlagIfDone);
			menuPriority.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));
			menuPriority.EnableMenuItem(MP_PRIOAUTO,uFlagIfDone);
d2510 2
a2511 4
			menuAdvanced.AppendMenu(MF_STRING,MP_FAKE_CHECK,GetResString(IDS_FAKE_CHECK));
			menuAdvanced.EnableMenuItem(MP_FAKE_CHECK, bJustOne ? MF_ENABLED:MF_GRAYED);
			menuAdvanced.AppendMenu(MF_STRING,MP_FAKE_REPORT,GetResString(IDS_FAKE_REPORT));
			menuAdvanced.EnableMenuItem(MP_FAKE_REPORT, bJustOne ? MF_ENABLED:MF_GRAYED);
d2513 2
a2514 4
			menuAdvanced.AppendMenu(MF_STRING,MP_DOCLEANUP, GetResString(IDS_DOCLEANUP));
			menuAdvanced.EnableMenuItem(MP_DOCLEANUP, (bJustOne && bFileDone) ? MF_GRAYED:MF_ENABLED);
			menuAdvanced.AppendMenu(MF_STRING,MP_CHANGEDIR, GetResString(IDS_CHANGEDIR));
			menuAdvanced.EnableMenuItem(MP_CHANGEDIR, !bFileDone ? MF_ENABLED:MF_GRAYED);
d2532 1
a2532 2
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF),SSP_TAB_PREFIX));
			menuAdvanced.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(bJustOne && !bFileDone) ? MF_ENABLED : MF_GRAYED);
d2594 1
a2594 2
			menuFile.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)menuPriority.m_hMenu, GetResString(IDS_PRIORITY));
			menuFile.EnableMenuItem((UINT_PTR)menuPriority.m_hMenu, MF_ENABLED);
d2596 1
a2596 2
			menuFile.AppendMenu(MF_STRING,MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLCancel),SSP_TAB_PREFIX));
			menuFile.EnableMenuItem(MP_CANCEL,(!bFileDone) ? MF_ENABLED : MF_GRAYED);
d2706 1
d3841 1
a3841 4
    CString		strFileName1 = pFile1->GetFileName();
    CString		strFileName2 = pFile2->GetFileName();

	if (g_eMuleApp.m_pGlobPrefs->DoPausedStoppedLast())
d3843 1
a3843 1
		if  (strFileName1.IsEmpty() || strFileName2.IsEmpty())
d3845 1
a3845 1
			return 0;
d3847 1
a3847 1
		else if (pFile1->IsPaused() || pFile2->IsPaused())
d3849 1
a3849 8
			if (!pFile1->IsPaused() || pFile2->IsStopped())
			{
				return -1;
			}
			else if (pFile1->IsStopped() || !pFile2->IsPaused())
			{
				return 1;
			}
d3852 2
a3853 1
	return _tcsicmp(strFileName1,strFileName2);
@


1.387
log
@Changed some code by other devs
@
text
@d1025 2
a1026 4
				uint16		iNotCurrentSourcesCount = pPartFile->GetNotCurrentSourcesCount();
				uint16		iSourcesCount = pPartFile->GetSourceCount();
				uint16		iA4AFSourcesCount = pPartFile->GetSrcA4AFCount();
				uint16		iTransferringSourcesCount = pPartFile->GetTransferringSrcCount();
d1028 1
a1028 1
				if (iNotCurrentSourcesCount != 0)
d1030 1
a1030 1
					buffer.Format(_T("%i/%i"),iSourcesCount - iNotCurrentSourcesCount,iSourcesCount);
d1034 1
a1034 1
					buffer.Format(_T("%i"),iSourcesCount);
d1036 4
a1039 1
				if (g_eMuleApp.m_pGlobPrefs->IsA4AFCountEnabled() && iA4AFSourcesCount != 0)
d1041 1
a1041 1
					buffer.AppendFormat(_T("+%i"),iA4AFSourcesCount);
d1043 1
a1043 1
				buffer.AppendFormat(_T(" (%i)"), iTransferringSourcesCount);
@


1.386
log
@formatting; minor changes; something was missed in last commit (Aw3 ???); always keep paused and stopped files at bottom in downloadlist
@
text
@d3852 1
a3852 1
	if  (strFileName1.IsEmpty() || strFileName2.IsEmpty())
d3854 1
a3854 5
		return 0;
	}
	else if (pFile1->IsPaused() || pFile2->IsPaused())
	{
		if (!pFile1->IsPaused() || pFile2->IsStopped())
d3856 1
a3856 1
			return -1;
d3858 1
a3858 1
		else if (pFile1->IsStopped() || !pFile2->IsPaused())
d3860 8
a3867 1
			return 1;
a3870 1

@


1.385
log
@Optimization of priority display
@
text
@d3698 1
a3698 1
			iCompare = Compare(pPartFile1, pPartFile2, iFileSortItem) * iFileSortMod;
d3708 1
a3708 1
			iCompare = Compare(pPartFile1, pPartFile2, iFileSortItem) * iFileSortMod;
d3720 1
a3720 1
			iCompare = Compare(pPartFile1, pPartFile2, iFileSortItem) * iFileSortMod;
d3725 1
a3725 1
			iCompare = Compare(pSourceItem1->GetParentFile(), pSourceItem2->GetParentFile(),iFileSortItem) * iFileSortMod;
d3845 3
a3847 2
//	CompareFileNames() compares the names of 'pFile1' and 'pFile2' and returns -1 for <, 0 for ==, and 1 for >
/*static*/ int CDownloadListCtrl::CompareFileNames(CPartFile* pFile1, CPartFile* pFile2)
d3856 1
a3856 1
	else
d3858 8
a3865 1
		return _tcsicmp(strFileName1,strFileName2);
d3867 2
d3873 1
a3873 1
/*static*/ int CDownloadListCtrl::Compare(CPartFile *file1, CPartFile *file2, LPARAM lParamSort)
d3883 1
a3883 1
	switch (lParamSort)
d3890 1
a3890 1
        }
d4153 3
a4155 1
		iCompare = CompareFileNames(file1,file2);
d4821 2
a4822 2
	CDownloadList::PartFileItemVector	*pvecPartFileItems = g_eMuleApp.m_pDownloadList->GetFileItems();
	uint32								iNumFiles = pvecPartFileItems->size();
@


1.384
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@a1453 2
		uint16				nRemoteQueueRank = pSource->GetRemoteQueueRank();
		int					iDifference = pSource->GetDifference(); //cendre-eau
a1454 1
		bool				bRemoteQueueFull = pSource->IsRemoteQueueFull();
d1753 2
a1754 1
				bool	bIsColorChanged = false;
d1756 2
a1757 2
				if ( ( bIsEmuleClient || nRemoteQueueRank)		//now emule v ? display the QR too!
					&& nDownloadState==DS_ONQUEUE && !pSourceItem->IsAskedForAnotherFile() )
d1759 1
a1759 1
					if (bRemoteQueueFull)
d1765 1
a1765 1
						if (nRemoteQueueRank)
d1767 2
d1773 1
a1773 1
								buffer.Format("QR: %u (%+i)", nRemoteQueueRank, iDifference);
d1775 1
a1775 1
							else if (iDifference == static_cast<int>(nRemoteQueueRank))
d1777 2
a1778 1
								buffer.Format("QR: %u", nRemoteQueueRank);
d1784 1
a1784 1
								buffer.Format("QR: %u", nRemoteQueueRank);
d1790 1
a1790 1
								buffer.Format("QR: %u (%+i)", nRemoteQueueRank, iDifference);
@


1.383
log
@final fix for excessive resizing on column resize bug + few optimisations and formatting
@
text
@d841 5
a845 5
						uint8		r,g,b;
						const uint8	grayAmount = 0x60;
						const uint8	grayBuffer = 0x40;
						const uint8	grayLimit = 0xFF - grayBuffer;
						uint8		gray = grayAmount;
d915 2
a916 2
					uint32		iDataRate = pPartFile->GetDataRate();
					uint32		iAvgDataRate = 0;
d919 1
a919 1
						iAvgDataRate = pPartFile->GetAvgDataRate(true);
d921 1
a921 1
					if (iDataRate > 10)
d923 2
a924 2
						buffer.Format(_T("%.1f"), iDataRate/1024.0f);
						if (iAvgDataRate > 10)
d926 1
a926 1
							buffer.AppendFormat(_T(" (%.2f)"), iAvgDataRate/1024.0f);
d929 1
a929 1
					else if (iAvgDataRate > 10)
d931 1
a931 1
						buffer.Format(_T("(%.2f)"), iAvgDataRate/1024.0f);
d1422 1
a1422 1
		uint8				nDownloadState = pSource->GetDownloadState();
a1803 1
			//	Lord KiRon
a1812 1
			//	Lord KiRon - end
a1889 1

d2769 1
a2769 1
					uint8			iUserCatIndex = wParam - MP_ASSIGNCAT;
d2773 1
a2773 1
						uint8		iCatIndex = CCat::UserCatIndexToCatIndex(iUserCatIndex);
a3874 1
	//	Obaldin: funny, but we might not have a filename yet..
d3876 2
a3877 1
	//	See below
d3879 1
a3879 1
		}
d4321 1
a4321 1
			uint8		ds1 = pClient1->GetDownloadState();
d4323 1
a4323 1
			uint8		ds2 = pClient2->GetDownloadState();
d4800 1
a4800 1
void CDownloadListCtrl::ChangeCategoryByIndex(uint8 iNewCatIndex)
@


1.382
log
@minor optimisation, thanks Aw3
@
text
@d1470 1
a1470 1
 		CString		status;
a1494 1
   				status = _T("");
d1528 7
a1534 1
							try{ status.Format(_T("(%s)"),pSource->m_pReqPartFile->GetFileName());}catch(...){}
d1537 1
a1537 1
							status = _T("(") + GetResString(IDS_ASKED4ANOTHERFILE) + _T(")");
d1603 9
a1611 3
					buffer1.Format(_T("[%s] %s"),GetResString(IDS_UNKNOWN), status);
				} else {
					buffer1.Format(_T("%s %s"), sClientName, status);
d1642 1
a1642 1
				if (bMeasuring && buffer.GetLength() != 0)
d1720 2
a1721 1
						try{
d1723 5
a1727 1
						}catch(...){} // in case client has been deleted meanwhile
d1797 1
a1797 1
				if (bMeasuring)
d1810 1
a1810 1
				if (bMeasuring && sDownloadState.GetLength() != 0)
d1833 1
a1833 1
				if (bMeasuring && buffer.GetLength() != 0)
d1855 1
a1855 1
				if (bMeasuring && buffer.GetLength() != 0)
d1868 1
a1868 1
				if (bMeasuring && buffer.GetLength() != 0)
d1879 1
a1879 1
				if (bMeasuring && buffer.GetLength() != 0)
d1900 1
a1900 1
				if (bMeasuring && buffer.GetLength() != 0)
d2455 3
a2457 3
			bool					bFileDone = ( pPartFile->GetStatus()==PS_COMPLETE
											   || pPartFile->GetStatus()==PS_COMPLETING );
			bool					bJustOne = (GetSelectedCount()==1);
d2805 1
a2805 1
						for (pos = selectedList.GetHeadPosition(); pos != 0; selectedList.GetNext(pos))
d3164 1
a3164 2
								POSITION pos1, pos2;
								for (pos1 = pPartFile->m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL;)
d3166 1
a3166 2
									pPartFile->m_srcLists[sl].GetNext(pos1);
									pPartFile->m_srcLists[sl].GetAt(pos2)->SwapToAnotherFile(NULL, false);
d4602 1
a4602 1
	for (POSITION pos = selectedList.GetHeadPosition(); pos != NULL;)
@


1.381
log
@few changes and formatting + corrected a previous change that is not working
@
text
@d916 4
a919 1
					uint32		iAvgDataRate = pPartFile->GetAvgDataRate(true);
d924 1
a924 1
						if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate() && iAvgDataRate > 10)
d929 1
a929 1
					else if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate() && iAvgDataRate > 10)
@


1.380
log
@Reversion. Hope it's like before...
@
text
@d916 1
a918 2
						buffer.AppendFormat(_T("%.1f"), iDataRate/1024.0f);
					if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
d920 9
a928 3
						iDataRate = pPartFile->GetAvgDataRate(true);
						if (iDataRate > 10)
							buffer.AppendFormat(_T(" (%.2f)"), iDataRate/1024.0f);
d932 3
a934 1
					buffer.AppendFormat(_T("[%.2f]"), pPartFile->GetAvgDataRate(false)/1024.0f);
d937 1
d939 1
d1027 1
a1027 1
				if (iNotCurrentSourcesCount > 0)
d1441 5
a1445 1
		if (pSource->GetUserName())
a1446 7
			try
			{
				sClientName = CString(pSource->GetUserName());
			}
			catch(...)
			{
			}
d1595 1
a1595 1
					buffer1.Format(_T("?  (%s)"),GetResString(IDS_UNKNOWN));
a1619 1
				uint8		iDownloadState = pSource->GetDownloadState();
d1621 1
a1621 1
				if (iLastPart != 0xFFFF && iDownloadState == DS_DOWNLOADING)
d1638 1
a1638 1
				if (!pSourceItem->IsAskedForAnotherFile() && nTransferredDown && !g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
d1664 1
a1664 1
				if (!pSourceItem->IsAskedForAnotherFile())
d1666 1
a1666 1
					if (nDownloadDataRate!=0)
d1671 1
a1671 1
					if (bMeasuring)
d1737 2
d1753 2
a1754 1
								buffer.Format("QR: %u (-%u)", nRemoteQueueRank, -iDifference);
d1763 1
d1769 2
a1770 1
								buffer.Format("QR: %u (+%u)", nRemoteQueueRank, iDifference);
d1776 2
a1777 1
				dc->SetTextColor((COLORREF)RGB(0,0,0));
d1785 1
a1785 1
				// Lord KiRon
d1791 1
a1791 1
				if (bMeasuring)
d1795 1
a1795 1
			// Lord KiRon - end
d1803 1
a1803 2
				uint16		iLastPart = pSource->GetLastDownPartAsked();
				uint8		iDownloadState = pSource->GetDownloadState();
d1805 1
a1805 1
				if (iLastPart != 0xFFFF && iDownloadState == DS_DOWNLOADING)
d1824 3
a1826 2
				uint16		iLastPart = pSource->GetLastDownPartAsked();
				uint8		iDownloadState = pSource->GetDownloadState();
d1828 1
a1828 1
				if (iLastPart != 0xFFFF && ds==DS_DOWNLOADING && nDownloadDataRate != 0)
d1849 1
a1849 1
				if (bMeasuring)
a1872 1
				uint8		ds = pSource->GetDownloadState();
d1874 1
a1874 1
				if (ds == DS_ONQUEUE)
d2035 1
a2035 1
				if (iCurrent == DLCOL_FILENAME)
d2037 1
a2037 1
					int		iNext = pHeaderCtrl->OrderToIndex(iCurrent + 1);
d2039 1
a2039 1
					if (iNext == DLCOL_SIZE)
d2041 1
a2041 1
						cx += CListCtrl::GetColumnWidth(iNext);
d3861 3
a3863 3
		//	Obaldin: funny, but we might not have a filename yet..
	        {
		//	See below
d3865 1
a3865 1
        	}
d4576 2
a4577 2
		if ( pFileItem != NULL
		  && pFileItem->GetFile()->GetSourceCount() <= g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() )
d4585 1
a4585 1
	for (POSITION pos = selectedList.GetHeadPosition(); pos != 0;)
@


1.379
log
@Formatting, comments, and name changes.
Removed old #defines
@
text
@d1018 1
a1018 1
				if (iNotCurrentSourcesCount != 0)
a1025 1

d1030 9
a1038 8
				if (iTransferringSourcesCount != 0)
				{
					buffer.AppendFormat(_T(" (%i)"), iTransferringSourcesCount);
				}
				if (((CKnownFile*)pPartFile)->IsAutoPrioritized())
				{
					((CKnownFile*)pPartFile)->UpdateUploadAutoPriority();
				}
@


1.378
log
@Slight improvements
@
text
@d1614 1
a1614 1
				uint8		iDonwloadState = pSource->GetDownloadState();
d1616 1
a1616 1
				if (iLastPart != 0xFFFF && iDonwloadState == DS_DOWNLOADING)
a2230 9

#ifdef OLD
		if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && !m_bShowSrc)	//Cax2 ...& restore the sort index that was there before expanding the files
		{
			m_dwLastSortCode = m_iFilesSortIndex;
			m_iCurrentSortItem = m_dwLastSortCode < MLC_SORTDESC ? m_dwLastSortCode : m_dwLastSortCode - MLC_SORTDESC;
			SetSortArrow(m_iCurrentSortItem, (m_dwLastSortCode < MLC_SORTDESC));
		}
#endif OLD
@


1.377
log
@Extra space is remove from Speed column values of Download pane
@
text
@d984 2
a985 8
						if (floor(dblPercentCompleted) == dblPercentCompleted)
						{
							buffer.Format(_T("%.f%%"), dblPercentCompleted);
						}
						else
						{
							buffer.Format(_T("%.1f%%"), dblPercentCompleted);
						}
@


1.376
log
@minor changes
@
text
@d918 1
a918 1
						buffer.AppendFormat(_T("%.1f "), iDataRate/1024.0f);
d923 1
a923 1
							buffer.AppendFormat(_T("(%.2f) "), iDataRate/1024.0f);
@


1.375
log
@Formatting, comments, and name changes.
@
text
@d982 1
d984 5
a988 6
						buffer.Format(_T("%.4f%%"), pPartFile->GetPercentCompleted());

						int		pos1 = buffer.Find(_T(GetLocalDecimalPoint()));
						int		pos2 = buffer.Find(_T("%"));

						if ( ( pos1 != -1 ) && ( pos2 != -1 ) && ( pos2 > pos1 ) && ( (pos2 - pos1) > 2) )
d990 1
a990 4
							if (buffer.GetAt((pos1 + 1)) == _T('0'))
								buffer.Delete(pos1, (pos2 - pos1));
							else
								buffer.Delete(pos1 + 2,(pos2 - pos1) - 2);
d1024 5
a1028 1
				if (iNotCurrentSourcesCount > 0)
d1030 1
a1030 1
					buffer.AppendFormat(_T("%i/"),iSourcesCount - iNotCurrentSourcesCount);
a1031 1
				buffer.AppendFormat(_T("%i"),iSourcesCount);
d1033 1
a1033 1
				if (g_eMuleApp.m_pGlobPrefs->IsA4AFCountEnabled() && iA4AFSourcesCount > 0)
d1037 1
a1037 1
				if (iTransferringSourcesCount > 0)
d1174 1
a1174 1
					buffer.AppendFormat(_T("%s"), CastSecondsToHM(restTime));
d1185 1
a1185 1
					buffer.AppendFormat(_T("[%s / %s]"), CastItoXBytes(pPartFile->GetSessionTransferred()), CastSecondsToHM(restTime));
a1614 1
	#ifdef LATER
d1616 1
d1620 1
a1620 2
				uint8		ds = pSource->GetDownloadState();
				uint32		iPartSize = 0L;
d1622 1
a1622 1
				if (iLastPart != 0xFFFF && ds==DS_DOWNLOADING)
d1624 2
a1625 1
					iPartSize = pSourceItem->GetFile()->GetPartSize(iLastPart);
d1629 6
a1635 1
			//	:MOREVIT
a1636 3
	#else
				break;
	#endif LATER
d1794 8
a1801 1
	#ifdef LATER
d1803 1
a1803 5
				//	MOREVIT: - display last part remaining
				//	TODO: (bug - we want the CURRENT part)
					uint16		iLastPart = pSource->GetLastDownPartAsked();
					uint8		ds = pSource->GetDownloadState();
					uint32		iPartSize = 0L;
d1805 8
a1812 9
					if (iLastPart != 0xFFFF && ds==DS_DOWNLOADING)
					{
						iPartSize = pSourceItem->GetFile()->GetBytesInPart(iLastPart,true);
						buffer.Format( _T("%s (Part %i)"),
									static_cast<LPCTSTR>(CastItoXBytes(iPartSize)),
									pSource->GetLastDownPartAsked() );
					}
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_LEFT);
					break;
d1814 1
a1814 1
	#endif LATER
d1816 1
d1818 6
a1823 1
	#ifdef LATER
d1825 2
a1826 3
					uint16		iLastPart = pSource->GetLastDownPartAsked();
					uint8		ds = pSource->GetDownloadState();
					uint32		iPartSize = 0L;
d1828 6
a1833 9
					if (iLastPart != 0xFFFF && ds==DS_DOWNLOADING && nDownloadDataRate != 0)
					{
						iPartSize = pSourceItem->GetFile()->GetBytesInPart(iLastPart,true);

						uint32		seconds = iPartSize / nDownloadDataRate;

						buffer = ::CastSecondsToHM(iPartSize);
					}
					break;
d1835 1
a1835 1
	#endif LATER
d1837 1
d1994 1
a1994 1
				DrawFileItem(dc, 5, &cur_rec, pFileItem);
d2025 1
a2025 1
				DrawSourceItem(dc, 5, &cur_rec, pSourceItem);
d2030 12
d3618 10
a3627 4
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD, m_iCurrentSortItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD, m_bSortAscending);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_DOWNLOAD2, m_iSourceSortItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_DOWNLOAD2, m_bSortSourcesAscending);
@


1.374
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d917 1
a917 1
			       		if (iDataRate > 10)
d919 2
a920 2
				       	if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
				       	{
d1407 1
a1407 1
		CUpDownClient		*pSource = pSourceItem->GetSource();
@


1.373
log
@Formatting, comments, and name changes.
@
text
@d843 1
a843 1
						const uint8 grayBuffer = 0x40;
d905 2
a906 2
			    buffer = CastItoXBytes(pPartFile->GetCompletedSize());
			    dc->DrawText(buffer,buffer.GetLength(),&r, DT_RIGHT | iCalcFlag);
d909 1
a909 1
			    break;
d917 1
a917 1
			       	if (iDataRate > 10)
d919 2
a920 2
			       	if (g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
			       	{
d1022 4
a1025 3
				uint16		ncsc = pPartFile->GetNotCurrentSourcesCount();
				uint16		sc = pPartFile->GetSourceCount();
				uint16		tsc = pPartFile->GetTransferringSrcCount();
d1027 1
a1027 1
				if (ncsc > 0)
d1029 1
a1029 1
					buffer.AppendFormat(_T("%i/"),sc - ncsc);
d1031 1
a1031 1
				buffer.AppendFormat(_T("%i"),pPartFile->GetSourceCount());
d1033 1
a1033 1
				if (g_eMuleApp.m_pGlobPrefs->IsA4AFCountEnabled() && pPartFile->GetSrcA4AFCount() > 0)
d1035 1
a1035 1
					buffer.AppendFormat(_T("+%i"),pPartFile->GetSrcA4AFCount());
d1037 1
a1037 1
				if (tsc > 0)
d1039 1
a1039 1
					buffer.AppendFormat(_T(" (%i)"), tsc);
d1270 1
a1270 1
		    {
d1407 1
a1407 1
		CUpDownClient	   *pSource = pSourceItem->GetSource();
d1471 2
a1472 2
		    case DLCOL_FILENAME:
  			{
d1503 1
a1503 1
									m_imageList.Draw(dc, DL_ICON_DCS3, point, ILD_NORMAL);
d1506 1
a1506 1
									m_imageList.Draw(dc, DL_ICON_DCS2, point, ILD_NORMAL);
d1510 1
a1510 1
									m_imageList.Draw(dc, DL_ICON_DCS1, point, ILD_NORMAL);
d1514 1
a1514 1
									m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL);
d1517 1
a1517 1
									m_imageList.Draw(dc, DL_ICON_DCS5, point, ILD_NORMAL);
d1522 1
a1522 1
               			m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL);
d1536 1
a1536 1
                POINT point2= {r.left,r.top+1};
d1573 5
a1577 5
				if (!g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons())
				{
					r.left += OFFSET_RATINGICON;
					iWidth += OFFSET_RATINGICON;
				}
d1581 1
a1581 1
							m_imageList.Draw(dc, DL_ICON_BANNED_ONLY, point2, ILD_TRANSPARENT);
d1583 1
a1583 1
							m_imageList.Draw(dc, DL_ICON_FRIEND_ONLY, point2, ILD_TRANSPARENT);
d1585 1
a1585 1
							m_imageList.Draw(dc, DL_ICON_CREDIT_DOWNESTIMATED, point2, ILD_TRANSPARENT);
d1600 1
a1600 1
                // DonGato: different color for A4AF sources
d1610 2
a1611 2
                if(bIsA4AF)
                	dc->SetTextColor(crOldTxtColor);
d1616 8
d1625 2
a1626 14
				//	MOREVIT: - display last part size
				//	TODO: (bug - want the CURRENT part)
					uint16		iLastPart = pSource->GetLastDownPartAsked();
					uint8		ds = pSource->GetDownloadState();
					uint32		iPartSize = 0L;

					if (iLastPart != 0xFFFF && ds==DS_DOWNLOADING)
					{
						iPartSize = pSourceItem->GetFile()->GetPartSize(iLastPart);
						buffer = CastItoXBytes(iPartSize);
					}
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
					break;
				//	:MOREVIT
d1628 6
a1634 2
			break;

d1636 3
a1638 1
				if (!pSourceItem->IsAskedForAnotherFile() && nTransferredDown && !g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted()) {
d1647 1
a1647 1

d1649 3
a1651 1
				if (!bIsA4AF && nTransferredDown && g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted()) {
d1660 1
a1660 1

d1662 1
d1676 1
a1676 1

d1686 2
a1687 2
						if (pSourceItem->GetBitmap() == (HBITMAP)NULL)
							VERIFY(pSourceItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL));
d1691 1
a1691 1
						int cx = pSourceItem->GetBitmap().GetBitmapDimension().cx;
d1693 1
a1693 1
						if(pSourceItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !pSourceItem->GetUpdateTimer())
d1695 4
a1698 4
							pSourceItem->GetBitmap().DeleteObject();
							pSourceItem->GetBitmap().CreateCompatibleBitmap(dc,  iWidth, iHeight);
							pSourceItem->GetBitmap().SetBitmapDimension(iWidth,  iHeight);
							hOldBitmap = cdcStatus.SelectObject(pSourceItem->GetBitmap());
d1721 1
a1722 2
			break;

a1733 1

d1754 1
a1754 1
									buffer.Format("QR: %u", nRemoteQueueRank);
d3632 2
a3633 2
    if ((dwFilesSortCode & MLC_SORTDESC) != 0)
    {
d3816 2
a3817 2
    if  (strFileName1.IsEmpty() || strFileName2.IsEmpty())
    {
d3820 1
a3820 1
    else
d3842 1
a3842 1
        {
d3845 1
a3845 1
        }
d3861 1
a3861 1
	    case DLCOL_COMPLETED:
@


1.372
log
@changed A4AF sources count display as an option + minor cosmetic changes
@
text
@d981 1
a981 1
						int		iOldBkMode = dc->SetBkMode(TRANSPARENT);
@


1.371
log
@smartfilter preferences "core"
@
text
@a1023 1
				uint16		asc = pPartFile->GetSrcA4AFCount();
d1031 2
a1032 1
				if (asc > 0)
d1034 1
a1034 1
					buffer.AppendFormat(_T("+%i"),asc);
d1856 4
a1859 1
				if (!IsColumnHidden(DLCOL_WAITED))
d1861 1
a1861 1
					uint8		ds = pSource->GetDownloadState();
d1863 6
a1868 12
					if (ds == DS_ONQUEUE)
					{
						uint32		iSeconds = pSource->GetQueueWaitTime() / 1000.0;

						buffer = ::CastSecondsToHM(iSeconds);
					}
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag | DT_RIGHT);
					if (bMeasuring && buffer.GetLength() != 0)
					{
						iWidth += r.right-r.left+1;
					}
					break;
d1870 2
@


1.370
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d446 1
a446 1
	//		rank above 25 (TODO: Make this a pref)...
d449 1
a449 1
		  && ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() > 25 )
d2577 1
a2577 1
			menuFile.EnableMenuItem(MP_PAUSE,((eFileStatus != PS_PAUSED && eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone) ? MF_ENABLED:MF_GRAYED));
d5181 4
@


1.369
log
@minor change
@
text
@d694 1
a694 1
		CString			buffer;
d903 1
a903 1
		    case DLCOL_COMPLETED:
d912 1
a912 2
		    {
				buffer.Empty();
d981 1
a981 1
						int			iOldBkMode = dc->SetBkMode(TRANSPARENT);
d984 4
a987 2
						int pos1 = buffer.Find(_T(GetLocalDecimalPoint()));
						int pos2 = buffer.Find(_T("%"));
a1021 1
				CString		buffer2;
d1023 3
d1028 12
a1039 4
					buffer2.Format(_T("%i/"),pPartFile->GetSourceCount() -ncsc);
				else
					buffer2 = _T("");
				buffer.Format(_T("%s%i (%i)"),buffer2, pPartFile->GetSourceCount(), pPartFile->GetTransferringSrcCount());
d1041 1
d1043 2
a1044 1
				dc->DrawText(buffer,(int)_tcslen(buffer),&r, DT_RIGHT | iCalcFlag);
d1046 1
d1048 1
d1136 1
a1136 5
				if (pPartFile->GetStatus() == PS_COMPLETING || pPartFile->GetStatus() == PS_COMPLETE)
				{
					buffer = _T("");
				}
				else
d1139 1
d1141 1
d1143 1
d1145 1
d1147 9
a1155 5
					CString		str1 = buffer;
					buffer.Format( _T("%s [%.4f%%]"), str1, dblRemainingPercent);
					int pos1 = buffer.ReverseFind(_T(GetLocalDecimalPoint()));
					int pos2 = buffer.Find(_T("%"));
					if ( ( pos1 != -1 ) && ( pos2 != -1 ) && ( pos2 > pos1 ) && ( (pos2 - pos1) > 2) )
d1157 1
a1157 4
						if (buffer.GetAt((pos1 + 1)) == _T('0'))
							buffer.Delete(pos1, (pos2 - pos1));
						else
							buffer.Delete(pos1 + 2,(pos2 - pos1) - 2);
a1169 1
				buffer.Empty();
d1259 2
a1260 3
				if (lWaitedSeconds < 15)
					buffer = _T("");
				else
d1262 1
a1269 1
				buffer.Empty();
a1287 1
				buffer.Empty();
a1301 1
				buffer.Empty();
a1331 1
				buffer.Empty();
a1626 4
					else
					{
						buffer = _T("");
					}
d1659 2
a1660 3
					if (nDownloadDataRate==0)
						buffer = _T("");
					else
d1662 1
d1731 1
a1737 1
						dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
d1748 4
a1754 4
									buffer.Format("QR: %u", nRemoteQueueRank);
								}
							else if (iDifference == static_cast<int>(nRemoteQueueRank))
								{
a1761 2
							dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
							dc->SetTextColor((COLORREF)RGB(0,0,0));
a1762 8
						else
						{
							dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
						}
					}
					if (bMeasuring)
					{
						iWidth += r.right-r.left+1;
d1765 3
a1767 1
				else
d1769 1
a1769 1
					dc->DrawText(buffer,buffer.GetLength(),&r, iCalcFlag);
d1772 2
a1773 2

		    case DLCOL_STATUS:		// status
a1802 4
					else
					{
						buffer = _T("");
					}
a1822 4
					else
					{
						buffer = _T("");
					}
d1829 1
d1831 1
a1831 2
				else
					buffer = _T("");
d1840 1
d1842 1
a1842 2
				else
					buffer = _T("");
a1865 4
					else
					{
						buffer = _T("");
					}
@


1.368
log
@minor changes
@
text
@d2535 1
a2535 1
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_OTHER, GetResString(IDS_ALL_A4AF_TO_OTHER) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFOther),SSP_TAB_PREFIX)); 
d3150 1
a3150 1
					}				
d3895 2
d4646 1
a4646 1
			
@


1.367
log
@some minor changes and optimizations
@
text
@d989 1
a989 1
							if (buffer.GetAt((pos1 + 1)) == '0')
d1138 1
a1138 1
						if (buffer.GetAt((pos1 + 1)) == '0')
@


1.366
log
@Why so complex?
@
text
@d1027 1
a1027 1
					buffer2 = "";
d1095 1
a1095 1
					buffer="";
d1123 1
a1123 1
					buffer="";
d1245 1
a1245 1
					buffer = "";
d1653 1
a1653 1
						buffer="";
d1806 1
a1806 1
						buffer = "";
d1830 1
a1830 1
						buffer = "";
d1839 2
a1840 1
				else buffer="";
d1851 1
a1851 1
					buffer="";
d1877 1
a1877 1
						buffer = "";
d2779 1
a2779 1
						CString		strFileList="";
@


1.365
log
@fix for "+" & "-" keys: colapse a list even we chose a source (now it do not need to scroll to the roor)
@
text
@a2266 3
	//bool	isShift = GetAsyncKeyState(VK_SHIFT) < 0;
	//bool	isCtrl = GetAsyncKeyState(VK_CONTROL) < 0;
	//bool	isAlt = GetAsyncKeyState(VK_MENU) < 0;
a4628 4
	bool	isShift=GetAsyncKeyState(VK_SHIFT) < 0;
	bool	isCtrl=GetAsyncKeyState(VK_CONTROL) < 0;
	bool	isAlt=GetAsyncKeyState(VK_MENU) < 0;

a4630 4
	CMuleCtrlItem	*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(iClientListIndex));
	CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
	CSourceDLItem	*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
	CPartFile		*pPartFile = NULL;
d4632 1
a4632 1
	if (pFileItem != NULL)
d4634 4
a4637 6
		pPartFile = pFileItem->GetFile();
	}
	else if (pSourceItem != NULL)
	{
		pPartFile = pSourceItem->GetParentFile();
	}
d4639 6
a4644 3
	if (pPartFile)
	{
		switch(nChar)
d4646 10
a4655 20
			case VK_ADD:
				ExpandCollapseItem(iClientListIndex, EXPAND_ONLY, true);
				break;

			case VK_SUBTRACT:
				ExpandCollapseItem(iClientListIndex, COLLAPSE_ONLY, true);
				break;
		}
	}

	if (nChar == VK_CONTROL)
	{
		if (m_iSourceSortItem2 == -1)
		{
			SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending);
		}
		else
		{
			SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending,1);
			SetSortArrow(m_iSourceSortItem2, m_bSortSourcesAscending2,2);
@


1.364
log
@added 'Swap all A4AF sources to other files' by right-click menu or shortcut + minor changes
@
text
@d4640 1
d4646 5
d4652 2
@


1.363
log
@Fix for usage of undefined variable
@
text
@d2507 1
a2507 1
			if (bJustOne && !pPartFile->PreviewAvailable() && !pPartFile->IsArchive())
d2526 2
a2527 1
			if (bJustOne && eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING)
d2537 2
d3135 20
d5145 1
a5145 1
						  bJustOne && eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING )
d5150 1
a5150 1
						  bJustOne && eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING )
d5154 5
@


1.362
log
@fix for "+" & "-" keys, that were working in background
@
text
@d4615 1
a4615 2
	EnumExpandType	expandtype;
	CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(iClientListIndex));
d4617 1
a4617 1
	CPartFile			*pPartFile = NULL;
d4626 1
a4626 1
				expandtype = EXPAND_ONLY;
d4628 1
a4628 1
				
d4630 1
a4630 1
				expandtype = COLLAPSE_ONLY;
a4632 5

		if (expandtype == EXPAND_ONLY || expandtype == COLLAPSE_ONLY)
		{
			ExpandCollapseItem(iClientListIndex, expandtype, true);
		}
@


1.361
log
@*** empty log message ***
@
text
@d2267 3
a2269 3
	bool	isShift = GetAsyncKeyState(VK_SHIFT) < 0;
	bool	isCtrl = GetAsyncKeyState(VK_CONTROL) < 0;
	bool	isAlt = GetAsyncKeyState(VK_MENU) < 0;
d4566 1
a4566 1
	RefreshInfo();
d4572 1
d4613 4
a4616 2
	POSITION	posSelClient = GetFirstSelectedItemPosition();
	CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(GetItemData(GetNextSelectedItem(posSelClient)));
d4623 16
@


1.360
log
@fix for the category sorting bug
@
text
@d1618 1
a1618 1
						buffer = "";
@


1.359
log
@best QR variation calculation thX to Aw3
@
text
@d3972 1
@


1.358
log
@More Kush changes for localization, minor optimizations and fix for Upload AutoPriority.
@
text
@d1440 1
a1440 1
		uint16				nDifference = pSource->GetDifference(); //cendre-eau
d1736 1
a1736 3
							COLORREF		crOldTxtColor;

							if (nDifference == nRemoteQueueRank)
d1738 2
a1739 2
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
								buffer.Format("QR: %u", nRemoteQueueRank);
d1741 1
a1741 1
							else if (nDifference < nRemoteQueueRank)
d1743 1
a1743 3
								if (nDifference == 0)
								{
									crOldTxtColor = dc->SetTextColor((COLORREF)RGB(5,65,195));
d1746 1
a1746 1
								else
d1748 1
a1748 3
									crOldTxtColor = dc->SetTextColor((COLORREF)RGB(190,60,60));
									buffer.Format("QR: %u (+%u)", nRemoteQueueRank, nDifference);
								}
d1752 2
a1753 2
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(10,160,70));
								buffer.Format("QR: %u (-%u)", nRemoteQueueRank, (65536-nDifference));
d1756 1
a1756 1
							crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
@


1.357
log
@Some AW3 suggestions
@
text
@d24 1
a24 1
#include "otherfunctions.h" 
d53 1
a53 1
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)	
d64 1
a64 1
CDownloadListCtrl::CDownloadListCtrl() 
d96 1
a96 1
	
d187 1
a187 1
	{	
d190 1
a190 1
	else 
d210 1
a210 1
void CDownloadListCtrl::Localize() 
d365 1
a365 1
	
d398 1
a398 1
	if (pSourceItem != NULL && ::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_pdlgEmule->IsRunning()) 
d462 1
a462 1
		  && ds == DS_CONNECTED) 
d531 1
a531 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning() || pFileItem == NULL) 
d555 1
a555 1
	
d654 1
a654 1
	
d662 1
a662 1
void CDownloadListCtrl::DrawFileItem(CDC *dc, int nColumn, LPRECT lpRect, CPartFileDLItem *pFileItem) 
d692 1
a692 1
	if (lpRect->left < lpRect->right) 
d762 1
a762 1
				if ( g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons() 
d816 1
a816 1
						
d875 1
a875 1
				
d957 1
a957 1
					{ 
d972 1
a972 1
					else 
d997 1
a997 1
						
d1041 1
a1041 1
	
d1117 1
a1117 1
				if (iRemaining < 0) 
d1131 1
a1131 1
						dblRemainingPercent = 0.0;					
d1392 1
a1392 1
	if (lpRect->left < lpRect->right) 
d1456 2
a1457 2
		
		switch (nColumn) 
d1520 1
a1520 1
	
d1578 1
a1578 1
				
d1590 1
a1590 1
    
d1610 1
a1610 1
	    
d1681 1
a1681 1
					{ 
d1697 1
a1697 1
					} else 
d1742 1
a1742 1
							}      
d1744 1
a1744 1
							{  
d1793 1
a1793 1
			
d1802 1
a1802 1
	    
d1825 1
a1825 1
	    
d1829 1
a1829 1
	    
d1831 1
a1831 1
	    
d1873 1
a1873 1
	    
d1877 1
a1877 1
	    
d1923 1
a1923 1
	{	
d1984 1
a1984 1
		for (int iCurrent = 0; iCurrent < iNumColumns; iCurrent++) 
d2004 2
a2005 2
			} 
			else 
d2013 1
a2013 1
	} 
d2035 2
a2036 2
			} 
			else 
d2070 1
a2070 1
		} 
d2078 1
a2078 1
		} 
d2233 1
a2233 1
		
d2256 1
a2256 1
	
d2264 1
a2264 1
	if (iItem == -1) 
d2278 1
a2278 1
	if (bCollapseSource && pSourceItem != NULL && pSourceItem->GetParentFileItem() != NULL) 
d2282 1
a2282 1
		
d2294 1
a2294 1
		{		
d2297 1
a2297 1
		
d2300 1
a2300 1
		if (pPartFile == NULL) 
d2306 1
a2306 1
		if (pFileItem->m_bSrcsAreVisible == false && pPartFile->GetStatus() != PS_COMPLETING) 
d2313 1
a2313 1
				
d2338 1
a2338 1
		else 
d2340 1
a2340 1
			if (expand == EXPAND_COLLAPSE || expand == COLLAPSE_ONLY) 
d2433 1
a2433 1
		if (pFileItem != NULL) 
d2447 1
a2447 1
		
d2640 1
a2640 1
			if (pSource != NULL) 
d2646 1
a2646 1
			
d2724 2
a2725 2
		while (pos != NULL) 
		{ 
d2727 1
a2727 1
			if (iIndex > -1) 
d2734 2
a2735 2
			} 
		} 
d2743 1
a2743 1
			if (wParam >= MP_WEBURL && wParam <= MP_WEBURL + 64) 
d2751 2
a2752 2
				while (!selectedList.IsEmpty()) 
				{ 
d2767 1
a2767 1
				}				
d2781 1
a2781 1
				//	For multiple selections 
d2810 1
a2810 1
	
d2815 1
a2815 1
								{ 
d2831 1
a2831 1
							}  
d2843 2
a2844 2
						while(!selectedList.IsEmpty()) 
						{ 
d2848 1
a2848 1
						} 
d2851 1
a2851 1
					} 
d2859 2
a2860 2
						while(!selectedList.IsEmpty()) 
						{ 
d2867 1
a2867 1
					} 
d2875 1
a2875 1
						while(!selectedList.IsEmpty()) 
d2883 1
a2883 1
					} 
d2891 1
a2891 1
						while(!selectedList.IsEmpty()) 
d2899 1
a2899 1
					} 
d2907 2
a2908 2
						while(!selectedList.IsEmpty()) 
						{ 
d2911 1
a2911 1
						} 
d2914 1
a2914 1
					} 
d2921 2
a2922 2
						while(!selectedList.IsEmpty()) 
						{ 
d2928 1
a2928 1
					} 
d2935 1
a2935 1
					} 
d2944 1
a2944 1
					} 
d2948 1
a2948 1
				case MP_RENAME: 
d2960 1
a2960 1
							pPartFile->SavePartFile(); 
d2972 2
a2973 2
						while(!selectedList.IsEmpty()) 
						{ 
d2981 1
a2981 1
					} 
d3012 2
a3013 2
						while(!selectedList.IsEmpty()) 
						{ 
d3020 1
a3020 1
					} 
d3027 2
a3028 2
						while(!selectedList.IsEmpty()) 
						{ 
d3035 1
a3035 1
					} 
d3041 1
a3041 1
					{	
d3048 1
a3048 1
				//FakeCheck 
d3050 1
a3050 1
				{ 
d3054 1
a3054 1
					} 
d3059 1
a3059 1
				{ 
d3063 1
a3063 1
					} 
d3071 1
a3071 1
					{	
d3083 1
a3083 1
				case MP_CHANGEDIR: 
d3100 1
a3100 1
							}			
d3110 1
a3110 1
					{ 
d3152 1
a3152 1
							}	
d3164 1
a3164 1
					}						
d3169 1
a3169 1
					{ 
d3177 1
a3177 1
					} 
d3179 1
a3179 1
					
d3186 1
a3186 1
						{ 
d3195 1
a3195 1
					} 
d3203 2
a3204 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3209 1
a3209 1
					} 
d3216 2
a3217 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3222 1
a3222 1
					} 
d3229 2
a3230 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3235 1
a3235 1
					} 
d3242 2
a3243 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3248 1
a3248 1
					} 
d3255 2
a3256 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3261 1
a3261 1
					} 
d3268 2
a3269 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3274 1
a3274 1
					} 
d3281 2
a3282 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3287 1
a3287 1
					} 
d3294 2
a3295 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3300 1
a3300 1
					} 
d3307 2
a3308 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3313 1
a3313 1
					} 
d3320 2
a3321 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3326 1
a3326 1
					} 
d3333 2
a3334 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3339 1
a3339 1
					} 
d3346 2
a3347 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3352 1
a3352 1
					} 
d3359 2
a3360 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3365 1
a3365 1
					} 
d3372 2
a3373 2
						while (!selectedItemList.IsEmpty()) 
						{ 
d3378 1
a3378 1
					} 
d3410 1
a3410 1
				case MP_DOWNNOW: 
d3416 1
a3416 1
				}				
d3537 1
a3537 1
	
d3681 1
a3681 1
		} 
d3683 1
a3683 1
		else 
d3689 1
a3689 1
			{ 
d3699 1
a3699 1
				{	
d3703 1
a3703 1
				{	
d3707 1
a3707 1
				{	
d3741 1
a3741 1
void CDownloadListCtrl::SetStyle() 
d3778 1
a3778 1
void CDownloadListCtrl::OnListModified(NMHDR *pNMHDR, LRESULT *pResult) 
d3812 1
a3812 1
    {   
d3816 1
a3816 1
	{   
d3823 1
a3823 1
/*static*/ int CDownloadListCtrl::Compare(CPartFile *file1, CPartFile *file2, LPARAM lParamSort) 
d3887 1
a3887 1
		case DLCOL_STATUS: //Status asc 
d3920 1
a3920 1
			{	
d3924 1
a3924 1
			{	
d3928 1
a3928 1
			{	
d3933 1
a3933 1
		case DLCOL_LASTSEENCOMPLETE: //Last seen complete asc 
d3936 1
a3936 1
			{    
d3940 1
a3940 1
			{    
d3944 1
a3944 1
			{    
d3956 1
a3956 1
			{	
d4014 1
a4014 1
			{	
d4018 1
a4018 1
			{	
d4022 1
a4022 1
			{	
d4049 1
a4049 1
			{	
d4053 1
a4053 1
			{	
d4057 1
a4057 1
			{	
d4084 1
a4084 1
			{	
d4088 1
a4088 1
			{	
d4092 1
a4092 1
			{	
d4098 1
a4098 1
	
d4160 1
a4160 1
					if (plus1 && plus2) 
d4204 1
a4204 1
				iCompare = pClient1->GetRemoteQueueRank() - pClient2->GetRemoteQueueRank();   
d4247 1
a4247 1
				if ( lParamSort==10 && isValid1 && isValid2)											//Cax2 - bugfix after reCDVst changes 
d4251 1
a4251 1
				else if (isValid1 && isValid2)																//Cax2 - it's got to be lParamSort==11 after reCDVst changes 
d4303 1
a4303 1
	
d4374 1
a4374 1
	// Get indexes of the first and last visible items in 
d4456 1
a4456 1
				{	
d4467 1
a4467 1
	
d4508 2
a4509 2
			} 
			else 
d4516 1
a4516 1
	
d4533 3
a4535 3
// After that modded by Vorlost too 
void CDownloadListCtrl::RestartWaitingDownloads() 
{ 
a4540 1
	POSITION	pos;
d4542 1
a4542 1
//	Vorlost - get initial sources from server if we dont have our MaxSourcesPerFile Limit reached 
d4552 1
a4552 1
	   	} 
d4557 3
a4559 3
	for (pos = selectedList.GetHeadPosition(); pos != 0; selectedList.GetNext(pos)) 
		selectedList.GetAt(pos)->GetSourcesAfterServerConnect();
    
d4654 1
a4654 1
		{			
d4656 2
a4657 2
		} 
		else 
d4668 1
a4668 1
			} 
d4676 2
a4677 2
			}	
		}	
d4684 1
a4684 1
void CDownloadListCtrl::ShowFilesCount() 
d4689 1
a4689 1
void CDownloadListCtrl::ShowSelectedFileDetails() 
d4703 1
a4703 1
	SetSelectionMark(it);   // display selection mark correctly! 
d4722 1
a4722 1
		else 
d4771 1
a4771 1
		else 
d4849 1
a4849 1
	EMULE_CATCH	
@


1.356
log
@Reverted completion changes (now completion is done after a block is sent) and some minor changes by KuSh.
@
text
@a1744 2
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(190,60,60));
								buffer.Format("QR: %u (+%u)", nRemoteQueueRank, nDifference);
d1750 5
@


1.355
log
@small corrections & some optimizations
@
text
@d1741 1
a1741 1
								buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nRemoteQueueRank-nDifference));
d1746 1
a1746 1
								buffer.Format("QR: %u (+%u)",nRemoteQueueRank,(nDifference));
d1750 1
a1750 1
									buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nDifference));
d1756 1
a1756 1
								buffer.Format("QR: %u (-%u)",nRemoteQueueRank,(65536-nDifference));
@


1.354
log
@Some corrections in shortcut management code to keep new engine hierarchy (thanks to eklmn ;-))
@
text
@d5030 3
a5032 4
		int iMessage = 0;
		short nCode = GetCodeFromPressedKeys(pMsg);
		CMuleCtrlItem *pItem = ListGetOneSelectedItem();
		CPartFileDLItem *pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
d5034 1
a5034 2
	//	if the selected item is a file...
		if (pFileItem != NULL)
d5036 97
a5132 8
			CPartFile* pPartFile = pFileItem->GetFile();
			bool bJustOne  = (GetSelectedCount() == 1);
			bool bFileDone = (pPartFile->GetStatus() == PS_COMPLETE || pPartFile->GetStatus() == PS_COMPLETING );
			EnumPartFileStatuses eFileStatus = pPartFile->GetStatus();

			if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLCancel) && !bFileDone)
			{
				iMessage = MP_CANCEL;
d5134 2
a5135 2
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLStop) &&
					  eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone )
d5137 3
a5139 21
				iMessage = MP_STOP;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPause) &&
					  eFileStatus != PS_PAUSED && eFileStatus != PS_STOPPED && eFileStatus != PS_ERROR && !bFileDone )
			{
				iMessage = MP_PAUSE;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLResume) &&
					  (eFileStatus == PS_PAUSED || eFileStatus == PS_STOPPED) )
			{
				iMessage = MP_RESUME;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpen) &&
					  bJustOne && eFileStatus == PS_COMPLETE )
			{
				iMessage = MP_OPEN;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreview) &&
					  bJustOne && pPartFile->PreviewAvailable() )
			{
				iMessage = MP_PREVIEW;
a5140 61
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLRename) && bJustOne)
			{
				iMessage = MP_RENAME;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLComments) &&
				      bJustOne && (pPartFile->HasComment() || pPartFile->HasRating()) )
			{
				iMessage = MP_VIEWFILECOMMENTS;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetails) && bJustOne)
			{
				iMessage = MP_METINFO;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetailsSources) && bJustOne)
			{
				iMessage = MP_METINFOSOURCES;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear))
			{
				iMessage = MP_CLEARCOMPLETED;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLShowAllUp))
			{
				ShowAllUploadingSources();
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLUseDefaultSort))
			{
				SortInit(DL_OVERRIDESORT);
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreallocate) &&
					  bJustOne && !pPartFile->IsLastBlockComplete() && !pPartFile->IsPreallocated() )
			{
				iMessage = MP_PREALLOCATE;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF) &&
					  bJustOne && eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING )
			{
				iMessage = MP_ALL_A4AF_TO_HERE;
			}
			else if ( nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFAuto) &&
					  bJustOne && eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING )
			{
				iMessage = MP_ALL_A4AF_AUTO;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2KLink))
			{
				iMessage = MP_GETED2KLINK;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkHtml))
			{
				iMessage = MP_GETHTMLED2KLINK;
			}
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkSource))
			{
				iMessage = MP_GETSOURCEED2KLINK;
			}
		}
	//	if the selected item is a source...
		else
		{
			POSITION posSelClient = GetFirstSelectedItemPosition();
d5142 1
a5142 1
			if (posSelClient != NULL)
d5144 2
a5145 2
				CUpDownClient* pSource = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));
				iMessage = GetClientListActionFromShortcutCode(nCode, pSource);
a5147 6

		if (iMessage > 0)
		{
			PostMessage(WM_COMMAND, iMessage);
			return TRUE;
		}
d5150 1
a5150 1
	return __super::PreTranslateMessage(pMsg);
@


1.353
log
@solution for selection & clicking (hopefuilly it will be final)
@
text
@d5035 1
d5129 11
@


1.352
log
@refresh an InfoList only if ListCtrl is active
@
text
@d4326 39
d4388 1
a4388 1
			CMuleCtrlItem	*pListItem = ListGetItemAt(index);
d4392 1
a4392 1
				return;
d4457 1
a4457 1
            }
d4474 1
a4474 1
	int		iSel = GetSelectionMark();
d4476 1
a4476 1
	if (iSel != -1)
d4478 3
a4480 3
		CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4615 3
a4617 2
	CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
	CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
d4650 2
a4651 2
		POSITION		pos = GetFirstSelectedItemPosition();
		if (pos == NULL)
d4657 3
a4659 3
			CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
			CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
			CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
@


1.351
log
@some minor loop corrections
@
text
@d400 1
a400 1
		int		iItem = ListGetSourceItemIndex(pSourceItem);
d4608 1
a4608 7
	POSITION		pos = GetFirstSelectedItemPosition();

	if (pos == NULL)
	{			
 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
	} 
	else 
d4610 10
a4619 3
		CMuleCtrlItem		*pItem = ListGetOneSelectedItem();
		CPartFileDLItem		*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d4621 3
a4623 3
		if (pFileItem != NULL)
		{
			const CPartFile		*pPartFile = pFileItem->GetFile();
d4625 4
a4628 4
 			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_FILE,const_cast<CPartFile*>(pPartFile));
		} 
		else if (pSourceItem != NULL)
		{
d4630 1
a4630 1
			const CUpDownClient	*pSource = pSourceItem->GetSource();
d4632 1
a4632 1
 			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,const_cast<CUpDownClient*>(pSource));
d4634 1
d4636 1
a4636 1
	}	
@


1.350
log
@minor naming change
@
text
@d4502 1
a4502 1
	for (int i = 0; i != iNumItems; i++)
@


1.349
log
@Updated shortcut management
@
text
@d2945 1
a2945 1
				case MP_F2: 
d5031 1
a5031 1
				iMessage = MP_F2;
@


1.348
log
@open 'rename & cleanup box' on pressing F2 in downloads pane
@
text
@d2995 10
a4597 25
	if (isCtrl)
	{
		if (nChar == 'U')
		{
			bHandled = true;

			ShowAllUploadingSources();
		}
		else if (nChar == 'R' && pFileItem != NULL)
		{
			bHandled = true;

			CFileDetails		dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);

			dialog.SetActivePage(2);
			dialog.DoModal();
			SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
		}
		else if (nChar == 'S' && g_eMuleApp.m_pGlobPrefs->DoUseSort())
		{
			bHandled = true;

			SortInit(DL_OVERRIDESORT);
		}
	}
d5029 4
d5042 4
d5049 8
@


1.347
log
@Code for debug. Will be removed later.
@
text
@d31 1
d2945 20
@


1.346
log
@Fix for Remaining sorting
@
text
@d1448 4
d3159 1
a3159 1
						AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
@


1.345
log
@stalled files smartfilter bugfix
@
text
@d3856 2
a3857 4
			int		tmp1 = file1->GetFileSize()-file1->GetCompletedSize();
			int		tmp2 = file2->GetFileSize()-file2->GetCompletedSize();

			iCompare = (tmp1 == tmp2) ? 0 : ((tmp1 < tmp2) ? -1 : 1);
@


1.344
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d5087 1
a5087 1
	else if (eStatus == PS_WAITINGFORSOURCE)
@


1.343
log
@Fix for jumping non-eMule clients
@
text
@d4418 2
a4419 2
				strBuffer.Format(_T("%s\\%s"),pPartFile->GetPath(),pPartFile->GetFileName());
				AddLogLine(false, _T("%s\\%s"),pPartFile->GetPath(),pPartFile->GetFileName());
d4486 1
a4486 1
	AddLogLine(true,IDS_NEWSERVERCONNECT,g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
@


1.342
log
@Fix for A4AF icon showing without file status icons.
@
text
@d4172 8
a4179 1
				iCompare = (pClient1->IsEmuleClient())?((pClient2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
d4183 8
a4190 1
				iCompare = (pClient1->GetRemoteQueueRank()==0)?((pClient2->GetRemoteQueueRank()==0)?0:2):-1;
@


1.341
log
@fixed crash  due context menu, shortcut optimiation & update to UNICODE
@
text
@d761 2
a762 1
				if (pPartFile == g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() && !bMeasuring)
@


1.340
log
@minor fix
@
text
@d2463 3
a2465 3
			menuED2K.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2KLink)));
			menuED2K.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkHtml)));
			menuED2K.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLED2kLinkSource)));
d2499 1
a2499 1
			menuAdvanced.AppendMenu(MF_STRING,MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreallocate)));
d2516 1
a2516 1
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AF)));
d2522 1
a2522 1
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,strBuffer + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLA4AFAuto)));
d2571 1
a2571 1
			menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear)));
d2579 1
a2579 1
			menuFile.AppendMenu(MF_STRING,MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLCancel)));
d2582 1
a2582 1
			menuFile.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLStop)));
d2585 1
a2585 1
			menuFile.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPause)));
d2588 1
a2588 1
			menuFile.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLResume)));
d2596 1
a2596 1
			menuFile.AppendMenu(MF_STRING,MP_OPEN, GetResString(IDS_DL_OPEN) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLOpen)));
d2599 1
a2599 1
			menuFile.AppendMenu(MF_STRING,MP_PREVIEW, GetResString(IDS_DL_PREVIEW) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLPreview)));
d2602 1
a2602 1
			menuFile.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLDetails)));
d2605 1
a2605 1
			menuFile.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLComments)));
d2638 1
a2638 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails)));
d2640 1
a2640 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
d2642 3
a2644 3
				menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
			menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage)));
			menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles)));
d2658 1
a2658 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexDLClear)));
@


1.339
log
@proper InfoList handling
@
text
@d1128 2
@


1.338
log
@Percent completed on the progress bar should be in the middle now + Hebrew translation update
@
text
@d540 1
a540 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d2435 1
a2435 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(pPartFile);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d2630 1
a2630 2
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser(const_cast<CUpDownClient*>(pSource));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d4587 1
a4587 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d4599 1
a4599 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(const_cast<CPartFile*>(pPartFile));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d4606 1
a4606 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser(const_cast<CUpDownClient*>(pSource));
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
@


1.337
log
@Correct localization of decimal point & thousands seperator + Correct encoding for Hebrew language in WebServer
@
text
@d994 3
d999 1
a999 1
						r.left += ((iBarWidth / 2) - (buffer.GetLength() * 3));
@


1.336
log
@Localization fix for percent remaining + Hebrew translation update
@
text
@d687 1
a687 1
		iCalcFlag = (iCalcFlag | DT_RTLREADING);
d984 1
a984 1
						int pos1 = buffer.FindOneOf(_T(".,"));
d1128 1
a1128 3
					int pos1 = buffer.ReverseFind('.');
					if ( pos1 == -1 )
						pos1 = buffer.ReverseFind(',');
@


1.335
log
@Added a function: bool IsRightToLeftLanguage(); + Fixed Hebrew text alignment in Shared Files list + Hebrew translation update
@
text
@d1129 2
a1130 2
					if ( pos1 != -1 )
						buffer.ReverseFind(',');
@


1.334
log
@Fixed Hebrew text alignment in Client, Downlod, Queue & Upload lists to Right-To-Left
@
text
@d686 1
a686 1
	if ( g_eMuleApp.m_pGlobPrefs->GetLanguageID() == 1037 )
@


1.333
log
@Fix for percent remaining showing more than 100%
@
text
@d686 3
@


1.332
log
@percent remaining is more accurate
@
text
@d1121 2
a1123 1

@


1.331
log
@Show minimal info on progress bar (remove .0 at end - 0.0% = 0% 10.0% = 10% etc.)
@
text
@d1120 1
a1120 1
					double		dblRemainingPercent = 100.0 - pPartFile->GetPercentCompleted();
d1123 12
a1134 1
					buffer.Format( _T("%s [%.1f%%]"), str1, dblRemainingPercent);
@


1.330
log
@minor change
@
text
@d983 7
a989 2
						if ( ( pos1 != -1 ) && ( pos2 != -1 ) && ( pos2 > pos1 ) && ( (pos2 - pos1) >2) )
							buffer.Delete(pos1 + 2,(pos2 - pos1) - 2);
d993 2
a994 1
						r.left += iBarWidth / 2 - 10;
@


1.329
log
@Fixed a localization bug with the display of percent complete on the progress bar.
@
text
@d980 3
a982 5
						buffer.Format("%.4f%%", pPartFile->GetPercentCompleted());
						int pos1 = buffer.Find('.');
						if ( pos1 == -1 )
							pos1 = buffer.Find(',');
						int pos2 = buffer.Find('%');
@


1.328
log
@Fix for bug #0000460
@
text
@d982 2
@


1.327
log
@percent completed is now even more accurate
@
text
@d3057 1
a3060 1
					g_eMuleApp.m_pSharedFilesList->Reload(false);	//SyruS: Is this whole reload needed just for updating shared filename?
@


1.326
log
@don't try to cleanup completed files; +2 question-comments
@
text
@d980 5
a984 1
						buffer.Format("%.1f%%", pPartFile->GetPercentCompleted());
@


1.325
log
@defaulting "show avg speed/time" to off; no brackets in seperate columns
@
text
@d2470 1
a2470 1
			menuAdvanced.EnableMenuItem(MP_DOCLEANUP, !bFileDone ? MF_ENABLED:MF_GRAYED);
d2489 1
a2489 1
			menuAdvanced.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, ((eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING) ? MF_ENABLED : MF_GRAYED));
d2491 1
a2491 1
			menuAdvanced.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(bJustOne && eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING) ? MF_ENABLED : MF_GRAYED);
d3027 1
a3027 1
					if(newpath!=dir)
d3029 1
a3029 1
						if(iNumSelected > 1)
d3031 1
a3031 1
							while(!selectedList.IsEmpty())
d3040 1
a3040 1
						pPartFile->GetOutputDir();
d3045 1
a3045 1
					while(!selectedList.IsEmpty())
d3047 7
a3053 6
						CPartFile* selFile = selectedList.GetHead();	//subst for shorter code, debugging & intellisense
						selFile->SetFileName(CleanupFilename(selFile->GetFileName()).GetBuffer());
						selFile->SavePartFile();
						g_eMuleApp.m_pSharedFilesList->Reload(false);
						selFile->UpdateDisplayedInfo(true);		//better update (saves last updatetime)
						//UpdateFileItem(selectedList.GetHead());	//update display at once, not in 1 sec
d3056 1
@


1.324
log
@*** empty log message ***
@
text
@d923 1
a923 1
				else
d1235 1
a1235 1
					buffer.AppendFormat(_T("[%.2f]"), pPartFile->GetAvgDataRate(false)/1024.0f);
@


1.323
log
@Reverted localization of Last Seen Complete & Last Reception
@
text
@d91 1
a91 1
	ilDummyImageList.Create(1, 17, ILC_COLOR32 | ILC_MASK, 1, 1); 
d718 32
a749 11
						case PS_COMPLETING:			iIcon = DL_ICON_STATUS_COMPLETING; break;
						case PS_COMPLETE:			iIcon = DL_ICON_STATUS_COMPLETE; break;
						case PS_DOWNLOADING:		iIcon = DL_ICON_STATUS_DOWNLOADING; break;
						case PS_WAITINGFORSOURCE:	iIcon = DL_ICON_STATUS_WAITING; break;
						case PS_WAITINGFORHASH:		iIcon = DL_ICON_STATUS_WAITINGHASH; break;
						case PS_HASHING:			iIcon = DL_ICON_STATUS_HASHING; break;
						case PS_PAUSED:				iIcon = DL_ICON_STATUS_PAUSED; break;
						case PS_STALLED:			iIcon = DL_ICON_STATUS_STALLED; break;
						case PS_STOPPED:			iIcon = DL_ICON_STATUS_STOPPED; break;
						case PS_ERROR:				iIcon = DL_ICON_STATUS_ERRONEOUS; break;
						default:					iIcon = DL_ICON_STATUS_ERRONEOUS;
d791 1
a791 1
										break; 
d794 1
a794 1
										break; 
d797 1
a797 1
										break; 
d800 1
a800 1
										break; 
d803 1
a803 1
										break; 
d938 1
a938 1
					int		iBarWidth = r.right - r.left; 
d942 1
a942 1
						VERIFY(pFileItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL)); 
d944 1
a944 1
					CDC			cdcStatus; 
d947 1
a947 1
					cdcStatus.CreateCompatibleDC(dc); 
d949 2
a950 2
					int		cx = pFileItem->GetBitmap().GetBitmapDimension().cx; 
					DWORD	dwTicks = GetTickCount(); 
d954 11
a964 11
						pFileItem->GetBitmap().DeleteObject(); 
						pFileItem->GetBitmap().CreateCompatibleBitmap(dc,  iBarWidth, iBarHeight); 
						pFileItem->GetBitmap().SetBitmapDimension(iBarWidth,  iBarHeight); 
						hOldBitmap = cdcStatus.SelectObject(pFileItem->GetBitmap()); 

						RECT rec_status; 
						rec_status.left = 0; 
						rec_status.top = 0; 
						rec_status.bottom = iBarHeight; 
						rec_status.right = iBarWidth; 
						pPartFile->DrawStatusBar(&cdcStatus,  &rec_status, g_eMuleApp.m_pGlobPrefs->UseFlatBar()); 
d966 1
a966 1
						pFileItem->SetUpdateTimer(dwTicks + (rand() % 128)); 
d969 1
a969 1
						hOldBitmap = cdcStatus.SelectObject(pFileItem->GetBitmap()); 
d971 1
a971 1
					dc->BitBlt(r.left, r.top, iBarWidth, iBarHeight,  &cdcStatus, 0, 0, SRCCOPY); 
d1477 1
a1477 1
               			m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL); 
d1481 1
a1481 1
							try{ status.Format(_T("(%s)"),pSource->m_pReqPartFile->GetFileName()); }catch(...){}
d1635 2
a1636 2
					lpRect->bottom--; 
					lpRect->top++; 
d1638 2
a1639 2
					int iWidth = lpRect->right - lpRect->left; 
					int iHeight = lpRect->bottom - lpRect->top; 
d1641 2
a1642 2
							VERIFY(pSourceItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL)); 
					CDC cdcStatus; 
d1644 3
a1646 3
					cdcStatus.CreateCompatibleDC(dc); 
						int cx = pSourceItem->GetBitmap().GetBitmapDimension().cx; 
					DWORD dwTicks = GetTickCount(); 
d1649 10
a1658 10
							pSourceItem->GetBitmap().DeleteObject(); 
							pSourceItem->GetBitmap().CreateCompatibleBitmap(dc,  iWidth, iHeight); 
							pSourceItem->GetBitmap().SetBitmapDimension(iWidth,  iHeight); 
							hOldBitmap = cdcStatus.SelectObject(pSourceItem->GetBitmap()); 

						RECT rec_status; 
						rec_status.left = 0; 
						rec_status.top = 0; 
						rec_status.bottom = iHeight; 
						rec_status.right = iWidth; 
d1660 1
a1660 1
							pSource->DrawStatusBar(&cdcStatus,  &rec_status,(pSourceItem->IsAskedForAnotherFile()), g_eMuleApp.m_pGlobPrefs->UseFlatBar()); 
d1663 1
a1663 1
						pSourceItem->SetUpdateTimer(dwTicks + (rand() % 128)); 
d1665 1
a1665 1
						hOldBitmap = cdcStatus.SelectObject(pSourceItem->GetBitmap()); 
d1667 1
a1667 1
					dc->BitBlt(lpRect->left, lpRect->top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
d1670 2
a1671 2
					lpRect->bottom++; 
					lpRect->top--; 
d2163 1
a2163 1
	for (int i = 0; i < GetItemCount(); )
d2172 2
a2173 2
			pSourceItem->ResetUpdateTimer(); 
			pSourceItem->GetBitmap().DeleteObject(); 
d2184 1
a2184 1
		m_bShowSrc = false; 
d2259 1
a2259 1
			m_iFilesSortIndex = m_dwLastSortCode; 
d2577 1
a2577 1
			menuFile.EnableMenuItem(MP_METINFO,(bJustOne)?MF_ENABLED:MF_GRAYED); // Cax2
d2580 1
a2580 1
			menuFile.EnableMenuItem(MP_VIEWFILECOMMENTS,(bJustOne && (pPartFile->HasComment() || pPartFile->HasRating())) /*&& !bFileDone*/ ?MF_ENABLED:MF_GRAYED); // Cax2  //netwolf: no comments on complete files	// netwolf 06.05.03 only enabled if there is a comment/rating	// #zegzav:pastcomment; allow to see past comments for completed files
d2683 1
a2683 1
		UINT		iNumSelected = GetSelectedCount(); 
d2685 1
a2685 1
		POSITION	pos = GetFirstSelectedItemPosition(); 
d2692 1
a2692 1
			iIndex = GetNextSelectedItem(pos); 
d2732 1
a2732 1
					selectedList.RemoveHead(); 
d2752 1
a2752 1
						
d2759 2
a2760 2
									strFileList.Append("\n"+CString(selectedList.GetAt(pos)->GetFileName())); 
							} 
d2766 1
a2766 1
						{	
d2770 1
a2770 1
						{	
d2774 1
a2774 1
						{ 
d2780 1
a2780 1
								switch(selectedList.GetHead()->GetStatus()) 
d2786 1
a2786 1
										selectedList.RemoveHead(); 
d2790 1
a2790 1
										selectedList.GetHead()->DeleteFile(); 
d2794 2
a2795 2
										selectedList.GetHead()->DeleteFile(); 
										selectedList.RemoveHead(); 
d2800 1
d2811 3
a2813 3
							selectedList.GetHead()->SetAutoPriority(false); 
							selectedList.GetHead()->SetPriority(PR_HIGH); 
							selectedList.RemoveHead(); 
d2816 1
a2816 1
						break; 
d2827 3
a2829 3
							selectedList.GetHead()->SetAutoPriority(false); 
							selectedList.GetHead()->SetPriority(PR_LOW); 
							selectedList.RemoveHead(); 
d2832 1
a2832 1
						break; 
d2875 2
a2876 2
							selectedList.GetHead()->PauseFile(); 
							selectedList.RemoveHead(); 
d2879 1
a2879 1
						break; 
d2889 2
a2890 2
							selectedList.GetHead()->ResumeFile(); 
							selectedList.RemoveHead(); 
d2893 1
a2893 1
						break; 
d2900 1
a2900 1
						break; 
d2909 1
a2909 1
						break; 
d2922 2
a2923 2
							selected->StopFile(); 
							selectedList.RemoveHead(); 
d2926 1
a2926 1
						break; 
d2950 2
a2951 2
							str += selectedList.GetHead()->CreateED2kLink() + "\n"; 
							selectedList.RemoveHead(); 
d2955 1
a2955 1
						break; 
d2965 2
a2966 2
							str += selectedList.GetHead()->CreateHTMLED2kLink() + "\n"; 
							selectedList.RemoveHead(); 
d2970 1
a2970 1
						break; 
d2981 1
a2981 1
					break; 
d2989 1
a2989 1
						break; 
d2998 1
a2998 1
						break; 
d3015 2
a3016 2
					CCommentDialogLst dialog(pPartFile); 
					dialog.DoModal(); 
d3022 1
a3022 1
					if (dir.GetLength() == 2) // DonGato: fix for root directories
d3025 1
a3025 1
					if (newpath.GetLength() == 3) // DonGato: fix for root directories
d3040 1
a3040 1
						pPartFile->GetOutputDir(); //<<-- to add new path to shared list
d3056 1
a3056 1
				case MP_ALL_A4AF_TO_HERE: // Tarod
d3061 1
a3061 1
				case MP_ALL_A4AF_AUTO: // Tarod
a3062 1
						// v6:- eklmn: A4AF management
d3071 1
a3071 1
				// DonGato - Movie Preview Mode
a3099 1
				// DonGato - Movie Preview Mode end
a3100 1
                // obaldin - make dropping supercompressed a per-pPartFile setting
d3113 1
a3113 2

				// START - enkeyDEV(Ottavio84) -ThniCreate source ed2k from downloads-
d3121 2
a3122 2
							str += selectedList.GetHead()->CreateED2KSourceLink(7, 10); 
							selectedList.RemoveHead(); 
d3128 1
a3128 1
						break; 
d3139 2
a3140 2
							selectedItemList.GetHead()->m_bShowUploadingSources = !selectedItemList.GetHead()->m_bShowUploadingSources; 
							selectedItemList.RemoveHead(); 
d3144 1
a3144 1
					break; 
d3152 2
a3153 2
							selectedItemList.GetHead()->m_bShowOnQueueSources = !selectedItemList.GetHead()->m_bShowOnQueueSources; 
							selectedItemList.RemoveHead(); 
d3157 1
a3157 1
					break; 
d3165 2
a3166 2
							selectedItemList.GetHead()->m_bShowFullQueueSources = !selectedItemList.GetHead()->m_bShowFullQueueSources; 
							selectedItemList.RemoveHead(); 
d3170 1
a3170 1
					break; 
d3178 2
a3179 2
							selectedItemList.GetHead()->m_bShowConnectedSources = !selectedItemList.GetHead()->m_bShowConnectedSources; 
							selectedItemList.RemoveHead(); 
d3183 1
a3183 1
					break; 
d3191 2
a3192 2
							selectedItemList.GetHead()->m_bShowConnectingSources = !selectedItemList.GetHead()->m_bShowConnectingSources; 
							selectedItemList.RemoveHead(); 
d3196 1
a3196 1
					break; 
d3204 2
a3205 2
							selectedItemList.GetHead()->m_bShowNNPSources = !selectedItemList.GetHead()->m_bShowNNPSources; 
							selectedItemList.RemoveHead(); 
d3209 1
a3209 1
					break; 
d3217 2
a3218 2
							selectedItemList.GetHead()->m_bShowTooManyConnSources = !selectedItemList.GetHead()->m_bShowTooManyConnSources; 
							selectedItemList.RemoveHead(); 
d3222 1
a3222 1
					break; 
d3230 2
a3231 2
							selectedItemList.GetHead()->m_bShowLowToLowIDSources = !selectedItemList.GetHead()->m_bShowLowToLowIDSources; 
							selectedItemList.RemoveHead(); 
d3235 1
a3235 1
					break; 
d3243 2
a3244 2
							selectedItemList.GetHead()->m_bShowBannedSources = !selectedItemList.GetHead()->m_bShowBannedSources; 
							selectedItemList.RemoveHead(); 
d3248 1
a3248 1
					break; 
d3256 2
a3257 2
							selectedItemList.GetHead()->m_bShowErrorSources = !selectedItemList.GetHead()->m_bShowErrorSources; 
							selectedItemList.RemoveHead(); 
d3261 1
a3261 1
					break; 
d3269 2
a3270 2
							selectedItemList.GetHead()->m_bShowA4AFSources = !selectedItemList.GetHead()->m_bShowA4AFSources; 
							selectedItemList.RemoveHead(); 
d3274 1
a3274 1
					break; 
d3282 2
a3283 2
							selectedItemList.GetHead()->m_bShowUnknownSources = !selectedItemList.GetHead()->m_bShowUnknownSources; 
							selectedItemList.RemoveHead(); 
d3287 1
a3287 1
					break; 
d3295 2
a3296 2
							selectedItemList.GetHead()->FilterAllSources(); 
							selectedItemList.RemoveHead(); 
d3300 1
a3300 1
					break; 
d3308 2
a3309 2
							selectedItemList.GetHead()->FilterNoSources(); 
							selectedItemList.RemoveHead(); 
d3313 1
a3313 1
					break; 
d3349 1
a3349 1
					break; 
d3355 1
a3355 1
		selectedList.RemoveAll(); 
d4340 2
a4341 2
					CCommentDialogLst dlg(pPartFile); 
					dlg.DoModal(); 
d4421 1
a4421 1
	CTypedPtrList<CPtrList, CPartFile*>		selectedList; 
d4423 2
a4424 2
	int			iNumItems = GetItemCount(); 
	POSITION	pos; 
d4439 1
a4439 1
	iNumItems = selectedList.GetCount(); 
d4442 1
a4442 1
		selectedList.GetAt(pos)->GetSourcesAfterServerConnect(); 
d4444 1
a4444 1
	AddLogLine(true,IDS_NEWSERVERCONNECT,g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()); 
d4446 1
a4446 1
	selectedList.RemoveAll(); 
d4606 1
a4606 1
	CPoint		p = point; 
d4608 1
a4608 1
    ScreenToClient(&p); 
d4610 1
a4610 1
    int			it = HitTest(p); 
@


1.322
log
@Fixed a bug with Last Reception column never showing never ;-)
@
text
@d1129 1
d1131 2
d1134 7
a1140 3
					buffer = pPartFile->LocalizeLastSeenComplete();

				dc->DrawText(buffer,(int)_tcslen(buffer),&r, iCalcFlag);
d1148 1
d1150 2
d1153 7
a1159 3
					buffer = pPartFile->LocalizeLastDownTransfer();

				dc->DrawText(buffer,(int)_tcslen(buffer),&r, iCalcFlag);
@


1.321
log
@New sockets
@
text
@d1140 1
a1140 2
				if (pPartFile->GetFileDate() == 0)
				{
a1141 2
					dc->DrawText(buffer,(int)_tcslen(buffer),&r, iCalcFlag);
				}
d1143 1
a1143 3
				{					
					CTime			ctTime(pPartFile->GetFileDate());
					SYSTEMTIME		st;
d1145 1
a1145 6
					ctTime.GetAsSystemTime(st);

					COleDateTime	odtTime(st);

					dc->DrawText(odtTime.Format(), &r, iCalcFlag);
				}
@


1.320
log
@Change to shortcut management code (it's easier to add an action now) / Added a lot of actions to shortcut management / Added some keys to shortcut management
@
text
@d415 1
d521 3
d1317 1
d1848 1
d2354 1
d2642 1
d3298 1
d3330 1
d3624 1
d3630 1
d3635 1
d3641 1
d4361 1
d4374 1
d4558 1
d4563 1
d4617 1
d4621 1
d4785 1
d4800 3
@


1.319
log
@Reverted a change
@
text
@d2405 3
a2407 3
			menuED2K.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
			menuED2K.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
			menuED2K.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK));
d2441 1
a2441 1
			menuAdvanced.AppendMenu(MF_STRING,MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE));
d2458 1
a2458 1
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE));
d2464 1
a2464 1
			menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,strBuffer);
d2513 1
a2513 1
			menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetDownloadClearCompletedFilesShortcutCode()));
d2521 1
a2521 1
			menuFile.AppendMenu(MF_STRING,MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL));
d2524 1
a2524 1
			menuFile.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP));
d2527 1
a2527 1
			menuFile.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE));
d2530 1
a2530 1
			menuFile.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME));
d2538 1
a2538 1
			menuFile.AppendMenu(MF_STRING,MP_OPEN, GetResString(IDS_DL_OPEN));
d2541 1
a2541 1
			menuFile.AppendMenu(MF_STRING,MP_PREVIEW, GetResString(IDS_DL_PREVIEW));
d2544 1
a2544 1
			menuFile.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetDownloadViewFileDetailsShortcutCode()));
d2547 1
a2547 1
			menuFile.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetDownloadViewFileCommentsShortcutCode()));
d2581 1
a2581 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientDetailsShortcutCode()));
d2583 1
a2583 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));
d2585 3
a2587 3
				menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));
			menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadSendMessageClientShortcutCode()));
			menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientFilesShortcutCode()));
d2601 1
a2601 1
		menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
d4902 36
a4937 1
			if (nCode == g_eMuleApp.m_pGlobPrefs->GetDownloadViewFileCommentsShortcutCode())
d4941 1
a4941 1
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetDownloadViewFileDetailsShortcutCode())
d4945 1
a4945 1
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetDownloadClearCompletedFilesShortcutCode())
d4948 27
@


1.318
log
@Fixed selection background color on Uploads, On Queue & Known Clients lists and some other fixes
@
text
@d4816 1
a4816 4
	int		iItem = -1;

	if(&find.psz)
		iItem =	FindItem(&find);
@


1.317
log
@correction in Fake Report URL
@
text
@d1852 1
a1852 2

	if (lpDrawItemStruct->itemData == NULL)
a1874 1
	{
a1875 1
	}
d1989 1
a1989 1
		CBrush* pOldBrush = dc->SelectObject(&brush);	//eklmn: select a new brush
d1991 1
a1991 1
		dc->SelectObject(pOldBrush);	//eklmn: recover an old brush
d2013 1
a2013 1
		if(bCtrlFocused)
d2037 1
a2037 1
		CBrush* pOldnfBrush = dc->SelectObject(&nfBrush);	//eklmn: select a new brush
d2039 1
a2039 1
		dc->SelectObject(pOldnfBrush);	//eklmn: recover an old brush
d2091 1
a2091 1
			CBrush* pOldBrush = dc->SelectObject(&brush);	//eklmn: select a new brush
d2093 1
a2093 1
			dc->SelectObject(pOldBrush);	//eklmn: recover an old brush
d2118 4
a2121 2
	dc->SelectObject(pOldFont);
	dc->SetTextColor(crOldTextColor);
@


1.316
log
@Fix for category drag & drop
@
text
@d2958 1
a2958 1
					ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/report/iIndex.php?link2="+pPartFile->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
@


1.315
log
@Fixed bug with A4AF sources being at the top when files sorted by progress
@
text
@d4848 1
a4848 1
	if (::IsWindow(GetSafeHwnd()))
@


1.314
log
@Modified so that disabling "Smart Filtering" resets the source filtering on all file items.
@
text
@d3611 1
a3611 1
					iCompare = (iFileSortItem == DLCOL_PROGRESS) ? -n : n;
d4817 4
a4820 1
	int		iItem = FindItem(&find);
@


1.313
log
@Applied the "sort arrows stick on source sort after ctrl-R" fix to the corresponding menu option.
@
text
@d3421 12
a3432 1
				UpdateFileItems();
d4960 13
@


1.312
log
@Added "smart" source filtering code. Fixed IsSourceFiltered() so it filters out "connecting via server" sources if the "connecting" filter is on.
@
text
@d464 1
a464 1
	//	If we're filtering out sources that are connecting and this source is connecting...
d466 1
a466 1
		  && ds == DS_CONNECTING )
d2908 1
d4893 1
d4895 1
d4897 1
d4899 1
d4901 1
d4903 1
@


1.311
log
@Formatting, comments, and name changes.
@
text
@d348 5
d412 1
a412 1
//		from the DownloadList window according to the current SmartOpen filter.
d418 1
d427 1
a427 1
		uint8	ds = pSource->GetDownloadState();
d429 1
d431 1
a431 1
			&& ds == DS_DOWNLOADING )
d435 2
d438 10
a447 1
			&& ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() > 0 )
d451 2
d454 1
a454 1
			&& ds == DS_ONQUEUE && pSource->GetRemoteQueueRank() == 0 )
d458 1
d460 1
a460 1
		  && ds == DS_CONNECTED)
d464 1
d466 1
a466 1
		  && ds == DS_CONNECTING)
d470 2
d473 1
a473 1
			&& ds == DS_NONEEDEDPARTS )
d477 2
d484 2
d491 1
d497 2
d504 2
d511 1
d596 1
a596 1
void CDownloadListCtrl::UpdateSourceItems()
d598 23
a620 1
	CDownloadList::SourceItemVector	   *pvecSourceItems = g_eMuleApp.m_pDownloadList->GetSourceItems();
d632 2
d644 4
d3417 6
d4909 6
d4916 28
@


1.310
log
@*** empty log message ***
@
text
@d30 1
a30 1
#include "KeyboardShortcut.h"	// DropF - Keyboard Shortcuts
d2452 1
a2452 1
			menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetDownloadClearCompletedFilesShortcutCode()));	// DropF - Keyboard Shortcuts
d2483 1
a2483 1
			menuFile.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetDownloadViewFileDetailsShortcutCode()));	// DropF - Keyboard Shortcuts
d2486 1
a2486 1
			menuFile.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetDownloadViewFileCommentsShortcutCode()));	// DropF - Keyboard Shortcuts
d2520 1
a2520 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientDetailsShortcutCode()));	// DropF - Keyboard Shortcuts
d2522 1
a2522 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));	// DropF - Keyboard Shortcuts
d2524 3
a2526 3
				menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));	// DropF - Keyboard Shortcuts
			menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadSendMessageClientShortcutCode()));	// DropF - Keyboard Shortcuts
			menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientFilesShortcutCode()));	// DropF - Keyboard Shortcuts
a4811 2

// DropF START - Keyboard Shortcuts
d4840 2
a4841 1
// DropF END - Keyboard Shortcuts@


1.309
log
@Formatting, comments, and name changes.
@
text
@d30 1
d2452 1
a2452 1
			menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
d2483 1
a2483 1
			menuFile.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO));
d2486 1
a2486 1
			menuFile.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL));
d2520 1
a2520 1
			menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
d2522 1
a2522 1
				menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d2524 3
a2526 3
				menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
			menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG));
			menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
d4812 31
@


1.308
log
@Fixed uninitialized source filters.
@
text
@d1501 1
a1501 1
			case DLCOL_TRANSFERRED:		// transferred
d1512 1
a1512 1
			case DLCOL_COMPLETED:		// completed
@


1.307
log
@Formatting, comments, and name changes.
Fixed "sort arrows stick on source sort after ctrl-R".
@
text
@d100 1
a100 10
	m_bShowUploadingSources = true;
	m_bShowOnQueueSources = true;
	m_bShowConnectedSources = true;
	m_bShowConnectingSources = true;
	m_bShowNNPSources = true;
	m_bShowTooManyConnSources = true;
	m_bShowLowToLowIDSources = true;
	m_bShowBannedSources = true;
	m_bShowErrorSources = true;
	m_bShowA4AFSources = true;
@


1.306
log
@Fix for showing of sources for stopped files
@
text
@d3987 2
a3988 2
					uint32 plus1=(pClient1->PlusVersion()<0x2600)?pClient1->PlusVersion():0;
					uint32 plus2=(pClient2->PlusVersion()<0x2600)?pClient2->PlusVersion():0;
d4430 1
@


1.305
log
@Updated to b3 version and removed extra space for sources
@
text
@d645 1
a645 1
					  &&  !(pPartFile->GetStatus() == PS_COMPLETING || pPartFile->GetStatus() == PS_COMPLETE) )
@


1.304
log
@Removed now extraneous Source retrieval to make eklmn happy.
@
text
@d1344 1
a1344 1
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d1359 1
a1359 1
				r.left += OFFSET_PLUSMINUS;
d1443 6
@


1.303
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@a558 2
				CUpDownClient	*pSource = pSourceItem->GetSource();

@


1.302
log
@Fix for CTRL+A, DEL and other shortcuts not working
@
text
@d42 1
d57 1
d69 1
a69 1
	m_bSortSourcesAscending = true;
d853 1
d899 4
a902 3
						// HoaX_69: BEGIN Display percent in progress bar
						COLORREF oldclr = dc->SetTextColor(RGB(255,255,255));
						int iOMode = dc->SetBkMode(TRANSPARENT);
d905 5
a909 3
						int iOLeft = r.left;
						r.left += iBarWidth / 2 - 10; // Close enough
						if(pPartFile->GetStatus()!=PS_COMPLETE && pPartFile->GetStatus()!=PS_COMPLETING)
d911 1
d914 3
a916 4
						r.left = iOLeft;
						dc->SetBkMode(iOMode);
						dc->SetTextColor(oldclr);
						// HoaX_69: END
d924 1
d1006 1
a1006 1
					float	saved = 100.0f - pPartFile->GetPercentCompleted();
d1033 1
a1033 1
					float		fRemainingPercent = 100.0f - pPartFile->GetPercentCompleted();
d1036 1
a1036 1
					buffer.Format( _T("%s [%.1f%%]"), str1, fRemainingPercent);
d1312 1
a1312 1
		float				fRemoteBaseModifier = pSource->GetRemoteBaseModifier();
d1451 1
a1451 1
					else if (fRemoteBaseModifier >= 1.1)
d1720 1
a1720 1
					buffer.Format(_T("%0.1f"), fRemoteBaseModifier);
d3664 1
a3664 1
		case DLCOL_SIZE: //size asc
d3671 1
a3671 1
				iCompare = 1;		//sort for >2gb
d3674 1
a3674 1
		case DLCOL_TRANSFERRED: //transferred asc
d3679 1
a3679 1
	    case DLCOL_COMPLETED: //completed asc
d3684 1
a3684 1
		case DLCOL_SPEED: //speed asc
d3691 1
a3691 1
		case DLCOL_PROGRESS: //progress asc
d3693 1
a3693 1
			float		comp = file1->GetPercentCompleted() - file2->GetPercentCompleted();
d3695 3
a3697 3
			if (comp < .01 && comp > -.01)
				comp = 0;
			iCompare = (comp > 0) ? 1 : ((comp < 0) ? -1 : 0);
@


1.301
log
@Changed source filter menu code to use resource strings.
@
text
@a4404 1
		bHandled = true;
d4407 2
d4413 2
d4422 2
a4425 26
/*		else if (nChar == 'C' && pFileItem != NULL)
		{
			if (pPartFile->GetStatus() == PS_COMPLETE)
				g_eMuleApp.m_pDownloadList->ClearCompleted(pPartFile->GetFileHash());
		}
		else if (nChar == 'E' && pFileItem != NULL)
		{
			g_eMuleApp.CopyTextToClipboard(pPartFile->CreateED2kLink());
		}
		else if (nChar == 'P' && pFileItem != NULL)
		{
			if (pPartFile->GetStatus() == PS_PAUSED)
				pPartFile->ResumeFile();
			else
				pPartFile->PauseFile();
		}
		else if (nChar == 'S' && pFileItem != NULL)
		{
			if (pPartFile->GetStatus() == PS_STOPPED)
				pPartFile->ResumeFile();
			else
				pPartFile->StopFile();
		}
		else
			bHandled = false;
*/
@


1.300
log
@Formatting, comments, and name changes.
@
text
@d2347 13
a2359 13
			menuSourceFilter.AddMenuTitle(_T("Showing"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowUploadingSources?MF_CHECKED:0),MP_SRCFILTER_UPLOADING,_T("Uploading"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowOnQueueSources?MF_CHECKED:0),MP_SRCFILTER_ONQUEUE,_T("On Queue"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowFullQueueSources?MF_CHECKED:0),MP_SRCFILTER_FULLQUEUE,_T("Full Queue"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowConnectedSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTED,_T("Connected"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowConnectingSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTING,_T("Connecting"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowNNPSources?MF_CHECKED:0),MP_SRCFILTER_NNP,_T("No Needed Parts"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowTooManyConnSources?MF_CHECKED:0),MP_SRCFILTER_TOOMANYCONN,_T("Too Many Connections"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowLowToLowIDSources?MF_CHECKED:0),MP_SRCFILTER_LOWTOLOWID,_T("Low ID to Low ID"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowBannedSources?MF_CHECKED:0),MP_SRCFILTER_BANNED,_T("Banned"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowErrorSources?MF_CHECKED:0),MP_SRCFILTER_ERROR,_T("Error"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowA4AFSources?MF_CHECKED:0),MP_SRCFILTER_A4AF,_T("A4AF"));
			menuSourceFilter.AppendMenu(MF_STRING|(pFileItem->m_bShowUnknownSources?MF_CHECKED:0),MP_SRCFILTER_UNKNOWN,_T("Unknown"));
d2363 2
a2364 6
			menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_SHOWALL,_T("Show All"));
			menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_HIDEALL,_T("Hide All"));

			menuSourceFilter.AppendMenu(MF_SEPARATOR);

			menuSourceFilter.AppendMenu(MF_STRING|(m_bSmartFilter?MF_CHECKED:0),MP_SMARTFILTER,_T("Smart Filter"));
d2488 1
a2488 1
			menuFile.AppendMenu(MF_STRING|MF_POPUP,reinterpret_cast<UINT_PTR>(menuSourceFilter.m_hMenu), _T("Source filtering"));
d2543 13
a2555 13
		menuSourceFilter.AddMenuTitle(_T("Showing"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUploadingSources?MF_CHECKED:0),MP_SRCFILTER_UPLOADING,_T("Uploading"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowOnQueueSources?MF_CHECKED:0),MP_SRCFILTER_ONQUEUE,_T("On Queue"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowFullQueueSources?MF_CHECKED:0),MP_SRCFILTER_FULLQUEUE,_T("Full Queue"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectedSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTED,_T("Connected"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectingSources?MF_CHECKED:0),MP_SRCFILTER_CONNECTING,_T("Connecting"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowNNPSources?MF_CHECKED:0),MP_SRCFILTER_NNP,_T("No Needed Parts"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowTooManyConnSources?MF_CHECKED:0),MP_SRCFILTER_TOOMANYCONN,_T("Too Many Connections"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowLowToLowIDSources?MF_CHECKED:0),MP_SRCFILTER_LOWTOLOWID,_T("Low ID to Low ID"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowBannedSources?MF_CHECKED:0),MP_SRCFILTER_BANNED,_T("Banned"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowErrorSources?MF_CHECKED:0),MP_SRCFILTER_ERROR,_T("Error"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowA4AFSources?MF_CHECKED:0),MP_SRCFILTER_A4AF,_T("A4AF"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUnknownSources?MF_CHECKED:0),MP_SRCFILTER_UNKNOWN,_T("Unknown"));
d2559 2
a2560 2
		menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_SHOWALL,_T("Show All"));
		menuSourceFilter.AppendMenu(MF_STRING,MP_SRCFILTER_HIDEALL,_T("Hide All"));
d2564 1
a2564 1
		menuSourceFilter.AppendMenu(MF_STRING|(m_bSmartFilter?MF_CHECKED:0),MP_SMARTFILTER,_T("Smart Filter"));
d2566 1
a2566 1
		menuFile.AppendMenu(MF_STRING|MF_POPUP,reinterpret_cast<UINT_PTR>(menuSourceFilter.m_hMenu), _T("Source filtering"));
d2964 1
a2964 1
						// v6:- eklmn: A4AF mangement
d2966 1
a2966 1
							//curent pPartFile is A4AF auto => User want to switch it off
d2973 1
a2973 1
				// DonGato - Moview Preview Mode
d3002 1
a3002 1
				// DonGato - Moview Preview Mode end
@


1.299
log
@Fixed CTRL+A for download list
@
text
@d2810 1
a2810 1
						g_eMuleApp.m_pSharedFilesList->SafeAddKFile(pPartFile);
d4203 1
a4203 1
							g_eMuleApp.m_pSharedFilesList->SafeAddKFile(pPartFile);
d4379 2
d4409 1
d4448 3
a4450 2
*/		else
			CMuleListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
d4452 2
@


1.298
log
@Aligned column
@
text
@d4404 1
d4422 1
a4422 5
/*		else if (nChar == 'A' && pFileItem != NULL)
		{
			pPartFile->DownloadAllA4AF();
		}
		else if (nChar == 'C' && pFileItem != NULL)
d4445 3
a4447 3
*/	}
	else
		CMuleListCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
@


1.297
log
@Changed position of +/- icon as Psy suggestion
@
text
@d129 1
a129 1
	InsertColumn(DLCOL_REMAININGTIME,GetResString(IDS_DLCOL_REMAININGTIME),LVCFMT_RIGHT, 110); // should be est. time or ETA
@


1.296
log
@Removed NNS feature and changed SLS
@
text
@d607 1
a608 1
#define OFFSET_PLUSMINUS	18
d643 12
a676 1
					ipoint.x += OFFSET_STATUSICON;
a678 11
			//	Draw the old-style +/- box
				iIcon = ( pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0
					  &&  !(pPartFile->GetStatus() == PS_COMPLETING || pPartFile->GetStatus() == PS_COMPLETE) )
					  ? (pFileItem->m_bSrcsAreVisible ? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS)
					  : DL_ICON_LISTNONE;
				if (!bMeasuring)
					m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
				else
					iWidth += OFFSET_PLUSMINUS;
				r.left += OFFSET_PLUSMINUS;

d4166 9
d4180 1
d4182 1
a4182 1
				rFileStatus.right = rFileStatus.left + 16;
a4206 11

		// [+]/[-]
			CRect rPlusMinus(r);
			rPlusMinus.left += 2;
			if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
				rPlusMinus.left += OFFSET_STATUSICON;
			rPlusMinus.top += 2;
			rPlusMinus.right = rPlusMinus.left + OFFSET_PLUSMINUS;
			rPlusMinus.bottom = rPlusMinus.top + 16;
			if(rPlusMinus.PtInRect(pt))
				OnItemActivate(pNMHDR, pResult);
@


1.295
log
@Fixed "Sort order reverts to prefs after expanding a file". Fixed "Incorrect sort arrows shown for source sorting when prefs have a multicolumn source sort and a column has been clicked to resort".
@
text
@a2394 2
			menuAdvanced.AppendMenu(MF_STRING,MP_DROPNONEEDEDSRCS, GetResString(IDS_DROPNONEEDEDSRCS));
			menuAdvanced.EnableMenuItem(MP_DROPNONEEDEDSRCS,((eFileStatus != PS_COMPLETE && eFileStatus != PS_COMPLETING) ? MF_ENABLED:MF_GRAYED));
a2975 7
					break;
				case MP_DROPNONEEDEDSRCS:
					while(!selectedList.IsEmpty()) // Tarod
					{
						selectedList.GetHead()->RemoveNoNeededSources();
						selectedList.RemoveHead();
					} 
@


1.294
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d2215 1
a2215 1
		SortInit(pFileItem->m_bSrcsAreVisible && g_eMuleApp.m_pGlobPrefs->DoUseSort()); //override if useSort & showing sources...
d3422 1
@


1.293
log
@Added new File Status icons and some compilation fixes.
@
text
@d66 2
d204 2
a205 2
		m_dwLastSortCode = m_iCurrentSortItem + (m_bSortAscending ? DL_SORTASC : DL_SORTDESC)
						+ (m_iSourceSortItem + (m_bSortSourcesAscending ? DL_SORTASC : DL_SORTDESC)) * 0x10000;
d600 4
d1246 4
d1309 1
d1317 1
d1337 1
a1337 2
		    case DLCOL_FILENAME:  	// icon, name
			// Lord Kiron
d1472 1
d1474 1
a1474 4
			break;
			// Lord KiRon - end

			case DLCOL_SIZE:		// size
d1479 1
a1479 1
					uint16		iLastPart = pSource->GetLastDownPart();
d1599 1
a1599 1
					if(bRemoteQueueFull)
d1601 1
a1601 1
						buffer=GetResString(IDS_QUEUEFULL);
d1608 3
a1610 3
							//cendre-eau
							COLORREF crOldTxtColor;
							if (nDifference==nRemoteQueueRank)
d1615 1
a1615 1
							else if (nDifference<nRemoteQueueRank)
d1619 1
a1619 1
								if (nDifference==0)
a1631 1
							//cendre-eau
d1638 4
a1646 4
				if (bMeasuring)
				{
					iWidth += r.right-r.left+1;
				}
d1668 1
a1668 1
					uint16		iLastPart = pSource->GetLastDownPart();
d1677 1
a1677 1
									pSource->GetLastDownPart() );
d1691 1
a1691 1
					uint16		iLastPart = pSource->GetLastDownPart();
d1724 2
a1725 1
				else buffer="";
d1727 1
a1727 1
				if (bMeasuring)
d1754 1
a1754 1
					if (bMeasuring)
d1791 1
a1791 1
	if (g_eMuleApp.m_pGlobPrefs->DoUseSrcSortCol2() && g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_bShowSrc && m_dwSortTime+1000<::GetTickCount())
d2103 1
d2107 2
a2108 2
			m_iCurrentSortItem = m_dwLastSortCode < DL_SORTDESC ? m_dwLastSortCode : m_dwLastSortCode - DL_SORTDESC;
			SetSortArrow(m_iCurrentSortItem, (m_dwLastSortCode < DL_SORTDESC));
d2110 1
d3408 1
a3408 1
	bool	bIsShift = GetAsyncKeyState(VK_SHIFT) < 0;
d3410 1
a3410 1
	if (!bIsShift)
d3422 3
a3424 2
	m_dwLastSortCode = m_iCurrentSortItem + (m_bSortAscending ? DL_SORTASC : DL_SORTDESC)
					+ ((m_iSourceSortItem + (m_bSortSourcesAscending ? DL_SORTASC : DL_SORTDESC)) << 16);
d3446 3
a3448 1
	int					iFileSortItem, iSourceSortItem;
d3451 5
d3459 1
a3459 1
    if ((lParamSortCode & 0xFFFF) >= DL_SORTDESC)
a3461 1
		iFileSortItem = (lParamSortCode & 0xFFFF) - DL_SORTDESC;
d3463 3
a3465 5
	else
	{
		iFileSortItem = lParamSortCode & 0xFFFF;
	}
	if (((lParamSortCode & 0xFFFF0000) >> 16) >= DL_SORTDESC)
a3467 1
		iSourceSortItem = ((lParamSortCode & 0xFFFF0000) >> 16) - DL_SORTDESC;
d3469 3
a3471 1
	else
d3473 6
a3478 1
		iSourceSortItem = (lParamSortCode & 0xFFFF0000) >> 16;
d3544 5
a3548 1
					iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem) * iSourceSortMod;
d3553 5
a3557 1
				iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem) * iSourceSortMod;
d3584 1
a3584 1
		m_dwLastSortCode -= (m_dwLastSortCode >= 0) ? 10000 : 0;
d3587 13
a3599 33
		m_dwLastSortCode = g_eMuleApp.m_pGlobPrefs->GetDownloadSortCol();
		m_iCurrentSortItem = (m_dwLastSortCode < DL_SORTDESC) ? m_dwLastSortCode : m_dwLastSortCode - DL_SORTDESC;
		SetSortArrow(m_iCurrentSortItem,(m_dwLastSortCode < DL_SORTDESC));
	}
	if (m_bShowSrc)
	{
		if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_dwLastSortCode < 0)
		{
			SortItems(&SortProc,DL_SORTSOURCES + g_eMuleApp.m_pGlobPrefs->GetSrcSortCol1()); //+ show sources(clients)
			if (g_eMuleApp.m_pGlobPrefs->DoUseSrcSortCol2())
			{
				if (g_eMuleApp.m_pGlobPrefs->GetSrcSortCol2() == 255)
				{
					SortItems(&SortProc,DL_SORTSOURCES + DL_SORTDESC + DLCOL_STATUS); // kiron's status desc, show sources(clients) 05/01/03
					SortItems(&SortProc,DL_SORTSOURCES + DL_SORTDESC + DLCOL_SPEED); // speed desc, show sources(clients)
				}
				else
				{
					SortItems(&SortProc,DL_SORTSOURCES + g_eMuleApp.m_pGlobPrefs->GetSrcSortCol2());
				}
			}
		}
	}
	else
	{
		if (m_dwLastSortCode < 0)
		{
			SortItems(&SortProc,g_eMuleApp.m_pGlobPrefs->GetDownloadSortCol());
		}
		else
		{
			SortItems(&SortProc, m_dwLastSortCode);
		}
d3601 2
d3649 3
a3651 1
/*static*/ int CDownloadListCtrl::Compare(CPartFile* file1, CPartFile* file2, LPARAM lParamSort) 
d3937 4
a3940 1
/*static*/ int CDownloadListCtrl::Compare(CUpDownClient* pClient1,CUpDownClient* pClient2, LPARAM lParamSort) 
d4120 1
a4120 1
	if (iCompare == 0)
d4350 1
a4350 1
	if (nChar == VK_SHIFT)
d4401 1
a4401 1
	if (nChar == VK_SHIFT)
d4403 9
a4411 1
		SetSortArrow(m_iSourceSortItem, m_bSortSourcesAscending);
d4426 4
d4592 1
@


1.292
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d183 1
d646 1
@


1.291
log
@Added a throttle to the refresh message handler to reduce CPU load.
@
text
@d1242 17
d1264 16
a1279 8
		CString buffer;
		CUpDownClient *pSource = pSourceItem->GetSource();
		CString sDownloadState = _T("");
		try{ sDownloadState = pSource->GetDownloadStateAsString(); }catch(...){}
		uint8 nDownloadState = pSource->GetDownloadState();
		EnumClientTypes nClientSoft = pSource->GetClientSoft();
		uint32 nVersion;	//Cax2 - version nr bugfix
		switch(nClientSoft){
d1290 30
a1319 21
		bool bIsBanned = pSource->IsBanned(); //katsyonak 07/07/03
		bool bIsFriend = pSource->IsFriend();
		float fRemoteBaseModifier = pSource->GetRemoteBaseModifier();
		CString sClientName = _T("");
		if(pSource->GetUserName())
			try{ sClientName = CString(pSource->GetUserName()); }catch(...){}
		uint32 nTransferredDown = pSource->GetTransferredDown();
		uint32 nDownloadDataRate = pSource->GetDownloadDataRate();
		bool bIsEmuleClient = pSource->IsEmuleClient();
		uint16 nRemoteQueueRank = pSource->GetRemoteQueueRank();
		uint16 nDifference = pSource->GetDifference(); //cendre-eau
		bool bNeverAskedBefore = pSource->GetLastSrcReqTime() == 0;
		bool bRemoteQueueFull = pSource->IsRemoteQueueFull();
		bool bIsRemoteInfoAvail = pSource->IsRemoteInfoAvaiable();
		bool bCredits = pSource->credits != (CClientCredits*)NULL && pSource->credits != (CClientCredits*)-1;
		uint16 nRemoteRatio = pSource->GetRemoteRatio();
		bool a4af=pSourceItem->IsAskedForAnotherFile();

		// Lord KiRon - just make compiler happy :)
 		POINT point;
 		CString status;
d1321 1
a1321 1
		switch(nColumn) 
a1325 4
				RECT cur_rec;

				cur_rec = *lpRect;
			
d1327 4
a1330 1
					cur_rec.left += OFFSET_STATUSICON;
d1332 4
a1335 1
					cur_rec.left += OFFSET_FILETYPEICON;
d1337 64
a1400 14
					cur_rec.left += OFFSET_RATINGICON;
				cur_rec.left += OFFSET_PLUSMINUS;
				point.x = cur_rec.left;
				point.y = cur_rec.top+1;
   				status = _T(""); 
				if (!a4af)
				{
					switch (nDownloadState)
					{
						case DS_CONNECTING:
						case DS_CONNECTED:
						case DS_WAITCALLBACK:
						case DS_TOOMANYCONNS:
							    m_imageList.Draw(dc, DL_ICON_DCS3, point, ILD_NORMAL);
d1402 2
a1403 2
						case DS_ONQUEUE:
							    m_imageList.Draw(dc, DL_ICON_DCS2, point, ILD_NORMAL);
d1405 2
a1406 3
						case DS_DOWNLOADING:
						case DS_REQHASHSET:
							    m_imageList.Draw(dc, DL_ICON_DCS1, point, ILD_NORMAL);
d1408 12
a1419 3
						case DS_NONEEDEDPARTS:
						case DS_LOWTOLOWIP:
							    m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL);
d1422 2
a1423 1
							    m_imageList.Draw(dc, DL_ICON_DCS5, point, ILD_NORMAL);
a1424 10
				} else {
               		    m_imageList.Draw(dc, DL_ICON_DCS4, point, ILD_NORMAL); 
					if(g_eMuleApp.m_pGlobPrefs->IsA4AFStringEnabled()) {
						//Cax2 - get local file name
						try{ status.Format(_T("(%s)"),pSource->reqfile->GetFileName()); }catch(...){}
					} else
						status = _T("(") + GetResString(IDS_ASKED4ANOTHERFILE) + _T(")");
  				}
	
				cur_rec.left += 20;
d1426 7
a1432 32
                POINT point2= {cur_rec.left,cur_rec.top+1};

				// Display client icon
				switch(nClientSoft) {
					case SO_CDONKEY:
						    m_imageList.Draw(dc, DL_ICON_CDONKEY, point2, ILD_NORMAL);
						break;
					case SO_LMULE:
						    m_imageList.Draw(dc, DL_ICON_LMULE, point2, ILD_NORMAL);
						break;
					case SO_SHAREAZA:
						    m_imageList.Draw(dc, DL_ICON_SHAREAZA, point2, ILD_NORMAL);
						break;
					case SO_EDONKEYHYBRID:
						    m_imageList.Draw(dc, DL_ICON_EDONKEYHYBRID, point2, ILD_NORMAL);
						break;
					case SO_MLDONKEY:
						    m_imageList.Draw(dc, DL_ICON_MLDONKEY, point2, ILD_NORMAL);
						break;
					case SO_EMULE:
					case SO_OLDEMULE:
						if (pSource->credits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
							    m_imageList.Draw(dc, DL_ICON_SECUREHASH, point2, ILD_NORMAL);
						else
							    m_imageList.Draw(dc, DL_ICON_COMPROT, point2, ILD_NORMAL);
						break;
					case SO_EDONKEY:
						    m_imageList.Draw(dc, DL_ICON_NORMAL, point2, ILD_NORMAL);
						break;
					default:
						    m_imageList.Draw(dc, DL_ICON_UNKNOWN, point2, ILD_NORMAL);
						break;
d1435 2
a1436 9
				// Display any Extra Overlay icons
				if (bIsBanned) //katsyonak 07/07/03
					    m_imageList.Draw(dc, DL_ICON_BANNED_ONLY, point2, ILD_TRANSPARENT);
				else if (bIsFriend)
					    m_imageList.Draw(dc, DL_ICON_FRIEND_ONLY, point2, ILD_TRANSPARENT);
				else if (fRemoteBaseModifier >= 1.1)
					    m_imageList.Draw(dc, DL_ICON_CREDIT_DOWNESTIMATED, point2, ILD_TRANSPARENT);

				cur_rec.left += 20;
d1450 1
a1450 1
				if(a4af)
d1452 6
a1457 2
				dc->DrawText(buffer1,buffer1.GetLength(),&cur_rec, DLC_DT_TEXT);
                if(a4af)
d1481 1
a1481 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1491 5
a1495 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1500 1
a1500 1
				if (!a4af && nTransferredDown && g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted()) {
d1502 5
a1506 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1517 5
a1521 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1527 4
a1530 2
				lpRect->bottom--; 
				lpRect->top++; 
d1532 27
a1558 14
				int iWidth = lpRect->right - lpRect->left; 
				int iHeight = lpRect->bottom - lpRect->top; 
					if (pSourceItem->GetBitmap() == (HBITMAP)NULL)
						VERIFY(pSourceItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL)); 
				CDC cdcStatus; 
				HGDIOBJ hOldBitmap;
				cdcStatus.CreateCompatibleDC(dc); 
					int cx = pSourceItem->GetBitmap().GetBitmapDimension().cx; 
				DWORD dwTicks = GetTickCount(); 
					if(pSourceItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !pSourceItem->GetUpdateTimer())
				{ 
						pSourceItem->GetBitmap().DeleteObject(); 
						pSourceItem->GetBitmap().CreateCompatibleBitmap(dc,  iWidth, iHeight); 
						pSourceItem->GetBitmap().SetBitmapDimension(iWidth,  iHeight); 
d1561 2
a1562 12
					RECT rec_status; 
					rec_status.left = 0; 
					rec_status.top = 0; 
					rec_status.bottom = iHeight; 
					rec_status.right = iWidth; 
					try{
						pSource->DrawStatusBar(&cdcStatus,  &rec_status,(pSourceItem->IsAskedForAnotherFile()), g_eMuleApp.m_pGlobPrefs->UseFlatBar()); 
					}catch(...){} // in case client has been deleted meanwhile

					pSourceItem->SetUpdateTimer(dwTicks + (rand() % 128)); 
				} else 
					hOldBitmap = cdcStatus.SelectObject(pSourceItem->GetBitmap()); 
d1564 5
a1568 5
				dc->BitBlt(lpRect->left, lpRect->top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
				cdcStatus.SelectObject(hOldBitmap);

				lpRect->bottom++; 
				lpRect->top--; 
d1576 5
a1580 1
				dc->DrawText(clientVerString,clientVerString.GetLength(),lpRect, DLC_DT_TEXT);
d1591 1
a1591 1
						dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1619 1
a1619 1
							dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1625 1
a1625 1
							dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1631 5
a1635 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1641 3
a1643 5
				RECT cur_rec;
				memcpy2(&cur_rec, lpRect, sizeof(RECT));
				cur_rec.left += 6;
				point.x = cur_rec.left;
				point.y = cur_rec.top+1;
d1645 5
a1649 1
				dc->DrawText(sDownloadState,sDownloadState.GetLength(),&cur_rec, DLC_DT_TEXT);
d1673 1
a1673 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_LEFT);
d1705 5
a1709 1
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1715 5
a1719 1
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1742 5
a1746 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1758 8
d1782 1
a1782 1
		SortInit(false); // Cax2 sortdlg
d1822 4
d2916 1
a2916 1
					if(dir.GetLength() == 2) // DonGato: fix for root directories
d2918 2
a2919 2
					CString newpath = BrowseFolder(g_eMuleApp.m_pdlgEmule->m_hWnd,GetResString(IDS_SELECTOUTPUTDIR),dir);
					if(newpath.GetLength() == 3) // DonGato: fix for root directories
d3410 1
a3410 1
					+ (m_iSourceSortItem + (m_bSortSourcesAscending ? DL_SORTASC : DL_SORTDESC)) * 0x10000;
d3500 1
a3500 1
		//Cax2:a4af clients kept separate, unless sorting for name
d3502 1
a3502 1
			  && iFileSortItem != DLCOL_FILENAME )
d3514 1
a3514 1
				if (n != 0)			//always at the end, unless sort by source - then a4af always at the top
d3552 2
a3553 2
		m_dwLastSortCode -= (m_dwLastSortCode >= 0) ? 10000 : 0;	//simple override, keep the old sorting column, restore it later...
	if (override == 99) //major override, wipe old sorting order...
d3556 2
a3557 2
		m_iCurrentSortItem = (m_dwLastSortCode<DL_SORTDESC) ? m_dwLastSortCode : m_dwLastSortCode - DL_SORTDESC;
		SetSortArrow(m_iCurrentSortItem,(m_dwLastSortCode<DL_SORTDESC));
d4041 2
a4042 2
				bool	isValid1 = (pClient1->IsRemoteInfoAvaiable()|| pClient1->credits);
				bool	isValid2 = (pClient2->IsRemoteInfoAvaiable()|| pClient2->credits);
@


1.290
log
@Added "Queue Full" and "Unknown" to source filtering.
@
text
@a2107 18
#ifdef OLD
		case WM_DL_UPDATEFILEITEM:
		{
			CPartFile		*pPartFile = reinterpret_cast<CPartFile*>(lParam);

			UpdateFileItem(pPartFile);
			bHandled = true;
			break;
		}
		case WM_DL_UPDATESOURCEITEM:
		{
			CUpDownClient	*pSource = reinterpret_cast<CUpDownClient*>(lParam);

			UpdateSourceItem(pSource);
			bHandled = true;
			break;
		}
#endif OLD
d2110 1
a2110 1
			CDownloadList::PartFileItemVector	   *pvecDirtyFileItems = g_eMuleApp.m_pDownloadList->GetDirtyFiles();
d2112 1
a2112 1
			if (pvecDirtyFileItems != NULL)
d2114 1
a2114 1
				int		iNumDirtyFileItems = pvecDirtyFileItems->size();
d2116 1
a2116 1
				for (int i = 0; i < iNumDirtyFileItems; i++)
d2118 8
a2125 1
					UpdateFileItem((*pvecDirtyFileItems)[i]);
d2128 1
a2128 2
				delete pvecDirtyFileItems;
			}
d2130 3
a2132 1
			CDownloadList::SourceItemVector	   *pvecDirtySources = g_eMuleApp.m_pDownloadList->GetDirtySources();
d2134 4
a2137 3
			if (pvecDirtySources != NULL)
			{
				int		iNumDirtySources = pvecDirtySources->size();
d2139 1
a2139 3
				for (int i = 0; i < iNumDirtySources; i++)
				{
					UpdateSourceItem((*pvecDirtySources)[i]);
d2142 1
a2142 1
				delete pvecDirtySources;
@


1.289
log
@First working version of the new source filtering code and some bugfixes for the new sorting code.
@
text
@d432 6
a437 1
			&& pSource->GetRemoteQueueRank() > 0 )
d481 5
d2240 1
d2249 1
d2442 1
d2451 1
d2967 13
d3084 13
d3183 6
d3237 6
d4247 3
a4249 2
#ifdef LATER
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
d4251 1
a4251 1
		CPartFileDLItem		*pFileItem = MapGetFileItem(itFile);
d4259 1
d4262 2
a4263 1
#endif LATER
d4681 1
d4690 1
d4698 1
d4707 1
@


1.288
log
@no message
@
text
@d424 51
a474 14
#ifdef OLD
	//	If the file item has source filtering on...
		if ( pFileItem->m_bShowOnlySrcsUploading
		  || pFileItem->m_bShowOnlySrcsAllowingUsInUploadQueue
		  || pFileItem->m_bShowOnlySrcsWithNeededParts )
		{
			uint8	ds = pSource->GetDownloadState();

			if (!( pFileItem->m_bShowOnlySrcsUploading && ds==DS_DOWNLOADING && !pSourceItem->IsAskedForAnotherFile()		//Cax2 - don't show clients transferring to another file...
				|| pFileItem->m_bShowOnlySrcsAllowingUsInUploadQueue && pSource->GetRemoteQueueRank() > 0
				|| pFileItem->m_bShowOnlySrcsWithNeededParts && ds != DS_NONEEDEDPARTS ) )
			{
				bShowNewSource = false;
			}
a475 1
#endif OLD
d557 10
d1810 1
a1810 1
			if (typeid(pPrevItem) == typeid(CPartFileDLItem))
d1818 1
a1818 1
			if (typeid(pNextItem) == typeid(CPartFileDLItem))
d1967 1
a1967 1
			if (typeid(pItem) == typeid(CSourceDLItem))
d1998 1
a1998 1
void CDownloadListCtrl::ExpandCollapseItem(int iItem,EnumExpandType expand,bool bCollapseSource)
d2052 2
d2061 5
a2065 2
					iNumAdded++;
					ListInsertSourceItem((*pvecSourceItems)[i],iItem+1);
d2228 10
a2237 9
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUploadingSources?MF_CHECKED:0),0,_T("Uploading"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowOnQueueSources?MF_CHECKED:0),0,_T("On Queue"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectedSources?MF_CHECKED:0),0,_T("Connected"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectingSources?MF_CHECKED:0),0,_T("Connecting"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowNNPSources?MF_CHECKED:0),0,_T("No Needed Parts"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowTooManyConnSources?MF_CHECKED:0),0,_T("Too Many Connections"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowLowToLowIDSources?MF_CHECKED:0),0,_T("Low ID to Low ID"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowBannedSources?MF_CHECKED:0),0,_T("Banned"));
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowErrorSources?MF_CHECKED:0),0,_T("Error"));
d2241 6
a2246 1
			menuSourceFilter.AppendMenu(MF_STRING|(m_bSmartFilter?MF_CHECKED:0),0,_T("Smart Filter"));
d2428 15
a2442 9
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowUploadingSources?MF_CHECKED:0),0,_T("Uploading"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowOnQueueSources?MF_CHECKED:0),0,_T("On Queue"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectedSources?MF_CHECKED:0),0,_T("Connected"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowConnectingSources?MF_CHECKED:0),0,_T("Connecting"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowNNPSources?MF_CHECKED:0),0,_T("No Needed Parts"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowTooManyConnSources?MF_CHECKED:0),0,_T("Too Many Connections"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowLowToLowIDSources?MF_CHECKED:0),0,_T("Low ID to Low ID"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowBannedSources?MF_CHECKED:0),0,_T("Banned"));
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowErrorSources?MF_CHECKED:0),0,_T("Error"));
d2446 1
a2446 1
		menuSourceFilter.AppendMenu(MF_STRING|(m_bSmartFilter?MF_CHECKED:0),0,_T("Smart Filter"));
d2472 2
a2473 1
		CTypedPtrList<CPtrList, CPartFile*>		selectedList;
d2480 1
a2480 1
				if (typeid(ListGetItemAt(iIndex)) == typeid(CPartFileDLItem))
d2482 1
d2928 12
d2941 12
d2954 12
d2967 12
d2980 12
d2993 12
d3006 12
d3019 12
d3033 23
a3055 1
					break;
d3059 10
a3068 1
					break;
d3072 10
a3081 1
					break;
d3131 72
d3371 1
a3371 1
					iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem, iSourceSortMod);
d3376 1
a3376 1
				iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem, iSourceSortMod);
d3772 1
a3772 1
/*static*/ int CDownloadListCtrl::Compare(CUpDownClient* pClient1,CUpDownClient* pClient2, LPARAM lParamSort, int sortMod) 
d3807 1
a3807 1
			iCompare = pClient1->GetAvailablePartCount() - pClient2->GetAvailablePartCount();
d3814 1
a3814 1
				iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft())*sortMod;		//Cax2 append all unknown ones at the end
d3853 1
a3853 1
					iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
d3861 1
a3861 1
					iCompare = (pClient1->GetDownloadState()!=DS_ONQUEUE)?((pClient2->GetDownloadState()!=DS_ONQUEUE)?0:sortMod):-1*sortMod;		//Cax2 now should show properly...
d3864 1
a3864 1
			else if (sortMod<0 || (pClient1->GetRemoteQueueRank()>0 && pClient2->GetRemoteQueueRank()>0))
d3888 1
a3888 1
				iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft())*sortMod;					//Cax2 append all unknown ones at the end
d3939 1
a3939 1
			iCompare = (iWaitSeconds1 < iWaitSeconds2) ? -1 : ((iWaitSeconds1 > iWaitSeconds2) ? 1 : 0);
d3965 1
a3965 1
			iCompare = (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0 : sortMod) : -1 * sortMod;	//Cax2 append all unknown ones at the end
d4473 1
a4473 1
				&& typeid(ListGetItemAt(iInsertionIndex+1)) != typeid(CPartFileDLItem))
d4619 30
@


1.287
log
@no message
@
text
@d3046 1
a3046 1
			iCompare = 1;
d3056 1
a3056 1
			iCompare = -1;
d3088 1
a3088 1
				if (pSourceItem2->IsAskedForAnotherFile() && !pSourceItem1->IsAskedForAnotherFile())
d3094 1
a3094 1
					return (iFileSortItem == DLCOL_PROGRESS) ? -n : n;
d3096 8
a3104 2

			iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), iSourceSortItem, iSourceSortMod);
@


1.286
log
@More fixes for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@d64 2
d67 1
a67 1
	m_iLastSortCode = DLCOL_FILENAME;
d195 9
a203 5
		int		iSortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD);
		bool	bSortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD);

		SetSortArrow(iSortItem, bSortAscending);
		SortItems(SortProc, iSortItem + (bSortAscending ? DL_SORTASC : DL_SORTDESC));
d1930 3
a1932 3
			m_iLastSortCode = m_iFilesSortIndex;
			m_iCurrentSortItem = m_iLastSortCode < DL_SORTDESC ? m_iLastSortCode : m_iLastSortCode - DL_SORTDESC;
			SetSortArrow(m_iCurrentSortItem, (m_iLastSortCode < DL_SORTDESC));
d1987 1
a1987 1
			m_iFilesSortIndex = m_iLastSortCode; 
d2973 17
a2989 5
	m_bSortAscending = (m_iCurrentSortItem != pNMListView->iSubItem) ? true : !m_bSortAscending;
	m_iCurrentSortItem = pNMListView->iSubItem;
	SetSortArrow(m_iCurrentSortItem, m_bSortAscending);
	m_iLastSortCode = m_iCurrentSortItem + (m_bSortAscending ? DL_SORTASC : DL_SORTDESC);
	SortItems(SortProc, m_iCurrentSortItem + (m_bSortAscending ? DL_SORTASC : DL_SORTDESC) + (m_bShowSrc ? DL_SORTSOURCES : DL_SORTFILES));
d2992 2
d3000 1
a3000 1
int CDownloadListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
d3010 7
a3016 12

	bool		bSortSources = false;

	if (lParamSort >= DL_SORTSOURCES)
	{ 
		bSortSources = true; 
		lParamSort -= DL_SORTSOURCES; 
	} 

    int		iSortMod = 1;

    if (lParamSort >= DL_SORTDESC)
d3018 15
a3032 2
		iSortMod = -1;
		lParamSort -= DL_SORTDESC;
d3038 11
a3048 2
	if ( (pFileItem1 != NULL && pSourceItem2 != NULL)
	  || (pSourceItem1 != NULL && pFileItem2 != NULL) )
d3050 8
a3057 3
	//	Leave it as it is...
		iCompare = 0;
	} 
d3063 2
a3064 8
			if (bSortSources)
			{	
				iCompare = 0;
			}
			else
			{ 
				CPartFile	*pPartFile1 = pFileItem1->GetFile();
				CPartFile	*pPartFile2 = pFileItem2->GetFile();
d3066 1
a3066 2
				iCompare = Compare(pPartFile1, pPartFile2, lParamSort);
			}
d3071 1
a3071 1
			iCompare = Compare(pSourceItem1->GetParentFile(), pSourceItem2->GetParentFile(),0);
d3076 1
a3076 1
				return 0;
d3080 1
a3080 1
			  && lParamSort != DLCOL_FILENAME )
d3086 1
a3086 1
					n = -1;
d3090 1
a3090 1
					n = 1;
d3094 1
a3094 1
					return (lParamSort == DLCOL_PROGRESS)? n : -n;
d3098 1
a3098 1
			iCompare = Compare(pSourceItem1->GetSource(), pSourceItem2->GetSource(), lParamSort, iSortMod);
d3102 1
a3102 1
   	return iSortMod * iCompare;
d3122 1
a3122 1
	m_dwSortTime=::GetTickCount();
d3124 1
a3124 1
		m_iLastSortCode -= (m_iLastSortCode >= 0) ? 10000 : 0;	//simple override, keep the old sorting column, restore it later...
d3127 3
a3129 3
		m_iLastSortCode=g_eMuleApp.m_pGlobPrefs->GetDownloadSortCol();
		m_iCurrentSortItem=(m_iLastSortCode<100)?m_iLastSortCode:m_iLastSortCode-100;
		SetSortArrow(m_iCurrentSortItem,(m_iLastSortCode<100));
d3131 1
a3131 1
	if(m_bShowSrc)
d3133 1
a3133 1
		if(g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_iLastSortCode<0)
d3135 1
a3135 1
			SortItems(&SortProc,1000 + g_eMuleApp.m_pGlobPrefs->GetSrcSortCol1()); //+ show sources(clients)
d3138 6
a3143 1
				if (g_eMuleApp.m_pGlobPrefs->GetSrcSortCol2()==255)
d3145 2
a3146 4
					SortItems(&SortProc,1107); // kiron's status desc, show sources(clients) 05/01/03
					SortItems(&SortProc,1103); // speed desc, show sources(clients)
				} else 
					SortItems(&SortProc,1000 + g_eMuleApp.m_pGlobPrefs->GetSrcSortCol2());
d3149 4
a3152 2
	} else {
		if (m_iLastSortCode<0)
d3155 5
a3159 2
		} else 
			SortItems(&SortProc, m_iLastSortCode);
d3902 5
d3951 4
@


1.285
log
@Minor changes
@
text
@d472 1
a472 1
void CDownloadListCtrl::UpdateItem(CSourceDLItem *pSourceItem)
d515 1
a515 1
void CDownloadListCtrl::UpdateItem(CPartFileDLItem *pFileItem)
d2046 1
a2046 1
			UpdateItem(pPartFile);
d2054 1
a2054 1
			UpdateItem(pSource);
d2069 1
a2069 1
					UpdateItem((*pvecDirtyFileItems)[i]);
d2083 1
a2083 1
					UpdateItem((*pvecDirtySources)[i]);
d2764 1
a2764 1
						//UpdateItem(selectedList.GetHead());	//update display at once, not in 1 sec
@


1.284
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d2200 9
a2297 8
			menuFile.AppendMenu(MF_STRING,MP_MOVIE, GetResString(IDS_MOVIE));
			if (bJustOne && !pPartFile->PreviewAvailable() && !pPartFile->IsArchive())
			{
				menuFile.CheckMenuItem(MP_MOVIE,(pPartFile->GetMovieMode() != 0)?MF_CHECKED:MF_UNCHECKED);
			}
			else
				menuFile.EnableMenuItem(MP_MOVIE, MF_GRAYED);

d3909 8
a3916 1
		else if (nChar == 'A' && pFileItem != NULL)
a3935 7
		else if (nChar == 'R' && pFileItem != NULL)
		{
			CFileDetails		dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);

			dialog.SetActivePage(2);
			dialog.DoModal();
		}
d3943 1
a3943 1
	}
@


1.283
log
@Started source filter rewrite.
Restructured list code (more to come)
@
text
@a72 2
	MapRemoveAllFiles();

d201 1
a201 1
	m_iCurTabCat = CAT_ALL;
d332 2
a333 2
//	AddFile() adds part file 'pPartFile' to the DownloadList and adds a row to display it if it should be visible.
void CDownloadListCtrl::AddFile(CPartFile *pPartFile)
d337 1
a337 9
	if (pPartFile == NULL)
		return;

//	Create new Item
	CPartFileDLItem	   *pFileItem = new CPartFileDLItem(pPartFile);

//	The same file shall be added only once
	ASSERT(!IsValidIterator(MapFindFileItem(pPartFile)));
	MapInsertFileItem(pPartFile, pFileItem);
d340 1
a340 1
	if (CCat::FileBelongsToGivenCat(pPartFile,m_iCurTabCat))
d350 2
a351 2
//	AddSource() adds Source 'pSource' to the download list and adds a row to display it if it should be visible.
void CDownloadListCtrl::AddSource(CPartFile *pParentFile,CUpDownClient *pSource,bool bSourceNotAvailable)
d355 1
a355 45
	if (pParentFile == NULL || pSource == NULL)
		return;

	CSourceDLItem	   *pSourceItem = NULL;

	SourceRange			range = MapFindSourceItems(pSource);

	for (SourceIter itSource = range.first; itSource != range.second; itSource++)
	{
		CSourceDLItem		*pSourceItem2 = itSource->second;

		if (pSourceItem2->GetParentFile() == pParentFile)
		{
			pSourceItem = pSourceItem2;
		}
		else
		{
		//	A Source can only be "Available" for one file at a time
			if (bSourceNotAvailable == false)
				pSourceItem2->SetAvailability(false);
		}
	}

	CPartFileDLItem		*pParentFileItem = NULL;

//	If there's no existing item for 'pSource', create one
	if (pSourceItem == NULL)
	{
	//	Find the part file item we want to add it to
		PFIter		itFileItem = MapFindFileItem(pParentFile);

	//	If it doesn't exist...
		if (!IsValidIterator(itFileItem))
			return;
		pParentFileItem = MapGetFileItem(itFileItem);
		pSourceItem = pParentFileItem->CreateSourceItem(pSource,!bSourceNotAvailable);
		MapInsertSourceItem(pSource,pSourceItem);
	}
//	If there's already an item for 'pSource'...
	else
	{
		pSourceItem->SetAvailability(!bSourceNotAvailable);
		pSourceItem->ResetUpdateTimer();
		return;
	}
d370 1
a370 1
		CPartFileDLItem	   *pFileItem3 = dynamic_cast<CPartFileDLItem*>(ListGetItemAt(iItem+1));
d372 1
a372 1
		if (pFileItem3 != NULL)
d383 3
a385 3
//	RemoveSource() removes and destroys any list items for source 'pSource' belonging to
//		part file 'pOwner'. If an error occurs, the method does nothing.
void CDownloadListCtrl::RemoveSource(CUpDownClient *pSource,CPartFile *pParentFile)
d389 1
a389 14
//	eklmn: do nothing if mule will be closed
	if (!g_eMuleApp.m_pdlgEmule->IsRunning()) 
	{
		return;
	}
	//eklmn: check null case
	if (pSource == NULL)
	{
		return;
	}

//	If the InfoList is displaying this source...
	if ( g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE
	  && g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == pSource )
d391 1
a391 4
	//	Set it to display nothing
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
	}
d393 5
a397 7
	CSourceDLItem	   *pSourceItem = RemoveSourceItem(pSource,pParentFile);

	if (pSourceItem != NULL)
	{
		CPartFileDLItem		*pParentFileItem = pSourceItem->GetParentFileItem();

		pParentFileItem->DeleteSourceItem(pSourceItem);
d439 1
a439 1
void CDownloadListCtrl::RemoveFile(CPartFile *pFileToRemove)
d443 1
a443 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning() || pFileToRemove == NULL) 
d450 1
a450 1
	  && g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetFile() == pFileToRemove )
d457 1
a457 1
	PFIter		itFile = MapFindFileItem(pFileToRemove);
d459 3
a461 2
//	If it was found...
	if (IsValidIterator(itFile))
d463 2
a464 14
		CPartFileDLItem	*pFileItem = MapGetFileItem(itFile);
		int				iFilePos = ListGetFileItemIndex(pFileItem);

	//	Remove the file item from the file map
		m_mapFiles.erase(itFile);
	//
	//	Remove the file item from the list
		if (iFilePos != -1)
		{
			pFileItem->SetVisibility(false);
			DeleteItem(iFilePos);
		}
	//	Destroy the file item
		delete pFileItem;
d472 1
a472 1
void CDownloadListCtrl::UpdateItem(CUpDownClient *pSource)
d476 1
a476 1
	if (::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_pdlgEmule->IsRunning())
d478 1
a478 1
		SourceRange		range = MapFindSourceItems(pSource);
d480 1
a480 2
	//	For each source item associated with 'pSource'...
		for (SourceIter itSource = range.first; itSource != range.second; itSource++)
d482 1
a482 2
			CSourceDLItem  *pSourceItem = MapGetSourceItem(itSource);
			int				iSourcePos = ListGetSourceItemIndex(pSourceItem);
d484 6
a489 1
			if (iSourcePos != -1)
d491 16
a506 12
			    bool	bDontUpdate = false;
    
			    if (pSourceItem != NULL && IsSourceFiltered(pSourceItem))
			    {
				    HideSource(pSourceItem->GetSource());
				    bDontUpdate = true;
			    }
			    if (!bDontUpdate)
			    {
				    if (pSourceItem != NULL)
						pSourceItem->ResetUpdateTimer();
					Update(iSourcePos);
a508 14
	    //	If we didn't find the source item in the list...
		    else
		    {
		    //	If it's a source, check to see if it should be shown now
			    if (pSourceItem != NULL)
			    {
				    CUpDownClient	*pSource = pSourceItem->GetSource();
    
				    if (!IsSourceFiltered(pSourceItem))
				    {
					    ShowSource(pSource);
				    }
			    }
		    }
d515 1
a515 1
void CDownloadListCtrl::UpdateItem(CPartFile *pPartFile)
d519 1
a519 1
	if (::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_pdlgEmule->IsRunning())
d521 1
a521 2
	//	Retrieve all entries matching the object
		PFIter		itFileItem = MapFindFileItem(pPartFile);
d523 2
a524 1
		if (IsValidIterator(itFileItem))
d526 4
a529 11
			CPartFileDLItem	   *pFileItem = MapGetFileItem(itFileItem);
			int					iFilePos = ListGetFileItemIndex(pFileItem);

	    //	If we found the file item in the list...
			if (iFilePos != -1)
			{
				if (pFileItem != NULL)
					pFileItem->ResetUpdateTimer();
				Update(iFilePos);
			}
	    }
d1043 1
a1043 1
						pPartFile->SetCatID(0);
d2000 6
a2005 3
			//	Go through the whole list to find out the sources for this file
			//	TODO: REWRITE THIS TO USE SOURCE LIST IN THE PARENT FILE ITEM.
				for (SourceIter itSource = m_mapSources.begin(); itSource != m_mapSources.end(); itSource++)
d2007 5
a2011 1
					CSourceDLItem		*pSourceItem2 = MapGetSourceItem(itSource);
a2012 6
					if (pSourceItem2 != NULL && pSourceItem2->GetParentFile() == pPartFile)
					{
						iNumAdded++;
						ListInsertSourceItem(pSourceItem2,iItem+1);
					}
				}
d2041 1
d2058 33
d2183 1
a2183 1
			menuSourceFilter.AppendMenu(MF_STRING|(m_bShowErrorSources?MF_CHECKED:0),0,_T("Smart Filter"));
d2376 1
a2376 1
		menuSourceFilter.AppendMenu(MF_STRING|(m_bShowErrorSources?MF_CHECKED:0),0,_T("Smart Filter"));
d2443 1
a2443 1
						pSelectedFile->SetCatID(0);
d2450 2
a2451 2
				UpdateItem(pPartFile);
			//	Update the category pPartFile counts
d2645 1
a2645 1
					ClearCompleted();
d2921 1
a2921 1
				ClearCompleted();
a3072 66
void CDownloadListCtrl::ClearCompleted(uint8 iCategoryID/* = 0*/)
{
//	Search for completed file(s)
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end();)
	{
		CPartFileDLItem		*pFileItem = MapGetFileItem(itFile);

		itFile++; // Already point to the next file.
		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pFileItem->GetFile();

			if ( pPartFile->IsPartFile() == false
			  && ( CCat::FileBelongsToGivenCat(pPartFile,iCategoryID == 0 ? m_iCurTabCat : iCategoryID)
				|| (iCategoryID == CAT_ALL) ) )
			{	
				RemoveFile(pPartFile);
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ClearCompleted() clears the single completed file with file hash 'pFileHash'.
void CDownloadListCtrl::ClearCompleted(const uchar *pFileHash /*=NULL*/)
{
	EMULE_TRY

//	eklmn: init temp array
	CArray<CPartFile*, CPartFile*>	completedFilesList;

	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); )
	{
		CPartFileDLItem	   *pFileItem = MapGetFileItem(itFile);

		itFile++; // Already point to the next file
		if (pFileItem != NULL)
		{
			CPartFile	*pPartFile = pFileItem->GetFile();

			if (!pPartFile->IsPartFile())
			{	
				if (pFileHash == NULL)
				{	
					completedFilesList.Add(pPartFile); 
				}
				else if (md4cmp(pFileHash, pPartFile->GetFileHash()) == 0) 
				{
					RemoveFile(pPartFile);
					break;	//we can stop searching if match is found
				}
			}
		}
	}
//	eklmn: clear all file correct way
	if (pFileHash == NULL)
	{
		for (int i = 0; i < completedFilesList.GetCount(); i++)
		{	
			RemoveFile(completedFilesList[i]);	//continue clearing all
		}
		completedFilesList.RemoveAll();
	}
	
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3704 1
a3704 1
						ClearCompleted(pPartFile->GetFileHash());
d3867 1
d3880 1
d3915 1
a3915 1
				ClearCompleted(pPartFile->GetFileHash());
a3990 63
CString CDownloadListCtrl::GetPartFilesStatusString() 
{
	EMULE_TRY

	CString		strOut=_T("");
	CString		strTemp1,strTemp2;

// Search for file(s)
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
	{
		CPartFileDLItem		*pFileItem = MapGetFileItem(itFile);

		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pFileItem->GetFile();

			AddLogLine(false,pPartFile->GetFileName());
			strTemp2 = pPartFile->GetFileName(); 
			if (strTemp2.GetLength() > 50) 
			{
				strTemp2 = strTemp2.Mid(0,50);
			}
			strTemp1.Format( _T("\n%s\t [%.1f%%] %i/%i - %s"),
							 strTemp2,
							 pPartFile->GetPercentCompleted(),
							 pPartFile->GetTransferringSrcCount(),
							 pPartFile->GetSourceCount(), 
							 pPartFile->GetPartfileStatus() );
			strOut = strOut + strTemp1;
		}
	}
	AddLogLine(false,strOut);

	return strOut;

	EMULE_CATCH

	return _T("");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CDownloadListCtrl::GetDisplayedFiles(CArray<CPartFile*,CPartFile*> *pDisplayedFileList)
{
	EMULE_TRY

	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
	{
		CPartFileDLItem		*pFileItem = MapGetFileItem(itFile);

		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pFileItem->GetFile();

			pDisplayedFileList->Add(pPartFile);
		}
	}	
	
	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d4041 1
a4041 1
void CDownloadListCtrl::ChangeCategoryByID(uint8 iNewCatID)
d4045 1
a4045 1
	iNewCatIndex = CCat::GetCatIndexByID(iNewCatID);
d4059 1
a4059 1
	m_iCurTabCat = CCat::GetCatIDByIndex(iNewCatIndex);
d4062 4
a4065 1
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
d4067 1
a4067 1
		CPartFileDLItem		*pFileItem = MapGetFileItem(itFile);
d4069 4
a4072 9
		if (pFileItem != NULL)
		{
			CPartFile	*pPartFile = pFileItem->GetFile();
			
			if (!CCat::FileBelongsToGivenCat(pPartFile,m_iCurTabCat))
				HideFile(pPartFile);
			else 
				ShowFile(pPartFile);
		}
d4074 1
d4080 1
a4080 1
void CDownloadListCtrl::HideSource(CUpDownClient *pSource)
d4082 2
a4083 2
//	Retrieve all entries matching the source
	SourceRange		range = MapFindSourceItems(pSource);
d4085 1
a4085 1
	for (SourceIter itSource = range.first; itSource != range.second; itSource++)
d4087 2
a4088 11
		CSourceDLItem		*pSourceItem  = MapGetSourceItem(itSource);

	// Find entry in list and update object
		int		iSourceIndex = ListGetSourceItemIndex(pSourceItem);

		if (iSourceIndex != -1)
		{
			pSourceItem->SetVisibility(false);
			DeleteItem(iSourceIndex);
			return;
		}
d4092 1
a4092 1
void CDownloadListCtrl::HideFile(CPartFile *pPartFile)
d4096 1
a4096 1
	HideSources(pPartFile);
d4098 1
a4098 2
//	Retrieve the entry for the file (if any)
	PFIter		itFile = MapFindFileItem(pPartFile);
d4100 1
a4100 1
	if (IsValidIterator(itFile))
d4102 2
a4103 8
		CPartFileDLItem	   *pFileItem = MapGetFileItem(itFile);
		int					iFileIndex = ListGetFileItemIndex(pFileItem);

		if (iFileIndex != -1)
		{
			pFileItem->SetVisibility(false);
			DeleteItem(iFileIndex);
		}
d4109 1
a4109 1
void CDownloadListCtrl::ShowFile(CPartFile *pPartFile)
d4113 1
a4113 2
//	Retrieve the entry matching the file (if any)
	PFIter			itFile = MapFindFileItem(pPartFile);
d4115 1
a4115 1
	if (IsValidIterator(itFile))
d4117 1
a4117 7
		CPartFileDLItem	   *pFileItem = MapGetFileItem(itFile);
		int					iFileIndex = ListGetFileItemIndex(pFileItem);

		if (iFileIndex == -1)
		{
			ListInsertFileItem(pFileItem,GetItemCount());
		}
d4123 1
a4123 1
void CDownloadListCtrl::ShowSource(CUpDownClient *pSource)
d4127 1
a4127 2
//	Retrieve all entries matching the source
	SourceRange		range = MapFindSourceItems(pSource);
d4129 2
a4130 1
	for (SourceIter itSource = range.first; itSource != range.second; itSource++)
d4132 10
a4141 5
		CSourceDLItem	   *pSourceItem = MapGetSourceItem(itSource);
		int					iSourceIndex = ListGetSourceItemIndex(pSourceItem);

	//	If the source item isn't already in the list...
		if (iSourceIndex == -1)
d4143 1
a4143 14
			CPartFileDLItem	   *pParentFileItem = pSourceItem->GetParentFileItem();
		//	Find the position of the next file item or the end of the list
			int					iParentFileIndex = ListGetFileItemIndex(pParentFileItem);
			int					iInsertionIndex = 0;

			if (iParentFileIndex > 0)
				iInsertionIndex = iParentFileIndex;
		//	Until we hit the end of the list or the next item is a file item...
			while ( iInsertionIndex+1 < GetItemCount()
				 && typeid(ListGetItemAt(iInsertionIndex+1)) != typeid(CPartFileDLItem))
			{
				iInsertionIndex++;
			}
			ListInsertSourceItem(pSourceItem,iInsertionIndex+1);
d4145 1
a4145 2

		return;
a4220 19
//	Map methods

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	MapRemoveAllFiles() removes and destroys all part file items in the window.
void CDownloadListCtrl::MapRemoveAllFiles()
{
	while (m_mapFiles.empty() == false)
	{
		delete MapGetFileItem(m_mapFiles.begin());
		m_mapFiles.erase(m_mapFiles.begin());
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadListCtrl::SourceRange CDownloadListCtrl::MapFindSourceItems(CUpDownClient *pSource)
{
	return m_mapSources.equal_range(pSource);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

d4266 2
a4267 4
//	RemoveSourceItem() removes the source item for source 'pSource' and parent file 'pParentFile'
//		from the source map and the list. If 'pParentFile' is NULL, all source items for the source are removed.
//		The last of the source items removed  is returned (or NULL if there is none).
CSourceDLItem *CDownloadListCtrl::RemoveSourceItem(CUpDownClient *pSource, CPartFile *pParentFile/*=NULL*/)
d4269 8
a4276 5
	CSourceDLItem	   *pSourceItem = NULL;
	SourceRange			range = MapFindSourceItems(pSource);

//	For each source item associated with 'pSource' in the multi-map...
	for (SourceIter itSource = range.first; itSource != range.second; )
d4278 1
a4278 1
		pSourceItem = MapGetSourceItem(itSource);
d4280 2
a4281 2
	//	If no parent file was spec'd or this item belongs to the spec'd parent file...
		if (pSourceItem != NULL && (pParentFile == NULL || pSourceItem->GetParentFile() == pParentFile))
d4283 2
a4284 16
			m_mapSources.erase(itSource);

			int		iItem = ListGetSourceItemIndex(pSourceItem);

			if (iItem != -1)
			{
				pSourceItem->SetVisibility(false);
				DeleteItem(iItem);
			}
		//	If a parent file was spec'd we're done, otherwise continue for the rest of the items for the source.
			if (pParentFile != NULL)
				break;
		}
		else
		{
			itSource++;
a4286 8

	return pSourceItem;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ListGetItemAt() returns the list item at index 'iIndex'.
CMuleCtrlItem *CDownloadListCtrl::ListGetItemAt(int iIndex)
{
	return reinterpret_cast<CMuleCtrlItem*>(GetItemData(iIndex));
@


1.282
log
@Changed the default value in ClearCompleted from CAT_UNCATEGORIZED to 0.
@
text
@d73 3
a75 14
	if(m_menuPriority)
	{ 
		VERIFY( m_menuPriority.DestroyMenu() );
	}
	if(m_menuFile) 
	{
		VERIFY( m_menuFile.DestroyMenu() );
	}
	while(m_mapItems.empty() == false)
	{
		delete m_mapItems.begin()->second;
		m_mapItems.erase(m_mapItems.begin());
	}	
	m_imageList.DeleteImageList();	//eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d84 2
a85 1
	CImageList ilDummyImageList;
d88 1
a88 1
	ASSERT( (GetStyle() & LVS_SHAREIMAGELISTS) == 0 );
d94 13
d186 2
a187 2

	//sortdlg Cax2
d212 1
a212 1
	if(GetSafeHwnd())
d214 3
a216 2
		CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
		HDITEM hdi;
d218 2
a219 1
		CString strRes;
d271 1
a271 1
		strRes = GetResString(IDS_TIME); // should be est. time
d334 2
a335 2
//	AddFile() adds PartFile 'toadd' to the DownloadList and adds a row to display it if it should be visible.
void CDownloadListCtrl::AddFile(CPartFile* pFileToAdd)
d339 1
a339 1
	if (pFileToAdd == NULL)
d342 2
a343 2
	// Create new Item
	CMuleCtrlItem	*pItem = new CMuleCtrlItem(pFileToAdd, NULL, NULL);
d346 2
a347 2
	ASSERT(m_mapItems.find(pFileToAdd) == m_mapItems.end());
	m_mapItems.insert(make_pair(pFileToAdd, pItem));
d349 5
a353 4
	//	If the file belongs to the currently displayed category, add it to the list control (emule .30a)
	if (CCat::FileBelongsToGivenCat(pFileToAdd,m_iCurTabCat))
		{
	        uint16 itemnr = GetItemCount();
d355 1
a355 4
			InsertItem(LVIF_PARAM|LVIF_TEXT,itemnr,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)pItem);
		}

		ShowFilesCount();
d360 2
a361 1
void CDownloadListCtrl::AddSource(CPartFile *pOwner,CUpDownClient *pSource,bool bSourceNotAvailable)
d365 1
a365 1
	if (pOwner == NULL || pSource == NULL)
d368 3
a370 2
	CMuleCtrlItem	*pSourceItem = NULL;
	MuleRange		Range = m_mapItems.equal_range(pSource);
d372 1
a372 2
//	Try to find existing DownloadListCtrl items for the source belonging to the spec'd file
	for (MuleIter itFile = Range.first; itFile != Range.second; itFile++)
d374 1
a374 1
		CMuleCtrlItem	*pItem2 = itFile->second;
d376 1
a376 1
		if (pItem2->GetFile() == pOwner)
d378 1
a378 1
			pSourceItem = pItem2;
d384 1
a384 1
				pItem2->SetSourceAvailability(false);
d388 1
a388 1
	CMuleCtrlItem	*pFileItem = NULL;
d390 1
a390 1
//	Create item, if it's new
d394 1
a394 1
		MuleIter		itFileItem = m_mapItems.find(pOwner);
d397 1
a397 1
		if (itFileItem == m_mapItems.end())
d399 3
a401 4
		pFileItem = itFileItem->second;
		pSourceItem = new CMuleCtrlItem(pOwner, pFileItem, pSource);
		pSourceItem->SetSourceAvailability(!bSourceNotAvailable);
		m_mapItems.insert(make_pair(pSource, pSourceItem));
d403 1
d406 1
a406 1
		pSourceItem->SetSourceAvailability(!bSourceNotAvailable);
d411 1
a411 1
	if (pFileItem == NULL || !pFileItem->m_bSrcsAreVisible)
d417 2
a418 1
	LVFINDINFO		find;
d420 5
a424 2
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pFileItem;
d426 4
a429 6
	int		nItem = FindItem(&find);

	if (nItem < 0)
		nItem = 0;
	while (GetItemCount() > nItem+1 && !(reinterpret_cast<CMuleCtrlItem*>(GetItemData(nItem+1)))->IsFile())
		nItem++;
d432 1
a432 3
		InsertItem(LVIF_PARAM,nItem+1,0,0,0,0,(LPARAM)pSourceItem);

	//RefreshInfo();	// eklmn: bugfix(12): refresh whole list
d439 1
a439 1
void CDownloadListCtrl::RemoveSource(CUpDownClient *pSource,CPartFile *pOwner)
d463 1
a463 2
//	Retrieve all list items matching the source
	MuleRange		Range = m_mapItems.equal_range(pSource);
d465 1
a465 1
	for (MuleIter itSource = Range.first; itSource != Range.second; )
d467 1
a467 12
		CMuleCtrlItem	*pSourceItem = itSource->second;

		if (pOwner == NULL || pSourceItem->GetFile() == pOwner)
		{
		//	Remove it from the item list
			itSource = m_mapItems.erase(itSource);

		//	Remove it from the list control
 			LVFINDINFO		find;

			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)pSourceItem;
d469 1
a469 13
			sint16		result = FindItem(&find);

			if (result != -1)
			{
				DeleteItem(result);
			}
		//	Finally, destroy the source item
			delete pSourceItem;
		}
		else
		{
			itSource++;
		}
d477 1
a477 1
bool CDownloadListCtrl::IsSourceFiltered(CMuleCtrlItem *pSourceItem)
d479 2
a480 2
	bool			bShowNewSource = true;
	CMuleCtrlItem  *pFileItem = pSourceItem->GetFileItem();
d488 1
a488 1
		CUpDownClient	*pSource = pSourceItem->GetSource();	//TODO: Should check to make pSource it's really a pSource
d490 1
d505 1
d515 1
a515 6
	if (!g_eMuleApp.m_pdlgEmule->IsRunning()) 
	{
		return;
	}
//	Check NULL case
	if (pFileToRemove == NULL)
d520 1
a520 1
	//	If the InfoList is displaying this file...
d529 4
a532 4
//	Retrieve all entries matching the File or linked to the file
//	Remark: The 'asked another files' clients must be removed from here
	ASSERT(pFileToRemove != NULL);
	for (MuleIter itItem = m_mapItems.begin(); itItem != m_mapItems.end(); )
d534 2
a535 1
		CMuleCtrlItem		*pItem = itItem->second;
d537 5
a541 1
		if (pItem->GetFile() == pFileToRemove/* || pItem->GetSource() == pFileToRemove*/)
d543 2
a544 21
		//	Remove it from the item list
			itItem = m_mapItems.erase(itItem);

		//	Remove it from the list control
			LVFINDINFO		find;

			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)pItem;

			int		result = FindItem(&find);

			if (result != -1)
			{
				DeleteItem(result);
			}
		//	Finally, destroy the item
			delete pItem;
		}
		else 
		{
			itItem++;
d546 2
d549 1
d555 1
a555 1
void CDownloadListCtrl::UpdateItem(void* pObjToUpdate) //<= UGLY
d558 2
a559 2
	
	if (!::IsWindow(GetSafeHwnd()))	//fix crash at exit [TwoBottle Mod]
d561 1
a561 2
		return;
	}
d563 2
a564 6
	if (g_eMuleApp.m_pdlgEmule->IsRunning()) 
	{
	//	Retrieve all entries matching the object
	    MuleRange		Range = m_mapItems.equal_range(pObjToUpdate);
    
	    for (MuleIter itItem = Range.first; itItem != Range.second; itItem++)
d566 2
a567 1
		    CMuleCtrlItem	*pItem = itItem->second;
d569 1
a569 10
		//	Try to find a corresponding list ctrl item
		    LVFINDINFO		find;

			find.flags = LVFI_PARAM;
		    find.lParam = (LPARAM)pItem;
    
		    int		result = FindItem(&find);
    
	    //	If we found the MuleCtrlItem in the DownloadListCtrl...
			if (result != -1)
d573 1
a573 1
			    if (pItem->IsSource())
d575 2
a576 5
				    if (IsSourceFiltered(pItem))
				    {
					    HideSource(pItem->GetSource());
					    bDontUpdate = true;
				    }
d580 3
a582 2
				    pItem->ResetUpdateTimer();
					Update(result);
d585 1
a585 1
	    //	If we didn't find the MuleCtrlItem in the DownloadListCtrl...
d589 1
a589 1
			    if (pItem->IsSource())
d591 1
a591 1
				    CUpDownClient	*pSource = pItem->GetSource();
d593 1
a593 1
				    if (!IsSourceFiltered(pItem))
d599 27
d632 1
a632 1
void CDownloadListCtrl::DrawFileItem(CDC *dc, int nColumn, LPRECT lpRect, CMuleCtrlItem *lpFileItem) 
a658 3
	if (!lpFileItem->IsFile())
		return;

d662 1
a662 1
		CPartFile		*pPartFile = lpFileItem->GetFile();
d698 1
a698 1
					  ? (lpFileItem->m_bSrcsAreVisible ? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS)
d888 2
a889 2
					if (lpFileItem->GetBitmap() == (HBITMAP)NULL)
						VERIFY(lpFileItem->GetBitmap().CreateBitmap(1, 1, 1, 8, NULL)); 
d896 1
a896 1
					int		cx = lpFileItem->GetBitmap().GetBitmapDimension().cx; 
d899 1
a899 1
					if (lpFileItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iBarWidth || lpFileItem->GetUpdateTimer() != 0)
d901 4
a904 4
						lpFileItem->GetBitmap().DeleteObject(); 
						lpFileItem->GetBitmap().CreateCompatibleBitmap(dc,  iBarWidth, iBarHeight); 
						lpFileItem->GetBitmap().SetBitmapDimension(iBarWidth,  iBarHeight); 
						hOldBitmap = cdcStatus.SelectObject(lpFileItem->GetBitmap()); 
d913 1
a913 1
						lpFileItem->SetUpdateTimer(dwTicks + (rand() % 128)); 
d916 1
a916 1
						hOldBitmap = cdcStatus.SelectObject(lpFileItem->GetBitmap()); 
d1273 1
a1273 1
void CDownloadListCtrl::DrawSourceItem(CDC *dc, int nColumn, LPRECT lpRect, CMuleCtrlItem *pSourceItem) 
d1277 1
a1277 1
	if(pSourceItem == NULL || !pSourceItem->IsSource())
d1280 1
a1280 1
	if(lpRect->left < lpRect->right) 
d1283 1
a1283 1
			CUpDownClient *lpClient = pSourceItem->GetSource();
d1285 3
a1287 3
		try{ sDownloadState = lpClient->GetDownloadStateAsString(); }catch(...){}
		uint8 nDownloadState = lpClient->GetDownloadState();
		EnumClientTypes nClientSoft = lpClient->GetClientSoft();
d1295 1
a1295 1
				nVersion= lpClient->GetMuleVersion();
d1298 1
a1298 1
				nVersion= lpClient->GetVersion();
d1300 3
a1302 3
		bool bIsBanned = lpClient->IsBanned(); //katsyonak 07/07/03
		bool bIsFriend = lpClient->IsFriend();
		float fRemoteBaseModifier = lpClient->GetRemoteBaseModifier();
d1304 13
a1316 13
		if(lpClient->GetUserName())
			try{ sClientName = CString(lpClient->GetUserName()); }catch(...){}
		uint32 nTransferredDown = lpClient->GetTransferredDown();
		uint32 nDownloadDataRate = lpClient->GetDownloadDataRate();
		bool bIsEmuleClient = lpClient->IsEmuleClient();
		uint16 nRemoteQueueRank = lpClient->GetRemoteQueueRank();
		uint16 nDifference = lpClient->GetDifference(); //cendre-eau
		bool bNeverAskedBefore = lpClient->GetLastSrcReqTime() == 0;
		bool bRemoteQueueFull = lpClient->IsRemoteQueueFull();
		bool bIsRemoteInfoAvail = lpClient->IsRemoteInfoAvaiable();
		bool bCredits = lpClient->credits != (CClientCredits*)NULL && lpClient->credits != (CClientCredits*)-1;
		uint16 nRemoteRatio = lpClient->GetRemoteRatio();
			bool a4af=pSourceItem->IsAskedForAnotherFile();
d1369 1
a1369 1
						try{ status.Format(_T("(%s)"),lpClient->reqfile->GetFileName()); }catch(...){}
d1397 1
a1397 1
						if (lpClient->credits->GetCurrentIdentState(lpClient->GetIP()) != IS_IDENTIFIED)
d1446 2
a1447 2
					uint16		iLastPart = lpClient->GetLastDownPart();
					uint8		ds = lpClient->GetDownloadState();
d1518 1
a1518 1
						lpClient->DrawStatusBar(&cdcStatus,  &rec_status,(pSourceItem->IsAskedForAnotherFile()), g_eMuleApp.m_pGlobPrefs->UseFlatBar()); 
d1535 1
a1535 1
				CString clientVerString = GetClientNameAndVersionString(lpClient);
d1609 2
a1610 2
					uint16		iLastPart = lpClient->GetLastDownPart();
					uint8		ds = lpClient->GetDownloadState();
d1618 1
a1618 1
									lpClient->GetLastDownPart() );
d1632 2
a1633 2
					uint16		iLastPart = lpClient->GetLastDownPart();
					uint8		ds = lpClient->GetDownloadState();
d1673 1
a1673 1
					uint8		ds = lpClient->GetDownloadState();
d1677 1
a1677 1
						uint32		iSeconds = lpClient->GetQueueWaitTime() / 1000.0;
d1716 6
a1721 4
	CDC				*odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	CMuleCtrlItem	*pItem = (CMuleCtrlItem*)lpDrawItemStruct->itemData;
	BOOL			bCtrlFocused = ((GetFocus() == this) || (GetStyle() & LVS_SHOWSELALWAYS));
	RECT			cur_rec;
d1723 1
a1723 1
	if ((pItem->IsFile()) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d1745 1
a1745 1
		if (pItem->IsFile())
d1751 1
a1751 1
			DrawFileItem(dc, m_iMeasuringColumn, &cur_rec, pItem);
d1769 1
a1769 1
	if (pItem->IsFile())
d1789 1
a1789 1
				DrawFileItem(dc, 5, &cur_rec, pItem);
d1795 1
a1795 1
				DrawFileItem(dc, iColumn, &cur_rec, pItem);
d1801 1
a1801 1
	else if (pItem->IsSource())
d1820 1
a1820 1
				DrawSourceItem(dc, 5, &cur_rec, pItem);
d1826 1
a1826 1
				DrawSourceItem(dc, iColumn, &cur_rec, pItem);
d1835 1
a1835 1
	  && (lpDrawItemStruct->itemState & ODS_SELECTED) && (pItem->IsFile()) )
d1851 1
a1851 1
		if(bNotFirst && (GetItemState(lpDrawItemStruct->itemID - 1, LVIS_SELECTED)))
d1853 3
a1855 2
			CMuleCtrlItem* prev = (CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID - 1);
			if(prev->IsFile())
d1859 1
a1859 1
		if(bNotLast && (GetItemState(lpDrawItemStruct->itemID + 1, LVIS_SELECTED)))
d1861 3
a1863 2
			CMuleCtrlItem* next = (CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1);
			if(next->IsFile())
d1908 6
a1913 4
		BOOL hasNext = bNotLast &&
			((CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1))->IsSource();
		BOOL isOpenRoot = hasNext && pItem->IsFile();
		BOOL isChild = pItem->IsSource();
d1986 2
a1987 1
		CMuleCtrlItem		*pItem = (CMuleCtrlItem*)GetItemData(i); 
d1990 1
a1990 1
		if (pItem->IsSource() && pItem->GetFile() == pPartFile)
d1992 4
a1995 3
			pItem->GetFileItem()->m_bSrcsAreVisible = false;
			pItem->ResetUpdateTimer(); 
			pItem->GetBitmap().DeleteObject(); 
d1999 1
d2001 1
d2003 1
a2003 1
	if (m_bShowSrc)			//Cax2 check if we don't show sources anymore...
d2006 1
a2006 1
	//	For each item in the list control...
d2009 2
d2012 1
a2012 1
			if (((CMuleCtrlItem*)GetItemData(i))->IsSource()) 
d2052 7
a2058 5
	CMuleCtrlItem		*pItem = (CMuleCtrlItem*)GetItemData(iItem);

	bool	isShift=GetAsyncKeyState(VK_SHIFT) < 0;
	bool	isCtrl=GetAsyncKeyState(VK_CONTROL) < 0;
	bool	isAlt=GetAsyncKeyState(VK_MENU) < 0;
d2061 4
a2064 3
	if (bCollapseSource && pItem->GetFileItem()!=NULL) 
	{// to collapse/expand files when one of its source is selected
		pItem = pItem->GetFileItem();
d2066 1
a2066 1
 		LVFINDINFO		find;
d2068 2
a2069 3
		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pItem;
		iItem = FindItem(&find);
d2071 1
a2071 2
		if (iItem==-1)
			return;
d2074 1
a2074 1
	if (pItem != NULL && pItem->IsFile()) 
d2081 1
a2081 1
		CPartFile		*pPartFile = pItem->GetFile();
d2088 2
a2089 2
	// Check if the source branch is disabled
		if (pItem->m_bSrcsAreVisible == false && pPartFile->GetStatus() != PS_COMPLETING) 
a2090 18
			bool		bFilterSources = false;

		//	If a modifier key is held, toggle corresponding filter
			if (isShift || isCtrl || isAlt)
			{
				if (isShift)
					pItem->m_bShowOnlySrcsUploading = !pItem->m_bShowOnlySrcsUploading;
				if (isCtrl)
					pItem->m_bShowOnlySrcsAllowingUsInUploadQueue = !pItem->m_bShowOnlySrcsAllowingUsInUploadQueue;
				if (isAlt)
					pItem->m_bShowOnlySrcsWithNeededParts = !pItem->m_bShowOnlySrcsWithNeededParts;
			}

			//	Filter if any of the source filters are active
			bFilterSources = pItem->m_bShowOnlySrcsUploading
						  || pItem->m_bShowOnlySrcsAllowingUsInUploadQueue
						  || pItem->m_bShowOnlySrcsWithNeededParts;

d2098 2
a2099 2
			//	Remark: don't use GetSourceCount() => UNAVAILABLE_SOURCE
				for (MuleIter itItem = m_mapItems.begin(); itItem != m_mapItems.end(); itItem++)
d2101 1
a2101 1
					const CMuleCtrlItem		*pItem2 = itItem->second;
d2103 1
a2103 1
					if (pItem2->IsSource() && pItem2->GetFile() == pPartFile)
a2104 11
						if (bFilterSources)
						{
							EnumDLQState	ds = pItem2->GetSource()->GetDownloadState();

							if (!( pItem->m_bShowOnlySrcsUploading && ds==DS_DOWNLOADING && !pItem2->IsAskedForAnotherFile()
							    || pItem->m_bShowOnlySrcsAllowingUsInUploadQueue && pItem2->GetSource()->GetRemoteQueueRank() > 0
							    || pItem->m_bShowOnlySrcsWithNeededParts && ds != DS_NONEEDEDPARTS ) )
							{
								continue; // skip this source
							}
						}
d2106 1
a2106 1
						InsertItem(LVIF_PARAM|LVIF_TEXT,iItem+1,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)pItem2);
d2109 1
a2109 1
				pItem->m_bSrcsAreVisible = iNumAdded > 0;
d2123 1
a2123 1
		SortInit(pItem->m_bSrcsAreVisible && g_eMuleApp.m_pGlobPrefs->DoUseSort()); //override if useSort & showing sources...
d2165 1
a2165 1
void CDownloadListCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
d2169 7
a2175 5
	CTitleMenu		m_menuClient;
	CTitleMenu		m_menuFile;
	CMenu			m_menuPriority;
	CMenu			m_ed2kMenu;
	CMenu			m_menuWeb;
d2178 1
a2178 1
	if (GetSelectionMark() != (-1) && GetSelectedCount()>0)
d2180 4
a2183 2
		CMuleCtrlItem		*content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
		const CPartFile		*cFile = NULL; //Cax2 bugfix for Dr Slump? start
d2186 14
a2199 10
		if (content->IsFile()) 
			cFile = content->GetFile();
		if (cFile != NULL)
		{
			CPartFile		*file = (CPartFile*)cFile; //Cax2 bugfix
			bool			filedone = (file->GetStatus()==PS_COMPLETE || file->GetStatus()==PS_COMPLETING);
			bool			justOne = (GetSelectedCount()==1); //Cax2 faster code
			int				status = file->GetStatus();

			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(file); // FoRcHa
d2201 41
a2241 2
			
			UINT		uFlagIfDone  = filedone?MF_GRAYED:MF_ENABLED;
d2243 1
a2243 2
			m_menuFile.CreatePopupMenu();
			m_menuFile.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));
d2245 43
a2287 52
			m_menuPriority.CreateMenu();
			m_menuPriority.AppendMenu(MF_STRING,MP_PRIOLOW, GetResString(IDS_PRIOLOW));
			m_menuPriority.EnableMenuItem(MP_PRIOLOW,uFlagIfDone);
			m_menuPriority.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
			m_menuPriority.EnableMenuItem(MP_PRIONORMAL,uFlagIfDone);
			m_menuPriority.AppendMenu(MF_STRING,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
			m_menuPriority.EnableMenuItem(MP_PRIOHIGH,uFlagIfDone);
			m_menuPriority.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));
			m_menuPriority.EnableMenuItem(MP_PRIOAUTO,uFlagIfDone);
		
			m_ed2kMenu.CreateMenu();
			m_ed2kMenu.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
			m_ed2kMenu.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
			m_ed2kMenu.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK));

			m_menuAdvanced.CreateMenu();
			m_menuAdvanced.AppendMenu(MF_STRING,MP_FAKE_CHECK,GetResString(IDS_FAKE_CHECK));
			m_menuAdvanced.EnableMenuItem(MP_FAKE_CHECK, justOne ? MF_ENABLED:MF_GRAYED);
			m_menuAdvanced.AppendMenu(MF_STRING,MP_FAKE_REPORT,GetResString(IDS_FAKE_REPORT));
			m_menuAdvanced.EnableMenuItem(MP_FAKE_REPORT, justOne ? MF_ENABLED:MF_GRAYED);
			m_menuAdvanced.AppendMenu(MF_SEPARATOR);
			m_menuAdvanced.AppendMenu(MF_STRING,MP_DOCLEANUP, GetResString(IDS_DOCLEANUP));
			m_menuAdvanced.EnableMenuItem(MP_DOCLEANUP, !filedone ? MF_ENABLED:MF_GRAYED);
			m_menuAdvanced.AppendMenu(MF_STRING,MP_CHANGEDIR, GetResString(IDS_CHANGEDIR));
			m_menuAdvanced.EnableMenuItem(MP_CHANGEDIR, !filedone ? MF_ENABLED:MF_GRAYED);
			m_menuAdvanced.AppendMenu(MF_STRING,MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE));
			m_menuAdvanced.EnableMenuItem(MP_PREALLOCATE, (justOne && !file->IsLastBlockComplete()
															&& !file->IsPreallocated()) ? MF_ENABLED:MF_GRAYED);
			m_menuAdvanced.AppendMenu(MF_SEPARATOR);
			m_menuAdvanced.AppendMenu(MF_STRING,MP_DROPNONEEDEDSRCS, GetResString(IDS_DROPNONEEDEDSRCS));
			m_menuAdvanced.EnableMenuItem(MP_DROPNONEEDEDSRCS,((status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));
			m_menuAdvanced.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED));
			m_menuAdvanced.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, file->GetDiscardSuperCompressed() ? MF_CHECKED:MF_UNCHECKED);
			m_menuAdvanced.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, ((status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));
			m_menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE));
			m_menuAdvanced.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(justOne && status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED);
			CString buffer;
			buffer.Format(_T("%s (%s)"), GetResString(IDS_ALL_A4AF_TO_HERE), GetResString(IDS_PRIOAUTO));
			m_menuAdvanced.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,buffer);
			if (justOne && status != PS_COMPLETE && status != PS_COMPLETING)
			{
				m_menuAdvanced.CheckMenuItem(MP_ALL_A4AF_AUTO, (file== g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile()) ? MF_CHECKED:MF_UNCHECKED);
				m_menuAdvanced.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_ENABLED);
			} else {
				m_menuAdvanced.CheckMenuItem(MP_ALL_A4AF_AUTO, MF_UNCHECKED);
				m_menuAdvanced.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_GRAYED);
			}

			int		counter;

			m_menuWeb.CreateMenu();
			UpdateURLMenu(m_menuWeb,counter);
d2289 2
a2290 1
			UINT	flag;
d2292 1
a2292 1
			flag = (counter == 0) ? MF_GRAYED : MF_STRING;
d2294 4
a2297 4
			m_menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
			m_menuFile.AppendMenu(MF_SEPARATOR);

		//	Create Category assignment sub-menu
d2300 1
a2300 1
			int				iFileCatIndex = CCat::CatIndexToUserCatIndex(CCat::GetCatIndexByID(cFile->GetCatID()));
d2306 1
a2306 1
				flag = MF_STRING;
d2319 1
a2319 1
				flag = MF_GRAYED;
d2321 9
a2329 1
			m_menuFile.AppendMenu(flag|MF_POPUP,(UINT_PTR)catMenu.m_hMenu, GetResString(IDS_CAT_ASSIGN) );
d2331 2
a2332 9
			m_menuFile.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_menuPriority.m_hMenu, GetResString(IDS_PRIORITY));
			m_menuFile.EnableMenuItem((UINT_PTR)m_menuPriority.m_hMenu, MF_ENABLED);
			m_menuPriority.CheckMenuItem(MP_PRIOLOW,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_LOW)? MF_CHECKED:MF_UNCHECKED);
			m_menuPriority.CheckMenuItem(MP_PRIONORMAL,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_NORMAL)? MF_CHECKED:MF_UNCHECKED);
			m_menuPriority.CheckMenuItem(MP_PRIOHIGH,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_HIGH)? MF_CHECKED:MF_UNCHECKED);
			m_menuPriority.CheckMenuItem(MP_PRIOAUTO, (justOne && file->IsAutoPrioritized())? MF_CHECKED:MF_UNCHECKED);
			
			m_menuFile.AppendMenu(MF_STRING,MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL));
			m_menuFile.EnableMenuItem(MP_CANCEL,(!filedone) ? MF_ENABLED:MF_GRAYED);
d2334 2
a2335 2
			m_menuFile.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP));
			m_menuFile.EnableMenuItem(MP_STOP,((status != PS_STOPPED && status != PS_ERROR && !filedone ) ? MF_ENABLED:MF_GRAYED));
d2337 2
a2338 2
			m_menuFile.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE));
			m_menuFile.EnableMenuItem(MP_PAUSE,((status != PS_PAUSED && status != PS_STOPPED && status != PS_ERROR && !filedone) ? MF_ENABLED:MF_GRAYED));
d2340 2
a2341 2
			m_menuFile.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME));
			m_menuFile.EnableMenuItem(MP_RESUME,((status == PS_PAUSED || status == PS_STOPPED) ? MF_ENABLED:MF_GRAYED));
d2343 2
a2344 2
			if(justOne && status == PS_ERROR)
				m_menuFile.AppendMenu(MF_STRING,MP_INITIALIZE, GetResString(IDS_DL_INITIALIZE));
d2346 1
a2346 1
			m_menuFile.AppendMenu(MF_SEPARATOR);
d2348 2
a2349 2
			m_menuFile.AppendMenu(MF_STRING,MP_OPEN, GetResString(IDS_DL_OPEN));
			m_menuFile.EnableMenuItem(MP_OPEN,((justOne && status == PS_COMPLETE) ? MF_ENABLED:MF_GRAYED));
d2351 2
a2352 2
			m_menuFile.AppendMenu(MF_STRING,MP_MOVIE, GetResString(IDS_MOVIE));
			if(justOne && !file->PreviewAvailable() && !file->IsArchive())
d2354 4
a2357 9
				m_menuFile.CheckMenuItem(MP_MOVIE,(file->GetMovieMode() != 0)?MF_CHECKED:MF_UNCHECKED);
			} else
				m_menuFile.EnableMenuItem(MP_MOVIE, MF_GRAYED);

			m_menuFile.AppendMenu(MF_STRING,MP_PREVIEW, GetResString(IDS_DL_PREVIEW));
			m_menuFile.EnableMenuItem(MP_PREVIEW,((justOne && file->PreviewAvailable()) ? MF_ENABLED:MF_GRAYED));

			m_menuFile.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO));
			m_menuFile.EnableMenuItem(MP_METINFO,(justOne)?MF_ENABLED:MF_GRAYED); // Cax2
d2359 2
a2360 2
			m_menuFile.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL));
			m_menuFile.EnableMenuItem(MP_VIEWFILECOMMENTS,(justOne && (file->HasComment() || file->HasRating())) /*&& !filedone*/ ?MF_ENABLED:MF_GRAYED); // Cax2  //netwolf: no comments on complete files	// netwolf 06.05.03 only enabled if there is a comment/rating	// #zegzav:pastcomment; allow to see past comments for completed files
d2362 2
a2363 1
			m_menuFile.AppendMenu(MF_SEPARATOR);
d2365 20
a2384 11
			m_menuFile.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_menuAdvanced.m_hMenu, GetResString(IDS_PW_ADVANCED));
			m_menuFile.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_ed2kMenu.m_hMenu, GetResString(IDS_ED2KLINKFIX));
			m_menuFile.AppendMenu(flag|MF_POPUP,(UINT_PTR)m_menuWeb.m_hMenu, GetResString(IDS_WEBSERVICES));

			m_menuFile.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
//			m_menuFile.RemoveMenu(28,MF_BYPOSITION);
			m_menuPriority.DestroyMenu();
			m_ed2kMenu.DestroyMenu();
			m_menuAdvanced.DestroyMenu();
			m_menuWeb.DestroyMenu();
			m_menuFile.DestroyMenu();
d2386 1
d2389 4
a2392 3
			const CUpDownClient* client = content->GetSource();
			if (client !=NULL) 
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser((CUpDownClient*)client);
d2394 4
a2397 3

			m_menuClient.CreatePopupMenu();
			m_menuClient.AddMenuTitle(GetResString(IDS_CLIENTS));
d2399 3
a2401 3
			m_menuClient.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
			if(client->IsFriend())
				m_menuClient.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d2403 5
a2407 5
				m_menuClient.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
			m_menuClient.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG));
			m_menuClient.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
			if(content->IsAskedForAnotherFile())
				m_menuClient.AppendMenu(MF_STRING,MP_DOWNNOW, GetResString(IDS_DOWNLOAD_A4AF)); // Ambdribant
d2409 2
a2410 2
			m_menuClient.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
			m_menuClient.DestroyMenu();
d2412 32
a2443 6
	} else {
		m_menuFile.CreatePopupMenu();
		m_menuFile.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));
		m_menuFile.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
		m_menuFile.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
		m_menuFile.DestroyMenu();
d2453 1
a2453 1
	if (GetSelectionMark() != (-1))
d2455 12
a2466 8
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
				
		//for multiple selections 
		UINT selectedCount = GetSelectedCount(); 
		CTypedPtrList<CPtrList, CPartFile*> selectedList; 
		int index = -1; 
		POSITION pos = GetFirstSelectedItemPosition(); 
		while(pos != NULL) 
d2468 2
a2469 2
			index = GetNextSelectedItem(pos); 
			if(index > -1) 
d2471 1
a2471 1
				if (((CMuleCtrlItem*)GetItemData(index))->IsFile())
d2473 1
a2473 1
					selectedList.AddTail(((CMuleCtrlItem*)GetItemData(index))->GetFile());
d2477 2
a2478 2

		if (content->IsFile())
d2480 1
a2480 1
			CPartFile* file = content->GetFile();
d2482 3
a2484 1
			if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+64) 
d2486 1
a2486 1
				RunURL(file, g_eMuleApp.webservices.GetAt(wParam-MP_WEBURL) );
d2492 1
a2492 1
				while(!selectedList.IsEmpty()) 
d2494 2
a2495 2
					CPartFile	*selected = selectedList.GetHead();
					uint8		iUserCatIndex = wParam - MP_ASSIGNCAT;
d2501 1
a2501 1
						selected->SetCatID(CCat::GetCatIDByIndex(iCatIndex));
d2505 1
a2505 1
						selected->SetCatID(0);
d2509 1
a2509 1
			//	Hide the file if it's not in the displayed category
d2511 3
a2513 3
			//	Redraw the file in its new color assuming it is visible
				UpdateItem(file);
			//	Update the category file counts
d2522 2
a2523 2
					//for multiple selections 
					if(selectedCount > 0)
d2525 2
a2526 2
						CString fileList="";
						bool validdelete = false;
d2528 1
a2528 1
						for (pos = selectedList.GetHeadPosition() ; pos != 0 ; selectedList.GetNext(pos))
d2530 1
a2530 1
							if(selectedList.GetAt(pos)->GetStatus() != PS_COMPLETING && selectedList.GetAt(pos)->GetStatus() != PS_COMPLETE)
d2532 3
a2534 2
								validdelete = true;
								if (selectedCount<50) fileList.Append("\n"+CString(selectedList.GetAt(pos)->GetFileName())); 
d2538 3
a2540 2
						CString quest;
						if (selectedCount==1)
d2542 1
a2542 1
							quest=GetResString(IDS_Q_CANCELDL2);
d2546 1
a2546 1
							quest=GetResString(IDS_Q_CANCELDL);
d2548 1
a2548 1
						if (validdelete && AfxMessageBox(quest + fileList,MB_ICONQUESTION|MB_YESNO) == IDYES)
d2552 1
a2552 1
							while(!selectedList.IsEmpty())
d2580 1
a2580 1
					if(selectedCount > 1)
d2592 2
a2593 2
					file->SetAutoPriority(false);
					file->SetPriority(PR_HIGH);
d2596 1
a2596 1
					if(selectedCount > 1)
d2608 2
a2609 2
					file->SetAutoPriority(false);
					file->SetPriority(PR_LOW);
d2612 1
a2612 1
					if(selectedCount > 1)
d2624 2
a2625 2
					file->SetAutoPriority(false);
					file->SetPriority(PR_NORMAL);
d2628 1
a2628 1
					if(selectedCount > 1)
d2640 2
a2641 2
					file->SetAutoPriority(true);
					file->SetPriority(PR_HIGH);
d2644 1
a2644 1
					if(selectedCount > 1)
d2655 1
a2655 1
					file->PauseFile();
d2658 1
a2658 1
					if(selectedCount > 1)
d2669 1
a2669 1
					file->ResumeFile();
d2672 1
a2672 1
					if(selectedCount > 1)
d2676 3
a2678 3
					file->LoadPartFile(file->GetTempDir(), file->GetPartMetFileName());
					if (file->GetStatus(true) == PS_READY)
						g_eMuleApp.m_pSharedFilesList->SafeAddKFile(file);
d2681 1
a2681 1
					if(selectedCount > 1)
d2685 2
a2686 2
					if(!file->IsLastBlockComplete())
						file->AllocateNeededSpace();
d2689 1
a2689 1
					if(selectedCount > 1)
d2702 2
a2703 2
					HideSources(file);
					file->StopFile();
d2711 6
a2716 5
					{
						CFileDetails dialog(GetResString(IDS_FD_TITLE), file, this, 0);
						dialog.DoModal();
						break;
					}
d2718 1
a2718 1
					if(selectedCount > 1)
d2730 1
a2730 1
					g_eMuleApp.CopyTextToClipboard(file->CreateED2kLink());
d2733 1
a2733 1
					if(selectedCount > 1)
d2745 1
a2745 1
					g_eMuleApp.CopyTextToClipboard(file->CreateHTMLED2kLink());
d2749 1
a2749 1
					if(selectedCount > 1)
d2753 1
a2753 1
					ShellOpenFile(file->GetFullName());
d2760 1
a2760 1
					if(selectedCount > 1)
d2764 1
a2764 1
					ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/report/index.php?link2="+file->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d2769 1
a2769 1
					if(selectedCount > 1)
d2773 1
a2773 1
					ShellExecute(NULL, NULL, "http://donkeyfakes.gambri.net/fakecheck/update/fakecheck.php?ed2k="+file->CreateED2kLink(), NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d2779 1
a2779 1
					if(selectedCount > 1)
d2783 1
a2783 1
					file->PreviewFile();
d2788 1
a2788 1
					CCommentDialogLst dialog(file); 
d2794 1
a2794 1
					CString dir = file->GetOutputDir();
d2802 1
a2802 1
						if(selectedCount > 1)
d2811 3
a2813 3
						file->SetAlternativeOutputDir(&newpath);
						file->SavePartFile();
						file->GetOutputDir(); //<<-- to add new path to shared list
d2831 1
a2831 1
						file->DownloadAllA4AF();
d2837 2
a2838 2
						if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == file)
							//curent file is A4AF auto => User want to switch it off
d2841 2
a2842 2
							//another file is A4AF auto => switch to new file
							g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(file);
d2854 1
a2854 1
					if (!(file->GetStatus()==PS_COMPLETE) && !(file->GetStatus()==PS_COMPLETING))
d2856 1
a2856 1
						if (file->GetMovieMode())
d2858 2
a2859 2
							file->SetMovieMode(0);
							file->SaveSettingsFile();
d2861 1
a2861 1
							if (file->IsAviMovie())
d2864 1
a2864 1
									file->SetMovieMode(1);
d2866 1
a2866 1
									file->SetMovieMode(2);
d2868 1
a2868 1
							else if (file->IsMpgMovie())
d2871 1
a2871 1
									file->SetMovieMode(4);
d2873 1
a2873 1
									file->SetMovieMode(5);
d2876 2
a2877 2
								file->SetMovieMode(0);
							file->SaveSettingsFile();
d2883 1
a2883 1
                // obaldin - make dropping supercompressed a per-file setting
d2899 2
a2900 1
					if(selectedCount > 1)
d2914 21
a2934 1
					g_eMuleApp.CopyTextToClipboard(file->CreateED2KSourceLink(7, 10));
d2936 1
d2939 1
d2942 2
a2943 1
			CUpDownClient* client = content->GetSource();
d2947 1
a2947 1
					client->RequestSharedFileList();
d2950 1
a2950 1
					g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(client);
d2953 1
a2953 1
					g_eMuleApp.m_pFriendList->AddFriend(client);
d2956 1
a2956 1
					g_eMuleApp.m_pFriendList->RemoveFriend(client);
d2960 2
a2961 1
					CClientDetails dialog(GetResString(IDS_CD_TITLE), client, this, 0);
d2967 3
a2969 2
					CPartFile *pFile = content->GetFile();
					client->SwapToAnotherFile(pFile);	//eklmn: bugfix(08): A4AF switching
d2974 1
a2974 1
		// cleanup multiselection
d2977 2
a2978 1
	else /*nothing selected*/
d3046 2
d3049 2
d3071 2
a3072 2
	if ( (pItem1->IsFile() && !pItem2->IsFile())
	  || (pItem2->IsFile() && !pItem1->IsFile()) )
d3080 1
a3080 1
		if (pItem1->IsFile())
d3088 2
a3089 2
				CPartFile	*pPartFile1 = pItem1->GetFile();
				CPartFile	*pPartFile2 = pItem2->GetFile();
d3097 1
a3097 1
			iCompare = Compare(pItem1->GetFile(), pItem2->GetFile(),0);
d3105 2
a3106 1
			if ((pItem1->IsAskedForAnotherFile() || pItem2->IsAskedForAnotherFile()) && lParamSort != DLCOL_FILENAME)
d3110 1
a3110 1
				if (pItem1->IsAskedForAnotherFile() && !pItem2->IsAskedForAnotherFile())
d3114 1
a3114 1
				if (pItem2->IsAskedForAnotherFile() && !pItem1->IsAskedForAnotherFile())
d3124 1
a3124 1
			iCompare = Compare(pItem1->GetSource(), pItem2->GetSource(), lParamSort, iSortMod);
d3138 1
a3138 1
	for (MuleIter it = m_mapItems.begin(); it != m_mapItems.end();)
d3140 1
a3140 1
		CMuleCtrlItem		*cur_item = it->second;
d3142 2
a3143 2
		it++; // Already point to the next iterator. 
		if (cur_item->IsFile())
d3145 1
a3145 1
			CPartFile		*pPartFile = cur_item->GetFile();
d3157 1
a3157 1
//SyruS clear single completed files
d3165 1
a3165 1
	for (MuleIter itItem = m_mapItems.begin(); itItem != m_mapItems.end(); )
d3167 1
a3167 1
		CMuleCtrlItem	*pItem = itItem->second;
d3169 2
a3170 2
		itItem++; // Already point to the next iterator
		if (pItem->IsFile())
d3172 1
a3172 1
			CPartFile	*pFile = pItem->GetFile();
d3174 1
a3174 1
			if (!pFile->IsPartFile())
d3178 1
a3178 1
					completedFilesList.Add(pFile); 
d3180 1
a3180 1
				else if (md4cmp(pFileHash, pFile->GetFileHash()) == 0) 
d3182 1
a3182 1
					RemoveFile(pFile);
d3210 1
a3210 1
void CDownloadListCtrl::SortInit(int override) // Cax2 sortdlg
d3805 4
a3808 4
				CMuleCtrlItem *pListItem = (CMuleCtrlItem*)GetItemData(index);
			if(!pListItem)
				return;
				if(!pListItem->IsFile())			// if it isn't a file we're done
d3892 2
a3893 1
	int iSel = GetSelectionMark();
d3896 3
a3898 1
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
d3900 1
a3900 1
		if (content->IsFile())		//Cax2: doubleclick opens completed files
d3902 3
a3904 2
			CPartFile* file = content->GetFile();
			if(file->GetStatus()==PS_COMPLETE)
d3906 5
a3910 4
				CString buffer;
				buffer.Format(_T("%s\\%s"),file->GetPath(),file->GetFileName());
				AddLogLine(false, _T("%s\\%s"),file->GetPath(),file->GetFileName());
				ShellOpenFile(buffer);
d3913 1
a3913 1
		else	//client  options
d3915 2
a3916 1
			CUpDownClient* client = content->GetSource();
d3919 2
a3920 1
				CClientDetails dialog(GetResString(IDS_CD_TITLE), client, this, 0);
d3925 1
a3925 1
				g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(client);
d3951 4
a3954 3
	CTypedPtrList<CPtrList, CPartFile*> selectedList; 
	int count = GetItemCount(); 
	POSITION pos; 
d3956 8
a3963 5
	// Vorlost get initial sources from server if we dont have our MaxSourcesPerFile Limit reached 
	for(int i = 0; i != count; i++)
	{ 
		if(((CMuleCtrlItem*)GetItemData(i))->IsFile() 
			&& ((CMuleCtrlItem*)GetItemData(i))->GetFile()->GetSourceCount() <= g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()) 
d3965 1
a3965 1
			selectedList.AddTail(((CMuleCtrlItem*)GetItemData(i))->GetFile());
d3969 1
a3969 1
	count = selectedList.GetCount(); 
d3971 1
a3971 1
	for (pos = selectedList.GetHeadPosition() ; pos != 0 ; selectedList.GetNext(pos)) 
d3995 1
a3995 1
	for (MuleIter itItem = m_mapItems.begin(); itItem != m_mapItems.end(); itItem++)
d3997 1
a3997 1
		CMuleCtrlItem		*pItem = itItem->second;
d3999 1
a3999 1
		if (pItem->IsFile())
d4001 4
a4004 26
			if (!pItem->m_bSrcsAreVisible || !pItem->m_bShowOnlySrcsUploading)
			{
#ifdef LATER
			//	Go through the whole list to find out the sources for this file
				for (MuleIter itItem2 = m_mapItems.begin(); itItem2 != m_mapItems.end(); itItem2++)
				{
					const CMuleCtrlItem		*pItem2 = itItem2->second;

					if (pItem2->IsSource() && pItem2->GetFile() == pItem->GetFile())
					{
						EnumDLQState	ds = pItem2->GetSource()->GetDownloadState();

						if (!( pItem->m_bShowOnlySrcsUploading && ds==DS_DOWNLOADING && !pItem2->IsAskedForAnotherFile()))
						{
							continue; // skip this source
						}
					}
					iNumAdded++;
					InsertItem(LVIF_PARAM|LVIF_TEXT,iItem+1,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)pItem2);
				}
#endif LATER
			}
			pItem->m_bSrcsAreVisible = true;
			pItem->m_bShowOnlySrcsUploading = true;
			pItem->m_bShowOnlySrcsAllowingUsInUploadQueue = false;
			pItem->m_bShowOnlySrcsWithNeededParts = false;
d4019 3
a4021 1
	CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark()); 
d4023 1
a4023 1
	if (content->IsFile())
d4025 1
a4025 1
		CPartFile* file = content->GetFile();
d4034 1
a4034 1
		else if (nChar == 'A' && content->IsFile())
a4035 1
			CPartFile* pPartFile = content->GetFile();
d4038 1
a4038 1
		else if (nChar == 'C' && content->IsFile())
a4039 1
			CPartFile* pPartFile = content->GetFile();
d4043 1
a4043 1
		else if (nChar == 'E' && content->IsFile())
a4044 1
			CPartFile* pPartFile = content->GetFile();
d4047 1
a4047 1
		else if (nChar == 'P' && content->IsFile())
a4048 1
			CPartFile* pPartFile = content->GetFile();
d4054 1
a4054 1
		else if (nChar == 'R' && content->IsFile())
d4056 2
a4057 2
			CPartFile* pPartFile = content->GetFile();
			CFileDetails dialog(GetResString(IDS_FD_TITLE), pPartFile, this, 0);
d4061 1
a4061 1
		else if (nChar == 'S' && content->IsFile())
a4062 1
			CPartFile* pPartFile = content->GetFile();
d4079 3
a4081 2
	POSITION pos = GetFirstSelectedItemPosition();
	if(pos == NULL)
d4088 12
a4099 2
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
		if (content != NULL)
d4101 5
a4105 13
			if (content->IsFile())
			{
				const CPartFile* file = content->GetFile();
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile((CPartFile*)file);
			    g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
			} 
			else 
			{
				const CUpDownClient* client = content->GetSource();
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser((CUpDownClient*)client);
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
			}	
		}
d4111 1
a4113 20
	uint16	count=0;
	CString counter;
	CMuleCtrlItem	*pCurItem;

	for (MuleIter it = m_mapItems.begin(); it != m_mapItems.end(); it++)
	{
		pCurItem = it->second;
		if (pCurItem->IsFile())
		{
			CPartFile		*file=pCurItem->GetFile();

			if (CCat::FileBelongsToGivenCat(file,m_iCurTabCat))
			{
				++count;
			}
		}
	}

//	counter.Format("%s (%u)", GetResString(IDS_TW_DOWNLOADS),count);
//	g_eMuleApp.m_pdlgEmule->m_wndTransfer.GetDlgItem(IDC_DOWNLOAD_TEXT)->SetWindowText(counter);
d4117 1
a4117 1
CString CDownloadListCtrl::getTextList() 
d4121 2
a4122 2
	CString out=_T("");
	CString temp,temp2;
d4124 2
a4125 2
	// Search for file(s)
	for(MuleIter g = m_mapItems.begin(); g != m_mapItems.end(); g++)
d4127 3
a4129 2
		CMuleCtrlItem* pItem = g->second;
		if (pItem->IsFile())
d4131 1
a4131 1
			CPartFile* file = pItem->GetFile();
d4133 3
a4135 3
			AddLogLine(false,file->GetFileName());
			temp2 = file->GetFileName(); 
			if (temp2.GetLength()>50) 
d4137 1
a4137 1
				temp2=temp2.Mid(0,50);
d4139 7
a4145 7
			temp.Format(_T("\n%s\t [%.1f%%] %i/%i - %s"),
							temp2,
							file->GetPercentCompleted(),
							file->GetTransferringSrcCount(),
							file->GetSourceCount(), 
							file->GetPartfileStatus());
			out = out + temp;
d4148 1
a4148 1
	AddLogLine(false,out);
d4150 1
a4150 1
	return out;
d4157 1
a4157 1
bool CDownloadListCtrl::GetDisplayedFiles(CArray<CPartFile*,CPartFile*> *list)
d4161 1
a4161 1
	for(MuleIter g = m_mapItems.begin(); g != m_mapItems.end(); g++)
d4163 3
a4165 2
		CMuleCtrlItem* pItem = g->second;
		if(pItem->IsFile())
d4167 3
a4169 2
			CPartFile* file = pItem->GetFile();
			list->Add(file);
d4199 3
a4201 1
	CMuleCtrlItem		*pContentItem = reinterpret_cast<CMuleCtrlItem*>(this->GetItemData(GetSelectionMark()));
d4203 1
a4203 1
	if (pContentItem->IsFile())
d4205 1
a4205 1
		CPartFile		*pPartFile = pContentItem->GetFile();
d4219 1
a4219 1
	else
d4221 1
a4221 1
		CUpDownClient		*pSource = pContentItem->GetSource();
d4250 2
a4251 2
	//	Remove all displayed files with a different cat and show the correct ones
	for(MuleIter it = m_mapItems.begin(); it != m_mapItems.end(); it++)
d4253 1
a4253 1
		CMuleCtrlItem		*pItem = it->second;
d4255 1
a4255 1
		if (pItem->IsFile())
d4257 1
a4257 1
			CPartFile	*file = pItem->GetFile();
d4259 2
a4260 2
			if (!CCat::FileBelongsToGivenCat(file,m_iCurTabCat))
				HideFile(file);
d4262 1
a4262 2
				ShowFile(file);

d4273 1
a4273 1
	MuleRange		rangeIt = m_mapItems.equal_range(pSource);
d4275 1
a4275 1
	for (MuleIter it = rangeIt.first; it != rangeIt.second; it++)
d4277 1
a4277 7
		CMuleCtrlItem		*updateItem  = it->second;

		// Find entry in CListCtrl and update object
 		LVFINDINFO		find;

		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)updateItem;
d4279 2
a4280 1
		sint16		result = FindItem(&find);
d4282 1
a4282 1
		if (result != (-1))
d4284 2
a4285 1
			DeleteItem(result);
d4291 1
a4291 1
void CDownloadListCtrl::HideFile(CPartFile* tohide)
d4295 1
a4295 1
	HideSources(tohide);
d4297 2
a4298 2
	// Retrieve all entries matching the source
	MuleRange		rangeIt = m_mapItems.equal_range(tohide);
d4300 1
a4300 1
	for (MuleIter it = rangeIt.first; it != rangeIt.second; it++)
d4302 2
a4303 1
		CMuleCtrlItem		*updateItem  = it->second;
d4305 1
a4305 7
		// Find entry in CListCtrl and update object
 		LVFINDINFO find;

		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)updateItem;
		sint16 result = FindItem(&find);
		if (result != -1) 
d4307 2
a4308 2
			DeleteItem(result);
			return;
d4315 1
a4315 1
void CDownloadListCtrl::ShowFile(CPartFile *pPartFileToShow)
d4319 2
a4320 2
	// Retrieve all entries matching the source
	MuleRange		rangeIt = m_mapItems.equal_range(pPartFileToShow);
d4322 1
a4322 1
	for (MuleIter it = rangeIt.first; it != rangeIt.second; it++)
d4324 2
a4325 4
		CMuleCtrlItem		*updateItem  = it->second;

		// Check if entry is already in the List
 		LVFINDINFO find;
d4327 1
a4327 5
		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)updateItem;
		sint16 result = FindItem(&find);

		if (result == (-1))
d4329 1
a4329 1
			InsertItem(LVIF_PARAM|LVIF_TEXT,GetItemCount(),LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)updateItem);
a4330 2

		return;
d4336 1
a4336 1
void CDownloadListCtrl::ShowSource(CUpDownClient* pSource)
d4341 1
a4341 1
	MuleRange		rangeIt = m_mapItems.equal_range(pSource);
d4343 1
a4343 1
	for (MuleIter it = rangeIt.first; it != rangeIt.second; it++)
d4345 2
a4346 1
		CMuleCtrlItem		*updateItem  = it->second;
d4348 2
a4349 9
	//	Check if entry is already in the List
 		LVFINDINFO		find;

		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)updateItem;

		sint16		result = FindItem(&find);

		if (result == (-1))
d4351 4
a4354 3
		//	Find the part file item we want to add it to
			CMuleCtrlItem	*pParent = NULL;
			MuleIter		g = m_mapItems.find(updateItem->GetFile());
d4356 5
a4360 2
		//	If it doesn't exist...
			if (g != m_mapItems.end())
d4362 1
a4362 1
				pParent = g->second;
d4364 1
a4364 15
		//
		//	Find the position of the next file item or the end of the list
		//
			LVFINDINFO		find;

			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)pParent;

			int		nItem = FindItem(&find);

			if (nItem < 0)
				nItem = 0;
			while (GetItemCount() > nItem+1 && !((CMuleCtrlItem*)GetItemData(nItem+1))->IsFile())
				nItem++;
			InsertItem(LVIF_PARAM|LVIF_TEXT,nItem+1,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)updateItem);
d4369 1
d4397 2
d4400 3
a4402 2
        if (pItem != NULL && pItem->GetFile() != NULL){
			if (pItem->IsFile())
d4404 11
a4414 13
				switch (pDispInfo->item.iSubItem)
				{
					case 0:
						if (pDispInfo->item.cchTextMax > 0){
							_tcsncpy(pDispInfo->item.pszText, pItem->GetFile()->GetFileName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
						}
						break;
					default:
						// shouldn't happen
						pDispInfo->item.pszText[0] = _T('\0');
						break;
				}
d4416 4
a4419 1
			else if (pItem->IsSource())
d4421 11
a4431 14
				switch (pDispInfo->item.iSubItem)
				{
					case 0:
						if (pItem->GetSource()->GetUserName() != "" && pDispInfo->item.cchTextMax > 0)
						{
							_tcsncpy(pDispInfo->item.pszText, pItem->GetSource()->GetUserName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
						}
						break;
					default:
						// shouldn't happen
						pDispInfo->item.pszText[0] = _T('\0');
						break;
				}
d4433 5
a4437 3
			else
				ASSERT(0);
        }
d4443 108
@


1.281
log
@Modified ClearCompleted() to take a category ID instead of a boolean, allowing the GUI category to be overridden.
@
text
@d3062 1
a3062 1
void CDownloadListCtrl::ClearCompleted(uint8 iCategoryID/* = CAT_UNCATEGORIZED*/)
d3075 1
a3075 1
			  && ( CCat::FileBelongsToGivenCat(pPartFile,iCategoryID == CAT_UNCATEGORIZED ? m_iCurTabCat : iCategoryID)
@


1.280
log
@Removed old details code, added more keyboard shortcuts (now with only Ctrl instead of all three keys)
@
text
@d3062 1
a3062 1
void CDownloadListCtrl::ClearCompleted(bool bIgnoreCats/* = false*/)
d3074 3
a3076 1
			if (pPartFile->IsPartFile() == false && (CCat::FileBelongsToGivenCat(pPartFile,m_iCurTabCat) || bIgnoreCats) )
@


1.279
log
@Separated CMuleCtrlItem out of DownloadListCtrl files.
@
text
@a26 1
#ifdef _USE_NEW_DETAILS_
a28 4
#else
#include "ClientDetailDialog.h"
#include "FileDetailDialog.h"
#endif
a2671 1
					#ifdef _USE_NEW_DETAILS_	
a2672 3
					#else
						CFileDetailDialog dialog(file);
					#endif
a2894 1
				#ifdef _USE_NEW_DETAILS_
a2895 3
				#else
					CClientDetailDialog dialog(client);
				#endif
a3837 1
			#if _USE_NEW_DETAILS_
a3838 3
			#else
				CClientDetailDialog dialog(client);
			#endif
d3955 8
a3962 1
	if (isShift && isCtrl && isAlt)
d3968 1
a3968 1
		else if (nChar == 'R')
d3970 36
a4005 14
			CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark()); 
			if (content->IsFile())
			{
				CPartFile* file = content->GetFile();

				#ifdef _USE_NEW_DETAILS_	
					CFileDetails dialog(GetResString(IDS_FD_TITLE), file, this, 0);
					dialog.SetActivePage(2);
					dialog.DoModal();
				#else
					CFileDetailDialog dialog(file);
					dialog.DoModal();
				#endif
			}
a4164 1
		#ifdef _USE_NEW_DETAILS_	
a4165 3
		#else
			CFileDetailDialog	dialog(pPartFile);
		#endif
a4166 1
//			dialog.DoModal();
a4171 1
	#if _USE_NEW_DETAILS_
a4172 3
	#else
		CClientDetailDialog	dialog(pSource);
	#endif
@


1.278
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@a41 9
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CMuleCtrlItem::IsAskedForAnotherFile() const
{
	return (m_pSource ? (m_pSource->reqfile != m_pFile) : false); 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

@


1.277
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d2184 36
@


1.276
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@a34 1
#include "memcpy_amd.h"
@


1.275
log
@Fixed a problem with rating icon and removed old code not used anymore
@
text
@d736 4
a739 5
				iIcon = ((pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0) && 
						!(pPartFile->GetStatus() == PS_COMPLETING || pPartFile->GetStatus() == PS_COMPLETE))
						? ( lpFileItem->m_bSrcsAreVisible
						? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
						: DL_ICON_LISTNONE;
d2700 2
a2701 1
  				case MP_FAKE_REPORT:{ 
d2709 2
a2710 1
 				case MP_FAKE_CHECK:{ 
@


1.274
log
@Minor fix (grrr)
@
text
@a81 1
	m_bDblClicked = false;
d1599 2
a1600 8
								//if(bNeverAskedBefore)
								//{
									crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
									buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nRemoteQueueRank-nDifference));
								/*} else {
									crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,255));
									buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nRemoteQueueRank-nDifference));
								}*/
a1622 1
							//buffer="";
a1628 1
				//	buffer="";
a2180 2

		m_bDblClicked = false;
d3737 2
a3738 1
					if((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_bDblClicked)
d3740 1
d3743 1
a3743 2
						if (!m_bDblClicked)
							ClearCompleted(pPartFile->GetFileHash());
d3767 1
d3769 2
a3770 2
				rRating.left += OFFSET_STATUSICON + 2;
			rRating.left = 2 + OFFSET_PLUSMINUS + 2;
d3773 1
a3773 1
			rRating.top = 2;
a3838 1
	m_bDblClicked=true;
@


1.273
log
@Reinstated ShowFileStatusIcons
@
text
@a734 15
				else
				{
					iIcon = DL_ICON_LISTNONE;

					iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0)
							? ( lpFileItem->m_bSrcsAreVisible
							? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
							: DL_ICON_LISTNONE;

					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_PLUSMINUS;
					r.left += OFFSET_PLUSMINUS;
				}
d737 2
a738 2
				iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0 || 
						!(pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE))
@


1.272
log
@Updates
@
text
@d712 1
a712 2
			//	Draw the status icon
				switch (pPartFile->GetPartfileStatusID())
d714 20
a733 10
					case PS_COMPLETING:			iIcon = DL_ICON_STATUS_COMPLETING; break;
					case PS_COMPLETE:			iIcon = DL_ICON_STATUS_COMPLETE; break;
					case PS_DOWNLOADING:		iIcon = DL_ICON_STATUS_DOWNLOADING; break;
					case PS_WAITINGFORSOURCE:	iIcon = DL_ICON_STATUS_WAITING; break;
					case PS_HASHING:			iIcon = DL_ICON_STATUS_HASHING; break;
					case PS_PAUSED:				iIcon = DL_ICON_STATUS_PAUSED; break;
					case PS_STALLED:			iIcon = DL_ICON_STATUS_STALLED; break;
					case PS_STOPPED:			iIcon = DL_ICON_STATUS_STOPPED; break;
					case PS_ERROR:				iIcon = DL_ICON_STATUS_ERRONEOUS; break;
					default:					iIcon = DL_ICON_STATUS_ERRONEOUS;
a734 2
				if (!bMeasuring)
					m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d736 14
a749 3
					iWidth += OFFSET_STATUSICON;
				r.left += OFFSET_STATUSICON;
				ipoint.x += OFFSET_STATUSICON;
d1388 2
a1389 1
				cur_rec.left += OFFSET_STATUSICON;
d3748 28
a3775 25
		// File Status
			CRect rFileStatus(r);
			rFileStatus.left += 2;
			rFileStatus.top += 2;
			rFileStatus.right = rFileStatus.left + 16;
			rFileStatus.bottom = rFileStatus.top + 16;
			if(rFileStatus.PtInRect(pt))
			{
				CPartFile *pPartFile = pListItem->GetFile();

				if (pPartFile == NULL)
					return;

				if((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_bDblClicked)
					pPartFile->ResumeFile();
				else if (pPartFile->GetStatus() == PS_COMPLETE)
				{
					if (!m_bDblClicked)
						ClearCompleted(pPartFile->GetFileHash());
				}
				else if (pPartFile->GetStatus() == PS_ERROR)
				{
					pPartFile->LoadPartFile(pPartFile->GetTempDir(), pPartFile->GetPartMetFileName());
					if (pPartFile->GetStatus(true) == PS_READY)
						g_eMuleApp.m_pSharedFilesList->SafeAddKFile(pPartFile);
d3781 3
a3783 1
			rPlusMinus.left += OFFSET_STATUSICON + 2;
d3792 3
a3794 1
			rRating.left = 2 + OFFSET_STATUSICON + 2 + OFFSET_PLUSMINUS + 2;
@


1.271
log
@FakeCheck for Search Result and Download List (Check and Report ... made by milobac ... merged by DropF ... tested by n@@boleo and me)
@
text
@d2240 35
a2274 2
			m_ed2kMenu.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK)); //<<-- enkeyDEV(Ottavio84) -Create source ed2k from downloads-
		
a2334 4
			if(justOne && !file->IsLastBlockComplete())
				if (!file->IsPreallocated())
					m_menuFile.AppendMenu(MF_STRING,MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE));

a2355 36
			m_menuFile.AppendMenu(MF_STRING,MP_CHANGEDIR, GetResString(IDS_CHANGEDIR)); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
			m_menuFile.EnableMenuItem(MP_CHANGEDIR, !filedone ? MF_ENABLED:MF_GRAYED); //<<-- enkeyDEV(Ottavio84) -ChangeDir-

			//SyruS: cleanup
			m_menuFile.AppendMenu(MF_STRING,MP_DOCLEANUP, GetResString(IDS_DOCLEANUP));
			m_menuFile.EnableMenuItem(MP_DOCLEANUP, !filedone ? MF_ENABLED:MF_GRAYED);

			m_menuFile.AppendMenu(MF_SEPARATOR);

			//Fakecheck
			m_menuFile.AppendMenu(MF_STRING,MP_FAKE_CHECK,GetResString(IDS_FAKE_CHECK));
			m_menuFile.AppendMenu(MF_STRING,MP_FAKE_REPORT,GetResString(IDS_FAKE_REPORT));
			m_menuFile.AppendMenu(MF_SEPARATOR);

			m_menuFile.AppendMenu(MF_STRING,MP_DROPNONEEDEDSRCS, GetResString(IDS_DROPNONEEDEDSRCS)); // Tarod
			m_menuFile.EnableMenuItem(MP_DROPNONEEDEDSRCS,((status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED)); // Added by Tarod	// netwolf 07.05.03

			m_menuFile.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED));
			m_menuFile.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, file->GetDiscardSuperCompressed() ? MF_CHECKED:MF_UNCHECKED);
			m_menuFile.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, ((status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));	//netwolf: no dropSCB on complete/ing) files

			m_menuFile.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE)); // Tarod
			m_menuFile.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(justOne && status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED); // Tarod(+Cax2 Patch 21/12/02)	//netwolf 07.05.03

			CString buffer;
			buffer.Format(_T("%s (%s)"), GetResString(IDS_ALL_A4AF_TO_HERE), GetResString(IDS_PRIOAUTO));
			m_menuFile.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,buffer); // Tarod
			if (justOne && status != PS_COMPLETE && status != PS_COMPLETING) // Cax2	// netwolf 07.05.03
			{
				m_menuFile.CheckMenuItem(MP_ALL_A4AF_AUTO, (file== g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile()) ? MF_CHECKED:MF_UNCHECKED); // Tarod
				m_menuFile.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_ENABLED);
			} else {
				m_menuFile.CheckMenuItem(MP_ALL_A4AF_AUTO, MF_UNCHECKED);
				m_menuFile.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_GRAYED);
			}

d2358 1
a2359 1

d2366 1
a2710 3
						while(!selectedList.IsEmpty()) { 
							selectedList.RemoveHead(); 
						}
a2718 7
						//CString str;
						while(!selectedList.IsEmpty()) { 
							//str += theApp.CreateED2kLink(selectedList.GetHead()) + "\n"; 
							selectedList.RemoveHead(); 
						}
						//theApp.CopyTextToClipboard(str);
						//AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
a2720 1
					//theApp.CopyTextToClipboard(theApp.CreateED2kLink(file));
@


1.270
log
@Removed KB/s from speed columns (we already know that and some people don't like it).
@
text
@d2336 5
d2344 1
a2344 1
            m_menuFile.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED));
d2712 30
@


1.269
log
@Removed KB/s from speed columns (we already know that and some people don't like it)
@
text
@d1373 2
@


1.268
log
@Fix (removed old code)
@
text
@d133 1
a133 5

	CString		strSpeed;

	strSpeed.Format(_T("%s (%s)"),GetResString(IDS_DL_SPEED),GetResString(IDS_KBYTESEC));
	InsertColumn(DLCOL_SPEED,strSpeed,LVCFMT_RIGHT, 65);
a138 1

d152 1
a152 5

	CString		strAvgSpeed;

	strAvgSpeed.Format(_T("%s (%s)"),GetResString(IDS_DLCOL_AVGSPEED),GetResString(IDS_KBYTESEC));
	InsertColumn(DLCOL_AVGSPEED,strAvgSpeed,LVCFMT_RIGHT,100);
d252 1
a252 3
		CString	strSpeed;
		strSpeed.Format(_T("%s (%s)"),GetResString(IDS_DL_SPEED),GetResString(IDS_KBYTESEC));
		strRes = strSpeed;
d277 1
a277 1
		strRes = GetResString(IDS_DL_REMAINS);	// netwolf 14.05.03
a286 1
		// Maverick
@


1.267
log
@Retro-fitted "columns won't expand" bug fix from upload panel.
@
text
@d724 2
a725 1
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d727 10
a736 31
				//	Draw the status icon
					switch (pPartFile->GetPartfileStatusID())
					{
						case PS_COMPLETING:			iIcon = DL_ICON_STATUS_COMPLETING; break;
						case PS_COMPLETE:			iIcon = DL_ICON_STATUS_COMPLETE; break;
						case PS_DOWNLOADING:		iIcon = DL_ICON_STATUS_DOWNLOADING; break;
						case PS_WAITINGFORSOURCE:	iIcon = DL_ICON_STATUS_WAITING; break;
						case PS_HASHING:			iIcon = DL_ICON_STATUS_HASHING; break;
						case PS_PAUSED:				iIcon = DL_ICON_STATUS_PAUSED; break;
						case PS_STALLED:			iIcon = DL_ICON_STATUS_STALLED; break;
						case PS_STOPPED:			iIcon = DL_ICON_STATUS_STOPPED; break;
						case PS_ERROR:				iIcon = DL_ICON_STATUS_ERRONEOUS; break;
						default:					iIcon = DL_ICON_STATUS_ERRONEOUS;
					}
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_STATUSICON;
					r.left += OFFSET_STATUSICON;
					ipoint.x += OFFSET_STATUSICON;

				//	Draw the old-style +/- box
					iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0)
							? ( lpFileItem->m_bSrcsAreVisible
							? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
							: DL_ICON_LISTNONE;
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_PLUSMINUS;
					r.left += OFFSET_PLUSMINUS;
d738 2
d741 15
a755 20
				{
					iIcon = DL_ICON_LISTNONE;

					if (pPartFile->GetStatus()==PS_COMPLETE)
						iIcon = DL_ICON_LISTCOMPLETE;
					else if (pPartFile->GetStatus()==PS_STOPPED)
						iIcon = DL_ICON_LISTSTOPPED;
					else if (pPartFile->GetStatus()==PS_PAUSED)
						iIcon = DL_ICON_LISTPAUSED;
					else
						iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0)
								? ( lpFileItem->m_bSrcsAreVisible
								? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
								: DL_ICON_LISTNONE;
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_PLUSMINUS;
					r.left += OFFSET_PLUSMINUS;
				}
d1382 1
a1382 2
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
					cur_rec.left += OFFSET_STATUSICON;
@


1.266
log
@Removed option to disable File Status icons
Added old actions to new File Status icons
Removed spamming log from Source Saver
Removed old non used icons from resources
Updated +/- icons with Psy suggestion
@
text
@d695 10
a704 1
	UINT	iCalcFlag = bMeasuring ? DT_CALCRECT : 0;
d724 1
a724 2
			//	Draw the status icon
				switch (pPartFile->GetPartfileStatusID())
d726 31
a756 10
					case PS_COMPLETING:			iIcon = DL_ICON_STATUS_COMPLETING; break;
					case PS_COMPLETE:			iIcon = DL_ICON_STATUS_COMPLETE; break;
					case PS_DOWNLOADING:		iIcon = DL_ICON_STATUS_DOWNLOADING; break;
					case PS_WAITINGFORSOURCE:	iIcon = DL_ICON_STATUS_WAITING; break;
					case PS_HASHING:			iIcon = DL_ICON_STATUS_HASHING; break;
					case PS_PAUSED:				iIcon = DL_ICON_STATUS_PAUSED; break;
					case PS_STALLED:			iIcon = DL_ICON_STATUS_STALLED; break;
					case PS_STOPPED:			iIcon = DL_ICON_STATUS_STOPPED; break;
					case PS_ERROR:				iIcon = DL_ICON_STATUS_ERRONEOUS; break;
					default:					iIcon = DL_ICON_STATUS_ERRONEOUS;
a757 2
				if (!bMeasuring)
					m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d759 20
a778 15
					iWidth += OFFSET_STATUSICON;
				r.left += OFFSET_STATUSICON;
				ipoint.x += OFFSET_STATUSICON;

			//	Draw the old-style +/- box
				iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0 || 
						!(pPartFile->GetStatus() != PS_COMPLETING && pPartFile->GetStatus() != PS_COMPLETE))
						? ( lpFileItem->m_bSrcsAreVisible
						? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
						: DL_ICON_LISTNONE;
				if (!bMeasuring)
					m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
				else
					iWidth += OFFSET_PLUSMINUS;
				r.left += OFFSET_PLUSMINUS;
d895 1
a895 1
				dc->DrawText(pPartFile->GetFileName(), (int)_tcslen(pPartFile->GetFileName()),&r, DLC_DT_TEXT | iCalcFlag);
d908 1
a908 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d916 1
a916 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d924 1
a924 1
			    dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d947 1
a947 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1031 1
a1031 1
				dc->DrawText(buffer,(int)_tcslen(buffer),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1045 1
a1045 1
							dc->DrawText(GetResString(IDS_PRIOAUTOLOW),GetResString(IDS_PRIOAUTOLOW).GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1048 1
a1048 1
							dc->DrawText(GetResString(IDS_PRIOAUTONORMAL),GetResString(IDS_PRIOAUTONORMAL).GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1051 1
a1051 1
							dc->DrawText(GetResString(IDS_PRIOAUTOHIGH),GetResString(IDS_PRIOAUTOHIGH).GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1060 1
a1060 1
							dc->DrawText(GetResString(IDS_PRIOLOW),GetResString(IDS_PRIOLOW).GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1063 1
a1063 1
							dc->DrawText(GetResString(IDS_PRIONORMAL),GetResString(IDS_PRIONORMAL).GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1066 1
a1066 1
							dc->DrawText(GetResString(IDS_PRIOHIGH),GetResString(IDS_PRIOHIGH).GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1077 1
a1077 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1096 1
a1096 1
					dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1104 1
a1104 1
					dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1110 1
a1110 1
					dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1132 1
a1132 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1159 1
a1159 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1171 1
a1171 1
				dc->DrawText(buffer,(int)_tcslen(buffer),&r, DLC_DT_TEXT | iCalcFlag);
d1181 1
a1181 1
					dc->DrawText(buffer,(int)_tcslen(buffer),&r, DLC_DT_TEXT | iCalcFlag);
d1192 1
a1192 1
					dc->DrawText(odtTime.Format(), &r, DLC_DT_TEXT | iCalcFlag);
d1218 1
a1218 1
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | iCalcFlag);
d1232 1
a1232 1
				dc->DrawText(buffer,(int)_tcslen(buffer),&r, DLC_DT_TEXT | iCalcFlag);
d1249 1
a1249 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1264 1
a1264 1
				dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1289 1
a1289 1
						dc->DrawText(odtTime.Format(), &r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1296 1
a1296 1
					dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1320 1
a1320 1
						dc->DrawText(odtTime.Format(), &r, DLC_DT_TEXT | DT_RIGHT | iCalcFlag);
d1327 1
a1327 1
					dc->DrawText(buffer,buffer.GetLength(),&r, DLC_DT_TEXT | iCalcFlag);
d1337 1
a1337 1
			if (iWidth < 40)
d1405 2
a1406 1
				cur_rec.left += OFFSET_STATUSICON;
d2948 8
a2955 1
	SetColumnWidth(iColumn,m_iColumnMaxWidths[iColumn]);
d3962 1
a3962 6
		if (nChar == 'M')
		{
			g_eMuleApp.m_pGlobPrefs->SetShowPausedGray(!g_eMuleApp.m_pGlobPrefs->ShowPausedGray());
			Invalidate();
		}
		else if (nChar == 'U')
@


1.265
log
@Added SHIFT+CTRL+ALT+R to call Source Names dialog
@
text
@d168 27
a194 30
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));					// 0
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));				// 1
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));				// 2
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  		// 3
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_DOWNESTIMATED),16,16));	// 4
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));			// 5
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));		 	// 6
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPAUSED),16,16));        		// 7
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));         			// 8
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));	        		// 9
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));		      		// 10
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));			  		// 11
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));         			// 12
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  			// 13
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  			// 14
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  			// 15
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));				// 16
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));		// 17
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));			// 18
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));	  		// 19
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));			// 20
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));	  		// 21
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  				// 22
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  				// 23
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  				// 24
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));	  			// 25
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTCOMPLETE),16,16));  			// 26
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTSTOPPED),16,16));  			// 27
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  			// 28
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_A4AFAUTO),16,16));				// 29
d715 2
a716 1
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d718 10
a727 31
				//	Draw the status icon
					switch (pPartFile->GetPartfileStatusID())
					{
						case PS_COMPLETING:			iIcon = DL_ICON_STATUS_COMPLETING; break;
						case PS_COMPLETE:			iIcon = DL_ICON_STATUS_COMPLETE; break;
						case PS_DOWNLOADING:		iIcon = DL_ICON_STATUS_DOWNLOADING; break;
						case PS_WAITINGFORSOURCE:	iIcon = DL_ICON_STATUS_WAITING; break;
						case PS_HASHING:			iIcon = DL_ICON_STATUS_HASHING; break;
						case PS_PAUSED:				iIcon = DL_ICON_STATUS_PAUSED; break;
						case PS_STALLED:			iIcon = DL_ICON_STATUS_STALLED; break;
						case PS_STOPPED:			iIcon = DL_ICON_STATUS_STOPPED; break;
						case PS_ERROR:				iIcon = DL_ICON_STATUS_ERRONEOUS; break;
						default:					iIcon = DL_ICON_STATUS_ERRONEOUS;
					}
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_STATUSICON;
					r.left += OFFSET_STATUSICON;
					ipoint.x += OFFSET_STATUSICON;

				//	Draw the old-style +/- box
					iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0)
							? ( lpFileItem->m_bSrcsAreVisible
							? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
							: DL_ICON_LISTNONE;
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_PLUSMINUS;
					r.left += OFFSET_PLUSMINUS;
d729 2
d732 15
a746 20
				{
					iIcon = DL_ICON_LISTNONE;

					if (pPartFile->GetStatus()==PS_COMPLETE)
						iIcon = DL_ICON_LISTCOMPLETE;
					else if (pPartFile->GetStatus()==PS_STOPPED)
						iIcon = DL_ICON_LISTSTOPPED;
					else if (pPartFile->GetStatus()==PS_PAUSED)
						iIcon = DL_ICON_LISTPAUSED;
					else
						iIcon = (pPartFile->GetSourceCount() > 0 || pPartFile->GetSrcA4AFCount() > 0)
								? ( lpFileItem->m_bSrcsAreVisible
								? DL_ICON_LISTMINUS : DL_ICON_LISTPLUS )
								: DL_ICON_LISTNONE;
					if (!bMeasuring)
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					else
						iWidth += OFFSET_PLUSMINUS;
					r.left += OFFSET_PLUSMINUS;
				}
d1373 1
a1373 2
				if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
					cur_rec.left += OFFSET_STATUSICON;
d1437 1
a1437 1
							    m_imageList.Draw(dc, 28, point2, ILD_NORMAL);
a2121 7
		if((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_bDblClicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
			pPartFile->ResumeFile();
		else if (pPartFile->GetStatus() == PS_COMPLETE)
		{
			if (!m_bDblClicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
				ClearCompleted(pPartFile->GetFileHash());
		}
d2123 1
a2123 1
		else if (pItem->m_bSrcsAreVisible == false && pPartFile->GetStatus() != PS_COMPLETING) 
d3705 7
a3711 4
		// [+]/[-]	
			CRect rPlusMinus(r);
			rPlusMinus.left += 4 + 4;			// eeek, hardcoded values
			if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d3713 18
a3730 1
				rPlusMinus.left += OFFSET_STATUSICON;
d3732 7
a3738 3
			rPlusMinus.top += 1 + 2;						//  --||--
			rPlusMinus.right = rPlusMinus.left + 16 - 4;	//  --||--
			rPlusMinus.bottom = rPlusMinus.top + 16 - 4;	//  --||--
d3743 2
a3744 2
			CRect rRating;
			rRating.left = rPlusMinus.right+2; //EC 30.07.03 +2 for filetype icon gap +16 for size
d3746 4
a3749 4
				rRating.left += 16+2; //EC 30.07.03 +2 for filetype icon gap +16 for size
			rRating.top = rPlusMinus.top;
			rRating.right = rRating.left + 16 - 6;
			rRating.bottom = rRating.top + 16 - 2;
d3751 1
a3751 1
			{						
d3902 1
a3902 1
			pItem->m_bSrcsAreVisible = true;;
a3923 1
			g_eMuleApp.m_pGlobPrefs->SetShowFullFileStatusIcons(!g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons());
@


1.264
log
@Localization update
@
text
@d3942 17
@


1.263
log
@Visual fix for cancel files
@
text
@d2696 1
a2696 1
						CFileDetails dialog("File Details", file, this, 0);
d2902 1
a2902 1
					CClientDetails dialog("Client Details", client, this, 0);
d3809 1
a3809 1
				CClientDetails dialog("Client Details", client, this, 0);
d4101 1
a4101 1
			CFileDetails		dialog("File Details", pPartFile, this, 0);
d4109 1
a4109 1
	else 
d4113 1
a4113 1
		CClientDetails		dialog("Client Details", pSource, this, 0);
@


1.262
log
@Formatting, comments, and name changes.
Fixed "sort settings not saved".
Fixed "double-click on completed file disables file sorting".
Added sorting for new "waited on queue" in DL.
@
text
@a2509 1
						SetRedraw(false);
d2533 2
d2556 2
a2558 1
						SetRedraw(true);
@


1.261
log
@Code formatting and fixes for preallocation (statistics)
@
text
@d77 1
a77 1
	m_iCurrentSortItem = 0;
d79 4
a82 4
	m_bShowSrc=false;  // Cax2
	m_iLastSortCode=0;
	m_dwSortTime=0;
	m_bDblClicked=false; // DonGato
d213 1
a213 1
	if(g_eMuleApp.m_pGlobPrefs->DoUseSort())
d215 1
a215 1
		SortInit(99);
d219 6
a224 5
		// Barry - Use preferred sort order from preferences
		int sortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_DOWNLOAD);
		bool sortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_DOWNLOAD);
		SetSortArrow(sortItem, sortAscending);
		SortItems(SortProc, sortItem + (sortAscending ? 0:100));	//Cax2 - more than 10 columns
d453 1
a453 1
	while (GetItemCount() > nItem+1 && !((CMuleCtrlItem*)GetItemData(nItem+1))->IsFile())
d464 2
d1785 1
a1785 1
	if (g_eMuleApp.m_pGlobPrefs->DoUseSrcSortCol2() && g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_bShowSrc && m_dwSortTime+1000<::GetTickCount()) 
d2084 2
a2085 2
			m_iCurrentSortItem = m_iLastSortCode < 100 ? m_iLastSortCode : m_iLastSortCode - 100;
			SetSortArrow(m_iCurrentSortItem, (m_iLastSortCode < 100));
a2140 1
		m_bShowSrc = true;  //newsort added by Cax2 03/11/02 
d2151 5
a2155 2
		else if (pPartFile->GetStatus() == PS_COMPLETE && !m_bDblClicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
			ClearCompleted(pPartFile->GetFileHash());
d2177 1
a2177 1
			if (expand > COLLAPSE_ONLY)
d2179 2
d2955 1
a2955 1
void CDownloadListCtrl::OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult)
d2959 1
a2959 1
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
d2964 4
a2967 2
	m_iLastSortCode=m_iCurrentSortItem + (m_bSortAscending ? 0:100);	//Cax2 - more than 10 columns
	SortItems(SortProc, m_iCurrentSortItem + (m_bSortAscending ? 0:100)+(m_bShowSrc?1000:0)); // Cax2
d2978 2
a2979 2
	CMuleCtrlItem		*item1 = (CMuleCtrlItem*)lParam1;
	CMuleCtrlItem		*item2 = (CMuleCtrlItem*)lParam2;
d2981 1
a2981 1
	bool showSrc=false;  
d2983 1
a2983 1
	if (lParamSort>=1000)
d2985 2
a2986 2
		showSrc=true; 
		lParamSort-=1000; 
d2989 1
a2989 1
    int sortMod = 1;
d2991 1
a2991 1
    if(lParamSort >= 100)	//Cax2 - more than 10 columns
d2993 2
a2994 2
		sortMod = -1;
		lParamSort -= 100;
d2997 1
a2997 1
	int comp;
d2999 6
a3004 4
	if ( (item1->IsFile() && !item2->IsFile())
	  || (item2->IsFile() && !item1->IsFile()) )
	{ // files vs source?
		comp = 0; // leave it as it is...
d3007 3
a3009 23
		if (item1->IsFile())
	{ //both files? (!)
		if (showSrc)
		{	
			comp = 0;
		}
		else
		{ 
				CPartFile	*file1 = item1->GetFile();
				CPartFile	*file2 = item2->GetFile();
			comp = Compare(file1, file2, lParamSort);
		}
    } 
	else 
	{ //both sources...
			comp = Compare(item1->GetFile(), item2->GetFile(),0);
			//	If the sources aren't for the same file...
        if(comp != 0)
		{ 
			return 0;
		}
		//Cax2:a4af clients kept separate, unless sorting for name
			if ((item1->IsAskedForAnotherFile() || item2->IsAskedForAnotherFile()) && lParamSort!=0)
d3011 8
a3018 1
			int n = 0;
d3020 1
a3020 3
				if (item1->IsAskedForAnotherFile() && !item2->IsAskedForAnotherFile())
			{	
				n = -1;
d3022 10
a3031 3
				if (item2->IsAskedForAnotherFile() && !item1->IsAskedForAnotherFile())
			{	
				n = 1;
d3033 17
a3049 3
			if (n != 0)			//always at the end, unless sort by source - then a4af always at the top
			{	
				return (lParamSort == 5)? n : -n;
a3050 1
		}
d3052 5
a3056 3
			comp = Compare(item1->GetSource(), item2->GetSource(), lParamSort, sortMod);
    } 
   	return sortMod * comp;
d3059 1
d3065 1
a3065 1
	// Search for completed file(s)
d3084 1
a3084 1
void CDownloadListCtrl::ClearCompleted(const uchar* FileHash /*=NULL*/)
d3088 4
a3091 3
	//eklmn: init temp array
	CArray<CPartFile*, CPartFile*> CompletedFiles;
	for(MuleIter g = m_mapItems.begin(); g != m_mapItems.end(); )
d3093 4
a3096 3
		CMuleCtrlItem* pItem = g->second;
		g++; // Already point to the next iterator
		if(pItem->IsFile())
d3098 3
a3100 2
			CPartFile* pFile = pItem->GetFile();
			if(!pFile->IsPartFile())
d3102 1
a3102 1
				if (FileHash == NULL)
d3104 1
a3104 1
					CompletedFiles.Add(pFile); 
d3106 1
a3106 1
				else if (md4cmp(FileHash, pFile->GetFileHash()) == 0) 
d3114 2
a3115 2
	// eklmn: clear all file correct way
	if (FileHash == NULL)
d3117 1
a3117 1
		for(int i = 0; i < CompletedFiles.GetCount(); i++)
d3119 1
a3119 1
			RemoveFile(CompletedFiles[i]);	//continue clearing all
d3121 1
a3121 1
		CompletedFiles.RemoveAll();
d3503 1
a3503 1
/*static*/ int CDownloadListCtrl::Compare(CUpDownClient* client1,CUpDownClient* client2, LPARAM lParamSort, int sortMod) 
d3509 1
a3509 1
	if (client1==NULL||client2==NULL)
d3522 1
a3522 1
			    iCompare = CompareUnsigned(client1->GetTransferredDown(), client2->GetTransferredDown());
d3528 1
a3528 1
			    iCompare = CompareUnsigned(client1->GetTransferredDown(), client2->GetTransferredDown());
d3533 1
a3533 1
			iCompare = CompareUnsigned(client1->GetDownloadDataRate(), client2->GetDownloadDataRate());
d3538 1
a3538 1
			iCompare = client1->GetAvailablePartCount() - client2->GetAvailablePartCount();
d3543 1
a3543 1
			if (client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )
d3545 1
a3545 1
				iCompare = (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;		//Cax2 append all unknown ones at the end
d3547 1
a3547 1
			else if (client1->GetClientSoft() == client2->GetClientSoft())
d3549 1
a3549 1
				if (client1->IsEmuleClient())
d3551 2
a3552 2
					uint32 plus1=(client1->PlusVersion()<0x2600)?client1->PlusVersion():0;
					uint32 plus2=(client2->PlusVersion()<0x2600)?client2->PlusVersion():0;
d3557 1
a3557 1
					else if (client1->GetMuleVersion() == client2->GetMuleVersion())
d3559 4
a3562 4
						if (!client1->GetModVersion().IsEmpty() && !client2->GetModVersion().IsEmpty())
							iCompare = _tcsicmp(client1->GetModVersion(), client2->GetModVersion());
						else if (!client1->GetModVersion().IsEmpty() || !client2->GetModVersion().IsEmpty())
							iCompare = (client1->GetModVersion().IsEmpty()) ? 1 : -1;
d3565 1
a3565 1
						iCompare = client2->GetMuleVersion() - client1->GetMuleVersion();
d3569 1
a3569 1
					iCompare = client2->GetVersion() - client1->GetVersion();
d3574 1
a3574 1
				iCompare = client1->GetClientSoft() - client2->GetClientSoft();
d3580 1
a3580 1
			if (client1->GetDownloadState()!=DS_ONQUEUE || client2->GetDownloadState()!=DS_ONQUEUE)	//Cax2 QR gaps bugfix
d3582 1
a3582 1
				if (client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
d3584 1
a3584 1
					iCompare = (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
d3586 1
a3586 1
				else if (client1->GetDownloadState()==DS_DOWNLOADING || client2->GetDownloadState()==DS_DOWNLOADING)		//Cax2 QR gaps bugfix
d3588 1
a3588 1
					iCompare = (client1->GetDownloadState()==DS_DOWNLOADING)?((client2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2; //Cax2 QR gaps bugfix
d3592 1
a3592 1
					iCompare = (client1->GetDownloadState()!=DS_ONQUEUE)?((client2->GetDownloadState()!=DS_ONQUEUE)?0:sortMod):-1*sortMod;		//Cax2 now should show properly...
d3595 1
a3595 1
			else if (sortMod<0 || (client1->GetRemoteQueueRank()>0 && client2->GetRemoteQueueRank()>0))
d3597 1
a3597 1
				iCompare = client1->GetRemoteQueueRank() - client2->GetRemoteQueueRank();   
d3599 1
a3599 1
			else if (client1->GetRemoteQueueRank()==0 && client2->GetRemoteQueueRank()==0)
d3601 1
a3601 1
				iCompare = (client1->IsEmuleClient())?((client2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
d3605 1
a3605 1
				iCompare = (client1->GetRemoteQueueRank()==0)?((client2->GetRemoteQueueRank()==0)?0:2):-1;
d3611 1
a3611 1
			iCompare = client1->GetDownloadStateAsString().Compare(client2->GetDownloadStateAsString());
d3617 1
a3617 1
			if (client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )	//Cax2 append all unknown ones at the end
d3619 1
a3619 1
				iCompare = (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;					//Cax2 append all unknown ones at the end
d3623 2
a3624 2
				bool	isValid1 = (client1->IsRemoteInfoAvaiable()|| client1->credits);
				bool	isValid2 = (client2->IsRemoteInfoAvaiable()|| client2->credits);
d3628 1
a3628 1
					iCompare = (client1->GetRemoteBaseModifier() <client2->GetRemoteBaseModifier())?-1:1;	//Cax2 - has to return an integer!
d3632 1
a3632 1
					iCompare = client1->GetRemoteRatio() - client2->GetRemoteRatio();
d3649 32
d3688 1
a3688 1
		{ sName1 = CString(client1->GetUserName()); }
d3692 1
a3692 1
		{ sName2 = CString(client2->GetUserName()); }
@


1.260
log
@Formatting, comments, and name changes.
Possible fix for the drawing problem in DrawItem().
@
text
@d2331 2
a2332 1
				m_menuFile.AppendMenu(MF_STRING,MP_PREALLOCATE, GetResString(IDS_DL_PREALLOCATE));
d2815 1
a2815 1
							file->SaveFileSettings();
d2833 1
a2833 1
							file->SaveFileSettings();
d2847 1
a2847 1
							selFile->SaveFileSettings();
@


1.259
log
@Restored old code until devs fix the drwing problem
@
text
@d720 10
a729 10
						case PS_COMPLETING:			iIcon = ICON_STATUS_COMPLETING; break;
						case PS_COMPLETE:			iIcon = ICON_STATUS_COMPLETE; break;
						case PS_DOWNLOADING:		iIcon = ICON_STATUS_DOWNLOADING; break;
						case PS_WAITINGFORSOURCE:	iIcon = ICON_STATUS_WAITING; break;
						case PS_HASHING:			iIcon = ICON_STATUS_HASHING; break;
						case PS_PAUSED:				iIcon = ICON_STATUS_PAUSED; break;
						case PS_STALLED:			iIcon = ICON_STATUS_STALLED; break;
						case PS_STOPPED:			iIcon = ICON_STATUS_STOPPED; break;
						case PS_ERROR:				iIcon = ICON_STATUS_ERRONEOUS; break;
						default:					iIcon = ICON_STATUS_ERRONEOUS;
d741 2
a742 2
							? ICON_LISTMINUS : ICON_LISTPLUS )
							: ICON_LISTNONE;
d751 1
a751 1
					iIcon = ICON_LISTNONE;
d754 1
a754 1
						iIcon = ICON_LISTCOMPLETE;
d756 1
a756 1
						iIcon = ICON_LISTSTOPPED;
d758 1
a758 1
						iIcon = ICON_LISTPAUSED;
d762 2
a763 2
								? ICON_LISTMINUS : ICON_LISTPLUS )
								: ICON_LISTNONE;
d773 1
a773 1
					m_imageList.Draw(dc, ICON_A4AFAUTO, ipoint, ILD_TRANSPARENT);
d796 1
a796 1
						iIcon = ICON_RATING_NO;
d803 1
a803 1
										iIcon = ICON_RATING_NO;
d806 1
a806 1
										iIcon = ICON_RATING_FAKE;
d809 1
a809 1
										iIcon = ICON_RATING_POOR;
d812 1
a812 1
										iIcon = ICON_RATING_GOOD;
d815 1
a815 1
										iIcon = ICON_RATING_FAIR;
d818 1
a818 1
										iIcon = ICON_RATING_EXCELLENT;
d821 1
a821 1
								iIcon=ICON_RATING_NO;
d1412 1
a1412 1
							    m_imageList.Draw(dc, ICON_DCS3, point, ILD_NORMAL);
d1415 1
a1415 1
							    m_imageList.Draw(dc, ICON_DCS2, point, ILD_NORMAL);
d1419 1
a1419 1
							    m_imageList.Draw(dc, ICON_DCS1, point, ILD_NORMAL);
d1423 1
a1423 1
							    m_imageList.Draw(dc, ICON_DCS4, point, ILD_NORMAL);
d1426 1
a1426 1
							    m_imageList.Draw(dc, ICON_DCS5, point, ILD_NORMAL);
d1429 1
a1429 1
               		    m_imageList.Draw(dc, ICON_DCS4, point, ILD_NORMAL); 
d1444 1
a1444 1
						    m_imageList.Draw(dc, ICON_CDONKEY, point2, ILD_NORMAL);
d1447 1
a1447 1
						    m_imageList.Draw(dc, ICON_LMULE, point2, ILD_NORMAL);
d1450 1
a1450 1
						    m_imageList.Draw(dc, ICON_SHAREAZA, point2, ILD_NORMAL);
d1453 1
a1453 1
						    m_imageList.Draw(dc, ICON_EDONKEYHYBRID, point2, ILD_NORMAL);
d1456 1
a1456 1
						    m_imageList.Draw(dc, ICON_MLDONKEY, point2, ILD_NORMAL);
d1463 1
a1463 1
							    m_imageList.Draw(dc, ICON_COMPROT, point2, ILD_NORMAL);
d1466 1
a1466 1
						    m_imageList.Draw(dc, ICON_NORMAL, point2, ILD_NORMAL);
d1469 1
a1469 1
						    m_imageList.Draw(dc, ICON_UNKNOWN, point2, ILD_NORMAL);
d1475 1
a1475 1
					    m_imageList.Draw(dc, ICON_BANNED_ONLY, point2, ILD_TRANSPARENT);
d1477 1
a1477 1
					    m_imageList.Draw(dc, ICON_FRIEND_ONLY, point2, ILD_TRANSPARENT);
d1479 1
a1479 1
					    m_imageList.Draw(dc, ICON_CREDIT_DOWNESTIMATED, point2, ILD_TRANSPARENT);
a1770 2
// Restored old code until the people who added the changes solve the drawing problem with multiple selections [DonGato]
/*
a1790 4
	CMemDC			dc(odc,&CRect(lpDrawItemStruct->rcItem));
	CFont			*pOldFont = dc->SelectObject(GetFont());
	COLORREF		crOldTextColor = dc->SetTextColor(m_crWindowText);
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
d1804 5
a1956 1

a2040 247
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	EMULE_TRY

	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
		return;
	if (!lpDrawItemStruct->itemData)
		return;

	if(g_eMuleApp.m_pGlobPrefs->DoUseSrcSortCol2() && g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_bShowSrc && m_dwSortTime+1000<::GetTickCount()) 
	{	
		SortInit(false); // Cax2 sortdlg
	}

	CDC* odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	CMuleCtrlItem* content = (CMuleCtrlItem*)lpDrawItemStruct->itemData;
	BOOL bCtrlFocused = ((GetFocus() == this) || (GetStyle() & LVS_SHOWSELALWAYS));

	if ((content->IsFile()) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
	{
		if(bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	} else
		odc->SetBkColor(GetBkColor());

	CMemDC dc(odc,&CRect(lpDrawItemStruct->rcItem));
	CFont *pOldFont = dc->SelectObject(GetFont());
	COLORREF crOldTextColor = dc->SetTextColor(m_crWindowText);

	BOOL notLast = lpDrawItemStruct->itemID + 1 != GetItemCount();
	BOOL notFirst = lpDrawItemStruct->itemID != 0;
	int tree_start=0;
	int tree_end=0;

	RECT cur_rec;
	memcpy2(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));

	//offset was 4, now it's the standard 2 spaces
	int iOffset = dc->GetTextExtent(_T(" "), 1 ).cx * 2;
	CHeaderCtrl *pHeaderCtrl = GetHeaderCtrl();
	int iCount = pHeaderCtrl->GetItemCount();
	cur_rec.right = cur_rec.left;
	cur_rec.right -= iOffset;
	cur_rec.left += iOffset/2;

	if (content->IsFile())
	{		
		for(int iCurrent = 0; iCurrent < iCount; iCurrent++) 
		{
			int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
			int cx = CListCtrl::GetColumnWidth(iColumn);
			if(iColumn == 5)
			{
				int iNextLeft = cur_rec.left + cx;
				//set up tree vars
				cur_rec.left = cur_rec.right + iOffset;
				cur_rec.right = cur_rec.left + min(8, cx);
				tree_start = cur_rec.left + 1;
				tree_end = cur_rec.right;
				//normal column stuff
				cur_rec.left = cur_rec.right + 1;
				cur_rec.right = tree_start + cx - iOffset;
				DrawFileItem(dc, 5, &cur_rec, content);
				cur_rec.left = iNextLeft;
			} 
			else 
			{
				cur_rec.right += cx;
				DrawFileItem(dc, iColumn, &cur_rec, content);
				cur_rec.left += cx;
			}

		}
	} 
	else if (content->IsSource())
	{
		for(int iCurrent = 0; iCurrent < iCount; iCurrent++)
		{
			int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
			int cx = CListCtrl::GetColumnWidth(iColumn);

			if(iColumn == 5)
			{
				int iNextLeft = cur_rec.left + cx;
				//set up tree vars
				cur_rec.left = cur_rec.right + iOffset;
				cur_rec.right = cur_rec.left + min(8, cx);
				tree_start = cur_rec.left + 1;
				tree_end = cur_rec.right;
				//normal column stuff
				cur_rec.left = cur_rec.right + 1;
				cur_rec.right = tree_start + cx - iOffset;
				DrawSourceItem(dc, 5, &cur_rec, content);
				cur_rec.left = iNextLeft;
			} 
			else 
			{
				cur_rec.right += cx;
				DrawSourceItem(dc, iColumn, &cur_rec, content);
				cur_rec.left += cx;
			}
		}
	}

	//draw rectangle around selected item(s)
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) &&
		(lpDrawItemStruct->itemState & ODS_SELECTED) && (content->IsFile()))
	{
		RECT outline_rec;
		memcpy2(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));

		outline_rec.top--;
		outline_rec.bottom++;
		CBrush brush(GetBkColor());
		CBrush* pOldBrush = dc->SelectObject(&brush);	//eklmn: select a new brush
		dc->FrameRect(&outline_rec, &brush);
		dc->SelectObject(pOldBrush);	//eklmn: recover an old brush
		outline_rec.top++;
		outline_rec.bottom--;
		outline_rec.left++;
		outline_rec.right--;

		if(notFirst && (GetItemState(lpDrawItemStruct->itemID - 1, LVIS_SELECTED)))
		{
			CMuleCtrlItem* prev = (CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID - 1);
			if(prev->IsFile())
				outline_rec.top--;
		} 

		if(notLast && (GetItemState(lpDrawItemStruct->itemID + 1, LVIS_SELECTED)))
		{
			CMuleCtrlItem* next = (CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1);
			if(next->IsFile())
				outline_rec.bottom++;
		} 

		if(bCtrlFocused)
		{
			CBrush fBrush(m_crFocusLine);
			CBrush* pOldfBrush = dc->SelectObject(&fBrush);	//eklmn: select a new brush
			dc->FrameRect(&outline_rec, &fBrush);
			dc->SelectObject(pOldfBrush);	//eklmn: recover an old brush
		}
		else
		{
			CBrush nfBrush(m_crNoFocusLine);
			CBrush* pOldnfBrush = dc->SelectObject(&nfBrush);	//eklmn: select a new brush
			dc->FrameRect(&outline_rec, &nfBrush);
			dc->SelectObject(pOldnfBrush);	//eklmn: recover an old brush
		}
	}
	//draw focus rectangle around non-highlightable items when they have the focus
	else if (((lpDrawItemStruct->itemState & ODS_FOCUS) == ODS_FOCUS) && (GetFocus() == this))
	{
		RECT focus_rec;
		focus_rec.top    = lpDrawItemStruct->rcItem.top;
		focus_rec.bottom = lpDrawItemStruct->rcItem.bottom;
		focus_rec.left   = lpDrawItemStruct->rcItem.left + 1;
		focus_rec.right  = lpDrawItemStruct->rcItem.right - 1;
		CBrush nfBrush(m_crNoFocusLine);
		CBrush* pOldnfBrush = dc->SelectObject(&nfBrush);	//eklmn: select a new brush
		dc->FrameRect(&focus_rec, &nfBrush);
		dc->SelectObject(pOldnfBrush);	//eklmn: recover an old brush
	}

	//draw tree last so it draws over selected and focus (looks better)
	if(tree_start < tree_end)
	{
		//set new bounds
		RECT tree_rect;
		tree_rect.top    = lpDrawItemStruct->rcItem.top;
		tree_rect.bottom = lpDrawItemStruct->rcItem.bottom;
		tree_rect.left   = tree_start;
		tree_rect.right  = tree_end;
		dc->SetBoundsRect(&tree_rect, DCB_DISABLE);

		//gather some information
		BOOL hasNext = notLast &&
			((CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1))->IsSource();
		BOOL isOpenRoot = hasNext && content->IsFile();
		BOOL isChild = content->IsSource();
		BOOL isExpandable = !isChild && content->GetFile()->GetSourceCount() > 0;
		//might as well calculate these now
		int treeCenter = tree_start + 3;
		int middle = (cur_rec.top + cur_rec.bottom + 1) / 2;

		//set up a new pen for drawing the tree
		CPen pn, *oldpn;
		pn.CreatePen(PS_SOLID, 1, dc->GetTextColor());
		oldpn = dc->SelectObject(&pn);

		if(isChild)
		{
			//draw the line to the status bar
			dc->MoveTo(tree_end, middle);
			dc->LineTo(tree_start + 3, middle);

			//draw the line to the child node
			if(hasNext)
			{
				dc->MoveTo(treeCenter, middle);
				dc->LineTo(treeCenter, cur_rec.bottom + 1);
			}
		} else if(isOpenRoot) {
			//draw circle
			RECT circle_rec;
			COLORREF crBk = dc->GetBkColor();
			circle_rec.top    = middle - 2;
			circle_rec.bottom = middle + 3;
			circle_rec.left   = treeCenter - 2;
			circle_rec.right  = treeCenter + 3;
			CBrush brush(dc->GetTextColor());
			CBrush* pOldBrush = dc->SelectObject(&brush);	//eklmn: select a new brush
			dc->FrameRect(&circle_rec, &brush);
			dc->SelectObject(pOldBrush);	//eklmn: recover an old brush
			dc->SetPixelV(circle_rec.left,      circle_rec.top,    crBk);
			dc->SetPixelV(circle_rec.right - 1, circle_rec.top,    crBk);
			dc->SetPixelV(circle_rec.left,      circle_rec.bottom - 1, crBk);
			dc->SetPixelV(circle_rec.right - 1, circle_rec.bottom - 1, crBk);
			//draw the line to the child node
			if(hasNext)
			{
				dc->MoveTo(treeCenter, middle + 3);
				dc->LineTo(treeCenter, cur_rec.bottom + 1);
			}
		}
		//draw the line back up to parent node
		if(notFirst && isChild)
		{
			dc->MoveTo(treeCenter, middle);
			dc->LineTo(treeCenter, cur_rec.top - 1);
		}

		//put the old pen back
		dc->SelectObject(oldpn);
		pn.DeleteObject();
	}

	//put the original objects back
	dc->SelectObject(pOldFont);
	dc->SetTextColor(crOldTextColor);
	EMULE_CATCH
}
d2940 1
a2940 1
//	CMuleListCtrl::OnNMDividerDoubleClick(pHeader,pResult);
@


1.258
log
@Preallocate feature and Localization fixes
@
text
@d1771 2
d2028 247
@


1.257
log
@Formatting, comments, and name changes.
Fixed column resizing on double-click.
@
text
@d1796 12
a1823 12
	if ((pItem->IsFile()) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
	{
		if (bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	}
	else
	{
		odc->SetBkColor(GetBkColor());
	}

d1956 1
d2327 5
a2331 2
			m_menuFile.AppendMenu(MF_STRING,MP_INITIALIZE, GetResString(IDS_DL_INITIALIZE));
			m_menuFile.EnableMenuItem(MP_INITIALIZE,(justOne && status == PS_ERROR) ? MF_ENABLED:MF_GRAYED);
d2339 1
a2339 1
			if(justOne && !file->PreviewAvailable())
d2652 8
@


1.256
log
@Minor fix
@
text
@d77 6
a82 6
	m_CurrentSortItem = 0;
	m_SortAscending = true;
	m_ShowSrc=false;  // Cax2
	m_lastSort=0;
	m_sortTime=0;
	m_dblclicked=false; // DonGato
d89 1
a89 1
	if(m_PrioMenu)
d91 1
a91 1
		VERIFY( m_PrioMenu.DestroyMenu() );
d93 1
a93 1
	if(m_FileMenu) 
d95 1
a95 1
		VERIFY( m_FileMenu.DestroyMenu() );
d97 1
a97 1
	while(m_ListItems.empty() == false)
d99 2
a100 2
		delete m_ListItems.begin()->second;
		m_ListItems.erase(m_ListItems.begin());
d122 7
d134 2
a135 1
	CString	strSpeed;
d158 2
a159 1
	CString	strAvgSpeed;
d371 2
a372 2
	ASSERT(m_ListItems.find(pFileToAdd) == m_ListItems.end());
	m_ListItems.insert(make_pair(pFileToAdd, pItem));
d395 1
a395 1
	MuleRange		Range = m_ListItems.equal_range(pSource);
d420 1
a420 1
		MuleIter		itFileItem = m_ListItems.find(pOwner);
d423 1
a423 1
		if (itFileItem == m_ListItems.end())
d428 1
a428 1
		m_ListItems.insert(make_pair(pSource, pSourceItem));
d488 1
a488 1
	MuleRange		Range = m_ListItems.equal_range(pSource);
d497 1
a497 1
			itSource = m_ListItems.erase(itSource);
d583 1
a583 1
	for (MuleIter itItem = m_ListItems.begin(); itItem != m_ListItems.end(); )
d590 1
a590 1
			itItem = m_ListItems.erase(itItem);
d629 1
a629 1
	    MuleRange		Range = m_ListItems.equal_range(pObjToUpdate);
d684 5
d691 9
a704 1

d706 1
a706 1
		CPartFile		*lpPartFile = lpFileItem->GetFile();
a709 5
//	TODO: Put these constants somewhere sensible!
#define OFFSET_STATUSICON	18
#define OFFSET_PLUSMINUS	18
#define OFFSET_FILETYPEICON	19
#define OFFSET_RATINGICON	10
d711 5
d717 2
a718 5
					RECT	r = *lpRect;
					POINT	ipoint = { r.left, r.top + 1 };
					int		iIcon = 0;

					if (g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d720 24
a743 14
					//	Draw the status icon
						switch (lpPartFile->GetPartfileStatusID())
						{
							case PS_COMPLETING:			iIcon = ICON_STATUS_COMPLETING; break;
							case PS_COMPLETE:			iIcon = ICON_STATUS_COMPLETE; break;
							case PS_DOWNLOADING:		iIcon = ICON_STATUS_DOWNLOADING; break;
							case PS_WAITINGFORSOURCE:	iIcon = ICON_STATUS_WAITING; break;
							case PS_HASHING:			iIcon = ICON_STATUS_HASHING; break;
							case PS_PAUSED:				iIcon = ICON_STATUS_PAUSED; break;
							case PS_STALLED:			iIcon = ICON_STATUS_STALLED; break;
							case PS_STOPPED:			iIcon = ICON_STATUS_STOPPED; break;
							case PS_ERROR:				iIcon = ICON_STATUS_ERRONEOUS; break;
							default:					iIcon = ICON_STATUS_ERRONEOUS;
						}
d745 7
a751 2
						r.left += OFFSET_STATUSICON;
						ipoint.x += OFFSET_STATUSICON;
d753 8
a760 2
					//	Draw the old-style +/- box
						iIcon = (lpPartFile->GetSourceCount() > 0 || lpPartFile->GetSrcA4AFCount() > 0)
d764 1
a765 2
						r.left += OFFSET_PLUSMINUS;
					}
d767 3
a769 17
					{
						iIcon = ICON_LISTNONE;

						if(lpPartFile->GetStatus()==PS_COMPLETE)
							iIcon = ICON_LISTCOMPLETE;
						else if(lpPartFile->GetStatus()==PS_STOPPED)
							iIcon = ICON_LISTSTOPPED;
						else if(lpPartFile->GetStatus()==PS_PAUSED)
							iIcon = ICON_LISTPAUSED;
						else
							iIcon = (lpPartFile->GetSourceCount() > 0 || lpPartFile->GetSrcA4AFCount() > 0)
								  ? ( lpFileItem->m_bSrcsAreVisible
								    ? ICON_LISTMINUS : ICON_LISTPLUS )
								  : ICON_LISTNONE;
						m_imageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
						r.left += OFFSET_PLUSMINUS;
					}
d771 4
a774 4
				//	DropF START - Show that a file is A4AF auto
					if (lpPartFile == g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile())
						m_imageList.Draw(dc, ICON_A4AFAUTO, ipoint, ILD_TRANSPARENT);
				//	DropF END
d776 4
a779 2
				//	File Type
					if (g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
d781 1
a781 1
						int		iImage = g_eMuleApp.GetFileTypeSystemImageIdx(lpPartFile->GetFileName());
d787 3
d791 4
a794 4
				//	Comments/ratings
			        if (!g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons())
					{
						if(lpPartFile->HasComment() || lpPartFile->HasRating())
d798 1
a798 1
						if (lpPartFile->HasRating())
d800 1
a800 1
				        	switch (lpPartFile->GetRating())
d824 2
a825 2
					    POINT	point= {r.left-4,r.top+3};

d828 3
a830 2
				    r.left += OFFSET_RATINGICON;
					}
d832 7
a838 7
				//
				//	Finally, the file title. First set the color
                    COLORREF	crOldTxtColor;
					COLORREF	cr = CCat::GetCatColorByID(lpPartFile->GetCatID());
					bool		bRestoreColor = true;	// Not restoring the color _may_ make the rest of the
														//	row the same color. Don't count on it.
					cr = (cr > 0) ? cr : (::GetSysColor(COLOR_WINDOWTEXT));
d840 3
a842 1
					if (lpPartFile->GetStatus()==PS_PAUSED || lpPartFile->GetStatus()==PS_STOPPED)
d844 19
a862 1
						if (g_eMuleApp.m_pGlobPrefs->ShowPausedGray())
d864 1
a864 2
							cr = ::GetSysColor(COLOR_GRAYTEXT);
							bRestoreColor = false;
d866 6
d873 5
a877 12
						{
						//	TODO: This might be worth pulling out into its own function (as I see others have already done)
							uint8		r,g,b;
							const uint8	grayAmount = 0x60;
							const uint8 grayBuffer = 0x40;
							const uint8	grayLimit = 0xFF - grayBuffer;
							uint8		gray = grayAmount;

						//	"gray" the color
							r = GetRValue(cr);
							b = GetBValue(cr);
							g = GetGValue(cr);
d879 1
a879 20
						//	Make sure we don't wash the color out TOO much
							if (r + gray >= grayLimit && b + gray >= grayLimit && g + gray >= grayLimit)
							{
								gray -= grayBuffer;
							}
							if (r + gray <= 0xFF)
								r += gray;
							else
								r = 0xFF;
							if (b + gray <= 0xFF)
								b += gray;
							else
								b = 0xFF;
							if (g + gray <= 0xFF)
								g += gray;
							else
								g = 0xFF;

							cr = RGB(r,g,b);
						}
a880 10

					crOldTxtColor = dc->SetTextColor(cr);
				    
				//	Draw the file name
					dc->DrawText(lpPartFile->GetFileName(), (int)_tcslen(lpPartFile->GetFileName()),&r, DLC_DT_TEXT);

				//	Restore the original color
					if (bRestoreColor)
						dc->SetTextColor(crOldTxtColor);
					break;
d883 19
a901 3
			case DLCOL_SIZE:		// size
				buffer = CastItoXBytes(lpPartFile->GetFileSize());
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d903 7
a909 4

			case DLCOL_TRANSFERRED:		// transferred
				buffer = CastItoXBytes(lpPartFile->GetTransferred());
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d911 7
a917 4

		    case DLCOL_COMPLETED:		// transferred complete
			    buffer = CastItoXBytes(lpPartFile->GetCompletedSize());
			    dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d919 7
d927 7
a933 15
			case DLCOL_SPEED:		// speed
		       	{
					buffer.Empty();
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
					{
						uint32 dRate = lpPartFile->GetDataRate();
			       		if (dRate > 10)
							buffer.AppendFormat(_T("%.1f "), dRate/1024.0f);
						//bond006 (smoothed "remaining time" calculation) //SyruS
			       		if(g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
			       		{
							dRate = lpPartFile->GetAvgDataRate(true);
							if (dRate > 10)
								buffer.AppendFormat(_T("(%.2f) "), dRate/1024.0f);
						}
a934 3
					else	//SyruS show average sessionrate
						buffer.AppendFormat(_T("[%.2f]"), lpPartFile->GetAvgDataRate(false)/1024.0f);
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d936 5
d942 10
a952 6
			case DLCOL_PROGRESS:		// progress
				{
					lpRect->bottom --;
					lpRect->top ++;
					int  iWidth = lpRect->right - lpRect->left; 
					int iHeight = lpRect->bottom - lpRect->top;
d955 4
a958 2
					CDC cdcStatus; 
					HGDIOBJ hOldBitmap;
d960 5
a964 3
					int cx = lpFileItem->GetBitmap().GetBitmapDimension().cx; 
					DWORD dwTicks = GetTickCount(); 
					if (lpFileItem->GetUpdateTimer() + DLC_BARUPDATE < dwTicks || cx !=  iWidth || lpFileItem->GetUpdateTimer() != 0)
d967 2
a968 2
						lpFileItem->GetBitmap().CreateCompatibleBitmap(dc,  iWidth, iHeight); 
						lpFileItem->GetBitmap().SetBitmapDimension(iWidth,  iHeight); 
d974 3
a976 3
						rec_status.bottom = iHeight; 
						rec_status.right = iWidth; 
						lpPartFile->DrawStatusBar(&cdcStatus,  &rec_status, g_eMuleApp.m_pGlobPrefs->UseFlatBar()); 
d979 2
a980 1
					} else 
d983 1
a983 1
					dc->BitBlt(lpRect->left, lpRect->top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
d991 1
a991 1
						buffer.Format("%.1f%%", lpPartFile->GetPercentCompleted());
d993 5
a997 5
						int iOLeft = lpRect->left;
						lpRect->left += iWidth / 2 - 10; // Close enough
						if(lpPartFile->GetStatus()!=PS_COMPLETE && lpPartFile->GetStatus()!=PS_COMPLETING)
							lpRect->top += 3; // Just a little down
						dc->DrawText(buffer, buffer.GetLength(), lpRect, DLC_DT_TEXT);
d999 1
a999 1
						lpRect->left = iOLeft;
a1003 3

					lpRect->bottom ++;
					lpRect->top --;
d1005 3
d1009 5
d1015 10
a1024 14
			case DLCOL_NUMSOURCES:		// sources
				{
					CString buffer2;
					uint16 ncsc=lpPartFile->GetNotCurrentSourcesCount();
					if(ncsc>0)
						buffer2.Format(_T("%i/"),lpPartFile->GetSourceCount() -ncsc);
					else
						buffer2 = "";
					buffer.Format(_T("%s%i (%i)"),buffer2, lpPartFile->GetSourceCount(), lpPartFile->GetTransferringSrcCount());
					if (((CKnownFile*)lpPartFile)->IsAutoPrioritized())
						((CKnownFile*)lpPartFile)->UpdateUploadAutoPriority();
					// g_eMuleApp.m_pSharedFilesList->UpdateItem(((CKnownFile*)lpPartFile)); // obaldin: what the heck was it doing here? moved to UpdateItem
					dc->DrawText(buffer,(int)_tcslen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);
				}
d1026 4
a1029 4

			case DLCOL_PRIORITY:		// prio
				// Tarod (auto priority)
				if (lpPartFile->IsAutoPrioritized())
d1031 1
a1031 1
					lpPartFile->UpdateDownloadAutoPriority();
d1033 1
a1033 1
					switch(lpPartFile->GetPriority())
d1036 1
a1036 1
							dc->DrawText(GetResString(IDS_PRIOAUTOLOW),GetResString(IDS_PRIOAUTOLOW).GetLength(),lpRect, DLC_DT_TEXT);
d1039 1
a1039 1
							dc->DrawText(GetResString(IDS_PRIOAUTONORMAL),GetResString(IDS_PRIOAUTONORMAL).GetLength(),lpRect, DLC_DT_TEXT);
d1042 1
a1042 1
							dc->DrawText(GetResString(IDS_PRIOAUTOHIGH),GetResString(IDS_PRIOAUTOHIGH).GetLength(),lpRect, DLC_DT_TEXT);
d1045 4
a1048 2
				} else {
					switch(lpPartFile->GetPriority())
d1051 1
a1051 1
							dc->DrawText(GetResString(IDS_PRIOLOW),GetResString(IDS_PRIOLOW).GetLength(),lpRect, DLC_DT_TEXT);
d1054 1
a1054 1
							dc->DrawText(GetResString(IDS_PRIONORMAL),GetResString(IDS_PRIONORMAL).GetLength(),lpRect, DLC_DT_TEXT);
d1057 1
a1057 1
							dc->DrawText(GetResString(IDS_PRIOHIGH),GetResString(IDS_PRIOHIGH).GetLength(),lpRect, DLC_DT_TEXT);
d1061 2
d1064 13
d1078 5
a1082 4
			case DLCOL_STATUS:		// status
				buffer = lpPartFile->GetPartfileStatus();
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
				break;
d1084 6
a1089 2
			case DLCOL_REMAINING:	// remaining size and %
				if (!IsColumnHidden(DLCOL_REMAINING)) 
d1091 1
a1091 3
					// size 
					uint32 remains;
					remains=lpPartFile->GetFileSize()-lpPartFile->GetCompletedSize();
d1093 3
a1095 3
					if(remains < 0) 
						remains = 0;
					buffer = CastItoXBytes(remains);
d1097 5
a1101 9
					if (lpPartFile->GetStatus()==PS_COMPLETING || lpPartFile->GetStatus()==PS_COMPLETE)
						buffer="";
					else
					{
						float saved = 100.0f - lpPartFile->GetPercentCompleted(); 
						CString str1 = buffer;
						buffer.Format( _T("%s [%.1f%%]"), str1, saved);
					}
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1103 8
a1110 1
			    break;
d1112 1
a1112 2
			case DLCOL_REMAININGTIME:	//remaining time
				if (!IsColumnHidden(DLCOL_REMAININGTIME)) 
d1114 8
a1121 19
					sint32 restTime;
					buffer.Empty();
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
					{
						restTime = lpPartFile->GetTimeRemaining();
						buffer.AppendFormat(_T("%s"), CastSecondsToHM(restTime));
						//bond006 (smoothed "remaining time" calculation) //SyruS
						if(g_eMuleApp.m_pGlobPrefs->GetShowAverageDataRate())
						{
							restTime = lpPartFile->GetTimeRemaining(true);
							buffer.AppendFormat(_T(" (%s)"), CastSecondsToHM(restTime));
						}
					}
					else
					{	//SyruS show total sessiontransfer and sessiontime
						restTime = lpPartFile->GetFlushTimeSpan().GetTotalSeconds();
						buffer.AppendFormat(_T("[%s / %s]"), CastItoXBytes(lpPartFile->GetSessionTransferred()), CastSecondsToHM(restTime));
					}
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1123 4
d1128 4
d1133 2
a1134 2
			case DLCOL_LASTSEENCOMPLETE:	// last seen complete
				if (!IsColumnHidden(DLCOL_LASTSEENCOMPLETE)) 
d1136 2
a1137 4
					if (lpPartFile->lastseencomplete==NULL)
						buffer=GetResString(IDS_NEVER);
					else
					buffer = lpPartFile->LocalizeLastSeenComplete();
d1139 5
a1143 1
					dc->DrawText(buffer,(int)_tcslen(buffer),lpRect, DLC_DT_TEXT);
d1145 8
d1154 7
d1162 5
d1168 2
a1169 1
				if (!IsColumnHidden(DLCOL_LASTRECEIVED)) 
d1171 13
a1183 13
					if (lpPartFile->GetFileDate() == 0)
					{
						buffer = GetResString(IDS_NEVER);
					    dc->DrawText(buffer,(int)_tcslen(buffer),lpRect, DLC_DT_TEXT);
					}
					else
					{					
						CTime ctTime(lpPartFile->GetFileDate());
						SYSTEMTIME st;
						ctTime.GetAsSystemTime(st);
						COleDateTime odtTime(st);
						dc->DrawText(odtTime.Format(), lpRect, DLC_DT_TEXT);
					}
d1185 2
d1188 1
a1188 1

d1190 2
a1191 1
				if (!IsColumnHidden(DLCOL_CATEGORY))
d1193 7
a1199 1
					if (lpPartFile->GetCatID() == 0)
d1201 1
a1201 1
						buffer = GetResString(IDS_CAT_UNCATEGORIZED);
d1205 2
a1206 11
						CCat	*pCat = CCat::GetCatByID(lpPartFile->GetCatID());

						if (pCat != NULL)
						{
							buffer = pCat->GetTitle();
						}
						else
						{
							lpPartFile->SetCatID(0);
							buffer = GetResString(IDS_CAT_UNCATEGORIZED);
						}
a1207 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1209 3
d1213 1
a1213 1

d1215 3
a1217 4
				if (!IsColumnHidden(DLCOL_WAITED))
				{
					CTimeSpan	ts = CTime::GetCurrentTime() - lpPartFile->GetLastDownTransfer();
					long		lWaitedSeconds = ts.GetTotalSeconds();
d1219 7
a1225 6
					if (lWaitedSeconds < 15)
						buffer = "";
					else
						buffer = ::CastSecondsToHM(lWaitedSeconds);
					dc->DrawText(buffer,(int)_tcslen(buffer),lpRect, DLC_DT_TEXT);
				}
d1227 1
a1227 1

d1229 5
a1233 6
				if (!IsColumnHidden(DLCOL_AVGSPEED))
		       	{
					buffer.Empty();
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
					{
						uint32		dRate = lpPartFile->GetAvgDataRate(true);
d1235 2
a1236 6
						if (dRate > 10)
							buffer.Format(_T("%.2f"), dRate/1024.0f);
					}
					else	//SyruS show average sessionrate
						buffer.AppendFormat(_T("[%.2f]"), lpPartFile->GetAvgDataRate(false)/1024.0f);
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1238 5
d1244 1
d1246 5
a1250 1
				if (!IsColumnHidden(DLCOL_AVGREMTIME)) 
d1252 2
a1253 9
					sint32		restTime;

					buffer.Empty();
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
					{
						restTime = lpPartFile->GetTimeRemaining(true);
						buffer.AppendFormat(_T("%s"), CastSecondsToHM(restTime));
					}
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
d1255 3
d1259 1
d1261 5
a1265 1
				if (!IsColumnHidden(DLCOL_ETA)) 
d1267 1
a1267 1
					sint32		restTime;
d1269 1
a1269 2
					buffer.Empty();
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
d1271 2
a1272 1
						restTime = lpPartFile->GetTimeRemaining();
d1274 3
a1276 8
						if (restTime != -1)
						{
							CTime			ctTime;
							SYSTEMTIME		st;

							ctTime = CTime::GetCurrentTime();
							ctTime += CTimeSpan(restTime);
							ctTime.GetAsSystemTime(st);
d1278 1
a1278 1
							COleDateTime	odtTime(st);
d1280 3
a1282 6
							dc->DrawText(odtTime.Format(), lpRect, DLC_DT_TEXT | DT_RIGHT);
						}
					}
					else
					{
						dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1284 4
d1290 1
d1292 5
a1296 1
				if (!IsColumnHidden(DLCOL_AVGETA)) 
d1298 1
a1298 1
					sint32		restTime;
d1300 1
a1300 2
					buffer.Empty();
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
d1302 2
a1303 1
						restTime = lpPartFile->GetTimeRemaining(true);
d1305 3
a1307 8
						if (restTime != -1)
						{
							CTime			ctTime;
							SYSTEMTIME		st;

							ctTime = CTime::GetCurrentTime();
							ctTime += CTimeSpan(restTime);
							ctTime.GetAsSystemTime(st);
d1309 1
a1309 1
							COleDateTime	odtTime(st);
d1311 3
a1313 2
							dc->DrawText(odtTime.Format(), lpRect, DLC_DT_TEXT | DT_RIGHT);
						}
d1315 4
a1318 1
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1321 1
d1323 9
a1331 1
					break;
d1742 24
d1778 2
a1779 1
	if (!lpDrawItemStruct->itemData)
d1782 1
a1782 1
	if(g_eMuleApp.m_pGlobPrefs->DoUseSrcSortCol2() && g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_ShowSrc && m_sortTime+1000<::GetTickCount()) 
d1787 8
a1794 3
	CDC* odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	CMuleCtrlItem* content = (CMuleCtrlItem*)lpDrawItemStruct->itemData;
	BOOL bCtrlFocused = ((GetFocus() == this) || (GetStyle() & LVS_SHOWSELALWAYS));
d1796 4
a1799 1
	if ((content->IsFile()) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d1801 14
a1814 1
		if(bCtrlFocused)
d1818 3
a1820 1
	} else
d1822 1
d1824 8
a1831 11
	CMemDC dc(odc,&CRect(lpDrawItemStruct->rcItem));
	CFont *pOldFont = dc->SelectObject(GetFont());
	COLORREF crOldTextColor = dc->SetTextColor(m_crWindowText);

	BOOL notLast = lpDrawItemStruct->itemID + 1 != GetItemCount();
	BOOL notFirst = lpDrawItemStruct->itemID != 0;
	int tree_start=0;
	int tree_end=0;

	RECT cur_rec;
	memcpy2(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
a1832 4
	//offset was 4, now it's the standard 2 spaces
	int iOffset = dc->GetTextExtent(_T(" "), 1 ).cx * 2;
	CHeaderCtrl *pHeaderCtrl = GetHeaderCtrl();
	int iCount = pHeaderCtrl->GetItemCount();
d1837 8
a1844 7
	if (content->IsFile())
	{		
		for(int iCurrent = 0; iCurrent < iCount; iCurrent++) 
		{
			int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
			int cx = CListCtrl::GetColumnWidth(iColumn);
			if(iColumn == 5)
d1846 3
a1848 2
				int iNextLeft = cur_rec.left + cx;
				//set up tree vars
d1853 2
a1854 1
				//normal column stuff
d1857 1
a1857 1
				DrawFileItem(dc, 5, &cur_rec, content);
d1863 1
a1863 1
				DrawFileItem(dc, iColumn, &cur_rec, content);
d1869 1
a1869 1
	else if (content->IsSource())
d1871 1
a1871 1
		for(int iCurrent = 0; iCurrent < iCount; iCurrent++)
d1873 2
a1874 2
			int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
			int cx = CListCtrl::GetColumnWidth(iColumn);
d1876 1
a1876 1
			if(iColumn == 5)
d1878 3
a1880 2
				int iNextLeft = cur_rec.left + cx;
				//set up tree vars
d1885 1
a1885 1
				//normal column stuff
d1888 1
a1888 1
				DrawSourceItem(dc, 5, &cur_rec, content);
d1894 1
a1894 1
				DrawSourceItem(dc, iColumn, &cur_rec, content);
d1899 5
a1903 4

	//draw rectangle around selected item(s)
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) &&
		(lpDrawItemStruct->itemState & ODS_SELECTED) && (content->IsFile()))
d1919 1
a1919 1
		if(notFirst && (GetItemState(lpDrawItemStruct->itemID - 1, LVIS_SELECTED)))
d1926 1
a1926 1
		if(notLast && (GetItemState(lpDrawItemStruct->itemID + 1, LVIS_SELECTED)))
d1948 1
a1948 1
	//draw focus rectangle around non-highlightable items when they have the focus
d1962 2
a1963 2
	//draw tree last so it draws over selected and focus (looks better)
	if(tree_start < tree_end)
d1974 1
a1974 1
		BOOL hasNext = notLast &&
d1976 3
a1978 3
		BOOL isOpenRoot = hasNext && content->IsFile();
		BOOL isChild = content->IsSource();
		BOOL isExpandable = !isChild && content->GetFile()->GetSourceCount() > 0;
d2024 1
a2024 1
		if(notFirst && isChild)
d2063 1
a2063 1
	if (m_ShowSrc)			//Cax2 check if we don't show sources anymore...
d2065 1
a2065 1
		m_ShowSrc = false; 
d2072 1
a2072 1
				m_ShowSrc = true;
d2077 1
a2077 1
		if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && !m_ShowSrc)	//Cax2 ...& restore the sort index that was there before expanding the files
d2079 3
a2081 3
			m_lastSort = m_iFilesSortIndex;
			m_CurrentSortItem = m_lastSort < 100 ? m_lastSort : m_lastSort - 100;
			SetSortArrow(m_CurrentSortItem, (m_lastSort < 100));
d2133 1
a2133 1
		if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && !m_ShowSrc)		//Cax2 - restore the sort index that was there before opening the files if advanced sort
d2135 1
a2135 1
			m_iFilesSortIndex = m_lastSort; 
d2137 1
a2137 1
		m_ShowSrc = true;  //newsort iNumAdded by Cax2 03/11/02 
d2146 1
a2146 1
		if((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_dblclicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d2148 1
a2148 1
		else if (pPartFile->GetStatus() == PS_COMPLETE && !m_dblclicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d2177 1
a2177 1
				for (MuleIter itItem = m_ListItems.begin(); itItem != m_ListItems.end(); itItem++)
d2214 1
a2214 1
		m_dblclicked = false;
d2224 3
a2226 3
	CTitleMenu		m_ClientMenu;
	CTitleMenu		m_FileMenu;
	CMenu			m_PrioMenu;
d2228 1
a2228 1
	CMenu			m_Web;
d2251 2
a2252 2
			m_FileMenu.CreatePopupMenu();
			m_FileMenu.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));
d2254 9
a2262 9
			m_PrioMenu.CreateMenu();
			m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOLOW, GetResString(IDS_PRIOLOW));
			m_PrioMenu.EnableMenuItem(MP_PRIOLOW,uFlagIfDone);
			m_PrioMenu.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
			m_PrioMenu.EnableMenuItem(MP_PRIONORMAL,uFlagIfDone);
			m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
			m_PrioMenu.EnableMenuItem(MP_PRIOHIGH,uFlagIfDone);
			m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));
			m_PrioMenu.EnableMenuItem(MP_PRIOAUTO,uFlagIfDone);
d2271 2
a2272 2
			m_Web.CreateMenu();
			UpdateURLMenu(m_Web,counter);
d2278 2
a2279 2
			m_FileMenu.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
			m_FileMenu.AppendMenu(MF_SEPARATOR);
d2305 1
a2305 1
			m_FileMenu.AppendMenu(flag|MF_POPUP,(UINT_PTR)catMenu.m_hMenu, GetResString(IDS_CAT_ASSIGN) );
d2307 6
a2312 6
			m_FileMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_PrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
			m_FileMenu.EnableMenuItem((UINT_PTR)m_PrioMenu.m_hMenu, MF_ENABLED);
			m_PrioMenu.CheckMenuItem(MP_PRIOLOW,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_LOW)? MF_CHECKED:MF_UNCHECKED);
			m_PrioMenu.CheckMenuItem(MP_PRIONORMAL,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_NORMAL)? MF_CHECKED:MF_UNCHECKED);
			m_PrioMenu.CheckMenuItem(MP_PRIOHIGH,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_HIGH)? MF_CHECKED:MF_UNCHECKED);
			m_PrioMenu.CheckMenuItem(MP_PRIOAUTO, (justOne && file->IsAutoPrioritized())? MF_CHECKED:MF_UNCHECKED);
d2314 2
a2315 2
			m_FileMenu.AppendMenu(MF_STRING,MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL));
			m_FileMenu.EnableMenuItem(MP_CANCEL,(!filedone) ? MF_ENABLED:MF_GRAYED);
d2317 2
a2318 2
			m_FileMenu.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP));
			m_FileMenu.EnableMenuItem(MP_STOP,((status != PS_STOPPED && status != PS_ERROR && !filedone ) ? MF_ENABLED:MF_GRAYED));
d2320 2
a2321 2
			m_FileMenu.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE));
			m_FileMenu.EnableMenuItem(MP_PAUSE,((status != PS_PAUSED && status != PS_STOPPED && status != PS_ERROR && !filedone) ? MF_ENABLED:MF_GRAYED));
d2323 2
a2324 2
			m_FileMenu.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME));
			m_FileMenu.EnableMenuItem(MP_RESUME,((status == PS_PAUSED || status == PS_STOPPED) ? MF_ENABLED:MF_GRAYED));
d2326 2
a2327 2
			m_FileMenu.AppendMenu(MF_STRING,MP_INITIALIZE, GetResString(IDS_DL_INITIALIZE));
			m_FileMenu.EnableMenuItem(MP_INITIALIZE,(justOne && status == PS_ERROR) ? MF_ENABLED:MF_GRAYED);
d2329 1
a2329 1
			m_FileMenu.AppendMenu(MF_SEPARATOR);
d2331 2
a2332 2
			m_FileMenu.AppendMenu(MF_STRING,MP_OPEN, GetResString(IDS_DL_OPEN));
			m_FileMenu.EnableMenuItem(MP_OPEN,((justOne && status == PS_COMPLETE) ? MF_ENABLED:MF_GRAYED));
d2334 1
a2334 1
			m_FileMenu.AppendMenu(MF_STRING,MP_MOVIE, GetResString(IDS_MOVIE));
d2337 1
a2337 1
				m_FileMenu.CheckMenuItem(MP_MOVIE,(file->GetMovieMode() != 0)?MF_CHECKED:MF_UNCHECKED);
d2339 1
a2339 1
				m_FileMenu.EnableMenuItem(MP_MOVIE, MF_GRAYED);
d2341 2
a2342 2
			m_FileMenu.AppendMenu(MF_STRING,MP_PREVIEW, GetResString(IDS_DL_PREVIEW));
			m_FileMenu.EnableMenuItem(MP_PREVIEW,((justOne && file->PreviewAvailable()) ? MF_ENABLED:MF_GRAYED));
d2344 2
a2345 2
			m_FileMenu.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO));
			m_FileMenu.EnableMenuItem(MP_METINFO,(justOne)?MF_ENABLED:MF_GRAYED); // Cax2
d2347 2
a2348 2
			m_FileMenu.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL));
			m_FileMenu.EnableMenuItem(MP_VIEWFILECOMMENTS,(justOne && (file->HasComment() || file->HasRating())) /*&& !filedone*/ ?MF_ENABLED:MF_GRAYED); // Cax2  //netwolf: no comments on complete files	// netwolf 06.05.03 only enabled if there is a comment/rating	// #zegzav:pastcomment; allow to see past comments for completed files
d2350 2
a2351 2
			m_FileMenu.AppendMenu(MF_STRING,MP_CHANGEDIR, GetResString(IDS_CHANGEDIR)); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
			m_FileMenu.EnableMenuItem(MP_CHANGEDIR, !filedone ? MF_ENABLED:MF_GRAYED); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
d2354 2
a2355 2
			m_FileMenu.AppendMenu(MF_STRING,MP_DOCLEANUP, GetResString(IDS_DOCLEANUP));
			m_FileMenu.EnableMenuItem(MP_DOCLEANUP, !filedone ? MF_ENABLED:MF_GRAYED);
d2357 1
a2357 1
			m_FileMenu.AppendMenu(MF_SEPARATOR);
d2359 2
a2360 2
			m_FileMenu.AppendMenu(MF_STRING,MP_DROPNONEEDEDSRCS, GetResString(IDS_DROPNONEEDEDSRCS)); // Tarod
			m_FileMenu.EnableMenuItem(MP_DROPNONEEDEDSRCS,((status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED)); // Added by Tarod	// netwolf 07.05.03
d2362 3
a2364 3
            m_FileMenu.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED));
			m_FileMenu.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, file->GetDiscardSuperCompressed() ? MF_CHECKED:MF_UNCHECKED);
			m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, ((status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));	//netwolf: no dropSCB on complete/ing) files
d2366 2
a2367 2
			m_FileMenu.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE)); // Tarod
			m_FileMenu.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(justOne && status != PS_COMPLETE && status != PS_COMPLETING)?MF_ENABLED:MF_GRAYED); // Tarod(+Cax2 Patch 21/12/02)	//netwolf 07.05.03
d2371 1
a2371 1
			m_FileMenu.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,buffer); // Tarod
d2374 2
a2375 2
				m_FileMenu.CheckMenuItem(MP_ALL_A4AF_AUTO, (file== g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile()) ? MF_CHECKED:MF_UNCHECKED); // Tarod
				m_FileMenu.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_ENABLED);
d2377 2
a2378 2
				m_FileMenu.CheckMenuItem(MP_ALL_A4AF_AUTO, MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_ALL_A4AF_AUTO, MF_GRAYED);
d2381 1
a2381 1
			m_FileMenu.AppendMenu(MF_SEPARATOR);
d2383 1
a2383 1
			m_FileMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_ed2kMenu.m_hMenu, GetResString(IDS_ED2KLINKFIX));
d2385 1
a2385 1
			m_FileMenu.AppendMenu(flag|MF_POPUP,(UINT_PTR)m_Web.m_hMenu, GetResString(IDS_WEBSERVICES));
d2387 3
a2389 3
			m_FileMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
//			m_FileMenu.RemoveMenu(28,MF_BYPOSITION);
			m_PrioMenu.DestroyMenu();
d2391 2
a2392 2
			m_Web.DestroyMenu();
			m_FileMenu.DestroyMenu();
d2401 2
a2402 2
			m_ClientMenu.CreatePopupMenu();
			m_ClientMenu.AddMenuTitle(GetResString(IDS_CLIENTS));
d2404 1
a2404 1
			m_ClientMenu.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
d2406 1
a2406 1
				m_ClientMenu.AppendMenu(MF_STRING,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d2408 3
a2410 3
				m_ClientMenu.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
			m_ClientMenu.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG));
			m_ClientMenu.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
d2412 1
a2412 1
				m_ClientMenu.AppendMenu(MF_STRING,MP_DOWNNOW, GetResString(IDS_DOWNLOAD_A4AF)); // Ambdribant
d2414 2
a2415 2
			m_ClientMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
			m_ClientMenu.DestroyMenu();
d2418 5
a2422 5
		m_FileMenu.CreatePopupMenu();
		m_FileMenu.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));
		m_FileMenu.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
		m_FileMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
		m_FileMenu.DestroyMenu();
d2916 19
d2941 5
a2945 5
	m_SortAscending = (m_CurrentSortItem != pNMListView->iSubItem) ? true : !m_SortAscending;
	m_CurrentSortItem = pNMListView->iSubItem;
	SetSortArrow(m_CurrentSortItem, m_SortAscending);
	m_lastSort=m_CurrentSortItem + (m_SortAscending ? 0:100);	//Cax2 - more than 10 columns
	SortItems(SortProc, m_CurrentSortItem + (m_SortAscending ? 0:100)+(m_ShowSrc?1000:0)); // Cax2
d3034 1
a3034 1
	for (MuleIter it = m_ListItems.begin(); it != m_ListItems.end();)
d3058 1
a3058 1
	for(MuleIter g = m_ListItems.begin(); g != m_ListItems.end(); )
d3105 1
a3105 1
	m_sortTime=::GetTickCount();
d3107 1
a3107 1
		m_lastSort -= (m_lastSort >= 0) ? 10000 : 0;	//simple override, keep the old sorting column, restore it later...
d3110 3
a3112 3
		m_lastSort=g_eMuleApp.m_pGlobPrefs->GetDownloadSortCol();
		m_CurrentSortItem=(m_lastSort<100)?m_lastSort:m_lastSort-100;
		SetSortArrow(m_CurrentSortItem,(m_lastSort<100));
d3114 1
a3114 1
	if(m_ShowSrc)
d3116 1
a3116 1
		if(g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_lastSort<0)
d3130 1
a3130 1
		if (m_lastSort<0)
d3134 1
a3134 1
			SortItems(&SortProc, m_lastSort);
a3221 1
		//	TODO: Make sort by immediate/average selectable
d3754 1
a3754 1
	m_dblclicked=true;
d3815 1
a3815 1
	for (MuleIter itItem = m_ListItems.begin(); itItem != m_ListItems.end(); itItem++)
d3825 1
a3825 1
				for (MuleIter itItem2 = m_ListItems.begin(); itItem2 != m_ListItems.end(); itItem2++)
d3919 1
a3919 1
	for (MuleIter it = m_ListItems.begin(); it != m_ListItems.end(); it++)
d3946 1
a3946 1
	for(MuleIter g = m_ListItems.begin(); g != m_ListItems.end(); g++)
d3981 1
a3981 1
	for(MuleIter g = m_ListItems.begin(); g != m_ListItems.end(); g++)
d4076 1
a4076 1
	for(MuleIter it = m_ListItems.begin(); it != m_ListItems.end(); it++)
d4099 1
a4099 1
	MuleRange		rangeIt = m_ListItems.equal_range(pSource);
d4128 1
a4128 1
	MuleRange		rangeIt = m_ListItems.equal_range(tohide);
d4155 1
a4155 1
	MuleRange		rangeIt = m_ListItems.equal_range(pPartFileToShow);
d4184 1
a4184 1
	MuleRange		rangeIt = m_ListItems.equal_range(pSource);
d4202 1
a4202 1
			MuleIter		g = m_ListItems.find(updateItem->GetFile());
d4205 1
a4205 1
			if (g != m_ListItems.end())
@


1.255
log
@Localization fixes
@
text
@d1437 1
a1437 1
						buffer.Format(_T("%.1f %s"), nDownloadDataRate/1024.0f,GetResString(IDS_KBYTESEC));
@


1.254
log
@Final code merge from official for preview
@
text
@d127 1
a127 2
	CString		strSpeed;

d150 1
a150 2
	CString		strAvgSpeed;

d254 3
a256 1
		strRes = GetResString(IDS_DL_SPEED);
@


1.253
log
@Official code merge (katsyonak)
@
text
@d135 2
a136 2
	InsertColumn(DLCOL_REMAINING,GetResString(IDS_DL_REMAINS),LVCFMT_RIGHT, 110);
	
d2176 1
a2176 1
			if(justOne && !file->FirstLastLoaded())	//Cax2 - greyed out if we have those chunks
a2177 1
				//m_FileMenu.EnableMenuItem(MP_MOVIE,(file->IsArchive())?MF_GRAYED:MF_ENABLED);
@


1.252
log
@added localization for new DL columns
@
text
@d2167 3
d2173 1
a2173 1
			m_FileMenu.EnableMenuItem(MP_OPEN,((justOne && status == PS_COMPLETE) ? MF_ENABLED:MF_GRAYED)); //<<--9/21/02
d2176 1
a2176 1
			if(file->IsMovie() && justOne && !file->FirstLastLoaded())	//Cax2 - greyed out if we have those chunks
d2481 9
@


1.251
log
@Improved sort order for all "Time Remaining" and "ETA" columns.
@
text
@d324 20
@


1.250
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d3056 2
d3063 2
d3150 2
d3157 2
d3185 2
d3194 2
d3220 2
d3229 2
@


1.249
log
@Added download list columns for average speed, averaged time remaining, ETA, and averaged ETA. Renamed "Time" column to "Remaining Time".
@
text
@d1731 4
a1734 1
		dc->FrameRect(&outline_rec, &CBrush(GetBkColor()));
d1755 6
a1760 1
			dc->FrameRect(&outline_rec, &CBrush(m_crFocusLine));
d1762 6
a1767 1
			dc->FrameRect(&outline_rec, &CBrush(m_crNoFocusLine));
d1770 1
a1770 2
	else if (((lpDrawItemStruct->itemState & ODS_FOCUS) == ODS_FOCUS) &&
		(GetFocus() == this))
d1777 4
a1780 1
		dc->FrameRect(&focus_rec, &CBrush(m_crNoFocusLine));
d1829 4
a1832 1
			dc->FrameRect(&circle_rec, &CBrush(dc->GetTextColor()));
@


1.248
log
@Fixed sorting stability for "zero" progress files sorted by progess.
@
text
@d126 5
a130 1
	InsertColumn(DLCOL_SPEED,GetResString(IDS_DL_SPEED),LVCFMT_RIGHT, 65);
d135 1
a135 1
	InsertColumn(DLCOL_REMAINING,GetResString(IDS_DL_REMAINS),LVCFMT_LEFT, 110);
d138 1
a138 1
	InsertColumn(DLCOL_TIME,GetResString(IDS_TIME),LVCFMT_LEFT, 110); // should be est. time or ETA
d151 8
d666 1
a666 1
		switch(nColumn)
a875 2
					if (!buffer.IsEmpty())
						buffer.Append(GetResString(IDS_KBYTESEC));
d1016 2
a1017 2
			case DLCOL_TIME:	//remaining time
				if (!IsColumnHidden(DLCOL_TIME)) 
d1109 89
d1568 1
a1568 1
			case DLCOL_TIME:	// remaining time
d2997 2
d3033 1
a3033 1
		case DLCOL_TIME: //Remaining Time asc
d3035 7
a3041 2
			int		tmp1 = file1->GetTimeRemaining();
			int		tmp2 = file2->GetTimeRemaining();
d3043 1
a3043 5
			if (tmp1 > 0 && tmp2 > 0)
			{ 
				iCompare = tmp1-tmp2;
			}
			if (tmp1 > 0 || tmp2 > 0)
d3045 1
a3045 1
				iCompare = tmp2-tmp1; 
d3116 98
@


1.247
log
@Fix for forced sharing (root dirs)
Added filtering to GUI queue
@
text
@d2904 2
@


1.246
log
@Stabilized source sorting by adding a secondary sort on source name.
@
text
@d2434 2
@


1.245
log
@Stabilized file sorting by adding a secondary sort on file name.
@
text
@d3024 2
d3027 1
d3031 1
a3031 1
	switch(lParamSort)
d3033 30
a3062 1
		case 0: //name asc
d3064 1
a3064 8
				CString sName1, sName2;
				try{ sName1 = CString(client1->GetUserName()); }
				catch(...){ sName1 = _T(""); }
				try{ sName2 = CString(client2->GetUserName()); }
				catch(...){ sName2 = _T(""); }
				if  (sName1.IsEmpty() || sName2.IsEmpty())
					return (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0:sortMod):-1*sortMod;	//Cax2 append all unknown ones at the end
				return _tcsicmp(sName1, sName2);
d3066 1
a3066 1
		case 2: //transferred asc
d3068 18
a3085 2
				if(!g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
			        return CompareUnsigned(client1->GetTransferredDown(), client2->GetTransferredDown());
d3087 7
a3093 1
	                return 0;
d3095 5
a3099 1
		case 3://completed asc
d3101 8
a3108 2
				if(g_eMuleApp.m_pGlobPrefs->IsTransferredOnCompleted())
			        return CompareUnsigned(client1->GetTransferredDown(), client2->GetTransferredDown());
d3110 3
a3112 1
					return 0;
d3114 25
a3138 29
		case 4: //speed asc
				return CompareUnsigned(client1->GetDownloadDataRate(), client2->GetDownloadDataRate());
		case 5: //progress asc
				return client1->GetAvailablePartCount() - client2->GetAvailablePartCount();
		case 6: //sources column
			{
				if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )
					return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;		//Cax2 append all unknown ones at the end
				if(client1->GetClientSoft() == client2->GetClientSoft())
					if(client1->IsEmuleClient())
					{
						uint32 plus1=(client1->PlusVersion()<0x2600)?client1->PlusVersion():0;
						uint32 plus2=(client2->PlusVersion()<0x2600)?client2->PlusVersion():0;
						if(plus1 && plus2) 
							return plus2-plus1;
						if(plus1 || plus2)
							return (plus1)?-1:1;
						if (client1->GetMuleVersion() == client2->GetMuleVersion() )
						{
							if (!client1->GetModVersion().IsEmpty() && !client2->GetModVersion().IsEmpty())
								return _tcsicmp(client1->GetModVersion(), client2->GetModVersion());
							if (!client1->GetModVersion().IsEmpty() || !client2->GetModVersion().IsEmpty())
								return (client1->GetModVersion().IsEmpty()) ? 1 : -1;
						}
						return client2->GetMuleVersion() - client1->GetMuleVersion();
					}
					else
						return client2->GetVersion() - client1->GetVersion();
				return client1->GetClientSoft() - client2->GetClientSoft();
d3140 1
a3140 1
		case 7: //priority column - QR
d3142 12
a3153 1
				if (client1->GetDownloadState()!=DS_ONQUEUE || client2->GetDownloadState()!=DS_ONQUEUE)	//Cax2 QR gaps bugfix
d3155 10
a3164 30
					if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
						return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
					if (client1->GetDownloadState()==DS_DOWNLOADING || client2->GetDownloadState()==DS_DOWNLOADING)		//Cax2 QR gaps bugfix
						return (client1->GetDownloadState()==DS_DOWNLOADING)?((client2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2; //Cax2 QR gaps bugfix
					return (client1->GetDownloadState()!=DS_ONQUEUE)?((client2->GetDownloadState()!=DS_ONQUEUE)?0:sortMod):-1*sortMod;		//Cax2 now should show properly...
				}
				if (sortMod<0 || (client1->GetRemoteQueueRank()>0 && client2->GetRemoteQueueRank()>0))
					return client1->GetRemoteQueueRank() - client2->GetRemoteQueueRank();   
				if(client1->GetRemoteQueueRank()==0 && client2->GetRemoteQueueRank()==0)
					return (client1->IsEmuleClient())?((client2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
				return (client1->GetRemoteQueueRank()==0)?((client2->GetRemoteQueueRank()==0)?0:2):-1;
			}
		case 8: //Status column - Lord KiRon
			return client1->GetDownloadStateAsString().Compare(client2->GetDownloadStateAsString()); 
		case 11: // UL/DL column - Maverick
		case 12: // Ratio column - Maverick
			{	//Cax2 - faster this way & less code to go wrong...
				if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )	//Cax2 append all unknown ones at the end
					return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;					//Cax2 append all unknown ones at the end
				bool isValid1 = (client1->IsRemoteInfoAvaiable()|| client1->credits);
				bool isValid2 = (client2->IsRemoteInfoAvaiable()|| client2->credits);
				if ( lParamSort==10 && isValid1 && isValid2)											//Cax2 - bugfix after reCDVst changes 
					return (client1->GetRemoteBaseModifier() <client2->GetRemoteBaseModifier())?-1:1;	//Cax2 - has to return an integer!
				if (isValid1 && isValid2)																//Cax2 - it's got to be lParamSort==11 after reCDVst changes 
					return client1->GetRemoteRatio() - client2->GetRemoteRatio();
				if (isValid1)				
					return 1;
				if (isValid2)				
					return -1;
				return 0;
d3166 2
a3167 2
		default:
			return 0;
d3170 17
d3188 1
a3188 1
	return 0;
@


1.244
log
@Formatting, comments, and name changes.
@
text
@d2838 2
a2839 1
int CDownloadListCtrl::Compare(CPartFile* file1, CPartFile* file2, LPARAM lParamSort) 
d2841 17
d2864 1
a2864 1
	switch(lParamSort)
d2867 15
a2881 15
            // obaldin: funny, but we might not have a filename yet..
            {
                CString fname1=file1->GetFileName();
                CString fname2=file2->GetFileName();
                if  (fname1.IsEmpty() || fname2.IsEmpty())
                {   
					return 0;
				}
                else
			    {   
					return _tcsicmp(fname1,fname2);
				}
            }
		case 1: //size asc
			return (file1->GetFileSize()== file2->GetFileSize())?0:((file1->GetFileSize() < file2->GetFileSize())?-1:1);		//sort for >2gb
d2883 4
a2886 1
			return CompareUnsigned(file1->GetTransferred(), file2->GetTransferred());
d2888 4
a2891 1
			return CompareUnsigned(file1->GetCompletedSize(), file2->GetCompletedSize());
d2893 5
a2897 2
			//	TODO: Make sort by immediate/average selectable
			return CompareUnsigned(file1->GetDataRate(), file2->GetDataRate());
d2899 6
a2904 4
			{
				float comp = file1->GetPercentCompleted() - file2->GetPercentCompleted();
				return (comp > 0) ? 1 : ((comp < 0) ? -1 : 0);
			}
d2906 4
a2909 1
			return file1->GetSourceCount() - file2->GetSourceCount();
d2911 4
a2914 1
			return file1->GetPriority() - file2->GetPriority();
d2916 8
a2923 2
			{
				int comp = file1->getPartfileStatusRang() - file2->getPartfileStatusRang();
d2925 7
a2931 5
				// Second sort order on filename
				if(comp == 0) 
				{
					comp = _tcsicmp(file1->GetFileName(), file2->GetFileName());
				}
d2933 3
a2935 1
				return comp;
d2937 1
a2937 1
		case DLCOL_REMAINING: //Remaining size asc
d2939 12
a2950 3
				int tmp1=file1->GetFileSize()-file1->GetCompletedSize();
				int tmp2=file2->GetFileSize()-file2->GetCompletedSize();
				return (tmp1==tmp2)?0:((tmp1<tmp2)?-1:1); 
d2952 3
a2954 27
		case DLCOL_TIME: //Remaining Time asc
			{
				int tmp1=file1->GetTimeRemaining();
				int tmp2=file2->GetTimeRemaining();
				if (tmp1 > 0 && tmp2 > 0)
				{ 
					return tmp1-tmp2 ;
				}
				if (tmp1 > 0 || tmp2 > 0)
				{
					return tmp2-tmp1; 
				}
				//if no remaining time sort by remaining size asc. Leave completed files last...
				tmp1=(file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE);
				tmp2=(file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE);
				if ((tmp1) && (tmp2))
				{	
					return 0;
				}
				if (tmp2)
				{	
					return -1;
				}
				if (tmp1)
				{	
					return 1;
				}
d2956 2
d2959 1
d2962 1
a2962 1
				return 1;
d2966 1
a2966 1
				return -1;
d2970 1
a2970 1
				return 0;
d2972 2
d2975 1
d2978 1
a2978 1
				return 1;
d2980 1
a2980 1
			else if(file1->GetFileDate() < file2->GetFileDate())
d2982 1
a2982 1
				return -1;
d2986 1
a2986 1
				return 0;
d2989 1
d2998 1
a2998 1
				return 1;
d3000 1
a3000 1
				return -1;
d3002 1
a3002 1
				return 0;
d3009 2
a3010 1
			return (ts1 > ts2) ? 1 : ((ts1 < ts2) ? -1 : 0);
a3011 3
		break;
		default:
			return 0;
d3014 3
d3019 1
a3019 1
	return 0;
d3022 1
a3022 1
int CDownloadListCtrl::Compare(CUpDownClient* client1,CUpDownClient* client2, LPARAM lParamSort, int sortMod) 
@


1.243
log
@Changed .movie files to .settings and added stopped status knowledge
@
text
@d1037 1
a1037 1
					buffer = lpPartFile->localelastseencomplete();
@


1.242
log
@Reverted code change by another commit
@
text
@d2493 1
a2493 1
							file->SaveMovieMode();
d2511 1
a2511 1
							file->SaveMovieMode();
d2525 1
a2525 1
							selFile->SaveMovieMode();
a2529 8
					/*
					if (!(file->GetStatus()==PS_COMPLETE) && !(file->GetStatus()==PS_COMPLETING))
					{
                        file->SetDiscardSuperCompressed( !file->GetDiscardSuperCompressed() );
                        file->SaveMovieMode();
                    }
                    break;
                    */
@


1.241
log
@Fixed bug "crash on unassign category from file context menu". Fixed bug "Can't expand/collapse files".
@
text
@d1850 1
a1850 3
		if ((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_dblclicked)
		{
			if (!g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d1852 1
a1852 4
		}
		else if (pPartFile->GetStatus() == PS_COMPLETE && !m_dblclicked)
		{
			if (!g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
a1853 1
		}
@


1.240
log
@Reduced MP_WEBURL to 64 options
@
text
@d733 4
d738 2
a739 6
							iIcon = ICON_RATING_NO;

							if (lpPartFile->HasRating())
							{
				        		switch (lpPartFile->GetRating())
				        		{
d758 2
a759 3
									default:
										iIcon=ICON_RATING_NO;
								}
d761 2
a762 1
							POINT	point= {r.left-4,r.top+3};
d764 3
a766 3
							m_imageList.Draw(dc, iIcon, point, ILD_NORMAL);
						}
						r.left += OFFSET_RATINGICON;
d1850 3
a1852 1
		if((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_dblclicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d1854 4
a1857 1
		else if (pPartFile->GetStatus() == PS_COMPLETE && !m_dblclicked && !g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
d1859 2
a1860 1
		// Check if the source branch is disable
d1943 2
a1944 2
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
		const CPartFile* cFile=NULL; //Cax2 bugfix for Dr Slump? start
d1949 1
a1949 1
		if (cFile!=NULL)
d1951 4
a1954 4
			CPartFile* file=(CPartFile*)cFile; //Cax2 bugfix
			bool filedone=(file->GetStatus()==PS_COMPLETE || file->GetStatus()==PS_COMPLETING);
			bool justOne=(GetSelectedCount()==1); //Cax2 faster code
			int status=file->GetStatus();
d1959 1
a1959 1
			UINT uFlagIfDone	=	filedone?MF_GRAYED:MF_ENABLED;
d1979 1
a1979 1
			int counter;
d1984 1
a1984 1
			UINT flag;
d1986 1
a1986 1
			flag=(counter==0) ? MF_GRAYED:MF_STRING;
d2175 6
a2180 1
					CPartFile *selected = selectedList.GetHead();
d2182 6
a2187 1
					selected->SetCatID(CCat::GetCatIDByIndex(CCat::UserCatIndexToCatIndex(wParam - MP_ASSIGNCAT)));
@


1.239
log
@Fix to my fix (Thx morevit)
@
text
@d2159 1
a2159 1
			if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+256) 
@


1.238
log
@Category rewrite with predefined status/media type categories.
@
text
@d1850 4
a1853 6
		if ((pPartFile->GetStatus() == PS_PAUSED || pPartFile->GetStatus() == PS_STOPPED) && !m_dblclicked)
			if(!g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
				pPartFile->ResumeFile();
		else if (pPartFile->GetStatus() == PS_COMPLETE && !m_dblclicked) 
			if(!g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons())
				ClearCompleted(pPartFile->GetFileHash());
d3132 1
a3132 10
			{	
				    CPartFile *pPartFile = pListItem->GetFile();

				    if (pPartFile == NULL)
					return;
				if(pPartFile->GetStatus() == PS_PAUSED)
					pPartFile->ResumeFile();
				else
					OnItemActivate(pNMHDR, pResult);
			}
@


1.237
log
@Changed preferences (added some missing ones)
Updated unpause/clearcomplete when using FileStatus icons
@
text
@d57 14
d73 2
d84 1
a84 1

d106 1
a106 1

a191 1
	m_nCurTab = 0;
d207 3
d212 1
a212 1

d307 5
d334 1
a334 1
		if (CheckShowItemInGivenCat(pFileToAdd, m_nCurTab ))
d772 1
a772 1
					COLORREF	cr = (g_eMuleApp.m_pGlobPrefs->GetCatColor(lpPartFile->GetCategory())>0)?g_eMuleApp.m_pGlobPrefs->GetCatColor(lpPartFile->GetCategory()):(::GetSysColor(COLOR_WINDOWTEXT));
d775 1
d1065 1
a1065 2

					if(lpPartFile->GetCategory() == 0)
d1067 1
a1067 1
						buffer = GetResString(IDS_ALLOTHERS);
d1071 3
a1073 2
						Category_Struct *pCatStruct = g_eMuleApp.m_pGlobPrefs->GetCategory(lpPartFile->GetCategory());
						if(pCatStruct != NULL)
d1075 1
a1075 1
							buffer = pCatStruct->title;
d1079 2
a1080 2
							lpPartFile->SetCategory(0);
							buffer = GetResString(IDS_ALLOTHERS);
a1082 1

d1086 1
a1792 16

BEGIN_MESSAGE_MAP(CDownloadListCtrl, CMuleListCtrl)
	ON_NOTIFY_REFLECT(LVN_ITEMACTIVATE, OnItemActivate)
	ON_NOTIFY_REFLECT(LVN_ITEMCHANGED, OnListModified)
	ON_NOTIFY_REFLECT(LVN_INSERTITEM, OnListModified)
	ON_NOTIFY_REFLECT(LVN_DELETEITEM, OnListModified)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMDblclkDownloadlist)
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)	
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
	ON_WM_SIZE()
	ON_WM_KEYUP()
	ON_WM_KEYDOWN()
END_MESSAGE_MAP()
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d1936 1
d1942 1
d1956 1
d1976 1
d1979 1
d1981 1
a1986 1
#ifdef LATER
d1989 1
a1989 1
			int				iNumPermanentCats = CCat::GetNumPermanentCats();
d1994 1
a1994 1
			if (CCat::GetNumCats() > iNumPermanentCats)
d2008 1
a2008 1
			//	If there are only permanent cats, gray the assign menu
a2011 1
#endif LATER
d2167 1
a2167 1
			if (wParam>=MP_ASSIGNCAT && wParam<=MP_ASSIGNCAT+99) 
d2172 2
a2173 1
					selected->SetCategory(wParam-MP_ASSIGNCAT);
d2176 6
a2181 1
				ChangeCategory(m_nCurTab);
d2702 1
a2702 1

d2715 1
a2715 1
			if (pPartFile->IsPartFile() == false && (CheckShowItemInGivenCat(pPartFile,m_nCurTab) || bIgnoreCats) )
d2722 1
a2722 1

d2763 1
a2763 1

d2954 13
a2966 3
			return _tcsicmp(
			(file1->GetCategory()!=0)?g_eMuleApp.m_pGlobPrefs->GetCategory(file1->GetCategory())->title:GetResString(IDS_ALL),
			(file2->GetCategory()!=0)?g_eMuleApp.m_pGlobPrefs->GetCategory(file2->GetCategory())->title:GetResString(IDS_ALL));
d2983 1
a2983 1

d3089 1
a3089 1

d3175 1
a3175 1

d3220 1
a3220 1

d3230 1
a3230 1

d3262 1
a3262 1

d3388 1
a3388 1
			if (CheckShowItemInGivenCat(file,m_nCurTab))
d3438 1
a3438 1

d3515 5
d3521 10
a3530 1
void CDownloadListCtrl::ChangeCategory(int newsel)
d3532 1
a3532 1
	EMULE_TRY
d3534 2
a3535 1
	SetRedraw(FALSE);
d3537 1
a3537 1
	// remove all displayed files with a different cat and show the correct ones
d3540 3
a3542 2
		const CMuleCtrlItem* cur_item = it->second;
		if (cur_item->IsFile())
d3544 1
a3544 1
			CPartFile* file = cur_item->GetFile();
d3546 1
a3546 2
			if ( !CheckShowItemInGivenCat(file,newsel))
			{ 
a3547 1
			}
a3548 1
			{
d3550 1
a3550 1
			}
a3554 1
	m_nCurTab=newsel;
a3555 2

	EMULE_CATCH
a3690 41
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadListCtrl::MoveCompletedfilesCat(uint8 from, uint8 to)
{
	EMULE_TRY

	uint8 mycat;

	for(MuleIter it = m_ListItems.begin(); it != m_ListItems.end();)
	{
		CMuleCtrlItem* cur_item = it->second;
		it++; // Already point to the next iterator.
		if(cur_item->IsFile())
		{
			CPartFile* file = cur_item->GetFile();
			if (!file->IsPartFile())
			{
				mycat=file->GetCategory();
				if ( mycat>=min(from,to) && mycat<=max(from,to)) 
				{
					if (mycat==from) 
					{	
						file->SetCategory(to); 
					}
					else
					{	
						if (from<to)
						{
							file->SetCategory(mycat-1);
						}
						else 
						{
							file->SetCategory(mycat+1);
						}
					}
				}
			}
		}
	}

	EMULE_CATCH
@


1.236
log
@Minor GUI fix
@
text
@d1843 2
a1844 1
			pPartFile->ResumeFile();
d1846 2
a1847 1
			ClearCompleted(pPartFile->GetFileHash());
@


1.235
log
@Added new hotkey Ctrl-Alt-Shift 'U' which expands all files but filters so only uploading sources show.
@
text
@d691 1
a691 1
				//	DropF START - Show a heart if the file is A4AF auto
d694 1
a694 1
				//	DropF END - Show a heart if the file is A4AF auto
d707 1
a707 1
			        if ( !g_eMuleApp.m_pGlobPrefs->GetDisableRatingIcons() && ( lpPartFile->HasComment() || lpPartFile->HasRating() ))
d709 3
a711 1
						iIcon = ICON_RATING_NO;
d713 25
a737 12
						if (lpPartFile->HasRating())
						{
				        	switch (lpPartFile->GetRating())
				        	{
							case PF_RATING_NONE:		iIcon = ICON_RATING_NO;	break; 
							case PF_RATING_FAKE:		iIcon = ICON_RATING_FAKE;	break; 
							case PF_RATING_POOR:		iIcon = ICON_RATING_POOR;	break; 
							case PF_RATING_GOOD:		iIcon = ICON_RATING_GOOD;	break; 
							case PF_RATING_FAIR:		iIcon = ICON_RATING_FAIR;	break; 
							case PF_RATING_EXCELLENT:	iIcon = ICON_RATING_EXCELLENT;	break;
								default:
								iIcon=ICON_RATING_NO;
d739 3
d743 1
a743 3
					    POINT	point= {r.left-4,r.top+3};

						m_imageList.Draw(dc, iIcon, point, ILD_NORMAL);
a744 1
				    r.left += OFFSET_RATINGICON;
@


1.234
log
@(Ok, one _little_ logic change) Added "Waited" column to download list.
@
text
@d3227 43
d3278 1
a3278 1
	if (isShift && isCtrl && isAlt && nChar == 'M')
d3280 10
a3289 3
		g_eMuleApp.m_pGlobPrefs->SetShowFullFileStatusIcons(!g_eMuleApp.m_pGlobPrefs->ShowFullFileStatusIcons());
		g_eMuleApp.m_pGlobPrefs->SetShowPausedGray(!g_eMuleApp.m_pGlobPrefs->ShowPausedGray());
		Invalidate();
d3296 1
a3296 1

@


1.233
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@a128 1
#ifdef LATER
a129 1
#endif
a1047 1
#ifdef LATER
a1059 1
#endif LATER
d2891 1
a2891 1
		case 13: //Last seen complete asc 
a2921 1
#ifdef LATER
a2929 1
#endif LATER
@


1.232
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d177 1
a177 1
	LoadSettings(CPreferences::tableDownload);
d188 2
a189 2
		int sortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::tableDownload);
		bool sortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::tableDownload);
@


1.231
log
@Got rid of one last bad reference to 'CPartFile::srcsarevisible'.
@
text
@d1400 1
a1400 5
				#ifndef AMD
				memcpy(&cur_rec, lpRect, sizeof(RECT));
				#else
				memcpy_amd(&cur_rec, lpRect, sizeof(RECT));
				#endif
d1519 1
a1519 5
	#ifndef AMD
	memcpy(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
	#else
	memcpy_amd(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
	#endif
d1593 1
a1593 5
		#ifndef AMD
		memcpy(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
		#else
		memcpy_amd(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
		#endif
@


1.230
log
@changed back wrongly renamed filename of ipfilter.dat and folder of webserver icons
@
text
@d375 1
a375 1
	if (!pOwner->srcarevisible)
@


1.229
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d3603 1
@


1.228
log
@// DropF  - Show a heart if the file is A4AF auto
@
text
@d43 3
a45 1
bool IsAskedForAnotherFile(ST_CTRLITEM *pItem)
d47 1
a47 27
	if(pItem == NULL)
	{
		return false;	// hmm....
	}

	if(pItem->eType == AVAILABLE_SOURCE || pItem->eType == UNAVAILABLE_SOURCE)
	{
		CUpDownClient* pClient = (CUpDownClient*)pItem->pValue;
		CPartFile* pParent = (CPartFile*)pItem->pOwner;
		
		return (pClient->reqfile != pParent);
	}

	return false;
}

CPartFile* GetFile(ST_CTRLITEM *pItem)
{
	if(pItem == NULL)
	{
		return NULL;
	}
	if(pItem->eType == FILE_TYPE)
	{
		return (CPartFile*)pItem->pValue;
	}
	return (CPartFile*)pItem->pParent->pValue;
d49 2
d86 1
a86 1
	m_pImageList.DeleteImageList();	//eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d133 42
a174 32
	m_pImageList.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	m_pImageList.SetBkColor(CLR_NONE);
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));				// 0
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));				// 1
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));				// 2
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));			// 3
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_DOWNESTIMATED),16,16));	// 4
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));			// 5
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));			// 6
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPAUSED),16,16));			// 7
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));					// 8
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));					// 9
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));					// 10
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));					// 11
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));					// 12
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));				// 13
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  			// 14
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  			// 15
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));				// 16
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));		// 17
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));			// 18
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));	  		// 19
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));			// 20
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));	  		// 21
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));				// 22
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));				// 23
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  				// 24
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  			// 25
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTCOMPLETE),16,16));  		// 26
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTSTOPPED),16,16));  			// 27
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  			// 28
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_A4AFAUTO),16,16));				// 29
d181 1
a181 1
	if(theApp.glob_prefs->DoUseSort())
d188 2
a189 2
		int sortItem = theApp.glob_prefs->GetColumnSortItem(CPreferences::tableDownload);
		bool sortAscending = theApp.glob_prefs->GetColumnSortAscending(CPreferences::tableDownload);
d298 1
a298 1
void CDownloadListCtrl::AddFile(CPartFile* toadd)
d302 1
a302 1
	if (toadd == NULL)
d306 1
a306 11
        ST_CTRLITEM* newitem = new ST_CTRLITEM;
        uint16 itemnr = GetItemCount();
        newitem->pOwner = NULL;
        newitem->eType = FILE_TYPE;
        newitem->pValue = toadd;
        newitem->pParent = NULL;
		newitem->dwUpdated = 0; 

		// The same file shall be added only once
		ASSERT(m_ListItems.find(toadd) == m_ListItems.end());
		m_ListItems.insert(ListItemsPair(toadd, newitem));
d308 11
a318 2
		if (CheckShowItemInGivenCat(toadd, m_nCurTab ))
			InsertItem(LVIF_PARAM|LVIF_TEXT,itemnr,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)newitem);
d324 2
a325 2

void CDownloadListCtrl::AddSource(CPartFile* pOwner,CUpDownClient* source,bool notavailable)
d329 1
a329 1
	if (pOwner == NULL || source == NULL)
d332 7
a338 35
		// Create new Item
        ST_CTRLITEM* newitem = new ST_CTRLITEM;
        newitem->pOwner = pOwner;
        newitem->eType = (notavailable) ? UNAVAILABLE_SOURCE : AVAILABLE_SOURCE;
        newitem->pValue = source;
		newitem->dwUpdated = 0; 

		// Update cross link to the owner
		ListItems::const_iterator ownerIt = m_ListItems.find(pOwner);
		ASSERT(ownerIt != m_ListItems.end());
		ST_CTRLITEM* ownerItem = ownerIt->second;
		ASSERT(ownerItem->pValue == pOwner);
		newitem->pParent = ownerItem;

		// The same source could be added a few time but only one time per file 
		{
			// Update the other instances of this source
			bool bFound = false;
			std::pair<ListItems::const_iterator, ListItems::const_iterator> rangeIt = m_ListItems.equal_range(source);
			for(ListItems::const_iterator it = rangeIt.first; it != rangeIt.second; it++){
				ST_CTRLITEM* cur_item = it->second;

				// Check if this source has been already added to this file => to be sure
				if(cur_item->pOwner == pOwner){
					// Update this instance with its new setting
					cur_item->eType = newitem->eType;
					cur_item->dwUpdated = 0;
					bFound = true;
				}
				else if(notavailable == false){
					// The state 'Available' is exclusive
					cur_item->eType = UNAVAILABLE_SOURCE;
					cur_item->dwUpdated = 0;
				}
			}
d340 9
a348 4
			if(bFound == true){
				delete newitem; 
				return;
			}
d350 47
a396 1
		m_ListItems.insert(ListItemsPair(source, newitem));
d401 1
a401 1
void CDownloadListCtrl::RemoveSource(CUpDownClient* source,CPartFile* pOwner)
d404 3
a406 2
	//eklmn: do nothing if mule will be closed
	if(!theApp.emuledlg->IsRunning()) 
d411 1
a411 1
	if(source == NULL)
d416 13
a428 3
	// Retrieve all entries matching the source
	std::pair<ListItems::iterator, ListItems::iterator> rangeIt = m_ListItems.equal_range(source);
	for(ListItems::iterator it = rangeIt.first; it != rangeIt.second; )
d430 3
a432 2
		ST_CTRLITEM* delItem  = it->second;
		if(pOwner == NULL || pOwner == delItem->pOwner)
d434 5
a438 2
			// Remove it from the m_ListItems			
			it = m_ListItems.erase(it);
a439 2
			// Remove it from the CListCtrl
 			LVFINDINFO find;
d441 5
a445 3
			find.lParam = (LPARAM)delItem;
			sint16 result = FindItem(&find);
			if(result != -1)
d449 2
a450 3

			// finally it could be delete
			delete delItem;
d454 1
a454 1
			it++;
d461 35
a495 1
void CDownloadListCtrl::RemoveFile(CPartFile* toremove)
d499 1
a499 1
	if (!theApp.emuledlg->IsRunning()) 
d503 2
a504 2
	//check NULL case
	if(!toremove)
d508 14
a521 4
	// Retrieve all entries matching the File or linked to the file
	// Remark: The 'asked another files' clients must be removed from here
	ASSERT(toremove != NULL);
	for(ListItems::iterator it = m_ListItems.begin(); it != m_ListItems.end();)
d523 3
a525 2
		ST_CTRLITEM* delItem = it->second;
		if(delItem->pOwner == toremove || delItem->pValue == toremove)
d527 5
a531 2
			// Remove it from the m_ListItems
			it = m_ListItems.erase(it);
a532 2
			// Remove it from the CListCtrl
			LVFINDINFO find;
d534 5
a538 3
			find.lParam = (LPARAM)delItem;
			sint16 result = FindItem(&find);
			if(result != -1)
d542 2
a543 3

			// finally it could be delete
			delete delItem;
d547 1
a547 1
			it++;
d554 2
a555 2

void CDownloadListCtrl::UpdateItem(void* toupdate)
d564 1
a564 1
	if (theApp.emuledlg->IsRunning()) 
d566 6
d573 2
a574 5
		// Retrieve all entries matching the source
		std::pair<ListItems::const_iterator, ListItems::const_iterator> rangeIt = m_ListItems.equal_range(toupdate);
		for(ListItems::const_iterator it = rangeIt.first; it != rangeIt.second; it++)
		{
			ST_CTRLITEM* updateItem  = it->second;
a575 2
			// Find entry in CListCtrl and update object
 			LVFINDINFO find;
d577 6
a582 3
			find.lParam = (LPARAM)updateItem;
			sint16 result = FindItem(&find);
			if(result != -1)
d584 15
a598 2
				updateItem->dwUpdated = 0;
				Update(result);
d600 15
a614 1
		}
d620 1
a620 1
void CDownloadListCtrl::DrawFileItem(CDC *dc, int nColumn, LPRECT lpRect, ST_CTRLITEM *lpCtrlItem) 
d624 1
a624 1
	if(lpCtrlItem->eType != FILE_TYPE)
d627 1
a627 1
	if(lpRect->left < lpRect->right) 
d630 2
a631 2
		CString buffer;
		CPartFile *lpPartFile = (CPartFile*)lpCtrlItem->pValue;
d635 5
d642 32
a673 8
					POINT ipoint = { lpRect->left, lpRect->top + 1 };
					int iIcon = 14;
					if(lpPartFile->GetStatus()==PS_COMPLETE)
						iIcon = 26;
					else if(lpPartFile->GetStatus()==PS_STOPPED)
						iIcon = 27;
					else if(lpPartFile->GetStatus()==PS_PAUSED)
						iIcon = 7;
d675 39
a713 21
						iIcon = (lpPartFile->GetSourceCount() > 0 || lpPartFile->GetSrcA4AFCount() > 0) ? (lpPartFile->srcarevisible ? 13 : 15) : 14;
					m_pImageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
					lpRect->left += 18;

					// DropF START - Show a heart if the file is A4AF auto
					if (lpPartFile == theApp.downloadqueue->GetA4AFAutoFile())
						m_pImageList.Draw(dc, 29, ipoint, ILD_TRANSPARENT);
					// DropF END - Show a heart if the file is A4AF auto

					// File Type
					if(theApp.glob_prefs->ShowFileTypeIcon())
					{
						int iImage = theApp.GetFileTypeSystemImageIdx(lpPartFile->GetFileName());
						if (theApp.GetSystemImageList() != NULL)
							::ImageList_Draw(theApp.GetSystemImageList(), iImage, dc->GetSafeHdc(), lpRect->left, lpRect->top+1, ILD_TRANSPARENT);
						lpRect->left += 19;
					}

                    // now comments/ratings
					if (!theApp.glob_prefs->GetDisableRatingIcons()) {
						if ( lpPartFile->HasComment() || lpPartFile->HasRating() )
d715 48
a762 2
							int image=16;
							if (lpPartFile->HasRating())
d764 1
a764 23
				        		switch(lpPartFile->GetRating())
				        		{
									case 0: 
										image=16; 
										break; 
									case 1: 
										image=21;
										break; 
									case 2: 
										image=20; 
										break; 
									case 3: 
										image=18; 
										break; 
									case 4: 
										image=19; 
										break; 
									case 5: 
										image=17; 
										break;
									default:
										image=16;
								}
d766 12
a777 2
							POINT point= {lpRect->left-4,lpRect->top+3};
							m_pImageList.Draw(dc, image, point, ILD_NORMAL);
d779 1
a780 1
						lpRect->left+=10;
d783 1
a783 16
                    // obaldin: warn if file had no progress
                    // for the last week
                    COLORREF crOldTxtColor;
                    bool warn=false;
                    if(lpPartFile->GetStatus()==PS_READY)
					{
                        CTimeSpan ts = CTime::GetCurrentTime() - lpPartFile->GetLastDownTransfer();
                        if(ts.GetTotalHours()>24*WARN_PERIOD_OF_NO_PROGRESS)
                            warn = true;
                    }
                    if(warn)
                        crOldTxtColor = dc->SetTextColor((COLORREF)RGB(190,60,60));
					else if(lpPartFile->GetStatus()==PS_PAUSED || lpPartFile->GetStatus()==PS_STOPPED)
						crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));
					else 
						crOldTxtColor = dc->SetTextColor( (theApp.glob_prefs->GetCatColor(lpPartFile->GetCategory())>0)?theApp.glob_prefs->GetCatColor(lpPartFile->GetCategory()):(::GetSysColor(COLOR_WINDOWTEXT)) );
d785 2
a786 11
					dc->DrawText(lpPartFile->GetFileName(), (int)_tcslen(lpPartFile->GetFileName()),lpRect, DLC_DT_TEXT);
                    
					
					if(warn)
                        dc->SetTextColor(crOldTxtColor);

					if(theApp.glob_prefs->ShowFileTypeIcon())
						lpRect->left -= 19;
					if (!theApp.glob_prefs->GetDisableRatingIcons())
						lpRect->left -= 10;
					lpRect->left -= 18;
d788 3
d818 1
a818 1
			       		if(theApp.glob_prefs->GetShowAverageDataRate())
d826 1
a826 1
						buffer.AppendFormat(_T("[%.2f] "), lpPartFile->GetAvgDataRate(false)/1024.0f);
d839 2
a840 2
					if (lpCtrlItem->bmpStatus == (HBITMAP)NULL)
						VERIFY(lpCtrlItem->bmpStatus.CreateBitmap(1, 1, 1, 8, NULL)); 
d844 1
a844 1
					int cx = lpCtrlItem->bmpStatus.GetBitmapDimension().cx; 
d846 1
a846 1
					if(lpCtrlItem->dwUpdated + DLC_BARUPDATE < dwTicks || cx !=  iWidth || !lpCtrlItem->dwUpdated)
d848 4
a851 4
						lpCtrlItem->bmpStatus.DeleteObject(); 
						lpCtrlItem->bmpStatus.CreateCompatibleBitmap(dc,  iWidth, iHeight); 
						lpCtrlItem->bmpStatus.SetBitmapDimension(iWidth,  iHeight); 
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->bmpStatus); 
d858 1
a858 1
						lpPartFile->DrawStatusBar(&cdcStatus,  &rec_status, theApp.glob_prefs->UseFlatBar()); 
d860 1
a860 1
						lpCtrlItem->dwUpdated = dwTicks + (rand() % 128); 
d862 1
a862 1
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->bmpStatus); 
d867 1
a867 1
					if (theApp.glob_prefs->GetUseDwlPercentage())
d902 1
a902 1
					// theApp.sharedfiles->UpdateItem(((CKnownFile*)lpPartFile)); // obaldin: what the heck was it doing here? moved to UpdateItem
d979 1
a979 1
						if(theApp.glob_prefs->GetShowAverageDataRate())
d1035 1
a1035 1
						Category_Struct *pCatStruct = theApp.glob_prefs->GetCategory(lpPartFile->GetCategory());
d1050 14
a1063 1
				
d1071 2
a1072 2

void CDownloadListCtrl::DrawSourceItem(CDC *dc, int nColumn, LPRECT lpRect, ST_CTRLITEM *lpCtrlItem) 
d1076 1
a1076 3
	if(lpCtrlItem == NULL)
		return;
	if(lpCtrlItem->eType != AVAILABLE_SOURCE && lpCtrlItem->eType != UNAVAILABLE_SOURCE)
d1081 43
a1123 43
	CString buffer;
	CUpDownClient *lpClient = (CUpDownClient*)lpCtrlItem->pValue;
	CString sDownloadState = _T("");
	try{ sDownloadState = lpClient->GetDownloadStateAsString(); }catch(...){}
	uint8 nDownloadState = lpClient->GetDownloadState();
	eClientTypes nClientSoft = lpClient->GetClientSoft();
	uint32 nVersion;	//Cax2 - version nr bugfix
	switch(nClientSoft){
		case SO_EMULE:
		case SO_LMULE:
		case SO_OLDEMULE:
		case SO_CDONKEY:
		case SO_SHAREAZA:
			nVersion= lpClient->GetMuleVersion();
			break;
		default:
			nVersion= lpClient->GetVersion();
	}
	bool bIsBanned = lpClient->IsBanned(); //katsyonak 07/07/03
	bool bIsFriend = lpClient->IsFriend();
	float fRemoteBaseModifier = lpClient->GetRemoteBaseModifier();
	CString sClientName = _T("");
	if(lpClient->GetUserName())
		try{ sClientName = CString(lpClient->GetUserName()); }catch(...){}
	uint32 nTransferredDown = lpClient->GetTransferredDown();
	uint32 nDownloadDataRate = lpClient->GetDownloadDataRate();
	bool bIsEmuleClient = lpClient->IsEmuleClient();
	uint16 nRemoteQueueRank = lpClient->GetRemoteQueueRank();
	uint16 nDifference = lpClient->GetDifference(); //cendre-eau
	bool bNeverAskedBefore = lpClient->GetLastSrcReqTime() == 0;
	bool bRemoteQueueFull = lpClient->IsRemoteQueueFull();
	bool bIsRemoteInfoAvail = lpClient->IsRemoteInfoAvaiable();
	bool bCredits = lpClient->credits != (CClientCredits*)NULL && lpClient->credits != (CClientCredits*)-1;
	uint16 nRemoteRatio = lpClient->GetRemoteRatio();
	bool a4af=IsAskedForAnotherFile(lpCtrlItem);

	// Lord KiRon - just make compiler happy :)
 	POINT point;
 	CString status;
	
	switch(nColumn) 
	{
		case 0:  	// icon, name
a1125 1
				
d1127 8
a1134 6
				#ifndef AMD
				memcpy(&cur_rec, lpRect, sizeof(RECT));
				#else
				memcpy_amd(&cur_rec, lpRect, sizeof(RECT));
				#endif
				cur_rec.left += 18;
d1138 1
a1138 1
				if(!a4af)
d1146 1
a1146 1
							    m_pImageList.Draw(dc, ICON_DCS3, point, ILD_NORMAL);
d1149 1
a1149 1
							    m_pImageList.Draw(dc, ICON_DCS2, point, ILD_NORMAL);
d1153 1
a1153 1
							    m_pImageList.Draw(dc, ICON_DCS1, point, ILD_NORMAL);
d1157 1
a1157 1
							    m_pImageList.Draw(dc, ICON_DCS4, point, ILD_NORMAL);
d1160 1
a1160 1
							    m_pImageList.Draw(dc, ICON_DCS5, point, ILD_NORMAL);
d1163 2
a1164 2
               		    m_pImageList.Draw(dc, ICON_DCS4, point, ILD_NORMAL); 
					if(theApp.glob_prefs->IsA4AFStringEnabled()) {
d1178 1
a1178 1
						    m_pImageList.Draw(dc, ICON_CDONKEY, point2, ILD_NORMAL);
d1181 1
a1181 1
						    m_pImageList.Draw(dc, ICON_LMULE, point2, ILD_NORMAL);
d1184 1
a1184 1
						    m_pImageList.Draw(dc, ICON_SHAREAZA, point2, ILD_NORMAL);
d1187 1
a1187 1
						    m_pImageList.Draw(dc, ICON_EDONKEYHYBRID, point2, ILD_NORMAL);
d1190 1
a1190 1
						    m_pImageList.Draw(dc, ICON_MLDONKEY, point2, ILD_NORMAL);
d1195 1
a1195 1
							    m_pImageList.Draw(dc, 28, point2, ILD_NORMAL);
d1197 1
a1197 1
							    m_pImageList.Draw(dc, ICON_COMPROT, point2, ILD_NORMAL);
d1200 1
a1200 1
						    m_pImageList.Draw(dc, ICON_NORMAL, point2, ILD_NORMAL);
d1203 1
a1203 1
						    m_pImageList.Draw(dc, ICON_UNKNOWN, point2, ILD_NORMAL);
d1209 1
a1209 1
					    m_pImageList.Draw(dc, ICON_BANNED_ONLY, point2, ILD_TRANSPARENT);
d1211 1
a1211 1
					    m_pImageList.Draw(dc, ICON_FRIEND_ONLY, point2, ILD_TRANSPARENT);
d1213 1
a1213 1
					    m_pImageList.Draw(dc, ICON_CREDIT_DOWNESTIMATED, point2, ILD_TRANSPARENT);
d1238 23
a1260 1
		case 1:		// size
d1263 5
a1267 5
		case 2:		// transferred
			if (!a4af && nTransferredDown && !theApp.glob_prefs->IsTransferredOnCompleted()) {
				buffer = CastItoXBytes(nTransferredDown);
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
			}
d1270 6
a1275 6
		case 3:		// completed
			if (!a4af && nTransferredDown && theApp.glob_prefs->IsTransferredOnCompleted()) {
				buffer = CastItoXBytes(nTransferredDown);
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
			}
			break;
d1277 10
a1286 10
		case 4:		// speed
			if (!a4af)
			{
				if (nDownloadDataRate==0)
					buffer="";
				else
					buffer.Format(_T("%.1f %s"), nDownloadDataRate/1024.0f,GetResString(IDS_KBYTESEC));
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
			}
			break;
d1288 1
a1288 1
		case 5:		// file info
d1295 2
a1296 2
				if (lpCtrlItem->bmpStatus == (HBITMAP)NULL)
					VERIFY(lpCtrlItem->bmpStatus.CreateBitmap(1, 1, 1, 8, NULL)); 
d1300 1
a1300 1
				int cx = lpCtrlItem->bmpStatus.GetBitmapDimension().cx; 
d1302 1
a1302 1
				if(lpCtrlItem->dwUpdated + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !lpCtrlItem->dwUpdated)
d1304 4
a1307 4
					lpCtrlItem->bmpStatus.DeleteObject(); 
					lpCtrlItem->bmpStatus.CreateCompatibleBitmap(dc,  iWidth, iHeight); 
					lpCtrlItem->bmpStatus.SetBitmapDimension(iWidth,  iHeight); 
					hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->bmpStatus); 
d1315 1
a1315 1
					lpClient->DrawStatusBar(&cdcStatus,  &rec_status,(a4af), theApp.glob_prefs->UseFlatBar()); 
d1318 1
a1318 1
					lpCtrlItem->dwUpdated = dwTicks + (rand() % 128); 
d1320 1
a1320 1
					hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->bmpStatus); 
d1330 1
a1330 1
		case 6:		// sources
d1338 3
a1340 4
		case 7:		// prio
			if ((bIsEmuleClient || nRemoteQueueRank)&& nDownloadState==DS_ONQUEUE && !a4af) //now emule v ? display the QR too!
			{
				if(bRemoteQueueFull)
d1342 6
a1347 6
					buffer=GetResString(IDS_QUEUEFULL);
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
				}
				else
				{
					if (nRemoteQueueRank)
d1349 1
a1349 3
						//cendre-eau
						COLORREF crOldTxtColor;
						if (nDifference==nRemoteQueueRank)
d1351 3
a1353 14
							//if(bNeverAskedBefore)
							//{
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
								buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nRemoteQueueRank-nDifference));
							/*} else {
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,255));
								buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nRemoteQueueRank-nDifference));
							}*/
						}      
						else if (nDifference<nRemoteQueueRank)
						{  
							crOldTxtColor = dc->SetTextColor((COLORREF)RGB(190,60,60));
							buffer.Format("QR: %u (+%u)",nRemoteQueueRank,(nDifference));
							if (nDifference==0)
d1355 18
a1372 3
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(5,65,195));
								buffer.Format("QR: %u (%u)",nRemoteQueueRank,(nDifference));
							}
d1376 11
a1386 2
							crOldTxtColor = dc->SetTextColor((COLORREF)RGB(10,160,70));
							buffer.Format("QR: %u (-%u)",nRemoteQueueRank,(65536-nDifference));
a1387 8
						dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
						crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
						//cendre-eau
					}
					else
					{
						//buffer="";
						dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
a1389 1
				}
d1393 3
a1395 3
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
			}
			break;
d1397 11
a1407 11
		case 8:		// status
			// Lord KiRon
			RECT cur_rec;
			#ifndef AMD
			memcpy(&cur_rec, lpRect, sizeof(RECT));
			#else
			memcpy_amd(&cur_rec, lpRect, sizeof(RECT));
			#endif
			cur_rec.left += 6;
			point.x = cur_rec.left;
			point.y = cur_rec.top+1;
d1409 1
a1409 1
			dc->DrawText(sDownloadState,sDownloadState.GetLength(),&cur_rec, DLC_DT_TEXT);
d1413 68
a1480 16
		case 9:		// remaining size
			break;
		case 10:	// remaining time
			break;
		case 11: // UL/DL Ratio Maverick
			if (bIsRemoteInfoAvail || bCredits)
				buffer.Format(_T("%0.1f"), fRemoteBaseModifier);
			else buffer="";
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
			break;
		case 12: // Ratio total Maverick
			if (bIsRemoteInfoAvail || bCredits)
				buffer.Format(_T("%ld"), nRemoteRatio);
			else buffer="";
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
			break;
d1485 1
a1485 1

d1490 1
a1490 1
	if (!theApp.emuledlg->IsRunning())
d1495 1
a1495 1
	if(theApp.glob_prefs->DoUseSrcSortCol2() && theApp.glob_prefs->DoUseSort() && m_ShowSrc && m_sortTime+1000<::GetTickCount()) 
d1501 1
a1501 1
	ST_CTRLITEM* content = (ST_CTRLITEM*)lpDrawItemStruct->itemData;
d1504 1
a1504 1
	if ((content->eType == FILE_TYPE) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d1537 1
a1537 1
	if (content->eType == FILE_TYPE)
d1566 1
a1566 1
	else if (content->eType == AVAILABLE_SOURCE || content->eType == UNAVAILABLE_SOURCE)
d1598 1
a1598 1
		(lpDrawItemStruct->itemState & ODS_SELECTED) && (content->eType == FILE_TYPE))
d1617 2
a1618 2
			ST_CTRLITEM* prev = (ST_CTRLITEM*)GetItemData(lpDrawItemStruct->itemID - 1);
			if(prev->eType == FILE_TYPE)
d1624 2
a1625 2
			ST_CTRLITEM* next = (ST_CTRLITEM*)GetItemData(lpDrawItemStruct->itemID + 1);
			if(next->eType == FILE_TYPE)
d1659 4
a1662 4
			((ST_CTRLITEM*)GetItemData(lpDrawItemStruct->itemID + 1))->eType != FILE_TYPE;
		BOOL isOpenRoot = hasNext && content->eType == FILE_TYPE;
		BOOL isChild = content->eType != FILE_TYPE;
		//BOOL isExpandable = !isChild && ((CPartFile*)content->pValue)->GetSourceCount() > 0;
d1722 1
a1722 2
// modifier-keys -view filtering [Ese Juani+xrmb]
void CDownloadListCtrl::HideSources(CPartFile* toCollapse,bool isShift,bool isCtrl,bool isAlt) 
d1727 3
a1729 3
	int pre,post;
	pre = post = 0;
	for(int i = 0; i < GetItemCount(); i++) 
d1731 4
a1734 2
		ST_CTRLITEM* item = (ST_CTRLITEM*)this->GetItemData(i);
		if(item->pOwner == toCollapse) 
d1736 4
a1739 15
			pre++;
			if(isShift || isCtrl || isAlt)
			{
				eDLQState ds=((CUpDownClient*)item->pValue)->GetDownloadState();
				if((isShift && ds==DS_DOWNLOADING) ||
					(isCtrl && ((CUpDownClient*)item->pValue)->GetRemoteQueueRank()> 0) ||
					(isAlt && ds!=DS_NONEEDEDPARTS))
				{
					continue;
				}
			}
			item->dwUpdated = 0;
			item->bmpStatus.DeleteObject();
			DeleteItem(i--);
			post++;
d1741 2
a1743 1

d1747 5
a1751 4
		for(int i = 0; i < GetItemCount(); i++)
		{	
			ST_CTRLITEM* item = (ST_CTRLITEM*)this->GetItemData(i);
			if(item)
d1753 2
a1754 5
				if(item->eType == AVAILABLE_SOURCE || item->eType == UNAVAILABLE_SOURCE)
				{
					m_ShowSrc = true;
					break;
				}
d1758 1
a1758 1
		if (theApp.glob_prefs->DoUseSort() && !m_ShowSrc)	//Cax2 ...& restore the sort index that was there before expanding the files
d1760 1
a1760 1
			m_lastSort = FilesSortIndex;
a1764 5

	if (pre-post==0)
	{ 
		toCollapse->srcarevisible = false;
	}
d1769 1
d1783 1
d1786 1
a1786 1
void CDownloadListCtrl::ExpandCollapseItem(int item,uint8 expand,bool collapsesource)
d1790 13
a1802 1
	if (item == -1) 
d1807 1
a1807 1
	ST_CTRLITEM* content = (ST_CTRLITEM*)this->GetItemData(item);
d1809 4
a1812 4
	// modifier-keys -view filtering [Ese Juani+xrmb]
	bool isShift=GetAsyncKeyState(VK_SHIFT) < 0;
	bool isCtrl=GetAsyncKeyState(VK_CONTROL) < 0;
	bool isAlt=GetAsyncKeyState(VK_MENU) < 0;
d1814 1
a1814 1
	if (collapsesource && content->pParent!=NULL) 
d1816 1
a1816 1
		content=content->pParent;
d1818 2
a1819 1
 		LVFINDINFO find;
d1821 5
a1825 3
		find.lParam = (LPARAM)content;
		item = FindItem(&find);
		if (item==-1) return;
d1828 1
a1828 1
	if (!content || content->eType != FILE_TYPE) 
d1830 7
a1836 14
		return;
	}
	
	if(theApp.glob_prefs->DoUseSort() && !m_ShowSrc)		//Cax2 - restore the sort index that was there before opening the files if advanced sort
	{		
		FilesSortIndex = m_lastSort; 
	}
	m_ShowSrc=true;  //newsort added by Cax2 03/11/02 
	
	CPartFile* partfile = reinterpret_cast<CPartFile*>(content->pValue);
	if (!partfile) 
	{
		return;
	}
d1838 1
a1838 8
	if((partfile->GetStatus() == PS_PAUSED || partfile->GetStatus() == PS_STOPPED) && !m_dblclicked)
		partfile->ResumeFile();
	else if (partfile->GetStatus() == PS_COMPLETE && !m_dblclicked) 
		ClearCompleted(partfile->GetFileHash());
	// Check if the source branch is disable
	else if(partfile->srcarevisible == false && partfile->GetStatus() != PS_COMPLETING) 
	{
		if (expand > COLLAPSE_ONLY)
d1840 41
a1880 16
			SetRedraw(false);
			
			// Go throught the whole list to find out the sources for this file
			// Remark: don't use GetSourceCount() => UNAVAILABLE_SOURCE
			for(ListItems::const_iterator it = m_ListItems.begin(); it != m_ListItems.end(); it++)
			{
				const ST_CTRLITEM* cur_item = it->second;
				if(cur_item->pOwner == partfile)
				{
					if(isShift || isCtrl || isAlt) 
					{
						ASSERT(cur_item->eType != FILE_TYPE);
						eDLQState ds=((CUpDownClient*)cur_item->pValue)->GetDownloadState();
						if(!(isShift && ds==DS_DOWNLOADING ||
							isCtrl && ((CUpDownClient*)cur_item->pValue)->GetRemoteQueueRank()>0 ||
							isAlt && ds!=DS_NONEEDEDPARTS))
d1882 8
a1889 1
							continue; // skip this source
d1891 2
a1893 2
					partfile->srcarevisible = true;
					InsertItem(LVIF_PARAM|LVIF_TEXT,item+1,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)cur_item);
d1895 3
a1898 2

			SetRedraw(true);
d1900 2
a1901 4
	}
	else 
	{
		if(expand == EXPAND_COLLAPSE || expand == COLLAPSE_ONLY) 
d1903 4
a1906 1
			HideSources(partfile,isShift,isCtrl,isAlt);
a1907 1
	}
d1909 1
a1909 1
	SortInit(partfile->srcarevisible&&theApp.glob_prefs->DoUseSort()); //override if useSort & showing sources...
d1911 2
a1912 8
	m_dblclicked = false;

	EMULE_CATCH
}

void CDownloadListCtrl::OnItemActivate(NMHDR *pNMHDR, LRESULT *pResult)
{
	EMULE_TRY
a1913 4
	LPNMITEMACTIVATE pNMIA = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	ExpandCollapseItem(pNMIA->iItem,2);
	*pResult = 0;
	
d1929 1
a1929 1
		ST_CTRLITEM* content = (ST_CTRLITEM*)GetItemData(GetSelectionMark());
d1931 3
a1933 4
		if (content->eType == FILE_TYPE) 
		{
			cFile = (CPartFile*)content->pValue;
		}
d1941 2
a1942 2
			theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToFile(file); // FoRcHa
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
d1972 28
d2065 1
a2065 1
				m_FileMenu.CheckMenuItem(MP_ALL_A4AF_AUTO, (file== theApp.downloadqueue->GetA4AFAutoFile()) ? MF_CHECKED:MF_UNCHECKED); // Tarod
d2087 1
a2087 1
			const CUpDownClient* client = (CUpDownClient*)content->pValue;
d2089 2
a2090 2
				theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToUser((CUpDownClient*)client);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
d2102 1
a2102 1
			if(IsAskedForAnotherFile(content))
d2125 1
a2125 1
		ST_CTRLITEM* content = (ST_CTRLITEM*)GetItemData(GetSelectionMark());
d2137 1
a2137 1
				if (((ST_CTRLITEM*)GetItemData(index))->eType == FILE_TYPE) 
d2139 1
a2139 1
					selectedList.AddTail((CPartFile*)((ST_CTRLITEM*)GetItemData(index))->pValue); 
d2144 1
a2144 1
		if (content->eType == FILE_TYPE)
d2146 1
a2146 1
			CPartFile* file = (CPartFile*)content->pValue;
d2150 1
a2150 1
				RunURL(file, theApp.webservices.GetAt(wParam-MP_WEBURL) );
d2152 2
d2356 1
a2356 1
						theApp.CopyTextToClipboard(str);
d2360 1
a2360 1
					theApp.CopyTextToClipboard(file->CreateED2kLink());
d2371 1
a2371 1
						theApp.CopyTextToClipboard(str);
d2375 1
a2375 1
					theApp.CopyTextToClipboard(file->CreateHTMLED2kLink());
d2406 1
a2406 1
					CString newpath = BrowseFolder(theApp.emuledlg->m_hWnd,GetResString(IDS_SELECTOUTPUTDIR),dir);
d2430 1
a2430 1
						theApp.sharedfiles->Reload(false);
d2444 1
a2444 1
						if (theApp.downloadqueue->GetA4AFAutoFile() == file)
d2446 1
a2446 1
							theApp.downloadqueue->SetA4AFAutoFile(NULL);
d2449 1
a2449 1
							theApp.downloadqueue->SetA4AFAutoFile(file);
d2524 1
a2524 1
						theApp.CopyTextToClipboard(str);
d2528 1
a2528 1
					theApp.CopyTextToClipboard(file->CreateED2KSourceLink(7, 10));
d2534 1
a2534 1
			CUpDownClient* client = (CUpDownClient*)content->pValue;
d2541 1
a2541 1
					theApp.emuledlg->chatwnd.StartSession(client);
d2544 1
a2544 1
					theApp.friendlist->AddFriend(client);
d2547 1
a2547 1
					theApp.friendlist->RemoveFriend(client);
d2561 1
a2561 1
					CPartFile *pFile = (CPartFile*)content->pOwner;
d2609 2
a2610 2
	ST_CTRLITEM* item1 = (ST_CTRLITEM*)lParam1;
	ST_CTRLITEM* item2 = (ST_CTRLITEM*)lParam2;
d2629 3
a2631 2
	if ((item1->eType == FILE_TYPE && item2->eType != FILE_TYPE) ||
		(item2->eType == FILE_TYPE && item1->eType != FILE_TYPE))
d2635 2
a2636 1
	else if (item1->eType == FILE_TYPE) 
d2644 2
a2645 2
			CPartFile* file1 = (CPartFile*)item1->pValue;
			CPartFile* file2 = (CPartFile*)item2->pValue;
d2651 2
a2652 1
		comp = Compare(GetFile(item1), GetFile(item2),0);
d2658 1
a2658 1
		if ((IsAskedForAnotherFile(item1) || IsAskedForAnotherFile(item2)) && lParamSort != 0)
d2661 2
a2662 1
			if(IsAskedForAnotherFile(item1) && !IsAskedForAnotherFile(item2))
d2666 1
a2666 1
			if(IsAskedForAnotherFile(item2) && !IsAskedForAnotherFile(item1))
d2676 1
a2676 1
		comp = Compare((CUpDownClient*)item1->pValue, (CUpDownClient*)item2->pValue, lParamSort, sortMod);
d2684 1
a2684 1
void CDownloadListCtrl::ClearCompleted(bool ignorecats)
d2687 1
a2687 1
	for(ListItems::iterator it = m_ListItems.begin(); it != m_ListItems.end();)
d2689 2
a2690 1
		ST_CTRLITEM* cur_item = it->second;
d2692 1
a2692 1
		if(cur_item->eType == FILE_TYPE)
d2694 3
a2696 2
			CPartFile* file = reinterpret_cast<CPartFile*>(cur_item->pValue);
			if(file->IsPartFile() == false && (CheckShowItemInGivenCat(file,m_nCurTab) || ignorecats) )
d2698 1
a2698 1
				RemoveFile(file);
d2711 1
a2711 1
	for(ListItems::iterator it = m_ListItems.begin(); it != m_ListItems.end();)
d2713 3
a2715 3
		ST_CTRLITEM* cur_item = it->second;
		it++; // Already point to the next iterator. 
		if(cur_item->eType == FILE_TYPE)
d2717 1
a2717 1
			CPartFile* pFile = reinterpret_cast<CPartFile*>(cur_item->pValue);
d2763 1
a2763 1
		m_lastSort=theApp.glob_prefs->GetDownloadSortCol();
d2769 1
a2769 1
		if(theApp.glob_prefs->DoUseSort() && m_lastSort<0)
d2771 2
a2772 2
			SortItems(&SortProc,1000 + theApp.glob_prefs->GetSrcSortCol1()); //+ show sources(clients)
			if (theApp.glob_prefs->DoUseSrcSortCol2())
d2774 1
a2774 1
				if (theApp.glob_prefs->GetSrcSortCol2()==255)
d2779 1
a2779 1
					SortItems(&SortProc,1000 + theApp.glob_prefs->GetSrcSortCol2());
d2785 1
a2785 1
			SortItems(&SortProc,theApp.glob_prefs->GetDownloadSortCol());
d2936 12
a2947 2
			(file1->GetCategory()!=0)?theApp.glob_prefs->GetCategory(file1->GetCategory())->title:GetResString(IDS_ALL),
			(file2->GetCategory()!=0)?theApp.glob_prefs->GetCategory(file2->GetCategory())->title:GetResString(IDS_ALL));
d2978 1
a2978 1
				if(!theApp.glob_prefs->IsTransferredOnCompleted())
d2985 1
a2985 1
				if(theApp.glob_prefs->IsTransferredOnCompleted())
d3090 1
a3090 1
			ST_CTRLITEM *pListItem = (ST_CTRLITEM*)GetItemData(index);
d3093 1
a3093 1
			if(!pListItem->eType == FILE_TYPE)			// if it isn't a file we're done
d3099 4
d3108 3
a3110 2
				CPartFile *pPartFile = (CPartFile*)pListItem->pValue;
				if(!pPartFile)
d3121 1
a3121 1
			if (theApp.glob_prefs->ShowFileTypeIcon())
d3128 1
a3128 1
				CPartFile *pPartFile = (CPartFile*)pListItem->pValue;
d3156 3
a3158 2
		ST_CTRLITEM* content = (ST_CTRLITEM*)this->GetItemData(iSel);
		if (content && content->pValue)
d3160 2
a3161 1
			if (content->eType == FILE_TYPE)
d3163 4
a3166 8
				CPartFile* file = (CPartFile*)content->pValue;
				if(file->GetStatus()==PS_COMPLETE)
				{
					CString buffer;
					buffer.Format(_T("%s\\%s"),file->GetPath(),file->GetFileName());
					AddLogLine(false, _T("%s\\%s"),file->GetPath(),file->GetFileName());
					ShellOpenFile(buffer);
				}
d3168 5
a3172 1
			else	//client  options
d3174 10
a3183 14
				CUpDownClient* client = (CUpDownClient*)content->pValue;
				if (theApp.glob_prefs->GetDetailsOnClick())
				{
				#if _USE_NEW_DETAILS_
					CClientDetails dialog("Client Details", client, this, 0);
				#else
					CClientDetailDialog dialog(client);
				#endif
					dialog.DoModal();
				} 
				else 
				{
					theApp.emuledlg->chatwnd.StartSession(client);
				}
d3217 2
a3218 2
		ST_CTRLITEM *pItem = (ST_CTRLITEM*)GetItemData(i);
		if(pItem)
d3220 1
a3220 11
			if(pItem->eType == FILE_TYPE)
			{
				CPartFile* pFile = (CPartFile*)pItem->pValue;
				if(pFile)
				{
					if(pFile->GetSourceCount() <= theApp.glob_prefs->GetMaxSourcePerFile())
					{
						selectedList.AddTail(pFile);
					}
				}
			}
d3229 1
a3229 1
	AddLogLine(true,IDS_NEWSERVERCONNECT,theApp.glob_prefs->GetMaxSourcePerFile()); 
d3245 19
d3272 2
a3273 2
		theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToFile(NULL);
		theApp.emuledlg->transferwnd.UpdateInfoHeader();
d3277 2
a3278 2
		ST_CTRLITEM* content = (ST_CTRLITEM*)GetItemData(GetSelectionMark());
		if(content->eType == FILE_TYPE)
d3280 13
a3292 10
			const CPartFile* file = (CPartFile*)content->pValue;
			theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToFile((CPartFile*)file);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
		} 
		else 
		{
			const CUpDownClient* client = (CUpDownClient*)content->pValue;
			theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToUser((CUpDownClient*)client);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
		}	
d3302 1
a3302 1
	ST_CTRLITEM* cur_item;
d3304 1
a3304 1
	for(ListItems::const_iterator it = m_ListItems.begin(); it != m_ListItems.end(); it++)
d3306 2
a3307 2
		cur_item = it->second;
		if (cur_item->eType == FILE_TYPE)
d3309 2
a3310 1
			CPartFile* file=(CPartFile*)cur_item->pValue;
d3319 2
a3320 2
//	theApp.emuledlg->transferwnd.GetDlgItem(IDC_DOWNLOAD_TEXT)->SetWindowText(counter);
	theApp.emuledlg->transferwnd.UpdateDownloadHeader();
d3331 4
a3334 4
	for(ListItems::iterator it = m_ListItems.begin(); it != m_ListItems.end(); it++)
	{ // const is better
		ST_CTRLITEM* cur_item = it->second;
		if(cur_item->eType == FILE_TYPE)
d3336 1
a3336 1
			CPartFile* file = reinterpret_cast<CPartFile*>(cur_item->pValue);
d3366 1
a3366 1
	for(ListItems::iterator it = m_ListItems.begin(); it != m_ListItems.end();)
d3368 2
a3369 3
		ST_CTRLITEM* cur_item = it->second;
		it++; // Already point to the next iterator. 
		if(cur_item->eType == FILE_TYPE)
d3371 1
a3371 1
			CPartFile* file = reinterpret_cast<CPartFile*>(cur_item->pValue);
d3375 1
d3402 1
a3402 1
	ST_CTRLITEM* content = (ST_CTRLITEM*)this->GetItemData(GetSelectionMark());
d3404 1
a3404 1
	if (content->eType == FILE_TYPE)
d3406 1
a3406 1
		CPartFile* file = (CPartFile*)content->pValue;
d3408 1
a3408 1
		if ((file->HasComment() || file->HasRating()) && p.x<13 ) 
d3410 2
a3411 1
			CCommentDialogLst dialog(file);
d3417 1
a3417 1
			CFileDetails dialog("File Details", file, this, 0);
d3419 1
a3419 1
			CFileDetailDialog dialog(file);
d3427 1
a3427 1
		CUpDownClient* client = (CUpDownClient*)content->pValue;
d3429 1
a3429 1
		CClientDetails dialog("Client Details", client, this, 0);
d3431 1
a3431 1
		CClientDetailDialog dialog(client);
d3446 1
a3446 1
	for(ListItems::const_iterator it = m_ListItems.begin(); it != m_ListItems.end(); it++)
d3448 2
a3449 2
		const ST_CTRLITEM* cur_item = it->second;
		if (cur_item->eType == FILE_TYPE)
d3451 1
a3451 1
			CPartFile* file = reinterpret_cast<CPartFile*>(cur_item->pValue);
d3471 25
d3503 3
a3505 2
	std::pair<ListItems::const_iterator, ListItems::const_iterator> rangeIt = m_ListItems.equal_range(tohide);
	for(ListItems::const_iterator it = rangeIt.first; it != rangeIt.second; it++)
d3507 1
a3507 1
		ST_CTRLITEM* updateItem  = it->second;
d3525 1
a3525 1
void CDownloadListCtrl::ShowFile(CPartFile* toshow)
d3530 3
a3532 2
	std::pair<ListItems::const_iterator, ListItems::const_iterator> rangeIt = m_ListItems.equal_range(toshow);
	for(ListItems::const_iterator it = rangeIt.first; it != rangeIt.second; it++)
d3534 1
a3534 1
		ST_CTRLITEM* updateItem  = it->second;
d3542 2
a3543 1
		if(result == -1)
d3554 51
d3611 1
a3611 1
	for(ListItems::iterator it = m_ListItems.begin(); it != m_ListItems.end();)
d3613 1
a3613 1
		ST_CTRLITEM* cur_item = it->second;
d3615 1
a3615 1
		if(cur_item->eType == FILE_TYPE)
d3617 1
a3617 1
			CPartFile* file = reinterpret_cast<CPartFile*>(cur_item->pValue);
d3667 9
a3675 5
    if (pDispInfo->item.mask & LVIF_TEXT){
        const ST_CTRLITEM* pItem = reinterpret_cast<ST_CTRLITEM*>(pDispInfo->item.lParam);
        if (pItem != NULL && pItem->pValue != NULL){
			if (pItem->eType == FILE_TYPE){
				switch (pDispInfo->item.iSubItem){
d3678 1
a3678 1
							_tcsncpy(pDispInfo->item.pszText, ((const CPartFile*)pItem->pValue)->GetFileName(), pDispInfo->item.cchTextMax);
d3688 4
a3691 2
			else if (pItem->eType == UNAVAILABLE_SOURCE || pItem->eType == AVAILABLE_SOURCE){
				switch (pDispInfo->item.iSubItem){
d3693 3
a3695 2
						if (((CUpDownClient*)pItem->pValue)->GetUserName() != "" && pDispInfo->item.cchTextMax > 0){
							_tcsncpy(pDispInfo->item.pszText, ((CUpDownClient*)pItem->pValue)->GetUserName(), pDispInfo->item.cchTextMax);
@


1.227
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d160 1
a160 1
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  		// 3
d162 9
a170 9
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      	// 5
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      	// 6
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPAUSED),16,16));         		// 7
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));         		// 8
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));         		// 9
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));         		// 10
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));         		// 11
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));         		// 12
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  		// 13
d173 1
a173 1
	m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));			// 16
d179 2
a180 2
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  			// 22
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  			// 23
d183 1
a183 1
    m_pImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTCOMPLETE),16,16));  			// 26
d186 1
d547 5
@


1.226
log
@minor file type icons fix
@
text
@a102 1
	
d105 1
a105 1
		delete m_ListItems.begin()->second; // second = ST_CTRLITEM*
d108 1
a108 2

	m_ImageList.DeleteImageList();	//eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d128 10
a137 10
	InsertColumn(0,GetResString(IDS_DL_FILENAME),LVCFMT_LEFT, 260);
	InsertColumn(1,GetResString(IDS_DL_SIZE),LVCFMT_RIGHT, 60);
	InsertColumn(2,GetResString(IDS_DL_TRANSF),LVCFMT_RIGHT, 65);
	InsertColumn(3,GetResString(IDS_SF_COMPLETED),LVCFMT_RIGHT, 65);
	InsertColumn(4,GetResString(IDS_DL_SPEED),LVCFMT_RIGHT, 65);
	InsertColumn(5,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT, 170);
	InsertColumn(6,GetResString(IDS_DL_SOURCES),LVCFMT_RIGHT, 50);
	InsertColumn(7,GetResString(IDS_PRIORITY),LVCFMT_LEFT, 55);
	InsertColumn(8,GetResString(IDS_STATUS),LVCFMT_LEFT, 70);
	InsertColumn(9,GetResString(IDS_DL_REMAINS),LVCFMT_LEFT, 110);
d140 3
a142 3
	InsertColumn(10,GetResString(IDS_TIME),LVCFMT_LEFT, 110); 		// should be est. time or ETA
	InsertColumn(11,GetResString(IDS_DL_ULDL),LVCFMT_RIGHT,60);		//netwolf 05.05.03 (right justified)
	InsertColumn(12,GetResString(IDS_QL_RATING),LVCFMT_RIGHT,60);	//netwolf 05.05.03 (right justified)
d146 1
a146 1
	InsertColumn(13, lsctitle,LVCFMT_LEFT, 110);
d149 37
a185 34
	InsertColumn(14, lsctitle, LVCFMT_LEFT, 220);
	InsertColumn(15, GetResString(IDS_CAT), LVCFMT_LEFT, 100);

	m_ImageList.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	m_ImageList.SetBkColor(CLR_NONE);
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));					// 0
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));				// 1
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));				// 2
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  		// 3
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_DOWNESTIMATED),16,16));	// 4
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      		// 5
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      		// 6
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPAUSED),16,16));  			// 7
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));         			// 8
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));         			// 9
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));         			// 10
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));         			// 11
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));         			// 12
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  			// 13
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  			// 14
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  			// 15
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));				// 16
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));		// 17
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));			// 18
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));	  		// 19
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));			// 20
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));	  		// 21
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  				// 22
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  				// 23
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  				// 24
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  				// 25
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTCOMPLETE),16,16));  			// 26
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTSTOPPED),16,16));  			// 27
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  			// 28
d307 2
a308 1

d313 1
a313 2
	if(!toadd)
	{
a314 1
	}
d341 1
a341 2
	if(!pOwner || !source)
	{
a342 1
	}
d389 1
a389 2


d393 1
a393 1

d398 2
a399 1
	if(!source)
d435 1
a435 1

d444 1
d487 1
a487 1
	if(!::IsWindow(GetSafeHwnd()))
d516 1
a516 3

#define WARN_PERIOD_OF_NO_PROGRESS 7

d532 1
a532 1
			case 0:		// file name
d544 1
a544 1
					m_ImageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d588 1
a588 1
							m_ImageList.Draw(dc, image, point, ILD_NORMAL);
d626 1
a626 1
			case 1:		// size
d631 2
a632 2
			case 2:		// transfered
				buffer = CastItoXBytes(lpPartFile->GetTransfered());
d636 1
a636 1
		    case 3:		// transfered complete
d641 1
a641 1
			case 4:		// speed
d646 1
a646 1
						uint32 dRate = lpPartFile->GetDatarate();
d650 1
a650 1
			       		if(theApp.glob_prefs->GetShowAverageDatarate())
d652 1
a652 1
							dRate = lpPartFile->GetAvgDatarate(true);
d658 1
a658 1
						buffer.AppendFormat(_T("[%.2f] "), lpPartFile->GetAvgDatarate(false)/1024.0f);
d665 1
a665 1
			case 5:		// progress
d723 1
a723 1
			case 6:		// sources
d731 1
a731 1
					buffer.Format(_T("%s%i (%i)"),buffer2, lpPartFile->GetSourceCount(), lpPartFile->GetTransferingSrcCount());
d739 1
a739 1
			case 7:		// prio
d773 1
a773 1
			case 8:		// status
d778 2
a779 2
			case 9:	// remaining size and %
				if (!IsColumnHidden(9)) 
d801 2
a802 2
			case 10:	//remaining time
				if (!IsColumnHidden(10)) 
d806 1
a806 1
					if (lpPartFile->GetStatus()!=PS_COMPLETING || lpPartFile->GetStatus()!=PS_COMPLETE)
d811 1
a811 1
						if(theApp.glob_prefs->GetShowAverageDatarate())
d820 1
a820 1
						buffer.AppendFormat(_T("[%s / %s]"), CastItoXBytes(lpPartFile->GetSessionTransfered()), CastSecondsToHM(restTime));
d826 2
a827 2
			case 13:	// last seen complete
				if (!IsColumnHidden(13)) 
d838 2
a839 2
			case 14: // last receive
				if (!IsColumnHidden(14)) 
d841 6
a846 1
					if(lpPartFile->GetFileDate() != NULL)
d857 2
a858 2
			case 15: // cat
				if (!IsColumnHidden(15)) 
d909 1
a909 2
	switch(nClientSoft)
	{
d926 2
a927 2
	uint32 nTransferredDown = lpClient->GetTransferedDown();
	uint32 nDownloadDataRate = lpClient->GetDownloadDatarate();
d966 1
a966 1
							m_ImageList.Draw(dc, 10, point, ILD_NORMAL);
d969 1
a969 1
							m_ImageList.Draw(dc, 9, point, ILD_NORMAL);
d973 1
a973 1
							m_ImageList.Draw(dc, 8, point, ILD_NORMAL);
d977 1
a977 1
							m_ImageList.Draw(dc, 11, point, ILD_NORMAL);
d980 1
a980 1
							m_ImageList.Draw(dc, 12, point, ILD_NORMAL);
d983 1
a983 1
               		m_ImageList.Draw(dc, 11, point, ILD_NORMAL); 
d998 1
a998 1
						m_ImageList.Draw(dc, 23, point2, ILD_NORMAL);
d1001 1
a1001 1
						m_ImageList.Draw(dc, 24, point2, ILD_NORMAL);
d1004 1
a1004 1
						m_ImageList.Draw(dc, 25, point2, ILD_NORMAL);
d1007 1
a1007 1
						m_ImageList.Draw(dc, 3, point2, ILD_NORMAL);
d1010 1
a1010 1
						m_ImageList.Draw(dc, 2, point2, ILD_NORMAL);
d1015 1
a1015 1
							m_ImageList.Draw(dc, 28, point2, ILD_NORMAL);
d1017 1
a1017 1
							m_ImageList.Draw(dc, 1, point2, ILD_NORMAL);
d1020 1
a1020 1
						m_ImageList.Draw(dc, 0, point2, ILD_NORMAL);
d1023 1
a1023 1
						m_ImageList.Draw(dc, 22, point2, ILD_NORMAL);
d1029 1
a1029 1
					m_ImageList.Draw(dc, 6, point2, ILD_TRANSPARENT);
d1031 1
a1031 1
					m_ImageList.Draw(dc, 5, point2, ILD_TRANSPARENT);
d1033 1
a1033 1
					m_ImageList.Draw(dc, 4, point2, ILD_TRANSPARENT);
d1048 1
d1061 1
a1061 1
		case 2:		// transfered
a1151 1
							
d1170 3
a1172 1
						} else {
d1186 3
a1188 1
			} else {
d1208 1
d1466 1
a1466 1

d1544 1
a1544 1

d1651 1
a1651 1

d1826 1
a1826 1

d2293 1
a2293 1

d2299 1
d2310 1
a2310 1

d2319 1
d2325 1
d2327 1
d2453 1
a2453 1

d2457 1
d2459 3
a2461 2
	if (override) m_lastSort-=(m_lastSort>=0)?10000:0;	//simple override, keep the old sorting column, restore it later...
	if (override==99) //major override	wipe old sorting order...
d2491 1
d2518 1
a2518 1

d2522 1
d2529 1
a2529 1
		case 0: //filename asc
d2545 3
a2547 3
		case 2: //transfered asc
			return CompareUnsigned(file1->GetTransfered(), file2->GetTransfered());
	    case 3: //completed asc
d2549 4
a2552 3
		case 4: //speed asc
			return CompareUnsigned(file1->GetDatarate(), file2->GetDatarate());
		case 5: //progress asc
d2557 1
a2557 1
		case 6: //sources asc
d2559 1
a2559 1
		case 7: //priority asc
d2561 1
a2561 1
		case 8: //Status asc 
d2573 1
a2573 1
		case 9: //Remaining size asc
d2579 1
a2579 1
		case 10: //Remaining Time asc
d2620 1
a2620 1
		case 14: //last received Time asc 
d2633 2
a2634 1
		case 15:
d2666 1
a2666 1
		case 2: //transfered asc
d2669 1
a2669 1
			        return CompareUnsigned(client1->GetTransferedDown(), client2->GetTransferedDown());
d2676 1
a2676 1
			        return CompareUnsigned(client1->GetTransferedDown(), client2->GetTransferedDown());
d2681 1
a2681 1
				return CompareUnsigned(client1->GetDownloadDatarate(), client2->GetDownloadDatarate());
d2972 1
a2972 1

d2996 1
a2996 1

d3021 1
a3021 1
							file->GetTransferingSrcCount(),
d3056 1
a3056 1

d3061 2
a3062 1
	POINT point;
d3064 3
a3066 1
	CPoint p = point; 
d3068 3
a3070 1
    int it = HitTest(p); 
d3072 3
a3074 1
    if (it == -1) return;
d3095 1
a3095 1
			dialog.DoModal();
d3143 1
a3143 1

d3158 1
d3162 1
a3162 1
		if(result != -1) 
d3171 1
a3171 1

d3184 1
d3198 1
a3198 1

d3239 1
a3239 1

d3298 2
@


1.225
log
@Fixed problem with root dirs browsing
@
text
@d555 1
a555 1
							::ImageList_Draw(theApp.GetSystemImageList(), iImage, dc->GetSafeHdc(), lpRect->left, lpRect->top, ILD_TRANSPARENT);
@


1.224
log
@Minor fixes (ops!)
@
text
@d2104 2
@


1.223
log
@Fix for lists navigation [from official]
@
text
@a532 6
		bool isReady = (lpPartFile->GetStatus()==PS_READY);
		bool isPaused = (lpPartFile->GetStatus()==PS_PAUSED);
		bool isStopped = (lpPartFile->GetStatus()==PS_STOPPED);
		bool isComplete = (lpPartFile->GetStatus()==PS_COMPLETE);
		bool isCompleting = (lpPartFile->GetStatus()==PS_COMPLETING);

d539 1
a539 1
					if(isComplete)
d541 1
a541 1
					else if(isStopped)
d543 1
a543 1
					else if(isPaused)
d601 1
a601 1
                    if(isReady)
d609 1
a609 1
					else if(isPaused || isStopped)
d647 1
a647 1
					if (!isCompleting && !isComplete)
d711 1
a711 1
						if(!isComplete || !isCompleting)
d792 1
a792 1
					if (isCompleting || isComplete)
d809 1
a809 1
					if (!isCompleting || !isComplete)
@


1.222
log
@Fixed HTMLExport, update SharedList when name is changed, minor fix (not propper) to FileTypeIcon disable in search.
@
text
@d330 1
a330 1
			InsertItem(LVIF_PARAM,itemnr,0,0,0,0,(LPARAM)newitem);
d1540 1
d1619 1
a1619 1
					InsertItem(LVIF_PARAM,item+1,0,0,0,0,(LPARAM)cur_item);
d3169 1
a3169 1
			InsertItem(LVIF_PARAM,GetItemCount(),0,0,0,0,(LPARAM)updateItem);
d3217 59
@


1.221
log
@Added + for A4AF only downloads to show that they are A4AF sources.
@
text
@d2133 1
d2137 1
a2137 1
					} 
@


1.220
log
@More fixes (sharing of files, JS used with downloading files and other minor ones)
@
text
@d552 1
a552 1
						iIcon = lpPartFile->GetSourceCount() > 0 ? (lpPartFile->srcarevisible ? 13 : 15) : 14;
@


1.219
log
@*** empty log message ***
@
text
@d1674 1
d1718 1
a1718 1
			m_FileMenu.EnableMenuItem(MP_STOP,((file->GetStatus() != PS_STOPPED && file->GetStatus() != PS_ERROR && !filedone ) ? MF_ENABLED:MF_GRAYED));
d1721 1
a1721 1
			m_FileMenu.EnableMenuItem(MP_PAUSE,((file->GetStatus() != PS_PAUSED && file->GetStatus() != PS_ERROR && !filedone) ? MF_ENABLED:MF_GRAYED));
d1724 1
a1724 1
			m_FileMenu.EnableMenuItem(MP_RESUME,((file->GetStatus() == PS_PAUSED || file->GetStatus() == PS_STOPPED) ? MF_ENABLED:MF_GRAYED));
d1729 1
a1729 1
			m_FileMenu.EnableMenuItem(MP_OPEN,((justOne && file->GetStatus() == PS_COMPLETE) ? MF_ENABLED:MF_GRAYED)); //<<--9/21/02
d1758 1
a1758 1
			m_FileMenu.EnableMenuItem(MP_DROPNONEEDEDSRCS,((file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING)?MF_ENABLED:MF_GRAYED)); // Added by Tarod	// netwolf 07.05.03
d1762 1
a1762 1
			m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, ((file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));	//netwolf: no dropSCB on complete/ing) files
d1765 1
a1765 1
			m_FileMenu.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(justOne && file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING)?MF_ENABLED:MF_GRAYED); // Tarod(+Cax2 Patch 21/12/02)	//netwolf 07.05.03
d1770 1
a1770 1
			if (justOne && file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING) // Cax2	// netwolf 07.05.03
d1854 1
a1854 1
			
d1907 4
a1910 4
									case PS_WAITINGFORHASH: 
									case PS_HASHING: 
									case PS_COMPLETING: 
									case PS_COMPLETE: 
d1913 1
a1918 4
									//	if (theApp.glob_prefs->StartNextFile()) 
									//	{
									//		theApp.downloadqueue->StartNextFile();
									//	}
@


1.218
log
@Updated templates and improved GetOutputDir
@
text
@d717 1
a717 1
						if(isComplete || isCompleting)
@


1.217
log
@Fixed minor display/string issues
@
text
@d2110 1
a2110 11
					int cat = file->GetCategory();
					CString dir;

					if(cat != 0)
					{
						dir = theApp.glob_prefs->GetCatPath(cat);
						dir += "\\";
					}
					else
						dir = file->GetOutputDir() + "\\";
	
d2112 1
a2112 1
					if(newpath!=(file->GetOutputDir()+ _T("\\")) )
@


1.216
log
@Fixes regarding Category directory handling
@
text
@d653 1
a653 1
					if (isCompleting && isComplete)
d867 1
a867 1
						buffer = GetResString(IDS_ALL);
d879 1
a879 1
							buffer = GetResString(IDS_ALL);
@


1.215
log
@Removed DoubleClick option (now is default).
Added cancel for Categories Dialog (now no more ? cats after cancel)
@
text
@d532 7
d545 1
a545 1
					if(lpPartFile->GetStatus()==PS_COMPLETE)
d547 1
a547 1
					else if(lpPartFile->GetStatus()==PS_STOPPED)
d549 1
a549 1
					else if(lpPartFile->GetStatus()==PS_PAUSED)
d607 2
a608 1
                    if(lpPartFile->GetStatus()==PS_READY) {
d615 1
a615 1
					else if(lpPartFile->GetStatus()==PS_PAUSED || lpPartFile->GetStatus()==PS_STOPPED)
d628 1
a628 1
					if ( !theApp.glob_prefs->GetDisableRatingIcons())
d653 1
a653 1
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
d714 1
a714 1
						   
d716 3
a718 1
						lpRect->left += iWidth / 2 - 10; // Close enough 
d720 1
a720 1
						   
d798 1
a798 1
					if (lpPartFile->GetStatus()==PS_COMPLETING || lpPartFile->GetStatus()==PS_COMPLETE )
d815 1
a815 1
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE)
d2110 11
a2120 1
					CString dir = file->GetOutputDir() + "\\";
@


1.214
log
@Fixed Category Autopriority
@
text
@d1635 1
a1635 6

	if (theApp.glob_prefs->IsDoubleClickEnabled() || pNMIA->iSubItem >= 0)
	{
		ExpandCollapseItem(pNMIA->iItem,2);
	}
		
d2432 3
a2434 8
	if (theApp.glob_prefs->IsDoubleClickEnabled())
	{	
		SetExtendedStyle(LVS_EX_FULLROWSELECT);
	}
	else
	{	
		SetExtendedStyle(LVS_EX_ONECLICKACTIVATE | LVS_EX_FULLROWSELECT);
	}
d2443 1
a2443 1
	if (override==99) //major override, wipe old sorting order...
d2737 10
a2746 12
	if(theApp.glob_prefs->IsDoubleClickEnabled())	// pretty useless/faulty if single-click 
	{												// for opening is activated
		DWORD pos = GetMessagePos();
		CPoint pt(LOWORD(pos), HIWORD(pos));
		ScreenToClient(&pt);

		// Get indexes of the first and last visible items in 
		// the listview control.
		int index = GetTopIndex();
		int last_visible_index = index + GetCountPerPage();
		if(last_visible_index > GetItemCount())
			last_visible_index = GetItemCount();
d2748 9
a2756 2
		// Loop until number visible items has been reached.
		while(index <= last_visible_index)
d2758 16
a2773 9
			// Get the bounding rectangle of an item. If the mouse
			// location is within the bounding rectangle of the item,
			// you know you have found the item that was being clicked.
			CRect r;
			GetItemRect(index, &r, LVIR_BOUNDS);
			if(r.PtInRect(pt))
			{
				ST_CTRLITEM *pListItem = (ST_CTRLITEM*)GetItemData(index);
				if(!pListItem)
d2775 18
a2792 1
				if(!pListItem->eType == FILE_TYPE)			// if it isn't a file we're done
d2794 1
a2794 8

			// [+]/[-]	
				CRect rPlusMinus(r);
				rPlusMinus.left += 4 + 4;			// eeek, hardcoded values
				rPlusMinus.top += 1 + 2;						//  --||--
				rPlusMinus.right = rPlusMinus.left + 16 - 4;	//  --||--
				rPlusMinus.bottom = rPlusMinus.top + 16 - 4;	//  --||--
				if(rPlusMinus.PtInRect(pt))
d2796 2
a2797 7
					CPartFile *pPartFile = (CPartFile*)pListItem->pValue;
					if(!pPartFile)
						return;
					if(pPartFile->GetStatus() == PS_PAUSED)
						pPartFile->ResumeFile();
					else
						OnItemActivate(pNMHDR, pResult);
d2799 3
d2803 3
a2805 26
			// rating
				CRect rRating;
				rRating.left = rPlusMinus.right+2; //EC 30.07.03 +2 for filetype icon gap +16 for size
				if (theApp.glob_prefs->ShowFileTypeIcon())
					rRating.left += 16+2; //EC 30.07.03 +2 for filetype icon gap +16 for size
				rRating.top = rPlusMinus.top;
				rRating.right = rRating.left + 16 - 6;
				rRating.bottom = rRating.top + 16 - 2;
				if(rRating.PtInRect(pt))
				{						
					CPartFile *pPartFile = (CPartFile*)pListItem->pValue;
					if(!pPartFile)
						return;
					if(pPartFile->HasComment()||pPartFile->HasRating())		//Cax2 - bugfix!
					{	
						CCommentDialogLst dlg(pPartFile); 
						dlg.DoModal(); 
					}
                }
				break;
			}

			// Get the next item in listview control.
			index++;
		}
	}	
@


1.213
log
@Minor changes
@
text
@d213 76
a288 76
	  CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
	  HDITEM hdi;
	  hdi.mask = HDI_TEXT;
	  CString strRes;
  
	  strRes = GetResString(IDS_DL_FILENAME);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(0, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_DL_SIZE);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(1, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_DL_TRANSF);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(2, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_SF_COMPLETED);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(3, &hdi);
	  strRes.ReleaseBuffer();

	  strRes = GetResString(IDS_DL_SPEED);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(4, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_DL_PROGRESS);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(5, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_DL_SOURCES);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(6, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_PRIORITY);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(7, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_STATUS);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(8, &hdi);
	  strRes.ReleaseBuffer();
  
	  strRes = GetResString(IDS_DL_REMAINS);	// netwolf 14.05.03
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(9, &hdi);
	  strRes.ReleaseBuffer();

	  strRes = GetResString(IDS_TIME); // should be est. time
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(10, &hdi);
	  strRes.ReleaseBuffer();

	  // Maverick
	  strRes = GetResString(IDS_DL_ULDL);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(11, &hdi);
	  strRes.ReleaseBuffer();

	  strRes = GetResString(IDS_QL_RATING);
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(12, &hdi);
	  strRes.ReleaseBuffer();

	  strRes = GetResString(IDS_LASTSEENCOMPL);
	  strRes.Remove(':');
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(13, &hdi);
	  strRes.ReleaseBuffer();
d778 1
a779 1

d801 1
d826 6
a831 6
			{
				if (lpPartFile->lastseencomplete==NULL)
					buffer=GetResString(IDS_NEVER);
				else
				buffer = lpPartFile->localelastseencomplete();
				//buffer=lpPartFile->lastseencomplete.Format( "%A, %x, %X");
d833 2
a834 1
				dc->DrawText(buffer,(int)_tcslen(buffer),lpRect, DLC_DT_TEXT);
a835 1
			}
d838 1
a838 1
				if (!IsColumnHidden(11)) 
d852 1
a852 1
				if (!IsColumnHidden(12)) 
a853 2
	//				buffer = (lpPartFile->GetCategory() != 0) ?
	//					theApp.glob_prefs->GetCategory(lpPartFile->GetCategory())->title : GetResString(IDS_ALL);
d876 1
a876 2
            // Maverick
			//case 9 & 10
@


1.212
log
@Chnaged SUI again to icon based
@
text
@a1043 1
				// EC - Use Dark Green for SUI Clients
a1044 4
				//if (lpClient->credits->GetCurrentIdentState(lpClient->GetIP()) == IS_IDENTIFIED)
				//{				
				//	crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));
				//}
d1048 1
a1048 1
                if(a4af || lpClient->credits->GetCurrentIdentState(lpClient->GetIP()) == IS_IDENTIFIED)
@


1.211
log
@Fixed problem with exchanged sources names.
@
text
@d1011 4
a1014 1
						m_ImageList.Draw(dc, 1, point2, ILD_NORMAL);
d1046 4
a1049 4
				if (lpClient->credits->GetCurrentIdentState(lpClient->GetIP()) == IS_IDENTIFIED)
				{				
					crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));
				}
@


1.210
log
@Implemented ConfigDir
@
text
@d1036 2
a1037 2
				} else {	
					buffer1.Format(_T("%s %s"), sClientName.GetBuffer(0), status.GetBuffer(0));
d3224 1
a3224 1
}@


1.209
log
@SUI Clients are shown with a green name now instead of a check in the icon
@
text
@d142 1
a142 1
	InsertColumn(10,GetResString(IDS_TIME),LVCFMT_LEFT, 110); // should be est. time or ETA
d156 1
a156 1
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));				// 0
d161 2
a162 2
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      	// 5
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      	// 6
d164 6
a169 6
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));         		// 8
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));         		// 9
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));         		// 10
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));         		// 11
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));         		// 12
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  		// 13
d172 1
a172 1
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));			// 16
d178 2
a179 2
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  			// 22
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  			// 23
d181 4
a184 4
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  			// 25
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTCOMPLETE),16,16));  		// 26
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTSTOPPED),16,16));  		// 27
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  		// 28
d634 1
a634 1
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d639 1
a639 1
			    dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d845 1
a845 1
						dc->DrawText(odtTime.Format(), lpRect, DLC_DT_TEXT);	
a1028 3
			
					
				
d1034 1
a1034 1
				{					
d1036 1
a1036 1
				} else {					
d1045 1
a1045 1
					crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));								
d1051 1
a1051 1
                	dc->SetTextColor(crOldTxtColor);				
d1212 1
a1212 1
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d1218 1
a1218 1
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d1510 1
a1510 1
			m_lastSort = FilesSortIndex;	
@


1.208
log
@no Drop SCB on complete/ing files
@
text
@d1029 2
a1030 2
				if (lpClient->credits->GetCurrentIdentState(lpClient->GetIP()) == IS_IDENTIFIED)
					m_ImageList.Draw(dc, 28, point2, ILD_TRANSPARENT);
d1044 1
d1046 4
a1049 1

d1053 1
a1053 1
                if(a4af)
@


1.207
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d1759 1
a1759 10
			m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, MF_ENABLED);
			/*
			if (justOne && file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING) {
				m_FileMenu.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, file->GetDiscardSuperCompressed() ? MF_CHECKED:MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, MF_ENABLED);
			} else {
				m_FileMenu.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, MF_GRAYED);
			}
			*/
@


1.206
log
@bugfix for showing completed files via webserver
@
text
@d184 1
d1029 3
@


1.205
log
@Fixed again doubleclick unpausing files
@
text
@d3049 1
@


1.204
log
@fixes
@
text
@d1535 2
d1577 1
a1577 2
	if(/*partfile->GetStatus() == PS_PAUSED ||*/ partfile->GetStatus() == PS_STOPPED && !m_dblclicked)
	{
d1579 1
a1579 5
		return;
	}

	if (partfile->GetStatus() == PS_COMPLETE && !m_dblclicked) 
	{
a1580 3
		return;
	}

d1582 1
a1582 1
	if(partfile->srcarevisible == false && partfile->GetStatus() != PS_COMPLETING) 
d1625 2
@


1.203
log
@bugfixes
@
text
@d1486 25
d1575 1
a1575 1
	if(partfile->GetStatus() == PS_PAUSED || partfile->GetStatus() == PS_STOPPED && !m_dblclicked)
d2356 1
a2356 1
		comp = Compare((CPartFile*)item1->pValue, (CPartFile*)item2->pValue,0);
d2795 10
a2804 1
					OnItemActivate(pNMHDR, pResult);
@


1.202
log
@Fixes
@
text
@d71 1
a71 1
	return (CPartFile*)pItem->pOwner;
d2289 1
a2289 1
#ifndef _THISDEFINEDOESNOTEXIST_
d2297 2
a2298 2
	bool showSrc = false;  
	if (lParamSort >= 1000)
d2300 2
a2301 2
		showSrc = true; 
		lParamSort -= 1000; 
d2311 1
a2311 1
/*	if ((item1->eType == FILE_TYPE && item2->eType != FILE_TYPE) ||
a2328 26
*/	
	if(item1->eType == FILE_TYPE && item2->eType != FILE_TYPE)
	{
		if(item1->pValue == item2->pParent->pValue)
		{
			return -1;
		}

		comp = Compare((CPartFile*)(item1->pValue), (CPartFile*)(item2->pParent->pValue), lParamSort);
	}
	else if(item2->eType == FILE_TYPE && item1->eType != FILE_TYPE)
	{
		if(item1->pParent->pValue == item2->pValue)
		{
			return 1;
		}

		comp = Compare((CPartFile*)(item1->pParent->pValue), (CPartFile*)(item2->pValue), lParamSort);
	}
	else if(item1->eType == FILE_TYPE)
	{
		CPartFile* file1 = (CPartFile*)item1->pValue;
		CPartFile* file2 = (CPartFile*)item2->pValue;

		comp = Compare(file1, file2, lParamSort);
	}
d2331 3
a2333 3
	/*	comp = Compare(GetFile(item1), GetFile(item2),0);
        if(comp != 0) 
		{
d2337 1
a2337 1
		if ((IsAskedForAnotherFile(item1) || IsAskedForAnotherFile(item2)) && lParamSort!=0)
d2348 1
a2348 1
			if (n!=0)			//always at the end, unless sort by source - then a4af always at the top
d2350 1
a2350 1
				return (lParamSort==5)? n : -n;
a2352 29
		*/CUpDownClient* pItem1 = (CUpDownClient*)item1->pValue;
		CUpDownClient* pItem2 = (CUpDownClient*)item2->pValue;
		comp = Compare(pItem1, pItem2, lParamSort, sortMod);
    } 
   	return sortMod * comp;

	EMULE_CATCH
	return 0;
}
#else
int CDownloadListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	EMULE_TRY

	ST_CTRLITEM* item1 = (ST_CTRLITEM*)lParam1;
	ST_CTRLITEM* item2 = (ST_CTRLITEM*)lParam2;

	bool showSrc=false;  
	if (lParamSort>=1000)
	{ 
		showSrc=true; 
		lParamSort-=1000; 
	} 
    int sortMod = 1;
    if(lParamSort >= 100)	//Cax2 - more than 10 columns
    {
		sortMod = -1;
		lParamSort -= 100;
	}
a2353 28
	int comp;
	if ((item1->eType == FILE_TYPE && item2->eType != FILE_TYPE) ||
		(item2->eType == FILE_TYPE && item1->eType != FILE_TYPE))
	{ // files vs source?
		comp=0; // leave it as it is...
	} else if (item1->eType == FILE_TYPE) { //both files? (!)
		if (showSrc)
			comp= 0;
		else
		{ 
			CPartFile* file1 = (CPartFile*)item1->pValue;
			CPartFile* file2 = (CPartFile*)item2->pValue;
			comp = Compare(file1, file2, lParamSort);
		}
    } else { //both sources...
		comp = Compare((CPartFile*)(item1->pParent->pValue), (CPartFile*)(item2->pParent->pValue),0);
        if(comp != 0) return 0;
		//Cax2:a4af clients kept separate, unless sorting for name
		if ((IsAskedForAnotherFile(item1) || IsAskedForAnotherFile(item2)) && lParamSort!=0)
		{
			int n = 0;
			if(IsAskedForAnotherFile(item1) && IsAskedForAnotherFile(item2))
				n = -1;
			if(IsAskedForAnotherFile(item2) && IsAskedForAnotherFile(item1))
				n = 1;
			if (n!=0)			//always at the end, unless sort by source - then a4af always at the top
				return (lParamSort==5)? n : -n;
		}
d2361 1
a2361 1
#endif
@


1.201
log
@*** empty log message ***
@
text
@d2899 1
a2899 1
				//if(file->GetStatus()==PS_COMPLETE)
@


1.200
log
@another bugfix
@
text
@d1614 1
a1614 1
	if (theApp.glob_prefs->IsDoubleClickEnabled() || pNMIA->iSubItem > 0)
@


1.199
log
@Fixes
@
text
@d1305 1
a1305 1
			int cx = GetColumnWidth(iColumn);
@


1.198
log
@bugfix
@
text
@d1550 2
a1551 4
	if(partfile->GetStatus() == PS_PAUSED || 
	   partfile->GetStatus() == PS_STOPPED &&
	   !m_dblclicked)
	{		
d1558 1
a1558 2
		//ClearCompleted(partfile->GetFileHash());
		ShellOpenFile(partfile->GetFullName());
d2606 1
a2606 1
		return CompareUnsigned(file1->GetTransfered(), file2->GetTransfered());
d2608 1
a2608 1
		return CompareUnsigned(file1->GetCompletedSize(), file2->GetCompletedSize());
d2610 1
a2610 1
		return CompareUnsigned(file1->GetDatarate(), file2->GetDatarate());
a2708 1
	{
d2710 1
a2710 1
	}
d2714 1
a2714 1
				{
d2723 3
a2725 2
				}
			case 2: //transfered asc
d2730 3
a2732 1
	        case 3://completed asc
d2737 2
a2738 1
			case 4: //speed asc
d2740 1
a2740 1
			case 5: //progress asc
d2742 2
a2743 1
			case 6: //sources column
d2767 2
a2768 2
			case 7: //priority column - QR 
			if (client1->GetDownloadState()!=DS_ONQUEUE || client2->GetDownloadState()!=DS_ONQUEUE)	//Cax2 QR gaps bugfix
d2770 14
a2783 11
				if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
					return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
				if (client1->GetDownloadState()==DS_DOWNLOADING || client2->GetDownloadState()==DS_DOWNLOADING)		//Cax2 QR gaps bugfix
					return (client1->GetDownloadState()==DS_DOWNLOADING)?((client2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2; //Cax2 QR gaps bugfix
				return (client1->GetDownloadState()!=DS_ONQUEUE)?((client2->GetDownloadState()!=DS_ONQUEUE)?0:sortMod):-1*sortMod;		//Cax2 now should show properly...
			}
			if (sortMod<0 || (client1->GetRemoteQueueRank()>0 && client2->GetRemoteQueueRank()>0))
				return client1->GetRemoteQueueRank() - client2->GetRemoteQueueRank();   
			if(client1->GetRemoteQueueRank()==0 && client2->GetRemoteQueueRank()==0)
				return (client1->IsEmuleClient())?((client2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
			return (client1->GetRemoteQueueRank()==0)?((client2->GetRemoteQueueRank()==0)?0:2):-1;  
a2785 1
		//Cax2 - sort bugfix
d2788 15
a2802 15
		{	//Cax2 - faster this way & less code to go wrong...
			if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
				return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
			bool isValid1 = (client1->IsRemoteInfoAvaiable()|| client1->credits);
			bool isValid2 = (client2->IsRemoteInfoAvaiable()|| client2->credits);
			if ( lParamSort==10 && isValid1 && isValid2) //Cax2 - bugfix after reCDVst changes 
				return (client1->GetRemoteBaseModifier() <client2->GetRemoteBaseModifier())?-1:1;		//Cax2 - has to return an integer!
			if (isValid1 && isValid2)		//Cax2 - it's got to be lParamSort==11 after reCDVst changes 
				return client1->GetRemoteRatio() - client2->GetRemoteRatio();
			if (isValid1)				
				return 1;
			if (isValid2)				
				return -1;
			return 0;
		}
d2899 1
a2899 1
			//	if(file->GetStatus()==PS_COMPLETE)
a2904 1
			//		m_dblclicked=true;
@


1.197
log
@*** empty log message ***
@
text
@d539 3
a541 1
					else if(lpPartFile->GetStatus()==PS_PAUSED || lpPartFile->GetStatus()==PS_STOPPED)
d1269 1
a1269 1
	cur_rec.left += iOffset;
d1276 1
a1276 1
			int cx = GetColumnWidth(iColumn);
d1320 3
a1322 1
			} else {
@


1.196
log
@Fixed sorting of Completed colum (transferred)
@
text
@d43 1
a43 1
bool CMuleCtrlItem::IsAskedForAnotherFile()
d45 14
a58 1
	return (m_pSource ? (m_pSource->reqfile != m_pFile) : false); 
d61 12
a78 7
//temp fix for dragging columns
#define GetColumnWidth(X)   (CListCtrl::GetColumnWidth(X))

// CDownloadListCtrl

// hmm some parts here might be overkill ;) ...
// oh well at least I can do/draw/paint everything I want in this window now ;)
d95 5
a99 1
	while(m_ListData.empty() == false)
d101 1
a101 2
		delete m_ListData.begin()->second;
		m_ListData.erase(m_ListData.begin());
d103 8
a110 1
	imagelist.DeleteImageList();	//eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d120 1
a120 1
	ilDummyImageList.Create(1, 17,ILC_COLOR32 | ILC_MASK, 1, 1); 
d122 3
d140 2
a142 1
	// Maverick
d145 2
a146 1
	CString lsctitle=GetResString(IDS_LASTSEENCOMPL);
d149 4
d154 30
a183 35
#ifdef __USE_CATEGORIES__
	curTab=0;
#endif

	imagelist.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	imagelist.SetBkColor(CLR_NONE);
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));				// 0
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));				// 1
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));				// 2
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  		// 3
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_DOWNESTIMATED),16,16));	// 4
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      	// 5
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      	// 6
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPAUSED),16,16));  			// 7
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));         		// 8
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));         		// 9
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));         		// 10
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));         		// 11
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));         		// 12
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  		// 13
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  			// 14
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  			// 15
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));			// 16
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));		// 17
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));			// 18
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));	  		// 19
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));			// 20
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));	  		// 21
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  			// 22
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  			// 23
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  				// 24
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  			// 25
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTCOMPLETE),16,16));  		// 26
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTSTOPPED),16,16));  		// 27
	
d187 1
d190 2
a191 1
	if (theApp.glob_prefs->DoUseSort())
d193 3
a195 1
	else {
d288 13
d311 1
d313 10
d324 8
a331 13
	// Create item
	CMuleCtrlItem* pItem = new CMuleCtrlItem(toadd, NULL);
	// The same file shall be added only once
	ASSERT(m_ListData.find(toadd) == m_ListData.end());
	m_ListData.insert(make_pair(toadd, pItem));

	uint16 itemnr = GetItemCount();
	InsertItem(LVIF_PARAM,itemnr,0,0,0,0,(LPARAM)pItem);

#ifdef __USE_CATEGORIES__
	if(CheckShowItemInGivenCat(toadd, curTab ))
		InsertItem(LVIF_PARAM,itemnr,0,0,0,0,(LPARAM)pItem);
#endif
d336 1
a336 1
void CDownloadListCtrl::AddSource(CPartFile* owner,CUpDownClient* source,bool notavailable)
d340 2
a341 1
	if(!owner || !source)
a342 11

	CMuleCtrlItem* pItem = NULL;
	MuleRange Range = m_ListData.equal_range(source);
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		CMuleCtrlItem* pItem2 = g->second;
		if(pItem2->GetFile() == owner)
		{
			pItem = pItem2;
			break;
		}
d345 35
a379 1
	CMuleCtrlItem* pParent = NULL;
d381 6
a386 28
	// Create item, if it's new
	if(!pItem)
	{
		// Find parent
		MuleIter g = m_ListData.find(owner);
		if(g == m_ListData.end())
			return;
		pParent = g->second;
		pItem = new CMuleCtrlItem(owner, source);
		m_ListData.insert(make_pair(source, pItem));
	}
	else
		return;

	if (!owner->srcarevisible)
		return;

	LVFINDINFO find;
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pParent;
	int nItem = FindItem(&find);
	if(nItem < 0) nItem = 0;
	while (GetItemCount() > nItem+1 && !((CMuleCtrlItem*)GetItemData(nItem+1))->IsFile())
		nItem++;

	InsertItem(LVIF_PARAM,nItem+1,0,0,0,0,(LPARAM)pItem);

	//RefreshInfo();	// eklmn: bugfix(12): refresh whole list
d392 1
a392 1
void CDownloadListCtrl::RemoveSource(CUpDownClient* source,CPartFile* owner)
d395 6
a400 6
	//eklmn: do nothing if mule will be closed
	if (!theApp.emuledlg->IsRunning()) return;
	//eklmn: check null case
	if(!source) return;
	
	if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 1)
d402 1
a402 5
		if(theApp.emuledlg->transferwnd.infolistctrl.GetClient() == source)
		{
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
		}
d405 3
a407 2
	MuleRange Range = m_ListData.equal_range(source);
	for(MuleIter g = Range.first; g != Range.second; )
d409 2
a410 2
		CMuleCtrlItem* pSource = g->second;
		if(!owner || pSource->GetFile() == owner)
d412 15
a426 11
			g = m_ListData.erase(g);
			//Don't refresh during app shutdown [TwoBottle Mod]
			//if (::IsWindow(m_hWnd)) {
 				LVFINDINFO find;
				find.flags = LVFI_PARAM;
				find.lParam = (LPARAM)pSource;
				sint16 result = FindItem(&find);
				if(result != -1)
					DeleteItem(result);
			//}
			delete pSource;
d429 3
a431 1
			g++;
d433 1
a433 1
		
a439 3
	if (!theApp.emuledlg->IsRunning()) return;
	//check NULL case
	if(!toremove) return;
d441 1
a441 1
	if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 2)
d443 13
a455 1
		if(theApp.emuledlg->transferwnd.infolistctrl.GetFile() == toremove)
d457 2
a458 4
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
		}
	}			
d460 1
a460 6
	for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); )
	{
		CMuleCtrlItem* pItem = g->second;
		if(pItem->GetFile() == toremove)
		{
			g = m_ListData.erase(g);
d463 2
a464 2
			find.lParam = (LPARAM)pItem;
			int result = FindItem(&find);
d466 1
d468 8
a475 1
			delete pItem;
a476 2
		else
			g++;
d478 1
a478 2
	//eklmn: refresh DL-list after file was removed.
	RefreshInfo();
a484 2
	if (!::IsWindow(m_hWnd))	//fix crash at exit [TwoBottle Mod]
		return;
d487 6
a492 2
	MuleRange Range = m_ListData.equal_range(toupdate);
	for(MuleIter g = Range.first; g != Range.second; g++)
d494 17
a510 12
		CMuleCtrlItem* pItem = g->second;
		LVFINDINFO find;
		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pItem;
		int result = FindItem(&find);
		if (result != -1)
		{
			pItem->m_dwUpdated = 0;
			Update(result);
			//RedrawItems(result,result);
			//if(pItem->IsFile())
			//	theApp.sharedfiles->UpdateItem(((CKnownFile*)toupdate),false);
d519 1
a519 1
void CDownloadListCtrl::DrawFileItem(CDC *dc, int nColumn, LPRECT lpRect, CMuleCtrlItem *lpCtrlItem) 
d523 1
a523 1
	if(!lpCtrlItem->IsFile())
d530 1
a530 1
		CPartFile *lpPartFile = lpCtrlItem->GetFile();
d539 1
a539 3
					else if(lpPartFile->GetStatus()==PS_STOPPED)
						iIcon = 27;
					else if(lpPartFile->GetStatus()==PS_PAUSED)
d543 1
a543 1
					imagelist.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d587 1
a587 1
							imagelist.Draw(dc, image, point, ILD_NORMAL);
d606 2
d669 2
a670 2
					if (lpCtrlItem->m_Status == (HBITMAP)NULL)
						VERIFY(lpCtrlItem->m_Status.CreateBitmap(1, 1, 1, 8, NULL)); 
d674 1
a674 1
					int cx = lpCtrlItem->m_Status.GetBitmapDimension().cx; 
d676 1
a676 1
					if(lpCtrlItem->m_dwUpdated + DLC_BARUPDATE < dwTicks || cx !=  iWidth || !lpCtrlItem->m_dwUpdated)
d678 4
a681 4
						lpCtrlItem->m_Status.DeleteObject(); 
						lpCtrlItem->m_Status.CreateCompatibleBitmap(dc,  iWidth, iHeight); 
						lpCtrlItem->m_Status.SetBitmapDimension(iWidth,  iHeight); 
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->m_Status); 
d690 1
a690 1
						lpCtrlItem->m_dwUpdated = dwTicks + (rand() % 128); 
d692 1
a692 1
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->m_Status); 
d822 4
a825 4
		    {
			    if (lpPartFile->lastseencomplete==NULL)
				    buffer=GetResString(IDS_NEVER);
			    else
d829 45
a873 3
			    dc->DrawText(buffer,(int)_tcslen(buffer),lpRect, DLC_DT_TEXT);
		    }
		    break;
d884 1
a884 1
void CDownloadListCtrl::DrawSourceItem(CDC *dc, int nColumn, LPRECT lpRect, CMuleCtrlItem *lpCtrlItem) 
d888 3
a890 1
	if(!lpCtrlItem->IsSource())
d893 2
d896 1
a896 1
	CUpDownClient *lpClient = lpCtrlItem->GetSource();
d902 2
a903 1
	switch(nClientSoft){
d930 1
a930 1
	bool a4af=lpCtrlItem->IsAskedForAnotherFile();
d935 2
a936 2

	switch(nColumn)
d960 1
a960 1
							imagelist.Draw(dc, 10, point, ILD_NORMAL);
d963 1
a963 1
							imagelist.Draw(dc, 9, point, ILD_NORMAL);
d967 1
a967 1
							imagelist.Draw(dc, 8, point, ILD_NORMAL);
d971 1
a971 1
							imagelist.Draw(dc, 11, point, ILD_NORMAL);
d974 1
a974 1
							imagelist.Draw(dc, 12, point, ILD_NORMAL);
d977 1
a977 1
               		imagelist.Draw(dc, 11, point, ILD_NORMAL); 
d992 1
a992 1
						imagelist.Draw(dc, 23, point2, ILD_NORMAL);
d995 1
a995 1
						imagelist.Draw(dc, 24, point2, ILD_NORMAL);
d998 1
a998 1
						imagelist.Draw(dc, 25, point2, ILD_NORMAL);
d1001 1
a1001 1
						imagelist.Draw(dc, 3, point2, ILD_NORMAL);
d1004 1
a1004 1
						imagelist.Draw(dc, 2, point2, ILD_NORMAL);
d1008 1
a1008 1
						imagelist.Draw(dc, 1, point2, ILD_NORMAL);
d1011 1
a1011 1
						imagelist.Draw(dc, 0, point2, ILD_NORMAL);
d1014 1
a1014 1
						imagelist.Draw(dc, 22, point2, ILD_NORMAL);
d1020 1
a1020 1
					imagelist.Draw(dc, 6, point2, ILD_TRANSPARENT);
d1022 1
a1022 1
					imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
d1024 1
a1024 1
					imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
d1048 1
d1057 1
a1057 1
			break;
d1084 2
a1085 2
				if (lpCtrlItem->m_Status == (HBITMAP)NULL)
					VERIFY(lpCtrlItem->m_Status.CreateBitmap(1, 1, 1, 8, NULL)); 
d1089 1
a1089 1
				int cx = lpCtrlItem->m_Status.GetBitmapDimension().cx; 
d1091 1
a1091 1
				if(lpCtrlItem->m_dwUpdated + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !lpCtrlItem->m_dwUpdated)
d1093 4
a1096 4
					lpCtrlItem->m_Status.DeleteObject(); 
					lpCtrlItem->m_Status.CreateCompatibleBitmap(dc,  iWidth, iHeight); 
					lpCtrlItem->m_Status.SetBitmapDimension(iWidth,  iHeight); 
					hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->m_Status); 
d1107 1
a1107 1
					lpCtrlItem->m_dwUpdated = dwTicks + (rand() % 128); 
d1109 1
a1109 1
					hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->m_Status); 
d1197 1
a1197 1
		case 9:	// remaining size
d1213 1
a1214 1
	
d1222 2
d1226 1
d1228 1
d1230 2
d1233 1
a1233 1
	CMuleCtrlItem* content = (CMuleCtrlItem*)lpDrawItemStruct->itemData;
d1236 1
a1236 1
	if ((content->IsFile()) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d1267 1
a1267 1
	cur_rec.left += iOffset/2;
d1269 1
a1269 1
	if (content->IsFile())
d1288 3
a1290 1
			} else {
d1298 1
a1298 1
	else if (content->IsSource())
d1328 1
a1328 1
		(lpDrawItemStruct->itemState & ODS_SELECTED) && (content->IsFile()))
d1347 2
a1348 2
			CMuleCtrlItem* prev = (CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID - 1);
			if(prev->IsFile())
d1354 2
a1355 2
			CMuleCtrlItem* next = (CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1);
			if(next->IsFile())
d1389 4
a1392 4
			((CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1))->IsSource();
		BOOL isOpenRoot = hasNext && content->IsFile();
		BOOL isChild = content->IsSource();
		BOOL isExpandable = !isChild && content->GetFile()->GetSourceCount() > 0;
d1452 39
d1492 1
a1492 1
	ON_NOTIFY_REFLECT(LVN_ITEMACTIVATE, OnLvnItemActivate)
d1496 1
a1497 1
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)
d1499 1
a1499 1
	ON_WM_CONTEXTMENU()
d1504 1
a1504 1
void CDownloadListCtrl::OnLvnItemActivate(NMHDR *pNMHDR, LRESULT *pResult)
d1506 4
a1509 1
	EMULE_TRY
d1511 1
a1511 2
	LPNMITEMACTIVATE pNMIA = reinterpret_cast<LPNMITEMACTIVATE>(pNMHDR);
	CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(pNMIA->iItem);
d1513 8
a1520 14
	//--- xrmb:smartopen ---
	bool	isShift=GetAsyncKeyState(VK_SHIFT) < 0;
	bool	isCtrl=GetAsyncKeyState(VK_CONTROL) < 0;
	bool	isAlt=GetAsyncKeyState(VK_MENU) < 0;
	int		added=0;
	//--- :xrmb ---

	if (content->IsFile())
	{
		SetRedraw(false);
		if(theApp.glob_prefs->DoUseSort() && !m_ShowSrc)		//Cax2 - restore the sort index that was there before opening the files if advanced sort
			FilesSortIndex=m_lastSort; 
		m_ShowSrc=true;  //newsort added by Cax2 03/11/02 
		CPartFile* partfile = content->GetFile();
d1522 70
a1591 32
		if((partfile->GetStatus()==PS_PAUSED || partfile->GetStatus()==PS_STOPPED) && !m_dblclicked)
			partfile->ResumeFile();
		else if(partfile->GetStatus()==PS_COMPLETE && !m_dblclicked)
			ClearCompleted(partfile->GetFileHash());
		else if ((!partfile->srcarevisible) && partfile->GetSourceCount()>0 && partfile->GetStatus()!=PS_COMPLETING)	//Cax2: when (slow) completing, the files stay shut
		{
			CUpDownClient* client;
			CMuleCtrlItem* pItem;
			for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); g++)
			{
				pItem = g->second;
				if (pItem->IsSource() && pItem->GetFile() == partfile)
				{
					client = pItem->GetSource();
					//--- xrmb:smartopen ---
					//--- if shift key only show ppl with transfer ---
					if(isShift || isCtrl || isAlt)
					{
						uint8 ds = client->GetDownloadState();
						if(!(isShift	&& ds==DS_DOWNLOADING && !pItem->IsAskedForAnotherFile() ||		//Cax2 - don't show clients transferring to another file...
							isCtrl	&& client->GetRemoteQueueRank()>0 ||
							isAlt	&& ds!=DS_NONEEDEDPARTS))
								continue;
					}
					added++;
					//--- :xrmb ---
					InsertItem(LVIF_PARAM,pNMIA->iItem+1,0,0,0,0,(LPARAM)pItem);
				}
			}
			//--- xrmb:smartopen ---
			partfile->srcarevisible = added!=0;
			//--- :xrmb ---
d1593 19
a1611 2
		else
			HideSources(partfile); //Cax2 closefile bugfix [thx Lord KiRon] 
d1613 3
a1615 3
		SortInit(partfile->srcarevisible&&theApp.glob_prefs->DoUseSort()); //override if useSort & showing sources...
		//newsort end 
		SetRedraw(true);
d1617 1
d1619 1
a1619 1
	m_dblclicked = false;
d1635 1
a1635 1
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
d1637 4
a1640 1
		if (content->IsFile()) cFile = content->GetFile();
d1647 1
a1647 1
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(file); // FoRcHa
d1774 1
a1774 1
			const CUpDownClient* client = content->GetSource();
d1776 1
a1776 1
				theApp.emuledlg->transferwnd.infolistctrl.SwitchToUser((CUpDownClient*)client);
d1789 1
a1789 1
			if(content->IsAskedForAnotherFile())
d1808 1
a1808 2
	try
	{
d1812 3
a1814 3
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
		
		// for multiple selections 
d1824 4
a1827 2
				if (((CMuleCtrlItem*)GetItemData(index))->IsFile())
					selectedList.AddTail(((CMuleCtrlItem*)GetItemData(index))->GetFile());
d1831 1
a1831 1
		if (content->IsFile())
d1833 1
a1833 1
			CPartFile* file = content->GetFile();
d1835 2
a1836 1
			if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+256) {
d1839 4
a1842 4

		#ifdef __USE_CATEGORIES__
			if (wParam>=MP_ASSIGNCAT && wParam<=MP_ASSIGNCAT+99) {
				while(!selectedList.IsEmpty()) { 
d1847 1
a1847 1
				ChangeCategory(curTab);
a1848 1
		#endif
d1850 1
a1850 1
			switch (wParam) //Cax2 note: all multiple/single selection code is now merged into one! [thx LordKiRon]
d1852 1
d1854 3
d1858 4
a1861 1
						CString fileList; 
d1864 1
a1864 7
							fileList += "\n" ; 
							fileList += selectedList.GetAt(pos)->GetFileName(); 
						} 
						CString str=(selectedCount > 1)?GetResString(IDS_Q_CANCELDL):GetResString(IDS_Q_CANCELDL2);	//Cax2 bugfix: plurals
						if (MessageBox(str + fileList,GetResString(IDS_CANCEL),MB_ICONQUESTION|MB_YESNO) == IDYES)
						{ 
							while(!selectedList.IsEmpty())
d1866 20
a1885 1
								switch(selectedList.GetHead()->GetStatus())
d1892 2
a1893 2
										break; 
									default: 
d1896 8
d1907 1
a1907 1
						break; 
d1909 2
d1912 11
a1922 5
					while(!selectedList.IsEmpty())
					{ 
						selectedList.GetHead()->SetAutoPriority(false); // Tarod
						selectedList.GetHead()->SetPriority(PR_HIGH); 
						selectedList.RemoveHead();
d1924 3
a1926 1
					break; 
d1928 11
a1938 5
					while(!selectedList.IsEmpty())
					{ 
						selectedList.GetHead()->SetAutoPriority(false); // Tarod
						selectedList.GetHead()->SetPriority(PR_LOW); 
						selectedList.RemoveHead();
d1940 3
a1942 1
					break; 
d1944 11
a1954 5
					while(!selectedList.IsEmpty())
					{ 
						selectedList.GetHead()->SetAutoPriority(false); // Tarod
						selectedList.GetHead()->SetPriority(PR_NORMAL); 
						selectedList.RemoveHead();
d1956 15
a1970 7
					break; 
				case MP_PRIOAUTO: // Added by Tarod
					while(!selectedList.IsEmpty())
					{ 
						selectedList.GetHead()->SetAutoPriority(true);  // Added by Tarod
						selectedList.GetHead()->SetPriority(PR_NORMAL); 
						selectedList.RemoveHead();
d1972 3
a1974 1
					break; 
d1976 10
a1985 4
					while(!selectedList.IsEmpty())
					{ 
						selectedList.GetHead()->PauseFile(); 
						selectedList.RemoveHead();
d1987 2
a1988 1
					break; 
d1990 1
a1990 1
					while(!selectedList.IsEmpty())
d1992 8
a1999 3
						selectedList.GetHead()->ResumeFile(); 
                       //selectedList.GetHead()->SavePartFile();
						selectedList.RemoveHead();
d2001 2
a2002 1
					break; 
d2004 12
a2015 5
					while(!selectedList.IsEmpty())
					{ 
                        HideSources(selectedList.GetHead());
						selectedList.GetHead()->StopFile(); 
						selectedList.RemoveHead();
d2017 3
a2019 1
					break; 
d2021 1
d2023 1
d2033 1
a2034 1
					break;
d2036 1
d2039 1
a2039 1
						while(!selectedList.IsEmpty())
d2041 2
a2042 4
							str += selectedList.GetHead()->CreateED2kLink(); 
							selectedList.RemoveHead();
							if(!selectedList.IsEmpty())
								str += "\n";
d2046 3
a2048 1
					}
d2051 1
d2054 1
a2054 1
						while(!selectedList.IsEmpty())
d2056 2
a2057 4
							str += selectedList.GetHead()->CreateHTMLED2kLink(); 
							selectedList.RemoveHead();
							if(!selectedList.IsEmpty())
								str += "\n";
d2061 3
a2063 1
					}
d2066 13
a2078 6
					{
						if(selectedCount > 1) break;
						CString buffer;
						buffer.Format(_T("%s\\%s"),file->GetOutputDir(),file->GetFileName()); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
						ShellOpenFile(buffer);
						
d2080 1
d2082 9
a2090 3

				// START - enkeyDEV(Ottavio84) -ChangeDir-
				case MP_CHANGEDIR: {
d2095 4
a2098 2
						if(selectedCount > 1){
							while(!selectedList.IsEmpty()){
d2110 1
a2110 4
				// END - enkeyDEV(Ottavio84) -ChangeDir-

			    //SyruS: cleanup
			   	case MP_DOCLEANUP:
d2121 1
a2121 14

				case MP_PREVIEW:
					{
						if(selectedCount > 1) break;
						file->PreviewFile();
					}
					break;
				case MP_VIEWFILECOMMENTS:
					{
						CCommentDialogLst dialog(file); 
						dialog.DoModal(); 
					}
					break;
                case MP_ALL_A4AF_TO_HERE: // Tarod
a2214 1
				// END - enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d2216 4
a2219 2
		} else {
			CUpDownClient* client = content->GetSource();
a2224 3
				case MP_DOWNNOW: 
					client->SwapToAnotherFile(content->GetFile());	//eklmn: bugfix(08): A4AF switching
					break; 
d2235 1
d2243 7
d2267 2
a2268 2

	}catch(...){}
d2288 95
d2384 4
d2392 2
a2393 2
	CMuleCtrlItem* item1 = (CMuleCtrlItem*)lParam1;
	CMuleCtrlItem* item2 = (CMuleCtrlItem*)lParam2;
d2409 3
a2411 1
	if ((item1->IsFile() && !item2->IsFile())||(item2->IsFile() && !item1->IsFile())){ // files vs source?
d2413 1
a2413 1
	} else if (item1->IsFile()) { //both files? (!)
d2418 2
a2419 2
			CPartFile* file1 = item1->GetFile();
			CPartFile* file2 = item2->GetFile();
d2423 1
a2423 1
		comp = Compare(item1->GetFile(), item2->GetFile(),0);
d2426 1
a2426 1
		if ((item1->IsAskedForAnotherFile() || item2->IsAskedForAnotherFile()) && lParamSort!=0)
d2429 1
a2429 1
			if(item1->IsAskedForAnotherFile() && !item2->IsAskedForAnotherFile())
d2431 1
a2431 1
			if(item2->IsAskedForAnotherFile() && !item1->IsAskedForAnotherFile())
d2436 1
a2436 1
		comp = Compare(item1->GetSource(), item2->GetSource(), lParamSort, sortMod);
d2443 2
a2444 2

void CDownloadListCtrl::HideSources(CPartFile* partfile)
d2446 2
a2447 19
	EMULE_TRY

	if (!partfile->srcarevisible)
		return; 
	partfile->srcarevisible = false;
	SetRedraw(false); 
	for (int i = 0; i < GetItemCount(); )
	{ 
		CMuleCtrlItem* pItem = (CMuleCtrlItem*)GetItemData(i); 
		if(pItem->IsSource() && pItem->GetFile() == partfile)
		{
			pItem->m_dwUpdated = 0; 
			pItem->m_Status.DeleteObject(); 
			DeleteItem(i);
		}
		else
			i++;
	} 
	if (m_ShowSrc)			//Cax2 check if we don't show sources anymore...
d2449 8
a2456 6
		m_ShowSrc=false; 
		for(int i = 0; i < GetItemCount(); i++)
			if(((CMuleCtrlItem*)GetItemData(i))->IsSource()) 
			{
				m_ShowSrc=true;
				break;
a2457 5
		if (theApp.glob_prefs->DoUseSort() && !m_ShowSrc)	//Cax2 ...& restore the sort index that was there before expanding the files
		{
			m_lastSort=FilesSortIndex;	
			m_CurrentSortItem=(m_lastSort<100)?m_lastSort:m_lastSort-100;
			SetSortArrow(m_CurrentSortItem,(m_lastSort<100));
a2459 3
	SetRedraw(true);
	
	EMULE_CATCH
d2469 1
a2469 1
	for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); )
d2471 3
a2473 3
		CMuleCtrlItem* pItem = g->second;
		g++; // Already point to the next iterator
		if(pItem->IsFile())
d2475 1
a2475 1
			CPartFile* pFile = pItem->GetFile();
d2477 1
d2479 1
d2481 1
d2487 1
d2494 1
d2496 1
d2507 1
d2509 1
d2511 1
d2513 1
d2582 2
a2583 1
	if (file1==NULL||file2==NULL)
d2585 1
d2594 3
a2596 1
                    return 0;
d2598 3
a2600 1
			        return _tcsicmp(fname1,fname2);
d2613 1
a2613 1
				return (comp > 0)?1:((comp<0)?-1:0);
d2621 1
a2621 1
				int comp =  file1->getPartfileStatusRang()-file2->getPartfileStatusRang();
d2624 3
a2626 2
				if(comp == 0) {
					comp = _tcsicmp(file1->GetFileName(),file2->GetFileName());
d2641 2
a2642 1
				if (tmp1>0&&tmp2>0) 
d2644 3
a2646 1
				if (tmp1>0||tmp2>0)
d2648 1
d2653 1
d2655 1
d2657 1
d2659 1
d2661 1
d2663 1
d2667 3
a2669 1
			    return 1;
d2671 3
a2673 1
			    return -1;
d2675 20
a2694 1
			    return 0;
d2698 1
d2707 7
a2713 4
	if (client1==NULL||client2==NULL) return 0;
		switch(lParamSort)
		{
			case 0: //name asc
d2763 32
a2794 35
				if (client1->GetDownloadState()!=DS_ONQUEUE || client2->GetDownloadState()!=DS_ONQUEUE)	//Cax2 QR gaps bugfix
				{
					if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
								return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
					if (client1->GetDownloadState()==DS_DOWNLOADING || client2->GetDownloadState()==DS_DOWNLOADING)		//Cax2 QR gaps bugfix
						return (client1->GetDownloadState()==DS_DOWNLOADING)?((client2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2; //Cax2 QR gaps bugfix
					return (client1->GetDownloadState()!=DS_ONQUEUE)?((client2->GetDownloadState()!=DS_ONQUEUE)?0:sortMod):-1*sortMod;		//Cax2 now should show properly...
				}
				if (sortMod<0 || (client1->GetRemoteQueueRank()>0 && client2->GetRemoteQueueRank()>0))
					return client1->GetRemoteQueueRank() - client2->GetRemoteQueueRank();   
				if(client1->GetRemoteQueueRank()==0 && client2->GetRemoteQueueRank()==0)
					return (client1->IsEmuleClient())?((client2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
				return (client1->GetRemoteQueueRank()==0)?((client2->GetRemoteQueueRank()==0)?0:2):-1;  
			case 8: //Status column - Lord KiRon
				return client1->GetDownloadStateAsString().Compare(client2->GetDownloadStateAsString()); 
			//Cax2 - sort bugfix
			case 11: // UL/DL column - Maverick
			case 12: // Ratio column - Maverick
				{	//Cax2 - faster this way & less code to go wrong...
					if(client1->GetClientSoft() == SO_UNKNOWN || client2->GetClientSoft() == SO_UNKNOWN )		//Cax2 append all unknown ones at the end
								return (client1->GetClientSoft()-client2->GetClientSoft())*sortMod;							//Cax2 append all unknown ones at the end
					bool isValid1 = (client1->IsRemoteInfoAvaiable()|| client1->credits);
					bool isValid2 = (client2->IsRemoteInfoAvaiable()|| client2->credits);
					if ( lParamSort==10 && isValid1 && isValid2) //Cax2 - bugfix after reCDVst changes 
						return (client1->GetRemoteBaseModifier() <client2->GetRemoteBaseModifier())?-1:1;		//Cax2 - has to return an integer!
					if (isValid1 && isValid2)		//Cax2 - it's got to be lParamSort==11 after reCDVst changes 
						return client1->GetRemoteRatio() - client2->GetRemoteRatio();
					if (isValid1)				
						return 1;
					if (isValid2)				
						return -1;
					return 0;
				}
			default:
				return 0;
d2796 4
d2833 1
a2833 1
				CMuleCtrlItem *pListItem = (CMuleCtrlItem*)GetItemData(index);
d2836 1
a2836 1
				if(!pListItem->IsFile())			// if it isn't a file we're done
d2846 1
a2846 1
					OnLvnItemActivate(pNMHDR, pResult);
d2857 1
a2857 1
					CPartFile *pPartFile = pListItem->GetFile();
d2883 2
a2884 1
	if (GetSelectionMark() != (-1))
d2886 2
a2887 3
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());

		if (content->IsFile())		//Cax2: doubleclick opens completed files
d2889 1
a2889 2
			CPartFile* file = content->GetFile();
			if(file->GetStatus()==PS_COMPLETE)
d2891 9
a2899 4
				CString buffer;
				buffer.Format(_T("%s\\%s"),file->GetPath(),file->GetFileName());
				AddLogLine(false, _T("%s\\%s"),file->GetPath(),file->GetFileName());
				ShellOpenFile(buffer);
d2901 1
a2901 5
		}
		else	//client  options
		{
			CUpDownClient* client = content->GetSource();
			if (theApp.glob_prefs->GetDetailsOnClick())
d2903 14
a2916 10
			#if _USE_NEW_DETAILS_
				CClientDetails dialog("Client Details", client, this, 0);
			#else
				CClientDetailDialog dialog(client);
			#endif
				dialog.DoModal();
			} 
			else 
			{
				theApp.emuledlg->chatwnd.StartSession(client);
d2950 16
a2965 4
		if(((CMuleCtrlItem*)GetItemData(i))->IsFile() 
			&& ((CMuleCtrlItem*)GetItemData(i))->GetFile()->GetSourceCount() <= theApp.glob_prefs->GetMaxSourcePerFile()) 
			selectedList.AddTail(((CMuleCtrlItem*)GetItemData(i))->GetFile());
   	} 
d2996 1
a2996 1
		theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
d2998 5
a3002 3
	} else {
		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
		if(content->IsFile())
d3004 2
a3005 2
			const CPartFile* file = content->GetFile();
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile((CPartFile*)file);
d3007 5
a3011 3
		} else {
			const CUpDownClient* client = content->GetSource();
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToUser((CUpDownClient*)client);
d3019 24
d3050 22
a3071 11
	for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); g++)
	{
		CMuleCtrlItem* pItem = g->second;
		if(!pItem->IsFile())
			continue;
		CPartFile* file = pItem->GetFile();
		AddLogLine(false,file->GetFileName());
		temp2=file->GetFileName(); if (temp2.GetLength()>50) temp2=temp2.Mid(0,50);
		temp.Format(_T("\n%s\t [%.1f%%] %i/%i - %s"),
			temp2,file->GetPercentCompleted(),file->GetTransferingSrcCount(),file->GetSourceCount(), file->GetPartfileStatus());
		out=out+temp;
a3081 1
//SyruS show completed files (0.28b)
d3085 2
a3086 2
	list->RemoveAll();
	for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); g++)
d3088 47
a3134 5
		CMuleCtrlItem* pItem = g->second;
		if(!pItem->IsFile())
			continue;
		CPartFile* file = pItem->GetFile();
		list->Add(file);
d3136 11
a3146 3
	
	return true;
	
d3148 1
d3150 3
a3152 2
	return false;	//failsafe
}
a3153 4
#ifdef __USE_CATEGORIES__
void CDownloadListCtrl::ChangeCategory(int newsel){
#pragma message("code removed!")
/*
d3157 6
a3162 4
	for(ListItems::const_iterator it = m_ListItems.begin(); it != m_ListItems.end(); it++){
		const CtrlItem_Struct* cur_item = it->second;
		if (cur_item->type == FILE_TYPE){
			CPartFile* file = reinterpret_cast<CPartFile*>(cur_item->value);
d3164 8
a3171 3
			if ( !CheckShowItemInGivenCat(file,newsel)) HideFile(file);
				else ShowFile(file);

d3176 1
a3176 1
	curTab=newsel;
d3178 2
a3179 1
*/
d3181 94
a3274 1
#endif
@


1.195
log
@Fixed last changes.
@
text
@d1021 3
a1023 2
							if(bNeverAskedBefore)
							{
d1026 1
a1026 1
							} else {
d1029 1
a1029 1
							}
d2274 4
a2277 1
		        return CompareUnsigned(client1->GetTransferedDown(), client2->GetTransferedDown());
d2279 4
a2282 1
                return 0;
d2284 1
a2284 1
		return CompareUnsigned(client1->GetDownloadDatarate(), client2->GetDownloadDatarate());
@


1.194
log
@Updates/Fixes
@
text
@d620 5
a624 1
					if (theApp.glob_prefs->GetUseDwlPercentage()) {
a639 2
					dc->BitBlt(lpRect->left, lpRect->top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
					cdcStatus.SelectObject(hOldBitmap);
@


1.193
log
@Double click doesn't unpause files.
@
text
@d620 16
a902 30
				/*
                if(nClientSoft == SO_EDONKEYHYBRID) {
                    imagelist.Draw(dc, 3, point2, ILD_NORMAL);
                    if (bIsFriend)
                        imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                    else if (fRemoteBaseModifier >= 1.1)
                        imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
                }
		        else if (nClientSoft == SO_MLDONKEY) {
                    imagelist.Draw(dc, 2, point2, ILD_NORMAL);
                    if (bIsFriend)
                        imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                    else if (fRemoteBaseModifier >= 1.1)
                        imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
		        }
		        else if (nClientSoft==SO_EMULE || nClientSoft==SO_OLDEMULE) {
                    imagelist.Draw(dc, 1, point2, ILD_NORMAL);
                    if (bIsFriend)
                        imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                    else if (fRemoteBaseModifier >= 1.1)
                        imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
                }
				else {
                    imagelist.Draw(dc, 0, point2, ILD_NORMAL);
                    if (bIsFriend)
                        imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                    else if (fRemoteBaseModifier >= 1.1)
                        imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
				}*/

a903 4

                //if(lpUpDownClient->GetClientSoft()==SO_EMULE && lpUpDownClient->GetMuleVersion()==0x26) {
                //	imagelist.Draw(dc, 7, point2, ILD_TRANSPARENT);
                //}
@


1.192
log
@Fixes
@
text
@a2452 1
				m_dblclicked=true;
d2475 1
@


1.191
log
@Show transferred data on Complete column
@
text
@d947 1
a947 1
			if (!a4af && nTransferredDown) {
@


1.190
log
@Updates to QR code by cendre-eau and other changes.
@
text
@d953 5
a957 1
		case 3:// completed
@


1.189
log
@Minor update (QR not shown on A4AF).
@
text
@a1028 3
						//buffer.Format(_T("QR: %u"), nRemoteQueueRank);
						//dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);

d1031 1
a1031 2
						crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
						if ((nRemoteQueueRank-(65536-nDifference)==0))
a1033 2
								buffer.Format("QR: %u (%u)",nRemoteQueueRank,(0));
							else
d1035 3
d1039 1
a1039 1
								buffer.Format("QR: %u (%u)",nRemoteQueueRank,(0));
d1041 6
a1046 4
						}
						if ((nRemoteQueueRank-(65536-nDifference))>0)
						{
							if ((nRemoteQueueRank-(65536-nDifference))<25000)
d1048 2
a1049 2
								crOldTxtColor = dc->SetTextColor((COLORREF)RGB(190,60,60));
								buffer.Format("QR: %u (+%u)",nRemoteQueueRank,(65536-nDifference));
d1051 1
a1051 3
						}
						else if ((65536-nDifference)-(nRemoteQueueRank)>0)
						{
d1053 1
a1053 1
							buffer.Format("QR: %u (-%u)",nRemoteQueueRank,(nDifference));
@


1.188
log
@remote queue progress is now shown and color coded [cendre-eau]
now you can set multiple files to Drop supercompressed blocks
Some fixes to images and installer profile
@
text
@d791 1
a802 1
				bool a4af=lpCtrlItem->IsAskedForAnotherFile();
d947 1
a947 1
			if (!lpCtrlItem->IsAskedForAnotherFile() && nTransferredDown) {
d957 1
a957 1
			if (!lpCtrlItem->IsAskedForAnotherFile())
d994 1
a994 1
					lpClient->DrawStatusBar(&cdcStatus,  &rec_status,(lpCtrlItem->IsAskedForAnotherFile()), theApp.glob_prefs->UseFlatBar()); 
d1009 1
a1009 1
	case 6:		// sources
d1011 5
a1015 12
				// [Lord KiRon]
				// display client version
				//if (nClientSoft == SO_UNKNOWN)
				//	buffer.Format("???");
				//else
				//	buffer.Format("%s v%s",GetClientNameString(nClientSoft),GetClientVersionString(nClientSoft, nVersion));

            CString clientVerString = GetClientNameAndVersionString(lpClient);
			// [/Lord KiRon]
			dc->DrawText(clientVerString,clientVerString.GetLength(),lpRect, DLC_DT_TEXT);
			break;
		}
d1018 1
a1018 3
		if ((bIsEmuleClient || nRemoteQueueRank)&& nDownloadState==DS_ONQUEUE) //now emule v ? display the QR too!
		{
			if(bRemoteQueueFull)
d1020 6
a1025 6
				buffer=GetResString(IDS_QUEUEFULL);
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
			}
			else
			{
				if (nRemoteQueueRank)
d1027 4
a1030 2
					//buffer.Format(_T("QR: %u"), nRemoteQueueRank);
					//dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1032 14
a1045 8
					//cendre-eau
					COLORREF crOldTxtColor;
					crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
					if ((nRemoteQueueRank-(65536-nDifference)==0))
					{
						if(bNeverAskedBefore)
							buffer.Format("QR: %u (%u)",nRemoteQueueRank,(0));
						else
d1047 5
a1051 2
							crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,255));
							buffer.Format("QR: %u (%u)",nRemoteQueueRank,(0));
d1053 1
a1053 4
					}
					if ((nRemoteQueueRank-(65536-nDifference))>0)
					{
						if ((nRemoteQueueRank-(65536-nDifference))<25000)
d1055 2
a1056 2
							crOldTxtColor = dc->SetTextColor((COLORREF)RGB(190,60,60));
							buffer.Format("QR: %u (+%u)",nRemoteQueueRank,(65536-nDifference));
d1058 3
d1062 1
a1062 1
					else if ((65536-nDifference)-(nRemoteQueueRank)>0)
d1064 2
a1065 2
						crOldTxtColor = dc->SetTextColor((COLORREF)RGB(10,160,70));
						buffer.Format("QR: %u (-%u)",nRemoteQueueRank,(nDifference));
a1066 8
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
					crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,0,0));
					//cendre-eau
				}
				else
				{
					//buffer="";
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1068 3
d1072 1
a1072 5
		} else {
			//	buffer="";
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
		}
		break;
@


1.187
log
@*** empty log message ***
@
text
@d785 2
d1025 1
a1025 2
		if ((bIsEmuleClient || nRemoteQueueRank)&&		//now emule v ? display the QR too!
			nDownloadState==DS_ONQUEUE)
d1027 2
a1028 1
			if(bRemoteQueueFull){
d1032 40
a1071 7
			else{
				if (nRemoteQueueRank){
				buffer.Format(_T("QR: %u"), nRemoteQueueRank);
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
			}
				else{
				//	buffer="";
d1076 2
a1077 2
				//	buffer="";
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d1079 1
a1079 1
			break;
d1529 3
d1539 1
d1885 14
a1898 1
					if (!(file->GetStatus()==PS_COMPLETE) && !(file->GetStatus()==PS_COMPLETING)) {
d1903 1
@


1.186
log
@added past comments
@
text
@d27 4
d33 1
d117 4
d273 5
d1596 11
d1698 3
d1702 1
d1892 3
d1896 1
d2414 3
d2418 1
d2420 3
a2422 1
			} else {
d2557 25
@


1.185
log
@Added STOP visual notification.
@
text
@d1465 1
a1465 1
			m_FileMenu.EnableMenuItem(MP_VIEWFILECOMMENTS,(justOne && file->HasComment() || file->HasRating()) && !filedone ?MF_ENABLED:MF_GRAYED); // Cax2  //netwolf: no comments on complete files	// netwolf 06.05.03 only enabled if there is a comment/rating
@


1.184
log
@Moved a little to the left the filename column.
@
text
@d141 2
a142 1

d451 3
a453 1
					else if(lpPartFile->GetStatus()==PS_PAUSED || lpPartFile->GetStatus()==PS_STOPPED)
d1437 1
a1437 1
			m_FileMenu.EnableMenuItem(MP_STOP,((file->GetStatus() != PS_ERROR && !filedone ) ? MF_ENABLED:MF_GRAYED));
d1443 1
a1443 1
			m_FileMenu.EnableMenuItem(MP_RESUME,((file->GetStatus() == PS_PAUSED) ? MF_ENABLED:MF_GRAYED));
@


1.183
log
@Fix for a bug introduced by me (double-clicking with the new actions triggered the clear or unpause action for the selected file).
@
text
@d1108 1
a1108 1
	cur_rec.left += iOffset;
@


1.182
log
@Bugfix for #225 - You cannot specify the root dir of any drive when using "Change destination directory"
@
text
@d65 1
d448 1
a448 1
					if(lpPartFile->GetStatus()==PS_COMPLETE || lpPartFile->GetStatus()==PS_COMPLETING)
d1326 1
a1326 1
		if(partfile->GetStatus()==PS_PAUSED || partfile->GetStatus()==PS_STOPPED)
d1328 1
a1328 1
		else if(partfile->GetStatus()==PS_COMPLETE)
d1330 1
a1330 1
		else if ( (!partfile->srcarevisible) && partfile->GetSourceCount()>0 && partfile->GetStatus()!=PS_COMPLETING)	//Cax2: when (slow) completing, the files stay shut
d1367 1
d1889 1
d1896 1
d1898 1
d2368 3
a2370 2
				AddLogLine( false, _T("%s\\%s"),file->GetPath(),file->GetFileName());
				ShellOpenFile(buffer);				
@


1.181
log
@previous bugfix takins into consideration ShowFileTypeIcon state
@
text
@d1712 2
a1713 1
					CString newpath = BrowseFolder(theApp.emuledlg->m_hWnd,GetResString(IDS_SELECTOUTPUTDIR),file->GetOutputDir());
@


1.180
log
@BUGFIX: comments where displayed when clicking on filetype icon instead of rating icon
@
text
@d2317 3
a2319 1
				rRating.left = rPlusMinus.right+2+16+2; //EC 30.07.03 +2 for filetype icon gap +16 for size
@


1.179
log
@Tweaked icons, no gap when comment/filetype icons are disabled, text now fixed on download list
@
text
@d2317 1
a2317 1
				rRating.left = rPlusMinus.right+2;
@


1.178
log
@Option to disable filetype icons.
@
text
@d462 1
a462 1
						lpRect->left += 16 + 3;
d466 29
a494 27
			        if ( !theApp.glob_prefs->GetDisableRatingIcons() && ( lpPartFile->HasComment() || lpPartFile->HasRating() ))
			        {
				        int image=16;
				        if (lpPartFile->HasRating())
				        {
				        	switch(lpPartFile->GetRating())
				        	{
								case 0: 
									image=16; 
									break; 
								case 1: 
									image=21;
									break; 
								case 2: 
									image=20; 
									break; 
								case 3: 
									image=18; 
									break; 
								case 4: 
									image=19; 
									break; 
								case 5: 
									image=17; 
									break;
								default:
									image=16;
d496 3
d500 2
a501 4
				        POINT point= {lpRect->left-4,lpRect->top+3};
				        imagelist.Draw(dc, image, point, ILD_NORMAL);
			        }
				    lpRect->left+=10;
a519 1
					
d522 5
a526 2
					
				    lpRect->left-=9;
d528 1
@


1.177
log
@FileType Icons in shared and downloading files
@
text
@d457 7
a463 4
					int iImage = theApp.GetFileTypeSystemImageIdx(lpPartFile->GetFileName());
					if (theApp.GetSystemImageList() != NULL)
						::ImageList_Draw(theApp.GetSystemImageList(), iImage, dc->GetSafeHdc(), lpRect->left, lpRect->top, ILD_NORMAL);
					lpRect->left += 16 + 3;
@


1.176
log
@Corrections to last code.
@
text
@d455 7
d510 6
a515 2
				    dc->DrawText(lpPartFile->GetFileName(), (int)_tcslen(lpPartFile->GetFileName()),lpRect, DLC_DT_TEXT);
                    if(warn)
@


1.175
log
@updated GUI graphic information about file status [psy]
@
text
@d1305 5
a1309 1
		if ( (!partfile->srcarevisible) && partfile->GetSourceCount()>0 && partfile->GetStatus()!=PS_COMPLETING)	//Cax2: when (slow) completing, the files stay shut
d1337 1
a1337 1
		} 
d1629 1
a1629 1
					{ 
@


1.174
log
@SingleLock object was removed
@
text
@d120 1
a120 1
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         		// 7
d139 1
a139 1

d446 7
a452 1
					int iIcon = lpPartFile->GetSourceCount() > 0 ? (lpPartFile->srcarevisible ? 13 : 15) : 14;
d501 1
a501 1
					else if(lpPartFile->GetStatus()==PS_PAUSED)
@


1.173
log
@added a Unlock() fro each CSingleLock
@
text
@a70 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

a75 3

	AccessLock.Unlock();

a252 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

a261 2
	AccessLock.Unlock();

a271 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

a291 2
		{
			AccessLock.Unlock();
a292 1
		}
a297 2
	{
		AccessLock.Unlock();
a298 1
	}
a300 2
	{
		AccessLock.Unlock();
a301 1
	}
a312 2
	AccessLock.Unlock();

a326 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

a356 1
	AccessLock.Unlock();
a367 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

a393 2
	AccessLock.Unlock();

a404 2

	CSingleLock AccessLock(&m_MutexAccess, TRUE);
a422 1
	AccessLock.Unlock();
a1300 2
			CSingleLock AccessLock(&m_MutexAccess, TRUE);

a1323 2
			AccessLock.Unlock();
			
d1923 1
d1957 1
a2434 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

a2446 2
	AccessLock.Unlock();
	
a2459 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);
	
a2468 1
	AccessLock.Unlock();
@


1.172
log
@CHANGE: now showing "never" instead of "unknown" in Last Seen Complete column [Andrerib]
@
text
@d79 2
a254 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

d258 2
d267 3
a269 1
    InsertItem(LVIF_PARAM,itemnr,0,0,0,0,(LPARAM)pItem);
d303 2
d306 1
d312 2
d315 1
d317 5
a321 2
    if (!owner->srcarevisible)
            return;
d323 2
a324 2
    LVFINDINFO find;
    find.flags = LVFI_PARAM;
d326 1
a326 1
    int nItem = FindItem(&find);
d330 4
a333 1
    InsertItem(LVIF_PARAM,nItem+1,0,0,0,0,(LPARAM)pItem);
d1358 2
d2482 3
a2484 1
    }
d2498 2
a2499 1
	//yes or no? CSingleLock AccessLock(&m_MutexAccess, TRUE);
d2508 3
a2510 1
    }
d2512 1
@


1.171
log
@1) don't update item twice
2) refresh a list if file was removed
@
text
@d704 1
a704 1
				    buffer=GetResString(IDS_UNKNOWN);
@


1.170
log
@added Lock-Unlock in UpdateItems(), RemoveSource(), RemoveFile()
@
text
@d406 3
d433 3
a435 3
			RedrawItems(result,result);
			if(pItem->IsFile())
				theApp.sharedfiles->UpdateItem(((CKnownFile*)toupdate),false);
@


1.169
log
@using const uchar* for parameter to ClearCompleted
@
text
@d328 7
a343 2
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

d351 2
a352 2
//Don't refresh during app shutdown [TwoBottle Mod]
			if (::IsWindow(m_hWnd)) {
d359 1
a359 1
			}
d365 1
a365 1
	//RefreshInfo();	// eklmn: bugfix(12): refresh whole list
d374 2
a375 2
	if(!toremove)
		return;
d405 2
d415 3
d435 2
@


1.168
log
@Removed old Stored Sources from all code.
@
text
@d1963 1
a1963 1
void CDownloadListCtrl::ClearCompleted(uchar FileHash[16])
@


1.167
log
@not all completed files were cleared in "ClearAll" case
@
text
@a1443 11
/*			m_FileMenu.AppendMenu(MF_STRING,MP_LOADSOURCES, GetResString(IDS_DL_LOADSOURCES)); // Mr.Fry
			m_FileMenu.AppendMenu(MF_STRING,MP_SAVESOURCES, GetResString(IDS_DL_SAVESOURCES)); // Mr.Fry
			if(theApp.glob_prefs->SLSEnable())
			{
				m_FileMenu.EnableMenuItem(MP_LOADSOURCES,((file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));
				m_FileMenu.EnableMenuItem(MP_SAVESOURCES,((file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING)?MF_ENABLED:MF_GRAYED));	// netwolf 07.05.03
			} else {
				m_FileMenu.EnableMenuItem(MP_LOADSOURCES,MF_GRAYED);
				m_FileMenu.EnableMenuItem(MP_SAVESOURCES,MF_GRAYED);
			}
*/
a1727 27
#ifdef OLD_SLS_ENABLED
				case MP_LOADSOURCES:	// Mr.Fry
					while(!selectedList.IsEmpty())
					{
						if (theApp.glob_prefs->IsRemoveNNSEnabled()) // Vorlost added prefs question
							selectedList.GetHead()->RemoveNoNeededSources(); // Tarod - clean no needed sources
						//Vorlost (Patch by Mr.Fry)
						if(theApp.downloadqueue->KeepStoredSourcesOpen())
							selectedList.GetHead()->AddFromStoredSources(selectedList.GetHead()->GetStoredSources()
												     ,true
												     ,selectedList.GetHead()->GetLoadSourcesAtOnceLimit()
												     ,true);
						else
							selectedList.GetHead()->LoadAndAddSources(false
												  ,true
												  ,file->GetLoadSourcesAtOnceLimit()
												  ,true);
						selectedList.RemoveHead();
					}
				case MP_SAVESOURCES:	// Mr.Fry
					while(!selectedList.IsEmpty())
					{
						selectedList.GetHead()->SaveSources();
						selectedList.RemoveHead();
					}
					break;
#endif //OLD_SLS_ENABLED
@


1.166
log
@katsyonak show banned client in downloadlist
@
text
@d2001 1
a2001 1
void CDownloadListCtrl::ClearCompleted(uchar FileHash[16] /*=NULL*/)
d2004 3
d2016 3
a2018 2
					RemoveFile(pFile);	//continue clearing all
				else if (md4cmp(FileHash, pFile->GetFileHash()) == 0) {
d2024 8
@


1.165
log
@now using Ottavios SLS system [netwolf]
@
text
@d732 1
d835 3
a837 1
				if (bIsFriend)
@


1.164
log
@added sessiontransfres in front of sessiontime on completed files
@
text
@d1441 1
a1441 1
			m_FileMenu.AppendMenu(MF_STRING,MP_LOADSOURCES, GetResString(IDS_DL_LOADSOURCES)); // Mr.Fry
d1451 1
a1451 1

@


1.163
log
@fix "refresh whole downloadlist after source update" reverted
@
text
@d678 1
a678 1
					{	//SyruS show total sessiontime
d680 1
a680 1
						buffer.AppendFormat(_T("[%s]"), CastSecondsToHM(restTime));
@


1.162
log
@FEATURE: show average sessionspeed and total sessiontime for completed files [SyruS]
final smoothed remaining time
@
text
@d319 1
a319 1
	RefreshInfo();	// eklmn: bugfix(12): refresh whole list
d360 1
a360 1
	RefreshInfo();	// eklmn: bugfix(12): refresh whole list
@


1.161
log
@Simplified AvgDataRate/RemainingTime code
@
text
@d525 12
a536 9
					uint32 dRate = lpPartFile->GetDatarate();
			       	if (dRate > 10)
						buffer.AppendFormat(_T("%.1f "), dRate/1024.0f);
					//bond006 (smoothed "remaining time" calculation) //SyruS
			       	if(theApp.glob_prefs->GetShowAverageDatarate())
			       	{
						dRate = lpPartFile->GetAvgDatarate();
						if (dRate > 100)
							buffer.AppendFormat(_T("(%.1f) "), dRate/1024.0f);
d538 2
d664 1
d668 1
a668 1
						sint32 restTime = lpPartFile->GetTimeRemaining();
d673 1
a673 1
							restTime = lpPartFile->GetTimeRemaining(false);
d676 5
@


1.160
log
@New A4AF mangement
@
text
@a522 1
		       	if(theApp.glob_prefs->GetShowAverageDatarate())
d529 6
a534 3
					dRate = lpPartFile->GetAvgDatarate();
					if (dRate > 100)	//&& option
						buffer.AppendFormat(_T("(%.1f) "), dRate/1024.0f);
a538 9
				else
				{
	             	//Cax2: faster if: this still shows 0.0 for all datarates between 0.01 and 0.05, nothing if lower...
					if(lpPartFile->GetDatarate()<11)
						buffer = "";
					else
						buffer.Format(_T("%.1f %s"), lpPartFile->GetDatarate() / 1024.0f,GetResString(IDS_KBYTESEC));
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
				}
d578 1
d656 1
a657 1
				if(theApp.glob_prefs->GetShowAverageDatarate())
d665 1
a665 1
						//if (option) 
d667 2
a668 2
						restTime = lpPartFile->GetTimeRemaining(false);
						buffer.AppendFormat(_T(" (%s)"), CastSecondsToHM(restTime));
a672 10
				else
				{
					sint32 restTime=lpPartFile->GetTimeRemaining();
					buffer = CastSecondsToHM(restTime);
					if (lpPartFile->GetStatus()==PS_COMPLETING || lpPartFile->GetStatus()==PS_COMPLETE)
						buffer="";
					CString str1 = buffer;
					buffer.Format( _T("%s"), str1);
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
				}
d674 1
@


1.159
log
@Updated Show Average Datarate option/Smoothed remaining time
@
text
@d1476 1
a1476 1
				m_FileMenu.CheckMenuItem(MP_ALL_A4AF_AUTO, file->IsA4AFAuto() ? MF_CHECKED:MF_UNCHECKED); // Tarod
d1769 1
a1769 1
						DownloadAllA4AF(file);
d1774 7
a1780 7
						if (file->IsA4AFAuto())
						{
							file->SetA4AFAuto(false);
						} else {
							theApp.downloadqueue->DisableAllA4AFAuto();
							file->SetA4AFAuto(true);
						}
a2415 23

	EMULE_CATCH
}

void CDownloadListCtrl::DownloadAllA4AF(CPartFile* file)
{
	EMULE_TRY

	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	// Make a list of sources
	CArray<CUpDownClient*, CUpDownClient*> SourcesList;
	for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); g++)
	{
		CMuleCtrlItem* pItem = g->second;
		if(pItem->IsSource() && pItem->GetFile() == file && pItem->IsAskedForAnotherFile())
			SourcesList.Add(pItem->GetSource());
	}
	AccessLock.Unlock();

	// Actually handover
	for(int i = 0; i < SourcesList.GetCount(); i++)
		SourcesList[i]->SwapToAnotherFile(file);	//eklmn: bugfix(08): A4AF switching
@


1.158
log
@Added Show Average Datarate option.
@
text
@a535 1
					break;
a544 1
					break;
d546 1
d663 1
d666 1
a666 1
					if (lpPartFile->GetStatus()!=PS_COMPLETING && lpPartFile->GetStatus()!=PS_COMPLETE )
a677 1
					break;
d679 11
a689 1

@


1.157
log
@updated: smoothing time remaining & average downloadrate
@
text
@d523 16
d540 7
a546 13
				buffer.Empty();
				uint32 dRate = lpPartFile->GetDatarate();
             	//Cax2: faster if: this still shows 0.0 for all datarates between 0.01 and 0.05, nothing if lower...
		       	if (dRate > 10)
					buffer.AppendFormat(_T("%.1f "), dRate/1024.0f);
				//bond006 (smoothed "remaining time" calculation) //SyruS
				dRate = lpPartFile->GetAvgDatarate();
				if (dRate > 100)	//&& option
					buffer.AppendFormat(_T("(%.1f) "), dRate/1024.0f);
				if (!buffer.IsEmpty())
					buffer.Append(GetResString(IDS_KBYTESEC));
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
				break;
@


1.156
log
@CHANGE: added average downloadrate within brackets to speedcolumn [SyruS]
CHANGE: smoothed "remaining time" calculation by bond006 [SyruS]
@
text
@d531 1
a531 1
				if (dRate > 100)
d652 1
a652 1
			    	break;
d655 12
a666 6
				sint32 restTime=lpPartFile->GetTimeRemaining();
				buffer = CastSecondsToHM(restTime);
				if (lpPartFile->GetStatus()==PS_COMPLETING || lpPartFile->GetStatus()==PS_COMPLETE )
					buffer="";
					CString str1 = buffer;
					buffer.Format( _T("%s"), str1);
d668 1
d670 1
a670 1
				break;
@


1.155
log
@CHANGE: WebServer: show filename in cancel-confirmation
CHANGE: WebServer: download a4af only possible on non-paused files with sources
BUGFIX: WebServer: code optimization and stabilisation of transferlist
@
text
@d523 12
a534 6
            	//Cax2: faster if: this still shows 0.0 for all datarates between 0.01 and 0.05, nothing if lower...
            	if(lpPartFile->GetDatarate()<11)
					buffer = "";
				else
					buffer.Format(_T("%.1f %s"), lpPartFile->GetDatarate() / 1024.0f,GetResString(IDS_KBYTESEC));
	
d537 1
@


1.154
log
@unicode cleanup
@
text
@d2477 1
a2477 1
void CDownloadListCtrl::GetDisplayedFiles(CArray<CPartFile*,CPartFile*> *list)
d2480 2
a2481 2

	//? CSingleLock AccessLock(&m_MutexAccess, TRUE);
d2490 2
d2493 1
a2493 1
	EMULE_CATCH
@


1.153
log
@FEATURE: disable rating icons
@
text
@d498 1
a498 1
				    dc->DrawText(lpPartFile->GetFileName(), (int)strlen(lpPartFile->GetFileName()),lpRect, DLC_DT_TEXT);
d527 1
a527 1
					buffer.Format("%.1f %s", lpPartFile->GetDatarate() / 1024.0f,GetResString(IDS_KBYTESEC));
d574 1
a574 1
						buffer2.Format("%i/",lpPartFile->GetSourceCount() -ncsc);
d577 1
a577 1
					buffer.Format("%s%i (%i)",buffer2, lpPartFile->GetSourceCount(), lpPartFile->GetTransferingSrcCount());
d581 1
a581 1
					dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);
d641 1
a641 1
						buffer.Format( "%s [%.1f%%]", str1, saved);
d653 1
a653 1
					buffer.Format( "%s", str1);
d665 1
a665 1
			    dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d766 1
a766 1
						try{ status.Format("(%s)",lpClient->reqfile->GetFileName()); }catch(...){}
d850 1
a850 1
					buffer1.Format("?  (%s)",GetResString(IDS_UNKNOWN));
d852 1
a852 1
					buffer1.Format("%s %s", sClientName.GetBuffer(0), status.GetBuffer(0));
d885 1
a885 1
					buffer.Format("%.1f %s", nDownloadDataRate/1024.0f,GetResString(IDS_KBYTESEC));
d957 1
a957 1
				buffer.Format("QR: %u", nRemoteQueueRank);
d992 1
a992 1
				buffer.Format("%0.1f", fRemoteBaseModifier);
d998 1
a998 1
				buffer.Format("%ld", nRemoteRatio);
d1439 1
a1439 1
			buffer.Format("%s (%s)", GetResString(IDS_ALL_A4AF_TO_HERE), GetResString(IDS_PRIOAUTO));
d1656 1
a1656 1
						buffer.Format("%s\\%s",file->GetOutputDir(),file->GetFileName()); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
d2078 1
a2078 1
			        return strcmpi(fname1,fname2);
d2103 1
a2103 1
					comp = strcmpi(file1->GetFileName(),file2->GetFileName());
d2162 1
a2162 1
				return strcmpi(sName1, sName2);
d2187 1
a2187 1
								return strcmpi(client1->GetModVersion(), client2->GetModVersion());
d2324 2
a2325 2
				buffer.Format("%s\\%s",file->GetPath(),file->GetFileName());
				AddLogLine( false, "%s\\%s",file->GetPath(),file->GetFileName());
d2450 1
a2450 1
	CString out="";
d2463 1
a2463 1
		temp.Format("\n%s\t [%.1f%%] %i/%i - %s",
@


1.152
log
@refresh whole downloadlist after souce update
A4AF switching
@
text
@d451 1
a451 1
			        if (lpPartFile->HasComment() || lpPartFile->HasRating())
@


1.151
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d319 2
d360 2
d1824 1
a1824 1
					client->HandoverToAnotherFile(content->GetFile()); 
d2405 1
a2405 1
		SourcesList[i]->HandoverToAnotherFile(file);
@


1.150
log
@CHANGE: code cleanup (m_modVerString & m_modExtendedString coverting to CString) [DoubleT]
@
text
@d30 1
d725 1
d727 3
d970 1
d972 3
d1034 1
d1036 3
d1108 1
d1110 3
@


1.149
log
@converted to new logger methods
@
text
@d2165 1
a2165 1
							if (client1->GetModVersion() && client2->GetModVersion())
d2167 2
a2168 2
							if (client1->GetModVersion() || client2->GetModVersion())
								return (client1->GetModVersion())? -1:1;
@


1.148
log
@WebServer: clear all or single completed files [SyruS]
@
text
@d2359 1
a2359 1
	AddLogLine(true,GetResString(IDS_NEWSERVERCONNECT),theApp.glob_prefs->GetMaxSourcePerFile()); 
@


1.147
log
@WebServer: show completed files (0.28b) [SuruS]
@
text
@d1947 2
a1948 1
void CDownloadListCtrl::ClearCompleted()
d1959 6
a1964 1
				RemoveFile(pFile);
d2455 1
a2455 1
//SuruS show completed files (0.28b)
@


1.146
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d2447 19
a2465 1
}@


1.145
log
@code cleanup
@
text
@d78 2
@


1.144
log
@code cleanup
@
text
@d564 1
a564 1
					char buffer2[64];
d567 1
a567 1
						sprintf(buffer2,"%i/",lpPartFile->GetSourceCount() -ncsc);
d569 1
a569 1
						sprintf(buffer2,"");
d836 1
a836 1
				char* buffer1;
d838 4
a841 6
				{
					buffer1 = new char[50];
					sprintf(buffer1,"?  (%s)",GetResString(IDS_UNKNOWN));
				} else {
					buffer1 = new char[sClientName.GetLength() + 50 + status.GetLength()];
					sprintf(buffer1,"%s %s", sClientName.GetBuffer(0), status.GetBuffer(0));
d849 1
a849 1
				dc->DrawText(buffer1,(int)strlen(buffer1),&cur_rec, DLC_DT_TEXT);
d851 1
a851 2
                	dc->SetTextColor(crOldTxtColor);
				delete[] buffer1;
a1306 1
			char buffer[100];
d1415 2
a1416 1
			sprintf(buffer,"%s (%s)", GetResString(IDS_ALL_A4AF_TO_HERE), GetResString(IDS_PRIOAUTO));
d1632 2
a1633 2
						char* buffer = new char[250];
						sprintf(buffer,"%s\\%s",file->GetOutputDir(),file->GetFileName()); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
d1635 1
a1635 1
						delete buffer;
d2294 2
a2295 2
				char* buffer = new char[MAX_PATH];
				sprintf(buffer,"%s\\%s",file->GetPath(),file->GetFileName());
d2297 1
a2297 2
				ShellOpenFile(buffer);
				delete buffer;
@


1.143
log
@coverted code from char * to CString
@
text
@d1609 1
a1609 1
							str += theApp.CreateED2kLink(selectedList.GetHead()); 
d1623 1
a1623 1
							str += theApp.CreateHTMLED2kLink(selectedList.GetHead()); 
@


1.142
log
@SyruS: better way of refreshing after cleanup
@
text
@d2047 3
a2049 3
                char *fname1=file1->GetFileName();
                char *fname2=file2->GetFileName();
                if  (!fname1||!fname2)
@


1.141
log
@BUGFIX: display of file updated directly after cleanup [SyruS]
@
text
@d1666 5
a1670 3
						selectedList.GetHead()->SetFileName(CleanupFilename(selectedList.GetHead()->GetFileName()).GetBuffer());
						selectedList.GetHead()->SavePartFile();
						UpdateItem(selectedList.GetHead());	//update display at once, not in 1 sec
@


1.140
log
@reverted change (SCB setting allowed on only one file again)
@
text
@d1668 1
@


1.139
log
@minor fixes and improvements
@
text
@d1408 1
a1408 1
			if (file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING) {
@


1.138
log
@drop SCB setting change allowed on multiple files
@
text
@d361 1
d613 1
a613 1
				buffer.Format("%s", lpPartFile->GetPartfileStatus());
d953 1
a953 1
					buffer="";
d958 1
a958 1
					buffer="";
d1022 2
a1023 2
	int tree_start;
	int tree_end;
d1583 1
a1583 1
                        selectedList.GetHead()->SavePartFile();
d2054 1
a2054 1
			return file1->GetTransfered() - file2->GetTransfered();
d2056 1
a2056 1
		    return file1->GetCompletedSize() - file2->GetCompletedSize();
d2058 1
a2058 1
			return file1->GetDatarate() - file2->GetDatarate();
d2136 1
a2136 1
		        return client1->GetTransferedDown() - client2->GetTransferedDown();
d2140 1
a2140 1
				return client1->GetDownloadDatarate() - client2->GetDownloadDatarate();
@


1.137
log
@Changed order on menu.
@
text
@d1407 1
a1407 1
			if (justOne && file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING) {
@


1.136
log
@Small fixes
@
text
@d1406 9
a1426 10
			}


            m_FileMenu.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED, GetResString(IDS_DROPSUPERCOMPRESSED));
			if (justOne && file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING) {
				m_FileMenu.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, file->GetDiscardSuperCompressed() ? MF_CHECKED:MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, MF_ENABLED);
			} else {
				m_FileMenu.CheckMenuItem(MP_DROP_SUPERCOMPRESSED, MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_DROP_SUPERCOMPRESSED, MF_GRAYED);
@


1.135
log
@make "drop supercompressed blocks" a per-file setting
@
text
@d1421 1
a1421 1
            m_FileMenu.AppendMenu(MF_STRING,MP_DROP_SUPERCOMPRESSED,"Drop supercompressed");
d1437 1
a1437 1
			m_FileMenu.RemoveMenu(28,MF_BYPOSITION);
d1441 1
@


1.134
log
@SyruS: added SavePartFile() after cleanup command
@
text
@d1420 10
d1763 8
@


1.133
log
@SyruS: moved cleanup-visuals to advanced tab
@
text
@d1656 1
@


1.132
log
@SyruS: customizable cleanup of filenames
@
text
@a1655 1
						//maybe a refresh would be appreciated
@


1.131
log
@added missing 'localize when language changed'
@
text
@d1386 4
d1650 10
@


1.130
log
@New icons for unknown, lmule cdonkey and shareaza clients
@
text
@d215 5
@


1.129
log
@Added lmule detection, better mldonkey detection and fixed bug 208
@
text
@d135 5
d758 36
d821 2
a822 1
				}
@


1.128
log
@*** empty log message ***
@
text
@d676 1
@


1.127
log
@shareaza identification.
@
text
@d105 2
a106 2
	InsertColumn(11,GetResString(IDS_DL_ULDL),LVCFMT_LEFT,60);
	InsertColumn(12,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60);
d1333 1
a1333 1
			m_FileMenu.EnableMenuItem(MP_VIEWFILECOMMENTS,(justOne) && !filedone ?MF_ENABLED:MF_GRAYED); // Cax2  //netwolf: no comments on complete files
d1345 1
a1345 1
				m_FileMenu.EnableMenuItem(MP_SAVESOURCES,MF_ENABLED);
d1352 1
a1352 1
			m_FileMenu.EnableMenuItem(MP_DROPNONEEDEDSRCS,MF_ENABLED); // Added by Tarod
d1355 1
a1355 1
			m_FileMenu.EnableMenuItem(MP_ALL_A4AF_TO_HERE,(justOne)?MF_ENABLED:MF_GRAYED); // Tarod(+Cax2 Patch 21/12/02)
d1359 1
a1359 1
			if (justOne) // Cax2
@


1.126
log
@katsyonak's fix
@
text
@d678 1
@


1.125
log
@Fixed new column in DownloadList. Queue Min Size changed in languages and some minor web template fixes.
@
text
@d616 1
d618 7
a624 10
					buffer="";

					// jicxicmic
					float saved = 100.0f - lpPartFile->GetPercentCompleted(); 
					// [Lord KiRon] this is completely WRONG read the MSDN on format :)
					CString str1	=	buffer;
					//buffer.Format( "%s [%.1f%%]", buffer, saved);
					buffer.Format( "%s [%.1f%%]", str1, saved);
					// [//Lord KiRon]
					// jicxicmic - end
@


1.124
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d99 1
a99 1
	InsertColumn(6,GetResString(IDS_DL_SOURCES),LVCFMT_CENTER, 50);
@


1.123
log
@Reversed problematic changes until fixed properly.
@
text
@d103 1
d105 2
a106 2
	InsertColumn(10,GetResString(IDS_DL_ULDL),LVCFMT_LEFT,60);
	InsertColumn(11,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60);
d109 1
a109 1
	InsertColumn(12, lsctitle,LVCFMT_LEFT, 110);
d210 1
a210 1
	  strRes = GetResString(IDS_DL_REMAINS);
d212 1
a212 1
	  pHeaderCtrl->SetItem(9, &hdi);
d218 1
a218 1
	  pHeaderCtrl->SetItem(10, &hdi);
d223 1
a223 1
	  pHeaderCtrl->SetItem(11, &hdi);
d229 1
a229 1
	  pHeaderCtrl->SetItem(12, &hdi);
d606 1
a606 1
			case 9:		// remaining time & size
d615 1
a615 4

					// time 
					sint32 restTime=lpPartFile->GetTimeRemaining();
					buffer = CastSecondsToHM(restTime) + " (" + CastItoXBytes(remains) + ")";
d630 12
a641 1
		    case 12: // last seen complete
d926 3
a928 1
		case 9:		// remaining time & size
d930 1
a930 1
		case 10: // UL/DL Ratio Maverick
d936 1
a936 1
		case 11: // Ratio total Maverick
d1334 1
a1334 1
			m_FileMenu.EnableMenuItem(MP_VIEWFILECOMMENTS,(justOne)?MF_ENABLED:MF_GRAYED); // Cax2
d1999 7
a2005 1
		case 9: //Remaining Time asc
a2021 3
				tmp1=file1->GetFileSize()-file1->GetCompletedSize();
				tmp2=file2->GetFileSize()-file2->GetCompletedSize();
				return (tmp1==tmp2)?0:((tmp1<tmp2)?-1:1); 
d2023 1
a2023 1
	    case 12: //Remaining Time asc 
d2104 2
a2105 2
			case 10: // UL/DL column - Maverick
			case 11: // Ratio column - Maverick
@


1.122
log
@Fixed a bug with not being able to set some folders as output folder (0000225)   (it was not only drives root but some "special" folders too). .
also fixed few COM/Shell related memory leaks.
@
text
@d617 1
a617 10
					// if remaining time is valid
					if ( restTime > 0 )
					{
						buffer = CastSecondsToHM(restTime) + _T(" (") + CastItoXBytes(remains) + _T(")");
					}
					else
					{
						// if not valid then we do not know :)
						buffer	=	_T("?");
					}
d621 2
a622 13

					// we need just to optimize the calls (speed)
					float saved	=	lpPartFile->GetPercentCompleted();
					// if lpPartFile->GetPercentCompleted() is valid 
					if ( saved > 0.f )
					{
						saved = 100.0f - saved; 
					}
					else
					{
						// if not valid , just set to 0
						saved = 0.f;
					}
@


1.121
log
@Corrective solution for 0 size file proble in addition ti Ultra's "Preventive solution"
@
text
@d1592 1
a1592 1
					if(newpath!=file->GetOutputDir())
@


1.120
log
@Changing prioraty for complited files is no longer available (part of the bug         0000227)
@
text
@d617 10
a626 1
					buffer = CastSecondsToHM(restTime) + " (" + CastItoXBytes(remains) + ")";
d630 13
a642 2
					// jicxicmic
					float saved = 100.0f - lpPartFile->GetPercentCompleted(); 
@


1.119
log
@last seen complete and last downloaded are displayed under locale settings
@
text
@d1256 1
d1262 1
d1264 1
d1266 1
d1268 1
@


1.118
log
@Minor changes
@
text
@d637 3
a639 1
				    buffer=lpPartFile->lastseencomplete.Format( "%A, %x, %X");
@


1.117
log
@Sorting fix by Cax2 (Bug #163)
@
text
@d112 22
a133 22
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));			// 0
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));			// 1
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));			// 2
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  	// 3
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_DOWNESTIMATED),16,16));      // 4
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      // 5
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      // 6
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         	// 7
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));         	// 8
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));         	// 9
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));         	// 10
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));         	// 11
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));         	// 12
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  	// 13 15
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  		// 14 16
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  		// 15 17
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));		// 16 18
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));	// 17 19
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));		// 18 20
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));	  	// 19 21
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));		// 20 22
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));	  	// 21 23
@


1.116
log
@Fixes to "destination directory"
@
text
@d1827 1
a1827 1
	if (theApp.glob_prefs->DoUseSort() && m_ShowSrc)			//Cax2 check if we don't show sources anymore...
d1836 1
a1836 1
		if (!m_ShowSrc)	//Cax2 ...& restore the sort index that was there before expanding the files
@


1.115
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d1564 13
a1576 8
					CString newpath;
					newpath = BrowseFolder(theApp.emuledlg->m_hWnd,GetResString(IDS_SELECTOUTPUTDIR),file->GetOutputDir());
					if(selectedCount > 1){
						while(!selectedList.IsEmpty()){
							selectedList.GetHead()->SetAlternativeOutputDir(&newpath);
							selectedList.GetHead()->SavePartFile();
							selectedList.RemoveHead();
						}			
a1577 3
					file->SetAlternativeOutputDir(&newpath);
					file->SavePartFile();
					file->GetOutputDir(); //<<-- to add new path to shared list
@


1.114
log
@last bugfixes!
@
text
@d1182 1
a1182 1
		if(!m_ShowSrc)		//Cax2 always restore the sort index that was there before opening the files...
d1825 1
a1825 1
	if (m_ShowSrc)			//Cax2 check if we don't show sources anymore...
d1834 1
a1834 1
		if (!m_ShowSrc)	//Cax2 always restore the sort index that was there before expanding the files...
@


1.114.2.1
log
@27a partial merge
@
text
@d108 1
a108 4
	InsertColumn(12, lsctitle,LVCFMT_LEFT, 220);
	lsctitle=GetResString(IDS_FD_LASTCHANGE);
	lsctitle.Remove(':');
	InsertColumn(13, lsctitle,LVCFMT_LEFT, 220);
a229 6

	  strRes = GetResString(IDS_FD_LASTCHANGE);
	  strRes.Remove(':');
	  hdi.pszText = strRes.GetBuffer();
	  pHeaderCtrl->SetItem(13, &hdi);
	  strRes.ReleaseBuffer();
d637 1
a637 1
					buffer=lpPartFile->lastseencomplete.Format( theApp.glob_prefs->GetDateTimeFormat());
d641 3
a643 7
		case 13: // last receive
			if (!IsColumnHidden(11)) {
			if(lpPartFile->GetLastChangeDatetime()!=NULL)
				buffer=lpPartFile->GetLastChangeDatetime().Format( theApp.glob_prefs->GetDateTimeFormat());
				else buffer="";
			dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
		}	
a668 1
		case SO_LMULE:
d1288 1
a1288 1
			m_FileMenu.EnableMenuItem(MP_STOP,((!file->IsStopped() && file->GetStatus() != PS_ERROR && !filedone ) ? MF_ENABLED:MF_GRAYED));
d1425 1
a1425 1
			if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+99) {
d1555 1
a1555 1
						char* buffer = new char[MAX_PATH];
d2000 1
a2000 1
	    case 12: //last seen complete asc 
a2006 7
	case 13: //last received Time asc 
		if (file1->GetLastChangeDatetime() > file2->GetLastChangeDatetime())
			return 1;
		else if(file1->GetLastChangeDatetime() < file2->GetLastChangeDatetime())
			return -1;
		else
			return 0;
@


1.114.2.2
log
@uncompleted stuff...
@
text
@d109 1
a109 1
	lsctitle=GetResString(IDS_LAST_FILE_PROGRESS);
d234 1
a234 1
	  strRes = GetResString(IDS_LAST_FILE_PROGRESS);
@


1.114.2.3
log
@27c
@
text
@d480 1
a480 1
                        CTimeSpan ts = CTime::GetCurrentTime() - lpPartFile->GetCFileDate();
d651 3
a653 2
			if(lpPartFile->GetFileDate()!=NULL)
				buffer=lpPartFile->GetCFileDate().Format( theApp.glob_prefs->GetDateTimeFormat());
d656 2
a657 1
			break;
d1517 1
d2022 1
a2022 1
		if (file1->GetFileDate() > file2->GetFileDate())
d2024 1
a2024 1
		else if(file1->GetFileDate() < file2->GetFileDate())
@


1.113
log
@Updated Night Shift to Scheduller (needs more testing and a new icon from DrSiRiUs... coming!)
@
text
@d2046 3
a2048 3
						uint32 plus1=client1->PlusVersion();
						uint32 plus2=client2->PlusVersion();
						if(plus1>0 && plus2>0) 
d2050 9
a2058 2
						if(plus1>0 || plus2>0)
							return (plus1>0)?-1:1;
@


1.112
log
@fix crash at exit
@
text
@d116 1
a116 1
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));      // 4
@


1.111
log
@corrected menu options for non-vlc preview & low disk space
@
text
@d386 2
@


1.110
log
@bugfix: preview movies( bug #50)
@
text
@d1300 1
a1300 1
			if(file->IsMovie() && justOne && !file->PreviewAvailable())	//Cax2 - greyed out if we can preview it
@


1.109
log
@*** empty log message ***
@
text
@d1300 1
a1300 1
			if((file->IsMovie()||file->IsArchive()) && justOne && !filedone)
d1302 2
a1303 2
				m_FileMenu.EnableMenuItem(MP_MOVIE,(file->IsArchive())?MF_GRAYED:MF_ENABLED);
				m_FileMenu.CheckMenuItem(MP_MOVIE,(file->GetMovieMode() != 0 || file->IsArchive())?MF_CHECKED:MF_UNCHECKED);
@


1.108
log
@various bugfixes for "friends"
@
text
@d401 1
a401 1
				theApp.sharedfiles->UpdateItem(((CKnownFile*)toupdate));
@


1.107
log
@more logical sortorder: Complete-Completing-Downloading-Waiting-Paused-Errors
@
text
@d1372 4
a1375 1
			m_ClientMenu.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
d1706 3
@


1.106
log
@Changes to credits and ed2k links.
@
text
@d1961 10
a1970 1
			return file1->GetPartfileStatus().Compare(file2->GetPartfileStatus()); 
@


1.105
log
@sorting
@
text
@d1524 1
a1524 1
							str += theApp.CreateED2kLink(selectedList.GetHead()) + "\n"; 
d1526 2
d1538 1
a1538 1
							str += theApp.CreateHTMLED2kLink(selectedList.GetHead()) + "\n"; 
d1540 2
d1673 3
a1675 2
						while(!selectedList.IsEmpty()) { 
							str += selectedList.GetHead()->CreateED2KSourceLink(7, 10) + "\n"; 
d1677 2
@


1.104
log
@swapping columns around
@
text
@d2009 1
a2009 1
				return client1->GetTransferedUp() - client2->GetTransferedUp();
d2011 1
a2011 1
		        return client1->GetTransferedDown() - client2->GetTransferedDown();
@


1.103
log
@bugifx: bug #10
@
text
@a800 5
			buffer = lpClient->GetTransferedUp()?CastItoXBytes(lpClient->GetTransferedUp()):"";
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
			break;

		case 3:// completed
d805 3
@


1.102
log
@converted to new logging method
@
text
@d2059 1
a2059 1
					if ( lParamSort==9 && isValid1 && isValid2)
d2061 1
a2061 1
					if (isValid1 && isValid2)		//Cax2 - it's got to be lParamSort==10
@


1.101
log
@fix for some problems during app shutdown
@
text
@d2164 1
a2164 1
				theApp.emuledlg->AddLogLine( false, "%s\\%s",file->GetPath(),file->GetFileName());
d2220 1
a2220 1
	theApp.emuledlg->AddLogLine(true,GetResString(IDS_NEWSERVERCONNECT),theApp.glob_prefs->GetMaxSourcePerFile()); 
d2301 1
a2301 1
		theApp.emuledlg->AddLogLine(false,file->GetFileName());
d2307 1
a2307 1
	theApp.emuledlg->AddLogLine(false,out);
@


1.100
log
@corrected yet another minor mistake by me :D
@
text
@d330 9
a338 7

 			LVFINDINFO find;
			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)pSource;
			sint16 result = FindItem(&find);
			if(result != -1)
				DeleteItem(result);
@


1.99
log
@corrected a minor error
@
text
@d1976 1
a1976 1
	    case 10: //Remaining Time asc 
@


1.98
log
@added columns from official and changed transferred column
@
text
@d2009 1
a2009 1
				return client1->GetSessionUp() - client2->GetSessionUp();
@


1.97
log
@partial bug 5 bugfix: plus sorted & named correctly in download list
@
text
@d96 7
a102 6
	InsertColumn(3,GetResString(IDS_DL_SPEED),LVCFMT_RIGHT, 65);
	InsertColumn(4,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT, 170);
	InsertColumn(5,GetResString(IDS_DL_SOURCES),LVCFMT_CENTER, 50);
	InsertColumn(6,GetResString(IDS_PRIORITY),LVCFMT_LEFT, 55);
	InsertColumn(7,GetResString(IDS_STATUS),LVCFMT_LEFT, 70);
	InsertColumn(8,GetResString(IDS_DL_REMAINS),LVCFMT_LEFT, 110);
d104 5
a108 2
	InsertColumn(9,GetResString(IDS_DL_ULDL),LVCFMT_LEFT,60);
	InsertColumn(10,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60);
d179 5
d186 1
a186 1
	  pHeaderCtrl->SetItem(3, &hdi);
d191 1
a191 1
	  pHeaderCtrl->SetItem(4, &hdi);
d196 1
a196 1
	  pHeaderCtrl->SetItem(5, &hdi);
d201 1
a201 1
	  pHeaderCtrl->SetItem(6, &hdi);
d206 1
a206 1
	  pHeaderCtrl->SetItem(7, &hdi);
d211 1
a211 1
	  pHeaderCtrl->SetItem(8, &hdi);
d217 1
a217 1
	  pHeaderCtrl->SetItem(9, &hdi);
d222 7
a228 1
	  pHeaderCtrl->SetItem(10, &hdi);
d494 6
a499 1
			case 3:		// speed
d509 1
a509 1
			case 4:		// progress
d546 1
a546 1
			case 5:		// sources
d562 1
a562 1
			case 6:		// prio
d596 1
a596 1
			case 7:		// status
d601 1
a601 1
			case 8:		// remaining time & size
d628 9
d799 6
a804 2
			if(!lpCtrlItem->IsAskedForAnotherFile() && nTransferredDown)
			{
d806 1
a806 2

				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d810 1
a810 1
		case 3:		// speed
d821 1
a821 1
		case 4:		// file info
d863 1
a863 1
	case 5:		// sources
d878 1
a878 1
		case 6:		// prio
d902 1
a902 1
		case 7:		// status
d913 1
a913 1
		case 8:		// remaining time & size
d915 1
a915 1
		case 9: // UL/DL Ratio Maverick
d921 1
a921 1
		case 10: // Ratio total Maverick
d979 1
a979 1
			if(iColumn == 4)
d990 1
a990 1
				DrawFileItem(dc, 4, &cur_rec, content);
d1007 1
a1007 1
			if(iColumn == 4)
d1018 1
a1018 1
				DrawSourceItem(dc, 4, &cur_rec, content);
d1940 3
a1942 1
		case 3: //speed asc
d1944 1
a1944 1
		case 4: //progress asc
d1949 1
a1949 1
		case 5: //sources asc
d1951 1
a1951 1
		case 6: //priority asc
d1953 1
a1953 1
		case 7: //Status asc 
d1955 1
a1955 1
		case 8: //Remaining Time asc
d1976 7
d2009 4
a2012 2
				return client1->GetTransferedDown() - client2->GetTransferedDown();
			case 3: //speed asc
d2014 1
a2014 1
			case 4: //progress asc
d2016 1
a2016 1
			case 5: //sources column
d2033 1
a2033 1
			case 6: //priority column - QR 
d2047 1
a2047 1
			case 7: //Status column - Lord KiRon
d2050 2
a2051 2
			case 9: // UL/DL column - Maverick
			case 10: // Ratio column - Maverick
d2077 1
a2077 1
	
d2312 1
a2312 1
}
@


1.96
log
@some sorting bugfixes
@
text
@d1979 6
a1984 4
						// Lord KiRon - not needed any more because version corrected when read
						/*if ((client2->GetMuleVersion()==0x2B  &&  client1->GetMuleVersion()==0x22)||(client1->GetMuleVersion()==0x2B  &&  client2->GetMuleVersion()==0x22))
								return client2->GetMuleVersion() - client1->GetMuleVersion();
						return ((client2->GetMuleVersion()==0x2B)?0x22:client2->GetMuleVersion()) - ((client1->GetMuleVersion()==0x2B)?0x22:client1->GetMuleVersion());*/
@


1.95
log
@bugfix a4af local name
@
text
@d143 1
a143 1
		SortItems(SortProc, sortItem + (sortAscending ? 0:10));
d1699 2
a1700 2
	m_lastSort=m_CurrentSortItem + (m_SortAscending ? 0:10); // Cax2
	SortItems(SortProc, m_CurrentSortItem + (m_SortAscending ? 0:10)+(m_ShowSrc?1000:0)); // Cax2
d1719 1
a1719 1
    if(lParamSort >= 10)
d1722 1
a1722 1
		lParamSort -= 10;
d1790 2
a1791 2
			m_CurrentSortItem=(m_lastSort<10)?m_lastSort:m_lastSort-10;
			SetSortArrow(m_CurrentSortItem,(m_lastSort<10));
d1833 2
a1834 2
		m_CurrentSortItem=(m_lastSort<10)?m_lastSort:m_lastSort-10;
		SetSortArrow(m_CurrentSortItem,(m_lastSort<10));
d1845 2
a1846 2
					SortItems(&SortProc,1017); // kiron's status desc, show sources(clients) 05/01/03
					SortItems(&SortProc,1013); // speed desc, show sources(clients)
d2004 1
a2005 8
				if ((client1->IsRemoteInfoAvaiable() || client1->credits) &&
					(client2->IsRemoteInfoAvaiable() || client2->credits))
					return (client1->GetRemoteBaseModifier() - client2->GetRemoteBaseModifier())*10;		//Cax2 - has to return an integer!
				if (client1->IsRemoteInfoAvaiable() || client1->credits)				
					return 1;
				if (client2->IsRemoteInfoAvaiable() || client2->credits)				
					return -1;
				return 0;
d2007 15
a2021 8
				if ((client1->IsRemoteInfoAvaiable() || client1->credits) &&
					(client2->IsRemoteInfoAvaiable() || client2->credits))
					return client1->GetRemoteRatio() - client2->GetRemoteRatio();
				if (client1->IsRemoteInfoAvaiable() || client1->credits)				
					return 1;
				if (client2->IsRemoteInfoAvaiable() || client2->credits)				
					return -1;
				return 0;
@


1.94
log
@Last changes to context menues and Fakecheck code removal.
@
text
@a626 4

	CString sClientFileName = _T("");
	if(lpClient->GetClientFilename())
		try{ sClientFileName = CString(lpClient->GetClientFilename()); }catch(...){}
d664 2
d672 1
a672 1
				if(!lpCtrlItem->IsAskedForAnotherFile())
d699 2
a700 3
						CString fname;
						fname.Format("(%s)", sClientFileName.GetBuffer(0));
						status = fname;
d743 1
a743 1
				CString sName;
d756 1
a756 3
				bool a4af=false;
				if(lpCtrlItem->IsAskedForAnotherFile())
					a4af = true;
d758 1
a758 1
					crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));
@


1.93
log
@Updates to reCDVst changes (missing strings) and some changes to the context menu (lost an hour for a f****** define). Added standard web services.
@
text
@d1232 1
a1232 2
			if(theApp.glob_prefs->IsDAPEnabled())
				m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));
d1253 1
a1253 2
			if(theApp.glob_prefs->IsDAPEnabled())
				m_PrioMenu.CheckMenuItem(MP_PRIOAUTO, (justOne && file->IsAutoPrioritized())? MF_CHECKED:MF_UNCHECKED);
a1324 1
			m_FileMenu.EnableMenuItem((UINT_PTR)m_ed2kMenu.m_hMenu, MF_ENABLED);
a1604 3
					break;
           		case MP_FAKECHECK1:	// DeltaHF
					theApp.Action(file,NULL,NULL);
@


1.92
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@a69 5
	if(m_PrioMenu.GetSafeHmenu())
		m_PrioMenu.DestroyMenu();
	if(m_FileMenu.GetSafeHmenu())
		m_FileMenu.DestroyMenu();

a132 1
	CreateMenues();
a1127 1
	ON_NOTIFY_REFLECT(NM_RCLICK, OnNMRclick)
d1131 1
d1200 1
a1200 1
void CDownloadListCtrl::OnNMRclick(NMHDR *pNMHDR, LRESULT *pResult)
d1204 6
a1209 2
	POINT point;
	GetCursorPos(&point);
d1220 1
d1225 39
d1265 2
a1266 1
			m_FileMenu.EnableMenuItem(MP_STOP,((file->GetStatus() != PS_ERROR && !filedone ) ? MF_ENABLED:MF_GRAYED));
d1268 4
d1273 10
d1284 14
a1297 1
			
d1305 1
a1305 1
			}			
d1307 1
d1309 2
d1312 3
a1314 4
			m_FileMenu.EnableMenuItem(MP_METINFO,(justOne)?MF_ENABLED:MF_GRAYED); // Cax2
			m_FileMenu.EnableMenuItem(MP_VIEWFILECOMMENTS,(justOne)?MF_ENABLED:MF_GRAYED); // Cax2
			m_FileMenu.EnableMenuItem(MP_CHANGEDIR, !filedone ? MF_ENABLED:MF_GRAYED); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
			m_FileMenu.EnableMenuItem(MP_FAKECHECK1,(justOne)?MF_ENABLED:MF_GRAYED); // DeltaHF (+Cax2 Patch 21/12/02)
d1317 1
a1317 1
				m_FileMenu.CheckMenuItem(MP_ALL_A4AF_AUTO, file->IsA4AFAuto()? MF_CHECKED: MF_UNCHECKED); // Tarod
a1322 8
			m_FileMenu.EnableMenuItem(MP_CANCEL,(!filedone) ? MF_ENABLED:MF_GRAYED);

			if( (file->IsMovie()||file->IsArchive()) && justOne && !filedone)
			{
				m_FileMenu.EnableMenuItem(MP_MOVIE,(file->IsArchive())?MF_GRAYED:MF_ENABLED);
				m_FileMenu.CheckMenuItem(MP_MOVIE,(file->GetMovieMode() != 0 || file->IsArchive())?MF_CHECKED:MF_UNCHECKED);
			} else
				m_FileMenu.EnableMenuItem(MP_MOVIE, MF_GRAYED);
d1324 1
a1324 4
			m_FileMenu.EnableMenuItem((UINT_PTR)m_PrioMenu.m_hMenu, MF_ENABLED);
			m_FileMenu.EnableMenuItem(MP_GETED2KLINK, MF_ENABLED);
			m_FileMenu.EnableMenuItem(MP_GETHTMLED2KLINK, MF_ENABLED);
			m_FileMenu.EnableMenuItem(MP_GETSOURCEED2KLINK, MF_ENABLED);
d1326 2
a1327 4
			m_PrioMenu.CheckMenuItem(MP_PRIOAUTO, (justOne && file->IsAutoPrioritized())? MF_CHECKED:MF_UNCHECKED);
			m_PrioMenu.CheckMenuItem(MP_PRIOHIGH,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_HIGH)? MF_CHECKED:MF_UNCHECKED);
			m_PrioMenu.CheckMenuItem(MP_PRIONORMAL,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_NORMAL)? MF_CHECKED:MF_UNCHECKED);
			m_PrioMenu.CheckMenuItem(MP_PRIOLOW,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_LOW)? MF_CHECKED:MF_UNCHECKED);
d1329 1
a1329 7
			int counter;
			m_Web.CreateMenu();
			UpdateURLMenu(m_Web,counter);
			UINT flag;
			flag=(counter==0) ? MF_GRAYED:MF_STRING;
			
			m_FileMenu.AppendMenu(flag|MF_POPUP,(UINT_PTR)m_Web.m_hMenu, GetResString(IDS_WEBSERVICES) );
d1333 2
d1336 3
a1338 1
		} else {
d1346 1
d1358 3
a1360 20
		m_FileMenu.EnableMenuItem((UINT_PTR)m_PrioMenu.m_hMenu,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_CANCEL,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_PAUSE,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_STOP,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_RESUME,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_PREVIEW,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_OPEN,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_FAKECHECK1,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_MOVIE,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_VIEWFILECOMMENTS,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_METINFO,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_CHANGEDIR, MF_GRAYED); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
		m_FileMenu.EnableMenuItem(MP_LOADSOURCES,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_SAVESOURCES,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_DROPNONEEDEDSRCS,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_ALL_A4AF_TO_HERE,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_ALL_A4AF_AUTO,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_GETED2KLINK,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_GETHTMLED2KLINK,MF_GRAYED);
		m_FileMenu.EnableMenuItem(MP_GETSOURCEED2KLINK,MF_GRAYED);
d1362 1
a1363 1
	*pResult = 0;
a2146 53

	EMULE_CATCH
}

void CDownloadListCtrl::CreateMenues() 
{
	EMULE_TRY

	char buffer[100];
	if (m_PrioMenu) m_PrioMenu.DestroyMenu();
	if (m_FileMenu) m_FileMenu.DestroyMenu();

	m_PrioMenu.CreateMenu();
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOLOW, GetResString(IDS_PRIOLOW));
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));

	m_FileMenu.CreatePopupMenu();
	m_FileMenu.AddMenuTitle(GetResString(IDS_DOWNLOADMENUTITLE));

	m_FileMenu.AppendMenu(MF_STRING,MP_CLEARCOMPLETED, GetResString(IDS_DL_CLEAR));
	m_FileMenu.AppendMenu(MF_SEPARATOR);
	m_FileMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_PrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
	m_FileMenu.AppendMenu(MF_STRING,MP_CANCEL, GetResString(IDS_MAIN_BTN_CANCEL));
	m_FileMenu.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP));
	m_FileMenu.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE));
	m_FileMenu.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME));
	m_FileMenu.AppendMenu(MF_SEPARATOR);
	m_FileMenu.AppendMenu(MF_STRING,MP_OPEN, GetResString(IDS_DL_OPEN));
	m_FileMenu.AppendMenu(MF_STRING,MP_MOVIE, GetResString(IDS_MOVIE));
	m_FileMenu.AppendMenu(MF_STRING,MP_PREVIEW, GetResString(IDS_DL_PREVIEW));
	m_FileMenu.AppendMenu(MF_STRING,MP_METINFO, GetResString(IDS_DL_INFO));
	m_FileMenu.AppendMenu(MF_STRING,MP_VIEWFILECOMMENTS, GetResString(IDS_CMT_SHOWALL));
	m_FileMenu.AppendMenu(MF_STRING,MP_CHANGEDIR, GetResString(IDS_CHANGEDIR)); //<<-- enkeyDEV(Ottavio84) -ChangeDir-
	m_FileMenu.AppendMenu(MF_STRING,MP_FAKECHECK1, (LPCTSTR)"Jigle FakeCheck"); // DeltaHF
	m_FileMenu.AppendMenu(MF_SEPARATOR);
	m_FileMenu.AppendMenu(MF_STRING,MP_LOADSOURCES, GetResString(IDS_DL_LOADSOURCES)); // Mr.Fry
	m_FileMenu.AppendMenu(MF_STRING,MP_SAVESOURCES, GetResString(IDS_DL_SAVESOURCES)); // Mr.Fry
	m_FileMenu.AppendMenu(MF_SEPARATOR);
	m_FileMenu.AppendMenu(MF_STRING,MP_DROPNONEEDEDSRCS, GetResString(IDS_DROPNONEEDEDSRCS)); // Tarod
	m_FileMenu.AppendMenu(MF_STRING,MP_ALL_A4AF_TO_HERE, GetResString(IDS_ALL_A4AF_TO_HERE)); // Tarod
	sprintf(buffer,"%s (%s)", GetResString(IDS_ALL_A4AF_TO_HERE), GetResString(IDS_PRIOAUTO));
	m_FileMenu.AppendMenu(MF_STRING,MP_ALL_A4AF_AUTO,buffer); // Tarod
	m_FileMenu.AppendMenu(MF_SEPARATOR);
	
	m_FileMenu.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
	m_FileMenu.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
	m_FileMenu.AppendMenu(MF_STRING,MP_GETSOURCEED2KLINK, GetResString(IDS_CREATESOURCELINK)); //<<-- enkeyDEV(Ottavio84) -Create source ed2k from downloads-
	m_FileMenu.AppendMenu(MF_SEPARATOR);

	if(m_hWnd)
		SetMenu(&m_FileMenu);
@


1.91
log
@Another rewrite - now very close to Maella's code
@
text
@d1245 1
d1274 8
d1283 2
d1315 1
d1358 4
d1486 1
a1486 1
						sprintf(buffer,"%s\\%s",theApp.glob_prefs->GetIncomingDir(),file->GetFileName());
d1491 19
d2144 1
d2159 2
a2160 1
	
@


1.90
log
@restore Plus version recognition
@
text
@a36 3
#define MULE_ITEM_KEY (void*)0
#define MULE_FILE_KEY (void*)1

a41 243
CMuleItemMgr::~CMuleItemMgr()
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	MuleRange Range = m_ListData.equal_range(MULE_ITEM_KEY);
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		CMuleCtrlItem* pItem = (CMuleCtrlItem*)g->second;
		delete pItem;
	}
}

CMuleCtrlItem* CMuleItemMgr::AddFile(CPartFile* pFile)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	if(!pFile)
		return NULL;

	// Create item
	CMuleCtrlItem* pItem = new CMuleCtrlItem(pFile, NULL);
	// To be able to find item by CPartFile pointer
	m_ListData.insert(make_pair(pFile, pItem));
	// To be able to find file by item pointer
	m_ListData.insert(make_pair(pItem, pFile));

	// To be able to find all items
	m_ListData.insert(make_pair(MULE_ITEM_KEY, pItem));

	// To be able to find all files
	m_ListData.insert(make_pair(MULE_FILE_KEY, pFile));

	return pItem;
}

void CMuleItemMgr::RemoveFile(CMuleCtrlItem* pItem)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);
	CSingleLock RemoveLock(&m_MutexRemove, TRUE);

	CPartFile* pFile = pItem->GetFile();
//	int nFound = 0;
	bool bFound = true;
	while(bFound)
	{
		bFound = false;
		for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); g++)
		{
			if(g->second == pItem)
			{
				m_ListData.erase(g);
				bFound = true;
//				nFound++;
				break;
			}
		}
	}
//	if(nFound == 0)
//		TRACE("Didn't find source to delete when deleting file %g!\n", pFile);

	MuleRange Range = m_ListData.equal_range(MULE_ITEM_KEY);
//	bFound = false;
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second == pItem)
		{
			m_ListData.erase(g);
//			bFound = true;
			break;
		}
	}
//	if(!bFound)
//		TRACE("Didn't find item to delete when deleting file %g!\n", pFile);

	Range = m_ListData.equal_range(MULE_FILE_KEY);
//	bFound = false;
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second == pFile)
		{
			m_ListData.erase(g);
//			bFound = true;
			break;
		}
	}
//	if(!bFound)
//		TRACE("Didn't find file to delete when deleting file %g!\n", pFile);

	m_ListData.erase(pItem);
	m_ListData.erase(pFile);
	delete pItem;
}

CMuleCtrlItem* CMuleItemMgr::AddSource(CUpDownClient* pSource, CPartFile* pFile)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	if(!pSource || !pFile)
		return NULL;

	CMuleCtrlItem* pItem = FindSource(pSource, pFile, FALSE);

	// Create item, if it's new
	if(!pItem)
	{
		pItem = new CMuleCtrlItem(pFile, pSource);
		// To be able to find item by CPartFile pointer
		m_ListData.insert(make_pair(pFile, pItem));
		// To be able to find item by CUpDownClient pointer
		m_ListData.insert(make_pair(pSource, pItem));
		// To be able to find all items
		m_ListData.insert(make_pair(MULE_ITEM_KEY, pItem));
	}

	return pItem;
}

void CMuleItemMgr::RemoveSource(CMuleCtrlItem* pItem)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);
	CSingleLock RemoveLock(&m_MutexRemove, TRUE);

	CUpDownClient* pSource = pItem->GetSource();
	m_ListData.erase(pSource);
	MuleRange Range = m_ListData.equal_range(pItem->GetSource());
//	bool bFound = false;
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second == pItem)
		{
			m_ListData.erase(g);
//			bFound = true;
			break;
		}
	}
//	if(!bFound)
//		TRACE("Didn't find source %g to delete!\n", pSource);
	Range = m_ListData.equal_range(pItem->GetFile());
//	bFound = false;
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second == pItem)
		{
			m_ListData.erase(g);
//			bFound = true;
			break;
		}
	}
//	if(!bFound)
//		TRACE("Didn't find file %g to delete!\n", pSource);
	Range = m_ListData.equal_range(MULE_ITEM_KEY);
//	bFound = false;
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second == pItem)
		{
			m_ListData.erase(g);
//			bFound = true;
			break;
		}
	}
//	if(!bFound)
//		TRACE("Didn't find item %g to delete!\n", pItem);
	delete pItem;

}

void CMuleItemMgr::RemoveSource(CUpDownClient* pSource)
{
	// Removing all instances of source
//	int nFound = 0;
	bool bFound = true;
	while(bFound)
	{
		bFound = false;
		MuleRange Range = m_ListData.equal_range(pSource);
		for(MuleIter g = Range.first; g != Range.second; g++)
		{
			CMuleCtrlItem* pItem = (CMuleCtrlItem*)g->second;
			if(pItem->IsSource())
			{
				RemoveSource(pItem);
//				nFound++;
				bFound = true;
				break;
			}
		}
	}
//	if(nFound == 0)
//		TRACE("Didn't find ANY source %g to delete!\n", pSource);
}

CMuleCtrlItem* CMuleItemMgr::FindSource(CUpDownClient* pSource, CPartFile* pFile, BOOL bLock)
{
	CSingleLock AccessLock(&m_MutexAccess, bLock);

	// It's better to find by CUpDownClient key, since there are
	// much less files per source than sources per file
	MuleRange Range = m_ListData.equal_range(pSource);
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second)
		{
			CMuleCtrlItem* pItem = (CMuleCtrlItem*)g->second;
			if(pItem->GetFile() == pFile)
				return pItem;
		}
	}
	return NULL;
}

CMuleCtrlItem* CMuleItemMgr::FindFile(CPartFile* pFile)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	MuleRange Range = m_ListData.equal_range(pFile);
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second)
		{
			CMuleCtrlItem* pItem = (CMuleCtrlItem*)g->second;
			if(pItem->IsFile())
				return pItem;
		}
	}
	return NULL;
}

MuleRange CMuleItemMgr::GetAllFiles()
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	// We keep list of files by file key
	return m_ListData.equal_range(MULE_FILE_KEY);
}

MuleRange CMuleItemMgr::GetItemsByFile(CPartFile* pFile)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	return m_ListData.equal_range(pFile);
}

d75 8
d230 12
a241 2
	CMuleCtrlItem* pItem = m_ItemMgr.AddFile(toadd);
    uint16 itemnr = GetItemCount();
d250 33
a282 2
        
	CMuleCtrlItem* pItem = m_ItemMgr.AddSource(source, owner);
d289 1
a289 1
	find.lParam = (LPARAM)m_ItemMgr.FindFile(owner);
d303 1
a303 6

	CMuleCtrlItem* pSource = NULL;
	if(owner)
		pSource = m_ItemMgr.FindSource(source, owner);

	if(pSource || !owner)
d305 1
a305 1
		if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 1)
d307 2
a308 5
			if(theApp.emuledlg->transferwnd.infolistctrl.GetClient() == source)
			{
				theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
				theApp.emuledlg->transferwnd.UpdateInfoHeader();
			}
d310 3
d314 5
a318 2
		// Delete source only for this file
		if(owner)
d320 1
a320 1
			CMuleCtrlItem* pParent = m_ItemMgr.FindFile(owner);
d322 1
a322 1
			LVFINDINFO find;
d324 5
a328 13
			find.lParam = (LPARAM)pParent;
			int nItem = FindItem(&find);
			if(nItem < 0) nItem = 0;
			for(; nItem < GetItemCount(); nItem++)
			{
				CMuleCtrlItem* pItem = (CMuleCtrlItem*)GetItemData(nItem);
				if(pItem->GetSource() == source && pItem->GetFile() == owner)
				{
					DeleteItem(nItem);
					break;
				}
			}
			m_ItemMgr.RemoveSource(m_ItemMgr.FindSource(source, owner));
a329 1
		// Delete this source for all files
d331 1
a331 13
		{
			for(uint16 nItem = 0; nItem < GetItemCount();)
			{
				CMuleCtrlItem* pItem = (CMuleCtrlItem*)GetItemData(nItem);
				if(pItem->GetSource() == source)
				{
					DeleteItem(nItem);
				}
				else
					nItem++;
			}
			m_ItemMgr.RemoveSource(source);
		}
d339 6
a344 2
	CMuleCtrlItem* pFile = m_ItemMgr.FindFile(toremove);
	if(pFile)
d346 1
a346 1
		if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 2)
d348 6
a353 14
			if(theApp.emuledlg->transferwnd.infolistctrl.GetFile() == toremove)
			{
				theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
				theApp.emuledlg->transferwnd.UpdateInfoHeader();
			}
		}			
		LVFINDINFO find;
		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pFile;
		int result = FindItem(&find);
		if(result != -1)
			DeleteItem(result);
	}
   	for(int i = 0; i < GetItemCount();)
d355 12
a366 6
		CMuleCtrlItem* pItem = (CMuleCtrlItem*)GetItemData(i);
		if(pItem->IsSource() && pItem->GetFile() == toremove)
	   	{
		   	DeleteItem(i);
			m_ItemMgr.RemoveSource(pItem);
	   	}
d368 2
a369 4
			i++;
   	}
	if(pFile)
		m_ItemMgr.RemoveFile(pFile);
d376 2
a377 3

	CMuleCtrlItem* pFile = m_ItemMgr.FindFile((CPartFile*)toupdate);
	if(pFile)
d379 1
d382 1
a382 1
		find.lParam = (LPARAM)pFile;
d386 1
a386 1
			pFile->m_dwUpdated = 0;
d389 2
a390 1
			theApp.sharedfiles->UpdateItem(((CKnownFile*)toupdate));
a392 15
	else	// Then it's source
	{
		// Looking for all items with this source
		for(int i = 0; i < GetItemCount(); i++)
		{
			CMuleCtrlItem* pItem = (CMuleCtrlItem*)GetItemData(i);
			if(pItem->GetSource() == (CUpDownClient*)toupdate)
			{
				pItem->m_dwUpdated = 0;
				Update(i);
				RedrawItems(i, i);
			}
		}
	}

d1166 2
a1167 2
			m_ItemMgr.LockRemove();
			MuleRange Range = m_ItemMgr.GetItemsByFile(partfile);
d1170 1
a1170 1
			for(MuleIter g = Range.first; g != Range.second; g++)
d1172 2
a1173 2
				pItem = (CMuleCtrlItem*)g->second;
				if (pItem->IsSource())
d1175 1
a1175 6
					
					if (!(client=pItem->GetSource()))	//Cax2 - remove it!!!
					{
						m_ItemMgr.RemoveSource(pItem);
						continue;
					}
a1190 1
			m_ItemMgr.UnlockRemove();
d1194 2
a1195 1
		} else {
d1197 1
a1197 1
		}
d1705 1
a1705 7
	CMuleCtrlItem* pItem; 
    LVFINDINFO find;
    find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)m_ItemMgr.FindFile(partfile);
    int nItem = FindItem(&find);
	if(nItem < 0) nItem = 0;
	for (int i = nItem; i <GetItemCount(); )
d1707 1
a1707 1
		pItem = (CMuleCtrlItem*)GetItemData(i); 
d1740 1
a1740 3
	
	bool bFound = true;
	while(bFound)
d1742 7
a1748 13
		bFound = false;
		m_ItemMgr.LockRemove();
		MuleRange Range = m_ItemMgr.GetAllFiles();
		for(MuleIter g = Range.first; g != Range.second; g++)
		{
			CPartFile* file = (CPartFile*)g->second;
			if (!file->IsPartFile())
			{
				m_ItemMgr.UnlockRemove();
				RemoveFile(file);
				bFound = true;
				break;
			}
a1749 2
		if(!bFound)
			m_ItemMgr.UnlockRemove();
a1750 1

d2174 2
d2178 1
a2178 3
	m_ItemMgr.LockRemove();
	MuleRange Range = m_ItemMgr.GetItemsByFile(file);
	for(MuleIter g = Range.first; g != Range.second; g++)
d2180 2
a2181 2
		CMuleCtrlItem* pItem = (CMuleCtrlItem*)g->second;
		if(pItem->IsSource() && pItem->IsAskedForAnotherFile())
d2184 2
a2185 1
	m_ItemMgr.UnlockRemove();
d2236 3
a2238 3
	m_ItemMgr.LockRemove();
	MuleRange Range = m_ItemMgr.GetAllFiles();
	for(MuleIter g = Range.first; g != Range.second; g++)
d2240 4
a2243 1
		CPartFile* file = (CPartFile*)g->second;
a2250 1
	m_ItemMgr.UnlockRemove();
@


1.89
log
@Corrected grayed Get First/Last for movies.
@
text
@d1080 6
a1085 4
				if (nClientSoft == SO_UNKNOWN)
					buffer.Format("???");
				else
					buffer.Format("%s v%s",GetClientNameString(nClientSoft),GetClientVersionString(nClientSoft, nVersion));
d1087 1
a1087 1
			dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
@


1.88
log
@*** empty log message ***
@
text
@d1495 2
a1496 2
				m_FileMenu.EnableMenuItem(MP_MOVIE,(file->GetMovieMode() != 0 || file->IsArchive())?MF_GRAYED:MF_ENABLED);
				m_FileMenu.CheckMenuItem(MP_MOVIE, (file->GetMovieMode() != 0 || file->IsArchive())? MF_CHECKED:MF_UNCHECKED);
@


1.87
log
@No movie preview on completed files.
@
text
@d1779 1
a1779 1
					if (!filedone)
@


1.86
log
@enkeydev stuff
@
text
@d1493 1
a1493 1
			if( (file->IsMovie()||file->IsArchive()) && justOne)
d1779 1
a1779 1
					if (file->GetMovieMode())
d1781 1
a1781 4
						file->SetMovieMode(0);
						file->SaveMovieMode();
					} else {
						if (file->IsAviMovie())
d1783 17
a1799 2
							if (selectedList.GetHead()->GetFileSize() < 209715200)
								file->SetMovieMode(1);
d1801 2
a1802 8
								file->SetMovieMode(2);
						}	
						else if (file->IsMpgMovie())
						{
							if (selectedList.GetHead()->GetFileSize() < 209715200)
								file->SetMovieMode(4);
							else
								file->SetMovieMode(5);
a1803 3
						else
							file->SetMovieMode(0);
						file->SaveMovieMode();
@


1.85
log
@*** empty log message ***
@
text
@d1503 1
d1548 1
d1804 17
d2373 1
@


1.84
log
@minor bugfix!
@
text
@d1495 1
a1495 1
				m_FileMenu.EnableMenuItem(MP_MOVIE, MF_ENABLED);
@


1.83
log
@file buffer size, autotake ed2k links and some preferences reorganization.
@
text
@d2254 1
a2254 1
					if(pPartFile->HasComment())
@


1.82
log
@Paused files shown in grey and Selected search methos stored between sessions.
@
text
@d1496 1
a1496 1
				m_FileMenu.CheckMenuItem(MP_MOVIE, (file->GetMovieMode() != 0)? MF_CHECKED:MF_UNCHECKED);
@


1.81
log
@A4AF bugfixes: shift+expand doesn't show A4AF anymore, the source count is updated....
@
text
@d698 2
d703 1
a703 1

@


1.80
log
@Bogfix: rating average, and last 'unknown friends' bugfix... I hope
@
text
@d1398 2
d1402 1
a1402 1
				CMuleCtrlItem* pItem = (CMuleCtrlItem*)g->second;
d1405 2
a1406 1
					if (!pItem->GetSource())	//Cax2 - remove it!!!
d1415 3
a1417 3
						uint8 ds = pItem->GetSource()->GetDownloadState();
						if(!(isShift	&& ds==DS_DOWNLOADING ||
							isCtrl	&& pItem->GetSource()->GetRemoteQueueRank()>0 ||
d2235 1
a2235 1
				rPlusMinus.left += 4 + 2;			// eeek, hardcoded values
d2243 1
a2243 1
				rRating.left = rPlusMinus.right;
d2245 1
a2245 1
				rRating.right = rRating.left + 16 - 4;
@


1.79
log
@*** empty log message ***
@
text
@d1403 5
@


1.78
log
@Messages friend details working & solved context menu problems (Damn! we need a redesign of that). Now version 1b beta 1.
@
text
@d1490 4
d1514 1
@


1.77
log
@Release 1a
@
text
@d1439 1
a1439 1
	if (GetSelectionMark() != (-1))
@


1.76
log
@proper Hybrid version nr!
@
text
@d940 1
a940 1
						fname.Format("(A4AF: %s)", sClientFileName.GetBuffer(0));
@


1.75
log
@bugfix: Hybrid version nr
@
text
@d873 1
a873 1
	uint8 nVersion;
d1078 1
a1078 3
				switch(nClientSoft)
				{
				case SO_UNKNOWN:
d1080 1
a1080 2
					break;
				default:
a1081 1
				}
@


1.74
log
@bugfixed A4AF
@
text
@d873 10
a882 1
	uint8 nMuleVersion = lpClient->GetMuleVersion();
a1079 5
				case SO_EMULE:
				case SO_OLDEMULE:
				case SO_CDONKEY:
					buffer.Format("%s v%s",GetClientNameString(nClientSoft),GetClientVersionString(nClientSoft, nMuleVersion));
					break;
d1084 1
a1084 2
					buffer.Format("%s v%s",GetClientNameString(nClientSoft),GetClientVersionString(nClientSoft, nMuleVersion));
					break;
@


1.73
log
@A4AF shown gray, context menus updated and minor updates. Beta 3 numbering.
@
text
@d1888 2
a1889 2
			//always at the end, unless sort by source - then a4af always at the top
			return (lParamSort==5)? n : -n;
@


1.72
log
@More bugfixes
@
text
@d985 8
d994 2
@


1.71
log
@Final icons from DrSiRiUs for ratings.
@
text
@d86 1
a86 1
	int nFound = 0;
d97 1
a97 1
				nFound++;
d102 2
a103 2
	if(nFound == 0)
		TRACE("Didn't find source to delete when deleting file %g!\n", pFile);
d106 1
a106 1
	bFound = false;
d112 1
a112 1
			bFound = true;
d116 2
a117 2
	if(!bFound)
		TRACE("Didn't find item to delete when deleting file %g!\n", pFile);
d120 1
a120 1
	bFound = false;
d126 1
a126 1
			bFound = true;
d130 2
a131 2
	if(!bFound)
		TRACE("Didn't find file to delete when deleting file %g!\n", pFile);
d170 1
a170 1
	bool bFound = false;
d176 1
a176 1
			bFound = true;
d180 2
a181 2
	if(!bFound)
		TRACE("Didn't find source %g to delete!\n", pSource);
d183 1
a183 1
	bFound = false;
d189 1
a189 1
			bFound = true;
d193 2
a194 2
	if(!bFound)
		TRACE("Didn't find file %g to delete!\n", pSource);
d196 1
a196 1
	bFound = false;
d202 1
a202 1
			bFound = true;
d206 2
a207 2
	if(!bFound)
		TRACE("Didn't find item %g to delete!\n", pItem);
d215 1
a215 1
	int nFound = 0;
d227 1
a227 1
				nFound++;
d233 2
a234 2
	if(nFound == 0)
		TRACE("Didn't find ANY source %g to delete!\n", pSource);
d864 23
a886 1
	CUpDownClient *lpUpDownClient = lpCtrlItem->GetSource();
d905 1
a905 1
					switch (lpUpDownClient->GetDownloadState())
d931 1
a931 1
						fname.Format("(A4AF: %s)", lpUpDownClient->GetClientFilename());
d941 1
a941 1
                if(lpUpDownClient->GetClientSoft() == SO_EDONKEYHYBRID) {
d943 1
a943 1
                    if (lpUpDownClient->IsFriend())
d945 1
a945 1
                    else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
d948 1
a948 1
		        else if (lpUpDownClient->GetClientSoft() == SO_MLDONKEY) {
d950 1
a950 1
                    if (lpUpDownClient->IsFriend())
d952 1
a952 1
                    else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
d955 1
a955 1
		        else if (lpUpDownClient->GetClientSoft()==SO_EMULE || lpUpDownClient->GetClientSoft()==SO_OLDEMULE) {
d957 1
a957 1
                    if (lpUpDownClient->IsFriend())
d959 1
a959 1
                    else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
d964 1
a964 1
                    if (lpUpDownClient->IsFriend())
d966 1
a966 1
                    else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
a975 2
				try{ sName = lpUpDownClient->GetUserName(); }
				catch(...){ sName = _T(""); }
d977 1
a977 1
				if (sName.IsEmpty())
d982 2
a983 2
					buffer1 = new char[sName.GetLength() + 50 + status.GetLength()];
					sprintf(buffer1,"%s %s", sName.GetBuffer(0), status.GetBuffer(0));
d994 1
a994 1
			if(!lpCtrlItem->IsAskedForAnotherFile() && lpUpDownClient->GetTransferedDown())
d996 1
a996 1
				buffer = CastItoXBytes(lpUpDownClient->GetTransferedDown());
d1003 1
a1003 1
			if (!lpCtrlItem->IsAskedForAnotherFile() && lpUpDownClient->GetDownloadDatarate())
d1005 1
a1005 1
				if (lpUpDownClient->GetDownloadDatarate()==0)
d1008 1
a1008 1
					buffer.Format("%.1f %s", lpUpDownClient->GetDownloadDatarate()/1024.0f,GetResString(IDS_KBYTESEC));
d1040 1
a1040 1
					lpUpDownClient->DrawStatusBar(&cdcStatus,  &rec_status,(lpCtrlItem->IsAskedForAnotherFile()), theApp.glob_prefs->UseFlatBar()); 
d1059 1
a1059 1
				switch(lpUpDownClient->GetClientSoft())
d1064 1
a1064 1
					buffer.Format("%s v%s",GetClientNameString(lpUpDownClient->GetClientSoft()),GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetMuleVersion()));
d1070 1
a1070 1
					buffer.Format("%s v%s",GetClientNameString(lpUpDownClient->GetClientSoft()),GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetVersion()));
d1079 2
a1080 2
		if ((lpUpDownClient->IsEmuleClient() ||  lpUpDownClient->GetRemoteQueueRank())&&		//now emule v ? display the QR too!
			lpUpDownClient->GetDownloadState()==DS_ONQUEUE)
d1082 1
a1082 1
			if( lpUpDownClient->IsRemoteQueueFull() ){
d1087 2
a1088 2
				if ( lpUpDownClient->GetRemoteQueueRank()){
				buffer.Format("QR: %u",lpUpDownClient->GetRemoteQueueRank());
d1110 1
a1110 12
			status = lpUpDownClient->GetDownloadStateAsString();
			char* buffer1;
			if (!lpUpDownClient->GetUserName())
			{
				buffer1 = new char[strlen(status)+1];
				sprintf(buffer1,"%s",status);
			} else {
				buffer1 = new char[strlen(status)+1];
				sprintf(buffer1,"%s",status);
			}
			dc->DrawText(buffer1,(int)strlen(buffer1),&cur_rec, DLC_DT_TEXT);
			delete[] buffer1; 
d1116 2
a1117 2
			if (lpUpDownClient->IsRemoteInfoAvaiable() || lpUpDownClient->credits)
				buffer.Format("%0.1f",lpUpDownClient->GetRemoteBaseModifier());
d1122 2
a1123 2
			if (lpUpDownClient->IsRemoteInfoAvaiable() || lpUpDownClient->credits)
				buffer.Format("%ld",lpUpDownClient->GetRemoteRatio());
@


1.70
log
@Bugfixes and some simplifying of code
@
text
@d368 1
a368 1
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELENT),16,16));	// 17 19
d685 1
a685 1
				    lpRect->left+=9;
@


1.69
log
@Bugfixes
@
text
@d37 3
d49 1
a49 1
	MuleRange Range = m_ListData.equal_range(NULL);
d71 2
a72 2
	// To be able to find all items by zero key
	m_ListData.insert(make_pair((void*)NULL, pItem));
d74 2
a75 2
	// To be able to find all files by zero key
	m_ListFS.insert(make_pair((void*)NULL, pFile));
d86 35
a120 3
	m_ListData.erase(pItem);
	m_ListData.erase(pFile);
	MuleRange Range = m_ListFS.equal_range(NULL);
d125 2
a126 1
			m_ListFS.erase(g);
d130 5
a134 1
	m_ListFS.erase(pFile);
d155 2
a156 6
		// To be able to find all items by zero key
		m_ListData.insert(make_pair((void*)NULL, pItem));
		// To be able to find file by source
		m_ListFS.insert(make_pair(pSource, pFile));
		// To be able to find source by file
		m_ListFS.insert(make_pair(pFile, pSource));
d169 2
a170 2
	m_ListFS.erase(pSource);
	MuleRange Range = m_ListData.equal_range(pItem->GetFile());
d176 1
d180 4
a183 1
	Range = m_ListData.equal_range(NULL);
d189 1
d193 4
a196 1
	Range = m_ListFS.equal_range(pItem->GetFile());
d199 1
a199 1
		if(g->second == pSource)
d201 2
a202 1
			m_ListFS.erase(g);
d206 2
d215 1
d227 1
d233 2
d277 2
a278 2
	// We keep in ListFS list of files by zero key
	return m_ListFS.equal_range(NULL);
@


1.68
log
@now ratings are shown with more descriptive icons (THX->DrSiRiUs)
@
text
@d37 5
d67 4
d162 1
d322 1
a322 1
	
a428 1
	pItem->SetAskedForAnotherFile(notavailable);
d481 1
a482 1
				break;
d567 1
a567 1
			if(pItem->IsSource() && pItem->GetSource() == (CUpDownClient*)toupdate)
d631 1
a631 1
						POINT point= {lpRect->left-4,lpRect->top+3};
a1081 1
	//CtrlItem_Struct* content = (CtrlItem_Struct*)lpDrawItemStruct->itemData;
d1472 2
a1473 1
	EMULE_TRY
d1757 1
a1757 1
	EMULE_CATCH
d1836 1
a1836 1
	CMuleCtrlItem* item; 
d1844 2
a1845 2
		item = (CMuleCtrlItem*)GetItemData(i); 
		if(item->IsSource() && item->GetFile() == partfile)
d1847 2
a1848 2
			item->m_dwUpdated = 0; 
			item->m_Status.DeleteObject(); 
d2103 1
a2103 1
					return client1->GetRemoteRatio() - client2->GetRemoteRatio();	
a2316 2
// Added by Tarod -download all A4AF sources in this file now
// kuchin [1.1.2003] - added more checks as seen in dump there was crash
d2321 2
d2329 1
a2329 1
			pItem->GetSource()->HandoverToAnotherFile(file);
d2332 3
@


1.67
log
@minor bugfixes, refreshes sources display...
@
text
@d303 10
a312 6
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING),16,16));		   	// 13
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATINGBAD),16,16));	  	// 14
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  	// 15
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  		// 16
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  		// 17

d589 1
a589 1
					int iIcon = lpPartFile->GetSourceCount() > 0 ? (lpPartFile->srcarevisible ? 15 : 17) : 16;
d593 30
a622 5
			        if (lpPartFile->HasComment() || lpPartFile->HasRating()){
				        int image=13;
				        if (lpPartFile->HasRating()) if (lpPartFile->HasBadRating()) image=14;

				        POINT point= {lpRect->left-4,lpRect->top+3};
@


1.66
log
@ClearCompleted fix
@
text
@d1044 1
d2056 1
a2056 1
					return client1->GetRemoteBaseModifier() - client2->GetRemoteBaseModifier();
d2065 1
a2065 1
					return client1->GetRemoteRatio() - client2->GetRemoteRatio();
d2125 1
a2125 1
				rRating.right = rRating.left + 16 - 6;
@


1.65
log
@Small fix
@
text
@d1839 2
a1840 3
	m_ItemMgr.LockRemove();
	MuleRange Range = m_ItemMgr.GetAllFiles();
	for(MuleIter g = Range.first; g != Range.second; g++)
d1842 17
a1858 5
		CPartFile* file = (CPartFile*)g->second;
		if (!file->IsPartFile())
			RemoveFile(file);
    }
	m_ItemMgr.UnlockRemove();
@


1.64
log
@Updated conetext menus.
@
text
@d930 1
d932 1
@


1.64.2.1
log
@v1a upgrade
@
text
@a36 8
#define MULE_ITEM_KEY (void*)0
#define MULE_FILE_KEY (void*)1

bool CMuleCtrlItem::IsAskedForAnotherFile()
{
	return (m_pSource ? (m_pSource->reqfile != m_pFile) : false); 
}

d41 1
a41 1
	MuleRange Range = m_ListData.equal_range(MULE_ITEM_KEY);
d62 2
a63 6

	// To be able to find all items
	m_ListData.insert(make_pair(MULE_ITEM_KEY, pItem));

	// To be able to find all files
	m_ListData.insert(make_pair(MULE_FILE_KEY, pFile));
d74 3
a76 35
//	int nFound = 0;
	bool bFound = true;
	while(bFound)
	{
		bFound = false;
		for(MuleIter g = m_ListData.begin(); g != m_ListData.end(); g++)
		{
			if(g->second == pItem)
			{
				m_ListData.erase(g);
				bFound = true;
//				nFound++;
				break;
			}
		}
	}
//	if(nFound == 0)
//		TRACE("Didn't find source to delete when deleting file %g!\n", pFile);

	MuleRange Range = m_ListData.equal_range(MULE_ITEM_KEY);
//	bFound = false;
	for(MuleIter g = Range.first; g != Range.second; g++)
	{
		if(g->second == pItem)
		{
			m_ListData.erase(g);
//			bFound = true;
			break;
		}
	}
//	if(!bFound)
//		TRACE("Didn't find item to delete when deleting file %g!\n", pFile);

	Range = m_ListData.equal_range(MULE_FILE_KEY);
//	bFound = false;
d81 1
a81 2
			m_ListData.erase(g);
//			bFound = true;
d85 1
a85 5
//	if(!bFound)
//		TRACE("Didn't find file to delete when deleting file %g!\n", pFile);

	m_ListData.erase(pItem);
	m_ListData.erase(pFile);
d106 6
a111 2
		// To be able to find all items
		m_ListData.insert(make_pair(MULE_ITEM_KEY, pItem));
d124 2
a125 2
	MuleRange Range = m_ListData.equal_range(pItem->GetSource());
//	bool bFound = false;
a130 1
//			bFound = true;
d134 1
a134 4
//	if(!bFound)
//		TRACE("Didn't find source %g to delete!\n", pSource);
	Range = m_ListData.equal_range(pItem->GetFile());
//	bFound = false;
a139 1
//			bFound = true;
d143 1
a143 4
//	if(!bFound)
//		TRACE("Didn't find file %g to delete!\n", pSource);
	Range = m_ListData.equal_range(MULE_ITEM_KEY);
//	bFound = false;
d146 1
a146 1
		if(g->second == pItem)
d148 1
a148 2
			m_ListData.erase(g);
//			bFound = true;
a151 2
//	if(!bFound)
//		TRACE("Didn't find item %g to delete!\n", pItem);
a152 1

a157 1
//	int nFound = 0;
a168 1
//				nFound++;
a173 2
//	if(nFound == 0)
//		TRACE("Didn't find ANY source %g to delete!\n", pSource);
d216 2
a217 2
	// We keep list of files by file key
	return m_ListData.equal_range(MULE_FILE_KEY);
d303 5
a307 9
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));	  	// 13 15
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));	  		// 14 16
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));	  		// 15 17
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_NO),16,16));		// 16 18
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_EXCELLENT),16,16));	// 17 19
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_GOOD),16,16));		// 18 20
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAIR),16,16));	  	// 19 21
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_POOR),16,16));		// 20 22
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_RATING_FAKE),16,16));	  	// 21 23
d415 1
a467 1
					break;
d469 1
d554 1
a554 1
			if(pItem->GetSource() == (CUpDownClient*)toupdate)
d585 1
a585 1
					int iIcon = lpPartFile->GetSourceCount() > 0 ? (lpPartFile->srcarevisible ? 13 : 15) : 14;
d589 4
a592 29
			        if (lpPartFile->HasComment() || lpPartFile->HasRating())
			        {
				        int image=16;
				        if (lpPartFile->HasRating())
				        {
				        	switch(lpPartFile->GetRating())
				        	{
								case 0: 
									image=16; 
									break; 
								case 1: 
									image=21;
									break; 
								case 2: 
									image=20; 
									break; 
								case 3: 
									image=18; 
									break; 
								case 4: 
									image=19; 
									break; 
								case 5: 
									image=17; 
									break;
								default:
									image=16;
							}
						}
d596 1
a596 1
				    lpRect->left+=10;
d775 1
a775 32
	CUpDownClient *lpClient = lpCtrlItem->GetSource();

	CString sClientFileName = _T("");
	if(lpClient->GetClientFilename())
		try{ sClientFileName = CString(lpClient->GetClientFilename()); }catch(...){}
	CString sDownloadState = _T("");
	try{ sDownloadState = lpClient->GetDownloadStateAsString(); }catch(...){}
	uint8 nDownloadState = lpClient->GetDownloadState();
	eClientTypes nClientSoft = lpClient->GetClientSoft();
	uint32 nVersion;	//Cax2 - version nr bugfix
	switch(nClientSoft){
		case SO_EMULE:
		case SO_OLDEMULE:
		case SO_CDONKEY:
			nVersion= lpClient->GetMuleVersion();
			break;
		default:
			nVersion= lpClient->GetVersion();
	}
	bool bIsFriend = lpClient->IsFriend();
	float fRemoteBaseModifier = lpClient->GetRemoteBaseModifier();
	CString sClientName = _T("");
	if(lpClient->GetUserName())
		try{ sClientName = CString(lpClient->GetUserName()); }catch(...){}
	uint32 nTransferredDown = lpClient->GetTransferedDown();
	uint32 nDownloadDataRate = lpClient->GetDownloadDatarate();
	bool bIsEmuleClient = lpClient->IsEmuleClient();
	uint16 nRemoteQueueRank = lpClient->GetRemoteQueueRank();
	bool bRemoteQueueFull = lpClient->IsRemoteQueueFull();
	bool bIsRemoteInfoAvail = lpClient->IsRemoteInfoAvaiable();
	bool bCredits = lpClient->credits != (CClientCredits*)NULL && lpClient->credits != (CClientCredits*)-1;
	uint16 nRemoteRatio = lpClient->GetRemoteRatio();
d794 1
a794 1
					switch (nDownloadState)
d820 1
a820 1
						fname.Format("(%s)", sClientFileName.GetBuffer(0));
d830 1
a830 1
                if(nClientSoft == SO_EDONKEYHYBRID) {
d832 1
a832 1
                    if (bIsFriend)
d834 1
a834 1
                    else if (fRemoteBaseModifier >= 1.1)
d837 1
a837 1
		        else if (nClientSoft == SO_MLDONKEY) {
d839 1
a839 1
                    if (bIsFriend)
d841 1
a841 1
                    else if (fRemoteBaseModifier >= 1.1)
d844 1
a844 1
		        else if (nClientSoft==SO_EMULE || nClientSoft==SO_OLDEMULE) {
d846 1
a846 1
                    if (bIsFriend)
d848 1
a848 1
                    else if (fRemoteBaseModifier >= 1.1)
d853 1
a853 1
                    if (bIsFriend)
d855 1
a855 1
                    else if (fRemoteBaseModifier >= 1.1)
d865 2
d868 1
a868 1
				if (sClientName.IsEmpty())
d873 2
a874 2
					buffer1 = new char[sClientName.GetLength() + 50 + status.GetLength()];
					sprintf(buffer1,"%s %s", sClientName.GetBuffer(0), status.GetBuffer(0));
a875 8

                // DonGato: different color for A4AF sources
				COLORREF crOldTxtColor;
				bool a4af=false;
				if(lpCtrlItem->IsAskedForAnotherFile())
					a4af = true;
				if(a4af)
					crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));
a876 2
                if(a4af)
                	dc->SetTextColor(crOldTxtColor);
d885 1
a885 1
			if(!lpCtrlItem->IsAskedForAnotherFile() && nTransferredDown)
d887 1
a887 1
				buffer = CastItoXBytes(nTransferredDown);
d894 1
a894 1
			if (!lpCtrlItem->IsAskedForAnotherFile())
d896 1
a896 1
				if (nDownloadDataRate==0)
d899 1
a899 1
					buffer.Format("%.1f %s", nDownloadDataRate/1024.0f,GetResString(IDS_KBYTESEC));
d930 1
a930 3
					try{
					lpClient->DrawStatusBar(&cdcStatus,  &rec_status,(lpCtrlItem->IsAskedForAnotherFile()), theApp.glob_prefs->UseFlatBar()); 
					}catch(...){} // in case client has been deleted meanwhile
d948 8
a955 1
				if (nClientSoft == SO_UNKNOWN)
d957 5
a961 2
				else
					buffer.Format("%s v%s",GetClientNameString(nClientSoft),GetClientVersionString(nClientSoft, nVersion));
d968 2
a969 2
		if ((bIsEmuleClient || nRemoteQueueRank)&&		//now emule v ? display the QR too!
			nDownloadState==DS_ONQUEUE)
d971 1
a971 1
			if(bRemoteQueueFull){
d976 2
a977 2
				if (nRemoteQueueRank){
				buffer.Format("QR: %u", nRemoteQueueRank);
d999 12
a1010 1
			dc->DrawText(sDownloadState,sDownloadState.GetLength(),&cur_rec, DLC_DT_TEXT);
d1016 2
a1017 2
			if (bIsRemoteInfoAvail || bCredits)
				buffer.Format("%0.1f", fRemoteBaseModifier);
d1022 2
a1023 2
			if (bIsRemoteInfoAvail || bCredits)
				buffer.Format("%ld", nRemoteRatio);
a1293 5
					if (!pItem->GetSource())	//Cax2 - remove it!!!
					{
						m_ItemMgr.RemoveSource(pItem);
						continue;
					}
d1330 1
a1330 1
	if (GetSelectionMark() != (-1) && GetSelectedCount()>0)
a1380 4
			m_FileMenu.EnableMenuItem((UINT_PTR)m_PrioMenu.m_hMenu, MF_ENABLED);
			m_FileMenu.EnableMenuItem(MP_GETED2KLINK, MF_ENABLED);
			m_FileMenu.EnableMenuItem(MP_GETHTMLED2KLINK, MF_ENABLED);

a1400 1

d1432 1
a1432 2
	try
	{
d1716 1
a1716 1
	}catch(...){}
d1777 2
a1778 2
			if (n!=0)			//always at the end, unless sort by source - then a4af always at the top
				return (lParamSort==5)? n : -n;
d1795 1
a1795 1
	CMuleCtrlItem* pItem; 
d1803 2
a1804 2
		pItem = (CMuleCtrlItem*)GetItemData(i); 
		if(pItem->IsSource() && pItem->GetFile() == partfile)
d1806 2
a1807 2
			pItem->m_dwUpdated = 0; 
			pItem->m_Status.DeleteObject(); 
d1837 3
a1839 2
	bool bFound = true;
	while(bFound)
d1841 5
a1845 17
		bFound = false;
		m_ItemMgr.LockRemove();
		MuleRange Range = m_ItemMgr.GetAllFiles();
		for(MuleIter g = Range.first; g != Range.second; g++)
		{
			CPartFile* file = (CPartFile*)g->second;
			if (!file->IsPartFile())
			{
				m_ItemMgr.UnlockRemove();
				RemoveFile(file);
				bFound = true;
				break;
			}
		}
		if(!bFound)
			m_ItemMgr.UnlockRemove();
	}
d2042 1
a2042 1
					return (client1->GetRemoteBaseModifier() - client2->GetRemoteBaseModifier())*10;		//Cax2 - has to return an integer!
d2111 1
a2111 1
				rRating.right = rRating.left + 16 - 4;
d2265 2
a2270 2
	// Make a list of sources
	CArray<CUpDownClient*, CUpDownClient*> SourcesList;
d2277 1
a2277 1
			SourcesList.Add(pItem->GetSource());
a2279 3
	// Actually handover
	for(int i = 0; i < SourcesList.GetCount(); i++)
		SourcesList[i]->HandoverToAnotherFile(file);
@


1.64.2.2
log
@keeping in sync with the main cvs line
@
text
@a697 2
					else if(lpPartFile->GetStatus()==PS_PAUSED)
						crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_GRAYTEXT));
d701 1
a701 1
					
a1397 2
			CUpDownClient* client;
			CMuleCtrlItem* pItem;
d1400 1
a1400 1
				pItem = (CMuleCtrlItem*)g->second;
d1403 1
a1403 2
					
					if (!(client=pItem->GetSource()))	//Cax2 - remove it!!!
d1412 3
a1414 3
						uint8 ds = client->GetDownloadState();
						if(!(isShift	&& ds==DS_DOWNLOADING && !pItem->IsAskedForAnotherFile() ||		//Cax2 - don't show clients transferring to another file...
							isCtrl	&& client->GetRemoteQueueRank()>0 ||
d1491 1
a1491 1
				m_FileMenu.CheckMenuItem(MP_MOVIE, (file->GetMovieMode() != 0 || file->IsArchive())? MF_CHECKED:MF_UNCHECKED);
d2232 1
a2232 1
				rPlusMinus.left += 4 + 4;			// eeek, hardcoded values
d2240 1
a2240 1
				rRating.left = rPlusMinus.right+2;
d2242 1
a2242 1
				rRating.right = rRating.left + 16 - 6;
@


1.63
log
@another useless feature: a click on the ratings-icon opens the file-comments-dialog (my files had no rating, so i couldn't test it!!)
@
text
@d1350 8
a1357 2
			m_FileMenu.EnableMenuItem(MP_LOADSOURCES,((file->GetStatus() != PS_COMPLETE && file->GetStatus() != PS_COMPLETING)?MF_ENABLED:MF_GRAYED)); // Add mr.fry
			m_FileMenu.EnableMenuItem(MP_SAVESOURCES,MF_ENABLED); // Mr Fry
d1405 1
d1412 11
a1422 1
		m_FileMenu.EnableMenuItem(MP_FAKECHECK1,MF_GRAYED); // DeltaHF
@


1.62
log
@Removed upload slots configuration.
@
text
@d2050 2
d2076 7
d2086 2
a2087 2
				rPlusMinus.right = rPlusMinus.left + 16 - 2;	//  --||--
				rPlusMinus.bottom = rPlusMinus.top + 16 - 2;	//  --||--
d2090 17
d2114 1
a2114 2

	RefreshInfo();
@


1.61
log
@Banning Message, A4AF customization, AutoPriority fix, Static Servers fix, .dat/.bin Preview
@
text
@d820 1
a820 1
						fname.Format("(%s)", lpUpDownClient->GetClientFilename());
@


1.60
log
@bufix in download sort
@
text
@d818 6
a823 1
					status = _T("(") + GetResString(IDS_ASKED4ANOTHERFILE) + _T(")");
@


1.59
log
@Proper fix
@
text
@a796 2
							imagelist.Draw(dc, 10, point, ILD_NORMAL);
							break;
a797 2
							imagelist.Draw(dc, 10, point, ILD_NORMAL);
							break;
d799 1
a805 2
							imagelist.Draw(dc, 8, point, ILD_NORMAL);
							break;
a809 2
							imagelist.Draw(dc, 11, point, ILD_NORMAL);
							break;
a812 3
						case DS_TOOMANYCONNS:
							imagelist.Draw(dc, 10, point, ILD_NORMAL);
							break;
d1977 1
a1977 1
					return (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0:1):-1;
d1988 1
a1988 1
					return (client2->GetClientSoft()-client1->GetClientSoft())*sortMod;
d2004 2
d2008 1
a2008 1
					return (client1->GetDownloadState()!=DS_ONQUEUE)?((client2->GetDownloadState()!=DS_ONQUEUE)?0:2):-1;
@


1.58
log
@Fixes
@
text
@d155 21
a467 1
					m_ItemMgr.RemoveSource(pItem);
d471 1
a481 1
					m_ItemMgr.RemoveSource(pItem);
d486 1
@


1.57
log
@Improvements
@
text
@d148 1
a148 1
			m_ListData.erase(g);
d2281 2
d2284 2
@


1.56
log
@Performance fix
@
text
@d71 1
d120 1
d1271 1
d1293 1
d1804 1
d1812 1
d2211 3
a2213 2
/*	POSITION pos = m_ItemMgr.m_ListSources.GetStartPosition();
    while(pos != 0) 
d2215 6
a2220 15
        void* key;
		CMuleSourceEntry* pSourceEntry = NULL;
        m_ItemMgr.m_ListSources.GetNextAssoc(pos, key, pSourceEntry);
		for(int i = 0; i < pSourceEntry->GetSourceCount(); i++)
		{
			CMuleCtrlItem* item = pRealSource->GetSource(i);
			if (item->IsAskedForAnotherFile() && item->GetFile() == file)
			{
				CUpDownClient* cur_src = item->GetSource();
				if(cur_src)
					cur_src->HandoverToAnotherFile(file);
			}
		}
    }
*/
d2260 4
a2263 3
CString CDownloadListCtrl::getTextList() {
	return "";
/*
d2267 3
a2269 2
	POSITION pos = listcontent.GetStartPosition();
	while(pos != NULL)
d2271 7
a2277 13
        void* key;
		CtrlItem_Struct* delitem;
		listcontent.GetNextAssoc(pos, key, delitem);
		if (delitem->type == 1){
			CPartFile* file = (CPartFile*)delitem->value;
			theApp.emuledlg->AddLogLine(false,file->GetFileName());

			temp2=file->GetFileName(); if (temp2.GetLength()>50) temp2=temp2.Mid(0,50);
			temp.Format("\n%s\t [%.1f%%] %i/%i - %s",
				temp2,file->GetPercentCompleted(),file->GetTransferingSrcCount(),file->GetSourceCount(), file->GetPartfileStatus());
			out=out+temp;
		}
	}
d2279 3
a2281 1
	return out;*/
@


1.55
log
@Small fix
@
text
@d79 1
d81 2
d127 1
d129 2
d136 1
d138 2
d145 1
d147 2
@


1.54
log
@3rd rewrite - multimap rulez
@
text
@a191 7
int CMuleItemMgr::GetSourcesCount(CPartFile* pFile)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);

	return m_ListFS.count(pFile);
}

d1157 1
a1157 1
			!((CMuleCtrlItem*)GetItemData(lpDrawItemStruct->itemID + 1))->IsFile();
d1160 1
a1160 1
		BOOL isExpandable = !isChild && m_ItemMgr.GetSourcesCount(content->GetFile()) > 0;
@


1.53
log
@listcontent rewrite - second try
@
text
@d37 1
a37 1
void CMuleFileEntry::AddSource(CMuleSourceEntry* pSource)
d39 8
a46 2
	CSingleLock AccessLock(&m_AccessMutex, TRUE);
	m_List.SetAt(pSource, NULL);
d49 1
a49 1
void CMuleFileEntry::RemoveSource(CMuleSourceEntry* pSource)
d51 1
a51 3
	CSingleLock AccessLock(&m_AccessMutex, TRUE);
	m_List.RemoveKey(pSource);
}
d53 2
a54 5
bool CMuleFileEntry::IsEmpty()
{
    POSITION pos = m_List.GetStartPosition();
	return (pos == NULL);
}
d56 8
a63 5
void CMuleSourceEntry::AddFile(CMuleFileEntry* pFile)
{
	CSingleLock AccessLock(&m_AccessMutex, TRUE);
	m_List.SetAt(pFile, NULL);
}
d65 1
a65 4
void CMuleSourceEntry::RemoveFile(CMuleFileEntry* pFile)
{
	CSingleLock AccessLock(&m_AccessMutex, TRUE);
	m_List.RemoveKey(pFile);
d68 1
a68 1
bool CMuleSourceEntry::IsEmpty()
d70 1
a70 3
    POSITION pos = m_List.GetStartPosition();
	return (pos == NULL);
}
d72 11
a82 4
bool CMuleSourceEntry::IsInList(CMuleFileEntry* pFile)
{
	void* pNull;
	return m_List.Lookup(pFile, pNull);
d85 1
a85 1
CMuleCtrlItem* CMuleItemMgr::AddFile(CPartFile* pFile)
d88 22
a109 10
	CMuleFileEntry* pFileEntry = NULL;
	// Maybe file already exists
	if(!m_ListFiles.Lookup(pFile, pFileEntry))
	{
		pFileEntry = new CMuleFileEntry(pFile);
		m_ListFiles.SetAt(pFile, pFileEntry);
	}
	CMuleCtrlItem* pItem = new CMuleCtrlItem(pFileEntry, NULL);
	m_ListItems.SetAt(pItem, NULL);
	pFileEntry->SetCtrlItem(pItem);
d113 1
a113 1
void CMuleItemMgr::RemoveFile(CMuleCtrlItem* pFile)
d116 18
a133 7
	if(!pFile->IsFile())
		return;
	CMuleFileEntry* pFileEntry = pFile->GetFile();
	m_ListFiles.RemoveKey(pFileEntry->GetFile());
	// Find and remove all ctrl source childs, if any
    POSITION pos = m_ListItems.GetStartPosition();
    while(pos != 0) 
d135 14
a148 12
        void* pNull;
        CMuleCtrlItem* pItem;
        m_ListItems.GetNextAssoc(pos, pItem, pNull);
		if(pItem->GetFile() == pFileEntry)
		{
			m_ListItems.RemoveKey(pItem);
			delete pItem;
		}
    }
	// Find and remove all references to file in sources, if any
	pos = m_ListSources.GetStartPosition();
    while(pos != 0) 
d150 1
a150 6
        CUpDownClient* key;
        CMuleSourceEntry* pItem;
        m_ListSources.GetNextAssoc(pos, key, pItem);
		pItem->RemoveFile(pFileEntry);
		// And remove source, if it's not connected to any file
		if(pItem->IsEmpty())
d152 3
a154 2
			m_ListSources.RemoveKey(key);
			delete pItem;
d156 2
a157 3
    }
	delete pFileEntry;
	delete pFile;
d160 1
a160 1
CMuleCtrlItem* CMuleItemMgr::AddSource(CUpDownClient* pSource, CPartFile* pFile)
a162 23
	CMuleSourceEntry* pSourceEntry = NULL;
	// Maybe source is already exists
	if(!m_ListSources.Lookup(pSource, pSourceEntry))
	{
		pSourceEntry = new CMuleSourceEntry(pSource);
		m_ListSources.SetAt(pSource, pSourceEntry);
	}
	CMuleFileEntry* pFileEntry = NULL;
	// Maybe file already exists
	if(!m_ListFiles.Lookup(pFile, pFileEntry))
	{
		pFileEntry = new CMuleFileEntry(pFile);
		m_ListFiles.SetAt(pFile, pFileEntry);
	}
	bool bFirst = pSourceEntry->IsEmpty();
	pSourceEntry->AddFile(pFileEntry);
	if(bFirst)
		pSourceEntry->SetCurrentFile(pFileEntry->GetFile());
	pFileEntry->AddSource(pSourceEntry);
	CMuleCtrlItem* pItem = new CMuleCtrlItem(pFileEntry, pSourceEntry);
	m_ListItems.SetAt(pItem, NULL);
	return pItem;
}
d164 2
a165 8
void CMuleItemMgr::RemoveSource(CMuleCtrlItem* pSource)
{
	CSingleLock AccessLock(&m_MutexAccess, TRUE);
	CMuleSourceEntry* pSourceEntry = pSource->GetSource();
	CMuleFileEntry* pFileEntry = pSource->GetFile();
	pFileEntry->RemoveSource(pSourceEntry);
	pSourceEntry->RemoveFile(pFileEntry);
	if(pSourceEntry->IsEmpty())
d167 6
a172 2
		m_ListSources.RemoveKey(pSourceEntry->GetSource());
		delete pSourceEntry;
d174 1
a174 1
	delete pSource;
d177 1
a177 1
CMuleSourceEntry* CMuleItemMgr::FindSource(CUpDownClient* pClient)
d180 3
a182 3
	CMuleSourceEntry* pSource = NULL;
	m_ListSources.Lookup(pClient, pSource);
	return pSource;
d185 1
a185 1
CMuleFileEntry* CMuleItemMgr::FindFile(CPartFile* pFile)
d188 2
a189 3
	CMuleFileEntry* pFileEntry = NULL;
	m_ListFiles.Lookup(pFile, pFileEntry);
	return pFileEntry;
d192 3
d196 1
a196 26
CMuleItemMgr::~CMuleItemMgr()
{
    POSITION pos = m_ListSources.GetStartPosition();
    while(pos != 0) {
		CUpDownClient* key;
        CMuleSourceEntry* value;
        m_ListSources.GetNextAssoc(pos, key, value);
	    delete value;
    }
	m_ListSources.RemoveAll();
    pos = m_ListFiles.GetStartPosition();
    while(pos != 0) {
        CPartFile* key;
        CMuleFileEntry* value;
        m_ListFiles.GetNextAssoc(pos, key, value);
	    delete value;
    }
	m_ListFiles.RemoveAll();
	pos = m_ListItems.GetStartPosition();
    while(pos != 0) {
        void* pNull;
        CMuleCtrlItem* value;
        m_ListItems.GetNextAssoc(pos, value, pNull);
	    delete value;
    }
	m_ListItems.RemoveAll();
a199 1

d387 1
a387 2
	if(!notavailable)
		pItem->GetSource()->SetCurrentFile(owner);
d394 3
a396 2
	find.lParam = (LPARAM)pItem->GetFile()->GetCtrlItem();
    uint16 nItem = FindItem(&find);
d409 3
a411 2
	CMuleSourceEntry* pSource = m_ItemMgr.FindSource(source);
	CMuleFileEntry* pFile = m_ItemMgr.FindFile(owner);
d413 1
a413 1
	if(pSource && (pSource->IsInList(pFile) || (!owner) ) )
d427 1
a427 1
			CMuleCtrlItem* pParent = pFile->GetCtrlItem();
d432 3
a434 1
			for(uint16 nItem = FindItem(&find); nItem < GetItemCount(); nItem++)
d437 1
a437 1
				if(pItem->GetSource() == pSource && pItem->GetFile() == pFile)
d451 1
a451 1
				if(pItem->GetSource() == pSource)
d467 1
a467 1
	CMuleFileEntry* pFile = m_ItemMgr.FindFile(toremove);
d480 2
a481 2
		find.lParam = (LPARAM)pFile->GetCtrlItem();
		sint16 result = FindItem(&find);
d488 1
a488 1
		if(pItem->IsSource() && pItem->GetFile()->GetFile() == toremove)
d497 1
a497 1
		m_ItemMgr.RemoveFile(pFile->GetCtrlItem());
d505 1
a505 1
	CMuleFileEntry* pFile = m_ItemMgr.FindFile((CPartFile*)toupdate);
d510 2
a511 2
		find.lParam = (LPARAM)pFile->GetCtrlItem();
		sint16 result = FindItem(&find);
d514 1
a514 1
			pFile->GetCtrlItem()->m_dwUpdated = 0;
a518 2

		return;
d520 1
a520 3

	CMuleSourceEntry* pSource = m_ItemMgr.FindSource((CUpDownClient*)toupdate);
	if(pSource)
d522 1
a522 1
		// looking for all items with this source
d526 1
a526 1
			if(pItem->IsSource() && pItem->GetSource() == pSource)
d551 1
a551 1
		CPartFile *lpPartFile = lpCtrlItem->GetFile()->GetFile();
d747 1
a747 1
	CUpDownClient *lpUpDownClient = lpCtrlItem->GetSource()->GetSource();
d1167 1
a1167 1
		BOOL isExpandable = !isChild && !content->GetFile()->IsEmpty();
d1260 1
a1260 1
		CPartFile* partfile = content->GetFile()->GetFile();
d1264 5
a1268 8
			CMuleFileEntry *pFileEntry = content->GetFile();
			POSITION pos = m_ItemMgr.m_ListItems.GetStartPosition();
			while(pos != 0)
			{
				CMuleCtrlItem* cur_item = NULL;
				void* pNull;
				m_ItemMgr.m_ListItems.GetNextAssoc(pos, cur_item, pNull);
				if (cur_item->IsSource() && cur_item->GetFile() == pFileEntry)
d1274 1
a1274 1
						uint8 ds=cur_item->GetSource()->GetSource()->GetDownloadState();
d1276 1
a1276 1
							isCtrl	&& cur_item->GetSource()->GetSource()->GetRemoteQueueRank()>0 ||
d1282 1
a1282 1
					InsertItem(LVIF_PARAM,pNMIA->iItem+1,0,0,0,0,(LPARAM)cur_item);
d1309 1
a1309 1
		if (content->IsFile()) cFile = content->GetFile()->GetFile();
d1357 1
a1357 1
			const CUpDownClient* client = content->GetSource()->GetSource();
d1407 1
a1407 1
					selectedList.AddTail(((CMuleCtrlItem*)GetItemData(index))->GetFile()->GetFile());
d1413 1
a1413 1
			CPartFile* file = content->GetFile()->GetFile();
d1637 1
a1637 1
			CUpDownClient* client = content->GetSource()->GetSource();
d1644 1
a1644 1
					client->HandoverToAnotherFile(content->GetFile()->GetFile()); 
d1720 2
a1721 2
			CPartFile* file1 = item1->GetFile()->GetFile();
			CPartFile* file2 = item2->GetFile()->GetFile();
d1725 1
a1725 1
		comp = Compare(item1->GetFile()->GetFile(), item2->GetFile()->GetFile(),0);
d1738 1
a1738 1
		comp = Compare(item1->GetSource()->GetSource(), item2->GetSource()->GetSource(), lParamSort, sortMod);
d1746 1
a1746 1
void CDownloadListCtrl::HideSources(CPartFile* partfile) // Cax2 closefile bugfix
d1754 6
a1759 1
	for (int i = 0; i <GetItemCount(); )
d1762 1
a1762 1
		if(item->GetFile()->GetFile() == partfile && item->IsSource())
d1771 2
a1772 1
	if (m_ShowSrc)	{		//Cax2 check if we don't show sources anymore...
d1774 1
a1774 1
		for(int i = 0;i<GetItemCount();i++)
d1794 3
a1796 2
		POSITION pos = m_ItemMgr.m_ListFiles.GetStartPosition();
    while(pos != NULL) 
d1798 3
a1800 6
       CPartFile* key;
       CMuleFileEntry* delitem;
       m_ItemMgr.m_ListFiles.GetNextAssoc(pos, key, delitem);
       CPartFile* file = delitem->GetFile();
       if (!file->IsPartFile())
	       RemoveFile(file);
d2076 1
a2076 1
			CPartFile* file = content->GetFile()->GetFile();
d2088 1
a2088 1
			CUpDownClient* client = content->GetSource()->GetSource();
d2178 2
a2179 2
			&& ((CMuleCtrlItem*)GetItemData(i))->GetFile()->GetFile()->GetSourceCount() <= theApp.glob_prefs->GetMaxSourcePerFile()) 
			selectedList.AddTail(((CMuleCtrlItem*)GetItemData(i))->GetFile()->GetFile());
d2244 1
a2244 1
			const CPartFile* file = content->GetFile()->GetFile();
d2248 1
a2248 1
			const CUpDownClient* client = content->GetSource()->GetSource();
@


1.52
log
@clicking [+]/[-] expands/collapses the list-items
@
text
@d37 1
a37 2

CMuleCtrlItem::CMuleCtrlItem(CPartFile* pFile)
d39 2
a40 3
	m_nType = CTRLITEM_FILE;
	m_dwUpdated = NULL;
	m_pFile = pFile;
d43 1
a43 1
CMuleCtrlItem::CMuleCtrlItem(CUpDownClient* pSource, CPartFile* pFile, CMuleCtrlItem* pRealSource)
d45 2
a46 5
	m_nType = CTRLITEM_SOURCE;
	m_dwUpdated = NULL;
	m_pSource = pSource;
	m_pFile = pFile;
	m_pRealSource = pRealSource;
d49 1
a49 1
CMuleCtrlItem::CMuleCtrlItem(CUpDownClient* pSource)
d51 2
a52 3
	m_nType = CTRLITEM_SOURCEUNIQUE;
	m_pSource = pSource;
	m_pFile = NULL;
d55 1
a55 1
CMuleCtrlItem::~CMuleCtrlItem()
d57 2
a58 6
	m_Status.DeleteObject();
	if(IsRealSource())
	{
		for(int i = 0; i < m_Sources.GetCount(); i++)
			delete m_Sources[i];
	}
d61 1
a61 1
void CMuleCtrlItem::AddSource(CMuleCtrlItem* pSource)
d63 2
a64 4
	if(theApp.m_app_state == theApp.APP_STATE_SHUTINGDOWN)
		return;
	if(IsFile() || IsRealSource())
		m_Sources.Add(pSource);	// will destroy only in realsource destructor
d67 1
a67 1
void CMuleCtrlItem::RemoveSource(CMuleCtrlItem* pSource)
d69 2
a70 8
	for(int i = 0; i < m_Sources.GetCount(); i++)
		if(m_Sources[i] == pSource)
		{
			m_Sources.RemoveAt(i);
			break;
		}

	delete pSource;
d73 1
a73 1
void CMuleCtrlItem::SetCurrentFile(CPartFile* pFile)
d75 2
a76 4
	if(IsSource())
		m_pRealSource->SetCurrentFile(pFile);
	else if(IsRealSource())
		m_pFile = pFile;
d79 1
a79 1
bool CMuleCtrlItem::IsInFileList(CPartFile* pFile)
d81 12
a92 8
	if(IsSource())
		return GetRealSource()->IsInFileList(pFile);

	for(int i = 0; i < m_Sources.GetCount(); i++)
		if(m_Sources[i]->m_pFile == pFile)
			return true;

	return false;
d95 1
a95 2

CMuleItemMgr::~CMuleItemMgr()
d97 17
a113 6
    POSITION pos = m_ListSources.GetStartPosition();
    while(pos != 0) {
        void* key;
        CMuleCtrlItem* value;
        m_ListSources.GetNextAssoc(pos, key, value);
	    delete value;
d115 14
a128 7
	m_ListSources.RemoveAll();
    pos = m_ListFiles.GetStartPosition();
    while(pos != 0) {
        void* key;
        CMuleCtrlItem* value;
        m_ListFiles.GetNextAssoc(pos, key, value);
	    delete value;
d130 2
a131 8
	m_ListFiles.RemoveAll();
}

CMuleCtrlItem* CMuleItemMgr::AddFile(CPartFile* pFile)
{
	CMuleCtrlItem* pItem = new CMuleCtrlItem(pFile);
	m_ListFiles.SetAt(pFile, pItem);
	return pItem;
d136 2
a137 1
	CMuleCtrlItem* pRealSource = NULL;
d139 1
a139 1
	if(!m_ListSources.Lookup(pSource, pRealSource))
d141 2
a142 2
		pRealSource = new CMuleCtrlItem(pSource);
		m_ListSources.SetAt(pSource, pRealSource);
d144 14
a157 3
	CMuleCtrlItem* pItem = new CMuleCtrlItem(pSource, pFile, pRealSource);
	pRealSource->AddSource(pItem);
	FindFile(pFile)->AddSource(pItem);
d161 1
a161 1
CMuleCtrlItem* CMuleItemMgr::FindFile(CPartFile *pFile)
d163 11
a173 3
	CMuleCtrlItem* pItem = NULL;
	m_ListFiles.Lookup(pFile, pItem);
	return pItem;
d176 1
a176 1
CMuleCtrlItem* CMuleItemMgr::FindRealSource(CUpDownClient* pSource)
d178 4
a181 3
	CMuleCtrlItem* pItem = NULL;
	m_ListSources.Lookup(pSource, pItem);
	return pItem;
d184 1
a184 1
void CMuleItemMgr::RemoveFile(CMuleCtrlItem* pFile)
d186 4
a189 2
	m_ListFiles.RemoveKey(pFile->GetFile());
	delete pFile;
d192 2
a193 1
void CMuleItemMgr::RemoveSource(CMuleCtrlItem* pSource)
d195 24
a218 8
	CMuleCtrlItem* pRealSource = pSource->GetRealSource();
	pRealSource->RemoveSource(pSource);
	FindFile(pSource->GetFile())->RemoveSource(pSource);
	if(pRealSource->GetSourceCount() == 0)
	{
		m_ListSources.RemoveKey(pRealSource->GetSource());
		delete pRealSource;
	}
d222 1
d411 1
a411 1
		pItem->SetCurrentFile(owner);
d418 1
a418 1
	find.lParam = (LPARAM)m_ItemMgr.FindFile(owner);
d432 2
a433 1
	CMuleCtrlItem* pRealSource = m_ItemMgr.FindRealSource(source);
d435 1
a435 1
	if(pRealSource && (pRealSource->IsInFileList(owner) || (!owner) ) )
d449 1
a449 1
			CMuleCtrlItem* pParent = m_ItemMgr.FindFile(owner);
d456 2
a457 2
				CMuleCtrlItem* pSource = (CMuleCtrlItem*)GetItemData(nItem);
				if(pSource->GetRealSource() == pRealSource)
d460 1
a460 1
					m_ItemMgr.RemoveSource(pSource);
d470 2
a471 2
				CMuleCtrlItem* pSource = (CMuleCtrlItem*)GetItemData(nItem);
				if(pSource->GetRealSource() == pRealSource)
d474 1
a474 1
					m_ItemMgr.RemoveSource(pSource);
d487 1
a487 1
	CMuleCtrlItem* pFile = m_ItemMgr.FindFile(toremove);
d500 1
a500 1
		find.lParam = (LPARAM)pFile;
a503 1
		m_ItemMgr.RemoveFile(pFile);
d507 2
a508 2
		CMuleCtrlItem* pChild = (CMuleCtrlItem*)GetItemData(i);
		if(pChild->IsSource() && pChild->IsInFileList(toremove))
d511 1
a511 1
			m_ItemMgr.RemoveSource(pChild);
d516 2
d525 2
a526 7
	CMuleCtrlItem* pSearch = m_ItemMgr.FindFile((CPartFile*)toupdate);
	if(!pSearch)
		pSearch = m_ItemMgr.FindRealSource((CUpDownClient*)toupdate);
    if(!pSearch)
		return;

	if(pSearch->IsFile())
d530 1
a530 1
		find.lParam = (LPARAM)pSearch;
d534 1
a534 1
			pSearch->m_dwUpdated = 0;
d539 2
d542 3
a544 1
	else if(pSearch->IsRealSource())
d546 2
a547 1
		for(int i = 0; i < pSearch->GetSourceCount(); i++)
d549 2
a550 2
			CMuleCtrlItem* pItem = pSearch->GetSource(i);
			if(pItem)
d552 3
a554 10
				LVFINDINFO find;
				find.flags = LVFI_PARAM;
				find.lParam = (LPARAM)pItem;
				sint16 result = FindItem(&find);
				if (result != -1)
				{
					pItem->m_dwUpdated = 0;
					Update(result);
					RedrawItems(result,result);
				}
d575 1
a575 1
		CPartFile *lpPartFile = lpCtrlItem->GetFile();
d771 1
a771 1
	CUpDownClient *lpUpDownClient = lpCtrlItem->GetSource();
d1190 2
a1191 2
		BOOL isChild = !content->IsFile();
		BOOL isExpandable = !isChild && content->GetFile()->GetSourceCount() > 0;
d1284 1
a1284 1
		CPartFile* partfile = content->GetFile();
d1288 8
a1295 4
			for(int i = 0; i < content->GetSourceCount(); i++)
			{
				CMuleCtrlItem* cur_item = content->GetSource(i);
				if (cur_item->GetFile() == partfile)
d1301 1
a1301 1
						uint8 ds=cur_item->GetSource()->GetDownloadState();
d1303 1
a1303 1
							isCtrl	&& cur_item->GetSource()->GetRemoteQueueRank()>0 ||
d1336 1
a1336 1
		if (content->IsFile()) cFile = content->GetFile();
d1384 1
a1384 1
			const CUpDownClient* client = content->GetSource(); // Cax2 bugfix
d1434 1
a1434 1
					selectedList.AddTail(((CMuleCtrlItem*)GetItemData(index))->GetFile());
d1440 1
a1440 1
			CPartFile* file = content->GetFile();
d1664 1
a1664 1
			CUpDownClient* client = content->GetSource();
d1671 1
a1671 1
					client->HandoverToAnotherFile(content->GetFile()); 
d1747 2
a1748 2
			CPartFile* file1 = item1->GetFile();
			CPartFile* file2 = item2->GetFile();
d1752 1
a1752 1
		comp = Compare(item1->GetFile(), item2->GetFile(),0);
d1765 1
a1765 1
		comp = Compare(item1->GetSource(), item2->GetSource(), lParamSort, sortMod);
d1784 1
a1784 1
		if(item->GetFile() == partfile && item->IsSource())
d1818 2
a1819 2
       void* key;
       CMuleCtrlItem* delitem;
d1821 3
a1823 6
       if (delitem->IsFile())
	   {
	       CPartFile* file = delitem->GetFile();
	       if (!file->IsPartFile())
		       RemoveFile(file);
       }
d2099 1
a2099 1
			CPartFile* file = content->GetFile();
d2111 1
a2111 1
			CUpDownClient* client = content->GetSource();
d2201 2
a2202 2
		   && ((CMuleCtrlItem*)GetItemData(i))->GetFile()->GetSourceCount() <= theApp.glob_prefs->GetMaxSourcePerFile()) 
            		selectedList.AddTail(((CMuleCtrlItem*)GetItemData(i))->GetFile());
d2223 1
a2223 1
	POSITION pos = m_ItemMgr.m_ListSources.GetStartPosition();
d2227 3
a2229 3
		CMuleCtrlItem* pRealSource = NULL;
        m_ItemMgr.m_ListSources.GetNextAssoc(pos, key, pRealSource);
		for(int i = 0; i < pRealSource->GetSourceCount(); i++)
d2240 1
a2240 1

d2267 1
a2267 1
			const CPartFile* file = content->GetFile();	// Cax2 nullpointer fix
d2271 1
a2271 1
			const CUpDownClient* client = content->GetSource(); // Cax2 nullpointer fix
@


1.51
log
@Rewrite of listcontent - bugfix
@
text
@d2013 38
@


1.50
log
@Rewrite of listcontent
@
text
@d178 1
d422 1
a423 1
					DeleteItem(nItem);
d436 1
a437 1
					DeleteItem(nItem);
d474 1
a475 1
		   	DeleteItem(i);
@


1.49
log
@bugfixes:remembers opened/closed stats, 2GB sort everywhere. version updated
@
text
@d38 148
a212 12
	//for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos))
	//	delete listcontent.GetAt(pos);

    POSITION pos = listcontent.GetStartPosition();
    while(pos != 0) {
        void* key;
        CtrlItem_Struct* value;
        listcontent.GetNextAssoc(pos, key, value);
	    delete value;
    }
	listcontent.RemoveAll();

d361 1
a361 1
    CtrlItem_Struct* newitem = new CtrlItem_Struct;
d363 1
a363 7
    newitem->owner = 0;
    newitem->type = 1;
    newitem->value = toadd;
    newitem->parent = NULL;
	newitem->dwUpdated = false; 
	listcontent.SetAt(newitem->value, newitem);
    InsertItem(LVIF_PARAM,itemnr,0,0,0,0,(LPARAM)newitem);
d372 3
a374 17
    CtrlItem_Struct* newitem = new CtrlItem_Struct;
    newitem->owner = owner;
    newitem->type = (notavailable)? 3:2;
    newitem->value = source;
	newitem->dwUpdated = false; 
/*	//Lord KiRon dupe check...
	CtrlItem_Struct* item;
	if ( listcontent.Lookup(newitem->value,item) )
	{
		delete newitem;
		return;
	} */
	listcontent.SetAt(newitem->value, newitem);

    CtrlItem_Struct* search	=	NULL;
    listcontent.Lookup(owner, search);
    newitem->parent = search;
d381 5
a385 5
    find.lParam = (LPARAM)search;
    uint16 itemnr = FindItem(&find);
    while (GetItemCount() > itemnr+1 && ((CtrlItem_Struct*)GetItemData(itemnr+1))->type != 1)
            itemnr++;
    InsertItem(LVIF_PARAM,itemnr+1,0,0,0,0,(LPARAM)newitem);
d395 1
a395 2
	CtrlItem_Struct* delitem;
    BOOL found = listcontent.Lookup(source, delitem);
d397 1
a397 1
	if(found && (delitem->owner == owner || (!owner) ) )
d407 35
a441 9
		LVFINDINFO find;
		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)delitem;
		sint16 result = FindItem(&find);
		if (result != (-1))
			DeleteItem(result);
		listcontent.RemoveKey(source);
		delitem->status.DeleteObject();
		delete delitem;
d449 2
a450 3
	CtrlItem_Struct* delitem;
    BOOL found = listcontent.Lookup(toremove, delitem);    
	if(found)
d462 1
a462 1
		find.lParam = (LPARAM)delitem;
d466 1
a466 3
		listcontent.RemoveKey(toremove);
		delitem->status.DeleteObject();
		delete delitem;
d468 1
a468 1
   	for(int i = 0; i < GetItemCount(); i++)
d470 2
a471 2
		delitem = (CtrlItem_Struct*) GetItemData(i);
	   	if(delitem->owner == delitem)
d473 1
a473 1
			delete delitem;
d476 2
d486 5
a490 1
	CtrlItem_Struct* search	=	NULL;
d492 2
a493 3
    BOOL found = listcontent.Lookup(toupdate, search);
    
    if(found) {
d496 1
a496 1
		find.lParam = (LPARAM)search;
d500 1
a500 1
			search->dwUpdated = 0;
d502 22
a523 4
			//Cax2: - Ok I'm an idiot...
			RedrawItems(result,result);	// Lord KiRon
            if(search->type == 1)
                theApp.sharedfiles->UpdateItem(((CKnownFile*)toupdate));
a524 1
		return;
d532 1
a532 1
void CDownloadListCtrl::DrawFileItem(CDC *dc, int nColumn, LPRECT lpRect, CtrlItem_Struct *lpCtrlItem) 
d535 4
d543 1
a543 1
		CPartFile *lpPartFile = (CPartFile*)lpCtrlItem->value;
d608 2
a609 2
					if (lpCtrlItem->status == (HBITMAP)NULL)
						VERIFY(lpCtrlItem->status.CreateBitmap(1, 1, 1, 8, NULL)); 
d613 1
a613 1
					int cx = lpCtrlItem->status.GetBitmapDimension().cx; 
d615 1
a615 1
					if(lpCtrlItem->dwUpdated + DLC_BARUPDATE < dwTicks || cx !=  iWidth || !lpCtrlItem->dwUpdated)
d617 4
a620 4
						lpCtrlItem->status.DeleteObject(); 
						lpCtrlItem->status.CreateCompatibleBitmap(dc,  iWidth, iHeight); 
						lpCtrlItem->status.SetBitmapDimension(iWidth,  iHeight); 
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->status); 
d629 1
a629 1
						lpCtrlItem->dwUpdated = dwTicks + (rand() % 128); 
d631 1
a631 1
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->status); 
d731 1
a731 1
void CDownloadListCtrl::DrawSourceItem(CDC *dc, int nColumn, LPRECT lpRect, CtrlItem_Struct *lpCtrlItem) 
d735 2
a736 2
		CString buffer;
		CUpDownClient *lpUpDownClient = (CUpDownClient*)lpCtrlItem->value;
d738 2
a739 3
		// Lord KiRon - just make compiler happy :)
 		POINT point;
 		CString status;
d741 18
a758 12
		switch(nColumn)
		{
			case 0:  	// icon, name
				// Lord Kiron
  				{
					RECT cur_rec;
					memcpy(&cur_rec, lpRect, sizeof(RECT));
					cur_rec.left += 18;
					point.x = cur_rec.left;
					point.y = cur_rec.top+1;
   					status = _T(""); 
   					if (lpCtrlItem->type == 2)
d760 36
a795 38
						switch (lpUpDownClient->GetDownloadState())
						{
							case DS_CONNECTING:
								imagelist.Draw(dc, 10, point, ILD_NORMAL);
								break;
							case DS_CONNECTED:
								imagelist.Draw(dc, 10, point, ILD_NORMAL);
								break;
							case DS_WAITCALLBACK:
								imagelist.Draw(dc, 10, point, ILD_NORMAL);
								break;
							case DS_ONQUEUE:
								imagelist.Draw(dc, 9, point, ILD_NORMAL);
								break;
							case DS_DOWNLOADING:
								imagelist.Draw(dc, 8, point, ILD_NORMAL);
								break;
							case DS_REQHASHSET:
								imagelist.Draw(dc, 8, point, ILD_NORMAL);
								break;
							case DS_NONEEDEDPARTS:
								imagelist.Draw(dc, 11, point, ILD_NORMAL);
								break;
							case DS_LOWTOLOWIP:
								imagelist.Draw(dc, 11, point, ILD_NORMAL);
								break;
							case DS_TOOMANYCONNS:
								imagelist.Draw(dc, 10, point, ILD_NORMAL);
								break;
							default:
								imagelist.Draw(dc, 12, point, ILD_NORMAL);
						}
					} else {
               					imagelist.Draw(dc, 11, point, ILD_NORMAL); 
						status = _T("(") + GetResString(IDS_ASKED4ANOTHERFILE) + _T(")"); 
  					}
		
					cur_rec.left += 20;
d797 1
a797 1
                    POINT point2= {cur_rec.left,cur_rec.top+1};
d799 29
a827 29
                    if(lpUpDownClient->GetClientSoft() == SO_EDONKEYHYBRID) {
                        imagelist.Draw(dc, 3, point2, ILD_NORMAL);
                        if (lpUpDownClient->IsFriend())
                            imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                        else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
                            imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
                    }
		            else if (lpUpDownClient->GetClientSoft() == SO_MLDONKEY) {
                        imagelist.Draw(dc, 2, point2, ILD_NORMAL);
                        if (lpUpDownClient->IsFriend())
                            imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                        else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
                            imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
		            }
		            else if (lpUpDownClient->GetClientSoft()==SO_EMULE || lpUpDownClient->GetClientSoft()==SO_OLDEMULE) {
                        imagelist.Draw(dc, 1, point2, ILD_NORMAL);
                        if (lpUpDownClient->IsFriend())
                            imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                        else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
                            imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
                    }
				    else {
                        imagelist.Draw(dc, 0, point2, ILD_NORMAL);
                        if (lpUpDownClient->IsFriend())
                            imagelist.Draw(dc, 5, point2, ILD_TRANSPARENT);
                        else if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
                            imagelist.Draw(dc, 4, point2, ILD_TRANSPARENT);
					}
					cur_rec.left += 20;
d829 15
a843 15
                    //if(lpUpDownClient->GetClientSoft()==SO_EMULE && lpUpDownClient->GetMuleVersion()==0x26) {
                    //	imagelist.Draw(dc, 7, point2, ILD_TRANSPARENT);
                    //}
					
					char* buffer1;
					if (!lpUpDownClient->GetUserName())
					{
						buffer1 = new char[50];
						sprintf(buffer1,"?  (%s)",GetResString(IDS_UNKNOWN));
					} else {
						buffer1 = new char[strlen(lpUpDownClient->GetUserName())+50+strlen(status)];
						sprintf(buffer1,"%s %s",lpUpDownClient->GetUserName(),status);
					}
					dc->DrawText(buffer1,(int)strlen(buffer1),&cur_rec, DLC_DT_TEXT);
					delete[] buffer1;
d845 55
a899 4
				break;
				// Lord KiRon - end
			case 1:		// size
				break;
d901 3
a903 4
			case 2:		// transfered
				if (lpCtrlItem->type == 2 && lpUpDownClient->GetTransferedDown())
				{
					buffer = CastItoXBytes(lpUpDownClient->GetTransferedDown());
d905 2
a906 3
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
				}
				break;
d908 4
a911 10
			case 3:		// speed
				if (lpCtrlItem->type == 2 && lpUpDownClient->GetDownloadDatarate())
				{
					if (lpUpDownClient->GetDownloadDatarate()==0)
						buffer="";
					else
						buffer.Format("%.1f %s", lpUpDownClient->GetDownloadDatarate()/1024.0f,GetResString(IDS_KBYTESEC));
					dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);
				}
				break;
d913 5
a917 1
			case 4:		// file info
d919 11
a929 35
					lpRect->bottom--; 
					lpRect->top++; 
	
					int iWidth = lpRect->right - lpRect->left; 
					int iHeight = lpRect->bottom - lpRect->top; 
					if (lpCtrlItem->status == (HBITMAP)NULL)
						VERIFY(lpCtrlItem->status.CreateBitmap(1, 1, 1, 8, NULL)); 
					CDC cdcStatus; 
					HGDIOBJ hOldBitmap;
					cdcStatus.CreateCompatibleDC(dc); 
					int cx = lpCtrlItem->status.GetBitmapDimension().cx; 
					DWORD dwTicks = GetTickCount(); 
					if(lpCtrlItem->dwUpdated + DLC_BARUPDATE < dwTicks || cx !=  iWidth  || !lpCtrlItem->dwUpdated)
					{ 
						lpCtrlItem->status.DeleteObject(); 
						lpCtrlItem->status.CreateCompatibleBitmap(dc,  iWidth, iHeight); 
						lpCtrlItem->status.SetBitmapDimension(iWidth,  iHeight); 
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->status); 
	
						RECT rec_status; 
						rec_status.left = 0; 
						rec_status.top = 0; 
						rec_status.bottom = iHeight; 
						rec_status.right = iWidth; 
						lpUpDownClient->DrawStatusBar(&cdcStatus,  &rec_status,(lpCtrlItem->type == 3), theApp.glob_prefs->UseFlatBar()); 
	
						lpCtrlItem->dwUpdated = dwTicks + (rand() % 128); 
					} else 
						hOldBitmap = cdcStatus.SelectObject(lpCtrlItem->status); 
	
					dc->BitBlt(lpRect->left, lpRect->top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
					cdcStatus.SelectObject(hOldBitmap);
	
					lpRect->bottom++; 
					lpRect->top--; 
d931 4
a934 1
				break;
d936 11
a946 19
		case 5:		// sources
			 {
				 // [Lord KiRon]
				 // display client version
				 switch(lpUpDownClient->GetClientSoft())
				 {
				 case SO_EMULE:
				 case SO_OLDEMULE:
				 case SO_CDONKEY:
					 buffer.Format("%s v%s",GetClientNameString(lpUpDownClient->GetClientSoft()),GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetMuleVersion()));
					 break;
				 case SO_UNKNOWN:
					 buffer.Format("???");
					 break;
				 default:
					 buffer.Format("%s v%s",GetClientNameString(lpUpDownClient->GetClientSoft()),GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetVersion()));
					 break;
				 }
				// [/Lord KiRon]
a947 1
				break;
d949 2
a950 7

			case 6:		// prio
			if ((lpUpDownClient->IsEmuleClient() ||  lpUpDownClient->GetRemoteQueueRank())&&		//now emule v ? display the QR too!
				lpUpDownClient->GetDownloadState()==DS_ONQUEUE)
			{
				if( lpUpDownClient->IsRemoteQueueFull() ){
					buffer=GetResString(IDS_QUEUEFULL);
d953 3
a955 3
				else{
					if ( lpUpDownClient->GetRemoteQueueRank()){
					buffer.Format("QR: %u",lpUpDownClient->GetRemoteQueueRank());
d957 17
a973 6
				}
					else{
						buffer="";
						dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
					}
				}
d975 2
a976 2
						buffer="";
						dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT);
d978 19
a996 39
				break;

			case 7:		// status
				// Lord KiRon
				RECT cur_rec;
				memcpy(&cur_rec, lpRect, sizeof(RECT));
				cur_rec.left += 6;
				point.x = cur_rec.left;
				point.y = cur_rec.top+1;

				status = lpUpDownClient->GetDownloadStateAsString();
				char* buffer1;
				if (!lpUpDownClient->GetUserName())
				{
					buffer1 = new char[strlen(status)+1];
					sprintf(buffer1,"%s",status);
				} else {
					buffer1 = new char[strlen(status)+1];
					sprintf(buffer1,"%s",status);
				}
				dc->DrawText(buffer1,(int)strlen(buffer1),&cur_rec, DLC_DT_TEXT);
				delete[] buffer1; 
				// Lord KiRon - end
				
			case 8:		// remaining time & size
				break;
			case 9: // UL/DL Ratio Maverick
				if (lpUpDownClient->IsRemoteInfoAvaiable() || lpUpDownClient->credits)
					buffer.Format("%0.1f",lpUpDownClient->GetRemoteBaseModifier());
				else buffer="";
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
				break;
			case 10: // Ratio total Maverick
				if (lpUpDownClient->IsRemoteInfoAvaiable() || lpUpDownClient->credits)
					buffer.Format("%ld",lpUpDownClient->GetRemoteRatio());
				else buffer="";
				dc->DrawText(buffer,buffer.GetLength(),lpRect, DLC_DT_TEXT | DT_RIGHT);	
				break;
		}
d1010 1
a1010 1
	CtrlItem_Struct* content = (CtrlItem_Struct*)lpDrawItemStruct->itemData;
d1013 1
a1013 1
	if ((content->type == 1) && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d1042 1
a1042 1
	if (content->type == 1)
d1069 1
a1069 1
	else if (content->type == 3 || content->type == 2)
d1099 1
a1099 1
		(lpDrawItemStruct->itemState & ODS_SELECTED) && (content->type == 1))
d1114 2
a1115 2
			CtrlItem_Struct* prev = (CtrlItem_Struct*)this->GetItemData(lpDrawItemStruct->itemID - 1);
			if(prev->type == 1)
d1121 2
a1122 2
			CtrlItem_Struct* next = (CtrlItem_Struct*)this->GetItemData(lpDrawItemStruct->itemID + 1);
			if(next->type == 1)
d1156 4
a1159 4
			((CtrlItem_Struct*)this->GetItemData(lpDrawItemStruct->itemID + 1))->type != 1;
		BOOL isOpenRoot = hasNext && content->type == 1;
		BOOL isChild = content->type != 1;
		BOOL isExpandable = !isChild && ((CPartFile*)content->value)->GetSourceCount() > 0;
d1237 1
a1237 1
	CtrlItem_Struct* content = (CtrlItem_Struct*)this->GetItemData(pNMIA->iItem);
d1246 1
a1246 1
	if (content->type == 1)
d1252 1
a1252 1
		CPartFile* partfile = (CPartFile*)content->value;
d1256 1
a1256 5

			CtrlItem_Struct* cur_item; //resource optimization
            POSITION pos = listcontent.GetStartPosition();

			while(pos != NULL)
d1258 2
a1259 3
                void* key;
                listcontent.GetNextAssoc(pos, key, cur_item);
				if (cur_item->owner == partfile)
d1265 1
a1265 1
						uint8 ds=((CUpDownClient*)cur_item->value)->GetDownloadState();
d1267 1
a1267 1
							isCtrl	&& ((CUpDownClient*)cur_item->value)->GetRemoteQueueRank()>0 ||
d1298 1
a1298 1
		CtrlItem_Struct* content = (CtrlItem_Struct*)this->GetItemData(GetSelectionMark());
d1300 1
a1300 1
		if (content->type == 1) cFile = (CPartFile*)content->value;
d1348 1
a1348 1
			const CUpDownClient* client = (CUpDownClient*)content->value; // Cax2 bugfix
d1359 1
a1359 1
			if(content->type == 3)
d1385 1
a1385 1
		CtrlItem_Struct* content = (CtrlItem_Struct*)this->GetItemData(GetSelectionMark());
d1397 2
a1398 2
				if (((CtrlItem_Struct*)this->GetItemData(index))->type == 1)
					selectedList.AddTail((CPartFile*)((CtrlItem_Struct*)this->GetItemData(index))->value);
d1402 1
a1402 1
		if (content->type == 1)
d1404 1
a1404 1
			CPartFile* file = (CPartFile*)content->value;
d1628 1
a1628 1
			CUpDownClient* client = (CUpDownClient*)content->value;
d1635 1
a1635 1
					client->HandoverToAnotherFile((CPartFile*)content->owner); 
d1687 2
a1688 2
	CtrlItem_Struct* item1 = (CtrlItem_Struct*)lParam1;
	CtrlItem_Struct* item2 = (CtrlItem_Struct*)lParam2;
d1704 1
a1704 1
	if ((item1->type == 1 && item2->type != 1)||(item2->type == 1 && item1->type != 1)){ // files vs source?
d1706 1
a1706 1
	} else if (item1->type == 1) { //both files? (!)
d1711 2
a1712 2
			CPartFile* file1 = (CPartFile*)item1->value;
			CPartFile* file2 = (CPartFile*)item2->value;
d1715 18
a1732 8
    	} else { //both sources...
		comp = Compare((CPartFile*)(item1->parent->value), (CPartFile*)(item2->parent->value),0); // Cax2 bugfix
        	if(comp != 0) return 0;
        	if (item1->type != item2->type && lParamSort!=0) //Cax2:a4af clients kept separate, unless sorting for name
				return (lParamSort==5)?item2->type - item1->type:item1->type - item2->type; //always at the end, unless sort by source - then a4af always at the top
		comp = Compare((CUpDownClient*)item1->value,(CUpDownClient*) item2->value, lParamSort, sortMod); //Cax2: previous 'fix' ineffective, using emule_try instead
    	} 
    	return sortMod * comp;
d1744 2
a1745 2
	CtrlItem_Struct* item; 
	for (int i = 0; i <GetItemCount(); i++)		//[Barry]
d1747 2
a1748 2
		item = (CtrlItem_Struct*)GetItemData(i); 
		if(item->owner==partfile)
d1750 6
a1755 4
			item->dwUpdated = 0; 
			item->status.DeleteObject(); 
			DeleteItem(i--);
			} 
d1760 1
a1760 1
			if (((CtrlItem_Struct*)GetItemData(i))->type != 1) 
d1779 1
a1779 1
    POSITION pos = listcontent.GetStartPosition();
d1783 5
a1787 4
       CtrlItem_Struct* delitem;
       listcontent.GetNextAssoc(pos, key, delitem);
       if (delitem->type == 1){
	       CPartFile* file = (CPartFile*)delitem->value;
d1938 10
a1947 3
				if  (!client1->GetUserName()||!client2->GetUserName())
					return (!client1->GetUserName())?((!client2->GetUserName())?0:1):-1;
				return strcmpi(client1->GetUserName(),client2->GetUserName());
d2024 1
a2024 1
		CtrlItem_Struct* content = (CtrlItem_Struct*)this->GetItemData(GetSelectionMark());
d2026 1
a2026 1
		if (content->type == 1)		//Cax2: doubleclick opens completed files
d2028 1
a2028 1
			CPartFile* file=(CPartFile*)content->value;
d2040 1
a2040 1
			CUpDownClient* client = (CUpDownClient*)content->value;
d2129 3
a2131 3
		if(((CtrlItem_Struct*)GetItemData(i))->type == 1 
		   && (((CPartFile*)( (CtrlItem_Struct*)GetItemData(i))->value))->GetSourceCount() <= theApp.glob_prefs->GetMaxSourcePerFile()) 
            		selectedList.AddTail(((CPartFile*)((CtrlItem_Struct*)GetItemData(i))->value));
d2152 2
a2153 3
/*
	POSITION pos1, pos2 = NULL;
	for (pos1 = listcontent.GetHeadPosition(); (pos2 = pos1) != NULL;) 
d2155 4
a2158 4
		listcontent.GetNext(pos1);
		if(pos2 == NULL)
			continue;
		if(listcontent.GetAt(pos2) != NULL)
d2160 2
a2161 1
			if (((CtrlItem_Struct*)listcontent.GetAt(pos2))->type == 3 && ((CtrlItem_Struct*)listcontent.GetAt(pos2))->owner == file)
d2163 1
a2163 1
				CUpDownClient* cur_src = (CUpDownClient*)((CtrlItem_Struct*)listcontent.GetAt(pos2))->value;
a2167 15
	}
*/

    POSITION pos = listcontent.GetStartPosition();
    while(pos != 0) 
	{
        void* key;
        CtrlItem_Struct* item;
        listcontent.GetNextAssoc(pos, key, item);
			if (item->type == 3 && item->owner == file)
			{
				CUpDownClient* cur_src = (CUpDownClient*)item->value;
				if(cur_src)
					cur_src->HandoverToAnotherFile(file);
			}
d2193 2
a2194 2
		CtrlItem_Struct* content = (CtrlItem_Struct*)this->GetItemData(GetSelectionMark());
		if(content->type == 1)
d2196 1
a2196 1
			const CPartFile* file = (CPartFile*)content->value;	// Cax2 nullpointer fix
d2200 1
a2200 1
			const CUpDownClient* client = (CUpDownClient*)content->value; // Cax2 nullpointer fix
d2210 2
d2232 1
a2232 1
	return out;
@


1.48
log
@bugfixes: sort in search window, unknown % in stats, dowload speed at startup updated search layout
@
text
@d1708 1
a1708 1
			return file1->GetFileSize() - file2->GetFileSize();
d1726 18
a1743 16

			int time1=file1->GetTimeRemaining();
			int time2=file2->GetTimeRemaining();
			if (time1>0&&time2>0) 
				return time1-time2 ;
			if (time1>0||time2>0)
				return time2-time1; 
			//if no remaining time sort by remaining size asc. Leave completed files last...
			if ((file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE) && 
			    (file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE))
				return 0;
			if (file2->GetStatus()==PS_COMPLETING || file2->GetStatus()==PS_COMPLETE)
				return -1;
			if (file1->GetStatus()==PS_COMPLETING || file1->GetStatus()==PS_COMPLETE)
				return 1;
			return (file1->GetFileSize()-file1->GetCompletedSize())-(file2->GetFileSize()-file2->GetCompletedSize()); 
@


1.47
log
@minor updates & bugfixes
@
text
@d247 1
a247 1

d253 1
a253 1
	}
@


1.46
log
@minor graphic improvements. search bugfix
@
text
@d1724 9
a1732 5
		case 8: //Remaining Time asc 
			if (file1->GetTimeRemaining()>0&&file2->GetTimeRemaining()>0) 
			return file1->GetTimeRemaining()-file2->GetTimeRemaining() ;
			if (file1->GetTimeRemaining()>0||file2->GetTimeRemaining()>0) 
				return file2->GetTimeRemaining()-file1->GetTimeRemaining(); 
d1742 1
@


1.45
log
@Removed messages from ed2k link generation.
@
text
@d1079 2
d1086 1
a1115 11
			//newsort START added by Cax2 03/11/02 
			m_ShowSrc=false; 
			//more srces showing? need to keep the file lines from moving... 
			for(int i = 0;i<GetItemCount();i++) //newsort 
				if (((CtrlItem_Struct*)GetItemData(i))->type != 1) 
				{
					m_ShowSrc=true;
					break;
				}
			if (!m_ShowSrc && m_lastSort<0)
				m_lastSort+=10000;	// restore the sort to what it was...
d1580 15
@


1.44
log
@Removed .26 icon modification (debug purpose not needed anymore)
@
text
@d1353 1
a1353 1
						AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
d1365 1
a1365 1
						AfxMessageBox(GetResString(IDS_COPIED2CB) + str);
@


1.43
log
@Corrected credits client icon shown (wrong parameter used when completed the icon change).
@
text
@d662 3
a664 3
                    if(lpUpDownClient->GetClientSoft()==SO_EMULE && lpUpDownClient->GetMuleVersion()==0x26) {
                        imagelist.Draw(dc, 7, point2, ILD_TRANSPARENT);
                    }
@


1.42
log
@Updated to b1 (beta 1 to be released tonight) & movie preview simplified.
Set to RELEASE mode to disable crashes (is this good for beta 1?)
@
text
@d636 1
a636 1
                        else if (lpUpDownClient->credits->GetScoreRatio() > 1)
d643 1
a643 1
                        else if (lpUpDownClient->credits->GetScoreRatio() > 1)
d650 1
a650 1
                        else if (lpUpDownClient->credits->GetScoreRatio() > 1)
d657 1
a657 1
                        else if (lpUpDownClient->credits->GetScoreRatio() > 1)
@


1.41
log
@Updated ListCtrls to new icon management to be more tidy and practical. Hope didn't broke anything.
@
text
@a1176 2

			// DonGato - Movie Preview Mode
d1179 9
a1187 26
				m_FileMenu.EnableMenuItem((UINT_PTR)m_MovieMenu.m_hMenu, MF_ENABLED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_NO, true? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_NO, (file->GetMovieMode() == 0)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_AVI, file->IsAviMovie()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_AVI, (file->GetMovieMode() == 1)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_LAVI, file->IsAviMovie()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_LAVI, (file->GetMovieMode() == 2)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_L2AVI, file->IsAviMovie()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_L2AVI, (file->GetMovieMode() == 3)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_MPG, file->IsMpgMovie()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_MPG, (file->GetMovieMode() == 4)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_LMPG, file->IsMpgMovie()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_LMPG, (file->GetMovieMode() == 5)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_L2MPG, file->IsMpgMovie()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_L2MPG, (file->GetMovieMode() == 6)? MF_CHECKED:MF_UNCHECKED);
				m_MovieMenu.EnableMenuItem(MP_MOVIE_STANDARD, file->IsMovie()||file->IsArchive()? MF_ENABLED:MF_GRAYED);
				m_MovieMenu.CheckMenuItem(MP_MOVIE_STANDARD, (file->GetMovieMode() == 7)? MF_CHECKED:MF_UNCHECKED);
			} else {
				m_FileMenu.EnableMenuItem((UINT_PTR)m_MovieMenu.m_hMenu, MF_GRAYED);
			}
			// DonGato - Moview Preview Mode end

			m_PrioMenu.CheckMenuItem(MP_PRIOAUTO, (justOne && file->IsAutoPrioritized())? MF_CHECKED:MF_UNCHECKED); // Tarod
			m_PrioMenu.CheckMenuItem(MP_PRIOHIGH,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_HIGH)? MF_CHECKED:MF_UNCHECKED); // Tarod
			m_PrioMenu.CheckMenuItem(MP_PRIONORMAL,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_NORMAL)? MF_CHECKED:MF_UNCHECKED); // Tarod
			m_PrioMenu.CheckMenuItem(MP_PRIOLOW,(justOne && !file->IsAutoPrioritized() && file->GetPriority() == PR_LOW)? MF_CHECKED:MF_UNCHECKED); // Tarod
d1443 24
a1466 31
				case MP_MOVIE_NO:
					file->SetMovieMode(0);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_AVI:
					file->SetMovieMode(1);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_LAVI:
					file->SetMovieMode(2);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_L2AVI:
					file->SetMovieMode(3);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_MPG:
					file->SetMovieMode(4);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_LMPG:
					file->SetMovieMode(5);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_L2MPG:
					file->SetMovieMode(6);
					file->SaveMovieMode();
					break;
				case MP_MOVIE_STANDARD:
					file->SetMovieMode(7);
					file->SaveMovieMode();
a1862 1
	if (m_MovieMenu) m_MovieMenu.DestroyMenu();
a1870 11
	// DonGato
	m_MovieMenu.CreateMenu();
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_NO, GetResString(IDS_MOVIE_NO)); // obaldin - moved into main menu
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_AVI, GetResString(IDS_MOVIE_AVI));
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_LAVI, GetResString(IDS_MOVIE_LAVI));
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_L2AVI, GetResString(IDS_MOVIE_L2AVI));
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_MPG, GetResString(IDS_MOVIE_MPG));
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_LMPG, GetResString(IDS_MOVIE_LMPG));
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_L2MPG, GetResString(IDS_MOVIE_L2MPG));
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_STANDARD, GetResString(IDS_MOVIE_STANDARD));

a1881 1
	m_FileMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_MovieMenu.m_hMenu, GetResString(IDS_MOVIE_MENU));
d1883 1
@


1.40
log
@menu rearrangements
@
text
@d110 20
a129 31
	m_ImageList.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	m_ImageList.SetBkColor(CLR_NONE);
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS1),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS2),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS3),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS4),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_DCS5),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTMINUS),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTNONE),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LISTPLUS),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_TAROD),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIENDCOMPROT),16,16));
	// By Maverick
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEYFRIEND),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_PLUS),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_PLUSCOMPROT),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEYPLUS),16,16));
	m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_TARODPLUS),16,16)); // Added by Tarod
	// END Maverick

    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  // 19
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));         // 20
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));         // 21
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         // 22

	m_ImageList.Add(theApp.LoadIcon(IDI_RATING));   //23
	m_ImageList.Add(theApp.LoadIcon(IDI_RATINGBAD));
d385 2
a386 2
					int iIcon = lpPartFile->GetSourceCount() > 0 ? (lpPartFile->srcarevisible ? 6 : 8) : 7;
					m_ImageList.Draw(dc, iIcon, ipoint, ILD_NORMAL);
d390 2
a391 2
				        int image=23;
				        if (lpPartFile->HasRating()) if (lpPartFile->HasBadRating()) image=24;
d394 1
a394 1
				        m_ImageList.Draw(dc, image, point, ILD_NORMAL);
d594 1
a594 1
								m_ImageList.Draw(dc, 2, point, ILD_NORMAL);
d597 1
a597 1
								m_ImageList.Draw(dc, 2, point, ILD_NORMAL);
d600 1
a600 1
								m_ImageList.Draw(dc, 2, point, ILD_NORMAL);
d603 1
a603 1
								m_ImageList.Draw(dc, 1, point, ILD_NORMAL);
d606 1
a606 1
								m_ImageList.Draw(dc, 0, point, ILD_NORMAL);
d609 1
a609 1
								m_ImageList.Draw(dc, 0, point, ILD_NORMAL);
d612 1
a612 1
								m_ImageList.Draw(dc, 3, point, ILD_NORMAL);
d615 1
a615 1
								m_ImageList.Draw(dc, 3, point, ILD_NORMAL);
d618 1
a618 1
								m_ImageList.Draw(dc, 2, point, ILD_NORMAL);
d621 1
a621 1
								m_ImageList.Draw(dc, 4, point, ILD_NORMAL);
d624 1
a624 1
               					m_ImageList.Draw(dc, 3, point, ILD_NORMAL); 
d631 1
d633 5
a637 5
                             m_ImageList.Draw(dc, 19, point2, ILD_NORMAL);
                             if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
                                m_ImageList.Draw(dc, 20, point2, ILD_NORMAL);
                             if (lpUpDownClient->IsFriend())
                                m_ImageList.Draw(dc, 21, point2, ILD_NORMAL);
d639 20
a658 31
                    else
                    // Maverick Rework of icon selection
					if (lpUpDownClient->IsFriend())
                    {
                        if (lpUpDownClient->ExtProtocolAvailable())
                        {
                            m_ImageList.Draw(dc, 12, point2, ILD_NORMAL);
                        }
                        else if(lpUpDownClient->GetClientSoft() == SO_MLDONKEY)
                        {
                            m_ImageList.Draw(dc, 14, point2, ILD_NORMAL);
                        }
                        else 
						{
							m_ImageList.Draw(dc, 11, point2, ILD_NORMAL);
						}
					} else 
					if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
					{
						if (lpUpDownClient->ExtProtocolAvailable())
                         {
                             if (lpUpDownClient->TarodVersion()) {
                                 m_ImageList.Draw(dc, 18, point2, ILD_NORMAL);
                             } else {
                                 m_ImageList.Draw(dc, 16, point2, ILD_NORMAL);
                             }
                         } else if (lpUpDownClient->GetClientSoft() == SO_MLDONKEY)
						 {
                             m_ImageList.Draw(dc, 17, point2, ILD_NORMAL);
						 } else {
                             m_ImageList.Draw(dc, 15, point2, ILD_NORMAL);
d660 4
a663 19
					} else {
						if (lpUpDownClient->ExtProtocolAvailable())
						{
							if (lpUpDownClient->TarodVersion()) {
								m_ImageList.Draw(dc, 9, point2, ILD_NORMAL);
							} else {
								m_ImageList.Draw(dc, 5, point2, ILD_NORMAL);
							}
						} else if (lpUpDownClient->GetClientSoft() == SO_MLDONKEY)
						{
                             m_ImageList.Draw(dc, 13, point2, ILD_NORMAL);
						} else {
							m_ImageList.Draw(dc, 10, point2, ILD_NORMAL);
						}
                    }
                    // END Maverick
					
                    if((lpUpDownClient->GetClientSoft()==SO_EMULE) && (lpUpDownClient->GetMuleVersion()==0x26)) {
                        m_ImageList.Draw(dc, 22, point2, ILD_NORMAL);
a664 1
					cur_rec.left += 20;
@


1.39
log
@restore changes that went missing in a cvs mixup
@
text
@a1213 8
			if(justOne) { // obaldin
				m_FileMenu.CheckMenuItem(MP_GET_PREVIEW_CHUNKS, file->GetPreviewChunksEnabled()? MF_CHECKED: MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_GET_PREVIEW_CHUNKS, MF_ENABLED);
			} else {
				m_FileMenu.CheckMenuItem(MP_GET_PREVIEW_CHUNKS, MF_UNCHECKED);
				m_FileMenu.EnableMenuItem(MP_GET_PREVIEW_CHUNKS, MF_GRAYED);
			}

d1216 1
a1216 1
			if(file->GetPreviewChunksEnabled() && justOne)
d1219 1
a1219 2
                /*
				m_MovieMenu.EnableMenuItem(MP_MOVIE_NO, file->IsMovie()? MF_ENABLED:MF_GRAYED);
a1220 1
                */
d1233 1
a1233 1
				m_MovieMenu.EnableMenuItem(MP_MOVIE_STANDARD, file->IsMovie()? MF_ENABLED:MF_GRAYED);
a1494 4
				case MP_GET_PREVIEW_CHUNKS: // obaldin
					file->SetPreviewChunksEnabled(!file->GetPreviewChunksEnabled()); 
					file->SaveMovieMode();
					break; 
d1937 1
a1937 1
	// m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_NO, GetResString(IDS_MOVIE_NO)); // obaldin - moved into main menu
a1956 1
	m_FileMenu.AppendMenu(MF_STRING,MP_GET_PREVIEW_CHUNKS, GetResString(IDS_GET_PREVIEW_CHUNKS)); // obaldin
@


1.38
log
@Memory leak fixed
@
text
@a318 10
/*
	POSITION pos1, pos2;
	CtrlItem_Struct* delitem;
	for(pos1 = listcontent.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		delitem = listcontent.GetNext(pos1);    
		if(delitem->value == toremove)
		{
*/
    // speedups by zz
d1389 1
d1396 1
d1455 1
d1481 2
a1482 1
				case MP_ALL_A4AF_TO_HERE: // Tarod
@


1.37
log
@Preparing for new SLS code
@
text
@d75 1
a76 7
	int nCount =	GetItemCount();

	// Delete all of the items from the list view control. [Lord KiRon]
	for (int i=0;i < nCount;i++)
	{
		DeleteItem(0);
	}
d259 6
d319 10
a1398 1
						selectedList.GetHead()->SavePartFile(); 
a1404 1
						HideSources(selectedList.GetHead());
a1462 1
#ifdef OLD_SLS_ENABLED
a1487 1
#endif //OLD_SLS_ENABLED
@


1.36
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d1455 1
d1481 1
@


1.35
log
@Memory leak fixed
@
text
@a318 10
/*
	POSITION pos1, pos2;
	CtrlItem_Struct* delitem;
	for(pos1 = listcontent.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		delitem = listcontent.GetNext(pos1);    
		if(delitem->value == toremove)
		{
*/
    // speedups by zz
d1389 1
d1396 1
@


1.34
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d76 7
@


1.33
log
@Added xrmb's SmartOpen
@
text
@d31 7
@


1.32
log
@not a good idea to call CSharedFilesCtrl::UpdateItem from every CDownloadListCtrl::DrawFileItem
@
text
@d1102 7
d1124 14
a1137 1
				if (cur_item->owner == partfile){
d1141 3
a1143 1
			partfile->srcarevisible = true;
@


1.31
log
@*** empty log message ***
@
text
@d368 2
d493 1
a493 1
					theApp.sharedfiles->UpdateItem(((CKnownFile*)lpPartFile));
@


1.30
log
@*** empty log message ***
@
text
@d1806 2
a1807 1
						if ((client2->GetMuleVersion()==0x2B  &&  client1->GetMuleVersion()==0x22)||(client1->GetMuleVersion()==0x2B  &&  client2->GetMuleVersion()==0x22))
d1809 2
a1810 1
						return ((client2->GetMuleVersion()==0x2B)?0x22:client2->GetMuleVersion()) - ((client1->GetMuleVersion()==0x2B)?0x22:client1->GetMuleVersion());
@


1.29
log
@*** empty log message ***
@
text
@d778 14
a791 15
				if ( lpUpDownClient->GetClientSoft() != SO_UNKNOWN )
				{
					if ( !lpUpDownClient->GetVersion() )
					{
						buffer.Format("%s v%s",GetClientNameString(lpUpDownClient->GetClientSoft()),GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetVersion()));
					}
					else
					{
						buffer.Format("%s v%s",GetClientNameString(lpUpDownClient->GetClientSoft()),GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetMuleVersion()));
					}
				}
				else
				{
					buffer.Format("???");
				}
@


1.28
log
@*** empty log message ***
@
text
@d776 3
a778 1
				switch(lpUpDownClient->GetClientSoft())
d780 8
a787 24
					case SO_EDONKEY:
						buffer.Format("eDonkey v%s", GetClientVersionString(SO_EDONKEY,lpUpDownClient->GetVersion()));
						break;
					case SO_EDONKEYHYBRID:
						buffer.Format("eDonkeyHybrid v%s", GetClientVersionString(SO_EDONKEYHYBRID,lpUpDownClient->GetVersion()));
						break;
					case SO_CDONKEY:
						buffer.Format("cDonkey v%s", GetClientVersionString(SO_CDONKEY,lpUpDownClient->GetMuleVersion()) );
						break;
					case SO_EMULE:
					case SO_OLDEMULE:{
						if ( lpUpDownClient->GetMuleVersion()>0)
							buffer.Format("eMule v%s", GetClientVersionString(lpUpDownClient->GetClientSoft(),lpUpDownClient->GetMuleVersion()));
						else 
							buffer="eMule v  ?";
						break;
									 }
					case SO_MLDONKEY:
						buffer=GetResString(IDS_OLDMLDONKEY);
						break;
					case SO_UNKNOWN:
						buffer=GetResString(IDS_UNKNOWN);
                    default:
						buffer= "???";
d789 5
@


1.27
log
@Statistics related changes
@
text
@d253 1
a253 1
    CtrlItem_Struct* search;
d353 1
a353 1
	CtrlItem_Struct* search;
@


1.26
log
@bugifxes & improvements
@
text
@d779 1
a779 1
						buffer.Format("eDonkey v%i", lpUpDownClient->GetVersion());
d782 1
a782 1
						buffer.Format("eDonkeyHybrid v%i", lpUpDownClient->GetVersion() - 1000);
d785 1
a785 1
						buffer.Format("cDonkey v%02X", lpUpDownClient->GetMuleVersion());
d790 1
a790 1
							buffer.Format("eMule v0.%02X", lpUpDownClient->GetMuleVersion());
@


1.25
log
@more 26b merges
@
text
@a433 4
				// Lord KiRon
            	//if (lpPartFile->GetTransferingSrcCount()==0) 
            	//if (lpPartFile->GetTransferingSrcCount()==0 || lpPartFile->GetStatus(true)==PS_COMPLETING || lpPartFile->GetStatus(true)==PS_COMPLETE || (lpPartFile->GetDatarate() / 1024.0f)==0 ) 
            	// Lord KiRon - end
d1721 1
a1721 1
	/*// Lord KiRon
d1732 2
a1733 2
	// Lord KiRon - end*/
	RedrawItems(pNMListView->iItem - notFirst, pNMListView->iItem + notLast);
@


1.24
log
@look changes+
@
text
@a234 2
	// speedups by zz
	//listcontent.AddTail(newitem);
a250 2
    // speedups by zz
	//listcontent.AddTail(newitem);
a252 7
    //CtrlItem_Struct* search = 0;
    //for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos)){
    //        if (listcontent.GetAt(pos)->value == owner){
    //                search = listcontent.GetAt(pos);
    //                break;
    //        }
    //}
a274 11
/*
	POSITION pos1, pos2;
	CtrlItem_Struct* delitem;	//Cax2: better here
	for(pos1 = listcontent.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		listcontent.GetNext(pos1);
		delitem = listcontent.GetAt(pos2);
		if(delitem->value == source && (delitem->owner == owner || (!owner)))
		{
*/
    // speedups by zz
a352 9
/*
	CtrlItem_Struct* search = 0;
	for (POSITION pos = listcontent.GetHeadPosition();pos !=  0;listcontent.GetNext(pos))
	{
		if (listcontent.GetAt(pos)->value == toupdate)
		{
			search = listcontent.GetAt(pos);
*/
	// speedups by zz
d357 1
a357 2
    if(found) 
	{
d789 1
a789 1
						buffer.Format("CDonkey v%i", lpUpDownClient->GetVersion());
a1122 6
/*
			for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos))
			{
				cur_item= (CtrlItem_Struct*)listcontent.GetAt(pos);
*/
// speedups by zz
a1653 14
/*
	POSITION pos1, pos2;
	for(pos1 = listcontent.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		listcontent.GetNext(pos1);
		CtrlItem_Struct* delitem = listcontent.GetAt(pos2);
		if (delitem->type == 1)
		{
			CPartFile* file = (CPartFile*)delitem->value;
			if(!file->IsPartFile())
				RemoveFile(file);
		}
	}
*/
a2095 22
/*
	CString out="";
	CString temp,temp2;

	POSITION pos1, pos2;
	for( pos1 = listcontent.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		listcontent.GetNext(pos1);
		CtrlItem_Struct* delitem = listcontent.GetAt(pos2);
		if (delitem->type == 1){
			CPartFile* file = (CPartFile*)delitem->value;
			theApp.emuledlg->AddLogLine(false,file->GetFileName());

			temp2=file->GetFileName(); if (temp2.GetLength()>50) temp2=temp2.Mid(0,50);
			temp.Format("\n%s\t [%.1f%%] %i/%i - %s",
				temp2,file->GetPercentCompleted(),file->GetTransferingSrcCount(),file->GetSourceCount(), file->GetPartfileStatus());
			out=out+temp;
		}
	}
	theApp.emuledlg->AddLogLine(false,out);
	return out;
*/
// speedups by zz
@


1.23
log
@Crash fixed
@
text
@d818 1
a818 1
						buffer.Format("eDonkeyHybrid v%i", lpUpDownClient->GetVersion());
@


1.22
log
@Hotfixes.
@
text
@d589 5
a593 1
					buffer.Format( "%s [%.1f%%]", buffer, saved);
@


1.21
log
@corrected display problem
@
text
@d456 1
a456 1
				buffer.Format("%s",CastItoXBytes(lpPartFile->GetFileSize()));
d461 1
a461 1
				buffer.Format( "%s", CastItoXBytes(lpPartFile->GetTransfered()));
d583 1
a583 1
					buffer.Format("%s (%s)",CastSecondsToHM(restTime),CastItoXBytes(remains));
d749 1
a749 1
					buffer.Format( "%s", CastItoXBytes(lpUpDownClient->GetTransferedDown()));
@


1.20
log
@.26b port
@
text
@d415 1
a415 1
		char buffer[200];
d456 2
a457 2
				
				dc->DrawText(buffer,(int)strlen(CastItoXBytes(lpPartFile->GetFileSize())),lpRect, DLC_DT_TEXT | DT_RIGHT);
d461 2
a462 2
				
				dc->DrawText(buffer,(int)strlen(CastItoXBytes(lpPartFile->GetTransfered())),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d472 1
a472 1
					sprintf(buffer, "");
d474 1
a474 1
					sprintf(buffer,"%.1f %s", lpPartFile->GetDatarate() / 1024.0f,GetResString(IDS_KBYTESEC));
d476 1
a476 1
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);
d524 1
a524 1
					sprintf(buffer,"%s%i (%i)",buffer2, lpPartFile->GetSourceCount(), lpPartFile->GetTransferingSrcCount());
d567 2
a568 2
				sprintf(buffer,"%s", lpPartFile->GetPartfileStatus());
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d583 1
a583 1
					sprintf(buffer,"%s (%s)",CastSecondsToHM(restTime),CastItoXBytes(remains));
d585 1
a585 1
						sprintf(buffer,"");
d589 1
a589 1
					sprintf(buffer, "%s [%.1f%%]", buffer, saved);
d591 1
a591 1
					dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d608 1
a608 4
	if(lpRect->left < lpRect->right)
	{ 

		char buffer[100];
d749 3
a751 2
					
					dc->DrawText(buffer,(int)strlen(CastItoXBytes(lpUpDownClient->GetTransferedDown())),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d759 1
a759 1
						sprintf(buffer,"");
d761 2
a762 2
						sprintf(buffer,"%.1f %s", lpUpDownClient->GetDownloadDatarate()/1024.0f,GetResString(IDS_KBYTESEC));
					dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);
d811 1
a811 1
						sprintf(buffer, "eDonkey v%i", lpUpDownClient->GetVersion());
d814 1
a814 1
						sprintf(buffer, "eDonkeyHybrid v%i", lpUpDownClient->GetVersion());
d817 1
a817 1
						sprintf(buffer, "CDonkey v%i", lpUpDownClient->GetVersion());
d822 1
a822 1
							sprintf(buffer, "eMule v0.%02X", lpUpDownClient->GetMuleVersion());
d824 1
a824 1
							sprintf(buffer,"eMule v  ?");
d828 1
a828 1
						sprintf(buffer, GetResString(IDS_OLDMLDONKEY));
d831 1
a831 1
						sprintf(buffer, GetResString(IDS_UNKNOWN));
d833 1
a833 1
						sprintf(buffer, "???");
d835 1
a835 1
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d844 2
a845 2
					sprintf(buffer,GetResString(IDS_QUEUEFULL));
					dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d849 2
a850 2
					sprintf(buffer,"QR: %u",lpUpDownClient->GetRemoteQueueRank());
					dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d852 4
d858 2
a859 2
						sprintf(buffer,"");
						dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT);
d889 3
a891 3
					sprintf(buffer,"%0.1f",lpUpDownClient->GetRemoteBaseModifier());
				else buffer[0] = 0;
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);	
d895 3
a897 3
					sprintf(buffer,"%ld",lpUpDownClient->GetRemoteRatio());
				else buffer[0] = 0;
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);	
a899 1
	}
@


1.19
log
@The files that did not see any progress for a week will be highlighted in red
@
text
@d456 2
a457 2
				CastItoXBytes(lpPartFile->GetFileSize(),buffer);
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);
d461 2
a462 2
				CastItoXBytes(lpPartFile->GetTransfered(),buffer);
				dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);	
a572 2
					char bufferSize[50];
					char bufferTime[50];
a579 1
					CastItoXBytes(remains,bufferSize);
d583 1
a583 2
					CastSecondsToHM(restTime,bufferTime);
					sprintf(buffer,"%s (%s)",bufferTime,bufferSize);
d752 2
a753 2
					CastItoXBytes(lpUpDownClient->GetTransferedDown(),buffer);
					dc->DrawText(buffer,(int)strlen(buffer),lpRect, DLC_DT_TEXT | DT_RIGHT);	
@


1.18
log
@preview menu rearrangement
@
text
@d407 2
d434 12
d447 3
@


1.17
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d1230 1
a1230 1
			if(theApp.glob_prefs->IsFirstLastMovieChunksEnabled() && file->IsMovie() && justOne)
d1233 1
d1236 1
d1965 1
a1965 1
	m_MovieMenu.AppendMenu(MF_STRING,MP_MOVIE_NO, GetResString(IDS_MOVIE_NO));
d1985 1
a2003 2
	m_FileMenu.AppendMenu(MF_SEPARATOR);
	m_FileMenu.AppendMenu(MF_STRING,MP_GET_PREVIEW_CHUNKS, GetResString(IDS_GET_PREVIEW_CHUNKS)); // obaldin
@


1.16
log
@CDonkey string added
@
text
@d58 10
a67 2
	for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos))
		delete listcontent.GetAt(pos);
d125 9
d235 3
a237 1
    listcontent.AddTail(newitem);
d253 13
a265 10
    listcontent.AddTail(newitem);

    CtrlItem_Struct* search = 0;
    for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos)){
            if (listcontent.GetAt(pos)->value == owner)
            {
                    search = listcontent.GetAt(pos);
                    break;
            }
    }
d286 1
d295 11
a305 1
			if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 1)
d307 2
a308 5
				if(theApp.emuledlg->transferwnd.infolistctrl.GetClient() == source)
				{
					theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
					theApp.emuledlg->transferwnd.UpdateInfoHeader();
				}
a309 9
			LVFINDINFO find;
			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)delitem;
			sint16 result = FindItem(&find);
			if (result != (-1))
				DeleteItem(result);
			listcontent.RemoveAt(pos2);
			delitem->status.DeleteObject();
			delete delitem;
d311 9
d327 1
d335 9
a343 1
			if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 2)
d345 13
a357 16
				if(theApp.emuledlg->transferwnd.infolistctrl.GetFile() == toremove)
				{
					theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
					theApp.emuledlg->transferwnd.UpdateInfoHeader();
				}
			}			
			LVFINDINFO find;
			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)delitem;
			sint16 result = FindItem(&find);
			if(result != -1)
				DeleteItem(result);
			listcontent.RemoveAt(pos2);
			delitem->status.DeleteObject();
			delete delitem;
		}
d375 1
d382 18
a399 12
			LVFINDINFO find;
			find.flags = LVFI_PARAM;
			find.lParam = (LPARAM)search;
			sint16 result = FindItem(&find);
			if (result != -1)
			{
				search->dwUpdated = 0;
				Update(result);
				//Cax2: - Ok I'm an idiot...
				RedrawItems(result,result);	// Lord KiRon
			}
			return;
d401 1
d423 11
a433 2
					dc->DrawText(lpPartFile->GetFileName(),
						(int)strlen(lpPartFile->GetFileName()),lpRect, DLC_DT_TEXT);
d657 9
a670 1
                            POINT point2= {cur_rec.left,cur_rec.top+1};
a671 1
                            cur_rec.left += 20;
a674 1
                            POINT point2= {cur_rec.left,cur_rec.top+1};
a675 1
                            cur_rec.left += 20;
a678 1
							POINT point2= {cur_rec.left,cur_rec.top+1};
a679 1
							cur_rec.left += 20;
a685 1
						POINT point2= {cur_rec.left,cur_rec.top+1};
d687 1
a687 2
                                 m_ImageList.Draw(dc, 17, point2, ILD_NORMAL);
                                 cur_rec.left += 20;
a689 1
                                 cur_rec.left += 20;
d693 1
a693 3
                             POINT point2= {cur_rec.left,cur_rec.top+1};
                             m_ImageList.Draw(dc, 18, point2, ILD_NORMAL);
                             cur_rec.left += 20;
a694 1
                             POINT point2= {cur_rec.left,cur_rec.top+1};
a695 1
						cur_rec.left += 20;
a699 1
							POINT point2= {cur_rec.left,cur_rec.top+1};
a701 1
								cur_rec.left += 20;
a703 1
								cur_rec.left += 20;
a706 1
                             POINT point2= {cur_rec.left,cur_rec.top+1};
a707 1
                             cur_rec.left += 20;
a708 1
							POINT point2= {cur_rec.left,cur_rec.top+1};
a709 1
							cur_rec.left += 20;
d714 5
d821 2
d1137 1
d1141 9
a1149 2
				if (cur_item->owner == partfile)
				{
d1672 1
d1685 14
d1782 9
a1790 1
			return strcmpi(file1->GetFileName(),file2->GetFileName());
d2056 1
d2073 15
d2129 1
d2137 23
@


1.15
log
@Hybrid client and CDonkey detection
@
text
@d758 3
@


1.14
log
@Get fist/last chunk is now a per-file setting
@
text
@d755 3
@


1.14.2.1
log
@Fixing list controls, adding support for eDonkey Hybrid
@
text
@a116 5

    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  // 19
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));         // 20
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));         // 21
    m_ImageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         // 22
a603 9
                    POINT point2= {cur_rec.left,cur_rec.top+1};
                    if(lpUpDownClient->GetClientSoft() == SO_EDONKEYHYBRID) {
                             m_ImageList.Draw(dc, 19, point2, ILD_NORMAL);
                             if (lpUpDownClient->GetRemoteBaseModifier() >= 1.1)
                                m_ImageList.Draw(dc, 20, point2, ILD_NORMAL);
                             if (lpUpDownClient->IsFriend())
                                m_ImageList.Draw(dc, 21, point2, ILD_NORMAL);
                    }
                    else
d609 1
d611 1
d615 1
d617 1
d621 1
d623 1
d630 1
d633 1
d636 1
d640 1
d642 1
d644 1
d646 1
d651 1
d654 1
d657 1
d661 1
d663 1
d665 1
d667 1
a670 5

                    if((lpUpDownClient->GetClientSoft()==SO_EMULE) && (lpUpDownClient->GetMuleVersion()==0x26)) {
                        m_ImageList.Draw(dc, 22, point2, ILD_NORMAL);
                    }
					cur_rec.left += 20;
a754 3
					case SO_EDONKEYHYBRID:
						sprintf(buffer, "eDonkeyHybrid v%i", lpUpDownClient->GetVersion());
						break;
a767 2
                    default:
						sprintf(buffer, "???");
@


1.14.2.2
log
@further fixes
@
text
@d639 1
a639 1
                                 m_ImageList.Draw(dc, 18, point2, ILD_NORMAL);
d645 1
a645 1
                             m_ImageList.Draw(dc, 17, point2, ILD_NORMAL);
@


1.14.2.3
log
@speedups by zz
@
text
@d54 2
a55 1
CDownloadListCtrl::~CDownloadListCtrl(){
d58 2
a59 10
	//for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos))
	//	delete listcontent.GetAt(pos);

    POSITION pos = listcontent.GetStartPosition();
    while(pos != 0) {
        void* key;
        CtrlItem_Struct* value;
        listcontent.GetNextAssoc(pos, key, value);
	    delete value;
    }
d223 1
a223 3
    // speedups by zz
        //listcontent.AddTail(newitem);
        listcontent.SetAt(newitem->value, newitem);
d229 2
a230 1
void CDownloadListCtrl::AddSource(CPartFile* owner,CUpDownClient* source,bool notavailable){
d239 10
a248 13
    // speedups by zz
        //listcontent.AddTail(newitem);
        listcontent.SetAt(newitem->value, newitem);

        //CtrlItem_Struct* search = 0;
        //for (POSITION pos = listcontent.GetHeadPosition();pos != 0;listcontent.GetNext(pos)){
        //        if (listcontent.GetAt(pos)->value == owner){
        //                search = listcontent.GetAt(pos);
        //                break;
        //        }
        //}
        CtrlItem_Struct* search;
        listcontent.Lookup(owner, search);
d266 2
a267 1
void CDownloadListCtrl::RemoveSource(CUpDownClient* source,CPartFile* owner){
a268 1
/*
a276 7
*/
    // speedups by zz

	CtrlItem_Struct* delitem;
    BOOL found = listcontent.Lookup(source, delitem);

	if(found && (delitem->owner == owner || (!owner) ) ){
d291 1
a291 1
			listcontent.RemoveKey(source);
d295 1
d299 2
a300 1
void CDownloadListCtrl::RemoveFile(CPartFile* toremove){
a301 1
/*
a308 5
*/
// speedups by zz
	CtrlItem_Struct* delitem;
    BOOL found = listcontent.Lookup(toremove, delitem);    
	if(found){
d323 1
a323 1
			listcontent.RemoveKey(toremove);
d327 1
d340 2
a341 1
void CDownloadListCtrl::UpdateItem(void* toupdate){
a343 1
/*
a349 7
*/
// speedups by zz
	CtrlItem_Struct* search;

    BOOL found = listcontent.Lookup(toupdate, search);
    
    if(found) {
d354 2
a355 1
			if (result != -1){
d363 1
a1085 1
/*
d1089 2
a1090 8
*/
// speedups by zz
                POSITION pos = listcontent.GetStartPosition();

				while(pos != NULL){
                    void* key;
                    listcontent.GetNextAssoc(pos, key, cur_item);
				if (cur_item->owner == partfile){
a1611 1

a1612 1
/*
a1624 13
*/
   POSITION pos = listcontent.GetStartPosition();
   while(pos != NULL) {
       void* key;
	   CtrlItem_Struct* delitem;
	   listcontent.GetNextAssoc(pos, key, delitem);
	   if (delitem->type == 1){
		   CPartFile* file = (CPartFile*)delitem->value;
		   if (!file->IsPartFile())
			   RemoveFile(file);
	   }
   }

a1973 1
        /*
a1989 14
*/

    POSITION pos = listcontent.GetStartPosition();
    while(pos != 0) {
        void* key;
        CtrlItem_Struct* item;
        listcontent.GetNextAssoc(pos, key, item);
			if (item->type == 3 && item->owner == file)
			{
				CUpDownClient* cur_src = (CUpDownClient*)item->value;
				if(cur_src)
					cur_src->HandoverToAnotherFile(file);
			}
    }
a2030 1
/*
a2037 22
		if (delitem->type == 1){
			CPartFile* file = (CPartFile*)delitem->value;
			theApp.emuledlg->AddLogLine(false,file->GetFileName());

			temp2=file->GetFileName(); if (temp2.GetLength()>50) temp2=temp2.Mid(0,50);
			temp.Format("\n%s\t [%.1f%%] %i/%i - %s",
				temp2,file->GetPercentCompleted(),file->GetTransferingSrcCount(),file->GetSourceCount(), file->GetPartfileStatus());
			out=out+temp;
		}
	}
	theApp.emuledlg->AddLogLine(false,out);
	return out;
*/
// speedups by zz
	CString out="";
	CString temp,temp2;

	POSITION pos = listcontent.GetStartPosition();
	while(pos != NULL){
        void* key;
		CtrlItem_Struct* delitem;
		listcontent.GetNextAssoc(pos, key, delitem);
@


1.14.2.4
log
@more fixes, more merging, try/catch balancing
@
text
@a128 4

	m_ImageList.Add(theApp.LoadIcon(IDI_RATING));   //23
	m_ImageList.Add(theApp.LoadIcon(IDI_RATINGBAD));

d404 2
a405 1
            case 0:{		// file name
d410 2
a411 11
                    // now comments/ratings
			        if (lpPartFile->HasComment() || lpPartFile->HasRating()){
				        int image=23;
				        if (lpPartFile->HasRating()) if (lpPartFile->HasBadRating()) image=24;

				        POINT point= {lpRect->left-4,lpRect->top+3};
				        m_ImageList.Draw(dc, image, point, ILD_NORMAL);
			        }
				    lpRect->left+=9;
				    dc->DrawText(lpPartFile->GetFileName(), (int)strlen(lpPartFile->GetFileName()),lpRect, DLC_DT_TEXT);
				    lpRect->left-=9;
@


1.14.2.5
log
@couple of 'can't hurt' crash protections
@
text
@d1768 1
a1768 9
            // obaldin: funny, but we might not have a filename yet..
            {
                char *fname1=file1->GetFileName();
                char *fname2=file2->GetFileName();
                if  (!fname1||!fname2)
                    return 0;
                else
			        return strcmpi(fname1,fname2);
            }
@


1.13
log
@Merge from official sockets
@
text
@d1157 9
d1442 4
d1915 2
@


1.12
log
@bugfixes & control panel updates
@
text
@d774 1
a774 1
			if (lpUpDownClient->IsEmuleClient() && 
@


1.11
log
@1 bugfix + 1 new feature, see changelog..
@
text
@d1257 2
a1258 1
						if (MessageBox((GetResString(IDS_Q_CANCELDL) + fileList),GetResString(IDS_CANCEL),MB_ICONQUESTION|MB_YESNO) == IDYES)
d1761 6
d1769 3
a1771 4
				else
					if(client1->GetRemoteQueueRank()==0 && client2->GetRemoteQueueRank()==0)
						return (client1->IsEmuleClient())?((client2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
					return (client1->GetRemoteQueueRank()==0)?((client2->GetRemoteQueueRank()==0)?0:2):-1;  
@


1.10
log
@merge fixes and minor optimizations
@
text
@d1079 1
a1079 1
		if ( (!partfile->srcarevisible) && partfile->GetSourceCount()>0 )
d1811 13
a1823 1
		if (content->type != 1)
@


1.9
log
@2.5 bugfixes
@
text
@d86 1
a86 1
	InsertColumn(5,GetResString(IDS_DL_SOURCES),LVCFMT_RIGHT, 50);
@


1.9.2.1
log
@updating this branch...
@
text
@@


1.9.2.2
log
@merge cleanup!
@
text
@d86 1
a86 1
	InsertColumn(5,GetResString(IDS_DL_SOURCES),LVCFMT_CENTER, 50);
@


1.9.2.3
log
@bugfix form main branch
@
text
@d1079 1
a1079 1
		if ( (!partfile->srcarevisible) && partfile->GetSourceCount()>0 && partfile->GetStatus()!=PS_COMPLETING)	//Cax2: when (slow) completing, the files stay shut
d1811 1
a1811 13
		if (content->type == 1)		//Cax2: doubleclick opens completed files
		{
			CPartFile* file=(CPartFile*)content->value;
			if(file->GetStatus()==PS_COMPLETE)
			{
				char* buffer = new char[MAX_PATH];
				sprintf(buffer,"%s\\%s",file->GetPath(),file->GetFileName());
				theApp.emuledlg->AddLogLine( false, "%s\\%s",file->GetPath(),file->GetFileName());
				ShellOpenFile(buffer);
				delete buffer;
			}
		}
		else	//client  options
@


1.9.2.4
log
@updated control panes, and assorted bugfixes
@
text
@d1257 1
a1257 2
						CString str=(selectedCount > 1)?GetResString(IDS_Q_CANCELDL):GetResString(IDS_Q_CANCELDL2);	//Cax2 bugfix: plurals
						if (MessageBox(str + fileList,GetResString(IDS_CANCEL),MB_ICONQUESTION|MB_YESNO) == IDYES)
a1759 6
				if (client1->GetDownloadState()!=DS_ONQUEUE || client2->GetDownloadState()!=DS_ONQUEUE)	//Cax2 QR gaps bugfix
				{
					if (client1->GetDownloadState()==DS_DOWNLOADING || client2->GetDownloadState()==DS_DOWNLOADING)		//Cax2 QR gaps bugfix
						return (client1->GetDownloadState()==DS_DOWNLOADING)?((client2->GetDownloadState()==DS_DOWNLOADING)?0:-1):2; //Cax2 QR gaps bugfix
					return (client1->GetDownloadState()!=DS_ONQUEUE)?((client2->GetDownloadState()!=DS_ONQUEUE)?0:2):-1;
				}
d1762 4
a1765 3
				if(client1->GetRemoteQueueRank()==0 && client2->GetRemoteQueueRank()==0)
					return (client1->IsEmuleClient())?((client2->IsEmuleClient())?0:-1):2;	//"queue full" or " " ?
				return (client1->GetRemoteQueueRank()==0)?((client2->GetRemoteQueueRank()==0)?0:2):-1;  
@


1.9.2.5
log
@emule v ? shows QR now
@
text
@d774 1
a774 1
			if ((lpUpDownClient->IsEmuleClient() ||  lpUpDownClient->GetRemoteQueueRank())&&		//now emule v ? display the QR too!
@


1.8
log
@bugfix  in dislpaying other clients versions (v2B was shown as v31) minor sort bugfixes
@
text
@d400 2
a401 2
            	//Cax2: faster if: 0.05 is always rounded up!
            	if((lpPartFile->GetDatarate() / 1024.0f)<0.05)
@


1.7
log
@should work ok
@
text
@d757 4
a760 2
						int temp = lpUpDownClient->GetMuleVersion()/16;
						sprintf(buffer, "eMule v%i", (temp*10)+( lpUpDownClient->GetMuleVersion()-temp*16));
d764 1
a764 1
						sprintf(buffer, "Old MlDonkey");
a1532 1
	//newsort START added by Cax2 03/11/02 
d1539 3
a1541 4
	//newsort END 
    	int sortMod = 1;
    	if(lParamSort >= 10)
    	{
a1546 1
	// Newsort START added by Cax2 
d1562 2
a1563 2
				return (lParamSort==5)?(item1->type - item2->type)* sortMod:item1->type - item2->type; //always at the end, uless click source column (a4af at the top on second click)
		comp = Compare((CUpDownClient*)item1->value,(CUpDownClient*) item2->value, lParamSort, sortMod); //Cax2: previous 'fix' ineffective
a1564 1
	// Newsort END 
d1665 1
a1665 1
	// Lord KiRon
d1676 3
a1678 1
	// Lord KiRon - end
d1747 9
a1755 7
				if( client1->GetClientSoft() == SO_UNKNOWN )
					return 1;
				if( client2->GetClientSoft() == SO_UNKNOWN )
					return -1;
				if( client1->GetClientSoft() == client2->GetClientSoft() )
					if( client1->IsEmuleClient() )
						return client2->GetMuleVersion() - client1->GetMuleVersion();
@


1.6
log
@restored functionality to downloadlistcontrol
@
text
@d529 3
a531 2
			case 9: break;
			case 10: break;
d620 5
a624 5
                        {
                            POINT point2= {cur_rec.left,cur_rec.top+1};
                            m_ImageList.Draw(dc, 11, point2, ILD_NORMAL);
                            cur_rec.left += 20;
                        }
d630 1
a630 1
                             POINT point2= {cur_rec.left,cur_rec.top+1};
d646 2
a647 2
                             cur_rec.left += 20;
                         }
d650 11
a660 11
                         {
                             POINT point2= {cur_rec.left,cur_rec.top+1};
                             if (lpUpDownClient->TarodVersion()) {
                                 m_ImageList.Draw(dc, 9, point2, ILD_NORMAL);
                                 cur_rec.left += 20;
                             } else {
                                 m_ImageList.Draw(dc, 5, point2, ILD_NORMAL);
                                 cur_rec.left += 20;
                             }
                         } else if (lpUpDownClient->GetClientSoft() == SO_MLDONKEY)
						 {
d664 5
a668 5
						 } else {
                             POINT point2= {cur_rec.left,cur_rec.top+1};
                             m_ImageList.Draw(dc, 10, point2, ILD_NORMAL);
                             cur_rec.left += 20;
                         }
d748 4
a751 2
		case 5:{		// sources
				switch(lpUpDownClient->GetClientSoft()){
d769 1
a769 1
			   }
d773 2
a774 2
				lpUpDownClient->GetDownloadState()==DS_ONQUEUE
			){
a921 8
				while(iCurrent < iCount) {
					int iNext = pHeaderCtrl->OrderToIndex(iCurrent + 1);
					if(iNext == 1 /*|| iNext == 5 || iNext == 7 || iNext == 8*/)
						cx += GetColumnWidth(iNext);
					else
						break;
					iCurrent++;
				}
d1092 2
a1093 1
			//check if sources are showing anywhere... 
a1513 1

a1514 1

a1519 1

a1521 1

d1562 3
a1564 3
        	if ((lParamSort==6)&& item1->type != item2->type) // put 'asked for another file' at the end when sorting by QR
                	return (item1->type - item2->type)* sortMod; // Cax2 bugfix
		comp = Compare((CUpDownClient*)item1->value,(CUpDownClient*)item2->value, lParamSort, sortMod); // Nullpointer fix
d1576 1
a1576 1
		return;
d1588 1
a1588 1
		} 
d1666 1
a1666 1
	
d1746 1
a1746 1
			case 5:
d1757 1
a1757 1
			case 6: //Sources column - QR Cax2
d1761 2
a1762 1
					return (client1->IsRemoteQueueFull())?((client2->IsRemoteQueueFull())?0:-1):2;
a1888 23

CString CDownloadListCtrl::getTextList() {
	CString out="";
	CString temp,temp2;

	POSITION pos1, pos2;
	for( pos1 = listcontent.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		listcontent.GetNext(pos1);
		CtrlItem_Struct* delitem = listcontent.GetAt(pos2);
		if (delitem->type == 1){
			CPartFile* file = (CPartFile*)delitem->value;
			theApp.emuledlg->AddLogLine(false,file->GetFileName());

			temp2=file->GetFileName(); if (temp2.GetLength()>50) temp2=temp2.Mid(0,50);
			temp.Format("\n%s\t [%.1f%%] %i/%i - %s",
				temp2,file->GetPercentCompleted(),file->GetTransferingSrcCount(),file->GetSourceCount(), file->GetPartfileStatus());
			out=out+temp;
		}
	}
	theApp.emuledlg->AddLogLine(false,out);
	return out;
}

d1989 22
@


1.5
log
@Redraw fix
@
text
@d353 2
a354 2
				//Cax2: why? update should trigger redraw - removing the line below...
				//RedrawItems(result,result);	// Lord KiRon
d1674 1
a1674 2
	//checking if redraw is any slower without this check - optimizations already present in drawitems
	/*
a1683 1
	*/
d1685 1
a1685 1
	//}
@


1.4
log
@port to .25 b codebase...
@
text
@a1093 1
			SetRedraw(true);
d1109 1
@


1.3
log
@update to .25b codebase
@
text
@d326 1
a326 1
	   	if(item->owner == delitem)
d922 1
a922 1
						cx += CListCtrl::GetColumnWidth(iNext);
d1913 1
a1913 1
				temp2,file->GetPercentCompleted(),file->GetTransferingSrcCount(),file->GetSourceCount(), file->getPartfileStatus());
@


1.2
log
@*** empty log message ***
@
text
@d126 5
a130 2
		SetSortArrow(0, true);
		SortItems(&SortProc, 0);
a263 1

d265 1
d269 1
a269 1
		CtrlItem_Struct* delitem = listcontent.GetAt(pos2);
a290 1

a296 1

d298 1
d301 1
a301 1
		CtrlItem_Struct* delitem = listcontent.GetNext(pos1);    
d325 2
a326 2
		CtrlItem_Struct* item = (CtrlItem_Struct*)this->GetItemData(i);
	   	if(item->owner == item)
d328 1
a328 1
			delete item;
a331 1

d353 2
a354 1
				RedrawItems(result,result);	// Lord KiRon
a365 1

d398 1
a398 1
            	if (lpPartFile->GetTransferingSrcCount()==0 || lpPartFile->GetStatus(true)==PS_COMPLETING || lpPartFile->GetStatus(true)==PS_COMPLETE || (lpPartFile->GetDatarate() / 1024.0f)==0 ) 
d400 2
d747 18
a764 1
			case 5:		// sources
d766 1
d769 9
a777 2
				if (lpUpDownClient->GetRemoteQueueRank())
				{
d781 5
d919 8
a1052 1

d1084 1
d1087 1
a1087 1
				CtrlItem_Struct* cur_item = (CtrlItem_Struct*)listcontent.GetAt(pos);
d1094 1
d1098 1
a1098 2
			m_ShowSrc=false; 
			//more srces showing? need to keep the file lines from moving... 
a1107 1
		SetRedraw(true);
a1109 1

a1111 1

d1120 1
a1120 1
	::GetCursorPos(&point);
d1152 1
d1155 1
a1155 1
				m_FileMenu.CheckMenuItem(MP_ALL_A4AF_AUTO, MF_GRAYED);
d1159 1
a1159 1
			// DonGato - Moview Preview Mode
d1528 2
d1570 1
a1570 1
        	if ((lParamSort==6 || lParamSort==1)&& item1->type != item2->type) // use 'asked for another file' only when sorting QR & status 
d1572 1
a1572 3
		const CUpDownClient* client1 = (CUpDownClient*)item1->value; // Nullpointer fix
        	const CUpDownClient* client2 = (CUpDownClient*)item2->value; // Nullpointer fix
		comp = Compare((CUpDownClient*) client1,(CUpDownClient*) client2, lParamSort, sortMod); // Nullpointer fix
a1575 1

a1576 1

a1582 1

d1584 2
a1585 1
		return; 
d1588 1
a1588 1
	for (int i = 0; i <GetItemCount(); i++)
d1591 1
a1591 1
		if(item->type==1 && ((CPartFile*)item->value)==partfile)
d1593 3
a1595 9
			i++; 
			while (i<GetItemCount() && ((CtrlItem_Struct*)GetItemData(i))->type != 1)
			{ 
				CtrlItem_Struct* cur_item = (CtrlItem_Struct*)GetItemData(i); 
				cur_item->dwUpdated = 0; 
				cur_item->status.DeleteObject(); 
				DeleteItem(i); 
			} 
			break;
a1597 1
	partfile->srcarevisible = false; 
a1598 1

a1604 1

a1616 1

a1622 1

a1626 1

a1632 1

a1662 1

a1664 1

d1674 2
a1675 1

d1685 1
d1687 1
a1687 1
	}
a1688 1

d1695 1
a1695 1
	if (file1==NULL||file2==NULL) // null pointer fix
d1710 1
a1710 1
				return (comp > 0)?1:((comp<0)?-1:0);	// Cax2 removed those ifs...
a1718 1
			//newsort start modified by Cax2 03/11/02 
d1723 1
a1723 1
			//if no remaining time sort by remaining size asc. * update 18/12/02 leave completed files last...
a1731 1
			//newsort end modified by Cax2 03/11/02
a1734 1

d1743 1
a1743 2

	if (client1==NULL||client2==NULL) return 0; // Cax2 null pointer fix 
d1746 1
a1746 1
			case 0: //name asc - Newsort Cax2
d1756 11
d1771 1
a1795 1

a1796 1

d1896 23
@


1.1
log
@*** empty log message ***
@
text
@d90 3
d109 8
d188 11
d525 3
d599 24
a622 1
					if (lpUpDownClient->IsFriend() && !lpUpDownClient->ExtProtocolAvailable())
d624 20
a643 20
						POINT point2= {cur_rec.left,cur_rec.top+1};
						m_ImageList.Draw(dc, 11, point2, ILD_NORMAL);
						cur_rec.left += 20;
					}
					else if (lpUpDownClient->IsFriend() && lpUpDownClient->ExtProtocolAvailable())
					{
						POINT point2= {cur_rec.left,cur_rec.top+1};
						m_ImageList.Draw(dc, 12, point2, ILD_NORMAL);
						cur_rec.left += 20;
					}
					else if (lpUpDownClient->ExtProtocolAvailable())
					{
						POINT point2= {cur_rec.left,cur_rec.top+1};
						if (lpUpDownClient->TarodVersion()) {
							m_ImageList.Draw(dc, 9, point2, ILD_NORMAL);
							cur_rec.left += 20;
						} else {
							m_ImageList.Draw(dc, 5, point2, ILD_NORMAL);
							cur_rec.left += 20;
						}
d645 22
a666 4
						POINT point2= {cur_rec.left,cur_rec.top+1};
						m_ImageList.Draw(dc, 10, point2, ILD_NORMAL);
						cur_rec.left += 20;
					}
d779 12
d1744 18
@

