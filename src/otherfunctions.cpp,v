head	1.254;
access;
symbols
	PublicRelease_1_2e:1.250
	Interim_Release_1-2e_RC1:1.250
	PublicRelease_1_2d:1.243
	Interim_Release_1-2d_RC1:1.243
	Interim_Release_1-2d_beta1:1.242
	PublicRelease_1_2c:1.231
	Interim_Release_1-2c_RC1:1.231
	Interim_Release_1-2c_beta1:1.226
	PublicRelease_1_2b:1.225
	Interim_Release_1-2b_RC1:1.224
	PublicRelease_1_2a:1.219
	Interim_Release_1-2a_RC1:1.218
	Interim_Release_1-2a_beta2:1.212
	Interim_Release_1-2a_beta1:1.210
	PublicRelease_1_2:1.205
	Interim_Release_1-2_RC1:1.205
	Interim_Release_1-2_beta1:1.202
	PublicRelease_1_1g:1.200
	Interim_Release_1-1g_RC3:1.200
	Interim_Release_1-1g_RC2:1.200
	Interim_Release_1-1g_RC1:1.200
	Interim_Release_1-1g_beta2:1.197
	Interim_Release_1-1g_beta1:1.191
	PublicRelease_1_1f:1.190
	Interim_Release_1-1f_RC1:1.190
	PublicRelease_1_1e:1.190
	Interim_Release_1-1e_RC2:1.190
	Interim_Release_1-1e_RC1:1.190
	Interim_Release_1-1e_beta1:1.189
	PublicRelease_1_1d:1.187
	Interim_Release_1-1d_RC1:1.186
	PublicRelease_1_1c:1.186
	Interim_Release_1-1c_RC1:1.185
	Interim_Release_1-1c_beta2:1.183
	Interim_Release_1-1c_beta1:1.181
	PublicRelease_1_1b:1.176
	Interim_Release_1-1b_RC1:1.176
	PublicRelease_1_1a:1.176
	Interim_Release_1-1a_RC2:1.175
	Interim_Release_1-1a_RC1:1.175
	Interim_Release_1-1a_beta2:1.175
	Interim_Release_1-1a_beta1:1.174
	PublicRelease_1_1:1.171
	Interim_Release_1-1_beta1:1.169
	PublicRelease_1o:1.168
	Interim_Release_1o_RC1:1.168
	Interim_Release_1o_beta1:1.167
	PublicRelease_1n:1.164
	Interim_Release_1n_RC2:1.164
	Interim_Release_1n_RC1:1.162
	Interim_Release_1n_beta2:1.155
	Interim_Release_1n_beta1:1.153
	PublicRelease_1m:1.150
	Interim_Release_1m_beta1:1.149
	PublicRelease_1l:1.148
	Interim_Release_1l_RC3:1.148
	Interim_Release_1l_RC2:1.146
	Interim_Release_1l_RC1:1.144
	Interim_Release_1l_beta2:1.144
	Interim_Release_1l_beta1:1.142
	PublicRelease_1k:1.136
	Interim_Release_1k_RC4:1.135
	Interim_1k_RC3:1.134
	Interim_1k_RC2:1.133
	Interim_Release_1k_RC1:1.131
	Interim_Release_1k_beta5:1.130
	Intrerim_Release_1k_beta4:1.130
	Interim_Release_1k_beta1:1.124
	PublicRelease_1j:1.110
	Interim_Release_1J_RC3:1.110
	Interim_Release_1j_RC3:1.110
	Interim_Release_1j_RC2:1.109
	Interim_Release_1j_RC1:1.109
	Interim_Release_1j_beta2:1.109
	Interim_Release_1j_beta1:1.109
	PublicRelease_1i:1.108
	Interim_Release_1i_RC6:1.108
	Interim_Release_1i_RC3:1.102
	Interim_Release_1i_RC2:1.102
	Interim_Release_1i_RC1:1.102
	Interim_Release_1i_beta3:1.102
	Interim_Release_1i_beta2:1.98
	Interim_Release_1i_beta1:1.92
	PublicRelease_1h:1.84
	Interim_Release_1h_rc2:1.84
	Interim_Release_1h_RC1:1.84
	Interim_Release_1h_beta2:1.83
	Interim_Release_1h_beta1_now:1.80
	Interim_Release_1h_beta1:1.80
	PublicRelease_1g:1.73
	Interim_Release_1g_RC6_Final:1.73
	Interim_Release_1g_RC6:1.73
	Interim_Release_1g_RC5:1.73
	Interim_Release_1g_RC4:1.72
	Interim_Release_1g_RC3:1.70
	Interim_Release_1g_beta2:1.62
	Interim_Release_1g_beta1:1.59
	Interim_Release_1f_RC4:1.52
	Interim_Release_1f_RC3:1.49
	Interim_Release_1f_RC2:1.44
	Interim_Release_1f_RC:1.44
	Interim_Release_1f_beta2:1.41
	Interim_Release_1f_beta1:1.37
	PublicRelease_1e:1.37
	Interim_Release_1e_RC2:1.37
	Interim_Release_1e_RC:1.37
	Interim_Release_1e_beta3:1.35
	Interim_Release_1e_beta2:1.35
	Interim_Release_1e_beta2_before_kuchin:1.34
	Interim_Release_1e_beta1:1.33
	PublicRelease_1c:1.32
	featurestest:1.32.0.2
	Interim_Release_1c_RC:1.32
	Interim_Release_1c_beta2:1.31
	Interim_Release_1c_beta1:1.30
	threaded_downloadqueue:1.29.0.2
	PublicRelease_1b:1.25
	Interim_Release_1b_beta2:1.25
	Interim_Release_1b_beta1:1.23
	proxydeadlake:1.22.0.2
	PublicRelease_1a:1.22
	Interim_Release_1a_beta2:1.22
	BerkeleyDb:1.21.0.2
	Interim_Release_1a_beta1:1.21
	PublicRelease_1:1.21
	goldfish:1.21
	eMulePlus_1_RC2:1.21
	eMulePlus_26b_1RC1:1.19
	PreRelease_26b_i0e:1.19
	before_26d_merge:1.19
	Interim_Release_26b_i0d:1.9
	Interim_Release_26b_i0c:1.5
	Interim_Release_26b_i0b:1.4
	Interim_Release_26b_i0a:1.4
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.254
date	2010.02.28.23.51.09;	author aw3;	state Exp;
branches;
next	1.253;

1.253
date	2009.11.17.02.37.22;	author aw3;	state Exp;
branches;
next	1.252;

1.252
date	2009.05.16.23.50.08;	author aw3;	state Exp;
branches;
next	1.251;

1.251
date	2009.05.16.22.15.21;	author aw3;	state Exp;
branches;
next	1.250;

1.250
date	2009.03.25.02.43.51;	author aw3;	state Exp;
branches;
next	1.249;

1.249
date	2009.03.24.03.09.25;	author aw3;	state Exp;
branches;
next	1.248;

1.248
date	2009.03.01.05.44.24;	author aw3;	state Exp;
branches;
next	1.247;

1.247
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.246;

1.246
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.245;

1.245
date	2008.09.29.04.47.56;	author aw3;	state Exp;
branches;
next	1.244;

1.244
date	2008.07.26.03.32.22;	author aw3;	state Exp;
branches;
next	1.243;

1.243
date	2008.03.03.05.19.14;	author aw3;	state Exp;
branches;
next	1.242;

1.242
date	2008.01.23.05.10.47;	author aw3;	state Exp;
branches;
next	1.241;

1.241
date	2008.01.03.04.47.41;	author aw3;	state Exp;
branches;
next	1.240;

1.240
date	2007.12.08.05.31.22;	author aw3;	state Exp;
branches;
next	1.239;

1.239
date	2007.12.07.02.42.43;	author aw3;	state Exp;
branches;
next	1.238;

1.238
date	2007.12.01.10.38.07;	author eklmn;	state Exp;
branches;
next	1.237;

1.237
date	2007.11.12.23.51.27;	author fuxie-dk;	state Exp;
branches;
next	1.236;

1.236
date	2007.10.31.18.27.01;	author fuxie-dk;	state Exp;
branches;
next	1.235;

1.235
date	2007.10.24.19.09.35;	author fuxie-dk;	state Exp;
branches;
next	1.234;

1.234
date	2007.10.12.21.35.11;	author double_t;	state Exp;
branches;
next	1.233;

1.233
date	2007.10.11.18.09.29;	author fuxie-dk;	state Exp;
branches;
next	1.232;

1.232
date	2007.10.03.18.09.18;	author eklmn;	state Exp;
branches;
next	1.231;

1.231
date	2007.08.17.12.22.31;	author aw3;	state Exp;
branches;
next	1.230;

1.230
date	2007.07.27.06.14.49;	author aw3;	state Exp;
branches;
next	1.229;

1.229
date	2007.07.17.04.04.32;	author aw3;	state Exp;
branches;
next	1.228;

1.228
date	2007.07.12.05.59.15;	author aw3;	state Exp;
branches;
next	1.227;

1.227
date	2007.04.05.03.55.56;	author aw3;	state Exp;
branches;
next	1.226;

1.226
date	2007.02.18.05.30.28;	author aw3;	state Exp;
branches;
next	1.225;

1.225
date	2007.01.28.14.54.04;	author aw3;	state Exp;
branches;
next	1.224;

1.224
date	2007.01.17.07.35.58;	author aw3;	state Exp;
branches;
next	1.223;

1.223
date	2006.12.22.22.23.35;	author eklmn;	state Exp;
branches;
next	1.222;

1.222
date	2006.12.06.14.02.54;	author aw3;	state Exp;
branches;
next	1.221;

1.221
date	2006.11.29.13.31.50;	author aw3;	state Exp;
branches;
next	1.220;

1.220
date	2006.11.23.05.28.24;	author aw3;	state Exp;
branches;
next	1.219;

1.219
date	2006.10.11.04.16.40;	author aw3;	state Exp;
branches;
next	1.218;

1.218
date	2006.09.18.04.17.59;	author aw3;	state Exp;
branches;
next	1.217;

1.217
date	2006.08.28.00.35.34;	author aw3;	state Exp;
branches;
next	1.216;

1.216
date	2006.07.21.00.37.07;	author aw3;	state Exp;
branches;
next	1.215;

1.215
date	2006.07.13.03.56.33;	author aw3;	state Exp;
branches;
next	1.214;

1.214
date	2006.07.12.17.40.42;	author kush_eplus;	state Exp;
branches;
next	1.213;

1.213
date	2006.07.04.04.42.29;	author aw3;	state Exp;
branches;
next	1.212;

1.212
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.211;

1.211
date	2006.05.17.03.52.25;	author aw3;	state Exp;
branches;
next	1.210;

1.210
date	2006.04.15.23.48.57;	author aw3;	state Exp;
branches;
next	1.209;

1.209
date	2006.04.09.22.32.29;	author kush_eplus;	state Exp;
branches;
next	1.208;

1.208
date	2006.04.09.15.18.43;	author kush_eplus;	state Exp;
branches;
next	1.207;

1.207
date	2006.03.19.23.42.31;	author aw3;	state Exp;
branches;
next	1.206;

1.206
date	2006.03.05.23.53.55;	author aw3;	state Exp;
branches;
next	1.205;

1.205
date	2006.02.09.00.45.51;	author aw3;	state Exp;
branches;
next	1.204;

1.204
date	2006.02.08.03.04.05;	author aw3;	state Exp;
branches;
next	1.203;

1.203
date	2006.02.07.05.31.43;	author aw3;	state Exp;
branches;
next	1.202;

1.202
date	2006.01.03.04.40.12;	author aw3;	state Exp;
branches;
next	1.201;

1.201
date	2005.12.28.19.11.33;	author aw3;	state Exp;
branches;
next	1.200;

1.200
date	2005.11.30.03.17.37;	author aw3;	state Exp;
branches;
next	1.199;

1.199
date	2005.11.27.22.11.52;	author eklmn;	state Exp;
branches;
next	1.198;

1.198
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.197;

1.197
date	2005.11.26.04.31.24;	author aw3;	state Exp;
branches;
next	1.196;

1.196
date	2005.11.19.03.35.38;	author aw3;	state Exp;
branches;
next	1.195;

1.195
date	2005.11.18.05.41.58;	author aw3;	state Exp;
branches;
next	1.194;

1.194
date	2005.10.04.03.25.38;	author aw3;	state Exp;
branches;
next	1.193;

1.193
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.192;

1.192
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.191;

1.191
date	2005.08.07.06.47.16;	author aw3;	state Exp;
branches;
next	1.190;

1.190
date	2005.06.11.14.38.37;	author aw3;	state Exp;
branches;
next	1.189;

1.189
date	2005.04.02.04.41.59;	author aw3;	state Exp;
branches;
next	1.188;

1.188
date	2005.03.26.04.12.43;	author aw3;	state Exp;
branches;
next	1.187;

1.187
date	2005.03.21.05.18.53;	author aw3;	state Exp;
branches;
next	1.186;

1.186
date	2005.02.27.13.40.18;	author kuchin;	state Exp;
branches;
next	1.185;

1.185
date	2005.02.22.22.27.22;	author netwolf1;	state Exp;
branches;
next	1.184;

1.184
date	2005.02.16.23.38.05;	author aw3;	state Exp;
branches;
next	1.183;

1.183
date	2005.02.03.17.41.46;	author aw3;	state Exp;
branches;
next	1.182;

1.182
date	2005.02.03.16.12.39;	author kuchin;	state Exp;
branches;
next	1.181;

1.181
date	2005.01.28.20.13.53;	author kuchin;	state Exp;
branches;
next	1.180;

1.180
date	2005.01.23.13.58.01;	author aw3;	state Exp;
branches;
next	1.179;

1.179
date	2005.01.19.21.10.54;	author netwolf1;	state Exp;
branches;
next	1.178;

1.178
date	2005.01.17.18.34.55;	author katsyonak;	state Exp;
branches;
next	1.177;

1.177
date	2005.01.16.00.35.00;	author netwolf1;	state Exp;
branches;
next	1.176;

1.176
date	2004.12.09.05.44.56;	author aw3;	state Exp;
branches;
next	1.175;

1.175
date	2004.11.11.05.36.29;	author aw3;	state Exp;
branches;
next	1.174;

1.174
date	2004.11.06.04.48.16;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2004.10.31.22.39.55;	author aw3;	state Exp;
branches;
next	1.172;

1.172
date	2004.10.26.01.36.35;	author aw3;	state Exp;
branches;
next	1.171;

1.171
date	2004.10.20.17.07.52;	author aw3;	state Exp;
branches;
next	1.170;

1.170
date	2004.10.19.05.00.38;	author aw3;	state Exp;
branches;
next	1.169;

1.169
date	2004.10.08.04.35.58;	author aw3;	state Exp;
branches;
next	1.168;

1.168
date	2004.09.25.07.32.25;	author aw3;	state Exp;
branches;
next	1.167;

1.167
date	2004.09.21.20.16.38;	author aw3;	state Exp;
branches;
next	1.166;

1.166
date	2004.09.20.07.12.31;	author aw3;	state Exp;
branches;
next	1.165;

1.165
date	2004.09.16.17.25.29;	author katsyonak;	state Exp;
branches;
next	1.164;

1.164
date	2004.09.07.19.54.26;	author aw3;	state Exp;
branches;
next	1.163;

1.163
date	2004.09.05.04.02.17;	author aw3;	state Exp;
branches;
next	1.162;

1.162
date	2004.08.28.04.59.04;	author aw3;	state Exp;
branches;
next	1.161;

1.161
date	2004.08.18.19.59.56;	author syrus77;	state Exp;
branches;
next	1.160;

1.160
date	2004.08.18.18.40.38;	author syrus77;	state Exp;
branches;
next	1.159;

1.159
date	2004.08.17.14.06.16;	author aw3;	state Exp;
branches;
next	1.158;

1.158
date	2004.08.12.14.51.53;	author eklmn;	state Exp;
branches;
next	1.157;

1.157
date	2004.08.11.19.18.18;	author aw3;	state Exp;
branches;
next	1.156;

1.156
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.155;

1.155
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.154;

1.154
date	2004.07.24.05.58.44;	author aw3;	state Exp;
branches;
next	1.153;

1.153
date	2004.07.19.12.54.56;	author katsyonak;	state Exp;
branches;
next	1.152;

1.152
date	2004.07.07.22.21.42;	author katsyonak;	state Exp;
branches;
next	1.151;

1.151
date	2004.07.07.12.17.29;	author katsyonak;	state Exp;
branches;
next	1.150;

1.150
date	2004.06.23.15.19.22;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2004.06.16.16.59.54;	author dongato;	state Exp;
branches;
next	1.148;

1.148
date	2004.06.07.13.48.39;	author netwolf1;	state Exp;
branches;
next	1.147;

1.147
date	2004.06.07.10.35.13;	author netwolf1;	state Exp;
branches;
next	1.146;

1.146
date	2004.06.01.22.31.03;	author aw3;	state Exp;
branches;
next	1.145;

1.145
date	2004.05.31.20.02.34;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2004.05.16.04.55.21;	author aw3;	state Exp;
branches;
next	1.143;

1.143
date	2004.05.15.00.32.59;	author aw3;	state Exp;
branches;
next	1.142;

1.142
date	2004.05.06.01.39.09;	author katsyonak;	state Exp;
branches;
next	1.141;

1.141
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.140;

1.140
date	2004.05.04.06.10.35;	author aw3;	state Exp;
branches;
next	1.139;

1.139
date	2004.05.03.19.55.53;	author dongato;	state Exp;
branches;
next	1.138;

1.138
date	2004.05.02.03.15.28;	author aw3;	state Exp;
branches;
next	1.137;

1.137
date	2004.05.01.05.37.21;	author aw3;	state Exp;
branches;
next	1.136;

1.136
date	2004.04.08.12.05.38;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2004.04.07.02.07.32;	author katsyonak;	state Exp;
branches;
next	1.134;

1.134
date	2004.04.04.13.19.48;	author syrus77;	state Exp;
branches;
next	1.133;

1.133
date	2004.03.30.22.18.26;	author syrus77;	state Exp;
branches;
next	1.132;

1.132
date	2004.03.29.17.16.53;	author eklmn;	state Exp;
branches;
next	1.131;

1.131
date	2004.03.24.09.51.22;	author eklmn;	state Exp;
branches;
next	1.130;

1.130
date	2004.03.16.00.38.57;	author aw3;	state Exp;
branches;
next	1.129;

1.129
date	2004.03.15.10.45.27;	author bavariansnail;	state Exp;
branches;
next	1.128;

1.128
date	2004.03.11.04.56.49;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2004.03.06.09.44.23;	author bavariansnail;	state Exp;
branches;
next	1.126;

1.126
date	2004.03.06.07.01.57;	author aw3;	state Exp;
branches;
next	1.125;

1.125
date	2004.03.02.01.51.10;	author aw3;	state Exp;
branches;
next	1.124;

1.124
date	2004.02.18.13.48.46;	author kush_eplus;	state Exp;
branches;
next	1.123;

1.123
date	2004.02.18.02.12.35;	author aw3;	state Exp;
branches;
next	1.122;

1.122
date	2004.02.16.23.22.39;	author aw3;	state Exp;
branches;
next	1.121;

1.121
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.120;

1.120
date	2004.02.14.06.35.52;	author aw3;	state Exp;
branches;
next	1.119;

1.119
date	2004.02.13.01.52.16;	author aw3;	state Exp;
branches;
next	1.118;

1.118
date	2004.02.11.23.41.34;	author aw3;	state Exp;
branches;
next	1.117;

1.117
date	2004.02.11.04.13.02;	author katsyonak;	state Exp;
branches;
next	1.116;

1.116
date	2004.02.08.22.44.39;	author kush_eplus;	state Exp;
branches;
next	1.115;

1.115
date	2004.02.06.15.40.42;	author netwolf1;	state Exp;
branches;
next	1.114;

1.114
date	2004.02.05.00.00.06;	author kush_eplus;	state Exp;
branches;
next	1.113;

1.113
date	2004.02.04.13.40.58;	author kush_eplus;	state Exp;
branches;
next	1.112;

1.112
date	2004.02.03.19.18.05;	author katsyonak;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.02.21.28.45;	author katsyonak;	state Exp;
branches;
next	1.110;

1.110
date	2004.01.19.18.21.29;	author dropf;	state Exp;
branches;
next	1.109;

1.109
date	2003.12.11.14.32.47;	author kuchin;	state Exp;
branches;
next	1.108;

1.108
date	2003.12.02.04.33.14;	author katsyonak;	state Exp;
branches;
next	1.107;

1.107
date	2003.12.02.01.40.08;	author netwolf1;	state Exp;
branches;
next	1.106;

1.106
date	2003.11.23.22.54.12;	author netwolf1;	state Exp;
branches;
next	1.105;

1.105
date	2003.11.23.13.33.37;	author katsyonak;	state Exp;
branches;
next	1.104;

1.104
date	2003.11.21.20.24.58;	author eklmn;	state Exp;
branches;
next	1.103;

1.103
date	2003.11.20.20.07.25;	author katsyonak;	state Exp;
branches;
next	1.102;

1.102
date	2003.10.28.21.35.41;	author morevit;	state Exp;
branches;
next	1.101;

1.101
date	2003.10.28.12.07.56;	author katsyonak;	state Exp;
branches;
next	1.100;

1.100
date	2003.10.28.10.09.30;	author katsyonak;	state Exp;
branches;
next	1.99;

1.99
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.98;

1.98
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.97;

1.97
date	2003.10.21.15.41.05;	author netwolf1;	state Exp;
branches;
next	1.96;

1.96
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.95;

1.95
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.94;

1.94
date	2003.10.13.15.13.05;	author morevit;	state Exp;
branches;
next	1.93;

1.93
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.92;

1.92
date	2003.10.03.10.40.54;	author dongato;	state Exp;
branches;
next	1.91;

1.91
date	2003.09.26.18.37.34;	author bavariansnail;	state Exp;
branches;
next	1.90;

1.90
date	2003.09.24.20.37.32;	author dongato;	state Exp;
branches;
next	1.89;

1.89
date	2003.09.23.20.26.30;	author dongato;	state Exp;
branches;
next	1.88;

1.88
date	2003.09.23.16.52.51;	author morevit;	state Exp;
branches;
next	1.87;

1.87
date	2003.09.21.22.05.20;	author morevit;	state Exp;
branches;
next	1.86;

1.86
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.85;

1.85
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.84;

1.84
date	2003.09.07.02.24.57;	author syrus77;	state Exp;
branches;
next	1.83;

1.83
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.82;

1.82
date	2003.08.26.22.14.04;	author syrus77;	state Exp;
branches;
next	1.81;

1.81
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	1.80;

1.80
date	2003.08.16.17.57.38;	author eklmn;	state Exp;
branches;
next	1.79;

1.79
date	2003.08.15.15.14.51;	author forcha;	state Exp;
branches;
next	1.78;

1.78
date	2003.08.13.15.55.27;	author eklmn;	state Exp;
branches;
next	1.77;

1.77
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.76;

1.76
date	2003.08.04.21.24.38;	author zegzav;	state Exp;
branches;
next	1.75;

1.75
date	2003.08.03.21.07.03;	author forcha;	state Exp;
branches;
next	1.74;

1.74
date	2003.07.28.14.57.52;	author dongato;	state Exp;
branches;
next	1.73;

1.73
date	2003.07.11.00.58.02;	author emoulari;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.08.00.04.59;	author netwolf1;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.04.19.14.21;	author syrus77;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.25.01.42.07;	author netwolf1;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.20.22.04.51;	author syrus77;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.19.07.47.47;	author partyckip;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.16.04.44.44;	author partyckip;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.16.02.04.34;	author netwolf1;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.15.09.09.28;	author partyckip;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.11.18.27.14;	author eklmn;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.09.21.59.36;	author partyckip;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.09.00.31.11;	author syrus77;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.08.18.06.18;	author partyckip;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.01.15.49.33;	author kuchin;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.01.10.08.44;	author partyckip;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.01.09.28.05;	author partyckip;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.31.15.38.57;	author partyckip;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.31.08.50.55;	author partyckip;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.27.04.32.11;	author partyckip;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.26.22.54.24;	author partyckip;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.26.22.15.44;	author partyckip;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.26.11.25.20;	author syrus77;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.25.14.32.01;	author syrus77;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.23.00.16.42;	author syrus77;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.20.20.46.34;	author netwolf1;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.20.09.06.49;	author netwolf1;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.18.03.43.24;	author syrus77;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.17.13.56.10;	author syrus77;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.15.22.03.56;	author syrus77;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.12.09.13.25;	author kuchin;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.11.14.46.06;	author kuchin;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.11.11.37.49;	author kuchin;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.09.23.07.44;	author moosetea;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.08.17.08.27;	author netwolf1;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.08.08.21.34;	author partyckip;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.06.23.11.21;	author moosetea;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.26.19.46.45;	author lord_kiron;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.26.17.39.15;	author lord_kiron;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.22.12.41.52;	author kuchin;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.19.07.17.00;	author kuchin;	state Exp;
branches;
next	1.33;

1.33
date	2003.04.13.17.48.31;	author kuchin;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.22.01.14.00;	author cax2;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2003.03.19.11.02.42;	author dongato;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.14.22.49.01;	author lord_kiron;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.14.14.19.30;	author lord_kiron;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.13.19.17.43;	author emoulari;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.13.15.51.57;	author cax2;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.11.00.34.10;	author cax2;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.08.12.09.43;	author recdvst;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.06.21.01.53;	author obaldin;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.03.22.10.10;	author moosetea;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.26.21.33.12;	author obaldin;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.20.07.25.22;	author cax2;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.02.20.00.34.18;	author dongato;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.16.22.01.52;	author lord_kiron;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.15.09.00.18;	author lord_kiron;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.14.16.35.13;	author lord_kiron;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.14.15.33.35;	author lord_kiron;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.14.15.20.16;	author lord_kiron;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.14.14.18.05;	author lord_kiron;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.14.13.54.13;	author lord_kiron;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.14.13.24.30;	author lord_kiron;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.14.12.22.36;	author lord_kiron;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.13.20.56.41;	author lord_kiron;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.13.18.00.09;	author lord_kiron;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.12.20.18.24;	author obaldin;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.12.14.11.12;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.11.19.38.50;	author lord_kiron;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.11.17.52.20;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.10.19.24.53;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.15.05.41;	author cax2;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2003.01.21.18.21.25;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.41;	author cax2;	state Exp;
branches;
next	;

1.2.4.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.21.2.1
date	2003.02.28.22.44.57;	author obaldin;	state Exp;
branches;
next	;

1.32.2.1
date	2003.03.23.06.22.03;	author recdvst;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2003.03.24.09.39.45;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.254
log
@Added Windows 7 OS detection in case it's required for future; Slightly optimized main encryption routine.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "otherfunctions.h"
#include "updownclient.h"
#ifndef NEW_SOCKETS_ENGINE
#include "emule.h"
#endif //NEW_SOCKETS_ENGINE
#include "memcpy_amd.h"
#include "StringConversion.h"
#include <share.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

const TCHAR g_acHexDigits[16] =
{
	_T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'),
	_T('8'), _T('9'), _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F')
};

static const byte base32Chars[32] = {
	'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
	'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7'
};

CString __stdcall CastItoXBytes(uint64 qwNum)
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	CString		strBuffer;
	double		dNum;

	if (qwNum <= 0xFFFFFFFFui64)
	{
		uint32	dwNum = static_cast<uint32>(qwNum);

		if (dwNum < 1024)
			strBuffer.Format(_T("%u %s"), dwNum, GetResString(IDS_BYTES));
		else
		{
			dNum = static_cast<double>(dwNum);
			if (dwNum < (1024 * 1024))
				strBuffer.Format( (g_App.m_pPrefs->ShowRoundSizes()) ? _T("%.f %s") : _T("%.2f %s"),
					dNum / 1024.0, GetResString(IDS_KBYTES) );
			else if (dwNum < (1024 * 1024 * 1024))
				strBuffer.Format(_T("%.2f %s"), dNum / (1024.0 * 1024.0), GetResString(IDS_MBYTES));
			else
				strBuffer.Format(_T("%.2f %s"), dNum / (1024.0 * 1024.0 * 1024.0), GetResString(IDS_GBYTES));
		}
	}
	else
	{
		dNum = static_cast<double>(qwNum);
		if (qwNum < 1099511627776)
			strBuffer.Format(_T("%.2f %s"), dNum / (1024.0 * 1024.0 * 1024.0), GetResString(IDS_GBYTES));
		else
			strBuffer.Format(_T("%.3f %s"), dNum / 1099511627776.0, GetResString(IDS_TBYTES));
	}

	if (g_App.m_pPrefs->ShowRoundSizes())
	{
		CString	strDecimalPoint = GetLocalDecimalPoint();
		int		iPos2, iPos1 = strBuffer.Find(strDecimalPoint);

		if (iPos1 >= 0)
		{
			iPos2 = strBuffer.Find(_T(' '), iPos1 + strDecimalPoint.GetLength());
			if (iPos2 >= 0)
			{
				while (strBuffer.GetAt(--iPos2) == _T('0'))
					strBuffer.Delete(iPos2, 1);
				if (iPos2 == iPos1)
					strBuffer.Delete(iPos1, strDecimalPoint.GetLength());
			}
		}
	}

	return strBuffer;
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH2

	return _T("");
}

CString __stdcall CastItoIShort(uint64 qwCount)
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	CString	strBuffer;
	double	dNum;

	if (qwCount < 1000000000)
	{
		uint32	dwNum = static_cast<uint32>(qwCount);

		if (dwNum < 1000)
			strBuffer.Format(_T("%u"), dwNum);
		else
		{
			dNum = static_cast<double>(dwNum);
			if (dwNum < 1000000)
				strBuffer.Format(g_App.m_pPrefs->ShowRoundSizes() ? _T("%.f%s") : _T("%.2f%s"), dNum / 1000.0, GetResString(IDS_KILO));
			else
				strBuffer.Format(_T("%.2f%s"), dNum / 1000000.0, GetResString(IDS_MEGA));
		}
	}
	else
	{
		dNum = static_cast<double>(qwCount);
		if (qwCount < 1000000000000)
			strBuffer.Format(_T("%.2f%s"), dNum / 1000000000.0, GetResString(IDS_GIGA));
		else if (qwCount < 1000000000000000)
			strBuffer.Format(_T("%.2f%s"), dNum / 1000000000000.0, GetResString(IDS_TERRA));
	}

	return strBuffer;
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH2

	return _T("");
}

CString __stdcall CastSecondsToHM(sint32 iCount)
{
#ifndef NEW_SOCKETS_ENGINE
	CString	strBuffer;

	if (iCount < 0)
		strBuffer = _T("?");
	else if (iCount < 60)
		strBuffer.Format(_T("%u %s"), iCount, GetResString(IDS_SECS));
	else if (iCount < 3600)
		strBuffer.Format(_T("%u:%02u %s"), iCount / 60, iCount - (iCount / 60) * 60, GetResString(IDS_MINS));
	else if (iCount < 86400)
		strBuffer.Format(_T("%u:%02u %s"), iCount / 3600, (iCount - (iCount / 3600) * 3600) / 60, GetResString(IDS_HOURS));
	else
		strBuffer.Format(_T("%u %s %u %s"), iCount / 86400, GetResString(IDS_DAYS),  (iCount - (iCount / 86400) * 86400) / 3600, GetResString(IDS_HOURS));

	return strBuffer;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

CString __stdcall CastSecondsToLngHM(uint32 dwSecs)
{
#ifndef NEW_SOCKETS_ENGINE
	CString	strBuffer;

	if (dwSecs < 86400)
	{
		if (dwSecs < 3600)
		{
			if (dwSecs < 60)
				strBuffer.Format(_T("%u %s"), dwSecs, GetResString(IDS_LONGSECS));
			else
				strBuffer.Format(_T("%u:%02u %s"), dwSecs / 60, static_cast<uint32>(dwSecs - (dwSecs / 60) * 60), GetResString(IDS_LONGMINS));
		}
		else
			strBuffer.Format(_T("%u:%02u %s"), dwSecs / 3600, static_cast<uint32>((dwSecs - (dwSecs / 3600) * 3600) / 60), GetResString(IDS_LONGHRS));
	}
	else
	{
		uint32	dwCntDays = dwSecs / 86400;
		uint32	dwCntHrs = (dwSecs - dwCntDays * 86400u) / 3600u;
		uint32	dwCntMins = ((dwSecs - (dwCntDays * 86400u)) - (dwCntHrs * 3600u)) / 60u;

		CString strDay = GetResString((dwCntDays > 1) ? IDS_LONGDAYS : IDS_LONGDAY);

		if (dwCntHrs != 0)
			strBuffer.Format(_T("%u %s %u:%02u %s"), dwCntDays, strDay, dwCntHrs, dwCntMins, GetResString(IDS_LONGHRS));
		else
			strBuffer.Format(_T("%u %s %02u %s"), dwCntDays, strDay, dwCntMins, GetResString(IDS_LONGMINS));
	}
	return strBuffer;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

// Credits: adapted from http://www.codeguru.com/string/long2string.html
CString __stdcall CastItoThousands(sint64 iVal)
{
	EMULE_TRY

	CString		strBuffer;
	uint32		dwDigVal;
	CString		strThousandSeparator = GetLocalThousandsSep();
	int			iIndex, iDecimalPos = 0;

	if (iVal < 0)
	{
		strBuffer = GetLocalNegativeSign();
		iVal = -iVal;
	}
	iIndex = strBuffer.GetLength();

	do
	{
		if (++iDecimalPos != 4)
		{
			dwDigVal = (uint32)(iVal % 10);
			iVal /= 10;
			strBuffer.Insert(iIndex, static_cast<TCHAR>(dwDigVal + _T('0')));
		}
		else
		{
			strBuffer.Insert(iIndex, strThousandSeparator);
			iDecimalPos = 0;
		}
	} while (iVal > 0);

	return strBuffer;

	EMULE_CATCH2

	return _T("");
}

void ShellOpenFile(const CString& name)
{
	EMULE_TRY
	ShellExecute(NULL, _T("open"), name, NULL, NULL, SW_SHOW);
	EMULE_CATCH
}

CString __stdcall GetResString(UINT dwStringID)
{
#ifndef NEW_SOCKETS_ENGINE
	HINSTANCE	hMod = ::GetModuleHandle(NULL);
	CString		strResString;

	if (!strResString.LoadString(hMod, dwStringID, g_App.m_pPrefs->GetLanguageID()))
		strResString.LoadString(hMod, dwStringID, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT));
	return strResString;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

CString __stdcall GetResString(UINT dwStringID, WORD uLanguageID)
{
#ifndef NEW_SOCKETS_ENGINE
	HINSTANCE	hMod = ::GetModuleHandle(NULL);
	CString		strResString;

	if (!strResString.LoadString(hMod, dwStringID, uLanguageID))
		strResString.LoadString(hMod, dwStringID, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT));
	return strResString;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetResString() loads default language resource string into already existing string.
__declspec(noinline) void __stdcall GetResString(CString *pstrOutput, UINT dwStringID)
{
#ifndef NEW_SOCKETS_ENGINE
	HINSTANCE hMod = ::GetModuleHandle(NULL);

	if (!pstrOutput->LoadString(hMod, dwStringID, g_App.m_pPrefs->GetLanguageID()))
		pstrOutput->LoadString(hMod, dwStringID, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT));
#endif //NEW_SOCKETS_ENGINE
}

bool CheckIsRegistrySet()
{
	EMULE_TRY

	CRegKey	regkey;

	regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\shell\\open\\command"));

	TCHAR	acBuffer[500];
	ULONG	dwSize = ARRSIZE(acBuffer);
	LONG	iRet;

	if ((iRet = regkey.QueryStringValue(NULL, acBuffer, &dwSize)) != ERROR_SUCCESS)
		return false;

	TCHAR	acMod[MAX_PATH];

	if (::GetModuleFileName(NULL, acMod, MAX_PATH) == 0)
		return false;

	CString	strReg = _T("\"");

	strReg += acMod;
	strReg += _T("\" \"%1\"");

	return (strReg == acBuffer);

	EMULE_CATCH

	return false;
}

static void BackupReg(void)
{
	EMULE_TRY
	// Look for pre-existing old ed2k links
	CRegKey regkey;
	regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\shell\\open\\command"));

	TCHAR rbuffer[500];
	ULONG maxsize = ARRSIZE(rbuffer);
	// Is it ok to write new values
	if ((regkey.QueryStringValue(_T("OldDefault"), rbuffer, &maxsize) != ERROR_SUCCESS) || (maxsize == 0))
	{
		maxsize = ARRSIZE(rbuffer);
		regkey.QueryStringValue(0, rbuffer, &maxsize);
		regkey.SetStringValue(_T("OldDefault"), rbuffer);
		regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\DefaultIcon") );
		maxsize = ARRSIZE(rbuffer);
		if (regkey.QueryStringValue(0, rbuffer, &maxsize) == ERROR_SUCCESS)
			regkey.SetStringValue(_T("OldIcon"), rbuffer);
	}
	regkey.Close();
	EMULE_CATCH
}

bool Ask4RegFix(bool bDontAsk)
{
	EMULE_TRY

	BackupReg();
#ifndef NEW_SOCKETS_ENGINE

//	Check registry if ed2k links is assigned to emule
	if (!CheckIsRegistrySet())
	{
		if (bDontAsk || (AfxMessageBox(GetResString(IDS_ASSIGNED2K), MB_ICONQUESTION | MB_YESNO) == IDYES))
		{
			CRegKey	regkey;
			TCHAR	acMod[MAX_PATH];

			if (::GetModuleFileName(NULL, acMod, MAX_PATH) == 0)
				return false;

			CString	strReg = _T("\"");

			strReg += acMod;
			strReg += _T("\" \"%1\"");

			regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\shell\\open\\command"));
			regkey.SetStringValue(0, strReg);
			regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\DefaultIcon"));
			regkey.SetStringValue(0, strReg);
			regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k") );
			regkey.SetStringValue(0, _T("URL: ed2k Protocol"));
			regkey.SetStringValue(_T("URL Protocol"), _T(""));
			regkey.Close();
		}
	}
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH

	return false;
}

void RevertReg(void)
{
	EMULE_TRY
	// restore previous ed2k links before being assigned to emule
	CRegKey regkey;
	regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\shell\\open\\command"));
	TCHAR rbuffer[500];
	ULONG maxsize = ARRSIZE(rbuffer);

	if (regkey.QueryStringValue(_T("OldDefault"), rbuffer, &maxsize) == ERROR_SUCCESS)
	{
		regkey.SetStringValue(0, rbuffer);
		regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\DefaultIcon") );
		regkey.DeleteValue(_T("OldDefault"));
		maxsize = ARRSIZE(rbuffer);
		if (regkey.QueryStringValue(_T("OldIcon"), rbuffer, &maxsize) == ERROR_SUCCESS)
		{
			regkey.SetStringValue(0, rbuffer);
			regkey.DeleteValue(_T("OldIcon"));
		}
	}
	regkey.Close();
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetMaxConnections() determines a reasonable maximum number of connections based on the OS version.
int GetMaxConnections()
{
	OSVERSIONINFO osvi;

	osvi.dwOSVersionInfoSize = sizeof(osvi);
	GetVersionEx(&osvi);

	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)// Windows 95 product family
	{
		if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)//old school 95
		{
			HKEY hKey;
			DWORD dwValue;
			DWORD dwLength = sizeof(dwValue);
			LONG lResult;

		//	Read the OS' max connection setting from the Registry
			RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\VxD\\MSTCP"),
				0, KEY_QUERY_VALUE, &hKey);
			lResult = RegQueryValueEx(hKey, TEXT("MaxConnections"), NULL, NULL,
				(LPBYTE)&dwValue, &dwLength);
			RegCloseKey(hKey);

			if(lResult != ERROR_SUCCESS || lResult < 1)
				return 100;  //the default for 95 is 100

			return dwValue;
		}
		else
		{ //98 or ME
			HKEY hKey;
			TCHAR szValue[32];
			DWORD dwLength = sizeof(szValue);
			LONG lResult;

		//	Read the OS' max connection setting from the Registry
			RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\VxD\\MSTCP"),
				0, KEY_QUERY_VALUE, &hKey);
			lResult = RegQueryValueEx(hKey, TEXT("MaxConnections"), NULL, NULL,
				(LPBYTE)szValue, &dwLength);
			RegCloseKey(hKey);

			LONG lMaxConnections;

			if(lResult != ERROR_SUCCESS || (lMaxConnections = _tstoi(szValue)) < 1)
				return 100;  //the default for 98/ME is 100

			return lMaxConnections;
		}
	}
	return -1;  //no limits (Windows NT product family)
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
WORD DetectWinVersion(bool *pbNTBased)
{
	*pbNTBased = false;

	OSVERSIONINFO osvi;

	osvi.dwOSVersionInfoSize = sizeof(osvi);
	GetVersionEx(&osvi);

	switch(osvi.dwPlatformId)
	{
		case VER_PLATFORM_WIN32_NT:
			*pbNTBased = true;

			if (osvi.dwMajorVersion <= 4)
				return _WINVER_NT4_;
			if (osvi.dwMajorVersion == 5)
			{
				if (osvi.dwMinorVersion == 0)
					return _WINVER_2K_;
				if (osvi.dwMinorVersion == 1)
					return _WINVER_XP_;
				if (osvi.dwMinorVersion == 2)	//	Windows Server 2003
					return _WINVER_SE_;
			}
			else if (osvi.dwMajorVersion == 6)
			{
				if (osvi.dwMinorVersion == 0)
					return _WINVER_VISTA_;
				if (osvi.dwMinorVersion == 1)
					return _WINVER_WIN7_;
			//	Following versions of this family will be probably closer to Vista than to XP
				return _WINVER_VISTA_;
			}
			return _WINVER_XP_;	//	Never return Win95 if we get the info about a NT system

		case VER_PLATFORM_WIN32_WINDOWS:
			if (osvi.dwMajorVersion == 4)
			{
				if (osvi.dwMinorVersion == 0)
					return _WINVER_95_;
				if (osvi.dwMinorVersion == 10)
					return _WINVER_98_;
				if (osvi.dwMinorVersion == 90)
					return _WINVER_ME_;
			}

		default:
			break;
	}
	return _WINVER_95_;		// there shouldn't be anything lower than this
}

uint64 GetFreeDiskSpaceX(LPCTSTR pDirectory)
{
	static BOOL	_bInitialized = FALSE;
	static BOOL	(WINAPI *_pGetDiskFreeSpaceEx)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER) = NULL;

	if (!_bInitialized)
	{
		_bInitialized = TRUE;
#ifdef _UNICODE
		(FARPROC&)_pGetDiskFreeSpaceEx = GetProcAddress(GetModuleHandle(_T("kernel32.dll")), "GetDiskFreeSpaceExW");
#else
		(FARPROC&)_pGetDiskFreeSpaceEx = GetProcAddress(GetModuleHandle(_T("kernel32.dll")), "GetDiskFreeSpaceExA");
#endif
	}

	if (_pGetDiskFreeSpaceEx != NULL)
	{
		ULARGE_INTEGER	qwFreeDiskSpace, qwDummy;

		_pGetDiskFreeSpaceEx(pDirectory, &qwFreeDiskSpace, &qwDummy, NULL);
		return qwFreeDiskSpace.QuadPart;
	}
	else
	{
		TCHAR	acDrive[16];
		const TCHAR	*p = _tcschr(pDirectory, _T('\\'));

		if (p != NULL)
		{
			memcpy2(acDrive, pDirectory, (p - pDirectory) * sizeof(TCHAR));
			acDrive[p - pDirectory] = _T('\0');
		}
		else
			_tcscpy(acDrive, pDirectory);

		DWORD	dwSectPerClust, dwBytesPerSect, dwFreeClusters, dwDummy;

		if (GetDiskFreeSpace(acDrive, &dwSectPerClust, &dwBytesPerSect, &dwFreeClusters, &dwDummy))
			return (static_cast<uint64>(dwFreeClusters) * dwSectPerClust * dwBytesPerSect);
		else
			return 0;
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FillImgLstWith16x16Icons() fills image list with 16x16 icons.
//		Params:
//			pImgLst     - image list to fill;
//			uResIDs     - array of icon resource IDs;
//			uiResAmount - number of icons in array.
void __stdcall FillImgLstWith16x16Icons(CImageList *pImgLst, const uint16 *uResIDs, unsigned uiResAmount)
{
	HINSTANCE hInst = AfxGetInstanceHandle();

	for (unsigned ui = 0; ui < uiResAmount; ui++)
	{
		HICON	hIcon = reinterpret_cast<HICON>(::LoadImage(hInst, MAKEINTRESOURCE(uResIDs[ui]), IMAGE_ICON, 16, 16, 0));

		pImgLst->Add(hIcon);
	//	This resource isn't required anymore, unload it
		::DestroyIcon(hIcon);
	}
}

CString GetRatingString(EnumPartFileRating nRating)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY
	switch (nRating)
	{
	case PF_RATING_NONE:
		return GetResString(IDS_CMT_NOTRATED);
		break;
	case PF_RATING_FAKE:
		return GetResString(IDS_CMT_FAKE);
		break;
	case PF_RATING_POOR:
		return GetResString(IDS_CMT_POOR);
		break;
	case PF_RATING_GOOD:
		return GetResString(IDS_CMT_GOOD);
		break;
	case PF_RATING_FAIR:
		return GetResString(IDS_CMT_FAIR);
		break;
	case PF_RATING_EXCELLENT:
		return GetResString(IDS_CMT_EXCELLENT);
		break;
	}
	EMULE_CATCH
	return GetResString(IDS_CMT_NOTRATED);
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

// Returns a BASE32 encoded byte array
//
// [In]
//   buffer: Pointer to byte array
//   bufLen: Lenght of buffer array
//
// [Return]
//   CString object with BASE32 encoded byte array
CString EncodeBase32(const unsigned char* buffer, unsigned int bufLen)
{
	CString	strBase32Buff;
	unsigned int i, index;
	unsigned char word;

	for(i = 0, index = 0; i < bufLen;)
	{
		// Is the current word going to span a byte boundary?
		if (index > 3)
		{
			word = static_cast<byte>(buffer[i] & (0xFF >> index));
			index = (index + 5) % 8;
			word <<= index;
			if (i < bufLen - 1)
				word |= buffer[i + 1] >> (8 - index);
			i++;
		}
		else
		{
			word = static_cast<byte>((buffer[i] >> (8 - (index + 5))) & 0x1F);
			index = (index + 5) % 8;
			if (index == 0)
				i++;
		}

		strBase32Buff += (TCHAR)base32Chars[word];
	}

	return strBase32Buff;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
unsigned DecodeBase32(const TCHAR *pcInStr, unsigned uiInLen, byte *pbyteOutput, unsigned uiBufSz)
{
	unsigned	uiDecodeLen, uiCh, uiBits = 0, uiCnt = 0;

	if (pcInStr == NULL)
		return 0;

	uiDecodeLen = (5 * uiInLen) / 8;	//process only complete hash bytes
	if (uiDecodeLen != uiBufSz)
		return 0;

	while ((int)--uiInLen >= 0)
	{
		uiCh = *pcInStr++;
		if ((uiCh <= _T('7')) && (uiCh >= _T('2')))
			uiBits |= uiCh - _T('2') + _T('Z') - _T('A') + 1;
		else
		{
			uiCh = CHR2UP(uiCh);
			if ((uiCh >= _T('A')) && (uiCh <= _T('Z')))
				uiBits |= uiCh - _T('A');
			else
				return 0;
		}
		
		if ((uiCnt += 5) >= 8)
		{
			uiCnt -= 8;
			*pbyteOutput++ = static_cast<byte>(uiBits >> uiCnt);
		}
		uiBits <<= 5;
	}

	return uiDecodeLen;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int UpdateURLMenu(CMenu &menu)
{
	int iNumURLs = 0;

	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	g_App.m_strWebServiceURLArray.RemoveAll();

	TCHAR	acBuf[1024];
	FILE	*pWebServiceFile = _tfsopen(g_App.m_pPrefs->GetConfigDir() + _T("webservices.dat"), _T("r"), _SH_DENYWR);

	if (pWebServiceFile != NULL)
	{
		CString	strBuffer;

	//	Until we've read the last line...
		while (feof(pWebServiceFile) == 0)
		{
		//	Try to get a line from the web services file. If we fail...
			if (_fgetts(acBuf, ARRSIZE(acBuf), pWebServiceFile) == 0)
				break;
			if (*acBuf == _T('#') || *acBuf == _T('/'))	// Ignore comments
				continue;
			strBuffer = acBuf;
			if (strBuffer.GetLength() < 5)	// Ignore too short lines
				continue;

			if (strBuffer == _T("<separator>\n") || strBuffer == _T("<separator>"))
				menu.AppendMenu(MF_SEPARATOR);
			else
			{
				int	iPos = strBuffer.Find(_T(','));

				if (iPos > 0 && iNumURLs < 64)
				{
					menu.AppendMenu(MF_STRING, MP_WEBURL + iNumURLs++, strBuffer.Left(iPos).Trim());
					g_App.m_strWebServiceURLArray.Add(strBuffer.Right(strBuffer.GetLength() - iPos - 1).Trim());
				}
			}
		}
		fclose(pWebServiceFile);
	}
#endif //NEW_SOCKETS_ENGINE
	EMULE_CATCH

	return iNumURLs;
}

static CString ReplaceDotsWithSpaces(CString strIn, CString exceptStr, CString addClear, bool keepExt)
{
	//with standard-params simply all dots are replaced with spaces :)
	//dots won't be replaced between 2 chars of exceptStr (numbers for versions and dates)
	//if u want to replace additional chars with spaces set addClear (invalid & nonsense chars)
	//set keepExt=true for keeping the extension-dot
	EMULE_TRY
	int extpos = strIn.ReverseFind(_T('.'));
	int max = strIn.GetLength() - 1;
	for (int pos = 0; pos <= max; pos++)
	{
		if (strIn.GetAt(pos) == _T('.'))
		{
			//replace dot at beginning and end
			if (pos == 0 || pos == max)
				strIn.SetAt(pos, _T(' '));
			//replace dot only if not between 2 chars of exceptStr
			else if (exceptStr.Find(strIn.GetAt(pos-1)) < 0 || exceptStr.Find(strIn.GetAt(pos+1)) < 0)
				strIn.SetAt(pos, _T(' '));
		}
		//replace chars from addClear with space, too
		else if (addClear.Find(strIn.GetAt(pos)) >= 0)
			strIn.SetAt(pos, _T(' '));
	}
	if (keepExt && extpos >= 0)
		strIn.SetAt(extpos, _T('.'));
	EMULE_CATCH
	return strIn;
}

static CString DeleteNonAlphaNumeric(CString inStr, CString exceptStr, bool onlyRep)
{
	//with standard-params output simply won't contain any nonalphanumeric chars
	//set exceptStr to chars u don't want to be deleted (i.e. pipe as separator-char "|")
	//if onlyRep==true only repeated non-alphanumeric chars will be reduced to one occurence
	//if onlyRep==false all non-alphanumeric chars are deleted except the allowed ones in exceptStr
	EMULE_TRY
	TCHAR curChar;
	int pos = 0;
	while (pos < inStr.GetLength())
	{
		curChar = inStr.GetAt(pos);
		if (!IsCharAlphaNumeric(curChar) && exceptStr.Find(curChar) < 0
		&& (!onlyRep || (pos+1 < inStr.GetLength() && inStr.Find(curChar, pos+1) == pos+1 )))
			inStr.Delete(pos);
		else
			pos++;
	}
	EMULE_CATCH
	return inStr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ExtractTitle() extracts title from the file name
static CString ExtractTitle(const CString &strIn)
{
	static const TCHAR s_acDelim[] = {
		_T('['), _T(']'), _T('('), _T(')'), _T('{'), _T('}')
	};
	static const TCHAR *s_apcTailAd[] = {
		_T("dvd"), _T("divx"), _T("xvid"), _T("ac3"), _T("mp3"), _T("vcd"), _T("svcd"),
		_T("dvb"), _T("vh-prod"), _T("vhs")
	};
	static const TCHAR *s_apcTailWords[] = {
		_T("proper"), _T("internal"), _T("int"), _T("uncut")
	};
	CString		strName(URLDecode(strIn).MakeLower());
	CString		strToken;
	int			iTkPos, iPos;
	TCHAR		cCh;
	unsigned	ui;

	iPos = strName.ReverseFind(_T('.'));
	if (iPos >= 0)
		strName.Truncate(iPos);	//	cut off extension

//	CD# is usually after the title, cut off by it
	for (iTkPos = 0;;)
	{
		if ((iPos = strName.Find(_T("cd"), iTkPos)) <= 0)
			break;
		cCh = strName.GetString()[iPos + CSTRLEN(_T("cd"))];
		if (static_cast<unsigned>(cCh - _T('0')) <= 9u)
		{
			strName.Truncate(iPos);
			break;
		}
		iTkPos = iPos + 1;
	}

//	Format specifiers are usually after the title, cut off by them
	for (ui = 0; ui < ARRSIZE(s_apcTailAd); ui++)
	{
		if ((iPos = strName.Find(s_apcTailAd[ui])) <= 0)
			continue;
		strName.Truncate(iPos);
	}

	CString	strList(g_App.m_pPrefs->GetFilenameCleanups().MakeLower());	//list of pipe-separated tokens

	for (iTkPos = 0;;)
	{
		strToken = strList.Tokenize(_T("|"), iTkPos);
		if (strToken.IsEmpty())
			break;
	//	As ads is normally at the end, cut off by it
		if ((iPos = strName.Find(strToken)) > 0)
			strName.Truncate(iPos);
	}

//	Take out everything in brackets
	for (ui = 0; ui < ARRSIZE(s_acDelim); ui += 2)
	{
		for (;;)
		{
			iPos = strName.Find(s_acDelim[ui]);
			if (iPos < 0)
				break;
			iTkPos = strName.Find(s_acDelim[ui + 1], iPos);
			if (iTkPos > 0)
			//	Closing bracket is left for ReplaceDotsWithSpaces to be replaced with a space
				strName.Delete(iPos, iTkPos - iPos);
			else
				strName.Truncate(iPos);
		}
	}

	strName = ReplaceDotsWithSpaces(strName, _T(""), _T("_+\\\"/:*?<>|-&@@#=,])}"), false);
	strName = DeleteNonAlphaNumeric(strName, _T(""), true);	// reduce doubles

	strName.Trim();

//	Remove specific words from the tail
	iPos = strName.ReverseFind(_T(' '));
	if (iPos >= 0)
	{
		for (ui = 0; ui < ARRSIZE(s_apcTailWords); ui++)
		{
			if (_tcscmp(&strName.GetString()[iPos + 1], s_apcTailWords[ui]) == 0)
			{
				strName.Truncate(iPos);
				break;
			}
		}
	}

//	Remove year at the end
	iPos = strName.ReverseFind(_T(' '));
	if (iPos >= 0)
	{
		cCh = strName.GetString()[iPos + 1];
		if (static_cast<unsigned>(cCh - _T('0')) <= 9u)
		{
			ui = _tstoi(&strName.GetString()[iPos + 1]);
			if ((ui - 1900u) < (2099u - 1900u))	// check centures
				strName.Truncate(iPos);
		}
	}

	return strName;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void RunURL(CAbstractFile* pFile, CString srtURLPattern)
{
	EMULE_TRY
	if (pFile != NULL)
	{
	//	Convert hash to hexadecimal text and add it to the URL
		srtURLPattern.Replace(_T("#hashid"), HashToString(pFile->GetFileHash()));

	//	Add file size to the URL
		CString strTemp;
		strTemp.Format(_T("%I64u"), pFile->GetFileSize());
		srtURLPattern.Replace(_T("#filesize"), strTemp);

	//	Add filename to the URL
		srtURLPattern.Replace(_T("#filename"), URLEncode(pFile->GetFileName()));

	//	Add cleaned up name to the URL
		srtURLPattern.Replace(_T("#cleanname"), URLEncode(ExtractTitle(pFile->GetFileName())));
	}

//	Replace "|" for Mozilla compatibility
	srtURLPattern.Replace(_T("|"), _T("%7C"));

//	Open URL
#ifndef NEW_SOCKETS_ENGINE
	ShellExecute(NULL, NULL, srtURLPattern, NULL, g_App.m_pPrefs->GetAppDir(), SW_SHOWDEFAULT);
#endif //NEW_SOCKETS_ENGINE
	EMULE_CATCH
}

CString GetClientVersionString(EnumClientTypes eClienType, uint32 dwVersion)
{
#ifndef NEW_SOCKETS_ENGINE
	if (dwVersion == 0)
		return _T("v ?");

	CString	strBuff;
	uint32	dwMajVer = GET_CLIENT_MAJVER(dwVersion);
	uint32	dwMinVer = GET_CLIENT_MINVER(dwVersion);
	uint32	dwUpdVer = GET_CLIENT_UDPVER(dwVersion);

	switch(eClienType)
	{
		case SO_PLUS:
			strBuff.Format(_T("v%u"), dwMajVer);
			if (dwMinVer != 0)
				strBuff.AppendFormat(_T(".%u"), dwMinVer);
			if (dwUpdVer != 0)
				strBuff += static_cast<TCHAR>(_T('a') + dwUpdVer - 1);
			break;
		case SO_EMULE:
			if ((dwVersion >= FORM_CLIENT_VER(0, 40, 0)) && (dwUpdVer < 26))
			{
				strBuff.Format(_T("v%u.%u%c"), dwMajVer, dwMinVer, _T('a') + dwUpdVer);
				break;
			}
		default:
			if ((dwUpdVer != 0) || ((eClienType == SO_AMULE) && (dwVersion >= FORM_CLIENT_VER(0, 40, 0))))
				strBuff.Format(_T("v%u.%u.%u"), dwMajVer, dwMinVer, dwUpdVer);
			else
				strBuff.Format(_T("v%u.%u"), dwMajVer, dwMinVer);
			break;
	}
	return strBuff;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

CString StringLimit(const CString& in, unsigned uiLen)
{
	if ((static_cast<unsigned>(in.GetLength()) <= uiLen) || (uiLen <= (1u + 3u + 8u)))
		return in;
	return (in.Left(uiLen - 8) + _T("...") + in.Right(8));
}

CString ConcatFullPath(const CString &strPath, const CString &strFname)
{
	if (strPath.Right(1) == _T('\\'))
		return (strPath + strFname);
	else
		return (strPath + _T('\\') + strFname);
}

void GetStatusULQueueString(CString *pstrOut, EnumULQState State)
{
#ifndef NEW_SOCKETS_ENGINE
	static const uint16 s_auResTbl[] =
	{
		IDS_TRANSFERRING,		//US_UPLOADING
		IDS_ONQUEUE,			//US_ONUPLOADQUEUE
		IDS_CONNECTING,			//US_CONNECTING
		IDS_BANNED,				//US_BANNED
		IDS_UNKNOWN				//US_NONE
	};
	unsigned	uiState = State;

	if (uiState >= ARRSIZE(s_auResTbl))
		uiState = US_NONE;
	GetResString(pstrOut, s_auResTbl[uiState]);
#else
	*pstrOut = _T("");
#endif //NEW_SOCKETS_ENGINE
}

CString GetClientNameString(EnumClientTypes eClientType)
{
	static const TCHAR s_acNames[][10] =
	{
		_T("Plus"),		//SO_PLUS
		_T("eMule"),	//SO_EMULE
		_T("aMule"),	//SO_AMULE
		_T("Hybrid"),	//SO_EDONKEYHYBRID
		_T("eDonkey"),	//SO_EDONKEY
		_T("MLdonkey"),	//SO_MLDONKEY
		_T(""),			//SO_OLDEMULE
		_T("Shareaza"),	//SO_SHAREAZA
		_T("xMule"),	//SO_XMULE
		_T("lphant")	//SO_LPHANT
	};
	CString	strName;
	uint32	dwClientType = static_cast<uint32>(eClientType);

	if (dwClientType < SO_UNKNOWN)
		strName = reinterpret_cast<const TCHAR*>(&s_acNames[dwClientType]);
#ifndef NEW_SOCKETS_ENGINE
	else
		GetResString(&strName, IDS_UNKNOWN);
#endif //NEW_SOCKETS_ENGINE

	return strName;
}

int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
	NOPRM(lParam);

	if ((uMsg == BFFM_INITIALIZED) && lpData)
		::SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);

	return 0;
}

CString BrowseFolder(HWND hwndOwner, LPCTSTR pszTitle, LPCTSTR pszStartFolder)
{
	CString retstring(pszStartFolder);
	EMULE_TRY
	TCHAR pszDisplayName[MAX_PATH];
	LPITEMIDLIST lpID;
	BROWSEINFO bi;

	bi.hwndOwner = hwndOwner;
	bi.pidlRoot = NULL;
	bi.pszDisplayName = pszDisplayName;
	bi.lpszTitle = pszTitle;
	bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT | BIF_NEWDIALOGSTYLE;
	bi.lpfn = BrowseCallbackProc;
	bi.lParam = (LPARAM)pszStartFolder;
	bi.iImage = NULL;
	lpID = SHBrowseForFolder(&bi);
	if (lpID != NULL)
	{
		if (SHGetPathFromIDList(lpID, pszDisplayName))
			retstring.Format(_T("%s"), pszDisplayName);
		LPMALLOC pMalloc = NULL;
		HRESULT hResult = SHGetMalloc (&pMalloc);
		if (hResult == NOERROR && pMalloc)
			pMalloc->Free (lpID);
		pMalloc->Release();
	}
	EMULE_CATCH
	return retstring;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	HexChr2Num() converts hexadecimal character to a number.
//		Params: cCh - char ('0'-'9','A'-'F','a'-'f')
//		Return: 0..15 - number, else error
unsigned HexChr2Num(TCHAR cCh)
{
	unsigned	uiDigit;

	if ((uiDigit = static_cast<unsigned>(cCh - _T('0'))) > 9u)
		uiDigit = static_cast<unsigned>(static_cast<TCHAR>(CHR2UP(cCh)) - _T('A')) + 10u;
	return uiDigit;
}

static CString LeadingCaps(CString inStr, CString exceptStr = _T(""))
{
	//there is no upper after chars defined in exceptStr (recommended: "'")
	EMULE_TRY
	if (!inStr.IsEmpty())
	{
		CString tempStr(inStr.GetAt(0));
		tempStr.MakeUpper();
		inStr.SetAt(0, tempStr.GetAt(0));

		int max = inStr.GetLength()-1;
		for (int pos=0; pos < max; pos++)
		{
			if (!IsCharAlpha(inStr.GetAt(pos)) && exceptStr.Find(inStr.GetAt(pos)) < 0)
			{
				tempStr=inStr.GetAt(pos+1);
				tempStr.MakeUpper();
				inStr.SetAt(pos+1,tempStr.GetAt(0));
			}
		}
	}
	EMULE_CATCH
	return inStr;
}

//	TODO: ms-help://MS.VSCC/MS.MSDNVS.1031/vclib/html/_crt_Interpretation_of_Multibyte.2d.Character_Sequences.htm
CString CleanupFilename(const CString &inStr)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY
	CString filename(inStr);	//process on local copy only
	CString resToken;			//one token out of strList
	CString extension;			//only the extension of filename with dot
	int foundPos = 0;			//position where something is found
	int curPos = 0;				//position for tokenize() (by reference!)

	filename.SetString(URLDecode(filename.MakeLower()));

//	Cut off & cleanup extension before further process
	foundPos = filename.ReverseFind(_T('.'));
	if ((foundPos >= 0) && (foundPos < (filename.GetLength() - 1)))	//minimum one char
	{
		extension.SetString(filename.Right(filename.GetLength()-foundPos));		//copy extension with dot
		extension.SetString(DeleteNonAlphaNumeric(extension, _T("."), false));	//only alphanum & dot allowed
		filename.SetString(filename.Left(foundPos));							//cut to filename without dot
		for (;;)
		{	//cutoff doubled extensions in filename
			filename.TrimRight(_T(" .,"));
			curPos = filename.GetLength()-extension.GetLength();
			if (curPos < 0)
				break;
			foundPos = filename.Find(extension,curPos);
			if (foundPos == curPos)
				filename.SetString(filename.Left(curPos));
			else
				break;
		}
	}
	if (extension.IsEmpty()) extension.SetString(_T(".non"));

	//remove all between [ and ]
	if (g_App.m_pPrefs->GetFilenameCleanupTags())
	{
		int foundPo2, foundPo3;
		for (;;)
		{
			foundPos = filename.Find(_T('['));
			if (foundPos < 0)
				break;
			foundPo2 = filename.Find(_T(']'), foundPos);
			if (foundPo2 > foundPos)
			{
				foundPo3 = filename.Find(_T('['), foundPos + 1);
				while (foundPo3 > 0 && foundPo3 < foundPo2)
				{	//check for nested brackets
					foundPos = foundPo3;
					foundPo3 = filename.Find(_T('['), foundPos + 1);
				}
				filename.SetString(filename.Left(foundPos) + _T(" ") + filename.Right(filename.GetLength()-foundPo2-1));
			}
			else
				break;
		}
	}

	CString	strList(g_App.m_pPrefs->GetFilenameCleanups());	//list of pipe-separated tokens

	strList.MakeLower();
	for (curPos = 0;;)
	{
		resToken = strList.Tokenize(_T("|"), curPos);
		if (resToken.IsEmpty())
			break;
		filename.Replace(resToken, _T(" "));
	}

	filename.SetString(ReplaceDotsWithSpaces(filename, _T("01234567689"), _T("_+\\\"/:*?<>|"), false)); //spaceholders

	//advertising cleanup (lowercase without dots)
	filename.Replace(_T("shared by"), _T(""));
	filename.Replace(_T("shared for"), _T(""));
	filename.Replace(_T("shared via"), _T(""));
	filename.Replace(_T("shared "), _T(""));
	filename.Replace(_T("found at"), _T(""));
	filename.Replace(_T("found via xxx"), _T(""));	//filedonkey.com special
	filename.Replace(_T("found via"), _T(""));
	filename.Replace(_T("link by"), _T(""));
	filename.Replace(_T("linked at"), _T(""));
	filename.Replace(_T("linked by"), _T(""));
	filename.Replace(_T("linked "), _T(""));
	filename.Replace(_T("powered by"), _T(""));
	filename.Replace(_T("-powered-by-"), _T(""));	//eselfilme.de special
	filename.Replace(_T("powered-by-"), _T(""));	//eselfilme.de special
	filename.Replace(_T("powered-for-"), _T(""));	//eselfilme.de special
	filename.Replace(_T("powered "), _T(""));
	filename.Replace(_T("sponsored for"), _T(""));
	filename.Replace(_T("sponsored by"), _T(""));
	filename.Replace(_T("sponsored "), _T(""));

	filename.SetString(DeleteNonAlphaNumeric(filename, _T(""), true));	//reduce doubles

	//remove spaces inside brackets
	filename.Replace(_T("( "), _T("("));
	filename.Replace(_T(" )"), _T(")"));
	filename.Replace(_T("[ "), _T("["));
	filename.Replace(_T(" ]"), _T("]"));
	filename.Replace(_T("{ "), _T("{"));
	filename.Replace(_T(" }"), _T("}"));
	//remove empty brackets
	filename.Replace(_T("()"), _T(""));
	filename.Replace(_T("[]"), _T(""));
	filename.Replace(_T("{}"), _T(""));

	filename.SetString(LeadingCaps(filename, _T("'`0123456789")));	//leadingcaps except after "'`" and numbers

	//special uppercasing by netwolf and DoubleT
	filename.Replace(_T("Cd"),_T("CD"));
	filename.Replace(_T("Vcd"),_T("VCD"));
	filename.Replace(_T("Svcd"),_T("SVCD"));
	filename.Replace(_T("Mvcd"),_T("MVCD"));
	filename.Replace(_T("Rvcd"),_T("RVCD"));
	filename.Replace(_T("Rsvcd"),_T("RSVCD"));
	filename.Replace(_T("Dvd"),_T("DVD"));
	filename.Replace(_T("Divx"),_T("DivX"));
	filename.Replace(_T("Xvid"),_T("XviD"));
	filename.Replace(_T("Ac3"),_T("AC3"));
	filename.Replace(_T("Aac"),_T("AAC"));
	filename.Replace(_T("Mp3"),_T("MP3"));
	filename.Replace(_T("Vbr"),_T("VBR"));
	filename.Replace(_T("Cbr"),_T("CBR"));
	filename.Replace(_T("Vhs"),_T("VHS"));
	filename.Replace(_T("Tv"),_T("TV"));
	filename.Replace(_T("Fsk"),_T("FSK"));
	filename.Replace(_T("Dvb"),_T("DVB"));
	filename.Replace(_T("Emuleplus"), CLIENT_NAME);
	filename.Replace(_T("Emule"),_T("eMule"));
	//make "v" in front of versions lowercase
	filename.Replace(_T("V1"),_T("v1"));
	filename.Replace(_T("V2"),_T("v2"));
	filename.Replace(_T("V3"),_T("v3"));
	filename.Replace(_T("V4"),_T("v4"));
	filename.Replace(_T("V5"),_T("v5"));
	filename.Replace(_T("V6"),_T("v6"));
	filename.Replace(_T("V7"),_T("v7"));
	filename.Replace(_T("V8"),_T("v8"));
	filename.Replace(_T("V9"),_T("v9"));
	filename.Replace(_T("V0"),_T("v0"));
	//roman numerals up to 20
	filename.Replace(_T("Iii"),_T("III"));
	filename.Replace(_T("Viii"),_T("VIII"));
	filename.Replace(_T("Vii"),_T("VII"));
	filename.Replace(_T("Xiii"),_T("XIII"));
	filename.Replace(_T("Xii"),_T("XII"));
	filename.Replace(_T("Xiv"),_T("XIV"));
	filename.Replace(_T("Xviii"),_T("XVIII"));
	filename.Replace(_T("Xvii"),_T("XVII"));
	filename.Replace(_T("Xvi"),_T("XVI"));
	filename.Replace(_T("Xix"),_T("XIX"));
	filename.Replace(_T("Xxx"),_T("XXX"));
	filename += _T(' ');
	filename.Replace(_T("Ii "),_T("II "));
	filename.Replace(_T("Iv "),_T("IV "));
	filename.Replace(_T("Vi "),_T("VI "));
	filename.Replace(_T("Ix "),_T("IX "));
	filename.Replace(_T("Xi "),_T("XI "));
	filename.Replace(_T("Xx "),_T("XX "));

	//final steps
	filename.TrimRight(_T(" -.,#&([{"));
	filename.TrimLeft(_T(" -.,#&)]}"));
	if (filename.IsEmpty())
		return inStr;
	filename.Append(extension);
	return filename;
	EMULE_CATCH
	return inStr;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

static int GetSystemErrorString(DWORD dwError, CString &rstrError)
{
	// FormatMessage language flags:
	//
	// - MFC uses: MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT)
	//				SUBLANG_SYS_DEFAULT = 0x02 (system default)
	//
	// - SDK uses: MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT)
	//				SUBLANG_DEFAULT		= 0x01 (user default)
	//
	//
	// Found in "winnt.h"
	// ------------------
	//  Language IDs.
	//
	//  The following two combinations of primary language ID and
	//  sublanguage ID have special semantics:
	//
	//    Primary Language ID   Sublanguage ID      Result
	//    -------------------   ---------------     ------------------------
	//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
	//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
	//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
	//
	// *** SDK notes also:
	// If you pass in zero, 'FormatMessage' looks for a message for LANGIDs in
	// the following order:
	//
	//	1) Language neutral
	//	2) Thread LANGID, based on the thread's locale value
	//  3) User default LANGID, based on the user's default locale value
	//	4) System default LANGID, based on the system default locale value
	//	5) US English
	LPTSTR		pszSysMsg = NULL;
	DWORD		dwLength = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
								NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
								(LPTSTR)&pszSysMsg, 0, NULL );

	if (pszSysMsg != NULL && dwLength != 0)
	{
		if (dwLength >= 2 && pszSysMsg[dwLength - 2] == _T('\r'))
			pszSysMsg[dwLength - 2] = _T('\0');
		rstrError = pszSysMsg;
		rstrError.Replace(_T("\r\n"), _T(" ")); // some messages contain CRLF within the message!?
	}
	else
	{
		rstrError.Empty();
	}

	if (pszSysMsg)
		LocalFree(pszSysMsg);

	return rstrError.GetLength();
}

int GetErrorMessage(DWORD dwError, CString &rstrErrorMsg, DWORD dwFlags /* = 0*/)
{
	int			iMsgLen = GetSystemErrorString(dwError, rstrErrorMsg);

	if (iMsgLen == 0)
	{
		if ((long)dwError >= 0)
			rstrErrorMsg.Format(_T("Error %u"), dwError);
		else
			rstrErrorMsg.Format(_T("Error 0x%08x"), dwError);
	}
	else if (dwFlags & 1)
	{
		CString			strFullErrorMsg;

		if ((long)dwError >= 0)
			strFullErrorMsg.Format(_T("Error %u: %s"), dwError, rstrErrorMsg);
		else
			strFullErrorMsg.Format(_T("Error 0x%08x: %s"), dwError, rstrErrorMsg);
		rstrErrorMsg = strFullErrorMsg;
	}

	return rstrErrorMsg.GetLength();
}

CString GetErrorMessage(DWORD dwError, DWORD dwFlags)
{
	CString			strError;

	GetErrorMessage(dwError, strError, dwFlags);
	return strError;
}

CString GetErrorMessage(CException *pError)
{
	ASSERT(pError != NULL);
	EMULE_TRY

	const size_t	bs = 255;
	TCHAR	acBuf[bs];

	pError->GetErrorMessage(acBuf, bs);
	return acBuf;

	EMULE_CATCH

	return _T("N/A");
}

bool DialogBrowseFile(CString &rstrPath, LPCTSTR pcFilters, LPCTSTR pcDefFileName/*=NULL*/,
	DWORD dwFlags/*=0*/, bool bOpenFile/*=true*/, LPCTSTR pcDefDir/*=NULL*/)
{
	bool		bRc;
	CFileDialog	myFileDialog( bOpenFile, NULL, pcDefFileName,
		dwFlags | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, pcFilters, NULL,
		0 );	// Automatically use explorer style open dialog on systems which support it

	myFileDialog.m_pOFN->lpstrInitialDir = pcDefDir;
	if ((bRc = (myFileDialog.DoModal() == IDOK)) == true)
		rstrPath = myFileDialog.GetPathName();
	return bRc;
}

#ifdef _UNICODE
unsigned long inet_addr(LPCTSTR cp)
{
	USES_CONVERSION;
	return inet_addr(T2A(cp));
}
#endif
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Same as 'inet_ntoa(*(in_addr*)&nIP)' but is not restricted to ASCII strings
CString ipstr(uint32 dwIP)
{
	const byte	*pbyteIP = reinterpret_cast<byte*>(&dwIP);
	CString		strIP;

	strIP.ReleaseBuffer( _stprintf( strIP.GetBuffer(3 + 1 + 3 + 1 + 3 + 1 + 3),
		_T("%u.%u.%u.%u"), pbyteIP[0], pbyteIP[1], pbyteIP[2], pbyteIP[3] ) );
	return strIP;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ipstr(CString *pstrOut, uint32 dwIP)
{
	const byte	*pbyteIP = reinterpret_cast<byte*>(&dwIP);

	pstrOut->ReleaseBuffer( _stprintf( pstrOut->GetBuffer(3 + 1 + 3 + 1 + 3 + 1 + 3),
		_T("%u.%u.%u.%u"), pbyteIP[0], pbyteIP[1], pbyteIP[2], pbyteIP[3] ) );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	The validity check of HybridID based on invalid IP ranges
bool IsGoodHybridID(uint32 dwHybridID)
{
//	0.0.0.0					invalid
	if (dwHybridID == 0)
		return false;
//	127.0.0.0 - 127.255.255.255		Loopback
	if (((dwHybridID & 0xFF000000) == 0x7F000000) && !g_App.m_pPrefs->AllowLocalHostIP())
		return false;
//	224.0.0.0 - 239.255.255.255		Multicast
//	240.0.0.0 - 255.255.255.255		Reserved for Future Use
	if (dwHybridID >= 0xE0000000)
		return false;

	return true;
}

CString Crypt(const CString &strNormal)
{
	uint32		dwStrLen = strNormal.GetLength();
	const TCHAR	*pcSrc = strNormal.GetString();
	CString		str;
	TCHAR		*pcDst = str.GetBufferSetLength(2 * dwStrLen);

	for (uint32 dwIdx = 0; dwIdx < dwStrLen; dwIdx++, pcDst += 2)
	{
		pcDst[0] = ((pcSrc[dwIdx] >> 4) & 0x0F) + _T('A');
		pcDst[1] = (pcSrc[dwIdx] & 0x0F) + _T('A');
	}
	return str;
}

CString Decrypt(const CString &strCrypted)
{
	uint32		dwStrLen = strCrypted.GetLength() / 2;
	const TCHAR	*pcSrc = strCrypted.GetString();
	CString		str;
	TCHAR		*pcDst = str.GetBufferSetLength(dwStrLen);

	for (uint32 dwIdx = 0; dwIdx < dwStrLen; dwIdx++, pcSrc += 2)
	{
		pcDst[dwIdx] = (((pcSrc[0] - _T('A')) << 4) | (pcSrc[1] - _T('A'))) & 0xFF;
	}
	return str;
}

typedef struct
{
	LPCTSTR	pszInitialDir;
	LPCTSTR	pszDlgTitle;
} BROWSEINIT, *LPBROWSEINIT;

bool SelectDir(HWND hWnd, LPTSTR pszPath, LPCTSTR pszTitle, LPCTSTR pszDlgTitle)
{
	bool	bResult = false;

	CoInitialize(0);
	LPMALLOC pShlMalloc;
	if (SHGetMalloc(&pShlMalloc) == NOERROR)
	{
		BROWSEINFO BrsInfo = {0};
		BrsInfo.hwndOwner = hWnd;
		BrsInfo.lpszTitle = (pszTitle != NULL) ? pszTitle : pszDlgTitle;
		BrsInfo.ulFlags = BIF_VALIDATE | BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS | BIF_SHAREABLE | BIF_DONTGOBELOWDOMAIN;

		BROWSEINIT BrsInit = {0};
		if (pszPath != NULL || pszTitle != NULL || pszDlgTitle != NULL)
		{
			// Need the 'BrowseCallbackProc' to set those strings
			BrsInfo.lpfn = BrowseCallbackProc;
			BrsInfo.lParam = (LPARAM)&BrsInit;
			BrsInit.pszDlgTitle = (pszDlgTitle != NULL) ? pszDlgTitle : NULL/*pszTitle*/;
			BrsInit.pszInitialDir = pszPath;
		}

		LPITEMIDLIST pidlBrowse;
		if ((pidlBrowse = SHBrowseForFolder(&BrsInfo)) != NULL)
		{
			if (SHGetPathFromIDList(pidlBrowse, pszPath))
				bResult = true;
			pShlMalloc->Free(pidlBrowse);
		}
		pShlMalloc->Release();
	}
	CoUninitialize();
	return bResult;
}

void MakeFolderName(TCHAR *pcPath)
{
	CString strPath(pcPath);

	PathCanonicalize(pcPath, strPath);
	PathRemoveBackslash(pcPath);
}

TCHAR* stristr(const TCHAR *str1, const TCHAR *str2)
{
	const TCHAR *cp = str1;
	const TCHAR *s1;
	const TCHAR *s2;

	if (!*str2)
		return (TCHAR *)str1;

	while (*cp)
	{
		s1 = cp;
		s2 = str2;

		while (*s1 && *s2 && _totlower(*s1) == _totlower(*s2))
			s1++, s2++;

		if (!*s2)
			return (TCHAR *)cp;

		cp++;
	}

	return NULL;
}

size_t fast_strlen(const char *pcStr)
{
#define hasNullChar(x) ((x - 0x01010101) & ~x & 0x80808080)
#define SW (sizeof(int) / sizeof(char))
	const char *pcTmp;
	int iVal;

	pcTmp = pcStr - 1;
	do {
		pcTmp++;
		if ((((int)pcTmp) & (SW - 1)) == 0)
		{
			do {
				iVal = *((int*)pcTmp);
				pcTmp += SW;
			} while(!hasNullChar(iVal));
			pcTmp -= SW;
		}
	} while(*pcTmp != 0);
	return pcTmp - pcStr;
#undef hasNullChar
#undef SW
}

COLORREF LightenColor(COLORREF crColor, int i)
{
	return RGB( max(min(GetRValue(crColor) + i, 255), 0),
				max(min(GetGValue(crColor) + i, 255), 0),
				max(min(GetBValue(crColor) + i, 255), 0) );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// note: if value of qwTotal is larger as 1e+13 (10000 Gb), then calculation will be incorrect
double __fastcall GetPercent(uint64 qwValue, uint64 qwTotal)
{
	double		dblPercentage = 0.0;

	if (qwTotal > 0)
		dblPercentage = static_cast<double>(100.0 * qwValue) / static_cast<double>(qwTotal);

	return dblPercentage;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double __fastcall GetPercent(uint32 dwValue, uint32 dwTotal)
{
	double		dblPercentage = 0.0;

	if (dwTotal > 0)
		dblPercentage = static_cast<double>(100.0 * dwValue) / static_cast<double>(dwTotal);

	return dblPercentage;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CompareDirectories(const CString& rstrDir1, const CString& rstrDir2)
{
	// use case insensitive compare as a starter
	if (rstrDir1.CompareNoCase(rstrDir2)==0)
	{
		return 0;
	}

	// if one of the paths ends with a '\' the paths may still be equal from the file system's POV
	CString strDir1(rstrDir1);
	CString strDir2(rstrDir2);

	PathRemoveBackslash(strDir1.GetBuffer());	// remove any available backslash
	strDir1.ReleaseBuffer();
	PathRemoveBackslash(strDir2.GetBuffer());	// remove any available backslash
	strDir2.ReleaseBuffer();

	return strDir1.CompareNoCase(strDir2);		// compare again
}

TCHAR* md4str(const uchar *hash, TCHAR *pszHash)
{
	TCHAR		*pcHashCopy = pszHash;
	unsigned	uiCh;

	for (int i = 0; i < 16; i++, pszHash += 2)
	{
		uiCh = static_cast<unsigned>(hash[i]);
		pszHash[0] = g_acHexDigits[uiCh >> 4];
		pszHash[1] = g_acHexDigits[uiCh & 0xf];
	}
	*pszHash = _T('\0');
	return pcHashCopy;
}

CString __stdcall HashToString(const uchar *hash)
{
	TCHAR	acHash[MAX_HASHSTR_SIZE];

	return md4str(hash, acHash);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	StringToHash() converts hexadecimal string into hash (case insensitive).
//		Params:
//			strHexStr - string to convert;
//			pbyteHash - output hash buffer.
//		Return: pointer to hash buffer, in case of error zero hash is returned.
byte* __stdcall StringToHash(const CString &strHexStr, byte *pbyteHash)
{
	for (;;)
	{
		if (strHexStr.GetLength() == 32)
		{
			unsigned uiDgt1, uiDgt2, ui;

			for (ui = 0; ui < 16; ui++)
			{
				if ((uiDgt1 = HexChr2Num(strHexStr.GetAt(ui * 2))) > 15)
					break;
				if ((uiDgt2 = HexChr2Num(strHexStr.GetAt(ui * 2 + 1))) > 15)
					break;
				pbyteHash[ui] = static_cast<byte>((uiDgt1 << 4) | uiDgt2);
			}
			if (ui == 16)
				break;
		}
		md4clr(pbyteHash);
		break;
	}
	return pbyteHash;
}

#define _STRVAL(op)	{_T(#op), op}
typedef struct {
	const TCHAR *pcOpcode;
	byte byteOpcode;
} OpCodeStr;

CString DbgGetClientTCPOpcode(bool bEMulePck, byte byteOpcode)
{
	static const OpCodeStr aDonkeyOpcodes[] = {
		_STRVAL(OP_HELLO),
		_STRVAL(OP_SENDINGPART),
		_STRVAL(OP_REQUESTPARTS),
		_STRVAL(OP_FILEREQANSNOFIL),
		_STRVAL(OP_END_OF_DOWNLOAD),
		_STRVAL(OP_ASKSHAREDFILES),
		_STRVAL(OP_ASKSHAREDFILESANSWER),
		_STRVAL(OP_HELLOANSWER),
		_STRVAL(OP_CHANGE_CLIENT_ID),
		_STRVAL(OP_MESSAGE),
		_STRVAL(OP_SETREQFILEID),
		_STRVAL(OP_FILESTATUS),
		_STRVAL(OP_HASHSETREQUEST),
		_STRVAL(OP_HASHSETANSWER),
		_STRVAL(OP_STARTUPLOADREQ),
		_STRVAL(OP_ACCEPTUPLOADREQ),
		_STRVAL(OP_CANCELTRANSFER),
		_STRVAL(OP_OUTOFPARTREQS),
		_STRVAL(OP_REQUESTFILENAME),
		_STRVAL(OP_REQFILENAMEANSWER),
		_STRVAL(OP_CHANGE_SLOT),
		_STRVAL(OP_QUEUERANK),
		_STRVAL(OP_ASKSHAREDDIRS),
		_STRVAL(OP_ASKSHAREDFILESDIR),
		_STRVAL(OP_ASKSHAREDDIRSANS),
		_STRVAL(OP_ASKSHAREDFILESDIRANS),
		_STRVAL(OP_ASKSHAREDDENIEDANS)
	};
	static const OpCodeStr aMuleOpcodes[] = {
		_STRVAL(OP_EMULEINFO),
		_STRVAL(OP_EMULEINFOANSWER),
		_STRVAL(OP_COMPRESSEDPART),
		_STRVAL(OP_QUEUERANKING),
		_STRVAL(OP_FILEDESC),
		_STRVAL(OP_REQUESTSOURCES),
		_STRVAL(OP_ANSWERSOURCES),
		_STRVAL(OP_REQUESTSOURCES2),
		_STRVAL(OP_ANSWERSOURCES2),
		_STRVAL(OP_PUBLICKEY),
		_STRVAL(OP_SIGNATURE),
		_STRVAL(OP_SECIDENTSTATE),
		_STRVAL(OP_MULTIPACKET),
		_STRVAL(OP_MULTIPACKETANSWER),
		_STRVAL(OP_BUDDYPING),
		_STRVAL(OP_BUDDYPONG),
		_STRVAL(OP_REASKCALLBACKTCP),
		_STRVAL(OP_AICHANSWER),
		_STRVAL(OP_AICHREQUEST),
		_STRVAL(OP_AICHFILEHASHANS),
		_STRVAL(OP_AICHFILEHASHREQ),
		_STRVAL(OP_COMPRESSEDPART_I64),
		_STRVAL(OP_SENDINGPART_I64),
		_STRVAL(OP_REQUESTPARTS_I64),
		_STRVAL(OP_MULTIPACKET_EXT),
		_STRVAL(OP_CHATCAPTCHAREQ),
		_STRVAL(OP_CHATCAPTCHARES)
	};
	const OpCodeStr	*pOpcode;
	unsigned		uiTabSz;

	if (bEMulePck)
	{
		uiTabSz = ARRSIZE(aMuleOpcodes);
		pOpcode = aMuleOpcodes;
	}
	else
	{
		uiTabSz = ARRSIZE(aDonkeyOpcodes);
		pOpcode = aDonkeyOpcodes;
	}

	for (unsigned ui = 0; ui < uiTabSz; ui++)
	{
		if (pOpcode[ui].byteOpcode == byteOpcode)
			return pOpcode[ui].pcOpcode;
	}

	CString strOpcode;

	strOpcode.Format(_T("opcode %#x"), byteOpcode);
	return strOpcode;
}
#undef _STRVAL

ULONGLONG GetDiskFileSize(LPCTSTR pszFilePath)
{
	static BOOL _bInitialized = FALSE;
	static DWORD (WINAPI *_pfnGetCompressedFileSize)(LPCTSTR, LPDWORD) = NULL;

	if (!_bInitialized)
	{
		_bInitialized = TRUE;
#ifdef _UNICODE
		(FARPROC&)_pfnGetCompressedFileSize = GetProcAddress(GetModuleHandle(_T("kernel32.dll")), "GetCompressedFileSizeW");
#else
		(FARPROC&)_pfnGetCompressedFileSize = GetProcAddress(GetModuleHandle(_T("kernel32.dll")), "GetCompressedFileSizeA");
#endif
	}

	// If the file is not compressed nor sparse, 'GetCompressedFileSize' returns the 'normal' file size.
	if (_pfnGetCompressedFileSize)
	{
		ULONGLONG ullCompFileSize;
		LPDWORD pdwCompFileSize = (LPDWORD)&ullCompFileSize;
		pdwCompFileSize[0] = (*_pfnGetCompressedFileSize)(pszFilePath, &pdwCompFileSize[1]);
		if (pdwCompFileSize[0] != INVALID_FILE_SIZE || GetLastError() == NO_ERROR)
			return ullCompFileSize;
	}

	// If 'GetCompressedFileSize' failed or is not available, use the default function
	WIN32_FIND_DATA fd;
	HANDLE hFind = FindFirstFile(pszFilePath, &fd);
	if (hFind == INVALID_HANDLE_VALUE)
		return 0;
	FindClose(hFind);

	return (ULONGLONG)fd.nFileSizeHigh << 32 | (ULONGLONG)fd.nFileSizeLow;
}

bool IsRightToLeftLanguage()
{
#ifndef NEW_SOCKETS_ENGINE
	switch (g_App.m_pPrefs->GetLanguageID())
	{
		case MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT):
		case MAKELANGID(LANG_FARSI, SUBLANG_DEFAULT):
			return true;
	}
#endif //NEW_SOCKETS_ENGINE
	return false;
}

CString GetLocalDecimalPoint(bool bSystem /*= false*/)
{
	CString	strResult;

	if (bSystem)
	{
		int	iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, NULL, 0);

		if (iSize > 0)
		{
			GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, strResult.GetBufferSetLength(iSize), iSize);
			strResult.ReleaseBuffer();
		}
	}

	if (strResult.IsEmpty())
		strResult = localeconv()->decimal_point;

	return strResult;
}

CString GetLocalThousandsSep(bool bSystem /*= false*/)
{
	CString	strResult;

	if (bSystem)
	{
		int	iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, NULL, 0);

		if (iSize > 0)
		{
			GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, strResult.GetBufferSetLength(iSize), iSize);
			strResult.ReleaseBuffer();
		}
	}

	if (strResult.IsEmpty())
		strResult = localeconv()->thousands_sep;

	return strResult;
}

CString GetLocalNegativeSign(bool bSystem /*= false*/)
{
	CString	strResult;

	if (bSystem)
	{
		int	iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SNEGATIVESIGN, NULL, 0);

		if (iSize > 0)
		{
			GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SNEGATIVESIGN, strResult.GetBufferSetLength(iSize), iSize);
			strResult.ReleaseBuffer();
		}
	}

	if (strResult.IsEmpty())
		strResult = localeconv()->negative_sign;

	return strResult;
}

int GetClientListActionFromShortcutCode(short nCode, CUpDownClient* pClient)
{
	int iMessage = 0;
#ifndef NEW_SOCKETS_ENGINE

	if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_SRC_DETAILS))
	{
		iMessage = MP_DETAIL;
	}
	else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_SRC_FRIEND))
	{
		if (pClient != NULL)
			iMessage = (pClient->IsFriend()) ? MP_REMOVEFRIEND : MP_ADDFRIEND;
	}
	else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_SRC_MSG))
	{
		iMessage = MP_MESSAGE;
	}
	else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_SRC_SHAREDFILES))
	{
		if ((pClient != NULL) && pClient->GetViewSharedFilesSupport())
			iMessage = MP_SHOWLIST;
	}

#endif //NEW_SOCKETS_ENGINE
	return iMessage;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool IsStolenName(const CString &strUserName)
{
	static const TCHAR *s_apcFullStolenNames[] =
	{
		_T("pbwll"),
		_T("unix user"),
		_T("http://emule-element.tk")
	};
	static const TCHAR *s_apcPartialStolenNames[] =
	{
		_T("$GAM3R$"),
		_T("G@@m3rs Edit"),
		_T("G@@m3rs Edit"),
		_T("[RAMMSTEIN"),
		_T("[toXic]"),
		_T("Leecha"),
		_T("leecha"),
		_T("darkmule"),
		_T("DarkMule"),
		_T("eVortex"),
		_T("|eVorte|X|"),
		_T("MISON"),
		_T("Mison"),
		_T("[miciolino.de]")
	};
	static const TCHAR *s_apcStartsWith[] =
	{
		_T("EDD ")
	};

	if (!strUserName.IsEmpty())
	{
		for (unsigned ui = 0; ui < ARRSIZE(s_apcFullStolenNames); ui++)
		{
			if (strUserName == s_apcFullStolenNames[ui])
				return true;
		}
		for (unsigned ui = 0; ui < ARRSIZE(s_apcPartialStolenNames); ui++)
		{
			if (strUserName.Find(s_apcPartialStolenNames[ui]) >= 0)
				return true;
		}
		for (unsigned ui = 0; ui < ARRSIZE(s_apcStartsWith); ui++)
		{
			if (strUserName.Find(s_apcStartsWith[ui]) == 0)
				return true;
		}
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool IsLeecherType(const CString &strModVersion)
{
	static const TCHAR *s_apcPartialLeecherModVersions[] =
	{
		_T("xl build"),
		_T("00de.de"),
		_T("LioNetwork"),
		_T("element"),
		_T("Plus Plus"),
		_T("LH"),
		_T("Mison"),
		_T("eVortex"),
		_T("Rappi"),
		_T("XvooM"),
		_T("Plus+")
	};

	if (!strModVersion.IsEmpty())
	{
		for (unsigned ui = 0; ui < ARRSIZE(s_apcPartialLeecherModVersions); ui++)
		{
			if (strModVersion.Find(s_apcPartialLeecherModVersions[ui]) >= 0)
				return true;
		}
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int __stdcall GetItemUnderMouse(CListCtrl *ctrl)
{
	EMULE_TRY

	LVHITTESTINFO	hit;

	::GetCursorPos(&hit.pt);
	ctrl->ScreenToClient(&hit.pt);

//	Return the index of parent item
	if ((ctrl->SubItemHitTest(&hit) != -1) && (hit.iSubItem == 0) && (hit.flags & LVHT_ONITEM))
		return hit.iItem;

	EMULE_CATCH

	return (-1);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EnumClientTypes GetClientTypeFromCompatibilityTag(uint32 dwTagValue)
{
	switch (dwTagValue)
	{
		case 0:
			return SO_EMULE;

		case 2:
			return SO_XMULE;

		case 3:
			return SO_AMULE;

		case 4:
		case 40:	// new Shareaza ID
			return SO_SHAREAZA;

		case PLUS_COMPATIBLECLIENTID:
			return SO_PLUS;

		case 10:
			return SO_MLDONKEY;

		case 20:
			return SO_LPHANT;

		default:
			return SO_UNKNOWN;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CreateAllDirectories() creates full path (not only last directory like CreateDirectory()).
//		Note: no need to check directory existence before this call.
//		Params:
//			pstrPath - directory(ies) to cleate (trailing '\' not required, but allowed).
void CreateAllDirectories(const CString *pstrPath)
{
	if (!::CreateDirectory(*pstrPath, NULL) && (::GetLastError() == ERROR_PATH_NOT_FOUND))
	{
		int	iPos = 0;

		while (((iPos = pstrPath->Find(_T('\\'), iPos + 1)) >= 0) && (iPos < (pstrPath->GetLength() - 1)))
			::CreateDirectory(pstrPath->Left(iPos), NULL);
		::CreateDirectory(*pstrPath, NULL);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FractionalRate2String()
void FractionalRate2String(CString *pstrOut, uint32 dwRate)
{
	if ((dwRate % 10) == 0)
		pstrOut->Format(_T("%u"), dwRate / 10);
	else
		pstrOut->Format(_T("%.1f"), static_cast<double>(dwRate) / 10.0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static bool IsDaylightSavingTimeActive(int *piDaylightBias)
{
	TIME_ZONE_INFORMATION tzi;

	if (GetTimeZoneInformation(&tzi) != TIME_ZONE_ID_DAYLIGHT)
		return false;
	*piDaylightBias = tzi.DaylightBias;
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static bool IsFileOnNTFSVolume(const CString &strFilePath)
{
	CString	strRootPath(strFilePath);
	BOOL	bResult = PathStripToRoot(strRootPath.GetBuffer());

	strRootPath.ReleaseBuffer();
	if (!bResult)
		return false;

	DWORD	dwMaximumComponentLength = 0, dwFileSystemFlags = 0;
	TCHAR	acFileSystemNameBuffer[128];

	if (!GetVolumeInformation(strRootPath, NULL, 0, NULL, &dwMaximumComponentLength, &dwFileSystemFlags, acFileSystemNameBuffer, ARRSIZE(acFileSystemNameBuffer)))
		return false;
	return (_tcscmp(acFileSystemNameBuffer, _T("NTFS")) == 0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool IsFileOnFATVolume(const CString &strFilePath)
{
	CString	strRootPath(strFilePath);
	BOOL	bResult = PathStripToRoot(strRootPath.GetBuffer());

	strRootPath.ReleaseBuffer();
	if (!bResult)
		return false;

	DWORD	dwMaximumComponentLength = 0, dwFileSystemFlags = 0;
	TCHAR	acFileSystemNameBuffer[128];

	if (!GetVolumeInformation(strRootPath, NULL, 0, NULL, &dwMaximumComponentLength, &dwFileSystemFlags, acFileSystemNameBuffer, ARRSIZE(acFileSystemNameBuffer)))
		return false;
	return (_tcsnicmp(acFileSystemNameBuffer, _T("FAT"), 3) == 0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static bool IsAutoDaylightTimeSetActive()
{
	CRegKey key;
	if (key.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation"), KEY_READ) == ERROR_SUCCESS)
	{
		DWORD dwDisableAutoDaylightTimeSet = 0;

		if (key.QueryDWORDValue(_T("DisableAutoDaylightTimeSet"), dwDisableAutoDaylightTimeSet) == ERROR_SUCCESS)
		{
			if (dwDisableAutoDaylightTimeSet)
				return false;
		}
	}
	return true; // default to 'Automatically adjust clock for daylight saving changes'
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool AdjustNTFSDaylightFileTime(uint32 *pdwFileDate, const CString &strFilePath)
{
	if (*pdwFileDate == 0)
		return false;

	int	iDaylightBias;

	if (IsDaylightSavingTimeActive(&iDaylightBias))
	{
		if (IsAutoDaylightTimeSetActive() && IsFileOnNTFSVolume(strFilePath))
		{
			*pdwFileDate += 60 * iDaylightBias;
			return true;
		}
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetAdjustedFileTime() returns file date considering daylight saving time
//	To avoid issues with weird dates, the method used to get the date has to be
//	similar to one used in checking routines (e.g. AddFilesFromDirectory())
void GetAdjustedFileTime(const CString &strFName, uint32 *pdwTime)
{
	WIN32_FIND_DATA	findFileData;
	HANDLE			hFind = FindFirstFile(strFName, &findFileData);

	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
		*pdwTime = static_cast<uint32>(CTime(findFileData.ftLastWriteTime).GetTime());
		AdjustNTFSDaylightFileTime(pdwTime, strFName);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetFileTypeForWebServer() returns file type according to WebServer requirements
//		Params: strFileName - file name (case insensitive)
const TCHAR* GetFileTypeForWebServer(const CString &strFileName)
{
	static const TCHAR *const s_apcTypes[ED2KFT_COUNT] =
	{
		_T("other"),		//ED2KFT_ANY
		_T("music"),		//ED2KFT_AUDIO
		_T("movie"),		//ED2KFT_VIDEO
		_T("picture"),		//ED2KFT_IMAGE
		_T("application"),	//ED2KFT_PROGRAM
		_T("document"),		//ED2KFT_DOCUMENT
		_T("archive"),		//ED2KFT_ARCHIVE
		_T("cdimage")		//ED2KFT_CDIMAGE
	};
	return s_apcTypes[static_cast<unsigned>(GetED2KFileTypeID(strFileName))];
}
#ifdef EP_SPIDERWEB
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	StructuredExceptionHandler() intercepts all system crashes and logs crash information.
void StructuredExceptionHandler(unsigned int uiCode, EXCEPTION_POINTERS *pExp)
{
	EMULE_TRY

	if (g_App.m_pMDlg != NULL)
	{
		g_App.m_pMDlg->AddLogLine( LOG_FL_DBG | LOG_RGB_ERROR,
			_T("EXCEPTION! code=%#x addr=%#x AX=%#x BX=%#x CX=%#x DX=%#x SI=%#x DI=%#x BP=%#x"),
			uiCode, pExp->ExceptionRecord->ExceptionAddress,
			pExp->ContextRecord->Eax, pExp->ContextRecord->Ebx, pExp->ContextRecord->Ecx,
			pExp->ContextRecord->Edx, pExp->ContextRecord->Esi, pExp->ContextRecord->Edi, pExp->ContextRecord->Ebp );
	}

	EMULE_CATCH2
}
#endif //EP_SPIDERWEB
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetAppImageListColorFlag()
{
	HDC hdcScreen = ::GetDC(NULL);
	int iColorBits = GetDeviceCaps(hdcScreen, BITSPIXEL) * GetDeviceCaps(hdcScreen, PLANES);
	::ReleaseDC(NULL, hdcScreen);
	int iIlcFlag;
	if (iColorBits >= 32)
		iIlcFlag = ILC_COLOR32;
	else if (iColorBits >= 24)
		iIlcFlag = ILC_COLOR24;
	else if (iColorBits >= 16)
		iIlcFlag = ILC_COLOR16;
	else if (iColorBits >= 8)
		iIlcFlag = ILC_COLOR8;
	else if (iColorBits >= 4)
		iIlcFlag = ILC_COLOR4;
	else
		iIlcFlag = ILC_COLOR;

	return iIlcFlag;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RC4 Encryption
static __inline void swap_byte(byte *a, byte *b)
{
	byte byteSwap = *a;

	*a = *b;
	*b = byteSwap;
}

RC4_Key_Struct* RC4CreateKey(const byte *pbyteKeyData, uint32 dwLen, RC4_Key_Struct *key, bool bSkipDiscard/*=false*/)
{
	unsigned	uiIdx1, uiIdx2;
	byte		*pbyteState;

	if (key == NULL)
		key = new RC4_Key_Struct;

	pbyteState= &key->abyteState[0];
	for (int i = 0; i < 256; i++)
		pbyteState[i] = static_cast<byte>(i);

	key->byteX = 0;
	key->byteY = 0;
	uiIdx1 = uiIdx2 = 0;
	for (int i = 0; i < 256; i++)
	{
		uiIdx2 = (pbyteKeyData[uiIdx1] + pbyteState[i] + uiIdx2) & 255;
		swap_byte(&pbyteState[i], &pbyteState[uiIdx2]);
		uiIdx1 = ((uiIdx1 + 1u) % dwLen) & 255u;
	}
	if (!bSkipDiscard)
		RC4Crypt(NULL, NULL, 1024, key);
	return key;
}

void RC4Crypt(const byte *pbyteIn, byte *pbyteOut, uint32 dwLen, RC4_Key_Struct *key)
{
	ASSERT(key != NULL && dwLen > 0);
	if ((key == NULL) || (dwLen == 0))
		return;

	unsigned	uiXorIdx, uiX = key->byteX, uiY = key->byteY;
	byte		*pbyteState = &key->abyteState[0];
	uint32		i = 0;

	if (pbyteIn != NULL)
	{
		do
		{
			uiX = (uiX + 1u) & 255u;
			uiY = (pbyteState[uiX] + uiY) & 255;
			swap_byte(&pbyteState[uiX], &pbyteState[uiY]);
			
			uiXorIdx = (pbyteState[uiX] + pbyteState[uiY]) & 255;
			pbyteOut[i] = pbyteIn[i] ^ pbyteState[uiXorIdx];
			i++;
		} while(--dwLen != 0);
	}
	else
	{
		do
		{
			uiX = (uiX + 1u) & 255u;
			uiY = (pbyteState[uiX] + uiY) & 255;
			swap_byte(&pbyteState[uiX], &pbyteState[uiY]);
		} while(--dwLen != 0);
	}
	key->byteX = static_cast<byte>(uiX);
	key->byteY = static_cast<byte>(uiY);
}
@


1.253
log
@Banned multi-network downloading only client {gnwd}.
@
text
@a490 1
#if 0	// following versions of this family will be probably closer to Vista than to XP
a491 1
#endif
d493 4
d2256 1
a2256 1
	if (key == NULL)
d2261 1
d2263 1
a2263 1
	for (uint32 i = 0; i < dwLen; i++)
d2265 1
a2265 5
		uiX = (uiX + 1u) & 255u;
		uiY = (pbyteState[uiX] + uiY) & 255;
		swap_byte(&pbyteState[uiX], &pbyteState[uiY]);
		
		if (pbyteIn != NULL)
d2267 4
d2273 11
a2283 1
		}
@


1.252
log
@Suppressed warnings.
@
text
@d1965 1
@


1.251
log
@Added AICH hash decoding from the link (just preparation for future - it's not used in anyway).
@
text
@d630 1
a630 1
			word = (buffer[i] & (0xFF >> index));
d639 1
a639 1
			word = (buffer[i] >> (8 - (index + 5))) & 0x1F;
@


1.250
log
@strlen optimization for IP filter.
@
text
@d40 4
a43 3
#if 0	// Can be required later for AICH
static const byte base32Chars[33] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
#endif
a610 1
#if 0	// Can be required later for AICH
a621 3

	EMULE_TRY

a623 1
//	int pos = 0;
a626 1

a634 1

d645 1
a645 1
		strBase32Buff += (char) base32Chars[word];
d648 35
a682 1
	EMULE_CATCH
d684 1
a684 1
	return strBase32Buff;
a685 1
#endif
@


1.249
log
@Slightly faster webservices.dat parsing.
@
text
@d1526 24
@


1.248
log
@More detailed debug information about received bad packets (received client TCP packets).
@
text
@a668 1
	CString	strBuffer;
d674 2
d682 2
d685 1
a685 3

		//	Ignore comments & too short lines
			if (*acBuf == _T('#') || *acBuf == _T('/') || strBuffer.GetLength() < 5)
@


1.247
log
@Simplified logging system implementation.
@
text
@d1626 93
@


1.246
log
@Reduced H-file dependency.
@
text
@d2037 2
a2038 3
		CString	strOut;

		strOut.Format( RGB_LOG_ERROR_TXT _T("EXCEPTION! code=%#x addr=%#x AX=%#x BX=%#x CX=%#x DX=%#x SI=%#x DI=%#x BP=%#x"),
a2041 1
		g_App.m_pMDlg->AddDebugLogLine(strOut);
@


1.245
log
@Some local functions were made static; Removed unused DecodeLengthBase16().
@
text
@d20 1
@


1.244
log
@Removed unused client upload states.
@
text
@d319 24
a382 24
void BackupReg(void)
{
	EMULE_TRY
	// Look for pre-existing old ed2k links
	CRegKey regkey;
	regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\shell\\open\\command"));

	TCHAR rbuffer[500];
	ULONG maxsize = ARRSIZE(rbuffer);
	// Is it ok to write new values
	if ((regkey.QueryStringValue(_T("OldDefault"), rbuffer, &maxsize) != ERROR_SUCCESS) || (maxsize == 0))
	{
		maxsize = ARRSIZE(rbuffer);
		regkey.QueryStringValue(0, rbuffer, &maxsize);
		regkey.SetStringValue(_T("OldDefault"), rbuffer);
		regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\DefaultIcon") );
		maxsize = ARRSIZE(rbuffer);
		if (regkey.QueryStringValue(0, rbuffer, &maxsize) == ERROR_SUCCESS)
			regkey.SetStringValue(_T("OldIcon"), rbuffer);
	}
	regkey.Close();
	EMULE_CATCH
}

a657 12

// Calculates length to decode from BASE16
//
// [In]
//   base16Length: Actual length of BASE16 string
//
// [Return]
//   New length of byte array decoded
unsigned int DecodeLengthBase16(unsigned int base16Length)
{
	return base16Length / 2U;
}
d706 52
d1055 1
a1055 1
CString LeadingCaps(CString inStr, CString exceptStr /*=""*/)
a1079 52
CString DeleteNonAlphaNumeric(CString inStr, CString exceptStr /*=""*/, bool onlyRep /*=true*/)
{
	//with standard-params output simply won't contain any nonalphanumeric chars
	//set exceptStr to chars u don't want to be deleted (i.e. pipe as separator-char "|")
	//if onlyRep==true only repeated non-alphanumeric chars will be reduced to one occurence
	//if onlyRep==false all non-alphanumeric chars are deleted except the allowed ones in exceptStr
	EMULE_TRY
	TCHAR curChar;
	int pos = 0;
	while (pos < inStr.GetLength())
	{
		curChar = inStr.GetAt(pos);
		if (!IsCharAlphaNumeric(curChar) && exceptStr.Find(curChar) < 0
		&& (!onlyRep || (pos+1 < inStr.GetLength() && inStr.Find(curChar, pos+1) == pos+1 )))
			inStr.Delete(pos);
		else
			pos++;
	}
	EMULE_CATCH
	return inStr;
}

CString ReplaceDotsWithSpaces(CString strIn, CString exceptStr, CString addClear, bool keepExt)
{
	//with standard-params simply all dots are replaced with spaces :)
	//dots won't be replaced between 2 chars of exceptStr (numbers for versions and dates)
	//if u want to replace additional chars with spaces set addClear (invalid & nonsense chars)
	//set keepExt=true for keeping the extension-dot
	EMULE_TRY
	int extpos = strIn.ReverseFind(_T('.'));
	int max = strIn.GetLength() - 1;
	for (int pos = 0; pos <= max; pos++)
	{
		if (strIn.GetAt(pos) == _T('.'))
		{
			//replace dot at beginning and end
			if (pos == 0 || pos == max)
				strIn.SetAt(pos, _T(' '));
			//replace dot only if not between 2 chars of exceptStr
			else if (exceptStr.Find(strIn.GetAt(pos-1)) < 0 || exceptStr.Find(strIn.GetAt(pos+1)) < 0)
				strIn.SetAt(pos, _T(' '));
		}
		//replace chars from addClear with space, too
		else if (addClear.Find(strIn.GetAt(pos)) >= 0)
			strIn.SetAt(pos, _T(' '));
	}
	if (keepExt && extpos >= 0)
		strIn.SetAt(extpos, _T('.'));
	EMULE_CATCH
	return strIn;
}

d1256 1
a1256 1
int GetSystemErrorString(DWORD dwError, CString &rstrError)
@


1.243
log
@GetKnownFilePriorityString() functionality moved to knownfile class.
@
text
@a918 1
		IDS_CONNVIASERVER,		//US_WAITCALLBACK
a919 1
		IDS_PENDING,			//US_PENDING
a920 1
		IDS_ERROR_STATE,		//US_ERROR
@


1.242
log
@Proper share mode for open files (before other applications could write to a file while we were reading).
@
text
@a2084 59

#ifndef NEW_SOCKETS_ENGINE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetKnownFilePriorityString() returns file upload priority string.
CString GetKnownFilePriorityString(CKnownFile *pKnownFile)
{
	uint32	dwResId;

	if (pKnownFile->IsULAutoPrioritized())
	{
		switch (pKnownFile->GetULPriority())
		{
			default:
			case PR_LOW:
				dwResId = IDS_PRIOAUTOLOW;
				break;
			case PR_NORMAL:
				dwResId = IDS_PRIOAUTONORMAL;
				break;
			case PR_HIGH:
				dwResId = IDS_PRIOAUTOHIGH;
				break;
			case PR_RELEASE:
				dwResId = IDS_PRIOAUTORELEASE;
				break;
		}
	}
	else
	{
		switch (pKnownFile->GetULPriority())
		{
			default:
			case PR_VERYLOW:
				dwResId = IDS_PRIOVERYLOW;
				break;
			case PR_LOW:
				dwResId = IDS_PRIOLOW;
				break;
			case PR_NORMAL:
				dwResId = IDS_PRIONORMAL;
				break;
			case PR_HIGH:
				dwResId = IDS_PRIOHIGH;
				break;
			case PR_RELEASE:
				dwResId = IDS_PRIORELEASE;
				break;
		}
	}

	CString	strBuffer;

	if (pKnownFile->GetJumpstartEnabled())
		strBuffer.Format(_T("JumpStart[%s]"), GetResString(dwResId));
	else
		GetResString(&strBuffer, dwResId);
	return strBuffer;
}
#endif //NEW_SOCKETS_ENGINE
@


1.241
log
@Fixed modeless ed2k link registration message box {muleteer}.
@
text
@d25 1
d680 1
a680 1
	CString	strName, strURL, strBuffer;
d682 1
a682 1
	FILE	*pWebServiceFile = _tfopen(g_App.m_pPrefs->GetConfigDir() + _T("webservices.dat"), _T("r"));
@


1.240
log
@Added 'vhs' to the title filtering.
@
text
@d328 1
a328 1
		if (bDontAsk || (MessageBox(0, GetResString(IDS_ASSIGNED2K), GetResString(IDS_ED2KLINKFIX), MB_ICONQUESTION | MB_YESNO) == IDYES))
d343 1
a343 1
			regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\DefaultIcon") );
d347 1
a347 1
			regkey.SetStringValue(_T("URL Protocol") ,_T(""));
@


1.239
log
@Added WebServices link for IMDb movie info look-up;
Preparations for comprehensive exception handling.
@
text
@d726 1
a726 1
		_T("dvb"), _T("vh-prod")
@


1.238
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d718 109
d842 3
d2041 21
@


1.237
log
@Suppressed compiler warnings [Aw3].
@
text
@d24 1
d32 1
a32 1
static const TCHAR s_acHexDigits[16] =
a246 54
CString URLEncode(CString sIn)
{
	EMULE_TRY
	CString sOut;

	const int nLen = sIn.GetLength() + 1;

	register LPBYTE pOutTmp = NULL;
	LPBYTE pOutBuf = NULL;
	register LPBYTE pInTmp = NULL;
	LPBYTE pInBuf =(LPBYTE)sIn.GetBuffer(nLen);
//	BYTE b = 0;

	//alloc out buffer
	pOutBuf = (LPBYTE)sOut.GetBuffer(nLen  * 3 - 2);//new BYTE [nLen  * 3];

	if(pOutBuf)
	{
		pInTmp	= pInBuf;
		pOutTmp = pOutBuf;

		// do encoding
		while (*pInTmp)
		{
			if (isalnum(*pInTmp))
			{
				*pOutTmp++ = *pInTmp;
			}
			else
			{
				if (isspace(*pInTmp))
				{
					*pOutTmp++ = '+';
				}
				else
				{
					*pOutTmp++ = '%';
					*pOutTmp++ = s_acHexDigits[*pInTmp >> 4];
					*pOutTmp++ = s_acHexDigits[*pInTmp & 0xf];
				}
			}
			pInTmp++;
		}
		*pOutTmp = '\0';
		//sOut=pOutBuf;
		//delete [] pOutBuf;
		sOut.ReleaseBuffer();
	}
	sIn.ReleaseBuffer();
	return sOut;
	EMULE_CATCH
	return sIn;
}

d896 1
a896 1
static unsigned HexChr2Num(TCHAR cCh)
a904 68
CString URLDecode(const CString &strIn)
{
	EMULE_TRY

	CString		outStr;
	int			more = -1;
	unsigned	uiDgt1, uiDgt2;

	for (int x = 0; x < strIn.GetLength(); ++x)
	{
		if ( (strIn.GetAt(x) == '%') && ((x + 2) < strIn.GetLength()) &&
			((uiDgt1 = HexChr2Num(strIn.GetAt(x + 1))) <= 15) &&
			((uiDgt2 = HexChr2Num(strIn.GetAt(x + 2))) <= 15) )
		{
			int Result;
			int sumb;
			x += 2;

			// EC 11.07.03 UTF-8 Decoding
			Result = (uiDgt1 << 4) | uiDgt2;
			if ((Result & 0xc0) == 0x80) // 10xxxxxx (continuation byte)
			{
				sumb = (sumb << 6) | (Result & 0x3f) ;	// Add 6 bits to sumb
				if (--more == 0) outStr.AppendChar((char) sumb) ; // Add char to sbuf
			}
			else if ((Result & 0x80) == 0x00) 		// 0xxxxxxx (yields 7 bits)
			{
				outStr.AppendChar((char) Result);			// Append Character
			}
			else if ((Result & 0xe0) == 0xc0) 		// 110xxxxx (yields 5 bits)
			{
				sumb = Result & 0x1f;
				more = 1;				// Expect 1 more byte
			}
			else if ((Result & 0xf0) == 0xe0) 		// 1110xxxx (yields 4 bits)
			{
				sumb = Result & 0x0f;
				more = 2;				// Expect 2 more bytes
			}
			else if ((Result & 0xf8) == 0xf0)
			{		// 11110xxx (yields 3 bits)
				sumb = Result & 0x07;
				more = 3;				// Expect 3 more bytes
			}
			else if ((Result & 0xfc) == 0xf8)
			{		// 111110xx (yields 2 bits)
				sumb = Result & 0x03;
				more = 4;				// Expect 4 more bytes
			}
			else /*if ((b & 0xfe) == 0xfc)*/ 	// 1111110x (yields 1 bit)
			{
				sumb = Result & 0x01;
				more = 5;				// Expect 5 more bytes
			}
		}
		else
		{
			outStr.AppendChar(strIn.GetAt(x));
		}
		// EC 11.07.03 UTF-8 Decoding Ends
	}
	return outStr;

	EMULE_CATCH

	return strIn;
}

d1482 2
a1483 2
		pszHash[0] = s_acHexDigits[uiCh >> 4];
		pszHash[1] = s_acHexDigits[uiCh & 0xf];
@


1.236
log
@Some optimization of CastItoIShort() to reduce code size [Aw3].
@
text
@d514 1
a514 1
WORD DetectWinVersion(BOOL &bNTBased)
d516 1
a516 1
	bNTBased = FALSE;
d526 1
a526 1
			bNTBased = TRUE;
d1479 2
a1480 1
	BOOL bResult = FALSE;
d1504 1
a1504 1
				bResult = TRUE;
d1952 1
a1952 1
	bool	bResult = PathStripToRoot(strRootPath.GetBuffer());
d1969 1
a1969 1
	bool	bResult = PathStripToRoot(strRootPath.GetBuffer());
d2028 1
a2028 1
		*pdwTime = CTime(findFileData.ftLastWriteTime).GetTime();
@


1.235
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d108 1
a111 1
		double	dNum;
d125 8
a132 4
	else if (qwCount < 1000000000000)
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(qwCount) / 1000000000.0, GetResString(IDS_GIGA));
	else if (qwCount < 1000000000000000)
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(qwCount) / 1000000000000.0, GetResString(IDS_TERRA));
@


1.234
log
@Changes from Eklmn restored.
They were accidentally overwritten by Fuxie - DK
@
text
@d848 1
a848 1
void GetStatusULQueueString(CString *pstrOut, EnumULQState &State)
@


1.233
log
@Faster date to string conversion (CastSecondsToLngHM) -- used in statistics tree to show duration [Aw3].
@
text
@d840 1
a840 1
CString ConcatFullPath(CString &strPath, CString &strFname)
@


1.232
log
@improved the string handling
@
text
@d160 1
a160 1
CString __stdcall CastSecondsToLngHM(uint64 qwCount)
d165 1
a165 1
	if (qwCount < 86400)
d167 7
a173 6
		uint32	dwNum = static_cast<uint32>(qwCount);

		if (dwNum < 60)
			strBuffer.Format(_T("%u %s"), dwNum, GetResString(IDS_LONGSECS));
		else if (dwNum < 3600)
			strBuffer.Format(_T("%u:%02u %s"), dwNum / 60, static_cast<uint32>(dwNum - (dwNum / 60) * 60), GetResString(IDS_LONGMINS));
d175 1
a175 1
			strBuffer.Format(_T("%u:%02u %s"), dwNum / 3600, static_cast<uint32>((dwNum - (dwNum / 3600) * 3600) / 60), GetResString(IDS_LONGHRS));
d179 3
a181 3
		uint64	qwCntDays = qwCount / 86400;
		uint32	dwCntHrs = static_cast<uint32>(qwCount - qwCntDays * 86400) / 3600;
		uint32	dwCntMins = (static_cast<uint32>(qwCount - (qwCntDays * 86400)) - (dwCntHrs * 3600)) / 60;
d183 1
a183 1
		CString strDay = GetResString((qwCntDays > 1) ? IDS_LONGDAYS : IDS_LONGDAY);
d186 1
a186 1
			strBuffer.Format(_T("%I64u %s %u:%02u %s"), qwCntDays, strDay, dwCntHrs, dwCntMins, GetResString(IDS_LONGHRS));
d188 1
a188 1
			strBuffer.Format(_T("%I64u %s %02u %s"), qwCntDays, strDay , dwCntMins, GetResString(IDS_LONGMINS));
d840 1
a840 1
CString ConcatFullPath(const CString &strPath, const CString &strFname)
@


1.231
log
@Leecher ban for strange scanning, fake queue status and file name.
@
text
@d839 1
a839 1
CString ConcatFullPath(CString &strPath, CString &strFname)
@


1.230
log
@Removed unused functionality; Some formatting.
@
text
@d1806 4
d1823 5
@


1.229
log
@Optimized prototypes of widely used functions; Optimized YesNoStr() service;
Optimized functions to display numbers in 100K style and time duration;
Removed not working functionality to drop trailing zeros when "Round file and transfer sizes" is enabled for 100K style numbers (when K, M, etc. is added at the end).
@
text
@d138 1
a138 1
CString __stdcall CastSecondsToHM(sint32 iCount, TimeFormat eTimeFormat/*=TIMEFORMAT_D_DAYS_H_HOURS*/)
d152 1
a152 11
	{
		switch (eTimeFormat)
		{
			case TIMEFORMAT_D_DAYS_H_HOURS:
				strBuffer.Format(_T("%u %s %u %s"), iCount / 86400, GetResString(IDS_DAYS),  (iCount - (iCount / 86400) * 86400) / 3600, GetResString(IDS_HOURS));
				break;
			case TIMEFORMAT_D_COLON_H_DAYS:
				strBuffer.Format(_T("%u:%02u %s"), iCount / 86400, (iCount - (iCount / 86400) * 86400) / 3600, GetResString(IDS_DAYS));
				break;
		}
	}
d343 1
a343 1
	ULONG	dwSize = sizeof(acBuffer) / sizeof(acBuffer[0]);
d414 1
a414 1
	ULONG maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);
d418 1
a418 1
		maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);
d422 1
a422 1
		maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);
d437 1
a437 1
	ULONG maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);
d444 1
a444 1
		maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);
d863 1
a863 1
	if (uiState >= ELEMENT_COUNT(s_auResTbl))
d901 2
d1946 1
a1946 1
	if (!GetVolumeInformation(strRootPath, NULL, 0, NULL, &dwMaximumComponentLength, &dwFileSystemFlags, acFileSystemNameBuffer, ELEMENT_COUNT(acFileSystemNameBuffer)))
d1963 1
a1963 1
	if (!GetVolumeInformation(strRootPath, NULL, 0, NULL, &dwMaximumComponentLength, &dwFileSystemFlags, acFileSystemNameBuffer, ELEMENT_COUNT(acFileSystemNameBuffer)))
@


1.228
log
@Fixed "day" string in representation of time duration {Fuxie - DK}.
@
text
@d41 1
a41 1
CString CastItoXBytes(uint64 qwNum)
d79 1
a79 1
		int		iPos1 = strBuffer.Find(strDecimalPoint);
d83 1
a83 2
			int		iPos2 = strBuffer.Find(_T(' '), iPos1 + strDecimalPoint.GetLength());

d102 1
a102 1
CString CastItoIShort(uint64 qwCount)
d107 1
a107 12
	CString	strBuffer, strDecimalPoint = GetLocalDecimalPoint();

	if (qwCount < 1000)
		strBuffer.Format(_T("%i"), qwCount);
	else if (qwCount < 1000000)
		strBuffer.Format(g_App.m_pPrefs->ShowRoundSizes() ? _T("%.f%s") : _T("%.2f%s"), static_cast<double>(qwCount) / 1000.0, GetResString(IDS_KILO));
	else if (qwCount < 1000000000)
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(qwCount) / 1000000.0, GetResString(IDS_MEGA).GetBuffer(0));
	else if (qwCount < 1000000000000)
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(qwCount) / 1000000000.0, GetResString(IDS_GIGA).GetBuffer(0));
	else if (qwCount < 1000000000000000)
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(qwCount) / 1000000000000.0, GetResString(IDS_TERRA).GetBuffer(0));
d109 1
a109 1
	if (g_App.m_pPrefs->ShowRoundSizes())
d111 2
a112 1
		int	iPos1 = strBuffer.Find(strDecimalPoint);
d114 3
a116 1
		if (iPos1 != -1)
d118 5
a122 12
			int	iPos2 = strBuffer.Find(_T(" "), iPos1 + strDecimalPoint.GetLength());

			if (iPos2 != -1)
			{
				while (strBuffer.GetAt(iPos2 - 1) == _T('0'))
				{
					iPos2--;
					strBuffer.Delete(iPos2, 1);
				}
				if (iPos2 - 1 == iPos1)
					strBuffer.Delete(iPos1, strDecimalPoint.GetLength());
			}
d125 4
a130 1

d138 1
a138 1
CString CastSecondsToHM(sint32 iCount, TimeFormat eTimeFormat/* = TIMEFORMAT_D_DAYS_H_HOURS*/)
d170 1
a170 1
CString CastSecondsToLngHM(uint64 qwCount)
d175 11
a185 6
	if (qwCount < 60)
		strBuffer.Format(_T("%I64d %s"), qwCount, GetResString(IDS_LONGSECS));
	else if (qwCount < 3600)
		strBuffer.Format(_T("%I64d:%02u %s"), qwCount / 60, static_cast<uint32>(qwCount - (qwCount / 60) * 60), GetResString(IDS_LONGMINS));
	else if (qwCount < 86400)
		strBuffer.Format(_T("%I64d:%02u %s"), qwCount / 3600, static_cast<uint32>((qwCount - (qwCount / 3600) * 3600) / 60), GetResString(IDS_LONGHRS));
d206 1
a206 1
CString CastItoThousands(sint64 iVal)
d1858 1
a1858 10
CString	__stdcall YesNoStr(bool bYes)
{
#ifndef NEW_SOCKETS_ENGINE
	return GetResString(bYes ? IDS_YES : IDS_NO);
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int GetItemUnderMouse(CListCtrl* ctrl)
@


1.227
log
@Unified way to check language ID; Arabic changed into Farsi.
@
text
@d200 1
a200 1
		CString strDay = GetResString((qwCntDays > 1) ? IDS_LONGDAY : IDS_LONGDAYS);
@


1.226
log
@Default browsing directory for WebServer templates and while saving logs (default is main e+ dir) {muleteer}.
@
text
@d1698 2
a1699 2
		case 1037: // Hebrew
		case 1025: // Arabic
@


1.225
log
@Removed some old simple name checks to avoid any harm.
@
text
@d1395 2
a1396 1
BOOL DialogBrowseFile(CString& rstrPath, LPCTSTR pszFilters, LPCTSTR pszDefaultFileName, DWORD dwFlags,bool openfilestyle)
d1398 3
a1400 2
	CFileDialog myFileDialog( openfilestyle, NULL, pszDefaultFileName,
		dwFlags | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, pszFilters, NULL,
d1403 4
a1406 4
	if (myFileDialog.DoModal() != IDOK)
		return FALSE;
	rstrPath = myFileDialog.GetPathName();
	return TRUE;
@


1.224
log
@Fixed an issue introduced by SX update -- recovered ability to work with local sources if allowed in prefs.ini;
Removed useless check for 255.255.255.255.
@
text
@a1804 1
		_T("Odin"),
a1811 1
		_T("eDevil"),
@


1.223
log
@removed dublicated hit test (SubItemHitTest() is doing whole job)
@
text
@d1433 17
a2059 1

@


1.222
log
@Added proper Vista detection {muleteer}.
@
text
@d1862 1
a1862 1
	LVHITTESTINFO	hit, subhit;
d1867 3
a1869 10
	subhit.pt = hit.pt;
	ctrl->SubItemHitTest(&subhit);

	int	iSel = ctrl->HitTest(&hit);

	if (iSel != LB_ERR && (hit.flags & LVHT_ONITEM))
	{
		if (subhit.iSubItem == 0)
			return iSel;
	}
d1873 1
a1873 1
	return LB_ERR;
@


1.221
log
@Unified way to preselect default folder for select dialog.
@
text
@d529 1
a529 1
	bNTBased	=	FALSE;
d539 1
a539 2
		{
			bNTBased	=	TRUE;
d541 1
a541 1
			if(osvi.dwMajorVersion <= 4)
d543 18
a560 9
			if(osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
				return _WINVER_2K_;
			if(osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
				return _WINVER_XP_;
			if(osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)	//	Windows Server 2003
				return _WINVER_SE_;
		//	Never return Win95 if we get the info about a NT system
			return _WINVER_XP_;
		}
d562 10
a571 9
		{
			if(osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0)
				return _WINVER_95_;
			if(osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 10)
				return _WINVER_98_;
			if(osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 90)
				return _WINVER_ME_;
			break;
		}
d575 1
a575 1
	return _WINVER_95_;		// there should'nt be anything lower than this
@


1.220
log
@Encryption preparations.
@
text
@d910 3
a912 13
	EMULE_TRY
	switch(uMsg)
	{
	case BFFM_INITIALIZED:
		if (lpData)
		{
			SendMessage(hwnd,BFFM_SETSELECTION,TRUE,lpData);
		}
		break;
	default:
		break;
	}
	EMULE_CATCH
@


1.219
log
@Fixed constant rehashing of files with some weird date {mamamia}.
@
text
@d2133 60
@


1.218
log
@Minor Unicode correction.
@
text
@d2018 16
@


1.217
log
@Large file size support preparations.
@
text
@d1128 3
a1130 3
	//cut off & cleanup extension before further process
	foundPos = filename.ReverseFind('.');
	if( foundPos >= 0 && foundPos < filename.GetLength()-1 )					//one char minimum
@


1.216
log
@Improved string processing in filename cleanup function.
@
text
@d49 1
a49 1
	if (qwNum <= 0xFFFFFFFF)
d1950 1
a1950 1
static bool IsNTFSVolume(LPCTSTR pcVolume)
d1952 7
d1962 1
a1962 1
	if (!GetVolumeInformation(pcVolume, NULL, 0, NULL, &dwMaximumComponentLength, &dwFileSystemFlags, acFileSystemNameBuffer, ELEMENT_COUNT(acFileSystemNameBuffer)))
d1967 1
a1967 1
static bool IsFileOnNTFSVolume(const CString &strFilePath)
d1975 7
a1981 1
	return IsNTFSVolume(strRootPath);
@


1.215
log
@Simplified code.
@
text
@a1120 1
	CString strList;			//list of pipe-separated tokens
d1175 3
a1177 1
	strList = g_App.m_pPrefs->GetFilenameCleanups().MakeLower();
@


1.214
log
@UNICODE preparations; optimizations; formattings.
@
text
@d727 1
a727 1
void UpdateURLMenu(CMenu &menu, int *piNumURLs)
d729 2
a733 1
	*piNumURLs = 0;
d760 1
a760 1
				if (iPos > 0 && *piNumURLs < 64)
d762 1
a762 2
					(*piNumURLs)++;
					menu.AppendMenu(MF_STRING, MP_WEBURL + (*piNumURLs - 1), strBuffer.Left(iPos).Trim());
d771 2
@


1.213
log
@Minor optimization for tooltip processing.
@
text
@d355 10
a364 7
	CRegKey regkey;
	regkey.Create(HKEY_CLASSES_ROOT,_T("ed2k\\shell\\open\\command"));
	TCHAR rbuffer[500];
	ULONG size = sizeof(rbuffer) / sizeof(rbuffer[0]);
	LONG ret;
	if ((ret = regkey.QueryStringValue(NULL, rbuffer, &size)) != ERROR_SUCCESS)
	{
a365 1
	}
d367 3
a369 3
	TCHAR mod[MAX_PATH];
	if (::GetModuleFileName(NULL, mod, MAX_PATH) == 0)
	{
a370 1
	}
d372 6
a377 1
	CString reg(CString(_T("\"")) + mod + _T("\" \"%1\""));
a378 1
	return (reg == rbuffer);
d380 1
d384 1
a384 1
bool Ask4RegFix(bool dontAsk)
d387 1
d389 1
d391 1
a391 2
#ifndef NEW_SOCKETS_ENGINE
	// check registry if ed2k links is assigned to emule
d394 1
a394 1
		if (dontAsk || (MessageBox(0,GetResString(IDS_ASSIGNED2K),GetResString(IDS_ED2KLINKFIX),MB_ICONQUESTION|MB_YESNO) == IDYES))
d396 2
a397 1
			CRegKey regkey;
d399 1
a399 3
			TCHAR mod[MAX_PATH];
			if (::GetModuleFileName(NULL, mod, MAX_PATH) == 0)
			{
a400 2
			}
			CString reg(CString(_T("\"")) + mod + _T("\" \"%1\""));
d402 12
a413 7
			regkey.Create(HKEY_CLASSES_ROOT,_T("ed2k\\shell\\open\\command"));
			regkey.SetStringValue(0,reg);
			regkey.Create(HKEY_CLASSES_ROOT,_T("ed2k\\DefaultIcon") );// Added Shrink
			regkey.SetStringValue(0,mod);
			regkey.Create(HKEY_CLASSES_ROOT,_T("ed2k") );
			regkey.SetStringValue(0,_T("URL: ed2k Protocol"));
			regkey.SetStringValue(_T("URL Protocol"),_T("") );
d418 1
d420 1
d727 1
a727 1
void UpdateURLMenu(CMenu &menu,int &out_iNumURLs)
d732 1
a732 1
	out_iNumURLs = 0;
d736 1
a736 3
	char	arrcBuffer[1024];
	int		iLenBuf = 1024;

d742 1
a742 1
		while (!feof(pWebServiceFile))
d745 1
a745 1
			if (fgets(arrcBuffer,iLenBuf,pWebServiceFile) == 0)
d747 1
a747 1
			strBuffer = arrcBuffer;
d750 1
a750 1
			if (strBuffer.GetAt(0) == '#' || strBuffer.GetAt(0) == '/' || strBuffer.GetLength() < 5)
d753 1
a753 2
			if (strBuffer == "<separator>\n" || strBuffer == "<separator>")
			{
a754 1
			}
d757 1
a757 1
				int		iPos = strBuffer.Find(',');
d759 1
a759 1
				if (iPos > 0 && out_iNumURLs < 64)
d761 3
a763 3
					out_iNumURLs++;
					menu.AppendMenu(MF_STRING,MP_WEBURL+(out_iNumURLs-1), strBuffer.Left(iPos).Trim());
					g_App.m_strWebServiceURLArray.Add(strBuffer.Right(strBuffer.GetLength()-iPos-1).Trim());
d1377 1
a1377 1
CString GetErrorMessage(CException* e)
d1379 1
a1379 1
	ASSERT(e != NULL);
d1381 7
a1387 4
	const size_t bs = 255;
	TCHAR b[bs];
	e->GetErrorMessage(b, bs);
	return CString(b);
d1389 2
a1390 1
	return CString(_T("N/A"));
d1502 1
a1502 1
void MakeFolderName(TCHAR* path)
d1504 1
a1504 11
//	CString string(path);
//	if(string.GetLength() > 0)
//	{
//		if(string.Right(1) == '\\')
//		{
//			string = string.Left(string.GetLength()-1);
//		}
//	}
//	sprintf(path, "%s", string);

	CString strPath(path);
d1506 2
a1507 2
	PathCanonicalize(path, strPath);
	PathRemoveBackslash(path);
@


1.212
log
@Large file size support preparations.
@
text
@d1859 1
a1859 4
	CPoint			pt;

	::GetCursorPos(&pt);
	ctrl->ScreenToClient(&pt);
d1861 2
a1862 1
	LVHITTESTINFO	hit, subhit;
d1864 1
a1864 2
	hit.pt = pt;
	subhit.pt = pt;
d1867 1
a1867 1
	int				iSel = ctrl->HitTest(&hit);
@


1.211
log
@Removed function reading file in a circular way as such possibility was removed long time ago.
@
text
@d776 1
a776 1
		strTemp.Format(_T("%u"), pFile->GetFileSize());
@


1.210
log
@Unicode preparations.
@
text
@a1913 35
//	CircularFileRead() opens file and read information in circular way.
//		Params:
//			pcFileName    - file to open;
//			dwOffset      - file offset to start reading from;
//			dwBytesToRead - number of bytes to read;
//			pbyteBuffer   - buffer to receive data.
//		Return:
//			TRUE if operation is successful, else FALSE.
bool __stdcall CircularFileRead(const TCHAR *pcFileName, uint32 dwOffset, uint32 dwBytesToRead, byte *pbyteBuffer)
{
	bool	bRc = false;

	EMULE_TRY

	CFile	file;

	if (file.Open(pcFileName, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
	{
		file.Seek(dwOffset, CFile::begin);

		if (uint32 dwDone = file.Read(pbyteBuffer, dwBytesToRead) != dwBytesToRead)
		{
		//	Data wraps, read the rest from the beginning
			file.SeekToBegin();
			file.Read(pbyteBuffer + dwDone, dwBytesToRead - dwDone);
		}
		file.Close();
		bRc = true;
	}

	EMULE_CATCH

	return bRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.209
log
@corrected minor typo
@
text
@d1401 19
d2079 1
a2080 1

@


1.208
log
@UNICODE preparations; optimizations; formattings
@
text
@d887 1
a887 1
	uint32	dwClientType = static_cast<unsigned>(eClientType);
@


1.207
log
@Unicode corrections.
@
text
@d31 5
d37 1
a37 4
static const TCHAR s_acHexDigits[16] = { _T('0'), _T('1'), _T('2'), _T('3'), _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9'), _T('A'), _T('B'), _T('C'), _T('D'), _T('E'), _T('F') };

// Base chars for encode an decode functions
#if 0	//can be required later for AICH
a39 26
#define BASE16_LOOKUP_MAX 23
static byte base16Lookup[BASE16_LOOKUP_MAX][2] = {
    { '0', 0x0 },
    { '1', 0x1 },
    { '2', 0x2 },
    { '3', 0x3 },
    { '4', 0x4 },
    { '5', 0x5 },
    { '6', 0x6 },
    { '7', 0x7 },
    { '8', 0x8 },
    { '9', 0x9 },
	{ ':', 0x9 },
    { ';', 0x9 },
    { '<', 0x9 },
    { '=', 0x9 },
    { '>', 0x9 },
    { '?', 0x9 },
    { '@@', 0x9 },
    { 'A', 0xA },
    { 'B', 0xB },
    { 'C', 0xC },
    { 'D', 0xD },
    { 'E', 0xE },
    { 'F', 0xF }
};
d100 1
a100 1
	return CString(_T(""));
d103 1
a103 1
CString CastItoIShort(uint64 count)
d108 1
a108 1
	CString		strBuffer, strDecimalPoint = GetLocalDecimalPoint();
d110 10
a119 23
	if (count < 1000)
	{
		strBuffer.Format(_T("%i"), count);
	}
	else if (count < 1000000)
	{
		if (g_App.m_pPrefs->ShowRoundSizes())
			strBuffer.Format(_T("%.f%s"), static_cast<double>(count) / 1000.0, GetResString(IDS_KILO).GetBuffer(0));
		else
			strBuffer.Format(_T("%.2f%s"), static_cast<double>(count) / 1000.0, GetResString(IDS_KILO).GetBuffer(0));
	}
	else if (count < 1000000000)
	{
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(count) / 1000000.0, GetResString(IDS_MEGA).GetBuffer(0));
	}
	else if (count < 1000000000000)
	{
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(count) / 1000000000.0, GetResString(IDS_GIGA).GetBuffer(0));
	}
	else if (count < 1000000000000000)
	{
		strBuffer.Format(_T("%.2f%s"), static_cast<double>(count) / 1000000000000.0, GetResString(IDS_TERRA).GetBuffer(0));
	}
d123 1
a123 1
		int		iPos1 = strBuffer.Find(strDecimalPoint);
d127 1
a127 1
			int		iPos2 = strBuffer.Find(_T(" "), iPos1 + strDecimalPoint.GetLength());
d148 1
a148 1
	return CString(_T(""));
d151 1
a151 1
CString CastSecondsToHM(sint32 count, TimeFormat enumTimeFormat /*=TIMEFORMAT_D_DAYS_H_HOURS*/)
d153 2
a154 1
	EMULE_TRY
d156 8
a163 10
#ifndef NEW_SOCKETS_ENGINE
	CString buffer;
	if (count < 0)
		buffer = _T("?");
	else if (count < 60)
		buffer.Format(_T("%i %s"),count,GetResString(IDS_SECS).GetBuffer(0));
	else if (count < 3600)
		buffer.Format(_T("%i:%02i %s"),count/60,count-(count/60)*60,GetResString(IDS_MINS).GetBuffer(0));
	else if (count < 86400)
		buffer.Format(_T("%i:%02i %s"),count/3600,(count-(count/3600)*3600)/60,GetResString(IDS_HOURS).GetBuffer(0));
d166 1
a166 1
		switch (enumTimeFormat)
d169 1
a169 1
				buffer.Format(_T("%i %s %i %s"),count/86400,GetResString(IDS_DAYS).GetBuffer(0),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS).GetBuffer(0));
d172 1
a172 1
				buffer.Format(_T("%i:%02i %s"),count/86400,(count-(count/86400)*86400)/3600,GetResString(IDS_DAYS).GetBuffer(0));
d177 3
a179 2
	return buffer;

a180 4

	EMULE_CATCH2

	return CString(_T(""));
d183 1
a183 2

CString CastSecondsToLngHM(uint64 count)
d186 8
a193 9
	CString buffer;
	if (count < 0)
		buffer = _T("?");
	else if (count < 60)
		buffer.Format("%I64d %s",count,GetResString(IDS_LONGSECS));
	else if (count < 3600)
		buffer.Format("%I64d:%02u %s", count/60, static_cast<uint32>(count-(count/60)*60), GetResString(IDS_LONGMINS));
	else if (count < 86400)
		buffer.Format("%I64d:%02u %s", count/3600, static_cast<uint32>((count-(count/3600)*3600)/60), GetResString(IDS_LONGHRS));
d196 3
a198 2
		__int64 cntDays = count/86400;
		__int64 cntHrs = (count-(count/86400)*86400)/3600;
d200 1
a200 1
		CString strDay = GetResString((count < 172800) ? IDS_LONGDAY : IDS_LONGDAYS);
d202 2
a203 4
		if (cntHrs)
		{
			buffer.Format("%I64d %s %I64d:%02u %s", cntDays, strDay, cntHrs, (uint32)(count-(cntDays*86400)-(cntHrs*3600))/60, GetResString(IDS_LONGHRS));
		}	
d205 1
a205 3
		{
			buffer.Format("%I64d %s %u %s",cntDays, strDay ,(uint32)(count-(cntDays*86400)-(cntHrs*3600))/60, GetResString(IDS_LONGMINS));
		}
d207 1
a207 1
	return buffer;
d209 1
a209 1
	return CString(_T(""));
d236 1
a236 1
			strBuffer.Insert(iIndex, (TCHAR)(dwDigVal + _T('0')));
d249 1
a249 1
	return CString(_T(""));
d255 1
a255 1
    ShellExecute(NULL, _T("open"), name, NULL, NULL, SW_SHOW);
d270 1
a270 1
	//    BYTE b = 0;
d560 2
a561 2
	static BOOL _bInitialized = FALSE;
	static BOOL (WINAPI *_pGetDiskFreeSpaceEx)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER) = NULL;
d566 3
d570 1
d573 1
a573 1
	if(_pGetDiskFreeSpaceEx)
d575 4
a578 4
		ULARGE_INTEGER nFreeDiskSpace;
		ULARGE_INTEGER dummy;
		_pGetDiskFreeSpaceEx(pDirectory, &nFreeDiskSpace, &dummy, &dummy);
		return nFreeDiskSpace.QuadPart;
d582 4
a585 3
		TCHAR acDrive[16];
		const TCHAR *p = _tcschr(pDirectory, _T('\\'));
		if (p)
d592 3
a594 1
		DWORD dwSectPerClust, dwBytesPerSect, dwFreeClusters, dwDummy;
d654 1
a654 1
#if 0	//can be required later for AICH
d665 4
a668 2
	CString Base32Buff(_T(""));
    EMULE_TRY
d670 1
a670 1
    unsigned char word;
d673 1
a673 1
    for(i = 0, index = 0; i < bufLen;)
d677 1
a677 11
        if (index > 3)
		{
            word = (buffer[i] & (0xFF >> index));
            index = (index + 5) % 8;
            word <<= index;
            if (i < bufLen - 1)
                word |= buffer[i + 1] >> (8 - index);

            i++;
        }
		else
d679 5
a683 5
            word = (buffer[i] >> (8 - (index + 5))) & 0x1F;
            index = (index + 5) % 8;
            if (index == 0)
               i++;
        }
d685 1
a685 40
		Base32Buff += (char) base32Chars[word];
    }
	EMULE_CATCH
    return Base32Buff;
}
#endif

// Decodes a BASE16 string into a byte array
//
// [In]
//   base16Buffer: String containing BASE16
//   base16BufLen: Lenght BASE16 coded string's length
//
// [Out]
//   buffer: byte array containing decoded string
bool DecodeBase16(const char *base16Buffer, unsigned int base16BufLen, byte *buffer, unsigned int bufflen)
{
	EMULE_TRY

	unsigned int uDecodeLengthBase16 = DecodeLengthBase16(base16BufLen);
	if (uDecodeLengthBase16 > bufflen)
		return false;

	memzero(buffer, uDecodeLengthBase16);

	for(unsigned int i = 0; i < base16BufLen; i++)
	{
		int lookup = toupper(base16Buffer[i]) - '0';

		// Check to make sure that the given word falls inside a valid range
		byte word = 0;

		if ( lookup < 0 || lookup >= BASE16_LOOKUP_MAX)
			word = 0xFF;
		else
			word = base16Lookup[lookup][1];

		if(i % 2 == 0)
		{
			buffer[i/2] = word << 4;
d689 4
a692 1
			buffer[(i-1)/2] |= word;
d694 2
a696 1
	return true;
d699 2
a700 1
	return false;
d702 1
d724 3
a726 3
	CString		strName,strURL,strBuffer;
	char		arrcBuffer[1024];
	int			iLenBuf = 1024;
d728 1
a728 1
	FILE	   *pWebServiceFile = _tfopen(CString(g_App.m_pPrefs->GetConfigDir())+_T("webservices.dat"), _T("r"));
a841 1
	{
a842 1
	}
a843 1
	{
a844 1
	}
d871 1
a871 1
CString GetClientNameString(EnumClientTypes clienttype)
d873 2
a874 1
	static const TCHAR s_acNames[][10] = {
d886 2
a887 2
	CString strName;
	uint32	dwClientType = clienttype;
d911 1
a911 1
	   break;
d1090 2
a1091 2
		   	if( pos == 0 || pos == max )
					strIn.SetAt(pos, _T(' '));
d1093 2
a1094 2
				else if (exceptStr.Find(strIn.GetAt(pos-1)) < 0 || exceptStr.Find(strIn.GetAt(pos+1)) < 0)
					strIn.SetAt(pos, _T(' '));
d1306 1
a1306 1
	// If you pass in zero, 'FormatMessage' looks for a message for LANGIDs in 
d1309 5
a1313 5
	//	1) Language neutral 
	//	2) Thread LANGID, based on the thread's locale value 
	//  3) User default LANGID, based on the user's default locale value 
	//	4) System default LANGID, based on the system default locale value 
	//	5) US English 
d1315 3
a1317 3
	DWORD		dwLength = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_IGNORE_INSERTS,
								   NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
								   (LPTSTR)&pszSysMsg, 0, NULL);
d1384 5
a1388 4
    CFileDialog myFileDialog(openfilestyle,NULL,pszDefaultFileName,
							 dwFlags | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, pszFilters, NULL,
							 0/*automatically use explorer style open dialog on systems which support it*/);
    if (myFileDialog.DoModal() != IDOK)
d1518 3
a1520 16
	int r = GetRValue(crColor);
	int g = GetGValue(crColor);
	int b = GetBValue(crColor);

	r += i;
	g += i;
	b += i;

	r = min(r, 255);
	r = max(r, 0);
	g = min(g, 255);
	g = max(g, 0);
	b = min(b, 255);
	b = max(b, 0);

	return RGB(r,g,b);
d1523 1
a1523 1
// note: if value of qwTotal is larger as 1e+13 (10000 Gb), then calculation will be incorrect 
d1581 1
a1581 1
	TCHAR acHash[MAX_HASHSTR_SIZE];
d1620 1
a1620 1
	static DWORD (WINAPI *_pfnGetCompressedFileSize)(LPCSTR, LPDWORD) = NULL;
d1625 5
a1629 1
		(FARPROC&)_pfnGetCompressedFileSize = GetProcAddress(GetModuleHandle("kernel32.dll"), "GetCompressedFileSizeA");
d1667 2
a1668 2
	CString		strResult;
	
d1671 1
a1671 1
		int			iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, NULL, 0);
d1675 2
a1676 5
			TCHAR	*szBuffer = new TCHAR[iSize];

			if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, szBuffer, iSize) != NULL)
				strResult = szBuffer;
			delete[] szBuffer;
d1681 1
a1681 5
	{
		struct lconv	*lconv_struct = localeconv();

		strResult = *lconv_struct->decimal_point;
	}
d1688 1
a1688 1
	CString		strResult;
d1692 1
a1692 1
		int			iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, NULL, 0);
d1696 2
a1697 5
			TCHAR	*szBuffer = new TCHAR[iSize];

			if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, szBuffer, iSize) != NULL)
				strResult = szBuffer;
			delete[] szBuffer;
d1702 1
a1702 5
	{
		struct lconv	*lconv_struct = localeconv();

		strResult = *lconv_struct->thousands_sep;
	}
d1709 1
a1709 1
	CString		strResult;
d1713 1
a1713 1
		int			iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SNEGATIVESIGN, NULL, 0);
d1717 2
a1718 5
			TCHAR	*szBuffer = new TCHAR[iSize];

			if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SNEGATIVESIGN, szBuffer, iSize) != NULL)
				strResult = szBuffer;
			delete[] szBuffer;
d1723 1
a1723 5
	{
		struct lconv	*lconv_struct = localeconv();

		strResult = *lconv_struct->negative_sign;
	}
d2024 2
a2025 1
	static const char *const s_apcTypes[ED2KFT_COUNT] = {
d2035 1
a2035 1
	return s_apcTypes[GetED2KFileTypeID(strFileName)];
@


1.206
log
@Fixed Unicode issue.
@
text
@d1486 4
a1489 3
	uint32	dwStrLen = strNormal.GetLength();
	BYTE *pBuf = new BYTE[dwStrLen * 2 + 1];
	strcpy((char *)pBuf, strNormal);
d1491 1
a1491 1
	for (uint32 dwBufSize = dwStrLen; dwBufSize--;)
d1493 2
a1494 2
		((PSTR) pBuf)[2 * dwBufSize + 1]	= (((PSTR) pBuf)[dwBufSize] % 0x10) + 'A';
		((PSTR) pBuf)[2 * dwBufSize]		= (((PSTR) pBuf)[dwBufSize] / 0x10) + 'A';
a1495 6

	pBuf[dwStrLen*2] = 0;

	CString str(pBuf);
	delete[] pBuf;

d1501 4
a1504 2
	uint32	dwStrLen = strCrypted.GetLength() / 2;
	BYTE *pBuf = new BYTE[dwStrLen + 1];
d1506 1
a1506 1
	for (uint32 dwPos = 0; dwPos < dwStrLen; dwPos++)
d1508 1
a1508 2
		((PSTR) pBuf)[dwPos] = (((strCrypted.GetAt(dwPos * 2) - _T('A')) << 4) & 0xFF) |
			((strCrypted.GetAt(dwPos * 2 + 1) - _T('A')) & 0xFF);
a1509 6

	pBuf[dwStrLen] = 0;

	CString str(pBuf);
	delete[] pBuf;

a1512 1

@


1.205
log
@Suppressed compilation warning.
@
text
@d1879 1
a1879 1
bool IsStolenName(const CString& strUserName)
d2143 3
a2145 3
//	GetFileTypeForWebServer() returns file type according to WebServer requirements.
//		Params: strFileName - file name (case insensitive).
const char* GetFileTypeForWebServer(const CString &strFileName)
d2148 8
a2155 8
		"other",		//ED2KFT_ANY
		"music",		//ED2KFT_AUDIO
		"movie",		//ED2KFT_VIDEO
		"picture",		//ED2KFT_IMAGE
		"application",	//ED2KFT_PROGRAM
		"document",		//ED2KFT_DOCUMENT
		"archive",		//ED2KFT_ARCHIVE
		"cdimage"		//ED2KFT_CDIMAGE
@


1.204
log
@Fixed compilation, sorry and enjoy it again.
@
text
@d914 1
a914 1
	if ((in.GetLength() <= uiLen) || (uiLen <= (1u + 3u + 8u)))
@


1.203
log
@Download state to string conversion was moved to download client class;
Some Unicode corrections by KuSh.
@
text
@d914 1
a914 1
	if ((in.GetLength() <= uiLen) || (uiLen <= (1 + 3 + 8)))
@


1.202
log
@Removed unused code.
@
text
@a482 1
// Barry - Restore previous values
d912 1
a912 1
CString StringLimit(const CString& in,uint16 length)
d914 3
a916 2
	if (in.GetLength()<=length || length<10) return in;
	return (in.Left(length-8)+_T("...")+in.Right(8));
a930 56
CString GetStatusDLQueueString(EnumDLQState &State)
{
#ifndef NEW_SOCKETS_ENGINE
	UINT		dwResStrId;

	EMULE_TRY

	switch(State)
	{
	case DS_DOWNLOADING:
		dwResStrId = IDS_TRANSFERRING;
		break;
	case DS_ONQUEUE:
		dwResStrId = IDS_ONQUEUE;
		break;
	case DS_CONNECTED:
		dwResStrId = IDS_ASKING;
		break;
	case DS_CONNECTING:
		dwResStrId = IDS_CONNECTING;
		break;
	case DS_WAITCALLBACK:
		dwResStrId = IDS_CONNVIASERVER;
		break;
	case DS_REQHASHSET:
		dwResStrId = IDS_RECHASHSET;
		break;
	case DS_NONEEDEDPARTS:
		dwResStrId = IDS_NONEEDEDPARTS;
		break;
	case DS_LOWTOLOWIP:
		dwResStrId = IDS_NOCONNECTLOW2LOW;
		break;
	case DS_ERROR:
		dwResStrId = IDS_ERROR_STATE;
		break;
	case DS_WAIT_FOR_FILE_REQUEST:
		dwResStrId = IDS_WAITFILEREQ;
		break;
	case DS_LOWID_ON_OTHER_SERVER:
		dwResStrId = IDS_ANOTHER_SERVER_LOWID;
		break;
	case DS_NONE:
	default:
		dwResStrId = IDS_UNKNOWN;
		break;
	};

	EMULE_CATCH

	return GetResString(dwResStrId);
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}

d1476 1
a1476 1
#ifdef UNICODE
d1881 25
a1905 1
	EMULE_TRY
d1907 1
a1907 22
	if ( !strUserName.IsEmpty() && (
         //--- equals ---
	         strUserName == "pbwll" ||
	         strUserName == "unix user" ||
	         strUserName == "http://emule-element.tk"
         //--- begins with ---
	         || strUserName.Find("Odin") != -1
	         || strUserName.Find("$GAM3R$") != -1
	         || strUserName.Find("G@@m3rs Edit") != -1
	         || strUserName.Find("G@@m3rs Edit") != -1
	         || strUserName.Find("[RAMMSTEIN") != -1
	         || strUserName.Find("[toXic]") != -1
	         || strUserName.Find("Leecha") != -1
	         || strUserName.Find("leecha") != -1
	         || strUserName.Find("eDevil") != -1
	         || strUserName.Find("darkmule") != -1
	         || strUserName.Find("DarkMule") != -1
	         || strUserName.Find("eVortex") != -1
	         || strUserName.Find("|eVorte|X|") != -1
	         || strUserName.Find("MISON") != -1
	         || strUserName.Find("Mison") != -1
	         || strUserName.Find("[miciolino.de]") != -1 ) )
d1909 10
a1918 1
		return true;
a1919 2

	EMULE_CATCH
d1923 1
a1923 1
bool IsLeecherType(const CString& strModVersion)
d1925 1
a1925 11
	if ( !strModVersion.IsEmpty() && (
		strModVersion.Find("00de.de") != -1
		|| strModVersion.Find("LioNetwork") != -1
		|| strModVersion.Find("element") != -1
		|| strModVersion.Find("Plus Plus") != -1
		|| strModVersion.Find("LH") != -1
		|| strModVersion.Find("Mison") != -1
		|| strModVersion.Find("eVortex") != -1
		|| strModVersion.Find("Rappi") != -1
		|| strModVersion.Find("XvooM") != -1
		|| strModVersion.Find("Plus+") != -1 ) )
d1927 19
a1945 1
		return true;
a1946 1

@


1.201
log
@Compatibility with VC2005 [brengarne];
Minor Unicode corrections; Formatting;
Added sanity return code check for GetFreeDiskSpaceX().
@
text
@d35 1
a35 1
static const byte base16Chars[16] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
d37 1
d694 1
d738 1
a738 21

// Returns a BASE16 encoded byte array
//
// [In]
//   buffer: Pointer to byte array
//   bufLen: Lenght of buffer array
//
// [Return]
//   CString object with BASE16 encoded byte array
CString EncodeBase16(const unsigned char* buffer, unsigned int bufLen)
{
	CString Base16Buff(_T(""));
	EMULE_TRY
	for(unsigned int i = 0; i < bufLen; i++)
	{
		Base16Buff += base16Chars[buffer[i] >> 4];
		Base16Buff += base16Chars[buffer[i] & 0xf];
	}
	EMULE_CATCH
    return Base16Buff;
}
@


1.200
log
@Unicode preparations; Improved string processing.
@
text
@d624 3
a626 3
		char cDrive[16];
		char *p = strchr(pDirectory, '\\');
		if(p)
d628 2
a629 2
			memcpy2(cDrive, pDirectory, p-pDirectory);
			cDrive[p-pDirectory] = '\0';
d632 1
a632 1
			strcpy(cDrive, pDirectory);
d634 4
a637 2
		GetDiskFreeSpace(cDrive, &dwSectPerClust, &dwBytesPerSect, &dwFreeClusters, &dwDummy);
		return (dwFreeClusters * dwSectPerClust * dwBytesPerSect);
d1778 1
a1778 1
			unsigned uiDgt1, uiDgt2;
d1780 1
a1780 1
			for (unsigned ui = 0; ui < 16; ui++)
@


1.199
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@a23 1
//#include "Winsock2.h"
d1231 1
a1231 1
CString ReplaceDotsWithSpaces(CString inStr, CString exceptStr /*=""*/, CString addClear /*=""*/, bool keepExt /*=false*/)
d1238 3
a1240 3
	int extpos = inStr.ReverseFind('.');
	int max = inStr.GetLength()-1;
	for (int pos=0; pos <= max; pos++)
d1242 1
a1242 1
		if (inStr.GetAt(pos) == '.')
d1246 1
a1246 1
				inStr.SetAt(pos, ' ');
d1248 2
a1249 2
			else if( exceptStr.Find(inStr.GetAt(pos-1)) < 0 || exceptStr.Find(inStr.GetAt(pos+1)) < 0)
				inStr.SetAt(pos, ' ');
d1252 2
a1253 2
		else if (addClear.Find(inStr.GetAt(pos)) >= 0)
			inStr.SetAt(pos, ' ');
d1255 2
a1256 1
	if (keepExt && extpos >= 0) inStr.SetAt(extpos, '.');
d1258 1
a1258 1
	return inStr;
d1655 1
a1655 1
CHAR *stristr(const CHAR *str1, const CHAR *str2)
d1657 3
a1659 3
	const CHAR *cp = str1;
	const CHAR *s1;
	const CHAR *s2;
d1662 1
a1662 1
		return (CHAR *)str1;
d1669 1
a1669 1
		while (*s1 && *s2 && tolower(*s1) == tolower(*s2))
d1673 1
a1673 1
			return (CHAR *)cp;
d1757 1
a1757 1
CString HashToString(const uchar *hash)
d1770 1
a1770 1
byte* StringToHash(const CString &strHexStr, byte *pbyteHash)
d2005 1
a2005 1
CString	YesNoStr(bool bYes)
@


1.198
log
@renamed 3 variables
@
text
@d83 1
a83 1
				strBuffer.Format( (g_App.g_pPrefs->ShowRoundSizes()) ? _T("%.f %s") : _T("%.2f %s"),
d100 1
a100 1
	if (g_App.g_pPrefs->ShowRoundSizes())
d140 1
a140 1
		if (g_App.g_pPrefs->ShowRoundSizes())
d158 1
a158 1
	if (g_App.g_pPrefs->ShowRoundSizes())
d365 1
a365 1
	if (!strResString.LoadString(hMod, dwStringID, g_App.g_pPrefs->GetLanguageID()))
d393 1
a393 1
	if (!pstrOutput->LoadString(hMod, dwStringID, g_App.g_pPrefs->GetLanguageID()))
d826 1
a826 1
	FILE	   *pWebServiceFile = _tfopen(CString(g_App.g_pPrefs->GetConfigDir())+_T("webservices.dat"), _T("r"));
d886 1
a886 1
	ShellExecute(NULL, NULL, srtURLPattern, NULL, g_App.g_pPrefs->GetAppDir(), SW_SHOWDEFAULT);
d1298 1
a1298 1
	if (g_App.g_pPrefs->GetFilenameCleanupTags())
d1322 1
a1322 1
	strList = g_App.g_pPrefs->GetFilenameCleanups().MakeLower();
d1829 1
a1829 1
	switch (g_App.g_pPrefs->GetLanguageID())
d1928 1
a1928 1
	if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_SRC_DETAILS))
d1932 1
a1932 1
	else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_SRC_FRIEND))
d1937 1
a1937 1
	else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_SRC_MSG))
d1941 1
a1941 1
	else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_SRC_SHAREDFILES))
@


1.197
log
@Hash to string conversion is ready for Unicode.
@
text
@d83 1
a83 1
				strBuffer.Format( (g_eMuleApp.m_pGlobPrefs->ShowRoundSizes()) ? _T("%.f %s") : _T("%.2f %s"),
d100 1
a100 1
	if (g_eMuleApp.m_pGlobPrefs->ShowRoundSizes())
d140 1
a140 1
		if (g_eMuleApp.m_pGlobPrefs->ShowRoundSizes())
d158 1
a158 1
	if (g_eMuleApp.m_pGlobPrefs->ShowRoundSizes())
d365 1
a365 1
	if (!strResString.LoadString(hMod, dwStringID, g_eMuleApp.m_pGlobPrefs->GetLanguageID()))
d393 1
a393 1
	if (!pstrOutput->LoadString(hMod, dwStringID, g_eMuleApp.m_pGlobPrefs->GetLanguageID()))
d820 1
a820 1
	g_eMuleApp.m_strWebServiceURLArray.RemoveAll();
d826 1
a826 1
	FILE	   *pWebServiceFile = _tfopen(CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir())+_T("webservices.dat"), _T("r"));
d854 1
a854 1
					g_eMuleApp.m_strWebServiceURLArray.Add(strBuffer.Right(strBuffer.GetLength()-iPos-1).Trim());
d886 1
a886 1
	ShellExecute(NULL, NULL, srtURLPattern, NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
d1298 1
a1298 1
	if (g_eMuleApp.m_pGlobPrefs->GetFilenameCleanupTags())
d1322 1
a1322 1
	strList = g_eMuleApp.m_pGlobPrefs->GetFilenameCleanups().MakeLower();
d1829 1
a1829 1
	switch (g_eMuleApp.m_pGlobPrefs->GetLanguageID())
d1928 1
a1928 1
	if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_SRC_DETAILS))
d1932 1
a1932 1
	else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_SRC_FRIEND))
d1937 1
a1937 1
	else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_SRC_MSG))
d1941 1
a1941 1
	else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_SRC_SHAREDFILES))
@


1.196
log
@One more step to integrate eklmn's SSDQ.
@
text
@d33 1
a33 1
static const char s_acHexDigits[16] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
d1742 1
a1742 1
void md4str(const uchar *hash, char *pszHash)
d1744 2
a1745 1
	unsigned uiCh;
d1753 2
a1754 1
	*pszHash = '\0';
d1759 1
a1759 1
	char acHash[MAX_HASHSTR_SIZE];
d1761 1
a1761 2
	md4str(hash, acHash);
	return acHash;
@


1.195
log
@Improved string processing; Minor Unicode corrections.
@
text
@a977 3
	case DS_TOOMANYCONNS:
		dwResStrId = IDS_TOOMANYCONNS;
		break;
@


1.194
log
@Removed unused DS_BANNED state.
@
text
@d1559 1
a1559 1
CString Crypt(CString sNormal)
d1561 3
a1563 3
	ULONG lStringLen = sNormal.GetLength();
	BYTE *pBuf = new BYTE[lStringLen * 2 + 1];
	strcpy((char *)pBuf, sNormal);
d1565 1
a1565 1
	for (ULONG dwBufSize = lStringLen; dwBufSize--; )
d1571 1
a1571 1
	pBuf[lStringLen*2] = 0;
d1579 1
a1579 1
CString Decrypt(CString sCrypted)
d1581 2
a1582 3
	ULONG lStringLen = sCrypted.GetLength();
	lStringLen /= 2;
	BYTE *pBuf = new BYTE[lStringLen + 1];
d1584 1
a1584 1
	for (ULONG dwPos = 0; dwPos < lStringLen; dwPos++)
d1586 2
a1587 4
		char chHigh = ((PCSTR) sCrypted)[dwPos * 2] - 'A';
		char chLow  = ((PCSTR) sCrypted)[dwPos * 2 + 1] - 'A';

		((PSTR) pBuf)[dwPos] = (chHigh << 4) + chLow;
d1590 1
a1590 1
	pBuf[lStringLen] = 0;
@


1.193
log
@One more step to integrate eklmn's SSDQ.
@
text
@a983 3
	case DS_BANNED:
		dwResStrId = IDS_BANNED;
		break;
@


1.192
log
@Some eklmn's modifications.
@
text
@d993 3
@


1.191
log
@Identification of new Shareaza.
@
text
@d990 3
d1000 1
a1016 1
		IDS_NOCONNECTLOW2LOW,	//US_LOWTOLOWIP
@


1.190
log
@Unified and regrouped shortcuts.
@
text
@d2058 1
@


1.189
log
@Process client shortcuts for friend list too {DopeFish}.
@
text
@d1930 1
a1930 1
	if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails))
d1934 1
a1934 1
	else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend))
d1939 1
a1939 1
	else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage))
d1943 1
a1943 1
	else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles))
@


1.188
log
@Faster size to string conversion;
Improved string processing; Unicode preparations.
@
text
@d1936 2
a1937 4
		if (pClient->IsFriend())
			iMessage = MP_REMOVEFRIEND;
		else
			iMessage = MP_ADDFRIEND;
@


1.187
log
@Removed banning of eF-Mod.
@
text
@d65 1
a65 1
CString CastItoXBytes(uint64 count)
d70 2
a71 1
	CString		strBuffer, strDecimalPoint = GetLocalDecimalPoint();
d73 1
a73 1
	if (count < 1024)
d75 4
a78 6
		strBuffer.Format(_T("%.f %s"), static_cast<double>(count), GetResString(IDS_BYTES).GetBuffer(0));
	}
	else if (count < 1048576)
	{
		if (g_eMuleApp.m_pGlobPrefs->ShowRoundSizes())
			strBuffer.Format(_T("%.f %s"), static_cast<double>(count) / 1024.0, GetResString(IDS_KBYTES).GetBuffer(0));
d80 10
a89 9
			strBuffer.Format(_T("%.2f %s"), static_cast<double>(count) / 1024.0, GetResString(IDS_KBYTES).GetBuffer(0));
	}
	else if (count < 1073741824)
	{
		strBuffer.Format(_T("%.2f %s"), static_cast<double>(count) / 1048576.0, GetResString(IDS_MBYTES).GetBuffer(0));
	}
	else if (count < 1099511627776)
	{
		strBuffer.Format(_T("%.2f %s"), static_cast<double>(count) / 1073741824.0, GetResString(IDS_GBYTES).GetBuffer(0));
d93 5
a97 1
		strBuffer.Format(_T("%.3f %s"), static_cast<double>(count) / 1099511627776.0, GetResString(IDS_TBYTES).GetBuffer(0));
d102 1
d105 1
a105 1
		if (iPos1 != -1)
d107 1
a107 1
			int		iPos2 = strBuffer.Find(_T(" "), iPos1 + strDecimalPoint.GetLength());
d109 1
a109 1
			if (iPos2 != -1)
d111 1
a111 3
				while (strBuffer.GetAt(iPos2 - 1) == _T('0'))
				{
					iPos2--;
d113 1
a113 2
				}
				if (iPos2 - 1 == iPos1)
d260 1
a260 1
CString CastItoThousands(_int64 count)
d265 2
a266 3
	_int64		iVal;
	UINT		iDigVal;
	CString		sThousandSeparator = GetLocalThousandsSep();
d269 1
a269 1
  	if (count < 0)
d272 1
a272 1
		iVal = (_int64)(-(_int64)count);
a273 2
	else
		iVal = count;
d278 1
a278 2
		iDecimalPos++;
		if (iDecimalPos != 4)
d280 1
a280 1
			iDigVal = (unsigned)(iVal % 10);
d282 1
a282 1
			strBuffer.Insert(iIndex, (char)(iDigVal + _T('0')));
d286 1
a286 1
			strBuffer.Insert(iIndex, sThousandSeparator);
d1262 1
a1262 1
CString CleanupFilename(CString inStr)
d1267 3
a1269 2
	CString strList(_T(""));	//list of pipe-separated tokens
	CString resToken(_T(""));	//one token out of strList
a1271 1
	CString extension(_T(""));	//only the extension of filename with dot
d1282 1
a1282 1
		while (true)
d1301 1
a1301 1
		while (true)
d1303 1
a1303 1
			foundPos = filename.Find('[');
d1306 1
a1306 1
			foundPo2 = filename.Find(']',foundPos);
d1309 1
a1309 1
				foundPo3 = filename.Find('[',foundPos+1);
d1313 1
a1313 1
					foundPo3 = filename.Find('[',foundPos+1);
d1322 2
a1323 4
	strList.SetString(g_eMuleApp.m_pGlobPrefs->GetFilenameCleanups().MakeLower());
	curPos = 0;
	resToken.SetString(strList.Tokenize(_T("|"),curPos));
	while (!resToken.IsEmpty())
d1325 4
a1328 2
		filename.Replace(resToken,_T(" "));
		resToken.SetString(strList.Tokenize(_T("|"),curPos));
d1414 1
a1414 1
	filename.Append(_T(" "));
d1819 3
a1821 3
    WIN32_FIND_DATA fd;
    HANDLE hFind = FindFirstFile(pszFilePath, &fd);
    if (hFind == INVALID_HANDLE_VALUE)
@


1.186
log
@v2 - fix for Release configuration
@
text
@d2003 1
a2003 3
		|| strModVersion.Find("Plus+") != -1
		|| strModVersion.Find("eFMod") != -1
		|| strModVersion.Find("eF-Mod") != -1 ) )
@


1.185
log
@Minor improvement to version detection.
Some minor additions to uppercasing (filename cleanup).
@
text
@d456 1
a457 1
#endif //NEW_SOCKETS_ENGINE
@


1.184
log
@Move displaying of LowID from Waited to Status column;
Faster conversion of upload status into string.
@
text
@d586 1
a586 1
			if(osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)	// netwolf: Windows Server 2003
d588 2
a589 1
			break;
d1377 2
d1383 1
@


1.183
log
@Fixed resource string loading when localized string is missed {Psy}.
@
text
@a224 1
	EMULE_TRY
d252 2
a254 2
	EMULE_CATCH2
	return CString(_T(""));
a256 1
// BavarianSnail
d1004 1
a1004 1
CString GetStatusULQueueString(EnumULQState &State)
d1007 1
a1007 5
	UINT		dwResStrId;

	EMULE_TRY

	switch(State)
d1009 9
a1017 28
	case US_UPLOADING:
		dwResStrId = IDS_TRANSFERRING;
		break;
	case US_ONUPLOADQUEUE:
		dwResStrId = IDS_ONQUEUE;
		break;
	case US_WAITCALLBACK:
		dwResStrId = IDS_CONNVIASERVER;
		break;
	case US_CONNECTING:
		dwResStrId = IDS_CONNECTING;
		break;
	case US_PENDING:
		dwResStrId = IDS_PENDING;
		break;
	case US_LOWTOLOWIP:
		dwResStrId = IDS_NOCONNECTLOW2LOW;
		break;
	case US_BANNED:
		dwResStrId = IDS_BANNED;
		break;
	case US_ERROR:
		dwResStrId = IDS_ERROR_STATE;
		break;
	case US_NONE:
	default:
		dwResStrId = IDS_UNKNOWN;
		break;
d1019 1
d1021 3
a1023 2
	EMULE_CATCH
	return GetResString(dwResStrId);
d1025 1
a1025 1
	return _T("");
@


1.182
log
@Many ifdefs for v2
@
text
@d369 1
a369 2
	strResString.LoadString(hMod, dwStringID, g_eMuleApp.m_pGlobPrefs->GetLanguageID());
	if (strResString.IsEmpty())
d383 1
a383 2
	strResString.LoadString(hMod, dwStringID, uLanguageID);
	if (strResString.IsEmpty())
d397 1
a397 2
	pstrOutput->LoadString(hMod, dwStringID, g_eMuleApp.m_pGlobPrefs->GetLanguageID());
	if (pstrOutput->IsEmpty())
@


1.181
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@a32 1
#ifndef NEW_SOCKETS_ENGINE
d69 1
d118 1
d129 1
d179 2
d190 1
d215 2
d225 2
d253 3
d365 1
d373 3
d380 1
d388 3
d396 1
d402 1
d436 1
d462 1
d668 1
d693 3
d824 1
d866 1
d891 1
d893 1
d899 1
d931 3
d956 1
d1004 3
d1011 1
d1050 3
d1074 1
d1077 1
d1291 1
d1455 3
d1854 1
d1861 1
d1952 1
d1975 1
d2037 1
d2039 3
a2242 1
#endif //NEW_SOCKETS_ENGINE
@


1.180
log
@Unified display of file permission and upload file priority.
@
text
@d2209 2
d2267 1
@


1.179
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d2208 57
a2264 1
}@


1.178
log
@Moved GetItemUnderMouse to otherfunctions.
@
text
@d2186 23
@


1.177
log
@Add sources possibly received from global search (official).
Added missing translations in case countryflag.dll / ip-to-country.cvs is not found.
Notifier informs if a new version is available (not annoying, but still more likely
 to be noticed than just a log line).
Added 'Folder' column to Shared files window.
Prevent adding install/working dirs (\Webserver, \Db...) to Shared files.
+ some other minor changes/fixes.
@
text
@d1986 28
@


1.176
log
@Faster URL decoding; Formatting; Added GPL violator+leecher.
@
text
@d220 1
a220 1
		buffer = "?";
@


1.175
log
@WebServer: faster way to detect file type as well as more file extentions added
(thanks eklmn for idea).
@
text
@d1085 14
a1098 2
//SyruS: cleanup centralized functions
CString URLDecode(CString inStr)
d1101 10
a1110 5
	CString outStr("");
	int more = -1;
	for (int x = 0;x < inStr.GetLength() ; ++x )
	{
		if ( inStr.GetAt(x)== '%' && x+2 < inStr.GetLength() && _istxdigit(inStr.GetAt(x+1)) && _istxdigit(inStr.GetAt(x+2)) )
a1111 1
			TCHAR hexstr[3]; hexstr[2]=0;
d1114 1
a1114 2
			_tcsncpy(hexstr, inStr.Mid(x+1,2).GetBuffer(), 2);
			x = x + 2;
d1117 1
a1117 1
			Result = _tcstoul(hexstr, NULL, 16);
d1120 3
a1122 3
	         sumb = (sumb << 6) | (Result & 0x3f) ;	// Add 6 bits to sumb
	         if (--more == 0) outStr.AppendChar((char) sumb) ; // Add char to sbuf
            }
d1125 2
a1126 2
	          outStr.AppendChar((char) Result) ;			// Append Character
            }
d1129 2
a1130 2
			  sumb = Result & 0x1f;
	          more = 1;				// Expect 1 more byte
d1134 2
a1135 2
			  sumb = Result & 0x0f;
	          more = 2;				// Expect 2 more bytes
d1139 2
a1140 2
			  sumb = Result & 0x07;
			  more = 3;				// Expect 3 more bytes
d1144 2
a1145 2
			 sumb = Result & 0x03;
			 more = 4;				// Expect 4 more bytes
d1149 2
a1150 2
			 sumb = Result & 0x01;
			 more = 5;				// Expect 5 more bytes
d1155 1
a1155 1
			outStr.AppendChar( inStr.GetAt(x));
d1160 1
d1162 2
a1163 1
	return inStr;
a1740 13
//	HexChr2Num() converts hexadecimal character to a number.
//		Params: cCh - char ('0'-'9','A'-'F','a'-'f')
//		Return: 0..15 - number, else error
static unsigned HexChr2Num(TCHAR cCh)
{
	unsigned	uiDigit;

	if ((uiDigit = static_cast<unsigned>(cCh - _T('0'))) > 9u)
		uiDigit = static_cast<unsigned>(static_cast<TCHAR>(CHR2UP(cCh)) - _T('A')) + 10u;
	return uiDigit;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a1960 2
	EMULE_TRY

d1963 1
a1965 1
		|| strModVersion.Find("eVortex") != -1
a1966 1
		|| strModVersion.Find("LioNetwork") != -1
d1968 1
d1971 1
a1977 1
	EMULE_CATCH
@


1.174
log
@New eMule Plus identification;
Inform a remote client when 'See my share = No one' to save traffic (original).
@
text
@d2139 16
@


1.173
log
@Service was moved to the H-file.
@
text
@d1914 2
a1915 1
		iMessage = MP_SHOWLIST;
d2000 3
@


1.172
log
@Minor corrections.
@
text
@a1722 3
//	Convert char to upper case
#define CHR2UP(ch)		((ch) & ~(_T('A') ^ _T('a')))

@


1.171
log
@Fixed rehashing on Daylight Saving Time change (official).
@
text
@d1026 1
d1028 2
a1029 2
	if (clienttype < SO_UNKNOWN)
		strName = reinterpret_cast<const TCHAR*>(&s_acNames[clienttype]);
@


1.170
log
@Strike Back!
@
text
@d2072 65
@


1.169
log
@Fractional upload/download limits (min 1 KB/s, granularity 0.1 KB/s).
@
text
@d1969 3
a1971 1
		|| strModVersion.Find("XvooM") != -1 ) )
@


1.168
log
@Own client type for eMule Plus clients.
@
text
@a1987 1
		{
d1989 1
a1989 5
		}
		case 20:
		{
			return SO_LPHANT;
		}
a1990 1
		{
d1992 1
a1992 1
		}
a1993 1
		{
d1995 1
a1995 1
		}
a1996 1
		{
d1998 1
a1998 1
		}
a1999 1
		{
d2001 4
a2004 1
		}
d2061 9
@


1.167
log
@LMULE -> XMULE; Faster obtainment of client name by client type.
@
text
@d877 7
d1014 1
@


1.166
log
@Improved string to hash conversion.
@
text
@d1006 17
a1022 1
	CString strName = GetResString(IDS_UNKNOWN);
a1023 27
	switch(clienttype)
	{
	case SO_EMULE:
		strName = _T("eMule");
		break;
	case SO_AMULE:
		strName = _T("aMule");
		break;
	case SO_LMULE:
		strName = _T("xMule");
		break;
	case SO_SHAREAZA:
		strName = _T("Shareaza");
		break;
	case SO_EDONKEYHYBRID:
		strName = _T("Hybrid");
		break;
	case SO_EDONKEY:
		strName = _T("eDonkey");
		break;
	case SO_MLDONKEY:
		strName = _T("MLdonkey");
		break;
	case SO_LPHANT:
		strName = _T("lphant");
		break;
	};
d1989 1
a1989 1
			return SO_LMULE;
@


1.165
log
@Leecher modes update.
@
text
@d1725 47
@


1.164
log
@Fixed directory creating [reported by Cheesy].
@
text
@d1924 2
a1925 1
		|| strModVersion.Find("Rappi") != -1 ) )
@


1.163
log
@Client "LMule" is renamed into "xMule" because they are actually xMules.
@
text
@d2006 16
@


1.162
log
@Completely reworked remote clients version detection; Improved filtering.
@
text
@d1017 1
a1017 1
		strName = _T("LMule");
@


1.161
log
@corrected leechermod "eMule++" to "Plus Plus"
@
text
@d867 2
a868 1
	EMULE_TRY
d870 4
a873 1
	CString strBuff;
d878 1
a878 13
		case SO_AMULE:
		case SO_SHAREAZA:
		case SO_LMULE:
		case SO_LPHANT:
			strBuff.Format(_T("v0.%02X"), dwVersion);
			break;
		case SO_EDONKEYHYBRID:
		// [Lord KiRon]
		// I am not sure about this but this should take care of some strange
		// v1432 ve getting, so I assume it's 43.2
		// v44.7 for sure reports 10447 so may be here some hex math goes on but
		// until someone finds it - this works
			if (dwVersion > 1)
d880 2
a881 10
				double dVersion;
				uint32 dwDivider = 10;

				while ((dwVersion / dwDivider) != 0)
					dwDivider *= 10;
				dwVersion -= (dwDivider / 10);
				dVersion = static_cast<double>(dwVersion);
				if (dwVersion > 100)
					dVersion /= 10.;
				strBuff.Format(_T("v%.1f") , dVersion);
d883 3
d887 1
a887 1
				dwVersion = 0;
d889 2
a890 15
		case SO_EDONKEY:
		case SO_MLDONKEY:
		case SO_OLDEMULE:
			strBuff.Format(_T("v%u"), dwVersion);
			break;
		default:
			dwVersion = 0;
			break;
	};
	if (dwVersion)
		return strBuff;

	EMULE_CATCH

	return _T("v ?");
d1006 2
a1007 2
	CString nameString = GetResString(IDS_UNKNOWN);
	EMULE_TRY
d1011 1
a1011 1
		nameString	=	_T("eMule");
d1014 1
a1014 1
		nameString	=	_T("aMule");
d1017 1
a1017 1
		nameString	=	_T("LMule");
d1020 1
a1020 1
		nameString	=	_T("Shareaza");
d1023 1
a1023 1
		nameString	=	_T("Hybrid");
d1026 1
a1026 1
		nameString	=	_T("eDonkey");
d1029 1
a1029 1
		nameString	=	_T("MlDonkey");
d1032 1
a1032 4
		nameString	=	_T("lphant");
		break;
	case SO_OLDEMULE:
		nameString	=	GetResString(IDS_OLDEMULE);
d1035 1
a1035 2
	EMULE_CATCH
	return 	nameString;
d1902 2
a1903 1
	         || strUserName.Find("Mison") != -1 ) )
@


1.160
log
@new leechermods: 00de.de, element, Rappi, eMule++
@
text
@d1948 1
a1948 1
		|| strModVersion.Find("eMule++") != -1
@


1.159
log
@lphant client support.
@
text
@d1916 1
a1916 1
	         strUserName == "http://emule-element.tk" // EC 14.08.03 0-Upload Mod default nickname
d1922 1
a1922 1
	         || strUserName.Find( "[RAMMSTEIN" ) != -1
d1946 6
a1951 1
		strModVersion.Find("eVortex") != -1
d1953 1
a1953 2
		|| strModVersion.Find("LH") != -1
		|| strModVersion.Find("LioNetwork") != -1))
@


1.158
log
@GetPercent was splitted to 64 & 32 bit version
@
text
@d877 1
d1057 3
a1967 1
		case 20: // unknown
d1971 4
d1987 1
a1987 1
		case 10: // mlDonkey
@


1.157
log
@Faster and easier OS version detection.
@
text
@d1689 1
d1695 11
a1705 1
		dblPercentage = (100.0 * qwValue) / qwTotal;
@


1.156
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d495 1
a495 3
	EMULE_TRY

	OSVERSIONINFOEX osvi;
d497 2
a498 13
	memzero(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	if (!GetVersionEx((OSVERSIONINFO*)&osvi))
	{
	//	If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO
		osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
		if(!GetVersionEx((OSVERSIONINFO*)&osvi))
			return -1;  //shouldn't ever happen
	}

	if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) // Windows NT product family
		return -1;  //no limits
a519 1

d543 1
a543 2
	EMULE_CATCH
	return -1;  //give the user the benefit of the doubt, most use NT+ anyway
a548 3
	EMULE_TRY
	OSVERSIONINFOEX osvi;
	BOOL bOsVersionInfoEx;
d550 1
a550 2
	memzero(&osvi, sizeof(OSVERSIONINFOEX));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
d552 2
a553 6
	if(!(bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi)))
	{
		osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		if(!GetVersionEx((OSVERSIONINFO*)&osvi))
		return FALSE;
	}
a583 1
	EMULE_CATCH
@


1.155
log
@Preparations for new client version report code.
@
text
@a1666 192
struct SED2KFileType
{
	LPCTSTR pszExt;
	EED2KFileType iFileType;
} _aED2KFileTypes[] =
{
	{ _T(".669"),   ED2KFT_AUDIO },
	{ _T(".aac"),	ED2KFT_AUDIO },
	{ _T(".aif"),	ED2KFT_AUDIO },
	{ _T(".aiff"),	ED2KFT_AUDIO },
	{ _T(".amf"),   ED2KFT_AUDIO },
	{ _T(".ams"),   ED2KFT_AUDIO },
	{ _T(".ape"),	ED2KFT_AUDIO },
	{ _T(".au"),	ED2KFT_AUDIO },
	{ _T(".dbm"),   ED2KFT_AUDIO },
	{ _T(".dmf"),   ED2KFT_AUDIO },
	{ _T(".dsm"),   ED2KFT_AUDIO },
	{ _T(".far"),   ED2KFT_AUDIO },
	{ _T(".flac"),	ED2KFT_AUDIO },
	{ _T(".it"),    ED2KFT_AUDIO },
	{ _T(".mdl"),   ED2KFT_AUDIO },
	{ _T(".med"),   ED2KFT_AUDIO },
	{ _T(".mid"),	ED2KFT_AUDIO },
	{ _T(".midi"),	ED2KFT_AUDIO },
	{ _T(".mod"),   ED2KFT_AUDIO },
	{ _T(".mol"),   ED2KFT_AUDIO },
	{ _T(".mp1"),	ED2KFT_AUDIO },
	{ _T(".mp2"),	ED2KFT_AUDIO },
	{ _T(".mp3"),	ED2KFT_AUDIO },
	{ _T(".mp4"),	ED2KFT_AUDIO },
	{ _T(".mpa"),	ED2KFT_AUDIO },
	{ _T(".mpc"),	ED2KFT_AUDIO },
	{ _T(".mpp"),	ED2KFT_AUDIO },
	{ _T(".mtm"),   ED2KFT_AUDIO },
	{ _T(".nst"),   ED2KFT_AUDIO },
	{ _T(".ogg"),	ED2KFT_AUDIO },
	{ _T(".okt"),   ED2KFT_AUDIO },
	{ _T(".psm"),   ED2KFT_AUDIO },
	{ _T(".ptm"),   ED2KFT_AUDIO },
	{ _T(".ra"),	ED2KFT_AUDIO },
	{ _T(".rmi"),	ED2KFT_AUDIO },
	{ _T(".s3m"),   ED2KFT_AUDIO },
	{ _T(".stm"),   ED2KFT_AUDIO },
	{ _T(".ult"),   ED2KFT_AUDIO },
	{ _T(".umx"),   ED2KFT_AUDIO },
	{ _T(".wav"),	ED2KFT_AUDIO },
	{ _T(".wma"),	ED2KFT_AUDIO },
	{ _T(".wow"),   ED2KFT_AUDIO },
	{ _T(".xm"),    ED2KFT_AUDIO },

	{ _T(".asf"),	ED2KFT_VIDEO },
	{ _T(".avi"),	ED2KFT_VIDEO },
	{ _T(".divx"),	ED2KFT_VIDEO },
	{ _T(".m1v"),	ED2KFT_VIDEO },
	{ _T(".m2v"),	ED2KFT_VIDEO },
	{ _T(".mkv"),	ED2KFT_VIDEO },
	{ _T(".mov"),	ED2KFT_VIDEO },
	{ _T(".mp1v"),	ED2KFT_VIDEO },
	{ _T(".mp2v"),	ED2KFT_VIDEO },
	{ _T(".mpe"),	ED2KFT_VIDEO },
	{ _T(".mpeg"),	ED2KFT_VIDEO },
	{ _T(".mpg"),	ED2KFT_VIDEO },
	{ _T(".mps"),	ED2KFT_VIDEO },
	{ _T(".mpv"),	ED2KFT_VIDEO },
	{ _T(".mpv1"),	ED2KFT_VIDEO },
	{ _T(".mpv2"),	ED2KFT_VIDEO },
	{ _T(".ogm"),	ED2KFT_VIDEO },
	{ _T(".qt"),	ED2KFT_VIDEO },
	{ _T(".ram"),	ED2KFT_VIDEO },
	{ _T(".rm"),	ED2KFT_VIDEO },
	{ _T(".rv"),	ED2KFT_VIDEO },
	{ _T(".rv9"),	ED2KFT_VIDEO },
	{ _T(".ts"),	ED2KFT_VIDEO },
	{ _T(".vivo"),	ED2KFT_VIDEO },
	{ _T(".vob"),	ED2KFT_VIDEO },
	{ _T(".wmv"),	ED2KFT_VIDEO },
	{ _T(".xvid"),	ED2KFT_VIDEO },

	{ _T(".bmp"),	ED2KFT_IMAGE },
	{ _T(".dcx"),	ED2KFT_IMAGE },
	{ _T(".emf"),	ED2KFT_IMAGE },
	{ _T(".gif"),	ED2KFT_IMAGE },
	{ _T(".ico"),	ED2KFT_IMAGE },
	{ _T(".jpeg"),	ED2KFT_IMAGE },
	{ _T(".jpg"),	ED2KFT_IMAGE },
	{ _T(".pct"),	ED2KFT_IMAGE },
	{ _T(".pcx"),	ED2KFT_IMAGE },
	{ _T(".pic"),	ED2KFT_IMAGE },
	{ _T(".pict"),	ED2KFT_IMAGE },
	{ _T(".png"),	ED2KFT_IMAGE },
	{ _T(".psd"),	ED2KFT_IMAGE },
	{ _T(".psp"),	ED2KFT_IMAGE },
	{ _T(".tga"),	ED2KFT_IMAGE },
	{ _T(".tif"),	ED2KFT_IMAGE },
	{ _T(".tiff"),	ED2KFT_IMAGE },
	{ _T(".wmf"),	ED2KFT_IMAGE },
	{ _T(".xif"),	ED2KFT_IMAGE },

	{ _T(".ace"),	ED2KFT_ARCHIVE },
	{ _T(".arj"),	ED2KFT_ARCHIVE },
	{ _T(".gz"),	ED2KFT_ARCHIVE },
	{ _T(".hqx"),	ED2KFT_ARCHIVE },
	{ _T(".lha"),	ED2KFT_ARCHIVE },
	{ _T(".rar"),	ED2KFT_ARCHIVE },
	{ _T(".sea"),	ED2KFT_ARCHIVE },
	{ _T(".sit"),	ED2KFT_ARCHIVE },
	{ _T(".tar"),	ED2KFT_ARCHIVE },
	{ _T(".tgz"),	ED2KFT_ARCHIVE },
	{ _T(".uc2"),	ED2KFT_ARCHIVE },
	{ _T(".zip"),	ED2KFT_ARCHIVE },

	{ _T(".bat"),	ED2KFT_PROGRAM },
	{ _T(".cmd"),	ED2KFT_PROGRAM },
	{ _T(".com"),	ED2KFT_PROGRAM },
	{ _T(".exe"),	ED2KFT_PROGRAM },

	{ _T(".bin"),	ED2KFT_CDIMAGE },
	{ _T(".bwa"),	ED2KFT_CDIMAGE },
	{ _T(".bwi"),	ED2KFT_CDIMAGE },
	{ _T(".bws"),	ED2KFT_CDIMAGE },
	{ _T(".bwt"),	ED2KFT_CDIMAGE },
	{ _T(".ccd"),	ED2KFT_CDIMAGE },
	{ _T(".cue"),	ED2KFT_CDIMAGE },
	{ _T(".dmg"),	ED2KFT_CDIMAGE },
	{ _T(".dmz"),	ED2KFT_CDIMAGE },
	{ _T(".img"),	ED2KFT_CDIMAGE },
	{ _T(".iso"),	ED2KFT_CDIMAGE },
	{ _T(".mdf"),	ED2KFT_CDIMAGE },
	{ _T(".mds"),	ED2KFT_CDIMAGE },
	{ _T(".nrg"),	ED2KFT_CDIMAGE },
	{ _T(".sub"),	ED2KFT_CDIMAGE },
	{ _T(".toast"), ED2KFT_CDIMAGE },

	// To be uncommented after we use the 'Doc' ed2k filetype for search expressions
	{ _T(".txt"),   ED2KFT_DOCUMENT },
	{ _T(".nfo"),   ED2KFT_DOCUMENT },
	{ _T(".diz"),   ED2KFT_DOCUMENT },
	{ _T(".doc"),   ED2KFT_DOCUMENT },
	{ _T(".rtf"),   ED2KFT_DOCUMENT },
	{ _T(".pdf"),   ED2KFT_DOCUMENT },	// double check this!
	{ _T(".xls"),   ED2KFT_DOCUMENT },	// double check this!
	{ _T(".html"),  ED2KFT_DOCUMENT },
	{ _T(".htm"),   ED2KFT_DOCUMENT }
};

int __cdecl CompareE2DKFileType(const void* p1, const void* p2)
{
	return _tcscmp( ((const SED2KFileType*)p1)->pszExt, ((const SED2KFileType*)p2)->pszExt );
}

EED2KFileType GetED2KFileTypeID(LPCTSTR pszFileName)
{
	LPCTSTR pszExt = _tcsrchr(pszFileName, _T('.'));

	if (pszExt == NULL)
		return ED2KFT_ANY;

	CString strExt(pszExt);

	strExt.MakeLower();

	SED2KFileType ft;

	ft.pszExt = strExt;
	ft.iFileType = ED2KFT_ANY;
	const SED2KFileType		*pFound = (SED2KFileType*)bsearch(&ft, _aED2KFileTypes, ARRSIZE(_aED2KFileTypes), sizeof _aED2KFileTypes[0], CompareE2DKFileType);
	if (pFound != NULL)
		return pFound->iFileType;

	return ED2KFT_ANY;
}

class CED2KFileTypes
{
public:
	CED2KFileTypes()
	{
		qsort(_aED2KFileTypes, ELEMENT_COUNT(_aED2KFileTypes), sizeof _aED2KFileTypes[0], CompareE2DKFileType);
#ifdef _DEBUG
		// check for duplicate entries
		LPCTSTR pszLast = _aED2KFileTypes[0].pszExt;
		for (int i = 1; i < ELEMENT_COUNT(_aED2KFileTypes); i++)
		{
			ASSERT( _tcscmp(pszLast, _aED2KFileTypes[i].pszExt) != 0 );
			pszLast = _aED2KFileTypes[i].pszExt;
		}
#endif
	}
};
CED2KFileTypes theED2KFileTypes; // get the list sorted *before* any code is accessing it


d1713 1
a1713 1
double GetPercent(uint32 dwValue, uint32 dwTotal)
d1717 2
a1718 2
	if (dwTotal > 0)
		dblPercentage = (100.0 * dwValue) / dwTotal;
@


1.154
log
@Faster icon loading.
@
text
@a1087 44
CString GetClientNameAndVersionString(CUpDownClient *client)
{
	CString buffer(_T("?"));
	EMULE_TRY
	bool isPlus=(client->GetPlusVersion() && client->GetPlusVersion()<0x2600);
	switch(client->GetClientSoft())
	{
	case SO_EMULE:
		if(isPlus)	//Cax2 - second check - don't display the 38e (pre v1?) mods
		{	//Cax2 - assuming v1 v1a v1b - v1.1 v1.1a etc...
			int num=(client->GetPlusVersion() & 0xF0)>>4;
			int letter=(client->GetPlusVersion() & 0x0F);
			letter=(letter==0)?(int)' ':letter+(int)'a'-1;
			if (num>0)
				buffer.Format(_T("Plus v%u.%u%c"), client->GetPlusVersion()>>8,num, (char)letter);
			else
				buffer.Format(_T("Plus v%u%c"), client->GetPlusVersion()>>8,(char)letter);
			break;
		}
	case SO_LMULE:  // Other Mules fall under one catagory
	case SO_SHAREAZA:
	case SO_OLDEMULE:
	case SO_AMULE:
		{
			if (!client->GetModVersion().IsEmpty() && !isPlus)
				buffer.Format( _T("%s %s [%s]"), GetClientNameString(client->GetClientSoft()),
					GetClientVersionString(client->GetClientSoft(), client->GetMuleVersion()), client->GetModVersion() );
			else
				buffer.Format( _T("%s %s"), GetClientNameString(client->GetClientSoft()),
					GetClientVersionString(client->GetClientSoft(), client->GetMuleVersion()) );
		}
		break;
	case SO_UNKNOWN:
		buffer = _T("???");
		break;
	default:
		buffer.Format( _T("%s %s"), GetClientNameString(client->GetClientSoft()),
			GetClientVersionString(client->GetClientSoft(), client->GetVersion()) );
		break;
	}
	EMULE_CATCH
	return buffer;
}

@


1.153
log
@some code from official
@
text
@d654 2
d658 1
a658 1
		HICON	hIcon = reinterpret_cast<HICON>(::LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(uResIDs[ui]), IMAGE_ICON, 16, 16, 0));
@


1.152
log
@some more fixes & changes
@
text
@d1487 89
@


1.151
log
@Changed to system default decimal point & thousand seperator (instead of current locale) + Some formatting
@
text
@d70 1
a70 1
	CString		strBuffer;
d98 1
a98 1
		int		iPos1 = strBuffer.Find(GetLocalDecimalPoint());
d102 1
a102 1
			int		iPos2 = strBuffer.Find(_T(" "), iPos1 + 1);
d112 1
a112 1
					strBuffer.Delete(iPos1, 1);
d128 1
a128 1
	CString		strBuffer;
d156 1
a156 1
		int		iPos1 = strBuffer.Find(GetLocalDecimalPoint());
d160 1
a160 1
			int		iPos2 = strBuffer.Find(_T(" "), iPos1 + 1);
d170 1
a170 1
					strBuffer.Delete(iPos1, 1);
d256 1
a256 1
	int			iIndex = 0, iDecimalPos = 0;
d260 1
a260 1
		strBuffer = _T('-');
a261 1
		iIndex++;
d265 1
d1951 1
a1951 1
CString GetLocalDecimalPoint()
a1953 1
	int			iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, NULL, 0);
d1955 1
a1955 1
	if (iSize > 0)
d1957 5
a1961 1
		TCHAR	*szBuffer = new TCHAR[iSize];
d1963 4
a1966 3
		if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SDECIMAL, szBuffer, iSize) != NULL)
			strResult = szBuffer;
		delete[] szBuffer;
d1979 1
a1979 1
CString GetLocalThousandsSep()
d1982 2
a1983 3
	int			iSize = GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, NULL, 0);
	
	if (iSize > 0)
d1985 1
a1985 1
		TCHAR	*szBuffer = new TCHAR[iSize];
d1987 8
a1994 3
		if (GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_STHOUSAND, szBuffer, iSize) != NULL)
			strResult = szBuffer;
		delete[] szBuffer;
d2007 28
@


1.150
log
@Not allow GetResString to be inline (inline for GetResString doesn't
increase performance, but significantly increase size).
@
text
@d70 1
a70 1
	CString		buffer;
d74 1
a74 1
		buffer.Format(_T("%.f %s"),static_cast<double>(count),GetResString(IDS_BYTES).GetBuffer(0));
d79 1
a79 1
			buffer.Format(_T("%.f %s"),static_cast<double>(count)/1024.0,GetResString(IDS_KBYTES).GetBuffer(0));
d81 1
a81 1
			buffer.Format(_T("%.2f %s"),static_cast<double>(count)/1024.0,GetResString(IDS_KBYTES).GetBuffer(0));
d85 1
a85 1
		buffer.Format(_T("%.2f %s"),static_cast<double>(count)/1048576.0,GetResString(IDS_MBYTES).GetBuffer(0));
d89 1
a89 1
		buffer.Format(_T("%.2f %s"),static_cast<double>(count)/1073741824.0,GetResString(IDS_GBYTES).GetBuffer(0));
d93 1
a93 1
		buffer.Format(_T("%.3f %s"),static_cast<double>(count)/1099511627776.0,GetResString(IDS_TBYTES).GetBuffer(0));
d96 1
a96 3
	int pos1 = buffer.Find(_T(GetLocalDecimalPoint()));

	if (pos1 != -1 && g_eMuleApp.m_pGlobPrefs->ShowRoundSizes())
d98 1
a98 1
		int pos2 = buffer.Find(_T(" "), pos1);
d100 1
a100 1
		if (pos2 != -1)
d102 3
a104 1
			while (buffer.GetAt(pos2 - 1) == _T('0'))
d106 7
a112 2
				pos2--;
				buffer.Delete(pos2, 1);
a113 2
			if (pos2 - 1 == pos1)
				buffer.Delete(pos1, 1);
d117 1
a117 1
	return buffer;
d128 1
a128 1
	CString		buffer;
d132 1
a132 1
		buffer.Format(_T("%i"),count);
d137 1
a137 1
			buffer.Format(_T("%.f%s"),static_cast<double>(count)/1000.0, GetResString(IDS_KILO).GetBuffer(0));
d139 1
a139 1
			buffer.Format(_T("%.2f%s"),static_cast<double>(count)/1000.0, GetResString(IDS_KILO).GetBuffer(0));
d143 1
a143 1
		buffer.Format(_T("%.2f%s"),static_cast<double>(count)/1000000.0, GetResString(IDS_MEGA).GetBuffer(0));
d147 1
a147 1
		buffer.Format(_T("%.2f%s"),static_cast<double>(count)/1000000000.0, GetResString(IDS_GIGA).GetBuffer(0));
d151 1
a151 1
		buffer.Format(_T("%.2f%s"),static_cast<double>(count)/1000000000000.0, GetResString(IDS_TERRA).GetBuffer(0));
d154 1
a154 3
	int pos1 = buffer.Find(_T(GetLocalDecimalPoint()));

	if (pos1 != -1 && g_eMuleApp.m_pGlobPrefs->ShowRoundSizes())
d156 1
a156 1
		int pos2 = buffer.Find(_T(" "), pos1);
d158 1
a158 1
		if (pos2 != -1)
d160 3
a162 1
			while (buffer.GetAt(pos2 - 1) == _T('0'))
d164 7
a170 2
				pos2--;
				buffer.Delete(pos2, 1);
a171 2
			if (pos2 - 1 == pos1)
				buffer.Delete(pos1, 1);
d175 1
a175 1
	return buffer;
d252 11
a262 10
	CString buffer;
	_int64 val;
	unsigned digval;

	char sThousandSeparator = _T(GetLocalThousandsSep());

  	if (count < 0 )
	{
		buffer = _T('-');
		val = (_int64)(-(_int64)count);
d265 1
a265 6
	{
		buffer = _T(" ");
		val = count;
	}

	int iDecimalPos = 0;
d269 1
a269 1
		iDecimalPos ++;
d272 3
a274 3
			digval = (unsigned) (val % 10);
			val /= 10;
			buffer.Insert(1,(char)(digval + '0'));
d278 1
a278 1
			buffer.Insert(1,sThousandSeparator);
d281 1
a281 1
	} while (val > 0);
d283 1
a283 1
	return buffer.TrimLeft(_T(" "));
d1951 1
a1951 1
char GetLocalDecimalPoint()
d1953 20
a1972 2
	struct lconv *lconv_struct = localeconv();
	return *lconv_struct->decimal_point;
d1974 2
a1975 1
char GetLocalThousandsSep()
d1977 20
a1996 2
	struct lconv *lconv_struct = localeconv();
	return *lconv_struct->thousands_sep;
@


1.149
log
@Fix for Web Services
@
text
@d372 1
a372 1
void __stdcall GetResString(CString *pstrOutput, UINT dwStringID)
@


1.148
log
@Added client version info to debug log messages.
@
text
@d860 1
a860 1
void RunURL(CAbstractFile* file, CString urlpattern)
d863 1
a863 1
	if (file!=NULL)
d865 2
a866 2
		// Convert hash to hexadecimal text and add it to the URL
		urlpattern.Replace(_T("#hashid"), HashToString(file->GetFileHash()));
d868 4
a871 4
		// Add file size to the URL
		CString temp;
		temp.Format(_T("%u"),file->GetFileSize());
		urlpattern.Replace(_T("#filesize"), temp);
d873 2
a874 2
		// add filename to the url
		urlpattern.Replace(_T("#filename"),URLEncode(file->GetFileName()));
d876 6
a881 2
	// Open URL
	ShellExecute(NULL, NULL, urlpattern, NULL, g_eMuleApp.m_pGlobPrefs->GetAppDir(), SW_SHOWDEFAULT);
@


1.147
log
@'Old MlDonkey' --> 'MlDonkey'.
@
text
@a1096 1
				//buffer.Format("plus v1 %c",(char) letter);
@


1.146
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d1070 1
a1070 1
		nameString	=	GetResString(IDS_OLDMLDONKEY);
@


1.145
log
@Unified definitions for client name.
@
text
@d890 1
a890 1
		case SO_CDONKEY:
d1054 2
a1055 2
	case SO_CDONKEY:
		nameString	=	_T("CDonkey");
d1103 1
a1103 1
	case SO_CDONKEY:
a2047 4
		case 1:
		{
			return SO_CDONKEY;
		}
d2052 1
a2052 1
		case 3: // aMule
d2054 1
a2054 1
			return SO_LMULE;
@


1.144
log
@Optimized resource string loading.
@
text
@d1438 1
a1438 1
	filename.Replace(_T("Emuleplus"),_T("eMule Plus"));
@


1.143
log
@One more new GetResString service which is more effective in some cases.
@
text
@d349 1
a349 1
CString GetResString(UINT dwStringID)
d351 7
a357 1
	return GetResString(dwStringID, g_eMuleApp.m_pGlobPrefs->GetLanguageID());
d360 1
a360 1
CString GetResString(UINT dwStringID, WORD uLanguageID)
d362 2
a363 1
	CString	strResString;
d365 1
a365 1
	strResString.LoadString(::GetModuleHandle(NULL), dwStringID, uLanguageID);
d367 1
a367 1
		strResString.LoadString(::GetModuleHandle(NULL), dwStringID, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT));
d374 3
a376 1
	pstrOutput->LoadString(::GetModuleHandle(NULL), dwStringID, g_eMuleApp.m_pGlobPrefs->GetLanguageID());
d378 1
a378 1
		pstrOutput->LoadString(::GetModuleHandle(NULL), dwStringID, MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT));
@


1.142
log
@added tooltips to the Server list
@
text
@d349 1
a349 1
CString GetResString(UINT uStringID)
d351 1
a351 1
	return GetResString(uStringID,g_eMuleApp.m_pGlobPrefs->GetLanguageID());
d354 1
a354 1
CString GetResString(UINT uStringID,WORD languageID)
d356 14
a369 5
	CString resString;
	resString.LoadString(::GetModuleHandle(NULL),uStringID, languageID );
	if (!resString.GetLength())
		resString.LoadString(::GetModuleHandle(NULL),uStringID, MAKELANGID(LANG_ENGLISH,SUBLANG_DEFAULT) );
	return resString;
@


1.141
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d2016 5
@


1.140
log
@Removed old icon loading service.
@
text
@d479 1
a479 1
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
d548 1
a548 1
	ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
@


1.139
log
@New option to disable round of sizes for files and transfers
@
text
@a625 9
HICON LoadImgLstIcon(LPCTSTR lpszName, int cx, int cy)
{
	static HICON s_hLastIcon = NULL;

	if (s_hLastIcon != NULL)
		::DestroyIcon(s_hLastIcon);
	s_hLastIcon = reinterpret_cast<HICON>(::LoadImage(AfxGetInstanceHandle(), lpszName, IMAGE_ICON, cx, cy, 0));
	return s_hLastIcon;
}
@


1.138
log
@Added a new service to fill image lists.
@
text
@d78 4
a81 1
		buffer.Format(_T("%.f %s"),static_cast<double>(count)/1024.0,GetResString(IDS_KBYTES).GetBuffer(0));
d97 2
a98 1
	if (pos1 != -1)
d101 1
d125 2
a126 1
	CString buffer;
d128 1
d130 1
d132 6
a137 1
		buffer.Format(_T("%.f%s"),static_cast<double>(count)/1000.0, GetResString(IDS_KILO).GetBuffer(0));
d139 1
d141 1
d143 1
d145 1
d147 1
d149 1
d152 2
a153 1
	if (pos1 != -1)
d156 1
@


1.137
log
@Fixed loss of client uploading turn during part file flushing and single part hashing;
Reworked file completion algorithm to eliminate file locking in completing state.
@
text
@d614 17
@


1.136
log
@added ban for LH & LioNetwork clients
@
text
@d2021 35
@


1.135
log
@minor changes
@
text
@d1975 4
a1978 2
	         strModVersion.Find("eVortex") != -1
	         || strModVersion.Find("Mison") != -1 ) )
@


1.134
log
@fixed security exploit in IRC module and Web server (from official) [katsyonak]
@
text
@d1640 1
@


1.133
log
@minor correction of filenamecleanup
@
text
@d716 1
a716 1
void DecodeBase16(LPCTSTR base16Buffer, unsigned int base16BufLen, byte *buffer)
a718 1
    memzero(buffer, DecodeLengthBase16(base16BufLen));
d720 7
a726 1
    for(unsigned int i = 0; i < base16BufLen; i++)
d730 1
a730 1
        // Check to make sure that the given word falls inside a valid range
d734 3
a736 3
           word = 0xFF;
        else
           word = base16Lookup[lookup][1];
d747 2
d750 1
d760 1
a760 1
int	DecodeLengthBase16(int base16Length)
d762 1
a762 1
	return base16Length / 2;
@


1.132
log
@corrected client software detection
@
text
@d1328 1
a1328 1
	filename.SetString(ReplaceDotsWithSpaces(filename, _T("01234567689"), _T("_+^!$%=~@@;\\\"/:*?<>|"), false)); //spaceholders
@


1.131
log
@some refactoring : IsStolenName & IsLeecherType were moved into otherfunctions.cpp
@
text
@d1976 34
@


1.130
log
@Remake for display '&' on info pane; now also all fields can show '&' correctly.
@
text
@d1927 4
d1932 44
@


1.129
log
@display fix for & chars in filename for infolist pane
@
text
@a367 6
CString MakeStringEscaped(CString in) {
	in.Replace("&","&&");
	
	return in;
}

@


1.128
log
@minor optimization
@
text
@d368 6
@


1.127
log
@changed concatenation of .met path and fname in tooltips to avoid missing or doubled backslashes when using multiple temp folders.
@
text
@d885 1
a885 1
CString ConcatFullPath(CString& strPath, CString& strFname)
d887 1
a887 1
	if (strPath.Right(1) == "\\")
d893 1
a893 1
		return (strPath + _T("\\") + strFname);
a896 13
byte GetRealPrio(byte in)
{
	switch(in)
	{
		case 4 : return 0;
		case 0 : return 1;
		case 1 : return 2;
		case 2 : return 3;
		case 3 : return 4;
	}
	return 0;
}

@


1.126
log
@Improved client version to string conversion
@
text
@d885 12
@


1.125
log
@Solved all problems with display of '&' in File and Client Details dialogs (unrequired service is removed)
@
text
@d607 6
a612 5
	static HICON lasticon = NULL;
	if(lasticon)
		DestroyIcon(lasticon);
	lasticon = (HICON)::LoadImage(AfxGetInstanceHandle(), lpszName, IMAGE_ICON, cx, cy, 0);
	return lasticon;
d826 1
a826 1
CString GetClientVersionString(EnumClientTypes clientype,uint32 uVersion)
a827 1
	CString cbuffer	=	_T("0");
d829 4
a832 5
	double dVersion	=	0.;
	double dVersion1	=	0.;
	double dVersion2	=	0.;
	uint32 uDivider		=	10;
	switch(clientype)
d834 7
a840 8
	case SO_EMULE:
	case SO_CDONKEY:
	case SO_SHAREAZA:
	case SO_LMULE:
		cbuffer.Format(_T("0.%02X"),uVersion);
		break;
	case SO_EDONKEYHYBRID:
		//cbuffer.Format(_T("%i"),uVersion - 1000);
d842 28
a869 29
		// I am not sure about this but this should take care of some stange
		// v1432 ve getting , so I assume it's 43.2
		// v44.7 for sure  reports 10447 so may be here some hex math goes on but
		// until some1 finds it - this works
		while(uVersion/uDivider !=0 )uDivider*=10;
		uVersion	=	uVersion - (uDivider/10);
		dVersion	=	(double)(uVersion);
		if (dVersion > 100. )
		{
			dVersion /= 10.;
		}
		cbuffer.Format(_T("%.1f") , dVersion);
		break;
	case SO_EDONKEY:
		cbuffer.Format(_T("%i"),uVersion);
		break;
	case SO_MLDONKEY:
		cbuffer.Format(_T("%i"),uVersion);
		break;
	case SO_OLDEMULE:
		// Lord KiRon - not needed any more because version corrected at read packet time
		/*if(uVersion == 0x2B)
		{
			uVersion = 0x22;
		}*/
		cbuffer.Format(_T("%i"),uVersion);
		break;
	default:
		break;
d871 3
d875 2
a876 1
	return (cbuffer==_T("0.00")||cbuffer==_T("0.0")||cbuffer==_T("0"))?_T(" ?"):cbuffer ;
d1034 1
a1034 1
        if(isPlus)	//Cax2 - second check - don't display the 38e (pre v1?) mods
d1045 1
a1045 1
        }
d1050 1
a1050 1
        {
d1052 2
a1053 2
				buffer.Format(_T("%s v%s [%s]"),GetClientNameString(client->GetClientSoft()),
					GetClientVersionString(client->GetClientSoft(), client->GetMuleVersion()), client->GetModVersion());
d1055 3
a1057 3
				buffer.Format(_T("%s v%s"),GetClientNameString(client->GetClientSoft()),
					GetClientVersionString(client->GetClientSoft(), client->GetMuleVersion()));
        }
d1060 1
a1060 1
		buffer.Format(_T("???"));
d1063 2
a1064 2
		buffer.Format(_T("%s v%s"),GetClientNameString(client->GetClientSoft()),
            GetClientVersionString(client->GetClientSoft(),client->GetVersion()));
d1068 1
a1068 1
    return buffer;
d1929 1
a1929 1
#endif //NEW_SOCKETS_ENGINE@


1.124
log
@formatting, removed some ending space and minor changes
removed some menus memleak in sharedctrl
fixed new 'LATER' code
changed new paused/stopped file sorting
removed a space not meant to be there in french.rcu
update changelog
@
text
@a341 8
CString MakeStringEscaped(CString in)
{
	EMULE_TRY
	in.Replace(_T("&"),_T("&&"));
	EMULE_CATCH
	return in;
}

@


1.123
log
@Improved hash to string conversion; improved DL/UP queue state display; minor optimization
@
text
@d299 1
d301 1
d303 1
d305 1
d307 1
d314 1
@


1.122
log
@Improved hash to string conversion
@
text
@d34 2
d298 1
a298 1
			if(isalnum(*pInTmp))
d301 1
a301 1
				if(isspace(*pInTmp))
d306 2
a307 2
					*pOutTmp++ = toHex(*pInTmp>>4);
					*pOutTmp++ = toHex(*pInTmp%16);
d309 1
a309 1
				pInTmp++;
a321 5
inline BYTE toHex(const BYTE &x)
{
	return x > 9 ? x + 55: x + 48;
}

d812 1
a812 1
		urlpattern.Replace(_T("#hashid"), EncodeBase16(file->GetFileHash(), 16));
d901 2
a902 1
	CString stateString = GetResString(IDS_UNKNOWN);
d904 1
d908 1
a908 1
		stateString	=	GetResString(IDS_TRANSFERRING);
d911 1
a911 1
		stateString	=	GetResString(IDS_ONQUEUE);
d914 1
a914 1
		stateString	=	GetResString(IDS_ASKING);
d917 1
a917 1
		stateString	=	GetResString(IDS_CONNECTING);
d920 1
a920 1
		stateString	=	GetResString(IDS_CONNVIASERVER);
d923 1
a923 1
		stateString	=	GetResString(IDS_RECHASHSET);
d926 1
a926 1
		stateString	=	GetResString(IDS_NONEEDEDPARTS);
d929 1
a929 1
		stateString	=	GetResString(IDS_TOOMANYCONNS);
d932 1
a932 1
		stateString	=	GetResString(IDS_NOCONNECTLOW2LOW);
d935 1
a935 1
		stateString	=	GetResString(IDS_BANNED);
d938 1
a938 1
		stateString	=	GetResString(IDS_ERROR_STATE);
d941 2
a942 1
		stateString	=	GetResString(IDS_UNKNOWN);
d945 1
d947 1
a947 1
	return stateString;
d952 2
a953 1
	CString stateString = GetResString(IDS_UNKNOWN);
d955 1
d959 1
a959 1
		stateString	=	GetResString(IDS_TRANSFERRING);
d962 1
a962 1
		stateString	=	GetResString(IDS_ONQUEUE);
d965 1
a965 1
		stateString	=	GetResString(IDS_CONNVIASERVER);
d968 1
a968 1
		stateString	=	GetResString(IDS_CONNECTING);
d971 1
a971 1
		stateString	=	GetResString(IDS_PENDING);
d974 1
a974 1
		stateString	=	GetResString(IDS_NOCONNECTLOW2LOW);
d977 1
a977 1
		stateString	=	GetResString(IDS_BANNED);
d980 1
a980 1
		stateString	=	GetResString(IDS_ERROR_STATE);
d983 2
a984 1
		stateString	=	GetResString(IDS_UNKNOWN);
d987 1
d989 1
a989 1
	return stateString;
a1830 1
	static const char acHexDigits[] = { '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F' };
d1836 2
a1837 2
		pszHash[0] = acHexDigits[uiCh >> 4];
		pszHash[1] = acHexDigits[uiCh & 0xf];
@


1.121
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@a264 8
CString FileHashToString(const uchar *hash)
{
	CString ret;
	for (int i = 0; i < 16; i++)
		ret.AppendFormat(_T("%02X"), hash[i]);
	return ret;
}

d1838 1
a1838 1
CString md4str(const uchar* hash)
d1840 4
a1843 3
	char szHash[MAX_HASHSTR_SIZE];
	md4str(hash, szHash);
	return szHash;
@


1.120
log
@fix for changes added in version 1.118
@
text
@d897 1
a897 1
uint8 GetRealPrio(uint8 in)
@


1.119
log
@Optimized hash processings
@
text
@d195 1
a195 1
		buffer.Format("%I64d:%02u %s", count/60, count-(count/60)*60, GetResString(IDS_LONGMINS));
d197 1
a197 1
		buffer.Format("%I64d:%02u %s", count/3600, (count-(count/3600)*3600)/60, GetResString(IDS_LONGHRS));
@


1.118
log
@Improved string processings
@
text
@d35 2
a36 2
static byte base16Chars[17] = "0123456789ABCDEF";
static byte base32Chars[33] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
d1832 1
a1832 1
void md4str(const uchar* hash, char* pszHash)
d1834 8
a1841 5
    static const char _acHexDigits[] = "0123456789ABCDEF";
    for (int i = 0; i < 16; i++)
    {
		*pszHash++ = _acHexDigits[hash[i] >> 4];
		*pszHash++ = _acHexDigits[hash[i] & 0xf];
@


1.117
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d189 1
a189 1
	CString buffer, strDay;
d195 1
a195 1
		buffer.Format("%I64d:%s %s",count/60,LeadingZero(count-(count/60)*60),GetResString(IDS_LONGMINS));
d197 1
a197 1
		buffer.Format("%I64d:%s %s",count/3600,LeadingZero((count-(count/3600)*3600)/60),GetResString(IDS_LONGHRS));
d203 2
a204 8
		if (count < 172800)
		{
			strDay = GetResString(IDS_LONGDAY);
		}
		else
		{
			strDay = GetResString(IDS_LONGDAYS);
		}
d207 1
a207 1
			buffer.Format("%I64d %s %I64d:%s %s",cntDays, strDay ,cntHrs ,LeadingZero((uint32)(count-(cntDays*86400)-(cntHrs*3600))/60),GetResString(IDS_LONGHRS)); 
a272 11
CString LeadingZero(uint32 units)
{
	CString		temp;

	if (units<10)
		temp.Format(_T("0%i"),units);
	else
		temp.Format(_T("%i"),units);
	return temp;
}

@


1.116
log
@minor changes
@
text
@d748 1
a748 1
    memset2(buffer, 0, DecodeLengthBase16(base16BufLen));
@


1.115
log
@get rid of "1 days...." (don't think we need to do it for ds, hrs etc., do 'we ?)
@
text
@d171 1
a171 1
		buffer.Format(_T("%i %s %i %s"),count/86400,GetResString(IDS_DAYS).GetBuffer(0),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS).GetBuffer(0));
d281 6
a286 2
	CString temp;
	if (units<10) temp.Format(_T("0%i"),units); else temp.Format(_T("%i"),units);
@


1.114
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d189 1
a189 1
	CString buffer;
d202 9
d212 3
a214 1
			buffer.Format("%I64d %s %I64d:%s %s",cntDays,GetResString(IDS_DAYS),cntHrs,LeadingZero((uint32)(count-(cntDays*86400)-(cntHrs*3600))/60),GetResString(IDS_LONGHRS));
d216 3
a218 1
			buffer.Format("%I64d %s %u %s",cntDays,GetResString(IDS_DAYS),(uint32)(count-(cntDays*86400)-(cntHrs*3600))/60,GetResString(IDS_LONGMINS));
@


1.113
log
@changed A4AF sources count display as an option + minor cosmetic changes
@
text
@d86 1
a86 1
	else 
d106 1
a106 1
	
d117 1
a117 1
		
d158 5
a162 5
   if (count < 0) 
		buffer = _T("?"); 
   else if (count < 60) 
		buffer.Format(_T("%i %s"),count,GetResString(IDS_SECS).GetBuffer(0)); 
   else if (count < 3600) 
d164 1
a164 1
   else if (count < 86400) 
d166 1
a166 1
   else 
d171 1
a171 1
		buffer.Format(_T("%i %s %i %s"),count/86400,GetResString(IDS_DAYS).GetBuffer(0),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS).GetBuffer(0)); 
d178 1
a178 1
	
d184 1
a184 1
} 
d191 1
a191 1
		buffer = "?"; 
d193 2
a194 2
		buffer.Format("%I64d %s",count,GetResString(IDS_LONGSECS)); 
	else if (count < 3600) 
d196 1
a196 1
	else if (count < 86400) 
d203 1
a203 1
			buffer.Format("%I64d %s %I64d:%s %s",cntDays,GetResString(IDS_DAYS),cntHrs,LeadingZero((uint32)(count-(cntDays*86400)-(cntHrs*3600))/60),GetResString(IDS_LONGHRS)); 
d208 1
a208 1
} 
d215 1
a215 1
		
d219 1
a219 1
	
d258 1
a258 1
CString FileHashToString(const uchar *hash) 
d260 2
a261 2
	CString ret;	
	for (int i = 0; i < 16; i++) 
d263 1
a263 1
	return ret;		
d273 1
a273 1
void ShellOpenFile(const CString& name) 
d278 1
a278 1
} 
d360 1
a360 1
	TCHAR rbuffer[500];	
d368 1
a368 1
	TCHAR mod[MAX_PATH];	
d375 1
a375 1
		
d388 1
a388 1
	{			
d392 2
a393 2
			
			TCHAR mod[MAX_PATH];		
d399 1
a399 1
			
d401 2
a402 2
			regkey.SetStringValue(0,reg);	
			regkey.Create(HKEY_CLASSES_ROOT,_T("ed2k\\DefaultIcon") );// Added Shrink 
d409 1
a409 1
	}	
d420 1
a420 1
	
d428 1
a428 1
		regkey.SetStringValue(_T("OldDefault"), rbuffer);	
d430 1
a430 1
		maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);	
d444 1
a444 1
	regkey.Create(HKEY_CLASSES_ROOT, _T("ed2k\\shell\\open\\command"));	
d450 1
a450 1
		regkey.SetStringValue(0, rbuffer);	
d453 1
a453 1
		maxsize = sizeof(rbuffer) / sizeof(rbuffer[0]);	
d527 1
a527 1
		}         
d546 1
a546 1
		if(!GetVersionEx((OSVERSIONINFO*)&osvi)) 
d553 1
d555 1
d565 1
a565 1
      
d567 1
d569 1
a569 1
				return _WINVER_95_; 
d571 1
a571 1
				return _WINVER_98_; 
d573 1
a573 1
				return _WINVER_ME_; 
d575 1
a575 1
		
d587 1
a587 1
	
d601 1
a601 1
	else 
d606 1
a606 1
		{	
d653 1
a653 1
} 
d732 1
a732 1
  
d739 1
a739 1
        
d822 10
a831 10
	    // Convert hash to hexadecimal text and add it to the URL
	    urlpattern.Replace(_T("#hashid"), EncodeBase16(file->GetFileHash(), 16));
    
	    // Add file size to the URL
	    CString temp;
	    temp.Format(_T("%u"),file->GetFileSize());
	    urlpattern.Replace(_T("#filesize"), temp);
    
	    // add filename to the url
	    urlpattern.Replace(_T("#filename"),URLEncode(file->GetFileName()));
d859 1
a859 1
		// v44.7 for sure  reports 10447 so may be here some hex math goes on but 
d947 1
a947 1
		stateString	=	GetResString(IDS_ERROR_STATE); 
d1045 1
a1045 1
			else 
d1097 1
a1097 1
    TCHAR pszDisplayName[MAX_PATH];
d1100 1
a1100 1
	
d1114 4
a1117 4
		LPMALLOC pMalloc = NULL; 
		HRESULT hResult = SHGetMalloc (&pMalloc); 
		if (hResult == NOERROR && pMalloc) 
			pMalloc->Free (lpID); 
d1143 1
a1143 1
			{			
d1161 1
a1161 1
			else if ((Result & 0xf8) == 0xf0) 
d1166 1
a1166 1
			else if ((Result & 0xfc) == 0xf8) 
d1447 1
a1447 1
							 dwFlags | OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, pszFilters, NULL, 
d1479 1
a1479 1
	
d1496 1
a1496 1
	
d1501 1
a1501 1
	
d1550 4
a1553 4
//	if(string.GetLength() > 0) 
//	{	
//		if(string.Right(1) == '\\') 
//		{	
d1569 1
a1569 1
} _aED2KFileTypes[] = 
d1571 1
a1571 1
    { _T(".669"),   ED2KFT_AUDIO },
d1575 2
a1576 2
    { _T(".amf"),   ED2KFT_AUDIO },
    { _T(".ams"),   ED2KFT_AUDIO },
d1579 4
a1582 4
    { _T(".dbm"),   ED2KFT_AUDIO },
    { _T(".dmf"),   ED2KFT_AUDIO },
    { _T(".dsm"),   ED2KFT_AUDIO },
    { _T(".far"),   ED2KFT_AUDIO },
d1584 3
a1586 3
    { _T(".it"),    ED2KFT_AUDIO },
    { _T(".mdl"),   ED2KFT_AUDIO },
    { _T(".med"),   ED2KFT_AUDIO },
d1589 2
a1590 2
    { _T(".mod"),   ED2KFT_AUDIO },
    { _T(".mol"),   ED2KFT_AUDIO },
d1598 2
a1599 2
    { _T(".mtm"),   ED2KFT_AUDIO },
    { _T(".nst"),   ED2KFT_AUDIO },
d1601 3
a1603 3
    { _T(".okt"),   ED2KFT_AUDIO },
    { _T(".psm"),   ED2KFT_AUDIO },
    { _T(".ptm"),   ED2KFT_AUDIO },
d1606 4
a1609 4
    { _T(".s3m"),   ED2KFT_AUDIO },
    { _T(".stm"),   ED2KFT_AUDIO },
    { _T(".ult"),   ED2KFT_AUDIO },
    { _T(".umx"),   ED2KFT_AUDIO },
d1612 2
a1613 2
    { _T(".wow"),   ED2KFT_AUDIO },
    { _T(".xm"),    ED2KFT_AUDIO },
d1798 1
a1798 1
	
d1805 1
a1805 1
		
d1816 1
a1816 1
	{	
@


1.112
log
@small change
@
text
@d68 2
a69 1
	CString buffer;
d72 1
a72 8
		if ( count > 0 )
		{
			buffer.Format(_T("%.0f %s"),static_cast<double>(count),GetResString(IDS_BYTES).GetBuffer(0));
		}
		else
		{
			buffer.Format(_T("0 %s"),GetResString(IDS_BYTES).GetBuffer(0));
		}
d75 3
a77 1
		buffer.Format(_T("%.0f %s"),static_cast<double>(count)/1024.0,GetResString(IDS_KBYTES).GetBuffer(0));
d79 1
d81 1
d83 1
d85 1
d87 1
d89 1
d122 1
a122 1
		buffer.Format(_T("%.0f%s"),static_cast<double>(count)/1000.0, GetResString(IDS_KILO).GetBuffer(0));
@


1.111
log
@minor changes
@
text
@d89 2
a90 2
	int pos = buffer.Find(_T(GetLocalDecimalPoint()));
	if (pos != -1)
d92 11
a102 2
		if (buffer.Mid(pos + 1, 2) == _T("00"))
			buffer.Delete(pos, 3);
d128 2
a129 2
	int pos = buffer.Find(_T(GetLocalDecimalPoint()));
	if (pos != -1)
d131 11
a141 2
		if (buffer.Mid(pos + 1, 2) == _T("00"))
			buffer.Delete(pos, 3);
@


1.110
log
@Some corrections in shortcut management code to keep new engine hierarchy (thanks to eklmn ;-))
@
text
@d88 7
d118 8
a125 1
	
@


1.109
log
@New engine
@
text
@d1866 27
@


1.108
log
@Formatting + minor changes
@
text
@d20 1
d22 1
d33 1
d1865 2
@


1.107
log
@minor cleanup change
@
text
@a149 1
// -khaos--+++> Prettier.
d161 2
a162 1
	else {
a171 2
// <-----khaos-

a219 1
// -BavarianSnail
d229 2
a230 1
CString LeadingZero(uint32 units) {
a235 1
//<<--9/21/02
d243 2
a244 1
CString URLEncode(CString sIn){
d246 9
a254 3
    CString sOut;
	
    const int nLen = sIn.GetLength() + 1;
d256 2
a257 8
    register LPBYTE pOutTmp = NULL;
    LPBYTE pOutBuf = NULL;
    register LPBYTE pInTmp = NULL;
    LPBYTE pInBuf =(LPBYTE)sIn.GetBuffer(nLen);
//    BYTE b = 0;
	
    //alloc out buffer
    pOutBuf = (LPBYTE)sOut.GetBuffer(nLen  * 3 - 2);//new BYTE [nLen  * 3];
d259 1
a259 7
    if(pOutBuf)
    {
        pInTmp	= pInBuf;
	pOutTmp = pOutBuf;
		
	// do encoding
	while (*pInTmp)
d261 5
a265 6
	    if(isalnum(*pInTmp))
	        *pOutTmp++ = *pInTmp;
	    else
	        if(isspace(*pInTmp))
		    *pOutTmp++ = '+';
		else
d267 20
a286 13
		    *pOutTmp++ = '%';
		    *pOutTmp++ = toHex(*pInTmp>>4);
		    *pOutTmp++ = toHex(*pInTmp%16);
		}
	    pInTmp++;
	}
	*pOutTmp = '\0';
	//sOut=pOutBuf;
	//delete [] pOutBuf;
	sOut.ReleaseBuffer();
    }
    sIn.ReleaseBuffer();
    return sOut;
d291 2
a292 1
inline BYTE toHex(const BYTE &x){
d296 2
a297 1
CString GetResString(UINT uStringID) {
d301 2
a302 1
CString GetResString(UINT uStringID,WORD languageID) {
d310 2
a311 1
CString MakeStringEscaped(CString in) {
d326 2
a327 1
	if ((ret = regkey.QueryStringValue(NULL, rbuffer, &size)) != ERROR_SUCCESS) {
d332 2
a333 1
	if (::GetModuleFileName(NULL, mod, MAX_PATH) == 0) {
d344 2
a345 1
bool Ask4RegFix(bool dontAsk){
a346 1
	// Barry - Make backup first	
d350 4
a353 2
	if (!CheckIsRegistrySet()) {			
		if (dontAsk || (MessageBox(0,GetResString(IDS_ASSIGNED2K),GetResString(IDS_ED2KLINKFIX),MB_ICONQUESTION|MB_YESNO) == IDYES)){
d357 2
a358 1
			if (::GetModuleFileName(NULL, mod, MAX_PATH) == 0) {
d548 2
a549 1
	if (!_bInitialized){
a586 1
//For  Rate File // 
a613 1
//end rate File//
d631 2
a632 1
    for(i = 0, index = 0; i < bufLen;) {
d635 2
a636 1
        if (index > 3) {
d644 3
a646 1
        } else {
d671 2
a672 1
	for(unsigned int i = 0; i < bufLen; i++) {
d693 2
a694 1
    for(unsigned int i = 0; i < base16BufLen; i++) {
d705 2
a706 1
		if(i % 2 == 0) {
d708 3
a710 1
		} else {
d756 1
a756 1
			if (strBuffer == "<separator>\n" || strBuffer == "<separator>") // Sp4rK patch !!
d780 2
a781 1
	if (file!=NULL) {
d851 2
a852 1
CString StringLimit(const CString& in,uint16 length){
d857 4
a860 2
uint8 GetRealPrio(uint8 in) {
	switch(in) {
d990 2
a991 1
CString GetClientNameAndVersionString(CUpDownClient *client) {
d1035 2
a1036 2
// START - enkeyDEV(Ottavio84) -ChangeDir-
int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData) {
d1038 2
a1039 1
	switch(uMsg){
d1041 2
a1042 1
		if (lpData){
d1053 2
a1054 1
CString BrowseFolder(HWND hwndOwner, LPCTSTR pszTitle, LPCTSTR pszStartFolder) {
d1070 2
a1071 1
	if (lpID != NULL){
a1082 1
// END - enkeyDEV(Ottavio84) -ChangeDir-
d1085 2
a1086 1
CString URLDecode(CString inStr) {
d1089 1
a1089 1
	int more = -1; // EC 11.07.03
d1092 2
a1093 1
		if ( inStr.GetAt(x)== '%' && x+2 < inStr.GetLength() && _istxdigit(inStr.GetAt(x+1)) && _istxdigit(inStr.GetAt(x+2)) ) {
d1095 2
a1096 2
			int Result; // EC 11.07.03
			int sumb; // EC 11.07.03
d1106 2
a1107 2
            } else 
			if ((Result & 0x80) == 0x00) 		// 0xxxxxxx (yields 7 bits)
d1110 2
a1111 2
            } else 
			if ((Result & 0xe0) == 0xc0) 		// 110xxxxx (yields 5 bits)
d1115 2
a1116 2
			} else 
			if ((Result & 0xf0) == 0xe0) 		// 1110xxxx (yields 4 bits)
d1120 2
a1121 2
			} else 
			if ((Result & 0xf8) == 0xf0) 
d1125 2
a1126 2
			} else 
			if ((Result & 0xfc) == 0xf8) 
d1130 2
a1131 1
			}	else /*if ((b & 0xfe) == 0xfc)*/ 	// 1111110x (yields 1 bit)
d1137 2
a1138 1
		else {
d1148 2
a1149 1
CString LeadingCaps(CString inStr, CString exceptStr /*=""*/) {
d1173 2
a1174 1
CString DeleteNonAlphaNumeric(CString inStr, CString exceptStr /*=""*/, bool onlyRep /*=true*/) {
d1195 2
a1196 1
CString ReplaceDotsWithSpaces(CString inStr, CString exceptStr /*=""*/, CString addClear /*=""*/, bool keepExt /*=false*/) {
d1225 2
a1226 1
CString CleanupFilename(CString inStr) {
d1392 2
a1393 1
CString GetErrorMessage(CException* e) {
d1404 4
a1407 3
CString DialogBrowseFile(CString Filters, CString DefaultFileName) {
        CFileDialog myFileDialog(true,NULL,LPCTSTR(DefaultFileName),
							 OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, LPCTSTR(Filters), NULL, 
d1409 5
a1413 3
        myFileDialog.DoModal();
        return myFileDialog.GetPathName();
	}
d1416 2
a1417 1
unsigned long inet_addr(LPCTSTR cp) {
d1485 2
a1486 1
		if (pszPath != NULL || pszTitle != NULL || pszDlgTitle != NULL){
d1495 2
a1496 1
		if ((pidlBrowse = SHBrowseForFolder(&BrsInfo)) != NULL){
d1815 2
a1816 1
	if (!_bInitialized){
@


1.106
log
@perform CastItoXBytes on free disk space output
@
text
@d1305 1
@


1.105
log
@Correct localization of decimal point & thousands seperator + Correct encoding for Hebrew language in WebServer
@
text
@d185 1
a185 1
	char sThousantSeparator = _T(GetLocalThousandsSep());
d211 1
a211 1
			buffer.Insert(1,sThousantSeparator);
@


1.104
log
@File Type correction & related name changes
@
text
@d177 1
a177 1
CString CastItoIdots(_int64 count)
d185 1
a185 1
	char sThousantSeparator = '.';
d187 2
a188 2

  	if (count < 0 ) {
d200 2
a201 1
	do {
d1810 12
a1821 1
}@


1.103
log
@Added a function: bool IsRightToLeftLanguage(); + Fixed Hebrew text alignment in Shared Files list + Hebrew translation update
@
text
@a295 43
// Returns the Typename, examining the extention of the given filename
CString GetFiletypeByName(const CString& infile) {
	EMULE_TRY
	TCHAR e[_MAX_EXT];
	_tsplitpath(infile, NULL, NULL, NULL, e);
	CString ext(_tcslwr(e));

	if (ext==".mp1" || ext==".mp2" || ext==".mp3" || ext==".mp4"|| ext==".mpc" || ext==".mp+" || ext==".mpp" ||
		ext==".mpga" || ext==".au" || ext==".aac" || ext==".ape" || ext==".ogg" || ext==".flac" ||
		ext==".midi" || ext==".mid" || ext==".ra" || ext==".rmi" || ext==".aif" || ext==".aiff" ||
		ext==".wav" || ext==".wma" || ext==".au")
			return GetResString(IDS_SEARCH_AUDIO);

	if (ext==".bmp" || ext==".jpg" || ext==".jpeg" || ext==".gif" || ext==".png" || ext==".tga" ||
		ext==".tif" || ext==".xif" || ext==".tiff" || ext==".psd" || ext==".psp" || ext==".pcx" ||
		ext==".dcx" || ext==".pic" || ext==".pict" || ext==".pct" || ext==".wmf" || ext==".emf")
			return GetResString(IDS_SEARCH_PICS);

	if (ext==".avi" || ext==".divx" || ext==".ram" || ext==".rm" || ext==".rv" || ext==".ogm" ||
		ext==".mpg" || ext==".mpeg" || ext==".mpv" || ext==".mps" || ext==".m1v" || ext==".m2v" ||
		ext==".mpe" || ext==".mpa" || ext==".mp4" || ext==".vob" || ext==".mov" || ext==".asf" ||
		ext==".wmv" || ext==".vivo" || ext==".rmvb" || ext==".xvid")
			return GetResString(IDS_SEARCH_VIDEO);

	if (ext==".zip" || ext==".rar" || ext==".ace" || ext==".tar" || ext==".gz" || ext==".tgz" ||
		ext==".arj" || ext==".lha" || ext==".uc2")
			return GetResString(IDS_SEARCH_ARC);

	if (ext==".exe" || ext==".com")
			return GetResString(IDS_SEARCH_PRG);

	if (ext==".ccd"|| ext==".sub" || ext==".cue" || ext==".bin" || ext==".iso" || ext==".nrg" ||
		ext==".img" || ext==".bwa" || ext==".bwi" || ext==".bws" || ext==".bwt" || ext==".mds" ||
		ext==".mdf")
		return GetResString(IDS_SEARCH_CDIMG);

	if (ext==".doc" || ext==".txt" || ext==".pdf" || ext==".xls" || ext==".rtf" || ext==".nfo" || 
		ext==".xml" || ext==".htm" || ext==".html" || ext==".ppt")
			return GetResString(IDS_SEARCH_DOC);
	EMULE_CATCH
	return GetResString(IDS_SEARCH_ANY);
}

d1615 1
a1615 1
	{ _T(".toast"), ED2KFT_CDIMAGE }
d1618 9
a1626 9
//	{ _T(".txt"),   ED2KFT_DOCUMENT },
//	{ _T(".nfo"),   ED2KFT_DOCUMENT },
//	{ _T(".diz"),   ED2KFT_DOCUMENT },
//	{ _T(".doc"),   ED2KFT_DOCUMENT },
//	{ _T(".rtf"),   ED2KFT_DOCUMENT },
//	{ _T(".pdf"),   ED2KFT_DOCUMENT },	// double check this!
//	{ _T(".xls"),   ED2KFT_DOCUMENT },	// double check this!
//	{ _T(".html"),  ED2KFT_DOCUMENT },
//	{ _T(".htm"),   ED2KFT_DOCUMENT }
d1656 1
a1656 13
// Retuns the ed2k file type term which is to be used in server searches
LPCSTR GetED2KFileTypeSearchTerm(EED2KFileType iFileID)
{
	if (iFileID == ED2KFT_AUDIO)		return "Audio";
	if (iFileID == ED2KFT_VIDEO)		return "Video";
	if (iFileID == ED2KFT_IMAGE)		return "Image";
	if (iFileID == ED2KFT_ARCHIVE || iFileID == ED2KFT_PROGRAM || iFileID == ED2KFT_CDIMAGE) return "Pro";
	if (iFileID == ED2KFT_DOCUMENT)		return "Doc";
	return NULL;
}

// Returns a localized typename, examining the extention of the given filename
CString GetFiletypeByName(LPCTSTR pszFileName)
a1657 14
	EED2KFileType iFileType = GetED2KFileTypeID(pszFileName);
	switch (iFileType) {
		case ED2KFT_AUDIO :		return GetResString(IDS_SEARCH_AUDIO);
		case ED2KFT_VIDEO :		return GetResString(IDS_SEARCH_VIDEO);
		case ED2KFT_IMAGE :		return GetResString(IDS_SEARCH_PICS);
		case ED2KFT_ARCHIVE :	return GetResString(IDS_SEARCH_ARC);
		case ED2KFT_PROGRAM :	return GetResString(IDS_SEARCH_PRG);
		case ED2KFT_CDIMAGE :	return GetResString(IDS_SEARCH_CDIMG);
		default:				return GetResString(IDS_SEARCH_ANY);
	}
}


class CED2KFileTypes{
d1659 2
a1660 1
	CED2KFileTypes(){
d1665 2
a1666 1
		for (int i = 1; i < ELEMENT_COUNT(_aED2KFileTypes); i++){
@


1.102
log
@Formatting, comments, and name changes.
@
text
@d1866 11
@


1.101
log
@free disk space needed is now determined with respect to NTFS compression and/or sparse files
@
text
@d1016 1
a1016 1
	bool isPlus=(client->PlusVersion() && client->PlusVersion()<0x2600);
d1022 2
a1023 2
			int num=(client->PlusVersion() & 0xF0)>>4;
			int letter=(client->PlusVersion() & 0x0F);
d1026 1
a1026 1
				buffer.Format(_T("Plus v%u.%u%c"), client->PlusVersion()>>8,num, (char)letter);
d1028 1
a1028 1
				buffer.Format(_T("Plus v%u%c"), client->PlusVersion()>>8,(char)letter);
@


1.100
log
@some updates from official
@
text
@d1836 30
@


1.99
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d578 9
a586 3
_int64 GetFreeDiskSpaceX(LPCTSTR pDirectory)
{	
	FARPROC pGetDiskFreeSpaceEx;
d588 1
a588 3
	pGetDiskFreeSpaceEx = GetProcAddress(GetModuleHandle(_T("kernel32.dll")), "GetDiskFreeSpaceExA");

	if(pGetDiskFreeSpaceEx)
d592 1
a592 1
		GetDiskFreeSpaceEx(pDirectory, &nFreeDiskSpace, &dummy, &dummy);
d597 2
a598 2
		TCHAR cDrive[16];
		TCHAR *p = _tcschr(pDirectory, '\\');
d605 1
a605 1
			_tcscpy(cDrive, pDirectory);
a609 2
	
//	return 0;
d1599 1
@


1.98
log
@Formatting, comments, and name changes.
@
text
@d70 1
a70 1
			buffer.Format(_T("%.0f %s"),(float)count,GetResString(IDS_BYTES).GetBuffer(0));
d78 1
a78 1
		buffer.Format(_T("%.0f %s"),(float)count/1024,GetResString(IDS_KBYTES).GetBuffer(0));
d80 1
a80 1
		buffer.Format(_T("%.2f %s"),(float)count/1048576,GetResString(IDS_MBYTES).GetBuffer(0));
d82 1
a82 1
		buffer.Format(_T("%.2f %s"),(float)count/1073741824,GetResString(IDS_GBYTES).GetBuffer(0));
d84 1
a84 1
		buffer.Format(_T("%.3f %s"),(float)count/1099511627776,GetResString(IDS_TBYTES).GetBuffer(0));
d101 1
a101 1
		buffer.Format(_T("%.0f%s"),(float)count/1000, GetResString(IDS_KILO).GetBuffer(0));
d103 1
a103 1
		buffer.Format(_T("%.2f%s"),(float)count/1000000, GetResString(IDS_MEGA).GetBuffer(0));
d105 1
a105 1
		buffer.Format(_T("%.2f%s"),(float)count/1000000000, GetResString(IDS_GIGA).GetBuffer(0));
d107 1
a107 1
		buffer.Format(_T("%.2f%s"),(float)count/1000000000000, GetResString(IDS_TERRA).GetBuffer(0));
d1785 2
a1786 2

float GetPercent(uint32 Value, uint32 TotalValue)
d1788 1
a1788 1
	float ProcentValue = 0.0f;
d1790 2
a1791 2
	if (TotalValue > 0)
		ProcentValue = 100*Value/TotalValue;
d1793 1
a1793 1
	return ProcentValue;
d1795 1
a1795 1

@


1.97
log
@minor change
@
text
@d1234 1
a1234 1
//TODO: ms-help://MS.VSCC/MS.MSDNVS.1031/vclib/html/_crt_Interpretation_of_Multibyte.2d.Character_Sequences.htm
@


1.96
log
@no message
@
text
@d1318 2
@


1.95
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d891 1
a891 1
CString GetStatusDLQueueString(EnumDLQState State)
d938 1
a938 1
CString GetStatusULQueueString(EnumULQState State)
@


1.94
log
@Formatting, comments, and name changes.
@
text
@d720 1
a720 1
    memset(buffer, 0, DecodeLengthBase16(base16BufLen));
@


1.93
log
@Formatting, comments, and name changes.
@
text
@d753 2
a754 2

void UpdateURLMenu(CMenu &menu,int &counter)
a756 5
	counter=0;
	g_eMuleApp.webservices.RemoveAll();
	CString name,url,sbuffer;
	char buffer[1024];
	int lenBuf = 1024;
d758 10
a767 2
	FILE* readFile= _tfopen(CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir())+_T("webservices.dat"), _T("r"));
	if (readFile!=NULL)
d769 2
a770 1
		while (!feof(readFile))
d772 2
a773 1
			if (fgets(buffer,lenBuf,readFile)==0)
d775 1
a775 1
			sbuffer=buffer;
d777 2
a778 2
			// ignore comments & too short lines
			if (sbuffer.GetAt(0) == '#' || sbuffer.GetAt(0) == '/' || sbuffer.GetLength()<5)
d781 1
a781 1
			if (sbuffer == "<separator>\n" || sbuffer == "<separator>") // Sp4rK patch !!
d787 3
a789 2
				int pos=sbuffer.Find(',');
				if (pos>0 && counter<64)
d791 3
a793 3
					counter++;
					menu.AppendMenu(MF_STRING,MP_WEBURL+(counter-1), sbuffer.Left(pos).Trim());
					g_eMuleApp.webservices.Add(sbuffer.Right(sbuffer.GetLength()-pos-1).Trim());
d797 1
a797 1
		fclose(readFile);
d801 1
a801 1

@


1.92
log
@ace and xvid added.
@
text
@d620 2
a621 1
CString GetRateString(uint16 rate) {
d623 1
a623 1
	switch (rate)
d625 1
a625 1
	case 0:
d628 1
a628 1
	case 1:
d631 1
a631 1
	case 2:
d634 1
a634 1
	case 3:
d637 1
a637 1
	case 4:
d640 1
a640 1
	case 5:
@


1.91
log
@added function to format large numbers with thousands dots (asked by purity to use in webserver)
@
text
@d1591 1
@


1.90
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d175 48
@


1.89
log
@Reduced MP_WEBURL to 64 options
@
text
@d1757 18
@


1.88
log
@Category rewrite with predefined status/media type categories.
@
text
@d734 1
a734 1
				if (pos>0)
@


1.87
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@a1410 51
bool CheckShowItemInGivenCat(CPartFile* file, int inCategory) 
{
	// easy normal cases
	if((inCategory > 0 && inCategory == file->GetCategory()) || 
		(inCategory == 0 && g_eMuleApp.m_pGlobPrefs->GetAllcatType() == 0)) 
	{
		return true;
	}

	// ToDo

	if(inCategory == 0 && g_eMuleApp.m_pGlobPrefs->GetAllcatType() > 0)
	{
		switch(g_eMuleApp.m_pGlobPrefs->GetAllcatType()) 
		{
			case 1 : return (file->GetCategory() == 0);
			case 2 : return (file->IsPartFile());
			case 3 : return (!file->IsPartFile());
			case 4 : return ((file->GetStatus() == PS_READY || file->GetStatus() == PS_EMPTY) && file->GetTransferringSrcCount() == 0);
			case 5 : return ((file->GetStatus() == PS_READY|| file->GetStatus() == PS_EMPTY) && file->GetTransferringSrcCount() > 0);
			case 6 : return (file->GetStatus() == PS_ERROR);
			case 7 : return (file->GetStatus() == PS_PAUSED);
			case 8 : return (file->GetStatus() == PS_STOPPED);
			case 10 : return file->IsMovie();
			case 11 : return (ED2KFT_AUDIO == GetED2KFileTypeID(file->GetFileName()));
			case 12 : return file->IsArchive();
			case 13 : return (ED2KFT_CDIMAGE == GetED2KFileTypeID(file->GetFileName()));
		}
	}

	return false;
}

CString GetCatTitle(int catid) {
	switch (catid) {
		case 0 : return GetResString(IDS_ALL);
		case 1 : return GetResString(IDS_ALLOTHERS);
		case 2 : return GetResString(IDS_STATUS_NOTCOMPLETED);
		case 3 : return GetResString(IDS_DL_TRANSFCOMPL);
		case 4 : return GetResString(IDS_WAITING);
		case 5 : return GetResString(IDS_DOWNLOADING);
		case 6 : return GetResString(IDS_ERRORLIKE);
		case 7 : return GetResString(IDS_PAUSED);
		case 8 : return GetResString(IDS_STOPPED);
		case 10 : return GetResString(IDS_VIDEO);
		case 11 : return GetResString(IDS_AUDIO);
		case 12 : return GetResString(IDS_SEARCH_ARC);
		case 13 : return GetResString(IDS_SEARCH_CDIMG);
	}
	return "?";
}
@


1.86
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d549 1
a549 5
			#ifndef AMD
			memcpy(cDrive, pDirectory, p-pDirectory);
			#else
			memcpy_amd(cDrive, pDirectory, p-pDirectory);
			#endif
@


1.85
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d292 1
a292 1
	return GetResString(uStringID,theApp.glob_prefs->GetLanguageID());
d713 1
a713 1
	theApp.webservices.RemoveAll();
d718 1
a718 1
	FILE* readFile= _tfopen(CString(theApp.glob_prefs->GetConfigDir())+_T("webservices.dat"), _T("r"));
d742 1
a742 1
					theApp.webservices.Add(sbuffer.Right(sbuffer.GetLength()-pos-1).Trim());
d767 1
a767 1
	ShellExecute(NULL, NULL, urlpattern, NULL, theApp.glob_prefs->GetAppDir(), SW_SHOWDEFAULT);
d771 1
a771 1
CString GetClientVersionString(eClientTypes clientype,uint32 uVersion)
d840 1
a840 1
CString GetStatusDLQueueString(eDLQState State)
d887 1
a887 1
CString GetStatusULQueueString(eULQState State)
d925 1
a925 1
CString GetClientNameString(eClientTypes clienttype)
d1218 1
a1218 1
	if (theApp.glob_prefs->GetFilenameCleanupTags())
d1242 1
a1242 1
	strList.SetString(theApp.glob_prefs->GetFilenameCleanups().MakeLower());
d1419 1
a1419 1
		(inCategory == 0 && theApp.glob_prefs->GetAllcatType() == 0)) 
d1426 1
a1426 1
	if(inCategory == 0 && theApp.glob_prefs->GetAllcatType() > 0)
d1428 1
a1428 1
		switch(theApp.glob_prefs->GetAllcatType()) 
@


1.84
log
@filenamecleanup: proper clear of nested square brackets
@
text
@d116 1
a116 1
CString CastSecondsToHM(sint32 count)
d126 1
a126 1
		buffer.Format(_T("%i:%s %s"),count/60,LeadingZero(count-(count/60)*60).GetBuffer(0),GetResString(IDS_MINS).GetBuffer(0));
d128 1
a128 1
		buffer.Format(_T("%i:%s %s"),count/3600,LeadingZero((count-(count/3600)*3600)/60).GetBuffer(0),GetResString(IDS_HOURS).GetBuffer(0));
d130 4
d135 6
d413 5
a418 2
int GetMaxConnections() {
	EMULE_TRY
d420 1
d424 3
a426 2
	if(!GetVersionEx((OSVERSIONINFO*)&osvi)) {
		//if OSVERSIONINFOEX doesn't work, try OSVERSIONINFO
d435 4
a438 3
	if(osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) { // Windows 95 product family

		if (osvi.dwMajorVersion == 4 && osvi.dwMinorVersion == 0) { //old school 95
d444 1
d456 3
a458 1
		} else { //98 or ME
d464 1
d472 1
d482 1
a482 1

d1433 2
a1434 2
			case 4 : return ((file->GetStatus() == PS_READY || file->GetStatus() == PS_EMPTY) && file->GetTransferingSrcCount() == 0);
			case 5 : return ((file->GetStatus() == PS_READY|| file->GetStatus() == PS_EMPTY) && file->GetTransferingSrcCount() > 0);
d1506 1
a1506 1
void MakeFoldername(char* path)
d1519 1
d1674 1
d1677 1
d1679 1
d1683 1
d1686 1
a1686 1
	const SED2KFileType* pFound = (SED2KFileType*)bsearch(&ft, _aED2KFileTypes, ELEMENT_COUNT(_aED2KFileTypes), sizeof _aED2KFileTypes[0], CompareE2DKFileType);
d1689 1
d1804 1
d1809 1
@


1.83
log
@Implemented ConfigDir
@
text
@d1199 1
a1199 1
		int foundPo2;
d1207 9
a1215 1
				filename.SetString(filename.Left(foundPos) + filename.Right(filename.GetLength()-foundPo2-1));
a1315 1
	filename.Trim();
@


1.82
log
@filenamecleanup:
cutoff doubled extension
clear leading and trailing junk
safe failover returning original input
...more2come...
@
text
@d697 1
a697 1
	FILE* readFile= _tfopen(CString(theApp.glob_prefs->GetAppDir())+_T("webservices.dat"), _T("r"));
@


1.81
log
@*** empty log message ***
@
text
@d1163 1
a1163 1
CString CleanupFilename(CString filename) {
d1165 1
d1181 12
d1200 2
a1201 1
		while (true) {
d1203 4
a1206 2
			foundPo2 = filename.Find(']');
			if (foundPos > -1 && foundPo2 > foundPos)
d1216 2
a1217 1
	while (!resToken.IsEmpty()) {
d1257 1
a1257 1
	filename.SetString(LeadingCaps(filename, _T("'0123456789")));	//leadingcaps except after "'" and numbers
d1274 2
d1309 4
a1312 1
	if (filename.IsEmpty()) filename.SetString(_T("Empty"));
d1314 1
d1316 1
a1316 1
	return filename;
@


1.80
log
@extended Upload Session statistic
@
text
@d180 2
a181 1
void ShellOpenFile(const CString& name) {
a1363 1
#ifdef __USE_CATEGORIES__
a1374 1
/*
d1386 1
a1386 1
			case 8 : return file->IsStopped();
d1393 1
a1393 1
*/
d1416 39
d1457 216
a1672 6
	CString string(path);
	if(string.GetLength() > 0) 
	{	
		if(string.Right(1) == '\\') 
		{	
			string = string.Left(string.GetLength()-1);
d1674 1
d1676 48
a1723 1
	sprintf(path, "%s", string);
a1724 1
#endif
d1734 18
@


1.79
log
@*** empty log message ***
@
text
@d1431 9
@


1.78
log
@1) fix with 100% load after connect to server
2) MOD are sorted now
@
text
@d1398 19
@


1.77
log
@new statistic (khaos based)
@
text
@d141 1
a141 1
CString CastSecondsToLngHM(__int64 count)
@


1.76
log
@share files with soft limit
@
text
@d139 26
@


1.75
log
@*** empty log message ***
@
text
@d781 11
@


1.74
log
@Added simple encription of SMTP password.
@
text
@d1325 50
@


1.73
log
@Proper URL Decoding
@
text
@d1283 42
@


1.72
log
@FATURE: specify path to WebServer template in preferences
@
text
@d995 2
a996 1
	for (int x = 0; x < inStr.GetLength() ; ++x )
d1000 2
d1004 36
a1039 1
			outStr.AppendChar(_tcstoul(hexstr, NULL, 16));
d1044 1
@


1.71
log
@tiny filename-cleanup changes
@
text
@d1230 8
@


1.70
log
@minor cleanup addition
@
text
@d1085 1
d1088 5
a1092 5
	CString strList("");	//list of pipe-separated tokens
	CString resToken("");	//one token out of strList
	int foundPos = 0;		//position where something is found
	int curPos = 0;			//position for tokenize() (by reference!)
	CString extension("");	//only the extension of filename with dot
d1098 1
a1098 1
	if( foundPos >= 0 )
a1128 1
	//chinese wipeout bugfix filename.SetString(DeleteNonAlphaNumeric(filename, _T(" .,'-&#()[]{}"), false));
d1163 1
a1163 1
	filename.SetString(LeadingCaps(filename, _T("'0123456789")));	//leadingcaps except after "'" and numbers
@


1.69
log
@FEATURE: capitalize roman numerals during cleanup [SyruS]
BUGFIX: don't cleanup chinese (and other) non alphanumeric letters [SyruS]
more try & catch
@
text
@d1179 1
@


1.68
log
@unicode cleanup
@
text
@d154 4
a157 2
void ShellOpenFile(const CString& name){ 
    ShellExecute(NULL, _T("open"), name, NULL, NULL, SW_SHOW); 
d161 1
d203 2
d213 1
a213 1
	
d250 1
a250 1

d267 1
d269 1
a269 1
	
d275 1
d292 3
a294 1
	return (reg == rbuffer);	
d437 2
a440 1
	bNTBased	=	FALSE;
d478 1
a478 1
	
d528 25
a552 22
CString   GetRateString(uint16 rate)   { 
      switch (rate){ 
      case 0: 
         return GetResString(IDS_CMT_NOTRATED); 
         break; 
      case 1: 
         return GetResString(IDS_CMT_FAKE); 
         break; 
      case 2: 
         return GetResString(IDS_CMT_POOR); 
         break; 
      case 3: 
         return GetResString(IDS_CMT_GOOD); 
         break; 
      case 4: 
         return GetResString(IDS_CMT_FAIR); 
         break; 
      case 5: 
         return GetResString(IDS_CMT_EXCELLENT); 
         break; 
      } 
      return GetResString(IDS_CMT_NOTRATED); 
d554 3
a556 1
//end rate File//// Returns a BASE32 encoded byte array
d566 2
a567 2
	CString Base32Buff;
    
d592 1
a592 1

d606 2
a607 2
	CString Base16Buff;

d612 1
a612 1

d626 1
d646 1
a722 1

d725 2
a726 1
	CString cbuffer	=	_T("");;
d772 1
a777 1

a780 1

d783 2
a784 1
	CString stateString	=	GetResString(IDS_UNKNOWN);
d824 1
a827 1

d830 2
a831 1
	CString stateString	=	GetResString(IDS_UNKNOWN);
d862 1
a865 2


d868 2
a869 1
	CString nameString	=	GetResString(IDS_UNKNOWN);
d897 1
d902 2
a903 1
	CString buffer;
d941 1
d946 2
a947 2
int CALLBACK BrowseCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
d957 1
a957 1
         
d963 1
d985 2
a986 1
	} 
d993 1
d1008 2
d1014 1
d1032 1
d1041 2
d1046 3
a1048 1
		if (!IsCharAlphaNumeric(inStr.GetAt(pos)) && exceptStr.Find(inStr.GetAt(pos)) < 0 && ( !onlyRep || (pos+1 < inStr.GetLength() && inStr.Find(inStr.GetAt(pos), pos+1) == pos+1 )))
d1053 1
d1062 1
d1081 1
d1086 1
a1086 1

d1099 1
a1099 1
		extension.SetString(filename.Right(filename.GetLength()-foundPos));	//copy extension with dot
d1101 1
a1101 1
		filename.SetString(filename.Left(foundPos));						//cut to filename without dot
d1128 1
a1128 1
	filename.SetString(DeleteNonAlphaNumeric(filename, _T(" .,'-&#()[]{}"), false));	//only alphanum and " .,'-&#()[]{}" remain
d1163 1
a1163 1
	filename.SetString(LeadingCaps(filename, _T("'")));	//leadingcaps except after "'"
d1180 29
a1208 10
	filename.Replace(_T(" V1"),_T(" v1"));
	filename.Replace(_T(" V2"),_T(" v2"));
	filename.Replace(_T(" V3"),_T(" v3"));
	filename.Replace(_T(" V4"),_T(" v4"));
	filename.Replace(_T(" V5"),_T(" v5"));
	filename.Replace(_T(" V6"),_T(" v6"));
	filename.Replace(_T(" V7"),_T(" v7"));
	filename.Replace(_T(" V8"),_T(" v8"));
	filename.Replace(_T(" V9"),_T(" v9"));
	filename.Replace(_T(" V0"),_T(" v0"));
d1214 1
a1218 1

d1220 1
a1220 1

d1225 2
@


1.67
log
@unicode cleanup
@
text
@d940 1
a940 1
CString BrowseFolder(HWND hwndOwner, const char* pszTitle, const char* pszStartFolder) {
@


1.66
log
@minor cleanup addition
@
text
@d472 1
a472 1
_int64 GetFreeDiskSpaceX(PCHAR pDirectory)
d487 2
a488 2
		char cDrive[16];
		char *p = strchr(pDirectory, '\\');
d499 1
a499 1
			strcpy(cDrive, pDirectory);
d691 1
a691 1
	    urlpattern.Replace("#hashid", EncodeBase16(file->GetFileHash(), 16));
d695 2
a696 2
	    temp.Format("%u",file->GetFileSize());
	    urlpattern.Replace("#filesize", temp);
d699 1
a699 1
	    urlpattern.Replace("#filename",URLEncode(file->GetFileName()));
d755 1
a755 1
	return (cbuffer=="0.00"||cbuffer=="0.0"||cbuffer=="0")?" ?":cbuffer ;
d761 1
a761 1
	return (in.Left(length-8)+"..."+in.Right(8));
d873 1
a873 1
		nameString	=	_T(GetResString(IDS_OLDMLDONKEY));
d876 1
a876 1
		nameString	=	_T(GetResString(IDS_OLDEMULE));
d894 1
a894 1
				buffer.Format("Plus v%u.%u%c", client->PlusVersion()>>8,num, (char)letter);
d896 1
a896 1
				buffer.Format("Plus v%u%c", client->PlusVersion()>>8,(char)letter);
d906 2
a907 2
				buffer.Format("%s v%s [%s]",(const char*)GetClientNameString(client->GetClientSoft()),
					(const char*)GetClientVersionString(client->GetClientSoft(), client->GetMuleVersion()), (const char*)client->GetModVersion());
d909 2
a910 2
				buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
					(const char*)GetClientVersionString(client->GetClientSoft(), client->GetMuleVersion()));
d914 1
a914 1
		buffer.Format("???");
d917 2
a918 2
		buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
            (const char*)GetClientVersionString(client->GetClientSoft(),client->GetVersion()));
d944 1
a944 1
	BROWSEINFOA bi;
d957 1
a957 1
			retstring.Format("%s", pszDisplayName);
d974 2
a975 2
			char hexstr[3]; hexstr[2]=0;
			strncpy(hexstr, inStr.Mid(x+1,2).GetBuffer(), 2);
d977 1
a977 1
			outStr.AppendChar((unsigned char)strtoul(hexstr, NULL, 16));
d1065 1
a1065 1
		extension.SetString(DeleteNonAlphaNumeric(extension, ".", false));	//only alphanum & dot allowed
d1068 1
a1068 1
	if (extension.IsEmpty()) extension.SetString(".non");
d1086 1
a1086 1
	resToken.SetString(strList.Tokenize("|",curPos));
d1088 2
a1089 2
		filename.Replace(resToken," ");
		resToken.SetString(strList.Tokenize("|",curPos));
d1092 2
a1093 2
	filename.SetString(ReplaceDotsWithSpaces(filename, "01234567689", "_+^!$%=~@@;\\\"/:*?<>|", false)); //spaceholders
	filename.SetString(DeleteNonAlphaNumeric(filename, " .,'-&#()[]{}", false));	//only alphanum and " .,'-&#()[]{}" remain
d1096 17
a1112 17
	filename.Replace("shared by", "");
	filename.Replace("shared for", "");
	filename.Replace("shared via", "");
	filename.Replace("shared ", "");
	filename.Replace("found at", "");
	filename.Replace("found via xxx", "");	//filedonkey.com special
	filename.Replace("found via", "");
	filename.Replace("link by", "");
	filename.Replace("linked at", "");
	filename.Replace("linked by", "");
	filename.Replace("linked ", "");
	filename.Replace("powered by", "");
	filename.Replace("-powered-by-", "");	//eselfilme.de special
	filename.Replace("powered ", "");
	filename.Replace("sponsored for", "");
	filename.Replace("sponsored by", "");
	filename.Replace("sponsored ", "");
d1114 1
a1114 1
	filename.SetString(DeleteNonAlphaNumeric(filename, "", true));	//reduce doubles
d1117 6
a1122 6
	filename.Replace("( ", "(");
	filename.Replace(" )", ")");
	filename.Replace("[ ", "[");
	filename.Replace(" ]", "]");
	filename.Replace("{ ", "{");
	filename.Replace(" }", "}");
d1124 3
a1126 3
	filename.Replace("()", "");
	filename.Replace("[]", "");
	filename.Replace("{}", "");
d1128 1
a1128 1
	filename.SetString(LeadingCaps(filename, "'"));	//leadingcaps except after "'"
d1131 13
a1143 13
	filename.Replace("Cd","CD");
	filename.Replace("Vcd","VCD");
	filename.Replace("Svcd","SVCD");
	filename.Replace("Dvd","DVD");
	filename.Replace("Divx","DivX");
	filename.Replace("Xvid","XviD");
	filename.Replace("Ac3","AC3");
	filename.Replace("Mp3","MP3");
	filename.Replace("Vbr","VBR");
	filename.Replace("Cbr","CBR");
	filename.Replace("Vhs","VHS");
	filename.Replace("Tv","TV");
	filename.Replace("Fsk","FSK");
d1145 10
a1154 10
	filename.Replace(" V1"," v1");
	filename.Replace(" V2"," v2");
	filename.Replace(" V3"," v3");
	filename.Replace(" V4"," v4");
	filename.Replace(" V5"," v5");
	filename.Replace(" V6"," v6");
	filename.Replace(" V7"," v7");
	filename.Replace(" V8"," v8");
	filename.Replace(" V9"," v9");
	filename.Replace(" V0"," v0");
d1158 1
a1158 1
	if (filename.IsEmpty()) filename.SetString("Empty");
@


1.65
log
@unicode cleanup
@
text
@d661 1
a661 1
			
d1143 1
@


1.64
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d70 1
a70 1
			buffer.Format("%.0f %s",(float)count,GetResString(IDS_BYTES).GetBuffer(0));
d74 1
a74 1
			buffer.Format("0 %s",GetResString(IDS_BYTES).GetBuffer(0));
d78 1
a78 1
		buffer.Format("%.0f %s",(float)count/1024,GetResString(IDS_KBYTES).GetBuffer(0));
d80 1
a80 1
		buffer.Format("%.2f %s",(float)count/1048576,GetResString(IDS_MBYTES).GetBuffer(0));
d82 1
a82 1
		buffer.Format("%.2f %s",(float)count/1073741824,GetResString(IDS_GBYTES).GetBuffer(0));
d84 1
a84 1
		buffer.Format("%.3f %s",(float)count/1099511627776,GetResString(IDS_TBYTES).GetBuffer(0));
d99 1
a99 1
		buffer.Format("%i",count);
d101 1
a101 1
		buffer.Format("%.0f%s",(float)count/1000, GetResString(IDS_KILO).GetBuffer(0));
d103 1
a103 1
		buffer.Format("%.2f%s",(float)count/1000000, GetResString(IDS_MEGA).GetBuffer(0));
d105 1
a105 1
		buffer.Format("%.2f%s",(float)count/1000000000, GetResString(IDS_GIGA).GetBuffer(0));
d107 1
a107 1
		buffer.Format("%.2f%s",(float)count/1000000000000, GetResString(IDS_TERRA).GetBuffer(0));
d122 1
a122 1
		buffer = "?"; 
d124 1
a124 1
		buffer.Format("%i %s",count,GetResString(IDS_SECS).GetBuffer(0)); 
d126 1
a126 1
		buffer.Format("%i:%s %s",count/60,LeadingZero(count-(count/60)*60).GetBuffer(0),GetResString(IDS_MINS).GetBuffer(0));
d128 1
a128 1
		buffer.Format("%i:%s %s",count/3600,LeadingZero((count-(count/3600)*3600)/60).GetBuffer(0),GetResString(IDS_HOURS).GetBuffer(0));
d130 1
a130 1
		buffer.Format("%i %s %i %s",count/86400,GetResString(IDS_DAYS).GetBuffer(0),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS).GetBuffer(0)); 
d143 1
a143 1
		ret.AppendFormat("%02X", hash[i]);
d149 1
a149 1
	if (units<10) temp.Format("0%i",units); else temp.Format("%i",units);
d155 1
a155 1
    ShellExecute(NULL, "open", name, NULL, NULL, SW_SHOW); 
d262 1
a262 1
	in.Replace("&","&&");
d283 1
a283 1
	CString reg(CString("\"") + mod + "\" \"%1\"");
d302 1
a302 1
			CString reg(CString("\"") + mod + "\" \"%1\"");
d304 1
a304 1
			regkey.Create(HKEY_CLASSES_ROOT,"ed2k\\shell\\open\\command");
d306 1
a306 1
			regkey.Create(HKEY_CLASSES_ROOT,"ed2k\\DefaultIcon" );// Added Shrink 
d308 3
a310 3
			regkey.Create(HKEY_CLASSES_ROOT,"ed2k" );
			regkey.SetStringValue(0,"URL: ed2k Protocol");
			regkey.SetStringValue("URL Protocol","" );
d323 1
a323 1
	regkey.Create(HKEY_CLASSES_ROOT, "ed2k\\shell\\open\\command");
d328 1
a328 1
	if ((regkey.QueryStringValue("OldDefault", rbuffer, &maxsize) != ERROR_SUCCESS) || (maxsize == 0))
d332 2
a333 2
		regkey.SetStringValue("OldDefault", rbuffer);	
		regkey.Create(HKEY_CLASSES_ROOT, "ed2k\\DefaultIcon" );
d336 1
a336 1
			regkey.SetStringValue("OldIcon", rbuffer);
d348 1
a348 1
	regkey.Create(HKEY_CLASSES_ROOT, "ed2k\\shell\\open\\command");	
d352 1
a352 1
	if (regkey.QueryStringValue("OldDefault", rbuffer, &maxsize) == ERROR_SUCCESS)
d355 2
a356 2
		regkey.Create(HKEY_CLASSES_ROOT, "ed2k\\DefaultIcon" );
		regkey.DeleteValue("OldDefault");
d358 1
a358 1
		if (regkey.QueryStringValue("OldIcon", rbuffer, &maxsize) == ERROR_SUCCESS)
d361 1
a361 1
			regkey.DeleteValue("OldIcon");
d392 1
a392 1
			RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\MSTCP",
d409 1
a409 1
			RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\VxD\\MSTCP",
d416 1
a416 1
			if(lResult != ERROR_SUCCESS || (lMaxConnections = atoi(szValue)) < 1)
d476 1
a476 1
	pGetDiskFreeSpaceEx = GetProcAddress(GetModuleHandle("kernel32.dll"), "GetDiskFreeSpaceExA");
d653 1
a653 1
	FILE* readFile= fopen(CString(theApp.glob_prefs->GetAppDir())+"webservices.dat", "r");
d1171 7
@


1.63
log
@unicode cleanup
@
text
@d21 1
d491 1
d493 3
d1170 1
a1170 1
}@


1.62
log
@CHANGE: code cleanup (m_modVerString & m_modExtendedString coverting to CString) [DoubleT]
@
text
@d604 1
a604 1
void DecodeBase16(const char *base16Buffer, unsigned int base16BufLen, byte *buffer)
@


1.61
log
@converted to helper function GetErrorMessage
@
text
@d900 1
a900 1
			if (client->GetModVersion() && !isPlus) 
d1134 3
@


1.60
log
@Fix for ed2k links handling
@
text
@d1153 10
@


1.59
log
@code cleanup
@
text
@d282 1
a282 1
	CString reg(CString("\"") + mod + "\" \"%%1\"");
d301 1
a301 1
			CString reg(CString("\"") + mod + "\" \"%%1\"");
@


1.58
log
@code cleanup
@
text
@d60 1
a60 1
CString CastItoXBytes(uint64 count, char *pBuffer,size_t size)
d84 1
a84 5
	if(pBuffer && size)
	{
		strncpy(pBuffer, buffer, size - 1);
		pBuffer[size - 1] = NULL;
	}
d92 1
a92 1
CString CastItoIShort(uint64 count, char *pBuffer,size_t size)
d107 1
a107 5
	if(pBuffer && size)
	{
		strncpy(pBuffer, buffer, size - 1);
		pBuffer[size - 1] = NULL;
	}
d115 1
a115 1
CString CastSecondsToHM(sint32 count, char *pBuffer,size_t size)
d130 1
a130 5
	if(pBuffer && size)
	{
		strncpy(pBuffer, buffer, size - 1);
		pBuffer[size - 1] = NULL;
	}
@


1.57
log
@code cleanup
@
text
@d283 3
a285 2
	ULONG size = sizeof(rbuffer) / sizeof(rbuffer[0]);	
	if (regkey.QueryStringValue(NULL, rbuffer, &size) != ERROR_SUCCESS) {
d294 2
a295 3
	CString reg;
	reg.Format("\"%s\" \"%%1\"", mod);
	
d308 7
a314 2
			char modbuffer[490];
			char regbuffer[520];
d316 1
a316 1
			regkey.SetStringValue(0,regbuffer);	
d318 1
a318 1
			regkey.SetStringValue(0,modbuffer);
@


1.56
log
@code cleanup
@
text
@a168 30
namespace {
	bool IsHexDigit(int c) {
		switch (c) {
		case '0': return true;
		case '1': return true;
		case '2': return true;
		case '3': return true;
		case '4': return true;
		case '5': return true;
		case '6': return true;
		case '7': return true;
		case '8': return true;
		case '9': return true;
		case 'A': return true;
		case 'B': return true;
		case 'C': return true;
		case 'D': return true;
		case 'E': return true;
		case 'F': return true;
		case 'a': return true;
		case 'b': return true;
		case 'c': return true;
		case 'd': return true;
		case 'e': return true;
		case 'f': return true;
		default: return false;
		}
	}
}

d278 22
a299 1
bool Ask4RegFix(bool checkOnly, bool dontAsk){
d301 2
a302 3
	// Barry - Make backup first
	if (!checkOnly)
		BackupReg();
d305 1
a305 11
	CRegKey regkey;
	regkey.Create(HKEY_CLASSES_ROOT,"ed2k\\shell\\open\\command");
	ULONG maxsize = 500;
	TCHAR rbuffer[500];
	char modbuffer[490];
	char regbuffer[520];
	regkey.QueryStringValue(0,rbuffer,&maxsize);
	::GetModuleFileName(0,modbuffer, 490);
	sprintf(regbuffer,"\"%s\" \"%%1\"",modbuffer);
	if (strcmp(rbuffer,regbuffer)){
		if (checkOnly) return true;
d307 4
d317 1
d319 1
a319 2
	}
	regkey.Close();
d330 1
a330 1
	ULONG maxsize = 500;
d332 1
d336 1
a336 1
		maxsize = 500;
d340 1
a340 1
		maxsize = 500;	
d354 1
a354 2
	regkey.Create(HKEY_CLASSES_ROOT, "ed2k\\shell\\open\\command");
	ULONG maxsize = 500;
d356 2
d363 1
a363 1
		maxsize = 500;	
d944 1
a944 1
    char pszDisplayName[MAX_PATH];
d975 1
a975 1
		if ( inStr.GetAt(x)== '%' && x+2 < inStr.GetLength() && IsHexDigit(inStr.GetAt(x+1)) && IsHexDigit(inStr.GetAt(x+2)) ) {
@


1.55
log
@coverted code from char * to CString
@
text
@d150 8
@


1.54
log
@inlined function should be defined in header
@
text
@d64 1
a64 1
	char buffer[500];
d69 1
a69 1
			sprintf(buffer, "%.0f %s",(float)count,GetResString(IDS_BYTES).GetBuffer(0));
d73 1
a73 1
			sprintf(buffer,"0 %s",GetResString(IDS_BYTES).GetBuffer(0));
d77 1
a77 1
		sprintf(buffer, "%.0f %s",(float)count/1024,GetResString(IDS_KBYTES).GetBuffer(0));
d79 1
a79 1
		sprintf(buffer, "%.2f %s",(float)count/1048576,GetResString(IDS_MBYTES).GetBuffer(0));
d81 1
a81 1
		sprintf(buffer, "%.2f %s",(float)count/1073741824,GetResString(IDS_GBYTES).GetBuffer(0));
d83 1
a83 1
		sprintf(buffer, "%.3f %s",(float)count/1099511627776,GetResString(IDS_TBYTES).GetBuffer(0));
d89 1
a89 1
	return CString(buffer);
d100 1
a100 1
	char buffer[500];
d102 1
a102 1
		sprintf(buffer, "%i",count);
d104 1
a104 1
		sprintf(buffer, "%.0f%s",(float)count/1000, GetResString(IDS_KILO).GetBuffer(0));
d106 1
a106 1
		sprintf(buffer, "%.2f%s",(float)count/1000000, GetResString(IDS_MEGA).GetBuffer(0));
d108 1
a108 1
		sprintf(buffer, "%.2f%s",(float)count/1000000000, GetResString(IDS_GIGA).GetBuffer(0));
d110 1
a110 1
		sprintf(buffer, "%.2f%s",(float)count/1000000000000, GetResString(IDS_TERRA).GetBuffer(0));
d116 1
a116 1
	return CString(buffer);
d127 1
a127 1
	char buffer[500];
d129 1
a129 1
		sprintf(buffer, "?"); 
d131 1
a131 1
		sprintf(buffer, "%i %s",count,GetResString(IDS_SECS).GetBuffer(0)); 
d133 1
a133 1
		sprintf(buffer, "%i:%s %s",count/60,LeadingZero(count-(count/60)*60).GetBuffer(0),GetResString(IDS_MINS).GetBuffer(0));
d135 1
a135 1
		sprintf(buffer, "%i:%s %s",count/3600,LeadingZero((count-(count/3600)*3600)/60).GetBuffer(0),GetResString(IDS_HOURS).GetBuffer(0));
d137 1
a137 1
		sprintf(buffer, "%i %s %i %s",count/86400,GetResString(IDS_DAYS).GetBuffer(0),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS).GetBuffer(0)); 
d143 1
a143 1
	return CString(buffer);
@


1.53
log
@kill unused URLDecode method
@
text
@a293 7
inline char* nstrdup(const char* todup) { 
  if (!todup) 
    return NULL; //added by lovelace (crash prevention)
   size_t len = strlen(todup)+1; 
   return (char*)memcpy(new char[len], todup, len); 
} 

@


1.52
log
@SyruS: bugfix don't delete remaining dots anymore
@
text
@a190 29
void URLDecode(CString& result, const char* buff)
{
	int buflen = (int)strlen(buff);
	int x;
	int y;
	char* buff2 = nstrdup(buff); // length of buff2 will be less or equal to length of buff
	for (x = 0, y = 0; x < buflen ; ++x )
	{
		if ( buff[x] == '%' && x+2 < buflen && IsHexDigit(buff[x+1]) && IsHexDigit(buff[x+2]) ) {
			char hexstr[3];
			// Copy the two bytes following the %
			strncpy(hexstr, &buff[x + 1], 2);

			// Skip over the hex
			x = x + 2;

			// Convert the hex to ASCII
			buff2[y++] = (unsigned char)strtoul(hexstr, NULL, 16);
		}
		else {
			buff2[y++] = buff[x];
			break;
		}
	}
	result = buff2;
	//free(buff2);
	delete buff2; // it was allocated with new (in nstrdup() )
}

@


1.51
log
@SyruS: cleanup: leave TV capitalized, make "v" in front of version lowercase
@
text
@d1137 1
a1137 1
	filename.SetString(DeleteNonAlphaNumeric(filename, " ,'-&#()[]{}", false));	//only alphanum and " ,'-&#()[]{}" remain
@


1.50
log
@SyruS: last cleanup-changes (before further major changes)
@
text
@d1139 1
a1139 1
	//advertising cleanup
d1183 12
@


1.49
log
@minor fixes and improvements
@
text
@d1012 1
a1012 1
//SyruS: centralized functions used by CleanupFilename
a1013 1

a1027 1

d1030 2
a1031 2
CString LeadingCaps(CString inStr) {

d1034 1
a1034 4
		CString tempStr("");
		int topos=inStr.GetLength()-1;

		tempStr=inStr.GetAt(0);
d1038 2
a1039 1
		for (int ix=0; ix < topos; ix++)
d1041 1
a1041 1
			if (!IsCharAlpha(inStr.GetAt(ix)))
d1043 1
a1043 1
				tempStr=inStr.GetAt(ix+1);
d1045 1
a1045 1
				inStr.SetAt(ix+1,tempStr.GetAt(0));
d1050 1
d1052 40
a1093 1
//SyruS: merged with 0.28b
d1095 8
a1102 24
	
	CString tempStr("");
	filename=URLDecode(filename);
	filename.MakeLower();

	// Replace Space-holders with Spaces
	filename.Replace('_',' ');
	filename.Replace("+"," ");
	// invalid for filenames
	filename.Replace("\\", " ");
	filename.Replace("\"", " ");
	filename.Replace("/", " ");
	filename.Replace(":", " ");
	filename.Replace("*", " ");
	filename.Replace("?", " ");
	filename.Replace("<", " ");
	filename.Replace(">", " ");
	filename.Replace("|", " ");
	// other nonsense
	filename.Replace("=", " ");
	filename.Replace("^", " ");
	filename.Replace("", " ");
	filename.Replace("~", " ");
	filename.Replace("!", " ");
d1105 6
a1110 18
	CString extension("");
	int extpos = filename.ReverseFind('.');
	if( extpos >= 0 )
	{
		extension = filename.Right(filename.GetLength()-extpos);	//copy extension with dot
		extension.Replace(" ","");
		filename = filename.Left(extpos);	//cut to filename without dot
	}
	else extension.SetString(".non");

	//remove substrings, defined in the preferences (.ini)
	CString resToken("");
	CString strClear(theApp.glob_prefs->GetFilenameCleanups().MakeLower());
	int curPos = 0;
	resToken= strClear.Tokenize("|",curPos);
	while (!resToken.IsEmpty()) {
		filename.Replace(resToken," ");
		resToken = strClear.Tokenize("|",curPos);
d1112 1
d1117 1
a1117 1
		int pos1,pos2;
d1119 4
a1122 4
			pos1=filename.Find('[');
			pos2=filename.Find(']');
			if (pos1>-1 && pos2>pos1)
				filename=filename.Left(pos1)+filename.Right(filename.GetLength()-pos2-1);
d1128 6
a1133 17
	//clear dots
	if (!filename.IsEmpty())
	{
		const CString numbers("0123456789");		// numberchars where not to clear dots between
		int maxpos = filename.GetLength()-1;
		for (int ix=0; ix <= maxpos; ix++)
		{
		    if( filename.GetAt(ix) == '.' )
		    {
				//replace dot at beginning and end of filename
		   		if( ix == 0 || ix == maxpos )
				    filename.SetAt(ix, ' ');
				//replace dot only if not between 2 numbers (versions and dates)
			    else if( numbers.Find(filename.GetAt(ix-1)) < 0 || numbers.Find(filename.GetAt(ix+1)) < 0)
				    filename.SetAt(ix, ' ');
		    }
		}
d1136 3
a1138 10
	filename = LeadingCaps(filename);
	//special uppercasing by netwolf and DoubleT
	filename.Replace("Cd","CD");
	filename.Replace("Vcd","VCD");
	filename.Replace("Svcd","SVCD");
	filename.Replace("Dvd","DVD");
	filename.Replace("Divx","DivX");
	filename.Replace("Xvid","XviD");
	filename.Replace("Ac3","AC3");
	filename.Replace("Mp3","MP3");
d1140 19
a1158 29
	filename.Replace("Shared By", "");
	filename.Replace("Shared For", "");
	filename.Replace("Shared Via", "");
	filename.Replace("Shared ", "");
	filename.Replace("Found At", "");
	filename.Replace("Found Via Xxx.", "");	//filedonkey.com special
	filename.Replace("Found Via", "");
	filename.Replace("Link By", "");
	filename.Replace("Linked At", "");
	filename.Replace("Linked By", "");
	filename.Replace("Linked ", "");
	filename.Replace("Powered By", "");
	filename.Replace("-Powered-By-", "");	//eselfilme.de special
	filename.Replace("Powered ", "");
	filename.Replace("Sponsored For", "");
	filename.Replace("Sponsored By", "");
	filename.Replace("Sponsored ", "");

	//reduce doubles
	const CString special(" .,;-+#%&()[]{}");	// repeated chars get reduced to one occurence
	int ix=0;
	while (ix < filename.GetLength()-1)
	{
		int foundpos = special.Find(filename.GetAt(ix));
		if (foundpos >= 0 && foundpos == special.Find(filename.GetAt(ix+1)))
			filename.Delete(ix);
		else
			ix++;
	}
d1171 13
a1189 2


@


1.48
log
@windows server 2003 detection support
@
text
@d229 1
a229 1
    BYTE b = 0;
d549 1
a549 1
	return 0;
d599 1
a599 1
	int pos = 0;
@


1.47
log
@SyruS: added special uppercasing by netwolf and DoubleT to cleanup
@
text
@d500 2
@


1.46
log
@SyruS: tiny update of cleanup
@
text
@a1135 1
	//special cleanup with leading caps
d1137 10
a1146 1
	filename.Replace("Cd","CD");	//netwolf: personal favor; IMO that disc is called CD, not Cd :)
@


1.45
log
@SyruS: customizable cleanup of filenames
@
text
@d1094 7
a1100 7
	CString resToken;
	CString strlink=theApp.glob_prefs->GetFilenameCleanups().MakeLower();
	int curPos=0;
	resToken= strlink.Tokenize("|",curPos);
	while (resToken != "") {
		filename.Replace(resToken,"");
		resToken=strlink.Tokenize("|",curPos);
d1141 4
d1147 1
d1149 1
d1151 2
a1152 1
	filename.Replace("-Powered-By-", "");
d1155 1
@


1.44
log
@One more document extension
@
text
@d1009 171
@


1.43
log
@More document types
@
text
@d305 1
a305 1
		ext==".xml" || ext==".htm" || ext==".html")
@


1.42
log
@documents search and 'NOT' search filter
@
text
@d304 2
a305 1
	if (ext==".doc" || ext==".txt" || ext==".pdf" || ext==".xls")
@


1.41
log
@Added lmule detection, better mldonkey detection and fixed bug 208
@
text
@d304 3
@


1.40
log
@*** empty log message ***
@
text
@a754 8
		// Lord KiRon - not needed any more because version corrected at read packet time
		/*if(uVersion == 0x2B)
		{
			uVersion = 0x22;
		}*/
		cbuffer.Format(_T("0.%02X"),uVersion);
		break;

d756 2
a757 3
		cbuffer.Format(_T("0.%02X"),uVersion);
		break;
	case SO_SHAREAZA://MTSHAZ
d898 4
a901 1
	case SO_SHAREAZA://MTSHAZ
d938 2
a939 1
	case SO_SHAREAZA://MTSHAZ
@


1.39
log
@code cleanup
@
text
@d275 5
a279 2
	if (ext==".mpc" || ext==".mp4" || ext==".aac" || ext==".ape" || ext==".mp3" || ext==".flac" ||
		ext==".mp2" || ext==".wav" || ext==".au" || ext==".ogg" || ext==".wma") return GetResString(IDS_SEARCH_AUDIO);
d281 4
a284 2
	if (ext==".jpg" || ext==".jpeg" || ext==".bmp" || ext==".gif" || ext==".tif" ||
		ext==".png") return GetResString(IDS_SEARCH_PICS);
d286 5
a290 2
	if (ext==".avi" || ext==".mpg" || ext==".mpeg" || ext==".ram" || ext==".rm" || ext==".asf" ||
		ext==".vob" || ext==".divx" || ext==".vivo" || ext==".ogm" || ext==".mov" || ext==".wmv" || ext==".rmvb") return GetResString(IDS_SEARCH_VIDEO);
d292 3
a294 1
	if (ext==".gz" || ext==".zip" || ext==".ace" || ext==".rar") return GetResString(IDS_SEARCH_ARC);
d296 2
a297 1
	if (ext==".exe" || ext==".com") return GetResString(IDS_SEARCH_PRG);
d300 2
a301 1
		ext==".img" || ext==".bwa" || ext==".bwi" || ext==".bws" || ext==".bwt" || ext==".mds" || ext==".mdf")
@


1.38
log
@shareaza identification.
@
text
@d157 1
a157 1
void ShellOpenFile(CString name){ 
d269 5
a273 4
CString GetFiletypeByName(CString infile) {
	CString ext;

	if (infile.ReverseFind('.')==-1) return GetResString(IDS_SEARCH_ANY);
a274 2
	ext= infile.Right(infile.GetLength()-infile.ReverseFind('.')).MakeLower() ;
	
d793 1
a793 1
CString StringLimit(CString in,uint16 length){
@


1.37
log
@Fixed a bug with not being able to set some folders as output folder (0000225)   (it was not only drives root but some "special" folders too). .
also fixed few COM/Shell related memory leaks.
@
text
@d751 1
d755 3
d896 3
d933 1
@


1.36
log
@Corrective solution for 0 size file proble in addition ti Ultra's "Preventive solution"
@
text
@d978 1
a978 1
	lpID = SHBrowseForFolderA(&bi);
@


1.35
log
@Upgrade to 0.28a
@
text
@d66 10
a75 1
		sprintf(buffer, "%.0f %s",(float)count,GetResString(IDS_BYTES).GetBuffer(0));
@


1.34
log
@Upgrade to webserver official 0.28a
@
text
@d274 1
a274 1
		ext==".vob" || ext==".divx" || ext==".vivo" || ext==".ogm" || ext==".mov" || ext==".wmv") return GetResString(IDS_SEARCH_VIDEO);
d300 2
d707 12
a718 11
	// Convert hash to hexadecimal text and add it to the URL
	urlpattern.Replace("#hashid", EncodeBase16(file->GetFileHash(), 16));

	// Add file size to the URL
	CString temp;
	temp.Format("%u",file->GetFileSize());
	urlpattern.Replace("#filesize", temp);

	// add filename to the url
	urlpattern.Replace("#filename",URLEncode(file->GetFileName()));

@


1.33
log
@More try/catch according to crash dumps
@
text
@d778 6
@


1.32
log
@last bugfixes!
@
text
@d311 1
a311 1

d338 1
d344 1
d362 1
d368 1
d387 1
d391 1
d444 1
a444 1

d662 1
d699 1
d704 1
d718 1
@


1.32.2.1
log
@27a partial merge
@
text
@d488 4
a491 2
	BOOL (WINAPI *pGetDiskFreeSpaceEx)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
	(FARPROC&)pGetDiskFreeSpaceEx = GetProcAddress(GetModuleHandle("kernel32.dll"), "GetDiskFreeSpaceExA");
d496 1
a496 1
		pGetDiskFreeSpaceEx(pDirectory, &nFreeDiskSpace, &dummy, &dummy);
a761 3
	case SO_LMULE:
		cbuffer.Format(_T("0.%02X"),uVersion);
		break;
a875 3
	case SO_LMULE:
		nameString	=	_T("lMule");
		break;
a899 1
	case SO_LMULE:
a962 4

void MakeFoldername(CString& path){
	if (path.GetLength()>0) if (path.Right(1)=='\\') path=path.Left(path.GetLength()-1);
}
@


1.32.2.2
log
@27c
@
text
@d694 11
a704 12
	if (file!=NULL) {
	    // Convert hash to hexadecimal text and add it to the URL
	    urlpattern.Replace("#hashid", EncodeBase16(file->GetFileHash(), 16));
    
	    // Add file size to the URL
	    CString temp;
	    temp.Format("%u",file->GetFileSize());
	    urlpattern.Replace("#filesize", temp);
    
	    // add filename to the url
	    urlpattern.Replace("#filename",URLEncode(file->GetFileName()));
	}
@


1.31
log
@Separators on Web Services [Sp4rK]
@
text
@d882 1
d886 1
a886 1
        if(client->PlusVersion()>0 && client->PlusVersion()<0x2600)	//Cax2 - second check - don't display the 38e (pre v1?) mods
d901 6
a906 2
	        buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
				(const char*)GetClientVersionString(client->GetClientSoft(),client->GetMuleVersion()));
@


1.30
log
@Another leak fix
@
text
@d654 2
a655 1
void UpdateURLMenu(CMenu &menu,int &counter){
d663 6
a668 3
	if (readFile!=NULL) {
		while (!feof(readFile)) {
			if (fgets(buffer,lenBuf,readFile)==0) break;
d674 14
a687 6
			
			int pos=sbuffer.Find(',');
			if (pos>0) {
				counter++;
				menu.AppendMenu(MF_STRING,MP_WEBURL+(counter-1), sbuffer.Left(pos).Trim() );
				theApp.webservices.Add(sbuffer.Right(sbuffer.GetLength()-pos-1).Trim() );
@


1.29
log
@*** empty log message ***
@
text
@d207 2
a208 1
	free(buff2);
@


1.28
log
@BUGFIX: 0000117
@
text
@d441 1
a441 1
WORD DetectWinVersion()
d445 1
d460 1
@


1.27
log
@bugfix: plus v38e & hybrid not showing in details panel
@
text
@d856 1
a856 1
		nameString	=	_T("Old MLDonkey");
d859 1
a859 1
		nameString	=	_T("Old eMule");
@


1.26
log
@partial bug 5 bugfix: plus sorted & named correctly in download list
@
text
@d870 1
a870 1
        if(client->PlusVersion()>0) 
@


1.25
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d870 12
d885 2
a886 7
            CString plusver("");
            if(client->PlusVersion()>0) {
                buffer.Format("eMulePlus v%x.%02x", client->PlusVersion()>>8, client->PlusVersion() & 0xFF);
            } else {
		        buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
                    (const char*)GetClientVersionString(client->GetClientSoft(),client->GetMuleVersion()));
            }
@


1.24
log
@restore Plus version recognition
@
text
@a650 2

/*
d678 1
a678 1
*/
d892 44
@


1.23
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d874 9
a882 2
		buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
            (const char*)GetClientVersionString(client->GetClientSoft(),client->GetMuleVersion()));
@


1.22
log
@version displaying in messages, fixes in chunk selection
@
text
@d21 1
a21 1
#include "Winsock2.h"
@


1.21
log
@minor updates & bugfixes
@
text
@d866 21
@


1.21.2.1
log
@v1a upgrade
@
text
@a865 21

CString GetClientNameAndVersionString(CUpDownClient *client) {
	CString buffer;
	switch(client->GetClientSoft())
	{
	case SO_EMULE:
	case SO_OLDEMULE:
	case SO_CDONKEY:
		buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
            (const char*)GetClientVersionString(client->GetClientSoft(),client->GetMuleVersion()));
		break;
	case SO_UNKNOWN:
		buffer.Format("???");
		break;
	default:
		buffer.Format("%s v%s",(const char*)GetClientNameString(client->GetClientSoft()),
            (const char*)GetClientVersionString(client->GetClientSoft(),client->GetVersion()));
		break;
	}
    return buffer;
}
@


1.20
log
@Last BUGFIXES (FileComments/SharedFiles Columns)
@
text
@d752 1
a752 1
	return cbuffer;
@


1.19
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d852 1
a852 1
		nameString	=	_T("eDonkeyHybrid");
@


1.18
log
@*** empty log message ***
@
text
@d23 7
@


1.17
log
@*** empty log message ***
@
text
@d21 1
d696 3
d717 5
a721 1
		dVersion	=	double(uVersion-1000);
@


1.16
log
@*** empty log message ***
@
text
@d698 2
a699 1
		if(uVersion == 0x2B)
d702 1
a702 1
		}
d727 2
a728 1
		if(uVersion == 0x2B)
d731 1
a731 1
		}
@


1.15
log
@*** empty log message ***
@
text
@d712 2
a713 1
		if ( uVersion )
d715 1
a715 5
			dVersion	=	double(uVersion-1000);
			if (dVersion > 100. )
			{
				dVersion /= 10.;
			}
@


1.14
log
@*** empty log message ***
@
text
@d712 1
a712 2
		dVersion	=	double(uVersion-1000);
		if (dVersion > 100. )
d714 5
a718 1
			dVersion /= 10.;
@


1.13
log
@*** empty log message ***
@
text
@d694 1
d708 10
a717 1
		cbuffer.Format(_T("%i"),uVersion - 1000);
@


1.12
log
@*** empty log message ***
@
text
@d810 29
@


1.11
log
@*** empty log message ***
@
text
@d729 1
a729 1
CString GetStatusString(eQState State)
d765 1
a765 1
		stateString	=	_T("Problematic"); // need some IDS_ for this one
d772 38
a809 1
}@


1.10
log
@Final client statistics changes
@
text
@d726 46
@


1.9
log
@Further Statistics changes
@
text
@d697 4
d716 4
@


1.8
log
@more 26b merges
@
text
@d689 30
@


1.7
log
@Fix on fix :)
@
text
@d673 1
a673 1
void RunURL(CKnownFile* file, CString urlpattern)
@


1.6
log
@*** empty log message ***
@
text
@d52 4
a55 1
CString CastItoXBytes(uint64 count, char *pBuffer,size_t size){
d67 5
a71 2
   if(pBuffer && size)
	   strncpy(pBuffer, buffer,size);
d73 4
d79 4
a82 1
CString CastItoIShort(uint64 count, char *pBuffer,size_t size){
d94 5
a98 2
   if(pBuffer && size)
	   strncpy(pBuffer, buffer,size);
d100 4
d106 4
a109 1
CString CastSecondsToHM(sint32 count, char *pBuffer,size_t size){
d121 5
a125 2
   if(pBuffer && size)
	   strncpy(pBuffer, buffer,size);
d127 4
@


1.5
log
@Hotfixes.
@
text
@d52 1
a52 1
CString CastItoXBytes(uint64 count, char *pBuffer){
d64 2
a65 2
   if(pBuffer)
	   strcpy(pBuffer, buffer);
d69 1
a69 1
CString CastItoIShort(uint64 count, char *pBuffer){
d81 2
a82 2
   if(pBuffer)
	   strcpy(pBuffer, buffer);
d86 1
a86 1
CString CastSecondsToHM(sint32 count, char *pBuffer){
d98 2
a99 2
   if(pBuffer)
	   strcpy(pBuffer, buffer);
@


1.4
log
@.26b port
@
text
@d52 2
a53 2
CString CastItoXBytes(uint64 count){
	CString buffer;
d55 1
a55 1
		buffer.Format("%.0f %s",(float)count,GetResString(IDS_BYTES));
d57 1
a57 1
		buffer.Format("%.0f %s",(float)count/1024,GetResString(IDS_KBYTES));
d59 1
a59 1
		buffer.Format("%.2f %s",(float)count/1048576,GetResString(IDS_MBYTES));
d61 1
a61 1
		buffer.Format("%.2f %s",(float)count/1073741824,GetResString(IDS_GBYTES));
d63 4
a66 2
		buffer.Format("%.3f %s",(float)count/1099511627776,GetResString(IDS_TBYTES));
	return buffer;
d69 2
a70 2
CString CastItoIShort(uint64 count){
	CString output;
d72 1
a72 1
		output.Format("%i",count);
d74 1
a74 1
		output.Format("%.0f%s",(float)count/1000, GetResString(IDS_KILO));
d76 1
a76 1
		output.Format("%.2f%s",(float)count/1000000, GetResString(IDS_MEGA));
d78 1
a78 1
		output.Format("%.2f%s",(float)count/1000000000, GetResString(IDS_GIGA));
d80 4
a83 2
		output.Format("%.2f%s",(float)count/1000000000000, GetResString(IDS_TERRA));
	return output;
d86 2
a87 2
CString CastSecondsToHM(sint32 count){
	CString buffer;
d89 1
a89 1
		buffer = "?"; 
d91 1
a91 1
		buffer.Format("%i %s",count,GetResString(IDS_SECS)); 
d93 1
a93 1
		buffer.Format("%i:%s %s",count/60,LeadingZero(count-(count/60)*60),GetResString(IDS_MINS));
d95 1
a95 1
		buffer.Format("%i:%s %s",count/3600,LeadingZero((count-(count/3600)*3600)/60),GetResString(IDS_HOURS));
d97 4
a100 2
		buffer.Format("%i %s %i %s",count/86400,GetResString(IDS_DAYS),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS)); 
	return buffer;
@


1.3
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d52 2
a53 1
void CastItoXBytes(uint64 count,char* output){
d55 1
a55 1
		sprintf(output,"%.0f %s",(float)count,GetResString(IDS_BYTES));
d57 1
a57 1
		sprintf(output,"%.0f %s",(float)count/1024,GetResString(IDS_KBYTES));
d59 1
a59 1
		sprintf(output,"%.2f %s",(float)count/1048576,GetResString(IDS_MBYTES));
d61 1
a61 1
		sprintf(output,"%.2f %s",(float)count/1073741824,GetResString(IDS_GBYTES));
d63 2
a64 1
		sprintf(output,"%.3f %s",(float)count/1099511627776,GetResString(IDS_TBYTES));
d82 2
a83 1
void CastSecondsToHM(sint32 count,char* output){ 
d85 1
a85 1
      sprintf(output,"?"); 
d87 1
a87 1
	   sprintf(output,"%i %s",count,GetResString(IDS_SECS)); 
d89 1
a89 1
	   sprintf(output,"%i:%s %s",count/60,LeadingZero(count-(count/60)*60),GetResString(IDS_MINS));
d91 1
a91 1
	   sprintf(output,"%i:%s %s",count/3600,LeadingZero((count-(count/3600)*3600)/60),GetResString(IDS_HOURS));
d93 2
a94 1
	   sprintf(output,"%i %s %i %s",count/86400,GetResString(IDS_DAYS),(count-(count/86400)*86400)/3600,GetResString(IDS_HOURS)); 
@


1.2
log
@update to .25b codebase
@
text
@d22 30
d62 1
a62 1
		sprintf(output,"%.3f %s",(float)count/1073741824,GetResString(IDS_TBYTES));
d225 1
a225 1
		ext==".vob" || ext==".divx" || ext==".vivo" || ext==".ogm" || ext==".mov") return GetResString(IDS_SEARCH_VIDEO);
d500 149
a648 1
//end rate File//@


1.2.4.1
log
@initial upgrade to .26
@
text
@a21 30
// Base chars for encode an decode functions
static byte base16Chars[17] = "0123456789ABCDEF";
static byte base32Chars[33] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
#define BASE16_LOOKUP_MAX 23
static byte base16Lookup[BASE16_LOOKUP_MAX][2] = {
    { '0', 0x0 },
    { '1', 0x1 },
    { '2', 0x2 },
    { '3', 0x3 },
    { '4', 0x4 },
    { '5', 0x5 },
    { '6', 0x6 },
    { '7', 0x7 },
    { '8', 0x8 },
    { '9', 0x9 },
	{ ':', 0x9 },
    { ';', 0x9 },
    { '<', 0x9 },
    { '=', 0x9 },
    { '>', 0x9 },
    { '?', 0x9 },
    { '@@', 0x9 },
    { 'A', 0xA },
    { 'B', 0xB },
    { 'C', 0xC },
    { 'D', 0xD },
    { 'E', 0xE },
    { 'F', 0xF }
};

d32 1
a32 1
		sprintf(output,"%.3f %s",(float)count/1099511627776,GetResString(IDS_TBYTES));
d195 1
a195 1
		ext==".vob" || ext==".divx" || ext==".vivo" || ext==".ogm" || ext==".mov" || ext==".wmv") return GetResString(IDS_SEARCH_VIDEO);
a230 1

d470 1
a470 150
//end rate File//
// Returns a BASE32 encoded byte array
//
// [In]
//   buffer: Pointer to byte array
//   bufLen: Lenght of buffer array
//
// [Return]
//   CString object with BASE32 encoded byte array
CString EncodeBase32(const unsigned char* buffer, unsigned int bufLen)
{
	CString Base32Buff;
    
	unsigned int i, index;
    unsigned char word;
	int pos = 0;

    for(i = 0, index = 0; i < bufLen;) {

		// Is the current word going to span a byte boundary?
        if (index > 3) {
            word = (buffer[i] & (0xFF >> index));
            index = (index + 5) % 8;
            word <<= index;
            if (i < bufLen - 1)
                word |= buffer[i + 1] >> (8 - index);

            i++;
        } else {
            word = (buffer[i] >> (8 - (index + 5))) & 0x1F;
            index = (index + 5) % 8;
            if (index == 0)
               i++;
        }

		Base32Buff += (char) base32Chars[word];
    }

    return Base32Buff;
}

// Returns a BASE16 encoded byte array
//
// [In]
//   buffer: Pointer to byte array
//   bufLen: Lenght of buffer array
//
// [Return]
//   CString object with BASE16 encoded byte array
CString EncodeBase16(const unsigned char* buffer, unsigned int bufLen)
{
	CString Base16Buff;

	for(unsigned int i = 0; i < bufLen; i++) {
		Base16Buff += base16Chars[buffer[i] >> 4];
		Base16Buff += base16Chars[buffer[i] & 0xf];
	}

    return Base16Buff;
}

// Decodes a BASE16 string into a byte array
//
// [In]
//   base16Buffer: String containing BASE16
//   base16BufLen: Lenght BASE16 coded string's length
//
// [Out]
//   buffer: byte array containing decoded string
void DecodeBase16(const char *base16Buffer, unsigned int base16BufLen, byte *buffer)
{
    memset(buffer, 0, DecodeLengthBase16(base16BufLen));
  
    for(unsigned int i = 0; i < base16BufLen; i++) {
		int lookup = toupper(base16Buffer[i]) - '0';

        // Check to make sure that the given word falls inside a valid range
		byte word = 0;
        
		if ( lookup < 0 || lookup >= BASE16_LOOKUP_MAX)
           word = 0xFF;
        else
           word = base16Lookup[lookup][1];

		if(i % 2 == 0) {
			buffer[i/2] = word << 4;
		} else {
			buffer[(i-1)/2] |= word;
		}
	}
}

// Calculates length to decode from BASE16
//
// [In]
//   base16Length: Actual length of BASE16 string
//
// [Return]
//   New length of byte array decoded
int	DecodeLengthBase16(int base16Length)
{
	return base16Length / 2;
}


/*
void UpdateURLMenu(CMenu &menu,int &counter){
	counter=0;
	theApp.webservices.RemoveAll();
	CString name,url,sbuffer;
	char buffer[1024];
	int lenBuf = 1024;

	FILE* readFile= fopen(CString(theApp.glob_prefs->GetAppDir())+"webservices.dat", "r");
	if (readFile!=NULL) {
		while (!feof(readFile)) {
			if (fgets(buffer,lenBuf,readFile)==0) break;
			sbuffer=buffer;
			
			// ignore comments & too short lines
			if (sbuffer.GetAt(0) == '#' || sbuffer.GetAt(0) == '/' || sbuffer.GetLength()<5)
				continue;
			
			int pos=sbuffer.Find(',');
			if (pos>0) {
				counter++;
				menu.AppendMenu(MF_STRING,MP_WEBURL+(counter-1), sbuffer.Left(pos).Trim() );
				theApp.webservices.Add(sbuffer.Right(sbuffer.GetLength()-pos-1).Trim() );
			}
		}
		fclose(readFile);
	}
}
*/
void RunURL(CKnownFile* file, CString urlpattern)
{
	// Convert hash to hexadecimal text and add it to the URL
	urlpattern.Replace("#hashid", EncodeBase16(file->GetFileHash(), 16));

	// Add file size to the URL
	CString temp;
	temp.Format("%u",file->GetFileSize());
	urlpattern.Replace("#filesize", temp);

	// add filename to the url
	urlpattern.Replace("#filename",URLEncode(file->GetFileName()));

	// Open URL
	ShellExecute(NULL, NULL, urlpattern, NULL, theApp.glob_prefs->GetAppDir(), SW_SHOWDEFAULT);
}
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d38 1
a38 1
		output.Format("%.0f",count);
d188 1
a188 1
	if (ext==".mpc" || ext==".mp4" || ext==".aac" || ext==".ape" || ext==".mp3" || 
d194 1
a194 1
	if (ext==".avi" || ext==".mpg" || ext==".mpeg" || ext==".ram" || ext==".rm" ||
d197 1
a197 1
	if (ext==".zip" || ext==".ace" || ext==".rar") return GetResString(IDS_SEARCH_ARC);
d201 3
a203 2
	if (ext==".ccd"|| ext==".sub" || ext==".cue" || ext==".bin" || ext==".iso" ||
		ext==".nrg" || ext==".ccd" || ext==".img") return GetResString(IDS_SEARCH_CDIMG);
d225 12
a236 1
bool Ask4RegFix(bool checkOnly){
d249 1
a249 1
		if (MessageBox(0,GetResString(IDS_ASSIGNED2K),GetResString(IDS_ED2KLINKFIX),MB_ICONQUESTION|MB_YESNO) == IDYES){
d260 44
@

