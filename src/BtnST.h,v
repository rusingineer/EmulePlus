head	1.9;
access;
symbols
	PublicRelease_1_2e:1.9
	Interim_Release_1-2e_RC1:1.9
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.7
	Interim_Release_1-2c_RC1:1.7
	Interim_Release_1-2c_beta1:1.7
	PublicRelease_1_2b:1.7
	Interim_Release_1-2b_RC1:1.6
	PublicRelease_1_2a:1.6
	Interim_Release_1-2a_RC1:1.6
	Interim_Release_1-2a_beta2:1.6
	Interim_Release_1-2a_beta1:1.6
	PublicRelease_1_2:1.6
	Interim_Release_1-2_RC1:1.6
	Interim_Release_1-2_beta1:1.6
	PublicRelease_1_1g:1.6
	Interim_Release_1-1g_RC3:1.6
	Interim_Release_1-1g_RC2:1.6
	Interim_Release_1-1g_RC1:1.6
	Interim_Release_1-1g_beta2:1.6
	Interim_Release_1-1g_beta1:1.6
	PublicRelease_1_1f:1.6
	Interim_Release_1-1f_RC1:1.6
	PublicRelease_1_1e:1.6
	Interim_Release_1-1e_RC2:1.6
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.3
	Interim_Release_1l_RC1:1.3
	Interim_Release_1l_beta2:1.3
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.3
	Interim_Release_1k_RC4:1.3
	Interim_1k_RC3:1.3
	Interim_1k_RC2:1.3
	Interim_Release_1k_RC1:1.3
	Interim_Release_1k_beta5:1.3
	Intrerim_Release_1k_beta4:1.3
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.14
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.2
	threaded_downloadqueue:1.2.0.12
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.10
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.8
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.9
date	2009.01.08.05.16.24;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2008.12.08.13.28.22;	author kush_eplus;	state Exp;
branches;
next	1.7;

1.7
date	2007.02.04.10.49.09;	author kush_eplus;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.01.16.02.05;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2005.06.27.05.20.54;	author eklmn;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.05.19.58.23;	author katsyonak;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.18.15.41.48;	author katsyonak;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.24.22.07.45;	author maverick65;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.17.59.09;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Removed useless one byte alignment for structures; Formatting.
@
text
@//
//	Class:		CButtonST
//
//	Compiler:	Visual C++
//	Tested on:	Visual C++ 5.0
//				Visual C++ 6.0
//
//	Version:	See GetVersionC() or GetVersionI()
//
//	Created:	xx/xxxx/1998
//	Updated:	03/March/2003
//
//	Author:		Davide Calabro'		davide_calabro@@yahoo.com
//									http://www.softechsoftware.it
//
//	Note:		Code for the PreSubclassWindow and OnSetStyle functions
//				has been taken from the COddButton class
//				published by Paolo Messina and Jerzy Kaczorowski
//
//	Disclaimer
//	----------
//	THIS SOFTWARE AND THE ACCOMPANYING FILES ARE DISTRIBUTED "AS IS" AND WITHOUT
//	ANY WARRANTIES WHETHER EXPRESSED OR IMPLIED. NO REPONSIBILITIES FOR POSSIBLE
//	DAMAGES OR EVEN FUNCTIONALITY CAN BE TAKEN. THE USER MUST ASSUME THE ENTIRE
//	RISK OF USING THIS SOFTWARE.
//
//	Terms of use
//	------------
//	THIS SOFTWARE IS FREE FOR PERSONAL USE OR FREEWARE APPLICATIONS.
//	IF YOU USE THIS SOFTWARE IN COMMERCIAL OR SHAREWARE APPLICATIONS YOU
//	ARE GENTLY ASKED TO DONATE 5$ (FIVE U.S. DOLLARS) TO THE AUTHOR:
//
//		Davide Calabro'
//		P.O. Box 65
//		21019 Somma Lombardo (VA)
//		Italy
//
#pragma once

// Uncomment the following 2 lines to enable support for BCMenu class
//#define	BTNST_USE_BCMENU
//#include "BCMenu.h"

// Uncomment the following line to enable support for sound effects
//#define	BTNST_USE_SOUND

// Return values
#ifndef	BTNST_OK
#define	BTNST_OK						0
#endif
#ifndef	BTNST_INVALIDRESOURCE
#define	BTNST_INVALIDRESOURCE			1
#endif
#ifndef	BTNST_FAILEDMASK
#define	BTNST_FAILEDMASK				2
#endif
#ifndef	BTNST_INVALIDINDEX
#define	BTNST_INVALIDINDEX				3
#endif
#ifndef	BTNST_INVALIDALIGN
#define	BTNST_INVALIDALIGN				4
#endif
#ifndef	BTNST_BADPARAM
#define	BTNST_BADPARAM					5
#endif
#ifndef	BTNST_INVALIDPRESSEDSTYLE
#define	BTNST_INVALIDPRESSEDSTYLE		6
#endif

// Dummy identifier for grayscale icon
#ifndef	BTNST_AUTO_GRAY
#define	BTNST_AUTO_GRAY					(HICON)(0xffffffff - 1L)
#endif
// Dummy identifier for 15% darker icon
#ifndef	BTNST_AUTO_DARKER
#define	BTNST_AUTO_DARKER				(HICON)(0xffffffff - 2L)
#endif

class CButtonST : public CButton
{
public:
	CButtonST();
	virtual ~CButtonST();

	enum	{	ST_ALIGN_HORIZ	= 0,			// Icon/bitmap on the left, text on the right
				ST_ALIGN_VERT,					// Icon/bitmap on the top, text on the bottom
				ST_ALIGN_HORIZ_RIGHT,			// Icon/bitmap on the right, text on the left
				ST_ALIGN_OVERLAP				// Icon/bitmap on the same space as text
	};

	enum	{	BTNST_COLOR_BK_IN	= 0,		// Background color when mouse is INside
				BTNST_COLOR_FG_IN,				// Text color when mouse is INside
				BTNST_COLOR_BK_OUT,				// Background color when mouse is OUTside
				BTNST_COLOR_FG_OUT,				// Text color when mouse is OUTside
				BTNST_COLOR_BK_FOCUS,			// Background color when the button is focused
				BTNST_COLOR_FG_FOCUS,			// Text color when the button is focused

				BTNST_MAX_COLORS
	};

	enum	{	BTNST_PRESSED_LEFTRIGHT = 0,	// Pressed style from left to right (as usual)
				BTNST_PRESSED_TOPBOTTOM			// Pressed style from top to bottom
	};

	// ClassWizard generated virtual function overrides
public:
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
protected:
	virtual void PreSubclassWindow();

public:
	DWORD SetDefaultColors(BOOL bRepaint = TRUE);
	DWORD SetColor(BYTE byColorIndex, COLORREF crColor, BOOL bRepaint = TRUE);
	DWORD GetColor(BYTE byColorIndex, COLORREF* crpColor);
	DWORD OffsetColor(BYTE byColorIndex, short shOffset, BOOL bRepaint = TRUE);

	DWORD SetCheck(int nCheck, BOOL bRepaint = TRUE);
	int GetCheck();

	DWORD SetURL(LPCTSTR lpszURL = NULL);
	void DrawTransparent(BOOL bRepaint = FALSE);
	DWORD SetBk(CDC* pDC);

	BOOL GetDefault();
	DWORD SetAlwaysTrack(BOOL bAlwaysTrack = TRUE);

	void SetTooltipText(int nText, BOOL bActivate = TRUE);
	void SetTooltipText(LPCTSTR lpszText, BOOL bActivate = TRUE);
	void ActivateTooltip(BOOL bEnable = TRUE);
	DWORD EnableBalloonTooltip();

	DWORD SetBtnCursor(int nCursorId = NULL, BOOL bRepaint = TRUE);

	DWORD SetFlat(BOOL bFlat = TRUE, BOOL bRepaint = TRUE);
	DWORD SetAlign(BYTE byAlign, BOOL bRepaint = TRUE);
	DWORD SetPressedStyle(BYTE byStyle, BOOL bRepaint = TRUE);
	DWORD SetPushLike(BOOL bPushLike = TRUE, BOOL bRepaint = TRUE);

	DWORD DrawBorder(BOOL bDrawBorder = TRUE, BOOL bRepaint = TRUE);
	DWORD DrawFlatFocus(BOOL bDrawFlatFocus, BOOL bRepaint = TRUE);

	DWORD SetIcon(int nIconIn, int nCxDesiredIn, int nCyDesiredIn, int nIconOut = NULL, int nCxDesiredOut = 0, int nCyDesiredOut = 0);
	DWORD SetIcon(int nIconIn, int nIconOut = NULL);
	DWORD SetIcon(HICON hIconIn, HICON hIconOut = NULL);

	DWORD SetBitmaps(int nBitmapIn, COLORREF crTransColorIn, int nBitmapOut = NULL, COLORREF crTransColorOut = 0);
	DWORD SetBitmaps(HBITMAP hBitmapIn, COLORREF crTransColorIn, HBITMAP hBitmapOut = NULL, COLORREF crTransColorOut = 0);

	void SizeToContent();

#ifdef	BTNST_USE_BCMENU
	DWORD SetMenu(UINT nMenu, HWND hParentWnd, BOOL bWinXPStyle = TRUE, UINT nToolbarID = NULL, CSize sizeToolbarIcon = CSize(16, 16), COLORREF crToolbarBk = RGB(255, 0, 255), BOOL bRepaint = TRUE);
#else
	DWORD SetMenu(UINT nMenu, HWND hParentWnd, BOOL bRepaint = TRUE);
#endif
	DWORD SetMenuCallback(HWND hWnd, UINT nMessage, LPARAM lParam = 0);

#ifdef	BTNST_USE_SOUND
	DWORD SetSound(LPCTSTR lpszSound, HMODULE hMod = NULL, BOOL bPlayOnClick = FALSE, BOOL bPlayAsync = TRUE);
#endif

	static short GetVersionI()		{return 39;}
	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("3.9");}

	BOOL	m_bShowDisabledBitmap;
	POINT	m_ptImageOrg;
	POINT	m_ptPressedOffset;

protected:
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnSysColorChange();
	afx_msg BOOL OnClicked();
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnCancelMode();
	afx_msg UINT OnGetDlgCode();

#ifdef	BTNST_USE_BCMENU
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
#endif

	afx_msg HBRUSH CtlColor(CDC* pDC, UINT nCtlColor);
	HICON CreateGrayscaleIcon(HICON hIcon);
	HICON CreateDarkerIcon(HICON hIcon);
	HBITMAP CreateGrayscaleBitmap(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTrans);
	HBITMAP CreateDarkerBitmap(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTrans);
	COLORREF DarkenColor(COLORREF crColor, double dFactor);
	virtual DWORD OnDrawBackground(CDC* pDC, CRect* pRect);
	virtual DWORD OnDrawBorder(CDC* pDC, CRect* pRect);

	BOOL		m_bIsFlat;			// Is a flat button?
	BOOL		m_bMouseOnButton;	// Is mouse over the button?
	BOOL		m_bDrawTransparent;	// Draw transparent?
	BOOL		m_bIsPressed;		// Is button pressed?
	BOOL		m_bIsFocused;		// Is button focused?
	BOOL		m_bIsDisabled;		// Is button disabled?
	BOOL		m_bIsDefault;		// Is default button?
	BOOL		m_bIsCheckBox;		// Is the button a checkbox?
	BOOL		m_bIsPushLike;		// Is a PushLike button?
	BYTE		m_byAlign;			// Align mode
	BOOL		m_bDrawBorder;		// Draw border?
	BOOL		m_bDrawFlatFocus;	// Draw focus rectangle for flat button?
	COLORREF	m_crColors[BTNST_MAX_COLORS];	// Colors to be used
	HWND		m_hParentWndMenu;	// Handle to window for menu selection
	BOOL		m_bMenuDisplayed;	// Is menu displayed ?

#ifdef	BTNST_USE_BCMENU
	BCMenu		m_menuPopup;		// BCMenu class instance
#else
	HMENU		m_hMenu;			// Handle to associated menu
#endif
	CDC			m_dcBk;
	CBitmap		m_bmpBk;

private:
	LRESULT OnSetCheck(WPARAM wParam, LPARAM lParam);
	LRESULT OnGetCheck(WPARAM wParam, LPARAM lParam);
	LRESULT OnSetStyle(WPARAM wParam, LPARAM lParam);
	LRESULT OnMouseLeave(WPARAM wParam, LPARAM lParam);

	void CancelHover();
	void FreeResources(BOOL bCheckForNULL = TRUE);
	void PrepareImageRect(BOOL bHasTitle, RECT* rpItem, CRect* rpTitle, BOOL bIsPressed, DWORD dwWidth, DWORD dwHeight, CRect* rpImage);
	HBITMAP CreateBitmapMask(HBITMAP hSourceBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTransColor);
	virtual void DrawTheIcon(CDC* pDC, BOOL bHasTitle, RECT* rpItem, CRect* rpCaption, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void DrawTheBitmap(CDC* pDC, BOOL bHasTitle, RECT* rpItem, CRect* rpCaption, BOOL bIsPressed, BOOL bIsDisabled);
	virtual void DrawTheText(CDC* pDC, LPCTSTR lpszText, RECT* rpItem, CRect* rpCaption, BOOL bIsPressed, BOOL bIsDisabled);
	void PaintBk(CDC* pDC);

	void InitToolTip();

	HCURSOR		m_hCursor;			// Handle to cursor
	CToolTipCtrl m_ToolTip;			// Tooltip

	CBitmap*	m_pbmpOldBk;

	BOOL		m_bAlwaysTrack;		// Always hilight button?
	int			m_nCheck;			// Current value for checkbox
	UINT		m_nTypeStyle;		// Button style
	DWORD		m_dwToolTipStyle;	// Style of tooltip control

	TCHAR		m_szURL[_MAX_PATH];	// URL to open when clicked

	typedef struct _STRUCT_ICONS
	{
		HICON		hIcon;			// Handle to icon
		DWORD		dwWidth;		// Width of icon
		DWORD		dwHeight;		// Height of icon
	} STRUCT_ICONS;

	typedef struct _STRUCT_BITMAPS
	{
		HBITMAP		hBitmap;		// Handle to bitmap
		DWORD		dwWidth;		// Width of bitmap
		DWORD		dwHeight;		// Height of bitmap
		HBITMAP		hMask;			// Handle to mask bitmap
		COLORREF	crTransparent;	// Transparent color
	} STRUCT_BITMAPS;

	typedef struct _STRUCT_CALLBACK
	{
		HWND		hWnd;			// Handle to window
		UINT		nMessage;		// Message identifier
		WPARAM		wParam;
		LPARAM		lParam;
	} STRUCT_CALLBACK;

	STRUCT_ICONS	m_csIcons[2];
	STRUCT_BITMAPS	m_csBitmaps[2];

	STRUCT_CALLBACK	m_csCallbacks;

#ifdef	BTNST_USE_SOUND
	typedef struct _STRUCT_SOUND
	{
		TCHAR		szSound[_MAX_PATH];
		LPCTSTR		lpszSound;
		HMODULE		hMod;
		DWORD		dwFlags;
	} STRUCT_SOUND;

	STRUCT_SOUND	m_csSounds[2];	// Index 0 = Over	1 = Clicked
#endif

	DECLARE_MESSAGE_MAP()
};
@


1.8
log
@Make base class destructors virtual.
@
text
@d38 1
a38 2
#ifndef _BTNST_H
#define _BTNST_H
a46 4
#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

d82 1
a82 1
    CButtonST();
d85 1
a85 1
    enum	{	ST_ALIGN_HORIZ	= 0,			// Icon/bitmap on the left, text on the right
d89 1
a89 1
			};
d99 1
a99 1
			};
d101 1
a101 1
    enum	{	BTNST_PRESSED_LEFTRIGHT = 0,	// Pressed style from left to right (as usual)
d103 1
a103 1
			};
d106 1
a106 2
    //{{AFX_VIRTUAL(CButtonST)
	public:
d109 1
a109 1
	protected:
a110 1
	//}}AFX_VIRTUAL
a170 1
    //{{AFX_MSG(CButtonST)
a179 1
	//}}AFX_MSG
a247 1
#pragma pack(1)
a253 1
#pragma pack()
a254 1
#pragma pack(1)
a262 1
#pragma pack()
a263 1
#pragma pack(1)
a270 1
#pragma pack()
a277 1
#pragma pack(1)
a284 1
#pragma pack()
a290 5

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif
@


1.7
log
@crash on visual style change {theirix}
@
text
@d88 1
a88 1
	~CButtonST();
@


1.6
log
@Rolled back last changes not to increase number of GDI resources.
@
text
@d225 2
a247 2
	CDC			m_dcBk;
	CBitmap		m_bmpBk;
@


1.5
log
@small optimizations
@
text
@a249 2
	CBrush		m_brush000;

@


1.4
log
@Iconed buttons border is now visible also in a non-themed environment.
Updated BtnST code to v3.9 + Formatted & Optimized.
Shiftet Underline icon one pixel to the right.
Changed IRC text and color formatting buttons to look correct on both themed & not themed environment.
@
text
@d250 2
@


1.3
log
@Fixed Mantis bug #500 - Display bug in Server window (buttons) when using XP Visual Styles
@
text
@d11 1
a11 1
//	Updated:	25/November/2002
d79 4
d145 1
d150 1
d170 2
a171 2
	static short GetVersionI()		{return 38;}
	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("3.8");}
d197 4
d212 1
@


1.2
log
@updated to .25b codebase
@
text
@d11 1
a11 1
//	Updated:	22/July/2002
d31 1
a31 1
//	ARE GENTLY ASKED TO DONATE 1$ (ONE U.S. DOLLAR) TO THE AUTHOR:
d120 1
a120 3
	void  SetLeftAlign(bool in) {leftAligned=in;}
	bool  GetLeftAlign() {return leftAligned;}
	void  SetMarked(BOOL in) {marked=in;}
d134 1
a134 1
	void Repaint() {Invalidate();}
d164 2
a165 2
	static short GetVersionI()		{return 37;}
	static LPCTSTR GetVersionC()	{return (LPCTSTR)_T("3.7");}
d191 2
a192 2
	virtual DWORD OnDrawBackground(CDC* pDC, LPCRECT pRect);
	virtual DWORD OnDrawBorder(CDC* pDC, LPCRECT pRect);
d221 1
a238 1
	void CancelHover();
a240 2
	bool		leftAligned;
	BOOL		marked;
d242 1
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d236 1
a236 1
	CDC		m_dcBk;
d240 1
a240 1
	void 		CancelHover();
d242 1
a242 1
	int		m_nCheck;			// Current value for checkbox
@

