head	1.322;
access;
symbols
	PublicRelease_1_2e:1.315
	Interim_Release_1-2e_RC1:1.314
	PublicRelease_1_2d:1.311
	Interim_Release_1-2d_RC1:1.311
	Interim_Release_1-2d_beta1:1.311
	PublicRelease_1_2c:1.307
	Interim_Release_1-2c_RC1:1.307
	Interim_Release_1-2c_beta1:1.304
	PublicRelease_1_2b:1.300
	Interim_Release_1-2b_RC1:1.299
	PublicRelease_1_2a:1.293
	Interim_Release_1-2a_RC1:1.293
	Interim_Release_1-2a_beta2:1.288
	Interim_Release_1-2a_beta1:1.283
	PublicRelease_1_2:1.281
	Interim_Release_1-2_RC1:1.281
	Interim_Release_1-2_beta1:1.280
	PublicRelease_1_1g:1.276
	Interim_Release_1-1g_RC3:1.276
	Interim_Release_1-1g_RC2:1.274
	Interim_Release_1-1g_RC1:1.274
	Interim_Release_1-1g_beta2:1.272
	Interim_Release_1-1g_beta1:1.268
	PublicRelease_1_1f:1.268
	Interim_Release_1-1f_RC1:1.268
	PublicRelease_1_1e:1.268
	Interim_Release_1-1e_RC2:1.267
	Interim_Release_1-1e_RC1:1.267
	Interim_Release_1-1e_beta1:1.265
	PublicRelease_1_1d:1.265
	Interim_Release_1-1d_RC1:1.265
	PublicRelease_1_1c:1.264
	Interim_Release_1-1c_RC1:1.264
	Interim_Release_1-1c_beta2:1.263
	Interim_Release_1-1c_beta1:1.263
	PublicRelease_1_1b:1.255
	Interim_Release_1-1b_RC1:1.255
	PublicRelease_1_1a:1.252
	Interim_Release_1-1a_RC2:1.252
	Interim_Release_1-1a_RC1:1.252
	Interim_Release_1-1a_beta2:1.251
	Interim_Release_1-1a_beta1:1.245
	PublicRelease_1_1:1.242
	Interim_Release_1-1_beta1:1.242
	PublicRelease_1o:1.238
	Interim_Release_1o_RC1:1.238
	Interim_Release_1o_beta1:1.236
	PublicRelease_1n:1.236
	Interim_Release_1n_RC2:1.236
	Interim_Release_1n_RC1:1.235
	Interim_Release_1n_beta2:1.226
	Interim_Release_1n_beta1:1.222
	PublicRelease_1m:1.211
	Interim_Release_1m_beta1:1.211
	PublicRelease_1l:1.208
	Interim_Release_1l_RC3:1.205
	Interim_Release_1l_RC2:1.203
	Interim_Release_1l_RC1:1.201
	Interim_Release_1l_beta2:1.199
	Interim_Release_1l_beta1:1.193
	PublicRelease_1k:1.179
	Interim_Release_1k_RC4:1.179
	Interim_1k_RC3:1.179
	Interim_1k_RC2:1.179
	Interim_Release_1k_RC1:1.176
	Interim_Release_1k_beta5:1.174
	Intrerim_Release_1k_beta4:1.174
	Interim_Release_1k_beta1:1.172
	PublicRelease_1j:1.155
	Interim_Release_1J_RC3:1.155
	Interim_Release_1j_RC3:1.155
	Interim_Release_1j_RC2:1.151
	Interim_Release_1j_RC1:1.151
	Interim_Release_1j_beta2:1.150
	Interim_Release_1j_beta1:1.148
	PublicRelease_1i:1.145
	Interim_Release_1i_RC6:1.145
	Interim_Release_1i_RC3:1.144
	Interim_Release_1i_RC2:1.144
	Interim_Release_1i_RC1:1.144
	Interim_Release_1i_beta3:1.144
	Interim_Release_1i_beta2:1.141
	Interim_Release_1i_beta1:1.128
	PublicRelease_1h:1.119
	Interim_Release_1h_rc2:1.119
	Interim_Release_1h_RC1:1.118
	Interim_Release_1h_beta2:1.116
	Interim_Release_1h_beta1_now:1.112
	Interim_Release_1h_beta1:1.112
	PublicRelease_1g:1.104
	Interim_Release_1g_RC6_Final:1.104
	Interim_Release_1g_RC6:1.102
	Interim_Release_1g_RC5:1.99
	Interim_Release_1g_RC4:1.97
	Interim_Release_1g_RC3:1.94
	Interim_Release_1g_beta2:1.71
	Interim_Release_1g_beta1:1.65
	Interim_Release_1f_RC4:1.64
	Interim_Release_1f_RC3:1.64
	Interim_Release_1f_RC2:1.62
	Interim_Release_1f_RC:1.62
	Interim_Release_1f_beta2:1.61
	Interim_Release_1f_beta1:1.58
	PublicRelease_1e:1.58
	Interim_Release_1e_RC2:1.58
	Interim_Release_1e_RC:1.58
	Interim_Release_1e_beta3:1.58
	Interim_Release_1e_beta2:1.58
	Interim_Release_1e_beta2_before_kuchin:1.58
	Interim_Release_1e_beta1:1.57
	PublicRelease_1c:1.54
	featurestest:1.54.0.2
	Interim_Release_1c_RC:1.54
	Interim_Release_1c_beta2:1.53
	Interim_Release_1c_beta1:1.50
	threaded_downloadqueue:1.50.0.2
	PublicRelease_1b:1.45
	Interim_Release_1b_beta2:1.44
	Interim_Release_1b_beta1:1.41
	proxydeadlake:1.37.0.2
	PublicRelease_1a:1.37
	Interim_Release_1a_beta2:1.34
	BerkeleyDb:1.31.0.2
	Interim_Release_1a_beta1:1.30
	PublicRelease_1:1.27
	goldfish:1.27
	eMulePlus_1_RC2:1.25
	eMulePlus_26b_1RC1:1.23
	PreRelease_26b_i0e:1.23
	before_26d_merge:1.21
	Interim_Release_26b_i0d:1.17
	Interim_Release_26b_i0c:1.15
	Interim_Release_26b_i0b:1.15
	Interim_Release_26b_i0a:1.15
	systraydlg:1.13.0.4
	plus26based:1.13.0.2
	Interim_Release_25b_i0b:1.13
	Proxy_Dev:1.13
	Interim_Release_25b_i0a:1.7.2.4
	proxytest:1.7.2.1.0.2
	official_sockets:1.7.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.322
date	2011.05.14.04.54.07;	author aw3;	state Exp;
branches;
next	1.321;

1.321
date	2010.08.11.04.19.43;	author aw3;	state Exp;
branches;
next	1.320;

1.320
date	2009.10.28.04.35.00;	author aw3;	state Exp;
branches;
next	1.319;

1.319
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.318;

1.318
date	2009.07.12.16.18.15;	author aw3;	state Exp;
branches;
next	1.317;

1.317
date	2009.05.24.21.38.45;	author aw3;	state Exp;
branches;
next	1.316;

1.316
date	2009.05.18.20.36.13;	author aw3;	state Exp;
branches;
next	1.315;

1.315
date	2009.04.16.04.25.20;	author aw3;	state Exp;
branches;
next	1.314;

1.314
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.313;

1.313
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.312;

1.312
date	2008.10.03.04.26.59;	author aw3;	state Exp;
branches;
next	1.311;

1.311
date	2008.02.03.01.51.29;	author aw3;	state Exp;
branches;
next	1.310;

1.310
date	2008.01.01.11.12.07;	author eklmn;	state Exp;
branches;
next	1.309;

1.309
date	2007.12.30.05.00.25;	author aw3;	state Exp;
branches;
next	1.308;

1.308
date	2007.12.28.04.02.41;	author aw3;	state Exp;
branches;
next	1.307;

1.307
date	2007.07.23.03.46.58;	author aw3;	state Exp;
branches;
next	1.306;

1.306
date	2007.05.11.01.15.56;	author aw3;	state Exp;
branches;
next	1.305;

1.305
date	2007.03.07.04.48.56;	author aw3;	state Exp;
branches;
next	1.304;

1.304
date	2007.02.26.04.49.07;	author aw3;	state Exp;
branches;
next	1.303;

1.303
date	2007.02.25.05.31.03;	author aw3;	state Exp;
branches;
next	1.302;

1.302
date	2007.02.18.16.00.49;	author eklmn;	state Exp;
branches;
next	1.301;

1.301
date	2007.02.17.05.45.59;	author aw3;	state Exp;
branches;
next	1.300;

1.300
date	2007.01.31.20.01.23;	author eklmn;	state Exp;
branches;
next	1.299;

1.299
date	2007.01.08.05.55.29;	author aw3;	state Exp;
branches;
next	1.298;

1.298
date	2006.12.13.06.04.14;	author aw3;	state Exp;
branches;
next	1.297;

1.297
date	2006.11.21.12.09.41;	author eklmn;	state Exp;
branches;
next	1.296;

1.296
date	2006.11.16.05.53.01;	author aw3;	state Exp;
branches;
next	1.295;

1.295
date	2006.11.13.17.02.22;	author eklmn;	state Exp;
branches;
next	1.294;

1.294
date	2006.11.10.15.03.55;	author eklmn;	state Exp;
branches;
next	1.293;

1.293
date	2006.09.05.01.10.47;	author aw3;	state Exp;
branches;
next	1.292;

1.292
date	2006.07.30.03.02.19;	author aw3;	state Exp;
branches;
next	1.291;

1.291
date	2006.07.28.03.04.30;	author aw3;	state Exp;
branches;
next	1.290;

1.290
date	2006.07.23.00.35.04;	author aw3;	state Exp;
branches;
next	1.289;

1.289
date	2006.07.19.04.25.22;	author aw3;	state Exp;
branches;
next	1.288;

1.288
date	2006.06.19.04.11.56;	author aw3;	state Exp;
branches;
next	1.287;

1.287
date	2006.05.22.03.45.00;	author aw3;	state Exp;
branches;
next	1.286;

1.286
date	2006.05.18.03.50.46;	author aw3;	state Exp;
branches;
next	1.285;

1.285
date	2006.05.17.03.46.40;	author aw3;	state Exp;
branches;
next	1.284;

1.284
date	2006.05.15.05.54.08;	author aw3;	state Exp;
branches;
next	1.283;

1.283
date	2006.04.22.21.58.08;	author aw3;	state Exp;
branches;
next	1.282;

1.282
date	2006.03.27.03.53.13;	author aw3;	state Exp;
branches;
next	1.281;

1.281
date	2006.02.07.05.31.04;	author aw3;	state Exp;
branches;
next	1.280;

1.280
date	2006.01.22.05.15.34;	author aw3;	state Exp;
branches;
next	1.279;

1.279
date	2006.01.14.19.54.36;	author aw3;	state Exp;
branches;
next	1.278;

1.278
date	2006.01.12.17.58.09;	author eklmn;	state Exp;
branches;
next	1.277;

1.277
date	2006.01.03.04.36.40;	author aw3;	state Exp;
branches;
next	1.276;

1.276
date	2005.12.15.03.23.08;	author aw3;	state Exp;
branches;
next	1.275;

1.275
date	2005.12.10.06.27.06;	author aw3;	state Exp;
branches;
next	1.274;

1.274
date	2005.11.27.22.11.50;	author eklmn;	state Exp;
branches;
next	1.273;

1.273
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.272;

1.272
date	2005.11.23.04.00.32;	author aw3;	state Exp;
branches;
next	1.271;

1.271
date	2005.11.19.16.51.12;	author aw3;	state Exp;
branches;
next	1.270;

1.270
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.269;

1.269
date	2005.09.18.16.35.20;	author aw3;	state Exp;
branches;
next	1.268;

1.268
date	2005.07.09.17.58.34;	author aw3;	state Exp;
branches;
next	1.267;

1.267
date	2005.06.19.05.04.00;	author aw3;	state Exp;
branches;
next	1.266;

1.266
date	2005.06.17.15.20.01;	author eklmn;	state Exp;
branches;
next	1.265;

1.265
date	2005.03.03.20.38.36;	author eklmn;	state Exp;
branches;
next	1.264;

1.264
date	2005.02.20.20.29.35;	author aw3;	state Exp;
branches;
next	1.263;

1.263
date	2005.01.28.20.02.02;	author aw3;	state Exp;
branches;
next	1.262;

1.262
date	2005.01.27.17.45.49;	author aw3;	state Exp;
branches;
next	1.261;

1.261
date	2005.01.21.09.01.12;	author kush_eplus;	state Exp;
branches;
next	1.260;

1.260
date	2005.01.20.16.24.41;	author kush_eplus;	state Exp;
branches;
next	1.259;

1.259
date	2005.01.19.21.10.52;	author netwolf1;	state Exp;
branches;
next	1.258;

1.258
date	2005.01.19.19.37.03;	author eklmn;	state Exp;
branches;
next	1.257;

1.257
date	2005.01.16.00.35.00;	author netwolf1;	state Exp;
branches;
next	1.256;

1.256
date	2005.01.15.09.47.22;	author eklmn;	state Exp;
branches;
next	1.255;

1.255
date	2004.12.21.21.00.43;	author aw3;	state Exp;
branches;
next	1.254;

1.254
date	2004.12.21.06.48.46;	author aw3;	state Exp;
branches;
next	1.253;

1.253
date	2004.12.19.09.27.57;	author eklmn;	state Exp;
branches;
next	1.252;

1.252
date	2004.11.25.12.48.43;	author eklmn;	state Exp;
branches;
next	1.251;

1.251
date	2004.11.20.07.16.07;	author eklmn;	state Exp;
branches;
next	1.250;

1.250
date	2004.11.19.21.00.15;	author eklmn;	state Exp;
branches;
next	1.249;

1.249
date	2004.11.18.06.57.49;	author aw3;	state Exp;
branches;
next	1.248;

1.248
date	2004.11.17.06.34.05;	author aw3;	state Exp;
branches;
next	1.247;

1.247
date	2004.11.15.19.07.32;	author aw3;	state Exp;
branches;
next	1.246;

1.246
date	2004.11.08.21.09.14;	author aw3;	state Exp;
branches;
next	1.245;

1.245
date	2004.11.05.18.43.39;	author eklmn;	state Exp;
branches;
next	1.244;

1.244
date	2004.10.29.23.06.04;	author aw3;	state Exp;
branches;
next	1.243;

1.243
date	2004.10.29.06.58.51;	author eklmn;	state Exp;
branches;
next	1.242;

1.242
date	2004.10.18.18.07.02;	author aw3;	state Exp;
branches;
next	1.241;

1.241
date	2004.10.09.23.11.15;	author dongato;	state Exp;
branches;
next	1.240;

1.240
date	2004.10.09.07.56.33;	author eklmn;	state Exp;
branches;
next	1.239;

1.239
date	2004.10.05.08.34.41;	author dongato;	state Exp;
branches;
next	1.238;

1.238
date	2004.09.27.06.39.12;	author aw3;	state Exp;
branches;
next	1.237;

1.237
date	2004.09.25.07.32.25;	author aw3;	state Exp;
branches;
next	1.236;

1.236
date	2004.09.05.07.56.04;	author eklmn;	state Exp;
branches;
next	1.235;

1.235
date	2004.08.28.04.55.51;	author aw3;	state Exp;
branches;
next	1.234;

1.234
date	2004.08.27.15.07.28;	author eklmn;	state Exp;
branches;
next	1.233;

1.233
date	2004.08.21.01.23.15;	author aw3;	state Exp;
branches;
next	1.232;

1.232
date	2004.08.16.21.13.47;	author aw3;	state Exp;
branches;
next	1.231;

1.231
date	2004.08.15.21.06.02;	author eklmn;	state Exp;
branches;
next	1.230;

1.230
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.229;

1.229
date	2004.08.12.13.02.02;	author eklmn;	state Exp;
branches;
next	1.228;

1.228
date	2004.08.10.19.25.47;	author eklmn;	state Exp;
branches;
next	1.227;

1.227
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.226;

1.226
date	2004.08.07.08.51.53;	author eklmn;	state Exp;
branches;
next	1.225;

1.225
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.224;

1.224
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.223;

1.223
date	2004.07.29.17.58.58;	author aw3;	state Exp;
branches;
next	1.222;

1.222
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.221;

1.221
date	2004.07.16.19.40.53;	author eklmn;	state Exp;
branches;
next	1.220;

1.220
date	2004.07.12.14.10.42;	author katsyonak;	state Exp;
branches;
next	1.219;

1.219
date	2004.07.11.12.20.48;	author dongato;	state Exp;
branches;
next	1.218;

1.218
date	2004.06.30.13.38.43;	author dongato;	state Exp;
branches;
next	1.217;

1.217
date	2004.06.29.15.17.17;	author syrus77;	state Exp;
branches;
next	1.216;

1.216
date	2004.06.29.03.10.48;	author syrus77;	state Exp;
branches;
next	1.215;

1.215
date	2004.06.28.23.08.22;	author dongato;	state Exp;
branches;
next	1.214;

1.214
date	2004.06.28.22.58.28;	author dongato;	state Exp;
branches;
next	1.213;

1.213
date	2004.06.28.17.29.36;	author dongato;	state Exp;
branches;
next	1.212;

1.212
date	2004.06.28.03.17.00;	author dongato;	state Exp;
branches;
next	1.211;

1.211
date	2004.06.22.05.43.57;	author aw3;	state Exp;
branches;
next	1.210;

1.210
date	2004.06.17.12.23.06;	author netwolf1;	state Exp;
branches;
next	1.209;

1.209
date	2004.06.16.16.29.46;	author dongato;	state Exp;
branches;
next	1.208;

1.208
date	2004.06.10.22.04.19;	author netwolf1;	state Exp;
branches;
next	1.207;

1.207
date	2004.06.10.05.13.59;	author aw3;	state Exp;
branches;
next	1.206;

1.206
date	2004.06.09.22.54.15;	author dongato;	state Exp;
branches;
next	1.205;

1.205
date	2004.06.07.13.48.39;	author netwolf1;	state Exp;
branches;
next	1.204;

1.204
date	2004.06.04.04.33.34;	author aw3;	state Exp;
branches;
next	1.203;

1.203
date	2004.06.02.21.02.44;	author aw3;	state Exp;
branches;
next	1.202;

1.202
date	2004.06.01.22.31.03;	author aw3;	state Exp;
branches;
next	1.201;

1.201
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.200;

1.200
date	2004.05.22.11.50.07;	author dongato;	state Exp;
branches;
next	1.199;

1.199
date	2004.05.21.18.37.19;	author dongato;	state Exp;
branches;
next	1.198;

1.198
date	2004.05.21.04.37.09;	author aw3;	state Exp;
branches;
next	1.197;

1.197
date	2004.05.19.10.14.34;	author netwolf1;	state Exp;
branches;
next	1.196;

1.196
date	2004.05.17.01.45.15;	author dongato;	state Exp;
branches;
next	1.195;

1.195
date	2004.05.15.00.56.22;	author aw3;	state Exp;
branches;
next	1.194;

1.194
date	2004.05.12.23.18.03;	author kush_eplus;	state Exp;
branches;
next	1.193;

1.193
date	2004.05.04.17.51.07;	author netwolf1;	state Exp;
branches;
next	1.192;

1.192
date	2004.05.04.11.28.01;	author netwolf1;	state Exp;
branches;
next	1.191;

1.191
date	2004.05.01.05.37.21;	author aw3;	state Exp;
branches;
next	1.190;

1.190
date	2004.04.30.01.30.24;	author kush_eplus;	state Exp;
branches;
next	1.189;

1.189
date	2004.04.30.00.09.24;	author kush_eplus;	state Exp;
branches;
next	1.188;

1.188
date	2004.04.29.23.55.39;	author kush_eplus;	state Exp;
branches;
next	1.187;

1.187
date	2004.04.28.19.46.49;	author syrus77;	state Exp;
branches;
next	1.186;

1.186
date	2004.04.27.16.56.31;	author kush_eplus;	state Exp;
branches;
next	1.185;

1.185
date	2004.04.27.03.04.05;	author kush_eplus;	state Exp;
branches;
next	1.184;

1.184
date	2004.04.22.17.13.15;	author aw3;	state Exp;
branches;
next	1.183;

1.183
date	2004.04.22.02.58.13;	author kush_eplus;	state Exp;
branches;
next	1.182;

1.182
date	2004.04.15.14.54.11;	author katsyonak;	state Exp;
branches;
next	1.181;

1.181
date	2004.04.13.22.13.09;	author dongato;	state Exp;
branches;
next	1.180;

1.180
date	2004.04.12.16.24.24;	author dongato;	state Exp;
branches;
next	1.179;

1.179
date	2004.03.31.08.05.09;	author eklmn;	state Exp;
branches;
next	1.178;

1.178
date	2004.03.28.14.15.52;	author eklmn;	state Exp;
branches;
next	1.177;

1.177
date	2004.03.28.14.03.31;	author eklmn;	state Exp;
branches;
next	1.176;

1.176
date	2004.03.27.17.22.13;	author eklmn;	state Exp;
branches;
next	1.175;

1.175
date	2004.03.24.09.51.22;	author eklmn;	state Exp;
branches;
next	1.174;

1.174
date	2004.03.14.21.07.25;	author eklmn;	state Exp;
branches;
next	1.173;

1.173
date	2004.03.14.20.06.28;	author eklmn;	state Exp;
branches;
next	1.172;

1.172
date	2004.02.16.23.25.59;	author aw3;	state Exp;
branches;
next	1.171;

1.171
date	2004.02.15.11.55.58;	author morevit;	state Exp;
branches;
next	1.170;

1.170
date	2004.02.15.10.12.15;	author eklmn;	state Exp;
branches;
next	1.169;

1.169
date	2004.02.14.06.37.21;	author aw3;	state Exp;
branches;
next	1.168;

1.168
date	2004.02.13.16.13.35;	author netwolf1;	state Exp;
branches;
next	1.167;

1.167
date	2004.02.13.01.47.11;	author aw3;	state Exp;
branches;
next	1.166;

1.166
date	2004.02.11.04.13.01;	author katsyonak;	state Exp;
branches;
next	1.165;

1.165
date	2004.02.09.23.10.53;	author netwolf1;	state Exp;
branches;
next	1.164;

1.164
date	2004.02.09.16.39.50;	author kush_eplus;	state Exp;
branches;
next	1.163;

1.163
date	2004.02.07.00.50.45;	author netwolf1;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.05.00.00.02;	author kush_eplus;	state Exp;
branches;
next	1.161;

1.161
date	2004.02.04.19.06.00;	author morevit;	state Exp;
branches;
next	1.160;

1.160
date	2004.02.03.21.39.12;	author syrus77;	state Exp;
branches;
next	1.159;

1.159
date	2004.02.03.14.28.06;	author kush_eplus;	state Exp;
branches;
next	1.158;

1.158
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.157;

1.157
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.30.20.33.57;	author eklmn;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.23.13.38.55;	author dongato;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.22.06.33.34;	author eklmn;	state Exp;
branches;
next	1.153;

1.153
date	2004.01.21.12.45.40;	author kuchin;	state Exp;
branches;
next	1.152;

1.152
date	2004.01.16.19.46.50;	author eklmn;	state Exp;
branches;
next	1.151;

1.151
date	2004.01.10.20.34.51;	author eklmn;	state Exp;
branches;
next	1.150;

1.150
date	2004.01.05.03.33.04;	author dongato;	state Exp;
branches;
next	1.149;

1.149
date	2004.01.03.21.23.29;	author syrus77;	state Exp;
branches;
next	1.148;

1.148
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.147;

1.147
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.146;

1.146
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.145;

1.145
date	2003.11.23.00.03.43;	author syrus77;	state Exp;
branches;
next	1.144;

1.144
date	2003.10.29.14.14.19;	author morevit;	state Exp;
branches;
next	1.143;

1.143
date	2003.10.26.14.00.52;	author morevit;	state Exp;
branches;
next	1.142;

1.142
date	2003.10.26.12.44.08;	author kuchin;	state Exp;
branches;
next	1.141;

1.141
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.140;

1.140
date	2003.10.23.13.14.32;	author dongato;	state Exp;
branches;
next	1.139;

1.139
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.138;

1.138
date	2003.10.20.13.20.04;	author morevit;	state Exp;
branches;
next	1.137;

1.137
date	2003.10.17.10.29.07;	author morevit;	state Exp;
branches;
next	1.136;

1.136
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.135;

1.135
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.134;

1.134
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.09.09.25.17;	author morevit;	state Exp;
branches;
next	1.132;

1.132
date	2003.10.08.15.48.34;	author eklmn;	state Exp;
branches;
next	1.131;

1.131
date	2003.10.08.12.56.35;	author morevit;	state Exp;
branches;
next	1.130;

1.130
date	2003.10.08.01.53.33;	author morevit;	state Exp;
branches;
next	1.129;

1.129
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.128;

1.128
date	2003.09.30.22.42.32;	author syrus77;	state Exp;
branches;
next	1.127;

1.127
date	2003.09.30.11.35.39;	author morevit;	state Exp;
branches;
next	1.126;

1.126
date	2003.09.29.14.55.46;	author morevit;	state Exp;
branches;
next	1.125;

1.125
date	2003.09.24.20.37.30;	author dongato;	state Exp;
branches;
next	1.124;

1.124
date	2003.09.22.22.25.15;	author eklmn;	state Exp;
branches;
next	1.123;

1.123
date	2003.09.21.22.05.19;	author morevit;	state Exp;
branches;
next	1.122;

1.122
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.121;

1.121
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.120;

1.120
date	2003.09.19.00.13.38;	author morevit;	state Exp;
branches;
next	1.119;

1.119
date	2003.09.14.13.59.08;	author kuchin;	state Exp;
branches;
next	1.118;

1.118
date	2003.09.09.18.25.13;	author partyckip;	state Exp;
branches;
next	1.117;

1.117
date	2003.09.08.18.29.44;	author eklmn;	state Exp;
branches;
next	1.116;

1.116
date	2003.09.01.22.48.10;	author eklmn;	state Exp;
branches;
next	1.115;

1.115
date	2003.08.30.11.23.26;	author emoulari;	state Exp;
branches;
next	1.114;

1.114
date	2003.08.30.08.19.58;	author zegzav;	state Exp;
branches;
next	1.113;

1.113
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	1.112;

1.112
date	2003.08.17.12.04.27;	author double_t;	state Exp;
branches;
next	1.111;

1.111
date	2003.08.16.18.03.26;	author eklmn;	state Exp;
branches;
next	1.110;

1.110
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.109;

1.109
date	2003.08.07.20.29.56;	author syrus77;	state Exp;
branches;
next	1.108;

1.108
date	2003.08.03.01.04.56;	author dongato;	state Exp;
branches;
next	1.107;

1.107
date	2003.07.28.22.04.47;	author partyckip;	state Exp;
branches;
next	1.106;

1.106
date	2003.07.28.21.53.17;	author netwolf1;	state Exp;
branches;
next	1.105;

1.105
date	2003.07.26.11.27.02;	author zegzav;	state Exp;
branches;
next	1.104;

1.104
date	2003.07.21.15.54.46;	author eklmn;	state Exp;
branches;
next	1.103;

1.103
date	2003.07.21.15.30.18;	author eklmn;	state Exp;
branches;
next	1.102;

1.102
date	2003.07.16.23.36.01;	author syrus77;	state Exp;
branches;
next	1.101;

1.101
date	2003.07.16.23.04.00;	author partyckip;	state Exp;
branches;
next	1.100;

1.100
date	2003.07.15.21.48.45;	author syrus77;	state Exp;
branches;
next	1.99;

1.99
date	2003.07.09.15.30.09;	author eklmn;	state Exp;
branches;
next	1.98;

1.98
date	2003.07.09.15.08.21;	author netwolf1;	state Exp;
branches;
next	1.97;

1.97
date	2003.07.07.21.45.17;	author syrus77;	state Exp;
branches;
next	1.96;

1.96
date	2003.07.05.18.32.01;	author obaldin;	state Exp;
branches;
next	1.95;

1.95
date	2003.07.03.22.18.38;	author eklmn;	state Exp;
branches;
next	1.94;

1.94
date	2003.06.27.15.51.04;	author eklmn;	state Exp;
branches;
next	1.93;

1.93
date	2003.06.25.22.43.32;	author partyckip;	state Exp;
branches;
next	1.92;

1.92
date	2003.06.25.18.28.28;	author eklmn;	state Exp;
branches;
next	1.91;

1.91
date	2003.06.24.23.19.31;	author syrus77;	state Exp;
branches;
next	1.90;

1.90
date	2003.06.23.22.04.43;	author partyckip;	state Exp;
branches;
next	1.89;

1.89
date	2003.06.23.21.55.16;	author partyckip;	state Exp;
branches;
next	1.88;

1.88
date	2003.06.21.21.46.07;	author eklmn;	state Exp;
branches;
next	1.87;

1.87
date	2003.06.19.18.27.17;	author syrus77;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.19.07.31.53;	author partyckip;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.17.16.35.03;	author netwolf1;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.17.05.49.35;	author eklmn;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.17.02.15.18;	author dongato;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.16.21.54.52;	author dongato;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.16.15.37.42;	author netwolf1;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.16.13.44.19;	author netwolf1;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.16.04.45.58;	author partyckip;	state Exp;
branches;
next	1.78;

1.78
date	2003.06.16.00.55.14;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.15.23.27.46;	author dongato;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.15.22.22.29;	author dongato;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.15.19.11.18;	author dongato;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.11.18.27.13;	author eklmn;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.10.09.36.47;	author kuchin;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.09.15.14.38;	author kuchin;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.08.23.58.37;	author syrus77;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.08.07.36.58;	author partyckip;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.06.20.03.09;	author eklmn;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.05.01.22.31;	author netwolf1;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.04.22.37.15;	author netwolf1;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.04.21.01.28;	author eklmn;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.26.22.12.00;	author partyckip;	state Exp;
branches;
next	1.64;

1.64
date	2003.05.22.13.12.23;	author obaldin;	state Exp;
branches;
next	1.63;

1.63
date	2003.05.20.16.30.42;	author netwolf1;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.12.13.28.18;	author kuchin;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.09.11.57.06;	author kuchin;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.06.07.43.07;	author partyckip;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.05.21.39.52;	author partyckip;	state Exp;
branches;
next	1.58;

1.58
date	2003.04.18.15.49.49;	author partyckip;	state Exp;
branches;
next	1.57;

1.57
date	2003.04.12.14.54.06;	author obaldin;	state Exp;
branches;
next	1.56;

1.56
date	2003.04.11.21.58.03;	author obaldin;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.25.12.39.36;	author cax2;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.21.10.58.06;	author recdvst;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2003.03.21.09.53.11;	author cax2;	state Exp;
branches;
next	1.52;

1.52
date	2003.03.20.18.09.34;	author cax2;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.20.13.42.54;	author obaldin;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.14.16.24.22;	author partyckip;	state Exp;
branches;
next	1.49;

1.49
date	2003.03.12.17.33.15;	author obaldin;	state Exp;
branches;
next	1.48;

1.48
date	2003.03.11.18.31.57;	author obaldin;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.10.23.04.20;	author cax2;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.10.16.12.12;	author cax2;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.09.09.55.53;	author obaldin;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.05.23.17.40;	author cax2;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.05.21.36.31;	author dongato;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.05.21.16.38;	author obaldin;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.03.22.09.51;	author moosetea;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.01.12.29.07;	author obaldin;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.28.21.00.39;	author dongato;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.28.19.17.14;	author cax2;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.27.20.24.39;	author obaldin;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.27.11.16.14;	author dongato;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.27.10.06.33;	author kuchin;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.26.21.33.11;	author obaldin;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.25.18.08.01;	author cax2;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.25.15.36.13;	author dongato;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.24.20.09.50;	author dongato;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2003.02.23.20.20.37;	author obaldin;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.23.12.35.46;	author obaldin;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.20.14.48.18;	author dongato;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.20.14.29.03;	author dongato;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.20.07.25.22;	author cax2;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.19.15.18.02;	author obaldin;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.17.09.15.17;	author cax2;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.16.22.01.50;	author lord_kiron;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.15.13.35.54;	author obaldin;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.14.13.24.30;	author lord_kiron;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.14.12.22.36;	author lord_kiron;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.13.14.57.48;	author obaldin;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.12.21.55.34;	author obaldin;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.09.22.04.26;	author obaldin;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.02.03.39.55;	author cax2;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2003.02.01.14.45.39;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.31.21.16.49;	author obaldin;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.30.22.40.33;	author cax2;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.30.18.28.36;	author cax2;	state Exp;
branches;
next	1.8;

1.8
date	2003.01.30.17.32.15;	author cax2;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.26.16.00.24;	author cax2;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.01.26.06.03.05;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.25.17.35.58;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.24.22.07.51;	author maverick65;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.17.30.09;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches;
next	;

1.7.2.1
date	2003.01.28.16.54.32;	author cax2;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.01.30.17.42.45;	author cax2;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.01.30.18.28.55;	author cax2;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.01.30.22.36.58;	author cax2;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.01.31.16.29.40;	author obaldin;	state Exp;
branches;
next	;

1.13.2.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2003.02.05.17.03.14;	author obaldin;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2003.02.06.15.56.14;	author obaldin;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2003.02.06.23.14.43;	author obaldin;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2003.02.08.13.37.05;	author obaldin;	state Exp;
branches;
next	;

1.31.2.1
date	2003.02.28.22.44.56;	author obaldin;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2003.03.01.20.59.36;	author obaldin;	state Exp;
branches;
next	;

1.54.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.322
log
@Removed previous workaround for Hybrids to provide hashset when no complete chunks available (this was introduced in 1.1g as a measure to reduce weird flood of hashset requests from this buggy client, as it didn't change anything and they send requests even after hashset was sent to them -- no need to waste our traffic for that).
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "zlib/zlib.h"
#include "UpDownClient.h"
#include "opcodes.h"
#include "packets.h"
#include "emule.h"
#include "UploadQueue.h"
#include "otherstructs.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "ListenSocket.h"
#include "SafeFile.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::DrawUpStatusBar(CDC *pDC, RECT *pRect, bool bFlat)
{
	EMULE_TRY

	const COLORREF	crSentData = RGB(222, 160, 0);
	const COLORREF	crSendingPart = RGB(255, 208, 0);
	const COLORREF	crMeOnly = RGB(190, 190, 255);
	COLORREF		crBoth, crNeither, crClientOnly;

	if (bFlat)
	{
		crBoth = RGB(0, 150, 0);
		crNeither = RGB(224, 224, 224);
		crClientOnly = RGB(0, 0, 0);
	}
	else
	{
		crBoth = RGB(0, 192, 0);
		crNeither = RGB(240, 240, 240);
		crClientOnly = RGB(95, 95, 95);
	}

//	Get and set the file's size
	CPartFile	   *pUploadingFile = reinterpret_cast<CPartFile*>(g_App.m_pSharedFilesList->GetFileByID(m_reqFileHash));
	uint64			qwFileSz = (pUploadingFile != NULL) ? pUploadingFile->GetFileSize() : 1ui64;
	CBarShader		statusBar(pRect->bottom - pRect->top, pRect->right - pRect->left, crNeither, qwFileSz);

	if ((m_pbyteUpPartStatuses != NULL) && (pUploadingFile != NULL))
	{
		uint32		dwUploadingPart = GetCurrentlyUploadingPart();
		uint64		qwStartPos, qwEndPos;

		for (uint32 i = 0; i < m_uUpPartCount; i++)
		{
			qwStartPos = static_cast<uint64>(i) * PARTSIZE;
			qwEndPos = ((qwStartPos + PARTSIZE) > qwFileSz) ? qwFileSz : (qwStartPos + PARTSIZE);
			if (i == dwUploadingPart)
			{
			//	Add the current uploading part
				statusBar.FillRange(qwStartPos, qwEndPos, crSendingPart);

				ReqBlockDeque::iterator	itBlock;
				Requested_Block_Struct	*pDoneBlock;

			//	Add already uploaded pieces
				for (itBlock = m_doneBlocksList.begin(); itBlock != m_doneBlocksList.end(); itBlock++)
				{
					pDoneBlock = *itBlock;
					if (dwUploadingPart == static_cast<uint32>(pDoneBlock->qwStartOffset / PARTSIZE))
						statusBar.FillRange(pDoneBlock->qwStartOffset, pDoneBlock->qwEndOffset, crSentData);
				}
			}
			else if (!pUploadingFile->IsPartFile() || pUploadingFile->IsPartComplete(i))	// We've this part
			{
				statusBar.FillRange(qwStartPos, qwEndPos, (m_pbyteUpPartStatuses[i] != 0) ? crBoth : crMeOnly);
			}
			else if (m_pbyteUpPartStatuses[i] != 0)	// The remote user has this part
			{
				statusBar.FillRange(qwStartPos, qwEndPos, crClientOnly);
			}
		}
	}
	statusBar.Draw(pDC, pRect->left, pRect->top, bFlat);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::IsCommunity()
{
	EMULE_TRY
	
	if (m_byteActionsOnNameChange & AONC_COMMUNITY_CHECK)
	{
		m_bIsCommunity = false;

		if (g_App.m_pPrefs->CommunityEnabled())
		{
			CString		strLowerCommunity = g_App.m_pPrefs->CommunityString();

			strLowerCommunity.MakeLower();
			strLowerCommunity.Remove(_T('['));
			strLowerCommunity.Remove(_T(']'));

			if (!strLowerCommunity.IsEmpty())
			{
				CString		strProperCommunity;

				strProperCommunity.Format(_T("[%s]"), strLowerCommunity);

			//	Ignore unsuitable tags which are not meant to be used as community
				CString		strLowerUserName = m_strUserName;

				strLowerUserName.MakeLower();
				strLowerUserName.Replace(_T("[eplus]"), _T(""));

			//	Only the first community-tag is evaluated to be valid
				int		iFirstTagPos = strLowerUserName.Find(_T('['));

				if (iFirstTagPos >= 0 && iFirstTagPos == strLowerUserName.Find(strProperCommunity))
					m_bIsCommunity = true;
			}
		}

		m_byteActionsOnNameChange &= ~AONC_COMMUNITY_CHECK;
	}

	return m_bIsCommunity;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUpDownClient::GetScore(bool bOnlyBaseValue /*= false*/)
{
	EMULE_TRY

	if ((m_eBanState != BAN_CLIENT_NONE) || m_strUserName.IsEmpty())
		return 0;

	if (HasUserNameForbiddenStrings() || HasMODNameForbiddenStrings())
	{
		Ban(BAN_CLIENT_KWOWN_LEECHER);
		return 0;
	}

	if (m_pCredits != NULL && m_pCredits->GetCurrentIdentState(GetIP()) == IS_IDBADGUY)
		return 0;

	if (IsDownloading())
		return 0;

	CKnownFile	*pSharedFile = g_App.m_pSharedFilesList->GetFileByID(m_reqFileHash);

	if (pSharedFile == NULL)
		return 0;

	ASSERT(m_reqFileHash != NULL);

	double	dBaseValue, dFilePriority;

	switch (pSharedFile->GetULPriority())
	{
		case PR_RELEASE:
			if (pSharedFile->IsPartFile())
				dFilePriority = 5.0;
			else
				dFilePriority = 10.0;
			break;

		case PR_HIGH:
			dFilePriority = 2.0;
			break;

		case PR_LOW:
			dFilePriority = 0.5;
			break;

		case PR_VERYLOW:
			dFilePriority = 0.2;
			break;

		case PR_NORMAL:
		default:
			dFilePriority = 1.0;	// standard
			break;
	}

	double	dPopularityRatio = pSharedFile->GetPopularityRatio();

//	Calculate score, based on waiting time and other factors
	if (bOnlyBaseValue)
		dBaseValue = 100.0;
	else
	{
#ifdef OLD_SOCKETS_ENABLED
		if (HasLowID() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
		{
			if (!g_App.m_pServerConnect->IsConnected() || g_App.m_pServerConnect->IsLowID())
				return 0;
		}
#endif //OLD_SOCKETS_ENABLED
		dBaseValue = static_cast<double>(::GetTickCount() - GetWaitStartTime()) / 1000.0;
	}

	if (IsFriend())			//	Client is on friendlist
		dBaseValue *= 2.0;
	else if (IsCommunity())	//	Client is a community user
		dBaseValue *= 1.5;
	else if ((m_fIdenThief == 1) && g_App.m_pPrefs->IsCounterMeasures())
		dBaseValue *= 0.8;

//	Client has credits (modifier between 1.0 and 10.0)
	if (m_pCredits != NULL)
		dBaseValue *= m_pCredits->GetScoreRatio(GetIP());

	dBaseValue *= dFilePriority * pSharedFile->GetSizeRatio() * dPopularityRatio;

	return static_cast<uint32>(dBaseValue);

	EMULE_CATCH

	return 1;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Checks if it is next requested block from another chunk of the actual file or from another file
//	Return:
//		> 0 : Next requested block is from another chunk or file than last downloaded block
//		= 0 : Next requested block is from same chunk that last downloaded block
//		< 0 : Next requested block is from another chunk or file, but allow to continue
int CUpDownClient::IsDifferentPartBlock(bool *pbJSBlocked)
{
	int			iDiffPart = 0;
	CKnownFile	*pKFile = NULL;

	*pbJSBlocked = false;
	try
	{
	//	Check if we have good lists and proceed to check for different chunks
		if (!m_blockRequestsQueue.empty())
		{
		//	Get next pending block
			Requested_Block_Struct	*pNextReqBlk = m_blockRequestsQueue.front();
		//	Calculate corresponding part for the block
			uint32		dwNextReqPart = static_cast<uint32>(pNextReqBlk->qwStartOffset / PARTSIZE);

			if (!m_doneBlocksList.empty())
			{
			//	Get last transferred block
				Requested_Block_Struct	*pLastDoneBlk = m_doneBlocksList.front();
				uint32	dwLastDonePart = static_cast<uint32>(pLastDoneBlk->qwStartOffset / PARTSIZE);

			//	Check that the same file and part are asked
				if (dwLastDonePart != dwNextReqPart || md4cmp(pLastDoneBlk->m_fileHash, pNextReqBlk->m_fileHash) != 0)
					iDiffPart = 1;
			}

			pKFile = g_App.m_pSharedFilesList->GetFileByID(pNextReqBlk->m_fileHash);
			if ((pKFile != NULL) && !pKFile->AllowChunkForClient(dwNextReqPart, this))
				*pbJSBlocked = true;	//	Forbidden by Jumpstart
		}
	}
	catch (...)
	{
		iDiffPart = 1;
	}

	if (iDiffPart > 0)
	{
		if (GetSessionUp() < (PARTSZ32 / 4))
			iDiffPart = -1;
		else if (GetSessionUp() < (3 * PARTSZ32 / 4))
		{
			if (IsFriend())
				iDiffPart = -1;
			else if (pKFile != NULL)
			{
				if (pKFile->IsPartFile())
				{
					uint32	dwSrcNum = reinterpret_cast<CPartFile*>(pKFile)->GetSourceCount();

				//	File is rare if number of sources != 0 and < RARE_FILE
					if ((dwSrcNum - 1u) < (RARE_FILE - 1))
						iDiffPart = -1;
				}
				else
				{
					if (pKFile->GetCompleteSourcesCount() < 5)
						iDiffPart = -1;
				}
			}
		}
	}

	return iDiffPart;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSyncHelper
{
public:

	CSyncHelper()
	{
		m_pObject = NULL;
	}

	~CSyncHelper()
	{
		if (m_pObject)
			m_pObject->Unlock();
	}

	CSyncObject* m_pObject;
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Check if we should kick this client
//	- Always kick if transfer is longer than SESSIONMAXTIME
//	- Never kick friends before a chunck was transferred
//	- Never allow more than the size of a chunk (+500 KBytes for small resends of invalid data) to be transferred
//	- We never kick a lancast user
//	- Full chunk transfers are being enforced, is not more an option
//
EnumBlockPacketCreationResult CUpDownClient::CreateNextBlockPackage()
{
	EMULE_TRY

//	If there are no new blocks requested, we will happily transfer more if the client requested it
	if (m_blockRequestsQueue.empty())
		return BPCR_FAILED_NO_REQUESTED_BLOCKS;

	bool	bJumpstartBlocked;
	int		iDiffPart = IsDifferentPartBlock(&bJumpstartBlocked);

	if (bJumpstartBlocked)
		return BPCR_FAILED_BLOCKED_PART;

	bool	bAllowedMore = IsOnLAN();
	uint32	dwTimeout = 0;

//	If user is from Internet & Full chunk (or timeout)
	if ( !bAllowedMore &&
		((iDiffPart > 0) || ((dwTimeout = GetUpStartTimeDelay()) > SESSIONMAXTIME)) )
	{
		if ((dwTimeout > SESSIONMAXTIME) && IsFriend())
		{
			bAllowedMore = true;
			if (g_App.m_pPrefs->IsClientTransferLogEnabled())
				AddLogLine(LOG_FL_DBG, _T("Client %s downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend"), GetClientNameWithSoftware(), this->GetSessionUp() / 1024);
		}
		else
		{
			if (iDiffPart > 0)
				return BPCR_FAILED_BLOCKED_PART;
			else
				return BPCR_FAILED_TIME_LIMIT;
		}
	}

	CFile			file;
	CKnownFile*		srcfile;
	byte*			filedata = NULL;
	EnumBlockPacketCreationResult eBPCResult = BPCR_FAILED_TIME_LIMIT;

	try
	{
		if ((iDiffPart < 0) && !bAllowedMore && g_App.m_pPrefs->IsClientTransferLogEnabled())
			AddLogLine(LOG_FL_DBG, _T("Client %s continues downloading (should be back on queue) because of a low transferred size"), GetClientNameWithSoftware());
	//	Note: since this function is called when upload packets queue is empty,
	//	the upload can be broken during packets creation for requested blocks,
	//	therefore in order to decrease the probability of connection loss,
	//	we gonna create just one requested block packet. This leads to:
	//	1) faster response after initial request -> better number of successful upload sessions
	//	2) reduced delay between some packets -> smoother upload -> less possibility of connection loss
		Requested_Block_Struct	   *pCurrBlk = m_blockRequestsQueue.front();

		srcfile = g_App.m_pSharedFilesList->GetFileByID(pCurrBlk->m_fileHash);

		if (srcfile == NULL)
		{
			CString		strError;

			eBPCResult = BPCR_FAILED_FILE_ERROR;
			strError.Format(_T("requested file not found, hash: %s"), HashToString(pCurrBlk->m_fileHash));
			throw strError;
		}

	//	Update the file hash to the requested file
		md4cpy(m_reqFileHash, pCurrBlk->m_fileHash);

	//	Check that block start is within the file
		if (pCurrBlk->qwStartOffset >= srcfile->GetFileSize())
		{
			CString		strError;

			eBPCResult = BPCR_FAILED_FILE_ERROR;
			strError.Format( _T("request data %#I64x-%#I64x beyond the file end %#I64x '%s'"),
				pCurrBlk->qwStartOffset, pCurrBlk->qwEndOffset, srcfile->GetFileSize(), srcfile->GetFileName());
			throw strError;
		}

		uint32 dwPart = static_cast<uint32>(pCurrBlk->qwStartOffset / PARTSIZE);

	//	Accessing a blocked part ?
		if (!srcfile->GetJumpstartEnabled() && !srcfile->IsPartShared(dwPart))
		{
			CString		strError;

			AddLogLine(0, IDS_PARTPRIO_DENIED, dwPart, srcfile->GetFileName());
			strError.Format(GetResString(IDS_PARTPRIO_DENIED), dwPart, srcfile->GetFileName());
			eBPCResult = BPCR_FAILED_BLOCKED_PART;
			throw strError;
		}

		uint32 dwToGo;
		uint64 qwStart = static_cast<uint64>(dwPart) * PARTSIZE;
		uint64 qwEnd = ((qwStart + PARTSIZE) > srcfile->GetFileSize()) ? srcfile->GetFileSize() : (qwStart + PARTSIZE);

	//	Everyone is limited to a single chunk (some functions below were also optimized for that)
	//	Check that m_dwStartOffset and m_dwEndOffset are in the same chunk and
	//	make sure we don't pass the end of the file.
		if ( (dwPart != static_cast<uint32>((pCurrBlk->qwEndOffset - 1ui64) / PARTSIZE)) ||
			(pCurrBlk->qwEndOffset > qwEnd) )
		{
		//	m_dwEndOffset goes into the next chunk or is beyond the file end.
		//	Set it to the end of the chunk that m_dwStartOffset is in.
			pCurrBlk->qwEndOffset = qwEnd;
		}

	//	This can't be a wrapped around request, since it has been limited to a single chunk
		dwToGo = static_cast<uint32>(pCurrBlk->qwEndOffset - pCurrBlk->qwStartOffset);

		if (dwToGo > (3 * EMBLOCKSZ32))
		{
			CString	strError;

			strError.Format(_T("requested block too large %u"), dwToGo);
			eBPCResult = BPCR_FAILED_FILE_ERROR;
			throw strError;
		}
		if (srcfile->IsPartFile())
		{
			if (!(reinterpret_cast<CPartFile*>(srcfile))->IsPartComplete(dwPart))
			{
				CString		strError;

				strError.Format(_T("asked for incomplete block from '%s'"), srcfile->GetFileName());
				eBPCResult = BPCR_FAILED_BLOCKED_PART;
				throw strError;
			}
		}

	//	Create a buffer for file data before we start to work with the file
		filedata = new byte[dwToGo + 500];

		int	iRc = srcfile->ReadFileForUpload(pCurrBlk->qwStartOffset, dwToGo, filedata);

		if (iRc < 0)
		{
		//	Error occurred
			CString		strError;

			strError.Format(_T("failed to open '%s'"), srcfile->GetFileName());
			eBPCResult = BPCR_FAILED_FILE_ERROR;
			throw strError;
		}

		md4cpy(m_reqFileHash, pCurrBlk->m_fileHash);

		bool bFromPF = (iRc) ? true : false;
		bool bPacketCreated, bCompress = false;

		if (m_byteDataCompVer == 1)
		{
			bCompress = srcfile->IsCompressedTransferAllowed();
		}

		if (bCompress)
			bPacketCreated = CreatePackedPackets(filedata, dwToGo, pCurrBlk, srcfile->GetULPriority(), bFromPF);
		else
			bPacketCreated = CreateStandardPackets(filedata, dwToGo, pCurrBlk, srcfile->GetULPriority(), bFromPF);

	//	Update the data only if packet was created
		if (bPacketCreated)
		{
		//	File statistic
			srcfile->statistic.AddTransferred(dwToGo);
			srcfile->statistic.AddTraffic(dwPart, pCurrBlk->qwStartOffset, dwToGo);

			if (srcfile->GetJumpstartEnabled())
				srcfile->AddSentBlock(this, pCurrBlk->qwStartOffset, dwToGo);

			m_doneBlocksList.push_front(m_blockRequestsQueue.front());

			eBPCResult = BPCR_OK;
		}

		m_blockRequestsQueue.pop_front();
		delete[] filedata;
		filedata = NULL;
	}
//	Check for exception that will be throw by "new"
	catch (CMemoryException *error)
	{
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
		error->Delete();
		SetUploadFileID(NULL);
		return BPCR_FAILED_FILE_ERROR;
	}
	catch (CFileException *error)
	{
		OUTPUT_DEBUG_TRACE();
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
		SetUploadFileID(NULL);
		delete[] filedata;
		error->Delete();
		return BPCR_FAILED_FILE_ERROR;
	}
	catch (CString &strError)
	{
		OUTPUT_DEBUG_TRACE();
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Client %s caused an error while creating package (%s), disconnecting!"), GetClientNameWithSoftware(), strError);
		SetUploadFileID(NULL);
		delete[] filedata;
		return eBPCResult;
	}

	return eBPCResult;

	EMULE_CATCH

	return BPCR_FAILED_FILE_ERROR;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::CheckForUpPartsInfo()
{
	EMULE_TRY

	if ( m_uPartCount == 0 || m_pReqPartFile == NULL
		|| md4cmp(m_reqFileHash, m_pReqPartFile->GetFileHash())
		|| m_pbytePartStatuses == NULL )
	{
		return;
	}

	delete[] m_pbyteUpPartStatuses;
	m_pbyteUpPartStatuses = NULL;

	m_uUpPartCount = m_uPartCount;
	m_uAvailUpPartCount = 0;
	m_pbyteUpPartStatuses = new byte[m_uUpPartCount];

	for (int i = 0; i < m_uUpPartCount; i++)
	{
		m_pbyteUpPartStatuses[i] = m_pbytePartStatuses[i];

		if (m_pbyteUpPartStatuses[i] != 0)
			m_uAvailUpPartCount++;
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ProcessExtendedInfo - processes extended information about uploading file
//	Return:	false - received packet is for a wrong file, otherwise true
bool CUpDownClient::ProcessExtendedInfo(CSafeMemFile *pPktStream, CKnownFile *pKnownFile)
{
	delete[] m_pbyteUpPartStatuses;
	m_pbyteUpPartStatuses = NULL;
	m_uUpPartCount = 0;
	m_uAvailUpPartCount = 0;
	m_uUpCompleteSourcesCount = 0;
	if (GetExtendedRequestsVersion() == 0)
	{
		CheckForUpPartsInfo();
		return true;
	}

	uint16			uED2KUpPartCount;

	pPktStream->Read(&uED2KUpPartCount, 2);
	m_uUpPartCount = pKnownFile->GetPartCount();

	if (uED2KUpPartCount == 0)
	{
		m_pbyteUpPartStatuses = new byte[m_uUpPartCount];
		memzero(m_pbyteUpPartStatuses, m_uUpPartCount);
	}
	else
	{
		m_fNoDataForRemoteClient = 1;
		if (pKnownFile->GetED2KPartCount() != uED2KUpPartCount)
		{
			m_uUpPartCount = 0;
			return false;
		}

		m_pbyteUpPartStatuses = new byte[m_uUpPartCount];

		uint32	dwDone = 0, dwUpPartCnt = static_cast<uint32>(m_uUpPartCount);
		byte	byteToRead;

		while (dwDone < dwUpPartCnt)
		{
			pPktStream->Read(&byteToRead, 1);
			for (unsigned ui = 0; ui < 8; ui++)
			{
				m_pbyteUpPartStatuses[dwDone] = static_cast<byte>((byteToRead >> ui) & 1);
				if (m_pbyteUpPartStatuses[dwDone])
					m_uAvailUpPartCount++;
				else
				{
					if (pKnownFile->IsPartShared(dwDone))
						m_fNoDataForRemoteClient = 0;
				}
				if (++dwDone == dwUpPartCnt)
					break;
			}
		}

		if (GetExtendedRequestsVersion() > 1)
		{
			uint16	uCompleteCountLast = GetUpCompleteSourcesCount();
			uint16	uCompleteCountNew;

			pPktStream->Read(&uCompleteCountNew, 2);
			SetUpCompleteSourcesCount(uCompleteCountNew);
			if (uCompleteCountLast != uCompleteCountNew)
				pKnownFile->CalculateCompleteSources();
		}
	}
	g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(this);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::CreateStandardPackets(byte *pbyteFileData, uint32 dwToGo, Requested_Block_Struct *pCurrBlk, byte byteFilePriority, bool bFromPF /*= true*/)
{
	EMULE_TRY

	uint32		dwPacketSize;
	CMemFile	memfile(pbyteFileData, dwToGo);
	PacketDeque	blockSendTempQueue;
	Packet		*pPacket;

	if (dwToGo > 10240)
		dwPacketSize = dwToGo / (dwToGo / 10240u);
	else
		dwPacketSize = dwToGo;

	while (dwToGo != 0)
	{
		if (dwToGo < dwPacketSize * 2)
			dwPacketSize = dwToGo;

		dwToGo -= dwPacketSize;

		uint64 qwEnd = pCurrBlk->qwEndOffset - static_cast<uint64>(dwToGo);
		uint64 qwStart = qwEnd - static_cast<uint64>(dwPacketSize);

		if (qwEnd > 0xFFFFFFFFui64)		//	Start is always < End
		{
			pPacket = new Packet(OP_SENDINGPART_I64, dwPacketSize + 32, OP_EMULEPROT, byteFilePriority, bFromPF);
			md4cpy(&pPacket->m_pcBuffer[0], m_reqFileHash);
			POKE_QWORD(&pPacket->m_pcBuffer[16], qwStart);
			POKE_QWORD(&pPacket->m_pcBuffer[24], qwEnd);
		//	Append the file data to the packet
			memfile.Read(&pPacket->m_pcBuffer[32], dwPacketSize);
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(32);
		}
		else
		{
			pPacket = new Packet(OP_SENDINGPART, dwPacketSize + 24, OP_EDONKEYPROT, byteFilePriority, bFromPF);
			md4cpy(&pPacket->m_pcBuffer[0], m_reqFileHash);
			POKE_DWORD(&pPacket->m_pcBuffer[16], static_cast<uint32>(qwStart));
			POKE_DWORD(&pPacket->m_pcBuffer[20], static_cast<uint32>(qwEnd));
		//	Append the file data to the packet
			memfile.Read(&pPacket->m_pcBuffer[24], dwPacketSize);
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(24);
		}

	//	If the split was successful, then move the split packets to the global queue
		if (SplitAndAddPacketsToSendQueue(pPacket, &blockSendTempQueue, byteFilePriority, bFromPF))
		{
		//	Attach split packets to the global queue
			while (!blockSendTempQueue.empty())
			{
				m_blockSendQueue.push_back(blockSendTempQueue.front());
				blockSendTempQueue.pop_front();
			}
		}
		else
		{
			while (!blockSendTempQueue.empty())
			{
				delete blockSendTempQueue.front();
				blockSendTempQueue.pop_front();
			}
		}
	}

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::CreatePackedPackets(byte *pbyteFileData, uint32 dwToGo, Requested_Block_Struct *pCurrBlk, byte byteFilePriority, bool bFromPF /*= true*/)
{
	EMULE_TRY

	BYTE	*output = new BYTE[dwToGo + 300];
	uLongf	newsize = dwToGo + 300;
	int		iResult = compress2(output, &newsize, pbyteFileData, dwToGo, 9);

	if ((iResult != Z_OK) || (dwToGo <= newsize))
	{
		delete[] output;
		return CreateStandardPackets(pbyteFileData, dwToGo, pCurrBlk, byteFilePriority, bFromPF);
	}

	CMemFile	memfile(output, newsize);
	PacketDeque	blockSendTempQueue;
	uint32		dwPacketSize;
	Packet		*pPacket;

//	Update the compression statistic
	m_dwCompressionGain += (dwToGo - newsize);
	m_dwUncompressed += dwToGo;

	dwToGo = newsize;
	if (dwToGo > 10240)
		dwPacketSize = dwToGo / (uint32)(dwToGo / 10240);
	else
		dwPacketSize = dwToGo;

	while (dwToGo != 0)
	{
		if (dwToGo < dwPacketSize * 2)
			dwPacketSize = dwToGo;

		dwToGo -= dwPacketSize;

		if (pCurrBlk->qwEndOffset > 0xFFFFFFFFui64)		//	Start is always < End
		{
			pPacket = new Packet(OP_COMPRESSEDPART_I64, dwPacketSize + 28, OP_EMULEPROT, byteFilePriority, bFromPF);
			md4cpy(&pPacket->m_pcBuffer[0], m_reqFileHash);
			POKE_QWORD(&pPacket->m_pcBuffer[16], pCurrBlk->qwStartOffset);
			POKE_DWORD(&pPacket->m_pcBuffer[24], newsize);
			memfile.Read(&pPacket->m_pcBuffer[28], dwPacketSize);
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(28);
		}
		else
		{
			pPacket = new Packet(OP_COMPRESSEDPART, dwPacketSize + 24, OP_EMULEPROT, byteFilePriority, bFromPF);
			md4cpy(&pPacket->m_pcBuffer[0], m_reqFileHash);
			POKE_DWORD(&pPacket->m_pcBuffer[16], static_cast<uint32>(pCurrBlk->qwStartOffset));
			POKE_DWORD(&pPacket->m_pcBuffer[20], newsize);
			memfile.Read(&pPacket->m_pcBuffer[24], dwPacketSize);
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(24);
		}

	//	If one of the split action was failed, then cancel whole packet creation, cause otherwise Z-stream on other side will be corrupted
		if (!SplitAndAddPacketsToSendQueue(pPacket, &blockSendTempQueue, byteFilePriority, bFromPF))
		{
			while (!blockSendTempQueue.empty())
			{
				delete blockSendTempQueue.front();
				blockSendTempQueue.pop_front();
			}
			delete[] output;
			return false;
		}
	}
	delete[] output;

//	Attach split packets to global queue
	while (!blockSendTempQueue.empty())
	{
		m_blockSendQueue.push_back(blockSendTempQueue.front());
		blockSendTempQueue.pop_front();
	}

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A packet should never be larger than MAXFRAGSIZE. This method splits up the
// given packets into several packets with the size MAXFRAGSIZE, if necessary.
bool CUpDownClient::SplitAndAddPacketsToSendQueue(Packet *pPacket, PacketDeque *pSendQueue, byte byteFilePriority, bool bFromPF)
{
	EMULE_TRY

	if (pPacket->GetRealPacketSize() > 0 && pPacket->GetRealPacketSize() > MAXFRAGSIZE * 2)
	{
	//	Splitting packets
		uint32		dwSize = pPacket->GetRealPacketSize();
		char	   *m_pcBuffer = pPacket->DetachPacket();

		delete pPacket;

		uint32	dwPos = 0;
		int		iAllocationTries = 0;

		while (dwPos < dwSize && iAllocationTries < 3)
		{
			char	   *pBuffer2 = NULL;
			Packet	   *pPacket = NULL;
			uint32		dwNewSz = (dwSize - dwPos < MAXFRAGSIZE) ? dwSize - dwPos : MAXFRAGSIZE;

			try
			{
				pBuffer2 = new char[dwNewSz];
				pPacket = new Packet(pBuffer2, dwNewSz, (dwSize - dwPos) <= MAXFRAGSIZE, byteFilePriority, bFromPF);
			//	To optimize handling in case of failed packet allocation, let's copy the data after packet creation
				memcpy2(pBuffer2, m_pcBuffer + dwPos, dwNewSz);
			//	Put packet in temporary queue
				pSendQueue->push_back(pPacket);
			//	Update the data pointer for next fragment only if packet allocation was successful
			//	in this case we can retry to allocate the packet again
				dwPos += dwNewSz;
				iAllocationTries = 0;
			}
			catch (CMemoryException *error)
			{
				error->Delete();
				delete[] pBuffer2;
				iAllocationTries++;
			}
		}
		delete[] m_pcBuffer;

	//	If the split was failed due to problem with memory allocation report it back
		if (iAllocationTries != 0)
			return false;
	}
	else
	{
		m_blockSendQueue.push_back(pPacket);
	}

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetUploadFileID(uchar *pbyteReqFileID)
{
	if (pbyteReqFileID != NULL)
		md4cpy(m_reqFileHash, pbyteReqFileID);
	else
		md4clr(m_reqFileHash);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::AddReqBlock(Requested_Block_Struct *pReqBlock)
{
	EMULE_TRY

	ReqBlockDeque::iterator		itBlock;
	Requested_Block_Struct	   *pTmpBlock;

	for (itBlock = m_doneBlocksList.begin(); itBlock != m_doneBlocksList.end(); itBlock++)
	{
		pTmpBlock = *itBlock;
		if ( (pTmpBlock != NULL) && (pReqBlock->qwStartOffset == pTmpBlock->qwStartOffset)
			&& (pReqBlock->qwEndOffset == pTmpBlock->qwEndOffset) )
		{
			return;
		}
	}

	for (itBlock = m_blockRequestsQueue.begin(); itBlock != m_blockRequestsQueue.end(); itBlock++)
	{
		pTmpBlock = *itBlock;
		if ( (pTmpBlock != NULL) && (pReqBlock->qwStartOffset >= pTmpBlock->qwStartOffset)
			&& (pReqBlock->qwEndOffset <= pTmpBlock->qwEndOffset) )
		{
		//	Except identical request, drop also nested requests sent by some buggy clients
			return;
		}
	}

	pTmpBlock = new Requested_Block_Struct;

	memcpy(pTmpBlock, pReqBlock, sizeof(Requested_Block_Struct));
	m_blockRequestsQueue.push_back(pTmpBlock);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetWaitStartTime()
{
	if (m_pCredits == NULL)
		return;

	m_pCredits->SetSecWaitStartTime(GetIP());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// m_dwWaitTime
uint32 CUpDownClient::GetWaitStartTime() const
{
	if (m_pCredits == NULL)
		return 0;

	uint32 dwSecureTime = m_pCredits->GetSecureWaitStartTime(GetIP());

	if (IsDownloading() && (dwSecureTime > m_dwUploadTime))
		dwSecureTime = m_dwUploadTime - 1;

	return dwSecureTime;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUpDownClient::SendBlockData(uint32 dwMaxAmount, EnumBlockSendResult& eResult)
{
	eResult = BSR_FAILED_CLIENT_LEFT_UQ;

	uint32	dwTimePeriod, dwAmountTransferred = 0;
	DWORD	curTick = GetTickCount();

	try
	{
	//	Check for 'stuck' clients
		if ((curTick - GetLastGotULData() > 2 * 60 * 1000) && (GetUpStartTimeDelay() > 2 * 60 * 1000))
		{
		//	We were unable to transfer for 2 minutes, just remove the client from UL queue
		//	If client stays online, he will request file & be added to the queue
			if (g_App.m_pPrefs->IsClientTransferLogEnabled())
				AddLogLine(LOG_FL_DBG, _T("Client %s appears to be stuck, putting back on queue"), GetClientNameWithSoftware());
			g_App.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
			return 0;
		}

#ifdef OLD_SOCKETS_ENABLED
	//	Only feed this slot new data if it has been able to empty its buffer since we last offered data
		if (m_pRequestSocket != NULL)
		{
			if (m_pRequestSocket->IsBusy())
			{
			//	Check block queues to separate the active client from just invited to upload
				if (m_blockRequestsQueue.empty() && m_blockSendQueue.empty())
					eResult = BSR_FAILED_NO_REQUESTED_BLOCKS;
				else
					eResult = BSR_BUSY;
			}
			else
			{
			//	1) Measure only already transferred data! the speed should be calculated before data transfer, otherwise
			//		not yet transferred data from current iteration will lead to higher(incorrect) speed value
			//	2) Use socket status to find out the correct time for the speed measurements, because any calculation of the average inbetween
			//		will decrease the calculated value, what does not reflect real situation
				m_averageUDRList.push_front(m_dwTransferredUp);
				m_averageULTickList.push_front(curTick);

			//	Don't store too much statistics. maximal 40 sec ~ socket timeout
				while ((dwTimePeriod = (curTick - m_averageULTickList.back())) > CONNECTION_TIMEOUT)
				{
					m_averageUDRList.pop_back();
					m_averageULTickList.pop_back();
				}

			//	Calculate average data rate
				uint32 dwCurUpDataRate = 0;

			//	Leave this slot's speed as 0 unless there's a good chunk of stored statistics for it (at least 10 samples ~ 1 sec).
				if (dwTimePeriod > 1000)
				{
					dwCurUpDataRate = static_cast<uint32>((static_cast<double>(m_averageUDRList.front() - m_averageUDRList.back())) * 1000.0 / dwTimePeriod);
				}

			//	Assign & update only if values are different
				if (m_dwUpDataRate != dwCurUpDataRate)
				{
					m_dwUpDataRate = dwCurUpDataRate;
					g_App.m_pMDlg->m_wndTransfer.m_ctlUploadList.UpdateClient(this);
				}

				if (GetUploadState() == US_UPLOADING)
				{
					if (m_blockSendQueue.empty())
					{
					// If all packets were sent, try to create a new one
						EnumBlockPacketCreationResult	eBPCResult = CreateNextBlockPackage();

						if (eBPCResult != BPCR_OK)
						{
						//	If packets creation was failed, client can be removed without data loss
							if (eBPCResult == BPCR_FAILED_NO_REQUESTED_BLOCKS)
							{
							//	If client did not request data, keep him in the queue & give him a chance to request something
							//	The client will be removed from UL queue after 2 min.
								eResult = BSR_FAILED_NO_REQUESTED_BLOCKS;
								return 0;
							}
							else if (eBPCResult == BPCR_FAILED_BLOCKED_PART)
							{
								if (g_App.m_pPrefs->IsClientTransferLogEnabled())
									AddLogLine(LOG_FL_DBG, _T("Client %s left UL queue after receiving %u KB. Asked for new or blocked chunk/file"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
								g_App.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
							}
							else if (eBPCResult == BPCR_FAILED_FILE_ERROR)
							{
								if (g_App.m_pPrefs->IsClientTransferLogEnabled())
									AddLogLine(LOG_FL_DBG, _T("Client %s left UL queue after receiving %u KB. Asked for inaccessible data (file removed, wrong request, etc)"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
								g_App.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
							}
							else
							{
								if (g_App.m_pPrefs->IsClientTransferLogEnabled())
									AddLogLine(LOG_FL_DBG, _T("Client %s left UL queue after receiving %u KB. Upload timeout (low speed, no block request)"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
								g_App.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
							}

						//	Notify the remote client about the end of the session
						//	Note (offical): 
						//		OP_OUTOFPARTREQS will tell the downloading client to go back to OnQueue..
						//		The main reason for this is that if we put the client back on queue and it goes
						//		back to the upload before the socket times out... We get a situation where the
						//		downloader thinks it already sent the requested blocks and the uploader thinks
						//		the downloader didn't send any request blocks. Then the connection times out..
						//	Note (eMule Plus):
						//		eMule Plus is also using OP_QUEUERANKING to detect the end of the session
							Packet	   *pCancelTransferPacket = new Packet(OP_OUTOFPARTREQS, 0);

							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pCancelTransferPacket->m_dwSize);
							m_pRequestSocket->SendPacket(pCancelTransferPacket, true, true);

							g_App.m_pUploadQueue->AddClientToWaitingQueue(this, true);

							return 0;
						}
					}

				//	Feed data to this slot, one block at a time, as long as there's enough bandwidth left
				//	for the entire next block. There must also be blocks to send (not empty request queue)
					while (!m_blockSendQueue.empty())
					{
					//	Get next block and give it to the Request Socket for transfer
						Packet	   *pPacket = m_blockSendQueue.front();
						uint32		dwBlockSize = pPacket->GetRealPacketSize();

						if (dwBlockSize + dwAmountTransferred > dwMaxAmount)
							break;

						m_blockSendQueue.pop_front();

					//	Extended statistics information based on which client software and which port we sent this data to.
					//	This also updates the grand total for sent bytes, etc. And where this data came from.
					//	We have to call function before packet will be sent, otherwise packet will be deleted.
						g_App.m_pPrefs->Add2SessionUpTransferData( GetClientSoft(), pPacket->IsFromPF(),
							dwBlockSize, IsCommunity(), pPacket->GetFilePriority() );
						m_pRequestSocket->SendPacket(pPacket, true, false);
						pPacket = NULL;

					//	We've transferred some data. Store this in relevant statistics variables
						m_dwTransferredUp += dwBlockSize;
						dwAmountTransferred += dwBlockSize;
						m_pCredits->AddUploaded(dwBlockSize, this->GetIP());

					//	If we're out of prepared blocks, create some more
						if (m_blockSendQueue.empty())
							CreateNextBlockPackage();
					}

				//	Check result of the data transfer
					if (dwAmountTransferred == 0)
					{
					//	The size of the packet is larger than allowed bandwidth
						eResult = BSR_FAILED_NOT_ENOUGHT_BANDWIDTH;
					}
					else
					{
						if (!m_blockSendQueue.empty())
						//	If this slot wasn't given enough data to empty its request queue, it wants more data.
							eResult = BSR_OK_WANTS_MORE_BANDWIDTH;
						else
						//	Very rare case, the size of the packets fits the bandwidth
							eResult = BSR_OK;

					//	Remember when this connection was last fed some data, so we
					//	can make sure we give it data often enough to not time out.
						SetLastGotULData();
					}
				}
			}
		}
		else
		{
			AddLogLine(LOG_FL_DBG, _T("CUpDownClient::SendBlockData (socket doesn't exist)"));
			Disconnected(false);
			return 0;
		}
#endif //OLD_SOCKETS_ENABLED
	}
//	In case of exception, disconnect the client
	catch(CException *err)
	{
		g_App.m_pMDlg->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(err));
		err->Delete();
		Disconnected(false);
	}
	catch(...)
	{
		Disconnected(false);
	}

	return dwAmountTransferred;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FlushSendBlocks() sends the rest of the last block queued for upload to this client if it has been split
//	across multiple packets. Call this when you stop uploading or the request socket is not able to send.
void CUpDownClient::FlushSendBlocks()
{
	EMULE_TRY

	if ((m_pRequestSocket != NULL) && m_pRequestSocket->TruncateQueues())
		return;

	bool	bBreak = false;

#ifdef OLD_SOCKETS_ENABLED
	while ( !m_blockSendQueue.empty() && m_blockSendQueue.front()->IsSplit() &&
			m_pRequestSocket != NULL && m_pRequestSocket->IsConnected() && !bBreak )
	{
		Packet	   *pPacket = m_blockSendQueue.front();

		m_blockSendQueue.pop_front();
		bBreak = pPacket->IsLastSplit();

		g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
		m_pRequestSocket->SendPacket(pPacket, true, false);
	}
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendHashsetPacket(byte *pbytePacket)
{
	EMULE_TRY

	CKnownFile		*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pbytePacket);

	if (pKnownFile == NULL)
	{
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Client %s: requested hashset for not shared file (hash: %s)"), GetClientNameWithSoftware(), HashToString(pbytePacket));
	//	Cause OP_HASHSETREQUEST can be abused for file-scanning
		UpdateFailedFileRequests();
		return;
	}

	uint16		uPartCount = pKnownFile->GetHashCount();
	uint32		dwHashSetLength = 16 * uPartCount;
	CMemFile	pbyteFileData(16 + 2 + dwHashSetLength);

	pbyteFileData.Write(pKnownFile->GetFileHash(), 16);
	pbyteFileData.Write(&uPartCount, 2);

	if (uPartCount != 0 && pKnownFile->GetHashSet() != NULL)
		pbyteFileData.Write(pKnownFile->GetHashSet(), dwHashSetLength);

	Packet	   *pPacket = new Packet(&pbyteFileData);

	pPacket->m_eOpcode = OP_HASHSETANSWER;
	g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED

	m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ClearUploadBlockRequests()
{
	EMULE_TRY

	while (!m_blockRequestsQueue.empty())
	{
		delete m_blockRequestsQueue.front();
		m_blockRequestsQueue.pop_front();
	}

	while (!m_blockSendQueue.empty())
	{
		delete m_blockSendQueue.front();
		m_blockSendQueue.pop_front();
	}

	while (!m_doneBlocksList.empty())
	{
		delete m_doneBlocksList.front();
		m_doneBlocksList.pop_front();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendRankingInfo()
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket == NULL)
		return;

#endif //OLD_SOCKETS_ENABLED
	if (!ExtProtocolAvailable())
		return;

	uint16 uRank = g_App.m_pUploadQueue->GetWaitingPosition(this);

	if (uRank == 0)
		return;

	Packet	   *pPacket = new Packet(OP_QUEUERANKING, 12, OP_EMULEPROT);

	memset(pPacket->m_pcBuffer, 0, 12);
	*reinterpret_cast<uint16 *>(pPacket->m_pcBuffer) = uRank;

	g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
	m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendCommentInfo(CKnownFile *pKnownFile)
{
	EMULE_TRY

	if (!m_bCommentDirty || pKnownFile == NULL || !ExtProtocolAvailable() || m_byteAcceptCommentVer < 1)
		return;

	m_bCommentDirty = false;

	byte 		byteRating = static_cast<byte>(pKnownFile->GetFileRating());

	if (byteRating == PF_RATING_NONE && pKnownFile->GetFileComment().IsEmpty())
		return;

	CMemFile	packetStream(256);
	uint32		dwLength;
	CStringA	strEncoded;

	packetStream.Write(&byteRating, sizeof(byteRating));			// <rating 1>
	dwLength = Str2MB(m_eStrCodingFormat, &strEncoded, pKnownFile->GetFileComment());
	packetStream.Write(&dwLength, sizeof(dwLength));		// <commentlen 4>
	packetStream.Write(strEncoded.GetString(), dwLength);	// (<commentchars 1>)*commentlen

	Packet	   *pPacket = new Packet(&packetStream, OP_EMULEPROT);

	pPacket->m_eOpcode = OP_FILEDESC;
	g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
	m_pRequestSocket->SendPacket(pPacket, true);
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::AddRequestCount(uchar *pbyteFileId)
{
	EMULE_TRY

	uint32 dwCurTick = ::GetTickCount();

	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL;)
	{
		Requested_File_Struct	   *pReqFile = static_cast<Requested_File_Struct*>(m_requestedFilesList.GetNext(pos));

		if (!md4cmp(pReqFile->m_fileHash, pbyteFileId))
		{
			if (dwCurTick - pReqFile->m_dwLastAskedTime < g_App.m_pPrefs->BadClientMinRequestTime())
			{
				if (GetDownloadState() != DS_DOWNLOADING)
					pReqFile->m_byteNumBadRequests++;
				if (pReqFile->m_byteNumBadRequests == g_App.m_pPrefs->BadClientMinRequestNum())
					Ban(BAN_CLIENT_AGGRESSIVE);
			}
			else if (pReqFile->m_byteNumBadRequests != 0)
				pReqFile->m_byteNumBadRequests--;
			pReqFile->m_dwLastAskedTime = dwCurTick;
			return;
		}
	}

//	If file was not found create a new file
	Requested_File_Struct	   *pNewFile = new Requested_File_Struct;

	md4cpy(pNewFile->m_fileHash, pbyteFileId);
	pNewFile->m_dwLastAskedTime = dwCurTick;
	pNewFile->m_byteNumBadRequests = 0;
	m_requestedFilesList.AddHead(pNewFile);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::UnBan()
{
	EMULE_TRY

	m_eBanState = BAN_CLIENT_NONE;
	m_dwBanTime = 0;

	SetWaitStartTime();
	g_App.m_pClientList->UpdateBanCounters();
	g_App.m_pMDlg->m_wndTransfer.UpdateUploadHeader();

	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL;)
	{
		Requested_File_Struct	   *pReqFile = static_cast<Requested_File_Struct*>(m_requestedFilesList.GetNext(pos));

		pReqFile->m_byteNumBadRequests = 0;
		pReqFile->m_dwLastAskedTime = 0;
	}
	g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(this);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CUpDownClient::GetBanString()
{
	static const UINT s_adwBanString[BAN_CLIENT_LAST] =
	{
		IDS_NO,					//BAN_CLIENT_NONE
		IDS_BAN_AGGRESSIVECLI,	//BAN_CLIENT_AGGRESSIVE
		IDS_BAN_LEECHERSPAM,	//BAN_CLIENT_SPAMMING
		IDS_BAN_HASHIMP,		//BAN_CLIENT_USE_OUR_HASH
		IDS_BAN_HASHSTEAL,		//BAN_CLIENT_HASH_STEALER
		IDS_BAN_LEECHERADV		//BAN_CLIENT_KWOWN_LEECHER
	};

	return GetResString(s_adwBanString[m_eBanState]);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::Ban(EnumBanState eReason)
{
	EMULE_TRY

	if (!g_App.m_pPrefs->BanEnabled())
	{
	//	If the ban function is disabled, no need to ban a client (default is enabled!)
		m_eBanState = BAN_CLIENT_NONE;
		m_dwBanTime = 0;
		return;
	}

	EnumBanState	ePrevBanState = m_eBanState;

	m_eBanState = eReason;	// Set it before queue operations and GetBanString()
	if (m_eUploadState == US_UPLOADING)
	{
	//	Kick already downloading client back to waitingqueue
		AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s banned and kicked out of uploadqueue (%s)"),
						GetClientNameWithSoftware(), GetBanString());
		g_App.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BAN, true);
		g_App.m_pUploadQueue->AddClientToWaitingQueue(this, true);
	}

	if (ePrevBanState != BAN_CLIENT_NONE)
	{
	//	No need to ban a client (and send a message) again except for extending the bantime
		m_dwBanTime = ::GetTickCount();
		return;
	}

	if (g_App.m_pPrefs->CommunityNoBanEnabled() && g_App.m_pPrefs->CommunityEnabled() && IsCommunity())
	{
		m_eBanState = ePrevBanState;	// Undo
		return;
	}

	SetChatState(MS_NONE);
	m_dwBanTime = ::GetTickCount();

	if (!g_App.m_pPrefs->IsCMNotLog())
		AddLogLine(LOG_RGB_DIMMED, IDS_CLIENTBLOCKED, GetUserName(), GetBanString());

	g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(this);
	g_App.m_pClientList->UpdateBanCounters();
	g_App.m_pMDlg->m_wndTransfer.UpdateUploadHeader();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendBanMessage()
{
	const TCHAR	*pcMsg;
	
	switch (m_eBanState)
	{
		case BAN_CLIENT_NONE:
		default:
			return;

		case BAN_CLIENT_AGGRESSIVE:
			pcMsg =
				_T("AUTOMATED MESSAGE: You're being banned because your client is ")
				_T("too aggressive.")
				_T(" Get more info at http://emuleplus.info/ban/");
			break;
		case BAN_CLIENT_SPAMMING:
			pcMsg =
				_T("AUTOMATED MESSAGE: You're being banned because your client is ")
				_T("spamming.")
				_T(" Get more info at http://emuleplus.info/ban/");
			break;
		case BAN_CLIENT_USE_OUR_HASH:
		case BAN_CLIENT_HASH_STEALER:
		case BAN_CLIENT_KWOWN_LEECHER:
			pcMsg =
				_T("AUTOMATED MESSAGE: You're being banned because your client is ")
				_T("leeching!")
				_T(" Get more info at http://emuleplus.info/ban/");
			break;
	}

	g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.StartSession(this, false);
	g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.SendMessage(pcMsg);
	g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.EndSession(this, false);

#if 1
	AddLogLine(LOG_FL_DBG | LOG_RGB_BLUE_GRAY, _T("Send a ban message to remote client %s (h=%s, bs=%x)"),
					GetClientNameWithSoftware(), HashToString(GetUserHash()), m_eBanState);
#endif
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUpDownClient::GetRemoteRatio()
{
	EMULE_TRY

//	This calculation is not very accurate for several reasons:
//	- We do not know the file priority
//	- We do not save the client info if he has nothing uploaded to us
//	- Other factores like community etc

	double dblBaseValue = 100.0;

#ifdef OLD_SOCKETS_ENABLED
	if (g_App.m_pServerConnect->IsLowID())
		dblBaseValue *= 0.8;

#endif //OLD_SOCKETS_ENABLED
	CKnownFile	   *pKnownReqFile = g_App.m_pSharedFilesList->GetFileByID(m_reqFileHash);

	dblBaseValue *= GetRemoteBaseModifier();
//	Official client doesn't have SF/RF push
	if ((pKnownReqFile != NULL) && (GetClientSoft() == SO_PLUS))
	{
		dblBaseValue *= pKnownReqFile->GetSizeRatio();
		dblBaseValue *= pKnownReqFile->GetPopularityRatio();
	}
	return static_cast<uint32>(dblBaseValue);

	EMULE_CATCH

	return 100;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double CUpDownClient::GetRemoteBaseModifier()
{
	EMULE_TRY

//	This calculation is not very accurate for some reasons...
//	Crashes can cause that either client can not write its client data.
//	This can cause differences of the client data at the two clients.
	if (m_pCredits == reinterpret_cast<CClientCredits*>(-1))
		m_pCredits = NULL;

	if (m_pCredits != NULL)
		return m_pCredits->GetScoreRatio(GetIP(), true);

	EMULE_CATCH

	return 1.0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUpDownClient::GetCurrentlyUploadingPart()
{
	EMULE_TRY

	if (!m_doneBlocksList.empty())
	{
	//	Do we need to check upload state here?
		Requested_Block_Struct		*pFirstDoneBlock = m_doneBlocksList.front();

	//	Calculate which part the block is in
		return static_cast<uint32>(pFirstDoneBlock->qwStartOffset / PARTSIZE);
	}

	EMULE_CATCH

	return 0xFFFF;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetUploadState(EnumULQState eUploadState)
{
	if (eUploadState != m_eUploadState)
	{
		if (m_eUploadState == US_UPLOADING)
		{
		//	Update connection time not to drop sources accidently (we might transfer for hours)
		//	as this time is used to remove inactive LowID sources in PartFile:Process()
			m_dwEnteredConnectedState = ::GetTickCount();
		}
		if (eUploadState == US_UPLOADING)
		{
		//	Erase previous session upload rate statistics
			m_dwUpDataRate = 0;
			m_averageUDRList.clear();
			m_averageULTickList.clear();
		}
		m_eUploadState = eUploadState;
		g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.UpdateClient(this);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::LeaveSourceLists()
{
	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL;)
	{
		Requested_File_Struct	   *pReqFile = static_cast<Requested_File_Struct*>(m_requestedFilesList.GetNext(pos));
		CKnownFile *pSharedFile = g_App.m_pSharedFilesList->GetFileByID((uchar*)pReqFile->m_fileHash);

		if (pSharedFile != NULL)
			pSharedFile->RemoveClientFromSourceList(this);
	}
}
@


1.321
log
@Corrected code to suppress compiler warning.
@
text
@d1170 4
a1173 12
		pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);

	// File isn't in the download list either or hashset wasn't received yet
		if ((pKnownFile == NULL) || (pKnownFile->GetHashSet() == NULL))
		{
			AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Client %s: requested file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(pbytePacket));
		//	Cause OP_HASHSETREQUEST can be abused for file-scanning
			UpdateFailedFileRequests();
			return;
		}
	//	Hybrids request hashset even when we don't have complete chunks
	//	If hashset is available, give them what they want to stop wave of requests
@


1.320
log
@Reduced H-file dependency.
@
text
@d1427 1
@


1.319
log
@Reduced H-file dependency.
@
text
@d30 3
@


1.318
log
@Don't transmit for nested/overlapping data requests (no traffic waste for buggy clients).
@
text
@d28 1
@


1.317
log
@Protect against too large block requests.
@
text
@d896 2
a897 2
		if ( (pTmpBlock != NULL) && (pReqBlock->qwStartOffset == pTmpBlock->qwStartOffset)
			&& (pReqBlock->qwEndOffset == pTmpBlock->qwEndOffset) )
d899 1
@


1.316
log
@Unified ProcessExtendedInfo processing.
@
text
@d449 8
d538 1
a538 1
		AddLogLine(LOG_FL_DBG, _T("Client %s caused an error while creating package (%s), disconnecting!"), GetClientNameWithSoftware(), strError);
d905 1
a905 1
	memcpy2(pTmpBlock, pReqBlock, sizeof(Requested_Block_Struct));
@


1.315
log
@Identity thief countermeasures {Fuxie - DK/muleteer/Bro-DK}.
@
text
@d573 1
a573 1
bool CUpDownClient::ProcessExtendedInfo(byte *pbytePacket, uint32 dwPacketSz, CKnownFile *pKnownFile)
a585 2
//	Skip hash, it was already processed by the caller
	CSafeMemFile	packetStream(reinterpret_cast<BYTE*>(pbytePacket + 16), dwPacketSz - 16);
d588 1
a588 1
	packetStream.Read(&uED2KUpPartCount, 2);
d612 1
a612 1
			packetStream.Read(&byteToRead, 1);
d633 1
a633 1
			packetStream.Read(&uCompleteCountNew, 2);
@


1.314
log
@Simplified logging system implementation.
@
text
@d227 2
@


1.313
log
@Reduced H-file dependency.
@
text
@d363 1
a363 1
				AddDebugLogLine(_T("Client %s downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend"), GetClientNameWithSoftware(), this->GetSessionUp() / 1024);
d382 1
a382 1
			AddDebugLogLine(_T("Client %s continues downloading (should be back on queue) because of a low transferred size"), GetClientNameWithSoftware());
d423 1
a423 1
			AddLogLine(false, IDS_PARTPRIO_DENIED, dwPart, srcfile->GetFileName());
d511 1
a511 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d519 1
a519 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d528 1
a528 1
		AddDebugLogLine(_T("Client %s caused an error while creating package (%s), disconnecting!"), GetClientNameWithSoftware(), strError);
d940 1
a940 1
				AddDebugLogLine(_T("Client %s appears to be stuck, putting back on queue"), GetClientNameWithSoftware());
d1009 1
a1009 1
									AddDebugLogLine(_T("Client %s left UL queue after receiving %u KB. Asked for new or blocked chunk/file"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
d1015 1
a1015 1
									AddDebugLogLine(_T("Client %s left UL queue after receiving %u KB. Asked for inaccessible data (file removed, wrong request, etc)"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
d1021 1
a1021 1
									AddDebugLogLine(_T("Client %s left UL queue after receiving %u KB. Upload timeout (low speed, no block request)"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
d1100 1
a1100 1
			AddDebugLogLine(_T("CUpDownClient::SendBlockData (socket doesn't exist)"));
d1162 1
a1162 1
			AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Client %s: requested file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(pbytePacket));
d1375 2
a1376 3
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s banned and kicked out of uploadqueue (%s)"),
						GetClientNameWithSoftware(),
						GetBanString());
d1398 1
a1398 1
		AddLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_CLIENTBLOCKED), GetUserName(), GetBanString());
d1443 2
a1444 4
	AddDebugLogLine(RGB_BLUE_GRAY_TXT _T("Send a ban message to remote client %s (h=%s, bs=%x)"),
					GetClientNameWithSoftware(),
					HashToString(GetUserHash()),
					m_eBanState);
@


1.312
log
@Fixed incorrect destructor for allocated buffer; Removed useless checks around delete operator.
@
text
@d26 1
@


1.311
log
@Use preferences variable directly.
@
text
@d520 1
a520 2
		if (filedata != NULL)
			delete[] filedata;
d529 1
a529 2
		if (filedata != NULL)
			delete[] filedata;
d551 2
a552 5
	if (m_pbyteUpPartStatuses)
	{
		delete[] m_pbyteUpPartStatuses;
		m_pbyteUpPartStatuses = NULL;
	}
d837 1
a837 1
				safe_delete(pBuffer2);
a839 1

@


1.310
log
@improved comment processing
@
text
@d1303 1
a1303 1
				if (pReqFile->m_byteNumBadRequests == BADCLIENTBAN)
@


1.309
log
@Added support to send Unicode file comment.
@
text
@d1262 1
a1262 2
	EnumPartFileRating	eRating = pKnownFile->GetFileRating();
	CString				strDesc = pKnownFile->GetFileComment();
d1264 1
a1264 1
	if (eRating == PF_RATING_NONE && strDesc.IsEmpty())
d1271 2
a1272 3
	packetStream.Write(&eRating, sizeof(eRating));			// <rating 1>
	Str2MB(m_eStrCodingFormat, &strEncoded, strDesc);
	dwLength = strEncoded.GetLength();
@


1.308
log
@Simplified transfer statistics gathering; Suppressed compiler warnings.
@
text
@d1268 3
a1270 1
	CSafeMemFile		packetStream(256);
d1273 2
a1274 6

	uint32		dwLength = strDesc.GetLength();

	if (dwLength > 128)
		dwLength = 128;

d1276 1
a1276 3

	if (dwLength > 0)
		packetStream.Write(strDesc.GetString(), dwLength);	// (<commentchars 1>)*commentlen
@


1.307
log
@Reduced #include dependency; Removed double #include; Minor loop optimization.
@
text
@d1066 2
a1067 6
						g_App.m_pPrefs->Add2SessionTransferData( GetClientSoft(),
																pPacket->IsFromPF(),
																TRANSFERTYPE_UPLOAD,
																dwBlockSize,
																IsCommunity(),
																pPacket->GetFilePriority() );
d1462 1
a1462 1
uint16 CUpDownClient::GetRemoteRatio()
@


1.306
log
@Slightly increased upload limit.
@
text
@d27 1
a27 1
#include "math.h"
d611 2
a612 1
		uint16	uDone = 0;
d614 1
a614 1
		while (uDone != m_uUpPartCount)
a615 2
			byte	byteToRead;

d619 2
a620 3
				m_pbyteUpPartStatuses[uDone] = ((byteToRead >> ui) & 1) ? 1 : 0;

				if (m_pbyteUpPartStatuses[uDone])
d624 1
a624 1
					if (pKnownFile->IsPartShared(uDone))
d627 1
a627 3

				uDone++;
				if (uDone == m_uUpPartCount)
@


1.305
log
@Corrected previous modification of upload client rate calculation in case of consecutive upload sessions (reset was done on leaving upload queue instead of entering).
@
text
@d286 1
a286 1
		else if (GetSessionUp() < (PARTSZ32 / 2))
@


1.304
log
@Minor correction -- exclude part files with zero sources from being rare for upload limit (they are probably paused and can't be considered as rare -- not enough information to estimate them);
Fixed upload client rate calculation in case of consecutive upload sessions (rate data is reset on entering upload queue) {muleteer};
Slightly changed general upload limit to be aligned with chunk size for easier calculations.
@
text
@d1547 3
@


1.303
log
@Changed upload limits for rare files and friends;
Faster upload data block preparation.
@
text
@d284 1
a284 1
		if (GetSessionUp() < (2 * 1024 * 1024))
d294 4
a297 1
					if (reinterpret_cast<CPartFile*>(pKFile)->GetSourceCount() < RARE_FILE)
d1547 4
@


1.302
log
@removed the port statistic (part 2)
@
text
@d241 5
a245 4
//	[Returns]
//	true : Next requested block is from another different chunk or file than last downloaded block
//	false: Next requested block is from same chunk that last downloaded block
bool CUpDownClient::IsDifferentPartBlock(bool bSilent /*= false*/)
d247 2
a248 1
	bool	bDiffPart = false;
d250 1
d254 1
a254 1
		if (!m_blockRequestsQueue.empty() && !m_doneBlocksList.empty())
d256 1
a256 2
		//	Get last and next pending blocks
			Requested_Block_Struct	*pLastDoneBlk = m_doneBlocksList.front();
d258 17
a274 7
		//	Calculate corresponding parts to blocks
			uint32	dwLastDonePart = static_cast<uint32>(pLastDoneBlk->qwStartOffset / PARTSIZE);
			uint32	dwNextReqPart = static_cast<uint32>(pNextReqBlk->qwStartOffset / PARTSIZE);

		//	Check that the same file and part are asked
			if (dwLastDonePart != dwNextReqPart || md4cmp(pLastDoneBlk->m_fileHash, pNextReqBlk->m_fileHash) != 0)
				bDiffPart = true;
d279 1
a279 1
		bDiffPart = true;
d282 1
a282 1
	if (bDiffPart)
a283 2
	//	obaldin: this is for old clients, that rotate the chunk, so that they'll be able to download at least _something_
	//	But probably even after the majority switches we'd better check for 0 here
d285 2
d288 15
a302 4
			bDiffPart = false;

			if (!bSilent && g_App.m_pPrefs->IsClientTransferLogEnabled())
				AddDebugLogLine(_T("Client %s continues downloading (should be back on queue) because of a low transferred size"), GetClientNameWithSoftware());
d306 1
a306 23
	return bDiffPart;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::IsForbiddenByJumpstart()
{
	EMULE_TRY

	Requested_Block_Struct	*pNextReqBlk;
	uint32	dwNextReqPart;

	if (!m_blockRequestsQueue.empty())
	{
		pNextReqBlk = m_blockRequestsQueue.front();
		dwNextReqPart = static_cast<uint32>(pNextReqBlk->qwStartOffset / PARTSIZE);
		CKnownFile* kf = g_App.m_pSharedFilesList->GetFileByID(pNextReqBlk->m_fileHash);

		if (kf != NULL && !kf->AllowChunkForClient(dwNextReqPart, this))
			return true;
	}

	EMULE_CATCH

	return false;
d342 8
a349 4
	bool bAllowedMore = IsOnLAN();
	bool bDifferentPart = IsDifferentPartBlock(true);
	bool bJSIsBlocked = IsForbiddenByJumpstart();
	bool bShouldContinue = ((GetUpStartTimeDelay() > SESSIONMAXTIME) || bDifferentPart);
d352 2
a353 1
	if (!bAllowedMore && bShouldContinue)
d355 1
a355 1
		if (IsFriend() && (GetSessionUp() < PARTSZ32) && !bJSIsBlocked)
d363 1
a363 3
			if (bDifferentPart)
				return BPCR_FAILED_BLOCKED_PART;
			else if (bJSIsBlocked)
d372 1
a372 1
	byte*			filedata = 0;
d377 2
d382 8
a389 5
	//	we gonna create just one requested block packet.
	//	This will lead to
	//		1) faster response after initial request -> better number of successful UL sessions
	//		2) reduced delay between some packets -> smoother upload -> less possibility of connection loss
		if ( (bAllowedMore || !IsDifferentPartBlock()) && !IsForbiddenByJumpstart() )
d391 1
a391 1
			Requested_Block_Struct	   *pCurrBlk = m_blockRequestsQueue.front();
d393 18
a410 1
			srcfile = g_App.m_pSharedFilesList->GetFileByID(pCurrBlk->m_fileHash);
d412 1
a412 3
			if (srcfile == NULL)
			{
				CString		strError;
d414 4
a417 4
				eBPCResult = BPCR_FAILED_FILE_ERROR;
				strError.Format(_T("requested file not found, hash: %s"), HashToString(pCurrBlk->m_fileHash));
				throw strError;
			}
d419 5
a423 2
		//	Update the file hash to the requested file
			md4cpy(m_reqFileHash, pCurrBlk->m_fileHash);
d425 3
a427 4
		//	Check that block start is within the file
			if (pCurrBlk->qwStartOffset >= srcfile->GetFileSize())
			{
				CString		strError;
d429 10
a438 5
				eBPCResult = BPCR_FAILED_FILE_ERROR;
				strError.Format( _T("request data %#I64x-%#I64x beyond the file end %#I64x '%s'"),
					pCurrBlk->qwStartOffset, pCurrBlk->qwEndOffset, srcfile->GetFileSize(), srcfile->GetFileName());
				throw strError;
			}
d440 2
a441 1
			uint32 dwPart = static_cast<uint32>(pCurrBlk->qwStartOffset / PARTSIZE);
d443 3
a445 2
		//	Accessing a blocked part ?
			if (!srcfile->GetJumpstartEnabled() && !srcfile->IsPartShared(dwPart))
d449 1
a449 2
				AddLogLine(false, IDS_PARTPRIO_DENIED, dwPart, srcfile->GetFileName());
				strError.Format(GetResString(IDS_PARTPRIO_DENIED), dwPart, srcfile->GetFileName());
d453 1
d455 2
a456 14
			uint32 dwToGo;
			uint64 qwStart = static_cast<uint64>(dwPart) * PARTSIZE;
			uint64 qwEnd = ((qwStart + PARTSIZE) > srcfile->GetFileSize()) ? srcfile->GetFileSize() : (qwStart + PARTSIZE);

		//	Everyone is limited to a single chunk (some functions below were also optimized for that)
		//	Check that m_dwStartOffset and m_dwEndOffset are in the same chunk and
		//	make sure we don't pass the end of the file.
			if ( (dwPart != static_cast<uint32>((pCurrBlk->qwEndOffset - 1ui64) / PARTSIZE)) ||
				(pCurrBlk->qwEndOffset > qwEnd) )
			{
			//	m_dwEndOffset goes into the next chunk or is beyond the file end.
			//	Set it to the end of the chunk that m_dwStartOffset is in.
				pCurrBlk->qwEndOffset = qwEnd;
			}
d458 1
a458 2
		//	This can't be a wrapped around request, since it has been limited to a single chunk
			dwToGo = static_cast<uint32>(pCurrBlk->qwEndOffset - pCurrBlk->qwStartOffset);
d460 4
a463 5
			if (srcfile->IsPartFile())
			{
				if (!(reinterpret_cast<CPartFile*>(srcfile))->IsPartComplete(dwPart))
				{
					CString		strError;
d465 4
a468 5
					strError.Format(_T("asked for incomplete block from '%s'"), srcfile->GetFileName());
					eBPCResult = BPCR_FAILED_BLOCKED_PART;
					throw strError;
				}
			}
d470 1
a470 2
		//	Create a buffer for file data before we start to work with the file
			filedata = new byte[dwToGo + 500];
d472 2
a473 1
			int	iRc = srcfile->ReadFileForUpload(pCurrBlk->qwStartOffset, dwToGo, filedata);
d475 4
a478 4
			if (iRc < 0)
			{
			//	Error occurred
				CString		strError;
d480 4
a483 4
				strError.Format(_T("failed to open '%s'"), srcfile->GetFileName());
				eBPCResult = BPCR_FAILED_FILE_ERROR;
				throw strError;
			}
d485 6
a490 1
			md4cpy(m_reqFileHash, pCurrBlk->m_fileHash);
d492 2
a493 2
			bool bFromPF = (iRc) ? true : false;
			bool bPacketCreated, bCompress = false;
d495 1
a495 4
			if (m_byteDataCompVer == 1)
			{
				bCompress = srcfile->IsCompressedTransferAllowed();
			}
d497 2
a498 4
			if (bCompress)
				bPacketCreated = CreatePackedPackets(filedata, dwToGo, pCurrBlk, srcfile->GetULPriority(), bFromPF);
			else
				bPacketCreated = CreateStandardPackets(filedata, dwToGo, pCurrBlk, srcfile->GetULPriority(), bFromPF);
d500 3
a502 19
		//	Update the data only if packet was created
			if (bPacketCreated)
			{
			//	File statistic
				srcfile->statistic.AddTransferred(dwToGo);
				srcfile->statistic.AddTraffic(dwPart, pCurrBlk->qwStartOffset, dwToGo);

				if (srcfile->GetJumpstartEnabled())
					srcfile->AddSentBlock(this, pCurrBlk->qwStartOffset, dwToGo);

				m_doneBlocksList.push_front(m_blockRequestsQueue.front());

				eBPCResult = BPCR_OK;
			}

			m_blockRequestsQueue.pop_front();
			delete[] filedata;
			filedata = 0;
		}
a1326 1
	memzero(pNewFile, sizeof(Requested_File_Struct));
d1329 1
d1555 1
a1555 1
		CKnownFile *m_pSharedFile = g_App.m_pSharedFilesList->GetFileByID((uchar*)pReqFile->m_fileHash);
d1557 2
a1558 2
		if (m_pSharedFile)
			m_pSharedFile->RemoveClientFromSourceList(this);
@


1.301
log
@Removed limitation of the uploading by the score;
Don't calculate score for downloading sources;
Removed score punishing of very old clients (< 0.19) to speed up score calculation as these guys are dead by now;
Slightly faster score calculation; Formatting.
@
text
@d1066 5
a1070 5
																		GetUserPort(), pPacket->IsFromPF(),
																		TRANSFERTYPE_UPLOAD,
																		dwBlockSize,
																		IsCommunity(),
																		pPacket->GetFilePriority() );
@


1.300
log
@removed the debug message
@
text
@d150 1
a150 1
uint32 CUpDownClient::GetScore(bool bIsDownloading, bool bOnlyBaseValue /*= false*/)
d154 1
a154 1
	if (m_strUserName.IsEmpty() || (m_eBanState != BAN_CLIENT_NONE))
d166 2
a167 10
#ifdef OLD_SOCKETS_ENABLED
	if (!bIsDownloading && !bOnlyBaseValue)
	{
		if (HasLowID() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
		{
			if (!g_App.m_pServerConnect->IsConnected() || g_App.m_pServerConnect->IsLowID())
				return 0;
		}
	}
#endif //OLD_SOCKETS_ENABLED
d169 1
a169 1
	CKnownFile* pSharedFile = g_App.m_pSharedFilesList->GetFileByID(m_reqFileHash);
d176 1
a176 1
	double	dblFilePriority;
d182 1
a182 1
				dblFilePriority = 5.0;
d184 1
a184 1
				dblFilePriority = 10.0;
d188 1
a188 1
			dblFilePriority = 2.0;
d192 1
a192 1
			dblFilePriority = 0.5;
d196 1
a196 1
			dblFilePriority = 0.2;
d201 1
a201 1
			dblFilePriority = 1.0;	// standard
d205 1
a205 2
	double	dblSizeRatio = pSharedFile->GetSizeRatio();
	double	dblPopularityRatio = pSharedFile->GetPopularityRatio();
a207 1
	double		dblBaseValue;
d209 1
a209 7
	{
		dblBaseValue = 100.0f;
	}
	else if (!bIsDownloading)
	{
		dblBaseValue = static_cast<double>(::GetTickCount() - GetWaitStartTime()) / 1000.0;
	}
d212 8
a219 6
	//	We don't want one client to download forever
	//	the first 15 min download time counts as 15 min waitingtime and you get a 15 min bonus while you are in the first 15 min :)
	//	(to avoid 20 sec downloads) after this the score won't raise anymore
		dblBaseValue = static_cast<double>(m_dwUploadTime - GetWaitStartTime());
		dblBaseValue += static_cast<double>((::GetTickCount() - m_dwUploadTime > 900000) ? 900000.0 : 1800000.0);
		dblBaseValue /= 1000.0;
d223 1
a223 1
		dblBaseValue *= 2.0;
d225 1
a225 1
		dblBaseValue *= 1.5;
d229 1
a229 1
		dblBaseValue *= m_pCredits->GetScoreRatio(this->GetIP());
d231 1
a231 3
//	Little penalty for _very_ old clients that are harmful for servers and network (from official)
	if (IsEmuleClient() && m_byteEmuleVersion <= 0x19)
		dblBaseValue *= 0.5f;
d233 1
a233 3
	dblBaseValue *= dblFilePriority * dblSizeRatio * dblPopularityRatio;

	return static_cast<uint32>(dblBaseValue);
d349 1
a349 2
		if ( IsFriend() && GetSessionUp() < (PARTSZ32 + EMBLOCKSZ32 * 6)
			 && !g_App.m_pUploadQueue->CheckForTimeOver(this) && !bJSIsBlocked )
d1508 1
a1508 1
		return m_pCredits->GetScoreRatio(this->GetIP(), true);
@


1.299
log
@Fixed ability to keep connection after cancel transfer reception;
Fixed connection loss after transfer of some specific data packet size (in some cases) --
it could cause problems for A4AF switching or lead to connection loss with the remote source (all that under many rare condiftions).
@
text
@a942 1
	{
a943 7
#if 1
		AddDebugLogLine(_T("Client %s had GetWaitStartTime() greater than m_dwUploadTime ip=%s:%u, h=%s"),
						GetClientNameWithSoftware(),
						GetFullIP(), GetUserPort(),
						HashToString(m_userHash));
#endif
	}
@


1.298
log
@Slightly increased min upload threshold.
@
text
@d830 1
a830 1
		uint32		nSize = pPacket->GetRealPacketSize();
d835 1
a835 1
		uint32	nPos = 0;
d838 1
a838 1
		while (nPos < nSize && iAllocationTries < 3)
d842 1
a842 1
			uint32		nNewSize = (nSize - nPos < MAXFRAGSIZE) ? nSize - nPos : MAXFRAGSIZE;
d846 2
a847 2
				pBuffer2 = new char[nNewSize];
				pPacket = new Packet(pBuffer2, nNewSize, (nNewSize < MAXFRAGSIZE), byteFilePriority, bFromPF);
d849 1
a849 1
				memcpy2(pBuffer2, m_pcBuffer + nPos, nNewSize);
d854 1
a854 1
				nPos += nNewSize;
d1162 3
d1174 1
a1174 2

		bool	bBreak = pPacket->IsLastSplit();
a1227 2
// FlushSendBlocks() was removed, since the client on the other side ignores all packets,
// that will be coming after an OP_CANCEL... what actually means traffic waste.
@


1.297
log
@protect the waiting time with SUI
@
text
@d292 1
a292 1
		if (GetSessionUp() < 1024 * 1024)
@


1.296
log
@No need to do that for local variables.
@
text
@d224 1
a224 1
		dblBaseValue = static_cast<double>(::GetTickCount() - m_dwWaitTime) / 1000.0;
d231 1
a231 2
		dblBaseValue = static_cast<double>(m_dwUploadTime - m_dwWaitTime);
		ASSERT (m_dwUploadTime - m_dwWaitTime >= 0); //oct 28, 02: changed this from "> 0" to ">= 0"
d926 1
a926 1
void CUpDownClient::SetUpStartTime(uint32 dwTime)
d928 2
a929 6
	EMULE_TRY

	if (dwTime != 0)
		m_dwUploadTime = dwTime;
	else
		m_dwUploadTime = ::GetTickCount();
d931 1
a931 1
	EMULE_CATCH
d934 2
a935 1
void CUpDownClient::SetWaitStartTime(uint32 dwTime)
d937 4
a940 1
	EMULE_TRY
d942 10
a951 4
	if (dwTime != 0)
		m_dwWaitTime = dwTime;
	else
		m_dwWaitTime = ::GetTickCount();
d953 1
a953 1
	EMULE_CATCH
@


1.295
log
@give 0-score to the client who use a hash that was identified for another client to preven an upload to possible hash stealers
@
text
@d224 1
a224 1
		dblBaseValue = static_cast<double>(::GetTickCount() - GetWaitStartTime()) / 1000.0;
d231 2
a232 2
		dblBaseValue = static_cast<double>(m_dwUploadTime - GetWaitStartTime());
		ASSERT (m_dwUploadTime - GetWaitStartTime() >= 0); //oct 28, 02: changed this from "> 0" to ">= 0"
@


1.294
log
@remove the hash stealer detection from xrmb because:
1) duplicated functionaly, i.e. it has similar functionaly as client credits
2) useless when client changes a ports (remember an random ports)
as result less CPU load and memory consumption
@
text
@d163 3
d224 1
a224 1
		dblBaseValue = static_cast<double>(GetTickCount() - m_dwWaitTime) / 1000.0;
d231 3
a233 3
		dblBaseValue = static_cast<double>(m_dwUploadTime - m_dwWaitTime);
		ASSERT (m_dwUploadTime - m_dwWaitTime >= 0); //oct 28, 02: changed this from "> 0" to ">= 0"
		dblBaseValue += static_cast<double>((GetTickCount() - m_dwUploadTime > 900000) ? 900000.0 : 1800000.0);
@


1.293
log
@Large file size support (max file size 512 GB - 1 = 549,755,813,887).
@
text
@a1362 5
	const uint64 qwIPPortID = GetUID();

	g_App.m_pClientList->m_mapOffenseCounter.erase(qwIPPortID);
	g_App.m_pClientList->m_mapHashBase.erase(qwIPPortID);

d1383 1
a1383 1
		IDS_BAN_HASHSTEAL,		//BAN_CLIENT_CHANGED_HASH_3_TIMES
d1463 1
a1463 1
		case BAN_CLIENT_CHANGED_HASH_3_TIMES:
@


1.292
log
@Fixed kick of banned source from upload queue (as well as log message).
@
text
@d365 1
a365 1
		if ( IsFriend() && GetSessionUp() < (PARTSZ32 + EMBLOCKSIZE * 6)
@


1.291
log
@Added sending of large file data;
Added missed upload overhead for data packets;
Chat session has to be disconnected on ban (from original).
@
text
@d1407 3
d1420 1
a1420 1
	if (m_eBanState != BAN_CLIENT_NONE)
d1428 2
d1431 1
a1433 1
	m_eBanState = eReason;
@


1.290
log
@Faster processing of remote part status packets (eliminated double search in the shared files list);
Don't add sources with mismatch part count to downloading (as well as stop communication with such sources);
Corrected packet exception handling -- should be outside to avoid communication with bogus clients;
Unified packet buffer type; Formatting.
@
text
@d668 4
a671 3
	uint32			dwPacketSize;
	CMemFile		memfile(pbyteFileData, dwToGo);
	PacketDeque		blockSendTempQueue;
d674 1
a674 1
		dwPacketSize = dwToGo / (dwToGo / 10240L);
d685 2
a686 1
		Packet		*pPacket = new Packet(OP_SENDINGPART, dwPacketSize + 24, OP_EDONKEYPROT, byteFilePriority, bFromPF);
d688 20
a707 7
		md4cpy(&pPacket->m_pcBuffer[0], m_reqFileHash);

		uint32 endpos = (pCurrBlk->qwEndOffset - dwToGo);
		uint32 startpos = endpos - dwPacketSize;

		POKE_DWORD(&pPacket->m_pcBuffer[16], startpos);
		POKE_DWORD(&pPacket->m_pcBuffer[20], endpos);
d709 1
a709 3
	//	Append the file data to the packet
		memfile.Read(&pPacket->m_pcBuffer[24], dwPacketSize);
	//	If the split was successful, then move the splited packets to global queue
d712 1
a712 1
		//	Attach splitted packets to global queue
d740 3
a742 3
	BYTE * output = new BYTE[dwToGo + 300];
	uLongf newsize = dwToGo + 300;
	uint16 result = compress2(output, &newsize, pbyteFileData, dwToGo, 9);
d744 1
a744 1
	if (result != Z_OK || dwToGo <= newsize)
d750 4
a753 3
	CMemFile		memfile(output, newsize);
	PacketDeque		blockSendTempQueue;
	uint32			dwPacketSize;
d772 18
a789 7
		Packet	   *pPacket = new Packet(OP_COMPRESSEDPART, dwPacketSize + 24, OP_EMULEPROT, byteFilePriority, bFromPF);
		uint32		startpos = pCurrBlk->qwStartOffset;

		md4cpy(&pPacket->m_pcBuffer[0], m_reqFileHash);
		POKE_DWORD(&pPacket->m_pcBuffer[16], startpos);
		POKE_DWORD(&pPacket->m_pcBuffer[20], newsize);
		memfile.Read(&pPacket->m_pcBuffer[24], dwPacketSize);
d805 1
a805 1
//	Attach splitted packets to global queue
d1427 1
@


1.289
log
@Removed crash interceptor for primitive function to improve performace; Formatting.
@
text
@d585 3
a587 1
void CUpDownClient::ProcessUpFileStatus(char *pcPacket, uint32 dwPacketSize)
d589 2
a590 7
	EMULE_TRY

	if (m_pbyteUpPartStatuses)
	{
		delete[] m_pbyteUpPartStatuses;
		m_pbyteUpPartStatuses = NULL;
	}
d594 1
a594 1
	if (dwPacketSize == 16)
d597 1
a597 1
		return;
d600 2
a601 6
	CSafeMemFile	packetStream(reinterpret_cast<BYTE *>(pcPacket), dwPacketSize);
	uchar			abyteFileHash[16];

	packetStream.Read(abyteFileHash, 16);

	CKnownFile	   *pKnownFile = g_App.m_pSharedFilesList->GetFileByID(abyteFileHash);
d618 1
a618 1
			return;
d630 1
a630 2

			for (sint32 i = 0;i != 8;i++)
d632 1
a632 1
				m_pbyteUpPartStatuses[uDone] = ((byteToRead >> i) & 1) ? 1 : 0;
a634 1
				{
a635 1
				}
d648 1
a648 1
		if ((GetExtendedRequestsVersion() > 1) && (dwPacketSize >= 20 + (((uint32)m_uUpPartCount + 7) >> 3)))
d661 1
a661 1
	EMULE_CATCH
d1149 1
a1149 1
void CUpDownClient::SendHashsetPacket(char *pcFileHash)
d1153 1
a1153 1
	CKnownFile		*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(reinterpret_cast<BYTE*>(pcFileHash));
d1157 1
a1157 1
		pKnownFile = g_App.m_pDownloadQueue->GetFileByID(reinterpret_cast<uchar*>(pcFileHash));
d1162 1
a1162 1
			AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Client %s: requested file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(reinterpret_cast<BYTE*>(pcFileHash)));
@


1.288
log
@Corrected dropping of inactive LowID sources
(there was a change that a good source could be removed).
@
text
@d443 1
a443 1
		//	Everyone is limited to a single chunk.
d487 1
a487 2
			bool bPackedCreated = false;
			bool bCompress = false;
d495 1
a495 1
				bPackedCreated = CreatePackedPackets(filedata, dwToGo, pCurrBlk, srcfile->GetULPriority(), bFromPF);
d497 1
a497 1
				bPackedCreated = CreateStandardPackets(filedata, dwToGo, pCurrBlk, srcfile->GetULPriority(), bFromPF);
d500 1
a500 1
			if (bPackedCreated)
a867 2
	EMULE_TRY

a871 2

	EMULE_CATCH
@


1.287
log
@Large file size support preparations.
@
text
@d1545 6
@


1.286
log
@Large file size support preparations.
@
text
@d61 2
a62 2
	uint32			dwFileSize = (pUploadingFile != NULL) ? pUploadingFile->GetFileSize() : 1;
	CBarShader		statusBar(pRect->bottom - pRect->top, pRect->right - pRect->left, crNeither, dwFileSize);
d67 1
a67 1
		uint32		dwStartPos, dwEndPos;
d71 2
a72 2
			dwStartPos = PARTSIZE * i;
			dwEndPos = ((dwFileSize - dwStartPos) > PARTSIZE) ? (dwStartPos + PARTSIZE) : dwFileSize;
d76 1
a76 1
				statusBar.FillRange(dwStartPos, dwEndPos, crSendingPart);
d91 1
a91 1
				statusBar.FillRange(dwStartPos, dwEndPos, (m_pbyteUpPartStatuses[i] != 0) ? crBoth : crMeOnly);
d95 1
a95 1
				statusBar.FillRange(dwStartPos, dwEndPos, crClientOnly);
@


1.285
log
@Large file size support preparations;
Faster calculation of part end to slightly compensate 64bit calculations overhead (this can be used now as we don't have 32bit limits anymore).
@
text
@d505 1
a505 1
				srcfile->statistic.AddTraffic(pCurrBlk->qwStartOffset, dwToGo);
@


1.284
log
@Large file size support preparations; Renaming;
Faster memory copy while preparing packet.
@
text
@d440 2
a441 2
			uint32 dwStart = dwPart * PARTSIZE;
			uint32 dwEnd = ((srcfile->GetFileSize() - dwStart) > PARTSIZE) ? (dwStart + PARTSIZE) : srcfile->GetFileSize();
d447 1
a447 1
				(pCurrBlk->qwEndOffset > dwEnd) )
d451 1
a451 1
				pCurrBlk->qwEndOffset = dwEnd;
@


1.283
log
@Large file size support preparations.
@
text
@d85 2
a86 2
					if (dwUploadingPart == (pDoneBlock->m_dwStartOffset / PARTSIZE))
						statusBar.FillRange(pDoneBlock->m_dwStartOffset, pDoneBlock->m_dwEndOffset, crSentData);
d262 1
a262 1
	bool	different_part = false;
d269 3
a271 4
		//	Get last block and next pending
			Requested_Block_Struct	*last_done_block = m_doneBlocksList.front();
			Requested_Block_Struct	*next_requested_block = m_blockRequestsQueue.front();

d273 2
a274 2
			uint32	last_done_part = last_done_block->m_dwStartOffset / PARTSIZE;
			uint32	next_requested_part = next_requested_block->m_dwStartOffset / PARTSIZE;
d276 3
a278 3
		//	Test is we are asking same file and same part
			if (last_done_part != next_requested_part || md4cmp(last_done_block->m_fileHash, next_requested_block->m_fileHash) != 0)
				different_part = true;
d283 1
a283 1
		different_part = true;
d286 1
a286 1
	if (different_part)
d292 1
a292 1
			different_part = false;
d299 1
a299 1
	return different_part;
d306 2
a307 2
	Requested_Block_Struct * next_requested_block;
	uint32 next_requested_part = 0xffffffff;
d309 1
a309 5
	if (m_blockRequestsQueue.empty())
	{
		return false;
	}
	else
d311 3
a313 3
		next_requested_block = (Requested_Block_Struct*)m_blockRequestsQueue.front();
		next_requested_part = next_requested_block->m_dwStartOffset / PARTSIZE;
		CKnownFile* kf = g_App.m_pSharedFilesList->GetFileByID(next_requested_block->m_fileHash);
d315 1
a315 1
		if (kf != NULL && !kf->AllowChunkForClient(next_requested_part, this))
d399 1
a399 1
			Requested_Block_Struct	   *pCurrentBlock = m_blockRequestsQueue.front();
d401 1
a401 1
			srcfile = g_App.m_pSharedFilesList->GetFileByID(pCurrentBlock->m_fileHash);
d408 1
a408 1
				strError.Format(_T("requested file not found, hash: %s"), HashToString(pCurrentBlock->m_fileHash));
d413 1
a413 1
			md4cpy(m_reqFileHash, pCurrentBlock->m_fileHash);
d416 1
a416 1
			if (pCurrentBlock->m_dwStartOffset >= srcfile->GetFileSize())
d421 2
a422 2
				strError.Format( _T("request data %#x-%#x beyond the file end %#x '%s'"),
									pCurrentBlock->m_dwStartOffset, pCurrentBlock->m_dwEndOffset, srcfile->GetFileSize(), srcfile->GetFileName());
d426 1
a426 1
			uint32 dwPart = pCurrentBlock->m_dwStartOffset / PARTSIZE;
d446 2
a447 2
			if ( (dwPart != ((pCurrentBlock->m_dwEndOffset - 1) / PARTSIZE)) ||
				(pCurrentBlock->m_dwEndOffset > dwEnd) )
d451 1
a451 1
				pCurrentBlock->m_dwEndOffset = dwEnd;
d454 2
a455 2
		//	This can't be a wrapped around request, since it has been limited to a single chunk.
			dwToGo = pCurrentBlock->m_dwEndOffset - pCurrentBlock->m_dwStartOffset;
d472 1
a472 1
			int	iRc = srcfile->ReadFileForUpload(pCurrentBlock->m_dwStartOffset, dwToGo, filedata);
d484 1
a484 1
			md4cpy(m_reqFileHash, pCurrentBlock->m_fileHash);
d496 1
a496 3
			{
				bPackedCreated = CreatePackedPackets(filedata, dwToGo, pCurrentBlock, srcfile->GetULPriority(), bFromPF);
			}
d498 1
a498 3
			{
				bPackedCreated = CreateStandardPackets(filedata, dwToGo, pCurrentBlock, srcfile->GetULPriority(), bFromPF);
			}
d505 1
a505 2

				srcfile->statistic.AddTraffic(pCurrentBlock->m_dwStartOffset, dwToGo);
d508 1
a508 3
				{
					srcfile->AddSentBlock(this, pCurrentBlock->m_dwStartOffset, dwToGo);
				}
d675 1
a675 1
bool CUpDownClient::CreateStandardPackets(byte *pbyteFileData, uint32 dwToGo, Requested_Block_Struct *pCurrentBlock, byte byteFilePriority, bool bFromPF /*= true*/)
d699 2
a700 2
		uint32 startpos = (pCurrentBlock->m_dwEndOffset - dwToGo) - dwPacketSize;
		uint32 endpos = (pCurrentBlock->m_dwEndOffset - dwToGo);
d702 2
a703 2
		memcpy2(&pPacket->m_pcBuffer[16], &startpos, 4);
		memcpy2(&pPacket->m_pcBuffer[20], &endpos, 4);
d734 1
a734 1
bool CUpDownClient::CreatePackedPackets(byte *pbyteFileData, uint32 dwToGo, Requested_Block_Struct *pCurrentBlock, byte byteFilePriority, bool bFromPF /*= true*/)
d745 1
a745 1
		return CreateStandardPackets(pbyteFileData, dwToGo, pCurrentBlock, byteFilePriority, bFromPF);;
d770 1
a770 1
		uint32		startpos = pCurrentBlock->m_dwStartOffset;
d773 2
a774 2
		memcpy2(&pPacket->m_pcBuffer[16], &startpos, 4);
		memcpy2(&pPacket->m_pcBuffer[20], &newsize, 4);
d884 1
a884 1
	Requested_Block_Struct	   *pTempBlock;
d888 3
a890 4
		pTempBlock = *itBlock;

		if (pTempBlock != NULL && pReqBlock->m_dwStartOffset == pTempBlock->m_dwStartOffset
			&& pReqBlock->m_dwEndOffset == pTempBlock->m_dwEndOffset)
d898 3
a900 4
		pTempBlock = *itBlock;

		if (pTempBlock != NULL && pReqBlock->m_dwStartOffset == pTempBlock->m_dwStartOffset
			&& pReqBlock->m_dwEndOffset == pTempBlock->m_dwEndOffset)
d906 1
a906 1
	pTempBlock = new Requested_Block_Struct;
d908 2
a909 2
	memcpy2(pTempBlock, pReqBlock, sizeof(Requested_Block_Struct));
	m_blockRequestsQueue.push_back(pTempBlock);
d1050 1
a1050 1
							m_pRequestSocket->SendPacket(pCancelTransferPacket,true,true);
d1117 1
a1117 1
			AddDebugLogLine(_T("CUpDownClient::SendBlockData (the socket does not exist)"));
d1532 2
a1533 8
	//	Calculate which part the block is in.
		uint32		dwPartNum = pFirstDoneBlock->m_dwStartOffset / PARTSIZE;

		return dwPartNum;
	}
	else
	{
		return 0xFFFF;
@


1.282
log
@Simplified client upload data rate processing -- never return negative (Mantis #518);
Added protection for SetUploadState not to process if the state wasn't changed.
@
text
@d370 1
a370 1
		if ( IsFriend() && GetSessionUp() < (PARTSIZE + EMBLOCKSIZE * 6)
@


1.281
log
@Download state to string conversion was moved to download client class.
@
text
@d1001 1
a1001 1
				sint32 lCurUpDataRate = -1;
d1006 1
a1006 1
					lCurUpDataRate = static_cast<sint32>((static_cast<double>(m_averageUDRList.front() - m_averageUDRList.back())) * 1000.0 / dwTimePeriod);
d1010 1
a1010 1
				if (m_lUpDataRate != lCurUpDataRate)
d1012 1
a1012 1
					m_lUpDataRate = lCurUpDataRate;
d1563 5
a1567 2
	m_eUploadState = eUploadState;
	g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.UpdateClient(this);
@


1.280
log
@Removed braces from ban status strings.
@
text
@d1487 1
a1487 6
CString CUpDownClient::GetDownloadStateAsString()
{
	return GetStatusDLQueueString((EnumDLQState)GetDownloadState());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint16	CUpDownClient::GetRemoteRatio()
@


1.279
log
@Improved string processing; Formatting.
@
text
@d1388 6
a1393 1
		IDS_NO, IDS_BAN_AGGRESSIVECLI, IDS_BAN_LEECHERSPAM, IDS_BAN_HASHIMP, IDS_BAN_HASHSTEAL, IDS_BAN_LEECHERADV
d1414 1
a1414 1
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s banned and kicked out of uploadqueue %s"),
@


1.278
log
@1) keep ban reason information (part 1 - logic)
2) disable incoming FR for LowID if file was paused
@
text
@d154 1
a154 1
	if (m_strUserName.IsEmpty())
d157 1
a157 1
	if (m_eBanState != BAN_CLIENT_NONE)
d159 1
a161 8
	else
	{
		if ( HasUserNameForbiddenStrings() || HasMODNameForbiddenStrings() )
		{
			Ban(BAN_CLIENT_KWOWN_LEECHER);
			return 0;
		}
	}
d1386 1
a1386 1
	static const UINT s_apcBanString[BAN_CLIENT_LAST] =
d1391 1
a1391 1
	return GetResString(s_apcBanString[m_eBanState]);
d1441 1
a1441 6
	if (m_eBanState == BAN_CLIENT_NONE)
		return;

	CString		strMsg;

	strMsg += _T("AUTOMATED MESSAGE: You're being banned because your client is ");
d1445 3
d1449 4
a1452 1
			strMsg += _T("too aggressive.");
d1455 4
a1458 1
			strMsg += _T("spamming.");
d1463 4
a1466 1
			strMsg += _T("leeching!");
a1469 1
	strMsg += _T(" Get more info at http://emuleplus.info/ban/");
d1471 1
a1471 1
	g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.SendMessage(strMsg);
@


1.277
log
@Minor formatting.
@
text
@a151 2
	static DWORD	dwLastMsgTime = 0;

d157 1
a157 1
	if (m_bBanned)
d163 1
a163 2
		if ( HasUserNameForbiddenStrings() || HasMODNameForbiddenStrings()
			 || ((GetModString() == _T(PLUS_VERSION_STR)) && (GetPlusVersion() == 0)) )
d165 1
a165 9
		//	Spam control
			if (::GetTickCount() > dwLastMsgTime + (60 * 1000))
			{
				AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client %s has been banned"), GetClientNameWithSoftware());

				Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_LEECHERADV));

				dwLastMsgTime = ::GetTickCount();
			}
d1343 1
a1343 2
					Ban( _T("AUTOMATED MESSAGE: You're being banned because your client is behaving aggressively!"),
						 GetResString(IDS_BAN_AGGRESSIVECLI) );
d1367 1
a1367 1
	m_bBanned = false;
d1391 11
a1401 1
void CUpDownClient::Ban(LPCTSTR pszLine, const CString &strReason, ...)
d1408 1
a1408 1
		m_bBanned = false;
d1416 3
a1418 1
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s banned and kicked out of uploadqueue %s"), GetClientNameWithSoftware(), strReason);
d1423 1
a1423 1
	if (m_bBanned)
d1433 2
a1434 1
	m_bBanned = true;
d1436 4
d1443 7
a1449 1
	m_dwBanTime = ::GetTickCount();
d1451 1
a1451 1
	uint32	dwResID = IDS_CLIENTBLOCKED;
d1453 3
a1455 1
	if (g_App.m_pPrefs->IsBanMessageEnabled())
d1457 11
a1467 7
		CString	strMsg = pszLine;

		strMsg += " Get more info at http://emuleplus.info/ban/";
		g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.StartSession(this, false);
		g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.SendMessage(strMsg);
		g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.EndSession(this, false);
		dwResID = IDS_SENTBAN;
d1470 11
a1480 6
	if (!g_App.m_pPrefs->IsCMNotLog())
		AddLogLine(false, RGB_LOG_DIMMED + GetResString(dwResID), GetUserName(), strReason);

	g_App.m_pMDlg->m_wndTransfer.m_ctlQueueList.UpdateClient(this);

	EMULE_CATCH
@


1.276
log
@Provide hashset even when no complete chunks to avoid a wave of requests from Hybrids.
@
text
@d610 1
a610 1
		if (m_pbyteUpPartStatuses[i] != NULL)
d1077 2
a1078 2
						//	Note (ePlus):
						//		ePlus is also using OP_QUEUERANKING to detect end of the session
@


1.275
log
@Corrected mistake in debug log message {muleteer}.
@
text
@d1204 12
a1215 4
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Client %s: requested file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(reinterpret_cast<BYTE*>(pcFileHash)));
	//	Cause OP_HASHSETREQUEST can be abused for file-scanning
		UpdateFailedFileRequests();
		return;
d1218 3
a1220 3
	uint16				uPartCount = pKnownFile->GetHashCount();
	uint32				dwHashSetLength = 16 * uPartCount;
	CSafeMemFile		pbyteFileData(16 + 2 + dwHashSetLength);
@


1.274
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1060 1
a1060 1
									AddDebugLogLine(_T("Client %s left UL queue after receiving %u KB. Asked for unaccessible data (file removed, wrong request, etc)"), GetClientNameWithSoftware(), GetSessionUp() / 1024);
@


1.273
log
@renamed 3 variables
@
text
@d112 1
a112 1
		if (g_App.g_pPrefs->CommunityEnabled())
d114 1
a114 1
			CString		strLowerCommunity = g_App.g_pPrefs->CommunityString();
d313 1
a313 1
			if (!bSilent && g_App.g_pPrefs->IsClientTransferLogEnabled())
d392 1
a392 1
			if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d984 1
a984 1
			if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d1053 1
a1053 1
								if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d1059 1
a1059 1
								if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d1065 1
a1065 1
								if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d1106 1
a1106 1
						g_App.g_pPrefs->Add2SessionTransferData( GetClientSoft(),
d1341 1
a1341 1
			if (dwCurTick - pReqFile->m_dwLastAskedTime < g_App.g_pPrefs->BadClientMinRequestTime())
d1399 1
a1399 1
	if (!g_App.g_pPrefs->BanEnabled())
d1422 1
a1422 1
	if (g_App.g_pPrefs->CommunityNoBanEnabled() && g_App.g_pPrefs->CommunityEnabled() && IsCommunity())
d1434 1
a1434 1
	if (g_App.g_pPrefs->IsBanMessageEnabled())
d1445 1
a1445 1
	if (!g_App.g_pPrefs->IsCMNotLog())
@


1.272
log
@Unicode corrections {KuSh}.
@
text
@d60 1
a60 1
	CPartFile	   *pUploadingFile = reinterpret_cast<CPartFile*>(g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash));
d112 1
a112 1
		if (g_eMuleApp.m_pGlobPrefs->CommunityEnabled())
d114 1
a114 1
			CString		strLowerCommunity = g_eMuleApp.m_pGlobPrefs->CommunityString();
d186 1
a186 1
			if (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID())
d192 1
a192 1
	CKnownFile* pSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash);
d313 1
a313 1
			if (!bSilent && g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d336 1
a336 1
		CKnownFile* kf = g_eMuleApp.m_pSharedFilesList->GetFileByID(next_requested_block->m_fileHash);
d389 1
a389 1
			 && !g_eMuleApp.m_pUploadQueue->CheckForTimeOver(this) && !bJSIsBlocked )
d392 1
a392 1
			if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d424 1
a424 1
			srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pCurrentBlock->m_fileHash);
d639 1
a639 1
	CKnownFile	   *pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(abyteFileHash);
d700 1
a700 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(this);
d984 1
a984 1
			if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d986 1
a986 1
			g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
d1031 1
a1031 1
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(this);
d1053 1
a1053 1
								if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d1055 1
a1055 1
								g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
d1059 1
a1059 1
								if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d1061 1
a1061 1
								g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
d1065 1
a1065 1
								if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d1067 1
a1067 1
								g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
d1081 1
a1081 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pCancelTransferPacket->m_dwSize);
d1084 1
a1084 1
							g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this, true);
d1106 1
a1106 1
						g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData( GetClientSoft(),
d1158 1
a1158 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(err));
d1188 1
a1188 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d1200 1
a1200 1
	CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reinterpret_cast<BYTE*>(pcFileHash));
d1223 1
a1223 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1271 1
a1271 1
	uint16 uRank = g_eMuleApp.m_pUploadQueue->GetWaitingPosition(this);
d1281 1
a1281 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d1321 1
a1321 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d1341 1
a1341 1
			if (dwCurTick - pReqFile->m_dwLastAskedTime < g_eMuleApp.m_pGlobPrefs->BadClientMinRequestTime())
d1375 2
a1376 2
	g_eMuleApp.m_pClientList->UpdateBanCounters();
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d1380 2
a1381 2
	g_eMuleApp.m_pClientList->m_mapOffenseCounter.erase(qwIPPortID);
	g_eMuleApp.m_pClientList->m_mapHashBase.erase(qwIPPortID);
d1390 1
a1390 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(this);
d1399 1
a1399 1
	if (!g_eMuleApp.m_pGlobPrefs->BanEnabled())
d1411 2
a1412 2
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BAN, true);
		g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this, true);
d1422 1
a1422 1
	if (g_eMuleApp.m_pGlobPrefs->CommunityNoBanEnabled() && g_eMuleApp.m_pGlobPrefs->CommunityEnabled() && IsCommunity())
d1427 2
a1428 2
	g_eMuleApp.m_pClientList->UpdateBanCounters();
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateUploadHeader();
d1434 1
a1434 1
	if (g_eMuleApp.m_pGlobPrefs->IsBanMessageEnabled())
d1439 3
a1441 3
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.StartSession(this, false);
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.SendMessage(strMsg);
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.EndSession(this, false);
d1445 1
a1445 1
	if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d1448 1
a1448 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(this);
d1470 1
a1470 1
	if (g_eMuleApp.m_pServerConnect->IsLowID())
d1474 1
a1474 1
	CKnownFile	   *pKnownReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash);
d1535 1
a1535 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(this);
d1543 1
a1543 1
		CKnownFile *m_pSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pReqFile->m_fileHash);
@


1.271
log
@Reduced a number of GetTickCount() calls;
Substitute confusing MIN_REQUESTTIME with actual preferences parameter.
@
text
@d1158 1
a1158 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__, __FILE__, __LINE__, GetErrorMessage(err));
@


1.270
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1333 2
d1341 1
a1341 1
			if (::GetTickCount() - pReqFile->m_dwLastAskedTime < MIN_REQUESTTIME)
d1349 3
a1351 6
			else
			{
				if (pReqFile->m_byteNumBadRequests)
					pReqFile->m_byteNumBadRequests--;
			}
			pReqFile->m_dwLastAskedTime = ::GetTickCount();
d1361 1
a1361 1
	pNewFile->m_dwLastAskedTime = ::GetTickCount();
@


1.269
log
@Increased maximum uploading time to transfer more to/from slow users (80 min -> 120 min).
@
text
@d1376 1
a1376 1
	g_eMuleApp.m_pUploadQueue->UpdateBanCount();
d1428 1
a1428 1
	g_eMuleApp.m_pUploadQueue->UpdateBanCount();
@


1.268
log
@Remove Shareaza punishment (thanks eklmn).
@
text
@d365 2
a366 2
//	Check if we should kick this client (time critical !!!)
//	- Always kick if transfer is longer than 80 minutes
d376 1
a376 1
//	If there are no new blocks requested, we will happily transfer more if the client request it
d383 1
a383 1
	bool bShouldContinue = ((GetUpStartTimeDelay() >= 80 * 60 * 1000) || bDifferentPart);
@


1.267
log
@Probably it's more correct to initialize new statistics variable earlier;
Unified way to display client name and version; Improved string processing.
@
text
@d262 1
a262 1
	if((IsEmuleClient() && m_byteEmuleVersion <= 0x19) || this->GetClientSoft() == SO_SHAREAZA)
@


1.266
log
@added statistic that show the number of failed DL sessions in case that remote client has nothing to request
@
text
@d171 1
a171 1
				AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) has been banned"), GetUserName(), GetClientNameAndVersionString());
d252 1
a252 3
	if (IsFriend())
	{
	//	Client is on friendlist
d254 2
a255 7
	}
	else
	{
	//	Client is a community user
		if (IsCommunity())
			dblBaseValue *= 1.5;
	}
d314 1
a314 1
				AddDebugLogLine(_T("Client '%s' (%s) continues downloading (should be back on queue) because of a low transferred size"), GetUserName(), GetClientNameAndVersionString());
d393 1
a393 1
				AddDebugLogLine(_T("Client '%s' (%s) downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend"), GetUserName(), GetClientNameAndVersionString(), this->GetSessionUp() / 1024);
d456 1
a456 1
				AddLogLine(false,  IDS_PARTPRIO_DENIED, dwPart, srcfile->GetFileName());
d551 1
a551 1
	catch (CMemoryException * error)
d553 1
a553 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d558 1
a558 1
	catch (CFileException * error)
d561 1
a561 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d571 1
a571 1
		AddDebugLogLine(_T("Client '%s' (%s) caused an error while creating package (%s), disconnecting!"), GetUserName(), GetClientNameAndVersionString(), strError);
d652 1
a661 1
		m_fNoDataForRemoteClient = 1;
d985 1
a985 2
				AddDebugLogLine( _T("Client '%s' (%s) appears to be stuck, putting back on queue"),
								 GetUserName(), GetClientNameAndVersionString() );
d1054 1
a1054 1
									AddDebugLogLine(_T("Client %s (%s) left UL queue after receiving %u KB. Asked for new or blocked chunk/file"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
d1060 1
a1060 1
									AddDebugLogLine(_T("Client %s (%s) left UL queue after receiving %u KB. Asked for unaccessible data (file removed, wrong request, etc)"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
d1066 1
a1066 1
									AddDebugLogLine(_T("Client %s (%s) left UL queue after receiving %u KB. Upload timeout (low speed, no block request)"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
d1204 1
a1204 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("Client '%s' (%s): requested file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(), HashToString(reinterpret_cast<BYTE*>(pcFileHash)));
d1411 1
a1411 1
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s) banned and kicked out of uploadqueue %s"), GetUserName(), GetClientNameAndVersionString(), strReason);
@


1.265
log
@new source exchange system
@
text
@d668 1
d681 1
d683 7
@


1.264
log
@Fixed score comparison bugs committed on Jan 20 'Removed GetScore() unused parameter' {xalbux}.
@
text
@d1537 12
@


1.263
log
@Show chunks which can be downloaded from the particular client on upload progress bar {DopeFish}.
@
text
@d150 1
a150 1
uint32 CUpDownClient::GetScore(bool bIsDownloading /*= false*/, bool bOnlyBaseValue /*= false*/)
@


1.262
log
@Corrected some previous formatting.
@
text
@d44 1
a44 1
	COLORREF		crNeither, crBoth;
d48 1
d50 1
a50 1
		crBoth = RGB(0, 150, 0);
d54 1
d56 1
a56 1
		crBoth = RGB(0, 192, 0);
d89 1
a89 1
			else if (m_pbyteUpPartStatuses[i] != 0)	// The remote user has this part
d91 1
a91 1
				statusBar.FillRange(dwStartPos, dwEndPos, crBoth);
d93 1
a93 1
			else if (!pUploadingFile->IsPartFile() || pUploadingFile->IsPartComplete(i))
d95 1
a95 1
				statusBar.FillRange(dwStartPos, dwEndPos, crMeOnly);
d475 3
a477 3
		//		make sure we don't pass the end of the file.
			if ( (dwPart != ((pCurrentBlock->m_dwEndOffset - 1) / PARTSIZE))
					|| (pCurrentBlock->m_dwEndOffset > dwEnd) )
d865 1
a865 1
			//		in this case we can retry to allocate the packet again
@


1.261
log
@fix for my last change (1.260)
@
text
@a432 2
				eBPCResult = BPCR_FAILED_FILE_ERROR;

d435 1
a445 2
				eBPCResult = BPCR_FAILED_FILE_ERROR;

d448 1
a458 3
				AddLogLine(false,  IDS_PARTPRIO_DENIED, dwPart, srcfile->GetFileName());
				eBPCResult = BPCR_FAILED_BLOCKED_PART;

d461 1
d463 1
a488 2
					eBPCResult = BPCR_FAILED_BLOCKED_PART;

d492 1
a504 2
				eBPCResult = BPCR_FAILED_FILE_ERROR;

d508 1
d621 1
a621 1
void CUpDownClient::ProcessUpFileStatus(char *pachPacketBuf, uint32 dwPacketSize)
d639 2
a640 2
	CSafeMemFile	packetStream(reinterpret_cast<BYTE *>(pachPacketBuf), dwPacketSize);
	uchar			pachFileHash[16];
d642 1
a642 1
	packetStream.Read(pachFileHash, 16);
d644 1
a644 1
	CKnownFile	   *pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pachFileHash);
d788 1
a788 1
	while (dwToGo > 0)
d796 1
a798 3

		uint32		startpos = pCurrentBlock->m_dwStartOffset;

d893 1
a893 1
void CUpDownClient::SetUploadFileID(uchar *pachReqFileID)
d897 2
a898 2
	if (pachReqFileID != NULL)
		md4cpy(m_reqFileHash, pachReqFileID);
d946 1
a946 1
	if (dwTime > 0)
d958 1
a958 1
	if (dwTime > 0)
d1067 1
a1067 1
						//	Notify the remote client about end of the session
d1088 1
a1088 1
				//		for the entire next block. There must also be blocks to send (not empty request queue)
d1138 1
a1138 1
					//		can make sure we give it data often enough to not time out.
d1193 1
a1193 1
void CUpDownClient::SendHashsetPacket(char *pachFileHash)
d1197 1
a1197 1
	CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reinterpret_cast<BYTE*>(pachFileHash));
d1201 1
a1201 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("Client '%s' (%s): requested file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(), HashToString(reinterpret_cast<BYTE*>(pachFileHash)));
d1275 1
a1275 1
	memzero(pPacket->m_pcBuffer, 12);
d1326 1
a1326 1
void CUpDownClient::AddRequestCount(uchar *pachFileId)
d1334 1
a1334 1
		if (!md4cmp(pReqFile->m_fileHash, pachFileId))
d1358 1
a1358 1
	md4cpy(pNewFile->m_fileHash, pachFileId);
@


1.260
log
@Removed GetScore() unused parameter
More Coding GuideLines compliant code
@
text
@d620 1
a620 1
		if (m_pbyteUpPartStatuses[i] > 0)
d1000 1
a1000 1
			// check block queues to separate the active client from just invited to upload
@


1.259
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d37 1
a37 1
void CUpDownClient::DrawUpStatusBar(CDC* dc, RECT* rect, bool bFlat)
d44 1
a44 1
	COLORREF	crNeither, crBoth;
d58 3
a60 3
	CPartFile	*pUploadingFile = reinterpret_cast<CPartFile*>(g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash));
	uint32		dwFileSize = (pUploadingFile != NULL) ? pUploadingFile->GetFileSize() : 1;
	CBarShader	statusBar(rect->bottom - rect->top, rect->right - rect->left, crNeither, dwFileSize);
d87 2
a88 1
			else if (m_pbyteUpPartStatuses[i] != 0)	//the remote user has this part
d90 1
d92 1
d94 1
d97 1
a97 1
	statusBar.Draw(dc, rect->left, rect->top, bFlat);
d112 2
a113 1
			CString strLowerCommunity = g_eMuleApp.m_pGlobPrefs->CommunityString();
d120 2
a121 1
				CString strProperCommunity;
d125 2
a126 1
				CString strLowerUserName = m_strUserName;
d131 1
a131 1
				int iFirstTagPos = strLowerUserName.Find(_T('['));
a133 1
				{
a134 1
				}
d148 1
a148 1
uint32 CUpDownClient::GetScore(bool sysvalue, bool isdownloading, bool onlybasevalue)
d163 2
a164 2
		if ( HasUserNameForbiddenStrings() || HasMODNameForbiddenStrings() ||
			 ((GetModString() == _T(PLUS_VERSION_STR)) && (GetPlusVersion() == 0)) )
d180 1
a180 1
	if (!isdownloading && !onlybasevalue)
a194 1
// 	i_a: m_reqFileHash is an array so the if() was superfluous
d231 1
a231 1
	if (onlybasevalue)
d235 1
a235 1
	else if (!isdownloading)
a258 1
		{
a259 1
		}
a263 1
	{
a264 1
	}
a267 1
	{
a268 1
	}
d283 1
a283 1
bool CUpDownClient::IsDifferentPartBlock(bool silent)
a301 1
			{
a302 1
			}
d318 1
a318 2
			if (!silent && g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
			{
a319 1
			}
a343 1
		{
a344 1
		}
d381 1
a382 2
	{
	//	There are no new blocks requested, we will happily transfer more if the client request it
a383 1
	}
d427 3
a429 2
			Requested_Block_Struct * currentblock = m_blockRequestsQueue.front();
			srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(currentblock->m_fileHash);
a432 1
				CString srtError;
d434 5
a438 2
				srtError.Format(_T("requested file not found, hash: %s"), HashToString(currentblock->m_fileHash));
				throw srtError;
d442 1
a442 1
			md4cpy(m_reqFileHash, currentblock->m_fileHash);
d445 1
a445 1
			if (currentblock->m_dwStartOffset >= srcfile->GetFileSize())
a446 1
				CString srtError;
d448 6
a453 3
				srtError.Format( _T("request data %#x-%#x beyond the file end %#x '%s'"),
					currentblock->m_dwStartOffset, currentblock->m_dwEndOffset, srcfile->GetFileSize(), srcfile->GetFileName());
				throw srtError;
d456 1
a456 1
			uint32 dwPart = currentblock->m_dwStartOffset / PARTSIZE;
d458 1
a458 1
		// Accessing a blocked part ?
d460 1
a460 2
				{
				CString sMessage;
a461 1
				sMessage.Format(GetResString( IDS_PARTPRIO_DENIED), dwPart, srcfile->GetFileName());
d463 5
a467 1
				throw sMessage;
d470 1
a470 1
			uint32 togo;
d476 3
a478 3
		//	make sure we don't pass the end of the file.
			if ( (dwPart != ((currentblock->m_dwEndOffset - 1) / PARTSIZE)) ||
				(currentblock->m_dwEndOffset > dwEnd) )
d482 1
a482 1
				currentblock->m_dwEndOffset = dwEnd;
d486 1
a486 1
			togo = currentblock->m_dwEndOffset - currentblock->m_dwStartOffset;
d492 4
a495 1
					CString strError;
a496 1
					eBPCResult = BPCR_FAILED_BLOCKED_PART;
d502 1
a502 1
			filedata = new byte[togo + 500];
d504 1
a504 1
			int	iRc = srcfile->ReadFileForUpload(currentblock->m_dwStartOffset, togo, filedata);
d509 4
a512 1
				CString strError;
a513 1
				eBPCResult = BPCR_FAILED_FILE_ERROR;
d517 1
a517 1
			md4cpy(m_reqFileHash, currentblock->m_fileHash);
d530 1
a530 1
				bPackedCreated = CreatePackedPackets(filedata, togo, currentblock, srcfile->GetULPriority(), bFromPF);
d534 1
a534 1
				bPackedCreated = CreateStandardPackets(filedata, togo, currentblock, srcfile->GetULPriority(), bFromPF);
d537 1
a537 1
		//	 update the data only if packet was created
d541 1
a541 1
				srcfile->statistic.AddTransferred(togo);
d543 1
a543 1
				srcfile->statistic.AddTraffic(currentblock->m_dwStartOffset, togo);
d547 1
a547 1
					srcfile->AddSentBlock(this, currentblock->m_dwStartOffset, togo);
d573 2
a574 2
		if (filedata)
			delete []filedata;
d583 2
a584 2
		if (filedata)
			delete []filedata;
d598 4
a601 13
	if (m_uPartCount == 0)
	{
		return;
	}
	if (!m_pReqPartFile)
	{
		return;
	}
	if (md4cmp(m_reqFileHash, m_pReqPartFile->GetFileHash()))
	{
		return;
	}
	if (!m_pbytePartStatuses)
d605 1
d620 1
a620 2
		if (m_pbyteUpPartStatuses[i])
		{
a621 1
		}
d626 1
a626 1
void CUpDownClient::ProcessUpFileStatus(char* packet, uint32 size)
d638 1
a638 1
	if (size == 16)
a642 5
	CSafeMemFile data((BYTE*)packet, size);
	uchar cfilehash[16];
	data.Read(cfilehash, 16);
	CKnownFile* tempreqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(cfilehash);
	uint16 uED2KUpPartCount;
d644 10
a653 2
	data.Read(&uED2KUpPartCount, 2);
	m_uUpPartCount = tempreqfile->GetPartCount();
d662 1
a662 1
		if (tempreqfile->GetED2KPartCount() != uED2KUpPartCount)
a668 1
		uint16 done = 0;
d670 3
a672 1
		while (done != m_uUpPartCount)
d674 3
a676 2
			byte toread;
			data.Read(&toread, 1);
d680 1
a680 1
				m_pbyteUpPartStatuses[done] = ((toread >> i) & 1) ? 1 : 0;
d682 1
a682 2
				if (m_pbyteUpPartStatuses[done])
				{
d684 2
a685 4
				}
				done++;
				if (done == m_uUpPartCount)
				{
a686 1
				}
d690 1
a690 1
		if ((GetExtendedRequestsVersion() > 1) && (size >= 20 + (((uint32)m_uUpPartCount + 7) >> 3)))
d692 7
a698 6
			uint16 nCompleteCountLast = GetUpCompleteSourcesCount();
			uint16 nCompleteCountNew;
			data.Read(&nCompleteCountNew, 2);
			SetUpCompleteSourcesCount(nCompleteCountNew);
			if (nCompleteCountLast != nCompleteCountNew)
				tempreqfile->CalculateCompleteSources();
d706 1
a706 1
bool CUpDownClient::CreateStandardPackets(byte* pbyteFileData, uint32 togo, Requested_Block_Struct* currentblock, byte byteFilePriority, bool bFromPF)
d710 3
a712 3
	uint32			nPacketSize;
	CMemFile		memfile(pbyteFileData, togo);
	PacketDeque blockSendTempQueue;
d714 2
a715 4
	if (togo > 10240)
	{
		nPacketSize = togo / (togo / 10240L);
	}
d717 1
a717 3
	{
		nPacketSize = togo;
	}
d719 1
a719 1
	while (togo != 0)
d721 2
a722 4
		if (togo < nPacketSize * 2)
		{
			nPacketSize = togo;
		}
d724 1
a724 1
		togo -= nPacketSize;
d726 1
a726 1
		Packet		*packet = new Packet(OP_SENDINGPART, nPacketSize + 24, OP_EDONKEYPROT, byteFilePriority, bFromPF);
d728 1
a728 1
		md4cpy(&packet->m_pcBuffer[0], m_reqFileHash);
d730 2
a731 2
		uint32 startpos = (currentblock->m_dwEndOffset - togo) - nPacketSize;
		uint32 endpos = (currentblock->m_dwEndOffset - togo);
d733 2
a734 2
		memcpy2(&packet->m_pcBuffer[16], &startpos, 4);
		memcpy2(&packet->m_pcBuffer[20], &endpos, 4);
d737 3
a739 3
		memfile.Read(&packet->m_pcBuffer[24], nPacketSize);
	//	if the split was successful, then move the splited packets to global queue
		if (SplitAndAddPacketsToSendQueue(packet, &blockSendTempQueue, byteFilePriority, bFromPF))
d741 1
a741 1
		//	attach splitted packets to global queue
d765 1
a765 1
bool CUpDownClient::CreatePackedPackets(byte* pbyteFileData, uint32 togo, Requested_Block_Struct* currentblock, byte byteFilePriority, bool bFromPF)
d769 3
a771 3
	BYTE * output = new BYTE[togo + 300];
	uLongf newsize = togo + 300;
	uint16 result = compress2(output, &newsize, pbyteFileData, togo, 9);
d773 1
a773 1
	if (result != Z_OK || togo <= newsize)
d776 1
a776 1
		return CreateStandardPackets(pbyteFileData, togo, currentblock, byteFilePriority, bFromPF);;
d779 3
a781 3
	CMemFile memfile(output, newsize);
	PacketDeque blockSendTempQueue;
	uint32 nPacketSize;
d783 3
a785 3
//	update the compression statistic
	m_dwCompressionGain += (togo - newsize);
	m_dwUncompressed += togo;
d787 3
a789 5
	togo = newsize;
	if (togo > 10240)
	{
		nPacketSize = togo / (uint32)(togo / 10240);
	}
d791 3
d795 6
a800 2
		nPacketSize = togo;
	}
d802 1
a802 9
	while (togo)
	{
		if (togo < nPacketSize * 2)
		{
			nPacketSize = togo;
		}
		togo -= nPacketSize;
		Packet* packet = new Packet(OP_COMPRESSEDPART, nPacketSize + 24, OP_EMULEPROT, byteFilePriority, bFromPF);
		md4cpy(&packet->m_pcBuffer[0], m_reqFileHash);
d804 1
a804 1
		uint32 startpos = currentblock->m_dwStartOffset;
d806 3
a808 3
		memcpy2(&packet->m_pcBuffer[16], &startpos, 4);
		memcpy2(&packet->m_pcBuffer[20], &newsize, 4);
		memfile.Read(&packet->m_pcBuffer[24], nPacketSize);
d810 2
a811 2
	//	if one of the split action was failed, then cancel whole packet creation, cause otherwise Z-stream on other side will be corrupted
		if (!SplitAndAddPacketsToSendQueue(packet, &blockSendTempQueue, byteFilePriority, bFromPF))
d824 1
a824 1
//	attach splitted packets to global queue
d840 1
a840 1
bool CUpDownClient::SplitAndAddPacketsToSendQueue(Packet* pPacket, PacketDeque* pSendQueue, byte byteFilePriority, bool bFromPF)
d847 3
a849 2
		uint32 nSize = pPacket->GetRealPacketSize();
		char* m_pcBuffer = pPacket->DetachPacket();
d852 3
a854 3
		uint32 nPos = 0;
		int	iAllocationTries = 0;
		//bool bLast = true;
d857 3
a859 3
			char* pBuffer2 = NULL;
			Packet* pPacket = NULL;
			uint32 nNewSize = (nSize - nPos < MAXFRAGSIZE) ? nSize - nPos : MAXFRAGSIZE;
d865 1
a865 1
			//	to optimize hadling in case of failed packet allocation, let's copy the data after packet creation
d867 1
a867 1
			//	put packet in temporary queue
d869 2
a870 2
			//	update the data pointer for next fragment only if packet allocation was successful
			//	in this case we can retry to allocate the packet again
a871 1
				//bLast = false;
d874 1
a874 1
			catch (CMemoryException * error)
d884 1
a884 1
	//	if the split was failed due to problem with memory allocation report it back
d900 1
a900 1
void CUpDownClient::SetUploadFileID(uchar *pNewReqFileID)
d904 2
a905 4
	if (pNewReqFileID)
	{
		md4cpy(m_reqFileHash, pNewReqFileID);
	}
a906 1
	{
a907 1
	}
d912 1
a912 1
void CUpDownClient::AddReqBlock(Requested_Block_Struct* pNewReqBlock)
d916 2
a917 1
	ReqBlockDeque::iterator itBlock;
d919 1
a919 1
	for (itBlock = m_doneBlocksList.begin(); itBlock != m_doneBlocksList.end(); itBlock++ )
d921 1
a921 1
		Requested_Block_Struct* pFinishedBlock = *itBlock;
d923 2
a924 2
		if (pFinishedBlock && pNewReqBlock->m_dwStartOffset == pFinishedBlock->m_dwStartOffset
			&& pNewReqBlock->m_dwEndOffset == pFinishedBlock->m_dwEndOffset)
d932 1
a932 1
		Requested_Block_Struct* pReqBlock = *itBlock;
d934 2
a935 2
		if (pReqBlock && pNewReqBlock->m_dwStartOffset == pReqBlock->m_dwStartOffset
			&& pNewReqBlock->m_dwEndOffset == pReqBlock->m_dwEndOffset)
d941 1
a941 1
	Requested_Block_Struct* pNewBlock = new Requested_Block_Struct;
d943 2
a944 2
	memcpy2(pNewBlock, pNewReqBlock, sizeof(Requested_Block_Struct));
	m_blockRequestsQueue.push_back(pNewBlock);
d953 1
a953 2
	if (dwTime != 0)
	{
a954 1
	}
a955 1
	{
a956 1
	}
d965 1
a965 2
	if (dwTime != 0)
	{
a966 1
	}
a967 1
	{
a968 1
	}
d973 1
a973 1
uint32 CUpDownClient::SendBlockData(uint32 dwMaxAmount,  EnumBlockSendResult& eResult)
d976 3
a978 2
	uint32 dwTimePeriod, dwAmountTransferred = 0;
	DWORD curTick = GetTickCount();
d986 1
a986 1
		//	if client stays online, he will request file & added to the queue
d996 1
a996 1
		if (m_pRequestSocket)
d1008 4
a1011 4
			// 1)  measure only already transferred data! the speed should be calculated before data transfer, otherwise
			//      not yet transferred data from current iteration will lead to higher(incorrect) speed value
			// 2)  use socket status to find out the correct time for the speed measurements, because any calculation of the average inbetween
			//      will decrease the calculated value, what does not reflect real situation
d1015 1
a1015 1
			// Don't store too much statistics. maximal 40 sec ~ socket timeout
d1043 2
a1044 1
						EnumBlockPacketCreationResult eBPCResult = CreateNextBlockPackage();
d1047 1
a1047 1
						// If packets creation was failed, client can be removed without data loss 
d1050 2
a1051 2
							// if client did not request data, keep him in the queue & give him a chance to request something
							// the client will be removed from UL queue after 2 min.
d1074 11
a1084 10
						// notify the remote client about the end of the session
						// note (offical): 
						// OP_OUTOFPARTREQS will tell the downloading client to go back to OnQueue..
						// The main reason for this is that if we put the client back on queue and it goes
						// back to the upload before the socket times out... We get a situation where the
						// downloader thinks it already sent the requested blocks and the uploader thinks
						// the downloader didn't send any request blocks. Then the connection times out..
						// note (ePlus):
						// ePlus is also using OP_QUEUERANKING to detect end of the session
							Packet* pCancelTransferPacket = new Packet(OP_OUTOFPARTREQS, 0);
d1095 1
a1095 1
				//	for the entire next block. There must also be blocks to send (not empty request queue)
d1099 1
a1099 1
						Packet*		pPacket = m_blockSendQueue.front();
d1110 1
a1110 1
						g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(),
d1115 1
a1115 1
																		pPacket->GetFilePriority());
a1125 1
						{
a1126 1
						}
d1129 1
a1129 1
				// check result of the data transfer
d1132 1
a1132 1
					// the size of the packet larger as allowed bandwidth
d1138 1
a1138 2
						{
						// If this slot wasn't given enough data to empty its request queue, it wants more data.
a1139 1
						}
d1141 1
a1141 2
						{
						// very rare case the size of the packets fits the bandwidth
d1143 1
a1143 1
						}
d1145 1
a1145 1
					//	can make sure we give it data often enough to not time out.
d1159 1
a1159 1
// in case of exception disconnect the client
d1162 1
a1162 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(err));
d1186 1
a1186 1
		Packet*	pPacket = m_blockSendQueue.front();
d1200 1
a1200 1
void CUpDownClient::SendHashsetPacket(char* fileHash)
d1204 1
a1204 1
	CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reinterpret_cast<BYTE*>(fileHash));
d1208 2
a1209 2
		AddDebugLogLine(RGB_LOG_ERROR + _T("Client '%s' (%s): requested file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(), HashToString(reinterpret_cast<BYTE*>(fileHash)));
	//	cause OP_HASHSETREQUEST can be abused for file-scanning
d1214 3
a1216 3
	uint16			uPartCount = pKnownFile->GetHashCount();
	uint32			dwHashSetLength = 16*uPartCount;
	CSafeMemFile		pbyteFileData(16+2+dwHashSetLength);
d1224 1
a1224 1
	Packet		*packet = new Packet(&pbyteFileData);
d1226 2
a1227 2
	packet->m_eOpcode = OP_HASHSETANSWER;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d1230 1
a1230 1
	m_pRequestSocket->SendPacket(packet, true, true);
d1270 1
a1271 1

d1280 1
a1280 3
	Packet* packet = new Packet(OP_QUEUERANKING, 12, OP_EMULEPROT);
	memset(packet->m_pcBuffer, 0, 12);
	*reinterpret_cast<uint16*>(packet->m_pcBuffer) = uRank;
d1282 4
a1285 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
d1287 1
a1287 1
	m_pRequestSocket->SendPacket(packet, true, true);
a1297 1
	{
d1299 1
a1299 1
	}
d1302 4
a1305 4
	EnumPartFileRating rating = pKnownFile->GetFileRating();
	CString desc = pKnownFile->GetFileComment();
	if (pKnownFile->GetFileRating() == PF_RATING_NONE && desc.IsEmpty())
	{
a1306 1
	}
d1310 3
a1312 1
	packetStream.Write(&rating, sizeof(rating));		// <rating 1>
d1314 2
a1315 1
	int		length = desc.GetLength();
d1317 1
a1317 5
	if (length > 128)
	{
		length = 128;
	}
	packetStream.Write(&length, sizeof(length));		// <commentlen 4>
d1319 2
a1320 4
	if (length > 0)
	{
		packetStream.Write(desc.GetBuffer(), length);	// (<commentchars 1>)*commentlen
	}
d1322 1
a1322 1
	Packet		*packet = new Packet(&packetStream, OP_EMULEPROT);
d1324 2
a1325 2
	packet->m_eOpcode = OP_FILEDESC;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
d1327 1
a1327 2

	m_pRequestSocket->SendPacket(packet, true);
d1333 1
a1333 1
void CUpDownClient::AddRequestCount(uchar* fileid)
d1337 1
a1337 1
	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL; )
d1341 1
a1341 1
		if (!md4cmp(pReqFile->m_fileHash, fileid))
a1345 1
				{
a1346 1
				}
a1347 1
				{
a1349 1
				}
a1353 1
				{
a1354 1
				}
d1361 1
a1361 1
//	if file was not found create a new file
d1363 1
d1365 1
a1365 1
	md4cpy(pNewFile->m_fileHash, fileid);
d1388 1
a1388 1
	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL; )
d1390 2
a1391 1
		Requested_File_Struct *pReqFile = static_cast<Requested_File_Struct*>(m_requestedFilesList.GetNext(pos));
d1400 1
a1400 1
void CUpDownClient::Ban(LPCTSTR line, const CString& reason, ...)
d1415 1
a1415 1
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s) banned and kicked out of uploadqueue %s"), GetUserName(), GetClientNameAndVersionString(), reason);
a1427 1
	{
d1429 1
a1429 1
	}
d1437 2
d1441 1
a1441 1
		CString	strMsg = line;
d1447 1
a1447 11
		if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
		{
			AddLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_SENTBAN), GetUserName(), reason);
		}
	}
	else
	{
		if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
		{
			AddLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_CLIENTBLOCKED), GetUserName(), reason);
		}
d1449 3
d1458 1
a1458 1
CString CUpDownClient::GetDownloadStateAsString(void)
a1474 1

a1475 1
	{
d1477 1
a1477 1
	}
d1479 1
a1479 2

	CKnownFile* pKnownReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash);
a1502 1
	{
d1504 1
a1504 1
	}
a1505 1
	{
a1506 1
	}
d1537 1
a1537 1
void CUpDownClient::SetUploadState(EnumULQState news)
d1539 1
a1539 1
	m_eUploadState = news;
@


1.258
log
@separate active clients & invited to upload if socket is busy
@
text
@d1104 1
a1104 1
						// downloader things it already send the requested blocks and the uploader thinks
@


1.257
log
@Add sources possibly received from global search (official).
Added missing translations in case countryflag.dll / ip-to-country.cvs is not found.
Notifier informs if a new version is available (not annoying, but still more likely
 to be noticed than just a log line).
Added 'Folder' column to Shared files window.
Prevent adding install/working dirs (\Webserver, \Db...) to Shared files.
+ some other minor changes/fixes.
@
text
@d1026 5
a1030 1
				eResult = BSR_BUSY;
@


1.256
log
@increased time period for stable speed estimation on line with big latency
@
text
@d564 1
d571 1
@


1.255
log
@Minor optimization.
@
text
@d1035 2
a1036 2
			// Don't store too much statistics. maximal 20 sec
				while ((dwTimePeriod = (curTick - m_averageULTickList.back())) > 20000)
@


1.254
log
@Removed unused code; Comments; Local optimization.
@
text
@d1036 1
a1036 1
				while ((dwTimePeriod = (m_averageULTickList.front() - m_averageULTickList.back())) > 20000)
@


1.253
log
@physicaly correct speed measurements
@
text
@d1001 1
a1001 1
	uint32 dwAmountTransferred = 0;
a1017 34
	// 1)  measure only already transfered data! the speed should be calculated before data transfer, otherwise
	//      not yet transfered data from current iteration will lead to higher(incorrect) speed value
	// 2)  use socket status to find out the correct time for the speed measurements, because any calculation of the average inbetween
	//      will decrease the calculated value, what does not reflect real situation
		if (m_pRequestSocket && !m_pRequestSocket->IsBusy())
		{
			m_averageUDRList.push_front(m_dwTransferredUp);
			m_averageULTickList.push_front(curTick);

		// Don't store too much statistics. maximal 20 sec
			while ((m_averageULTickList.front() - m_averageULTickList.back()) > 20000)
			{
				m_averageUDRList.pop_back();
				m_averageULTickList.pop_back();
			}

		//	Calculate average data rate
			sint32 lCurUpDataRate = -1;
			uint32 timePeriod = m_averageULTickList.front() - m_averageULTickList.back();

		//	Leave this slot's speed as 0 unless there's a good chunk of stored statistics for it (at least 10 samples ~ 1 sec).
			if (timePeriod > 1000)
			{
				lCurUpDataRate = static_cast<sint32>((static_cast<double>(m_averageUDRList.front() - m_averageUDRList.back())) * 1000.0 / timePeriod);
			}

		//	assign & update only if values are different
			if (m_lUpDataRate != lCurUpDataRate)
			{
				m_lUpDataRate = lCurUpDataRate;
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(this);
			}
		}

d1026 1
a1026 1
			else if(GetUploadState() == US_UPLOADING)
d1028 9
a1036 1
				if (m_blockSendQueue.empty())
d1038 3
a1040 30
				// If all packet were sended, try to create new.
					EnumBlockPacketCreationResult eBPCResult = CreateNextBlockPackage();
					if (eBPCResult != BPCR_OK)
					{
					// If packets creation was failed, client can be removed without data loss 
						if (eBPCResult == BPCR_FAILED_NO_REQUESTED_BLOCKS)
						{
						// if client did not request a data, keep him in the queue & give him a chance to request something.
						// the client will be removed from UL queue after 2 min.
							eResult = BSR_FAILED_NO_REQUESTED_BLOCKS;
							return 0;
						}
						else if (eBPCResult == BPCR_FAILED_BLOCKED_PART)
						{
							if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
								AddDebugLogLine(_T("Client %s (%s) left UL queue after receiving %u KB. Asked for new or blocked chunk/file"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
							g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
						}
						else if (eBPCResult == BPCR_FAILED_FILE_ERROR)
						{
							if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
								AddDebugLogLine(_T("Client %s (%s) left UL queue after receiving %u KB. Asked for unaccessible data (file removed, wrong request, etc)"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
							g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
						}
						else
						{
							if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
								AddDebugLogLine(_T("Client %s (%s) left UL queue after receiving %u KB. Upload timeout (low speed, no block request)"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
							g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
						}
d1042 2
a1043 12
					// notify the remote client about and of the session
					// note (offical): 
					// OP_OUTOFPARTREQS will tell the downloading client to go back to OnQueue..
					// The main reason for this is that if we put the client back on queue and it goes
					// back to the upload before the socket times out... We get a situation where the
					// downloader things it already send the requested blocks and the uploader thinks
					// the downloader didn't send any reqeust blocks. Then the connection times out..
					// note (ePlus):
					// ePlus is also using OP_QUEUERANKING to detect end of the session
						Packet* pCancelTransferPacket = new Packet(OP_OUTOFPARTREQS, 0);
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pCancelTransferPacket->m_dwSize);
						m_pRequestSocket->SendPacket(pCancelTransferPacket,true,true);
d1045 5
a1049 1
						g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this, true);
d1051 5
a1055 2
						return 0;
					}
d1058 1
a1058 3
			//	Feed data to this slot, one block at a time, as long as there's enough bandwidth left
			//	for the entire next block. There must also be blocks to send (not empty request queue)
				while ( !m_blockSendQueue.empty() )
d1060 51
a1110 25
				//	Get next block and give it to the Request Socket for transfer
					Packet*		pPacket = m_blockSendQueue.front();
					uint32		dwBlockSize = pPacket->GetRealPacketSize();

					if (dwBlockSize + dwAmountTransferred > dwMaxAmount)
						break;

					m_blockSendQueue.pop_front();

				//	Extended statistics information based on which client software and which port we sent this data to.
				//	This also updates the grand total for sent bytes, etc. And where this data came from.
				//	We have to call function before packet will be sent, otherwise packet will be deleted.
					g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(),
																	GetUserPort(), pPacket->IsFromPF(),
																	TRANSFERTYPE_UPLOAD,
																	dwBlockSize,
																	IsCommunity(),
																	pPacket->GetFilePriority());
					m_pRequestSocket->SendPacket(pPacket, true, false);
					pPacket = NULL;

				//	We've transferred some data. Store this in relevant statistics variables
					m_dwTransferredUp += dwBlockSize;
					dwAmountTransferred += dwBlockSize;
					m_pCredits->AddUploaded(dwBlockSize, this->GetIP());
d1112 3
a1114 2
				//	If we're out of prepared blocks, create some more
					if (m_blockSendQueue.empty())
d1116 31
a1146 1
						CreateNextBlockPackage();
a1147 1
				}
d1149 2
a1150 9
			// check result of the data transfer
				if (dwAmountTransferred == 0)
				{
				// the size of the packet larger as allowed bandwidth
					eResult = BSR_FAILED_NOT_ENOUGHT_BANDWIDTH;
				}
				else
				{
					if (!m_blockSendQueue.empty())
d1152 2
a1153 2
					// If this slot wasn't given enough data to empty its request queue, it wants more data.
						eResult = BSR_OK_WANTS_MORE_BANDWIDTH;
d1157 13
a1169 2
					// very rare case the size of the packets fits the bandwidth
						eResult = BSR_OK;
a1170 3
				//	Remember when this connection was last fed some data, so we
				//	can make sure we give it data often enough to not time out.
					SetLastGotULData();
a1419 1
	m_bIsHashThief = false;
@


1.252
log
@fixed exception in DownloadProcess (way my fault :( )
@
text
@d1018 34
a1181 33

	//	recalcualte the speed & request GUI update only in case if we transfer some data
	//	note: since performance is more importatnt than graphical output, this function was moved to the end

	//	Store how much data we've transferred this round,
	//	to be able to calculate average speed later
		m_averageUDRList.push_front(m_dwTransferredUp);
		m_averageULTickList.push_front(curTick);

	//	Don't store too much statistics
		while (m_averageULTickList.size() > 500)
		{
			m_averageUDRList.pop_back();
			m_averageULTickList.pop_back();
		}

	//	Calculate average data rate
		sint32 lCurUpDataRate = -1;
		uint32 timePeriod = m_averageULTickList.front() - m_averageULTickList.back();

	//	Leave this slot's speed as 0 unless there's a good chunk of stored statistics for it (at least 10 samples ~ 1 sec).
		if (timePeriod > 1000)
		{
			lCurUpDataRate = static_cast<sint32>((static_cast<double>(m_averageUDRList.front() - m_averageUDRList.back())) * 1000.0 / timePeriod);
		}

	//	assign & update only if values are different
		if (m_lUpDataRate != lCurUpDataRate)
		{
			m_lUpDataRate = lCurUpDataRate;
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(this);
		}

@


1.251
log
@changes in part control; hidden & blocked statuses are merged
@
text
@a1075 7
					// note: at this point remote client was removed from the UL queue & got the OP_OUTOFPARTREQS
					// with OP_QUEUERANKING (only if he was  able to enter into W queue). so we can shotdown the socket
						if (m_pRequestSocket)
						{
							m_pRequestSocket->Safe_Delete();
							m_pRequestSocket = NULL;
						}
@


1.250
log
@improved processing of user name & mod string
@
text
@d463 3
a465 4
			if (!srcfile->GetJumpstartEnabled())
			{
			//	Accessing a blocked part ?
				byte part_status = srcfile->GetPartStatus(dwPart);
d467 4
a470 11
				switch (part_status)
				{
					case PR_PART_OFF:
						AddLogLine(false, IDS_PARTPRIO_DENIED, dwPart, srcfile->GetFileName());
						sMessage.Format(GetResString(IDS_PARTPRIO_DENIED), dwPart, srcfile->GetFileName());
						eBPCResult = BPCR_FAILED_BLOCKED_PART;
						throw sMessage;
						break;
					case PR_PART_HIDDEN:
						AddLogLine(false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(), dwPart);
				}
@


1.249
log
@Improved BarShader constructor/destructor.
@
text
@d102 1
a102 1
	if (m_bIsUserNameChanged)
d133 1
@


1.248
log
@Show parts a remote user can get from you on upload progress bar (#522) {DopeFish}.
@
text
@d60 1
a60 1
	CBarShader	statusBar(rect->bottom - rect->top, rect->right - rect->left, dwFileSize);
a61 1
	statusBar.Fill(crNeither);
@


1.247
log
@Improved BarShared constructor.
@
text
@d18 1
a18 1
#include "StdAfx.h"
d43 2
d46 4
a49 10
//	Find the most used color
	COLORREF	crMostUsed;
	COLORREF	crLessUsed;
	byte		byteLessUsed;

	if ((GetAvailUpPartCount() * 2) < m_uUpPartCount)
	{
		crMostUsed = (bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240);
		crLessUsed = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);
		byteLessUsed = 1;
d53 2
a54 3
		crMostUsed = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);
		crLessUsed = (bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240);
		byteLessUsed = 0;
d58 3
a60 11
	CKnownFile	   *pUploadedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash);
	uint32			dwFileSize = (pUploadedFile != NULL) ? pUploadedFile->GetFileSize() : (m_uUpPartCount * PARTSIZE);
	CBarShader		statusBar(rect->bottom - rect->top, rect->right - rect->left, dwFileSize);

//	Fill the bar with the most used color
	statusBar.Fill(crMostUsed);

	uint32	dwUploadingPart = GetCurrentlyUploadingPart();
	uint32	dwLastPart = m_uUpPartCount - 1;
	uint32	dwStartPos;
	uint32	dwEndPos;
d62 2
a63 2
//	Draw the current uploading part if needed
	if (dwUploadingPart != 0xFFFF)
d65 2
a66 3
		dwStartPos = PARTSIZE * dwUploadingPart;
		dwEndPos = (dwUploadingPart != dwLastPart) ? PARTSIZE * (dwUploadingPart + 1) : dwFileSize;
		statusBar.FillRange(dwStartPos, dwEndPos, crSendingPart);
d68 1
a68 1
		if (!m_doneBlocksList.empty())
d70 6
a75 2
			ReqBlockDeque::iterator	itBlock;
			Requested_Block_Struct	   *pDoneBlock;
d77 2
a78 10
			for (itBlock = m_doneBlocksList.begin(); itBlock != m_doneBlocksList.end(); itBlock++)
			{
				pDoneBlock = *itBlock;
				if (dwUploadingPart == (pDoneBlock->m_dwStartOffset / PARTSIZE))
				{
					statusBar.FillRange(pDoneBlock->m_dwStartOffset, pDoneBlock->m_dwEndOffset, crSentData);
				}
			}
		}
	}
d80 2
a81 10
//	Draw the parts with the less used color if needed
	if (m_pbyteUpPartStatuses != NULL && GetAvailUpPartCount() > 0 && (dwUploadingPart == 0xFFFF || GetAvailUpPartCount() < dwLastPart))
	{
		dwStartPos = 0;
		dwEndPos = 0;
		for (uint32 i = 0; i < m_uUpPartCount; i++)
		{
			if (m_pbyteUpPartStatuses[i] == byteLessUsed && i != dwUploadingPart)
			{
				if (dwEndPos != PARTSIZE * i)
d83 3
a85 5
					if (dwStartPos != dwEndPos)
					{
						statusBar.FillRange(dwStartPos, dwEndPos, crLessUsed);
					}
					dwStartPos = PARTSIZE * i;
a86 1
				dwEndPos = PARTSIZE * (i + 1);
d88 4
a92 5
		if (dwEndPos > dwFileSize)
		{
			dwEndPos = dwFileSize;
		}
		statusBar.FillRange(dwStartPos, dwEndPos, crLessUsed);
a93 1

@


1.246
log
@Removed non-working code;
Removed speed reporting in OP_QUEUERANKING (it wasn't used on RX side).
@
text
@a61 2
	CBarShader statusBar(rect->bottom - rect->top, rect->right - rect->left);

d64 2
a65 11
	uint32			dwFileSize;

	if (pUploadedFile != NULL)
	{
		dwFileSize = pUploadedFile->GetFileSize();
	}
	else
	{
		dwFileSize = m_uUpPartCount * PARTSIZE;
	}
	statusBar.SetFileSize(dwFileSize);
@


1.245
log
@1) improved ZZ upload process
2) fixed possible upload break at last block in part
@
text
@a1315 25
double CUpDownClient::GetClientSpeed()
{
	EMULE_TRY
//	Calculates the session speed of the client. Providing the other Clients with this info
//	gives then the possibility to select the sources more wisely.
	if (g_eMuleApp.stat_transferStarttime == 0)
	{
		return 0.0;
	}

	DWORD running = (GetTickCount() - g_eMuleApp.stat_transferStarttime) / 1000;

	if (running < 5)
	{
		return 0.0;
	}

	return static_cast<double>(g_eMuleApp.stat_sessionSentBytes / 1024.0) / running;

	EMULE_CATCH

	return 0.0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a1348 1
	{
a1349 1
	}
a1352 1
	{
a1353 2
	}
	uint16 nRank = g_eMuleApp.m_pUploadQueue->GetWaitingPosition(this);
d1355 1
a1355 11
#ifndef DISABLE_EXTENDED_INFO_EXCHANGE
 #define DISABLE_EXTENDED_INFO_EXCHANGE
// The extended info exchange is currently disabled since it is possible
// to ask the client with several userhashes for the file and then use
// the one with the best UL/DL ratio
// It is planned to reactivate this feature, but with a protection against
// this userhash spoofing.
// At the last stage this faeture should make it possible to choose the
// sources more intelligently by taking UL/DL ratio, queuerank and
// speed of the other client into account.
#endif
d1357 1
a1357 3
#ifdef DISABLE_EXTENDED_INFO_EXCHANGE
	if (!nRank)
	{
a1358 27
	}
#else

	uint16 nBaseModifier = (uint16) GetScore(false, false, true);
	uint32 nScore = GetScore(false, false, false);

	byte nCommunity = -1;

	if (!g_eMuleApp.m_pGlobPrefs->CommunityEnabled())
	{
		nCommunity = 2;
	}
	else if (IsCommunity())
	{
		nCommunity = 1;
	}

	double dblBaseValue = 1.0;

	if (m_pCredits != (CClientCredits*)NULL)
	{
		dblBaseValue *= m_pCredits->GetScoreRatio(this->GetIP());
	}

	dblBaseValue *= 10;
	uint16 nRatio = (uint16)dblBaseValue;
#endif
a1359 3
	uint16 nClientSpeed = (uint16)((GetClientSpeed() < 65535) ? GetClientSpeed() : 65535);

//	Providing the other clients with this info can not be used to leech
d1361 2
a1362 11
	memzero(packet->m_pcBuffer, 12);
	memcpy2(packet->m_pcBuffer + 0, &nRank, 2);
#ifndef DISABLE_EXTENDED_INFO_EXCHANGE

	memcpy2(packet->m_pcBuffer + 2, &nBaseModifier, 1);		// UINT8 is enough 0-100
	memcpy2(packet->m_pcBuffer + 3, &nRatio, 2);			// UINT16 needed saw about 32000 max (SF * UL/DL * RF)
	memcpy2(packet->m_pcBuffer + 5, &nScore, 4);			// UINT32 needed
	memcpy2(packet->m_pcBuffer + 9, &nCommunity, 1);		// 2-Bits needed
#endif

	memcpy2(packet->m_pcBuffer + 10, &nClientSpeed, 2);		// UINT16 (I think not many have more than 65 MByte UL)
a1365 1

a1558 16
uint32	CUpDownClient::GetRemoteScore()
{
	EMULE_TRY

	if (IsRemoteInfoAvaiable())
	{
		return m_dwRemoteScore;
	}

	EMULE_CATCH

//	We do not know for how long we are on the queue.
//	Furhtermore the we do not know the remote ratio.
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a1561 2
	if (IsRemoteInfoAvaiable())
		return m_uRemoteRatio;
a1597 4
	if (IsRemoteInfoAvaiable())
	{
		return static_cast<double>(m_uRemoteBaseModifier) / 100.0;
	}
@


1.244
log
@Increased the limit as the previous change decreased it by interaction.
@
text
@d427 1
a427 1
bool CUpDownClient::CreateNextBlockPackage()
d431 6
d455 1
a455 5
			{
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
				if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
					AddDebugLogLine(_T("Client '%s' (%s) back on queue. Asked for a new chunk/file, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
			}
d457 1
a457 5
			{
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
				if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
					AddDebugLogLine(_T("Client '%s' (%s) back on queue. Asked for a chunk forbidden by Jumpstart, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
			}
d459 1
a459 9
			{
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
				if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
					AddDebugLogLine(_T("Client '%s' (%s) back on queue. Upload timeout, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(), GetSessionUp() / 1024);
			}

			g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this, true);

			return false;
a462 6
	if (m_blockRequestsQueue.empty())
	{
	//	There are no new blocks requested, we will happily transfer more if the client request it
		return false;
	}

d466 1
a469 5
	//	Repeat as long as next requested block is in the same chunk as previous blocks and
	//	as long as there is a next requested block. If a friend or lancast user, keep going!
//		while ( !m_blockRequestsQueue.empty() && (bAllowedMore || !IsDifferentPartBlock()) &&
//				!IsForbiddenByJumpstart() )

d485 1
a485 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
d497 1
a497 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
d515 1
a515 1
						g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
d547 1
a547 1
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
d562 1
a562 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
d600 2
a612 1
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
d614 1
a614 1
		return false;
a619 1
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
d623 1
a623 1
		return false;
d632 1
a632 1
		return false;
d635 1
a635 1
	return true;
d639 1
a639 1
	return false;
d1048 1
a1048 1
uint32 CUpDownClient::SendBlockData(uint32 nMaxAmmount, bool& wantsMoreBandwidth)
d1050 3
a1052 1
	EMULE_TRY
d1054 13
a1066 16
	DWORD curTick = GetTickCount();
//	This will be set to true if/when the slot is actually fed some data
	wantsMoreBandwidth = false;
	uint32 amounttransferred = 0;

//	Check for 'stuck' clients
	if ((curTick - GetLastGotULData() > 2 * 60 * 1000) && (GetUpStartTimeDelay() > 2 * 60 * 1000))
	{
	//	We were unable to transfer for 2 minutes, just remove the client from UL queue
	//	if client stays online, he will request file & added to the queue
		if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
			AddDebugLogLine( _T("Client '%s' (%s) appears to be stuck, putting back on queue"),
							 GetUserName(), GetClientNameAndVersionString() );
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_TIMEOUT);
		return 0;
	}
d1069 2
a1070 5
//	Only feed this slot new data if it has been able to empty
//	its buffer since we last offered data
	if (m_pRequestSocket && !m_pRequestSocket->IsBusy() && GetUploadState() == US_UPLOADING)
	{
		if (m_blockSendQueue.empty())
d1072 1
a1072 2
		//	No valid blocks to transfer. Put the client back on queue
			if (!CreateNextBlockPackage())
d1074 1
a1074 1
				return 0;
d1076 73
a1148 1
		}
d1150 23
a1172 27
	//	Feed data to this slot, one block at a time, as long as there's enough bandwidth left
	//	for the entire next block. There must also be blocks to send (not empty request queue)
		while ( !m_blockSendQueue.empty() &&
				m_blockSendQueue.front()->GetRealPacketSize() + amounttransferred <= nMaxAmmount )
		{
		//	Get next block and give it to the Request Socket for transfer
			Packet*		pPacket = m_blockSendQueue.front();
			uint32		nBlockSize = pPacket->GetRealPacketSize();

			m_blockSendQueue.pop_front();

		//	Extended statistics information based on which client software and which port we sent this data to.
		//	This also updates the grand total for sent bytes, etc. And where this data came from.
		//	We have to call function before packet will be sent, otherwise packet will be deleted.
			g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(),
															GetUserPort(), pPacket->IsFromPF(),
															TRANSFERTYPE_UPLOAD,
															nBlockSize,
															IsCommunity(),
															pPacket->GetFilePriority());
			m_pRequestSocket->SendPacket(pPacket, true, false);
			pPacket = NULL;

		//	We've transferred some data. Store this in relevant statistics variables
			m_dwTransferredUp += nBlockSize;
			amounttransferred += nBlockSize;
			m_pCredits->AddUploaded(nBlockSize, this->GetIP());
d1174 22
a1195 4
		//	If we're out of prepared blocks, create some more
			if (m_blockSendQueue.empty())
			{
				CreateNextBlockPackage();
d1198 15
d1214 2
a1215 2
	//	If this slot wasn't given enough data to empty its request queue, it wants more data.
		if (!m_blockSendQueue.empty())
d1217 2
a1218 1
			wantsMoreBandwidth = true;
d1221 6
a1226 3
	//	Remember when this connection was last fed some data, so we
	//	can make sure we give it data often enough to not time out.
		if (amounttransferred > 0)
d1228 1
a1228 1
			SetLastGotULData();
a1229 2
	}
#endif //OLD_SOCKETS_ENABLED
d1231 6
a1236 7
//	recalcualte the speed & request GUI update only in case if we transfer some data
//	note: since performance is more importatnt than graphical output, this function was moved to the end

//	Store how much data we've transferred this round,
//	to be able to calculate average speed later
	m_averageUDRList.push_front(m_dwTransferredUp);
	m_averageULTickList.push_front(curTick);
a1237 5
//	Don't store too much statistics
	while (m_averageULTickList.size() > 500)
	{
		m_averageUDRList.pop_back();
		m_averageULTickList.pop_back();
d1239 2
a1240 7

//	Calculate average data rate
	sint32 lCurUpDataRate = -1;
	uint32 timePeriod = m_averageULTickList.front() - m_averageULTickList.back();

//	Leave this slot's speed as 0 unless there's a good chunk of stored statistics for it (at least 10 samples ~ 1 sec).
	if (timePeriod > 1000)
d1242 3
a1244 1
		lCurUpDataRate = static_cast<sint32>((static_cast<double>(m_averageUDRList.front() - m_averageUDRList.back())) * 1000.0 / timePeriod);
d1246 1
a1246 3

//	assign & update only if values are different
	if (m_lUpDataRate != lCurUpDataRate)
d1248 1
a1248 2
		m_lUpDataRate = lCurUpDataRate;
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.UpdateClient(this);
d1251 1
a1251 5
	return amounttransferred;

	EMULE_CATCH

	return 0;
@


1.243
log
@improved upload, comments inside :)
@
text
@d439 1
a439 1
		if ( IsFriend() && GetSessionUp() < (PARTSIZE + EMBLOCKSIZE * 4)
d490 7
a496 5
	//	note: since this function is called if upload packets queue is empty,  during block packet creation the upload will be breaked
	//	therefore in order decrease the transfer break we gonna create just one block packet, what will decrease the break time in 3x.
	//	this will lead to
	//		1) faster response after initial request -> better number of successful UL session
	//		2) smaller delay during UL -> more full will be uploaded
@


1.242
log
@Send new ban message in one packet.
@
text
@d487 9
a495 2
		while ( !m_blockRequestsQueue.empty() && (bAllowedMore || !IsDifferentPartBlock()) &&
				!IsForbiddenByJumpstart() )
@


1.241
log
@Minor fix
@
text
@d1541 3
d1545 1
a1545 2
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.SendMessage(line);
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.SendMessage("Get more info at http://emuleplus.info/ban/");
@


1.240
log
@fixed slot speed calculation
@
text
@d1543 1
a1543 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.SendMessage("Get more info at http://emule.info/ban/");
@


1.239
log
@Minor changes
@
text
@d1145 9
a1153 1
	if (amounttransferred != 0)
d1155 3
a1157 4
	//	Store how much data we've transferred this round,
	//	to be able to calculate average speed later
		m_averageUDRList.push_front(m_dwTransferredUp);
		m_averageULTickList.push_front(curTick);
d1159 3
a1161 6
	//	Don't store too much statistics
		while (m_averageULTickList.size() > 500)
		{
			m_averageUDRList.pop_back();
			m_averageULTickList.pop_back();
		}
d1163 5
a1167 13
	//	Since performance is more importatnt than graphical output, this function was moved to the end
	//	Calculate average data rate
	//	Present this slot's speed as 0 unless there's a good chunk of stored statistics for it.
	//	If there's to little data, the UL speed will be far off, so we might as well hide it in those cases.
		uint32 timePeriod = m_averageULTickList.front() - m_averageULTickList.back();
		if (timePeriod > 5000)
		{
			m_lUpDataRate = static_cast<sint32>((static_cast<double>(m_averageUDRList.front() - m_averageUDRList.back())) * 1000.0 / timePeriod);
		}
		else
		{
			m_lUpDataRate = -1;
		}
d1169 4
@


1.238
log
@Minor preparations for new identification.
@
text
@d1543 1
@


1.237
log
@Own client type for eMule Plus clients.
@
text
@d201 1
a201 2
			 ( (GetModString() == _T(PLUS_VERSION_STR)) &&
			 ((GetMuleVersion() != CURRENT_VERSION_SHORT) || (GetPlusVersion() == 0)) ) )
@


1.236
log
@optimized sending of the hashset
@
text
@d1608 2
a1609 2
//	Official client doesnt have SF/RF push
	if (pKnownReqFile != NULL && this->GetPlusVersion() != 0)
@


1.235
log
@Fixed eMule Plus identification; Improved filtering; Removed unrequired log message.
@
text
@d1224 3
a1226 1
	CSafeMemFile		pbyteFileData(1024);
a1228 3

	uint16		uPartCount = pKnownFile->GetHashCount();

d1231 2
a1232 4
	for (int i = 0; i < uPartCount; i++)
	{
		pbyteFileData.Write(pKnownFile->GetPartHash(i), 16);
	}
@


1.234
log
@UL speed optimization (archive extension check)
@
text
@d201 2
a202 1
			 (GetModVersion() == _T(PLUS_VERSION_STR) && GetMuleVersion() != CURRENT_VERSION_SHORT ) )
d207 1
a207 4
				if (!m_strModVersion.IsEmpty())
					AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) using the mod %s has been banned"), GetUserName(), GetClientNameAndVersionString(), GetModVersion());
				else
					AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) has been banned"), GetUserName(), GetClientNameAndVersionString());
@


1.233
log
@Fixed processing of incorrect block request
(request could be beyond the end file, so incorrect data was uploaded);
Removed wraparound upload; all upload requests are limited to chunk boundaries
(all that was possible before in cases of LanCast, Friend Status, etc.).
@
text
@a579 2
			bool	bFromPF = (iRc) ? true : false;

d582 2
d588 1
a588 27
				bCompress = true;

				CString	strExt = srcfile->GetFileName();

				int pos = strExt.ReverseFind('.');
				if (pos > 0)
				{
					static const TCHAR s_apcExt[][4] =
					{
						_T("zip"), _T("rar"), _T("ace"), _T("arj"),
						_T("cab"), _T("tgz"), _T("gz"), _T("bz2")
					};

				//	Take lowercase extension without point
					strExt = strExt.Mid(pos + 1);
					strExt.MakeLower();

				//	Don't try to compress already compressed files
					for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcExt); ui++)
					{
						if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcExt[ui])) == 0)
						{
							bCompress = false;
							break;
						}
					}
				}
a590 2
			bool bPackedCreated = false;
			
@


1.232
log
@Minor formatting.
@
text
@d507 12
d522 1
a522 1
				byte part_status = srcfile->GetPartStatus(currentblock->m_dwStartOffset / PARTSIZE);
d527 2
a528 4
						AddLogLine( false, IDS_PARTPRIO_DENIED, currentblock->m_dwStartOffset / PARTSIZE,
									srcfile->GetFileName() );
						sMessage.Format( GetResString(IDS_PARTPRIO_DENIED), currentblock->m_dwStartOffset / PARTSIZE,
										 srcfile->GetFileName() );
d533 1
a533 2
						AddLogLine( false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(),
									currentblock->m_dwStartOffset / PARTSIZE );
d538 8
a545 1
			if (bAllowedMore)
d547 3
a549 17
			//	LAN clients are not limited by chunks boundaries.
			//	Is this a wraparound request?
				if (currentblock->m_dwStartOffset > currentblock->m_dwEndOffset - 1)
				{
				//	If m_dwStartOffset is later in the file than m_dwEndOffset, it means
				//	that the request is a wraparound request. It reads to the end of
				//	the file, then it wraps around and continues in the beginning of the file.

				//	Calculate how much the client is requesting, knowing that this is a wraparound request
					togo = currentblock->m_dwEndOffset + (srcfile->GetFileSize() - currentblock->m_dwStartOffset);
				}
				else
				{
				//	not a wraparound request. This makes it easier to calculate how many bytes is
				//	being requested.
					togo = currentblock->m_dwEndOffset - currentblock->m_dwStartOffset;
				}
a550 10
			else
			{
			//	Everyone else are limited to a single chunk
			//	Check that m_dwStartOffset and m_dwEndOffset is in the same chunk
				if (currentblock->m_dwStartOffset / PARTSIZE != (currentblock->m_dwEndOffset - 1) / PARTSIZE)
				{
				//	The m_dwEndOffset goes into the next chunk.
				//	Set it to the end of the chunk that m_dwStartOffset is in.
					currentblock->m_dwEndOffset = ((uint32)(currentblock->m_dwStartOffset / PARTSIZE) + 1) * PARTSIZE;
				}
d552 2
a553 9
			//	Make sure we don't pass end of file
				if (currentblock->m_dwStartOffset > currentblock->m_dwEndOffset)
				{
					currentblock->m_dwEndOffset = srcfile->GetFileSize();
				}

			//	This can't be a wrapped around request, since it has been limited to a single chunk.
				togo = currentblock->m_dwEndOffset - currentblock->m_dwStartOffset;
			}
d557 1
a557 3
				uint32 parts_start = ((currentblock->m_dwStartOffset) / PARTSIZE) * PARTSIZE;
				uint32 parts_end = ((currentblock->m_dwEndOffset - 1) / PARTSIZE + 1) * PARTSIZE - 1;
				if (!(reinterpret_cast<CPartFile*>(srcfile))->IsComplete(parts_start, parts_end))
@


1.231
log
@minor name correction
@
text
@d317 1
a317 1
	dblBaseValue *= dblFilePriority*dblSizeRatio*dblPopularityRatio;
d1023 1
a1023 1
void CUpDownClient::SetUploadFileID(uchar *tempreqfileid)
d1027 1
a1027 1
	if (tempreqfileid)
d1029 1
a1029 1
		md4cpy(m_reqFileHash, tempreqfileid);
@


1.230
log
@rollback of old waiting queue
@
text
@d470 1
a470 1
			g_eMuleApp.m_pUploadQueue->AddClientToQueue(this, true);
d1569 1
a1569 1
		g_eMuleApp.m_pUploadQueue->AddClientToQueue(this, true);
@


1.229
log
@some changes to make code looking better
@
text
@a144 2
	bool m_bIsCommunityPrevValue = m_bIsCommunity;

a177 4
//	if client on the queue & value is changed, then update position in waiting queue
	if (GetWaitingScore() != 0 && m_bIsCommunityPrevValue != m_bIsCommunity)
		g_eMuleApp.m_pUploadQueue->UpdateClientInWaitingQueue(this);

d185 1
a185 1
uint32 CUpDownClient::CalculateWaitingScore()
d187 2
d191 21
a211 6
	uint32	dwNewScore = 0;
	double	dblFilePriority = 0;
	double	dblWaitTimeValue = 0;
	double	dblBaseTimeValue = 0;
	double	dblSmallFilePushRatio = 0;
	double	dblRareFilePushRatio = 0;
d213 5
a217 4
//	calculate  the score if 
//	1. client is not violating the protocol (over name check)
//	2. client is not banned
//	3. cllient name has forbidden words
d219 2
a220 6
	if (!m_strUserName.IsEmpty()
		&& !m_bBanned
		&& !HasUserNameForbiddenStrings()
		&& !HasMODNameForbiddenStrings() 
		&& !(GetModVersion() == _T(PLUS_VERSION_STR) && GetMuleVersion() != CURRENT_VERSION_SHORT )
		&& !(GetMuleVersion() == 0 && GetVersion() == 0 && (GetClientSoft() == SO_EMULE || GetClientSoft() == SO_OLDEMULE)))
d222 7
a228 2
	//	get file priority & calculate coefficient for it
		CKnownFile* pKnownReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash);
d230 1
a230 10
		if (pKnownReqFile != NULL)
		{
			switch (pKnownReqFile->GetULPriority())
			{
				case PR_RELEASE:
					if (pKnownReqFile->IsPartFile())
						dblFilePriority = 5.0;
					else
						dblFilePriority = 10.0;
					break;
d232 2
a233 3
				case PR_HIGH:
					dblFilePriority = 2.0;
					break;
d235 2
a236 3
				case PR_LOW:
					dblFilePriority = 0.5;
					break;
d238 1
a238 3
				case PR_VERYLOW:
					dblFilePriority = 0.2;
					break;
d240 8
a247 5
				case PR_NORMAL:
				default:
					dblFilePriority = 1.0;	// standard
					break;
			}
d249 3
a251 4
		//	Small and/or Rare file push
			dblSmallFilePushRatio = pKnownReqFile->GetSizeRatio();
			dblRareFilePushRatio = pKnownReqFile->GetPopularityRatio();
		}
d253 3
a255 7
	//	calculate time based value. note: for dowloading clients the score will be calcualted as if they are enter into the waiting queue
		uint32 dwWaitTime;
	
		if (!IsDownloading())
			dwWaitTime = m_dwWaitTime;
		else
			dwWaitTime = ::GetTickCount();
d257 3
a259 2
	//	calculate wait time relative maximal time
		dblWaitTimeValue = static_cast<double>(0xFFFFFFFF - dwWaitTime + g_eMuleApp.stat_starttime) / 1000.0;
d261 5
a265 2
	//e: get base time unit for boost calculations
		dblBaseTimeValue = static_cast<double>(PARTSIZE)/static_cast<double>(g_eMuleApp.m_pGlobPrefs->GetMaxUpload()*1024.0);
d267 2
a268 14
	//	check status coeffecient
		if (IsFriend())
		{
		//	Client is on friendlist
			dblBaseTimeValue *= 2.0;
		}
		else
		{
		//	Client is a community user
			if (IsCommunity())
			{
				dblBaseTimeValue *= 1.5;
			}
		}
d270 20
a289 5
	//	Client has credits (modifier between 1.0 and 10.0)
		if (m_pCredits != NULL)
		{
			dblBaseTimeValue *= m_pCredits->GetScoreRatio(this->GetIP());
		}
d291 9
a299 2
	//	Little penalty for _very_ old clients that are harmful for servers and network (from official)
		if((IsEmuleClient() && m_byteEmuleVersion <= 0x19) || this->GetClientSoft() == SO_SHAREAZA)
d301 1
a301 1
			dblBaseTimeValue *= 0.5f;
d303 1
d305 5
a309 2
	//	use file related coefficients: Priority, Small and/or Rare file push
		dblBaseTimeValue *= dblSmallFilePushRatio*dblRareFilePushRatio*dblFilePriority;
d311 4
a314 1
		dwNewScore = static_cast<uint32>(dblWaitTimeValue + dblBaseTimeValue);
d317 1
a317 1
	m_dwWaitingScore = dwNewScore;
d319 1
a319 1
	return dwNewScore;
d323 1
a323 1
	return 0;
d443 1
a443 2
			 && !g_eMuleApp.m_pUploadQueue->IsULPermitedByWaitingScore(this) 
			 && !bJSIsBlocked )
d470 1
a470 1
			g_eMuleApp.m_pUploadQueue->CheckAndAddClientToWaitingQueue(this);
d1023 1
a1023 1
void CUpDownClient::SetUploadFileID(uchar *pNewReqFileID)
a1025 1
	bool bIsOtherFileRequested = false;
d1027 1
a1027 1
	if (pNewReqFileID)
d1029 1
a1029 5
		if (md4cmp(m_reqFileHash, pNewReqFileID) != 0)
		{
			bIsOtherFileRequested = true;
		}
		md4cpy(m_reqFileHash, pNewReqFileID);
d1033 1
a1033 6
	//	check hash state & do nothing if it already was cleared
		if (md4cmp0(m_reqFileHash) != 0)
		{
			bIsOtherFileRequested = true;
			md4clr(m_reqFileHash);
		}
a1035 4
//	if client in the queue & he chosen another file, then update position in waiting queue
	if (GetWaitingScore() != 0 && bIsOtherFileRequested)
		g_eMuleApp.m_pUploadQueue->UpdateClientInWaitingQueue(this);

d1363 1
a1363 2

	uint16 nRank = GetPosInWaitingQueue();
d1384 2
a1385 3
//	???
	uint16 nBaseModifier = (uint16) GetWaitingScore();
	uint32 nScore = GetWaitingScore();
d1569 1
a1569 1
		g_eMuleApp.m_pUploadQueue->CheckAndAddClientToWaitingQueue(this);
@


1.228
log
@1) the agressivity check moved in ListenSocket
2) optimized client addition to the waiting queue
@
text
@d828 1
a828 1
		Packet		*packet = new Packet(OP_SENDINGPART, nPacketSize + 24, OP_EDONKEYPROT, bFromPF, byteFilePriority);
d906 1
a906 1
		Packet* packet = new Packet(OP_COMPRESSEDPART, nPacketSize + 24, OP_EMULEPROT, bFromPF, byteFilePriority);
@


1.227
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d452 1
a452 1
			g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this);
d1115 2
a1116 1
	//	We were unable to transfer for 2 minutes, put the client back on queue
a1120 1
		g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this);
a1507 1

d1511 2
d1567 1
a1567 1
		g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(this);
@


1.226
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d620 1
a620 1
				bPackedCreated = CreatePackedPackets(filedata, togo, currentblock, bFromPF);
d624 1
a624 1
				bPackedCreated = CreateStandardPackets(filedata, togo, currentblock, bFromPF);
d802 1
a802 1
bool CUpDownClient::CreateStandardPackets(byte* pbyteFileData, uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d828 1
a828 1
		Packet		*packet = new Packet(OP_SENDINGPART, nPacketSize + 24, OP_EDONKEYPROT, bFromPF);
d841 1
a841 1
		if (SplitAndAddPacketsToSendQueue(packet, &blockSendTempQueue, bFromPF))
d867 1
a867 1
bool CUpDownClient::CreatePackedPackets(byte* pbyteFileData, uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d878 1
a878 1
		return CreateStandardPackets(pbyteFileData, togo, currentblock, bFromPF);;
d906 1
a906 1
		Packet* packet = new Packet(OP_COMPRESSEDPART, nPacketSize + 24, OP_EMULEPROT, bFromPF);
d916 1
a916 1
		if (!SplitAndAddPacketsToSendQueue(packet, &blockSendTempQueue, bFromPF))
d945 1
a945 1
bool CUpDownClient::SplitAndAddPacketsToSendQueue(Packet* pPacket, PacketDeque* pSendQueue, bool bFromPF)
d968 1
a968 1
				pPacket = new Packet(pBuffer2, nNewSize, (nNewSize < MAXFRAGSIZE), bFromPF);
d1152 6
a1157 1
			g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), pPacket->IsFromPF(), TRANSFERTYPE_UPLOAD, nBlockSize, IsCommunity());
@


1.225
log
@SSWQ
@
text
@d247 2
a248 2
			dblSmallFilePushRatio = GetSmallFilePushRatio();
			dblRareFilePushRatio = GetRareFilePushRatio();
a306 49
double CUpDownClient::GetSmallFilePushRatio()
{
	EMULE_TRY

	CKnownFile * srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_reqFileHash);

	if (srcfile == NULL)
	{
		return 1.0;
	}

	long lFileSize = srcfile->GetFileSize();

	if (lFileSize > 0.0 && lFileSize < 9961472)
	{
		double		dUploadModifier = 9961472.0 / lFileSize;

		if (dUploadModifier > 100.0)
		{
			dUploadModifier = 100.0;
		}

		return dUploadModifier;
	}

	EMULE_CATCH

	return 1.0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double CUpDownClient::GetRareFilePushRatio()
{
	EMULE_TRY

	CKnownFile * srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_reqFileHash);

	if (srcfile == NULL)
		return 1.0;

//	Keep the FileRatio
	double ratio = 0 + srcfile->GetFileRatio();

	return(ratio < 1.0 ? 1.0 : ((ratio > 100.0) ? 100.0 : ratio));

	EMULE_CATCH

	return 1.0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d1647 2
d1651 1
a1651 1
	if (this->GetPlusVersion() != 0)
d1653 2
a1654 2
		dblBaseValue *= GetSmallFilePushRatio() ;
		dblBaseValue *= GetRareFilePushRatio() ;
@


1.224
log
@Preparations for new client version report code.
@
text
@d145 2
d180 4
d191 1
a191 1
uint32 CUpDownClient::GetScore(bool sysvalue, bool isdownloading, bool onlybasevalue)
d193 1
a193 1
	static DWORD	dwLastMsgTime = 0;
d195 6
a200 1
	EMULE_TRY
d202 4
a205 2
	if (m_strUserName.IsEmpty())
		return 0;
d207 6
a212 1
	if (m_bBanned)
d214 4
a217 6
		return 0;
	}
	else
	{
		if ( HasUserNameForbiddenStrings() || HasMODNameForbiddenStrings() ||
			 (GetModVersion() == _T(PLUS_VERSION_STR) && GetMuleVersion() != CURRENT_VERSION_SHORT ) )
d219 1
a219 2
		//	Spam control
			if (::GetTickCount() > dwLastMsgTime + (60 * 1000))
d221 14
a234 4
				if (!m_strModVersion.IsEmpty())
					AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) using the mod %s has been banned"), GetUserName(), GetClientNameAndVersionString(), GetModVersion());
				else
					AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) has been banned"), GetUserName(), GetClientNameAndVersionString());
d236 3
a238 1
				Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_LEECHERADV));
d240 4
a243 1
				dwLastMsgTime = ::GetTickCount();
a244 3
			return 0;
		}
	}
d246 3
a248 7
#ifdef OLD_SOCKETS_ENABLED
	if (!isdownloading && !onlybasevalue)
	{
		if (HasLowID() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
		{
			if (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID())
				return 0;
a249 2
	}
#endif //OLD_SOCKETS_ENABLED
d251 7
a257 1
	CKnownFile* req_file = g_eMuleApp.m_pSharedFilesList->GetFileByID(m_reqFileHash);
d259 2
a260 2
	if (req_file == NULL)
		return 0;
d262 2
a263 2
// 	i_a: m_reqFileHash is an array so the if() was superfluous
	ASSERT(m_reqFileHash != NULL);
d265 14
a278 1
	double	dFilePriority;
d280 5
a284 47
	switch (req_file->GetPriority())
	{
		case PR_RELEASE:
			if (req_file->IsPartFile())
				dFilePriority = 5.0;
			else
				dFilePriority = 10.0;
			break;

		case PR_HIGH:
			dFilePriority = 2.0;
			break;

		case PR_LOW:
			dFilePriority = 0.5;
			break;

		case PR_VERYLOW:
			dFilePriority = 0.2;
			break;

		case PR_NORMAL:
		default:
			dFilePriority = 1.0;	// standard
			break;
	}

//	Calculate score, based on waiting time and other factors
	double		dblBaseValue;
	if (onlybasevalue)
	{
		dblBaseValue = 100.0f;
	}
	else if (!isdownloading)
	{
		dblBaseValue = static_cast<double>(GetTickCount() - m_dwWaitTime) / 1000.0;
	}
	else
	{
	//	We don't want one client to download forever
	//	the first 15 min download time counts as 15 min waitingtime and you get a 15 min bonus while you are in the first 15 min :)
	//	(to avoid 20 sec downloads) after this the score won't raise anymore
		dblBaseValue = static_cast<double>(m_dwUploadTime - m_dwWaitTime);
		ASSERT (m_dwUploadTime - m_dwWaitTime >= 0); //oct 28, 02: changed this from "> 0" to ">= 0"
		dblBaseValue += static_cast<double>((GetTickCount() - m_dwUploadTime > 900000) ? 900000.0 : 1800000.0);
		dblBaseValue /= 1000.0;
	}
d286 2
a287 9
	if (IsFriend())
	{
	//	Client is on friendlist
		dblBaseValue *= 2.0;
	}
	else
	{
	//	Client is a community user
		if (IsCommunity())
d289 1
a289 1
			dblBaseValue *= 1.5;
a290 1
	}
d292 2
a293 5
//	Client has credits (modifier between 1.0 and 10.0)
	if (m_pCredits != NULL)
	{
		dblBaseValue *= m_pCredits->GetScoreRatio(this->GetIP());
	}
d295 1
a295 4
//	Little penalty for _very_ old clients that are harmful for servers and network (from official)
	if((IsEmuleClient() && m_byteEmuleVersion <= 0x19) || this->GetClientSoft() == SO_SHAREAZA)
	{
		dblBaseValue *= 0.5f;
d298 1
a298 5
//	Small and/or Rare file push
	dblBaseValue *= GetSmallFilePushRatio();
	dblBaseValue *= GetRareFilePushRatio();

	dblBaseValue *= dFilePriority;
d300 1
a300 1
	return static_cast<uint32>(dblBaseValue);
d304 1
a304 1
	return 1;
d473 2
a474 1
			 && !g_eMuleApp.m_pUploadQueue->CheckForTimeOver(this) && !bJSIsBlocked )
a481 2
			SetWaitStartTime();

d501 1
a501 1
			g_eMuleApp.m_pUploadQueue->AddClientToQueue(this, true);
d1054 1
a1054 1
void CUpDownClient::SetUploadFileID(uchar *tempreqfileid)
d1057 1
d1059 1
a1059 1
	if (tempreqfileid)
d1061 5
a1065 1
		md4cpy(m_reqFileHash, tempreqfileid);
d1069 6
a1074 1
		md4clr(m_reqFileHash);
d1077 4
a1167 1
		SetWaitStartTime();
d1169 1
a1169 1
		g_eMuleApp.m_pUploadQueue->AddClientToQueue(this, true);
d1403 2
a1404 1
	uint16 nRank = g_eMuleApp.m_pUploadQueue->GetWaitingPosition(this);
d1425 3
a1427 2
	uint16 nBaseModifier = (uint16) GetScore(false, false, true);
	uint32 nScore = GetScore(false, false, false);
d1610 1
a1610 1
		g_eMuleApp.m_pUploadQueue->AddClientToQueue(this, true);
@


1.223
log
@Memory leak after exception; Improved string processing inside exception handler.
@
text
@d207 1
a207 1
					AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) using the mod %s has been banned"), GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d209 1
a209 1
					AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) has been banned"), GetUserName(), GetClientNameAndVersionString(this));
d419 1
a419 1
				AddDebugLogLine(_T("Client '%s' (%s) continues downloading (should be back on queue) because of a low transferred size"), GetUserName(), GetClientNameAndVersionString(this));
d497 1
a497 1
				AddDebugLogLine(_T("Client '%s' (%s) downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend"), GetUserName(), GetClientNameAndVersionString(this), this->GetSessionUp() / 1024);
d507 1
a507 1
					AddDebugLogLine(_T("Client '%s' (%s) back on queue. Asked for a new chunk/file, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d513 1
a513 1
					AddDebugLogLine(_T("Client '%s' (%s) back on queue. Asked for a chunk forbidden by Jumpstart, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d519 1
a519 1
					AddDebugLogLine(_T("Client '%s' (%s) back on queue. Upload timeout, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d739 1
a739 1
		AddDebugLogLine(_T("Client '%s' (%s) caused an error while creating package (%s), disconnecting!"), GetUserName(), GetClientNameAndVersionString(this), strError);
d1174 1
a1174 1
							 GetUserName(), GetClientNameAndVersionString(this) );
d1313 1
a1313 1
		AddDebugLogLine(RGB_LOG_ERROR + _T("Client '%s' (%s): requested file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(reinterpret_cast<BYTE*>(fileHash)));
d1614 1
a1614 1
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s) banned and kicked out of uploadqueue %s"), GetUserName(), GetClientNameAndVersionString(this), reason);
@


1.222
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@d732 1
a732 1
			delete filedata;
d736 1
a736 1
	catch (CString & error)
d739 1
a739 1
		AddDebugLogLine(_T("Client '%s' (%s) caused an error while creating package (%s), disconnecting!"), GetUserName(), GetClientNameAndVersionString(this), error.GetBuffer());
d742 1
a742 1
			delete filedata;
@


1.221
log
@fixed flaw in packet creation, that could lead to corrupted part
@
text
@d145 1
a145 1
	if (!m_bCommunityIsCached)
a146 1
		m_bCommunityIsCached = true;
d177 1
a184 10
void CUpDownClient::ResetValueCache()
{
	EMULE_TRY

	m_bScoreBaseIsCached = false;
	m_bCommunityIsCached = false;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d200 1
a200 1
		if ( IsStolenName(m_strUserName) || IsLeecherType(m_strModVersion) ||
d1240 7
a1246 4
//	Store how much data we've transferred this round,
//	to be able to calculate average speed later
	m_averageUDRList.push_front(m_dwTransferredUp);
	m_averageULTickList.push_front(curTick);
d1248 6
a1253 6
//	Don't store too much statistics
	while (m_averageULTickList.size() > 500)
	{
		m_averageUDRList.pop_back();
		m_averageULTickList.pop_back();
	}
d1255 1
a1255 4
//	Since performance is more importatnt than graphical output, this function was moved to the end
//	Check if it's time to update the display.
	if (curTick - m_dwLastRefreshedULDisplayTime > MINWAIT_BEFORE_ULDISPLAY_WINDOWUPDATE && m_averageUDRList.size() >= 2)
	{
d1268 1
a1269 1
		m_dwLastRefreshedULDisplayTime = curTick + (uint32)(rand() / (RAND_MAX / 1000));
@


1.220
log
@Fixed a GUI glitch in Messages window when multiple tabs are open and windows is themed;
Name changes, formatting etc.
@
text
@d93 1
a93 1
		if (!m_doneBlocksList.IsEmpty())
d95 1
d98 1
a98 1
			for (POSITION pos = m_doneBlocksList.GetHeadPosition(); pos != NULL; )
d100 1
a100 1
				pDoneBlock = m_doneBlocksList.GetNext(pos);
d397 1
a397 1
		if (!m_blockRequestsQueue.IsEmpty() && !m_doneBlocksList.IsEmpty())
d400 2
a401 2
			Requested_Block_Struct	*last_done_block = m_doneBlocksList.GetHead();
			Requested_Block_Struct	*next_requested_block = m_blockRequestsQueue.GetHead();
d444 1
a444 1
	if (m_blockRequestsQueue.IsEmpty())
d450 1
a450 1
		next_requested_block = (Requested_Block_Struct*)m_blockRequestsQueue.GetHead();
d538 1
a538 1
	if (m_blockRequestsQueue.IsEmpty())
d552 1
a552 1
		while ( !m_blockRequestsQueue.IsEmpty() && (bAllowedMore || !IsDifferentPartBlock()) &&
d555 1
a555 1
			Requested_Block_Struct * currentblock = m_blockRequestsQueue.GetHead();
d695 3
d700 1
a700 1
				CreatePackedPackets(filedata, togo, currentblock, bFromPF);
d704 1
a704 1
				CreateStandardPackets(filedata, togo, currentblock, bFromPF);
d707 5
a711 2
		//	File statistic
			srcfile->statistic.AddTransferred(togo);
d713 1
a713 1
			srcfile->statistic.AddTraffic(currentblock->m_dwStartOffset, togo);
d715 6
a720 3
			if (srcfile->GetJumpstartEnabled())
			{
				srcfile->AddSentBlock(this, currentblock->m_dwStartOffset, togo);
d723 1
a723 1
			m_doneBlocksList.AddHead(m_blockRequestsQueue.RemoveHead());
d882 1
a882 1
void CUpDownClient::CreateStandardPackets(byte* pbyteFileData, uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d888 1
d920 19
d940 1
a940 2
		SplitAndAddPacketsToSendQueue(packet, bFromPF);
	}
d943 2
d947 1
a947 1
void CUpDownClient::CreatePackedPackets(byte* pbyteFileData, uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d958 1
a958 2
		CreateStandardPackets(pbyteFileData, togo, currentblock, bFromPF);
		return;
d961 5
d968 1
a968 1
	CMemFile memfile(output, newsize);
a969 2
	uint32 nPacketSize;

d995 11
a1005 1
		SplitAndAddPacketsToSendQueue(packet, bFromPF);
d1009 9
d1019 2
d1025 1
a1025 1
void CUpDownClient::SplitAndAddPacketsToSendQueue(Packet* packet, bool bFromPF)
d1029 1
a1029 1
	if (packet->GetRealPacketSize() > 0 && packet->GetRealPacketSize() > MAXFRAGSIZE * 2)
d1032 3
a1034 3
		uint32 nSize = packet->GetRealPacketSize();
		char* m_pcBuffer = packet->DetachPacket();
		delete packet;
d1037 3
a1039 2
		bool bLast = true;
		while (nPos < nSize)
d1041 2
d1044 22
a1065 5
			char* pBuffer2 = new char[nNewSize];
			memcpy2(pBuffer2, m_pcBuffer + nPos, nNewSize);
			nPos += nNewSize;
			m_blockSendQueue.AddTail(new Packet(pBuffer2, nNewSize, (nNewSize < MAXFRAGSIZE), bFromPF));
			bLast = false;
d1068 4
d1075 1
a1075 1
		m_blockSendQueue.AddTail(packet);
d1078 2
d1081 2
d1105 3
a1107 1
	for (POSITION pos = m_doneBlocksList.GetHeadPosition(); pos != NULL; )
d1109 1
a1109 1
		Requested_Block_Struct* pFinishedBlock = static_cast<Requested_Block_Struct*>(m_doneBlocksList.GetNext(pos));
d1118 1
a1118 1
	for (POSITION pos = m_blockRequestsQueue.GetHeadPosition(); pos != NULL; )
d1120 1
a1120 1
		Requested_Block_Struct* pReqBlock = static_cast<Requested_Block_Struct*>(m_blockRequestsQueue.GetNext(pos));
d1132 1
a1132 1
	m_blockRequestsQueue.AddTail(pNewBlock);
d1196 1
a1196 1
		if (m_blockSendQueue.IsEmpty())
d1207 2
a1208 2
		while ( !m_blockSendQueue.IsEmpty() &&
				m_blockSendQueue.GetHead()->GetRealPacketSize() + amounttransferred <= nMaxAmmount )
d1211 1
a1211 1
			Packet		*pPacket = m_blockSendQueue.RemoveHead();
d1214 2
d1229 1
a1229 1
			if (m_blockSendQueue.IsEmpty())
d1236 1
a1236 1
		if (!m_blockSendQueue.IsEmpty())
d1298 1
a1298 1
	while ( !m_blockSendQueue.IsEmpty() && m_blockSendQueue.GetHead()->IsSplit() &&
d1301 4
a1304 1
		Packet	*pPacket = m_blockSendQueue.RemoveHead();
d1385 1
a1385 1
	while (!m_blockRequestsQueue.IsEmpty())
d1387 2
a1388 1
		delete m_blockRequestsQueue.RemoveHead();
d1391 1
a1391 1
	while (!m_blockSendQueue.IsEmpty())
d1393 2
a1394 1
		delete m_blockSendQueue.RemoveHead();
d1397 1
a1397 1
	while (!m_doneBlocksList.IsEmpty())
d1399 2
a1400 1
		delete m_doneBlocksList.RemoveHead();
d1755 1
a1755 1
	if (!m_doneBlocksList.IsEmpty())
d1758 1
a1758 1
		Requested_Block_Struct		*pFirstDoneBlock = m_doneBlocksList.GetHead();
@


1.219
log
@Minor log changes
@
text
@d1557 3
a1559 3
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.StartSession(this, false);
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.SendMessage(line);
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.EndSession(this, false);
@


1.218
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a559 1

d637 2
d640 1
a640 1
					throw CString(_T("asked for incomplete block"));
d652 2
d655 1
a655 1
				throw CString(_T("failed to open requested file"));
d739 1
a739 1
		AddDebugLogLine(_T("Client '%s' (%s) caused an error while creating package (%s), disconnecting client!"), GetUserName(), GetClientNameAndVersionString(this), error.GetBuffer());
@


1.217
log
@removed ignoring of [funnynick]
@
text
@d216 1
a216 1
					AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) using the mod %s has been banned"), GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d218 1
a218 1
					AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) has been banned"), GetUserName(), GetClientNameAndVersionString(this));
d426 1
a426 1
			if (!silent)
d428 1
a428 1
				AddDebugLogLine(false, _T("Client '%s' (%s) continues downloading (should be back on queue) because of a low transferred size"), GetUserName(), GetClientNameAndVersionString(this));
d505 2
a506 1
			AddDebugLogLine(false, _T("Client '%s' (%s) downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend"), GetUserName(), GetClientNameAndVersionString(this), this->GetSessionUp() / 1024);
d515 2
a516 1
				AddDebugLogLine(false, _T("Client '%s' (%s) back on queue. Asked for a new chunk/file, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d521 2
a522 1
				AddDebugLogLine(false, _T("Client '%s' (%s) back on queue. Asked for a chunk forbidden by Jumpstart, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d527 2
a528 1
				AddDebugLogLine(false, _T("Client '%s' (%s) back on queue. Upload timeout, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d718 1
a718 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d726 1
a726 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d736 1
a736 1
		AddDebugLogLine(false, _T("Client '%s' (%s) caused an error while creating package (%s), disconnecting client!"), GetUserName(), GetClientNameAndVersionString(this), error.GetBuffer());
d1095 3
a1097 2
		AddDebugLogLine( false, _T("Client '%s' (%s) appears to be stuck, putting back on queue"),
						 GetUserName(), GetClientNameAndVersionString(this) );
d1231 1
a1231 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Client '%s' (%s): requested file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(reinterpret_cast<BYTE*>(fileHash)));
d1529 1
a1529 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' (%s) banned and kicked out of uploadqueue %s"), GetUserName(), GetClientNameAndVersionString(this), reason);
@


1.216
log
@changed iscommunity-check
@
text
@a164 1
				strLowerUserName.Replace(_T("[funnynick]"), _T(""));
@


1.215
log
@Ops!
@
text
@d143 1
a143 1

d146 14
a159 2
		CString username(m_strUserName);
		username.MakeLower();
d161 15
a175 2
		if (username.Find("[ePlus]") >= 0)
			return false;
a176 9
		CString community(g_eMuleApp.m_pGlobPrefs->CommunityString());
		community.MakeLower();
		CString communityok;

		community.Remove('[');
		community.Remove(']');
		communityok.Format("[%s]", community);
		m_bIsCommunity = (username.Find(communityok) >= 0);
		m_bCommunityIsCached = true;
a297 1
//	Client is on friendlist
d299 2
d302 9
a310 4

//	Client is a community user
	if (g_eMuleApp.m_pGlobPrefs->CommunityEnabled() && IsCommunity() && !IsFriend())
		dblBaseValue *= 1.5;
@


1.214
log
@Reverted some changes...
@
text
@d149 1
a149 1
		if (username.Find("[ePlus]" >= 0)
@


1.213
log
@Some changes to fix the focus change issue
@
text
@d148 4
d156 1
a156 1
		community.Remove( '[' );
@


1.212
log
@Changed CS and Friends scores
@
text
@d1524 1
a1524 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.StartSession(this);
d1526 1
a1526 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.EndSession(this);
@


1.211
log
@Fixed sending of additional incorrect OP_REASKACK packet;
Fixed double asked count increment during OP_REASKFILEPING processing.
@
text
@a176 1
//	Spam control
d193 1
a193 1
		// Spam control
d283 2
a284 2
	if (g_eMuleApp.m_pGlobPrefs->CommunityEnabled() && IsCommunity())
		dblBaseValue *= 2.0;
@


1.210
log
@minor changes.
@
text
@a1545 27
void CUpDownClient::UDPFileReasked()
{
	EMULE_TRY

	AddAskedCount();
	SetLastUpRequest();
	SetLastL2HACExecution();

	uint16		uQueueRank = g_eMuleApp.m_pUploadQueue->GetWaitingPosition(this);

	Packet		*pPacket = new Packet(OP_REASKACK, 2, OP_EMULEPROT);

	memcpy2(pPacket->m_pcBuffer, &uQueueRank, 2);	// <queuerank 2>

	ProxySettings		proxy = g_eMuleApp.m_pGlobPrefs->GetProxy();

	if (!proxy.m_bUseProxy)
	{
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);

#ifdef OLD_SOCKETS_ENABLED
		g_eMuleApp.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort());
#endif OLD_SOCKETS_ENABLED
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.209
log
@Community statistics
@
text
@d198 1
a198 1
					AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T(": Anti-leechermods: Client '%s' (%s) using the mod %s has been banned"), GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d200 1
a200 1
					AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T(": Anti-leechermods: Client '%s' (%s) has been banned"), GetUserName(), GetClientNameAndVersionString(this));
@


1.208
log
@Removed debug log translations + minor additions + minor change
@
text
@d1101 1
a1101 1
			g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), pPacket->IsFromPF(), TRANSFERTYPE_UPLOAD, nBlockSize);
@


1.207
log
@Make log message in the same style as others.
@
text
@d611 1
a611 1
					throw GetResString(IDS_ERR_INCOMPLETEBLOCK);
d624 1
a624 1
				throw GetResString(IDS_ERR_OPEN);
@


1.206
log
@Fixes
@
text
@d1067 1
a1067 1
		AddDebugLogLine( false, _T("Client %s(%s) appears to be stuck, putting back on queue"),
@


1.205
log
@Added client version info to debug log messages.
@
text
@d534 1
a534 1
				srtError.Format(RGB_LOG_ERROR + _T("Client '%s' (%s): requested file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(currentblock->m_fileHash));
@


1.204
log
@Enable compression for .ogm files (they can be compressed quite well).
@
text
@d404 1
a404 1
				AddDebugLogLine(false, _T("Client '%s' continues downloading (should be back on queue) because of a low transferred size"), GetUserName());
d481 1
a481 1
			AddDebugLogLine(false, _T("Client '%s' downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend"), GetUserName(), this->GetSessionUp() / 1024);
d534 1
a534 1
				srtError.Format(RGB_LOG_ERROR + _T("Client '%s': requested file not found (hash: %s)"), GetUserName(), HashToString(currentblock->m_fileHash));
d708 1
a708 1
		AddDebugLogLine(false, _T("Client '%s' caused an error while creating package (%s), disconnecting client!"), GetUserName(), error.GetBuffer());
d1202 1
a1202 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Client '%s': requested file not found (hash: %s)"), GetUserName(), HashToString(reinterpret_cast<BYTE*>(fileHash)));
d1500 1
a1500 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' banned and kicked out of uploadqueue %s"), GetUserName(), reason);
@


1.203
log
@No need to save that in the class <thanks xrmb>; minor optimization.
@
text
@d644 1
a644 1
						_T("zip"), _T("rar"), _T("ace"), _T("ogm"), _T("arj"),
@


1.202
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@a225 2
//	eklmn: we can't cache a value here, cause otherwise our chages of priority will
//	be not applied until we restart eMule Plus
d228 4
d233 1
a233 3
		switch (req_file->GetPriority())
		{
			case PR_RELEASE:
d235 1
a235 1
				m_uFilePriority = 50;
d237 1
a237 1
				m_uFilePriority = 100;
d240 2
a241 2
			case PR_HIGH:
			m_uFilePriority = 20;
d244 2
a245 2
			case PR_LOW:
			m_uFilePriority = 5;
d248 2
a249 2
			case PR_VERYLOW:
			m_uFilePriority = 2;
d252 3
a254 3
			case PR_NORMAL:
			default:
			m_uFilePriority = 10;	// standard
a255 1
		}
d303 1
a303 1
	dblBaseValue *= static_cast<double>(m_uFilePriority) / 10.0;
@


1.201
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d295 2
a296 2
	if( (IsEmuleClient() && m_byteEmuleVersion <= 0x19) || this->GetClientSoft() == SO_CDONKEY || this->GetClientSoft() == SO_SHAREAZA )
{
d298 1
a298 1
}
@


1.200
log
@Fixed a mistake in a log
@
text
@d35 2
d139 1
a139 1

d164 1
a164 1

d174 1
a174 1

d198 1
a198 1
					AddDebugLogLine(false, RGB_LOG_DIMMED_TXT __FUNCTION__ _T(": Anti-leechermods: Client %s (%s) using the mod %s has been banned"), GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d200 1
a200 1
					AddDebugLogLine(false, RGB_LOG_DIMMED_TXT __FUNCTION__ _T(": Anti-leechermods: Client %s (%s) has been banned"), GetUserName(), GetClientNameAndVersionString(this));
d312 1
a312 1

d342 1
a342 1

d361 1
a361 1

a362 1
//
d405 1
a405 1
				AddDebugLogLine(false, _T("Client %s continues downloading (should be back on queue) because of a low transferred size"), GetUserName());
d412 1
a412 1

d440 1
a440 1

d458 1
a458 1

d482 1
a482 1
			AddDebugLogLine(false, _T("Client %s downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend."), GetUserName(), this->GetSessionUp() / 1024);
d491 1
a491 1
				AddDebugLogLine(false, _T("Client %s (%s) back on queue. Asked for a new chunk/file, after receiving %u KB."), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d496 1
a496 1
				AddDebugLogLine(false, _T("Client %s (%s) back on queue. Asked for a chunk forbidden by Jumpstart, after receiving %u KB."), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d501 1
a501 1
				AddDebugLogLine(false, _T("Client %s (%s) back on queue. Upload timeout, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d535 1
a535 1
				srtError.Format(RGB_LOG_ERROR + _T("%s: Requested file not found (hash: %s)"), __FUNCTION__, HashToString(currentblock->m_fileHash));
d709 1
a709 1
		AddDebugLogLine(false, _T("Client '%s' caused error while creating package (%s), disconnecting client!"), GetUserName(), error.GetBuffer());
d722 1
a722 1

d763 1
a763 1

d841 1
a841 2


d867 1
a867 1
		Packet		*packet = new Packet(OP_SENDINGPART, nPacketSize + 24, OP_EDONKEYPROT, bFromPF);	// -khaos: Create the packet with the new boolean.
d885 1
a885 1

d923 1
a923 1
		Packet* packet = new Packet(OP_COMPRESSEDPART, nPacketSize + 24, OP_EMULEPROT, bFromPF);	// -khaos: Create the packet with the new boolean.
d938 1
a938 2


a940 1
//
d972 1
a972 1

d1203 1
a1203 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Requested file not found (hash: %s)"), __FUNCTION__, HashToString(reinterpret_cast<BYTE*>(fileHash)));
d1302 8
a1309 8
//	The extended info exchange is currently disabled since it is possible
//	to ask the client with several userhashes for the file and then use
//	the one with the best UL/DL ratio
//	It is planned to reactivate this feature, but with a protection against
//	this userhash spoofing.
//	At the last stage this faeture should make it possible to choose the
//	sources more intelligently by taking UL/DL ratio, queuerank and
//	speed of the other client into account.
d1319 1
a1319 1
	uint16 nBaseModifier = (uint16) GetScore(false, false, true); //16-Bits are enough for base value
a1367 1

d1573 1
a1573 1

d1578 1
a1578 1

d1594 1
a1594 1

d1629 1
a1629 1

@


1.199
log
@Final DebugLog formating and changes
@
text
@d534 1
a534 1
				srtError.Format(RGB_LOG_ERROR + _T("%s: Requested file not found (hash: %s)"), __FUNCTION__, currentblock->m_fileHash);
d1205 1
a1205 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Requested file not found (hash: %s)"), __FUNCTION__, fileHash);
@


1.198
log
@Removed unused code.
@
text
@d531 2
d534 2
a535 1
				throw GetResString(IDS_ERR_REQ_FNF);
d708 1
a708 1
		AddDebugLogLine(false, IDS_ERR_CLIENTERRORED, GetUserName(), error.GetBuffer());
d1205 1
a1205 1
		AddDebugLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_REQ_FNF) + CString(" (SendHashsetPacket)"));
@


1.197
log
@minor changes, fixes and improvements
@
text
@a897 1
	m_bUsedCompressionUp = true;
@


1.196
log
@Some changes to track the Ban Messages crashes
@
text
@d706 1
@


1.195
log
@Compression wasn't used for files without extension;
Faster (in some cases) detection to use Tx compression or not;
Improved string processing.
@
text
@d1526 1
a1526 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.StartSession(this, false);
@


1.194
log
@minor optimization of the upload progress bar drawing;
corrected the CompleteSources part of ProcessUpFileStatus
@
text
@d196 1
a196 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Anti-leechermods: Client %s (%s) using the mod %s has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d198 1
a198 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Anti-leechermods: Client %s (%s) has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this));
a627 2
			CString ext = srcfile->GetFileName();

d630 1
a630 2
			int pos = ext.ReverseFind('.');
			if (pos > 0)
d632 3
a634 3
			 //	Take lowercase extension without point
				ext = ext.Mid(pos + 1);
				ext.MakeLower();
d636 23
a658 2
			//	Dont try to compress already compressed files
				bCompress = (ext != _T("zip") && ext != _T("rar") && ext != _T("ace") && ext != _T("ogm") && ext != _T("arj") && ext != _T("cab") && ext != _T("tgz") && ext != _T("gz") && ext != _T("bz2"));
d660 1
a660 1
			if (m_byteDataCompVer == 1 && (bCompress))
@


1.193
log
@better estimation of own score on remote client + no more friend/community guess + minor Infolist fix + removed unused functions
@
text
@d39 20
a58 4
	const COLORREF crAvailablePart = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);
	const COLORREF crNeither = (bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240);
	const COLORREF crSentData = RGB(222, 160, 0);
	const COLORREF crSendingPart = RGB(255, 208, 0);
d77 1
a77 3
	bool	bHalfFilled = (GetAvailUpPartCount() * 2) >= m_uUpPartCount;

	statusBar.Fill((bHalfFilled) ? crAvailablePart : crNeither);
d113 1
a113 1
			if (m_pbyteUpPartStatuses[i] == ((bHalfFilled) ? 0 : 1) && i != dwUploadingPart)
d119 1
a119 1
						statusBar.FillRange(dwStartPos, dwEndPos, bHalfFilled ? crNeither : crAvailablePart);
d130 1
a130 1
		statusBar.FillRange(dwStartPos, dwEndPos, bHalfFilled ? crNeither : crAvailablePart);
d806 6
a811 3
			uint16 nCount;
			data.Read(&nCount, 2);
			SetUpCompleteSourcesCount(nCount);
a813 1
	tempreqfile->CalculateCompleteSources();
@


1.192
log
@minor changes (function renamings, unused typedef removal)
@
text
@d1582 3
a1584 1
	if (IsFriend())
d1586 2
a1587 1
		dblBaseValue *= 2.0;
a1588 8

	if (g_eMuleApp.m_pGlobPrefs->CommunityEnabled() && IsCommunity())
	{
		dblBaseValue *= 2.0;
	}
	dblBaseValue *= GetRemoteBaseModifier();
	dblBaseValue *= GetSmallFilePushRatio() ;
	dblBaseValue *= GetRareFilePushRatio() ;
@


1.191
log
@Fixed loss of client uploading turn during part file flushing and single part hashing;
Reworked file completion algorithm to eliminate file locking in completing state.
@
text
@d1495 1
a1495 1
		if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
d1502 1
a1502 1
		if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
@


1.190
log
@reverted a silly change ... i should go to bed :(
@
text
@a502 1
	CPartFile*		pPartFile;
a503 3
	bool			bFromPF = true;
	CString			fullname;
	CSyncHelper		lockFile;
a523 38
		//	Check if it is a PartFile & cache result to save some CPU
			if (srcfile->IsPartFile())
			{
				pPartFile = reinterpret_cast<CPartFile*>(srcfile);
			}
			else
			{
				pPartFile = NULL;
			}

			if (pPartFile != NULL && pPartFile->GetStatus() != PS_COMPLETE)
			{
			//	Report the file about start of UL
				if (m_doneBlocksList.IsEmpty())
				{
					pUploadingPartFile = pPartFile;
					pUploadingPartFile->SetFileUpload(true);
				}
			//	Do not access a part file, if it is currently being moved into the incoming directory.
			//	Because the moving of part file into the incoming directory may take a noticable
			//	amount of time, we can not wait for 'm_FileCompleteMutex' and block the main thread.
			//	Just do a quick test of the mutex's state and return if it's locked.
				if (!pPartFile->m_FileCompleteMutex.Lock(0))
				{
					return false;
				}
				lockFile.m_pObject = &pPartFile->m_FileCompleteMutex;
			//	If it's a part file which we are uploading the file remains locked until we've read the
			//	current block. This way the file completion thread can not (try to) "move" the file into
			//	the incoming directory.
				fullname = pPartFile->GetFullName();
				fullname.Truncate(fullname.GetLength() - 4);
			}
			else
			{
				fullname.Format(_T("%s\\%s"), srcfile->GetPath(), srcfile->GetFileName());
			}

d587 1
a587 1
			if (pPartFile != NULL)
d591 1
a591 1
				if (!pPartFile->IsComplete(parts_start, parts_end))
d601 3
a603 1
			if (pPartFile == NULL)
d605 3
a607 14
				bFromPF = false;
				if (!file.Open(fullname, CFile::modeRead | CFile::osSequentialScan | CFile::shareDenyNone))
				{
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
					throw GetResString(IDS_ERR_OPEN);
				}
				file.Seek(currentblock->m_dwStartOffset, 0);

				if (uint32 done = file.Read(filedata, togo) != togo)
				{
					file.SeekToBegin();
					file.Read(filedata + done, togo - done);
				}
				file.Close();
a608 3
			else
			{
				pPartFile->GetPartFileHandle().Seek(currentblock->m_dwStartOffset, 0);
d610 1
a610 13
				if (uint32 done = pPartFile->GetPartFileHandle().Read(filedata, togo) != togo)
				{
					pPartFile->GetPartFileHandle().SeekToBegin();
					pPartFile->GetPartFileHandle().Read(filedata + done, togo - done);
				}

			//	Check for unlock only for PartFile
				if (lockFile.m_pObject)
				{
					lockFile.m_pObject->Unlock();
					lockFile.m_pObject = NULL;
				}
			}
d642 1
a642 1
			if (pPartFile == NULL)
d644 1
a644 4
				if (srcfile->GetJumpstartEnabled())
				{
					srcfile->AddSentBlock(this, currentblock->m_dwStartOffset, togo);
				}
@


1.189
log
@fix for my fix in 1.188 the previous fix create a bug in the waiting queue if remote client just miss one chunk
@
text
@d99 1
a99 1
			if (m_pbyteUpPartStatuses[i] == ((bHalfFilled) ? 0 : 1))
@


1.188
log
@fix for upload progressbar drawing when the remote client just miss one chunk
@
text
@d93 1
a93 1
	if (m_pbyteUpPartStatuses != NULL && GetAvailUpPartCount() > 0 && GetAvailUpPartCount() < dwLastPart)
@


1.187
log
@prevent filescanning by OP_HASHSETREQUEST
@
text
@d92 2
a93 4
	bool	bNoPartsAvailable = (GetAvailUpPartCount() == 0) || (m_pbyteUpPartStatuses == NULL);

//	Draw the parts with the less used color if there are some
	if (m_uUpPartCount != 1 && !bNoPartsAvailable)
d99 1
a99 1
			if (m_pbyteUpPartStatuses[i] == ((bHalfFilled) ? 0 : 1) && i != dwUploadingPart)
@


1.186
log
@minor fix to avoid some strange drawing (shouldn't happen)
@
text
@d1240 2
@


1.185
log
@upload progress bars fit their file's size; improved drawing of upload progress bar
@
text
@d84 4
a87 1
				statusBar.FillRange(pDoneBlock->m_dwStartOffset, pDoneBlock->m_dwEndOffset, crSentData);
@


1.184
log
@variable name correction.
@
text
@d35 1
a35 1
void CUpDownClient::DrawUpStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool bFlat)
d39 1
a39 1
	const COLORREF crBoth = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);
d44 18
a61 1
	uint32 filesize = (m_uUpPartCount) ? PARTSIZE * (m_uUpPartCount) : 1;
d63 1
a63 3
	CBarShader statusBar(rect->bottom - rect->top, rect->right - rect->left);
	statusBar.SetFileSize(filesize);
	statusBar.Fill(crNeither);
d65 4
a68 1
	uint32 dwCurrentUploadingPart = GetCurrentlyUploadingPart();
d70 2
a71 1
	if (filesize != 1 && !onlygreyrect && m_pbyteUpPartStatuses)
d73 5
a77 1
		for (uint32 i = 0;i != m_uUpPartCount;i++)
d79 3
a81 1
			if (i == dwCurrentUploadingPart)
d83 2
a84 7
			// They send this part
				statusBar.FillRange(PARTSIZE * i, PARTSIZE * (i + 1), crSendingPart);
			}
			else if (m_pbyteUpPartStatuses[i])
			{
			//	They have this part
				statusBar.FillRange(PARTSIZE * i, PARTSIZE * (i + 1), crBoth);
d87 1
d89 1
a89 1
	}
d91 2
a92 1
	if (!m_doneBlocksList.IsEmpty())
d94 3
a96 4
		Requested_Block_Struct	   *pDoneBlock;
		uint32						dwPartNum;

		for (POSITION pos = m_doneBlocksList.GetHeadPosition(); pos != NULL; )
d98 1
a98 3
			pDoneBlock = m_doneBlocksList.GetNext(pos);
			dwPartNum = pDoneBlock->m_dwStartOffset / PARTSIZE;
			if (dwPartNum == dwCurrentUploadingPart)
d100 9
a108 1
				statusBar.FillRange(pDoneBlock->m_dwStartOffset, pDoneBlock->m_dwEndOffset, crSentData);
d111 5
d352 1
a352 6
	Requested_Block_Struct * last_done_block;
	Requested_Block_Struct* next_requested_block;
	uint32 last_done_part = 0xffffffff;
	uint32 next_requested_part = 0xffffffff;

	bool different_part = false;
d360 2
a361 2
			last_done_block = (Requested_Block_Struct*)m_doneBlocksList.GetHead();
			next_requested_block = (Requested_Block_Struct*)m_blockRequestsQueue.GetHead();
d364 2
a365 2
			last_done_part = last_done_block->m_dwStartOffset / PARTSIZE;
			next_requested_part = next_requested_block->m_dwStartOffset / PARTSIZE;
d518 1
a518 1
			if (!srcfile)
d537 1
a537 1
			if (pPartFile && pPartFile->GetStatus() != PS_COMPLETE)
d642 1
a642 1
			if (!pPartFile)
@


1.183
log
@better different shades of yellow feature for upload transfers; removed uneeded GetCurrentlyUploadingPos() function; list processing impovements
@
text
@d41 1
a41 1
	const COLORREF crSendedData = RGB(222, 160, 0);
d81 1
a81 1
				statusBar.FillRange(pDoneBlock->m_dwStartOffset, pDoneBlock->m_dwEndOffset, crSendedData);
@


1.182
log
@xrmb fix for unused pixel in Upload/On Queue progress bar; xrmb different shades of yellow in progress bar for current transfer position and remaining
@
text
@d41 2
a42 2
	const COLORREF crBeingSent = RGB(222, 160, 0);
	const COLORREF crToGo = RGB(255, 208, 0);
d50 2
d56 4
a59 6
			uint32 uEnd = PARTSIZE * (i + 1);

			if (m_pbyteUpPartStatuses[i])
			{ 
			//	They have this part
				statusBar.FillRange(PARTSIZE * i, uEnd, crBoth); // will do for now
d61 1
a61 1
			else 
d63 2
a64 2
			//	They don't have a part
				statusBar.FillRange(PARTSIZE * i, uEnd, crNeither);
d66 1
a66 1
			uint32 curpos = GetCurrentlyUploadingPos();
d68 12
a79 1
			if (curpos != 0xFFFFFFFF && i == curpos / PARTSIZE)
d81 1
a81 2
				statusBar.FillRange(PARTSIZE * i, curpos, crBeingSent);
				statusBar.FillRange(curpos, uEnd, crToGo);
d85 1
d663 1
a663 1
			//	Dont try to compress already compressed files 
d999 1
a999 1
	for (POSITION pos = m_doneBlocksList.GetHeadPosition(); pos != NULL; m_doneBlocksList.GetNext(pos))
d1001 1
a1001 1
		Requested_Block_Struct* pFinishedBlock = m_doneBlocksList.GetAt(pos);
d1003 1
a1003 1
		if (pFinishedBlock && pNewReqBlock->m_dwStartOffset == pFinishedBlock->m_dwStartOffset 
d1010 1
a1010 1
	for (POSITION pos = m_blockRequestsQueue.GetHeadPosition(); pos != NULL; m_blockRequestsQueue.GetNext(pos))
d1012 1
a1012 1
		Requested_Block_Struct* pReqBlock = m_blockRequestsQueue.GetAt(pos);
d1014 1
a1014 1
		if (pReqBlock && pNewReqBlock->m_dwStartOffset == pReqBlock->m_dwStartOffset 
d1033 1
a1033 1
	if (dwTime)
d1049 1
a1049 1
	if (dwTime)
d1074 1
a1074 1
		AddDebugLogLine( false, _T("Client %s(%s) appears to be stuck, putting back on queue"), 
d1178 1
a1178 1
//	FlushSendBlocks() sends the rest of the last block queued for upload to this client if it has been split 
d1241 1
a1241 1
//	Calculates the session speed of the client. Providing the other Clients with this info 
d1263 1
a1263 1
// FlushSendBlocks() was removed, since the client on the other side ignores all packets, 
d1424 1
a1424 1
	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL; m_requestedFilesList.GetNext(pos))
d1426 1
a1426 1
		Requested_File_Struct * cur_struct = m_requestedFilesList.GetAt(pos);
d1428 1
a1428 1
		if (!md4cmp(cur_struct->m_fileHash, fileid))
d1430 1
a1430 1
			if (::GetTickCount() - cur_struct->m_dwLastAskedTime < MIN_REQUESTTIME)
d1434 1
a1434 1
					cur_struct->m_byteNumBadRequests++;
d1436 1
a1436 1
				if (cur_struct->m_byteNumBadRequests == BADCLIENTBAN)
d1444 1
a1444 1
				if (cur_struct->m_byteNumBadRequests)
d1446 1
a1446 1
					cur_struct->m_byteNumBadRequests--;
d1449 1
a1449 1
			cur_struct->m_dwLastAskedTime = ::GetTickCount();
d1454 5
a1458 5
	Requested_File_Struct* new_struct = new Requested_File_Struct;
	memzero(new_struct, sizeof(Requested_File_Struct));
	md4cpy(new_struct->m_fileHash, fileid);
	new_struct->m_dwLastAskedTime = ::GetTickCount();
	m_requestedFilesList.AddHead(new_struct);
d1480 1
a1480 1
	for (POSITION pos = m_requestedFilesList.GetHeadPosition(); pos != NULL; m_requestedFilesList.GetNext(pos))
d1482 3
a1484 3
		Requested_File_Struct * cur_struct = m_requestedFilesList.GetAt(pos);
		cur_struct->m_byteNumBadRequests = 0;
		cur_struct->m_dwLastAskedTime = 0;
d1496 1
a1496 1
	{ 
a1688 12
uint32 CUpDownClient::GetCurrentlyUploadingPos()
{
	EMULE_TRY

	if (!m_doneBlocksList.IsEmpty())
		return m_doneBlocksList.GetHead()->m_dwStartOffset;

	EMULE_CATCH

	return 0xFFFFFFFF;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.181
log
@Better number :P
@
text
@d41 2
a42 1
	const COLORREF crBeingSent = RGB(255, 208, 0);
d66 1
a66 1
			uint32 partno = GetCurrentlyUploadingPart();
d68 5
a72 2
			if (i == partno)
				statusBar.FillRange(PARTSIZE * i, uEnd, crBeingSent);
d1678 12
@


1.180
log
@Minor formating changes, some more upload log and fix for clipboard monitoring
@
text
@d420 1
a420 1
		if ( IsFriend() && GetSessionUp() < (PARTSIZE*1.1)
@


1.179
log
@replaced  pos != 0 to pos != NULL
@
text
@a34 4

//	members of CUpDownClient
//	which are mainly used for uploading functions

d39 1
a39 1
	const COLORREF crBoth = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);	//Cax2 - same green used for files & clients
d43 1
a43 1
	uint32 filesize = (m_uUpPartCount) ? PARTSIZE * (m_uUpPartCount) : 1; // might be a little off.. better than nothing
d45 1
a45 1
	CBarShader statusBar(rect->bottom - rect->top, rect->right - rect->left); //Maella - Not a static object anymore
d49 1
a49 1
	if (filesize != 1 && !onlygreyrect && m_pbyteUpPartStatuses)	//Cax2 - no more black rectangle
a52 6
			/* no need for that now, cause we don't use the precise filesize
			if (PARTSIZE*(i+1) > filesize)
			uEnd = filesize;
			else
			uEnd = PARTSIZE*(i+1);
			*/
d56 2
a57 1
			{ //they have this part
d60 3
a62 1
			else //they don't have a part.
d64 1
d66 2
a67 1
			if (i == partno) // won't be equal if it is 0xFFFF
a81 2
	//	[i_a] DonGato (Community Sharing)
	//eklmn: to prevent a leeching the community string must have a same format
d97 1
d104 1
d107 1
d113 2
a114 1
	static DWORD	dwLastMsgTime = 0;	//spam control
d117 1
a117 1
//	TODO: complete this (friends, uploadspeed, emuleuser etc etc)
d120 1
a120 2
//SyruS moved this up (from end) to skip the whole useless calculation
//Start milobac: Anti-leechermods
d122 1
d124 1
d126 3
a128 4
		if (IsStolenName(m_strUserName) 
			|| IsLeecherType(m_strModVersion)
			|| (GetModVersion() == _T(PLUS_VERSION_STR) && GetMuleVersion() != CURRENT_VERSION_SHORT )
			/*&& g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM()*/)
d130 2
a131 1
			if (::GetTickCount() > dwLastMsgTime + (60 * 1000))	//spam control
d137 1
a137 1
			//katsyonak: Send leecher ban message 15.06.03
d144 1
a144 1
//End milobac: Anti-leechermods
d158 1
d162 4
a165 3
//eklmn: we cann't cache a value here, cause otherwise our chages of priority will
//	be not applied until we restart eMule.
	ASSERT(m_reqFileHash != NULL); // i_a: m_reqFileHash is an array so the if() was superfluous
d195 1
a195 1
//	calculate score, based on waiting time and other factors
d198 1
d200 1
d202 1
d204 1
d207 1
a207 1
	//	we don't want one client to download forever
d215 2
a216 2
//	if (GetDownloadState() == DS_DOWNLOADING && GetDataRate() > 500) // obaldin: prevent 0.1 upload abuse
//		dblBaseValue *= 1.5; // // thats what the credit system is for !
d219 2
a220 1
//	DonGato (Community Sharing)
d224 2
a225 1
	if (m_pCredits != (CClientCredits*)NULL)
d231 2
a232 1
	if( (IsEmuleClient() || this->GetClientSoft() == SO_CDONKEY || this->GetClientSoft() == SO_SHAREAZA /* || this->GetClientSoft() == SO_XMULE */ ) && m_byteEmuleVersion <= 0x19 )
d234 1
d236 1
a236 1
//	Small and Rare file push
d245 1
d249 30
d284 1
d288 1
a288 1
//	keep the FileRatio
d290 2
a291 1
	return(ratio < 1.0 ? 1.0 : ((ratio > 100.0) ? 100.0 : ratio)); //Cax2 bugfix
d294 1
d303 1
a303 1
bool CUpDownClient::IsDifferentPartBlock(bool silent) // [Tarod 12/22/2002] Cax2 - added silent option
d326 1
a326 2
			/*
			if ( last_done_part != next_requested_part)
a328 1
				//AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk, sent %u KB", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
a329 8
			if (md4cmp (last_done_block->m_fileHash, next_requested_block->m_fileHash) != 0)
			{
				different_part = true;
			             //AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u KB", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
			}
			*/
			if (last_done_part != next_requested_part || md4cmp(last_done_block->m_fileHash, next_requested_block->m_fileHash) != 0)
				different_part = true;
d339 2
a340 6
	//AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u KB", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferredUp() / 1024);

	//	obaldin: this is for old clients, that rotate the chunk,
	//	so that they'll be able to download at least _something_
	//	But probably even after the majority switches we'd
	//	better check for 0 here
d344 1
d346 1
d348 1
d371 1
a382 25
double CUpDownClient::GetSmallFilePushRatio()
{
	EMULE_TRY

	CKnownFile * srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_reqFileHash);
	if (srcfile == NULL)
		return 1.0;

	long lFileSize = srcfile->GetFileSize() ;

	if (lFileSize > 0.0 && lFileSize < 9961472)
	{

	//	Modded by Tarod to: Min(100, Max(1, 9.5 / FS)) [9.5 Mbs. == Chunk Size]
		double		mul = 9961472.0 / lFileSize ;		// VQB formula + Cax2 overflow bugfix...

		if (mul > 100.0)
			mul = 100.0 ;		// VQB formula
		return mul ;
	}

	EMULE_CATCH
	return 1.0;
}

d401 7
d410 1
a410 12
//	check if we should kick this client (time critical !!!)
//	Never kick friends
//	Always kick if transfer is longer than 80 minutes
//	Never allow more than the size of a chunk (+500 KBytes for small resends of invalid data) to be transferred
//	VQB to provide full chunk transfers (modified by Tarod)
//	Note: Full chunk transfers really should be enforced, not an option
	EMULE_TRY
//	LANCAST (moosetea) We never kick a lancast user
	bool AllowedMore = IsOnLAN();
//	v- eklmn: bugfix(04): conflict between upload logic & LANcast
	bool diff_part = IsDifferentPartBlock(true);	//Cax2 - don't write anyting to the log yet!
	bool JS_blocked = IsForbiddenByJumpstart();
d412 4
a415 1
	bool shouldGo = ((GetUpStartTimeDelay() >= 80 * 60 * 1000) || diff_part);
d417 2
a418 2
//	if user is from Internet && full chunk (or timeout)
	if (!AllowedMore && shouldGo)
d420 2
a421 1
		if (IsFriend() && !g_eMuleApp.m_pUploadQueue->CheckForTimeOver(this) && !JS_blocked)
d423 1
a423 1
			AllowedMore = true;
d429 2
a430 1
			if (diff_part)
d435 1
a435 1
			else if (JS_blocked)
d445 1
d447 1
a450 1
//	^- eklmn: bugfix(04): conflict between upload logic & LANcast
d454 2
a455 4
	//	There are no new blocks requested, put we will happily transfer more
	//	if the client just requests something
	//	AddDebugLogLine(false, "No more data to send to client %s(%s), should be back on queue", GetUserName(), GetClientNameAndVersionString(this));
		return false; //eklmn: bugfix(03): keeping user in queue if he doesn't need anything
d468 4
a471 4
	//	repeat as long as next requested block is in the same chunk as previous blocks
	//	and as long as there is a next requested block
	//added: if a friend or lancast user, keep going![Cax2]
		while (!m_blockRequestsQueue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()) && !IsForbiddenByJumpstart())
d475 1
d478 1
a478 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);	// eklmn: ???
d482 1
a482 1
			//eklmn: update a file hash to really requested file
d485 1
a485 1
			//eklmn: check a if it is a PartFile & cache result to save some CPU cycle on reinterpretation
d487 1
d489 1
d491 1
d493 1
d497 1
a497 1
				//eklmn: report the file about start of UL
d503 1
a503 1
			//	SyruS (0.29c) Do not access a part file, if it is currently moved into the incoming directory.
d506 3
a508 1
				if (!pPartFile->m_FileCompleteMutex.Lock(0)) // just do a quick test of the mutex's state and return if it's locked.
d510 1
d527 1
a527 1
				CString s;
d531 7
a537 5
					AddLogLine(false, IDS_PARTPRIO_DENIED, currentblock->m_dwStartOffset / PARTSIZE, srcfile->GetFileName());
					s.Format(GetResString(IDS_PARTPRIO_DENIED), currentblock->m_dwStartOffset / PARTSIZE, srcfile->GetFileName());
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_BLOCKED_CHUNK);
					throw s;
					break;
d539 2
a540 1
					AddLogLine(false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(), currentblock->m_dwStartOffset / PARTSIZE);
d545 3
a547 2
			if (AllowedMore)
			{	// Friends & LAN  are not limited by chunks boundaries.
d571 2
a572 2
				//	The m_dwEndOffset goes into the next chunk. Set it to the end of the chunk
				//	that m_dwStartOffset is in.
d582 1
a582 2
			//	This can't be a wrapped around request, since it has been limited to
			//	a single chunk.
d587 1
a587 1
			{ // proper check
d597 1
a597 1
			//eklmn: create a buffer for a file data before we start to work with a file
d627 1
a627 1
				//eklmn: check for unlock only for PartFile
d630 2
a631 2
					lockFile.m_pObject->Unlock();	//SyruS (0.29c) Unlock the (part) file as soon as we are done with accessing it.
					lockFile.m_pObject = NULL;		//SyruS (0.30b)
d678 2
a679 1
	catch (CMemoryException * error)	//check for exception that will be thow by "new"
d704 1
a704 1
//	AddDebugLogLine(false, "Debug: Packet done. Size: %i",blockpack->GetLength());
d708 1
d716 1
d718 1
d720 1
d722 1
d724 1
d726 1
d728 1
d730 1
a730 1

d736 1
d740 1
d744 1
d746 1
d748 1
a773 1

d778 1
d791 1
d794 1
d799 1
d803 1
d805 1
d807 1
a807 3
			//	We may want to use this for another feature..
			//	if (m_pbyteUpPartStatuses[done] && !tempreqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
			//	bPartsNeeded = true;
d810 1
d812 1
d838 1
d840 1
d842 1
d844 1
d849 1
d851 2
d870 1
d877 1
d881 1
d888 1
d895 1
d897 1
d899 1
d901 1
d903 2
d908 1
d910 1
d924 1
d928 4
a931 4
/**
 * A packet should never be larger than MAXFRAGSIZE. This method splits up the
 * given packets into several packets with the size MAXFRAGSIZE, if necessary.
 */
a936 1
	//	splitting packets
d938 1
d969 1
d971 1
d973 1
d975 1
d983 1
d994 1
d1017 1
d1019 1
d1021 1
d1023 1
d1025 2
d1033 1
d1035 1
d1037 1
d1039 1
d1041 2
d1049 1
d1051 1
a1051 1
//	this will be set to true if/when the slot is actually fed some data
d1055 1
a1055 1
//	check for 'stuck' clients
d1058 3
a1060 2
	//	were unable to transfer for 2 minutes, put the client back on queue
		AddDebugLogLine(false, _T("Client %s(%s) appears to be stuck, putting back on queue"), GetUserName(), GetClientNameAndVersionString(this));
d1068 2
a1069 2
//	Only feed this slot new data if it has been able to empty its
//	buffer since we last offered it data
a1071 1
	//	v- eklmn: bugfix(03): keeping user in queue if he doesn't need anything (v2)
d1074 1
a1074 1
		//	no valid blocks to transfer. Put the client back on queue
d1076 1
d1078 1
a1079 1
	//	^- eklmn: bugfix(03): keeping user in queue if he doesn't need anything (v2)
d1081 4
a1084 4
	//	Feed data to this slot, one block at a time, as long as there's
	//	enough bandwidth left for the entire next block.
	//	There must also be blocks to send (not empty request queue)
		while (!m_blockSendQueue.IsEmpty() && m_blockSendQueue.GetHead()->GetRealPacketSize() + amounttransferred <= nMaxAmmount)
d1090 3
a1092 3
		//	Extended statistics information based on which client software and which port we sent this data to...
		//	This also updates the grand total for sent bytes, etc.  And where this data came from.  Yeesh.
		//	eklmn: we have to call function before packet will sended, otherwise packet will be deleted & we have Access violation
a1093 1
		//g_eMuleApp.UpdateSentBytes(nBlockSize);
d1095 1
a1095 2
			pPacket = NULL;	//eklmn: bugfix(17): upload fix(reset pPacket in SendBlockData)
		//m_pRequestSocket->ResetTimeOutTimer();
a1099 1
		//	g_eMuleApp.m_pUploadQueue->AddUpDataRateMSOverhead(24, 160);
d1104 1
d1106 1
d1109 1
a1109 3
	//	If this slot wasn't given enough data to empty it's request queue,
	//	it wants more data.

d1129 1
a1129 2
//	Don't store more than 40 seconds of statistics
//while(curTick-m_averageULTickList.back() > 40000) {
d1136 1
a1136 1
//eklmn: since performance is more importatnt, that graphical output this function moved to the end
d1141 2
a1142 3
	//	Present this slot's speed as 0 unless there's a good chunk
	//	of stored statistics for it. If there's to little data, the
	//	UL speed will be far off, so we might as well hide it in those cases.
d1145 1
d1147 1
d1149 1
d1151 1
a1151 1

d1153 1
a1153 1
		m_dwLastRefreshedULDisplayTime = curTick + (uint32)(rand() / (RAND_MAX / 1000));	//SyruS moved rand out of if(...)
d1159 1
d1163 2
a1164 2
//	FlushSendBlocks() sends the rest of the last block queued for upload to this client if it has been split across
//		multiple packets. Call this when you stop upload, or the request socket might be not able to send.
d1169 1
a1169 1
	bool		bBreak = false;
d1172 2
a1173 2
	while ( !m_blockSendQueue.IsEmpty() && m_blockSendQueue.GetHead()->IsSplit()
		 && m_pRequestSocket != NULL && m_pRequestSocket->IsConnected() && !bBreak )
d1175 2
a1176 3
		Packet		*pPacket = m_blockSendQueue.RemoveHead();

		bool		bBreak = pPacket->IsLastSplit();
d1182 1
d1205 1
d1207 1
d1209 1
d1226 2
a1227 4
//	Calculates the session speed of the client
//	Providing the other Clients with this info
//	gives then the possibility to select the
//	sources more intelligently
d1229 1
d1231 1
d1234 1
d1236 1
d1238 1
d1241 1
d1243 1
d1246 1
d1248 2
a1249 2
// eklmn: the FlushSendBlocks() was removed, since client on other side ignores all packets, that will be coming after a send of OP_CANCEL...
// what actually means traffic waste
d1278 1
d1280 1
d1284 1
d1286 1
d1288 1
a1288 1
//	By Maverick
a1301 1

d1303 1
d1305 1
d1312 1
d1314 1
d1316 1
d1318 1
d1320 1
d1322 1
a1323 1
	double dblBaseValue = 1.0;
d1328 1
a1333 2
//	Providing the other clients with this info
//	can not be used to leech
d1335 1
d1348 1
a1348 1
//	END Maverick
d1357 1
d1362 1
d1364 1
d1366 1
d1372 1
d1374 1
d1383 1
d1385 1
d1387 1
d1389 1
d1391 1
d1408 1
d1412 1
d1418 1
d1420 6
a1425 2
				if (cur_struct->m_byteNumBadRequests == BADCLIENTBAN) //katsyonak 16.06.03
					Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is behaving aggressively!"), GetResString(IDS_BAN_AGGRESSIVECLI));
d1430 1
d1432 1
d1435 1
d1444 1
d1451 1
d1454 1
d1458 1
a1458 1
//--- xrmb:hashthieves1 ---
d1460 2
a1461 1
	g_eMuleApp.m_pClientList->m_mapOffenseCounter.erase(qwIPPortID);	//g_mapOffenseCounter.RemoveKey(qwIPPortID);
d1464 1
a1464 1
//--- :xrmb ---
d1472 1
d1477 1
a1477 1
{ //katsyonak 16.06.03
d1481 2
a1482 1
	{ // DbT: if the ban function is disable, no need to ban a client (default is enable!)
d1487 1
d1489 2
a1490 1
	{	//SyruS kick already downloading client back to waitingqueue
d1495 1
d1498 1
a1498 2
	//	SyruS: No need to ban a client (and send a message) again except for extending the bantime
	//	AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
d1502 1
d1504 1
d1506 1
d1508 1
d1511 1
d1513 1
d1518 1
a1518 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.EndSession(this);		// now it automatically closes the session afterwards
d1520 1
d1522 1
d1525 1
d1527 1
d1529 2
d1563 1
a1563 2
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Lord KiRon
d1568 1
a1568 2
//	Lord KiRon - end
//	By Maverick
d1572 1
d1574 1
d1576 2
d1579 2
a1580 1
	return 0;	// We do not know for how long we are on the queue
d1582 1
d1590 1
d1601 1
d1603 1
d1607 1
d1609 2
d1612 1
d1614 1
d1628 1
d1630 1
d1632 4
a1635 4
//	This calculation is not very accurate for some reasons:
//	- Crashes can cause that either client can not write
//	its client data. This can cause differences of the
//	client data at the two clients.
d1637 1
d1639 1
d1641 1
d1643 2
d1646 1
d1665 1
d1667 1
@


1.178
log
@sh**. my typo bug
@
text
@d922 1
a922 1
	for (POSITION pos = m_doneBlocksList.GetHeadPosition();pos != 0; m_doneBlocksList.GetNext(pos))
d932 1
a932 1
	for (POSITION pos = m_blockRequestsQueue.GetHeadPosition(); pos != 0; m_blockRequestsQueue.GetNext(pos))
d1262 1
a1262 1

d1298 1
a1298 1

d1302 1
a1302 1
	for (POSITION pos = m_requestedFilesList.GetHeadPosition();pos != 0;m_requestedFilesList.GetNext(pos))
d1330 1
a1330 1

d1345 1
a1345 1
	for (POSITION pos = m_requestedFilesList.GetHeadPosition();pos != 0;m_requestedFilesList.GetNext(pos))
d1354 1
a1354 1

@


1.177
log
@fix for "better detection of leecher clients" :)
@
text
@d130 1
a130 1
			|| (GetModVersion() == _T(PLUS_VERSION_STR) && GetMuleVersion() != CURRENT_VERSION_SHORT) )
@


1.176
log
@corretions in "hash thieves", added Leecher type statistic
@
text
@d128 4
a131 1
		if (IsStolenName(m_strUserName) || IsLeecherType(m_strModVersion) /*&& g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM()*/)
@


1.175
log
@some refactoring : IsStolenName & IsLeecherType were moved into otherfunctions.cpp
@
text
@d1338 2
a1339 2
	g_mapOffenseCounter.erase(qwIPPortID);	//g_mapOffenseCounter.RemoveKey(qwIPPortID);
	g_mapHashBase.erase(qwIPPortID);			//g_mapHashBase.RemoveKey(qwIPPortID);
@


1.174
log
@possible memleak & loss of block request by OP_REQUESTPARTS (post fix, :( well i forgot about some thing)
@
text
@d128 1
a128 1
		if (IsStolenName() || IsLeecherType() /*&& g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM()*/)
@


1.173
log
@possible memleak & loss of block request by OP_REQUESTPARTS
@
text
@d916 1
a916 1
void CUpDownClient::AddReqBlock(Requested_Block_Struct* reqblock)
d919 1
a919 1
	for (POSITION pos = m_doneBlocksList.GetHeadPosition();pos != 0;m_doneBlocksList.GetNext(pos))
d921 4
a924 2
		if (reqblock->m_dwStartOffset == m_doneBlocksList.GetAt(pos)->m_dwStartOffset 
			&& reqblock->m_dwEndOffset == m_doneBlocksList.GetAt(pos)->m_dwEndOffset)
d929 1
a929 1
	for (POSITION pos = m_blockRequestsQueue.GetHeadPosition();pos != 0;m_blockRequestsQueue.GetNext(pos))
d931 4
a934 2
		if (reqblock->m_dwStartOffset == m_blockRequestsQueue.GetAt(pos)->m_dwStartOffset 
			&& reqblock->m_dwEndOffset == m_blockRequestsQueue.GetAt(pos)->m_dwEndOffset)
d939 5
a943 1
	m_blockRequestsQueue.AddTail(reqblock);
@


1.172
log
@Processing files with size = 0 modulo PARTSIZE (as a result impossible to receive hashset, impossible to complete such file, incorrect average speed report, etc.)
@
text
@d915 1
a915 1

d921 2
a922 1
		if (reqblock->m_dwStartOffset == m_doneBlocksList.GetAt(pos)->m_dwStartOffset && reqblock->m_dwEndOffset == m_doneBlocksList.GetAt(pos)->m_dwEndOffset)
a923 1
			delete reqblock;
d929 2
a930 1
		if (reqblock->m_dwStartOffset == m_blockRequestsQueue.GetAt(pos)->m_dwStartOffset && reqblock->m_dwEndOffset == m_blockRequestsQueue.GetAt(pos)->m_dwEndOffset)
a931 1
			delete reqblock;
d939 1
a939 1

d949 1
a949 1

d959 1
a959 1

@


1.171
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d739 6
a744 2
	data.Read(&m_uUpPartCount, 2);
	if (!m_uUpPartCount)
a745 1
		m_uUpPartCount = tempreqfile->GetPartCount();
d751 1
a751 1
		if (tempreqfile->GetPartCount() != m_uUpPartCount)
@


1.170
log
@speed optimization & output in stats of the feature "countermeasures against unfair client"
@
text
@d508 1
a508 1
				uint8 part_status = srcfile->GetPartStatus(currentblock->m_dwStartOffset / PARTSIZE);
d708 1
a708 1
	m_pbyteUpPartStatuses = new uint8[m_uUpPartCount];
d743 1
a743 1
		m_pbyteUpPartStatuses = new uint8[m_uUpPartCount];
d753 1
a753 1
		m_pbyteUpPartStatuses = new uint8[m_uUpPartCount];
d757 1
a757 1
			uint8 toread;
d1207 1
a1207 1
	uint8 nCommunity = -1;
@


1.169
log
@Compression desicion: check for "tgz" instead of "tar", because tar isn't compressed.
@
text
@d1326 3
a1328 2
	g_mapOffenseCounter.RemoveKey(GetUID());
	g_mapHashBase.RemoveKey(GetUID());
@


1.168
log
@removed MOBILE_MULE and JUMPSTART defines + minor improvements (thx aw3)
@
text
@d628 1
a628 1
				bCompress = (ext != _T("zip") && ext != _T("rar") && ext != _T("ace") && ext != _T("ogm") && ext != _T("arj") && ext != _T("cab") && ext != _T("tar") && ext != _T("gz") && ext != _T("bz2"));
@


1.167
log
@Optimized hash processings
@
text
@a320 1
#if JUMPSTART
a346 2
#endif // JUMPSTART

a403 2
#if JUMPSTART

a404 1
#endif
a410 1
#if JUMPSTART
a411 5
#else

		if (IsFriend() && !g_eMuleApp.m_pUploadQueue->CheckForTimeOver(this))
#endif

a423 1
#if JUMPSTART
a428 1
#endif
a460 1
#if JUMPSTART
a461 5
#else

		while (!m_blockRequestsQueue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()))		//Cax2 - if a friend or lancast user, keep going!
#endif

a504 2
		//v- eklmn: bugfix(18): conflict between JUMSTART & PartTraffic)
#if JUMPSTART
a505 3
#else
			if (true)
#endif
a521 1
		//^- eklmn: bugfix(18): conflict between JUMSTART & PartTraffic)
d618 1
a618 1
			ext.MakeLower();
d621 5
a625 2
			if (pos > -1)
				ext = ext.Mid(pos);
d627 4
a630 3
		//	Dont try to compress already compressed files	
			bool bDoCompress = (ext != _T(".zip") && ext != _T(".rar") && ext != _T(".ace") && ext != _T(".ogm") && ext != _T(".arj") && ext != _T(".cab") && ext != _T(".tar") && ext != _T(".gz") && ext != _T(".lzh") && ext != _T(".bz2"));
			if (m_byteDataCompVer == 1 && (bDoCompress))
a643 1
#if JUMPSTART
a650 1
#endif // JUMPSTART
@


1.166
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d925 1
a925 1
void CUpDownClient::SetUploadFileID(uchar* tempreqfileid)
d928 1
d932 2
a933 2
		for (int i = 0; i < 16; i++)
			m_reqFileHash[i] = 0;
@


1.165
log
@BUGFIX: decision whether to compress packets was case sensitive + added some more file extension + some other changes
@
text
@d768 1
a768 1
		memset2(m_pbyteUpPartStatuses, 0, m_uUpPartCount);
d1251 1
a1251 1
	memset2(packet->m_pcBuffer, 0, 12);
d1333 1
a1333 1
	memset2(new_struct, 0, sizeof(Requested_File_Struct));
@


1.164
log
@formating
@
text
@d208 2
a209 2
	if (GetDownloadState() == DS_DOWNLOADING && GetDataRate() > 500) // obaldin: prevent 0.1 upload abuse
		dblBaseValue *= 1.5; // since up/down credits are in, this isn't that important anymore
a215 2
//Fix by Amdribant [loadedsrc]
//ASSERT(m_pCredits != NULL);
d221 5
a225 1
//	Added by Tarod (herbert code)
a236 1
//	Added by Tarod based in herbert code and modifications by MatzeHH
d240 1
a240 2
//if(!g_eMuleApp.m_pGlobPrefs->FairShareRarePush())
//	return 1.0;
d354 1
a354 2
//if(!g_eMuleApp.m_pGlobPrefs->FairShareRarePush())
//	return 1.0f;
a358 1
//Cax2 faster code ....
a360 1
//if (filesizeinmb > 0.0f && filesizeinmb < 9.5f) {
a374 1
//	End added by Tarod
a375 1
//SyruS (0.29c)
d532 1
a532 2
			//--- xrmb:partprio ---
			//--- accessing a blocked part??? ---
a545 1
			//--- :xrmb ---
d607 1
a607 1
				bFromPF = false;	// <-khaos--+++> This is not a part file...
d641 13
a653 3
			CString ext = srcfile->GetFileName().Right(4);
		//	-khaos--+++> We're going to add bFromPF as a parameter to the calls to create packets...
			if (m_byteDataCompVer == 1 && ext != _T(".zip") && ext != _T(".rar") && ext != _T(".ace"))
d655 1
d657 1
d659 1
a659 1
		//	<-----khaos-
d661 1
a661 1
		//	file statistic
a663 1
		//--- xrmb:parttraffic ---
a664 1
		//--- :xrmb ---
d720 1
a720 1
	if (memcmp(m_reqFileHash, m_pReqPartFile->GetFileHash(), 16))
d749 1
a749 1
		m_pbyteUpPartStatuses = NULL;	// added by jicxicmic
d753 1
a753 1
	m_uUpCompleteSourcesCount = 0;	// netwolf: complete sources (zegzav )
d756 1
a756 1
		CheckForUpPartsInfo(); // obaldin
a796 1
	//	netwolf: complete sources (zegzav ) - BEGIN
a802 1
	//	netwolf: complete sources (zegzav ) - END
d804 1
a804 1
	tempreqfile->CalculateCompleteSources(); // netwolf complete sources (zegzav) // tempreqfile->NewAvailPartsInfo()
d856 1
a856 1
		CreateStandardPackets(pbyteFileData, togo, currentblock, bFromPF);		// -khaos: Create the packet with the new boolean.
d860 2
a861 2
	m_dwCompressionGain += (togo - newsize); // Add show compression
	m_dwUncompressed += togo; // Add show compression
a988 1
//	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
a1021 1
		//	-khaos--+++>
d1463 1
a1463 7
	/* // Myself Bot user?
	bool bIsBotuser;	//we still assume that the other client 'punishes' us if our name is 'wrong' 	//Cax2 - not anymore
	CString pszUsername = g_eMuleApp.m_pGlobPrefs->GetUserNick();
	if (pszUsername)
		bIsBotuser = (strstr(pszUsername, "edk-files") || strstr(pszUsername, "finder")) && strstr(pszUsername, "com");
	else bIsBotuser = false;
	*/
a1464 2
	double dblBaseValue = 100.0;
//if (bIsBotuser) dblBaseValue *= 0.9f;	//Cax2 - not anymore
a1470 2
	if (GetDownloadState() == DS_DOWNLOADING)
		dblBaseValue *= 1.5;
@


1.163
log
@upload auto priority sets very well spread files to low prio + minor changes + cleanup
@
text
@d1025 1
a1025 1
		//	eklmnf: we have to call function before packet will sended, otherwise packet will be deleted & we have Access violation
@


1.162
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d166 1
a166 1
			case PR_VERYHIGH:  // Modified by Tarod for UAP
a190 1
//End milobac: Anti-leechermods
@


1.161
log
@Formatting, comments, and name changes.
@
text
@d58 4
a61 4
			if (PARTSIZE*(i+1) > filesize) 
			uEnd = filesize; 
			else 
			uEnd = PARTSIZE*(i+1); 
d284 1
a284 1
			{ 
d286 1
a286 1
				//AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk, sent %u KB", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d289 1
a289 1
			{ 
d291 1
a291 1
			             //AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u KB", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d468 8
a475 7
	CFile file;
	CKnownFile* 	srcfile;
	CPartFile*	pPartFile;
	byte* filedata = 0;
	bool bFromPF = true;
	CString fullname;
	CSyncHelper lockFile;
d622 1
a622 1
				
d639 1
a639 1
				
d685 1
a685 1
	}	
@


1.160
log
@commented out a debuglogline (client is already banned)
@
text
@d1381 3
a1383 2
	{	//SyruS no need to ban a client (and send a message) again except for extending the bantime
		//AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
@


1.159
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d1382 1
a1382 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
@


1.158
log
@Formatting, comments, and name changes.
@
text
@a533 1

a535 1

@


1.157
log
@Formatting, comments, and name changes.
@
text
@d1020 4
a1023 3
		//	Get next block and give it to the m_pRequestSocket for transfer
			Packet * pPacket = m_blockSendQueue.RemoveHead();
			uint32 nBlockSize = pPacket->GetRealPacketSize();
d1287 6
a1292 3
	CSafeMemFile data(256);
	data.Write(&rating, sizeof(rating));
	int length = desc.GetLength();
d1295 1
a1295 1
	data.Write(&length, sizeof(length));
d1297 4
a1300 2
		data.Write(desc.GetBuffer(), length);
	Packet *packet = new Packet(&data, OP_EMULEPROT);
d1410 1
a1410 1

d1414 1
d1417 9
a1425 4
	SetLastL2HACExecution(); //<<-- enkeyDEV(th1) -L2HAC
	uint16 nRank = g_eMuleApp.m_pUploadQueue->GetWaitingPosition(this);
	Packet* response = new Packet(OP_REASKACK, 2, OP_EMULEPROT);
	memcpy2(response->m_pcBuffer, &nRank, 2);
a1426 2
//	By Maverick
	ProxySettings proxy = g_eMuleApp.m_pGlobPrefs->GetProxy();
d1429 2
a1430 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(response->m_dwSize);
d1432 2
a1433 4

		g_eMuleApp.m_pClientUDPSocket->SendPacket(response, GetIP(), GetUDPPort());
#endif //OLD_SOCKETS_ENABLED

d1437 1
a1437 1

@


1.156
log
@recommit for "Completion Fix" with Aw3 correction
@
text
@d600 1
a600 1
			if (pPartFile)
d666 1
a666 1
			if (!pPartFile)
d812 1
a812 1
void CUpDownClient::CreateStandardPackets(byte* data, uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d815 4
a818 2
	uint32 nPacketSize;
	CMemFile memfile((BYTE*)data, togo);
d820 1
a820 1
		nPacketSize = togo / (uint32)(togo / 10240);
d823 2
a824 1
	while (togo)
d829 3
a831 1
		Packet* packet = new Packet(OP_SENDINGPART, nPacketSize + 24, OP_EDONKEYPROT, bFromPF);	// -khaos: Create the packet with the new boolean.
d833 2
a834 1
		uint32 statpos = (currentblock->m_dwEndOffset - togo) - nPacketSize;
d836 2
a837 1
		memcpy2(&packet->m_pcBuffer[16], &statpos, 4);
d839 2
d848 1
a848 1
void CUpDownClient::CreatePackedPackets(byte* data, uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d853 1
a853 1
	uint16 result = compress2(output, &newsize, data, togo, 9);
d857 1
a857 1
		CreateStandardPackets(data, togo, currentblock, bFromPF);		// -khaos: Create the packet with the new boolean.
d877 4
a880 2
		uint32 statpos = currentblock->m_dwStartOffset;
		memcpy2(&packet->m_pcBuffer[16], &statpos, 4);
d1121 1
a1121 1
void CUpDownClient::SendHashsetPacket(char* forfileid)
d1124 4
a1127 2
	CKnownFile * file = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)forfileid);
	if (!file)
d1133 12
a1144 7
	CSafeMemFile data(1024);
	data.Write(file->GetFileHash(), 16);
	uint16 parts = file->GetHashCount();
	data.Write(&parts, 2);
	for (int i = 0; i < parts; i++)
		data.Write(file->GetPartHash(i), 16);
	Packet* packet = new Packet(&data);
d1154 1
a1154 1

d1274 1
a1274 1
void CUpDownClient::SendCommentInfo(CKnownFile *file)
d1277 1
a1277 1
	if (!m_bCommentDirty || file == NULL || !ExtProtocolAvailable() || m_byteAcceptCommentVer < 1)
d1281 3
a1283 3
	EnumPartFileRating rating = file->GetFileRating();
	CString desc = file->GetFileComment();
	if (file->GetFileRating() == PF_RATING_NONE && desc.IsEmpty())
@


1.155
log
@Reverted completion 'fix' by eklmn so we can release 1j this month
@
text
@d496 3
d507 6
a512 6
//				//eklmn: report the file about start of UL
//				if (m_doneBlocksList.IsEmpty())
//				{
//					pUploadingPartFile = pPartFile;
//					pUploadingPartFile->SetFileUpload(true);
//				}
@


1.154
log
@added memory exception handling by block creation + some optimization
@
text
@d504 6
a509 6
				//eklmn: report the file about start of UL
				if (m_doneBlocksList.IsEmpty())
				{
					pUploadingPartFile = pPartFile;
					pUploadingPartFile->SetFileUpload(true);
				}
@


1.153
log
@eklmn's changes
@
text
@d469 2
a470 1
	CKnownFile* srcfile;
d496 7
a502 1
			if (srcfile->IsPartFile() && ((CPartFile*)srcfile)->GetStatus() != PS_COMPLETE)
d507 1
a507 1
					pUploadingPartFile = reinterpret_cast<CPartFile*>(srcfile);
d513 1
a513 1
				if (!((CPartFile*)srcfile)->m_FileCompleteMutex.Lock(0)) // just do a quick test of the mutex's state and return if it's locked.
d515 1
a515 1
				lockFile.m_pObject = &((CPartFile*)srcfile)->m_FileCompleteMutex;
d519 1
a519 1
				fullname = ((CPartFile *)srcfile)->GetFullName();
d597 1
a597 1
			if (srcfile->IsPartFile())
d601 1
a601 1
				if (!((CPartFile*)srcfile)->IsComplete(parts_start, parts_end))
d608 4
a611 1
			if (!srcfile->IsPartFile())
d620 1
a620 2

				filedata = new byte[togo + 500];
d630 1
a630 2
				CPartFile* partfile = (CPartFile*)srcfile;
				partfile->GetPartFileHandle().Seek(currentblock->m_dwStartOffset, 0);
d632 8
a639 2
				filedata = new byte[togo + 500];
				if (uint32 done = partfile->GetPartFileHandle().Read(filedata, togo) != togo)
d641 2
a642 2
					partfile->GetPartFileHandle().SeekToBegin();
					partfile->GetPartFileHandle().Read(filedata + done, togo - done);
a644 5
			if (lockFile.m_pObject)
			{
				lockFile.m_pObject->Unlock();	//SyruS (0.29c) Unlock the (part) file as soon as we are done with accessing it.
				lockFile.m_pObject = NULL;		//SyruS (0.30b)
			}
d663 1
a663 2

			if (!srcfile->IsPartFile())
d677 8
a684 1
	catch (CString & error)
d687 2
a688 1
		AddDebugLogLine(false, IDS_ERR_CLIENTERRORED, GetUserName(), error.GetBuffer());
d691 1
d694 1
a694 2
//v- eklmn: bugfix(13): memleak in UploadClient due CFile (based on 0.29a)
	catch (CFileException * error)
d697 1
a697 2
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_FILE_ERROR);
a699 1
		error->Delete();
a701 1
//^- eklmn: bugfix(13): memleak in UploadClient due CFile (based on 0.29a)
@


1.152
log
@new way of syncronization by file completion
@
text
@d500 2
a501 2
					((CPartFile*)srcfile)->SetFileUpload(true);
					bPartFileIsUploading = true;
@


1.151
log
@fixed data transfer after cancel request
@
text
@d497 6
@


1.150
log
@Minor changes
@
text
@d1134 2
d1140 4
a1143 4
	FlushSendBlocks();
	for (POSITION pos = m_blockRequestsQueue.GetHeadPosition();pos != 0;m_blockRequestsQueue.GetNext(pos))
		delete m_blockRequestsQueue.GetAt(pos);
	m_blockRequestsQueue.RemoveAll();
d1145 4
a1148 3
	for (POSITION pos = m_doneBlocksList.GetHeadPosition();pos != 0;m_doneBlocksList.GetNext(pos))
		delete m_doneBlocksList.GetAt(pos);
	m_doneBlocksList.RemoveAll();
d1150 4
a1153 3
	for (POSITION pos = m_blockSendQueue.GetHeadPosition();pos != 0;m_blockSendQueue.GetNext(pos))
		delete m_blockSendQueue.GetAt(pos);
	m_blockSendQueue.RemoveAll();
@


1.149
log
@caseinsensitive handling of communtiy-sharing
@
text
@d440 1
a440 1
				AddDebugLogLine(false, _T("Client %s (%s)  back on queue. Asked for a new chunk/file, after receiving %u KB."), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d446 1
a446 1
				AddDebugLogLine(false, _T("Client %s (%s)  back on queue. Asked for a chunk forbidden by Jumpstart, after receiving %u KB."), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d452 1
a452 1
				AddDebugLogLine(false, _T("Client %s (%s)  back on queue. Upload timeout, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
@


1.148
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d90 1
d92 1
@


1.147
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d131 1
a131 1
					AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Anti-leechermods: Client %s (%s) using the mod %s has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d133 1
a133 1
					AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Anti-leechermods: Client %s (%s) has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this));
d673 1
a673 1
		AddDebugLogLine(false, RGB_RED + _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d1092 1
a1092 1
		AddDebugLogLine(false, RGB_RED + GetResString(IDS_ERR_REQ_FNF) + CString(" (SendHashsetPacket)"));
d1326 1
a1326 1
		AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Client '%s' banned and kicked out of uploadqueue %s"), GetUserName(), reason);
d1332 1
a1332 1
		AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
d1348 1
a1348 1
			AddLogLine(false, RGB_BLUE_GRAY + GetResString(IDS_SENTBAN), GetUserName(), reason);
d1352 1
a1352 1
			AddLogLine(false, RGB_BLUE_GRAY + GetResString(IDS_CLIENTBLOCKED), GetUserName(), reason);
@


1.146
log
@Added some colors to the logs...
@
text
@d131 1
a131 1
					AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Anti-leechermods: Client %s (%s) using the mod %s has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d133 1
a133 1
					AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Anti-leechermods: Client %s (%s) has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this));
d673 1
a673 1
		AddDebugLogLine(false, _T("<COLOR=255,0,0>Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d681 1
a681 1
//	AddDebugLogLine(false,"Debug: Packet done. Size: %i",blockpack->GetLength());
d1092 1
a1092 1
		AddDebugLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_REQ_FNF) + CString(" (SendHashsetPacket)"));
d1326 1
a1326 1
		AddDebugLogLine(false, _T("<COLOR=102,102,153>Client '%s' banned and kicked out of uploadqueue %s"), GetUserName(), reason);
d1332 1
a1332 1
		AddDebugLogLine(false, _T("<COLOR=102,102,153>Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
d1348 1
a1348 1
			AddLogLine(false, _T("<COLOR=102,102,153>") + GetResString(IDS_SENTBAN), GetUserName(), reason);
d1352 1
a1352 1
			AddLogLine(false, _T("<COLOR=102,102,153>") + GetResString(IDS_CLIENTBLOCKED), GetUserName(), reason);
@


1.145
log
@minor spell-corrections (debuglog)
@
text
@d131 1
a131 1
					AddDebugLogLine(false, _T("%s: Anti-leechermods: Client %s (%s) using the mod %s has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this), GetModVersion());
d133 1
a133 1
					AddDebugLogLine(false, _T("%s: Anti-leechermods: Client %s (%s) has been banned"), __FUNCTION__, GetUserName(), GetClientNameAndVersionString(this));
d673 1
a673 1
		AddDebugLogLine(false, _T("Failed to create upload package for %s - %s"), GetUserName(), GetErrorMessage(error));
d1092 1
a1092 1
		AddDebugLogLine(false, GetResString(IDS_ERR_REQ_FNF) + CString(" (SendHashsetPacket)"));
d1326 1
a1326 1
		AddDebugLogLine(false, _T("Client '%s' banned and kicked out of uploadqueue %s"), GetUserName(), reason);
d1332 1
a1332 1
		AddDebugLogLine(false, _T("Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
d1348 1
a1348 1
			AddLogLine(false, IDS_SENTBAN, GetUserName(), reason);
d1352 1
a1352 1
			AddLogLine(false, IDS_CLIENTBLOCKED, GetUserName(), reason);
@


1.144
log
@Formatting, comments, and name changes.
@
text
@d1326 1
a1326 1
		AddDebugLogLine(false, _T("Client '%s' banned and kicked out of m_pUploadQueue %s"), GetUserName(), reason);
d1332 1
a1332 1
		AddDebugLogLine(false, _T("Client '%s' is already banned from the m_pUploadQueue %s"), GetUserName(), reason);
@


1.143
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d89 1
a89 1
		CString username(m_strUsername);
d119 1
a119 1
	if (m_strUsername.IsEmpty())
d276 2
a277 2
			last_done_part = last_done_block->StartOffset / PARTSIZE;
			next_requested_part = next_requested_block->StartOffset / PARTSIZE;
d286 1
a286 1
			if (md4cmp (last_done_block->FileID, next_requested_block->FileID) != 0)
d292 1
a292 1
			if (last_done_part != next_requested_part || md4cmp(last_done_block->FileID, next_requested_block->FileID) != 0)
d335 2
a336 2
		next_requested_part = next_requested_block->StartOffset / PARTSIZE;
		CKnownFile* kf = g_eMuleApp.m_pSharedFilesList->GetFileByID(next_requested_block->FileID);
d486 1
a486 1
			srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(currentblock->FileID);
d523 1
a523 1
				uint8 part_status = srcfile->GetPartStatus(currentblock->StartOffset / PARTSIZE);
d528 2
a529 2
					AddLogLine(false, IDS_PARTPRIO_DENIED, currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
					s.Format(GetResString(IDS_PARTPRIO_DENIED), currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
d534 1
a534 1
					AddLogLine(false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
d544 1
a544 1
				if (currentblock->StartOffset > currentblock->EndOffset - 1)
d546 1
a546 1
				//	If StartOffset is later in the file than EndOffset, it means
d551 1
a551 1
					togo = currentblock->EndOffset + (srcfile->GetFileSize() - currentblock->StartOffset);
d557 1
a557 1
					togo = currentblock->EndOffset - currentblock->StartOffset;
d563 2
a564 2
			//	Check that StartOffset and EndOffset is in the same chunk
				if (currentblock->StartOffset / PARTSIZE != (currentblock->EndOffset - 1) / PARTSIZE)
d566 3
a568 3
				//	The EndOffset goes into the next chunk. Set it to the end of the chunk
				//	that StartOffset is in.
					currentblock->EndOffset = ((uint32)(currentblock->StartOffset / PARTSIZE) + 1) * PARTSIZE;
d572 1
a572 1
				if (currentblock->StartOffset > currentblock->EndOffset)
d574 1
a574 1
					currentblock->EndOffset = srcfile->GetFileSize();
d579 1
a579 1
				togo = currentblock->EndOffset - currentblock->StartOffset;
d584 2
a585 2
				uint32 parts_start = ((currentblock->StartOffset) / PARTSIZE) * PARTSIZE;
				uint32 parts_end = ((currentblock->EndOffset - 1) / PARTSIZE + 1) * PARTSIZE - 1;
d601 1
a601 1
				file.Seek(currentblock->StartOffset, 0);
d614 1
a614 1
				partfile->GetPartFileHandle().Seek(currentblock->StartOffset, 0);
d629 1
a629 1
			md4cpy(m_reqFileHash, currentblock->FileID);
d642 1
a642 1
			srcfile->statistic.AddTraffic(currentblock->StartOffset, togo);
d651 1
a651 1
					srcfile->AddSentBlock(this, currentblock->StartOffset, togo);
d804 2
a805 2
		uint32 statpos = (currentblock->EndOffset - togo) - nPacketSize;
		uint32 endpos = (currentblock->EndOffset - togo);
d844 1
a844 1
		uint32 statpos = currentblock->StartOffset;
d907 1
a907 1
		if (reqblock->StartOffset == m_doneBlocksList.GetAt(pos)->StartOffset && reqblock->EndOffset == m_doneBlocksList.GetAt(pos)->EndOffset)
d915 1
a915 1
		if (reqblock->StartOffset == m_blockRequestsQueue.GetAt(pos)->StartOffset && reqblock->EndOffset == m_blockRequestsQueue.GetAt(pos)->EndOffset)
d986 2
a987 2
			Packet * tosend = m_blockSendQueue.RemoveHead();
			uint32 nBlockSize = tosend->GetRealPacketSize();
d992 1
a992 1
			g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), tosend->IsFromPF(), TRANSFERTYPE_UPLOAD, nBlockSize);
d994 2
a995 2
			m_pRequestSocket->SendPacket(tosend, true, false);
			tosend = NULL;	//eklmn: bugfix(17): upload fix(reset tosend in SendBlockData)
d1062 3
a1064 1

d1066 1
a1066 1
{ // call this when you stop upload, or the m_pRequestSocket might be not able to send
d1068 3
a1070 1
	bool bBreak = false;
d1072 4
d1077 4
a1080 6
	while (!m_blockSendQueue.IsEmpty() && m_blockSendQueue.GetHead()->IsSplit() && m_pRequestSocket && m_pRequestSocket->IsConnected() && !bBreak)
	{
		Packet * tosend = m_blockSendQueue.RemoveHead();
		bool bBreak = tosend->IsLastSplit();
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(tosend->m_dwSize);
		m_pRequestSocket->SendPacket(tosend, true, false);
d1085 1
a1085 1

d1131 1
a1131 1

d1135 1
d1148 1
d1151 1
a1151 1

d1265 1
a1265 1
		if (!md4cmp(cur_struct->fileid, fileid))
d1267 1
a1267 1
			if (::GetTickCount() - cur_struct->lastasked < MIN_REQUESTTIME)
d1270 2
a1271 2
					cur_struct->badrequests++;
				if (cur_struct->badrequests == BADCLIENTBAN) //katsyonak 16.06.03
d1276 2
a1277 2
				if (cur_struct->badrequests)
					cur_struct->badrequests--;
d1279 1
a1279 1
			cur_struct->lastasked = ::GetTickCount();
d1285 2
a1286 2
	md4cpy(new_struct->fileid, fileid);
	new_struct->lastasked = ::GetTickCount();
d1300 2
a1301 2
	offensecounter.RemoveKey(GetUID());
	hashbase.RemoveKey(GetUID());
d1307 2
a1308 2
		cur_struct->badrequests = 0;
		cur_struct->lastasked = 0;
d1469 1
a1469 1
		uint32		dwPartNum = pFirstDoneBlock->StartOffset / PARTSIZE;
@


1.142
log
@New sockets - fix for compilation
@
text
@d191 2
a192 2
//	calculate score, based on waitingtime and other factors
	float fBaseValue;
d194 1
a194 1
		fBaseValue = 100.0f;
d196 1
a196 1
		fBaseValue = (float)(GetTickCount() - m_dwWaitTime) / 1000.0f;
d199 2
a200 2
	//	we dont want one client to download forever
	//	the first 15 min downloadtime counts as 15 min waitingtime and you get a 15 min bonus while you are in the first 15 min :)
d202 1
a202 1
		fBaseValue = (float)(m_dwUploadTime - m_dwWaitTime);
d204 2
a205 2
		fBaseValue += (float)(GetTickCount() - m_dwUploadTime > 900000) ? 900000.0f : 1800000.0f;
		fBaseValue /= 1000.0f;
d208 1
a208 1
		fBaseValue *= 1.5f; // since up/down credits are in, this isn't that improtant anymore
d210 1
a210 1
		fBaseValue *= 2.0f;
d213 1
a213 1
		fBaseValue *= 2.0f;
d219 1
a219 1
		fBaseValue *= m_pCredits->GetScoreRatio(this->GetIP());
d223 2
a224 2
	fBaseValue *= GetSmallFilePushRatio();
	fBaseValue *= GetRareFilePushRatio();
d226 1
a226 1
	fBaseValue *= ((float)(m_uFilePriority)) / 10.0f;
d228 1
a228 1
	return(uint32)fBaseValue;
d235 1
a235 1
float CUpDownClient::GetRareFilePushRatio()
d239 1
a239 1
//	return 1.0f;
d242 1
a242 1
		return 1.0f;
d245 2
a246 2
	float ratio = 0 + srcfile->GetFileRatio();
	return(ratio < 1.0f ? 1.0f : ((ratio > 100.0f) ? 100.0f : ratio)); //Cax2 bugfix
d249 1
a249 1
	return 1.0f;
d350 1
a350 1
float CUpDownClient::GetSmallFilePushRatio()
d357 1
a357 1
		return 1.0f;
d360 1
a360 1
	long filesize = srcfile->GetFileSize() ;
d363 1
a363 1
	if (filesize > 0.0f && filesize < 9961472)
d367 4
a370 3
		float mul = 9961472 / filesize ;		// VQB formula + Cax2 overflow bugfix...
		if (mul > 100.0f)
			mul = 100.0f ;		// VQB formula
d375 1
a375 1
	return 1.0f;
d1049 1
a1049 1
			m_lUpDataRate = (uint32)(((float)(m_averageUDRList.front() - m_averageUDRList.back())) * 1000 / timePeriod);
d1107 1
a1107 1
float CUpDownClient::GetClientSpeed()
d1115 1
a1115 1
		return 0;
d1119 1
a1119 1
		return 0;
d1121 1
a1121 1
	return(float)(g_eMuleApp.stat_sessionSentBytes / 1024) / running;
d1123 1
a1123 1
	return 0;
d1185 1
a1185 1
	float fBaseValue = 1.0;
d1188 1
a1188 1
		fBaseValue *= m_pCredits->GetScoreRatio(this->GetIP());
d1190 2
a1191 2
	fBaseValue *= 10;
	uint16 nRatio = (uint16)fBaseValue;
d1410 2
a1411 2
	float fBaseValue = 100.0f;
//if (bIsBotuser) fBaseValue *= 0.9f;	//Cax2 - not anymore
d1415 1
a1415 1
		fBaseValue *= 0.8f;
d1419 1
a1419 1
		fBaseValue *= 1.5f;
d1421 1
a1421 1
		fBaseValue *= 2.0f;
d1423 6
a1428 5
		fBaseValue *= 2.0f;
	fBaseValue *= GetRemoteBaseModifier();
	fBaseValue *= GetSmallFilePushRatio() ;
	fBaseValue *= GetRareFilePushRatio() ;
	return(uint32)fBaseValue;
d1430 1
d1434 1
a1434 1
float	CUpDownClient::GetRemoteBaseModifier()
d1438 1
a1438 1
		return(float)m_uRemoteBaseModifier / 100.0;
d1443 1
a1443 1
	if (m_pCredits == (CClientCredits*) - 1)
@


1.141
log
@Formatting, comments, and name changes.
@
text
@d1147 1
d1150 1
@


1.140
log
@Trying to fix the SetFocus issue.
@
text
@d118 1
a118 1
//TODO: complete this (friends, uploadspeed, emuleuser etc etc)
d1146 4
@


1.139
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d1329 1
a1329 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.StartSession(this, TRUE);
@


1.138
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d31 1
a31 1
static char THIS_FILE[]=__FILE__;
d37 1
a37 1
//	which are mainly used for uploading functions 
d39 2
a40 1
void CUpDownClient::DrawUpStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool  bFlat){ 
d43 3
a45 3
	const COLORREF crBoth=(bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);	//Cax2 - same green used for files & clients 
	const COLORREF crNeither=(bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240); 
    const COLORREF crBeingSent = RGB(255,208,0);
d47 1
a47 1
	uint32 filesize =(m_uUpPartCount) ? PARTSIZE*(m_uUpPartCount):1; // might be a little off.. better than nothing
d50 2
a51 2
	statusBar.SetFileSize(filesize); 
	statusBar.Fill(crNeither); 
d53 2
a54 2
	if (filesize !=1 && !onlygreyrect && m_pbyteUpPartStatuses)	//Cax2 - no more black rectangle
	{ 
d56 2
a57 2
		{ 
            /* no need for that now, cause we don't use the precise filesize
d59 1
a59 1
				uEnd = filesize; 
d61 7
a67 6
				uEnd = PARTSIZE*(i+1); 
            */
		    uint32 uEnd = PARTSIZE*(i+1);
			
			if (m_pbyteUpPartStatuses[i]){ //they have this part
                statusBar.FillRange(PARTSIZE*i, uEnd, crBoth); // will do for now
d70 7
a76 7
                statusBar.FillRange(PARTSIZE*i, uEnd, crNeither);
                uint32 partno = GetCurrentlyUploadingPart();
                if(i==partno) // won't be equal if it is 0xFFFF
                    statusBar.FillRange(PARTSIZE*i,  uEnd, crBeingSent);
		} 
   	} 
   	statusBar.Draw(dc, rect->left, rect->top, bFlat); 
d79 1
a79 1
} 
d81 1
a81 1
bool CUpDownClient::IsCommunity()        
d87 2
a88 2
		// [i_a] DonGato (Community Sharing)
		//eklmn: to prevent a leeching the community string must have a same format
d92 4
a95 3
		
		community.Remove('['); community.Remove(']');
		communityok.Format("[%s]",community);
d100 1
a100 1
	
d108 2
a109 2
    m_bScoreBaseIsCached = false;
    m_bCommunityIsCached = false;
d118 1
a118 1
	//TODO: complete this (friends, uploadspeed, emuleuser etc etc)
d121 3
a123 3
	//SyruS moved this up (from end) to skip the whole useless calculation
	//Start milobac: Anti-leechermods
	if (m_bBanned) 
d125 1
a125 1
	else	
d128 1
a128 1
			if (::GetTickCount() > dwLastMsgTime + (60*1000))	//spam control
d131 4
a134 4
					AddDebugLogLine(false,_T("%s: Anti-leechermods: Client %s (%s) using the mod %s has been banned"),__FUNCTION__,GetUserName(),GetClientNameAndVersionString(this),GetModVersion());
				else 
					AddDebugLogLine(false,_T("%s: Anti-leechermods: Client %s (%s) has been banned"),__FUNCTION__,GetUserName(),GetClientNameAndVersionString(this));
				//katsyonak: Send leecher ban message 15.06.03
d141 1
a141 1
	//End milobac: Anti-leechermods
d147 1
a147 1
	{ 
d155 15
a169 1
	if (req_file == NULL) return 0;
a170 13
	//eklmn: we cann't cache a value here, cause otherwise our chages of priority will 
	//           be not applied until we restart eMule.
        ASSERT(m_reqFileHash != NULL); // i_a: m_reqFileHash is an array so the if() was superfluous 
        { 
		switch(req_file->GetPriority())
		{ 
			case PR_VERYHIGH: // Modified by Tarod for UAP
				if (req_file->IsPartFile())
					m_uFilePriority = 50;
				else
					m_uFilePriority = 100;
				break;
					
d172 3
a174 3
				m_uFilePriority = 20;
				break;
					
d176 2
a177 2
				m_uFilePriority = 5;
				break;
d180 3
a182 3
				m_uFilePriority = 2;
				break;
					
d185 3
a187 3
				m_uFilePriority = 10;	// standard
				break;
		} 
d189 1
a189 1
	//End milobac: Anti-leechermods
d191 1
a191 1
	// calculate score, based on waitingtime and other factors
d196 1
a196 1
		fBaseValue = (float)(GetTickCount()-m_dwWaitTime)/1000.0f;
d199 6
a204 6
		// we dont want one client to download forever
		// the first 15 min downloadtime counts as 15 min waitingtime and you get a 15 min bonus while you are in the first 15 min :)
		// (to avoid 20 sec downloads) after this the score won't raise anymore 
		fBaseValue = (float)(m_dwUploadTime-m_dwWaitTime);
		ASSERT ( m_dwUploadTime-m_dwWaitTime >= 0 ); //oct 28, 02: changed this from "> 0" to ">= 0"
		fBaseValue += (float)(GetTickCount() - m_dwUploadTime > 900000)? 900000.0f:1800000.0f;
d206 1
a206 1
	}	
d211 2
a212 2
	// DonGato (Community Sharing)
	if (g_eMuleApp.m_pGlobPrefs->CommunityEnabled() && IsCommunity())		
d214 5
a218 5
	
	//Fix by Amdribant [loadedsrc]
	//ASSERT(m_pCredits != NULL); 
	if(m_pCredits != (CClientCredits*)NULL)
	{ 
d220 1
a220 1
	} 
d222 1
a222 1
	// Added by Tarod (herbert code)
d226 1
a226 1
	fBaseValue *= ((float)(m_uFilePriority))/10.0f; 
d228 1
a228 1
	return (uint32)fBaseValue;
d234 1
a234 1
// Added by Tarod based in herbert code and modifications by MatzeHH
d238 3
a240 3
	//if(!g_eMuleApp.m_pGlobPrefs->FairShareRarePush())
	//	return 1.0f;
	CKnownFile* srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_reqFileHash);
d243 4
a246 4
	
	// keep the FileRatio
	float ratio = 0+srcfile->GetFileRatio();
	return (ratio < 1.0f ? 1.0f :((ratio>100.0f)?100.0f: ratio)); //Cax2 bugfix
d252 5
a256 5
// Checks if it is next requested block from another chunk of the actual file or from another file 
// 
// [Returns] 
//   true : Next requested block is from another different chunk or file than last downloaded block 
//   false: Next requested block is from same chunk that last downloaded block 
d258 2
a259 2
{ 
	Requested_Block_Struct* last_done_block;
d263 1
a263 1
	
d265 4
a268 3
	
	try {
		// Check if we have good lists and proceed to check for different chunks
d271 1
a271 1
			// Get last block and next pending
d273 3
a275 3
			next_requested_block = (Requested_Block_Struct*)m_blockRequestsQueue.GetHead(); 
			
			// Calculate corresponding parts to blocks
d277 3
a279 3
			next_requested_part = next_requested_block->StartOffset / PARTSIZE; 
             
			// Test is we are asking same file and same part
d289 1
a289 1
                //AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u KB", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d292 1
a292 1
			if ( last_done_part != next_requested_part || md4cmp(last_done_block->FileID, next_requested_block->FileID) != 0)
d294 17
a310 15
		} 
   	}
   	catch(...)
   	{ 
      		different_part = true; 
   	}

	if(different_part) {
		//AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u KB", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferredUp() / 1024); 

		// obaldin: this is for old clients, that rotate the chunk,
		// so that they'll be able to download at least _something_
		// But probably even after the majority switches we'd
		// better check for 0 here
		if(GetSessionUp() < 1024*1024) {
d313 1
a313 1
				AddDebugLogLine(false, _T("Client %s continues downloading (should be back on queue) because of a low transferred size"),GetUserName()); 
d317 1
a317 1
	return different_part; 
d322 1
a322 1
{ 
d324 2
a325 2
		
	Requested_Block_Struct* next_requested_block;
d328 2
a329 1
	if(m_blockRequestsQueue.IsEmpty()) {
d331 3
a333 2
	} 
	else {
d337 2
a338 1
		if (kf != NULL && !kf->AllowChunkForClient(next_requested_part, this)) {
d350 2
a351 1
float CUpDownClient::GetSmallFilePushRatio(){
d353 3
a355 3
	//if(!g_eMuleApp.m_pGlobPrefs->FairShareRarePush())
	//	return 1.0f;
	CKnownFile* srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_reqFileHash);
d359 1
a359 1
	//Cax2 faster code ....
d362 3
a364 2
	//if (filesizeinmb > 0.0f && filesizeinmb < 9.5f) {
	if (filesize > 0.0f && filesize < 9961472) {
d366 4
a369 3
		// Modded by Tarod to: Min(100, Max(1, 9.5 / FS)) [9.5 Mbs. == Chunk Size]
		float mul = 9961472/ filesize ;		// VQB formula + Cax2 overflow bugfix...
		if (mul > 100.0f) mul = 100.0f ;		// VQB formula 
d376 1
a376 1
// End added by Tarod
d397 12
a408 11
bool CUpDownClient::CreateNextBlockPackage(){
	// check if we should kick this client (time critical !!!)
	// Never kick friends
	// Always kick if transfer is longer than 80 minutes
	// Never allow more than the size of a chunk (+500 KBytes for small resends of invalid data) to be transferred
	// VQB to provide full chunk transfers (modified by Tarod)
	// Note: Full chunk transfers really should be enforced, not an option
	EMULE_TRY
	// LANCAST (moosetea) We never kick a lancast user
	bool AllowedMore = IsOnLAN();	
	// v- eklmn: bugfix(04): conflict between upload logic & LANcast
d411 1
a413 1
	bool shouldGo=((GetUpStartTimeDelay()>= 80*60*1000) || diff_part);
d415 3
a417 1
	// if user is from Internet && full chunk (or timeout)
d423 1
d426 1
d429 1
a429 1
			AddDebugLogLine(false, _T("Client %s downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend."), GetUserName(), this->GetSessionUp() / 1024); 
d431 1
a431 1
		else 
d436 1
a436 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d442 1
a442 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d448 1
a448 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_TIMEOUT);
d451 1
a451 1
			g_eMuleApp.m_pUploadQueue->AddClientToQueue(this,true);
d455 7
a461 6
	// ^- eklmn: bugfix(04): conflict between upload logic & LANcast
	
	if (m_blockRequestsQueue.IsEmpty()) {
		// There are no new blocks requested, put we will happily transfer more
		// if the client just requests something
		// AddDebugLogLine(false, "No more data to send to client %s(%s), should be back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
d473 3
a475 3
		// repeat as long as next requested block is in the same chunk as previous blocks
		// and as long as there is a next requested block
		//added: if a friend or lancast user, keep going![Cax2]
d477 1
a477 1
		while (!m_blockRequestsQueue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()) && !IsForbiddenByJumpstart() )
d479 2
a480 1
		while (!m_blockRequestsQueue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()) )		//Cax2 - if a friend or lancast user, keep going!
d482 1
d484 1
a484 1
			Requested_Block_Struct* currentblock = m_blockRequestsQueue.GetHead();
d488 1
a488 1
				g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_FILE_ERROR);	// eklmn: ???
d494 3
a496 3
				// SyruS (0.29c) Do not access a part file, if it is currently moved into the incoming directory.
				// Because the moving of part file into the incoming directory may take a noticable 
				// amount of time, we can not wait for 'm_FileCompleteMutex' and block the main thread.
d500 3
a502 3
				// If it's a part file which we are uploading the file remains locked until we've read the
				// current block. This way the file completion thread can not (try to) "move" the file into
				// the incoming directory.
d504 1
a504 1
				fullname.Truncate(fullname.GetLength() - 4);			
d507 2
a508 2
			{				
				fullname.Format(_T("%s\\%s"),srcfile->GetPath(),srcfile->GetFileName());
d511 1
a511 1
			//v- eklmn: bugfix(18): conflict between JUMSTART & PartTraffic)
d515 2
a516 1
			if (true) 
d518 1
d520 2
a521 2
				//--- xrmb:partprio ---
				//--- accessing a blocked part??? ---
d524 2
a525 1
				switch (part_status) {
d527 5
a531 5
						AddLogLine(false, IDS_PARTPRIO_DENIED, currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
						s.Format(GetResString(IDS_PARTPRIO_DENIED), currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
						g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
						throw s;
						break;
d533 1
a533 1
						AddLogLine(false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
d535 1
a535 1
				//--- :xrmb ---
d537 2
a538 2
			//^- eklmn: bugfix(18): conflict between JUMSTART & PartTraffic)
			
d540 8
a547 6
			if (AllowedMore) {	// Friends & LAN  are not limited by chunks boundaries.
				// Is this a wraparound request?
				if (currentblock->StartOffset > currentblock->EndOffset-1){
					// If StartOffset is later in the file than EndOffset, it means
					// that the request is a wraparound request. It reads to the end of
					// the file, then it wraps around and continues in the beginning of the file.
d549 1
a549 1
					// Calculate how much the client is requesting, knowing that this is a wraparound request
d551 5
a555 4
				} 
				else {
					// not a wraparound request. This makes it easier to calculate how many bytes is
					// being requested.
d558 10
a567 8
			} 
			else {
				// Everyone else are limited to a single chunk
				// Check that StartOffset and EndOffset is in the same chunk
				if(currentblock->StartOffset/PARTSIZE != (currentblock->EndOffset - 1)/PARTSIZE) {
					// The EndOffset goes into the next chunk. Set it to the end of the chunk
					// that StartOffset is in.
					currentblock->EndOffset = ((uint32)(currentblock->StartOffset/PARTSIZE)+1)*PARTSIZE;
d570 3
a572 2
				// Make sure we don't pass end of file
				if (currentblock->StartOffset > currentblock->EndOffset) {
d576 2
a577 2
				// This can't be a wrapped around request, since it has been limited to
				// a single chunk.
d581 5
a585 4
			if (srcfile->IsPartFile()) { // proper check
				uint32 parts_start = ((currentblock->StartOffset)/PARTSIZE)*PARTSIZE;
				uint32 parts_end = ((currentblock->EndOffset-1)/PARTSIZE + 1)*PARTSIZE -1;
				if(!((CPartFile*)srcfile)->IsComplete(parts_start,parts_end))
d587 1
a587 1
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d591 1
a591 1
			
d595 1
a595 1
				if (!file.Open(fullname,CFile::modeRead|CFile::osSequentialScan|CFile::shareDenyNone))
d597 2
a598 2
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_FILE_ERROR);
					throw GetResString(IDS_ERR_OPEN);				
d600 5
a604 4
				file.Seek(currentblock->StartOffset,0);
				
				filedata = new byte[togo+500];
				if (uint32 done = file.Read(filedata,togo) != togo){
d606 1
a606 1
					file.Read(filedata + done,togo-done);
d612 6
a617 5
				CPartFile* partfile = (CPartFile*)srcfile;				
				partfile->GetPartFileHandle().Seek(currentblock->StartOffset,0);
				
				filedata = new byte[togo+500];
				if (uint32 done = partfile->GetPartFileHandle().Read(filedata,togo) != togo){
d619 1
a619 1
					partfile->GetPartFileHandle().Read(filedata + done,togo-done);
d628 1
a628 1
			md4cpy(m_reqFileHash,currentblock->FileID);
d630 1
a630 1
			// -khaos--+++> We're going to add bFromPF as a parameter to the calls to create packets...
d632 1
a632 1
				CreatePackedPackets(filedata,togo,currentblock,bFromPF);
d634 4
a637 4
				CreateStandardPackets(filedata,togo,currentblock,bFromPF);
			// <-----khaos-
			
			// file statistic
d640 1
a640 1
			//--- xrmb:parttraffic ---
d642 1
a642 1
			//--- :xrmb ---
d645 5
a649 2
			if (!srcfile->IsPartFile()){
				if (srcfile->GetJumpstartEnabled()){
d660 2
a661 1
	catch(CString &error){
d663 1
a663 1
		AddDebugLogLine(false,IDS_ERR_CLIENTERRORED,GetUserName(),error.GetBuffer());
d668 3
a670 2
	//v- eklmn: bugfix(13): memleak in UploadClient due CFile (based on 0.29a)
	catch(CFileException* error){
d672 2
a673 2
		AddDebugLogLine(false,_T("Failed to create upload package for %s - %s"),GetUserName(),GetErrorMessage(error));
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_FILE_ERROR);
d679 2
a680 2
	//^- eklmn: bugfix(13): memleak in UploadClient due CFile (based on 0.29a)
	//	AddDebugLogLine(false,"Debug: Packet done. Size: %i",blockpack->GetLength());
d682 1
a682 1
	
d687 2
a688 1
void CUpDownClient::CheckForUpPartsInfo(){
d690 8
a697 8
    if(m_uPartCount==0)
        return;
    if(!m_pReqPartFile)
        return;
    if(memcmp(m_reqFileHash,m_pReqPartFile->GetFileHash(),16))
        return;
    if(!m_pbytePartStatuses)
        return;
d699 2
a700 1
    if (m_pbyteUpPartStatuses) {
d703 1
a703 1
    }
d705 8
a712 7
    m_uAvailUpPartCount = 0;
    m_pbyteUpPartStatuses = new uint8[m_uUpPartCount];
    for(int i=0; i<m_uUpPartCount; i++) {
        m_pbyteUpPartStatuses[i] = m_pbytePartStatuses[i];
        if(m_pbyteUpPartStatuses[i]) 
            m_uAvailUpPartCount++;
    }
d716 3
a718 2
void CUpDownClient::ProcessUpFileStatus(char* packet,uint32 size){
    EMULE_TRY
d720 2
a721 1
    if (m_pbyteUpPartStatuses) {
d724 1
a724 1
    }
d726 5
a730 4
    m_uAvailUpPartCount = 0;
	m_uUpCompleteSourcesCount= 0;	// netwolf: complete sources (zegzav )
    if( size == 16 ) {
        CheckForUpPartsInfo(); // obaldin
d732 2
a733 2
    }
	CSafeMemFile data((BYTE*)packet,size);
d735 1
a735 1
	data.Read(cfilehash,16);
d737 3
a739 2
	data.Read(&m_uUpPartCount,2);
	if (!m_uUpPartCount){
d742 1
a742 1
		memset2(m_pbyteUpPartStatuses,0,m_uUpPartCount);
d744 4
a747 2
	else{
		if (tempreqfile->GetPartCount() != m_uUpPartCount){
d753 2
a754 1
		while (done != m_uUpPartCount){
d756 9
a764 8
			data.Read(&toread,1);
			for (sint32 i = 0;i != 8;i++){
				m_pbyteUpPartStatuses[done] = ((toread>>i)&1)? 1:0;
                if(m_pbyteUpPartStatuses[done])
                    m_uAvailUpPartCount++;
//				We may want to use this for another feature..
//				if (m_pbyteUpPartStatuses[done] && !tempreqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
//					bPartsNeeded = true;
d771 1
a771 1
		// netwolf: complete sources (zegzav ) - BEGIN
d775 1
a775 1
			data.Read(&nCount,2);
d778 1
a778 1
		// netwolf: complete sources (zegzav ) - END
d783 1
a783 1
    EMULE_CATCH
d787 1
a787 1
void CUpDownClient::CreateStandardPackets(byte* data,uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d791 3
a793 3
	CMemFile memfile((BYTE*)data,togo);
	if (togo > 10240) 
		nPacketSize = togo/(uint32)(togo/10240);
d796 3
a798 2
	while (togo){
		if (togo < nPacketSize*2)
d801 2
a802 2
		Packet* packet = new Packet(OP_SENDINGPART,nPacketSize+24,OP_EDONKEYPROT,bFromPF);	// -khaos: Create the packet with the new boolean.
		md4cpy(&packet->m_pcBuffer[0],m_reqFileHash);
d805 3
a807 3
		memcpy2(&packet->m_pcBuffer[16],&statpos,4);
		memcpy2(&packet->m_pcBuffer[20],&endpos,4);
		memfile.Read(&packet->m_pcBuffer[24],nPacketSize);
d809 1
a809 1
        	SplitAndAddPacketsToSendQueue(packet, bFromPF);
d814 2
a815 1
void CUpDownClient::CreatePackedPackets(byte* data,uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF){
d817 5
a821 4
	BYTE* output = new BYTE[togo+300];
	uLongf newsize = togo+300;
	uint16 result = compress2(output,&newsize,data,togo,9);
	if (result != Z_OK || togo <= newsize){
d823 1
a823 1
		CreateStandardPackets(data,togo,currentblock, bFromPF);		// -khaos: Create the packet with the new boolean.
d827 3
a829 3
	m_dwCompressionGain += (togo-newsize); // Add show compression
	m_dwUncompressed += togo;// Add show compression
	CMemFile memfile(output,newsize);
d832 2
a833 2
	if (togo > 10240) 
		nPacketSize = togo/(uint32)(togo/10240);
d836 3
a838 2
	while (togo){
		if (togo < nPacketSize*2)
d841 2
a842 2
		Packet* packet = new Packet(OP_COMPRESSEDPART,nPacketSize+24,OP_EMULEPROT, bFromPF);	// -khaos: Create the packet with the new boolean.
		md4cpy(&packet->m_pcBuffer[0],m_reqFileHash);
d844 3
a846 3
		memcpy2(&packet->m_pcBuffer[16],&statpos,4);
		memcpy2(&packet->m_pcBuffer[20],&newsize,4);
		memfile.Read(&packet->m_pcBuffer[24],nPacketSize);
d848 1
a848 1
        	SplitAndAddPacketsToSendQueue(packet, bFromPF);
d862 2
a863 2
	if (packet->GetRealPacketSize() > 0 && packet->GetRealPacketSize() > MAXFRAGSIZE*2) 
	// splitting packets
d868 1
a868 1
        	
d873 1
a873 1
			uint32 nNewSize = (nSize-nPos < MAXFRAGSIZE) ? nSize-nPos : MAXFRAGSIZE;
d875 1
a875 1
			memcpy2(pBuffer2,m_pcBuffer+nPos,nNewSize);
d877 1
a877 1
			m_blockSendQueue.AddTail(new Packet(pBuffer2,nNewSize,(nNewSize < MAXFRAGSIZE), bFromPF));
d881 2
a882 2
	} 
	else 
d886 1
a886 1
	
d890 2
a891 1
void CUpDownClient::SetUploadFileID(uchar* tempreqfileid){
d893 2
a894 2
	if(tempreqfileid)
		md4cpy(m_reqFileHash,tempreqfileid);
d896 1
a896 1
		for( int i = 0; i <16; i++)
d901 2
a902 1
void CUpDownClient::AddReqBlock(Requested_Block_Struct* reqblock){
d904 4
a907 2
	for (POSITION pos = m_doneBlocksList.GetHeadPosition();pos != 0;m_doneBlocksList.GetNext(pos)){
		if (reqblock->StartOffset == m_doneBlocksList.GetAt(pos)->StartOffset && reqblock->EndOffset == m_doneBlocksList.GetAt(pos)->EndOffset){
d912 4
a915 2
	for (POSITION pos = m_blockRequestsQueue.GetHeadPosition();pos != 0;m_blockRequestsQueue.GetNext(pos)){
		if (reqblock->StartOffset == m_blockRequestsQueue.GetAt(pos)->StartOffset && reqblock->EndOffset == m_blockRequestsQueue.GetAt(pos)->EndOffset){
d925 2
a926 1
void CUpDownClient::SetUpStartTime(uint32 dwTime){
d935 2
a936 1
void CUpDownClient::SetWaitStartTime(uint32 dwTime){
d948 11
a958 10
    DWORD curTick = GetTickCount();
    // this will be set to true if/when the slot is actually fed some data
    wantsMoreBandwidth = false;
    uint32 amounttransferred = 0;

    // check for 'stuck' clients
    //	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
    if ((curTick-GetLastGotULData() > 2*60*1000)  && (GetUpStartTimeDelay()>2*60*1000)) {
		// were unable to transfer for 2 minutes, put the client back on queue
		AddDebugLogLine(false, _T("Client %s(%s) appears to be stuck, putting back on queue"), GetUserName(), GetClientNameAndVersionString(this)); 
d960 2
a961 2
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_TIMEOUT);
		g_eMuleApp.m_pUploadQueue->AddClientToQueue(this,true);
d966 6
a971 14
	// Only feed this slot new data if it has been able to empty its
	// buffer since we last offered it data
	if (m_pRequestSocket && !m_pRequestSocket->IsBusy() && GetUploadState() == US_UPLOADING) {
		// v- eklmn: bugfix(03): keeping user in queue if he doesn't need anything (v2)
		if (m_blockSendQueue.IsEmpty()) {	
			 // no valid blocks to transfer. Put the client back on queue
			if ( !CreateNextBlockPackage())  return 0;
		}
		// ^- eklmn: bugfix(03): keeping user in queue if he doesn't need anything (v2)
		
		// Feed data to this slot, one block at a time, as long as there's
		// enough bandwidth left for the entire next block.
		// There must also be blocks to send (not empty request queue)
		while (!m_blockSendQueue.IsEmpty() && m_blockSendQueue.GetHead()->GetRealPacketSize()+amounttransferred <= nMaxAmmount) 
d973 13
a985 2
			// Get next block and give it to the m_pRequestSocket for transfer
			Packet* tosend = m_blockSendQueue.RemoveHead();
d987 7
a993 7
			// -khaos--+++>
			// Extended statistics information based on which client software and which port we sent this data to...
			// This also updates the grand total for sent bytes, etc.  And where this data came from.  Yeesh.
			// eklmnf: we have to call function before packet will sended, otherwise packet will be deleted & we have Access violation
			g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), tosend->IsFromPF(), Upload, nBlockSize);
			//g_eMuleApp.UpdateSentBytes(nBlockSize); 
			m_pRequestSocket->SendPacket(tosend,true,false);
d995 1
a995 1
			//m_pRequestSocket->ResetTimeOutTimer();
d997 1
a997 1
			// We've transferred some data. Store this in relevant statistics variables
d1000 2
a1001 2
//			g_eMuleApp.m_pUploadQueue->AddUpDataRateMSOverhead(24, 160);
			m_pCredits->AddUploaded(nBlockSize,this->GetIP());
d1003 3
a1005 2
			// If we're out of prepared blocks, create some more
			if (m_blockSendQueue.IsEmpty()) CreateNextBlockPackage();
d1008 2
a1009 2
		// If this slot wasn't given enough data to empty it's request queue, 
		// it wants more data.
d1011 2
a1012 1
		if(!m_blockSendQueue.IsEmpty()) {
d1016 4
a1019 3
		// Remember when this connection was last fed some data, so we
		// can make sure we give it data often enough to not time out.
		if(amounttransferred > 0) {
d1025 2
a1026 2
	// Store how much data we've transferred this round,
	// to be able to calculate average speed later
d1030 3
a1032 3
	// Don't store more than 40 seconds of statistics
	//while(curTick-m_averageULTickList.back() > 40000) {
	while(m_averageULTickList.size() > 500) 
d1034 1
a1034 1
   		m_averageUDRList.pop_back();
d1038 9
a1046 9
	//eklmn: since performance is more importatnt, that graphical output this function moved to the end
	// Check if it's time to update the display.
	if (curTick-m_dwLastRefreshedULDisplayTime > MINWAIT_BEFORE_ULDISPLAY_WINDOWUPDATE && m_averageUDRList.size() >= 2) 
	{
		// Calculate average data rate
		// Present this slot's speed as 0 unless there's a good chunk
		// of stored statistics for it. If there's to little data, the
		// UL speed will be far off, so we might as well hide it in those cases.
		uint32 timePeriod = m_averageULTickList.front()-m_averageULTickList.back();
d1048 1
a1048 1
			m_lUpDataRate = (uint32)(((float)(m_averageUDRList.front()-m_averageUDRList.back()))*1000 / timePeriod);
d1053 1
a1053 1
		m_dwLastRefreshedULDisplayTime = curTick+(uint32)(rand()/(RAND_MAX/1000));	//SyruS moved rand out of if(...)
d1057 1
a1057 1
	
d1062 2
a1063 1
void CUpDownClient::FlushSendBlocks(){ // call this when you stop upload, or the m_pRequestSocket might be not able to send
d1067 4
a1070 2
	while (!m_blockSendQueue.IsEmpty() && m_blockSendQueue.GetHead()->IsSplit() && m_pRequestSocket && m_pRequestSocket->IsConnected() && !bBreak ){	
		Packet* tosend = m_blockSendQueue.RemoveHead();
d1073 1
a1073 1
		m_pRequestSocket->SendPacket(tosend,true,false);
d1079 2
a1080 1
void CUpDownClient::SendHashsetPacket(char* forfileid){
d1082 1
a1082 1
	CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)forfileid);
d1085 1
a1085 1
		AddDebugLogLine(false, GetResString(IDS_ERR_REQ_FNF)+CString(" (SendHashsetPacket)"));
d1090 1
a1090 1
	data.Write(file->GetFileHash(),16);
d1092 1
a1092 1
	data.Write(&parts,2);
d1094 1
a1094 1
		data.Write(file->GetPartHash(i),16);
d1099 2
a1100 1
	m_pRequestSocket->SendPacket(packet,true,true);
d1102 1
d1109 6
a1114 5
	// Calculates the session speed of the client
	// Providing the other Clients with this info
	// gives then the possibility to select the 
	// sources more intelligently
	if (g_eMuleApp.stat_transferStarttime==0) return 0;
d1116 3
a1118 2
	DWORD running=(GetTickCount()-g_eMuleApp.stat_transferStarttime)/1000;
	if (running<5) return 0;
d1120 1
a1120 1
	return (float)(g_eMuleApp.stat_sessionSentBytes/1024) / running;
d1125 2
a1126 1
void CUpDownClient::ClearUploadBlockRequests(){
d1132 1
a1132 1
	
d1136 1
a1136 1
	
d1143 2
a1144 1
void CUpDownClient::SendRankingInfo(){
d1149 1
a1149 1
    // By Maverick
d1151 9
a1159 9
    #define DISABLE_EXTENDED_INFO_EXCHANGE
    // The extended info exchange is currently disabled since it is possible
    // to ask the client with several userhashes for the file and then use 
    // the one with the best UL/DL ratio
    // It is planned to reactivate this feature, but with a protection against
    // this userhash spoofing.
    // At the last stage this faeture should make it possible to choose the 
    // sources more intelligently by taking UL/DL ratio, queuerank and 
    // speed of the other client into account.
d1163 1
d1167 4
a1170 3
	uint16 nBaseModifier = (uint16) GetScore(false,false,true); //16-Bits are enough for base value
	uint32 nScore = GetScore(false,false,false);
	
d1176 1
a1176 1
	
d1179 2
a1180 1
	if(m_pCredits != (CClientCredits*)NULL) { 
d1182 1
a1182 1
	} 
d1184 1
a1184 1
	uint16 nRatio = (uint16)fBaseValue; 
d1186 8
a1193 7
	uint16 nClientSpeed = (uint16)((GetClientSpeed() < 65535) ? GetClientSpeed() : 65535); 
										// Providing the other clients with this info 
										// can not be used to leech

	Packet* packet = new Packet(OP_QUEUERANKING,12,OP_EMULEPROT);
	memset2(packet->m_pcBuffer,0,12);
	memcpy2(packet->m_pcBuffer+0,&nRank,2);
d1195 5
a1199 4
	memcpy2(packet->m_pcBuffer+2,&nBaseModifier,1);		// UINT8 is enough 0-100
	memcpy2(packet->m_pcBuffer+3,&nRatio,2);			// UINT16 needed saw about 32000 max (SF * UL/DL * RF) 
	memcpy2(packet->m_pcBuffer+5,&nScore,4);			// UINT32 needed
	memcpy2(packet->m_pcBuffer+9,&nCommunity,1);		// 2-Bits needed
d1201 3
a1203 2
	memcpy2(packet->m_pcBuffer+10,&nClientSpeed,2);		// UINT16 (I think not many have more than 65 MByte UL)
	// END Maverick
d1206 2
a1207 1
	m_pRequestSocket->SendPacket(packet,true,true);
d1209 1
d1213 2
a1214 1
void CUpDownClient::SendCommentInfo(CKnownFile *file) {
d1220 3
a1222 3
	EnumPartFileRating rating=file->GetFileRating();
	CString desc=file->GetFileComment();
	if(file->GetFileRating() == PF_RATING_NONE && desc.IsEmpty())
d1226 8
a1233 8
	data.Write(&rating,sizeof(rating));
	int length=desc.GetLength();
	if (length>128) 
		length=128;
	data.Write(&length,sizeof(length));
	if (length>0) 
		data.Write(desc.GetBuffer(),length);
	Packet *packet = new Packet(&data,OP_EMULEPROT);
d1237 2
a1238 1
	m_pRequestSocket->SendPacket(packet,true);
d1240 1
d1244 2
a1245 1
void  CUpDownClient::AddRequestCount(uchar* fileid){
d1247 7
a1253 4
	for (POSITION pos = m_requestedFilesList.GetHeadPosition();pos != 0;m_requestedFilesList.GetNext(pos)){
		Requested_File_Struct* cur_struct = m_requestedFilesList.GetAt(pos);
		if (!md4cmp(cur_struct->fileid,fileid)){
			if (::GetTickCount() - cur_struct->lastasked < MIN_REQUESTTIME){
d1259 2
a1260 1
			else{
d1269 2
a1270 2
	memset2(new_struct,0,sizeof(Requested_File_Struct));
	md4cpy(new_struct->fileid,fileid);
d1276 2
a1277 1
void  CUpDownClient::UnBan(){
d1284 1
a1284 1
	//--- xrmb:hashthieves1 ---
d1287 5
a1291 4
	m_bIsHashThief=false;
	//--- :xrmb ---
	for (POSITION pos = m_requestedFilesList.GetHeadPosition();pos != 0;m_requestedFilesList.GetNext(pos)){
		Requested_File_Struct* cur_struct = m_requestedFilesList.GetAt(pos);
d1293 1
a1293 1
		cur_struct->lastasked = 0;	
d1299 2
a1300 1
void CUpDownClient::Ban(LPCTSTR line, const CString& reason, ...){ //katsyonak 16.06.03
d1303 1
a1303 1
 	if (!g_eMuleApp.m_pGlobPrefs->BanEnabled())
d1311 1
a1311 1
		AddDebugLogLine(false,_T("Client '%s' banned and kicked out of m_pUploadQueue %s"), GetUserName(), reason);
d1317 1
a1317 1
		AddDebugLogLine(false,_T("Client '%s' is already banned from the m_pUploadQueue %s"), GetUserName(), reason);
d1321 1
a1321 1
	if(g_eMuleApp.m_pGlobPrefs->CommunityNoBanEnabled() && g_eMuleApp.m_pGlobPrefs->CommunityEnabled() && IsCommunity())
d1327 1
a1327 1
	if(g_eMuleApp.m_pGlobPrefs->IsBanMessageEnabled())
d1344 2
a1345 1
void CUpDownClient::UDPFileReasked(){
d1351 2
a1352 2
	Packet* response = new Packet(OP_REASKACK,2,OP_EMULEPROT);
	memcpy2(response->m_pcBuffer,&nRank,2);
d1354 1
a1354 1
	// By Maverick
d1356 2
a1357 1
	if (!proxy.m_bUseProxy){
d1360 2
a1361 1
		g_eMuleApp.m_pClientUDPSocket->SendPacket(response,GetIP(),GetUDPPort());
d1363 1
d1368 3
a1370 3
// Lord KiRon
CString CUpDownClient::GetDownloadStateAsString(void) 
{ 
d1372 3
a1374 3
} 
// Lord KiRon - end
// By Maverick
d1378 2
a1379 1
	if (IsRemoteInfoAvaiable()) return m_dwRemoteScore;
d1382 1
a1382 1
				// Furhtermore the we do not know the remote ratio.
d1388 6
a1393 5
	if (IsRemoteInfoAvaiable()) return m_uRemoteRatio;
	// This calculation is not very accurate for several reasons:
	// - We do not know the file priority
	// - We do not save the client info if he has nothing uploaded to us
	// - Other factores like community etc
d1404 1
a1404 1
	//if (bIsBotuser) fBaseValue *= 0.9f;	//Cax2 - not anymore
d1406 3
a1408 1
	if (g_eMuleApp.m_pServerConnect->IsLowID()) fBaseValue *= 0.8f;
d1410 5
a1414 2
	if (GetDownloadState() == DS_DOWNLOADING) fBaseValue *= 1.5f;
	if (IsFriend()) fBaseValue *= 2.0f;
d1420 1
a1420 1
	return (uint32)fBaseValue;
d1428 7
a1434 6
	if (IsRemoteInfoAvaiable()) return (float)m_uRemoteBaseModifier / 100.0;
	// This calculation is not very accurate for some reasons:
	// - Crashes can cause that either client can not write
	//   its client data. This can cause differences of the
	//   client data at the two clients.
	if(m_pCredits == (CClientCredits*)-1)
d1436 2
a1437 2
	if(m_pCredits != NULL)
		return m_pCredits->GetScoreRatio(this->GetIP(),true);
d1441 17
a1458 9
uint32 CUpDownClient::GetCurrentlyUploadingPart() {
	EMULE_TRY
    if(!m_doneBlocksList.IsEmpty()) { // do we need to check upload state here?
        Requested_Block_Struct* done_block = (Requested_Block_Struct*)m_doneBlocksList.GetHead();
        uint32 partno = done_block->StartOffset / PARTSIZE;
        return partno;
    }
    else
        return 0xFFFF;
d1460 2
a1461 1
    return 0xFFFF;
d1463 1
a1463 1

@


1.137
log
@no message
@
text
@d46 1
a46 1
	uint32 filesize =(m_nUpPartCount) ? PARTSIZE*(m_nUpPartCount):1; // might be a little off.. better than nothing
d52 1
a52 1
	if (filesize !=1 && !onlygreyrect && m_abyUpPartStatus)	//Cax2 - no more black rectangle
d54 1
a54 1
		for (uint32 i = 0;i != m_nUpPartCount;i++)
d64 1
a64 1
			if (m_abyUpPartStatus[i]){ //they have this part
a78 1
// [i_a]
d83 1
a83 1
	if (!community_cached)
d87 1
a87 1
		CString username(m_pszUsername);
d93 2
a94 2
		iscommunity = (username.Find(communityok) >= 0);
		community_cached = true;
d96 1
a96 1
	return iscommunity;
d105 2
a106 2
    score_base_cached = false;
    community_cached = false;
a108 1
// [/i_a]
d116 1
a116 1
	if (m_pszUsername.IsEmpty())
d127 1
a127 1
				if (!m_modVerString.IsEmpty())
d151 1
a151 1
	CKnownFile* req_file = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
a153 8
		// TODO coded by tecxx & herbert, one yet unsolved problem here:
		// sometimes a client asks for 2 files and there is no way to decide, which file the 
		// client finally gets. so it could happen that he is queued first because of a 
		// high prio file, but then asks for something completely different.
		
		// isfriend = 	g_eMuleApp.m_pdlgEmule->m_wndChat.IsFriend(CString(m_pszUsername));
		// isemuleclient = false; // i_a: unused

d156 1
a156 1
        ASSERT(reqfileid != NULL); // i_a: reqfileid is an array so the if() was superfluous 
d162 1
a162 1
					filepriority = 50;
d164 1
a164 1
					filepriority = 100;
d168 1
a168 1
				filepriority = 20;
d172 1
a172 1
				filepriority = 5;
d176 1
a176 1
				filepriority = 2;
d181 1
a181 1
				filepriority = 10;	// standard
d212 2
a213 2
	//ASSERT(credits != NULL); 
	if(credits != (CClientCredits*)NULL)
d215 1
a215 1
		fBaseValue *= credits->GetScoreRatio(this->GetIP());
d222 1
a222 1
	fBaseValue *= ((float)(filepriority))/10.0f; 
d236 1
a236 1
	CKnownFile* srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)reqfileid);
d264 1
a264 1
		if (!m_BlockRequests_queue.IsEmpty() && !m_DoneBlocks_list.IsEmpty())
d267 2
a268 2
			last_done_block = (Requested_Block_Struct*)m_DoneBlocks_list.GetHead();
			next_requested_block = (Requested_Block_Struct*)m_BlockRequests_queue.GetHead(); 
d321 1
a321 1
	if(m_BlockRequests_queue.IsEmpty()) {
d325 1
a325 1
		next_requested_block = (Requested_Block_Struct*)m_BlockRequests_queue.GetHead();
d344 1
a344 1
	CKnownFile* srcfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)reqfileid);
d393 1
a393 1
	bool AllowedMore = isOnLAN();	
d439 1
a439 1
	if (m_BlockRequests_queue.IsEmpty()) {
d458 1
a458 1
		while (!m_BlockRequests_queue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()) && !IsForbiddenByJumpstart() )
d460 1
a460 1
		while (!m_BlockRequests_queue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()) )		//Cax2 - if a friend or lancast user, keep going!
d463 1
a463 1
			Requested_Block_Struct* currentblock = m_BlockRequests_queue.GetHead();
d595 1
a595 1
			md4cpy(reqfileid,currentblock->FileID);
d598 1
a598 1
			if (m_byDataCompVer == 1 && ext != _T(".zip") && ext != _T(".rar") && ext != _T(".ace"))
d619 1
a619 1
			m_DoneBlocks_list.AddHead(m_BlockRequests_queue.RemoveHead());
d651 1
a651 1
    if(m_nPartCount==0)
d653 1
a653 1
    if(!reqfile)
d655 1
a655 1
    if(memcmp(reqfileid,reqfile->GetFileHash(),16))
d657 1
a657 1
    if(!m_abyPartStatus)
d660 3
a662 3
    if (m_abyUpPartStatus) {
		delete[] m_abyUpPartStatus;
		m_abyUpPartStatus = NULL;
d664 7
a670 7
	m_nUpPartCount = m_nPartCount;
    m_nAvailUpPartCount = 0;
    m_abyUpPartStatus = new uint8[m_nUpPartCount];
    for(int i=0; i<m_nUpPartCount; i++) {
        m_abyUpPartStatus[i] = m_abyPartStatus[i];
        if(m_abyUpPartStatus[i]) 
            m_nAvailUpPartCount++;
d678 3
a680 3
    if (m_abyUpPartStatus) {
		delete[] m_abyUpPartStatus;
		m_abyUpPartStatus = NULL;	// added by jicxicmic
d682 3
a684 3
	m_nUpPartCount = 0;
    m_nAvailUpPartCount = 0;
	m_nUpCompleteSourcesCount= 0;	// netwolf: complete sources (zegzav )
d693 5
a697 5
	data.Read(&m_nUpPartCount,2);
	if (!m_nUpPartCount){
		m_nUpPartCount = tempreqfile->GetPartCount();
		m_abyUpPartStatus = new uint8[m_nUpPartCount];
		memset2(m_abyUpPartStatus,0,m_nUpPartCount);
d700 2
a701 2
		if (tempreqfile->GetPartCount() != m_nUpPartCount){
			m_nUpPartCount = 0;
d704 1
a704 1
		m_abyUpPartStatus = new uint8[m_nUpPartCount];
d706 1
a706 1
		while (done != m_nUpPartCount){
d710 3
a712 3
				m_abyUpPartStatus[done] = ((toread>>i)&1)? 1:0;
                if(m_abyUpPartStatus[done])
                    m_nAvailUpPartCount++;
d714 1
a714 1
//				if (m_abyUpPartStatus[done] && !tempreqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
d717 1
a717 1
				if (done == m_nUpPartCount)
d723 1
a723 1
		if ((GetExtendedRequestsVersion() > 1) && (size >= 20 + (((uint32)m_nUpPartCount + 7) >> 3)))
d752 1
a752 1
		md4cpy(&packet->m_pcBuffer[0],reqfileid);
d759 1
a759 1
        	splitAndAddPacketsToSendQueue(packet, bFromPF);
d774 3
a776 3
	m_bUsedComprUp = true;
	compressiongain += (togo-newsize); // Add show compression
	notcompressed += togo;// Add show compression
d789 1
a789 1
		md4cpy(&packet->m_pcBuffer[0],reqfileid);
d795 1
a795 1
        	splitAndAddPacketsToSendQueue(packet, bFromPF);
d805 1
a805 1
void CUpDownClient::splitAndAddPacketsToSendQueue(Packet* packet, bool bFromPF)
d824 1
a824 1
			m_BlockSend_queue.AddTail(new Packet(pBuffer2,nNewSize,(nNewSize < MAXFRAGSIZE), bFromPF));
d831 1
a831 1
		m_BlockSend_queue.AddTail(packet);
d840 1
a840 1
		md4cpy(reqfileid,tempreqfileid);
d843 1
a843 1
			reqfileid[i] = 0;
d849 2
a850 2
	for (POSITION pos = m_DoneBlocks_list.GetHeadPosition();pos != 0;m_DoneBlocks_list.GetNext(pos)){
		if (reqblock->StartOffset == m_DoneBlocks_list.GetAt(pos)->StartOffset && reqblock->EndOffset == m_DoneBlocks_list.GetAt(pos)->EndOffset){
d855 2
a856 2
	for (POSITION pos = m_BlockRequests_queue.GetHeadPosition();pos != 0;m_BlockRequests_queue.GetNext(pos)){
		if (reqblock->StartOffset == m_BlockRequests_queue.GetAt(pos)->StartOffset && reqblock->EndOffset == m_BlockRequests_queue.GetAt(pos)->EndOffset){
d861 1
a861 1
	m_BlockRequests_queue.AddTail(reqblock);
d908 1
a908 1
		if (m_BlockSend_queue.IsEmpty()) {	
d917 1
a917 1
		while (!m_BlockSend_queue.IsEmpty() && m_BlockSend_queue.GetHead()->GetRealPacketSize()+amounttransferred <= nMaxAmmount) 
d920 1
a920 1
			Packet* tosend = m_BlockSend_queue.RemoveHead();
d933 1
a933 1
			m_nTransferredUp += nBlockSize;
d936 1
a936 1
			credits->AddUploaded(nBlockSize,this->GetIP());
d939 1
a939 1
			if (m_BlockSend_queue.IsEmpty()) CreateNextBlockPackage();
d945 1
a945 1
		if(!m_BlockSend_queue.IsEmpty()) {
d959 2
a960 2
	m_AverageUDR_list.push_front(m_nTransferredUp);
	m_Average_UL_tick_list.push_front(curTick);
d963 2
a964 2
	//while(curTick-m_Average_UL_tick_list.back() > 40000) {
	while(m_Average_UL_tick_list.size() > 500) 
d966 2
a967 2
   		m_AverageUDR_list.pop_back();
		m_Average_UL_tick_list.pop_back();
d972 1
a972 1
	if (curTick-m_lastRefreshedULDisplay > MINWAIT_BEFORE_ULDISPLAY_WINDOWUPDATE && m_AverageUDR_list.size() >= 2) 
d978 1
a978 1
		uint32 timePeriod = m_Average_UL_tick_list.front()-m_Average_UL_tick_list.back();
d980 1
a980 1
			m_nUpDataRate = (uint32)(((float)(m_AverageUDR_list.front()-m_AverageUDR_list.back()))*1000 / timePeriod);
d982 1
a982 1
			m_nUpDataRate = -1;
d985 1
a985 1
		m_lastRefreshedULDisplay = curTick+(uint32)(rand()/(RAND_MAX/1000));	//SyruS moved rand out of if(...)
d998 2
a999 2
	while (!m_BlockSend_queue.IsEmpty() && m_BlockSend_queue.GetHead()->IsSplit() && m_pRequestSocket && m_pRequestSocket->IsConnected() && !bBreak ){	
		Packet* tosend = m_BlockSend_queue.RemoveHead();
d1052 3
a1054 3
	for (POSITION pos = m_BlockRequests_queue.GetHeadPosition();pos != 0;m_BlockRequests_queue.GetNext(pos))
		delete m_BlockRequests_queue.GetAt(pos);
	m_BlockRequests_queue.RemoveAll();
d1056 3
a1058 3
	for (POSITION pos = m_DoneBlocks_list.GetHeadPosition();pos != 0;m_DoneBlocks_list.GetNext(pos))
		delete m_DoneBlocks_list.GetAt(pos);
	m_DoneBlocks_list.RemoveAll();
d1060 3
a1062 3
	for (POSITION pos = m_BlockSend_queue.GetHeadPosition();pos != 0;m_BlockSend_queue.GetNext(pos))
		delete m_BlockSend_queue.GetAt(pos);
	m_BlockSend_queue.RemoveAll();
d1099 2
a1100 2
	if(credits != (CClientCredits*)NULL) { 
		fBaseValue *= credits->GetScoreRatio(this->GetIP());
d1129 1
a1129 1
	if (!m_bCommentDirty || file == NULL || !ExtProtocolAvailable() || m_byAcceptCommentVer < 1)
d1157 2
a1158 2
	for (POSITION pos = m_RequestedFiles_list.GetHeadPosition();pos != 0;m_RequestedFiles_list.GetNext(pos)){
		Requested_File_Struct* cur_struct = m_RequestedFiles_list.GetAt(pos);
d1178 1
a1178 1
	m_RequestedFiles_list.AddHead(new_struct);
d1190 3
a1192 3
	offensecounter.RemoveKey(getUID());
	hashbase.RemoveKey(getUID());
	hashthief=false;
d1194 2
a1195 2
	for (POSITION pos = m_RequestedFiles_list.GetHeadPosition();pos != 0;m_RequestedFiles_list.GetNext(pos)){
		Requested_File_Struct* cur_struct = m_RequestedFiles_list.GetAt(pos);
d1277 1
a1277 1
	if (IsRemoteInfoAvaiable()) return m_RemoteScore;
d1286 1
a1286 1
	if (IsRemoteInfoAvaiable()) return m_RemoteRatio;
d1320 1
a1320 1
	if (IsRemoteInfoAvaiable()) return (float)m_RemoteBaseModifier / 100.0;
d1325 4
a1328 4
	if(credits == (CClientCredits*)-1)
		credits = NULL;
	if(credits != NULL)
		return credits->GetScoreRatio(this->GetIP(),true);
d1335 2
a1336 2
    if(!m_DoneBlocks_list.IsEmpty()) { // do we need to check upload state here?
        Requested_Block_Struct* done_block = (Requested_Block_Struct*)m_DoneBlocks_list.GetHead();
@


1.136
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d145 1
a145 1
		if (HasLowID() && !(socket && socket->IsConnected()))
d916 1
a916 1
	if (socket && !socket->IsBusy() && GetUploadState() == US_UPLOADING) {
d929 1
a929 1
			// Get next block and give it to the socket for transfer
d938 1
a938 1
			socket->SendPacket(tosend,true,false);
d940 1
a940 1
			//socket->ResetTimeOutTimer();
d1004 1
a1004 1
void CUpDownClient::FlushSendBlocks(){ // call this when you stop upload, or the socket might be not able to send
d1008 1
a1008 1
	while (!m_BlockSend_queue.IsEmpty() && m_BlockSend_queue.GetHead()->IsSplit() && socket && socket->IsConnected() && !bBreak ){	
d1012 1
a1012 1
		socket->SendPacket(tosend,true,false);
d1037 1
a1037 1
	socket->SendPacket(packet,true,true);
d1132 1
a1132 1
	socket->SendPacket(packet,true,true);
d1160 1
a1160 1
	socket->SendPacket(packet,true);
d1222 1
a1222 1
	if (m_byUploadState == US_UPLOADING)
d1358 1
a1358 1
	m_byUploadState = news;
@


1.135
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d742 1
a742 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(this);
d994 1
a994 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndUploadList.RefreshClient(this);
d1209 1
a1209 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(this);
d1252 1
a1252 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(this);
d1359 1
a1359 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(this);
@


1.134
log
@Formatting, comments, and name changes.
@
text
@d707 1
a707 1
		memset(m_abyUpPartStatus,0,m_nUpPartCount);
d1120 1
a1120 1
	memset(packet->m_pcBuffer,0,12);
d1185 1
a1185 1
	memset(new_struct,0,sizeof(Requested_File_Struct));
@


1.133
log
@Formatting, comments, and name changes.
@
text
@d1143 1
a1143 1
	int8 rating=file->GetFileRate();
d1145 1
a1145 1
	if(file->GetFileRate() == 0 && desc.IsEmpty())
@


1.132
log
@measurement period was reduced to improve speed estimation
@
text
@d615 1
a615 1
			srcfile->statistic.AddTransferd(togo);
@


1.131
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d974 1
a974 1
	while(m_Average_UL_tick_list.size() > 1000) 
@


1.130
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d26 1
a26 1
#include "memcpy_amd.h"
@


1.129
log
@Formatting, comments, and name changes.
@
text
@d762 1
a762 1
		md4cpy(&packet->pBuffer[0],reqfileid);
d765 3
a767 3
		memcpy2(&packet->pBuffer[16],&statpos,4);
		memcpy2(&packet->pBuffer[20],&endpos,4);
		memfile.Read(&packet->pBuffer[24],nPacketSize);
d799 1
a799 1
		md4cpy(&packet->pBuffer[0],reqfileid);
d801 3
a803 3
		memcpy2(&packet->pBuffer[16],&statpos,4);
		memcpy2(&packet->pBuffer[20],&newsize,4);
		memfile.Read(&packet->pBuffer[24],nPacketSize);
d823 1
a823 1
		char* pBuffer = packet->DetachPacket();
d832 1
a832 1
			memcpy2(pBuffer2,pBuffer+nPos,nNewSize);
d837 1
a837 1
		delete[] pBuffer;
d1008 1
a1008 1
	while (!m_BlockSend_queue.IsEmpty() && m_BlockSend_queue.GetHead()->IsSplitted() && socket && socket->IsConnected() && !bBreak ){	
d1010 2
a1011 2
		bool bBreak = tosend->IsLastSplitted();
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(tosend->size);
d1034 2
a1035 2
	packet->opcode = OP_HASHSETANSWER;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d1120 2
a1121 2
	memset(packet->pBuffer,0,12);
	memcpy2(packet->pBuffer+0,&nRank,2);
d1123 4
a1126 4
	memcpy2(packet->pBuffer+2,&nBaseModifier,1);		// UINT8 is enough 0-100
	memcpy2(packet->pBuffer+3,&nRatio,2);			// UINT16 needed saw about 32000 max (SF * UL/DL * RF) 
	memcpy2(packet->pBuffer+5,&nScore,4);			// UINT32 needed
	memcpy2(packet->pBuffer+9,&nCommunity,1);		// 2-Bits needed
d1128 1
a1128 1
	memcpy2(packet->pBuffer+10,&nClientSpeed,2);		// UINT16 (I think not many have more than 65 MByte UL)
d1130 1
a1130 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d1157 2
a1158 2
	packet->opcode = OP_FILEDESC;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d1264 1
a1264 1
	memcpy2(response->pBuffer,&nRank,2);
d1269 1
a1269 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(response->size);
@


1.128
log
@(0.30b) setting lockFile.m_pObject = NULL after unlocking completionmutex when creating next packet from file
@
text
@d1268 1
a1268 1
	if (!proxy.UseProxy){
@


1.127
log
@Temporary debug log spam control. I believe the moved code in GetScore() should be returned to its original position.
@
text
@d600 4
a603 1
				lockFile.m_pObject->Unlock(); //SyruS (0.29c) Unlock the (part) file as soon as we are done with accessing it.
@


1.126
log
@Formatting, comments, and name changes.
@
text
@d114 2
d127 11
a137 6
			if (!m_modVerString.IsEmpty())
				AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) using the mod %s has been banned"),GetUserName(),GetClientNameAndVersionString(this),GetModVersion());
			else 
				AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) has been banned"),GetUserName(),GetClientNameAndVersionString(this));
			//katsyonak: Send leecher ban message 15.06.03
			Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_LEECHERADV));
@


1.125
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d974 1
a974 1
		// Calculate average dataRate
@


1.124
log
@IsCommunity function was a bit rewritten in order to use a same class
@
text
@d1346 5
@


1.123
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d88 2
a89 2
		CString username = m_pszUsername;
		CString community = g_eMuleApp.m_pGlobPrefs->CommunityString();
d92 1
a92 1
		//community.Remove('['); community.Remove(']');
a95 4

		communityok.Empty();
		community.Empty();
		username.Empty();
@


1.122
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@a598 1
			#ifndef AMD
a599 3
			#else
			memcpy_amd(reqfileid,currentblock->FileID,16);
			#endif
d759 2
a760 7
		#ifndef AMD
		memcpy(&packet->pBuffer[16],&statpos,4);
		memcpy(&packet->pBuffer[20],&endpos,4);
		#else
		memcpy_amd(&packet->pBuffer[16],&statpos,4);
		memcpy_amd(&packet->pBuffer[20],&endpos,4);
		#endif
d795 2
a796 7
		#ifndef AMD
		memcpy(&packet->pBuffer[16],&statpos,4);
		memcpy(&packet->pBuffer[20],&newsize,4);
		#else
		memcpy_amd(&packet->pBuffer[16],&statpos,4);
		memcpy_amd(&packet->pBuffer[20],&newsize,4);
		#endif
d826 1
a826 5
			#ifndef AMD
			memcpy(pBuffer2,pBuffer+nPos,nNewSize);
			#else
			memcpy_amd(pBuffer2,pBuffer+nPos,nNewSize);
			#endif
d1115 1
a1115 2
	#ifndef AMD
	memcpy(packet->pBuffer+0,&nRank,2);
d1117 4
a1120 4
	memcpy(packet->pBuffer+2,&nBaseModifier,1);		// UINT8 is enough 0-100
	memcpy(packet->pBuffer+3,&nRatio,2);			// UINT16 needed saw about 32000 max (SF * UL/DL * RF) 
	memcpy(packet->pBuffer+5,&nScore,4);			// UINT32 needed
	memcpy(packet->pBuffer+9,&nCommunity,1);		// 2-Bits needed
d1122 1
a1122 11
	memcpy(packet->pBuffer+10,&nClientSpeed,2);		// UINT16 (I think not many have more than 65 MByte UL)
	#else
	memcpy_amd(packet->pBuffer+0,&nRank,2);
#ifndef DISABLE_EXTENDED_INFO_EXCHANGE
	memcpy_amd(packet->pBuffer+2,&nBaseModifier,1);		// UINT8 is enough 0-100
	memcpy_amd(packet->pBuffer+3,&nRatio,2);			// UINT16 needed saw about 32000 max (SF * UL/DL * RF) 
	memcpy_amd(packet->pBuffer+5,&nScore,4);			// UINT32 needed
	memcpy_amd(packet->pBuffer+9,&nCommunity,1);		// 2-Bits needed
#endif
	memcpy_amd(packet->pBuffer+10,&nClientSpeed,2);		// UINT16 (I think not many have more than 65 MByte UL)
	#endif
d1258 1
a1258 5
	#ifndef AMD
	memcpy(response->pBuffer,&nRank,2);
	#else
	memcpy(response->pBuffer,&nRank,2);
	#endif
@


1.121
log
@Second batch of name changes
@
text
@d24 1
a24 1
#include "uploadqueue.h"
d89 1
a89 1
		CString community = theApp.glob_prefs->CommunityString();
d127 1
a127 1
		if (IsStolenName() || IsLeecherType() /*&& theApp.glob_prefs->GetMlDonkeyCM()*/)
d144 1
a144 1
			if (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID())
d150 1
a150 1
	CKnownFile* req_file = theApp.sharedfiles->GetFileByID(reqfileid);
d158 1
a158 1
		// isfriend = 	theApp.emuledlg->chatwnd.IsFriend(CString(m_pszUsername));
d215 1
a215 1
	if (theApp.glob_prefs->CommunityEnabled() && IsCommunity())		
d241 1
a241 1
	//if(!theApp.glob_prefs->FairShareRarePush())
d243 1
a243 1
	CKnownFile* srcfile = theApp.sharedfiles->GetFileByID((uchar*)reqfileid);
d334 1
a334 1
		CKnownFile* kf = theApp.sharedfiles->GetFileByID(next_requested_block->FileID);
d349 1
a349 1
	//if(!theApp.glob_prefs->FairShareRarePush())
d351 1
a351 1
	CKnownFile* srcfile = theApp.sharedfiles->GetFileByID((uchar*)reqfileid);
d412 1
a412 1
		if (IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this) && !JS_blocked)
d414 1
a414 1
		if (IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this))
d425 1
a425 1
				theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d431 1
a431 1
				theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d437 1
a437 1
				theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_TIMEOUT);
d440 1
a440 1
			theApp.uploadqueue->AddClientToQueue(this,true);
d471 1
a471 1
			srcfile = theApp.sharedfiles->GetFileByID(currentblock->FileID);
d474 1
a474 1
				theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_FILE_ERROR);	// eklmn: ???
d512 1
a512 1
						theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d563 1
a563 1
					theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_BLOCKED_CHUNK);
d573 1
a573 1
					theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_FILE_ERROR);
d643 1
a643 1
		theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_FILE_ERROR);
d700 1
a700 1
	CKnownFile* tempreqfile = theApp.sharedfiles->GetFileByID(cfilehash);
d740 1
a740 1
	theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(this);
d920 2
a921 2
		theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_TIMEOUT);
		theApp.uploadqueue->AddClientToQueue(this,true);
d948 2
a949 2
			theApp.glob_prefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), tosend->IsFromPF(), Upload, nBlockSize);
			//theApp.UpdateSentBytes(nBlockSize); 
d957 1
a957 1
//			theApp.uploadqueue->AddUpDataRateMSOverhead(24, 160);
d1006 1
a1006 1
		theApp.emuledlg->transferwnd.m_wndUploadList.RefreshClient(this);
d1023 1
a1023 1
		theApp.uploadqueue->AddUpDataOverheadOther(tosend->size);
d1032 1
a1032 1
	CKnownFile* file = theApp.sharedfiles->GetFileByID((uchar*)forfileid);
d1047 1
a1047 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d1061 1
a1061 1
	if (theApp.stat_transferStarttime==0) return 0;
d1063 1
a1063 1
	DWORD running=(GetTickCount()-theApp.stat_transferStarttime)/1000;
d1066 1
a1066 1
	return (float)(theApp.stat_sessionSentBytes/1024) / running;
d1092 1
a1092 1
	uint16 nRank = theApp.uploadqueue->GetWaitingPosition(this);
d1114 1
a1114 1
	if (!theApp.glob_prefs->CommunityEnabled())
d1153 1
a1153 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d1181 1
a1181 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d1220 2
a1221 2
	theApp.uploadqueue->UpdateBanCount();
	theApp.emuledlg->transferwnd.UpdateUploadHeader();
d1232 1
a1232 1
	theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(this);
d1239 1
a1239 1
 	if (!theApp.glob_prefs->BanEnabled())
d1247 3
a1249 3
		AddDebugLogLine(false,_T("Client '%s' banned and kicked out of uploadqueue %s"), GetUserName(), reason);
		theApp.uploadqueue->RemoveFromUploadQueue(this, ETS_BAN, true);
		theApp.uploadqueue->AddClientToQueue(this, true);
d1253 1
a1253 1
		AddDebugLogLine(false,_T("Client '%s' is already banned from the uploadqueue %s"), GetUserName(), reason);
d1257 1
a1257 1
	if(theApp.glob_prefs->CommunityNoBanEnabled() && theApp.glob_prefs->CommunityEnabled() && IsCommunity())
d1260 2
a1261 2
	theApp.uploadqueue->UpdateBanCount();
	theApp.emuledlg->transferwnd.UpdateUploadHeader();
d1263 1
a1263 1
	if(theApp.glob_prefs->IsBanMessageEnabled())
d1265 4
a1268 4
		theApp.emuledlg->chatwnd.chatselector.StartSession(this, TRUE);
		theApp.emuledlg->chatwnd.chatselector.SendMessage(line);
		theApp.emuledlg->chatwnd.chatselector.EndSession(this);		// now it automatically closes the session afterwards
		if (!theApp.glob_prefs->GetCMNotLog())
d1272 1
a1272 1
		if (!theApp.glob_prefs->GetCMNotLog())
d1275 1
a1275 1
	theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(this);
d1285 1
a1285 1
	uint16 nRank = theApp.uploadqueue->GetWaitingPosition(this);
d1294 1
a1294 1
	ProxySettings proxy = theApp.glob_prefs->GetProxy();
d1296 1
a1296 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size);
d1298 1
a1298 1
		theApp.clientudp->SendPacket(response,GetIP(),GetUDPPort());
d1307 1
a1307 1
	return GetStatusDLQueueString((eDLQState)GetDownloadState());
d1331 1
a1331 1
	CString pszUsername = theApp.glob_prefs->GetUserNick();
d1340 1
a1340 1
	if (theApp.serverconnect->IsLowID()) fBaseValue *= 0.8f;
d1344 1
a1344 1
	if (theApp.glob_prefs->CommunityEnabled() && IsCommunity())
@


1.120
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d120 2
a121 2
	if (m_pszUsername.IsEmpty()) return 0;

d192 1
d335 1
a335 1
		if ((kf != NULL) && !kf->AllowChunkForClient(next_requested_part, this)) {
d588 1
a588 1
				partfile->m_hPartFile.Seek(currentblock->StartOffset,0);
d591 3
a593 3
				if (uint32 done = partfile->m_hPartFile.Read(filedata,togo) != togo){
					partfile->m_hPartFile.SeekToBegin();
					partfile->m_hPartFile.Read(filedata + done,togo-done);
d984 1
a984 1
	// Don't store more than 40 seconds of statistics m_Average_DL_tick_list.size()
@


1.119
log
@Small change for debug logging
@
text
@d209 1
a209 1
	if (GetDownloadState() == DS_DOWNLOADING && GetDatarate() > 500) // obaldin: prevent 0.1 upload abuse
d303 1
a303 1
		//AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u KB", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
d394 1
a394 1
	// Never allow more than the size of a chunk (+500 KBytes for small resends of invalid data) to be transfered
d587 1
a587 1
				partfile->m_hpartfile.Seek(currentblock->StartOffset,0);
d590 3
a592 3
				if (uint32 done = partfile->m_hpartfile.Read(filedata,togo) != togo){
					partfile->m_hpartfile.SeekToBegin();
					partfile->m_hpartfile.Read(filedata + done,togo-done);
d608 1
a608 1
				CreateStandartPackets(filedata,togo,currentblock,bFromPF);
d745 1
a745 1
void CUpDownClient::CreateStandartPackets(byte* data,uint32 togo, Requested_Block_Struct* currentblock, bool bFromPF)
d783 1
a783 1
		CreateStandartPackets(data,togo,currentblock, bFromPF);		// -khaos: Create the packet with the new boolean.
d911 1
a911 1
    uint32 amounttransfered = 0;
d938 1
a938 1
		while (!m_BlockSend_queue.IsEmpty() && m_BlockSend_queue.GetHead()->GetRealPacketSize()+amounttransfered <= nMaxAmmount) 
d953 3
a955 3
			// We've transfered some data. Store this in relevant statistics variables
			m_nTransferedUp += nBlockSize;
			amounttransfered += nBlockSize;
d972 1
a972 1
		if(amounttransfered > 0) {
d978 1
a978 1
	// Store how much data we've transfered this round,
d980 1
a980 1
	m_AverageUDR_list.push_front(m_nTransferedUp);
d995 1
a995 1
		// Calculate average datarate
d1001 1
a1001 1
			m_nUpDatarate = (uint32)(((float)(m_AverageUDR_list.front()-m_AverageUDR_list.back()))*1000 / timePeriod);
d1003 1
a1003 1
			m_nUpDatarate = -1;
d1009 1
a1009 1
	return amounttransfered;
@


1.118
log
@uninitialized variable
@
text
@d1033 4
a1036 1
		throw GetResString(IDS_ERR_REQ_FNF)+CString(" (SendHashsetPacket)");
@


1.117
log
@upload fix & some stattistics fixes
@
text
@d455 1
a455 1
	bool bFromPF;
@


1.116
log
@optimization in SendBlockData()
@
text
@d453 1
d455 1
d458 2
a459 1
	try{
d470 1
a470 1
			CKnownFile* srcfile = theApp.sharedfiles->GetFileByID(currentblock->FileID);
a566 11
			// eklmn: actually it is pointless to check cause in any case we gonna upload only one chunk
			/* 
			if( togo > EMBLOCKSIZE )
			{
				CString LargeBlock;
				LargeBlock.Format("Requested block is too large (size: %i, overhead: %i).", togo, (togo-EMBLOCKSIZE));
				//throw CString("GetResString(IDS_ERR_LARGEREQBLOCK)");	//SyruS unhandled exception without CString()!
				throw LargeBlock;
			}
			*/
			
d569 1
d604 1
d606 1
a606 1
				CreatePackedPackets(filedata,togo,currentblock);
d608 2
a609 1
				CreateStandartPackets(filedata,togo,currentblock);
d758 1
a758 1
		Packet* packet = new Packet(OP_SENDINGPART,nPacketSize+24,bFromPF);	// -khaos: Create the packet with the new boolean.
d771 1
a771 1
        splitAndAddPacketsToSendQueue(packet);
d812 1
a812 1
        splitAndAddPacketsToSendQueue(packet);
d822 2
a823 1
void CUpDownClient::splitAndAddPacketsToSendQueue(Packet* packet) {
d825 7
a831 5
    if (packet->GetRealPacketSize() > 0 && packet->GetRealPacketSize() > MAXFRAGSIZE*2) {
	    // splitting packets
		    uint32 nSize = packet->GetRealPacketSize();
		    char* pBuffer = packet->DetachPacket();
		    delete packet;
d833 22
a854 18
		    uint32 nPos = 0;
		    bool bLast = true;
		    while (nPos < nSize){
			    uint32 nNewSize = (nSize-nPos < MAXFRAGSIZE) ? nSize-nPos : MAXFRAGSIZE;
			    char* pBuffer2 = new char[nNewSize];
			    #ifndef AMD
			    memcpy(pBuffer2,pBuffer+nPos,nNewSize);
			    #else
			    memcpy_amd(pBuffer2,pBuffer+nPos,nNewSize);
			    #endif
			    nPos += nNewSize;
			    m_BlockSend_queue.AddTail(new Packet(pBuffer2,nNewSize,(nNewSize < MAXFRAGSIZE)));
			    bLast = false;
		    }
		    delete[] pBuffer;
    } else {
        m_BlockSend_queue.AddTail(packet);
    }
d931 1
a931 3
			if ( !CreateNextBlockPackage()) {
				return 0;
			}
@


1.115
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@a910 18
    // Check if it's time to update the display.
	if (curTick-m_lastRefreshedULDisplay > MINWAIT_BEFORE_ULDISPLAY_WINDOWUPDATE &&
        m_AverageUDR_list.size() >= 2) {
        // Calculate average datarate
        // Present this slot's speed as 0 unless there's a good chunk
        // of stored statistics for it. If there's to little data, the
        // UL speed will be far off, so we might as well hide it in those
        // cases.

        if(m_Average_UL_tick_list.front()-m_Average_UL_tick_list.back()>10000)
	        m_nUpDatarate = (uint32)(((float)(m_AverageUDR_list.front()-m_AverageUDR_list.back()))*1000 / (m_Average_UL_tick_list.front()-m_Average_UL_tick_list.back()));
        else
            m_nUpDatarate = -1;

		theApp.emuledlg->transferwnd.m_wndUploadList.RefreshClient(this);
        m_lastRefreshedULDisplay = curTick+(uint32)(rand()/(RAND_MAX/1000));	//SyruS moved rand out of if(...)
	}

d980 6
a985 1
	if(m_Average_UL_tick_list.empty() || curTick - m_Average_UL_tick_list.back() >= 500)	//Cax2 - update no faster than every .5 sec
d987 2
a988 8
		m_AverageUDR_list.push_front(m_nTransferedUp);
		m_Average_UL_tick_list.push_front(curTick);

		// Don't store more than 40 seconds of statistics
		while(curTick-m_Average_UL_tick_list.back() > 40000) {
   			m_AverageUDR_list.pop_back();
			m_Average_UL_tick_list.pop_back();
		}
@


1.114
log
@updated complete sources (compatibility with future official)
@
text
@d144 1
a144 1
			if (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID() || theApp.listensocket->TooManySockets())
d221 1
a221 1
		fBaseValue *= credits->GetScoreRatio();
d566 1
a566 1
			if( togo > BLOCKSIZE )
d569 1
a569 1
				LargeBlock.Format("Requested block is too large (size: %i, overhead: %i).", togo, (togo-BLOCKSIZE));
d975 1
a975 1
			credits->AddUploaded(nBlockSize);
d1137 1
a1137 1
		fBaseValue *= credits->GetScoreRatio();
d1380 1
a1380 1
		return credits->GetScoreRatio(true);
@


1.113
log
@*** empty log message ***
@
text
@d735 1
a735 1
		if (size >= 20 + (((uint32)m_nUpPartCount + 7) >> 3))
@


1.112
log
@after the implementation of all the bans,
the enable/disable ban function was broken
@
text
@d744 1
a744 1
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this);
d906 26
a931 10
	DWORD curTick = GetTickCount();

	// this will be set to true if/when the slot is actually fed some data
	wantsMoreBandwidth = false;
	uint32 amounttransfered = 0;

	//eklmn: first of all check for 'stuck' clients, it is pointless to update a stuck client
	//	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
	if ((curTick-GetLastGotULData() > 2*60*1000) && (GetUpStartTimeDelay()>2*60*1000)) 
	{
d1024 1
a1024 1
		theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(this);
d1247 1
a1247 1
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this);
d1290 1
a1290 1
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this);
@


1.111
log
@1) extended UL Session statistic
2) permanent ban for leecher MOD's
@
text
@d1195 1
a1195 1
				if ((cur_struct->badrequests == BADCLIENTBAN) && (theApp.glob_prefs->BanEnabled())){ // DbT:BanEnDisable //katsyonak 16.06.03
a1196 1
				}
d1238 6
@


1.110
log
@new statistic (khaos based)
@
text
@d92 1
a92 1
		community.Remove('['); community.Remove(']');
d96 4
d116 2
a117 1
uint32 CUpDownClient::GetScore(bool sysvalue, bool isdownloading, bool onlybasevalue){
d120 5
a124 6
	if (m_pszUsername.IsEmpty())
		return 0;
	if (IsBanned())	//SyruS moved this up (from end) to skip the whole useless calculation
		return 0;
    /* obaldin: Have to reexamine the changes in low-id handling in v27
	if (sysvalue && HasLowID() && !(socket && socket->IsConnected())){
d126 21
d148 4
a151 1
    */
a152 2
	if (!score_base_cached) 
	{ 
d160 3
a162 1
		filepriority = 10; // standard	
d165 26
a190 40
			if(theApp.sharedfiles->GetFileByID(reqfileid) != NULL)
			{
				switch(theApp.sharedfiles->GetFileByID(reqfileid)->GetPriority())
				{ 
					case PR_VERYHIGH: // Modified by Tarod for UAP
						if (theApp.sharedfiles->GetFileByID(reqfileid)->IsPartFile())
						{
							filepriority = 50;
						} else {
							filepriority = 100;
						}
						break;
					case PR_HIGH:
						filepriority = 20;
						break;
					case PR_LOW:
						filepriority = 5;
						break;
					case PR_VERYLOW:
						filepriority = 2;
						break;
					case PR_NORMAL:
						default:
						filepriority = 10;
					break;
				} 
			}
		}
		score_base_cached = true; // i_a 
	}

	//Start milobac: Anti-leechermods
	if (!m_bBanned && theApp.glob_prefs->GetMlDonkeyCM() && IsStolenName())
	{
		if (!m_modVerString.IsEmpty())
			AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) using the mod %s has been banned"),GetUserName(),GetClientNameAndVersionString(this),GetModVersion());
		else 
			AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) has been banned"),GetUserName(),GetClientNameAndVersionString(this));
		//katsyonak: Send leecher ban message 15.06.03
		Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_LEECHERADV));
a191 1
	//End milobac: Anti-leechermods
d193 1
a193 1
    // calculate score, based on waitingtime and other factors
a229 10
#ifdef OLD_SOCKETS_ENABLED
	if (!isdownloading && !onlybasevalue)
	{
		if (HasLowID() && !(socket && socket->IsConnected()))
		{
			if (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID() || theApp.listensocket->TooManySockets())
				return 0;
		}
	}
#endif //OLD_SOCKETS_ENABLED
a420 1
			//v- eklmn: bugfix(06): don't check client twice if he got full chunk
a421 3
			theApp.uploadqueue->RemoveFromUploadQueue(this);
			theApp.uploadqueue->AddClientToQueue(this,true);
			//^- eklmn: bugfix(06): don't check client twice if he got full chunk
d423 2
d426 1
d429 2
d432 1
d435 2
d438 2
d469 2
d472 1
d508 1
d558 2
d561 1
d564 2
d573 1
d578 2
d581 1
a638 1
		theApp.uploadqueue->RemoveFromUploadQueue(this);
d647 1
a647 1
		theApp.uploadqueue->RemoveFromUploadQueue(this);
d656 1
d903 2
a904 1
uint32 CUpDownClient::SendBlockData(uint32 nMaxAmmount, bool& wantsMoreBandwidth){
d906 1
a906 18
    DWORD curTick = GetTickCount();
    // this will be set to true if/when the slot is actually fed some data
    wantsMoreBandwidth = false;
    uint32 amounttransfered = 0;

    // Check if it's time to update the display.
	if (curTick-m_lastRefreshedULDisplay > MINWAIT_BEFORE_ULDISPLAY_WINDOWUPDATE &&
        m_AverageUDR_list.size() >= 2) {
        // Calculate average datarate
        // Present this slot's speed as 0 unless there's a good chunk
        // of stored statistics for it. If there's to little data, the
        // UL speed will be far off, so we might as well hide it in those
        // cases.

        if(m_Average_UL_tick_list.front()-m_Average_UL_tick_list.back()>10000)
	        m_nUpDatarate = (uint32)(((float)(m_AverageUDR_list.front()-m_AverageUDR_list.back()))*1000 / (m_Average_UL_tick_list.front()-m_Average_UL_tick_list.back()));
        else
            m_nUpDatarate = -1;
d908 8
a915 7
		theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(this);
        m_lastRefreshedULDisplay = curTick+(uint32)(rand()/(RAND_MAX/1000));	//SyruS moved rand out of if(...)
	}

    // check for 'stuck' clients
    //	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
    if ((curTick-GetLastGotULData() > 2*60*1000)  && (GetUpStartTimeDelay()>2*60*1000)) {
d919 1
a919 1
		theApp.uploadqueue->RemoveFromUploadQueue(this);
d980 2
a981 2
    // Store how much data we've transfered this round,
    // to be able to calculate average speed later
d993 21
a1013 1
    return amounttransfered;
d1242 1
a1242 1
		theApp.uploadqueue->RemoveFromUploadQueue(this, true, false);
@


1.109
log
@kick already downloading client back to waitingqueue when banning (rare case)
@
text
@d81 1
a81 1
{    
d83 16
a98 12
    if (!community_cached)
    { 
        // [i_a] DonGato (Community Sharing)
        CString username(GetUserName());
		CString community(theApp.glob_prefs->CommunityString().MakeUpper());
		community.Remove('[');
		community.Remove(']');
		CString communityok('[' + community + ']');
        iscommunity = (username.MakeUpper().Find(communityok) >= 0);
        community_cached = true;
    } 
    return iscommunity;
d728 2
a729 1
void CUpDownClient::CreateStandartPackets(byte* data,uint32 togo, Requested_Block_Struct* currentblock){
d741 1
a741 1
		Packet* packet = new Packet(OP_SENDINGPART,nPacketSize+24);
d759 1
a759 1
void CUpDownClient::CreatePackedPackets(byte* data,uint32 togo, Requested_Block_Struct* currentblock){
d766 1
a766 1
		CreateStandartPackets(data,togo,currentblock);
d783 1
a783 1
		Packet* packet = new Packet(OP_COMPRESSEDPART,nPacketSize+24,OP_EMULEPROT);
d933 2
a934 1
		while (!m_BlockSend_queue.IsEmpty() && m_BlockSend_queue.GetHead()->GetRealPacketSize()+amounttransfered <= nMaxAmmount) {
d938 6
a951 1
			theApp.UpdateSentBytes(nBlockSize);
@


1.108
log
@Community Sharing fix
@
text
@d1201 6
@


1.107
log
@fixed NULL pointer access
@
text
@d79 2
a80 2
// [i_a] 
bool CUpDownClient::IsCommunity()                
d83 1
a83 1
    if (!community_cached) 
d85 8
a92 5
        // [i_a] DonGato (Community Sharing)  
        CString copy1(GetUserName()); 
        CString copy2(theApp.glob_prefs->CommunityString().MakeUpper());         
        iscommunity = (copy1.MakeUpper().Find(copy2) >= 0); 
        community_cached = true; 
d94 1
a94 1
    return iscommunity; 
d97 1
a97 1
} 
d99 2
a100 2
void CUpDownClient::ResetValueCache() 
{ 
d102 2
a103 2
    score_base_cached = false; 
    community_cached = false; 
d105 2
a106 2
} 
// [/i_a] 
d123 8
a130 8
	// TODO coded by tecxx & herbert, one yet unsolved problem here:
	// sometimes a client asks for 2 files and there is no way to decide, which file the 
	// client finally gets. so it could happen that he is queued first because of a 
	// high prio file, but then asks for something completely different.
	
	// isfriend = 	theApp.emuledlg->chatwnd.IsFriend(CString(m_pszUsername));
	// isemuleclient = false; // i_a: unused
	filepriority = 10; // standard	
d132 25
a156 18
         { 
		if(theApp.sharedfiles->GetFileByID(reqfileid) != NULL){ 
			switch(theApp.sharedfiles->GetFileByID(reqfileid)->GetPriority()){ 
				case PR_VERYHIGH: // Modified by Tarod for UAP
					if (theApp.sharedfiles->GetFileByID(reqfileid)->IsPartFile()) {
						filepriority = 50;
					} else {
						filepriority = 100;
					}
					break;
				case PR_HIGH: 
					filepriority = 20; 
					break; 
				case PR_LOW: 
					filepriority = 5; 
					break; 
				case PR_VERYLOW:
					filepriority = 2;
d158 2
a159 5
				case PR_NORMAL: 
					default: 
					filepriority = 10; 
				break; 
			} 
d161 1
a161 2
		 }
	score_base_cached = true; // i_a 
d165 2
a166 1
	if (!m_bBanned && theApp.glob_prefs->GetMlDonkeyCM() && IsStolenName()){
d173 1
a173 1
	 }
d182 2
a183 1
	else{
d198 1
a198 2
			fBaseValue *= 2.0f;
	//
d202 2
a203 1
	if(credits != (CClientCredits*)NULL) { 
d208 2
a209 3
	fBaseValue *= GetSmallFilePushRatio() ;
	fBaseValue *= GetRareFilePushRatio() ;
	// End by Tarod
d211 1
a211 2
	/*if (!onlybasevalue)*/
		fBaseValue *= ((float)(filepriority))/10.0f; 
d214 4
a217 2
	if (!isdownloading && !onlybasevalue){
		if (HasLowID() && !(socket && socket->IsConnected())){
d230 2
a231 1
float CUpDownClient::GetRareFilePushRatio(){
d240 2
a241 2
	float ratio = 0+srcfile->GetFileRatio() ;
	return (ratio < 1.0f ? 1.0f :((ratio>100.0f)?100.0f: ratio)) ;		//Cax2 bugfix
@


1.106
log
@minor debuglog change
@
text
@d318 1
a318 1
		if (!kf->AllowChunkForClient(next_requested_part, this)) {
@


1.105
log
@updated complete sources (0.06b: display range of values)
@
text
@d538 1
a538 1
				LargeBlock.Format("Required block is too large (size: %i, overhead: %i).", togo, (togo-BLOCKSIZE));
@


1.104
log
@fix for extended output :)
@
text
@d701 5
a705 1
			data.Read(&m_nUpCompleteSourcesCount,2);
@


1.103
log
@extended debug output in case of large blocks
@
text
@d536 3
d540 2
a541 1
				throw CString("Required block is too large (size: %i, overhead: %i).",togo, (togo-BLOCKSIZE));
@


1.102
log
@fixed unhandled exception in CUpDownClient::CreateNextBlockPackage()
@
text
@d536 2
a537 1
				throw CString("GetResString(IDS_ERR_LARGEREQBLOCK)");	//SyruS unhandled exception without CString()!
@


1.101
log
@one exception was not handled
@
text
@d536 1
a536 1
				throw CString("GetResString(IDS_ERR_LARGEREQBLOCK)");
@


1.100
log
@SyruS (0.29c) bluecow: Fixed problem with completing file which was concurrently uploaded.
@
text
@d536 1
a536 1
				throw "GetResString(IDS_ERR_LARGEREQBLOCK)";
@


1.99
log
@fixed conflict betwenn JS & full chunk condition
@
text
@d355 18
d433 1
d449 11
a459 1
			if (srcfile->IsPartFile() && ((CPartFile*)srcfile)->GetStatus() != PS_COMPLETE){
d462 3
a464 1
			} else{				
d538 2
a539 1
			if (!srcfile->IsPartFile()){
d551 2
a552 1
			else{
d562 2
d601 1
a601 1
			delete filedata;		
@


1.98
log
@FEATURE: logging countermeasures made optional [Netwolf]
plus cleanup of unused prefs (transfer full chunks, global load f/l chunks first...)
@
text
@d376 3
a379 2
#if JUMPSTART
		if (!JS_blocked)
d439 1
a439 1
			if (!srcfile->GetJumpstartEnabled()) {
d441 1
a441 1
			if (true) {
d443 1
@


1.97
log
@more #if JUMPSTART #else #endif
more TRY & CATCH
@
text
@d1163 2
a1164 1
		AddLogLine(false, IDS_SENTBAN, GetUserName(), reason);
d1167 2
a1168 1
		AddLogLine(false, IDS_CLIENTBLOCKED, GetUserName(), reason);
@


1.96
log
@small fix
@
text
@d363 1
a363 1

d376 4
a379 1
		if (IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this) && !JS_blocked)
d437 1
d439 3
d580 2
d585 1
d607 1
d746 1
d771 1
d775 1
d781 1
d822 1
d824 3
d829 1
a829 1
	if (curTick-m_lastRefreshedULDisplay > MINWAIT_BEFORE_ULDISPLAY_WINDOWUPDATE+(uint32)(rand()/(RAND_MAX/1000)) &&
d843 1
a843 1
        m_lastRefreshedULDisplay = curTick;
a845 6
    // this will be set to true if/when the slot is actually fed some data
    wantsMoreBandwidth = false;

    uint32 amounttransfered = 0;


d921 2
d962 1
d973 2
d1264 1
d1272 2
@


1.95
log
@conflict between upload logic & LANcast
@
text
@d416 1
a416 1
		while (!m_BlockRequests_queue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock() || !IsForbiddenByJumpstart()) )
@


1.94
log
@possible conflict between JUMSTART & PartTraffic
@
text
@d366 1
a366 1
	// v- eklmn: bugfix(04): no full chunk transfer for user outside the LAN 
d369 2
a370 4
	
	bool JS_bloked = IsForbiddenByJumpstart();
	bool shouldGo=((GetUpStartTimeDelay()>= 80*60*1000) || diff_part || JS_bloked);
#else
a371 1
#endif
d373 5
a377 2
	if (AllowedMore) {
		if(shouldGo && IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this))  {
d381 9
a389 9
	}	
	else if (!AllowedMore && shouldGo) {
		//v- eklmn: bugfix(06): don't check client twice if he got full chunk
		SetWaitStartTime();
		theApp.uploadqueue->RemoveFromUploadQueue(this);
		theApp.uploadqueue->AddClientToQueue(this,true);
		//^- eklmn: bugfix(06): don't check client twice if he got full chunk
		if (diff_part)
			AddDebugLogLine(false, _T("Client %s (%s)  back on queue. Asked for a new chunk/file, after receiving %u KB."), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d391 2
a392 2
		else if (JS_bloked)
			AddDebugLogLine(false, _T("Client %s (%s)  back on queue. Asked for a chunk forbidden by Jumpstart, after receiving %u KB."), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d394 4
a397 3
		else
			AddDebugLogLine(false, _T("Client %s (%s)  back on queue. Upload timeout, after receiving %u KB"), GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
		return false;
d399 2
a400 1
	// ^- eklmn: bugfix(04): no full chunk transfer for user outside the LAN 
@


1.93
log
@unicode cleanup
@
text
@d369 1
d431 16
a446 12
			//--- xrmb:partprio ---
			//--- accessing a blocked part??? ---
			uint8 part_status = srcfile->GetPartStatus(currentblock->StartOffset / PARTSIZE);
			CString s;
			switch (part_status) {
				case PR_PART_OFF:
					AddLogLine(false, IDS_PARTPRIO_DENIED, currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
					s.Format(GetResString(IDS_PARTPRIO_DENIED), currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
					throw s;
					break;
				case PR_PART_HIDDEN:
					AddLogLine(false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
d448 1
a448 1
			//--- :xrmb ---
@


1.92
log
@Jumpstart fix
@
text
@d519 2
a520 1
			if (m_byDataCompVer == 1 && (!strstr(srcfile->GetFileName(),".zip")) && (!strstr(srcfile->GetFileName(),".rar")) && (!strstr(srcfile->GetFileName(),".ace")))
@


1.91
log
@banning loglines goto normal log instead of debuglog
@
text
@d27 1
d306 2
a307 1
    EMULE_TRY
d311 15
a325 12
    if(m_BlockRequests_queue.IsEmpty()) {
        return false;
    } else {
        next_requested_block = (Requested_Block_Struct*)m_BlockRequests_queue.GetHead();
        next_requested_part = next_requested_block->StartOffset / PARTSIZE;
        CKnownFile* kf = theApp.sharedfiles->GetFileByID(next_requested_block->FileID);
        if(!kf->AllowChunkForClient(next_requested_part, this)) {
            return true;
        }
    }
    EMULE_CATCH
    return false;
d367 5
a371 1
	bool diff_part=IsDifferentPartBlock(true);	//Cax2 - don't write anyting to the log yet!
d373 1
d389 4
a407 3
#if JUMPSTART
	bool have_something = false;
#endif // JUMPSTART
d409 3
a411 4
        // repeat as long as next requested block is in the same chunk as previous blocks
        // and as long as there is a next requested block
		while (!m_BlockRequests_queue.IsEmpty() && (AllowedMore || !IsDifferentPartBlock()))		//Cax2 - if a friend or lancast user, keep going!
		{
d413 3
a415 7
#if 0
            if(IsForbiddenByJumpstart()) {
                if(have_something)
                    break;
                else
                    return false;
            }
d417 1
a417 2
#endif // JUMPSTART
            
d432 10
a441 6
			if(srcfile->GetPartStatus(currentblock->StartOffset / PARTSIZE)==PR_PART_OFF)
			{
				CString s;
				AddLogLine(false, IDS_PARTPRIO_DENIED, currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
				s.Format(GetResString(IDS_PARTPRIO_DENIED), currentblock->StartOffset / PARTSIZE, srcfile->GetFileName());
				throw s;
d443 27
d471 8
a478 3
			if(srcfile->GetPartStatus(currentblock->StartOffset / PARTSIZE)==PR_PART_HIDDEN)
			{
				AddLogLine(false, IDS_PARTPRIO_HIDDEN, GetUserName(), srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
a479 2
			//--- :xrmb ---
            uint32 togo;
d481 4
a484 39
            if(AllowedMore)	// Friends & LAN  are not limited by chunks boundaries.
			{
                // Is this a wraparound request?
                if (currentblock->StartOffset > currentblock->EndOffset-1){
                    // If StartOffset is later in the file than EndOffset, it means
                    // that the request is a wraparound request. It reads to the end of
                    // the file, then it wraps around and continues in the beginning of the file.

                    // Calculate how much the client is requesting, knowing that this is a wraparound request
				    togo = currentblock->EndOffset + (srcfile->GetFileSize() - currentblock->StartOffset);
			    } else {
                    // not a wraparound request. This makes it easier to calculate how many bytes is
                    // being requested.
				    togo = currentblock->EndOffset - currentblock->StartOffset;
			    }
            } else {
                // Everyone else are limited to a single chunk

                // Check that StartOffset and EndOffset is in the same chunk
                if(currentblock->StartOffset/PARTSIZE != (currentblock->EndOffset - 1)/PARTSIZE) {
                    // The EndOffset goes into the next chunk. Set it to the end of the chunk
                    // that StartOffset is in.
                    currentblock->EndOffset = ((uint32)(currentblock->StartOffset/PARTSIZE)+1)*PARTSIZE;
                }

                // Make sure we don't pass end of file
			    if (currentblock->StartOffset > currentblock->EndOffset){
                    currentblock->EndOffset = srcfile->GetFileSize();
                }

                // This can't be a wrapped around request, since it has been limited to
                // a single chunk.
                togo = currentblock->EndOffset - currentblock->StartOffset;
            }

            if (srcfile->IsPartFile()) { // proper check
                uint32 parts_start = ((currentblock->StartOffset)/PARTSIZE)*PARTSIZE;
                uint32 parts_end = ((currentblock->EndOffset-1)/PARTSIZE + 1)*PARTSIZE -1;
                if(!((CPartFile*)srcfile)->IsComplete(parts_start,parts_end))
d486 1
a486 1
            }
d533 4
a536 4
                if (srcfile->GetJumpstartEnabled()){
                    srcfile->AddSentBlock(this, currentblock->StartOffset, togo);
                }
            }
a541 3
#if JUMPSTART
            have_something = true;
#endif // JUMPSTART
d563 1
a563 1
//	AddDebugLogLine(false,"Debug: Packet done. Size: %i",blockpack->GetLength());
@


1.90
log
@converted to helper IsStolenName
@
text
@d1139 1
a1139 1
		AddDebugLogLine(false, IDS_CLIENTBLOCKED, GetUserName(), reason);
@


1.89
log
@unicode cleanup
@
text
@d107 1
a107 1
	if (!m_pszUsername)
d158 7
a164 23
	if((strstr(m_pszUsername,"$GAM3R$")||
		strstr(m_pszUsername,"G@@m3rs Edit")||
		strstr(m_pszUsername,"G@@m3rs Edit")||
		strstr(m_pszUsername,"[RAMMSTEIN")||
		strstr(m_pszUsername,"[toXic]")||
		strstr(m_pszUsername,"Leecha")||
		strstr(m_pszUsername,"leecha")||
		strstr(m_pszUsername,"edevil")||
		strstr(m_pszUsername,"DarkMule")||
		strstr(m_pszUsername,"darkmule")||
		strstr(m_pszUsername,"Odin")||
		strstr(m_pszUsername,"eVortex")||
		strstr(m_pszUsername,"|eVorte|X|")||
		strstr(m_modVerString,"eVortex")||
		strstr(m_pszUsername,"MISON")||
		strstr(m_pszUsername,"Mison")||
		strstr(m_modVerString,"Mison"))&&(m_bBanned != true)&&theApp.glob_prefs->GetMlDonkeyCM()){
			if (m_modVerString != "")
				AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) using the mod %s has been banned"),GetUserName(),GetClientNameAndVersionString(this),GetModVersion());
			else 
				AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) has been banned"),GetUserName(),GetClientNameAndVersionString(this));
			//katsyonak: Send leecher ban message 15.06.03
			Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_LEECHERADV));
@


1.88
log
@upload fix (reset tosend in SendBlockData, based on 0.29)
@
text
@d176 1
a176 1
				AddDebugLogLine(false,"Anti-leechermods: Client %s (%s) using the mod %s has been banned",GetUserName(),GetClientNameAndVersionString(this),GetModVersion());
d178 1
a178 1
				AddDebugLogLine(false,"Anti-leechermods: Client %s (%s) has been banned",GetUserName(),GetClientNameAndVersionString(this));
d180 1
a180 1
			Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!", GetResString(IDS_BAN_LEECHERADV));
d311 1
a311 1
				AddDebugLogLine(false, "Client %s continues downloading (should be back on queue) because of a low transferred size",GetUserName()); 
d384 1
a384 1
			AddDebugLogLine(false, "Client %s downloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend.", GetUserName(), this->GetSessionUp() / 1024); 
d394 1
a394 1
			AddDebugLogLine(false, "Client %s (%s)  back on queue. Asked for a new chunk/file, after receiving %u KB.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d438 1
a438 1
				fullname.Format("%s\\%s",srcfile->GetPath(),srcfile->GetFileName());
d844 1
a844 1
		AddDebugLogLine(false, "Client %s(%s) appears to be stuck, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
d1092 1
a1092 1
					Ban("AUTOMATED MESSAGE: You're being banned because your client is behaving aggressively!", GetResString(IDS_BAN_AGGRESSIVECLI));
@


1.87
log
@no need to ban a client (and send a message) again except for extending the bantime
@
text
@d872 1
d883 1
a883 2
			if (m_BlockSend_queue.IsEmpty())
				CreateNextBlockPackage();
@


1.86
log
@use helper method for community check
@
text
@d109 2
d116 1
a118 2

	
d152 4
a155 4
		} 
	} 
        score_base_cached = true; // i_a 
      } 
a220 2
	if (IsBanned())
		return 0;
d1134 7
a1157 1

@


1.85
log
@some more localizations...
@
text
@d1008 1
a1008 4

	char *copy1, *copy2;
	copy1 = _strupr( _strdup( m_pszUsername ) );
	copy2 = _strupr( _strdup( theApp.glob_prefs->CommunityString() ) );
d1010 5
a1014 4
	if (!theApp.glob_prefs->CommunityEnabled()) nCommunity = 2;
	else if ((copy1 && copy2) && (strstr(copy1 ,copy2) != NULL )) nCommunity = 1;
	free(copy1);
	free(copy2);
@


1.84
log
@memleak in UploadClient::CreateNextBlockPackage due CFile exception
@
text
@d447 2
a448 2
				AddLogLine(false, "Access to '%s' part %i denied", srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
				s.Format("Access to '%s' part %i denied", srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
d454 1
a454 1
				AddLogLine(false, "Client '%s' accessed hidden '%s' part %i", GetUserName(), srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
@


1.83
log
@Updated Banning messages.
@
text
@d568 11
@


1.82
log
@xrmb countermeasures now use the option in preferences and some minor changes.
@
text
@d179 1
a179 1
			Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!");
d1084 1
a1084 1
					Ban("AUTOMATED MESSAGE: You're being banned because your client is behaving aggressively!");
d1124 1
a1124 1
void CUpDownClient::Ban(LPCTSTR line, ...){ //katsyonak 16.06.03
a1131 1
	AddDebugLogLine(false,IDS_CLIENTBLOCKED,GetUserName());
d1137 1
a1137 1
		AddLogLine(false, IDS_SENTBAN,GetUserName());
d1139 3
@


1.81
log
@minor changes (use md4... instead of mem...)
@
text
@d175 3
a177 2
				AddDebugLogLine(false,"Anti-leechermods: Client %s (%s) using the mod %s has been banned because of using a leecher mod",GetUserName(),GetClientNameAndVersionString(this),GetModVersion());
			else AddDebugLogLine(false,"Anti-leechermods: Client %s (%s) has been banned because of using a leecher mod",GetUserName(),GetClientNameAndVersionString(this));
d179 1
a179 1
		Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!");
d447 2
a448 2
				AddLogLine(false, "access to '%s' part %i denied", srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
				s.Format("access to '%s' part %i denied", srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
d454 1
a454 1
				AddLogLine(false, "client '%s' accessed hidden '%s' part %i", GetUserName(), srcfile->GetFileName(), currentblock->StartOffset / PARTSIZE);
@


1.80
log
@katsyonak: minor fix regarding anti-leechermod logging
@
text
@d286 1
a286 1
			if (memcmp(last_done_block->FileID, next_requested_block->FileID, 16) != 0)
d384 1
a384 1
			AddDebugLogLine(false, "Client %s dowloaded %u KB so far. Allowed to continue downloading (should go back on queue) because it's a friend.", GetUserName(), this->GetSessionUp() / 1024); 
d527 1
a527 1
			memcpy(reqfileid,currentblock->FileID,16);
@


1.79
log
@missing "
@
text
@d174 3
a176 1
		AddDebugLogLine(false,"Anti-leechermods: Client %s using the mod %s has been banned",GetUserName(),GetModVersion()); 
@


1.78
log
@*** empty log message ***
@
text
@d394 1
a394 1
			AddDebugLogLine(false, "Client %s (%s)  back on queue. Upload timeout, after receiving %u KB, GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
@


1.77
log
@Updated banning message
@
text
@d282 1
a282 1
				//AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d287 1
a287 1
                //AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d300 1
a300 1
		//AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
d382 1
a382 1
			AddDebugLogLine(false, "Client %s dowloaded %u Kbs so far. Allowed to continue downloading (should go back on queue) because it's a friend.", GetUserName(), this->GetSessionUp() / 1024); 
d392 1
a392 1
			AddDebugLogLine(false, "Client %s (%s)  back on queue. Asked for a new chunk/file, after receiving %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d394 1
a394 1
			AddDebugLogLine(false, "Client %s (%s)  back on queue. Upload timeout, after receiving %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d1080 1
a1080 1
				if (cur_struct->badrequests == BADCLIENTBAN){
a1122 2
	if(!theApp.glob_prefs->BanEnabled()) // DbT:BanEnDisable
		return;
@


1.76
log
@Added countermeasures for unfair clients and some forum bugfixing
@
text
@d173 2
a174 4
		strstr(m_modVerString,"Mison"))&&(m_bBanned != true)&&theApp.glob_prefs->GetMlDonkeyCM())
	{
			m_bBanned = true;
			AddDebugLogLine(false,"Anti-leechermods: Client %s using the mod %s has been banned",GetUserName(),GetModVersion()); 
d176 1
a176 8
			theApp.uploadqueue->UpdateBanCount();
			theApp.emuledlg->transferwnd.UpdateUploadHeader();
			m_dwBanTime = ::GetTickCount();
			theApp.emuledlg->chatwnd.chatselector.StartSession(this, TRUE);
			theApp.emuledlg->chatwnd.chatselector.SendMessage("AUTOMATED MESSAGE: You're being banned because your client is leeching!");
			theApp.emuledlg->chatwnd.chatselector.EndSession(this);
			AddLogLine(false, IDS_SENTBAN,GetUserName());
			theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this);
d1081 1
a1081 1
					Ban();
d1121 1
a1121 1
void CUpDownClient::Ban(){
d1135 1
a1135 1
		theApp.emuledlg->chatwnd.chatselector.SendMessage("AUTOMATED MESSAGE: You're being banned because your client is behaving aggressively!");
@


1.75
log
@Removed some Debug logs.
@
text
@a155 3
    // calculate score, based on waitingtime and other factors
	float fBaseValue;

d189 2
d1116 5
@


1.74
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d158 34
@


1.73
log
@Preparing for new sockets
@
text
@d26 1
d500 1
d502 3
d643 2
a645 1
		uint32 endpos = (currentblock->EndOffset - togo);
d647 4
d685 1
d688 4
d716 1
d718 3
d993 1
d1002 10
d1123 3
d1127 1
@


1.72
log
@Preparing for new sockets
@
text
@d195 1
d197 2
a198 10
		if (HasLowID()
#ifdef OLD_SOCKETS_ENABLED
			&& !(socket && socket->IsConnected()) 
#endif //OLD_SOCKETS_ENABLED
			){
			if (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID()
#ifdef OLD_SOCKETS_ENABLED
				|| theApp.listensocket->TooManySockets()
#endif //OLD_SOCKETS_ENABLED
				)
d202 1
d1098 5
a1102 3
	    theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size);
            theApp.clientudp->SendPacket(response,GetIP(),GetUDPPort());
        }
d1141 1
d1143 1
@


1.71
log
@FEATURE: en/disable banning optional [DoubleT]
@
text
@d196 10
a205 2
		if (HasLowID() && !(socket && socket->IsConnected()) ){
			if (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID() || theApp.listensocket->TooManySockets())
d801 1
d849 1
d870 1
d877 1
d896 1
d898 1
d990 1
d992 1
d1018 1
d1020 1
@


1.70
log
@converted to new logger methods
@
text
@d1052 2
@


1.69
log
@don't check client twice if he got full chunk
@
text
@d528 1
a528 1
		AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERRORED),GetUserName(),error.GetBuffer());
d1058 1
a1058 1
	AddDebugLogLine(false,GetResString(IDS_CLIENTBLOCKED),GetUserName());
d1064 1
a1064 1
		AddLogLine(false,GetResString(IDS_SENTBAN),GetUserName());
@


1.68
log
@DoubleT: bug #295 fixed (bypass part blocking on opcode StartUploadReq)
@
text
@d272 2
a273 2
    if(different_part) {
	    //AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
d275 6
a280 6
        // obaldin: this is for old clients, that rotate the chunk,
        // so that they'll be able to download at least _something_
        // But probably even after the majority switches we'd
        // better check for 0 here
        if(GetSessionUp() < 1024*1024) {
            different_part = false;
d283 2
a284 2
        }
    }
d349 2
a350 4
	bool diff_part=IsDifferentPartBlock(true);	//Cax2 - don't write anyting to the log yet! 
	bool shouldGo=(GetUpStartTimeDelay() >= 80*60*1000 || diff_part);
	//bool shouldGo = false;
	//bool diff_part = false;
d359 10
a368 6
			//SetWaitStartTime();
			//theApp.uploadqueue->RemoveFromUploadQueue(this);
			//theApp.uploadqueue->AddClientToQueue(this,true);
			if(diff_part)
				AddDebugLogLine(false, "Client %s (%s)  back on queue. Asked for a new chunk/file, after receiving %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
			return false;
d374 1
d783 5
a787 5
//	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
	if ((curTick-GetLastGotULData() > 2*60*1000)  && (GetUpStartTimeDelay()>2*60*1000)) {
        // were unable to transfer for 2 minutes, put the client back on queue
        AddDebugLogLine(false, "Client %s(%s) appears to be stuck, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
        SetWaitStartTime();
d793 5
a797 5

    // Only feed this slot new data if it has been able to empty its
    // buffer since we last offered it data
    if (socket && !socket->IsBusy() && GetUploadState() == US_UPLOADING) {
		if (m_BlockSend_queue.IsEmpty()) {	// eklmn: bugfix(03): keeping user in queue if he doesn't need anything
a799 4
				AddDebugLogLine(false, "No more data to send to client %s(%s), should be back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
				SetWaitStartTime();
				theApp.uploadqueue->RemoveFromUploadQueue(this);
				theApp.uploadqueue->AddClientToQueue(this,true);
d803 5
a807 4

        // Feed data to this slot, one block at a time, as long as there's
        // enough bandwidth left for the entire next block.
        // There must also be blocks to send (not empty request queue)
d809 1
a809 1
            // Get next block and give it to the socket for transfer
d813 1
a813 1
            //socket->ResetTimeOutTimer();
d815 1
a815 1
            // We've transfered some data. Store this in relevant statistics variables
d817 1
a817 1
            amounttransfered += nBlockSize;
d822 1
a822 1
            // If we're out of prepared blocks, create some more
d827 6
a832 5
        // If this slot wasn't given enough data to empty it's request queue, 
        // it wants more data.
        if(!m_BlockSend_queue.IsEmpty()) {
            wantsMoreBandwidth = true;
        }
d834 5
a838 5
        // Remember when this connection was last fed some data, so we
        // can make sure we give it data often enough to not time out.
        if(amounttransfered > 0) {
            SetLastGotULData();
        }
@


1.67
log
@minor changes
@
text
@d409 15
d468 1
a468 1
			if( togo > 184320 )
@


1.66
log
@BUGFIX: no full chunk transfer for user outside the LAN [Eklmn]
BUGFIX: keeping user in queue if he doesn't need anything [Eklmn]
@
text
@d263 1
a263 1
			if ( last_done_part != next_requested_part || memcmp(last_done_block->FileID, next_requested_block->FileID, 16) != 0)
d616 1
a616 1
		memcpy(&packet->pBuffer[0],reqfileid,16);
d653 1
a653 1
		memcpy(&packet->pBuffer[0],reqfileid,16);
d694 1
a694 1
		memcpy(reqfileid,tempreqfileid,16);
d859 2
a860 2
	CMemFile* data = new CMemFile();
	data->Write(file->GetFileHash(),16);
d862 4
a865 4
	data->Write(&parts,2);
	for (int i = 0; i != parts; i++)
		data->Write(file->GetPartHash(i),16);
	Packet* packet = new Packet(data);
a866 1
	delete data;
d975 2
a976 2
	CMemFile *data = new CMemFile();
	data->Write(&rating,sizeof(rating));
d978 6
a983 4
	if (length>128) length=128;
	data->Write(&length,sizeof(length));
	if (length>0) data->Write(desc.GetBuffer(),length);
	Packet *packet = new Packet(data,OP_EMULEPROT);
a984 1
	delete data;
d994 1
a994 1
		if (!memcmp(cur_struct->fileid,fileid,16)){
d1012 1
a1012 1
	memcpy(new_struct->fileid,fileid,16);
@


1.65
log
@coverted code from char * to CString
@
text
@d339 4
a342 5
	// time critical
	// check if we should kick this client
    // Never kick friends
    // Always kick if transfer is longer than 80 minutes
    // Never allow more than the size of a chunk (+500 KBytes for small resends of invalid data) to be transfered
d344 1
a344 1
    // Note: Full chunk transfers really should be enforced, not an option
d347 9
a355 10
    bool AllowedMore = isOnLAN();	
	bool shouldGo = false;
	bool diff_part = false;

	if (AllowedMore)
	{
		diff_part=IsDifferentPartBlock(true);	//Cax2 - don't write anyting to the log yet! 
		shouldGo=(GetUpStartTimeDelay() >= 80*60*1000 || diff_part);
		if(shouldGo && IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this))
		{
d359 2
a360 3

		if (!AllowedMore && shouldGo)
		{
d364 2
a365 2
            if(diff_part)
                AddDebugLogLine(false, "Client %s (%s)  back on queue. Asked for a new chunk/file, after receiving %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
a366 1
		}
d368 6
d375 1
a375 7
	if(m_BlockRequests_queue.IsEmpty()) {
        // There are no new blocks requested, put we will happily transfer more
        // if the client just requests something
        return true;
    }

    CFile file;
d379 1
a379 1
    bool have_something = false;
d779 9
a787 7
		if (m_BlockSend_queue.IsEmpty() && !CreateNextBlockPackage()) {
            // no valid blocks to transfer. Put the client back on queue
			AddDebugLogLine(false, "No more data to send to client %s(%s), should be back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
            SetWaitStartTime();
		    theApp.uploadqueue->RemoveFromUploadQueue(this);
		    theApp.uploadqueue->AddClientToQueue(this,true);
		    return 0;
@


1.64
log
@fix for Jumpstart insisting on turning itself on
@
text
@d381 1
a381 1
	char* fullname = 0;
d407 4
a410 5
				fullname = nstrdup(((CPartFile*)srcfile)->GetFullName());
				fullname[strlen(fullname)-4] = 0;			
			} else{
				fullname = new char[strlen(srcfile->GetPath())+strlen(srcfile->GetFileName())+10];
				sprintf(fullname,"%s\\%s",srcfile->GetPath(),srcfile->GetFileName());
d462 1
a462 3
					throw GetResString(IDS_ERR_OPEN);
				delete[] fullname;
				fullname = 0;
d473 1
a473 3
				CPartFile* partfile = (CPartFile*)srcfile;
				delete[] fullname;
				fullname = 0;
d517 1
a517 3
			delete filedata;
		if (fullname)
			delete[] fullname;
@


1.63
log
@complete sources column
@
text
@d286 3
d290 14
a303 10
    if(last_done_part == 0xffffffff || different_part) {
        if(next_requested_part == 0xffffffff && !m_BlockRequests_queue.IsEmpty()) {
            next_requested_block = (Requested_Block_Struct*)m_BlockRequests_queue.GetHead();
            next_requested_part = next_requested_block->StartOffset / PARTSIZE;
        }
        if(next_requested_part != 0xffffffff) {
            CKnownFile* kf = theApp.sharedfiles->GetFileByID(next_requested_block->FileID);
            if(kf->IsJsChunkComplete(next_requested_part)) {
                AddDebugLogLine(false, "Jumpstart DEBUG: Client %s is getting an already completed chunk",GetUserName()); 
            }
d306 3
a309 2
	return different_part; 
}
d382 3
d390 11
d512 3
@


1.62
log
@Fixed bug 271 by katsyonak
@
text
@d78 1
a78 1
bool CUpDownClient::IsCommunity()               
d176 1
a176 1
		fBaseValue *= 2.0f;	
d365 1
a365 1
    if(m_BlockRequests_queue.IsEmpty()) {
d539 1
d555 1
a555 1
		if (tempreqfile->GetPartCount() != m_nUpPartCount){			
d577 4
d582 1
d584 1
a584 1
	
d1090 1
a1090 1
	
@


1.61
log
@L2HAC by EnkeyDev
@
text
@d1008 1
a1008 1
//	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this, true, true);
@


1.60
log
@removed duplicated code
@
text
@d1038 1
@


1.59
log
@fixed memory leak
@
text
@d78 1
a78 1
bool CUpDownClient::IsCommunity()                
d85 2
a86 4
        CString copy2(theApp.glob_prefs->CommunityString()); 
        copy1.MakeUpper(); 
        copy2.MakeUpper(); 
        iscommunity = (copy1.Find(copy2) >= 0); 
d175 2
a176 10
	if (theApp.glob_prefs->CommunityEnabled())
	{
		// DonGato (Community Sharing)
		CString c1(m_pszUsername);
		CString c2(theApp.glob_prefs->CommunityString());
		bool iscommunity = (c1.MakeUpper().Find(c2.MakeUpper()) != -1);

		if (iscommunity)
			fBaseValue *= 2.0f;
	}
d1083 1
a1083 12
	// Community Sharing
	bool iscommunity = false;
    if(m_pszUsername) {
	    char *copy1, *copy2;
	    copy1 = _strupr( _strdup( m_pszUsername ) );
	    copy2 = _strupr( _strdup( theApp.glob_prefs->CommunityString() ) );
	    if (copy1 && copy2)
		    iscommunity = (strstr(copy1 ,copy2) != NULL );
	    free(copy1);
	    free(copy2);
    }

d1089 2
a1090 1
	if (theApp.glob_prefs->CommunityEnabled() && iscommunity) fBaseValue *= 2.0f;
@


1.58
log
@checking community string only when it is enabled
@
text
@d553 1
a553 1
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
d555 1
a555 1
	data->Read(cfilehash,16);
d557 1
a557 1
	data->Read(&m_nUpPartCount,2);
d564 1
a564 2
		if (tempreqfile->GetPartCount() != m_nUpPartCount){
			delete data;	//mf
d572 1
a572 1
			data->Read(&toread,1);
d588 1
a588 2
	delete data;

@


1.57
log
@Jumpstart logging fix
@
text
@d118 1
a118 8
	// DonGato (Community Sharing)
	char *copy1, *copy2;
	copy1 = _strupr( _strdup(m_pszUsername));
	copy2 = _strupr( _strdup(theApp.glob_prefs->CommunityString()));
	bool iscommunity = (strstr(copy1 ,copy2) != NULL);
	free(copy1);
	free(copy2);

d179 5
@


1.56
log
@Jumpstart debug runtime check
@
text
@d296 2
d299 4
a302 3
        CKnownFile* kf = theApp.sharedfiles->GetFileByID(next_requested_block->FileID);
        if(kf->IsJsChunkComplete(next_requested_part)) {
            AddDebugLogLine(false, "Jumpstart DEBUG: Client %s is getting an already completed chunk",GetUserName()); 
d304 7
a311 3


    }
@


1.55
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d296 8
@


1.54
log
@*** empty log message ***
@
text
@d717 1
a717 1
    DWORD curTick = ::GetTickCount();
d721 1
a721 1
        m_AvarageUDR_list.GetCount() >= 2) {
d728 3
a730 3
        if((m_avarage_UL_tick_list.GetTail()-m_avarage_UL_tick_list.GetHead()) > 10*1000) {
	        m_nUpDatarate = (uint32)(((float)(m_AvarageUDR_list.GetTail()-m_AvarageUDR_list.GetHead()))*1000 / (m_avarage_UL_tick_list.GetTail()-m_avarage_UL_tick_list.GetHead()));
        } else {
a731 1
        }
d804 1
a804 1
	if(m_avarage_UL_tick_list.IsEmpty() || curTick >= m_avarage_UL_tick_list.GetTail()+500)	//Cax2 - update no faster than every .5 sec
d806 2
a807 2
		m_AvarageUDR_list.AddTail(m_nTransferedUp);
		m_avarage_UL_tick_list.AddTail(curTick);
d810 3
a812 3
		while(curTick-m_avarage_UL_tick_list.GetHead() > 40000) {
   			m_AvarageUDR_list.RemoveHead();
			m_avarage_UL_tick_list.RemoveHead();
@


1.54.2.1
log
@27a partial merge
@
text
@d134 1
a134 1
        ASSERT(GetUploadFileID() != NULL); // i_a: reqfileid is an array so the if() was superfluous 
d208 1
a208 1
		if (sysvalue && HasLowID() && !(socket && socket->IsConnected()) ){
d470 1
a470 1
			srcfile->statistic.AddTransferred(togo);
a492 1
		SetUploadFileID(NULL);
d595 1
a595 1
		memcpy(&packet->pBuffer[0],GetUploadFileID(),16);
d632 1
a632 1
		memcpy(&packet->pBuffer[0],GetUploadFileID(),16);
d695 18
@


1.54.2.2
log
@27c
@
text
@d463 2
a464 10
			SetUploadFileID(currentblock->FileID);

			// check extention to decide whether to compress or not
			CString ext=srcfile->GetFileName();ext.MakeLower();
			int pos=ext.ReverseFind('.');
			if (pos>-1) ext=ext.Mid(pos);
			bool compFlag=(ext!=".zip" && ext!=".rar" && ext!=".ace" && ext!=".ogm" );
			if (ext==".avi" && theApp.glob_prefs->GetDontCompressAvi()) compFlag=false;

			if (m_byDataCompVer == 1 && compFlag )
@


1.53
log
@better lancast support & clearer error log messages
@
text
@d671 8
@


1.52
log
@bugfix: less resource usage, fixed bug #131
@
text
@d241 1
a241 1
bool CUpDownClient::IsDifferentPartBlock() // [Tarod 12/22/2002] 
a249 1
	
d263 1
d274 3
d284 1
a284 1
    if(different_part == true) {
d291 1
a291 1
        if(this->GetSessionUp() < 1024*1024) {
d293 2
a294 1
			AddDebugLogLine(false, "Debug: Not switching because of a low transferred size"); 
d336 2
a337 1
    bool friendAllowedMore = false;
d341 3
a343 3
	// LANCAST (moosetea) We never kick a lancast user
	if (!isOnLAN()) {
        diff_part=IsDifferentPartBlock();
d347 2
a348 2
			friendAllowedMore = true;
			AddDebugLogLine(false, "Debug: User %s, a friend, got %u Kbs and keeps going", GetUserName(), this->GetSessionUp() / 1024); 
d351 1
a351 1
		if (!friendAllowedMore && shouldGo)
d357 1
a357 1
                AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk/file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d374 1
a374 1
		while (!m_BlockRequests_queue.IsEmpty() && (friendAllowedMore || !IsDifferentPartBlock()))	//Cax2 - if a friend, don't repeat messages
d391 2
a392 4
            // Friends get special treatment. Check if it's a friend with a friends slot
            if(IsFriend()) {
                // Friends are not limited to a single chunk

d753 1
a753 1
            AddDebugLogLine(false, "Client %s(%s) has no blocks to transfer, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
@


1.51
log
@reinstate buffer flush on timeout
@
text
@d794 4
a797 8
	m_AvarageUDR_list.AddTail(m_nTransferedUp);
    m_avarage_UL_tick_list.AddTail(curTick);

    // Don't store more than 40 seconds of statistics
    while(curTick-m_avarage_UL_tick_list.GetHead() > 40*1000) {
   	    m_AvarageUDR_list.RemoveHead();
        m_avarage_UL_tick_list.RemoveHead();
    }
d799 6
@


1.50
log
@converted to new logging method
@
text
@d110 1
d114 1
@


1.49
log
@jumpstart fixes
@
text
@d265 1
a265 1
				//theApp.emuledlg->AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d270 1
a270 1
                //theApp.emuledlg->AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d280 1
a280 1
	    //theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
d288 1
a288 1
			theApp.emuledlg->AddDebugLogLine(false, "Debug: Not switching because of a low transferred size"); 
d341 1
a341 1
			theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, a friend, got %u Kbs and keeps going", GetUserName(), this->GetSessionUp() / 1024); 
d350 1
a350 1
                theApp.emuledlg->AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk/file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024);
d486 1
a486 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERRORED),GetUserName(),error.GetBuffer());
d494 1
a494 1
//	theApp.emuledlg->AddDebugLogLine(false,"Debug: Packet done. Size: %i",blockpack->GetLength());
d735 1
a735 1
        theApp.emuledlg->AddDebugLogLine(false, "Client %s(%s) appears to be stuck, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
d748 1
a748 1
            theApp.emuledlg->AddDebugLogLine(false, "Client %s(%s) has no blocks to transfer, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
d1005 1
a1005 1
	theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_CLIENTBLOCKED),GetUserName());
d1011 1
a1011 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_SENTBAN),GetUserName());
@


1.48
log
@crashfix
@
text
@d265 1
a265 1
				theApp.emuledlg->AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d270 1
a270 1
               theApp.emuledlg->AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d332 2
d336 2
a337 1
		shouldGo=(GetUpStartTimeDelay() >= 4800000 || IsDifferentPartBlock());	//80*60*1000 = 4800000
d349 2
@


1.47
log
@some sorting bugfixes
@
text
@d1064 10
a1073 9
	char *copy1, *copy2;
	copy1 = _strupr( _strdup( m_pszUsername ) );
	copy2 = _strupr( _strdup( theApp.glob_prefs->CommunityString() ) );
	bool iscommunity;
	if (copy1 && copy2)
		iscommunity = (strstr(copy1 ,copy2) != NULL );
	else iscommunity = false;
	free(copy1);
	free(copy2);
@


1.46
log
@adds line to normal log when sending an automated ban message
@
text
@d1056 2
a1057 2
	// Myself Bot user?
	bool bIsBotuser;	//we still assume that the other client 'punishes' us if our name is 'wrong'
d1062 1
a1062 1

d1075 1
a1075 1
	if (bIsBotuser) fBaseValue *= 0.9f;
@


1.45
log
@Changes protected by a #define, should have no effect
@
text
@d1006 1
a1006 1
		theApp.emuledlg->AddDebugLogLine(false,"Sent ban message to user: %s" ,GetUserName());
@


1.44
log
@bugfix: status bar mem leak - Maella
@
text
@d466 8
@


1.43
log
@pdated the banning message
@
text
@a36 2
CBarShader CUpDownClient::s_UpStatusBar(16);

d40 9
a48 28
	COLORREF crBoth; 
	COLORREF crNeither; 
/*	COLORREF crClientOnly; 
	COLORREF crPending = RGB(255,208,0);
	COLORREF crNextPending = RGB(255,255,100);
	//--- xrmb:seetheneed ---
	COLORREF crMeOnly = RGB(190,190,255); 
	//--- :xrmb ---
*/
    COLORREF crBeingSent = RGB(255,208,0);

	if(bFlat) { 
		crBoth = RGB(0, 150, 0);
		crNeither = RGB(224, 224, 224);
		//crClientOnly = RGB(0, 0, 0);
	} else { 
		crBoth = RGB(0, 192, 0);	//Cax2 - same green used for files & clients
		crNeither = RGB(240, 240, 240);
		//crClientOnly = RGB(95, 95, 95);
	} 


    uint32 filesize = PARTSIZE*(m_nUpPartCount); // might be a little off.. better than nothing

	s_UpStatusBar.SetFileSize(filesize); 
	s_UpStatusBar.SetHeight(rect->bottom - rect->top); 
	s_UpStatusBar.SetWidth(rect->right - rect->left); 
	s_UpStatusBar.Fill(crNeither); 
d50 2
a51 1
	if (!onlygreyrect && m_abyUpPartStatus) { 
a54 1
			//--- xrmb:seetheneed --- & Cax2 graphic glitch fix
d63 1
a63 13
                /*
				// do i have it ?
				if  (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))
					s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crBoth); 
				else if (m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && 
                                                     m_nLastBlockOffset >= PARTSIZE*i)
						s_StatusBar.FillRange(PARTSIZE*i, uEnd, crPending);
				else if (gettingParts.GetAt(i) == 'Y')
					s_StatusBar.FillRange(PARTSIZE*i, uEnd, crNextPending);
	    		else
					s_StatusBar.FillRange(PARTSIZE*i, uEnd, crClientOnly);
                */
                s_UpStatusBar.FillRange(PARTSIZE*i, uEnd, crBoth); // will do for now
d65 2
a66 6
			else //they don't have a part. Do I have it?
                /*
				if (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1)) 
					s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crMeOnly); 
                */
                s_UpStatusBar.FillRange(PARTSIZE*i, uEnd, crNeither);
d69 1
a69 1
                    s_UpStatusBar.FillRange(PARTSIZE*i,  uEnd, crBeingSent);
d72 1
a72 1
   	s_UpStatusBar.Draw(dc, rect->left, rect->top, bFlat); 
@


1.42
log
@Protection from on-disk hashset corruption, proper check that we already have the data before sending
@
text
@d1033 1
a1033 1
		theApp.emuledlg->chatwnd.chatselector.SendMessage("You're being banned because your client is behaving aggressively!");
@


1.41
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d453 4
a456 1
				if (srcfile->IsPartFile() && !((CPartFile*)srcfile)->IsComplete(currentblock->StartOffset,currentblock->EndOffset-1))
d458 1
@


1.40
log
@prevent stuck clients
@
text
@d368 9
a376 6
	bool shouldGo=(GetUpStartTimeDelay() >= 4800000 || IsDifferentPartBlock());	//80*60*1000 = 4800000
    if(shouldGo && IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this))
	{
		friendAllowedMore = true;
		theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, a friend, got %u Kbs and keeps going", GetUserName(), this->GetSessionUp() / 1024); 
    }
d378 7
a384 6
	if (!friendAllowedMore && shouldGo)
	{
		//SetWaitStartTime();
		//theApp.uploadqueue->RemoveFromUploadQueue(this);
		//theApp.uploadqueue->AddClientToQueue(this,true);
		return false;
@


1.39
log
@Paused files shown in grey and Selected search methos stored between sessions.
@
text
@d307 1
a307 1
               theApp.emuledlg->AddDebugLogLine(false, "Session for user %s(%s v%s) ended due to different file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d413 1
a413 1
            if(IsFriend() && GetFriendSlot()) {
d417 1
a417 1
                if (currentblock->StartOffset > currentblock->EndOffset){
d746 13
d764 1
@


1.38
log
@Ban message code updated!
@
text
@d1013 1
a1013 1
		theApp.emuledlg->AddDebugLogLine(false,"Sent ban message to the following user: %s" ,GetUserName());
@


1.37
log
@adjust offsets
@
text
@d1007 1
d1012 2
d1016 1
a1016 1
	theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_CLIENTBLOCKED),GetUserName());
@


1.36
log
@Ops! Didn't start the session on the banning message send before sending it. :-S
@
text
@d433 1
a433 1
                if(currentblock->StartOffset/PARTSIZE != currentblock->EndOffset/PARTSIZE) {
d436 1
a436 1
                    currentblock->EndOffset = ((uint32)(currentblock->StartOffset/PARTSIZE)+1)*PARTSIZE-1;
@


1.35
log
@Bugfixes and some simplifying of code
@
text
@d1008 2
d1011 1
@


1.34
log
@version displaying in messages, fixes in chunk selection
@
text
@d1097 2
@


1.33
log
@minor bugfixes, refreshes sources display...
@
text
@d302 1
a302 1
				theApp.emuledlg->AddDebugLogLine(false, "Session for user %s ended due to new chunk, sent %u Kbs.", GetUserName(), GetSessionUp() / 1024); 
d307 1
a307 1
               theApp.emuledlg->AddDebugLogLine(false, "Session for user %s ended due to different file, sent %u Kbs.", GetUserName(), GetSessionUp() / 1024); 
@


1.32
log
@Added again Confirm on exit. :-)
@
text
@d276 1
a276 1
bool CUpDownClient::IsDifferentPartBlock(void) // [Tarod 12/22/2002] 
d302 1
a302 1
        	    theApp.emuledlg->AddDebugLogLine(false, "Session for user %s ended due to new chunk, sent %u Kbs.", GetUserName(), GetSessionUp() / 1024); 
d307 1
a307 1
        	    theApp.emuledlg->AddDebugLogLine(false, "Session for user %s ended due to different file, sent %u Kbs.", GetUserName(), GetSessionUp() / 1024); 
d325 1
a325 1
    	    theApp.emuledlg->AddDebugLogLine(false, "Debug: Not switching because of a low transferred size"); 
d368 5
a372 7
    if(GetUpStartTimeDelay() >= 80*60*1000 || IsDifferentPartBlock()) {
        if(IsFriend()) {
            if(!theApp.uploadqueue->CheckForTimeOver(this)) {
                 friendAllowedMore = true;
                 theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, a friend, got %u Kbs and keeps going", GetUserName(), this->GetSessionUp() / 1024); 
            }
        }
d375 2
a376 4
	if (!friendAllowedMore &&
        (GetUpStartTimeDelay() >= 80*60*1000 ||
         IsDifferentPartBlock())) {

d395 2
a396 3
		while (!m_BlockRequests_queue.IsEmpty() &&
               (IsDifferentPartBlock() == false ||
                friendAllowedMore)){
@


1.31
log
@Banning Message, A4AF customization, AutoPriority fix, Static Servers fix, .dat/.bin Preview
@
text
@a152 4
	//Cax2: removed bot user & low id 'punishments' . 
	// Bot user?
	//m_bIsBotuser = (strstr(m_pszUsername, "edk-files") || strstr(m_pszUsername, "finder")) && strstr(m_pszUsername, "com");

a153 1
	// Maverick only 1 community possible
d155 3
a157 5
	copy1 = _strupr( _strdup( m_pszUsername ) );
	copy2 = _strupr( _strdup( "[" + theApp.glob_prefs->CommunityString() + "]") );
	bool iscommunity = (strstr(copy1 ,copy2) != NULL );
	if (iscommunity) 
		iscommunity = ((strchr(copy1,'[') == strrchr(copy1,'[')) || (strchr(copy1,']') == strrchr(copy1,']')));
@


1.31.2.1
log
@v1a upgrade
@
text
@d153 4
d158 1
d160 5
a164 3
	copy1 = _strupr( _strdup(m_pszUsername));
	copy2 = _strupr( _strdup(theApp.glob_prefs->CommunityString()));
	bool iscommunity = (strstr(copy1 ,copy2) != NULL);
d283 1
a283 1
bool CUpDownClient::IsDifferentPartBlock() // [Tarod 12/22/2002] 
d309 1
a309 1
				theApp.emuledlg->AddDebugLogLine(false, "Session for user %s (%s) ended due to new chunk, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d314 1
a314 1
               theApp.emuledlg->AddDebugLogLine(false, "Session for user %s(%s) ended due to different file, sent %u Kbs.", GetUserName(), GetClientNameAndVersionString(this), GetSessionUp() / 1024); 
d332 1
a332 1
			theApp.emuledlg->AddDebugLogLine(false, "Debug: Not switching because of a low transferred size"); 
d375 7
a381 5
	bool shouldGo=(GetUpStartTimeDelay() >= 4800000 || IsDifferentPartBlock());	//80*60*1000 = 4800000
    if(shouldGo && IsFriend() && !theApp.uploadqueue->CheckForTimeOver(this))
	{
		friendAllowedMore = true;
		theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, a friend, got %u Kbs and keeps going", GetUserName(), this->GetSessionUp() / 1024); 
d384 4
a387 2
	if (!friendAllowedMore && shouldGo)
	{
d406 3
a408 2
		while (!m_BlockRequests_queue.IsEmpty() && (friendAllowedMore || !IsDifferentPartBlock()))	//Cax2 - if a friend, don't repeat messages
		{
d445 1
a445 1
                if(currentblock->StartOffset/PARTSIZE != (currentblock->EndOffset - 1)/PARTSIZE) {
d448 1
a448 1
                    currentblock->EndOffset = ((uint32)(currentblock->StartOffset/PARTSIZE)+1)*PARTSIZE;
a757 12

    // check for 'stuck' clients
	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
        // were unable to transfer for 2 minutes, put the client back on queue
        theApp.emuledlg->AddDebugLogLine(false, "Client %s(%s) appears to be stuck, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
        SetWaitStartTime();
		theApp.uploadqueue->RemoveFromUploadQueue(this);
		theApp.uploadqueue->AddClientToQueue(this,true);
		return 0;
	}


a762 1
            theApp.emuledlg->AddDebugLogLine(false, "Client %s(%s) has no blocks to transfer, putting back on queue", GetUserName(), GetClientNameAndVersionString(this)); 
a1019 2
	{
		theApp.emuledlg->chatwnd.chatselector.StartSession(this, TRUE);
a1020 1
	}
a1108 2
	if(credits == (CClientCredits*)-1)
		credits = NULL;
@


1.31.2.2
log
@keeping in sync with the main cvs line
@
text
@d413 1
a413 1
            if(IsFriend()) {
d417 1
a417 1
                if (currentblock->StartOffset > currentblock->EndOffset-1){
d748 1
a748 2
//	if ((GetSessionUp()==0) && (GetUpStartTimeDelay()>2*60*1000)) {
	if ((curTick-GetLastGotULData() > 2*60*1000)  && (GetUpStartTimeDelay()>2*60*1000)) {
a1019 1
	theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_CLIENTBLOCKED),GetUserName());
a1023 2
		theApp.emuledlg->chatwnd.chatselector.EndSession(this);		// now it automatically closes the session afterwards
		theApp.emuledlg->AddDebugLogLine(false,"Sent ban message to user: %s" ,GetUserName());
d1026 1
a1026 1

@


1.30
log
@Show the uploaded part number the Uploads
@
text
@d1019 2
@


1.29
log
@better handling of friends
@
text
@d51 2
a73 1
		        uint32 uEnd = filesize;
d81 1
d104 3
d205 2
a206 4
	// friend slot
	if (IsFriend() && GetFriendSlot())
		return 0xFFFFFFFF;
	// calculate score, based on waitingtime and other factors
d1112 11
@


1.28
log
@the famous zz upload system! :)
@
text
@d306 1
a306 1
				theApp.emuledlg->AddDebugLogLine(false, "Session ended due to new chunk.");
d311 1
a311 1
				theApp.emuledlg->AddDebugLogLine(false, "Session ended due to different file.");
d321 2
a322 1
	    theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
d327 1
a327 1
        if(this->GetTransferedUp() < 1024*1024) {
d370 12
a381 1
	if (!(IsFriend() && GetFriendSlot()) &&
d405 1
a405 1
                IsFriend() && GetFriendSlot())){
@


1.27
log
@End of double check with official code.
@
text
@a288 7
    // obaldin: this is for old clients, that rotate the chunk,
    // so that they'll be able to download at least _something_
    // But probably even after the majority switches we'd
    // better check for 0 here
    if(this->GetTransferedUp() < 1024*1024) {
        return false;
    }
d318 1
a318 4
   	} 
	//theApp.emuledlg->AddDebugLogLine(false, "User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
	// obaldin: this message was causing a high cpu load for users, so we comment it out.
	// NB: When (if) we have time, see why the catch(...) is used here
d320 11
d364 3
a366 3
	// DonGato [By VQB]
	if (theApp.glob_prefs->TransferFullChunks())
	{
d368 8
a375 6
	if ( theApp.uploadqueue->CheckForTimeOver(this) || IsDifferentPartBlock())
	{
		SetWaitStartTime();
		SetAskedCount(0);
		theApp.uploadqueue->RemoveFromUploadQueue(this);
		theApp.uploadqueue->AddClientToQueue(this,true);
d378 8
a385 14
	} else {
		if (theApp.uploadqueue->CheckForTimeOver(this))
		{
			// back on the waitqueue
			SetWaitStartTime();
			theApp.uploadqueue->RemoveFromUploadQueue(this);
			theApp.uploadqueue->AddClientToQueue(this,true);
			return false;
		}
	}
	if (m_BlockRequests_queue.IsEmpty()){
		return false;
	}
	CFile file;
d389 5
a393 1
		while (!m_BlockRequests_queue.IsEmpty()){
d402 1
a402 2
			}
			else{
d406 40
a445 7
		
			uint32 togo;
			if (currentblock->StartOffset > currentblock->EndOffset){
				togo = currentblock->EndOffset + (srcfile->GetFileSize() - currentblock->StartOffset);
			}
			else{
				togo = currentblock->EndOffset - currentblock->StartOffset;
a447 1
			}
d609 2
a610 1
		m_BlockSend_queue.AddTail(packet);
d645 2
a646 1
		m_BlockSend_queue.AddTail(packet);
d652 26
d716 17
a732 15
uint32 CUpDownClient::SendBlockData(uint32 nMaxAmmount){
	EMULE_TRY
	// START - enkeyDEV(Ottavio84) -Accurate speed measurement-
	TransferredData newitem = {dataratems, GetTickCount()};
	m_AvarageUDR_list.AddTail(newitem);
	sumavgudr += dataratems;
	if (m_AvarageUDR_list.GetCount() > 200)
		sumavgudr -= m_AvarageUDR_list.RemoveHead().datalen;

	float deltat = (float)(m_AvarageUDR_list.GetTail().timestamp - m_AvarageUDR_list.GetHead().timestamp) / 1000.0;
	if (deltat > 0.0) 
        m_nUpDatarate = (uint32)((float)sumavgudr / deltat);
	else
		m_nUpDatarate = 0;
	// END - enkeyDEV(Ottavio84) -Accurate speed measurement-
a733 3
	m_cSendblock++;
	if (m_cSendblock == 30){
		m_cSendblock = 0;
d735 1
d737 15
a751 6
	dataratems = 0;
	if (socket && !socket->IsBusy()){
		
		if (m_BlockSend_queue.IsEmpty()){
			if (!CreateNextBlockPackage())
				return 0;
d753 6
a758 29
        // obaldin: applied enhancements by Maella
        // Splitting packets if necessary
        // Remark: - don't use 2*MAXFRAGSIZE (see CEMSocket::Send()), otherwise the 
        //           counter m_nMaxSendAllowed will trigged the sending of two TCP packets
        //           of 1300 (2*1300) at the same time => increase the ping of the application.
        //         - should be moved to CreateNextBlockPackage()
		if (m_BlockSend_queue.GetHead()->GetRealPacketSize() > 0/*m_nMaxSendAllowed*3*/
			&& m_BlockSend_queue.GetHead()->GetRealPacketSize() > MAXFRAGSIZE*2){
			// splitting packets
				uint32 nSize = m_BlockSend_queue.GetHead()->GetRealPacketSize();
				const char* pBuffer = m_BlockSend_queue.GetHead()->DetachPacket();
				delete m_BlockSend_queue.RemoveHead();
				
				uint32 nPos = nSize;
				bool bLast = true;
				while (nPos){
					uint32 nNewSize = (nPos < MAXFRAGSIZE) ? nPos : MAXFRAGSIZE;
					nPos -= nNewSize;
					char* pBuffer2 = new char[nNewSize];
					memcpy(pBuffer2,pBuffer+nPos,nNewSize);
					m_BlockSend_queue.AddHead(new Packet(pBuffer2,nNewSize,bLast));
					bLast = false;
				}
				delete[] pBuffer;
		}
		m_nMaxSendAllowed += nMaxAmmount;
		while (!socket->IsBusy() && !m_BlockSend_queue.IsEmpty()
			&& m_BlockSend_queue.GetHead()->GetRealPacketSize() <= m_nMaxSendAllowed){
			
a760 3
			m_nMaxSendAllowed -= nBlockSize;
//			theApp.uploadqueue->AddUpDataOverheadOther(0, 24);
            dataratems += nBlockSize;
d762 10
a774 4
        // Update credits
        m_nTransferedUp += dataratems;
        theApp.UpdateSentBytes(dataratems);
        credits->AddUploaded(dataratems);
d776 25
a800 5
        // Return the real size of sent packet(s) => true bandwidth (it means less wrong here)
        return dataratems;
	}
	EMULE_CATCH
	return 0;
@


1.26
log
@Code clean up and double check wit official code.
@
text
@a217 4
	/*if (m_bIsBotuser)	//Cax2 removed 'punishments'
		fBaseValue *= 0.9f;
	if (HasLowID())
		fBaseValue *= 0.8f;*/
a928 1
	//merge fix, restored to full functionality - spotted by Maverick
@


1.25
log
@minor updates & bugfixes
@
text
@d330 1
a330 1
	//theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
@


1.24
log
@applied Maella's upload optimizations
@
text
@d44 3
a46 3
	COLORREF crClientOnly; 
	COLORREF crPending;
	COLORREF crNextPending;
d48 1
a48 1
	COLORREF crMeOnly; 
d50 1
a50 1

d54 1
a54 3
		crClientOnly = RGB(0, 0, 0);
		crPending = RGB(255,208,0);
		crNextPending = RGB(255,255,100);
d56 1
a56 1
		crBoth = RGB(0, 192, 0);
d58 1
a58 3
		crClientOnly = RGB(104, 104, 104);
		crPending = RGB(255, 208, 0);
		crNextPending = RGB(255,255,100);
d60 1
a60 3
		//--- xrmb:seetheneed ---
		crMeOnly = RGB(190,190,255);
		//--- :xrmb --
@


1.23
log
@SF & RF ratios bugfixed, added 'type' options to filedonkey search
@
text
@d694 6
a699 1
		m_nMaxSendAllowed += nMaxAmmount;
d704 1
a704 1
				char* pBuffer = m_BlockSend_queue.GetHead()->DetachPacket();
d719 2
a720 1
		while (!m_BlockSend_queue.IsEmpty()
d727 1
a728 5
			m_nTransferedUp += nBlockSize;
			//if (theApp.glob_prefs->TransferFullChunks())
			//	m_nSessionUp += nBlockSize; // VQB Transfer Session Value
			theApp.UpdateSentBytes(nBlockSize);
			credits->AddUploaded(nBlockSize);
d732 7
a738 2
		dataratems = nMaxAmmount;
		return nMaxAmmount;
@


1.22
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d274 1
a274 1
	if (srcfile == (CKnownFile*)NULL)
d277 3
a279 3
	// FileRatio holen
	float ratio = srcfile->GetFileRatio() ;
	return (ratio < 1.0f ? 1.0f : ratio) ;
d349 1
a349 1
	if (srcfile == (CKnownFile*)NULL)
d352 5
a356 10
	// Falls der nchste erfragte Block zu einer kleinen Datei bis 100MB gehrt, dann antiproportional Vorrang!
	float filesizeinmb = ((float)srcfile->GetFileSize() / 1048576.0f);
	
	if (filesizeinmb > 0.0f && filesizeinmb < 9.5f) {
		//i.e. Filesize = 100MB->mul = 1.1, 
		//     Filesize =  10MB->mul = 2.0, 
		//     FileSize =  1MB->mul = 10.0
		//     Maximal Push: 100.0
		//float mul = 10.0f / filesizeinmb + 1.0f ;
		//if (mul > 100.0f) mul = 100.0f ;
d359 2
a360 3
		float mul = 9.5f / filesizeinmb ;		// VQB formula
		if (mul > 100.0f) mul = 100.0f ;		// VQB formula
		
@


1.21
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d383 1
a383 1
	if (/*theApp.uploadqueue->CheckForTimeOver(this) &&*/ IsDifferentPartBlock())
d433 3
d495 24
d528 2
a529 1
	if( size == 16 )
d531 1
d729 2
a730 2
			if (theApp.glob_prefs->TransferFullChunks())
				m_nSessionUp += nBlockSize; // VQB Transfer Session Value
@


1.20
log
@not needed
@
text
@d27 7
@


1.19
log
@*** empty log message ***
@
text
@a499 5
    if(!tempreqfile) { // obaldin
		delete data;
		m_nUpPartCount = 0;
		return;
    }
@


1.18
log
@*** empty log message ***
@
text
@d940 1
a940 1
	return GetStatusString((eQState)GetDownloadState());
@


1.17
log
@overhead parameters change
@
text
@d940 1
a940 33
   CString status; 
   switch (GetDownloadState()) { 
      case DS_CONNECTING: 
         status = GetResString(IDS_CONNECTING); 
         break; 
      case DS_CONNECTED: 
         status = GetResString(IDS_ASKING); 
         break; 
      case DS_WAITCALLBACK: 
         status = GetResString(IDS_CONNVIASERVER); 
         break; 
      case DS_ONQUEUE: 
         status = GetResString(IDS_ONQUEUE); 
         break; 
      case DS_DOWNLOADING: 
         status = GetResString(IDS_TRANSFERRING); 
         break; 
      case DS_REQHASHSET: 
         status = GetResString(IDS_RECHASHSET); 
         break; 
      case DS_NONEEDEDPARTS: 
         status = GetResString(IDS_NONEEDEDPARTS); 
         break; 
      case DS_LOWTOLOWIP: 
         status = GetResString(IDS_NOCONNECTLOW2LOW); 
         break; 
      case DS_TOOMANYCONNS: 
         status = GetResString(IDS_TOOMANYCONNS); 
         break; 
      default: 
         status = GetResString(IDS_UNKNOWN); 
   } 
   return status; 
@


1.16
log
@Show the number of remote client's parts
@
text
@d490 1
a490 1
        m_abyUpPartStatus = NULL; //obaldin: 'just in case' fix by jicxicmic
d718 1
a718 1
		theApp.uploadqueue->AddUpDataOverheadOther(tosend->size, 0);
d739 1
a739 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d831 1
a831 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d856 1
a856 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d931 1
a931 1
	    theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size, 0);
@


1.15
log
@merge with a branch fixes
@
text
@d493 1
d524 2
@


1.14
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d221 1
a221 1
	if (GetDownloadState() == DS_DOWNLOADING)
@


1.13
log
@bugfixes & control panel updates
@
text
@d30 78
d292 8
d313 1
a313 1
			if (memcmp(last_done_block->FileID, next_requested_block->FileID, 16) != 0 || last_done_part != next_requested_part)
d316 6
d485 55
d692 1
a692 1
			theApp.uploadqueue->AddUpDataRateMSOverhead(24, 160);
d715 1
d736 1
a736 1
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d828 1
a828 1
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d853 1
a853 1
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d898 1
a898 1
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this, true, true);
d927 4
a930 1
	if (!proxy.UseProxy) theApp.clientudp->SendPacket(response,GetIP(),GetUDPPort());
@


1.13.2.1
log
@initial upgrade to .26
@
text
@a29 20
CBarShader CUpDownClient::s_UpStatusBar(16);
void CUpDownClient::DrawUpStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool  bFlat){
	RECT gaprect;
	gaprect.top = rect->top + 2;
	gaprect.bottom = rect->bottom - 2;
	gaprect.left = rect->left;
	gaprect.right = rect->right;
	dc->FillRect(&gaprect,&CBrush(RGB(220,220,220)));
	if( onlygreyrect )
		return;
	float blockpixel = (float)(rect->right - rect->left)/((float)(PARTSIZE*(m_nUpPartCount))/1024);
	for (uint32 i = 0;i != m_nUpPartCount;i++){ 
		if (m_abyUpPartStatus[i]){ 
			gaprect.right = rect->left + (uint32)(((float)PARTSIZE*i/1024)*blockpixel);
			gaprect.left  = rect->left + (uint32)((float)((float)PARTSIZE*(i+1)/1024)*blockpixel);
			dc->FillRect(&gaprect,&CBrush(RGB(0,0,0)));
		}
	}
}

d227 1
a227 6
			if ( last_done_part != next_requested_part)
			{ 
				different_part = true;
				theApp.emuledlg->AddDebugLogLine(false, "Session ended due to new chunk.");
			}
			if (memcmp(last_done_block->FileID, next_requested_block->FileID, 16) != 0)
a229 1
				theApp.emuledlg->AddDebugLogLine(false, "Session ended due to different file.");
d237 3
a239 1
//	theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
a392 44
void CUpDownClient::ProcessUpFileStatus(char* packet,uint32 size){
	if (m_abyUpPartStatus)
		delete[] m_abyUpPartStatus;
	m_nUpPartCount = 0;
	if( size == 16 )
		return;
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
	uchar cfilehash[16];
	data->Read(cfilehash,16);
	CKnownFile* tempreqfile = theApp.sharedfiles->GetFileByID(cfilehash);
	data->Read(&m_nUpPartCount,2);
	if (!m_nUpPartCount){
		m_nUpPartCount = tempreqfile->GetPartCount();
		m_abyUpPartStatus = new uint8[m_nUpPartCount];
		memset(m_abyUpPartStatus,0,m_nUpPartCount);
	}
	else{
		if (tempreqfile->GetPartCount() != m_nUpPartCount){
			delete data;	//mf
			m_nUpPartCount = 0;
			return;
		}
		m_abyUpPartStatus = new uint8[m_nUpPartCount];
		uint16 done = 0;
		while (done != m_nUpPartCount){
			uint8 toread;
			data->Read(&toread,1);
			for (sint32 i = 0;i != 8;i++){
				m_abyUpPartStatus[done] = ((toread>>i)&1)? 1:0;
//				We may want to use this for another feature..
//				if (m_abyUpPartStatus[done] && !tempreqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
//					bPartsNeeded = true;
				done++;
				if (done == m_nUpPartCount)
					break;
			}
		}

	}
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this);
	delete data;
}


d545 1
a545 1
//			theApp.uploadqueue->AddUpDataOverheadOther(0, 24);
a567 1
		theApp.uploadqueue->AddUpDataOverheadOther(tosend->size, 0);
d588 1
a588 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d680 1
a680 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d705 1
a705 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d750 1
a750 1
//	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this, true, true);
d779 1
a779 4
	if (!proxy.UseProxy){
	    theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size, 0);
            theApp.clientudp->SendPacket(response,GetIP(),GetUDPPort());
        }
@


1.13.2.2
log
@Fixing list controls, adding support for eDonkey Hybrid
@
text
@d142 1
a142 1
	if (IsFriend() && GetFriendSlot()) // MERGE26
@


1.13.2.3
log
@further fixes
@
text
@a30 1
/* obaldin: hey what's this??? Where's the eye-candy??? ;)
a48 78
*/

void CUpDownClient::DrawUpStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool  bFlat){ 
	EMULE_TRY

	COLORREF crBoth; 
	COLORREF crNeither; 
	COLORREF crClientOnly; 
	COLORREF crPending;
	COLORREF crNextPending;
	//--- xrmb:seetheneed ---
	COLORREF crMeOnly; 
	//--- :xrmb ---

	if(bFlat) { 
		crBoth = RGB(0, 150, 0);
		crNeither = RGB(224, 224, 224);
		crClientOnly = RGB(0, 0, 0);
		crPending = RGB(255,208,0);
		crNextPending = RGB(255,255,100);
	} else { 
		crBoth = RGB(0, 192, 0);
		crNeither = RGB(240, 240, 240);
		crClientOnly = RGB(104, 104, 104);
		crPending = RGB(255, 208, 0);
		crNextPending = RGB(255,255,100);
	} 
		//--- xrmb:seetheneed ---
		crMeOnly = RGB(190,190,255);
		//--- :xrmb --

    uint32 filesize = PARTSIZE*(m_nUpPartCount); // might be a little off.. better than nothing

	s_UpStatusBar.SetFileSize(filesize); 
	s_UpStatusBar.SetHeight(rect->bottom - rect->top); 
	s_UpStatusBar.SetWidth(rect->right - rect->left); 
	s_UpStatusBar.Fill(crNeither); 

	if (!onlygreyrect && m_abyUpPartStatus) { 
		for (uint32 i = 0;i != m_nUpPartCount;i++)
		{ 
		        uint32 uEnd = filesize;
            /* no need for that now, cause we don't use the precise filesize
			//--- xrmb:seetheneed --- & Cax2 graphic glitch fix
			if (PARTSIZE*(i+1) > filesize) 
				uEnd = filesize; 
			else 
				uEnd = PARTSIZE*(i+1); 
            */
			
			if (m_abyUpPartStatus[i]){ //they have this part
                /*
				// do i have it ?
				if  (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))
					s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crBoth); 
				else if (m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && 
                                                     m_nLastBlockOffset >= PARTSIZE*i)
						s_StatusBar.FillRange(PARTSIZE*i, uEnd, crPending);
				else if (gettingParts.GetAt(i) == 'Y')
					s_StatusBar.FillRange(PARTSIZE*i, uEnd, crNextPending);
	    		else
					s_StatusBar.FillRange(PARTSIZE*i, uEnd, crClientOnly);
                */
                s_UpStatusBar.FillRange(PARTSIZE*i, uEnd, crBoth); // will do for now
			}
			else //they don't have a part. Do I have it?
                /*
				if (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1)) 
					s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crMeOnly); 
                */
                s_UpStatusBar.FillRange(PARTSIZE*i, uEnd, crNeither);
		} 
   	} 
   	s_UpStatusBar.Draw(dc, rect->left, rect->top, bFlat); 

	EMULE_CATCH
} 

a232 8

    // obaldin: this is for old clients, that rotate the chunk,
    // so that they'll be able to download at least _something_
    // But probably even after the majority of switches we'd
    // better check for 0 here
    if(this->GetTransferedUp() < 1024*1024) {
        return false;
    }
a417 2
    EMULE_TRY

a426 5
    if(!tempreqfile) { // obaldin
		delete data;
		m_nUpPartCount = 0;
		return;
    }
a457 2

    EMULE_CATCH
@


1.13.2.4
log
@spelling
@
text
@d315 1
a315 1
    // But probably even after the majority switches we'd
@


1.13.2.5
log
@more fixes, more merging, try/catch balancing
@
text
@d507 1
a507 1
    if (m_abyUpPartStatus) {
a508 2
        m_abyUpPartStatus = NULL; //obaldin: 'just in case' fix by jicxicmic
    }
@


1.12
log
@Updates to Preferences (and enabling/disabling options in code because of that)
@
text
@d281 2
d292 10
d548 2
a549 1
			m_nSessionUp += nBlockSize; // VQB Transfer Session Value
@


1.11
log
@removed debug message that was eating CPU
@
text
@d281 2
a282 1
	if (theApp.glob_prefs->TransferFullChunks())
d284 5
a288 18
		// VQB to provide full chunk transfers (modified by Tarod)
		if (/*theApp.uploadqueue->CheckForTimeOver(this) &&*/ IsDifferentPartBlock())
		{
			SetWaitStartTime();
			SetAskedCount(0);
			theApp.uploadqueue->RemoveFromUploadQueue(this);
			theApp.uploadqueue->AddClientToQueue(this,true);
			return false;
		}
	} else {
		if (theApp.uploadqueue->CheckForTimeOver(this))
		{
			// back on the waitqueue
			SetWaitStartTime();
			theApp.uploadqueue->RemoveFromUploadQueue(this);
			theApp.uploadqueue->AddClientToQueue(this,true);
			return false;
		}
d536 1
a536 2
			if (theApp.glob_prefs->TransferFullChunks())
				m_nSessionUp += nBlockSize; // VQB Transfer Session Value
@


1.10
log
@bugfix: column size & settings remembered, removed 'punishments'
@
text
@d237 3
a239 1
	theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
@


1.9
log
@ban() fixed, and no community ban option restored
@
text
@d68 2
d71 1
a71 1
	m_bIsBotuser = (strstr(m_pszUsername, "edk-files") || strstr(m_pszUsername, "finder")) && strstr(m_pszUsername, "com");
d139 1
a139 1
	if (m_bIsBotuser)
d142 1
a142 1
		fBaseValue *= 0.8f;
d148 4
a151 3
	if (theApp.glob_prefs->CommunityEnabled()){
	if (iscommunity)
		fBaseValue *= 2.0f;
d839 1
a839 1
	bool bIsBotuser;
@


1.8
log
@Maverick's ban bugfix
@
text
@d751 3
a753 1
	//	return;  //Maverick bugfix 
@


1.7
log
@updated pooz fix
@
text
@d751 1
a751 1
		return;
@


1.7.2.1
log
@updating this branch...
@
text
@@


1.7.2.2
log
@ban bugfix[Maverick]
@
text
@d751 1
@


1.7.2.3
log
@ban() fixed, and no community ban option restored
@
text
@a750 3
	//merge fix, restored to full functionality - spotted by Maverick
	if(theApp.glob_prefs->CommunityNoBanEnabled() && theApp.glob_prefs->CommunityEnabled() && IsCommunity())
		return;
@


1.7.2.4
log
@removed punishments & bugfixed load column positions
@
text
@a67 2

	//Cax2: removed bot user & low id 'punishments' . 
d69 1
a69 1
	//m_bIsBotuser = (strstr(m_pszUsername, "edk-files") || strstr(m_pszUsername, "finder")) && strstr(m_pszUsername, "com");
d137 1
a137 1
	/*if (m_bIsBotuser)	//Cax2 removed 'punishments'
d140 1
a140 1
		fBaseValue *= 0.8f;*/
d146 3
a148 4
	if (theApp.glob_prefs->CommunityEnabled())
	{
		if (iscommunity)
			fBaseValue *= 2.0f;
d836 1
a836 1
	bool bIsBotuser;	//we still assume that the other client 'punishes' us if our name is 'wrong'
@


1.7.2.5
log
@off. team's debug message was causing a high cpu load
@
text
@d237 1
a237 3
	//theApp.emuledlg->AddDebugLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, this->GetTransferedUp() / 1024); 
	// obaldin: this message was causing a high cpu load for users, so we comment it out.
	// NB: When (if) we have time, see why the catch(...) is used here
@


1.6
log
@pooz's fix
@
text
@d835 1
a835 2
	CString sUserName = theApp.glob_prefs->GetUserNick();
	char* pszUsername = _strdup(sUserName.GetBuffer());
a849 1
	free(pszUsername);
@


1.5
log
@Pointer check for NULL
@
text
@d835 3
a837 2
	char* pszUsername = theApp.glob_prefs->GetUserNick().GetBuffer();
	if (m_pszUsername)
d851 1
@


1.4
log
@updated to .25b codebase
@
text
@d873 2
a874 1
	return credits->GetScoreRatio(true);
@


1.3
log
@port to .25 b codebase...
@
text
@d197 43
a773 42
}

// Checks if it is next requested block from another chunk of the actual file or from another file 
// 
// [Returns] 
//   true : Next requested block is from another different chunk or file than last downloaded block 
//   false: Next requested block is from same chunk that last downloaded block 
bool CUpDownClient::IsDifferentPartBlock(void) // [Tarod 12/22/2002] 
{ 
	Requested_Block_Struct* last_done_block;
	Requested_Block_Struct* next_requested_block;
	uint32 last_done_part = 0xffffffff;
	uint32 next_requested_part = 0xffffffff;
	
	bool different_part = false;
	
	try {
		// Check if we have good lists and proceed to check for different chunks
		if (!m_BlockRequests_queue.IsEmpty() && !m_DoneBlocks_list.IsEmpty())
		{
			// Get last block and next pending
			last_done_block = (Requested_Block_Struct*)m_DoneBlocks_list.GetHead();
			next_requested_block = (Requested_Block_Struct*)m_BlockRequests_queue.GetHead(); 
			
			// Calculate corresponding parts to blocks
			last_done_part = last_done_block->StartOffset / PARTSIZE;
			next_requested_part = next_requested_block->StartOffset / PARTSIZE; 
             
			// Test is we are asking same file and same part
			if (memcmp(last_done_block->FileID, next_requested_block->FileID, 16) != 0 || last_done_part != next_requested_part)
			{ 
				different_part = true;
			}
		} 
   	}
   	catch(...)
   	{ 
      		different_part = true; 
   	} 
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "Debug: User %s, last_done_part (%u) %s (%u) next_requested_part, sent %u Kbs.", GetUserName(), last_done_part, different_part? "!=": "==", next_requested_part, GetSessionUp() / 1024)); 

	return different_part; 
@


1.2
log
@*** empty log message ***
@
text
@d127 1
a127 1
		fBaseValue = (float)(::GetTickCount()-m_dwWaitTime)/1000.0f;
d134 1
a134 1
		fBaseValue += (float)(::GetTickCount() - m_dwUploadTime > 900000)? 900000.0f:1800000.0f;
d236 1
a236 1
		if (theApp.uploadqueue->CheckForTimeOver(this) && IsDifferentPartBlock())
d333 1
a333 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_CLIENTERRORED),GetUserName(),error.GetBuffer());
d341 1
a341 1
	//theApp.emuledlg->AddLogLine(false,"Debug: Packet done. Size: %i",blockpack->GetLength());
d446 1
a446 1
	TransferredData newitem = {dataratems, ::GetTickCount()};
d497 1
d540 1
d632 1
d639 1
a639 1
	if (!m_bCommentDirty || file == NULL || !ExtProtocolAvailable() || GetMuleVersion() < 0x24)
d651 1
a651 1
	if (length>50) length=50;
d657 1
a708 1
	
d714 2
a715 3
#ifdef _DEBUG
	theApp.emuledlg->AddLogLine(false,GetResString(IDS_CLIENTBLOCKED),GetUserName());
#endif
@


1.1
log
@*** empty log message ***
@
text
@d33 1
d45 2
d51 1
d54 1
d59 1
d72 1
d75 1
a75 1
	copy2 = _strupr( _strdup( theApp.glob_prefs->CommunityString() ) );
d77 2
d175 3
d182 1
d192 3
d198 1
d222 2
d346 1
d366 1
d370 1
d402 1
d407 1
a407 1

d422 1
d426 1
d431 1
d435 1
d440 1
d444 1
d509 1
d514 1
d521 1
d525 1
d540 15
d558 1
d571 1
d575 1
d579 14
d595 24
d622 8
d631 1
d635 1
d655 1
d659 1
d683 1
d687 1
d699 1
d703 1
a703 1
	if(theApp.glob_prefs->CommunityNoBanEnabled() && theApp.glob_prefs->CommunityEnabled() && IsCommunity())
d714 1
d718 1
d724 5
a728 1
	theApp.clientudp->SendPacket(response,GetIP(),GetUDPPort());
d811 63
@

