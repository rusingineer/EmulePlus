head	1.35;
access;
symbols
	PublicRelease_1_2e:1.35
	Interim_Release_1-2e_RC1:1.35
	PublicRelease_1_2d:1.34
	Interim_Release_1-2d_RC1:1.34
	Interim_Release_1-2d_beta1:1.34
	PublicRelease_1_2c:1.32
	Interim_Release_1-2c_RC1:1.32
	Interim_Release_1-2c_beta1:1.32
	PublicRelease_1_2b:1.32
	Interim_Release_1-2b_RC1:1.32
	PublicRelease_1_2a:1.32
	Interim_Release_1-2a_RC1:1.32
	Interim_Release_1-2a_beta2:1.32
	Interim_Release_1-2a_beta1:1.32
	PublicRelease_1_2:1.31
	Interim_Release_1-2_RC1:1.31
	Interim_Release_1-2_beta1:1.30
	PublicRelease_1_1g:1.30
	Interim_Release_1-1g_RC3:1.30
	Interim_Release_1-1g_RC2:1.30
	Interim_Release_1-1g_RC1:1.30
	Interim_Release_1-1g_beta2:1.28
	Interim_Release_1-1g_beta1:1.28
	PublicRelease_1_1f:1.27
	Interim_Release_1-1f_RC1:1.27
	PublicRelease_1_1e:1.27
	Interim_Release_1-1e_RC2:1.27
	Interim_Release_1-1e_RC1:1.27
	Interim_Release_1-1e_beta1:1.27
	PublicRelease_1_1d:1.27
	Interim_Release_1-1d_RC1:1.27
	PublicRelease_1_1c:1.27
	Interim_Release_1-1c_RC1:1.27
	Interim_Release_1-1c_beta2:1.27
	Interim_Release_1-1c_beta1:1.27
	PublicRelease_1_1b:1.27
	Interim_Release_1-1b_RC1:1.27
	PublicRelease_1_1a:1.27
	Interim_Release_1-1a_RC2:1.27
	Interim_Release_1-1a_RC1:1.27
	Interim_Release_1-1a_beta2:1.27
	Interim_Release_1-1a_beta1:1.27
	PublicRelease_1_1:1.26
	Interim_Release_1-1_beta1:1.26
	PublicRelease_1o:1.25
	Interim_Release_1o_RC1:1.25
	Interim_Release_1o_beta1:1.25
	PublicRelease_1n:1.25
	Interim_Release_1n_RC2:1.25
	Interim_Release_1n_RC1:1.25
	Interim_Release_1n_beta2:1.24
	Interim_Release_1n_beta1:1.23
	PublicRelease_1m:1.21
	Interim_Release_1m_beta1:1.21
	PublicRelease_1l:1.21
	Interim_Release_1l_RC3:1.21
	Interim_Release_1l_RC2:1.21
	Interim_Release_1l_RC1:1.21
	Interim_Release_1l_beta2:1.21
	Interim_Release_1l_beta1:1.19
	PublicRelease_1k:1.18
	Interim_Release_1k_RC4:1.18
	Interim_1k_RC3:1.18
	Interim_1k_RC2:1.18
	Interim_Release_1k_RC1:1.18
	Interim_Release_1k_beta5:1.18
	Intrerim_Release_1k_beta4:1.18
	Interim_Release_1k_beta1:1.15
	PublicRelease_1j:1.14
	Interim_Release_1J_RC3:1.14
	Interim_Release_1j_RC3:1.14
	Interim_Release_1j_RC2:1.14
	Interim_Release_1j_RC1:1.14
	Interim_Release_1j_beta2:1.14
	Interim_Release_1j_beta1:1.14
	PublicRelease_1i:1.14
	Interim_Release_1i_RC6:1.14
	Interim_Release_1i_RC3:1.14
	Interim_Release_1i_RC2:1.14
	Interim_Release_1i_RC1:1.14
	Interim_Release_1i_beta3:1.13
	Interim_Release_1i_beta2:1.13
	Interim_Release_1i_beta1:1.12
	PublicRelease_1h:1.11
	Interim_Release_1h_rc2:1.11
	Interim_Release_1h_RC1:1.11
	Interim_Release_1h_beta2:1.11
	Interim_Release_1h_beta1_now:1.10
	Interim_Release_1h_beta1:1.10
	PublicRelease_1g:1.10
	Interim_Release_1g_RC6_Final:1.10
	Interim_Release_1g_RC6:1.10
	Interim_Release_1g_RC5:1.10
	Interim_Release_1g_RC4:1.10
	Interim_Release_1g_RC3:1.10
	Interim_Release_1g_beta2:1.9
	Interim_Release_1g_beta1:1.9
	Interim_Release_1f_RC4:1.9
	Interim_Release_1f_RC3:1.9
	Interim_Release_1f_RC2:1.7
	Interim_Release_1f_RC:1.7
	Interim_Release_1f_beta2:1.7
	Interim_Release_1f_beta1:1.6
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.5
	featurestest:1.5.0.2
	Interim_Release_1c_RC:1.5
	Interim_Release_1c_beta2:1.5
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.35
date	2008.09.30.04.33.22;	author aw3;	state Exp;
branches;
next	1.34;

1.34
date	2008.01.14.21.32.22;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.16.21.38.00;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.14.03.53.25;	author aw3;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.28;

1.28
date	2005.08.23.04.18.14;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.31.22.40.38;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.14.05.19.25;	author aw3;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.16.22.03.59;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.20.22.40.29;	author aw3;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.08.06.15.59;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.05.21.03.24;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.19.22.23.29;	author netwolf1;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.19.19.56.55;	author netwolf1;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.15.16.57.56;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.14.21.10.11;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.09.22.11.34;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.02.12.38.12;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.19.07.47.47;	author partyckip;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.20.20.46.25;	author netwolf1;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.20.09.06.49;	author netwolf1;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.08.17.08.24;	author netwolf1;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.30.11.37.53;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.17.22.37.46;	author moosetea;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.03.12.19.27.03;	author moosetea;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.11.20.07.47;	author moosetea;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.03;	author cax2;	state Exp;
branches;
next	;

1.5.2.1
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.35
log
@Local function made static; CString moved outside the loop.
@
text
@// DirectoryTreeCtrl.cpp : implementation file
//
/////////////////////////////////////////////
// written by robert rostek - tecxx@@rrs.at //
/////////////////////////////////////////////

#include "stdafx.h"
#include "DirectoryTreeCtrl.h"
#include "TitleMenu.h"
#include "otherfunctions.h"
#include "emule.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CDirectoryTreeCtrl, CTreeCtrl)
CDirectoryTreeCtrl::CDirectoryTreeCtrl()
{
	m_bSelectSubDirs = false;
	m_bCtrlPressed = false;
}

CDirectoryTreeCtrl::~CDirectoryTreeCtrl()
{
}

BEGIN_MESSAGE_MAP(CDirectoryTreeCtrl, CTreeCtrl)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnTvnItemexpanding)
	ON_WM_LBUTTONDOWN()
	ON_NOTIFY_REFLECT(NM_RCLICK, OnNMRclickSharedList)
	ON_NOTIFY_REFLECT(TVN_KEYDOWN, OnTvnKeydown)
	ON_WM_KEYDOWN()
	ON_WM_KEYUP()
END_MESSAGE_MAP()


// CDirectoryTreeCtrl message handlers

void CDirectoryTreeCtrl::OnTvnItemexpanding(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMTREEVIEW pNMTreeView = reinterpret_cast<LPNMTREEVIEW>(pNMHDR);
	HTREEITEM hItem = pNMTreeView->itemNew.hItem;
	HTREEITEM hRemove = GetChildItem(hItem);

//	remove all subitems
	while(hRemove)
	{
		DeleteItem(hRemove);
		hRemove = GetChildItem(hItem);
	}

//	get the directory
	CString strDir = GetFullPath(hItem);

//	fetch all subdirectories and add them to the node
	AddSubdirectories(hItem, strDir);

	*pResult = 0;
}

void CDirectoryTreeCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	UINT uFlags;
	HTREEITEM hItem = HitTest(point, &uFlags);
	HTREEITEM tItem = GetFirstVisibleItem();

	if((hItem) && (uFlags & TVHT_ONITEMSTATEICON))
	{
		CheckChanged(hItem, !GetCheck(hItem));

		if(nFlags & MK_CONTROL)
		{
			Expand(hItem, TVE_TOGGLE);
			HTREEITEM hChild;
			hChild = GetChildItem(hItem);
			while (hChild != NULL)
			{
				MarkChilds(hChild,!GetCheck(hItem));
				hChild = GetNextSiblingItem(hChild);
			}
			Expand(hItem, TVE_TOGGLE);
		}
	}
	SelectSetFirstVisible(tItem);
	CTreeCtrl::OnLButtonDown(nFlags, point);
}

void CDirectoryTreeCtrl::MarkChilds(HTREEITEM hChild, bool mark)
{
	CheckChanged(hChild, mark);
	SetCheck(hChild,mark);
	Expand(hChild, TVE_TOGGLE);
	HTREEITEM hChild2;
	hChild2 = GetChildItem(hChild);

	while( hChild2 != NULL)
	{
		MarkChilds(hChild2,mark);
		hChild2 = GetNextSiblingItem( hChild2 );
	}

	Expand(hChild, TVE_TOGGLE);
}

void CDirectoryTreeCtrl::Init(bool bAllowCDROM /*= true*/)
{
#ifdef _UNICODE
//	Win9x: Explicitly set to Unicode to receive Unicode notifications.
	SendMessage(CCM_SETUNICODEFORMAT, TRUE);
#endif

	DeleteAllItems();

	SHFILEINFO shFinfo;
	HIMAGELIST hImgList;
	CImageList imageList;

//	Get the system image list using a "path" which is available on all systems. [patch by bluecow]
	hImgList = (HIMAGELIST)SHGetFileInfo(_T("."), FILE_ATTRIBUTE_DIRECTORY, &shFinfo, sizeof(shFinfo), SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES);
	imageList.Attach(hImgList);
	SetImageList(&imageList, TVSIL_NORMAL);
//	Don't destroy the system's image list
	imageList.Detach();

	TCHAR drivebuffer[128], cDrv, *pos = drivebuffer;

	::GetLogicalDriveStrings(ARRSIZE(drivebuffer), drivebuffer); // e.g. "a:\ c:\ d:\"
	while(*pos != _T('\0'))
	{
		UINT	dwDrvType = ::GetDriveType(pos);

	//	Skip floppy drives (check letter as some USB drives can also be removable) and in some cases CD/DVD
		if ( ((dwDrvType != DRIVE_REMOVABLE) || (((cDrv = CHR2UP(*pos)) != _T('A')) && (cDrv != _T('B')))) &&
			(bAllowCDROM || (dwDrvType != DRIVE_CDROM)) )
		{
			pos[2] = _T('\0');
			AddChildItem(NULL, pos); // e.g. ("c:")
		}
	//	Point to the next drive (4 chars interval)
		pos += 4;
	}
}

HTREEITEM CDirectoryTreeCtrl::AddChildItem(HTREEITEM hRoot, CString strText)
{
	CString strDir = GetFullPath(hRoot);

	strDir += strText;
	if (hRoot == NULL)
		strDir += _T('\\');

	TV_INSERTSTRUCT	itInsert;
	SHFILEINFO		shFinfo;

	memzero(&itInsert, sizeof(itInsert));
	
	if ( SHGetFileInfo( strDir, FILE_ATTRIBUTE_DIRECTORY, &shFinfo, sizeof(shFinfo),
		SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES ) != NULL )
	{
		itInsert.item.mask |= TVIF_IMAGE;
		itInsert.item.iImage = shFinfo.iIcon;
	}
	
	if ( SHGetFileInfo( strDir, FILE_ATTRIBUTE_DIRECTORY, &shFinfo, sizeof(shFinfo),
		SHGFI_SYSICONINDEX | SHGFI_OPENICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES ) != NULL )
	{
		itInsert.item.mask |= TVIF_SELECTEDIMAGE;
		itInsert.item.iSelectedImage = shFinfo.iIcon;
	}

	if (hRoot != NULL)
		strDir += _T('\\');

	if (HasSharedSubdirectory(strDir))
		itInsert.item.state = TVIS_BOLD;

	if (HasSubdirectories(strDir))
		itInsert.item.cChildren = 1;		// used to display the + symbol next to each item

	itInsert.item.mask |= TVIF_CHILDREN | TVIF_HANDLE | TVIF_TEXT | TVIF_STATE;
	itInsert.item.stateMask = TVIS_BOLD;
	itInsert.item.pszText = const_cast<LPTSTR>(strText.GetString());
	itInsert.hInsertAfter = (hRoot == NULL) ? TVI_LAST : TVI_SORT;	// root items are already sorted
	itInsert.hParent = hRoot;

	HTREEITEM hItem = InsertItem(&itInsert);

	if (IsShared(strDir))
		SetCheck(hItem);

	return hItem;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetFullPath() returns full path with '\\' at the end
CString CDirectoryTreeCtrl::GetFullPath(HTREEITEM hItem)
{
	CString strDir;
	HTREEITEM hSearchItem = hItem;

	while(hSearchItem != NULL)
	{
		strDir = GetItemText(hSearchItem) + _T('\\') + strDir;
		hSearchItem = GetParentItem(hSearchItem);
	}

	return strDir;
}

void CDirectoryTreeCtrl::AddSubdirectories(HTREEITEM hRoot, CString strDir)
{
	strDir += _T("*.*");

	CFileFind finder;
	BOOL bWorking = finder.FindFile(strDir);

	while (bWorking)
	{
		bWorking = finder.FindNextFile();

		if (finder.IsDots())
			continue;
		if (finder.IsSystem())
			continue;
		if (!finder.IsDirectory())
			continue;
		
		CString	strFilename = finder.GetFileName();
		int		iIdx;

		if ((iIdx = strFilename.ReverseFind('\\')) != -1)
			strFilename = strFilename.Mid(iIdx + 1);

		AddChildItem(hRoot, strFilename);
	}

	finder.Close();
}

bool CDirectoryTreeCtrl::HasSubdirectories(CString strDir)
{
	strDir += _T("*.*");

	CFileFind finder;
	BOOL bWorking = finder.FindFile(strDir);

	while (bWorking)
	{
		bWorking = finder.FindNextFile();

		if (finder.IsDots())
			continue;
		if (finder.IsSystem())
			continue;
		if (!finder.IsDirectory())
			continue;

		finder.Close();

		return true;
	}

	finder.Close();
	return false;
}


static bool DirectoryExists(const CString &Name)
{
	DWORD Code = GetFileAttributes(Name);
	return (Code != INVALID_FILE_ATTRIBUTES) && (Code & FILE_ATTRIBUTE_DIRECTORY);
}

bool CDirectoryTreeCtrl::HasSharedSubdirectory(CString strDir)
{
	CString str;

	strDir.MakeLower();
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL;)
	{
		str = m_lstShared.GetNext(pos);
		str.MakeLower();

		if (str.Find(strDir) == 0 && strDir != str)
			return DirectoryExists(str);
	}

	return false;
}

void CDirectoryTreeCtrl::CheckChanged(HTREEITEM hItem, bool bChecked)
{
	CString strDir = GetFullPath(hItem);

	if (bChecked)
		AddShare(strDir);
	else
		DelShare(strDir);

	UpdateParentItems(hItem);

	CWnd *pParent = GetParent();

	if(pParent)
		pParent->SendMessage(WM_COMMAND, DIRLIST_ITEMSTATECHANGED, (long)m_hWnd);
}

bool CDirectoryTreeCtrl::IsShared(CString strDir)
{
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL;)
	{
		CString str = m_lstShared.GetNext(pos);

		if (str.CompareNoCase(strDir) == 0)
			return true;
	}

	return false;
}

void CDirectoryTreeCtrl::AddShare(CString strDir)
{
	if (!IsShared(strDir) && strDir.CompareNoCase(g_App.m_pPrefs->GetConfigDir()))
		m_lstShared.AddTail(strDir);
}

void CDirectoryTreeCtrl::DelShare(CString strDir)
{
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL;)
	{
		POSITION pos2 = pos;
		CString str = m_lstShared.GetNext(pos);

		if (str.CompareNoCase(strDir) == 0)
			m_lstShared.RemoveAt(pos2);
	}
}

void CDirectoryTreeCtrl::UpdateParentItems(HTREEITEM hChild)
{
	HTREEITEM hSearch = GetParentItem(hChild);

	while(hSearch != NULL)
	{
		if (HasSharedSubdirectory(GetFullPath(hSearch)))
			SetItemState(hSearch, TVIS_BOLD, TVIS_BOLD);
		else
			SetItemState(hSearch, 0, TVIS_BOLD);

		hSearch = GetParentItem(hSearch);
	}
}

void CDirectoryTreeCtrl::OnNMRclickSharedList(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pNMHDR);
//	Get item under cursor
	POINT point;
	::GetCursorPos(&point);
	CPoint p = point;
	ScreenToClient(&p);
	HTREEITEM hItem = HitTest(p);

	CTitleMenu  menuShared;

//	Create the menu
	menuShared.CreatePopupMenu();
	menuShared.AddMenuTitle(GetResString((m_lstShared.GetCount() == 0) ? IDS_NOSHAREDFOLDERS : IDS_SHAREDFOLDERS));

	bool		bFolder = false;

//	Add right clicked folder, if any
	if (hItem)
	{
		m_strLastRightClicked = GetFullPath(hItem);

		if (!IsShared(m_strLastRightClicked))
		{
			CString	strTmp;

			strTmp.Format(GetResString(IDS_VIEW_NOTSHARED), m_strLastRightClicked);
			menuShared.AppendMenu(MF_STRING, MP_SHAREDFOLDERS_FIRST - 1, strTmp);
			bFolder = true;
		}
	}

//	Add all shared directories
	int iCnt = 0;

	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL; iCnt++)
		menuShared.AppendMenu(MF_STRING,MP_SHAREDFOLDERS_FIRST+iCnt, (LPCTSTR)m_lstShared.GetNext(pos));

//	Display menu (do not display empty menu)
	if ((m_lstShared.GetHeadPosition() != NULL) || bFolder)
	{
		menuShared.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);
	}
	*pResult = 0;
//	Menu objects are destroyed in their destructor
}

BOOL CDirectoryTreeCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	NOPRM(lParam);
	if (wParam < MP_SHAREDFOLDERS_FIRST)
	{
		ShellExecute(NULL, _T("open"), m_strLastRightClicked, NULL, NULL, SW_SHOW);
		return false;
	}

	unsigned cnt = 0;

	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL;)
	{
		CString str = m_lstShared.GetNext(pos);

		if (cnt == wParam - MP_SHAREDFOLDERS_FIRST)
		{
			ShellExecute(NULL, _T("open"), str, NULL, NULL, SW_SHOW);
			return true;
		}
		cnt++;
	}

	return true;
}

void CDirectoryTreeCtrl::OnTvnKeydown(NMHDR *pNMHDR, LRESULT *pResult)
{ 
	LPNMTVKEYDOWN pTVKeyDown = reinterpret_cast<LPNMTVKEYDOWN>(pNMHDR);

	switch(pTVKeyDown->wVKey)
	{
		case VK_SPACE:
		case VK_RETURN:
		{
			HTREEITEM hItem = GetSelectedItem();

			if(hItem)
			{		
				HTREEITEM tItem = GetFirstVisibleItem();

				CheckChanged(hItem, !GetCheck(hItem));
								
				if(m_bCtrlPressed)
				{
					Expand(hItem, TVE_TOGGLE);
					HTREEITEM hChild;
					hChild = GetChildItem(hItem);

					while(hChild != NULL)
					{ 
						MarkChilds(hChild,!GetCheck(hItem));
						hChild = GetNextSiblingItem( hChild );
					}

					SetCheck(hItem, !GetCheck(hItem));
					Expand(hItem, TVE_TOGGLE);
				}
		 
				SelectSetFirstVisible(tItem);
			}

			break;
		}

		default:
			break;
	}

	*pResult = 0;
}

void CDirectoryTreeCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(nChar == VK_CONTROL)
		m_bCtrlPressed = true;

	CTreeCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CDirectoryTreeCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if(nChar == VK_CONTROL)
		m_bCtrlPressed = false;

	CTreeCtrl::OnKeyUp(nChar, nRepCnt, nFlags);
}
@


1.34
log
@set Unicode message format for Win9x systems
@
text
@d271 1
a271 1
bool DirectoryExists(const CString Name)
d279 2
a281 1

d284 1
a284 2
		CString str = m_lstShared.GetNext(pos);

@


1.33
log
@Suppressed level 4 warnings; Formatting.
@
text
@d110 5
@


1.32
log
@Reduced H-file dependency.
@
text
@d125 1
a125 1
	::GetLogicalDriveStrings(ELEMENT_COUNT(drivebuffer), drivebuffer); // e.g. "a:\ c:\ d:\"
d354 1
d400 1
a400 1
BOOL CDirectoryTreeCtrl::OnCommand(WPARAM wParam,LPARAM lParam )
d402 1
d409 1
a409 1
	int cnt = 0;
d415 1
a415 1
		if (cnt == wParam-MP_SHAREDFOLDERS_FIRST)
a419 1

@


1.31
log
@Removed not required code.
@
text
@d9 1
a18 2
// CDirectoryTreeCtrl

@


1.30
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d181 1
a181 2
	itInsert.item.pszText = (LPTSTR)strText.GetString();
	itInsert.item.cchTextMax = strText.GetLength();
@


1.29
log
@renamed 3 variables
@
text
@d323 1
a323 1
	if (!IsShared(strDir) && strDir.CompareNoCase(g_App.g_pPrefs->GetConfigDir()))
@


1.28
log
@IDS_VIEW1 is combined with IDS_VIEW2 renamed into IDS_VIEW_NOTSHARED.
@
text
@d323 1
a323 1
	if (!IsShared(strDir) && strDir.CompareNoCase(g_eMuleApp.m_pGlobPrefs->GetConfigDir()))
@


1.27
log
@Fixed possibility to add shared directories from some kind of USB drives {smashy}.
@
text
@d378 4
a381 1
			menuShared.AppendMenu(MF_STRING, MP_SHAREDFOLDERS_FIRST-1, (LPCTSTR)(GetResString(IDS_VIEW1) + m_strLastRightClicked +GetResString(IDS_VIEW2)));
@


1.26
log
@Fixed temporary directory list processing (double list entries which could be caused
by case sensitive compares; remove incorrect entries from the list; don't allow
main temp dir to be added to the list).
@
text
@d124 1
a124 1
	TCHAR drivebuffer[128], *pos = drivebuffer;
d131 3
a133 2
	//	Skip floppy drives and in some cases CD/DVD
		if ((dwDrvType != DRIVE_REMOVABLE) && (bAllowCDROM || (dwDrvType != DRIVE_CDROM)))
@


1.25
log
@Show directories tree icons (Preferences->Directories) in Windows 9x.
@
text
@a266 6
void CDirectoryTreeCtrl::GetSharedDirectories(CStringList* list)
{
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL;)
		list->AddTail(m_lstShared.GetNext(pos));
}

d270 1
a270 18
	return (Code != -1) && (Code & FILE_ATTRIBUTE_DIRECTORY);
}

void CDirectoryTreeCtrl::SetSharedDirectories(CStringList* list)
{
	m_lstShared.RemoveAll();

	for (POSITION pos = list->GetHeadPosition(); pos != NULL;)
	{
		CString str = list->GetNext(pos);

		if (str.Right(1) != _T('\\'))
			str += _T('\\');

		m_lstShared.AddTail(str);
	}

	Init(false);	// disable CD-ROM drives as temp. location
@


1.24
log
@CD-ROM/DVD drives are not allowed as additional temporary location;
Faster loading of directory tree icons; Better way to set [+] for subdirectories;
Faster insertion of root entries;
Improved string processing by reworking trail '\' processing.
@
text
@a40 1

d113 12
a124 14
	WORD wWinVer = g_eMuleApp.m_pGlobPrefs->GetWindowsVersion(); // maybe causes problems on 98 & nt4
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_ || wWinVer == _WINVER_SE_)
	{
		SHFILEINFO shFinfo;
		HIMAGELIST hImgList;
		CImageList imageList;

	//	Get the system image list using a "path" which is available on all systems. [patch by bluecow]
		hImgList = (HIMAGELIST)SHGetFileInfo(_T("."), FILE_ATTRIBUTE_DIRECTORY, &shFinfo, sizeof(shFinfo), SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES);
		imageList.Attach(hImgList);
		SetImageList(&imageList, TVSIL_NORMAL);
	//	Don't destroy the system's image list
		imageList.Detach();
	}
a125 1
	TCHAR drivebuffer[500];
a126 1
	const TCHAR* pos = drivebuffer;
d129 1
a129 5
	//	Copy drive name
		TCHAR drive[4];
		memccpy(drive, pos, '\0', 4);

		UINT	dwDrvType = ::GetDriveType(drive);
d131 1
d134 2
a135 3
		//	Skip floppy drives
			drive[2] = _T('\0');
			AddChildItem(NULL, drive); // e.g. ("c:")
d138 1
a138 1
		pos = &pos[4];
d147 1
a147 1
	if(strDir.Right(1) != _T('\\'))
d150 2
a151 1
	TV_INSERTSTRUCT itInsert;
d155 17
d178 1
a178 1
	itInsert.item.mask = TVIF_CHILDREN | TVIF_HANDLE | TVIF_TEXT | TVIF_STATE;
a184 22
	WORD wWinVer = g_eMuleApp.m_pGlobPrefs->GetWindowsVersion();

	if ( (wWinVer == _WINVER_XP_) || (wWinVer == _WINVER_2K_) ||
		(wWinVer == _WINVER_ME_) || (wWinVer == _WINVER_SE_) )
	{
		SHFILEINFO shFinfo;

		if ( SHGetFileInfo( strDir, FILE_ATTRIBUTE_DIRECTORY, &shFinfo, sizeof(shFinfo),
			SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES ) != NULL )
		{
			itInsert.item.mask |= TVIF_IMAGE;
			itInsert.item.iImage = shFinfo.iIcon;
		}
		
		if ( SHGetFileInfo( strDir, FILE_ATTRIBUTE_DIRECTORY, &shFinfo, sizeof(shFinfo),
			SHGFI_SYSICONINDEX | SHGFI_OPENICON | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES ) != NULL )
		{
			itInsert.item.mask |= TVIF_SELECTEDIMAGE;
			itInsert.item.iSelectedImage = shFinfo.iIcon;
		}
	}
	
@


1.23
log
@Corrected floppy drive check for preferences directory tree;
Improved initialization of preferences directory tree control (
improved string processing; use less temporary GUI resources;
removed old idle code; more correct error processing).
@
text
@a28 2
//	Don't destroy the system's image list
	m_image.Detach();
a32 1
	ON_NOTIFY_REFLECT(TVN_GETDISPINFO, OnTvnGetdispinfo)
d110 1
a110 8
void CDirectoryTreeCtrl::OnTvnGetdispinfo(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMTVDISPINFO pTVDispInfo = reinterpret_cast<LPNMTVDISPINFO>(pNMHDR);
	pTVDispInfo->item.cChildren = 1;
	*pResult = 0;
}

void CDirectoryTreeCtrl::Init(void)
d115 1
a115 1
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_ || wWinVer == _WINVER_SE_)		
d118 2
a119 1
		HIMAGELIST hImgList = NULL;
d122 5
a126 3
		hImgList = (HIMAGELIST)SHGetFileInfo(_T("."), 0, &shFinfo, sizeof(shFinfo), SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
		m_image.m_hImageList = hImgList;
		SetImageList(&m_image, TVSIL_NORMAL);
d130 1
a130 1
	::GetLogicalDriveStrings(500, drivebuffer); // e.g. "a:\ c:\ d:\"
d138 3
a140 1
		if (::GetDriveType(drive) != DRIVE_REMOVABLE)
d155 2
a156 1
	if (hRoot != NULL && strDir.Right(1) != _T('\\'))
a157 1
	strDir += strText;
d167 1
a167 1
		itInsert.item.cChildren = I_CHILDRENCALLBACK;		// used to display the + symbol next to each item
d173 1
a173 1
	itInsert.hInsertAfter = TVI_SORT;
a180 5
		CString strTemp = strDir;

		if(strTemp.Right(1) != _T('\\'))
			strTemp += _T('\\');

d183 2
a184 2
		if ( SHGetFileInfo( strTemp, 0, &shFinfo, sizeof(shFinfo),
			SHGFI_SYSICONINDEX | SHGFI_SMALLICON ) != NULL )
d190 2
a191 2
		if ( SHGetFileInfo( strTemp, 0, &shFinfo, sizeof(shFinfo),
			SHGFI_SYSICONINDEX | SHGFI_OPENICON | SHGFI_SMALLICON ) != NULL )
d206 2
a223 2
	if (strDir.Right(1) != _T('\\'))
		strDir += _T('\\');
a253 2
	if (strDir.Right(1) != _T('\\'))
		strDir += _T('\\');
a291 1

d306 1
a306 1
	Init();
a310 3
	if (strDir.Right(1) != _T('\\'))
		strDir += _T('\\');

d319 1
a319 1
		if (str.Find(strDir) == 0 && strDir != str) //strDir.GetLength() != str.GetLength())
a344 3
	if (strDir.Right(1) != _T('\\'))
		strDir += _T('\\');

a348 3
		if (str.Right(1) != _T('\\'))
			str += _T('\\');

d358 2
a359 7
	if (strDir.Right(1) != _T('\\'))
		strDir += _T('\\');
	
	if (IsShared(strDir) || !strDir.CompareNoCase(CString(g_eMuleApp.m_pGlobPrefs->GetConfigDir())))
		return;

	m_lstShared.AddTail(strDir);
a363 3
	if (strDir.Right(1) != _T('\\'))
		strDir += _T('\\');

@


1.22
log
@Fixed the active directory changing in Directory preferences dialog (official);
Minor improvements.
@
text
@d144 2
a145 1
		switch(drive[0])
d147 3
a149 9
			case _T('a'):
			case _T('A'):
			case _T('b'):
			case _T('B'):
			//	Skip floppy disk
				break;
			default:
				drive[2] = _T('\0');
				AddChildItem(NULL, drive); // e.g. ("c:")
d158 1
a158 1
	CString strPath = GetFullPath(hRoot);
d160 3
a162 2
	if (hRoot != NULL && strPath.Right(1) != _T('\\'))
		strPath += _T('\\');
a163 1
	CString strDir = strPath + strText;
a167 13
	WORD wWinVer = g_eMuleApp.m_pGlobPrefs->GetWindowsVersion();

	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_ || wWinVer == _WINVER_SE_)
	{
		itInsert.item.mask = TVIF_CHILDREN | TVIF_HANDLE | TVIF_TEXT | TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
		itInsert.item.stateMask = TVIS_BOLD | TVIS_STATEIMAGEMASK;
	}
	else
	{
		itInsert.item.mask = TVIF_CHILDREN | TVIF_HANDLE | TVIF_TEXT | TVIF_STATE;
		itInsert.item.stateMask = TVIS_BOLD;
	}
	
a169 2
	else
		itInsert.item.state = 0;
a172 2
	else
		itInsert.item.cChildren = 0;
d174 3
a176 1
	itInsert.item.pszText = strText.GetBuffer();
d180 5
a184 2
	
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer ==  _WINVER_ME_|| wWinVer == _WINVER_SE_)
a189 5
		
		UINT nType = GetDriveType(strTemp);

		if(DRIVE_REMOVABLE <= nType && nType <= DRIVE_RAMDISK)
			itInsert.item.iImage = nType;
d193 2
a194 5
		if(!SHGetFileInfo(strTemp, 0, &shFinfo,	sizeof(shFinfo), SHGFI_ICON | SHGFI_SMALLICON))
		{
			itInsert.itemex.iImage = 0;
		}
		else
d196 2
a197 2
			itInsert.itemex.iImage = shFinfo.iIcon;
			DestroyIcon(shFinfo.hIcon);
d200 2
a201 5
		if(!SHGetFileInfo(strTemp, 0, &shFinfo, sizeof(shFinfo), SHGFI_ICON | SHGFI_OPENICON | SHGFI_SMALLICON))
		{
			itInsert.itemex.iImage = 0;
		}
		else
d203 2
a204 2
			itInsert.itemex.iSelectedImage = shFinfo.iIcon;
			DestroyIcon(shFinfo.hIcon);
a212 2
	strText.ReleaseBuffer();

@


1.21
log
@Last change was commented out (by myself; really gotta get some sleep :P) thx Aw3 for telling me !
@
text
@d139 1
a139 1
	while(*pos != '\0')
d146 4
a149 4
			case 'a':
			case 'A':
			case 'b':
			case 'B':
d153 1
a153 1
				drive[2] = '\0';
d165 2
a166 2
	if (hRoot != NULL && strPath.Right(1) != "\\")
		strPath += "\\";
d201 1
a201 1
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer ==  _WINVER_ME_|| wWinVer == _WINVER_SE_)		
d205 2
a206 2
		if(strTemp.Right(1) != "\\")
			strTemp += "\\";
d262 3
a264 5
	if (strDir.Right(1) != '\\')
		strDir += '\\';

	if (!::SetCurrentDirectory(strDir))
		return;
d267 1
a267 1
	BOOL bWorking = finder.FindFile(_T("*.*"));
d280 2
a281 1
		CString strFilename = finder.GetFileName();
d283 2
a284 2
		if (strFilename.ReverseFind('\\') != -1)
			strFilename = strFilename.Mid(strFilename.ReverseFind('\\') + 1);
d294 3
a296 4
	if (strDir.Right(1) != '\\')
		strDir += '\\';

	::SetCurrentDirectory(strDir);
d299 1
a299 1
	BOOL bWorking = finder.FindFile(_T("*.*"));
d343 2
a344 2
		if (str.Right(1) != '\\')
			str += '\\';
d410 1
a410 1
	if (strDir.Right(1) != ('\\'))
@


1.20
log
@Fixed bug which was deleting the system's icon image list.
@
text
@d30 1
a30 1
//	m_image.Detach();
@


1.19
log
@Removed style modification (control already has this style); formating
Removed control hide/show (quite useless before dialog creature).
@
text
@d29 2
@


1.18
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d68 1
a68 1
{ 
d71 1
a71 1
 	HTREEITEM tItem = GetFirstVisibleItem();
d74 2
a75 2
	{ 
      	CheckChanged(hItem, !GetCheck(hItem));
d79 13
a91 13
         		Expand(hItem, TVE_TOGGLE);
        	 	HTREEITEM hChild;
         		hChild = GetChildItem(hItem);
         		while (hChild != NULL)
         		{ 
            			MarkChilds(hChild,!GetCheck(hItem));
            			hChild = GetNextSiblingItem( hChild );
         		}
         		Expand(hItem, TVE_TOGGLE);
      		}
   	}
   	SelectSetFirstVisible(tItem);
   	CTreeCtrl::OnLButtonDown(nFlags, point);
d95 12
a106 12
{ 
   CheckChanged(hChild, mark);
   SetCheck(hChild,mark);
   Expand(hChild, TVE_TOGGLE);
   HTREEITEM hChild2;
   hChild2 = GetChildItem(hChild);

   while( hChild2 != NULL)
   {
	   MarkChilds(hChild2,mark);
	   hChild2 = GetNextSiblingItem( hChild2 );
   }
d108 1
a108 1
   Expand(hChild, TVE_TOGGLE);
a119 1
	ShowWindow(SW_HIDE);
a121 2
	ModifyStyle( 0, TVS_CHECKBOXES );

d137 2
a138 1
	while(*pos != '\0'){
d142 14
a155 13
		switch(drive[0]){
	case 'a':
	case 'A':
	case 'b':
	case 'B':
	//	Skip floppy disk
		break;
		default:
			drive[2] = '\0';
			AddChildItem(NULL, drive); // e.g. ("c:")
	}
		//	Point to the next drive (4 chars interval)
			pos = &pos[4];
a156 2

	ShowWindow(SW_SHOW);
d173 1
a173 1
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_ || wWinVer == _WINVER_SE_)		
d354 2
a355 2
	if (strDir.Right(1) != '\\')
		strDir += '\\';
d391 2
a392 2
	if (strDir.Right(1) != '\\')
		strDir += '\\';
d398 2
a399 2
		if (str.Right(1) != '\\')
			str += '\\';
d410 2
a411 2
	if (strDir.Right(1) != '\\')
		strDir += '\\';
d421 2
a422 2
	if (strDir.Right(1) != '\\')
		strDir += '\\';
@


1.17
log
@Improved string processing
@
text
@d489 3
a491 1
		menuShared.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.16
log
@Improved context menu creation;
Removed display of empty context menu.
@
text
@d254 1
a254 1
		strDir = GetItemText(hSearchItem) + _T("\\") + strDir;
d263 2
a264 2
	if (strDir.Right(1) != "\\")
		strDir += "\\";
@


1.15
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@a22 1
	m_SharedMenu.m_hMenu = NULL;
d461 2
d464 2
a465 2
	m_SharedMenu.DestroyMenu();
	m_SharedMenu.CreatePopupMenu();
d467 1
a467 4
	if (m_lstShared.GetCount() == 0)
		m_SharedMenu.AddMenuTitle(GetResString(IDS_NOSHAREDFOLDERS));
	else
		m_SharedMenu.AddMenuTitle(GetResString(IDS_SHAREDFOLDERS));
d475 4
a478 1
			m_SharedMenu.AppendMenu(MF_STRING, MP_SHAREDFOLDERS_FIRST-1, (LPCTSTR)(GetResString(IDS_VIEW1) + m_strLastRightClicked +GetResString(IDS_VIEW2)));
d483 1
d485 1
a485 1
		m_SharedMenu.AppendMenu(MF_STRING,MP_SHAREDFOLDERS_FIRST+iCnt, (LPCTSTR)m_lstShared.GetNext(pos));
d487 3
a489 2
//	Display menu
	m_SharedMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
d491 1
@


1.14
log
@Various fixes for Interim beta2 reported bugs
@
text
@d173 1
a173 1
	memset2(&itInsert, 0, sizeof(itInsert));
@


1.13
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@a31 1

a48 1
//	int iAction = pNMTreeView->action;
a49 1
	// remove all subitems
d51 2
d59 1
a59 1
	// get the directory
d62 1
a62 1
	// fetch all subdirectories and add them to the node
d68 1
a68 1
void CDirectoryTreeCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
d70 5
a74 5
	//VQB adjustments to provide for sharing or unsharing of subdirectories when control key is Down 
	UINT uFlags; 
	HTREEITEM hItem = HitTest(point, &uFlags); 
 	HTREEITEM tItem = GetFirstVisibleItem(); // VQB mark initial window position 
	if((hItem) && (uFlags & TVHT_ONITEMSTATEICON)) 
d76 8
a83 6
      		CheckChanged(hItem, !GetCheck(hItem)); 
		if(nFlags & MK_CONTROL) { // Is control key down? 
         		Expand(hItem, TVE_TOGGLE); //VQB - make sure tree has entries 
        	 	HTREEITEM hChild; 
         		hChild = GetChildItem(hItem); 
         		while (hChild != NULL) 
d85 9
a93 9
            			MarkChilds(hChild,!GetCheck(hItem)); 
            			hChild = GetNextSiblingItem( hChild ); 
         		} 
         		Expand(hItem, TVE_TOGGLE); // VQB - restore tree to initial disposition 
      		} 
   	} 
   	SelectSetFirstVisible(tItem); // VQB - restore window scroll to initial position 
   	CTreeCtrl::OnLButtonDown(nFlags, point); 
} 
d95 1
a95 1
void CDirectoryTreeCtrl::MarkChilds(HTREEITEM hChild, bool mark) 
d97 13
a109 11
   CheckChanged(hChild, mark); 
   SetCheck(hChild,mark);    
   Expand(hChild, TVE_TOGGLE); // VQB - make sure tree has entries 
   HTREEITEM hChild2; 
   hChild2 = GetChildItem(hChild); 
   while( hChild2 != NULL) 
   { 
	   MarkChilds(hChild2,mark); 
	   hChild2 = GetNextSiblingItem( hChild2 ); 
   } 
   Expand(hChild, TVE_TOGGLE); // VQB - restore tree to initial disposition 
d126 1
a126 2
	// START: added by FoRcHa /////////////
	WORD wWinVer = g_eMuleApp.m_pGlobPrefs->GetWindowsVersion();	// maybe causes problems on 98 & nt4
d129 2
a130 2
	SHFILEINFO shFinfo;
	HIMAGELIST hImgList = NULL;
d132 4
a135 11
	// Get the system image list using a "path" which is available on all systems. [patch by bluecow]
	hImgList = (HIMAGELIST)SHGetFileInfo(_T("."), 0, &shFinfo, sizeof(shFinfo),
											SHGFI_SYSICONINDEX | SHGFI_SMALLICON);
	if(!hImgList)
	{
		TRACE(_T("Cannot retrieve the Handle of SystemImageList!"));
		//return;
	}

	m_image.m_hImageList = hImgList;
	SetImageList(&m_image, TVSIL_NORMAL);
a136 1
	////////////////////////////////
d138 1
a138 2

	TCHAR drivebuffer[500];		// netwolf 07.05.03 (don´t move uninitialized memory (Maella))
d142 1
a142 1
		// Copy drive name
d150 1
a150 1
			// Skip floppy disk
d153 1
a153 1
			drive[2] = '\0'; 
d156 1
a156 1
			// Point to the next drive (4 chars interval)
d158 1
a158 1
	}							// netwolf END
d166 1
d169 1
d172 1
a174 1
	// START: changed by FoRcHa /////
d176 1
d179 1
a179 2
		itInsert.item.mask = TVIF_CHILDREN | TVIF_HANDLE | TVIF_TEXT |
							TVIF_STATE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
a186 1
	// END: changed by FoRcHa ///////
d192 1
a202 1
	// START: added by FoRcHa ////////////////
d205 31
a235 19
	CString strTemp = strDir;
	if(strTemp.Right(1) != "\\")
		strTemp += "\\";
	
	UINT nType = GetDriveType(strTemp);
	if(DRIVE_REMOVABLE <= nType && nType <= DRIVE_RAMDISK)
		itInsert.item.iImage = nType;

	SHFILEINFO shFinfo;
	if(!SHGetFileInfo(strTemp, 0, &shFinfo,	sizeof(shFinfo),
					SHGFI_ICON | SHGFI_SMALLICON))
	{
		TRACE(_T("Error Gettting SystemFileInfo!"));
		itInsert.itemex.iImage = 0; // :(
	}
	else
	{
		itInsert.itemex.iImage = shFinfo.iIcon;
		DestroyIcon(shFinfo.hIcon);
a237 14
	if(!SHGetFileInfo(strTemp, 0, &shFinfo, sizeof(shFinfo),
						SHGFI_ICON | SHGFI_OPENICON | SHGFI_SMALLICON))
	{
		TRACE(_T("Error Gettting SystemFileInfo!"));
		itInsert.itemex.iImage = 0;
	}
	else
	{
		itInsert.itemex.iSelectedImage = shFinfo.iIcon;
		DestroyIcon(shFinfo.hIcon);
	}
	}
	// END: added by FoRcHa //////////////
	
d239 1
d242 1
d252 1
d258 1
d266 1
d269 1
d272 1
d276 1
d285 1
d288 1
d291 1
d299 1
d301 1
d304 1
d308 1
d315 1
d317 1
d320 1
d328 1
a328 1
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL; )
d343 1
a343 1
	for (POSITION pos = list->GetHeadPosition(); pos != NULL; )
d346 1
d349 2
a350 1
			m_lstShared.AddTail(str);
d352 1
a355 1

d360 1
d362 2
a363 1
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL; )
d366 1
d368 2
a369 1
		if (str.Find(strDir) == 0 && strDir != str)//strDir.GetLength() != str.GetLength())
d372 1
d379 1
d388 1
d397 2
a398 1
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL; )
d401 1
d404 1
d408 1
d427 2
a428 1
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL; )
d432 1
d441 1
d448 1
d455 1
a455 1
	// get item under cursor
d462 1
a462 1
	// create the menu
d465 1
d471 1
a471 1
	// add right clicked folder, if any
d475 1
d480 1
a480 1
	// add all shared directories
d485 1
a485 1
	// display menu
d490 2
a491 1
BOOL CDirectoryTreeCtrl::OnCommand(WPARAM wParam,LPARAM lParam ){
d497 1
d499 2
a500 1
	for (POSITION pos = m_lstShared.GetHeadPosition(); pos != NULL; )
d503 1
d509 1
d512 1
d515 1
d526 1
d529 3
a531 2
				HTREEITEM tItem = GetFirstVisibleItem(); // VQB mark initial window position 
				CheckChanged(hItem, !GetCheck(hItem)); 
d534 6
a539 5
				{ // Is control key down? 
					Expand(hItem, TVE_TOGGLE); //VQB - make sure tree has entries 
					HTREEITEM hChild; 
					hChild = GetChildItem(hItem); 
					while(hChild != NULL) 
d541 4
a544 3
						MarkChilds(hChild,!GetCheck(hItem)); 
						hChild = GetNextSiblingItem( hChild ); 
					} 
d546 2
a547 2
					Expand(hItem, TVE_TOGGLE); // VQB - restore tree to initial disposition 
				} 
d549 1
a549 1
				SelectSetFirstVisible(tItem); // VQB - restore window scroll to initial position 
d551 1
d554 1
d558 1
d560 1
a560 1
} 
d566 1
d574 1
@


1.12
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d177 1
a177 1
	memset(&itInsert, 0, sizeof(itInsert));
@


1.11
log
@Implemented ConfigDir
@
text
@d124 1
a124 1
	WORD wWinVer = theApp.glob_prefs->GetWindowsVersion();	// maybe causes problems on 98 & nt4
d180 1
a180 1
	WORD wWinVer = theApp.glob_prefs->GetWindowsVersion();
d394 1
a394 1
	if (IsShared(strDir) || !strDir.CompareNoCase(CString(theApp.glob_prefs->GetConfigDir())))
@


1.10
log
@unicode cleanup
@
text
@d394 1
a394 1
	if (IsShared(strDir))
d396 1
@


1.9
log
@minor fixes and improvements
@
text
@d131 1
a131 1
	hImgList = (HIMAGELIST)SHGetFileInfo(".", 0, &shFinfo, sizeof(shFinfo),
d145 1
a145 1
	char drivebuffer[500];		// netwolf 07.05.03 (don´t move uninitialized memory (Maella))
d147 1
a147 1
	const char* pos = drivebuffer;
d150 1
a150 1
		char drive[4];
d260 1
a260 1
		strDir = GetItemText(hSearchItem) + "\\" + strDir;
d273 1
a273 1
	BOOL bWorking = finder.FindFile("*.*");
d298 1
a298 1
	BOOL bWorking = finder.FindFile("*.*");
d463 1
a463 1
		ShellExecute(NULL, "open", m_strLastRightClicked, NULL, NULL, SW_SHOW);
d472 1
a472 1
			ShellExecute(NULL, "open", str, NULL, NULL, SW_SHOW);
@


1.8
log
@windows server 2003 detection support
@
text
@d50 1
a50 1
	int iAction = pNMTreeView->action;
d136 1
a136 1
		return;
@


1.7
log
@*** empty log message ***
@
text
@d125 1
a125 1
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_)		
d181 1
a181 1
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_)		
d209 1
a209 1
	if(wWinVer == _WINVER_2K_ || wWinVer == _WINVER_XP_ || wWinVer == _WINVER_ME_)		
@


1.6
log
@netwolf's changes
@
text
@d145 5
a149 4
	char drivebuffer[500];
	::GetLogicalDriveStrings(500, drivebuffer);
	while(drivebuffer[0] != '\0')
	{
d151 9
a159 2
		memccpy(drive, drivebuffer, '\0', 10);
		if (tolower(drive[0]) != tolower('A') && tolower(drive[0]) != tolower('B')) { // <-- added 
d161 1
a161 3
			AddChildItem(NULL, drive); 
		}
		memmove(drivebuffer, drivebuffer+4, 500);
d163 4
@


1.5
log
@bug : 0000049 Shared subdirectories dont make parent directories bold if they dont exist
@
text
@d130 2
a131 1
	hImgList = (HIMAGELIST)SHGetFileInfo("C:\\", 0, &shFinfo, sizeof(shFinfo),
@


1.5.2.1
log
@27c
@
text
@d130 1
a130 2
	// Get the system image list using a "path" which is available on all systems. [patch by bluecow]
	hImgList = (HIMAGELIST)SHGetFileInfo(".", 0, &shFinfo, sizeof(shFinfo),
d135 1
a135 1
		//return;
@


1.4
log
@Rolled back my directory "fix" nasty side effects with multiple temp files
@
text
@d311 1
a311 1
/*bool DirectoryExists(const CString Name)
d315 1
a315 1
}*/ 
a326 2

		//if(DirectoryExists(str))		// Moosetea - We Check to see if the directory exists first
d343 1
a343 1
			return true;
@


1.3
log
@Directorires are only shown in prefs as shared if they exist
@
text
@d311 1
a311 1
bool DirectoryExists(const CString Name)
d315 1
a315 1
} 
d328 1
a328 1
		if(DirectoryExists(str))		// Moosetea - We Check to see if the directory exists first
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d310 8
d327 3
a329 1
		m_lstShared.AddTail(str);
d333 1
@


1.1
log
@*** empty log message ***
@
text
@d12 5
@


1.1.4.1
log
@updating this branch...
@
text
@@

