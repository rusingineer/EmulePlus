head	1.25;
access;
symbols
	PublicRelease_1_2e:1.24
	Interim_Release_1-2e_RC1:1.24
	PublicRelease_1_2d:1.24
	Interim_Release_1-2d_RC1:1.24
	Interim_Release_1-2d_beta1:1.24
	PublicRelease_1_2c:1.22
	Interim_Release_1-2c_RC1:1.22
	Interim_Release_1-2c_beta1:1.21
	PublicRelease_1_2b:1.21
	Interim_Release_1-2b_RC1:1.20
	PublicRelease_1_2a:1.19
	Interim_Release_1-2a_RC1:1.19
	Interim_Release_1-2a_beta2:1.19
	Interim_Release_1-2a_beta1:1.19
	PublicRelease_1_2:1.19
	Interim_Release_1-2_RC1:1.19
	Interim_Release_1-2_beta1:1.19
	PublicRelease_1_1g:1.19
	Interim_Release_1-1g_RC3:1.19
	Interim_Release_1-1g_RC2:1.19
	Interim_Release_1-1g_RC1:1.19
	Interim_Release_1-1g_beta2:1.18
	Interim_Release_1-1g_beta1:1.18
	PublicRelease_1_1f:1.18
	Interim_Release_1-1f_RC1:1.18
	PublicRelease_1_1e:1.18
	Interim_Release_1-1e_RC2:1.18
	Interim_Release_1-1e_RC1:1.18
	Interim_Release_1-1e_beta1:1.18
	PublicRelease_1_1d:1.18
	Interim_Release_1-1d_RC1:1.18
	PublicRelease_1_1c:1.18
	Interim_Release_1-1c_RC1:1.18
	Interim_Release_1-1c_beta2:1.18
	Interim_Release_1-1c_beta1:1.18
	PublicRelease_1_1b:1.15
	Interim_Release_1-1b_RC1:1.15
	PublicRelease_1_1a:1.15
	Interim_Release_1-1a_RC2:1.15
	Interim_Release_1-1a_RC1:1.15
	Interim_Release_1-1a_beta2:1.15
	Interim_Release_1-1a_beta1:1.15
	PublicRelease_1_1:1.14
	Interim_Release_1-1_beta1:1.14
	PublicRelease_1o:1.14
	Interim_Release_1o_RC1:1.14
	Interim_Release_1o_beta1:1.14
	PublicRelease_1n:1.14
	Interim_Release_1n_RC2:1.14
	Interim_Release_1n_RC1:1.14
	Interim_Release_1n_beta2:1.14
	Interim_Release_1n_beta1:1.13
	PublicRelease_1m:1.13
	Interim_Release_1m_beta1:1.13
	PublicRelease_1l:1.13
	Interim_Release_1l_RC3:1.13
	Interim_Release_1l_RC2:1.13
	Interim_Release_1l_RC1:1.13
	Interim_Release_1l_beta2:1.13
	Interim_Release_1l_beta1:1.13
	PublicRelease_1k:1.11
	Interim_Release_1k_RC4:1.11
	Interim_1k_RC3:1.11
	Interim_1k_RC2:1.11
	Interim_Release_1k_RC1:1.11
	Interim_Release_1k_beta5:1.9
	Intrerim_Release_1k_beta4:1.9
	Interim_Release_1k_beta1:1.9
	PublicRelease_1j:1.9
	Interim_Release_1J_RC3:1.9
	Interim_Release_1j_RC3:1.9
	Interim_Release_1j_RC2:1.9
	Interim_Release_1j_RC1:1.9
	Interim_Release_1j_beta2:1.9
	Interim_Release_1j_beta1:1.9
	PublicRelease_1i:1.7
	Interim_Release_1i_RC6:1.7
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.4;
locks; strict;
comment	@// @;


1.25
date	2009.05.14.01.40.36;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.15.13.19.13;	author eklmn;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.31.18.26.28;	author fuxie-dk;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.24.03.35.19;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2007.01.24.22.37.00;	author eklmn;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.15.04.18.26;	author kush_eplus;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.19.10.48.08;	author dongato;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.17.14.26.44;	author dongato;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.16.12.01.59;	author dongato;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.31.04.20.48;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.03.09.59.43;	author netwolf1;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.12.18.58.56;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2004.03.26.20.57.06;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.25.20.30.07;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.11.10.35.44;	author dongato;	state Exp;
branches;
next	1.7;

1.7
date	2003.11.27.13.57.18;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.12.14.26.04;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.12.13.17.24;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.20.13.19.58;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.20.11.04.47;	author eklmn;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.15.10.24.20;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.15.03.52.26;	author morevit;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "opcodes.h"
#include "emule.h"
#include "DownloadList.h"
#include "DownloadListCtrl.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadList::CDownloadList()
{
	m_pvecDirtyFiles = new PartFileItemVector();
	m_pvecDirtySources = new SourceItemVector();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadList::~CDownloadList()
{
	RemoveAllFiles();

	delete m_pvecDirtyFiles;
	delete m_pvecDirtySources;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AddFile() adds part file 'pPartFile' to the download list and notifies the download list ctrl of the addition.
void CDownloadList::AddFile(CPartFile *pPartFile)
{
	EMULE_TRY

	if (pPartFile == NULL)
		return;

//	Create new Item
	CPartFileDLItem	   *pFileItem = new CPartFileDLItem(pPartFile);

//	The same file shall be added only once
	ASSERT(!IsValidIterator(FindFileItem(pPartFile)));
	InsertFileItem(pPartFile, pFileItem);

	m_pctlDownloadList->AddFileItem(pFileItem);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::RemoveFile(CPartFile *pPartFile)
{
	if (pPartFile != NULL)
	{
		PFIter		itFile = FindFileItem(pPartFile);

	//	If it was found...
		if (IsValidIterator(itFile))
		{
			CPartFileDLItem		*pFileItem = GetFileItem(itFile);

		//	Remove the file item from the file map
			m_mapFiles.erase(itFile);

		//
		//	If it's in the dirty list, remove it from there too
			PartFileItemVector::iterator	it = ::find(m_pvecDirtyFiles->begin(),m_pvecDirtyFiles->end(),pFileItem);

			if (it != m_pvecDirtyFiles->end())
			{
				m_pvecDirtyFiles->erase(it);
			}

		//	NOTE: This call must remain synchronous as the item is destroyed immediately after.
			m_pctlDownloadList->RemoveFileItem(pFileItem);

		//	Destroy the file item
			delete pFileItem;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::UpdateFile(CPartFile *pPartFile)
{
	if (pPartFile != NULL)
	{
		PFIter		itFileItem = FindFileItem(pPartFile);

	//	For each file item associated with 'pFile'...
		if (IsValidIterator(itFileItem))
		{
			CPartFileDLItem  *pFileItem = GetFileItem(itFileItem);

			if (pFileItem != NULL)
			{
				AddDirtyFile(pFileItem);
			}
		}
		m_pctlDownloadList->PostRefreshMessage();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::AddDirtyFile(CPartFileDLItem *pFileItem)
{
//	If 'pFileItem' is not already in the dirty file list...
	if (::find(m_pvecDirtyFiles->begin(),m_pvecDirtyFiles->end(),pFileItem) == m_pvecDirtyFiles->end())
	{
		m_pvecDirtyFiles->push_back(pFileItem);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetDirtyFiles() detaches the current dirty file list and returns it to the caller (who's responsible
//		for destroying it). This allows the download list control to update without locking down the download list.
CDownloadList::PartFileItemVector *CDownloadList::GetDirtyFiles()
{
	PartFileItemVector		*pDirtyFiles = NULL;

	if (!m_pvecDirtyFiles->empty())
	{
		pDirtyFiles = m_pvecDirtyFiles;
		m_pvecDirtyFiles = new PartFileItemVector();
	}

	return pDirtyFiles;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AddSource() adds Source 'pSource' to the download list and notifies the download list ctrl of the addition.
void CDownloadList::AddSource(CPartFile *pParentFile,CUpDownClient *pSource,bool bSourceNotAvailable)
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
	if (pParentFile == NULL || pSource == NULL)
		return;
//
//	Find out if there is already an item for the spec'd source and file. If the source is available,
//		mark any other items unavailable.
	CSourceDLItem	   *pSourceItem = NULL;

	SourceRange			range = FindSourceItems(pSource);

	for (SourceIter itSource = range.first; itSource != range.second; itSource++)
	{
		CSourceDLItem		*pSourceItem2 = itSource->second;

		if (pSourceItem2->GetParentFile() == pParentFile)
		{
			pSourceItem = pSourceItem2;
		}
		else
		{
		//	A Source can only be "Available" for one file at a time
			if (bSourceNotAvailable == false)
				pSourceItem2->SetAvailability(false);
		}
	}

	CPartFileDLItem		*pParentFileItem = NULL;

//	If there's no existing item for 'pSource', create one
	if (pSourceItem == NULL)
	{
	//	Find the part file item we want to add it to
		PFIter		itFileItem = FindFileItem(pParentFile);

	//	If it doesn't exist...
		if (!IsValidIterator(itFileItem))
			return;
		pParentFileItem = GetFileItem(itFileItem);
		pSourceItem = pParentFileItem->CreateSourceItem(pSource,!bSourceNotAvailable);
		InsertSourceItem(pSource,pSourceItem);
	}
//	If there's already an item for 'pSource'...
	else
	{
		pSourceItem->SetAvailability(!bSourceNotAvailable);
		pSourceItem->ResetUpdateTimer();
		return;
	}
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RemoveSource() removes and destroys the source item for source 'pSource' belonging to
//		part file 'pParentFile'. If 'pParentFile' is NULL then all source items for source 'pSource'
//		are deleted. If an error occurs, the method does nothing.
void CDownloadList::RemoveSource(CUpDownClient *pSource,CPartFile *pParentFile/*=NULL*/)
{
	EMULE_TRY

	if (pSource != NULL)
	{
	//	If the InfoList is displaying this source and it is being completely removed...
		if ( pParentFile == NULL
		  && g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE
		  && g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetClient() == pSource
		  && g_App.m_pMDlg->IsRunning())
		{
		//	Set it to display nothing
			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
		}

		CSourceDLItem	   *pSourceItem = NULL;
		SourceRange			range = FindSourceItems(pSource);

	//	For each source item associated with 'pSource' in the multi-map...
		for (SourceIter itSource = range.first; itSource != range.second; )
		{
			pSourceItem = GetSourceItem(itSource);

		//	If no parent file was spec'd or this item belongs to the spec'd parent file...
			if (pSourceItem != NULL && (pParentFile == NULL || pSourceItem->GetParentFile() == pParentFile))
			{
				itSource = m_mapSources.erase(itSource);

			//
			//	If it's in the dirty list, remove it from there too
				SourceItemVector::iterator	it = ::find(m_pvecDirtySources->begin(),m_pvecDirtySources->end(),pSourceItem);

				if (it != m_pvecDirtySources->end())
				{
					m_pvecDirtySources->erase(it);
				}

			//	Remove the source item from the download list ctrl
				m_pctlDownloadList->RemoveSourceItem(pSourceItem);

				CPartFileDLItem		*pParentFileItem = pSourceItem->GetParentFileItem();

				pParentFileItem->DeleteSourceItem(pSourceItem);

			//	If a parent file was spec'd we're done, otherwise continue for the rest of the items for the source.
				if (pParentFile != NULL)
					break;
			}
			else
			{
				itSource++;
			}
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::UpdateSource(CUpDownClient *pSource, CPartFile *pParentFile/*=NULL*/)
{
	if (pSource != NULL)
	{
		SourceRange		range = FindSourceItems(pSource);

	//	For each source item associated with 'pSource'...
		for (SourceIter itSource = range.first; itSource != range.second; itSource++)
		{
			CSourceDLItem  *pSourceItem = GetSourceItem(itSource);

			if (pSourceItem != NULL && (pParentFile == NULL || pParentFile == pSourceItem->GetParentFile()))
			{
				AddDirtySource(pSourceItem);
				if (pParentFile != NULL)
					break;
			}
		}
		m_pctlDownloadList->PostRefreshMessage();
		g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.PostUniqueMessage(WM_CL_REFRESH);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::AddDirtySource(CSourceDLItem *pSourceItem)
{
//	If 'pSourceItem' is not already in the dirty source list...
	if (::find(m_pvecDirtySources->begin(),m_pvecDirtySources->end(),pSourceItem) == m_pvecDirtySources->end())
	{
		m_pvecDirtySources->push_back(pSourceItem);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetDirtySources() detaches the current dirty source list and returns it to the caller (who's responsible
//		for destroying it). This allows the download list control to update without locking down the download list.
CDownloadList::SourceItemVector *CDownloadList::GetDirtySources()
{
	SourceItemVector		*pDirtySources = NULL;

	if (!m_pvecDirtySources->empty())
	{
		pDirtySources = m_pvecDirtySources;
		m_pvecDirtySources = new SourceItemVector();
	}

	return pDirtySources;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RemoveAllFiles() removes and destroys all part file items in the window.
void CDownloadList::RemoveAllFiles()
{
	while (m_mapFiles.empty() == false)
	{
		delete GetFileItem(m_mapFiles.begin());
		m_mapFiles.erase(m_mapFiles.begin());
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadList::SourceRange CDownloadList::FindSourceItems(CUpDownClient *pSource)
{
	return m_mapSources.equal_range(pSource);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::ClearCompleted(EnumCategories eCategoryID/* = CAT_NONE*/)
{
	EMULE_TRY

	EnumCategories		eCurCat = m_pctlDownloadList->GetCurTabCat();

//	Search for completed file(s)
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end();)
	{
		CPartFileDLItem		*pFileItem = GetFileItem(itFile);

		itFile++;
		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pFileItem->GetFile();

			if ( pPartFile->IsPartFile() == false
			  && ( CCat::FileBelongsToGivenCat(pPartFile,eCategoryID == CAT_NONE ? eCurCat : eCategoryID)
				|| (eCategoryID == CAT_ALL) ) )
			{
				RemoveFile(pPartFile);
			}
		}
	}

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ClearCompleted(pPartFile) clears the single completed file with file pointer.
void CDownloadList::ClearCompleted(CPartFile *pPartFile)
{
	EMULE_TRY

	if (pPartFile != NULL && !pPartFile->IsPartFile())
	{
		RemoveFile(pPartFile);
		g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ClearCompleted(pFileHash) clears the single completed file with file hash.
void CDownloadList::ClearCompleted(const uchar *pFileHash /*=NULL*/)
{
	EMULE_TRY

	CArray<CPartFile*, CPartFile*>	completedFilesList;

	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); )
	{
		CPartFileDLItem	   *pFileItem = GetFileItem(itFile);

		itFile++; // Already point to the next file
		if (pFileItem != NULL)
		{
			CPartFile	*pPartFile = pFileItem->GetFile();

			if (!pPartFile->IsPartFile())
			{
				if (pFileHash == NULL)
				{
					completedFilesList.Add(pPartFile);
				}
				else if (md4cmp(pFileHash, pPartFile->GetFileHash()) == 0)
				{
					RemoveFile(pPartFile);
					break;	//we can stop searching if match is found
				}
			}
		}
	}
//	eklmn: clear all file correct way
	if (pFileHash == NULL)
	{
		for (int i = 0; i < completedFilesList.GetCount(); i++)
		{
			RemoveFile(completedFilesList[i]);	//continue clearing all
		}
		completedFilesList.RemoveAll();
	}

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CDownloadList::GetPartFilesStatusString()
{
	EMULE_TRY

	CString		strOut;

//	Search for file(s)
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
	{
		CPartFileDLItem		*pFileItem = GetFileItem(itFile);

		if (pFileItem != NULL)
		{
			CPartFile		*pPartFile = pFileItem->GetFile();

			strOut.AppendFormat( _T("\r\n%s\t [%.2f%%] %u/%u - %s"),
							 pPartFile->GetFileName(),
							 pPartFile->GetPercentCompleted2(),
							 pPartFile->GetTransferringSrcCount(),
							 pPartFile->GetSourceCount(),
							 pPartFile->GetPartFileStatus() );
		}
	}
	return strOut;

	EMULE_CATCH

	return _T("");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadList::PartFileVector *CDownloadList::GetFiles()
{
	PartFileVector		*pvecPartFiles = new PartFileVector();

	EMULE_TRY

	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
	{
		pvecPartFiles->push_back(itFile->first);
	}

	EMULE_CATCH

	return pvecPartFiles;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadList::PartFileItemVector *CDownloadList::GetFileItems()
{
	PartFileItemVector		*pvecPartFileItems = new PartFileItemVector();

	EMULE_TRY

	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
	{
		pvecPartFileItems->push_back(itFile->second);
	}

	EMULE_CATCH

	return pvecPartFileItems;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadList::SourceItemVector *CDownloadList::GetSourceItems(CUpDownClient *pSource/* = NULL*/)
{
	SourceItemVector	   *pvecSourceItems = new SourceItemVector();

	if (pSource != NULL)
	{
	//	Retrieve all entries matching the source
		SourceRange		range = FindSourceItems(pSource);

		for (SourceIter itSource = range.first; itSource != range.second; itSource++)
		{
			CSourceDLItem		*pSourceItem  = GetSourceItem(itSource);

			pvecSourceItems->push_back(pSourceItem);
		}
	}
	else
	{
		for (SourceIter itSource = m_mapSources.begin(); itSource != m_mapSources.end(); itSource++)
		{
			CSourceDLItem	   *pSourceItem = GetSourceItem(itSource);

			pvecSourceItems->push_back(pSourceItem);
		}
	}

	return pvecSourceItems;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadList::RemoveSourceItem(CSourceDLItem *pSourceItem)
{
#ifdef OLD_SOCKETS_ENABLED
	CSourceDLItem	   *pSourceItem2 = NULL;
	SourceRange			range = FindSourceItems(pSourceItem->GetSource());

//	For each source item associated with 'pSource' in the multi-map...
	for (SourceIter itSource = range.first; itSource != range.second; )
	{
		pSourceItem2 = GetSourceItem(itSource);

	//	If we found 'pSourceItem' in the map...
		if (pSourceItem == pSourceItem2)
		{
			m_mapSources.erase(itSource);

		//
		//	If it's in the dirty list, remove it from there too
			SourceItemVector::iterator	it = ::find(m_pvecDirtySources->begin(),m_pvecDirtySources->end(),pSourceItem);

			if (it != m_pvecDirtySources->end())
			{
				m_pvecDirtySources->erase(it);
			}

		//	Remove the source item from the download list ctrl
			m_pctlDownloadList->RemoveSourceItem(pSourceItem);

			break;
		}
		else
		{
			itSource++;
		}
	}
#endif //OLD_SOCKETS_ENABLED
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.24
log
@correction after review
@
text
@d20 1
a22 1
#include "emule.h"
@


1.23
log
@Reduced H-file dependency [Aw3].
@
text
@d422 1
a422 1
			strOut.AppendFormat( _T("\n%s\t [%.2f%%] %u/%u - %s"),
@


1.22
log
@Removed file name trimming (to 50 characters) for status.log.
@
text
@a17 3
// DownloadList.cpp : implementation file
//

d19 1
a19 1

@


1.21
log
@added missed brackets
@
text
@a423 1
			CString		strTemp2 = pPartFile->GetFileName();
a424 2
			if (strTemp2.GetLength() > 50)
				strTemp2.Truncate(50);
d426 1
a426 1
							 strTemp2,
@


1.20
log
@Potential workaround for Fuxie - DK crash on ClearCompleted, thanks to Aw3
@
text
@d269 1
a269 1
			if (pSourceItem != NULL && pParentFile == NULL || pParentFile == pSourceItem->GetParentFile())
@


1.19
log
@renamed 3 variables
@
text
@d322 2
d339 1
a339 1
			{	
d346 2
d382 1
a382 1
			{	
d384 2
a385 2
				{	
					completedFilesList.Add(pPartFile); 
d387 1
a387 1
				else if (md4cmp(pFileHash, pPartFile->GetFileHash()) == 0) 
d399 1
a399 1
		{	
d404 1
a404 1
	
d410 1
a410 1
CString CDownloadList::GetPartFilesStatusString() 
d426 1
a426 1
			if (strTemp2.GetLength() > 50) 
d432 1
a432 1
							 pPartFile->GetSourceCount(), 
d452 2
a453 2
	}	
	
d468 2
a469 2
	}	
	
@


1.18
log
@Moved new function to proper place
@
text
@d207 3
a209 3
		  && g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE
		  && g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == pSource
		  && g_eMuleApp.m_pdlgEmule->IsRunning())
d212 1
a212 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d277 1
a277 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.PostUniqueMessage(WM_CL_REFRESH);
d343 1
a343 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d354 1
a354 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d401 1
a401 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
@


1.17
log
@Fix for my last change...
@
text
@a537 21
// SaveAllSLSFiles() - Updates all .txtxsrc files with current sources
void CDownloadList::SaveAllSLSFiles()
{
	EMULE_TRY

//	Search for file(s)
	for (PFIter itFile = m_mapFiles.begin(); itFile != m_mapFiles.end(); itFile++)
	{
		CPartFileDLItem            *pFileItem = GetFileItem(itFile);

		if (pFileItem != NULL)
		{
			CPartFile            *pPartFile = pFileItem->GetFile();
		//	Save Sources
			g_eMuleApp.m_pDownloadQueue->m_sourcesaver.Process(pPartFile, g_eMuleApp.m_pGlobPrefs->SLSMaxSourcesPerFile(), true);
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.16
log
@Forces saving sources during client close
@
text
@d552 1
a552 1
			g_eMuleApp.m_pDownloadQueue->m_sourcesaver.Process(pPartFile, g_eMuleApp.m_pGlobPrefs->SLSMaxSourcesPerFile());
@


1.15
log
@Don't report 100.00% completed for file with minor amount left to download {vendetta7}.
@
text
@d538 21
@


1.14
log
@SSWQ
@
text
@d424 1
a424 1
			strOut.AppendFormat( _T("\n%s\t [%.1f%%] %u/%u - %s"),
d426 1
a426 1
							 pPartFile->GetPercentCompleted(),
@


1.13
log
@minor changes (Partfile --> PartFile...)
@
text
@d277 1
a277 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.PostRefreshMessage();
@


1.12
log
@Modified Clear Completed
@
text
@d429 1
a429 1
							 pPartFile->GetPartfileStatus() );
@


1.11
log
@Removal of redundant log messages
@
text
@d346 16
a361 1
//	ClearCompleted() clears the single completed file with file hash 'pFileHash'.
@


1.10
log
@Solved potential crashes when filename contains '%';
Improved string processing.
@
text
@a406 1
			AddLogLine(false, _T("%s"), strTemp2);
a416 2
	AddLogLine(false, _T("%s"), strOut);

@


1.9
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d395 1
a395 2
	CString		strOut=_T("");
	CString		strTemp1, strTemp2;
d405 1
d407 1
a407 2
			AddLogLine(false, pPartFile->GetFileName());
			strTemp2 = pPartFile->GetFileName(); 
d409 2
a410 4
			{
				strTemp2 = strTemp2.Mid(0,50);
			}
			strTemp1.Format( _T("\n%s\t [%.1f%%] %i/%i - %s"),
a415 1
			strOut = strOut + strTemp1;
d418 1
a418 1
	AddLogLine(false, strOut);
@


1.8
log
@Updated to 1j beta 1
@
text
@d407 1
a407 1
			AddLogLine(false,pPartFile->GetFileName());
d422 1
a422 1
	AddLogLine(false,strOut);
@


1.7
log
@proper InfoList handling
@
text
@d342 2
d386 2
@


1.6
log
@New sockets
@
text
@d212 1
a212 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.ClearInfoHeader();
@


1.5
log
@Reverted code changes (GUI/Update problems) and done a check on application exit.
@
text
@d143 1
d191 1
d490 1
d523 1
@


1.4
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d206 2
a207 1
		  && g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == pSource )
@


1.3
log
@infinite loop by removing a source, if PartFile does not specified
@
text
@d212 2
a213 2
		CSourceDLItem	*pSourceItem = NULL;
		SourceRange		range = FindSourceItems(pSource);
d216 1
a216 1
		for (SourceIter itSource = range.first; itSource != range.second; itSource++)
d223 1
a223 1
				m_mapSources.erase(itSource);
d244 4
@


1.2
log
@A number of robustification changes.
@
text
@d212 2
a213 2
		CSourceDLItem	   *pSourceItem = NULL;
		SourceRange			range = FindSourceItems(pSource);
d216 1
a216 1
		for (SourceIter itSource = range.first; itSource != range.second; )
a243 4
			}
			else
			{
				itSource++;
@


1.1
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d225 9
d483 36
@

