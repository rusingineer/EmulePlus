head	1.16;
access;
symbols
	PublicRelease_1_2e:1.15
	Interim_Release_1-2e_RC1:1.15
	PublicRelease_1_2d:1.15
	Interim_Release_1-2d_RC1:1.15
	Interim_Release_1-2d_beta1:1.15
	PublicRelease_1_2c:1.13
	Interim_Release_1-2c_RC1:1.13
	Interim_Release_1-2c_beta1:1.13
	PublicRelease_1_2b:1.13
	Interim_Release_1-2b_RC1:1.13
	PublicRelease_1_2a:1.11
	Interim_Release_1-2a_RC1:1.11
	Interim_Release_1-2a_beta2:1.11
	Interim_Release_1-2a_beta1:1.11
	PublicRelease_1_2:1.11
	Interim_Release_1-2_RC1:1.11
	Interim_Release_1-2_beta1:1.11
	PublicRelease_1_1g:1.10
	Interim_Release_1-1g_RC3:1.10
	Interim_Release_1-1g_RC2:1.10
	Interim_Release_1-1g_RC1:1.10
	Interim_Release_1-1g_beta2:1.10
	Interim_Release_1-1g_beta1:1.10
	PublicRelease_1_1f:1.10
	Interim_Release_1-1f_RC1:1.10
	PublicRelease_1_1e:1.10
	Interim_Release_1-1e_RC2:1.10
	Interim_Release_1-1e_RC1:1.10
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.10
	Interim_Release_1-1c_beta2:1.10
	Interim_Release_1-1c_beta1:1.10
	PublicRelease_1_1b:1.10
	Interim_Release_1-1b_RC1:1.10
	PublicRelease_1_1a:1.10
	Interim_Release_1-1a_RC2:1.10
	Interim_Release_1-1a_RC1:1.10
	Interim_Release_1-1a_beta2:1.10
	Interim_Release_1-1a_beta1:1.10
	PublicRelease_1_1:1.10
	Interim_Release_1-1_beta1:1.10
	PublicRelease_1o:1.10
	Interim_Release_1o_RC1:1.10
	Interim_Release_1o_beta1:1.10
	PublicRelease_1n:1.10
	Interim_Release_1n_RC2:1.10
	Interim_Release_1n_RC1:1.10
	Interim_Release_1n_beta2:1.10
	Interim_Release_1n_beta1:1.10
	PublicRelease_1m:1.10
	Interim_Release_1m_beta1:1.10
	PublicRelease_1l:1.10
	Interim_Release_1l_RC3:1.10
	Interim_Release_1l_RC2:1.10
	Interim_Release_1l_RC1:1.10
	Interim_Release_1l_beta2:1.10
	Interim_Release_1l_beta1:1.9
	PublicRelease_1k:1.9
	Interim_Release_1k_RC4:1.9
	Interim_1k_RC3:1.9
	Interim_1k_RC2:1.9
	Interim_Release_1k_RC1:1.9
	Interim_Release_1k_beta5:1.9
	Intrerim_Release_1k_beta4:1.9
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.8
	Interim_Release_1J_RC3:1.8
	Interim_Release_1j_RC3:1.8
	Interim_Release_1j_RC2:1.8
	Interim_Release_1j_RC1:1.8
	Interim_Release_1j_beta2:1.8
	Interim_Release_1j_beta1:1.8
	PublicRelease_1i:1.8
	Interim_Release_1i_RC6:1.8
	Interim_Release_1i_RC3:1.8
	Interim_Release_1i_RC2:1.8
	Interim_Release_1i_RC1:1.8
	Interim_Release_1i_beta3:1.8
	Interim_Release_1i_beta2:1.7
	Interim_Release_1i_beta1:1.7
	PublicRelease_1h:1.4
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.4
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.16
date	2009.05.14.01.40.37;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.10.09.27.25;	author eklmn;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.19.04.55.38;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2007.01.07.20.31.47;	author eklmn;	state Exp;
branches;
next	1.12;

1.12
date	2007.01.06.19.59.16;	author eklmn;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.29.05.34.52;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2004.05.11.02.47.55;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.16.00.38.57;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.02.15.50.22;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.25.15.08.55;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.25.13.06.57;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.23.16.13.13;	author forcha;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Reduced H-file dependency.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// CRollupCtrl & CRollupHeader
// (c) 2002 by FoRcHa (a.k.a. NO)  [seppforcher38@@hotmail.com]
//
// I would appreciate a notification of any bugs or bug fixes to help the control grow.
///////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "otherfunctions.h"
#include "RollupCtrl.h"
#include "RollupGripper.h"
#include "Preferences.h"
#include "TransferWnd.h"
#include "DeferPos.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRollupHeader
CRollupHeader::CRollupHeader()
{
#ifndef NEW_LOOK
	m_crBackColor = GetSysColor(COLOR_3DDKSHADOW);
	m_crTextColor =  GetSysColor(COLOR_3DHIGHLIGHT);
#else
	m_crBackColor = GetSysColor(COLOR_BTNFACE);
	m_crTextColor =  GetSysColor(COLOR_WINDOWTEXT);
#endif NEW_LOOK
	m_crBorderColor = GetSysColor(COLOR_WINDOWFRAME);

	CFont	*pDefGuiFont = CFont::FromHandle(static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT)));
	LOGFONT	lf;

	pDefGuiFont->GetLogFont(&lf);
	m_cfTextFont.CreateFontIndirect(&lf);
	m_cpBorderPen.CreatePen(PS_SOLID, 1, m_crBorderColor);
	m_cpArrowPen.CreatePen(PS_SOLID, 1, m_crTextColor);
	
	m_MemDC.m_hDC = NULL;
	m_MemBMP.m_hObject = NULL;
	m_pOldMemBMP = NULL;

	m_rClientRect = m_rArrowRect = m_rTextRect = CRect(0,0,0,0);

	m_bInit = TRUE;	
	m_bExpanded = FALSE;

	m_iHeight = RUP_HEADERHEIGHT;
}

CRollupHeader::~CRollupHeader()
{
	if(m_MemDC.m_hDC)
	{
		if(m_pOldMemBMP != NULL)
			m_MemDC.SelectObject(m_pOldMemBMP);
	}
}


BEGIN_MESSAGE_MAP(CRollupHeader, CWnd)
	ON_WM_PAINT()
	ON_WM_LBUTTONUP()
	ON_WM_SIZE()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_RBUTTONUP()
	ON_WM_ERASEBKGND()
ON_WM_ERASEBKGND()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRollupHeader message handlers
void CRollupHeader::OnPaint() 
{
	CPaintDC dc(this);
	CRect rClientRect;
	
	if(m_bInit)
	{
		GetClientRect(&rClientRect);
		CreateMemDC(&dc, &rClientRect);
//		m_MemDC.SelectObject(&m_cpBorderPen);
//		m_MemDC.SetTextColor(m_crTextColor);
//		m_MemDC.SetBkColor(m_crBackColor);
//		m_MemDC.SetBkMode(OPAQUE);

		m_rClientRect = rClientRect;
		m_rArrowRect = rClientRect;
		m_rArrowRect.right = m_rArrowRect.left + m_iHeight;
		m_rArrowRect.DeflateRect(2,2);
		m_cpArrowPoint.x = m_rArrowRect.left + 5;
		m_cpArrowPoint.y = m_rArrowRect.top + 5;
		m_rTextRect = rClientRect;
		m_rTextRect.DeflateRect(m_iHeight + 2, 2, 4+5, 2);	// space(s) between border and text

		m_bInit = FALSE;
	}

	CPen *pOldPen = m_MemDC.SelectObject(&m_cpBorderPen);
	COLORREF crOldTxtColor = m_MemDC.SetTextColor(m_crTextColor);
	COLORREF crOldBckColor = m_MemDC.SetBkColor(m_crBackColor);
	int iOldBkMode = m_MemDC.SetBkMode(OPAQUE);

	m_MemDC.FillSolidRect(m_rClientRect, m_crBackColor);
	m_MemDC.MoveTo(m_rClientRect.left, m_rClientRect.top);
	m_MemDC.LineTo(m_rClientRect.right, m_rClientRect.top);

#ifndef NEW_LOOK
	m_MemDC.MoveTo(m_rClientRect.left, m_rClientRect.bottom-1);
	m_MemDC.LineTo(m_rClientRect.right, m_rClientRect.bottom-1);

	m_MemDC.MoveTo(m_rClientRect.left, m_rClientRect.top);
	m_MemDC.LineTo(m_rClientRect.left, m_rClientRect.bottom);

	m_MemDC.MoveTo(m_rClientRect.right-1, m_rClientRect.top);
	m_MemDC.LineTo(m_rClientRect.right-1, m_rClientRect.bottom);
#endif NEW_LOOK

	CPoint cpArrowPt(m_cpArrowPoint);
	if(m_bExpanded)
		cpArrowPt.y+=3;
	else
		cpArrowPt.x++;
	
	DrawArrow(&m_MemDC, &cpArrowPt, m_bExpanded);
	
	CFont *pOldFont = m_MemDC.SelectObject(&m_cfTextFont);
	m_MemDC.DrawText(m_strRightText, m_rTextRect,
		DT_RIGHT | DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
	m_MemDC.DrawText(m_strLeftText, m_rTextRect,
		DT_LEFT | DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);

	dc.BitBlt(m_rClientRect.left, m_rClientRect.top, m_rClientRect.Width(), m_rClientRect.Height(),
				&m_MemDC, 0, 0, SRCCOPY);

	m_MemDC.SelectObject(pOldFont);
	m_MemDC.SetBkMode(iOldBkMode);
	m_MemDC.SetBkColor(crOldBckColor);
	m_MemDC.SetTextColor(crOldTxtColor);
	m_MemDC.SelectObject(pOldPen);
}

void CRollupHeader::OnLButtonUp(UINT nFlags, CPoint point) 
{
	if(point.x >= m_rArrowRect.left && point.x <= m_rArrowRect.right &&
	   point.y >= m_rArrowRect.top  && point.y <= m_rArrowRect.bottom)
	{
		m_bExpanded = !m_bExpanded;
		Invalidate();
		GetParent()->SendMessage(WM_COMMAND, USRMSG_STATECHANGED, (LPARAM)m_hWnd);
	}
	
	CWnd::OnLButtonUp(nFlags, point);
}

void CRollupHeader::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	if(point.x >= m_rTextRect.left && point.x <= m_rTextRect.right &&
		point.y >= m_rTextRect.top && point.y <= m_rTextRect.bottom)
	{
		m_bExpanded = !m_bExpanded;
		Invalidate();
		GetParent()->SendMessage(WM_COMMAND, USRMSG_STATECHANGED, (LPARAM)m_hWnd);
	}

	CWnd::OnLButtonDblClk(nFlags, point);
}

void CRollupHeader::OnRButtonUp(UINT nFlags, CPoint point)
{
	GetParent()->SendMessage(WM_COMMAND, USRMSG_RIGHTCLICK, (LPARAM)m_hWnd);
	CWnd::OnRButtonUp(nFlags, point);
}

void CRollupHeader::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
	m_bInit = TRUE;
}

void CRollupHeader::OnSysColorChange()
{
	CWnd::OnSysColorChange();
#ifndef NEW_LOOK
	m_crBackColor = GetSysColor(COLOR_3DDKSHADOW);
	m_crTextColor = GetSysColor(COLOR_3DHIGHLIGHT);
#else
	m_crBackColor = GetSysColor(COLOR_BTNFACE);
	m_crTextColor = GetSysColor(COLOR_WINDOWTEXT);
#endif NEW_LOOK
	m_crBorderColor = GetSysColor(COLOR_WINDOWFRAME);

	if(m_cpBorderPen.GetSafeHandle())
		m_cpBorderPen.DeleteObject();
	m_cpBorderPen.CreatePen(PS_SOLID, 1, m_crBorderColor);
	if(m_cpArrowPen.GetSafeHandle())
		m_cpArrowPen.DeleteObject();
	m_cpArrowPen.CreatePen(PS_SOLID, 1, m_crTextColor);
	Invalidate();
}

void CRollupHeader::DrawArrow(CDC* pDC, const CPoint* pTopLeft, bool bDown)
{
	CPen *pOldPen;
	pOldPen = pDC->SelectObject(&m_cpArrowPen);
	
	if(bDown)
	{
		int xs = pTopLeft->x;
		int xe = pTopLeft->x + 7;
		
		for(int y = pTopLeft->y; y < pTopLeft->y + 4; y++)
		{	
			pDC->MoveTo(xs,y);
			pDC->LineTo(xe,y);
			xs++;
			xe--;
		}
	}
	else
	{
		int ys = pTopLeft->y;
		int ye = pTopLeft->y + 7;

		for(int x = pTopLeft->x; x < pTopLeft->x + 4; x++)
		{
			pDC->MoveTo(x,ys);
			pDC->LineTo(x,ye);
			ys++;
			ye--;
		}
	}
	
	pDC->SelectObject(pOldPen);
}

BOOL CRollupHeader::OnEraseBkgnd(CDC* pDC)
{
	NOPRM(pDC);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CRollupCtrl
CRollupCtrl::CRollupCtrl() : m_iHeaderHeight(0)
{
	m_iHeaderHeight = RUP_HEADERHEIGHT;
	m_iExpandedItems = 0;
	m_iExpandedMsk = 0x00;
}

CRollupCtrl::~CRollupCtrl()
{
	int iCount = m_List.GetSize();

	for(int i = 0; i < iCount; i++)
	{
		RollupEntry *pEntry = m_List.GetAt(i);
		if(pEntry != NULL)
		{
			if(pEntry->pHeader != NULL)
			{
				if(pEntry->pHeader->m_hWnd)
					pEntry->pHeader->DestroyWindow();
				delete pEntry->pHeader;
			}
			if(pEntry->pGripper != NULL)
			{
				if(pEntry->pGripper->m_hWnd)
					pEntry->pGripper->DestroyWindow();
				delete pEntry->pGripper;
			}
			delete pEntry;
		}
	}

	m_List.RemoveAll();
}

BEGIN_MESSAGE_MAP(CRollupCtrl, CWnd)
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_ERASEBKGND()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRollupCtrl message handlers
int CRollupCtrl::InsertItem(LPCTSTR strLeft, LPCTSTR strRight, CWnd *pClient, int iIndex, bool bExpanded)
{
	ASSERT(pClient != NULL);
	ASSERT(pClient->m_hWnd != NULL);
	
	CRollupHeader *pHeader = new CRollupHeader;
	pHeader->Create(NULL, NULL, WS_CHILD | WS_VISIBLE, CRect(0,0,0,0), this, rand());
	pHeader->SetHeight(m_iHeaderHeight);
	pHeader->Expand(bExpanded);
	pHeader->SetLeftText(strLeft);
	pHeader->SetRightText(strRight);
	
	CRollupGripper *pGripper = new CRollupGripper;
	pGripper->Create(NULL, NULL, WS_CHILD, CRect(0,0,60,15), this, rand());
	
	RollupEntry *pEntry = new RollupEntry;
	pEntry->pHeader	 = pHeader;
	pEntry->pGripper = pGripper;
	pEntry->pClient  = pClient;	
	pEntry->iMinHeight = RUP_ENTRYMINHEIGHT;
	
	int iPos;
	if(iIndex < 0)
		iPos = (int)m_List.Add(pEntry);
	else
	{
		m_List.InsertAt(iIndex, pEntry);
		iPos = iIndex;
	}

	if(bExpanded)
	{	
		m_iExpandedMsk |= (1 << iPos);
		m_iExpandedItems++;
	}

	return iPos;
}

void CRollupCtrl::OnPaint() 
{	
	CPaintDC dc(this);
	
	CRect rClient;
	GetClientRect(&rClient);
	
	int iExpandedItems = 0;
	int iYpos = 0;
	int iCount = (int)m_List.GetSize();

	CDeferPos dp(iCount * 3 - 1);

	for(int i = 0; i < iCount; i++)
	{	
		RollupEntry *pEntry = m_List.GetAt(i);
		ASSERT(pEntry != NULL);
	
		dp.MoveWindow(pEntry->pHeader, rClient.left, rClient.top + iYpos,
						rClient.Width(), m_iHeaderHeight, TRUE); 
	
		iYpos += m_iHeaderHeight;

		if(pEntry->pHeader->IsExpanded())
		{	
			iExpandedItems++;

			double dblHeight = static_cast<double>(rClient.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems)) * pEntry->adSizes[m_iExpandedMsk] / 100.0;
			int iHeight = static_cast<int>(dblHeight + .5);
			bool bShowGripper;
			
			if(i >= iCount-1) // lastitem?
			{
				iHeight += RUP_BORDERSIZES;

				if(pEntry->pGripper->IsWindowVisible())
				{
					pEntry->pGripper->ShowWindow(SW_HIDE);
					pEntry->pGripper->EnableWindow(FALSE);
				}
				bShowGripper = false;
			}
			else
			{	
				if(m_iExpandedItems > iExpandedItems)
				{
					iHeight -= RUP_GRIPPERHEIGHT + RUP_BORDERSIZES;
					bShowGripper = true;
				}
				else
				{
					bShowGripper = false;
					if(pEntry->pGripper->IsWindowVisible())
					{
						pEntry->pGripper->ShowWindow(SW_HIDE);
						pEntry->pGripper->EnableWindow(FALSE);
					}
				}
			}
	
			CRect rPClient = rClient;
			rPClient.top += iYpos;
			rPClient.bottom = rPClient.top + iHeight - 1;
			CWnd *pClientParent = pEntry->pClient->GetParent();
			if(pClientParent != NULL && pClientParent != this)
			{
				ClientToScreen(&rPClient);
				pClientParent->ScreenToClient(&rPClient);
			}

			pEntry->pClient->EnableWindow();
			dp.MoveWindow(pEntry->pClient, rPClient.left, rPClient.top, rPClient.Width(), rPClient.Height(), TRUE);
			pEntry->pClient->ShowWindow(SW_SHOW); // need OnShowWindow in CInfoListCtrl
			
			CRect rFill = rClient;
			rFill.top = rPClient.bottom;

			iYpos += iHeight + RUP_BORDERSIZES;
			
			if(bShowGripper)
			{
				dp.SetWindowPos(pEntry->pGripper, NULL, 
								rClient.left + rClient.Width() / 2 - RUP_GRIPPERWIDTH / 2,
								rClient.top + iYpos, RUP_GRIPPERWIDTH, RUP_GRIPPERHEIGHT, 
								SWP_NOZORDER|SWP_NOSIZE|SWP_SHOWWINDOW);
				pEntry->pGripper->EnableWindow();

				iYpos += RUP_GRIPPERHEIGHT + RUP_BORDERSIZES;
			}

			rFill.bottom = rClient.top + iYpos;
			dc.FillSolidRect(rFill, GetSysColor(COLOR_BTNFACE));
		}
		else
		{
			if(pEntry->pGripper->IsWindowEnabled())
				pEntry->pGripper->EnableWindow(FALSE);
			if(pEntry->pGripper->IsWindowVisible())
				pEntry->pGripper->ShowWindow(SW_HIDE);
			if(pEntry->pClient->IsWindowEnabled())
				pEntry->pClient->EnableWindow(FALSE);
			if(pEntry->pClient->IsWindowVisible())
				pEntry->pClient->ShowWindow(SW_HIDE);
		}
	}

	if(iExpandedItems == 0)
	{
		CRect rFill = rClient;
		rFill.top = rClient.top + iYpos;
		dc.FillSolidRect(rFill, GetSysColor(COLOR_BTNFACE));
	}
}

void CRollupCtrl::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);
}

BOOL CRollupCtrl::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	switch(wParam)
	{
		case USRMSG_STATECHANGED:
		{		
			ChildStateChanged((HWND)lParam, true);
			break;
		}
		case USRMSG_GRIPPERMOVE:
		{
			if(Recalc((HWND)lParam))
				Invalidate();			
			break;
		}
		case USRMSG_RIGHTCLICK:
		{
			if(m_List.GetAt(1)->pHeader->m_hWnd == (HWND)lParam)
				GetParent()->SendMessage(WM_COMMAND, USRMSG_SWITCHUPLOADLIST, 0);
			else if(m_List.GetAt(0)->pHeader->m_hWnd == (HWND)lParam)
				GetParent()->SendMessage(WM_COMMAND, USRMSG_CLEARCOMPLETED, 0);
		}
		default: 
		{
			//GetParent()->PostMessage(WM_COMMAND, wParam, lParam);
			break;
		}
	}
	
	return CWnd::OnCommand(wParam, lParam);
}

int CRollupCtrl::SetText(int iItem, const CString &strText, bool bLeft)
{
	if (static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize()))
		return -1;
	
	if(bLeft)
		m_List.GetAt(iItem)->pHeader->SetLeftText(strText);
	else
		m_List.GetAt(iItem)->pHeader->SetRightText(strText);

	return 0;
}

int CRollupCtrl::SetHeaderColor(int iItem, int iColor, COLORREF crColor)
{
	if (static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize()))
		return -1;

	switch(iColor%3)
	{
		case 0:
			m_List.GetAt(iItem)->pHeader->SetBackColor(crColor);
			break;
		case 1:
			m_List.GetAt(iItem)->pHeader->SetTextColor(crColor);
			break;
		case 2:
			m_List.GetAt(iItem)->pHeader->SetBorderColor(crColor);
			break;
	}

	return 0;
}

BOOL CRollupCtrl::OnEraseBkgnd(CDC* pDC)
{
	NOPRM(pDC);
	return FALSE;
}

int CRollupCtrl::SetItemHeights(int iItem, double *pHeights, unsigned uiSize)
{
	RollupEntry *pEntry;

	if ((static_cast<unsigned>(iItem) >= static_cast<unsigned>(m_List.GetSize())) || (uiSize > sizeof(pEntry->adSizes)))
		return -1;

	pEntry = m_List.GetAt(iItem);
	memcpy2(pEntry->adSizes, pHeights, uiSize);
	return 0;
}

int CRollupCtrl::Recalc(HWND hWnd)
{
	int iCount = m_List.GetSize();

	for(int i = 0; i < iCount; i++)
	{
		RollupEntry *pEntry = m_List.GetAt(i);
		if(pEntry->pGripper->m_hWnd == hWnd)
		{	
			CRect rClientRect;
			GetClientRect(&rClientRect);
						
			RollupEntry *pNextEntry = m_List.GetAt(i+1);		// ToDO: Error-Handling
			if(!pNextEntry->pHeader->IsExpanded())
			{
				if(i+2 < iCount)
					pNextEntry = m_List.GetAt(i+2);
				else
					return 0;
			}
			
			int iMove = pEntry->pGripper->GetLastMove();
			double dCurrEntry = pEntry->adSizes[m_iExpandedMsk];
			double dNextEntry = pNextEntry->adSizes[m_iExpandedMsk];
			double dblTotal = dCurrEntry + dNextEntry;

			// get window heights:
			double dblSize = static_cast<double>(rClientRect.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems));
			double dblHeight1 = dblSize / 100.0 * dCurrEntry - RUP_GRIPPERHEIGHT - RUP_BORDERSIZES;
			double dblHeight2 = dblSize / 100.0 * dNextEntry;
				
			if(pNextEntry->pHeader->IsExpanded() && i+1 < iCount-1)
				dblHeight2 -= (RUP_GRIPPERHEIGHT + RUP_BORDERSIZES);
			
			// change the heights:
			if(iMove >= 0)
			{
				dblHeight1 -= iMove;
				if(dblHeight1 <= pEntry->iMinHeight)
				{	
					iMove -= pEntry->iMinHeight - static_cast<int>(dblHeight1);
					dblHeight1 = pEntry->iMinHeight;
				}												
				dblHeight2 += iMove;
			}
			else
			{
				iMove = -iMove;
				dblHeight2 -= iMove;
				if(dblHeight2 <= pNextEntry->iMinHeight)
				{
					iMove -= pNextEntry->iMinHeight - static_cast<int>(dblHeight2);
					dblHeight2 = pNextEntry->iMinHeight;
				}
				dblHeight1 += iMove;
			}

			if(pNextEntry->pHeader->IsExpanded() && i+1 < iCount-1)
				dblHeight2 += RUP_GRIPPERHEIGHT + RUP_BORDERSIZES;
			// calc the percentages
			dCurrEntry = (dblHeight1 + RUP_GRIPPERHEIGHT+RUP_BORDERSIZES) / dblSize * 100.0;
			dNextEntry = dblTotal - dCurrEntry;

			if(dCurrEntry < 10)	// should be changed sometime
			{
				dNextEntry -= (10 - dCurrEntry);
				dCurrEntry = 10;
			}
			pEntry->adSizes[m_iExpandedMsk] = dCurrEntry;
			pNextEntry->adSizes[m_iExpandedMsk] = dNextEntry;
		}
	}

	return 1;
}

int CRollupCtrl::SetItemClient(int iItem, CWnd *pClient)
{
	if (static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize()))
		return -1;

	m_List.GetAt(iItem)->pClient = pClient;
	return 0;
}

CWnd* CRollupCtrl::GetItemClient(int iItem)
{
	if (static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize()))
		return NULL;

	return m_List.GetAt(iItem)->pClient;
}

RollupEntry* CRollupCtrl::GetItem(int iItem)
{
	if (static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize()))
		return NULL;

	return m_List.GetAt(iItem);
}

int CRollupCtrl::ExpandItem(int iItem, bool bExpand)
{
	if (static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize()))
		return -1;
	
	RollupEntry *pEntry = m_List.GetAt(iItem);

	if (pEntry->pHeader->IsExpanded() != bExpand)
	{
		pEntry->pHeader->Expand(bExpand, false);
		ChildStateChanged(pEntry->pHeader->m_hWnd, false);
	}
	return 0;
}

void CRollupCtrl::ChildStateChanged(HWND hChild, bool bInvalidate)
{
	int iEntry, iCount = m_List.GetSize();

	for(int i = 0; i < iCount; i++)
	{	
		RollupEntry *pEntry = m_List.GetAt(i);

		if(pEntry->pHeader->m_hWnd == hChild)
		{
			iEntry = (1 << i);
			if(pEntry->pHeader->IsExpanded())
			{
				m_iExpandedMsk |= iEntry;
				m_iExpandedItems++;
			}
			else
			{
				m_iExpandedMsk &= ~iEntry;
				m_iExpandedItems--;
			}
			break;
		}
	}

	if(bInvalidate)
		Invalidate();
}

// redirect notify messages to the owner
BOOL CRollupCtrl::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	CWnd *pParent = GetParent();

	if(pParent)
	{
		*pResult = pParent->SendMessage(WM_NOTIFY, wParam, lParam);
		return TRUE;
	}
	return CWnd::OnNotify(wParam, lParam, pResult);
}
@


1.15
log
@use the default GUI font to display Unicode properly
@
text
@d28 1
@


1.14
log
@Reduced H-file dependency; Formatting and clean-up; Suppressed compiler warnings;
Slightly better memory allocation strategy; Some generic optimization.
@
text
@d49 6
a54 2
			
	m_cfTextFont.CreateFont(-10,0,0,0,0,0,0,0,0,1,2,1,34,_T("MS Sans Serif"));
@


1.13
log
@minor correction for previous changes (thk Aw3) & futher formating
@
text
@d1 16
d27 1
a29 1
#include ".\rollupctrl.h"
a36 1

a38 1

a40 4
	//m_crBackColor	= RGB(80,80,80);
	//m_crTextColor	= RGB(255,255,255);
	//m_crBorderColor = LightenColor(m_crBackColor, -40);
	
a76 1
	//{{AFX_MSG_MAP(CRollupHeader)
a79 1
	//}}AFX_MSG_MAP
a86 1

a88 1

d255 1
a258 1

d261 1
a261 3

CRollupCtrl::CRollupCtrl()
: m_iHeaderHeight(0)
d265 1
a265 1
	m_bExpandedItems = 0x00;
a288 2
			if(pEntry->pSizes != NULL)
				delete [] pEntry->pSizes;
a295 1

a296 1
	//{{AFX_MSG_MAP(CRollupCtrl)
a299 1
	//}}AFX_MSG_MAP
a301 1

a322 1
	pEntry->pSizes	 = new double[10];			// max. 8 items
d336 1
a336 2
		BYTE bEntry = 0x01 << iPos;
		m_bExpandedItems |= bEntry;
d370 2
a371 6
			double dblHeight = static_cast<double>(rClient.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems)) * pEntry->pSizes[m_bExpandedItems] / 100.0;
			int iHeight = static_cast<int>(dblHeight);

			if(dblHeight - iHeight >= 0.5)
				iHeight++;
			
d528 1
a528 1
BOOL CRollupCtrl::OnEraseBkgnd(CDC* pDC) 
d530 1
a530 3
	//CRect r;
	//GetClientRect(&r);
	//pDC->FillSolidRect(r, GetSysColor(COLOR_BTNFACE));
d534 1
a534 1
int CRollupCtrl::SetItemHeights(int iItem, double *pHeights, int iCount)
d536 3
a538 1
	if ((static_cast<unsigned int>(iItem) >= static_cast<unsigned int>(m_List.GetSize())) || (iCount > 10) )
d541 2
a542 3
	RollupEntry *pEntry = m_List.GetAt(iItem);

	memcpy2(pEntry->pSizes, pHeights, iCount * sizeof(double));
d568 3
a570 1
			double dblTotal = pEntry->pSizes[m_bExpandedItems] + pNextEntry->pSizes[m_bExpandedItems];
d574 2
a575 2
			double dblHeight1 = dblSize / 100.0 * pEntry->pSizes[m_bExpandedItems] - RUP_GRIPPERHEIGHT - RUP_BORDERSIZES;
			double dblHeight2 = dblSize / 100.0 * pNextEntry->pSizes[m_bExpandedItems];
d606 2
a607 2
			pEntry->pSizes[m_bExpandedItems] = (dblHeight1 + RUP_GRIPPERHEIGHT+RUP_BORDERSIZES) / dblSize * 100.0;
			pNextEntry->pSizes[m_bExpandedItems] = dblTotal - pEntry->pSizes[m_bExpandedItems];
d609 1
a609 1
			if(pEntry->pSizes[m_bExpandedItems] < 10)	// should be changed sometime
d611 2
a612 2
				pNextEntry->pSizes[m_bExpandedItems] -= (10-pEntry->pSizes[m_bExpandedItems]);
				pEntry->pSizes[m_bExpandedItems] = 10;
d614 2
d664 1
a664 1
	int iCount = m_List.GetSize();
d672 1
a672 2
			BYTE bEntry = 0x01 << i;

d675 1
a675 1
				m_bExpandedItems |= bEntry;
d680 1
a680 1
				m_bExpandedItems &= ~bEntry;
a693 1
	NMHDR* pNMHDR = (NMHDR*)lParam;
@


1.12
log
@some optimization & formatting
@
text
@d267 1
d502 1
a502 1
int CRollupCtrl::SetText(int iItem, const CString& strText, bool bLeft)
d504 1
a504 1
	if (iItem >= m_List.GetSize())
d517 1
a517 1
	if (iItem >= m_List.GetSize())
d522 9
a530 3
		case 0:	m_List.GetAt(iItem)->pHeader->SetBackColor(crColor); break;
		case 1:	m_List.GetAt(iItem)->pHeader->SetTextColor(crColor); break;
		case 2:	m_List.GetAt(iItem)->pHeader->SetBorderColor(crColor); break;
d546 1
a546 1
	if ((iItem >= m_List.GetSize()) || (iCount > 10))
d550 1
a551 1

d557 2
a558 1
	int iCount = (int)m_List.GetSize();
d560 1
a560 1
	{			
d628 2
a629 2
{	
	if (iItem >= m_List.GetSize())
d638 1
a638 1
	if (iItem >= m_List.GetSize())
d646 1
a646 1
	if (iItem >= m_List.GetSize())
d654 1
a654 1
	if (iItem >= m_List.GetSize())
d667 1
a667 1
void CRollupCtrl::ChildStateChanged(const HWND hChild, bool bInvalidate)
d669 2
a670 1
	int iCount = (int)m_List.GetSize();
d674 1
d676 1
a676 1
		{					
d680 1
a680 1
			{	
d683 1
a683 1
			}					
d685 1
a685 1
			{	
d702 1
@


1.11
log
@Compatibility with VC2005 [brengarne].
@
text
@a7 1
//#include "emule.h"
d60 1
a60 1
		if(m_pOldMemBMP)
d62 1
a62 1
	}	
d212 1
a212 1
void CRollupHeader::DrawArrow(CDC* pDC, CPoint* pTopLeft, bool bDown)
d266 1
a266 1
	int iCount = (int)m_List.GetSize();
d270 3
a272 3
		if(pEntry)
		{	
			if(pEntry->pHeader)
d278 1
a278 1
			if(pEntry->pGripper)
d284 1
a284 1
			if(pEntry->pSizes)
d373 2
a374 2
			CRect rFillRect = rClient;
			rFillRect.top += iYpos;
a375 2
			double dblHeight = (rClient.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems)) * pEntry->pSizes[m_bExpandedItems] / 100.0;
			int iHeight = static_cast<int>(dblHeight);
d501 1
a501 1
int CRollupCtrl::SetText(unsigned uiItem, CString strText, bool bLeft)
d503 1
a503 1
	if (uiItem >= static_cast<unsigned>(m_List.GetSize()))
d507 1
a507 1
		m_List.GetAt(uiItem)->pHeader->SetLeftText(strText);
d509 1
a509 1
		m_List.GetAt(uiItem)->pHeader->SetRightText(strText);
d514 1
a514 1
int CRollupCtrl::SetHeaderColor(unsigned uiItem, int iColor, COLORREF crColor)
d516 1
a516 1
	if (uiItem >= static_cast<unsigned>(m_List.GetSize()))
d521 3
a523 3
		case 0:	m_List.GetAt(uiItem)->pHeader->SetBackColor(crColor); break;
		case 1:	m_List.GetAt(uiItem)->pHeader->SetTextColor(crColor); break;
		case 2:	m_List.GetAt(uiItem)->pHeader->SetBorderColor(crColor); break;
d537 1
a537 1
int CRollupCtrl::SetItemHeights(unsigned uiItem, double *pHeights, int iCount)
d539 1
a539 1
	if ((uiItem >= static_cast<unsigned>(m_List.GetSize())) || (iCount > 10))
d542 1
a542 1
	RollupEntry *pEntry = m_List.GetAt(uiItem);
a568 1
			
d619 1
a619 1
int CRollupCtrl::SetItemClient(unsigned uiItem, CWnd *pClient)
d621 1
a621 1
	if (uiItem >= static_cast<unsigned>(m_List.GetSize()))
d624 1
a624 1
	m_List.GetAt(uiItem)->pClient = pClient;
d628 1
a628 1
CWnd* CRollupCtrl::GetItemClient(unsigned uiItem)
d630 1
a630 1
	if (uiItem >= static_cast<unsigned>(m_List.GetSize()))
d633 1
a633 1
	return m_List.GetAt(uiItem)->pClient;
d636 1
a636 1
RollupEntry* CRollupCtrl::GetItem(unsigned uiItem)
d638 1
a638 1
	if (uiItem >= static_cast<unsigned>(m_List.GetSize()))
d641 1
a641 1
	return m_List.GetAt(uiItem);
d644 1
a644 1
int CRollupCtrl::ExpandItem(unsigned uiItem, bool bExpand)
d646 1
a646 1
	if (uiItem >= static_cast<unsigned>(m_List.GetSize()))
d649 1
a649 1
	RollupEntry *pEntry = m_List.GetAt(uiItem);
d659 1
a659 1
void CRollupCtrl::ChildStateChanged(HWND hChild, bool bInvalidate)
@


1.10
log
@Fixed exception during gui.dat saving after failed startup
(before gui.dat was reset to zero size);
Reduced memory used by rollup controls; Minor optimization.
@
text
@d589 1
a589 1
					iMove -= pEntry->iMinHeight - dblHeight1;
d600 1
a600 1
					iMove -= pNextEntry->iMinHeight - dblHeight2;
@


1.9
log
@Remake for display '&' on info pane; now also all fields can show '&' correctly.
@
text
@d325 1
a325 1
	pEntry->pSizes	 = new double[256];			// max. 8 items
d504 1
a504 1
int CRollupCtrl::SetText(int iItem, CString strText, bool bLeft)
d506 1
a506 1
	if(iItem < 0 || iItem >= m_List.GetSize())
d510 1
a510 1
		m_List.GetAt(iItem)->pHeader->SetLeftText(strText);
d512 1
a512 1
		m_List.GetAt(iItem)->pHeader->SetRightText(strText);
d514 1
a514 1
	return iItem;
d517 1
a517 1
int CRollupCtrl::SetHeaderColor(int iItem, int iColor, COLORREF crColor)
d519 1
a519 1
	if(iItem < 0 || iItem >= m_List.GetSize())
d524 3
a526 3
		case 0:	m_List.GetAt(iItem)->pHeader->SetBackColor(crColor); break;
		case 1:	m_List.GetAt(iItem)->pHeader->SetTextColor(crColor); break;
		case 2:	m_List.GetAt(iItem)->pHeader->SetBorderColor(crColor); break;
d529 1
a529 1
	return iItem;
d540 1
a540 1
int CRollupCtrl::SetItemHeights(int iItem, double *pHeights, int iCount)
d542 1
a542 1
	if(iItem < 0 || iItem >= m_List.GetSize() || iCount >= 256)
d545 2
a546 3
	RollupEntry *pEntry = m_List.GetAt(iItem);
	for(int i = 0; i < iCount; i++)
		pEntry->pSizes[i] = pHeights[i];
d623 1
a623 1
int CRollupCtrl::SetItemClient(int iItem, CWnd *pClient)
d625 1
a625 1
	if(iItem < 0 || iItem >= m_List.GetSize())
d628 1
a628 1
	m_List.GetAt(iItem)->pClient = pClient;
d632 1
a632 1
CWnd* CRollupCtrl::GetItemClient(int iItem)
d634 1
a634 1
	if(iItem < 0 || iItem >= m_List.GetSize())
d637 1
a637 1
	return m_List.GetAt(iItem)->pClient;
d640 1
a640 1
RollupEntry* CRollupCtrl::GetItem(int iItem)
d642 1
a642 1
	if(iItem < 0 || iItem >= m_List.GetSize())
d645 1
a645 1
	return m_List.GetAt(iItem);
d648 1
a648 1
int CRollupCtrl::ExpandItem(int iItem, bool bExpand)
d650 1
a650 1
	if(iItem < 0 || iItem >= m_List.GetSize())
d653 1
a653 1
	RollupEntry *pEntry = m_List.GetAt(iItem);
d655 5
a659 4
	if(pEntry->pHeader->IsExpanded() == bExpand)
		return 0;
	pEntry->pHeader->Expand(bExpand, false);
	ChildStateChanged(pEntry->pHeader->m_hWnd, false);
d671 2
a674 1
				BYTE bEntry = 0x01 << i;
a679 1
				BYTE bEntry = 0x01 << i;
d683 1
a683 2

			i = iCount;
@


1.8
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d139 4
a142 2
	m_MemDC.DrawText(m_strRightText, m_rTextRect, DT_RIGHT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
	m_MemDC.DrawText(m_strLeftText, m_rTextRect, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);		
@


1.7
log
@Small color fix
@
text
@d323 1
a323 1
	pEntry->pSizes	 = new float[256];			// max. 8 items
d375 3
a377 3
			float fHeight = (rClient.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems)) * pEntry->pSizes[m_bExpandedItems] / 100;
			int iHeight = (int)fHeight;
			if(fHeight - iHeight >= 0.5)
d538 1
a538 1
int CRollupCtrl::SetItemHeights(int iItem, float *pHeights, int iCount)
d572 1
a572 1
			float fTotal = pEntry->pSizes[m_bExpandedItems] + pNextEntry->pSizes[m_bExpandedItems];
d575 3
a577 3
			float fSize = (float)(rClientRect.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems));
			float fHeight1 = fSize / 100 * pEntry->pSizes[m_bExpandedItems] - RUP_GRIPPERHEIGHT - RUP_BORDERSIZES;
			float fHeight2 = fSize / 100 * pNextEntry->pSizes[m_bExpandedItems];
d580 1
a580 1
				fHeight2 -= (RUP_GRIPPERHEIGHT + RUP_BORDERSIZES);
d585 2
a586 2
				fHeight1 -= iMove;
				if(fHeight1 <= pEntry->iMinHeight)
d588 2
a589 2
					iMove -= (int)(pEntry->iMinHeight - fHeight1);
					fHeight1 = (float)pEntry->iMinHeight;		
d591 1
a591 1
				fHeight2 += iMove;
d596 2
a597 2
				fHeight2 -= iMove;
				if(fHeight2 <= pNextEntry->iMinHeight)
d599 2
a600 2
					iMove -= (int)(pNextEntry->iMinHeight - fHeight2);
					fHeight2 = (float)pNextEntry->iMinHeight;
d602 1
a602 1
				fHeight1 += iMove;
d606 1
a606 1
				fHeight2 += RUP_GRIPPERHEIGHT + RUP_BORDERSIZES;
d608 2
a609 2
			pEntry->pSizes[m_bExpandedItems] = (fHeight1 + RUP_GRIPPERHEIGHT+RUP_BORDERSIZES) / fSize * 100;
			pNextEntry->pSizes[m_bExpandedItems] = fTotal - pEntry->pSizes[m_bExpandedItems];
@


1.6
log
@Changed the #ifdefs to use a single switch. Put NEW_LOOK into your preprocessor defines for the new look.
@
text
@d119 1
a119 1
#ifndef NEW
d128 1
a128 1
#endif
d193 1
a193 1
#ifdef OLD
d199 1
a199 1
#endif OLD
@


1.5
log
@Changed back to standard windows colors.
@
text
@d32 1
a32 1
#ifdef OLD
d38 1
a38 1
#endif OLD
@


1.4
log
@*** empty log message ***
@
text
@d32 1
d35 4
d118 12
a129 1
	
d193 1
d196 4
@


1.3
log
@*** empty log message ***
@
text
@d32 2
a33 2
	m_crBackColor = GetSysColor(COLOR_INACTIVECAPTION);	//GetSysColor(COLOR_3DDKSHADOW);
	m_crTextColor = GetSysColor(COLOR_INACTIVECAPTIONTEXT);	//GetSysColor(COLOR_3DHIGHLIGHT);
@


1.2
log
@unicode cleanup
@
text
@d8 1
a8 1
#include "emule.h"
d10 1
a11 1
#include "DownloadListCtrl.h"
d13 2
a21 19
COLORREF LightenColor(COLORREF crColor, int iDiv)
{
	int R = GetRValue(crColor);
	int G = GetGValue(crColor);
	int B = GetBValue(crColor);

	R += iDiv;
	G += iDiv;
	B += iDiv;
	
	if(R > 255)	R = 255;
	if(G > 255) G = 255;
	if(B > 255) B = 255;
	if(R < 0)	R = 0;
	if(G < 0)	G = 0;
	if(B < 0)	B = 0;

	return RGB(R,G,B);		
}
d32 2
a33 2
	m_crBackColor = GetSysColor(COLOR_3DDKSHADOW);
	m_crTextColor = GetSysColor(COLOR_3DHIGHLIGHT);
d71 2
d143 1
a143 1
		GetParent()->SendMessage(WM_COMMAND, USRMSG_STATECHANGED, (long)m_hWnd);
d156 1
a156 1
		GetParent()->SendMessage(WM_COMMAND, USRMSG_STATECHANGED, (long)m_hWnd);
d164 1
a164 1
	GetParent()->SendMessage(WM_COMMAND, USRMSG_RIGHTCLICK, (long)m_hWnd);
d225 6
d244 1
a244 1
	int iCount = m_List.GetSize();
d307 1
a307 1
		iPos = m_List.Add(pEntry);
d328 3
a330 3
	CRect rClientRect;
	GetClientRect(&rClientRect);
		
d333 4
a336 2
	int iCount = m_List.GetSize();
	HDWP hdwp = BeginDeferWindowPos(m_iExpandedItems + iCount+2);
d342 3
a344 3
		hdwp = ::DeferWindowPos(hdwp, pEntry->pHeader->m_hWnd, NULL, 
									rClientRect.left, rClientRect.top + iYpos,
										rClientRect.Width(), m_iHeaderHeight, SWP_NOZORDER); 
d351 1
a351 1
			CRect rFillRect = rClientRect;
d354 1
a354 1
			float fHeight = (rClientRect.Height() - (m_iHeaderHeight * m_List.GetSize() + RUP_BORDERSIZES * m_iExpandedItems)) * pEntry->pSizes[m_bExpandedItems] / 100;
d390 10
d401 1
a401 5
		
			hdwp = ::DeferWindowPos(hdwp, pEntry->pClient->m_hWnd, NULL,
										rClientRect.left, rClientRect.top + iYpos, 
											rClientRect.Width(), iHeight-1,
												SWP_NOZORDER); // | SWP_SHOWWINDOW);
d403 4
a406 1
						
d408 1
a408 1

d411 4
a414 4
				hdwp = ::DeferWindowPos(hdwp, pEntry->pGripper->m_hWnd, NULL,
											rClientRect.left + rClientRect.Width() / 2 - RUP_GRIPPERWIDTH / 2, 
												rClientRect.top + iYpos, RUP_GRIPPERWIDTH, RUP_GRIPPERHEIGHT,
													SWP_NOZORDER | SWP_SHOWWINDOW);
d419 3
d435 7
a441 1
	EndDeferWindowPos(hdwp);
d469 1
a469 1
				((CDownloadListCtrl*)m_List.GetAt(0)->pClient)->ClearCompleted();
d511 4
a514 4
	CRect r;
	GetClientRect(&r);
	pDC->FillSolidRect(r, GetSysColor(COLOR_BTNFACE));
	return CWnd::OnEraseBkgnd(pDC);
d531 1
a531 1
	int iCount = m_List.GetSize();
a639 12
// added for tooltip notify:
BOOL CRollupCtrl::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
{	
	if(nCode == 0x4EFDF8) // 0x4EFDF8 ??? 
	{	
		CWnd *pParent = GetParent();
		if(pParent)
			pParent->OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
	}
	return CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

d642 1
a642 1
	int iCount = m_List.GetSize();
d667 13
@


1.1
log
@*** empty log message ***
@
text
@d53 1
a53 1
	m_cfTextFont.CreateFont(-10,0,0,0,0,0,0,0,0,1,2,1,34,"MS Sans Serif");
d292 1
a292 1
int CRollupCtrl::InsertItem(LPCSTR strLeft, LPCSTR strRight, CWnd *pClient, int iIndex, bool bExpanded)
@


1.1.4.1
log
@updating this branch...
@
text
@@

