head	1.39;
access;
symbols
	PublicRelease_1_2e:1.38
	Interim_Release_1-2e_RC1:1.38
	PublicRelease_1_2d:1.36
	Interim_Release_1-2d_RC1:1.36
	Interim_Release_1-2d_beta1:1.33
	PublicRelease_1_2c:1.32
	Interim_Release_1-2c_RC1:1.32
	Interim_Release_1-2c_beta1:1.32
	PublicRelease_1_2b:1.32
	Interim_Release_1-2b_RC1:1.32
	PublicRelease_1_2a:1.32
	Interim_Release_1-2a_RC1:1.30
	Interim_Release_1-2a_beta2:1.29
	Interim_Release_1-2a_beta1:1.29
	PublicRelease_1_2:1.29
	Interim_Release_1-2_RC1:1.29
	Interim_Release_1-2_beta1:1.29
	PublicRelease_1_1g:1.29
	Interim_Release_1-1g_RC3:1.29
	Interim_Release_1-1g_RC2:1.29
	Interim_Release_1-1g_RC1:1.29
	Interim_Release_1-1g_beta2:1.28
	Interim_Release_1-1g_beta1:1.28
	PublicRelease_1_1f:1.28
	Interim_Release_1-1f_RC1:1.28
	PublicRelease_1_1e:1.28
	Interim_Release_1-1e_RC2:1.28
	Interim_Release_1-1e_RC1:1.28
	Interim_Release_1-1e_beta1:1.28
	PublicRelease_1_1d:1.28
	Interim_Release_1-1d_RC1:1.28
	PublicRelease_1_1c:1.28
	Interim_Release_1-1c_RC1:1.28
	Interim_Release_1-1c_beta2:1.28
	Interim_Release_1-1c_beta1:1.25
	PublicRelease_1_1b:1.25
	Interim_Release_1-1b_RC1:1.25
	PublicRelease_1_1a:1.25
	Interim_Release_1-1a_RC2:1.25
	Interim_Release_1-1a_RC1:1.25
	Interim_Release_1-1a_beta2:1.25
	Interim_Release_1-1a_beta1:1.25
	PublicRelease_1_1:1.25
	Interim_Release_1-1_beta1:1.25
	PublicRelease_1o:1.25
	Interim_Release_1o_RC1:1.25
	Interim_Release_1o_beta1:1.25
	PublicRelease_1n:1.25
	Interim_Release_1n_RC2:1.25
	Interim_Release_1n_RC1:1.25
	Interim_Release_1n_beta2:1.25
	Interim_Release_1n_beta1:1.24
	PublicRelease_1m:1.23
	Interim_Release_1m_beta1:1.23
	PublicRelease_1l:1.23
	Interim_Release_1l_RC3:1.23
	Interim_Release_1l_RC2:1.22
	Interim_Release_1l_RC1:1.21
	Interim_Release_1l_beta2:1.20
	Interim_Release_1l_beta1:1.19
	PublicRelease_1k:1.16
	Interim_Release_1k_RC4:1.16
	Interim_1k_RC3:1.16
	Interim_1k_RC2:1.15
	Interim_Release_1k_RC1:1.15
	Interim_Release_1k_beta5:1.15
	Intrerim_Release_1k_beta4:1.15
	Interim_Release_1k_beta1:1.15
	PublicRelease_1j:1.15
	Interim_Release_1J_RC3:1.15
	Interim_Release_1j_RC3:1.15
	Interim_Release_1j_RC2:1.14
	Interim_Release_1j_RC1:1.14
	Interim_Release_1j_beta2:1.14
	Interim_Release_1j_beta1:1.14
	PublicRelease_1i:1.14
	Interim_Release_1i_RC6:1.14
	Interim_Release_1i_RC3:1.14
	Interim_Release_1i_RC2:1.14
	Interim_Release_1i_RC1:1.13
	Interim_Release_1i_beta3:1.12
	Interim_Release_1i_beta2:1.10
	Interim_Release_1i_beta1:1.7
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.4
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.3
	Interim_Release_1g_beta1:1.3
	Interim_Release_1f_RC4:1.3
	Interim_Release_1f_RC3:1.3
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.4
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.2
	threaded_downloadqueue:1.2.0.2
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.39
date	2009.05.14.03.04.47;	author aw3;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.03.05.56.16;	author aw3;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.02.02.47.13;	author aw3;	state Exp;
branches;
next	1.36;

1.36
date	2008.04.06.07.41.02;	author eklmn;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.05.20.22.49;	author eklmn;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.05.09.49.08;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2007.12.16.21.38.00;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2006.09.29.04.03.31;	author aw3;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.25.03.21.40;	author aw3;	state Exp;
branches;
next	1.30;

1.30
date	2006.09.06.05.51.10;	author aw3;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.30.02.23.43;	author aw3;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.07.19.47.22;	author eklmn;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.01.21.25.47;	author eklmn;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.01.19.48.36;	author eklmn;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.06.16.46.02;	author katsyonak;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.06.04.56.40;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.30.02.36.09;	author katsyonak;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.24.21.12.16;	author katsyonak;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.20.00.12.24;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.06.04.01.14;	author katsyonak;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.11.11.45.59;	author eklmn;	state Exp;
branches;
next	1.16;

1.16
date	2004.04.02.17.22.08;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.19.18.21.28;	author dropf;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.11.15.55.42;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.04.16.09.17;	author katsyonak;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.30.02.44.37;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.29.22.13.32;	author dropf;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.24.01.21.19;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.03.13.05.59;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.14.13.48.42;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.20.20.46.28;	author netwolf1;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.14.09.45.23;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.20;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.16;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Save sorting directions for all GUI lists; Unified list sort initialization and click processing;
Simplified list arrow configuration interface; Reduced H-file dependency.
@
text
@#pragma once

#define MLC_SORTASC		0
#define MLC_SORTDESC	0x80
#define MLC_SORTALT		0x40	// Sort on alternate value
#define MLC_COLUMNMASK	0x3F
#define MLC_DONTSORT	0xFF

// Quite unique size to separate own search requests from list control ones
#define ML_SEARCH_SZ	510

//////////////////////////////////
class CMuleListCtrl : public CListCtrl
{
	DECLARE_DYNAMIC(CMuleListCtrl)

public:
	CMuleListCtrl(PFNLVCOMPARE pfnCompare = SortProc, DWORD dwParamSort = 0);
	virtual ~CMuleListCtrl();

//	Default sort proc, this does nothing
	static int CALLBACK SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

	void SaveSettings(int iTbl);	//	Save to preferences
	void LoadSettings(int iTbl);	//	Load from preferences

	void HideColumn(int iColumn);	//	Hide the column
	void ShowColumn(int iColumn);	//	Unhide the column

//	Check to see if the column is hidden
	bool IsColumnHidden(int iColumn) const
	{
		if (iColumn < 1 || iColumn >= m_iColumnsTracked)
			return false;

		return m_aColumns[iColumn].bHidden;
	}

//	Get the correct column width even if column is hidden
	int GetColumnWidth(int iColumn) const
	{
		if (iColumn < 0 || iColumn >= m_iColumnsTracked)
			return 0;

		if (m_aColumns[iColumn].bHidden)
			return m_aColumns[iColumn].iWidth;
		else
			return CListCtrl::GetColumnWidth(iColumn);
	}

//	Call SetRedraw to allow changes to be redrawn or to prevent changes from being redrawn.
	void SetRedraw(BOOL bRedraw = TRUE)
	{
		bool	bCall;

		EnterCriticalSection(&m_csRedraw);
	//	Don't call SetRedraw under protection, because of possible deadlock
	//	if dispatch thread also calls SetRedraw inside SendMessage processing
		if (bRedraw)
		{
			bCall = ((m_lRedrawCount > 0) && (--m_lRedrawCount == 0));
			LeaveCriticalSection(&m_csRedraw);
			if (bCall)
				CListCtrl::SetRedraw(TRUE);
		}
		else
		{
			bCall = (m_lRedrawCount++ == 0);
			LeaveCriticalSection(&m_csRedraw);
			if (bCall)
				CListCtrl::SetRedraw(FALSE);
		}
	}
//eklmn: items redraw during resorting is disable, since we have a wrapper function
//	protected by critical section it should not give us any problem.

//	Sorts the list
	BOOL SortItems(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData)
	{
		SetRedraw(FALSE);
		BOOL bResult = CListCtrl::SortItems(pfnCompare, dwData);
		SetRedraw(TRUE);
		return bResult;
	}

//	Sorts the list
	BOOL SortItems(DWORD dwData)
	{
		SetRedraw(FALSE);
		BOOL bResult = CListCtrl::SortItems(m_SortProc, dwData);
		SetRedraw(TRUE);
		return bResult;
	}

//	Sets the sorting procedure
	void SetSortProcedure(PFNLVCOMPARE funcSortProcedure)
	{
		m_SortProc = (funcSortProcedure != NULL) ? funcSortProcedure : SortProc;
	}

	void SortInit(int iSortCode);
 	void SetDoubleLayerSort(const int *piDoubleCols, unsigned uiCnt)	
	{
		m_piDoubleSortCols = piDoubleCols;
		m_uiDoubleSortCnt = uiCnt;
	}

//	Retrieves the data (lParam) associated with a particular item
	DWORD_PTR GetItemData(int iItem);
//	Returns list positions for consecutive GetItemDataByPos()
	POSITION GetItemDataHeadPos() const	{ return m_Params.GetHeadPosition(); }
	POSITION GetItemDataPos(int iItem) const	{ return m_Params.FindIndex(iItem); }
//	Fast item data retrieval (list sorting must be disabled)
	DWORD_PTR GetItemDataByPos(POSITION &pos, int iIdx)
	{
		POSITION	posPrev = pos;
		LPARAM		lParam = m_Params.GetNext(pos);

		if (lParam == 0xFEEBDEEF) //same as MLC_MAGIC!
			m_Params.SetAt(posPrev, lParam = CListCtrl::GetItemData(iIdx));
		return lParam;
	}

//	Retrieves the number of items in the control
	int GetItemCount() const			{ return m_Params.GetCount(); }

	enum	// item order shouldn't be changed
	{
		arrowDown = 0,
		arrowUp,
		arrowDoubleDown,
		arrowDoubleUp,
		arrowDown1,
		arrowUp1,
		arrowDown2,
		arrowUp2,
		arrowDown3,
		arrowUp3
	};

//	Places a sort arrow in a column
	void SetSortArrow(int iColumn, unsigned uiType);
	void SetSortArrow(int iColumn, bool bAscending, int iColumnIndex);

	void ApplyImageList(HIMAGELIST himl);

//	General purpose listview find dialog+functions (optional)
	void SetGeneralPurposeFind(bool bEnable)	{ m_bGeneralPurposeFind = bEnable; }
	void DoFind(int iStartItem, int iDirection /*1=down, 0 = up*/, BOOL bShowError);
	void DoFindNext(BOOL bShowError);
	uint32 GetSortParam() const		{ return m_dwParamSort; }
	void PostUniqueMessage(UINT uiMsg);
	CHeaderCtrl*	GetHeaderCtrl()
	{
		if (m_pHeaderCtrl == NULL)
			m_pHeaderCtrl = CListCtrl::GetHeaderCtrl();

		return m_pHeaderCtrl;
	}

	afx_msg void OnLvnColumnClick(NMHDR *pNMHDR, LRESULT *pResult);

protected:
	virtual void PreSubclassWindow();
	virtual BOOL OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);

	virtual void OnNMDividerDoubleClick(NMHEADER *pNMHDR);

	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnSysColorChange();

	DECLARE_MESSAGE_MAP()

//	Checks the item to see if it is in order
	int UpdateLocation(int iItem);
//	Get location of the item into the sorted list
	int GetNewLocation(const DWORD_PTR dwpItemData, int iItem, bool bInsertion);
//	Moves the item in list and returns the new index
	int MoveItem(int iOldIndex, int iNewIndex);
//	Update the colors
	void SetColors();
	DWORD SetExtendedStyle(DWORD dwNewStyle)
	{
		return CListCtrl::SetExtendedStyle(dwNewStyle | LVS_EX_HEADERDRAGDROP);
	}

	CHeaderCtrl		*m_pHeaderCtrl;
	PFNLVCOMPARE	m_SortProc;
	DWORD			m_dwParamSort;
	COLORREF		m_crWindow;
	COLORREF		m_crWindowText;
	COLORREF		m_crWindowTextBk;
	COLORREF		m_crHighlight;
	COLORREF		m_crGlow;
	COLORREF		m_crGlowText;
	COLORREF		m_crDimmedText;
	COLORREF		m_crFocusLine;
	COLORREF		m_crNoHighlight;
	COLORREF		m_crNoFocusLine;
	NMLVCUSTOMDRAW	m_lvcd;
	bool			m_bCustomDraw;
	CImageList		m_imlHeaderCtrl;

//	General purpose listview find dialog+functions (optional)
	bool m_bGeneralPurposeFind;
	CString m_strFindText;
	int m_iFindDirection;
	int m_iFindColumn;
	void OnFindStart();
	void OnFindNext();
	void OnFindPrev();

private:
	void TextDraw(CDC* pDC, CString &strText, LPRECT lpRect, UINT iFormat, COLORREF crForeground, COLORREF crBackground);

	static int IndexToOrder(CHeaderCtrl* pHeader, int iIndex);

	struct MULE_COLUMN
	{
		int iWidth;
		int iLocation;
		bool bHidden;
	};

	int			m_iColumnsTracked;
	MULE_COLUMN	*m_aColumns;
	unsigned	m_uiTableIdx;
	const int	*m_piDoubleSortCols;
	unsigned	m_uiDoubleSortCnt;
	bool		m_bMovingItem;

	int GetHiddenColumnCount() const
	{
		int iHidden = 0;

		for (int i = 0; i < m_iColumnsTracked; i++)
			if (m_aColumns[i].bHidden)
				iHidden++;
		return iHidden;
	}

	int			m_iCurrentSortItem[3];
	unsigned	m_auiSortArrow[3];

	long m_lRedrawCount;
	CRITICAL_SECTION m_csRedraw;
	CList<DWORD_PTR> m_Params;

	DWORD_PTR GetParamAt(POSITION pos, int iPos)
	{
		LPARAM lParam = m_Params.GetAt(pos);

		if (lParam == 0xFEEBDEEF) //same as MLC_MAGIC!
			m_Params.SetAt(pos, lParam = CListCtrl::GetItemData(iPos));
		return lParam;
	}
};
@


1.38
log
@Simplified column resize interface.
@
text
@a1 2
#include "Preferences.h"
#include "resource.h"
a12 2
//	CMuleListCtrl

d24 2
a25 8
//	Save to preferences
	void SaveSettings(CPreferences::EnumTable tID);

//	Load from preferences
	void LoadSettings(CPreferences::EnumTable tID);

//	Hide the column
	void HideColumn(int iColumn);
d27 2
a28 2
//	Unhide the column
	void ShowColumn(int iColumn);
d101 6
a106 2
//	Gets the sorting procedure
	PFNLVCOMPARE GetSortProcedure()		{ return m_SortProc; }
d127 1
a127 1
	enum ArrowType
d129 10
a138 4
		arrowDown = IDB_DOWN, arrowUp = IDB_UP,
		arrowDoubleDown = IDB_DOWN2X, arrowDoubleUp = IDB_UP2X,
		arrowDown1 = IDB_DOWN1, arrowDown2 = IDB_DOWN2, arrowDown3 = IDB_DOWN3,
		arrowUp1 = IDB_UP1, arrowUp2 = IDB_UP2, arrowUp3 = IDB_UP3,
d142 2
a143 2
	void SetSortArrow(int iColumn, ArrowType atType);
	void SetSortArrow(int iColumn, bool bAscending, int iColumnIndex = 0);
d161 2
d228 6
a233 3
	int m_iColumnsTracked;
	MULE_COLUMN *m_aColumns;
	bool m_bMovingItem;
d246 1
a246 1
	ArrowType	m_atSortArrow[3];
@


1.37
log
@Increased transfer page list performance by not processing meaningless list control GetDispInfo requests.
@
text
@d166 1
a166 1
	virtual BOOL OnNMDividerDoubleClick(NMHEADER* pNMHDR, LRESULT* pResult);
a168 1

@


1.36
log
@changed the handlig of embedded GUI list header (minimal version)
@
text
@d11 3
@


1.35
log
@rolled back last changes.
@
text
@d150 7
d186 1
@


1.34
log
@changed the handlig of embedded GUI list header
@
text
@a149 2
	virtual CHeaderCtrl* GetHeaderCtrl()	{return m_pHeaderCtrl;}
	void	InitHeader()					{m_pHeaderCtrl = CListCtrl::GetHeaderCtrl();}
d159 1
a180 1
	CHeaderCtrl*	m_pHeaderCtrl;
d205 1
a205 1
	static void TextDraw(CDC* pDC, CString &strText, LPRECT lpRect, UINT iFormat, COLORREF crForeground, COLORREF crBackground);
@


1.33
log
@Suppressed level 4 warnings; Formatting.
@
text
@d150 2
a160 1

d182 1
d207 1
a207 1
	void TextDraw(CDC* pDC, CString &strText, LPRECT lpRect, UINT iFormat, COLORREF crForeground, COLORREF crBackground);
@


1.32
log
@One more service for fast list access.
@
text
@d38 1
a38 1
	BOOL IsColumnHidden(int iColumn) const
@


1.31
log
@Introduced new services allowing fast access to the list; Formatting.
@
text
@d113 1
a113 1
//	Returns list head position for consecutive GetItemDataByPos()
d115 1
@


1.30
log
@Removed unused code.
@
text
@d105 1
a105 1
		m_SortProc = funcSortProcedure;
d109 1
a109 4
	PFNLVCOMPARE GetSortProcedure()
	{
		return m_SortProc;
	}
d111 1
a111 1
//	Retrieves the data (lParam) associated with a particular item.
d113 7
d121 3
a123 4
//	Retrieves the number of items in the control.
	int GetItemCount() const
	{
		return m_Params.GetCount();
d126 3
d144 1
a144 4
	void SetGeneralPurposeFind(bool bEnable)
	{
		m_bGeneralPurposeFind = bEnable;
	}
@


1.29
log
@Removed not working code to slightly speed up search in lists.
@
text
@a24 3
//	Sets the list name, used for hide/show menu
	void SetName(LPCTSTR lpszName);

a174 1
	CString			m_Name;
@


1.28
log
@try N2: optimization of execution; some code simplification
@
text
@a197 1
	bool m_bFindMatchCase;
@


1.27
log
@rollback :(
@
text
@d167 2
d219 1
@


1.26
log
@optimization of execution; some code simplification
@
text
@a166 2
//	Get location of the item into the sorted list
	int GetNewLocation(DWORD_PTR dwpItemData, int iItem);
@


1.25
log
@SSWQ
@
text
@d167 2
@


1.24
log
@Color coded IRC channel list description;
Added "WhoIs" context menu to IRC nick list;
Added "Refresh" context menu to IRC channel list.
@
text
@d148 1
@


1.23
log
@GetSortParam method is added.
@
text
@d203 2
@


1.22
log
@Formatting + Minor changes
@
text
@d124 1
a124 1
	};
d147 1
@


1.21
log
@Dim servers that has failed once or more ( with DonGato's approval :-) )
@
text
@d217 1
d234 1
@


1.20
log
@Fixed deadlock inside SetRedraw (a dispatch thread could call SetRedraw
inside SendMessage processing) <thanks muley for report and testing>.
@
text
@d183 1
@


1.19
log
@Different background color for connected server
@
text
@d64 2
d67 2
d71 3
a73 1
			if (m_lRedrawCount > 0 && --m_lRedrawCount == 0)
d78 3
a80 1
			if (m_lRedrawCount++ == 0)
a82 1
		LeaveCriticalSection(&m_csRedraw);
@


1.18
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d167 3
a169 3
	CString m_Name;
	PFNLVCOMPARE m_SortProc;
	DWORD m_dwParamSort;
d175 1
d179 1
a179 1
	NMLVCUSTOMDRAW		m_lvcd;
@


1.17
log
@optimization of sorting over SetRedraw
@
text
@d172 3
a174 1
	COLORREF		 m_crHighlight;
d178 1
a178 1
	NMLVCUSTOMDRAW m_lvcd;
@


1.16
log
@measurements against SetRedraw collision
@
text
@d77 2
d83 4
a86 1
		return CListCtrl::SortItems(pfnCompare, dwData);
d92 4
a95 1
		return CListCtrl::SortItems(m_SortProc, dwData);
@


1.15
log
@Some corrections in shortcut management code to keep new engine hierarchy (thanks to eklmn ;-))
@
text
@d64 1
d67 1
a67 1
			if (m_iRedrawCount > 0 && --m_iRedrawCount == 0)
d72 1
a72 1
			if (m_iRedrawCount++ == 0)
d75 1
d207 2
a208 1
	int m_iRedrawCount;
@


1.14
log
@Small fixes
@
text
@a134 1
	virtual BOOL PreTranslateMessage(MSG* pMsg);
@


1.13
log
@added auto-complete for search text (search history) from official v0.30c
@
text
@d119 1
a119 29

//	Places a sort arrow in a column
	void SetSortArrow(int iColumn, bool bAscending, int iColumnIndex = 0)
	{
		ArrowType		arrowType;

		if (bAscending)
		{
			switch (iColumnIndex)
			{
				case 0: arrowType = arrowUp; break;
				case 1: arrowType = arrowUp1; break;
				case 2: arrowType = arrowUp2; break;
				case 3: arrowType = arrowUp3; break;
				default: arrowType = arrowUp;
			}
		}
		else
		{
			switch (iColumnIndex)
			{
				case 1: arrowType = arrowDown1; break;
				case 2: arrowType = arrowDown2; break;
				case 3: arrowType = arrowDown3; break;
				default: arrowType = arrowDown;
			}
		}
		SetSortArrow(iColumn, arrowType);
	}
@


1.12
log
@Formatting, comments, and name changes.
@
text
@a10 33
class CMuleListCtrl;

class CDlgListSearchListSearch : public CDialog
{
	DECLARE_DYNAMIC(CDlgListSearchListSearch)

public:
	CDlgListSearchListSearch(CWnd* pParent = NULL);   // standard constructor

//	Dialog Data
	enum
	{
		IDD = IDD_LISTVIEW_SEARCH
	      };

	CMuleListCtrl* m_pListView;
	CString m_strFindText;
	int m_iSearchColumn;

protected:
	CComboBox m_ctlSearchCol;

	void UpdateControls();

	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	DECLARE_MESSAGE_MAP()

public:
	afx_msg void OnEnChangeSearchText();
	virtual BOOL OnInitDialog();
};

@


1.11
log
@*** empty log message ***
@
text
@d196 1
a196 1
	virtual BOOL PreTranslateMessage(MSG* pMsg);	// DropF - Keyboard Shortcuts
@


1.10
log
@Formatting, comments, and name changes.
@
text
@d196 1
a196 1
	virtual BOOL PreTranslateMessage(MSG* pMsg);
@


1.9
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d162 1
d222 6
a227 6
	COLORREF m_crWindow;
	COLORREF m_crWindowText;
	COLORREF m_crHighlight;
	COLORREF m_crFocusLine;
	COLORREF m_crNoHighlight;
	COLORREF m_crNoFocusLine;
d229 2
a230 2
	bool m_bCustomDraw;
	CImageList	m_imlHeaderCtrl;
@


1.8
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d5 6
d145 4
a148 2
		                                arrowDoubleDown = IDB_DOWN2X, arrowDoubleUp = IDB_UP2X
	                                                  };
d154 1
a154 1
	void SetSortArrow(int iColumn, bool bAscending)
d156 23
a178 1
		SetSortArrow(iColumn, bAscending ? arrowUp : arrowDown);
d263 2
a264 2
	int m_iCurrentSortItem;
	ArrowType m_atSortArrow;
@


1.7
log
@Formatting, comments, and name changes.
Added OnNMDividerDoubleClick().
@
text
@d14 5
a18 2
// Dialog Data
	enum { IDD = IDD_LISTVIEW_SEARCH };
d39 1
a39 1
// CMuleListCtrl
d49 1
a49 1
	// Default sort proc, this does nothing
d52 1
a52 1
	// Sets the list name, used for hide/show menu
d55 1
a55 1
	// Save to preferences
d58 1
a58 1
	// Load from preferences
d61 1
a61 1
	// Hide the column
d64 1
a64 1
	// Unhide the column
d67 4
a70 3
	// Check to see if the column is hidden
	BOOL IsColumnHidden(int iColumn) const {
		if(iColumn < 1 || iColumn >= m_iColumnsTracked)
d76 4
a79 3
	// Get the correct column width even if column is hidden
	int GetColumnWidth(int iColumn) const {
		if(iColumn < 0 || iColumn >= m_iColumnsTracked)
d81 2
a82 2
		
		if(m_aColumns[iColumn].bHidden)
d88 6
a93 4
	// Call SetRedraw to allow changes to be redrawn or to prevent changes from being redrawn.
	void SetRedraw(BOOL bRedraw = TRUE) {
		if(bRedraw) {
			if(m_iRedrawCount > 0 && --m_iRedrawCount == 0)
d95 4
a98 2
		} else {
			if(m_iRedrawCount++ == 0)
d103 3
a105 2
	// Sorts the list
	BOOL SortItems(PFNLVCOMPARE pfnCompare, DWORD_PTR dwData) {
d109 5
a113 2
	// Sorts the list
	BOOL SortItems(DWORD dwData) { return CListCtrl::SortItems(m_SortProc, dwData); }
d115 5
a119 2
	// Sets the sorting procedure
	void SetSortProcedure(PFNLVCOMPARE funcSortProcedure) { m_SortProc = funcSortProcedure; }
d121 5
a125 2
	// Gets the sorting procedure
	PFNLVCOMPARE GetSortProcedure() { return m_SortProc; }
d127 1
a127 1
	// Retrieves the data (lParam) associated with a particular item.
d130 5
a134 2
	// Retrieves the number of items in the control.
	int GetItemCount() const { return m_Params.GetCount(); };
d136 5
a140 2
	enum ArrowType { arrowDown = IDB_DOWN, arrowUp = IDB_UP,
		arrowDoubleDown = IDB_DOWN2X, arrowDoubleUp = IDB_UP2X };
d142 1
a142 1
	// Places a sort arrow in a column
d145 3
a147 2
	// Places a sort arrow in a column
	void SetSortArrow(int iColumn, bool bAscending) {
d153 5
a157 2
	// General purpose listview find dialog+functions (optional)
	void SetGeneralPurposeFind(bool bEnable) { m_bGeneralPurposeFind = bEnable; }
d177 8
a184 7
	// Checks the item to see if it is in order
	int          UpdateLocation(int iItem);
	// Moves the item in list and returns the new index
	int          MoveItem(int iOldIndex, int iNewIndex);
	// Update the colors
	void         SetColors();
	DWORD        SetExtendedStyle(DWORD dwNewStyle) {
d188 12
a199 12
	CString          m_Name;
	PFNLVCOMPARE     m_SortProc;
	DWORD            m_dwParamSort;
	COLORREF         m_crWindow;
	COLORREF         m_crWindowText;
	COLORREF         m_crHighlight;
	COLORREF         m_crFocusLine;
	COLORREF         m_crNoHighlight;
	COLORREF         m_crNoFocusLine;
	NMLVCUSTOMDRAW   m_lvcd;
	bool             m_bCustomDraw;
	CImageList		 m_imlHeaderCtrl;
d201 1
a201 1
	// General purpose listview find dialog+functions (optional)
d214 2
a215 1
	struct MULE_COLUMN {
d221 1
a221 1
	int          m_iColumnsTracked;
d224 2
a225 1
	int GetHiddenColumnCount() const {
d227 2
a228 2
		for(int i = 0; i < m_iColumnsTracked; i++)
			if(m_aColumns[i].bHidden)
d233 1
a233 1
	int       m_iCurrentSortItem;
d239 2
a240 1
	DWORD_PTR GetParamAt(POSITION pos, int iPos) {
d242 1
a242 1
		if(lParam == 0xFEEBDEEF) //same as MLC_MAGIC!
@


1.6
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d4 31
d137 3
@


1.5
log
@Fix for lists navigation [from official]
@
text
@d22 1
a22 1
	void SaveSettings(CPreferences::Table tID);
d25 1
a25 1
	void LoadSettings(CPreferences::Table tID);
@


1.4
log
@*** empty log message ***
@
text
@a100 18

	//--- xrmb:parttraffic ---
	// get real column column
	int GetColumnColumn(int iColumn) const {
		if(iColumn < 0 || iColumn >= m_iColumnsTracked)
			return -1;
		
		for(int i=0; i<m_iColumnsTracked; i++)
			if(iColumn==m_aColumns[i].iLocation)
				return i;
		
		//--- not found ---
		return -1;
	}

	int	ColumnsTracked() { return m_iColumnsTracked; }
	//--- :xrmb ---

d105 1
@


1.3
log
@minor fixes and improvements
@
text
@d93 1
d96 6
d125 1
a125 1
	virtual afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
d153 10
@


1.2
log
@*** empty log message ***
@
text
@d93 1
d116 1
d145 1
@


1.1
log
@*** empty log message ***
@
text
@d116 1
a116 1
	afx_msg void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
@


1.1.4.1
log
@updating this branch...
@
text
@@

