head	1.56;
access;
symbols
	PublicRelease_1_2e:1.55
	Interim_Release_1-2e_RC1:1.55
	PublicRelease_1_2d:1.54
	Interim_Release_1-2d_RC1:1.54
	Interim_Release_1-2d_beta1:1.54
	PublicRelease_1_2c:1.52
	Interim_Release_1-2c_RC1:1.52
	Interim_Release_1-2c_beta1:1.52
	PublicRelease_1_2b:1.51
	Interim_Release_1-2b_RC1:1.51
	PublicRelease_1_2a:1.51
	Interim_Release_1-2a_RC1:1.51
	Interim_Release_1-2a_beta2:1.51
	Interim_Release_1-2a_beta1:1.51
	PublicRelease_1_2:1.51
	Interim_Release_1-2_RC1:1.51
	Interim_Release_1-2_beta1:1.51
	PublicRelease_1_1g:1.51
	Interim_Release_1-1g_RC3:1.51
	Interim_Release_1-1g_RC2:1.51
	Interim_Release_1-1g_RC1:1.51
	Interim_Release_1-1g_beta2:1.51
	Interim_Release_1-1g_beta1:1.49
	PublicRelease_1_1f:1.49
	Interim_Release_1-1f_RC1:1.49
	PublicRelease_1_1e:1.49
	Interim_Release_1-1e_RC2:1.49
	Interim_Release_1-1e_RC1:1.49
	Interim_Release_1-1e_beta1:1.48
	PublicRelease_1_1d:1.48
	Interim_Release_1-1d_RC1:1.48
	PublicRelease_1_1c:1.48
	Interim_Release_1-1c_RC1:1.47
	Interim_Release_1-1c_beta2:1.47
	Interim_Release_1-1c_beta1:1.46
	PublicRelease_1_1b:1.45
	Interim_Release_1-1b_RC1:1.45
	PublicRelease_1_1a:1.43
	Interim_Release_1-1a_RC2:1.43
	Interim_Release_1-1a_RC1:1.43
	Interim_Release_1-1a_beta2:1.41
	Interim_Release_1-1a_beta1:1.41
	PublicRelease_1_1:1.40
	Interim_Release_1-1_beta1:1.40
	PublicRelease_1o:1.40
	Interim_Release_1o_RC1:1.40
	Interim_Release_1o_beta1:1.39
	PublicRelease_1n:1.39
	Interim_Release_1n_RC2:1.39
	Interim_Release_1n_RC1:1.39
	Interim_Release_1n_beta2:1.35
	Interim_Release_1n_beta1:1.33
	PublicRelease_1m:1.32
	Interim_Release_1m_beta1:1.32
	PublicRelease_1l:1.32
	Interim_Release_1l_RC3:1.32
	Interim_Release_1l_RC2:1.32
	Interim_Release_1l_RC1:1.32
	Interim_Release_1l_beta2:1.32
	Interim_Release_1l_beta1:1.32
	PublicRelease_1k:1.31
	Interim_Release_1k_RC4:1.31
	Interim_1k_RC3:1.31
	Interim_1k_RC2:1.31
	Interim_Release_1k_RC1:1.31
	Interim_Release_1k_beta5:1.30
	Intrerim_Release_1k_beta4:1.30
	Interim_Release_1k_beta1:1.29
	PublicRelease_1j:1.27
	Interim_Release_1J_RC3:1.27
	Interim_Release_1j_RC3:1.27
	Interim_Release_1j_RC2:1.27
	Interim_Release_1j_RC1:1.27
	Interim_Release_1j_beta2:1.27
	Interim_Release_1j_beta1:1.27
	PublicRelease_1i:1.27
	Interim_Release_1i_RC6:1.27
	Interim_Release_1i_RC3:1.27
	Interim_Release_1i_RC2:1.27
	Interim_Release_1i_RC1:1.27
	Interim_Release_1i_beta3:1.27
	Interim_Release_1i_beta2:1.27
	Interim_Release_1i_beta1:1.26
	PublicRelease_1h:1.22
	Interim_Release_1h_rc2:1.22
	Interim_Release_1h_RC1:1.22
	Interim_Release_1h_beta2:1.22
	Interim_Release_1h_beta1_now:1.22
	Interim_Release_1h_beta1:1.22
	PublicRelease_1g:1.21
	Interim_Release_1g_RC6_Final:1.21
	Interim_Release_1g_RC6:1.21
	Interim_Release_1g_RC5:1.20
	Interim_Release_1g_RC4:1.20
	Interim_Release_1g_RC3:1.20
	Interim_Release_1g_beta2:1.18
	Interim_Release_1g_beta1:1.18
	Interim_Release_1f_RC4:1.17
	Interim_Release_1f_RC3:1.17
	Interim_Release_1f_RC2:1.16
	Interim_Release_1f_RC:1.16
	Interim_Release_1f_beta2:1.16
	Interim_Release_1f_beta1:1.16
	PublicRelease_1e:1.16
	Interim_Release_1e_RC2:1.16
	Interim_Release_1e_RC:1.16
	Interim_Release_1e_beta3:1.16
	Interim_Release_1e_beta2:1.16
	Interim_Release_1e_beta2_before_kuchin:1.16
	Interim_Release_1e_beta1:1.16
	PublicRelease_1c:1.15
	featurestest:1.15.0.2
	Interim_Release_1c_RC:1.15
	Interim_Release_1c_beta2:1.14
	Interim_Release_1c_beta1:1.13
	threaded_downloadqueue:1.13.0.2
	PublicRelease_1b:1.12
	Interim_Release_1b_beta2:1.12
	Interim_Release_1b_beta1:1.12
	proxydeadlake:1.10.0.4
	PublicRelease_1a:1.10
	Interim_Release_1a_beta2:1.10
	BerkeleyDb:1.10.0.2
	Interim_Release_1a_beta1:1.10
	PublicRelease_1:1.7
	goldfish:1.7
	eMulePlus_1_RC2:1.7
	eMulePlus_26b_1RC1:1.7
	PreRelease_26b_i0e:1.7
	before_26d_merge:1.7
	Interim_Release_26b_i0d:1.6
	Interim_Release_26b_i0c:1.5
	Interim_Release_26b_i0b:1.5
	Interim_Release_26b_i0a:1.5
	systraydlg:1.4.0.6
	plus26based:1.4.0.4
	Interim_Release_25b_i0b:1.4
	Proxy_Dev:1.4
	Interim_Release_25b_i0a:1.4.2.1
	proxytest:1.4.2.1.0.2
	official_sockets:1.4.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.56
date	2009.07.15.02.23.05;	author aw3;	state Exp;
branches;
next	1.55;

1.55
date	2008.10.28.02.45.47;	author aw3;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.31.18.18.58;	author fuxie-dk;	state Exp;
branches;
next	1.53;

1.53
date	2007.10.24.19.06.29;	author fuxie-dk;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.17.05.38.44;	author aw3;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.04.06.47.32;	author aw3;	state Exp;
branches;
next	1.50;

1.50
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.17.15.20.09;	author eklmn;	state Exp;
branches;
next	1.48;

1.48
date	2005.02.26.22.44.00;	author aw3;	state Exp;
branches;
next	1.47;

1.47
date	2005.02.14.17.37.48;	author aw3;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.27.22.37.17;	author eklmn;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.19.22.12.04;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.19.13.43.28;	author eklmn;	state Exp;
branches;
next	1.43;

1.43
date	2004.11.26.18.59.51;	author aw3;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.26.06.40.15;	author eklmn;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.05.18.43.39;	author eklmn;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.25.07.25.28;	author aw3;	state Exp;
branches;
next	1.39;

1.39
date	2004.08.21.11.42.56;	author eklmn;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.15.21.06.03;	author eklmn;	state Exp;
branches;
next	1.37;

1.37
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.36;

1.36
date	2004.08.10.19.25.47;	author eklmn;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.07.08.52.07;	author eklmn;	state Exp;
branches;
next	1.34;

1.34
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.18.18.31.31;	author eklmn;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.03.10.57.14;	author netwolf1;	state Exp;
branches;
next	1.31;

1.31
date	2004.03.27.19.39.45;	author dongato;	state Exp;
branches;
next	1.30;

1.30
date	2004.03.17.02.46.48;	author kush_eplus;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.19.14.04.00;	author aw3;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.09.23.10.54;	author netwolf1;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.23.19.08.54;	author uid124029;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.29.14.55.47;	author morevit;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.24;

1.24
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.19.00.13.38;	author morevit;	state Exp;
branches;
next	1.22;

1.22
date	2003.08.16.17.57.38;	author eklmn;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.18.14.51.29;	author eklmn;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.21.20.52.54;	author eklmn;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.09.20.05.55;	author partyckip;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.30.21.27.00;	author partyckip;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.20.20.46.33;	author netwolf1;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.25.12.39.38;	author cax2;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.21.18.55.17;	author dongato;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2003.03.20.18.09.36;	author cax2;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.14.16.20.28;	author partyckip;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.03.22.09.52;	author moosetea;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.03.03.23.51;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.23.12.35.46;	author obaldin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.21.12.47.37;	author lord_kiron;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.15.15.36.24;	author lord_kiron;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.12.20.18.24;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.24.22.07.52;	author maverick65;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2003.01.23.17.00.45;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches;
next	;

1.4.2.1
date	2003.01.28.16.54.37;	author cax2;	state Exp;
branches;
next	;

1.4.4.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.15.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Encryption preparations.
@
text
@//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#pragma once

#pragma warning(push)
#pragma warning(disable:4702) // unreachable code
#include <vector>
#include <list>
#pragma warning(pop)
#include "Loggable.h"

#define UL_QUEUE_DATARATE_SAMPLE_TIME 500

class CUpDownClient;

typedef std::list<CUpDownClient*> ClientList;

class CUploadQueue : public CLoggable
{
	friend class CWebServer;
public:
	CUploadQueue();
	~CUploadQueue();
	void	Process();
	void	AddClientToWaitingQueue(CUpDownClient* client,bool bIgnoreTimelimit = false);
	bool	RemoveFromUploadQueue(CUpDownClient* client, EnumEndTransferSession eReason, bool updatewindow = true);
	bool	RemoveFromWaitingQueue(CUpDownClient* client,bool updatewindow = true);
	bool	IsOnUploadQueue(CUpDownClient* client)	{return (GetWaitingClient(client) != NULL); }
	bool	IsDownloading(CUpDownClient* pClient);
	uint32	GetDataRate()							{return m_dwDataRate;}
	int		GetWaitingUserCount() const				{return waitinglist.GetCount();}
	int		GetUploadQueueLength() const			{return m_UploadingList.size();}
	CUpDownClient*	GetWaitingClientByIP_UDP(uint32 dwIP, uint16 uPort, bool *pbMultipleIPs);

	void	SCHShift1UploadCheck();
	void	SCHShift2UploadCheck();

	void	DeleteAll();
	uint16	GetWaitingPosition(CUpDownClient* client);
	void	SetBanCount(uint32 dwCount)				{ m_dwBannedCount = dwCount; }
	uint32	GetBanCount() const						{ return m_dwBannedCount; }
	// v: eklmn: extended UL statistic
	uint32	GetSuccessfulUpCount()					{return m_iULSessionSuccessful;}
	uint32	GetULFullChunkCount()					{return m_iULSessionSuccessfulFullChunk;}	// Should that be full up-chuck count?
	uint32	GetULPartChunkCount()					{uint32 part_chunk = 0;
														for (int i =0; i < ETS_TERMINATOR; i++)
															part_chunk += m_iULSessionSuccessfulPartChunk[i];
														return part_chunk;
													}
	uint32	GetULPartChunkSubCount(EnumEndTransferSession index)		{return m_iULSessionSuccessfulPartChunk[index];}
	uint32	GetFailedUpCount()						{uint32 failed = 0;
														for (int i = 0; i < ETS_TERMINATOR; i++)
															failed += m_iULSessionFailed[i];
														return failed;
													}
	uint32	GetFailedSubCount(EnumEndTransferSession index)		{return m_iULSessionFailed[index];}
	// ^: eklmn: extended UL statistic
	uint32	GetAverageUpTime();
	void	FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, const uchar* filehash);
	void	GetUploadFilePartsAvailability(uint32 *pdwStatuses, uint32 dwPartCnt, const byte *pbyteFileHash);
	void	AddUpDataOverheadSourceExchange(uint32 data)	{ m_nUpDataRateMSOverhead += data;
															  m_nUpDataOverheadSourceExchange += data;
															  m_nUpDataOverheadSourceExchangePackets++;}
	void	AddUpDataOverheadFileRequest(uint32 data)		{ m_nUpDataRateMSOverhead += data;
															  m_nUpDataOverheadFileRequest += data;
															  m_nUpDataOverheadFileRequestPackets++;}
	void	AddUpDataOverheadServer(uint32 data)			{ m_nUpDataRateMSOverhead += data;
															  m_nUpDataOverheadServer += data;
															  m_nUpDataOverheadServerPackets++;}
	void	AddUpDataOverheadOther(uint32 data)				{ m_nUpDataRateMSOverhead += data;
															  m_nUpDataOverheadOther += data;
															  m_nUpDataOverheadOtherPackets++;}
	uint32	GetUpDataRateOverhead()						{return m_nUpDataRateOverhead;}
	uint64	GetUpDataOverheadSourceExchange()			{return m_nUpDataOverheadSourceExchange;}
	uint64	GetUpDataOverheadFileRequest()				{return m_nUpDataOverheadFileRequest;}
	uint64	GetUpDataOverheadServer()					{return m_nUpDataOverheadServer;}
	uint64	GetUpDataOverheadOther()					{return m_nUpDataOverheadOther;}
	uint64	GetUpDataOverheadSourceExchangePackets()	{return m_nUpDataOverheadSourceExchangePackets;}
	uint64	GetUpDataOverheadFileRequestPackets()		{return m_nUpDataOverheadFileRequestPackets;}
	uint64	GetUpDataOverheadServerPackets()			{return m_nUpDataOverheadServerPackets;}
	uint64	GetUpDataOverheadOtherPackets()				{return m_nUpDataOverheadOtherPackets;}
	void	CompUpDataRateOverhead();
	POSITION GetHeadPosition();
	CUpDownClient* GetNext(POSITION& pos);
	void	GetCopyUploadQueueList(ClientList *pCopy);
protected:
	void	RemoveFromWaitingQueue(POSITION pos, bool updatewindow);
	POSITION	GetWaitingClient(CUpDownClient* client);
	POSITION	GetWaitingClientByID(CUpDownClient* client);
	bool		CanAcceptNewClient(uint32 dwNumOfUploads);
	void		AddClientToUploadQueue(CUpDownClient* pClient = NULL);

public:
	DWORD	m_dwLastScheduledBackupTick;
	HANDLE	m_hQuitEvent;

private:
	std::deque<uint64> m_averageDataRateList;
	std::deque<DWORD> m_averageTickList;
	std::deque<uint32> m_activeClientsDeque;
	std::vector<uint32> m_activeClientsSortedVector;
	CTypedPtrList<CPtrList, CUpDownClient*> waitinglist;
	ClientList m_UploadingList;

	uint32	m_dwDataRate;   //data rate

	UINT_PTR m_hTimer;
	uint32	m_dwBannedCount;
	uint32	m_iULSessionSuccessful;
	uint32	m_iULSessionSuccessfulFullChunk;
	uint32	m_iULSessionSuccessfulPartChunk[ETS_TERMINATOR];
	uint32	m_iULSessionFailed[ETS_TERMINATOR];
	uint32 	m_iULSessionFailedNoDataForRemoteClient;

	uint32	m_iTotalUploadTime;
	sint32	m_iLeftOverBandwidth;
	uint32	m_nUpDataRateOverhead;
	uint32	m_nUpDataRateMSOverhead;
	uint64	m_nUpDataOverheadSourceExchange;
	uint64	m_nUpDataOverheadFileRequest;
	uint64	m_nUpDataOverheadServer;
	uint64	m_nUpDataOverheadOther;
	uint64	m_nUpDataOverheadSourceExchangePackets;
	uint64	m_nUpDataOverheadFileRequestPackets;
	uint64	m_nUpDataOverheadServerPackets;
	uint64	m_nUpDataOverheadOtherPackets;
	std::deque<uint32>	m_UpDataOverheadDeque;
	uint32	m_dwSumUpDataOverheadInDeque;

	uint32	m_guessedMaxLANBandwidth; // LANCAST (moosetea) the max LAN data rate

	DWORD	m_lastGaveDataTick;
	CWinThread *m_pSaveThread;

	CString	m_strUploadLogFilePath;

	CRITICAL_SECTION		m_csUploadQueueList;
};
@


1.55
log
@Reduced H-file dependency; Define ClientList locally to avoid dependency on the base client class.
@
text
@d2 1
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
d44 4
a47 4
	uint32	GetDataRate()								{return m_dwDataRate;}
	int		GetWaitingUserCount()					{return waitinglist.GetCount();}
	int	GetUploadQueueLength()					{return m_UploadingList.size();}
	CUpDownClient*	GetWaitingClientByIPAndUDPPort(uint32 dwIP, uint16 dwPort);
d60 1
a60 1
														  for (int i =0;i<ETS_TERMINATOR;i++)
d62 2
a63 2
														  return part_chunk;
														}
d66 1
a66 1
														  for (int i =0;i<ETS_TERMINATOR;i++)
d68 2
a69 2
														  return failed;
														}
@


1.54
log
@Suppressed compiler warnings [Aw3].
@
text
@d19 5
a23 3
#include "types.h"
#include "opcodes.h"
#include "updownclient.h"
d28 4
@


1.53
log
@Reduced H-file dependency [Aw3].
@
text
@d36 1
a36 1
	bool	IsOnUploadQueue(CUpDownClient* client)	{return GetWaitingClient(client);}
@


1.52
log
@Removed limitation of the uploading by the score;
Removed unused class members;
Removed unrequired #include;
Removed unrequired preferences parameter.
@
text
@a21 1
#include "WebServer.h"
@


1.51
log
@Formatting.
@
text
@d17 1
a18 1
#pragma once
a21 1
#include "preferences.h"
d31 1
a31 1
	CUploadQueue(CPreferences* in_prefs);
a39 1
	bool	CheckForTimeOver(CUpDownClient* client);
a114 1
	sint32	m_iEstMaxDataRate; // estimated max data rate
a115 1
	CPreferences* m_pAppPrefs;
a138 1
	uint32	m_guessedMaxBandwidth;
@


1.50
log
@One more step to integrate eklmn's SSDQ.
@
text
@d28 2
a29 1
class CUploadQueue : public CLoggable{
d101 1
a101 1
	bool		CanAcceptNewClient(uint32 numberOfUploads);
d109 2
a110 2
	std::deque<uint64> m_averageDataRateList;		//Cax2 - memory optimization
	std::deque<DWORD> m_averageTickList;	//Cax2 - memory optimization
@


1.49
log
@added statistic that show the number of failed DL sessions in case that remote client has nothing to request
@
text
@d23 1
a23 1
#include "WebServer.h" // kuchin
d29 1
a29 1
	friend class CWebServer; // kuchin
a42 1
	void	UpdateBanCount();
d50 2
a51 2
	void	SetBanCount(uint32 in_count)			{m_iBannedCount = in_count;}
	uint32	GetBanCount()							{return m_iBannedCount;}
d120 1
a120 1
	uint32	m_iBannedCount;
@


1.48
log
@Fixed auto resume from stand-by {Mikelke/al37919}.
@
text
@d126 1
@


1.47
log
@Removed some suspicious stuff.
@
text
@a105 1
	HANDLE	m_hSaveSTimer;
@


1.46
log
@reworked control over number of clients in upload queue
@
text
@d72 1
a72 1
	void	AddUpDataOverheadSourceExchange(uint32 data, uint32 dummy=0)	{ m_nUpDataRateMSOverhead += data;
d75 1
a75 1
	void	AddUpDataOverheadFileRequest(uint32 data, uint32 dummy=0)		{ m_nUpDataRateMSOverhead += data;
d78 1
a78 1
	void	AddUpDataOverheadServer(uint32 data, uint32 dummy=0)			{ m_nUpDataRateMSOverhead += data;
d81 1
a81 1
	void	AddUpDataOverheadOther(uint32 data, uint32 dummy=0)				{ m_nUpDataRateMSOverhead += data;
@


1.45
log
@Changed inteface for the previous "UL queue improvement" to reduce performance loss.
@
text
@d113 1
a129 1
	uint32	m_MaxActiveClients;
@


1.44
log
@improvement for UL queue:
1) used STL
2) fixed access to the queue from WebServer
@
text
@d41 1
a41 1
	int	GetWaitingUserCount()					{return waitinglist.GetCount();}
a42 1
	int	GetActiveUploadsCount()					{return m_MaxActiveClients;}
d96 1
a96 2

	ClientList* GetCopyUploadQueueList();
@


1.43
log
@Detailed file parts information.
@
text
@d38 1
a38 2
	// eklmn: optimization: search client with extra function?! Why?!
	bool	IsDownloading(CUpDownClient* client)	{return uploadinglist.Find(client);}
d41 3
a43 3
	int		GetWaitingUserCount()					{return waitinglist.GetCount();}
	int		GetUploadQueueLength()					{return uploadinglist.GetCount();}
	int		GetActiveUploadsCount()					{return m_MaxActiveClients;}
d97 2
d116 1
a116 1
	CTypedPtrList<CPtrList, CUpDownClient*> uploadinglist;
@


1.42
log
@some code preparation
@
text
@d73 1
@


1.41
log
@1) improved ZZ upload process
2) fixed possible upload break at last block in part
@
text
@d112 1
a112 1
	CList<int,int> activeClients_list;
@


1.40
log
@Own client type for eMule Plus clients; Removed unused class variables.
@
text
@a39 1
	bool	IsFileUploading (CPartFile* check_file);		//eklmn: Complete Bug
d150 2
@


1.39
log
@optimized datarate calcualtion for UL queue, removed unneeded code
@
text
@a117 1
	uint32	m_iDataRateAvg; //datarage average (since progstart) *unused*
@


1.38
log
@minor name correction
@
text
@d26 2
d41 1
a41 2
	uint32	GetDataRateShown();		//Cax2 - more immediate data rate feedback.
	uint32	GetDataRate();
d117 1
a117 1
	uint32	m_iDataRate;   //data rate
a148 1
	DWORD	m_lastCalculatedDataRateTick;
@


1.37
log
@rollback of old waiting queue
@
text
@d32 1
a32 1
	void	AddClientToQueue(CUpDownClient* client,bool bIgnoreTimelimit = false);
@


1.36
log
@1) the agressivity check moved in ListenSocket
2) optimized client addition to the waiting queue
@
text
@a25 3
typedef list<CUpDownClient*> ClientList;
typedef deque<CUpDownClient*> ClientDeque;

d32 1
d34 2
a35 8

//	waiting queue functions
	void CheckAndAddClientToWaitingQueue(CUpDownClient* pClient);
	void UpdateClientInWaitingQueue(CUpDownClient* pClient);
	bool RemoveClientFromWaitingQueue(CUpDownClient* pClient);
	CUpDownClient* GetClientWithBestWaitingScore();
	bool	IsOnWaitingQueue(CUpDownClient* pClient)	{return (pClient->GetPosInWaitingQueue() != 0);}

d41 2
a42 2
	bool	IsULPermitedByWaitingScore(CUpDownClient* pClient);
	int		GetWaitingUserCount()					{return m_waitingList.size();}
d52 1
d72 1
d95 2
a96 4

	void GetSourcesFromWaitingQueueByFileID(ClientDeque* pSourcesDeque, const uchar* filehash);
	void GetSourcesFromUploadQueueByFileID(ClientDeque* pSourcesDeque, const uchar* filehash);

d98 3
a103 3
private:
	bool AddClientToWaitingQueue(CUpDownClient* pClient, bool bCheckDeadClients = true);

a104 1
	ClientList m_waitingList;
d113 1
a151 4

	uint32 	m_dwWaitingScore;

	CCriticalSection m_csWaitingQueue;
@


1.35
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d36 3
a38 1
	void AddClientToWaitingQueue(CUpDownClient* pClient);
d43 1
d105 7
a117 5
protected:
	//POSITION	GetDownloadingClient(CUpDownClient* client);
	bool		CanAcceptNewClient(uint32 numberOfUploads);
	void		AddClientToUploadQueue(CUpDownClient* pClient = NULL);

@


1.34
log
@SSWQ
@
text
@a75 1
	void	FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, const uchar* filehash);
@


1.33
log
@speed optimization of overhead calculation
@
text
@d26 3
a34 1
	void	AddClientToQueue(CUpDownClient* client,bool bIgnoreTimelimit = false);
d36 5
a40 3
	bool	RemoveFromWaitingQueue(CUpDownClient* client,bool updatewindow = true);
	bool	IsOnUploadQueue(CUpDownClient* client)	{return GetWaitingClient(client);}
	//bool	IsDownloading(CUpDownClient* client)	{return GetDownloadingClient(client);}
d46 2
a47 2
	bool	CheckForTimeOver(CUpDownClient* client);
	int		GetWaitingUserCount()					{return waitinglist.GetCount();}
d51 1
a51 4
	CUpDownClient*	GetWaitingClientByIP_UDP(uint32 dwIP, uint16 dwPort);

	HANDLE	m_hSaveSTimer;
	HANDLE	m_hQuitEvent;
a56 1
	uint16	GetWaitingPosition(CUpDownClient* client);
d99 6
a104 2
	POSITION GetHeadPosition();
	CUpDownClient* GetNext(POSITION& pos);
d106 3
a109 3
	void	RemoveFromWaitingQueue(POSITION pos, bool updatewindow);
	POSITION	GetWaitingClient(CUpDownClient* client);
	POSITION	GetWaitingClientByID(CUpDownClient* client);
d112 2
a113 1
	void		AddUpNextClient(CUpDownClient* directadd = NULL);
a117 1
	CTypedPtrList<CPtrList, CUpDownClient*> waitinglist;
d156 4
@


1.32
log
@added Scheduled Backup feature
@
text
@d110 2
a111 2
	std::list<uint64> m_averageDataRateList;		//Cax2 - memory optimization
	std::list<DWORD> m_averageTickList;	//Cax2 - memory optimization
d141 2
a142 1
	CList<int,int>	m_AvarageUDRO_list;
@


1.31
log
@Updated preferences dialogs.
Added upload log file (should be tested).
@
text
@d101 1
@


1.30
log
@list processing optimization, reduce cpu load when updating or sorting the Waiting Queue
@
text
@d148 2
@


1.29
log
@Improved and corrected implementation of saving thread
@
text
@a47 1
	CUpDownClient*	GetNextClient(CUpDownClient* update);
d54 1
a54 1
	
d62 2
a63 2
	uint32	GetULPartChunkCount()					{uint32 part_chunk = 0; 
														  for (int i =0;i<ETS_TERMINATOR;i++) 
d68 1
a68 1
	uint32	GetFailedUpCount()						{uint32 failed = 0; 
d99 2
d115 1
a115 1
	uint32	m_iDataRate;   //data rate 
d117 1
a117 1
	sint32	m_iEstMaxDataRate; // estimated max data rate	
d124 1
a124 1
	uint32	m_iULSessionSuccessfulPartChunk[ETS_TERMINATOR];	
@


1.28
log
@BUGFIX: decision whether to compress packets was case sensitive + added some more file extension + some other changes
@
text
@d39 1
a39 1
	bool IsFileUploading (CPartFile* check_file);		//eklmn: Complete Bug
d42 1
a42 1
	bool    CheckForTimeOver(CUpDownClient* client);
d50 2
a51 2
	HANDLE m_hSaveSTimer;
	BOOL m_bExiting;
d127 2
a128 2
    sint32  m_iLeftOverBandwidth;
    uint32  m_MaxActiveClients;
d141 2
a142 2
    uint32  m_guessedMaxBandwidth;
	uint32  m_guessedMaxLANBandwidth; // LANCAST (moosetea) the max LAN data rate
d144 2
a145 2
    DWORD   m_lastGaveDataTick;
    DWORD   m_lastCalculatedDataRateTick;
@


1.27
log
@1) "fixed" bug 0000295
2) some otimization in upload
3) don't upload the file if it has a status COMPLETING
@
text
@a117 1
//	DWORD	lasttimechecked; // last time that we checked to remove a client from upload queue
a145 2
//	uint32	sumavgdata; // enkeyDEV(Ottavio84) -Accurate speed measurement-
//	uint32	sendtimestamp;	// enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
@


1.26
log
@Formatting, comments, and name changes.
@
text
@d106 1
a106 1
	void		AddUpNextClient(CUpDownClient* directadd = 0);
@


1.25
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d108 2
a109 2
	std::list<uint64> average_dr_list;		//Cax2 - memory optimization
	std::list<DWORD> average_tick_list;	//Cax2 - memory optimization
@


1.24
log
@Second batch of name changes
@
text
@d33 1
a33 1
	bool	RemoveFromUploadQueue(CUpDownClient* client, eEndTransferSession eReason, bool updatewindow = true);
d68 1
a68 1
	uint32	GetULPartChunkSubCount(eEndTransferSession index)		{return m_iULSessionSuccessfulPartChunk[index];}
d74 1
a74 1
	uint32	GetFailedSubCount(eEndTransferSession index)		{return m_iULSessionFailed[index];}
@


1.23
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d40 1
a40 1
	uint32	GetDataRateShown();		//Cax2 - more immediate dataRate feedback.
d49 1
d58 2
a59 2
	void	SetBanCount(uint32 in_count)			{bannedcount = in_count;}
	uint32	GetBanCount()							{return bannedcount;}
d61 2
a62 2
	uint32	GetSuccessfulUpCount()					{return ULSession_Successful;}
	uint32	GetULFullChunkCount()					{return ULSession_Successful_FullChunk;}
d65 1
a65 1
															part_chunk += ULSession_Successful_PartChunk[i];
d68 1
a68 1
	uint32	GetULPartChunkSubCount(eEndTransferSession index)		{return ULSession_Successful_PartChunk[index];}
d71 1
a71 1
															failed += ULSession_Failed[i];
d74 1
a74 1
	uint32	GetFailedSubCount(eEndTransferSession index)		{return ULSession_Failed[index];}
d105 1
a105 1
	bool		AcceptNewClient(uint32 numberOfUploads);
d113 4
a116 3
	uint32	dataRate;   //dataRate 
	uint32	dataRateave; //datarage average (since progstart) *unused*
	sint32	estadataRate; // esta. max dataRate	
d119 7
a125 7
	CPreferences* app_prefs;
	UINT_PTR h_timer;
	uint32	bannedcount;
	uint32	ULSession_Successful;
	uint32	ULSession_Successful_FullChunk;
	uint32	ULSession_Successful_PartChunk[ETS_TERMINATOR];	
	uint32	ULSession_Failed[ETS_TERMINATOR];
d127 2
a128 2
	uint32	totaluploadtime;
    sint32  leftoverBandwidth;
d143 1
a143 1
	uint32  m_guessedMaxLANBandwidth; // LANCAST (moosetea) the max LAN dataRate
@


1.22
log
@extended Upload Session statistic
@
text
@d40 2
a41 2
	uint32	GetDatarateShown();		//Cax2 - more immediate datarate feedback.
	uint32	GetDatarate();
d60 2
a61 2
	uint32	GetSuccessfullUpCount()					{return ULSession_Successfull;}
	uint32	GetULFullChunkCount()					{return ULSession_Successfull_FullChunk;}
d64 1
a64 1
															part_chunk += ULSession_Successfull_PartChunk[i];
d67 1
a67 1
	uint32	GetULPartChunkSubCount(eEndTransferSession index)		{return ULSession_Successfull_PartChunk[index];}
d89 1
a89 1
	uint32	GetUpDatarateOverhead()						{return m_nUpDatarateOverhead;}
d98 1
a98 1
	void	CompUpDatarateOverhead();
d112 3
a114 3
	uint32	datarate;   //datarate 
	uint32	datarateave; //datarage average (since progstart) *unused*
	sint32	estadatarate; // esta. max datarate	
d120 3
a122 3
	uint32	ULSession_Successfull;
	uint32	ULSession_Successfull_FullChunk;
	uint32	ULSession_Successfull_PartChunk[ETS_TERMINATOR];	
d128 1
a128 1
	uint32	m_nUpDatarateOverhead;
d141 1
a141 1
	uint32  m_guessedMaxLANBandwidth; // LANCAST (moosetea) the max LAN datarate
@


1.21
log
@completing bug (eMule cann't complete a file, if file is uploaded)
@
text
@d33 1
a33 1
	bool	RemoveFromUploadQueue(CUpDownClient* client,bool updatewindow = true, bool performFailedCheck = true);
d59 16
a74 2
	uint32	GetSuccessfullUpCount()					{return successfullupcount;}
	uint32	GetFailedUpCount()						{return failedupcount;}
d120 5
a124 2
	uint32	successfullupcount;
	uint32	failedupcount;
@


1.20
log
@speed optimization (GetDownloadingClient(client) is obsolet)
@
text
@d39 1
@


1.19
log
@code cleanup (removed namespaces header pollution)
@
text
@d36 3
a38 1
	bool	IsDownloading(CUpDownClient* client)	{return GetDownloadingClient(client);}
d41 1
a41 1
    bool    CheckForTimeOver(CUpDownClient* client);
d88 1
a88 1
	POSITION	GetDownloadingClient(CUpDownClient* client);
@


1.18
log
@code cleanup
@
text
@d90 2
a91 2
	list<uint64> average_dr_list;		//Cax2 - memory optimization
	list<DWORD> average_tick_list;	//Cax2 - memory optimization
@


1.17
log
@minor fixes and improvements
@
text
@d59 1
a59 1
	void	FindSourcesForFileById(CTypedPtrList<CPtrList, CUpDownClient*>* srclist, uchar* filehash);
@


1.16
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d44 1
a44 1
	CUpDownClient*	GetWaitingClientByIP(uint32 dwIP);
@


1.15
log
@Updated Night Shift to Scheduller (needs more testing and a new icon from DrSiRiUs... coming!)
@
text
@d90 2
a91 2
	CList<uint64,uint64> average_dr_list;	//Cax2 - I feel better now! :)
	CList<DWORD,DWORD> average_tick_list;
@


1.15.2.1
log
@27a partial merge
@
text
@d35 2
a36 2
	bool	IsOnUploadQueue(CUpDownClient* client)	const {return waitinglist.Find(client);}
	bool	IsDownloading(CUpDownClient* client)	const {return uploadinglist.Find(client);}
d84 3
a86 3
	//POSITION	GetWaitingClient(CUpDownClient* client);
	//POSITION	GetWaitingClientByID(CUpDownClient* client);
	//POSITION	GetDownloadingClient(CUpDownClient* client);
@


1.15.2.2
log
@27c
@
text
@a42 9
	
	POSITION GetFirstFromUploadList()				{return uploadinglist.GetHeadPosition();}
	CUpDownClient* GetNextFromUploadList(POSITION &curpos)	{return uploadinglist.GetNext(curpos);}
	CUpDownClient* GetQueueClientAt(POSITION &curpos)	{return uploadinglist.GetAt(curpos);}

	POSITION GetFirstFromWaitingList()				{return waitinglist.GetHeadPosition();}
	CUpDownClient* GetNextFromWaitingList(POSITION &curpos)	{return waitinglist.GetNext(curpos);}
	CUpDownClient* GetWaitClientAt(POSITION &curpos)	{return waitinglist.GetAt(curpos);}

d44 1
a44 1
	CUpDownClient*	GetWaitingClientByIP_UDP(uint32 dwIP, uint16 dwPort);
@


1.14
log
@bugfix: less resource usage, fixed bug #131
@
text
@d49 2
a50 2
	void	NSNightUploadCheck();
	void	NSDayUploadCheck();
@


1.13
log
@converted to new logging method
@
text
@d37 2
a38 12
	uint32	GetDatarate() {
        // Calculate average datarate
        if(::GetTickCount()-m_lastCalculatedDataRateTick > 1000) {
            if(avarage_dr_list.GetSize() >= 2) {
	            datarate = (uint32)(((float)(avarage_dr_list.GetTail()-avarage_dr_list.GetHead()))*1000 / (avarage_tick_list.GetTail()-avarage_tick_list.GetHead()));
            } else {
                datarate = 0;
            }
        }

        return datarate;
    }
d90 2
a91 2
	CList<uint64,uint64> avarage_dr_list;
	CList<DWORD,DWORD> avarage_tick_list;
@


1.12
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d24 1
d26 1
a26 1
class CUploadQueue{
@


1.11
log
@Night Shift (in cooperation with obaldin :P)
@
text
@d130 2
@


1.10
log
@better handling of friends
@
text
@d58 2
@


1.9
log
@the famous zz upload system! :)
@
text
@d48 1
@


1.8
log
@*** empty log message ***
@
text
@d32 1
a32 1
	bool	RemoveFromUploadQueue(CUpDownClient* client,bool updatewindow = true);
d36 12
a47 2
	uint32	GetDatarate()							{return datarate;}
	bool	CheckForTimeOver(CUpDownClient* client);
d50 1
d93 1
a93 1
	bool		AcceptNewClient();
d96 3
a98 1
	CList<TransferredData,TransferredData> avarage_dr_list; // enkeyDEV(Ottavio84) -Accurate speed measurement-
a101 1
	uint32	dataratems;	// datarate last 100ms
d105 1
a105 4
	bool	bDataRateMaxed; // Added by Tarod [LoneStar]
	uint32	uLastUploadStart; // Added by Tarod [LoneStar]

	DWORD	lasttimechecked; // last time that we checked to remove a client from upload queue
d112 2
d126 5
a130 2
	uint32	sumavgdata; // enkeyDEV(Ottavio84) -Accurate speed measurement-
	uint32	sendtimestamp;	// enkeyDEV(Ottavio84) -Upload rate is made independent from the inaccurate WM_TIMER-
@


1.7
log
@*** empty log message ***
@
text
@d43 2
a116 1
	HANDLE m_hSaveSTimer;
@


1.6
log
@more 26b merges
@
text
@d115 2
@


1.5
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d53 21
a73 13
	void	AddUpDataOverheadSourceExchange(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																			  m_nUpDataOverheadSourceExchange += (data+header);}
	void	AddUpDataOverheadFileRequest(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																		  m_nUpDataOverheadFileRequest += (data+header);}
	void	AddUpDataOverheadServer(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																	  m_nUpDataOverheadServer += (data+header);}
	void	AddUpDataOverheadOther(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																	  m_nUpDataOverheadOther += (data+header);}
	uint32	GetUpDatarateOverhead()			{return m_nUpDatarateOverhead;}
	uint64	GetUpDataOverheadSourceExchange()	{return m_nUpDataOverheadSourceExchange;}
	uint64	GetUpDataOverheadFileRequest()	{return m_nUpDataOverheadFileRequest;}
	uint64	GetUpDataOverheadServer()		{return m_nUpDataOverheadServer;}
	uint64	GetUpDataOverheadOther()			{return m_nUpDataOverheadOther;}
d101 2
a102 2
	uint32		m_nUpDatarateOverhead;
	uint32		m_nUpDataRateMSOverhead;
d107 5
a111 1
	CList<int,int>									 m_AvarageUDRO_list;
@


1.4
log
@updated to .25b codebase
@
text
@d53 14
a66 3
	void	AddUpDataRateMSOverhead(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead = m_nUpDataRateMSOverhead+data+header;}
	uint32	GetDatarateOverhead()		{return m_nUpDatarateOverhead;}
	void	CompDatarateOverhead();
d95 4
@


1.4.4.1
log
@initial upgrade to .26
@
text
@d53 3
a55 14
	void	AddUpDataOverheadSourceExchange(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																			  m_nUpDataOverheadSourceExchange += (data+header);}
	void	AddUpDataOverheadFileRequest(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																		  m_nUpDataOverheadFileRequest += (data+header);}
	void	AddUpDataOverheadServer(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																	  m_nUpDataOverheadServer += (data+header);}
	void	AddUpDataOverheadOther(uint32 data, uint32 header)	{ m_nUpDataRateMSOverhead += (data+header);
																	  m_nUpDataOverheadOther += (data+header);}
	uint32	GetUpDatarateOverhead()			{return m_nUpDatarateOverhead;}
	uint64	GetUpDataOverheadSourceExchange()	{return m_nUpDataOverheadSourceExchange;}
	uint64	GetUpDataOverheadFileRequest()	{return m_nUpDataOverheadFileRequest;}
	uint64	GetUpDataOverheadServer()		{return m_nUpDataOverheadServer;}
	uint64	GetUpDataOverheadOther()			{return m_nUpDataOverheadOther;}
	void	CompUpDatarateOverhead();
d59 1
a59 1
//	POSITION	GetWaitingClientByID(CUpDownClient* client);
d82 2
a83 6
	uint32	m_nUpDatarateOverhead;
	uint32	m_nUpDataRateMSOverhead;
	uint64	m_nUpDataOverheadSourceExchange;
	uint64	m_nUpDataOverheadFileRequest;
	uint64	m_nUpDataOverheadServer;
	uint64	m_nUpDataOverheadOther;
@


1.4.2.1
log
@updating this branch...
@
text
@@


1.3
log
@final port to .25b!
@
text
@d38 2
a39 2
	int		GetWaitingUserCount() {return waitinglist.GetCount();}
	int		GetUploadQueueLength() {return uploadinglist.GetCount();}
@


1.2
log
@port to .25 b codebase...
@
text
@d84 1
a84 1
	CList<TransferredData,TransferredData>									 m_AvarageUDRO_list;
@


1.1
log
@*** empty log message ***
@
text
@d53 3
a55 1

d82 4
@

