head	1.56;
access;
symbols
	PublicRelease_1_2e:1.56
	Interim_Release_1-2e_RC1:1.56
	PublicRelease_1_2d:1.55
	Interim_Release_1-2d_RC1:1.55
	Interim_Release_1-2d_beta1:1.51
	PublicRelease_1_2c:1.48
	Interim_Release_1-2c_RC1:1.48
	Interim_Release_1-2c_beta1:1.48
	PublicRelease_1_2b:1.48
	Interim_Release_1-2b_RC1:1.48
	PublicRelease_1_2a:1.46
	Interim_Release_1-2a_RC1:1.46
	Interim_Release_1-2a_beta2:1.46
	Interim_Release_1-2a_beta1:1.46
	PublicRelease_1_2:1.46
	Interim_Release_1-2_RC1:1.46
	Interim_Release_1-2_beta1:1.46
	PublicRelease_1_1g:1.45
	Interim_Release_1-1g_RC3:1.45
	Interim_Release_1-1g_RC2:1.45
	Interim_Release_1-1g_RC1:1.45
	Interim_Release_1-1g_beta2:1.44
	Interim_Release_1-1g_beta1:1.43
	Interim_Release_1-1f_RC1:1.43
	PublicRelease_1_1e:1.43
	Interim_Release_1-1e_RC2:1.43
	Interim_Release_1-1e_RC1:1.43
	Interim_Release_1-1e_beta1:1.43
	PublicRelease_1_1d:1.42
	Interim_Release_1-1d_RC1:1.42
	PublicRelease_1_1c:1.42
	Interim_Release_1-1c_RC1:1.42
	Interim_Release_1-1c_beta2:1.42
	Interim_Release_1-1c_beta1:1.41
	PublicRelease_1_1b:1.40
	Interim_Release_1-1b_RC1:1.40
	PublicRelease_1_1a:1.40
	Interim_Release_1-1a_RC2:1.40
	Interim_Release_1-1a_RC1:1.40
	Interim_Release_1-1a_beta2:1.40
	Interim_Release_1-1a_beta1:1.40
	PublicRelease_1_1:1.40
	Interim_Release_1-1_beta1:1.40
	PublicRelease_1o:1.40
	Interim_Release_1o_RC1:1.40
	Interim_Release_1o_beta1:1.40
	PublicRelease_1n:1.40
	Interim_Release_1n_RC2:1.40
	Interim_Release_1n_RC1:1.40
	PublicRelease_1m:1.40
	Interim_Release_1m_beta1:1.40
	PublicRelease_1l:1.37
	Interim_Release_1l_RC3:1.37
	Interim_Release_1l_RC2:1.36
	Interim_Release_1l_RC1:1.27
	Interim_Release_1l_beta2:1.24
	Interim_Release_1l_beta1:1.15
	PublicRelease_1k:1.14
	Interim_Release_1k_RC4:1.14
	Interim_1k_RC3:1.14
	Interim_1k_RC2:1.14
	Interim_Release_1k_RC1:1.14
	Interim_Release_1k_beta5:1.14
	Intrerim_Release_1k_beta4:1.14
	Interim_Release_1k_beta1:1.14
	PublicRelease_1j:1.13
	Interim_Release_1J_RC3:1.13
	Interim_Release_1j_RC3:1.13
	Interim_Release_1j_RC2:1.13
	Interim_Release_1j_RC1:1.13
	Interim_Release_1j_beta2:1.13
	Interim_Release_1j_beta1:1.13
	PublicRelease_1i:1.12
	Interim_Release_1i_RC6:1.12
	Interim_Release_1i_RC3:1.12
	Interim_Release_1i_RC2:1.12
	Interim_Release_1i_RC1:1.12
	Interim_Release_1i_beta3:1.12
	Interim_Release_1i_beta2:1.11
	Interim_Release_1i_beta1:1.10
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.8
	Interim_Release_1h_RC1:1.8
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.6
	Interim_Release_1h_beta1:1.6
	PublicRelease_1g:1.6
	Interim_Release_1g_RC6_Final:1.6
	Interim_Release_1g_RC6:1.6
	Interim_Release_1g_RC5:1.6
	Interim_Release_1g_RC4:1.6
	Interim_Release_1g_RC3:1.6
	Interim_Release_1g_beta2:1.5
	Interim_Release_1g_beta1:1.5
	Interim_Release_1f_RC4:1.5
	Interim_Release_1f_RC3:1.5
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2;
locks; strict;
comment	@// @;


1.56
date	2008.08.12.04.48.38;	author aw3;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.01.18.58.59;	author aw3;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.29.20.37.05;	author eklmn;	state Exp;
branches;
next	1.53;

1.53
date	2008.02.28.19.56.38;	author eklmn;	state Exp;
branches;
next	1.52;

1.52
date	2008.02.20.21.34.15;	author eklmn;	state Exp;
branches;
next	1.51;

1.51
date	2008.02.11.20.26.17;	author eklmn;	state Exp;
branches;
next	1.50;

1.50
date	2008.02.09.12.01.20;	author eklmn;	state Exp;
branches;
next	1.49;

1.49
date	2007.11.03.09.40.41;	author eklmn;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.26.11.07.33;	author eklmn;	state Exp;
branches;
next	1.47;

1.47
date	2006.12.23.07.55.57;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2005.12.29.05.36.41;	author aw3;	state Exp;
branches;
next	1.45;

1.45
date	2005.11.28.03.04.25;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2005.09.19.19.56.45;	author eklmn;	state Exp;
branches;
next	1.43;

1.43
date	2005.04.16.01.05.22;	author aw3;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.07.21.24.27;	author katsyonak;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.19.21.11.36;	author netwolf1;	state Exp;
branches;
next	1.40;

1.40
date	2004.06.16.23.03.32;	author katsyonak;	state Exp;
branches;
next	1.39;

1.39
date	2004.06.16.22.42.46;	author katsyonak;	state Exp;
branches;
next	1.38;

1.38
date	2004.06.15.23.13.58;	author katsyonak;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.08.05.00.01;	author katsyonak;	state Exp;
branches;
next	1.36;

1.36
date	2004.06.02.17.50.29;	author katsyonak;	state Exp;
branches;
next	1.35;

1.35
date	2004.06.02.17.28.54;	author katsyonak;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.02.04.27.56;	author katsyonak;	state Exp;
branches;
next	1.33;

1.33
date	2004.06.01.02.27.46;	author katsyonak;	state Exp;
branches;
next	1.32;

1.32
date	2004.05.30.20.06.25;	author katsyonak;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.30.18.56.34;	author katsyonak;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.30.15.04.22;	author katsyonak;	state Exp;
branches;
next	1.29;

1.29
date	2004.05.30.02.36.10;	author katsyonak;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.27.12.43.59;	author katsyonak;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.24.16.05.42;	author katsyonak;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.24.13.25.30;	author katsyonak;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.23.15.00.05;	author katsyonak;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.20.14.20.24;	author katsyonak;	state Exp;
branches;
next	1.23;

1.23
date	2004.05.19.20.33.01;	author katsyonak;	state Exp;
branches;
next	1.22;

1.22
date	2004.05.19.15.47.37;	author katsyonak;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.19.03.55.41;	author katsyonak;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.19.00.31.04;	author katsyonak;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.12.00.31.39;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.11.01.19.24;	author katsyonak;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.10.01.25.38;	author katsyonak;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.09.12.49.00;	author katsyonak;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.05.06.09.27;	author katsyonak;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.11.04.13.04;	author katsyonak;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.14.21.46.33;	author dropf;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.26.14.10.47;	author katsyonak;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.14.18.41.01;	author syrus77;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.01.15.11.18;	author eklmn;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.21.22.06.14;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.05.18.15.04;	author dongato;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.05.11.21.49;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.11.18.53.17;	author eklmn;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.21.22.27.00;	author netwolf1;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.18.13.29.31;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.14.15.56.19;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.12.15.29.23;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.12.13.22.16;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Better parameter passing; Don't cache array size for loops.
@
text
@/********************************************************************
	created:	2003/04/12
	created:	12:04:2003   10:50
	file base:	PPTooltip
	file ext:	cpp
	author:		Eugene Pustovoyt
	
	purpose:	
*********************************************************************/
#include "stdafx.h"
#include "multimon.h"
#include "PPToolTip.h"
#include "..\otherfunctions.h"
#include "..\emule.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
static LRESULT CALLBACK ToolTipWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hWnd, uiMsg, wParam, lParam);
}
/////////////////////////////////////////////////////////////////////////////
// CPPToolTip
CPPToolTip::CPPToolTip()
{
	m_pParentWnd = NULL;
	
	m_nStyles = NULL;

	m_rgnShadow.CreateRectRgn(0, 0, 0, 0);
	m_rgnToolTip.CreateRectRgn(0, 0, 0, 0);
	// m_rgnCombo.CreateRectRgn(0, 0, 0, 0);

	m_ptOriginal.x = -1;
	m_ptOriginal.y = -1;

	m_nIndexCurrentWnd = PPTOOLTIP_TOOL_NOEXIST;
	m_nIndexDisplayWnd = PPTOOLTIP_TOOL_NOEXIST;

	SetDelayTime(TTDT_INITIAL, 500);
	SetDelayTime(TTDT_AUTOPOP, 5000);
	SetNotify(FALSE);
	SetDirection();
	SetBehaviour();
	SetDefaultStyles();
	SetDefaultColors();
	SetDefaultSizes();
	SetEffectBk(PPTOOLTIP_EFFECT_SOLID);
	RemoveAllTools();

	// Register the window class if it has not already been registered.
	WNDCLASS		wndcls;
	HINSTANCE		hInst = AfxGetInstanceHandle();

	if(!(::GetClassInfo(hInst, PPTOOLTIP_CLASSNAME, &wndcls)))
	{
		// otherwise we need to register a new class
		wndcls.style			= CS_SAVEBITS;
		wndcls.lpfnWndProc		= ToolTipWndProc;
		wndcls.cbClsExtra		= wndcls.cbWndExtra = 0;
		wndcls.hInstance		= hInst;
		wndcls.hIcon			= NULL;
		wndcls.hCursor			= LoadCursor(hInst, IDC_ARROW );
		wndcls.hbrBackground	= NULL;
		wndcls.lpszMenuName		= NULL;
		wndcls.lpszClassName	= PPTOOLTIP_CLASSNAME;

		if (!AfxRegisterClass(&wndcls))
			AfxThrowResourceException();
	}
}

CPPToolTip::~CPPToolTip()
{
	RemoveAllTools();
	RemoveAllNamesOfResource();

	m_nLengthLines.RemoveAll();
	m_nHeightLines.RemoveAll();
	m_iAutoTabLines.RemoveAll();

	// m_rgnCombo.Detach();
	// m_rgnCombo.DeleteObject();
	m_rgnToolTip.DeleteObject();
	m_rgnShadow.DeleteObject();

	if (IsWindow(m_hWnd))
        DestroyWindow();
}


BEGIN_MESSAGE_MAP(CPPToolTip, CWnd)
	//{{AFX_MSG_MAP(CPPToolTip)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_DESTROY()
	ON_WM_KILLFOCUS()
	ON_WM_ERASEBKGND()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CPPToolTip message handlers

BOOL CPPToolTip::Create(CWnd* pParentWnd, BOOL bBalloonSize /* = TRUE */) 
{
//	TRACE(_T("CPPToolTip::Create\n"));

	ASSERT_VALID(pParentWnd);

	DWORD		dwStyle = WS_POPUP; 
	DWORD		dwExStyle = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;

	m_pParentWnd = pParentWnd;

	if (!CreateEx(dwExStyle, PPTOOLTIP_CLASSNAME, NULL, dwStyle, 0, 0, 0, 0, pParentWnd->GetSafeHwnd(), NULL, NULL))
	{
		return FALSE;
	}

	SetDefaultFont();
	SetDefaultSizes(bBalloonSize);
	
	return TRUE;
}

void CPPToolTip::OnDestroy() 
{
	KillTimers();
	
	CWnd::OnDestroy();
}

void CPPToolTip::OnKillFocus(CWnd* pNewWnd) 
{
	CWnd::OnKillFocus(pNewWnd);
	
	Pop();
}

BOOL CPPToolTip::OnEraseBkgnd(CDC *pDC)
{
	NOPRM(pDC);
	return FALSE;
}

void CPPToolTip::Pop()
{
	if (m_nIndexDisplayWnd == PPTOOLTIP_TOOL_HELPER)
		m_nIndexDisplayWnd = PPTOOLTIP_TOOL_NOEXIST;
	KillTimers();
	ShowWindow(SW_HIDE);
}

BOOL CPPToolTip::PreTranslateMessage(MSG* pMsg) 
{
	RelayEvent(pMsg);
	
	return CWnd::PreTranslateMessage(pMsg);
}

LRESULT CPPToolTip::SendNotify(CPoint * pt, PPTOOLTIP_INFO & ti) 
{ 
//	TRACE(_T("CPPToolTip::SendNotify()\n")); 
 	// Make sure this is a valid window  
	if (!IsWindow(GetSafeHwnd())) 
		return 0L; 
  
	// See if the user wants to be notified  
	if (!GetNotify()) 
		return 0L; 
  	
	NM_PPTOOLTIP_DISPLAY		lpnm; 
	PPTOOLTIP_INFO				tiCopy = ti; 

	FromHandle(ti.hWnd)->ClientToScreen(&tiCopy.rectBounds); 
	m_pParentWnd->ScreenToClient(&tiCopy.rectBounds); 
	lpnm.pt = pt;  
	lpnm.ti = &tiCopy; 
	lpnm.hdr.hwndFrom = m_hWnd; 
	lpnm.hdr.idFrom   = GetDlgCtrlID(); 
	lpnm.hdr.code     = UDM_TOOLTIP_DISPLAY; 
	 
	::SendMessage(m_hNotifyWnd, WM_NOTIFY, lpnm.hdr.idFrom, (LPARAM)&lpnm);

	CRect		rcBound = ti.rectBounds;  

	ti = tiCopy; 
	ti.rectBounds = rcBound;  
	return 0L; 
}

void CPPToolTip::OnPaint() 
{
	if (!IsEnabledIndexTool(m_nIndexCurrentWnd))
		return;

	m_nIndexDisplayWnd = m_nIndexCurrentWnd;
	m_nIndexCurrentWnd = PPTOOLTIP_TOOL_NOEXIST;

	CPaintDC dc(this); // device context for painting

	CRect			rect;

	GetClientRect(&rect);
	rect.DeflateRect(0, 0, 1, 1);

	// Create a memory device-context. This is done to help reduce
	// screen flicker, since we will paint the entire control to the
	// off screen device context first.CDC memDC;
	CDC				memDC;
	CBitmap			bitmap;

	memDC.CreateCompatibleDC(&dc);
	bitmap.CreateCompatibleBitmap(&dc, rect.Width(), rect.Height());
	
	CBitmap			*pOldBitmap = memDC.SelectObject(&bitmap); 
	
	memDC.BitBlt(0, 0, rect.Width(), rect.Height(), &dc, 0,0, SRCCOPY);

	OnDraw(&memDC, rect);

	//Copy the memory device context back into the original DC via BitBlt().
	dc.BitBlt(0, 0, rect.Width(), rect.Height(), &memDC, 0,0, SRCCOPY);
	
	//Cleanup resources.
	memDC.SelectObject(pOldBitmap);
	bitmap.DeleteObject();
	memDC.DeleteDC();
}

void CPPToolTip::OnDraw(CDC * pDC, CRect rect)
{
	CBrush			brBorder(m_crColor [PPTOOLTIP_COLOR_BORDER]);

	pDC->SetBkMode(TRANSPARENT); 

	//Sets clip region of the tooltip and draws the shadow if you need
	if (m_pToolInfo.nStyles & PPTOOLTIP_SHADOW)
	{
		//Draws the shadow for the tooltip
		OnDrawShadow(pDC);
		rect.DeflateRect(0, 0, m_nSizes[PPTTSZ_SHADOW_CX], m_nSizes[PPTTSZ_SHADOW_CY]);
	}
	pDC->SelectClipRgn(&m_rgnToolTip);

	OnDrawBackground(pDC, &rect);

	//Draws the main region's border of the tooltip
	pDC->FrameRgn(&m_rgnToolTip, &brBorder, m_nSizes[PPTTSZ_BORDER_CX], m_nSizes[PPTTSZ_BORDER_CY]);

	//Gets the rectangle to draw the tooltip text
	rect.DeflateRect(m_nSizes[PPTTSZ_MARGIN_CX], m_nSizes[PPTTSZ_MARGIN_CY]);
	if ((m_nLastDirection == PPTOOLTIP_RIGHT_BOTTOM) || (m_nLastDirection == PPTOOLTIP_LEFT_BOTTOM))
		rect.top += m_nSizes[PPTTSZ_HEIGHT_ANCHOR];
	else
		rect.bottom -= m_nSizes[PPTTSZ_HEIGHT_ANCHOR];

	// Draw the icon
	if (m_pToolInfo.hIcon != NULL)
	{
		CPoint			ptIcon;

		ptIcon.x = m_nSizes[PPTTSZ_MARGIN_CX];
		ptIcon.y = rect.top;
		if (m_pToolInfo.nStyles & PPTOOLTIP_ICON_VCENTER_ALIGN)
			ptIcon.y = rect.top + (rect.Height() - m_szToolIcon.cy) / 2;
		else if (m_pToolInfo.nStyles & PPTOOLTIP_ICON_BOTTOM_ALIGN)
			ptIcon.y = rect.bottom - m_szToolIcon.cy;
		//First variant
//		pDC->DrawIcon(m_nSizes[PPTTSZ_MARGIN_CX], rect.top + (rect.Height() - m_szToolIcon.cy) / 2, m_pToolInfo.hIcon);

		//Second variant
//		pDC->DrawState(ptIcon, m_szToolIcon, m_pToolInfo.hIcon, DSS_NORMAL, (CBrush*)NULL);

		//Third variant
		DrawIconEx(pDC->m_hDC, ptIcon.x, ptIcon.y, m_pToolInfo.hIcon, m_szToolIcon.cx, 
			m_szToolIcon.cy, 0, NULL, DI_NORMAL);
		DestroyIcon(m_pToolInfo.hIcon);

//		rect.left += m_szToolIcon.cx + m_nSizes[PPTTSZ_MARGIN_CX]; 
	}

	//Aligns tooltip's text
	if (m_pToolInfo.nStyles & PPTOOLTIP_BOTTOM_ALIGN)
		rect.top = rect.bottom - m_szTextTooltip.cy;
	else if (m_pToolInfo.nStyles & PPTOOLTIP_VCENTER_ALIGN)
		rect.top += (rect.Height() - m_szTextTooltip.cy) / 2;

	//Prints the tooltip's text
	PrintTitleString(pDC, rect, m_pToolInfo.sTooltip, FALSE);
}

void CPPToolTip::OnDrawShadow(CDC * pDC)
{
	//Draws the shadow for the tooltip
	CBrush			brShadow(m_crColor [PPTOOLTIP_COLOR_SHADOW]);
	int			nRop2Mode = pDC->SetROP2(R2_MASKPEN);

	pDC->FillRgn(&m_rgnShadow, &brShadow);
	pDC->SetROP2(nRop2Mode);
}

void CPPToolTip::OnDrawBackground(CDC * pDC, CRect * pRect)
{
	switch (m_pToolInfo.nEffect)
	{
	default:
		pDC->FillSolidRect(pRect, m_crColor[PPTOOLTIP_COLOR_BK_BEGIN]);
		break;
	case PPTOOLTIP_EFFECT_HGRADIENT:
		FillGradient(pDC, pRect, m_crColor[PPTOOLTIP_COLOR_BK_BEGIN], m_crColor [PPTOOLTIP_COLOR_BK_END], TRUE);
		break;
	case PPTOOLTIP_EFFECT_VGRADIENT:
		FillGradient(pDC, pRect, m_crColor[PPTOOLTIP_COLOR_BK_BEGIN], m_crColor [PPTOOLTIP_COLOR_BK_END], FALSE);
		break;
	case PPTOOLTIP_EFFECT_HCGRADIENT:
		FillGradient(pDC, CRect(pRect->left, pRect->top, pRect->left + pRect->Width() / 2, pRect->bottom), 
			m_crColor[PPTOOLTIP_COLOR_BK_BEGIN], m_crColor [PPTOOLTIP_COLOR_BK_END], TRUE);
		FillGradient(pDC, CRect(pRect->left + pRect->Width() / 2, pRect->top, pRect->right, pRect->bottom), 
			m_crColor[PPTOOLTIP_COLOR_BK_END], m_crColor [PPTOOLTIP_COLOR_BK_BEGIN], TRUE);
		break;
	case PPTOOLTIP_EFFECT_VCGRADIENT:
		FillGradient(pDC, CRect (pRect->left, pRect->top, pRect->right, pRect->top + pRect->Height() / 2), 
			m_crColor[PPTOOLTIP_COLOR_BK_BEGIN], m_crColor [PPTOOLTIP_COLOR_BK_END], FALSE);
		FillGradient(pDC, CRect (pRect->left, pRect->top + pRect->Height() / 2, pRect->right, pRect->bottom), 
			m_crColor[PPTOOLTIP_COLOR_BK_END], m_crColor [PPTOOLTIP_COLOR_BK_BEGIN], FALSE);
		break;
	case PPTOOLTIP_EFFECT_3HGRADIENT:
		FillGradient(pDC, CRect(pRect->left, pRect->top, pRect->left + pRect->Width()/2, pRect->bottom), 
			m_crColor[PPTOOLTIP_COLOR_BK_BEGIN], m_crColor [PPTOOLTIP_COLOR_BK_MID], TRUE);
		FillGradient(pDC, CRect(pRect->left + pRect->Width() / 2, pRect->top, pRect->right, pRect->bottom), 
			m_crColor[PPTOOLTIP_COLOR_BK_MID], m_crColor [PPTOOLTIP_COLOR_BK_END], TRUE);
		break;
	case PPTOOLTIP_EFFECT_3VGRADIENT:
		FillGradient(pDC, CRect (pRect->left, pRect->top, pRect->right, pRect->top + pRect->Height() / 2), 
			m_crColor[PPTOOLTIP_COLOR_BK_BEGIN], m_crColor [PPTOOLTIP_COLOR_BK_MID], FALSE);
		FillGradient(pDC, CRect (pRect->left, pRect->top + pRect->Height() / 2, pRect->right, pRect->bottom), 
			m_crColor[PPTOOLTIP_COLOR_BK_MID], m_crColor [PPTOOLTIP_COLOR_BK_END], FALSE);
		break;
#ifdef PPTOOLTIP_USE_SHADE
	case PPTOOLTIP_EFFECT_NOISE:
	case PPTOOLTIP_EFFECT_DIAGSHADE:
	case PPTOOLTIP_EFFECT_HSHADE:
	case PPTOOLTIP_EFFECT_VSHADE:
	case PPTOOLTIP_EFFECT_HBUMP:
	case PPTOOLTIP_EFFECT_VBUMP:
	case PPTOOLTIP_EFFECT_SOFTBUMP:
	case PPTOOLTIP_EFFECT_HARDBUMP:
	case PPTOOLTIP_EFFECT_METAL:
		m_dNormal.Draw(pDC->GetSafeHdc(),0,0);
		break;
#endif
	}
}

void CPPToolTip::RelayEvent(MSG* pMsg)
{
	ASSERT(m_pParentWnd);

	if (m_pParentWnd == NULL)
		return;

	CWnd			*pWnd = NULL;
	int			nIndexTool = PPTOOLTIP_TOOL_NOEXIST;

//	PPTOOLTIP_INFO  Info;
		
	switch(pMsg->message)
	{
		case WM_LBUTTONDOWN:
		case WM_LBUTTONDBLCLK:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONDBLCLK:
		case WM_MBUTTONDOWN:
		case WM_MBUTTONDBLCLK:
		case WM_NCLBUTTONDOWN:
		case WM_NCLBUTTONDBLCLK:
		case WM_NCRBUTTONDOWN:
		case WM_NCRBUTTONDBLCLK:
		case WM_NCMBUTTONDOWN:
		case WM_NCMBUTTONDBLCLK:
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
			// The user has interrupted the current tool - dismiss it
			Pop();
			break;

		case WM_MOUSEMOVE:
			if ( ((m_ptOriginal.x == pMsg->pt.x) && (m_ptOriginal.y == pMsg->pt.y))
				|| (m_nIndexCurrentWnd == PPTOOLTIP_TOOL_HELPER) 
				|| (m_nIndexDisplayWnd == PPTOOLTIP_TOOL_HELPER))
				return; //Mouse pointer was not move
		case WM_MOUSEWHEEL:
		//Check Active window
			if (!(m_nStyles & PPTOOLTIP_SHOW_INACTIVE))
			{
				pWnd = GetActiveWindow();
				if (!pWnd)
					return;
			}

			CPoint CurPoint(pMsg->pt);

			m_ptOriginal = CurPoint; //Stores the mouse's coordinates
			
		//Gets the real window under the mouse
			m_pParentWnd->ScreenToClient(&CurPoint);
			
			nIndexTool = FindTool(CurPoint);

			if (!IsExistTool(nIndexTool))
			{
				//If the window under the mouse doen't exist
				if (IsCursorInToolTip() && (m_pToolInfo.nBehaviour & PPTOOLTIP_CLOSE_LEAVEWND))
					return;
				Pop();
				m_nIndexCurrentWnd = PPTOOLTIP_TOOL_NOEXIST;
				m_nIndexDisplayWnd = PPTOOLTIP_TOOL_NOEXIST;
				return;
			}
			else
			{
				//The window under the mouse does exist
				if (nIndexTool == m_nIndexDisplayWnd)
				{
					if (IsVisible())
					{
						//Now the tooltip is visible
						if ((m_pToolInfo.nBehaviour & PPTOOLTIP_CLOSE_LEAVEWND))
							return;
					}
					if (m_pToolInfo.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)
					{
						SetNewToolTip(nIndexTool);
					}
					else
						Pop();
				}
				else
				{
					SetNewToolTip(nIndexTool, !IsVisible());
				}
			}
			break;
	}
}

void CPPToolTip::SetNewToolTip(int nIndexTool, BOOL bWithDelay /* = TRUE */)
{
//	TRACE (_T("CPPToolTip::SetNewToolTip(Index = 0x%X)\n"), nIndexTool);
	
	m_nIndexDisplayWnd = PPTOOLTIP_TOOL_NOEXIST; //reset the displayed window
	Pop();

	//Gets the info about current tool
	if (!GetTool(nIndexTool, m_pToolInfo))
		return;

	//Remembers the pointer to the current window
	m_nIndexCurrentWnd = nIndexTool;

	//Start the show timer
	if (bWithDelay)
		SetTimer(PPTOOLTIP_SHOW, m_nTimeInitial, NULL);
	else
		OnTimer(PPTOOLTIP_SHOW);
}

void CPPToolTip::OnTimer(UINT nIDEvent) 
{
	CPoint			pt = m_ptOriginal, point;
	int				nIndexTool = PPTOOLTIP_TOOL_HELPER;

	switch (nIDEvent)
	{
	case PPTOOLTIP_SHOW:
//		TRACE(_T("OnTimerShow\n"));
		Pop();
		if (m_nIndexCurrentWnd != PPTOOLTIP_TOOL_HELPER)
		{
			GetCursorPos(&pt);
			point = pt;
			m_pParentWnd->ScreenToClient(&point);
			nIndexTool = FindTool(point);
		}
		if ((nIndexTool == m_nIndexCurrentWnd) && (pt == m_ptOriginal) && IsEnabledIndexTool(nIndexTool))
		{
			PrepareDisplayToolTip(&pt);
			if (m_nTimeAutoPop && !(m_pToolInfo.nBehaviour & PPTOOLTIP_DISABLE_AUTOPOP)) //Don't hide window if autopop is 0
				SetTimer(PPTOOLTIP_HIDE, m_nTimeAutoPop, NULL);
		}
		break;
	case PPTOOLTIP_HIDE:
//		TRACE(_T("OnTimerHide\n"));
		if (!IsCursorInToolTip() || !IsVisible() || !(m_pToolInfo.nBehaviour & PPTOOLTIP_NOCLOSE_OVER))
			Pop();
		break;
	}
	
	CWnd::OnTimer(nIDEvent);
}

BOOL CPPToolTip::IsEnabledIndexTool(int nIndex)
{
	return (BOOL)(IsExistTool(nIndex) || (nIndex == PPTOOLTIP_TOOL_HELPER));
}

BOOL CPPToolTip::IsCursorInToolTip() const
{
    ASSERT(m_pParentWnd);
	
    // Is tooltip visible?
    if (!IsVisible() || !IsWindow(m_hWnd))
		return FALSE;
	
    CPoint			 pt;

    GetCursorPos(&pt);
	
	CPPToolTip		*pWnd = (CPPToolTip*)WindowFromPoint(pt);
	
	return (pWnd == this);
}

void CPPToolTip::KillTimers(UINT nIDTimer /* = NULL */)
{
//	TRACE (_T("CPPToolTip::KillTimers\n"));
	if (nIDTimer == NULL)
	{
		KillTimer(PPTOOLTIP_SHOW);
		KillTimer(PPTOOLTIP_HIDE);
	}
	else if (nIDTimer == PPTOOLTIP_SHOW)
		KillTimer(PPTOOLTIP_SHOW);
	else if (nIDTimer == PPTOOLTIP_HIDE)
		KillTimer(PPTOOLTIP_HIDE);
}

void CPPToolTip::PrepareDisplayToolTip(CPoint * pt)
{
//	TRACE (_T("CPPToolTip::DisplayToolTip()\n"));
	
	//Fills default members
	if (!(m_pToolInfo.nMask & PPTOOLTIP_MASK_STYLES))
		m_pToolInfo.nStyles = m_nStyles;
	if (!(m_pToolInfo.nMask & PPTOOLTIP_MASK_EFFECT))
	{
		m_pToolInfo.nEffect = m_nEffect;
		m_pToolInfo.nGranularity = static_cast<BYTE>(m_nGranularity);
	}
	if (!(m_pToolInfo.nMask & PPTOOLTIP_MASK_COLORS))
	{
		m_pToolInfo.crBegin = m_crColor[PPTOOLTIP_COLOR_BK_BEGIN];
		m_pToolInfo.crMid = m_crColor[PPTOOLTIP_COLOR_BK_MID];
		m_pToolInfo.crEnd = m_crColor[PPTOOLTIP_COLOR_BK_END];
	}
	if (!(m_pToolInfo.nMask & PPTOOLTIP_MASK_DIRECTION))
		m_pToolInfo.nDirection = m_nDirection;
	if (!(m_pToolInfo.nMask & PPTOOLTIP_MASK_BEHAVIOUR))
		m_pToolInfo.nBehaviour = m_nBehaviour;
	
	//Send notify
	SendNotify(pt, m_pToolInfo);

	//If string and icon doesn't exist then exit
	if ((m_pToolInfo.hIcon == NULL) && m_pToolInfo.sTooltip.IsEmpty())
		return;
	
	//calculate the width and height of the box dynamically
	CSize			sz = GetTooltipSize(m_pToolInfo.sTooltip);

	m_szTextTooltip = sz; //Stores the real size of the tooltip's text
	
	//Gets size of the current icon
	m_szToolIcon = GetSizeIcon(m_pToolInfo.hIcon);
	if (m_szToolIcon.cx || m_szToolIcon.cy)
	{
		sz.cx = max(m_szToolIcon.cx, sz.cx);
		/*if (m_szTextTooltip.cx != 0)
			sz.cx += m_nSizes[PPTTSZ_MARGIN_CX]; //If text does exist then adds separator*/
		sz.cy = max(m_szToolIcon.cy, sz.cy);
	}

	//Gets size of the tooltip with margins
	sz.cx += m_nSizes[PPTTSZ_MARGIN_CX] * 2;
	sz.cy += m_nSizes[PPTTSZ_MARGIN_CY] * 2 + m_nSizes[PPTTSZ_HEIGHT_ANCHOR];
	if (m_pToolInfo.nStyles & PPTOOLTIP_SHADOW)
	{
		sz.cx += m_nSizes[PPTTSZ_SHADOW_CX];
		sz.cy += m_nSizes[PPTTSZ_SHADOW_CY];
	}
	
	CRect			rect (0, 0, sz.cx, sz.cy);
	
#ifdef PPTOOLTIP_USE_SHADE
	//If needed to create the bitmap of the background effect
	switch (m_pToolInfo.nEffect)
	{
	case PPTOOLTIP_EFFECT_NOISE:
	case PPTOOLTIP_EFFECT_DIAGSHADE:
	case PPTOOLTIP_EFFECT_HSHADE:
	case PPTOOLTIP_EFFECT_VSHADE:
	case PPTOOLTIP_EFFECT_HBUMP:
	case PPTOOLTIP_EFFECT_VBUMP:
	case PPTOOLTIP_EFFECT_SOFTBUMP:
	case PPTOOLTIP_EFFECT_HARDBUMP:
	case PPTOOLTIP_EFFECT_METAL:
		SetShade(rect, m_pToolInfo.nEffect, static_cast<BYTE>(m_nGranularity), 5, m_pToolInfo.crBegin);
	}
#endif

	DisplayToolTip(pt, &rect);
}

void CPPToolTip::DisplayToolTip(CPoint * pt, CRect * rect)
{
	//Calculate the placement on the screen
	CalculateInfoBoxRect(pt, rect);

	SetWindowPos(NULL, 
                 rect->left, rect->top,
                 rect->Width() + 2, rect->Height() + 2,
                 SWP_SHOWWINDOW|SWP_NOCOPYBITS|SWP_NOACTIVATE|SWP_NOZORDER);

	CRgn			rgnCombo;

	rgnCombo.CreateRectRgn(0, 0, 0, 0);
	if (m_pToolInfo.nStyles & PPTOOLTIP_SHADOW)
	{
		rect->right -= m_nSizes[PPTTSZ_SHADOW_CX];
		rect->bottom -= m_nSizes[PPTTSZ_SHADOW_CY];
	}
	m_rgnToolTip.DeleteObject();
	GetWindowRegion(&m_rgnToolTip, CSize (rect->Width(), rect->Height()), *pt);
	rgnCombo.CopyRgn(&m_rgnToolTip);
	if (m_pToolInfo.nStyles & PPTOOLTIP_SHADOW)
	{
		m_rgnShadow.DeleteObject();
		m_rgnShadow.CreateRectRgn(0, 0, 0, 0);
		m_rgnShadow.CopyRgn(&m_rgnToolTip);
		m_rgnShadow.OffsetRgn(m_nSizes[PPTTSZ_SHADOW_CX], m_nSizes[PPTTSZ_SHADOW_CY]);
		rgnCombo.CombineRgn(&rgnCombo, &m_rgnShadow, RGN_OR);
	}
	SetWindowRgn((HRGN)rgnCombo.Detach(), FALSE);
}

CRect CPPToolTip::GetWindowRegion(CRgn * rgn, CSize sz, CPoint pt)
{
	CRect			rect;

	rect.SetRect(0, 0, sz.cx, sz.cy);

	CRgn			rgnRect;
	CRgn			rgnAnchor;
	CPoint			ptAnchor [3];

	ptAnchor [0] = pt;
	ScreenToClient(&ptAnchor [0]);
	
	switch (m_nLastDirection)
	{
	case PPTOOLTIP_LEFT_TOP:
	case PPTOOLTIP_RIGHT_TOP:
		rect.bottom -= m_nSizes[PPTTSZ_HEIGHT_ANCHOR];
		ptAnchor [1].y = ptAnchor [2].y = rect.bottom;
		break;
	case PPTOOLTIP_LEFT_BOTTOM:
	case PPTOOLTIP_RIGHT_BOTTOM:
		rect.top += m_nSizes[PPTTSZ_HEIGHT_ANCHOR];
		ptAnchor [1].y = ptAnchor [2].y = rect.top;
		break;
	}
	
	//Gets the region for rectangle with the text
	if (m_pToolInfo.nStyles & PPTOOLTIP_ROUNDED)
		rgnRect.CreateRoundRectRgn(rect.left, rect.top, rect.right + 1, rect.bottom + 1, 
		m_nSizes[PPTTSZ_ROUNDED_CX], m_nSizes[PPTTSZ_ROUNDED_CY]);
	else rgnRect.CreateRectRgn(rect.left, rect.top, rect.right + 1, rect.bottom + 1);
	
	//Gets the region for anchor
	if (m_pToolInfo.nStyles & PPTOOLTIP_ANCHOR)
	{
		switch (m_nLastDirection)
		{
		case PPTOOLTIP_LEFT_TOP:
		case PPTOOLTIP_LEFT_BOTTOM:
			ptAnchor [1].x = rect.right - m_nSizes[PPTTSZ_MARGIN_ANCHOR];
			if (ptAnchor [1].x - ptAnchor [0].x > 55)
				ptAnchor [1].x = ptAnchor [0].x + 55;
			ptAnchor [2].x = ptAnchor [1].x - m_nSizes[PPTTSZ_WIDTH_ANCHOR];
			break;
		case PPTOOLTIP_RIGHT_TOP:
		case PPTOOLTIP_RIGHT_BOTTOM:
			ptAnchor [1].x = rect.left + m_nSizes[PPTTSZ_MARGIN_ANCHOR];
			if (ptAnchor [0].x - ptAnchor [1].x > 55)
				ptAnchor [1].x = ptAnchor [0].x - 55;
			ptAnchor [2].x = ptAnchor [1].x + m_nSizes[PPTTSZ_WIDTH_ANCHOR];
			break;
		}
		if (m_nLastDirection == PPTOOLTIP_LEFT_BOTTOM)
		{
			ptAnchor [1].x -= 8;
			ptAnchor [2].x -= 8;
		}
		else if (m_nLastDirection == PPTOOLTIP_RIGHT_BOTTOM)
		{
			ptAnchor [1].x += 16;
			ptAnchor [2].x += 16;
		}
		rgnAnchor.CreatePolygonRgn(ptAnchor, 3, ALTERNATE);
	}
	else
		rgnAnchor.CreateRectRgn(0, 0, 0, 0);
	
	rgn->CreateRectRgn(0, 0, 0, 0);
	rgn->CombineRgn(&rgnRect, &rgnAnchor, RGN_OR);
	
	rgnAnchor.DeleteObject();
	rgnRect.DeleteObject();
	
	return rect;
}

///////////////////////////////////////////////////
//	Gets the size of the current tooltip text
//
//	Parameters:
//		none
//
//	Return value:
//		Size of current tooltip text
///////////////////////////////////////////////////
CSize CPPToolTip::GetTooltipSize(const CString &str)
{
	//Gets max windows rectangle
	CRect			rect;

	GetWindowRect(&rect);

/*	//Calculate the width and height of the box dynamically
	CDC		*pDC = GetDC();
	CSize	sz(0, 0);

	ASSERT(pDC->GetSafeHdc());
	sz = PrintTitleString(pDC, rect, str);
	ReleaseDC(pDC);*/

	//Creates compatibility context device in memory
//	CDC * pDC = GetDC();
	CWindowDC dc(NULL);

	CDC				memDC;
	CBitmap			bitmap;

	memDC.CreateCompatibleDC(&dc);
//	memDC.CreateCompatibleDC(pDC);
	bitmap.CreateCompatibleBitmap(&dc, rect.Width(), rect.Height());
//	bitmap.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());

	CBitmap			*pOldBitmap = memDC.SelectObject(&bitmap);

	//Prints the string on device context for gets minimal size of the rectangle 
	//of the tooltip
	CSize			sz = PrintTitleString(&memDC, rect, str);

	memDC.SelectObject(pOldBitmap);
	bitmap.DeleteObject();
	memDC.DeleteDC();

//	ReleaseDC(pDC);

	//Returns minimal rectangle of the tooltip
	return sz;
}

CSize CPPToolTip::GetSizeIcon(HICON hIcon) const
{
	ICONINFO		ii;

	CSize sz (0, 0);

	if (hIcon != NULL)
	{
		// Gets icon dimension
		memzero(&ii, sizeof(ICONINFO));
		if (::GetIconInfo(hIcon, &ii))
		{
			sz.cx = (DWORD)(ii.xHotspot * 2);
			sz.cy = (DWORD)(ii.yHotspot * 2);
			//release icon mask bitmaps
			if(ii.hbmMask)
				::DeleteObject(ii.hbmMask);
			if(ii.hbmColor)
				::DeleteObject(ii.hbmColor);
		}
	}
	return sz;
}

///////////////////////////////////////////////////
//	Calculates the real rect for the tooltip with margins
//
//	Parameters:
//		pt		[in] - the mouse coordinates (screen coordinates)
//		sz		[in] - the size of the tooltip text
//
//	Return value:
//		The rectangle when the tooltip will draw (screen coordinates)
///////////////////////////////////////////////////
void CPPToolTip::CalculateInfoBoxRect(CPoint * pt, CRect * rect)
{
	// Get tooltip work area
	HMONITOR		hMonitor = MonitorFromPoint(*pt, MONITOR_DEFAULTTONEAREST);
	MONITORINFO		mi;
	CRect			rWindow;

	mi.cbSize = sizeof(mi);
	GetMonitorInfo(hMonitor, &mi);
	rWindow.left    = max(::GetSystemMetrics(SM_XVIRTUALSCREEN), mi.rcWork.left);
	rWindow.top     = max(::GetSystemMetrics(SM_YVIRTUALSCREEN), mi.rcWork.top);
	rWindow.right   = rWindow.left + min(::GetSystemMetrics(SM_CXVIRTUALSCREEN), mi.rcWork.right - mi.rcWork.left);
	rWindow.bottom  = rWindow.top + min(::GetSystemMetrics(SM_CYVIRTUALSCREEN), mi.rcWork.bottom - mi.rcWork.top);

	// Offset the rect according to the direction
	m_nLastDirection = m_pToolInfo.nDirection;
	
	if (!TestHorizDirection(pt->x, rect->Width(), rWindow, m_nLastDirection, rect))
	{
		m_nLastDirection = GetNextHorizDirection(m_nLastDirection);
		if (!TestHorizDirection(pt->x, rect->Width(), rWindow, m_nLastDirection, rect))
		{
			if (m_nLastDirection == PPTOOLTIP_LEFT_BOTTOM)
				m_nLastDirection = PPTOOLTIP_RIGHT_BOTTOM;
			else if (m_nLastDirection == PPTOOLTIP_LEFT_TOP)
				m_nLastDirection = PPTOOLTIP_RIGHT_TOP;
			rect->left = rWindow.right - rect->Width();
			rect->right = rWindow.right;
		}
	}
	if (!TestVertDirection(pt->y, rect->Height(), rWindow, m_nLastDirection, rect))
	{
		m_nLastDirection = GetNextVertDirection(m_nLastDirection);
		if (!TestVertDirection(pt->y, rect->Height(), rWindow, m_nLastDirection, rect))
		{
			if (m_nLastDirection == PPTOOLTIP_LEFT_TOP)
				m_nLastDirection = PPTOOLTIP_LEFT_BOTTOM;
			else if (m_nLastDirection == PPTOOLTIP_RIGHT_TOP)
				m_nLastDirection = PPTOOLTIP_RIGHT_BOTTOM;
			rect->top = rWindow.bottom - rect->Height();
			rect->bottom = rWindow.bottom;
		}
	}

	// Returns the rect of the tooltip
	if ((m_pToolInfo.nStyles & PPTOOLTIP_SHADOW) && 
		((m_nLastDirection == PPTOOLTIP_LEFT_TOP) || (m_nLastDirection == PPTOOLTIP_LEFT_BOTTOM)))
		rect->OffsetRect(m_nSizes[PPTTSZ_SHADOW_CX], m_nSizes[PPTTSZ_SHADOW_CY]);
}

///////////////////////////////////////////////////
//	Gets the next horizontal direction
//
//	Parameters:
//		nDirection		[in] - the current direction
//
//	Return value:
//		The next horizontal direction
///////////////////////////////////////////////////
int CPPToolTip::GetNextHorizDirection(int nDirection) const
{
	switch (nDirection)
	{
	case PPTOOLTIP_LEFT_TOP:
		nDirection = PPTOOLTIP_RIGHT_TOP;
		break;
	case PPTOOLTIP_RIGHT_TOP:
		nDirection = PPTOOLTIP_LEFT_TOP;
		break;
	case PPTOOLTIP_LEFT_BOTTOM:
		nDirection = PPTOOLTIP_RIGHT_BOTTOM;
		break;
	case PPTOOLTIP_RIGHT_BOTTOM:
		nDirection = PPTOOLTIP_LEFT_BOTTOM;
		break;
	}
	return nDirection;
}

///////////////////////////////////////////////////
//	Gets the next vertical direction
//
//	Parameters:
//		nDirection		[in] - the current direction
//
//	Return value:
//		The next vertical direction
///////////////////////////////////////////////////
int CPPToolTip::GetNextVertDirection(int nDirection) const
{
	switch (nDirection)
	{
	case PPTOOLTIP_LEFT_TOP:
		nDirection = PPTOOLTIP_LEFT_BOTTOM;
		break;
	case PPTOOLTIP_LEFT_BOTTOM:
		nDirection = PPTOOLTIP_LEFT_TOP;
		break;
	case PPTOOLTIP_RIGHT_TOP:
		nDirection = PPTOOLTIP_RIGHT_BOTTOM;
		break;
	case PPTOOLTIP_RIGHT_BOTTOM:
		nDirection = PPTOOLTIP_RIGHT_TOP;
		break;
	}
	return nDirection;
}

BOOL CPPToolTip::TestHorizDirection(int x, int cx, LPRECT w_rect, int nDirection, LPRECT rect) const
{
	int			left, right;
	
	switch (nDirection)
	{
		case PPTOOLTIP_LEFT_TOP:
		case PPTOOLTIP_LEFT_BOTTOM:
			right = ((x + (int)m_nSizes[PPTTSZ_MARGIN_ANCHOR]) > w_rect->right) ? w_rect->right : (x + m_nSizes[PPTTSZ_MARGIN_ANCHOR]);
			left = right - cx;
			break;
		case PPTOOLTIP_RIGHT_TOP:
		case PPTOOLTIP_RIGHT_BOTTOM:
			left = (x < (w_rect->left + (int)m_nSizes[PPTTSZ_MARGIN_ANCHOR])) ? w_rect->left : (x - m_nSizes[PPTTSZ_MARGIN_ANCHOR]);
			right = left + cx;
			break;
		default:
			return FALSE;
	}

	bool		bTestOk = ((left >= w_rect->left) && (right <= w_rect->right)) ? TRUE : FALSE;

	if (bTestOk)
	{
		rect->left = left;
		rect->right = right;
	}

	return bTestOk;
}

BOOL CPPToolTip::TestVertDirection(int y, int cy, LPRECT w_rect, int nDirection, LPRECT rect) const
{
	int			top, bottom;

	switch (nDirection)
	{
		case PPTOOLTIP_LEFT_TOP:
		case PPTOOLTIP_RIGHT_TOP:
			bottom = max(y, w_rect->top);
			top = bottom - cy;
			break;
		case PPTOOLTIP_LEFT_BOTTOM:
		case PPTOOLTIP_RIGHT_BOTTOM:
			top = min(y, w_rect->bottom);
			bottom = top + cy;
			break;
		default:
			return FALSE;
	}

	bool		bTestOk = ((top >= w_rect->top) && (bottom <= w_rect->bottom)) ? TRUE : FALSE;

	if (bTestOk)
	{
		rect->top = top;
		rect->bottom = bottom;
	}

	return bTestOk;
}

/////////////////////////////////////////////////////////////////
// Gets the system tooltip's logfont
/////////////////////////////////////////////////////////////////
void CPPToolTip::GetSystemToolTipFont(LOGFONT *pLogFont) const
{
	CFont	*pDefGuiFont = CFont::FromHandle(static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT)));

	pDefGuiFont->GetLogFont(pLogFont);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
// Prints the formating string of the tooltip
//  
// Parameters:
//		pDC			 - [in] The device context to print the string
//      str			 - [in] The formating string for drawing
//      rect         - [in] The rectangle to draws the tooltip
//		bEnableAlign - [in] If TRUE align's operators are enables.
//
// Return values:
//      None.
//---------------------------------------------------------------
// Format of string:
//  <b> text </b> - The bold string
//  <i> text </i> - The italic string 
//  <u> text </u> - The underline string
//  <s> text </s> - The strike out string
//
//  <cb=0x123456> text </cb> - The background color (RGB (12,34,56))
//  <ct=0x123456> text </ct> - The text color (RGB (12,34,56))
//
//  <cbi=1> text </cbi> - The index background color(0 - F)
//  <cti=1> text </cti> - The index text color(0 - F)
//
//	<al> or <al_l> - sets align to left edge
//  <al_c> - sets align to the center 
//  <al_r> - sets align to the right edge
//
//	<hr=100%> - the horizontal line with length 100%
//  <hr=32> - the horizontal line with length 32 pixels.
//
//	<a="link"> text </a> - The hyperlink 
//
//  <h=1> text </h> - hot zone (number of zone)
//
//	<br[=1]> - new line (numbers of the lines)
//  <t[=1]> - tabulation (number of tabulations)
//
//  <img[=0x0000] [cx=0] [cy=0]>				 - draws the image by his name
//  <ilst[=0x0000]>								 - draws the image from image list
//  <bmp[=0x0000] mask[=0xFF00FF] [cx=0] [cy=0]> - draws bitmap
//  <icon[=0x0000] [cx=0] [cy=0]>				 - draws the icon
//
//  <cat=0x123456> Draws a category triangle - The triangle color (RGB (12,34,56))
////////////////////////////////////////////////////////////////////////////////////////////////////
CSize CPPToolTip::PrintTitleString(CDC * pDC, CRect rect, const CString &str, BOOL bCalculate /* = TRUE */)
{
	enum{	CMD_NONE = 0,
			CMD_BOLD,
			CMD_ITALIC,
			CMD_STRIKE,
			CMD_UNDERLINE,
			CMD_COLOR_TEXT,
			CMD_COLOR_TEXT_INDEX,
			CMD_COLOR_BK,
			CMD_COLOR_BK_INDEX,
			CMD_NEW_LINE,
			CMD_TABULATION,
			CMD_HORZ_LINE,
			CMD_HORZ_LINE_PERCENT,
			CMD_DRAW_IMAGE,
			CMD_DRAW_IMAGE_LIST,
			CMD_DRAW_BITMAP,
			CMD_DRAW_BITMAP_MASK,
			CMD_DRAW_ICON,
			CMD_DRAW_TRIANGLE
	};

	enum{	ALIGN_LEFT = 0,
			ALIGN_CENTER,
			ALIGN_RIGHT
		};

	//Clears the length of the lines
	if (bCalculate)
	{
		m_nLengthLines.RemoveAll();
		m_nHeightLines.RemoveAll();
		m_iAutoTabLines.RemoveAll();
	}

	CSize			sz(0, 0);

	if (str.IsEmpty())
		return sz;

	CUIntArray		aiPercent, aiTabbedLines, aiTabbedTo, aiOrigTabLines;
	int			iLineIdx = 0;
	int			nCmd = CMD_NONE;
	int			nAlign = ALIGN_LEFT;
	bool			bCloseTag = FALSE;

// if input string is not empty, then we have at least one string
	if (bCalculate)
	{
		m_nLengthLines.Add(0);
		m_nHeightLines.Add(0);
		m_iAutoTabLines.Add(0);
	}
	aiPercent.Add(0);

	CSize			szLine(0, 0);
	CSize			szIcon(0, 0); //The size of icon
	CPoint			pt = rect.TopLeft();
	CPoint			ptCur = pt;

	// Copies default logfont's structure
	LOGFONT			lf;
	NEWTEXTMETRIC		ntm;
	CFont			font, *pOldFont;

// create normal font
	memcpy(&lf, &m_LogFont, sizeof(LOGFONT));
	font.CreateFontIndirect(&lf);
// choose normal font & get it metrics
// note: for some unknown reason (bug in VS2003?, graphic driver?) the call of the GetTextMetrics()
// in unicode compilation leads to the message "stack corruption".
// The use of larger structure NEWTEXTMETRIC allows to prevent it.
	pOldFont = pDC->SelectObject(&font);
	pDC->GetTextMetrics((TEXTMETRIC*)&ntm);

	int				nHeight = ntm.tmHeight; //The height of the font
	int				nWidth = ntm.tmAveCharWidth; //The width of the font

	CString			strTag;  // Tag's name 
	CString			strText; // The current text to output
	CString			sParam; // The text parameter

	UINT			nParam = 0, nParam1 = 0;
	int				nLineHeight = bCalculate ? nHeight : m_nHeightLines.GetAt(0); //The height of the current line

	int				i, iTmp = 0;
	int				iCurTabLine = 0;
	bool			bFirstOutput = true;

	MONITORINFO		mi;
	HMONITOR		hMonitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);

	mi.cbSize = sizeof(mi);
	GetMonitorInfo(hMonitor, &mi);

	pDC->SetTextColor(m_crColor[PPTOOLTIP_COLOR_FG]);

	for (i = 0; i <= str.GetLength(); i++)
	{
		if (i < str.GetLength())
		{
			nCmd = CMD_NONE;
			strText = SearchBeginOfTag(str, i);
			if (strText.IsEmpty())
			{
				//Tag was found
				strTag = GetNameOfTag(str, i);
				bCloseTag = (strTag.GetAt(0) == _T('/')) ? TRUE : FALSE;
				if (bCloseTag)
					strTag = strTag.Right(strTag.GetLength() - 1);
				strTag.MakeLower();
				if (strTag == _T("b"))
				{
					nCmd = CMD_BOLD;
				}
				else if (strTag == _T("i"))
				{
					nCmd = CMD_ITALIC;
				}
				else if (strTag == _T("u"))
				{
					nCmd = CMD_UNDERLINE;
				}
				else if (strTag == _T("s"))
				{
					nCmd = CMD_STRIKE;
				}
				else if (strTag == _T("br"))
				{
					nCmd = CMD_NEW_LINE;
					nParam = GetUIntValue(str, i, 1);
				}
				else if (strTag == _T("t"))
				{
					nCmd = CMD_TABULATION;
					nParam = GetUIntValue(str, i, 0);
				}
				else if (strTag == _T("ct"))
				{
					nCmd = CMD_COLOR_TEXT;
					nParam = GetUIntValue(str, i, (UINT)m_crColor[PPTOOLTIP_COLOR_FG]);
				}
				else if (strTag == _T("cti"))
				{
					nCmd = CMD_COLOR_TEXT;
					nParam = GetUIntValue(str, i, PPTOOLTIP_COLOR_FG);
				}
				else if (strTag == _T("cb"))
				{
					nCmd = CMD_COLOR_BK;
					nParam = GetUIntValue(str, i, (UINT)m_crColor[PPTOOLTIP_COLOR_BK_BEGIN]);
				}
				else if (strTag == _T("cbi"))
				{
					nCmd = CMD_COLOR_BK_INDEX;
					nParam = GetUIntValue(str, i, PPTOOLTIP_COLOR_BK_BEGIN);
				}
				else if (strTag == _T("al") || strTag == _T("al_l"))
				{
					nAlign = ALIGN_LEFT;
				}
				else if (strTag == _T("al_c"))
				{
					if (!bCalculate)
						nAlign = ALIGN_CENTER;
				}
				else if (strTag == _T("al_r"))
				{
					if (!bCalculate)
						nAlign = ALIGN_RIGHT;
				}
				else if (strTag == _T("hr"))
				{
					sParam = GetStringValue(str, i);
					if (!sParam.IsEmpty())
						nParam = _tcstoul(sParam, 0, 0);
					else
						nParam = 100;
					nCmd = (sParam.Right(1) == _T("%"))? CMD_HORZ_LINE_PERCENT : CMD_HORZ_LINE;
				}
				else if (strTag == _T("img"))
				{
					nCmd = CMD_DRAW_IMAGE;
					sParam = GetStringValue(str, i);
					szIcon = CSize(0, 0);
					//Gets two param
					for (iTmp = 0; iTmp < 2; iTmp++)
					{
						strTag = GetPropertiesOfTag(str, i).MakeLower();
						if (strTag == _T("cx"))
							szIcon.cx = GetUIntValue(str, i, 0);
						else if (strTag == _T("cy"))
							szIcon.cy = GetUIntValue(str, i, 0);
					}
				}
				else if (strTag == _T("ilst"))
				{
					nCmd = CMD_DRAW_IMAGE_LIST;
					nParam = GetUIntValue(str, i, 0);
				}
				else if (strTag == _T("icon"))
				{
					nCmd = CMD_DRAW_ICON;
					nParam = GetUIntValue(str, i, 0);
					szIcon = CSize(0, 0);
					//Gets two param
					for (iTmp = 0; iTmp < 2; iTmp++)
					{
						strTag = GetPropertiesOfTag(str, i).MakeLower();
						if (strTag == _T("cx"))
							szIcon.cx = GetUIntValue(str, i, 0);
						else if (strTag == _T("cy"))
							szIcon.cy = GetUIntValue(str, i, 0);
					}
				}
				else if (strTag == _T("bmp"))
				{
					nCmd = CMD_DRAW_BITMAP;
					nParam = GetUIntValue(str, i, 0);
					sParam.Empty();
					//Gets three param
					for (iTmp = 0; iTmp < 3; iTmp++)
					{
						strTag = GetPropertiesOfTag(str, i).MakeLower();
						if (strTag == _T("mask"))
						{
							sParam = strTag;
							nParam1 = GetUIntValue(str, i, 0xFF00FF);
						}
						else if (strTag == _T("cx"))
							szIcon.cx = GetUIntValue(str, i, 0);
						else if (strTag == _T("cy"))
							szIcon.cy = GetUIntValue(str, i, 0);
					}
				}
				else if (strTag == _T("cat"))
				{
					nCmd = CMD_DRAW_TRIANGLE;
					nParam = GetUIntValue(str, i, (UINT)m_crColor[PPTOOLTIP_COLOR_FG]);
				}
				else
					nCmd = CMD_NONE;
				SearchEndOfTag(str, i);
			}
			else
			{
				//If text to output does exist
				if (bFirstOutput)
				{
					switch (nAlign)
					{
					case ALIGN_CENTER:
						ptCur.x = pt.x + (rect.Width() - m_nLengthLines.GetAt(iLineIdx)) / 2;
						break;
					case ALIGN_RIGHT:
						ptCur.x = pt.x + rect.Width() - m_nLengthLines.GetAt(iLineIdx);
						break;
					}
				}
				
				szLine = pDC->GetTextExtent(strText);

				if ((long)((ptCur.x - pt.x) + szLine.cx + (m_nSizes[PPTTSZ_MARGIN_CX] * 2) + m_nSizes[PPTTSZ_SHADOW_CX]) > (mi.rcWork.right - mi.rcWork.left))
				{
					while (!strText.IsEmpty() && (long)((ptCur.x - pt.x) + szLine.cx + (m_nSizes[PPTTSZ_MARGIN_CX] * 2) + m_nSizes[PPTTSZ_SHADOW_CX]) > (mi.rcWork.right - mi.rcWork.left))
					{
						strText.Truncate(strText.GetLength() - 1);
						szLine = pDC->GetTextExtent(strText + _T("..."));
					}
					strText += _T("...");
				}

				if (bCalculate)
					nLineHeight = max(nLineHeight, szLine.cy);
				else
				{
					if (IsRightToLeftLanguage())
					{
						bool	bRTL = true, bFound1 = false, bFound2 = false, bFound3 = false;

						for (int j = 0; j < strText.GetLength(); j++)
						{
							TCHAR tc = static_cast<TCHAR>(toupper(strText[j]));

						//	Detect if we have text with latin letter that must be printed out with left to right order
							if (tc >= _T('A') && tc <= _T('Z'))
							{
								bRTL = false;
								break;
							}
							else if (tc == _T('(') || tc == _T('['))
							{
								bFound1 = true;
								bFound3 = false;
							}
							else if (tc == _T(')') || tc == _T(']'))
							{
								bFound2 = true;
								bFound3 = false;
							}
							else if (tc == _T(':') || tc == _T(';'))
								bFound3 = true;
							else if (tc != _T(' '))
								bFound3 = false;
						}
						
						if (bRTL && bFound1 == bFound2 && !bFound3)
							pDC->SetTextAlign(pDC->GetTextAlign() | TA_RTLREADING);
						else
							pDC->SetTextAlign(pDC->GetTextAlign() & ~TA_RTLREADING);
					}
					pDC->TextOut(ptCur.x, ptCur.y + m_nHeightLines.GetAt(iLineIdx) - nHeight, strText);
				}
				ptCur.x += szLine.cx;
				strText.Empty();
				bFirstOutput = FALSE;
				i--;
			}
		}
		else
		{
			nCmd = CMD_NEW_LINE;
			nParam = 1; 
		}

		//Prepares to first draw in line
		switch (nCmd)
		{
		case CMD_DRAW_IMAGE:
		case CMD_DRAW_IMAGE_LIST:
		case CMD_DRAW_BITMAP:
		case CMD_DRAW_ICON:
			if (bFirstOutput)
			{
				switch (nAlign)
				{
				case ALIGN_CENTER:
					ptCur.x = pt.x + (rect.Width() - m_nLengthLines.GetAt(iLineIdx)) / 2;
					break;
				case ALIGN_RIGHT:
					ptCur.x = pt.x + rect.Width() - m_nLengthLines.GetAt(iLineIdx);
					break;
				}
				bFirstOutput = FALSE;
			}
			break;
		}
		
		//Executes command
		switch (nCmd)
		{
		case CMD_BOLD:
			//Bold text
			pDC->SelectObject(pOldFont);
			font.DeleteObject();
			lf.lfWeight = m_LogFont.lfWeight; 
			if (!bCloseTag) 
			{ 
				lf.lfWeight *= 2;   
				if (lf.lfWeight > FW_BLACK)   
					lf.lfWeight = FW_BLACK;   
			} 
			font.CreateFontIndirect(&lf);
			pDC->SelectObject(&font);
			break;
		case CMD_ITALIC:
			//Italic text
			pDC->SelectObject(pOldFont);
			font.DeleteObject();
			lf.lfItalic = !bCloseTag;
			font.CreateFontIndirect(&lf);
			pDC->SelectObject(&font);
			break;
		case CMD_STRIKE:
			//Strikeout text
			pDC->SelectObject(pOldFont);
			font.DeleteObject();
			lf.lfStrikeOut = !bCloseTag;
			font.CreateFontIndirect(&lf);
			pDC->SelectObject(&font);
			break;
		case CMD_UNDERLINE:
			//Underline text
			pDC->SelectObject(pOldFont);
			font.DeleteObject();
			lf.lfUnderline = !bCloseTag;
			font.CreateFontIndirect(&lf);
			pDC->SelectObject(&font);
			break;
		case CMD_COLOR_TEXT:
			//Color of the text
			pDC->SetTextColor((COLORREF)nParam);
			break;
		case CMD_COLOR_TEXT_INDEX:
			//Indexed color of the text
			if (nParam < PPTOOLTIP_MAX_COLORS)
				pDC->SetTextColor(m_crColor[nParam]);
			break;
		case CMD_COLOR_BK:
			//Color of the background
			pDC->SetBkColor((COLORREF)nParam);
			pDC->SetBkMode(bCloseTag ? TRANSPARENT : OPAQUE);
			break;
		case CMD_COLOR_BK_INDEX:
			//Indexed color of the background
			if (nParam < PPTOOLTIP_MAX_COLORS)
			{
				pDC->SetBkColor(m_crColor[nParam]);
				pDC->SetBkMode(bCloseTag ? TRANSPARENT : OPAQUE);
			}
			break;
		case CMD_HORZ_LINE_PERCENT:
			//Horizontal line with percent length
			if (bCalculate)
			{
				aiPercent.SetAt(iLineIdx, aiPercent.GetAt(iLineIdx) + nParam);
				nParam = 0;
			}
			else
				nParam = ::MulDiv(rect.Width(), nParam, 100);
			// fall throuth to draw horizontal line
		case CMD_HORZ_LINE:
			//Horizontal line with absolute length
			//If text to output does exist
			if (!bCalculate)
				DrawHorzLine(pDC, ptCur.x, ptCur.x + nParam, ptCur.y + m_nHeightLines.GetAt(iLineIdx) / 2);
			else
				m_iAutoTabLines.Add(0);
			iCurTabLine++;
			ptCur.x += nParam;
			break;
		case CMD_DRAW_IMAGE:
			if (!sParam.IsEmpty())
			{
				if (bCalculate)
				{
					szLine = DrawResource(sParam, pDC, ptCur, 0, szIcon, bCalculate);
					nLineHeight = max(nLineHeight, szLine.cy);
				}
				else
					szLine = DrawResource(sParam, pDC, ptCur, m_nHeightLines.GetAt(iLineIdx), szIcon, bCalculate);
				ptCur.x += szLine.cx;
			}
			break;
		case CMD_DRAW_IMAGE_LIST:
			if (m_imgTooltip.m_hImageList != NULL)
			{
				if (bCalculate)
				{
					szLine = DrawIconFromImageList(pDC, ptCur, m_szImage, m_imgTooltip, nParam, bCalculate);
					nLineHeight = max(nLineHeight, szLine.cy);
				}
				else
					szLine = DrawIconFromImageList(pDC, ptCur, m_szImage, m_imgTooltip, nParam, bCalculate);
				// If in one line a few bitmap with different height, then store max height
				ptCur.x += szLine.cx; //m_szImage.cx;
			}
			break;
		case CMD_DRAW_BITMAP:
			if (nParam != 0)
			{
				if (bCalculate)
				{
					szLine = DrawBitmap(pDC, ptCur, 0, nParam, !sParam.IsEmpty(), nParam1, szIcon, bCalculate);
					nLineHeight = max(nLineHeight, szLine.cy);
				}
				else
					szLine = DrawBitmap(pDC, ptCur, m_nHeightLines.GetAt(iLineIdx), nParam, !sParam.IsEmpty(), nParam1, szIcon, bCalculate);
				// If in one line a few bitmap with different height, then store max height
				ptCur.x += szLine.cx;
			}
			break;
		case CMD_DRAW_ICON:
			if (nParam != 0)
			{
				if (bCalculate)
				{
					szLine = DrawIcon(pDC, ptCur, 0, nParam, szIcon, bCalculate);
					nLineHeight = max(nLineHeight, szLine.cy);
				}
				else
					szLine = DrawIcon(pDC, ptCur, m_nHeightLines.GetAt(iLineIdx), nParam, szIcon, bCalculate);
				// If in one line a few bitmap with different height, then store max height
				ptCur.x += szLine.cx;
			}
			break;
		case CMD_NEW_LINE:
			//New line
			if (!nParam)
				nParam = 1;
			if (bCalculate)
			{
				sz.cx = max(sz.cx, ptCur.x - pt.x);
				m_nLengthLines.SetAt(iLineIdx, ptCur.x - pt.x); //Adds the real length of the lines
				m_nHeightLines.SetAt(iLineIdx, nLineHeight); //Adds the real height of the lines
				m_nLengthLines.Add(0);
				m_nHeightLines.Add(0);
			}
			ptCur.y += m_nHeightLines.GetAt(iLineIdx) * nParam;
			iLineIdx++;
			aiPercent.Add(0);
			bFirstOutput = TRUE;
			ptCur.x = pt.x;
			nLineHeight = nHeight;
	//		szLine.cy = nHeight;
			break;
		case CMD_TABULATION:
			//Tabulation
			if (!nParam) // Auto tab
			{
				if (bCalculate)
				{
					ptCur.x += (nWidth * 3);
					aiOrigTabLines.Add(ptCur.x - pt.x);
					aiTabbedLines.Add(iLineIdx);
					aiTabbedTo.Add(iCurTabLine);
					if (m_iAutoTabLines.GetAt(iCurTabLine) < (UINT)(ptCur.x - pt.x))
						m_iAutoTabLines.SetAt(iCurTabLine, ptCur.x - pt.x);
				}
				else
					ptCur.x = pt.x + m_iAutoTabLines.GetAt(iCurTabLine);
			}
			else
			{
				nParam1 = (ptCur.x - pt.x) % (nWidth * 4);
				if (nParam1)
				{
					//aligns with tab
					ptCur.x += (nWidth * 4) - nParam1;
					nParam --;
				}
				ptCur.x += (nParam * nWidth * 4);
			}
			break;
		case CMD_DRAW_TRIANGLE:
			// Category triangle
			if (!bCalculate)
			{
				CBrush			*pOldBrush, brNewBrush;

				brNewBrush.CreateSolidBrush((COLORREF)nParam);
				pOldBrush = pDC->SelectObject(&brNewBrush);
				pDC->BeginPath();
				pDC->MoveTo(ptCur.x, ptCur.y);
				pDC->LineTo(ptCur.x + 12, ptCur.y);
				pDC->LineTo(ptCur.x, ptCur.y + 12);
				pDC->EndPath();
				pDC->FillPath();
				pDC->SelectObject(pOldBrush);
			}
			ptCur.x += 16;
			nLineHeight = max(nLineHeight, 16);
			break;
		}
	}
	//Gets real height of the tooltip
	sz.cy = ptCur.y - pt.y;

	pDC->SelectObject(pOldFont);
	font.DeleteObject();

	if (bCalculate)
	{
		for (i = 0; i < aiTabbedLines.GetSize(); i++)
		{
			UINT uiTabbedLine = aiTabbedLines.GetAt(i);
			UINT uiNewLineLength =  m_nLengthLines.GetAt(uiTabbedLine) + (m_iAutoTabLines.GetAt(aiTabbedTo.GetAt(i)) - aiOrigTabLines.GetAt(i));

			m_nLengthLines.SetAt(uiTabbedLine, uiNewLineLength);
			sz.cx = max((UINT)sz.cx, uiNewLineLength);
		}
	}

	//Adds the percent's length to the line's length
	for (i = 0; i < m_nLengthLines.GetSize(); i++)
	{
		if (aiPercent.GetAt(i))
			m_nLengthLines.SetAt(i, m_nLengthLines.GetAt(i) + ::MulDiv(aiPercent.GetAt(i), sz.cx, 100));
	}

	return sz;
}

CString CPPToolTip::SearchBeginOfTag(const CString &str, int &nIndex)
{
	CString			sText;

	sText.Preallocate(str.GetLength() - nIndex);

	for (nIndex; nIndex < str.GetLength(); nIndex ++)
	{
		switch (str.GetAt(nIndex))
		{
		// Pass characters
		case _T('\b'):
		case _T('\n'):
		case _T('\r'):
		case _T('\t'):
			break;
		case _T('<'):
			nIndex ++;
			if ((nIndex < str.GetLength()) && (str.GetAt(nIndex) != _T('<')))
			{
				if (!sText.IsEmpty())
					nIndex --;
				return sText;
			}
			sText += _T('<');
			break;
		default:
			sText += str.GetAt(nIndex);
			break;
		}
	}
	return sText;
}

void CPPToolTip::SearchEndOfTag(const CString &str, int& nIndex)
{
	for (nIndex; nIndex < str.GetLength(); nIndex ++)
	{
		if (str.GetAt(nIndex) == _T('>'))
			return;
	}
}

CString CPPToolTip::GetNameOfTag(const CString &str, int &nIndex)
{
	CString			sText;
	
	for (nIndex; nIndex < str.GetLength(); nIndex ++)
	{
		switch (str.GetAt(nIndex))
		{
		case _T('\r'): //Pass character
			break;
			if (sText.IsEmpty())
			{
				sText += str.GetAt(nIndex);
//				nIndex ++;
				return sText;
			}
			break;
		case _T(' '):
			if (!sText.IsEmpty())
			{
				nIndex ++;
				return sText;
			}
			break;
		case _T('>'):
		case _T('='):
			return sText;
		default:
			sText += str.GetAt(nIndex);
			break;
		}
	}
	return sText;
}

CString CPPToolTip::GetPropertiesOfTag(const CString &str, int &nIndex)
{
	CString			sText;
	
	for (nIndex; nIndex < str.GetLength(); nIndex ++)
	{
		switch (str.GetAt(nIndex))
		{
		// Pass characters
		case _T('\b'):
		case _T('\n'):
		case _T('\r'):
		case _T('\t'):
			break;
		case _T(' '):
			if (!sText.IsEmpty())
			{
				nIndex ++;
				return sText;
			}
			break;
		case _T('>'):
		case _T('='):
			return sText;
		default:
			sText += str.GetAt(nIndex);
			break;
		}
	}
	return sText;
}

CString CPPToolTip::GetStringValue(const CString &str, int &nIndex)
{
	CString			sText;
	bool			bValueFound = FALSE;

	sText.Preallocate(str.GetLength() - nIndex);

	for (nIndex; nIndex < str.GetLength(); nIndex ++)
	{
		switch (str.GetAt(nIndex))
		{
		// Pass characters
		case _T('\b'): 
		case _T('\n'): 
		case _T('\r'):
		case _T('\t'):
			break;
		case _T(' '):
			if (!sText.IsEmpty())
			{
				nIndex ++;
				return sText;
			}
			break;
		case _T('>'):
			return sText;
		case _T('='):
			bValueFound = TRUE;
			break;
		default:
			if (!bValueFound)
				return sText;
			sText += str.GetAt(nIndex);
			break;
		}
	}
	return sText;

}

UINT CPPToolTip::GetUIntValue(const CString &str, int &nIndex, UINT nDefValue)
{
	CString			sText = GetStringValue(str, nIndex);

	if (!sText.IsEmpty())
		nDefValue = _tcstoul(sText, 0, 0);

	return nDefValue;
}

CSize CPPToolTip::DrawResource(CString sName, CDC * pDC, CPoint pt, int nMaxHeight, CSize szResource, BOOL bCalculate)
{
	CSize			sz(0, 0);
	int				nIndex = FindIdOfResource(sName);

	if (nIndex < 0)
		return sz;

	PPTOOLTIP_NAME_RES		nr = m_arrNameRes.GetAt(nIndex);

	if (nr.nID == 0)
		return sz;

	switch (nr.nTypeRes)
	{
	case TYPE_RES_ICON:
		sz = DrawIcon(pDC, pt, nMaxHeight, nr.nID, szResource, bCalculate);
		break;
	case TYPE_RES_BITMAP:
		sz = DrawBitmap(pDC, pt, nMaxHeight, nr.nID, FALSE, nr.crMask, szResource, bCalculate);
		break;
	case TYPE_RES_MASK_BITMAP:
		sz = DrawBitmap(pDC, pt, nMaxHeight, nr.nID, TRUE, nr.crMask, szResource, bCalculate);
		break;
	}

	return sz;
}

CSize CPPToolTip::DrawBitmap(CDC * pDC, CPoint pt, int nMaxHeight, UINT nID, BOOL bUseMask, COLORREF crMask, CSize szBitmap, BOOL bCalculate)
{
	CSize			sz(0, 0);
	HBITMAP			hBitmap = GetBitmapFromResources(nID);
	int			nRetValue;
	BITMAP			csBitmapSize;
	
	if (hBitmap == NULL)
		return sz;
	
	// Get bitmap size
	nRetValue = ::GetObject(hBitmap, sizeof(csBitmapSize), &csBitmapSize);
	if (nRetValue == 0)
	{
		::DeleteObject(hBitmap);
		return sz;
	}
	
	sz.cx = (DWORD)csBitmapSize.bmWidth;
	sz.cy = (DWORD)csBitmapSize.bmHeight;

	if (!szBitmap.cy)
		szBitmap.cy = sz.cy;

	if (!szBitmap.cx)
		szBitmap.cx = sz.cx;

	if (bCalculate)
	{
		::DeleteObject(hBitmap);
		return szBitmap;
	}
	
	HDC				hSrcDC = ::CreateCompatibleDC(pDC->m_hDC);
	HDC				hResDC = ::CreateCompatibleDC(pDC->m_hDC);
	HBITMAP			hSrcBitmap = ::CreateCompatibleBitmap(pDC->m_hDC, szBitmap.cx, szBitmap.cy);
	HBITMAP			hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, hSrcBitmap);
	HBITMAP			hOldResBitmap = (HBITMAP)::SelectObject(hResDC, hBitmap);

	//Scales a bitmap if need
	if ((sz.cx != szBitmap.cx) || (sz.cy != szBitmap.cy))
		::StretchBlt(hSrcDC, 0, 0, szBitmap.cx, szBitmap.cy, hResDC, 0, 0, sz.cx, sz.cy, SRCCOPY);
	else
		::BitBlt(hSrcDC, 0, 0, szBitmap.cx, szBitmap.cy, hResDC, 0, 0, SRCCOPY);

	::SelectObject(hResDC, hOldResBitmap);
	::DeleteObject(hBitmap);
	::DeleteDC(hResDC);

	pt.y += (nMaxHeight - szBitmap.cy);

	if (bUseMask)
	{
		//Draws a bitmap with mask
		::SelectObject(hSrcDC, hOldSrcBitmap);

		CImageList		img;

		img.Create(szBitmap.cx, szBitmap.cy, g_App.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
		img.Add(CBitmap::FromHandle(hSrcBitmap), crMask);
		DrawIconFromImageList(pDC, pt, szBitmap, img, 0, FALSE);
	}
	else
	{
		//Draws a bitmap without mask
		pDC->BitBlt(pt.x, pt.y, szBitmap.cx, szBitmap.cy, CDC::FromHandle(hSrcDC), 0, 0, SRCCOPY);
		::SelectObject(hSrcDC, hOldSrcBitmap);
	}

	::DeleteObject(hSrcBitmap);
	::DeleteDC(hSrcDC);

	return szBitmap;
}

CSize CPPToolTip::DrawIcon(CDC * pDC, CPoint pt, int nMaxHeight, UINT nID, CSize szIcon, BOOL bCalculate)
{
	CSize			sz (0, 0);
	HICON			hIcon = GetIconFromResources(nID, szIcon);

	if (hIcon != NULL)
	{
		sz = GetSizeIcon(hIcon);
		if (!bCalculate)
		{
			pt.y += (nMaxHeight - sz.cy);
			pDC->DrawState(pt, sz, hIcon, DSS_NORMAL, (CBrush*)NULL);
		}
	}
	
	if (hIcon)
		::DestroyIcon(hIcon);
	
	return sz;
}

CSize CPPToolTip::DrawIconFromImageList(CDC * pDC, CPoint pt, CSize sz, CImageList & img, int nIndex /* = 0 */, BOOL bCalculate /* = TRUE */)
{
	if (img.GetSafeHandle() == NULL)
		return CSize (0, 0);

	int			nCount = img.GetImageCount();

	if (nIndex >= nCount)
		return CSize (0, 0);

	if (bCalculate)
		return sz;
	
	HICON		hIcon = img.ExtractIcon(nIndex);

	pDC->DrawState(pt, sz, hIcon, DSS_NORMAL, (CBrush*)NULL);

	if (hIcon)
		DestroyIcon(hIcon);

	return sz;
}

void CPPToolTip::DrawHorzLine(CDC * pDC, int xStart, int xEnd, int y) const
{
	CPen		pen(PS_SOLID, 1, pDC->GetTextColor());
	CPen		*penOld = pDC->SelectObject(&pen);

	pDC->MoveTo(xStart, y);
	pDC->LineTo(xEnd, y);
	pDC->SelectObject(penOld);
}

void CPPToolTip::FillGradient (	CDC * pDC, CRect rect, 
								COLORREF colorStart, COLORREF colorFinish, 
								BOOL bHorz/* = TRUE*/)
{
	// this will make 2^6 = 64 fountain steps
	int			nShift = 6;
	int			nSteps = 1 << nShift;

	for (int i = 0; i < nSteps; i++)
	{
		// do a little alpha blending
		BYTE bR = (BYTE) ((GetRValue(colorStart) * (nSteps - i) +
				GetRValue(colorFinish) * i) >> nShift);
		BYTE bG = (BYTE) ((GetGValue(colorStart) * (nSteps - i) +
				GetGValue(colorFinish) * i) >> nShift);
		BYTE bB = (BYTE) ((GetBValue(colorStart) * (nSteps - i) +
				GetBValue(colorFinish) * i) >> nShift);

		CBrush		br (RGB(bR, bG, bB));
		// then paint with the resulting color
		CRect		r2 = rect;

		if (!bHorz)
		{
			r2.top = rect.top +  ((i * rect.Height()) >> nShift);
			r2.bottom = rect.top +  (((i + 1) * rect.Height()) >> nShift);
			if (r2.Height() > 0)
				pDC->FillRect(r2, &br);
		}
		else
		{
			r2.left = rect.left + ((i * rect.Width()) >> nShift);
			r2.right = rect.left + (((i + 1) * rect.Width()) >> nShift);
			if (r2.Width() > 0)
				pDC->FillRect(r2, &br);
		}
	}
}

#ifdef PPTOOLTIP_USE_SHADE
void CPPToolTip::SetShade(CRect rect, UINT shadeID /* = 0 */, BYTE granularity /* = 8 */, 
						  BYTE coloring /* = 0 */, COLORREF color /* = 0 */)
{
	long		sXSize, sYSize, bytes, j ,i ,k ,h;
	BYTE		*iDst, *posDst;
	
	sYSize= rect.Height(); //rect.bottom-rect.top;
	sXSize= rect.Width(); //rect.right-rect.left ;

	m_dh.Create(max(1, sXSize /*-2*m_FocusRectMargin-1*/ ), 1, 8);	//create the horizontal focus bitmap
	m_dv.Create(1, max(1, sYSize /*-2*m_FocusRectMargin*/), 8);	//create the vertical focus bitmap

	m_dNormal.Create(sXSize, sYSize, 8);					//create the default bitmap

	COLORREF		hicr = m_pToolInfo.crBegin; //GetSysColor(COLOR_BTNHIGHLIGHT);	//get the button base colors
	COLORREF		midcr = m_pToolInfo.crMid;  //GetSysColor(COLOR_BTNFACE);
	COLORREF		locr = m_pToolInfo.crEnd;   //GetSysColor(COLOR_BTNSHADOW);
	long			r, g ,b;					//build the shaded palette

	for(i = 0; i < 129; i++)
	{
		r = ((128 - i) * GetRValue(locr) + i * GetRValue(midcr)) / 128;
		g = ((128 - i) * GetGValue(locr) + i * GetGValue(midcr)) / 128;
		b = ((128 - i) * GetBValue(locr) + i * GetBValue(midcr)) / 128;
		m_dNormal.SetPaletteIndex((BYTE)i, (BYTE)r, (BYTE)g, (BYTE)b);
		m_dh.SetPaletteIndex((BYTE)i, (BYTE)r, (BYTE)g, (BYTE)b);
		m_dv.SetPaletteIndex((BYTE)i, (BYTE)r, (BYTE)g, (BYTE)b);
	}
	for(i = 1; i < 129; i++)
	{
		r = ((128 - i) * GetRValue(midcr) + i * GetRValue(hicr)) / 128;
		g = ((128 - i) * GetGValue(midcr) + i * GetGValue(hicr)) / 128;
		b = ((128 - i) * GetBValue(midcr) + i * GetBValue(hicr)) / 128;
		m_dNormal.SetPaletteIndex((BYTE)(i + 127), (BYTE)r, (BYTE)g, (BYTE)b);
		m_dh.SetPaletteIndex((BYTE)(i + 127), (BYTE)r, (BYTE)g, (BYTE)b);
		m_dv.SetPaletteIndex((BYTE)(i + 127), (BYTE)r, (BYTE)g, (BYTE)b);
	}

	m_dNormal.BlendPalette(color, coloring);	//color the palette

	iDst = m_dh.GetBits();		//build the horiz. dotted focus bitmap
	j = (long)m_dh.GetWidth();
	for(i = 0; i < j; i++)
	{
//		iDst[i]=64+127*(i%2);	//soft
		iDst[i] = static_cast<BYTE>(255 * (i % 2));	//hard
	}

	iDst = m_dv.GetBits();		//build the vert. dotted focus bitmap
	j = (long)m_dv.GetHeight();
	for(i = 0; i < j; i++)
	{
//		*iDst=64+127*(i%2);		//soft
		*iDst = static_cast<BYTE>(255 * (i % 2));	//hard
		iDst += 4;
	}

	bytes = m_dNormal.GetLineWidth();
	iDst = m_dNormal.GetBits();
	posDst = iDst;

	long		a, x, y, d, xs, idxmax, idxmin;
	int			grainx2 = RAND_MAX / (max(1, 2 * granularity));

	idxmax = 255 - granularity;
	idxmin = granularity;

	switch (shadeID)
	{
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_METAL:
		m_dNormal.Clear();
		// create the strokes
		k = 40;	//stroke granularity
		for(a = 0; a < 200; a++)
		{
			x = rand() / (RAND_MAX / sXSize); //stroke postion
			y = rand() / (RAND_MAX / sYSize);	//stroke position
			xs = rand() / (RAND_MAX / min(sXSize,sYSize)) / 2; //stroke lenght
			d = rand() / (RAND_MAX / k);	//stroke color
			for(i = 0; i < xs; i++)
			{
				if (((x - i) > 0) && ((y + i) < sYSize))
					m_dNormal.SetPixelIndex(x - i, y + i, (BYTE)d);
				if (((x + i) < sXSize) && ((y - i) > 0))
					m_dNormal.SetPixelIndex(sXSize - x + i, y - i, (BYTE)d);
			}
		}
		//blend strokes with SHS_DIAGONAL
		posDst = iDst;
		a = (idxmax - idxmin - k) / 2;
		for(i = 0; i < sYSize; i++)
		{
			for(j = 0; j < sXSize; j++)
			{
				d = posDst[j] + ((a * i) / sYSize + (a * (sXSize - j)) / sXSize);
				posDst[j] = static_cast<BYTE>((BYTE)d + rand() / grainx2);
			}
			posDst += bytes;
		}

		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_HARDBUMP:	// 
		//set horizontal bump
		for(i = 0; i < sYSize; i++)
		{
			k = (255 * i / sYSize) - 127;
			k = (k * (k * k) / 128) / 128;
			k = (k * (128 - granularity * 2)) / 128 + 128;
			for(j = 0; j < sXSize; j++)
			{
				posDst[j] = static_cast<BYTE>((BYTE)k + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
		//set vertical bump
		d = min(16, sXSize / 6);	//max edge=16
		a = sYSize * sYSize / 4;
		posDst = iDst;
		for(i = 0; i < sYSize; i++)
		{
			y = i - sYSize / 2;
			for(j = 0; j < sXSize; j++)
			{
				x = j - sXSize / 2;
				xs = sXSize / 2 - d + (y * y * d) / a;
				if (x > xs)
					posDst[j] = static_cast<BYTE>(idxmin + (BYTE)(((sXSize - j) * 128) / d));
				if ((x + xs) < 0)
					posDst[j] = static_cast<BYTE>(idxmax - (BYTE)((j * 128) / d));
				posDst[j] = static_cast<BYTE>(posDst[j] + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_SOFTBUMP: //
		for(i = 0; i < sYSize; i++)
		{
			h = (255 * i / sYSize) - 127;
			for(j = 0; j < sXSize; j++)
			{
				k = (255 * (sXSize - j) / sXSize) - 127;
				k = (h * (h * h) / 128) / 128 + (k * (k * k) / 128) / 128;
				k = k * (128 - granularity) / 128 + 128;
				if (k < idxmin)
					k = idxmin;
				if (k > idxmax)
					k = idxmax;
				posDst[j] = static_cast<BYTE>((BYTE)k + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_VBUMP: // 
		for(j = 0; j < sXSize; j++)
		{
			k = (255 * (sXSize - j) / sXSize) - 127;
			k = (k * (k * k) / 128) / 128;
			k = (k * (128 - granularity)) / 128 + 128;
			for(i = 0; i < sYSize; i++)
			{
				posDst[j + i * bytes] = static_cast<BYTE>((BYTE)k + rand() / grainx2 - granularity);
			}
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_HBUMP: //
		for(i = 0; i < sYSize; i++)
		{
			k = (255 * i / sYSize) - 127;
			k = (k * (k * k) / 128) / 128;
			k = (k * (128 - granularity)) / 128 + 128;
			for(j = 0; j < sXSize; j++)
			{
				posDst[j] = static_cast<BYTE>((BYTE)k + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_DIAGSHADE:	//
		a = (idxmax - idxmin) / 2;
		for(i = 0; i < sYSize; i++)
		{
			for(j = 0; j < sXSize; j++)
			{
				posDst[j] = (BYTE)(idxmin + a * i / sYSize + a * (sXSize - j) / sXSize);
				posDst[j] = static_cast<BYTE>(posDst[j] + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_HSHADE:	//
		a = idxmax - idxmin;
		for(i = 0; i < sYSize; i++)
		{
			k = a * i / sYSize + idxmin;
			for(j = 0; j < sXSize; j++)
			{
				posDst[j] = static_cast<BYTE>((BYTE)k + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_VSHADE:	//:
		a = idxmax-idxmin;
		for(j = 0; j < sXSize; j++)
		{
			k = a * (sXSize - j) / sXSize + idxmin;
			for(i = 0; i < sYSize; i++)
			{
				posDst[j + i * bytes] = static_cast<BYTE>((BYTE)k + rand() / grainx2 - granularity);
			}
		}
		break;
//----------------------------------------------------
	case PPTOOLTIP_EFFECT_NOISE:
		for(i = 0; i < sYSize; i++)
		{
			for(j = 0; j < sXSize; j++)
			{
				posDst[j] = static_cast<BYTE>(128 + rand() / grainx2 - granularity);
			}
			posDst += bytes;
		}
	}
//----------------------------------------------------
}
#endif

HICON CPPToolTip::GetIconFromResources(UINT nID, CSize szIcon /* = CSize(0, 0) */) const
{
	// Find correct resource handle
	HINSTANCE		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nID), RT_GROUP_ICON);
	// Set icon when the mouse is IN the button
	HICON			hIcon = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nID), IMAGE_ICON, szIcon.cx, szIcon.cy, 0);

	return hIcon;
}

HBITMAP CPPToolTip::GetBitmapFromResources(UINT nID) const
{
	// Find correct resource handle
	HINSTANCE		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nID), RT_BITMAP);
	// Load bitmap
	HBITMAP			hBitmap = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nID), IMAGE_BITMAP, 0, 0, 0);

	return hBitmap;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetStyles  (public member function)
//    Sets the new styles of the control
//
//  Parameters :
//		nStyle		[in] - new style
//
//  Returns :
//		Old styles
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetStyles(DWORD nStyles, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::SetStyles()\n"));

	ModifyStyles(nStyles, ~0u, nIndexTool);
}  // End of SetStyles

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::ModifyStyles  (public member function)
//    Modify the styles of the control
//
//  Parameters :
//		nAddStyle	 [in] - The styles to add
//		nRemoveStyle [in] - The styles to remove
//
//  Returns :
//		Old styles
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::ModifyStyles(DWORD nAddStyles, DWORD nRemoveStyles, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
	if (!IsExistTool(nIndexTool))
	{
		m_nStyles &= ~nRemoveStyles;
		m_nStyles |= nAddStyles;
	}
	else
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		if (!(ti.nMask & PPTOOLTIP_MASK_STYLES))
			ti.nStyles = m_nStyles;
		ti.nStyles &= ~nRemoveStyles;
		ti.nStyles |= nAddStyles;
		ti.nMask |= PPTOOLTIP_MASK_STYLES;
		SetAtTool(nIndexTool, ti);
	}
}  // End of ModifyStyles

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetStyles (public member function)
//    Gets the current styles of the control
//
//  Parameters :
//
//  Returns :
//		Current styles
//
/////////////////////////////////////////////////////////////////////////////
DWORD CPPToolTip::GetStyles(int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::GetStyles()\n"));

	if (IsExistTool(nIndexTool))
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		if (ti.nMask & PPTOOLTIP_MASK_STYLES)
			return ti.nStyles;
	}
	return m_nStyles;
}  // End of GetStyles

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetDefaultStyles  (public member function)
//    Sets the new styles of the control
//
//  Parameters :
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetDefaultStyles(int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::SetDefaultStyles()\n"));

	SetStyles(PPTOOLTIP_BALLOON/* | PPTOOLTIP_ICON_VCENTER_ALIGN*/, nIndexTool);
}  // End of SetDefaultStyles


/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetColor (public member function)
//    Set the color
//
//  Parameters :
//		nIndex  [in] - index of the color
//		crColor [in] - new color
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetColor(int nIndex, COLORREF crColor)
{
//	TRACE (_T("CPPToolTip::SetColor(nIndex = %d)\n"), nIndex);
	
	if (nIndex >= PPTOOLTIP_MAX_COLORS)
		return;

	m_crColor [nIndex] = crColor;
}  // End of SetColor

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetColor (public member function)
//    Set the color
//
//  Parameters :
//		nIndex  [in] - index of the color
//
//  Returns :
//		Current color
//
/////////////////////////////////////////////////////////////////////////////
COLORREF CPPToolTip::GetColor(int nIndex)
{
//	TRACE (_T("CPPToolTip::GetColor(nIndex = %d)\n"), nIndex);

	if (nIndex >= PPTOOLTIP_MAX_COLORS)
		nIndex = PPTOOLTIP_COLOR_FG;

	return m_crColor [nIndex];
}  // End of GetColor

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetDefaultColors (public member function)
//    Set the color as default
//
//  Parameters :
//		None
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetDefaultColors()
{
//	TRACE (_T("CPPToolTip::SetDefaultColors\n"));
	
	SetColor(PPTOOLTIP_COLOR_0, RGB (0, 0, 0));
	SetColor(PPTOOLTIP_COLOR_1, RGB (0, 0, 128));
	SetColor(PPTOOLTIP_COLOR_2, RGB (0, 128, 0));
	SetColor(PPTOOLTIP_COLOR_3, RGB (0, 128, 128));
	SetColor(PPTOOLTIP_COLOR_4, RGB (128, 0, 0));
	SetColor(PPTOOLTIP_COLOR_5, RGB (128, 0, 128));
	SetColor(PPTOOLTIP_COLOR_6, RGB (128, 128, 0));
	SetColor(PPTOOLTIP_COLOR_7, RGB (128, 128, 128));
	SetColor(PPTOOLTIP_COLOR_8, RGB (0, 0, 255));
	SetColor(PPTOOLTIP_COLOR_9, RGB (0, 255, 0));
	SetColor(PPTOOLTIP_COLOR_10, RGB (0, 255, 255));
	SetColor(PPTOOLTIP_COLOR_11, RGB (255, 0, 0));
	SetColor(PPTOOLTIP_COLOR_12, RGB (255, 0, 255));
	SetColor(PPTOOLTIP_COLOR_13, RGB (255, 255, 0));
	SetColor(PPTOOLTIP_COLOR_14, RGB (192, 192, 192));
	SetColor(PPTOOLTIP_COLOR_15, RGB (255, 255, 255));
	SetColor(PPTOOLTIP_COLOR_FG, ::GetSysColor(COLOR_INFOTEXT));
	SetColor(PPTOOLTIP_COLOR_BK_BEGIN, ::GetSysColor(COLOR_INFOBK));
	SetColor(PPTOOLTIP_COLOR_BK_MID, ::GetSysColor(COLOR_INFOBK));
	SetColor(PPTOOLTIP_COLOR_BK_END, ::GetSysColor(COLOR_INFOBK));
	SetColor(PPTOOLTIP_COLOR_LINK, RGB(0, 0, 238));
	SetColor(PPTOOLTIP_COLOR_VISITED, RGB(85, 26, 139));
	SetColor(PPTOOLTIP_COLOR_HOVER, RGB(255, 0, 0));
	SetColor(PPTOOLTIP_COLOR_SHADOW, ::GetSysColor(COLOR_3DSHADOW));
	SetColor(PPTOOLTIP_COLOR_BORDER, ::GetSysColor(COLOR_INFOTEXT));
}  // End of SetDefaultColors

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetGradientColors (public member function)
//    Set the gradient colors
//
//  Parameters :
//		crStart [in] - start color
//		crEnd [in] - end color
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetGradientColors(COLORREF crBegin, COLORREF crMid, COLORREF crEnd, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE (_T("CPPToolTip::SetGradientColors\n"));
	if (!IsExistTool(nIndexTool))
	{
		SetColor(PPTOOLTIP_COLOR_BK_BEGIN, crBegin);
		SetColor(PPTOOLTIP_COLOR_BK_MID, crMid);
		SetColor(PPTOOLTIP_COLOR_BK_END, crEnd);
	}
	else
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		ti.crBegin = crBegin;
		ti.crMid = crMid;
		ti.crEnd = crEnd;
		ti.nMask |= PPTOOLTIP_MASK_COLORS;
		SetAtTool(nIndexTool, ti);
	}
} // End of SetGradientColors

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetGradientColors (public member function)
//    Set the gradient colors
//
//  Parameters :
//		None
//
//  Returns :
//		crStart [out] - start color
//		crEnd [out] - end color
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::GetGradientColors(COLORREF & crBegin, COLORREF & crMid, COLORREF & crEnd, int nIndexTool /* = -1 */)
{
//	TRACE (_T("CPPToolTip::GetGradientColors\n"));
	if (IsExistTool(nIndexTool))
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		if (ti.nMask & PPTOOLTIP_MASK_COLORS)
		{
			crBegin = ti.crBegin;
			crMid = ti.crMid;
			crEnd = ti.crEnd;
			return;
		}
	}
	crBegin = GetColor(PPTOOLTIP_COLOR_BK_BEGIN);
	crMid = GetColor(PPTOOLTIP_COLOR_BK_MID);
	crEnd = GetColor(PPTOOLTIP_COLOR_BK_END);
} // End of GetGradientColors

void CPPToolTip::SetMaskTool(int nIndexTool, UINT nMask /* = 0 */)
{
	ModifyMaskTool(nIndexTool, nMask, ~0u);
}

void CPPToolTip::ModifyMaskTool(int nIndexTool, UINT nAddMask, UINT nRemoveMask)
{
	if (!IsExistTool(nIndexTool))
		return;

	PPTOOLTIP_INFO		ti;

	GetTool(nIndexTool, ti);
	ti.nMask &= ~nRemoveMask;
	ti.nMask |= nAddMask;
	SetAtTool(nIndexTool, ti);
}

UINT CPPToolTip::GetMaskTool(int nIndexTool)
{
	if (!IsExistTool(nIndexTool))
		return 0;

	PPTOOLTIP_INFO		ti;

	GetTool(nIndexTool, ti);
	return ti.nMask;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetEffectBk (public member function)
//    sets the background's effect
//
//  Parameters :
//		nEffect	[in]  - the background's effect 
//
//  Returns :
//		None 
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetEffectBk(UINT nEffect, BYTE nGranularity /* = 2 */, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE (_T("CPPToolTip::SetEffectBk\n"));
	
	if (!IsExistTool(nIndexTool))
	{
		m_nEffect = nEffect;
		m_nGranularity = nGranularity;
	}
	else
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		ti.nEffect = nEffect;
		ti.nGranularity = nGranularity;
		ti.nMask |= PPTOOLTIP_MASK_EFFECT;
		SetAtTool(nIndexTool, ti);
	}
} // End SetEffectBk

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetEffectBk (public member function)
//    gets the background's effect
//
//  Parameters :
//		None 
//
//  Returns :
//		the background's effect 
//
/////////////////////////////////////////////////////////////////////////////
UINT CPPToolTip::GetEffectBk(int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
	BYTE nGranularity = 0;
	
	return GetEffectBk(nGranularity, nIndexTool);
} // End SetEffectBk

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetEffectBk (public member function)
//    gets the background's effect
//
//  Parameters :
//		nGranularity	[out] - effect's granularity
//
//  Returns :
//		the background's effect 
//
/////////////////////////////////////////////////////////////////////////////
UINT CPPToolTip::GetEffectBk(BYTE & nGranularity, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE (_T("CPPToolTip::GetEffectBk\n"));
	
	if (IsExistTool(nIndexTool))
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		if (ti.nMask & PPTOOLTIP_MASK_EFFECT)
		{
			nGranularity = ti.nGranularity;
			return ti.nEffect;
		}
	}
	nGranularity = static_cast<BYTE>(m_nGranularity);
	return m_nEffect;
} // End SetEffectBk

/////////////////////////////////////////////////////////////////////
// CPPToolTip::SetNotify
// This function sets or removes the notification messages from the control before display.
//
// Parameters:
//	bParentNotify [in] - If TRUE the control will be send the notification 
//				   to parent window
//				   Else the notification will not send
///////////////////////////////////////////////////////////////////////
void CPPToolTip::SetNotify(BOOL bParentNotify /* = TRUE */)
{
	HWND		hWnd = NULL;

	if (bParentNotify)
		hWnd = m_pParentWnd->GetSafeHwnd();

	SetNotify(hWnd);
} //End SetNotify

/////////////////////////////////////////////////////////////////////
// CPPToolTip::SetNotify
// This function sets or removes the notification messages from the control before display.
//
// Parameters:
//	hWnd [in] -    If non-NULL the control will be send the notification 
//				   to specified window
//				   Else the notification will not send
///////////////////////////////////////////////////////////////////////
void CPPToolTip::SetNotify(HWND hWnd)
{
//	TRACE(_T("CPPToolTip::SetNotify\n"));

	m_hNotifyWnd = hWnd;
} //End SetNotify

/////////////////////////////////////////////////////////////////////
// CPPToolTip::GetNotify
// This function determines will be send the notification messages from 
// the control or not before display.
//
// Return value:
//	TRUE if the control will be notified the specified window
///////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::GetNotify()
{
//	TRACE(_T("CPPToolTip::GetNotify\n"));

	return (m_hNotifyWnd != NULL);
}  //End GetNotify

/////////////////////////////////////////////////////////////////////
// CPPToolTip::SetDelayTime
// Call this function to set the delay time for a tool tip control. 
// The delay time is the length of time the cursor must remain on a tool 
// before the tool tip window appears. The default delay time is 500 milliseconds.
//
// Parameters:
//   dwDuration	[in]  - Flag that specifies which duration value will be retrieved. 
//						This parameter can be one of the following values:
//			
//			TTDT_AUTOPOP  - Retrieve the length of time the tool tip 
//							window remains visible if the pointer is 
//							stationary within a tool's bounding rectangle. 
//			TTDT_INITIAL  - Retrieve the length of time the pointer 
//							must remain stationary within a tool's bounding 
//							rectangle before the tool tip window appears. 
//			TTDT_RESHOW   - Retrieve the length of time it takes for 
//							subsequent tool tip windows to appear as the 
//							pointer moves from one tool to another.
//	 nTime [in] - The specified delay time, in milliseconds.
//
/////////////////////////////////////////////////////////////////////
void CPPToolTip::SetDelayTime(DWORD dwDuration, UINT nTime)
{
	switch (dwDuration)
	{
	case TTDT_AUTOPOP:
		m_nTimeAutoPop = nTime;
		break;
	case TTDT_INITIAL :
		m_nTimeInitial = nTime;
		break;
//	case TTDT_RESHOW:
//		m_nTimeReShow = nTime;
//		break;
	}
} // End SetDelayTime

/////////////////////////////////////////////////////////////////////
// CPPToolTip::GetDelayTime
// Retrieves the initial, pop-up, and reshow durations currently set 
// for a CPPToolTip control
//
// Parameters:
//   dwDuration	[in] - Flag that specifies which duration value will 
//					   be retrieved. This parameter can be one of the 
//					   following values:
//			
//			TTDT_AUTOPOP  - Retrieve the length of time the tool tip 
//							window remains visible if the pointer is 
//							stationary within a tool's bounding rectangle. 
//			TTDT_INITIAL  - Retrieve the length of time the pointer 
//							must remain stationary within a tool's bounding 
//							rectangle before the tool tip window appears. 
//			TTDT_RESHOW   - Retrieve the length of time it takes for 
//							subsequent tool tip windows to appear as the 
//							pointer moves from one tool to another. 
//
// Return value:
//	The specified delay time, in milliseconds
///////////////////////////////////////////////////////////////////////
UINT CPPToolTip::GetDelayTime(DWORD dwDuration) const
{
	UINT		nTime = 0;

	switch (dwDuration)
	{
	case TTDT_AUTOPOP:
		nTime = m_nTimeAutoPop;
		break;
	case TTDT_INITIAL:
		nTime = m_nTimeInitial;
		break;
//	case TTDT_RESHOW:
//		nTime = m_nTimeReShow;
//		break;
	}

	return nTime;
} // End GetDelayTime

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetSize (public member function)
//    Sets the specified size
//
//  Parameters :
//		nSizeIndex  [in] - index of the size
//		nValue [in] - size's value
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetSize(int nSizeIndex, UINT nValue)
{
//	TRACE(_T("CPPToolTip::SetSize(nSizeIndex = %d, nValue = %d)\n"), nSizeIndex, nValue);
	if (nSizeIndex >= PPTTSZ_MAX_SIZES)
		return;

	m_nSizes [nSizeIndex] = nValue;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetSize (public member function)
//    Gets the specified size
//
//  Parameters :
//		nSizeIndex  [in] - index of the size
//
//  Returns :
//		size's value
//
/////////////////////////////////////////////////////////////////////////////
UINT CPPToolTip::GetSize(int nSizeIndex)
{
//	TRACE(_T("CPPToolTip::GetSize(nSizeIndex = %d)\n"), nSizeIndex);
	if (nSizeIndex >= PPTTSZ_MAX_SIZES)
		return 0;

	return m_nSizes [nSizeIndex];
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetDefaultSizes (public member function)
//    Sets all sizes to default values
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetDefaultSizes(BOOL bBalloonSize /* = TRUE */)
{
//	TRACE(_T("CPPToolTip::SetDefaultSizes()\n"));

	if (bBalloonSize)
	{
		SetSize(PPTTSZ_ROUNDED_CX, 16);
		SetSize(PPTTSZ_ROUNDED_CY, 16);
		SetSize(PPTTSZ_MARGIN_CX, 12);
		SetSize(PPTTSZ_MARGIN_CY, 12);
		SetSize(PPTTSZ_SHADOW_CX, 4);
		SetSize(PPTTSZ_SHADOW_CY, 4);
		SetSize(PPTTSZ_WIDTH_ANCHOR, 12);
		SetSize(PPTTSZ_HEIGHT_ANCHOR, 16);
		SetSize(PPTTSZ_MARGIN_ANCHOR, 16);
		SetSize(PPTTSZ_BORDER_CX, 1);
		SetSize(PPTTSZ_BORDER_CY, 1);
	}
	else
	{
		SetSize(PPTTSZ_ROUNDED_CX, 0);
		SetSize(PPTTSZ_ROUNDED_CY, 0);
		SetSize(PPTTSZ_MARGIN_CX, 3);
		SetSize(PPTTSZ_MARGIN_CY, 1);
		SetSize(PPTTSZ_SHADOW_CX, 0);
		SetSize(PPTTSZ_SHADOW_CY, 0);
		SetSize(PPTTSZ_WIDTH_ANCHOR, 0);
		SetSize(PPTTSZ_HEIGHT_ANCHOR, 0);
		SetSize(PPTTSZ_MARGIN_ANCHOR, 0);
		SetSize(PPTTSZ_BORDER_CX, 1);
		SetSize(PPTTSZ_BORDER_CY, 1);
	}
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetDirection (public member function)
//    Sets the tooltip's direction
//
//  Parameters :
//		nDirection  [in] - direction of the tooltip
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetDirection(UINT nDirection /* = PPTOOLTIP_RIGHT_BOTTOM */, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::SetDirection(nDirection = %d)\n"), nDirection);

	if (nDirection >= PPTOOLTIP_MAX_DIRECTIONS)
		return;

	if (!IsExistTool(nIndexTool))
	{
		m_nDirection = nDirection;
	}
	else
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		ti.nDirection = nDirection;
		ti.nMask |= PPTOOLTIP_MASK_DIRECTION;
		SetAtTool(nIndexTool, ti);
	}
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetDirection (public member function)
//    Gets the tooltip's direction
//
//  Returns :
//		tooltip's direction
//
/////////////////////////////////////////////////////////////////////////////
UINT CPPToolTip::GetDirection(int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::GetDirection()\n"));

	if (IsExistTool(nIndexTool))
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		if (ti.nMask & PPTOOLTIP_MASK_DIRECTION)
			return ti.nDirection;
	}
	return m_nDirection;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetBehaviour (public member function)
//    Sets the tooltip's direction
//
//  Parameters :
//		nBehaviour  [in] - direction of the tooltip
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////

void CPPToolTip::SetBehaviour(UINT nBehaviour /* = 0 */, int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::SetBehaviour(nBehaviour = 0x%X)\n"), nBehaviour);

	if (IsExistTool(nIndexTool))
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		ti.nBehaviour = nBehaviour;
		ti.nMask |= PPTOOLTIP_MASK_BEHAVIOUR;
		SetAtTool(nIndexTool, ti);
	}
	else m_nBehaviour = nBehaviour;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetBehaviour (public member function)
//    Gets the tooltip's direction
//
//  Returns :
//		tooltip's direction
//
/////////////////////////////////////////////////////////////////////////////
UINT CPPToolTip::GetBehaviour(int nIndexTool /* = PPTOOLTIP_TOOL_NOEXIST */)
{
//	TRACE(_T("CPPToolTip::GetBehaviour()\n"));

	if (IsExistTool(nIndexTool))
	{
		PPTOOLTIP_INFO		ti;

		GetTool(nIndexTool, ti);
		if (ti.nMask & PPTOOLTIP_MASK_BEHAVIOUR)
			return ti.nBehaviour;
	}
	return m_nBehaviour;
}

/*
/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetMultipleShow (public member function)
//    Sets the multiple show for the tooltip
//
//  Parameters :
//		bMultiple	[in] - 
//		pWnd		[in] - the pointer to the window
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetMultipleShow(BOOL bMultiple  = TRUE , CWnd * pWnd  = NULL )
{
	if (bMultiple)
		ModifyStyles(PPTOOLTIP_MULTIPLE_SHOW, 0, pWnd);
	else
		ModifyStyles(0, PPTOOLTIP_MULTIPLE_SHOW, pWnd);
} // End of SetMultipleShow

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::IsMultipleShow (public member function)
//    
//
//  Parameters :
//		pWnd		[in] - the pointer to the window
//
//  Returns :
//		TRUE if for window sets the multiple show
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::IsMultipleShow(CWnd * pWnd  = NULL )
{
	return (BOOL)(PPTOOLTIP_MULTIPLE_SHOW & GetStyles(pWnd));
} // End of IsMultipleShow
*/

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetFont  (public member function)
//    Sets the new font to the control
//
//  Parameters :
//		font		[in] - new font
//
//  Returns :
//		Nonzero if successful; otherwise 0.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::SetFont(CFont & font)
{
//	TRACE(_T("CPPToolTip::SetFont()\n"));

	LOGFONT			lf;

	font.GetLogFont(&lf);

	return SetFont(&lf);
}  // End of SetFont

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetFont  (public member function)
//    Sets the new font to the control
//
//  Parameters :
//		lf			[in] - structure LOGFONT for the new font
//
//  Returns :
//		Nonzero if successful; otherwise 0.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::SetFont(LPLOGFONT lf)
{
//	TRACE(_T("CPPToolTip::SetFont()\n"));

//	m_font.DeleteObject();

	// Store font as the global default
	memcpy2(&m_LogFont, lf, sizeof(LOGFONT));

	return TRUE; //m_font.CreateFontIndirect(lf);
}  // End of SetFont

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetFont  (public member function)
//    Sets the new font to the control
//
//  Parameters :
//		font		[in] - new font
//
//  Returns :
//		Nonzero if successful; otherwise 0.
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::SetFont(LPCTSTR lpszFaceName, int nSizePoints /* = 8 */,
									BOOL bUnderline /* = FALSE */, BOOL bBold /* = FALSE */,
									BOOL bStrikeOut /* = FALSE */, BOOL bItalic /* = FALSE */)
{
//	TRACE(_T("CPPToolTip::SetFont()\n"));

	CDC				*pDC = GetDC();
	LOGFONT			lf;

	memzero(&lf, sizeof(LOGFONT));

	_tcscpy(lf.lfFaceName, lpszFaceName);
	lf.lfHeight = -MulDiv (nSizePoints, GetDeviceCaps (pDC->m_hDC, LOGPIXELSY), 72);
	lf.lfUnderline = static_cast<BYTE>(bUnderline);
	lf.lfWeight = bBold ? FW_BOLD : FW_NORMAL;
	lf.lfStrikeOut = static_cast<BYTE>(bStrikeOut);
	lf.lfItalic = static_cast<BYTE>(bItalic);

	if (pDC)
		ReleaseDC(pDC);

	return SetFont(&lf);
}  // End of SetFont

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetDefaultFonts  (public member function)
//    Sets default fonts of the control
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetDefaultFont()
{
//	TRACE(_T("CPPToolTip::SetDefaultFont()\n"));
	LOGFONT	SysFont;

	GetSystemToolTipFont(&SysFont);
	SetFont(&SysFont);
} // End of SetDefaultFonts

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetFont  (public member function)
//    Sets the new font to the control
//
//  Parameters :
//		font		[out] - the current font
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::GetFont(CFont & font)
{
	font.CreateFontIndirect(&m_LogFont);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetFont  (public member function)
//    Sets the new font to the control
//
//  Parameters :
//		lf		[out] - the current font's structure
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::GetFont(LPLOGFONT lf)
{
	memcpy2(lf, &m_LogFont, sizeof(LOGFONT));
}

///////////////////////////////////////////////////////////////////
//
//
// Parameters:
//		pt		[in] - the mouse's coordinates in client coordinates
//
// Return values:
//      CWnd*	[out] - the pointer to the window under the mouse. Returns
//                      NULL if under the mouse no control.
///////////////////////////////////////////////////////////////////
HWND CPPToolTip::GetWndFromPoint(CPoint & pt, BOOL bGetDisabled /* = TRUE */) const
{
	ASSERT(m_pParentWnd);
	
    CPoint			point = pt;

	// Find the window under the cursor
    m_pParentWnd->ClientToScreen(&point);
    HWND			hWnd = ::WindowFromPoint(point);
	
	// WindowFromPoint misses disabled windows and such - go for a more
    // comprehensive search in this case.
	UINT			nFlags = CWP_ALL;

	if (!bGetDisabled)
		nFlags |= CWP_SKIPDISABLED;
    if (hWnd == m_pParentWnd->GetSafeHwnd())
        hWnd = m_pParentWnd->ChildWindowFromPoint(pt, nFlags)->GetSafeHwnd();

    return hWnd;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::AddTool (public member function)
//    adds or updates the tool
//
//  Parameters :
//		pWnd	[in] - the pointer to the window
//		nIdText  [in] - the tooltip's text id 
//		nIdIcon  [in] - the icon's identificator 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::AddTool(CWnd * pWnd, UINT nIdText, HICON hIcon /* = NULL */,
						 LPCRECT lpRectTool /* = NULL */, UINT nIDTool /* = 0 */)
{
	CString			str;

	str.LoadString(nIdText);
	AddTool(pWnd, str, hIcon, lpRectTool, nIDTool);
} // End AddTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::AddTool (public member function)
//    adds or updates the tool
//
//  Parameters :
//		pWnd	[in] - the pointer to the window
//		nIdText  [in] - the tooltip's text id 
//		nIdIcon  [in] - the icon's identificator 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::AddTool(CWnd * pWnd, UINT nIdText, UINT nIdIcon, CSize szIcon /* = CSize(0, 0) */,
						 LPCRECT lpRectTool /* = NULL */, UINT nIDTool /* = 0 */)
{
	CString			str;

	str.LoadString(nIdText);
	AddTool(pWnd, str, nIdIcon, szIcon, lpRectTool, nIDTool);
} // End AddTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::AddTool (public member function)
//    adds or updates the tool
//
//  Parameters :
//		pWnd	[in] - the pointer to the window
//		sTooltipText [in] - the tooltip's text 
//		nIdIcon  [in] - the icon's identificator 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::AddTool(CWnd *pWnd, const TCHAR *pcTooltipText, UINT nIdIcon, CSize szIcon /* = CSize(0, 0) */,
						 LPCRECT lpRectTool /* = NULL */, UINT nIDTool /* = 0 */)
{
	HICON			hIcon	= GetIconFromResources(nIdIcon, szIcon);

	AddTool(pWnd, pcTooltipText, hIcon, lpRectTool, nIDTool);
} // End AddTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::AddTool (public member function)
//    adds or updates the tool
//
//  Parameters :
//		pWnd	[in] - the pointer to the window
//		sTooltipText [in] - the tooltip's text 
//		hIcon   [in] - the icon's handle 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::AddTool(CWnd *pWnd, const TCHAR *pcTooltipText, HICON hIcon /* = NULL */,
						 LPCRECT lpRectTool /* = NULL */, UINT nIDTool /* = 0 */)
{
	// Store the tool information
	PPTOOLTIP_INFO		ti;

	ti.hWnd = pWnd->GetSafeHwnd();
	ti.nIDTool = nIDTool;
	ti.hIcon = hIcon;
	ti.sTooltip = pcTooltipText;
	ti.nMask = 0; //All values as default

	if (lpRectTool)
		ti.rectBounds = lpRectTool;
	else
		ti.rectBounds.SetRectEmpty();

	AddTool(ti);
} // End AddTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::AddTool (public member function)
//    adds or updates the tool
//
//  Parameters :
//		ti		[in] - the tooltip's structure 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::AddTool(const PPTOOLTIP_INFO &ti)
{
	ASSERT (ti.hWnd);
//	TRACE (_T("CPPToolTip::AddTool = 0x%X\n"), ti.hWnd); 
	// Get bounding region for tooltip info 
/*
    if (ti.rectBounds.IsRectEmpty()) 
    {  
		CRect rect; 
		CWnd::FromHandle(ti.hWnd)->GetClientRect(&rect); 
		//m_pParentWnd->ScreenToClient(rect); 
		ti.rectBounds = rect; 
    } 
*/
	int nIndexTool = FindTool(CWnd::FromHandle(ti.hWnd), ti.rectBounds);

	if (!IsExistTool(nIndexTool))
		m_arrTools.Add(ti);
	else
		m_arrTools.SetAt(nIndexTool, ti);
} // End AddTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindTool (public member function)
//    searches the tool under cursor point
//
//  Parameters :
//		pt	[in] - cursor point in client coordinates
//
//  Returns :
//		< 0  = Not available tool
//      >= 0 = Index of the found tool
//
/////////////////////////////////////////////////////////////////////////////
int CPPToolTip::FindTool(CPoint & pt) 
{ 
	HWND				hWnd = GetWndFromPoint(pt, m_nStyles & PPTOOLTIP_SHOW_DISABLED); 
	PPTOOLTIP_INFO		pToolInfo;  
	CPoint				ptClient;  

	// Find the window under the cursor 
    m_pParentWnd->ClientToScreen(&pt); 
    for (int i = 0; i < m_arrTools.GetSize(); i++) 
    { 
        pToolInfo = m_arrTools.GetAt(i); 
        if (hWnd == pToolInfo.hWnd)  
		{ 
			ptClient = pt; 
			::ScreenToClient(hWnd, &ptClient); 
  			if (pToolInfo.rectBounds.PtInRect(ptClient) || pToolInfo.rectBounds.IsRectEmpty()) 
			{
				return i;  
			}
		}
	}  
	return PPTOOLTIP_TOOL_NOEXIST;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindTool (public member function)
//    searches the tool with window's pointer and rectangle
//
//  Parameters :
//		pWnd	[in] - the pointer to the window
//		lpRect	[in] - rectangle of the hot area. Or NULL for any rectangle
//
//  Returns :
//		< 0  = Not available tool
//      >= 0 = Index of the found tool
//
/////////////////////////////////////////////////////////////////////////////
int CPPToolTip::FindTool(CWnd * pWnd, LPCRECT lpRect /* = NULL */)
{
	HWND				hWnd = pWnd->GetSafeHwnd();
	PPTOOLTIP_INFO		pToolInfo;

	for (int i = 0; i < m_arrTools.GetSize(); i++)
	{
		pToolInfo = m_arrTools.GetAt(i);

		if (hWnd == pToolInfo.hWnd) 
		{
			if ((NULL == lpRect) || (lpRect == pToolInfo.rectBounds))
				return i;
		}
	}

	return PPTOOLTIP_TOOL_NOEXIST;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindTool (public member function)
//    searches the tool with id
//
//  Parameters :
//		nIDTool	[in] - id of the window
//
//  Returns :
//		< 0  = Not available tool
//      >= 0 = Index of the found tool
//
/////////////////////////////////////////////////////////////////////////////
int CPPToolTip::FindTool(UINT nIDTool)
{
	PPTOOLTIP_INFO		pToolInfo;

	for (int i = 0; i < m_arrTools.GetSize(); i++)
	{
		pToolInfo = m_arrTools.GetAt(i);

		if (nIDTool == pToolInfo.nIDTool)
			return i;
	}
	return PPTOOLTIP_TOOL_NOEXIST;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetTool (public member function)
//    gets the tooltip's info
//
//  Parameters :
//		nIndexTool	[in]  - the index of the tool
//		ti		[out] - the tooltip's structure 
//
//  Returns :
//		FALSE - tool not found
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::GetTool(int nIndexTool, PPTOOLTIP_INFO & ti)
{
	if (!IsExistTool(nIndexTool))
		return FALSE;
	ti = m_arrTools.GetAt(nIndexTool);
	return TRUE;
} // End GetTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::RemoveTool (public member function)
//    removes the tool
//
//  Parameters :
//		pWnd	[in]  - the pointer to the window
//
//  Returns :
//		None 
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::RemoveTool(int nIndexTool)
{
//	TRACE (_T("CPPToolTip::RemoveTool\n"));

	if (!IsExistTool(nIndexTool))
		return FALSE;
	
	m_arrTools.RemoveAt(nIndexTool);

	return TRUE;
} // End RemoveTool

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::RemoveAllTools (public member function)
//    removes the tool
//
//  Parameters :
//		None
//
//  Returns :
//		None 
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::RemoveAllTools()
{
//	TRACE (_T("CPPToolTip::RemoveAllTools\n"));
	
	m_arrTools.RemoveAll();
} // End RemoveAllTools

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::IsExistTool (public member function)
//    removes the tool
//
//  Parameters :
//		nIndexTool	[in]  - the index of the tool
//
//  Returns :
//		TRUE - the tool does exist
//
/////////////////////////////////////////////////////////////////////////////
BOOL CPPToolTip::IsExistTool(int nIndexTool)
{
	return (BOOL)((nIndexTool < m_arrTools.GetSize()) && (nIndexTool >= 0));
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetAtTool (public member function)
//    adds or updates the tool
//
//  Parameters :
//		nIndexTool	[in] - the index of the tool
//		ti		[in] - the tooltip's structure 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetAtTool(int nIndexTool, PPTOOLTIP_INFO & ti)
{
	if (!IsExistTool(nIndexTool))
		return;
	m_arrTools.SetAt(nIndexTool, ti);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::ShowHelpTooltip (public member function)
//    shows the tooltip as help window
//
//  Parameters :
//		pt	[in] - the point of the tooltip's anchor in client coordinates
//		nIdText  [in] - the tooltip's text id 
//		nIdIcon  [in] - the icon's identificator 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::ShowHelpTooltip(CPoint & pt, UINT nIdText, HICON hIcon /* = NULL */)
{
	CString			str;

    str.LoadString(nIdText);
	ShowHelpTooltip(pt, str, hIcon);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::ShowHelpTooltip (public member function)
//    shows the tooltip as help window
//
//  Parameters :
//		pt	[in] - the point of the tooltip's anchor in client coordinates
//		nIdText  [in] - the tooltip's text id 
//		nIdIcon  [in] - the icon's identificator 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::ShowHelpTooltip(CPoint & pt, UINT nIdText, UINT nIdIcon)
{
	CString			str;

    str.LoadString(nIdText);
	ShowHelpTooltip(pt, str, nIdIcon);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::ShowHelpTooltip (public member function)
//    shows the tooltip as help window
//
//  Parameters :
//		pt	[in] - the point of the tooltip's anchor in client coordinates
//		sTooltipText [in] - the tooltip's text 
//		nIdIcon  [in] - the icon's identificator 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::ShowHelpTooltip(CPoint & pt, CString sTooltipText, UINT nIdIcon)
{
	HICON			hIcon	= GetIconFromResources(nIdIcon);

	ShowHelpTooltip(pt, sTooltipText, hIcon);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::ShowHelpTooltip (public member function)
//    shows the tooltip as help window
//
//  Parameters :
//		pt	[in] - the point of the tooltip's anchor in client coordinates
//		sTooltipText [in] - the tooltip's text 
//		hIcon   [in] - the icon's handle 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::ShowHelpTooltip(CPoint & pt, CString sTooltipText, HICON hIcon /* = NULL */)
{
	PPTOOLTIP_INFO		ti;

	ti.hWnd = m_pParentWnd->GetSafeHwnd();
	ti.hIcon = hIcon;
	ti.sTooltip = sTooltipText;
	ti.nMask = 0; //All values as default
	ShowHelpTooltip(pt, ti);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::ShowHelpTooltip (public member function)
//    shows the tooltip as help window
//
//  Parameters :
//		pt		[in] - the point of the tooltip's anchor in client coordinates
//		ti		[in] - the tooltip's structure 
//
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::ShowHelpTooltip(CPoint & pt, PPTOOLTIP_INFO & ti)
{
//	TRACE(_T("ShowHelpTooltip()\n"));
	m_nIndexDisplayWnd = PPTOOLTIP_TOOL_NOEXIST;
	m_nIndexCurrentWnd = PPTOOLTIP_TOOL_HELPER;
	m_pToolInfo = ti;

	m_ptOriginal = pt;
	m_pParentWnd->ClientToScreen(&m_ptOriginal);
	
	//Start the show timer
	OnTimer(PPTOOLTIP_SHOW);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetImageList (public member function)
//    sets the image list to tooltip
//
//  Parameters :
//		nIdBitmap	[in] - Resource IDs of the bitmap to be associated with the image list
//		cx			[in] - Dimensions of each image, in pixels.
//		cy			[in] - Dimensions of each image, in pixels.
//		nCount		[in] - Number of images that the image list initially contains.
//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the 
//						   specified bitmap is changed to black, and the corresponding 
//						   bit in the mask is set to one.
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetImageList(UINT nIdBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)
{
	// Load bitmap
	HBITMAP			hBitmap = GetBitmapFromResources(nIdBitmap);

	SetImageList(hBitmap, cx, cy, nCount, crMask);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::SetImageList (public member function)
//    sets the image list to tooltip
//
//  Parameters :
//		hBitmap		[in] - Handle of the bitmap to be associated with the image list
//		cx			[in] - Dimensions of each image, in pixels.
//		cy			[in] - Dimensions of each image, in pixels.
//		nCount		[in] - Number of images that the image list initially contains.
//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the 
//						   specified bitmap is changed to black, and the corresponding 
//						   bit in the mask is set to one.
//  Returns :
//		None
//
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::SetImageList(HBITMAP hBitmap, int cx, int cy, int nCount, COLORREF crMask /* = RGB(255, 0, 255) */)
{
	if (m_imgTooltip.m_hImageList != NULL)
		m_imgTooltip.DeleteImageList();

	m_imgTooltip.Create(cx, cy, g_App.m_iDfltImageListColorFlags | ILC_MASK, nCount, 1);
	m_imgTooltip.Add(CBitmap::FromHandle(hBitmap), crMask);

	m_szImage = CSize(cx, cy);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::GetImageList (public member function)
//    gets the image list from tooltip
//
//  Parameters :
//		sz		   [out] - Dimensions of each image, in pixels.
//  Returns :
//		A pointer to a CImageList object
//
/////////////////////////////////////////////////////////////////////////////
CImageList * CPPToolTip::GetImageList(CSize & sz)
{
	sz = m_szImage;
	return &m_imgTooltip;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::AddNameOfResource (public member function)
//    Associates the resource name with him ID
//
//  Parameters :
//		sName		[in] - A resource name in format string of the tooltip
//		nID			[in] - A resource ID associated with name.
//		nTypeRes	[in] - A resource type:
//							TYPE_RES_ICON - a resource is a icon
//							TYPE_RES_BITMAP - a resource is a bitmap
//							TYPE_RES_MASK_BITMAP - a resource is a transparent bitmap
//		crMask		[in] - Color used to generate a mask. Each pixel of this color in the 
//						   specified bitmap is changed to black, and the corresponding 
//						   bit in the mask is set to one.
//  Returns :
//		None
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::AddNameOfResource(CString sName, UINT nID, BYTE nTypeRes /* = TYPE_RES_TRAN_BITMAP */, COLORREF crMask /* = RGB(255, 0, 255) */)
{
	if (sName.IsEmpty() || (nID == 0) || (nTypeRes >= MAX_TYPES_RES))
		return;
	
	PPTOOLTIP_NAME_RES		nr;

	nr.sName = sName;
	nr.nID = nID;
	nr.nTypeRes = nTypeRes;
	nr.crMask = crMask;

	m_arrNameRes.Add(nr);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindIdOfResource (public member function)
//    Search the ID resource by his name
//
//  Parameters :
//		sName		[in] - A resource name in format string of the tooltip
//  Returns :
//		The array's index with ID resource associated with name or -1 if ID not found
/////////////////////////////////////////////////////////////////////////////
int CPPToolTip::FindIdOfResource(const CString &strName)
{
	PPTOOLTIP_NAME_RES		nr;

	for (int i = 0; i < m_arrNameRes.GetSize(); i++)
	{
		nr = m_arrNameRes.GetAt(i);
		if (strName.CompareNoCase(nr.sName) == 0)
			return i;
	}
	return -1;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindIdOfResource (public member function)
//    Search the resource name by his ID
//
//  Parameters :
//		nID		[in] - A ID resource
//  Returns :
//		The array's index with resource name associated with ID or -1 if name not found
/////////////////////////////////////////////////////////////////////////////
int CPPToolTip::FindNameOfResource(UINT nID)
{
	PPTOOLTIP_NAME_RES		nr;

	for (int i = 0; i < m_arrNameRes.GetSize(); i++)
	{
		nr = m_arrNameRes.GetAt(i);
		if (nr.nID == nID)
			return i;
	}
	return -1;
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindIdOfResource (public member function)
//    Removes resource name by index of the array
//
//  Parameters :
//		nIndex		[in] - A The index of the resource name in the array
//  Returns :
//		None
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::RemoveNameOfResource(int nIndex)
{
	if (nIndex < m_arrNameRes.GetSize())
		m_arrNameRes.RemoveAt(nIndex);
}

/////////////////////////////////////////////////////////////////////////////
//  CPPToolTip::FindIdOfResource (public member function)
//    Removes all resource names from the array
/////////////////////////////////////////////////////////////////////////////
void CPPToolTip::RemoveAllNamesOfResource()
{
	m_arrNameRes.RemoveAll();
}
@


1.55
log
@Simplified GetSystemToolTipFont; Suppressed compiler warnings; Formatting.
@
text
@d3168 1
a3168 1
void CPPToolTip::AddTool(CWnd * pWnd, CString sTooltipText, UINT nIdIcon, CSize szIcon /* = CSize(0, 0) */,
d3171 1
a3171 1
	HICON			hIcon	= GetIconFromResources (nIdIcon, szIcon);
d3173 1
a3173 1
	AddTool(pWnd, sTooltipText, hIcon, lpRectTool, nIDTool);
d3189 1
a3189 1
void CPPToolTip::AddTool(CWnd * pWnd, CString sTooltipText, HICON hIcon /* = NULL */,
d3198 1
a3198 1
	ti.sTooltip = sTooltipText;
d3200 2
a3201 2
	
    if (lpRectTool)
d3220 3
a3222 3
void CPPToolTip::AddTool(PPTOOLTIP_INFO ti) 
{ 
	ASSERT (ti.hWnd);  
d3236 4
a3239 4
	if (!IsExistTool(nIndexTool)) 
		m_arrTools.Add(ti); 
	else 
		m_arrTools.SetAt(nIndexTool, ti); 
a3257 1
	int					nSize = m_arrTools.GetSize(); 
d3262 1
a3262 1
    for (int i = 0; i < nSize; i++) 
a3294 1
	int					nSize = m_arrTools.GetSize();
d3296 1
a3296 1
	for (int i = 0; i < nSize; i++)
a3324 1
	int					nSize = m_arrTools.GetSize();
d3326 5
a3330 5
    for (int i = 0; i < nSize; i++)
    {
        pToolInfo = m_arrTools.GetAt(i);
		
        if (nIDTool == pToolInfo.nIDTool)
d3332 1
a3332 1
    }
@


1.54
log
@Suppressed some compiler warnings
@
text
@d147 1
a147 1
BOOL CPPToolTip::OnEraseBkgnd(CDC* pDC) 
d149 1
d556 1
a556 1
		m_pToolInfo.nGranularity = m_nGranularity;
d615 1
a615 1
		SetShade(rect, m_pToolInfo.nEffect, m_nGranularity, 5, m_pToolInfo.crBegin);
d931 12
a942 12
	case PPTOOLTIP_LEFT_TOP:
	case PPTOOLTIP_LEFT_BOTTOM:
		right = ((x + (int)m_nSizes[PPTTSZ_MARGIN_ANCHOR]) > w_rect->right) ? w_rect->right : (x + m_nSizes[PPTTSZ_MARGIN_ANCHOR]);
		left = right - cx;
		break;
	case PPTOOLTIP_RIGHT_TOP:
	case PPTOOLTIP_RIGHT_BOTTOM:
		left = (x < (w_rect->left + (int)m_nSizes[PPTTSZ_MARGIN_ANCHOR])) ? w_rect->left : (x - m_nSizes[PPTTSZ_MARGIN_ANCHOR]);
		right = left + cx;
		break;
	default:
		return FALSE;
d962 12
a973 12
	case PPTOOLTIP_LEFT_TOP:
	case PPTOOLTIP_RIGHT_TOP:
		bottom = max(y, w_rect->top);
		top = bottom - cy;
		break;
	case PPTOOLTIP_LEFT_BOTTOM:
	case PPTOOLTIP_RIGHT_BOTTOM:
		top = min(y, w_rect->bottom);
		bottom = top + cy;
		break;
	default:
		return FALSE;
d990 1
a990 1
LPLOGFONT CPPToolTip::GetSystemToolTipFont() const
d992 1
a992 2
	static LOGFONT		LogFont = {0};
	CFont				*pDefGuiFont = CFont::FromHandle(static_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT)));
d994 1
a994 3
	pDefGuiFont->GetLogFont(&LogFont);

	return &LogFont; 
d1463 1
a1463 1
			// fallthrouth to drow the horizontal line
d1542 1
a1542 1
			iLineIdx ++;
d2029 1
a2029 1
		iDst[i] = 255 * (i % 2);	//hard
d2037 1
a2037 1
		*iDst = 255 * (i % 2);	//hard
d2080 1
a2080 2
				posDst[j] = (BYTE)d;
				posDst[j] += rand() / grainx2;
d2096 1
a2096 2
				posDst[j] = (BYTE)k;
				posDst[j] += rand() / grainx2 - granularity;
d2112 1
a2112 1
					posDst[j] = idxmin + (BYTE)(((sXSize - j) * 128) / d);
d2114 2
a2115 2
					posDst[j] = idxmax - (BYTE)((j * 128) / d);
				posDst[j] += rand() / grainx2 - granularity;
d2134 1
a2134 2
				posDst[j] = (BYTE)k;
				posDst[j] += rand() / grainx2 - granularity;
d2148 1
a2148 2
				posDst[j + i * bytes] = (BYTE)k;
				posDst[j + i * bytes] += rand() / grainx2 - granularity;
d2161 1
a2161 2
				posDst[j] = (BYTE)k;
				posDst[j] += rand() / grainx2 - granularity;
d2174 1
a2174 1
				posDst[j] += rand() / grainx2 - granularity;
d2187 1
a2187 2
				posDst[j] = (BYTE)k;
				posDst[j] += rand() / grainx2 - granularity;
d2200 1
a2200 2
				posDst[j + i * bytes] = (BYTE)k;
				posDst[j + i * bytes] += rand() / grainx2 - granularity;
d2210 1
a2210 1
				posDst[j] = 128 + rand() / grainx2 - granularity;
d2257 1
a2257 1
	ModifyStyles(nStyles, -1, nIndexTool);
d2490 1
a2490 1
	ModifyMaskTool(nIndexTool, nMask, -1);
d2593 1
a2593 1
	nGranularity = m_nGranularity;
d3025 1
a3025 1
	lf.lfUnderline = bUnderline;
d3027 2
a3028 2
	lf.lfStrikeOut = bStrikeOut;
	lf.lfItalic = bItalic;
d3047 1
d3049 2
a3050 3
	LPLOGFONT		lpSysFont = GetSystemToolTipFont();

	SetFont(lpSysFont);
@


1.53
log
@fixed getting of the default font
@
text
@d940 2
d971 2
d991 1
a991 1
	static LOGFONT		LogFont;
d1327 1
a1327 1
							register TCHAR tc = toupper(strText[j]);
a1630 1
	bool			bTagFound = FALSE;
@


1.52
log
@minor optimization
@
text
@d987 2
a988 2
    static LOGFONT			LogFont;
    NONCLIENTMETRICS		ncm;
d990 1
a990 3
    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    if (!SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS), &ncm, 0))
        return FALSE;
d992 1
a992 3
    memcpy2(&LogFont, &(ncm.lfStatusFont), sizeof(LOGFONT));

    return &LogFont; 
@


1.51
log
@fixed detection of latin letters in right-to-left languages (thanks Aw3)
@
text
@d3665 1
a3665 1
int CPPToolTip::FindIdOfResource(CString sName)
d3672 1
a3672 1
		if (sName.CompareNoCase(nr.sName) == 0)
@


1.50
log
@declare our own windows callback function to support MSLU
@
text
@d1323 1
a1323 1
						bool			bRTL = false, bFound1 = false, bFound2 = false, bFound3 = false;
d1327 4
a1330 1
							if (toupper(strText[j]) >= _T('A') && toupper(strText[j]) <= _T('Z'))
d1335 1
a1335 6
							else if ((strText[j] >= _T('0') && strText[j] <= _T('9')) || strText[j] >= _T('') && strText[j] <= _T(''))
							{
								bRTL = true;
								bFound3 = false;
							}
							else if (strText[j] == _T('(') || strText[j] == _T('['))
d1340 1
a1340 1
							else if (strText[j] == _T(')') || strText[j] == _T(']'))
d1345 1
a1345 1
							else if (strText[j] == _T(':') || strText[j] == _T(';'))
d1347 1
a1347 1
							else if (strText[j] != _T(' '))
@


1.49
log
@1) workaround for weird problem with GetMetrics
2) corrected resource using
3) corrected the tooltip output
@
text
@d23 5
a28 1

d64 1
a64 1
		wndcls.lpfnWndProc		= ::DefWindowProc;
@


1.48
log
@correcttion for my last changes (thanks Aw3 for the tip)
@
text
@a234 1
	CBrush			brBackground(m_crColor [PPTOOLTIP_COLOR_BK_BEGIN]);
d236 1
a236 1
	
a292 3

	brBackground.DeleteObject();
	brBorder.DeleteObject();
d297 1
d299 1
a299 4

	//Draws the shadow for the tooltip
	int				nRop2Mode = pDC->SetROP2(R2_MASKPEN);
	CBrush			*pOldBrush = pDC->SelectObject(&brShadow);
a302 2
	pDC->SelectObject(pOldBrush);
	brShadow.DeleteObject();
d769 1
a769 1
	bitmap.DeleteObject();	//eklmn: we need to delete an object from device context 
a1073 1
		m_iAutoTabLines.Add(0);
a1074 5
	
	int				nLine = 0;
	int				nCmd = CMD_NONE;
	int				nAlign = ALIGN_LEFT;
	bool			bCloseTag = FALSE;
a1076 2
	CSize			szLine(0, 0);
	CSize			szIcon(0, 0); //The size of icon
d1081 17
d1100 1
a1100 1
	
d1103 2
a1104 4
	
	memcpy2(&lf, &m_LogFont, sizeof(LOGFONT));

	CFont			font;
d1106 2
d1109 6
d1116 2
a1117 8
	CFont			*pOldFont = pDC->SelectObject(&font);

	TEXTMETRIC		tm;

	pDC->GetTextMetrics(&tm);

	int				nHeight = tm.tmHeight; //The height of the font
	int				nWidth = tm.tmAveCharWidth; //The width of the font
a1124 4
	
	CUIntArray		aiPercent, aiTabbedLines, aiTabbedTo, aiOrigTabLines;

	aiPercent.Add(0);
d1129 2
a1131 1
	MONITORINFO		mi;
d1135 1
a1135 1
	
d1293 1
a1293 1
						ptCur.x = pt.x + (rect.Width() - m_nLengthLines.GetAt(nLine)) / 2;
d1296 1
a1296 1
						ptCur.x = pt.x + rect.Width() - m_nLengthLines.GetAt(nLine);
d1354 1
a1354 1
					pDC->TextOut(ptCur.x, ptCur.y + m_nHeightLines.GetAt(nLine) - nHeight, strText);
d1367 1
a1367 1
				
d1380 1
a1380 1
					ptCur.x = pt.x + (rect.Width() - m_nLengthLines.GetAt(nLine)) / 2;
d1383 1
a1383 1
					ptCur.x = pt.x + rect.Width() - m_nLengthLines.GetAt(nLine);
d1458 1
a1458 1
				aiPercent.SetAt(nLine, aiPercent.GetAt(nLine) + nParam);
d1463 1
d1468 1
a1468 1
				DrawHorzLine(pDC, ptCur.x, ptCur.x + nParam, ptCur.y + m_nHeightLines.GetAt(nLine) / 2);
d1483 1
a1483 1
					szLine = DrawResource(sParam, pDC, ptCur, m_nHeightLines.GetAt(nLine), szIcon, bCalculate);
d1510 1
a1510 1
					szLine = DrawBitmap(pDC, ptCur, m_nHeightLines.GetAt(nLine), nParam, !sParam.IsEmpty(), nParam1, szIcon, bCalculate);
d1514 1
d1524 1
a1524 1
					szLine = DrawIcon(pDC, ptCur, m_nHeightLines.GetAt(nLine), nParam, szIcon, bCalculate);
d1536 4
a1539 2
				m_nLengthLines.Add(ptCur.x - pt.x); //Adds the real length of the lines
				m_nHeightLines.Add(nLineHeight); //Adds the real height of the lines
d1541 2
a1542 2
			ptCur.y += m_nHeightLines.GetAt(nLine) * nParam;
			nLine ++;
d1557 1
a1557 1
					aiTabbedLines.Add(nLine);
d1608 5
a1612 2
			m_nLengthLines.SetAt(aiTabbedLines.GetAt(i), m_nLengthLines.GetAt(aiTabbedLines.GetAt(i)) + (m_iAutoTabLines.GetAt(aiTabbedTo.GetAt(i)) - aiOrigTabLines.GetAt(i)));
			sz.cx = max((UINT)sz.cx,m_nLengthLines.GetAt(aiTabbedLines.GetAt(i)));
d1617 1
a1617 1
	for (i = 0; i < aiPercent.GetSize(); i++)
d1630 3
a1632 1
	
d1741 3
a1743 1
	
d1820 1
a1820 1
	int				nRetValue;
d1829 2
d1832 1
d1844 2
d1847 1
d1862 1
a1863 2
	::DeleteObject(hOldResBitmap);
	::DeleteObject(hBitmap);
d1885 1
a1886 2
	::DeleteObject(hOldSrcBitmap);
	::DeleteObject(hSrcBitmap);
a1942 1
	pen.DeleteObject();
d1949 13
a1961 13
    // this will make 2^6 = 64 fountain steps
    int			nShift = 6;
    int			nSteps = 1 << nShift;

    for (int i = 0; i < nSteps; i++)
    {
        // do a little alpha blending
        BYTE bR = (BYTE) ((GetRValue(colorStart) * (nSteps - i) +
                   GetRValue(colorFinish) * i) >> nShift);
        BYTE bG = (BYTE) ((GetGValue(colorStart) * (nSteps - i) +
                   GetGValue(colorFinish) * i) >> nShift);
        BYTE bB = (BYTE) ((GetBValue(colorStart) * (nSteps - i) +
                   GetBValue(colorFinish) * i) >> nShift);
d1964 2
d1967 15
a1981 22
        // then paint with the resulting color
        CRect		r2 = rect;

        if (!bHorz)
        {
            r2.top = rect.top + 
                ((i * rect.Height()) >> nShift);
            r2.bottom = rect.top + 
                (((i + 1) * rect.Height()) >> nShift);
            if (r2.Height() > 0)
                pDC->FillRect(r2, &br);
        }
        else
        {
            r2.left = rect.left + 
                ((i * rect.Width()) >> nShift);
            r2.right = rect.left + 
                (((i + 1) * rect.Width()) >> nShift);
            if (r2.Width() > 0)
                pDC->FillRect(r2, &br);
        }
    }
d3137 1
a3137 1
    str.LoadString(nIdText);
d3159 1
a3159 1
    str.LoadString(nIdText);
d3306 6
a3311 5
    for (int i = 0; i < nSize; i++)
    {
        pToolInfo = m_arrTools.GetAt(i);
		
        if (hWnd == pToolInfo.hWnd) 
d3313 4
a3316 2
			return i;
    }
@


1.47
log
@*** empty log message ***
@
text
@d411 4
a414 1
			m_ptOriginal = pMsg->pt; //Stores the mouse's coordinates
d417 1
a417 1
			m_pParentWnd->ScreenToClient(&m_ptOriginal);
d419 1
a419 1
			nIndexTool = FindTool(m_ptOriginal);
@


1.46
log
@Compatibility with VC2005 [brengarne]; Formatting.
@
text
@d374 1
a374 3
	CPoint			pt;
	CRect			rect;
	int				nIndexTool = PPTOOLTIP_TOOL_NOEXIST;
d380 22
a401 25
	case WM_LBUTTONDOWN:
	case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN:
	case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
	case WM_MBUTTONDBLCLK:
	case WM_NCLBUTTONDOWN:
	case WM_NCLBUTTONDBLCLK:
	case WM_NCRBUTTONDOWN:
	case WM_NCRBUTTONDBLCLK:
	case WM_NCMBUTTONDOWN:
	case WM_NCMBUTTONDBLCLK:
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		// The user has interrupted the current tool - dismiss it
		Pop();
		break;
	case WM_MOUSEWHEEL:
	case WM_MOUSEMOVE:
//		TRACE (_T("OnMouseMove()\n"));
		if(pMsg->message != WM_MOUSEWHEEL)
		{
			if ((m_ptOriginal == pMsg->pt) || 
				(m_nIndexCurrentWnd == PPTOOLTIP_TOOL_HELPER) ||
				(m_nIndexDisplayWnd == PPTOOLTIP_TOOL_HELPER))
d403 1
a403 2
		}

d405 8
a412 8
		if (!(m_nStyles & PPTOOLTIP_SHOW_INACTIVE))
		{
			pWnd = GetActiveWindow();
			if (!pWnd)
				return;
		}
		m_ptOriginal = pMsg->pt; //Stores the mouse's coordinates
		
d414 12
a425 9
		pt = pMsg->pt;
		m_pParentWnd->ScreenToClient(&pt);
		
		nIndexTool = FindTool(pt);

		if (!IsExistTool(nIndexTool))
		{
			//If the window under the mouse doen't exist
			if (IsCursorInToolTip() && (m_pToolInfo.nBehaviour & PPTOOLTIP_CLOSE_LEAVEWND))
d427 2
a428 9
			Pop();
			m_nIndexCurrentWnd = PPTOOLTIP_TOOL_NOEXIST;
			m_nIndexDisplayWnd = PPTOOLTIP_TOOL_NOEXIST;
			return;
		}
		else
		{
			//The window under the mouse does exist
			if (nIndexTool == m_nIndexDisplayWnd)
d430 2
a431 1
				if (IsVisible())
d433 12
a444 3
					//Now the tooltip is visible
					if ((m_pToolInfo.nBehaviour & PPTOOLTIP_CLOSE_LEAVEWND))
						return;
d446 1
a446 1
				if (m_pToolInfo.nBehaviour & PPTOOLTIP_MULTIPLE_SHOW)
d448 1
a448 1
					SetNewToolTip(nIndexTool);
a449 2
				else
					Pop();
d451 1
a451 6
			else
			{
				SetNewToolTip(nIndexTool, !IsVisible());
			}
		}
		break;
d740 1
a740 1
CSize CPPToolTip::GetTooltipSize(CString str)
d1045 1
a1045 1
CSize CPPToolTip::PrintTitleString(CDC * pDC, CRect rect, CString str, BOOL bCalculate /* = TRUE */)
d1618 1
a1618 1
CString CPPToolTip::SearchBeginOfTag(CString & str, int & nIndex)
d1651 1
a1651 1
void CPPToolTip::SearchEndOfTag(CString & str, int & nIndex)
d1660 1
a1660 1
CString CPPToolTip::GetNameOfTag(CString & str, int & nIndex)
d1695 1
a1695 1
CString CPPToolTip::GetPropertiesOfTag(CString & str, int & nIndex)
d1727 1
a1727 1
CString CPPToolTip::GetStringValue(CString & str, int & nIndex)
d1765 1
a1765 1
UINT CPPToolTip::GetUIntValue(CString & str, int & nIndex, UINT nDefValue)
@


1.45
log
@Finished renaming to make sources compilable again...
@
text
@d1133 1
a1133 1
	int				nTemp = 0; //the temporary variable
d1144 1
a1144 1
	for (int i = 0; i <= str.GetLength(); i++)
d1233 1
a1233 1
					for (nTemp = 0; nTemp < 2; nTemp++)
d1253 1
a1253 1
					for (nTemp = 0; nTemp < 2; nTemp++)
d1268 1
a1268 1
					for (nTemp = 0; nTemp < 3; nTemp++)
@


1.44
log
@removed unused string; new user message
@
text
@d1864 1
a1864 1
		img.Create(szBitmap.cx, szBitmap.cy, g_eMuleApp.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
d3594 1
a3594 1
	m_imgTooltip.Create(cx, cy, g_eMuleApp.m_iDfltImageListColorFlags | ILC_MASK, nCount, 1);
@


1.43
log
@Removed one unused string variable which BTW was a reason of crash in one reported crash dump.
@
text
@a485 1
	CString			str;
@


1.42
log
@Minor correction for Hebrew display of tooltips.
@
text
@a375 1
	CString			str;
@


1.41
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d1336 1
a1336 1
							else if (strText[j] >= _T('0') && strText[j] <= _T('9'))
d1341 1
a1341 1
							else if (strText[j] == _T('('))
d1346 1
a1346 1
							else if (strText[j] == _T(')'))
d1351 1
a1351 1
							else if (strText[j] == _T(':'))
@


1.40
log
@ fix for signed/unsigned warning...
@
text
@d14 1
d1866 1
a1866 1
		img.Create(szBitmap.cx, szBitmap.cy, ILC_COLOR32 | ILC_MASK, 1, 1);
d3596 1
a3596 1
	m_imgTooltip.Create(cx, cy, ILC_COLOR32 | ILC_MASK, nCount, 1);
@


1.39
log
@Fixed another multi-monitor issue with the tooltips;
Better way to create Client menu in Comments dialog (Thanks again Aw3)
@
text
@d1310 1
a1310 1
				if (((ptCur.x - pt.x) + szLine.cx + (m_nSizes[PPTTSZ_MARGIN_CX] * 2) + m_nSizes[PPTTSZ_SHADOW_CX]) > (mi.rcWork.right - mi.rcWork.left))
d1312 1
a1312 1
					while (!strText.IsEmpty() && ((ptCur.x - pt.x) + szLine.cx + (m_nSizes[PPTTSZ_MARGIN_CX] * 2) + m_nSizes[PPTTSZ_SHADOW_CX]) > (mi.rcWork.right - mi.rcWork.left))
@


1.38
log
@Fixed tooltips foreground color
@
text
@a1138 1
	UINT			iWorkAreaX;
d1142 1
a1142 2
	iWorkAreaX = min(::GetSystemMetrics(SM_CXVIRTUALSCREEN), mi.rcWork.right - mi.rcWork.left) - max(::GetSystemMetrics(SM_XVIRTUALSCREEN), mi.rcWork.left);

d1310 1
a1310 1
				if (((ptCur.x - pt.x) + szLine.cx + (m_nSizes[PPTTSZ_MARGIN_CX] * 2) + m_nSizes[PPTTSZ_SHADOW_CX]) > iWorkAreaX)
d1312 1
a1312 1
					while (!strText.IsEmpty() && ((ptCur.x - pt.x) + szLine.cx + (m_nSizes[PPTTSZ_MARGIN_CX] * 2) + m_nSizes[PPTTSZ_SHADOW_CX]) > iWorkAreaX)
@


1.37
log
@minor changes
@
text
@d1145 1
a1145 1
	pDC->SetTextColor(PPTOOLTIP_COLOR_FG);
d1160 2
a1161 2
				
				if (!strTag.CompareNoCase(_T("b")))
d1165 1
a1165 1
				else if (!strTag.CompareNoCase(_T("i")))
d1169 1
a1169 1
				else if (!strTag.CompareNoCase(_T("u")))
d1173 1
a1173 1
				else if (!strTag.CompareNoCase(_T("s")))
d1177 1
a1177 1
				else if (!strTag.CompareNoCase(_T("br")))
d1182 1
a1182 1
				else if (!strTag.CompareNoCase(_T("t")))
d1187 1
a1187 1
				else if (!strTag.CompareNoCase(_T("ct")))
d1192 1
a1192 1
				else if (!strTag.CompareNoCase(_T("cti")))
d1197 1
a1197 1
				else if (!strTag.CompareNoCase(_T("cb")))
d1202 1
a1202 1
				else if (!strTag.CompareNoCase(_T("cbi")))
d1207 1
a1207 1
				else if (!strTag.CompareNoCase(_T("al")) || !strTag.CompareNoCase(_T("al_l")))
d1211 1
a1211 1
				else if (!strTag.CompareNoCase(_T("al_c")))
d1216 1
a1216 1
				else if (!strTag.CompareNoCase(_T("al_r")))
d1221 1
a1221 1
				else if (!strTag.CompareNoCase(_T("hr")))
d1230 1
a1230 1
				else if (!strTag.CompareNoCase(_T("img")))
d1238 2
a1239 2
						strTag = GetPropertiesOfTag(str, i);
						if (!strTag.CompareNoCase(_T("cx")))
d1241 1
a1241 1
						else if (!strTag.CompareNoCase(_T("cy")))
d1245 1
a1245 1
				else if (!strTag.CompareNoCase(_T("ilst")))
d1250 1
a1250 1
				else if (!strTag.CompareNoCase(_T("icon")))
d1258 2
a1259 2
						strTag = GetPropertiesOfTag(str, i);
						if (!strTag.CompareNoCase(_T("cx")))
d1261 1
a1261 1
						else if (!strTag.CompareNoCase(_T("cy")))
d1265 1
a1265 1
				else if (!strTag.CompareNoCase(_T("bmp")))
d1273 2
a1274 2
						strTag = GetPropertiesOfTag(str, i);
						if (!strTag.CompareNoCase(_T("mask")))
d1279 1
a1279 1
						else if (!strTag.CompareNoCase(_T("cx")))
d1281 1
a1281 1
						else if (!strTag.CompareNoCase(_T("cy")))
d1285 1
a1285 1
				else if (!strTag.CompareNoCase(_T("cat")))
d3667 1
a3667 1
		if (!sName.CompareNoCase(nr.sName))
@


1.36
log
@minor change
@
text
@d1361 1
a1361 1
							pDC->SetTextAlign(pDC->GetTextAlign() & (~TA_RTLREADING));
d1366 1
a1366 1
				strText = _T("");
d1421 1
a1421 1
			lf.lfItalic = bCloseTag ? FALSE : TRUE;
d1429 1
a1429 1
			lf.lfStrikeOut = bCloseTag ? FALSE : TRUE;
d1437 1
a1437 1
			lf.lfUnderline = bCloseTag ? FALSE : TRUE;
@


1.35
log
@minor fix
@
text
@d715 10
@


1.34
log
@Small fix
@
text
@d703 2
d710 2
@


1.33
log
@Fixed an issue with the tooltips (Thanks KuSh!)
@
text
@d1116 1
a1116 1
	CUIntArray		percent, m_aiTabbedLines, m_aiTabbedTo, m_iOrigTabLines;
d1118 1
a1118 1
	percent.Add(0);
d1123 7
d1298 10
d1453 1
a1453 1
				percent.SetAt(nLine, percent.GetAt(nLine) + nParam);
d1534 1
a1534 1
			percent.Add(0);
d1547 3
a1549 3
					m_iOrigTabLines.Add(ptCur.x - pt.x);
					m_aiTabbedLines.Add(nLine);
					m_aiTabbedTo.Add(iCurTabLine);
d1597 1
a1597 1
		for (i = 0; i < m_aiTabbedLines.GetSize(); i++)
d1599 2
a1600 2
			m_nLengthLines.SetAt(m_aiTabbedLines.GetAt(i), m_nLengthLines.GetAt(m_aiTabbedLines.GetAt(i)) + (m_iAutoTabLines.GetAt(m_aiTabbedTo.GetAt(i)) - m_iOrigTabLines.GetAt(i)));
			sz.cx = max((UINT)sz.cx,m_nLengthLines.GetAt(m_aiTabbedLines.GetAt(i)));
d1605 1
a1605 1
	for (i = 0; i < percent.GetSize(); i++)
d1607 2
a1608 2
		if (percent.GetAt(i))
			m_nLengthLines.SetAt(i, m_nLengthLines.GetAt(i) + ::MulDiv(percent.GetAt(i), sz.cx, 100));
@


1.32
log
@better Hebrew alignment
@
text
@d828 1
a828 1
	if (!TestHorizDirection(pt->x, rect->Width(), rWindow.right, m_nLastDirection, rect))
d831 1
a831 1
		if (!TestHorizDirection(pt->x, rect->Width(), rWindow.right, m_nLastDirection, rect))
d841 1
a841 1
	if (!TestVertDirection(pt->y, rect->Height(), rWindow.bottom, m_nLastDirection, rect))
d844 1
a844 1
		if (!TestVertDirection(pt->y, rect->Height(), rWindow.bottom, m_nLastDirection, rect))
d919 1
a919 1
BOOL CPPToolTip::TestHorizDirection(int x, int cx, int w_cx, int nDirection, LPRECT rect) const
d921 1
a921 1
	int			left,right;
d927 1
a927 1
		right = ((x + (int)m_nSizes[PPTTSZ_MARGIN_ANCHOR]) > w_cx) ? w_cx : (x + m_nSizes[PPTTSZ_MARGIN_ANCHOR]);
d932 1
a932 1
		left = (x < (int)m_nSizes[PPTTSZ_MARGIN_ANCHOR]) ? 0 : (x - m_nSizes[PPTTSZ_MARGIN_ANCHOR]);
d937 1
a937 1
	bool		bTestOk = ((left >= 0) && (right <= w_cx)) ? TRUE : FALSE;
d948 1
a948 1
BOOL CPPToolTip::TestVertDirection(int y, int cy, int w_cy, int nDirection, LPRECT rect) const
d956 1
a956 1
		bottom = y;
d961 1
a961 1
		top = y;
d966 1
a966 1
	bool		bTestOk = ((top >= 0) && (bottom <= w_cy)) ? TRUE : FALSE;
@


1.31
log
@Hebrew alignment fix
@
text
@d1297 29
a1325 2
						bool			bFound1 = strText.Find(_T("(")) != -1;
						bool			bFound2 = strText.Find(_T(")")) != -1;
d1327 1
a1327 1
						if (strText.FindOneOf(_T("0123456789")) != -1 && bFound1 == bFound2)
@


1.30
log
@minor change
@
text
@d1294 11
d1306 1
@


1.29
log
@Formatting + Minor changes
@
text
@d1516 11
a1526 4
				pDC->SetTextColor((COLORREF)nParam);
				for (int j = 12; j > 0; j--)
					DrawHorzLine(pDC, ptCur.x, ptCur.x + j, ptCur.y + 12 - j);
				pDC->SetTextColor(PPTOOLTIP_COLOR_FG);
@


1.28
log
@small correction
@
text
@d52 3
a54 2
	WNDCLASS wndcls;
	HINSTANCE hInst = AfxGetInstanceHandle();
d112 3
a114 2
	DWORD dwStyle = WS_POPUP; 
	DWORD dwExStyle = WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
d173 3
a175 2
	NM_PPTOOLTIP_DISPLAY lpnm; 
	PPTOOLTIP_INFO tiCopy = ti; 
d184 4
a187 2
	::SendMessage(m_hNotifyWnd, WM_NOTIFY, lpnm.hdr.idFrom, (LPARAM)&lpnm);  
	CRect rcBound = ti.rectBounds;  
d203 2
a204 1
	CRect rect;
d211 3
a213 2
	CDC memDC;
	CBitmap bitmap;
d216 2
a217 1
	CBitmap* pOldBitmap = memDC.SelectObject(&bitmap); 
d234 2
a235 2
	CBrush brBackground(m_crColor [PPTOOLTIP_COLOR_BK_BEGIN]);
	CBrush brBorder(m_crColor [PPTOOLTIP_COLOR_BORDER]);
d263 2
a264 1
		CPoint ptIcon;
d300 2
a301 1
	CBrush brShadow(m_crColor [PPTOOLTIP_COLOR_SHADOW]);
d303 3
a305 2
	int nRop2Mode = pDC->SetROP2(R2_MASKPEN);
	CBrush* pOldBrush = pDC->SelectObject(&brShadow);
d372 5
a376 5
	CWnd * pWnd = NULL;
	CPoint pt;
	CRect rect;
	CString str;
	int nIndexTool = PPTOOLTIP_TOOL_NOEXIST;
a416 1

d450 2
a451 1
				else Pop();
d485 3
a487 3
	CPoint pt = m_ptOriginal, point;
	CString str;
	int nIndexTool = PPTOOLTIP_TOOL_HELPER;
d510 1
a510 3
		if (!IsCursorInToolTip() || 
			!IsVisible() || 
			!(m_pToolInfo.nBehaviour & PPTOOLTIP_NOCLOSE_OVER))
d531 2
a532 1
    CPoint pt;
d535 1
a535 1
	CPPToolTip * pWnd = (CPPToolTip*)WindowFromPoint(pt);
d585 1
a585 1
	CSize sz = GetTooltipSize(m_pToolInfo.sTooltip);
d608 1
a608 1
	CRect rect (0, 0, sz.cx, sz.cy);
d640 1
a640 1
	CRgn rgnCombo;
d664 1
a664 1
	CRect rect;
d668 3
a670 3
	CRgn rgnRect;
	CRgn rgnAnchor;
	CPoint ptAnchor [3];
d737 2
a738 1
	CRect rect;
d753 2
a754 2
	CDC memDC;
	CBitmap bitmap;
d760 2
a761 1
	CBitmap* pOldBitmap = memDC.SelectObject(&bitmap);
d765 1
a765 1
	CSize sz = PrintTitleString(&memDC, rect, str);
d779 2
a780 1
	ICONINFO ii;
d921 1
a921 1
	int left,right;
d937 2
a938 1
	BOOL bTestOk = ((left >= 0) && (right <= w_cx)) ? TRUE : FALSE;
d950 1
a950 1
	int top, bottom;
d966 1
a966 1
	BOOL bTestOk = ((top >= 0) && (bottom <= w_cy)) ? TRUE : FALSE;
d982 2
a983 2
    static LOGFONT LogFont;
    NONCLIENTMETRICS ncm;
d1076 8
a1083 8
	int nLine = 0;
	int nCmd = CMD_NONE;
	int nAlign = ALIGN_LEFT;
	BOOL bCloseTag = FALSE;

	CSize sz(0, 0);
	CSize szLine(0, 0);
	CSize szIcon(0, 0); //The size of icon
d1088 2
a1089 2
	CPoint	pt = rect.TopLeft();
	CPoint  ptCur = pt;
d1092 1
a1092 1
	LOGFONT lf;
d1096 1
a1096 1
	CFont font;
d1100 1
a1100 1
	CFont* pOldFont = pDC->SelectObject(&font);
d1102 1
a1102 1
	TEXTMETRIC tm;
d1106 2
a1107 2
	int nHeight = tm.tmHeight; //The height of the font
	int nWidth = tm.tmAveCharWidth; //The width of the font
d1109 3
a1111 3
	CString strTag;  // Tag's name 
	CString strText; // The current text to output
	CString sParam; // The text parameter
d1113 2
a1114 2
	UINT nParam = 0, nParam1 = 0;
	int nLineHeight = bCalculate ? nHeight : m_nHeightLines.GetAt(0); //The height of the current line
d1116 1
a1116 1
	CUIntArray percent, m_aiTabbedLines, m_aiTabbedTo, m_iOrigTabLines;
d1120 3
a1122 3
	int		nTemp = 0; //the temporary variable
	int		iCurTabLine = 0;
	bool	bFirstOutput = true;
d1553 2
a1554 2
	CString sText;
	BOOL bTagFound = FALSE;
d1595 1
a1595 1
	CString sText;
d1630 1
a1630 1
	CString sText;
d1662 2
a1663 2
	CString sText;
	BOOL bValueFound = FALSE;
d1700 1
a1700 1
	CString sText = GetStringValue(str, nIndex);
d1710 2
a1711 2
	CSize sz(0, 0);
	int nIndex = FindIdOfResource(sName);
d1716 1
a1716 1
	PPTOOLTIP_NAME_RES nr = m_arrNameRes.GetAt(nIndex);
d1739 4
a1742 4
	CSize sz(0, 0);
	HBITMAP	hBitmap = GetBitmapFromResources(nID);
	int		nRetValue;
	BITMAP	csBitmapSize;
d1764 5
a1768 5
	HDC hSrcDC = ::CreateCompatibleDC(pDC->m_hDC);
	HDC hResDC = ::CreateCompatibleDC(pDC->m_hDC);
	HBITMAP hSrcBitmap = ::CreateCompatibleBitmap(pDC->m_hDC, szBitmap.cx, szBitmap.cy);
	HBITMAP hOldSrcBitmap = (HBITMAP)::SelectObject(hSrcDC, hSrcBitmap);
	HBITMAP hOldResBitmap = (HBITMAP)::SelectObject(hResDC, hBitmap);
d1787 3
a1789 1
		CImageList img;
d1810 2
a1811 2
	CSize sz (0, 0);
	HICON hIcon = GetIconFromResources(nID, szIcon);
d1834 2
a1835 1
	int nCount = img.GetImageCount();
d1842 1
a1842 1
	HICON hIcon = img.ExtractIcon(nIndex);
d1854 2
a1855 2
	CPen pen(PS_SOLID, 1, pDC->GetTextColor());
	CPen * penOld = pDC->SelectObject(&pen);
d1868 2
a1869 2
    int nShift = 6;
    int nSteps = 1 << nShift;
d1881 1
a1881 1
		CBrush br (RGB(bR, bG, bB));
d1884 2
a1885 1
        CRect r2 = rect;
d1911 2
a1912 2
	long	sXSize,sYSize,bytes,j,i,k,h;
	BYTE	*iDst ,*posDst;
d1917 2
a1918 2
	m_dh.Create(max(1,sXSize /*-2*m_FocusRectMargin-1*/ ),1,8);	//create the horizontal focus bitmap
	m_dv.Create(1,max(1,sYSize /*-2*m_FocusRectMargin*/),8);	//create the vertical focus bitmap
d1920 1
a1920 1
	m_dNormal.Create(sXSize,sYSize,8);					//create the default bitmap
d1922 30
a1951 27
	COLORREF hicr = m_pToolInfo.crBegin; //GetSysColor(COLOR_BTNHIGHLIGHT);		//get the button base colors
	COLORREF midcr = m_pToolInfo.crMid;  //GetSysColor(COLOR_BTNFACE);
	COLORREF locr = m_pToolInfo.crEnd;   //GetSysColor(COLOR_BTNSHADOW);
	long r,g,b;											//build the shaded palette

	for(i=0;i<129;i++){
		r=((128-i)*GetRValue(locr)+i*GetRValue(midcr))/128;
		g=((128-i)*GetGValue(locr)+i*GetGValue(midcr))/128;
		b=((128-i)*GetBValue(locr)+i*GetBValue(midcr))/128;
		m_dNormal.SetPaletteIndex((BYTE)i,(BYTE)r,(BYTE)g,(BYTE)b);
		m_dh.SetPaletteIndex((BYTE)i,(BYTE)r,(BYTE)g,(BYTE)b);
		m_dv.SetPaletteIndex((BYTE)i,(BYTE)r,(BYTE)g,(BYTE)b);
	}
	for(i=1;i<129;i++){
		r=((128-i)*GetRValue(midcr)+i*GetRValue(hicr))/128;
		g=((128-i)*GetGValue(midcr)+i*GetGValue(hicr))/128;
		b=((128-i)*GetBValue(midcr)+i*GetBValue(hicr))/128;
		m_dNormal.SetPaletteIndex((BYTE)(i+127),(BYTE)r,(BYTE)g,(BYTE)b);
		m_dh.SetPaletteIndex((BYTE)(i+127),(BYTE)r,(BYTE)g,(BYTE)b);
		m_dv.SetPaletteIndex((BYTE)(i+127),(BYTE)r,(BYTE)g,(BYTE)b);
	}

	m_dNormal.BlendPalette(color,coloring);	//color the palette

	iDst=m_dh.GetBits();		//build the horiz. dotted focus bitmap
	j=(long)m_dh.GetWidth();
	for(i=0;i<j;i++){
d1953 1
a1953 1
		iDst[i]=255*(i%2);		//hard
d1956 4
a1959 3
	iDst=m_dv.GetBits();		//build the vert. dotted focus bitmap
	j=(long)m_dv.GetHeight();
	for(i=0;i<j;i++){
d1961 2
a1962 2
		*iDst=255*(i%2);		//hard
		iDst+=4;
d1967 1
a1967 2
	posDst =iDst;
	long a,x,y,d,xs,idxmax,idxmin;
d1969 5
a1973 3
	int grainx2=RAND_MAX/(max(1,2*granularity));
	idxmax=255-granularity;
	idxmin=granularity;
d1981 13
a1993 11
		k=40;	//stroke granularity
		for(a=0;a<200;a++){
			x=rand()/(RAND_MAX/sXSize); //stroke postion
			y=rand()/(RAND_MAX/sYSize);	//stroke position
			xs=rand()/(RAND_MAX/min(sXSize,sYSize))/2; //stroke lenght
			d=rand()/(RAND_MAX/k);	//stroke color
			for(i=0;i<xs;i++){
				if (((x-i)>0)&&((y+i)<sYSize))
					m_dNormal.SetPixelIndex(x-i,y+i,(BYTE)d);
				if (((x+i)<sXSize)&&((y-i)>0))
					m_dNormal.SetPixelIndex(sXSize-x+i,y-i,(BYTE)d);
d1997 9
a2005 7
		posDst =iDst;
		a=(idxmax-idxmin-k)/2;
		for(i = 0; i < sYSize; i++) {
			for(j = 0; j < sXSize; j++) {
				d=posDst[j]+((a*i)/sYSize+(a*(sXSize-j))/sXSize);
				posDst[j]=(BYTE)d;
				posDst[j]+=rand()/grainx2;
d2007 1
a2007 1
			posDst+=bytes;
d2014 9
a2022 7
		for(i = 0; i < sYSize; i++) {
			k=(255*i/sYSize)-127;
			k=(k*(k*k)/128)/128;
			k=(k*(128-granularity*2))/128+128;
			for(j = 0; j < sXSize; j++) {
				posDst[j]=(BYTE)k;
				posDst[j]+=rand()/grainx2-granularity;
d2024 1
a2024 1
			posDst+=bytes;
d2027 15
a2041 11
		d=min(16,sXSize/6);	//max edge=16
		a=sYSize*sYSize/4;
		posDst =iDst;
		for(i = 0; i < sYSize; i++) {
			y=i-sYSize/2;
			for(j = 0; j < sXSize; j++) {
				x=j-sXSize/2;
				xs=sXSize/2-d+(y*y*d)/a;
				if (x>xs) posDst[j]=idxmin+(BYTE)(((sXSize-j)*128)/d);
				if ((x+xs)<0) posDst[j]=idxmax-(BYTE)((j*128)/d);
				posDst[j]+=rand()/grainx2-granularity;
d2043 1
a2043 1
			posDst+=bytes;
d2048 14
a2061 10
		for(i = 0; i < sYSize; i++) {
			h=(255*i/sYSize)-127;
			for(j = 0; j < sXSize; j++) {
				k=(255*(sXSize-j)/sXSize)-127;
				k=(h*(h*h)/128)/128+(k*(k*k)/128)/128;
				k=k*(128-granularity)/128+128;
				if (k<idxmin) k=idxmin;
				if (k>idxmax) k=idxmax;
				posDst[j]=(BYTE)k;
				posDst[j]+=rand()/grainx2-granularity;
d2063 1
a2063 1
			posDst+=bytes;
d2068 9
a2076 7
		for(j = 0; j < sXSize; j++) {
			k=(255*(sXSize-j)/sXSize)-127;
			k=(k*(k*k)/128)/128;
			k=(k*(128-granularity))/128+128;
			for(i = 0; i < sYSize; i++) {
				posDst[j+i*bytes]=(BYTE)k;
				posDst[j+i*bytes]+=rand()/grainx2-granularity;
d2082 9
a2090 7
		for(i = 0; i < sYSize; i++) {
			k=(255*i/sYSize)-127;
			k=(k*(k*k)/128)/128;
			k=(k*(128-granularity))/128+128;
			for(j = 0; j < sXSize; j++) {
				posDst[j]=(BYTE)k;
				posDst[j]+=rand()/grainx2-granularity;
d2092 1
a2092 1
			posDst+=bytes;
d2097 7
a2103 5
		a=(idxmax-idxmin)/2;
		for(i = 0; i < sYSize; i++) {
			for(j = 0; j < sXSize; j++) {
				posDst[j]=(BYTE)(idxmin+a*i/sYSize+a*(sXSize-j)/sXSize);
				posDst[j]+=rand()/grainx2-granularity;
d2105 1
a2105 1
			posDst+=bytes;
d2110 8
a2117 6
		a=idxmax-idxmin;
		for(i = 0; i < sYSize; i++) {
			k=a*i/sYSize+idxmin;
			for(j = 0; j < sXSize; j++) {
				posDst[j]=(BYTE)k;
				posDst[j]+=rand()/grainx2-granularity;
d2119 1
a2119 1
			posDst+=bytes;
d2124 8
a2131 6
		a=idxmax-idxmin;
		for(j = 0; j < sXSize; j++) {
			k=a*(sXSize-j)/sXSize+idxmin;
			for(i = 0; i < sYSize; i++) {
				posDst[j+i*bytes]=(BYTE)k;
				posDst[j+i*bytes]+=rand()/grainx2-granularity;
d2137 5
a2141 3
		for(i = 0; i < sYSize; i++) {
			for(j = 0; j < sXSize; j++) {
				posDst[j]=128+rand()/grainx2-granularity;
d2143 1
a2143 1
			posDst+=bytes;
d2153 1
a2153 1
	HINSTANCE hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nID), RT_GROUP_ICON);
d2155 1
a2155 1
	HICON hIcon = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nID), IMAGE_ICON, szIcon.cx, szIcon.cy, 0);
d2163 1
a2163 1
	HINSTANCE hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nID), RT_BITMAP);
d2165 1
a2165 1
	HBITMAP hBitmap = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nID), IMAGE_BITMAP, 0, 0, 0);
d2212 2
a2213 1
		PPTOOLTIP_INFO ti;
d2240 2
a2241 1
		PPTOOLTIP_INFO ti;
d2375 1
a2375 1
		PPTOOLTIP_INFO ti;
d2403 2
a2404 1
		PPTOOLTIP_INFO ti;
d2429 1
a2429 1
	PPTOOLTIP_INFO ti;
d2442 1
a2442 1
	PPTOOLTIP_INFO ti;
d2470 1
a2470 1
		PPTOOLTIP_INFO ti;
d2515 1
a2515 1
		PPTOOLTIP_INFO ti;
d2539 1
a2539 1
	HWND hWnd = NULL;
d2641 1
a2641 1
	UINT nTime = 0;
d2766 1
a2766 1
		PPTOOLTIP_INFO ti;
d2789 1
a2789 1
		PPTOOLTIP_INFO ti;
d2816 1
a2816 1
		PPTOOLTIP_INFO ti;
d2840 1
a2840 1
		PPTOOLTIP_INFO ti;
d2902 1
a2902 1
	LOGFONT lf;
d2949 2
a2950 2
	CDC* pDC = GetDC();
	LOGFONT lf;
d2979 1
a2979 1
	LPLOGFONT lpSysFont = GetSystemToolTipFont();
d3024 1
a3024 1
    CPoint point = pt;
d3028 1
a3028 1
    HWND hWnd = ::WindowFromPoint(point);
d3032 1
a3032 1
	UINT nFlags = CWP_ALL;
d3058 1
a3058 1
	CString str;
d3080 1
a3080 1
	CString str;
d3102 1
a3102 1
	HICON hIcon	= GetIconFromResources (nIdIcon, szIcon);
d3124 1
a3124 1
	PPTOOLTIP_INFO ti;
d3187 4
a3190 4
	HWND hWnd = GetWndFromPoint(pt, m_nStyles & PPTOOLTIP_SHOW_DISABLED); 
	PPTOOLTIP_INFO pToolInfo;  
	int nSize = m_arrTools.GetSize(); 
	CPoint ptClient;  
d3225 3
a3227 3
	HWND hWnd = pWnd->GetSafeHwnd();
	PPTOOLTIP_INFO pToolInfo;
	int nSize = m_arrTools.GetSize();
d3254 2
a3255 2
	PPTOOLTIP_INFO pToolInfo;
	int nSize = m_arrTools.GetSize();
d3378 1
a3378 1
	CString str;
d3399 1
a3399 1
	CString str;
d3420 1
a3420 1
	HICON hIcon	= GetIconFromResources(nIdIcon);
d3440 1
a3440 1
	PPTOOLTIP_INFO ti;
d3494 1
a3494 1
	HBITMAP hBitmap = GetBitmapFromResources(nIdBitmap);
d3564 1
a3564 1
	PPTOOLTIP_NAME_RES nr;
d3585 1
a3585 1
	PPTOOLTIP_NAME_RES nr;
d3607 1
a3607 1
	PPTOOLTIP_NAME_RES nr;
@


1.27
log
@small correction
@
text
@d417 1
a417 1
			//If the window under the mouse isn't exist
d427 1
a427 1
			//The window under the mouse is exist
d570 1
a570 1
	//If string and icon are not exist then exit
d585 1
a585 1
			sz.cx += m_nSizes[PPTTSZ_MARGIN_CX]; //If text exists then adds separator*/
d818 9
a826 1
		TestHorizDirection(pt->x, rect->Width(), rWindow.right, m_nLastDirection, rect);
d831 9
a839 1
		TestVertDirection(pt->y, rect->Height(), rWindow.bottom, m_nLastDirection, rect);
d1261 1
a1261 1
				//If text to output is exist
d1390 1
a1390 1
			//If text to output is exist
d3284 1
a3284 1
//		TRUE - the tool is exist
@


1.26
log
@multi-monitor issue with the tooltips should be resolved now
@
text
@d800 11
a810 9
	// Use the screen's right edge as the right hand border, not the right edge of the client.
	CWindowDC	wdc(NULL);
	CRect		rWindow;

	// The whole virtual desktop - not just the primary screen
    rWindow.left    = ::GetSystemMetrics(SM_XVIRTUALSCREEN);
    rWindow.top     = ::GetSystemMetrics(SM_YVIRTUALSCREEN);
	rWindow.right   = rWindow.left + ::GetSystemMetrics(SM_CXVIRTUALSCREEN);
    rWindow.bottom  = rWindow.top + ::GetSystemMetrics(SM_CYVIRTUALSCREEN);
@


1.25
log
@Advanced Log tooltip on status bar;
Tooltip width should be now correct
@
text
@d294 1
a294 1
	CBrush* pOldBrush = pDC->SelectObject(&brShadow);	//eklmn: select new brush
d297 1
a297 1
	pDC->SelectObject(pOldBrush);	//eklmn: recover an old brush
d576 1
d631 1
d655 1
d657 1
d661 1
d744 1
d801 2
a802 11
	//	CWindowDC wdc(NULL);
	//  CRect rWindow(0, 0, 0, 0);
	//	rWindow.right = GetDeviceCaps(wdc, HORZRES);// - 8;
	//	rWindow.bottom = GetDeviceCaps(wdc, VERTRES);// - 8;

	// katsyonak October 26, 2003 - Multi-Monitor fix
	HMONITOR hMonitor = MonitorFromPoint(*pt, MONITOR_DEFAULTTONEAREST);
	MONITORINFO mi;
	mi.cbSize = sizeof(mi);
	GetMonitorInfo(hMonitor, &mi);
    CRect rWindow = mi.rcWork;
d804 5
a808 7
	/*
	m_szToolIcon = GetSizeIcon(m_pToolInfo.hIcon);
	if (m_szToolIcon.cx || m_szToolIcon.cy)
	{
		sz.cx += m_szToolIcon.cx + m_nSizes[PPTTSZ_MARGIN_CX];
		sz.cy = max(m_szToolIcon.cy, sz.cy);
	}
d810 1
a810 17
	//Gets size of the tooltip with margins
	sz.cx += m_nSizes[PPTTSZ_MARGIN_CX] * 2;
	sz.cy += m_nSizes[PPTTSZ_MARGIN_CY] * 2 + m_nSizes[PPTTSZ_HEIGHT_ANCHOR];
	if (m_pToolInfo.nStyles & PPTOOLTIP_SHADOW)
	{
		rWindow.right -= m_nSizes[PPTTSZ_SHADOW_CX];
		rWindow.bottom -= m_nSizes[PPTTSZ_SHADOW_CY];
		sz.cx += m_nSizes[PPTTSZ_SHADOW_CX];
		sz.cy += m_nSizes[PPTTSZ_SHADOW_CY];
	}
*/	
//	CRect rect;
//	rect.SetRect(0, 0, sz.cx, sz.cy);
//	CRect rectCopy = *rect;
	
	//Offset the rect from the mouse pointer
	CPoint ptEnd;
d824 1
a824 1
	//Returns the rect of the tooltip
d935 1
d951 1
a952 1
    NONCLIENTMETRICS ncm;
d1005 1
a1005 1
// <cat=0x123456> Draws a category triangle - The triangle color (RGB (12,34,56))
d1065 1
d1669 1
a1678 1
	
d1680 1
a1708 1
	
a1733 1
	
d1778 1
d1808 1
d1821 1
d1890 1
d2307 1
d2358 1
d2360 1
d2371 1
d2373 1
d2401 1
d2446 1
d2572 1
d2697 1
d2720 1
d2747 1
d2771 1
d2833 2
a2834 1
	font.GetLogFont (&lf);
d2881 1
d2955 1
d2963 1
d2989 1
d3011 1
d3055 1
d3095 2
a3096 1
	int nIndexTool = FindTool(CWnd::FromHandle(ti.hWnd), ti.rectBounds); 
a3117 1
	
d3121 1
d3158 1
d3186 1
d3309 1
d3330 1
d3351 1
d3371 1
d3425 1
d3495 1
d3516 1
d3538 1
@


1.24
log
@Tooltip width calculation should be more correct now
@
text
@d583 2
a584 2
		if (m_szTextTooltip.cx != 0)
			sz.cx += m_nSizes[PPTTSZ_MARGIN_CX]; //If text exists then adds separator
d1111 2
a1280 2
				{
					pDC->SetTextColor(m_crColor[PPTOOLTIP_COLOR_FG]);
a1281 1
				}
d1324 7
a1330 1
			lf.lfWeight = bCloseTag ? FW_NORMAL : FW_BOLD;
@


1.23
log
@better way to indicate category color in tooltips
@
text
@a1104 1
	m_iOrigTabLines.Add(0);
a1389 1
			{
a1390 2
				m_iOrigTabLines.Add(0);
			}
d1472 2
a1473 4
					m_iOrigTabLines.SetAt(iCurTabLine, ptCur.x - pt.x);
					ptCur.x += (nWidth * 7);
					if ((int)m_iAutoTabLines.GetAt(iCurTabLine) < (ptCur.x - pt.x))
						m_iAutoTabLines.SetAt(iCurTabLine, ptCur.x - pt.x);
d1476 2
d1480 1
a1480 1
					ptCur.x = m_iAutoTabLines.GetAt(iCurTabLine) - pt.x;
d1518 2
a1519 2
   			m_nLengthLines.SetAt(m_aiTabbedLines.GetAt(i), m_nLengthLines.GetAt(m_aiTabbedLines.GetAt(i)) + (m_iAutoTabLines.GetAt(m_aiTabbedTo.GetAt(i)) - m_iOrigTabLines.GetAt(m_aiTabbedTo.GetAt(i))));
			sz.cx = max(sz.cx,(int)m_nLengthLines.GetAt(m_aiTabbedLines.GetAt(i)));
@


1.22
log
@better tooltip width calculation
@
text
@d982 1
a982 1
/////////////////////////////////////////////////////////////////
d1024 3
a1026 1
////////////////////////////////////////////////////////////////
d1046 2
a1047 1
			CMD_DRAW_ICON
d1250 5
d1498 12
@


1.21
log
@minor change in tooltip width calculation workaround
@
text
@d1100 1
a1100 1
	CUIntArray percent;
d1102 1
d1106 2
a1107 2
	int		iCurTabLine = 0, iTotalBoldCharacters = 0;
	bool	bFirstOutput = true, bBold = false;
a1269 3
				{
					if (bBold)
						iTotalBoldCharacters = max(iTotalBoldCharacters, strText.GetLength());
a1270 1
				}
a1317 1
			//lf.lfWeight = bCloseTag ? m_LogFont.lfWeight : m_LogFont.lfWeight * 2;
a1318 1
			bBold = !bCloseTag;
d1383 1
d1385 2
d1450 1
a1450 1
				sz.cx = max(sz.cx, ptCur.x - pt.x + iTotalBoldCharacters + (nWidth * 8));
d1468 1
d1472 2
d1498 9
@


1.20
log
@Temporary workaround for tooltips width
@
text
@d582 1
a582 1
		sz.cx += m_szToolIcon.cx;
d584 1
a584 1
			sz.cx += m_nSizes[PPTTSZ_MARGIN_CX]; //If text is exist then adds separator
d725 8
d1104 3
a1106 3
	int nTemp = 0; //the temporary variable
	int iCurTabLine = 0;
	BOOL bFirstOutput = TRUE;
d1269 3
d1273 1
d1321 3
a1323 7
			lf.lfWeight = m_LogFont.lfWeight;
			if (!bCloseTag)
			{
				lf.lfWeight *= 2;
				if (lf.lfWeight > FW_BLACK)
					lf.lfWeight = FW_BLACK;
			}
d1452 1
a1452 1
				sz.cx = max(sz.cx, ptCur.x - pt.x + (nWidth * 12));
@


1.19
log
@Fixed tooltips exception after failed startup.
@
text
@d1257 1
d1259 1
d1444 1
a1444 1
				sz.cx = max(sz.cx, ptCur.x - pt.x + 32);
@


1.18
log
@Display client version and server name in tooltips
@
text
@d357 4
d385 1
a385 1
		// The user has interupted the current tool - dismiss it
@


1.17
log
@Tooltips alignment is now automatic;  Improved status bar tooltips
@
text
@d1055 2
a1056 2
	CSize szLine (0, 0);
	CSize szIcon (0, 0); //The size of icon
d1075 1
d1077 1
d1089 1
d1384 1
a1384 1
					nLineHeight = max (nLineHeight, szLine.cy);
d1397 1
a1397 1
					nLineHeight = max (nLineHeight, szLine.cy);
d1411 1
a1411 1
					nLineHeight = max (nLineHeight, szLine.cy);
d1424 1
a1424 1
					nLineHeight = max (nLineHeight, szLine.cy);
d1438 1
a1438 1
				sz.cx = max(sz.cx, ptCur.x - pt.x);
@


1.16
log
@some fixes
@
text
@d79 1
d571 1
a571 1
    CSize sz = GetTooltipSize(m_pToolInfo.sTooltip);
d1045 2
d1090 1
d1092 1
a1092 1
	
d1131 1
a1131 1
					nParam = GetUIntValue(str, i, 1);
d1363 2
a1364 1
			else nParam = ::MulDiv(rect.Width(), nParam, 100);
d1370 3
a1384 1

a1396 1
				{
a1397 1
				}
a1410 1
				{
a1411 1
				}
a1423 1
				{
a1424 1
				}
d1449 12
a1460 4
			if (!nParam)
				nParam = 1;
			nParam1 = (ptCur.x - pt.x) % (nWidth * 4);
			if (nParam1)
d1462 8
a1469 3
				//aligns with tab
				ptCur.x += (nWidth * 4) - nParam1;
				nParam --;
a1470 1
			ptCur.x += (nParam * nWidth * 4);
a1473 1
	
@


1.15
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d1076 3
a1078 3
	CString strTag = _T("");  // Tag's name 
	CString strText = _T(""); // The current text to output
	CString sParam = _T(""); // The text parameter
a1128 10
				else if (strTag.GetAt(0) == _T('\n'))
				{
					nCmd = CMD_NEW_LINE;
					nParam = 1;
				}
				else if (strTag.GetAt(0) == _T('\t'))
				{
					nCmd = CMD_TABULATION;
					nParam = 1;
				}
d1227 2
a1228 1
				else nCmd = CMD_NONE;
d1480 1
a1480 1
	CString sText = _T("");
d1487 3
d1491 1
a1502 5
		case _T('\t'):
		case _T('\n'):
			if (!sText.IsEmpty())
				nIndex--;
			return sText;
d1515 1
a1515 5
		switch (str.GetAt(nIndex))
		{
		case _T('>'):
		case _T('\n'):
		case _T('\t'):
a1516 1
		}
d1522 1
a1522 1
	CString sText = _T("");
a1529 2
		case _T('\t'): //It is a tab tag
		case _T('\n'): //It is a new line tag
d1557 1
a1557 1
	CString sText = _T("");
d1563 4
a1566 1
		case _T('\r'): //Pass characters
a1567 1
		case _T('\n'):
d1589 1
a1589 1
	CString sText = _T("");
d1596 5
a1600 3
		case _T('\r'): //Pass character
		case _T('\t'): //It is a tab tag
		case _T('\n'): //It is a new line tag
@


1.14
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d754 1
a754 1
		::ZeroMemory(&ii, sizeof(ICONINFO));
@


1.13
log
@BUGFIX: corrected tooltip font color
@
text
@d2837 1
a2837 1
	memset2(&lf, 0, sizeof(LOGFONT));
@


1.12
log
@Fixed bug 0000406 - Multi-monitor issue with tooltips
@
text
@d1259 2
d1262 1
@


1.11
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d11 1
d782 12
a793 5
	//	CWindowDC wdc(NULL);		// katsyonak 20.05.03
	CRect rWindow(0, 0, 0, 0);
	//	rWindow.right = GetDeviceCaps(wdc, HORZRES);// - 8;		// katsyonak 20.05.03
	//	rWindow.bottom = GetDeviceCaps(wdc, VERTRES);// - 8;	// katsyonak 20.05.03
	SystemParametersInfo(SPI_GETWORKAREA,0,rWindow, 0);			// katsyonak 20.05.03
@


1.10
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d2826 1
a2826 1
	memset (&lf, 0, sizeof(LOGFONT));
d2828 1
a2828 1
	_tcscpy (lf.lfFaceName, lpszFaceName);
@


1.9
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d26 2
d218 1
a219 1
	bitmap.DeleteObject(); 
d292 1
d295 1
d736 1
a737 1
	bitmap.DeleteObject();
d1061 1
a1061 1
	CFont * pOldFont = pDC->SelectObject(&font);
@


1.8
log
@Fixed adding clipboard links with | and tooltips
@
text
@d12 1
a12 1
#include "..\memcpy_amd.h"
d952 1
a952 5
    #ifndef AMD
    memcpy(&LogFont, &(ncm.lfStatusFont), sizeof(LOGFONT));
    #else
    memcpy_amd(&LogFont, &(ncm.lfStatusFont), sizeof(LOGFONT));
    #endif
d1052 1
a1052 5
	#ifndef AMD
	memcpy(&lf, &m_LogFont, sizeof(LOGFONT));
	#else
	memcpy_amd(&lf, &m_LogFont, sizeof(LOGFONT));
	#endif
d2798 1
a2798 5
	#ifndef AMD
	memcpy(&m_LogFont, lf, sizeof(LOGFONT));
	#else
	memcpy_amd(&m_LogFont, lf, sizeof(LOGFONT));
	#endif
d2877 1
a2877 5
	#ifndef AMD
	memcpy(lf, &m_LogFont, sizeof(LOGFONT));
	#else
	memcpy_amd(lf, &m_LogFont, sizeof(LOGFONT));
	#endif
@


1.7
log
@Temporary fix of tooltip on mouse wheel move.
@
text
@a373 1
	case WM_MOUSEWHEEL:
d378 1
d381 7
a387 4
		if ((m_ptOriginal == pMsg->pt) || 
			(m_nIndexCurrentWnd == PPTOOLTIP_TOOL_HELPER) ||
			(m_nIndexDisplayWnd == PPTOOLTIP_TOOL_HELPER))
			return; //Mouse pointer was not move
@


1.6
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d374 1
@


1.5
log
@katsyonak's fix for "some upload list tooltips hidden by system taskbar"
@
text
@d12 1
d948 1
d950 3
d1051 6
a1056 1
    memcpy(&lf, &m_LogFont, sizeof(LOGFONT));
d2802 5
a2806 1
    memcpy(&m_LogFont, lf, sizeof(LOGFONT));
d2885 1
d2887 3
@


1.4
log
@Small fixes
@
text
@d772 1
a772 1
	CWindowDC wdc(NULL);
d774 4
a777 3
	rWindow.right = GetDeviceCaps(wdc, HORZRES);// - 8;
	rWindow.bottom = GetDeviceCaps(wdc, VERTRES);// - 8;
/*
@


1.3
log
@Tooltips fixes
@
text
@d102 1
a102 1
	TRACE(_T("CPPToolTip::Create\n"));
d157 1
a157 1
	TRACE(_T("CPPToolTip::SendNotify()\n")); 
d438 1
a438 1
	TRACE (_T("CPPToolTip::SetNewToolTip(Index = 0x%X)\n"), nIndexTool);
d466 1
a466 1
		TRACE(_T("OnTimerShow\n"));
d483 1
a483 1
		TRACE(_T("OnTimerHide\n"));
d531 1
a531 1
	TRACE (_T("CPPToolTip::DisplayToolTip()\n"));
d2066 1
a2066 1
	TRACE(_T("CPPToolTip::SetStyles()\n"));
d2115 1
a2115 1
	TRACE(_T("CPPToolTip::GetStyles()\n"));
d2139 1
a2139 1
	TRACE(_T("CPPToolTip::SetDefaultStyles()\n"));
d2159 1
a2159 1
	TRACE (_T("CPPToolTip::SetColor(nIndex = %d)\n"), nIndex);
d2180 1
a2180 1
	TRACE (_T("CPPToolTip::GetColor(nIndex = %d)\n"), nIndex);
d2201 1
a2201 1
	TRACE (_T("CPPToolTip::SetDefaultColors\n"));
d2244 1
a2244 1
	TRACE (_T("CPPToolTip::SetGradientColors\n"));
d2277 1
a2277 1
	TRACE (_T("CPPToolTip::GetGradientColors\n"));
d2333 1
a2333 1
	TRACE (_T("CPPToolTip::SetEffectBk\n"));
d2382 1
a2382 1
	TRACE (_T("CPPToolTip::GetEffectBk\n"));
d2428 1
a2428 1
	TRACE(_T("CPPToolTip::SetNotify\n"));
d2443 1
a2443 1
	TRACE(_T("CPPToolTip::GetNotify\n"));
d2542 1
a2542 1
	TRACE(_T("CPPToolTip::SetSize(nSizeIndex = %d, nValue = %d)\n"), nSizeIndex, nValue);
d2562 1
a2562 1
	TRACE(_T("CPPToolTip::GetSize(nSizeIndex = %d)\n"), nSizeIndex);
d2579 1
a2579 1
	TRACE(_T("CPPToolTip::SetDefaultSizes()\n"));
d2624 1
a2624 1
	TRACE(_T("CPPToolTip::SetDirection(nDirection = %d)\n"), nDirection);
d2653 1
a2653 1
	TRACE(_T("CPPToolTip::GetDirection()\n"));
d2679 1
a2679 1
	TRACE(_T("CPPToolTip::SetBehaviour(nBehaviour = 0x%X)\n"), nBehaviour);
d2702 1
a2702 1
	TRACE(_T("CPPToolTip::GetBehaviour()\n"));
d2765 1
a2765 1
	TRACE(_T("CPPToolTip::SetFont()\n"));
d2786 1
a2786 1
	TRACE(_T("CPPToolTip::SetFont()\n"));
d2811 1
a2811 1
	TRACE(_T("CPPToolTip::SetFont()\n"));
d2840 1
a2840 1
	TRACE(_T("CPPToolTip::SetDefaultFont()\n"));
d3012 1
a3012 1
	TRACE (_T("CPPToolTip::AddTool = 0x%X\n"), ti.hWnd); 
d3155 1
a3155 1
	TRACE (_T("CPPToolTip::RemoveTool\n"));
d3178 1
a3178 1
	TRACE (_T("CPPToolTip::RemoveAllTools\n"));
d3314 1
a3314 1
	TRACE(_T("ShowHelpTooltip()\n"));
@


1.2
log
@Fixes for tooltips
@
text
@d261 1
a261 1
		pDC->DrawState(ptIcon, m_szToolIcon, m_pToolInfo.hIcon, DSS_NORMAL, (CBrush*)NULL);
d264 3
a266 2
//		DrawIconEx(pDC->m_hDC, ptIcon.x, ptIcon.y, m_pToolInfo.hIcon, m_szToolIcon.cx, 
//			m_szToolIcon.cy, 0, NULL, DI_NORMAL);
d268 1
a268 1
		rect.left += m_szToolIcon.cx + m_nSizes[PPTTSZ_MARGIN_CX]; 
@


1.1
log
@Enhanced tooltips by JoeyRamone
@
text
@d2140 1
a2140 1
	SetStyles(PPTOOLTIP_BALLOON | PPTOOLTIP_ICON_VCENTER_ALIGN, nIndexTool);
@

