head	1.7;
access;
symbols
	PublicRelease_1_2e:1.7
	Interim_Release_1-2e_RC1:1.7
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.7
	Interim_Release_1-2c_RC1:1.7
	Interim_Release_1-2c_beta1:1.5
	PublicRelease_1_2b:1.5
	Interim_Release_1-2b_RC1:1.5
	PublicRelease_1_2a:1.5
	Interim_Release_1-2a_RC1:1.5
	Interim_Release_1-2a_beta2:1.5
	Interim_Release_1-2a_beta1:1.5
	PublicRelease_1_2:1.5
	Interim_Release_1-2_RC1:1.5
	Interim_Release_1-2_beta1:1.5
	PublicRelease_1_1g:1.5
	Interim_Release_1-1g_RC3:1.5
	Interim_Release_1-1g_RC2:1.5
	Interim_Release_1-1g_RC1:1.5
	Interim_Release_1-1g_beta2:1.5
	Interim_Release_1-1g_beta1:1.5
	Interim_Release_1-1f_RC1:1.5
	PublicRelease_1_1e:1.5
	Interim_Release_1-1e_RC2:1.5
	Interim_Release_1-1e_RC1:1.5
	Interim_Release_1-1e_beta1:1.5
	PublicRelease_1_1d:1.5
	Interim_Release_1-1d_RC1:1.5
	PublicRelease_1_1c:1.5
	Interim_Release_1-1c_RC1:1.5
	Interim_Release_1-1c_beta2:1.5
	Interim_Release_1-1c_beta1:1.5
	PublicRelease_1_1b:1.5
	Interim_Release_1-1b_RC1:1.5
	PublicRelease_1_1a:1.5
	Interim_Release_1-1a_RC2:1.5
	Interim_Release_1-1a_RC1:1.5
	Interim_Release_1-1a_beta2:1.5
	Interim_Release_1-1a_beta1:1.5
	PublicRelease_1_1:1.5
	Interim_Release_1-1_beta1:1.5
	PublicRelease_1o:1.5
	Interim_Release_1o_RC1:1.5
	Interim_Release_1o_beta1:1.5
	PublicRelease_1n:1.5
	Interim_Release_1n_RC2:1.5
	Interim_Release_1n_RC1:1.5
	PublicRelease_1m:1.5
	Interim_Release_1m_beta1:1.5
	PublicRelease_1l:1.5
	Interim_Release_1l_RC3:1.5
	Interim_Release_1l_RC2:1.5
	Interim_Release_1l_RC1:1.5
	Interim_Release_1l_beta2:1.5
	Interim_Release_1l_beta1:1.5
	PublicRelease_1k:1.5
	Interim_Release_1k_RC4:1.5
	Interim_1k_RC3:1.5
	Interim_1k_RC2:1.5
	Interim_Release_1k_RC1:1.5
	Interim_Release_1k_beta5:1.5
	Intrerim_Release_1k_beta4:1.5
	Interim_Release_1k_beta1:1.5
	PublicRelease_1j:1.4
	Interim_Release_1J_RC3:1.4
	Interim_Release_1j_RC3:1.4
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.4
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.4
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1;
locks; strict;
comment	@// @;


1.7
date	2007.07.27.06.21.22;	author aw3;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.24.00.54.51;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.11.04.13.04;	author katsyonak;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.14.18.41.01;	author syrus77;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.21.22.06.14;	author morevit;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.11.18.53.16;	author eklmn;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.12.13.22.16;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Suppressed level 4 warnings.
@
text
@#include "stdafx.h"
#include "CeXDib.h"
#include "..\otherfunctions.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CCeXDib::CCeXDib()
{
	m_hDib = NULL;
	m_dwLineWidth = 0;
	m_wColors = 0;

	m_hMemDC = NULL;
	m_hBitmap = NULL;
	m_lpBits = NULL;

	FreeResources();
}

CCeXDib::~CCeXDib()
{
	FreeResources();
}

void CCeXDib::FreeResources()
{
	if (m_hMemDC)	
		::DeleteDC(m_hMemDC);
	if (m_hBitmap)	
		::DeleteObject(m_hBitmap);
	if (m_hDib)		
		delete m_hDib;

	m_hDib = NULL;
	m_hMemDC = NULL;
	m_hBitmap = NULL;
	m_lpBits = NULL;
	memzero(&m_bi, sizeof(m_bi));
} // End of FreeResources

HDIB CCeXDib::Create(DWORD dwWidth, DWORD dwHeight, WORD wBitCount)
{
    LPBITMAPINFOHEADER  lpbi = NULL;	// Pointer to BITMAPINFOHEADER
    DWORD               dwLen = 0;		// Size of memory block

	FreeResources();

	// Following <switch> is taken from
	// CDIBSectionLite class by Chris Maunder
    switch (wBitCount) 
    {
	    case 1:  m_wColors = 2;   break;
#ifdef _WIN32_WCE
        case 2:  m_wColors = 4;   break;   // winCE only       
#endif
        case 4:  m_wColors = 16;  break;
        case 8:  m_wColors = 256; break;
        case 16:
        case 24:
        case 32: m_wColors = 0;   break;   // 16,24 or 32 bpp have no color table

        default:
           m_wColors = 0;
    } // switch
/*
    // Make sure bits per pixel is valid
    if (wBitCount <= 1)			wBitCount = 1;
    else if (wBitCount <= 4)	wBitCount = 4;
    else if (wBitCount <= 8)	wBitCount = 8;
    else				        wBitCount = 24;

    switch (wBitCount)
	{
        case 1:
            m_wColors = 2;
			break;
        case 4:
            m_wColors = 16;
			break;
        case 8:
            m_wColors = 256;
			break;
        default:
            m_wColors = 0;
			break;
    } // switch
*/
    m_dwLineWidth = WIDTHBYTES(wBitCount * dwWidth);

    // Initialize BITMAPINFOHEADER
    m_bi.biSize = sizeof(BITMAPINFOHEADER);
    m_bi.biWidth = dwWidth;         // fill in width from parameter
    m_bi.biHeight = dwHeight;       // fill in height from parameter
    m_bi.biPlanes = 1;              // must be 1
    m_bi.biBitCount = wBitCount;    // from parameter
    m_bi.biCompression = BI_RGB;    
    m_bi.biSizeImage = m_dwLineWidth * dwHeight;
    m_bi.biXPelsPerMeter = 0;
    m_bi.biYPelsPerMeter = 0;
    m_bi.biClrUsed = 0;
    m_bi.biClrImportant = 0;

    // Calculate size of memory block required to store the DIB.  This
    // block should be big enough to hold the BITMAPINFOHEADER, the color
    // table, and the bits.
    dwLen = GetSize();

	m_hDib = new HDIB[dwLen]; // Allocate memory block to store our bitmap
    if (m_hDib == NULL) return NULL;

    // Use our bitmap info structure to fill in first part of
    // our DIB with the BITMAPINFOHEADER
	lpbi = (LPBITMAPINFOHEADER)(m_hDib);
    *lpbi = m_bi;

    return m_hDib; // Return handle to the DIB
} // End of Create

DWORD CCeXDib::GetSize()
{
	return m_bi.biSize + m_bi.biSizeImage + GetPaletteSize();
} // End of GetSize

DWORD CCeXDib::GetPaletteSize()
{
	return (m_wColors * sizeof(RGBQUAD));
} // End of GetPaletteSize

LPBYTE CCeXDib::GetBits()
{
	if (m_hDib)	
		return ((LPBYTE)m_hDib + *(LPDWORD)m_hDib + GetPaletteSize()); 

	return NULL;
} // End of GetBits

DWORD CCeXDib::GetWidth()
{
	return m_bi.biWidth;
} // End of GetWidth

DWORD CCeXDib::GetHeight()
{
	return m_bi.biHeight;
} // End of GetHeight

DWORD CCeXDib::GetLineWidth()
{
	return m_dwLineWidth;
} // End of GetLineWidth

void CCeXDib::BlendPalette(COLORREF crColor, DWORD dwPerc)
{
	if (m_hDib == NULL || m_wColors == 0) 
		return;

	LPBYTE iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);

	long i,r,g,b;

	RGBQUAD* pPal = (RGBQUAD*)iDst;

	r = GetRValue(crColor);
	g = GetGValue(crColor);
	b = GetBValue(crColor);

	if (dwPerc > 100) 
		dwPerc = 100;

	for (i = 0; i < m_wColors; i++)
	{
		pPal[i].rgbBlue = (BYTE)((pPal[i].rgbBlue * (100 - dwPerc) + b * dwPerc) / 100);
		pPal[i].rgbGreen = (BYTE)((pPal[i].rgbGreen * (100 - dwPerc) + g * dwPerc) / 100);
		pPal[i].rgbRed = (BYTE)((pPal[i].rgbRed * (100 - dwPerc) + r * dwPerc) / 100);
	} // for
} // End of BlendPalette

void CCeXDib::Clear(BYTE byVal)
{
	if (m_hDib)
		memset2(GetBits(), byVal, m_bi.biSizeImage);
} // End of Clear

void CCeXDib::SetPixelIndex(DWORD dwX, DWORD dwY, BYTE byI)
{
	if ((m_hDib == NULL) || (m_wColors == 0) ||
		((long)dwX < 0) || ((long)dwY < 0) || (dwX >= (DWORD)m_bi.biWidth) || (dwY >= (DWORD)m_bi.biHeight)) return;

	LPBYTE iDst = GetBits();
	iDst[(m_bi.biHeight - dwY - 1) * m_dwLineWidth + dwX] = byI;
} // End of SetPixelIndex

void CCeXDib::Clone(CCeXDib* src)
{
	Create(src->GetWidth(), src->GetHeight(), src->GetBitCount());
	if (m_hDib)
		memcpy2(m_hDib, src->m_hDib, GetSize());
} // End of Clone

WORD CCeXDib::GetBitCount()
{
	return m_bi.biBitCount;
} // End of GetBitCount

void CCeXDib::SetPaletteIndex(BYTE byIdx, BYTE byR, BYTE byG, BYTE byB)
{
	if (m_hDib && m_wColors)
	{
		LPBYTE iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);
		if ((byIdx >= 0) && (byIdx < m_wColors))
		{	
			long ldx = byIdx * sizeof(RGBQUAD);
			iDst[ldx++] = (BYTE)byB;
			iDst[ldx++] = (BYTE)byG;
			iDst[ldx++] = (BYTE)byR;
			iDst[ldx] = (BYTE)0;
		} // if
	} // if
} // End of SetPaletteIndex

void CCeXDib::Draw(HDC hDC, DWORD dwX, DWORD dwY)
{
	HBITMAP	hOldBitmap = NULL;

	if (m_hBitmap == NULL)
	{
		m_hBitmap = CreateDIBSection(hDC, (BITMAPINFO*)m_hDib, DIB_RGB_COLORS, &m_lpBits, NULL, 0);
		if (m_hBitmap == NULL)	return;
		if (m_lpBits == NULL)
		{
			::DeleteObject(m_hBitmap);
			m_hBitmap = NULL;
			return;
		} // if
	} // if
	memcpy2(m_lpBits, GetBits(), m_bi.biSizeImage);

	if (m_hMemDC == NULL)
	{
		m_hMemDC = CreateCompatibleDC(hDC);
		if (m_hMemDC == NULL)	return;
	} // if

	hOldBitmap = (HBITMAP)SelectObject(m_hMemDC, m_hBitmap);

	BitBlt(hDC, dwX, dwY, m_bi.biWidth, m_bi.biHeight, m_hMemDC, 0, 0, SRCCOPY);

	SelectObject(m_hMemDC, hOldBitmap);
} // End of Draw

void CCeXDib::SetGrayPalette()
{
	RGBQUAD		pal[256];
	RGBQUAD*	ppal;
	LPBYTE		iDst;
	int			ni;

	if (m_hDib == NULL || m_wColors == 0) return;

	ppal = (RGBQUAD*)&pal[0];
	iDst = (LPBYTE)(m_hDib) + sizeof(BITMAPINFOHEADER);
	for (ni = 0; ni < m_wColors; ni++)
	{
		pal[ni] = RGB2RGBQUAD(RGB(ni,ni,ni));
	} // for

	pal[0] = RGB2RGBQUAD(RGB(0,0,0));
	pal[m_wColors-1] = RGB2RGBQUAD(RGB(255,255,255));

	memcpy2(iDst, ppal, GetPaletteSize());
} // End of SetGrayPalette

RGBQUAD CCeXDib::RGB2RGBQUAD(COLORREF cr)
{
	RGBQUAD c;
	c.rgbRed = GetRValue(cr);	/* get R, G, and B out of DWORD */
	c.rgbGreen = GetGValue(cr);
	c.rgbBlue = GetBValue(cr);
	c.rgbReserved=0;
	return c;
} // End of RGB2RGBQUAD

WORD CCeXDib::GetNumColors()
{
	return m_wColors;
} // End of GetNumColors

BOOL CCeXDib::WriteBMP(LPCTSTR bmpFileName)
{
	BITMAPFILEHEADER	hdr;
	HANDLE	hFile;
	DWORD	nByteWrite;

	if (*bmpFileName == _T('\0') || m_hDib == 0) return 0;

	hFile=CreateFile(			// open if exist ini file
		bmpFileName,			// pointer to name of the file 
		GENERIC_WRITE,			// access mode 
		0,						// share mode 
		NULL,					// pointer to security descriptor 
		CREATE_ALWAYS,			// how to create 
		FILE_ATTRIBUTE_NORMAL,	// file attributes 
		NULL				 	// handle to file with attributes to copy  
		);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;

    // Fill in the fields of the file header
	hdr.bfType = BFT_BITMAP;
	hdr.bfSize = GetSize() + sizeof(BITMAPFILEHEADER);
	hdr.bfReserved1 = hdr.bfReserved2 = 0;
	hdr.bfOffBits = (DWORD) sizeof(BITMAPFILEHEADER)+
					m_bi.biSize + GetPaletteSize();

    // Write the file header
	WriteFile(						// write ini (sync mode <-> no overlapped)
		hFile,						// handle of file to write 
		(LPSTR) &hdr,				// address of buffer that contains data  
		sizeof(BITMAPFILEHEADER),	// number of bytes to write 
		&nByteWrite,				// address of number of bytes written 
		NULL	 					// address of structure for data 
		);

    // Write the DIB header and the bits
	WriteFile(						// write ini (sync mode <-> no overlapped)
		hFile,						// handle of file to write 
		(LPSTR) m_hDib,				// address of buffer that contains data  
		GetSize(),					// number of bytes to write 
		&nByteWrite,				// address of number of bytes written 
		NULL	 					// address of structure for data 
		);

	CloseHandle(hFile);				// free file handle

	return TRUE;
} // End of WriteBMP
@


1.6
log
@Updated (actually only formatting) to the last public version.
@
text
@a226 1
	HBITMAP	hBitmap = NULL;
a227 1
	HDC		hMemDC = NULL;
@


1.5
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d31 6
a36 3
	if (m_hMemDC)	::DeleteDC(m_hMemDC);
	if (m_hBitmap)	::DeleteObject(m_hBitmap);
	if (m_hDib)		delete m_hDib;
d135 2
a136 1
	if (m_hDib)	return ((LPBYTE)m_hDib + *(LPDWORD)m_hDib + GetPaletteSize()); 
d158 2
a159 1
	if (m_hDib == NULL || m_wColors == 0) return;
d171 2
a172 1
	if (dwPerc > 100) dwPerc = 100;
d200 2
a201 1
	if (m_hDib) memcpy2(m_hDib, src->m_hDib, GetSize());
@


1.4
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d39 1
a39 1
	memset2(&m_bi, 0, sizeof(m_bi));
@


1.3
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d39 1
a39 1
	memset(&m_bi, 0, sizeof(m_bi));
d178 2
a179 1
	if (m_hDib) memset(GetBits(), byVal, m_bi.biSizeImage);
@


1.2
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d3 1
a3 1
#include "..\memcpy_amd.h"
d193 1
a193 5
	#ifndef AMD
	if (m_hDib) memcpy(m_hDib, src->m_hDib, GetSize());
	#else
	if (m_hDib) memcpy_amd(m_hDib, src->m_hDib, GetSize());
	#endif
d234 1
a234 5
	#ifndef AMD
	memcpy(m_lpBits, GetBits(), m_bi.biSizeImage);
	#else
	memcpy_amd(m_lpBits, GetBits(), m_bi.biSizeImage);
	#endif
d268 1
a268 5
	#ifndef AMD
	memcpy(iDst, ppal, GetPaletteSize());
	#else
	memcpy_amd(iDst, ppal, GetPaletteSize());
	#endif
@


1.1
log
@Enhanced tooltips by JoeyRamone
@
text
@d3 1
d193 1
d195 3
d238 5
a242 2

    memcpy(m_lpBits, GetBits(), m_bi.biSizeImage);
d276 1
d278 3
@

