head	1.297;
access;
symbols
	PublicRelease_1_2e:1.288
	Interim_Release_1-2e_RC1:1.286
	PublicRelease_1_2d:1.279
	Interim_Release_1-2d_RC1:1.279
	Interim_Release_1-2d_beta1:1.279
	PublicRelease_1_2c:1.277
	Interim_Release_1-2c_RC1:1.277
	Interim_Release_1-2c_beta1:1.272
	PublicRelease_1_2b:1.272
	Interim_Release_1-2b_RC1:1.272
	PublicRelease_1_2a:1.269
	Interim_Release_1-2a_RC1:1.269
	Interim_Release_1-2a_beta2:1.267
	Interim_Release_1-2a_beta1:1.265
	PublicRelease_1_2:1.262
	Interim_Release_1-2_RC1:1.262
	Interim_Release_1-2_beta1:1.260
	PublicRelease_1_1g:1.259
	Interim_Release_1-1g_RC3:1.259
	Interim_Release_1-1g_RC2:1.258
	Interim_Release_1-1g_RC1:1.258
	Interim_Release_1-1g_beta2:1.255
	Interim_Release_1-1g_beta1:1.242
	PublicRelease_1_1f:1.238
	Interim_Release_1-1f_RC1:1.238
	PublicRelease_1_1e:1.237
	Interim_Release_1-1e_RC2:1.237
	Interim_Release_1-1e_RC1:1.236
	Interim_Release_1-1e_beta1:1.235
	PublicRelease_1_1d:1.233
	Interim_Release_1-1d_RC1:1.232
	PublicRelease_1_1c:1.231
	Interim_Release_1-1c_RC1:1.231
	Interim_Release_1-1c_beta2:1.231
	Interim_Release_1-1c_beta1:1.229
	PublicRelease_1_1b:1.226
	Interim_Release_1-1b_RC1:1.226
	PublicRelease_1_1a:1.225
	Interim_Release_1-1a_RC2:1.225
	Interim_Release_1-1a_RC1:1.224
	Interim_Release_1-1a_beta2:1.224
	Interim_Release_1-1a_beta1:1.224
	PublicRelease_1_1:1.223
	Interim_Release_1-1_beta1:1.223
	PublicRelease_1o:1.220
	Interim_Release_1o_RC1:1.220
	Interim_Release_1o_beta1:1.220
	PublicRelease_1n:1.218
	Interim_Release_1n_RC2:1.218
	Interim_Release_1n_RC1:1.216
	Interim_Release_1n_beta2:1.216
	Interim_Release_1n_beta1:1.214
	PublicRelease_1m:1.212
	Interim_Release_1m_beta1:1.212
	PublicRelease_1l:1.211
	Interim_Release_1l_RC3:1.211
	Interim_Release_1l_RC2:1.211
	Interim_Release_1l_RC1:1.211
	Interim_Release_1l_beta2:1.207
	Interim_Release_1l_beta1:1.201
	PublicRelease_1k:1.196
	Interim_Release_1k_RC4:1.196
	Interim_1k_RC3:1.195
	Interim_1k_RC2:1.194
	Interim_Release_1k_RC1:1.194
	Interim_Release_1k_beta5:1.194
	Intrerim_Release_1k_beta4:1.194
	Interim_Release_1k_beta1:1.186
	PublicRelease_1j:1.165
	Interim_Release_1J_RC3:1.165
	Interim_Release_1j_RC3:1.164
	Interim_Release_1j_RC2:1.163
	Interim_Release_1j_RC1:1.162
	Interim_Release_1j_beta2:1.161
	Interim_Release_1j_beta1:1.150
	PublicRelease_1i:1.147
	Interim_Release_1i_RC6:1.147
	Interim_Release_1i_RC3:1.144
	Interim_Release_1i_RC2:1.144
	Interim_Release_1i_RC1:1.139
	Interim_Release_1i_beta3:1.136
	Interim_Release_1i_beta2:1.129
	Interim_Release_1i_beta1:1.116
	PublicRelease_1h:1.98
	Interim_Release_1h_rc2:1.98
	Interim_Release_1h_RC1:1.96
	Interim_Release_1h_beta2:1.91
	Interim_Release_1h_beta1_now:1.84
	Interim_Release_1h_beta1:1.84
	PublicRelease_1g:1.78
	Interim_Release_1g_RC6_Final:1.78
	Interim_Release_1g_RC6:1.73
	Interim_Release_1g_RC5:1.73
	Interim_Release_1g_RC4:1.70
	Interim_Release_1g_RC3:1.68
	Interim_Release_1g_beta2:1.52
	Interim_Release_1g_beta1:1.51
	Interim_Release_1f_RC4:1.50
	Interim_Release_1f_RC3:1.50
	Interim_Release_1f_RC2:1.48
	Interim_Release_1f_RC:1.48
	Interim_Release_1f_beta2:1.48
	Interim_Release_1f_beta1:1.48
	PublicRelease_1e:1.46
	Interim_Release_1e_RC2:1.46
	Interim_Release_1e_RC:1.46
	Interim_Release_1e_beta3:1.45
	Interim_Release_1e_beta2:1.45
	Interim_Release_1e_beta2_before_kuchin:1.44
	Interim_Release_1e_beta1:1.42
	PublicRelease_1c:1.41
	featurestest:1.41.0.2
	Interim_Release_1c_RC:1.41
	Interim_Release_1c_beta2:1.39
	Interim_Release_1c_beta1:1.37
	threaded_downloadqueue:1.37.0.2
	PublicRelease_1b:1.32
	Interim_Release_1b_beta2:1.32
	Interim_Release_1b_beta1:1.27
	proxydeadlake:1.22.0.2
	PublicRelease_1a:1.22
	Interim_Release_1a_beta2:1.20
	BerkeleyDb:1.18.0.2
	Interim_Release_1a_beta1:1.18
	PublicRelease_1:1.17
	goldfish:1.17
	eMulePlus_1_RC2:1.16
	eMulePlus_26b_1RC1:1.16
	PreRelease_26b_i0e:1.16
	before_26d_merge:1.14
	Interim_Release_26b_i0d:1.13
	Interim_Release_26b_i0c:1.12
	Interim_Release_26b_i0b:1.12
	Interim_Release_26b_i0a:1.12
	systraydlg:1.9.0.4
	plus26based:1.9.0.2
	Interim_Release_25b_i0b:1.9
	Proxy_Dev:1.8
	Interim_Release_25b_i0a:1.7.2.4
	proxytest:1.7.2.1.0.2
	official_sockets:1.7.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.297
date	2009.10.28.04.34.58;	author aw3;	state Exp;
branches;
next	1.296;

1.296
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.295;

1.295
date	2009.07.19.14.48.38;	author aw3;	state Exp;
branches;
next	1.294;

1.294
date	2009.07.15.02.23.48;	author aw3;	state Exp;
branches;
next	1.293;

1.293
date	2009.06.23.03.44.13;	author aw3;	state Exp;
branches;
next	1.292;

1.292
date	2009.06.06.19.59.20;	author aw3;	state Exp;
branches;
next	1.291;

1.291
date	2009.06.02.02.19.29;	author aw3;	state Exp;
branches;
next	1.290;

1.290
date	2009.05.16.22.15.21;	author aw3;	state Exp;
branches;
next	1.289;

1.289
date	2009.04.21.03.14.55;	author aw3;	state Exp;
branches;
next	1.288;

1.288
date	2009.04.08.04.05.38;	author aw3;	state Exp;
branches;
next	1.287;

1.287
date	2009.04.03.01.29.59;	author aw3;	state Exp;
branches;
next	1.286;

1.286
date	2009.03.21.22.47.43;	author aw3;	state Exp;
branches;
next	1.285;

1.285
date	2009.03.20.02.52.23;	author aw3;	state Exp;
branches;
next	1.284;

1.284
date	2008.12.01.18.08.08;	author kush_eplus;	state Exp;
branches;
next	1.283;

1.283
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.282;

1.282
date	2008.10.17.04.52.02;	author aw3;	state Exp;
branches;
next	1.281;

1.281
date	2008.09.29.22.49.33;	author aw3;	state Exp;
branches;
next	1.280;

1.280
date	2008.08.05.04.15.22;	author aw3;	state Exp;
branches;
next	1.279;

1.279
date	2007.10.31.18.25.07;	author fuxie-dk;	state Exp;
branches;
next	1.278;

1.278
date	2007.09.27.14.26.40;	author fuxie-dk;	state Exp;
branches;
next	1.277;

1.277
date	2007.07.27.06.21.18;	author aw3;	state Exp;
branches;
next	1.276;

1.276
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.275;

1.275
date	2007.06.14.02.58.45;	author aw3;	state Exp;
branches;
next	1.274;

1.274
date	2007.06.04.01.32.15;	author aw3;	state Exp;
branches;
next	1.273;

1.273
date	2007.04.18.00.23.36;	author aw3;	state Exp;
branches;
next	1.272;

1.272
date	2007.01.17.07.51.48;	author aw3;	state Exp;
branches;
next	1.271;

1.271
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.270;

1.270
date	2006.11.05.05.01.44;	author aw3;	state Exp;
branches;
next	1.269;

1.269
date	2006.08.08.05.59.59;	author aw3;	state Exp;
branches;
next	1.268;

1.268
date	2006.07.14.04.49.06;	author aw3;	state Exp;
branches;
next	1.267;

1.267
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.266;

1.266
date	2006.05.21.06.14.29;	author aw3;	state Exp;
branches;
next	1.265;

1.265
date	2006.04.18.15.46.48;	author eklmn;	state Exp;
branches;
next	1.264;

1.264
date	2006.04.04.22.28.40;	author kush_eplus;	state Exp;
branches;
next	1.263;

1.263
date	2006.03.27.02.54.11;	author aw3;	state Exp;
branches;
next	1.262;

1.262
date	2006.02.12.17.40.29;	author eklmn;	state Exp;
branches;
next	1.261;

1.261
date	2006.02.10.17.09.41;	author eklmn;	state Exp;
branches;
next	1.260;

1.260
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.259;

1.259
date	2005.12.11.00.10.28;	author aw3;	state Exp;
branches;
next	1.258;

1.258
date	2005.11.28.05.27.37;	author aw3;	state Exp;
branches;
next	1.257;

1.257
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.256;

1.256
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.255;

1.255
date	2005.11.25.05.11.43;	author aw3;	state Exp;
branches;
next	1.254;

1.254
date	2005.11.23.04.00.31;	author aw3;	state Exp;
branches;
next	1.253;

1.253
date	2005.11.16.20.55.30;	author eklmn;	state Exp;
branches;
next	1.252;

1.252
date	2005.11.16.05.59.22;	author aw3;	state Exp;
branches;
next	1.251;

1.251
date	2005.11.15.06.03.41;	author aw3;	state Exp;
branches;
next	1.250;

1.250
date	2005.11.11.05.54.31;	author aw3;	state Exp;
branches;
next	1.249;

1.249
date	2005.10.04.03.27.25;	author aw3;	state Exp;
branches;
next	1.248;

1.248
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.247;

1.247
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.246;

1.246
date	2005.09.13.05.59.18;	author aw3;	state Exp;
branches;
next	1.245;

1.245
date	2005.09.02.05.14.12;	author aw3;	state Exp;
branches;
next	1.244;

1.244
date	2005.08.27.15.08.17;	author aw3;	state Exp;
branches;
next	1.243;

1.243
date	2005.08.25.11.57.47;	author aw3;	state Exp;
branches;
next	1.242;

1.242
date	2005.08.21.21.26.40;	author eklmn;	state Exp;
branches;
next	1.241;

1.241
date	2005.08.12.03.43.07;	author aw3;	state Exp;
branches;
next	1.240;

1.240
date	2005.08.11.05.19.37;	author aw3;	state Exp;
branches;
next	1.239;

1.239
date	2005.08.07.06.46.03;	author aw3;	state Exp;
branches;
next	1.238;

1.238
date	2005.07.25.03.40.19;	author aw3;	state Exp;
branches;
next	1.237;

1.237
date	2005.06.28.03.54.20;	author aw3;	state Exp;
branches;
next	1.236;

1.236
date	2005.06.18.01.02.44;	author aw3;	state Exp;
branches;
next	1.235;

1.235
date	2005.05.01.23.14.59;	author aw3;	state Exp;
branches;
next	1.234;

1.234
date	2005.03.23.04.56.59;	author aw3;	state Exp;
branches;
next	1.233;

1.233
date	2005.03.19.09.39.17;	author bavariansnail;	state Exp;
branches;
next	1.232;

1.232
date	2005.03.06.21.59.24;	author aw3;	state Exp;
branches;
next	1.231;

1.231
date	2005.02.13.22.58.10;	author aw3;	state Exp;
branches;
next	1.230;

1.230
date	2005.02.09.23.10.08;	author aw3;	state Exp;
branches;
next	1.229;

1.229
date	2005.01.28.19.36.49;	author aw3;	state Exp;
branches;
next	1.228;

1.228
date	2005.01.19.10.48.08;	author dongato;	state Exp;
branches;
next	1.227;

1.227
date	2005.01.16.00.34.59;	author netwolf1;	state Exp;
branches;
next	1.226;

1.226
date	2004.12.13.05.25.08;	author aw3;	state Exp;
branches;
next	1.225;

1.225
date	2004.12.06.17.55.48;	author dongato;	state Exp;
branches;
next	1.224;

1.224
date	2004.10.31.11.18.36;	author dongato;	state Exp;
branches;
next	1.223;

1.223
date	2004.10.14.05.19.25;	author aw3;	state Exp;
branches;
next	1.222;

1.222
date	2004.10.08.04.35.58;	author aw3;	state Exp;
branches;
next	1.221;

1.221
date	2004.10.08.03.28.31;	author dongato;	state Exp;
branches;
next	1.220;

1.220
date	2004.09.24.03.19.09;	author aw3;	state Exp;
branches;
next	1.219;

1.219
date	2004.09.15.18.56.52;	author aw3;	state Exp;
branches;
next	1.218;

1.218
date	2004.08.31.07.47.34;	author eklmn;	state Exp;
branches;
next	1.217;

1.217
date	2004.08.31.05.18.05;	author eklmn;	state Exp;
branches;
next	1.216;

1.216
date	2004.08.07.08.51.53;	author eklmn;	state Exp;
branches;
next	1.215;

1.215
date	2004.07.25.15.00.26;	author dongato;	state Exp;
branches;
next	1.214;

1.214
date	2004.07.18.18.31.30;	author eklmn;	state Exp;
branches;
next	1.213;

1.213
date	2004.06.30.13.38.40;	author dongato;	state Exp;
branches;
next	1.212;

1.212
date	2004.06.17.12.41.28;	author netwolf1;	state Exp;
branches;
next	1.211;

1.211
date	2004.05.25.03.23.35;	author kush_eplus;	state Exp;
branches;
next	1.210;

1.210
date	2004.05.24.11.37.29;	author netwolf1;	state Exp;
branches;
next	1.209;

1.209
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.208;

1.208
date	2004.05.23.13.51.09;	author bavariansnail;	state Exp;
branches;
next	1.207;

1.207
date	2004.05.21.20.06.04;	author dongato;	state Exp;
branches;
next	1.206;

1.206
date	2004.05.21.19.09.39;	author dongato;	state Exp;
branches;
next	1.205;

1.205
date	2004.05.21.14.37.56;	author dongato;	state Exp;
branches;
next	1.204;

1.204
date	2004.05.21.13.17.47;	author dongato;	state Exp;
branches;
next	1.203;

1.203
date	2004.05.19.10.14.23;	author netwolf1;	state Exp;
branches;
next	1.202;

1.202
date	2004.05.10.12.47.22;	author netwolf1;	state Exp;
branches;
next	1.201;

1.201
date	2004.05.05.02.22.51;	author netwolf1;	state Exp;
branches;
next	1.200;

1.200
date	2004.05.04.11.28.00;	author netwolf1;	state Exp;
branches;
next	1.199;

1.199
date	2004.05.03.08.24.59;	author katsyonak;	state Exp;
branches;
next	1.198;

1.198
date	2004.05.01.03.56.43;	author aw3;	state Exp;
branches;
next	1.197;

1.197
date	2004.04.18.13.17.30;	author bavariansnail;	state Exp;
branches;
next	1.196;

1.196
date	2004.04.06.09.14.30;	author eklmn;	state Exp;
branches;
next	1.195;

1.195
date	2004.04.03.12.45.35;	author dongato;	state Exp;
branches;
next	1.194;

1.194
date	2004.03.22.18.46.38;	author eklmn;	state Exp;
branches;
next	1.193;

1.193
date	2004.03.21.22.02.25;	author eklmn;	state Exp;
branches;
next	1.192;

1.192
date	2004.03.18.03.44.11;	author kush_eplus;	state Exp;
branches;
next	1.191;

1.191
date	2004.03.14.21.10.11;	author aw3;	state Exp;
branches;
next	1.190;

1.190
date	2004.03.12.11.10.20;	author eklmn;	state Exp;
branches;
next	1.189;

1.189
date	2004.02.29.04.51.38;	author aw3;	state Exp;
branches;
next	1.188;

1.188
date	2004.02.25.17.58.55;	author kush_eplus;	state Exp;
branches;
next	1.187;

1.187
date	2004.02.20.22.09.52;	author eklmn;	state Exp;
branches;
next	1.186;

1.186
date	2004.02.18.11.43.26;	author netwolf1;	state Exp;
branches;
next	1.185;

1.185
date	2004.02.15.19.48.35;	author eklmn;	state Exp;
branches;
next	1.184;

1.184
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.183;

1.183
date	2004.02.13.01.54.32;	author aw3;	state Exp;
branches;
next	1.182;

1.182
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.181;

1.181
date	2004.02.10.22.01.43;	author kush_eplus;	state Exp;
branches;
next	1.180;

1.180
date	2004.02.09.16.39.50;	author kush_eplus;	state Exp;
branches;
next	1.179;

1.179
date	2004.02.06.02.54.09;	author kush_eplus;	state Exp;
branches;
next	1.178;

1.178
date	2004.02.05.23.35.17;	author kush_eplus;	state Exp;
branches;
next	1.177;

1.177
date	2004.02.05.19.28.09;	author kush_eplus;	state Exp;
branches;
next	1.176;

1.176
date	2004.02.04.23.59.59;	author kush_eplus;	state Exp;
branches;
next	1.175;

1.175
date	2004.02.04.12.06.20;	author netwolf1;	state Exp;
branches;
next	1.174;

1.174
date	2004.02.03.23.36.52;	author netwolf1;	state Exp;
branches;
next	1.173;

1.173
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.172;

1.172
date	2004.02.02.08.43.01;	author kush_eplus;	state Exp;
branches;
next	1.171;

1.171
date	2004.02.01.12.14.30;	author netwolf1;	state Exp;
branches;
next	1.170;

1.170
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.169;

1.169
date	2004.01.27.14.03.00;	author dongato;	state Exp;
branches;
next	1.168;

1.168
date	2004.01.27.12.39.01;	author syrus77;	state Exp;
branches;
next	1.167;

1.167
date	2004.01.27.04.59.52;	author kush_eplus;	state Exp;
branches;
next	1.166;

1.166
date	2004.01.27.03.13.45;	author kush_eplus;	state Exp;
branches;
next	1.165;

1.165
date	2004.01.23.15.04.36;	author dongato;	state Exp;
branches;
next	1.164;

1.164
date	2004.01.23.13.38.02;	author dongato;	state Exp;
branches;
next	1.163;

1.163
date	2004.01.11.14.59.31;	author syrus77;	state Exp;
branches;
next	1.162;

1.162
date	2004.01.10.20.35.44;	author eklmn;	state Exp;
branches;
next	1.161;

1.161
date	2004.01.07.16.40.47;	author dongato;	state Exp;
branches;
next	1.160;

1.160
date	2004.01.07.15.41.49;	author dongato;	state Exp;
branches;
next	1.159;

1.159
date	2004.01.06.03.18.37;	author dongato;	state Exp;
branches;
next	1.158;

1.158
date	2004.01.05.21.38.36;	author dongato;	state Exp;
branches;
next	1.157;

1.157
date	2004.01.05.11.09.02;	author dongato;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.05.11.07.50;	author dongato;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.05.11.02.00;	author dongato;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.05.03.33.04;	author dongato;	state Exp;
branches;
next	1.153;

1.153
date	2004.01.04.15.56.06;	author dongato;	state Exp;
branches;
next	1.152;

1.152
date	2004.01.04.15.13.17;	author dongato;	state Exp;
branches;
next	1.151;

1.151
date	2004.01.04.04.25.35;	author dongato;	state Exp;
branches;
next	1.150;

1.150
date	2003.12.24.01.21.13;	author katsyonak;	state Exp;
branches;
next	1.149;

1.149
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.148;

1.148
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.147;

1.147
date	2003.11.24.19.25.55;	author eklmn;	state Exp;
branches;
next	1.146;

1.146
date	2003.11.23.00.03.43;	author syrus77;	state Exp;
branches;
next	1.145;

1.145
date	2003.11.21.13.21.50;	author bavariansnail;	state Exp;
branches;
next	1.144;

1.144
date	2003.11.17.17.20.58;	author eklmn;	state Exp;
branches;
next	1.143;

1.143
date	2003.11.08.14.59.12;	author eklmn;	state Exp;
branches;
next	1.142;

1.142
date	2003.11.08.00.13.48;	author eklmn;	state Exp;
branches;
next	1.141;

1.141
date	2003.11.07.22.49.54;	author eklmn;	state Exp;
branches;
next	1.140;

1.140
date	2003.11.07.22.21.47;	author eklmn;	state Exp;
branches;
next	1.139;

1.139
date	2003.11.02.13.52.21;	author dongato;	state Exp;
branches;
next	1.138;

1.138
date	2003.11.01.13.30.41;	author dongato;	state Exp;
branches;
next	1.137;

1.137
date	2003.10.31.23.01.59;	author eklmn;	state Exp;
branches;
next	1.136;

1.136
date	2003.10.31.06.46.59;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2003.10.29.18.18.51;	author dongato;	state Exp;
branches;
next	1.134;

1.134
date	2003.10.28.21.32.48;	author morevit;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.28.12.07.55;	author katsyonak;	state Exp;
branches;
next	1.132;

1.132
date	2003.10.27.17.25.09;	author eklmn;	state Exp;
branches;
next	1.131;

1.131
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.130;

1.130
date	2003.10.26.12.02.51;	author eklmn;	state Exp;
branches;
next	1.129;

1.129
date	2003.10.24.01.21.19;	author morevit;	state Exp;
branches;
next	1.128;

1.128
date	2003.10.21.16.45.06;	author dongato;	state Exp;
branches;
next	1.127;

1.127
date	2003.10.20.15.49.35;	author eklmn;	state Exp;
branches;
next	1.126;

1.126
date	2003.10.20.13.19.58;	author morevit;	state Exp;
branches;
next	1.125;

1.125
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.124;

1.124
date	2003.10.15.14.15.33;	author morevit;	state Exp;
branches;
next	1.123;

1.123
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.122;

1.122
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.121;

1.121
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.08.15.39.47;	author morevit;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.08.12.56.33;	author morevit;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.08.01.53.31;	author morevit;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.05.10.29.06;	author eklmn;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.04.16.54.07;	author dongato;	state Exp;
branches;
next	1.114;

1.114
date	2003.10.04.12.52.23;	author dongato;	state Exp;
branches;
next	1.113;

1.113
date	2003.10.03.21.38.46;	author dongato;	state Exp;
branches;
next	1.112;

1.112
date	2003.10.03.13.04.36;	author morevit;	state Exp;
branches;
next	1.111;

1.111
date	2003.10.02.00.58.14;	author morevit;	state Exp;
branches;
next	1.110;

1.110
date	2003.09.30.11.58.50;	author morevit;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.30.11.32.35;	author morevit;	state Exp;
branches;
next	1.108;

1.108
date	2003.09.30.06.58.44;	author dongato;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.29.14.55.45;	author morevit;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.24.16.45.13;	author morevit;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.23.16.52.49;	author morevit;	state Exp;
branches;
next	1.104;

1.104
date	2003.09.22.22.31.58;	author eklmn;	state Exp;
branches;
next	1.103;

1.103
date	2003.09.22.16.33.21;	author morevit;	state Exp;
branches;
next	1.102;

1.102
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.21.22.05.15;	author morevit;	state Exp;
branches;
next	1.100;

1.100
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.99;

1.99
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.98;

1.98
date	2003.09.16.14.12.54;	author kuchin;	state Exp;
branches;
next	1.97;

1.97
date	2003.09.16.13.29.08;	author kuchin;	state Exp;
branches;
next	1.96;

1.96
date	2003.09.09.21.36.02;	author dongato;	state Exp;
branches;
next	1.95;

1.95
date	2003.09.09.20.27.33;	author eklmn;	state Exp;
branches;
next	1.94;

1.94
date	2003.09.09.16.21.58;	author dongato;	state Exp;
branches;
next	1.93;

1.93
date	2003.09.09.01.16.58;	author dongato;	state Exp;
branches;
next	1.92;

1.92
date	2003.09.05.11.12.13;	author dongato;	state Exp;
branches;
next	1.91;

1.91
date	2003.09.04.03.53.30;	author dongato;	state Exp;
branches;
next	1.90;

1.90
date	2003.09.03.15.45.29;	author dongato;	state Exp;
branches;
next	1.89;

1.89
date	2003.09.02.18.28.57;	author puritynn666;	state Exp;
branches;
next	1.88;

1.88
date	2003.08.26.16.54.22;	author kuchin;	state Exp;
branches;
next	1.87;

1.87
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.86;

1.86
date	2003.08.21.20.38.44;	author dongato;	state Exp;
branches;
next	1.85;

1.85
date	2003.08.21.00.56.03;	author dongato;	state Exp;
branches;
next	1.84;

1.84
date	2003.08.10.14.12.51;	author zegzav;	state Exp;
branches;
next	1.83;

1.83
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.82;

1.82
date	2003.08.10.01.25.41;	author dongato;	state Exp;
branches;
next	1.81;

1.81
date	2003.08.03.20.42.05;	author forcha;	state Exp;
branches;
next	1.80;

1.80
date	2003.07.31.15.02.19;	author puritynn666;	state Exp;
branches;
next	1.79;

1.79
date	2003.07.30.12.29.31;	author kuchin;	state Exp;
branches;
next	1.78;

1.78
date	2003.07.24.19.35.58;	author partyckip;	state Exp;
branches;
next	1.77;

1.77
date	2003.07.24.17.17.17;	author eklmn;	state Exp;
branches;
next	1.76;

1.76
date	2003.07.22.16.36.28;	author eklmn;	state Exp;
branches;
next	1.75;

1.75
date	2003.07.22.05.06.20;	author partyckip;	state Exp;
branches;
next	1.74;

1.74
date	2003.07.21.15.57.20;	author eklmn;	state Exp;
branches;
next	1.73;

1.73
date	2003.07.12.14.10.37;	author dongato;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.12.06.16.37;	author eklmn;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.10.19.36.45;	author eklmn;	state Exp;
branches;
next	1.70;

1.70
date	2003.07.06.12.01.00;	author dongato;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.02.22.40.33;	author syrus77;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.02.15.49.26;	author eklmn;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.30.16.46.11;	author eklmn;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.28.18.17.24;	author eklmn;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.27.16.06.07;	author eklmn;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.22.09.35.43;	author eklmn;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.19.09.24.22;	author eklmn;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.18.21.44.25;	author eklmn;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.16.19.29.38;	author eklmn;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.16.15.37.42;	author netwolf1;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.15.07.41.36;	author eklmn;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.14.00.18.35;	author eklmn;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.13.17.14.15;	author eklmn;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.11.18.27.07;	author eklmn;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.10.20.53.01;	author eklmn;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.10.09.36.45;	author kuchin;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.30.21.26.58;	author partyckip;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.20.21.14.41;	author netwolf1;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.20.20.46.26;	author netwolf1;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.04.10.05.32;	author kuchin;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.29.08.37.43;	author kuchin;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.26.17.36.12;	author ultras;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.22.12.41.51;	author kuchin;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.20.17.27.35;	author kuchin;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.20.16.59.32;	author kuchin;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.25.12.39.35;	author cax2;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.21.17.24.43;	author cax2;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2003.03.21.12.10.19;	author partyckip;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.20.18.09.30;	author cax2;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.17.07.31.04;	author recdvst;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.14.16.24.17;	author partyckip;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.13.10.21.28;	author kuchin;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.10.18.00.11;	author cax2;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.10.16.19.54;	author kuchin;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.10.16.15.38;	author kuchin;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.08.12.09.41;	author recdvst;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.08.01.57.13;	author recdvst;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.07.14.48.22;	author moosetea;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.07.13.35.16;	author moosetea;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.07.12.51.54;	author kuchin;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.05.11.23.43;	author recdvst;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.04.22.57.43;	author moosetea;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.03.22.09.44;	author moosetea;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.28.13.15.02;	author cax2;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.28.11.15.45;	author cax2;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.27.19.15.50;	author cax2;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.27.10.02.10;	author cax2;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.26.03.26.50;	author cax2;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.25.18.08.00;	author cax2;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2003.02.20.23.21.18;	author cax2;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.17.14.59.25;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.12.20.18.22;	author obaldin;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.10.19.44.56;	author cax2;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.10.19.24.47;	author cax2;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.09.18.39.41;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.02.16.46.57;	author cax2;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2003.01.29.14.37.05;	author cax2;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.27.22.59.57;	author lord_kiron;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.01.26.23.54.20;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.26.23.46.43;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.25.17.09.37;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.24.22.07.48;	author maverick65;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.01.42.30;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches;
next	;

1.7.2.1
date	2003.01.28.16.54.04;	author cax2;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2003.01.29.00.25.44;	author cax2;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2003.01.29.13.38.26;	author cax2;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2003.01.31.10.21.45;	author cax2;	state Exp;
branches;
next	;

1.9.2.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.02.08.13.37.04;	author obaldin;	state Exp;
branches;
next	;

1.18.2.1
date	2003.02.28.22.44.54;	author obaldin;	state Exp;
branches;
next	;

1.41.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.297
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002-2006 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "opcodes.h"
#include "DownloadQueue.h"
#include "server.h"
#include "ServerList.h"
#include "updownclient.h"
#include "PartFile.h"
#include "ED2KLink.h"
#include "otherfunctions.h"
#include "SharedFileList.h"
#include "UploadQueue.h"
#include "IPFilter.h"
#include "emule.h"
#include "packets.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

static const uint32 g_dwZeroConst = 0;

BEGIN_MESSAGE_MAP(CHostnameSourceWnd, CWnd)
	ON_MESSAGE(TM_SOURCEHOSTNAMERESOLVED, OnSourceHostnameResolved)
	ON_WM_TIMER()
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHostnameSourceWnd::CHostnameSourceWnd()
{
	m_pOwner = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LRESULT CHostnameSourceWnd::OnSourceHostnameResolved(WPARAM wParam, LPARAM lParam)
{
	if (m_pOwner)
		m_pOwner->SourceHostnameResolved(wParam, lParam);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadQueue::CDownloadQueue(CSharedFileList *in_pSharedFileList)
{
	m_pSharedFileList = in_pSharedFileList;
	m_dwDataRate = 0;
	m_pCurUDPServer = NULL;
	m_dwLastUDPSearchTime = 0;
	m_dwLastUDPStatTime = 0;
	m_pLastUDPSearchedFile = NULL;
	m_dwAverDataRate = 0;
	m_uiUDCounter = 0;
	m_dwSumDownDataOverheadInDeque = 0;
	m_nDownDataRateMSOverhead = 0;
	m_nDownDataRateOverhead = 0;
	m_nDownDataOverheadSourceExchange = 0;
	m_nDownDataOverheadFileRequest = 0;
	m_nDownDataOverheadOther = 0;
	m_nDownDataOverheadServer = 0;
	m_nDownDataOverheadSourceExchangePackets = 0;
	m_nDownDataOverheadFileRequestPackets = 0;
	m_nDownDataOverheadOtherPackets = 0;
	m_nDownDataOverheadServerPackets = 0;
	m_A4AF_auto_file = NULL;
	m_bIsInitialized = false;
	m_dwLastTCPSourcesRequestTime = 0;
	m_pLastTCPSrcReqServer = NULL;
	m_dwBannedCounter = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CDownloadQueue::~CDownloadQueue()
{
	EMULE_TRY

//--- xrmb:keepPartFileStats ---
	SaveAllPartFileStats();
//--- :xrmb ---

	while (!m_partFileList.IsEmpty())
	{
		CPartFile* pPartFile = m_partFileList.RemoveHead();

		if (pPartFile != NULL)
			delete pPartFile;
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::AddPartFilesToShare()
{
	EMULE_TRY

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		CPartFile	* pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile && pPartFile->GetRawStatus() == PS_READY)
			m_pSharedFileList->SafeAddKnownFile(pPartFile, true);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::CompDownDataRateOverhead()
{
	EMULE_TRY

//	update the list & sum
	m_DownDataOverheadDeque.push_back(m_nDownDataRateMSOverhead);
	m_dwSumDownDataOverheadInDeque += m_nDownDataRateMSOverhead;

//	reset the data
	m_nDownDataRateMSOverhead = 0;

//	chech deque length
	while (m_DownDataOverheadDeque.size() > 150)
	{
		m_dwSumDownDataOverheadInDeque -= m_DownDataOverheadDeque.front();
		m_DownDataOverheadDeque.pop_front();
	}

//	calculate average value
	if (m_DownDataOverheadDeque.size() > 10)
		m_nDownDataRateOverhead = 10 * m_dwSumDownDataOverheadInDeque/m_DownDataOverheadDeque.size();
	else
		m_nDownDataRateOverhead = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::Init()
{
	EMULE_TRY

//	Find all part files, read & hash them if needed and store them into a list
	uint16	iCount = 0;
	CString	strTempDir = g_App.m_pPrefs->GetTempDir();
	CStringList	tmpTempDirList;	//	list elements will be deleted in list destructor

//	Make local copy to prevent long locking of list resource
	g_App.m_pPrefs->TempDirListCopy(&tmpTempDirList);
//	Add the main temporary directory to the temporary directories list for easier processing
	strTempDir += _T('\\');
	tmpTempDirList.AddHead(strTempDir);

//	For each temp dir...
	for (POSITION pos = tmpTempDirList.GetHeadPosition(); pos != NULL; )
	{
		CFileFind		ff;
		CString			strTempDirPath(tmpTempDirList.GetNext(pos));
		CString			strSearchPath = strTempDirPath;

		strSearchPath += _T("*.part.met");

	//	Check all part.met files
		bool	bEnd = !ff.FindFile(strSearchPath, 0);

	//	Until we can't find any more .met files...
		while (!bEnd)
		{
			bEnd = !ff.FindNextFile();
		//	If, for some reason, there's a .met directory, skip it
			if (ff.IsDirectory())
				continue;

			CPartFile		*pPartFile = new CPartFile();

		//	Try to load the part file. If we were successful...
		
			bool bLoadPartFileStatus = pPartFile->LoadPartFile(strTempDirPath, ff.GetFileName());

		//	Try recovering part.met.bak file if load failed before
			if (!bLoadPartFileStatus)
				bLoadPartFileStatus = pPartFile->TryToRecoverPartFile(strTempDirPath, ff.GetFileName());

			if (bLoadPartFileStatus)
			{
				iCount++;
			//	Check if is an A4AF auto file
				if (md4cmp(pPartFile->GetFileHash(), g_App.m_pPrefs->GetA4AFHash()) == 0)
					g_App.m_pDownloadQueue->SetA4AFAutoFile(pPartFile);

			//	Add it to the download queue
				m_partFileList.AddTail(pPartFile);

			//	PartFiles are always shared files
				if (pPartFile->GetRawStatus() == PS_READY)
					m_pSharedFileList->SafeAddKnownFile(pPartFile);

				g_App.m_pDownloadList->AddFile(pPartFile);

			//	Load SLS sources on PartFile loading
				m_sourcesaver.LoadSources(pPartFile);
			}
			else
			{
				delete pPartFile;
			}
		}
		ff.Close();
	}

	if (iCount == 0)
		AddLogLine(0, IDS_NOPARTSFOUND);
	else
	{
		AddLogLine(0, IDS_FOUNDPARTS, iCount);
		SortByPriority();
	}

//--- xrmb:keepPartFileStats ---
	m_lastPartFileStatsSave = GetTickCount();
//--- :xrmb ---

	m_wndHSCallback = NULL;
	sourceHostnameResolveRetry = 0;
	m_bIsResolving = false;
	m_bIsInitialized = true;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::AddSearchToDownload(CSearchFile *pNewSearchFile, EnumCategories eCatID/*=CAT_NONE*/, bool bPaused/*=false*/)
{
	EMULE_TRY

	if (pNewSearchFile->GetFileSize() == 0)
	{
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_SKIPZEROLENGTHFILE, pNewSearchFile->GetFileName());
		return;
	}

	CPartFile	*pNewPartFile = NULL;

	if (FileExists(pNewSearchFile->GetFileHash()))
	{
		if ((pNewPartFile = GetFileByID(pNewSearchFile->GetFileHash())) == NULL)
			return;	// Existing file isn't in the download list
	}
	else
	{
		pNewPartFile = new CPartFile(pNewSearchFile, eCatID);
		if (pNewPartFile->GetStatus() == PS_ERROR)
		{
			delete pNewPartFile;
			return;
		}
		AddDownload(pNewPartFile, bPaused);
	}

	if (pNewSearchFile->GetClientHybridID() != 0 && pNewSearchFile->GetClientPort() != 0)
	{
	//	If the search result is from a client ('View Files') add that client as source
		if (pNewSearchFile->GetType() == SFT_CLIENT)
		{
			CClientSource	source;

			source.dwSrcIDHybrid = pNewSearchFile->GetClientHybridID();
			source.sourcePort = pNewSearchFile->GetClientPort();
			source.serverIP = pNewSearchFile->GetClientServerIP();
			source.serverPort = pNewSearchFile->GetClientServerPort();
			md4cpy(source.achUserHash, pNewSearchFile->GetClientHash());

			pNewPartFile->AddClientSource(&source, 0, false, 0, ADDSRC_KNOWNSRC);
		}
		else
		{
		//	If the search result is from OP_GLOBSEARCHRES there may also be a source
			CMemFile	sourcesFile(16);
			uint32		dwClientID;
			uint16		uPort;
			byte		byteSources = 1;

			sourcesFile.Write(&byteSources, 1);
			dwClientID = pNewSearchFile->GetClientID();
			sourcesFile.Write(&dwClientID, 4);
			uPort = pNewSearchFile->GetClientPort();
			sourcesFile.Write(&uPort, 2);

			sourcesFile.SeekToBegin();
			pNewPartFile->AddServerSources(sourcesFile, pNewSearchFile->GetClientServerIP(), pNewSearchFile->GetClientServerPort(), false);
		}
	}

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::AddFileLinkToDownload(CED2KFileLink *pLink, EnumCategories eCatID)
{
	EMULE_TRY

	if (!m_bIsInitialized)	// don't add anything until it's fully initialized to avoid some startup issues
		return;

	CPartFile	*pNewPartFile = new CPartFile(pLink, eCatID);

	if (pNewPartFile->GetStatus() == PS_ERROR)
	{
		delete pNewPartFile;
		pNewPartFile = NULL;
	}
	else
		AddDownload(pNewPartFile, g_App.m_pPrefs->StartDownloadPaused());

	if (pLink->HasValidSources())
	{
		if (pNewPartFile != NULL)
		{
		//	Add all IP sources and eliminate them from list
			pNewPartFile->AddClientSources(pLink->ClientSourcesList);
		}
		else
		{
			CPartFile	*pPartFile = GetFileByID(pLink->GetHashKey());

			if (pPartFile != NULL)
			//	Add all IP sources and eliminate them from list
				pPartFile->AddClientSources(pLink->ClientSourcesList);
		}
	}
	if (pLink->HasValidAICHHash())
	{
#ifdef _AICH_READY
		pLink->GetAICHHash()
#endif
	}
	if (pNewPartFile != NULL)	// Update only if a new file was added
		g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	StartNextFile() starts a paused download preferably in the same category (takes in account priority)
void CDownloadQueue::StartNextFile(EnumCategories eCatID)
{
	EMULE_TRY

	CPartFile	*pPartFile, *pTempPartFile;
	CPartFile	*pStartFile = NULL;
	POSITION	pos;

	bool bFoundInSameCat = false;

//	Try to find a paused file in the same category
	for (pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		pTempPartFile = m_partFileList.GetNext(pos);
		if (CCat::FileBelongsToGivenCat(pTempPartFile, eCatID) && pTempPartFile->GetStatus() == PS_PAUSED)
		{
			bFoundInSameCat = true;
			break;
		}
	}
	for (pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile && pPartFile->GetStatus() == PS_PAUSED && ((!bFoundInSameCat && g_App.m_pPrefs->IsResumeOtherCat())
			|| (bFoundInSameCat &&  CCat::FileBelongsToGivenCat(pPartFile, eCatID))))
		{
		//	If no start file has been found or 'pPartFile' is higher priority...
		//  and now it's same priority but next in file order (ie. 1/2/3 in a series)
			if (pStartFile == NULL || pStartFile->GetPriority() < pPartFile->GetPriority()
				|| ( pStartFile->GetPriority() == pPartFile->GetPriority()
				    && (pStartFile->CmpFileNames(pPartFile->GetFileName()) > 0) ) )
				pStartFile = pPartFile;
		}
	}

	if (pStartFile != NULL)
		pStartFile->ResumeFile();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::AddDownload(CPartFile *pNewPartFile, bool bPaused)
{
	EMULE_TRY

	m_partFileList.AddTail(pNewPartFile);
	SortByPriority();

	if (bPaused)
	{
		pNewPartFile->PauseFile();
		pNewPartFile->SetStartTimeReset(true);
	}

	g_App.m_pDownloadList->AddFile(pNewPartFile);

	CCat		*pCat = CCat::GetCatByID(pNewPartFile->GetCatID());
	CString		strCategory = (pCat != NULL) ? pCat->GetTitle() : GetResString(IDS_CAT_UNCATEGORIZED);

	AddLogLine(LOG_FL_SBAR, IDS_NEWDOWNLOAD, pNewPartFile->GetFileName(), strCategory);

//	Sending message when a download is added
	CString	strMessageText;

	strMessageText.Format(GetResString(IDS_NEWDOWNLOAD), pNewPartFile->GetFileName(), strCategory);
	g_App.m_pMDlg->SendMail( strMessageText, g_App.m_pPrefs->GetUseDownloadAddNotifier(),
	                                        g_App.m_pPrefs->IsSMTPInfoEnabled() );
	g_App.m_pMDlg->ShowNotifier( strMessageText, TBN_DLOAD_ADD, false,
	                                      g_App.m_pPrefs->GetUseDownloadAddNotifier() );
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CDownloadQueue::FileExists(const uchar *strFileHash)
{
	bool		bFileExists = false;
	CKnownFile	*pKnownFile;

	EMULE_TRY

	if ((pKnownFile = m_pSharedFileList->GetFileByID(strFileHash)) != NULL)
	{
		if (pKnownFile->IsPartFile())
			AddLogLine(LOG_FL_SBAR, IDS_ERR_ALREADY_DOWNLOADING, pKnownFile->GetFileName());
		else
			AddLogLine(LOG_FL_SBAR, IDS_ERR_ALREADY_DOWNLOADED, pKnownFile->GetFileName());
		bFileExists = true;
	}
	else if ((pKnownFile = GetFileByID(strFileHash)) != NULL)
	{
		AddLogLine(LOG_FL_SBAR, IDS_ERR_ALREADY_DOWNLOADING, pKnownFile->GetFileName());
		bFileExists = true;
	}

	EMULE_CATCH

	return bFileExists;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::UpdateSourceStatesAfterServerChange()
{
	EMULE_TRY

	ClientList sourceListCopy;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile != NULL)
		{
			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

			if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY) || (eFileStatus == PS_PAUSED))
			{
				pPartFile->GetCopySourceLists(SLM_CHECK_SERVER_CHANGE, &sourceListCopy);
				for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
				{
					(*cIt)->UpdateDownloadStateAfterFileReask();
				}
			}
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::Process()
{
	EMULE_TRY

	if (!m_bIsInitialized)
		return;

	uint32	dwDownSpeed = 0;
	uint32	dwMaxDLSpeed = g_App.m_pPrefs->GetMaxDownload();

	if ((dwMaxDLSpeed != UNLIMITED) && ((m_dwDataRate > 1500) || (dwMaxDLSpeed < 30)))
	{
		uint32	dwMaxDLSpeedBPS = dwMaxDLSpeed * 1024;	// Bytes per second

	//	Don't remove upper DL limit, otherwise one DL will block all others
	//	Calculate what percentage of the max data rate the current data rate is
		dwDownSpeed = (dwMaxDLSpeedBPS * 10) / (m_dwDataRate + 1);
	//	Pin it between 50% and 200% of max
		if (dwDownSpeed < 50)
			dwDownSpeed = 50;
		else if (dwDownSpeed > 200)
			dwDownSpeed = 200;
	}

//	Process all the part files in the queue in decreasing order of priority
//	m_partFileList is already sorted by prio every time a file is added or deleted
//	therefore we removed all the extra loops...
	uint32	dwDataRate = 0;

	m_uiUDCounter++;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);

		if (pPartFile != NULL)
		{
			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

			if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
				dwDataRate += pPartFile->Process(dwDownSpeed, m_uiUDCounter /*iteration*/);
		}
	//	Due to a fact that list is sorted by priority, position can be changed
	//	while doing file processing, thus do GetNext at the end to avoid exceptions
	//	This though doesn't resolve the problem that not all files might be processed by the loop
		m_partFileList.GetNext(pos);
	}
	m_dwDataRate = dwDataRate;

	DWORD	dwCurTick = ::GetTickCount();

//	Save used bandwidth for speed calculations
	if (m_averageTickList.empty() || dwCurTick - m_averageTickList.front() >= 500)	// Update no faster than every .5 sec
	{
		m_averageDataRateList.push_front(g_App.stat_sessionReceivedBytes);
	//	Save time between each speed snapshot
		m_averageTickList.push_front(dwCurTick);

	//	Save 40 secs of data. It seems to give the most accurate result atm...
		while (dwCurTick - m_averageTickList.back() > 40000)
		{
			m_averageDataRateList.pop_back();
			m_averageTickList.pop_back();
		}
	}

//	Calculate average data rate
	if (m_averageDataRateList.size() > 1)
		m_dwAverDataRate = static_cast<uint32>((static_cast<double>(m_averageDataRateList.front() - m_averageDataRateList.back())) * 1000.0 / (m_averageTickList.front() - m_averageTickList.back()));
	else
		m_dwAverDataRate = 0;

//	The code of sources refresh on local server was moved here in order to prevent
//	the situation where the client is blacklisted. We create:
//	1) one 'packet' which contains 15 buffered OP_GETSOURCES ED2K packets to be sent in one TCP frame every 300 sec
//		or
//	2) one OP_GETSOURCES contained hash & size of a bunch of files (up to 15)
#ifdef OLD_SOCKETS_ENABLED
	if (m_uiUDCounter == 2 && g_App.m_pServerConnect->IsConnected() && !m_LocalServerSourcesReqQueue.IsEmpty())
	{
		if (!m_dwLastTCPSourcesRequestTime || (dwCurTick - m_dwLastTCPSourcesRequestTime) > SERVER_SRC_REQ_QUANT)
		{
			int			iRequestedNumber = 0;
			CMemFile	packetStream((16 + 4 + 8) * 15);
		//	Server accepts OP_GETSOURCES containing several files, plus <HASH 16><SIZE 4>
			uint64		qwTmp;
			uint32		dwSrvTCPFlags = g_App.m_pServerConnect->GetCurrentServer()->GetTCPFlags();
			bool		bSupportNewFormat = (dwSrvTCPFlags & SRV_TCPFLG_EXT_GETSOURCES) != 0;
			bool		bSrvSupportsLargeFiles = (dwSrvTCPFlags & SRV_TCPFLG_LARGEFILES) != 0;

			while (iRequestedNumber < 15 && !m_LocalServerSourcesReqQueue.IsEmpty())
			{
				CPartFile	   *pPartFile = m_LocalServerSourcesReqQueue.RemoveHead();
				EnumPartFileStatuses	eFileStatus;

				if ( (pPartFile != NULL) &&
					(((eFileStatus = pPartFile->GetStatus()) == PS_READY) || (eFileStatus == PS_EMPTY)) &&
					(bSrvSupportsLargeFiles || !pPartFile->IsLargeFile()) )
				{
					if (bSupportNewFormat)
					{
						packetStream.Write(pPartFile->GetFileHash(), 16);
						qwTmp = pPartFile->GetFileSize();
						if (pPartFile->IsLargeFile())
						{
							packetStream.Write(&g_dwZeroConst, 4);	// indicates that this is a large file and a uint64 follows
							packetStream.Write(&qwTmp, sizeof(qwTmp));
						}
						else
							packetStream.Write(&qwTmp, 4);
					}
					else
					{
						Packet	packet(OP_GETSOURCES, 16);

						md4cpy(packet.m_pcBuffer, pPartFile->GetFileHash());
						packetStream.Write(packet.GetPacket(), packet.GetRealPacketSize());
					}
					iRequestedNumber++;
				}
			}

			const int	iStreamSize = static_cast<int>(packetStream.GetLength());

			if (iStreamSize > 0)
			{
				if (bSupportNewFormat)
				{
					Packet	packet(&packetStream);

#ifdef _CRYPT_READY
					packet.m_eOpcode = ( g_App.m_pPrefs->IsClientCryptLayerSupported() &&
						(dwSrvTCPFlags & SRV_TCPFLG_TCPOBFUSCATION) != 0) ) ? OP_GETSOURCES_OBFU : OP_GETSOURCES;
#else
					packet.m_eOpcode = OP_GETSOURCES;
#endif
					g_App.m_pUploadQueue->AddUpDataOverheadServer(packet.m_dwSize);
					g_App.m_pServerConnect->SendPacket(&packet, false);
				}
				else
				{
				//	Create one 'packet' which contains all buffered OP_GETSOURCES ED2K packets to be sent in one TCP frame
					Packet	*packet = new Packet(new char[iStreamSize], iStreamSize, true, 0, false);

					packetStream.SeekToBegin();
					packetStream.Read(packet->GetPacket(), iStreamSize);
					g_App.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
					g_App.m_pServerConnect->SendPacket(packet, true);
				}
			//	Update time only in case we sent something
				m_dwLastTCPSourcesRequestTime = dwCurTick;
			}
		}
	}
#endif //OLD_SOCKETS_ENABLED

	if (m_uiUDCounter == 5)
	{
		if ((!m_dwLastUDPStatTime) || (dwCurTick - m_dwLastUDPStatTime) > UDPSERVERSTATTIME)
		{
			m_dwLastUDPStatTime = dwCurTick;
			g_App.m_pServerList->ServerStats();
		}
	}
	else if (m_uiUDCounter >= 10)
	{
		m_uiUDCounter = 0;
		if ((!m_dwLastUDPSearchTime) || (dwCurTick - m_dwLastUDPSearchTime) > UDPSERVERREASKTIME)
		{
			SendNextUDPPacket();
		}
//--- xrmb:keepPartFileStats ---
		if (m_lastPartFileStatsSave + 300000 < dwCurTick)
		{
			m_lastPartFileStatsSave = dwCurTick;
			SaveAllPartFileStats();
		}
//--- :xrmb ---
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SaveAllPartFileStats()
{
	EMULE_TRY

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile)
		{
			pPartFile->SavePartFileStats();
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetFileByIndex() returns the 'iIndex'th (0-based) file in the queue or NULL if 'iIndex' is out of range.
CPartFile *CDownloadQueue::GetFileByIndex(int iIndex)
{
	POSITION	pos = m_partFileList.FindIndex(iIndex);

	return (pos != NULL) ? m_partFileList.GetAt(pos) : NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetFileByID() returns the part file from the download queue with file hash 'strFileHash'
//	or NULL if there is none.
CPartFile *CDownloadQueue::GetFileByID(const uchar* strFileHash)
{
	CPartFile	   *pPartFile = NULL;

	EMULE_TRY

	CPartFile	   *pTempPartFile;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		pTempPartFile = m_partFileList.GetNext(pos);

		if (pTempPartFile && !md4cmp(strFileHash, pTempPartFile->GetFileHash()))
		{
			pPartFile = pTempPartFile;
			break;
		}
	}

	EMULE_CATCH

	return pPartFile;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CDownloadQueue::IsInDLQueue(CKnownFile *pFileToTest)
{
	bool	bIsInDLQueue = false;

	EMULE_TRY

	POSITION	pos = m_partFileList.Find(pFileToTest);

	if (pos != NULL)
		bIsInDLQueue = true;

	EMULE_CATCH

	return bIsInDLQueue;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwUserIDHyb, uint16 uUserPort, uint32 dwSrvIP, uint16 uSrvPort, uchar *pbyteUserHash, int iMode/*=0*/)
{
	EMULE_TRY

	if (!IsGoodHybridID(dwUserIDHyb))
		return NULL;

	uint32	dwIP = fast_ntohl(dwUserIDHyb);

//	Check if source is our own client (now checking also TCP port)
	if (dwIP == g_App.m_pPrefs->GetLancastIP() && uUserPort == g_App.m_pPrefs->GetPort())
		return NULL;

//	If this part file is stopped or complete/completing or erroneous, no sources needed anymore
	EnumPartFileStatuses	eFileStatus = pSenderFile->GetStatus();

	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE
		|| eFileStatus == PS_COMPLETING || eFileStatus == PS_ERROR)
	{
		return NULL;
	}

//	Check if client has to be filtered, to prevent adding it to DL-queue by source exchange
//	1) The LowID source can't be filtered, so we need to be sure that client has the server IP & port
//	2) Filter HighID source over an IP that extracted from Hybrid User ID
	if (IsLowID(dwUserIDHyb))
	{
	//	TODO: add handling of firewalled Kad users who send an ID "0x1" & don't have a proper server information 
		if ((dwSrvIP == 0) || (uSrvPort == 0))
		{
		//	Continue for known source (it's A4AF for some other file)
			if ((iMode & ADDSRC_KNOWNSRC) == 0)
				return NULL;
		}
	}
	else if (g_App.m_pIPFilter->IsFiltered(dwIP))
	{
		InterlockedIncrement(&g_App.m_lSXFiltered);
		InterlockedIncrement(&g_App.m_lTotalFiltered);
		if (!g_App.m_pPrefs->IsCMNotLog())
			AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Filtered (reject as new source): %u.%u.%u.%u %hs"),
							 (byte)dwIP, (byte)(dwIP >> 8), (byte)(dwIP >> 16),
							 (byte)(dwIP >> 24), g_App.m_pIPFilter->GetLastHit() );
		return NULL;
	}

// Now we need to check if client is already in the DL-queue with all available information
	CUpDownClient	*pTempSource = g_App.m_pClientList->FindClient(dwUserIDHyb, uUserPort, dwSrvIP, uSrvPort, pbyteUserHash);

//	Client is already known
	if (pTempSource != NULL)
	{
	//	Check UL only case (client exist only in UL-queue)
		if (pTempSource->m_pReqPartFile == NULL)
		{
		// 	Add if OtherRequestList is empty (source was removed)
			if (pTempSource->m_otherRequestsList.IsEmpty())
			{
				pTempSource->SetDLRequiredFile(pSenderFile);
				pTempSource->SetDownloadState(DS_WAIT_FOR_FILE_REQUEST);
				pTempSource->ResetLastAskedTime();
				pSenderFile->RemovePastComment(pTempSource);
				g_App.m_pDownloadList->AddSource(pSenderFile, pTempSource, false);
			}
		}
		else if (pTempSource->m_pReqPartFile != pSenderFile)
		{
			if (pTempSource->AddRequestForAnotherFile(pSenderFile))
				g_App.m_pDownloadList->AddSource(pSenderFile, pTempSource, true);
		}

		return NULL;
	}
//	Client doesn't exist
	else if (!IsLowID(dwUserIDHyb) || ((iMode & ADDSRC_KNOWNSRC) == 0))	//	return if known LowID source is not found
	{
		CUpDownClient	*pNewSource = new CUpDownClient(uUserPort, dwUserIDHyb, dwSrvIP, uSrvPort, pSenderFile, UID_HYBRID);

		if (g_App.m_pClientList->AddClient(pNewSource, true))
		{
			pNewSource->SetDLRequiredFile(pSenderFile);
			pNewSource->SetDownloadState(DS_WAIT_FOR_FILE_REQUEST);
			pSenderFile->RemovePastComment(pNewSource);
			g_App.m_pDownloadList->AddSource(pSenderFile, pNewSource, false);
			return pNewSource;
		}
		else
			safe_delete(pNewSource);
	}

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CDownloadQueue::CheckAndAddKnownSource(CPartFile *pPartFile, CUpDownClient *pKnownSource)
{
	EMULE_TRY

	EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

//	Stop adding sources to stopped, completing, completed and erroneous files
	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE
		|| eFileStatus == PS_COMPLETING || eFileStatus == PS_ERROR)
	{
		return false;
	}

	if (!IsGoodHybridID(pKnownSource->GetUserIDHybrid()))
		return false;

//	If we receive ourselves (now checking IP and UDP port) as a source we drop it
	if ( md4cmp(g_App.m_pPrefs->GetUserHash(), pKnownSource->GetUserHash()) == 0 &&
		 pKnownSource->GetIP() == g_App.m_pPrefs->GetLancastIP() &&
		 pKnownSource->GetUDPPort() == g_App.m_pPrefs->GetUDPPort() )
		return false;

//	Check if file is in download list
	if (IsInDLQueue(pPartFile))
	{
	//	If requested file is already specified
		if (pKnownSource->m_pReqPartFile)
		{
		//	Check if it's the same file
			if (pPartFile == pKnownSource->m_pReqPartFile)
			{
			//	If file was found, to speed up checks we will use variable pKnownSourceslot
				if (pPartFile->IsClientInSourceList(pKnownSource))
					return true;
			}
			else
			{
				if (pKnownSource->AddRequestForAnotherFile(pPartFile))
					g_App.m_pDownloadList->AddSource(pPartFile,pKnownSource,false);
				return true;
			}
		}
	}

	pKnownSource->SetDLRequiredFile(pPartFile);
	pKnownSource->SetDownloadState(DS_WAIT_FOR_FILE_REQUEST);
	pPartFile->RemovePastComment(pKnownSource);
	//pKnownSource->StartDLQueueWaitTimer();
	g_App.m_pDownloadList->AddSource(pPartFile,pKnownSource,false);

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function removes the source from all files
void CDownloadQueue::RemoveSource(CUpDownClient *toremove, bool updatewindow /*true*/)
{
	EMULE_TRY

	CPartFile	*pPartFile;

	toremove->SetDownloadState(DS_NONE);

//	Now a remove client in A4AF files. Let's use "OtherRequests_list" for this matter
	for (POSITION pos = toremove->m_otherRequestsList.GetHeadPosition(); pos != NULL; )
	{
		pPartFile = toremove->m_otherRequestsList.GetNext(pos);
		if (IsInDLQueue(pPartFile))
		{
			pPartFile->RemoveClientFromA4AFSourceList(toremove);
		}
	}
//	Clear client from all graphical lists
	if (updatewindow)
		g_App.m_pDownloadList->RemoveSource(toremove, NULL);

	if (toremove->m_pReqPartFile != NULL)
		toremove->m_pReqPartFile->CheckAndAddPastComment(toremove);

	toremove->SetDLRequiredFile(NULL);
	toremove->m_otherNoNeededMap.RemoveAll();
	toremove->m_otherRequestsList.RemoveAll();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::RemoveFile(CPartFile* toremove)
{
	EMULE_TRY

	POSITION remove_pos = m_partFileList.Find(toremove);
	if (remove_pos != NULL)
		m_partFileList.RemoveAt(remove_pos);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::ResumeFiles()
{
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		CPartFile* pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile)
		{
			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

			if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
			{
				pPartFile->ResumeFile();
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::DeleteAll()
{
	EMULE_TRY

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		CPartFile* pPartFile = m_partFileList.GetNext(pos);
		if (pPartFile != NULL)
		{
			pPartFile->ClearSourceLists();
			pPartFile->ClearA4AFSourceList();

		//	Barry - Should also remove all requested blocks
		//	Don't worry about deleting the blocks, that gets handled
		//	when CUpDownClient is deleted in CClientList::DeleteAll()
			pPartFile->RemoveAllRequestedBlocks();
		}
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Max. file IDs per UDP packet
// ----------------------------
// 576 - 30 bytes of header (28 for UDP, 2 for "E3 9A" edonkey proto) = 546 bytes
// 546 / 16 = 34
// 546 / 20 = 27
// Every large file adds extra 8 bytes
bool CDownloadQueue::SendNextUDPPacket()
{
#ifdef OLD_SOCKETS_ENABLED
	EMULE_TRY

	if ( !m_bIsInitialized || m_partFileList.IsEmpty() ||
		!g_App.m_pServerConnect->IsConnected() ||
		g_App.m_pPrefs->IsClientCryptLayerRequired() ) // sources received without userhash can't be used, so don't ask
	{
		return false;
	}

	CServer	*pCurServer = g_App.m_pServerConnect->GetCurrentServer();

//	Get server for request
//	Check for the local server and try to switch to another one, plus
//	don't send source requests to the dead servers (dead static servers aren't removed automatically)
	while ((m_pCurUDPServer = g_App.m_pServerList->GetSuccServer(m_pCurUDPServer)) != NULL)
	{
		if (m_pCurUDPServer == g_App.m_pServerList->GetServerByAddress(pCurServer->GetAddress(), pCurServer->GetPort()))
			continue;
		if (m_pCurUDPServer->GetFailedCount() >= g_App.m_pPrefs->GetDeadserverRetries())
			continue;
		break;
	}
//	If we got NULL pointer back, that means
//	1. list is empty
//	2. we are in the end of the list
//	in both cases we will stop any UDP request
	if (m_pCurUDPServer == NULL)
	{
		StopUDPRequests();
		return false;
	}

	uint32		dwSz, dwPos, dwSrvUDPFlags = m_pCurUDPServer->GetUDPFlags();
	bool		bGetSources2Packet = (dwSrvUDPFlags & SRV_UDPFLG_EXT_GETSOURCES2) != 0;
	bool		bSrvSupportsLargeFiles = (dwSrvUDPFlags & SRV_UDPFLG_LARGEFILES) != 0;
//	Check support of extended request
	uint32		dwMaxPacketSz = (dwSrvUDPFlags & SRV_UDPFLG_EXT_GETSOURCES) ? 546 : 16;
//	Allocate a little bit more to simplify the algorithm
	CMemFile	dataGlobGetSources(dwMaxPacketSz + 20/*GETSOURCES2*/ + 8/*LargeFile*/);
	POSITION	posLastSearchedFile = NULL;

//	Get position in the file list
	if (m_pLastUDPSearchedFile != NULL)
		posLastSearchedFile = m_partFileList.Find(m_pLastUDPSearchedFile);

//	Check if file was found. This can happens in 2 cases
//	1. initial case: m_pLastUDPSearchedFile is not yet definded
//	2. if "m_pLastUDPSearchedFile" was deleted & m_partFileList.Find() return a 0
	if (posLastSearchedFile == NULL)
		posLastSearchedFile = m_partFileList.GetHeadPosition();

//	At this point we have a start position to search in "posLastSearchedFile"
//	so we can create a packet
	uint64			qwTmp;
	CPartFile		*pNextPartFile;

	for (int i = 0; i < m_partFileList.GetCount(); i++)
	{
		if ((pNextPartFile = m_partFileList.GetNext(posLastSearchedFile)) != NULL)
		{
			EnumPartFileStatuses	eFileStatus = pNextPartFile->GetStatus();

			if ( ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY)) &&
				(g_App.m_pPrefs->GetMaxSourcePerFileUDP() > pNextPartFile->GetSourceCount()) &&
				(bSrvSupportsLargeFiles || !pNextPartFile->IsLargeFile()) )
			{
				dwPos = static_cast<uint32>(dataGlobGetSources.GetLength());
				dataGlobGetSources.Write(pNextPartFile->GetFileHash(), 16);

				if (bGetSources2Packet)
				{
					qwTmp = pNextPartFile->GetFileSize();
					if (pNextPartFile->IsLargeFile())
					{
						dataGlobGetSources.Write(&g_dwZeroConst, 4);	// indicates that this is a large file and a uint64 follows
						dataGlobGetSources.Write(&qwTmp, sizeof(qwTmp));
					}
					else
						dataGlobGetSources.Write(&qwTmp, 4);
				}
			//	If packet is filled break the loop
				if ((dwSz = static_cast<uint32>(dataGlobGetSources.GetLength())) >= dwMaxPacketSz)
				{
					if (dwSz > dwMaxPacketSz)	//	Rollback the last file
						dataGlobGetSources.SetLength(dwPos);
					break;
				}
				m_pLastUDPSearchedFile = pNextPartFile;
			}
		//	Check for the end of the loop & start from the head if it's needed
			if (posLastSearchedFile == NULL)
				posLastSearchedFile = m_partFileList.GetHeadPosition();
		}
	}

	if (static_cast<uint32>(dataGlobGetSources.GetLength()) != 0)
	{
		Packet			packet(&dataGlobGetSources);

		packet.m_eOpcode = (bGetSources2Packet) ? OP_GLOBGETSOURCES2 : OP_GLOBGETSOURCES;
		g_App.m_pUploadQueue->AddUpDataOverheadServer(packet.m_dwSize);
		g_App.m_pServerConnect->SendUDPPacket(&packet, m_pCurUDPServer, false);
	}
	return true;

	EMULE_CATCH
#endif //OLD_SOCKETS_ENABLED
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::StopUDPRequests()
{
	m_pCurUDPServer = NULL;
	m_dwLastUDPSearchTime = ::GetTickCount();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SortByPriority()
{
	EMULE_TRY

	POSITION		pos1, pos2;
	CPartFile	   *pPartFile;
	int				i = 0;

	for (pos1 = m_partFileList.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos1);

		if (pPartFile)
		{
			if (pPartFile->GetPriority() == PR_HIGH)
			{
				m_partFileList.AddHead(pPartFile);
				m_partFileList.RemoveAt(pos2);
			}
			else if (pPartFile->GetPriority() == PR_LOW)
			{
				m_partFileList.AddTail(pPartFile);
				m_partFileList.RemoveAt(pos2);
			}

			if (++i == m_partFileList.GetCount())
				break;
		}
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CDownloadQueue::GetDownloadClientByIP_UDP(uint32 dwIP, uint16 uUDPPort)
{
	EMULE_TRY

	POSITION		pos1;
	CUpDownClient	*pSrc, *pMatchingIPClient;
	CPartFile		*pPartFile;
	ClientList		clientListCopy;
	unsigned		uiMatches = 0;

	for (pos1 = m_partFileList.GetHeadPosition(); pos1 != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos1);

		if (pPartFile != NULL)
		{
			pPartFile->GetCopySourceLists(SLM_ALL, &clientListCopy);
			for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
			{
				pSrc = *cIt;
				if (dwIP == pSrc->GetIP())
				{
					if (uUDPPort == pSrc->GetUDPPort())
						return pSrc;
					pMatchingIPClient = pSrc;
					uiMatches++;
				}
			}
		}
	}
//	UDP packets reception when remote client is behind UDP portmapping router
	if (uiMatches == 1)
		return pMatchingIPClient;

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::GetDownloadStats(uint32 adwSrc[], uint64 aqwData[])
{
	EMULE_TRY

	memzero(adwSrc, sizeof(adwSrc[0]) * STATS_DLSRC_COUNT);
	memzero(aqwData, sizeof(aqwData[0]) * STATS_DLDATA_COUNT);

	CPartFile	   *pPartFile;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		if ((pPartFile = m_partFileList.GetNext(pos)) != NULL)
		{
			adwSrc[STATS_DLSRC_TOTAL] += pPartFile->GetSourceCount();
			adwSrc[STATS_DLSRC_TRANSFERRING] += pPartFile->GetTransferringSrcCount();
			adwSrc[STATS_DLSRC_ONQUEUE] += pPartFile->GetOnQueueSrcCount();
			adwSrc[STATS_DLSRC_QUEUEFULL] += pPartFile->GetQueueFullSrcCount();
			adwSrc[STATS_DLSRC_NNS] += pPartFile->GetNoNeededPartsSrcCount();
			adwSrc[STATS_DLSRC_CONNECTED] += pPartFile->GetConnectedSrcCount();
			adwSrc[STATS_DLSRC_CONNECTING] += pPartFile->GetConnectingSrcCount();
			adwSrc[STATS_DLSRC_CONNECTING_VIA_SRV] += pPartFile->GetConnectingViaServerSrcCount();
			adwSrc[STATS_DLSRC_WAIT4FILEREQ] += pPartFile->GetWaitForFileReqSrcCount();
			adwSrc[STATS_DLSRC_LOW2LOW] += pPartFile->GetLow2LowSrcCount();
			adwSrc[STATS_DLSRC_LOWID_ON_OTHER_SRV] += pPartFile->GetLowIDOnOtherServer();
			adwSrc[STATS_DLSRC_HIGH_QR] += pPartFile->GetHighQRSrcCount();

			uint64 qwNeededSpace = (pPartFile->GetFileSize() - pPartFile->GetRealFileSize());
			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

			if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
			{
				aqwData[STATS_DLDAT_ACTFILESIZE] += pPartFile->GetFileSize();
				aqwData[STATS_DLDAT_SIZE2TRANSFER] += pPartFile->GetSizeToTransfer();
				aqwData[STATS_DLDAT_ACTFILEREQSPACE] += qwNeededSpace;
			}
			aqwData[STATS_DLDAT_FILESIZETOTAL] += pPartFile->GetFileSize();
			aqwData[STATS_DLDAT_FILEREQSPACETOTAL] += qwNeededSpace;
			aqwData[STATS_DLDAT_FILEREALSIZE] += pPartFile->GetRealFileSize();
		}
	}

	adwSrc[STATS_DLSRC_BANNED] = m_dwBannedCounter;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SetAutoSourcesPerFile()
{
	sint32 cur_tmc = 0;
	sint32 cur_stotal = 0;
	sint32 old_mspf = g_App.m_pPrefs->GetMaxSourcePerFile();
	sint32 new_mspf = old_mspf;
	sint32 min_spf = g_App.m_pPrefs->GetMinAutoSourcesPerFile();
	sint32 max_spf = g_App.m_pPrefs->GetMaxAutoSourcesPerFile();
	sint32 max_stotal = g_App.m_pPrefs->GetMaxAutoSourcesTotal();
	sint32 max_sesrc = g_App.m_pPrefs->GetMaxAutoExchangeSources();
//	Count too many connections for all files
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; )
	{
		CPartFile * cur_file = m_partFileList.GetNext(pos);
		cur_tmc += cur_file->GetWaitForFileReqSrcCount();
		cur_stotal += cur_file->GetSourceCount();
	}

//	Check lower and upper limit
	sint32 current_dls = g_App.m_pDownloadQueue->GetActiveFileCount();
	if (current_dls > 0)
	{
		sint32 useful_min = max_stotal / current_dls;
		if (min_spf > useful_min)
		{
			min_spf = useful_min;
			g_App.m_pPrefs->SetMinAutoSourcesPerFile(min_spf);
		}
	}
	if (max_spf > max_stotal)
	{
		max_spf = max_stotal;
		g_App.m_pPrefs->SetMaxAutoSourcesPerFile(max_spf);
	}

//	Adjust SPF according to situation
	if (cur_stotal > max_stotal)
	{
	//	Too many total sources, lower
		if (cur_stotal - max_stotal > 200)
		{
			new_mspf = old_mspf - 10;
		}
		else
		{
			new_mspf = old_mspf - 2;
		}
	}
	else
	{
	//	Too many connections, lower sources per file
		if ((cur_tmc > 10) && (old_mspf > min_spf))
		{
			new_mspf = old_mspf - (cur_tmc / 15);
		}

	//	Not too many connections, raise sources per file depending on situation
		else if ((cur_tmc < 11) && (old_mspf < 200))
		{
			new_mspf = old_mspf + 10;
		}
		else if ((cur_tmc < 21) && (old_mspf < 200))
		{
			new_mspf = old_mspf + 2;
		}
		else if ((cur_tmc < 6) && (old_mspf < 400))
		{
			new_mspf = old_mspf + 5;
		}
		else if ((cur_tmc < 11) && (old_mspf < 400))
		{
			new_mspf = old_mspf + 2;
		}
		else if ((cur_tmc < 6) && (old_mspf < 600))
		{
			new_mspf = old_mspf + 5;
		}
		else if ((cur_tmc < 2) && (old_mspf < 800))
		{
			new_mspf = old_mspf + 5;
		}
		else if ((cur_tmc == 0) && (old_mspf < max_spf))
		{
			new_mspf = old_mspf + 2;
		}
	}

//	Stay between min_spf and max_spf
	if (new_mspf < min_spf)
		new_mspf = min_spf;
	if (new_mspf > max_spf)
		new_mspf = max_spf;

//	Change values
	if (old_mspf != new_mspf)
	{
		g_App.m_pPrefs->SetMaxSourcePerFile(new_mspf);

		if (g_App.m_pPrefs->IsAutoSourcesLogEnabled())
		{
			AddLogLine( LOG_FL_DBG | LOG_RGB_NOTICE, _T("AutoSourcesPerFile: TMC=%u / Total=%u -> Changed from %u to %u (%+d)"),
							 cur_tmc, cur_stotal, old_mspf, new_mspf, new_mspf - old_mspf );
		}

	//	Change source excange limit according to sources per file
		sint32 new_sesrc = g_App.m_pPrefs->GetMaxSourcePerFileSoft();
		g_App.m_pPrefs->SetXSUpTo((new_sesrc < max_sesrc) ? new_sesrc : max_sesrc);
	}
	else if (g_App.m_pPrefs->IsAutoSourcesLogEnabled())
	{
		AddLogLine( LOG_FL_DBG | LOG_RGB_NOTICE, _T("AutoSourcesPerFile: TMC=%u / Total=%u -> Not changed from %u"),
						 cur_tmc, cur_stotal, old_mspf );
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CDownloadQueue::GetTransferringFiles() const
{
	EMULE_TRY

	int				iCount = 0;
	CPartFile	   *pPartFile;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos);
		if ((pPartFile != NULL) && (pPartFile->GetTransferringSrcCount() > 0))
			iCount++;
	}

	return iCount;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CDownloadQueue::GetPausedFileCount() const
{
	EMULE_TRY

	int				iCount = 0;
	CPartFile	   *pPartFile;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile)
		{
			if (pPartFile->GetStatus() == PS_PAUSED)
				iCount++;
		}
	}

	return iCount;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CDownloadQueue::GetStoppedFileCount() const
{
	EMULE_TRY

	int				iCount = 0;
	CPartFile	   *pPartFile;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile != NULL && pPartFile->GetStatus() == PS_STOPPED)
		{
			iCount++;
		}
	}

	return iCount;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CDownloadQueue::GetActiveFileCount() const
{
	EMULE_TRY

	int				iCount = 0;
	CPartFile	   *pPartFile;

	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos);

		if (pPartFile)
		{
			EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();

			if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
			{
				iCount++;
			}
		}
	}

	return iCount;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::AddClientHostnameToResolve(CTypedPtrList<CPtrList, CClientSource*>* pLink)
{
	if (pLink != NULL)
		hostnameResolveQueue.AddTail(pLink);

	if (hostnameResolveQueue.IsEmpty() || m_bIsResolving)
		return;

	ResolveNextSourceHostname();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::ResolveNextSourceHostname()
{
	m_bIsResolving = true;
	CClientSource* source;
	for (;;)
	{
	 //	No more hostnames to resolve
		if (hostnameResolveQueue.IsEmpty())
		{
		//	Free unneccessary window
			delete m_wndHSCallback;
			m_wndHSCallback = NULL;
			m_bIsResolving = false;
			return;
		}

		source = hostnameResolveQueue.GetHead();

		if (source->sourceType != ED2KLINK_SOURCE_HOSTNAME)
		{
			delete source;
			hostnameResolveQueue.RemoveHead();
		}
		else
			break;
	}

	memzero(hostentBuffer, sizeof(hostentBuffer));

	if (!m_wndHSCallback)
	{
		m_wndHSCallback = new CHostnameSourceWnd();
		VERIFY(m_wndHSCallback->CreateEx(0, AfxRegisterWndClass(0), _T("Emule DNS Source Socket Wnd"), WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL));
		m_wndHSCallback->m_pOwner = this;
	}

	AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Resolving source hostname: %s"), source->sourceHostname);
	HANDLE RetValue;
	USES_CONVERSION;
	RetValue = WSAAsyncGetHostByName( m_wndHSCallback->m_hWnd, TM_SOURCEHOSTNAMERESOLVED,
	                                  CT2CA(source->sourceHostname), hostentBuffer, MAXGETHOSTSTRUCT );

	if (RetValue == 0)
	{
		if (sourceHostnameResolveRetry > 3)
		{
			CClientSource * hostsource;
			hostsource = hostnameResolveQueue.RemoveHead();
			AddLogLine( LOG_FL_DBG | LOG_RGB_ERROR, _T(__FUNCTION__) _T(": Error calling WSAAsyncGetHostByName to resolve source '%s'"),
				hostsource->sourceHostname );
			delete hostsource;
			delete m_wndHSCallback;
			m_wndHSCallback = NULL;
			memzero(hostentBuffer, sizeof(hostentBuffer));
			m_bIsResolving = false;
		}
		else
		{
			sourceHostnameResolveRetry += 1;
			memzero(hostentBuffer, sizeof(hostentBuffer));
			AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Source resolve retry number %i"), sourceHostnameResolveRetry);
			ResolveNextSourceHostname();
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp)
{
	NOPRM(wp);
	ASSERT (hostnameResolveQueue.GetCount() > 0);

	sourceHostnameResolveRetry = 0;

	CClientSource* hostsource;
	hostsource = hostnameResolveQueue.RemoveHead();

	if (WSAGETASYNCERROR(lp) != 0)
	{
		DEBUG_ONLY(AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T(__FUNCTION__) _T(": Error resolving source '%s'"), hostsource->sourceHostname));
		delete hostsource;
		delete m_wndHSCallback;
		m_wndHSCallback = NULL;
		memzero(hostentBuffer, sizeof(hostentBuffer));
		ResolveNextSourceHostname();
		return;
	}

	int iBufLen = WSAGETASYNCBUFLEN(lp);
	LPHOSTENT lphost = (LPHOSTENT)malloc(iBufLen);
	memcpy2(lphost, hostentBuffer, iBufLen);
	hostsource->dwSrcIDHybrid = fast_ntohl(((LPIN_ADDR)lphost->h_addr_list[0])->s_addr);
	in_addr resolvedaddr = *(LPIN_ADDR)lphost->h_addr_list[0];
	free(lphost);

	AddLogLine( LOG_FL_DBG, _T(__FUNCTION__) _T(": Resolved source hostname: %s - %u.%u.%u.%u"),
					 hostsource->sourceHostname,
					 resolvedaddr.S_un.S_un_b.s_b1,
					 resolvedaddr.S_un.S_un_b.s_b2,
					 resolvedaddr.S_un.S_un_b.s_b3,
					 resolvedaddr.S_un.S_un_b.s_b4 );

	CPartFile* partfile = this->GetFileByID(hostsource->filehashkey);

	if (partfile != NULL)
		partfile->AddClientSource(hostsource);
	else
	{
	//	TODO: notify user the partfile exists no more?
		DEBUG_ONLY(AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T(__FUNCTION__) _T(": impossible to add source because the partfile doesn't exist anymore")));
	}
	delete hostsource;
	memzero(hostentBuffer, sizeof(hostentBuffer));
	ResolveNextSourceHostname();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::GetUDPSearchStatus(CString *pstrOut)
{
	if (!m_bIsInitialized
#ifdef OLD_SOCKETS_ENABLED
		|| m_partFileList.IsEmpty() || !g_App.m_pServerConnect->IsConnected()
#endif //OLD_SOCKETS_ENABLED
		)
		GetResString(pstrOut, IDS_FSTAT_WAITING);
	else if (m_pCurUDPServer != NULL)
		GetResString(pstrOut, IDS_UDPSEARCH_PROGRESS);
	else if (m_dwLastUDPSearchTime)
	{
		uint32 dwNextUDPSearchTimeInSec = (m_dwLastUDPSearchTime + UDPSERVERREASKTIME - ::GetTickCount())/1000;

	//	Avoid to show some crazy time when search moment came, but search wasn't initiated yet
		if (dwNextUDPSearchTimeInSec > UDPSERVERREASKTIME)
			dwNextUDPSearchTimeInSec = 0;
		pstrOut->Format(GetResString(IDS_UDPSEARCH_NEXT), CastSecondsToHM(dwNextUDPSearchTimeInSec));
	}
	else
		GetResString(pstrOut, IDS_UDPSEARCH_NOTSTART);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SetA4AFAutoFile(CPartFile *file)
{
	EMULE_TRY

	m_A4AF_auto_file = file;

	if (file)
		g_App.m_pPrefs->SetA4AFHash(file->GetFileHash());
	else
	{
	//	Set null hash
		uchar null_hash[16];

		md4clr(null_hash);
		g_App.m_pPrefs->SetA4AFHash(null_hash);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::ResetCatParts(int iCatIndex)
{
//	We need a copy of the list because of the original list update done in SetCatID
	CTypedPtrList<CPtrList, CPartFile*> locallist;

	POSITION		pos;
	CPartFile	   *pPartFile;

	for (pos = m_partFileList.GetHeadPosition(); pos != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos);
		if (pPartFile != NULL)
			locallist.AddTail(pPartFile);
	}

	for (pos = locallist.GetHeadPosition(); pos != NULL;)
	{
		pPartFile = locallist.GetNext(pos);

		if (CCat::GetCatIndexByID(pPartFile->GetCatID()) == iCatIndex)
			pPartFile->SetCatID(CAT_NONE);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SetCatPrio(int iCatIndex, byte newprio)
{
//	We need a copy of the list because of the original list update done in SetCatID
	CTypedPtrList<CPtrList, CPartFile*>	locallist;

	POSITION		pos;
	CPartFile	   *pPartFile;

	for (pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		pPartFile = m_partFileList.GetNext(pos);
		if (pPartFile)
		{
			locallist.AddTail(pPartFile);
		}
	}

	for (pos = locallist.GetHeadPosition(); pos != NULL; )
	{
		pPartFile = locallist.GetNext(pos);

		if (iCatIndex == 0 || CCat::GetCatIndexByID(pPartFile->GetCatID()) == iCatIndex)
		{
			if (newprio == PR_AUTO)
			{
				pPartFile->SetAutoPriority(true);
				pPartFile->UpdateDownloadAutoPriority();
			}
			else
			{
				pPartFile->SetAutoPriority(false);
				pPartFile->SetPriority(newprio);
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SetCatStatus(int iCatIndex, uint16 newstatus)
{
	bool reset = false;
	POSITION pos = m_partFileList.GetHeadPosition();

	while (pos != NULL)
	{
		CPartFile * cur_file = m_partFileList.GetNext(pos);

		if (!cur_file)
			continue;

		if ( iCatIndex == -1 || (iCatIndex == -2 && cur_file->GetCatID() == 0)
		     || (iCatIndex == 0 && CCat::FileBelongsToGivenCat(cur_file, CAT_ALL))
		     || (iCatIndex >= CCat::GetNumPredefinedCats() && CCat::GetCatIDByIndex(iCatIndex) == cur_file->GetCatID()) )
		{
			switch (newstatus)
			{
				case MP_CANCEL:
					cur_file->DeleteFile();
					reset = true;
					break;
				case MP_PAUSE:
					cur_file->PauseFile();
					break;
				case MP_STOP:
					cur_file->StopFile();
					break;
				case MP_RESUME:
					if(cur_file->GetStatus() == PS_PAUSED || cur_file->GetStatus() == PS_STOPPED)
						cur_file->ResumeFile();
					break;
			}
		}
		if (reset)
		{
			reset = false;
			pos = m_partFileList.GetHeadPosition();
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::SetAutoCat(CPartFile *pPartFile)
{
	if (CCat::GetNumCats() > 1)
	{
		for (int ix = CCat::GetNumPredefinedCats(); ix < CCat::GetNumCats(); ix++)
		{
			int		iCurPos = 0;
			CString	strCatExt = CCat::GetCatByIndex(ix)->GetAutoCatExt();

		//	No need to compare again an empty AutoCat array
			if (strCatExt.IsEmpty())
				continue;

			strCatExt.MakeLower();

			CString	strFullName = pPartFile->GetFileName();

			strFullName.MakeLower();

			CString	strCmpExt = strCatExt.Tokenize(_T("|"), iCurPos);

			while (!strCmpExt.IsEmpty())
			{
			//	Allow wildcards in autocat string
				if (strCmpExt.FindOneOf(_T("*?")) != -1)
				{
				//	Use wildcards
					if (PathMatchSpec(static_cast<LPCTSTR>(strFullName.GetString()), static_cast<LPCTSTR>(strCmpExt.GetString())))
					{
						if (pPartFile->GetCatID() == CAT_NONE)
							pPartFile->SetCatID(CCat::GetCatIDByIndex(ix));
						return;
					}
				}
				else
				{
					if (strFullName.Find(strCmpExt) != -1)
					{
						if (pPartFile->GetCatID() == CAT_NONE)
							pPartFile->SetCatID(CCat::GetCatIDByIndex(ix));
						return;
					}
				}
				strCmpExt = strCatExt.Tokenize(_T("|"), iCurPos);
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SaveAllSLSFiles() - Updates all .txtsrc files with current sources
void CDownloadQueue::SaveAllSLSFiles()
{
	EMULE_TRY

	if (g_App.m_pPrefs->SLSEnable())
	{
		for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
		{
			CPartFile	*pPartFile = m_partFileList.GetNext(pos);

		//	Don't save if nothing to save...
			if ((pPartFile != NULL) && (pPartFile->GetSourceCount() != 0))
				g_App.m_pDownloadQueue->m_sourcesaver.Process(pPartFile, g_App.m_pPrefs->SLSMaxSourcesPerFile(), true);
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.296
log
@Reduced H-file dependency.
@
text
@d32 3
@


1.295
log
@Fixed UDP packets reception when remote client is behind UDP portmapping router (from original).
@
text
@d31 1
@


1.294
log
@Reduced H-file dependency.
@
text
@d1126 1
a1126 1
	CUpDownClient	*pSource;
d1129 1
d1140 8
a1147 4
				pSource = *cIt;

				if ((dwIP == pSource->GetIP()) && (uUDPPort == pSource->GetUDPPort()))
					return pSource;
d1151 4
d1156 1
@


1.293
log
@Don't send UDP source requests to the dead static servers to save on traffic; Some formatting.
@
text
@d28 1
@


1.292
log
@Fixed addition of HighID source to a file from a received shared file list (issue was introduced in the previous revision);
Added ability to append sources from the search list to already downloading files by starting downloading again.
@
text
@d62 1
a62 1
	pCurUDPServer = NULL;
d984 3
a986 3
	pCurUDPServer = g_App.m_pServerList->GetSuccServer(pCurUDPServer);
//	Check local server & try switch to another one
	if (pCurUDPServer == g_App.m_pServerList->GetServerByAddress(pCurServer->GetAddress(), pCurServer->GetPort()))
d988 5
a992 1
		pCurUDPServer = g_App.m_pServerList->GetSuccServer(pCurUDPServer);
d998 1
a998 1
	if (pCurUDPServer == NULL)
d1004 1
a1004 1
	uint32		dwSz, dwPos, dwSrvUDPFlags = pCurUDPServer->GetUDPFlags();
d1073 1
a1073 1
		g_App.m_pServerConnect->SendUDPPacket(&packet, pCurUDPServer, false);
d1084 1
a1084 3
	EMULE_TRY

	pCurUDPServer = NULL;
a1085 2

	EMULE_CATCH
d1543 1
a1543 1
	else if (pCurUDPServer)
@


1.291
log
@Ability to add known LowID source through remote client shared files list; Fast byte swap for ntohl and ntohs;
Removed duplicate checks for ClientSourcesList as it's covered by HasValidSources() verification.
@
text
@a247 2
	if (FileExists(pNewSearchFile->GetFileHash()))
		return;
d249 1
a249 1
	CPartFile	*pNewPartFile = new CPartFile(pNewSearchFile, eCatID);
d251 6
a256 1
	if (pNewPartFile->GetStatus() == PS_ERROR)
d258 7
a264 2
		delete pNewPartFile;
		return;
a265 1
	AddDownload(pNewPartFile, bPaused);
d280 1
a280 9
			if (pNewPartFile != NULL)
				pNewPartFile->AddClientSource(&source, 0, false, 0, ADDSRC_KNOWNSRC);
			else
			{
				CPartFile	*pPartFile = GetFileByID(pNewSearchFile->GetFileHash());

				if (pPartFile != NULL)
					pPartFile->AddClientSource(&source, 0, false, 0, ADDSRC_KNOWNSRC);
			}
a320 1
	{
a321 1
	}
d325 1
a325 1
		if (pNewPartFile)
d345 2
a346 1
	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
d803 1
a803 1
	else if ((iMode & ADDSRC_KNOWNSRC) == 0)	//	return if known source is not found
@


1.290
log
@Added AICH hash decoding from the link (just preparation for future - it's not used in anyway).
@
text
@d271 1
d274 1
a274 1
				pNewPartFile->AddClientSource(&source, 0, false, 0);
d280 1
a280 1
					pPartFile->AddClientSource(&source, 0, false, 0);
d330 2
a331 3
			if (pLink->ClientSourcesList)
			//	Add all IP sources and eliminate them from list
				pNewPartFile->AddClientSources(pLink->ClientSourcesList);
d337 1
a337 1
			if (pPartFile && pLink->ClientSourcesList)
d731 1
a731 1
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwUserIDHyb, uint16 uUserPort, uint32 dwSrvIP, uint16 uSrvPort, uchar *pbyteUserHash)
d738 1
a738 1
	uint32	dwIP = ntohl(dwUserIDHyb);
d754 1
a754 1
//	1) The LowID source cann't be filtered, so we need to be sure that client has the server IP & port
d760 5
a764 1
			return NULL;
d805 1
a805 1
	else
d1512 1
a1512 1
	hostsource->dwSrcIDHybrid = ntohl(((LPIN_ADDR)lphost->h_addr_list[0])->s_addr);
@


1.289
log
@Fixed duplicate file added to the download list through ed2k link on startup {glaskrug}.
@
text
@d342 6
@


1.288
log
@Reduced H-file dependency.
@
text
@d310 3
@


1.287
log
@Workaround to avoid download queue exceptions when file priority is changed (for example, file priority is changed in auto mode).
@
text
@d22 1
@


1.286
log
@Reduced #include dependency.
@
text
@d504 1
a504 1
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);
d513 4
@


1.285
log
@Keep IP-filter description strings in ASCII to reduce memory usage.
@
text
@d27 1
@


1.284
log
@Removed unneeded checks around delete operators.
@
text
@d752 1
a752 1
			AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Filtered (reject as new source): %u.%u.%u.%u %s"),
d762 1
a762 1
	if (pTempSource)
d765 1
a765 1
		if (!pTempSource->m_pReqPartFile)
@


1.283
log
@Simplified logging system implementation.
@
text
@d1412 3
a1414 6
			if (m_wndHSCallback)
			{
			//	Free unneccessary window
				delete m_wndHSCallback;
				m_wndHSCallback = NULL;
			}
d1454 2
a1455 5
			if (m_wndHSCallback)
			{
				delete m_wndHSCallback;
				m_wndHSCallback = NULL;
			}
@


1.282
log
@Formatting.
@
text
@d218 1
a218 3
	{
		AddLogLine(false, IDS_NOPARTSFOUND);
	}
d221 1
a221 1
		AddLogLine(false, IDS_FOUNDPARTS, iCount);
d243 1
a243 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_SKIPZEROLENGTHFILE), pNewSearchFile->GetFileName());
d403 1
a403 1
	AddLogLine(true, IDS_NEWDOWNLOAD, pNewPartFile->GetFileName(), strCategory);
d426 1
a426 1
			AddLogLine(true, IDS_ERR_ALREADY_DOWNLOADING, pKnownFile->GetFileName());
d428 1
a428 1
			AddLogLine(true, IDS_ERR_ALREADY_DOWNLOADED, pKnownFile->GetFileName());
d433 1
a433 1
		AddLogLine(true, IDS_ERR_ALREADY_DOWNLOADING, pKnownFile->GetFileName());
d752 1
a752 1
			AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Filtered (reject as new source): %u.%u.%u.%u %s"),
d1278 1
a1278 1
			AddDebugLogLine( RGB_LOG_NOTICE_TXT _T("AutoSourcesPerFile: TMC=%u / Total=%u -> Changed from %u to %u (%+d)"),
d1288 1
a1288 1
		AddDebugLogLine( RGB_LOG_NOTICE_TXT _T("AutoSourcesPerFile: TMC=%u / Total=%u -> Not changed from %u"),
d1442 1
a1442 1
	AddDebugLogLine(_T(__FUNCTION__) _T(": Resolving source hostname: %s"), source->sourceHostname);
d1454 1
a1454 1
			AddDebugLogLine( RGB_LOG_ERROR_TXT _T(__FUNCTION__) _T(": Error calling WSAAsyncGetHostByName to resolve source '%s'"),
d1469 1
a1469 1
			AddDebugLogLine(_T(__FUNCTION__) _T(": Source resolve retry number %i"), sourceHostnameResolveRetry);
d1487 1
a1487 1
		DEBUG_ONLY(AddDebugLogLine(RGB_LOG_ERROR_TXT _T(__FUNCTION__) _T(": Error resolving source '%s'"), hostsource->sourceHostname));
d1503 1
a1503 1
	AddDebugLogLine( _T(__FUNCTION__) _T(": Resolved source hostname: %s - %u.%u.%u.%u"),
d1517 1
a1517 1
		DEBUG_ONLY(AddDebugLogLine(RGB_LOG_WARNING_TXT _T(__FUNCTION__) _T(": impossible to add source because the partfile doesn't exist anymore")));
@


1.281
log
@Corrected used Packet construction (no bad impact was caused by this issue).
@
text
@d96 1
a96 1
		if (pPartFile)
d1396 1
a1396 1
	if (pLink)
d1399 1
a1399 5
	if (hostnameResolveQueue.IsEmpty())
		return;

	if (m_bIsResolving)
	{
a1400 1
	}
d1421 1
a1421 1
			return ;
d1577 1
a1577 1
	for (pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d1580 1
a1580 2
		if (pPartFile)
		{
a1581 1
		}
d1584 1
a1584 1
	for (pos = locallist.GetHeadPosition(); pos != NULL; )
@


1.280
log
@Corrected log message regarding downloaded and downloading files {muleteer}.
@
text
@d610 1
a610 1
					Packet	*packet = new Packet(new char[iStreamSize], iStreamSize, true, false);
@


1.279
log
@Suppressed compiler warnings; Reduced H-file dependency [Aw3].
@
text
@d427 1
a427 1
		if (dynamic_cast<CPartFile*>(pKnownFile) != NULL)
@


1.278
log
@Reduced #include dependency.
@
text
@d19 1
a21 1
#include "opcodes.h"
d590 1
a590 1
			const int	iStreamSize = packetStream.GetLength();
d1134 1
a1134 1
void CDownloadQueue::GetDownloadStats(uint16 auSrc[], uint64 aqwData[])
d1138 1
a1138 1
	memzero(auSrc, sizeof(auSrc[0]) * STATS_DLSRC_COUNT);
d1143 1
a1143 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d1145 1
a1145 2
		pPartFile = m_partFileList.GetNext(pos);
		if (pPartFile)
d1147 12
a1158 14
			auSrc[STATS_DLSRC_TOTAL] += pPartFile->GetSourceCount();
			auSrc[STATS_DLSRC_TRANSFERRING] += pPartFile->GetTransferringSrcCount();
		//	Extra stats
			auSrc[STATS_DLSRC_ONQUEUE] += pPartFile->GetOnQueueSrcCount();
			auSrc[STATS_DLSRC_QUEUEFULL] += pPartFile->GetQueueFullSrcCount();
			auSrc[STATS_DLSRC_NNS] += pPartFile->GetNoNeededPartsSrcCount();
			auSrc[STATS_DLSRC_CONNECTED] += pPartFile->GetConnectedSrcCount();

			auSrc[STATS_DLSRC_CONNECTING] += pPartFile->GetConnectingSrcCount();
			auSrc[STATS_DLSRC_CONNECTING_VIA_SRV] += pPartFile->GetConnectingViaServerSrcCount();
			auSrc[STATS_DLSRC_WAIT4FILEREQ] += pPartFile->GetWaitForFileReqSrcCount();
			auSrc[STATS_DLSRC_LOW2LOW] += pPartFile->GetLow2LowSrcCount();
			auSrc[STATS_DLSRC_LOWID_ON_OTHER_SRV] += pPartFile->GetLowIDOnOtherServer();
			auSrc[STATS_DLSRC_HIGH_QR] += pPartFile->GetHighQRSrcCount();
d1175 1
a1175 1
	auSrc[STATS_DLSRC_BANNED] = static_cast<uint16>(m_dwBannedCounter);
a1268 1
	{
a1269 1
	}
a1270 1
	{
a1271 1
	}
d1281 1
a1281 1
							 cur_tmc, cur_stotal, old_mspf, new_mspf, new_mspf-old_mspf );
@


1.277
log
@Suppressed level 4 warnings.
@
text
@d27 1
@


1.276
log
@Reduced #include depedency.
@
text
@d419 2
a420 1
	bool	bFileExists = false;
d424 1
a424 1
	if (CKnownFile *pKnownFile = m_pSharedFileList->GetFileByID(strFileHash))
d432 1
a432 1
	else if (pKnownFile = GetFileByID(strFileHash))
d1078 1
a1078 1
	uint32			i = 0;
d1490 1
@


1.275
log
@Encryption preparations;
Reduced #include dependency; Removed local preferences pointer; Formatting.
@
text
@d20 1
@


1.274
log
@Encryption preparations.
@
text
@d20 1
d25 1
d54 1
a54 1
CDownloadQueue::CDownloadQueue(CPreferences *in_pPrefs, CSharedFileList *in_pSharedFileList)
a55 1
	m_pPrefs = in_pPrefs;
d57 1
a57 1
	m_iDataRate = 0;
d63 1
a63 1
	m_iUDCounter = 0;
d149 1
a149 1
	CString	strTempDir = m_pPrefs->GetTempDir();
d153 1
a153 1
	m_pPrefs->TempDirListCopy(&tmpTempDirList);
d237 1
a237 1
void CDownloadQueue::AddSearchToDownload(CSearchFile *pNewSearchFile, EnumCategories eCatID /*=CAT_NONE*/, bool bPaused)
d477 1
a477 1
	uint32	dwMaxDLSpeed = m_pPrefs->GetMaxDownload();
d479 1
a479 1
	if ((dwMaxDLSpeed != UNLIMITED) && ((m_iDataRate > 1500) || (dwMaxDLSpeed < 30)))
d485 1
a485 1
		dwDownSpeed = (dwMaxDLSpeedBPS * 10) / (m_iDataRate + 1);
d498 1
a498 1
	m_iUDCounter++;
d509 1
a509 1
				dwDataRate += pPartFile->Process(dwDownSpeed, m_iUDCounter /*iteration*/);
d512 1
a512 1
	m_iDataRate = dwDataRate;
d543 1
a543 1
	if (m_iUDCounter == 2 && g_App.m_pServerConnect->IsConnected() && !m_LocalServerSourcesReqQueue.IsEmpty())
d595 4
d600 1
d621 1
a621 1
	if (m_iUDCounter == 5)
d629 1
a629 2

	if (m_iUDCounter == 10)
d631 1
a631 1
		m_iUDCounter = 0;
d773 1
a773 1
				g_App.m_pDownloadList->AddSource(pSenderFile,pTempSource, false);
d779 1
a779 1
				g_App.m_pDownloadList->AddSource(pSenderFile,pTempSource, true);
d789 1
a789 1
		if (g_App.m_pClientList->AddClient(pNewSource,true))
d794 1
a794 1
			g_App.m_pDownloadList->AddSource(pSenderFile,pNewSource,false);
d956 4
a959 1
	if (!m_bIsInitialized || m_partFileList.IsEmpty() || !g_App.m_pServerConnect->IsConnected())
d961 1
d975 1
a975 1
//	in both case we will stop any UDP request
@


1.273
log
@Code restructuring, update and formatting.
@
text
@d294 1
a294 1
			pNewPartFile->AddServerSources(sourcesFile, pNewSearchFile->GetClientServerIP(), pNewSearchFile->GetClientServerPort());
@


1.272
log
@Newly added stuff was renamed according to the original for easier reference;
Avoided allocation of a big memory chunk for small stream object;
Removed useless check for "dwHybridUserID == 0 && pbyteUserHash" -- not required according to IsGoodHybridID();
Avoided unrequired IP conversion.
@
text
@d957 1
a957 1
	pCurUDPServer = g_App.m_pServerList->GetNextServer(pCurUDPServer);
d961 1
a961 1
		pCurUDPServer = g_App.m_pServerList->GetNextServer(pCurUDPServer);
@


1.271
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d260 1
a260 1
		if ( pNewSearchFile->GetType() == SFT_CLIENT)
d264 1
a264 1
			source.dwHybridSourceID = pNewSearchFile->GetClientHybridID();
a269 1
			{
a270 1
			}
d275 1
a275 1
				if (pPartFile)
d282 1
a282 1
			CMemFile	sourcesFile;
d285 1
a285 1
			byte 		byteSources = 1;
a287 1

a289 1

d710 1
a710 1
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwHybridUserID, uint16 nUserPort, uint32 dwSrvIP, uint16 uSrvPort, uchar *pbyteUserHash)
d714 1
a714 2
//	Prevent an addition of the client that we will not be able to identify
	if (dwHybridUserID == 0 && pbyteUserHash == NULL)
d717 1
a717 2
	if (!IsGoodHybridID(dwHybridUserID))
		return NULL;
d720 1
a720 2
	if(dwHybridUserID == ntohl(g_App.m_pPrefs->GetLancastIP()) && nUserPort == g_App.m_pPrefs->GetPort())
	{
a721 1
	}
d734 2
a735 2
//	2) Filter HighID source over an IP that extracted from HybridUserID
	if (IsLowID(dwHybridUserID))
d741 1
a741 1
	else if ( g_App.m_pIPFilter->IsFiltered(ntohl(dwHybridUserID)) )
d747 2
a748 2
							 (byte)dwHybridUserID>>24, (byte)(dwHybridUserID>>16), (byte)(dwHybridUserID>>8),
							 (byte)(dwHybridUserID), g_App.m_pIPFilter->GetLastHit() );
d753 1
a753 1
	CUpDownClient	*pTempSource = g_App.m_pClientList->FindClient(dwHybridUserID, nUserPort, dwSrvIP, uSrvPort, pbyteUserHash);
d768 1
a768 1
				g_App.m_pDownloadList->AddSource(pSenderFile,pTempSource,false);
d774 1
a774 1
				g_App.m_pDownloadList->AddSource(pSenderFile,pTempSource,true);
d782 1
a782 1
		CUpDownClient* pNewSource = new CUpDownClient(nUserPort, dwHybridUserID, dwSrvIP, uSrvPort, pSenderFile, CIDT_HYBRID);
d801 1
a801 1
bool CDownloadQueue::CheckAndAddKnownSource(CPartFile* pPartFile,CUpDownClient* pKnownSource)
d814 1
a814 1
	if (!IsGoodHybridID(pKnownSource->GetHybridUserID()))
d1500 1
a1500 1
	hostsource->dwHybridSourceID = ntohl(((LPIN_ADDR)lphost->h_addr_list[0])->s_addr);
@


1.270
log
@Fixed incorrect filtering out of some LowID sources.
@
text
@d257 1
a257 4
//	If the search result is from a client ('View Files') add that client as source
	if ( pNewSearchFile->GetType() == SFT_CLIENT
	  && pNewSearchFile->GetClientID()
	  && pNewSearchFile->GetClientPort() )
d259 4
a262 1
		CMemFile	sourcesFile;
d264 4
a267 2
		uint16		uSources = 1;
		sourcesFile.Write(&uSources, sizeof uSources);
d269 7
a275 2
		uint32		uIP = pNewSearchFile->GetClientID();
		sourcesFile.Write(&uIP, sizeof uIP);
d277 3
a279 13
		uint16		uPort = pNewSearchFile->GetClientPort();
		sourcesFile.Write(&uPort, sizeof uPort);

		uIP = pNewSearchFile->GetClientServerIP();
		sourcesFile.Write(&uIP, sizeof uIP);

		uPort = pNewSearchFile->GetClientServerPort();
		sourcesFile.Write(&uPort, sizeof uPort);

		sourcesFile.SeekToBegin();
		if (pNewPartFile)
		{
			pNewPartFile->AddClientSources(&sourcesFile);
d283 7
a289 1
			CPartFile	*pPartFile = GetFileByID(pNewSearchFile->GetFileHash());
d291 8
a298 2
			if (pPartFile)
				pPartFile->AddClientSources(&sourcesFile);
a301 17
//	If the search result is from OP_GLOBSEARCHRES there may also be a source
	if (pNewSearchFile->GetClientID() && pNewSearchFile->GetClientPort())
	{
		CMemFile sourcesFile;
		byte uSources = 1;

		sourcesFile.Write(&uSources, 1);

		uint32 uIP = pNewSearchFile->GetClientID();
		sourcesFile.Write(&uIP, 4);

		uint16 uPort = pNewSearchFile->GetClientPort();
		sourcesFile.Write(&uPort, 2);

		sourcesFile.SeekToBegin();
		pNewPartFile->AddSources(sourcesFile, pNewSearchFile->GetClientServerIP(), pNewSearchFile->GetClientServerPort());
	}
d714 1
a714 1
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwUserIP, uint16 nUserPort, uint32 dwSrvIP, uint16 uSrvPort, uchar *pbyteUserHash)
d719 1
a719 1
	if (dwUserIP == 0 && pbyteUserHash == NULL)
d722 1
a722 2
//	Prevent adding loopback sources (i.e. 127.x.x.x)
	if (((dwUserIP & 0xFF) == 0x7F) && !g_App.m_pPrefs->AllowLocalHostIP())
d726 1
a726 1
	if(dwUserIP == g_App.m_pPrefs->GetLancastIP() && nUserPort == g_App.m_pPrefs->GetPort())
d741 9
a749 4
//	Checks for ID and server are added as a temporary solution (until better redesign)
//	to avoid filtering LowID sources out, as dwUserIP for them is user ID and not IP address
	if ( ((dwUserIP >= 0x1000000) || (dwSrvIP == 0) || (uSrvPort == 0)) &&
		g_App.m_pIPFilter->IsFiltered(dwUserIP) )
d755 2
a756 2
							 (byte)dwUserIP, (byte)(dwUserIP>>8), (byte)(dwUserIP>>16),
							 (byte)(dwUserIP>>24), g_App.m_pIPFilter->GetLastHit() );
d761 1
a761 1
	CUpDownClient	*pTempSource = g_App.m_pClientList->FindClient(dwUserIP, nUserPort, dwSrvIP, uSrvPort, pbyteUserHash);
d790 1
a790 1
		CUpDownClient* pNewSource = new CUpDownClient(nUserPort, dwUserIP, dwSrvIP, uSrvPort, pSenderFile);
d819 1
a819 1
		return FALSE;
d822 2
a823 2
	if(!pKnownSource->HasLowID() && (pKnownSource->GetUserID() & 0xFF) == 0x7F)
		return FALSE;
d829 1
a829 1
		return FALSE;
d859 1
a859 1
	return TRUE;
d863 1
a863 1
	return FALSE;
d1508 1
a1508 1
	hostsource->sourceID = ((LPIN_ADDR)lphost->h_addr_list[0])->s_addr;
d1518 1
d1520 2
a1521 1
	if (partfile)
@


1.269
log
@Added server source requests of large files; Formatting;
Check for saving part file stats only once per second to reduce overhead.
@
text
@d722 1
a722 1
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwUserIP, uint16 nUserPort, uint32 dwServerIP, uint16 nServerPort, uchar *pbyteUserHash)
d750 4
a753 1
	if (g_App.m_pIPFilter->IsFiltered(dwUserIP))
d765 1
a765 1
	CUpDownClient	*pTempSource = g_App.m_pClientList->FindClient(dwUserIP, nUserPort, dwServerIP, nServerPort, pbyteUserHash);
d794 1
a794 1
		CUpDownClient* pNewSource = new CUpDownClient(nUserPort,dwUserIP,dwServerIP,nServerPort,pSenderFile);
@


1.268
log
@Added preferences.ini option (AllowLocalHostIP) to allow acceptance of local sources (127.*.*.*).
@
text
@d1 2
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
d31 2
d181 1
a181 1
			bool bLoadPartFileStatus = pPartFile->LoadPartFile(strTempDirPath, ff.GetFileName().GetBuffer());
d185 1
a185 1
				bLoadPartFileStatus = pPartFile->TryToRecoverPartFile(strTempDirPath, ff.GetFileName().GetBuffer());
d485 1
a485 1
		return ;
d487 1
a487 1
	uint32	iDownSpeed = 0;
d496 1
a496 1
		iDownSpeed = (dwMaxDLSpeedBPS * 10) / (m_iDataRate + 1);
d498 4
a501 4
		if (iDownSpeed < 50)
			iDownSpeed = 50;
		else if (iDownSpeed > 200)
			iDownSpeed = 200;
d507 1
a507 1
	uint32	iTempDataRate = 0;
d511 1
a511 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d520 1
a520 3
			{
				iTempDataRate += pPartFile->Process(iDownSpeed, m_iUDCounter /*iteration*/);
			}
d523 1
a523 2

	m_iDataRate = iTempDataRate;
a530 1

a557 1
			uint32		dwTmp;
d559 6
a564 3
			CMemFile	packetStream(22 * 15);
		//	Server accepts OP_GETSOURCES containing serveral files, plus <HASH 16><SIZE 4>
			bool		bSupportNewFormat = (g_App.m_pServerConnect->GetCurrentServer()->GetTCPFlags() & SRV_TCPFLG_EXT_GETSOURCES);
d572 2
a573 1
					(((eFileStatus = pPartFile->GetStatus()) == PS_READY) || (eFileStatus == PS_EMPTY)) )
d578 8
a585 2
						dwTmp = pPartFile->GetFileSize();
						packetStream.Write(&dwTmp, 4);
d589 1
a589 1
						Packet	   packet(OP_GETSOURCES, 16);
d604 1
a604 1
					Packet			packet(&packetStream);
d621 1
a621 1
				m_dwLastTCPSourcesRequestTime = ::GetTickCount();
d643 7
a651 8
//--- xrmb:keepPartFileStats ---
	if (m_lastPartFileStatsSave + 300000 < dwCurTick)
	{
		m_lastPartFileStatsSave = dwCurTick;

		SaveAllPartFileStats();
	}
//--- :xrmb ---
a769 1

d954 1
d960 1
a960 3
	if (!m_bIsInitialized)
		return false;
	if (m_partFileList.IsEmpty() || !g_App.m_pServerConnect->IsConnected())
d982 3
d986 3
a988 9
	int				iMaxFilesPerPacket = 1;

	if (pCurUDPServer->GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES)
		iMaxFilesPerPacket = 34;

	if (pCurUDPServer->GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES2)
		iMaxFilesPerPacket = 27;

	CMemFile	dataGlobGetSources(546);
d1003 2
a1004 2
	int		iRequestedFiles = 0;
	uint32	dwTmp;
d1008 1
a1008 3
		CPartFile	   *pNextPartFile = m_partFileList.GetNext(posLastSearchedFile);

		if (pNextPartFile)
d1012 3
a1014 2
			if (((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
				&& g_App.m_pPrefs->GetMaxSourcePerFileUDP() > pNextPartFile->GetSourceCount())
d1016 1
d1019 13
a1031 1
				if (pCurUDPServer->GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES2)
d1033 3
a1035 2
					dwTmp = pNextPartFile->GetFileSize();
					dataGlobGetSources.Write(&dwTmp, 4);
a1037 1
				iRequestedFiles++;
a1038 5

		//	If packet is filled break the loop
			if (iRequestedFiles >= iMaxFilesPerPacket)
				break;

d1045 1
a1045 1
	if (dataGlobGetSources.GetLength() != 0)
d1049 1
a1049 1
		packet.m_eOpcode = (pCurUDPServer->GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES2) ? OP_GLOBGETSOURCES2 : OP_GLOBGETSOURCES;
d1309 2
a1310 6

		if (pPartFile)
		{
			if (pPartFile->GetTransferringSrcCount() > 0)
				iCount++;
		}
@


1.267
log
@Large file size support preparations.
@
text
@d719 1
a719 1
//	Prevent an addition of the client that we will not be able to idenficate
d724 1
a724 1
	if ((dwUserIP & 0xFF) == 0x7F)
@


1.266
log
@Simplified/speeded up processing of partfile status.
@
text
@d1151 1
a1151 1
			uint32 dwNeededSpace = (pPartFile->GetFileSize() - pPartFile->GetRealFileSize());
d1158 1
a1158 1
				aqwData[STATS_DLDAT_ACTFILEREQSPACE] += dwNeededSpace;
d1161 1
a1161 1
			aqwData[STATS_DLDAT_FILEREQSPACETOTAL] += dwNeededSpace;
@


1.265
log
@update the state for LowID clients only after server change
@
text
@d105 1
a105 1
		if (pPartFile && pPartFile->GetStatus(true) == PS_READY)
d195 1
a195 1
				if (pPartFile->GetStatus(true) == PS_READY)
@


1.264
log
@new email notifier code (adapted from original) - fully UNICODE ready;
option to send email notification messages in subject
@
text
@d449 28
d512 1
a512 1
		if (pPartFile)
@


1.263
log
@Renaming.
@
text
@a22 1
#include "Smtp.h"
d417 1
a417 1
	g_App.m_pSMTPConnection->SendMail( strMessageText, g_App.m_pPrefs->GetUseDownloadAddNotifier(),
@


1.262
log
@improved the source removement
@
text
@d59 1
a59 1
	m_iAverageDataRate = 0;
d518 1
a518 1
		m_iAverageDataRate = static_cast<uint32>((static_cast<double>(m_averageDataRateList.front() - m_averageDataRateList.back())) * 1000.0 / (m_averageTickList.front() - m_averageTickList.back()));
d520 1
a520 1
		m_iAverageDataRate = 0;
@


1.261
log
@safe A4AF switch
@
text
@d905 1
@


1.260
log
@UNICODE preparation (first shot)
@
text
@d849 1
a849 5
			POSITION pos_A4AF = pPartFile->m_A4AFsrcList.Find(toremove);
			if (pos_A4AF)
			{
				pPartFile->m_A4AFsrcList.RemoveAt(pos_A4AF);
			}
@


1.259
log
@Corrected comment.
@
text
@d1651 1
a1651 1
void CDownloadQueue::SetAutoCat(CPartFile *newfile)
d1657 2
a1658 2
			int			curPos = 0;
			CString		catExt = CCat::GetCatByIndex(ix)->GetAutoCatExt();
d1661 1
a1661 1
			if (catExt == "")
d1664 1
a1664 1
			catExt.MakeLower();
d1666 1
a1666 1
			CString		fullname = newfile->GetFileName();
d1668 1
a1668 1
			fullname.MakeLower();
d1670 1
a1670 1
			CString		cmpExt = catExt.Tokenize("|", curPos);
d1672 1
a1672 1
			while (cmpExt != "")
d1675 1
a1675 1
				if (cmpExt.FindOneOf("*?") != -1)
d1678 1
a1678 3
					char * file = fullname.GetBuffer();
					char* spec = cmpExt.GetBuffer();
					if (PathMatchSpec(file, spec))
d1680 2
a1681 2
						if(newfile->GetCatID() == CAT_NONE)
							newfile->SetCatID(CCat::GetCatIDByIndex(ix));
d1687 1
a1687 1
					if (fullname.Find(cmpExt) != -1)
d1689 2
a1690 2
						if(newfile->GetCatID() == CAT_NONE)
							newfile->SetCatID(CCat::GetCatIDByIndex(ix));
d1694 1
a1694 1
				cmpExt = catExt.Tokenize("|", curPos);
@


1.258
log
@Fixed session statistics 'Parts Saved Due To ICH' {Fuxie - DK}.
@
text
@d692 1
a692 1
//	prevent an addtion of the client that we will not able to idenficate
d728 1
a728 1
	CUpDownClient	*pTempSource = g_App.m_pClientList->FindClient(dwUserIP,nUserPort,dwServerIP, nServerPort, pbyteUserHash);
@


1.257
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@a1123 1

a1124 2
			auSrc[STATS_DLSRC_SAVED_BY_ICH] += pPartFile->TotalPacketsSavedDueToICH();

@


1.256
log
@renamed 3 variables
@
text
@d189 1
a189 1
				if (md4cmp(pPartFile->GetFileHash(), g_App.g_pPrefs->GetA4AFHash()) == 0)
d326 1
a326 1
		AddDownload(pNewPartFile, g_App.g_pPrefs->StartDownloadPaused());
d376 1
a376 1
		if (pPartFile && pPartFile->GetStatus() == PS_PAUSED && ((!bFoundInSameCat && g_App.g_pPrefs->IsResumeOtherCat())
d418 2
a419 2
	g_App.m_pSMTPConnection->SendMail( strMessageText, g_App.g_pPrefs->GetUseDownloadAddNotifier(),
	                                        g_App.g_pPrefs->IsSMTPInfoEnabled() );
d421 1
a421 1
	                                      g_App.g_pPrefs->GetUseDownloadAddNotifier() );
d701 1
a701 1
	if(dwUserIP == g_App.g_pPrefs->GetLancastIP() && nUserPort == g_App.g_pPrefs->GetPort())
d720 1
a720 1
		if (!g_App.g_pPrefs->IsCMNotLog())
d794 3
a796 3
	if ( md4cmp(g_App.g_pPrefs->GetUserHash(), pKnownSource->GetUserHash()) == 0 &&
		 pKnownSource->GetIP() == g_App.g_pPrefs->GetLancastIP() &&
		 pKnownSource->GetUDPPort() == g_App.g_pPrefs->GetUDPPort() )
d989 1
a989 1
				&& g_App.g_pPrefs->GetMaxSourcePerFileUDP() > pNextPartFile->GetSourceCount())
d1154 1
a1154 1
	sint32 old_mspf = g_App.g_pPrefs->GetMaxSourcePerFile();
d1156 4
a1159 4
	sint32 min_spf = g_App.g_pPrefs->GetMinAutoSourcesPerFile();
	sint32 max_spf = g_App.g_pPrefs->GetMaxAutoSourcesPerFile();
	sint32 max_stotal = g_App.g_pPrefs->GetMaxAutoSourcesTotal();
	sint32 max_sesrc = g_App.g_pPrefs->GetMaxAutoExchangeSources();
d1176 1
a1176 1
			g_App.g_pPrefs->SetMinAutoSourcesPerFile(min_spf);
d1182 1
a1182 1
		g_App.g_pPrefs->SetMaxAutoSourcesPerFile(max_spf);
d1250 1
a1250 1
		g_App.g_pPrefs->SetMaxSourcePerFile(new_mspf);
d1252 1
a1252 1
		if (g_App.g_pPrefs->IsAutoSourcesLogEnabled())
d1259 2
a1260 2
		sint32 new_sesrc = g_App.g_pPrefs->GetMaxSourcePerFileSoft();
		g_App.g_pPrefs->SetXSUpTo((new_sesrc < max_sesrc) ? new_sesrc : max_sesrc);
d1262 1
a1262 1
	else if (g_App.g_pPrefs->IsAutoSourcesLogEnabled())
d1536 1
a1536 1
		g_App.g_pPrefs->SetA4AFHash(file->GetFileHash());
d1543 1
a1543 1
		g_App.g_pPrefs->SetA4AFHash(null_hash);
d1710 1
a1710 1
	if (g_App.g_pPrefs->SLSEnable())
d1718 1
a1718 1
				g_App.m_pDownloadQueue->m_sourcesaver.Process(pPartFile, g_App.g_pPrefs->SLSMaxSourcesPerFile(), true);
@


1.255
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d189 2
a190 2
				if (md4cmp(pPartFile->GetFileHash(), g_eMuleApp.m_pGlobPrefs->GetA4AFHash()) == 0)
					g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(pPartFile);
d199 1
a199 1
				g_eMuleApp.m_pDownloadList->AddFile(pPartFile);
d308 1
a308 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d326 1
a326 1
		AddDownload(pNewPartFile, g_eMuleApp.m_pGlobPrefs->StartDownloadPaused());
d346 1
a346 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d376 1
a376 1
		if (pPartFile && pPartFile->GetStatus() == PS_PAUSED && ((!bFoundInSameCat && g_eMuleApp.m_pGlobPrefs->IsResumeOtherCat())
d407 1
a407 1
	g_eMuleApp.m_pDownloadList->AddFile(pNewPartFile);
d418 4
a421 4
	g_eMuleApp.m_pSMTPConnection->SendMail( strMessageText, g_eMuleApp.m_pGlobPrefs->GetUseDownloadAddNotifier(),
	                                        g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled() );
	g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessageText, TBN_DLOAD_ADD, false,
	                                      g_eMuleApp.m_pGlobPrefs->GetUseDownloadAddNotifier() );
d503 1
a503 1
		m_averageDataRateList.push_front(g_eMuleApp.stat_sessionReceivedBytes);
d528 1
a528 1
	if (m_iUDCounter == 2 && g_eMuleApp.m_pServerConnect->IsConnected() && !m_LocalServerSourcesReqQueue.IsEmpty())
d536 1
a536 1
			bool		bSupportNewFormat = (g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetTCPFlags() & SRV_TCPFLG_EXT_GETSOURCES);
d572 2
a573 2
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet.m_dwSize);
					g_eMuleApp.m_pServerConnect->SendPacket(&packet, false);
d582 2
a583 2
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
					g_eMuleApp.m_pServerConnect->SendPacket(packet, true);
d597 1
a597 1
			g_eMuleApp.m_pServerList->ServerStats();
d701 1
a701 1
	if(dwUserIP == g_eMuleApp.m_pGlobPrefs->GetLancastIP() && nUserPort == g_eMuleApp.m_pGlobPrefs->GetPort())
d716 1
a716 1
	if (g_eMuleApp.m_pIPFilter->IsFiltered(dwUserIP))
d718 3
a720 3
		InterlockedIncrement(&g_eMuleApp.m_lSXFiltered);
		InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);
		if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d723 1
a723 1
							 (byte)(dwUserIP>>24), g_eMuleApp.m_pIPFilter->GetLastHit() );
d728 1
a728 1
	CUpDownClient	*pTempSource = g_eMuleApp.m_pClientList->FindClient(dwUserIP,nUserPort,dwServerIP, nServerPort, pbyteUserHash);
d744 1
a744 1
				g_eMuleApp.m_pDownloadList->AddSource(pSenderFile,pTempSource,false);
d750 1
a750 1
				g_eMuleApp.m_pDownloadList->AddSource(pSenderFile,pTempSource,true);
d760 1
a760 1
		if (g_eMuleApp.m_pClientList->AddClient(pNewSource,true))
d765 1
a765 1
			g_eMuleApp.m_pDownloadList->AddSource(pSenderFile,pNewSource,false);
d794 3
a796 3
	if ( md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), pKnownSource->GetUserHash()) == 0 &&
		 pKnownSource->GetIP() == g_eMuleApp.m_pGlobPrefs->GetLancastIP() &&
		 pKnownSource->GetUDPPort() == g_eMuleApp.m_pGlobPrefs->GetUDPPort() )
d815 1
a815 1
					g_eMuleApp.m_pDownloadList->AddSource(pPartFile,pKnownSource,false);
d825 1
a825 1
	g_eMuleApp.m_pDownloadList->AddSource(pPartFile,pKnownSource,false);
d858 1
a858 1
		g_eMuleApp.m_pDownloadList->RemoveSource(toremove, NULL);
d931 1
a931 1
	if (m_partFileList.IsEmpty() || !g_eMuleApp.m_pServerConnect->IsConnected())
d934 1
a934 1
	CServer	*pCurServer = g_eMuleApp.m_pServerConnect->GetCurrentServer();
d937 1
a937 1
	pCurUDPServer = g_eMuleApp.m_pServerList->GetNextServer(pCurUDPServer);
d939 1
a939 1
	if (pCurUDPServer == g_eMuleApp.m_pServerList->GetServerByAddress(pCurServer->GetAddress(), pCurServer->GetPort()))
d941 1
a941 1
		pCurUDPServer = g_eMuleApp.m_pServerList->GetNextServer(pCurUDPServer);
d989 1
a989 1
				&& g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileUDP() > pNextPartFile->GetSourceCount())
d1017 2
a1018 2
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet.m_dwSize);
		g_eMuleApp.m_pServerConnect->SendUDPPacket(&packet, pCurUDPServer, false);
d1154 1
a1154 1
	sint32 old_mspf = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile();
d1156 4
a1159 4
	sint32 min_spf = g_eMuleApp.m_pGlobPrefs->GetMinAutoSourcesPerFile();
	sint32 max_spf = g_eMuleApp.m_pGlobPrefs->GetMaxAutoSourcesPerFile();
	sint32 max_stotal = g_eMuleApp.m_pGlobPrefs->GetMaxAutoSourcesTotal();
	sint32 max_sesrc = g_eMuleApp.m_pGlobPrefs->GetMaxAutoExchangeSources();
d1169 1
a1169 1
	sint32 current_dls = g_eMuleApp.m_pDownloadQueue->GetActiveFileCount();
d1176 1
a1176 1
			g_eMuleApp.m_pGlobPrefs->SetMinAutoSourcesPerFile(min_spf);
d1182 1
a1182 1
		g_eMuleApp.m_pGlobPrefs->SetMaxAutoSourcesPerFile(max_spf);
d1250 1
a1250 1
		g_eMuleApp.m_pGlobPrefs->SetMaxSourcePerFile(new_mspf);
d1252 1
a1252 1
		if (g_eMuleApp.m_pGlobPrefs->IsAutoSourcesLogEnabled())
d1259 2
a1260 2
		sint32 new_sesrc = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft();
		g_eMuleApp.m_pGlobPrefs->SetXSUpTo((new_sesrc < max_sesrc) ? new_sesrc : max_sesrc);
d1262 1
a1262 1
	else if (g_eMuleApp.m_pGlobPrefs->IsAutoSourcesLogEnabled())
d1510 1
a1510 1
		|| m_partFileList.IsEmpty() || !g_eMuleApp.m_pServerConnect->IsConnected()
d1536 1
a1536 1
		g_eMuleApp.m_pGlobPrefs->SetA4AFHash(file->GetFileHash());
d1543 1
a1543 1
		g_eMuleApp.m_pGlobPrefs->SetA4AFHash(null_hash);
d1710 1
a1710 1
	if (g_eMuleApp.m_pGlobPrefs->SLSEnable())
d1718 1
a1718 1
				g_eMuleApp.m_pDownloadQueue->m_sourcesaver.Process(pPartFile, g_eMuleApp.m_pGlobPrefs->SLSMaxSourcesPerFile(), true);
@


1.254
log
@Unicode corrections {KuSh}.
@
text
@d741 1
a741 1
				pSenderFile->m_srcLists[pTempSource->m_iSourcesSlot].AddTail(pTempSource);
d763 1
a763 1
			pSenderFile->m_srcLists[pNewSource->m_iSourcesSlot].AddTail(pNewSource);
d822 1
a822 1
	pPartFile->m_srcLists[pKnownSource->m_iSourcesSlot].AddTail(pKnownSource);
d843 1
a843 14
//	Check actual requested file (we have this info in "m_pReqPartFile")
	pPartFile = toremove->m_pReqPartFile;

	if (pPartFile != NULL && !pPartFile->m_srcLists[toremove->m_iSourcesSlot].IsEmpty())
	{
		POSITION remove_pos = pPartFile->m_srcLists[toremove->m_iSourcesSlot].Find(toremove);
		if (remove_pos != NULL)
		{
			pPartFile->m_srcLists[toremove->m_iSourcesSlot].RemoveAt(remove_pos);
		}
		pPartFile->NewSrcPartsInfo();
	}

//	Now remove client in A4AF files. Lets use "OtherRequests_list" for this matter
@


1.253
log
@1) name corrections
2) fixed the DL session cancel if remote client delays with sending of the first data block
3) added the "m_SourceLists" in header file
@
text
@d1440 1
a1440 1
	AddDebugLogLine(_T("%s: Resolving source hostname: %s"), __FUNCTION__, source->sourceHostname);
d1452 2
a1453 2
			AddDebugLogLine( RGB_LOG_ERROR_TXT _T("%s: Error calling WSAAsyncGetHostByName to resolve source '%s'"),
							 __FUNCTION__, hostsource->sourceHostname );
d1467 1
a1467 1
			AddDebugLogLine(_T("%s: Source resolve retry number %i"), __FUNCTION__, sourceHostnameResolveRetry);
d1484 1
a1484 1
		DEBUG_ONLY(AddDebugLogLine(RGB_LOG_ERROR_TXT _T("%s: Error resolving source '%s'"), __FUNCTION__, hostsource->sourceHostname));
d1500 1
a1500 2
	AddDebugLogLine( _T("%s: Resolved source hostname: %s - %i:%i:%i:%i"),
					 __FUNCTION__,
d1512 1
a1512 2
		DEBUG_ONLY(AddDebugLogLine( RGB_LOG_WARNING_TXT _T("%s: impossible to add source because the partfile doesn't exist anymore")
									__FUNCTION__ ));
@


1.252
log
@Unified handling of file comments.
@
text
@d874 1
a874 1
		toremove->m_pReqPartFile->AddPastComment(toremove);
@


1.251
log
@Faster processing of file comments.
@
text
@a850 1
			pPartFile->AddPastComment(toremove);
d873 2
a874 2
	if (!toremove->IsFileCommentEmpty() || (toremove->GetFileRating() != PF_RATING_NONE))
		toremove->m_pReqPartFile->UpdateFileRatingCommentAvail();
@


1.250
log
@Unified download queue statistics, removed unused stuff.
@
text
@d874 1
a874 1
	if (toremove->GetFileComment().GetLength() > 0 || toremove->GetFileRating() != PF_RATING_NONE)
@


1.249
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1112 1
a1112 2
// WARNING: by adding a new type don't forget to change constants in opcodes
void CDownloadQueue::GetDownloadStats(uint16 sources[], uint64 data[])
d1116 2
a1117 2
	memzero(sources, sizeof(sources[0]) * STATS_DL_SOURCES_TYPE);
	memzero(data, sizeof(data[0]) * STATS_DL_DATA_INFO);
d1126 2
a1127 2
			sources[0] += pPartFile->GetSourceCount();
			sources[1] += pPartFile->GetTransferringSrcCount();
d1129 14
a1142 15
			sources[2] += pPartFile->GetOnQueueSrcCount();
			sources[3] += pPartFile->GetQueueFullSrcCount();
			sources[4] += pPartFile->GetNoNeededPartsSrcCount();
			sources[5] += pPartFile->GetConnectedSrcCount();
			sources[6] += pPartFile->GetRecHashsetSrcCount();
			sources[7] += pPartFile->GetConnectingSrcCount();
			sources[8] += pPartFile->GetConnectingViaServerSrcCount();
			sources[9] += pPartFile->GetWaitForFileReqSrcCount();
			sources[10] += pPartFile->GetLow2LowSrcCount();
			sources[11] += pPartFile->GetUnknownSrcCount();
			sources[12] += pPartFile->GetLowIDOnOtherServer();
			sources[14] += pPartFile->TotalPacketsSavedDueToICH();
			sources[15] += pPartFile->GetSrcA4AFCount();
			sources[16] += pPartFile->GetTimeoutedSrcCount();
			sources[17] += pPartFile->GetHighQRSrcCount();
d1149 3
a1151 3
				data[2] += pPartFile->GetFileSize();
				data[3] += pPartFile->GetSizeToTransfer();
				data[4] += dwNeededSpace;
d1153 3
a1155 3
			data[5] += pPartFile->GetFileSize();
			data[6] += dwNeededSpace;
			data[9] += pPartFile->GetRealFileSize();
d1159 1
a1159 1
	sources[13] = static_cast<uint16>(m_dwBannedCounter);
@


1.248
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1138 1
a1138 1
			sources[10] += pPartFile->GetLowIDOnOtherServer();
d1140 1
a1140 1
			sources[12] += pPartFile->GetErrorSrcCount();
a1144 2
			sources[18] += pPartFile->GetLow2LowSrcCount();
		//	Some data
@


1.247
log
@Some eklmn's modifications.
@
text
@d76 1
a76 1
	m_uBannedCounter = 0;
d1138 1
a1138 1
			sources[10] += pPartFile->GetLow2LowSrcCount();
d1145 1
a1145 1
			sources[18] += pPartFile->GetNoUploadSrcCount();
d1163 1
a1163 1
	sources[13] = m_uBannedCounter;
@


1.246
log
@One more step to integrate eklmn's SSDQ.
@
text
@d76 1
d1137 1
a1137 1
			sources[9] += pPartFile->GetTooManyConnsSrcCount();
a1140 1
			sources[13] += pPartFile->GetBannedSrcCount();
d1163 2
d1182 1
a1182 1
		cur_tmc += cur_file->GetTooManyConnsSrcCount();
@


1.245
log
@Removed unrequired extra check.
@
text
@d834 1
a834 1
bool CDownloadQueue::RemoveSource(CUpDownClient* toremove, bool updatewindow)
d838 2
a839 3
	bool removed = false;
	CPartFile* cur_file;
//	Set client state to DS_NONE in order to prevent any action from him
d843 1
a843 1
	cur_file = toremove->m_pReqPartFile;
d845 1
a845 1
	if (cur_file != NULL && !cur_file->m_srcLists[toremove->m_iSourcesSlot].IsEmpty())
d847 1
a847 1
		POSITION remove_pos = cur_file->m_srcLists[toremove->m_iSourcesSlot].Find(toremove);
d850 2
a851 3
			cur_file->AddPastComment(toremove);
			cur_file->m_srcLists[toremove->m_iSourcesSlot].RemoveAt(remove_pos);
			removed = true;
d853 1
a853 1
		cur_file->NewSrcPartsInfo();
d859 2
a860 2
		cur_file = toremove->m_otherRequestsList.GetNext(pos);
		if (IsInDLQueue(cur_file))
d862 1
a862 1
			POSITION pos_A4AF = cur_file->m_A4AFsrcList.Find(toremove);
d865 1
a865 1
				cur_file->m_A4AFsrcList.RemoveAt(pos_A4AF);
a879 2
	return removed;

a880 2

	return false;
@


1.244
log
@The second step to integrate eklmn's SSDQ.
@
text
@d1108 1
a1108 1
				if ((pSource != NULL) && (dwIP == pSource->GetIP()) && (uUDPPort == pSource->GetUDPPort()))
@


1.243
log
@Corrections for SSDQ integration.
@
text
@d739 1
a739 1
				pTempSource->m_pReqPartFile = pSenderFile;
d761 1
a761 1
			pNewSource->m_pReqPartFile = pSenderFile;
d808 1
a808 1
				if (pPartFile->m_srcLists[pKnownSource->m_iSourcesSlot].Find(pKnownSource))
d820 1
a820 1
	pKnownSource->m_pReqPartFile = pPartFile;
d878 1
a878 1
	toremove->m_pReqPartFile = NULL;
d925 1
a925 1
		if (pPartFile)
d927 2
a928 5
			for (int sl = 0;sl < SOURCESSLOTS;sl++)
			{
				if (!pPartFile->m_srcLists[sl].IsEmpty())
					pPartFile->m_srcLists[sl].RemoveAll();
			}
@


1.242
log
@improved LowID check by SX (part 2)
@
text
@d1106 1
a1106 1
			pPartFile->GetCopySourceList(DS_DOWNLOADING, DS_LAST_QUEUED_STATE, &clientListCopy);
@


1.241
log
@Removed unused GetDownloadClientByIP service.
@
text
@d687 1
a687 1
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwUserIP, uint16 nUserPort, uint32 dwServerIP, uint16 nServerPort)
d691 4
d726 2
a727 4
// Now we need to check if client is already in the DL-queue which based on following ideas:
// 1. this function will be always called after object creation (only IP & port are known)
// 2. if client exist as source, he must be presented in ClientList
	CUpDownClient	*pTempSource = g_eMuleApp.m_pClientList->FindClientByPortAndID(dwUserIP,nUserPort);
a763 1
			//pNewSource->StartDLQueueWaitTimer();
@


1.240
log
@Simplified transition to eklmn's SSDQ.
@
text
@a1089 29
CUpDownClient* CDownloadQueue::GetDownloadClientByIP(uint32 dwIP)
{
	EMULE_TRY

	POSITION		pos1;
	CUpDownClient	*pSource;
	CPartFile		*pPartFile;
	ClientList		clientListCopy;

	for (pos1 = m_partFileList.GetHeadPosition(); pos1 != NULL;)
	{
		pPartFile = m_partFileList.GetNext(pos1);

		if (pPartFile != NULL)
		{
			pPartFile->GetCopySourceList(DS_DOWNLOADING, DS_LAST_QUEUED_STATE, &clientListCopy);
			for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
			{
				pSource = *cIt;

				if ((pSource != NULL) && (dwIP == pSource->GetIP()))
					return pSource;
			}
		}
	}
	EMULE_CATCH
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.239
log
@No need to get time twice, as it is the same.
@
text
@d1094 4
a1097 3
	POSITION			pos1, pos2;
	CUpDownClient	   *pSource;
	CPartFile		   *pPartFile;
d1103 1
a1103 1
		if (pPartFile)
d1105 2
a1106 1
			for (int sl = 0; sl < SOURCESSLOTS; sl++)
d1108 1
a1108 3
				for (pos2 = pPartFile->m_srcLists[sl].GetHeadPosition(); pos2 != NULL;)
				{
					pSource = pPartFile->m_srcLists[sl].GetNext(pos2);
d1110 2
a1111 5
					if (pSource && dwIP == pSource->GetIP())
					{
						return pSource;
					}
				}
d1119 1
a1119 1
CUpDownClient* CDownloadQueue::GetDownloadClientByIP_UDP(uint32 dwIP, uint16 nUDPPort)
d1123 4
a1126 3
	POSITION			pos1, pos2;
	CUpDownClient	   *pSource;
	CPartFile		   *pPartFile;
d1132 1
a1132 1
		if (pPartFile)
d1134 2
a1135 1
			for (int sl = 0; sl < SOURCESSLOTS; sl++)
d1137 1
a1137 3
				for (pos2 = pPartFile->m_srcLists[sl].GetHeadPosition(); pos2 != NULL;)
				{
					pSource = pPartFile->m_srcLists[sl].GetNext(pos2);
d1139 2
a1140 5
					if (pSource && dwIP == pSource->GetIP() && nUDPPort == pSource->GetUDPPort())
					{
						return pSource;
					}
				}
@


1.238
log
@Fixed saving and display of "Gained Due To Compression" global statistics.
@
text
@a520 2
	dwCurTick = ::GetTickCount();

@


1.237
log
@Cumulative statistics of lost due to corruption was always zero after restart {muleteer}.
@
text
@a1191 1
			data[1] += pPartFile->GetSessionGainDueToCompression();
a1203 1
			data[8] += pPartFile->GetGainDueToCompression();
@


1.236
log
@Optimized GetCurrentServer() calls (cache value for consecutive usage).
@
text
@a1191 1
			data[0] += pPartFile->GetSessionLostDueToCorruption();
a1193 1
			uint32 dwSizeToTransfer = 0;
d1197 1
a1197 2
			pPartFile->GetSizeToTransfer(dwSizeToTransfer);
			if ((eFileStatus ==  PS_READY) || (eFileStatus == PS_EMPTY))
d1200 1
a1200 1
				data[3] += dwSizeToTransfer;
a1204 1
			data[7] += pPartFile->GetLostDueToCorruption();
@


1.235
log
@Fixed wrong next UDP search time in statistics right before search start {Fuxie - DK} (problem #530).
@
text
@d957 2
d962 1
a962 1
	if (pCurUDPServer == g_eMuleApp.m_pServerList->GetServerByAddress(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetAddress(), g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetPort()))
@


1.234
log
@Removed unused parameter.
@
text
@d1586 4
@


1.233
log
@correcting own bug - values could be negative with insane amount of running downloads on start causing spf jump to max instead of min value
@
text
@d689 1
a689 1
CUpDownClient* CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, uint32 dwUserIP, uint16 nUserPort, uint32 dwServerIP, uint16 nServerPort, bool bSaveSources)
@


1.232
log
@Faster filename comparison during selecting next file to start,
as well as make case insensitive comparison.
@
text
@d1217 8
a1224 8
	uint32 cur_tmc = 0;
	uint32 cur_stotal = 0;
	uint32 old_mspf = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile();
	uint32 new_mspf = old_mspf;
	uint32 min_spf = g_eMuleApp.m_pGlobPrefs->GetMinAutoSourcesPerFile();
	uint32 max_spf = g_eMuleApp.m_pGlobPrefs->GetMaxAutoSourcesPerFile();
	uint32 max_stotal = g_eMuleApp.m_pGlobPrefs->GetMaxAutoSourcesTotal();
	uint32 max_sesrc = g_eMuleApp.m_pGlobPrefs->GetMaxAutoExchangeSources();
d1234 1
a1234 1
	uint32 current_dls = g_eMuleApp.m_pDownloadQueue->GetActiveFileCount();
d1237 1
a1237 1
		uint32 useful_min = max_stotal / current_dls;
d1324 1
a1324 2
		uint32 new_sesrc = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft();

@


1.231
log
@Removed unused variable; Improved string processing.
@
text
@d382 1
a382 1
				    && pStartFile->GetFileName() > pPartFile->GetFileName() ) )
@


1.230
log
@New protocol security features: provide file size for TCP & UDP server source requests {lugdunummaster};
Eliminated sending of empty UDP source request packet (OP_GLOBGETSOURCES);
Removed unrequired load during preparing of OP_GETSOURCES packet when nothing to send;
Avoided memory reallocations during preparing of source request packets.
@
text
@d17 1
a17 1
#include "StdAfx.h"
d20 2
a21 2
#include "partfile.h"
#include "ed2klink.h"
a73 2
//	We need to initialize this variable to prevent extra screen refreshing during start
	m_dwLastRefreshedDLDisplayTime = ::GetTickCount();
d240 1
a240 1
		return ;
d243 1
a243 1
		return ;
d250 1
a250 1
		return ;
d718 1
a718 1
			AddDebugLogLine( RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"),
d1319 1
a1319 1
			AddDebugLogLine( RGB_LOG_NOTICE + _T("AutoSourcesPerFile: TMC=%u / Total=%u -> Changed from %u to %u (%+d)"),
d1325 2
a1326 8
		if (new_sesrc < max_sesrc)
		{
			g_eMuleApp.m_pGlobPrefs->SetXSUpTo(new_sesrc);
		}
		else
		{
			g_eMuleApp.m_pGlobPrefs->SetXSUpTo(max_sesrc);
		}
d1330 1
a1330 1
		AddDebugLogLine( RGB_LOG_NOTICE + _T("AutoSourcesPerFile: TMC=%u / Total=%u -> Not changed from %u"),
d1505 1
a1505 1
			AddDebugLogLine( RGB_LOG_ERROR + _T("%s: Error calling WSAAsyncGetHostByName to resolve source '%s'"),
a1527 1

d1537 1
a1537 1
		DEBUG_ONLY(AddDebugLogLine(RGB_LOG_ERROR + _T("%s: Error resolving source '%s'"), __FUNCTION__, hostsource->sourceHostname));
d1543 1
a1543 1
		return ;
d1566 1
a1566 1
		DEBUG_ONLY(AddDebugLogLine( RGB_LOG_WARNING + _T("%s: impossible to add source because the partfile doesn't exist anymore")
d1574 1
a1574 1
CString CDownloadQueue::GetUDPSearchStatus()
d1576 1
a1576 4
	EMULE_TRY

	if (!m_bIsInitialized)
		return _T("");
d1578 1
a1578 3

	if (m_partFileList.IsEmpty() || !g_eMuleApp.m_pServerConnect->IsConnected())
		return _T("");
d1580 4
a1583 7

	CString strOut;

	if (pCurUDPServer)
	{
		strOut = GetResString(IDS_UDPSEARCH_PROGRESS);
	}
d1587 1
a1587 1
		strOut.Format( GetResString(IDS_UDPSEARCH_NEXT), CastSecondsToHM(dwNextUDPSearchTimeInSec));
d1590 1
a1590 6
		strOut = GetResString(IDS_UDPSEARCH_NOTSTART);

	return strOut;

	EMULE_CATCH
	return _T("");
@


1.229
log
@Fixed sources saving on close (don't save when option is disabled;
now really saves sources for all files; don't create empty .txtsrc files without sources).
@
text
@d525 5
a529 3
//	The code of sources refresh on local server was moved here in order prevent the situation
//	where the client is blacklisted. We create one 'packet' which contains the
//	15 buffered OP_GETSOURCES ED2K packets to be sent in one TCP frame every 300 sec
d531 1
a531 1
	if (m_iUDCounter == 2 && g_eMuleApp.m_pServerConnect->IsConnected())
d535 5
a539 2
			int iRequestedNumber = 0;
			CSafeMemFile		packetStream(22);
d544 1
d546 2
a547 1
				if (pPartFile != NULL && (pPartFile->GetStatus() == PS_READY || pPartFile->GetStatus() == PS_EMPTY))
d549 9
a557 1
					Packet	   *packet = new Packet(OP_GETSOURCES, 16);
d559 3
a561 3
					md4cpy(packet->m_pcBuffer, pPartFile->GetFileHash());
					packetStream.Write(packet->GetPacket(), packet->GetRealPacketSize());
					delete packet;
a565 2
			//	Create one 'packet' which contains all buffered OP_GETSOURCES ED2K packets to be sent in one TCP frame
			//	KuSh: in the official code bFromPF arg is set to false ? isn't this packet only sent for PartFile?
d570 12
a581 1
				Packet	*packet = new Packet(new char[iStreamSize], iStreamSize, true, false);
d583 5
a587 4
				packetStream.SeekToBegin();
				packetStream.Read(packet->GetPacket(), iStreamSize);
				g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
				g_eMuleApp.m_pServerConnect->SendPacket(packet, true);
d948 1
d982 5
a986 2
	CSafeMemFile	dataGlobGetSources(16);
	POSITION		posLastSearchedFile = NULL;
d1000 2
a1001 1
	int	iRequestedFiles = 0;
d1015 6
d1035 3
a1037 1
	Packet			packet(&dataGlobGetSources);
d1039 4
a1042 3
	packet.m_eOpcode = OP_GLOBGETSOURCES;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet.m_dwSize);
	g_eMuleApp.m_pServerConnect->SendUDPPacket(&packet, pCurUDPServer, false);
@


1.228
log
@Moved new function to proper place
@
text
@d90 1
a90 1
		CPartFile* pPartFile = dynamic_cast<CPartFile*>(m_partFileList.RemoveHead());
d105 1
a105 1
		CPartFile	* pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d366 1
a366 1
		pTempPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d375 1
a375 1
		pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d484 1
a484 1
		CPartFile	*pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d605 1
a605 1
		CPartFile	*pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d636 1
a636 1
		pTempPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d882 1
a882 1
		CPartFile* pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d902 1
a902 1
		CPartFile* pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d1734 1
a1734 1
						return ;
d1743 1
a1743 1
						return ;
d1752 1
a1752 1
// SaveAllSLSFiles() - Updates all .txtxsrc files with current sources
d1757 1
a1757 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;)
d1759 3
a1761 1
		CPartFile	*pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos));
d1763 3
a1765 3
		if (pPartFile)
		{
			g_eMuleApp.m_pDownloadQueue->m_sourcesaver.Process(pPartFile, g_eMuleApp.m_pGlobPrefs->SLSMaxSourcesPerFile());
@


1.227
log
@Add sources possibly received from global search (official).
Added missing translations in case countryflag.dll / ip-to-country.cvs is not found.
Notifier informs if a new version is available (not annoying, but still more likely
 to be noticed than just a log line).
Added 'Folder' column to Shared files window.
Prevent adding install/working dirs (\Webserver, \Db...) to Shared files.
+ some other minor changes/fixes.
@
text
@d1752 18
@


1.226
log
@Removed unused code.
@
text
@d291 18
@


1.225
log
@Changes to last features
@
text
@a98 12
void CDownloadQueue::UpdateDisplayedInfo(CUpDownClient *pSource, boolean bForceUpdate)
{
	EMULE_TRY

	if (!m_bIsInitialized)
		return;

	g_eMuleApp.m_pDownloadList->UpdateSource(pSource);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.224
log
@Changed the way we use backup files for .part.met (more user friendly)
Removed old code not needed.
@
text
@d269 1
a269 1
	if ( pNewSearchFile->GetType() == CSearchFile::SFT_CLIENT
@


1.223
log
@Fixed temporary directory list processing (double list entries which could be caused
by case sensitive compares; remove incorrect entries from the list; don't allow
main temp dir to be added to the list).
@
text
@d191 8
a198 1
			if (pPartFile->LoadPartFile(strTempDirPath, ff.GetFileName().GetBuffer()))
a222 34

	//	Try recovering any part.met.backup files
		strSearchPath += ".backup";
		bEnd = !ff.FindFile(strSearchPath, 0);
		while (!bEnd)
		{
			bEnd = !ff.FindNextFile();
			if (ff.IsDirectory())
				continue;

			CPartFile		*pPartFile = new CPartFile();

			if (pPartFile->LoadPartFile(strTempDirPath.GetBuffer(), ff.GetFileName().GetBuffer()))
			{
			//	Save backup again
				pPartFile->SavePartFile();
				iCount++;
			//	Add it to the download queue
				m_partFileList.AddTail(pPartFile);

			//	PartFiles are always shared files
				if (pPartFile->GetStatus(true) == PS_READY)
					m_pSharedFileList->SafeAddKnownFile(pPartFile);

				g_eMuleApp.m_pDownloadList->AddFile(pPartFile);

				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_RECOVERED_PARTMET), pPartFile->GetFileName());
			}
			else
			{
				delete pPartFile;
			}
		}
		ff.Close();
@


1.222
log
@Fractional upload/download limits (min 1 KB/s, granularity 0.1 KB/s).
@
text
@d160 7
a166 1
	bool	bRemove = false;
a167 7
//	If the default temp dir isn't in the alt temp dir list...
	if (m_pPrefs->m_tempDirList.Find(strTempDir) == NULL && m_pPrefs->m_tempDirList.Find(strTempDir + '\\') == NULL)
	{
	//	Add the default temp dir to the alt temp dir list
		m_pPrefs->m_tempDirList.AddHead(strTempDir);
		bRemove = true;
	}
d169 1
a169 1
	for (POSITION pos = m_pPrefs->m_tempDirList.GetHeadPosition(); pos != NULL; )
d172 1
a172 1
		CString			strTempDirPath(m_pPrefs->m_tempDirList.GetNext(pos).GetBuffer());
d175 1
a175 1
		strSearchPath += _T("\\*.part.met");
a250 3
//	If we added the default temp dir to the alt temp dir list, remove it now
	if (bRemove)
		m_pPrefs->m_tempDirList.RemoveHead();
@


1.221
log
@Customizable temporary directory for categories
@
text
@d484 1
a484 1
	uint16	iMaxDLSpeed = m_pPrefs->GetMaxDownload();
d486 1
a486 1
	if ((iMaxDLSpeed != UNLIMITED) && ((m_iDataRate > 1500) || (iMaxDLSpeed < 3)))
d488 1
a488 1
		uint32	iMaxDLSpeedBPS = iMaxDLSpeed * 1024;	// Bytes per second
d492 1
a492 1
		iDownSpeed = (iMaxDLSpeedBPS * 100) / (m_iDataRate + 1);
@


1.220
log
@Better low download rate control.
@
text
@d290 1
a290 1
	CPartFile	*pNewPartFile = new CPartFile(pNewSearchFile);
a296 1
	pNewPartFile->SetCatID(eCatID);
d343 1
a343 1
	CPartFile	*pNewPartFile = new CPartFile(pLink);
a351 1
		pNewPartFile->SetCatID(eCatID);
a432 2
	SetAutoCat(pNewPartFile);

@


1.219
log
@Fixed GUI update after file addition from WebServer/MobileMule {reported by Fuxie - DK};
Removed unused code.
@
text
@a488 1
	uint32	iMaxDLSpeedBPS = iMaxDLSpeed * 1024;	// Bytes per second
d490 1
a490 1
	if (iMaxDLSpeed != UNLIMITED && m_iDataRate > 1500 /*&& iMaxDLSpeedBPS>m_iDataRate*/)
d492 2
@


1.218
log
@removed double check of status for target file; small optimization
@
text
@d335 1
a335 17

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CDownloadQueue::AddSearchToDownload(CString strE2DKLink, EnumCategories eCatID /*=CAT_NONE*/, bool bPaused)
{
	EMULE_TRY

	CPartFile	* pNewPartFile = new CPartFile(strE2DKLink);

	if (pNewPartFile->GetStatus() == PS_ERROR)
	{
		delete pNewPartFile;
		return ;
	}
	pNewPartFile->SetCatID(eCatID);
	AddDownload(pNewPartFile, bPaused);
@


1.217
log
@corrected source swap by file deletion & fixed competion hang up
@
text
@d724 9
a744 9
//	If this part file is stopped or complete/completing or erroneous, no sources needed anymore
	EnumPartFileStatuses	eFileStatus = pSenderFile->GetStatus();

	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE
		|| eFileStatus == PS_COMPLETING || eFileStatus == PS_ERROR)
	{
		return NULL;
	}

a763 1
				//pTempSource->StartDLQueueWaitTimer();
d769 2
a770 7
		//	Attach the source only to incomplete files
			if (pSenderFile->GetStatus() != PS_COMPLETING
				&& pSenderFile->GetStatus() != PS_COMPLETE)
			{
				if (pTempSource->AddRequestForAnotherFile(pSenderFile))
					g_eMuleApp.m_pDownloadList->AddSource(pSenderFile,pTempSource,true);
			}
d835 2
a836 7
			//	Attach the source only to incomplete files
				if (pPartFile->GetStatus() != PS_COMPLETING
					&& pPartFile->GetStatus() != PS_COMPLETE)
				{
					if (pKnownSource->AddRequestForAnotherFile(pPartFile))
						g_eMuleApp.m_pDownloadList->AddSource(pPartFile,pKnownSource,false);
				}
@


1.216
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d770 3
a772 11
		//	Current requested file for that source is complete, try to swap
			if (pTempSource->m_pReqPartFile->GetStatus() == PS_COMPLETE)
			{
				AddDebugLogLine( _T("Client '%s' is attached to completed file %s, so we will swap it to file %s"),
								 pTempSource->GetUserName(),
								 pTempSource->m_pReqPartFile->GetFileName(),
								 pSenderFile->GetFileName() );
				pTempSource->SwapToAnotherFile(pSenderFile, true);
			}
		//	Requested for another (not complete) file
			else
d841 3
a843 11
			//	Current requested file for that source is complete, try to swap
				if (pKnownSource->m_pReqPartFile->GetStatus() == PS_COMPLETE)
				{
					AddDebugLogLine( _T("Client '%s' is attached to completed file %s, so we will swap it to file %s"),
									 pKnownSource->GetUserName(),
									 pKnownSource->m_pReqPartFile->GetFileName(),
									 pPartFile->GetFileName() );
					pKnownSource->SwapToAnotherFile(pPartFile, true);
				}
			//	Requested for another (not complete) file
				else
@


1.215
log
@Some changes for the Swap of sources attached to completed files.
@
text
@d764 1
a764 1
				pTempSource->StartQueueWaitTimer();
d799 1
a799 1
			pNewSource->StartQueueWaitTimer();
d872 1
a872 1
	pKnownSource->StartQueueWaitTimer();
@


1.214
log
@speed optimization of overhead calculation
@
text
@d777 1
a777 1
				pTempSource->SwapToAnotherFile(pSenderFile);
d856 1
a856 1
					pKnownSource->SwapToAnotherFile(pPartFile);
@


1.213
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d61 1
d130 3
a132 3
	m_averageDDROList.AddTail(m_nDownDataRateMSOverhead);
	if (m_averageDDROList.GetCount() > 150)
		m_averageDDROList.RemoveAt(m_averageDDROList.GetHeadPosition());
d134 1
a134 1
	m_nDownDataRateOverhead = 0;
d137 6
a142 2
	for (POSITION pos = m_averageDDROList.GetHeadPosition(); pos != NULL;)
		m_nDownDataRateOverhead += m_averageDDROList.GetNext(pos);
d144 3
a146 2
	if (m_averageDDROList.GetCount() > 10)
		m_nDownDataRateOverhead = 10 * m_nDownDataRateOverhead / m_averageDDROList.GetCount();
@


1.212
log
@Added active, paused and stopped files counters to download list header.
@
text
@d724 3
a726 3
			AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"),
							 		(byte)dwUserIP, (byte)(dwUserIP>>8), (byte)(dwUserIP>>16),
									(byte)(dwUserIP>>24), g_eMuleApp.m_pIPFilter->GetLastHit() );
d767 4
a770 4
				AddDebugLogLine( false, _T("Client '%s' is attached to completed file %s, so we will swap it to file %s"),
										pTempSource->GetUserName(),
										pTempSource->m_pReqPartFile->GetFileName(),
										pSenderFile->GetFileName() );
d846 4
a849 4
					AddDebugLogLine( false, _T("Client '%s' is attached to completed file %s, so we will swap it to file %s"),
											pKnownSource->GetUserName(),
											pKnownSource->m_pReqPartFile->GetFileName(),
											pPartFile->GetFileName() );
d1347 2
a1348 2
			AddDebugLogLine( false, RGB_LOG_NOTICE + "AutoSourcesPerFile: TMC=%u / Total=%u -> Changed from %u to %u (%+d)",
									cur_tmc, cur_stotal, old_mspf, new_mspf, new_mspf-old_mspf );
d1364 2
a1365 2
		AddDebugLogLine( false, RGB_LOG_NOTICE + "AutoSourcesPerFile: TMC=%u / Total=%u -> Not changed from %u",
								cur_tmc, cur_stotal, old_mspf );
d1527 1
a1527 1
	AddDebugLogLine(false, CString("%s: Resolving source hostname: %s"), __FUNCTION__, source->sourceHostname);
d1539 2
a1540 2
			AddDebugLogLine( false, RGB_LOG_ERROR + _T("%s: Error calling WSAAsyncGetHostByName to resolve source '%s'"),
									__FUNCTION__, hostsource->sourceHostname );
d1554 1
a1554 1
			AddDebugLogLine(false, CString("%s: Source resolve retry number %i"), __FUNCTION__, sourceHostnameResolveRetry);
d1572 1
a1572 1
		DEBUG_ONLY(AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Error resolving source '%s'"), __FUNCTION__, hostsource->sourceHostname));
d1588 7
a1594 7
	AddDebugLogLine( false, CString("%s: Resolved source hostname: %s - %i:%i:%i:%i"),
							__FUNCTION__,
							hostsource->sourceHostname,
							resolvedaddr.S_un.S_un_b.s_b1,
							resolvedaddr.S_un.S_un_b.s_b2,
							resolvedaddr.S_un.S_un_b.s_b3,
							resolvedaddr.S_un.S_un_b.s_b4 );
d1601 2
a1602 2
		DEBUG_ONLY(AddDebugLogLine( false, RGB_LOG_WARNING + _T("%s: impossible to add source because the partfile doesn't exist anymore")
											__FUNCTION__ ));
@


1.211
log
@updated code to follow meaning of the ContextMenu :
now even with Donwload paused option enabled using "download" and not "download (paused)" will start the download unpaused !
@
text
@d1419 24
@


1.210
log
@Added option "Resume from other category when all done".
@
text
@d94 1
a94 1
	
d364 1
a364 1
		AddDownload(pNewPartFile);
d397 1
a397 1
	
d404 1
a404 1
		if (CCat::FileBelongsToGivenCat(pTempPartFile, eCatID) && pTempPartFile->GetStatus() == PS_PAUSED) 
d438 2
a439 1
	if (g_eMuleApp.m_pGlobPrefs->StartDownloadPaused() || bPaused)
d573 1
a573 1
			
d592 1
a592 1
			
d821 1
a821 1
	
d964 1
a964 1
	
d1041 1
a1041 1
	
d1339 1
a1339 1
		
d1566 1
a1566 1
							hostsource->sourceHostname, 
@


1.209
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d414 1
a414 1
		if (pPartFile && pPartFile->GetStatus() == PS_PAUSED && (!bFoundInSameCat
@


1.208
log
@auto spf: check lower and upper limits for useful values and change if necessary
@
text
@d766 1
a766 2
				AddDebugLogLine( false, _T("%s: Source %s is attached to completed file %s, so we will swap it to file %s"),
										__FUNCTION__,
d845 1
a845 2
					AddDebugLogLine( false, _T("%s: Source %s is attached to completed file %s, so we will swap it to file %s"),
											__FUNCTION__,
d1346 2
a1347 2
			AddDebugLogLine( false, RGB_LOG_NOTICE + "%s: AutoSourcesPerFile TMC=%u / Total=%u -> Changed from %u to %u (%+d)",
									__FUNCTION__, cur_tmc, cur_stotal, old_mspf, new_mspf, new_mspf-old_mspf );
d1363 2
a1364 2
		AddDebugLogLine( false, RGB_LOG_NOTICE + "%s: AutoSourcesPerFile TMC=%u / Total=%u -> Not changed from %u",
								__FUNCTION__, cur_tmc, cur_stotal, old_mspf );
d1514 1
a1514 1
			AddDebugLogLine( false, RGB_LOG_ERROR + _T("%s: Error calling WSAAsyncGetHostByName to resolve source: %s"),
d1547 1
a1547 1
		DEBUG_ONLY(AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Error resolving source: %s"), __FUNCTION__, hostsource->sourceHostname));
@


1.207
log
@Reverted a log change...
@
text
@d1262 18
@


1.206
log
@Another check for adding sources for completed files (Thanks Syrus!)
@
text
@d723 2
a724 2
			AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Filtered (reject as new source): %i.%i.%i.%i %s"),
							 		__FUNCTION__, (byte)dwUserIP, (byte)(dwUserIP>>8), (byte)(dwUserIP>>16),
@


1.205
log
@DebugLog formating and changes
@
text
@d843 16
a858 2
				if (pKnownSource->AddRequestForAnotherFile(pPartFile))
					g_eMuleApp.m_pDownloadList->AddSource(pPartFile,pKnownSource,false);
@


1.204
log
@Formating and added a check for adding sources attached to completed files
@
text
@d723 3
a725 3
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"),
							(byte)dwUserIP,(byte)(dwUserIP>>8),(byte)(dwUserIP>>16),(byte)(dwUserIP>>24),
							g_eMuleApp.m_pIPFilter->GetLastHit());
d766 2
a767 1
				AddDebugLogLine( false, _T("Source %s is attached to completed file %s, so we will swap it to file %s"),
d1316 2
a1317 1
			AddDebugLogLine(false, RGB_LOG_NOTICE + "AutoSourcesPerFile TMC=%u / Total=%u -> Changed from %u to %u (%+d)",cur_tmc,cur_stotal,old_mspf,new_mspf,new_mspf-old_mspf);
d1333 2
a1334 1
		AddDebugLogLine(false, RGB_LOG_NOTICE + "AutoSourcesPerFile TMC=%u / Total=%u -> Not changed from %u",cur_tmc,cur_stotal,old_mspf);
d1472 1
a1472 1
	AddDebugLogLine(false, CString("Resolving source hostname: %s"), source->sourceHostname);
d1484 2
a1485 1
			AddDebugLogLine(false, RGB_LOG_ERROR + _T("Error calling WSAAsyncGetHostByName to resolve source: %s"), hostsource->sourceHostname);
d1499 1
a1499 1
			AddDebugLogLine(false, CString("Source resolve retry number %i"), sourceHostnameResolveRetry);
d1517 1
a1517 1
		DEBUG_ONLY(AddDebugLogLine(false, RGB_LOG_ERROR + _T("Error resolving source: %s"), hostsource->sourceHostname));
d1533 7
a1539 1
	AddDebugLogLine(false, CString("Resolved source hostname: %s - %i:%i:%i:%i"), hostsource->sourceHostname, resolvedaddr.S_un.S_un_b.s_b1, resolvedaddr.S_un.S_un_b.s_b2, resolvedaddr.S_un.S_un_b.s_b3, resolvedaddr.S_un.S_un_b.s_b4);
d1546 2
a1547 1
		DEBUG_ONLY(AddDebugLogLine(false, RGB_LOG_WARNING + _T("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
@


1.203
log
@minor changes, fixes and improvements
@
text
@a30 1
//	START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
a36 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a49 5
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d73 1
a73 1
//eklmn: it's need to initialize this variable to prevent extra screen refreshing during the start
d82 1
a91 1
		{
a92 1
		}
d103 1
a103 1
		return ;
d114 1
a114 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d135 2
a136 1
	for (POSITION pos = m_averageDDROList.GetHeadPosition(); pos != NULL; )
d151 1
a151 2
//	Find all part files, read & hash them if needed and store into a list
//	start changed by InterCeptor (multiple tempdirs) 19.11.02
d171 1
a171 1
	//
a172 1
	//
d189 2
a190 2
			//	Added by Tarod -check if is an A4AF auto file, correct place?
				if (md4cmp(pPartFile->GetFileHash(), g_eMuleApp.m_pGlobPrefs->GetA4AFHash()) == 0) // v1:- eklmn: A4AF mangement
d193 4
a196 1
				m_partFileList.AddTail(pPartFile); // to download queue
d198 1
a198 1
					m_pSharedFileList->SafeAddKnownFile(pPartFile); // part files are always shared files
d202 2
a203 1
				m_sourcesaver.LoadSources(pPartFile); // DonGato - Load SLS sources on loading
d225 2
a226 1
				pPartFile->SavePartFile(); // resave backup
d228 4
a231 1
				m_partFileList.AddTail(pPartFile);			// to download queue
d233 2
a234 1
					m_pSharedFileList->SafeAddKnownFile(pPartFile); // part files are always shared files
d246 1
a246 1
//	If we added the default temp dir to the alt temp dir list, remove it now.
d249 1
a249 1
//	End added by InterCeptor (multiple tempdirs) 19.11.02
d263 1
a263 1
//	START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
a266 1
//	END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d268 1
d372 2
a373 1
				pNewPartFile->AddClientSources(pLink->ClientSourcesList); //add all IP source and eliminates them from list
d380 2
a381 1
				pPartFile->AddClientSources(pLink->ClientSourcesList); //add all IP source and eliminates them from list
d418 1
a418 1
		//  and now it's same priority but next in file order (ie. 1/2/3 in a series) [DonGato]
d441 1
a441 1
		pNewPartFile->SetStartTimeReset(true);	//SyruS enable reset on resume
d452 2
a453 1
//	Purity - Sending message when download added
d498 1
a498 1
	uint32	iMaxDLSpeedBPS = iMaxDLSpeed * 1024;	//Bytes per second
d502 2
a503 2
	//	eklmn: don't remove upper DL limit, otherwise on DL will block all other
	//	Calculate what percentage of the max data rate the current data rate is.
a511 1
//
d514 1
a514 2
//	therefore I removed all the extra loops..
//
d539 1
a539 1
	if (m_averageTickList.empty() || dwCurTick - m_averageTickList.front() >= 500)	//Cax2 - update no faster than every .5 sec
d546 1
a546 1
	//	Cax2 save 40 secs of data. It seems to give the most accurate result atm...
d560 1
a560 6
	dwCurTick = ::GetTickCount();	//Cax2 - Refresh the variable

//
//	The code of sources refresh on local server move here in order prevent situation when client will be blacklisted
//	we create one 'packet' which contains the 15 buffered OP_GETSOURCES eD2K packets to be sent with one TCP frame every 300 sec
//
d562 3
d588 2
a589 3
			//	Create one 'packet' which contains all buffered OP_GETSOURCES eD2K packets to be sent with one TCP frame
			//	KuSh: in the official code bFromPF arg is set to false ? isn't this packet only sent for PartFile ?
			//
d600 1
a600 1
				//eklmn:  update a time only in  case if we sended something
a625 1
//--- i hope that is a safe point to save the stats ---
d640 1
a640 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d671 1
a671 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d707 1
a707 1
	//eklmn: prevent the loopback, i.e. all adresse 127.x.x.x
d711 1
a711 1
	//	check if source is our own client (now checking also TCP port)
d717 1
a717 1
	//eklmn: check if client has to be filtered, to prevent adding them to DL-queue over source exchange
d721 1
a721 1
		InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);	//g_eMuleApp.stat_filteredclients++;
d738 3
a740 8
	//eklmn: the checks below were removed, since at this point UserName & Hash are unknown
	// (filtering invalid eMule clients) ....
	// [Lord KiRon] v3: sometimes we can get ourself as a source, so let's check it

	// eklmn: now we need to check if client is already in the DL-queue
	// there is an alternative way to do it, which based on following ideas
	// 1) this function always will be(way) called after object creation (only IP & port are known)
	// 2) if client exist as source, he must be presented in ClientList
d743 1
a743 1

d746 1
a746 2

	//	eklmn: check UL only case, i.e. client exist only in UL-queue
d750 1
a750 1
		// 	add if OtherRequestList is empty, i.e. source was removed
d763 15
a777 2
			if (pTempSource->AddRequestForAnotherFile(pSenderFile))
				g_eMuleApp.m_pDownloadList->AddSource(pSenderFile,pTempSource,true);
d782 2
a783 1
	else		// client doesn't exist
d789 1
a789 1
			pNewSource->m_pReqPartFile = pSenderFile;		// fix for 'unknown' bug
d791 2
a792 2
			pSenderFile->RemovePastComment(pNewSource);		// #zegzav:pastcomment
			pNewSource->StartQueueWaitTimer(); 				//<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
d821 1
a821 1
	// If we receive ourselves (now checking IP and UDP port) as a source we drop it
d827 1
a827 1
	//eklmn: check a file in download list
d830 1
a830 1
		// if requested file already specified
d833 1
a833 1
			// check if it's a same file
d836 1
a836 1
				// if file was found, to speed up checks we gonna use variable pKnownSourceslot
a849 1
	//if (pKnownSource->GetFileRate()>0 ||pKnownSource->GetFileComment().GetLength()>0) pPartFile->UpdateFileRatingCommentAvail();
d851 2
a852 2
	pPartFile->RemovePastComment(pKnownSource);		// #zegzav:pastcomment
	pKnownSource->StartQueueWaitTimer(); //<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
d856 1
d862 1
a862 1
//eklmn: this function will remove  the source complete, from all files
a866 1
//	v-eklmn: bugfix(09): hang up by start if all files are paused
d869 1
a869 1
//	eklmn: set client state to DS_NONE in order to prevent any action from him
d872 1
a872 1
//eklmn: check actual requested file (we have this info in "m_pReqPartFile")
d874 1
d880 1
a880 1
			cur_file->AddPastComment(toremove);		// #zegzav:pastcomment
d883 2
a884 3
		} //if remove_pos
	//eklmn: update source info for the file
		cur_file->NewSrcPartsInfo();	// eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d887 1
a887 1
//eklmn: now remove client in A4AF files. let's use "OtherRequests_list" for this goal
d900 1
a900 1
//eklmn: clear client from all graphical lists
d984 1
a984 1
//	get server for request
d986 1
a986 1
//	check local server & try switch to another one
d991 4
a994 4
//	if we got NULL pointer back, that means
//	1) list is empty
//	2) we are in the end of the list
//	in both case we gonna stop UDP requests
d1001 1
a1001 1
//	check support of  extended request
d1010 1
a1010 1
//	eklmn: get position in the file list
d1014 3
a1016 3
//	check if file was found. this can happens in 2 cases
//	1) initial case. m_pLastUDPSearchedFile is not yet definded
//	2) if "m_pLastUDPSearchedFile" was deleted & m_partFileList.Find() return a 0.
d1020 1
a1020 1
//	at this point we have a start position to search in "posLastSearchedFile"
d1022 1
a1022 1
	int				iRequestedFiles = 0;
a1025 1
	//	get next file from the
d1040 1
a1040 1
		//	if packet is filled break the loop
d1044 1
a1044 1
		//	check for end of the loop & start from the head if it needs
d1080 1
a1080 1
	for (pos1 = m_partFileList.GetHeadPosition(); (pos2 = pos1) != NULL; )
d1096 1
d1112 1
a1112 1
	for (pos1 = m_partFileList.GetHeadPosition(); pos1 != NULL; )
d1115 1
d1120 1
a1120 1
				for (pos2 = pPartFile->m_srcLists[sl].GetHeadPosition(); pos2 != NULL; )
d1123 1
d1144 1
a1144 1
	for (pos1 = m_partFileList.GetHeadPosition(); pos1 != NULL; )
d1147 1
d1152 1
a1152 1
				for (pos2 = pPartFile->m_srcLists[sl].GetHeadPosition(); pos2 != NULL; )
d1155 1
d1168 1
a1168 1
//eklmn: by adding a new type don't forget to change constants in opcodes
d1239 1
a1239 1
	// count too many connections for all files
d1249 1
a1249 1
		// too many total sources, lower
d1261 1
a1261 1
		// too many connections, lower sources per file
d1267 1
a1267 1
		// not too many connections, raise sources per file depending on situation
d1298 1
a1298 1
	// stay between min_spf and max_spf
d1308 1
a1308 1
	// change values
d1312 1
d1317 2
a1318 1
		// change source excange limit according to sources per file
d1342 1
a1342 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d1345 1
d1352 1
d1354 1
d1356 1
d1367 1
a1367 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d1370 1
d1377 1
d1379 1
d1381 1
d1392 1
a1392 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
d1395 1
d1406 1
d1408 1
d1410 1
a1413 1
//	START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d1420 1
a1420 1
		return ;
d1424 1
a1424 2
		DEBUG_ONLY(AddLogLine(false, CString("void CDownloadQueue::AddClientHostnameToResolve(CPtrList* pLink): already resolving. Exiting.")));
		return ;
d1436 1
d1438 1
a1438 1
		{ //No more hostnames to resolve
d1441 2
a1442 1
				delete m_wndHSCallback; //free unneccessary window
d1448 1
d1450 1
d1469 1
a1469 1
	AddLogLine(false, CString("Resolving source hostname: %s"), source->sourceHostname);
d1481 1
a1481 1
			AddLogLine(false, RGB_LOG_ERROR + _T("Error calling WSAAsyncGetHostByName to resolve source "), hostsource->sourceHostname);
d1495 1
a1495 1
			AddLogLine(false, CString("Source resolve retry numer %i"), sourceHostnameResolveRetry);
d1513 1
a1513 1
		DEBUG_ONLY(AddLogLine(false, RGB_LOG_ERROR + _T("Error resolving source : %s"), hostsource->sourceHostname));
d1529 1
a1529 1
	AddLogLine(false, CString("Resolved source hostname: %s - %i:%i:%i:%i"), hostsource->sourceHostname, resolvedaddr.S_un.S_un_b.s_b1, resolvedaddr.S_un.S_un_b.s_b2, resolvedaddr.S_un.S_un_b.s_b3, resolvedaddr.S_un.S_un_b.s_b4);
d1536 1
a1536 1
		DEBUG_ONLY(AddLogLine(false, RGB_LOG_WARNING + _T("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
a1541 1
//	END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d1563 1
a1563 1
		uint32 dwNextUDPSearchTimeInSec = (m_dwLastUDPSearchTime + UDPSERVERREASKTIME - ::GetTickCount() )/1000;
d1580 1
d1597 1
a1597 1
//DonGato: fix because of list update in SetCatID :S
d1623 1
a1623 1
//DonGato: fix because of list update in SetCatID :S
d1709 1
a1709 1
		//	No need to compare agains an empty AutoCat array
d1723 1
a1723 2
				// HoaX_69: Allow wildcards in autocat string
				//  thanks to: bluecow, khaos and SlugFiller
@


1.202
log
@Start downloading paused file on complete: if no more paused file found in same category, start file of another category.
@
text
@a293 1
//	netwolf 20.05.03 enhanced source finding (bluecow)
a328 1
//	netwolf 15.05.03 enhanced source finding END
d732 1
a732 2
	//eklmn: if this part file is stopped or complete/completing no sources needed any more
	//MOREVIT - Finally. A comment that makes some sense!
d735 3
a737 1
	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING)
d739 1
d806 4
a809 2
	// SyruS "stop adding pKnownSources on stopped, completing and completed files" (Cax2 + SyruS check)
	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING)
d811 1
d1634 1
a1634 1
void CDownloadQueue::SetCatStatus(int iCatIndex, int newstatus)
@


1.201
log
@Added 'filesize on disk' info to details pane, file details, category tooltips and statistics
@
text
@d389 1
a389 1
//	StartNextFile() starts a paused download (takes in account priority)
d394 1
a394 1
	CPartFile	*pPartFile;
d397 2
d400 10
d414 2
a415 1
		if (pPartFile && pPartFile->GetStatus() == PS_PAUSED && CCat::FileBelongsToGivenCat(pPartFile, eCatID))
@


1.200
log
@minor changes (function renamings, unused typedef removal)
@
text
@d1198 1
@


1.199
log
@added 'Download (Paused)' to Searchlist context menu
@
text
@d714 1
a714 1
		if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
@


1.198
log
@Eliminated double .part.met backup & save on closure;
.part file flush is removed (if it is required, it will be made in destructor).
@
text
@d272 1
a272 1
void CDownloadQueue::AddSearchToDownload(CSearchFile *pNewSearchFile, EnumCategories eCatID /*=CAT_NONE*/)
d292 1
a292 1
	AddDownload(pNewPartFile);
d335 1
a335 1
void CDownloadQueue::AddSearchToDownload(CString strE2DKLink, EnumCategories eCatID /*=CAT_NONE*/)
d347 1
a347 1
	AddDownload(pNewPartFile);
d419 1
a419 1
void CDownloadQueue::AddDownload(CPartFile *pNewPartFile)
d425 1
a425 1
	if (g_eMuleApp.m_pGlobPrefs->StartDownloadPaused())
d431 1
a431 1
	SetAutoCat(pNewPartFile); // HoaX_69 / Slugfiller: AutoCat
@


1.197
log
@auto max sources per file
@
text
@a92 8
/*
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL; )
	{
		m_partFileList.GetAt(pos)->m_hPartFile.Flush() ; // Flush before close app [Tarod]
		m_partFileList.GetAt(pos)->SavePartFile();
		delete m_partFileList.GetNext(pos);
	}
*/
a98 2
			pPartFile->m_hPartFile.Flush() ; // Flush before close app [Tarod]
			pPartFile->SavePartFile();
a101 1

@


1.196
log
@KuSh changes puted back
@
text
@d1215 104
@


1.195
log
@Changes to Upload Log, enabled addsource for second client on same computer (different port) and other minor changes
@
text
@d572 2
d583 2
a584 4
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
					g_eMuleApp.m_pServerConnect->SendPacket(packet, true);
					//eklmn:  update a time only in  case if we sended something
					m_dwLastTCPSourcesRequestTime = ::GetTickCount();
d588 17
d622 1
d624 1
@


1.194
log
@KuSh chages for local source request over TCP temporary disabled
@
text
@d695 2
a696 2
	//	check if source is our own client
	if(dwUserIP == g_eMuleApp.m_pGlobPrefs->GetLancastIP())
d791 5
a795 3

	// eklmn: sometimes we can get ourself as a source, so let's check it [Lord KiRon] v3
	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), pKnownSource->GetUserHash()) == 0)
@


1.193
log
@fixed source check for lancast sources & memleak connected to it
@
text
@d571 2
a572 3
			CSafeMemFile		packetStream(22);

			for (int i = 0; i < 15 && !m_LocalServerSourcesReqQueue.IsEmpty(); i++)
d581 5
a585 2
					packetStream.Write(packet->GetPacket(), packet->GetRealPacketSize());
					delete packet;
a587 19

			int		iStreamSize = packetStream.GetLength();

		// eklmn: according to e2k protocol it is allow to send a packet if client connected to server
		// so we need to check connection state before send it
			if (iStreamSize > 0 && g_eMuleApp.m_pServerConnect->IsConnected())
			{
			//	Create one 'packet' which contains all buffered OP_GETSOURCES eD2K packets to be sent with one TCP frame
			//	KuSh: in the official code bFromPF arg is set to false ? isn't this packet only sent for PartFile ?
			//
				Packet		   *packet = new Packet(new char[iStreamSize], iStreamSize, true, false);

				packetStream.SeekToBegin();
				packetStream.Read(packet->GetPacket(), iStreamSize);
				g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
				g_eMuleApp.m_pServerConnect->SendPacket(packet, true);
				//eklmn:  update a time only in  case if we sended something
				m_dwLastTCPSourcesRequestTime = ::GetTickCount();
			}
d600 1
@


1.192
log
@list processing optimization
@
text
@d711 6
a776 7
	//	check if source is our own client
		if(pNewSource->GetIP() == g_eMuleApp.m_pGlobPrefs->GetLancastIP())
		{
			return NULL;
			safe_delete(pNewSource);
		}

@


1.191
log
@Improved string processing
@
text
@d665 1
a665 1
	CPartFile	*pPartFile = NULL;
d669 1
a669 1
	POSITION	pos1, pos2;
d671 1
a671 1
	for (pos1 = m_partFileList.GetHeadPosition(); (pos2 = pos1) != NULL; )
d673 1
a673 1
		CPartFile* pTempPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetNext(pos1));
d677 1
a677 1
			pPartFile = dynamic_cast<CPartFile*>(m_partFileList.GetAt(pos2));
a936 1
	POSITION pos;
d938 1
a938 1
	for (pos = m_partFileList.GetHeadPosition();pos != 0; )
d1064 3
a1066 2
	POSITION	pos1, pos2;
	uint32		i = 0;
d1068 1
a1068 1
	for (pos1 = m_partFileList.GetHeadPosition(); (pos2 = pos1) != NULL;)
d1070 1
a1070 1
		CPartFile		*pPartFile = m_partFileList.GetNext(pos1);
d1095 3
a1097 3
	POSITION pos, pos1;
	CUpDownClient* pSource;
	CPartFile* pPartFile;
d1099 1
a1099 1
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; )
d1101 1
a1101 1
		pPartFile = m_partFileList.GetNext(pos);
d1106 1
a1106 1
				for (pos1 = pPartFile->m_srcLists[sl].GetHeadPosition(); pos1 != NULL; )
d1108 1
a1108 1
					pSource = pPartFile->m_srcLists[sl].GetNext(pos1);
d1125 3
a1127 2
	CPartFile * pPartFile;
	POSITION pos, pos2;
d1129 1
a1129 1
	for (pos = m_partFileList.GetHeadPosition(); pos != 0;)
d1131 1
a1131 1
		pPartFile = m_partFileList.GetNext(pos);
d1136 1
a1136 1
				for (pos2 = pPartFile->m_srcLists[sl].GetHeadPosition(); pos2 != 0;)
d1138 1
a1138 1
					CUpDownClient* pSource = pPartFile->m_srcLists[sl].GetNext(pos2);
d1159 3
a1161 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; )
d1163 1
a1163 1
		CPartFile * pPartFile = m_partFileList.GetNext(pos);
d1214 5
a1218 2
	int iCount = 0;
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; )
d1220 1
a1220 1
		CPartFile * pPartFile = m_partFileList.GetNext(pos);
d1235 5
a1239 2
	int iCount = 0;
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;)
d1241 1
a1241 1
		CPartFile* pPartFile = m_partFileList.GetNext(pos);
d1256 5
a1260 2
	int iCount = 0;
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;)
d1262 1
a1262 1
		CPartFile				*pPartFile = m_partFileList.GetNext(pos);
d1462 4
a1465 2
	POSITION pos;
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; )
d1467 1
a1467 1
		CPartFile* pPartFile = m_partFileList.GetNext(pos);
d1474 1
a1474 1
	for (pos = locallist.GetHeadPosition(); pos != 0; )
d1476 1
a1476 1
		CPartFile	*cur_file = locallist.GetNext(pos);
d1478 2
a1479 2
		if (CCat::GetCatIndexByID(cur_file->GetCatID()) == iCatIndex)
			cur_file->SetCatID(CAT_NONE);
d1488 3
a1490 1
	POSITION pos;
d1493 1
a1493 1
		CPartFile* pPartFile = m_partFileList.GetNext(pos);
d1502 1
a1502 1
		CPartFile	*cur_file = locallist.GetNext(pos);
d1504 1
a1504 1
		if (iCatIndex == 0 || CCat::GetCatIndexByID(cur_file->GetCatID()) == iCatIndex)
d1508 2
a1509 2
				cur_file->SetAutoPriority(true);
				cur_file->UpdateDownloadAutoPriority();
d1513 2
a1514 2
				cur_file->SetAutoPriority(false);
				cur_file->SetPriority(newprio);
@


1.190
log
@pointer check
@
text
@d1571 1
a1571 1
				if (cmpExt.Find(CString("*")) != -1 || cmpExt.Find(CString("?")) != -1)
@


1.189
log
@General improvements; style corrections.
@
text
@d93 1
d100 14
d135 1
a135 1
		CPartFile	* pPartFile = m_partFileList.GetNext(pos);
d137 1
a137 1
		if (pPartFile->GetStatus(true) == PS_READY)
d409 1
a409 1
	for (pos = m_partFileList.GetHeadPosition(); pos != (POSITION)NULL; )
d411 1
a411 1
		pPartFile = static_cast<CPartFile*>(m_partFileList.GetNext(pos));
d413 1
a413 1
		if (pPartFile->GetStatus() == PS_PAUSED && CCat::FileBelongsToGivenCat(pPartFile, eCatID))
d520 1
a520 2
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);
		EnumPartFileStatuses	eFileStatus = pPartFile->GetStatus();
d522 1
a522 1
		if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
d524 6
a529 1
			iTempDataRate += pPartFile->Process(iDownSpeed, m_iUDCounter /*iteration*/);
d642 1
a642 1
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);
d644 4
a647 1
		pPartFile->SavePartFileStats();
d673 3
a675 1
		if (!md4cmp(strFileHash, m_partFileList.GetNext(pos1)->GetFileHash()))
d677 1
a677 1
			pPartFile = m_partFileList.GetAt(pos2);
d920 1
a920 2
		CPartFile * cur_file = m_partFileList.GetNext(pos);
		EnumPartFileStatuses	eFileStatus = cur_file->GetStatus();
d922 1
a922 1
		if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
d924 6
a929 1
			cur_file->ResumeFile();
d938 1
d941 13
a953 8
		CPartFile * cur_file = m_partFileList.GetNext(pos);
		for (int sl = 0;sl < SOURCESSLOTS;sl++)
			if (!cur_file->m_srcLists[sl].IsEmpty())
				cur_file->m_srcLists[sl].RemoveAll();
	//	Barry - Should also remove all requested blocks
	//	Don't worry about deleting the blocks, that gets handled
	//	when CUpDownClient is deleted in CClientList::DeleteAll()
		cur_file->RemoveAllRequestedBlocks();
d1016 2
a1017 4
		EnumPartFileStatuses	eFileStatus = pNextPartFile->GetStatus();

		if (((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
			&& g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileUDP() > pNextPartFile->GetSourceCount())
d1019 1
a1019 4
			dataGlobGetSources.Write(pNextPartFile->GetFileHash(), 16);
			m_pLastUDPSearchedFile = pNextPartFile;
			iRequestedFiles++;
		}
d1021 7
a1027 3
	//	if packet is filled break the loop
		if (iRequestedFiles >= iMaxFilesPerPacket)
			break;
d1029 8
a1036 3
	//	check for end of the loop & start from the head if it needs
		if (posLastSearchedFile == NULL)
			posLastSearchedFile = m_partFileList.GetHeadPosition();
d1070 1
a1070 1
		CPartFile		*cur_file = m_partFileList.GetNext(pos1);
d1072 1
a1072 1
		if (cur_file->GetPriority() == PR_HIGH)
d1074 12
a1085 2
			m_partFileList.AddHead(cur_file);
			m_partFileList.RemoveAt(pos2);
a1086 7
		else if (cur_file->GetPriority() == PR_LOW)
		{
			m_partFileList.AddTail(cur_file);
			m_partFileList.RemoveAt(pos2);
		}
		if (++i == m_partFileList.GetCount())
			break;
d1096 2
a1097 2
	CUpDownClient* cur_src;
	CPartFile* cur_file;
d1101 4
a1104 3
		cur_file = m_partFileList.GetNext(pos);
		for (int sl = 0; sl < SOURCESSLOTS; sl++)
			for (pos1 = cur_file->m_srcLists[sl].GetHeadPosition(); pos1 != NULL; )
d1106 1
a1106 3
				cur_src = cur_file->m_srcLists[sl].GetNext(pos1);

				if (dwIP == cur_src->GetIP())
d1108 5
a1112 1
					return cur_src;
d1115 1
d1125 2
a1126 1
	CPartFile * cur_file;
d1128 1
a1128 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0;)
d1130 4
a1133 3
		cur_file = m_partFileList.GetNext(pos);
		for (int sl = 0; sl < SOURCESSLOTS; sl++)
			for (POSITION pos2 = cur_file->m_srcLists[sl].GetHeadPosition(); pos2 != 0;)
d1135 1
a1135 2
				CUpDownClient* cur_client = cur_file->m_srcLists[sl].GetNext(pos2);
				if (dwIP == cur_client->GetIP() && nUDPPort == cur_client->GetUDPPort())
d1137 5
a1141 1
					return cur_client;
d1144 1
d1160 43
a1202 40
		CPartFile * cur_file = m_partFileList.GetNext(pos);
		sources[0] += cur_file->GetSourceCount();
		sources[1] += cur_file->GetTransferringSrcCount();
	//	Extra stats
		sources[2] += cur_file->GetOnQueueSrcCount();
		sources[3] += cur_file->GetQueueFullSrcCount();
		sources[4] += cur_file->GetNoNeededPartsSrcCount();
		sources[5] += cur_file->GetConnectedSrcCount();
		sources[6] += cur_file->GetRecHashsetSrcCount();
		sources[7] += cur_file->GetConnectingSrcCount();
		sources[8] += cur_file->GetConnectingViaServerSrcCount();
		sources[9] += cur_file->GetTooManyConnsSrcCount();
		sources[10] += cur_file->GetLow2LowSrcCount();
		sources[11] += cur_file->GetUnknownSrcCount();
		sources[12] += cur_file->GetErrorSrcCount();
		sources[13] += cur_file->GetBannedSrcCount();
		sources[14] += cur_file->TotalPacketsSavedDueToICH();
		sources[15] += cur_file->GetSrcA4AFCount();
		sources[16] += cur_file->GetTimeoutedSrcCount();
		sources[17] += cur_file->GetHighQRSrcCount();
		sources[18] += cur_file->GetNoUploadSrcCount();
	//	Some data
		data[0] += cur_file->GetSessionLostDueToCorruption();
		data[1] += cur_file->GetSessionGainDueToCompression();

		uint32 dwSizeToTransfer = 0;
		uint32 dwNeededSpace = (cur_file->GetFileSize() - cur_file->GetRealFileSize());
		EnumPartFileStatuses	eFileStatus = cur_file->GetStatus();

		cur_file->GetSizeToTransfer(dwSizeToTransfer);
		if ((eFileStatus ==  PS_READY) || (eFileStatus == PS_EMPTY))
		{
			data[2] += cur_file->GetFileSize();
			data[3] += dwSizeToTransfer;
			data[4] += dwNeededSpace;
		}
		data[5] += cur_file->GetFileSize();
		data[6] += dwNeededSpace;
		data[7] += cur_file->GetLostDueToCorruption();
		data[8] += cur_file->GetGainDueToCompression();
d1214 6
a1219 3
		CPartFile * cur_file = m_partFileList.GetNext(pos);
		if (cur_file->GetTransferringSrcCount() > 0)
			iCount++;
d1232 6
a1237 3
		CPartFile* cur_file = m_partFileList.GetNext(pos);
		if (cur_file->GetStatus() == PS_PAUSED)
			iCount++;
d1250 4
a1253 2
		CPartFile				*cur_file = m_partFileList.GetNext(pos);
		EnumPartFileStatuses	eFileStatus = cur_file->GetStatus();
d1255 4
a1258 3
		if ((eFileStatus == PS_READY) || (eFileStatus == PS_EMPTY))
		{
			iCount++;
d1452 7
a1458 1
		locallist.AddTail(m_partFileList.GetNext(pos));
d1476 7
a1482 1
		locallist.AddTail(m_partFileList.GetNext(pos));
@


1.188
log
@list processing optimization
@
text
@d118 1
a118 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0; )
d139 1
a139 1
	for (POSITION pos = m_averageDDROList.GetHeadPosition(); pos != 0; )
d168 1
a168 1
	for (POSITION pos = m_pPrefs->m_tempDirList.GetHeadPosition(); pos != 0; )
d503 1
a503 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; )
d506 1
d508 1
a508 1
		if (pPartFile->GetStatus() == PS_READY || pPartFile->GetStatus() == PS_EMPTY)
d516 1
a516 1
	DWORD	dwCurTick = GetTickCount();
d621 1
a621 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; )
d636 1
a636 4
	if (pos != NULL)
		return m_partFileList.GetAt(pos);
	else
		return NULL;
d671 1
a671 1
	if (pos)
d701 3
a703 3
	if ( pSenderFile->GetStatus() == PS_STOPPED
		|| pSenderFile->GetStatus() == PS_COMPLETE
		|| pSenderFile->GetStatus() == PS_COMPLETING )
d776 2
d779 1
a779 3
	if (pPartFile->GetStatus() == PS_STOPPED
		|| pPartFile->GetStatus() == PS_COMPLETE
		|| pPartFile->GetStatus() == PS_COMPLETING)
d786 1
a786 1
   	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), pKnownSource->GetUserHash()) == 0)
d851 1
a851 1
	if (!toremove->m_otherRequestsList.IsEmpty())
d853 2
a854 1
		for (POSITION pos = toremove->m_otherRequestsList.GetHeadPosition();pos != 0; )
d856 2
a857 2
			cur_file = toremove->m_otherRequestsList.GetNext(pos);
			if (IsInDLQueue(cur_file))
d859 1
a859 5
				POSITION pos_A4AF = cur_file->m_A4AFsrcList.Find(toremove);
				if (pos_A4AF)
				{
					cur_file->m_A4AFsrcList.RemoveAt(pos_A4AF);
				}
d897 3
a899 1
		if (cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) //netwolf
d982 1
d984 1
a984 1
		if ((pNextPartFile->GetStatus() == PS_READY || pNextPartFile->GetStatus() == PS_EMPTY)
d1028 1
a1028 1
	uint16		i = 0;
d1044 1
a1044 2
		i++;
		if (i == m_partFileList.GetCount())
d1058 1
a1058 1
	for (pos = m_partFileList.GetHeadPosition();pos != 0; )
d1061 6
a1066 3
		for (int sl = 0;sl < SOURCESSLOTS;sl++)
			if (!cur_file->m_srcLists[sl].IsEmpty())
				for (pos1 = cur_file->m_srcLists[sl].GetHeadPosition(); pos1 != NULL; )
d1068 1
a1068 6
					cur_src = cur_file->m_srcLists[sl].GetNext(pos1);

					if (dwIP == cur_src->GetIP())
					{
						return cur_src;
					}
d1070 1
d1082 1
a1082 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;)
d1085 2
a1086 2
		for (int sl = 0;sl < SOURCESSLOTS;sl++)
			if (!cur_file->m_srcLists[sl].IsEmpty())
d1088 2
a1089 1
				for (POSITION pos2 = cur_file->m_srcLists[sl].GetHeadPosition();pos2 != 0;)
d1091 1
a1091 5
					CUpDownClient* cur_client = cur_file->m_srcLists[sl].GetNext(pos2);
					if (dwIP == cur_client->GetIP() && nUDPPort == cur_client->GetUDPPort())
					{
						return cur_client;
					}
d1104 2
a1105 4
	for (int i = 0;i < STATS_DL_SOURCES_TYPE;i++)
		sources[i] = 0;
	for (int i = 0;i < STATS_DL_DATA_INFO;i++)
		data[i] = 0;
d1107 1
a1107 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0; )
d1112 1
a1112 1
	//extra stats
d1130 1
a1130 1
	//	some data
d1133 1
d1135 3
a1137 1
		uint32 dwNeededSpace = (cur_file->GetFileSize()-cur_file->GetRealFileSize());
d1139 1
a1139 1
		if (cur_file->GetStatus() ==  PS_READY || cur_file->GetStatus() == PS_EMPTY)
d1190 4
a1193 2
		CPartFile* cur_file = m_partFileList.GetNext(pos);
		if (cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY)
d1225 1
a1225 1
	while (1)
d1343 2
a1344 1
	CString sOut = _T("");
d1347 1
a1347 1
		sOut = GetResString(IDS_UDPSEARCH_PROGRESS);
d1352 1
a1352 1
		sOut.Format( GetResString(IDS_UDPSEARCH_NEXT), CastSecondsToHM(dwNextUDPSearchTimeInSec));
d1355 1
a1355 1
		sOut = GetResString(IDS_UDPSEARCH_NOTSTART);
d1357 1
a1357 1
	return sOut;
d1406 1
a1406 1
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; )
d1409 1
a1409 1
	for (pos = locallist.GetHeadPosition(); pos != 0; )
d1432 1
d1434 1
a1434 2
	POSITION pos = m_partFileList.GetHeadPosition();
	while (pos != 0)
a1479 2
			catExt.MakeLower();

d1484 2
a1522 1

@


1.187
log
@minor fix for KuSh changes
@
text
@d93 1
a93 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0; )
d635 1
a635 1
	if (pos)
d651 1
a651 1
	for (pos1 = m_partFileList.GetHeadPosition(); (pos2 = pos1) != 0; )
d695 1
a695 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"), 
@


1.186
log
@added Active Downloads to stats + some other changes
@
text
@d567 1
a567 1
			int					iStreamSize = packetStream.GetLength();
d569 2
a570 3
		//	The connection state is checked before sending the packet to keep refreshing going
		//  if client was disconnected. Such a approach will prevent a situation when we after reconnection
		//  gonna ask for source again
d582 2
a584 1
			m_dwLastTCPSourcesRequestTime = ::GetTickCount();
@


1.185
log
@extended filtered stats
@
text
@a60 1
	m_iNumFilesReady = 0;
d1160 1
a1160 1
int CDownloadQueue::GetTransferringFiles()
d1175 1
a1175 1
int CDownloadQueue::GetPausedFileCount()
d1190 17
@


1.184
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d693 2
d696 3
a698 2
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"), (byte)dwUserIP,(byte)(dwUserIP>>8),(byte)(dwUserIP>>16),(byte)(dwUserIP>>24),
			g_eMuleApp.m_pIPFilter->GetLastHit());
@


1.183
log
@Optimized hash processings
@
text
@d694 1
a694 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"), (uint8)dwUserIP,(uint8)(dwUserIP>>8),(uint8)(dwUserIP>>16),(uint8)(dwUserIP>>24),
d1384 1
a1384 1
void CDownloadQueue::SetCatPrio(int iCatIndex, uint8 newprio)
@


1.182
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d1347 1
a1347 1
void CDownloadQueue::SetA4AFAutoFile(CPartFile* file)
d1358 2
a1359 1
		memzero(null_hash, sizeof(null_hash));
@


1.181
log
@sources request are sent in one tcp frame + remove uneeded text in ipfilter
@
text
@d1232 1
a1232 1
	memset2(hostentBuffer, 0, sizeof(hostentBuffer));
d1260 1
a1260 1
			memset2(hostentBuffer, 0, sizeof(hostentBuffer));
d1266 1
a1266 1
			memset2(hostentBuffer, 0, sizeof(hostentBuffer));
d1289 1
a1289 1
		memset2(hostentBuffer, 0, sizeof(hostentBuffer));
d1311 1
a1311 1
	memset2(hostentBuffer, 0, sizeof(hostentBuffer));
d1358 1
a1358 1
		memset2(null_hash, 0, sizeof(null_hash));
@


1.180
log
@formating
@
text
@d543 2
a544 4
//	The code of source refresh sources on local server move here in order prevent situation when client will be blacklisted
//	from now(26.10.2003) we gonna request a 15 source after 300 sec
//	note: official client creates one packet which contains all buffered OP_GETSOURCES eD2K packets to be sent with one TCP frame
//	      could be great to do the same...
d552 2
d556 1
a556 1
				CPartFile		*pPartFile = m_LocalServerSourcesReqQueue.RemoveHead();
d558 1
a558 4
			//	The connection state must be checked inside the loop to keep refreshing going
			//  if client was disconnected. Such a approach will prevent a situation when we after reconnection
			//  gonna ask for source again
				if (pPartFile != NULL)
d560 1
a560 1
					Packet		*packet = new Packet(OP_GETSOURCES, 16);
d563 2
a564 2
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
					g_eMuleApp.m_pServerConnect->SendPacket(packet, true);
d567 18
@


1.179
log
@stopped and paused files are not considered as partfile for upload auto priorities + some changes to avoid a bug with PR_AUTO in my last changes + minor changes about priorities
@
text
@d924 1
a924 1
	//get server for request
d926 1
a926 1
	//check local server & try switch to another one
d931 5
a935 5
	// if we got NULL pointer back, that means
	// 1) list is empty
	// 2) we are in the end of the list
	// in both case we gonna stop UDP requests
	if (!pCurUDPServer)
d941 2
a942 2
	//check support of  extended request
	int iMaxFilesPerPacket = 1;
d947 2
a948 2
	CSafeMemFile dataGlobGetSources(16);
	POSITION	posLastSearchedFile = NULL;
d950 2
a951 2
	//eklmn: get position in the file list
	if (m_pLastUDPSearchedFile)
d954 4
a957 4
	//check if file was found. this can happens in 2 cases
	// 1) initial case. m_pLastUDPSearchedFile is not yet definded
	// 2) if "m_pLastUDPSearchedFile" was deleted & m_partFileList.Find() return a 0.
	if (!posLastSearchedFile)
d960 3
a962 3
	// at this point we have a start posion to search in "posLastSearchedFile"
	// so we can create a packet
	int iRequestedFiles = 0;
d966 3
a968 2
		// get next file from the
		CPartFile* pNextPartFile = m_partFileList.GetNext(posLastSearchedFile);
d977 1
a977 1
		// if packet is filled break the loop
d981 2
a982 2
		//check for end of the loop & start from the head if it needs
		if (!posLastSearchedFile)
d986 2
a987 1
	Packet packet(&dataGlobGetSources);
@


1.178
log
@reverted a change, sorting is not needed when deleting a file ...
@
text
@d1384 1
a1384 1
				cur_file->SetPriority(PR_HIGH);
@


1.177
log
@optimisation of the file processing + some formatting, comments and deletions of spaces and tabs at end of lines
@
text
@a876 2
	SortByPriority();

@


1.176
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d497 2
a502 4
	POSITION pos;
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; )
	{
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);
d504 1
a504 19
	//	If the part file is waiting and has a High or Auto priority...
		if ( (pPartFile->GetStatus() == PS_READY || pPartFile->GetStatus() == PS_EMPTY)
		     && (pPartFile->GetPriority() == PR_HIGH || pPartFile->GetPriority() == PR_AUTO) )	//jicxicmic fix
		{
			iTempDataRate += pPartFile->Process(iDownSpeed, m_iUDCounter /*iteration*/);
		}
	}
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; )
	{
		CPartFile	*pPartFile = m_partFileList.GetNext(pos);

	//	If the part file is waiting and has a Normal priority...
		if ( (pPartFile->GetStatus() == PS_READY || pPartFile->GetStatus() == PS_EMPTY)
		     && pPartFile->GetPriority() == PR_NORMAL )
		{
			iTempDataRate += pPartFile->Process(iDownSpeed, m_iUDCounter /*iteration*/);
		}
	}
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; )
d508 1
a508 3
	//	If the part file is waiting and has a Low priority...
		if ( (pPartFile->GetStatus() == PS_READY || pPartFile->GetStatus() == PS_EMPTY)
		     && pPartFile->GetPriority() == PR_LOW )
d542 7
a548 2
	//eklmn: The code of source refresh sources on local server move here in order prevent situation when client will be blacklisted
	// from now(26.10.2003) we gonna request a 15 source after 300 sec
d558 1
a558 1
			//	The connection state must be checked inside the loop to keep refreshing going 
d874 1
a874 1
	if (remove_pos)
d877 2
@


1.175
log
@added category name to log, popup and email notifier (when a download is added or finished) [FR 359]
@
text
@d566 1
a566 1
#ifdef OLD_SOCKETS_ENABLED			
d576 1
a576 1
			//  if client was disconnected. Such a approach will prevent a situation when we after reconnection 
d590 1
a590 1
#endif //OLD_SOCKETS_ENABLED				
d693 1
a693 1
	if (g_eMuleApp.m_pIPFilter->IsFiltered(dwUserIP)) 
d710 1
a710 1
	// [Lord KiRon] v3: sometimes we can get ourself as a source, so let's check it  
d777 1
a777 1
	
d781 1
a781 1
		|| pPartFile->GetStatus() == PS_COMPLETING) 
d783 1
a783 1
	
d786 4
a789 4
	
	// eklmn: sometimes we can get ourself as a source, so let's check it [Lord KiRon] v3 
   	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), pKnownSource->GetUserHash()) == 0) 
		return FALSE; 
d798 1
a798 1
			if (pPartFile == pKnownSource->m_pReqPartFile) 
d801 1
a801 1
				if (pPartFile->m_srcLists[pKnownSource->m_iSourcesSlot].Find(pKnownSource)) 
d935 1
a935 1
	
d960 1
a960 1
	
d983 1
a983 1
		// get next file from the 
d996 1
a996 1
	
d1016 1
a1016 1
		
d1019 1
a1019 1
	
d1430 1
a1430 1
				case MP_CANCEL:	
d1434 1
a1434 1
				case MP_PAUSE:	
d1437 1
a1437 1
				case MP_STOP:	
d1440 1
a1440 1
				case MP_RESUME: 
d1459 1
a1459 1
		{	
@


1.174
log
@fix for space needed... values
@
text
@d431 5
a435 1
	AddLogLine(true, IDS_NEWDOWNLOAD, pNewPartFile->GetFileName());
d439 1
a439 1
	strMessageText.Format(GetResString(IDS_NEWDOWNLOAD), pNewPartFile->GetFileName());
@


1.173
log
@Formatting, comments, and name changes.
@
text
@d1139 1
a1139 1
		if (cur_file->GetPartfileStatus() ==  PS_READY || cur_file->GetPartfileStatus() == PS_EMPTY)
@


1.172
log
@some minor changes and optimizations
@
text
@d649 1
@


1.171
log
@strangest thing Ive ever seen :P
@
text
@d648 2
a649 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d651 1
a651 1
		if (!md4cmp(strFileHash, m_partFileList.GetAt(pos)->GetFileHash()))
d653 1
a653 1
			pPartFile = m_partFileList.GetAt(pos);
@


1.170
log
@Formatting, comments, and name changes.
@
text
@d1137 1
a1137 1
		if (cur_file->GetPartfileStatus() != GetResString(IDS_PAUSED) && cur_file->GetPartfileStatus() != GetResString(IDS_STOPPED))
@


1.169
log
@Minor changes on PartFile
Fix for eMuleLight template ed2k box
Fix for CDownloadQueue::GetFileByID (wrong optmized code)
@
text
@d567 1
a567 2
			int i = 0;
			while (i<15 && !m_LocalServerSourcesReqQueue.IsEmpty())
d569 6
a574 5
				CPartFile* pPartFile = m_LocalServerSourcesReqQueue.RemoveHead();
				//eklmn: the connection state must be checked inside the loop to keep refreshing going 
				//  if client was disconnected. Such a approach will prevent a situation when we after reconnection 
				//  gonna ask for source again
				if (pPartFile)
d576 1
a576 1
					Packet *packet = new Packet(OP_GETSOURCES, 16);
a581 1
				i++;
@


1.168
log
@only removed doubled semicolons
@
text
@d649 1
a649 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; )
d651 3
a653 2
		pPartFile = m_partFileList.GetNext(pos);
		if (!md4cmp(strFileHash, pPartFile->GetFileHash()))
d655 1
@


1.167
log
@*** empty log message ***
@
text
@d1025 1
a1025 1
		CPartFile		*cur_file = m_partFileList.GetNext(pos1);;
d1412 1
a1412 1
		CPartFile * cur_file = m_partFileList.GetNext(pos);;
@


1.166
log
@some minor optimizations and changes
@
text
@d652 1
a652 1
		if (!md4cmp(strFileHash, pPartfile->GetFileHash()))
@


1.165
log
@Reverted a change not meant for RC3
@
text
@d94 1
a94 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos))
d98 1
a98 1
		delete m_partFileList.GetAt(pos);
d119 1
a119 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos))
d121 1
a121 1
		CPartFile	* pPartFile = m_partFileList.GetAt(pos);
d140 2
a141 2
	for (POSITION pos = m_averageDDROList.GetHeadPosition(); pos != 0; m_averageDDROList.GetNext(pos))
		m_nDownDataRateOverhead += m_averageDDROList.GetAt(pos);
d169 1
a169 1
	for (POSITION pos = m_pPrefs->m_tempDirList.GetHeadPosition(); pos != 0; m_pPrefs->m_tempDirList.GetNext(pos))
d172 2
a173 1
		CString			strSearchPath(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer());
d175 1
a175 1
		strSearchPath += "\\*.part.met";
d192 1
a192 1
			if (pPartFile->LoadPartFile(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer(), ff.GetFileName().GetBuffer()))
d225 1
a225 1
			if (pPartFile->LoadPartFile(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer(), ff.GetFileName().GetBuffer()))
d395 1
a395 1
	for (pos = m_partFileList.GetHeadPosition(); pos != (POSITION)NULL; m_partFileList.GetNext(pos))
d397 1
a397 1
		pPartFile = static_cast<CPartFile*>(m_partFileList.GetAt(pos));
d497 2
a498 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d500 1
a500 1
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);
d509 1
a509 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d511 1
a511 1
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);
d520 1
a520 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d522 1
a522 1
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);
d620 1
a620 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d622 1
a622 1
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);
d649 1
a649 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d651 2
a652 3
		if (!md4cmp(strFileHash, m_partFileList.GetAt(pos)->GetFileHash()))
		{
			pPartFile = m_partFileList.GetAt(pos);
a653 1
		}
d848 1
a848 1
		for (POSITION pos = toremove->m_otherRequestsList.GetHeadPosition();pos != 0; toremove->m_otherRequestsList.GetNext(pos))
d850 1
a850 1
			cur_file = toremove->m_otherRequestsList.GetAt(pos);
d892 1
a892 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;m_partFileList.GetNext(pos))
d894 1
a894 1
		CPartFile * cur_file = m_partFileList.GetAt(pos);
d906 1
a906 1
	for (pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos))
d908 1
a908 1
		CPartFile * cur_file = m_partFileList.GetAt(pos);
d1025 1
a1025 3
		m_partFileList.GetNext(pos1);

		CPartFile		*cur_file = m_partFileList.GetAt(pos2);
d1048 1
a1048 1
	POSITION pos, pos1, pos2;
d1052 1
a1052 1
	for (pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos))
d1054 1
a1054 1
		cur_file = m_partFileList.GetAt(pos);
d1057 1
a1057 1
				for (pos1 = cur_file->m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d1059 1
a1059 2
					cur_file->m_srcLists[sl].GetNext(pos1);
					cur_src = cur_file->m_srcLists[sl].GetAt(pos2);
d1107 1
a1107 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0; m_partFileList.GetNext(pos))
d1109 1
a1109 1
		CPartFile * cur_file = m_partFileList.GetAt(pos);
d1155 1
a1155 1
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d1157 1
a1157 1
		CPartFile * cur_file = m_partFileList.GetAt(pos);
d1363 3
a1365 2
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
		locallist.AddTail(m_partFileList.GetAt(pos));
d1367 1
a1367 1
	for (POSITION pos = locallist.GetHeadPosition(); pos != 0; locallist.GetNext(pos))
d1369 1
a1369 1
		CPartFile	*cur_file = locallist.GetAt(pos);
d1381 3
a1383 2
	for (POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
		locallist.AddTail(m_partFileList.GetAt(pos));
d1385 1
a1385 1
	for (POSITION pos = locallist.GetHeadPosition(); pos != 0; locallist.GetNext(pos))
d1387 1
a1387 1
		CPartFile	*cur_file = locallist.GetAt(pos);
d1412 1
a1412 1
		CPartFile * cur_file = m_partFileList.GetAt(pos);
a1438 1
		m_partFileList.GetNext(pos);
@


1.164
log
@Reverted completion 'fix' by eklmn so we can release 1j this month
@
text
@a714 4
	//	check if source is our own client
		if(pTempSource->GetIP() == g_eMuleApp.m_pGlobPrefs->GetLancastIP())
			return NULL;
	
a779 4
	// check if source is our own client
	if(pKnownSource->GetIP() == g_eMuleApp.m_pGlobPrefs->GetLancastIP())
		return NULL;

@


1.163
log
@do not log "filtered"-messages if "do not log coutermeasures" is enabled
@
text
@d711 1
d714 5
d745 8
a752 1
		
d784 4
d1509 1
@


1.162
log
@removed a source in GUI after an insertion
@
text
@d688 2
a689 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered (reject as new source): %i.%i.%i.%i %s"), (uint8)dwUserIP,(uint8)(dwUserIP>>8),(uint8)(dwUserIP>>16),(uint8)(dwUserIP>>24),
@


1.161
log
@Beta 2
@
text
@a745 1
			UpdateDisplayedInfo(pNewSource);				// eklmn: bugfix(12): refresh whole downloadlist
a801 1
	UpdateDisplayedInfo(pKnownSource);	// eklmn: bugfix(12): refresh whole downloadlist
@


1.160
log
@Removed debug code
@
text
@d721 1
@


1.159
log
@fixed precedence of category selection on WebServer and Search over Auto Cat feature
@
text
@a715 51
		//	DonGato: debug code for unknown problem
			CPartFile* pOtherFile = NULL;

			if (!pTempSource->m_otherRequestsList.IsEmpty())
				pOtherFile = pTempSource->m_otherRequestsList.GetTail();

			if (pOtherFile)
			{
				AddDebugLogLine( false, "** Client %s has no requested file. Requester: %s. A4AF[%i]: %s. Last action: %i",
					pTempSource->GetUserName(), pSenderFile->GetFileName(), pTempSource->m_otherRequestsList.GetCount(),
					pOtherFile->GetFileName(), pTempSource->m_ReqPartResetList.GetTail() );
			}
			else
			{
				CString strBuffer = "";

				switch (pTempSource->GetUploadState())
				{
					case US_ONUPLOADQUEUE:
						strBuffer = GetResString(IDS_ONQUEUE);
						break;
					case US_PENDING:
						strBuffer = GetResString(IDS_CL_PENDING);
						break;
					case US_LOWTOLOWIP:
						strBuffer = GetResString(IDS_CL_LOW2LOW);
						break;
					case US_BANNED:
						strBuffer = GetResString(IDS_BANNED);
						break;
					case US_ERROR:
						strBuffer = GetResString(IDS_ERRORLIKE);
						break;
					case US_CONNECTING:
						strBuffer = GetResString(IDS_CONNECTING);
						break;
					case US_WAITCALLBACK:
						strBuffer = GetResString(IDS_CONNVIASERVER);
						break;
					case US_UPLOADING:
						strBuffer = GetResString(IDS_TRANSFERRING);
						break;
					default:
						strBuffer = _T("Not in queue");
				}

				AddDebugLogLine( false, "** Client %s has no requested file. Requester: %s. No A4AF. Last action: %i. Upload State: %s",
					pTempSource->GetUserName(), pSenderFile->GetFileName(), pTempSource->m_ReqPartResetList.GetTail(),
					strBuffer );
			}

a857 2

	toremove->m_ReqPartResetList.AddTail(3); // DonGato: for testing purposes
@


1.158
log
@Auto Upload Priority for completed files
@
text
@d1525 2
a1526 1
						newfile->SetCatID(CCat::GetCatIDByIndex(ix));
d1534 2
a1535 1
						newfile->SetCatID(CCat::GetCatIDByIndex(ix));
@


1.157
log
@*** empty log message ***
@
text
@d709 1
d712 2
a713 1
		if (pTempSource->m_pReqPartFile == NULL)
a714 1
//			pTempSource->m_pReqPartFile = pSenderFile;
d716 1
d730 35
a764 2
				AddDebugLogLine( false, "** Client %s has no requested file. Requester: %s. No A4AF. Last action: %i",
					pTempSource->GetUserName(), pSenderFile->GetFileName(), pTempSource->m_ReqPartResetList.GetTail() );
d767 9
d777 1
a777 2

		if (pTempSource->m_pReqPartFile != pSenderFile)
d782 1
d914 2
@


1.156
log
@Ops!
@
text
@d715 1
a715 1
			CPartFile* pOtherFile;
@


1.155
log
@Reverted a change and added more debug log for unknown problem.
@
text
@d714 5
a718 1
			CPartFile* pOtherFile = pTempSource->m_otherRequestsList.GetTail();
@


1.154
log
@Minor changes
@
text
@d713 15
a727 3
			pTempSource->m_pReqPartFile = pSenderFile;
			AddDebugLogLine( false, "Client %s has no requested file, adding it to %s (last action: %i)",
				pTempSource->GetUserName(), pSenderFile->GetFileName(), pTempSource->m_ReqPartResetList.GetTail());
@


1.153
log
@A mistake... :P
@
text
@d711 7
@


1.152
log
@Added some data for debug, changed some log lines.
@
text
@d803 1
a803 1
//	toremove->SetDownloadState(DS_NONE);
@


1.151
log
@Some changes (unknown sources and wrong edonkey tags)
@
text
@d713 1
a713 1
			if (pTempSource->AddRequestForAnotherFile(pSenderFile)) 
d716 1
a716 1
		return NULL;		
d803 1
a803 1
	toremove->SetDownloadState(DS_NONE);
d842 2
@


1.150
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d724 1
d727 1
a727 1
			pNewSource->StartQueueWaitTimer(); //<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
d729 1
a729 1
			UpdateDisplayedInfo(pNewSource);	// eklmn: bugfix(12): refresh whole downloadlist
d779 1
a779 1
	
@


1.149
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d233 1
a233 1
				AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_RECOVERED_PARTMET), pPartFile->GetFileName());
d274 1
a274 1
		AddLogLine(true, RGB_RED + GetResString(IDS_SKIPZEROLENGTHFILE), pNewSearchFile->GetFileName());
d688 1
a688 1
		AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Filtered (reject as new source): %i.%i.%i.%i %s"), (uint8)dwUserIP,(uint8)(dwUserIP>>8),(uint8)(dwUserIP>>16),(uint8)(dwUserIP>>24),
d1221 1
a1221 1
			AddLogLine(false, RGB_RED + _T("Error calling WSAAsyncGetHostByName to resolve source "), hostsource->sourceHostname);
d1253 1
a1253 1
		DEBUG_ONLY(AddLogLine(false, RGB_RED + _T("Error resolving source : %s"), hostsource->sourceHostname));
d1276 1
a1276 1
		DEBUG_ONLY(AddLogLine(false, RGB_LIGHT_ORANGE + _T("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
@


1.148
log
@Added some colors to the logs...
@
text
@d233 1
a233 1
				AddLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_RECOVERED_PARTMET), pPartFile->GetFileName());
d274 1
a274 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_SKIPZEROLENGTHFILE), pNewSearchFile->GetFileName());
d688 1
a688 1
		AddDebugLogLine(false,_T("<COLOR=102,102,153>Filtered (reject as new source): %i.%i.%i.%i %s"), (uint8)dwUserIP,(uint8)(dwUserIP>>8),(uint8)(dwUserIP>>16),(uint8)(dwUserIP>>24),
d1221 1
a1221 1
			AddLogLine(false, CString("<COLOR=255,0,0>Error calling WSAAsyncGetHostByName to resolve source "), hostsource->sourceHostname);
d1253 1
a1253 1
		DEBUG_ONLY(AddLogLine(false, CString("<COLOR=255,0,0>Error resolving source : %s"), hostsource->sourceHostname));
d1276 1
a1276 1
		DEBUG_ONLY(AddLogLine(false, CString("<COLOR=255,102,0>void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
@


1.147
log
@corrected:
1) source filtering by adding a source
2) UDP status during a search
@
text
@d233 1
a233 1
				AddLogLine(false, IDS_RECOVERED_PARTMET, pPartFile->GetFileName());
d274 1
a274 1
		AddLogLine(true, IDS_SKIPZEROLENGTHFILE, pNewSearchFile->GetFileName());
d688 1
a688 1
		AddDebugLogLine(false,_T("Filtered (reject as new source): %i.%i.%i.%i %s"), (uint8)dwUserIP,(uint8)(dwUserIP>>8),(uint8)(dwUserIP>>16),(uint8)(dwUserIP>>24),
d1221 1
a1221 1
			AddLogLine(false, CString("Error calling WSAAsyncGetHostByName to resolve source "), hostsource->sourceHostname);
d1253 1
a1253 1
		DEBUG_ONLY(AddLogLine(false, CString("Error resolving source : %s"), hostsource->sourceHostname));
d1276 1
a1276 1
		DEBUG_ONLY(AddLogLine(false, CString("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
@


1.146
log
@minor spell-corrections (debuglog)
@
text
@d686 1
a686 1
	if (g_eMuleApp.m_pIPFilter->IsFiltered(dwUserIP) && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled()) 
d1297 5
a1301 1
	if (m_dwLastUDPSearchTime)
@


1.145
log
@missing update of cat titles after adding a new download via ed2k link
@
text
@d688 1
a688 1
		AddDebugLogLine(false,_T("Filtered (reject as new pSource): %i.%i.%i.%i %s"), (uint8)dwUserIP,(uint8)(dwUserIP>>8),(uint8)(dwUserIP>>16),(uint8)(dwUserIP>>24),
@


1.144
log
@improved NNS handling in A4AF
@
text
@d380 1
@


1.143
log
@exception fix in UDP request
@
text
@d842 1
a842 1
	toremove->CleanOtherRequests();	//Cax2 - downloadlistcontrol bugfix
@


1.142
log
@repair UDP broadcasting request
@
text
@d919 1
a929 1
	POSITION	posCurSearchedFile = NULL;
d944 2
a945 2
	
	while (iRequestedFiles < iMaxFilesPerPacket && posCurSearchedFile != posLastSearchedFile)
d948 1
a948 1
		CPartFile* pNextPartFile = m_partFileList.GetNext(posCurSearchedFile);
d957 7
a963 3
		//check for begining of the loop & start from the head if it needs
		if (!posCurSearchedFile)
			posCurSearchedFile = m_partFileList.GetHeadPosition();
@


1.141
log
@sorry people!!! i forgot an opcode
@
text
@d63 1
a63 1
	pCurUDPServer = 0;
d905 1
a905 2
	//get server for request (if server list is empty we have both calls of GetNextServer()
	// will give us a NULL
d907 2
a908 1
	if (!pCurUDPServer)
d910 1
a910 8
		if (g_eMuleApp.m_pServerList->GetNextServer(pCurUDPServer))
		{
			TRACE("ERROR:SendNextUDPPacket() no server found");
			StopUDPRequests();
			return false;
		}
		else
			pCurUDPServer = g_eMuleApp.m_pServerList->GetNextServer(pCurUDPServer);
d912 5
a916 2
	//eklmn: check local server & try switch to another one
	if (pCurUDPServer == g_eMuleApp.m_pServerList->GetServerByAddress(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetAddress(), g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetPort()))
d918 1
a918 4
		pCurUDPServer = g_eMuleApp.m_pServerList->GetNextServer(pCurUDPServer);
		//check if it was last server in the list
		if (!pCurUDPServer)
			g_eMuleApp.m_pServerList->GetNextServer(pCurUDPServer);
a961 1
	m_dwLastUDPSearchTime = ::GetTickCount();
@


1.140
log
@fixed endless loop in SendUDPRequest under some conditions
@
text
@d971 1
@


1.139
log
@Fix for my fix (statistics for corruption/compression gain)
@
text
@d934 1
a934 1
	CSafeMemFile dataGlobGetSources(16*iMaxFilesPerPacket);
d948 2
a949 1
	//create a packet
d951 1
a953 4
		//check for begining of the loop
		if (!posCurSearchedFile)
			posCurSearchedFile = posLastSearchedFile;
		
d963 4
@


1.138
log
@Fix for corruption/compression gain problem
@
text
@d1119 2
@


1.137
log
@1) UDP packet is not completly filled
2) corrected stats
3) removed unused variables
@
text
@d1106 2
a1107 2
		data[0] += cur_file->GetLostDueToCorruption();
		data[1] += cur_file->GetGainDueToCompression();
@


1.136
log
@1) compession support within communicatio client<->server
2) extended UDP file search support
@
text
@a63 1
	m_pLastPartFile = 0;
d66 1
a66 2
	m_nUDPSearchFile = 0;
	m_nUDPSearchServer = 0;
a84 1
	m_pLastUDPSearchedFile = NULL;
d941 5
a945 1
	else
d949 2
a950 2
	posCurSearchedFile = posLastSearchedFile;
	for (int i = 0; i < iMaxFilesPerPacket; i++)
d952 1
a952 1
		//check if the is a position pointer is valid (end of the list)
d954 2
a955 7
			posCurSearchedFile = m_partFileList.GetHeadPosition();

		// check to prevent doble entries
		// (we gonna have this if number of files with status "waiting" smaller 15)
		if (posCurSearchedFile == posLastSearchedFile)
			break;

d963 1
d1295 1
a1295 1
	if (m_pLastPartFile)
d1297 2
a1298 3
		sOut.Format( GetResString(IDS_UDPSEARCH_PROGRESS),
		             /*m_nUDPSearchFile*/0, m_partFileList.GetCount(),
		             /*m_nUDPSearchServer*/0, g_eMuleApp.m_pServerList->GetServerCount() );
d1301 2
a1302 6
	{
		if (m_dwLastUDPSearchTime)
			sOut.Format( GetResString(IDS_UDPSEARCH_NEXT), CastSecondsToHM((m_dwLastUDPSearchTime + UDPSERVERREASKTIME) - ::GetTickCount() ));
		else
			sOut = GetResString(IDS_UDPSEARCH_NOTSTART);
	}
@


1.135
log
@StartNextFile now also takes in account file names (useful for series)
@
text
@d63 1
a63 1
	cur_udpserver = 0;
d87 1
d894 4
d902 1
d907 7
a913 2
	if (!cur_udpserver)
		if (!(cur_udpserver = g_eMuleApp.m_pServerList->GetNextServer(cur_udpserver)))
d917 1
a917 11
		};

//	get nextfile
	CPartFile* nextfile = 0;
	while (!(nextfile && (nextfile->GetStatus() == PS_READY || nextfile->GetStatus() == PS_EMPTY)))
	{
		if (m_pLastPartFile == 0)
		{
			nextfile = m_partFileList.GetHead();
			m_nUDPSearchFile = 1;
			m_pLastPartFile = nextfile;
d920 44
d965 2
a966 35
			POSITION pos = m_partFileList.Find(m_pLastPartFile);
			if (!pos)
			{
				TRACE("Error: CDownloadQueue::SendNextUDPPacket()");
				nextfile = m_partFileList.GetHead();
				m_nUDPSearchFile = 1;
				m_pLastPartFile = nextfile;
			}
			else
			{
				m_partFileList.GetNext(pos);
				if (pos == 0)
				{
					cur_udpserver = g_eMuleApp.m_pServerList->GetNextServer(cur_udpserver);
					m_nUDPSearchServer++;
					if (cur_udpserver == 0)
					{
					//TRACE("finished");
						m_dwLastUDPSearchTime = ::GetTickCount();
						m_pLastPartFile = 0;
						m_nUDPSearchFile = 0;
						m_nUDPSearchServer = 0;
						return false; // finished (processed all file & all servers)
					}
					nextfile = m_partFileList.GetHead();
					m_nUDPSearchFile = 1;
					m_pLastPartFile = nextfile;
				}
				else
				{
					nextfile = m_partFileList.GetAt(pos);
					m_nUDPSearchFile++;
					m_pLastPartFile = nextfile;
				}
			}
d969 5
a973 9
	if ((g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileUDP()) < nextfile->GetSourceCount()) //<<--
		return true;
	Packet packet(OP_GLOBGETSOURCES, 16);
	md4cpy(packet.m_pcBuffer, nextfile->GetFileHash());
	if (cur_udpserver != g_eMuleApp.m_pServerList->GetServerByAddress(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetAddress(), g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetPort()))
	{
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet.m_dwSize);
		g_eMuleApp.m_pServerConnect->SendUDPPacket(&packet, cur_udpserver, false);
	}
d975 1
d984 2
a985 1
	cur_udpserver = 0;
d987 1
a987 1
	m_pLastPartFile = 0;
d1048 1
a1048 1

d1074 1
a1074 1

d1126 1
a1126 3


//	added by FoRcHa: ////////////////////////
d1141 1
a1141 1

d1156 1
a1156 1

d1174 1
a1174 1

d1241 1
a1241 1

d1284 1
a1284 1

d1301 2
a1302 2
		             m_nUDPSearchFile, m_partFileList.GetCount(),
		             m_nUDPSearchServer, g_eMuleApp.m_pServerList->GetServerCount() );
d1307 1
a1307 1
			sOut.Format( GetResString(IDS_UDPSEARCH_NEXT), CastSecondsToHM(m_dwLastTCPSourcesRequestTime));
d1316 1
a1316 2

//	v:- ekmn: A4AF management
a1333 1
//	^- ekmn: A4AF management
@


1.134
log
@Formatting, comments, and name changes.
@
text
@d402 4
a405 1
			if (pStartFile == NULL || pStartFile->GetPriority() < pPartFile->GetPriority())
@


1.133
log
@free disk space needed is now determined with respect to NTFS compression and/or sparse files
@
text
@d1098 3
a1100 3
		uint32 ui32SizeToTransfer = 0;
		uint32 ui32NeededSpace = (cur_file->GetFileSize()-cur_file->GetRealFileSize());
		cur_file->GetSizeToTransfer(ui32SizeToTransfer);
d1104 2
a1105 2
			data[3] += ui32SizeToTransfer;
			data[4] += ui32NeededSpace;
d1108 1
a1108 1
		data[6] += ui32NeededSpace;
@


1.132
log
@quantized sources request from the server
@
text
@d1099 2
a1100 2
		uint32 ui32NeededSpace = 0;
		cur_file->GetSizeToTransferAndNeededSpace (ui32SizeToTransfer, ui32NeededSpace);
d1105 1
a1105 2
			if (!cur_file->IsPreallocated())
				data[4] += ui32NeededSpace;
d1108 1
a1108 2
		if (!cur_file->IsPreallocated())
			data[6] += ui32NeededSpace;
@


1.131
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d85 2
d554 31
a584 1
	dwCurTick = GetTickCount();	//Cax2 - Refresh the variable
d1298 1
a1298 2
			sOut.Format( GetResString(IDS_UDPSEARCH_NEXT),
			             CastSecondsToHM((UDPSERVERREASKTIME - (GetTickCount() - m_dwLastUDPSearchTime)) / 1000) );
@


1.130
log
@stability improvements, i.e. delete a client (sorce) if addition to the client list was failed.
@
text
@d478 1
a478 1
		iDownSpeed = (iMaxDLSpeedBPS * 100) / (m_iDataRate + 1); //(uint16)((float)((float)(m_pPrefs->GetMaxDownload()*1024)/(m_iDataRate+1)) * 100);
d548 1
a548 1
		m_iAverageDataRate = (uint32)(((float)(m_averageDataRateList.front() - m_averageDataRateList.back())) * 1000 / (m_averageTickList.front() - m_averageTickList.back()));
@


1.129
log
@Formatting, comments, and name changes.
@
text
@d688 11
a698 8
		g_eMuleApp.m_pClientList->AddClient(pNewSource,true);
		pSenderFile->m_srcLists[pNewSource->m_iSourcesSlot].AddTail(pNewSource);
		pSenderFile->RemovePastComment(pNewSource);		// #zegzav:pastcomment
		pNewSource->StartQueueWaitTimer(); //<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
		g_eMuleApp.m_pDownloadList->AddSource(pSenderFile,pNewSource,false);
		UpdateDisplayedInfo(pNewSource);	// eklmn: bugfix(12): refresh whole downloadlist

		return pNewSource;
@


1.128
log
@Fix for SLS change
@
text
@d124 1
a124 1
			m_pSharedFileList->SafeAddKFile(pPartFile, true);
d200 1
a200 1
					m_pSharedFileList->SafeAddKFile(pPartFile); // part files are always shared files
d230 1
a230 1
					m_pSharedFileList->SafeAddKFile(pPartFile); // part files are always shared files
d1232 1
a1232 1
	//TODO: notify user the partfile exists no more?
@


1.127
log
@new way of adding sources
@
text
@d203 2
@


1.126
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d641 1
a641 1
void CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile, CUpDownClient *pSource, bool bSaveSources)
d645 3
a647 17
//	If we block loopbacks at this point it should prevent us from connecting to ourself
//	MOREVIT - What's the significance of the low byte of the client ID?
	if (!pSource->HasLowID() && (pSource->GetUserID() & 0xFF) == 0x7F)
	{
		delete pSource;
		return ;
	}

//	(filtering invalid eMule clients)
//	MOREVIT - How does this detect invalid clients?
	if ( pSource->GetMuleVersion() == 0
	     && pSource->GetVersion() == 0
	     && (pSource->GetClientSoft() == SO_EMULE || pSource->GetClientSoft() == SO_OLDEMULE) )
	{
		delete pSource;
		return ;
	}
d649 2
a650 3
//	Double check that the source isn't us... just testing...
//	[Lord KiRon] v2
	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), pSource->GetUserHash()) == 0)
d652 3
a654 2
		delete pSource;
		return ;
d657 2
a658 2
//	eklmn: if this part file is stopped or complete/completing no sources needed any more
//	MOREVIT - Finally. A comment that makes some sense!
d660 14
a673 2
	     || pSenderFile->GetStatus() == PS_COMPLETE
	     || pSenderFile->GetStatus() == PS_COMPLETING )
d675 6
a680 2
		delete pSource;
		return ;
d682 1
a682 14

//	eklmn: check if client has to be filtered
	if (g_eMuleApp.m_pIPFilter->IsFiltered(pSource->GetUserID()) && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled())
	{
		AddDebugLogLine(false, _T("Filtered (reject as new source): %s %s"), pSource->GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
		delete pSource;
		return ;
	}

//	Uses this only for temp. clients
	POSITION	pos, pos1, pos2;

//	For each part file in the queue...
	for (pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d684 8
a691 13
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);

	//	For each of the part file's source slots...
		for (int sl = 0; sl < SOURCESSLOTS; sl++)
		{
			if (!pPartFile->m_srcLists[sl].IsEmpty())
			{
			//	For each source in the source slot...
				for (pos1 = pPartFile->m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL;)
				{
					pPartFile->m_srcLists[sl].GetNext(pos1);

					CUpDownClient	*pTempSource = pPartFile->m_srcLists[sl].GetAt(pos2);
d693 1
a693 17
				//	If 'pSource' is already assigned to a file...
					if (pTempSource->Compare(pSource))
					{
					//	If we are adding another (different from current file) check in OtherFileList
						if (pPartFile != pSenderFile)
						{
						//	Check in other file list
							if (pTempSource->AddRequestForAnotherFile(pSenderFile))
								g_eMuleApp.m_pDownloadList->AddSource(pSenderFile, pTempSource, true);

						}
						delete pSource;
						return ;
					}
				}
			}
		}
a694 8
//	Our new source is real new but maybe it is already uploading to us?
//	If yes the known client will be attached to the var "pSource"
//	and the old sourceclient will be deleted
#ifdef OLD_SOCKETS_ENABLED
	if (g_eMuleApp.m_pClientList->AttachToAlreadyKnown(&pSource, 0))
		pSource->m_pReqPartFile = pSenderFile;
	else
#endif //OLD_SOCKETS_ENABLED
d696 1
a696 1
		g_eMuleApp.m_pClientList->AddClient(pSource, true);
d698 1
a698 7
	pSenderFile->m_srcLists[pSource->m_iSourcesSlot].AddTail(pSource);
	pSenderFile->RemovePastComment(pSource);		// #zegzav:pastcomment
	pSource->StartQueueWaitTimer(); //<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
	g_eMuleApp.m_pDownloadList->AddSource(pSenderFile, pSource, false);
	UpdateDisplayedInfo(pSource);	// eklmn: bugfix(12): refresh whole downloadlist

	EMULE_CATCH
d701 1
a701 1
BOOL CDownloadQueue::CheckAndAddKnownSource(CPartFile* sender, CUpDownClient* source)
d704 5
a708 6
//	SyruS "stop adding sources on stopped, completing and completed files" (Cax2 + SyruS check)
//	eklmn: please never use > or < in state check
	if ( sender->GetStatus() == PS_PAUSED
	     || sender->GetStatus() == PS_STOPPED
	     || sender->GetStatus() == PS_COMPLETE
	     || sender->GetStatus() == PS_COMPLETING )
d710 2
a711 2
//	SyruS end
	if (!source->HasLowID() && (source->GetUserID() & 0xFF) == 0x7F)
d713 4
a716 9
//	[Lord KiRon] v3
	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), source->GetUserHash()) == 0)
	{
	//	This is most important part of the fix
	//	if we not throw here, CClientReqSocket::ProcessPacket will never diconnect a client
		/*throw CString(_T("Got myself as a source"));*/
		return FALSE;
	}
//	[/Lord KiRon] v3
d718 2
a719 2
//eklmn: check a file in download list
	if (IsInDLQueue(sender))
d721 2
a722 2
	//	if requested file already specified
		if (source->m_pReqPartFile)
d724 2
a725 2
		//	check if it's a same file
			if (sender == source->m_pReqPartFile)
d727 2
a728 2
			//	if file was found, to speed up checks we gonna use variable sourceslot
				if (sender->m_srcLists[source->m_iSourcesSlot].Find(source))
a729 2
			//	else
			//	DEBUG_ONLY(AfxDebugBreak());
d733 2
a734 2
				if (source->AddRequestForAnotherFile(sender))
					g_eMuleApp.m_pDownloadList->AddSource(sender, source, false);
d739 8
a746 8

	source->m_pReqPartFile = sender;
//if (source->GetFileRate()>0 ||source->GetFileComment().GetLength()>0) sender->UpdateFileRatingCommentAvail();
	sender->m_srcLists[source->m_iSourcesSlot].AddTail(source);
	sender->RemovePastComment(source);		// #zegzav:pastcomment
	source->StartQueueWaitTimer(); //<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
	g_eMuleApp.m_pDownloadList->AddSource(sender, source, false);
	UpdateDisplayedInfo(source);	// eklmn: bugfix(12): refresh whole downloadlist
d753 1
a753 1

d811 1
a811 1

d822 1
a822 1

d834 1
a834 1

d852 1
a852 1

d931 1
a931 1

@


1.125
log
@no message
@
text
@d84 1
a84 1
	m_lastRefreshedDLDisplay = ::GetTickCount();
d646 1
a646 1
//	MOREVIT - What's the significance of the low byte of the user hash?
d684 1
a684 1
		AddDebugLogLine(false, _T("Filtered (reject as new pSource): %s %s"), pSource->GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d732 1
a732 1
		pSource->reqfile = pSenderFile;
d738 1
a738 1
	pSenderFile->m_srcLists[pSource->sourcesslot].AddTail(pSource);
d774 1
a774 1
		if (source->reqfile)
d777 1
a777 1
			if (sender == source->reqfile)
d780 1
a780 1
				if (sender->m_srcLists[source->sourcesslot].Find(source))
d794 1
a794 1
	source->reqfile = sender;
d796 1
a796 1
	sender->m_srcLists[source->sourcesslot].AddTail(source);
d819 3
a821 3
//eklmn: check actual requested file (we have this info in "reqfile")
	cur_file = toremove->reqfile;
	if (cur_file != NULL && !cur_file->m_srcLists[toremove->sourcesslot].IsEmpty())
d823 1
a823 1
		POSITION remove_pos = cur_file->m_srcLists[toremove->sourcesslot].Find(toremove);
d827 1
a827 1
			cur_file->m_srcLists[toremove->sourcesslot].RemoveAt(remove_pos);
d835 1
a835 1
	if (!toremove->m_OtherRequests_list.IsEmpty())
d837 1
a837 1
		for (POSITION pos = toremove->m_OtherRequests_list.GetHeadPosition();pos != 0; toremove->m_OtherRequests_list.GetNext(pos))
d839 1
a839 1
			cur_file = toremove->m_OtherRequests_list.GetAt(pos);
d855 1
a855 1
		toremove->reqfile->UpdateFileRatingCommentAvail();
d857 1
a857 1
	toremove->reqfile = NULL;
@


1.124
log
@More fixes for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@a109 10
#ifndef ASYNC_UI_UPDATES

	DWORD	dwCurTick = GetTickCount();

	if (bForceUpdate || dwCurTick - m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE + (uint32)(rand() * 1000 / RAND_MAX))
	{
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateSourceItem(pSource);
		m_lastRefreshedDLDisplay = dwCurTick;
	}
#else
a110 1
#endif ASYNC_UI_UPDATES
@


1.123
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d116 1
a116 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateItem(pSource);
@


1.122
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d27 1
a27 1
static char THIS_FILE[]=__FILE__;
d31 1
a31 1
// START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d44 1
a44 1
LRESULT CHostnameSourceWnd::OnSourceHostnameResolved(WPARAM wParam,LPARAM lParam)
d47 1
a47 1
		m_pOwner->SourceHostnameResolved(wParam,lParam);
d53 1
a53 1
// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d57 1
a57 1
CDownloadQueue::CDownloadQueue(CPreferences *in_pPrefs,CSharedFileList *in_pSharedFileList)
d83 1
a83 1
	//eklmn: it's need to initialize this variable to prevent extra screen refreshing during the start
d89 2
a90 2
    EMULE_TRY
	//--- xrmb:keepPartFileStats ---
d92 1
a92 1
	//--- :xrmb ---
d100 1
a100 1
    EMULE_CATCH
d103 1
a103 1
void CDownloadQueue::UpdateDisplayedInfo(CUpDownClient *pSource,boolean bForceUpdate)
d108 1
a108 1
		return;
a110 1
    DWORD		dwCurTick = GetTickCount();
d112 3
a114 1
    if (bForceUpdate || dwCurTick - m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX))
d116 3
a118 3
        g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(pSource);
        m_lastRefreshedDLDisplay = dwCurTick;
    }
d120 1
a120 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.PostMessage(WM_DL_UPDATESOURCEITEM,0,reinterpret_cast<LPARAM>(pSource));
d132 1
a132 1
		CPartFile	*pPartFile = m_partFileList.GetAt(pos);
d135 1
a135 1
			m_pSharedFileList->SafeAddKFile(pPartFile,true);
d138 1
a138 1
    EMULE_CATCH
d143 1
a143 1
    EMULE_TRY
d155 1
a155 1
		m_nDownDataRateOverhead = 10*m_nDownDataRateOverhead/m_averageDDROList.GetCount();
d159 1
a159 1
    EMULE_CATCH
d164 1
a164 1
    EMULE_TRY
d167 4
a170 4
//		start changed by InterCeptor (multiple tempdirs) 19.11.02
	uint16		iCount = 0;
	CString		strTempDir = m_pPrefs->GetTempDir();
	bool		bRemove = false;
d173 1
a173 1
	if (m_pPrefs->m_tempDirList.Find(strTempDir) == NULL && m_pPrefs->m_tempDirList.Find(strTempDir+'\\') == NULL)
d189 1
a189 1
		bool			bEnd = !ff.FindFile(strSearchPath,0);
d202 1
a202 1
			if (pPartFile->LoadPartFile(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d206 1
a206 1
				if (md4cmp(pPartFile->GetFileHash(), g_eMuleApp.m_pGlobPrefs->GetA4AFHash()) == 0)// v1:- eklmn: A4AF mangement
d213 1
a213 1
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddFile(pPartFile);// show in downloadwindow
d233 1
a233 1
			if (pPartFile->LoadPartFile(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d240 1
a240 1
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddFile(pPartFile);// show in downloadwindow
d257 1
a257 1
		AddLogLine(false,IDS_NOPARTSFOUND);
d261 1
a261 1
		AddLogLine(false,IDS_FOUNDPARTS,iCount);
d269 3
a271 3
	m_wndHSCallback=NULL; 
	sourceHostnameResolveRetry=0;
	m_bIsResolving=false;
d273 2
a274 2
	m_bIsInitialized=true;
    EMULE_CATCH
d277 1
a277 1
void CDownloadQueue::AddSearchToDownload(CSearchFile *pNewSearchFile,uint8 iCatID/*=0*/)
d281 1
a281 1
	if (pNewSearchFile->GetFileSize() == 0) 
d284 1
a284 1
		return;
d287 1
a287 1
		return;
d289 1
a289 1
	CPartFile		*pNewPartFile = new CPartFile(pNewSearchFile);
d294 1
a294 1
		return;
d296 1
a296 1
	pNewPartFile->SetCatID(iCatID);
d334 2
a335 2
	}				
	// netwolf 15.05.03 enhanced source finding END
d340 1
a340 1
void CDownloadQueue::AddSearchToDownload(CString strE2DKLink,uint8 iCatID/*=0*/)
d344 1
a344 1
	CPartFile	*pNewPartFile = new CPartFile(strE2DKLink);
d349 1
a349 1
		return;
d351 1
a351 1
	pNewPartFile->SetCatID(iCatID);
d357 1
a357 1
void CDownloadQueue::AddFileLinkToDownload(CED2KFileLink *pLink,uint8 iCatID)
d359 1
a359 1
    EMULE_TRY
d366 1
a366 1
		pNewPartFile=NULL;
d370 1
a370 1
		pNewPartFile->SetCatID(iCatID);
d377 1
a377 1
		{ 
d394 1
a394 1
void CDownloadQueue::StartNextFile(int iCatID)
d396 1
a396 1
    EMULE_TRY
d398 3
a400 3
	CPartFile		*pPartFile;
	CPartFile		*pStartFile = NULL;
	POSITION		pos;
d406 1
a406 1
		if (pPartFile->GetStatus() == PS_PAUSED && CCat::FileBelongsToGivenCat(pPartFile,iCatID))
d417 1
a417 1
    EMULE_CATCH
d422 1
a422 1
    EMULE_TRY
d432 1
a432 1
	SetAutoCat(pNewPartFile);// HoaX_69 / Slugfiller: AutoCat
d434 2
a435 2
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddFile(pNewPartFile);
	AddLogLine(true,IDS_NEWDOWNLOAD,pNewPartFile->GetFileName());
d437 1
a437 1
	CString		strMessageText;
d441 1
a441 1
											g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled() );
d443 2
a444 2
										  g_eMuleApp.m_pGlobPrefs->GetUseDownloadAddNotifier() );
    EMULE_CATCH
d451 1
a451 1
    EMULE_TRY
d467 1
a467 1
    EMULE_CATCH
d474 1
a474 1
    EMULE_TRY
d477 1
a477 1
		return;
d479 3
a481 3
	uint32		iDownSpeed = 0;
	uint16		iMaxDLSpeed = m_pPrefs->GetMaxDownload();
	uint32		iMaxDLSpeedBPS = iMaxDLSpeed*1024;	//Bytes per second
d487 1
a487 1
		iDownSpeed = (iMaxDLSpeedBPS*100)/(m_iDataRate+1); //(uint16)((float)((float)(m_pPrefs->GetMaxDownload()*1024)/(m_iDataRate+1)) * 100);
d498 1
a498 1
	uint32		iTempDataRate = 0;
d503 1
a503 1
		CPartFile		*pPartFile =  m_partFileList.GetAt(pos);
d506 2
a507 2
		if ( (pPartFile->GetStatus() == PS_READY || pPartFile->GetStatus() == PS_EMPTY) 
		  && (pPartFile->GetPriority() == PR_HIGH || pPartFile->GetPriority() == PR_AUTO) )	//jicxicmic fix
d514 1
a514 1
		CPartFile	*pPartFile =  m_partFileList.GetAt(pos);
d518 1
a518 1
		  && pPartFile->GetPriority() == PR_NORMAL )
d525 1
a525 1
		CPartFile	*pPartFile =  m_partFileList.GetAt(pos);
d529 1
a529 1
		  && pPartFile->GetPriority() == PR_LOW )
d531 1
a531 1
			iTempDataRate += pPartFile->Process(iDownSpeed, m_iUDCounter /*iteration*/); 
d537 1
a537 1
	DWORD		dwCurTick = GetTickCount();
d548 1
a548 1
		while (dwCurTick-m_averageTickList.back() > 40000)
d550 1
a550 1
   			m_averageDataRateList.pop_back();
d556 2
a557 2
	if (m_averageDataRateList.size() > 1) 
		m_iAverageDataRate = (uint32)(((float)(m_averageDataRateList.front()-m_averageDataRateList.back()))*1000 / (m_averageTickList.front()-m_averageTickList.back()));
d560 1
a560 1
	
d577 3
a579 3
	//--- xrmb:keepPartFileStats ---
	//--- i hope that is a safe point to save the stats ---
	if (m_lastPartFileStatsSave + 300000 < dwCurTick )
d581 1
a581 1
		m_lastPartFileStatsSave=dwCurTick;
d585 2
a586 2
	//--- :xrmb ---
    EMULE_CATCH
d591 1
a591 1
    EMULE_TRY
d600 1
a600 1
    EMULE_CATCH
d615 1
a615 1
//		or NULL if there is none.
d620 1
a620 1
    EMULE_TRY
d624 1
a624 1
		if (!md4cmp(strFileHash,m_partFileList.GetAt(pos)->GetFileHash()))
d631 1
a631 1
    EMULE_CATCH
d638 1
a638 1
	bool		bIsInDLQueue = false;
d652 1
a652 1
void CDownloadQueue::CheckAndAddSource(CPartFile *pSenderFile,CUpDownClient *pSource, bool bSaveSources)
d654 1
a654 1
    EMULE_TRY
d661 2
a662 2
		return;
	}	
d667 2
a668 2
	  && pSource->GetVersion() == 0
	  && (pSource->GetClientSoft() == SO_EMULE || pSource->GetClientSoft() == SO_OLDEMULE) )
d671 1
a671 1
		return;
d679 2
a680 2
		return;
	} 
d685 2
a686 2
	  || pSenderFile->GetStatus() == PS_COMPLETE
	  || pSenderFile->GetStatus() == PS_COMPLETING )
d689 1
a689 1
		return;
d693 1
a693 1
	if (g_eMuleApp.m_pIPFilter->IsFiltered(pSource->GetUserID()) && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled()) 
d695 1
a695 1
		AddDebugLogLine(false,_T("Filtered (reject as new pSource): %s %s"), pSource->GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d697 1
a697 1
		return;
d709 1
a709 1
		for (int sl = 0; sl < SOURCESSLOTS; sl++) 
d714 1
a714 1
				for (pos1 = pPartFile->m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL; )
d721 1
a721 1
					if (pTempSource->Compare(pSource)) 
d725 1
a725 1
						{ 
d727 2
a728 2
							if (pTempSource->AddRequestForAnotherFile(pSenderFile)) 
								g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(pSenderFile,pTempSource,true);
d732 1
a732 1
						return;
d742 1
a742 1
	if (g_eMuleApp.m_pClientList->AttachToAlreadyKnown(&pSource,0))
d746 3
a748 2
		g_eMuleApp.m_pClientList->AddClient(pSource,true);
	
d752 1
a752 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(pSenderFile,pSource,false);
d755 1
a755 1
   EMULE_CATCH
d758 1
a758 1
BOOL CDownloadQueue::CheckAndAddKnownSource(CPartFile* sender,CUpDownClient* source)
d760 10
a769 7
    EMULE_TRY
	// SyruS "stop adding sources on stopped, completing and completed files" (Cax2 + SyruS check)
	// eklmn: please never use > or < in state check
	if (sender->GetStatus() == PS_PAUSED 
		|| sender->GetStatus() == PS_STOPPED
		|| sender->GetStatus() == PS_COMPLETE
		|| sender->GetStatus() == PS_COMPLETING) 
d771 6
a776 2
	// SyruS end
	if(!source->HasLowID() && (source->GetUserID() & 0xFF) == 0x7F)
a777 7
	// [Lord KiRon] v3 
   	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), source->GetUserHash()) == 0) 
   	{ 
    	// This is most important part of the fix 
        // if we not throw here, CClientReqSocket::ProcessPacket will never diconnect a client 
        /*throw CString(_T("Got myself as a source"));*/ 
        return FALSE; 
d779 1
a779 1
	// [/Lord KiRon] v3 
d781 1
a781 1
	//eklmn: check a file in download list
d784 1
a784 1
		// if requested file already specified
d787 2
a788 2
			// check if it's a same file
			if (sender == source->reqfile) 
d790 2
a791 2
				// if file was found, to speed up checks we gonna use variable sourceslot
				if (sender->m_srcLists[source->sourcesslot].Find(source)) 
d793 2
a794 2
//				else 
//					DEBUG_ONLY(AfxDebugBreak());
d799 1
a799 1
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(sender,source,false);
d804 1
a804 1
	
d806 1
a806 1
	//if (source->GetFileRate()>0 ||source->GetFileComment().GetLength()>0) sender->UpdateFileRatingCommentAvail();
d810 1
a810 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(sender,source,false);
d815 1
a815 1
		
d824 1
a824 1
	// v-eklmn: bugfix(09): hang up by start if all files are paused
d827 1
a827 1
	// eklmn: set client state to DS_NONE in order to prevent any action from him
d829 2
a830 2
	
	//eklmn: check actual requested file (we have this info in "reqfile")
d835 1
a835 1
		if (remove_pos != NULL) 
d841 1
a841 1
		//eklmn: update source info for the file
d845 1
a845 1
	//eklmn: now remove client in A4AF files. let's use "OtherRequests_list" for this goal
d851 1
a851 1
			if(IsInDLQueue(cur_file))
d854 1
a854 1
				if (pos_A4AF) 
d861 1
a861 1
	//eklmn: clear client from all graphical lists
d863 1
a863 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.RemoveSource(toremove,NULL);	
d865 1
a865 1
	if (toremove->GetFileComment().GetLength()>0 || toremove->GetFileRating() != PF_RATING_NONE )
d871 1
a871 1
	
d873 2
a874 2
		
    return false;
d890 4
a893 4
	for(POSITION pos = m_partFileList.GetHeadPosition(); pos != NULL;m_partFileList.GetNext(pos))
	{ 
		CPartFile* cur_file = m_partFileList.GetAt(pos); 
		if( cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY ) //netwolf
d902 1
a902 1
    EMULE_TRY
d904 9
a912 7
	for (pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos)){
		CPartFile* cur_file = m_partFileList.GetAt(pos);
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->m_srcLists[sl].IsEmpty())
			cur_file->m_srcLists[sl].RemoveAll();
		// Barry - Should also remove all requested blocks
		// Don't worry about deleting the blocks, that gets handled 
		// when CUpDownClient is deleted in CClientList::DeleteAll()
d915 1
a915 1
    EMULE_CATCH
d922 2
a923 1
	if(!m_bIsInitialized) return false;
d927 2
a928 1
		if (!(cur_udpserver = g_eMuleApp.m_pServerList->GetNextServer(cur_udpserver))){
d933 1
a933 1
	// get nextfile
d935 4
a938 2
	while (!(nextfile && (nextfile->GetStatus() == PS_READY ||nextfile->GetStatus() == PS_EMPTY))){
		if (m_pLastPartFile == 0){
d943 2
a944 1
		else{
d946 2
a947 1
			if (!pos){
d953 2
a954 1
			else{
d956 2
a957 1
				if (pos == 0){
d960 3
a962 2
					if (cur_udpserver == 0){
						//TRACE("finished");
d973 2
a974 1
				else{
d982 6
a987 5
	if( (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileUDP()) < nextfile->GetSourceCount()) //<<--
		return true; 
	Packet packet(OP_GLOBGETSOURCES,16);
	md4cpy(packet.m_pcBuffer,nextfile->GetFileHash());
	if (cur_udpserver != g_eMuleApp.m_pServerList->GetServerByAddress(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetAddress(),g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetPort())){
d989 1
a989 1
		g_eMuleApp.m_pServerConnect->SendUDPPacket(&packet,cur_udpserver,false);
d1005 1
a1005 1

d1009 24
a1032 17
	POSITION pos1, pos2;
	uint16 i = 0;
	for( pos1 = m_partFileList.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
	   m_partFileList.GetNext(pos1);
	   CPartFile* cur_file = m_partFileList.GetAt(pos2);
	   if (cur_file->GetPriority() == PR_HIGH){
		   m_partFileList.AddHead(cur_file);
		   m_partFileList.RemoveAt(pos2);
	   }
	   else if (cur_file->GetPriority() == PR_LOW){
		   m_partFileList.AddTail(cur_file);
		   m_partFileList.RemoveAt(pos2);
	   }
	   i++;
	   if (i == m_partFileList.GetCount())
		   break;
   }
d1035 1
a1035 1

d1040 1
a1040 1
	POSITION pos,pos1,pos2;
d1043 1
a1043 1
	
d1047 1
a1047 1
		for (int sl=0;sl<SOURCESSLOTS;sl++) 
d1049 1
a1049 1
				for (pos1 = cur_file->m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d1068 1
a1068 1
	CPartFile* cur_file;
d1073 2
a1074 3
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->m_srcLists[sl].IsEmpty())
		{
			for (POSITION pos2 = cur_file->m_srcLists[sl].GetHeadPosition();pos2 != 0;)
d1076 1
a1076 2
				CUpDownClient* cur_client = cur_file->m_srcLists[sl].GetNext(pos2);
				if (dwIP == cur_client->GetIP() && nUDPPort == cur_client->GetUDPPort())
d1078 5
a1082 1
					return cur_client;
a1084 1
		}
d1091 1
a1091 1
void CDownloadQueue::GetDownloadStats(uint16 sources[], uint64  data[]) 
d1095 4
a1098 2
	for (int i=0;i<STATS_DL_SOURCES_TYPE;i++) sources[i] = 0;
	for (int i=0;i<STATS_DL_DATA_INFO;i++) data[i] = 0;
d1102 27
a1128 27
		CPartFile* cur_file =  m_partFileList.GetAt(pos);
		sources[0]+=cur_file->GetSourceCount();
		sources[1]+=cur_file->GetTransferringSrcCount();
		//extra stats
		sources[2]+=cur_file->GetOnQueueSrcCount();
		sources[3]+=cur_file->GetQueueFullSrcCount();
		sources[4]+=cur_file->GetNoNeededPartsSrcCount();
		sources[5]+=cur_file->GetConnectedSrcCount();
		sources[6]+=cur_file->GetRecHashsetSrcCount();
		sources[7]+=cur_file->GetConnectingSrcCount();
		sources[8]+=cur_file->GetConnectingViaServerSrcCount();
		sources[9]+=cur_file->GetTooManyConnsSrcCount();
		sources[10]+=cur_file->GetLow2LowSrcCount();
		sources[11]+=cur_file->GetUnknownSrcCount();
		sources[12]+=cur_file->GetErrorSrcCount();
		sources[13]+=cur_file->GetBannedSrcCount();
		sources[14]+=cur_file->TotalPacketsSavedDueToICH();
		sources[15]+=cur_file->GetSrcA4AFCount();
		sources[16]+=cur_file->GetTimeoutedSrcCount();
		sources[17]+=cur_file->GetHighQRSrcCount();
		sources[18]+=cur_file->GetNoUploadSrcCount();
		// some data
		data[0]+=cur_file->GetLostDueToCorruption();
		data[1]+=cur_file->GetGainDueToCompression();
		uint32 ui32SizeToTransfer=0;
		uint32 ui32NeededSpace=0;
		cur_file->GetSizeToTransferAndNeededSpace (ui32SizeToTransfer,ui32NeededSpace);
d1140 1
a1140 1
	
d1145 1
a1145 1
// added by FoRcHa: ////////////////////////
d1150 1
a1150 1
	for(POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d1152 2
a1153 2
		CPartFile* cur_file = m_partFileList.GetAt(pos);
		if(cur_file->GetTransferringSrcCount() > 0)
d1165 2
a1166 1
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;){
d1176 3
a1178 2
// START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
void CDownloadQueue::AddClientHostnameToResolve(CTypedPtrList<CPtrList, CClientSource*>* pLink) {
d1183 1
a1183 1
		return;
d1185 4
a1188 3
	if (m_bIsResolving) {
		DEBUG_ONLY(AddLogLine(false,CString("void CDownloadQueue::AddClientHostnameToResolve(CPtrList* pLink): already resolving. Exiting.")));
		return;
d1191 1
a1191 1
	ResolveNextSourceHostname(); 
d1194 2
a1195 1
void CDownloadQueue::ResolveNextSourceHostname() {
d1198 6
a1203 3
	while (1) { 
		if (hostnameResolveQueue.IsEmpty()) { //No more hostnames to resolve
			if (m_wndHSCallback) {
d1205 1
a1205 1
				m_wndHSCallback=NULL;
d1207 2
a1208 2
			m_bIsResolving=false;
			return;
d1211 2
a1212 1
		if (source->sourceType != ED2KLINK_SOURCE_HOSTNAME) {
d1215 2
a1216 1
		} else
d1222 4
a1225 3
	if (!m_wndHSCallback) {
		m_wndHSCallback=new CHostnameSourceWnd();
		VERIFY( m_wndHSCallback->CreateEx(0, AfxRegisterWndClass(0),_T("Emule DNS Source Socket Wnd"),WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL));
d1229 1
a1229 1
	AddLogLine(false,CString("Resolving source hostname: %s"),source->sourceHostname);
d1232 2
a1233 2
	RetValue=WSAAsyncGetHostByName(m_wndHSCallback->m_hWnd, TM_SOURCEHOSTNAMERESOLVED, 
		CT2CA(source->sourceHostname), hostentBuffer, MAXGETHOSTSTRUCT);
d1235 7
a1241 5
	if(RetValue==0) {
		if (sourceHostnameResolveRetry > 3) {
			CClientSource* hostsource;  
			hostsource = hostnameResolveQueue.RemoveHead();  
			AddLogLine(false,CString("Error calling WSAAsyncGetHostByName to resolve source "),hostsource->sourceHostname);
d1243 2
a1244 1
			if (m_wndHSCallback) {
d1246 1
a1246 1
				m_wndHSCallback=NULL;
d1249 5
a1253 4
			m_bIsResolving=false;
		} 
		else {
			sourceHostnameResolveRetry +=1;
d1255 1
a1255 1
			AddLogLine(false,CString("Source resolve retry numer %i"),sourceHostnameResolveRetry);
d1261 2
a1262 1
void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp) {
d1266 1
a1266 1
	sourceHostnameResolveRetry=0;
d1269 1
a1269 1
	hostsource = hostnameResolveQueue.RemoveHead();  
d1271 3
a1273 2
	if (WSAGETASYNCERROR(lp) != 0){
		DEBUG_ONLY(AddLogLine(false,CString("Error resolving source : %s"),hostsource->sourceHostname));
d1276 2
a1277 2
		m_wndHSCallback=NULL;
		memset2(hostentBuffer, 0, sizeof(hostentBuffer));  
d1279 1
a1279 1
		return;
d1285 1
a1285 1
	hostsource->sourceID=((LPIN_ADDR)lphost->h_addr_list[0])->s_addr; 
d1289 2
a1290 2
	AddLogLine(false,CString("Resolved source hostname: %s - %i:%i:%i:%i"),hostsource->sourceHostname, resolvedaddr.S_un.S_un_b.s_b1, resolvedaddr.S_un.S_un_b.s_b2, resolvedaddr.S_un.S_un_b.s_b3, resolvedaddr.S_un.S_un_b.s_b4);
	CPartFile* partfile=this->GetFileByID(hostsource->filehashkey);
d1293 4
a1296 3
	else {
		//TODO: notify user the partfile exists no more?
		DEBUG_ONLY(AddLogLine(false,CString("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
d1302 1
a1302 1
// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d1308 2
a1309 1
	if(!m_bIsInitialized) return _T("");
d1311 1
d1317 1
a1317 1
	if(m_pLastPartFile)
d1319 3
a1321 3
		sOut.Format(GetResString(IDS_UDPSEARCH_PROGRESS),
			m_nUDPSearchFile, m_partFileList.GetCount(),
			m_nUDPSearchServer, g_eMuleApp.m_pServerList->GetServerCount());
d1325 3
a1327 3
		if(m_dwLastUDPSearchTime)
			sOut.Format(GetResString(IDS_UDPSEARCH_NEXT), 
				CastSecondsToHM((UDPSERVERREASKTIME - (GetTickCount() - m_dwLastUDPSearchTime))/1000));
d1337 2
a1338 2
// v:- ekmn: A4AF management
void CDownloadQueue::SetA4AFAutoFile(CPartFile* file)		
d1341 1
a1341 1
		
d1345 3
a1347 2
	else {
		// Set null hash
d1355 1
a1355 1
// ^- ekmn: A4AF management
d1359 1
a1359 1
	//DonGato: fix because of list update in SetCatID :S
d1369 2
a1370 2
		if (CCat::GetCatIndexByID(cur_file->GetCatID()) == iCatIndex) 
			cur_file->SetCatID(0);
d1376 2
a1377 2
	//DonGato: fix because of list update in SetCatID :S
	CTypedPtrList<CPtrList, CPartFile*>		locallist;
d1384 1
a1384 1
		CPartFile		*cur_file = locallist.GetAt(pos);
d1387 2
a1388 2
		{	
			if (newprio==PR_AUTO) 
d1393 1
a1393 1
			else 
d1405 1
a1405 1
	
d1407 1
a1407 1
	while (pos != 0) 
d1409 1
a1409 1
		CPartFile* cur_file = m_partFileList.GetAt(pos);
d1411 1
a1411 1
		if (!cur_file) 
d1415 2
a1416 2
		  || (iCatIndex == 0 && CCat::FileBelongsToGivenCat(cur_file,CAT_ALL))
		  || (iCatIndex >= CCat::GetNumPredefinedCats() && CCat::GetCatIDByIndex(iCatIndex) == cur_file->GetCatID()) )
d1418 1
a1418 1
			switch (newstatus) 
d1437 1
a1437 1
		if(reset) 
d1456 2
a1457 2
			// No need to compare agains an empty AutoCat array
			if( catExt == "")
d1472 2
a1473 2
					// Use wildcards
					char* file = fullname.GetBuffer();
d1478 1
a1478 1
						return;
d1480 4
a1483 2
				} else {
					if(fullname.Find(cmpExt) != -1)
d1486 1
a1486 1
						return;
d1489 1
a1489 1
				cmpExt = catExt.Tokenize("|",curPos);
@


1.121
log
@Formatting, comments, and name changes.
@
text
@d1186 1
a1186 1
	memset(hostentBuffer, 0, sizeof(hostentBuffer));
d1210 1
a1210 1
			memset(hostentBuffer, 0, sizeof(hostentBuffer));
d1215 1
a1215 1
			memset(hostentBuffer, 0, sizeof(hostentBuffer));
d1236 1
a1236 1
		memset(hostentBuffer, 0, sizeof(hostentBuffer));  
d1257 1
a1257 1
	memset(hostentBuffer, 0, sizeof(hostentBuffer));
d1304 1
a1304 1
		memset(null_hash, 0, sizeof(null_hash));
@


1.120
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d863 1
a863 1
	if (toremove->GetFileComment().GetLength()>0 || toremove->GetFileRate()>0 )
@


1.119
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d103 1
a103 1
void CDownloadQueue::UpdateDisplayedInfo(boolean bForceUpdate)
d110 1
d115 1
a115 1
        g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d118 4
d751 1
a751 1
	UpdateDisplayedInfo();	// eklmn: bugfix(12): refresh whole downloadlist
d809 1
a809 1
	UpdateDisplayedInfo();	// eklmn: bugfix(12): refresh whole downloadlist
@


1.118
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d22 1
a22 1
#include "memcpy_amd.h"
@


1.117
log
@Formatting, comments, and name changes.
@
text
@d966 1
a966 1
	md4cpy(packet.pBuffer,nextfile->GetFileHash());
d968 1
a968 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet.size);
@


1.116
log
@intialization some variables in constructor
@
text
@d705 1
a705 1
			if (!pPartFile->srclists[sl].IsEmpty())
d708 1
a708 1
				for (pos1 = pPartFile->srclists[sl].GetHeadPosition(); (pos2 = pos1) != NULL; )
d710 1
a710 1
					pPartFile->srclists[sl].GetNext(pos1);
d712 1
a712 1
					CUpDownClient	*pTempSource = pPartFile->srclists[sl].GetAt(pos2);
d742 1
a742 1
	pSenderFile->srclists[pSource->sourcesslot].AddTail(pSource);
d784 1
a784 1
				if (sender->srclists[source->sourcesslot].Find(source)) 
d800 1
a800 1
	sender->srclists[source->sourcesslot].AddTail(source);
d825 1
a825 1
	if (cur_file != NULL && !cur_file->srclists[toremove->sourcesslot].IsEmpty())
d827 1
a827 1
		POSITION remove_pos = cur_file->srclists[toremove->sourcesslot].Find(toremove);
d831 1
a831 1
			cur_file->srclists[toremove->sourcesslot].RemoveAt(remove_pos);
d846 1
a846 1
				POSITION pos_A4AF = cur_file->A4AF_srclist.Find(toremove);
d849 1
a849 1
					cur_file->A4AF_srclist.RemoveAt(pos_A4AF);
d899 2
a900 2
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
			cur_file->srclists[sl].RemoveAll();
d1021 2
a1022 2
			if (!cur_file->srclists[sl].IsEmpty())
				for (pos1 = cur_file->srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d1024 2
a1025 2
					cur_file->srclists[sl].GetNext(pos1);
					cur_src = cur_file->srclists[sl].GetAt(pos2);
d1046 1
a1046 1
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
d1048 1
a1048 1
			for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0;)
d1050 1
a1050 1
				CUpDownClient* cur_client = cur_file->srclists[sl].GetNext(pos2);
@


1.115
log
@Code formatting and fixes for preallocation (statistics)
@
text
@d83 2
@


1.114
log
@Minor fixes and new log message
@
text
@d1101 2
a1102 1
			data[4] += ui32NeededSpace;
d1105 2
a1106 1
		data[6] += ui32NeededSpace;
@


1.113
log
@Preallocate feature and Localization fixes
@
text
@d431 1
a431 1
	strMessageText.Format(GetResString(IDS_NEWDOWNLOAD)+_T(" "),pNewPartFile->GetFileName());
@


1.112
log
@Formatting, comments, and name changes.
@
text
@d420 1
a420 1
		pNewPartFile->StopFile();
@


1.111
log
@Formatting, comments, and name changes.
@
text
@d628 1
a628 1
bool CDownloadQueue::IsInDLQueue(CKnownFile* totest)
d630 2
d634 2
a635 1
	POSITION pos = m_partFileList.Find(totest);
d637 1
a637 3
		return true;
	else
		return false;
d640 2
a641 2
	return false;
	
d644 1
a644 1
void CDownloadQueue::CheckAndAddSource(CPartFile* sender,CUpDownClient* source, bool saveSources)
d648 3
a650 2
	//	If we block loopbacks at this point it should prevent us from connecting to ourself
	if (!source->HasLowID() && (source->GetUserID() & 0xFF) == 0x7F)
d652 1
a652 1
		delete source;
d656 5
a660 2
	//(filtering invalid eMule clients)
	if (source->GetMuleVersion()==0 && source->GetVersion()==0 && (source->GetClientSoft()==SO_EMULE || source->GetClientSoft()==SO_OLDEMULE))
d662 1
a662 1
		delete source;
a664 2
	//end (filtering invalid eMule clients) //Mr Faber / netwolf

d666 3
a668 3
	// double check... just testing...
	// [Lord KiRon] v2
	if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), source->GetUserHash()) == 0)
d670 1
a670 1
		delete source;
a672 1
	// [/Lord KiRon] v2 
d674 5
a678 2
	//eklmn: if this part file is stopped or complete/completing no sources needed any more ()
	if (sender->GetStatus() == PS_STOPPED	|| sender->GetStatus() == PS_COMPLETE || sender->GetStatus() == PS_COMPLETING) 
d680 1
a680 1
		delete source;
d684 2
a685 2
	// eklmn: check if client has to be filtered
	if (g_eMuleApp.m_pIPFilter->IsFiltered(source->GetUserID()) && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled()) 
d687 2
a688 2
		AddDebugLogLine(false,_T("Filtered (reject as new source): %s %s"), source->GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
		delete source;
d692 2
a693 2
	// uses this only for temp. clients
	POSITION pos, pos1, pos2;
d695 1
d698 1
a698 1
		CPartFile* cur_file = m_partFileList.GetAt(pos);
d700 2
a701 1
		for (int sl=0;sl<SOURCESSLOTS;sl++) 
d703 1
a703 1
			if (!cur_file->srclists[sl].IsEmpty())
d705 2
a706 1
				for (pos1 = cur_file->srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;) 
d708 1
a708 1
					cur_file->srclists[sl].GetNext(pos1);
d710 1
a710 1
					CUpDownClient* temp_src = cur_file->srclists[sl].GetAt(pos2);
d712 2
a713 2
					// check if source already exists
					if (temp_src->Compare(source)) 
d715 2
a716 2
						// if we are adding another (different from current file) check in OtherFileList
						if (cur_file != sender)
d718 3
a720 3
							// check in other file list
							if (temp_src->AddRequestForAnotherFile(sender)) 
								g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(sender,temp_src,true);
d723 1
a723 1
						delete source;
d730 3
a732 3
	//our new source is real new but maybe it is already uploading to us?
	//if yes the known client will be attached to the var "source"
	//and the old sourceclient will be deleted
d734 2
a735 2
	if (g_eMuleApp.m_pClientList->AttachToAlreadyKnown(&source,0))
		source->reqfile = sender;
d738 1
a738 1
		g_eMuleApp.m_pClientList->AddClient(source,true);
d740 4
a743 5
	sender->srclists[source->sourcesslot].AddTail(source);
	sender->RemovePastComment(source);		// #zegzav:pastcomment
	source->StartQueueWaitTimer(); //<<-- enkeyDEV(Ottavio84) -Show download queue wait time-
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(sender,source,false);
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d748 1
a748 1

@


1.110
log
@Commented out frequently hit debug break. Please either add code to handle this error condition or fix the bug that causes it.
@
text
@d64 3
a66 3
	lastfile = 0;
	lastudpsearchtime = 0;
	lastudpstattime = 0;
d69 2
a70 2
	averageDataRate = 0;
	udcounter = 0;
d101 2
a102 1
void CDownloadQueue::UpdateDisplayedInfo(boolean force) {
a103 2
	if(!m_bIsInitialized) return;
    DWORD curTick = GetTickCount();
d105 7
a111 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
d113 1
a113 1
        m_lastRefreshedDLDisplay = curTick;
d117 1
a117 1

d121 7
a127 4
    for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos)){
		CPartFile* cur_file = m_partFileList.GetAt(pos);
		if (cur_file->GetStatus(true) == PS_READY)
			m_pSharedFileList->SafeAddKFile(cur_file,true);
d129 1
d132 4
d137 3
a139 5
void CDownloadQueue::CompDownDataRateOverhead(){
    EMULE_TRY
	m_AvarageDDRO_list.AddTail(m_nDownDataRateMSOverhead);
	if (m_AvarageDDRO_list.GetCount() > 150)
		m_AvarageDDRO_list.RemoveAt(m_AvarageDDRO_list.GetHeadPosition());
d143 2
a144 2
	for (POSITION pos = m_AvarageDDRO_list.GetHeadPosition();pos != 0;m_AvarageDDRO_list.GetNext(pos))
		m_nDownDataRateOverhead += m_AvarageDDRO_list.GetAt(pos);
d146 2
a147 2
	if(m_AvarageDDRO_list.GetCount() > 10)
		m_nDownDataRateOverhead = 10*m_nDownDataRateOverhead/m_AvarageDDRO_list.GetCount();
d150 1
a150 1
	return;
d269 1
a269 1
void CDownloadQueue::AddSearchToDownload(CSearchFile* toadd,uint8 cat)
d272 2
a273 2
	// Ultras: prevent to donload an empty file
	if(!toadd->GetFileSize()) 
d275 1
a275 1
		AddLogLine(true, IDS_SKIPZEROLENGTHFILE, toadd->GetFileName());
d278 1
a278 1
	if (IsFileExisting(toadd->GetFileHash()))
d280 4
a283 2
	CPartFile* newfile = new CPartFile(toadd);
	if (newfile->GetStatus() == PS_ERROR)
d285 1
a285 1
		delete newfile;
d288 10
a297 2
	newfile->SetCatID(cat);
	AddDownload(newfile);
d299 20
a318 17
	// netwolf 20.05.03 enhanced source finding (bluecow)
	// If the search result is from a client ('View Files') add that client as source
	if (toadd->GetType() == CSearchFile::Client && toadd->GetClientID() && toadd->GetClientPort())
	{
		CMemFile sources;
		uint16 uSources = 1;
		sources.Write(&uSources, sizeof uSources);
		uint32 uIP = toadd->GetClientID();
		sources.Write(&uIP, sizeof uIP);
		uint16 uPort = toadd->GetClientPort();
		sources.Write(&uPort, sizeof uPort);
		uIP = toadd->GetClientServerIP();
		sources.Write(&uIP, sizeof uIP);
		uPort = toadd->GetClientServerPort();
		sources.Write(&uPort, sizeof uPort);
		sources.SeekToBegin();
	if (newfile) newfile->AddClientSources(&sources);
d321 4
a324 3
			CPartFile* partfile = GetFileByID(toadd->GetFileHash());
				if (partfile)
					partfile->AddClientSources(&sources);
d331 4
d336 5
a340 5
void CDownloadQueue::AddSearchToDownload(CString link,uint8 cat){
    EMULE_TRY
	CPartFile* newfile = new CPartFile(link);
	if (newfile->GetStatus() == PS_ERROR){
		delete newfile;
d343 4
a346 3
	newfile->SetCatID(cat);
	AddDownload(newfile);
    EMULE_CATCH
d348 2
a349 2

void CDownloadQueue::AddFileLinkToDownload(CED2KFileLink* pLink,uint8 cat)
d352 7
a358 4
	CPartFile* newfile = new CPartFile(pLink);
	if (newfile->GetStatus() == PS_ERROR){
		delete newfile;
		newfile=NULL;
d360 4
a363 3
	else {
		newfile->SetCatID(cat);
		AddDownload(newfile);
d365 2
a366 2
	// START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
	if(pLink->HasValidSources())
d368 1
a368 1
		if (newfile)
d371 1
a371 1
				newfile->AddClientSources(pLink->ClientSourcesList); //add all IP source and eliminates them from list
d375 4
a378 2
			CPartFile* partfile = GetFileByID((uchar*)pLink->GetHashKey());
			if (partfile && pLink->ClientSourcesList) partfile->AddClientSources(pLink->ClientSourcesList); //add all IP source and eliminates them from list
d381 2
a382 2
	// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
    EMULE_CATCH
d384 3
a386 5

//in the official they renamed this funcion StartNextFile()
// Added by Tarod
// Starts a paused download (takes in account priority)
void CDownloadQueue::StartPausedDownload(int cat)
d390 3
a392 3
	CPartFile* cur_file;
	CPartFile* file_to_start = NULL;
	POSITION pos;
d396 1
a396 1
		cur_file = (CPartFile*)m_partFileList.GetAt(pos);
d398 1
a398 1
		if (cur_file->GetStatus() == PS_PAUSED && CCat::FileBelongsToGivenCat(cur_file,cat))
d400 3
a402 2
			if (file_to_start ==NULL || file_to_start->GetPriority() < cur_file->GetPriority())
				file_to_start = cur_file;
d406 2
a407 2
	if (file_to_start != NULL)
		file_to_start->ResumeFile() ;
d411 2
a412 2

void CDownloadQueue::AddDownload(CPartFile* newfile)
d416 1
a416 1
	m_partFileList.AddTail(newfile);
d418 4
a421 3
	if (g_eMuleApp.m_pGlobPrefs->StartDownloadPaused()) {
		newfile->StopFile();
		newfile->SetStartTimeReset(true);	//SyruS enable reset on resume
d424 12
a435 9
	SetAutoCat(newfile);// HoaX_69 / Slugfiller: AutoCat

	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddFile(newfile);
	AddLogLine(true,IDS_NEWDOWNLOAD,newfile->GetFileName());
	// Purity - Sending message when download added
	CString MessageText;
	MessageText.Format(GetResString(IDS_NEWDOWNLOAD)+_T(" "),newfile->GetFileName());
	g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseDownloadAddNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
	g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_DLOAD_ADD, false, g_eMuleApp.m_pGlobPrefs->GetUseDownloadAddNotifier());
d438 4
a442 2
bool CDownloadQueue::IsFileExisting(const uchar* fileid)
{
d444 5
a448 3
	if (CKnownFile* file = m_pSharedFileList->GetFileByID((uchar*)fileid)){
		if (file->IsPartFile())
			AddLogLine(true, IDS_ERR_ALREADY_DOWNLOADING, file->GetFileName());
d450 2
a451 2
			AddLogLine(true, IDS_ERR_ALREADY_DOWNLOADED, file->GetFileName());
		return true;
d453 4
a456 3
	else if ( file = GetFileByID((uchar*)fileid)){
		AddLogLine(true, IDS_ERR_ALREADY_DOWNLOADING, file->GetFileName());
		return true;
d458 1
d460 2
a461 1
	return false;
d463 1
a463 2


d467 33
a499 20
	if(!m_bIsInitialized) return;
	uint32 downspeed = 0;
	uint16 max_DL_speed = m_pPrefs->GetMaxDownload();
	uint32 max_DL_speed_kB = max_DL_speed*1024;
	if ( max_DL_speed != UNLIMITED && m_iDataRate > 1500 /*&& max_DL_speed_kB>m_iDataRate*/) {
		downspeed = (max_DL_speed_kB*100)/(m_iDataRate+1); //(uint16)((float)((float)(m_pPrefs->GetMaxDownload()*1024)/(m_iDataRate+1)) * 100);
		if (downspeed < 50)
			downspeed = 50;
		// eklmn: don't remove upper DL limit, otherwise on DL will block all other
		else if (downspeed > 200)
			downspeed = 200;
	}

	//static uint32 iteration=0;
	uint32 tempDataRate = 0;
	udcounter++;
	for (POSITION pos =m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos)){
		CPartFile* cur_file =  m_partFileList.GetAt(pos);
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) 
			&&(cur_file->GetPriority() == PR_HIGH || cur_file->GetPriority() == PR_AUTO))	//jicxicmic fix
d501 1
a501 1
			tempDataRate += cur_file->Process(downspeed, udcounter /*iteration*/);
d504 9
a512 4
	for (POSITION pos =m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos)){
		CPartFile* cur_file =  m_partFileList.GetAt(pos);
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) && cur_file->GetPriority() == PR_NORMAL){
			tempDataRate += cur_file->Process(downspeed, udcounter /*iteration*/);
d515 9
a523 4
	for (POSITION pos =m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos)){
		CPartFile* cur_file =  m_partFileList.GetAt(pos);
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) && cur_file->GetPriority() == PR_LOW){
			tempDataRate += cur_file->Process(downspeed, udcounter /*iteration*/); 
d527 3
a529 1
	//if(++iteration>15) iteration=0;
d531 2
a532 5
	m_iDataRate = tempDataRate;
	DWORD curTick = GetTickCount();
	// Save used bandwidth for speed calculations
	//avarage_dr_list.AddTail(usedBandwidthThisCall);
	if(m_averageTickList.empty() || curTick - m_averageTickList.front()>= 500)	//Cax2 - update no faster than every .5 sec
d536 2
a537 2
		// Save time beetween each speed snapshot
		m_averageTickList.push_front(curTick);
d539 3
a541 2
		//Cax2 save 40 secs of data. It seems to give the most accurate result atm...
		while(curTick-m_averageTickList.back() > 40000) {
d547 3
a549 3
	// Calculate average data rate
	if(m_averageDataRateList.size() >1) 
		averageDataRate = (uint32)(((float)(m_averageDataRateList.front()-m_averageDataRateList.back()))*1000 / (m_averageTickList.front()-m_averageTickList.back()));
d551 1
a551 1
		averageDataRate = 0;
d553 6
a558 4
	curTick = GetTickCount();	//Cax2 - Refresh the variable
	if (udcounter == 5){
		if((!lastudpstattime) || (curTick - lastudpstattime) > UDPSERVERSTATTIME){
			lastudpstattime = curTick;
d562 4
a565 3
	if (udcounter == 10){
		udcounter = 0;
		if ((!lastudpsearchtime) || (curTick - lastudpsearchtime) > UDPSERVERREASKTIME)
a568 1

d571 1
a571 1
	if(m_lastPartFileStatsSave+300000 < curTick )
d573 1
a573 1
		m_lastPartFileStatsSave=curTick;
d580 2
a581 2

void	CDownloadQueue::SaveAllPartFileStats()
d584 2
a585 1
	for (POSITION pos =m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos))
d587 3
a589 2
		CPartFile* cur_file =  m_partFileList.GetAt(pos);
		cur_file->SavePartFileStats();
d591 1
d594 5
a599 3
CPartFile*	CDownloadQueue::GetFileByIndex(int index)
{
	POSITION pos = m_partFileList.FindIndex(index);
d605 6
a611 2
CPartFile*	CDownloadQueue::GetFileByID(const uchar* filehash)
{
d613 8
a620 3
	for (POSITION pos = m_partFileList.GetHeadPosition();pos != 0;m_partFileList.GetNext(pos)){
		if (!md4cmp(filehash,m_partFileList.GetAt(pos)->GetFileHash()))
			return m_partFileList.GetAt(pos);
d622 1
d624 2
a625 1
	return 0;
d627 2
a628 2

bool CDownloadQueue::IsPartFile(void* totest)
d642 1
a642 1

d766 1
a766 1
	if (IsPartFile(sender))
d835 1
a835 1
			if(IsPartFile(cur_file))
d916 1
a916 1
		if (lastfile == 0){
d919 1
a919 1
			lastfile = nextfile;
d922 1
a922 1
			POSITION pos = m_partFileList.Find(lastfile);
d927 1
a927 1
				lastfile = nextfile;
d936 2
a937 2
						lastudpsearchtime = ::GetTickCount();
						lastfile = 0;
d944 1
a944 1
					lastfile = nextfile;
d949 1
a949 1
					lastfile = nextfile;
d972 2
a973 2
	lastudpsearchtime = ::GetTickCount();
	lastfile = 0;
d1257 1
a1257 1
	if(lastfile)
d1265 1
a1265 1
		if(lastudpsearchtime)
d1267 1
a1267 1
				CastSecondsToHM((UDPSERVERREASKTIME - (GetTickCount() - lastudpsearchtime))/1000));
@


1.109
log
@Fixed category related code.
@
text
@d691 2
a692 2
				else 
					DEBUG_ONLY(AfxDebugBreak());
@


1.108
log
@Customization for Scan Filter.
Fix for preferences toolbar button (take care when you do code renaming to keep the correct values)
@
text
@d1209 2
a1210 2

void CDownloadQueue::ResetCatParts(int cat)
d1214 2
a1215 1
	for(POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d1218 1
a1218 1
	for(POSITION pos = locallist.GetHeadPosition(); pos != 0; locallist.GetNext(pos))
d1220 3
a1222 2
		CPartFile* cur_file = locallist.GetAt(pos);
		if(cur_file->GetCatID() == cat) 
a1223 2
		else if(cur_file->GetCatID() > cat) 
			cur_file->SetCatID(cur_file->GetCatID()-1);
d1226 2
a1227 2

void CDownloadQueue::SetCatPrio(int cat, uint8 newprio)
d1230 3
a1232 2
	CTypedPtrList<CPtrList, CPartFile*> locallist;
	for(POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
d1235 1
a1235 1
	for(POSITION pos = locallist.GetHeadPosition(); pos != 0; locallist.GetNext(pos))
d1237 3
a1239 2
		CPartFile* cur_file = locallist.GetAt(pos);
		if(cat == 0 || cur_file->GetCatID() == cat)
d1241 1
a1241 1
			if(newprio==PR_AUTO) 
d1254 2
a1255 2

void CDownloadQueue::SetCatStatus(int cat, int newstatus)
d1260 1
a1260 1
	while(pos != 0) 
d1264 1
a1264 1
		if(!cur_file) 
d1267 3
a1269 4
	//	TODO: Adjust for status tabs
		if(cat == -1 || (cat == -2 && cur_file->GetCatID() == 0) ||
			(cat == 0 && CCat::FileBelongsToGivenCat(cur_file,cat))
			 || (cat > 0 && cat == cur_file->GetCatID()))
d1271 1
a1271 1
			switch(newstatus) 
d1297 2
a1298 3

#ifdef OLD // MOREVIT: Unnecessary
void CDownloadQueue::MoveCat(uint8 from, uint8 to)
d1300 1
a1300 12
	//DonGato: fix because of list update in SetCatID :S
	CTypedPtrList<CPtrList, CPartFile*> locallist;
	for(POSITION pos = m_partFileList.GetHeadPosition(); pos != 0; m_partFileList.GetNext(pos))
		locallist.AddTail(m_partFileList.GetAt(pos));

	if(from < to) 
		--to;

	uint8 mycat;

	POSITION pos = locallist.GetHeadPosition();
	for(POSITION pos = locallist.GetHeadPosition(); pos != 0; locallist.GetNext(pos))
d1302 4
a1305 1
		CPartFile* cur_file =  locallist.GetAt(pos);
a1306 31
		if(!cur_file) 
			continue;

		mycat = cur_file->GetCatID();
		if(mycat >= min(from,to) && mycat <= max(from,to)) 
		{
			if(mycat == from) 
			{	
				cur_file->SetCatID(to); 
			}
			else 
			{
				if(from < to) 
					cur_file->SetCatID(mycat-1);
				else 
					cur_file->SetCatID(mycat+1);
			}
		}
	}
}
#endif OLD
// :MOREVIT

void CDownloadQueue::SetAutoCat(CPartFile* newfile)
{
	if(CCat::GetNumCats()>1)
	{
		for (int ix=1;ix<CCat::GetNumCats();ix++)
		{	
			int curPos = 0;
			CString catExt = CCat::GetCatByIndex(ix)->GetAutoCatExt();
d1313 2
a1314 1
			CString fullname = newfile->GetFileName();
d1316 2
a1317 1
			CString cmpExt = catExt.Tokenize("|", curPos);
d1323 1
a1323 1
				if(cmpExt.Find(CString("*")) != -1 || cmpExt.Find(CString("?")) != -1)
d1328 1
a1328 1
					if(PathMatchSpec(file, spec))
d1330 1
a1330 1
						newfile->SetCatID(ix);
d1336 1
a1336 1
						newfile->SetCatID(ix);
d1345 1
@


1.107
log
@Formatting, comments, and name changes.
@
text
@d594 1
a594 1
	if (g_eMuleApp.m_pIPFilter->IsFiltered(source->GetUserID())) 
@


1.106
log
@Formatting, comments, and name changes.
@
text
@a31 4
CHostnameSourceWnd::CHostnameSourceWnd(){
	m_pOwner = NULL;
}

d37 9
a45 1
LRESULT CHostnameSourceWnd::OnSourceHostnameResolved(WPARAM wParam,LPARAM lParam) {
d48 1
d51 2
d55 8
a62 5
CDownloadQueue::CDownloadQueue(CPreferences* in_prefs,CSharedFileList* in_sharedfilelist){
	m_pPrefs = in_prefs;
	sharedfilelist = in_sharedfilelist;
	filesrdy = 0;
	dataRate = 0;
d84 7
d92 9
d116 2
a117 2
    for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file = filelist.GetAt(pos);
d119 1
a119 1
			sharedfilelist->SafeAddKFile(cur_file,true);
d142 1
a142 3



d147 8
a154 6
	// find all part files, read & hash them if needed and store into a list
	// start changed by InterCeptor (multiple tempdirs) 19.11.02
	uint16 count = 0;
	CString sTempDir = m_pPrefs->GetTempDir();
	bool bRemove = false;
	if(m_pPrefs->m_tempDirList.Find(sTempDir) == NULL && m_pPrefs->m_tempDirList.Find(sTempDir+'\\') == NULL)
d156 2
a157 1
		m_pPrefs->m_tempDirList.AddHead(sTempDir);
d160 2
a161 1
	for (POSITION pos = m_pPrefs->m_tempDirList.GetHeadPosition();pos != 0;m_pPrefs->m_tempDirList.GetNext(pos))
d163 11
a173 7
		CFileFind ff;
		CString searchPath(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer());
		searchPath += "\\*.part.met";

		//check all part.met files
		bool end = !ff.FindFile(searchPath,0);
		while (!end)
d175 2
a176 1
			end = !ff.FindNextFile();
d179 5
a183 2
			CPartFile* toadd = new CPartFile();
			if (toadd->LoadPartFile(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d185 10
a194 9
				count++;
				// Added by Tarod -check if is an A4AF auto file, correct place?
				if (md4cmp(toadd->GetFileHash(), g_eMuleApp.m_pGlobPrefs->GetA4AFHash()) == 0)
					// v1:- eklmn: A4AF mangement
					g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(toadd);
				filelist.AddTail(toadd); // to download queue
				if (toadd->GetStatus(true) == PS_READY)
					sharedfilelist->SafeAddKFile(toadd); // part files are always shared files
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddFile(toadd);// show in downloadwindow
d197 3
a199 1
				delete toadd;
d203 6
a208 5
		//try recovering any part.met files
		searchPath += ".backup";
		end = !ff.FindFile(searchPath, 0);
		while (!end){
			end = !ff.FindNextFile();
d211 4
a214 2
			CPartFile* toadd = new CPartFile();
			if (toadd->LoadPartFile(m_pPrefs->m_tempDirList.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d216 6
a221 6
				toadd->SavePartFile(); // resave backup
				count++;
				filelist.AddTail(toadd);			// to download queue
				if (toadd->GetStatus(true) == PS_READY)
					sharedfilelist->SafeAddKFile(toadd); // part files are always shared files
				g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddFile(toadd);// show in downloadwindow
d223 1
a223 1
				AddLogLine(false, IDS_RECOVERED_PARTMET, toadd->GetFileName());
d227 1
a227 1
				delete toadd;
d232 2
a233 1
	if(bRemove)
d235 3
a237 2
	// end added by InterCeptor (multiple tempdirs) 19.11.02
	if(count == 0) {
d239 4
a242 2
	} else {
		AddLogLine(false,IDS_FOUNDPARTS,count);
d246 5
a250 5
	//--- xrmb:keepPartFileStats ---
	m_lastPartFileStatsSave=GetTickCount();
	//--- :xrmb ---
	// START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
	hsCallbackWnd=NULL; 
d252 2
a253 2
	isResolving=false;
	// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d257 1
a257 15

CDownloadQueue::~CDownloadQueue(){
    EMULE_TRY
	//--- xrmb:keepPartFileStats ---
	SaveAllPartFileStats();
	//--- :xrmb ---

	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		filelist.GetAt(pos)->m_hPartFile.Flush() ; // Flush before close app [Tarod]
		filelist.GetAt(pos)->SavePartFile();
		delete filelist.GetAt(pos);
	}
    EMULE_CATCH
}

d360 1
a360 1
	for (pos = filelist.GetHeadPosition(); pos != (POSITION)NULL; filelist.GetNext(pos))
d362 1
a362 1
		cur_file = (CPartFile*)filelist.GetAt(pos);
d381 1
a381 1
	filelist.AddTail(newfile);
d403 1
a403 1
	if (CKnownFile* file = sharedfilelist->GetFileByID((uchar*)fileid)){
d426 2
a427 2
	if ( max_DL_speed != UNLIMITED && dataRate > 1500 /*&& max_DL_speed_kB>dataRate*/) {
		downspeed = (max_DL_speed_kB*100)/(dataRate+1); //(uint16)((float)((float)(m_pPrefs->GetMaxDownload()*1024)/(dataRate+1)) * 100);
d438 2
a439 2
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file =  filelist.GetAt(pos);
d446 2
a447 2
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file =  filelist.GetAt(pos);
d452 2
a453 2
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file =  filelist.GetAt(pos);
d461 1
a461 1
	dataRate = tempDataRate;
d465 1
a465 1
	if(average_tick_list.empty() || curTick - average_tick_list.front()>= 500)	//Cax2 - update no faster than every .5 sec
d467 1
a467 1
		average_dr_list.push_front(g_eMuleApp.stat_sessionReceivedBytes);
d470 1
a470 1
		average_tick_list.push_front(curTick);
d473 3
a475 3
		while(curTick-average_tick_list.back() > 40000) {
   			average_dr_list.pop_back();
			average_tick_list.pop_back();
d479 3
a481 3
	// Calculate average dataRate
	if(average_dr_list.size() >1) 
		averageDataRate = (uint32)(((float)(average_dr_list.front()-average_dr_list.back()))*1000 / (average_tick_list.front()-average_tick_list.back()));
d514 1
a514 1
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos))
d516 1
a516 1
		CPartFile* cur_file =  filelist.GetAt(pos);
d524 1
a524 1
	POSITION pos = filelist.FindIndex(index);
d526 1
a526 1
		return filelist.GetAt(pos);
d534 3
a536 3
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		if (!md4cmp(filehash,filelist.GetAt(pos)->GetFileHash()))
			return filelist.GetAt(pos);
d546 1
a546 1
	POSITION pos = filelist.Find(totest);
d604 1
a604 1
	for (pos = filelist.GetHeadPosition(); pos != 0; filelist.GetNext(pos))
d606 1
a606 1
		CPartFile* cur_file = filelist.GetAt(pos);
d779 1
a779 1
	POSITION remove_pos = filelist.Find(toremove);
d781 1
a781 1
		filelist.RemoveAt(remove_pos);
d788 1
a788 1
	for(POSITION pos = filelist.GetHeadPosition(); pos != NULL;filelist.GetNext(pos))
d790 1
a790 1
		CPartFile* cur_file = filelist.GetAt(pos); 
d802 2
a803 2
	for (pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file = filelist.GetAt(pos);
d819 1
a819 1
	if (filelist.IsEmpty() || !g_eMuleApp.m_pServerConnect->IsConnected())
d831 1
a831 1
			nextfile = filelist.GetHead();
d836 1
a836 1
			POSITION pos = filelist.Find(lastfile);
d839 1
a839 1
				nextfile = filelist.GetHead();
d844 1
a844 1
				filelist.GetNext(pos);
d856 1
a856 1
					nextfile = filelist.GetHead();
d861 1
a861 1
					nextfile = filelist.GetAt(pos);
d896 3
a898 3
	for( pos1 = filelist.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
	   filelist.GetNext(pos1);
	   CPartFile* cur_file = filelist.GetAt(pos2);
d900 2
a901 2
		   filelist.AddHead(cur_file);
		   filelist.RemoveAt(pos2);
d904 2
a905 2
		   filelist.AddTail(cur_file);
		   filelist.RemoveAt(pos2);
d908 1
a908 1
	   if (i == filelist.GetCount())
d922 1
a922 1
	for (pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos))
d924 1
a924 1
		cur_file = filelist.GetAt(pos);
d948 1
a948 1
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;)
d950 1
a950 1
		cur_file = filelist.GetNext(pos);
d975 1
a975 1
	for (POSITION pos = filelist.GetHeadPosition();pos != 0; filelist.GetNext(pos))
d977 1
a977 1
		CPartFile* cur_file =  filelist.GetAt(pos);
d1023 1
a1023 1
	for(POSITION pos = filelist.GetHeadPosition(); pos != 0; filelist.GetNext(pos))
d1025 1
a1025 1
		CPartFile* cur_file = filelist.GetAt(pos);
d1038 2
a1039 2
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;){
		CPartFile* cur_file = filelist.GetNext(pos);
d1056 1
a1056 1
	if (isResolving) {
d1065 1
a1065 1
	isResolving = true;
d1069 3
a1071 3
			if (hsCallbackWnd) {
				delete hsCallbackWnd; //free unneccessary window
				hsCallbackWnd=NULL;
d1073 1
a1073 1
			isResolving=false;
d1086 4
a1089 4
	if (!hsCallbackWnd) {
		hsCallbackWnd=new CHostnameSourceWnd();
		VERIFY( hsCallbackWnd->CreateEx(0, AfxRegisterWndClass(0),_T("Emule DNS Source Socket Wnd"),WS_OVERLAPPED, 0, 0, 0, 0, NULL, NULL));
		hsCallbackWnd->m_pOwner = this;
d1095 1
a1095 1
	RetValue=WSAAsyncGetHostByName(hsCallbackWnd->m_hWnd, TM_SOURCEHOSTNAMERESOLVED, 
d1104 3
a1106 3
			if (hsCallbackWnd) {
				delete hsCallbackWnd;
				hsCallbackWnd=NULL;
d1109 1
a1109 1
			isResolving=false;
d1132 2
a1133 2
		delete hsCallbackWnd;
		hsCallbackWnd=NULL;
d1166 1
a1166 1
	if (filelist.IsEmpty() || !g_eMuleApp.m_pServerConnect->IsConnected())
d1174 1
a1174 1
			m_nUDPSearchFile, filelist.GetCount(),
d1214 2
a1215 2
	for(POSITION pos = filelist.GetHeadPosition(); pos != 0; filelist.GetNext(pos))
		locallist.AddTail(filelist.GetAt(pos));
d1231 2
a1232 2
	for(POSITION pos = filelist.GetHeadPosition(); pos != 0; filelist.GetNext(pos))
		locallist.AddTail(filelist.GetAt(pos));
d1257 1
a1257 1
	POSITION pos = filelist.GetHeadPosition();
d1260 1
a1260 1
		CPartFile* cur_file = filelist.GetAt(pos);
d1288 1
a1288 1
		filelist.GetNext(pos);
d1292 1
a1292 1
			pos = filelist.GetHeadPosition();
d1302 2
a1303 2
	for(POSITION pos = filelist.GetHeadPosition(); pos != 0; filelist.GetNext(pos))
		locallist.AddTail(filelist.GetAt(pos));
@


1.105
log
@Category rewrite with predefined status/media type categories.
@
text
@d601 1
a601 1
	}
@


1.104
log
@1)added filtering by source exchange
2) speed optimization in Check&AddKnownSources
@
text
@d154 1
a154 1
				filelist.AddTail(toadd); // to m_pDownloadQueue
d176 1
a176 1
				filelist.AddTail(toadd);			// to m_pDownloadQueue
d243 1
a243 1
	newfile->SetCategory(cat);
d282 1
a282 1
	newfile->SetCategory(cat);
d296 1
a296 1
		newfile->SetCategory(cat);
d332 1
a332 2
		if (cur_file->GetStatus() == PS_PAUSED && (cur_file->GetCategory()==cat ||
			(cat==0 && g_eMuleApp.m_pGlobPrefs->GetAllcatType()==0 && cur_file->GetCategory()>0)))
d490 2
a491 1
CPartFile*	CDownloadQueue::GetFileByIndex(int index){
d528 4
a531 2
	// if we block loopbacks at this point it should prevent us from connecting to ourself
	if(!source->HasLowID() && (source->GetUserID() & 0xFF) == 0x7F) {
d537 2
a538 1
	if(source->GetMuleVersion()==0 && source->GetVersion()==0 && (source->GetClientSoft()==SO_EMULE || source->GetClientSoft()==SO_OLDEMULE)) {
d571 3
a573 1
	for (pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
d575 1
d577 1
d579 1
d583 1
d585 2
a586 1
					// check if souce is already exist
d590 2
a591 1
						if (cur_file != sender){ 
d602 2
d1180 1
a1180 1
	//DonGato: fix because of list update in SetCategory :S
d1188 4
a1191 4
		if(cur_file->GetCategory() == cat) 
			cur_file->SetCategory(0);
		else if(cur_file->GetCategory() > cat) 
			cur_file->SetCategory(cur_file->GetCategory()-1);
d1197 1
a1197 1
	//DonGato: fix because of list update in SetCategory :S
d1205 1
a1205 1
		if(cat == 0 || cur_file->GetCategory() == cat)
d1233 4
a1236 3
		if(cat == -1 || (cat == -2 && cur_file->GetCategory() == 0) ||
			(cat == 0 && CheckShowItemInGivenCat(cur_file,cat))
			 || (cat > 0 && cat == cur_file->GetCategory()))
d1265 1
d1268 1
a1268 1
	//DonGato: fix because of list update in SetCategory :S
d1286 1
a1286 1
		mycat = cur_file->GetCategory();
d1291 1
a1291 1
				cur_file->SetCategory(to); 
d1296 1
a1296 1
					cur_file->SetCategory(mycat-1);
d1298 1
a1298 1
					cur_file->SetCategory(mycat+1);
d1303 2
d1308 1
a1308 1
	if(g_eMuleApp.m_pGlobPrefs->GetCatCount()>1)
d1310 1
a1310 1
		for (int ix=1;ix<g_eMuleApp.m_pGlobPrefs->GetCatCount();ix++)
d1313 1
a1313 1
			CString catExt = g_eMuleApp.m_pGlobPrefs->GetCategory(ix)->autocat;
d1335 1
a1335 1
						newfile->SetCategory(ix);
d1341 1
a1341 1
						newfile->SetCategory(ix);
@


1.103
log
@Formatting, comments, and name changes.
@
text
@d558 8
d633 21
a653 11
	// v-eklmn: bugfix(09): hang up by start if all files are paused
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file = filelist.GetAt(pos);
		for (int sl=0;sl<SOURCESSLOTS;sl++){ 
			if (!cur_file->srclists[sl].IsEmpty()) {
				if (cur_file->srclists[sl].Find(source)) {
					if (cur_file == sender) return TRUE; // [Lord KiRon] v3
					if (source->AddRequestForAnotherFile(sender))
						g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.AddSource(sender,source,true);
					return TRUE;
				}
d657 1
a657 1
	// ^-eklmn: bugfix(09): hang up by start if all files are paused
@


1.102
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d49 1
a49 1
	app_prefs = in_prefs;
d126 1
a126 1
	CString sTempDir = app_prefs->GetTempDir();
d128 1
a128 1
	if(app_prefs->m_tempDirList.Find(sTempDir) == NULL && app_prefs->m_tempDirList.Find(sTempDir+'\\') == NULL)
d130 1
a130 1
		app_prefs->m_tempDirList.AddHead(sTempDir);
d133 1
a133 1
	for (POSITION pos = app_prefs->m_tempDirList.GetHeadPosition();pos != 0;app_prefs->m_tempDirList.GetNext(pos))
d136 1
a136 1
		CString searchPath(app_prefs->m_tempDirList.GetAt(pos).GetBuffer());
d147 1
a147 1
			if (toadd->LoadPartFile(app_prefs->m_tempDirList.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d172 1
a172 1
			if (toadd->LoadPartFile(app_prefs->m_tempDirList.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d191 1
a191 1
		app_prefs->m_tempDirList.RemoveHead();
d393 1
a393 1
	uint16 max_DL_speed = app_prefs->GetMaxDownload();
d396 1
a396 1
		downspeed = (max_DL_speed_kB*100)/(dataRate+1); //(uint16)((float)((float)(app_prefs->GetMaxDownload()*1024)/(dataRate+1)) * 100);
@


1.101
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d128 1
a128 1
	if(app_prefs->tempdir_list.Find(sTempDir) == NULL && app_prefs->tempdir_list.Find(sTempDir+'\\') == NULL)
d130 1
a130 1
		app_prefs->tempdir_list.AddHead(sTempDir);
d133 1
a133 1
	for (POSITION pos = app_prefs->tempdir_list.GetHeadPosition();pos != 0;app_prefs->tempdir_list.GetNext(pos))
d136 1
a136 1
		CString searchPath(app_prefs->tempdir_list.GetAt(pos).GetBuffer());
d147 1
a147 1
			if (toadd->LoadPartFile(app_prefs->tempdir_list.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d172 1
a172 1
			if (toadd->LoadPartFile(app_prefs->tempdir_list.GetAt(pos).GetBuffer(),ff.GetFileName().GetBuffer()))
d191 1
a191 1
		app_prefs->tempdir_list.RemoveHead();
@


1.100
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d1078 1
a1078 5
	#ifndef AMD
	memcpy(lphost, hostentBuffer, iBufLen);
	#else
	memcpy_amd(lphost, hostentBuffer, iBufLen);
	#endif
@


1.99
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d18 1
a18 1
#include "downloadqueue.h"
d81 1
a81 1
        theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d151 1
a151 1
				if (md4cmp(toadd->GetFileHash(), theApp.glob_prefs->GetA4AFHash()) == 0)
d153 2
a154 2
					theApp.downloadqueue->SetA4AFAutoFile(toadd);
				filelist.AddTail(toadd); // to downloadqueue
d157 1
a157 1
				theApp.emuledlg->transferwnd.m_wndDownloadList.AddFile(toadd);// show in downloadwindow
d176 1
a176 1
				filelist.AddTail(toadd);			// to downloadqueue
d179 1
a179 1
				theApp.emuledlg->transferwnd.m_wndDownloadList.AddFile(toadd);// show in downloadwindow
d333 1
a333 1
			(cat==0 && theApp.glob_prefs->GetAllcatType()==0 && cur_file->GetCategory()>0)))
d352 1
a352 1
	if (theApp.glob_prefs->StartDownloadPaused()) {
d359 1
a359 1
	theApp.emuledlg->transferwnd.m_wndDownloadList.AddFile(newfile);
d364 2
a365 2
	theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetUseDownloadAddNotifier(), theApp.glob_prefs->IsSMTPInfoEnabled());
	theApp.emuledlg->ShowNotifier(MessageText, TBN_DLOAD_ADD, false, theApp.glob_prefs->GetUseDownloadAddNotifier());
d436 1
a436 1
		average_dr_list.push_front(theApp.stat_sessionReceivedBytes);
d458 1
a458 1
			theApp.serverlist->ServerStats();
d544 1
a544 1
	if (md4cmp(theApp.glob_prefs->GetUserHash(), source->GetUserHash()) == 0)
d575 1
a575 1
								theApp.emuledlg->transferwnd.m_wndDownloadList.AddSource(sender,temp_src,true);
d587 1
a587 1
	if (theApp.clientlist->AttachToAlreadyKnown(&source,0))
d591 1
a591 1
		theApp.clientlist->AddClient(source,true);
d596 2
a597 2
	theApp.emuledlg->transferwnd.m_wndDownloadList.AddSource(sender,source,false);
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d617 1
a617 1
   	if (md4cmp(theApp.glob_prefs->GetUserHash(), source->GetUserHash()) == 0) 
d633 1
a633 1
						theApp.emuledlg->transferwnd.m_wndDownloadList.AddSource(sender,source,true);
d645 1
a645 1
	theApp.emuledlg->transferwnd.m_wndDownloadList.AddSource(sender,source,false);
d680 1
a680 1
	//eklmn: now remove client in A4AF files. let's use "m_OtherRequests_list" for this goal
d698 1
a698 1
		theApp.emuledlg->transferwnd.m_wndDownloadList.RemoveSource(toremove,NULL);	
d756 1
a756 1
	if (filelist.IsEmpty() || !theApp.serverconnect->IsConnected())
d759 1
a759 1
		if (!(cur_udpserver = theApp.serverlist->GetNextServer(cur_udpserver))){
d783 1
a783 1
					cur_udpserver = theApp.serverlist->GetNextServer(cur_udpserver);
d805 1
a805 1
	if( (theApp.glob_prefs->GetMaxSourcePerFileUDP()) < nextfile->GetSourceCount()) //<<--
d809 3
a811 3
	if (cur_udpserver != theApp.serverlist->GetServerByAddress(theApp.serverconnect->GetCurrentServer()->GetAddress(),theApp.serverconnect->GetCurrentServer()->GetPort())){
		theApp.uploadqueue->AddUpDataOverheadServer(packet.size);
		theApp.serverconnect->SendUDPPacket(&packet,cur_udpserver,false);
d1107 1
a1107 1
	if (filelist.IsEmpty() || !theApp.serverconnect->IsConnected())
d1116 1
a1116 1
			m_nUDPSearchServer, theApp.serverlist->GetServerCount());
d1139 1
a1139 1
		theApp.glob_prefs->SetA4AFHash(file->GetFileHash());
d1144 1
a1144 1
		theApp.glob_prefs->SetA4AFHash(null_hash);
d1277 1
a1277 1
	if(theApp.glob_prefs->GetCatCount()>1)
d1279 1
a1279 1
		for (int ix=1;ix<theApp.glob_prefs->GetCatCount();ix++)
d1282 1
a1282 1
			CString catExt = theApp.glob_prefs->GetCategory(ix)->autocat;
@


1.98
log
@Simplify
@
text
@d52 1
a52 1
	datarate = 0;
d59 1
a59 1
	averageDatarate = 0;
d62 1
a62 1
	m_nDownDatarateOverhead = 0;
d98 1
a98 1
void CDownloadQueue::CompDownDatarateOverhead(){
d104 1
a104 1
	m_nDownDatarateOverhead = 0;
d107 1
a107 1
		m_nDownDatarateOverhead += m_AvarageDDRO_list.GetAt(pos);
d110 1
a110 1
		m_nDownDatarateOverhead = 10*m_nDownDatarateOverhead/m_AvarageDDRO_list.GetCount();
d112 1
a112 1
		m_nDownDatarateOverhead = 0;
d219 1
a219 1
		filelist.GetAt(pos)->m_hpartfile.Flush() ; // Flush before close app [Tarod]
d395 2
a396 2
	if ( max_DL_speed != UNLIMITED && datarate > 1500 /*&& max_DL_speed_kB>datarate*/) {
		downspeed = (max_DL_speed_kB*100)/(datarate+1); //(uint16)((float)((float)(app_prefs->GetMaxDownload()*1024)/(datarate+1)) * 100);
d405 1
a405 1
	uint32 tempDatarate = 0;
d412 1
a412 1
			tempDatarate += cur_file->Process(downspeed, udcounter /*iteration*/);
d418 1
a418 1
			tempDatarate += cur_file->Process(downspeed, udcounter /*iteration*/);
d424 1
a424 1
			tempDatarate += cur_file->Process(downspeed, udcounter /*iteration*/); 
d430 1
a430 1
	datarate = tempDatarate;
d448 1
a448 1
	// Calculate average datarate
d450 1
a450 1
		averageDatarate = (uint32)(((float)(average_dr_list.front()-average_dr_list.back()))*1000 / (average_tick_list.front()-average_tick_list.back()));
d452 1
a452 1
		averageDatarate = 0;
d916 1
a916 1
		sources[1]+=cur_file->GetTransferingSrcCount();
d956 1
a956 1
int CDownloadQueue::GetTransferingFiles()
d963 1
a963 1
		if(cur_file->GetTransferingSrcCount() > 0)
@


1.97
log
@Fix
@
text
@d686 1
a686 1
			if(theApp.downloadqueue->IsPartFile(cur_file))
@


1.96
log
@More fixes (sharing of files, JS used with downloading files and other minor ones)
@
text
@d686 1
a686 2
			POSITION pos_A4AF = cur_file->A4AF_srclist.Find(toremove);
			if (pos_A4AF) 
d688 5
a692 1
				cur_file->A4AF_srclist.RemoveAt(pos_A4AF);
@


1.95
log
@crash if we trying to delete non-existing client
@
text
@d92 1
a92 2
		int status = cur_file->GetStatus(true);
		if (status == PS_READY || status == PS_STOPPED || status == PS_PAUSED)
@


1.94
log
@Fixed start paused files by category (when option set or by menu)
Removed Reset All Statistics (agreed with Eklmn that has no use and it brings problems)
Removed Mobile Mule profile
Localized 'All' tab when language changed
@
text
@d668 1
a668 1
	if (cur_file != NULL)
@


1.93
log
@Fixed problem with moving category tabs (beware of CPartFile::SetPriority as it rebuilds the download list so any function using that feature *should* make a copy of it before proceeding).
@
text
@d321 2
a322 1
void CDownloadQueue::StartPausedDownload() {
d324 14
a337 9
	CPartFile* cur_file ;
	CPartFile* file_to_start = NULL ;
	
	for (POSITION pos = filelist.GetHeadPosition() ; pos != (POSITION)NULL ; filelist.GetNext(pos)) {
		cur_file = (CPartFile*)filelist.GetAt(pos) ;
		if (cur_file->GetStatus() == PS_PAUSED) {
			if (file_to_start ==NULL || file_to_start->GetPriority() < cur_file->GetPriority()) {
				file_to_start = cur_file ;
			}
d341 3
a343 1
	if (file_to_start != NULL) file_to_start->ResumeFile() ;
@


1.92
log
@Added Category missing feature in Search Window.
@
text
@d227 2
a228 1
void CDownloadQueue::AddSearchToDownload(CSearchFile* toadd,uint8 cat){
d231 3
a233 2
	if( !toadd->GetFileSize() ) {
		AddLogLine( true, IDS_SKIPZEROLENGTHFILE, toadd->GetFileName() );
d239 2
a240 1
	if (newfile->GetStatus() == PS_ERROR){
d246 1
d249 2
a250 1
	if (toadd->GetType() == CSearchFile::Client && toadd->GetClientID() && toadd->GetClientPort()){
d264 2
a265 1
		else{
d267 6
a272 3
				if (partfile) partfile->AddClientSources(&sources);
			}
		}				// netwolf 15.05.03 enhanced source finding END
d1143 2
d1146 3
d1150 1
a1150 1
		CPartFile* cur_file = filelist.GetAt(pos);
d1160 1
a1160 1
	//DonGato: fix for changing priority of categories
d1192 1
d1195 1
d1229 5
d1236 1
d1239 2
a1240 2
	POSITION pos = filelist.GetHeadPosition();
	while(pos != 0) 
d1242 2
a1243 1
		CPartFile* cur_file = filelist.GetAt(pos);
d1250 1
a1250 1
			if(cur_file->GetCategory() == from) 
d1257 1
a1257 3
				{	
					cur_file->SetCategory(cur_file->GetCategory()-1);
				}
d1259 1
a1259 3
				{	
					cur_file->SetCategory(cur_file->GetCategory()+1);
				}
a1261 1
		filelist.GetNext(pos);
a1264 1
// HoaX_69: BEGIN AutoCat function
a1308 1
// HoaX_69: END
@


1.91
log
@Fixes and updates (read forum to know)
@
text
@d333 1
d340 3
d1246 47
@


1.90
log
@Fixed priority change for categories, WebServer templates update and fixed problem with upload speed after Purity changes.
@
text
@d92 2
a93 1
		if (cur_file->GetStatus(true) == PS_READY)
@


1.89
log
@merging category code for webserver
@
text
@d1141 2
d1144 3
d1148 1
a1148 1
		CPartFile* cur_file = filelist.GetAt(pos);
@


1.88
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d226 1
a226 1
void CDownloadQueue::AddSearchToDownload(CSearchFile* toadd){
d240 1
d266 1
a266 1
void CDownloadQueue::AddSearchToDownload(CString link){
d273 1
d278 1
a278 1
void CDownloadQueue::AddFileLinkToDownload(CED2KFileLink* pLink)
d286 4
a289 1
	else AddDownload(newfile);
@


1.87
log
@*** empty log message ***
@
text
@d724 1
a726 1
#ifdef OLD_SOCKETS_ENABLED
a728 1
#endif //OLD_SOCKETS_ENABLED
a779 1
#ifdef OLD_SOCKETS_ENABLED
a783 1
#endif //OLD_SOCKETS_ENABLED
d786 1
@


1.86
log
@katsyonak Statistics changes.
@
text
@d81 1
a81 1
        theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d157 1
a157 1
				theApp.emuledlg->transferwnd.downloadlistctrl.AddFile(toadd);// show in downloadwindow
d179 1
a179 1
				theApp.emuledlg->transferwnd.downloadlistctrl.AddFile(toadd);// show in downloadwindow
d333 1
a333 1
	theApp.emuledlg->transferwnd.downloadlistctrl.AddFile(newfile);
d549 1
a549 1
								theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,temp_src,true);
d570 2
a571 2
	theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,source,false);
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d607 1
a607 1
						theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,source,true);
d619 1
a619 1
	theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,source,false);
d669 1
a669 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);	
a1123 1
#ifdef __USE_CATEGORIES__
a1232 2
#endif

@


1.85
log
@Updates (Paused Progress Bar/Statistic)
@
text
@d911 3
d915 1
a915 4
		{ 
			uint32 ui32SizeToTransfer=0;
			uint32 ui32NeededSpace=0;
			cur_file->GetSizeToTransferAndNeededSpace (ui32SizeToTransfer,ui32NeededSpace);
d920 2
@


1.84
log
@added past comments
@
text
@d911 9
@


1.83
log
@new statistic (khaos based)
@
text
@d568 1
d617 1
d646 1
@


1.82
log
@Added STOP visual notification.
@
text
@a820 13
void CDownloadQueue::GetDownloadStats(int results[]) 
{
	EMULE_TRY
	results[0]=0;
	results[1]=0;
	for (POSITION pos = filelist.GetHeadPosition();pos != 0; filelist.GetNext(pos)){
		CPartFile* cur_file =  filelist.GetAt(pos);
		results[0]+=cur_file->GetSourceCount();
		results[1]+=cur_file->GetTransferingSrcCount();
	}
	EMULE_CATCH
}

d874 2
a875 1
void CDownloadQueue::GetDownloadStats(int results[],uint64& pui64TotFileSize,uint64& pui64TotBytesLeftToTransfer,uint64& pui64TotNeededSpace) 
d877 7
a883 7
	EMULE_TRY	
	results[0]=0;
	results[1]=0;
	results[2]=0;
	for (POSITION pos = filelist.GetHeadPosition();pos != 0; filelist.GetNext(pos)){
		uint32 ui32SizeToTransfer=0;
		uint32 ui32NeededSpace=0;
d885 23
a907 9
		if (cur_file->GetPartfileStatus() != GetResString(IDS_PAUSED)) { 
		cur_file->GetSizeToTransferAndNeededSpace (ui32SizeToTransfer,ui32NeededSpace);
        pui64TotFileSize += cur_file->GetFileSize(); 
        pui64TotBytesLeftToTransfer += ui32SizeToTransfer;
        pui64TotNeededSpace += ui32NeededSpace;
        results[2]++; 
		} 
		results[0]+=cur_file->GetSourceCount();
		results[1]+=cur_file->GetTransferingSrcCount();
d909 1
d913 1
a914 8
int CDownloadQueue::GetFileCount()
{
	EMULE_TRY
	return filelist.GetCount();
	EMULE_CATCH
	return 0;
}

@


1.81
log
@*** empty log message ***
@
text
@d1175 1
a1175 1
					if(cur_file->GetStatus() == PS_PAUSED) 
@


1.80
log
@eMailNotifier and PopUp CleanUp
@
text
@d1113 113
@


1.79
log
@Purity's changes
@
text
@a334 2
	CString msgTemp;
	msgTemp.Format(GetResString(IDS_NEWDOWNLOAD)+_T("\n"),newfile->GetFileName());
d336 4
a339 8
	if(theApp.glob_prefs->IsSMTPInfoEnabled())
	{
		CSMTPConnection mail;
		CString txt;
		txt.Format(GetResString(IDS_NEWDOWNLOAD)+_T("\n"),newfile->GetFileName());
		mail.SendMuleMessage(txt);
	}
	theApp.emuledlg->ShowNotifier(msgTemp, TBN_DLOAD_ADD);
@


1.78
log
@fixed access violation
@
text
@d23 1
d337 8
d471 8
d933 14
@


1.77
log
@added new file state PS_STOPPED
@
text
@d70 1
@


1.76
log
@small speed optimization in RemoveSource()
@
text
@d513 7
d567 6
a572 2
	// SyruS "stop adding sources on stopped, completing and completed files" //Cax2: modified for current codebase....
	if(sender->GetStatus()==PS_PAUSED || sender->GetStatus() > 7)		//Cax2 + SyruS check
@


1.75
log
@fixed NULL pointer access
@
text
@d629 1
a629 1
	for (POSITION pos = toremove->m_OtherRequests_list.GetHeadPosition();pos != 0; toremove->m_OtherRequests_list.GetNext(pos))
d631 1
a631 3
		cur_file = toremove->m_OtherRequests_list.GetAt(pos);
		POSITION pos_A4AF = cur_file->A4AF_srclist.Find(toremove);
		if (pos_A4AF) 
d633 6
a638 1
			cur_file->A4AF_srclist.RemoveAt(pos_A4AF);
@


1.74
log
@RemoveSource() was rewritten
@
text
@d616 1
a616 2
	POSITION remove_pos = cur_file->srclists[toremove->sourcesslot].Find(toremove);
	if (remove_pos != 0) 
d618 10
a627 6
		cur_file->srclists[toremove->sourcesslot].RemoveAt(remove_pos);
		removed = true;
	} //if remove_pos
	//eklmn: update source info for the file
	cur_file->NewSrcPartsInfo();	// eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
	
@


1.73
log
@Removed old Stored Sources from all code.
@
text
@d603 1
a603 1

d610 17
a626 1
	for (POSITION pos = filelist.GetHeadPosition();pos != 0; filelist.GetNext(pos))
d628 3
a630 3
		CPartFile* cur_file = filelist.GetAt(pos);
		POSITION remove_pos = cur_file->srclists[toremove->sourcesslot].Find(toremove);
		if (remove_pos != 0) 
d632 6
a637 24
			cur_file->srclists[toremove->sourcesslot].RemoveAt(remove_pos);
			theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);
			removed = true;
		} //if remove_pos
/*		
		for (int sl=0;sl<SOURCESSLOTS;sl++) {
			if (!cur_file->srclists[sl].IsEmpty()) {
				POSITION cur_FilePos = cur_file->srclists[sl].Find(toremove);
				if (cur_FilePos != 0) {
					cur_file->srclists[sl].RemoveAt(cur_FilePos);
					theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);
					removed = true;
					break;
				} //if cur_FilePos
			} // if srclist empty
		} // for sl=0
*/		
		POSITION pos_A4AF = cur_file->A4AF_srclist.Find(toremove);
		if (pos_A4AF) cur_file->A4AF_srclist.RemoveAt(pos_A4AF);
		cur_file->NewSrcPartsInfo();	// eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
	} // for (pos)
	// ^-eklmn: bugfix(09): hang up by start if all files are paused
	
	toremove->SetDownloadState(DS_NONE);
@


1.72
log
@optimization in RemoveFile()
@
text
@a119 21
	//////////////////////////////////////////////////
	//for saving/loading sources mr fry
	
	//this indicates, if a permanent open CStoredSources-object for each
	//part-file should be used...
	//means, additons of sources and loading sources are made to/from this
	//open CStoredSources-object and saved to disk only on closing of eMule
	//
	//otherwise on each saving-/loading- session the *.src-file on disk is
	//opened before the save-/load- operation and closed again afterwards
	//
	//I think the difference is:
	//set to true: more memory is used (I think, it took about 20 kB to save 300 sources to my hard-drive)
	//set to false: more cpu-power is used
	m_bKeepStoredSourcesOpened	= true;
		
	if(app_prefs->SLSEnable())
		SetSourcesLoading(true);
	else
		SetSourcesLoading(false);
	//////////////////////////////////////////////////
a155 18
				//////////////////////////////////////////////////
				//for loading sources mr fry
#ifdef OLD_SLS_ENABLED
				if(toadd->GetStatus() < 4 && IsSourcesLoadingEnabled())
				{
							
				
					//load source for the part-file
					toadd->LoadAndAddSources(KeepStoredSourcesOpen(),false,toadd->GetLoadSourcesAtOnceLimit(),true,false,false);	//to restore sources from file (by Mr.Fry)
					toadd->SetLoadedSourcesCompletely(false);

					//do load sources for part-files with different time-offsets
					//means: do not load the sources of all part-files at one time
					//(offset: (No. of part-file) multiplied by (1 second))
					toadd->SetLoadSourcesSlowTimeInterval((toadd->GetLoadSourcesSlowTimeInterval() + (count * 1000)));
				}
#endif //OLD_SLS_ENABLED
				//////////////////////////////////////////////////
a326 3
	// Added by Tarod
	// Checks if must add file paused and if not set first load saved sources time interval to 2 minutes
	// so we can get Exchanged sources excedings faster
a329 4
	} else {
#ifdef OLD_SLS_ENABLED
		newfile->SetLoadSourcesTimeInterval(2 * 60 * 1000) ;
#endif //OLD_SLS_ENABLED
a330 1
	// End by Tarod
a553 12
#ifdef OLD_SLS_ENABLED
	//////////////////////////////////////////////////
	//code for saving the sources to disk

     	if(saveSources && m_bKeepStoredSourcesOpened)
	{
         	//store the new source immediately to the CStoredSources-object of the part-file
         	sender->SaveToStoredSources(source);
	}//end of modification by Mr.Fry
	//////////////////////////////////////////////////
#endif //OLD_SLS_ENABLED

a595 9
#ifdef OLD_SLS_ENABLED
	//////////////////////////////////////////////////
	//code for saving the sources to disk
	if(m_bKeepStoredSourcesOpened){
		//store the new source immediately to the CStoredSources-object of the part-file
		sender->SaveToStoredSources(source);
	}//end of modification by Mr.Fry
	//////////////////////////////////////////////////
#endif //OLD_SLS_ENABLED
a905 31
/////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////
//Storing Sources:
#ifdef OLD_SLS_ENABLED
bool CDownloadQueue::SaveAllSourcesToFile(bool debug)
{
	EMULE_TRY
	if(!m_bIsInitialized) return false;
	bool errorOccured=false;
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* partFile = filelist.GetAt(pos);
		if(!partFile->SaveSources()){
			TRACE("Could not save sources (clients) for one downloading file\n\t(probably there are no sources for this file)\n");			
			errorOccured = true;
		}
	}
	if(errorOccured) return false;
	return true;
	EMULE_CATCH
	return false;
}
#endif //OLD_SLS_ENABLED
bool CDownloadQueue::IsMaxClientsExceeded()
{
	EMULE_TRY
	return (theApp.clientlist->GetClientCount() > (int)theApp.glob_prefs->GetMaxConnections());
	EMULE_CATCH
	return false;
}
///////////
@


1.71
log
@speed optimization in RemoveSource
@
text
@d566 2
a567 1
				for (pos1 = cur_file->srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;) {
d571 2
a572 1
					if (temp_src->Compare(source)) {
d601 3
a603 2
	 //////////////////////////////////////////////////
     //code for saving the sources to disk
d605 6
a610 4
     if(saveSources && m_bKeepStoredSourcesOpened){
         //store the new source immediately to the CStoredSources-object of the part-file
#ifdef OLD_SLS_ENABLED
         sender->SaveToStoredSources(source);
d612 1
a612 2
     }//end of modification by Mr.Fry
     //////////////////////////////////////////////////
d655 1
a657 1

a659 1
#ifdef OLD_SLS_ENABLED
a660 1
#endif //OLD_SLS_ENABLED
d663 1
d665 4
a668 3
	return TRUE; 
    EMULE_CATCH
    return FALSE;
d723 7
a729 8
    EMULE_TRY
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		if (toremove == filelist.GetAt(pos)){
			filelist.RemoveAt(pos);
			return;
		}
	}
    EMULE_CATCH
@


1.70
log
@merged missing UPD answers on ClientUDPSocket [DonGato]
@
text
@d674 2
a675 1
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
d677 8
d696 1
@


1.69
log
@sessiontime starts on resuming for initialy paused files (for avg datarate)
@
text
@d890 25
@


1.68
log
@upper DL set again, optimized IsPartFile(), iteration in Process was limited to 10  (improved DL)
@
text
@d370 2
a371 1
		newfile->StopFile() ;
@


1.67
log
@1) fixed possible exception during a scan of srclist;
2) fixed download timeouts
@
text
@d411 1
a411 1
	if ( max_DL_speed != UNLIMITED && datarate > 1500 && max_DL_speed_kB>datarate) {
d415 1
a415 1
		/* eklmn: it's pointless to recalculate upper limit every time, if DL < DL rate
a417 3
		*/
		//if (app_prefs->GetMaxDownload()*1024 < datarate)
		//	downspeed = 0xFFF;
d520 9
a528 5
    EMULE_TRY
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos))
		if (totest == filelist.GetAt(pos))
			return true;
    EMULE_CATCH
d530 1
d596 1
a596 2
	// doesn''t need here, updated in AddSource
	//UpdateDisplayedInfo();	// eklmn: bugfix(12): refresh whole downloadlist
d649 1
a649 2
	// doesn''t need here, updated in AddSource
	//UpdateDisplayedInfo();	// eklmn: bugfix(12): refresh whole downloadlist
@


1.66
log
@New A4AF mangement
@
text
@d423 3
a425 2
    static uint32 iteration=0;
    uint32 tempDatarate = 0;
d428 4
a431 6
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) &&(cur_file->GetPriority() == PR_HIGH || cur_file->GetPriority() == PR_AUTO))	//jicxicmic fix
		{	



			tempDatarate += cur_file->Process(downspeed, iteration);
d437 1
a437 1
			tempDatarate += cur_file->Process(downspeed, iteration);
d443 1
a443 1
			tempDatarate += cur_file->Process(downspeed, iteration); 
a445 1
    if(++iteration>15) iteration=0;
d447 1
a447 1
    datarate = tempDatarate;
d449 3
a451 2
    DWORD curTick = GetTickCount();
    // Save used bandwidth for speed calculations
d467 6
a472 6
    // Calculate average datarate
    if(average_dr_list.size() >1) 
	    averageDatarate = (uint32)(((float)(average_dr_list.front()-average_dr_list.back()))*1000 / (average_tick_list.front()-average_tick_list.back()));
    else
        averageDatarate = 0;
	udcounter++;
d558 2
a559 1
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
d563 2
a564 1
				for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)) {
d864 20
a883 8
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file = filelist.GetAt(pos);
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
			if (dwIP == cur_file->srclists[sl].GetAt(pos2)->GetIP()){
				return cur_file->srclists[sl].GetAt(pos2);
			}
		}
@


1.65
log
@unicode cleanup
@
text
@d171 2
a172 1
					toadd->SetA4AFAuto(true);
a360 32
// Deactivates all downloading files A4AF auto setting
void CDownloadQueue::DisableAllA4AFAuto(void)
{
    EMULE_TRY
	for (POSITION pos = filelist.GetHeadPosition(); pos != NULL; filelist.GetNext(pos)) {
		CPartFile* cur_file = (CPartFile*)filelist.GetAt(pos);
		if (cur_file != NULL) cur_file->SetA4AFAuto(false);
	}
    EMULE_CATCH
}

// Returns A4AF auto file
//
// [Return]
//      Pointer fo file that is A4AF or NULL in case that there is no A4AF auto file.
CPartFile* CDownloadQueue::GetA4AFAutoFile(void)
{
    EMULE_TRY
	CPartFile* A4AF_auto_file = NULL;
	POSITION pos = filelist.GetHeadPosition();
	while (A4AF_auto_file == NULL && pos != NULL) {
		if (((CPartFile*)filelist.GetAt(pos))->IsA4AFAuto()) {
			A4AF_auto_file = (CPartFile*)filelist.GetAt(pos);
		}
		filelist.GetNext(pos);
	}

	return A4AF_auto_file;
    EMULE_CATCH
    return NULL;
}

d561 16
a576 17
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
			if (cur_file->srclists[sl].GetAt(pos2)->Compare(source)){
				if (cur_file == sender){ // this file has already this source
					delete source;
					return;
				}
				// set request for this source
				if (cur_file->srclists[sl].GetAt(pos2)->AddRequestForAnotherFile(sender)){
					// add it to uploadlistctrl
					theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,cur_file->srclists[sl].GetAt(pos2),true);
					delete source;
					return;
				}
				else{
					delete source;
					return;
a577 2
			}
		}
d685 2
a687 2
		// v1:-eklmn: feature(00): ICR 2.7 (free parts by removing the parts)
		//if (cur_file == toremove->reqfile) cur_file->RemovePartFromBlockedList(toremove->m_LastPartAsked);
d1100 19
@


1.64
log
@eklmn: it's pointless to recalculate upper DL limit every time, if DL < DL rate
@
text
@d411 1
a411 1
	msgTemp.Format(GetResString(IDS_NEWDOWNLOAD)+"\n",newfile->GetFileName());
d1034 1
d1036 1
a1036 1
		source->sourceHostname, hostentBuffer, MAXGETHOSTSTRUCT);
@


1.63
log
@ICR 2.8 fix
@
text
@d440 4
a443 2
	if (app_prefs->GetMaxDownload() != UNLIMITED && datarate > 1500){
		downspeed = (app_prefs->GetMaxDownload()*1024*100)/(datarate+1); //(uint16)((float)((float)(app_prefs->GetMaxDownload()*1024)/(datarate+1)) * 100);
d446 1
d449 1
@


1.62
log
@some chages in RemoveSouce reverted
@
text
@d717 1
a717 1
		if (cur_file == toremove->reqfile) cur_file->RemovePartFromBlockedList(toremove->m_LastPartAsked);
@


1.61
log
@check all sourceslots in RemoveSource (gaps in FileDetails)
@
text
@d711 1
@


1.60
log
@ICR 2.7 (new condition for widespread parts 1 client = 1 Part)
@
text
@a708 4
					// v1:-eklmn: feature(00): ICR 2.7 (free parts by removing the parts)
					if (cur_file == toremove->reqfile) cur_file->RemovePartFromBlockedList(toremove->m_LastPartAsked);
					cur_file->NewSrcPartsInfo();	// eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
					//cur_file->UpdateAvailablePartsCount(); 
a710 1
					break;
d714 3
d720 1
a720 4
	if (updatewindow){
		//theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);	//Cax2 - downloadlistcontrol bugfix
		toremove->SetDownloadState(DS_NONE);
	}
@


1.59
log
@minor changes (use md4... instead of mem...)
@
text
@d709 2
@


1.58
log
@two source function (NewSrcPartsInfo & UpdateAvailablePartsCount) werr merged (speed optimization)
@
text
@d170 1
a170 1
				if (memcmp(toadd->GetFileHash(), theApp.glob_prefs->GetA4AFHash(), 16) == 0)
d578 1
a578 1
	if (memcmp(theApp.glob_prefs->GetUserHash(), source->GetUserHash(), 16) == 0)
d649 1
a649 1
   	if (memcmp(theApp.glob_prefs->GetUserHash(), source->GetUserHash(), 16) == 0) 
@


1.57
log
@A4AF switching v2
@
text
@d709 2
a710 2
					cur_file->NewSrcPartsInfo();
					cur_file->UpdateAvailablePartsCount();
@


1.56
log
@refresh whole downloadlist after souce update
@
text
@d696 1
a696 1
bool CDownloadQueue::RemoveSource(CUpDownClient* toremove, bool	updatewindow)
d706 9
a714 10
				for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
					if (toremove == cur_file->srclists[sl].GetAt(pos2)){
						cur_file->srclists[sl].RemoveAt(pos2);
						cur_file->NewSrcPartsInfo();
						cur_file->UpdateAvailablePartsCount();
						theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,cur_file);
						removed = true;
						break;
					} //if toremove
				} // for (pos2)
@


1.55
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d623 2
a624 1
	UpdateDisplayedInfo();
d677 2
a678 1
	UpdateDisplayedInfo();
@


1.54
log
@hang up by start if all files are paused (???)
@
text
@d22 1
d1077 1
d1079 3
d1129 1
a1129 1
}@


1.53
log
@Preparing for new sockets
@
text
@d654 2
a655 1
    // [/Lord KiRon] v3 
d658 6
a663 5
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
			if (cur_file->srclists[sl].Find(source)){
				if (cur_file == sender)
				{
					// [Lord KiRon] v3
a664 1
					// [/Lord KiRon] v3 
a665 3
				if (source->AddRequestForAnotherFile(sender))
					theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,source,true);
				return TRUE;
d667 1
d669 1
d671 1
d692 1
d695 3
a697 1
    EMULE_TRY
d701 17
a717 11
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
			if (toremove == cur_file->srclists[sl].GetAt(pos2)){
				cur_file->srclists[sl].RemoveAt(pos2);
				cur_file->NewSrcPartsInfo();
				removed = true;
				break;
			}
		}
		cur_file->UpdateAvailablePartsCount();
	}
d719 1
a719 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);	//Cax2 - downloadlistcontrol bugfix
d729 3
a731 1
    EMULE_CATCH
@


1.52
log
@converted to new logger methods
@
text
@d611 1
d615 1
d767 1
d770 1
d822 1
d827 1
d1088 1
d1091 1
@


1.51
log
@code cleanup
@
text
@d216 1
a216 1
				AddLogLine(false, GetResString(IDS_RECOVERED_PARTMET), toadd->GetFileName());
d229 1
a229 1
		AddLogLine(false,GetResString(IDS_NOPARTSFOUND));
d231 1
a231 1
		AddLogLine(false,GetResString(IDS_FOUNDPARTS),count);
d265 1
a265 1
		AddLogLine( true, GetResString(IDS_SKIPZEROLENGTHFILE), toadd->GetFileName() );
d408 1
a408 1
	AddLogLine(true,GetResString(IDS_NEWDOWNLOAD),newfile->GetFileName());
d420 1
a420 1
			AddLogLine(true, GetResString(IDS_ERR_ALREADY_DOWNLOADING), file->GetFileName());
d422 1
a422 1
			AddLogLine(true, GetResString(IDS_ERR_ALREADY_DOWNLOADED), file->GetFileName());
d426 1
a426 1
		AddLogLine(true, GetResString(IDS_ERR_ALREADY_DOWNLOADING), file->GetFileName());
@


1.50
log
@enhanced source finding
@
text
@d415 1
a415 1
bool CDownloadQueue::IsFileExisting(uchar* fileid)
d537 1
a537 1
CPartFile*	CDownloadQueue::GetFileByID(uchar* filehash)
@


1.49
log
@minor fixes and improvements
@
text
@d262 1
a262 1
    EMULE_TRY
d276 22
a297 1
    EMULE_CATCH
@


1.48
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d520 1
a520 1
		if (!memcmp(filehash,filelist.GetAt(pos)->GetFileHash(),16))
@


1.47
log
@fixes by BavarianSnail/obaldin/kuchin. see changelog+
@
text
@d545 9
d717 1
a717 1
		if( cur_file->GetStatus() == PS_READY )
@


1.46
log
@#0000258
bug, crash
0-byte file crash
@
text
@d428 1
d437 1
a437 1
			tempDatarate += cur_file->Process(downspeed);
d443 1
a443 1
			tempDatarate += cur_file->Process(downspeed);
d449 1
a449 1
			tempDatarate += cur_file->Process(downspeed); 
d452 2
@


1.45
log
@Upgrade to 0.28a
@
text
@d263 5
@


1.44
log
@UDP Search status moved to statistic and added to resource strings
@
text
@d673 1
a673 2
	// Moosetea - BugFix make sure that comments are removed! if this client had comments we need to check again
	if (toremove->GetFileComment() || toremove->GetFileRate()) //Spark2 - full check now
d779 3
a781 2
	memcpy(packet.pBuffer,nextfile->GetFileHash(),16);
	if (cur_udpserver != theApp.serverlist->GetServerByAddress(theApp.serverconnect->GetCurrentServer()->GetAddress(),theApp.serverconnect->GetCurrentServer()->GetPort()))
d783 1
@


1.43
log
@UDP Search status is shown in up-down tooltip
@
text
@d1049 1
a1049 1
		sOut.Format(_T("UDP Search: In progress. File %d/%d, Server %d/%d"),
d1056 2
a1057 1
			sOut = _T("UDP Search: Finished. Next Search in ") + CastSecondsToHM((UDPSERVERREASKTIME - (GetTickCount() - lastudpsearchtime))/1000);
d1059 1
a1059 1
			sOut = _T("UDP Search: Didn't start yet.");
@


1.42
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d55 2
d741 1
d749 1
d756 1
d761 2
d766 1
d771 1
d1036 29
a1064 1
// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-@


1.41
log
@bugfixed 'cancel  file' & 'remove comment'
@
text
@d449 1
a449 1
	if(average_tick_list.IsEmpty() || curTick >= average_tick_list.GetTail()+500)	//Cax2 - update no faster than every .5 sec
d451 1
a451 1
		average_dr_list.AddTail(theApp.stat_sessionReceivedBytes);
d454 1
a454 1
		average_tick_list.AddTail(curTick);
d456 4
a459 4
		// don't save more than 40 secs of data
		while(curTick-average_tick_list.GetHead() > 40000) {
   			average_dr_list.RemoveHead();
			average_tick_list.RemoveHead();
d464 3
a466 3
    if(average_dr_list.GetSize() >= 2) {
	    averageDatarate = (uint32)(((float)(average_dr_list.GetTail()-average_dr_list.GetHead()))*1000 / (average_tick_list.GetTail()-average_tick_list.GetHead()));
    } else {
a467 1
    }
d469 1
a469 1
	DWORD dwCurrentTime	=	GetTickCount(); // Use one variable to save few CPU cycles and have better time data [Lord KiRon]
d471 2
a472 2
		if((!lastudpstattime) || (dwCurrentTime - lastudpstattime) > UDPSERVERSTATTIME){
			lastudpstattime = dwCurrentTime;
d478 1
a478 1
		if ((!lastudpsearchtime) || (dwCurrentTime - lastudpsearchtime) > UDPSERVERREASKTIME)
d485 1
a485 1
	if(m_lastPartFileStatsSave+300000 < dwCurrentTime )
d487 1
a487 1
		m_lastPartFileStatsSave=dwCurrentTime;
@


1.41.2.1
log
@27a partial merge
@
text
@d420 2
a421 2
	datarate = 0;
	udcounter++;
d426 4
a429 1
			datarate += cur_file->Process(downspeed,udcounter);
d435 1
a435 1
			datarate += cur_file->Process(downspeed,udcounter);
d441 1
a441 1
			datarate += cur_file->Process(downspeed,udcounter);
d444 1
d469 1
d532 1
a532 1
	if( (!source->HasLowID() && (source->GetUserID() & 0xFF) == 0x7F) || sender->IsStopped()) {
d580 1
d603 1
a603 1
	if((!source->HasLowID() && (source->GetUserID() & 0xFF) == 0x7F) || sender->IsStopped() )
a661 1
				cur_file->RemoveDownloadingSource(toremove);
d773 1
a773 2
	if (cur_udpserver != theApp.serverlist->GetServerByAddress(theApp.serverconnect->GetCurrentServer()->GetAddress(),theApp.serverconnect->GetCurrentServer()->GetPort())){
		theApp.uploadqueue->AddUpDataOverheadServer(packet.size);
a774 1
	}
@


1.40
log
@added ResumeFiles method
@
text
@d673 1
a673 1
	if (toremove->GetFileComment().GetLength() > 0)
@


1.39
log
@bugfix: less resource usage, fixed bug #131
@
text
@d695 12
@


1.38
log
@Fixed bug #132
@
text
@d449 3
a451 1
	average_dr_list.AddTail(theApp.stat_sessionReceivedBytes);
d453 2
a454 2
    // Save time beetween each speed snapshot
    average_tick_list.AddTail(curTick);
d456 6
a461 5
    // don't save more than 40 secs of data
    while(curTick-average_tick_list.GetHead() > 40000) {
   	    average_dr_list.RemoveHead();
        average_tick_list.RemoveHead();
    }
@


1.37
log
@converted to new logging method
@
text
@d144 1
a144 1
	if(app_prefs->tempdir_list.Find(sTempDir) == NULL)
@


1.36
log
@Small fix related to multiple temp dirs
@
text
@d214 1
a214 1
				theApp.emuledlg->AddLogLine(false, GetResString(IDS_RECOVERED_PARTMET), toadd->GetFileName());
d227 1
a227 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_NOPARTSFOUND));
d229 1
a229 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_FOUNDPARTS),count);
d380 1
a380 1
	theApp.emuledlg->AddLogLine(true,GetResString(IDS_NEWDOWNLOAD),newfile->GetFileName());
d392 1
a392 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_ALREADY_DOWNLOADING), file->GetFileName());
d394 1
a394 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_ALREADY_DOWNLOADED), file->GetFileName());
d398 1
a398 1
		theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_ALREADY_DOWNLOADING), file->GetFileName());
d913 1
a913 1
		DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("void CDownloadQueue::AddClientHostnameToResolve(CPtrList* pLink): already resolving. Exiting.")));
d948 1
a948 1
	theApp.emuledlg->AddLogLine(false,CString("Resolving source hostname: %s"),source->sourceHostname);
d957 1
a957 1
			theApp.emuledlg->AddLogLine(false,CString("Error calling WSAAsyncGetHostByName to resolve source "),hostsource->sourceHostname);
d969 1
a969 1
			theApp.emuledlg->AddLogLine(false,CString("Source resolve retry numer %i"),sourceHostnameResolveRetry);
d985 1
a985 1
		DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("Error resolving source : %s"),hostsource->sourceHostname));
d1001 1
a1001 1
	theApp.emuledlg->AddLogLine(false,CString("Resolved source hostname: %s - %i:%i:%i:%i"),hostsource->sourceHostname, resolvedaddr.S_un.S_un_b.s_b1, resolvedaddr.S_un.S_un_b.s_b2, resolvedaddr.S_un.S_un_b.s_b3, resolvedaddr.S_un.S_un_b.s_b4);
d1007 1
a1007 1
		DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile doesn't exist anymore.")));
@


1.35
log
@bugfixed exchanged sources; removed unnecessary IDS_EXCHANGEDSOURCEMARK
@
text
@d143 1
d145 1
d147 2
d223 2
a224 1
//	app_prefs->tempdir_list.RemoveHead();
@


1.34
log
@Bugfix when temp folder appears twice or more in tempdir.dat
@
text
@d1002 1
a1002 1
		DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("void CDownloadQueue::SourceHostnameResolved(WPARAM wp, LPARAM lp): impossible to add source because the partfile exists no more.")));
@


1.33
log
@Bugfix when temp folder appears twice or more in tempdir.dat
@
text
@d219 1
a219 1
	app_prefs->tempdir_list.RemoveHead();
@


1.32
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d142 3
a144 1
	app_prefs->tempdir_list.AddHead(app_prefs->GetTempDir());
@


1.31
log
@bugfix to kuchin's bugfixes: m_bIsInitialized wasn't set to true
@
text
@d568 1
d621 1
@


1.30
log
@Fixed CVS (sorry my mistake)
@
text
@d234 1
@


1.29
log
@Comments are removed, the comment flag should disappear when we loose a commented source.
@
text
@d660 2
a661 2
	if (toremove->GetFileComment().StringLength > 0)
		reqfile->UpdateFileRatingCommentAvail();
@


1.28
log
@Bugfixes
@
text
@d658 5
@


1.27
log
@enkeydev stuff
@
text
@d67 1
d71 2
d79 1
d401 1
d696 1
a784 1
	
d787 1
a787 2

	for (POSITION pos =theApp.downloadqueue->filelist.GetHeadPosition();pos != 0;theApp.downloadqueue->filelist.GetNext(pos)){
d817 1
a817 2

	for (POSITION pos =theApp.downloadqueue->filelist.GetHeadPosition();pos != 0;theApp.downloadqueue->filelist.GetNext(pos)){
d847 1
a847 1
	for(POSITION pos = theApp.downloadqueue->filelist.GetHeadPosition(); pos != 0; theApp.downloadqueue->filelist.GetNext(pos))
d865 1
@


1.26
log
@Bugfix : plus no longer displays 100% upload on startup
@
text
@d29 16
d225 5
d280 12
a291 5
	if(pLink->HasValidSources()) {
		if (newfile) newfile->AddClientSources(pLink->SourcesList);
		else{
				CPartFile* partfile = GetFileByID((uchar*)pLink->GetHashKey());
				if (partfile) partfile->AddClientSources(pLink->SourcesList);
a292 1

d294 1
d883 112
a994 1
///////////@


1.25
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d39 1
@


1.24
log
@bugfix: all 'weird' clients should be gone... Some duplicate clients still showing....
@
text
@d383 4
a386 1
		{
@


1.23
log
@should eliminate 'unknown friends'
@
text
@a610 1
				theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,cur_file);	//Cax2 - downloadlistcontrol bugfix
d618 1
d622 1
a622 1
	toremove->CleanOtherRequests();	//Cax2 - should remove 'fake sources'
@


1.22
log
@bugfixed A4AF
@
text
@d611 1
a619 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);	//Cax2 - downloadlistcontrol bugfix
d622 1
@


1.21
log
@bugfix: should remove 'unknown friends' & some A4AF:null
@
text
@d568 9
a576 4
		if (cur_file->srclists[sl].Find(source)){
			if (cur_file == sender)
			{
				// [Lord KiRon] v3
a577 1
				// [/Lord KiRon] v3 
a578 4
			if (source->AddRequestForAnotherFile(sender))
				theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,source,true);
			return TRUE;
		}
d621 1
a621 1
	toremove->reqfile = 0;
@


1.20
log
@minimize to tray button v4a, updated connections control panel
@
text
@d619 1
a619 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,0);
@


1.19
log
@minor bugfixes, refreshes sources display...
@
text
@d401 1
a401 1
    DWORD curTick = ::GetTickCount();
d410 1
a410 1
    while(curTick-average_tick_list.GetHead() > 40*1000) {
d438 1
a438 1
	if(m_lastPartFileStatsSave+5*60*1000 < dwCurrentTime )
@


1.18
log
@the famous zz upload system! :)
@
text
@d55 1
a55 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()/(RAND_MAX/1000))) {
@


1.18.2.1
log
@v1a upgrade
@
text
@d55 1
a55 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
d401 1
a401 1
    DWORD curTick = GetTickCount();
d410 1
a410 1
    while(curTick-average_tick_list.GetHead() > 40000) {
d438 1
a438 1
	if(m_lastPartFileStatsSave+300000 < dwCurrentTime )
d568 4
a571 9
			if (cur_file->srclists[sl].Find(source)){
				if (cur_file == sender)
				{
					// [Lord KiRon] v3
					return TRUE;
					// [/Lord KiRon] v3 
				}
				if (source->AddRequestForAnotherFile(sender))
					theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,source,true);
d573 1
d575 4
a617 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(toremove,NULL);	//Cax2 - downloadlistcontrol bugfix
d619 1
d621 1
a621 2
	toremove->reqfile = NULL;
	toremove->CleanOtherRequests();	//Cax2 - downloadlistcontrol bugfix
@


1.17
log
@bugfixes: sort in search window, unknown % in stats, dowload speed at startup updated search layout
@
text
@d378 2
a379 1
	datarate = 0;
d384 1
a384 1
			datarate += cur_file->Process(downspeed);
d390 1
a390 1
			datarate += cur_file->Process(downspeed);
d396 1
a396 1
			datarate += cur_file->Process(downspeed); 
d399 22
@


1.16
log
@Preparing for new SLS code
@
text
@d381 2
a382 1
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) && cur_file->GetPriority() == PR_HIGH){
@


1.15
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d148 1
d162 1
d333 1
d335 1
d515 1
d517 1
d565 1
d567 1
d801 1
a801 1

d818 1
a818 1

@


1.14
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d84 1
a84 1
		m_nDownDatarateOverhead /= (m_AvarageDDRO_list.GetCount()/10);
d553 1
a553 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
@


1.13
log
@more 26b merges
@
text
@d23 7
@


1.12
log
@corrected mistake in .26b port
@
text
@d34 1
a34 1
	m_nDownDatarateOverhead = 0;	
d39 4
d359 1
a359 1
		downspeed =  (uint32)((float)((float)(app_prefs->GetMaxDownload()*1024)/(datarate+1)) * 100);
@


1.11
log
@.26b port
@
text
@d494 10
@


1.10
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d41 9
d353 1
a353 1
	sint16 downspeed = 0;
d355 1
a355 1
		downspeed =  (uint16)((float)((float)(app_prefs->GetMaxDownload()*1024)/(datarate+1)) * 100);
d492 2
a493 10
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
	//////////////////////////////////////////////////
	//code for saving the sources to disk

	if(saveSources && m_bKeepStoredSourcesOpened){
		//store the new source immediately to the CStoredSources-object of the part-file
		sender->SaveToStoredSources(source);
	}//end of modification by Mr.Fry
	//////////////////////////////////////////////////
    EMULE_CATCH
@


1.9
log
@stopped files bugfix & updated search dialog
@
text
@d35 4
a38 1
TRACE("filelist: %p-%d\r\n", &filelist, sizeof(filelist));
d52 1
a52 1
void CDownloadQueue::CompDatarateOverhead(){
d357 13
a369 1
		if (cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY){ 
d452 3
a454 2
		for (POSITION pos2 = cur_file->srclist.GetHeadPosition();pos2 != 0; cur_file->srclist.GetNext(pos2)){
			if (cur_file->srclist.GetAt(pos2)->Compare(source)){
d460 1
a460 1
				if (cur_file->srclist.GetAt(pos2)->AddRequestForAnotherFile(sender)){
d462 1
a462 1
					theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,cur_file->srclist.GetAt(pos2),true);
d480 2
a481 1
	sender->srclist.AddTail(source);
d515 2
a516 1
		if (cur_file->srclist.Find(source)){
d529 1
a529 1
	sender->srclist.AddTail(source);
d552 4
a555 3
		for (POSITION pos2 = cur_file->srclist.GetHeadPosition();pos2 != 0; cur_file->srclist.GetNext(pos2)){
			if (toremove == cur_file->srclist.GetAt(pos2)){
				cur_file->srclist.RemoveAt(pos2);
d591 2
a592 1
		cur_file->srclist.RemoveAll();
d709 4
a712 3
		for (POSITION pos2 = cur_file->srclist.GetHeadPosition();pos2 != 0; cur_file->srclist.GetNext(pos2)){
			if (dwIP == cur_file->srclist.GetAt(pos2)->GetIP()){
				return cur_file->srclist.GetAt(pos2);
@


1.9.2.1
log
@initial upgrade to .26
@
text
@d34 2
a35 5
	m_nDownDatarateOverhead = 0;
	m_nDownDataOverheadSourceExchange = 0;
	m_nDownDataOverheadFileRequest = 0;
	m_nDownDataOverheadOther = 0;
	m_nDownDataOverheadServer = 0;
d38 2
a39 1
void CDownloadQueue::AddPartFilesToShare(){
d49 2
a50 1
void CDownloadQueue::CompDownDatarateOverhead(){
d54 1
a54 1
	
d354 2
a355 14
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) && cur_file->GetPriority() == PR_HIGH){
			datarate += cur_file->Process(downspeed);
		}
	}
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file =  filelist.GetAt(pos);
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) && cur_file->GetPriority() == PR_NORMAL){
			datarate += cur_file->Process(downspeed);
		}
	}
	for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		CPartFile* cur_file =  filelist.GetAt(pos);
		if ((cur_file->GetStatus() == PS_READY || cur_file->GetStatus() == PS_EMPTY) && cur_file->GetPriority() == PR_LOW){
			datarate += cur_file->Process(downspeed);
d437 2
a438 3
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
			if (cur_file->srclists[sl].GetAt(pos2)->Compare(source)){
d444 1
a444 1
				if (cur_file->srclists[sl].GetAt(pos2)->AddRequestForAnotherFile(sender)){
d446 1
a446 1
					theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(sender,cur_file->srclists[sl].GetAt(pos2),true);
d464 1
a464 2
	
	sender->srclists[source->sourcesslot].AddTail(source);
d498 1
a498 2
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		if (cur_file->srclists[sl].Find(source)){
d511 1
a511 1
	sender->srclists[source->sourcesslot].AddTail(source);
d534 3
a536 4
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
			if (toremove == cur_file->srclists[sl].GetAt(pos2)){
				cur_file->srclists[sl].RemoveAt(pos2);
d554 2
a555 1
void CDownloadQueue::RemoveFile(CPartFile* toremove){
d566 2
a567 1
void CDownloadQueue::DeleteAll(){
d572 1
a572 2
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
			cur_file->srclists[sl].RemoveAll();
d646 2
a647 1
void CDownloadQueue::SortByPriority(){
a648 1

d684 2
a685 1
CUpDownClient* CDownloadQueue::GetDownloadClientByIP(uint32 dwIP){
a686 1

d689 3
a691 4
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!cur_file->srclists[sl].IsEmpty())
		for (POSITION pos2 = cur_file->srclists[sl].GetHeadPosition();pos2 != 0; cur_file->srclists[sl].GetNext(pos2)){
			if (dwIP == cur_file->srclists[sl].GetAt(pos2)->GetIP()){
				return cur_file->srclists[sl].GetAt(pos2);
@


1.9.2.2
log
@more fixes, more merging, try/catch balancing
@
text
@a51 1
    EMULE_TRY
@


1.8
log
@merge fixes and minor optimizations
@
text
@d482 2
a483 2
	if ((sender->GetStatus()==PS_PAUSED) || sender->GetStatus()==PS_COMPLETING || sender->GetStatus()==PS_COMPLETE)
			return FALSE;
@


1.7
log
@Very small CPU speed improvment
[Lord KiRon]
@
text
@a223 25
void CDownloadQueue::StartNextFile(){
    EMULE_TRY
	if( !theApp.glob_prefs->StartNextFile() )
		return;
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		if (filelist.GetAt(pos)->GetStatus() == PS_PAUSED && filelist.GetAt(pos)->GetPriority() == PR_HIGH ){
			filelist.GetAt(pos)->ResumeFile();
			return;
		}
	}
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		if (filelist.GetAt(pos)->GetStatus() == PS_PAUSED && filelist.GetAt(pos)->GetPriority() == PR_NORMAL ){
			filelist.GetAt(pos)->ResumeFile();
			return;
		}
	}
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
		if (filelist.GetAt(pos)->GetStatus() == PS_PAUSED && filelist.GetAt(pos)->GetPriority() == PR_LOW ){
			filelist.GetAt(pos)->ResumeFile();
			return;
		}
	}
    EMULE_CATCH
}

d244 1
d250 1
a250 1
	CPartFile* file_to_start = (CPartFile*)NULL ;
d255 1
a255 3
			if (file_to_start == (CPartFile*)NULL) {
				file_to_start = cur_file ;
			} else if (file_to_start->GetPriority() < cur_file->GetPriority()) {
d261 1
a261 1
	if (file_to_start != (CPartFile*)NULL) file_to_start->ResumeFile() ;
d482 1
a482 1
	if ((sender->GetStatus()==PS_PAUSED && sender->GetSourceCount()==0) || sender->GetStatus()==PS_COMPLETING || sender->GetStatus()==PS_COMPLETE)
@


1.7.2.1
log
@updating this branch...
@
text
@@


1.7.2.2
log
@merge bugfixes
@
text
@d224 24
a248 1
//in the official they changed it to StartNextFile()
d274 1
a274 1
	CPartFile* file_to_start = NULL ;
d279 3
a281 1
			if (file_to_start ==NULL || file_to_start->GetPriority() < cur_file->GetPriority()) {
d287 1
a287 1
	if (file_to_start != NULL) file_to_start->ResumeFile() ;
a445 5
	// SyruS "stop adding sources on stopped, completing and completed files" //Cax2: modified for current codebase....
	if ((sender->GetStatus()==PS_PAUSED) || sender->GetStatus()==PS_COMPLETING || sender->GetStatus()==PS_COMPLETE)
		delete source;	
		return;
	// SyruS end
d508 1
a508 1
	if ((sender->GetStatus()==PS_PAUSED) || sender->GetStatus()==PS_COMPLETING || sender->GetStatus()==PS_COMPLETE)
@


1.7.2.3
log
@merge cleanup!
@
text
@d421 5
@


1.7.2.4
log
@Interim release!
@
text
@d224 2
a245 1
//in the official they renamed this funcion StartNextFile()
@


1.6
log
@corrected typos
@
text
@d385 1
d387 2
a388 2
		if((!lastudpstattime) || (::GetTickCount() - lastudpstattime) > UDPSERVERSTATTIME){
			lastudpstattime = ::GetTickCount();
d394 1
a394 1
		if ((!lastudpsearchtime) || (::GetTickCount() - lastudpsearchtime) > UDPSERVERREASKTIME)
d398 1
d401 1
a401 1
	if(m_lastPartFileStatsSave+5*60*1000 < GetTickCount())
d403 1
a403 1
		m_lastPartFileStatsSave=GetTickCount();
@


1.5
log
@2.5 bugfixes
@
text
@d506 1
a506 1
	if ((sender->GetStatus()==PS_PAUSED && sender->GetSourceCount==0) || sender->GetStatus()==PS_COMPLETING || sender- >GetStatus()==PS_COMPLETE)
@


1.4
log
@TRY/CATCH small fix
@
text
@d505 4
d518 1
a518 1
	} 
@


1.3
log
@updated to .25b codebase
@
text
@d319 1
a319 1
    EMULE_TRY
d406 1
a406 1
    EMULE_TRY
@


1.2
log
@update to .25b codebase
@
text
@d40 2
a41 1
	for (POSITION pos = filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos)){
d46 1
d50 1
d65 1
d72 1
d183 1
d187 1
d197 1
d201 1
d210 1
d214 1
d221 1
d225 1
d246 1
d251 1
d266 1
d272 1
d288 1
d294 1
d299 1
d308 1
d319 2
d323 3
a325 1
void CDownloadQueue::AddDownload(CPartFile* newfile) {
d342 1
d345 3
a347 1
bool CDownloadQueue::IsFileExisting(uchar* fileid){
d359 1
d364 3
a366 1
void CDownloadQueue::Process(){
d406 1
d411 7
a417 5
		for (POSITION pos =filelist.GetHeadPosition();pos != 0;filelist.GetNext(pos))
		{
			CPartFile* cur_file =  filelist.GetAt(pos);
			cur_file->SavePartFileStats();
		}
d420 3
a422 1
CPartFile*	CDownloadQueue::GetFileByID(uchar* filehash){
d427 1
d431 3
a433 1
bool CDownloadQueue::IsPartFile(void* totest){
d437 1
d441 3
a443 1
void CDownloadQueue::CheckAndAddSource(CPartFile* sender,CUpDownClient* source, bool saveSources){
d499 1
d502 3
a504 1
BOOL CDownloadQueue::CheckAndAddKnownSource(CPartFile* sender,CUpDownClient* source){
d544 2
d548 3
a550 1
bool CDownloadQueue::RemoveSource(CUpDownClient* toremove, bool	updatewindow){
d570 2
d574 3
a576 1
void CDownloadQueue::RemoveFile(CPartFile* toremove){
d583 1
d586 3
a588 1
void CDownloadQueue::DeleteAll(){
d598 1
d601 3
a603 1
bool CDownloadQueue::SendNextUDPPacket(){
d653 2
d657 3
a659 1
void CDownloadQueue::StopUDPRequests(){
d663 1
d666 6
a671 4
void CDownloadQueue::SortByPriority(){
   POSITION pos1, pos2;
   uint16 i = 0;
   for( pos1 = filelist.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
d686 1
d689 3
a691 1
void CDownloadQueue::GetDownloadStats(int results[]) {
d701 1
d704 3
a706 1
CUpDownClient* CDownloadQueue::GetDownloadClientByIP(uint32 dwIP){
d715 1
d719 3
a721 2
void CDownloadQueue::GetDownloadStats(int results[],uint64& pui64TotFileSize,uint64& pui64TotBytesLeftToTransfer,uint64& pui64TotNeededSpace) {
	
d740 1
d742 1
d746 1
d748 2
d754 1
d763 2
d773 1
d784 2
d790 1
d792 2
@


1.1
log
@*** empty log message ***
@
text
@d33 3
a35 2

	TRACE("filelist: %p-%d\r\n", &filelist, sizeof(filelist));
d47 19
a200 1

d212 23
d402 6
d460 2
d537 4
d572 1
a572 1
						TRACE("finished");
@

