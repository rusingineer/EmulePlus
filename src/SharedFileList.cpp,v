head	1.150;
access;
symbols
	PublicRelease_1_2e:1.148
	Interim_Release_1-2e_RC1:1.148
	PublicRelease_1_2d:1.146
	Interim_Release_1-2d_RC1:1.146
	Interim_Release_1-2d_beta1:1.143
	PublicRelease_1_2c:1.140
	Interim_Release_1-2c_RC1:1.140
	Interim_Release_1-2c_beta1:1.138
	PublicRelease_1_2b:1.137
	Interim_Release_1-2b_RC1:1.137
	PublicRelease_1_2a:1.136
	Interim_Release_1-2a_RC1:1.136
	Interim_Release_1-2a_beta2:1.132
	Interim_Release_1-2a_beta1:1.130
	PublicRelease_1_2:1.128
	Interim_Release_1-2_RC1:1.128
	Interim_Release_1-2_beta1:1.127
	PublicRelease_1_1g:1.125
	Interim_Release_1-1g_RC3:1.125
	Interim_Release_1-1g_RC2:1.124
	Interim_Release_1-1g_RC1:1.124
	Interim_Release_1-1g_beta2:1.122
	Interim_Release_1-1g_beta1:1.118
	PublicRelease_1_1f:1.116
	Interim_Release_1-1f_RC1:1.116
	PublicRelease_1_1e:1.116
	Interim_Release_1-1e_RC2:1.116
	Interim_Release_1-1e_RC1:1.116
	Interim_Release_1-1e_beta1:1.113
	PublicRelease_1_1d:1.110
	Interim_Release_1-1d_RC1:1.110
	PublicRelease_1_1c:1.110
	Interim_Release_1-1c_RC1:1.107
	Interim_Release_1-1c_beta2:1.105
	Interim_Release_1-1c_beta1:1.99
	PublicRelease_1_1b:1.99
	Interim_Release_1-1b_RC1:1.99
	PublicRelease_1_1a:1.99
	Interim_Release_1-1a_RC2:1.99
	Interim_Release_1-1a_RC1:1.97
	Interim_Release_1-1a_beta2:1.97
	Interim_Release_1-1a_beta1:1.97
	PublicRelease_1_1:1.97
	Interim_Release_1-1_beta1:1.96
	PublicRelease_1o:1.95
	Interim_Release_1o_RC1:1.95
	Interim_Release_1o_beta1:1.94
	PublicRelease_1n:1.94
	Interim_Release_1n_RC2:1.94
	Interim_Release_1n_RC1:1.94
	Interim_Release_1n_beta2:1.93
	Interim_Release_1n_beta1:1.92
	PublicRelease_1m:1.91
	Interim_Release_1m_beta1:1.91
	PublicRelease_1l:1.91
	Interim_Release_1l_RC3:1.91
	Interim_Release_1l_RC2:1.90
	Interim_Release_1l_RC1:1.90
	Interim_Release_1l_beta2:1.90
	Interim_Release_1l_beta1:1.89
	PublicRelease_1k:1.85
	Interim_Release_1k_RC4:1.85
	Interim_1k_RC3:1.84
	Interim_1k_RC2:1.84
	Interim_Release_1k_RC1:1.83
	Interim_Release_1k_beta5:1.82
	Intrerim_Release_1k_beta4:1.82
	Interim_Release_1k_beta1:1.76
	PublicRelease_1j:1.71
	Interim_Release_1J_RC3:1.71
	Interim_Release_1j_RC3:1.71
	Interim_Release_1j_RC2:1.71
	Interim_Release_1j_RC1:1.71
	Interim_Release_1j_beta2:1.71
	Interim_Release_1j_beta1:1.70
	PublicRelease_1i:1.68
	Interim_Release_1i_RC6:1.68
	Interim_Release_1i_RC3:1.67
	Interim_Release_1i_RC2:1.64
	Interim_Release_1i_RC1:1.60
	Interim_Release_1i_beta3:1.60
	Interim_Release_1i_beta2:1.57
	Interim_Release_1i_beta1:1.48
	PublicRelease_1h:1.36
	Interim_Release_1h_rc2:1.35
	Interim_Release_1h_RC1:1.35
	Interim_Release_1h_beta2:1.34
	Interim_Release_1h_beta1_now:1.33
	Interim_Release_1h_beta1:1.33
	PublicRelease_1g:1.30
	Interim_Release_1g_RC6_Final:1.30
	Interim_Release_1g_RC6:1.30
	Interim_Release_1g_RC5:1.30
	Interim_Release_1g_RC4:1.30
	Interim_Release_1g_RC3:1.30
	Interim_Release_1g_beta2:1.25
	Interim_Release_1g_beta1:1.23
	Interim_Release_1f_RC4:1.19
	Interim_Release_1f_RC3:1.19
	Interim_Release_1f_RC2:1.19
	Interim_Release_1f_RC:1.19
	Interim_Release_1f_beta2:1.19
	Interim_Release_1f_beta1:1.19
	PublicRelease_1e:1.18
	Interim_Release_1e_RC2:1.18
	Interim_Release_1e_RC:1.18
	Interim_Release_1e_beta3:1.17
	Interim_Release_1e_beta2:1.17
	Interim_Release_1e_beta2_before_kuchin:1.17
	Interim_Release_1e_beta1:1.17
	PublicRelease_1c:1.14
	featurestest:1.14.0.2
	Interim_Release_1c_RC:1.14
	Interim_Release_1c_beta2:1.14
	Interim_Release_1c_beta1:1.10
	threaded_downloadqueue:1.9.0.2
	PublicRelease_1b:1.6
	Interim_Release_1b_beta2:1.6
	Interim_Release_1b_beta1:1.6
	proxydeadlake:1.5.0.4
	PublicRelease_1a:1.5
	Interim_Release_1a_beta2:1.5
	BerkeleyDb:1.5.0.2
	Interim_Release_1a_beta1:1.5
	PublicRelease_1:1.5
	goldfish:1.5
	eMulePlus_1_RC2:1.5
	eMulePlus_26b_1RC1:1.5
	PreRelease_26b_i0e:1.5
	before_26d_merge:1.5
	Interim_Release_26b_i0d:1.4
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.150
date	2009.10.28.04.34.59;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.147;

1.147
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.146;

1.146
date	2008.04.16.04.26.42;	author aw3;	state Exp;
branches;
next	1.145;

1.145
date	2008.02.27.04.16.10;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2008.02.26.17.26.47;	author kush_eplus;	state Exp;
branches;
next	1.143;

1.143
date	2008.01.31.22.50.31;	author eklmn;	state Exp;
branches;
next	1.142;

1.142
date	2007.12.05.22.02.48;	author eklmn;	state Exp;
branches;
next	1.141;

1.141
date	2007.09.27.14.28.55;	author fuxie-dk;	state Exp;
branches;
next	1.140;

1.140
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.139;

1.139
date	2007.07.03.03.58.23;	author aw3;	state Exp;
branches;
next	1.138;

1.138
date	2007.02.14.14.21.02;	author aw3;	state Exp;
branches;
next	1.137;

1.137
date	2006.10.22.12.08.23;	author kush_eplus;	state Exp;
branches;
next	1.136;

1.136
date	2006.09.05.01.10.47;	author aw3;	state Exp;
branches;
next	1.135;

1.135
date	2006.07.29.02.00.11;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2006.07.14.04.46.42;	author aw3;	state Exp;
branches;
next	1.133;

1.133
date	2006.06.22.03.05.48;	author aw3;	state Exp;
branches;
next	1.132;

1.132
date	2006.05.22.03.45.00;	author aw3;	state Exp;
branches;
next	1.131;

1.131
date	2006.05.13.04.45.27;	author aw3;	state Exp;
branches;
next	1.130;

1.130
date	2006.04.16.23.13.48;	author aw3;	state Exp;
branches;
next	1.129;

1.129
date	2006.03.04.04.29.52;	author aw3;	state Exp;
branches;
next	1.128;

1.128
date	2006.02.19.22.16.16;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2005.12.29.05.34.52;	author aw3;	state Exp;
branches;
next	1.126;

1.126
date	2005.12.25.05.45.24;	author aw3;	state Exp;
branches;
next	1.125;

1.125
date	2005.12.18.05.48.23;	author aw3;	state Exp;
branches;
next	1.124;

1.124
date	2005.11.27.22.11.50;	author eklmn;	state Exp;
branches;
next	1.123;

1.123
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.122;

1.122
date	2005.11.27.09.12.30;	author eklmn;	state Exp;
branches;
next	1.121;

1.121
date	2005.11.26.10.33.00;	author eklmn;	state Exp;
branches;
next	1.120;

1.120
date	2005.10.09.05.53.47;	author aw3;	state Exp;
branches;
next	1.119;

1.119
date	2005.09.11.01.00.24;	author aw3;	state Exp;
branches;
next	1.118;

1.118
date	2005.08.06.18.00.25;	author aw3;	state Exp;
branches;
next	1.117;

1.117
date	2005.08.04.03.23.15;	author aw3;	state Exp;
branches;
next	1.116;

1.116
date	2005.06.20.03.02.56;	author aw3;	state Exp;
branches;
next	1.115;

1.115
date	2005.06.12.02.10.53;	author aw3;	state Exp;
branches;
next	1.114;

1.114
date	2005.06.07.03.50.32;	author aw3;	state Exp;
branches;
next	1.113;

1.113
date	2005.06.06.04.45.56;	author aw3;	state Exp;
branches;
next	1.112;

1.112
date	2005.05.23.20.55.45;	author aw3;	state Exp;
branches;
next	1.111;

1.111
date	2005.04.21.03.07.43;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2005.02.28.00.51.53;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2005.02.27.20.17.48;	author kush_eplus;	state Exp;
branches;
next	1.108;

1.108
date	2005.02.25.04.39.37;	author aw3;	state Exp;
branches;
next	1.107;

1.107
date	2005.02.22.22.30.24;	author netwolf1;	state Exp;
branches;
next	1.106;

1.106
date	2005.02.17.17.41.59;	author kuchin;	state Exp;
branches;
next	1.105;

1.105
date	2005.02.16.05.10.11;	author aw3;	state Exp;
branches;
next	1.104;

1.104
date	2005.02.13.22.56.27;	author aw3;	state Exp;
branches;
next	1.103;

1.103
date	2005.02.05.13.57.12;	author kuchin;	state Exp;
branches;
next	1.102;

1.102
date	2005.02.04.23.41.56;	author aw3;	state Exp;
branches;
next	1.101;

1.101
date	2005.02.04.19.21.14;	author aw3;	state Exp;
branches;
next	1.100;

1.100
date	2005.02.04.09.38.19;	author kuchin;	state Exp;
branches;
next	1.99;

1.99
date	2004.12.06.19.32.20;	author dongato;	state Exp;
branches;
next	1.98;

1.98
date	2004.12.06.13.57.44;	author dongato;	state Exp;
branches;
next	1.97;

1.97
date	2004.10.20.17.08.06;	author aw3;	state Exp;
branches;
next	1.96;

1.96
date	2004.10.14.05.19.26;	author aw3;	state Exp;
branches;
next	1.95;

1.95
date	2004.09.27.01.52.11;	author aw3;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.93;

1.93
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.92;

1.92
date	2004.06.30.13.38.42;	author dongato;	state Exp;
branches;
next	1.91;

1.91
date	2004.06.04.15.54.23;	author dongato;	state Exp;
branches;
next	1.90;

1.90
date	2004.05.19.10.14.29;	author netwolf1;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.24.23.01.07;	author aw3;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.21.05.15.31;	author aw3;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.16.17.53.10;	author aw3;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.15.17.07.57;	author aw3;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.07.00.02.29;	author aw3;	state Exp;
branches;
next	1.84;

1.84
date	2004.03.31.08.05.09;	author eklmn;	state Exp;
branches;
next	1.83;

1.83
date	2004.03.25.09.17.18;	author eklmn;	state Exp;
branches;
next	1.82;

1.82
date	2004.03.21.20.07.11;	author kush_eplus;	state Exp;
branches;
next	1.81;

1.81
date	2004.03.20.12.32.10;	author eklmn;	state Exp;
branches;
next	1.80;

1.80
date	2004.03.16.18.45.10;	author kush_eplus;	state Exp;
branches;
next	1.79;

1.79
date	2004.03.12.06.09.18;	author aw3;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.11.04.56.49;	author aw3;	state Exp;
branches;
next	1.77;

1.77
date	2004.02.26.11.49.59;	author kush_eplus;	state Exp;
branches;
next	1.76;

1.76
date	2004.02.16.23.18.30;	author aw3;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.05.00.00.02;	author kush_eplus;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.02.16.08.06;	author kush_eplus;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.04.15.13.17;	author dongato;	state Exp;
branches;
next	1.70;

1.70
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.69;

1.69
date	2003.12.10.17.14.14;	author kuchin;	state Exp;
branches;
next	1.68;

1.68
date	2003.11.21.20.24.58;	author eklmn;	state Exp;
branches;
next	1.67;

1.67
date	2003.11.19.16.51.47;	author kuchin;	state Exp;
branches;
next	1.66;

1.66
date	2003.11.19.11.36.37;	author kuchin;	state Exp;
branches;
next	1.65;

1.65
date	2003.11.19.09.23.29;	author kuchin;	state Exp;
branches;
next	1.64;

1.64
date	2003.11.17.13.55.52;	author dongato;	state Exp;
branches;
next	1.63;

1.63
date	2003.11.17.10.24.29;	author kuchin;	state Exp;
branches;
next	1.62;

1.62
date	2003.11.10.11.54.40;	author kuchin;	state Exp;
branches;
next	1.61;

1.61
date	2003.11.05.18.03.28;	author netwolf1;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.31.06.47.00;	author eklmn;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.28.12.07.56;	author katsyonak;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.24.21.13.15;	author morevit;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.24.10.52.28;	author eklmn;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.20.15.51.38;	author eklmn;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.08.15.39.48;	author morevit;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.08.12.59.40;	author morevit;	state Exp;
branches;
next	1.49;

1.49
date	2003.10.08.01.53.33;	author morevit;	state Exp;
branches;
next	1.48;

1.48
date	2003.10.02.00.58.14;	author morevit;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.01.23.56.46;	author netwolf1;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.01.20.07.13;	author netwolf1;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.29.14.55.46;	author morevit;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.29.13.12.40;	author dongato;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.29.10.57.22;	author dongato;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.24.10.46.05;	author morevit;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.23.16.52.50;	author morevit;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.22.16.40.22;	author morevit;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.17.11.14.24;	author netwolf1;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.07.14.55.29;	author zegzav;	state Exp;
branches;
next	1.34;

1.34
date	2003.08.24.20.28.04;	author zegzav;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.10.16.42.02;	author kuchin;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.04.21.24.38;	author zegzav;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.23.21.55.16;	author partyckip;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.22.12.12.28;	author partyckip;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.21.19.32.20;	author partyckip;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.21.18.37.57;	author partyckip;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.10.09.36.47;	author kuchin;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.08.07.36.58;	author partyckip;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.06.20.37.18;	author partyckip;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.30.21.26.59;	author partyckip;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.29.04.45.19;	author partyckip;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.27.04.24.12;	author partyckip;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.26.21.24.49;	author partyckip;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.30.11.37.57;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.26.17.36.14;	author ultras;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.09.14.03.35;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.31.12.25.12;	author partyckip;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.27.09.39.43;	author recdvst;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.20.20.10.57;	author lord_kiron;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2003.03.17.20.16.32;	author lord_kiron;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.17.20.07.56;	author lord_kiron;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.15.19.41.52;	author lord_kiron;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.15.16.35.57;	author cax2;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.14.16.24.21;	author partyckip;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.13.21.57.23;	author partyckip;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.11.09.53.21;	author lord_kiron;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.03.22.09.51;	author moosetea;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.16.22.01.48;	author lord_kiron;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.13.14.57.48;	author obaldin;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.17.27.12;	author cax2;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2003.01.21.18.21.23;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.26;	author cax2;	state Exp;
branches;
next	;

1.2.4.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.14.2.1
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.150
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "updownclient.h"
#include "SharedFileList.h"
#include "KnownFileList.h"
#include "UploadQueue.h"
#include "server.h"
#include "packets.h"
#include "otherfunctions.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef NEW_SOCKETS_ENGINE
	#include "Engine/Files/TaskProcessorFiles.h"
	#include "FileHashControl.h"
#endif //NEW_SOCKETS_ENGINE

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifndef NEW_SOCKETS_ENGINE
CSharedFileList::CSharedFileList(CPreferences *pPrefs, CServerConnect *pServerConnect, CKnownFileList *pKnownFileList)
{
	m_pPrefs = pPrefs;
	m_pServerConnect = pServerConnect;
	m_pKnownFileList = pKnownFileList;
	m_pOutput = NULL;
	m_dwLastPublishED2KTime = 0;
	m_bLastPublishED2KFlag = true;
	m_pCurrentlyHashing = NULL;

	CSingleLock		sLock(&m_mutexList,true);

	m_mapSharedFiles.InitHashTable(1021);

	sLock.Unlock();

	FindSharedFiles();
}
#else
CSharedFileList::CSharedFileList(CPreferences *pPrefs, CKnownFileList *pKnownFileList)
{
	m_pPrefs = pPrefs;
	m_pKnownFileList = pKnownFileList;
	m_dwLastPublishED2KTime = 0;
	m_bLastPublishED2KFlag = true;
	m_pCurrentlyHashing = NULL;

	CSingleLock		sLock(&m_mutexList,true);

	m_mapSharedFiles.InitHashTable(1021);

	sLock.Unlock();

	FindSharedFiles();
}
#endif //NEW_SOCKETS_ENGINE
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSharedFileList::~CSharedFileList()
{
	m_pCurrentlyHashing = NULL;
	while (!m_waitingForHashList.IsEmpty())
		delete m_waitingForHashList.RemoveTail();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	NextLANBroadcast() broadcasts the next hash for LANCast
void CSharedFileList::NextLANBroadcast()
{
#ifndef NEW_SOCKETS_ENGINE
	if (g_App.m_app_state != g_App.APP_STATE_RUNNING)
		return;

	CSingleLock		sLock(&m_mutexList,true);

	if (!m_mapSharedFiles.IsEmpty())
	{
		CSharedFilesMap::CPair	*pCurVal = NULL;

		if (m_LancastKey.m_key != NULL)
			pCurVal = m_mapSharedFiles.PGetNextAssoc(m_mapSharedFiles.PLookup(m_LancastKey));

		if (pCurVal == NULL)
			pCurVal = m_mapSharedFiles.PGetFirstAssoc();

		if (pCurVal->value != NULL)
			m_LanCast.BroadcastHash(pCurVal->value);

		m_LancastKey = pCurVal->key;
	}
//	m_mutexList is unlocked here
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FindSharedFiles() adds all the files in the shared directories list to the known file list and the
//		shared files map
void CSharedFileList::FindSharedFiles()
{
	CSingleLock		sLock1(&m_mutexList,true); // list thread safe

	if (!m_mapSharedFiles.IsEmpty())
	{
		CCKey			bufKey;
		CKnownFile	   *pKnownFile = NULL;

		POSITION		pos = m_mapSharedFiles.GetStartPosition();

		while (pos != NULL)
		{
			m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
			pKnownFile->SetSharedFile(false);
		}
		m_mapSharedFiles.RemoveAll();

		sLock1.Unlock();

#ifndef NEW_SOCKETS_ENGINE
		g_App.m_pDownloadQueue->AddPartFilesToShare();
#endif //NEW_SOCKETS_ENGINE
	}
	else
		sLock1.Unlock();

//	If the Incoming directory isn't shared yet...
	if (m_pPrefs->SharedDirListCheckAndAdd(m_pPrefs->GetIncomingDir(), false))
	{
		AddFilesFromDirectory(m_pPrefs->GetIncomingDir());
	}

	CStringList	tmpSharedDirList;	//	list elements will be deleted in list destructor

//	Make local copy to prevent long locking of list resource
	m_pPrefs->SharedDirListCopy(&tmpSharedDirList);
	for (POSITION pos = tmpSharedDirList.GetHeadPosition(); pos != NULL;)
	{
		AddFilesFromDirectory(tmpSharedDirList.GetNext(pos));
	}

	int		iSharedCnt = m_mapSharedFiles.GetCount();
	int		iWaitCnt = m_waitingForHashList.GetCount();

#ifndef NEW_SOCKETS_ENGINE
	if (iWaitCnt == 0)
		AddLogLine(0, IDS_SHAREDFOUND, iSharedCnt);
	else
		AddLogLine(0, IDS_SHAREDFOUNDHASHING, iSharedCnt, iWaitCnt);
#endif //NEW_SOCKETS_ENGINE

	BuildSharedVDirForList(&tmpSharedDirList);
	HashNextFile();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsHashing() checks to see if the spec'd file is already in the waiting for hash list
bool CSharedFileList::IsHashing(const CString &strDirectory, const CString &strFileName)
{
	bool		bFound = false;

	for (POSITION pos = m_waitingForHashList.GetHeadPosition(); pos != NULL;)
	{
		UnknownFile_Struct		*pUnknownFile = reinterpret_cast<UnknownFile_Struct*>(m_waitingForHashList.GetNext(pos));

		if ( (pUnknownFile->m_strFileName.CompareNoCase(strFileName) == 0) &&
			(pUnknownFile->m_strDirectory.CompareNoCase(strDirectory) == 0) )
		{
			bFound = true;
			break;
		}
	}

	return bFound;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::RemoveFromHashing(CKnownFile *pHashed)
{
	if (m_pCurrentlyHashing != NULL)
	{
		POSITION	pos = m_waitingForHashList.Find(m_pCurrentlyHashing);

		if (pos != NULL)
		{
			if ( (m_pCurrentlyHashing->m_strFileName.CompareNoCase(pHashed->GetFileName()) == 0) &&
				(m_pCurrentlyHashing->m_strDirectory.CompareNoCase(pHashed->GetPath()) == 0) )
			{
				m_waitingForHashList.RemoveAt(pos);
				delete m_pCurrentlyHashing;
				m_pCurrentlyHashing = NULL;
				HashNextFile();		// start next hash if possible, but only if a previous hash finished
			}
		}
		else
			m_pCurrentlyHashing = NULL;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::FileHashingFailed(UnknownFile_Struct *pHashed)
{
	AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_FAILEDTOHASH, pHashed->m_strDirectory, pHashed->m_strFileName);
	if (m_pCurrentlyHashing != NULL)
	{
		POSITION	pos = m_waitingForHashList.Find(m_pCurrentlyHashing);

		if (pos != NULL)
		{
			if ( (m_pCurrentlyHashing->m_strFileName.CompareNoCase(pHashed->m_strFileName) == 0) &&
				(m_pCurrentlyHashing->m_strDirectory.CompareNoCase(pHashed->m_strDirectory) == 0) )
			{
				m_waitingForHashList.RemoveAt(pos);
				delete m_pCurrentlyHashing;
				m_pCurrentlyHashing = NULL;
				HashNextFile();		// start next hash if possible, but only if a previous hash finished
			}
		}
		else
			m_pCurrentlyHashing = NULL;
	}
	delete pHashed;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AddFilesFromDirectory() adds all the files in the spec'd directory to the known files list and the
//		shared files map.
void CSharedFileList::AddFilesFromDirectory(const CString &strDirectory)
{
	static const TCHAR s_apcForbiddenExt[][9] =
	{
		_T("part"), _T("met"), _T("settings"), _T("bak"), _T("txtsrc"),
		_T("stats"), _T("dir"), _T("dll"), _T("sys"), _T("drv"), _T("tmp"),
		_T("log"), _T("getright"), _T("jc!"), _T("ds_store"), _T("$$$"),
		_T("ini"), _T("lnk"), _T("pif"), _T("vbs"), _T("vbe")
	};
	ULONGLONG	qwFileSz;
	CFileFind	ff;
	CString		strName;
	bool		bEnd;
	int			iIdxExt;

	strName.Format(_T("%s\\*"), strDirectory);
	bEnd = !ff.FindFile(strName, 0);
	if (bEnd)
		return;

	CString		strExtension;

	while (!bEnd)
	{
		bEnd = !ff.FindNextFile();
		if ( ff.IsDirectory() || ff.IsDots() || ff.IsSystem() || ff.IsTemporary() ||
			((qwFileSz = ff.GetLength()) == 0) || (qwFileSz > MAX_EMULE_FILE_SIZE) )
			continue;

		CTime		lastWriteTime;

		ff.GetLastWriteTime(lastWriteTime);

		uint32	dwFileDate = static_cast<uint32>(lastWriteTime.GetTime());

		AdjustNTFSDaylightFileTime(&dwFileDate, ff.GetFilePath());
		strName = ff.GetFileName();

		if ((iIdxExt = strName.ReverseFind(_T('.'))) >= 0)
		{
			unsigned	ui;

			strExtension = strName.Mid(iIdxExt + 1);
			strExtension.MakeLower();

			for (ui = 0; ui < ARRSIZE(s_apcForbiddenExt); ui++)
			{
				if (strExtension.Compare(reinterpret_cast<const TCHAR*>(&s_apcForbiddenExt[ui])) == 0)
					break;
			}
		//	A file is one of the type we don't want to share...
			if (ui != ARRSIZE(s_apcForbiddenExt))
				continue;
		}

		CKnownFile	   *pKnownFile = m_pKnownFileList->FindKnownFile(strName, dwFileDate, qwFileSz);

	//	If the file is already known...
		if (pKnownFile != NULL)
		{
			strName = ff.GetFilePath();
			if (AddFile(pKnownFile, strName))
			{
				pKnownFile->SetPath(strDirectory);
				pKnownFile->SetFilePath(strName);
				m_bLastPublishED2KFlag = true;
			}
		}
	//	If the file is not in the known list...
		else
		{
		//	Start a thread to hash the new file
		//	If the spec'd file isn't already in the list (avoid duplications due to overlapping share paths)
			if (!IsHashing(strDirectory, strName))
			{
				UnknownFile_Struct	*pUnknownFile = new UnknownFile_Struct;

				pUnknownFile->m_strDirectory = strDirectory;
				pUnknownFile->m_strFileName = strName;
				m_waitingForHashList.AddTail(pUnknownFile);
			}
		}
	}
	ff.Close();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SafeAddKnownFile() shares a new file.
//		Params:
//			pNewKnownFile - file object to add;
//			bOnlyAdd      - add a file to shared files map but don't offer to the server;
//			bDelay        - delay publishing a little trying to reduce a number of packets.
void CSharedFileList::SafeAddKnownFile(CKnownFile *pNewKnownFile, bool bOnlyAdd/*=false*/, bool bDelay/*=false*/)
{
	EMULE_TRY

	if (pNewKnownFile == NULL)
		return;

	RemoveFromHashing(pNewKnownFile);	// hashed ok, remove from list if it was in the list

	bool	bAdded = AddFile(pNewKnownFile, pNewKnownFile->GetFilePath());

//	If we're just to add the file and not advertise it, return
	if (bOnlyAdd)
		return;
//	Update the SharedFiles window if it's open
#ifndef NEW_SOCKETS_ENGINE
	if (bAdded && (m_pOutput != NULL))
		m_pOutput->AddFile(pNewKnownFile);
#endif //NEW_SOCKETS_ENGINE
	if (bDelay)
	{
	//	Delay publishing a little to avoid double publishing of small files as well
	//	as to increase a chance of buffering of several publish requests in one packet
		m_dwLastPublishED2KTime = ::GetTickCount();
	}
	m_bLastPublishED2KFlag = true;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RepublishFile() republishes a file on the server to update server statistics
void CSharedFileList::RepublishFile(CKnownFile *pFile, int iMode)
{
	CServer	*pCurServer = m_pServerConnect->GetCurrentServer();

//	Republish only if a server supports a feature (e.g. complete sources, file rating, etc.)
	if ((pCurServer != NULL) && (pCurServer->GetTCPFlags() & iMode))
	{
		m_bLastPublishED2KFlag = true;
		pFile->SetPublishedED2K(false);
		UpdateItem(pFile, false);	// update item in the list
	//	This information is not critical, so delay publishing a little
	//	to increase a chance of buffering of several publish requests in one packet
		m_dwLastPublishED2KTime = ::GetTickCount();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSharedFileList::AddFile(CKnownFile *pKnownFile, const TCHAR *pcFullName)
{
	CCKey			bufKey(pKnownFile->GetFileHash());
	CKnownFile		*pResultFile;
	CSingleLock		sLock(&m_mutexList, true);

//	Check if the file is already known
	if (m_mapSharedFiles.Lookup(bufKey, pResultFile))
	{
		sLock.Unlock();
		AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Attempt to add duplicate shared files '%s' and '%s'"), pResultFile->GetFilePath(), pcFullName);
		return false;
	}

//	A file is being shared now
	pKnownFile->SetSharedFile(true);

//	Add a file to the shared files map
	m_mapSharedFiles.SetAt(CCKey(pKnownFile->GetFileHash()), pKnownFile);
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::FileHashingFinished(CKnownFile *pKnownFile)
{
//	File hashing has finished for a shared file (non partfile)
//	- reading shared directories at startup and hashing files which were not found in known.met
//	- reading shared directories during runtime (user hit Reload button, added a shared directory, ...)
	CKnownFile	*pFoundFile = GetFileByID(pKnownFile->GetFileHash());

	if (pFoundFile == NULL)
	{
		m_pKnownFileList->SafeAddKnownFile(pKnownFile);
		SafeAddKnownFile(pKnownFile);
		AddLogLine(LOG_RGB_DIMMED, IDS_HASBEENHASHED, pKnownFile->GetFileName(), GetWaitingForHashCount());
	}
	else
	{
		AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Duplicate shared files '%s' and '%s'"), pFoundFile->GetFilePath(), pKnownFile->GetFilePath());

		RemoveFromHashing(pKnownFile);
		delete pKnownFile;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RemoveFile() removes the first occurrence of 'pKnownFile' in the shared file list
void CSharedFileList::RemoveFile(CKnownFile *pKnownFile)
{
	pKnownFile->SetSharedFile(false);
#ifndef NEW_SOCKETS_ENGINE
	m_pOutput->RemoveFile(pKnownFile);
#endif //NEW_SOCKETS_ENGINE

	CSingleLock		sLock(&m_mutexList,true);

	m_mapSharedFiles.RemoveKey(CCKey(pKnownFile->GetFileHash()));
	m_pKnownFileList->RemoveFile(pKnownFile);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::Reload()
{
	FindSharedFiles();
#ifndef NEW_SOCKETS_ENGINE
	if (m_pOutput != NULL)
		m_pOutput->ShowFileList(this);
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::SetOutputCtrl(CSharedFilesCtrl *pSharedFilesCtrl)
{
#ifndef NEW_SOCKETS_ENGINE
	m_pOutput = pSharedFilesCtrl;
	m_pOutput->ShowFileList(this);
#endif //NEW_SOCKETS_ENGINE
	HashNextFile();		// if hashing not yet started, start it now
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
__inline uint32 GetRealPrio(byte byteIn)
{
	return (byteIn < 4) ? (byteIn + 1) : 0;
}

#define PUBLISH_MAX_FILES		200u
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::SendListToServer()
{
	EMULE_TRY

	m_dwLastPublishED2KTime = ::GetTickCount();
#ifdef OLD_SOCKETS_ENABLED
	CServer			*pCurServer;

	if (!m_pServerConnect->IsConnected() || ((pCurServer = m_pServerConnect->GetCurrentServer()) == NULL))
		return;

	CSingleLock		sLock(&m_mutexList, true);

	if (m_mapSharedFiles.IsEmpty())
		return;

	CCKey			bufKey;
	CKnownFile		*pKnownFile, *pListKFile;
	uint32			dwNumFiles, dwListNum, dwPrioPos2, dwPrioFile;
	POSITION		pos, pos2, pos3;
	CTypedPtrList<CPtrList, CKnownFile*>	sortedList(100);
	uint32			adwPrioDistrib[2 * 5];	//	double amount of all file priorities PR_VERYLOW..PR_RELEASE
	uint32			dwCnt, ui;

	memset(adwPrioDistrib, 0, sizeof(adwPrioDistrib));
//	For each shared file...
	for (dwListNum = 0, pos = m_mapSharedFiles.GetStartPosition(); pos != NULL;)
	{
		m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
	//	Take only files which should be (and can be) published
		if ( !pKnownFile->GetPublishedED2K() &&
			 (!pKnownFile->IsLargeFile() || pCurServer->SupportsLargeFilesTCP()) )
		{
			dwPrioFile = GetRealPrio(pKnownFile->GetULPriority()) + ((pKnownFile->IsPartFile()) ? (ARRSIZE(adwPrioDistrib) / 2) : 0);
		//	List sorting can take quite some time when it's long. We need only PUBLISH_MAX_FILES
		//	top files, so we keep priority distribution and drop file this time
		//	if it can't be in the first PUBLISH_MAX_FILES for sure
			if (++dwListNum > PUBLISH_MAX_FILES)
			{
				for (dwCnt = 0, ui = dwPrioFile; ui < ARRSIZE(adwPrioDistrib); ui++)
					dwCnt += adwPrioDistrib[ui];
				if (dwCnt >= PUBLISH_MAX_FILES)
					continue;
			}
			adwPrioDistrib[dwPrioFile]++;
		//	Perform an insertion sort into 'sortedList'
			for (pos2 = sortedList.GetHeadPosition(); ((pos3 = pos2) != NULL);)
			{
				pListKFile = sortedList.GetNext(pos2);
			//	Publish part files first to speed up downloading
				dwPrioPos2 = GetRealPrio(pListKFile->GetULPriority()) + ((pListKFile->IsPartFile()) ? (ARRSIZE(adwPrioDistrib) / 2) : 0);

			//	If the file we're inserting has a higher priority than the one from the sorted list
				if (dwPrioPos2 <= dwPrioFile)
				{
				//	Insert it before the current one in the sorted list
					sortedList.InsertBefore(pos3, pKnownFile);
					break;
				}
			}
		//	If we didn't find a file to add this one before, add it to the end of the list
			if (pos3 == NULL)
				sortedList.AddTail(pKnownFile);
		}
	}
	sLock.Unlock();

	dwNumFiles = pCurServer->GetSoftMaxFiles();

//	If a lot of file were added after the connection to the server, a warning won't be displayed
//	It be displayed on the next connection to the server, what is also fine
	if (((dwNumFiles != 0) && (dwNumFiles < dwListNum)) || ((dwNumFiles == 0) && (dwListNum > 1000)))
		AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_SHAREDWARNING, dwListNum);

	if ((dwNumFiles - 1u) > (PUBLISH_MAX_FILES - 1u))
		dwNumFiles = PUBLISH_MAX_FILES;

	if (dwListNum < dwNumFiles)
	{
		if ((dwNumFiles = dwListNum) == 0)
		{
			m_bLastPublishED2KFlag = false;		//	everything was published
			return;
		}
	}
//	Construct the byte stream for the OFFERFILES packet
	CMemFile		packetStream(4096);

	packetStream.Write(&dwNumFiles, sizeof(dwNumFiles));	// <count:DWORD> published file count

	AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Published %u file(s) on the server, %u remaining"), dwNumFiles, dwListNum - dwNumFiles);
	pos = sortedList.GetHeadPosition();
	do {
		pKnownFile = sortedList.GetNext(pos);
		WriteToOfferedFilePacket(pKnownFile, packetStream, pCurServer);	// (offered file info)[count]
		pKnownFile->SetPublishedED2K(true);
	} while(--dwNumFiles != 0);
//	Although only some items were change, redraw the whole list as it's faster this way
	UpdateItem(NULL, false);

	Packet		*pPacket = new Packet(&packetStream);

	pPacket->m_eOpcode = OP_OFFERFILES;
//	Always try to compress the packet
//   - this kind of data is highly compressable (N * (1 MD4 and plus 2 string meta data tags and 1 integer meta data tag))
//   - the minimum amount of data needed for one published file is ~60 bytes
//   - this function is called once when connecting to a server and when a file becomes shareable - so, it's called rarely
//   - if the compressed size is still >= the original size, we send the uncompressed packet
	if (pCurServer->GetTCPFlags() & SRV_TCPFLG_COMPRESSION)
		pPacket->PackPacket();

	g_App.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
	m_pServerConnect->SendPacket(pPacket, true);
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ClearED2KPublishInfo() resets file publishing information to allow overall republish
void CSharedFileList::ClearED2KPublishInfo()
{
	CKnownFile	*pKnownFile;
	CCKey		bufKey;
	CSingleLock	sLock(&m_mutexList, true);

	m_bLastPublishED2KFlag = true;
	for (POSITION pos = m_mapSharedFiles.GetStartPosition(); pos != 0;)
	{
		m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
		pKnownFile->SetPublishedED2K(false);
	}
	UpdateItem(NULL, false);	// redraw the whole list
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::WriteToOfferedFilePacket(CKnownFile *pKFile, CMemFile &packetStream,
											   CServer *pServer, CUpDownClient* pClient/*= NULL*/)
{
#ifdef OLD_SOCKETS_ENABLED
	packetStream.Write(pKFile->GetFileHash(), 16);		// <filehash 16>

	uint32		dwClientID = 0;
	uint16		uClientPort = 0;

	if ((pServer != NULL) && ((pServer->GetTCPFlags() & SRV_TCPFLG_COMPRESSION) != 0))
	{
		if (pKFile->IsPartFile())
		{
		//	Publishing an incomplete files
			dwClientID = 0xFCFCFCFC;
			uClientPort = 0xFCFC;
		}
		else
		{
		//	Publishing a complete files
			dwClientID = 0xFBFBFBFB;
			uClientPort = 0xFBFB;
		}
 	}
	else if (m_pServerConnect->IsConnected() && !m_pServerConnect->IsLowID())
	{	//	If connected and highID, set client ID and port
			dwClientID = m_pServerConnect->GetClientID();
			uClientPort = g_App.m_pPrefs->GetPort();
	}

	packetStream.Write(&dwClientID, 4);						// <clientid 4>
	packetStream.Write(&uClientPort, 2);					// <clientport 2>

	CWrTag	tagWr;
	uint32	dwNumType;
	CString	strFileType(pKFile->GetSearchFileType(&dwNumType));
	uint32	dwRating, dwTagFilePos, dwTagCnt = 0;
	ECodingFormat eCF = cfLocalCodePage;
	bool	bNewTags;

	dwTagFilePos = static_cast<uint32>(packetStream.GetPosition());
	packetStream.Write(&dwTagCnt, 4);						// <tagcount 4>

	bNewTags = ( ((pServer != NULL) && (pServer->GetTCPFlags() & SRV_TCPFLG_NEWTAGS)) ||
		( (pClient != NULL) && pClient->IsEmuleClient() &&
		( ((pClient->GetClientSoft() == SO_EMULE) && (pClient->GetVersion() >= FORM_CLIENT_VER(0, 42, 7))) ||
		((pClient->GetClientSoft() == SO_PLUS) && (pClient->GetVersion() > FORM_CLIENT_VER(1, 1, 0))) ) ) );

#ifdef _UNICODE
	if (((pServer != NULL) && (pServer->GetTCPFlags() & SRV_TCPFLG_UNICODE))
		|| ((pClient != NULL) && pClient->GetStrCodingFormat() == cfUTF8))
	{
		eCF = cfUTF8;
	}
#endif

//	There's no need to send FT_FILEFORMAT (file extension without ".") here as a server takes it from the file name

	if (bNewTags)
	{
		tagWr.WriteNewEd2kTag(FT_FILENAME, pKFile->GetFileName(), packetStream, eCF);
		dwTagCnt++;

	//	2*32bit tags are sent to servers, but a real 64bit tag to clients
		if ((pServer != NULL) || !pKFile->IsLargeFile())
		{
			tagWr.WriteNewEd2kTag(FT_FILESIZE, static_cast<uint32>(pKFile->GetFileSize()), packetStream);
			if (pKFile->IsLargeFile())
			{
				tagWr.WriteNewEd2kTag(FT_FILESIZE_HI, static_cast<uint32>(pKFile->GetFileSize() >> 32ui64), packetStream);
				dwTagCnt++;
			}
		}
		else
			tagWr.WriteNewEd2kTag(FT_FILESIZE, pKFile->GetFileSize(), packetStream);
		dwTagCnt++;

		if (!strFileType.IsEmpty())
		{
			if ((pServer != NULL) && (pServer->GetTCPFlags() & SRV_TCPFLG_TYPETAGINTEGER))
				tagWr.WriteNewEd2kTag(FT_FILETYPE, dwNumType, packetStream);
			else
				tagWr.WriteNewEd2kTag(FT_FILETYPE, strFileType, packetStream);
			dwTagCnt++;
		}
		dwRating = static_cast<uint32>(pKFile->GetFileRating());
	//	Send rating to client or server if server supports it (17.6+); also check for valid value
		if ( ( ((pServer == NULL) || ((pServer->GetTCPFlags() & SRV_TCPFLG_TYPETAGINTEGER) == 0)) &&
			(pClient == NULL) ) || (dwRating > PF_RATING_EXCELLENT) )
		{
			dwRating = 0;
		}
		if (dwRating != 0)	//	report file rating
		{
		//	Convert internal rating value into server rating value:
		//	0 - not rated; 1 - fake; 2 - poor; 3 - fair; 4 - good; 5 - excellent
			if ((dwRating == PF_RATING_GOOD) || (dwRating == PF_RATING_FAIR))
				dwRating = (~dwRating & 7);
			if (pClient != NULL)	//	Convert rating into format sent by servers
				dwRating *= (255 / 5/*RatingExcellent*/);
			tagWr.WriteNewEd2kTag(FT_FILERATING, dwRating, packetStream);
			dwTagCnt++;
		}
	}
	else
	{
		tagWr.WriteToFile(FT_FILENAME, pKFile->GetFileName(), packetStream, eCF);				// {FILENAME : string}
		dwTagCnt++;

	//	2*32bit tags are sent to servers, but a real 64bit tag to clients
		if ((pServer != NULL) || !pKFile->IsLargeFile())
		{
			tagWr.WriteToFile(FT_FILESIZE, static_cast<uint32>(pKFile->GetFileSize()), packetStream);
			if (pKFile->IsLargeFile())
			{
				tagWr.WriteToFile(FT_FILESIZE_HI, static_cast<uint32>(pKFile->GetFileSize() >> 32ui64), packetStream);
				dwTagCnt++;
			}
		}
		else if (pClient->SupportsLargeFiles())
			tagWr.WriteToFile(FT_FILESIZE, pKFile->GetFileSize(), packetStream, true);
		else
			tagWr.WriteToFile(FT_FILESIZE, 0, packetStream);
		dwTagCnt++;

		if (!strFileType.IsEmpty())
		{
			tagWr.WriteToFile(FT_FILETYPE, strFileType, packetStream);	// {FILETYPE : string}
			dwTagCnt++;
		}
	}
//	Save valid tag count
	packetStream.Seek(dwTagFilePos, CFile::begin);
	packetStream.Write(&dwTagCnt, 4);
	packetStream.SeekToEnd();
#endif //OLD_SOCKETS_ENABLED
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetDatasize() returns the size of the largest shared file in 'qwLargest' and returns
//		the total size of all shared files as its result.
uint64 CSharedFileList::GetDatasize(uint64 *pqwLargest)
{
	*pqwLargest = 0;

	uint64			qwFilesTotalBytes = 0;
	CCKey			bufKey;
	CKnownFile	   *pKnownFile;

	CSingleLock		sLock(&m_mutexList, true);

	for (POSITION pos = m_mapSharedFiles.GetStartPosition(); pos != NULL;)
	{
		m_mapSharedFiles.GetNextAssoc(pos,bufKey,pKnownFile);
		qwFilesTotalBytes += pKnownFile->GetFileSize();
	//	If this file is bigger than all the others...
		if (pKnownFile->GetFileSize() > *pqwLargest)
			*pqwLargest = pKnownFile->GetFileSize();
	}

	return qwFilesTotalBytes;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetFileByID() returns the Known File with hash 'pbyteFileHash' or NULL if there is none.
CKnownFile *CSharedFileList::GetFileByID(const uchar *pbyteFileHash)
{
	CKnownFile		*pResultFile;
	CCKey			tKey(pbyteFileHash);
	CSingleLock		sLock(&m_mutexList, true);

	if ((pbyteFileHash != NULL) && m_mapSharedFiles.Lookup(tKey, pResultFile))
		return pResultFile;
	else
		return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::HashNextFile()
{
//	Wait for the dialog to be opened
	if ((g_App.m_pMDlg == NULL) || !::IsWindow(g_App.m_pMDlg->m_hWnd))
		return;
	if (g_App.m_pMDlg->IsRunning() && (m_pOutput != NULL))
		m_pOutput->ShowFilesCount();
	if (m_pCurrentlyHashing != NULL)	// one hash at a time
		return;
	if (m_waitingForHashList.IsEmpty())	//	If there're no files to hash, just return
		return;

	m_pCurrentlyHashing = m_waitingForHashList.GetHead();

#ifndef NEW_SOCKETS_ENGINE
	g_App.m_fileHashControl.AddToHash(m_pCurrentlyHashing->m_strDirectory, m_pCurrentlyHashing->m_strFileName);
#else
	g_stEngine.Files.FileHasher.AddToHash(this, m_pCurrentlyHashing->m_strDirectory, m_pCurrentlyHashing->m_strFileName);
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::UpdateItem(CKnownFile *pKnownFile, bool bResort/*=true*/)
{
#ifndef NEW_SOCKETS_ENGINE
	if (m_pOutput != NULL)
	{
		m_pOutput->PostMessage( WM_SFL_UPDATEITEM,
			static_cast<WPARAM>(bResort), reinterpret_cast<LPARAM>(pKnownFile) );
	}
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define INCOMPLETE_DIR		_T("!Incomplete Files")
#define SHARED_DIR			_T("!Shared Files")

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSharedFileList::AddSharedVDirForList(bool bIncomplete, const CString &strNewDir)
{
	EMULE_TRY
	// clean dir
	CString strDir(strNewDir);
	PathRemoveBackslash(strDir.GetBuffer());
	if (strDir.IsEmpty())
		return false;

	// check already added
	POSITION	pos = m_SharedVDirForList.GetStartPosition();

	while (pos != NULL)
	{
		CString strCurKey;
		CString strCurDir;
		m_SharedVDirForList.GetNextAssoc(pos, strCurKey, strCurDir);
		if (strCurDir.CompareNoCase(strDir) == 0)
			return false;
	}

	// set key
	CString strKey, strWantedKey;
	if (bIncomplete)
	{
		strWantedKey = INCOMPLETE_DIR;	// default name used by Hybrid for temp dir
	}
	else
	{
		strWantedKey = PathFindFileName((LPCTSTR)strDir);	// short name without complete path
		if ((strWantedKey.IsEmpty()) || ((strWantedKey.GetLength() > 1) && (strWantedKey[1] == ':')))
			strWantedKey = SHARED_DIR;
	}

	CString strDir0, strDir1;
	if ((m_SharedVDirForList.Lookup(strWantedKey, strDir0)) || (m_SharedVDirForList.Lookup(strWantedKey + _T(" (1)"), strDir1)))
	{
		// rename key 0
		if (!strDir0.IsEmpty())
		{
			m_SharedVDirForList[strWantedKey + _T(" (1)")] = strDir0;
			m_SharedVDirForList.RemoveKey(strWantedKey);
		}

		// build unique key
		unsigned ui = 2;
		do
		{
			strKey.Format(_T("%s (%u)"), strWantedKey, ui++);
		} while (m_SharedVDirForList.Lookup(strKey, strDir0));
	}
	else
		strKey = strWantedKey;
	m_SharedVDirForList[strKey] = strDir;

	return true;

	EMULE_CATCH
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::BuildSharedVDirForList(CStringList *sharedDirList)
{
	if (!m_pPrefs)
		return;

	m_SharedVDirForList.RemoveAll();

// Temp dirs
	AddSharedVDirForList(true, m_pPrefs->GetTempDir());

	CStringList	tmpTempDirList;	//	list elements will be deleted in list destructor

//	Make local copy to prevent long locking of list resource
	m_pPrefs->TempDirListCopy(&tmpTempDirList);

	POSITION	pos = tmpTempDirList.GetHeadPosition();

	while (pos != NULL)
		AddSharedVDirForList(true, tmpTempDirList.GetNext(pos));

	// incoming dir
	AddSharedVDirForList(false, m_pPrefs->GetIncomingDir());

	// shared dirs
	pos = sharedDirList->GetHeadPosition();
	while (pos != NULL)
		AddSharedVDirForList(false, sharedDirList->GetNext(pos));

	// category dirs
	for (int i = 0; i < CCat::GetNumCats(); i++)
		AddSharedVDirForList(false, CCat::GetCatPathByIndex(i));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSharedFileList::Process()
{
	if (!m_bLastPublishED2KFlag || ((::GetTickCount() - m_dwLastPublishED2KTime) < ED2KREPUBLISHTIME))
		return;
	SendListToServer();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CHashFileThread, CWinThread)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CHashFileThread::CHashFileThread()
{
	m_pPartFile = NULL;
	m_bChangeState = false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SetValues() sets the thread parameters
void CHashFileThread::SetValues(bool bChgState, LPCTSTR pcDir, LPCTSTR pcFilename, CPartFile *pPartFile)
{
	 m_bChangeState = bChgState;
	 m_strDirectory = pcDir;
	 m_strFileName = pcFilename;
	 m_pPartFile = pPartFile;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CHashFileThread::InitInstance()
{
	g_App.m_pPrefs->InitThreadLocale();
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CHashFileThread::Run()
{
#ifdef EP_SPIDERWEB
//	Setup Structured Exception handler for the this thread
	_set_se_translator(StructuredExceptionHandler);
#endif

//	If there is no PartFile owner or if there's no filename...
	if ((m_pPartFile != NULL) && !m_strFileName.IsEmpty())
	{
	//	Only one extensive hard drive access at a time to reduce I/O load
#ifndef NEW_SOCKETS_ENGINE
		CSingleLock sLock(&g_App.m_csPreventExtensiveHDAccess, TRUE);
#endif //NEW_SOCKETS_ENGINE

		CKnownFile	*pNewKnownFile = new CKnownFile();
		if (pNewKnownFile != NULL)
		{
		//	Notify regarding operation start to switch file state
			if (m_bChangeState && g_App.m_pMDlg)
				PostMessage(g_App.m_pMDlg->m_hWnd, TM_HASHINGSTARTED, (WPARAM)m_pPartFile, NULL);
		//	Try to create a hashed KnownFile for the spec'd file. If successful...
			if (pNewKnownFile->CreateFromFile(m_strDirectory, m_strFileName, true))
			{
			//	Notify the PartFile (via a message to the eMule window) that the file it was
			//		completing has finished hashing.
#ifndef NEW_SOCKETS_ENGINE
				if (g_App.m_pMDlg)
				{
					PostMessage( g_App.m_pMDlg->m_hWnd, TM_FINISHEDHASHING,
						(WPARAM)m_pPartFile, (LPARAM)pNewKnownFile );
				}
#endif //NEW_SOCKETS_ENGINE
			}
			else
			{
				delete pNewKnownFile;
			}
		}

	//	m_csPreventExtensiveHDAccess is unlocked here
	}
	AfxEndThread(0, true);
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.149
log
@Reduced H-file dependency.
@
text
@d27 3
d129 1
a129 1
		while (pos!= NULL)
@


1.148
log
@Simplified logging system implementation.
@
text
@d23 1
@


1.147
log
@Reduced H-file dependency.
@
text
@d161 1
a161 1
		AddLogLine(false, IDS_SHAREDFOUND, iSharedCnt);
d163 1
a163 1
		AddLogLine(false, IDS_SHAREDFOUNDHASHING, iSharedCnt, iWaitCnt);
d214 1
a214 1
	AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_FAILEDTOHASH), pHashed->m_strDirectory, pHashed->m_strFileName);
d386 1
a386 1
		AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Attempt to add duplicate shared files '%s' and '%s'"), pResultFile->GetFilePath(), pcFullName);
d409 1
a409 1
		AddLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_HASBEENHASHED), pKnownFile->GetFileName(), GetWaitingForHashCount());
d413 1
a413 1
		AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Duplicate shared files '%s' and '%s'"), pFoundFile->GetFilePath(), pKnownFile->GetFilePath());
d532 1
a532 1
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_SHAREDWARNING), dwListNum);
d550 1
a550 1
	AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Published %u file(s) on the server, %u remaining"), dwNumFiles, dwListNum - dwNumFiles);
@


1.146
log
@Simplified shared files hashing thread [KuSh];
Preparations for comprehensive exception handling [Aw3].
@
text
@d20 1
@


1.145
log
@Proper resolution for the previous fix to consider that old clients don't support 64bit tags.
@
text
@d783 1
a783 1
	g_App.m_fileHashControl.AddToHash(this, m_pCurrentlyHashing->m_strDirectory, m_pCurrentlyHashing->m_strFileName);
d935 5
@


1.144
log
@Fix incorrect file size sent for large files in shared file list packets;
Suppressed compiler warning.
@
text
@d712 2
d715 1
a715 1
			tagWr.WriteToFile(FT_FILESIZE, pKFile->GetFileSize(), packetStream, true);
@


1.143
log
@changed the intialization of thread locale
@
text
@d270 1
a270 1
		uint32	dwFileDate = lastWriteTime.GetTime();
d713 1
a713 1
			tagWr.WriteToFile(FT_FILESIZE, pKFile->GetFileSize(), packetStream);
@


1.142
log
@added Unicode support for met-files
@
text
@d925 6
@


1.141
log
@Fixed messed waiting for hash and hashing file statuses in GUI and WebServer {Fuxie - DK} [Aw3];
Reduced #include dependency.
@
text
@d282 1
a282 1
			for (ui = 0; ui < ELEMENT_COUNT(s_apcForbiddenExt); ui++)
d288 1
a288 1
			if (ui != ELEMENT_COUNT(s_apcForbiddenExt))
d630 1
d641 8
d653 1
a653 1
		tagWr.WriteNewEd2kTag(FT_FILENAME, pKFile->GetFileName(), packetStream);
d699 1
a699 1
		tagWr.WriteToFile(FT_FILENAME, pKFile->GetFileName(), packetStream);				// {FILENAME : string}
@


1.140
log
@Reduced #include depedency.
@
text
@d19 1
d903 2
a904 1
	m_pOwner = NULL;
d908 1
a908 2
void CHashFileThread::SetValues(CSharedFileList *pOwner, LPCTSTR in_directory, LPCTSTR in_filename,
							    CPartFile *in_pPartFile)
d910 4
a913 4
	 m_pOwner = pOwner;
	 m_strDirectory = in_directory;
	 m_strFileName = in_filename;
	 m_pPartFile = in_pPartFile;
d918 2
a919 2
//	If there is neither a SharedFileList owner or a PartFile owner or if there's no filename...
	if ((m_pOwner || m_pPartFile) && !m_strFileName.IsEmpty())
d927 1
a927 1
		if (pNewKnownFile)
d929 3
d933 1
a933 1
			if (pNewKnownFile->CreateFromFile(m_strDirectory, m_strFileName, (m_pOwner == NULL)))
d941 1
a941 1
								(m_pOwner ? 0 : (WPARAM)m_pPartFile), (LPARAM)pNewKnownFile );
a946 11
#ifndef NEW_SOCKETS_ENGINE
				//	Notify main program of hash failure
				if (m_pOwner && g_App.m_pMDlg && g_App.m_pMDlg->IsRunning())
				{
					UnknownFile_Struct	*pHashed = new UnknownFile_Struct;

					pHashed->m_strDirectory = m_strDirectory;
					pHashed->m_strFileName = m_strFileName;
					PostMessage(g_App.m_pMDlg->m_hWnd, TM_HASHFAILED, 0, reinterpret_cast<LPARAM>(pHashed));
				}
#endif //NEW_SOCKETS_ENGINE
d953 1
a953 1
	AfxEndThread(0,true);
@


1.139
log
@Provide file rating to other clients with the list of shared files.
@
text
@d21 1
a23 1
#include <time.h>
@


1.138
log
@Fixed Shared Files List slow down while publishing a lot of files {Zom}.
@
text
@d601 1
a601 1
	if (pServer && (pServer->GetTCPFlags() & SRV_TCPFLG_COMPRESSION))
d616 2
a617 5
	else
	{
	//	If connected and highID, set client ID and port
		if (m_pServerConnect->IsConnected() && !m_pServerConnect->IsLowID())
		{
a619 1
		}
d669 3
a671 3
	//	Send rating only to server if server supports it (17.6+); also check for valid value
		if ( (pServer == NULL) || ((pServer->GetTCPFlags() & SRV_TCPFLG_TYPETAGINTEGER) == 0) ||
			(dwRating > PF_RATING_EXCELLENT) )
d681 2
@


1.137
log
@fix exception on shared file list reload with LanCast enabled {NonChance}
@
text
@d367 1
d456 1
d478 3
a480 1
	CTypedPtrList<CPtrList, CKnownFile*>	sortedList;
d482 1
d484 1
a484 1
	for (pos = m_mapSharedFiles.GetStartPosition(); pos != NULL;)
d491 13
a503 1
		//	Perform an insertion sort into 'sortedList'.
d508 1
a508 2
				dwPrioPos2 = GetRealPrio(pListKFile->GetULPriority()) + ((pListKFile->IsPartFile()) ? 8 : 0);
				dwPrioFile = GetRealPrio(pKnownFile->GetULPriority()) + ((pKnownFile->IsPartFile()) ? 8 : 0);
a525 1
	dwListNum = static_cast<uint32>(sortedList.GetCount());
d532 2
a533 2
	if ((dwNumFiles - 1) > 199)
		dwNumFiles = 200;
d544 1
a544 1
	CMemFile		packetStream(2048);
d555 2
d589 1
d733 1
a733 1
	for (POSITION pos = m_mapSharedFiles.GetStartPosition(); pos != NULL; )
d785 1
a785 1
							    static_cast<uint32>(bResort), reinterpret_cast<LPARAM>(pKnownFile) );
@


1.136
log
@Large file size support (max file size 512 GB - 1 = 549,755,813,887).
@
text
@a88 5
	static POSITION	pos = NULL;
	static CCKey		bufKey;

	CKnownFile		*pKnownFile = NULL;

d93 10
a102 4
		if (pos == NULL)
		{
			pos = m_mapSharedFiles.GetStartPosition();
		}
d104 1
a104 5
		if (pos != NULL)
		{
			m_mapSharedFiles.GetNextAssoc(pos,bufKey,pKnownFile);
			m_LanCast.BroadcastHash(pKnownFile);
		}
d106 1
a106 1
	sLock.Unlock();
d335 1
a335 1
	
d565 1
a565 1
	
@


1.135
log
@Publishing of large files; Changed prototype.
@
text
@d265 1
a265 1
			((qwFileSz = ff.GetLength()) == 0) || (qwFileSz >= 0xFFFFFFFF) )
a644 1
#if _LARGEFILE_READY
a646 1
#endif
a688 1
#if _LARGEFILE_READY
a690 1
#endif
@


1.134
log
@Delayed file republishing (1 min) on the server to post new rating or complete status
(to increase chances of grouping several files in one packet as this information isn't critical).
@
text
@d485 3
a487 1
		if (!pKnownFile->GetPublishedED2K())	//	take only files which should be published
d540 1
a540 1
		WriteToOfferedFilePacket(*pKnownFile, packetStream, pCurServer);	// (offered file info)[count]
d577 1
a577 1
void CSharedFileList::WriteToOfferedFilePacket(CKnownFile &sharedFile, CMemFile &packetStream,
d581 1
a581 1
	packetStream.Write(sharedFile.GetFileHash(),16);		// <filehash 16>
d588 1
a588 1
		if (sharedFile.IsPartFile())
d614 9
a622 13
	CWrTag		tagWr;
	uint32		dwNumType;
	CString		strFileType(sharedFile.GetSearchFileType(&dwNumType));
	uint32		dwTagCount = 2;
	uint32		dwRating = static_cast<uint32>(sharedFile.GetFileRating());
	bool		bNewTags;

//	Send rating only to server if server supports it (17.6+); also check for valid value
	if ( (pServer == NULL) || ((pServer->GetTCPFlags() & SRV_TCPFLG_TYPETAGINTEGER) == 0) ||
		(dwRating > PF_RATING_EXCELLENT) )
	{
		dwRating = 0;
	}
a626 6
	if ((dwRating != 0) && bNewTags)
		dwTagCount++;
	if (!strFileType.IsEmpty())
		dwTagCount++;

	packetStream.Write(&dwTagCount, 4);						// <tagcount 4>
d632 19
a650 2
		tagWr.WriteNewEd2kTag(FT_FILENAME, sharedFile.GetFileName(), packetStream);
		tagWr.WriteNewEd2kTag(FT_FILESIZE, sharedFile.GetFileSize(), packetStream);
d657 8
d673 1
d678 19
a696 2
		tagWr.WriteToFile(FT_FILENAME, sharedFile.GetFileName(), packetStream);				// {FILENAME : string}
		tagWr.WriteToFile(FT_FILESIZE, sharedFile.GetFileSize(), packetStream);				// {FILESIZE : int} (in bytes)
d698 1
d700 2
d703 4
@


1.133
log
@Fixed log information about duplicate shared files {Vladimir (SV)}.
@
text
@d370 3
@


1.132
log
@Large file size support preparations.
@
text
@d299 7
a305 5
			pKnownFile->SetPath(strDirectory);
			pKnownFile->SetFilePath(ff.GetFilePath());

			AddFile(pKnownFile);
			m_bLastPublishED2KFlag = true;
d339 1
a339 1
	bool	bAdded = AddFile(pNewKnownFile);
d373 1
a373 1
bool CSharedFileList::AddFile(CKnownFile *pKnownFile)
d383 1
a383 1
		AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Attempt to add duplicate shared files '%s' and '%s'"), pKnownFile->GetFilePath(), pResultFile->GetFilePath());
@


1.131
log
@Full path only for hashing log message of a partfile; Formatting.
@
text
@d294 1
a294 1
		CKnownFile	   *pKnownFile = m_pKnownFileList->FindKnownFile(strName, dwFileDate, static_cast<uint32>(qwFileSz));
d663 1
a663 1
//	GetDatasize() returns the size of the largest shared file in 'dwLargest' and returns
d665 1
a665 1
uint64 CSharedFileList::GetDatasize(uint32 *pdwLargest)
d667 1
a667 1
	*pdwLargest = 0;
d679 3
a681 3
	//	If this file is bigger than all the others...well duh.
		if (pKnownFile->GetFileSize() > *pdwLargest)
			*pdwLargest = pKnownFile->GetFileSize();
@


1.130
log
@Don't try to hash temporary files used by file completion {Fuxie - DK}.
@
text
@d782 1
a782 1
		int n = 2;
d785 1
a785 1
			strKey.Format(_T("%s (%d)"), (LPCTSTR)strWantedKey, n++);
d873 1
a873 1
			if (pNewKnownFile->CreateFromFile(m_strDirectory, m_strFileName))
@


1.129
log
@Formatting.
@
text
@d245 1
a245 1
		_T("log"), _T("getright"), _T("jc!"), _T("ds_store"),
@


1.128
log
@Avoided rare double publishing of a just completed file {muleteer}
(file publishing is sligtly delayed on reception of the first file chunk).
@
text
@d152 1
a152 1
	for (POSITION pos = tmpSharedDirList.GetHeadPosition(); pos != NULL; )
d176 1
a176 1
	for (POSITION pos = m_waitingForHashList.GetHeadPosition(); pos != NULL; )
d415 1
a415 1
//	RemoveFile() removes the first occurrence of 'pKnownFile' in the shared file list.
d687 2
a688 2
//	GetFileByID() returns the Known File with hash 'strFileHash' or NULL if there is none.
CKnownFile *CSharedFileList::GetFileByID(const uchar *strFileHash)
d691 2
a692 2
	CCKey			tKey(strFileHash);
	CSingleLock		sLock(&m_mutexList,true);
d694 1
a694 1
	if (strFileHash != NULL && m_mapSharedFiles.Lookup(tKey,pResultFile))
d762 1
a762 1
		strWantedKey= INCOMPLETE_DIR;	// default name used by Hybrid for temp dir
d766 1
a766 1
		strWantedKey= PathFindFileName((LPCTSTR)strDir);	// short name without complete path
d768 1
a768 1
			strWantedKey= SHARED_DIR;
d777 1
a777 1
			m_SharedVDirForList[strWantedKey + _T(" (1)")]= strDir0;
d782 1
a782 1
		int n= 2;
d789 2
a790 2
		strKey= strWantedKey;
	m_SharedVDirForList[strKey]= strDir;
d827 1
a827 1
	for (int i= 0; i < CCat::GetNumCats(); i++)
@


1.127
log
@Compatibility with VC2005 [brengarne].
@
text
@d67 1
a67 1
	m_mapSharedFiles.InitHashTable(1024);
d323 6
a328 3
//	SafeAddKnownFile() shares the KnownFile 'pNewKnownFile'. If 'bOnlyAdd' is true, the new file
//		is added to the shared files map but not offered to the connected server
void CSharedFileList::SafeAddKnownFile(CKnownFile *pNewKnownFile, bool bOnlyAdd)
d347 6
d358 2
a359 2
//	RepublishFile() republishes a file on the server after completion to update complete sources counter
void CSharedFileList::RepublishFile(CKnownFile *pFile)
d363 2
a364 2
//	Republish only if a server supports complete sources statistics
	if ((pCurServer != NULL) && (pCurServer->GetTCPFlags() & SRV_TCPFLG_COMPRESSION))
@


1.126
log
@Fixed a warning about too many shared files when no server information available {Vladimir (SV)}.
@
text
@d279 2
d284 1
a284 1
			for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcForbiddenExt); ui++)
@


1.125
log
@Show a warning about too many shared files based on actual server limit.
@
text
@d499 1
a499 1
	if ((dwNumFiles < dwListNum) || ((dwNumFiles == 0) && (dwListNum > 1000)))
@


1.124
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@a166 7
	if ((iSharedCnt + iWaitCnt) > 1000)
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_SHAREDWARNING), (iSharedCnt + iWaitCnt));
#endif //NEW_SOCKETS_ENGINE
	}

d461 1
a461 1
	uint32			dwNumFiles, dwPrioPos2, dwPrioFile;
d495 7
d505 1
a505 1
	if (static_cast<uint32>(sortedList.GetCount()) < dwNumFiles)
d507 1
a507 1
		if ((dwNumFiles = sortedList.GetCount()) == 0)
d518 1
a518 1
	AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Published %u file(s) on the server, %u remaining"), dwNumFiles, sortedList.GetCount() - dwNumFiles);
@


1.123
log
@renamed 3 variables
@
text
@d589 1
a589 1
			uClientPort = g_App.g_pPrefs->GetPort();
@


1.122
log
@added spaces
@
text
@d86 1
a86 1
	if (g_eMuleApp.m_app_state != g_eMuleApp.APP_STATE_RUNNING)
d136 1
a136 1
		g_eMuleApp.m_pDownloadQueue->AddPartFilesToShare();
d537 1
a537 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
d589 1
a589 1
			uClientPort = g_eMuleApp.m_pGlobPrefs->GetPort();
d692 1
a692 1
	if ((g_eMuleApp.m_pdlgEmule == NULL) || !::IsWindow(g_eMuleApp.m_pdlgEmule->m_hWnd))
d694 1
a694 1
	if (g_eMuleApp.m_pdlgEmule->IsRunning() && (m_pOutput != NULL))
d704 1
a704 1
	g_eMuleApp.m_fileHashControl.AddToHash(this, m_pCurrentlyHashing->m_strDirectory, m_pCurrentlyHashing->m_strFileName);
d855 1
a855 1
		CSingleLock sLock(&g_eMuleApp.m_csPreventExtensiveHDAccess, TRUE);
d867 1
a867 1
				if (g_eMuleApp.m_pdlgEmule)
d869 1
a869 1
					PostMessage( g_eMuleApp.m_pdlgEmule->m_hWnd, TM_FINISHEDHASHING,
d878 1
a878 1
				if (m_pOwner && g_eMuleApp.m_pdlgEmule && g_eMuleApp.m_pdlgEmule->IsRunning())
d884 1
a884 1
					PostMessage(g_eMuleApp.m_pdlgEmule->m_hWnd, TM_HASHFAILED, 0, reinterpret_cast<LPARAM>(pHashed));
@


1.121
log
@added new file extension to forbidden list (ini, lnk,pif,vbs,vbe)
@
text
@d253 1
a253 1
		_T("ini"),_T("lnk"),_T("pif"),_T("vbs"),_T("vbe")
@


1.120
log
@Send file rating to the server.
@
text
@d252 2
a253 1
		_T("log"), _T("getright"), _T("jc!"), _T("ds_store")
@


1.119
log
@Don't share .DS_Store files {morphis}.
@
text
@d599 2
d602 12
d621 1
a621 4
	if ( ((pServer != NULL) && (pServer->GetTCPFlags() & SRV_TCPFLG_NEWTAGS)) ||
		( (pClient != NULL) && pClient->IsEmuleClient() &&
		( ((pClient->GetClientSoft() == SO_EMULE) && (pClient->GetVersion() >= FORM_CLIENT_VER(0, 42, 7))) ||
		((pClient->GetClientSoft() == SO_PLUS) && (pClient->GetVersion() > FORM_CLIENT_VER(1, 1, 0))) ) ) )
d632 8
@


1.118
log
@File type as integer for the server to reduce traffic {lugdunummaster};
Separate GetFileTypeString for search type.
@
text
@d252 1
a252 1
		_T("log"), _T("getright") , _T("jc!")
@


1.117
log
@Global preferences reference for LanCast {WiZaRd};
Static LanCast object instead of dynamic.
@
text
@d596 2
a597 1
	CString		strFileType = sharedFile.GetFileTypeString();
d615 6
a620 1
			tagWr.WriteNewEd2kTag(FT_FILETYPE, strFileType, packetStream);
@


1.116
log
@Fixed time interval between the first and the second file publishments {Fuxie - DK}.
@
text
@a54 1
	m_pLanCast = new CLanCast(pPrefs);
a76 3
#ifndef NEW_SOCKETS_ENGINE
	delete m_pLanCast;
#endif //NEW_SOCKETS_ENGINE
d106 1
a106 1
			m_pLanCast->BroadcastHash(pKnownFile);
@


1.115
log
@Extended log message.
@
text
@d50 1
a50 1
	m_mapSharedFiles.InitHashTable(1024);
d457 1
d800 1
a800 4
	uint32	dwTicks;

	if ( !m_bLastPublishED2KFlag ||
		(((dwTicks = ::GetTickCount()) - m_dwLastPublishED2KTime) < ED2KREPUBLISHTIME) )
a801 1
	m_dwLastPublishED2KTime = dwTicks;
d817 1
a817 1
void CHashFileThread::SetValues( CSharedFileList *pOwner, LPCTSTR in_directory, LPCTSTR in_filename,
@


1.114
log
@Added log line reporting failure to hash.
@
text
@d520 1
a520 1
	AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Published %u file(s) on the server"), dwNumFiles);
@


1.113
log
@Fixed shared files hashing issues when hashing stopped {Juokelis/GMGMGM/taltamir};
Improved files publishing algorithm on the server;
Fixed hashing shared file search -- should've been case insensitive;
Fixed possibility to have files with the same hash in shared files list;
Removed useless loop to try hashing several times
(as nothing will change within microseconds); Removed unused code.
@
text
@d226 1
@


1.112
log
@Some preparations for new publishing algorithm.
@
text
@d20 1
a20 1
#include "knownfilelist.h"
d44 3
d54 1
a54 1
//	FindSharedFiles();
a55 1
	m_bDelayReload = false;
d62 3
d72 1
a72 2
	//	FindSharedFiles();
	m_bDelayReload = false;
d81 1
a82 1
	{
a83 1
	}
d118 1
a118 2
//		shared files map. As a side-effect (naughty) it sets the 'm_iFilesToBeHashed' in the eMule Dialog
//		to the number of files in the hash waiting list.
a160 2
	sLock1.Lock();

d164 1
a165 3
	{
		sLock1.Unlock();
#ifndef NEW_SOCKETS_ENGINE
a166 2
#endif //NEW_SOCKETS_ENGINE
	}
a167 6
	{
#ifndef NEW_SOCKETS_ENGINE
		g_eMuleApp.m_pdlgEmule->m_iFilesToBeHashed = iWaitCnt;
#endif //NEW_SOCKETS_ENGINE
		sLock1.Unlock();
#ifndef NEW_SOCKETS_ENGINE
a169 1
	}
d182 2
a183 2
//	FindUnknownFile() checks to see if the spec'd file is already in the waiting for hash list.
bool CSharedFileList::FindUnknownFile(CString strDirectory, CString strFileName)
d191 2
a192 1
		if (pUnknownFile->m_strDirectory == strDirectory && pUnknownFile->m_strFileName == strFileName)
d202 45
d296 1
a296 1
		//	A file is of the type we don't want to share...
d309 2
a310 5
			CSingleLock		sLock(&m_mutexList, true);

			pKnownFile->SetSharedFile(true);
			m_mapSharedFiles.SetAt(CCKey(pKnownFile->GetFileHash()), pKnownFile);
			sLock.Unlock();
d316 2
a317 2
			UnknownFile_Struct	*pUnknownFile = NULL;
			try
d319 1
a319 4
			//	If the spec'd file isn't already in the list (avoid duplications due to overlapping share paths)
				if (!FindUnknownFile(strDirectory, strName))
				{
					pUnknownFile = new UnknownFile_Struct;
d321 3
a323 13
					pUnknownFile->m_strDirectory = strDirectory;
					pUnknownFile->m_strFileName = strName;
					m_waitingForHashList.AddTail(pUnknownFile);
				}
			}
			catch(CException *err)
			{
#ifndef NEW_SOCKETS_ENGINE
				g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(err));
#endif //NEW_SOCKETS_ENGINE
				err->Delete();
				if (pUnknownFile)
					safe_delete(pUnknownFile);
d331 1
a331 1
//		is added to the shared files map but not offered to the connected server.
d339 3
a341 11
//	Tell 'pNewKnownFile' that it's being shared now
	pNewKnownFile->SetSharedFile(true);
//
//	TODO: Check if the file is already known - only with another date
//
	CSingleLock		sLock(&m_mutexList,true);

//	Add 'pNewKnownFile' to the shared files map
	m_mapSharedFiles.SetAt(CCKey(pNewKnownFile->GetFileHash()),pNewKnownFile);

	sLock.Unlock();
d348 1
a348 1
	if (m_pOutput != NULL)
d351 12
a362 4
	HashNextFile();
//	Offer new file to server
#ifdef OLD_SOCKETS_ENABLED
	if (m_pServerConnect && m_pServerConnect->IsConnected())
d364 10
a373 2
		CMemFile		packetStream(100);
		uint32		dwFileCount = 1;
d375 7
a381 2
		packetStream.Write(&dwFileCount,4);
		WriteToOfferedFilePacket(*pNewKnownFile,packetStream, m_pServerConnect->GetCurrentServer());
d383 2
a384 1
		Packet		*pPacket = new Packet(&packetStream);
d386 17
a402 3
		pPacket->m_eOpcode = OP_OFFERFILES;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
		m_pServerConnect->SendPacket(pPacket,true);
d404 3
a406 1
#endif //OLD_SOCKETS_ENABLED
d408 3
a410 1
	EMULE_CATCH
d427 1
a427 1
void CSharedFileList::Reload(bool bSendToServer /*=true*/)
d429 1
d431 2
a432 13
	if(bSendToServer && m_pServerConnect->IsConnected())
		AddDebugLogLine(_T("Reloading and sending to server shared files"));
#endif //NEW_SOCKETS_ENGINE

//	If there are no shared files waiting to be hashed...
	if (m_waitingForHashList.IsEmpty())
	{
	    FindSharedFiles();
#ifndef NEW_SOCKETS_ENGINE
	    if (m_pOutput != NULL)
		    m_pOutput->ShowFileList(this);
	    if (bSendToServer && m_pServerConnect->IsConnected())
		    SendListToServer();
a433 10
    }
	else
	{
		//eklmn: clear the waiting hash correct way
		while (!m_waitingForHashList.IsEmpty())
		{
			delete m_waitingForHashList.RemoveTail();
		}
		m_bDelayReload = true;
	}
d442 1
d446 1
a446 1
__inline byte GetRealPrio(byte byteIn)
d457 4
a460 1
	CSingleLock		sLock(&m_mutexList,true);
d462 1
a462 1
	CServer*		pCurServer = m_pServerConnect->GetCurrentServer();
d464 1
a464 1
	if (m_mapSharedFiles.IsEmpty() || !pCurServer)
d466 1
a466 4
//
//	Construct the byte stream for the OFFERFILES packet.
//
	CMemFile		packetStream;
d468 4
a471 2
	CKnownFile	   *pKnownFile;
	uint32			dwNumFiles;
d473 2
a474 3
//	If the connected server has a soft file limit and we have fewer files than the limit shared...
	if ( pCurServer->GetSoftMaxFiles() != 0
		&& static_cast<uint32>(m_mapSharedFiles.GetCount()) <= pCurServer->GetSoftMaxFiles() )
d476 2
a477 4
		dwNumFiles = m_mapSharedFiles.GetCount();
		packetStream.Write(&dwNumFiles,sizeof(DWORD));			// <count:DWORD> Shared file count

		for (POSITION pos = m_mapSharedFiles.GetStartPosition(); pos != NULL; )
a478 18
			m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
			WriteToOfferedFilePacket(*pKnownFile, packetStream, pCurServer);	// (offered file info)[count]
		}
	}
	else
	{
	//	Send a subset
		POSITION								pos, pos2, pos3;
		CTypedPtrList<CPtrList, CKnownFile*>	sortedList;
		bool									bAdded = false;

	//	For each shared file...
		for (pos = m_mapSharedFiles.GetStartPosition(); pos != NULL; )
		{
			m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);

			bAdded = false;
		//
d480 1
a480 1
			for (pos2 = sortedList.GetHeadPosition(); (pos3 = pos2) != NULL && !bAdded; )
d482 4
a485 2
				byte		nPrioPos2 = GetRealPrio(sortedList.GetNext(pos2)->GetULPriority());
				byte		nPrioFile = GetRealPrio(pKnownFile->GetULPriority());
d488 1
a488 4
			//		 or it's the same priority but it's file name comes before the other...
				if ( (nPrioPos2 < nPrioFile)
				  || ( (nPrioPos2 == nPrioFile)
				    && (sortedList.GetAt(pos3)->GetFileName().CompareNoCase(pKnownFile->GetFileName()) > 0) ) )
d490 1
a490 1
				//	Insert it before the current one in the sorted list.
d492 1
a492 1
					bAdded = true;
d495 2
a496 2
		//	If we didn't find a file to add this one before, add it to the end of the list.
			if (!bAdded)
d499 2
a500 7
	//
	//	Start writing the byte stream
		dwNumFiles = pCurServer->GetSoftMaxFiles();
	//	If we don't know the soft limit, we send all our files
		if (dwNumFiles == 0)
			dwNumFiles = sortedList.GetCount();
		packetStream.Write(&dwNumFiles,sizeof(DWORD));				// <count:DWORD> Shared file count
d502 3
a504 1
		uint32		dwCount = 0;
d506 3
a508 2
		pos = sortedList.GetHeadPosition();
		while (pos != NULL && dwCount < dwNumFiles)
d510 2
a511 2
			dwCount++;
			WriteToOfferedFilePacket(*sortedList.GetNext(pos),packetStream, pCurServer);	// (offered file info)[count]
d514 12
a525 1
	sLock.Unlock();
d530 5
a534 7

	// compress packet
	//   - this kind of data is highly compressable (N * (1 MD4 and at least 3 string meta data tags and 1 integer meta data tag))
	//   - the min. amount of data needed for one published file is ~100 bytes
	//   - this function is called once when connecting to a server and when a file becomes shareable - so, it's called rarely.
	//   - if the compressed size is still >= the original size, we send the uncompressed packet
	// therefor we always try to compress the packet
a535 1
	{
a536 1
	}
d539 1
a539 2

	m_pServerConnect->SendPacket(pPacket,true);
d545 15
a664 10
short CSharedFileList::GetFilePriorityByID(uchar *pFileHash)
{
	CKnownFile		*pKnownFile = GetFileByID(pFileHash);

	if (pKnownFile != NULL)
		return pKnownFile->GetULPriority();
	else
		return -10;	// file doesn't exist
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d667 6
a672 6
//	If we're waiting to reload the shared files list (after clearing hash list)...
	if(m_bDelayReload == true)
	{
	//	Do reload now
		m_bDelayReload = false;
		Reload();
d674 1
a674 3
	}
//	If there're no files to hash, just return
	if (m_waitingForHashList.IsEmpty())
d677 1
a677 1
	UnknownFile_Struct	   *pUnknownFile = m_waitingForHashList.RemoveHead();
d680 1
a680 1
	g_eMuleApp.m_fileHashControl.AddToHash(this, pUnknownFile->m_strDirectory, pUnknownFile->m_strFileName);
d682 1
a682 1
	g_stEngine.Files.FileHasher.AddToHash(this, pUnknownFile->m_strDirectory, pUnknownFile->m_strFileName);
a683 1
	delete pUnknownFile;
d686 1
a686 1
void CSharedFileList::UpdateItem(CKnownFile *pKnownFile,bool bResort/*=true*/)
d692 1
a692 2
							    static_cast<uint32>(bResort),
							    reinterpret_cast<LPARAM>(pKnownFile) );
d798 7
d838 2
a839 3
		// eklmn: since "new" can failed, we gonna try 3 times
		int iTry = 0;
		do
d841 2
a842 2
			CKnownFile	*pNewKnownFile = new CKnownFile();
			if (pNewKnownFile)
d844 4
a847 2
			//	Try to create a hashed KnownFile for the spec'd file. If successful...
				if (pNewKnownFile->CreateFromFile(m_strDirectory,m_strFileName))
d849 7
a855 2
				//	Notify the PartFile (via a message to the eMule window) that the file it was
				//		completing has finished hashing.
d857 2
a858 10
					if (g_eMuleApp.m_pdlgEmule)
					{
						PostMessage( g_eMuleApp.m_pdlgEmule->m_hWnd,
									TM_FINISHEDHASHING,
									(m_pOwner ? 0 : (WPARAM)m_pPartFile),
									(LPARAM)pNewKnownFile);
					}
#endif //NEW_SOCKETS_ENGINE
				}
				else
d860 5
a864 1
					delete pNewKnownFile;
d866 2
a867 1
				break;
d869 1
a869 2
			iTry++;
		} while (iTry <3);
@


1.111
log
@Optimized scanning of shared directories;
Easier code to maintain forbidden to share file extensions;
Make this code ready for Unicode.
@
text
@d779 4
@


1.110
log
@Minor string processing improvement.
@
text
@d216 7
a222 1
	CString		strExtension;
d224 3
a226 5
	CString		strSearchPath;

	strSearchPath.Format(_T("%s\\*"),strDirectory);

	bool		bEnd = !ff.FindFile(strSearchPath,0);
d228 2
d233 2
d238 2
a239 4
		if (ff.IsDirectory() || ff.IsDots() || ff.IsSystem() || ff.IsTemporary() || ff.GetLength() >= 0xFFFFFFFF)
			continue;
	//	Ultras: prevent to add the zero lenght files
		if (!ff.GetLength())
d249 3
a251 3
		strExtension = ff.GetFileName().Right(ff.GetFileName().GetLength() - ff.GetFileName().ReverseFind('.')).MakeLower();
	//	If the file doesn't have the extension of a type we don't want to share...
		if (!(strExtension==".part" || strExtension==".met" || strExtension==".settings" || strExtension==".bak" || strExtension==".txtsrc" || strExtension==".stats" || strExtension==".dir" || strExtension==".dll" || strExtension==".sys" || strExtension==".drv" || strExtension==".tmp" || strExtension==".log" || strExtension==".getright" || strExtension==".jc!"))
d253 2
a254 1
			CKnownFile	   *pKnownFile = m_pKnownFileList->FindKnownFile(ff.GetFileName().GetBuffer(), dwFileDate, static_cast<uint32>(ff.GetLength()));
d256 1
a256 2
		//	If the file is already known...
			if (pKnownFile != NULL)
d258 9
a266 2
				pKnownFile->SetPath(strDirectory);
				pKnownFile->SetFilePath(ff.GetFilePath());
d268 5
a272 1
				CSingleLock		sLock(&m_mutexList,true);
d274 12
a285 6
				pKnownFile->SetSharedFile(true);
				m_mapSharedFiles.SetAt(CCKey(pKnownFile->GetFileHash()),pKnownFile);
				sLock.Unlock();
			}
		//	If the file is not in the known list...
			else
d287 2
a288 3
			//	Start a thread to hash the new file
				UnknownFile_Struct	*pUnknownFile = NULL;
				try
d290 1
a290 5
				//	If the spec'd file isn't already in the list (avoid duplications due to overlapping
				//		share paths)
					if (!FindUnknownFile(strDirectory,ff.GetFileName()))
					{
						pUnknownFile = new UnknownFile_Struct;
d292 3
a294 4
						pUnknownFile->m_strDirectory = strDirectory;
						pUnknownFile->m_strFileName = ff.GetFileName();
						m_waitingForHashList.AddTail(pUnknownFile);
					}
d296 3
a298 2
				catch(CException *err)
				{
d300 1
a300 1
					g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(err));
d302 3
a304 4
					err->Delete();
					if (pUnknownFile)
						safe_delete(pUnknownFile);
				}
@


1.109
log
@Don't send empty FT_FILETYPE tag
@
text
@d568 1
a568 1
			tagWr.WriteNewEd2kTag(FT_FILETYPE, sharedFile.GetFileTypeString(), packetStream);
d575 1
a575 1
			tagWr.WriteToFile(FT_FILETYPE, sharedFile.GetFileTypeString(), packetStream);	// {FILETYPE : string}
@


1.108
log
@Removed unused code called "offered files to server".
@
text
@d550 5
a554 1
	uint32		dwTagCount = 3;
d567 2
a568 1
		tagWr.WriteNewEd2kTag(FT_FILETYPE, sharedFile.GetFileTypeString(), packetStream);
d572 4
a575 3
		tagWr.WriteToFile(FT_FILENAME, sharedFile.GetFileName(), packetStream);			// {FILENAME : string}
		tagWr.WriteToFile(FT_FILESIZE, sharedFile.GetFileSize(), packetStream);			// {FILESIZE : int} (in bytes)
		tagWr.WriteToFile(FT_FILETYPE, sharedFile.GetFileTypeString(), packetStream);	// {FILETYPE : string}
@


1.107
log
@More user friendly display of Files and User values in
 Server list + minor changes.
@
text
@a327 2
		pNewKnownFile->SetOfferedToServer(true);

d431 2
a432 3
			m_mapSharedFiles.GetNextAssoc(pos,bufKey,pKnownFile);
			WriteToOfferedFilePacket(*pKnownFile,packetStream, pCurServer);	// (offered file info)[count]
			pKnownFile->SetOfferedToServer(true);
d462 1
a462 1
					sortedList.InsertBefore(pos3,pKnownFile);
a483 1
			sortedList.GetAt(pos)->SetOfferedToServer(true);
a485 8
	//
	//	Clear the "offered to server" flag on all the files we couldn't send
		while (pos != NULL && dwCount<static_cast<uint32>(sortedList.GetCount()))
		{
			dwCount++;
			sortedList.GetNext(pos)->SetOfferedToServer(false);
		}
		sortedList.RemoveAll();
a487 1
	UpdateOfferedItems();
a511 11
//	UpdateOfferedItems() causes the shared file list window to be updated.
void CSharedFileList::UpdateOfferedItems()
{
#ifndef NEW_SOCKETS_ENGINE
	if (m_pOutput != NULL)
	{
		m_pOutput->PostMessage(WM_SFL_UPDATEOFFEREDITEMS,0,0);
	}
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.106
log
@v2 - shared files
@
text
@a513 1
		UINT uUncomprSize = pPacket->m_dwSize; // is this really needed ?
@


1.105
log
@Support new ed2k tag format (client<->server,
as well as used for shared list transfers to eMule v0.43a+ and eMule Plus v1.1a+).
@
text
@d18 1
a18 1
#include "StdAfx.h"
d25 5
d664 2
@


1.104
log
@Type of statistics values Max. Shared File Size and Max. Shared Average File Size
was changed from 64-bit into 32-bit to speed up processing as max. supported ed2k file size fits 32-bit.
@
text
@d532 2
a533 1
void CSharedFileList::WriteToOfferedFilePacket(CKnownFile &sharedFile, CMemFile &packetStream, CServer* pServer)
d543 1
a543 2
		CPartFile* pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(sharedFile.GetFileHash());
		if (pPartFile && (pPartFile->GetStatus() != PS_COMPLETE || pPartFile->GetStatus() != PS_COMPLETING))
d545 1
a545 1
			// magic values for incomplete files
d551 1
a551 1
			// magic values for  complete files
d575 16
a590 3
	tagWr.WriteToFile(FT_FILENAME, sharedFile.GetFileName(), packetStream);			// {FILENAME : string}
	tagWr.WriteToFile(FT_FILESIZE, sharedFile.GetFileSize(), packetStream);			// {FILESIZE : int} (in bytes)
	tagWr.WriteToFile(FT_FILETYPE, sharedFile.GetFileTypeString(), packetStream);	// {FILETYPE : string}
@


1.103
log
@Connecting preferences and known/shared files
@
text
@d574 1
d581 1
a581 1
//	GetDatasize() returns the size of the largest shared file in 'qwLargest' and returns
d583 1
a583 1
uint64 CSharedFileList::GetDatasize(uint64 &qwLargest)
d585 1
a585 1
	qwLargest = 0;
d598 2
a599 2
		if (pKnownFile->GetFileSize() > qwLargest)
			qwLargest = pKnownFile->GetFileSize();
@


1.102
log
@Optimized parameter tag processing (preparation and parsing).
@
text
@d51 1
a51 1
CSharedFileList::CSharedFileList(CKnownFileList *pKnownFileList)
d53 1
a139 1
#ifndef NEW_SOCKETS_ENGINE
a143 1
#endif //NEW_SOCKETS_ENGINE
a147 1
#ifndef NEW_SOCKETS_ENGINE
a148 1
#endif //NEW_SOCKETS_ENGINE
a728 1
#ifndef NEW_SOCKETS_ENGINE
a730 1
#endif //NEW_SOCKETS_ENGINE
a734 1
#ifndef NEW_SOCKETS_ENGINE
a735 1
#endif //NEW_SOCKETS_ENGINE
a739 1
#ifndef NEW_SOCKETS_ENGINE
a740 1
#endif //NEW_SOCKETS_ENGINE
a747 1
#ifndef NEW_SOCKETS_ENGINE
a748 1
#endif //NEW_SOCKETS_ENGINE
@


1.101
log
@A fix for the previous commitment: Unlock() must be before AddLogLine().
@
text
@d572 1
a573 1
	packetStream.Write(&dwTagCount,4);						// <tagcount 4>
d575 1
a575 2
	CFileTag	nameTag(FT_FILENAME,sharedFile.GetFileName());
	nameTag.WriteToFile(packetStream);						// {FILENAME : string}
d577 3
a579 5
	CFileTag	sizeTag(FT_FILESIZE,sharedFile.GetFileSize());
	sizeTag.WriteToFile(packetStream);						// {FILESIZE : int} (in bytes)

	CFileTag	typeTag(FT_FILETYPE, sharedFile.GetFileTypeString());
	typeTag.WriteToFile(packetStream);						// {FILETYPE : string}
@


1.100
log
@More ifdefs for v2
@
text
@d173 3
a177 1
		sLock1.Unlock();
@


1.99
log
@Changed color from ERROR to WARNING
@
text
@d32 1
d50 15
d68 1
d70 1
d80 1
d105 1
d131 1
d133 1
d139 1
d144 1
d149 1
d151 1
d165 1
d167 1
d171 1
d173 2
a175 1
		AddLogLine(false, IDS_SHAREDFOUNDHASHING, iSharedCnt, iWaitCnt);
d180 1
d182 1
d277 1
d279 1
d315 1
d318 1
d347 1
d349 1
d359 1
d362 1
d368 1
d373 1
d388 1
d391 1
d525 1
d530 1
d647 1
d649 1
d655 1
d662 1
d733 1
d736 1
d741 1
d743 1
d748 1
d750 1
d758 1
d760 1
d799 1
d801 1
d815 1
d823 1
@


1.98
log
@- added warning when sharing too much files that leads to connection problems
- new warning when adding a file from search that has no complete sources reported
@
text
@d150 1
a150 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_SHAREDWARNING), (iSharedCnt + iWaitCnt));
@


1.97
log
@Fixed rehashing on Daylight Saving Time change (official).
@
text
@d147 6
d498 1
a498 1
		if (pPartFile && (pPartFile->GetStatus() != PS_COMPLETE || pPartFile->GetStatus() != PS_COMPLETING)) 
d771 1
a771 1
		
@


1.96
log
@Fixed temporary directory list processing (double list entries which could be caused
by case sensitive compares; remove incorrect entries from the list; don't allow
main temp dir to be added to the list).
@
text
@d194 1
a194 1
		CTime		dwLastWriteTime;
d196 5
a200 1
		ff.GetLastWriteTime(dwLastWriteTime);
d205 1
a205 2
			uint32			time_tLocalTime = mktime(dwLastWriteTime.GetLocalTm());
			CKnownFile	   *pKnownFile = m_pKnownFileList->FindKnownFile(ff.GetFileName().GetBuffer(),time_tLocalTime,static_cast<uint32>(ff.GetLength()));
@


1.95
log
@Removed .torrent from forbidden shared file extensions.
@
text
@d679 1
a679 1
	// temp dirs
d682 6
a687 1
	POSITION	pos = m_pPrefs->m_tempDirList.GetHeadPosition();
d690 1
a690 1
		AddSharedVDirForList(true, m_pPrefs->m_tempDirList.GetNext(pos));
@


1.94
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d199 1
a199 1
		if (!(strExtension==".part" || strExtension==".met" || strExtension==".settings" || strExtension==".bak" || strExtension==".txtsrc" || strExtension==".stats" || strExtension==".dir" || strExtension==".dll" || strExtension==".sys" || strExtension==".drv" || strExtension==".tmp" || strExtension==".log" || strExtension==".torrent" || strExtension==".getright" || strExtension==".jc!"))
@


1.93
log
@SSWQ
@
text
@d524 1
a524 1
	CFileTag	typeTag(FT_FILETYPE, sharedFile.GetFileType());
@


1.92
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d398 2
a399 2
				byte		nPrioPos2 = GetRealPrio(sortedList.GetNext(pos2)->GetPriority());
				byte		nPrioFile = GetRealPrio(pKnownFile->GetPriority());
d571 1
a571 1
		return pKnownFile->GetPriority();
@


1.91
log
@Moved FinSharedFiles to a timer to fix issues with hashing hung on start
Fixed Search buttons activation issues and More not working
@
text
@d313 1
a313 1
		AddDebugLogLine(false, _T("Reloading and sending to server shared files"));
@


1.90
log
@minor changes, fixes and improvements
@
text
@d45 1
a45 1
	FindSharedFiles();
@


1.89
log
@Improved extensive hard drive access for simultaneous hashing and completion.
@
text
@d560 1
a560 1
	if (m_mapSharedFiles.Lookup(tKey,pResultFile))
@


1.88
log
@Corrected synchronization for the case of exception.
@
text
@d726 2
a727 2
	//	Only one completing file hashing at a time to reduce I/O load
		CSingleLock sLock(&g_eMuleApp.m_critsectHashing, TRUE);
d758 1
a758 1
	//	m_critsectHashing is unlocked here
@


1.87
log
@Resource lock time reduced.
@
text
@d727 1
a727 1
		g_eMuleApp.m_critsectHashing.Lock();
d758 1
a758 1
		g_eMuleApp.m_critsectHashing.Unlock();
@


1.86
log
@Fixed shared directory list corruption caused by asynchronous access (bug #502);
Fixed shared directory list processing to eliminate double list entries (that can be caused by case sensitive compares, by the bug on file completion after file destination change, or by initial shareddir.dat values).
@
text
@d133 4
a136 1
	if (m_waitingForHashList.IsEmpty())
d138 2
a139 1
		AddLogLine(false, IDS_SHAREDFOUND, m_mapSharedFiles.GetCount());
d143 3
a145 2
		g_eMuleApp.m_pdlgEmule->m_iFilesToBeHashed = m_waitingForHashList.GetCount();
		AddLogLine(false, IDS_SHAREDFOUNDHASHING, m_mapSharedFiles.GetCount(), m_waitingForHashList.GetCount());
a146 1
	sLock1.Unlock();
d535 1
a535 4
	uint64			qwFilesTotalBytes;

	qwFilesTotalBytes = 0;

d538 2
a539 1
	CSingleLock		sLock(&m_mutexList,true);
@


1.85
log
@Corrected list title update (removed multiple title update during switching between Shared & Known file lists).
@
text
@d114 1
a114 1
			sLock1.Unlock();
d117 6
a122 2
	if (!m_pPrefs->m_sharedDirList.Find(m_pPrefs->GetIncomingDir()) && !m_pPrefs->m_sharedDirList.Find(m_pPrefs->GetIncomingDir()+'\\'))
		AddFilesFromDirectory(m_pPrefs->GetIncomingDir().GetBuffer());
d124 6
a129 2
	for (POSITION pos = m_pPrefs->m_sharedDirList.GetHeadPosition(); pos != NULL; )
		AddFilesFromDirectory(m_pPrefs->m_sharedDirList.GetNext(pos).GetBuffer());
d143 1
a143 1
	BuildSharedVDirForList();
d670 1
a670 1
void CSharedFileList::BuildSharedVDirForList()
d689 3
a691 3
    pos = m_pPrefs->m_sharedDirList.GetHeadPosition();
    while (pos != NULL)
		AddSharedVDirForList(false, m_pPrefs->m_sharedDirList.GetNext(pos));
@


1.84
log
@replaced  pos != 0 to pos != NULL
@
text
@d261 1
a261 1
		m_pOutput->ShowFile(pNewKnownFile);
@


1.83
log
@feature: show number of complete files by search (untested)
@
text
@d65 1
a65 1
	static POSITION		pos = 0;
d68 1
a68 1
	CKnownFile		   *pKnownFile = NULL;
d74 1
a74 1
		if (pos == 0)
d79 1
a79 1
		if (pos != 0)
d362 1
a362 1
		for (POSITION pos = m_mapSharedFiles.GetStartPosition(); pos != 0; )
d423 1
a423 1
		while (pos != 0 && dwCount<static_cast<uint32>(sortedList.GetCount()))
@


1.82
log
@reverted upload Priority problems fix since it doesn't work like it should do
@
text
@d273 1
a273 1
		WriteToOfferedFilePacket(*pNewKnownFile,packetStream);
d365 1
a365 1
			WriteToOfferedFilePacket(*pKnownFile,packetStream);	// (offered file info)[count]
d419 1
a419 1
			WriteToOfferedFilePacket(*sortedList.GetNext(pos),packetStream);	// (offered file info)[count]
d466 1
a466 1
void CSharedFileList::WriteToOfferedFilePacket(CKnownFile &sharedFile,CMemFile &packetStream)
d474 1
a474 2
//	If connected and highID, set client ID and port
	if (m_pServerConnect->IsConnected() && !m_pServerConnect->IsLowID())
d476 22
a497 2
		dwClientID = m_pServerConnect->GetClientID();
		uClientPort = g_eMuleApp.m_pGlobPrefs->GetPort();
d499 1
@


1.81
log
@handling of failed new's
@
text
@a243 12
//	Change UploadPriority according to UAP state
	if (pNewKnownFile->IsAutoPrioritized() && !g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
	{
		pNewKnownFile->SetAutoPriority(false);
		pNewKnownFile->SetPriority(PR_NORMAL);
	}
	else if (!pNewKnownFile->IsAutoPrioritized() && g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
	{
		pNewKnownFile->SetAutoPriority(true);
		pNewKnownFile->UpdateUploadAutoPriority();
	}

@


1.80
log
@Upload Priority problems fix
@
text
@d239 5
d277 3
a279 6
	if (!m_pServerConnect->IsConnected())
		return;
#else

#endif //OLD_SOCKETS_ENABLED
	pNewKnownFile->SetOfferedToServer(true);
d281 2
a282 2
#ifdef OLD_SOCKETS_ENABLED
	CMemFile		packetStream(100);
d284 2
a285 1
	uint32			dwFileCount = 1;
d287 1
a287 2
	packetStream.Write(&dwFileCount,4);
	WriteToOfferedFilePacket(*pNewKnownFile,packetStream);
d289 5
a293 1
	Packet		*pPacket = new Packet(&packetStream);
d295 1
a295 4
	pPacket->m_eOpcode = OP_OFFERFILES;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
	m_pServerConnect->SendPacket(pPacket,true);
#endif //OLD_SOCKETS_ENABLED
d350 2
d465 2
d711 3
a713 4
		CKnownFile		*pNewKnownFile = new CKnownFile();

	//	Try to create a hashed KnownFile for the spec'd file. If successful...
		if (pNewKnownFile->CreateFromFile(m_strDirectory,m_strFileName))
d715 2
a716 3
		//	Notify the PartFile (via a message to the eMule window) that the file it was
		//		completing has finished hashing.
			if (g_eMuleApp.m_pdlgEmule)
d718 18
a735 4
				PostMessage( g_eMuleApp.m_pdlgEmule->m_hWnd,
							TM_FINISHEDHASHING,
							(m_pOwner ? 0 : (WPARAM)m_pPartFile),
							(LPARAM)pNewKnownFile);
d737 3
a739 6
		}
		else
		{
			delete pNewKnownFile;
		}

@


1.79
log
@Improved blocking synchronization for completing file hashing: faster synchronization object is used, removed synchronization overhead, optimization.
@
text
@d239 12
@


1.78
log
@minor optimization
@
text
@d687 4
a690 4
	if (!(m_pOwner || m_pPartFile) || m_strFileName.IsEmpty())
		AfxEndThread(0,true);

	CSingleLock sLock1(&(g_eMuleApp.m_mutexHashing)); // only one filehash at a time
d692 1
a692 1
	sLock1.Lock();
d694 17
a710 1
	CKnownFile		*pNewKnownFile = new CKnownFile();
d712 1
a712 10
//	Try to create a hashed KnownFile for the spec'd file. If successful...
	if (pNewKnownFile->CreateFromFile(m_strDirectory,m_strFileName))
	{
	//	Notify the PartFile (via a message to the eMule window) that the file it was
	//		completing has finished hashing.
		if (g_eMuleApp.m_pdlgEmule)
			PostMessage( g_eMuleApp.m_pdlgEmule->m_hWnd,
						 TM_FINISHEDHASHING,
						 (m_pOwner ? 0 : (WPARAM)m_pPartFile),
						 (LPARAM)pNewKnownFile);
a713 6
	else
	{
		delete pNewKnownFile;
	}

	sLock1.Unlock();
@


1.77
log
@list processing optimization
@
text
@d325 7
@


1.76
log
@Synchronization is improved
@
text
@d102 1
a102 1
		while (pos)
d120 2
a121 2
	for (POSITION pos = m_pPrefs->m_sharedDirList.GetHeadPosition(); pos != NULL; m_pPrefs->m_sharedDirList.GetNext(pos))
		AddFilesFromDirectory(m_pPrefs->m_sharedDirList.GetAt(pos).GetBuffer());
d127 1
a127 1
		AddLogLine(false, IDS_SHAREDFOUND,m_mapSharedFiles.GetCount());
d132 1
a132 1
		AddLogLine(false, IDS_SHAREDFOUNDHASHING,m_mapSharedFiles.GetCount(), m_waitingForHashList.GetCount());
d144 1
a144 1
	for (POSITION pos = m_waitingForHashList.GetHeadPosition(); pos != 0; m_waitingForHashList.GetNext(pos))
d146 1
a146 1
		UnknownFile_Struct		*pUnknownFile = reinterpret_cast<UnknownFile_Struct*>(m_waitingForHashList.GetAt(pos));
d360 1
a360 1
		POSITION								pos, pos2;
d365 1
a365 1
		for (pos = m_mapSharedFiles.GetStartPosition(); pos != 0;)
d372 1
a372 1
			for (pos2 = sortedList.GetHeadPosition(); pos2 != 0 && !bAdded; sortedList.GetNext(pos2))
d374 1
a374 1
				byte		nPrioPos2 = GetRealPrio(sortedList.GetAt(pos2)->GetPriority());
d381 1
a381 1
				    && (sortedList.GetAt(pos2)->GetFileName().CompareNoCase(pKnownFile->GetFileName()) > 0) ) )
d384 1
a384 1
					sortedList.InsertBefore(pos2,pKnownFile);
d403 1
a403 1
		while (pos != 0 && dwCount < dwNumFiles)
d497 1
a497 1
	for (POSITION pos = m_mapSharedFiles.GetStartPosition(); pos != NULL;)
d577 3
a579 2
	POSITION pos= m_SharedVDirForList.GetStartPosition();
	while (pos)
a632 1
	POSITION pos;
d637 4
a640 2
	pos= m_pPrefs->m_tempDirList.GetHeadPosition();
	while (pos)
d648 1
a648 1
    while (pos)
@


1.75
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@a92 1
	BOOL			bEmpty;
d95 1
a95 5
	bEmpty	=	m_mapSharedFiles.IsEmpty();

	sLock1.Unlock();

	if (!bEmpty)
a99 2
		sLock1.Lock();

d113 3
@


1.74
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d378 2
a379 2
				uint8		nPrioPos2 = GetRealPrio(sortedList.GetAt(pos2)->GetPriority());
				uint8		nPrioFile = GetRealPrio(pKnownFile->GetPriority());
@


1.73
log
@Formatting, comments, and name changes.
@
text
@d209 1
a209 1
			else 
d213 1
a213 1
				try 
d227 1
a227 1
				{ 
d281 1
a281 1
	pPacket->m_eOpcode = OP_OFFERFILES;	
d349 1
a349 1
		&& static_cast<uint32>(m_mapSharedFiles.GetCount()) <= pCurServer->GetSoftMaxFiles() ) 
d427 1
a427 1
	pPacket->m_eOpcode = OP_OFFERFILES;	
d440 1
a440 1
	
d552 2
a553 2
	g_eMuleApp.m_fileHashControl.AddToHash(this, pUnknownFile->m_strDirectory, pUnknownFile->m_strFileName); 	
	delete pUnknownFile;	
d652 1
a652 1
	
@


1.72
log
@from official: removed requesting the file status for files <= PARTSIZE
@
text
@d459 1
a459 1
	packetStream.Write(sharedFile.GetFileHash(),16);		// <HASH> file hash
d461 5
a465 4
	// if connected and highID, set client ID and port
	uint32 dwClientID = 0;
	uint16 uClientPort = 0;
	if(m_pServerConnect->IsConnected() && !m_pServerConnect->IsLowID())
d470 2
a471 2
	packetStream.Write(&dwClientID, 4);
	packetStream.Write(&uClientPort, 2);
a472 1
	//write a number of Tags
d474 1
a474 1
	packetStream.Write(&dwTagCount,4);	// <Tag_set> {<TAGCOUNT:DWORD> # tags determined by file type
d477 1
a477 1
	nameTag.WriteToFile(packetStream);					// (FT_FILENAME:string) file name
d480 1
a480 1
	sizeTag.WriteToFile(packetStream);					// (FT_FILESIZE:int) file size (bytes) }
d483 1
a483 1
	typeTag.WriteToFile(packetStream);
@


1.71
log
@Added some data for debug, changed some log lines.
@
text
@d437 1
a437 1
		UINT uUncomprSize = pPacket->m_dwSize;
@


1.70
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d301 1
a301 1
	if(bSendToServer)
d310 1
a310 1
	    if (bSendToServer)
@


1.69
log
@Separating engine and GUI
@
text
@d136 1
a136 1
		AddLogLine(false, IDS_SHAREDFOUNDHASHING,m_mapSharedFiles.GetCount(),m_waitingForHashList.GetCount());
@


1.68
log
@File Type correction & related name changes
@
text
@a23 1
#include "Sockets/EmEngine.h"
@


1.67
log
@New sockets
@
text
@a461 4
//	char buffer[sizeof(DWORD)+sizeof(WORD)];
//	memset2(buffer,0,sizeof(DWORD)+sizeof(WORD));		// <ID:DWORD> ClientID? = 0
//	packetStream.Write(buffer,sizeof(DWORD)+sizeof(WORD));// <PORT:WORD> port = 0

d463 2
a464 2
	ULONG nClientID = 0;
	USHORT nClientPort = 0;
d467 2
a468 2
		nClientID = m_pServerConnect->GetClientID();
		nClientPort = g_eMuleApp.m_pGlobPrefs->GetPort();
d470 2
a471 4
	packetStream.Write(&nClientID, sizeof(nClientID));
	packetStream.Write(&nClientPort, sizeof(nClientPort));

	uint32		dwSharedFileType = sharedFile.GetFileType();
d473 3
a475 1
	packetStream.Write(&dwSharedFileType,sizeof(DWORD));	// <Tag_set> {<TAGCOUNT:DWORD> # tags determined by file type
a477 1

a480 1

d483 2
a485 2

//	TODO: add tags for documents mp3 etc
@


1.66
log
@Fixes
@
text
@d459 1
d488 2
@


1.65
log
@New sockets
@
text
@d461 3
a463 1
	char		buffer[sizeof(DWORD)+sizeof(WORD)];
d465 10
a474 2
	memset2(buffer,0,sizeof(DWORD)+sizeof(WORD));		// <ID:DWORD> ClientID? = 0
	packetStream.Write(buffer,sizeof(DWORD)+sizeof(WORD));// <PORT:WORD> port = 0
@


1.64
log
@Fix for bug #0000460
@
text
@a444 2
#else
	g_eMuleApp.m_pEngine->SendSharedListToServer();
@


1.63
log
@New sockets
@
text
@d302 2
a303 1
	AddDebugLogLine(false, _T("Reloading shared files"));
@


1.62
log
@New sockets compilation fix
@
text
@d24 1
d267 2
d272 1
a283 1
#ifdef OLD_SOCKETS_ENABLED
d444 2
@


1.61
log
@prevent sharing of .bak .dir .settings .txtsrc etc. files
@
text
@d329 1
a333 1
#ifdef OLD_SOCKETS_ENABLED
a338 1
#endif //OLD_SOCKETS_ENABLED
a340 1
#ifdef OLD_SOCKETS_ENABLED
a418 1
#endif //OLD_SOCKETS_ENABLED
d439 1
a439 1
#ifdef OLD_SOCKETS_ENABLED
@


1.60
log
@1) compession support within communicatio client<->server
2) extended UDP file search support
@
text
@d191 1
a191 1
		if (!(strExtension==".part" || strExtension==".met" || strExtension==".dll" || strExtension==".sys" || strExtension==".drv" || strExtension==".tmp" || strExtension==".log" || strExtension==".torrent" || strExtension==".getright" || strExtension==".jc!"))
@


1.59
log
@free disk space needed is now determined with respect to NTFS compression and/or sparse files
@
text
@d331 2
d334 1
a334 1
	if (m_mapSharedFiles.IsEmpty() || !m_pServerConnect->IsConnected())
d347 2
a348 2
	if ( m_pServerConnect->GetCurrentServer()->GetSoftMaxFiles() != 0
	  && static_cast<uint32>(m_mapSharedFiles.GetCount()) <= m_pServerConnect->GetCurrentServer()->GetSoftMaxFiles() ) 
d397 1
a397 1
		dwNumFiles = m_pServerConnect->GetCurrentServer()->GetSoftMaxFiles();
d428 13
@


1.58
log
@Formatting, comments, and name changes.
@
text
@d200 1
@


1.57
log
@memleak due incorect clearing of waiting for hash list
@
text
@d527 1
a527 1
	UnknownFile_Struct *pUnknownFile = m_waitingForHashList.RemoveHead();
@


1.56
log
@Formatting, comments, and name changes.
@
text
@d53 4
d211 1
d218 1
a218 1
						UnknownFile_Struct		*pUnknownFile = new UnknownFile_Struct;
d228 3
a230 1
					err->Delete(); 
d311 5
a315 1
		m_waitingForHashList.RemoveAll();
d527 1
a527 1
	UnknownFile_Struct	   *pUnknownFile = m_waitingForHashList.RemoveHead();
@


1.55
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@a24 1

d31 9
a40 6
CSharedFileList::CSharedFileList(CPreferences* in_prefs,CServerConnect* in_server,CKnownFileList* in_filelist){
	m_pPrefs = in_prefs;
	server = in_server;
	m_pKnownFileList = in_filelist;
	m_pOutput = 0;
	CSingleLock sLock(&m_mutexList,true);
d42 1
d44 1
d46 2
a47 2
	m_lancast = new CLanCast(in_prefs);	// LANCAST (moosetea) - 
	m_bDelayReload=false;
d49 10
a58 4

// LANCAST (moosetea) - Broadcast the next hash 
void CSharedFileList::NextLANBroadcast(){
	if (g_eMuleApp.m_app_state != g_eMuleApp.APP_STATE_RUNNING )		//Cax2 - crash on exit bugfix
d61 2
a62 2
	static POSITION pos = 0;
	static CCKey bufKey;
d64 1
a64 1
	CKnownFile* cur_file;
d66 1
a66 2
	CSingleLock sLock(&m_mutexList,true);
	if (!m_mapSharedFiles.IsEmpty()){
d68 4
a71 1
		if (!pos)
d73 1
d75 4
a78 3
		if (pos) {
			m_mapSharedFiles.GetNextAssoc(pos,bufKey,cur_file);
			m_lancast->BroadcastHash(cur_file);
d83 8
d92 1
a92 3
CSharedFileList::~CSharedFileList(){
	delete m_lancast; //memory leak [TwoBottle Mod]
}
a93 4
void CSharedFileList::FindSharedFiles(){
	BOOL bEmpty;
	CSingleLock sLock1(&m_mutexList,true); // list thread safe
	bEmpty	=	m_mapSharedFiles.IsEmpty();
d95 6
a100 4
	if (!bEmpty){
		//--- xrmb:allyaknow ---
		CCKey		bufKey;
		CKnownFile* cur_file;		
d102 4
a105 2
		POSITION	pos=m_mapSharedFiles.GetStartPosition();
		while(pos)
d107 2
a108 2
			m_mapSharedFiles.GetNextAssoc(pos, bufKey, cur_file);
			cur_file->SetSharedFile(false);
a109 1
		//--- :xrmb ---
d111 1
d113 2
a114 1
		g_eMuleApp.m_pDownloadQueue->AddPartFilesToShare(); // readd partfiles
d116 2
a117 1
	if(!m_pPrefs->m_sharedDirList.Find(m_pPrefs->GetIncomingDir()) && !m_pPrefs->m_sharedDirList.Find(m_pPrefs->GetIncomingDir()+'\\'))
d119 2
a120 1
	for (POSITION pos = m_pPrefs->m_sharedDirList.GetHeadPosition();pos != 0;m_pPrefs->m_sharedDirList.GetNext(pos))
d122 1
d124 3
a126 1
	if (m_waitingForHashList.IsEmpty()) 
d128 1
d138 5
d144 27
a170 7
void CSharedFileList::AddFilesFromDirectory(const CString& directory){
	CString ext; //pruv3750
	CFileFind ff;
	CString searchpath;
	searchpath.Format(_T("%s\\*"),directory);
	bool end = !ff.FindFile(searchpath,0);	
	if (end)
d172 2
a173 2
	//ff.FindNextFile();
	while (!end)
d175 5
a179 2
		end = !ff.FindNextFile();
		if (ff.IsDirectory() || ff.IsDots() || ff.IsSystem() || ff.IsTemporary() || ff.GetLength()>=4294967295 )
d181 13
a193 10
		// Ultras: prevent to add the zero lenghts files
		if( !ff.GetLength() ) continue;
		CTime lwtime;
		ff.GetLastWriteTime(lwtime);
		ext= ff.GetFileName().Right(ff.GetFileName().GetLength()-ff.GetFileName().ReverseFind('.')).MakeLower() ; //pruv3750
		if (!(ext==".part" || ext==".met" || ext==".dll" || ext==".sys" || ext==".drv" || ext==".tmp" || ext==".log" || ext==".torrent" || ext==".getright" || ext==".jc!"))
		{
			uint32 fdate = mktime(lwtime.GetLocalTm());
			CKnownFile* toadd = m_pKnownFileList->FindKnownFile(ff.GetFileName().GetBuffer(),fdate,(uint32)ff.GetLength());
			if (toadd)
d195 6
a200 6
				toadd->SetPath(directory);
				CSingleLock sLock(&m_mutexList,true);
				//--- xrmb:allyaknow ---
				toadd->SetSharedFile(true);
				//--- :xrmb ---
				m_mapSharedFiles.SetAt(CCKey(toadd->GetFileHash()),toadd);
d202 2
a203 1
			} 
d206 1
a206 2
				//not in knownfilelist - start adding thread to hash file
				//eklmn: check construction
d209 10
a218 4
					UnknownFile_Struct* tohash = new UnknownFile_Struct;
					tohash->directory = directory;
					tohash->name = ff.GetFileName();
					m_waitingForHashList.AddTail(tohash);
d231 3
a233 1
void CSharedFileList::SafeAddKFile(CKnownFile *toadd, bool bOnlyAdd)
d235 6
a240 4
	//--- xrmb:allyaknow ---
//	Tell 'toadd' that it's being shared now
	toadd->SetSharedFile(true);
	//--- :xrmb ---
d242 2
a243 2
	// TODO: Check if the file is already known - only with another date
	CSingleLock sLock(&m_mutexList,true);
a244 2
//	Add 'toadd' to the shared files map
	m_mapSharedFiles.SetAt(CCKey(toadd->GetFileHash()),toadd);
d251 2
a252 2
	if (m_pOutput)
		m_pOutput->ShowFile(toadd);
d254 1
a254 1
	// offer new file to server
d256 1
a256 1
	if (!server->IsConnected())
d259 13
a271 10
	toadd->SetOfferedToServer(true);
	CMemFile files(100);
	uint32 filecount = 1;

	files.Write(&filecount,4);
	WriteToOfferedFilePacket(*toadd,files);

	Packet* packet = new Packet(&files);
	packet->m_eOpcode = OP_OFFERFILES;	
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
d273 1
a273 1
	server->SendPacket(packet,true);
d277 10
a286 9
// removes first occurrence of 'toremove' in 'list'
void CSharedFileList::RemoveFile(CKnownFile* toremove){
	//--- xrmb:allyaknow ---
	toremove->SetSharedFile(false);
	//--- :xrmb ---
	m_pOutput->RemoveFile(toremove);
	CSingleLock sLock(&m_mutexList,true);
	m_mapSharedFiles.RemoveKey(CCKey(toremove->GetFileHash()));
	m_pKnownFileList->RemoveFile(toremove);
d289 1
a289 1
void CSharedFileList::Reload(bool sendToServer /*=true*/)
d292 1
d297 1
a297 1
	    if (m_pOutput)
d299 1
a299 1
	    if (sendToServer)
d305 1
a305 1
		m_bDelayReload=true;
d309 3
a311 2
void CSharedFileList::SetOutputCtrl(CSharedFilesCtrl* in_ctrl){
	m_pOutput = in_ctrl;
d320 1
a320 1
	if (m_mapSharedFiles.IsEmpty() || !server->IsConnected())
d333 2
a334 2
	if ( server->GetCurrentServer()->GetSoftMaxFiles() != 0
	  && static_cast<uint32>(m_mapSharedFiles.GetCount()) <= server->GetCurrentServer()->GetSoftMaxFiles() ) 
d383 1
a383 1
		dwNumFiles = server->GetCurrentServer()->GetSoftMaxFiles();
d416 1
a416 1
	server->SendPacket(pPacket,true);
d453 21
a473 19
// -khaos--+++> New param:  pbytesLargest, pointer to uint64.
//				Various other changes to accomodate our new statistic...
//				Point of this is to find the largest file currently shared.
uint64 CSharedFileList::GetDatasize(uint64 &pbytesLargest) {
	pbytesLargest=0;
	// <-----khaos-
	uint64 fsize;
	fsize=0;

	CCKey bufKey;
	CKnownFile* cur_file;
	CSingleLock sLock(&m_mutexList,true);
	for (POSITION pos = m_mapSharedFiles.GetStartPosition();pos != 0;)
	{
		m_mapSharedFiles.GetNextAssoc(pos,bufKey,cur_file);
		fsize+=cur_file->GetFileSize();
		// -khaos--+++> If this file is bigger than all the others...well duh.
		if (cur_file->GetFileSize() > pbytesLargest) pbytesLargest = cur_file->GetFileSize();
		// <-----khaos-
d475 2
a476 1
	return fsize;
d492 6
a497 4
short CSharedFileList::GetFilePriorityByID(uchar* filehash){
	CKnownFile* tocheck = GetFileByID(filehash);
	if (tocheck)
		return tocheck->GetPriority();
d505 1
a505 1
	if(m_bDelayReload==true)
d508 1
a508 1
		m_bDelayReload=false;
d516 1
a516 32
	UnknownFile_Struct* nextfile = m_waitingForHashList.RemoveHead();

	g_eMuleApp.m_fileHashControl.AddToHash(this,nextfile->directory,nextfile->name); 	
	delete nextfile;	
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CAddFileThread, CWinThread)
CAddFileThread::CAddFileThread(){
	m_pOwner = 0;	
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SetValues() sets the thread parameters
void CAddFileThread::SetValues( CSharedFileList *pOwner, LPCTSTR in_directory, LPCTSTR in_filename,
							    CPartFile* in_partfile_Owner)
{
	 m_pOwner = pOwner;
	 directory = in_directory;
	 filename = in_filename;
	 partfile_Owner = in_partfile_Owner;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CAddFileThread::Run()
{
//	If there is neither a SharedFileList owner or a PartFile owner or if there's no filename...
	if (!(m_pOwner || partfile_Owner) || filename.IsEmpty())
		AfxEndThread(0,true);

	CSingleLock sLock1(&(g_eMuleApp.m_mutexHashing)); // only one filehash at a time

	sLock1.Lock();

	CKnownFile		*newRecord = new CKnownFile();
d518 2
a519 19
//	Try to create a hashed KnownFile for the spec'd file. If successful...
	if (newRecord->CreateFromFile(directory,filename))
	{
	//	Notify the PartFile (via a message to the eMule window) that the file it was
	//		completing has finished hashing.
		if (g_eMuleApp.m_pdlgEmule)
			PostMessage( g_eMuleApp.m_pdlgEmule->m_hWnd,
						 TM_FINISHEDHASHING,
						 (m_pOwner ? 0 : (WPARAM)partfile_Owner),
						 (LPARAM)newRecord);
	}
	else
	{
		delete newRecord;
	}

	sLock1.Unlock();
	AfxEndThread(0,true);
	return 0;
d532 1
a532 1
// #zegzav:vdir4list (BEGIN)
d536 1
d596 1
a596 1

d623 56
a678 1
// #zegzav:vdir4list (END)
@


1.54
log
@check object onstruction in AddFilesFromDirectory()
@
text
@d254 1
a254 1
	CMemFile		packetFile;
d260 1
a260 1
//	If the connected server has a soft file limit and we have fewer packetFile than the limit shared...
d265 1
a265 1
		packetFile.Write(&dwNumFiles,sizeof(DWORD));			// <count:DWORD> Shared file count
d270 1
a270 1
			WriteToOfferedFilePacket(*pKnownFile,packetFile);	// (offered file info)[count]
d315 1
a315 1
		packetFile.Write(&dwNumFiles,sizeof(DWORD));				// <count:DWORD> Shared file count
d324 1
a324 1
			WriteToOfferedFilePacket(*sortedList.GetNext(pos),packetFile);	// (offered file info)[count]
d339 1
a339 1
	Packet		*pPacket = new Packet(&packetFile);
d357 1
a357 1
void CSharedFileList::WriteToOfferedFilePacket(CKnownFile &sharedFile,CMemFile &packetFile)
d359 1
a359 1
	packetFile.Write(sharedFile.GetFileHash(),16);		// <HASH> file hash
d364 1
a364 1
	packetFile.Write(buffer,sizeof(DWORD)+sizeof(WORD));// <PORT:WORD> port = 0
d368 1
a368 1
	packetFile.Write(&dwSharedFileType,sizeof(DWORD));	// <Tag_set> {<TAGCOUNT:DWORD> # tags determined by file type
d372 1
a372 1
	nameTag.WriteToFile(packetFile);					// (FT_FILENAME:string) file name
d376 1
a376 1
	sizeTag.WriteToFile(packetFile);					// (FT_FILESIZE:int) file size (bytes) }
@


1.53
log
@no message
@
text
@d121 2
a122 1
	while (!end){
d135 2
a136 1
			if (toadd){
d144 3
a146 1
			} else {
d148 13
a160 4
				UnknownFile_Struct* tohash = new UnknownFile_Struct;
				tohash->directory = directory;
				tohash->name = ff.GetFileName();
				m_waitingForHashList.AddTail(tohash);
@


1.52
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@a339 3
#ifndef ASYNC_UI_UPDATES
		m_pOutput->UpdateOfferedItems();
#else
a340 1
#endif ASYNC_UI_UPDATES
a481 6
#ifndef ASYNC_UI_UPDATES
	if (m_pOutput != NULL)
	{
		m_pOutput->UpdateItem(pKnownFile,bResort);
	}
#else
a487 1
#endif ASYNC_UI_UPDATES
@


1.51
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d22 1
d354 1
a354 1
	memset(buffer,0,sizeof(DWORD)+sizeof(WORD));		// <ID:DWORD> ClientID? = 0
@


1.50
log
@Formatting, comments, and name changes. Factored "UpdateOfferedItems()" method out and modified to use async. messaging instead of sync. call.
@
text
@d342 1
a342 1
		m_pOutput->PostMessage(MP_SFL_UPDATEOFFEREDITEMS,0,0);
d483 1
a483 1
void CSharedFileList::UpdateItem(CKnownFile* toupdate,bool resort)
d485 13
a497 1
	m_pOutput->UpdateItem(toupdate,resort);
@


1.49
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d38 1
a38 1
	m_Files_map.InitHashTable(1024);
d56 1
a56 1
	if (!m_Files_map.IsEmpty()){
d59 1
a59 1
			pos = m_Files_map.GetStartPosition();
d62 1
a62 1
			m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
d76 1
a76 1
	bEmpty	=	m_Files_map.IsEmpty();
d83 1
a83 1
		POSITION	pos=m_Files_map.GetStartPosition();
d86 1
a86 1
			m_Files_map.GetNextAssoc(pos, bufKey, cur_file);
d90 1
a90 1
		m_Files_map.RemoveAll();
d100 1
a100 1
		AddLogLine(false, IDS_SHAREDFOUND,m_Files_map.GetCount());
d104 1
a104 1
		AddLogLine(false, IDS_SHAREDFOUNDHASHING,m_Files_map.GetCount(),m_waitingForHashList.GetCount());
d139 1
a139 1
				m_Files_map.SetAt(CCKey(toadd->GetFileHash()),toadd);
d164 1
a164 1
	m_Files_map.SetAt(CCKey(toadd->GetFileHash()),toadd);
d184 1
a184 1
	CreateOfferedFilePacket(*toadd,files);
d201 1
a201 1
	m_Files_map.RemoveKey(CCKey(toremove->GetFileHash()));
d228 4
a232 2
void CSharedFileList::SendListToServer(){
	CSingleLock sLock(&m_mutexList,true);
d234 1
a234 1
	if (m_Files_map.IsEmpty() || !server->IsConnected())
d236 3
d240 2
a241 2
	CMemFile files;
	CCKey bufKey;
d243 2
a244 2
	CKnownFile* cur_file;
	uint32 filecount;
d246 3
a248 2
//	Send all files
	if (server->GetCurrentServer()->GetSoftFiles() && (uint32)m_Files_map.GetCount()<=server->GetCurrentServer()->GetSoftFiles() ) 
d250 4
a253 3
		filecount = m_Files_map.GetCount();
		files.Write(&filecount,4);
		for (POSITION pos = m_Files_map.GetStartPosition();pos != 0;)
d255 3
a257 3
			m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
			CreateOfferedFilePacket(*cur_file,files);
			cur_file->SetOfferedToServer(true);
d262 7
a268 5
		// send subset
		POSITION pos, pos2;
		CTypedPtrList<CPtrList, CKnownFile*> sortedList;
		bool added=false;
		for (pos= m_Files_map.GetStartPosition(); pos!=0;)
d270 1
a270 2
			m_Files_map.GetNextAssoc(pos, bufKey, cur_file);
			added=false;
d272 4
a275 2
			//insertsort into sortedList
			for (pos2 = sortedList.GetHeadPosition();pos2 != 0 && !added;sortedList.GetNext(pos2))
d277 8
a284 3
				uint8 nPrioPos2= GetRealPrio(sortedList.GetAt(pos2)->GetPriority());
				uint8 nPrioFile= GetRealPrio(cur_file->GetPriority());
				if ((nPrioPos2 < nPrioFile) || ((nPrioPos2 == nPrioFile) && (sortedList.GetAt(pos2)->GetFileName().CompareNoCase(cur_file->GetFileName()) > 0)))
d286 3
a288 2
					sortedList.InsertBefore(pos2,cur_file);
					added=true;
d291 3
a293 2
			if (!added)
				sortedList.AddTail(cur_file);
d295 10
a304 6
		// add to packet
		filecount = server->GetCurrentServer()->GetSoftFiles();
		if (filecount == 0) // if we don't know the soft limit, we send all our files
			filecount = sortedList.GetCount();
		files.Write(&filecount,4);
		uint32 count=0;
d306 1
a306 1
		while (pos != 0 && count<filecount)
d308 1
a308 1
			count++;
d310 1
a310 1
			CreateOfferedFilePacket(*sortedList.GetNext(pos),files);
d312 3
a314 1
		while (pos != 0 && count<(uint32)sortedList.GetCount())
d316 1
a316 1
			count++;
a321 2
	if (m_pOutput)
		m_pOutput->UpdateOfferedItems();
d323 6
a328 3
	Packet* packet = new Packet(&files);
	packet->m_eOpcode = OP_OFFERFILES;	
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
d330 1
a330 1
	server->SendPacket(packet,true);
d333 19
d353 16
a368 14
void CSharedFileList::CreateOfferedFilePacket(CKnownFile& cur_file,CMemFile& files){
	files.Write(cur_file.GetFileHash(),16);
	char buffer[6];
	memset(buffer,0,6);
	files.Write(buffer,6);	
	uint32 fType =	cur_file.GetFileType();
	files.Write(&fType,4);
	CFileTag* nametag = new CFileTag(FT_FILENAME,cur_file.GetFileName());
	nametag->WriteToFile(files);
	delete nametag;
	CFileTag* sizetag = new CFileTag(FT_FILESIZE,cur_file.GetFileSize());
	sizetag->WriteToFile(files);
	delete sizetag;
	//TODO add tags for documents mp3 etc
d370 1
a370 1

d383 1
a383 1
	for (POSITION pos = m_Files_map.GetStartPosition();pos != 0;)
d385 1
a385 1
		m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
d401 1
a401 1
	if (m_Files_map.Lookup(tKey,pResultFile))
@


1.48
log
@Formatting, comments, and name changes.
@
text
@d187 2
a188 2
	packet->opcode = OP_OFFERFILES;	
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
d303 2
a304 2
	packet->opcode = OP_OFFERFILES;	
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
d317 2
a318 2
	CTag* nametag = new CTag(FT_FILENAME,cur_file.GetFileName());
	nametag->WriteTagToFile(files);
d320 2
a321 2
	CTag* sizetag = new CTag(FT_FILESIZE,cur_file.GetFileSize());
	sizetag->WriteTagToFile(files);
@


1.47
log
@added .jc! files (FlashGet temporary download files) to share filter.
it's incredible what crap some people share :P
@
text
@d348 7
d356 2
a357 6
CKnownFile*	CSharedFileList::GetFileByID(const uchar* filehash){
	CKnownFile* result;
	CCKey tkey(filehash);
	CSingleLock sLock(&m_mutexList,true);
	if (m_Files_map.Lookup(tkey,result))
		return result;
d359 1
a359 1
		return 0;
d361 1
a361 1

@


1.46
log
@don't share .GetRight files (incomplete downloads)
@
text
@d129 1
a129 1
		if (!(ext==".part" || ext==".met" || ext==".dll" || ext==".sys" || ext==".drv" || ext==".tmp" || ext==".log" || ext==".torrent" || ext==".getright"))
@


1.45
log
@Formatting, comments, and name changes.
@
text
@d129 1
a129 1
		if (!(ext==".part" || ext==".met" || ext==".dll" || ext==".sys" || ext==".drv" || ext==".tmp" || ext==".log" || ext==".torrent"))
@


1.44
log
@Changed log of files been hashed (better way of knowing remaining ones)
@
text
@d19 1
a19 1
#include "sharedfilelist.h"
d35 1
a35 1
	filelist = in_filelist;
d132 1
a132 1
			CKnownFile* toadd = filelist->FindKnownFile(ff.GetFileName().GetBuffer(),fdate,(uint32)ff.GetLength());
d202 1
a202 1
	filelist->RemoveFile(toremove);
@


1.43
log
@Log for files that has been hashed
@
text
@d102 2
d105 1
a530 5

int CSharedFileList::GetRemainingToBeHashed()
{
	return m_waitingForHashList.GetCount();
}
@


1.42
log
@Fixed a NEW_SOCKETS compiler warning.
@
text
@d528 5
@


1.41
log
@Category rewrite with predefined status/media type categories.
@
text
@d234 1
a238 1
#ifdef OLD_SOCKETS_ENABLED
@


1.40
log
@Formatting, comments, and name changes.
@
text
@d524 2
a525 2
	for (int i= 0; i < m_pPrefs->GetCatCount(); i++)
		AddSharedVDirForList(false, m_pPrefs->GetCatPath(i));
@


1.39
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d33 1
a33 1
	app_prefs = in_prefs;
d37 1
a37 1
	CSingleLock sLock(&list_mut,true);
d55 1
a55 1
	CSingleLock sLock(&list_mut,true);
d75 1
a75 1
	CSingleLock sLock1(&list_mut,true); // list thread safe
d94 4
a97 4
	if(!app_prefs->m_sharedDirList.Find(app_prefs->GetIncomingDir()) && !app_prefs->m_sharedDirList.Find(app_prefs->GetIncomingDir()+'\\'))
		AddFilesFromDirectory(app_prefs->GetIncomingDir().GetBuffer());
	for (POSITION pos = app_prefs->m_sharedDirList.GetHeadPosition();pos != 0;app_prefs->m_sharedDirList.GetNext(pos))
		AddFilesFromDirectory(app_prefs->m_sharedDirList.GetAt(pos).GetBuffer());
d132 1
a132 1
				CSingleLock sLock(&list_mut,true);
d158 1
a158 1
	CSingleLock sLock(&list_mut,true);
d197 1
a197 1
	CSingleLock sLock(&list_mut,true);
d227 1
a227 1
	CSingleLock sLock(&list_mut,true);
d334 1
a334 1
	CSingleLock sLock(&list_mut,true);
d349 1
a349 1
	CSingleLock sLock(&list_mut,true);
d503 1
a503 1
	if (!app_prefs)
d510 2
a511 2
	AddSharedVDirForList(true, app_prefs->GetTempDir());
	pos= app_prefs->m_tempDirList.GetHeadPosition();
d513 1
a513 1
		AddSharedVDirForList(true, app_prefs->m_tempDirList.GetNext(pos));
d516 1
a516 1
	AddSharedVDirForList(false, app_prefs->GetIncomingDir());
d519 1
a519 1
    pos = app_prefs->m_sharedDirList.GetHeadPosition();
d521 1
a521 1
		AddSharedVDirForList(false, app_prefs->m_sharedDirList.GetNext(pos));
d524 2
a525 2
	for (int i= 0; i < app_prefs->GetCatCount(); i++)
		AddSharedVDirForList(false, app_prefs->GetCatPath(i));
@


1.38
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d94 1
a94 1
	if(!app_prefs->shareddir_list.Find(app_prefs->GetIncomingDir()) && !app_prefs->shareddir_list.Find(app_prefs->GetIncomingDir()+'\\'))
d96 2
a97 2
	for (POSITION pos = app_prefs->shareddir_list.GetHeadPosition();pos != 0;app_prefs->shareddir_list.GetNext(pos))
		AddFilesFromDirectory(app_prefs->shareddir_list.GetAt(pos).GetBuffer());
d511 1
a511 1
	pos= app_prefs->tempdir_list.GetHeadPosition();
d513 1
a513 1
		AddSharedVDirForList(true, app_prefs->tempdir_list.GetNext(pos));
d519 1
a519 1
    pos = app_prefs->shareddir_list.GetHeadPosition();
d521 1
a521 1
		AddSharedVDirForList(false, app_prefs->shareddir_list.GetNext(pos));
@


1.37
log
@Second batch of name changes
@
text
@d47 1
a47 1
	if (theApp.m_app_state != theApp.APP_STATE_RUNNING )		//Cax2 - crash on exit bugfix
d92 1
a92 1
		theApp.downloadqueue->AddPartFilesToShare(); // readd partfiles
d185 1
a185 1
	theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
d301 1
a301 1
	theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
d380 1
a380 1
	theApp.m_FilesHashing.AddToHash(this,nextfile->directory,nextfile->name); 	
d405 1
a405 1
	CSingleLock sLock1(&(theApp.hashing_mut)); // only one filehash at a time
d416 2
a417 2
		if (theApp.emuledlg)
			PostMessage( theApp.emuledlg->m_hWnd,
@


1.36
log
@don't share .torrent files
@
text
@d36 1
a36 1
	output = 0;
d42 1
a42 1
	delayreload=false;
d99 1
a99 1
	if (waitingforhash_list.IsEmpty()) 
d102 1
a102 1
		AddLogLine(false, IDS_SHAREDFOUNDHASHING,m_Files_map.GetCount(),waitingforhash_list.GetCount());
d143 1
a143 1
				waitingforhash_list.AddTail(tohash);
d149 3
a151 2

void CSharedFileList::SafeAddKFile(CKnownFile* toadd, bool bOnlyAdd){
d153 1
d159 2
d163 2
d167 3
a169 2
	if (output)
		output->ShowFile(toadd);
d179 1
d182 1
d190 1
a190 1

d196 1
a196 1
	output->RemoveFile(toremove);
d201 3
a203 2

void CSharedFileList::Reload(bool sendtoserver){
d205 2
a206 1
	if (waitingforhash_list.IsEmpty())
d209 3
a211 3
	    if (output)
		    output->ShowFileList(this);
	    if (sendtoserver)
d216 2
a217 2
		waitingforhash_list.RemoveAll();
		delayreload=true;
d220 1
a220 1

d222 2
a223 2
	output = in_ctrl;
	output->ShowFileList(this);
d237 1
a237 1
	// send all files
d296 2
a297 2
	if (output)
		output->UpdateOfferedItems();
d363 1
a363 1

d366 2
a367 1
	if(delayreload==true)
d369 2
a370 1
		delayreload=false;
d374 2
a375 1
	if (waitingforhash_list.IsEmpty())
d377 3
a379 1
	UnknownFile_Struct* nextfile = waitingforhash_list.RemoveHead();
d383 1
a383 1

d388 5
a392 1
void CAddFileThread::SetValues(CSharedFileList* pOwner, LPCTSTR in_directory, LPCTSTR in_filename, CPartFile* in_partfile_Owner){
d398 4
a401 2

int CAddFileThread::Run(){
d404 1
d406 1
d408 8
a415 2
	CKnownFile* newrecord = new CKnownFile();
	if (newrecord->CreateFromFile(directory,filename)){
d417 4
a420 2
			PostMessage(theApp.emuledlg->m_hWnd,TM_FINISHEDHASHING,(m_pOwner ? 0:(WPARAM)partfile_Owner),(LPARAM)newrecord);
	
d422 3
a424 2
	else{
		delete newrecord;
d431 6
a436 3

void CSharedFileList::UpdateItem(CKnownFile* toupdate,bool resort) {output->UpdateItem(toupdate,resort);}

@


1.35
log
@updated OP_ASKSHAREDDIRS for categories
@
text
@d126 1
a126 1
		if (!(ext==".part" || ext==".met" || ext==".dll" || ext==".sys" || ext==".drv" || ext==".tmp" || ext==".log"))
@


1.34
log
@added OP_ASKSHAREDDIRS protocol
@
text
@d411 2
a487 1
	/* TODO: activate this lines if categories share their path
a489 1
	*/
@


1.33
log
@Preparing for new sockets
@
text
@d104 1
d400 92
@


1.32
log
@new statistic (khaos based)
@
text
@d226 1
d283 1
@


1.31
log
@share files with soft limit
@
text
@d309 6
a314 1
uint64 CSharedFileList::GetDatasize() {
d321 2
a322 1
	for (POSITION pos = m_Files_map.GetStartPosition();pos != 0;){
d325 3
@


1.30
log
@unicode cleanup
@
text
@d168 1
a220 3
	uint32 filecount = m_Files_map.GetCount();
	files.Write(&filecount,4);
	
d223 58
a280 3
	for (POSITION pos = m_Files_map.GetStartPosition();pos != 0;){
		m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
		CreateOfferedFilePacket(*cur_file,files);
d282 2
@


1.29
log
@fix for crash
@
text
@d111 1
a111 1
	searchpath.Format("%s\\*",directory);
d192 1
a192 1
	AddDebugLogLine(false, "Reloading shared files");
@


1.28
log
@char * to CString conversion
@
text
@d107 1
a107 1
void CSharedFileList::AddFilesFromDirectory(char* directory){
@


1.27
log
@char * to CString conversion
@
text
@d240 1
a240 1
	char* buffer = new char[6];
d242 1
a242 2
	files.Write(buffer,6);
	delete[] buffer;
@


1.26
log
@Preparing for new sockets
@
text
@d140 2
a141 2
				tohash->directory = nstrdup(directory);
				tohash->name = nstrdup(ff.GetFileName().GetBuffer());
d298 2
a299 5
	theApp.m_FilesHashing.AddToHash(this,nextfile->directory,nextfile->name); 
	delete[] nextfile->directory; 
	delete[] nextfile->name;
	delete nextfile;
	
@


1.25
log
@converted to new logger methods
@
text
@d164 1
d167 1
d175 1
d177 1
a177 1
	
d215 1
d218 1
d233 1
d235 1
@


1.24
log
@code cleanup
@
text
@d100 1
a100 1
		AddLogLine(false,GetResString(IDS_SHAREDFOUND),m_Files_map.GetCount());
d102 1
a102 1
		AddLogLine(false,GetResString(IDS_SHAREDFOUNDHASHING),m_Files_map.GetCount(),waitingforhash_list.GetCount());
@


1.23
log
@code cleanup
@
text
@d166 1
a166 1
	CMemFile* files = new CMemFile(100);
d168 4
a171 5
	files->Write(&filecount,4);
	CreateOfferedFilePacket(toadd,files);
	Packet* packet = new Packet(files);
	packet->opcode = OP_OFFERFILES;
	delete files;
d214 1
a214 1
	CMemFile* files = new CMemFile();
d216 1
a216 1
	files->Write(&filecount,4);
d222 1
a222 1
		CreateOfferedFilePacket(cur_file,files);
d225 2
a226 3
	Packet* packet = new Packet(files);
	packet->opcode = OP_OFFERFILES;
	delete files;
d231 2
a232 2
void CSharedFileList::CreateOfferedFilePacket(CKnownFile* cur_file,CMemFile* files){
	files->Write(cur_file->GetFileHash(),16);
d235 1
a235 1
	files->Write(buffer,6);
d237 3
a239 3
	uint32 fType =	cur_file->GetFileType();
	files->Write(&fType,4);
	CTag* nametag = new CTag(FT_FILENAME,cur_file->GetFileName());
d242 1
a242 1
	CTag* sizetag = new CTag(FT_FILESIZE,cur_file->GetFileSize());
@


1.22
log
@coverted code from char * to CString
@
text
@d264 1
a264 1
CKnownFile*	CSharedFileList::GetFileByID(uchar* filehash){
@


1.21
log
@coverted code from char * to CString
@
text
@d302 1
a302 3
	m_pOwner = 0;
	filename = 0;
	directory = 0;
d306 2
a307 2
	 directory = nstrdup(in_directory);
	 filename = nstrdup(in_filename);
d312 1
a312 1
	if (!(m_pOwner || partfile_Owner) || !filename)
a325 3
	delete[] filename;
	if (directory)
		delete[] directory;
@


1.20
log
@const correctness
@
text
@d110 3
a112 4
	char* searchpath = new char[strlen(directory)+3];
	sprintf(searchpath,"%s\\*",directory);
	bool end = !ff.FindFile(searchpath,0);
	delete[] searchpath;
@


1.19
log
@netwolf's changes
@
text
@d307 1
a307 1
void CAddFileThread::SetValues(CSharedFileList* pOwner, char* in_directory, char* in_filename, CPartFile* in_partfile_Owner){
@


1.18
log
@#0000258
bug, crash
0-byte file crash
@
text
@d119 1
a119 1
		if (ff.IsDirectory() || ff.IsDots() || ff.IsSystem() || ff.IsTemporary())
@


1.17
log
@More exception handling
@
text
@d121 2
@


1.16
log
@fix crash at exit
@
text
@d189 1
d192 6
a197 6
		FindSharedFiles();
		if (output)
			output->ShowFileList(this);
		if (sendtoserver)
			SendListToServer();
	}
@


1.15
log
@Fixed bugs #185, #153 & #28
@
text
@d318 2
a319 1
		PostMessage(theApp.emuledlg->m_hWnd,TM_FINISHEDHASHING,(m_pOwner ? 0:(WPARAM)partfile_Owner),(LPARAM)newrecord);
@


1.14
log
@*** empty log message ***
@
text
@d42 1
d94 2
a95 1
	AddFilesFromDirectory(app_prefs->GetIncomingDir().GetBuffer());
d189 13
a201 5
	FindSharedFiles();
	if (output)
		output->ShowFileList(this);
	if (sendtoserver)
		SendListToServer();
d282 6
@


1.14.2.1
log
@27c
@
text
@d117 1
a117 1
		if (ff.IsDirectory() || ff.IsDots() || ff.IsSystem() || ff.IsTemporary() || ff.GetLength()>=4294967295 )
a218 13
}

CKnownFile* CSharedFileList::GetFileByIndex(int index){
	int count=0;
	CKnownFile* cur_file;
	CCKey bufKey;

	for (POSITION pos = m_Files_map.GetStartPosition();pos != 0;){
		m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
		if (index==count) return cur_file;
		count++;
	}
	return 0;
@


1.13
log
@*** empty log message ***
@
text
@d183 1
@


1.12
log
@*** empty log message ***
@
text
@d316 1
a316 1
void CSharedFileList::UpdateItem(CKnownFile* toupdate,bool resort=true) {output->UpdateItem(toupdate,resort);}
@


1.11
log
@*** empty log message ***
@
text
@d316 1
a316 1
void CSharedFileList::UpdateItem(CKnownFile* toupdate) {output->UpdateItem(toupdate);}
@


1.10
log
@more bugfixes!
@
text
@d226 2
a227 1
	files->Write(cur_file->GetFileTypePtr(),4);
@


1.9
log
@converted to new logging method
@
text
@d46 2
@


1.8
log
@fixed memory leak
@
text
@d96 1
a96 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_SHAREDFOUND),m_Files_map.GetCount());
d98 1
a98 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_SHAREDFOUNDHASHING),m_Files_map.GetCount(),waitingforhash_list.GetCount());
@


1.7
log
@Fix for crash bug rehashing the files that was caused because of LANcast thread
@
text
@d67 1
@


1.6
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d37 1
d39 1
d52 1
d63 1
d70 5
a74 2
	if (!m_Files_map.IsEmpty()){
		CSingleLock sLock1(&list_mut,true); // list thread safe
d78 1
d93 1
d98 1
d178 1
d196 1
d209 1
d239 1
d250 1
@


1.5
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d24 1
d39 21
@


1.4
log
@overhead parameters change
@
text
@d24 7
@


1.3
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d128 1
a128 1
	theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
d171 1
a171 1
	theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
@


1.2
log
@first compile with .25 codebase!
@
text
@d128 1
d171 1
@


1.2.4.1
log
@initial upgrade to .26
@
text
@a127 1
	theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
a169 1
	theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d231 35
@

