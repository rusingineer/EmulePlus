head	1.5;
access;
symbols
	PublicRelease_1_2e:1.5
	Interim_Release_1-2e_RC1:1.5
	PublicRelease_1_2d:1.5
	Interim_Release_1-2d_RC1:1.5
	Interim_Release_1-2d_beta1:1.5
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.3
	Interim_Release_1-1e_RC2:1.3
	Interim_Release_1-1e_RC1:1.3
	Interim_Release_1-1e_beta1:1.3
	PublicRelease_1_1d:1.3
	Interim_Release_1-1d_RC1:1.3
	PublicRelease_1_1c:1.3
	Interim_Release_1-1c_RC1:1.3
	Interim_Release_1-1c_beta2:1.3
	Interim_Release_1-1c_beta1:1.3
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	Interim_Release_1n_beta2:1.2
	Interim_Release_1n_beta1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.5
date	2008.02.03.02.20.16;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.17.23.46.06;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.19.21.10.51;	author netwolf1;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.15.13.41.14;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.23;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.27;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Fixed stuck splitter control in messages window when focus is lost while holding mouse (ways to reproduce: Alt-Tab, shortcut to minimize, shortcut to switch to the next window);
Suppressed compiler warnings.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( devs@@emule-project.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "SplitterControl.h"
#include "opcodes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CSplitterControl

HCURSOR CSplitterControl::m_hcurMoveVert = NULL;
HCURSOR CSplitterControl::m_hcurMoveHorz = NULL;

BEGIN_MESSAGE_MAP(CSplitterControl, CStatic)
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
END_MESSAGE_MAP()

CSplitterControl::CSplitterControl()
{
	// Mouse is pressed down or not ?
	m_bIsPressed = FALSE;	

	// Min and Max range of the splitter.
	m_nMin = m_nMax = -1;
}

CSplitterControl::~CSplitterControl()
{
}

void CSplitterControl::Create(DWORD dwStyle, const CRect &rect, CWnd *pParent, UINT nID)
{
	CRect rc = rect;
	
	// Determine default type base on it's size.
	m_nType = (rc.Width() < rc.Height()) ? SPS_VERTICAL : SPS_HORIZONTAL;
	
	if (m_nType == SPS_VERTICAL)
		rc.right = rc.left + 5;
	else // SPS_HORIZONTAL
		rc.bottom = rc.top + 5;
	
	CStatic::Create(_T(""), dwStyle | SS_NOTIFY, rc, pParent, nID);
	
	if (!m_hcurMoveVert)
	{
		m_hcurMoveVert = ::LoadCursor(NULL, IDC_SIZEWE);
		m_hcurMoveHorz = ::LoadCursor(NULL, IDC_SIZENS);
	}
	
	// force the splitter not to be split
	SetRange(0, 0, -1);
}

void CSplitterControl::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

	RECT rcClient, rc;

	GetClientRect(&rcClient);
	rc.left = rcClient.left + 1;
	rc.top = rcClient.top + 1;
	rc.right = rcClient.right - 1;
	rc.bottom = rcClient.bottom - 1;
	dc.FillSolidRect(&rc, ::GetSysColor(COLOR_3DFACE));
	dc.Draw3dRect(&rcClient, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW));
}

void CSplitterControl::OnMouseMove(UINT nFlags, CPoint point)
{
	if (m_bIsPressed)
	{
		CWnd		*pParent = GetParent();
		CWindowDC	dc(NULL);

		DrawLine(&dc);
		
		CPoint pt = point;
		ClientToScreen(&pt);
		pParent->ScreenToClient(&pt);

		if (pt.x < m_nMin)
			pt.x = m_nMin;
		if (pt.y < m_nMin)
			pt.y = m_nMin;

		if (pt.x > m_nMax)
			pt.x = m_nMax;
		if (pt.y > m_nMax)
			pt.y = m_nMax;

		pParent->ClientToScreen(&pt);
		m_nX = pt.x;
		m_nY = pt.y;
		DrawLine(&dc);
	}
	CStatic::OnMouseMove(nFlags, point);
}

BOOL CSplitterControl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	if (nHitTest == HTCLIENT)
	{
		::SetCursor((m_nType == SPS_VERTICAL) ? m_hcurMoveVert : m_hcurMoveHorz);
		return 0;
	}
	else
		return CStatic::OnSetCursor(pWnd, nHitTest, message);
}

void CSplitterControl::OnLButtonDown(UINT nFlags, CPoint point)
{
	CStatic::OnLButtonDown(nFlags, point);
	
	m_bIsPressed = TRUE;
	SetCapture();
	CRect rcWnd;
	GetWindowRect(rcWnd);
	
	if (m_nType == SPS_VERTICAL)
		m_nSavePos = m_nX = rcWnd.left;
	else
		m_nSavePos = m_nY = rcWnd.top;

	CWindowDC dc(NULL);
	DrawLine(&dc);
}

void CSplitterControl::OnLButtonUp(UINT nFlags, CPoint point) 
{
	if (m_bIsPressed)
	{
		ReleaseCapture();
		ClientToScreen(&point);
		EraseTrace();

		CPoint pt(m_nX, m_nY);
		CWnd *pOwner = GetOwner();
		if (pOwner && IsWindow(pOwner->m_hWnd))
		{
			pOwner->ScreenToClient(&pt);
			MoveWindowTo(pt);

			SPC_NMHDR nmsp;
			nmsp.hdr.hwndFrom = m_hWnd;
			nmsp.hdr.idFrom = GetDlgCtrlID();
			nmsp.hdr.code = UM_SPN_SIZED;
			nmsp.delta = ((m_nType == SPS_VERTICAL) ? m_nX : m_nY) - m_nSavePos;
			pOwner->SendMessage(WM_NOTIFY, nmsp.hdr.idFrom, (LPARAM)&nmsp);
		}
	}

	CStatic::OnLButtonUp(nFlags, point);
}

void CSplitterControl::DrawLine(CDC *pDC)
{
	int nRop = pDC->SetROP2(R2_NOTXORPEN);

	CRect rcWnd;
	GetWindowRect(rcWnd);
	
	CPen pen;
	pen.CreatePen(PS_SOLID, 1, RGB(200, 200, 200));
	CPen *pOP = pDC->SelectObject(&pen);
	
	if (m_nType == SPS_VERTICAL)
	{
		pDC->MoveTo(m_nX - 1, rcWnd.top);
		pDC->LineTo(m_nX - 1, rcWnd.bottom);

		pDC->MoveTo(m_nX + 1, rcWnd.top);
		pDC->LineTo(m_nX + 1, rcWnd.bottom);
	}
	else // m_nType == SPS_HORIZONTAL
	{
		pDC->MoveTo(rcWnd.left, m_nY - 1);
		pDC->LineTo(rcWnd.right, m_nY - 1);
		
		pDC->MoveTo(rcWnd.left, m_nY + 1);
		pDC->LineTo(rcWnd.right, m_nY + 1);
	}
	pDC->SetROP2(nRop);
	pDC->SelectObject(pOP);
}

void CSplitterControl::MoveWindowTo(CPoint pt)
{
	CRect rc;
	GetWindowRect(rc);

	CWnd* pParent;
	pParent = GetParent();
	if (!pParent || !::IsWindow(pParent->m_hWnd))
		return;

	pParent->ScreenToClient(rc);
	if (m_nType == SPS_VERTICAL)
	{	
		int nMidX = (rc.left + rc.right) / 2;
		int dx = pt.x - nMidX;
		rc.OffsetRect(dx, 0);
	}
	else
	{	
		int nMidY = (rc.top + rc.bottom) / 2;
		int dy = pt.y - nMidY;
		rc.OffsetRect(0, dy);
	}
	MoveWindow(rc);
}

void CSplitterControl::ChangeWidth(CWnd *pParent, int iCtrlID, int iDx, DWORD dwFlag/*=CW_LEFTALIGN*/)
{
	if (pParent && ::IsWindow(pParent->m_hWnd))
	{
		CWnd	*pWnd = pParent->GetDlgItem(iCtrlID);
		CRect	rcWnd;

		pWnd->GetWindowRect(rcWnd);
		pParent->ScreenToClient(rcWnd);
		if (dwFlag == CW_LEFTALIGN)
			rcWnd.right += iDx;
		else if (dwFlag == CW_RIGHTALIGN)
			rcWnd.left -= iDx;
		pWnd->MoveWindow(rcWnd);
	}
}

void CSplitterControl::ChangeHeight(CWnd *pParent, int iCtrlID, int iDy, DWORD dwFlag/*=CW_TOPALIGN*/)
{
	if (pParent && ::IsWindow(pParent->m_hWnd))
	{
		CWnd	*pWnd = pParent->GetDlgItem(iCtrlID);
		CRect	rcWnd;

		pWnd->GetWindowRect(rcWnd);
		pParent->ScreenToClient(rcWnd);
		if (dwFlag == CW_TOPALIGN)
			rcWnd.bottom += iDy;
		else if (dwFlag == CW_BOTTOMALIGN)
			rcWnd.top -= iDy;
		pWnd->MoveWindow(rcWnd);
	}
	else ASSERT(0);
}

void CSplitterControl::ChangePos(CWnd *pParent, int iCtrlID, int iDx, int iDy)
{
	if (pParent && ::IsWindow(pParent->m_hWnd))
	{
		CWnd	*pWnd = pParent->GetDlgItem(iCtrlID);
		CRect	rcWnd;

		pWnd->GetWindowRect(rcWnd);
		pParent->ScreenToClient(rcWnd);
		rcWnd.OffsetRect(-iDx, iDy);
		pWnd->MoveWindow(rcWnd);
	}	
}

void CSplitterControl::SetRange(int nMin, int nMax)
{
	m_nMin = nMin;
	m_nMax = nMax;
}

// Set splitter range from (nRoot - nSubtraction) to (nRoot + nAddition)
// If (nRoot < 0)
//		nRoot =  <current position of the splitter>
void CSplitterControl::SetRange(int nSubtraction, int nAddition, int nRoot)
{
	if (nRoot < 0)
	{
		CRect rcWnd;
		GetWindowRect(rcWnd);
		GetParent()->ScreenToClient(rcWnd); // need to work in client coordinates
		if (m_nType == SPS_VERTICAL)
			nRoot = rcWnd.left + rcWnd.Width() / 2;
		else // if m_nType == SPS_HORIZONTAL
			nRoot = rcWnd.top + rcWnd.Height() / 2;
	}
	m_nMin = nRoot - nSubtraction;
	m_nMax = nRoot + nAddition;
}

void CSplitterControl::EraseTrace()
{
//	Undo previous drawing
	if (m_bIsPressed)
	{
		CWindowDC dc(NULL);

		DrawLine(&dc);
		m_bIsPressed = FALSE;
	}
}

void CSplitterControl::OnCancelMode()
{
	CWnd *pOwner = GetOwner();

	m_bIsPressed = FALSE;
//	Force redraw to erase last splitter marker
	if (pOwner && IsWindow(pOwner->m_hWnd))
	{
		SPC_NMHDR nmsp;

		nmsp.hdr.hwndFrom = m_hWnd;
		nmsp.hdr.idFrom = GetDlgCtrlID();
		nmsp.hdr.code = UM_SPN_SIZED;
		nmsp.delta = 0;
		pOwner->SendMessage(WM_NOTIFY, nmsp.hdr.idFrom, (LPARAM)&nmsp);
	}
	CWnd::OnCancelMode();
}

void CSplitterControl::CancelTracking()
{
	EraseTrace();
	ReleaseCapture();
}
@


1.4
log
@Adjustable splitter (adapted from original with optimization and fixes).
@
text
@d17 1
d41 1
d103 1
a103 1
		DrawLine(&dc, m_nX, m_nY);
d122 1
a122 1
		DrawLine(&dc, m_nX, m_nY);
d153 1
a153 1
	DrawLine(&dc, m_nX, m_nY);
d160 1
d162 1
a162 1
		CWindowDC dc(NULL);
a163 1
		DrawLine(&dc, m_nX, m_nY);
a164 1
		m_bIsPressed = FALSE;
a180 1
	ReleaseCapture();
d183 1
a183 1
void CSplitterControl::DrawLine(CDC* pDC, int x, int y)
d191 1
a191 1
	pen.CreatePen(0, 1, RGB(200, 200, 200));
d304 1
d313 37
@


1.3
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d1 2
a2 1
// SplitterControl.cpp : implementation file
d4 13
a16 1

d19 1
d27 1
d31 10
a40 4
// hCursor1 is for vertiacal one
// and hCursor2 is for horizontal one
static HCURSOR SplitterControl_hCursor1 = NULL;
static HCURSOR SplitterControl_hCursor2 = NULL;
a54 20

BEGIN_MESSAGE_MAP(CSplitterControl, CStatic)
	//{{AFX_MSG_MAP(CSplitterControl)
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_SETCURSOR()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSplitterControl message handlers

/****************************************************
*	Create(DWORD dwStyle, const CRect& rect, CWnd* pParent, nID)
*	Use this function instead of the CStatic::Create function
* Parameters: No need to explain (see MSDN (:-) )
*
****************************************************/
a57 1
	dwStyle |= SS_NOTIFY;
d60 1
a60 3
	m_nType = (rc.Width() < rc.Height())?
					SPS_VERTICAL:
					SPS_HORIZONTAL;
d67 1
a67 1
	CStatic::Create(_T(""), dwStyle, rc, pParent, nID);
d69 1
a69 1
	if (!SplitterControl_hCursor1)
d71 2
a72 2
		SplitterControl_hCursor1 = AfxGetApp()->LoadStandardCursor(IDC_SIZEWE);
		SplitterControl_hCursor2 = AfxGetApp()->LoadStandardCursor(IDC_SIZENS);
d75 1
a75 1
	// force the splitter not to be splited.
a78 13
// Set style for splitter control
// nStyle = SPS_VERTICAL or SPS_HORIZONTAL
int CSplitterControl::SetStyle(int nStyle)
{
	int m_nOldStyle = m_nType;
	m_nType = nStyle;
	return m_nOldStyle;
}
int CSplitterControl::GetStyle()
{
	return m_nType;
}

a81 5
	CRect rcClient;
	GetClientRect(rcClient);
	
	CBrush br, *pOB;
	CPen pen, *pOP;
d83 1
a83 9
	dc.Draw3dRect(rcClient, GetSysColor(COLOR_BTNHIGHLIGHT), GetSysColor(COLOR_BTNSHADOW));	
	rcClient.DeflateRect(1,1,1,1);
	
	pen.CreatePen(0, 1, RGB(200, 200, 200));
	br.CreateSolidBrush(RGB(200, 220, 220));
	pOB = dc.SelectObject(&br);
	pOP = dc.SelectObject(&pen);
	
	dc.Rectangle(rcClient);
d85 7
a91 3
	// Restore pen and brush
	dc.SelectObject(pOB);
	dc.SelectObject(pOP);
d94 1
a94 1
void CSplitterControl::OnMouseMove(UINT nFlags, CPoint point) 
d98 3
a100 1
		CWindowDC dc(NULL);
d105 1
a105 1
		GetParent()->ScreenToClient(&pt);
d117 1
a117 1
		GetParent()->ClientToScreen(&pt);
d129 1
a129 2
		(m_nType == SPS_VERTICAL)?(::SetCursor(SplitterControl_hCursor1))
			:(::SetCursor(SplitterControl_hCursor2));
d136 1
a136 1
void CSplitterControl::OnLButtonDown(UINT nFlags, CPoint point) 
d146 1
a146 7
		m_nX = rcWnd.left + rcWnd.Width() / 2;	
	
	else
		m_nY = rcWnd.top  + rcWnd.Height() / 2;
	
	if (m_nType == SPS_VERTICAL)
		m_nSavePos = m_nX;
d148 1
a148 1
		m_nSavePos = m_nY;
a166 3
			CRect rc;
			int delta;
			pOwner->GetClientRect(rc);
a169 6
			if (m_nType == SPS_VERTICAL)
				delta = m_nX - m_nSavePos;
			else
				delta = m_nY - m_nSavePos;
			
			
a170 1
		
d172 3
a174 4
			nmsp.hdr.idFrom   = GetDlgCtrlID();
			nmsp.hdr.code     = SPN_SIZED;
			nmsp.delta = delta;

a187 1
	int d = 1;
d189 2
a190 1
	CPen  pen;
d196 2
a197 2
		pDC->MoveTo(m_nX - d, rcWnd.top);
		pDC->LineTo(m_nX - d, rcWnd.bottom);
d199 2
a200 2
		pDC->MoveTo(m_nX + d, rcWnd.top);
		pDC->LineTo(m_nX + d, rcWnd.bottom);
d204 2
a205 2
		pDC->MoveTo(rcWnd.left, m_nY - d);
		pDC->LineTo(rcWnd.right, m_nY - d);
d207 2
a208 2
		pDC->MoveTo(rcWnd.left, m_nY + d);
		pDC->LineTo(rcWnd.right, m_nY + d);
d218 1
d240 1
a240 1
void CSplitterControl::ChangeWidth(CWnd *pWnd, int dx, DWORD dwFlag)
a241 1
	CWnd* pParent = pWnd->GetParent();
d244 3
a246 1
		CRect rcWnd;
d250 1
a250 1
			rcWnd.right += dx;
d252 1
a252 1
			rcWnd.left -= dx;
d257 1
a257 1
void CSplitterControl::ChangeHeight(CWnd *pWnd, int dy, DWORD dwFlag)
a258 1
	CWnd* pParent = pWnd->GetParent();
d261 3
a263 1
		CRect rcWnd;
d267 1
a267 1
			rcWnd.bottom += dy;
d269 1
a269 1
			rcWnd.top -= dy;
d272 1
d275 1
a275 1
void CSplitterControl::ChangePos(CWnd* pWnd, int dx, int dy)
a276 1
	CWnd* pParent = pWnd->GetParent();
d279 3
a281 1
		CRect rcWnd;
d284 1
a284 2
		rcWnd.OffsetRect(-dx, dy);

d311 1
a311 1
}@


1.2
log
@unicode cleanup
@
text
@d114 2
a115 2
	DeleteObject(dc.SelectObject(pOB));
	DeleteObject(dc.SelectObject(pOP));
@


1.1
log
@*** empty log message ***
@
text
@d69 1
a69 1
	CStatic::Create("", dwStyle, rc, pParent, nID);
@


1.1.4.1
log
@updating this branch...
@
text
@@

