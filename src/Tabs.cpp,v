head	1.16;
access;
symbols
	PublicRelease_1_2e:1.16
	Interim_Release_1-2e_RC1:1.16
	PublicRelease_1_2d:1.16
	Interim_Release_1-2d_RC1:1.15
	Interim_Release_1-2d_beta1:1.15
	PublicRelease_1_2c:1.12
	Interim_Release_1-2c_RC1:1.12
	Interim_Release_1-2c_beta1:1.11
	PublicRelease_1_2b:1.11
	Interim_Release_1-2b_RC1:1.11
	PublicRelease_1_2a:1.11
	Interim_Release_1-2a_RC1:1.11
	Interim_Release_1-2a_beta2:1.11
	Interim_Release_1-2a_beta1:1.11
	PublicRelease_1_2:1.11
	Interim_Release_1-2_RC1:1.11
	Interim_Release_1-2_beta1:1.11
	PublicRelease_1_1g:1.10
	Interim_Release_1-1g_RC3:1.10
	Interim_Release_1-1g_RC2:1.10
	Interim_Release_1-1g_RC1:1.10
	Interim_Release_1-1g_beta2:1.10
	Interim_Release_1-1g_beta1:1.10
	PublicRelease_1_1f:1.10
	Interim_Release_1-1f_RC1:1.10
	PublicRelease_1_1e:1.10
	Interim_Release_1-1e_RC2:1.10
	Interim_Release_1-1e_RC1:1.10
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.10
	Interim_Release_1-1c_beta2:1.10
	Interim_Release_1-1c_beta1:1.10
	PublicRelease_1_1b:1.10
	Interim_Release_1-1b_RC1:1.10
	PublicRelease_1_1a:1.10
	Interim_Release_1-1a_RC2:1.10
	Interim_Release_1-1a_RC1:1.10
	Interim_Release_1-1a_beta2:1.10
	Interim_Release_1-1a_beta1:1.10
	PublicRelease_1_1:1.10
	Interim_Release_1-1_beta1:1.10
	PublicRelease_1o:1.10
	Interim_Release_1o_RC1:1.10
	Interim_Release_1o_beta1:1.10
	PublicRelease_1n:1.10
	Interim_Release_1n_RC2:1.10
	Interim_Release_1n_RC1:1.10
	Interim_Release_1n_beta2:1.10
	Interim_Release_1n_beta1:1.10
	PublicRelease_1m:1.10
	Interim_Release_1m_beta1:1.10
	PublicRelease_1l:1.9
	Interim_Release_1l_RC3:1.9
	Interim_Release_1l_RC2:1.9
	Interim_Release_1l_RC1:1.9
	Interim_Release_1l_beta2:1.9
	Interim_Release_1l_beta1:1.9
	PublicRelease_1k:1.9
	Interim_Release_1k_RC4:1.9
	Interim_1k_RC3:1.9
	Interim_1k_RC2:1.9
	Interim_Release_1k_RC1:1.9
	Interim_Release_1k_beta5:1.9
	Intrerim_Release_1k_beta4:1.9
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.7
	Interim_Release_1J_RC3:1.7
	Interim_Release_1j_RC3:1.7
	Interim_Release_1j_RC2:1.7
	Interim_Release_1j_RC1:1.7
	Interim_Release_1j_beta2:1.7
	Interim_Release_1j_beta1:1.7
	PublicRelease_1i:1.7
	Interim_Release_1i_RC6:1.7
	Interim_Release_1i_RC3:1.7
	Interim_Release_1i_RC2:1.7
	Interim_Release_1i_RC1:1.7
	Interim_Release_1i_beta3:1.7
	Interim_Release_1i_beta2:1.7
	Interim_Release_1i_beta1:1.7
	PublicRelease_1h:1.4
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.4
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2;
locks; strict;
comment	@// @;


1.16
date	2008.05.14.03.38.11;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.17.22.02.51;	author eklmn;	state Exp;
branches;
next	1.14;

1.14
date	2007.11.03.09.51.28;	author eklmn;	state Exp;
branches;
next	1.13;

1.13
date	2007.11.03.09.42.35;	author eklmn;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.08.00.14.19;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.15.05.05.47;	author katsyonak;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.20.20.52.26;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.05.00.00.02;	author kush_eplus;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.25.15.08.55;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.25.14.41.49;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.25.13.07.36;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.23.08.18.03;	author forcha;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.15.15.11.29;	author forcha;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.03.20.49.13;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Suppressed compiler warnings.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "Tabs.h"
#include "otherfunctions.h"

//IMPLEMENT_DYNAMIC(CTabs, _TAB_BASECLASS)
CTabs::CTabs()
{
}

CTabs::~CTabs()
{
}


BEGIN_MESSAGE_MAP(CTabs, _TAB_BASECLASS)
	ON_WM_CREATE()
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
END_MESSAGE_MAP()


int CTabs::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (_TAB_BASECLASS::OnCreate(lpCreateStruct) == -1)
		return -1;

	ModifyStyle(0, TCS_OWNERDRAWFIXED);
#ifdef _UNICODE
//	Win9x: Explicitly set to Unicode to receive Unicode notifications.
	SendMessage(CCM_SETUNICODEFORMAT, TRUE);
#endif

	return 0;
}

void CTabs::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC			dc;

	dc.Attach(lpDIS->hDC);
	DrawItem(&dc, lpDIS->itemID);
	dc.Detach();
}

void CTabs::DrawItem(CDC *pDC, int iItem)
{
	CRect		rItem, rClient;

	GetItemRect(iItem, rItem);
	GetClientRect(rClient);
#ifndef NEW_LOOK
	rItem.top = rClient.top;
	rItem.bottom = rClient.bottom + 1;
#endif

	CGdiObject* pOldFont = pDC->SelectStockObject(DEFAULT_GUI_FONT);

	TCHAR	acText[512];
	TCITEM	tcItem;

	tcItem.mask = TCIF_TEXT;
	tcItem.pszText = acText;
	tcItem.cchTextMax = ARRSIZE(acText);
	GetItem(iItem, &tcItem);

	if (GetCurSel() == iItem)
	{
#ifdef NEW_LOOK
		rItem.top = rClient.top;
		rItem.bottom = rClient.bottom + 1;
#endif
		pDC->FillSolidRect(rItem, GetSysColor(COLOR_BTNFACE));
		pDC->Draw3dRect(rItem, GetSysColor(COLOR_BTNHILIGHT), GetSysColor(COLOR_BTNSHADOW));
		pDC->SetTextColor(GetSysColor(COLOR_BTNTEXT));
		pDC->SetBkColor(GetSysColor(COLOR_BTNFACE));
	}
	else
	{
#ifndef NEW_LOOK
		CPen		cpPen, *pOldPen;

		cpPen.CreatePen(PS_SOLID, 0, LightenColor(GetRGBColorTabs(), -40));
		pOldPen = pDC->SelectObject(&cpPen);
#else
		CPen		cpPen, cpPen2, *pOldPen;

		cpPen2.CreatePen(PS_SOLID, 0, RGB(0, 0, 0));

		pOldPen = pDC->SelectObject(&cpPen);
//		rItem.top = rClient.top;
		rItem.bottom = rClient.bottom + 1;
//		pDC->FillSolidRect(&rItem,GetRGBColorTabs());
//		pDC->Draw3dRect(&rItem,GetRGBColorTabs(),GetSysColor(COLOR_BTNSHADOW));
		pDC->FillSolidRect(rItem, GetSysColor(COLOR_BTNFACE));
		pDC->Draw3dRect(rItem, GetSysColor(COLOR_BTNHILIGHT), GetSysColor(COLOR_BTNSHADOW));
#endif //NEW_LOOK
		if (GetCurSel() != iItem - 1)
		{
			pDC->MoveTo(rItem.left, rItem.top + 2);
			pDC->LineTo(rItem.left, rItem.bottom - 2);
		}
		if (GetCurSel() != iItem + 1)
		{
			pDC->MoveTo(rItem.right, rItem.top + 2);
			pDC->LineTo(rItem.right, rItem.bottom - 2);
		}
#ifdef NEW_LOOK
		pDC->MoveTo(rItem.left + 1, rItem.top);
		pDC->MoveTo(rItem.right - 1, rItem.top);
#endif

		pDC->SelectObject(pOldPen);

		pDC->SetTextColor(GetRGBColorGrayText());
#ifndef NEW_LOOK
		pDC->SetBkColor(GetRGBColorTabs());
#else
		pDC->SetBkColor(GetSysColor(COLOR_BTNFACE));
#endif
	}

	CRect		rText = rItem;

	rText.DeflateRect(2, 2, 2, 2);
	pDC->DrawText(acText, -1, rText, DT_NOPREFIX|DT_NOCLIP|DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS);

	CWnd		*pSB = GetWindow(GW_CHILD);

	if (pSB != NULL)
	{
		CRect		rSB;

		pSB->GetWindowRect(rSB);
		ScreenToClient(&rSB);

		if (rSB.PtInRect(rItem.TopLeft()) ||
			rSB.PtInRect(rItem.BottomRight()) ||
			rSB.PtInRect(CPoint(rItem.right, rItem.top)) ||
			rSB.PtInRect(CPoint(rItem.left, rItem.bottom)) ||
			rItem.PtInRect(rSB.TopLeft()) ||
			rItem.PtInRect(rSB.BottomRight()) ||
			rItem.PtInRect(CPoint(rSB.right, rSB.top)) ||
			rItem.PtInRect(CPoint(rSB.left, rSB.bottom)))
		{
			pSB->Invalidate();
		}
	}

	pDC->SelectObject(pOldFont);
}

BOOL CTabs::OnEraseBkgnd(CDC* pDC)
{
	NOPRM(pDC);
	return FALSE;
}

void CTabs::OnPaint()
{
	CPaintDC		dc(this); // device context for painting
	CRect			rClient;

	GetClientRect(rClient);
#ifndef NEW_LOOK
	dc.FillSolidRect(rClient, GetRGBColorTabs());
#else
	dc.FillSolidRect(rClient, ::GetSysColor(COLOR_DESKTOP));
#endif

	int				iItemCount = GetItemCount();

	for(int i = 0; i < iItemCount; i++)
	{
		DrawItem(&dc, i);
	}
}

COLORREF CTabs::GetRGBColorTabs()
{
	int			iRed = GetRValue(GetRGBColorXP());
	int			iGreen = GetGValue(GetRGBColorXP());
	int			iBlue = GetBValue(GetRGBColorXP());
	int			iMax = 255 - max(max(iRed, iGreen), iBlue);
	
	iMax = iMax - (int)(iMax * 0.51);

	return RGB(iRed + iMax, iGreen + iMax, iBlue + iMax);
}

COLORREF CTabs::GetRGBColorXP()
{
	COLORREF		cr = GetSysColor(COLOR_3DFACE);

	return RGB(((3 * GetRValue(cr) + 240) / 4) + 1,
			   ((3 * GetGValue(cr) + 240) / 4) + 1,
			   ((3 * GetBValue(cr) + 240) / 4) + 1);
}

COLORREF CTabs::GetRGBColorGrayText()
{
	int			iRed = 0;
	int			iGreen = 0;
	int			iBlue = 0;

	iRed = iRed >> 1;
	iGreen = iGreen >> 1;
	iBlue = iBlue >> 1;

	int			iMax = 255 - max(max(iRed, iGreen), iBlue);

	iMax = iMax - (int)(iMax * 0.60);

	return RGB(iRed + iMax, iGreen + iMax, iBlue + iMax);
}
@


1.15
log
@set Unicode message format for Win9x systems
@
text
@d1 1
a1 1
// Tabs2.cpp : implementation file
d3 13
a20 2
// CTabs

a37 3

// CTabs message handlers

d70 1
a70 1
#endif NEW_LOOK
d87 1
a87 1
#endif NEW_LOOK
a99 1

d112 1
a112 1
#endif NEW_LOOK
d126 1
a126 1
#endif NEW_LOOK
d135 1
a135 1
#endif NEW_LOOK
d170 1
d184 1
a184 1
#endif NEW_LOOK
@


1.14
log
@remove includes of "UseDialogFont.h"
@
text
@d36 4
@


1.13
log
@1) don't use a class to get the dialog font
2) change font from ANSI to default
@
text
@a5 1
#include "UseDialogFont.h"
@


1.12
log
@Optimized DrawText -- no need to create temporary CString.
@
text
@d61 1
a61 1
	CUseDialogFont Font(pDC);
d154 2
@


1.11
log
@UNICODE preparation (first shot)
@
text
@d131 1
a131 1
	pDC->DrawText(acText, rText, DT_NOPREFIX|DT_NOCLIP|DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS);
@


1.10
log
@IRC channel messages now supports background color coded messages (Thanks SyruS!);
Added a Word Wrap context menu option to logs, IRC & messages;
Fixed category tabs padding (Mantis bug #0000415);
Improved logs, IRC & messages code + formatting & name changes
@
text
@d63 2
a64 2
	char		szText[512] = "";
	TCITEM		tcItem;
d67 2
a68 2
	tcItem.pszText = szText;
	tcItem.cchTextMax = sizeof(szText);
d131 1
a131 1
	pDC->DrawText(szText, rText, DT_NOPREFIX|DT_NOCLIP|DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS);
@


1.9
log
@Fixed tab title of category name containg '&'.
@
text
@d43 2
a44 1
	CDC dc;
d52 2
a53 1
	CRect rItem;
a54 2

	CRect rClient;
d58 1
a58 1
	rItem.bottom = rClient.bottom+1;	// let it attache to the header
d63 3
a65 2
	char szText[512] = "";
	TCITEM tcItem;
d71 1
a71 1
	if(GetCurSel() == iItem)
d75 1
a75 1
		rItem.bottom = rClient.bottom+1;	// let it attache to the header
d85 2
a86 1
		CPen cpPen, *pOldPen;
d91 3
a93 2
		CPen cpPen, cpPen2, *pOldPen;
		cpPen2.CreatePen(PS_SOLID, 0, RGB(0,0,0));
d97 1
a97 1
		rItem.bottom = rClient.bottom+1;	// let it attache to the header
d103 1
a103 1
		if(GetCurSel() != iItem - 1)
d108 1
a108 1
		if(GetCurSel() != iItem + 1)
d114 2
a115 2
		pDC->MoveTo(rItem.left+1, rItem.top);
		pDC->MoveTo(rItem.right-1, rItem.top);
d128 3
a130 2
	CRect rText = rItem;
	rText.DeflateRect(2,2,2,2);
d133 3
a135 2
	CWnd *pSB = GetWindow(GW_CHILD);
	if(pSB)
d137 2
a138 1
		CRect rSB;
d163 2
a164 1
	CPaintDC dc(this); // device context for painting
a165 1
	CRect rClient;
d173 2
a174 1
	int iItemCount = GetItemCount();
d183 6
a188 6
	int r = GetRValue(GetRGBColorXP());
	int g = GetGValue(GetRGBColorXP());
	int b = GetBValue(GetRGBColorXP());

	int iMax = 255 - max(max(r,g),b);
	iMax = iMax - (int)(iMax*0.51);
d190 1
a190 1
	return RGB(r + iMax, g + iMax, b + iMax);
d195 1
a195 1
	COLORREF cr = GetSysColor(COLOR_3DFACE);
d204 9
a212 7
	int r = 0;
	int g = 0;
	int b = 0;

	r = r >> 1;
	g = g >> 1;
	b = b >> 1;
a213 1
	int iMax = 255 - max(max(r,g),b);
d216 1
a216 1
	return RGB(r + iMax, g + iMax, b + iMax);
@


1.8
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d127 1
a127 1
	pDC->DrawText(szText, rText, DT_CENTER|DT_VCENTER|DT_SINGLELINE|DT_END_ELLIPSIS);
@


1.7
log
@Changed the #ifdefs to use a single switch. Put NEW_LOOK into your preprocessor defines for the new look.
@
text
@d60 1
a60 1
	
d87 1
a87 1
		
d114 1
a114 1
		
d136 1
a136 1
		if (rSB.PtInRect(rItem.TopLeft()) || 
d138 1
a138 1
			rSB.PtInRect(CPoint(rItem.right, rItem.top)) || 
d151 1
a151 1
{	
d182 1
a182 1
	
d189 1
a189 1
	
d207 1
a207 1
	
@


1.6
log
@*sigh* more CVS problems. The CORRECT code.
@
text
@d56 1
a56 1
#ifdef OLD
d59 1
a59 1
#endif OLD
d72 1
a72 1
#ifndef NEW
d75 1
a75 1
#endif NEW
d83 1
a83 1
#ifdef OLD
d99 1
a99 1
#endif OLD
d110 1
a110 1
#ifndef NEW
d113 1
a113 1
#endif NEW
d118 1
a118 1
#ifdef OLD
d122 1
a122 1
#endif OLD
d161 1
a161 1
#ifdef OLD
d165 1
a165 1
#endif OLD
@


1.5
log
@My poor attempt to achieve the "Psy" look. :(
@
text
@d56 1
d59 1
d118 1
d120 3
d161 1
d163 3
@


1.4
log
@*** empty log message ***
@
text
@d70 4
d81 1
d86 12
d108 4
@


1.3
log
@*** empty log message ***
@
text
@d101 20
@


1.2
log
@*** empty log message ***
@
text
@d1 1
a1 1
// Tabs.cpp : implementation file
d6 2
a8 7
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
d11 1
a13 1
	m_cfFont.CreateFont(-11,0,0,0,400,0,0,0,0,1,2,1,34,"MS Sans Serif");
d21 3
a23 2
BEGIN_MESSAGE_MAP(CTabs, _TABS_BASECLASS)
	//{{AFX_MSG_MAP(CTabs)
a24 1
	//}}AFX_MSG_MAP
d27 2
a28 1
/////////////////////////////////////////////////////////////////////////////
d31 1
a31 1
void CTabs::OnPaint() 
d33 4
a36 4
	CPaintDC dc(this); // device context for painting
	
	CRect rClient;
	GetClientRect(rClient);
d38 1
a38 2
	dc.FillSolidRect(rClient, GetRGBColorTabs());
	DrawTabs(&dc);
d41 7
d49 3
a51 8
void CTabs::DrawItem(CDC *pDC, int iItem, bool bSel)
{	
	

	TC_ITEM tci;
	CRect	rItem;
	char	szTabText[100];

a52 2
	if(!bSel)
		rItem.DeflateRect(1,0,1,0);
d54 4
a57 8

	memset(szTabText, '\0', sizeof(szTabText));

	tci.mask        = TCIF_TEXT;
	tci.pszText     = szTabText;
	tci.cchTextMax  = sizeof(szTabText)-1;

	GetItem(iItem, &tci);
d59 1
a59 4
//	if(bSel)
	
	COLORREF crBackColor = GetSysColor(COLOR_BTNFACE);;
	COLORREF crTextColor = RGB(0,255,0);
d61 6
d68 1
a68 26
	pDC->SetBkColor(crBackColor);
	pDC->SetTextColor(crTextColor);
	pDC->SetBkMode(TRANSPARENT);
	
	pDC->FillSolidRect(rItem, crBackColor);
	pDC->Draw3dRect(rItem, GetSysColor(COLOR_BTNHILIGHT), GetSysColor(COLOR_3DDKSHADOW));
	pDC->DrawText(szTabText, strlen(szTabText), rItem, DT_SINGLELINE|DT_CENTER|DT_VCENTER); 
	
}

void CTabs::DrawTabs(CDC* dc)
{
	CPen light(PS_SOLID,1,GetSysColor(COLOR_BTNHIGHLIGHT));
	CPen Dark(PS_SOLID,1,GetSysColor(COLOR_BTNSHADOW));
	CPen Black(PS_SOLID,1,GetSysColor(BLACK_PEN));	
	CRect rectText;
	CFont* m_fontOld=dc->SelectObject(&m_cfFont);
	CPen* oldPen= dc->SelectObject(&light);
	CString szStrPoints=_T("...");

	int iNumtabs = GetItemCount();
	int iSelectedTab = GetCurSel();

	CRect rScrollBox;
	CWnd *pwndScrollBox = GetWindow(GW_CHILD);
	if(pwndScrollBox)
d70 4
a73 2
		pwndScrollBox->GetWindowRect(rScrollBox);
		ScreenToClient(&rScrollBox);
d75 1
a75 3


	for(int iCont = 0; iCont < iNumtabs;iCont++)
d77 3
a79 9
		char	szTabText[100];
		TC_ITEM tci;
		CRect	rect;

		memset(szTabText, '\0', sizeof(szTabText));

		tci.mask        = TCIF_TEXT;
		tci.pszText     = szTabText;
		tci.cchTextMax  = sizeof(szTabText)-1;
d81 1
a81 5
		GetItem(iCont, &tci);
		GetItemRect(iCont, rect);
	//	rect.DeflateRect(0,4,0,4);
						
		if(iCont == iSelectedTab)
d83 2
a84 22
			CBrush cbr;
			CRect  rectTabAux=rect;
			rectTabAux.DeflateRect(1,1);
			rectTabAux.top-=4;	
			rectTabAux.bottom=rectTabAux.top+4;
		
			cbr.CreateSysColorBrush(COLOR_BTNFACE);
			
			dc->FillRect(rect,&cbr);
			dc->MoveTo(rect.left,rect.top-3);
			dc->LineTo(rect.left,rect.bottom-1);
			dc->FillRect(rectTabAux,&cbr);

			dc->SelectStockObject(BLACK_PEN);
			dc->MoveTo(rect.left,rect.bottom-1);
			dc->LineTo(rect.right,rect.bottom-1);
						
			dc->SelectStockObject(BLACK_PEN);
			dc->MoveTo(rect.right-1,rect.top-1);
			dc->LineTo(rect.right-1,rect.bottom-1);
			cbr.DeleteObject();

d86 1
a86 1
		else
d88 2
a89 7
			if((iCont+1) != iSelectedTab)
			{
				CPen* pOldPen=dc->SelectObject(&Dark);
				dc->MoveTo(rect.right-1,rect.top+2);
				dc->LineTo(rect.right-1,rect.bottom-2);
				dc->SelectObject(pOldPen);
			}
d92 19
a110 90
		int nMode = dc->SetBkMode(TRANSPARENT);
		CSize m_sChar=dc->GetTextExtent(tci.pszText,strlen(tci.pszText));
		COLORREF clrtext;
		if(iCont != iSelectedTab)
			clrtext=dc->SetTextColor(GetRGBColorGrayText());
		
	/*	if(m_sizeImag.cx+m_sChar.cx < rect.Width()-8)  
		{
			Image.Draw(dc,ct->uIcon,CPoint(ct->rect.left+2,ct->rect.top+2),ILD_TRANSPARENT);
			rectText=ct->rect;
			rectText.left+=m_sizeImag.cx+8;
			rectText.right-=2;
			dc->DrawText(ct->lpMsg,rectText,DT_SINGLELINE|DT_LEFT|DT_VCENTER);
			CToolTip.SetToolRect(this,iCont+1,CRect(0,0,0,0));
		}
		else
		{
			//verificamos si se puede poner algun texto o
			//por lo memos el icono
			if (m_sizeImag.cx < ct->rect.Width())
			{
				Image.Draw(dc,ct->uIcon,CPoint(ct->rect.left+2,ct->rect.top+2),ILD_TRANSPARENT);
				rectText=ct->rect;
				rectText.left+=m_sizeImag.cx+8;
				rectText.right-=5;
				CString m_cadBreak=ct->lpMsg;
				int c=0;
				int cont=m_cadBreak.GetLength();
				while(cont > 1 )
				{
					CString m_scadtemp=m_cadBreak+szStrPoints;
					CSize coor=dc->GetTextExtent(m_scadtemp,m_scadtemp.GetLength());
					if(coor.cx > rectText.Width())
						m_cadBreak=m_cadBreak.Left(m_cadBreak.GetLength()-1);
					else
						break;
					cont--;

				}
				m_cadBreak+=szStrPoints;
				rectText.right+=3;
			
				dc->DrawText(m_cadBreak,rectText,DT_SINGLELINE|DT_LEFT|DT_VCENTER);
				CToolTip.SetToolRect(this,iCont+1,&ct->rect);
			}
			
		
			
		}
	*/	
		dc->DrawText(tci.pszText,rect,DT_SINGLELINE|DT_CENTER|DT_VCENTER);
		
		if(iCont != iSelectedTab)
				dc->SetTextColor(clrtext);
		dc->SetBkMode(nMode);


		if(pwndScrollBox)
		{		
			if(rect.right > rScrollBox.left - 7)
			{	
				if(rScrollBox.left - 7 - rect.left > 5)
				{				
					CRect rClear = rect;
					rClear.left = rScrollBox.left - 7;
					if(iCont == iSelectedTab)
						rClear.top -= 4;
					else
						rClear.DeflateRect(0,2);
					
					dc->FillSolidRect(rClear, GetRGBColorTabs());	
					
									
					CPen* pOldPen=dc->SelectObject(iCont == iSelectedTab ? &Black : &Dark);
					dc->MoveTo(rClear.left,rClear.top);
					int x = 1, xd = 1;
					for(int y = rClear.top; y < rClear.bottom; y+=3)
					{
						dc->MoveTo(rClear.left-2 + x, y);
						dc->LineTo(rClear.left-2 + x, y+3 < rClear.bottom ? y+3 : rClear.bottom);
						
						x += xd;
						if(x >= 2 || x <= 0)
							xd = -xd;
					}
							
					dc->SelectObject(pOldPen);
				}
				else
					dc->FillSolidRect(rect, GetRGBColorTabs());
d112 3
a114 4
				iCont = iNumtabs;
			}
		}
	}	
d116 5
a120 2
	dc->SelectObject(oldPen);
	dc->SelectObject(m_fontOld);
d125 6
a130 11
	BYTE byRvalue = GetRValue(GetRGBColorXP());
	BYTE byGvalue = GetGValue(GetRGBColorXP());
	BYTE byBvalue = GetBValue(GetRGBColorXP());
//	byRvalue =byRvalue>>2;
//	byGvalue =byGvalue>>2;
//	byBvalue =byBvalue>>2;
	int iMaximo=max(byRvalue,byGvalue);
	iMaximo=max(iMaximo,byBvalue);
	iMaximo= 255-iMaximo;
	iMaximo=iMaximo-(int)(iMaximo*0.51);
	return RGB(byRvalue+iMaximo,byGvalue+iMaximo,byBvalue+iMaximo);	
d132 1
d137 1
a137 1

d139 3
a141 5
	COLORREF clr3DFace = ::GetSysColor (COLOR_3DFACE);
	return RGB (((3*GetRValue (clr3DFace)+240)/4)+1,
				((3*GetGValue (clr3DFace)+240)/4)+1,
				((3*GetBValue (clr3DFace)+240)/4)+1);

d146 10
a155 11
	BYTE byRvalue =0;
	BYTE byGvalue =0;
	BYTE byBvalue =0;
	byRvalue =byRvalue>>1;
	byGvalue =byGvalue>>1;
	byBvalue =byBvalue>>1;
	int iMaximo=max(byRvalue,byGvalue);
	iMaximo=max(iMaximo,byBvalue);
	iMaximo= 255-iMaximo;
	iMaximo=iMaximo-(int)(iMaximo*0.60);
	return RGB(byRvalue+iMaximo,byGvalue+iMaximo,byBvalue+iMaximo);	
d157 2
a158 1
}@


1.1
log
@*** empty log message ***
@
text
@d26 1
a26 1
BEGIN_MESSAGE_MAP(CTabs, CTabCtrl)
@

