head	1.11;
access;
symbols
	PublicRelease_1_2e:1.11
	Interim_Release_1-2e_RC1:1.11
	PublicRelease_1_2d:1.11
	Interim_Release_1-2d_RC1:1.11
	Interim_Release_1-2d_beta1:1.11
	PublicRelease_1_2c:1.10
	Interim_Release_1-2c_RC1:1.10
	Interim_Release_1-2c_beta1:1.10
	PublicRelease_1_2b:1.10
	Interim_Release_1-2b_RC1:1.10
	PublicRelease_1_2a:1.10
	Interim_Release_1-2a_RC1:1.10
	Interim_Release_1-2a_beta2:1.10
	Interim_Release_1-2a_beta1:1.10
	PublicRelease_1_2:1.10
	Interim_Release_1-2_RC1:1.10
	Interim_Release_1-2_beta1:1.10
	PublicRelease_1_1g:1.10
	Interim_Release_1-1g_RC3:1.10
	Interim_Release_1-1g_RC2:1.10
	Interim_Release_1-1g_RC1:1.10
	Interim_Release_1-1g_beta2:1.10
	Interim_Release_1-1g_beta1:1.10
	PublicRelease_1_1f:1.10
	Interim_Release_1-1f_RC1:1.10
	PublicRelease_1_1e:1.10
	Interim_Release_1-1e_RC2:1.10
	Interim_Release_1-1e_RC1:1.10
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.10
	Interim_Release_1-1c_beta2:1.10
	Interim_Release_1-1c_beta1:1.10
	PublicRelease_1_1b:1.10
	Interim_Release_1-1b_RC1:1.10
	PublicRelease_1_1a:1.10
	Interim_Release_1-1a_RC2:1.10
	Interim_Release_1-1a_RC1:1.10
	Interim_Release_1-1a_beta2:1.10
	Interim_Release_1-1a_beta1:1.10
	PublicRelease_1_1:1.10
	Interim_Release_1-1_beta1:1.10
	PublicRelease_1o:1.10
	Interim_Release_1o_RC1:1.10
	Interim_Release_1o_beta1:1.10
	PublicRelease_1n:1.9
	Interim_Release_1n_RC2:1.9
	Interim_Release_1n_RC1:1.9
	Interim_Release_1n_beta2:1.9
	Interim_Release_1n_beta1:1.9
	PublicRelease_1m:1.9
	Interim_Release_1m_beta1:1.9
	PublicRelease_1l:1.9
	Interim_Release_1l_RC3:1.9
	Interim_Release_1l_RC2:1.9
	Interim_Release_1l_RC1:1.9
	Interim_Release_1l_beta2:1.9
	Interim_Release_1l_beta1:1.9
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.8
	Interim_Release_1J_RC3:1.8
	Interim_Release_1j_RC3:1.8
	Interim_Release_1j_RC2:1.8
	Interim_Release_1j_RC1:1.8
	Interim_Release_1j_beta2:1.8
	Interim_Release_1j_beta1:1.8
	PublicRelease_1i:1.8
	Interim_Release_1i_RC6:1.8
	Interim_Release_1i_RC3:1.8
	Interim_Release_1i_RC2:1.8
	Interim_Release_1i_RC1:1.8
	Interim_Release_1i_beta3:1.8
	Interim_Release_1i_beta2:1.8
	Interim_Release_1i_beta1:1.8
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.8
	Interim_Release_1h_RC1:1.8
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.8
	Interim_Release_1h_beta1:1.8
	PublicRelease_1g:1.7
	Interim_Release_1g_RC6_Final:1.7
	Interim_Release_1g_RC6:1.7
	Interim_Release_1g_RC5:1.7
	Interim_Release_1g_RC4:1.7
	Interim_Release_1g_RC3:1.7
	Interim_Release_1g_beta2:1.7
	Interim_Release_1g_beta1:1.7
	Interim_Release_1f_RC4:1.7
	Interim_Release_1f_RC3:1.7
	Interim_Release_1f_RC2:1.7
	Interim_Release_1f_RC:1.7
	Interim_Release_1f_beta2:1.7
	Interim_Release_1f_beta1:1.7
	PublicRelease_1e:1.7
	Interim_Release_1e_RC2:1.7
	Interim_Release_1e_RC:1.7
	Interim_Release_1e_beta3:1.7
	Interim_Release_1e_beta2:1.7
	Interim_Release_1e_beta2_before_kuchin:1.7
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.4
	featurestest:1.4.0.2
	Interim_Release_1c_RC:1.4
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.2;
locks; strict;
comment	@ * @;


1.11
date	2007.12.11.04.29.32;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2004.09.20.07.14.55;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.13.02.47.42;	author katsyonak;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.15.10.08.17;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.20.14.35.30;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.19.07.15.46;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.04.09.41.55;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.15.20.53.48;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.15.19.41.52;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.15.12.16.44;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.15.11.34.29;	author lord_kiron;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Faster access to protected strings to speed up preferences.ini parsing on startup;
Stricter method prototype.
@
text
@#pragma once

class CCriticalSection_INL2 : public CRITICAL_SECTION
{
	DWORD m_dwSafeValue;
	static const DWORD s_dwSafeValue;
public:
	inline CCriticalSection_INL2() { InitializeCriticalSection(this); m_dwSafeValue = s_dwSafeValue; }
	inline ~CCriticalSection_INL2() { m_dwSafeValue = 0; DeleteCriticalSection(this); }
	inline void Enter() { if (m_dwSafeValue == s_dwSafeValue) EnterCriticalSection(this); }
	inline void Leave() { if (m_dwSafeValue == s_dwSafeValue) LeaveCriticalSection(this); }

	inline BOOL TryEnter(BOOL (WINAPI *pfnTryEnterCriticalSection)(CRITICAL_SECTION*))
		{ ASSERT(pfnTryEnterCriticalSection); return (m_dwSafeValue == s_dwSafeValue) && pfnTryEnterCriticalSection(this); }
};

class CRWLockLite
{
	CCriticalSection_INL2 m_csLock;
	LONG m_nReaders;
public:
	CRWLockLite() : m_nReaders(0) {}

	void ReadLock() { m_csLock.Enter(); InterlockedIncrement(&m_nReaders); m_csLock.Leave(); }
	void ReadUnlock() { InterlockedDecrement(&m_nReaders); }
	void WriteLock() { m_csLock.Enter(); while (m_nReaders) Sleep(0); }
	void WriteUnlock() { m_csLock.Leave(); }
};



enum SecuredVarErrors
{
	VariableNotInitialized,
	GetTooLongWaiting,
	PutTooLongWaiting
};


// Secured variable and array
template <class T> class CSecuredVar
{
	friend class T;
public:
	CSecuredVar()
	{
		m_bInitialized = false;
	}
	CSecuredVar(T NewVal)
	{
		Put(NewVal);
	}

	~CSecuredVar()
	{
	}

	T Get() const
	{
		#ifdef _DEBUG
		DWORD dwStart = ::GetTickCount();
		#endif // _DEBUG

//		CSingleLock AccessLock(&m_Access, TRUE);
		m_Access.ReadLock();

		if(!m_bInitialized)
			throw VariableNotInitialized;
		T TempVal = m_Val;

		#ifdef _DEBUG
		DWORD dwElapsed = ::GetTickCount() - dwStart;
		if(dwElapsed > 1000)
		{
			TRACE1("Waited %ld milliseconds to get value", dwElapsed);
			throw GetTooLongWaiting;
		}
		#endif // _DEBUG

		m_Access.ReadUnlock();

		return TempVal;
	}

	const T* Get(T* pOutVal) const
	{
		#ifdef _DEBUG
		DWORD dwStart = ::GetTickCount();
		#endif // _DEBUG

//		CSingleLock AccessLock(&m_Access, TRUE);
		m_Access.ReadLock();

		if(!m_bInitialized)
			throw VariableNotInitialized;
		*pOutVal = m_Val;

		#ifdef _DEBUG
		DWORD dwElapsed = ::GetTickCount() - dwStart;
		if(dwElapsed > 1000)
		{
			TRACE1("Waited %ld milliseconds to get value", dwElapsed);
			throw GetTooLongWaiting;
		}
		#endif // _DEBUG

		m_Access.ReadUnlock();

		return pOutVal;
	}

//	Direct value access when protection is not required (e.g. preferences loading)
	T* GetRaw()
	{
		m_bInitialized = true;	// assume it's initialized right after return
		return &m_Val;
	}

	void Put(const T &NewVal)
	{
#ifdef _DEBUG
		DWORD dwStart = ::GetTickCount();
#endif // _DEBUG

//		CSingleLock AccessLock(&m_Access, TRUE);
		m_Access.WriteLock();

		m_bInitialized = true;
		m_Val = NewVal;

#ifdef _DEBUG
		DWORD dwElapsed = ::GetTickCount() - dwStart;
		if(dwElapsed > 1000)
		{
			TRACE1("Waited %ld milliseconds to put value", dwElapsed);
			throw PutTooLongWaiting;
		}
#endif // _DEBUG

		m_Access.WriteUnlock();
	}
	void operator=(T NewVal)
	{
		Put(NewVal);
	}
	operator T() const
	{
		return Get();
	}
	T& operator=(CSecuredVar<T> &NewVal)
	{
		Put(NewVal.Get());
		return *this;
	}
	operator CSecuredVar<T>&()
	{
		return *this;
	}

private:
	T m_Val;

//	mutable CMutex	m_Access;
	mutable CRWLockLite	m_Access;
	bool	m_bInitialized;
};
@


1.10
log
@Faster processing of ini-file settings and preferences values.
@
text
@d85 1
a85 1
	T* Get(T* pOutVal) const
d112 7
@


1.9
log
@xrmb changes
@
text
@d3 2
a4 1
class CCriticalSection_INL2 : public CRITICAL_SECTION {
d17 2
a18 1
class CRWLockLite {
d85 1
a85 2

	void Put(T NewVal)
d92 27
d124 1
a124 1
		#ifdef _DEBUG
d131 1
a131 1
		#endif // _DEBUG
a159 1

@


1.8
log
@Another new sockets cumulative update
@
text
@d41 1
a41 1
	friend T;
@


1.7
log
@SecuredVars improvement
@
text
@d3 1
a3 1
class CCriticalSection_INL : public CRITICAL_SECTION {
d7 2
a8 2
	inline CCriticalSection_INL() { InitializeCriticalSection(this); m_dwSafeValue = s_dwSafeValue; }
	inline ~CCriticalSection_INL() { m_dwSafeValue = 0; DeleteCriticalSection(this); }
d17 1
a17 1
	CCriticalSection_INL m_csLock;
@


1.6
log
@Changes for debugging code
@
text
@d3 27
d62 3
a64 1
		CSingleLock AccessLock(&m_Access, TRUE);
d78 2
d90 3
a92 1
		CSingleLock AccessLock(&m_Access, TRUE);
d104 2
d128 2
a129 1
	mutable CMutex	m_Access;
@


1.5
log
@can be used for const vars now
@
text
@d5 3
a7 1
	VariableNotInitialized
d31 4
d39 10
d55 4
d62 9
@


1.4
log
@*** empty log message ***
@
text
@d27 1
a27 1
	T Get()
d47 1
a47 1
	operator T()
d64 1
a64 1
	CMutex	m_Access;
@


1.3
log
@*** empty log message ***
@
text
@d67 1
@


1.2
log
@*** empty log message ***
@
text
@d36 1
d43 1
a43 1
	T& operator=(T NewVal)
a45 1
		return *this;
d49 1
a49 1
		return (T)Get();
a54 4
	}
	operator T&()
	{
		return (T)Get();
@


1.1
log
@*** empty log message ***
@
text
@d12 1
d18 4
d49 14
a62 1
		return Get();
@

