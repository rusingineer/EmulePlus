head	1.420;
access;
symbols
	PublicRelease_1_2e:1.412
	Interim_Release_1-2e_RC1:1.409
	PublicRelease_1_2d:1.401
	Interim_Release_1-2d_RC1:1.401
	Interim_Release_1-2d_beta1:1.400
	PublicRelease_1_2c:1.394
	Interim_Release_1-2c_RC1:1.394
	Interim_Release_1-2c_beta1:1.386
	PublicRelease_1_2b:1.385
	Interim_Release_1-2b_RC1:1.384
	PublicRelease_1_2a:1.370
	Interim_Release_1-2a_RC1:1.370
	Interim_Release_1-2a_beta2:1.364
	Interim_Release_1-2a_beta1:1.357
	PublicRelease_1_2:1.345
	Interim_Release_1-2_RC1:1.345
	Interim_Release_1-2_beta1:1.345
	PublicRelease_1_1g:1.335
	Interim_Release_1-1g_RC3:1.335
	Interim_Release_1-1g_RC2:1.333
	Interim_Release_1-1g_RC1:1.333
	Interim_Release_1-1g_beta2:1.330
	Interim_Release_1-1g_beta1:1.318
	PublicRelease_1_1f:1.314
	Interim_Release_1-1f_RC1:1.314
	PublicRelease_1_1e:1.313
	Interim_Release_1-1e_RC2:1.313
	Interim_Release_1-1e_RC1:1.311
	Interim_Release_1-1e_beta1:1.308
	PublicRelease_1_1d:1.308
	Interim_Release_1-1d_RC1:1.308
	PublicRelease_1_1c:1.308
	Interim_Release_1-1c_RC1:1.308
	Interim_Release_1-1c_beta2:1.308
	Interim_Release_1-1c_beta1:1.303
	PublicRelease_1_1b:1.299
	Interim_Release_1-1b_RC1:1.299
	PublicRelease_1_1a:1.298
	Interim_Release_1-1a_RC2:1.298
	Interim_Release_1-1a_RC1:1.297
	Interim_Release_1-1a_beta2:1.296
	Interim_Release_1-1a_beta1:1.294
	PublicRelease_1_1:1.292
	Interim_Release_1-1_beta1:1.292
	PublicRelease_1o:1.292
	Interim_Release_1o_RC1:1.291
	Interim_Release_1o_beta1:1.289
	PublicRelease_1n:1.286
	Interim_Release_1n_RC2:1.285
	Interim_Release_1n_RC1:1.285
	Interim_Release_1n_beta2:1.278
	Interim_Release_1n_beta1:1.272
	PublicRelease_1m:1.267
	Interim_Release_1m_beta1:1.266
	PublicRelease_1l:1.264
	Interim_Release_1l_RC3:1.263
	Interim_Release_1l_RC2:1.262
	Interim_Release_1l_RC1:1.260
	Interim_Release_1l_beta2:1.256
	Interim_Release_1l_beta1:1.239
	PublicRelease_1k:1.229
	Interim_Release_1k_RC4:1.229
	Interim_1k_RC3:1.229
	Interim_1k_RC2:1.227
	Interim_Release_1k_RC1:1.224
	Interim_Release_1k_beta5:1.220
	Intrerim_Release_1k_beta4:1.220
	Interim_Release_1k_beta1:1.216
	PublicRelease_1j:1.194
	Interim_Release_1J_RC3:1.194
	Interim_Release_1j_RC3:1.194
	Interim_Release_1j_RC2:1.189
	Interim_Release_1j_RC1:1.188
	Interim_Release_1j_beta2:1.186
	Interim_Release_1j_beta1:1.182
	PublicRelease_1i:1.177
	Interim_Release_1i_RC6:1.176
	Interim_Release_1i_RC3:1.170
	Interim_Release_1i_RC2:1.170
	Interim_Release_1i_RC1:1.170
	Interim_Release_1i_beta3:1.169
	Interim_Release_1i_beta2:1.167
	Interim_Release_1i_beta1:1.152
	PublicRelease_1h:1.134
	Interim_Release_1h_rc2:1.134
	Interim_Release_1h_RC1:1.134
	Interim_Release_1h_beta2:1.132
	Interim_Release_1h_beta1_now:1.127
	Interim_Release_1h_beta1:1.127
	PublicRelease_1g:1.121
	Interim_Release_1g_RC6_Final:1.121
	Interim_Release_1g_RC6:1.121
	Interim_Release_1g_RC5:1.113
	Interim_Release_1g_RC4:1.111
	Interim_Release_1g_RC3:1.109
	Interim_Release_1g_beta2:1.81
	Interim_Release_1g_beta1:1.69
	Interim_Release_1f_RC4:1.66
	Interim_Release_1f_RC3:1.64
	Interim_Release_1f_RC2:1.59
	Interim_Release_1f_RC:1.59
	Interim_Release_1f_beta2:1.58
	Interim_Release_1f_beta1:1.53
	PublicRelease_1e:1.52
	Interim_Release_1e_RC2:1.52
	Interim_Release_1e_RC:1.52
	Interim_Release_1e_beta3:1.52
	Interim_Release_1e_beta2:1.52
	Interim_Release_1e_beta2_before_kuchin:1.52
	Interim_Release_1e_beta1:1.52
	PublicRelease_1c:1.44
	featurestest:1.43.0.2
	Interim_Release_1c_RC:1.43
	Interim_Release_1c_beta2:1.40
	Interim_Release_1c_beta1:1.37
	threaded_downloadqueue:1.37.0.2
	PublicRelease_1b:1.35
	Interim_Release_1b_beta2:1.35
	Interim_Release_1b_beta1:1.28
	proxydeadlake:1.27.0.2
	PublicRelease_1a:1.27
	Interim_Release_1a_beta2:1.27
	BerkeleyDb:1.25.0.2
	Interim_Release_1a_beta1:1.25
	PublicRelease_1:1.23
	goldfish:1.23
	eMulePlus_1_RC2:1.22
	eMulePlus_26b_1RC1:1.22
	PreRelease_26b_i0e:1.22
	before_26d_merge:1.18
	Interim_Release_26b_i0d:1.16
	Interim_Release_26b_i0c:1.15
	Interim_Release_26b_i0b:1.15
	Interim_Release_26b_i0a:1.15
	systraydlg:1.9.0.4
	plus26based:1.9.0.2
	Interim_Release_25b_i0b:1.9
	Proxy_Dev:1.9
	Interim_Release_25b_i0a:1.6.2.2
	proxytest:1.6.2.1.0.2
	official_sockets:1.6.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.420
date	2011.08.07.03.22.45;	author aw3;	state Exp;
branches;
next	1.419;

1.419
date	2010.05.13.04.45.56;	author aw3;	state Exp;
branches;
next	1.418;

1.418
date	2009.10.28.04.34.58;	author aw3;	state Exp;
branches;
next	1.417;

1.417
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.416;

1.416
date	2009.06.17.02.27.13;	author aw3;	state Exp;
branches;
next	1.415;

1.415
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.414;

1.414
date	2009.05.26.03.53.20;	author aw3;	state Exp;
branches;
next	1.413;

1.413
date	2009.05.19.01.26.36;	author aw3;	state Exp;
branches;
next	1.412;

1.412
date	2009.04.16.04.25.20;	author aw3;	state Exp;
branches;
next	1.411;

1.411
date	2009.04.10.03.37.49;	author aw3;	state Exp;
branches;
next	1.410;

1.410
date	2009.04.08.04.05.38;	author aw3;	state Exp;
branches;
next	1.409;

1.409
date	2009.03.21.22.47.43;	author aw3;	state Exp;
branches;
next	1.408;

1.408
date	2009.03.20.02.52.23;	author aw3;	state Exp;
branches;
next	1.407;

1.407
date	2009.02.18.00.38.24;	author aw3;	state Exp;
branches;
next	1.406;

1.406
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.405;

1.405
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.404;

1.404
date	2008.07.26.03.32.21;	author aw3;	state Exp;
branches;
next	1.403;

1.403
date	2008.07.23.04.08.23;	author aw3;	state Exp;
branches;
next	1.402;

1.402
date	2008.07.17.05.01.22;	author aw3;	state Exp;
branches;
next	1.401;

1.401
date	2008.03.24.14.09.42;	author eklmn;	state Exp;
branches;
next	1.400;

1.400
date	2008.02.10.04.59.46;	author aw3;	state Exp;
branches;
next	1.399;

1.399
date	2008.01.12.21.57.57;	author eklmn;	state Exp;
branches;
next	1.398;

1.398
date	2008.01.05.05.44.25;	author aw3;	state Exp;
branches;
next	1.397;

1.397
date	2008.01.01.21.53.26;	author eklmn;	state Exp;
branches;
next	1.396;

1.396
date	2007.12.01.23.21.57;	author aw3;	state Exp;
branches;
next	1.395;

1.395
date	2007.12.01.10.38.05;	author eklmn;	state Exp;
branches;
next	1.394;

1.394
date	2007.07.23.04.33.21;	author aw3;	state Exp;
branches;
next	1.393;

1.393
date	2007.07.07.04.07.36;	author aw3;	state Exp;
branches;
next	1.392;

1.392
date	2007.06.14.02.49.53;	author aw3;	state Exp;
branches;
next	1.391;

1.391
date	2007.06.04.01.33.22;	author aw3;	state Exp;
branches;
next	1.390;

1.390
date	2007.06.01.04.49.25;	author aw3;	state Exp;
branches;
next	1.389;

1.389
date	2007.05.28.02.07.14;	author aw3;	state Exp;
branches;
next	1.388;

1.388
date	2007.05.21.23.51.58;	author aw3;	state Exp;
branches;
next	1.387;

1.387
date	2007.03.04.22.46.02;	author kush_eplus;	state Exp;
branches;
next	1.386;

1.386
date	2007.02.26.02.20.04;	author aw3;	state Exp;
branches;
next	1.385;

1.385
date	2007.02.04.02.02.35;	author aw3;	state Exp;
branches;
next	1.384;

1.384
date	2007.01.18.06.21.22;	author eklmn;	state Exp;
branches;
next	1.383;

1.383
date	2007.01.17.19.38.45;	author eklmn;	state Exp;
branches;
next	1.382;

1.382
date	2007.01.17.07.45.24;	author aw3;	state Exp;
branches;
next	1.381;

1.381
date	2007.01.13.07.36.43;	author eklmn;	state Exp;
branches;
next	1.380;

1.380
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.379;

1.379
date	2007.01.08.06.00.32;	author aw3;	state Exp;
branches;
next	1.378;

1.378
date	2006.12.06.21.08.20;	author eklmn;	state Exp;
branches;
next	1.377;

1.377
date	2006.12.05.21.59.23;	author eklmn;	state Exp;
branches;
next	1.376;

1.376
date	2006.11.23.11.00.43;	author eklmn;	state Exp;
branches;
next	1.375;

1.375
date	2006.11.21.12.09.40;	author eklmn;	state Exp;
branches;
next	1.374;

1.374
date	2006.11.16.10.59.56;	author eklmn;	state Exp;
branches;
next	1.373;

1.373
date	2006.11.16.05.51.46;	author aw3;	state Exp;
branches;
next	1.372;

1.372
date	2006.11.10.15.03.54;	author eklmn;	state Exp;
branches;
next	1.371;

1.371
date	2006.10.25.13.25.40;	author aw3;	state Exp;
branches;
next	1.370;

1.370
date	2006.09.17.13.44.42;	author aw3;	state Exp;
branches;
next	1.369;

1.369
date	2006.09.09.01.13.04;	author aw3;	state Exp;
branches;
next	1.368;

1.368
date	2006.09.05.01.10.46;	author aw3;	state Exp;
branches;
next	1.367;

1.367
date	2006.08.07.23.51.15;	author aw3;	state Exp;
branches;
next	1.366;

1.366
date	2006.07.23.17.49.42;	author aw3;	state Exp;
branches;
next	1.365;

1.365
date	2006.07.23.00.29.15;	author aw3;	state Exp;
branches;
next	1.364;

1.364
date	2006.06.15.04.36.18;	author aw3;	state Exp;
branches;
next	1.363;

1.363
date	2006.06.05.04.38.17;	author aw3;	state Exp;
branches;
next	1.362;

1.362
date	2006.06.05.04.32.15;	author aw3;	state Exp;
branches;
next	1.361;

1.361
date	2006.05.23.04.34.53;	author aw3;	state Exp;
branches;
next	1.360;

1.360
date	2006.05.21.06.14.29;	author aw3;	state Exp;
branches;
next	1.359;

1.359
date	2006.05.13.04.42.10;	author aw3;	state Exp;
branches;
next	1.358;

1.358
date	2006.05.04.03.28.58;	author aw3;	state Exp;
branches;
next	1.357;

1.357
date	2006.05.01.01.25.46;	author aw3;	state Exp;
branches;
next	1.356;

1.356
date	2006.04.26.20.31.52;	author eklmn;	state Exp;
branches;
next	1.355;

1.355
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.354;

1.354
date	2006.04.22.15.19.36;	author eklmn;	state Exp;
branches;
next	1.353;

1.353
date	2006.04.17.00.36.05;	author aw3;	state Exp;
branches;
next	1.352;

1.352
date	2006.04.16.23.52.29;	author kush_eplus;	state Exp;
branches;
next	1.351;

1.351
date	2006.04.16.04.13.25;	author aw3;	state Exp;
branches;
next	1.350;

1.350
date	2006.04.14.21.25.16;	author eklmn;	state Exp;
branches;
next	1.349;

1.349
date	2006.04.08.07.44.07;	author eklmn;	state Exp;
branches;
next	1.348;

1.348
date	2006.03.27.03.53.27;	author aw3;	state Exp;
branches;
next	1.347;

1.347
date	2006.03.23.17.31.46;	author eklmn;	state Exp;
branches;
next	1.346;

1.346
date	2006.03.21.21.51.27;	author eklmn;	state Exp;
branches;
next	1.345;

1.345
date	2006.01.24.04.04.28;	author aw3;	state Exp;
branches;
next	1.344;

1.344
date	2006.01.19.16.50.04;	author eklmn;	state Exp;
branches;
next	1.343;

1.343
date	2006.01.15.07.19.52;	author aw3;	state Exp;
branches;
next	1.342;

1.342
date	2006.01.14.19.53.09;	author aw3;	state Exp;
branches;
next	1.341;

1.341
date	2006.01.12.17.58.09;	author eklmn;	state Exp;
branches;
next	1.340;

1.340
date	2006.01.06.20.07.15;	author kush_eplus;	state Exp;
branches;
next	1.339;

1.339
date	2006.01.05.12.08.18;	author eklmn;	state Exp;
branches;
next	1.338;

1.338
date	2005.12.24.13.04.35;	author aw3;	state Exp;
branches;
next	1.337;

1.337
date	2005.12.23.21.59.48;	author eklmn;	state Exp;
branches;
next	1.336;

1.336
date	2005.12.22.21.27.06;	author eklmn;	state Exp;
branches;
next	1.335;

1.335
date	2005.12.14.03.47.14;	author aw3;	state Exp;
branches;
next	1.334;

1.334
date	2005.12.13.20.50.29;	author eklmn;	state Exp;
branches;
next	1.333;

1.333
date	2005.11.30.03.16.36;	author aw3;	state Exp;
branches;
next	1.332;

1.332
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.331;

1.331
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.330;

1.330
date	2005.11.25.05.11.43;	author aw3;	state Exp;
branches;
next	1.329;

1.329
date	2005.11.23.04.00.31;	author aw3;	state Exp;
branches;
next	1.328;

1.328
date	2005.11.04.06.50.58;	author aw3;	state Exp;
branches;
next	1.327;

1.327
date	2005.10.29.04.54.13;	author aw3;	state Exp;
branches;
next	1.326;

1.326
date	2005.10.24.02.37.02;	author aw3;	state Exp;
branches;
next	1.325;

1.325
date	2005.10.24.00.11.49;	author aw3;	state Exp;
branches;
next	1.324;

1.324
date	2005.10.20.02.29.20;	author aw3;	state Exp;
branches;
next	1.323;

1.323
date	2005.09.30.04.43.38;	author aw3;	state Exp;
branches;
next	1.322;

1.322
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.321;

1.321
date	2005.09.09.03.58.02;	author aw3;	state Exp;
branches;
next	1.320;

1.320
date	2005.09.05.21.43.14;	author aw3;	state Exp;
branches;
next	1.319;

1.319
date	2005.08.27.15.08.17;	author aw3;	state Exp;
branches;
next	1.318;

1.318
date	2005.08.17.18.49.43;	author eklmn;	state Exp;
branches;
next	1.317;

1.317
date	2005.08.11.21.03.52;	author eklmn;	state Exp;
branches;
next	1.316;

1.316
date	2005.08.10.05.20.40;	author eklmn;	state Exp;
branches;
next	1.315;

1.315
date	2005.08.07.06.48.39;	author aw3;	state Exp;
branches;
next	1.314;

1.314
date	2005.07.23.11.04.36;	author eklmn;	state Exp;
branches;
next	1.313;

1.313
date	2005.07.02.21.27.45;	author aw3;	state Exp;
branches;
next	1.312;

1.312
date	2005.06.26.05.18.34;	author aw3;	state Exp;
branches;
next	1.311;

1.311
date	2005.06.19.04.51.11;	author aw3;	state Exp;
branches;
next	1.310;

1.310
date	2005.06.18.01.02.43;	author aw3;	state Exp;
branches;
next	1.309;

1.309
date	2005.06.07.03.35.17;	author aw3;	state Exp;
branches;
next	1.308;

1.308
date	2005.02.16.05.00.45;	author aw3;	state Exp;
branches;
next	1.307;

1.307
date	2005.02.14.22.42.17;	author aw3;	state Exp;
branches;
next	1.306;

1.306
date	2005.02.07.05.00.21;	author aw3;	state Exp;
branches;
next	1.305;

1.305
date	2005.02.04.23.46.15;	author aw3;	state Exp;
branches;
next	1.304;

1.304
date	2005.02.01.03.58.05;	author aw3;	state Exp;
branches;
next	1.303;

1.303
date	2005.01.29.03.36.02;	author aw3;	state Exp;
branches;
next	1.302;

1.302
date	2005.01.19.21.10.43;	author netwolf1;	state Exp;
branches;
next	1.301;

1.301
date	2005.01.16.00.34.58;	author netwolf1;	state Exp;
branches;
next	1.300;

1.300
date	2005.01.15.09.55.33;	author eklmn;	state Exp;
branches;
next	1.299;

1.299
date	2004.12.21.06.38.34;	author aw3;	state Exp;
branches;
next	1.298;

1.298
date	2004.12.06.03.25.35;	author aw3;	state Exp;
branches;
next	1.297;

1.297
date	2004.11.26.05.36.06;	author aw3;	state Exp;
branches;
next	1.296;

1.296
date	2004.11.19.21.00.15;	author eklmn;	state Exp;
branches;
next	1.295;

1.295
date	2004.11.08.21.07.16;	author aw3;	state Exp;
branches;
next	1.294;

1.294
date	2004.11.06.04.53.37;	author aw3;	state Exp;
branches;
next	1.293;

1.293
date	2004.10.26.01.36.35;	author aw3;	state Exp;
branches;
next	1.292;

1.292
date	2004.09.28.05.40.05;	author aw3;	state Exp;
branches;
next	1.291;

1.291
date	2004.09.27.06.39.11;	author aw3;	state Exp;
branches;
next	1.290;

1.290
date	2004.09.25.07.32.25;	author aw3;	state Exp;
branches;
next	1.289;

1.289
date	2004.09.24.03.20.36;	author aw3;	state Exp;
branches;
next	1.288;

1.288
date	2004.09.17.20.52.51;	author aw3;	state Exp;
branches;
next	1.287;

1.287
date	2004.09.16.21.49.22;	author aw3;	state Exp;
branches;
next	1.286;

1.286
date	2004.09.09.19.58.47;	author aw3;	state Exp;
branches;
next	1.285;

1.285
date	2004.08.28.05.11.15;	author aw3;	state Exp;
branches;
next	1.284;

1.284
date	2004.08.23.19.56.12;	author aw3;	state Exp;
branches;
next	1.283;

1.283
date	2004.08.23.12.45.34;	author eklmn;	state Exp;
branches;
next	1.282;

1.282
date	2004.08.17.14.06.15;	author aw3;	state Exp;
branches;
next	1.281;

1.281
date	2004.08.16.07.18.18;	author eklmn;	state Exp;
branches;
next	1.280;

1.280
date	2004.08.12.21.54.07;	author eklmn;	state Exp;
branches;
next	1.279;

1.279
date	2004.08.12.04.55.00;	author aw3;	state Exp;
branches;
next	1.278;

1.278
date	2004.08.06.17.00.45;	author eklmn;	state Exp;
branches;
next	1.277;

1.277
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.276;

1.276
date	2004.08.03.23.57.53;	author aw3;	state Exp;
branches;
next	1.275;

1.275
date	2004.08.02.18.15.21;	author syrus77;	state Exp;
branches;
next	1.274;

1.274
date	2004.07.24.06.57.38;	author aw3;	state Exp;
branches;
next	1.273;

1.273
date	2004.07.23.17.40.35;	author dongato;	state Exp;
branches;
next	1.272;

1.272
date	2004.07.19.20.40.05;	author eklmn;	state Exp;
branches;
next	1.271;

1.271
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.270;

1.270
date	2004.07.13.03.57.41;	author aw3;	state Exp;
branches;
next	1.269;

1.269
date	2004.07.12.14.10.41;	author katsyonak;	state Exp;
branches;
next	1.268;

1.268
date	2004.06.30.13.38.24;	author dongato;	state Exp;
branches;
next	1.267;

1.267
date	2004.06.25.17.35.15;	author syrus77;	state Exp;
branches;
next	1.266;

1.266
date	2004.06.19.00.08.13;	author syrus77;	state Exp;
branches;
next	1.265;

1.265
date	2004.06.17.12.43.12;	author netwolf1;	state Exp;
branches;
next	1.264;

1.264
date	2004.06.09.15.51.55;	author dongato;	state Exp;
branches;
next	1.263;

1.263
date	2004.06.07.13.48.39;	author netwolf1;	state Exp;
branches;
next	1.262;

1.262
date	2004.06.01.22.30.44;	author aw3;	state Exp;
branches;
next	1.261;

1.261
date	2004.05.31.23.22.03;	author aw3;	state Exp;
branches;
next	1.260;

1.260
date	2004.05.26.06.12.17;	author aw3;	state Exp;
branches;
next	1.259;

1.259
date	2004.05.24.19.52.35;	author dongato;	state Exp;
branches;
next	1.258;

1.258
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.257;

1.257
date	2004.05.23.21.19.43;	author dongato;	state Exp;
branches;
next	1.256;

1.256
date	2004.05.21.14.37.55;	author dongato;	state Exp;
branches;
next	1.255;

1.255
date	2004.05.21.04.37.08;	author aw3;	state Exp;
branches;
next	1.254;

1.254
date	2004.05.20.20.49.11;	author kush_eplus;	state Exp;
branches;
next	1.253;

1.253
date	2004.05.20.03.28.05;	author kush_eplus;	state Exp;
branches;
next	1.252;

1.252
date	2004.05.19.10.34.22;	author netwolf1;	state Exp;
branches;
next	1.251;

1.251
date	2004.05.18.21.07.43;	author katsyonak;	state Exp;
branches;
next	1.250;

1.250
date	2004.05.13.03.21.04;	author kush_eplus;	state Exp;
branches;
next	1.249;

1.249
date	2004.05.12.23.28.44;	author kush_eplus;	state Exp;
branches;
next	1.248;

1.248
date	2004.05.12.23.07.50;	author kush_eplus;	state Exp;
branches;
next	1.247;

1.247
date	2004.05.12.15.35.57;	author katsyonak;	state Exp;
branches;
next	1.246;

1.246
date	2004.05.11.23.27.39;	author katsyonak;	state Exp;
branches;
next	1.245;

1.245
date	2004.05.11.14.03.18;	author katsyonak;	state Exp;
branches;
next	1.244;

1.244
date	2004.05.11.01.19.15;	author katsyonak;	state Exp;
branches;
next	1.243;

1.243
date	2004.05.10.04.28.39;	author katsyonak;	state Exp;
branches;
next	1.242;

1.242
date	2004.05.10.01.25.32;	author katsyonak;	state Exp;
branches;
next	1.241;

1.241
date	2004.05.09.12.48.58;	author katsyonak;	state Exp;
branches;
next	1.240;

1.240
date	2004.05.07.05.00.30;	author aw3;	state Exp;
branches;
next	1.239;

1.239
date	2004.05.04.17.51.06;	author netwolf1;	state Exp;
branches;
next	1.238;

1.238
date	2004.05.04.11.28.00;	author netwolf1;	state Exp;
branches;
next	1.237;

1.237
date	2004.05.02.12.01.07;	author katsyonak;	state Exp;
branches;
next	1.236;

1.236
date	2004.05.01.05.31.28;	author aw3;	state Exp;
branches;
next	1.235;

1.235
date	2004.04.30.09.06.11;	author katsyonak;	state Exp;
branches;
next	1.234;

1.234
date	2004.04.28.12.36.10;	author katsyonak;	state Exp;
branches;
next	1.233;

1.233
date	2004.04.27.09.21.15;	author katsyonak;	state Exp;
branches;
next	1.232;

1.232
date	2004.04.26.14.08.33;	author katsyonak;	state Exp;
branches;
next	1.231;

1.231
date	2004.04.26.06.14.44;	author katsyonak;	state Exp;
branches;
next	1.230;

1.230
date	2004.04.23.22.13.40;	author katsyonak;	state Exp;
branches;
next	1.229;

1.229
date	2004.04.06.02.42.30;	author dongato;	state Exp;
branches;
next	1.228;

1.228
date	2004.04.05.10.29.14;	author dongato;	state Exp;
branches;
next	1.227;

1.227
date	2004.03.30.01.06.33;	author aw3;	state Exp;
branches;
next	1.226;

1.226
date	2004.03.29.17.16.53;	author eklmn;	state Exp;
branches;
next	1.225;

1.225
date	2004.03.28.14.03.31;	author eklmn;	state Exp;
branches;
next	1.224;

1.224
date	2004.03.28.12.33.48;	author eklmn;	state Exp;
branches;
next	1.223;

1.223
date	2004.03.27.17.22.13;	author eklmn;	state Exp;
branches;
next	1.222;

1.222
date	2004.03.25.20.22.12;	author aw3;	state Exp;
branches;
next	1.221;

1.221
date	2004.03.24.09.51.21;	author eklmn;	state Exp;
branches;
next	1.220;

1.220
date	2004.03.17.21.14.11;	author eklmn;	state Exp;
branches;
next	1.219;

1.219
date	2004.03.08.17.11.18;	author kush_eplus;	state Exp;
branches;
next	1.218;

1.218
date	2004.02.26.06.18.13;	author eklmn;	state Exp;
branches;
next	1.217;

1.217
date	2004.02.22.20.19.04;	author kush_eplus;	state Exp;
branches;
next	1.216;

1.216
date	2004.02.18.01.54.05;	author aw3;	state Exp;
branches;
next	1.215;

1.215
date	2004.02.17.01.58.30;	author kush_eplus;	state Exp;
branches;
next	1.214;

1.214
date	2004.02.16.23.14.00;	author aw3;	state Exp;
branches;
next	1.213;

1.213
date	2004.02.16.20.08.22;	author eklmn;	state Exp;
branches;
next	1.212;

1.212
date	2004.02.16.19.54.55;	author eklmn;	state Exp;
branches;
next	1.211;

1.211
date	2004.02.15.19.48.35;	author eklmn;	state Exp;
branches;
next	1.210;

1.210
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.209;

1.209
date	2004.02.15.10.12.15;	author eklmn;	state Exp;
branches;
next	1.208;

1.208
date	2004.02.15.03.41.59;	author kush_eplus;	state Exp;
branches;
next	1.207;

1.207
date	2004.02.13.11.36.39;	author morevit;	state Exp;
branches;
next	1.206;

1.206
date	2004.02.13.01.55.40;	author aw3;	state Exp;
branches;
next	1.205;

1.205
date	2004.02.12.18.41.17;	author syrus77;	state Exp;
branches;
next	1.204;

1.204
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.203;

1.203
date	2004.02.04.23.59.57;	author kush_eplus;	state Exp;
branches;
next	1.202;

1.202
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.201;

1.201
date	2004.02.03.01.20.30;	author double_t;	state Exp;
branches;
next	1.200;

1.200
date	2004.02.01.03.15.15;	author morevit;	state Exp;
branches;
next	1.199;

1.199
date	2004.01.31.22.02.53;	author dongato;	state Exp;
branches;
next	1.198;

1.198
date	2004.01.31.13.08.02;	author syrus77;	state Exp;
branches;
next	1.197;

1.197
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.196;

1.196
date	2004.01.30.20.33.57;	author eklmn;	state Exp;
branches;
next	1.195;

1.195
date	2004.01.28.14.38.01;	author dongato;	state Exp;
branches;
next	1.194;

1.194
date	2004.01.23.13.37.40;	author dongato;	state Exp;
branches;
next	1.193;

1.193
date	2004.01.21.13.30.47;	author dongato;	state Exp;
branches;
next	1.192;

1.192
date	2004.01.21.12.45.40;	author kuchin;	state Exp;
branches;
next	1.191;

1.191
date	2004.01.21.10.32.32;	author dongato;	state Exp;
branches;
next	1.190;

1.190
date	2004.01.16.19.46.50;	author eklmn;	state Exp;
branches;
next	1.189;

1.189
date	2004.01.11.14.59.31;	author syrus77;	state Exp;
branches;
next	1.188;

1.188
date	2004.01.10.11.37.47;	author dongato;	state Exp;
branches;
next	1.187;

1.187
date	2004.01.10.04.21.05;	author dongato;	state Exp;
branches;
next	1.186;

1.186
date	2004.01.07.15.41.49;	author dongato;	state Exp;
branches;
next	1.185;

1.185
date	2004.01.06.22.41.00;	author dongato;	state Exp;
branches;
next	1.184;

1.184
date	2004.01.04.15.13.17;	author dongato;	state Exp;
branches;
next	1.183;

1.183
date	2004.01.04.04.25.35;	author dongato;	state Exp;
branches;
next	1.182;

1.182
date	2003.12.24.01.21.13;	author katsyonak;	state Exp;
branches;
next	1.181;

1.181
date	2003.12.23.19.03.20;	author katsyonak;	state Exp;
branches;
next	1.180;

1.180
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.179;

1.179
date	2003.12.19.20.42.03;	author dongato;	state Exp;
branches;
next	1.178;

1.178
date	2003.12.19.15.57.58;	author dongato;	state Exp;
branches;
next	1.177;

1.177
date	2003.12.09.10.39.52;	author kuchin;	state Exp;
branches;
next	1.176;

1.176
date	2003.12.07.19.27.43;	author double_t;	state Exp;
branches;
next	1.175;

1.175
date	2003.12.05.16.42.10;	author eklmn;	state Exp;
branches;
next	1.174;

1.174
date	2003.12.04.06.54.23;	author eklmn;	state Exp;
branches;
next	1.173;

1.173
date	2003.11.30.11.57.03;	author katsyonak;	state Exp;
branches;
next	1.172;

1.172
date	2003.11.23.22.11.50;	author netwolf1;	state Exp;
branches;
next	1.171;

1.171
date	2003.11.21.22.37.43;	author forcha;	state Exp;
branches;
next	1.170;

1.170
date	2003.11.02.11.08.00;	author eklmn;	state Exp;
branches;
next	1.169;

1.169
date	2003.10.29.14.14.17;	author morevit;	state Exp;
branches;
next	1.168;

1.168
date	2003.10.28.21.27.53;	author morevit;	state Exp;
branches;
next	1.167;

1.167
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.166;

1.166
date	2003.10.20.13.19.57;	author morevit;	state Exp;
branches;
next	1.165;

1.165
date	2003.10.19.16.01.42;	author kuchin;	state Exp;
branches;
next	1.164;

1.164
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.163;

1.163
date	2003.10.17.10.29.05;	author morevit;	state Exp;
branches;
next	1.162;

1.162
date	2003.10.15.10.24.20;	author morevit;	state Exp;
branches;
next	1.161;

1.161
date	2003.10.15.03.51.44;	author morevit;	state Exp;
branches;
next	1.160;

1.160
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.159;

1.159
date	2003.10.13.15.00.21;	author morevit;	state Exp;
branches;
next	1.158;

1.158
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.157;

1.157
date	2003.10.08.15.39.46;	author morevit;	state Exp;
branches;
next	1.156;

1.156
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.155;

1.155
date	2003.10.08.01.53.31;	author morevit;	state Exp;
branches;
next	1.154;

1.154
date	2003.10.06.21.45.18;	author double_t;	state Exp;
branches;
next	1.153;

1.153
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.152;

1.152
date	2003.10.04.11.50.56;	author double_t;	state Exp;
branches;
next	1.151;

1.151
date	2003.10.03.19.37.29;	author double_t;	state Exp;
branches;
next	1.150;

1.150
date	2003.09.30.11.23.04;	author morevit;	state Exp;
branches;
next	1.149;

1.149
date	2003.09.29.21.12.36;	author dongato;	state Exp;
branches;
next	1.148;

1.148
date	2003.09.28.11.00.26;	author double_t;	state Exp;
branches;
next	1.147;

1.147
date	2003.09.28.08.29.05;	author double_t;	state Exp;
branches;
next	1.146;

1.146
date	2003.09.25.07.32.39;	author bavariansnail;	state Exp;
branches;
next	1.145;

1.145
date	2003.09.25.06.30.17;	author bavariansnail;	state Exp;
branches;
next	1.144;

1.144
date	2003.09.24.20.37.29;	author dongato;	state Exp;
branches;
next	1.143;

1.143
date	2003.09.23.19.01.31;	author netwolf1;	state Exp;
branches;
next	1.142;

1.142
date	2003.09.22.22.33.30;	author eklmn;	state Exp;
branches;
next	1.141;

1.141
date	2003.09.22.17.38.57;	author bavariansnail;	state Exp;
branches;
next	1.140;

1.140
date	2003.09.22.06.18.17;	author bavariansnail;	state Exp;
branches;
next	1.139;

1.139
date	2003.09.21.22.05.12;	author morevit;	state Exp;
branches;
next	1.138;

1.138
date	2003.09.21.11.39.50;	author bavariansnail;	state Exp;
branches;
next	1.137;

1.137
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.136;

1.136
date	2003.09.19.14.42.45;	author morevit;	state Exp;
branches;
next	1.135;

1.135
date	2003.09.19.00.13.36;	author morevit;	state Exp;
branches;
next	1.134;

1.134
date	2003.09.09.20.30.56;	author eklmn;	state Exp;
branches;
next	1.133;

1.133
date	2003.09.08.18.31.09;	author eklmn;	state Exp;
branches;
next	1.132;

1.132
date	2003.09.03.08.07.13;	author kuchin;	state Exp;
branches;
next	1.131;

1.131
date	2003.08.30.11.23.25;	author emoulari;	state Exp;
branches;
next	1.130;

1.130
date	2003.08.30.08.19.58;	author zegzav;	state Exp;
branches;
next	1.129;

1.129
date	2003.08.24.20.28.03;	author zegzav;	state Exp;
branches;
next	1.128;

1.128
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.127;

1.127
date	2003.08.16.17.57.38;	author eklmn;	state Exp;
branches;
next	1.126;

1.126
date	2003.08.14.00.42.28;	author emoulari;	state Exp;
branches;
next	1.125;

1.125
date	2003.08.10.16.42.02;	author kuchin;	state Exp;
branches;
next	1.124;

1.124
date	2003.08.10.14.12.51;	author zegzav;	state Exp;
branches;
next	1.123;

1.123
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.122;

1.122
date	2003.07.26.11.27.01;	author zegzav;	state Exp;
branches;
next	1.121;

1.121
date	2003.07.19.11.38.32;	author eklmn;	state Exp;
branches;
next	1.120;

1.120
date	2003.07.19.11.26.05;	author eklmn;	state Exp;
branches;
next	1.119;

1.119
date	2003.07.19.09.11.13;	author eklmn;	state Exp;
branches;
next	1.118;

1.118
date	2003.07.17.21.19.04;	author double_t;	state Exp;
branches;
next	1.117;

1.117
date	2003.07.17.16.13.28;	author eklmn;	state Exp;
branches;
next	1.116;

1.116
date	2003.07.16.22.34.42;	author syrus77;	state Exp;
branches;
next	1.115;

1.115
date	2003.07.13.17.12.18;	author dongato;	state Exp;
branches;
next	1.114;

1.114
date	2003.07.12.17.43.54;	author syrus77;	state Exp;
branches;
next	1.113;

1.113
date	2003.07.12.14.10.37;	author dongato;	state Exp;
branches;
next	1.112;

1.112
date	2003.07.12.06.16.04;	author eklmn;	state Exp;
branches;
next	1.111;

1.111
date	2003.07.08.05.08.11;	author eklmn;	state Exp;
branches;
next	1.110;

1.110
date	2003.07.03.14.17.07;	author netwolf1;	state Exp;
branches;
next	1.109;

1.109
date	2003.07.02.15.42.08;	author eklmn;	state Exp;
branches;
next	1.108;

1.108
date	2003.06.30.16.36.16;	author eklmn;	state Exp;
branches;
next	1.107;

1.107
date	2003.06.29.01.15.08;	author eklmn;	state Exp;
branches;
next	1.106;

1.106
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.105;

1.105
date	2003.06.24.15.52.09;	author netwolf1;	state Exp;
branches;
next	1.104;

1.104
date	2003.06.24.12.39.19;	author netwolf1;	state Exp;
branches;
next	1.103;

1.103
date	2003.06.22.23.21.07;	author dongato;	state Exp;
branches;
next	1.102;

1.102
date	2003.06.22.20.00.54;	author netwolf1;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.22.01.20.03;	author netwolf1;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.22.00.43.47;	author netwolf1;	state Exp;
branches;
next	1.99;

1.99
date	2003.06.22.00.35.26;	author netwolf1;	state Exp;
branches;
next	1.98;

1.98
date	2003.06.21.22.28.16;	author dongato;	state Exp;
branches;
next	1.97;

1.97
date	2003.06.21.20.20.43;	author dongato;	state Exp;
branches;
next	1.96;

1.96
date	2003.06.21.19.32.20;	author partyckip;	state Exp;
branches;
next	1.95;

1.95
date	2003.06.21.17.52.33;	author partyckip;	state Exp;
branches;
next	1.94;

1.94
date	2003.06.19.16.48.04;	author partyckip;	state Exp;
branches;
next	1.93;

1.93
date	2003.06.18.01.14.49;	author dongato;	state Exp;
branches;
next	1.92;

1.92
date	2003.06.17.02.15.18;	author dongato;	state Exp;
branches;
next	1.91;

1.91
date	2003.06.16.21.54.52;	author dongato;	state Exp;
branches;
next	1.90;

1.90
date	2003.06.16.15.37.42;	author netwolf1;	state Exp;
branches;
next	1.89;

1.89
date	2003.06.16.05.51.58;	author partyckip;	state Exp;
branches;
next	1.88;

1.88
date	2003.06.16.05.26.14;	author partyckip;	state Exp;
branches;
next	1.87;

1.87
date	2003.06.15.23.27.46;	author dongato;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.15.22.22.29;	author dongato;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.15.19.11.18;	author dongato;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.15.09.10.04;	author partyckip;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.11.18.27.05;	author eklmn;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.10.09.36.44;	author kuchin;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.09.11.57.42;	author kuchin;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.09.01.15.45;	author syrus77;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.09.00.31.11;	author syrus77;	state Exp;
branches;
next	1.78;

1.78
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.06.20.37.17;	author partyckip;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.06.19.56.45;	author partyckip;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.05.19.57.15;	author partyckip;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.05.06.05.12;	author partyckip;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.05.01.23.02;	author netwolf1;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.04.22.35.47;	author netwolf1;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.04.20.27.27;	author partyckip;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.02.22.18.48;	author partyckip;	state Exp;
branches;
next	1.69;

1.69
date	2003.05.31.08.50.54;	author partyckip;	state Exp;
branches;
next	1.68;

1.68
date	2003.05.31.06.15.55;	author partyckip;	state Exp;
branches;
next	1.67;

1.67
date	2003.05.26.17.26.33;	author partyckip;	state Exp;
branches;
next	1.66;

1.66
date	2003.05.26.12.31.00;	author emoulari;	state Exp;
branches;
next	1.65;

1.65
date	2003.05.25.01.12.05;	author syrus77;	state Exp;
branches;
next	1.64;

1.64
date	2003.05.20.20.38.09;	author netwolf1;	state Exp;
branches;
next	1.63;

1.63
date	2003.05.20.16.30.39;	author netwolf1;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.18.09.34.14;	author obaldin;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.15.19.49.48;	author partyckip;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.14.15.56.14;	author kuchin;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.12.13.22.09;	author kuchin;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.09.23.07.43;	author moosetea;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.09.11.57.05;	author kuchin;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.08.17.08.24;	author netwolf1;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.06.23.11.19;	author moosetea;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.06.15.51.44;	author partyckip;	state Exp;
branches;
next	1.53;

1.53
date	2003.04.29.15.33.49;	author partyckip;	state Exp;
branches;
next	1.52;

1.52
date	2003.04.05.10.58.51;	author dongato;	state Exp;
branches;
next	1.51;

1.51
date	2003.04.03.10.12.14;	author kuchin;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.30.00.59.09;	author moosetea;	state Exp;
branches;
next	1.49;

1.49
date	2003.03.28.22.23.21;	author moosetea;	state Exp;
branches;
next	1.48;

1.48
date	2003.03.28.10.19.07;	author dongato;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.28.07.38.41;	author partyckip;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.25.15.23.50;	author dongato;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.25.12.39.31;	author cax2;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.23.09.29.15;	author kuchin;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.22.01.13.59;	author cax2;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2003.03.21.11.17.05;	author recdvst;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.21.10.58.05;	author recdvst;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.18.20.08.35;	author obaldin;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.17.05.59.29;	author recdvst;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.16.06.09.31;	author cax2;	state Exp;
branches;
next	1.37;

1.37
date	2003.03.14.16.24.16;	author partyckip;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.14.15.27.22;	author obaldin;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.08.12.09.41;	author recdvst;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.07.12.49.37;	author kuchin;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.07.11.51.45;	author obaldin;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.06.23.41.20;	author obaldin;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.06.21.01.50;	author obaldin;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.06.17.47.36;	author obaldin;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.05.21.16.35;	author obaldin;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.03.22.09.44;	author moosetea;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.26.03.26.49;	author cax2;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.25.19.54.18;	author cax2;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.21.12.12.48;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.20.14.28.53;	author dongato;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.17.20.35.24;	author obaldin;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.17.17.43.12;	author lord_kiron;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.17.14.57.15;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.16.22.01.45;	author lord_kiron;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.14.18.25.26;	author cax2;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.12.20.18.21;	author obaldin;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.10.19.24.46;	author cax2;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.09.18.39.40;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.07.08.17.57;	author lord_kiron;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.06.22.21.22;	author lord_kiron;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.06.21.49.08;	author lord_kiron;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.06.21.13.54;	author lord_kiron;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.02.03.39.55;	author cax2;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2003.02.01.14.45.39;	author dongato;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.30.22.40.32;	author cax2;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.25.16.10.38;	author maverick65;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.01.24.22.07.44;	author maverick65;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.22.18.12.11;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.14.14.22;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.17.59.08;	author cax2;	state Exp;
branches;
next	;

1.6.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2003.01.30.22.36.55;	author cax2;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.02.02.02.36.26;	author cax2;	state Exp;
branches;
next	;

1.9.2.1
date	2003.02.05.01.58.40;	author obaldin;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2003.02.06.08.44.57;	author obaldin;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.02.06.22.57.27;	author obaldin;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.02.08.10.10.45;	author obaldin;	state Exp;
branches;
next	;

1.43.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2003.03.24.09.39.41;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.420
log
@Corrected typo.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "updownclient.h"
#include "emule.h"
#include "server.h"
#include "Friend.h"
#include "ServerList.h"
#include "UploadQueue.h"
#include "Clientlist.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "ListenSocket.h"
#include "IP2Country.h"
#include "IPFilter.h"
#include "SafeFile.h"
#include "packets.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

//	members of CUpDownClient
//	which are used by down and uploading functions

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef OLD_SOCKETS_ENABLED
CUpDownClient::CUpDownClient(CClientReqSocket *pRequestSocket) :
	m_pendingBlocksList(3), m_downloadBlocksList(3)
{
	m_pRequestSocket = pRequestSocket;
	SetDLRequiredFile(NULL);
	Init();
	m_fUserInfoWasReceived = 1;
}
#endif //OLD_SOCKETS_ENABLED
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient::CUpDownClient(uint16 uPort, uint32 dwUserID, uint32 dwSrvIP, uint16 uSrvPort, CPartFile *pReqPartFile, EnumUserIDType eIDType) :
	m_pendingBlocksList(3), m_downloadBlocksList(3)
{
#ifdef OLD_SOCKETS_ENABLED
	m_pRequestSocket = NULL;
#endif //OLD_SOCKETS_ENABLED

	Init();

	if ((eIDType == UID_ED2K) && !IsLowID(dwUserID))
		SetUserIDHybrid(fast_ntohl(dwUserID));
	else
		SetUserIDHybrid(dwUserID);
	m_uUserPort = uPort;

	if (!HasLowID())
	{
		m_dwConnectIP = fast_ntohl(m_dwUserIDHybrid);
		m_strFullUserIP.Format( _T("%u.%u.%u.%u"),
								static_cast<byte>(m_dwConnectIP),
								static_cast<byte>(m_dwConnectIP >> 8),
								static_cast<byte>(m_dwConnectIP >> 16),
								static_cast<byte>(m_dwConnectIP >> 24) );
		m_uUserCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwConnectIP);
	}
	m_dwServerIP = dwSrvIP;
	m_uServerPort = uSrvPort;
	SetDLRequiredFile(pReqPartFile);
	m_fUserInfoWasReceived = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::Init()
{
	EMULE_TRY

	m_strFullUserIP.Empty();
	m_pCredits = NULL;
	m_dwEnteredConnectedState = 0;
	m_uLastPartAsked = 0xFFFF;
	m_dwClientSumDLDataRateOverLastNMeasurements = 0;
	m_dwClientSumDLTickOverLastNMeasurements = 0;
	m_dwTransferredInLastPeriod = 0;
	m_bLimitlessDL = true;
	m_uUDPPort = 0;
	m_byteFailedCount = 0;
	m_dwBanTime = 0;
	m_dwTransferredUp = 0;
	m_dwAskedCount = 0;
	m_byteIncorrectBlockRequests = 0;
	m_dwDownAskedCount = 0;
	m_dwUpDataRate = 0;
	m_strUserName.Empty();
	m_uUserCountryIdx = NO_COUNTRY_INFO;
	m_dwUserIP = 0;
	m_dwConnectIP = 0;
	SetUserIDHybrid(0);
	m_uServerPort = 0;
	m_bIsOnLan = false;
	m_eBanState = BAN_CLIENT_NONE;
	m_iFileListRequested = m_iFileListRequestedSave = 0;
	m_dwLastUpRequest = 0;
	m_bEmuleProtocol = false;
	m_eStrCodingFormat = cfLocalCodePage;
	m_uNeededParts = 0;
	m_bCommentDirty = false;
	m_bReaskPending = false;
	m_byteNumUDPPendingReqs = 0;
	m_bUDPPending = false;
	m_byteEmuleVersion = 0;
	m_dwClientVersion = 0;
	m_strModString.Empty();
	m_strClientSoft = _T("???");
	m_uUserPort = 0;
	m_uPartCount = 0;
	m_uUpPartCount = 0;
	m_pbytePartStatuses = NULL;
	m_pbyteUpPartStatuses = NULL;
	m_uAvailUpPartCount = 0;
	m_uAvailPartCount = 0;
	ResetLastAskedTime();
	m_eDownloadState = DS_NONE;
	m_dwUploadTime = 0;
	m_dwTransferredDown = 0;
	m_dwSessionDownloadedData = 0;
	m_dwDownDataRate = 0;
	m_byteFailedFileRequestsCount = 0;
	m_eUploadState = US_NONE;
	m_dwLastBlockReceived = 0;
	m_byteDataCompVer = 0;
	m_dwPlusVers = 0;
	m_byteUDPVer = 0;
	m_byteSourceExchange1Ver = 0;
	m_byteAcceptCommentVer = 0;
	m_byteExtendedRequestsVer = 0;
	m_uRemoteQueueRank = 0;
	m_dwLastSourceRequest = 0;
	m_dwLastSourceAnswer = 0;
	m_byteCompatibleClient = 0;
	m_bIsHybrid = false;
	m_eChatState = MS_NONE;
	m_dwAwayMessageResendCount = 0;
	m_bIsML = false;
	m_pFriend = NULL;
	m_eRating = PF_RATING_NONE;
	m_strComment.Empty();
	m_dwLastGotULDataTime = 0;
	m_eClientSoft = SO_UNKNOWN;
	md4clr(m_userHash);
	m_fRequestingHashSet = 0;
	m_fNoViewSharedFiles = 0;
	m_fSupportsAskSharedDirs = 0;
	m_fNoDataForRemoteClient = 1;
	m_fAddNextConnect = 0;
	m_fSupportsLargeFiles = 0;
	m_fServerWasChanged = 0;
	m_fRxWrongFileRequest = 0;
	m_fRequestsCryptLayer = 0;
	m_fSupportsCryptLayer = 0;
	m_fRequiresCryptLayer = 0;
	m_fSentCancelTransfer = 0;
	m_fSupportsSourceEx2 = 0;
	m_fSupportsMultiPacket = 0;
	m_fSupportsExtMultiPacket = 0;
	m_fPeerCache = 0;
	m_fIdenThief = 0;

#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket != NULL)
	{
		SOCKADDR_IN	sockAddr = {0};
		int			iSockAddrLen = sizeof(sockAddr);

		m_pRequestSocket->GetPeerName(reinterpret_cast<SOCKADDR*>(&sockAddr), &iSockAddrLen);
		m_dwUserIP = sockAddr.sin_addr.s_addr;
		ipstr(&m_strFullUserIP, m_dwConnectIP = m_dwUserIP);
		m_uUserCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwConnectIP);
	}
#endif //OLD_SOCKETS_ENABLED
	m_uUpCompleteSourcesCount = 0;
	m_dwUpCompleteSourcesTime = 0;
	md4clr(m_reqFileHash);

	m_dwLastL2HACExec = 0;
	m_dwL2HACTime = 0;
	m_bL2HACEnabled = false;

	m_eSecureIdentState = IS_UNAVAILABLE;
	m_dwLastSignatureIP = 0;
	m_byteSupportSecIdent = 0;
	m_eInfoPacketsReceived = IP_NONE;

	m_byteActionsOnNameChange = 0;
	m_bHasUserNameForbiddenStrings = false;
	m_bIsMODNameChanged = false;
	m_bHasMODNameForbiddenStrings = false;
	m_bIsCommunity = false;

	m_bIsHandshakeFinished = false;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient::~CUpDownClient()
{
	EMULE_TRY

	g_App.m_pDownloadList->RemoveSource(this);
	g_App.m_pClientList->RemoveClient(this);

	if (m_pFriend != NULL)
		m_pFriend->SetLinkedClient(NULL);

#ifdef OLD_SOCKETS_ENABLED
	g_App.m_pListenSocket->DeleteSocket(m_pRequestSocket);
#endif //OLD_SOCKETS_ENABLED

	delete[] m_pbytePartStatuses;
	m_pbytePartStatuses	= NULL;
	delete[] m_pbyteUpPartStatuses;
	m_pbyteUpPartStatuses = NULL;

	ClearUploadBlockRequests();

	while (!m_requestedFilesList.IsEmpty())
		delete m_requestedFilesList.RemoveHead();

	ClearDownloadBlocksList();
	ClearPendingBlocksList();

	if (m_eRating != PF_RATING_NONE || m_strComment.GetLength() > 0)
	{
		m_eRating = PF_RATING_NONE;
		m_strComment.Empty();
		m_pReqPartFile->UpdateFileRatingCommentAvail();
	}

#ifdef OLD_SOCKETS_ENABLED
	DEBUG_ONLY (g_App.m_pListenSocket->Debug_ClientDeleted(this));
#endif //OLD_SOCKETS_ENABLED
	SetUploadFileID(NULL);

	if (m_eChatState != MS_NONE)
		g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.EndSession(this, false);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ClearHelloProperties()
{
	m_uUDPPort = 0;
	m_byteUDPVer = 0;
	m_byteDataCompVer = 0;
	m_byteEmuleVersion = 0;
	m_byteSourceExchange1Ver = 0;
	m_byteAcceptCommentVer = 0;
	m_byteExtendedRequestsVer = 0;
	m_byteCompatibleClient = 0;
	m_byteSupportSecIdent = 0;
	m_dwClientVersion = 0;
	m_fSupportsAskSharedDirs = 0;
	m_fSupportsLargeFiles = 0;
	m_fRequestsCryptLayer = 0;
	m_fSupportsCryptLayer = 0;
	m_fRequiresCryptLayer = 0;
	m_fSupportsSourceEx2 = 0;
	m_fSupportsMultiPacket = 0;
	m_fSupportsExtMultiPacket = 0;
	m_fPeerCache = 0;
	m_fIdenThief = 0;
	m_dwPlusVers = 0;
	m_dwL2HACTime = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::ProcessHelloPacket(BYTE *pbytePacket, uint32 dwSize)
{
	CSafeMemFile	packetStream(pbytePacket, dwSize);
	byte			byteHashSize;

	packetStream.Read(&byteHashSize, 1);
//	Reset all client properties; a client may not send a particular emule tag any longer
	ClearHelloProperties();
	return ProcessHelloTypePacket(packetStream);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessHelloAnswer(byte *pbytePacket, uint32 dwSize)
{
//	Ban the client if he changes a userhash and was already connected one time
	if (m_fUserInfoWasReceived != 0
		&& HasValidHash() && (md4cmp(GetUserHash(), pbytePacket) != 0))
	{
		Ban(BAN_CLIENT_HASH_STEALER);
		if (!g_App.m_pPrefs->IsCMNotLog())
		{
			AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Ban client %s (%s:%u) changed userhash from %s to %s on HelloAns"),
				GetClientNameWithSoftware(), GetFullIP(), GetUserPort(),
				HashToString(GetUserHash()), HashToString(pbytePacket));
		}
	}

	CSafeMemFile packetStream(pbytePacket, dwSize);
	ProcessHelloTypePacket(packetStream);
	SetHandshakeStatus(true);
	m_fUserInfoWasReceived = 1;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::ProcessHelloTypePacket(CSafeMemFile &packetStream)
{
	m_bIsHybrid = false;
	m_bIsML = false;
	m_fNoViewSharedFiles = 0;
	m_eStrCodingFormat = cfLocalCodePage;

	packetStream.Read(&m_userHash, 16);

	uint32	dwTagCount, dwEmuleTags = 0;

	packetStream.Read(&m_dwUserIDHybrid, 4);
	m_bIsLowID = IsLowID(m_dwUserIDHybrid);

	packetStream.Read(&m_uUserPort, 2);
	packetStream.Read(&dwTagCount, 4);

	bool	bCrashed = false, bPrTag = false;

	for (uint32 i = 0; i < dwTagCount; i++)
	{
		CTag	TempTag;

		TempTag.FillFromStream(packetStream, cfUTF8);
		switch (TempTag.GetTagID())
		{
			case CT_NAME:
				if (TempTag.IsStr())
				{
					if (!TempTag.IsStringValueEmpty())
					{
						if (!TempTag.IsStringValueEqual(m_strUserName))
						{
							TempTag.GetStringValue(&m_strUserName);
							m_byteActionsOnNameChange |= AONC_FORBIDDEN_NAME_CHECK | AONC_COMMUNITY_CHECK;
						}
						break;
					}
				}
				bCrashed = true;
				m_strUserName = _T("[Invalid user name]");
				break;

			case CT_VERSION:
				if (TempTag.IsInt())
					m_dwClientVersion = TempTag.GetIntValue();
				break;

			case CT_PORT:
				if (TempTag.IsInt())
					m_uUserPort = static_cast<uint16>(TempTag.GetIntValue());
				break;

			case CT_MOD_VERSION:
				if (TempTag.IsStr())
				{
					if (!TempTag.IsStringValueEqual(m_strModString))
					{
						TempTag.GetStringValue(&m_strModString);
						m_bIsMODNameChanged = true;
					}
				}
				else if (TempTag.IsInt())
					m_strModString.Format(_T("ModID=%u"), TempTag.GetIntValue());
				else
					m_strModString = _T("ModID=<Unknown>");
				break;

			case CT_EMULE_UDPPORTS:
				// 16 KAD Port
				// 16 UDP Port
				if (TempTag.IsInt())
				{
					m_uUDPPort = static_cast<uint16>(TempTag.GetIntValue());
					dwEmuleTags |= 1;
				}
				break;

			case CT_EMULE_MISCOPTIONS1:
				//  3 AICH Version (0 = not supported)
				//  1 Unicode
				//  4 UDP version
				//  4 Data compression version
				//  4 Secure Ident
				//  4 Source Exchange - deprecated
				//  4 Ext. Requests
				//  4 Comments
				//	1 PeerCache supported
				//	1 No 'View Shared Files' supported
				//	1 MultiPacket
				//  1 Preview
				if (TempTag.IsInt())
				{
					uint32	dwOpt = TempTag.GetIntValue();

					dwOpt >>= 1;	//skip Preview
					m_fSupportsMultiPacket = dwOpt & 0x01;
					dwOpt >>= 1;
					m_fNoViewSharedFiles = dwOpt & 0x01;
					dwOpt >>= 1;
					m_fPeerCache = dwOpt & 0x01;
					dwOpt >>= 1;
					m_byteAcceptCommentVer = static_cast<byte>(dwOpt & 0x0F);
					dwOpt >>= 4;
					m_byteExtendedRequestsVer = static_cast<byte>(dwOpt & 0x0F);
					dwOpt >>= 4;
					m_byteSourceExchange1Ver = static_cast<byte>(dwOpt & 0x0F);
					dwOpt >>= 4;
					m_byteSupportSecIdent = static_cast<byte>(dwOpt & 0x0F);
					dwOpt >>= 4;
					m_byteDataCompVer = static_cast<byte>(dwOpt & 0x0F);
					dwOpt >>= 4;
					m_byteUDPVer = static_cast<byte>(dwOpt & 0x0F);
					dwOpt >>= 4;
#ifdef _UNICODE
					m_eStrCodingFormat = (dwOpt & 0x01) ? cfUTF8 : cfLocalCodePage;
					dwOpt >>= 1;
#endif

					dwEmuleTags |= 2;
				}
				break;

			case CT_EMULE_MISCOPTIONS2:
				//  19 Reserved
				//   1 Direct UDP Callback supported and available
				//   1 Supports ChatCaptchas
				//   1 Supports SourceExachange2 Packets, ignores SX1 Packet Version
				//   1 Requires CryptLayer
				//   1 Requests CryptLayer
				//   1 Supports CryptLayer
				//   1 Reserved (ModBit)
				//   1 Ext Multipacket (Hash+Size instead of Hash)
				//   1 Large Files (includes support for 64bit tags)
				//   4 Kad Version
				if (TempTag.IsInt())
				{
					uint32	dwOpt = TempTag.GetIntValue();

					dwOpt >>= 4;	//skip Kad Version
					m_fSupportsLargeFiles = dwOpt & 0x01;
					dwOpt >>= 1;
					m_fSupportsExtMultiPacket = dwOpt & 0x01;
					dwOpt >>= 1;
					dwOpt >>= 1;	//Reserved
					SetConnectOptions(dwOpt);
					dwOpt >>= 3;
					m_fSupportsSourceEx2 = dwOpt & 0x01;
					dwOpt >>= 1;
//					dwEmuleTags |= 8;
				}
				break;

			case CT_EMULE_VERSION:
				//  8 Compatible Client ID
				//  7 Maj Version
				//  7 Min Version
				//  3 Upd Version
				//  7 Bld Version
				if (TempTag.IsInt())
				{
					m_dwClientVersion = TempTag.GetIntValue();
					m_byteCompatibleClient = static_cast<byte>(m_dwClientVersion >> 24);
					m_dwClientVersion &= 0x00FFFFFF;
					m_byteEmuleVersion = 0x99;
					m_fSupportsAskSharedDirs = 1;
					dwEmuleTags |= 4;
				}
				break;

			default:
			//	Since eDonkeyHybrid 1.3 is no longer sending the additional Int32
			//	at the end of the Hello packet, we use the "pr=1" tag to determine them
				if ((TempTag.GetTagName() != NULL) && (TempTag.GetTagName()[0] == 'p') && (TempTag.GetTagName()[1] == 'r'))
					bPrTag = true;
		}
	}

//	Check the other client's server parameters and add it to our server list
	uint32 		dwServerIP = 0;
	uint16 		uServerPort = 0;

	packetStream.Read(&dwServerIP, 4);
	packetStream.Read(&uServerPort, 2);
	m_fServerWasChanged = (m_dwServerIP != dwServerIP) || (m_uServerPort != uServerPort);
	if (m_fServerWasChanged != 0)
	{
		m_dwServerIP = dwServerIP;
		m_uServerPort = uServerPort;
	//	If the client didn't try to crash us with a blank name and the "add servers to server list on connect" preference is on...
		if (!bCrashed && g_App.m_pPrefs->GetAddServersFromClients())
		{
		//	... and server IP and port are valid (fast check) and the server isn't already in our server list
			if ((m_dwServerIP != 0) && (m_uServerPort != 0) && !g_App.m_pServerList->GetServerByIPTCP(m_dwServerIP, m_uServerPort))
			{
				CServer		*pServer = new CServer(m_uServerPort, ipstr(m_dwServerIP));

				pServer->SetListName(pServer->GetAddress());
				pServer->SetPreference(PR_LOW);	// not very reliable way to add, so make it low priority
				if (!g_App.m_pMDlg->m_wndServer.m_ctlServerList.AddServer(pServer, true))
					delete pServer;
			}
		}
	}

// Check for additional data in Hello packet to determine client's software
// - eDonkeyHybrid 0.40 - 1.2 sends an additional Int32 (since 1.3 they don't send it anymore)
// - MLdonkey sends an additional Int32
	if (packetStream.GetLength() - packetStream.GetPosition() == 4)
	{
		uint32		dwTest;

		packetStream.Read(&dwTest, 4);
		if (dwTest == 'KDLM')
		{
			m_bIsML = true;
		}
		else
			m_bIsHybrid = true;
	}

	SOCKADDR_IN	sockAddr = {0};
	int			iSockAddrLen = sizeof(sockAddr);

#ifdef OLD_SOCKETS_ENABLED
	m_pRequestSocket->GetPeerName((SOCKADDR*)&sockAddr, &iSockAddrLen);
#endif
	m_dwUserIP = sockAddr.sin_addr.s_addr;
	ipstr(&m_strFullUserIP, m_dwUserIP);
	if (m_dwConnectIP != m_dwUserIP)
	{
		m_dwConnectIP = m_dwUserIP;
		m_uUserCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwConnectIP);
	}

//	If Lancast is enabled check to see if this client is on the LAN
	m_bIsOnLan = ((g_App.m_pPrefs->GetLancastEnabled()) && ((g_App.m_pPrefs->GetLancastIP() & g_App.m_pPrefs->GetLancastSubnet()) == (m_dwUserIP & g_App.m_pPrefs->GetLancastSubnet())));

//	(a) If this is a HighID user, store the ID in the Hybrid format.
//	(b) Some older clients will not send an ID, these client are HighID users that are not connected to a server.
//	(c) The ed2k users (that are not connected to Kad) with a *.*.*.0 IPs will look like a LowID user they are actually
//		a HighID user. They can be detected easily because they will send an ID that is the same as their IP.
	if (!HasLowID() || m_dwUserIDHybrid == 0 || m_dwUserIDHybrid == m_dwUserIP || m_bIsOnLan)
		SetUserIDHybrid(fast_ntohl(m_dwUserIP));

//	Get client credits
	uchar key[16];
	md4cpy(key, m_userHash);
	m_pCredits = g_App.m_pClientCreditList->GetCredit(key);

	if ((m_pFriend = g_App.m_pFriendList->SearchFriend(key, m_dwUserIP, m_uUserPort)) != NULL)
	{
	//	Link the friend to that client
		m_pFriend->SetLinkedClient(this);

		if (m_eChatState == MS_CONNECTING)
		{
			TCITEM		tcNewItem;

			tcNewItem.mask = TCIF_TEXT;
			tcNewItem.pszText = m_strUserName.GetBuffer(256);
			g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.SetItem(g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.GetTabByClient(this), &tcNewItem);
		}
	}
//	Check if at least CT_EMULEVERSION was received, all other tags are optional
	bool bIsMule = ((dwEmuleTags & 0x04) != 0);

	if (!bIsMule && bPrTag)
		m_bIsHybrid = true;
	if (m_bIsHybrid)
		m_fSupportsAskSharedDirs = 1;

	ReGetClientSoft();

//--- detectmystolenhash ---
#ifdef OLD_SOCKETS_ENABLED
//	Check if remote client has our HASH
	if (md4cmp(m_userHash, g_App.m_pPrefs->GetUserHash()) == 0
		&& g_App.m_pPrefs->IsCounterMeasures())
	{
		Ban(BAN_CLIENT_USE_OUR_HASH);
	}
#endif //OLD_SOCKETS_ENABLED

//	Check famous stolen hashes/names
	if (HasUserNameForbiddenStrings())
		Ban(BAN_CLIENT_KWOWN_LEECHER);

	m_eInfoPacketsReceived |= IP_EDONKEYPROTPACK;
	if (bIsMule)
	{
		m_bEmuleProtocol = true;
		m_eInfoPacketsReceived |= IP_EMULEPROTPACK;
	}

	return bIsMule;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendHelloPacket()
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
//	If IP is filtered, don't greet him but disconnect...
	if (m_pRequestSocket != NULL)
	{
		CMemFile	packetStream(128);
		byte		byteHashSize = 16;

		packetStream.Write(&byteHashSize, 1);
		SendHelloTypePacket(packetStream);

		Packet		*pPacket = new Packet(&packetStream);

		pPacket->m_eOpcode = OP_HELLO;
		g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
		m_pRequestSocket->SendPacket(pPacket, true);
	}
#endif //OLD_SOCKETS_ENABLED
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendMuleInfoPacket(bool bAnswer)
{
	EMULE_TRY
#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket)
	{
		CMemFile packetStream(128);
	//	Header of the info packet
		byte uClientVersion = CURRENT_VERSION_SHORT;
		packetStream.Write(&uClientVersion, 1);
		byte uProtVersion = EMULE_PROTOCOL;
		packetStream.Write(&uProtVersion, 1);

		CWrTag	tagWr;
		uint32	dwTagCount = 10;

		packetStream.Write(&dwTagCount, 4);
	//	Body of the info packet
		tagWr.WriteToFile(ET_COMPRESSION, 1, packetStream);
		tagWr.WriteToFile(ET_UDPVER, 4, packetStream);
		tagWr.WriteToFile(ET_UDPPORT, g_App.m_pPrefs->GetUDPPort(), packetStream);
		tagWr.WriteToFile(ET_SOURCEEXCHANGE, SOURCEEXCHANGE1_VERSION, packetStream);
		tagWr.WriteToFile(ET_COMMENTS, 1, packetStream);
		tagWr.WriteToFile(ET_MOD_PLUS, CURRENT_PLUS_VERSION, packetStream);
		tagWr.WriteToFile(ET_EXTENDEDREQUEST, 2, packetStream);
		tagWr.WriteToFile(ET_MOD_VERSION, _T(PLUS_VERSION_STR), packetStream);
		tagWr.WriteToFile(ET_L2HAC, FILEREASKTIME, packetStream);
		tagWr.WriteToFile(ET_FEATURES, (uint32)(g_App.m_pClientCreditList->CryptoAvailable() ? 3 : 0), packetStream);

		Packet		*pPacket = new Packet(&packetStream, OP_EMULEPROT);
		if (!bAnswer)
			pPacket->m_eOpcode = OP_EMULEINFO;
		else
			pPacket->m_eOpcode = OP_EMULEINFOANSWER;

		if (m_pRequestSocket != NULL)
		{
			g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
			m_pRequestSocket->SendPacket(pPacket, true, true);
		}
		else
		{
			delete pPacket;
		}
	}
#endif //OLD_SOCKETS_ENABLED
	EMULE_CATCH
}

void CUpDownClient::ProcessMuleInfoPacket(BYTE* pbytePacket, uint32 dwSize)
{
	EMULE_TRY

	CSafeMemFile packetStream(pbytePacket, dwSize);
	m_byteCompatibleClient = 0;

	byte	byteEmuleVer, byteEmuleProt;

	packetStream.Read(&byteEmuleVer, 1);
	if (byteEmuleVer == 0x2B)
		byteEmuleVer = 0x22;

	packetStream.Read(&byteEmuleProt, 1);

//	Implicitly supported options by older clients
	if (byteEmuleProt != EMULE_PROTOCOL)
		return;
	if (m_byteEmuleVersion != 0x99)	//CT_EMULE_VERSION wasn't received
		m_byteEmuleVersion = byteEmuleVer;
	else
	{
	//	Make version again in the CT_EMULE_VERSION style
		m_dwClientVersion = (GET_CLIENT_MAJVER(m_dwClientVersion) << 17) |
			(GET_CLIENT_MINVER(m_dwClientVersion) << 10) | (GET_CLIENT_UDPVER(m_dwClientVersion) << 7);
	}

//	In the future do not use version to guess about new features
	if (m_byteEmuleVersion < 0x25 && m_byteEmuleVersion > 0x22)
		m_byteUDPVer = 1;

	if (m_byteEmuleVersion < 0x25 && m_byteEmuleVersion > 0x21)
		m_byteSourceExchange1Ver = 1;

	if (m_byteEmuleVersion == 0x24)
		m_byteAcceptCommentVer = 1;

//	Shared directories are requested since eMule 0.28+ because eMule 0.27 has a bug in
//	the OP_ASKSHAREDFILESDIR handler, which does not return the shared files for a directory
//	which has a trailing backslash. MLdonkey currently does not support shared directories
//	eMule+ supports shared directories since 1h (0x0108) -- eMule+ is checked later after detection
	if ((m_byteEmuleVersion >= 0x28) && !m_bIsML)
		m_fSupportsAskSharedDirs = 1;

	m_bEmuleProtocol = true;
	m_dwL2HACTime = 0;

	uint32 i, dwTagCount;
	packetStream.Read(&dwTagCount, 4);

	try
	{
		for (i = 0; i < dwTagCount; i++)
		{
			CTag	TempTag;

			TempTag.FillFromStream(packetStream, cfLocalCodePage);
			switch (TempTag.GetTagID())
			{
				case ET_COMPRESSION:
					if (TempTag.IsInt())
						m_byteDataCompVer = static_cast<byte>(TempTag.GetIntValue());
					break;

				case ET_UDPPORT:
					if (TempTag.IsInt())
						m_uUDPPort = static_cast<uint16>(TempTag.GetIntValue());
					break;

				case ET_UDPVER:
					if (TempTag.IsInt())
						m_byteUDPVer = static_cast<byte>(TempTag.GetIntValue());
					break;

				case ET_SOURCEEXCHANGE:
					if (TempTag.IsInt())
						m_byteSourceExchange1Ver = static_cast<byte>(TempTag.GetIntValue());
					break;

				case ET_COMMENTS:
					if (TempTag.IsInt())
						m_byteAcceptCommentVer = static_cast<byte>(TempTag.GetIntValue());
					break;

				case ET_EXTENDEDREQUEST:
					if (TempTag.IsInt())
						m_byteExtendedRequestsVer = static_cast<byte>(TempTag.GetIntValue());
					break;

				case ET_COMPATIBLECLIENT:
				//	Bits 31- 8: 0 - reserved
				//	Bits  7- 0: compatible client ID
					if (TempTag.IsInt())
						m_byteCompatibleClient = static_cast<byte>(TempTag.GetIntValue());
					break;

				case ET_MOD_VERSION:
					if (TempTag.IsStr())
					{
						if (!TempTag.IsStringValueEqual(m_strModString))
						{
							TempTag.GetStringValue(&m_strModString);
							m_bIsMODNameChanged = true;
						}
					}
					else if (TempTag.IsInt())
						m_strModString.Format(_T("ModID=%u"), TempTag.GetIntValue());
					else
						m_strModString = _T("ModID=<Unknwon>");
					break;

				case ET_MOD_PLUS:
					if (TempTag.IsInt())
						m_dwPlusVers = TempTag.GetIntValue();
					break;

				case ET_L2HAC:
					if (TempTag.IsInt())
						m_dwL2HACTime = TempTag.GetIntValue();
					break;

				case ET_FEATURES:
				//	Bits 31- 8: 0 - reserved
				//	Bit      7: Preview
				//	Bit   6- 0: secure identification
					if (TempTag.IsInt())
						m_byteSupportSecIdent = static_cast<byte>(TempTag.GetIntValue() & 3);
					break;
			}
		}
	}
	catch (CException *error)
	{
		error->Delete();
#ifdef _DEBUG
		AddLogLine( LOG_FL_DBG, _T("Error while processing emuletag %u/%u from client %s %s:%u"), i + 1,
						 dwTagCount, GetClientNameWithSoftware(), GetFullIP(), GetUserPort() );
#endif
	}

	if (!m_dwL2HACTime)
		m_dwL2HACTime = L2HAC_DEFAULT_EMULE;
	if (m_dwL2HACTime < L2HAC_MIN_TIME || m_dwL2HACTime > L2HAC_MAX_TIME)
		m_dwL2HACTime = 0;

	if (m_byteDataCompVer == 0)
	{
		m_byteSourceExchange1Ver = 0;
		m_byteExtendedRequestsVer = 0;
		m_byteAcceptCommentVer = 0;
		m_uUDPPort = 0;
		m_dwL2HACTime = 0;
	}

//	Validate eMule Plus version

//	Check minimal existing version and the last version sending ET_MOD_PLUS
	if ((m_dwPlusVers > 0x111) || (m_dwPlusVers < 0x100))
		m_dwPlusVers = 0;
	if (m_dwPlusVers != 0)
	{
		if ( ((m_dwPlusVers != CURRENT_PLUS_VERSION) && (m_strModString.Compare(_T(PLUS_VERSION_STR)) == 0)) ||
			((m_dwPlusVers <= 0x103) && (m_byteEmuleVersion > 0x26)) ||
			((m_dwPlusVers > 0x103) && m_strModString.IsEmpty()) ||	//several old versions didn't have ModString
			(m_strModString.GetLength() > 10) ||
			( (m_strModString.GetLength() >= 5) &&
			(memcmp(m_strModString.GetString(), _T("Plus "), sizeof(_T("Plus ")) - sizeof(TCHAR)) != 0) &&
			(memcmp(m_strModString.GetString(), _T("koizo"), sizeof(_T("koizo")) - sizeof(TCHAR)) != 0) ) )
		{
			m_dwPlusVers = 0;
		}
	}

//	eMule Plus supports shared directories since 1h (0x0108)
	if ((m_dwPlusVers != 0) && (m_dwPlusVers < 0x0108))
		m_fSupportsAskSharedDirs = 0;

	ReGetClientSoft();

//	Reset version if client type is incorrect (here SO_UNKNOWN means that handshaking hasn't finished yet)
	if ((m_dwPlusVers != 0) && (m_eClientSoft != SO_PLUS) && (m_eClientSoft != SO_UNKNOWN))
		m_dwPlusVers = 0;

	m_eInfoPacketsReceived |= IP_EMULEPROTPACK;

//	eMule Plus supports 'complete sources' since version 1f (force ET_EXTENDEDREQUEST v2 for backward compatibility)
	if ((GetPlusVersion() < 0x0108) && (GetPlusVersion() >= 0x0106) && (GetExtendedRequestsVersion() == 1))
		m_byteExtendedRequestsVer = 2;

//	Check for leeching clients
	if (HasMODNameForbiddenStrings())
		Ban(BAN_CLIENT_KWOWN_LEECHER);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendHelloAnswer()
{
	EMULE_TRY
#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket != NULL)
	{
		CMemFile packetStream(128);
		SendHelloTypePacket(packetStream);
		Packet		*pPacket = new Packet(&packetStream);
		pPacket->m_eOpcode = OP_HELLOANSWER;
		g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
		m_pRequestSocket->SendPacket(pPacket, true);
		SetHandshakeStatus(true);
	}
#endif //OLD_SOCKETS_ENABLED
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendHelloTypePacket(CMemFile &packetStream)
{
	EMULE_TRY

	packetStream.Write(g_App.m_pPrefs->GetUserHash(), 16);					// <userhash 16>

#ifdef OLD_SOCKETS_ENABLED
	uint32		dwClientID = g_App.m_pServerConnect->GetClientID();

	packetStream.Write(&dwClientID, 4);				// <ourclientid 4>
#endif //OLD_SOCKETS_ENABLED

	uint16		uPort = g_App.m_pPrefs->GetListenPort();

	packetStream.Write(&uPort, 2);					// <ourport 2>

	CWrTag		tagWr;
	uint32		dwTagCount = 6;

	packetStream.Write(&dwTagCount, 4);				// <tagcount 4>

	g_App.m_pPrefs->WritePreparedNameTag(packetStream);		// { NAME : int }
	tagWr.WriteToFile(CT_VERSION, EDONKEYVERSION, packetStream);		// { VERSION : int }
	tagWr.WriteToFile(CT_EMULE_UDPPORTS, g_App.m_pPrefs->GetUDPPort(), packetStream);

//	eMule Misc. Options #1
	const uint32	dwSupportSecIdent = (g_App.m_pClientCreditList->CryptoAvailable() ? 3 : 0);
	const uint32	dwNoViewSharedFiles = ((g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_NOONE) ? 1 : 0); // for backward compatibility this has to be a 'negative' flag
	tagWr.WriteToFile( CT_EMULE_MISCOPTIONS1,
#ifdef _AICH_READY
		(1						<< 4*7 + 1) |	//AICH Version
#endif
#ifdef _UNICODE
		(1						<< 4*7) |	//Unicode support
#endif
		(4						<< 4*6) |	//UDP version
		(1						<< 4*5) |	//Data compression version
		(dwSupportSecIdent		<< 4*4) |	//Secure Ident
		(SOURCEEXCHANGE1_VERSION << 4*3) |	//Source Exchange
		(2						<< 4*2) |	//Ext. Requests
		(1						<< 4*1) |	//Comments
		(dwNoViewSharedFiles	<< 1*2) |	//No 'View Shared Files' supported
		(1						<< 1*1), packetStream );	//MultiPacket

//	eMule Misc. Options #2
	const int	iCryptSupports = (g_App.m_pPrefs->IsClientCryptLayerSupported()) ? 1 : 0;
	const int	iCryptRequests = (g_App.m_pPrefs->IsClientCryptLayerRequested()) ? 1 : 0;
	const int	iCryptRequires = (g_App.m_pPrefs->IsClientCryptLayerRequired()) ? 1 : 0;
	tagWr.WriteToFile( CT_EMULE_MISCOPTIONS2,
		(1						<< 10) |	//Source Exchange 2
#ifdef _CRYPT_READY
		(iCryptRequires			<<  9) |
		(iCryptRequests			<<  8) |
		(iCryptSupports			<<  7) |
#endif
		(1						<<  5) |	//Ext Multipacket
		(1						<<  4), packetStream );	//Large File support

#if ((CURRENT_PLUS_VERSION & 0xF) > 7)
#error Incompatible eMule Plus version build number is used
#endif
	tagWr.WriteToFile( CT_EMULE_VERSION, (PLUS_COMPATIBLECLIENTID << 24) | ((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
		((CURRENT_PLUS_VERSION & 0xF0) << 6) | ((CURRENT_PLUS_VERSION & 0x7) << 7), packetStream );

	uint32		dwIP = 0;

	uPort = 0;
#ifdef OLD_SOCKETS_ENABLED

	if (g_App.m_pServerConnect->IsConnected())
	{
		CServer	*pCurServer = g_App.m_pServerConnect->GetCurrentServer();

		dwIP = pCurServer->GetIP();
		uPort = pCurServer->GetPort();
	}
#endif //OLD_SOCKETS_ENABLED
	packetStream.Write(&dwIP, 4);					// <serverip 4>
	packetStream.Write(&uPort, 2);					// <serverport 2>
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessMuleCommentPacket(byte *pbytePacket, uint32 dwSize)
{
	EMULE_TRY

	if ((m_pReqPartFile != NULL) && ((dwSize > (sizeof(m_eRating) + sizeof(int) - 1))))
	{
		CSafeMemFile packetStream(pbytePacket, dwSize);
		uint32	dwContainer, dwLen;
		bool	bPrevCommentEmpty = m_strComment.IsEmpty();
		EnumPartFileRating	ePrevRating = m_eRating;

		packetStream.Read(&m_eRating, sizeof(m_eRating));
		packetStream.Read(&dwLen, sizeof(dwLen));

		dwContainer = static_cast<uint32>(packetStream.GetLength() - packetStream.GetPosition());
		if (dwLen > dwContainer)
			dwLen = dwContainer;
	//	Increase the raw max. allowed file comment length because of possible UTF8 encoding
	//	which according to the standard can use up to 4 bytes to encode one character
		if (dwLen > 4 * MAXFILECOMMENTLEN)
			dwLen = 4 * MAXFILECOMMENTLEN;

		if (dwLen != 0)
		{
			ReadMB2Str(m_eStrCodingFormat, &m_strComment, packetStream, dwLen);

			if (m_strComment.GetLength() > MAXFILECOMMENTLEN) // enforce the max len on the comment
				m_strComment = m_strComment.Left(MAXFILECOMMENTLEN);

		//	Comment filter
			CString strList(g_App.m_pPrefs->GetCommentFilter().MakeLower());
			if (!strList.IsEmpty())
			{
			//	Make a copy of casesensitive comment
				CString	strResToken, lowComment(m_strComment);
				int		iCurPos = 0;

				lowComment.MakeLower();	//	Lowercase copy to search in
				for (;;)
				{
					strResToken = strList.Tokenize(_T("|"), iCurPos);
					if (strResToken.IsEmpty())
						break;
					if (lowComment.Find(strResToken) >= 0)
					{
						AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Description by client '%s' for file '%s' filtered: %s"),
										 m_strUserName, m_pReqPartFile->GetFileName(), m_strComment );
						m_strComment.Empty();
						m_eRating = PF_RATING_NONE;
					//	Clean previous rating, so spam doesn't influence overall score
					//	This is required as a user can update comment filter
						if ((ePrevRating != PF_RATING_NONE) || !bPrevCommentEmpty)
							m_pReqPartFile->UpdateFileRatingCommentAvail();
						break;
					}
				}
			}
			if (!m_strComment.IsEmpty())
			{
				m_pReqPartFile->SetHasComment(true);
				AddLogLine( LOG_FL_DBG, _T("Description by client '%s' for file '%s' received: %s"),
								 m_strUserName, m_pReqPartFile->GetFileName(), m_strComment );
			}
		}
		if (m_eRating != PF_RATING_NONE)
		{
			m_pReqPartFile->SetHasRating(true);
			AddLogLine( LOG_FL_DBG, _T("Rating by client '%s' for file '%s' received: %s"),
							 m_strUserName, m_pReqPartFile->GetFileName(), ::GetRatingString(m_eRating) );
		}
		if ((!m_strComment.IsEmpty()) || (m_eRating != PF_RATING_NONE))
			m_pReqPartFile->RemovePastComment(this, false);
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::Disconnected(bool bRetryConnection /*=true*/)
{
	bool	bDeleted = false;

	EMULE_TRY

	if (g_App.m_pClientList->IsValidClient(this))
	{
	//	If the client is uploading, remove it from the upload queue
		if (GetUploadState() == US_UPLOADING)
			g_App.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_DISCONNECT);

	//	Clear upload block lists, otherwise unrequested stuck blocks can be uploaded during next upload to the same client.
	//	That could happen when next time a remote client requests different blocks. That could be if a remote client:
	//	1) received some data from us and connection was lost.
	//	2) lost connection with us, but received these blocks from another client.
		ClearUploadBlockRequests();

	//	If the client is downloading, leave it on the queue but stop it from downloading
		if (GetDownloadState() == DS_DOWNLOADING)
			UpdateOnqueueDownloadState();
	// The remote client does not have to answer with OP_HASHSETANSWER *immediatly*
	// after we've sent OP_HASHSETREQUEST. It may occur that a (buggy) remote client
	// is sending us another OP_FILESTATUS which would let us change to DL-state DS_ONQUEUE.
		if (((GetDownloadState() == DS_REQHASHSET) || m_fRequestingHashSet) && m_pReqPartFile != NULL)
			m_pReqPartFile->m_bHashSetNeeded = true;
		ASSERT(g_App.m_pClientList->IsValidClient(this));

	//	Check if this client is needed in any way, if not delete it
		bool bDelete = true;

		switch (m_eUploadState)
		{
			case US_ONUPLOADQUEUE:
				bDelete = false;
		}
		switch (m_eDownloadState)
		{
			case DS_ONQUEUE:
			case DS_NONEEDEDPARTS:
			case DS_LOWTOLOWID:
			case DS_LOWID_ON_OTHER_SERVER:
				bDelete = false;
		}

		switch (m_eUploadState)
		{
			case US_CONNECTING:
				bDelete = true;
		}
		switch (m_eDownloadState)
		{
			case DS_CONNECTING:
				m_byteFailedCount++;
				if (bRetryConnection && m_byteFailedCount <= 2)
				{
					TryToConnect();
					return bDeleted;
				}

			case DS_WAITCALLBACK:
			case DS_ERROR:
				bDelete = true;
				g_App.m_pDownloadQueue->RemoveSource(this);
		}

		if (GetChatState() != MS_NONE)
		{
			bDelete = false;
			g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.ConnectingResult(this, false);
		}
#ifdef OLD_SOCKETS_ENABLED
		g_App.m_pListenSocket->DeleteSocket(m_pRequestSocket);
#endif //OLD_SOCKETS_ENABLED

		if (m_iFileListRequested)
		{
			AddLogLine(LOG_FL_SBAR, IDS_SHAREDFILES_FAILED, m_strUserName);
			m_iFileListRequested = m_iFileListRequestedSave = 0;
		}
		if (m_pFriend)
		{
			g_App.m_pFriendList->RefreshFriend(m_pFriend);
		}

		if (bDelete)
		{
			delete this;
			bDeleted = true;
		}
		else
		{
			m_fRequestingHashSet = 0;
			m_fSentCancelTransfer = 0;
			g_App.m_pClientList->UpdateClient(this);
		}
	}

	EMULE_CATCH

	return bDeleted;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::TryToConnect(bool bIgnoreMaxCon)
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
//	If we already have a connected request socket, we're done
//	note: we don't need to check if IP is filtered because in case of active connection it was already done
	if ((m_pRequestSocket != NULL) 
		&& (m_pRequestSocket->IsConnected() || m_pRequestSocket->IsConnecting()))
	{
		if (IsHandshakeFinished())
			ConnectionEstablished();
		return true;
	}

//	Check if it's allowed to create new socket
	if ((g_App.m_pListenSocket->TooManySockets() && !bIgnoreMaxCon))
	{
		Disconnected();
		return false;
	}
#endif //OLD_SOCKETS_ENABLED


//	Although we filter all received IPs (server sources, source exchange) and all incoming connection attempts,
//	we do have to filter outgoing connection attempts here too, because we may have updated the ip filter list
//	or client was added(removed) to(from) dynamic IP filtering list
	if ((m_dwConnectIP > 0) && g_App.m_pIPFilter->IsFiltered(m_dwConnectIP))
	{
		if (!g_App.m_pPrefs->IsCMNotLog())
		{
			AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Filtered client (don't connect): %s %hs"),
							 GetFullIP(), g_App.m_pIPFilter->GetLastHit() );
		}
	//	Disconnect and don't retry.
		Disconnected(false);
		InterlockedIncrement(&g_App.m_lOutgoingFiltered);
		InterlockedIncrement(&g_App.m_lTotalFiltered);
		return false;
	}

//	Check the cases when it's not possible to establish a connection to remote LowID client
//	1. our client hasn't connected to the server
//	2. both clients have LowIDs
//	3. the remote client is on another server
//	4. LowID client in US_CONNECTING state what according to Merkur's design should never happen
	if (HasLowID())
	{
#ifdef OLD_SOCKETS_ENABLED
		if (!g_App.m_pServerConnect->IsConnected()
			|| g_App.m_pServerConnect->IsLowID())
		{
			if (GetDownloadState() == DS_CONNECTING)
				SetDownloadState(DS_LOWTOLOWID);
			if (GetUploadState() == US_CONNECTING)
				SetUploadState(US_NONE);

			Disconnected(false);
			return false;
		}
		else if (g_App.m_pServerConnect->GetCurrentServer()->GetIP() != GetServerIP())
		{
			if (GetDownloadState() == DS_CONNECTING)
			{
			//	We come here after A4AF swap, as there's no information about
			//	remote file status, set general state
				SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
			}
			if (GetUploadState() == US_CONNECTING)
				SetUploadState(US_NONE);

			Disconnected(false);
			return false;
		}
		else
		{
		//	MOD Note: Do not change this part - Merkur
			if (GetDownloadState() == DS_CONNECTING)
				SetDownloadState(DS_WAITCALLBACK);

			if (GetUploadState() == US_CONNECTING)
			{
				SetUploadState(US_NONE);
				Disconnected(false);
				return false;
			}
		//	MOD Note - end

			Packet		*pPacket = new Packet(OP_CALLBACKREQUEST, 4);

			POKE_DWORD(pPacket->m_pcBuffer, m_dwUserIDHybrid);
			g_App.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
			g_App.m_pServerConnect->SendPacket(pPacket);

			m_bReaskPending = true;
		}
#endif //OLD_SOCKETS_ENABLED
	}
	else
	{
#ifdef OLD_SOCKETS_ENABLED
		if (m_pRequestSocket == NULL)
		{
			m_pRequestSocket = new CClientReqSocket(this);
			if (!m_pRequestSocket->Create())
			{
				m_pRequestSocket->Safe_Delete();
				return true;
			}
		}
		else if (!m_pRequestSocket->IsConnected())
		{
			m_pRequestSocket->Safe_Delete();
			m_pRequestSocket = new CClientReqSocket(this);
			if (!m_pRequestSocket->Create())
			{
				m_pRequestSocket->Safe_Delete();
				return true;
			}
		}

		SOCKADDR_IN	sockAddr = {0};

		sockAddr.sin_family = AF_INET;
		sockAddr.sin_port = fast_htons(GetUserPort());
		sockAddr.sin_addr.s_addr = m_dwConnectIP;
		m_pRequestSocket->Connect(reinterpret_cast<SOCKADDR*>(&sockAddr), sizeof(sockAddr));
#endif //OLD_SOCKETS_ENABLED

		SendHelloPacket();
	}
	return true;

	EMULE_CATCH
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ConnectionEstablished()
{
	EMULE_TRY

	m_byteFailedCount = 0;

//	Ok we have a connection, let's see if we want anything from this client.

//	If we're connecting for chat...
	if (GetChatState() == MS_CONNECTING)
	{
		g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.ConnectingResult(this, true);
	}
//	If we're connecting for download...
	switch (GetDownloadState())
	{
		case DS_CONNECTING:
		case DS_WAITCALLBACK:
			m_bReaskPending = false;
			SetDownloadState(DS_CONNECTED);
			SendFileRequest();
			break;

		case DS_ONQUEUE:
		case DS_NONEEDEDPARTS:
			if (!HasLowID())
				break;
		//	Check LowID properties of local server connection if it exists, otherwise consider 
		//	current client state as DS_LOWTOLOW
			if (g_App.m_pServerConnect->IsConnected())
			{
			//	If remote client is still on the same server then check if it's allowed to reask,
			//	otherwise remote client falls through & reasks or sets proper download state
			//	note: Don't reask faster than old client version when LowID client is on the same server
				if ((g_App.m_pServerConnect->GetCurrentServer()->GetIP() == GetServerIP())
					&& ((::GetTickCount() - m_dwLastAskedTime) < OLD_FILEREASKTIME))
				{
					break;
				}
			}
	//	If remote client has LowID & connected to another server, then send it a file request
	//	every time, when it establishes a new connection & minimal request time is gone
		case DS_LOWTOLOWID:
		case DS_LOWID_ON_OTHER_SERVER:
			if ((m_pReqPartFile != NULL) && (m_pReqPartFile->GetStatus() != PS_PAUSED)
				&& ((::GetTickCount() - m_dwLastAskedTime) > MIN_REQUESTTIME))
			{
				m_bReaskPending = false;
			//	Update the time to prevent an additional request from PartFile::Process()
				SetLastAskedTime();
				SetDownloadState(DS_CONNECTED);
				SendFileRequest();
			}
		//	Check if our client is connected to server & we can put client into proper LowID state 
			else if (g_App.m_pServerConnect->IsConnected())
			{
			//	Put client in proper state if server was changed
				if (m_fServerWasChanged == 1)
				{
					if (g_App.m_pServerConnect->IsLowID())
						SetDownloadState(DS_LOWTOLOWID);
					else if (m_uNeededParts == 0)
						SetDownloadState(DS_NONEEDEDPARTS);
					else if (g_App.m_pServerConnect->GetCurrentServer()->GetIP() != GetServerIP())
						SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
					else
						SetDownloadState(DS_ONQUEUE);
				}
			}
		//	Temporarily put the client into active state 
		//	note: the proper state will be set in CUpDownClient::TryToConnect() 
			else
			{
				if (m_uNeededParts != 0)
					SetDownloadState(DS_ONQUEUE);
				else
					SetDownloadState(DS_NONEEDEDPARTS);
			}
			break;
	}
//	If we're connecting for a "reask"...
	if (m_bReaskPending)
	{
		m_bReaskPending = false;
		if (GetDownloadState() != DS_NONE && GetDownloadState() != DS_DOWNLOADING)
		{
		//	Update the time to prevent an additional request from PartFile::Process()
			SetLastAskedTime();
			SetDownloadState(DS_CONNECTED);
			SendFileRequest();
		}
	}
//	If we're connecting for upload...
	switch (GetUploadState())
	{
		case US_CONNECTING:
		{
			if (g_App.m_pUploadQueue->IsDownloading(this))
			{
				Packet		*pPacket = new Packet(OP_ACCEPTUPLOADREQ, 0);

				g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);

#ifdef OLD_SOCKETS_ENABLED
				m_pRequestSocket->SendPacket(pPacket, true);
#endif OLD_SOCKETS_ENABLED

				SetUploadState(US_UPLOADING);
			//	Set Upload Timer
				SetLastGotULData();
			}
		}
	}
//	If we're connecting to retrieve the client's file list...
	if (m_iFileListRequested == 1)
	{
		Packet		*pPacket = new Packet((m_fSupportsAskSharedDirs != 0) ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES, 0);

		g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);

#ifdef OLD_SOCKETS_ENABLED
		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif OLD_SOCKETS_ENABLED
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CUpDownClient::GetHashType()
{
	if (m_userHash[5] == 14 && m_userHash[14] == 111)
		return SO_EMULE;
	else if (m_userHash[5] == 13 && m_userHash[14] == 110)
		return SO_OLDEMULE;
	else if (m_userHash[5] == 'M' && m_userHash[14] == 'L')
		return SO_MLDONKEY;
	else
		return SO_UNKNOWN;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ReGetClientSoft()
{
	EMULE_TRY

//	If this client hasn't been contacted, it is SO_UNKNOWN
	if (m_strUserName.IsEmpty())
	{
		m_eClientSoft = SO_UNKNOWN;
		return;
	}
//	In some cases at the time of OP_EMULEINO (which is received before OP_HELLOANSWER)
//	user hash can be zero. The processing will be done on OP_HELLOANSWER reception
	if (!HasValidHash())
		return;

	uint32	dwMajVer, dwMinVer, dwUpdVer;
	int		iHashType = GetHashType();

	switch (iHashType)
	{
	//	If a client is an old emule...
		case SO_OLDEMULE:
		{
			if ((m_byteEmuleVersion != 0x99) && (m_byteCompatibleClient == 0) && !m_bIsML)
			{
				m_eClientSoft = SO_OLDEMULE;
				m_strClientSoft.Format(_T("%s v0.%u"), GetResString(IDS_OLDEMULE), m_dwClientVersion);
				m_dwClientVersion = FORM_CLIENT_VER(0, m_dwClientVersion, 0);
				break;
			}
		}
	//	If a client is eMule compatible client...
		case SO_EMULE:
		{
			m_eClientSoft = GetClientTypeFromCompatibilityTag(m_byteCompatibleClient);
			if ((m_eClientSoft == SO_EMULE) || (m_eClientSoft == SO_UNKNOWN))
			{
				if (m_bIsML)
				{
					m_eClientSoft = SO_MLDONKEY;
					if (m_byteEmuleVersion == 0)	//neither CT_EMULE_VERSION nor OP_EMULEINFO was received
					{
						m_strClientSoft.Format(_T("MLdonkey v0.%u"), m_dwClientVersion);
						m_dwClientVersion = FORM_CLIENT_VER(0, m_dwClientVersion, 0);
						break;
					}
				}
				else if (m_bIsHybrid)
				{
					m_eClientSoft = SO_EDONKEYHYBRID;
				}
				else if (m_eClientSoft == SO_UNKNOWN)
				{
					m_eClientSoft = SO_EMULE;
					m_strModString.Format(_T("CompatID %u"), m_byteCompatibleClient);
				}
			}
			if ((m_dwPlusVers != 0) && (m_eClientSoft != SO_EMULE))
				m_dwPlusVers = 0;

			CString	strClientVer = _T(" ?");

			if (m_dwPlusVers != 0)
			{
			//	Adjust old client identification to the new style
				dwMajVer = m_dwPlusVers >> 8;
				dwMinVer = (m_dwPlusVers >> 4) & 0xF;
				dwUpdVer = m_dwPlusVers & 0xF;

				if ( !m_strModString.IsEmpty() &&
					(memcmp(m_strModString.GetString(), _T("Plus"), sizeof(_T("Plus")) - sizeof(TCHAR)) == 0) )
				{
					m_strModString.Empty();
				}
				m_eClientSoft = SO_PLUS;
				goto AdjustOldIdentification;
			}
			if (m_byteEmuleVersion == 0)
			{
				m_dwClientVersion = FORM_CLIENT_VER(0, 0, 0);
			}
			else if (m_byteEmuleVersion != 0x99)
			{
				dwMinVer = (m_byteEmuleVersion >> 4) * 10 + (m_byteEmuleVersion & 0xF);
				m_dwClientVersion = FORM_CLIENT_VER(0, dwMinVer, 0);
				strClientVer.Format(_T("0.%u"), dwMinVer);
			}
			else
			{
				dwMajVer = (m_dwClientVersion >> 17) & 0x7F;
				dwMinVer = (m_dwClientVersion >> 10) & 0x7F;
				dwUpdVer = (m_dwClientVersion >>  7) & 0x07;

				if ((m_eClientSoft == SO_LPHANT) && (static_cast<int>(--dwMajVer) < 0))
					dwMajVer++;

AdjustOldIdentification:
				m_dwClientVersion = FORM_CLIENT_VER(dwMajVer, dwMinVer, dwUpdVer);

				if (m_eClientSoft == SO_PLUS)
				{
					if (m_fPeerCache == 1)
					{
						m_fIdenThief = 1;
						m_eClientSoft = SO_EMULE;
						m_bIsCommunity = false;
						m_dwClientVersion = FORM_CLIENT_VER(43, 0, 0);	//set something reasonable
						m_strModString.Empty();
						m_strUserName.Format(_T("[IdentityThief %08X]"), this);
						m_strClientSoft.Format(_T("%s Mod v ?"), GetClientNameString(m_eClientSoft));
						break;
					}
					else
					{
						if (m_dwPlusVers == 0)
							m_dwPlusVers = (dwMajVer << 8) | ((dwMinVer & 0xF) << 4) | dwUpdVer;
						strClientVer.Format(_T("%u"), dwMajVer);
						if (dwMinVer != 0)
							strClientVer.AppendFormat(_T(".%u"), dwMinVer);
						if (dwUpdVer != 0)
							strClientVer += static_cast<TCHAR>(_T('a') + dwUpdVer - 1);
					}
				}
				else if ((m_eClientSoft == SO_EMULE) && (dwUpdVer < 26))
					strClientVer.Format(_T("%u.%u%c"), dwMajVer, dwMinVer, _T('a') + dwUpdVer);
				else if ((dwUpdVer != 0) || (m_eClientSoft == SO_AMULE))
					strClientVer.Format(_T("%u.%u.%u"), dwMajVer, dwMinVer, dwUpdVer);
				else
					strClientVer.Format(_T("%u.%u"), dwMajVer, dwMinVer);
			}
			if (m_strModString.IsEmpty())
				m_strClientSoft.Format(_T("%s v%s"), GetClientNameString(m_eClientSoft), strClientVer);
			else
				m_strClientSoft.Format(_T("%s v%s [%s]"), GetClientNameString(m_eClientSoft), strClientVer, m_strModString);
			break;
		}
		default:
		//	If a client is eDonkey-Hybrid...
			if (m_bIsHybrid)
			{
				m_eClientSoft = SO_EDONKEYHYBRID;

			//	I've never seen such idiotic version format in my life. Exampes:
			//	105321 - eDonkey 0.53.21
			//	1053   - eDonkey 0.53
			//	10502  - eDonkey 0.50.2
			//	1044   - eDonkey 0.44
			//	1432   - eDonkey 0.43.2 (first hybrid version)
			//	53248  - Overnet 0.53.24.8
			//	531    - Overnet 0.53.1
			//	53     - Overnet 0.53
			//	1000   - combined eDonkey-Overnet 1.0
			//	1001   - combined eDonkey-Overnet 1.0.1
			//	10200  - combined eDonkey-Overnet 1.2.0

			//	Convert eDonkey format into Overnet
				if (((m_dwClientVersion >= 1044) && (m_dwClientVersion < 1054)) || (m_dwClientVersion == 1432))
					m_dwClientVersion -= 1000;
				else if ((m_dwClientVersion > 10440) && (m_dwClientVersion < 10540))
					m_dwClientVersion -= 10000;
				else if ((m_dwClientVersion > 104400) && (m_dwClientVersion < 105400))
					m_dwClientVersion -= 100000;

				if (m_dwClientVersion < 1000)
				{
					dwMajVer = 0;
					if (m_dwClientVersion < 100)
					{
						dwMinVer = m_dwClientVersion;
						dwUpdVer = 0;
					}
					else
					{
						dwMinVer = m_dwClientVersion / 10;
						dwUpdVer = m_dwClientVersion - dwMinVer * 10;
					}
				}
				else if ((m_dwClientVersion > 4400) && (m_dwClientVersion < 5400))
				{
					dwMajVer = 0;
					dwMinVer = m_dwClientVersion / 100;
					dwUpdVer = m_dwClientVersion - dwMinVer * 100;
				}
				else if ((m_dwClientVersion > 44000) && (m_dwClientVersion < 54000))
				{
					dwMajVer = 0;
					dwMinVer = m_dwClientVersion / 1000;
					dwUpdVer = m_dwClientVersion / 10 - dwMinVer * 100;	//skip minor build number
				}
				else
				{
					if (m_dwClientVersion >= 10000)	// that's just an assumption
					{
						dwMajVer = m_dwClientVersion / 10000;
						m_dwClientVersion -= dwMajVer * 10000;
					}
					else
					{
						dwMajVer = m_dwClientVersion / 1000;
						m_dwClientVersion -= dwMajVer * 1000;
					}
					dwMinVer = m_dwClientVersion / 100;
					dwUpdVer = m_dwClientVersion - dwMinVer * 100;
				}
				m_dwClientVersion = FORM_CLIENT_VER(dwMajVer, dwMinVer, dwUpdVer);

				if (dwUpdVer)
					m_strClientSoft.Format(_T("Hybrid v%u.%u.%u"), dwMajVer, dwMinVer, dwUpdVer);
				else
					m_strClientSoft.Format(_T("Hybrid v%u.%u"), dwMajVer, dwMinVer);
			}
		//	If a client is MLdonkey...
			else if (m_bIsML || (iHashType == SO_MLDONKEY))
			{
				m_eClientSoft = SO_MLDONKEY;
				m_strClientSoft.Format(_T("MLdonkey v0.%u"), m_dwClientVersion);
				m_dwClientVersion = FORM_CLIENT_VER(0, m_dwClientVersion, 0);
			}
			else
			{
				m_eClientSoft = SO_EDONKEY;
				m_strClientSoft.Format(_T("eDonkey v0.%u"), m_dwClientVersion);
				m_dwClientVersion = FORM_CLIENT_VER(0, m_dwClientVersion, 0);
			}
			break;
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::RequestSharedFileList()
{
	EMULE_TRY

	if (m_iFileListRequested == 0)
	{
		AddLogLine(LOG_FL_SBAR, IDS_SHAREDFILES_REQUEST, m_strUserName);
		m_iFileListRequested = m_iFileListRequestedSave = 1;
		TryToConnect(true);
	}
	else
	{
		AddLogLine(LOG_FL_SBAR, IDS_SHAREDFILES_INPROGRESS, m_strUserName, GetUserIDHybrid());
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessSharedFileList(byte *pbytePacket, uint32 dwSize, LPCTSTR strDirectory)
{
	EMULE_TRY

	if (m_iFileListRequested > 0)
	{
		bool		bFirstDir = (m_iFileListRequested == m_iFileListRequestedSave);

		m_iFileListRequested--;
		g_App.m_pSearchList->ProcessSharedFileListAnswer(pbytePacket, dwSize, this, strDirectory, bFirstDir);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CUpDownClient::GetUploadFileInfo()
{
	if (this == NULL)
		return _T("");

	CString strInfo;
	CKnownFile *pReqFile = g_App.m_pSharedFilesList->GetFileByID(this->m_reqFileHash);

//	Build info text and display it
	strInfo.Format(GetResString(IDS_USERINFO), m_strUserName, GetUserIDHybrid());
	if (pReqFile)
	{
		strInfo.AppendFormat( GetResString(IDS_SF_REQUESTED) + _T(' ') + pReqFile->GetFileName() + _T('\n') + GetResString(IDS_FILESTATS_SESSION) + 
							  GetResString(IDS_FILESTATS_TOTAL), pReqFile->statistic.GetAccepts(), pReqFile->statistic.GetRequests(),
							  CastItoXBytes(pReqFile->statistic.GetTransferred()), pReqFile->statistic.GetAllTimeAccepts(),
							  pReqFile->statistic.GetAllTimeRequests(), CastItoXBytes(pReqFile->statistic.GetAllTimeTransferred()) );
	}
	else
		strInfo += GetResString(IDS_REQ_UNKNOWNFILE);

	return strInfo;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HICON CUpDownClient::GetClientInfo4Tooltips(CString &strInfo, bool bForUpload /*false*/)
{
	EMULE_TRY

	if (this == NULL)
		return (HICON)NULL;

	CString		strCountry, strUserName(m_strUserName);

	strUserName.Trim();
	strUserName.Replace(_T("\n"), _T("<br>"));
	strUserName.Replace(_T("<"), _T("<<"));
	if (g_App.m_pIP2Country->IsIP2Country())
		 strCountry.Format(_T(" (<b>%s</b>)"), GetCountryName());

	strInfo.Format(_T("<t=1><b>%s</b><br><t=1>%s: %u%s<br><hr=100%%><br><b>%s:<t></b>%s:%u (<b>%s</b>)"),
		strUserName, GetResString(IDS_USERID), GetUserIDHybrid(), strCountry,
		GetResString(IDS_CLIENT), GetFullIP(), GetUserPort(), m_strClientSoft);

	CServer *pServer = g_App.m_pServerList->GetServerByIPTCP(GetServerIP(), GetServerPort());

	if (pServer != NULL)
	{
		CString			strServerName = pServer->GetListName();

		strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s:%u"), GetResString(IDS_SERVER), ipstr(GetServerIP()), GetServerPort());

		strServerName.Replace(_T("<"), _T("<<"));
		strServerName.Replace(_T("\n"), _T("<br>"));
		if (!strServerName.IsEmpty())
		{
			strInfo += _T(" (<b>");
			strInfo += strServerName;
			strInfo += _T("</b>)");
		}
	}

	if (IsBanned())
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_BANNED), GetBanString());

	if (Credits() != NULL && Credits()->GetUploadedTotal() != GetTransferredUp())
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_DDATA), CastItoXBytes(GetTransferredUp()), CastItoXBytes(Credits()->GetUploadedTotal()));
	else if (GetTransferredUp() > 0)
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_DDATA), CastItoXBytes(GetTransferredUp()));

	if (Credits() != NULL && Credits()->GetDownloadedTotal() != GetTransferredDown())
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_UDATA), CastItoXBytes(GetTransferredDown()), CastItoXBytes(Credits()->GetDownloadedTotal()));
	else if (GetTransferredDown() > 0)
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_UDATA), CastItoXBytes(GetTransferredDown()));

	if (bForUpload)
	{
		CKnownFile *m_pReqSharedFile = g_App.m_pSharedFilesList->GetFileByID(this->m_reqFileHash);

		if (m_pReqSharedFile)
		{
			strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s<br><b>%s:</b><t>"), GetResString(IDS_TT_REQUESTED), m_pReqSharedFile->GetFileName(), GetResString(IDS_TT_FILESTATS_SESSION));
			strInfo.AppendFormat(GetResString(IDS_TT_FILESTATS), m_pReqSharedFile->statistic.GetAccepts(), m_pReqSharedFile->statistic.GetRequests(), CastItoXBytes(m_pReqSharedFile->statistic.GetTransferred()));
			strInfo.AppendFormat(_T("<br><b>%s:</b><t>"), GetResString(IDS_TT_FILESTATS_TOTAL));
			strInfo.AppendFormat(GetResString(IDS_TT_FILESTATS), m_pReqSharedFile->statistic.GetAllTimeAccepts(), m_pReqSharedFile->statistic.GetAllTimeRequests(), CastItoXBytes(m_pReqSharedFile->statistic.GetAllTimeTransferred()));
		}
		else
			strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_TT_REQUESTED), GetResString(IDS_REQ_UNKNOWNFILE));
	}

	return g_App.m_pMDlg->m_clientImgLists[CLIENT_IMGLST_PLAIN].ExtractIcon(GetClientIconIndex());

	EMULE_CATCH

	return (HICON)NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SendPublicKeyPacket() sends our public key to the client that requested it.
void CUpDownClient::SendPublicKeyPacket()
{
#ifdef DEBUG_SHOW_SECUREID
	DEBUG_ONLY(AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Sending public key to '%s'"), m_strUserName));
#endif

#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket == NULL || m_pCredits == NULL || m_eSecureIdentState != IS_KEYANDSIGNEEDED)
	{
		ASSERT (false);
		return;
	}
#endif //OLD_SOCKETS_ENABLED
	if (!g_App.m_pClientCreditList->CryptoAvailable())
		return;

	Packet		*pPacket = new Packet(OP_PUBLICKEY, g_App.m_pClientCreditList->GetPubKeyLen() + 1, OP_EMULEPROT);

	g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
	memcpy2(pPacket->m_pcBuffer + 1, g_App.m_pClientCreditList->GetPublicKey(), g_App.m_pClientCreditList->GetPubKeyLen());
	pPacket->m_pcBuffer[0] = g_App.m_pClientCreditList->GetPubKeyLen();
#ifdef OLD_SOCKETS_ENABLED

	m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

	m_eSecureIdentState = IS_SIGNATURENEEDED;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendSignaturePacket()
{
//	Sign the public key of this client and send it
#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket == NULL || m_pCredits == NULL || m_eSecureIdentState == 0)
	{
		ASSERT (false);
		return;
	}
#endif //OLD_SOCKETS_ENABLED

	if (!g_App.m_pClientCreditList->CryptoAvailable())
		return;

//	We don't have his public key yet, will be back here later
	if (m_pCredits->GetSecIDKeyLen() == 0)
		return;
#ifdef DEBUG_SHOW_SECUREID
	DEBUG_ONLY(AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Sending signature key to '%s'"), m_strUserName));
#endif
//	Do we have a challenge value received (actually we should if we are in this function)
	if (m_pCredits->m_dwCryptRndChallengeFrom == 0)
	{
		AddLogLine(LOG_FL_DBG, _T("Client '%s' want to send signature but challenge value is invalid"), m_strUserName);
		return;
	}
//	v2, we will use v1 as default, except if only v2 is supported
	bool		bUseV2;

	if ((m_byteSupportSecIdent & 1) == 1)
		bUseV2 = false;
	else
		bUseV2 = true;

	byte		byteChallengeIPKind = 0;
	uint32		ChallengeIP = 0;
#ifdef OLD_SOCKETS_ENABLED

	if (bUseV2)
	{
		if (g_App.m_pServerConnect->GetClientID() == 0 || g_App.m_pServerConnect->IsLowID())
		{
		//	We cannot know for sure our public ip, so use the remote clients one
			ChallengeIP = GetIP();
			byteChallengeIPKind = CRYPT_CIP_REMOTECLIENT;
		}
		else
		{
			ChallengeIP = g_App.m_pServerConnect->GetClientID();
			byteChallengeIPKind = CRYPT_CIP_LOCALCLIENT;
		}
	}
#endif //OLD_SOCKETS_ENABLED
	uchar		achBuffer[250];
	byte		siglen = g_App.m_pClientCreditList->CreateSignature(m_pCredits, achBuffer, 250, ChallengeIP, byteChallengeIPKind);

	if (siglen == 0)
	{
		ASSERT (false);
		return;
	}
	Packet		*pPacket = new Packet(OP_SIGNATURE, siglen + 1 + ((bUseV2) ? 1 : 0), OP_EMULEPROT);

	g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
	memcpy2(pPacket->m_pcBuffer + 1, achBuffer, siglen);
	pPacket->m_pcBuffer[0] = siglen;
	if (bUseV2)
		pPacket->m_pcBuffer[1 + siglen] = byteChallengeIPKind;
#ifdef OLD_SOCKETS_ENABLED

	m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

	m_eSecureIdentState = IS_ALLREQUESTSSEND;
}

void CUpDownClient::ProcessPublicKeyPacket(uchar* pbytePacket, uint32 dwSize)
{
#ifdef DEBUG_SHOW_SECUREID
	DEBUG_ONLY(g_App.m_pMDlg->AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Receiving public key from '%s'"), m_strUserName));
#endif

#ifdef OLD_SOCKETS_ENABLED
	if ( m_pRequestSocket == NULL || m_pCredits == NULL || pbytePacket[0] != dwSize - 1
	     || dwSize == 0 || dwSize > 250 )
	{
		ASSERT (false);
		return;
	}
#endif //OLD_SOCKETS_ENABLED
	if (!g_App.m_pClientCreditList->CryptoAvailable())
		return;
//	the function will handle everything (mulitple key etc)
	if (m_pCredits->SetSecureIdent(pbytePacket + 1, pbytePacket[0]))
	{
	//	if this client wants a signature, now we can send him one
		if (m_eSecureIdentState == IS_SIGNATURENEEDED)
		{
			SendSignaturePacket();
		}
		else if (m_eSecureIdentState == IS_KEYANDSIGNEEDED)
		{
		//	Something is wrong
			AddLogLine( LOG_FL_DBG, _T("Client '%s': Invalid State error, IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket"),
							 m_strUserName );
		}
	}
	else
	{
		AddLogLine(LOG_FL_DBG, _T("Client '%s' failed to use new received public key"), m_strUserName);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessSignaturePacket(uchar *pbytePacket, uint32 dwSize)
{
#ifdef DEBUG_SHOW_SECUREID
	DEBUG_ONLY(AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Receiving signature from '%s'"), m_strUserName));
#endif

//	Here we separate the good guys from the bad ones ;)

#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket == NULL || m_pCredits == NULL || dwSize == 0 || dwSize > 250)
	{
		ASSERT (false);
		return;
	}
#endif //OLD_SOCKETS_ENABLED

	byte	byteChallengeIPKind, byteSigLen = pbytePacket[0];

//	If the packet consists only of the signature length and signature (SecureIdent V1)...
	if (dwSize == sizeof(byteSigLen) + byteSigLen)
	{
		byteChallengeIPKind = 0;
	}
//	If the packet is long enough to contain the challenge IP kind (SecureIdent V2) and the client supports V2...
	else if ( (dwSize == byteSigLen + sizeof(byteSigLen) + sizeof(byteChallengeIPKind)) &&
		((m_byteSupportSecIdent & 2) > 0))
	{
		byteChallengeIPKind = pbytePacket[dwSize - 1];
	}
	else
	{
		ASSERT (false);
		return;
	}

	if (!g_App.m_pClientCreditList->CryptoAvailable())
		return;

//	If we already have a signature from this client IP...
	if (m_dwLastSignatureIP == GetIP())
	{
	//	We accept only one signature per IP, to avoid floods which need a lot cpu time for crypt functions
		AddLogLine(LOG_FL_DBG, _T("Received multiple signatures from client %s"), GetClientNameWithSoftware());
		return;
	}
//	If we don't have a public key for this client...
	if (m_pCredits->GetSecIDKeyLen() == 0)
	{
		AddLogLine(LOG_FL_DBG, _T("Received signature for client %s without public key"), GetClientNameWithSoftware());
		return;
	}
//	If we haven't generated a challenge value for this client yet...
	if (m_pCredits->m_dwCryptRndChallengeFor == 0)
	{
		AddLogLine(LOG_FL_DBG, _T("Received signature for client %s with invalid challenge value"), GetClientNameWithSoftware());
		return;
	}

	if (g_App.m_pClientCreditList->VerifyIdent(m_pCredits, pbytePacket + 1, byteSigLen, GetIP(), byteChallengeIPKind))
	{
	//	result is saved in function above
	}
#ifdef DEBUG_SHOW_SECUREID
	else
	{
		AddLogLine(LOG_FL_DBG, _T("Client %s has failed the secure identification, V2 State: %i"), GetClientNameWithSoftware(), byteChallengeIPKind);
	}
#endif

	m_dwLastSignatureIP = GetIP();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendSecIdentStatePacket()
{
//	Check if we need public key and signature
	BYTE		byteValue = 0;

	if (m_pCredits != NULL)
	{
		if (g_App.m_pClientCreditList->CryptoAvailable())
		{
			if (m_pCredits->GetSecIDKeyLen() == 0)
			{
				byteValue = IS_KEYANDSIGNEEDED;
			}
			else if (m_dwLastSignatureIP != GetIP())
			{
				byteValue = IS_SIGNATURENEEDED;
			}
		}
	//	If we already have the key and signature, we're done.
		if (byteValue == 0)
		{
#ifdef DEBUG_SHOW_SECUREID
			DEBUG_ONLY(AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Not sending SecIdentState Packet, because State is Zero")));
#endif
			return;
		}
	//	Crypt: send random data to sign
		uint32		dwRandom = rand() + 1;

		m_pCredits->m_dwCryptRndChallengeFor = dwRandom;

#ifdef DEBUG_SHOW_SECUREID
		DEBUG_ONLY(AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Sending SecIdentState packet, state: %u (to '%s')"), byteValue, m_strUserName));
#endif

		Packet		*pPacket = new Packet(OP_SECIDENTSTATE, 5, OP_EMULEPROT);

		g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
		pPacket->m_pcBuffer[0] = byteValue;
		memcpy(pPacket->m_pcBuffer + 1, &dwRandom, sizeof(dwRandom));

#ifdef OLD_SOCKETS_ENABLED
		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessSecIdentStatePacket(uchar *pbytePacket, uint32 dwSize)
{
	if (dwSize != 5)
		return;
	if (m_pCredits == NULL)
		return;

	switch (pbytePacket[0])
	{
		case 0:
			m_eSecureIdentState = IS_UNAVAILABLE;
			break;
		case 1:
			m_eSecureIdentState = IS_SIGNATURENEEDED;
			break;
		case 2:
			m_eSecureIdentState = IS_KEYANDSIGNEEDED;
			break;
	}
	uint32		dwRandom;

	memcpy2(&dwRandom, pbytePacket + 1, 4);
	m_pCredits->m_dwCryptRndChallengeFrom = dwRandom;

#ifdef DEBUG_SHOW_SECUREID
	DEBUG_ONLY(AddLogLine(LOG_FL_DBG, _T(__FUNCTION__) _T(": Received SecIdentState Packet, state: %u"), pbytePacket[0]));
#endif
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	InfoPacketsReceived() is called once the HELLO/HELLOANSWER and EMULEINFO/EMULEINFOANSWER information has
//	been received.
void CUpDownClient::InfoPacketsReceived()
{
	ASSERT (m_eInfoPacketsReceived == IP_BOTH);

	m_eInfoPacketsReceived = IP_NONE;

//	If this client supports secure credits...
	if (m_byteSupportSecIdent)
	{
		SendSecIdentStatePacket();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CUpDownClient::GetCountryName() const
{
	return g_App.m_pIP2Country->GetCountryNameByIndex(m_uUserCountryIdx);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ResetIP2Country()
{
	m_uUserCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::HasUserNameForbiddenStrings()
{
	if (m_byteActionsOnNameChange & AONC_FORBIDDEN_NAME_CHECK)
	{
		m_bHasUserNameForbiddenStrings = IsStolenName(m_strUserName);

		m_byteActionsOnNameChange &= ~AONC_FORBIDDEN_NAME_CHECK;
	}

	return m_bHasUserNameForbiddenStrings;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::HasMODNameForbiddenStrings()
{
	if (m_bIsMODNameChanged)
	{
		m_bHasMODNameForbiddenStrings = IsLeecherType(m_strModString);

	//	Check if a client isn't eMulePlus, but uses our MOD string
		if (!m_bHasMODNameForbiddenStrings && (m_dwPlusVers == 0))
		{
			m_bHasMODNameForbiddenStrings = (m_strModString == _T(PLUS_VERSION_STR));
		}

		m_bIsMODNameChanged = false;
	}

	return m_bHasMODNameForbiddenStrings;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CUpDownClient::GetClientIconIndex() const
{
	uint32	dwImgIdx = GetClientSoft();

	if ((dwImgIdx == SO_EMULE) || (dwImgIdx == SO_PLUS))
	{
		if (m_pCredits->GetCurrentIdentState(GetIP()) != IS_IDENTIFIED)
			dwImgIdx = SO_OLDEMULE;
	}
	else if (dwImgIdx > SO_UNKNOWN)
		dwImgIdx = SO_UNKNOWN;

	return static_cast<int>(dwImgIdx);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CString& CUpDownClient::GetFullSoftVersionString() const
{
	return m_strClientSoft;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CUpDownClient::GetClientNameWithSoftware() const
{
	CString strBuf;

	strBuf.Format(_T("'%s' (%s)"), m_strUserName, m_strClientSoft);
	return strBuf;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::IsObfuscatedConnectionEstablished() const
{
	if ((m_pRequestSocket != NULL) && m_pRequestSocket->IsConnected())
		return m_pRequestSocket->IsObfusicating();
	else
		return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::ShouldReceiveCryptUDPPackets() const
{
#ifdef _CRYPT_READY
#else
	return false;
#endif
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetConnectOptions(int iCryptOpt)
{
	int	iTmp = iCryptOpt & 1;

	m_fSupportsCryptLayer = iTmp;
	iTmp &= (iCryptOpt >> 1);
	m_fRequestsCryptLayer = iTmp;
	iTmp &= (iCryptOpt >> 2);
	m_fRequiresCryptLayer = iTmp;
}
@


1.419
log
@Don't set proper handshaking status on bad HelloAnswer packet; Encryption preparations.
@
text
@d388 1
a388 1
					m_strModString = _T("ModID=<Unknwon>");
@


1.418
log
@Reduced H-file dependency.
@
text
@a303 2
	EMULE_TRY

a320 1
	EMULE_CATCH
a2180 1
#ifdef _CRYPT_READY
a2181 3
#else
		return false;
#endif
@


1.417
log
@Reduced H-file dependency.
@
text
@d33 3
@


1.416
log
@Updated server list search API for encryption implementation.
@
text
@d28 1
d32 1
@


1.415
log
@Fast byte swap for ntohl and ntohs.
@
text
@d514 1
a514 1
			if ((m_dwServerIP != 0) && (m_uServerPort != 0) && !g_App.m_pServerList->GetServerByIP(m_dwServerIP, m_uServerPort))
d1749 1
a1749 1
	CServer *pServer = g_App.m_pServerList->GetServerByIP(GetServerIP(), GetServerPort());
@


1.414
log
@Encryption preparations.
@
text
@d63 1
a63 1
		SetUserIDHybrid(ntohl(dwUserID));
d70 1
a70 1
		m_dwConnectIP = ntohl(m_dwUserIDHybrid);
d564 1
a564 1
		SetUserIDHybrid(ntohl(m_dwUserIP));
@


1.413
log
@Added full multipacket support.
@
text
@d466 1
a466 1
					SetCryptLayer(dwOpt);
d2195 11
@


1.412
log
@Identity thief countermeasures {Fuxie - DK/muleteer/Bro-DK}.
@
text
@d445 3
a447 1
				//  21 Reserved
d935 3
d947 2
a948 1
		(dwNoViewSharedFiles	<< 1*2), packetStream );	//No 'View Shared Files' supported
d961 1
@


1.411
log
@Reduced H-file dependency.
@
text
@d176 2
d280 2
d421 2
a422 1
					dwOpt >>= 1;	//skip PeerCache
d1538 12
@


1.410
log
@Reduced H-file dependency.
@
text
@d30 1
@


1.409
log
@Reduced #include dependency.
@
text
@d23 1
@


1.408
log
@Keep IP-filter description strings in ASCII to reduce memory usage.
@
text
@d28 1
@


1.407
log
@Properly enforce max received file comment length for Unicode strings (from original).
@
text
@d1183 1
a1183 1
			AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Filtered client (don't connect): %s %s"),
@


1.406
log
@Simplified logging system implementation.
@
text
@d855 1
a855 1
//	eMule+ supports shared directories since 1h (0x0108)
d998 4
d1530 9
a1538 7
					if (m_dwPlusVers == 0)
						m_dwPlusVers = (dwMajVer << 8) | ((dwMinVer & 0xF) << 4) | dwUpdVer;
					strClientVer.Format(_T("%u"), dwMajVer);
					if (dwMinVer != 0)
						strClientVer.AppendFormat(_T(".%u"), dwMinVer);
					if (dwUpdVer != 0)
						strClientVer += static_cast<TCHAR>(_T('a') + dwUpdVer - 1);
@


1.405
log
@Reduced H-file dependency.
@
text
@d301 1
a301 1
			AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Ban client %s (%s:%u) changed userhash from %s to %s on HelloAns"),
d817 1
a817 1
		AddDebugLogLine( _T("Error while processing emuletag %u/%u from client %s %s:%u"), i + 1,
d1014 1
a1014 1
						AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Description by client '%s' for file '%s' filtered: %s"),
d1029 1
a1029 1
				AddDebugLogLine( _T("Description by client '%s' for file '%s' received: %s"),
d1036 1
a1036 1
			AddDebugLogLine( _T("Rating by client '%s' for file '%s' received: %s"),
d1122 1
a1122 1
			AddLogLine(true, IDS_SHAREDFILES_FAILED, m_strUserName);
d1179 1
a1179 1
			AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Filtered client (don't connect): %s %s"),
d1647 1
a1647 1
		AddLogLine(true, IDS_SHAREDFILES_REQUEST, m_strUserName);
d1653 1
a1653 1
		AddLogLine(true, IDS_SHAREDFILES_INPROGRESS, m_strUserName, GetUserIDHybrid());
d1773 1
a1773 1
	DEBUG_ONLY(AddDebugLogLine(_T(__FUNCTION__) _T(": Sending public key to '%s'"), m_strUserName));
d1817 1
a1817 1
	DEBUG_ONLY(AddDebugLogLine(_T(__FUNCTION__) _T(": Sending signature key to '%s'"), m_strUserName));
d1822 1
a1822 1
		AddDebugLogLine(_T("Client '%s' want to send signature but challenge value is invalid"), m_strUserName);
d1878 1
a1878 1
	DEBUG_ONLY(g_App.m_pMDlg->AddDebugLogLine(_T(__FUNCTION__) _T(": Receiving public key from '%s'"), m_strUserName));
d1902 1
a1902 1
			AddDebugLogLine( _T("Client '%s': Invalid State error, IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket"),
d1908 1
a1908 1
		AddDebugLogLine(_T("Client '%s' failed to use new received public key"), m_strUserName);
d1915 1
a1915 1
	DEBUG_ONLY(AddDebugLogLine(_T(__FUNCTION__) _T(": Receiving signature from '%s'"), m_strUserName));
d1954 1
a1954 1
		AddDebugLogLine(_T("Received multiple signatures from client %s"), GetClientNameWithSoftware());
d1960 1
a1960 1
		AddDebugLogLine(_T("Received signature for client %s without public key"), GetClientNameWithSoftware());
d1966 1
a1966 1
		AddDebugLogLine(_T("Received signature for client %s with invalid challenge value"), GetClientNameWithSoftware());
d1977 1
a1977 1
		AddDebugLogLine(_T("Client %s has failed the secure identification, V2 State: %i"), GetClientNameWithSoftware(), byteChallengeIPKind);
d2006 1
a2006 1
			DEBUG_ONLY(AddDebugLogLine(_T(__FUNCTION__) _T(": Not sending SecIdentState Packet, because State is Zero")));
d2016 1
a2016 1
		DEBUG_ONLY(AddDebugLogLine(_T(__FUNCTION__) _T(": Sending SecIdentState packet, state: %u (to '%s')"), byteValue, m_strUserName));
d2056 1
a2056 1
	DEBUG_ONLY(AddDebugLogLine(_T(__FUNCTION__) _T(": Received SecIdentState Packet, state: %u"), pbytePacket[0]));
@


1.404
log
@Removed unused client upload states.
@
text
@d25 1
@


1.403
log
@Added multipacket support preparation [eklmn].
@
text
@a1091 2
			case US_WAITCALLBACK:
			case US_ERROR:
a1379 1
		case US_WAITCALLBACK:
@


1.402
log
@Faster (intrinsic) htonl and htons implementation.
@
text
@d170 2
d272 2
d408 3
a410 1
					dwOpt >>= 2;	//skip Preview & MultiPacket
d452 2
a453 1
					dwOpt >>= 1;	//Ext Multipacket
@


1.401
log
@optimized string processing
@
text
@d1266 1
a1266 1
		sockAddr.sin_port = htons(GetUserPort());
@


1.400
log
@Unicode preparations; Suppressed compiler warnings.
@
text
@d2125 1
a2125 1
CString CUpDownClient::GetFullSoftVersionString() const
@


1.399
log
@added Unicode support for hello packets
@
text
@d359 1
a359 1
					m_uUserPort = TempTag.GetIntValue();
d408 1
a408 1
					m_byteAcceptCommentVer = dwOpt & 0x0F;
d410 1
a410 1
					m_byteExtendedRequestsVer = dwOpt & 0x0F;
d412 1
a412 1
					m_byteSourceExchange1Ver = dwOpt & 0x0F;
d414 1
a414 1
					m_byteSupportSecIdent = dwOpt & 0x0F;
d416 1
a416 1
					m_byteDataCompVer = dwOpt & 0x0F;
d418 1
a418 1
					m_byteUDPVer = dwOpt & 0x0F;
d465 1
a465 1
					m_byteCompatibleClient = (m_dwClientVersion >> 24);
d735 1
a735 1
						m_byteDataCompVer = TempTag.GetIntValue();
d740 1
a740 1
						m_uUDPPort = TempTag.GetIntValue();
d745 1
a745 1
						m_byteUDPVer = TempTag.GetIntValue();
d750 1
a750 1
						m_byteSourceExchange1Ver = TempTag.GetIntValue();
d755 1
a755 1
						m_byteAcceptCommentVer = TempTag.GetIntValue();
d760 1
a760 1
						m_byteExtendedRequestsVer = TempTag.GetIntValue();
d767 1
a767 1
						m_byteCompatibleClient = TempTag.GetIntValue();
d800 1
a800 1
						m_byteSupportSecIdent = TempTag.GetIntValue() & 3;
d917 1
a917 1
#ifdef _UNIREADY
d972 1
a972 1
		int length;
d977 1
a977 1
		packetStream.Read(&length, sizeof(length));
d979 3
a981 2
		if (length > packetStream.GetLength() - packetStream.GetPosition())
			length = packetStream.GetLength() - packetStream.GetPosition();
d984 2
a985 2
		if (length > 4 * MAXFILECOMMENTLEN)
			length = 4 * MAXFILECOMMENTLEN;
d987 1
a987 1
		if (length > 0)
d989 1
a989 1
			ReadMB2Str(m_eStrCodingFormat, &m_strComment, packetStream, length);
@


1.398
log
@Download comment rating clean-up after comment filter update {Efix}.
@
text
@d332 1
a332 1
		TempTag.FillFromStream(packetStream);
@


1.397
log
@unicode preparation (explicitly set the string encoding for FillFromStream to the ANSI)
@
text
@d973 3
d1009 4
@


1.396
log
@Recovered changes overwritten by Unicode merge.
@
text
@d730 1
a730 1
			TempTag.FillFromStream(packetStream);
@


1.395
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d431 1
a431 1
				//   1 Supports SourceExachnge2 Packets, ignores SX1 Packet Version
d978 2
a979 2
	//	Increase the raw max. allowed file comment length because of possible UTF8 encoding which according to
	//	standard used up to 4 bytes to encode one character
d986 1
a986 1
		//	Commentfilter
d991 5
a995 6
				CString lowComment(m_strComment);
			//	Lowercase copy to search in
				lowComment.MakeLower();	
				int curPos = 0;
				CString resToken(strList.Tokenize(_T("|"), curPos));
				while (!resToken.IsEmpty())
d997 4
a1000 1
					if (lowComment.Find(resToken) >= 0)
a1007 1
					resToken = strList.Tokenize(_T("|"), curPos);
@


1.394
log
@Improved calculation of available remote client parts;
Removed some unrequired checks;
m_bHasClientNeededParts replaced with m_uNeededParts (target functionality is not fully implemented though).
@
text
@d111 1
a111 1
	m_bUnicodeSupport = false;
d314 1
a314 1
	m_bUnicodeSupport = false;
d420 2
a421 2
#ifdef _UNIREADY
					m_bUnicodeSupport = dwOpt & 0x01;
d978 4
a981 3
	//	Increase the raw max. allowed file comment length because of possible UTF8 encoding
		if (length > 3 * MAXFILECOMMENTLEN)
			length = 3 * MAXFILECOMMENTLEN;
d985 1
a985 2
			packetStream.Read(m_strComment.GetBuffer(length + 1), length);
			m_strComment.ReleaseBuffer(length);
@


1.393
log
@Reduced #include depedency.
@
text
@a110 1
	m_bCompleteSource = false;
d112 1
a112 1
	m_bHasClientNeededParts = false;
d125 3
a127 1
	m_pbyteUpPartStatuses = 0;
d220 6
a225 10
	if (m_pbytePartStatuses != NULL)
	{
		delete[] m_pbytePartStatuses;
		m_pbytePartStatuses	= NULL;
	}
	if (m_pbyteUpPartStatuses != NULL)
	{
		delete[] m_pbyteUpPartStatuses;
		m_pbyteUpPartStatuses = NULL;
	}
d1331 1
a1331 1
					else if (!m_bHasClientNeededParts)
d1343 1
a1343 1
				if (m_bHasClientNeededParts)
@


1.392
log
@Simplified SetUserHash() to remove functionality we're are not using.
@
text
@d21 1
@


1.391
log
@Low priority is used for servers added to the list from other clients (original);
Encryption preparations.
@
text
@d503 1
a503 1
				pServer->SetPreference(PR_LOW);
a1684 12
void CUpDownClient::SetUserHash(uchar* m_achstrTempUserHash)
{
	if (m_achstrTempUserHash == NULL)
	{
		md4clr(m_userHash);
	}
	else
	{
		md4cpy(m_userHash, m_achstrTempUserHash);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.390
log
@Added Source Exchange 2 support (adapted from original 0.48a).
@
text
@d503 1
d2142 20
@


1.389
log
@Updated Source Exchange Protocol to version 4 (ability to spread encryption capabilities);
Preparation to support Source Exchange 2 (0.48a).
@
text
@d138 1
a138 1
	m_byteSourceExchangeVer = 0;
d260 1
a260 1
	m_byteSourceExchangeVer = 0;
d395 1
a395 1
				//  4 Source Exchange
d414 1
a414 1
					m_byteSourceExchangeVer = dwOpt & 0x0F;
d707 1
a707 1
		m_byteSourceExchangeVer = 1;
d751 1
a751 1
						m_byteSourceExchangeVer = TempTag.GetIntValue();
d822 1
a822 1
		m_byteSourceExchangeVer = 0;
d930 3
d934 6
@


1.388
log
@Encryption preparations.
@
text
@d167 1
d271 1
d432 2
a433 1
				//  22 Reserved
d452 2
d647 1
a647 1
		tagWr.WriteToFile(ET_SOURCEEXCHANGE, SOURCEEXCHANGE_VER, packetStream);
d924 1
a924 1
		(SOURCEEXCHANGE_VER		<< 4*3) |	//Source Exchange
@


1.387
log
@Fix a rare crash while redrawing messages window and client was deleted {anonymous in dump 0225}
@
text
@d447 2
a448 8
#ifdef _CRYPT_READY
					m_fSupportsCryptLayer	= dwOpt & 0x01;
					dwOpt >>= 1;
					m_fRequestsCryptLayer	= dwOpt & 0x01 & m_fSupportsCryptLayer;
					dwOpt >>= 1;
					m_fRequiresCryptLayer	= dwOpt & 0x01 & m_fRequestsCryptLayer;
					dwOpt >>= 1;
#endif
@


1.386
log
@Removed unrequired cleanup as it will be done in the consecutive member destructor.
@
text
@a229 1
	{
a230 1
	}
d247 3
@


1.385
log
@Minor formatting.
@
text
@a243 1
	m_averageUDRList.clear();
a244 1

@


1.384
log
@don't filter the lowid without ip
comment correction
@
text
@d292 1
a292 2
		&& HasValidHash()
		&& md4cmp(GetUserHash(),pbytePacket) != 0)
d297 3
a299 5
			AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Ban client %s (%s:%u) with userhash '%s' that changes userhash to '%s' on HA"),
							GetClientNameWithSoftware(),
							GetFullIP(), GetUserPort(),
							HashToString(GetUserHash()),
							HashToString(pbytePacket));
@


1.383
log
@removed an optimization for dublicated filtering
@
text
@d1154 1
a1154 1
//	Although we filter all received IPs (server sources, source exchange) and all incomming connection attempts,
d1157 1
a1157 1
	if (g_App.m_pIPFilter->IsFiltered(m_dwConnectIP))
@


1.382
log
@Newly added stuff was renamed according to the original for easier reference;
Minor optimization to set UserID for Lancast.
@
text
@d1153 18
a1177 4
	//	note: we don't need to check IP for LowID sources because:
	//		1) fresh added LowID sources don't have IP anyway
	//		2) after callback the sources will be filtered in OnAccept()

a1229 22
	//	Check if the client has proper connect IP
		if (m_dwConnectIP == 0)
		{
			Disconnected(false);
			return false;
		}

	//	Check this IP in filter
		if (g_App.m_pIPFilter->IsFiltered(m_dwConnectIP))
		{
			if (!g_App.m_pPrefs->IsCMNotLog())
			{
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Filtered client (don't connect): %s %s"),
								 GetFullIP(), g_App.m_pIPFilter->GetLastHit() );
			}
		//	Disconnect and don't retry.
			Disconnected(false);
			InterlockedIncrement(&g_App.m_lOutgoingFiltered);
			InterlockedIncrement(&g_App.m_lTotalFiltered);
			return false;
		}
	
@


1.381
log
@ver.3 inside hello packet
@
text
@d48 1
a48 1
CUpDownClient::CUpDownClient(uint16 uPort, uint32 dwUserID, uint32 dwServerIP, uint16 uServerPort, CPartFile *pReqPartFile, EnumClientIDType eIDType) :
d57 2
a58 2
	if (eIDType == CIDT_HYBRID || IsLowID(dwUserID))
		SetHybridUserID(dwUserID);
d60 1
a60 1
		SetHybridUserID(ntohl(dwUserID));
d65 1
a65 1
		m_dwConnectIP = ntohl(m_dwHybridUserID);
d73 2
a74 2
	m_dwServerIP = dwServerIP;
	m_uServerPort = uServerPort;
d103 1
a103 1
	SetHybridUserID(0);
d324 2
a325 2
	packetStream.Read(&m_dwHybridUserID,4);
	m_bIsLowID = IsLowID(m_dwHybridUserID);
a545 2
	if (m_bIsOnLan)
		SetHybridUserID(ntohl(m_dwUserIP));
d547 6
a552 6
//	(a) If this is a highID user, store the ID in the Hybrid format.
//	(b) Some older clients will not send a ID, these client are HighID users that are not connected to a server.
//	(c) The ed2k users (that are not connected to Kad) with a *.*.*.0 IPs will look like a lowID user they are actually
//		a highID user. They can be detected easily because they will send a ID that is the same as their IP.
	if (!HasLowID() || m_dwHybridUserID == 0 || m_dwHybridUserID == m_dwUserIP)
		SetHybridUserID(ntohl(m_dwUserIP));
d928 2
a929 2
		(dwSupportSecIdent				<< 4*4) |	//Secure Ident
		(SOURCEEXCHANGE_VER				<< 4*3) |	//Source Exchange
d1206 1
a1206 1
			memcpy(pPacket->m_pcBuffer, &m_dwHybridUserID, 4);
d1644 1
a1644 1
		AddLogLine(true, IDS_SHAREDFILES_INPROGRESS, m_strUserName, GetHybridUserID());
d1674 1
a1674 1
	strInfo.Format(GetResString(IDS_USERINFO), m_strUserName, GetHybridUserID());
d1716 1
a1716 1
		strUserName, GetResString(IDS_USERID), GetHybridUserID(), strCountry,
@


1.380
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d930 2
a931 2
		(dwSupportSecIdent		<< 4*4) |	//Secure Ident
		(2						<< 4*3) |	//Source Exchange
@


1.379
log
@Fixed source loss at the time of unexpected downloading disconnection {muleteer};
Formatting.
@
text
@d48 1
a48 1
CUpDownClient::CUpDownClient(uint16 uPort, uint32 dwClientID, uint32 dwServerIP, uint16 uServerPort, CPartFile *pReqPartFile) :
d57 4
a60 1
	SetUserID(dwClientID);
d62 1
d65 1
d67 4
a70 5
								static_cast<byte>(m_dwUserID),
								static_cast<byte>(m_dwUserID >> 8),
								static_cast<byte>(m_dwUserID >> 16),
								static_cast<byte>(m_dwUserID >> 24) );
		m_dwConnectIP = m_dwUserID;
d103 1
a103 1
	SetUserID(0);
d322 1
a322 4
	uint32	dwUserID, dwTagCount, dwEmuleTags = 0;
	uint16	uUserPort;

	packetStream.Read(&dwUserID, 4);
d324 2
a325 2
	if (m_dwUserID == 0)
		SetUserID(dwUserID);
d327 1
a327 1
	packetStream.Read(&uUserPort, 2);
d363 1
a363 1
					uUserPort = TempTag.GetIntValue();
a486 1
	m_uUserPort = uUserPort;
d547 1
a547 1
		m_dwUserID = m_dwUserIP;
d549 6
a554 3
//	Make sure if this user is a HighID user his userID matches his IP address
	if (!HasLowID() && m_dwUserID != m_dwUserIP)
		SetUserID(m_dwUserIP);
d588 1
a588 2
	if (g_App.m_pServerConnect->GetClientID() != m_dwUserID
		&& md4cmp(m_userHash, g_App.m_pPrefs->GetUserHash()) == 0
d654 1
a654 1
		tagWr.WriteToFile(ET_SOURCEEXCHANGE, 2, packetStream);
a1154 40
//	Filter LowIDs separately from HighIDs

//	If the client has a client IP...
	if (m_dwUserIP > 0)
	{
	//	case 1: it's a Client with known IP, always test the client IP instead of the client ID.
		if (g_App.m_pIPFilter->IsFiltered(m_dwUserIP))
		{
			if (!g_App.m_pPrefs->IsCMNotLog())
			{
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Filtered client (don't connect): %s %s"),
								 GetFullIP(), g_App.m_pIPFilter->GetLastHit() );
			}
		//	Disconnect and don't retry.
			Disconnected(false);
			InterlockedIncrement(&g_App.m_lOutgoingFiltered);
			InterlockedIncrement(&g_App.m_lTotalFiltered);
			return false;
		}
	}
//	If the client has no IP...
	else
	{
	//	If the client has a high ID...
		if (m_dwUserID > 0xFFFFFF)
		{
		//	case 2: it's HighID with client IP empty, test client ID instead
			if (g_App.m_pIPFilter->IsFiltered(m_dwUserID))
			{
				if (!g_App.m_pPrefs->IsCMNotLog())
					AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Filtered client (don't connect): %s %s"),
									 GetFullIP(), g_App.m_pIPFilter->GetLastHit() );
				Disconnected(false);
				InterlockedIncrement(&g_App.m_lOutgoingFiltered);
				InterlockedIncrement(&g_App.m_lTotalFiltered);
				return false;
			}
		}
	}

d1162 4
d1208 1
a1208 1
			memcpy(pPacket->m_pcBuffer, &m_dwUserID, 4);
d1218 22
d1646 1
a1646 1
		AddLogLine(true, IDS_SHAREDFILES_INPROGRESS, m_strUserName, GetUserID());
d1676 1
a1676 1
	strInfo.Format(GetResString(IDS_USERINFO), m_strUserName, GetUserID());
d1718 1
a1718 1
		strUserName, GetResString(IDS_USERID), GetUserID(), strCountry,
@


1.378
log
@remove SetWaitStartTime() in Init() (thanks Aw3)
@
text
@d162 1
d593 1
a593 1
//	Check famous stolen hashs/names
a1058 1
			{
a1059 1
			}
a1066 1
			{
a1067 1
			}
a1074 1
			{
a1075 1
			}
a1079 1
			{
d1086 1
a1086 1
			}
a1088 1
			{
a1090 1
			}
d1120 1
@


1.377
log
@removed "unfair *" statistic
@
text
@a150 1
	SetWaitStartTime();
@


1.376
log
@ban client who try to change the userhash on second connection
@
text
@d292 8
a299 9
		InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_App.m_lTotalNumHashChangeActions);
#if 1
		AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Ban client %s (%s:%u) with userhash '%s' that changes userhash to '%s' on HA"),
						GetClientNameWithSoftware(),
						GetFullIP(), GetUserPort(),
						HashToString(GetUserHash()),
						HashToString(pbytePacket));
#endif
a589 2
		InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_App.m_lTotalNumUseMyHashActions);
d595 1
a595 4
	{
		InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_App.m_lTotalNumStolenNameActions);
	}
a870 3
	{
		InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_App.m_lTotalNumLeecherTypeActions);
a871 1
	}
@


1.375
log
@protect the waiting time with SUI
@
text
@d44 1
d72 1
d286 3
a288 3
#if 1
// check if client try to change userhash with Hello Answer
	if (md4cmp0(GetUserHash()) != 0
d291 5
a295 1
		AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Client %s (%s:%u) with userhash '%s' changes userhash to '%s' on HA"),
d300 1
a301 1
#endif
d306 1
@


1.374
log
@added temporary debug message for better tracing of hash changers(stealers)
@
text
@d78 1
a78 1
	m_pCredits = 0;
@


1.373
log
@Modified constructors to avoid potential compiling issue due to type collision.
@
text
@d283 14
@


1.372
log
@remove the hash stealer detection from xrmb because:
1) duplicated functionaly, i.e. it has similar functionaly as client credits
2) useless when client changes a ports (remember an random ports)
as result less CPU load and memory consumption
@
text
@d1386 1
a1386 1
				Packet		*pPacket = new Packet(OP_ACCEPTUPLOADREQ);
d1403 1
a1403 1
		Packet		*pPacket = new Packet((m_fSupportsAskSharedDirs != 0) ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES);
@


1.371
log
@Encryption preparations.
@
text
@a561 1
//--- xrmb:hashthieves1 ---
a562 11
//	Get IP-Port hash
	const uint64 qwIPPortID = GetUID();
	uint32 dwNewUnfairActions = 0;
	uint32 dwUnfairClientActions = 0;
	OffenseCounterMap::iterator OffenseCounterIt = g_App.m_pClientList->m_mapOffenseCounter.find(qwIPPortID);

	if (OffenseCounterIt != g_App.m_pClientList->m_mapOffenseCounter.end())
	{
		dwUnfairClientActions = OffenseCounterIt->second;
	}

a569 1
		dwNewUnfairActions++;
a574 23
//	Detect a hash chager (detect id-changer). Actually we are detecting a change of ID based on UserHash
	uint64 qwNewHashID = 0;
	uint32 *pdwHash = reinterpret_cast<uint32*>(GetUserHash());

//	Calculate a HASH-ID
	qwNewHashID = (static_cast<uint64>(pdwHash[1] ^ pdwHash[3]) << static_cast<uint64>(32)) |
		static_cast<uint64>(pdwHash[0] ^ pdwHash[2]);

//	Check a map
	HashBaseMap::iterator HashBaseIt = g_App.m_pClientList->m_mapHashBase.find(qwIPPortID);

	if (HashBaseIt != g_App.m_pClientList->m_mapHashBase.end())
	{
		if (HashBaseIt->second != qwNewHashID)
		{
			dwNewUnfairActions++;
			InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
			InterlockedIncrement(&g_App.m_lTotalNumHashChangeActions);
		}
	}
//	Update a IDhash
	g_App.m_pClientList->m_mapHashBase[qwIPPortID] = qwNewHashID;

a577 1
		dwNewUnfairActions++;
a581 14
	if ((dwUnfairClientActions + dwNewUnfairActions) >= 3
		&& g_App.m_pPrefs->IsCounterMeasures())
	{
		Ban(BAN_CLIENT_CHANGED_HASH_3_TIMES);
	}

//	If we found new unfair action from remote client, then update table
	if (dwNewUnfairActions != 0)
	{
		g_App.m_pClientList->m_mapOffenseCounter[qwIPPortID] = dwUnfairClientActions + dwNewUnfairActions;
		g_App.m_lTotalNumUnfairClients = g_App.m_pClientList->m_mapOffenseCounter.size();
	}
//--- :xrmb ---

a856 9
		const uint64 qwIPPortID = GetUID();
		uint32 dwUnfairClientActions = 0;
		OffenseCounterMap::iterator OffenseCounterIt = g_App.m_pClientList->m_mapOffenseCounter.find(qwIPPortID);

		if (OffenseCounterIt != g_App.m_pClientList->m_mapOffenseCounter.end())
		{
			dwUnfairClientActions = OffenseCounterIt->second;
		}
		dwUnfairClientActions++;
a858 2
		g_App.m_pClientList->m_mapOffenseCounter[qwIPPortID] = dwUnfairClientActions;
		g_App.m_lTotalNumUnfairClients = g_App.m_pClientList->m_mapOffenseCounter.size();
d2037 1
a2037 1
		memcpy2(pPacket->m_pcBuffer + 1, &dwRandom, sizeof(dwRandom));
@


1.370
log
@Server list update option was split into update from servers and clients {ElAguila}.
@
text
@d158 3
d262 3
d413 6
a418 1
				//	27 Reserved
d428 10
@


1.369
log
@Removed user hash spoofing for MLdonkey, as this code is completely useless nowadays.
@
text
@d459 1
a459 1
		if (!bCrashed && g_App.m_pPrefs->GetAddServersFromConn())
@


1.368
log
@Large file size support (max file size 512 GB - 1 = 549,755,813,887).
@
text
@d928 1
a928 21
	BYTE		hash[16];
	CWrTag		tagWr;

	md4cpy(hash, g_App.m_pPrefs->GetUserHash());

//	Checking for MLdonkey does not help against their unfair share policy anymore
//	since they have removed this feature so we emulate now an eDonkey to MLdonkey

//	If we can see that the client is MLdonkey and MLdonkey countermeasures are turned on...
	if (GetClientSoft() == SO_MLDONKEY && g_App.m_pPrefs->IsCounterMeasures())
	{
	//	Spoof the identifying bytes in the hash with random values.
		do
		{
			uint32 dwRnd = rand();

			hash[5] = static_cast<BYTE>(dwRnd);
			hash[14] = static_cast<BYTE>(dwRnd >> 8);
		} while ((hash[5] == 14) || (hash[14] == 111));
	}
	packetStream.Write(hash, 16);					// <userhash 16>
d936 1
a936 1
	uint16		nPort = g_App.m_pPrefs->GetListenPort();
d938 1
a938 1
	packetStream.Write(&nPort, 2);					// <ourport 2>
d940 1
d976 1
a976 1
	nPort = 0;
d984 1
a984 1
		nPort = pCurServer->GetPort();
d988 1
a988 1
	packetStream.Write(&nPort, 2);					// <serverport 2>
@


1.367
log
@Corrected state change after swapping A4AF remote LowID sources.
@
text
@a959 1
#if _LARGEFILE_READY
a960 3
#else
	uint32		dwTagCount = 5;
#endif
a982 1
#if _LARGEFILE_READY
a985 1
#endif
@


1.366
log
@Stop communication with a source after mismatch file request.
@
text
@d1279 3
a1281 4
				if (m_bHasClientNeededParts)
					SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
				else
					SetDownloadState(DS_NONEEDEDPARTS);
@


1.365
log
@Unified packet buffer type.
@
text
@d157 1
@


1.364
log
@Added missed timeout processing for local LowID clients [eklmn].
@
text
@d273 1
a273 1
void CUpDownClient::ProcessHelloAnswer(char* pbytePacket, uint32 dwSize)
d276 1
a276 1
	CSafeMemFile packetStream((BYTE*)pbytePacket, dwSize);
d587 1
a587 1
	 g_App.m_pClientList->m_mapHashBase[qwIPPortID] = qwNewHashID;
d1016 1
a1016 1
void CUpDownClient::ProcessMuleCommentPacket(char* pachPacket, uint32 dwSize)
d1022 1
a1022 1
		CSafeMemFile packetStream((BYTE*)pachPacket, dwSize);
d1727 1
a1727 1
void CUpDownClient::ProcessSharedFileList(char *pachPacket, uint32 dwSize, LPCTSTR strDirectory)
d1736 1
a1736 1
		g_App.m_pSearchList->ProcessSharedFileListAnswer(pachPacket, dwSize, this, strDirectory, bFirstDir);
@


1.363
log
@Corrected download state change for remote LowID sources.
@
text
@d1308 2
@


1.362
log
@Fixed recently changes for download state of remote LowID NNS (as a result fixed broken:
source exchange because number of valid sources was incorrect, A4AF swap, sorting of NNS, NNS statistics, etc.).
@
text
@d1099 1
a1099 1
			SetDownloadState(DS_ONQUEUE);
@


1.361
log
@Fixed disappearing muleteer... (processing of remote LowID NNS) {muleteer/Fuxie - DK}.
@
text
@d1277 6
a1282 1
				SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
d1411 2
d1415 1
a1415 1
					else if (HasClientNeededParts())
a1416 2
					else
						SetDownloadState(DS_NONEEDEDPARTS);
d1423 1
a1423 1
				if (HasClientNeededParts())
a2105 1

@


1.360
log
@Simplified/speeded up processing of partfile status.
@
text
@a1181 1
			m_dwEnteredConnectedState = 0;
@


1.359
log
@Fixed update of reask time in some cases; Renamed DS_LOWTOLOWIP -> DS_LOWTOLOWID.
@
text
@d1390 1
a1390 1
			if ((m_pReqPartFile != NULL) && (m_pReqPartFile->GetStatus(false) != PS_PAUSED)
@


1.358
log
@Fixed completely wrong LowID processing {Fuxie - DK/muleteer} (beta 1 is broken).
@
text
@d1121 1
a1121 1
			case DS_LOWTOLOWIP:
d1268 1
a1268 1
				SetDownloadState(DS_LOWTOLOWIP);
d1388 1
a1388 1
		case DS_LOWTOLOWIP:
d1406 1
a1406 1
						SetDownloadState(DS_LOWTOLOWIP);
a1431 1
			SetDownloadState(DS_CONNECTED);
d1434 1
@


1.357
log
@Formatting.
@
text
@d1275 1
a1275 1
		else if (g_App.m_pServerConnect->GetLocalIP() != GetServerIP())
d1380 1
a1380 1
				if ((g_App.m_pServerConnect->GetLocalIP() == GetServerIP())
d1407 1
a1407 1
					else if (g_App.m_pServerConnect->GetLocalIP() != GetServerIP())
@


1.356
log
@change the detection of local LowID; added OnConnect()
@
text
@d1256 3
a1258 3
//	Check the cases when it's not possible to establish a connection to remote Low ID client 
//	1. our client don't connected to the server
//	2. both clients have LowIDs.
d1260 1
a1260 1
//	4. LowID client in US_CONNECTING state what according Merkur design should never be.
d1377 2
a1378 2
			//	If remote client is still on same sever then check if it's allowed to reask,
			//	otherwise remote client fall through & reask or set proper dowload state
d1383 1
a1383 1
						break;
a1385 1

@


1.355
log
@Reduced H-file dependency.
@
text
@a1364 2
		//	Update the time to prevent an additional request from PartFile::Process()
			SetLastAskedTime();
d1380 1
a1380 1
				if (g_App.m_pServerConnect->IsLocalServer(m_dwServerIP, m_uServerPort)
d1408 1
a1408 1
					else if (!g_App.m_pServerConnect->IsLocalServer(m_dwServerIP, m_uServerPort))
d1434 2
@


1.354
log
@1) last LowID check, i.e. put LowID client in proper state in TryToConnect();
2) added CONNECTING state
3) force request by A4AF swap for LowID clients (the proper state will set inTryToConnect() )
@
text
@d18 1
a18 1
#include "StdAfx.h"
d21 1
@


1.353
log
@It's better like this.
@
text
@d1199 2
a1200 1
	if ((m_pRequestSocket != NULL) && m_pRequestSocket->IsConnected())
d1213 1
a1253 1
#endif OLD_SOCKETS_ENABLED
d1255 5
a1259 1
//	MOD Note: Do not change this part - Merkur
d1262 3
a1264 2
	//	If we both have LowIDs...
		if (g_App.m_pServerConnect->IsLowID())
d1274 6
d1281 2
a1282 3
		if (GetDownloadState() == DS_CONNECTING)
		{
			SetDownloadState(DS_WAITCALLBACK);
d1284 1
a1284 1
		if (GetUploadState() == US_CONNECTING)
d1286 11
a1296 3
			Disconnected();
			return false;
		}
a1297 4
#ifdef OLD_SOCKETS_ENABLED
	//	If the client is on the same server that we are...
		if (g_App.m_pServerConnect->IsLocalServer(m_dwServerIP, m_uServerPort))
		{
a1303 19
	//	If the LowID client is on another server...
		else
		{
		//	If we're not uploading to him or currently downloading...
			if (GetUploadState() == US_NONE && (!GetRemoteQueueRank() || m_bReaskPending))
			{
				g_App.m_pDownloadQueue->RemoveSource(this);
				Disconnected();
				return false;
			}
			else
			{
				if (GetDownloadState() == DS_WAITCALLBACK)
				{
					m_bReaskPending = true;
					SetDownloadState(DS_ONQUEUE);
				}
			}
		}
a1305 1
//	MOD Note - end
d1374 9
a1382 5
		//	Don't reask faster than old client version when LowID client is on the same server
			if (g_App.m_pServerConnect->IsLocalServer(m_dwServerIP, m_uServerPort)
				&& (::GetTickCount() - m_dwLastAskedTime) < OLD_FILEREASKTIME)
			{
				if (m_fServerWasChanged == 1)
d1384 1
a1384 4
					if (g_App.m_pServerConnect->IsLowID())
						SetDownloadState(DS_LOWTOLOWIP);
					else if (GetServerIP() != g_App.m_pServerConnect->GetCurrentServer()->GetIP())
						SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
a1385 1
				break;
d1387 1
d1401 19
a1419 2
			else if ((m_fServerWasChanged == 1)
				&& (GetServerIP() == g_App.m_pServerConnect->GetCurrentServer()->GetIP()))
d1421 1
a1421 3
				if (g_App.m_pServerConnect->IsLowID())
					SetDownloadState(DS_LOWTOLOWIP);
				else if (HasClientNeededParts())
@


1.352
log
@Improved string processing.
@
text
@d1048 1
a1048 1
					if (lowComment.Find(resToken) != -1)
@


1.351
log
@Unicode preparations; Slightly faster socket creation to contact other sources.
@
text
@d1048 1
a1048 1
					if (lowComment.Find(resToken) > -1)
d1050 1
a1050 1
						AddDebugLogLine( RGB_LOG_DIMMED + _T("Description by client '%s' for file '%s' filtered: %s"),
d1223 1
a1223 1
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Filtered client (don't connect): %s %s"),
d1243 1
a1243 1
					AddDebugLogLine( RGB_LOG_DIMMED + _T("Filtered client (don't connect): %s %s"),
@


1.350
log
@optimization in TryToConnect:
1) don't check the IP in IP-filter if socket was created & connection is established
2) don't create socket for LowID clients
@
text
@d160 2
a161 1
		SOCKADDR_IN		sockAddr;
d163 3
a165 8
		memzero(&sockAddr, sizeof(sockAddr));

		int		iSockAddrLen = sizeof(sockAddr);

		m_pRequestSocket->GetPeerName(reinterpret_cast<SOCKADDR*>(&sockAddr),&iSockAddrLen);
		m_dwUserIP = sockAddr.sin_addr.S_un.S_addr;
		m_strFullUserIP = inet_ntoa(sockAddr.sin_addr);
		m_dwConnectIP = m_dwUserIP;
d462 1
a462 5
				in_addr		addhost;

				addhost.S_un.S_addr = m_dwServerIP;

				CServer		*pServer = new CServer(m_uServerPort, CString(inet_ntoa(addhost)));
d487 2
a488 5
	SOCKADDR_IN		sockAddr;

	memzero(&sockAddr, sizeof(sockAddr));

	uint32			dwSockAddrLen = sizeof(sockAddr);
d491 4
a494 5
	m_pRequestSocket->GetPeerName((SOCKADDR*) &sockAddr, (int*) &dwSockAddrLen);
#endif //OLD_SOCKETS_ENABLED

	m_dwUserIP = sockAddr.sin_addr.S_un.S_addr;
	m_strFullUserIP = inet_ntoa(sockAddr.sin_addr);
d1334 6
a1339 1
		m_pRequestSocket->Connect(GetFullIP(), GetUserPort());
a1783 1
		in_addr			serverAddr;
d1785 1
a1785 2
		serverAddr.S_un.S_addr = GetServerIP();
		strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s:%u"), GetResString(IDS_SERVER), inet_ntoa(serverAddr), GetServerPort());
@


1.349
log
@roll back the changes that lead to performance drop
@
text
@d1209 11
a1219 2
//	If we have too many sockets open and we're not already connected...
	if ((g_App.m_pListenSocket->TooManySockets() && !bIgnoreMaxCon) && !(m_pRequestSocket != NULL && m_pRequestSocket->IsConnected()))
a1263 12

//	If we both have LowIDs...
	if (g_App.m_pServerConnect->IsLowID() && HasLowID())
	{
		if (GetDownloadState() == DS_CONNECTING)
			SetDownloadState(DS_LOWTOLOWIP);
		if (GetUploadState() == US_CONNECTING)
			SetUploadState(US_NONE);

		Disconnected(false);
		return false;
	}
d1266 2
a1267 2
#ifdef OLD_SOCKETS_ENABLED
	if (m_pRequestSocket == NULL)
d1269 2
a1270 2
		m_pRequestSocket = new CClientReqSocket(this);
		if (!m_pRequestSocket->Create())
d1272 7
a1278 2
			m_pRequestSocket->Safe_Delete();
			return true;
d1280 1
a1280 22
	}
	else if (!m_pRequestSocket->IsConnected())
	{
		m_pRequestSocket->Safe_Delete();
		m_pRequestSocket = new CClientReqSocket(this);
		if (!m_pRequestSocket->Create())
		{
			m_pRequestSocket->Safe_Delete();
			return true;
		}
	}
//	If we already have a connected request socket, we're done
	else
	{
		if (IsHandshakeFinished())
			ConnectionEstablished();
		return true;
	}
#endif OLD_SOCKETS_ENABLED
//	MOD Note: Do not change this part - Merkur
	if (HasLowID())
	{
d1297 1
a1297 1
			memcpy2(pPacket->m_pcBuffer, &m_dwUserID, 4);
a1320 1

d1326 20
@


1.348
log
@Simplified client upload data rate processing -- never return negative (Mantis #518).
@
text
@d1376 2
d1407 2
@


1.347
log
@prevent data exchange before hello-handshake will be finished
@
text
@d91 1
a91 1
	m_lUpDataRate = -1;
d455 2
a456 1
	if ((m_dwServerIP != dwServerIP) || (m_uServerPort != uServerPort))
a457 1
		m_fServerWasChanged = 1;
a477 2
	else
		m_fServerWasChanged = 0;
d1098 1
a1098 1
	//	If the client is uploading, remove it from the upload queue.
a1396 1

@


1.346
log
@rare incorrect setting of NNS state by download
@
text
@d192 2
d281 1
d930 1
a1194 1
			g_App.m_pClientList->UpdateClient(this);
d1197 1
d1294 2
a1295 1
		ConnectionEstablished();
@


1.345
log
@Some updates from the original related to 64-bit file size support.
@
text
@d155 1
d447 6
a452 4
	packetStream.Read(&m_dwServerIP, 4);
	packetStream.Read(&m_uServerPort, 2);
//	If the client didn't try to crash us with a blank name and the "add servers to server list on connect" preference is on...
	if (!bCrashed && g_App.m_pPrefs->GetAddServersFromConn())
d454 5
a458 2
	//	... and server IP and port are valid (fast check) and the server isn't already in our server list
		if ((m_dwServerIP != 0) && (m_uServerPort != 0) && !g_App.m_pServerList->GetServerByIP(m_dwServerIP, m_uServerPort))
d460 4
a463 1
			in_addr		addhost;
d465 1
a465 1
			addhost.S_un.S_addr = m_dwServerIP;
d467 1
a467 1
			CServer		*pServer = new CServer(m_uServerPort, CString(inet_ntoa(addhost)));
d469 4
a472 3
			pServer->SetListName(pServer->GetAddress());
			if (!g_App.m_pMDlg->m_wndServer.m_ctlServerList.AddServer(pServer, true))
				delete pServer;
d475 2
d1385 7
d1394 1
d1406 10
a1435 2
				SetUploadState(US_UPLOADING);

d1444 1
@


1.344
log
@1) keep ban reason information (part 2 - GUI)
2) removed debug string "incoming FR for LowID.."
@
text
@d154 1
d257 1
d405 2
a406 1
				//	28 Reserved
d408 9
a416 1
//				dwEmuleTags |= 8;
d956 3
d960 1
d983 6
a1368 1

a1374 1

@


1.343
log
@Added some Unicode capabilities code (so far disabled).
@
text
@a1354 10
#if 1
		//fell though 
			if ((m_pReqPartFile != NULL) && (m_pReqPartFile->GetStatus(false) != PS_PAUSED)
				&& ((::GetTickCount() - m_dwLastAskedTime) > MIN_REQUESTTIME))
			{
				AddDebugLogLine(RGB_BLUE_VIOLET_TXT _T("FR on incoming connection from LowID client (t=%u min,c=%s,h=%s)"),
					(::GetTickCount() - m_dwLastAskedTime)/60000,
					GetClientNameWithSoftware(),
					HashToString(GetUserHash()));
			}
a1355 1
#endif
d1752 3
@


1.342
log
@Minor formatting.
@
text
@d104 1
d284 1
d369 1
a369 1
				//	1 PeerChache supported
d393 4
d918 2
a919 2
//	Checking for MLDonkey does not help against their unfair share policy anymore
//	since they have removed this feature so we emulate now an eDonkey to MLDonkey.
d921 1
a921 1
//	If we can see that the client is MLDonkey and MLDonkey countermeasures are turned on...
d957 3
@


1.341
log
@1) keep ban reason information (part 1 - logic)
2) disable incoming FR for LowID if file was paused
@
text
@d378 1
a378 1
					dwOpt >>= 1;	//skip PeerChache
d864 2
a865 2
//	Check leecher clients
	if ( HasMODNameForbiddenStrings() )
d1340 1
a1340 1
		//	Don't reask faster as old version, if LowID client is on same server
d2121 1
a2121 1
	//	Check if client isn't eMulePlus, but use our MOD string, 
d2124 1
a2124 1
			m_bHasMODNameForbiddenStrings = (GetModString() == _T(PLUS_VERSION_STR));
@


1.340
log
@removed unused code
@
text
@d99 1
a99 1
	m_bBanned = false;
d540 1
a540 1
		Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_HASHIMP));
d581 1
a581 1
		Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_HASHSTEAL));
d865 1
a865 2
	if ( HasMODNameForbiddenStrings() || ( (GetModString() == _T(PLUS_VERSION_STR)) &&
		(m_dwPlusVers == 0) ) )
d880 1
a880 1
		Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), GetResString(IDS_BAN_LEECHERADV));
d1348 2
a1349 1
			if ((::GetTickCount() - m_dwLastAskedTime) > MIN_REQUESTTIME)
d1362 2
a1363 1
			if ((::GetTickCount() - m_dwLastAskedTime) > MIN_REQUESTTIME)
d2121 6
@


1.339
log
@some improvements in FR on incoming LowID connection
@
text
@a609 8
		SOCKADDR_IN	sockAddr;

		memzero(&sockAddr, sizeof(sockAddr));

		uint32		dwSockAddrLen = sizeof(sockAddr);

		m_pRequestSocket->GetPeerName(reinterpret_cast<SOCKADDR*>(&sockAddr), reinterpret_cast<int*>(&dwSockAddrLen));

d1741 1
a1741 1
		strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s:%d"), GetResString(IDS_SERVER), inet_ntoa(serverAddr), GetServerPort());
@


1.338
log
@Corrected test message.
@
text
@d1348 7
d1372 1
@


1.337
log
@small corrections noted in forum
@
text
@a1347 1
		//fail though
d1349 1
d1352 1
a1352 1
				AddDebugLogLine(RGB_BLUE_VIOLET_TXT _T("FR on incoming connection from LowID client (t=%u min,c='%s',h='%s') "),
d1357 1
a1358 1

@


1.336
log
@file reask on incomming connection from LowID clients
@
text
@d1348 2
a1349 1
		//fail though 
d1352 1
a1352 1
				AddDebugLogLine(RGB_BLUE_VIOLET_TXT _T("FR on incomming connection from LowID client (t=%u min,c='%s',h='%s') "),
d1357 1
@


1.335
log
@Formatting.
@
text
@d1344 13
a1360 1
			SetDownloadState(DS_CONNECTED);
d1362 2
d1365 1
@


1.334
log
@hotfix for the problem with source removement in error state
@
text
@d1092 1
a1092 1
		};
d1102 1
a1102 1
		};
d1112 1
a1112 1
		};
d1130 1
a1130 1
		};
@


1.333
log
@Define max comment length.
@
text
@d1128 1
@


1.332
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1005 3
a1007 2
		if (length > 50)
			length = 50;
@


1.331
log
@renamed 3 variables
@
text
@d432 1
a432 1
	if (!bCrashed && g_App.g_pPrefs->GetAddServersFromConn())
d484 1
a484 1
	m_bIsOnLan = ((g_App.g_pPrefs->GetLancastEnabled()) && ((g_App.g_pPrefs->GetLancastIP() & g_App.g_pPrefs->GetLancastSubnet()) == (m_dwUserIP & g_App.g_pPrefs->GetLancastSubnet())));
d537 2
a538 2
		&& md4cmp(m_userHash, g_App.g_pPrefs->GetUserHash()) == 0
		&& g_App.g_pPrefs->IsCounterMeasures())
d579 1
a579 1
		&& g_App.g_pPrefs->IsCounterMeasures())
d654 1
a654 1
		tagWr.WriteToFile(ET_UDPPORT, g_App.g_pPrefs->GetUDPPort(), packetStream);
d919 1
a919 1
	md4cpy(hash, g_App.g_pPrefs->GetUserHash());
d925 1
a925 1
	if (GetClientSoft() == SO_MLDONKEY && g_App.g_pPrefs->IsCounterMeasures())
d944 1
a944 1
	uint16		nPort = g_App.g_pPrefs->GetListenPort();
d952 1
a952 1
	g_App.g_pPrefs->WritePreparedNameTag(packetStream);		// { NAME : int }
d954 1
a954 1
	tagWr.WriteToFile(CT_EMULE_UDPPORTS, g_App.g_pPrefs->GetUDPPort(), packetStream);
d958 1
a958 1
	const uint32	dwNoViewSharedFiles = ((g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_NOONE) ? 1 : 0); // for backward compatibility this has to be a 'negative' flag
d1013 1
a1013 1
			CString strList(g_App.g_pPrefs->GetCommentFilter().MakeLower());
d1187 1
a1187 1
			if (!g_App.g_pPrefs->IsCMNotLog())
d1208 1
a1208 1
				if (!g_App.g_pPrefs->IsCMNotLog())
@


1.330
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d65 1
a65 1
		m_uUserCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwConnectIP);
d167 1
a167 1
		m_uUserCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwConnectIP);
d196 2
a197 2
	g_eMuleApp.m_pDownloadList->RemoveSource(this);
	g_eMuleApp.m_pClientList->RemoveClient(this);
d203 1
a203 1
	g_eMuleApp.m_pListenSocket->DeleteSocket(m_pRequestSocket);
d235 1
a235 1
	DEBUG_ONLY (g_eMuleApp.m_pListenSocket->Debug_ClientDeleted(this));
d432 1
a432 1
	if (!bCrashed && g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn())
d435 1
a435 1
		if ((m_dwServerIP != 0) && (m_uServerPort != 0) && !g_eMuleApp.m_pServerList->GetServerByIP(m_dwServerIP, m_uServerPort))
d444 1
a444 1
			if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(pServer, true))
d480 1
a480 1
		m_uUserCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwConnectIP);
d484 1
a484 1
	m_bIsOnLan = ((g_eMuleApp.m_pGlobPrefs->GetLancastEnabled()) && ((g_eMuleApp.m_pGlobPrefs->GetLancastIP() & g_eMuleApp.m_pGlobPrefs->GetLancastSubnet()) == (m_dwUserIP & g_eMuleApp.m_pGlobPrefs->GetLancastSubnet())));
d495 1
a495 1
	m_pCredits = g_eMuleApp.m_pClientCreditList->GetCredit(key);
d497 1
a497 1
	if ((m_pFriend = g_eMuleApp.m_pFriendList->SearchFriend(key, m_dwUserIP, m_uUserPort)) != NULL)
d508 1
a508 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.SetItem(g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.GetTabByClient(this), &tcNewItem);
d527 1
a527 1
	OffenseCounterMap::iterator OffenseCounterIt = g_eMuleApp.m_pClientList->m_mapOffenseCounter.find(qwIPPortID);
d529 1
a529 1
	if (OffenseCounterIt != g_eMuleApp.m_pClientList->m_mapOffenseCounter.end())
d536 3
a538 3
	if (g_eMuleApp.m_pServerConnect->GetClientID() != m_dwUserID
		&& md4cmp(m_userHash, g_eMuleApp.m_pGlobPrefs->GetUserHash()) == 0
		&& g_eMuleApp.m_pGlobPrefs->IsCounterMeasures())
d542 2
a543 2
		InterlockedIncrement(&g_eMuleApp.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_eMuleApp.m_lTotalNumUseMyHashActions);
d556 1
a556 1
	HashBaseMap::iterator HashBaseIt = g_eMuleApp.m_pClientList->m_mapHashBase.find(qwIPPortID);
d558 1
a558 1
	if (HashBaseIt != g_eMuleApp.m_pClientList->m_mapHashBase.end())
d563 2
a564 2
			InterlockedIncrement(&g_eMuleApp.m_lTotalNumUnfairActions);
			InterlockedIncrement(&g_eMuleApp.m_lTotalNumHashChangeActions);
d568 1
a568 1
	 g_eMuleApp.m_pClientList->m_mapHashBase[qwIPPortID] = qwNewHashID;
d574 2
a575 2
		InterlockedIncrement(&g_eMuleApp.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_eMuleApp.m_lTotalNumStolenNameActions);
d579 1
a579 1
		&& g_eMuleApp.m_pGlobPrefs->IsCounterMeasures())
d587 2
a588 2
		g_eMuleApp.m_pClientList->m_mapOffenseCounter[qwIPPortID] = dwUnfairClientActions + dwNewUnfairActions;
		g_eMuleApp.m_lTotalNumUnfairClients = g_eMuleApp.m_pClientList->m_mapOffenseCounter.size();
d627 1
a627 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d654 1
a654 1
		tagWr.WriteToFile(ET_UDPPORT, g_eMuleApp.m_pGlobPrefs->GetUDPPort(), packetStream);
d661 1
a661 1
		tagWr.WriteToFile(ET_FEATURES, (uint32)(g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0), packetStream);
d671 1
a671 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d878 1
a878 1
		OffenseCounterMap::iterator OffenseCounterIt = g_eMuleApp.m_pClientList->m_mapOffenseCounter.find(qwIPPortID);
d880 1
a880 1
		if (OffenseCounterIt != g_eMuleApp.m_pClientList->m_mapOffenseCounter.end())
d885 4
a888 4
		InterlockedIncrement(&g_eMuleApp.m_lTotalNumUnfairActions);
		InterlockedIncrement(&g_eMuleApp.m_lTotalNumLeecherTypeActions);
		g_eMuleApp.m_pClientList->m_mapOffenseCounter[qwIPPortID] = dwUnfairClientActions;
		g_eMuleApp.m_lTotalNumUnfairClients = g_eMuleApp.m_pClientList->m_mapOffenseCounter.size();
d905 1
a905 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d919 1
a919 1
	md4cpy(hash, g_eMuleApp.m_pGlobPrefs->GetUserHash());
d925 1
a925 1
	if (GetClientSoft() == SO_MLDONKEY && g_eMuleApp.m_pGlobPrefs->IsCounterMeasures())
d939 1
a939 1
	uint32		dwClientID = g_eMuleApp.m_pServerConnect->GetClientID();
d944 1
a944 1
	uint16		nPort = g_eMuleApp.m_pGlobPrefs->GetListenPort();
d952 1
a952 1
	g_eMuleApp.m_pGlobPrefs->WritePreparedNameTag(packetStream);		// { NAME : int }
d954 1
a954 1
	tagWr.WriteToFile(CT_EMULE_UDPPORTS, g_eMuleApp.m_pGlobPrefs->GetUDPPort(), packetStream);
d957 2
a958 2
	const uint32	dwSupportSecIdent = (g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0);
	const uint32	dwNoViewSharedFiles = ((g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_NOONE) ? 1 : 0); // for backward compatibility this has to be a 'negative' flag
d979 1
a979 1
	if (g_eMuleApp.m_pServerConnect->IsConnected())
d981 1
a981 1
		CServer	*pCurServer = g_eMuleApp.m_pServerConnect->GetCurrentServer();
d1013 1
a1013 1
			CString strList(g_eMuleApp.m_pGlobPrefs->GetCommentFilter().MakeLower());
d1060 1
a1060 1
	if (g_eMuleApp.m_pClientList->IsValidClient(this))
d1064 1
a1064 1
			g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this, ETS_DISCONNECT);
d1080 1
a1080 1
		ASSERT(g_eMuleApp.m_pClientList->IsValidClient(this));
d1133 1
a1133 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.ConnectingResult(this, false);
d1136 1
a1136 1
		g_eMuleApp.m_pListenSocket->DeleteSocket(m_pRequestSocket);
d1146 1
a1146 1
			g_eMuleApp.m_pFriendList->RefreshFriend(m_pFriend);
d1156 1
a1156 1
			g_eMuleApp.m_pClientList->UpdateClient(this);
d1173 1
a1173 1
	if ((g_eMuleApp.m_pListenSocket->TooManySockets() && !bIgnoreMaxCon) && !(m_pRequestSocket != NULL && m_pRequestSocket->IsConnected()))
d1185 1
a1185 1
		if (g_eMuleApp.m_pIPFilter->IsFiltered(m_dwUserIP))
d1187 1
a1187 1
			if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d1190 1
a1190 1
								 GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit() );
d1194 2
a1195 2
			InterlockedIncrement(&g_eMuleApp.m_lOutgoingFiltered);
			InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);
d1206 1
a1206 1
			if (g_eMuleApp.m_pIPFilter->IsFiltered(m_dwUserID))
d1208 1
a1208 1
				if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d1210 1
a1210 1
									 GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit() );
d1212 2
a1213 2
				InterlockedIncrement(&g_eMuleApp.m_lOutgoingFiltered);
				InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);
d1220 1
a1220 1
	if (g_eMuleApp.m_pServerConnect->IsLowID() && HasLowID())
d1274 1
a1274 1
		if (g_eMuleApp.m_pServerConnect->IsLocalServer(m_dwServerIP, m_uServerPort))
d1279 2
a1280 2
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
			g_eMuleApp.m_pServerConnect->SendPacket(pPacket);
d1288 1
a1288 1
				g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d1330 1
a1330 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.ConnectingResult(this, true);
d1367 1
a1367 1
			if (g_eMuleApp.m_pUploadQueue->IsDownloading(this))
d1373 1
a1373 1
				g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1389 1
a1389 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d1654 1
a1654 1
		g_eMuleApp.m_pSearchList->ProcessSharedFileListAnswer(pachPacket, dwSize, this, strDirectory, bFirstDir);
d1666 1
a1666 1
	CKnownFile *pReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(this->m_reqFileHash);
d1707 1
a1707 1
	if (g_eMuleApp.m_pIP2Country->IsIP2Country())
d1714 1
a1714 1
	CServer *pServer = g_eMuleApp.m_pServerList->GetServerByIP(GetServerIP(), GetServerPort());
d1746 1
a1746 1
		CKnownFile *m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(this->m_reqFileHash);
d1759 1
a1759 1
	return g_eMuleApp.m_pdlgEmule->m_clientImgLists[CLIENT_IMGLST_PLAIN].ExtractIcon(GetClientIconIndex());
d1780 1
a1780 1
	if (!g_eMuleApp.m_pClientCreditList->CryptoAvailable())
d1783 1
a1783 1
	Packet		*pPacket = new Packet(OP_PUBLICKEY, g_eMuleApp.m_pClientCreditList->GetPubKeyLen() + 1, OP_EMULEPROT);
d1785 3
a1787 3
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
	memcpy2(pPacket->m_pcBuffer + 1, g_eMuleApp.m_pClientCreditList->GetPublicKey(), g_eMuleApp.m_pClientCreditList->GetPubKeyLen());
	pPacket->m_pcBuffer[0] = g_eMuleApp.m_pClientCreditList->GetPubKeyLen();
d1807 1
a1807 1
	if (!g_eMuleApp.m_pClientCreditList->CryptoAvailable())
d1836 1
a1836 1
		if (g_eMuleApp.m_pServerConnect->GetClientID() == 0 || g_eMuleApp.m_pServerConnect->IsLowID())
d1844 1
a1844 1
			ChallengeIP = g_eMuleApp.m_pServerConnect->GetClientID();
d1850 1
a1850 1
	byte		siglen = g_eMuleApp.m_pClientCreditList->CreateSignature(m_pCredits, achBuffer, 250, ChallengeIP, byteChallengeIPKind);
d1859 1
a1859 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d1875 1
a1875 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T(__FUNCTION__) _T(": Receiving public key from '%s'"), m_strUserName));
d1886 1
a1886 1
	if (!g_eMuleApp.m_pClientCreditList->CryptoAvailable())
d1944 1
a1944 1
	if (!g_eMuleApp.m_pClientCreditList->CryptoAvailable())
d1967 1
a1967 1
	if (g_eMuleApp.m_pClientCreditList->VerifyIdent(m_pCredits, pbytePacket + 1, byteSigLen, GetIP(), byteChallengeIPKind))
d1988 1
a1988 1
		if (g_eMuleApp.m_pClientCreditList->CryptoAvailable())
d2018 1
a2018 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d2075 1
a2075 1
	return g_eMuleApp.m_pIP2Country->GetCountryNameByIndex(m_uUserCountryIdx);
d2080 1
a2080 1
	m_uUserCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
@


1.329
log
@Unicode corrections {KuSh}.
@
text
@a56 1
	m_iSourcesSlot = m_dwUserID % SOURCESSLOTS;
a169 1
	m_iSourcesSlot = 0;
a1094 1
			case DS_TOOMANYCONNS:
d1340 10
@


1.328
log
@Improved LowID users handling in waiting queue to minimize unfare waiting time.
@
text
@a1219 6
		else
		{
		//	case 3: it's a LowID without known IP, cannot test yet
		//	AddDebugLogLine( RGB_LOG_DIMMED + _T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"),
		//					 __FUNCTION__, m_dwUserID,m_dwUserIP,GetFullIP() );
		}
d1763 1
a1763 1
	DEBUG_ONLY(AddDebugLogLine(_T("%s: Sending public key to '%s'"), __FUNCTION__, m_strUserName));
d1807 1
a1807 2

	DEBUG_ONLY(AddDebugLogLine(_T("%s: Sending signature key to '%s'"), __FUNCTION__, m_strUserName));
d1868 1
a1868 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("%s: Receiving public key from '%s'"), __FUNCTION__, m_strUserName));
d1905 1
a1905 1
	DEBUG_ONLY(AddDebugLogLine(_T("%s: Receiving signature from '%s'"), __FUNCTION__, m_strUserName));
d1996 1
a1996 1
			DEBUG_ONLY(AddDebugLogLine(_T("%s: Not sending SecIdentState Packet, because State is Zero"), __FUNCTION__));
d2006 1
a2006 1
		DEBUG_ONLY(AddDebugLogLine(_T("%s: Sending SecIdentState packet, state: %i (to '%s')"), __FUNCTION__, byteValue, m_strUserName));
d2047 1
a2047 1
	DEBUG_ONLY(AddDebugLogLine(_T("%s: Received SecIdentState Packet, state: %i"), __FUNCTION__, pbytePacket[0]));
@


1.327
log
@One more step to integrate eklmn's SSDQ.
@
text
@d153 1
@


1.326
log
@A correction to avoid recursive display of CompatID.
@
text
@a152 1
	m_fIsLastDownloadRequestTCP = 0;
@


1.325
log
@Mark new emule compatible clients with 'CompatID #'.
@
text
@d1464 1
a1464 3
					if (!m_strModString.IsEmpty())
						m_strModString += _T('/');
					m_strModString.AppendFormat(_T("CompatID %u"), m_byteCompatibleClient);
@


1.324
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1464 3
a1466 2
					AddDebugLogLine( _T("New Compatible ClientSoft %u (%s) - listed as eMule"),
									 m_byteCompatibleClient, HashToString(m_userHash) );
@


1.323
log
@One more step to integrate eklmn's SSDQ.
@
text
@d119 1
a119 1
	m_dwLastAskedTime = 0;
@


1.322
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1100 1
@


1.321
log
@Added some minor stuff from new eklmn's changes.
@
text
@d1227 2
a1228 2
//	If we both have Low IDs...
	if ((g_eMuleApp.m_pServerConnect->GetClientID() < 0x1000000) && HasLowID())
a1230 1
		{
a1231 6
		}
		else if (GetDownloadState() == DS_REQHASHSET)
		{
			SetDownloadState(DS_ONQUEUE);
			m_pReqPartFile->m_bHashSetNeeded = true;
		}
d1233 1
a1233 3
		{
			Disconnected(false);
		}
d1235 1
@


1.320
log
@One more step to integrate eklmn's SSDQ.
@
text
@d108 1
d153 1
@


1.319
log
@The second step to integrate eklmn's SSDQ.
@
text
@d105 1
@


1.318
log
@new way of queue handling
@
text
@d41 1
a41 1
	m_pReqPartFile = NULL;
d70 1
a70 1
	m_pReqPartFile = pReqPartFile;
@


1.317
log
@download log (part1: without GUI)
@
text
@a144 1
	m_fReceivedQR = 0;
@


1.316
log
@1. QR highlighting
2. output "Queue Full" if eMule client did not send QR
3. possible download abort
@
text
@d121 1
@


1.315
log
@Display proper lphant version.
@
text
@d144 1
a144 1
	m_bRemoteQueueFull = false;
@


1.314
log
@flood protection against block request packets
@
text
@d1508 3
d1526 1
a1526 1
				else if ((m_eClientSoft == SO_AMULE) || (dwUpdVer != 0))
@


1.313
log
@Proper detection of new Hybrid versions.
@
text
@d90 1
@


1.312
log
@Added a space between username and software.
@
text
@d295 1
a295 1
	bool			bCrashed = false;
d416 6
d447 3
a449 2
//	Hybrid now has an extra uint32.. What is it for?
//	Also, many clients seem to send an extra 6? These are not eDonkeys or Hybrids..
a459 1
		{
a460 2
			m_fSupportsAskSharedDirs = 1;
		}
d509 8
a589 3
//	Check if at least CT_EMULEVERSION was received, all other tags are optional
	bool bIsMule = ((dwEmuleTags & 0x04) == 0x04);

d1550 1
@


1.311
log
@Added initialization of the new statistics variable;
Faster remote client name handling; Unified way to display client name and version;
Improved string processing.
@
text
@d2122 1
a2122 1
	strBuf.Format(_T("'%s'(%s)"), m_strUserName, m_strClientSoft);
@


1.310
log
@Optimized GetCurrentServer() calls (cache value for consecutive usage).
@
text
@d149 1
d803 1
a803 1
	catch (CException* error)
d807 2
a808 2
		AddDebugLogLine( _T("Error while processing emuletag %u/%u from client '%s' (%s) %s:%u"), i + 1,
						 dwTagCount, GetUserName(), GetClientNameAndVersionString(), GetFullIP(), GetUserPort() );
d1130 1
a1130 1
			AddLogLine(true, IDS_SHAREDFILES_FAILED, GetUserName());
d1623 1
a1623 1
		AddLogLine(true, IDS_SHAREDFILES_REQUEST, GetUserName());
d1629 1
a1629 1
		AddLogLine(true, IDS_SHAREDFILES_INPROGRESS, GetUserName(), GetUserID());
d1659 1
a1659 1
	strInfo.Format(GetResString(IDS_USERINFO), GetUserName(), GetUserID());
d1692 1
a1692 1
	CString		strCountry, strUserName = GetUserName();
d1700 1
a1700 1
	strInfo.Format(_T("<t=1><b>%s</b><br><t=1>%s: %u%s<br><hr=100%%><br><b>%s:<t></b>%s:%d (<b>%s</b>)"),
d1702 1
a1702 1
		GetResString(IDS_CLIENT), GetFullIP(), GetUserPort(), GetClientNameAndVersionString());
d1760 1
a1760 1
	DEBUG_ONLY(AddDebugLogLine(_T("%s: Sending public key to '%s'"), __FUNCTION__, GetUserName()));
d1805 1
a1805 1
	DEBUG_ONLY(AddDebugLogLine(_T("%s: Sending signature key to '%s'"), __FUNCTION__, GetUserName()));
d1810 1
a1810 1
		AddDebugLogLine(_T("Client '%s' want to send signature but challenge value is invalid"), GetUserName());
d1866 1
a1866 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("%s: Receiving public key from '%s'"), __FUNCTION__, GetUserName()));
d1891 1
a1891 1
							 GetUserName() );
d1896 1
a1896 1
		AddDebugLogLine(_T("Client '%s' failed to use new received public key"), GetUserName());
d1903 1
a1903 1
	DEBUG_ONLY(AddDebugLogLine(_T("%s: Receiving signature from '%s'"), __FUNCTION__, GetUserName()));
d1942 1
a1942 1
		AddDebugLogLine(_T("Received multiple signatures from client %s (%s)"), GetUserName(), GetClientNameAndVersionString());
d1948 1
a1948 1
		AddDebugLogLine(_T("Received signature for client %s (%s) without public key"), GetUserName(), GetClientNameAndVersionString());
d1954 1
a1954 1
		AddDebugLogLine(_T("Received signature for client %s (%s) with invalid challenge value"), GetUserName(), GetClientNameAndVersionString());
d1965 1
a1965 1
		AddDebugLogLine(_T("Client '%s' (%s) has failed the secure identification, V2 State: %i"), GetUserName(), GetClientNameAndVersionString(), byteChallengeIPKind);
d2004 1
a2004 1
		DEBUG_ONLY(AddDebugLogLine(_T("%s: Sending SecIdentState packet, state: %i (to '%s')"), __FUNCTION__, byteValue, GetUserName()));
d2113 1
a2113 1
CString CUpDownClient::GetClientNameAndVersionString() const
d2117 8
@


1.309
log
@Removed unused code.
@
text
@d969 4
a972 2
		dwIP = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP();
		nPort = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetPort();
@


1.308
log
@Changed tag interface to avoid memory leaks which could be possible with
new tag object structure.
@
text
@d1235 1
a1235 1
		m_pRequestSocket = new CClientReqSocket(g_eMuleApp.m_pGlobPrefs, this);
d1245 1
a1245 1
		m_pRequestSocket = new CClientReqSocket(g_eMuleApp.m_pGlobPrefs, this);
@


1.307
log
@Better way to prepare user name tag; Remove caching of version tag.
@
text
@d298 1
a298 1
		CTag	TempTag(packetStream);
d300 1
d725 1
a725 1
			CTag	TempTag(packetStream);
d727 1
@


1.306
log
@Fixed friend last seen time value update (the value was set only on addition);
More correct way to update friend parameters.
@
text
@d934 1
a934 10
	uint32		dwTagCount = 3;

	if (g_eMuleApp.m_pGlobPrefs->m_pNameTag != NULL)
	{
		dwTagCount++;
		if (g_eMuleApp.m_pGlobPrefs->m_pVersionTag != NULL)
		{
			dwTagCount++;
		}
	}
d938 2
a939 8
	if (g_eMuleApp.m_pGlobPrefs->m_pNameTag != NULL)
	{
		g_eMuleApp.m_pGlobPrefs->m_pNameTag->WriteToFile(packetStream);				// { NAME : int }
		if (g_eMuleApp.m_pGlobPrefs->m_pVersionTag != NULL)
		{
			g_eMuleApp.m_pGlobPrefs->m_pVersionTag->WriteToFile(packetStream);		// { VERSION : int }
		}
	}
@


1.305
log
@Optimized parameter tag processing (preparation and parsing);
Changed remote user port reading in Hello packet.
@
text
@d197 2
a198 5
	{
		m_pFriend->m_pLinkedClient = NULL;
		g_eMuleApp.m_pFriendList->RefreshFriend(m_pFriend);
		m_pFriend = NULL;
	}
d353 1
d392 6
a488 1

d492 3
a494 1
		if (m_pFriend->m_pLinkedClient)
d496 1
a496 19
			if (m_pFriend->m_pLinkedClient != this)
			{
			//	Avoid that an unwanted client instance keeps a friend slot
				m_pFriend->m_pLinkedClient->m_pFriend = NULL;
				m_pFriend->m_pLinkedClient = this;
			}
		}
		else
		{
			m_pFriend->m_pLinkedClient = this;
			m_pFriend->m_dwHasHash = 1;
			md4cpy(m_pFriend->m_abyUserhash, GetUserHash());
			m_pFriend->m_strName = m_strUserName;
			m_pFriend->m_dwLastUsedIP = m_dwUserIP;
			m_pFriend->m_nLastUsedPort = m_uUserPort;
			g_eMuleApp.m_pFriendList->RefreshFriend(m_pFriend);
			if (m_eChatState == MS_CONNECTING)
			{
				TCITEM		tcNewItem;
d498 3
a500 4
				tcNewItem.mask = TCIF_TEXT;
				tcNewItem.pszText = m_strUserName.GetBuffer(256);
				g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.SetItem(g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.GetTabByClient(this), &tcNewItem);
			}
@


1.304
log
@Preparations and minor corrections for new tag processing.
@
text
@d287 1
d294 1
a294 1
	packetStream.Read(&m_uUserPort, 2);
a297 2
	bool			bWrongPort = false;
	CClientTag	   *pTempTag = NULL;
d301 3
a303 2
		pTempTag = new CClientTag(packetStream);
		switch (pTempTag->GetTagID())
d306 1
a306 8
			{
				if (pTempTag->GetStringValue().IsEmpty())
				{
					bCrashed = true;

					m_strUserName = _T("[Invalid user name]");
				}
				else
d308 1
a308 1
					if (m_strUserName != pTempTag->GetStringValue())
d310 6
a315 2
						m_strUserName.SetString(pTempTag->GetStringValue(), pTempTag->GetStringValue().GetLength());
						m_byteActionsOnNameChange |= AONC_FORBIDDEN_NAME_CHECK | AONC_COMMUNITY_CHECK;
d318 2
d321 1
a321 1
			}
d323 2
a324 2
			{
				m_dwClientVersion = pTempTag->GetIntValue();
d326 1
a326 1
			}
d328 2
a329 6
			{
			//	morevit: What does the hybrid use this port tag for if not the user port?
				if (pTempTag->GetIntValue() != m_uUserPort && GetClientSoft() != SO_EDONKEYHYBRID)
				{
					bWrongPort = true;
				}
d331 1
a331 1
			}
d333 1
a333 2
			{
				if (m_strModString != pTempTag->GetStringValue())
d335 5
a339 2
					m_strModString = pTempTag->GetStringValue();
					m_bIsMODNameChanged = true;
d341 4
d346 1
a346 1
			}
d350 5
a354 2
				m_uUDPPort = static_cast<uint16>(pTempTag->GetIntValue());
				dwEmuleTags |= 1;
a356 1
			{
d369 3
a371 1
				uint32	dwOpt = pTempTag->GetIntValue();
d373 16
a388 16
				dwOpt >>= 2;	//skip Preview & MultiPacket
				m_fNoViewSharedFiles = dwOpt & 0x01;
				dwOpt >>= 1;
				dwOpt >>= 1;	//skip PeerChache
				m_byteAcceptCommentVer = dwOpt & 0x0F;
				dwOpt >>= 4;
				m_byteExtendedRequestsVer = dwOpt & 0x0F;
				dwOpt >>= 4;
				m_byteSourceExchangeVer = dwOpt & 0x0F;
				dwOpt >>= 4;
				m_byteSupportSecIdent = dwOpt & 0x0F;
				dwOpt >>= 4;
				m_byteDataCompVer = dwOpt & 0x0F;
				dwOpt >>= 4;
				m_byteUDPVer = dwOpt & 0x0F;
				dwOpt >>= 4;
d390 2
a391 1
				dwEmuleTags |= 2;
d393 1
a393 1
			}
d400 1
a400 50
				m_dwClientVersion = pTempTag->GetIntValue();
				m_byteCompatibleClient = (m_dwClientVersion >> 24);
				m_dwClientVersion &= 0x00FFFFFF;
				m_byteEmuleVersion = 0x99;
				m_fSupportsAskSharedDirs = 1;
				dwEmuleTags |= 4;
				break;
			case CT_EMULE_RESERVED1:
			case CT_EMULE_RESERVED2:
			case CT_EMULE_RESERVED3:
			case CT_EMULE_RESERVED4:
			case CT_EMULE_RESERVED5:
			case CT_EMULE_RESERVED6:
			case CT_EMULE_RESERVED7:
			case CT_EMULE_RESERVED8:
			case CT_EMULE_RESERVED9:
			case CT_EMULE_RESERVED10:
			case CT_EMULE_RESERVED11:
			case CT_EMULE_RESERVED12:
			case CT_EMULE_RESERVED13:
			case CT_FRIENDSHARING:
			case CT_UNKNOWNx0:
			case CT_UNKNOWNx12:
			case CT_UNKNOWNx13:
			case CT_UNKNOWNx14:
			case CT_UNKNOWNx15:
			case CT_UNKNOWNx16:
			case CT_UNKNOWNx17:
			case CT_UNKNOWNx22:
			case CT_UNKNOWNx3c:
			case CT_UNKNOWNx3d:
			case CT_UNKNOWNx63:
			case CT_UNKNOWNx64:
			case CT_UNKNOWNx68:
			case CT_UNKNOWNx69:
			case CT_UNKNOWNx84:
			case CT_UNKNOWNx85:
			case CT_UNKNOWNx86:
			case CT_UNKNOWNx87:
			case CT_UNKNOWNx88:
			case CT_UNKNOWNx8c:
			case CT_UNKNOWNx8d:
			case CT_UNKNOWNx94:
			case CT_UNKNOWNx99:
			case CT_UNKNOWNxbb:
				break;
			default:
			{
#ifdef _DEBUG
				if (!pTempTag->GetStringValue().IsEmpty())
d402 6
a407 2
					CString buffer = pTempTag->GetStringValue();
					TagToDebugLogLine(RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), pTempTag->GetTagID());
d409 1
a409 5
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag for client '%s': %#x, Intvalue: %d Stringvalue: %s, (client version: %u)"),
				                 m_strUserName, static_cast<int>(pTempTag->GetTagID()), pTempTag->GetIntValue(),
				    			 pTempTag->GetStringValue(), m_dwClientVersion );
#endif
			}
a410 2
		delete pTempTag;
		pTempTag = NULL;
d412 1
a452 13
#ifdef OLD_SOCKETS_ENABLED
//	If the client sent a mismatched user port tag and it's not a hybrid...
	if (bWrongPort && !m_bIsHybrid)
	{
		CString		ip_addr;
		UINT		port;

		m_pRequestSocket->GetPeerName(ip_addr, port);
		AddDebugLogLine( _T("Client '%s' (version: %d|IP: %s) sent an incorrect user port. Using %d instead."),
						 m_strUserName, m_dwClientVersion, ip_addr, m_uUserPort );
	}
#endif //OLD_SOCKETS_ENABLED

d648 2
a649 1
		uint32 dwTagCount = 10;
d653 10
a662 20
		CEmuleTag tag1(ET_COMPRESSION, 1);
		tag1.WriteToFile(packetStream);
		CEmuleTag tag2(ET_UDPVER, 4);
		tag2.WriteToFile(packetStream);
		CEmuleTag tag3(ET_UDPPORT, g_eMuleApp.m_pGlobPrefs->GetUDPPort());
		tag3.WriteToFile(packetStream);
		CEmuleTag tag4(ET_SOURCEEXCHANGE, 2);
		tag4.WriteToFile(packetStream);
		CEmuleTag tag5(ET_COMMENTS, 1);
		tag5.WriteToFile(packetStream);
		CEmuleTag tag6(ET_MOD_PLUS, CURRENT_PLUS_VERSION);
		tag6.WriteToFile(packetStream);
		CEmuleTag tag7(ET_EXTENDEDREQUEST, 2);
		tag7.WriteToFile(packetStream);
		CEmuleTag tag8(ET_MOD_VERSION, _T(PLUS_VERSION_STR));
		tag8.WriteToFile(packetStream);
		CEmuleTag tag9(ET_L2HAC, FILEREASKTIME);
		tag9.WriteToFile(packetStream);
		CEmuleTag tag10(ET_FEATURES, (uint32)(g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0));
		tag10.WriteToFile(packetStream);
a732 1
	CEmuleTag* pTempTag = NULL;
d738 3
a740 2
			pTempTag = new CEmuleTag(packetStream);
			if (pTempTag != NULL)
d742 39
a780 40
				switch (pTempTag->GetTagID())
				{
					case ET_COMPRESSION:
					{
						m_byteDataCompVer = pTempTag->GetIntValue();
						break;
					}
					case ET_UDPPORT:
					{
						m_uUDPPort = pTempTag->GetIntValue();
						break;
					}
					case ET_UDPVER:
					{
						m_byteUDPVer = pTempTag->GetIntValue();
						break;
					}
					case ET_SOURCEEXCHANGE:
					{
						m_byteSourceExchangeVer = pTempTag->GetIntValue();
						break;
					}
					case ET_COMMENTS:
					{
						m_byteAcceptCommentVer = pTempTag->GetIntValue();
						break;
					}
					case ET_EXTENDEDREQUEST:
					{
						m_byteExtendedRequestsVer = pTempTag->GetIntValue();
						break;
					}
					case ET_COMPATIBLECLIENT:
					{
					//	Bits 31- 8: 0 - reserved
					//	Bits  7- 0: compatible client ID
						m_byteCompatibleClient = pTempTag->GetIntValue();
						break;
					}
					case ET_MOD_VERSION:
d782 1
a782 1
						if (m_strModString != pTempTag->GetStringValue())
d784 1
a784 1
							m_strModString = pTempTag->GetStringValue();
a786 1
						break;
d788 23
a810 77
					case ET_MOD_PLUS:
					{
						m_dwPlusVers = pTempTag->GetIntValue();
						break;
					}
					case ET_MOD_TAROD:
					case ET_MOD_BOWLFISH:
					case ET_MOD_TAROD_VERSION:
					case ET_MOD_FUSION:
					case ET_MOD_FUSION_VERSION:
					case ET_MOD_Morph:
					case ET_MOD_Morph_VERSION:
					case ET_MOD_MorTillo:
					case ET_MOD_MorTillo_VERSION:
					case ET_MOD_LSD:
					case ET_MOD_LSD_VERSION:
					case ET_MOD_LOVELACE_VERSION:
					case ET_MOD_OXY:
					case ET_MOD_UNKNOWNx12:
					case ET_MOD_UNKNOWNx13:
					case ET_MOD_UNKNOWNx14:
					case ET_MOD_UNKNOWNx17:
					case ET_MOD_UNKNOWNx2F:
					case ET_MOD_UNKNOWNx30:
					case ET_MOD_UNKNOWNx36:
					case ET_MOD_UNKNOWNx3C:
					case ET_MOD_UNKNOWNx41:
					case ET_MOD_UNKNOWNx42:
					case ET_MOD_UNKNOWNx43:
					case ET_MOD_UNKNOWNx50:
					case ET_MOD_UNKNOWNx59:
					case ET_MOD_UNKNOWNx5B:
					case ET_MOD_UNKNOWNx5C:
					case ET_MOD_UNKNOWNx60:
					case ET_MOD_UNKNOWNx64:
					case ET_MOD_UNKNOWNx76:
					case ET_MOD_UNKNOWNx84:
					case ET_MOD_UNKNOWNx85:
					case ET_MOD_UNKNOWNx86:
					case ET_MOD_UNKNOWNx91:
					case ET_MOD_UNKNOWNx92:
					case ET_MOD_UNKNOWNx93:
					case ET_MOD_UNKNOWNxA0:
					case ET_MOD_UNKNOWNxA1:
					case ET_MOD_UNKNOWNxA6:
					case ET_MOD_UNKNOWNxB1:
					case ET_MOD_UNKNOWNxB4:
					case ET_MOD_UNKNOWNxC8:
					case ET_MOD_UNKNOWNxC9:
					case ET_MOD_UNKNOWNxDA:
					case ET_INCOMPLETEPARTS:
					{
						break;
					}
					case ET_L2HAC:
					{
						m_dwL2HACTime = pTempTag->GetIntValue();
						break;
					}
					case ET_FEATURES:
					{
					//	Bits 31- 8: 0 - reserved
					//	Bit      7: Preview
					//	Bit   6- 0: secure identification
						m_byteSupportSecIdent = pTempTag->GetIntValue() & 3;
						break;
					}
					default:
					{
						if (!pTempTag->GetStringValue().IsEmpty())
						{
						//	Nothing to do for now...
						}
					}
				}
				delete pTempTag;
				pTempTag = NULL;
a816 1
		safe_delete(pTempTag);
d917 1
d969 1
a969 2
	CClientTag tag3(CT_EMULE_UDPPORTS, g_eMuleApp.m_pGlobPrefs->GetUDPPort()); 
	tag3.WriteToFile(packetStream);
d974 1
a974 1
	CClientTag tag4( CT_EMULE_MISCOPTIONS1,
d981 1
a981 2
		(dwNoViewSharedFiles	<< 1*2) );	//No 'View Shared Files' supported
	tag4.WriteToFile(packetStream);
d986 2
a987 3
	CClientTag tag5( CT_EMULE_VERSION, (PLUS_COMPATIBLECLIENTID << 24) | ((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
		((CURRENT_PLUS_VERSION & 0xF0) << 6) | ((CURRENT_PLUS_VERSION & 0x7) << 7) );
	tag5.WriteToFile(packetStream);
@


1.303
log
@Extended log line.
@
text
@d303 1
a303 1
		switch (pTempTag->GetSpecialTag())
d446 1
a446 1
					TagToDebugLogLine(RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), pTempTag->GetSpecialTag());
d449 1
a449 1
				                 m_strUserName, static_cast<int>(pTempTag->GetSpecialTag()), pTempTag->GetIntValue(),
d808 1
a808 1
				switch (pTempTag->GetSpecialTag())
@


1.302
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d1607 2
a1608 2
					AddDebugLogLine( _T("New Compatible ClientSoft ET_COMPATIBLECLIENT=%u client will be listed as eMule"),
									 m_byteCompatibleClient );
@


1.301
log
@Add sources possibly received from global search (official).
Added missing translations in case countryflag.dll / ip-to-country.cvs is not found.
Notifier informs if a new version is available (not annoying, but still more likely
 to be noticed than just a log line).
Added 'Folder' column to Shared files window.
Prevent adding install/working dirs (\Webserver, \Db...) to Shared files.
+ some other minor changes/fixes.
@
text
@d464 2
a465 2
	//	... and server IP is valid (fast check) and the server isn't already in our server list
		if ((m_dwServerIP != 0) && !g_eMuleApp.m_pServerList->GetServerByIP(m_dwServerIP, m_uServerPort))
d560 1
a560 1
			m_pFriend->m_strName.Format(_T("%s"), m_strUserName);
@


1.300
log
@sorted "UpDownClient.h"; removed unused variables
@
text
@d237 1
@


1.299
log
@Removed unused code.
@
text
@a80 2
	m_dwAvgDownDataRate = 0;
	m_dwAvgUpDataRate = 0;
a87 1
	m_dwMaxSendAllowed = 0;
@


1.298
log
@Removed unrequired cleanup as it will be done in the consequent member destructor.
@
text
@a148 1
	m_bIsHashThief = false;
a597 1
		m_bIsHashThief = true;
d615 1
a615 1
	if (HashBaseIt !=  g_eMuleApp.m_pClientList->m_mapHashBase.end())
d617 1
a617 1
		if ( HashBaseIt->second != qwNewHashID)
a618 1
			m_bIsHashThief = true;
a629 1
		m_bIsHashThief = true;
@


1.297
log
@Minor fix for Old eMule detection as some buggy mods could be assigned to that group.
@
text
@a236 1
	m_averageDLDataRateList.clear();
@


1.296
log
@improved processing of user name & mod string
@
text
@d1583 7
a1589 4
			m_eClientSoft = SO_OLDEMULE;
			m_strClientSoft.Format(_T("%s v0.%u"), GetResString(IDS_OLDEMULE), m_dwClientVersion);
			m_dwClientVersion = FORM_CLIENT_VER(0, m_dwClientVersion, 0);
			break;
@


1.295
log
@Removed non-working code (reducing of used memory); One more rare used bit is added to bit field.
@
text
@d184 1
a184 1
	m_bIsUserNameChanged = false;
d322 1
a322 1
						m_bIsUserNameChanged = true;
d2229 1
a2229 1
	if (m_bIsUserNameChanged)
d2232 2
d2244 2
@


1.294
log
@New eMule Plus identification;
Updated eMule protocol up to version 0.4x (original);
Inform a remote client when 'See my share = No one' to save traffic (original);
Reduced memory used during packet creation;
Correction for rare Hybrid version representation.
@
text
@a148 4
	m_dwRemoteScore = 0;
	m_uRemoteRatio = 0;
	m_uRemoteBaseModifier = 0;
	m_bRemoteInfoAvailable = false;
d152 1
a172 1
	m_bSupportsAskSharedDirs = false;
d258 1
a258 1
	m_bSupportsAskSharedDirs = false;
d402 1
a402 1
				m_bSupportsAskSharedDirs = true;
d497 1
a497 1
			m_bSupportsAskSharedDirs = true;
d799 1
a799 1
		m_bSupportsAskSharedDirs = true;
d988 1
a988 1
		m_bSupportsAskSharedDirs = false;
d1536 1
a1536 1
		Packet		*pPacket = new Packet(m_bSupportsAskSharedDirs ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES);
@


1.293
log
@Minor corrections.
@
text
@d154 2
a155 1
	m_bRequestingHashSet = false;
d250 17
d269 2
a270 5
	EMULE_TRY

	CSafeMemFile		packetStream(pbytePacket, dwSize);

	byte		byteHashSize;
d273 2
a275 4

	EMULE_CATCH

	return false;
a287 2
	EMULE_TRY

d290 1
d294 1
a294 1
	uint32		dwUserID;
a301 3

	uint32	dwTagCount;

d354 42
d407 1
a407 1
				m_bEmuleProtocol = true;
a417 2
			case CT_EMULE_UDPPORTS:
			case CT_EMULE_MISCOPTIONS1:
d658 3
d662 5
a666 6
	if (m_eInfoPacketsReceived == IP_BOTH)
		InfoPacketsReceived();

	return true;

	EMULE_CATCH
d668 1
a668 1
	return false;
d687 1
a687 1
		CMemFile	packetStream;
d709 1
a709 1
		CMemFile packetStream;
a729 1
	//	To check for eMulePlus
d929 2
a930 1
					//	Bit   7- 0: secure identification
d973 2
a974 3
//	Pre v1 versions had different format, don't consider them as Plus
//	Check minimal existing version
	if ((m_dwPlusVers >= 0x2505) || (m_dwPlusVers < 0x100))
a1000 2
	if (m_eInfoPacketsReceived == IP_BOTH)
		InfoPacketsReceived();
d1003 1
a1003 1
	if ((GetPlusVersion() >= 0x0106) && (GetPlusVersion() < 0x0108) && (GetExtendedRequestsVersion() == 1))
d1035 1
a1035 1
		CMemFile packetStream;
d1081 1
a1081 1
	uint32		dwTagCount = 0;
d1102 22
d1227 1
a1227 1
		if (((GetDownloadState() == DS_REQHASHSET) || m_bRequestingHashSet) && m_pReqPartFile != NULL)
d1307 1
a1307 1
			m_bRequestingHashSet = false;
d1660 2
d1693 1
d1727 6
d2073 1
a2073 3
	BYTE		byteChallengeIPKind;
	BYTE		byteSigLen = pbytePacket[0];
	bool		bClientSupportsSecIdentV2 = (m_byteSupportSecIdent & 2) > 0;
d2081 2
a2082 1
	else if (dwSize == byteSigLen + sizeof(byteSigLen) + sizeof(byteChallengeIPKind) && bClientSupportsSecIdentV2)
@


1.292
log
@Fixed reporting incorrect client version after receiving of incorrect OP_EMULEINFO packet;
Minor correction to properly show old eMulePlus clients (issue was created in 1.290).
@
text
@d2175 1
a2175 1
	int	iImgIdx = GetClientSoft();
d2177 1
a2177 1
	if ((iImgIdx == SO_EMULE) || (iImgIdx == SO_PLUS))
d2180 1
a2180 1
			iImgIdx = SO_OLDEMULE;
d2182 2
a2183 2
	else if (iImgIdx > SO_UNKNOWN)
		iImgIdx = SO_UNKNOWN;
d2185 1
a2185 1
	return iImgIdx;
@


1.291
log
@Minor preparations for new identification.
@
text
@d718 1
a718 1
	byte	byteTmp;
d720 9
a728 1
	packetStream.Read(&byteTmp, 1);
d730 1
a730 1
		m_byteEmuleVersion = byteTmp;
a736 8
	if (m_byteEmuleVersion == 0x2B)
		m_byteEmuleVersion = 0x22;

	packetStream.Read(&byteTmp, 1);

//	Implicitly supported options by older clients
	if (byteTmp != EMULE_PROTOCOL)
		return;
d1567 1
a1567 1
				m_byteEmuleVersion = 0x99;
d1581 5
a1585 6
				if (m_dwPlusVers == 0)
				{
					dwMajVer = (m_dwClientVersion >> 17) & 0x7F;
					dwMinVer = (m_dwClientVersion >> 10) & 0x7F;
					dwUpdVer = (m_dwClientVersion >>  7) & 0x07;
				}
@


1.290
log
@Own client type for eMule Plus clients.
@
text
@d664 1
d666 1
d960 1
a960 1
		((GetMuleVersion() != CURRENT_VERSION_SHORT) || (m_dwPlusVers == 0)) ) )
@


1.289
log
@Faster calculation.
@
text
@d926 6
a931 10
	//	Several old versions didn't have ModString, add it to show them in statistics
		if ((m_dwPlusVers <= 0x103) && (m_byteEmuleVersion <= 0x26) && m_strModString.IsEmpty())
		{
			if (m_dwPlusVers == 0x100)
				m_strModString = _T("Plus 1");
			else
				m_strModString.Format(_T("Plus 1%c"), (char)((m_dwPlusVers & 0x0F) + 'a' - 1));
		}
		if ( (m_strModString.GetLength() > 10) ||
			( (memcmp(m_strModString.GetString(), _T("Plus "), sizeof(_T("Plus ")) - sizeof(TCHAR)) != 0) &&
d945 1
a945 1
	if ((m_dwPlusVers != 0) && (m_eClientSoft != SO_EMULE) && (m_eClientSoft != SO_UNKNOWN))
d1554 1
a1557 1
				m_dwClientVersion = FORM_CLIENT_VER(dwMajVer, dwMinVer, dwUpdVer);
d1559 17
a1575 10
				strClientVer.Format(_T("%u"), dwMajVer);
				if (dwMinVer != 0)
					strClientVer.AppendFormat(_T(".%u"), dwMinVer);
				if (dwUpdVer != 0)
					strClientVer += static_cast<TCHAR>(_T('a') + dwUpdVer - 1);

				if (memcmp(m_strModString.GetString(), _T("Plus"), sizeof(_T("Plus")) - sizeof(TCHAR)) != 0)
					m_strClientSoft.Format(_T("Plus v%s [%s]"), strClientVer, m_strModString);
				else
					m_strClientSoft.Format(_T("Plus v%s"), strClientVer);
d1579 1
a1579 11
				if (m_byteEmuleVersion == 0)
				{
					m_dwClientVersion = FORM_CLIENT_VER(0, 0, 0);
				}
				else if (m_byteEmuleVersion != 0x99)
				{
					dwMinVer = (m_byteEmuleVersion >> 4) * 10 + (m_byteEmuleVersion & 0xF);
					m_dwClientVersion = FORM_CLIENT_VER(0, dwMinVer, 0);
					strClientVer.Format(_T("0.%u"), dwMinVer);
				}
				else
d1584 2
d1587 7
a1593 8
					m_dwClientVersion = FORM_CLIENT_VER(dwMajVer, dwMinVer, dwUpdVer);

					if ((m_eClientSoft == SO_EMULE) && (dwUpdVer < 26))
						strClientVer.Format(_T("%u.%u%c"), dwMajVer, dwMinVer, _T('a') + dwUpdVer);
					else if ((m_eClientSoft == SO_AMULE) || (dwUpdVer != 0))
						strClientVer.Format(_T("%u.%u.%u"), dwMajVer, dwMinVer, dwUpdVer);
					else
						strClientVer.Format(_T("%u.%u"), dwMajVer, dwMinVer);
d1595 4
a1598 2
				if (m_strModString.IsEmpty())
					m_strClientSoft.Format(_T("%s v%s"), GetClientNameString(m_eClientSoft), strClientVer);
d1600 1
a1600 1
					m_strClientSoft.Format(_T("%s v%s [%s]"), GetClientNameString(m_eClientSoft), strClientVer, m_strModString);
d1602 4
d2176 1
a2176 1
	if (iImgIdx == SO_EMULE)
@


1.288
log
@Faster client icons processing.
@
text
@d83 2
a84 2
	m_qwClientSumDLDataRateOverLastNMeasurements = 0;
	m_qwClientSumDLTickOverLastNMeasurements = 0;
@


1.287
log
@Fixed request method of shared file list [KuSh] (problem was created in 1n).
@
text
@d2174 1
a2174 1
	int	iImgIdx;
d2176 1
a2176 1
	switch (GetClientSoft())
d2178 2
a2179 31
		case SO_AMULE:
			iImgIdx = CLIENT_ICON_AMULE;
			break;
		case SO_LMULE:
			iImgIdx = CLIENT_ICON_LMULE;
			break;
		case SO_SHAREAZA:
			iImgIdx = CLIENT_ICON_SHAREAZA;
			break;
		case SO_EDONKEYHYBRID:
			iImgIdx = CLIENT_ICON_EDONKEYHYBRID;
			break;
		case SO_MLDONKEY:
			iImgIdx = CLIENT_ICON_MLDONKEY;
			break;
		case SO_LPHANT:
			iImgIdx = CLIENT_ICON_LPHANT;
			break;
		case SO_EMULE:
		case SO_OLDEMULE:
			if (m_pCredits->GetCurrentIdentState(GetIP()) != IS_IDENTIFIED)
				iImgIdx = CLIENT_ICON_SECUREHASH;
			else
				iImgIdx = CLIENT_ICON_COMPROT;
			break;
		case SO_EDONKEY:
			iImgIdx = CLIENT_ICON_NORMAL;
			break;
		default:
			iImgIdx = CLIENT_ICON_UNKNOWN;
			break;
d2181 3
@


1.286
log
@Finally own icon for lphant.
@
text
@d943 1
a943 1
	if ((m_dwPlusVers != 0) || (m_dwPlusVers < 0x0108))
@


1.285
log
@Completely reworked remote clients version detection;
Fixed sorting of Hybrids by client software; Removed unused code;
Fixed shared directories feature detection for old eMule Plus clients;
Fixed Hybrid version report; Fixed eMule Plus identification; Improved filtering.
@
text
@d2194 2
@


1.284
log
@Removed double initialization.
@
text
@a70 1
	ReGetClientSoft();
d111 3
a113 1
	m_strModVersion.Empty();
d128 1
a128 1
	m_dwDataPlusVers = 0;
a132 1
	m_byteDataTarodVer = 0;
d136 1
a136 1
	m_dwCompatibleClient = 0;
d338 1
a338 1
				if (m_strModVersion != pTempTag->GetStringValue())
d340 1
a340 1
					m_strModVersion = pTempTag->GetStringValue();
d345 13
a368 1
			case CT_EMULE_VERSION:
d407 1
a407 1
				AddDebugLogLine( RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag for client '%s': 0x%x, Intvalue: %d Stringvalue: %s, (client version: %d)"),
d476 1
a476 1
	m_pRequestSocket->GetPeerName((SOCKADDR*) & sockAddr, (int*) & dwSockAddrLen);
d712 1
d714 13
a726 2
	m_dwCompatibleClient = 0;
	packetStream.Read(&m_byteEmuleVersion, 1);
d729 2
a730 2
	byte protversion;
	packetStream.Read(&protversion, 1);
d733 2
a734 18
	if (protversion == EMULE_PROTOCOL)
	{
	//	In the future do not use version to guess about new features
		if (m_byteEmuleVersion < 0x25 && m_byteEmuleVersion > 0x22)
			m_byteUDPVer = 1;

		if (m_byteEmuleVersion < 0x25 && m_byteEmuleVersion > 0x21)
			m_byteSourceExchangeVer = 1;

		if (m_byteEmuleVersion == 0x24)
			m_byteAcceptCommentVer = 1;

	//	Shared directories are requested since eMule 0.28+ because eMule 0.27 has a bug in
	//	the OP_ASKSHAREDFILESDIR handler, which does not return the shared files for a directory
	//	which has a trailing backslash. MLdonkey currently does not support shared directories
	//	eMule+ supports shared directories since 1h (0x0108)
		if (m_byteEmuleVersion >= 0x28 && !m_bIsML && (GetPlusVersion() == 0 || GetPlusVersion() >= 0x0108))
			m_bSupportsAskSharedDirs = true;
d736 16
a751 5
	}
	else
	{
		return;
	}
d756 1
a756 1
	uint32 i, dwTagCount = 0;
d797 1
a797 1
						break ;
d801 3
a803 5
						m_dwCompatibleClient = pTempTag->GetIntValue();
						break;
					}
					case ET_MOD_FEATURESET:
					{
d808 1
a808 1
						if (m_strModVersion != pTempTag->GetStringValue())
d810 1
a810 1
							m_strModVersion = pTempTag->GetStringValue();
d817 2
a818 2
						m_dwDataPlusVers = pTempTag->GetIntValue();
						break ;
a820 4
					{
						m_byteDataTarodVer = pTempTag->GetIntValue();
						break;
					}
d865 1
a873 4
					case ET_INCOMPLETEPARTS:
					{
						break;
					}
d918 28
d948 4
d961 2
a962 2
	if (HasMODNameForbiddenStrings()
		|| (GetModVersion() == _T(PLUS_VERSION_STR) && GetMuleVersion() != CURRENT_VERSION_SHORT) )
d1486 3
a1488 1
	if (m_userHash[5] == 13 && m_userHash[14] == 110)
a1489 2
	else if (m_userHash[5] == 14 && m_userHash[14] == 111)
		return SO_EMULE;
d1506 4
d1511 1
a1511 1
//	What is this client's hash type
d1516 1
a1516 1
	//	If the client is an old emule...
d1520 2
d1524 1
a1524 7
	//	If the client is an Mldonkey...
		case SO_MLDONKEY:
		{
			m_eClientSoft = SO_MLDONKEY;
			break;
		}
	//	If the client is an Emule compatible client...
d1527 2
a1528 9
			if (m_byteEmuleVersion != 0x99)
			{
				CString		strTemp;

				strTemp.Format("%02X", m_byteEmuleVersion);
				m_dwClientVersion = _tstoi(strTemp.GetBuffer()) * 10;
			}
			m_eClientSoft = GetClientTypeFromCompatibilityTag(m_dwCompatibleClient);
			if (m_eClientSoft == SO_UNKNOWN)
d1533 6
d1544 42
d1588 12
a1599 3
					m_eClientSoft = SO_EMULE;
					AddDebugLogLine( _T("New Compatible ClientSoft ET_COMPATIBLECLIENT = %u client will be listed as an eMule"),
									 m_dwCompatibleClient );
d1601 4
d1609 23
a1631 3
			// if we got ET_COMPATIBLECLIENT tag, try to detect client over this tag
			if (m_dwCompatibleClient != 0)
				m_eClientSoft = GetClientTypeFromCompatibilityTag(m_dwCompatibleClient);
d1633 15
a1647 6
			if (m_eClientSoft == SO_UNKNOWN)
			{
			//	If the client is an Mldonkey
				if (m_bIsML)
					m_eClientSoft = SO_MLDONKEY;
				else if (m_bEmuleProtocol)
d1649 3
a1651 1
					m_eClientSoft = SO_EMULE;
d1655 5
a1659 3
				//	We're left with donkeys and Hybrids
					if (m_bIsHybrid)
						m_eClientSoft = SO_EDONKEYHYBRID;
d1661 6
a1666 1
						m_eClientSoft = SO_EDONKEY;
d1668 13
d1682 7
d2166 1
a2166 1
		m_bHasMODNameForbiddenStrings = IsLeecherType(m_strModVersion);
d2211 1
a2211 1
CString CUpDownClient::GetClientNameAndVersionString()
d2213 1
a2213 41
	CString buffer(_T("?"));
	EMULE_TRY
	bool isPlus=(GetPlusVersion() && GetPlusVersion()<0x2600);
	switch(GetClientSoft())
	{
	case SO_EMULE:
		if(isPlus)	//Cax2 - second check - don't display the 38e (pre v1?) mods
		{	//Cax2 - assuming v1 v1a v1b - v1.1 v1.1a etc...
			int num=(GetPlusVersion() & 0xF0)>>4;
			int letter=(GetPlusVersion() & 0x0F);
			letter=(letter==0)?(int)' ':letter+(int)'a'-1;
			if (num>0)
				buffer.Format(_T("Plus v%u.%u%c"), GetPlusVersion()>>8,num, (char)letter);
			else
				buffer.Format(_T("Plus v%u%c"), GetPlusVersion()>>8,(char)letter);
			break;
		}
	case SO_LMULE:  // Other Mules fall under one catagory
	case SO_SHAREAZA:
	case SO_OLDEMULE:
	case SO_AMULE:
	case SO_LPHANT:
		{
			if (!GetModVersion().IsEmpty() && !isPlus)
				buffer.Format( _T("%s %s [%s]"), GetClientNameString(GetClientSoft()),
					GetClientVersionString(GetClientSoft(), GetMuleVersion()), GetModVersion() );
			else
				buffer.Format( _T("%s %s"), GetClientNameString(GetClientSoft()),
					GetClientVersionString(GetClientSoft(), GetMuleVersion()) );
		}
		break;
	case SO_UNKNOWN:
		buffer = _T("???");
		break;
	default:
		buffer.Format( _T("%s %s"), GetClientNameString(GetClientSoft()),
			GetClientVersionString(GetClientSoft(), GetVersion()) );
		break;
	}
	EMULE_CATCH
	return buffer;
@


1.283
log
@fixed switching between limited & limitless DL; improved bandwidth control for  limited DL; fixed request of hashset
@
text
@a125 1
	m_byteEmuleVersion = 0;
@


1.282
log
@lphant client support.
@
text
@d87 1
@


1.281
log
@corrected bIsCommunity initialization
@
text
@d2039 1
d2080 1
@


1.280
log
@rollback of old waiting queue
@
text
@d191 1
@


1.279
log
@Removed old stuff.
@
text
@a191 3
	m_uPosInWaitingQueue = 0;
	m_dwWaitingScore = 0;

@


1.278
log
@SSWQ
@
text
@a111 1
	m_strModExtended.Empty();
a799 5
					case ET_MOD_PROTOCOL:
					{
						m_strModExtended = pTempTag->GetStringValue();
						break;
					}
@


1.277
log
@Preparations for new client version report code.
@
text
@d193 3
@


1.276
log
@Basic shared file list messages are moved to emule.log and again displayed on status bar.
@
text
@d895 1
a895 1
						 dwTagCount, GetUserName(), GetClientNameAndVersionString(this), GetFullIP(), GetUserPort() );
d1630 1
a1630 1
		GetResString(IDS_CLIENT), GetFullIP(), GetUserPort(), GetClientNameAndVersionString(this));
d1871 1
a1871 1
		AddDebugLogLine(_T("Received multiple signatures from client %s (%s)"), GetUserName(), GetClientNameAndVersionString(this));
d1877 1
a1877 1
		AddDebugLogLine(_T("Received signature for client %s (%s) without public key"), GetUserName(), GetClientNameAndVersionString(this));
d1883 1
a1883 1
		AddDebugLogLine(_T("Received signature for client %s (%s) with invalid challenge value"), GetUserName(), GetClientNameAndVersionString(this));
d1894 1
a1894 1
		AddDebugLogLine(_T("Client '%s' (%s) has failed the secure identification, V2 State: %i"), GetUserName(), GetClientNameAndVersionString(this), byteChallengeIPKind);
d2060 44
@


1.275
log
@fixed a logline-format
@
text
@d1185 1
a1185 1
			AddDebugLogLine(_T("Unable to retrieve shared files from '%s'"), GetUserName());
d1551 1
a1551 1
		AddDebugLogLine(_T("Requesting shared files from '%s'"), GetUserName());
d1557 1
a1557 1
		AddDebugLogLine(_T("Requesting shared files from user %s (%u) is already in progress"), GetUserName(), GetUserID());
@


1.274
log
@Unified processing of client icon images; Improved string processing.
@
text
@d1253 1
a1253 1
					AddDebugLogLine( RGB_LOG_DIMMED + _T("%Filtered client (don't connect): %s %s"),
@


1.273
log
@Minor change
@
text
@d1511 1
a1511 1
					AddDebugLogLine( _T("New Compatible ClientSoft ET_COMPATIBLECLIENT = %i client will be listed as an eMule"),
d1596 1
a1596 1
		strInfo.AppendFormat(GetResString(IDS_REQ_UNKNOWNFILE));
d1620 1
a1620 2
	CString		strCountry, strDownloaded, strUploaded, strUserName = GetUserName();
	int			iImageIndex = UL_ICON_UNKNOWN;
d1653 1
a1653 1
		strDownloaded.Format(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_DDATA), CastItoXBytes(GetTransferredUp()), CastItoXBytes(Credits()->GetUploadedTotal()));
d1655 1
a1655 2
		strDownloaded.Format(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_DDATA), CastItoXBytes(GetTransferredUp()));
	strInfo += strDownloaded;
d1658 1
a1658 1
		strUploaded.Format(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_UDATA), CastItoXBytes(GetTransferredDown()), CastItoXBytes(Credits()->GetDownloadedTotal()));
d1660 1
a1660 2
		strUploaded.Format(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_UDATA), CastItoXBytes(GetTransferredDown()));
	strInfo += strUploaded;
d1677 1
a1677 29
	switch (GetClientSoft())
	{
		case SO_AMULE:
			iImageIndex = UL_ICON_AMULE;
			break;
		case SO_LMULE:
			iImageIndex = UL_ICON_LMULE;
			break;
		case SO_SHAREAZA:
			iImageIndex = UL_ICON_SHAREAZA;
			break;
		case SO_EDONKEYHYBRID:
			iImageIndex = UL_ICON_EDONKEYHYBRID;
			break;
		case SO_MLDONKEY:
			iImageIndex = UL_ICON_MLDONKEY;
			break;
		case SO_EMULE:
		case SO_OLDEMULE:
			if (m_pCredits->GetCurrentIdentState(GetIP()) != IS_IDENTIFIED)
				iImageIndex = UL_ICON_SECUREHASH;
			else
				iImageIndex = UL_ICON_COMPROT;
			break;
		case SO_EDONKEY:
			iImageIndex = UL_ICON_NORMAL;
			break;
	}
	return g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlUploadList.m_imageList.ExtractIcon(iImageIndex);
d2022 38
@


1.272
log
@small optimization
@
text
@d1590 4
a1593 6
		strInfo += GetResString(IDS_SF_REQUESTED);
		strInfo += CString(pReqFile->GetFileName());
		strInfo += _T('\n');
		strInfo.AppendFormat(GetResString(IDS_FILESTATS_SESSION) + GetResString(IDS_FILESTATS_TOTAL),
			pReqFile->statistic.GetAccepts(), pReqFile->statistic.GetRequests(), CastItoXBytes(pReqFile->statistic.GetTransferred()),
			pReqFile->statistic.GetAllTimeAccepts(), pReqFile->statistic.GetAllTimeRequests(), CastItoXBytes(pReqFile->statistic.GetAllTimeTransferred()));
d1596 1
a1596 1
		strInfo += GetResString(IDS_REQ_UNKNOWNFILE);
@


1.271
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@a310 1
					m_bIsUserNameChanged = true;
@


1.270
log
@Clear upload requested block lists on disconnection (correct fix this time).
@
text
@a175 3
	m_dwLastRefreshedULDisplayTime = ::GetTickCount();
	m_bScoreBaseIsCached = false;
	m_bCommunityIsCached = false;
d188 5
a305 1
				m_strUserName.Empty();
d311 1
d315 5
a319 1
					m_strUserName.SetString(pTempTag->GetStringValue(), pTempTag->GetStringValue().GetLength());
d339 5
a343 1
				m_strModVersion = pTempTag->GetStringValue();
d576 1
a576 1
	if (IsStolenName(m_strUserName))
d792 5
a796 1
						m_strModVersion = pTempTag->GetStringValue();
d925 1
a925 1
	if (IsLeecherType(GetModVersion())
d2036 20
@


1.269
log
@Fixed a GUI glitch in Messages window when multiple tabs are open and windows is themed;
Name changes, formatting etc.
@
text
@d1097 7
a1103 15
	//	Although this should not happen, it happens sometimes. The problem we may run into here is as follows:
	//	1.) If we do not clear the block send requests for that client, we will send those blocks next time the client
	//	gets an upload slot. But because we are starting to send any available block send requests right _before_ the
	//	remote client had a chance to prepare to deal with them, the first sent blocks will get dropped by the client.
	//	Worst thing here is, because the blocks are zipped and can therefore only be uncompressed when the first block
	//	was received, all of those sent blocks will create a lot of uncompress errors at the remote client.
	//	2.) The remote client may have already received those blocks from some other client when it gets the next
	//	upload slot.
		if (m_blockSendQueue.GetCount() > 0)
		{
			AddDebugLogLine( _T("Disconnected client '%s' (%s). Block send queue=%u."), GetUserName(), 
							 GetClientNameAndVersionString(this), m_blockSendQueue.GetCount() );
			ClearUploadBlockRequests();
		}
		//	If the client is downloading, leave it on the queue but stop it from downloading
@


1.268
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d504 5
a508 4
				TCITEM newitem;
				newitem.mask = TCIF_TEXT;
				newitem.pszText = m_strUserName.GetBuffer(256);
				g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.SetItem(g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.GetTabByClient(this), &newitem);
d1172 1
a1172 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ConnectingResult(this, false);
d1383 1
a1383 1
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ConnectingResult(this, true);
@


1.267
log
@#ifdef _DEBUG tagerror loglines
added init m_eChatState to MS_NONE
init m_pbytePartStatuses to NULL instead of 0
@
text
@d386 3
a388 3
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag for client '%s': 0x%x, Intvalue: %d Stringvalue: %s, (client version: %d)"),
				                 	   m_strUserName, static_cast<int>(pTempTag->GetSpecialTag()), pTempTag->GetIntValue(),
				    				   pTempTag->GetStringValue(), m_dwClientVersion );
d443 2
a444 2
		AddDebugLogLine( false, _T("Client '%s' (version: %d|IP: %s) sent an incorrect user port. Using %d instead."),
								m_strUserName, m_dwClientVersion, ip_addr, m_uUserPort );
d880 2
a881 2
		AddDebugLogLine(false, _T("Error while processing emuletag %u/%u from client '%s' (%s) %s:%u")
			, i + 1, dwTagCount, GetUserName(), GetClientNameAndVersionString(this), GetFullIP(), GetUserPort());
d1056 2
a1057 2
						AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Description by client '%s' for file '%s' filtered: %s"),
												m_strUserName, m_pReqPartFile->GetFileName(), m_strComment );
d1068 2
a1069 2
				AddDebugLogLine( false, _T("Description by client '%s' for file '%s' received: %s"),
										m_strUserName, m_pReqPartFile->GetFileName(), m_strComment );
d1075 2
a1076 2
			AddDebugLogLine( false, _T("Rating by client '%s' for file '%s' received: %s"),
									m_strUserName, m_pReqPartFile->GetFileName(), ::GetRatingString(m_eRating) );
d1106 2
a1107 1
			AddDebugLogLine(false, "Disconnected client '%s' (%s). Block send queue=%u.", GetUserName(), GetClientNameAndVersionString(this), m_blockSendQueue.GetCount());
d1179 1
a1179 1
			AddDebugLogLine(false, _T("Unable to retrieve shared files from '%s'"), GetUserName());
d1227 2
a1228 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Filtered client (don't connect): %s %s"),
										GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit() );
d1247 2
a1248 2
					AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%Filtered client (don't connect): %s %s"),
											GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit() );
d1258 2
a1259 2
		//	AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"),
		//							__FUNCTION__, m_dwUserID,m_dwUserIP,GetFullIP() );
d1505 2
a1506 2
					AddDebugLogLine( false, "New Compatible ClientSoft ET_COMPATIBLECLIENT = %i client will be listed as an eMule",
											m_dwCompatibleClient );
d1545 1
a1545 1
		AddDebugLogLine(false, _T("Requesting shared files from '%s'"), GetUserName());
d1551 1
a1551 2
		AddDebugLogLine(false, _T("Requesting shared files from user %s (%u) is already in progress"),
								GetUserName(), GetUserID() );
d1715 1
a1715 1
	DEBUG_ONLY(AddDebugLogLine(false, "%s: Sending public key to '%s'", __FUNCTION__, GetUserName()));
d1760 1
a1760 1
	DEBUG_ONLY(AddDebugLogLine(false, "%s: Sending signature key to '%s'", __FUNCTION__, GetUserName()));
d1765 1
a1765 1
		AddDebugLogLine(false, "Client '%s' want to send signature but challenge value is invalid", GetUserName());
d1821 1
a1821 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Receiving public key from '%s'", __FUNCTION__, GetUserName()));
d1845 2
a1846 2
			AddDebugLogLine( false, _T("Client '%s': Invalid State error, IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket"),
									GetUserName() );
d1851 1
a1851 1
		AddDebugLogLine(false, "Client '%s' failed to use new received public key", GetUserName());
d1858 1
a1858 1
	DEBUG_ONLY(AddDebugLogLine(false, "%s: Receiving signature from '%s'", __FUNCTION__, GetUserName()));
d1898 1
a1898 1
		AddDebugLogLine(false, "Received multiple signatures from client %s (%s)", GetUserName(), GetClientNameAndVersionString(this));
d1904 1
a1904 1
		AddDebugLogLine(false, "Received signature for client %s (%s) without public key", GetUserName(), GetClientNameAndVersionString(this));
d1910 1
a1910 1
		AddDebugLogLine(false, "Received signature for client %s (%s) with invalid challenge value", GetUserName(), GetClientNameAndVersionString(this));
d1921 1
a1921 1
		AddDebugLogLine(false, "Client '%s' (%s) has failed the secure identification, V2 State: %i", GetUserName(), GetClientNameAndVersionString(this), byteChallengeIPKind);
d1950 1
a1950 1
			DEBUG_ONLY(AddDebugLogLine(false, "%s: Not sending SecIdentState Packet, because State is Zero", __FUNCTION__));
d1960 1
a1960 1
		DEBUG_ONLY(AddDebugLogLine(false, "%s: Sending SecIdentState packet, state: %i (to '%s')", __FUNCTION__, byteValue, GetUserName()));
d2001 1
a2001 1
	DEBUG_ONLY(AddDebugLogLine(false, "%s: Received SecIdentState Packet, state: %i", __FUNCTION__, pbytePacket[0]));
@


1.266
log
@fixed high cpu-usage loop due to malicious muleinfo packets
@
text
@d116 1
a116 1
	m_pbytePartStatuses = 0;
d139 1
d879 1
d881 2
a882 1
			, i + 1, dwTagCount, GetUserName(), GetClientNameAndVersionString(this), GetFullIP(), GetUDPPort());
@


1.265
log
@Clear list of (upload) block send requests on client disconnection.
@
text
@d726 1
a726 1
	uint32 dwTagCount = 0;
d729 2
a730 1
	for (uint32 i = 0;i < dwTagCount; i++)
d732 1
a732 4
		try
		{
		pTempTag = new CEmuleTag(packetStream);
		if (pTempTag)
d734 2
a735 1
			switch (pTempTag->GetSpecialTag())
d737 1
a737 1
				case ET_COMPRESSION:
d739 123
a861 123
					m_byteDataCompVer = pTempTag->GetIntValue();
					break;
				}
				case ET_UDPPORT:
				{
					m_uUDPPort = pTempTag->GetIntValue();
					break;
				}
				case ET_UDPVER:
				{
					m_byteUDPVer = pTempTag->GetIntValue();
					break;
				}
				case ET_SOURCEEXCHANGE:
				{
					m_byteSourceExchangeVer = pTempTag->GetIntValue();
					break;
				}
				case ET_COMMENTS:
				{
					m_byteAcceptCommentVer = pTempTag->GetIntValue();
					break;
				}
				case ET_EXTENDEDREQUEST:
				{
					m_byteExtendedRequestsVer = pTempTag->GetIntValue();
					break ;
				}
				case ET_COMPATIBLECLIENT:
				{
					m_dwCompatibleClient = pTempTag->GetIntValue();
					break;
				}
				case ET_MOD_FEATURESET:
				{
					break;
				}
				case ET_MOD_VERSION:
				{
					m_strModVersion = pTempTag->GetStringValue();
					break;
				}
				case ET_MOD_PROTOCOL:
				{
					m_strModExtended = pTempTag->GetStringValue();
					break;
				}
				case ET_MOD_PLUS:
				{
					m_dwDataPlusVers = pTempTag->GetIntValue();
					break ;
				}
				case ET_MOD_TAROD:
				{
					m_byteDataTarodVer = pTempTag->GetIntValue();
					break;
				}
				case ET_MOD_BOWLFISH:
				case ET_MOD_TAROD_VERSION:
				case ET_MOD_FUSION:
				case ET_MOD_FUSION_VERSION:
				case ET_MOD_Morph:
				case ET_MOD_Morph_VERSION:
				case ET_MOD_MorTillo:
				case ET_MOD_MorTillo_VERSION:
				case ET_MOD_LSD:
				case ET_MOD_LSD_VERSION:
				case ET_MOD_LOVELACE_VERSION:
				case ET_MOD_OXY:
				case ET_MOD_UNKNOWNx12:
				case ET_MOD_UNKNOWNx13:
				case ET_MOD_UNKNOWNx14:
				case ET_MOD_UNKNOWNx17:
				case ET_MOD_UNKNOWNx2F:
				case ET_MOD_UNKNOWNx30:
				case ET_MOD_UNKNOWNx36:
				case ET_MOD_UNKNOWNx3C:
				case ET_MOD_UNKNOWNx41:
				case ET_MOD_UNKNOWNx42:
				case ET_MOD_UNKNOWNx43:
				case ET_MOD_UNKNOWNx50:
				case ET_MOD_UNKNOWNx59:
				case ET_MOD_UNKNOWNx5B:
				case ET_MOD_UNKNOWNx5C:
				case ET_MOD_UNKNOWNx60:
				case ET_MOD_UNKNOWNx64:
				case ET_MOD_UNKNOWNx76:
				case ET_MOD_UNKNOWNx84:
				case ET_MOD_UNKNOWNx85:
				case ET_MOD_UNKNOWNx86:
				case ET_MOD_UNKNOWNx91:
				case ET_MOD_UNKNOWNx92:
				case ET_MOD_UNKNOWNx93:
				case ET_MOD_UNKNOWNxA0:
				case ET_MOD_UNKNOWNxA1:
				case ET_MOD_UNKNOWNxA6:
				case ET_MOD_UNKNOWNxB1:
				case ET_MOD_UNKNOWNxB4:
				case ET_MOD_UNKNOWNxC8:
				case ET_MOD_UNKNOWNxC9:
				case ET_MOD_UNKNOWNxDA:
				{
					break;
				}
				case ET_L2HAC:
				{
					m_dwL2HACTime = pTempTag->GetIntValue();
					break;
				}
				case ET_INCOMPLETEPARTS:
				{
					break;
				}
				case ET_FEATURES:
				{
				//	Bits 31- 8: 0 - reserved
				//	Bit   7- 0: secure identification
					m_byteSupportSecIdent = pTempTag->GetIntValue() & 3;
					break;
				}
				default:
				{
					if (!pTempTag->GetStringValue().IsEmpty())
d863 4
a866 1
					//	Nothing to do for now...
d869 2
a871 2
			delete pTempTag;
			pTempTag = NULL;
d874 6
a879 5
		catch (CException* error)
		{
			error->Delete();
			safe_delete(pTempTag);
		}
@


1.264
log
@DebugLog lines shouldn't update taskbar
@
text
@d1089 15
a1103 1
	//	If the client is downloading, leave it on the queue but stop it from downloading
@


1.263
log
@Added client version info to debug log messages.
@
text
@d1524 1
a1524 1
		AddDebugLogLine(true, _T("Requesting shared files from '%s'"), GetUserName());
d1530 1
a1530 1
		AddDebugLogLine( false, _T("Requesting shared files from user %s (%u) is already in progress"),
@


1.262
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d1878 1
a1878 1
		AddDebugLogLine(false, "Received multiple signatures from client %s", GetUserName());
d1884 1
a1884 1
		AddDebugLogLine(false, "Received signature for client %s without public key", GetUserName());
d1890 1
a1890 1
		AddDebugLogLine(false, "Received signature for client %s with invalid challenge value", GetUserName());
d1901 1
a1901 1
		AddDebugLogLine(false, "Client '%s' has failed the secure identification, V2 State: %i", GetUserName(), byteChallengeIPKind);
@


1.261
log
@Fixed update of country information if remote user IP was changed;
A fix to show country information for Source Exchange and saved sources.
@
text
@d1658 2
a1659 2
		case SO_CDONKEY:
			iImageIndex = UL_ICON_CDONKEY;
@


1.260
log
@Memory optimization required for the lists.
@
text
@d66 1
d97 2
a167 2
		if(m_dwConnectIP != m_dwUserIP)
			m_uUserCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
d169 1
a169 5
	}
	else
	{
		m_dwUserIP = 0;
		m_dwConnectIP = 0;
d459 1
a459 2
	m_dwConnectIP = m_dwUserIP;
	if(g_eMuleApp.m_pIP2Country->IsIP2Country())
d461 2
a462 2
		if (m_uUserCountryIdx == NO_COUNTRY_INFO)
			m_uUserCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
@


1.259
log
@Hope no more changes... :P
@
text
@d37 2
a38 1
CUpDownClient::CUpDownClient(CClientReqSocket *pRequestSocket)
d46 2
a47 1
CUpDownClient::CUpDownClient(uint16 uPort, uint32 dwClientID, uint32 dwServerIP, uint16 uServerPort, CPartFile *pReqPartFile)
@


1.258
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d1052 1
a1052 1
						AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Description by source %s for file '%s' filtered: %s"),
d1064 1
a1064 1
				AddDebugLogLine( false, _T("Description by source %s for file '%s' received: %s"),
d1071 1
a1071 1
			AddDebugLogLine( false, _T("Rating by source %s for file '%s' received: %s"),
@


1.257
log
@Minor change
@
text
@d386 3
a388 3
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
				                 __FUNCTION__, /*pTempTag->GetSpecialTag(),*/ static_cast<int>(pTempTag->GetSpecialTag()),
								 pTempTag->GetIntValue(), pTempTag->GetStringValue(), m_dwClientVersion, m_strUserName );
d443 2
a444 2
		AddDebugLogLine( false, _T("%s: Source %s (client version: %d | IP: %s) sent an incorrect user port. Use the real one instead: %d."),
								__FUNCTION__, m_strUserName, m_dwClientVersion, ip_addr, m_uUserPort );
d1160 1
a1160 1
			AddDebugLogLine(false, _T("%s: Unable to retrieve shared files from '%s'"), __FUNCTION__, GetUserName());
d1208 2
a1209 2
				AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Filtered client (don't connect): %s %s"),
										__FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit() );
d1228 2
a1229 2
					AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Filtered client (don't connect): %s %s"),
											__FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit() );
d1486 2
a1487 2
					AddDebugLogLine( false, "%s: New Compatible ClientSoft ET_COMPATIBLECLIENT = %i client will be listed as an eMule",
											__FUNCTION__, m_dwCompatibleClient );
d1526 1
a1526 1
		AddDebugLogLine(true, _T("%s: Requesting shared files from '%s'"), __FUNCTION__, GetUserName());
d1532 2
a1533 2
		AddDebugLogLine( false, _T("%s: Requesting shared files from user %s (%u) is already in progress"),
								__FUNCTION__, GetUserName(), GetUserID() );
d1747 1
a1747 1
		AddDebugLogLine(false, "%s: Want to send signature but challenge value is invalid ('%s')", __FUNCTION__, GetUserName());
d1827 2
a1828 2
			AddDebugLogLine( false, _T("%s: Invalid State error: IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket ('%s')"),
									__FUNCTION__, GetUserName() );
d1833 1
a1833 1
		AddDebugLogLine(false, "%s: Failed to use new received public key ('%s')", __FUNCTION__, GetUserName());
d1880 1
a1880 1
		AddDebugLogLine(false, "%s: Received multiple signatures from client %s", __FUNCTION__, GetUserName());
d1886 1
a1886 1
		AddDebugLogLine(false, "%s: Received signature for client %s without public key", __FUNCTION__, GetUserName());
d1892 1
a1892 1
		AddDebugLogLine(false, "%s: Received signature for client %s with invalid challenge value", __FUNCTION__, GetUserName());
d1903 1
a1903 1
		AddDebugLogLine(false, "%s: '%s' has failed the secure identification, V2 State: %i", __FUNCTION__, GetUserName(), byteChallengeIPKind);
d2010 1
a2010 1
}@


1.256
log
@DebugLog formating and changes
@
text
@d1052 2
a1053 2
						AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Description by source %s for file '%s' filtered: %s"),
												__FUNCTION__, m_strUserName, m_strClientFilename, m_strComment );
d1064 2
a1065 2
				AddDebugLogLine( false, _T("%s: Description by source %s for file '%s' received: %s"),
										__FUNCTION__, m_strUserName, m_strClientFilename, m_strComment );
d1071 2
a1072 2
			AddDebugLogLine( false, _T("%s: Rating by source %s for file '%s' received: %s"),
									__FUNCTION__, m_strUserName, m_strClientFilename, ::GetRatingString(m_eRating) );
@


1.255
log
@Removed unused code.
@
text
@a197 2
//	AddDebugLogLine(false, _T("%s: Destroying client %s (addr 0x%08X)"),__FUNCTION__,GetUserName(), this);

a308 2
//					AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, HashToString(m_userHash), m_strFullUserIP, m_uUserPort);

d313 1
a313 1
					m_strUserName.SetString(pTempTag->GetStringValue(), pTempTag->GetStringValue().GetLength()); //eklmn: used CSimpleString class & functions
d399 1
a399 2
//	If the client didn't try to crash us with a blank name and the "add servers
//		to server list on connect" preference is on...
d443 2
a444 3
		AddDebugLogLine(false, _T("%s: User %s (client version:%d) IP:%s sent an incorrect user port. Used the "
								  "real one instead: %d."), __FUNCTION__, m_strUserName, m_dwClientVersion,
						ip_addr, m_uUserPort);
d516 1
a516 1
	//get IP-Port hash
d528 1
a528 1
	//check if remote client has our HASH
a537 5
/*
		AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
		                 (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24), m_uUserPort,
		                 (dwUnfairClientActions + dwNewUnfairActions), g_dwTotalNumUnfairActions, g_dwTotalNumUnfairClients);
*/
d541 1
a541 2
	// detect a hash chager (detect id-changer)
	// eklmn: actually we are detecting a change of ID based on UserHash
d545 1
a545 1
// Calculate a HASH-ID
d549 1
a549 1
// Check a map
d555 2
a556 2
	{
		m_bIsHashThief = true;
a557 1
			//eklmn: update global statistic
a559 6

			/*
			AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
			                 (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24), m_uUserPort,
			                 (dwUnfairClientActions + dwNewUnfairActions), g_dwTotalNumUnfairActions, g_dwTotalNumUnfairClients);
			*/
d562 1
a562 1
	// update a IDhash
d565 1
a565 1
	//check famous stolen hashs/names
a571 4
/*
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUserName,
		        (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24), m_uUserPort, (dwUnfairClientActions + dwNewUnfairActions), g_dwTotalNumUnfairActions );
*/
d580 1
a580 1
	//if we found new unfair action from remote client, then update a table
a583 1
		//InterlockedIncrement(&g_eMuleApp.g_dwTotalNumUnfairClients);
d604 1
a604 1
//	if IP is filtered, don't greet him but disconnect...
d638 1
a638 1
		//header of the info packet
d645 1
a645 1
		//body of the info packet
d656 2
a657 1
		CEmuleTag tag6(ET_MOD_PLUS, CURRENT_PLUS_VERSION);	// To check for eMulePlus
d662 3
a664 3
		tag8.WriteToFile(packetStream);	 //More harmless than the other 2! :D
		CEmuleTag tag9(ET_L2HAC, FILEREASKTIME);	//<<-- enkeyDEV(th1) -L2HAC-
		tag9.WriteToFile(packetStream);			//<<-- enkeyDEV(th1) -L2HAC-
d699 1
a699 1
//implicitly supported options by older clients
d702 1
a702 2
	//in the future do not use version to guess about new features

d712 4
a715 5
	//	Shared directories are requested from eMule 0.28+ because eMule 0.27 has a bug in
	//	the OP_ASKSHAREDFILESDIR handler, which does not return the shared files for a
	//	directory which has a trailing backslash.
	//	MLdonkey currently does not support shared directories
	//	eMule+ supports shared directories with 1h (0x0108)
d724 1
d726 1
a726 2

	m_dwL2HACTime = 0;	//<<-- enkeyDEV(th1) -L2HAC-
d846 1
a846 1
				case ET_L2HAC:     	// START enkeyDEV(th1) -L2HAC-
d849 1
a849 1
					break;		// END enkeyDEV(th1) -L2HAC-
d851 1
a851 1
				case ET_INCOMPLETEPARTS:      // enkeyDEV(th1) -ICS-
d855 1
a855 1
				case ET_FEATURES:     	// secure credits (official 0.29b)
d866 1
a866 2
//						CString buffer = pTempTag->GetStringValue();
//						TagToDebugLogLine(RGB_LOG_DIMMED + _T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), pTempTag->GetSpecialTag());
a867 2
//					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
//						__FUNCTION__, pTempTag->GetSpecialTag(), pTempTag->GetIntValue(), pTempTag->GetStringValue(), m_strUserName, GetClientNameAndVersionString(this) );
a880 1
//	START enkeyDEV(th1) -L2HAC- Enable every emule anyway and disable bad clients
a884 1
//	END enkeyDEV(th1) -L2HAC-
d892 1
a892 1
		m_dwL2HACTime = 0;	//<<-- enkeyDEV(th1) -L2HAC-
d895 1
a895 3
	ReGetClientSoft();	// 9/5/2003 [Moosetea] Official client, this messes the stats up, creates lots of invalid edonkey clients
						// 29.03.2004 [eklmn] after rewriting of ReGetClientSoft() it's back, cause otherwise we are losing
						// 			information from compatibility tag
d901 1
a901 1
//	emuleplus supports 'complete sources' with versions 1f and 1g (force ET_EXTENDEDREQUEST v2 for backward compatibility)
d905 1
a905 1
	// check a leecher clients
a958 1
	//
d976 1
a976 1
	uint16		nPort = g_eMuleApp.m_pGlobPrefs->GetListenPort();  //Maverick
d995 1
a995 1
		g_eMuleApp.m_pGlobPrefs->m_pNameTag->WriteToFile(packetStream);			//{ NAME : int }
d998 1
a998 1
			g_eMuleApp.m_pGlobPrefs->m_pVersionTag->WriteToFile(packetStream);		//    { VERSION : int }
d1042 4
a1045 2
				CString lowComment(m_strComment);	//make a copy of casesensitive comment
				lowComment.MakeLower();				//make copy only lowercase to search in
d1052 2
a1053 1
						AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Description for file '%s' filtered: %s"), __FUNCTION__, m_strClientFilename, m_strComment);
d1064 2
a1065 1
				AddDebugLogLine(false, _T("%s: Description for file '%s' received: %s"), __FUNCTION__, m_strClientFilename, m_strComment);
d1071 2
a1072 1
			AddDebugLogLine(false, _T("%s: Rating for file '%s' received: %s"), __FUNCTION__, m_strClientFilename, ::GetRatingString(m_eRating));
d1074 1
a1074 1
		if ((!m_strComment.IsEmpty()) || (m_eRating != PF_RATING_NONE))	// #zegzav:pastcomment
d1100 1
a1100 1
	//
a1101 1
	//
a1150 1
		//	SyruS (0.29c)
d1160 1
a1160 1
			AddDebugLogLine(false, _T("%s: ") + ::GetResString(IDS_SHAREDFILES_FAILED), __FUNCTION__, GetUserName());
a1179 4
	else
	{
		AddDebugLogLine(false, _T("%s: Invalid client."), __FUNCTION__);
	}
d1197 2
a1198 3
//
//	BavarianSnail - filter LowIDs separately from HighIDs
//
d1208 2
a1209 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered client (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1214 1
a1214 1
			InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);	//g_eMuleApp.stat_filteredclients++;
d1228 2
a1229 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered client (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1232 1
a1232 1
				InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);	//g_eMuleApp.stat_filteredclients++;
d1239 2
a1240 1
		//	AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"), __FUNCTION__, m_dwUserID,m_dwUserIP,GetFullIP());
d1357 1
a1357 1
//
d1402 2
a1403 1
				SetLastGotULData();	//eklmn: set Upload Timer
d1456 1
a1456 1
	//	If the client is an Ml donkey...
d1486 2
a1487 1
					AddDebugLogLine(false, "%s: New Compatible ClientSoft ET_COMPATIBLECLIENT = %i client will be listed as an emule ", __FUNCTION__, m_dwCompatibleClient);
d1499 1
a1499 1
			//	If the client is an Ml donkey
d1526 1
a1526 1
		AddDebugLogLine(true, IDS_SHAREDFILES_REQUEST, GetUserName());
d1532 2
a1533 1
		AddDebugLogLine(false,_T("Requesting shared files from user %s (%u) is already in progress"),GetUserName(),GetUserID());
d1562 1
a1562 1
//	build info text and display it
d1697 1
a1697 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Sending public key to '%s'", __FUNCTION__, GetUserName()));
d1725 1
a1725 1
//	signate the public key of this client and send it
d1736 2
d1739 1
a1739 1
		return; // We don't have his public key yet, will be back here later
d1742 1
a1742 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Sending signature key to '%s'", __FUNCTION__, GetUserName()));
d1744 1
a1744 1
//	do we have a challenge value received (actually we should if we are in this function)
d1747 1
a1747 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Want to send signature but challenge value is invalid ('%s')", __FUNCTION__, GetUserName());
d1750 1
a1750 2
//	v2
//	we will use v1 as default, except if only v2 is supported
a1775 1
//end v2
a1801 1
//	g_eMuleApp.m_pClientList->AddTrackClient(this);
d1826 3
a1828 2
		//	something is wrong
			g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Invalid State error: IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket", __FUNCTION__);
d1833 1
a1833 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Failed to use new received public key", __FUNCTION__);
d1840 1
a1840 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Receiving signature from '%s'", __FUNCTION__, GetUserName()));
d1880 1
a1880 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received multiple signatures from one client", __FUNCTION__);
d1886 1
a1886 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received signature for client without public key", __FUNCTION__);
d1892 1
a1892 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received signature for client with invalid challenge value ('%s')", __FUNCTION__, GetUserName());
a1898 1
	//g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "'%s' has passed the secure identification, V2 State: %i", GetUserName(), byteChallengeIPKind);
d1903 1
a1903 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: '%s' has failed the secure identification, V2 State: %i", __FUNCTION__, GetUserName(), byteChallengeIPKind);
d1912 1
a1912 1
//	check if we need public key and signature
d1932 1
a1932 1
			DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Not sending SecIdentState Packet, because State is Zero", __FUNCTION__));
d1936 1
a1936 1
	//	crypt: send random data to sign
d1942 1
a1942 1
		DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Sending SecIdentState packet, state: %i (to '%s')", __FUNCTION__, byteValue, GetUserName()));
d1960 1
a1960 1
	if (dwSize != 5)	// <= ICK! Define a struct and use sizeof :P !
d1983 1
a1983 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received SecIdentState Packet, state: %i", __FUNCTION__, pbytePacket[0]));
d1988 1
a1988 1
//		been received.
@


1.254
log
@code formatting
@
text
@a100 2
	m_bUsedCompressionDown = false;
	m_bUsedCompressionUp = false;
@


1.253
log
@fix to avoid sending corrupted HelloType packets (it shouldn't happen)
@
text
@d1057 1
a1057 3
	int length;

	if ((m_pReqPartFile != NULL) && ((dwSize > (sizeof(m_eRating) + sizeof(length) - 1))))
@


1.252
log
@Prevent unwanted clients from becoming friends;
Fix for possible crash due to corrupt comment packet;
Fix for delayed remote answer to hashset request.
@
text
@d1015 10
a1024 1
	uint32		dwTagCount = 2;
d1028 1
a1028 1
	if (g_eMuleApp.m_pGlobPrefs->m_pNameTag)
d1031 4
a1034 5
	}

	if (g_eMuleApp.m_pGlobPrefs->m_pVersionTag)
	{
		g_eMuleApp.m_pGlobPrefs->m_pVersionTag->WriteToFile(packetStream);		//    { VERSION : int }
d1126 2
a1127 2
	// The remote client does not have to answer with OP_HASHSETANSWER *immediatly* 
	// after we've sent OP_HASHSETREQUEST. It may occur that a (buggy) remote client 
d1639 1
a1639 1
	
d1643 1
a1643 1
	
d1685 1
a1685 1
			strInfo.AppendFormat(GetResString(IDS_TT_FILESTATS), m_pReqSharedFile->statistic.GetAllTimeAccepts(), m_pReqSharedFile->statistic.GetAllTimeRequests(), CastItoXBytes(m_pReqSharedFile->statistic.GetAllTimeTransferred())); 
@


1.251
log
@Tooltips string improvements
@
text
@d151 1
d480 1
a480 1
//	Make sure if this user is a highid user there userid matches there ip address
d484 1
a484 1
//	get client credits
d488 3
a490 1
	if ((m_pFriend = g_eMuleApp.m_pFriendList->LinkFriend(key, m_dwUserIP, m_uUserPort)) != NULL)
d492 11
a502 8
		m_pFriend->m_pLinkedClient = this;
		m_pFriend->m_dwHasHash = 1;
		md4cpy(m_pFriend->m_abyUserhash, GetUserHash());
		m_pFriend->m_strName.Format(_T("%s"), m_strUserName);
		m_pFriend->m_dwLastUsedIP = m_dwUserIP;
		m_pFriend->m_nLastUsedPort = m_uUserPort;
		g_eMuleApp.m_pFriendList->RefreshFriend(m_pFriend);
		if (m_eChatState == MS_CONNECTING)
d504 14
a517 4
			TCITEM newitem;
			newitem.mask = TCIF_TEXT;
			newitem.pszText = m_strUserName.GetBuffer(256);
			g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.SetItem(g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.GetTabByClient(this), &newitem);
d699 9
a707 2
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
		m_pRequestSocket->SendPacket(pPacket, true, true);
d966 1
a966 1
	if (m_pRequestSocket)
a1018 6
/*
	CClientTag		*pTag = new CClientTag(CT_NAME, g_eMuleApp.m_pGlobPrefs->GetUserNick().GetBuffer());

	pTag->WriteToFile(packetStream);				//    { NAME : int }
	delete pTag;
*/
d1023 1
a1023 5
/*
	pTag = new CClientTag(CT_VERSION, EDONKEYVERSION);
	pTag->WriteToFile(packetStream);				//    { VERSION : int }
	delete pTag;
*/
d1049 3
a1051 1
	if ((m_pReqPartFile != NULL) && (dwSize > 2))
d1057 3
d1062 1
d1067 1
a1067 1
		//(SyruS) netwolf commentfilter
d1118 4
a1121 2
	//	If the client is requesting a hashset...
		if ((GetDownloadState() == DS_REQHASHSET) && m_pReqPartFile != NULL)
d1203 1
d1556 4
@


1.250
log
@Updated SourceExchange Protocol to v2
@
text
@d1597 1
a1597 1
	CString		strCountry, strDownloaded, strUploaded, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = GetUserName();
d1605 5
a1609 3
	strUserInfo += GetResString(IDS_TT_CLIENT);
	strUserInfo.Insert(strUserInfo.GetLength() - 4, _T(" (<b>") + GetClientNameAndVersionString(this) + _T("</b>)"));

d1614 2
a1615 2
		CString strServerLine, strServerName = pServer->GetListName();
		in_addr				serverAddr;
d1618 2
a1621 1
		strServerLine.Format(GetResString(IDS_TT_SERVER), inet_ntoa(serverAddr), GetServerPort());
d1623 5
a1627 2
			strServerLine.Insert(strServerLine.GetLength() - 4, _T(" (<b>") + strServerName + _T("</b>)"));
		strUserInfo += strServerLine;
a1629 2
	strInfo.Format(strUserInfo, strUserName, GetUserID(), strCountry, GetFullIP(), GetUserPort());

d1631 1
a1631 1
		strDownloaded.Format(_T("<b>%s:</b><t>%s (%s)<br>"), GetResString(IDS_STATS_DDATA), CastItoXBytes(GetTransferredUp()), CastItoXBytes(Credits()->GetUploadedTotal()));
d1633 1
a1633 1
		strDownloaded.Format(_T("<b>%s:</b><t>%s<br>"), GetResString(IDS_STATS_DDATA), CastItoXBytes(GetTransferredUp()));
d1637 1
a1637 1
		strUploaded.Format(_T("<b>%s:</b><t>%s (%s)<br>"), GetResString(IDS_STATS_UDATA), CastItoXBytes(GetTransferredDown()), CastItoXBytes(Credits()->GetDownloadedTotal()));
d1639 1
a1639 1
		strUploaded.Format(_T("<b>%s:</b><t>%s<br>"), GetResString(IDS_STATS_UDATA), CastItoXBytes(GetTransferredDown()));
d1647 6
a1652 3
			strInfo.AppendFormat(GetResString(IDS_TT_REQUESTED) + GetResString(IDS_TT_FILESTATS_SESSION) + GetResString(IDS_TT_FILESTATS_TOTAL),
			m_pReqSharedFile->GetFileName(), m_pReqSharedFile->statistic.GetAccepts(), m_pReqSharedFile->statistic.GetRequests(), CastItoXBytes(m_pReqSharedFile->statistic.GetTransferred()),
			m_pReqSharedFile->statistic.GetAllTimeAccepts(), m_pReqSharedFile->statistic.GetAllTimeRequests(), CastItoXBytes(m_pReqSharedFile->statistic.GetAllTimeTransferred()));
d1654 1
a1654 1
			strInfo += GetResString(IDS_REQ_UNKNOWNFILE);
a1655 1
	strInfo.TrimRight(_T("<br>"));
@


1.249
log
@updated UDP Protocol to v4
@
text
@d662 1
a662 1
		CEmuleTag tag4(ET_SOURCEEXCHANGE, 1);
@


1.248
log
@updated CT_UNKNOW tag list
@
text
@d658 1
a658 1
		CEmuleTag tag2(ET_UDPVER, 3);	// netwolf: complete sources UDP
@


1.247
log
@double clicking the status bar's session time switches to statistics dialog;
added session time tooltip;
added uploaded/downloaded data to clients tooltips
@
text
@d372 4
d379 1
d903 1
a903 1
	
d905 1
a905 1
						// 29.03.2004 [eklmn] after rewriting of ReGetClientSoft() it's back, cause otherwise we are losing 
d917 1
a917 1
	if (IsLeecherType(GetModVersion()) 
d1500 1
a1500 1
			
@


1.246
log
@Double clicking on the messages/server pane in the status bar now switches to the according dialog; Formatting and name changes
@
text
@d1592 1
a1592 2
	CString		strCountry, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = GetUserName();
	in_addr		serverAddr;
a1594 1
	serverAddr.S_un.S_addr = GetServerIP();
d1602 1
a1602 1
	strUserInfo += GetResString(IDS_TT_SERVER);
d1607 4
a1610 1
		CString strServerName = pServer->GetListName();
d1613 19
a1631 3
		strUserInfo.Insert(strUserInfo.GetLength() - 4, _T(" (<b>") + strServerName + _T("</b>)"));
	}
	strInfo.Format(strUserInfo, strUserName, GetUserID(), strCountry, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
@


1.245
log
@Formatting and some improvements in tooltips code
@
text
@d1590 1
a1590 1
		return NULL;
d1661 1
a1661 1
	return NULL;
@


1.244
log
@Display client version and server name in tooltips
@
text
@d1552 3
a1554 1
	CString sRet;
d1557 9
a1565 10
	sRet.Format(GetResString(IDS_USERINFO), GetUserName(), GetUserID());
	CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID(this->m_reqFileHash);
	if (file)
	{
		sRet += GetResString(IDS_SF_REQUESTED);
		sRet += CString(file->GetFileName());
		sRet += _T('\n');
		sRet.AppendFormat( GetResString(IDS_FILESTATS_SESSION) + GetResString(IDS_FILESTATS_TOTAL),
		             file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransferred()),
		             file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransferred()) );
d1568 3
a1570 4
	{
		sRet += GetResString(IDS_REQ_UNKNOWNFILE);
	}
	return sRet;
d1572 1
a1572 1

d1584 2
a1585 2

CString CUpDownClient::GetUploadFileInfo4Tooltips()
d1590 1
a1590 1
		return _T("");
d1592 1
a1592 1
	CString		sRet, strCountry, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = GetUserName();
d1594 1
d1605 1
a1605 1
	CServer* pServer = g_eMuleApp.m_pServerList->GetServerByIP(GetServerIP(), GetServerPort());
d1607 1
a1607 1
	if (pServer)
d1614 1
a1614 1
	sRet.Format(strUserInfo, strUserName, GetUserID(), strCountry, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
d1616 3
a1618 1
	CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID(this->m_reqFileHash);
d1620 6
a1625 5
	if (file)
	{
		sRet.AppendFormat(GetResString(IDS_TT_REQUESTED) + GetResString(IDS_TT_FILESTATS_SESSION) + GetResString(IDS_TT_FILESTATS_TOTAL),
             file->GetFileName(), file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransferred()),
             file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransferred()));
d1627 1
a1627 31
	else
	{
		sRet += GetResString(IDS_REQ_UNKNOWNFILE);
	}
	return sRet;

	EMULE_CATCH

	return _T("");
}

CString CUpDownClient::GetClientInfo4Tooltips()
{
	EMULE_TRY

	if (this == NULL)
		return _T("");

	CString	sRet, strCountry, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = GetUserName();
	in_addr	serverAddr;

	serverAddr.S_un.S_addr = GetServerIP();
	strUserName.Trim();
	strUserName.Replace(_T("<"), _T("<<"));
	strUserName.Replace(_T("\n"), _T("<br>"));
	if (g_eMuleApp.m_pIP2Country->IsIP2Country())
		strCountry.Format(_T(" (<b>%s</b>)"), GetCountryName());
	strUserInfo += GetResString(IDS_TT_CLIENT);
	strUserInfo.Insert(strUserInfo.GetLength() - 4, _T(" (<b>") + GetClientNameAndVersionString(this) + _T("</b>)"));
	strUserInfo += GetResString(IDS_TT_SERVER);
	CServer* pServer = g_eMuleApp.m_pServerList->GetServerByIP(GetServerIP(), GetServerPort());
d1629 1
a1629 1
	if (pServer)
d1631 25
a1655 4
		CString strServerName = pServer->GetListName();
		strServerName.Replace(_T("<"), _T("<<"));
		strServerName.Replace(_T("\n"), _T("<br>"));
		strUserInfo.Insert(strUserInfo.GetLength() - 4, _T(" (<b>") + strServerName + _T("</b>)"));
d1657 1
a1657 4
	sRet.Format(strUserInfo, strUserName, GetUserID(), strCountry, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
	sRet.TrimRight(_T("<br>"));

	return sRet;
d1661 1
a1661 1
	return _T("");
@


1.243
log
@minor changes
@
text
@d1602 1
d1604 9
d1651 1
d1653 9
@


1.242
log
@Tooltips alignment is now automatic;  Improved status bar tooltips
@
text
@a1641 3
	int iPos = strUserInfo.ReverseFind(_T('<'));
	if (iPos != -1)
		strUserInfo.Truncate(iPos);
d1643 1
@


1.241
log
@some fixes
@
text
@a1598 1
	strUserInfo.Replace(_T("%u"), _T("%u%s"));
a1631 1
	CString	strClient = GetResString(IDS_TT_CLIENT), strServer = GetResString(IDS_TT_SERVER);
a1632 26
	int iPos1Start = strClient.Find(_T("<t="));
	int iPos1End = strClient.Find(_T(">"), iPos1Start);
	int iPos2Start = strServer.Find(_T("<t="));
	int iPos2End = strServer.Find(_T(">"), iPos2Start);

	if (iPos1Start != -1 && iPos1End != -1 && iPos2Start != -1 && iPos2End != -1)
	{
		int iTab1 = _tstoi(strClient.Mid(iPos1Start + 3, iPos1End - (iPos1Start + 3)));
		int iTab2 = _tstoi(strServer.Mid(iPos2Start + 3, iPos2End - (iPos2Start + 3)));
		if (iTab1 > iTab2)
		{
			iTab1 = 1 + (iTab1 - iTab2);
			iTab2 = 1;
		}
		else
		{
			iTab2 = 1 + (iTab2 - iTab1);
			iTab1 = 1;
		}
		sRet.Format(strClient.Left(iPos1Start + 3) + _T("%d"), iTab1);
		sRet += strClient.Mid(iPos1End);
		strClient = sRet;
		sRet.Format(strServer.Left(iPos2Start + 3) + _T("%d"), iTab2);
		sRet += strServer.Mid(iPos2End);
		strServer = sRet;
	}
a1637 1
	strUserInfo.Replace(_T("%u"), _T("%u%s"));
d1640 2
a1641 2
	strUserInfo += strClient;
	strUserInfo += strServer;
@


1.240
log
@Totally reworked country information feature to minimize memory usage;
Corrected availability check of country name (more correct if flags weren't loaded).
@
text
@d1592 1
a1592 1
	CString		sRet, strCountry, strUserInfo = GetResString(IDS_TT_USERINFO);
d1596 3
d1604 1
a1604 1
	sRet.Format(strUserInfo, GetUserName(), GetUserID(), strCountry, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
d1632 2
a1633 3
	CString	sRet, strCountry, strUserInfo = GetResString(IDS_TT_USERINFO);
	CString	strClient = GetResString(IDS_TT_CLIENT);
	CString	strServer = GetResString(IDS_TT_SERVER);
d1663 3
d1674 1
a1674 1
	sRet.Format(strUserInfo, GetUserName(), GetUserID(), strCountry, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
@


1.239
log
@better estimation of own score on remote client + no more friend/community guess + minor Infolist fix + removed unused functions
@
text
@d93 1
a93 1
	m_structUserCountry = g_eMuleApp.m_pIP2Country->GetDefaultIP2Country();
d165 1
a165 1
			m_structUserCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
d465 2
a466 2
		if (m_structUserCountry == g_eMuleApp.m_pIP2Country->GetDefaultIP2Country())
			m_structUserCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
d1597 1
a1597 1
	if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d1662 1
a1662 1
	if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d1988 1
a1988 1
CString	CUpDownClient::GetCountryName(bool bShortName) const
d1990 1
a1990 12
	if (!g_eMuleApp.m_pIP2Country->IsIP2Country())
		return _T("");

	if(bShortName)
		return m_structUserCountry->ShortCountryName;

	return m_structUserCountry->LongCountryName;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CUpDownClient::GetCountryFlagIndex() const
{
	return m_structUserCountry->FlagIndex;
d1995 1
a1995 1
	m_structUserCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwUserIP);
@


1.238
log
@minor changes (function renamings, unused typedef removal)
@
text
@a133 1
	m_uRemoteClientSpeed = 0;
a149 2
	m_bRemoteCommunity = false;
	m_bRemoteCommunityEnabled = false;
@


1.237
log
@minor correction
@
text
@d521 1
a521 1
		&& g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d582 1
a582 1
		&& g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d966 1
a966 1
	if (GetClientSoft() == SO_MLDONKEY && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d1213 1
a1213 1
			if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
d1233 1
a1233 1
				if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
@


1.236
log
@Reworked file completion algorithm to eliminate file locking in completing state.
@
text
@d1639 1
a1639 1
	int iPos2End = strClient.Find(_T(">"), iPos2Start);
d1647 1
a1647 1
			iTab1 = iTab1 - iTab2 + 1;
d1652 1
a1652 1
			iTab2 = iTab2 - iTab1 + 1;
@


1.235
log
@better string processing
@
text
@a194 2
	pUploadingPartFile = NULL;

@


1.234
log
@minor change
@
text
@d75 1
a75 1
	m_strFullUserIP = "";
d92 1
a92 1
	m_strUserName = "";
d108 2
a109 2
	m_strModVersion = "";
	m_strModExtended = "";
d141 1
a141 1
	m_strComment = _T("");
d241 1
a241 1
		m_strComment = _T("");
d1061 1
a1061 1
						m_strComment = _T("");
d1612 3
a1614 5
		sRet.AppendFormat(GetResString(IDS_TT_REQUESTED), CString(file->GetFileName()));

		sRet.AppendFormat( GetResString(IDS_TT_FILESTATS_SESSION) + GetResString(IDS_TT_FILESTATS_TOTAL),
		             file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransferred()),
		             file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransferred()) );
@


1.233
log
@better way for creating On Queue/Known Clients tooltips
@
text
@d1636 1
a1636 1
	CString	sRet, strTemp, strUserInfo = GetResString(IDS_TT_USERINFO);
d1647 2
a1648 4
		strTemp = strClient.Mid(iPos1Start + 3, iPos1End - (iPos1Start + 3));
		int iTab1 = _tstoi(strTemp);
		strTemp = strServer.Mid(iPos2Start + 3, iPos2End - (iPos2Start + 3));
		int iTab2 = _tstoi(strTemp);
d1659 6
a1664 6
		strTemp.Format(strClient.Left(iPos1Start + 3) + _T("%d"), iTab1);
		strTemp += strClient.Mid(iPos1End);
		strClient = strTemp;
		strTemp.Format(strServer.Left(iPos2Start + 3) + _T("%d"), iTab2);
		strTemp += strServer.Mid(iPos2End);
		strServer = strTemp;
d1670 1
a1670 3
		strTemp.Format(_T(" (<b>%s</b>)"), GetCountryName());
	else
		strTemp = _T("");
d1676 1
a1676 1
	sRet.Format(strUserInfo, GetUserName(), GetUserID(), strTemp, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
@


1.232
log
@added tooltips in On Queue & Known Clients lists
@
text
@d1636 4
a1639 5
	CString		sRet, strCountry, strUserInfo = GetResString(IDS_TT_USERINFO);
	in_addr		serverAddr;

	CString strClient = GetResString(IDS_TT_CLIENT);
	CString strServer = GetResString(IDS_TT_SERVER);
d1647 5
a1651 5
		CString strNewTab1 = strClient.Mid(iPos1Start + 3, iPos1End - 1);
		CString strNewTab2 = strServer.Mid(iPos2Start + 3, iPos2End - 1);
		int iTab1 = _tstoi(strNewTab1);
		int iTab2 = _tstoi(strNewTab2);
		while (iTab1 > 1 && iTab2 > 1)
d1653 7
a1659 2
			iTab1--;
			iTab2--;
a1660 1
		CString strTemp;
d1672 3
a1674 1
		 strCountry.Format(_T(" (<b>%s</b>)"), GetCountryName());
d1680 1
a1680 1
	sRet.Format(strUserInfo, GetUserName(), GetUserID(), strCountry, GetFullIP(), GetUserPort(), inet_ntoa(serverAddr), GetServerPort());
@


1.231
log
@no longer loading mid size names + some small changes
@
text
@a1589 1
//BEGIN Improved Tooltips
d1593 1
a1595 1
	CString sRet;
d1597 2
a1598 2
//	build info text and display it
	CString strCountry, strUserInfo = GetResString(IDS_TT_USERINFO);
d1600 1
d1604 4
a1607 1
	sRet.Format(strUserInfo, GetUserName(), GetUserID(), strCountry);
d1609 1
d1628 55
a1682 1
//END Improved Tooltips
@


1.230
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d1603 1
a1603 1
		 strCountry.Format(_T(" (<b>%s</b>)"), GetCountryName(true));
d1936 1
a1936 1
CString	CUpDownClient::GetCountryName(bool longName) const
d1938 1
a1938 5
	//display in client detail
	if(longName && g_eMuleApp.m_pIP2Country->IsIP2Country() == false)
		return GetResString(IDS_DISABLED);

	if(g_eMuleApp.m_pIP2Country->IsIP2Country() == false)
d1941 2
a1942 6
	if(longName)
		return m_structUserCountry->LongCountryName;

	return m_structUserCountry->ShortCountryName;

	/*CString tempStr;
d1944 1
a1944 13
	switch(g_eMuleApp.m_pGlobPrefs.GetIP2CountryNameMode())
	{
		case IP2CountryName_SHORT:
			tempStr.Format("<%s>",m_structUserCountry->ShortCountryName);
			return tempStr;
		case IP2CountryName_MID:
			tempStr.Format("<%s>",m_structUserCountry->MidCountryName);
			return tempStr;
		case IP2CountryName_LONG:
			tempStr.Format("<%s>",m_structUserCountry->LongCountryName);
			return tempStr;
	}
	return _T("");*/
@


1.229
log
@Translation fix
@
text
@d24 1
d63 1
d93 1
a93 1
	m_dwUserIP = 0;
d167 8
d467 6
d1599 6
a1604 1
	sRet.Format(GetResString(IDS_TT_USERINFO), GetUserName(), GetUserID());
d1936 40
@


1.228
log
@Compilation fixes and sent a log to DEBUG only
@
text
@d917 1
a917 1
		Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
@


1.227
log
@Don't even try to add client server with 0.0.0.0 IP (this eliminates unnecessary server search, server object creature and deletion).
@
text
@d375 1
d384 1
@


1.226
log
@corrected client software detection
@
text
@d396 2
a397 2
	//	... and the server isn't already in our server list ...
		if (!g_eMuleApp.m_pServerList->GetServerByIP(m_dwServerIP, m_uServerPort))
@


1.225
log
@fix for "better detection of leecher clients" :)
@
text
@d885 5
a889 1
//ReGetClientSoft();	// 9/5/2003 [Moosetea] Official client, this messes the stats up, creates lots of invalid edonkey clients
d920 1
a920 1

d1459 2
a1460 1
			switch (m_dwCompatibleClient)
d1462 1
a1462 4
				case 0:
				case 3: // unknown
				case 10: // unknown
				case 20: // unknown
d1464 1
a1464 2
					m_eClientSoft = SO_EMULE;
					break;
d1466 1
a1466 1
				case 1:
d1468 1
a1468 2
					m_eClientSoft = SO_CDONKEY;
					break;
d1470 1
a1470 1
				case 2:
d1472 2
a1473 2
					m_eClientSoft = SO_LMULE;
					break;
d1475 14
a1488 1
				case 4:
d1490 1
a1490 2
					m_eClientSoft = SO_SHAREAZA;
					break;
d1492 1
a1492 1
				default:
d1494 2
a1495 6
					if (m_bIsML)
					{
						m_eClientSoft = SO_MLDONKEY;
					}
					else if (m_bIsHybrid)
					{
a1496 1
					}
d1498 1
a1498 4
					{
						m_eClientSoft = SO_EMULE;
						AddDebugLogLine(false, "%s: New Compatible ClientSoft ET_COMPATIBLECLIENT = %i client will be listed as an emule ", __FUNCTION__, m_dwCompatibleClient);
					}
d1500 1
a1500 14
			} // end: switch m_dwCompatibleClient
			break;
		}
		default:
		{
		//	If the client is an Ml donkey
			if (m_bIsML)
				m_eClientSoft = SO_MLDONKEY;
		//	We're left with donkeys and Hybrids
			if (m_bIsHybrid)
				m_eClientSoft = SO_EDONKEYHYBRID;
			else
				m_eClientSoft = SO_EDONKEY;
		}
@


1.224
log
@better detection of leecher clients
@
text
@d896 1
a896 2
		|| (GetModVersion() == _T(PLUS_VERSION_STR) 
			&& !(GetClientSoft() == SO_EMULE && GetMuleVersion() == CURRENT_VERSION_SHORT)) )
@


1.223
log
@corretions in "hash thieves", added Leecher type statistic
@
text
@d894 21
@


1.222
log
@Improved string processing
@
text
@a30 4
//--- xrmb:hashthieves1 ---
OffenseCounterMap		CUpDownClient::g_mapOffenseCounter;
HashBaseMap				CUpDownClient::g_mapHashBase;

d494 1
a494 1
	hash_map<uint64, uint32>::iterator OffenseCounterIt = g_mapOffenseCounter.find(qwIPPortID);
d496 1
a496 1
	if (OffenseCounterIt != g_mapOffenseCounter.end())
d530 1
a530 1
	hash_map<uint64, uint64>::iterator HashBaseIt = g_mapHashBase.find(qwIPPortID);
d532 1
a532 1
	if (HashBaseIt != g_mapHashBase.end())	//if (g_mapHashBase.Lookup(id, qwLastHashID) && qwLastHashID != qwNewHashID)
d550 1
a550 1
	g_mapHashBase[qwIPPortID] = qwNewHashID; //g_mapHashBase[id] = thishash;
d574 1
a574 1
		g_mapOffenseCounter[qwIPPortID] = dwUnfairClientActions + dwNewUnfairActions;
d576 1
a576 1
		g_eMuleApp.m_lTotalNumUnfairClients = g_mapOffenseCounter.size();
@


1.221
log
@some refactoring : IsStolenName & IsLeecherType were moved into otherfunctions.cpp
@
text
@d61 1
a61 1
		m_strFullUserIP.Format( _T("%i.%i.%i.%i"),
d1539 4
a1542 3
		sRet += GetResString(IDS_SF_REQUESTED) + CString(file->GetFileName()) + _T("\n");
		CString stat;
		stat.Format( GetResString(IDS_FILESTATS_SESSION) + GetResString(IDS_FILESTATS_TOTAL),
a1544 1
		sRet += stat;
a1550 2

	return _T("");
a1557 1
		return;
d1559 4
a1562 1
	md4cpy(m_userHash, m_achstrTempUserHash);
d1578 1
a1578 2
		CString sFileName;
		sFileName.Format(GetResString(IDS_TT_REQUESTED), CString(file->GetFileName()));
d1580 1
a1580 2
		CString stat;
		stat.Format( sFileName + GetResString(IDS_TT_FILESTATS_SESSION) + GetResString(IDS_TT_FILESTATS_TOTAL),
a1582 1
		sRet += stat;
@


1.220
log
@speed optimization (caching of 2 tags with constant value from hello packet)
@
text
@d557 1
a557 1
	if (IsStolenName())
a593 48

bool CUpDownClient::IsStolenName() const
{
	EMULE_TRY

	if ( !m_strUserName.IsEmpty() && (
         //--- equals ---
	         m_strUserName == "pbwll" ||
	         m_strUserName == "unix user" ||
	         m_strUserName == "http://emule-element.tk" // EC 14.08.03 0-Upload Mod default nickname
         //--- begins with ---
	         || m_strUserName.Find("Odin") != -1
	         || m_strUserName.Find("$GAM3R$") != -1
	         || m_strUserName.Find("G@@m3rs Edit") != -1
	         || m_strUserName.Find("G@@m3rs Edit") != -1
	         || m_strUserName.Find( "[RAMMSTEIN" ) != -1
	         || m_strUserName.Find("[toXic]") != -1
	         || m_strUserName.Find("Leecha") != -1
	         || m_strUserName.Find("leecha") != -1
	         || m_strUserName.Find("eDevil") != -1
	         || m_strUserName.Find("darkmule") != -1
	         || m_strUserName.Find("DarkMule") != -1
	         || m_strUserName.Find("eVortex") != -1
	         || m_strUserName.Find("|eVorte|X|") != -1
	         || m_strUserName.Find("MISON") != -1
	         || m_strUserName.Find("Mison") != -1 ) )
	{
		return true;
	}

	EMULE_CATCH
	return false;
}

bool CUpDownClient::IsLeecherType() const
{
	EMULE_TRY

	if ( !m_strModVersion.IsEmpty() && (
	         m_strModVersion.Find("eVortex") != -1
	         || m_strModVersion.Find("Mison") != -1 ) )
	{
		return true;
	}

	EMULE_CATCH
	return false;
}
@


1.219
log
@removed old search code + some fix and changes
@
text
@d1006 1
d1011 6
a1016 1

d1020 5
@


1.218
log
@functional optimization
@
text
@d507 2
a508 2
	if (g_eMuleApp.m_pServerConnect->GetClientID() != m_dwUserID 
		&& md4cmp(m_userHash, g_eMuleApp.m_pGlobPrefs->GetUserHash()) == 0 
d518 1
a518 1
		                 (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24), m_uUserPort, 
d535 1
a535 1
	
d548 1
a548 1
			                 (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24), m_uUserPort, 
d569 1
a569 1
	if ((dwUnfairClientActions + dwNewUnfairActions) >= 3 
a1558 1
#ifdef NEW_SEARCH_ENABLED
a1559 3
#else
		g_eMuleApp.m_pSearchList->ProcessSearchAnswer(pachPacket, dwSize, this, strDirectory, bFirstDir);
#endif // NEW_SEARCH_ENABLED
@


1.217
log
@formatting;
more button code comitted but not compiled as default
@
text
@a223 10
//	If downloadBlocks are existing free block reserved in pPartFile
	while (!m_downloadBlocksList.IsEmpty())
	{
		Requested_Block_Struct* pDLBlock =  m_downloadBlocksList.RemoveHead();
		CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pDLBlock->m_fileHash);

		pReqFile->RemoveBlockFromList(pDLBlock->m_dwStartOffset, pDLBlock->m_dwEndOffset);
		delete pDLBlock;
	}
	
d229 1
a230 15
	/*
	while (!m_pendingBlocksList.IsEmpty())
	{
		Pending_Block_Struct		*pPending = m_pendingBlocksList.RemoveHead();

		delete pPending->m_pRequestedBlock;
	//	Not always allocated
		if (pPending->m_pZStream)
		{
			inflateEnd(pPending->m_pZStream);
			delete pPending->m_pZStream;
		}
		delete pPending;
	}
	*/
@


1.216
log
@Fixed and optimized hash map calculation (before bits 63-32 were almost always = 1).
@
text
@d1583 3
d1587 1
@


1.215
log
@formatting; minor changes; something was missed in last commit (Aw3 ???); always keep paused and stopped files at bottom in downloadlist
@
text
@d551 7
a557 6
	//calculate a HASH-ID
	for (int i = 0; i < 8; i++)
	{
		qwNewHashID += GetUserHash()[i] << (i * 8) ^ GetUserHash()[i + 8] << (i * 8);
	}
	// check a map
@


1.214
log
@Unrequired code removal
@
text
@d224 1
a224 1
	//if downloadBlocks are existing free block reserved in pPartFile
@


1.213
log
@fixed block reservation by deleted client. addtion
@
text
@d335 1
a335 1
					BYTE	crashHash[16];
a336 5
					md4cpy(crashHash, m_userHash);

					CString		buffer = FileHashToString(crashHash);

//					AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
@


1.212
log
@fixed block reservation by deleted client
@
text
@d224 1
d227 5
a231 1
		delete m_downloadBlocksList.RemoveHead();
d233 1
@


1.211
log
@extended filtered stats
@
text
@d232 3
d248 1
@


1.210
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d1238 2
a1239 1
			g_eMuleApp.stat_filteredclients++;
d1255 2
a1256 1
				g_eMuleApp.stat_filteredclients++;
@


1.209
log
@speed optimization & output in stats of the feature "countermeasures against unfair client"
@
text
@d62 4
a65 4
								static_cast<uint8>(m_dwUserID),
								static_cast<uint8>(m_dwUserID >> 8),
								static_cast<uint8>(m_dwUserID >> 16),
								static_cast<uint8>(m_dwUserID >> 24) );
d269 1
a269 1
	uint8		byteHashSize;
d533 2
a534 2
		InterlockedIncrement(&g_eMuleApp.m_dwTotalNumUnfairActions);
		InterlockedIncrement(&g_eMuleApp.m_dwTotalNumUseMyHashActions);
d537 1
a537 1
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, 
d561 2
a562 2
			InterlockedIncrement(&g_eMuleApp.m_dwTotalNumUnfairActions);
			InterlockedIncrement(&g_eMuleApp.m_dwTotalNumHashChangeActions);
d566 1
a566 1
			                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, 
d579 2
a580 2
		InterlockedIncrement(&g_eMuleApp.m_dwTotalNumUnfairActions);
		InterlockedIncrement(&g_eMuleApp.m_dwTotalNumStolenNameActions);
d583 1
a583 1
		        (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (dwUnfairClientActions + dwNewUnfairActions), g_dwTotalNumUnfairActions );
d598 1
a598 1
		g_eMuleApp.m_dwTotalNumUnfairClients = g_mapOffenseCounter.size();
d678 1
a678 1
		uint8		byteHashSize = 16;
d701 1
a701 1
		uint8 uClientVersion = CURRENT_VERSION_SHORT;
d703 1
a703 1
		uint8 uProtVersion = EMULE_PROTOCOL;
d750 1
a750 1
	uint8 protversion;
d1716 1
a1716 1
	uint8		byteChallengeIPKind = 0;
d1737 1
a1737 1
	uint8		siglen = g_eMuleApp.m_pClientCreditList->CreateSignature(m_pCredits, achBuffer, 250, ChallengeIP, byteChallengeIPKind);
@


1.208
log
@final fix for excessive resizing on column resize bug + few optimisations and formatting
@
text
@d510 1
d513 11
a523 10
	uint64 id = GetUID();
	uint32 last_actions = 0;
	uint32 i_TotalClients = 0;
	uint32 i_TotalClientActions = 0;
	uint32 i_TotalActions = g_mapOffenseCounter[0];
	if (g_mapOffenseCounter.Lookup(id, i_TotalClientActions))
		i_TotalClients = g_mapOffenseCounter.GetSize() - 1;
	else
		i_TotalClients = g_mapOffenseCounter.GetSize();
//	now start to check actions
d525 4
a528 2

	if (g_eMuleApp.m_pServerConnect->GetClientID() != m_dwUserID && md4cmp(m_userHash, g_eMuleApp.m_pGlobPrefs->GetUserHash()) == 0 && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d532 4
a535 3
		last_actions++;
		i_TotalActions++;

d537 3
a539 1
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d543 4
a546 3
//--- detect id-changer ---
	uint64 lasthash;
	uint64 thishash = 0;
d548 9
a556 2
		thishash += GetUserHash()[i] << (i * 8) ^ GetUserHash()[i + 8] << (i * 8);
	if (g_mapHashBase.Lookup(id, lasthash) && lasthash != thishash)
d559 11
a569 5
		last_actions++;
		i_TotalActions++;

		AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d571 2
a572 1
	g_mapHashBase[id] = thishash;
d574 1
a574 1
//--- famous stolen hashs/names ---
d578 4
a581 3
		last_actions++;
		i_TotalActions++;

d583 2
a584 1
		        (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions );
d587 2
a588 1
	if ((i_TotalClientActions + last_actions) >= 3 && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d593 2
a594 1
	if (last_actions != 0)
d596 3
a598 2
		g_mapOffenseCounter[id] = i_TotalClientActions + last_actions;
		g_mapOffenseCounter[0] = i_TotalActions;
@


1.207
log
@Formatting, comments, and name changes.
@
text
@d143 1
a143 1
	m_strComment = "";
d249 1
a249 1
		m_strComment = "";
d1051 1
a1051 1
						m_strComment = "";
@


1.206
log
@Fixed user hash masking for MlDonkey; Optimized hash processings
@
text
@d961 1
a961 1
	uchar		hash[16];
d975 1
a975 1
			uint32 uiRnd = rand();
d977 2
a978 2
			hash[5] = static_cast<uchar>(uiRnd);
			hash[14] = static_cast<uchar>(uiRnd >> 8);
@


1.205
log
@removed old #define KEEP_BANNED_CLIENTS
@
text
@d496 1
a496 2
		for (int i = 0; i < 16; i++)
			m_pFriend->m_abyUserhash[i] = GetUserHash()[i];
d961 1
a961 1
	BYTE		hash[16];
d973 1
a973 1
		while ((hash[5] == 14) && (hash[14] = 111))
d975 1
a975 1
			BYTE	random = rand();
d977 3
a979 4
			memcpy2(&hash[5], &random, 1);
			random = rand();
			memcpy2(&hash[14], &random, 1);
		}
@


1.204
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@a199 11
#if KEEP_BANNED_CLIENTS
//
//	Log deletion of banned client
//
	if (m_bBanned && !g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
	{
	//	Enable cm-logging and set breakpoint here to see from where (shift-f11) it's been deleted
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Deleting banned client '%s' by releasing object"), __FUNCTION__, GetUserName());
	}
#endif

d1144 1
a1144 9
#if KEEP_BANNED_CLIENTS
	//	SyruS no deletion of banned client //this works...
		if (m_bBanned)
		{
			bDelete = false;
			if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Keeping banned client '%s' after disconnect"), __FUNCTION__, GetUserName());
		}
#endif
@


1.203
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d162 1
a162 1
		memset2(&sockAddr, 0, sizeof(sockAddr));
d479 1
a479 1
	memset2(&sockAddr, 0, sizeof(sockAddr));
d656 1
a656 1
		memset2(&sockAddr, 0, sizeof(sockAddr));
@


1.202
log
@Formatting, comments, and name changes.
@
text
@d406 1
a406 1
			break;
d713 1
a713 1
		
@


1.201
log
@minor changes to DebugLog and remove some marks
@
text
@d1210 2
a1211 1
	if (g_eMuleApp.m_pListenSocket->TooManySockets() && !bIgnoreMaxCon && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
d1216 3
d1220 1
a1220 1
//	BavarianSnail - filter LowIDs separately from HighIDs
d1223 1
a1223 1
	//	case 1: it's a Client with known IP, always test m_dwUserIP instead of m_dwUserID
d1228 1
a1228 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1236 1
d1240 1
a1240 1
		if ((unsigned)m_dwUserID > 0xFFFFFF)
d1242 1
a1242 1
		//	case 2: it's HighID with m_dwUserIP empty, test m_dwUserID instead
d1246 1
a1246 1
					AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1258 2
a1259 1
//	-BavarianSnail
d1263 1
d1265 1
d1272 1
d1274 2
a1275 1
		//Never connect lowID to lowID
d1278 1
a1278 1
#endif //OLD_SOCKETS_ENABLED
d1300 1
d1306 1
a1306 1
#endif //OLD_SOCKETS_ENABLED
d1311 1
d1313 1
d1321 1
d1330 1
d1333 1
d1366 1
a1366 1

d1370 1
d1372 4
a1375 1
//	ok we have a connection, lets see if we want anything from this client
d1377 1
d1379 2
d1385 3
a1387 3
		m_bReaskPending = false;
		SetDownloadState(DS_CONNECTED);
		SendFileRequest();
d1389 1
d1399 1
a1403 1
		if (g_eMuleApp.m_pUploadQueue->IsDownloading(this))
d1405 3
a1407 1
			SetUploadState(US_UPLOADING);
d1409 3
a1411 1
			Packet		*pPacket = new Packet(OP_ACCEPTUPLOADREQ);
a1412 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1414 2
d1417 2
a1418 4
			m_pRequestSocket->SendPacket(pPacket, true);
#endif //OLD_SOCKETS_ENABLED

			SetLastGotULData();	//eklmn: set Upload Timer
d1421 1
d1425 1
d1427 1
a1428 1

d1430 2
a1431 1
#endif //OLD_SOCKETS_ENABLED
a1432 1
	}
d1435 1
a1435 1

d1549 1
d1556 1
d1559 2
a1560 2

void CUpDownClient::ProcessSharedFileList(char* pachPacket, uint32 nSize, LPCTSTR pszDirectory)
d1563 1
d1566 2
a1567 1
		bool bFirstDir = (m_iFileListRequested == m_iFileListRequestedSave);
d1569 1
a1569 1
		g_eMuleApp.m_pSearchList->ProcessSearchAnswer(pachPacket, nSize, this, pszDirectory, bFirstDir);
d1571 1
d1574 1
a1574 1

@


1.200
log
@Formatting, comments, and name changes.
@
text
@d412 1
a412 1
					TagToDebugLogLine(RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), pTempTag->GetSpecialTag());	// DbT:Logging
d908 1
a908 1
//						TagToDebugLogLine(RGB_LOG_WARNING + _T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), pTempTag->GetSpecialTag());	// DbT:Logging
d910 2
a911 2
//					AddDebugLogLine( false, RGB_LOG_WARNING + _T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
//					                 __FUNCTION__, pTempTag->GetSpecialTag(), pTempTag->GetIntValue(), pTempTag->GetStringValue(), m_strUserName, GetClientNameAndVersionString(this) );
@


1.199
log
@*** empty log message ***
@
text
@d314 1
a314 1
	packetStream.Read(&m_uUserPort, 2); // hmm clientport is sent twice - why?
d320 3
a322 3
	bool			bCrashed = false; //Vorlost
	bool			bWrongPort = false; // obaldin
	CClientTag	   *pTempTag = NULL;	//eklmn: small tag optimization to prevent memleaks
d326 1
a326 1
		pTempTag = new CClientTag(packetStream);	//eklmn: small tag optimization to prevent memleaks
d331 1
a331 1
				m_strUserName.Empty();	//clear a user name
d336 1
a336 1
					uchar	crashHash[16];
d346 1
d348 1
d358 1
d420 1
a420 1
		pTempTag = NULL;	//eklmn: small tag optimization to prevent memleaks
d423 1
a423 1
//	check server parameters & add it to the list
d426 5
a430 2
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && !bCrashed)
	{  // obaldin: we shouldn't trust the client who tried to crash us
d433 2
a434 1
			in_addr addhost;
d436 6
a441 4
			CServer* addsrv = new CServer(m_uServerPort, CString(inet_ntoa(addhost)));
			addsrv->SetListName(addsrv->GetAddress());
			if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(addsrv, true))
				delete addsrv;
d449 4
a452 3
		uint32 test;
		packetStream.Read(&test, 4);
		if (test == 'KDLM')
a461 7
//	7/03/2003 [moosetea] Is this commented out for a reason? it cleans up client version numbers, specifically hybrids in the main client
//if( m_dwClientVersion > 10000 && m_dwClientVersion < 100000 )
//	m_dwClientVersion = m_dwClientVersion - (m_dwClientVersion/10000)*10000;
//if( m_dwClientVersion > 1000 )
//	m_dwClientVersion = m_dwClientVersion - (m_dwClientVersion/1000)*1000;
//if( m_dwClientVersion < 100 )
//	m_dwClientVersion *= 10;
d464 1
d467 3
a469 2
		CString ip_addr;
		UINT port;
d471 3
a473 1
		AddDebugLogLine(false, _T("%s: User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d."), __FUNCTION__, m_strUserName, m_dwClientVersion, ip_addr, m_uUserPort);
d477 2
a478 1
	SOCKADDR_IN sockAddr;
d480 3
a482 1
	uint32 dwSockAddrLen = sizeof(sockAddr);
a483 1

d490 1
a490 1
//	If lancast is enabled check to see if this client is on the LAN
a645 1
//v:- eklmn: do something if there is a m_pRequestSocket
a649 1
//	if IP is filtered, dont greet him but disconnect...
d651 1
d658 1
a658 1
		uint32	dwSockAddrLen = sizeof(sockAddr);
d663 1
a663 1
		uint8	hashsize = 16;
d665 1
a665 1
		packetStream.Write(&hashsize, 1);
d668 1
a668 1
		Packet	*packet = new Packet(&packetStream);
d670 3
a672 3
		packet->m_eOpcode = OP_HELLO;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
		m_pRequestSocket->SendPacket(packet, true);
d714 1
a714 1
		Packet* packet = new Packet(&packetStream, OP_EMULEPROT);
d716 1
a716 1
			packet->m_eOpcode = OP_EMULEINFO;
d718 1
a718 1
			packet->m_eOpcode = OP_EMULEINFOANSWER;
d720 2
a721 2
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
		m_pRequestSocket->SendPacket(packet, true, true);
d960 4
a963 4
		Packet* packet = new Packet(&packetStream);
		packet->m_eOpcode = OP_HELLOANSWER;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
		m_pRequestSocket->SendPacket(packet, true);
d968 2
a969 2

void CUpDownClient::SendHelloTypePacket(CMemFile& packetStream)
d972 3
a974 5
//	By Maverick
//	Emulate eDonkey or MlDonkey in case of a connection to a MlDonkey
//	This patch is introduced to conteract the MlDonkey's politics against
//	eMule. (eMules can only occupy 1/3 of the upload queue of a MlDonkey)
	uchar hash[16];
d976 6
a981 7
//	Checking for MLDonkey does not help anymore since they have removed this feature so
//	we emulate now an eDonkey to all except eMule. Note do not loose a word about this
//	in any forum. Otherwise we have to adapt to them again.
//	Does not help anymore either mlDonkey uses eMule type userhashes
//	Furthermore the servers have a problem with this feature so I had to go back to
//	emulating only with MlDonkey
	if (GetClientSoft() == SO_MLDONKEY && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())		//Cax2 only if enabled
d983 2
d987 2
a988 1
			uint8	random = rand();
d994 2
a995 2
	packetStream.Write(hash, 16);
//	END Patch Maverick
d997 1
d999 1
a999 2
	uint32 clientid = g_eMuleApp.m_pServerConnect->GetClientID();
	packetStream.Write(&clientid, 4);
d1002 19
a1020 14
	uint16 nPort = g_eMuleApp.m_pGlobPrefs->GetListenPort();  //Maverick
	packetStream.Write(&nPort, 2);
	uint32 dwTagCount = 2;
	packetStream.Write(&dwTagCount, 4);
	CClientTag* tag = new CClientTag(CT_NAME, g_eMuleApp.m_pGlobPrefs->GetUserNick().GetBuffer());
	tag->WriteToFile(packetStream);
	delete tag;
	tag = new CClientTag(CT_VERSION, EDONKEYVERSION);
	tag->WriteToFile(packetStream);
	delete tag;
//	tag = new CTag(CT_PORT,nPort); //Maverick
//	tag->WriteToFile(packetStream);
//	delete tag;
	uint32 dwIP = 0;
d1030 2
a1031 2
	packetStream.Write(&dwIP, 4);
	packetStream.Write(&nPort, 2);
d1034 2
a1035 2

void CUpDownClient::ProcessMuleCommentPacket(char* pbytePacket, uint32 dwSize)
d1038 1
d1041 1
a1041 1
		CSafeMemFile packetStream((BYTE*)pbytePacket, dwSize);
d1208 1
d1215 1
d1223 1
d1225 1
d1234 2
a1235 1
		if ((unsigned)m_dwUserID > 16777215)
d1310 1
a1310 1
			Packet		*packet = new Packet(OP_CALLBACKREQUEST, 4);
d1312 3
a1314 3
			memcpy2(packet->m_pcBuffer, &m_dwUserID, 4);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
			g_eMuleApp.m_pServerConnect->SendPacket(packet);
d1382 4
a1385 2
			Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d1388 1
a1388 1
			m_pRequestSocket->SendPacket(packet, true);
d1396 2
a1397 2
		Packet * packet = new Packet(m_bSupportsAskSharedDirs ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
d1400 1
a1400 1
		m_pRequestSocket->SendPacket(packet, true, true);
d1611 2
a1612 1

d1618 1
a1618 1
//	send our public key to the client who requested it
d1629 1
a1629 1
	Packet		*packet = new Packet(OP_PUBLICKEY, g_eMuleApp.m_pClientCreditList->GetPubKeyLen() + 1, OP_EMULEPROT);
d1631 3
a1633 3
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
	memcpy2(packet->m_pcBuffer + 1, g_eMuleApp.m_pClientCreditList->GetPublicKey(), g_eMuleApp.m_pClientCreditList->GetPubKeyLen());
	packet->m_pcBuffer[0] = g_eMuleApp.m_pClientCreditList->GetPubKeyLen();
d1636 1
a1636 1
	m_pRequestSocket->SendPacket(packet, true, true);
d1641 1
a1641 1

d1669 2
a1670 1
	bool bUseV2;
d1676 2
a1677 2
	uint8 byChaIPKind = 0;
	uint32 ChallengeIP = 0;
d1684 1
a1684 1
		//	we cannot do not know for sure our public ip, so use the remote clients one
d1686 1
a1686 1
			byChaIPKind = CRYPT_CIP_REMOTECLIENT;
d1691 1
a1691 1
			byChaIPKind = CRYPT_CIP_LOCALCLIENT;
d1696 3
a1698 2
	uchar achBuffer[250];
	uint8 siglen = g_eMuleApp.m_pClientCreditList->CreateSignature(m_pCredits, achBuffer, 250, ChallengeIP, byChaIPKind);
d1704 5
a1708 4
	Packet* packet = new Packet(OP_SIGNATURE, siglen + 1 + ((bUseV2) ? 1 : 0), OP_EMULEPROT);
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
	memcpy2(packet->m_pcBuffer + 1, achBuffer, siglen);
	packet->m_pcBuffer[0] = siglen;
d1710 1
a1710 1
		packet->m_pcBuffer[1 + siglen] = byChaIPKind;
d1713 1
a1713 1
	m_pRequestSocket->SendPacket(packet, true, true);
d1755 2
a1756 2

void CUpDownClient::ProcessSignaturePacket(uchar* pbytePacket, uint32 dwSize)
d1761 2
a1762 1
//	here we spread the good guys from the bad ones ;)
d1772 14
a1785 5
	uint8 byChaIPKind;
	if (pbytePacket[0] == dwSize - 1)
		byChaIPKind = 0;
	else if (pbytePacket[0] == dwSize - 2 && (m_byteSupportSecIdent & 2) > 0) //v2
		byChaIPKind = pbytePacket[dwSize - 1];
d1795 1
a1795 1
//	we accept only one signature per IP, to avoid floods which need a lot cpu time for cryptfunctions
d1798 1
d1802 1
a1802 1
//	also make sure this client has a public key
d1808 1
a1808 1
//	and one more check: did we ask for a signature and sent a challange packet?
d1815 1
a1815 1
	if (g_eMuleApp.m_pClientCreditList->VerifyIdent(m_pCredits, pbytePacket + 1, pbytePacket[0], GetIP(), byChaIPKind))
d1817 2
a1818 2
	//	result is saved in function abouve
	//g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "'%s' has passed the secure identification, V2 State: %i", GetUserName(), byChaIPKind);
d1822 3
a1824 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: '%s' has failed the secure identification, V2 State: %i", __FUNCTION__, GetUserName(), byChaIPKind);
d1829 1
a1829 1

d1833 3
a1835 2
	uint8 nValue = 0;
	if (m_pCredits)
d1840 3
a1842 1
				nValue = IS_KEYANDSIGNEEDED;
d1844 3
a1846 1
				nValue = IS_SIGNATURENEEDED;
d1848 2
a1849 1
		if (nValue == 0)
a1853 1

d1857 2
a1858 1
		uint32 dwRandom = rand() + 1;
d1860 1
d1862 4
d1867 3
a1869 2
		DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Sending SecIdentState Packet, state: %i (to '%s')", __FUNCTION__, nValue, GetUserName()));
#endif
a1870 4
		Packet* packet = new Packet(OP_SECIDENTSTATE, 5, OP_EMULEPROT);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
		packet->m_pcBuffer[0] = nValue;
		memcpy2(packet->m_pcBuffer + 1, &dwRandom, sizeof(dwRandom));
d1872 1
a1872 2

		m_pRequestSocket->SendPacket(packet, true, true);
d1878 1
a1878 1
void CUpDownClient::ProcessSecIdentStatePacket(uchar* pbytePacket, uint32 dwSize)
d1880 1
a1880 1
	if (dwSize != 5)
d1882 1
a1882 1
	if (!m_pCredits)
d1888 2
a1889 2
		m_eSecureIdentState = IS_UNAVAILABLE;
		break;
d1891 2
a1892 2
		m_eSecureIdentState = IS_SIGNATURENEEDED;
		break;
d1894 2
a1895 2
		m_eSecureIdentState = IS_KEYANDSIGNEEDED;
		break;
d1897 2
a1898 1
	uint32 dwRandom;
d1901 1
a1902 1

d1906 3
a1908 1

a1910 2
//	indicates that both Information Packets has been received
//	needed for actions, which process data from both packets
d1912 1
d1915 1
d1921 1
a1921 1

@


1.198
log
@forgotten name changes :o) don't u compile b4 commit, morevit?
@
text
@d342 2
a343 2
					AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
					m_strUserName = _T("[Invalid user name]"); //Vorlost
@


1.197
log
@Formatting, comments, and name changes.
@
text
@d1022 1
a1022 1
void CUpDownClient::ProcessMuleCommentPacket(char* pachPacket, uint32 nSize)
@


1.196
log
@recommit for "Completion Fix" with Aw3 correction
@
text
@d274 1
a274 1
bool CUpDownClient::ProcessHelloPacket(char* pachPacket, uint32 nSize)
d277 8
a284 4
	CSafeMemFile data((BYTE*)pachPacket, nSize);
	uint8 hashsize;
	data.Read(&hashsize, 1);
	return ProcessHelloTypePacket(data);
d286 1
d289 2
a290 2

void CUpDownClient::ProcessHelloAnswer(char* pachPacket, uint32 nSize)
d293 2
a294 2
	CSafeMemFile data((BYTE*)pachPacket, nSize);
	ProcessHelloTypePacket(data);
d297 2
a298 2

bool CUpDownClient::ProcessHelloTypePacket(CSafeMemFile& data)
d301 1
d304 21
a324 12
	data.Read(&m_userHash, 16);
	uint32 nUserID;
	data.Read(&nUserID, 4);
	if (!m_dwUserID)
		SetUserID(nUserID);
	data.Read(&m_uUserPort, 2); // hmm clientport is sent twice - why?
	uint32	tagcount;
	data.Read(&tagcount, 4);
	bool crashed = false;
	bool wrong_port = false;
	CClientTag* strTemptag;	//eklmn: small tag optimization to prevent memleaks
	for (uint32 i = 0;i < tagcount; i++)
d326 2
a327 2
		strTemptag = new CClientTag(data);	//eklmn: small tag optimization to prevent memleaks
		switch (strTemptag->GetSpecialTag())
a329 2
			m_strUserName.Empty();	//clear a user name
			if (strTemptag->GetStringValue().IsEmpty())
d331 17
a347 6
				crashed = true;
				uchar crashash[16];
				md4cpy(crashash, m_userHash);
				CString buffer = FileHashToString(crashash);
//				AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
				m_strUserName = _T("[Invalid user name]");
a348 3
			else
				m_strUserName.SetString(strTemptag->GetStringValue(), strTemptag->GetStringValue().GetLength()); //eklmn: used CSimpleString class & fuctions
			break;
d350 4
a353 2
			m_dwClientVersion = strTemptag->GetIntValue();
			break;
a354 1
			if (strTemptag->GetIntValue() != m_uUserPort && GetClientSoft() != SO_EDONKEYHYBRID)
d356 5
a360 1
				wrong_port = true;
a361 1
			break;
d364 1
a364 1
				m_strModVersion = strTemptag->GetStringValue();
d406 1
a406 1
				if (!strTemptag->GetStringValue().IsEmpty())
d408 2
a409 2
					CString buffer = strTemptag->GetStringValue();
					TagToDebugLogLine(RGB_LOG_DIMMED + _T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d412 2
a413 2
				                 __FUNCTION__, /*strTemptag->GetSpecialTag(),*/ static_cast<int>(strTemptag->GetSpecialTag()),
								 strTemptag->GetIntValue(), strTemptag->GetStringValue(), m_dwClientVersion, m_strUserName );
d416 2
a417 2
		delete strTemptag;
		strTemptag = NULL;	//eklmn: small tag optimization to prevent memleaks
d421 3
a423 3
	data.Read(&m_dwServerIP, 4);
	data.Read(&m_uServerPort, 2);
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && !crashed)
d438 1
a438 1
	if (data.GetLength() - data.GetPosition() == 4)
d441 1
a441 1
		data.Read(&test, 4);
d461 1
a461 1
	if (wrong_port && !m_bIsHybrid)
d654 1
a654 1
		CMemFile	data;
d657 2
a658 2
		data.Write(&hashsize, 1);
		SendHelloTypePacket(data);
d660 1
a660 1
		Packet	*packet = new Packet(&data);
d676 1
a676 1
		CMemFile data;
d679 1
a679 1
		data.Write(&uClientVersion, 1);
d681 1
a681 1
		data.Write(&uProtVersion, 1);
d683 1
a683 1
		data.Write(&dwTagCount, 4);
d686 1
a686 1
		tag1.WriteToFile(data);
d688 1
a688 1
		tag2.WriteToFile(data);
d690 1
a690 1
		tag3.WriteToFile(data);
d692 1
a692 1
		tag4.WriteToFile(data);
d694 1
a694 1
		tag5.WriteToFile(data);
d696 1
a696 1
		tag6.WriteToFile(data);
d698 1
a698 1
		tag7.WriteToFile(data);
d700 1
a700 1
		tag8.WriteToFile(data);	 //More harmless than the other 2! :D
d702 1
a702 1
		tag9.WriteToFile(data);			//<<-- enkeyDEV(th1) -L2HAC-
d704 1
a704 1
		tag10.WriteToFile(data);
d706 1
a706 1
		Packet* packet = new Packet(&data, OP_EMULEPROT);
d719 1
a719 1
void CUpDownClient::ProcessMuleInfoPacket(char* pachPacket, uint32 nSize)
d722 1
a722 1
	CSafeMemFile data((BYTE*)pachPacket, nSize);
d724 1
a724 1
	data.Read(&m_byteEmuleVersion, 1);
d728 1
a728 1
	data.Read(&protversion, 1);
d761 4
a764 4
	uint32 tagcount = 0;
	data.Read(&tagcount, 4);
	CEmuleTag* strTemptag = NULL;
	for (uint32 i = 0;i < tagcount; i++)
d768 2
a769 2
		strTemptag = new CEmuleTag(data);
		if (strTemptag)
d771 1
a771 1
			switch (strTemptag->GetSpecialTag())
d775 1
a775 1
					m_byteDataCompVer = strTemptag->GetIntValue();
d780 1
a780 1
					m_uUDPPort = strTemptag->GetIntValue();
d785 1
a785 1
					m_byteUDPVer = strTemptag->GetIntValue();
d790 1
a790 1
					m_byteSourceExchangeVer = strTemptag->GetIntValue();
d795 1
a795 1
					m_byteAcceptCommentVer = strTemptag->GetIntValue();
d800 1
a800 1
					m_byteExtendedRequestsVer = strTemptag->GetIntValue();
d805 1
a805 1
					m_dwCompatibleClient = strTemptag->GetIntValue();
d814 1
a814 1
					m_strModVersion = strTemptag->GetStringValue();
d819 1
a819 1
					m_strModExtended = strTemptag->GetStringValue();
d824 1
a824 1
					m_dwDataPlusVers = strTemptag->GetIntValue();
d829 1
a829 1
					m_byteDataTarodVer = strTemptag->GetIntValue();
d881 1
a881 1
					m_dwL2HACTime = strTemptag->GetIntValue();
d892 1
a892 1
					m_byteSupportSecIdent = strTemptag->GetIntValue() & 3;
d897 1
a897 1
					if (!strTemptag->GetStringValue().IsEmpty())
d899 2
a900 2
//						CString buffer = strTemptag->GetStringValue();
//						TagToDebugLogLine(RGB_LOG_WARNING + _T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d903 1
a903 1
//					                 __FUNCTION__, strTemptag->GetSpecialTag(), strTemptag->GetIntValue(), strTemptag->GetStringValue(), m_strUserName, GetClientNameAndVersionString(this) );
d906 2
a907 2
			delete strTemptag;
			strTemptag = NULL;
d913 1
a913 1
			safe_delete(strTemptag);
d950 3
a952 3
		CMemFile data;
		SendHelloTypePacket(data);
		Packet* packet = new Packet(&data);
d961 1
a961 1
void CUpDownClient::SendHelloTypePacket(CMemFile& data)
d986 1
a986 1
	data.Write(hash, 16);
d991 1
a991 1
	data.Write(&clientid, 4);
d995 3
a997 3
	data.Write(&nPort, 2);
	uint32 tagcount = 2;
	data.Write(&tagcount, 4);
d999 1
a999 1
	tag->WriteToFile(data);
d1002 1
a1002 1
	tag->WriteToFile(data);
d1005 1
a1005 1
//	tag->WriteToFile(data);
d1017 2
a1018 2
	data.Write(&dwIP, 4);
	data.Write(&nPort, 2);
d1025 1
a1025 1
	if ((m_pReqPartFile != NULL) && (nSize > 2))
d1027 1
a1027 1
		CSafeMemFile data((BYTE*)pachPacket, nSize);
d1029 2
a1030 2
		data.Read(&m_eRating, sizeof(m_eRating));
		data.Read(&length, sizeof(length));
d1035 1
a1035 1
			data.Read(m_strComment.GetBuffer(length + 1), length);
d1291 2
a1292 1
			Packet * packet = new Packet(OP_CALLBACKREQUEST, 4);
d1607 2
a1608 1
	Packet* packet = new Packet(OP_PUBLICKEY, g_eMuleApp.m_pClientCreditList->GetPubKeyLen() + 1, OP_EMULEPROT);
d1694 1
a1694 1
void CUpDownClient::ProcessPublicKeyPacket(uchar* pachPacket, uint32 nSize)
d1702 2
a1703 2
	if ( m_pRequestSocket == NULL || m_pCredits == NULL || pachPacket[0] != nSize - 1
	     || nSize == 0 || nSize > 250 )
d1712 1
a1712 1
	if (m_pCredits->SetSecureIdent(pachPacket + 1, pachPacket[0]))
d1731 1
a1731 1
void CUpDownClient::ProcessSignaturePacket(uchar* pachPacket, uint32 nSize)
d1739 1
a1739 1
	if (m_pRequestSocket == NULL || m_pCredits == NULL || nSize == 0 || nSize > 250)
d1747 1
a1747 1
	if (pachPacket[0] == nSize - 1)
d1749 2
a1750 2
	else if (pachPacket[0] == nSize - 2 && (m_byteSupportSecIdent & 2) > 0) //v2
		byChaIPKind = pachPacket[nSize - 1];
d1779 1
a1779 1
	if (g_eMuleApp.m_pClientCreditList->VerifyIdent(m_pCredits, pachPacket + 1, pachPacket[0], GetIP(), byChaIPKind))
d1832 2
a1833 2

void CUpDownClient::ProcessSecIdentStatePacket(uchar* pachPacket, uint32 nSize)
d1835 1
a1835 1
	if (nSize != 5)
d1840 1
a1840 1
	switch (pachPacket[0])
d1853 1
a1853 1
	memcpy2(&dwRandom, pachPacket + 1, 4);
d1857 1
a1857 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received SecIdentState Packet, state: %i", __FUNCTION__, pachPacket[0]));
@


1.195
log
@Removed uneeded log
@
text
@d189 1
a189 1
//	pUploadingPartFile = NULL;
@


1.194
log
@Reverted completion 'fix' by eklmn so we can release 1j this month
@
text
@d306 2
a307 2
	bool crashed = false; //Vorlost
	bool wrong_port = false; // obaldin
d322 2
a323 3
				if (g_eMuleApp.m_pGlobPrefs->GetBugReport())
					AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
				m_strUserName = _T("[Invalid user name]"); //Vorlost
@


1.193
log
@Some minor changes by KuSh.
@
text
@d189 1
a189 1
	pUploadingPartFile = NULL;
@


1.192
log
@eklmn's changes
@
text
@d322 2
a323 1
				AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
@


1.191
log
@More Kush changes for localization
@
text
@d189 1
a189 1
	bPartFileIsUploading = false;
d322 1
a322 2
				if (g_eMuleApp.m_pGlobPrefs->GetBugReport())
					AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
@


1.190
log
@new way of syncronization by file completion
@
text
@d322 2
a323 1
				AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_strFullUserIP, m_uUserPort);
@


1.189
log
@do not log "filtered"-messages if "do not log coutermeasures" is enabled
@
text
@d189 2
@


1.188
log
@Some fixes, added debug log for file starting to be hashed.
@
text
@d1179 2
a1180 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1194 2
a1195 1
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
@


1.187
log
@Changed a log color
@
text
@d369 1
@


1.186
log
@Removed debug code
@
text
@d381 1
a381 1
					TagToDebugLogLine(RGB_LOG_WARNING + _T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d383 1
a383 1
				AddDebugLogLine(false, RGB_LOG_WARNING + _T("%s: Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
@


1.185
log
@*** empty log message ***
@
text
@a42 1
	m_ReqPartResetList.AddTail(1); // DonGato: for testing purposes
@


1.184
log
@Added some data for debug, changed some log lines.
@
text
@d507 2
a508 3
		if(g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
			AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
			                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d523 2
a524 3
		if(g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
			AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
			                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d535 2
a536 3
		if(g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
			g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUserName,
			        (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions );
@


1.183
log
@Some changes (unknown sources and wrong edonkey tags)
@
text
@d43 1
d366 2
@


1.182
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d155 1
d382 2
a383 2
				                 __FUNCTION__, strTemptag->GetSpecialTag(), strTemptag->GetIntValue(), strTemptag->GetStringValue(), m_dwClientVersion,
				                 m_strUserName );
d504 3
a506 2
		AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d521 3
a523 2
		AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d534 3
a536 2
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, RGB_LOG_DIMMED + _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUserName,
		        (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_uUserPort, (i_TotalClientActions + last_actions), i_TotalActions );
@


1.181
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d204 1
a204 1
		AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Deleting banned client '%s' by releasing object"), __FUNCTION__, GetUserName());
d378 1
a378 1
					TagToDebugLogLine(RGB_LIGHT_ORANGE + _T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d380 1
a380 1
				AddDebugLogLine(false, RGB_LIGHT_ORANGE + _T("%s: Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
d503 1
a503 1
		AddDebugLogLine( false, RGB_BLUE_GRAY + _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
d519 1
a519 1
		AddDebugLogLine( false, RGB_BLUE_GRAY + _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
d531 1
a531 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, RGB_BLUE_GRAY + _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUserName,
d869 1
a869 1
//						TagToDebugLogLine(RGB_LIGHT_ORANGE + _T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d871 1
a871 1
//					AddDebugLogLine( false, RGB_LIGHT_ORANGE + _T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
d1018 1
a1018 1
						AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Description for file '%s' filtered: %s"), __FUNCTION__, m_strClientFilename, m_strComment);
d1116 1
a1116 1
				AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Keeping banned client '%s' after disconnect"), __FUNCTION__, GetUserName());
d1175 1
a1175 1
			AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1189 1
a1189 1
				AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1198 1
a1198 1
		//	AddDebugLogLine(false, RGB_BLUE_GRAY + _T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"), __FUNCTION__, m_dwUserID,m_dwUserIP,GetFullIP());
@


1.180
log
@Added some colors to the logs...
@
text
@d195 1
a195 1
//	AddDebugLogLine(false,_T("%s: Destroying client %s (addr 0x%08X)"),__FUNCTION__,GetUserName(),this);
d204 1
a204 1
		AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Deleting banned client '%s' by releasing object"), __FUNCTION__, GetUserName());
d378 1
a378 1
					TagToDebugLogLine(_T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d380 1
a380 1
				AddDebugLogLine( false, _T("<COLOR=255,102,0>%s: Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
d503 1
a503 1
		AddDebugLogLine( false, _T("<COLOR=102,102,153>%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
d519 1
a519 1
		AddDebugLogLine( false, _T("<COLOR=102,102,153>%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
d531 1
a531 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, _T("<COLOR=102,102,153>%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUserName,
d869 1
a869 1
//						TagToDebugLogLine(_T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d871 1
a871 1
//					AddDebugLogLine( false, _T("<COLOR=255,102,0>%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
d1018 1
a1018 1
						AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Description for file '%s' filtered: %s"), __FUNCTION__, m_strClientFilename, m_strComment);
d1116 1
a1116 1
				AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Keeping banned client '%s' after disconnect"), __FUNCTION__, GetUserName());
d1175 1
a1175 1
			AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1189 1
a1189 1
				AddDebugLogLine(false, _T("<COLOR=102,102,153>%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1198 1
a1198 1
		//	AddDebugLogLine(false,_T("<COLOR=102,102,153>%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"), __FUNCTION__, m_dwUserID,m_dwUserIP,GetFullIP());
@


1.179
log
@Minor change
@
text
@d204 1
a204 1
		AddDebugLogLine(false, _T("%s: Deleting banned client '%s' by releasing object"), __FUNCTION__, GetUserName());
d380 1
a380 1
				AddDebugLogLine( false, _T("%s: Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
d503 1
a503 1
		AddDebugLogLine( false, _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
d519 1
a519 1
		AddDebugLogLine( false, _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUserName,
d531 1
a531 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUserName,
d871 1
a871 1
//					AddDebugLogLine( false, _T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
d1018 1
a1018 1
						AddDebugLogLine(false, _T("%s: Description for file '%s' filtered: %s"), __FUNCTION__, m_strClientFilename, m_strComment);
d1116 1
a1116 1
				AddDebugLogLine(false, _T("%s: Keeping banned client '%s' after disconnect"), __FUNCTION__, GetUserName());
d1175 1
a1175 1
			AddDebugLogLine(false, _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1189 1
a1189 1
				AddDebugLogLine(false, _T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(), g_eMuleApp.m_pIPFilter->GetLastHit());
d1198 1
a1198 1
		//	AddDebugLogLine(false,_T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"), __FUNCTION__, m_dwUserID,m_dwUserIP,GetFullIP());
@


1.178
log
@Minor changes
@
text
@d977 1
a984 1
	else
a985 4
	{
		dwIP = 0;
		nPort = 0;
	}
@


1.177
log
@1i public release preparations
@
text
@d976 1
a976 1
	uint32 dwIP;
a985 1

d987 1
a988 1
		dwIP = 0;
@


1.176
log
@- add unknown eMule tags 0x30, 0x84
- add eDonky client tag 0x55 (mod version), because some clients use this instead of eMule client tag
- add compatible client ids 3, 10, 20 identified as SO_EMULE
@
text
@d868 2
a869 2
						CString buffer = strTemptag->GetStringValue();
						TagToDebugLogLine(_T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), strTemptag->GetSpecialTag());	// DbT:Logging
d871 2
a872 2
					AddDebugLogLine( false, _T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
					                 __FUNCTION__, strTemptag->GetSpecialTag(), strTemptag->GetIntValue(), strTemptag->GetStringValue(), m_strUserName, GetClientNameAndVersionString(this) );
@


1.175
log
@fixed a memleak that was introduced my stability measurements
@
text
@d334 5
d818 1
d831 1
d1410 3
@


1.174
log
@some measurements to increase stability
@
text
@d271 1
a271 1
void CUpDownClient::ProcessHelloPacket(char* pachPacket, uint32 nSize)
d277 1
a277 1
	ProcessHelloTypePacket(data);
d279 1
d290 1
a290 1
void CUpDownClient::ProcessHelloTypePacket(CSafeMemFile& data)
d395 2
a396 1
			g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(addsrv, true);
d546 2
d549 2
@


1.173
log
@minor fix
@
text
@d382 2
d386 11
a447 16
//	if (crashed) AddDebugLogLine(false,_T("The invalid user name was sent from IP:%s"), m_strFullUserIP);

//	get client credits
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && !crashed)
	{  // obaldin: we shouldn't trust the client who tried to crash us
		in_addr addhost;
		addhost.S_un.S_addr = m_dwServerIP;
		CServer* addsrv = new CServer(m_uServerPort, CString(inet_ntoa(addhost)));
		addsrv->SetListName(addsrv->GetAddress());

		if (!g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.AddServer(addsrv, true))
			delete addsrv;
		/*else
			AddLogLine(false,"Added new server: %s:%d", srv->GetFullIP(), srv->GetPort());*/
	}

d452 1
d724 2
d864 6
@


1.172
log
@minor change (don't add processed function to log when requesting shared files)
@
text
@a1197 1
		{
d1199 2
a1200 2
			return false; // SLUGFILLER: SafeDisconnect	//SyruS (0.29c) ouch! this was 2 lines down
		}
d1211 1
a1211 1
			return true;	// SLUGFILLER: SafeDisconnect
d1221 1
a1221 1
			return true;	// SLUGFILLER: SafeDisconnect
d1227 1
a1227 1
		return true;	// SLUGFILLER: SafeDisconnect
d1238 1
a1238 1
			return false;	// SLUGFILLER: SafeDisconnect
d1255 1
a1255 1
				return false;	// SLUGFILLER: SafeDisconnect
d1278 1
a1278 1
	return true;	// SLUGFILLER: SafeDisconnect
@


1.171
log
@fixed a typo
@
text
@d1451 1
a1451 1
		AddDebugLogLine(true, _T("%s: ") + ::GetResString(IDS_SHAREDFILES_REQUEST), __FUNCTION__, GetUserName());
@


1.170
log
@ET_TAROD will be not sended anymore
@
text
@d1465 1
a1465 1
		g_eMuleApp.m_pSearchList->ProcessSearchanswer(pachPacket, nSize, this, pszDirectory, bFirstDir);
@


1.169
log
@Formatting, comments, and name changes.
@
text
@d637 10
a646 8
		uint8 version = CURRENT_VERSION_SHORT;
		data.Write(&version, 1);
		uint8 protversion = EMULE_PROTOCOL;
		data.Write(&protversion, 1);
		uint32 tagcount = 11;
		data.Write(&tagcount, 4);
		CEmuleTag tag(ET_COMPRESSION, 1);
		tag.WriteToFile(data);
d655 11
a665 12
		CEmuleTag tag6(ET_MOD_TAROD, 1);						// To check for Tarod/Plus (just curiosity)
		tag6.WriteToFile(data);	// It do not harms at all (!)
		CEmuleTag tag7(ET_MOD_PLUS, CURRENT_PLUS_VERSION);	// To check for eMulePlus
		tag7.WriteToFile(data);	                    // It doesn't do any harm (?)
		CEmuleTag tag8(ET_EXTENDEDREQUEST, 2);
		tag8.WriteToFile(data);
		CEmuleTag tag9(ET_MOD_VERSION, _T(PLUS_VERSION_STR));
		tag9.WriteToFile(data);	 //More harmless than the other 2! :D
		CEmuleTag tag10(ET_L2HAC, FILEREASKTIME);	//<<-- enkeyDEV(th1) -L2HAC-
		tag10.WriteToFile(data);			//<<-- enkeyDEV(th1) -L2HAC-
		CEmuleTag tag11(ET_FEATURES, (uint32)(g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0));
		tag11.WriteToFile(data);
@


1.168
log
@Formatting, comments, and name changes.
@
text
@d32 2
a33 3
t_offensecounter offensecounter;
t_hashbase hashbase;
//--- :xrmb ---
d38 1
d40 1
a40 1
CUpDownClient::CUpDownClient(CClientReqSocket* sender)
d42 2
a43 2
	m_pRequestSocket = sender;
	m_pReqPartFile = 0;
d47 2
a48 19

//	LANCAST (moosetea) IsOnLAN returns true if lancast is enabled and this updownclient is on our subnet
//bool CUpDownClient::IsOnLAN(){
//	EMULE_TRY
//
//	static bool bFirstTime= true;
//	static bool bIsOnLan = false;
//
//	if (bFirstTime){
//	bFirstTime = false;
//	bIsOnLan = (g_eMuleApp.m_pGlobPrefs->GetLancastEnabled() && ((g_eMuleApp.m_pGlobPrefs->GetLancastIP()&g_eMuleApp.m_pGlobPrefs->GetLancastSubnet()) == (m_dwUserIP&g_eMuleApp.m_pGlobPrefs->GetLancastSubnet())));
//	}
//	return bIsOnLan;
//
//	EMULE_CATCH
//	return false;
//}

CUpDownClient::CUpDownClient(uint16 in_port, uint32 in_userid, uint32 in_serverip, uint16 in_serverport, CPartFile* in_reqfile)
d56 2
a57 2
	SetUserID(in_userid);
	m_uUserPort = in_port;
d60 10
a69 4
		m_strFullUserIP.Format(_T("%i.%i.%i.%i"), (uint8)m_dwUserID, (uint8)(m_dwUserID >> 8), (uint8)(m_dwUserID >> 16), (uint8)(m_dwUserID >> 24));
	m_dwServerIP = in_serverip;
	m_uServerPort = in_serverport;
	m_pReqPartFile = in_reqfile;
d72 1
a72 1

d76 1
a85 1
//	m_cShowDR = 0;
d94 1
a94 1
	m_strUsername = "";
d122 1
a122 2
//m_nDownDataRateMS = 0;
	m_byteFailedFileRequestsCount = 0;	// failed request counter
d132 1
a132 1
	m_byteDataTarodVer = 0; // Added by Tarod
d139 1
a139 1
	m_dwAwayMessageResendCount = 0; //<--enkeyDEV(kei-kun)
a148 1
//By Maverick
d155 1
d157 3
a160 3
	if (m_pRequestSocket)
	{
		SOCKADDR_IN sockAddr;
d162 4
a165 2
		uint32 nSockAddrLen = sizeof(sockAddr);
		m_pRequestSocket->GetPeerName((SOCKADDR*) & sockAddr, (int*) & nSockAddrLen);
d171 1
a171 1
	m_uUpCompleteSourcesCount = 0; // netwolf: complete sources (zegzav) 13.05.03
a173 1
//m_lastCalculatedDownloadRate = ::GetTickCount();
d179 3
a181 3
	m_dwLastL2HACExec = 0;		//<<-- enkeyDEV(th1) -L2HAC-
	m_dwL2HACTime = 0;			//<<-- enkeyDEV(th1) -L2HAC-
	m_bL2HACEnabled = false;	//<<-- enkeyDEV(th1) -L2HAC- lowid side
d190 1
a190 1

d195 1
a195 1
//AddDebugLogLine(false,_T("%s: Destroying client %s (addr 0x%08X)"),__FUNCTION__,GetUserName(),this);
a196 1
//Beep(400,5);
d198 3
a200 1
//SyruS log deletion of banned client
d202 2
a203 1
	//enable cm-logging and set breakpoint here to see from where (shift-f11) it's been deleted
d205 1
d210 2
a211 1
	if (m_pFriend)
d220 1
a220 1
	if (m_pbytePartStatuses)
d225 1
a225 1
	if (m_pbyteUpPartStatuses)
d233 1
d235 1
d237 1
d239 1
d242 3
a244 2
		Pending_Block_Struct * pending = m_pendingBlocksList.RemoveHead();
		delete pending->block;
d246 1
a246 1
		if (pending->zStream)
d248 2
a249 2
			inflateEnd(pending->zStream);
			delete pending->zStream;
d251 1
a251 1
		delete pending;
d270 1
a270 1

d304 1
a304 1
	CClientTag* temptag;	//eklmn: small tag optimization to prevent memleaks
d307 2
a308 2
		temptag = new CClientTag(data);	//eklmn: small tag optimization to prevent memleaks
		switch (temptag->GetSpecialTag())
d311 2
a312 2
			m_strUsername.Empty();	//clear a user name
			if (temptag->GetStringValue().IsEmpty())
d319 1
a319 1
				m_strUsername = _T("[Invalid user name]"); //Vorlost
d322 1
a322 1
				m_strUsername.SetString(temptag->GetStringValue(), temptag->GetStringValue().GetLength()); //eklmn: used CSimpleString class & fuctions
d325 1
a325 1
			m_dwClientVersion = temptag->GetIntValue();
d328 1
a328 1
			if (temptag->GetIntValue() != m_uUserPort && GetClientSoft() != SO_EDONKEYHYBRID)
d369 1
a369 1
				if (!temptag->GetStringValue().IsEmpty())
d371 2
a372 2
					CString buffer = temptag->GetStringValue();
					TagToDebugLogLine(_T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
d375 2
a376 2
				                 __FUNCTION__, temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_dwClientVersion,
				                 m_strUsername );
d379 2
a380 2
		delete temptag;
		temptag = NULL;	//eklmn: small tag optimization to prevent memleaks
d415 1
a415 1
		AddDebugLogLine(false, _T("%s: User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d."), __FUNCTION__, m_strUsername, m_dwClientVersion, ip_addr, m_uUserPort);
d421 1
a421 1
	uint32 nSockAddrLen = sizeof(sockAddr);
d424 1
a424 1
	m_pRequestSocket->GetPeerName((SOCKADDR*) & sockAddr, (int*) & nSockAddrLen);
d464 1
a464 1
		m_pFriend->m_strName.Format(_T("%s"), m_strUsername);
d472 1
a472 1
			newitem.pszText = m_strUsername.GetBuffer(256);
d483 3
a485 3
	uint32 i_TotalActions = offensecounter[0];
	if (offensecounter.Lookup(id, i_TotalClientActions))
		i_TotalClients = offensecounter.GetSize() - 1;
d487 1
a487 1
		i_TotalClients = offensecounter.GetSize();
d498 1
a498 1
		AddDebugLogLine( false, _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUsername,
d508 1
a508 1
	if (hashbase.Lookup(id, lasthash) && lasthash != thishash)
d514 1
a514 1
		AddDebugLogLine( false, _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_strUsername,
d517 1
a517 1
	hashbase[id] = thishash;
d526 1
a526 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_strUsername,
d537 2
a538 2
		offensecounter[id] = i_TotalClientActions + last_actions;
		offensecounter[0] = i_TotalActions;
d553 1
a553 1
	if ( !m_strUsername.IsEmpty() && (
d555 3
a557 3
	         m_strUsername == "pbwll" ||
	         m_strUsername == "unix user" ||
	         m_strUsername == "http://emule-element.tk" // EC 14.08.03 0-Upload Mod default nickname
d559 15
a573 15
	         || m_strUsername.Find("Odin") != -1
	         || m_strUsername.Find("$GAM3R$") != -1
	         || m_strUsername.Find("G@@m3rs Edit") != -1
	         || m_strUsername.Find("G@@m3rs Edit") != -1
	         || m_strUsername.Find( "[RAMMSTEIN" ) != -1
	         || m_strUsername.Find("[toXic]") != -1
	         || m_strUsername.Find("Leecha") != -1
	         || m_strUsername.Find("leecha") != -1
	         || m_strUsername.Find("eDevil") != -1
	         || m_strUsername.Find("darkmule") != -1
	         || m_strUsername.Find("DarkMule") != -1
	         || m_strUsername.Find("eVortex") != -1
	         || m_strUsername.Find("|eVorte|X|") != -1
	         || m_strUsername.Find("MISON") != -1
	         || m_strUsername.Find("Mison") != -1 ) )
d722 1
a722 1
	CEmuleTag* temptag = NULL;
d725 2
a726 2
		temptag = new CEmuleTag(data);
		if (temptag)
d728 1
a728 1
			switch (temptag->GetSpecialTag())
d732 1
a732 1
					m_byteDataCompVer = temptag->GetIntValue();
d737 1
a737 1
					m_uUDPPort = temptag->GetIntValue();
d742 1
a742 1
					m_byteUDPVer = temptag->GetIntValue();
d747 1
a747 1
					m_byteSourceExchangeVer = temptag->GetIntValue();
d752 1
a752 1
					m_byteAcceptCommentVer = temptag->GetIntValue();
d757 1
a757 1
					m_byteExtendedRequestsVer = temptag->GetIntValue();
d760 1
a760 1
				case ET_COMPATABLECLIENT:
d762 1
a762 1
					m_dwCompatibleClient = temptag->GetIntValue();
d771 1
a771 1
					m_strModVersion = temptag->GetStringValue();
d776 1
a776 1
					m_strModExtended = temptag->GetStringValue();
d781 1
a781 1
					m_dwDataPlusVers = temptag->GetIntValue();
d786 1
a786 1
					m_byteDataTarodVer = temptag->GetIntValue();
d836 1
a836 1
					m_dwL2HACTime = temptag->GetIntValue();
d847 1
a847 1
					m_byteSupportSecIdent = temptag->GetIntValue() & 3;
d852 1
a852 1
					if (!temptag->GetStringValue().IsEmpty())
d854 2
a855 2
						CString buffer = temptag->GetStringValue();
						TagToDebugLogLine(_T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
d858 1
a858 1
					                 __FUNCTION__, temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_strUsername, GetClientNameAndVersionString(this) );
d861 2
a862 2
			delete temptag;
			temptag = NULL;
d1349 1
a1349 1

d1354 2
a1355 2
//	If this client hasnt been contacted, its is SO_UNKNOWN
	if (m_strUsername.IsEmpty())
d1361 3
a1363 2
//	What is this clients hash type
	int iHashType = GetHashType();
d1366 2
a1367 1
		case SO_OLDEMULE:      // If the client is an old emule
d1372 2
a1373 1
		case SO_MLDONKEY:      // If the client is an Ml donkey
d1378 2
a1379 1
		case SO_EMULE:       // If the client is an Emule compatable client
d1383 4
a1386 3
				CString temp;
				temp.Format("%02X", m_byteEmuleVersion);
				m_dwClientVersion = _tstoi(temp.GetBuffer()) * 10;
d1413 1
d1415 1
d1417 1
d1419 1
d1423 1
a1423 1
						AddDebugLogLine(false, "%s: New Compatable ClientSoft ET_COMPATABLECLIENT = %i client will be listed as an emule ", __FUNCTION__, m_dwCompatibleClient);
d1434 1
a1434 1
		//	Were left with donkeys and Hybrids
d1444 1
d1496 1
a1496 1
void CUpDownClient::SetUserHash(uchar* m_achTempUserHash)
d1498 1
a1498 1
	if (m_achTempUserHash == NULL)
d1503 1
a1503 1
	md4cpy(m_userHash, m_achTempUserHash);
@


1.167
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d710 1
a710 1
		if (m_byteEmuleVersion >= 0x28 && !m_bIsML && (PlusVersion() == 0 || PlusVersion() >= 0x0108))
d889 1
a889 1
	if ((PlusVersion() >= 0x0106) && (PlusVersion() < 0x0108) && (GetExtendedRequestsVersion() == 1))
@


1.166
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d90 1
a90 1
	m_uLastPartAsked = 0xffff;		//jicxicmic
@


1.165
log
@Updated configurations, added VS2002 build config, continuing new sockets.
@
text
@d43 1
a43 1
	reqfile = 0;
d48 2
a49 2
//	LANCAST (moosetea) isOnLAN returns true if lancast is enabled and this updownclient is on our subnet
//bool CUpDownClient::isOnLAN(){
d74 2
a75 2
	m_nUserPort = in_port;
	sourcesslot = m_nUserID % SOURCESSLOTS;
d77 1
a77 1
		m_szFullUserIP.Format(_T("%i.%i.%i.%i"), (uint8)m_nUserID, (uint8)(m_nUserID >> 8), (uint8)(m_nUserID >> 16), (uint8)(m_nUserID >> 24));
d79 2
a80 2
	m_nServerPort = in_serverport;
	reqfile = in_reqfile;
d87 2
a88 2
	m_szFullUserIP = "";
	credits = 0;
d90 6
a95 6
	m_LastPartAsked = 0xffff;		//jicxicmic
	m_nAvDownDataRate = 0;
	m_nAvUpDataRate = 0;
	m_Client_Sum_DL_DR_over_last_N_measurements = 0;
	m_Client_Sum_DL_tick_over_last_N_measurements = 0;
	m_TransferredInLastPeriod = 0;
d97 2
a98 2
	m_nUDPPort = 0;
	m_iFailedCount = 0;
d100 6
a105 6
	m_nMaxSendAllowed = 0;
	m_nTransferredUp = 0;
	m_cAsked = 0;
	m_cDownAsked = 0;
	m_nUpDataRate = -1;
	m_pszUsername = "";
d108 2
a109 2
	m_nServerPort = 0;
	b_IsOnLan = false;
d114 2
a115 2
	usedcompressiondown = false;
	m_bUsedComprUp = false;
d120 8
a127 8
	m_byEmuleVersion = 0;
	m_modVerString = "";
	m_modExtendedString = "";
	m_nUserPort = 0;
	m_nPartCount = 0;
	m_nUpPartCount = 0;
	m_abyPartStatus = 0;
	m_abyUpPartStatus = 0;
d131 2
a132 2
	m_nTransferredDown = 0;
	m_nDownDataRate = 0;
d134 1
a134 1
	m_cFailFileRequests = 0;	// filed request counter
d137 2
a138 2
	m_byEmuleVersion = 0;
	m_byDataCompVer = 0;
d140 6
a145 6
	m_byUDPVer = 0;
	m_bySourceExchangeVer = 0;
	m_byAcceptCommentVer = 0;
	m_byExtendedRequestsVer = 0;
	m_byDataTarodVer = 0; // Added by Tarod
	m_nRemoteQueueRank = 0;
d148 2
a149 2
	m_RemoteClientSpeed = 0;
	m_byCompatableClient = 0;
d151 1
a151 1
	m_awayMessageResendCount = 0; //<--enkeyDEV(kei-kun)
d156 2
a157 2
	m_LastGotULData = 0;
	m_clientSoft = SO_UNKNOWN;
d159 1
a159 1
	md4clr(m_achUserHash);
d162 6
a167 6
	m_RemoteScore = 0;
	m_RemoteRatio = 0;
	m_RemoteBaseModifier = 0;
	m_RemoteInfoAvaiable = false;
	m_RemoteCommunity = false;
	m_RemoteCommunityEnabled = false;
d177 1
a177 1
		m_szFullUserIP = inet_ntoa(sockAddr.sin_addr);
d180 4
a183 4
	sourcesslot = 0;
	m_nUpCompleteSourcesCount = 0; // netwolf: complete sources (zegzav) 13.05.03
	m_nUpCompleteSourcesTime = 0;
	m_lastRefreshedULDisplay = ::GetTickCount();
d185 8
a192 8
	score_base_cached = false;
	community_cached = false;
	m_fSharedDirectories = 0;
	md4clr(reqfileid);

	m_last_l2hac_exec = 0;		//<<-- enkeyDEV(th1) -L2HAC-
	m_L2HAC_time = 0;			//<<-- enkeyDEV(th1) -L2HAC-
	m_l2hac_enabled = false;	//<<-- enkeyDEV(th1) -L2HAC- lowid side
d194 1
a194 1
	m_SecureIdentState = IS_UNAVAILABLE;
d196 2
a197 2
	m_bySupportSecIdent = 0;
	m_byInfopacketsReceived = IP_NONE;
d225 1
a225 5
	if (m_pRequestSocket != NULL)
	{
		m_pRequestSocket->m_pClient = NULL;
		m_pRequestSocket->Safe_Delete();
	}
d227 1
a227 1
	if (m_abyPartStatus)
d229 2
a230 2
		delete[] m_abyPartStatus;
		m_abyPartStatus	= 0;
d232 1
a232 1
	if (m_abyUpPartStatus)
d234 2
a235 2
		delete[] m_abyUpPartStatus;
		m_abyUpPartStatus	= 0;
d239 5
a243 5
	while (!m_DownloadBlocks_list.IsEmpty())
		delete m_DownloadBlocks_list.RemoveHead();
	while (!m_RequestedFiles_list.IsEmpty())
		delete m_RequestedFiles_list.RemoveHead();
	while (!m_PendingBlocks_list.IsEmpty())
d245 1
a245 1
		Pending_Block_Struct * pending = m_PendingBlocks_list.RemoveHead();
d260 1
a260 1
		reqfile->UpdateFileRatingCommentAvail();
d263 2
a264 2
	m_AverageUDR_list.clear();
	m_Average_DL_DR_list.clear();
d296 1
a296 1
	data.Read(&m_achUserHash, 16);
d299 1
a299 1
	if (!m_nUserID)
d301 1
a301 1
	data.Read(&m_nUserPort, 2); // hmm clientport is sent twice - why?
d313 1
a313 1
			m_pszUsername.Empty();	//clear a user name
d318 1
a318 1
				md4cpy(crashash, m_achUserHash);
d320 2
a321 2
				AddDebugLogLine(false, _T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"), __FUNCTION__, buffer, m_szFullUserIP, m_nUserPort);
				m_pszUsername = _T("[Invalid user name]"); //Vorlost
d324 1
a324 1
				m_pszUsername.SetString(temptag->GetStringValue(), temptag->GetStringValue().GetLength()); //eklmn: used CSimpleString class & fuctions
d327 1
a327 1
			m_nClientVersion = temptag->GetIntValue();
d330 1
a330 1
			if (temptag->GetIntValue() != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID)
d377 2
a378 2
				                 __FUNCTION__, temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_nClientVersion,
				                 m_pszUsername );
d385 1
a385 1
	data.Read(&m_nServerPort, 2);
d394 1
d396 1
d400 1
a400 1
			m_fSharedDirectories = 1;
d404 6
a409 6
//if( m_nClientVersion > 10000 && m_nClientVersion < 100000 )
//	m_nClientVersion = m_nClientVersion - (m_nClientVersion/10000)*10000;
//if( m_nClientVersion > 1000 )
//	m_nClientVersion = m_nClientVersion - (m_nClientVersion/1000)*1000;
//if( m_nClientVersion < 100 )
//	m_nClientVersion *= 10;
d417 1
a417 1
		AddDebugLogLine(false, _T("%s: User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d."), __FUNCTION__, m_pszUsername, m_nClientVersion, ip_addr, m_nUserPort);
d430 1
a430 1
	m_szFullUserIP = inet_ntoa(sockAddr.sin_addr);
d433 3
a435 3
	b_IsOnLan = ((g_eMuleApp.m_pGlobPrefs->GetLancastEnabled()) && ((g_eMuleApp.m_pGlobPrefs->GetLancastIP() & g_eMuleApp.m_pGlobPrefs->GetLancastSubnet()) == (m_dwUserIP & g_eMuleApp.m_pGlobPrefs->GetLancastSubnet())));
	if (b_IsOnLan)
		m_nUserID = m_dwUserIP;
d437 1
a437 1
//	if (crashed) AddDebugLogLine(false,_T("The invalid user name was sent from IP:%s"), m_szFullUserIP);
d444 1
a444 1
		CServer* addsrv = new CServer(m_nServerPort, CString(inet_ntoa(addhost)));
d454 1
a454 1
	if (!HasLowID() && m_nUserID != m_dwUserIP)
d458 3
a460 3
	md4cpy(key, m_achUserHash);
	credits = g_eMuleApp.m_pClientCreditList->GetCredit(key);
	if ((m_pFriend = g_eMuleApp.m_pFriendList->LinkFriend(key, m_dwUserIP, m_nUserPort)) != NULL)
d466 1
a466 1
		m_pFriend->m_strName.Format(_T("%s"), m_pszUsername);
d468 1
a468 1
		m_pFriend->m_nLastUsedPort = m_nUserPort;
d474 1
a474 1
			newitem.pszText = m_pszUsername.GetBuffer(256);
d481 1
a481 1
	uint64 id = getUID();
d493 1
a493 1
	if (g_eMuleApp.m_pServerConnect->GetClientID() != m_nUserID && md4cmp(m_achUserHash, g_eMuleApp.m_pGlobPrefs->GetUserHash()) == 0 && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d496 1
a496 1
		hashthief = true;
d500 2
a501 2
		AddDebugLogLine( false, _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_pszUsername,
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_nUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d512 1
a512 1
		hashthief = true;
d516 2
a517 2
		AddDebugLogLine( false, _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_pszUsername,
		                 (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_nUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients );
d524 1
a524 1
		hashthief = true;
d528 2
a529 2
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine( false, _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_pszUsername,
		        (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), m_nUserPort, (i_TotalClientActions + last_actions), i_TotalActions );
d544 2
a545 2
	m_byInfopacketsReceived |= IP_EDONKEYPROTPACK;
	if (m_byInfopacketsReceived == IP_BOTH)
d555 1
a555 1
	if ( !m_pszUsername.IsEmpty() && (
d557 3
a559 3
	         m_pszUsername == "pbwll" ||
	         m_pszUsername == "unix user" ||
	         m_pszUsername == "http://emule-element.tk" // EC 14.08.03 0-Upload Mod default nickname
d561 15
a575 15
	         || m_pszUsername.Find("Odin") != -1
	         || m_pszUsername.Find("$GAM3R$") != -1
	         || m_pszUsername.Find("G@@m3rs Edit") != -1
	         || m_pszUsername.Find("G@@m3rs Edit") != -1
	         || m_pszUsername.Find( "[RAMMSTEIN" ) != -1
	         || m_pszUsername.Find("[toXic]") != -1
	         || m_pszUsername.Find("Leecha") != -1
	         || m_pszUsername.Find("leecha") != -1
	         || m_pszUsername.Find("eDevil") != -1
	         || m_pszUsername.Find("darkmule") != -1
	         || m_pszUsername.Find("DarkMule") != -1
	         || m_pszUsername.Find("eVortex") != -1
	         || m_pszUsername.Find("|eVorte|X|") != -1
	         || m_pszUsername.Find("MISON") != -1
	         || m_pszUsername.Find("Mison") != -1 ) )
d588 3
a590 3
	if ( !m_modVerString.IsEmpty() && (
	         m_modVerString.Find("eVortex") != -1
	         || m_modVerString.Find("Mison") != -1 ) )
d608 1
a608 1
		SOCKADDR_IN		sockAddr;
d612 1
a612 1
		uint32		dwSockAddrLen = sizeof(sockAddr);
d614 1
a614 1
		m_pRequestSocket->GetPeerName(reinterpret_cast<SOCKADDR*>(&sockAddr),reinterpret_cast<int*>(&dwSockAddrLen));
d617 1
a617 1
		uint8		hashsize = 16;
d622 1
a622 1
		Packet	   *packet = new Packet(&data);
d684 4
a687 4
	m_byCompatableClient = 0;
	data.Read(&m_byEmuleVersion, 1);
	if (m_byEmuleVersion == 0x2B)
		m_byEmuleVersion = 0x22;
d696 2
a697 2
		if (m_byEmuleVersion < 0x25 && m_byEmuleVersion > 0x22)
			m_byUDPVer = 1;
d699 2
a700 2
		if (m_byEmuleVersion < 0x25 && m_byEmuleVersion > 0x21)
			m_bySourceExchangeVer = 1;
d702 2
a703 2
		if (m_byEmuleVersion == 0x24)
			m_byAcceptCommentVer = 1;
d710 2
a711 2
		if (m_byEmuleVersion >= 0x28 && !m_bIsML && (PlusVersion() == 0 || PlusVersion() >= 0x0108))
			m_fSharedDirectories = 1;
d720 1
a720 1
	m_L2HAC_time = 0;	//<<-- enkeyDEV(th1) -L2HAC-
d733 4
a736 2
				m_byDataCompVer = temptag->GetIntValue();
				break;
d738 4
a741 2
				m_nUDPPort = temptag->GetIntValue();
				break;
d743 4
a746 2
				m_byUDPVer = temptag->GetIntValue();
				break;
d748 4
a751 2
				m_bySourceExchangeVer = temptag->GetIntValue();
				break;
d753 4
a756 2
				m_byAcceptCommentVer = temptag->GetIntValue();
				break;
d758 4
a761 2
				m_byExtendedRequestsVer = temptag->GetIntValue();
				break ;
d763 4
a766 2
				m_byCompatableClient = temptag->GetIntValue();
				break;
d768 3
a770 1
				break;
d772 4
a775 2
				m_modVerString = temptag->GetStringValue();
				break;
d777 4
a780 2
				m_modExtendedString = temptag->GetStringValue();
				break;
d782 4
a785 2
				m_dwDataPlusVers = temptag->GetIntValue();
				break ;
d787 4
a790 2
				m_byDataTarodVer = temptag->GetIntValue();
				break;
d833 19
a851 11
				break;
				case ET_L2HAC:  	// START enkeyDEV(th1) -L2HAC-
				m_L2HAC_time = temptag->GetIntValue();
				break;		// END enkeyDEV(th1) -L2HAC-
				case ET_INCOMPLETEPARTS:   // enkeyDEV(th1) -ICS-
				break;
				case ET_FEATURES:  	// secure credits (official 0.29b)
			//	Bits 31- 8: 0 - reserved
			//	Bit   7- 0: secure identification
				m_bySupportSecIdent = temptag->GetIntValue() & 3;
				break;
a852 1
				if (!temptag->GetStringValue().IsEmpty())
d854 7
a860 2
					CString buffer = temptag->GetStringValue();
					TagToDebugLogLine(_T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
a861 2
				AddDebugLogLine( false, _T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
				                 __FUNCTION__, temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_pszUsername, GetClientNameAndVersionString(this) );
d869 4
a872 4
	if (!m_L2HAC_time)
		m_L2HAC_time = L2HAC_DEFAULT_EMULE;
	if (m_L2HAC_time < L2HAC_MIN_TIME || m_L2HAC_time > L2HAC_MAX_TIME)
		m_L2HAC_time = 0;
d875 1
a875 1
	if (m_byDataCompVer == 0)
d877 5
a881 5
		m_bySourceExchangeVer = 0;
		m_byExtendedRequestsVer = 0;
		m_byAcceptCommentVer = 0;
		m_nUDPPort = 0;
		m_L2HAC_time = 0;	//<<-- enkeyDEV(th1) -L2HAC-
d884 2
a885 2
	m_byInfopacketsReceived |= IP_EMULEPROTPACK;
	if (m_byInfopacketsReceived == IP_BOTH)
d890 1
a890 1
		m_byExtendedRequestsVer = 2;
d981 1
a981 1
	if ((reqfile != NULL) && (nSize > 2))
d1015 1
a1015 1
				reqfile->SetHasComment(true);
d1021 1
a1021 1
			reqfile->SetHasRating(true);
d1025 1
a1025 1
			reqfile->RemovePastComment(this, false);
d1030 1
a1030 1
bool CUpDownClient::Disconnected(bool bRetryConnection/*=true*/)
d1045 2
a1046 2
		if ((GetDownloadState() == DS_REQHASHSET) && reqfile != NULL)
			reqfile->m_bHashSetNeeded = true;
d1084 2
a1085 2
				m_iFailedCount++;
				if (bRetryConnection && m_iFailedCount <= 2)
d1113 1
a1113 5
		if (m_pRequestSocket != NULL && g_eMuleApp.m_pListenSocket->IsValidSocket(m_pRequestSocket))
		{
			m_pRequestSocket->Safe_Delete();
		}
		m_pRequestSocket = NULL;
d1159 1
a1159 1
	//	case 1: it's a Client with known IP, always test m_dwUserIP instead of m_nUserID
d1171 1
a1171 1
		if ((unsigned)m_nUserID > 16777215)
d1173 2
a1174 2
		//	case 2: it's HighID with m_dwUserIP empty, test m_nUserID instead
			if (g_eMuleApp.m_pIPFilter->IsFiltered(m_nUserID))
d1185 1
a1185 1
		//	AddDebugLogLine(false,_T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP());
d1189 1
a1189 1
	if ((g_eMuleApp.m_pServerConnect->GetClientID() < 16777216) && HasLowID())
d1196 1
a1196 1
			reqfile->m_bHashSetNeeded = true;
d1207 1
a1207 1
	if (!m_pRequestSocket)
d1244 1
a1244 1
		if (g_eMuleApp.m_pServerConnect->IsLocalServer(m_dwServerIP, m_nServerPort))
d1247 1
a1247 1
			memcpy2(packet->m_pcBuffer, &m_nUserID, 4);
d1289 1
a1289 1
	m_iFailedCount = 0;
d1329 1
a1329 1
		Packet * packet = new Packet(m_fSharedDirectories ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES);
d1342 1
a1342 1
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110)
d1344 1
a1344 1
	else if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111)
d1346 1
a1346 1
	else if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L')
d1357 1
a1357 1
	if (m_pszUsername.IsEmpty())
d1359 1
a1359 1
		m_clientSoft = SO_UNKNOWN;
d1367 1
a1367 8
		case SO_OLDEMULE:   // If the client is an old emule
		m_clientSoft = SO_OLDEMULE;
		break;
		case SO_MLDONKEY:   // If the client is an Ml donkey
		m_clientSoft = SO_MLDONKEY;
		break;
		case SO_EMULE:    // If the client is an Emule compatable client
		if (m_byEmuleVersion != 0x99)
d1369 2
a1370 3
			CString temp;
			temp.Format("%02X", m_byEmuleVersion);
			m_nClientVersion = _tstoi(temp.GetBuffer()) * 10;
d1372 1
a1372 1
		switch (m_byCompatableClient)
d1374 1
a1374 2
			case 0:
			m_clientSoft = SO_EMULE;
d1376 44
a1419 2
			case 1:
			m_clientSoft = SO_CDONKEY;
d1421 4
a1424 7
			case 2:
			m_clientSoft = SO_LMULE;
			break;
			case 4:
			m_clientSoft = SO_SHAREAZA;
			break;
			default:
d1426 4
a1429 3
				m_clientSoft = SO_MLDONKEY;
			else if (m_bIsHybrid)
				m_clientSoft = SO_EDONKEYHYBRID;
d1431 2
a1432 15
			{
				m_clientSoft = SO_EMULE;
				AddDebugLogLine(false, "%s: New Compatable ClientSoft ET_COMPATABLECLIENT = %i client will be listed as an emule ", __FUNCTION__, m_byCompatableClient);
			}
		} // end: switch m_byCompatableClient
		break;
		default:
	//	If the client is an Ml donkey
		if (m_bIsML)
			m_clientSoft = SO_MLDONKEY;
	//	Were left with donkeys and Hybrids
		if (m_bIsHybrid)
			m_clientSoft = SO_EDONKEYHYBRID;
		else
			m_clientSoft = SO_EDONKEY;
d1469 1
a1469 1
	CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID(this->reqfileid);
d1492 1
a1492 1
		md4clr(m_achUserHash);
d1495 1
a1495 1
	md4cpy(m_achUserHash, m_achTempUserHash);
d1508 1
a1508 1
	CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID(this->reqfileid);
d1539 1
a1539 1
	if (m_pRequestSocket == NULL || credits == NULL || m_SecureIdentState != IS_KEYANDSIGNEEDED)
d1557 1
a1557 1
	m_SecureIdentState = IS_SIGNATURENEEDED;
d1564 1
a1564 1
	if (m_pRequestSocket == NULL || credits == NULL || m_SecureIdentState == 0)
d1573 1
a1573 1
	if (credits->GetSecIDKeyLen() == 0)
d1580 1
a1580 1
	if (credits->m_dwCryptRndChallengeFrom == 0)
d1588 1
a1588 1
	if ((m_bySupportSecIdent & 1) == 1)
d1614 1
a1614 1
	uint8 siglen = g_eMuleApp.m_pClientCreditList->CreateSignature(credits, achBuffer, 250, ChallengeIP, byChaIPKind);
d1631 1
a1631 1
	m_SecureIdentState = IS_ALLREQUESTSSEND;
d1642 1
a1642 1
	if ( m_pRequestSocket == NULL || credits == NULL || pachPacket[0] != nSize - 1
d1652 1
a1652 1
	if (credits->SetSecureIdent(pachPacket + 1, pachPacket[0]))
d1655 1
a1655 1
		if (m_SecureIdentState == IS_SIGNATURENEEDED)
d1659 1
a1659 1
		else if (m_SecureIdentState == IS_KEYANDSIGNEEDED)
d1679 1
a1679 1
	if (m_pRequestSocket == NULL || credits == NULL || nSize == 0 || nSize > 250)
d1689 1
a1689 1
	else if (pachPacket[0] == nSize - 2 && (m_bySupportSecIdent & 2) > 0) //v2
d1707 1
a1707 1
	if (credits->GetSecIDKeyLen() == 0)
d1713 1
a1713 1
	if (credits->m_dwCryptRndChallengeFor == 0)
d1719 1
a1719 1
	if (g_eMuleApp.m_pClientCreditList->VerifyIdent(credits, pachPacket + 1, pachPacket[0], GetIP(), byChaIPKind))
d1736 1
a1736 1
	if (credits)
d1740 1
a1740 1
			if (credits->GetSecIDKeyLen() == 0)
d1755 1
a1755 1
		credits->m_dwCryptRndChallengeFor = dwRandom;
d1777 1
a1777 1
	if (!credits)
d1783 1
a1783 1
		m_SecureIdentState = IS_UNAVAILABLE;
d1786 1
a1786 1
		m_SecureIdentState = IS_SIGNATURENEEDED;
d1789 1
a1789 1
		m_SecureIdentState = IS_KEYANDSIGNEEDED;
d1794 1
a1794 1
	credits->m_dwCryptRndChallengeFrom = dwRandom;
d1805 2
a1806 2
	ASSERT (m_byInfopacketsReceived == IP_BOTH);
	m_byInfopacketsReceived = IP_NONE;
d1808 1
a1808 1
	if (m_bySupportSecIdent)
@


1.164
log
@no message
@
text
@d1492 1
d1498 1
d1517 1
d1523 1
d1595 1
d1602 1
d1632 1
d1638 1
@


1.163
log
@no message
@
text
@d68 1
a68 1
	m_pRequestSocket = 0;
d225 1
a225 1
	if (m_pRequestSocket)
d227 1
a227 1
		m_pRequestSocket->m_pClient = 0;
d600 1
a600 1

d605 1
d608 1
a608 1
	if (m_pRequestSocket)
d610 2
a611 1
		SOCKADDR_IN sockAddr;
d613 8
a620 4
		uint32 nSockAddrLen = sizeof(sockAddr);
		m_pRequestSocket->GetPeerName((SOCKADDR*) & sockAddr, (int*) & nSockAddrLen);
		CMemFile data;
		uint8 hashsize = 16;
d623 3
a625 1
		Packet* packet = new Packet(&data);
d633 1
a633 1

d998 1
a998 1
bool CUpDownClient::Disconnected()
d1053 1
a1053 1
				if (m_iFailedCount <= 2)
d1081 1
a1081 1
		if (m_pRequestSocket)
a1082 1
			ASSERT (g_eMuleApp.m_pListenSocket->IsValidSocket(m_pRequestSocket));
d1129 1
a1129 1
	if ((unsigned)m_dwUserIP > 0)
d1135 2
a1136 1
			Disconnected();
d1149 1
a1149 1
				Disconnected();
d1172 1
a1172 1
			Disconnected();
@


1.162
log
@A number of robustification changes.
@
text
@d27 1
a27 1
static char THIS_FILE[]=__FILE__;
d37 1
a37 1
//	which are used by down and uploading functions 
d40 3
a42 2
CUpDownClient::CUpDownClient(CClientReqSocket* sender){
	socket = sender;
d48 1
a48 1
// LANCAST (moosetea) isOnLAN returns true if lancast is enabled and this updownclient is on our subnet
d53 1
a53 1
//	static bool bIsOnLan = false; 
d55 5
a59 5
//		if (bFirstTime){
//			bFirstTime = false;
//			bIsOnLan = (g_eMuleApp.m_pGlobPrefs->GetLancastEnabled() && ((g_eMuleApp.m_pGlobPrefs->GetLancastIP()&g_eMuleApp.m_pGlobPrefs->GetLancastSubnet()) == (m_dwUserIP&g_eMuleApp.m_pGlobPrefs->GetLancastSubnet())));
//		}
//		return bIsOnLan;
d65 2
a66 1
CUpDownClient::CUpDownClient(uint16 in_port, uint32 in_userid,uint32 in_serverip, uint16 in_serverport,CPartFile* in_reqfile){
d68 1
a68 1
	socket = 0;
d70 1
d75 1
a75 1
	sourcesslot=m_nUserID%SOURCESSLOTS;
d77 1
a77 1
		m_szFullUserIP.Format(_T("%i.%i.%i.%i"),(uint8)m_nUserID,(uint8)(m_nUserID>>8),(uint8)(m_nUserID>>16),(uint8)(m_nUserID>>24));
d84 2
a85 1
void CUpDownClient::Init(){
d98 1
a98 1
	m_cFailed = 0;
d111 1
a111 1
    m_iFileListRequested = m_iFileListRequestedSave = 0;
d129 1
a129 1
	m_nDownloadState = DS_NONE;
d133 1
a133 1
	//m_nDownDataRateMS = 0;
d135 1
a135 1
	m_byUploadState = US_NONE;
d152 2
a153 2
	m_bIsML=false;
	m_Friend = NULL;
d155 1
a155 1
	m_strComment="";
d157 1
a157 1
	m_clientSoft=SO_UNKNOWN;
d161 2
a162 2
	//By Maverick
	m_RemoteScore = 0; 
d169 3
a171 1
	if (socket){
d175 1
a175 1
		socket->GetPeerName((SOCKADDR*)&sockAddr,(int*)&nSockAddrLen);
d180 3
a182 3
	sourcesslot=0;
	m_nUpCompleteSourcesCount= 0; // netwolf: complete sources (zegzav) 13.05.03
	m_nUpCompleteSourcesTime= 0;
d184 3
a186 3
	//m_lastCalculatedDownloadRate = ::GetTickCount();
	score_base_cached = false; 
	community_cached = false; 
d193 1
a193 1
	
d202 2
a203 1
CUpDownClient::~CUpDownClient(){
d208 1
a208 1
	//Beep(400,5);
d210 1
a210 1
	//SyruS log deletion of banned client
d212 2
a213 2
		//enable cm-logging and set breakpoint here to see from where (shift-f11) it's been deleted
		AddDebugLogLine(false,_T("%s: Deleting banned client '%s' by releasing object"), __FUNCTION__,GetUserName());
d215 1
d218 12
a229 10
	if (m_Friend){
		m_Friend->m_LinkedClient = NULL;
		g_eMuleApp.m_pFriendList->RefreshFriend(m_Friend);
		m_Friend = NULL;
	}	
#ifdef OLD_SOCKETS_ENABLED
	if (socket){
		socket->m_pClient = 0;
		socket->Safe_Delete();
	}	
d234 1
a234 1
		m_abyPartStatus	=	0;
d239 1
a239 1
		m_abyUpPartStatus	=	0;
d243 1
a243 1
	while(!m_DownloadBlocks_list.IsEmpty())
d245 1
a245 1
	while(!m_RequestedFiles_list.IsEmpty())
d247 3
a249 2
	while(!m_PendingBlocks_list.IsEmpty()){
		Pending_Block_Struct *pending = m_PendingBlocks_list.RemoveHead();
d251 3
a253 2
		// Not always allocated
		if (pending->zStream) {
d255 1
a255 1
			delete pending->zStream;			
d260 1
a260 1
	if (m_eRating != PF_RATING_NONE || m_strComment.GetLength()>0)
d263 1
a263 1
		m_strComment="";
d270 1
d277 2
a278 1
void CUpDownClient::ProcessHelloPacket(char* pachPacket, uint32 nSize){
d280 1
a280 1
	CSafeMemFile data((BYTE*)pachPacket,nSize);	
d282 2
a283 2
	data.Read(&hashsize,1);
	ProcessHelloTypePacket(data);	
d287 2
a288 1
void CUpDownClient::ProcessHelloAnswer(char* pachPacket, uint32 nSize){
d290 2
a291 2
	CSafeMemFile data((BYTE*)pachPacket,nSize);
	ProcessHelloTypePacket(data);	
d295 2
a296 1
void CUpDownClient::ProcessHelloTypePacket(CSafeMemFile& data){
d300 1
a300 1
	data.Read(&m_achUserHash,16);
d302 1
a302 1
	data.Read(&nUserID,4);
d305 1
a305 1
	data.Read(&m_nUserPort,2); // hmm clientport is sent twice - why?
d307 2
a308 2
	data.Read(&tagcount,4);
	bool crashed = false; //Vorlost    
d314 1
a314 1
		switch(temptag->GetSpecialTag())
d316 14
a329 14
			case CT_NAME:				
				m_pszUsername.Empty();	//clear a user name
				if (temptag->GetStringValue().IsEmpty())
				{
					crashed = true; 
					uchar crashash[16]; 
					md4cpy(crashash,m_achUserHash);
					CString buffer = FileHashToString(crashash);					
					AddDebugLogLine(false,_T("%s: Invalid user name received! Userhash:%s, IP:%s, Userport:%d"),__FUNCTION__,buffer,m_szFullUserIP,m_nUserPort);
					m_pszUsername = _T("[Invalid user name]"); //Vorlost
				}
				else
					m_pszUsername.SetString(temptag->GetStringValue(),temptag->GetStringValue().GetLength()); //eklmn: used CSimpleString class & fuctions
				break;
d331 2
a332 2
				m_nClientVersion = temptag->GetIntValue();
				break;
d334 5
a338 5
				if ( temptag->GetIntValue() != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID ) 
				{
					wrong_port = true;
				}
				break;
d372 1
a372 1
				break;
d374 2
a375 2
			{                    
				if(!temptag->GetStringValue().IsEmpty()) 
d380 3
a382 3
				AddDebugLogLine(false,_T("%s: Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
					__FUNCTION__,temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_nClientVersion,
					m_pszUsername);
d388 2
a389 2
	data.Read(&m_dwServerIP,4);
	data.Read(&m_nServerPort,2);
d391 4
a394 3
	// Hybrid now has an extra uint32.. What is it for?
	// Also, many clients seem to send an extra 6? These are not eDonkeys or Hybrids..
	if ( data.GetLength() - data.GetPosition() == 4 ){
d396 5
a400 4
		data.Read(&test,4);
		if (test=='KDLM') 
			m_bIsML=true;
		else{
d405 7
a411 7
	// 7/03/2003 [moosetea] Is this commented out for a reason? it cleans up client version numbers, specifically hybrids in the main client
	//if( m_nClientVersion > 10000 && m_nClientVersion < 100000 )
	//	m_nClientVersion = m_nClientVersion - (m_nClientVersion/10000)*10000;
	//if( m_nClientVersion > 1000 )
	//	m_nClientVersion = m_nClientVersion - (m_nClientVersion/1000)*1000;
	//if( m_nClientVersion < 100 )
	//	m_nClientVersion *= 10;
d414 6
a419 5
    if(wrong_port && !m_bIsHybrid) {
        CString ip_addr;
        UINT port;
        socket->GetPeerName(ip_addr, port);
		AddDebugLogLine(false,_T("%s: User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d."),__FUNCTION__,m_pszUsername,m_nClientVersion, ip_addr,m_nUserPort );
d427 2
a428 1
	socket->GetPeerName((SOCKADDR*)&sockAddr,(int*)&nSockAddrLen);
d430 1
d434 2
a435 2
	// If lancast is enabled check to see if this client is on the LAN
	b_IsOnLan = ((g_eMuleApp.m_pGlobPrefs->GetLancastEnabled()) && ((g_eMuleApp.m_pGlobPrefs->GetLancastIP()&g_eMuleApp.m_pGlobPrefs->GetLancastSubnet()) == (m_dwUserIP&g_eMuleApp.m_pGlobPrefs->GetLancastSubnet())));
d439 1
a439 1
	// if (crashed) AddDebugLogLine(false,_T("The invalid user name was sent from IP:%s"), m_szFullUserIP);
d441 3
a443 2
	// get client credits
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn() && !crashed){  // obaldin: we shouldn't trust the client who tried to crash us
d455 2
a456 2
	// Make sure if this user is a highid user there userid matches there ip address
	if(!HasLowID() && m_nUserID != m_dwUserIP)
d460 1
a460 1
	md4cpy(key,m_achUserHash);
d462 10
a471 9
	if ((m_Friend = g_eMuleApp.m_pFriendList->LinkFriend(key, m_dwUserIP, m_nUserPort) ) != NULL){
		m_Friend->m_LinkedClient = this;
		m_Friend->m_dwHasHash = 1;
		for( int i = 0; i < 16; i++ )
			m_Friend->m_abyUserhash[i] = GetUserHash()[i];
		m_Friend->m_strName.Format(_T("%s"), m_pszUsername);
		m_Friend->m_dwLastUsedIP = m_dwUserIP;
		m_Friend->m_nLastUsedPort = m_nUserPort;
		g_eMuleApp.m_pFriendList->RefreshFriend(m_Friend);
d477 1
a477 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.SetItem(g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.GetTabByClient(this),&newitem);
d481 3
a483 3
	//--- xrmb:hashthieves1 ---
	//--- detectmystolenhash ---
	uint64 id=getUID();
d489 1
a489 1
		i_TotalClients = offensecounter.GetSize()-1;
d492 1
a492 1
	// now start to check actions
d494 2
a495 1
	if(g_eMuleApp.m_pServerConnect->GetClientID()!=m_nUserID && md4cmp(m_achUserHash, g_eMuleApp.m_pGlobPrefs->GetUserHash())==0 && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d498 1
a498 1
		hashthief=true;
d502 2
a503 2
		AddDebugLogLine(false, _T("%s: Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_pszUsername,
			(uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), m_nUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients);
d507 1
a507 1
	//--- detect id-changer ---
d509 4
a512 4
	uint64 thishash=0;
	for(int i = 0; i < 8; i++ )
		thishash += GetUserHash()[i] << (i*8) ^ GetUserHash()[i+8] << (i*8);
	if (hashbase.Lookup(id, lasthash) && lasthash!=thishash)
d514 1
a514 1
		hashthief=true;
d518 2
a519 2
		AddDebugLogLine(false, _T("%s: Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), __FUNCTION__, m_pszUsername,
			(uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), m_nUserPort, (i_TotalClientActions + last_actions), i_TotalActions, i_TotalClients);
d521 1
a521 1
	hashbase[id]=thishash;
d523 2
a524 2
	//--- famous stolen hashs/names ---
	if(IsStolenName())
d526 1
a526 1
		hashthief=true;
d530 2
a531 2
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_pszUsername,
						(uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), m_nUserPort, (i_TotalClientActions + last_actions), i_TotalActions);
d534 1
a534 1
	if((i_TotalClientActions + last_actions)>=3 && g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())
d539 3
a541 2
	if (last_actions != 0) {
		offensecounter[id]=i_TotalClientActions + last_actions;
d544 1
a544 1
	//--- :xrmb ---
d556 22
a577 22
		
	if(!m_pszUsername.IsEmpty() && (
	//--- equals ---
		m_pszUsername == "pbwll" ||
		m_pszUsername == "unix user" ||
		m_pszUsername == "http://emule-element.tk" // EC 14.08.03 0-Upload Mod default nickname
	//--- begins with ---
		|| m_pszUsername.Find("Odin") != -1 
		|| m_pszUsername.Find("$GAM3R$") != -1 
		|| m_pszUsername.Find("G@@m3rs Edit") != -1 
		|| m_pszUsername.Find("G@@m3rs Edit") != -1 
		|| m_pszUsername.Find("[RAMMSTEIN") != -1 
		|| m_pszUsername.Find("[toXic]") != -1 
		|| m_pszUsername.Find("Leecha") != -1 
		|| m_pszUsername.Find("leecha") != -1 
		|| m_pszUsername.Find("eDevil") != -1 
		|| m_pszUsername.Find("darkmule") != -1 
		|| m_pszUsername.Find("DarkMule") != -1
		|| m_pszUsername.Find("eVortex") != -1
		|| m_pszUsername.Find("|eVorte|X|") != -1 
		|| m_pszUsername.Find("MISON") != -1 
		|| m_pszUsername.Find("Mison") != -1))
d581 1
a581 1
		
d589 4
a592 4
		
	if (!m_modVerString.IsEmpty() && (
		m_modVerString.Find("eVortex") != -1 
		|| m_modVerString.Find("Mison") != -1))
d601 3
a603 2
//v:- eklmn: do something if there is a socket
void CUpDownClient::SendHelloPacket(){
d605 1
a605 1
	// if IP is filtered, dont greet him but disconnect...
d607 2
a608 1
	if (socket){
d612 1
a612 1
		socket->GetPeerName((SOCKADDR*)&sockAddr,(int*)&nSockAddrLen);
d615 1
a615 1
		data.Write(&hashsize,1);
d620 1
a620 1
		socket->SendPacket(packet,true);
d626 2
a627 1
void CUpDownClient::SendMuleInfoPacket(bool bAnswer){
d630 1
a630 1
	if (socket)
d634 1
a634 1
		data.Write(&version,1);
d636 1
a636 1
		data.Write(&protversion,1);
d638 2
a639 2
		data.Write(&tagcount,4);
		CEmuleTag tag(ET_COMPRESSION,1);
d641 1
a641 1
		CEmuleTag tag2(ET_UDPVER,3);	// netwolf: complete sources UDP
d643 1
a643 1
		CEmuleTag tag3(ET_UDPPORT,g_eMuleApp.m_pGlobPrefs->GetUDPPort());
d645 1
a645 1
		CEmuleTag tag4(ET_SOURCEEXCHANGE,1);
d647 1
a647 1
		CEmuleTag tag5(ET_COMMENTS,1);
d653 1
a653 1
		CEmuleTag tag8(ET_EXTENDEDREQUEST,2);
d657 1
a657 1
		CEmuleTag tag10(ET_L2HAC,FILEREASKTIME);	//<<-- enkeyDEV(th1) -L2HAC-
d659 3
a661 3
        CEmuleTag tag11(ET_FEATURES,(uint32)(g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0));
        tag11.WriteToFile(data);
		Packet* packet = new Packet(&data,OP_EMULEPROT);
d668 1
a668 1
		socket->SendPacket(packet,true,true);
d674 2
a675 1
void CUpDownClient::ProcessMuleInfoPacket(char* pachPacket, uint32 nSize){
d677 1
a677 1
	CSafeMemFile data((BYTE*)pachPacket,nSize);
d679 2
a680 2
	data.Read(&m_byEmuleVersion,1);
	if( m_byEmuleVersion == 0x2B )
d683 1
a683 1
	data.Read(&protversion,1);
d685 4
a688 4
	//implicitly supported options by older clients
	if (protversion == EMULE_PROTOCOL) 
    {
		//in the future do not use version to guess about new features
d690 1
a690 1
		if(m_byEmuleVersion < 0x25 && m_byEmuleVersion > 0x22)
d693 1
a693 1
		if(m_byEmuleVersion < 0x25 && m_byEmuleVersion > 0x21)
d696 1
a696 1
		if(m_byEmuleVersion == 0x24)
d699 6
a704 6
		// Shared directories are requested from eMule 0.28+ because eMule 0.27 has a bug in 
		// the OP_ASKSHAREDFILESDIR handler, which does not return the shared files for a 
		// directory which has a trailing backslash.
		// MLdonkey currently does not support shared directories
		// eMule+ supports shared directories with 1h (0x0108)
		if(m_byEmuleVersion >= 0x28 && !m_bIsML && (PlusVersion()==0 || PlusVersion()>=0x0108)) 
d707 3
a709 1
	} else {		
d717 1
a717 1
	data.Read(&tagcount,4);
d724 1
a724 1
			switch(temptag->GetSpecialTag())
d726 1
a726 1
			case ET_COMPRESSION:
d729 1
a729 1
			case ET_UDPPORT:
d732 1
a732 1
			case ET_UDPVER:
d735 1
a735 1
			case ET_SOURCEEXCHANGE:
d738 1
a738 1
			case ET_COMMENTS:
d741 1
a741 1
			case ET_EXTENDEDREQUEST:
d744 1
a744 1
			case ET_COMPATABLECLIENT:
d747 1
a747 1
			case ET_MOD_FEATURESET:
d749 1
a749 1
			case ET_MOD_VERSION:
d752 1
a752 1
			case ET_MOD_PROTOCOL:				
d755 1
a755 1
			case ET_MOD_PLUS:
d758 1
a758 1
			case ET_MOD_TAROD:
d761 44
a804 44
			case ET_MOD_BOWLFISH:
			case ET_MOD_TAROD_VERSION:
			case ET_MOD_FUSION:
			case ET_MOD_FUSION_VERSION:
			case ET_MOD_Morph:
			case ET_MOD_Morph_VERSION:
			case ET_MOD_MorTillo:
			case ET_MOD_MorTillo_VERSION:
			case ET_MOD_LSD:
			case ET_MOD_LSD_VERSION:
			case ET_MOD_LOVELACE_VERSION:
			case ET_MOD_OXY:
			case ET_MOD_UNKNOWNx12:
			case ET_MOD_UNKNOWNx13:
			case ET_MOD_UNKNOWNx14:
			case ET_MOD_UNKNOWNx17:
			case ET_MOD_UNKNOWNx2F:
			case ET_MOD_UNKNOWNx36:
			case ET_MOD_UNKNOWNx3C:
			case ET_MOD_UNKNOWNx41:
			case ET_MOD_UNKNOWNx42:
			case ET_MOD_UNKNOWNx43:
			case ET_MOD_UNKNOWNx50:
			case ET_MOD_UNKNOWNx59:
			case ET_MOD_UNKNOWNx5B:
			case ET_MOD_UNKNOWNx5C:
			case ET_MOD_UNKNOWNx60:
			case ET_MOD_UNKNOWNx64:
			case ET_MOD_UNKNOWNx76:
			case ET_MOD_UNKNOWNx85:
			case ET_MOD_UNKNOWNx86:
			case ET_MOD_UNKNOWNx91:
			case ET_MOD_UNKNOWNx92:
			case ET_MOD_UNKNOWNx93:
			case ET_MOD_UNKNOWNxA0:
			case ET_MOD_UNKNOWNxA1:
			case ET_MOD_UNKNOWNxA6:
			case ET_MOD_UNKNOWNxB1:
			case ET_MOD_UNKNOWNxB4:
			case ET_MOD_UNKNOWNxC8:
			case ET_MOD_UNKNOWNxC9:
			case ET_MOD_UNKNOWNxDA:
			   	break;
			case ET_L2HAC:	// START enkeyDEV(th1) -L2HAC-
d807 5
a811 5
			case ET_INCOMPLETEPARTS: // enkeyDEV(th1) -ICS-
			   	break;
			case ET_FEATURES:	// secure credits (official 0.29b)
				// Bits 31- 8: 0 - reserved
				// Bit   7- 0: secure identification
d814 2
a815 2
			default:
				if(!temptag->GetStringValue().IsEmpty()) 
d820 2
a821 2
				AddDebugLogLine(false,_T("%s: Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
					__FUNCTION__, temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_pszUsername,GetClientNameAndVersionString(this) );
d828 6
a833 4
	// START enkeyDEV(th1) -L2HAC- Enable every emule anyway and disable bad clients
	if (!m_L2HAC_time) m_L2HAC_time = L2HAC_DEFAULT_EMULE;
	if (m_L2HAC_time < L2HAC_MIN_TIME || m_L2HAC_time > L2HAC_MAX_TIME) m_L2HAC_time = 0;
	// END enkeyDEV(th1) -L2HAC-
d835 2
a836 1
	if( m_byDataCompVer == 0 ){
d842 2
a843 2
	}	
	//ReGetClientSoft();	// 9/5/2003 [Moosetea] Official client, this messes the stats up, creates lots of invalid edonkey clients
d848 1
a848 1
	// emuleplus supports 'complete sources' with versions 1f and 1g (force ET_EXTENDEDREQUEST v2 for backward compatibility)
d850 1
a850 1
		m_byExtendedRequestsVer= 2;
d855 2
a856 1
void CUpDownClient::SendHelloAnswer(){
d859 1
a859 1
	if (socket)
d863 1
a863 1
		Packet* packet = new Packet(&data);	
d866 1
a866 1
		socket->SendPacket(packet,true);
d872 2
a873 1
void CUpDownClient::SendHelloTypePacket(CMemFile& data){
d875 4
a878 4
	// By Maverick
	// Emulate eDonkey or MlDonkey in case of a connection to a MlDonkey
	// This patch is introduced to conteract the MlDonkey's politics against 
	// eMule. (eMules can only occupy 1/3 of the upload queue of a MlDonkey)
d880 7
a886 7
	md4cpy(hash,g_eMuleApp.m_pGlobPrefs->GetUserHash());
	// Checking for MLDonkey does not help anymore since they have removed this feature so 
	// we emulate now an eDonkey to all except eMule. Note do not loose a word about this
	// in any forum. Otherwise we have to adapt to them again.
    // Does not help anymore either mlDonkey uses eMule type userhashes
    // Furthermore the servers have a problem with this feature so I had to go back to 
    // emulating only with MlDonkey
d892 1
a892 1
			memcpy2(&hash[5],&random,1);
d894 1
a894 1
			memcpy2(&hash[14],&random,1);
d897 2
a898 2
	data.Write(hash,16);
	// END Patch Maverick
d900 1
d902 1
a902 1
	data.Write(&clientid,4);
d904 1
d906 1
a906 1
	data.Write(&nPort,2);
d908 2
a909 2
	data.Write(&tagcount,4);
	CClientTag* tag = new CClientTag(CT_NAME,g_eMuleApp.m_pGlobPrefs->GetUserNick().GetBuffer());
d912 1
a912 1
	tag = new CClientTag(CT_VERSION,EDONKEYVERSION);
d920 3
a922 1
	if (g_eMuleApp.m_pServerConnect->IsConnected()){
d928 1
d933 2
a934 2
	data.Write(&dwIP,4);
	data.Write(&nPort,2);
d938 2
a939 1
void CUpDownClient::ProcessMuleCommentPacket(char* pachPacket, uint32 nSize){
d941 3
a943 2
	if ((reqfile != NULL) && (nSize > 2)){
		CSafeMemFile data((BYTE*)pachPacket,nSize);
d945 7
a951 5
		data.Read(&m_eRating,sizeof(m_eRating));
		data.Read(&length,sizeof(length));        
		if (length>50) length=50;
		if (length>0){			
			data.Read(m_strComment.GetBuffer(length+1),length);
d953 1
a953 1
			//(SyruS) netwolf commentfilter
d955 2
a956 1
			if (!strList.IsEmpty()) {
d960 5
a964 3
				CString resToken(strList.Tokenize(_T("|"),curPos));
				while (!resToken.IsEmpty()) {
					if (lowComment.Find(resToken)>-1) {
d966 1
a966 1
						m_strComment="";
d970 1
a970 1
					resToken = strList.Tokenize(_T("|"),curPos);
d977 1
a977 1
			}			
d979 2
a980 1
		if (m_eRating != PF_RATING_NONE) {
d990 1
a990 1
void CUpDownClient::Disconnected()
d992 2
d996 1
a996 1
    if (!g_eMuleApp.m_pClientList->IsValidClient(this))
d998 32
a1029 25
		AddDebugLogLine(false, _T("%s: Invalid client."), __FUNCTION__);
        return;
    }
	ASSERT(g_eMuleApp.m_pClientList->IsValidClient(this));

	if (GetUploadState() == US_UPLOADING)
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(this,ETS_DISCONNECT);
	if (GetDownloadState() == DS_DOWNLOADING)
		SetDownloadState(DS_ONQUEUE);
	if ((GetDownloadState() == DS_REQHASHSET) && reqfile != NULL)
        reqfile->m_bHashSetNeeded = true;
	ASSERT(g_eMuleApp.m_pClientList->IsValidClient(this));
	//check if this client is needed in any way, if not delete it
	bool bDelete = true;
	switch(m_byUploadState){
		case US_ONUPLOADQUEUE:
			bDelete = false;
	};
	switch(m_nDownloadState){
		case DS_ONQUEUE:
		case DS_TOOMANYCONNS:
		case DS_NONEEDEDPARTS:
		case DS_LOWTOLOWIP:
			bDelete = false;
	};
d1031 10
a1040 8
	switch(m_byUploadState){
		case US_CONNECTING:
		case US_WAITCALLBACK:
		case US_ERROR:
			bDelete = true;
	};
	switch(m_nDownloadState){
		case DS_CONNECTING:
d1042 8
a1049 4
			m_cFailed++;
			if (m_cFailed <= 2){
				TryToConnect();
				return;
d1051 13
a1064 12
		case DS_WAITCALLBACK:
		case DS_ERROR:
			bDelete = true;
	};
#if KEEP_BANNED_CLIENTS
	//SyruS no deletion of banned client //this works...
	if (m_bBanned)
	{
		bDelete = false;
		if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
			AddDebugLogLine(false,_T("%s: Keeping banned client '%s' after disconnect"), __FUNCTION__, GetUserName());
	}
d1066 6
a1071 4
	if (GetChatState() != MS_NONE){	//SyruS (0.29c)
		bDelete = false;
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ConnectingResult(this,false);
	}
d1073 6
a1078 5
	if (socket){
		ASSERT (g_eMuleApp.m_pListenSocket->IsValidSocket(socket));
		socket->Safe_Delete();
	}
	socket = 0;
a1079 6
	if (m_iFileListRequested){
		AddDebugLogLine(false,_T("%s: ") + ::GetResString(IDS_SHAREDFILES_FAILED),__FUNCTION__, GetUserName());
		m_iFileListRequested = m_iFileListRequestedSave = 0;
	}
	if (m_Friend)
		g_eMuleApp.m_pFriendList->RefreshFriend(m_Friend);
d1081 20
a1100 3
	if (bDelete)
	{
		delete this;
d1104 1
a1104 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(this);
		m_dwEnteredConnectedState = 0;
d1106 1
d1108 2
d1112 2
a1113 1
bool CUpDownClient::TryToConnect(bool bIgnoreMaxCon){
d1116 2
a1117 1
	if (g_eMuleApp.m_pListenSocket->TooManySockets() && !bIgnoreMaxCon && !(socket && socket->IsConnected())){
d1121 2
a1122 2
// BavarianSnail - filter LowIDs separately from HighIDs
	if ( (unsigned)m_dwUserIP > 0 )
d1124 2
a1125 2
		// case 1: it's a Client with known IP, always test m_dwUserIP instead of m_nUserID
		if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_dwUserIP))
d1127 1
a1127 1
			AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d1135 1
a1135 1
		if ( (unsigned)m_nUserID > 16777215 )
d1137 2
a1138 2
			// case 2: it's HighID with m_dwUserIP empty, test m_nUserID instead
			if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_nUserID))
d1140 1
a1140 1
				AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d1148 2
a1149 2
			// case 3: it's a LowID without known IP, cannot test yet
			// AddDebugLogLine(false,_T("%s: Cannot filter LowID (no IP yet): m_uUserID %u m_dwUserIP %u GetFullIP %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP());
d1152 3
a1154 2
// -BavarianSnail
	if ((g_eMuleApp.m_pServerConnect->GetClientID() < 16777216) && HasLowID()){
d1157 2
a1158 1
		else if (GetDownloadState() == DS_REQHASHSET){
d1162 2
a1163 1
		if (GetUploadState() == US_CONNECTING){
d1171 6
a1176 4
	if (!socket){
		socket = new CClientReqSocket(g_eMuleApp.m_pGlobPrefs,this);
		if (!socket->Create()){
			socket->Safe_Delete();
d1180 7
a1186 5
	else if (!socket->IsConnected()){
		socket->Safe_Delete();
		socket = new CClientReqSocket(g_eMuleApp.m_pGlobPrefs,this);
		if (!socket->Create()){
			socket->Safe_Delete();
d1190 2
a1191 1
	else{
d1196 3
a1198 2
	// MOD Note: Do not change this part - Merkur
	if (HasLowID()){
d1201 2
a1202 1
		if (GetUploadState() == US_CONNECTING){
d1208 4
a1211 3
		if (g_eMuleApp.m_pServerConnect->IsLocalServer(m_dwServerIP,m_nServerPort)){
			Packet* packet = new Packet(OP_CALLBACKREQUEST,4);
			memcpy2(packet->m_pcBuffer,&m_nUserID,4);
d1217 1
a1217 1
			if (GetUploadState() == US_NONE && (!GetRemoteQueueRank() || m_bReaskPending) )
d1233 1
d1235 1
a1235 1
	// MOD Note - end
d1239 1
a1239 1
		socket->Connect(GetFullIP(),GetUserPort());
d1241 1
d1245 1
a1245 1
	
d1250 2
a1251 1
void CUpDownClient::ConnectionEstablished(){
d1253 2
a1254 2
	m_cFailed = 0;
	// ok we have a connection, lets see if we want anything from this client
d1256 3
a1258 2
		g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ConnectingResult(this,true);
	switch(GetDownloadState()){
d1261 3
a1263 3
			m_bReaskPending = false;
			SetDownloadState(DS_CONNECTED);
			SendFileRequest();
d1265 2
a1266 1
	if (m_bReaskPending){
d1268 2
a1269 1
		if (GetDownloadState() != DS_NONE && GetDownloadState() != DS_DOWNLOADING){
d1274 2
a1275 1
	switch(GetUploadState()){
d1278 5
a1282 5
			if (g_eMuleApp.m_pUploadQueue->IsDownloading(this))
			{
				SetUploadState(US_UPLOADING);
				Packet* packet = new Packet(OP_ACCEPTUPLOADREQ);
				g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d1284 2
a1285 1
				socket->SendPacket(packet,true);
d1287 3
a1289 2
				SetLastGotULData();	//eklmn: set Upload Timer
			}
d1291 3
a1293 2
	if (m_iFileListRequested == 1){
		Packet* packet = new Packet(m_fSharedDirectories ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES);
d1296 2
a1297 1
		socket->SendPacket(packet,true,true);
d1299 1
d1310 1
a1310 1
 	else if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L')
d1320 6
a1325 2
	// If this client hasnt been contacted, its is SO_UNKNOWN
	if (m_pszUsername.IsEmpty()) {m_clientSoft=SO_UNKNOWN;return;}
d1327 1
a1327 1
	// What is this clients hash type
d1329 1
a1329 1
	switch (iHashType) 
d1331 23
a1353 2
		case SO_OLDEMULE: // If the client is an old emule
			m_clientSoft= SO_OLDEMULE;
d1355 2
a1356 2
		case SO_MLDONKEY: // If the client is an Ml donkey
			m_clientSoft= SO_MLDONKEY;
d1358 6
a1363 2
		case SO_EMULE:  // If the client is an Emule compatable client
			if( m_byEmuleVersion!=0x99 )
d1365 2
a1366 3
				CString temp;
				temp.Format( "%02X", m_byEmuleVersion );
				m_nClientVersion = _tstoi(temp.GetBuffer())*10;
d1368 2
a1369 26
			switch(m_byCompatableClient) 
			{
				case 0:
					m_clientSoft = SO_EMULE;
					break;
				case 1:
					m_clientSoft = SO_CDONKEY;
					break;
				case 2:
					m_clientSoft = SO_LMULE;
					break;
				case 4:
					m_clientSoft = SO_SHAREAZA;
					break;
				default:
					if (m_bIsML)
						m_clientSoft = SO_MLDONKEY;
					else if (m_bIsHybrid)
						m_clientSoft = SO_EDONKEYHYBRID;
					else
					{
						m_clientSoft = SO_EMULE;
						AddDebugLogLine(false,"%s: New Compatable ClientSoft ET_COMPATABLECLIENT = %i client will be listed as an emule ",__FUNCTION__, m_byCompatableClient);
					}
			}// end: switch m_byCompatableClient 
			break;
d1371 8
a1378 8
			// If the client is an Ml donkey
			if (m_bIsML) 
				m_clientSoft= SO_MLDONKEY;
			// Were left with donkeys and Hybrids
			if( m_bIsHybrid )
				m_clientSoft=SO_EDONKEYHYBRID;
			else
				m_clientSoft=SO_EDONKEY;
d1383 2
a1384 1
void CUpDownClient::RequestSharedFileList(){
d1386 3
a1388 2
	if (m_iFileListRequested == 0){
		AddDebugLogLine(true,_T("%s: ") + ::GetResString(IDS_SHAREDFILES_REQUEST),__FUNCTION__, GetUserName());
d1395 2
a1396 1
void CUpDownClient::ProcessSharedFileList(char* pachPacket, uint32 nSize, LPCTSTR pszDirectory){
d1398 3
a1400 2
	if (m_iFileListRequested > 0){
		bool bFirstDir= (m_iFileListRequested == m_iFileListRequestedSave);
d1402 1
a1402 1
		g_eMuleApp.m_pSearchList->ProcessSearchanswer(pachPacket,nSize,this,pszDirectory,bFirstDir);
d1409 2
a1410 1
	if(this == NULL) return _T("");
d1413 1
a1413 1
	// build info text and display it
d1420 3
a1422 3
		stat.Format(GetResString(IDS_FILESTATS_SESSION)+GetResString(IDS_FILESTATS_TOTAL),
					file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransferred()),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransferred()));
d1434 4
a1437 2
void CUpDownClient::SetUserHash(uchar* m_achTempUserHash){
	if( m_achTempUserHash == NULL ){
d1441 1
a1441 1
	md4cpy(m_achUserHash,m_achTempUserHash);
d1448 2
a1449 1
	if(this == NULL) return _T("");
d1452 1
a1452 1
	// build info text and display it
d1461 3
a1463 3
		stat.Format(sFileName+GetResString(IDS_TT_FILESTATS_SESSION)+GetResString(IDS_TT_FILESTATS_TOTAL),
					file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransferred()),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransferred()));
d1478 2
a1479 1
void CUpDownClient::SendPublicKeyPacket(){
d1483 4
a1486 3
	// send our public key to the client who requested it
	if (socket == NULL || credits == NULL || m_SecureIdentState != IS_KEYANDSIGNEEDED){
		ASSERT ( false );
d1492 1
a1492 1
    Packet* packet = new Packet(OP_PUBLICKEY,g_eMuleApp.m_pClientCreditList->GetPubKeyLen() + 1,OP_EMULEPROT);
d1494 1
a1494 1
	memcpy2(packet->m_pcBuffer+1,g_eMuleApp.m_pClientCreditList->GetPublicKey(), g_eMuleApp.m_pClientCreditList->GetPubKeyLen());
d1497 2
a1498 1
	socket->SendPacket(packet,true,true);
d1500 1
d1504 6
a1509 4
void CUpDownClient::SendSignaturePacket(){
	// signate the public key of this client and send it
	if (socket == NULL || credits == NULL || m_SecureIdentState == 0){
		ASSERT ( false );
d1518 1
d1521 3
a1523 2
	// do we have a challenge value received (actually we should if we are in this function)
	if (credits->m_dwCryptRndChallengeFrom == 0){
d1527 2
a1528 2
	// v2
	// we will use v1 as default, except if only v2 is supported
d1530 1
a1530 1
	if ( (m_bySupportSecIdent&1) == 1 )
d1538 6
a1543 3
	if (bUseV2){
		if (g_eMuleApp.m_pServerConnect->GetClientID() == 0 || g_eMuleApp.m_pServerConnect->IsLowID()){
			// we cannot do not know for sure our public ip, so use the remote clients one
d1547 2
a1548 1
		else{
d1550 1
a1550 1
			byChaIPKind  = CRYPT_CIP_LOCALCLIENT;
d1553 1
a1553 1
	//end v2
d1556 4
a1559 3
	uint8 siglen = g_eMuleApp.m_pClientCreditList->CreateSignature(credits, achBuffer,  250, ChallengeIP, byChaIPKind );
	if (siglen == 0){
		ASSERT ( false );
d1562 1
a1562 1
	Packet* packet = new Packet(OP_SIGNATURE,siglen + 1+ ( (bUseV2)? 1:0 ),OP_EMULEPROT);
d1564 1
a1564 1
	memcpy2(packet->m_pcBuffer+1,achBuffer, siglen);
d1567 1
a1567 1
		packet->m_pcBuffer[1+siglen] = byChaIPKind;
d1569 2
a1570 1
	socket->SendPacket(packet,true,true);
d1572 1
d1576 2
a1577 1
void CUpDownClient::ProcessPublicKeyPacket(uchar* pachPacket, uint32 nSize){
d1582 5
a1586 3
	if (socket == NULL || credits == NULL || pachPacket[0] != nSize-1
		|| nSize == 0 || nSize > 250){
		ASSERT ( false );
d1591 6
a1596 4
	// the function will handle everything (mulitple key etc)
	if (credits->SetSecureIdent(pachPacket+1, pachPacket[0])){
		// if this client wants a signature, now we can send him one
		if (m_SecureIdentState == IS_SIGNATURENEEDED){
d1599 4
a1602 3
		else if(m_SecureIdentState == IS_KEYANDSIGNEEDED){
			// something is wrong
			g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Invalid State error: IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket",__FUNCTION__);
d1605 3
a1607 2
	else{
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Failed to use new received public key",__FUNCTION__);
d1611 2
a1612 1
void CUpDownClient::ProcessSignaturePacket(uchar* pachPacket, uint32 nSize){
d1616 1
a1616 1
	// here we spread the good guys from the bad ones ;)
d1618 3
a1620 2
	if (socket == NULL || credits == NULL || nSize == 0 || nSize > 250){
		ASSERT ( false );
d1625 1
a1625 1
	if (pachPacket[0] == nSize-1)
d1627 5
a1631 4
	else if (pachPacket[0] == nSize-2 && (m_bySupportSecIdent & 2) > 0) //v2
		byChaIPKind = pachPacket[nSize-1];
	else{
		ASSERT ( false );
d1637 5
a1641 4
	
	// we accept only one signature per IP, to avoid floods which need a lot cpu time for cryptfunctions
	if (m_dwLastSignatureIP == GetIP()){
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received multiple signatures from one client",__FUNCTION__);
d1644 4
a1647 3
	// also make sure this client has a public key
	if (credits->GetSecIDKeyLen() == 0){
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Received signature for client without public key",__FUNCTION__);
d1650 3
a1652 2
	// and one more check: did we ask for a signature and sent a challange packet?
	if (credits->m_dwCryptRndChallengeFor == 0){
d1657 4
a1660 3
	if (g_eMuleApp.m_pClientCreditList->VerifyIdent(credits, pachPacket+1, pachPacket[0], GetIP(), byChaIPKind ) ){
		// result is saved in function abouve
		//g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "'%s' has passed the secure identification, V2 State: %i", GetUserName(), byChaIPKind);
d1666 2
a1667 1
	m_dwLastSignatureIP = GetIP(); 
d1672 1
a1672 1
	// check if we need public key and signature
d1674 4
a1677 2
	if (credits){
		if (g_eMuleApp.m_pClientCreditList->CryptoAvailable()){
d1683 2
a1684 1
		if (nValue == 0){
d1686 1
a1686 1
			DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Not sending SecIdentState Packet, because State is Zero",__FUNCTION__));
d1688 1
d1691 2
a1692 2
		// crypt: send random data to sign
		uint32 dwRandom = rand()+1;
d1695 2
a1696 1
		DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, "%s: Sending SecIdentState Packet, state: %i (to '%s')", __FUNCTION__, nValue, GetUserName() ));
d1698 2
a1699 1
		Packet* packet = new Packet(OP_SECIDENTSTATE,5,OP_EMULEPROT);
d1702 1
a1702 1
		memcpy2(packet->m_pcBuffer+1,&dwRandom, sizeof(dwRandom));
d1704 2
a1705 1
		socket->SendPacket(packet,true,true);
d1707 1
d1711 2
a1712 1
void CUpDownClient::ProcessSecIdentStatePacket(uchar* pachPacket, uint32 nSize){
d1718 12
a1729 11
	switch(pachPacket[0]){
			case 0:
				m_SecureIdentState = IS_UNAVAILABLE;
				break;
			case 1:
				m_SecureIdentState = IS_SIGNATURENEEDED;
				break;
			case 2:
				m_SecureIdentState = IS_KEYANDSIGNEEDED;
				break;
		}
d1731 1
a1731 1
	memcpy2(&dwRandom, pachPacket+1,4);
d1734 1
d1739 5
a1743 4
void CUpDownClient::InfoPacketsReceived(){
	// indicates that both Information Packets has been received
	// needed for actions, which process data from both packets
	ASSERT ( m_byInfopacketsReceived == IP_BOTH );
d1745 3
a1747 2
	
	if (m_bySupportSecIdent){
@


1.161
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d208 1
@


1.160
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d1024 1
a1024 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(this);
@


1.159
log
@Modified Disconnected() so that it doesn't refresh a client right before it destroys it.
@
text
@d167 1
a167 1
		memset(&sockAddr, 0, sizeof(sockAddr));
d404 1
a404 1
	memset(&sockAddr, 0, sizeof(sockAddr));
d582 1
a582 1
		memset(&sockAddr, 0, sizeof(sockAddr));
d1373 1
a1373 1
	memcpy(packet->m_pcBuffer+1,g_eMuleApp.m_pClientCreditList->GetPublicKey(), g_eMuleApp.m_pClientCreditList->GetPubKeyLen());
d1432 1
a1432 1
	memcpy(packet->m_pcBuffer+1,achBuffer, siglen);
d1547 1
a1547 1
		memcpy(packet->m_pcBuffer+1,&dwRandom, sizeof(dwRandom));
d1572 1
a1572 1
	memcpy(&dwRandom, pachPacket+1,4);
@


1.158
log
@Formatting, comments, and name changes.
@
text
@d198 3
a1016 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(this);
d1019 1
d1021 1
d1023 2
d1026 1
@


1.157
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@a91 1
	m_byChatstate = 0;
d150 1
a150 1
	m_iRate=0;
d244 4
a247 2
	if (m_iRate>0 || m_strComment.GetLength()>0) {
		m_iRate=0; m_strComment="";
d445 1
a445 1
		if(m_byChatstate==MS_CONNECTING)
d898 1
a898 1
		data.Read(&m_iRate,sizeof(m_iRate));
d915 1
a915 1
						m_iRate=0;
d927 1
a927 1
		if (m_iRate != 0) {
d929 1
a929 1
			AddDebugLogLine(false, _T("%s: Rating for file '%s' received: %i"), __FUNCTION__, m_strClientFilename, m_iRate);
d931 1
a931 1
		if ((!m_strComment.IsEmpty()) || (m_iRate != 0))	// #zegzav:pastcomment
@


1.156
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@a932 2
	//SyruS imho we do not have to update display manual at all - it's updated a sec later automaticly
	//if (reqfile->HasRating() || reqfile->HasComment()) g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(reqfile);
@


1.155
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d23 1
a23 1
#include "memcpy_amd.h"
d1173 1
a1173 1
				Packet* packet = new Packet(OP_ACCEPTUPLOADREQ,0);
d1182 1
a1182 1
		Packet* packet = new Packet(m_fSharedDirectories ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES,0);
@


1.154
log
@new unknown emule tags
@
text
@d289 1
a289 1
	CTag* temptag;	//eklmn: small tag optimization to prevent memleaks
d292 1
a292 1
		temptag = new CTag(data);	//eklmn: small tag optimization to prevent memleaks
d586 2
a587 2
		packet->opcode = OP_HELLO;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d606 22
a627 22
		CTag tag(ET_COMPRESSION,1);
		tag.WriteTagToFile(data);
		CTag tag2(ET_UDPVER,3);	// netwolf: complete sources UDP
		tag2.WriteTagToFile(data);
		CTag tag3(ET_UDPPORT,g_eMuleApp.m_pGlobPrefs->GetUDPPort());
		tag3.WriteTagToFile(data);
		CTag tag4(ET_SOURCEEXCHANGE,1);
		tag4.WriteTagToFile(data);
		CTag tag5(ET_COMMENTS,1);
		tag5.WriteTagToFile(data);
		CTag tag6(ET_MOD_TAROD, 1);						// To check for Tarod/Plus (just curiosity)
		tag6.WriteTagToFile(data);	// It do not harms at all (!)
		CTag tag7(ET_MOD_PLUS, CURRENT_PLUS_VERSION);	// To check for eMulePlus
		tag7.WriteTagToFile(data);	                    // It doesn't do any harm (?)
		CTag tag8(ET_EXTENDEDREQUEST,2);
		tag8.WriteTagToFile(data);
		CTag tag9(ET_MOD_VERSION, _T(PLUS_VERSION_STR));
		tag9.WriteTagToFile(data);	 //More harmless than the other 2! :D
		CTag tag10(ET_L2HAC,FILEREASKTIME);	//<<-- enkeyDEV(th1) -L2HAC-
		tag10.WriteTagToFile(data);			//<<-- enkeyDEV(th1) -L2HAC-
                CTag tag11(ET_FEATURES,(uint32)(g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0));
                tag11.WriteTagToFile(data);
d630 1
a630 1
			packet->opcode = OP_EMULEINFO;
d632 1
a632 1
			packet->opcode = OP_EMULEINFOANSWER;
d634 1
a634 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d682 1
a682 1
	CTag* temptag = NULL;
d685 1
a685 1
		temptag = new CTag(data);
d824 2
a825 2
		packet->opcode = OP_HELLOANSWER;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d866 2
a867 2
	CTag* tag = new CTag(CT_NAME,g_eMuleApp.m_pGlobPrefs->GetUserNick().GetBuffer());
	tag->WriteTagToFile(data);
d869 2
a870 2
	tag = new CTag(CT_VERSION,EDONKEYVERSION);
	tag->WriteTagToFile(data);
d873 1
a873 1
//	tag->WriteTagToFile(data);
d1110 2
a1111 2
			memcpy2(packet->pBuffer,&m_nUserID,4);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
d1174 1
a1174 1
				g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d1183 1
a1183 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d1366 3
a1368 3
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
	memcpy(packet->pBuffer+1,g_eMuleApp.m_pClientCreditList->GetPublicKey(), g_eMuleApp.m_pClientCreditList->GetPubKeyLen());
	packet->pBuffer[0] = g_eMuleApp.m_pClientCreditList->GetPubKeyLen();
d1425 3
a1427 3
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
	memcpy(packet->pBuffer+1,achBuffer, siglen);
	packet->pBuffer[0] = siglen;
d1429 1
a1429 1
		packet->pBuffer[1+siglen] = byChaIPKind;
d1539 3
a1541 3
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
		packet->pBuffer[0] = nValue;
		memcpy(packet->pBuffer+1,&dwRandom, sizeof(dwRandom));
@


1.153
log
@Formatting, comments, and name changes.
@
text
@d741 1
d743 1
d748 1
@


1.152
log
@new unknown tags
@
text
@d214 1
a214 1
		socket->client = 0;
d422 1
a422 1
		if (!g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.AddServer(addsrv, true))
d934 4
d939 3
a941 4
void CUpDownClient::Disconnected(){
	EMULE_TRY
    if(!g_eMuleApp.m_pClientList->Debug_IsValidClient(this)) { // obaldin: a quick fix for a strange bug
		AddDebugLogLine(false, _T("%s: Invalid client in CUpDownClient::Disconnected"), __FUNCTION__);
d944 2
a945 1
	ASSERT(g_eMuleApp.m_pClientList->Debug_IsValidClient(this));
d950 3
a952 3
	if ((GetDownloadState() == DS_REQHASHSET) && (reqfile))
        reqfile->hashsetneeded= true;
	ASSERT(g_eMuleApp.m_pClientList->Debug_IsValidClient(this));
d1020 1
a1020 1

d1065 1
a1065 1
			reqfile->hashsetneeded = true;
@


1.151
log
@new client tag range 0xf0-0xff from official 0.40x
@
text
@d350 1
d757 1
@


1.150
log
@Temporary debug log spam control
@
text
@d318 16
@


1.149
log
@Changes from official about handling of known.met
@
text
@d1329 1
d1331 1
d1361 1
d1363 1
d1413 1
a1413 1

d1415 1
d1440 1
d1442 1
d1483 1
d1486 1
d1502 1
d1504 1
d1510 1
d1512 1
d1543 1
d1545 1
d1558 1
@


1.148
log
@Fixed new unknown eMule tags
@
text
@d1481 2
a1482 1
void CUpDownClient::SendSecIdentStatePacket(){
a1507 2
	else
		ASSERT ( false );
d1513 1
a1513 2
	if (!credits){
		ASSERT ( false );
d1515 1
a1515 1
	}
a1542 1

@


1.147
log
@Some new unknown eMule tags
@
text
@d729 1
a742 1
			case ET_MOD_UNKNOWNxB5:
@


1.146
log
@added (unsigned) to ip compare
@
text
@d724 1
d728 1
d730 1
d739 6
@


1.145
log
@lowid filtering - changed conditions order to test highids with 0 as last byte correctly
@
text
@d998 1
a998 1
	if (m_dwUserIP > 0)
d1011 1
a1011 1
		if (m_nUserID > 16777215 )
@


1.144
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d998 1
a998 1
	if (m_nUserID < 16777216)
d1000 2
a1001 2
		// it's a LowID client
		if (m_dwUserIP < 16777216)
d1003 12
a1014 6
			// write a warning if there's an IP in GetFullIP but not in m_dwUserIP
			if (GetFullIP() != "")
				AddDebugLogLine(false,_T("%s: Cannot filter client (no IP): m_nUserID: %u m_dwUserIP: %u GetFullIP: %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP());
		} else {
			// check LowID clients by m_dwUserIP instead of m_nUserID
			if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_dwUserIP))
d1016 1
a1016 2
				// AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
				AddDebugLogLine(false,_T("%s: Filtered LowID (don't connect): m_nUserID: %u m_dwUserIP: %u GetFullIP: %s %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d1022 1
a1022 4
	}
	else // check HighIDs normally by m_nUserID
	{
		if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_nUserID)) 
d1024 2
a1025 4
			AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
			Disconnected();
			g_eMuleApp.stat_filteredclients++;
			return false;
d1027 1
a1027 1
	}		
@


1.143
log
@cleanup (friendslot)
@
text
@a192 1
	
d981 2
@


1.142
log
@change a way that filterd clients will be diconnected
@
text
@a113 1
	m_bFriendSlot = false;
@


1.141
log
@updated LowID filtering
@
text
@d306 1
a306 1
					m_pszUsername.Format("%s",_T("[Invalid user name]")); //Vorlost
d309 1
a309 1
					m_pszUsername.Format("%s",temptag->GetStringValue());
d1012 1
a1012 3
#ifdef OLD_SOCKETS_ENABLED
				if (socket) socket->Safe_Delete();
#endif //OLD_SOCKETS_ENABLED
d1023 1
a1023 3
#ifdef OLD_SOCKETS_ENABLED
			if (socket) socket->Safe_Delete();
#endif //OLD_SOCKETS_ENABLED
@


1.140
log
@reinsert ipfilter patch for lowids
@
text
@d1000 1
d1003 3
a1005 1
			AddDebugLogLine(false,_T("%s: Cannot filter client (no IP): m_nUserID: %u m_dwUserIP: %u GetFullIP: %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP());
d1007 2
a1008 1
			if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_dwUserIP)) // check IP instead of ID for LowIDs
d1020 1
a1020 1
	else // now HighIDs
@


1.139
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d997 2
a998 1
	if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_nUserID)) 
d1000 8
a1007 1
		AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d1009 1
a1009 1
		if (socket) socket->Safe_Delete();
d1011 4
a1014 2
		g_eMuleApp.stat_filteredclients++;
		return false;
d1016 13
@


1.138
log
@handle LowIDs correctly in ipfilter search and debug output for clients with no IP (bug?) in m_dwUserIP
@
text
@a302 1
					#ifndef AMD
a303 3
					#else
					memcpy_amd(crashash,m_achUserHash,16);
					#endif
a810 1
	#ifndef AMD
a811 3
	#else
	memcpy_amd(hash,g_eMuleApp.m_pGlobPrefs->GetUserHash(),16);
	#endif
d823 1
a823 2
			#ifndef AMD
			memcpy(&hash[5],&random,1);
d825 1
a825 6
			memcpy(&hash[14],&random,1);
			#else
			memcpy_amd(&hash[5],&random,1);
			random = rand();
			memcpy_amd(&hash[14],&random,1);
			#endif
d997 1
a997 2
// BavarianSnail - filter LowIDs separately from HighIDs
	if (m_nUserID < 16777216)
d999 1
a999 8
		if (m_dwUserIP < 16777216)
		{
			AddDebugLogLine(false,_T("%s: Cannot filter client (no IP): m_nUserID: %u m_dwUserIP: %u GetFullIP: %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP());
		} else {
			if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_dwUserIP)) // check IP instead of ID for LowIDs
			{
				// AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
				AddDebugLogLine(false,_T("%s: Filtered LowID (don't connect): m_nUserID: %u m_dwUserIP: %u GetFullIP: %s %s"), __FUNCTION__, m_nUserID,m_dwUserIP,GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d1001 1
a1001 1
				if (socket) socket->Safe_Delete();
d1003 2
a1004 4
				g_eMuleApp.stat_filteredclients++;
				return false;
			}
		}
a1005 13
	else // now HighIDs
	{
		if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_nUserID)) 
		{
			AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
#ifdef OLD_SOCKETS_ENABLED
			if (socket) socket->Safe_Delete();
#endif //OLD_SOCKETS_ENABLED
			g_eMuleApp.stat_filteredclients++;
			return false;
		}
	}		
// -BavarianSnail
d1053 1
a1053 5
			#ifndef AMD
			memcpy(packet->pBuffer,&m_nUserID,4);
			#else
			memcpy_amd(packet->pBuffer,&m_nUserID,4);
			#endif
@


1.137
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d1011 2
a1012 1
	if ( g_eMuleApp.m_pIPFilter->IsFiltered(m_nUserID)) 
d1014 8
a1021 1
		AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
d1023 1
a1023 1
		if (socket) socket->Safe_Delete();
d1025 4
a1028 2
		g_eMuleApp.stat_filteredclients++;
		return false;
d1030 13
@


1.136
log
@Second batch of name changes
@
text
@d21 1
a21 1
#include "uploadqueue.h"
d56 1
a56 1
//			bIsOnLan = (theApp.glob_prefs->GetLancastEnabled() && ((theApp.glob_prefs->GetLancastIP()&theApp.glob_prefs->GetLancastSubnet()) == (m_dwUserIP&theApp.glob_prefs->GetLancastSubnet())));
d204 1
a204 1
	if (m_bBanned && !theApp.glob_prefs->GetCMNotLog())
d208 1
a208 1
	theApp.clientlist->RemoveClient(this);
d211 1
a211 1
		theApp.friendlist->RefreshFriend(m_Friend);
d255 1
a255 1
	DEBUG_ONLY (theApp.listensocket->Debug_ClientDeleted(this));
d398 1
a398 1
	b_IsOnLan = ((theApp.glob_prefs->GetLancastEnabled()) && ((theApp.glob_prefs->GetLancastIP()&theApp.glob_prefs->GetLancastSubnet()) == (m_dwUserIP&theApp.glob_prefs->GetLancastSubnet())));
d405 1
a405 1
	if (theApp.glob_prefs->GetAddServersFromConn() && !crashed){  // obaldin: we shouldn't trust the client who tried to crash us
d411 1
a411 1
		if (!theApp.emuledlg->serverwnd.serverlistctrl.AddServer(addsrv, true))
d423 2
a424 2
	credits = theApp.clientcredits->GetCredit(key);
	if ((m_Friend = theApp.friendlist->LinkFriend(key, m_dwUserIP, m_nUserPort) ) != NULL){
d432 1
a432 1
		theApp.friendlist->RefreshFriend(m_Friend);
d438 1
a438 1
			theApp.emuledlg->chatwnd.chatselector.SetItem(theApp.emuledlg->chatwnd.chatselector.GetTabByClient(this),&newitem);
d455 1
a455 1
	if(theApp.serverconnect->GetClientID()!=m_nUserID && md4cmp(m_achUserHash, theApp.glob_prefs->GetUserHash())==0 && theApp.glob_prefs->GetMlDonkeyCM())
d490 1
a490 1
		theApp.emuledlg->AddDebugLogLine(false, _T("%s: Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), __FUNCTION__, m_pszUsername,
d494 1
a494 1
	if((i_TotalClientActions + last_actions)>=3 && theApp.glob_prefs->GetMlDonkeyCM())
d576 1
a576 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d599 1
a599 1
		CTag tag3(ET_UDPPORT,theApp.glob_prefs->GetUDPPort());
d615 1
a615 1
                CTag tag11(ET_FEATURES,(uint32)(theApp.clientcredits->CryptoAvailable() ? 3 : 0));
d623 1
a623 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d801 1
a801 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d816 1
a816 1
	md4cpy(hash,theApp.glob_prefs->GetUserHash());
d818 1
a818 1
	memcpy_amd(hash,theApp.glob_prefs->GetUserHash(),16);
d826 1
a826 1
	if (GetClientSoft() == SO_MLDONKEY && theApp.glob_prefs->GetMlDonkeyCM())		//Cax2 only if enabled
d845 1
a845 1
	uint32 clientid = theApp.serverconnect->GetClientID();
d848 1
a848 1
	uint16 nPort = theApp.glob_prefs->GetListenPort();  //Maverick
d852 1
a852 1
	CTag* tag = new CTag(CT_NAME,theApp.glob_prefs->GetUserNick().GetBuffer());
d863 3
a865 3
	if (theApp.serverconnect->IsConnected()){
		dwIP = theApp.serverconnect->GetCurrentServer()->GetIP();
		nPort = theApp.serverconnect->GetCurrentServer()->GetPort();
d890 1
a890 1
			CString strList(theApp.glob_prefs->GetCommentFilter().MakeLower());
d920 1
a920 1
	//if (reqfile->HasRating() || reqfile->HasComment()) theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(reqfile);
d926 1
a926 1
    if(!theApp.clientlist->Debug_IsValidClient(this)) { // obaldin: a quick fix for a strange bug
d930 1
a930 1
	ASSERT(theApp.clientlist->Debug_IsValidClient(this));
d932 1
a932 1
		theApp.uploadqueue->RemoveFromUploadQueue(this,ETS_DISCONNECT);
d937 1
a937 1
	ASSERT(theApp.clientlist->Debug_IsValidClient(this));
d976 1
a976 1
		if (!theApp.glob_prefs->GetCMNotLog())
d982 1
a982 1
		theApp.emuledlg->chatwnd.chatselector.ConnectingResult(this,false);
d986 1
a986 1
		ASSERT (theApp.listensocket->IsValidSocket(socket));
d996 1
a996 1
		theApp.friendlist->RefreshFriend(m_Friend);
d1007 1
a1007 1
	if (theApp.listensocket->TooManySockets() && !bIgnoreMaxCon && !(socket && socket->IsConnected())){
d1011 1
a1011 1
	if ( theApp.ipfilter->IsFiltered(m_nUserID)) 
d1013 1
a1013 1
		AddDebugLogLine(false,_T("%s: Filtered (don't connect): %s %s"), __FUNCTION__, GetFullIP(),theApp.ipfilter->GetLastHit());
d1017 1
a1017 1
		theApp.stat_filteredclients++;
d1020 1
a1020 1
	if ((theApp.serverconnect->GetClientID() < 16777216) && HasLowID()){
d1036 1
a1036 1
		socket = new CClientReqSocket(theApp.glob_prefs,this);
d1044 1
a1044 1
		socket = new CClientReqSocket(theApp.glob_prefs,this);
d1065 1
a1065 1
		if (theApp.serverconnect->IsLocalServer(m_dwServerIP,m_nServerPort)){
d1072 2
a1073 2
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
			theApp.serverconnect->SendPacket(packet);
d1079 1
a1079 1
				theApp.downloadqueue->RemoveSource(this);
d1113 1
a1113 1
		theApp.emuledlg->chatwnd.chatselector.ConnectingResult(this,true);
d1131 1
a1131 1
			if (theApp.uploadqueue->IsDownloading(this))
d1135 1
a1135 1
				theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d1144 1
a1144 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d1242 1
a1242 1
		theApp.searchlist->ProcessSearchanswer(pachPacket,nSize,this,pszDirectory,bFirstDir);
d1254 1
a1254 1
	CKnownFile* file = theApp.sharedfiles->GetFileByID(this->reqfileid);
d1290 1
a1290 1
	CKnownFile* file = theApp.sharedfiles->GetFileByID(this->reqfileid);
d1315 1
a1315 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Sending public key to '%s'", __FUNCTION__, GetUserName()));
d1321 1
a1321 1
	if (!theApp.clientcredits->CryptoAvailable())
d1324 4
a1327 4
    Packet* packet = new Packet(OP_PUBLICKEY,theApp.clientcredits->GetPubKeyLen() + 1,OP_EMULEPROT);
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
	memcpy(packet->pBuffer+1,theApp.clientcredits->GetPublicKey(), theApp.clientcredits->GetPubKeyLen());
	packet->pBuffer[0] = theApp.clientcredits->GetPubKeyLen();
d1341 1
a1341 1
	if (!theApp.clientcredits->CryptoAvailable())
d1345 1
a1345 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Sending signature key to '%s'", __FUNCTION__, GetUserName()));
d1348 1
a1348 1
		theApp.emuledlg->AddDebugLogLine(false, "%s: Want to send signature but challenge value is invalid ('%s')", __FUNCTION__, GetUserName());
d1363 1
a1363 1
		if (theApp.serverconnect->GetClientID() == 0 || theApp.serverconnect->IsLowID()){
d1369 1
a1369 1
			ChallengeIP = theApp.serverconnect->GetClientID();
d1376 1
a1376 1
	uint8 siglen = theApp.clientcredits->CreateSignature(credits, achBuffer,  250, ChallengeIP, byChaIPKind );
d1382 1
a1382 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d1394 1
a1394 1
//	theApp.clientlist->AddTrackClient(this);
d1396 1
a1396 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Receiving public key from '%s'", __FUNCTION__, GetUserName()));
d1402 1
a1402 1
	if (!theApp.clientcredits->CryptoAvailable())
d1412 1
a1412 1
			theApp.emuledlg->AddDebugLogLine(false, "%s: Invalid State error: IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket",__FUNCTION__);
d1416 1
a1416 1
		theApp.emuledlg->AddDebugLogLine(false, "%s: Failed to use new received public key",__FUNCTION__);
d1421 1
a1421 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Receiving signature from '%s'", __FUNCTION__, GetUserName()));
d1439 1
a1439 1
	if (!theApp.clientcredits->CryptoAvailable())
d1444 1
a1444 1
		theApp.emuledlg->AddDebugLogLine(false, "%s: Received multiple signatures from one client",__FUNCTION__);
d1449 1
a1449 1
		theApp.emuledlg->AddDebugLogLine(false, "%s: Received signature for client without public key",__FUNCTION__);
d1454 1
a1454 1
		theApp.emuledlg->AddDebugLogLine(false, "%s: Received signature for client with invalid challenge value ('%s')", __FUNCTION__, GetUserName());
d1458 1
a1458 1
	if (theApp.clientcredits->VerifyIdent(credits, pachPacket+1, pachPacket[0], GetIP(), byChaIPKind ) ){
d1460 1
a1460 1
		//theApp.emuledlg->AddDebugLogLine(false, "'%s' has passed the secure identification, V2 State: %i", GetUserName(), byChaIPKind);
d1463 1
a1463 1
		theApp.emuledlg->AddDebugLogLine(false, "%s: '%s' has failed the secure identification, V2 State: %i", __FUNCTION__, GetUserName(), byChaIPKind);
d1471 1
a1471 1
		if (theApp.clientcredits->CryptoAvailable()){
d1478 1
a1478 1
			DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Not sending SecIdentState Packet, because State is Zero",__FUNCTION__));
d1484 1
a1484 1
		DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Sending SecIdentState Packet, state: %i (to '%s')", __FUNCTION__, nValue, GetUserName() ));
d1486 1
a1486 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d1518 1
a1518 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "%s: Received SecIdentState Packet, state: %i", __FUNCTION__, pachPacket[0]));
@


1.135
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d206 1
a206 1
		AddDebugLogLine(false,_T("Deleting banned client '%s' by releasing object"), GetUserName());
d309 1
a309 1
					AddDebugLogLine(false,_T("Invalid user name received! Userhash:%s, IP:%s, Userport:%d"),buffer,m_szFullUserIP,m_nUserPort);
d348 2
a349 2
				AddDebugLogLine(false,_T("Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
					temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_nClientVersion,
d384 1
a384 1
        AddDebugLogLine(false,_T("User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d."),m_pszUsername,m_nClientVersion, ip_addr,m_nUserPort );
d462 1
a462 1
		AddDebugLogLine(false, _T("Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), m_pszUsername,
d478 1
a478 1
		AddDebugLogLine(false, _T("Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!"), m_pszUsername,
d490 1
a490 1
		theApp.emuledlg->AddDebugLogLine(false, _T("Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!"), m_pszUsername,
d760 2
a761 2
				AddDebugLogLine(false,_T("Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
					temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_pszUsername,GetClientNameAndVersionString(this) );
d898 1
a898 1
						AddDebugLogLine(false, _T("Description for file '%s' filtered: %s"), m_strClientFilename, m_strComment);
d909 1
a909 1
				AddDebugLogLine(false, _T("Description for file '%s' received: %s"), m_strClientFilename, m_strComment);
d914 1
a914 1
			AddDebugLogLine(false, _T("Rating for file '%s' received: %i"), m_strClientFilename, m_iRate);
d927 1
a927 1
        AddDebugLogLine(false, _T("Invalid client in CUpDownClient::Disconnected"));
d977 1
a977 1
			AddDebugLogLine(false,_T("Keeping banned client '%s' after disconnect"), GetUserName());
d992 1
a992 1
		AddDebugLogLine(false,IDS_SHAREDFILES_FAILED,GetUserName());
d1013 1
a1013 1
		AddDebugLogLine(false,_T("Filtered (don't connect): %s %s"), GetFullIP(),theApp.ipfilter->GetLastHit());
d1210 1
a1210 1
						AddDebugLogLine(false,"New Compatable ClientSoft ET_COMPATABLECLIENT = %i client will be listed as an emule ",m_byCompatableClient);
d1230 1
a1230 1
		AddDebugLogLine(true,IDS_SHAREDFILES_REQUEST,GetUserName());
d1315 1
a1315 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "sending public key to '%s'", GetUserName()));
d1345 2
a1346 2
		DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "sending signature key to '%s'", GetUserName()));
	// do we have a challenge value recieved (actually we should if we are in this function)
d1348 1
a1348 1
		theApp.emuledlg->AddDebugLogLine(false, "Want to send signature but challenge value is invalid ('%s')", GetUserName());
d1396 1
a1396 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "recieving public key from '%s'", GetUserName()));
d1412 1
a1412 1
			theApp.emuledlg->AddDebugLogLine(false, "Invalid State error: IS_KEYANDSIGNEEDED in ProcessPublicKeyPacket");
d1416 1
a1416 1
		theApp.emuledlg->AddDebugLogLine(false, "Failed to use new recieved public key");
d1421 1
a1421 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "receiving signature from '%s'", GetUserName()));
d1444 1
a1444 1
		theApp.emuledlg->AddDebugLogLine(false, "recieved multiple signatures from one client");
d1449 1
a1449 1
		theApp.emuledlg->AddDebugLogLine(false, "recieved signature for client without public key");
d1454 1
a1454 1
		theApp.emuledlg->AddDebugLogLine(false, "recieved signature for client with invalid challenge value ('%s')", GetUserName());
d1463 1
a1463 1
		theApp.emuledlg->AddDebugLogLine(false, "'%s' has failed the secure identification, V2 State: %i", GetUserName(), byChaIPKind);
d1478 1
a1478 1
			DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "Not sending SecIdentState Packet, because State is Zero"));
d1484 1
a1484 1
		DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "sending SecIdentState Packet, state: %i (to '%s')", nValue, GetUserName() ));
d1518 1
a1518 1
	DEBUG_ONLY(theApp.emuledlg->AddDebugLogLine(false, "recieved SecIdentState Packet, state: %i", pachPacket[0]));
@


1.134
log
@speed optimization in outgoing filtering
@
text
@d87 2
a88 2
	m_nAvDownDatarate = 0;
	m_nAvUpDatarate = 0;
d91 1
a91 1
	m_TransferedInLastPeriod = 0;
d98 1
a98 1
	m_nTransferedUp = 0;
d101 1
a101 1
	m_nUpDatarate = -1;
d129 2
a130 2
	m_nTransferedDown = 0;
	m_nDownDatarate = 0;
d1260 2
a1261 2
					file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransfered()),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransfered()));
d1298 2
a1299 2
					file->statistic.GetAccepts(), file->statistic.GetRequests(), CastItoXBytes(file->statistic.GetTransfered()),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), CastItoXBytes(file->statistic.GetAllTimeTransfered()));
@


1.133
log
@antiscaning measures & some optimization
@
text
@d1011 9
a1096 11
		if ( theApp.ipfilter->IsFiltered(m_nUserID)) 
		{
			AddDebugLogLine(false,_T("Filtered (don't connect): %s %s"), GetFullIP(),theApp.ipfilter->GetLastHit());
			theApp.downloadqueue->RemoveSource(this);
#ifdef OLD_SOCKETS_ENABLED
			if (socket)
				socket->Safe_Delete();
#endif //OLD_SOCKETS_ENABLED
			theApp.stat_filteredclients++;
			return false;
		}
@


1.132
log
@Update for new sockets
@
text
@d132 1
a288 1
	CString crash = _T("[Invalid user name]"); //Vorlost
d298 1
d310 1
a310 1
					m_pszUsername = crash;
d313 1
a313 1
					m_pszUsername = temptag->GetStringValue();
a569 10
		//eklmn: check at this place is removed. new check in TryToConnect
		/*
		if ( theApp.ipfilter->IsFiltered(sockAddr.sin_addr.S_un.S_addr)) 
		{
			AddDebugLogLine(false,_T("Filtered (HelloPacket): %s %s"), GetFullIP(),theApp.ipfilter->GetLastHit());
			Disconnected();
			theApp.stat_filteredclients++;
			return;
		}
		*/
d671 8
a678 3
	for (uint32 i = 0;i < tagcount; i++){
		CTag* temptag = new CTag(data);
		switch(temptag->GetSpecialTag()){
d701 5
a705 5
                break;
            case ET_MOD_VERSION:                
                m_modVerString = temptag->GetStringValue();
                break;
            case ET_MOD_PROTOCOL:				
d708 4
a711 4
            case ET_MOD_PLUS:
                m_dwDataPlusVers = temptag->GetIntValue();
                break ;
            case ET_MOD_TAROD:
d722 2
a723 2
            case ET_MOD_LSD:
            case ET_MOD_LSD_VERSION:
d725 1
a725 1
            case ET_MOD_OXY:
a754 1
                {                    
d757 8
a764 6
                        CString buffer = temptag->GetStringValue();
						TagToDebugLogLine(_T("Process: Unknown eMule tag"), buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
                    }
					AddDebugLogLine(false,_T("Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)"),
                        temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_pszUsername,GetClientNameAndVersionString(this) );
                }
a765 1
		delete temptag;
a997 5
	{
		//eklmn: since client can be disconnected over TryToConnect() during pocessing of DL queue of the file
		theApp.downloadqueue->RemoveSource(this);
		// if somehow client is also present in UL queue, so remove it
		theApp.uploadqueue->RemoveFromWaitingQueue(this);
a998 1
	}
@


1.131
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d1340 1
d1342 1
d1373 1
d1386 1
d1399 1
d1401 1
d1501 1
d1503 1
@


1.130
log
@updated complete sources (compatibility with future official)
@
text
@d189 6
d504 4
d602 1
a602 1
		uint32 tagcount = 10;
d624 2
d754 3
d785 3
d1325 211
@


1.129
log
@added OP_ASKSHAREDDIRS protocol
@
text
@d608 1
a608 1
		CTag tag8(ET_EXTENDEDREQUEST,1);
d770 5
@


1.128
log
@*** empty log message ***
@
text
@d108 1
a108 1
	m_bFileListRequested = false;
d182 1
d361 1
a361 1
			//m_fSharedDirectories = 1;  These arent supported in Plus YET
d651 8
d972 1
a972 1
	if (m_bFileListRequested){
d974 1
a974 1
		m_bFileListRequested = false;
d1131 2
a1132 2
	if (m_bFileListRequested){
		Packet* packet = new Packet(OP_ASKSHAREDFILES,0);
d1218 5
a1222 3
	AddDebugLogLine(true,IDS_SHAREDFILES_REQUEST,GetUserName());
	m_bFileListRequested = true;
	TryToConnect(true);
d1226 1
a1226 1
void CUpDownClient::ProcessSharedFileList(char* pachPacket, uint32 nSize){
d1228 4
a1231 3
	if (m_bFileListRequested){
		m_bFileListRequested = false;
		theApp.searchlist->ProcessSearchanswer(pachPacket,nSize,this);
@


1.127
log
@extended Upload Session statistic
@
text
@d892 1
a892 1
	//if (reqfile->HasRating() || reqfile->HasComment()) theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(reqfile);
@


1.126
log
@Just added one more leecher mod to the detection
@
text
@d904 1
a904 1
		theApp.uploadqueue->RemoveFromUploadQueue(this);
d973 2
d1111 2
a1112 1
			if (theApp.uploadqueue->IsDownloading(this)){
d1119 1
@


1.125
log
@Preparing for new sockets
@
text
@d507 2
a508 2
		m_pszUsername == "unix user" 

@


1.124
log
@added past comments
@
text
@d446 1
d457 1
d1068 1
d1071 1
@


1.123
log
@new statistic (khaos based)
@
text
@d886 2
@


1.122
log
@updated complete sources (0.06b: display range of values)
@
text
@d85 1
d501 1
d505 1
a505 1
		m_pszUsername == "unix user" ||
d508 31
a538 17
		m_pszUsername.Find("Odin") == 0 ||		
		m_pszUsername.Find("$GAM3R$") == 0 ||
		m_pszUsername.Find("G@@m3rs Edit") == 0 ||
		m_pszUsername.Find("G@@m3rs Edit") == 0 ||
		m_pszUsername.Find("[RAMMSTEIN") == 0 ||
		m_pszUsername.Find("[toXic]") == 0 ||
		m_pszUsername.Find("Leecha") == 0 ||
		m_pszUsername.Find("leecha") == 0 ||
		m_pszUsername.Find("eDevil") == 0 ||
		m_pszUsername.Find("darkmule") == 0 ||
		m_pszUsername.Find("DarkMule") == 0 ||
		m_pszUsername.Find("eVortex") == 0 ||
		m_pszUsername.Find("|eVorte|X|") == 0 ||
		m_modVerString.Find("eVortex") != -1 ||
		m_pszUsername.Find("MISON") == 0 ||
		m_pszUsername.Find("Mison") == 0 ||
		m_modVerString.Find("Mison") != -1))
d540 2
a706 8
				break;
			case ET_L2HAC:	// START enkeyDEV(th1) -L2HAC-
				m_L2HAC_time = temptag->GetIntValue();
				break;		// END enkeyDEV(th1) -L2HAC-
			case ET_INCOMPLETEPARTS: // enkeyDEV(th1) -ICS-
			   	break;
			case ET_FEATURES:	// secure credits (official 0.29b)
				break;
d725 7
d734 2
a735 1
                    if(!temptag->GetStringValue().IsEmpty()) {
d965 4
a968 1
	if (bDelete){
d971 2
@


1.121
log
@remove a socker for filtered clients
@
text
@d176 1
@


1.120
log
@Fiter-Check in SendHelloPacket is completly moved to TryToConnect()
@
text
@d1039 3
@


1.119
log
@prevent connection to filtered clients
@
text
@d537 2
d546 1
a546 1
		
a1035 3
#ifdef OLD_SOCKETS_ENABLED
		socket->Connect(GetFullIP(),GetUserPort());
#endif //OLD_SOCKETS_ENABLED
d1042 4
a1045 4
		else
		{
			SendHelloPacket();
		}
@


1.118
log
@new unknown eMule tags
0x12, 0x13, 0x14, 0x17 -> leecher
0x64 -> LSD & Athlazan
@
text
@d539 1
a539 1
			AddDebugLogLine(false,_T("Filtered: %s %s"), GetFullIP(),theApp.ipfilter->GetLastHit());
d1037 10
a1046 1
		SendHelloPacket();
@


1.117
log
@small speed optimization in ProcessHelloTypePacket()
@
text
@d694 4
d702 1
@


1.116
log
@severe error fixed in TryToConnect (returning false wrongly!) //SyruS (0.29c)
maybe the source of our downloadbug...
@
text
@d282 4
a285 2
	for (uint32 i = 0;i < tagcount; i++){
		CTag* temptag = new CTag(data);
d309 3
a311 2
				if ( temptag->GetIntValue() != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID ) {
                    wrong_port = true;
d331 11
a341 10
            default:
                {                    
                    if(!temptag->GetStringValue().IsEmpty()) {
                        CString buffer = temptag->GetStringValue();
						TagToDebugLogLine(_T("Hello: Unknown eDonkey tag"), buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
                    }
                    AddDebugLogLine(false,_T("Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s"),
                        temptag->GetSpecialTag(), temptag->GetIntValue(), temptag->GetStringValue(), m_nClientVersion,
                        m_pszUsername);
                }
d344 1
@


1.115
log
@Removed UNICODE support from IsStolenName() (seems to bring some problems).
@
text
@d917 1
a917 1
	if (GetChatState()){
d956 1
a957 1
		return false; // SLUGFILLER: SafeDisconnect
@


1.114
log
@first steps of keeping banned clients alive so that re-banning isn't so often
@
text
@d494 1
a494 1
	if( !m_pszUsername.IsEmpty() && (
d496 2
a497 2
		m_pszUsername == _T("pbwll") ||
		m_pszUsername == _T("unix user") ||
d500 17
a516 17
		m_pszUsername.Find(_T("Odin")) == 0 ||		
		m_pszUsername.Find(_T("$GAM3R$")) == 0 ||
		m_pszUsername.Find(_T("G@@m3rs Edit")) == 0 ||
		m_pszUsername.Find(_T("G@@m3rs Edit")) == 0 ||
		m_pszUsername.Find(_T("[RAMMSTEIN")) == 0 ||
		m_pszUsername.Find(_T("[toXic]")) == 0 ||
		m_pszUsername.Find(_T("Leecha")) == 0 ||
		m_pszUsername.Find(_T("leecha")) == 0 ||
		m_pszUsername.Find(_T("eDevil")) == 0 ||
		m_pszUsername.Find(_T("darkmule")) == 0 ||
		m_pszUsername.Find(_T("DarkMule")) == 0 ||
		m_pszUsername.Find(_T("eVortex")) == 0 ||
		m_pszUsername.Find(_T("|eVorte|X|")) == 0 ||
		m_modVerString.Find(_T("eVortex")) != -1 ||
		m_pszUsername.Find(_T("MISON")) == 0 ||
		m_pszUsername.Find(_T("Mison")) == 0 ||
		m_modVerString.Find(_T("Mison")) != -1))
@


1.113
log
@Removed old Stored Sources from all code.
@
text
@d192 6
d493 1
d518 1
d629 1
a629 1
	uint32 tagcount;
d908 9
a916 2
	

@


1.112
log
@1) new DL client speed measurement system
2) memleak in Send* functions
@
text
@d64 1
a64 6
// Modified by Tarod (LS tweak)
CUpDownClient::CUpDownClient(uint16 in_port, uint32 in_userid,uint32 in_serverip, uint16 in_serverport,CPartFile* in_reqfile
#ifdef OLD_SLS_ENABLED
, CSourceEntry* source_entry
#endif //OLD_SLS_ENABLED
){
a69 4
#ifdef OLD_SLS_ENABLED
	m_sourceEntry = source_entry ; // Added by Tarod (LS tweak)
	if (m_sourceEntry) m_sourceEntry->AddRef(); // HACK by Md5Chap 2002-11-24 (Used reference)
#endif //OLD_SLS_ENABLED
a140 3
#ifdef OLD_SLS_ENABLED
	m_sourceEntry = (CSourceEntry*)NULL; // Added by Tarod (LS tweak)
#endif //OLD_SLS_ENABLED
a241 9
#ifdef OLD_SLS_ENABLED
	// HACK by Md5Chap 2002-11-26 (Increment failedconnections here,
	// because of m_cfailed>0 we can be sure that we could not connect
	// to the other client. We can also check to have only this reference left, and
	// then adding a failed connection. This prevents a heavy referenced source to
	// be outdated at once.)
	if (m_sourceEntry && m_cFailed>0 && m_sourceEntry->GetRef()<=2 ) m_sourceEntry->IncrementFailedConnections();
	if (m_sourceEntry) m_sourceEntry->Release(true); // HACK by Md5Chap 2002-11-24 (autodelete, because it could be last one)
#endif //OLD_SLS_ENABLED
a1022 8
	// Added by Tarod (to add LS sources)
#ifdef OLD_SLS_ENABLED
	if (m_sourceEntry != (CSourceEntry*)NULL) {
		m_sourceEntry->ResetFailedConnections() ;
		m_sourceEntry->ResetLastSeenTime(); // HACK by Md5Chap 2002-11-26 (moved here,
											// because aging will be better here.)
	}
#endif //OLD_SLS_ENABLED
@


1.111
log
@SafeConnect from SlugFiller
@
text
@d97 3
d144 1
a144 1
    m_dwDataPlusVers = 0;
d164 1
a164 1
    m_LastGotULData = 0;
d188 4
a191 4
    m_lastRefreshedULDisplay = ::GetTickCount();
    m_lastCalculatedDownloadRate = ::GetTickCount();
    score_base_cached = false; 
    community_cached = false; 
d249 1
a249 1
	m_AverageDDR_list.clear();
d535 1
d545 3
a547 2
		if ( theApp.ipfilter->IsFiltered(sockAddr.sin_addr.S_un.S_addr)) {
            AddDebugLogLine(false,_T("Filtered: %s %s"), GetFullIP(),theApp.ipfilter->GetLastHit());
d552 7
a558 11
	}
#endif //OLD_SOCKETS_ENABLED

	CMemFile data;
	uint8 hashsize = 16;
	data.Write(&hashsize,1);
	SendHelloTypePacket(data);
	Packet* packet = new Packet(&data);
	packet->opcode = OP_HELLO;
#ifdef OLD_SOCKETS_ENABLED
	if (socket){
a567 32
	CMemFile data;
	uint8 version = CURRENT_VERSION_SHORT;
	data.Write(&version,1);
	uint8 protversion = EMULE_PROTOCOL;
	data.Write(&protversion,1);
	uint32 tagcount = 10;
	data.Write(&tagcount,4);
	CTag tag(ET_COMPRESSION,1);
	tag.WriteTagToFile(data);
	CTag tag2(ET_UDPVER,3);	// netwolf: complete sources UDP
	tag2.WriteTagToFile(data);
	CTag tag3(ET_UDPPORT,theApp.glob_prefs->GetUDPPort());
	tag3.WriteTagToFile(data);
	CTag tag4(ET_SOURCEEXCHANGE,1);
	tag4.WriteTagToFile(data);
	CTag tag5(ET_COMMENTS,1);
	tag5.WriteTagToFile(data);
	CTag tag6(ET_MOD_TAROD, 1);						// To check for Tarod/Plus (just curiosity)
	tag6.WriteTagToFile(data);	// It do not harms at all (!)
	CTag tag7(ET_MOD_PLUS, CURRENT_PLUS_VERSION);	// To check for eMulePlus
	tag7.WriteTagToFile(data);	                    // It doesn't do any harm (?)
	CTag tag8(ET_EXTENDEDREQUEST,1);
	tag8.WriteTagToFile(data);
	CTag tag9(ET_MOD_VERSION, _T(PLUS_VERSION_STR));
	tag9.WriteTagToFile(data);	 //More harmless than the other 2! :D
	CTag tag10(ET_L2HAC,FILEREASKTIME);	//<<-- enkeyDEV(th1) -L2HAC-
	tag10.WriteTagToFile(data);			//<<-- enkeyDEV(th1) -L2HAC-
	Packet* packet = new Packet(&data,OP_EMULEPROT);	
	if (!bAnswer)
		packet->opcode = OP_EMULEINFO;
	else
		packet->opcode = OP_EMULEINFOANSWER;
d569 35
a603 1
	if (socket){
a606 1
	else
a607 3
	{						//	
		delete packet;		//	netwolf 04.05.03
	}						//
a745 4
	CMemFile data;
	SendHelloTypePacket(data);
	Packet* packet = new Packet(&data);	
	packet->opcode = OP_HELLOANSWER;
d747 6
a752 1
	if (socket){
@


1.110
log
@minor change
@
text
@d946 1
a946 1
void CUpDownClient::TryToConnect(bool bIgnoreMaxCon){
d951 1
a951 1
		return;
d963 1
d972 1
a972 1
			return;
d980 1
a980 1
			return;
d985 1
a985 1
		return;
d994 1
a994 1
			return;
d1008 4
a1011 2
		else{
			if (GetUploadState() == US_NONE && (!GetRemoteQueueRank() || m_bReaskPending) ){
d1014 1
a1014 1
				return;
d1016 4
a1019 2
			else{
				if (GetDownloadState() == DS_WAITCALLBACK){
d1028 2
a1029 1
	else{
d1035 2
d1038 1
@


1.109
log
@improved Client identification (MLdonekey & Hybrid)
@
text
@d519 1
a519 1
		m_pszUsername.Find(_T("edevil")) == 0 ||
@


1.108
log
@optimization in "Anti-Leecher"... work with CMap is minimized
@
text
@d1094 2
a1095 1
void CUpDownClient::ReGetClientSoft(){
d1103 50
a1152 30

	// If the client is an old emule
	if (iHashType == SO_OLDEMULE) {m_clientSoft= SO_OLDEMULE;return;}

	// If the client is an Emule compatable client
	if (iHashType == SO_EMULE){
		if( m_byEmuleVersion!=0x99 ){
			CString temp;
			temp.Format( _T("%02X"), m_byEmuleVersion );
			m_nClientVersion = 	_tstoi(temp.GetBuffer())*10;
		}
		switch(m_byCompatableClient) {
			case 0:
				m_clientSoft = SO_EMULE;
				break;
			case 1:
				m_clientSoft = SO_CDONKEY;
				break;
			case 2:
				m_clientSoft = SO_LMULE;
				break;
			case 4:
				m_clientSoft = SO_SHAREAZA;
				break;
			default:
				m_clientSoft= SO_EMULE;
				AddDebugLogLine(false,_T("New Compatable ClientSoft ET_COMPATABLECLIENT = %i client will be listed as an emule "),m_byCompatableClient);
				break;
		}
		return;
a1154 10
	// If the client is an Ml donkey
	if (m_bIsML || iHashType == SO_MLDONKEY) {m_clientSoft= SO_MLDONKEY;return;}



	// Were left with donkeys and Hybrids
	if( m_bIsHybrid )
		m_clientSoft=SO_EDONKEYHYBRID;
	else
		m_clientSoft=SO_EDONKEY;
a1156 1

@


1.107
log
@major bug in Download
@
text
@d292 2
a293 2
	bool crashed = false; //Vorlost
    bool wrong_port = false; // obaldin
d442 9
d455 3
a457 6
		uint32 dummy;
		if(offensecounter.Lookup(id, dummy))
			offensecounter[id]++;
		else
			offensecounter[id]=1;
 
d459 1
a459 1
			(uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), m_nUserPort, offensecounter[id], offensecounter[0], offensecounter.GetSize()-1);
d467 1
a467 1
	if(hashbase.Lookup(id, lasthash) && lasthash!=thishash)
d470 2
a471 7
		uint32 dummy;
		if(offensecounter.Lookup(id, dummy))
			offensecounter[id]++;
		else
			offensecounter[id]=1;
 
		offensecounter[0]++;
d474 1
a474 1
			(uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), m_nUserPort, offensecounter[id], offensecounter[0], offensecounter.GetSize()-1);
d482 2
a483 7
		uint32 dummy;
		if(offensecounter.Lookup(id, dummy))
			offensecounter[id]++;
		else
			offensecounter[id]=1;
 
		offensecounter[0]++;
d486 1
a486 1
						(uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), m_nUserPort, offensecounter[id], offensecounter[0]);
d489 1
a489 2
	uint32 dummy;
	if(offensecounter.Lookup(id, dummy) && dummy>=3 && theApp.glob_prefs->GetMlDonkeyCM())
d493 5
d499 1
@


1.106
log
@unicode cleanup
@
text
@a190 2
    lastDownPart = 0xffff;

d882 1
a882 1
	if (GetDownloadState() == DS_DOWNLOADING){
a883 2
        lastDownPart = 0xffff;
	}
@


1.105
log
@added client tag 0x5A (Bowlfish) and minor debuglog cleanup ('invalid user name received' is one line now)
@
text
@d83 1
a83 1
		m_szFullUserIP.Format("%i.%i.%i.%i",(uint8)m_nUserID,(uint8)(m_nUserID>>8),(uint8)(m_nUserID>>16),(uint8)(m_nUserID>>24));
d311 1
a311 1
					AddDebugLogLine(false,"Invalid user name received! Userhash:%s, IP:%s, Userport:%d",buffer,m_szFullUserIP,m_nUserPort);
d346 1
a346 1
						TagToDebugLogLine("Hello: Unknown eDonkey tag", buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
d348 1
a348 1
                    AddDebugLogLine(false,"Hello: Unknown eDonkey tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s",
d383 1
a383 1
        AddDebugLogLine(false,_T("User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d."),m_pszUsername,m_nClientVersion,(const char*)ip_addr,m_nUserPort );
d407 1
a407 1
		CServer* addsrv = new CServer(m_nServerPort, inet_ntoa(addhost));
d446 1
a446 1
		Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!", GetResString(IDS_BAN_HASHIMP));
d454 1
a454 1
		AddDebugLogLine(false, "Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!", m_pszUsername,
d474 1
a474 1
		AddDebugLogLine(false, "Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!", m_pszUsername,
d491 1
a491 1
		theApp.emuledlg->AddDebugLogLine(false, "Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!", m_pszUsername,
d498 1
a498 1
		Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!", GetResString(IDS_BAN_HASHSTEAL));
d508 2
a509 2
		m_pszUsername == "pbwll" ||
		m_pszUsername == "unix user" ||
d512 17
a528 17
		m_pszUsername.Find("Odin") == 0 ||		
		m_pszUsername.Find("$GAM3R$") == 0 ||
		m_pszUsername.Find("G@@m3rs Edit") == 0 ||
		m_pszUsername.Find("G@@m3rs Edit") == 0 ||
		m_pszUsername.Find("[RAMMSTEIN") == 0 ||
		m_pszUsername.Find("[toXic]") == 0 ||
		m_pszUsername.Find("Leecha") == 0 ||
		m_pszUsername.Find("leecha") == 0 ||
		m_pszUsername.Find("edevil") == 0 ||
		m_pszUsername.Find("darkmule") == 0 ||
		m_pszUsername.Find("DarkMule") == 0 ||
		m_pszUsername.Find("eVortex") == 0 ||
		m_pszUsername.Find("|eVorte|X|") == 0 ||
		m_modVerString.Find("eVortex") != -1 ||
		m_pszUsername.Find("MISON") == 0 ||
		m_pszUsername.Find("Mison") == 0 ||
		m_modVerString.Find("Mison") != -1))
d543 1
a543 1
            AddDebugLogLine(false,"Filtered: %s %s", GetFullIP(),theApp.ipfilter->GetLastHit());
d591 1
a591 1
	CTag tag9(ET_MOD_VERSION, PLUS_VERSION_STR);
d721 1
a721 1
						TagToDebugLogLine("Process: Unknown eMule tag", buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
d723 1
a723 1
					AddDebugLogLine(false,"Process: Unknown eMule tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)",
d848 1
a848 1
				CString resToken(strList.Tokenize("|",curPos));
d851 1
a851 1
						AddDebugLogLine(false, "Description for file '%s' filtered: %s", m_strClientFilename, m_strComment);
d856 1
a856 1
					resToken = strList.Tokenize("|",curPos);
d862 1
a862 1
				AddDebugLogLine(false, "Description for file '%s' received: %s", m_strClientFilename, m_strComment);
d867 1
a867 1
			AddDebugLogLine(false, "Rating for file '%s' received: %i", m_strClientFilename, m_iRate);
d878 1
a878 1
        AddDebugLogLine(false, "Invalid client in CUpDownClient::Disconnected");
d1113 1
a1113 1
			temp.Format( "%02X", m_byEmuleVersion );
d1131 1
a1131 1
				AddDebugLogLine(false,"New Compatable ClientSoft ET_COMPATABLECLIENT = %i client will be listed as an emule ",m_byCompatableClient);
d1169 1
a1169 1
	if(this == NULL) return "";
d1177 1
a1177 1
		sRet += GetResString(IDS_SF_REQUESTED) + CString(file->GetFileName()) + "\n";
d1190 1
a1190 1
	return "";
d1205 1
a1205 1
	if(this == NULL) return "";
d1230 1
a1230 1
	return "";
@


1.104
log
@Removed unknown opcode 0x27 (secure credits tag) from debuglog
@
text
@d311 1
a311 1
					AddDebugLogLine(false,"Invalid user name received! Userhash:%s, Userport:%d",buffer,m_nUserPort);
d401 1
a401 1
	if (crashed) AddDebugLogLine(false,_T("The invalid user name was sent from IP:%s"), m_szFullUserIP);
d684 2
a685 1
            case ET_MOD_TAROD_VERSION:
@


1.103
log
@Added A4AF no icon on Web Server and change Upload tooltips to have KB/MB as needed.
@
text
@d701 2
@


1.102
log
@minor debuglog change ('Invalid user name received' not added to tray)
@
text
@d1177 2
a1178 2
					file->statistic.GetAccepts(), file->statistic.GetRequests(), file->statistic.GetTransfered(),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), file->statistic.GetAllTimeTransfered());
@


1.101
log
@DoubleT: unknown tags addition
@
text
@d311 1
a311 1
					AddDebugLogLine(true,"Incorrect user name received! Userhash:%s, Userport:%d",buffer,m_nUserPort);
@


1.100
log
@DoubleT: added some unknown tags
@
text
@d704 1
a704 1
			case ET_MOD_UNKNOWNx5c:
@


1.99
log
@dont add anti-leecher log to statusbar (test stage is over :))
@
text
@d335 1
d339 1
d346 1
a346 1
						TagToDebugLogLine("Unknown eDonkey tag", buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
d348 1
a348 1
                    AddDebugLogLine(false,"Hello: Unknown tag: 0x%x, Intvalue: %d Stringvalue: %s, (client version:%d) %s",
d706 2
d712 1
d718 1
a718 1
						TagToDebugLogLine("Unknown eMule tag", buffer, buffer.GetLength(), temptag->GetSpecialTag());	// DbT:Logging
d720 1
a720 1
					AddDebugLogLine(false,"Process: unknown tag: 0x%x, Intvalue: %d Stringvalue: %s User: %s(%s)",
@


1.98
log
@Removed Horde tags from DebugLog. Grrr.
@
text
@d452 1
a452 1
		AddDebugLogLine(true, "Client '%s' uses my hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!", m_pszUsername,
d472 1
a472 1
		AddDebugLogLine(true, "Client '%s' changed hash, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total/%i clients)!", m_pszUsername,
d489 1
a489 1
		theApp.emuledlg->AddDebugLogLine(true, "Client '%s' is known for cheating, ip %i.%i.%i.%i:%i, suspicious actions: %i (%i in total)!", m_pszUsername,
@


1.97
log
@Removed Frindship Client DebugLogLine.
@
text
@d326 1
d399 1
a399 1
	if (crashed) AddDebugLogLine(false,_T("The invalid user name was sent from IP:%s)"), m_szFullUserIP);
@


1.96
log
@char * to CString conversion
@
text
@a325 2
				AddDebugLogLine(false,"Hello: client %s identifies itself as a Friendsharing client", m_pszUsername);
				break;
@


1.95
log
@char * to CString conversion
@
text
@d826 1
a826 1
	if (nSize>2){
d830 1
a830 2
		data.Read(&length,sizeof(length));
        if(!reqfile) return;
d832 3
a834 5
		if (length>0){
			char* desc=new char[length+1];
			memset(desc,0,length+1);
			data.Read(desc,length);
			m_strComment.Format("%s",desc);
d844 1
a844 1
						AddDebugLogLine(false, "Description for file '%s' filtered: %s", m_strClientFilename, desc);
d855 2
a856 3
				AddDebugLogLine(false, "Description for file '%s' received: %s", m_strClientFilename, desc);
			}
			delete desc;
@


1.94
log
@unicode cleanup
@
text
@d293 1
a293 1
	char* crash ="[Invalid user name]"; //Vorlost
d298 1
a298 1
		switch(temptag->specialtag)
d300 2
a301 3
			case CT_NAME:
				m_pszUsername = "";
				if (!temptag->stringvalue)
d312 1
d314 2
a315 1
				m_pszUsername = CString(temptag->stringvalue ? temptag->stringvalue : crash);
d318 1
a318 1
				m_nClientVersion = temptag->intvalue;
d321 1
a321 1
				if ( temptag->intvalue != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID ) {
d342 4
a345 5
                {
                    CString buffer;
                    if(temptag->stringvalue) {
                        buffer = temptag->stringvalue;
						TagToDebugLogLine("Unknown eDonkey tag", buffer, buffer.GetLength(), temptag->specialtag);	// DbT:Logging
d348 1
a348 1
                        temptag->specialtag, temptag->intvalue, buffer, m_nClientVersion,
d647 1
a647 1
		switch(temptag->specialtag){
d649 1
a649 1
				m_byDataCompVer = temptag->intvalue;
d652 1
a652 1
				m_nUDPPort = temptag->intvalue;
d655 1
a655 1
				m_byUDPVer = temptag->intvalue;
d658 1
a658 1
				m_bySourceExchangeVer = temptag->intvalue;
d661 1
a661 1
				m_byAcceptCommentVer = temptag->intvalue;
d664 1
a664 1
				m_byExtendedRequestsVer = temptag->intvalue;
d667 1
a667 1
				m_byCompatableClient = temptag->intvalue;
d671 2
a672 3
            case ET_MOD_VERSION:
                if(temptag->stringvalue)
                    m_modVerString = temptag->stringvalue;
d674 2
a675 3
            case ET_MOD_PROTOCOL:
				if(temptag->stringvalue)
					m_modExtendedString = temptag->stringvalue;
d678 1
a678 1
                m_dwDataPlusVers = temptag->intvalue;
d681 1
a681 1
				m_byDataTarodVer = temptag->intvalue;
d696 1
a696 1
				m_L2HAC_time = temptag->intvalue;
d711 4
a714 5
                {
                    CString buffer;
                    if(temptag->stringvalue) {
                        buffer = temptag->stringvalue;
						TagToDebugLogLine("Unknown eMule tag", buffer, buffer.GetLength(), temptag->specialtag);	// DbT:Logging
d717 1
a717 1
                        temptag->specialtag, temptag->intvalue, buffer, m_pszUsername,GetClientNameAndVersionString(this) );
@


1.93
log
@Updates...
@
text
@d382 1
a382 1
        AddDebugLogLine(false,"User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,(const char*)ip_addr,m_nUserPort );
d400 1
a400 1
	if (crashed) AddDebugLogLine(false,"The invalid user name was sent from IP:%s)", m_szFullUserIP);
d427 1
a427 1
		m_Friend->m_strName.Format("%s", m_pszUsername);
@


1.92
log
@Updated Banning messages.
@
text
@d495 1
a495 1
	if(offensecounter.Lookup(id, dummy) && dummy>=2 && theApp.glob_prefs->GetMlDonkeyCM())
@


1.91
log
@xrmb countermeasures now use the option in preferences and some minor changes.
@
text
@d445 1
a445 1
		Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!");
d497 1
a497 1
		Ban("AUTOMATED MESSAGE: You're being banned because your client is leeching!");
@


1.90
log
@minor changes (use md4... instead of mem...)
@
text
@d422 1
a422 1
	if ( (m_Friend = theApp.friendlist->LinkFriend(key, m_dwUserIP, m_nUserPort) ) != NULL){
d443 1
a443 1
	if(theApp.serverconnect->GetClientID()!=m_nUserID && md4cmp(m_achUserHash, theApp.glob_prefs->GetUserHash())==0)
d479 1
a479 1
	if( IsStolenName())
d495 1
a495 1
	if(offensecounter.Lookup(id, dummy) && dummy>=3)
a501 1

@


1.89
log
@small typo
@
text
@d164 1
a164 1
	memset( m_achUserHash, 0, 16);
d189 1
a189 1
	memset(reqfileid, 0, 16);
d307 1
a307 1
					memcpy(crashash,m_achUserHash,16);
d443 1
a443 1
	if(theApp.serverconnect->GetClientID()!=m_nUserID && memcmp(m_achUserHash, theApp.glob_prefs->GetUserHash(), 16)==0)
d766 1
a766 1
	memcpy(hash,theApp.glob_prefs->GetUserHash(),16);
@


1.88
log
@small convertion to CString methods
@
text
@d525 1
a525 1
		m_modVerString.Find("eVortex") != 1 ||
@


1.87
log
@Updated banning message
@
text
@d479 1
a479 23
	if( m_pszUsername && (
	//--- equals ---
	strcmp(m_pszUsername, "pbwll")==0 ||
	strcmp(m_pszUsername, "unix user")==0 ||

	//--- begins with ---
	strstr(m_pszUsername,"Odin")==m_pszUsername ||
	strstr(m_pszUsername,"$GAM3R$")==m_pszUsername ||
	strstr(m_pszUsername,"G@@m3rs Edit")==m_pszUsername ||
	strstr(m_pszUsername,"G@@m3rs Edit")==m_pszUsername ||
	strstr(m_pszUsername,"[RAMMSTEIN")==m_pszUsername ||
	strstr(m_pszUsername,"[toXic]")==m_pszUsername ||
	strstr(m_pszUsername,"Leecha")==m_pszUsername ||
	strstr(m_pszUsername,"leecha")==m_pszUsername ||
	strstr(m_pszUsername,"edevil")==m_pszUsername ||
	strstr(m_pszUsername,"darkmule")==m_pszUsername ||
	strstr(m_pszUsername,"DarkMule")==m_pszUsername) ||
	strstr(m_pszUsername,"eVortex")==m_pszUsername ||
	strstr(m_pszUsername,"|eVorte|X|")==m_pszUsername ||
	strstr(m_modVerString,"eVortex") ||
	strstr(m_pszUsername,"MISON")==m_pszUsername ||
	strstr(m_pszUsername,"Mison")==m_pszUsername ||
	strstr(m_modVerString,"Mison"))
d501 30
@


1.86
log
@Added countermeasures for unfair clients and some forum bugfixing
@
text
@d445 1
a445 1
		Ban();
d519 1
a519 1
		Ban();
@


1.85
log
@Removed some Debug logs.
@
text
@d31 4
d440 82
@


1.84
log
@unicode cleanup
@
text
@d323 13
d607 12
@


1.83
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d996 1
a996 1
			m_nClientVersion = 	atoi(temp.GetBuffer())*10;
@


1.82
log
@Preparing for new sockets
@
text
@d23 1
d301 6
a306 1
					uchar crashash[16]; memcpy(crashash,m_achUserHash,16);
d646 1
d648 3
d662 1
d666 5
d884 1
d886 3
@


1.81
log
@Purity's webserver changes. Mostly.
@
text
@d354 1
a357 1
#ifdef OLD_SOCKETS_ENABLED
d360 1
a361 1
	}
d492 1
d494 1
a494 1
	else{					//	
d659 1
d662 1
d677 1
d682 3
a684 1
	else{
a821 1
#endif //OLD_SOCKETS_ENABLED
d833 1
d865 1
d885 1
@


1.80
log
@FEATURE: data logging of unknown tags and packets [DoubleT]
@
text
@d34 1
d40 1
d65 1
d67 1
d168 1
d177 1
d204 1
d209 1
d244 1
d246 3
a253 1
#ifdef OLD_SLS_ENABLED
d357 1
d360 1
d366 1
d368 1
d423 1
d436 1
d444 1
d449 1
d487 1
d492 1
d623 1
d628 1
d790 1
d796 1
d811 1
d816 1
d829 1
d849 1
d881 1
d883 1
d924 1
d926 1
d932 1
d934 1
@


1.79
log
@CHANGE: code cleanup (m_modVerString & m_modExtendedString coverting to CString) [DoubleT]
@
text
@a308 1
					
d310 2
a311 1
                        buffer = temptag->stringvalue;                        
d570 2
a571 1
                        buffer = temptag->stringvalue;                        
@


1.78
log
@converted to new logger methods
@
text
@d115 2
a116 2
	m_modVerString[0]=0;
//	m_modExtendedString[0]=0; // DbT: ET_MOD_PROTOCOL
d538 2
a539 5
                m_modVerString[0] = 0;
                if(temptag->stringvalue) {
                    strncpy(m_modVerString,temptag->stringvalue,40);
                    m_modVerString[40] = 0;
                }
d542 2
a543 1
				// m_modExtendedString = nstrdup(temptag->stringvalue);
@


1.77
log
@code cleanup
@
text
@d774 1
a774 1
		AddDebugLogLine(false,GetResString(IDS_SHAREDFILES_FAILED),GetUserName());
d972 1
a972 1
	AddDebugLogLine(true,GetResString(IDS_SHAREDFILES_REQUEST),GetUserName());
@


1.76
log
@code cleanup
@
text
@d421 1
a421 1
	CMemFile* data = new CMemFile();
d423 1
a423 1
	data->Write(&hashsize,1);
d425 1
a425 2
	Packet* packet = new Packet(data);
	delete data;
d436 1
a436 1
	CMemFile* data = new CMemFile();
d438 1
a438 1
	data->Write(&version,1);
d440 1
a440 1
	data->Write(&protversion,1);
d442 1
a442 1
	data->Write(&tagcount,4);
d463 1
a463 2
	Packet* packet = new Packet(data,OP_EMULEPROT);
	delete data;
d599 1
a599 1
	CMemFile* data = new CMemFile();
d601 1
a601 2
	Packet* packet = new Packet(data);
	delete data;
d610 1
a610 1
void CUpDownClient::SendHelloTypePacket(CMemFile* data){
d634 1
a634 1
	data->Write(hash,16);
d637 1
a637 1
	data->Write(&clientid,4);
d639 1
a639 1
	data->Write(&nPort,2);
d641 1
a641 1
	data->Write(&tagcount,4);
d660 2
a661 2
	data->Write(&dwIP,4);
	data->Write(&nPort,2);
@


1.75
log
@removed Tag_Struct usage from sources
@
text
@d281 1
a281 1
		CTag* temptag = new CTag(&data);
d514 1
a514 1
		CTag* temptag = new CTag(&data);
@


1.74
log
@changes reverted
@
text
@d282 1
a282 1
		switch(temptag->tag->specialtag)
d286 1
a286 1
				if (!temptag->tag->stringvalue)
d293 1
a293 1
				m_pszUsername = CString(temptag->tag->stringvalue ? temptag->tag->stringvalue : crash);
d296 1
a296 1
				m_nClientVersion = temptag->tag->intvalue;
d299 1
a299 1
				if ( temptag->tag->intvalue != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID ) {
d310 2
a311 2
                    if(temptag->tag->stringvalue) {
                        buffer = temptag->tag->stringvalue;                        
d314 1
a314 1
                        temptag->tag->specialtag, temptag->tag->intvalue, buffer, m_nClientVersion,
d515 1
a515 1
		switch(temptag->tag->specialtag){
d517 1
a517 1
				m_byDataCompVer = temptag->tag->intvalue;
d520 1
a520 1
				m_nUDPPort = temptag->tag->intvalue;
d523 1
a523 1
				m_byUDPVer = temptag->tag->intvalue;
d526 1
a526 1
				m_bySourceExchangeVer = temptag->tag->intvalue;
d529 1
a529 1
				m_byAcceptCommentVer = temptag->tag->intvalue;
d532 1
a532 1
				m_byExtendedRequestsVer = temptag->tag->intvalue;
d535 1
a535 1
				m_byCompatableClient = temptag->tag->intvalue;
d541 2
a542 2
                if(temptag->tag->stringvalue) {
                    strncpy(m_modVerString,temptag->tag->stringvalue,40);
d550 1
a550 1
                m_dwDataPlusVers = temptag->tag->intvalue;
d553 1
a553 1
				m_byDataTarodVer = temptag->tag->intvalue;
d568 1
a568 1
				m_L2HAC_time = temptag->tag->intvalue;
d573 2
a574 2
                    if(temptag->tag->stringvalue) {
                        buffer = temptag->tag->stringvalue;                        
d577 1
a577 1
                        temptag->tag->specialtag, temptag->tag->intvalue, buffer, m_pszUsername,GetClientNameAndVersionString(this) );
@


1.73
log
@DoubleT: tags supplemented and sorted
@
text
@d282 1
a282 1
		switch(temptag->specialtag)
d286 1
a286 1
				if (!temptag->stringvalue)
d293 1
a293 1
				m_pszUsername = CString(temptag->stringvalue ? temptag->stringvalue : crash);
d296 1
a296 1
				m_nClientVersion = temptag->intvalue;
d299 1
a299 1
				if ( temptag->intvalue != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID ) {
d310 2
a311 2
                    if(temptag->stringvalue) {
                        buffer = temptag->stringvalue;                        
d314 1
a314 1
                        temptag->specialtag, temptag->intvalue, buffer, m_nClientVersion,
d515 1
a515 1
		switch(temptag->specialtag){
d517 1
a517 1
				m_byDataCompVer = temptag->intvalue;
d520 1
a520 1
				m_nUDPPort = temptag->intvalue;
d523 1
a523 1
				m_byUDPVer = temptag->intvalue;
d526 1
a526 1
				m_bySourceExchangeVer = temptag->intvalue;
d529 1
a529 1
				m_byAcceptCommentVer = temptag->intvalue;
d532 1
a532 1
				m_byExtendedRequestsVer = temptag->intvalue;
d535 1
a535 1
				m_byCompatableClient = temptag->intvalue;
d541 2
a542 2
                if(temptag->stringvalue) {
                    strncpy(m_modVerString,temptag->stringvalue,40);
d550 1
a550 1
                m_dwDataPlusVers = temptag->intvalue;
d553 1
a553 1
				m_byDataTarodVer = temptag->intvalue;
d568 1
a568 1
				m_L2HAC_time = temptag->intvalue;
d573 2
a574 2
                    if(temptag->stringvalue) {
                        buffer = temptag->stringvalue;                        
d577 1
a577 1
                        temptag->specialtag, temptag->intvalue, buffer, m_pszUsername,GetClientNameAndVersionString(this) );
@


1.72
log
@complete sources update (UDP)
@
text
@d116 1
d303 1
a303 1
			case 0x66:		//friendsharing
d454 1
a454 1
	CTag tag6(ET_TAROD, 1);		// To check for Tarod/Plus (just curiosity)
d456 1
a456 1
	CTag tag7(ET_PLUS, CURRENT_PLUS_VERSION);		// To check for eMulePlus
d460 1
a460 1
	CTag tag9(ET_MOD_VERSION_STR, PLUS_VERSION_STR);
d531 2
a532 2
            case ET_TAROD:
				m_byDataTarodVer = temptag->intvalue;
d534 4
a537 11
			case ET_FUSION:
			case ET_FUSION_VERSION:
			case ET_TAROD_VERSION:
			case ET_MOD_MorTillo:
			case ET_MOD_MorTillo_VERSION:
			case ET_Morph:
			case ET_Morph_VERSION:
			case ET_LSD:
			case ET_LSD_VERSION:
			case ET_MOD_LOVELACE_VERSION:
			case ET_OXY:
d539 1
a539 1
            case ET_MOD_VERSION_STR:
d546 4
a549 1
            case ET_PLUS:
d552 2
a553 2
			case ET_EXTENDEDREQUEST:
				m_byExtendedRequestsVer = temptag->intvalue;
d555 11
a565 2
			case ET_COMPATABLECLIENT:
				m_byCompatableClient = temptag->intvalue;
@


1.71
log
@removed Tag_Struct usage from sources
@
text
@d445 1
a445 1
	CTag tag2(ET_UDPVER,2);
@


1.70
log
@code cleanup
@
text
@d281 1
a281 1
		switch(temptag->tag->specialtag)
d285 1
a285 1
				if (!temptag->tag->stringvalue)
d292 1
a292 1
				m_pszUsername = CString(temptag->tag->stringvalue ? temptag->tag->stringvalue : crash);
d295 1
a295 1
				m_nClientVersion = temptag->tag->intvalue;
d298 1
a298 1
				if ( temptag->tag->intvalue != m_nUserPort && GetClientSoft() != SO_EDONKEYHYBRID ) {
d307 4
a310 4
                    char buffer[71]="";
                    if(temptag->tag->stringvalue) {
                        strncpy(buffer,temptag->tag->stringvalue,70);
                        buffer[70] = 0;
d313 1
a313 1
                        temptag->tag->specialtag, temptag->tag->intvalue, buffer, m_nClientVersion,
d514 1
a514 1
		switch(temptag->tag->specialtag){
d516 1
a516 1
				m_byDataCompVer = temptag->tag->intvalue;
d519 1
a519 1
				m_nUDPPort = temptag->tag->intvalue;
d522 1
a522 1
				m_byUDPVer = temptag->tag->intvalue;
d525 1
a525 1
				m_bySourceExchangeVer = temptag->tag->intvalue;
d528 1
a528 1
				m_byAcceptCommentVer = temptag->tag->intvalue;
d531 1
a531 1
				m_byDataTarodVer = temptag->tag->intvalue;
d547 2
a548 2
                if(temptag->tag->stringvalue) {
                    strncpy(m_modVerString,temptag->tag->stringvalue,40);
d553 1
a553 1
                m_dwDataPlusVers = temptag->tag->intvalue;
d556 1
a556 1
				m_byExtendedRequestsVer = temptag->tag->intvalue;
d559 1
a559 1
				m_byCompatableClient = temptag->tag->intvalue;
d562 1
a562 1
				m_L2HAC_time = temptag->tag->intvalue;
d566 3
a568 4
                    char buffer[71]="";
                    if(temptag->tag->stringvalue) {
                        strncpy(buffer,temptag->tag->stringvalue,70);
                        buffer[70] = 0;
d571 1
a571 1
                        temptag->tag->specialtag, temptag->tag->intvalue, buffer, m_pszUsername,GetClientNameAndVersionString(this) );
@


1.69
log
@code cleanup
@
text
@a122 1
	m_pszClientFilename = 0;
d196 1
a196 3
	}
	if (m_pszClientFilename)
		delete[] m_pszClientFilename;
d686 1
a686 1
						AddDebugLogLine(false, "Description for file '%s' filtered: %s", m_pszClientFilename, desc);
d697 1
a697 1
				AddDebugLogLine(false, "Description for file '%s' received: %s", m_pszClientFilename, desc);
d703 1
a703 1
			AddDebugLogLine(false, "Rating for file '%s' received: %i", m_pszClientFilename, m_iRate);
@


1.68
log
@code cleanup
@
text
@d290 1
a290 1
					crashed = true; char buffer[100]; buffer[0] = 0;
d292 1
a292 2
					for (uint16 i = 0;i != 16;i++)
						sprintf(buffer,"%s%02X",buffer,crashash[i]);
@


1.67
log
@coverted code from char * to CString
@
text
@d74 1
a74 1
		sprintf(m_szFullUserIP,"%i.%i.%i.%i",(uint8)m_nUserID,(uint8)(m_nUserID>>8),(uint8)(m_nUserID>>16),(uint8)(m_nUserID>>24));
d83 1
a83 1
	memset(m_szFullUserIP,0,21);
d170 1
a170 1
		strcpy(m_szFullUserIP,inet_ntoa(sockAddr.sin_addr));
d358 1
a358 1
	strcpy(m_szFullUserIP,inet_ntoa(sockAddr.sin_addr));
@


1.66
log
@Tooltip for upload queue now shows bytes/KB/MB instead of xxxxxxxxxx bytes
@
text
@d98 1
a98 1
	m_pszUsername = 0;
d203 1
a203 6
	}
	if (m_pszUsername)
	{
		delete[] m_pszUsername;
		m_pszUsername	=	NULL;
	}
d287 1
a287 2
				if (m_pszUsername)
					delete[] m_pszUsername;
d296 1
a296 1
				m_pszUsername = nstrdup(temptag->tag->stringvalue ? temptag->tag->stringvalue : crash);
d307 1
a307 1
				AddDebugLogLine(false,"Hello: client %s identifies itself as a Friendsharing client", (m_pszUsername?m_pszUsername:""));
d318 1
a318 1
                        (m_pszUsername?m_pszUsername:""));
d400 1
a400 1
			newitem.pszText = m_pszUsername;
d923 1
a923 1
	if (!m_pszUsername) {m_clientSoft=SO_UNKNOWN;return;}
a968 11
	EMULE_CATCH
}

void CUpDownClient::SetUserName(char* pszNewName){
	EMULE_TRY
	if (m_pszUsername)
		delete[] m_pszUsername;
	if( pszNewName )
	    m_pszUsername = nstrdup(pszNewName);
	else
		m_pszUsername = NULL;
@


1.65
log
@SyruS: implemented netwolf's commentfilter (partly from 0.28b)
changed default button of "allow multiple instances" to "no"
@
text
@d1057 2
a1058 2
					file->statistic.GetAccepts(), file->statistic.GetRequests(), file->statistic.GetTransfered(),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), file->statistic.GetAllTimeTransfered());
@


1.64
log
@minor fixes and improvements
@
text
@a680 2
		reqfile->SetHasRating(true);
		AddDebugLogLine(false, "Rating for file '%s' received: %i", m_pszClientFilename, m_iRate);
a685 1
			AddDebugLogLine(false, "Description for file '%s' received: %s", m_pszClientFilename, desc);
d687 22
a708 1
			reqfile->SetHasComment(true);
d711 4
a714 1

d716 2
a717 1
	if (reqfile->HasRating() || reqfile->HasComment()) theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(reqfile);
d720 1
@


1.63
log
@complete sources column
@
text
@d287 1
a287 1
	for (int i = 0;i != tagcount; i++){
d391 1
a391 1
	memcpy(key,m_achUserHash,16);
d522 1
a522 1
	for (int i = 0;i != tagcount; i++){
@


1.62
log
@slight download speedup in some cases
@
text
@d173 1
@


1.61
log
@fixed memory leak when invalid info packet was received
@
text
@d179 2
d708 1
@


1.60
log
@Tooltips fixes
@
text
@d488 1
a488 1
	CSafeMemFile* data = new CSafeMemFile((BYTE*)pachPacket,nSize);
d490 1
a490 1
	data->Read(&m_byEmuleVersion,1);
d494 1
a494 1
	data->Read(&protversion,1);
d510 1
a510 2
	} else {
		delete data;
d518 1
a518 1
	data->Read(&tagcount,4);
d520 1
a520 1
		CTag* temptag = new CTag(data);
d596 1
a596 2
	}
	delete data;
@


1.59
log
@Enhanced tooltips by JoeyRamone
@
text
@d1031 1
a1031 1
		stat.Format(GetResString(IDS_TT_FILESTATS_SESSION)+GetResString(IDS_TT_FILESTATS_TOTAL),
@


1.58
log
@Added lmule detection, better mldonkey detection and fixed bug 208
@
text
@d1014 33
@


1.57
log
@L2HAC by EnkeyDev
@
text
@d148 1
d272 1
d328 1
d332 8
a339 9
//		uint32 test;
//		data->Read(&test,4);
		m_bIsHybrid = true;
//		if( m_nClientVersion > 10000 && m_nClientVersion < 100000 )
//			m_nClientVersion = m_nClientVersion - (m_nClientVersion/10000)*10000;
//		if( m_nClientVersion > 1000 )
//			m_nClientVersion = m_nClientVersion - (m_nClientVersion/1000)*1000;
//		if( m_nClientVersion < 100 )
//			m_nClientVersion *= 10;
d341 7
d363 1
d369 1
a370 2
	// key, 255.255.0.0 subnetmask

d382 2
d599 1
d888 12
d902 2
d905 14
a918 3
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110) {m_clientSoft= SO_OLDEMULE;return;}
	if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111){
		//MTSHAZ
d926 3
d939 7
a945 1
	if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L') {m_clientSoft= SO_MLDONKEY;return;}
d1005 8
@


1.56
log
@*** empty log message ***
@
text
@d177 5
d437 1
a437 1
	uint32 tagcount = 9;
d455 1
a455 1
	CTag tag9( ET_MOD_VERSION_STR, PLUS_VERSION_STR);
d457 2
d505 2
d558 4
a561 1
            default:
d574 6
d585 1
@


1.55
log
@shareaza identification.
@
text
@d462 3
@


1.54
log
@code cleanup
@
text
@d859 15
a873 7
		if( m_byCompatableClient == 1 ){
			m_clientSoft= SO_CDONKEY;
			return;
		}
		else{
			m_clientSoft= SO_EMULE;
			return;
d875 1
@


1.53
log
@fixed memory leak
@
text
@d252 1
a252 1
	ProcessHelloTypePacket(&data);	
d258 2
a259 3
	CSafeMemFile* data = new CSafeMemFile((BYTE*)pachPacket,nSize);
	ProcessHelloTypePacket(data);
	delete data;
d263 1
a263 1
void CUpDownClient::ProcessHelloTypePacket(CSafeMemFile* data){
d266 1
a266 1
	data->Read(&m_achUserHash,16);
d268 1
a268 1
	data->Read(&nUserID,4);
d271 1
a271 1
	data->Read(&m_nUserPort,2); // hmm clientport is sent twice - why?
d273 1
a273 1
	data->Read(&tagcount,4);
d278 1
a278 1
		CTag* temptag = new CTag(data);
d319 2
a320 2
	data->Read(&m_dwServerIP,4);
	data->Read(&m_nServerPort,2);
d323 1
a323 1
	if ( data->GetLength() - data->GetPosition() == 4 ){
@


1.52
log
@Fixed the file shown on the tooltip for a downloading client.
@
text
@d249 1
a249 1
	CSafeMemFile* data = new CSafeMemFile((BYTE*)pachPacket,nSize);
d251 2
a252 3
	data->Read(&hashsize,1);
	ProcessHelloTypePacket(data);
	delete data;
@


1.51
log
@Webserver from official 0.27c
@
text
@d913 2
a914 1
	if (reqfile)
d916 1
a916 1
		sRet += GetResString(IDS_SF_REQUESTED) + CString(reqfile->GetFileName()) + "\n";
d919 2
a920 2
					reqfile->statistic.GetAccepts(), reqfile->statistic.GetRequests(), reqfile->statistic.GetTransfered(),
					reqfile->statistic.GetAllTimeAccepts(), reqfile->statistic.GetAllTimeRequests(), reqfile->statistic.GetAllTimeTransfered());
@


1.50
log
@*** empty log message ***
@
text
@d905 25
@


1.49
log
@optimise isonlan, another cause of the freezes?
@
text
@d41 15
a55 15
bool CUpDownClient::isOnLAN(){
	EMULE_TRY

	static bool bFirstTime= true;
	static bool bIsOnLan = false; 

		if (bFirstTime){
			bFirstTime = false;
			bIsOnLan = (theApp.glob_prefs->GetLancastEnabled() && ((theApp.glob_prefs->GetLancastIP()&theApp.glob_prefs->GetLancastSubnet()) == (m_dwUserIP&theApp.glob_prefs->GetLancastSubnet())));
		}
		return bIsOnLan;

	EMULE_CATCH
	return false;
}
d102 1
d351 2
a352 2
	// LANCAST (moosetea) - If this client is connecting from our subnet, fix the userid for display
	if (isOnLAN())
@


1.48
log
@Minor changes
@
text
@d44 8
a51 4
	if (theApp.glob_prefs->GetLancastEnabled())
		return ((theApp.glob_prefs->GetLancastIP()&theApp.glob_prefs->GetLancastSubnet()) == (m_dwUserIP&theApp.glob_prefs->GetLancastSubnet()));
	else
		return false;
@


1.47
log
@fix mem leak (missing inflateEnd)
@
text
@d429 1
a429 1
	uint32 tagcount = 8;
@


1.46
log
@fix for LanCast detection [BavarianSnail]
@
text
@d215 4
a218 1
		if (pending->zStream) delete pending->zStream;
@


1.45
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d43 1
d46 3
@


1.44
log
@Crash on exit workarounds
@
text
@d220 2
a221 2
	m_AvarageUDR_list.RemoveAll();
	m_AvarageDDR_list.RemoveAll();
@


1.43
log
@last bugfixes!
@
text
@d42 1
d45 2
a46 2
	else
		return false;
d74 1
d168 1
d172 1
d232 1
d236 1
d242 1
d246 1
d250 1
d254 1
a254 1
	
d382 1
d386 1
d412 1
d416 1
d452 1
d456 1
d556 1
d560 1
d570 1
d574 1
d625 1
d629 1
d651 1
d654 1
d721 1
a721 1

d725 1
d795 1
d799 1
d841 1
d845 1
d863 1
d867 1
d874 1
d878 1
d882 1
d886 1
d891 1
@


1.43.2.1
log
@27a partial merge
@
text
@a75 1
	AddNextConnect = false;  // VQB Fix for LowID slots only on connection
d93 1
a93 1
    m_iFileListRequested = 0;
d134 1
a134 1
	m_byCompatibleClient = 0;
a218 1
	SetUploadFileID(NULL);
d443 1
a443 5
	m_byCompatibleClient = 0;
	//The version number part of this packet will soon be useless since it is only able to go to v.99.
	//Why the version is a uint8 and why it was not done as a tag like the eDonkey hello packet is not known..
	//Therefore, sooner or later, we are going to have to switch over to using the eDonkey hello packet to set the version.
	//No sense making a third value sent for versions..
d518 2
a519 2
			case ET_COMPATIBLECLIENT:
				m_byCompatibleClient = temptag->tag->intvalue;
a540 1
	ReGetClientSoft();
d689 1
a689 1
    if (m_iFileListRequested){
d691 1
a691 1
        m_iFileListRequested = 0;
d810 2
a811 2
    if (m_iFileListRequested == 1){
        Packet* packet = new Packet((GetClientSoft()==SO_EDONKEYHYBRID) ? OP_ASKSHAREDDIRS : OP_ASKSHAREDFILES,0);
d821 3
a823 9
		switch(m_byCompatibleClient){
			case SO_CDONKEY:
				m_clientSoft= SO_CDONKEY;
				break;
			case 2:
				m_clientSoft = SO_LMULE;
				break;
			default:
				m_clientSoft = SO_EMULE;
d825 2
d829 1
d848 1
a848 1
    m_iFileListRequested = 1;
d853 2
a854 2
    if (m_iFileListRequested > 0){
        m_iFileListRequested--;
@


1.43.2.2
log
@27c
@
text
@a41 1
	EMULE_TRY
d44 1
a44 1
	EMULE_CATCH
a72 1
	EMULE_TRY
a166 1
	EMULE_CATCH
a169 1
	EMULE_TRY
a229 1
	EMULE_CATCH
a232 1
	EMULE_TRY
a237 1
	EMULE_CATCH
a240 1
	EMULE_TRY
a243 1
	EMULE_CATCH
d247 1
a247 1
	EMULE_TRY
a374 1
	EMULE_CATCH
a377 1
	EMULE_TRY
a402 1
	EMULE_CATCH
a405 1
	EMULE_TRY
d419 1
a419 1
	CTag tag4(ET_SOURCEEXCHANGE,2);
a440 1
	EMULE_CATCH
a443 1
	EMULE_TRY
a547 1
	EMULE_CATCH
a550 1
	EMULE_TRY
a559 1
	EMULE_CATCH
a562 1
	EMULE_TRY
a612 1
	EMULE_CATCH
d616 19
a634 27
	EMULE_TRY
	if( reqfile ){
		if( reqfile->IsPartFile()){
			int length;
			if (nSize>(sizeof(m_iRate)+sizeof(length)-1)){
				CSafeMemFile data((BYTE*)pachPacket,nSize);
				data.Read(&m_iRate,sizeof(m_iRate));
				data.Read(&length,sizeof(length));
				reqfile->SetHasRating(true);
		        AddDebugLogLine(false, "Rating for file '%s' received: %i", m_pszClientFilename, m_iRate);
				if ( length > data.GetLength() - data.GetPosition() ){
					length = data.GetLength() - data.GetPosition();
				}
		        if (length>50) length=50;
		        if (length>0){
			        char* desc=new char[length+1];
			        memset(desc,0,length+1);
			        data.Read(desc,length);
			        AddDebugLogLine(false, "Description for file '%s' received: %s", m_pszClientFilename, desc);
			        m_strComment.Format("%s",desc);
			        reqfile->SetHasComment(true);
			        delete desc;
		        }
        
	        }
	        if (reqfile->HasRating() || reqfile->HasComment()) theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(reqfile);
        }
d636 1
a636 1
	EMULE_CATCH
a637 1

a638 1
	EMULE_TRY
d705 1
a705 1
	EMULE_CATCH
a708 1
	EMULE_TRY
a777 1
	EMULE_CATCH
a780 1
	EMULE_TRY
a821 1
	EMULE_CATCH
a824 1
	EMULE_TRY
a844 1
	EMULE_CATCH
a847 1
	EMULE_TRY
a853 1
	EMULE_CATCH
a856 1
	EMULE_TRY
a859 1
	EMULE_CATCH
d863 1
a863 2
 	EMULE_TRY
   if (m_iFileListRequested > 0){
a866 10
	EMULE_CATCH
}

void CUpDownClient::SetUserHash(uchar* m_achTempUserHash){
	if( m_achTempUserHash == NULL ){
		for( int i = 0; i <16; i++)
			m_achUserHash[i] = 0;
		return;
	}
	memcpy(m_achUserHash,m_achTempUserHash,16);
@


1.42
log
@*** empty log message ***
@
text
@d104 1
d283 3
d293 1
a293 1
                    AddDebugLogLine(false,"Hello: Unknown tag: %x, Intvalue: %d Stringvalue: %s, (client version:%d) %s",
d422 1
a422 1
	tag6.WriteTagToFile(data);	// It do not harms at all
d424 1
a424 1
	tag7.WriteTagToFile(data);	                    // It do not harms at all
d427 2
d493 11
a503 8
            case ET_TAROD_VERSION:
            case ET_LSD:
            case ET_LSD_VERSION:
            case ET_OXY:
            case ET_Morph:
            case ET_Morph_VERSION:
            case ET_FUSION:
            case ET_FUSION_VERSION:
d505 6
a510 1
            case ET_MOD_NAMEVERSION_STR:
d528 1
a528 1
                    AddDebugLogLine(false,"MuleInfo - unknown tag: 0x%x, Intvalue: %d Stringvalue: %s, User: %s(%s)",
@


1.41
log
@*** empty log message ***
@
text
@a214 1
	m_PendingBlocks_list.RemoveAll();
@


1.40
log
@tags
@
text
@d198 6
a203 8
	for (POSITION pos = m_DownloadBlocks_list.GetHeadPosition();pos != 0;m_DownloadBlocks_list.GetNext(pos))
		delete m_DownloadBlocks_list.GetAt(pos);
	m_DownloadBlocks_list.RemoveAll();
	for (POSITION pos = m_RequestedFiles_list.GetHeadPosition();pos != 0;m_RequestedFiles_list.GetNext(pos))
		delete m_RequestedFiles_list.GetAt(pos);
	m_RequestedFiles_list.RemoveAll();
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition();pos != 0;m_PendingBlocks_list.GetNext(pos)){
		Pending_Block_Struct *pending = m_PendingBlocks_list.GetAt(pos);
@


1.39
log
@various bugfixes for "friends"
@
text
@d496 4
@


1.38
log
@bugfix: should download better from .26 and above( bug 61)
@
text
@d363 7
@


1.37
log
@converted to new logging method
@
text
@d75 1
@


1.36
log
@*** empty log message ***
@
text
@d272 1
a272 1
					theApp.emuledlg->AddDebugLogLine(true,"Incorrect user name received! Userhash:%s, Userport:%d",buffer,m_nUserPort);
d291 1
a291 1
                    theApp.emuledlg->AddDebugLogLine(false,"Hello: Unknown tag: %x, Intvalue: %d Stringvalue: %s, (client version:%d) %s",
d318 1
a318 1
        theApp.emuledlg->AddDebugLogLine(false,"User %s (client version:%d) IP:%s sent an incorrect user port. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,(const char*)ip_addr,m_nUserPort );
d332 1
a332 1
	if (crashed) theApp.emuledlg->AddDebugLogLine(false,"The invalid user name was sent from IP:%s)", m_szFullUserIP);
d345 1
a345 1
			theApp.emuledlg->AddLogLine(false,"Added new server: %s:%d", srv->GetFullIP(), srv->GetPort());*/
d374 1
a374 1
            theApp.emuledlg->AddDebugLogLine(false,"Filtered: %s %s", GetFullIP(),theApp.ipfilter->GetLastHit());
d505 1
a505 1
                    theApp.emuledlg->AddDebugLogLine(false,"MuleInfo - unknown tag: 0x%x, Intvalue: %d Stringvalue: %s, User: %s(%s)",
d593 1
a593 1
		theApp.emuledlg->AddDebugLogLine(false, "Rating for file '%s' received: %i", m_pszClientFilename, m_iRate);
d599 1
a599 1
			theApp.emuledlg->AddDebugLogLine(false, "Description for file '%s' received: %s", m_pszClientFilename, desc);
d610 1
a610 1
        theApp.emuledlg->AddDebugLogLine(false, "Invalid client in CUpDownClient::Disconnected");
d667 1
a667 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_SHAREDFILES_FAILED),GetUserName());
d824 1
a824 1
	theApp.emuledlg->AddDebugLogLine(true,GetResString(IDS_SHAREDFILES_REQUEST),GetUserName());
@


1.35
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d291 3
a293 1
                    theApp.emuledlg->AddDebugLogLine(false,"Hello: Unknown tag: %x, Intvalue: %d Stringvalue: %s, (client version:%d)",temptag->tag->specialtag, temptag->tag->intvalue, buffer, m_nClientVersion );
@


1.34
log
@Bugfixes
@
text
@d134 1
@


1.33
log
@more tags from other mods
@
text
@d160 3
@


1.32
log
@Oxygen tag is known now
@
text
@d480 2
@


1.31
log
@restore Plus version recognition
@
text
@d479 1
@


1.30
log
@more tags from other mods
@
text
@d119 1
a119 1
    m_byDataPlusVers = 0;
d481 1
a481 1
                m_byDataPlusVers = temptag->tag->intvalue;
@


1.29
log
@Protection from on-disk hashset corruption, proper check that we already have the data before sending
@
text
@d477 2
@


1.28
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d254 1
d276 2
a277 9
				if ( temptag->tag->intvalue != m_nUserPort )
				{
                    CString ip_addr;
                    UINT port;
                    socket->GetPeerName(ip_addr, port);
					if ( temptag->tag->intvalue >=23 && temptag->tag->intvalue <=10000 )
						theApp.emuledlg->AddDebugLogLine(false,"User %s (client version:%d) IP:%s sent a false user port:%d. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,(const char*)ip_addr,temptag->tag->intvalue,m_nUserPort );
					else
                        theApp.emuledlg->AddDebugLogLine(false,"User %s (client version:%d) IP:%s sent an incorrect user port:%d. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,(const char*)ip_addr,temptag->tag->intvalue,m_nUserPort );
d280 9
d307 7
a313 1
	// tecxx 1609 2002 - add client's servet to serverlist (Moved to uploadqueue.cpp)
d476 2
d487 10
@


1.27
log
@minimize to tray button v4a, updated connections control panel
@
text
@d40 8
d312 5
@


1.26
log
@cpu optimization!!!
@
text
@a93 1
	m_bHadDownData=false;	//Cax2 - less CPU load
@


1.25
log
@the famous zz upload system! :)
@
text
@d94 1
@


1.24
log
@Small memleak fix
@
text
@d53 1
a53 1
	m_nUserID = in_userid;
d70 1
a70 1
	m_cShowDR = 0;
a75 1
	m_cSendblock = 0;
d78 1
a78 2
	dataratems = 0;
	m_nUpDatarate = 0;
d81 1
a81 1
	m_nUserID = 0;
d106 1
a106 1
	m_nDownDataRateMS = 0;
d129 1
a129 1
	m_nCurSessionUp = 0;
a133 2
	sumavgudr = 0;
	sumavgddr = 0;
d150 2
d240 1
a240 1
		m_nUserID = nUserID;
d320 1
a320 1
		m_nUserID = m_dwUserIP;
@


1.23
log
@Code clean up and double check wit official code.
@
text
@d263 1
a263 1
				m_pszUsername = temptag->tag->stringvalue ? nstrdup(temptag->tag->stringvalue) : crash;
@


1.22
log
@*** empty log message ***
@
text
@a124 1

d138 7
a144 6
	m_RemoteScore = 0; //By Maverick
	m_RemoteRatio = 0; //By Maverick
	m_RemoteBaseModifier = 0; //By Maverick
	m_RemoteInfoAvaiable = false; //By Maverick
	m_RemoteCommunity = false; // By Maverick
	m_RemoteCommunityEnabled = false; // By Maverick
d241 1
a241 1
	if (!m_nUserID) //  || nUserID < 16777216
d247 1
a247 1
	bool crashed = false;//Vorlost
d261 1
a261 1
					theApp.emuledlg->AddDebugLogLine(true,"Incorrect user name received! Userhash:%s, Userport:%d",buffer,m_nUserPort );
a262 1
				//ASSERT (temptag->tag->stringvalue);//Vorlost wants to see when it happens again
a278 2
				//else		//Cax2 err... according to the if() above they're already identical... no need to do anything here...
				//	m_nUserPort = temptag->tag->intvalue; 
d306 1
a306 1
	if (crashed) theApp.emuledlg->AddDebugLogLine(false,"The invalid user name was sent from this IP:%s)",m_szFullUserIP );
d348 1
a348 2
            theApp.emuledlg->AddDebugLogLine(false,"Filtered: %s %s "/*GetResString(IDS_IPFILTERED)*/,
                GetFullIP(),theApp.ipfilter->GetLastHit()); // if we decide we are going to keep this, we'll add a proper string
d386 1
a386 1
	CTag tag6(ET_TAROD, 1);		// To check for Tarod (just curiosity)
d453 1
a453 1
            case ET_TAROD:	// I insist it do not harm, just curiosity
d550 1
a550 1
		// theApp.emuledlg->AddDebugLogLine(true,GetResString(IDS_RATINGRECV),m_pszClientFilename,m_iRate); // MERGE26
d556 1
a556 1
			//theApp.emuledlg->AddDebugLogLine(true,GetResString(IDS_DESCRIPTIONRECV), m_pszClientFilename, desc); // MERGE26
d567 1
a567 1
        theApp.emuledlg->AddLogLine(false, "DEBUG: Invalid client in CUpDownClient::Disconnected");
a769 56

/*
void CUpDownClient::ReGetClientSoft(void)
{
	if (!m_pszUsername) 
	{
		m_clientSoft=SO_UNKNOWN;
		return;
	}
	if (m_achUserHash[5] == 14 && m_achUserHash[6] == 1 && m_achUserHash[14] == 111 && m_achUserHash[15] == 1) 
	{
		m_clientSoft= SO_CDONKEY;
		return;
	}
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110) 
	{
		m_clientSoft= SO_OLDEMULE;
		return;
	}
	if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111) 
	{
		m_clientSoft= SO_EMULE;
		return;
	}
	if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L') 
	{
		m_clientSoft= SO_MLDONKEY;
		return;
	}
	if( this->GetVersion() > 1040 )
	{
		m_clientSoft=SO_EDONKEYHYBRID;
	}
	else
	{
		m_clientSoft=SO_EDONKEY;
	}
}


uint8 CUpDownClient::GetClientSoft(){
	if (!m_pszUsername)
		return SO_UNKNOWN;
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110)
		return SO_OLDEMULE;
	if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111)
		return SO_EMULE;
	// By Maverick
	// Identify MlDonkey (only Version <= 2.02)
	if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L')
		return SO_MLDONKEY;
	// End Patch Maverick

	return SO_EDONKEY;
}
*/
@


1.21
log
@Memory leak fixed
@
text
@d272 3
d276 1
a276 1
						theApp.emuledlg->AddDebugLogLine(false,"User %s (client version:%d) sent a false user port:%d. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,temptag->tag->intvalue,m_nUserPort );
d278 1
a278 1
						theApp.emuledlg->AddDebugLogLine(false,"User %s (client version:%d) sent an incorrect user port:%d. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,temptag->tag->intvalue,m_nUserPort );
@


1.20
log
@Preparing for new SLS code
@
text
@d171 1
d173 2
d176 1
d178 2
d181 1
d183 2
@


1.19
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d41 5
a45 1
CUpDownClient::CUpDownClient(uint16 in_port, uint32 in_userid,uint32 in_serverip, uint16 in_serverport,CPartFile* in_reqfile, CSourceEntry* source_entry){
d49 1
d52 1
d119 1
d121 1
d206 1
d209 1
d702 1
d708 1
a708 1

@


1.18
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d120 1
d124 1
a124 1
	m_nSessionUp = 0;
d217 2
d254 1
a254 1
						theApp.emuledlg->AddDebugLogLine(true,"User %s (client version:%d) sent a false user port:%d. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,temptag->tag->intvalue,m_nUserPort );
d256 1
a256 1
						theApp.emuledlg->AddDebugLogLine(true,"User %s (client version:%d) sent an incorrect user port:%d. Used the real one instead: %d.",m_pszUsername,m_nClientVersion,temptag->tag->intvalue,m_nUserPort );
d266 13
d291 1
a291 1
	if (theApp.glob_prefs->GetAddServersFromConn()){
d322 15
d530 1
d746 1
a746 1
	if( this->GetVersion() > 1040 )
d811 4
a814 1
	m_pszUsername = nstrdup(pszNewName);
@


1.17
log
@Vorlost patch for invalid port + 2 bugfixes
@
text
@d24 7
@


1.16
log
@more 26b merges
@
text
@d217 2
d221 2
a222 1
		switch(temptag->tag->specialtag){
d226 10
a235 4
				if( temptag->tag->stringvalue )
				m_pszUsername = nstrdup(temptag->tag->stringvalue);
				else
					m_pszUsername=0;
d241 9
a249 1
				m_nUserPort = temptag->tag->intvalue;
d264 1
a264 1

@


1.15
log
@.26b port
@
text
@d112 1
d212 1
a212 1
	if (!m_nUserID || nUserID < 16777216)
d290 1
a290 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d326 1
a326 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d333 1
d335 2
d345 1
a345 1
		if((m_byEmuleVersion < 0x25 && m_byEmuleVersion > 0x22) || m_byEmuleVersion == 0x2B)
d348 1
a348 1
		if((m_byEmuleVersion < 0x25 && m_byEmuleVersion > 0x21) || m_byEmuleVersion == 0x2B)
d389 3
d411 1
a411 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d502 2
d609 1
a609 1
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
d665 1
a665 1
				theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d671 1
a671 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size,0);
d676 21
d734 1
a734 1
/*
@


1.14
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d110 1
@


1.13
log
@Unnesesary call to GetStatistics removed , code rearranged a bit to put breakpoints easily .
@
text
@d42 1
a72 1
	//m_bIsBotuser =false; //Cax2 removed 'punishment'
d86 1
d88 1
d90 1
a90 1
	m_nDownloadState = 0;
d96 1
a96 1
	m_byUploadState = 0;
d115 1
d135 1
a135 2
	m_nUpPartCount = 0;
	m_abyUpPartStatus = 0;
a157 1
	
d173 6
d221 1
d223 2
d245 1
d249 11
d287 2
a288 1
	if (socket)
d290 1
d297 1
a297 1
	uint8 protversion = EMULE_PROTOCOL; // or EMULE_PROTOCOL_VERSION?
d299 1
a299 1
	uint32 tagcount = 7;
d315 2
a316 2
//	CTag tag6(ET_EXTENDEDREQUEST,1);
//	tag6.WriteTagToFile(data);
d323 2
a324 1
	if (socket)
d326 1
d381 3
a383 3
//			case ET_EXTENDEDREQUEST:
//				m_byExtendedRequestsVer = temptag->tag->intvalue;
//				break;
d402 2
a403 1
	if (socket)
d405 1
d437 1
a437 1
	uint32 tagcount = 3;
d445 3
a447 3
	tag = new CTag(CT_PORT,nPort); //Maverick
	tag->WriteTagToFile(data);
	delete tag;
d467 2
a468 1
		theApp.emuledlg->AddDebugLogLine(true,"File rating received: %i",m_iRate);
d474 1
a474 1
			theApp.emuledlg->AddDebugLogLine(true,"File description received: %s",desc);
d476 1
d481 1
d484 4
d599 1
d655 1
d661 1
a665 23
uint8 CUpDownClient::GetClientSoft(){
	ReGetClientSoft();
	return m_clientSoft;
}

void CUpDownClient::SetUserName(char* pszNewName){
	if (m_pszUsername)
		delete[] m_pszUsername;
	m_pszUsername = nstrdup(pszNewName);
}

void CUpDownClient::RequestSharedFileList(){
	theApp.emuledlg->AddDebugLogLine(true,GetResString(IDS_SHAREDFILES_REQUEST),GetUserName());
	m_bFileListRequested = true;
	TryToConnect(true);
}

void CUpDownClient::ProcessSharedFileList(char* pachPacket, uint32 nSize){
	if (m_bFileListRequested){
		m_bFileListRequested = false;
		theApp.searchlist->ProcessSearchanswer(pachPacket,nSize,this);
	}
}
d703 29
a731 38
void CUpDownClient::ProcessUpFileStatus(char* packet, uint32 size)
{
	if (m_abyUpPartStatus)
		delete[] m_abyUpPartStatus;
	m_nUpPartCount = 0;
	if( size == 16 )
		return;
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
	uchar cfilehash[16];
	data->Read(cfilehash,16);
	CKnownFile* tempreqfile = theApp.sharedfiles->GetFileByID(cfilehash);
	data->Read(&m_nUpPartCount,2);
	if (!m_nUpPartCount){
		m_nUpPartCount = tempreqfile->GetPartCount();
		m_abyUpPartStatus = new uint8[m_nUpPartCount];
		memset(m_abyUpPartStatus,0,m_nUpPartCount);
	}
	else{
		if (tempreqfile->GetPartCount() != m_nUpPartCount){
			delete data;	//mf
			m_nUpPartCount = 0;
			return;
		}
		m_abyUpPartStatus = new uint8[m_nUpPartCount];
		uint16 done = 0;
		while (done != m_nUpPartCount){
			uint8 toread;
			data->Read(&toread,1);
			for (sint32 i = 0;i != 8;i++){
				m_abyUpPartStatus[done] = ((toread>>i)&1)? 1:0;
//				We may want to use this for another feature..
//				if (m_abyUpPartStatus[done] && !tempreqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
//					bPartsNeeded = true;
				done++;
				if (done == m_nUpPartCount)
					break;
			}
		}
d733 4
a737 2
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this);
	delete data;
@


1.12
log
@Always update client soft
@
text
@d653 25
a677 5
if (!m_pszUsername) {m_clientSoft=SO_UNKNOWN;return;}
	if (m_achUserHash[5] == 14 && m_achUserHash[6] == 1 && m_achUserHash[14] == 111 && m_achUserHash[15] == 1) {m_clientSoft= SO_CDONKEY;return;}
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110) {m_clientSoft= SO_OLDEMULE;return;}
	if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111) {m_clientSoft= SO_EMULE;return;}
	if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L') {m_clientSoft= SO_MLDONKEY;return;}
d679 1
d681 1
d683 1
d685 1
@


1.11
log
@*** empty log message ***
@
text
@d629 1
@


1.10
log
@Hybrid client and CDonkey detection
@
text
@d662 44
@


1.9
log
@bugfixes & control panel updates
@
text
@d47 1
d254 1
d629 1
a629 13
	if (!m_pszUsername)
		return SO_UNKNOWN;
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110)
		return SO_OLDEMULE;
	if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111)
		return SO_EMULE;
	// By Maverick
	// Identify MlDonkey (only Version <= 2.02)
	if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L')
		return SO_MLDONKEY;
	// End Patch Maverick

	return SO_EDONKEY;
d649 13
a661 1
}@


1.9.2.1
log
@initial upgrade to .26
@
text
@a41 1
	sourcesslot=m_nUserID%SOURCESSLOTS;
a46 1
	ReGetClientSoft();
d71 1
a84 1
	m_nUpPartCount = 0;
a85 1
	m_abyUpPartStatus = 0;
d87 1
a87 1
	m_nDownloadState = DS_NONE;
d93 1
a93 1
	m_byUploadState = US_NONE;
a111 1
	m_clientSoft=SO_UNKNOWN;
d131 2
a132 1
	sourcesslot=0;
d155 1
a170 6

	if (m_iRate>0 || m_strComment.GetLength()>0) {
		m_iRate=0; m_strComment="";
		reqfile->UpdateFileRatingCommentAvail();
	}

d213 1
a213 4
				if( temptag->tag->stringvalue )
					m_pszUsername = nstrdup(temptag->tag->stringvalue);
				else
					m_pszUsername=0;
a233 1

a236 11
	if (theApp.glob_prefs->GetAddServersFromConn()){
		in_addr addhost;
		addhost.S_un.S_addr = m_dwServerIP;
		CServer* addsrv = new CServer(m_nServerPort, inet_ntoa(addhost));
		addsrv->SetListName(addsrv->GetAddress());

		if (!theApp.emuledlg->serverwnd.serverlistctrl.AddServer(addsrv, true))
			delete addsrv;
		/*else
			theApp.emuledlg->AddLogLine(false,"Added new server: %s:%d", srv->GetFullIP(), srv->GetPort());*/
	}
a252 1
	ReGetClientSoft();
d263 1
a263 2
	if (socket){
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
a264 1
	}
d271 1
a271 1
	uint8 protversion = EMULE_PROTOCOL;
d297 1
a297 2
	if (socket){
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
a298 1
	}
d308 2
a309 1
	if (protversion == EMULE_PROTOCOL) {
d374 1
a374 2
	if (socket){
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
a375 1
	}
d407 1
a407 1
	uint32 tagcount = 2;
d415 3
a417 3
//	tag = new CTag(CT_PORT,nPort); //Maverick
//	tag->WriteTagToFile(data);
//	delete tag;
d437 1
a437 2
		reqfile->SetHasRating(true);
		// theApp.emuledlg->AddDebugLogLine(true,GetResString(IDS_RATINGRECV),m_pszClientFilename,m_iRate); // MERGE26
d443 1
a443 1
			//theApp.emuledlg->AddDebugLogLine(true,GetResString(IDS_DESCRIPTIONRECV), m_pszClientFilename, desc); // MERGE26
a444 1
			reqfile->SetHasComment(true);
a448 1
	if (reqfile->HasRating() || reqfile->HasComment()) theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(reqfile);
a561 1
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
a616 1
				theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
a621 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size,0);
a625 13
void CUpDownClient::ReGetClientSoft(){
	if (!m_pszUsername) {m_clientSoft=SO_UNKNOWN;return;}
	if (m_achUserHash[5] == 14 && m_achUserHash[6] == 1 && m_achUserHash[14] == 111 && m_achUserHash[15] == 1) {m_clientSoft= SO_CDONKEY;return;}
	if (m_achUserHash[5] == 13 && m_achUserHash[14] == 110) {m_clientSoft= SO_OLDEMULE;return;}
	if (m_achUserHash[5] == 14 && m_achUserHash[14] == 111) {m_clientSoft= SO_EMULE;return;}
	if (m_achUserHash[5] == 'M' && m_achUserHash[14] == 'L') {m_clientSoft= SO_MLDONKEY;return;}
	if( this->GetVersion() > 1040 )
		m_clientSoft=SO_EDONKEYHYBRID;
	else
		m_clientSoft=SO_EDONKEY;
}

/*
a640 1
*/
@


1.9.2.2
log
@ok, let's start supporting .26's extended requests
@
text
@d299 1
a299 1
	uint32 tagcount = 8;
d315 2
a316 2
	CTag tag8(ET_EXTENDEDREQUEST,1);
	tag8.WriteTagToFile(data);
d380 3
a382 3
			case ET_EXTENDEDREQUEST:
				m_byExtendedRequestsVer = temptag->tag->intvalue;
				break;
@


1.9.2.3
log
@there is a crash in there somewhere...
@
text
@a482 4
    if(!theApp.clientlist->Debug_IsValidClient(this)) {
        theApp.emuledlg->AddLogLine(false, "DEBUG: Invalid client in CUpDownClient::Disconnected");
        return;
    }
@


1.9.2.4
log
@put in some protection against a strange corruption bug (present since .25)
@
text
@d483 1
a483 1
    if(!theApp.clientlist->Debug_IsValidClient(this)) { // obaldin: a quick fix for a strange bug
@


1.8
log
@Updates to Preferences (and enabling/disabling options in code because of that)
@
text
@d391 1
a391 1
	if (GetClientSoft() == SO_MLDONKEY)
@


1.7
log
@bugfix: column size & settings remembered, removed 'punishments'
@
text
@d393 1
a393 1
		switch (theApp.glob_prefs->GetMlDonkeyBehviour())
d395 4
a398 13
			case eEmulateMlDonkey:
				hash[5] = 'M';
				hash[14] = 'L';
				break; 
			case eEmulateEDonkey:
				while ((hash[5] == 14) && (hash[14] = 111))
				{
					uint8	random = rand();
					memcpy(&hash[5],&random,1);
					random = rand();
					memcpy(&hash[14],&random,1);
				}
				break;
@


1.6
log
@Low ID Bugfix
@
text
@d71 1
a71 1
	m_bIsBotuser =false;
@


1.6.2.1
log
@updating this branch...
@
text
@@


1.6.2.2
log
@removed punishments & bugfixed load column positions
@
text
@d71 1
a71 1
	//m_bIsBotuser =false; //Cax2 removed 'punishment'
@


1.6.2.3
log
@updated control panes, and assorted bugfixes
@
text
@d391 1
a391 1
	if (GetClientSoft() == SO_MLDONKEY && theApp.glob_prefs->GetMlDonkeyCM())		//Cax2 only if enabled
d393 1
a393 1
		while ((hash[5] == 14) && (hash[14] = 111))
d395 13
a407 4
			uint8	random = rand();
			memcpy(&hash[5],&random,1);
			random = rand();
			memcpy(&hash[14],&random,1);
@


1.5
log
@updated to .25b codebase
@
text
@d388 4
a391 1
	if (GetClientSoft() != SO_EMULE && GetClientSoft() != SO_OLDEMULE)
@


1.4
log
@port to .25 b codebase...
@
text
@d97 1
d234 2
d237 1
a237 4
	// Potential SPOOF bug - Fix by moosetea 
	// if a client is confirmed HIGH ID (ie ip visible from anywhere)
	// and there userid doesnt match you try to fix the userid 
 	if (!HasLowID() && (m_nUserID != m_dwUserIP)) {
a238 1
	}
a239 2
	// get client credits
	// key, 255.255.0.0 subnetmask
d273 1
a273 1
	uint32 tagcount = 6;
d287 2
a288 1

d308 2
a309 1
	if (protversion == EMULE_PROTOCOL) {
d336 1
a336 1
				m_nUDPPort  = temptag->tag->intvalue;
d347 1
a347 1
			case ET_TAROD:	// I insist it do not harm, just curiosity
d350 3
a408 2
	
	//data->Write(theApp.glob_prefs->GetUserHash(),16);
a455 1

d566 4
a569 4
				Packet* packet = new Packet(OP_CALLBACKREQUEST,4);
				memcpy(packet->pBuffer,&m_nUserID,4);
				theApp.serverconnect->SendPacket(packet);
			}
d581 1
a583 1
	}
a598 1
	// End by Tarod
@


1.3
log
@*** empty log message ***
@
text
@d62 2
a63 1
	m_cAsked = 0; //<<--
d443 1
a443 1
//		theApp.emuledlg->AddLogLine(true,"File rating received: %i",m_iRate);
d449 1
a449 1
//			theApp.emuledlg->AddLogLine(true,"File description received: %s",desc);
@


1.2
log
@*** empty log message ***
@
text
@d62 1
a62 2
	m_cAsked = 0;
	m_cDownAsked = 0;
d105 1
d115 6
d273 1
a273 1
	uint8 protversion = EMULE_PROTOCOL;
d376 1
a376 1
	// By MAverick
d382 4
a385 1
	if (GetClientSoft() == SO_MLDONKEY)
d410 1
a410 1
	uint16 nPort = theApp.glob_prefs->GetPort();
d420 1
a420 1
	tag = new CTag(CT_PORT,theApp.glob_prefs->GetPort());
d641 1
a641 1
	// Identify MlDonkey
@


1.1
log
@*** empty log message ***
@
text
@d62 2
a63 1
	m_cAsked = 0; //<<--
d92 1
a92 1
	downdataratems = 0;
d97 4
d109 2
d157 5
a161 3
		delete m_PendingBlocks_list.GetAt(pos)->block;
		delete m_PendingBlocks_list.GetAt(pos)->buffer;
		delete m_PendingBlocks_list.GetAt(pos);
d267 1
a267 1
	uint8 protversion = EMULE_PROTOCOL_VERSION;
d269 1
a269 1
	uint32 tagcount = 3;
d273 1
a273 1
	CTag tag2(ET_UDPPORT,theApp.glob_prefs->GetUDPPort());
d275 8
a282 2
	CTag tag3(ET_TAROD, 1);		// To check for Tarod (just curiosity)
	tag3.WriteTagToFile(data);	// It do not harms at all
d284 2
d301 15
a315 3
	if (protversion == EMULE_PROTOCOL_VERSION)
		m_bEmuleProtocol = true;
	else{
d319 2
d332 9
d344 3
d350 6
d397 2
d500 1
a500 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_SHAREDFILES_FAILED),GetUserName());
d590 1
d647 1
a647 1
	theApp.emuledlg->AddLogLine(true,GetResString(IDS_SHAREDFILES_REQUEST),GetUserName());
@

