head	1.295;
access;
symbols
	PublicRelease_1_2e:1.285
	Interim_Release_1-2e_RC1:1.283
	PublicRelease_1_2d:1.275
	Interim_Release_1-2d_RC1:1.275
	Interim_Release_1-2d_beta1:1.275
	PublicRelease_1_2c:1.271
	Interim_Release_1-2c_RC1:1.271
	Interim_Release_1-2c_beta1:1.266
	PublicRelease_1_2b:1.266
	Interim_Release_1-2b_RC1:1.264
	PublicRelease_1_2a:1.258
	Interim_Release_1-2a_RC1:1.257
	Interim_Release_1-2a_beta2:1.250
	Interim_Release_1-2a_beta1:1.245
	PublicRelease_1_2:1.237
	Interim_Release_1-2_RC1:1.237
	Interim_Release_1-2_beta1:1.234
	PublicRelease_1_1g:1.231
	Interim_Release_1-1g_RC3:1.231
	Interim_Release_1-1g_RC2:1.231
	Interim_Release_1-1g_RC1:1.230
	Interim_Release_1-1g_beta2:1.227
	Interim_Release_1-1g_beta1:1.222
	PublicRelease_1_1f:1.220
	Interim_Release_1-1f_RC1:1.220
	PublicRelease_1_1e:1.217
	Interim_Release_1-1e_RC2:1.217
	Interim_Release_1-1e_RC1:1.214
	Interim_Release_1-1e_beta1:1.211
	PublicRelease_1_1d:1.209
	Interim_Release_1-1d_RC1:1.209
	PublicRelease_1_1c:1.208
	Interim_Release_1-1c_RC1:1.208
	Interim_Release_1-1c_beta2:1.208
	Interim_Release_1-1c_beta1:1.207
	PublicRelease_1_1b:1.206
	Interim_Release_1-1b_RC1:1.206
	PublicRelease_1_1a:1.206
	Interim_Release_1-1a_RC2:1.206
	Interim_Release_1-1a_RC1:1.203
	Interim_Release_1-1a_beta2:1.203
	Interim_Release_1-1a_beta1:1.198
	PublicRelease_1_1:1.196
	Interim_Release_1-1_beta1:1.196
	PublicRelease_1o:1.196
	Interim_Release_1o_RC1:1.196
	Interim_Release_1o_beta1:1.196
	PublicRelease_1n:1.195
	Interim_Release_1n_RC2:1.195
	Interim_Release_1n_RC1:1.194
	Interim_Release_1n_beta2:1.187
	Interim_Release_1n_beta1:1.184
	PublicRelease_1m:1.182
	Interim_Release_1m_beta1:1.181
	PublicRelease_1l:1.181
	Interim_Release_1l_RC3:1.179
	Interim_Release_1l_RC2:1.178
	Interim_Release_1l_RC1:1.177
	Interim_Release_1l_beta2:1.170
	Interim_Release_1l_beta1:1.162
	PublicRelease_1k:1.159
	Interim_Release_1k_RC4:1.158
	Interim_1k_RC3:1.157
	Interim_1k_RC2:1.157
	Interim_Release_1k_RC1:1.155
	Interim_Release_1k_beta5:1.151
	Intrerim_Release_1k_beta4:1.151
	Interim_Release_1k_beta1:1.148
	PublicRelease_1j:1.131
	Interim_Release_1J_RC3:1.131
	Interim_Release_1j_RC3:1.131
	Interim_Release_1j_RC2:1.128
	Interim_Release_1j_RC1:1.127
	Interim_Release_1j_beta2:1.126
	Interim_Release_1j_beta1:1.126
	PublicRelease_1i:1.122
	Interim_Release_1i_RC6:1.121
	Interim_Release_1i_RC3:1.115
	Interim_Release_1i_RC2:1.115
	Interim_Release_1i_RC1:1.115
	Interim_Release_1i_beta3:1.115
	Interim_Release_1i_beta2:1.110
	Interim_Release_1i_beta1:1.98
	PublicRelease_1h:1.82
	Interim_Release_1h_rc2:1.82
	Interim_Release_1h_RC1:1.82
	Interim_Release_1h_beta2:1.77
	Interim_Release_1h_beta1_now:1.75
	Interim_Release_1h_beta1:1.75
	PublicRelease_1g:1.72
	Interim_Release_1g_RC6_Final:1.72
	Interim_Release_1g_RC6:1.69
	Interim_Release_1g_RC5:1.67
	Interim_Release_1g_RC4:1.67
	Interim_Release_1g_RC3:1.65
	Interim_Release_1g_beta2:1.55
	Interim_Release_1g_beta1:1.47
	Interim_Release_1f_RC4:1.46
	Interim_Release_1f_RC3:1.44
	Interim_Release_1f_RC2:1.42
	Interim_Release_1f_RC:1.42
	Interim_Release_1f_beta2:1.42
	Interim_Release_1f_beta1:1.38
	PublicRelease_1e:1.36
	Interim_Release_1e_RC2:1.36
	Interim_Release_1e_RC:1.36
	Interim_Release_1e_beta3:1.36
	Interim_Release_1e_beta2:1.36
	Interim_Release_1e_beta2_before_kuchin:1.35
	Interim_Release_1e_beta1:1.34
	PublicRelease_1c:1.32
	featurestest:1.32.0.2
	Interim_Release_1c_RC:1.32
	Interim_Release_1c_beta2:1.31
	Interim_Release_1c_beta1:1.28
	threaded_downloadqueue:1.28.0.2
	PublicRelease_1b:1.27
	Interim_Release_1b_beta2:1.26
	Interim_Release_1b_beta1:1.26
	proxydeadlake:1.22.0.2
	PublicRelease_1a:1.22
	Interim_Release_1a_beta2:1.22
	BerkeleyDb:1.21.0.2
	Interim_Release_1a_beta1:1.21
	PublicRelease_1:1.20
	goldfish:1.20
	eMulePlus_1_RC2:1.18
	eMulePlus_26b_1RC1:1.18
	PreRelease_26b_i0e:1.18
	before_26d_merge:1.17
	Interim_Release_26b_i0d:1.15
	Interim_Release_26b_i0c:1.13
	Interim_Release_26b_i0b:1.12
	Interim_Release_26b_i0a:1.12
	systraydlg:1.5.0.4
	plus26based:1.5.0.2
	Interim_Release_25b_i0b:1.5
	Proxy_Dev:1.4
	Interim_Release_25b_i0a:1.3.2.3
	proxytest:1.3.2.2.0.2
	official_sockets:1.3.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.295
date	2012.09.20.03.25.44;	author aw3;	state Exp;
branches;
next	1.294;

1.294
date	2010.05.13.04.48.49;	author aw3;	state Exp;
branches;
next	1.293;

1.293
date	2009.11.24.05.15.01;	author aw3;	state Exp;
branches;
next	1.292;

1.292
date	2009.10.28.04.34.58;	author aw3;	state Exp;
branches;
next	1.291;

1.291
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.290;

1.290
date	2009.06.20.14.26.32;	author aw3;	state Exp;
branches;
next	1.289;

1.289
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.288;

1.288
date	2009.05.19.01.26.36;	author aw3;	state Exp;
branches;
next	1.287;

1.287
date	2009.05.18.20.36.13;	author aw3;	state Exp;
branches;
next	1.286;

1.286
date	2009.05.16.23.52.44;	author aw3;	state Exp;
branches;
next	1.285;

1.285
date	2009.04.10.03.37.49;	author aw3;	state Exp;
branches;
next	1.284;

1.284
date	2009.04.08.04.05.38;	author aw3;	state Exp;
branches;
next	1.283;

1.283
date	2009.03.21.22.47.43;	author aw3;	state Exp;
branches;
next	1.282;

1.282
date	2009.03.01.20.46.26;	author aw3;	state Exp;
branches;
next	1.281;

1.281
date	2009.03.01.05.50.34;	author aw3;	state Exp;
branches;
next	1.280;

1.280
date	2009.01.21.03.36.38;	author aw3;	state Exp;
branches;
next	1.279;

1.279
date	2009.01.18.02.12.15;	author aw3;	state Exp;
branches;
next	1.278;

1.278
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.277;

1.277
date	2008.10.04.03.40.26;	author aw3;	state Exp;
branches;
next	1.276;

1.276
date	2008.07.23.04.08.52;	author aw3;	state Exp;
branches;
next	1.275;

1.275
date	2008.01.10.23.08.25;	author eklmn;	state Exp;
branches;
next	1.274;

1.274
date	2008.01.02.04.08.38;	author aw3;	state Exp;
branches;
next	1.273;

1.273
date	2008.01.01.11.30.32;	author eklmn;	state Exp;
branches;
next	1.272;

1.272
date	2007.12.01.10.38.06;	author eklmn;	state Exp;
branches;
next	1.271;

1.271
date	2007.07.29.05.20.37;	author aw3;	state Exp;
branches;
next	1.270;

1.270
date	2007.07.27.06.21.20;	author aw3;	state Exp;
branches;
next	1.269;

1.269
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.268;

1.268
date	2007.06.01.04.49.26;	author aw3;	state Exp;
branches;
next	1.267;

1.267
date	2007.05.28.02.07.14;	author aw3;	state Exp;
branches;
next	1.266;

1.266
date	2007.02.04.05.50.19;	author aw3;	state Exp;
branches;
next	1.265;

1.265
date	2007.01.21.06.40.27;	author aw3;	state Exp;
branches;
next	1.264;

1.264
date	2007.01.17.07.40.13;	author aw3;	state Exp;
branches;
next	1.263;

1.263
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.262;

1.262
date	2007.01.08.05.59.45;	author aw3;	state Exp;
branches;
next	1.261;

1.261
date	2006.11.16.05.51.46;	author aw3;	state Exp;
branches;
next	1.260;

1.260
date	2006.11.05.18.20.54;	author eklmn;	state Exp;
branches;
next	1.259;

1.259
date	2006.10.20.18.57.43;	author eklmn;	state Exp;
branches;
next	1.258;

1.258
date	2006.09.25.02.43.19;	author aw3;	state Exp;
branches;
next	1.257;

1.257
date	2006.09.12.04.09.56;	author aw3;	state Exp;
branches;
next	1.256;

1.256
date	2006.09.09.19.44.18;	author aw3;	state Exp;
branches;
next	1.255;

1.255
date	2006.08.07.23.59.46;	author aw3;	state Exp;
branches;
next	1.254;

1.254
date	2006.07.29.02.00.41;	author aw3;	state Exp;
branches;
next	1.253;

1.253
date	2006.07.23.17.49.42;	author aw3;	state Exp;
branches;
next	1.252;

1.252
date	2006.07.23.00.36.34;	author aw3;	state Exp;
branches;
next	1.251;

1.251
date	2006.07.21.01.04.59;	author aw3;	state Exp;
branches;
next	1.250;

1.250
date	2006.06.19.04.15.32;	author aw3;	state Exp;
branches;
next	1.249;

1.249
date	2006.06.05.04.38.18;	author aw3;	state Exp;
branches;
next	1.248;

1.248
date	2006.05.21.06.14.29;	author aw3;	state Exp;
branches;
next	1.247;

1.247
date	2006.05.15.05.51.10;	author aw3;	state Exp;
branches;
next	1.246;

1.246
date	2006.05.13.04.40.28;	author aw3;	state Exp;
branches;
next	1.245;

1.245
date	2006.04.30.12.41.17;	author aw3;	state Exp;
branches;
next	1.244;

1.244
date	2006.04.29.21.54.26;	author eklmn;	state Exp;
branches;
next	1.243;

1.243
date	2006.04.26.20.31.52;	author eklmn;	state Exp;
branches;
next	1.242;

1.242
date	2006.04.25.05.09.56;	author aw3;	state Exp;
branches;
next	1.241;

1.241
date	2006.04.16.23.52.29;	author kush_eplus;	state Exp;
branches;
next	1.240;

1.240
date	2006.04.07.19.08.46;	author eklmn;	state Exp;
branches;
next	1.239;

1.239
date	2006.03.24.14.35.48;	author eklmn;	state Exp;
branches;
next	1.238;

1.238
date	2006.03.23.17.31.46;	author eklmn;	state Exp;
branches;
next	1.237;

1.237
date	2006.02.20.05.37.51;	author aw3;	state Exp;
branches;
next	1.236;

1.236
date	2006.02.14.15.52.16;	author aw3;	state Exp;
branches;
next	1.235;

1.235
date	2006.02.06.03.06.28;	author aw3;	state Exp;
branches;
next	1.234;

1.234
date	2006.01.15.07.18.06;	author aw3;	state Exp;
branches;
next	1.233;

1.233
date	2006.01.12.17.58.09;	author eklmn;	state Exp;
branches;
next	1.232;

1.232
date	2006.01.03.04.35.56;	author aw3;	state Exp;
branches;
next	1.231;

1.231
date	2005.12.03.07.57.57;	author eklmn;	state Exp;
branches;
next	1.230;

1.230
date	2005.11.28.03.09.10;	author aw3;	state Exp;
branches;
next	1.229;

1.229
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.228;

1.228
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.227;

1.227
date	2005.11.25.05.11.43;	author aw3;	state Exp;
branches;
next	1.226;

1.226
date	2005.11.23.04.00.32;	author aw3;	state Exp;
branches;
next	1.225;

1.225
date	2005.10.04.03.27.25;	author aw3;	state Exp;
branches;
next	1.224;

1.224
date	2005.09.30.04.45.03;	author aw3;	state Exp;
branches;
next	1.223;

1.223
date	2005.09.13.06.00.29;	author aw3;	state Exp;
branches;
next	1.222;

1.222
date	2005.08.17.18.49.43;	author eklmn;	state Exp;
branches;
next	1.221;

1.221
date	2005.08.10.05.20.40;	author eklmn;	state Exp;
branches;
next	1.220;

1.220
date	2005.07.23.11.04.37;	author eklmn;	state Exp;
branches;
next	1.219;

1.219
date	2005.07.18.03.24.43;	author aw3;	state Exp;
branches;
next	1.218;

1.218
date	2005.07.14.02.40.42;	author aw3;	state Exp;
branches;
next	1.217;

1.217
date	2005.07.08.18.50.16;	author eklmn;	state Exp;
branches;
next	1.216;

1.216
date	2005.07.07.03.11.36;	author aw3;	state Exp;
branches;
next	1.215;

1.215
date	2005.07.04.01.21.25;	author aw3;	state Exp;
branches;
next	1.214;

1.214
date	2005.06.19.05.02.39;	author aw3;	state Exp;
branches;
next	1.213;

1.213
date	2005.06.18.16.11.45;	author eklmn;	state Exp;
branches;
next	1.212;

1.212
date	2005.06.07.03.35.18;	author aw3;	state Exp;
branches;
next	1.211;

1.211
date	2005.06.04.06.59.54;	author eklmn;	state Exp;
branches;
next	1.210;

1.210
date	2005.05.17.16.27.47;	author eklmn;	state Exp;
branches;
next	1.209;

1.209
date	2005.03.03.20.38.36;	author eklmn;	state Exp;
branches;
next	1.208;

1.208
date	2005.02.16.05.10.11;	author aw3;	state Exp;
branches;
next	1.207;

1.207
date	2005.01.07.22.28.55;	author netwolf1;	state Exp;
branches;
next	1.206;

1.206
date	2004.12.08.19.29.44;	author aw3;	state Exp;
branches;
next	1.205;

1.205
date	2004.12.04.11.02.22;	author eklmn;	state Exp;
branches;
next	1.204;

1.204
date	2004.11.29.05.50.22;	author aw3;	state Exp;
branches;
next	1.203;

1.203
date	2004.11.11.17.08.54;	author eklmn;	state Exp;
branches;
next	1.202;

1.202
date	2004.11.11.07.22.55;	author aw3;	state Exp;
branches;
next	1.201;

1.201
date	2004.11.10.17.24.33;	author aw3;	state Exp;
branches;
next	1.200;

1.200
date	2004.11.09.19.11.46;	author aw3;	state Exp;
branches;
next	1.199;

1.199
date	2004.11.09.05.11.49;	author aw3;	state Exp;
branches;
next	1.198;

1.198
date	2004.11.07.12.28.54;	author eklmn;	state Exp;
branches;
next	1.197;

1.197
date	2004.11.06.04.50.08;	author aw3;	state Exp;
branches;
next	1.196;

1.196
date	2004.09.17.20.50.40;	author aw3;	state Exp;
branches;
next	1.195;

1.195
date	2004.08.31.05.18.05;	author eklmn;	state Exp;
branches;
next	1.194;

1.194
date	2004.08.26.20.56.16;	author aw3;	state Exp;
branches;
next	1.193;

1.193
date	2004.08.26.12.09.40;	author eklmn;	state Exp;
branches;
next	1.192;

1.192
date	2004.08.17.16.56.10;	author aw3;	state Exp;
branches;
next	1.191;

1.191
date	2004.08.16.13.21.23;	author eklmn;	state Exp;
branches;
next	1.190;

1.190
date	2004.08.15.21.06.02;	author eklmn;	state Exp;
branches;
next	1.189;

1.189
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.188;

1.188
date	2004.08.10.19.25.47;	author eklmn;	state Exp;
branches;
next	1.187;

1.187
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.186;

1.186
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.185;

1.185
date	2004.08.03.23.57.53;	author aw3;	state Exp;
branches;
next	1.184;

1.184
date	2004.07.12.14.10.41;	author katsyonak;	state Exp;
branches;
next	1.183;

1.183
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.182;

1.182
date	2004.06.23.20.13.15;	author aw3;	state Exp;
branches;
next	1.181;

1.181
date	2004.06.10.22.04.19;	author netwolf1;	state Exp;
branches;
next	1.180;

1.180
date	2004.06.09.15.51.55;	author dongato;	state Exp;
branches;
next	1.179;

1.179
date	2004.06.07.13.48.39;	author netwolf1;	state Exp;
branches;
next	1.178;

1.178
date	2004.05.29.08.39.48;	author bavariansnail;	state Exp;
branches;
next	1.177;

1.177
date	2004.05.26.12.49.25;	author netwolf1;	state Exp;
branches;
next	1.176;

1.176
date	2004.05.26.06.35.12;	author dongato;	state Exp;
branches;
next	1.175;

1.175
date	2004.05.25.19.11.16;	author bavariansnail;	state Exp;
branches;
next	1.174;

1.174
date	2004.05.25.05.47.21;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2004.05.24.19.52.35;	author dongato;	state Exp;
branches;
next	1.172;

1.172
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.171;

1.171
date	2004.05.21.22.35.28;	author dongato;	state Exp;
branches;
next	1.170;

1.170
date	2004.05.21.18.37.18;	author dongato;	state Exp;
branches;
next	1.169;

1.169
date	2004.05.21.15.50.01;	author dongato;	state Exp;
branches;
next	1.168;

1.168
date	2004.05.19.19.49.35;	author netwolf1;	state Exp;
branches;
next	1.167;

1.167
date	2004.05.19.10.14.28;	author netwolf1;	state Exp;
branches;
next	1.166;

1.166
date	2004.05.18.01.00.30;	author kush_eplus;	state Exp;
branches;
next	1.165;

1.165
date	2004.05.14.13.29.47;	author kush_eplus;	state Exp;
branches;
next	1.164;

1.164
date	2004.05.13.03.21.04;	author kush_eplus;	state Exp;
branches;
next	1.163;

1.163
date	2004.05.12.08.12.00;	author dongato;	state Exp;
branches;
next	1.162;

1.162
date	2004.05.04.11.28.00;	author netwolf1;	state Exp;
branches;
next	1.161;

1.161
date	2004.04.14.11.29.26;	author eklmn;	state Exp;
branches;
next	1.160;

1.160
date	2004.04.10.16.53.50;	author aw3;	state Exp;
branches;
next	1.159;

1.159
date	2004.04.09.03.55.12;	author dongato;	state Exp;
branches;
next	1.158;

1.158
date	2004.04.06.18.45.39;	author dongato;	state Exp;
branches;
next	1.157;

1.157
date	2004.03.31.17.15.10;	author eklmn;	state Exp;
branches;
next	1.156;

1.156
date	2004.03.31.08.05.09;	author eklmn;	state Exp;
branches;
next	1.155;

1.155
date	2004.03.28.12.33.49;	author eklmn;	state Exp;
branches;
next	1.154;

1.154
date	2004.03.27.17.22.13;	author eklmn;	state Exp;
branches;
next	1.153;

1.153
date	2004.03.25.09.17.18;	author eklmn;	state Exp;
branches;
next	1.152;

1.152
date	2004.03.24.09.51.21;	author eklmn;	state Exp;
branches;
next	1.151;

1.151
date	2004.03.14.19.49.57;	author eklmn;	state Exp;
branches;
next	1.150;

1.150
date	2004.03.14.12.23.38;	author eklmn;	state Exp;
branches;
next	1.149;

1.149
date	2004.02.21.22.00.27;	author double_t;	state Exp;
branches;
next	1.148;

1.148
date	2004.02.18.23.20.55;	author kush_eplus;	state Exp;
branches;
next	1.147;

1.147
date	2004.02.18.13.48.45;	author kush_eplus;	state Exp;
branches;
next	1.146;

1.146
date	2004.02.17.01.58.30;	author kush_eplus;	state Exp;
branches;
next	1.145;

1.145
date	2004.02.16.17.31.08;	author eklmn;	state Exp;
branches;
next	1.144;

1.144
date	2004.02.15.19.48.35;	author eklmn;	state Exp;
branches;
next	1.143;

1.143
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.142;

1.142
date	2004.02.13.16.13.34;	author netwolf1;	state Exp;
branches;
next	1.141;

1.141
date	2004.02.11.07.05.54;	author eklmn;	state Exp;
branches;
next	1.140;

1.140
date	2004.02.11.04.13.00;	author katsyonak;	state Exp;
branches;
next	1.139;

1.139
date	2004.02.06.19.53.55;	author morevit;	state Exp;
branches;
next	1.138;

1.138
date	2004.02.04.23.59.59;	author kush_eplus;	state Exp;
branches;
next	1.137;

1.137
date	2004.02.04.19.05.57;	author morevit;	state Exp;
branches;
next	1.136;

1.136
date	2004.02.03.14.28.06;	author kush_eplus;	state Exp;
branches;
next	1.135;

1.135
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.134;

1.134
date	2004.02.03.01.20.31;	author double_t;	state Exp;
branches;
next	1.133;

1.133
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.132;

1.132
date	2004.01.28.23.47.39;	author dongato;	state Exp;
branches;
next	1.131;

1.131
date	2004.01.19.23.42.58;	author double_t;	state Exp;
branches;
next	1.130;

1.130
date	2004.01.19.23.24.09;	author eklmn;	state Exp;
branches;
next	1.129;

1.129
date	2004.01.19.23.04.17;	author double_t;	state Exp;
branches;
next	1.128;

1.128
date	2004.01.11.14.59.31;	author syrus77;	state Exp;
branches;
next	1.127;

1.127
date	2004.01.10.20.19.27;	author eklmn;	state Exp;
branches;
next	1.126;

1.126
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.125;

1.125
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.124;

1.124
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.123;

1.123
date	2003.12.12.20.30.03;	author eklmn;	state Exp;
branches;
next	1.122;

1.122
date	2003.12.09.10.39.52;	author kuchin;	state Exp;
branches;
next	1.121;

1.121
date	2003.12.08.06.18.38;	author eklmn;	state Exp;
branches;
next	1.120;

1.120
date	2003.12.07.20.02.04;	author eklmn;	state Exp;
branches;
next	1.119;

1.119
date	2003.12.07.09.09.15;	author eklmn;	state Exp;
branches;
next	1.118;

1.118
date	2003.12.06.12.28.19;	author eklmn;	state Exp;
branches;
next	1.117;

1.117
date	2003.12.04.06.52.08;	author eklmn;	state Exp;
branches;
next	1.116;

1.116
date	2003.11.30.17.58.59;	author eklmn;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.114;

1.114
date	2003.10.28.20.30.23;	author eklmn;	state Exp;
branches;
next	1.113;

1.113
date	2003.10.28.17.02.10;	author eklmn;	state Exp;
branches;
next	1.112;

1.112
date	2003.10.26.13.34.11;	author eklmn;	state Exp;
branches;
next	1.111;

1.111
date	2003.10.26.12.02.51;	author eklmn;	state Exp;
branches;
next	1.110;

1.110
date	2003.10.24.01.21.19;	author morevit;	state Exp;
branches;
next	1.109;

1.109
date	2003.10.23.19.08.54;	author uid124029;	state Exp;
branches;
next	1.108;

1.108
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.107;

1.107
date	2003.10.20.13.19.59;	author morevit;	state Exp;
branches;
next	1.106;

1.106
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.105;

1.105
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.104;

1.104
date	2003.10.15.10.24.20;	author morevit;	state Exp;
branches;
next	1.103;

1.103
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.102;

1.102
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.101;

1.101
date	2003.10.08.12.56.33;	author morevit;	state Exp;
branches;
next	1.100;

1.100
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.99;

1.99
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.98;

1.98
date	2003.10.02.00.58.14;	author morevit;	state Exp;
branches;
next	1.97;

1.97
date	2003.09.30.11.34.05;	author morevit;	state Exp;
branches;
next	1.96;

1.96
date	2003.09.30.06.58.44;	author dongato;	state Exp;
branches;
next	1.95;

1.95
date	2003.09.29.14.55.46;	author morevit;	state Exp;
branches;
next	1.94;

1.94
date	2003.09.26.23.20.48;	author double_t;	state Exp;
branches;
next	1.93;

1.93
date	2003.09.26.21.38.31;	author eklmn;	state Exp;
branches;
next	1.92;

1.92
date	2003.09.26.20.33.20;	author eklmn;	state Exp;
branches;
next	1.91;

1.91
date	2003.09.24.20.37.29;	author dongato;	state Exp;
branches;
next	1.90;

1.90
date	2003.09.23.21.35.54;	author eklmn;	state Exp;
branches;
next	1.89;

1.89
date	2003.09.22.17.38.56;	author bavariansnail;	state Exp;
branches;
next	1.88;

1.88
date	2003.09.22.16.19.31;	author morevit;	state Exp;
branches;
next	1.87;

1.87
date	2003.09.22.06.18.16;	author bavariansnail;	state Exp;
branches;
next	1.86;

1.86
date	2003.09.21.22.05.16;	author morevit;	state Exp;
branches;
next	1.85;

1.85
date	2003.09.21.11.39.49;	author bavariansnail;	state Exp;
branches;
next	1.84;

1.84
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.83;

1.83
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.82;

1.82
date	2003.09.10.08.35.58;	author netwolf1;	state Exp;
branches;
next	1.81;

1.81
date	2003.09.08.22.28.53;	author netwolf1;	state Exp;
branches;
next	1.80;

1.80
date	2003.09.08.18.31.09;	author eklmn;	state Exp;
branches;
next	1.79;

1.79
date	2003.09.07.14.55.29;	author zegzav;	state Exp;
branches;
next	1.78;

1.78
date	2003.09.07.05.20.38;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2003.08.30.11.23.25;	author emoulari;	state Exp;
branches;
next	1.76;

1.76
date	2003.08.24.20.28.03;	author zegzav;	state Exp;
branches;
next	1.75;

1.75
date	2003.08.16.17.57.38;	author eklmn;	state Exp;
branches;
next	1.74;

1.74
date	2003.08.10.04.43.39;	author eklmn;	state Exp;
branches;
next	1.73;

1.73
date	2003.07.28.19.09.26;	author double_t;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.25.05.11.21;	author partyckip;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.25.04.11.06;	author partyckip;	state Exp;
branches;
next	1.70;

1.70
date	2003.07.24.17.17.17;	author eklmn;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.17.16.20.45;	author eklmn;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.16.14.10.16;	author moosetea;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.05.15.53.28;	author eklmn;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.05.15.21.11;	author eklmn;	state Exp;
branches;
next	1.65;

1.65
date	2003.07.02.16.01.10;	author eklmn;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.24.18.14.47;	author eklmn;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.21.16.46.30;	author partyckip;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.20.18.37.32;	author dongato;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.19.22.11.20;	author eklmn;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.14.18.08.22;	author partyckip;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.13.17.17.08;	author eklmn;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.11.18.27.09;	author eklmn;	state Exp;
branches;
next	1.56;

1.56
date	2003.06.10.09.36.45;	author kuchin;	state Exp;
branches;
next	1.55;

1.55
date	2003.06.09.01.15.45;	author syrus77;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.08.12.22.57;	author eklmn;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.06.21.29.41;	author partyckip;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.06.20.37.17;	author partyckip;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.06.20.01.39;	author eklmn;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.05.01.22.30;	author netwolf1;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.04.16.10.45;	author eklmn;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.28.05.29.11;	author partyckip;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.24.22.02.45;	author netwolf1;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.23.17.10.38;	author partyckip;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.20.20.46.27;	author netwolf1;	state Exp;
branches;
next	1.43;

1.43
date	2003.05.18.00.06.21;	author netwolf1;	state Exp;
branches;
next	1.42;

1.42
date	2003.05.09.11.57.06;	author kuchin;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.09.10.41.41;	author netwolf1;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.08.17.08.25;	author netwolf1;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.05.21.39.50;	author partyckip;	state Exp;
branches;
next	1.38;

1.38
date	2003.04.30.11.37.54;	author kuchin;	state Exp;
branches;
next	1.37;

1.37
date	2003.04.29.08.37.44;	author kuchin;	state Exp;
branches;
next	1.36;

1.36
date	2003.04.22.12.41.51;	author kuchin;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.20.06.03.35;	author kuchin;	state Exp;
branches;
next	1.34;

1.34
date	2003.04.07.14.53.03;	author partyckip;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.29.14.18.45;	author partyckip;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.21.10.52.04;	author recdvst;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2003.03.20.13.42.54;	author obaldin;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.19.08.49.53;	author recdvst;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.19.07.50.59;	author recdvst;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.14.16.24.19;	author partyckip;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.09.16.21.45;	author obaldin;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.05.13.28.51;	author cax2;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.05.11.25.23;	author recdvst;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.01.14.46.56;	author dongato;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.28.18.43.42;	author dongato;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.26.21.33.09;	author obaldin;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.02.20.20.55.52;	author obaldin;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.20.14.29.02;	author dongato;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.16.22.01.47;	author lord_kiron;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.14.14.22.40;	author obaldin;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.12.22.26.41;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.12.20.18.23;	author obaldin;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.11.13.34.05;	author cax2;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.10.13.15.39;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.09.18.39.41;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.06.22.04.15;	author lord_kiron;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.06.21.58.33;	author lord_kiron;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.06.21.54.25;	author lord_kiron;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.06.21.49.08;	author lord_kiron;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.06.20.32.25;	author lord_kiron;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.02.10.47.20;	author cax2;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.01.26.23.46.43;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.24.22.07.48;	author maverick65;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.01.22.17.45.38;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.20;	author cax2;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.28.14.55.44;	author obaldin;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.01.28.22.27.08;	author maverick65;	state Exp;
branches
	1.3.2.2.2.1;
next	1.3.2.3;

1.3.2.3
date	2003.01.29.10.36.29;	author cax2;	state Exp;
branches;
next	;

1.3.2.2.2.1
date	2003.01.28.23.51.14;	author maverick65;	state Exp;
branches;
next	;

1.5.2.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.02.06.19.01.01;	author obaldin;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.02.08.10.10.45;	author obaldin;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.02.08.10.13.39;	author obaldin;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.02.08.13.37.04;	author obaldin;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2003.02.08.17.04.48;	author obaldin;	state Exp;
branches;
next	;

1.21.2.1
date	2003.02.28.22.44.55;	author obaldin;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.03.01.20.59.35;	author obaldin;	state Exp;
branches;
next	;

1.22.2.1
date	2003.02.28.10.48.30;	author dongato;	state Exp;
branches;
next	;

1.32.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2003.03.24.09.39.43;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.295
log
@Cleared cancel transfer flag on remote queue entering otherwise cancel might not be sent for the following OP_ACCEPTUPLOADREQ (within the same socket connection) at file completion time.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "ListenSocket.h"
#include "server.h"
#include "opcodes.h"
#include "KnownFile.h"
#include "ServerList.h"
#include "SharedFileList.h"
#include "UploadQueue.h"
#include "updownclient.h"
#include "ClientList.h"
#include "otherfunctions.h"
#include "IPFilter.h"
#include "SafeFile.h"
#include "packets.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#ifdef OLD_SOCKETS_ENABLED

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CClientReqSocket
CClientReqSocket::CClientReqSocket(CUpDownClient *in_client)
{
	m_pClient = in_client;
	if (in_client)
		m_pClient->m_pRequestSocket = this;
	ResetTimeOutTimer();
	m_bDeleteThis = false;
	m_dwDeleteTimer = 0;
	g_App.m_pListenSocket->AddSocket(this);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CClientReqSocket::~CClientReqSocket()
{
	if (m_pClient != NULL)
	{
		m_pClient->SetHandshakeStatus(false);
		m_pClient->m_pRequestSocket = NULL;
		m_pClient = NULL;
	}
	g_App.m_pListenSocket->RemoveSocket(this);

	DEBUG_ONLY (g_App.m_pClientList->Debug_SocketDeleted(this));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::ResetTimeOutTimer()
{
	m_dwTimeoutTimer = ::GetTickCount();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CheckTimeOut() checks the timeout timer, and, if it has expired, it disconnects the m_pRequestSocket
//	and resets the timeout timer. It returns true if the timer has expired, false if it has not.
bool CClientReqSocket::CheckTimeOut()
{
	uint32	dwCurTicks, dwCurTimeout = CONNECTION_TIMEOUT;

//	Extend timeout for connecting state
	if (m_eConnectionState == ES_CONNECTING)
	{
	//	This socket is still in a half connection state.. Because of SP2, we don't know
	//	if this socket is actually failing, or if this socket is just queued in SP2's new
	//	protection queue. Therefore we give the socket a chance to either finally report
	//	the connection error, or finally make it through SP2's new queued socket system..
		dwCurTimeout = 4 * CONNECTION_TIMEOUT;
	}
	else if (m_pClient != NULL)
	{
	//	Increase socket timeout for DL clients
		if (m_pClient->GetDownloadState() == DS_DOWNLOADING)
			return false;
	//	Extend the timeout to avoid too fast disconnecting of chatting people
		if (m_pClient->GetChatState() == MS_CHATTING)
			dwCurTimeout += 2 * CONNECTION_TIMEOUT;
	}
//	If the timeout period has been exceeded...
	if (((dwCurTicks = ::GetTickCount()) - m_dwTimeoutTimer) > dwCurTimeout)
	{
		m_dwTimeoutTimer = dwCurTicks;	//	Reset the timeout timer
		Disconnect();
		return true;
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::Close()
{
	if (m_pClient != NULL)
		m_pClient->SetHandshakeStatus(false);

	CAsyncSocketEx::Close();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::OnClose(int nErrorCode)
{
	ASSERT (g_App.m_pListenSocket->IsValidSocket(this));
	CEMSocket::OnClose(nErrorCode);
	Disconnect();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::Disconnect()
{
//	Tell the m_pRequestSocket not to receive any more notifications
	AsyncSelect(0);
	m_eConnectionState = ES_DISCONNECTED;
	if (m_pClient != NULL && !g_App.m_pClientList->IsValidClient(m_pClient))
	{
		AddLogLine(LOG_FL_DBG, _T("Invalid client '%s'"), m_pClient->GetUserName());
		m_pClient->SetHandshakeStatus(false);
		m_pClient = NULL;
	}
	if (m_pClient == NULL)
		Safe_Delete();
	else
		m_pClient->Disconnected();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::TimedDelete()
{
//	It seems that MFC Sockets call socketfunctions after they are deleted, even if the m_pRequestSocket is closed
//	and select(0) is set. So we need to wait some time to make sure this doesn't happen.
	if (::GetTickCount() - m_dwDeleteTimer > 10000)
		delete this;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::Safe_Delete()
{
	ASSERT (g_App.m_pListenSocket->IsValidSocket(this));
	AsyncSelect(0);
	m_eConnectionState = ES_DISCONNECTED;
	m_dwDeleteTimer = ::GetTickCount();
	if (m_SocketData.hSocket != INVALID_SOCKET)
		ShutDown(2);
	if (m_pClient != NULL)
	{
		m_pClient->SetHandshakeStatus(false);
		m_pClient->m_pRequestSocket = NULL;
		m_pClient = NULL;
	}
	m_bDeleteThis = true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientReqSocket::ProcessPacket(byte *pbytePacket, uint32 dwPacketSize, EnumOpcodes eOpcode)
{
	EnumDLQState eClientDLState;

	try
	{
		try
		{
			if (m_pClient != NULL)
			{
				if (!m_pClient->IsHandshakeFinished() && eOpcode != OP_HELLOANSWER)
					throw CString(_T("a client asks for something without hello-handshake"));
			}
			else if (eOpcode != OP_HELLO)
			{
				throw CString(_T("a client asks for something without saying hello"));
			}

			switch (eOpcode)
			{
				case OP_HELLOANSWER:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
#if 1
					if ((m_pClient != NULL) && m_pClient->IsHandshakeFinished())
						AddLogLine( LOG_FL_DBG | LOG_RGB_ERROR, _T("Wrong HSA status %s"), m_pClient->GetClientNameWithSoftware());
#endif
					m_pClient->ProcessHelloAnswer(pbytePacket, dwPacketSize);
				//	Start secure identification, if
				//	- we have received OP_EMULEINFO and OP_HELLOANSWER (old eMule)
				//	- we have received eMule-OP_HELLOANSWER (new eMule)
					if ((m_pClient != NULL) && (m_pClient->GetInfoPacketsReceived() == IP_BOTH))
						m_pClient->InfoPacketsReceived();
					if (m_pClient != NULL)
					{
						m_pClient->ConnectionEstablished();
					//	Update of client in Clientlist will lead to GUI update in ClientListCtrl as well as DownloadListCtrl
						g_App.m_pClientList->UpdateClient(m_pClient);
					}
					break;
				}
				case OP_HELLO:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					bool bIsMuleHello, bNewClient = false;
					if (!m_pClient)
					{
					//	Create new client to save standard informations
						m_pClient = new CUpDownClient(this);
						bNewClient = true;
					}

					try
					{
						bIsMuleHello = m_pClient->ProcessHelloPacket(pbytePacket, dwPacketSize);
					}
					catch(...)
					{
						if (bNewClient)
							safe_delete(m_pClient);
						throw CString(_T("unable to process HelloPacket"));
					}
				//	Now we check if we know this client already. If yes this m_pRequestSocket will be attached
				//	to the known client, the new client will be deleted and the var. "client" will point
				//	to the known client. If not we keep our new-constructed client.
					if (g_App.m_pClientList->AttachToAlreadyKnown(&m_pClient, this))
					{
					//	Update the old client informations
						bIsMuleHello = m_pClient->ProcessHelloPacket(pbytePacket, dwPacketSize);
						m_pClient->DisableL2HAC();
						bNewClient = false;
					}
					else
					{
					//	If new client was not created delete him
						if (!g_App.m_pClientList->AddClient(m_pClient))
						{
							safe_delete(m_pClient);
							throw CString(_T("unable to add client in ClientList"));
						}
						m_pClient->SetCommentDirty();
					}

				//	Send a response packet with standard information
					if ((m_pClient->GetHashType() == SO_EMULE) && !bIsMuleHello)
						m_pClient->SendMuleInfoPacket(false);
#if 1
					if ((m_pClient != NULL) && m_pClient->IsHandshakeFinished())
						AddLogLine( LOG_FL_DBG | LOG_RGB_ERROR, _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
#endif

					m_pClient->SendHelloAnswer();
					if (m_pClient != NULL)
						m_pClient->ConnectionEstablished();
					if (m_pClient != NULL)
					{
					//	Start secure identification, if
					//	- we have received eMule-OP_HELLO (new eMule)
						if (m_pClient->GetInfoPacketsReceived() == IP_BOTH)
							m_pClient->InfoPacketsReceived();

					//	Update of client in Clientlist will lead to GUI update in ClientListCtrl as well as DownloadListCtrl
						if (!bNewClient)
							g_App.m_pClientList->UpdateClient(m_pClient);
					}
					break;
				}
				case OP_REQUESTFILENAME:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);

				//	IP banned, no answer for this request
					if (m_pClient->IsBanned())
						break;

				//	If we're filtering scanning (and misbehaving) clients and this client has asked for a
				//	non-existant file more than three times...
					if (g_App.m_pPrefs->IsScanFilterEnabled() && m_pClient->GetFailedFileRequests() >= 3)
					{
					//	Temporarily ban the client from the upload queue
						g_App.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
					//	If we're logging countermeasures...
						if (!g_App.m_pPrefs->IsCMNotLog())
							AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s (IP: %s) added to filtered clients due to file scanning"),
											 m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP() );
						Disconnect();
						break;
					}

				//	Since we don't process extended information it is better for compatibility with
				//	the rest of the network to always process a filehash & extended information
				//	only if the file exists and was activated by tag ET_EXTENDEDREQUEST
					if (dwPacketSize >= 16)
					{
						CKnownFile	*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pbytePacket);

					//	If we are not sharing the requested file...
						if (pKnownFile == NULL)
						{
						//	If we've just started a download we may want to use that client as a source.
						//	Moreover we need to check if the requested file exists in the DL queue
						//	in order to filter the clients correct way.

						//	Look for the requested file in the download queue
							CPartFile		*pPartFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);

						//	If we found the file and it isn't completed...
							if (pPartFile != NULL && pPartFile->IsPartFile())
							{
							//	... and we don't have enough sources already
								if (g_App.m_pPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount())
								{
									g_App.m_pDownloadQueue->CheckAndAddKnownSource(pPartFile, m_pClient);
								}
							}
						//	If we're not currently downloading the requested file...
							else
								m_pClient->UpdateFailedFileRequests();

						//	If the client is using our user hash (hash stealer)
							if (md4cmp(g_App.m_pPrefs->GetUserHash(), m_pClient->GetUserHash()) == 0)
								AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s (IP: %s) is using our userhash"), m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP());
						}
						else	//	If we are sharing the requested file...
						{
							if (pKnownFile->IsLargeFile() && !m_pClient->SupportsLargeFiles())
							{
								AddLogLine( LOG_FL_DBG | LOG_RGB_WARNING, _T("Client '%s' (%s) without 64bit file support requested large file '%s'"),
									m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP(), pKnownFile->GetFileName() );
								break;
							}

						//	If this client is requesting this file for the first time
							if (md4cmp(m_pClient->m_reqFileHash, pbytePacket) != 0)
								m_pClient->SetCommentDirty();
						//	Send filename etc
							m_pClient->ResetFailedFileRequests();
							m_pClient->SetUploadFileID(pbytePacket);

							CSafeMemFile	pktInStrm(pbytePacket + 16, dwPacketSize - 16);

							if (!m_pClient->ProcessExtendedInfo(&pktInStrm, pKnownFile))
							{
								m_pClient->SetWrongFileRequest();

								NoFileReply(pbytePacket);	//	Reply that requested file does not exist
#if 0
								AddLogLine( LOG_FL_DBG | LOG_RGB_WARNING, _T("Mismatched part count on file request '%s' by %s (%s)"),
												pKnownFile->GetFileName(), m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP() );
#endif
								break;
							}
							m_pClient->ResetWrongFileRequest();

						//	... and we're downloading the file... (this could be a new source)
							if (pKnownFile->IsPartFile())
							{
							//	... and we don't have enough sources already
								if (g_App.m_pPrefs->GetMaxSourcePerFile() > static_cast<CPartFile*>(pKnownFile)->GetSourceCount())
								{
									g_App.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);
								}
							}

							CMemFile	packetStream(128);
							CStringA	strEncoded;
							uint16		uNameLength;

							packetStream.Write(pKnownFile->GetFileHash(), 16);

							uNameLength = static_cast<uint16>(Str2MB(m_pClient->GetStrCodingFormat(), &strEncoded, pKnownFile->GetFileName()));
							packetStream.Write(&uNameLength, 2);
							packetStream.Write(strEncoded, uNameLength);

							Packet		*pReplyPacket = new Packet(&packetStream);

							pReplyPacket->m_eOpcode = OP_REQFILENAMEANSWER;
							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pReplyPacket->m_dwSize);
							SendPacket(pReplyPacket, true);
							m_pClient->SendCommentInfo(pKnownFile);
						}
					}
				//	If the packet is too small (malformed)...
					else
					{
						m_pClient->UpdateFailedFileRequests();
						throw CString(_T("invalid packet size"));
					}
					break;
				}
				case OP_FILEREQANSNOFIL:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (dwPacketSize != 16)
						throw CString(_T("invalid packet size"));

				//	If that client doesn't have my file maybe he has another one
					CPartFile	*pPartFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);
					if (pPartFile == NULL)
						break;

				//	Do nothing if no file was requested
					if ((m_pClient == NULL) || (m_pClient->m_pReqPartFile == NULL))
						break;

				//	We try to swap to another file ignoring no needed parts files
					switch (m_pClient->GetDownloadState())
					{
						case DS_CONNECTED:
						case DS_ONQUEUE:
						case DS_NONEEDEDPARTS:
						case DS_LOWID_ON_OTHER_SERVER:
						case DS_LOWTOLOWID:
						{
						//	try to switch the sources in case of A4AF
							if (!m_pClient->SwapToAnotherFile(NULL, A4AF_REMOVE))
								g_App.m_pDownloadQueue->RemoveSource(m_pClient, true);
							else
								g_App.m_pDownloadList->RemoveSource(m_pClient, pPartFile);
							break;
						}
					}
					break;
				}
				case OP_REQFILENAMEANSWER:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);

					CSafeMemFile	packetStream(pbytePacket, dwPacketSize);

					if (m_pClient->ProcessFileHash(packetStream))
						m_pClient->ProcessFileInfo(packetStream);
					break;
				}
				case OP_FILESTATUS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);

					CSafeMemFile	packetStream(pbytePacket, dwPacketSize);

					if (m_pClient->ProcessFileHash(packetStream))
						m_pClient->ProcessFileStatus(packetStream);
					break;
				}
				case OP_STARTUPLOADREQ:
				// The old eMule clients (<0.26) as well as original eDonkey don't send a hash (dwPacketSize is 0)
				// so we will add client to UL-queue anyway, but inside AddClientToQueue() will be checked
				// if any file was requested before.
				{
					CKnownFile	*pKnownFile = NULL;

				//	count only real upload request
					m_pClient->SetLastUpRequest();
					m_pClient->AddAskedCount();

					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (dwPacketSize == 16)
					{
					//	Check if file exits
						pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pbytePacket);
						if (pKnownFile != NULL)
						{
						//	If we are downloading this file, this could be a new source
							if (pKnownFile->IsPartFile())
								if (g_App.m_pPrefs->GetMaxSourcePerFile() > ((CPartFile*)pKnownFile)->GetSourceCount()) //<<--
									g_App.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);

						//	Check to see if this is a new file they are asking for
							if (md4cmp(m_pClient->GetUploadFileID(), pbytePacket) != 0)
								m_pClient->SetCommentDirty();

							m_pClient->ResetFailedFileRequests();
							m_pClient->SetUploadFileID(pbytePacket);
							m_pClient->SendCommentInfo(pKnownFile);
						}
						else
						{
						//	If client still asking for not existing, he is definitely violating eDonkey protocol
							if (!g_App.m_pDownloadQueue->GetFileByID(pbytePacket))
								m_pClient->UpdateFailedFileRequests();

							NoFileReply(pbytePacket);	//	Reply that requested file does not exist
							break;
						}
					}
					else
					{
						pKnownFile = g_App.m_pSharedFilesList->GetFileByID((uchar*)m_pClient->m_reqFileHash);
					}
				//	count only real file request
					if (pKnownFile != NULL)
					{
						pKnownFile->statistic.AddRequest();
						if (!m_pClient->IsOnLAN())
						{
							m_pClient->AddRequestCount((uchar*)m_pClient->m_reqFileHash);
							pKnownFile->AddClientToSourceList(m_pClient);
						}

					//	add file to queue
						g_App.m_pUploadQueue->AddClientToWaitingQueue(m_pClient);

					//	Send a ban message if client tries to enter into the waiting queue
						if (m_pClient->IsBanned() && g_App.m_pPrefs->IsBanMessageEnabled())
							m_pClient->SendBanMessage();
					}
					break;
				}
				case OP_QUEUERANK:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					uint32 rank = PEEK_DWORD(pbytePacket);
					m_pClient->SetRemoteQueueRank(static_cast<uint16>(rank));
					break;
				}
				case OP_ACCEPTUPLOADREQ:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (m_pClient->m_pReqPartFile && g_App.m_pDownloadQueue->IsInDLQueue(m_pClient->m_pReqPartFile))
					{
						eClientDLState = m_pClient->GetDownloadState();
					//	If the client is in our download queue and the part file is downloading/waiting an not paused
					//	Ask for next block while downloading
						if (eClientDLState == DS_DOWNLOADING)
						{
						//	Sometimes remote client sends us OP_ACCEPTUPLOADREQ during DS_DOWNLOADING state
						//	To prevent desynconization of request we will clear the list of pending blocks
							m_pClient->ClearPendingBlocksList();
							m_pClient->SendBlockRequests();
						}
					//	Change the state & request the blocks in following cases:
					//	1) DS_CONNECTED - local client opened the connection & got the download invitation
					//	2) DS_ONQUEUE, DS_WAIT_FOR_FILE_REQUEST - remote client opened the connection & invited us to the download
					//	3) DS_LOWID_ON_OTHER_SERVER - remote LowID client opened the connection & invited us to the download
						else if ( ( eClientDLState == DS_CONNECTED
									|| eClientDLState == DS_ONQUEUE
									|| eClientDLState == DS_WAIT_FOR_FILE_REQUEST
									|| eClientDLState == DS_LOWID_ON_OTHER_SERVER
									|| eClientDLState == DS_LOWTOLOWID )
								&& !m_pClient->m_pReqPartFile->IsPaused()
								&& (m_pClient->m_pReqPartFile->GetStatus() == PS_READY || m_pClient->m_pReqPartFile->GetStatus() == PS_EMPTY))
						{
							m_pClient->SetDownloadState(DS_DOWNLOADING);
							m_pClient->SetLastDownPartAsked(0xFFFF);
							m_pClient->SendBlockRequests();
						}
						else
						{
							m_pClient->SendCancelTransfer();
						//	Don't change a state for client which doesn't have needed parts in order to prevent faster(additional) file status request
							if (eClientDLState != DS_NONEEDEDPARTS)
								m_pClient->SetDownloadState(DS_ONQUEUE);
						}
					}
					else
					{
					//	As a file was complete it isn't in the download list anymore, but our
					//	client is still in the upload queues of many other sources, thus they
					//	can continue inviting us for download. So if a client is in our upload
					//	queue we need to send cancel to close socket faster and avoid source deletion
					//	to keep its position in the queue. If a source isn't in our upload queue
					//	it was probably a full source, so we don't need it anymore.
						if (!m_pClient->m_pReqPartFile && m_pClient->GetAskedCountDown() == 0)
							throw CString(_T("upload was offered before file was requested"));
						else
						{
						//	Let's assume that nonzero ask count means a source which was in our upload
						//	and download queues (if it's only in download queue, it's deleted on completion)
							if (m_pClient->GetAskedCountDown())
								m_pClient->SendCancelTransfer();
							else
								throw CString(_T("wrong fileID sent (!m_pReqPartFile), file: ") + ((m_pClient->m_pReqPartFile != NULL) ? m_pClient->m_pReqPartFile->GetFileName() : _T("NULL")));
						}
					}
					break;
				}
				case OP_REQUESTPARTS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);

					if (!CheckUploadStateForRequestParts())
						break;

					if (dwPacketSize >= 40)	// 16+(3*4)+(3*4)
					{
						Requested_Block_Struct	reqBlock;
						uint32	dwBeg, dwEnd;

						md4cpy(reqBlock.m_fileHash, pbytePacket);

						dwBeg = PEEK_DWORD(pbytePacket + 16);
						dwEnd = PEEK_DWORD(pbytePacket + 16 + 3*4);
						if (dwEnd > dwBeg)
						{
							reqBlock.qwStartOffset = static_cast<uint64>(dwBeg);
							reqBlock.qwEndOffset = static_cast<uint64>(dwEnd);
							m_pClient->AddReqBlock(&reqBlock);
						}

						dwBeg = PEEK_DWORD(pbytePacket + 16 + 4);
						dwEnd = PEEK_DWORD(pbytePacket + 16 + 3*4 + 4);
						if (dwEnd > dwBeg)
						{
							reqBlock.qwStartOffset = static_cast<uint64>(dwBeg);
							reqBlock.qwEndOffset = static_cast<uint64>(dwEnd);
							m_pClient->AddReqBlock(&reqBlock);
						}

						dwBeg = PEEK_DWORD(pbytePacket + 16 + 2*4);
						dwEnd = PEEK_DWORD(pbytePacket + 16 + 3*4 + 2*4);
						if (dwEnd > dwBeg)
						{
							reqBlock.qwStartOffset = static_cast<uint64>(dwBeg);
							reqBlock.qwEndOffset = static_cast<uint64>(dwEnd);
							m_pClient->AddReqBlock(&reqBlock);
						}
					}
					break;
				}
				case OP_CANCELTRANSFER:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					g_App.m_pUploadQueue->RemoveFromUploadQueue(m_pClient, ETS_CANCELED);
					if (g_App.m_pPrefs->IsClientTransferLogEnabled())
						g_App.m_pMDlg->AddLogLine(LOG_FL_DBG, _T("Client %s: upload session ended due to a cancelled transfer"), m_pClient->GetClientNameWithSoftware());
					m_pClient->SetUploadFileID(NULL);
					break;
				}
				case OP_END_OF_DOWNLOAD:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (dwPacketSize >= 16 && !md4cmp(m_pClient->GetUploadFileID(), pbytePacket))
					{
						g_App.m_pUploadQueue->RemoveFromUploadQueue(m_pClient, ETS_END_OF_DOWNLOAD);
						if (g_App.m_pPrefs->IsClientTransferLogEnabled())
							AddLogLine(LOG_FL_DBG, _T("Client %s: upload session ended due to a completed transfer"), m_pClient->GetClientNameWithSoftware());
						m_pClient->SetUploadFileID(NULL);
					}
					break;
				}
				case OP_HASHSETREQUEST:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (dwPacketSize != 16)
						throw CString(_T("invalid packet size"));
					m_pClient->SendHashsetPacket(pbytePacket);
					break;
				}
				case OP_HASHSETANSWER:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					m_pClient->ProcessHashSet(pbytePacket, dwPacketSize);
					break;
				}
				case OP_SENDINGPART:
				{
					m_pClient->UpdateLastBlockReceivedTime();
				//	Before we process the packet we need to check the client's download state.
				//	If the source sends us a packet while we're in an unwanted state (we
				//	haven't made a request) we switch him to an error state
					eClientDLState = m_pClient->GetDownloadState();
				//	If we're uploading to this client
					if (eClientDLState == DS_DOWNLOADING)
					{
						EnumPartFileStatuses	eFileStatus;

					//	If we have made a part file request of this client and the requested file is Waiting...
						if ( (m_pClient->m_pReqPartFile != NULL) &&
							(((eFileStatus = m_pClient->m_pReqPartFile->GetStatus()) == PS_READY) || (eFileStatus == PS_EMPTY)) )
						{
							g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(24);
							if (m_pClient->ProcessBlockPacket(pbytePacket, dwPacketSize, false, false) == 0)
							{
							//	If the file is now in a stopped state (paused/stopped/error)
								if ( (m_pClient->m_pReqPartFile != NULL) &&
									( ((eFileStatus = m_pClient->m_pReqPartFile->GetStatus()) == PS_PAUSED) ||
									(eFileStatus == PS_STOPPED) || (eFileStatus == PS_ERROR) ) )
								{
									m_pClient->SendCancelTransfer();
									m_pClient->SetDownloadState((m_pClient->m_pReqPartFile->IsStopped()) ? DS_NONE : DS_ONQUEUE);
								}
							}
							else
							{
							//	Client deletion was requested
								delete m_pClient;
								m_pClient = NULL;
							}
						}
					//	If we didn't want this file (or don't now)
						else
						{
							g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
							m_pClient->SendCancelTransfer();
							m_pClient->SetDownloadState(((m_pClient->m_pReqPartFile == NULL) || m_pClient->m_pReqPartFile->IsStopped()) ? DS_NONE : DS_ONQUEUE);
						}
					}
					else
					{
						g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					//	After we stop downloading by some reason a client still can continue sending
					//	data for a while -- don't disconnect it with error not to lose the source
						if (!m_pClient->WasCancelTransferSent())
						{
							m_pClient->SetDownloadState(DS_ERROR);
							m_pClient->Disconnected();
						}
					}
					break;
				}
				case OP_OUTOFPARTREQS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (m_pClient->GetDownloadState() == DS_DOWNLOADING)
					{
						m_pClient->UpdateOnqueueDownloadState();
					}
					break;
				}
				case OP_SETREQFILEID:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);

					if (m_pClient->GetFailedFileRequests() >= 3 && g_App.m_pPrefs->IsScanFilterEnabled())
					{
						g_App.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
						if (!g_App.m_pPrefs->IsCMNotLog())
							AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client '%s' (%s) added to filtered clients due to file scanning"),
											 m_pClient->GetFullIP(), m_pClient->GetFullSoftVersionString() );
						Disconnect();
						break;
					}

				//	IP banned, no answer for this request
					if (m_pClient->IsBanned())
						break;

					if (dwPacketSize == 16)
					{
						if (m_pClient->IsWrongFileRequest())
						{
					//	Don't reply to the source after mismatch file request was detected
							Disconnect();
							break;
						}

						CKnownFile	*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pbytePacket);

						if (pKnownFile == NULL)
						{
						//	If we just started a download we may want to use that client as a source.
						//  Moreover we need to check if the requested file exists in the DL queue
						//  in order to filter the clients the correct way.
							CPartFile* pPartFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);
							if (pPartFile && pPartFile->IsPartFile())
							{
								if (g_App.m_pPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount()) //<<--
									g_App.m_pDownloadQueue->CheckAndAddKnownSource(pPartFile, m_pClient);
							}
							else
								m_pClient->UpdateFailedFileRequests();

							NoFileReply(pbytePacket);	//	Send file request no such file
							break;
						}

						if (pKnownFile->IsLargeFile() && !m_pClient->SupportsLargeFiles())
						{
							AddLogLine( LOG_FL_DBG | LOG_RGB_WARNING, _T("Client '%s' (%s) without 64bit file support requested large file '%s'"),
								m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP(), pKnownFile->GetFileName() );
							NoFileReply(pbytePacket);
							break;
						}

					//	Reset Failed Request Counter
						m_pClient->ResetFailedFileRequests();
					//	If we are downloading this file, this could be a new source
						if (pKnownFile->IsPartFile())
							if (g_App.m_pPrefs->GetMaxSourcePerFile() > ((CPartFile*)pKnownFile)->GetSourceCount())
								g_App.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);

					//	Check to see if this is a new file they are asking for
						if (md4cmp(m_pClient->GetUploadFileID(), pbytePacket) != 0)
							m_pClient->SetCommentDirty();

					//	Send filestatus
						m_pClient->SetUploadFileID(pbytePacket);

						CMemFile packetStream(16 + 2 + 58);	// enough for 4GB without reallocation

						packetStream.Write(pKnownFile->GetFileHash(), 16);
						if (pKnownFile->IsPartFile())
							((CPartFile*)pKnownFile)->WritePartStatus(&packetStream);
						else if (pKnownFile->GetJumpstartEnabled())
							pKnownFile->WriteJumpstartPartStatus(m_pClient, &packetStream);
						else if (pKnownFile->HasHiddenParts())
							pKnownFile->WritePartStatus(&packetStream);
						else
						{
							uint32 null = 0;
							packetStream.Write(&null, 2);
						}

						Packet	*replypacket = new Packet(&packetStream);
						replypacket->m_eOpcode = OP_FILESTATUS;
						g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
						SendPacket(replypacket, true);
					}
					else
						throw CString(_T("invalid packet size"));
					break;
				}
				case OP_CHANGE_CLIENT_ID:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					CSafeMemFile packetStream(pbytePacket, dwPacketSize);
					uint32 nNewUserID;
					uint32 nNewServerIP;

					packetStream.Read(&nNewUserID, 4);
					packetStream.Read(&nNewServerIP, 4);
				//	Client changed server and got a LowID
					if (IsLowID(nNewUserID))
					{
						CServer *pNewServer = g_App.m_pServerList->GetServerByIP(nNewServerIP);
						if (pNewServer != NULL)
						{
						// 	Update UserID only if we know the server
							m_pClient->SetUserIDHybrid(nNewUserID);
							m_pClient->SetServerIP(nNewServerIP);
							m_pClient->SetServerPort(pNewServer->GetPort());
						}
					}
				//	Client changed server and got a HighID(IP)
					else if (nNewUserID == m_pClient->GetIP())
					{
						m_pClient->SetUserIDHybrid(fast_ntohl(nNewUserID));
						CServer* pNewServer = g_App.m_pServerList->GetServerByIP(nNewServerIP);
						if (pNewServer != NULL)
						{
							m_pClient->SetServerIP(nNewServerIP);
							m_pClient->SetServerPort(pNewServer->GetPort());
						}
					}
					break;
				}
				case OP_CHANGE_SLOT:	//	Sometimes sent by Hybrid
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					break;
				}
				case OP_MESSAGE:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);

					uint32	dwMsgLen;

					for(;;)
					{
					//	Verify the packet size
						if (dwPacketSize >= 2)
						{
							dwMsgLen = PEEK_WORD(pbytePacket);
							if ((dwMsgLen + 2) == dwPacketSize)
								break;
						}
						throw CString(_T("invalid message packet"));
					}
					if (dwMsgLen > MAX_CLIENT_MSG_LEN)
						dwMsgLen = MAX_CLIENT_MSG_LEN;

					CString		strMessage;

					MB2Str(m_pClient->GetStrCodingFormat(), &strMessage, reinterpret_cast<char*>(pbytePacket + 2), dwMsgLen);
					g_App.m_pMDlg->m_wndChat.m_ctlChatSelector.ProcessMessage(m_pClient, strMessage);
					break;
				}
				case OP_ASKSHAREDFILES:
				{
				//	Client wants to know what we have in share, let's see if we allow him to know that
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);

				//	IP banned, no answer for this request
					if (m_pClient->IsBanned())
						break;

					CPtrList	list;

					if ( g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					  || (g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
					{
						CCKey		bufKey;
						CKnownFile	*cur_file;

						for (POSITION pos = g_App.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != NULL;)
						{
							g_App.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, cur_file);

							if ( ( (cur_file->GetPermissions() == PERM_ALL) ||
								((cur_file->GetPermissions() == PERM_FRIENDS) && m_pClient->IsFriend()) ) &&
								(!cur_file->IsLargeFile() || m_pClient->SupportsLargeFiles()) )
							{
								list.AddTail((void*&)cur_file);
							}
						}
						AddLogLine( LOG_FL_SBAR | LOG_RGB_NOTICE, IDS_REQ_SHAREDFILES,
										 m_pClient->GetClientNameWithSoftware(), GetResString(IDS_ACCEPTED) );
					}
					else
					{
						AddLogLine( LOG_FL_SBAR | LOG_RGB_WARNING, IDS_REQ_SHAREDFILES,
										 m_pClient->GetClientNameWithSoftware(), GetResString(IDS_DENIED) );
					}

				//	Build the reply packet and send it.
					uint32			dwNumFiles = list.GetCount();
					CSafeMemFile	packetStream(256);

					packetStream.Write(&dwNumFiles, 4);
					while (list.GetCount())
					{
						g_App.m_pSharedFilesList->WriteToOfferedFilePacket(reinterpret_cast<CKnownFile*>(list.GetHead()), packetStream, NULL, m_pClient);
						list.RemoveHead();
					}

					Packet		*pReplyPacket = new Packet(&packetStream);

					pReplyPacket->m_eOpcode = OP_ASKSHAREDFILESANSWER;
					g_App.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
					SendPacket(pReplyPacket, true, true);
					break;
				}
				case OP_ASKSHAREDFILESANSWER:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					m_pClient->ProcessSharedFileList(pbytePacket, dwPacketSize);
					break;
				}
				case OP_ASKSHAREDDIRS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					ASSERT(dwPacketSize == 0);

				//	IP banned, no answer for this request
					if (m_pClient->IsBanned())
					{
						break;
					}

					if ( g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					  || (g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
					{
						AddLogLine( LOG_FL_SBAR | LOG_RGB_NOTICE, IDS_SHAREDREQ1, m_pClient->GetClientNameWithSoftware(),
							GetResString(IDS_ACCEPTED) );

						CString		strDir, strTest;

					//	Virtual folder list
						CArray<CString, CString&>	astrFolders;
						CMapStringToString			&mapVDirs = g_App.m_pSharedFilesList->GetSharedVDirForList();
						POSITION					pos = mapVDirs.GetStartPosition();

						while (pos)
						{
							CString		strKey, strDir;

							mapVDirs.GetNextAssoc(pos, strKey, strDir);

							int			i = 0;

							while ((i < astrFolders.GetCount()) && (strKey.CompareNoCase(astrFolders.GetAt(i)) > 0))
								i++;
							astrFolders.InsertAt(i, strKey);
						}

					//	Build the reply packet
						CSafeMemFile		packetStream(80);
						uint32				dwNumDirs = astrFolders.GetCount();

						packetStream.Write(&dwNumDirs, 4);
					//	For each directory in the array...
						for (int ix = 0; ix < astrFolders.GetCount(); ix++)
						{
							const CString		&strDir = astrFolders.GetAt(ix);
							uint16				uCnt = static_cast<uint16>(strDir.GetLength());

							packetStream.Write(&uCnt, 2);
							WriteStr2MB(m_pClient->GetStrCodingFormat(), strDir, packetStream);
						}

						Packet		*pReplyPacket = new Packet(&packetStream);

						pReplyPacket->m_eOpcode = OP_ASKSHAREDDIRSANS;
						g_App.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
						SendPacket(pReplyPacket, true, true);
					}
					else
					{
						AddLogLine( LOG_FL_SBAR | LOG_RGB_WARNING, IDS_SHAREDREQ1, m_pClient->GetClientNameWithSoftware(),
							GetResString(IDS_DENIED) );

						Packet		*pReplyPacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);

						g_App.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
						SendPacket(pReplyPacket, true, true);
					}
					break;
				}
				case OP_ASKSHAREDFILESDIR:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);

				//	IP banned, no answer for this request
					if (m_pClient->IsBanned())
						break;

					CSafeMemFile		packetStream(pbytePacket, dwPacketSize);

					uint16		uDirNameLen;
					packetStream.Read(&uDirNameLen, 2);

					CString		strReqDir, strReqVDir;
					ReadMB2Str(m_pClient->GetStrCodingFormat(), &strReqVDir, packetStream, uDirNameLen);
					PathRemoveBackslash(strReqVDir.GetBuffer());
					strReqVDir.ReleaseBuffer();

				//	Retrieve real dir from virtual dir
					CMapStringToString		&mapVDirs = g_App.m_pSharedFilesList->GetSharedVDirForList();
					BOOL		bReqVDir = mapVDirs.Lookup(strReqVDir, strReqDir);

					if ( (bReqVDir)
					  && ( g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					    || (g_App.m_pPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) ) )
					{
						AddLogLine( LOG_FL_DBG, _T("Client %s requested your list of shared files for directory '%s' ['%s'] (accepted)"),
										 m_pClient->GetClientNameWithSoftware(), strReqVDir, strReqDir );
						ASSERT(packetStream.GetPosition() == packetStream.GetLength());

						CCKey		bufKey;
						CKnownFile	*pKnownFile;

						CTypedPtrList<CPtrList, CKnownFile*>	list;

						for (POSITION pos = g_App.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != NULL;)
						{
							g_App.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);

							CString		strSharedFileDir(pKnownFile->GetPath());

							PathRemoveBackslash(strSharedFileDir.GetBuffer());
							strSharedFileDir.ReleaseBuffer();
							if ( (strReqDir.CompareNoCase(strSharedFileDir) == 0) &&
								((pKnownFile->GetPermissions() == PERM_ALL) || ((pKnownFile->GetPermissions() == PERM_FRIENDS) && m_pClient->IsFriend())) &&
								(!pKnownFile->IsLargeFile() || m_pClient->SupportsLargeFiles()) )
							{
								list.AddTail(pKnownFile);
							}
						}

					//	Currently we are sending each shared directory, even if it does not contain any files.
					//	Because of this we also have to send an empty shared files list..
						CSafeMemFile		packetStream(256);

						uint16		uDirNameLen = static_cast<uint16>(strReqVDir.GetLength());
						packetStream.Write(&uDirNameLen, 2);

						WriteStr2MB(m_pClient->GetStrCodingFormat(), strReqVDir, packetStream);

						uint32		dwNumFiles = list.GetCount();
						packetStream.Write(&dwNumFiles, 4);

						while (list.GetCount())
						{
							g_App.m_pSharedFilesList->WriteToOfferedFilePacket(list.GetHead(), packetStream, NULL, m_pClient);
							list.RemoveHead();
						}

						Packet		*pReplyPacket = new Packet(&packetStream);

						pReplyPacket->m_eOpcode = OP_ASKSHAREDFILESDIRANS;
						g_App.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
						SendPacket(pReplyPacket, true, true);
					}
				//	If the requester isn't allowed to see our shares...
					else
					{
						AddLogLine( LOG_FL_DBG, _T("Client %s requested your list of shared files for directory '%s' ['%s'] (denied)"),
										 m_pClient->GetClientNameWithSoftware(), strReqVDir, strReqDir );

						Packet		*pReplyPacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);

						g_App.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
						SendPacket(pReplyPacket, true, true);
					}
					break;
				}
				case OP_ASKSHAREDDIRSANS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					if (m_pClient->GetFileListRequested() == 1)
					{
						CSafeMemFile		packetStream(pbytePacket, dwPacketSize);

						uint32		dwNumDirs;
						packetStream.Read(&dwNumDirs, 4);

						for (UINT i = 0; i < dwNumDirs; i++)
						{
							uint16		uDirNameLen;
							packetStream.Read(&uDirNameLen, 2);

							CStringA		strEncodedDirName;
							packetStream.Read(strEncodedDirName.GetBuffer(uDirNameLen), uDirNameLen);
							strEncodedDirName.ReleaseBuffer(uDirNameLen);

							CMemFile		packetStream2(128);

							uDirNameLen = static_cast<uint16>(strEncodedDirName.GetLength());
							packetStream2.Write(&uDirNameLen, 2);
							packetStream2.Write(strEncodedDirName.GetString(), uDirNameLen);

							Packet		*pReplyPacket = new Packet(&packetStream2);

							pReplyPacket->m_eOpcode = OP_ASKSHAREDFILESDIR;
							g_App.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
							SendPacket(pReplyPacket, true, true);
						}

						ASSERT(packetStream.GetPosition() == packetStream.GetLength());
						m_pClient->SetFileListRequested(dwNumDirs);
					}
					else
					{
						AddLogLine( LOG_FL_DBG, _T("Client %s sent not requested list of shared directories - ignored"),
										 m_pClient->GetClientNameWithSoftware() );
					}

					break;
				}
				case OP_ASKSHAREDFILESDIRANS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);

					CSafeMemFile	packetStream(pbytePacket, dwPacketSize);
					uint32			dwPos;

				//	Get the directory name length
					uint16		uDirNameLen;
					packetStream.Read(&uDirNameLen, 2);

				//	Get the directory name
					CString		strDirName;
					ReadMB2Str(m_pClient->GetStrCodingFormat(), &strDirName, packetStream, uDirNameLen);
					PathRemoveBackslash(strDirName.GetBuffer());
					strDirName.ReleaseBuffer();

					if (m_pClient->GetFileListRequested() > 0)
					{
						AddLogLine( LOG_FL_DBG, _T("Client %s sent list of shared files for directory '%s'"),
										 m_pClient->GetClientNameWithSoftware(), strDirName );
						dwPos = static_cast<uint32>(packetStream.GetPosition());
						m_pClient->ProcessSharedFileList(pbytePacket + dwPos, dwPacketSize - dwPos, strDirName);
						if (m_pClient->GetFileListRequested() == 0)
						{
							AddLogLine( LOG_FL_DBG, _T("Client %s finished sending list of shared files"),
											 m_pClient->GetClientNameWithSoftware() );
						}
					}
					else
					{
						AddLogLine( LOG_FL_DBG, _T("Client %s sent not requested list of shared files for directory '%s' - ignored"),
										 m_pClient->GetClientNameWithSoftware(), strDirName);
					}
					break;
				}
				case OP_ASKSHAREDDENIEDANS:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					ASSERT(dwPacketSize == 0);
					AddLogLine(LOG_FL_SBAR, IDS_SHAREDREQDENIED, m_pClient->GetClientNameWithSoftware());
					m_pClient->SetFileListRequested(0);
					break;
				}
				default:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
			}
		}
		catch (CFileException *error)
		{
			OUTPUT_DEBUG_TRACE();
			error->Delete();
			throw CString(_T("invalid or corrupted packet received"));
		}
		catch (CMemoryException *error)
		{
			OUTPUT_DEBUG_TRACE();
			error->Delete();
			throw CString(_T("Memory exception"));
		}
	}
	catch (CString error)
	{
		OUTPUT_DEBUG_TRACE();
		if (m_pClient)
		{
			m_pClient->SetDownloadState(DS_ERROR);
			AddLogLine( LOG_FL_DBG | LOG_RGB_INDIAN_RED, _T("Client %s caused eDonkey packet (%s) processing error: %s. Disconnecting client!"),
				m_pClient->GetClientNameWithSoftware(), DbgGetClientTCPOpcode(false, static_cast<byte>(eOpcode)), error );
		}

		Disconnect();
		return false;
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientReqSocket::ProcessExtPacket(byte *pbytePacket, uint32 dwSize, EnumOpcodes opcode, uint32 dwRawSize)
{
	try
	{
		try
		{
			if (m_pClient == NULL)
			{
				g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
				throw CString(_T("unknown client sends extended protocol packet"));
			}

			EnumDLQState eClientDLState = m_pClient->GetDownloadState();

			switch (opcode)
			{
				case OP_MULTIPACKET:
				case OP_MULTIPACKET_EXT:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);

				//	IP banned, no answer for this request
					if (m_pClient->IsBanned())
						break;

				//	If we're filtering scanning (and misbehaving) clients and this client has asked for a
				//	non-existant file more than three times...
					if (g_App.m_pPrefs->IsScanFilterEnabled() && m_pClient->GetFailedFileRequests() >= 3)
					{
					//	Temporarily ban the client from the upload queue
						g_App.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
					//	If we're logging countermeasures...
						if (!g_App.m_pPrefs->IsCMNotLog())
							AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s (IP: %s) added to filtered clients due to file scanning"),
											 m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP() );
						Disconnect();
						break;
					}

					CSafeMemFile	packetStream(pbytePacket, dwSize);
					uint64			qwFileSz;
					uchar			abyteFileHash[16];
					CKnownFile		*pKnownFile;

					packetStream.Read(abyteFileHash, 16);

					if ((pKnownFile = g_App.m_pSharedFilesList->GetFileByID(abyteFileHash)) == NULL)
					{
						if ( ((pKnownFile = g_App.m_pDownloadQueue->GetFileByID(abyteFileHash)) == NULL)
							|| (pKnownFile->GetFileSize() <= PARTSIZE) )
						{
							NoFileReply(abyteFileHash);
							m_pClient->UpdateFailedFileRequests();
							break;
						}
					}
					if (pKnownFile->IsLargeFile() && !m_pClient->SupportsLargeFiles())
					{
						NoFileReply(abyteFileHash);
						AddLogLine( LOG_FL_DBG | LOG_RGB_WARNING, _T("Client '%s' (%s) without 64bit file support requested large file '%s'"),
							m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP(), pKnownFile->GetFileName() );
						break;
					}
					if (opcode == OP_MULTIPACKET_EXT)
					{
						packetStream.Read(&qwFileSz, 8);
						if (qwFileSz != pKnownFile->GetFileSize())
						{
							NoFileReply(abyteFileHash);
							AddLogLine( LOG_FL_DBG | LOG_RGB_WARNING, _T("Size mismatch (%I64u) on requested file '%s' by client '%s' (%s), sending FNF"),
								qwFileSz, pKnownFile->GetFileName(), m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP() );
							break;
						}
					}

				//	If this client is requesting this file for the first time
					if (md4cmp(m_pClient->m_reqFileHash, abyteFileHash) != 0)
						m_pClient->SetCommentDirty();

					m_pClient->ResetFailedFileRequests();
					m_pClient->SetUploadFileID(abyteFileHash);

				//	If we're downloading the file... (this could be a new source)
					if (pKnownFile->IsPartFile())
					{
					//	... and we don't have enough sources already
						if (g_App.m_pPrefs->GetMaxSourcePerFile() > static_cast<CPartFile*>(pKnownFile)->GetSourceCount())
							g_App.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);
					}

					CMemFile	pktOutStrm(256);
					byte		byteSubOpcode;

					pktOutStrm.Write(pKnownFile->GetFileHash(), 16);
					while (packetStream.GetLength() - packetStream.GetPosition())
					{
						packetStream.Read(&byteSubOpcode, 1);
						switch (byteSubOpcode)
						{
							case OP_REQUESTFILENAME:
							{
								if (!m_pClient->ProcessExtendedInfo(&packetStream, pKnownFile))
								{
									m_pClient->SetWrongFileRequest();

									NoFileReply(pKnownFile->GetFileHash());	//	Reply that requested file does not exist
									goto NoMultiPktAns;
								}
								m_pClient->ResetWrongFileRequest();

								CStringA	strEncoded;
								uint16		uNameLength;

								uNameLength = static_cast<uint16>(Str2MB(m_pClient->GetStrCodingFormat(), &strEncoded, pKnownFile->GetFileName()));
								byteSubOpcode = OP_REQFILENAMEANSWER;
								pktOutStrm.Write(&byteSubOpcode, 1);
								pktOutStrm.Write(&uNameLength, 2);
								pktOutStrm.Write(strEncoded, uNameLength);
								break;
							}
							case OP_AICHFILEHASHREQ:
#if 1//temporary until it's implemented
								throw CString(_T("received unsupported AICH request"));
#endif
								break;

							case OP_SETREQFILEID:
								byteSubOpcode = OP_FILESTATUS;
								pktOutStrm.Write(&byteSubOpcode, 1);
								if (pKnownFile->IsPartFile())
									((CPartFile*)pKnownFile)->WritePartStatus(&pktOutStrm);
								else if (pKnownFile->GetJumpstartEnabled())
									pKnownFile->WriteJumpstartPartStatus(m_pClient, &pktOutStrm);
								else if (pKnownFile->HasHiddenParts())
									pKnownFile->WritePartStatus(&pktOutStrm);
								else
								{
									uint32 null = 0;
									pktOutStrm.Write(&null, 2);
								}
								break;

							case OP_REQUESTSOURCES:
							case OP_REQUESTSOURCES2:
							{
								byte	byteRequestedVer = 0;
								uint16	uRequestedOptions = 0;

								if (byteSubOpcode == OP_REQUESTSOURCES2)
								{	// SX2 request contains additional data
									packetStream.Read(&byteRequestedVer, 1);
									packetStream.Read(&uRequestedOptions, 2);
								}
							//	Although this shouldn't happen, it's a just in case to any Mods that mess with version numbers
								if ((byteRequestedVer > 0) || (m_pClient->GetSourceExchange1Version() > 1))
								{
									DWORD		dwTimePassed = ::GetTickCount() - m_pClient->GetLastSrcReqTime() + CONNECTION_LATENCY;
									bool		bNeverAskedBefore = m_pClient->GetLastSrcReqTime() == 0;

									if (
									//	If not complete and file is rare, allow once every 10 minutes
											( pKnownFile->IsPartFile()
												&& ((CPartFile*)pKnownFile)->GetSourceCount() <= RARE_FILE * 2
												&& (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK) )
									//	OR if file is not rare or if file is complete, allow every 90 minutes
											|| (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY) )
									{
										m_pClient->SetLastSrcReqTime();

									//	Source packet is sent separately
										Packet	*pToSend = pKnownFile->CreateSrcInfoPacket(m_pClient, byteRequestedVer, uRequestedOptions);

										if (pToSend != NULL)
										{
											g_App.m_pUploadQueue->AddUpDataOverheadSourceExchange(pToSend->m_dwSize);
											SendPacket(pToSend, true);
										}
									}
								}
								break;
							}
							default:
							{
								CString strError;
								strError.Format(_T("invalid sub opcode %#x received"), byteSubOpcode);
								throw strError;
							}
						}
					}
					if (pktOutStrm.GetLength() > 16)	// more than just hash was added
					{
						Packet	*pReplyPacket = new Packet(&pktOutStrm, OP_EMULEPROT);

						pReplyPacket->m_eOpcode = OP_MULTIPACKETANSWER;
						g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pReplyPacket->m_dwSize);
						SendPacket(pReplyPacket, true);
					}
NoMultiPktAns:
					break;
				}
				case OP_MULTIPACKETANSWER:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);

					CSafeMemFile	packetStream(pbytePacket, dwSize);
					byte			byteSubOpcode;

					if (!m_pClient->ProcessFileHash(packetStream))
						break;

					while ((packetStream.GetLength() - packetStream.GetPosition()) > 0)
					{
						packetStream.Read(&byteSubOpcode, sizeof(byteSubOpcode));

						switch (byteSubOpcode)
						{
							case OP_REQFILENAMEANSWER:
								m_pClient->ProcessFileInfo(packetStream);
								break;

							case OP_FILESTATUS:
								m_pClient->ProcessFileStatus(packetStream);
								break;

							case OP_AICHFILEHASHANS:
#if 1//temporary until it's implemented
								throw CString(_T("received unrequested AICH"));
#endif
								break;

							default:
							{
								CString strError;
								strError.Format(_T("invalid sub opcode %#x received"), byteSubOpcode);
								throw strError;
							}
						}
					}
					break;
				}
				case OP_EMULEINFO:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
					m_pClient->ProcessMuleInfoPacket(pbytePacket, dwSize);
				//	Start secure identification, if
				//  - we have received eD2K and eMule info (old eMule)
					if (m_pClient->GetInfoPacketsReceived() == IP_BOTH)
						m_pClient->InfoPacketsReceived();
					m_pClient->SendMuleInfoPacket(true);
					break;

				case OP_EMULEINFOANSWER:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
					m_pClient->ProcessMuleInfoPacket(pbytePacket, dwSize);
				//	Update of client in the client list
					g_App.m_pClientList->UpdateClient(m_pClient);
				//	Start secure identification, if
				//  - we have received eD2K and eMule info (old eMule)
					if (m_pClient->GetInfoPacketsReceived() == IP_BOTH)
						m_pClient->InfoPacketsReceived();
					break;

				case OP_SECIDENTSTATE:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
					m_pClient->ProcessSecIdentStatePacket(pbytePacket, dwSize);
					if (m_pClient->GetSecureIdentState() == IS_SIGNATURENEEDED)
					{
						m_pClient->SendSignaturePacket();
					}
					else if (m_pClient->GetSecureIdentState() == IS_KEYANDSIGNEEDED)
					{
						m_pClient->SendPublicKeyPacket();
						m_pClient->SendSignaturePacket();
					}
					break;

				case OP_PUBLICKEY:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
					if (!m_pClient->IsBanned())
						m_pClient->ProcessPublicKeyPacket(pbytePacket, dwSize);
					break;

				case OP_SIGNATURE:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
					if (!m_pClient->IsBanned())
						m_pClient->ProcessSignaturePacket(pbytePacket, dwSize);
					break;

				case OP_REQUESTPARTS_I64:
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);

					if (!CheckUploadStateForRequestParts())
						break;

					if (dwSize >= 64)	// = 16+(3*8)+(3*8)
					{
						Requested_Block_Struct	reqBlock;

						md4cpy(reqBlock.m_fileHash, pbytePacket);

						reqBlock.qwStartOffset = PEEK_QWORD(pbytePacket + 16);
						reqBlock.qwEndOffset = PEEK_QWORD(pbytePacket + 16 + 3*8);
						if (reqBlock.qwEndOffset > reqBlock.qwStartOffset)
							m_pClient->AddReqBlock(&reqBlock);

						reqBlock.qwStartOffset = PEEK_QWORD(pbytePacket + 16 + 8);
						reqBlock.qwEndOffset = PEEK_QWORD(pbytePacket + 16 + 3*8 + 8);
						if (reqBlock.qwEndOffset > reqBlock.qwStartOffset)
							m_pClient->AddReqBlock(&reqBlock);

						reqBlock.qwStartOffset = PEEK_QWORD(pbytePacket + 16 + 2*8);
						reqBlock.qwEndOffset = PEEK_QWORD(pbytePacket + 16 + 3*8 + 2*8);
						if (reqBlock.qwEndOffset > reqBlock.qwStartOffset)
							m_pClient->AddReqBlock(&reqBlock);
					}
					break;

				case OP_COMPRESSEDPART:
				case OP_SENDINGPART_I64:
				case OP_COMPRESSEDPART_I64:
					m_pClient->UpdateLastBlockReceivedTime();
				//	Before we process a packet we need to check Download State
				//	If client send us a packet in an unwanted state (we don't request (need) this packet)
				//	we will switch him to error state
					if (eClientDLState == DS_DOWNLOADING)
					{
						EnumPartFileStatuses	eFileStatus;

						if ( (m_pClient->m_pReqPartFile != NULL) &&
							(((eFileStatus = m_pClient->m_pReqPartFile->GetStatus()) == PS_READY) || (eFileStatus == PS_EMPTY)) )
						{
							uint32 dwInc = 16 + 4 + 4;	//24

							if (opcode == OP_COMPRESSEDPART_I64)
								dwInc = 16 + 8 + 4;	//28
							else if (opcode == OP_SENDINGPART_I64)
								dwInc = 16 + 8 + 8;	//32
							g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwInc);
							m_pClient->ProcessBlockPacket( pbytePacket, dwSize,
								(opcode != OP_SENDINGPART_I64) /*compressed*/,
								(opcode != OP_COMPRESSEDPART) /*64bit*/ );
							if ( (m_pClient->m_pReqPartFile != NULL) &&
								( ((eFileStatus = m_pClient->m_pReqPartFile->GetStatus()) == PS_PAUSED) ||
								(eFileStatus == PS_STOPPED) || (eFileStatus == PS_ERROR) ) )
							{
								m_pClient->SendCancelTransfer();
								m_pClient->SetDownloadState((m_pClient->m_pReqPartFile->IsStopped()) ? DS_NONE : DS_ONQUEUE);
							}
						}
						else
						{
							g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);
							m_pClient->SendCancelTransfer();
							m_pClient->SetDownloadState(((m_pClient->m_pReqPartFile == NULL) || m_pClient->m_pReqPartFile->IsStopped()) ? DS_NONE : DS_ONQUEUE);
						}
					}
					else
					{
						g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);
					//	After we stop downloading by some reason a client still can continue sending
					//	data for a while -- don't disconnect it with error not to lose the source
						if (!m_pClient->WasCancelTransferSent())
						{
							m_pClient->SetDownloadState(DS_ERROR);
							m_pClient->Disconnected();
						}
					}
					break;

				case OP_QUEUERANKING:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);
					if (dwSize < 2)
						throw CString(_T("invalid size"));

					uint16 newrank = PEEK_WORD(pbytePacket);

					m_pClient->SetRemoteQueueRank(newrank);
				//	Switch DL state in case newrank != 0
					if ((newrank != 0) && (eClientDLState == DS_DOWNLOADING))
						m_pClient->UpdateOnqueueDownloadState();
				//	Clear the flag on queue entering, otherwise cancel transfer might not be sent for
				//	the following OP_ACCEPTUPLOADREQ (within the same socket connection) at file completion time
					m_pClient->SetSentCancelTransfer(0);
					break;
				}
				case OP_REQUESTSOURCES:
				case OP_REQUESTSOURCES2:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadSourceExchange(dwRawSize);

					CKnownFile	*pKFile;
					byte	*pbytePktPos = pbytePacket, byteRequestedVer = 0;
					uint16	uRequestedOptions = 0;

					if ((opcode == OP_REQUESTSOURCES2) && (dwSize >= 19))
					{	// SX2 request contains additional data
						byteRequestedVer = *pbytePktPos;
						uRequestedOptions = PEEK_WORD(pbytePktPos + 1);
						pbytePktPos += 3;
					}
				//	Original client don't answer if client's SourceExchange Version is less or equal to 1
				//	but I think we need to keep compatibility with old eMule Plus versions
					if ((byteRequestedVer != 0) || (m_pClient->GetSourceExchange1Version() >= 1))
					{
						if (dwSize < static_cast<uint32>(pbytePktPos - pbytePacket + 16))
							throw CString(_T("invalid size"));

					//	First check shared file list, then download list
						if ( ((pKFile = g_App.m_pSharedFilesList->GetFileByID(pbytePktPos)) != NULL) ||
							((pKFile = g_App.m_pDownloadQueue->GetFileByID(pbytePktPos)) != NULL) )
						{
							DWORD		dwTimePassed = ::GetTickCount() - m_pClient->GetLastSrcReqTime() + CONNECTION_LATENCY;
							bool		bNeverAskedBefore = m_pClient->GetLastSrcReqTime() == 0;

							if (
							//	If not complete and file is rare, allow once every 10 minutes
							    ( pKFile->IsPartFile()
							      && ((CPartFile*)pKFile)->GetSourceCount() <= RARE_FILE * 2
							      && (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK) )
							//	OR if file is not rare or if file is complete, allow every 90 minutes
							    || (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY) )
							{
								m_pClient->SetLastSrcReqTime();

								Packet	*tosend = pKFile->CreateSrcInfoPacket(m_pClient, byteRequestedVer, uRequestedOptions);

								if (tosend)
								{
									g_App.m_pUploadQueue->AddUpDataOverheadSourceExchange(tosend->m_dwSize);
									SendPacket(tosend, true, true);
								}
							}
						}
					}
					break;
				}
				case OP_ANSWERSOURCES:
				case OP_ANSWERSOURCES2:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadSourceExchange(dwRawSize);

					CSafeMemFile	packetStream(pbytePacket, dwSize);
					uchar			hash[16];
					byte			byteSXVer;

					if (opcode == OP_ANSWERSOURCES2)
						packetStream.Read(&byteSXVer, 1);
					else
						byteSXVer = m_pClient->GetSourceExchange1Version();
					packetStream.Read(hash, 16);

					CKnownFile		*pKnownFile = g_App.m_pDownloadQueue->GetFileByID(hash);

					if ((pKnownFile != NULL) && pKnownFile->IsPartFile())
					{
					//	Set the client's answer time
						m_pClient->SetLastSrcAnswerTime();
					//	and set the pKnownFile's last answer time
						((CPartFile*)pKnownFile)->SetLastAnsweredTime();
						((CPartFile*)pKnownFile)->AddClientSources(&packetStream, byteSXVer, (opcode == OP_ANSWERSOURCES2), m_pClient);
					}
					break;
				}
				case OP_FILEDESC:
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwRawSize);
					m_pClient->ProcessMuleCommentPacket(pbytePacket, dwSize);
					break;

				default:
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwRawSize);
			}
		}
		catch (CFileException *error)
		{
			OUTPUT_DEBUG_TRACE();
			error->Delete();
			throw CString(_T("invalid or corrupted packet received"));
		}
		catch(CMemoryException *error)
		{
			OUTPUT_DEBUG_TRACE();
			error->Delete();
			throw CString(_T("Memory exception"));
		}
	}
	catch (CString error)
	{
		OUTPUT_DEBUG_TRACE();
		if (m_pClient == NULL)
			AddLogLine(LOG_FL_DBG, _T("A client caused an error or did something bad: %s. Disconnecting client!"), error);
		else
		{
			AddLogLine( LOG_FL_DBG | LOG_RGB_INDIAN_RED, _T("Client %s caused eMule packet (%s) processing error: %s. Disconnecting client!"),
				m_pClient->GetClientNameWithSoftware(), DbgGetClientTCPOpcode(true, static_cast<byte>(opcode)), error );
			m_pClient->SetDownloadState(DS_ERROR);
		}
		Disconnect();
		return false;
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::OnSend(int nErrorCode)
{
	ResetTimeOutTimer();
	CEMSocket::OnSend(nErrorCode);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::OnError(int nErrorCode)
{
	if (m_pClient != NULL)
		AddLogLine( LOG_FL_DBG, _T("Client %s (IP: %s) caused an error: %u. Disconnecting client!"),
						 m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP(), nErrorCode );
	else
		AddLogLine(LOG_FL_DBG, _T("A client caused an error (%u) or did something bad. Disconnecting client!"), nErrorCode);
	Disconnect();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::PacketReceived(Packet* packet)
{
	try
	{
		uint32	dwRawSize = packet->m_dwSize;

		switch (packet->m_byteProtocol)
		{
			case OP_EDONKEYPROT:
				ProcessPacket(reinterpret_cast<byte*>(packet->m_pcBuffer), packet->m_dwSize, packet->m_eOpcode);
				break;
			case OP_PACKEDPROT:
				if (!packet->UnpackPacket())
				{
					ASSERT(false);
					break;
				}
			case OP_EMULEPROT:
				ProcessExtPacket(reinterpret_cast<byte*>(packet->m_pcBuffer), packet->m_dwSize, packet->m_eOpcode, dwRawSize);
				break;
			default:
			//	Lets free the socket from buggy and unknown clients
				if (m_pClient)
					m_pClient->SetDownloadState(DS_ERROR);
				Disconnect();
		}
	}
	catch(...)
	{
		OUTPUT_DEBUG_TRACE();
	//	If we get here, we probably had an access violation
		AddLogLine( LOG_FL_DBG | LOG_RGB_ERROR, _T(__FUNCTION__) _T(": Unknown exception. Protocol=%#02x opcode=%#02x size=%u"),
			(packet != NULL) ? packet->m_byteProtocol : 0, (packet != NULL) ? packet->m_eOpcode : 0, (packet != NULL) ? packet->m_dwSize : 0 );

	//	TODO: This exception handler should definitively be *here*. Though we may get some very
	//	strange socket deletion crashs if we disconnect a client's TCP socket on catching an exception
	//	here. See also comments in 'CAsyncSocketExHelperWindow::WindowProc'
	//	if (m_pClient)
	//		m_pClient->SetDownloadState(DS_ERROR);
	//	Disconnect();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::OnReceive(int nErrorCode)
{
	ResetTimeOutTimer();
	CEMSocket::OnReceive(nErrorCode);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientReqSocket::Create()
{
	g_App.m_pListenSocket->AddConnection();
	return (CAsyncSocketEx::Create(0, SOCK_STREAM, FD_CONNECT | FD_WRITE | FD_READ | FD_CLOSE, g_App.m_pPrefs->GetBindAddrA()) != FALSE);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::SendPacket(Packet *pPacket, bool bDeletePacket/*=true*/, bool bControlPacket/*=true*/)
{
	ResetTimeOutTimer();
	CEMSocket::SendPacket(pPacket, bDeletePacket, bControlPacket);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::OnConnect(int nErrorCode)
{
	CEMSocket::OnConnect(nErrorCode);

	if (nErrorCode == 0)
	{
	//	Socket may have been delayed by SP2 protection, let's make sure it doesn't timeout instantly
		ResetTimeOutTimer();
	}
	else
		Disconnect();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientReqSocket::CheckUploadStateForRequestParts()
{
//	Ignore block request if remote client doesn't download from us
	if (m_pClient->GetUploadState() != US_UPLOADING)
	{
		m_pClient->AddIncorrectBlockRequest();
		if (m_pClient->GetIncorrectBlockRequests() > 3)
		{
			g_App.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
			if (!g_App.m_pPrefs->IsCMNotLog())
				AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client '%s' (%s) added to filtered clients 3 data blocks request in wrong state"),
								m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP());
			Disconnect();
		}
		return false;
	}

	m_pClient->ResetIncorrectBlockRequestCounter();
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientReqSocket::NoFileReply(const byte *pbyteFileHash)
{
	Packet *replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
	md4cpy(replypacket->m_pcBuffer, pbyteFileHash);
	g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
	SendPacket(replypacket, true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	CListenSocket member functions

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CListenSocket constructor
CListenSocket::CListenSocket()
{
	m_iMaxConnectionsReachedCount = 0;
	InterlockedExchange(&m_lNumPendingConnections, 0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CListenSocket::~CListenSocket()
{
	Close();
	KillAllSockets();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CListenSocket::StartListening()
{
	m_bListening = true;

	return (Create(g_App.m_pPrefs->GetPort(), SOCK_STREAM, FD_ACCEPT, g_App.m_pPrefs->GetBindAddrA()) && Listen());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::RestartListening()
{
	m_bListening = true;
	if (InterlockedDecrement(&m_lNumPendingConnections) >= 0)
	{
		OnAccept(0);
	}
	else
	{
		InterlockedExchange(&m_lNumPendingConnections, 0);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::StopListening()
{
	m_bListening = false;
	m_iMaxConnectionsReachedCount++;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static int CALLBACK AcceptConnectionCond(LPWSABUF lpCallerId, LPWSABUF /*lpCallerData*/, LPQOS /*lpSQOS*/, LPQOS /*lpGQOS*/,
								  LPWSABUF /*lpCalleeId*/, LPWSABUF /*lpCalleeData*/, GROUP FAR* /*g*/, DWORD /*dwCallbackData*/)
{
	if (lpCallerId != NULL 
		&& lpCallerId->buf != NULL
		&& lpCallerId->len >= sizeof(SOCKADDR_IN))
	{
		LPSOCKADDR_IN pSockAddr = (LPSOCKADDR_IN)lpCallerId->buf;
		ASSERT( pSockAddr->sin_addr.S_un.S_addr != 0 && pSockAddr->sin_addr.S_un.S_addr != INADDR_NONE );

	//	Since the TCP/IP stack tries to establish the connection 3 times the simple caching of filtered IP will
	//	prevent multiple search in the IP filter table
		if (g_App.m_pIPFilter->IsCachedAndFiltered(pSockAddr->sin_addr.S_un.S_addr))
			return CF_REJECT;
	}

	return CF_ACCEPT;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	OnAccept() is called to notify the request socket that it can accept pending connection requests by calling
//	Accept().
//
// Rejecting a connection with conditional WSAAccept and not using SO_CONDITIONAL_ACCEPT
// -------------------------------------------------------------------------------------
// recv: SYN
// send: SYN ACK (!)
// recv: ACK
// send: ACK RST
// recv: PSH ACK + OP_HELLO packet
// send: RST
// --- 455 total bytes (depending on OP_HELLO packet)
// In case SO_CONDITIONAL_ACCEPT is not used, the TCP/IP stack establishes the connection
// before WSAAccept has a chance to reject it. That's why the remote peer starts to send
// it's first data packet.
// ---
// Not using SO_CONDITIONAL_ACCEPT gives us 6 TCP packets and the OP_HELLO data. We
// have to lookup the IP only 1 time. This is still way less traffic than rejecting the
// connection by closing it after the 'Accept'.

// Rejecting a connection with conditional WSAAccept and using SO_CONDITIONAL_ACCEPT
// ---------------------------------------------------------------------------------
// recv: SYN
// send: ACK RST
// recv: SYN
// send: ACK RST
// recv: SYN
// send: ACK RST
// --- 348 total bytes
// The TCP/IP stack tries to establish the connection 3 times until it gives up. 
// Furthermore the remote peer experiences a total timeout of ~ 1 minute which is
// supposed to be the default TCP/IP connection timeout (as noted in MSDN).
// ---
// Although we get a total of 6 TCP packets in case of using SO_CONDITIONAL_ACCEPT,
// it's still less than not using SO_CONDITIONAL_ACCEPT. But, we have to lookup
// the IP 3 times instead of 1 time.
void CListenSocket::OnAccept(int nErrorCode)
{
	if (nErrorCode == 0)
	{
		InterlockedIncrement(&m_lNumPendingConnections);
	//	If the number of pending connections was less than 0 (which obviously shouldn't happen)...
		InterlockedCompareExchange(&m_lNumPendingConnections, 1, 0);
		if (TooManySockets(true) && !g_App.m_pServerConnect->IsConnecting())
		{
			StopListening();
			return;
		}
		else if (m_bListening == false)
			RestartListening(); //If the client is still at maxconnections, this will allow it to go above it.. But if you don't, you will get a lowID on all servers.

		uint32	dwError, dwFataErrors = 0;

		while (InterlockedDecrement(&m_lNumPendingConnections) >= 0)
		{
			CClientReqSocket	*pNewClientSocket;
			SOCKADDR_IN			sockAddr = {0};
			int					iSockAddrLen = sizeof(sockAddr);
			
			if (g_App.m_pPrefs->GetProxySettings().m_bUseProxy)
			{
				pNewClientSocket = new CClientReqSocket();

				if (!Accept(*pNewClientSocket))
				{
					dwError = ::WSAGetLastError();
					pNewClientSocket->Safe_Delete();
				// check if pending connections were existed
					if (dwError == WSAEWOULDBLOCK)
					{
						AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("WSAGetLastError = WSAEWOULDBLOCK with %u"), m_lNumPendingConnections);
						InterlockedExchange(&m_lNumPendingConnections, 0);
						break;
					}
					else
					{
						AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("WSAGetLastError = %u"), dwError);
						if (++dwFataErrors > 10)
						{
						// the question is what todo on a error. We cant just ignore it because then the backlog will fill up
						// and lock everything. We can also just endlos try to repeat it because this will lock up eMule
						// this should basically never happen anyway
						// however if we are in such a position, try to reinitalize the socket.
							AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Accept() Error Loop"));
							Close();
							StartListening();
							InterlockedExchange(&m_lNumPendingConnections, 0);
							break;
						}
					}
					continue;
				}

				pNewClientSocket->GetPeerName((SOCKADDR*)&sockAddr, &iSockAddrLen);
				if (g_App.m_pIPFilter->IsFiltered(sockAddr.sin_addr.S_un.S_addr))
				{
					InterlockedIncrement(&g_App.m_lIncomingFiltered);
					InterlockedIncrement(&g_App.m_lTotalFiltered);
					pNewClientSocket->Safe_Delete();
					continue;
				}
			}
			else
			{
				SOCKET sNew = WSAAccept(m_SocketData.hSocket, (SOCKADDR*)&sockAddr, &iSockAddrLen, AcceptConnectionCond, 0);

				if (sNew == INVALID_SOCKET)
				{
					dwError = ::WSAGetLastError();
				// check if pending connections were existed
					if (dwError == WSAEWOULDBLOCK)
					{
						AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("WSAGetLastError = WSAEWOULDBLOCK with %u"), m_lNumPendingConnections);
						InterlockedExchange(&m_lNumPendingConnections, 0);
						break;
					}
					else if (dwError == WSAECONNREFUSED)
					{
						InterlockedIncrement(&g_App.m_lIncomingFiltered);
						InterlockedIncrement(&g_App.m_lTotalFiltered);
					}
					else
					{
						AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("WSAGetLastError = %u"), dwError);
						if (++dwFataErrors > 10)
						{
						// the question is what todo on a error. We cant just ignore it because then the backlog will fill up
						// and lock everything. We can also just endlos try to repeat it because this will lock up eMule
						// this should basically never happen anyway
						// however if we are in such a position, try to reinitalize the socket.
							AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Accept() Error Loop"));
							Close();
							StartListening();
							InterlockedExchange(&m_lNumPendingConnections, 0);
							break;
						}
					}
					continue;
				}

				pNewClientSocket = new CClientReqSocket();
				
				VERIFY(pNewClientSocket->InitAsyncSocketExInstance());
				pNewClientSocket->m_SocketData.hSocket=sNew;
				pNewClientSocket->AttachHandle(sNew);
			}

			pNewClientSocket->AsyncSelect(FD_WRITE | FD_READ | FD_CLOSE);
			AddConnection();
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Process() takes care of cleaning up invalid, deleted, and timed out sockets from the open request socket list.
void CListenSocket::Process()
{
	POSITION	pos2;

//	For each open request socket...
	for (POSITION pos1 = m_openSocketList.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		m_openSocketList.GetNext(pos1);

		CClientReqSocket	*pSocket = m_openSocketList.GetAt(pos2);

	//	If the request socket is marked for deletion...
		if (pSocket->m_bDeleteThis)
		{
			if (pSocket->m_SocketData.hSocket != INVALID_SOCKET) // deadlake PROXYSUPPORT - changed to AsyncSocketEx
			{
				pSocket->Close();
			}
			else
			{
				pSocket->TimedDelete();
			}
		}
		else
		{
		//	If the request socket has timed out, disconnect it.
			m_openSocketList.GetAt(pos2)->CheckTimeOut();
		}
	}
//	If we're not currently listening for new connections and we're either just connecting to a server
//	or we're not within 5 connections of max then start listening again.
	if ((GetNumOpenSockets() + 5 < g_App.m_pPrefs->GetMaxConnections() 
		|| g_App.m_pServerConnect->IsConnecting()) && !m_bListening)
	{
		RestartListening();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::AddSocket(CClientReqSocket* toadd)
{
	m_openSocketList.AddTail(toadd);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::RemoveSocket(CClientReqSocket *pSocket)
{
	POSITION	pos;

	pos = m_openSocketList.Find(pSocket);
	if (pos != NULL)
		m_openSocketList.RemoveAt(pos);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	DeleteSocket() schedules the socket 'pSocket' for deletion if it's in the open socket list.
bool CListenSocket::DeleteSocket(CClientReqSocket *pSocket)
{
	bool		bDeleted = false;

	if (pSocket != NULL && IsValidSocket(pSocket))
	{
		pSocket->Safe_Delete();
		bDeleted = true;
	}

	return bDeleted;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::KillAllSockets()
{
	for (POSITION pos = m_openSocketList.GetHeadPosition(); pos != NULL; pos = m_openSocketList.GetHeadPosition())
	{
		CClientReqSocket * cur_socket = m_openSocketList.GetAt(pos);
		if (cur_socket->m_pClient)
			delete cur_socket->m_pClient;
		else
			delete cur_socket;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::AddConnection()
{
// check how many connection was open in last 5 sec
// note: use the while loop to handle the change of _MaxConPerFive_ in case of lower value
	while (m_dwSocketOpenTime.size() >= g_App.m_pPrefs->GetMaxConPerFive())
	{
		m_dwSocketOpenTime.pop_front();
	}
	m_dwSocketOpenTime.push_back(::GetTickCount());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	TooManySockets() returns true if the number of open sockets is greater than the number specified
//	in Preferences. If 'bIgnoreInterval' is false, it will also return true if the number of
//	new connections since the last Process() call is greater than the "connections per 5 secs"
//	setting in Preferences.
bool CListenSocket::TooManySockets(bool bIgnoreInterval)
{
	if (GetNumOpenSockets() > g_App.m_pPrefs->GetMaxConnections())
		return true;
	if (bIgnoreInterval)
		return false;
//	Check how much time was elapsed since first allowed connection within 5 sec was opened
	if (m_dwSocketOpenTime.size() >= g_App.m_pPrefs->GetMaxConPerFive() && (::GetTickCount() - m_dwSocketOpenTime.front()) <= 5000)
		return true;

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsValidSocket() returns true if 'pSocket' is in the open request socket list.
bool CListenSocket::IsValidSocket(CClientReqSocket *pSocket)
{
	return (m_openSocketList.Find(pSocket) != NULL) ? true : false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CListenSocket::Debug_ClientDeleted(CUpDownClient* deleted)
{
	POSITION pos1, pos2;
	for (pos1 = m_openSocketList.GetHeadPosition();(pos2 = pos1) != NULL;)
	{
		m_openSocketList.GetNext(pos1);
		CClientReqSocket* cur_sock = m_openSocketList.GetAt(pos2);
		if (!AfxIsValidAddress(cur_sock, sizeof(CClientReqSocket)))
		{
			AfxDebugBreak();
		}
		if (cur_sock->m_pClient == deleted)
		{
			AfxDebugBreak();
		}
	}
}
#endif //OLD_SOCKETS_ENABLED
@


1.294
log
@Added an option to bind to specific network interface (from original) {Zom}.
@
text
@d1604 3
@


1.293
log
@No file status reply for old banned clients.
@
text
@d1791 1
a1791 1
	return (CAsyncSocketEx::Create(0, SOCK_STREAM, FD_CONNECT | FD_WRITE | FD_READ | FD_CLOSE) != FALSE);
d1865 1
a1865 1
	return(this->Create(g_App.m_pPrefs->GetPort(), SOCK_STREAM, FD_ACCEPT) && this->Listen());
@


1.292
log
@Reduced H-file dependency.
@
text
@d741 4
@


1.291
log
@Reduced H-file dependency.
@
text
@d33 3
@


1.290
log
@Fixed a loss of the connected source on file completion (A4AF source or remote source will lose position in our queue; this was introduced in v1.2e with code restructoring similar to original) {glaskrug}.
@
text
@d32 1
d1422 1
a1422 1
					byte			byteOpcode;
d1429 1
a1429 1
						packetStream.Read(&byteOpcode, sizeof(byteOpcode));
d1431 1
a1431 1
						switch (byteOpcode)
d1450 1
a1450 1
								strError.Format(_T("invalid sub opcode %#x received"), byteOpcode);
@


1.289
log
@Fast byte swap for ntohl and ntohs.
@
text
@d434 2
a435 2
					m_pClient->ProcessFileHash(packetStream);
					m_pClient->ProcessFileInfo(packetStream);
d444 2
a445 2
					m_pClient->ProcessFileHash(packetStream);
					m_pClient->ProcessFileStatus(packetStream);
d824 1
a824 1
						CServer * pNewServer = g_App.m_pServerList->GetServerByIP(nNewServerIP);
d1423 2
a1424 1
					m_pClient->ProcessFileHash(packetStream);
@


1.288
log
@Added full multipacket support.
@
text
@d836 1
a836 1
						m_pClient->SetUserIDHybrid(ntohl(nNewUserID));
@


1.287
log
@Unified ProcessExtendedInfo processing.
@
text
@d1232 184
d1612 2
a1613 2
				//	Original client don't answer if client's SourceExchange Version is less or equal than 1
				//	but i think we need to keep compatibility with old eMule Plus versions
@


1.286
log
@Unified no requested file reply preparation.
@
text
@d342 4
a345 1
							if (!m_pClient->ProcessExtendedInfo(pbytePacket, dwPacketSize, pKnownFile))
d368 3
a370 3
							CSafeMemFile		packetStream(128);
							CStringA			strEncoded;
							uint16				uNameLength;
@


1.285
log
@Reduced H-file dependency.
@
text
@d346 1
a346 5
							//	Reply that requested file does not exist
								Packet *replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
								md4cpy(replypacket->m_pcBuffer, pbytePacket);
								g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
								SendPacket(replypacket, true);
d482 1
a482 5
						//	Reply that requested file does not exist
							Packet *replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							md4cpy(replypacket->m_pcBuffer, pbytePacket);
							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
							SendPacket(replypacket, true);
d759 1
a759 5
						//	Send file request no such file
							Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							md4cpy(replypacket->m_pcBuffer, pbytePacket);
							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
							SendPacket(replypacket, true);
d767 1
a767 4
							Packet *replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							md4cpy(replypacket->m_pcBuffer, pbytePacket);
							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
							SendPacket(replypacket, true);
d1638 8
@


1.284
log
@Reduced H-file dependency.
@
text
@d31 1
@


1.283
log
@Reduced #include dependency.
@
text
@d24 1
@


1.282
log
@Removed old junk.
@
text
@a16 2
//	ListenSocket.cpp : implementation file
//
d29 1
@


1.281
log
@Added multipacket encoding support (helps to combine several packets together for p2p handshaking, as a result slightly reduces overhead and handshaking time) [eklmn/Aw3];
More detailed debug information about received bad packets (received client TCP packets).
@
text
@a1193 6
				case OP_UNKNOWNx6A:
				case OP_UNKNOWNx7A:
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
					break;
				}
a1194 1
				{
a1195 1
				}
@


1.280
log
@More accurate download bandwidth calculation for compressed packets (reported overhead was slightly higher than real).
@
text
@d390 1
a390 1
						throw CString(_T("invalid OP_REQUESTFILENAME packet size (OP_REQUESTFILENAME)"));
d397 14
a410 1
					if (dwPacketSize == 16)
d412 11
a422 3
					//	If that client doesn't have my file maybe he has another one
						CPartFile	*pPartFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);
						if (pPartFile == NULL)
a423 21

					//	Do nothing if no file was requested
						if ((m_pClient == NULL) || (m_pClient->m_pReqPartFile == NULL))
							break;

					//	We try to swap to another file ignoring no needed parts files
						switch (m_pClient->GetDownloadState())
						{
							case DS_CONNECTED:
							case DS_ONQUEUE:
							case DS_NONEEDEDPARTS:
							case DS_LOWID_ON_OTHER_SERVER:
							case DS_LOWTOLOWID:
							{
							//	try to switch the sources in case of A4AF
								if (!m_pClient->SwapToAnotherFile(NULL, A4AF_REMOVE))
									g_App.m_pDownloadQueue->RemoveSource(m_pClient, true);
								else
									g_App.m_pDownloadList->RemoveSource(m_pClient, pPartFile);
								break;
							}
a424 1
						break;
a425 1
					throw CString(_T("invalid OP_REQUESTFILENAME packet size (OP_FILEREQANSNOFIL)"));
d434 1
d444 2
a445 7
					uchar	pcFileHash[16];

					packetStream.Read(pcFileHash, 16);

					CPartFile	*pReqPartFile = g_App.m_pDownloadQueue->GetFileByID(pcFileHash);

					m_pClient->ProcessFileStatus(&packetStream, pReqPartFile);
d571 1
a571 1
							throw CString(_T("client sent OP_ACCEPTUPLOADREQ before file was requested"));
d579 1
a579 1
								throw CString(_T("wrong fileID sent (OP_ACCEPTUPLOADREQ => !m_pReqPartFile), file: ") + ((m_pClient->m_pReqPartFile != NULL) ? m_pClient->m_pReqPartFile->GetFileName() : _T("NULL")));
d652 1
a652 1
						throw CString(_T("invalid OP_HASHSETREQUEST packet size"));
d820 1
a820 1
						throw CString(_T("invalid OP_REQUESTFILENAME packet size (OP_SETREQFILEID)"));
d877 1
a877 1
						throw CString(_T("invalid message packet (OP_MESSAGE)"));
d1206 1
a1206 1
		catch (CFileException * error)
d1212 1
a1212 1
		catch (CMemoryException * error)
d1225 2
a1226 2
			AddLogLine( LOG_FL_DBG, _T("Client %s caused an error: %s. Disconnecting client!"),
							 m_pClient->GetClientNameWithSoftware(), error );
d1251 39
d1422 1
a1422 1
						throw CString(_T("invalid size (OP_QUEUERANKING)"));
d1452 1
a1452 1
							throw CString(_T("invalid size (OP_REQUESTSOURCES)"));
d1539 2
a1540 2
			AddLogLine( LOG_FL_DBG, _T("Client %s caused an error or did something bad: %s. Disconnecting client!"),
							 m_pClient->GetClientNameWithSoftware(), error );
@


1.279
log
@Fixed A4AF sources attached to complete file, plus sometimes incorrect A4AF source count {DonGato/DopeFish/muleteer/Vladimir (SV)/glaskrug}.
@
text
@d1241 1
a1241 1
bool CClientReqSocket::ProcessExtPacket(byte *pbytePacket, uint32 size, EnumOpcodes opcode)
d1249 1
a1249 1
				g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1258 2
a1259 3
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
					m_pClient->ProcessMuleInfoPacket(pbytePacket, size);
d1266 1
a1266 1
				}
d1268 2
a1269 3
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
					m_pClient->ProcessMuleInfoPacket(pbytePacket, size);
d1277 1
a1277 1
				}
d1279 2
a1280 3
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
					m_pClient->ProcessSecIdentStatePacket(pbytePacket, size);
d1291 1
a1291 1
				}
d1293 1
a1293 2
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1295 1
a1295 3
					{
						m_pClient->ProcessPublicKeyPacket(pbytePacket, size);
					}
d1297 1
a1297 1
				}
d1299 1
a1299 2
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1301 1
a1301 3
					{
						m_pClient->ProcessSignaturePacket(pbytePacket, size);
					}
d1303 1
a1303 1
				}
d1305 1
a1305 2
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1310 1
a1310 1
					if (size >= 64)	// = 16+(3*8)+(3*8)
d1332 1
a1332 1
				}
a1335 1
				{
d1354 1
a1354 1
							m_pClient->ProcessBlockPacket( pbytePacket, size,
d1367 1
a1367 1
							g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1374 1
a1374 1
						g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1384 1
a1384 1
				}
d1387 2
a1388 2
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					if (size < 2)
d1402 1
a1402 1
					g_App.m_pDownloadQueue->AddDownDataOverheadSourceExchange(size);
d1408 1
a1408 1
					if ((opcode == OP_REQUESTSOURCES2) && (size >= 19))
d1418 1
a1418 1
						if (size < static_cast<uint32>(pbytePktPos - pbytePacket + 16))
d1453 1
a1453 1
					g_App.m_pDownloadQueue->AddDownDataOverheadSourceExchange(size);
d1455 1
a1455 1
					CSafeMemFile	packetStream(pbytePacket, size);
d1478 2
a1479 3
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					m_pClient->ProcessMuleCommentPacket(pbytePacket, size);
d1481 1
a1481 1
				}
d1483 1
a1483 3
				{
					g_App.m_pDownloadQueue->AddDownDataOverheadOther(size);
				}
d1536 2
d1550 1
a1550 1
				ProcessExtPacket(reinterpret_cast<byte*>(packet->m_pcBuffer), packet->m_dwSize, packet->m_eOpcode);
@


1.278
log
@Simplified logging system implementation.
@
text
@d400 1
a400 1
						CPartFile* pPartFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);
d420 2
@


1.277
log
@Local function made static; Add socket to the list only after it's fully initialized.
@
text
@d128 1
a128 1
		AddDebugLogLine(_T("Invalid client '%s'"), m_pClient->GetUserName());
d188 1
a188 1
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Wrong HSA status %s"), m_pClient->GetClientNameWithSoftware());
d251 1
a251 1
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
d286 1
a286 1
							AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s (IP: %s) added to filtered clients due to file scanning"),
d324 1
a324 1
								AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s (IP: %s) is using our userhash"), m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP());
d330 1
a330 1
								AddDebugLogLine( RGB_LOG_WARNING_TXT _T("Client '%s' (%s) without 64bit file support requested large file '%s'"),
d351 1
a351 1
								AddDebugLogLine( RGB_LOG_WARNING_TXT _T("Mismatched part count on file request '%s' by %s (%s)"),
d636 1
a636 1
						g_App.m_pMDlg->AddDebugLogLine(_T("Client %s: upload session ended due to a cancelled transfer"), m_pClient->GetClientNameWithSoftware());
d647 1
a647 1
							AddDebugLogLine(_T("Client %s: upload session ended due to a completed transfer"), m_pClient->GetClientNameWithSoftware());
d739 1
a739 1
							AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client '%s' (%s) added to filtered clients due to file scanning"),
d780 1
a780 1
							AddDebugLogLine( RGB_LOG_WARNING_TXT _T("Client '%s' (%s) without 64bit file support requested large file '%s'"),
d920 1
a920 1
						AddLogLine( true, RGB_LOG_NOTICE + GetResString(IDS_REQ_SHAREDFILES),
d925 1
a925 1
						AddLogLine( true, RGB_LOG_WARNING + GetResString(IDS_REQ_SHAREDFILES),
d967 1
a967 1
						AddLogLine( true, RGB_LOG_NOTICE + GetResString(IDS_SHAREDREQ1), m_pClient->GetClientNameWithSoftware(),
d1013 1
a1013 1
						AddLogLine( true, RGB_LOG_WARNING + GetResString(IDS_SHAREDREQ1), m_pClient->GetClientNameWithSoftware(),
d1049 1
a1049 1
						AddDebugLogLine( _T("Client %s requested your list of shared files for directory '%s' ['%s'] (accepted)"),
d1101 1
a1101 1
						AddDebugLogLine( _T("Client %s requested your list of shared files for directory '%s' ['%s'] (denied)"),
d1148 1
a1148 1
						AddDebugLogLine( _T("Client %s sent not requested list of shared directories - ignored"),
d1173 1
a1173 1
						AddDebugLogLine( _T("Client %s sent list of shared files for directory '%s'"),
d1179 1
a1179 1
							AddDebugLogLine( _T("Client %s finished sending list of shared files"),
d1185 1
a1185 1
						AddDebugLogLine( _T("Client %s sent not requested list of shared files for directory '%s' - ignored"),
d1194 1
a1194 1
					AddLogLine(true, IDS_SHAREDREQDENIED, m_pClient->GetClientNameWithSoftware());
d1229 1
a1229 1
			AddDebugLogLine( _T("Client %s caused an error: %s. Disconnecting client!"),
d1515 1
a1515 1
			AddDebugLogLine(_T("A client caused an error or did something bad: %s. Disconnecting client!"), error);
d1518 1
a1518 1
			AddDebugLogLine( _T("Client %s caused an error or did something bad: %s. Disconnecting client!"),
d1536 2
a1537 2
	if (m_pClient)
		AddDebugLogLine( _T("Client %s (IP: %s) caused an error: %u. Disconnecting client!"),
d1540 1
a1540 1
		AddDebugLogLine(_T("A client caused an error (%u) or did something bad. Disconnecting client!"), nErrorCode);
d1573 1
a1573 1
		AddDebugLogLine( RGB_LOG_ERROR_TXT _T(__FUNCTION__) _T(": Unknown exception. Protocol=%#02x opcode=%#02x size=%u"),
d1626 1
a1626 1
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client '%s' (%s) added to filtered clients 3 data blocks request in wrong state"),
d1771 1
a1771 1
						AddDebugLogLine(RGB_LOG_ERROR_TXT _T("WSAGetLastError = WSAEWOULDBLOCK with %u"), m_lNumPendingConnections);
d1777 1
a1777 1
						AddDebugLogLine(RGB_LOG_ERROR_TXT _T("WSAGetLastError = %u"), dwError);
d1784 1
a1784 1
							AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Accept() Error Loop"));
d1813 1
a1813 1
						AddDebugLogLine(RGB_LOG_ERROR_TXT _T("WSAGetLastError = WSAEWOULDBLOCK with %u"), m_lNumPendingConnections);
d1824 1
a1824 1
						AddDebugLogLine(RGB_LOG_ERROR_TXT _T("WSAGetLastError = %u"), dwError);
d1831 1
a1831 1
							AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Accept() Error Loop"));
@


1.276
log
@Added multipacket support preparation [eklmn];
Removed meaningless type casting.
@
text
@a47 1
	g_App.m_pListenSocket->AddSocket(this);
d51 1
d1682 1
a1682 1
int CALLBACK AcceptConnectionCond(LPWSABUF lpCallerId, LPWSABUF /*lpCallerData*/, LPQOS /*lpSQOS*/, LPQOS /*lpGQOS*/,
@


1.275
log
@added Unicode support for shared folders/files
@
text
@d431 4
a434 1
					m_pClient->ProcessFileInfo(pbytePacket, dwPacketSize);
d1037 1
a1037 1
					ReadMB2Str(m_pClient->GetStrCodingFormat(), &strReqVDir, packetStream, static_cast<unsigned>(uDirNameLen));
d1167 1
a1167 1
					ReadMB2Str(m_pClient->GetStrCodingFormat(), &strDirName, packetStream, static_cast<unsigned>(uDirNameLen));
@


1.274
log
@Suppressed compiler warnings.
@
text
@d999 1
a999 1
							packetStream.Write(static_cast<LPCTSTR>(strDir), uCnt);
d1034 1
a1034 2
					packetStream.Read(strReqVDir.GetBuffer(uDirNameLen), uDirNameLen);
					strReqVDir.ReleaseBuffer(uDirNameLen);
d1078 1
a1078 1
						packetStream.Write(static_cast<LPCTSTR>(strReqVDir), uDirNameLen);
d1123 3
a1125 6
							CString		strDirName;
							packetStream.Read(strDirName.GetBuffer(uDirNameLen), uDirNameLen);
							strDirName.ReleaseBuffer(uDirNameLen);

							AddDebugLogLine( _T("Client %s shares directory '%s'"),
											 m_pClient->GetClientNameWithSoftware(), strDirName );
d1129 1
a1129 1
							uDirNameLen = static_cast<uint16>(strDirName.GetLength());
d1131 1
a1131 1
							packetStream2.Write(static_cast<LPCTSTR>(strDirName), uDirNameLen);
d1164 1
a1164 2
					packetStream.Read(strDirName.GetBuffer(uDirNameLen), uDirNameLen);
					strDirName.ReleaseBuffer(uDirNameLen);
@


1.273
log
@added Unicode support for filename request
@
text
@d374 1
a374 2
							uNameLength = Str2MB(m_pClient->GetStrCodingFormat(), &strEncoded, pKnownFile->GetFileName());

d521 1
a521 1
					m_pClient->SetRemoteQueueRank(rank);
d867 1
a867 1
					uint16		uMessageLen;
d874 2
a875 2
							uMessageLen = PEEK_WORD(pbytePacket);
							if ((uMessageLen + 2) == dwPacketSize)
d880 2
a881 2
					if (uMessageLen > MAX_CLIENT_MSG_LEN)
						uMessageLen = MAX_CLIENT_MSG_LEN;
d885 1
a885 1
					MB2Str(m_pClient->GetStrCodingFormat(), &strMessage, reinterpret_cast<char*>(pbytePacket + 2), uMessageLen);
d996 1
a996 1
							uint16				uCnt = strDir.GetLength();
d1041 1
a1041 2

					bool		bReqVDir = mapVDirs.Lookup(strReqVDir, strReqDir);
d1076 1
a1076 1
						uint16		uDirNameLen = strReqVDir.GetLength();
d1131 1
a1131 1
							CSafeMemFile		packetStream2(80);
d1133 1
a1133 1
							uDirNameLen = strDirName.GetLength();
d1159 2
a1160 1
					CSafeMemFile		packetStream(pbytePacket, dwPacketSize);
d1177 2
a1178 1
						m_pClient->ProcessSharedFileList(pbytePacket + packetStream.GetPosition(), dwPacketSize - packetStream.GetPosition(), strDirName);
d1966 1
a1966 1
	return m_openSocketList.Find(pSocket);
@


1.272
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d369 2
d374 1
a374 1
							uint16		uNameLength = _tcslen(pKnownFile->GetFileName());
d377 1
a377 1
							packetStream.Write(pKnownFile->GetFileName(), uNameLength);
d379 1
a379 1
							Packet		*replypacket = new Packet(&packetStream);
d381 3
a383 3
							replypacket->m_eOpcode = OP_REQFILENAMEANSWER;
							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
							SendPacket(replypacket, true);
@


1.271
log
@Modified condition checking for valid OP_QUEUERANKING packet to allow removal of 10 useless bytes in future.
@
text
@d882 1
a882 1
					char		*strMessage = new char[uMessageLen + 1];
d884 1
a884 2
					memcpy2(strMessage, pbytePacket + 2, uMessageLen);
					strMessage[uMessageLen] = 0;
a885 1
					delete[] strMessage;
@


1.270
log
@Suppressed level 4 warnings.
@
text
@d1399 1
a1399 1
					if (size != 12)
@


1.269
log
@Reduced #include depedency.
@
text
@d1247 1
a1247 1
			if (!m_pClient)
d1472 2
a1483 2
						if (opcode != OP_ANSWERSOURCES2)
							byteSXVer = m_pClient->GetSourceExchange1Version();
@


1.268
log
@Added Source Exchange 2 support (adapted from original 0.48a).
@
text
@d23 1
@


1.267
log
@Updated Source Exchange Protocol to version 4 (ability to spread encryption capabilities);
Preparation to support Source Exchange 2 (0.48a).
@
text
@d1414 2
a1415 1
					byte	byteRequestedVer = 0;
d1418 6
d1425 2
a1426 2
				//	but i think we need to keep compatibility with old ePlus versions
					if (m_pClient->GetSourceExchangeVersion() >= 1)
d1428 1
a1428 1
						if (size != 16)
d1432 2
a1433 6
						CKnownFile	   *file = g_App.m_pSharedFilesList->GetFileByID(pbytePacket);

						if (!file)
							file = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);

						if (file)
d1440 2
a1441 2
							    ( file->IsPartFile()
							      && ((CPartFile*)file)->GetSourceCount() <= RARE_FILE * 2
d1448 1
a1448 1
								Packet	   *tosend = file->CreateSrcInfoPacket(m_pClient, byteRequestedVer, uRequestedOptions);
d1461 1
a1461 1
 				case OP_ANSWERSOURCES2:
d1473 1
a1473 1
					CKnownFile		*pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);
d1482 2
a1483 2
							byteSXVer = m_pClient->GetSourceExchangeVersion();
						((CPartFile*)pKnownFile)->AddClientSources(&packetStream, byteSXVer, (opcode == OP_ANSWERSOURCES2));
@


1.266
log
@Corrected protection against potential crash; Formatting (else {} isn't after continue;).
@
text
@d1410 1
d1413 4
a1442 1

d1445 1
a1445 1
								Packet	   *tosend = file->CreateSrcInfoPacket(m_pClient);
d1458 1
d1462 3
a1464 2
					CSafeMemFile		packetStream(pbytePacket, size);
					uchar				hash[16];
d1466 2
d1470 1
a1470 1
					CKnownFile			*pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pbytePacket);
d1472 1
a1472 1
					if (pKnownFile != NULL)
d1474 7
a1480 9
						if (pKnownFile->IsPartFile())
						{
						//	Set the client's answer time
							m_pClient->SetLastSrcAnswerTime();
						//	and set the pKnownFile's last answer time
							((CPartFile*)pKnownFile)->SetLastAnsweredTime();
						//	Support Source Exchange v2
							((CPartFile*)pKnownFile)->AddClientSources(&packetStream, m_pClient->GetSourceExchangeVersion());
						}
@


1.265
log
@Formatting.
@
text
@d403 1
a403 1
						if (m_pClient->m_pReqPartFile == NULL)
d407 1
a407 1
						if (m_pClient)
d409 5
a413 1
							switch (m_pClient->GetDownloadState())
d415 4
a418 11
								case DS_CONNECTED:
								case DS_ONQUEUE:
								case DS_NONEEDEDPARTS:
								case DS_LOWID_ON_OTHER_SERVER:
								case DS_LOWTOLOWID:
								{
								//	try to switch the sources in case of A4AF
									if (!m_pClient->SwapToAnotherFile(NULL, A4AF_REMOVE))
										g_App.m_pDownloadQueue->RemoveSource(m_pClient, true);
									break;
								}
d1785 3
a1787 1
				else
d1789 4
a1792 8
					pNewClientSocket->GetPeerName((SOCKADDR*)&sockAddr, &iSockAddrLen);
					if (g_App.m_pIPFilter->IsFiltered(sockAddr.sin_addr.S_un.S_addr))
					{
						InterlockedIncrement(&g_App.m_lIncomingFiltered);
						InterlockedIncrement(&g_App.m_lTotalFiltered);
						pNewClientSocket->Safe_Delete();
						continue;
					}
@


1.264
log
@Newly added stuff was renamed according to the original for easier reference.
@
text
@d1747 1
a1747 1
		uint32 dwFataErrors = 0;
d1751 4
a1754 5
			CClientReqSocket* pNewClientSocket;
			uint32 dwError;
			SOCKADDR_IN sockAddr = {0};
			int iSockAddrLen = sizeof(sockAddr);

d1766 1
a1766 1
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("WSAGetLastError() = WSAEWOULDBLOCK with %u"),m_lNumPendingConnections);
d1772 2
a1773 3
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("WSAGetLastError() = %u"), dwError);
						dwFataErrors++;
						if (dwFataErrors > 10)
d1779 1
a1779 1
							AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Accept() Error Loop"));
d1790 1
a1790 1
					pNewClientSocket->GetPeerName((SOCKADDR*) & sockAddr, &iSockAddrLen);
d1810 1
a1810 1
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("WSAGetLastError() = WSAEWOULDBLOCK with %u"),m_lNumPendingConnections);
d1821 2
a1822 3
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("WSAGetLastError() = %u"), dwError);
						dwFataErrors++;
						if (dwFataErrors > 10)
d1828 1
a1828 1
							AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Accept() Error Loop"));
@


1.263
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d841 1
a841 1
							m_pClient->SetHybridUserID(nNewUserID);
d847 1
a847 1
	 				else if (nNewUserID == m_pClient->GetIP())
d849 1
a849 1
						m_pClient->SetHybridUserID(ntohl(nNewUserID));
@


1.262
log
@Fixed source loss at the time of unexpected downloading disconnection {muleteer}.
@
text
@d830 2
a832 1
					uint32 nNewServerIP;
d835 1
a835 1
					if (nNewUserID < 0x1000000)
d841 1
a841 1
							m_pClient->SetUserID(nNewUserID);
d846 2
a847 2
 					//	Client changed server and got a HighID(IP)
 	 					else if (nNewUserID == m_pClient->GetIP())
d849 1
a849 1
						m_pClient->SetUserID(nNewUserID);
@


1.261
log
@Modified constructors to avoid potential compiling issue due to type collision.
@
text
@d710 7
a716 2
						m_pClient->SetDownloadState(DS_ERROR);
						m_pClient->Disconnected();
d1387 7
a1393 2
						m_pClient->SetDownloadState(DS_ERROR);
						m_pClient->Disconnected();
@


1.260
log
@improved filtering of incomming connections (less traffic & CPU load)
@
text
@d1010 1
a1010 1
						Packet		*pReplyPacket = new Packet(OP_ASKSHAREDDENIEDANS);
d1100 1
a1100 1
						Packet		*pReplyPacket = new Packet(OP_ASKSHAREDDENIEDANS);
d1532 1
a1532 1
		switch (packet->m_eProtocol)
d1558 1
a1558 1
			(packet != NULL) ? packet->m_eProtocol : 0, (packet != NULL) ? packet->m_eOpcode : 0, (packet != NULL) ? packet->m_dwSize : 0 );
@


1.259
log
@performance optimization (double search & sorting) over prevention of GUI update for new (fresh added) clients
@
text
@d187 1
a187 1
						AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
d1666 19
d1687 34
d1727 1
a1727 5
		if (InterlockedCompareExchange(&m_lNumPendingConnections, 1, 0) == 0)
		{
			//ASSERT(false);
			//m_lNumPendingConnections = 1;
		}
d1736 2
d1740 6
a1745 5
			//m_lNumPendingConnections--;
			CClientReqSocket* pNewClientSocket = new CClientReqSocket();
			if (!Accept(*pNewClientSocket))
				pNewClientSocket->Safe_Delete();
			else
d1747 3
a1749 7
			//	Filter clients that are violating the protocol
				SOCKADDR_IN sockAddr;
				memzero(&sockAddr, sizeof(sockAddr));
				uint32 nSockAddrLen = sizeof(sockAddr);
				pNewClientSocket->GetPeerName((SOCKADDR*) & sockAddr, (int*) & nSockAddrLen);
				uint32 UserIP = sockAddr.sin_addr.S_un.S_addr;
				if (g_App.m_pIPFilter->IsFiltered(UserIP))
d1751 1
a1751 2
					InterlockedIncrement(&g_App.m_lIncomingFiltered);
					InterlockedIncrement(&g_App.m_lTotalFiltered);
d1753 25
d1781 8
a1788 1
					pNewClientSocket->AsyncSelect(FD_WRITE | FD_READ | FD_CLOSE);
d1791 47
@


1.258
log
@Modified log message to show error code value.
@
text
@d232 1
d264 2
a265 1
						g_App.m_pClientList->UpdateClient(m_pClient);
@


1.257
log
@Some checking code for file block requests was moved to a separate function.
@
text
@d1522 1
a1522 1
		AddDebugLogLine(_T("A client caused an error or did something bad: CClientReqSocket::OnError. Disconnecting client!"));
@


1.256
log
@Fixed large file block request packet {xalbux/Fuxie - DK}.
@
text
@d588 1
a588 12
				// ignore block request if remote client does not downloading from us
					if (m_pClient->GetUploadState() != US_UPLOADING)
					{
						m_pClient->AddIncorrectBlockRequest();
						if (m_pClient->GetIncorrectBlockRequests() > 3)
						{
							g_App.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
							if (!g_App.m_pPrefs->IsCMNotLog())
								AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client '%s' (%s) added to filtered clients 3 data blocks request in wrong state"),
												m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP());
							Disconnect();
						}
a589 3
					}

					m_pClient->ResetIncorrectBlockRequestCounter();
d591 1
a591 1
					if (dwPacketSize >= 40)	// OP_REQUESTPARTS = 16+(3*4)+(3*4)
d593 1
a593 1
						Requested_Block_Struct		reqBlock;
d1311 1
a1311 12
				// ignore block request if remote client does not downloading from us
					if (m_pClient->GetUploadState() != US_UPLOADING)
					{
						m_pClient->AddIncorrectBlockRequest();
						if (m_pClient->GetIncorrectBlockRequests() > 3)
						{
							g_App.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
							if (!g_App.m_pPrefs->IsCMNotLog())
								AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client '%s' (%s) added to filtered clients 3 data blocks request in wrong state"),
												m_pClient->GetClientNameWithSoftware(), m_pClient->GetFullIP());
							Disconnect();
						}
a1312 3
					}

					m_pClient->ResetIncorrectBlockRequestCounter();
d1316 1
a1316 1
						Requested_Block_Struct		reqBlock;
d1496 1
a1496 1
		if (!m_pClient)
d1499 1
a1501 1
		if (m_pClient)
d1503 1
d1598 21
@


1.255
log
@Disabled log message related to mismatched parts;
Corrected rare remote LowID state change (mostly for old clients).
@
text
@a584 1
				case OP_REQUESTPARTS_I64:
d608 1
d612 3
a614 1
						if (eOpcode == OP_REQUESTPARTS_I64)
d616 3
a618 17
							if (dwPacketSize >= 64)	// = 16+(3*8)+(3*8)
							{
								reqBlock.qwStartOffset = PEEK_QWORD(pbytePacket + 16);
								reqBlock.qwEndOffset = PEEK_QWORD(pbytePacket + 16 + 3*8);
								if (reqBlock.qwEndOffset > reqBlock.qwStartOffset)
									m_pClient->AddReqBlock(&reqBlock);

								reqBlock.qwStartOffset = PEEK_QWORD(pbytePacket + 16 + 8);
								reqBlock.qwEndOffset = PEEK_QWORD(pbytePacket + 16 + 3*8 + 8);
								if (reqBlock.qwEndOffset > reqBlock.qwStartOffset)
									m_pClient->AddReqBlock(&reqBlock);

								reqBlock.qwStartOffset = PEEK_QWORD(pbytePacket + 16 + 2*8);
								reqBlock.qwEndOffset = PEEK_QWORD(pbytePacket + 16 + 3*8 + 2*8);
								if (reqBlock.qwEndOffset > reqBlock.qwStartOffset)
									m_pClient->AddReqBlock(&reqBlock);
							}
d620 4
a623 1
						else
d625 4
a628 1
							uint32	dwBeg, dwEnd;
d630 7
a636 26
							dwBeg = PEEK_DWORD(pbytePacket + 16);
							dwEnd = PEEK_DWORD(pbytePacket + 16 + 3*4);
							if (dwEnd > dwBeg)
							{
								reqBlock.qwStartOffset = static_cast<uint64>(dwBeg);
								reqBlock.qwEndOffset = static_cast<uint64>(dwEnd);
								m_pClient->AddReqBlock(&reqBlock);
							}

							dwBeg = PEEK_DWORD(pbytePacket + 16 + 4);
							dwEnd = PEEK_DWORD(pbytePacket + 16 + 3*4 + 4);
							if (dwEnd > dwBeg)
							{
								reqBlock.qwStartOffset = static_cast<uint64>(dwBeg);
								reqBlock.qwEndOffset = static_cast<uint64>(dwEnd);
								m_pClient->AddReqBlock(&reqBlock);
							}

							dwBeg = PEEK_DWORD(pbytePacket + 16 + 2*4);
							dwEnd = PEEK_DWORD(pbytePacket + 16 + 3*4 + 2*4);
							if (dwEnd > dwBeg)
							{
								reqBlock.qwStartOffset = static_cast<uint64>(dwBeg);
								reqBlock.qwEndOffset = static_cast<uint64>(dwEnd);
								m_pClient->AddReqBlock(&reqBlock);
							}
d1321 44
@


1.254
log
@Changed prototype.
@
text
@d347 1
d350 1
d1405 1
a1405 1
						m_pClient->SetDownloadState(DS_ONQUEUE);
@


1.253
log
@Stop communication with a source after mismatch file request.
@
text
@d965 1
a965 1
						g_App.m_pSharedFilesList->WriteToOfferedFilePacket(*static_cast<CKnownFile*>(list.GetHead()), packetStream, NULL, m_pClient);
d1119 1
a1119 1
							g_App.m_pSharedFilesList->WriteToOfferedFilePacket(*list.GetHead(), packetStream, NULL, m_pClient);
@


1.252
log
@Faster processing of remote part status packets (eliminated double search in the shared files list);
Don't add sources with mismatch part count to downloading (as well as stop communication with such sources);
Unified packet buffer type; Formatting and cleanup;
Slightly optimized processing of several packets.
@
text
@a316 1
							{
a317 1
							}
d323 1
a323 2
					//	If we are sharing the requested file...
						else
d340 2
d351 1
d775 7
@


1.251
log
@Processing of large file size support packets;
On file request add a source to the download queue only after everything was checked;
Don't allow wrap-around file block requests anymore;
Minor optimization of the previous file block request code.
@
text
@d162 1
a162 1
bool CClientReqSocket::ProcessPacket(char *pcPacketBuf, uint32 dwPacketSize, EnumOpcodes eOpcode)
d189 1
a189 1
					m_pClient->ProcessHelloAnswer(pcPacketBuf, dwPacketSize);
d216 1
a216 1
						bIsMuleHello = m_pClient->ProcessHelloPacket(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d230 1
a230 1
						bIsMuleHello = m_pClient->ProcessHelloPacket(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d294 1
a294 5
						uchar		requestedFileHash[16];

						md4cpy(requestedFileHash, pcPacketBuf);

						CKnownFile	*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(requestedFileHash);
d304 1
a304 1
							CPartFile		*pPartFile = g_App.m_pDownloadQueue->GetFileByID(requestedFileHash);
d336 1
a336 1
							if (md4cmp(m_pClient->m_reqFileHash, pcPacketBuf) != 0)
d340 12
a351 4
							m_pClient->SetUploadFileID(reinterpret_cast<BYTE*>(pcPacketBuf));
						//	TODO: Don't let 'ProcessUpFileStatus' re-process the entire pcPacketBuf and search the fileid
						//	again in 'm_pSharedFilesList' -> waste of time.
							m_pClient->ProcessUpFileStatus(pcPacketBuf, dwPacketSize);
d372 1
a372 1
							Packet		*pcPacketBuf = new Packet(&packetStream);
d374 3
a376 3
							pcPacketBuf->m_eOpcode = OP_REQFILENAMEANSWER;
							g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pcPacketBuf->m_dwSize);
							SendPacket(pcPacketBuf, true);
d394 1
a394 1
						CPartFile* pPartFile = g_App.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
d428 1
a428 1
					m_pClient->ProcessFileInfo(pcPacketBuf, dwPacketSize);
d435 1
a435 1
					CSafeMemFile	packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d460 2
a461 4
						uchar requestedFileHash[16];
						md4cpy(requestedFileHash, pcPacketBuf);
					//check if file exits
						pKnownFile = g_App.m_pSharedFilesList->GetFileByID(requestedFileHash);
d470 1
a470 1
							if (md4cmp(m_pClient->GetUploadFileID(), pcPacketBuf) != 0)
d474 1
a474 1
							m_pClient->SetUploadFileID((uchar*)pcPacketBuf);
d480 1
a480 1
							if (!g_App.m_pDownloadQueue->GetFileByID(requestedFileHash))
d484 2
a485 2
							Packet * replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							md4cpy(replypacket->m_pcBuffer, pcPacketBuf);
a509 1
						{
a510 1
						}
d517 1
a517 2
					uint32 rank;
					memcpy2(&rank, pcPacketBuf, 4);
d608 1
a608 1
						md4cpy(reqBlock.m_fileHash, pcPacketBuf);
d614 2
a615 2
								reqBlock.qwStartOffset = PEEK_QWORD(pcPacketBuf + 16);
								reqBlock.qwEndOffset = PEEK_QWORD(pcPacketBuf + 16 + 3*8);
d619 2
a620 2
								reqBlock.qwStartOffset = PEEK_QWORD(pcPacketBuf + 16 + 8);
								reqBlock.qwEndOffset = PEEK_QWORD(pcPacketBuf + 16 + 3*8 + 8);
d624 2
a625 2
								reqBlock.qwStartOffset = PEEK_QWORD(pcPacketBuf + 16 + 2*8);
								reqBlock.qwEndOffset = PEEK_QWORD(pcPacketBuf + 16 + 3*8 + 2*8);
d634 2
a635 2
							dwBeg = PEEK_DWORD(pcPacketBuf + 16);
							dwEnd = PEEK_DWORD(pcPacketBuf + 16 + 3*4);
d643 2
a644 2
							dwBeg = PEEK_DWORD(pcPacketBuf + 16 + 4);
							dwEnd = PEEK_DWORD(pcPacketBuf + 16 + 3*4 + 4);
d652 2
a653 2
							dwBeg = PEEK_DWORD(pcPacketBuf + 16 + 2*4);
							dwEnd = PEEK_DWORD(pcPacketBuf + 16 + 3*4 + 2*4);
d676 1
a676 1
					if (dwPacketSize >= 16 && !md4cmp(m_pClient->GetUploadFileID(), pcPacketBuf))
d690 1
a690 1
					m_pClient->SendHashsetPacket(pcPacketBuf);
d696 1
a696 1
					m_pClient->ProcessHashSet(pcPacketBuf, dwPacketSize);
d716 1
a716 1
							if (m_pClient->ProcessBlockPacket(pcPacketBuf, dwPacketSize, false, false) == 0)
d775 1
a775 1
						CKnownFile	*pKnownFile = g_App.m_pSharedFilesList->GetFileByID((uchar*)pcPacketBuf);
d782 1
a782 1
							CPartFile* pPartFile = g_App.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
d791 1
a791 1
						//	Send file request no such file pcPacketBuf (0x48)
d793 1
a793 1
							md4cpy(replypacket->m_pcBuffer, pcPacketBuf);
d804 1
a804 1
							md4cpy(replypacket->m_pcBuffer, pcPacketBuf);
d818 1
a818 1
						if (md4cmp(m_pClient->GetUploadFileID(), pcPacketBuf) != 0)
d822 1
a822 1
						m_pClient->SetUploadFileID((uchar*)pcPacketBuf);
d839 4
a842 4
						Packet* pcPacketBuf = new Packet(&packetStream);
						pcPacketBuf->m_eOpcode = OP_FILESTATUS;
						g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pcPacketBuf->m_dwSize);
						SendPacket(pcPacketBuf, true);
d851 1
a851 1
					CSafeMemFile packetStream((BYTE*)pcPacketBuf, dwPacketSize);
d897 1
a897 1
							uMessageLen = PEEK_WORD(pcPacketBuf);
d908 1
a908 1
					memcpy2(strMessage, pcPacketBuf + 2, uMessageLen);
d972 1
a972 1
					m_pClient->ProcessSharedFileList(pcPacketBuf, dwPacketSize);
d1053 1
a1053 1
					CSafeMemFile		packetStream(reinterpret_cast<uchar*>(pcPacketBuf), dwPacketSize);
d1140 1
a1140 1
						CSafeMemFile		packetStream(reinterpret_cast<uchar*>(pcPacketBuf), dwPacketSize);
d1185 1
a1185 1
					CSafeMemFile		packetStream(reinterpret_cast<uchar*>(pcPacketBuf), dwPacketSize);
d1202 1
a1202 1
						m_pClient->ProcessSharedFileList(pcPacketBuf + packetStream.GetPosition(), dwPacketSize - packetStream.GetPosition(), strDirName);
d1265 1
a1265 1
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, EnumOpcodes opcode)
d1284 1
a1284 1
					m_pClient->ProcessMuleInfoPacket(reinterpret_cast<BYTE*>(packet), size);
d1295 1
a1295 1
					m_pClient->ProcessMuleInfoPacket(reinterpret_cast<BYTE*>(packet), size);
d1307 1
a1307 1
					m_pClient->ProcessSecIdentStatePacket(reinterpret_cast<BYTE*>(packet), size);
d1324 1
a1324 1
						m_pClient->ProcessPublicKeyPacket((uchar*)packet, size);
d1333 1
a1333 1
						m_pClient->ProcessSignaturePacket((uchar*)packet, size);
d1359 1
a1359 1
							m_pClient->ProcessBlockPacket( packet, size,
d1390 3
a1392 2
					uint16 newrank;
					memcpy2(&newrank, packet, 2);
d1395 1
a1395 1
					if (newrank && eClientDLState == DS_DOWNLOADING)
d1410 1
a1410 1
						CKnownFile	   *file = g_App.m_pSharedFilesList->GetFileByID((uchar*)packet);
d1413 1
a1413 1
							file = g_App.m_pDownloadQueue->GetFileByID((uchar*)packet);
d1447 1
a1447 1
					CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(packet), size);
d1452 1
a1452 1
					CKnownFile			*pKnownFile = g_App.m_pDownloadQueue->GetFileByID(reinterpret_cast<BYTE*>(packet));
d1471 1
a1471 1
					m_pClient->ProcessMuleCommentPacket(packet, size);
d1497 1
a1497 1
			AddDebugLogLine(_T("A client caused an error or did something bad: %s. Disconnecting client!"), error.GetBuffer());
d1500 1
a1500 1
							 m_pClient->GetClientNameWithSoftware(), error.GetBuffer() );
d1532 1
a1532 1
				ProcessPacket(packet->m_pcBuffer, packet->m_dwSize, packet->m_eOpcode);
d1541 1
a1541 1
				ProcessExtPacket(packet->m_pcBuffer, packet->m_dwSize, packet->m_eOpcode);
@


1.250
log
@Fixed position loss of some sources in our upload queue after file completion
(numerous debug log messages related to OP_ACCEPTUPLOADREQ were about that).
@
text
@a272 1
					{
a273 1
					}
d332 1
a332 2
						//	... and we're downloading the file... (this could be a new source)
							if (pKnownFile->IsPartFile())
d334 3
a336 5
							//	... and we don't have enough sources already
								if (g_App.m_pPrefs->GetMaxSourcePerFile() > static_cast<CPartFile*>(pKnownFile)->GetSourceCount())
								{
									g_App.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);
								}
a340 1
							{
a341 1
							}
d349 10
d584 1
d605 1
a605 1
					if (dwPacketSize == 40)	// 40 = 16+(3*4)+(3*4)
d611 51
a661 14
						reqBlock.qwStartOffset = static_cast<uint64>(PEEK_DWORD(pcPacketBuf + 16));
						reqBlock.qwEndOffset = static_cast<uint64>(PEEK_DWORD(pcPacketBuf + 16 + 3*4));
						if ((reqBlock.qwEndOffset - reqBlock.qwStartOffset) != 0)
							m_pClient->AddReqBlock(&reqBlock);

						reqBlock.qwStartOffset = static_cast<uint64>(PEEK_DWORD(pcPacketBuf + 16 + 4));
						reqBlock.qwEndOffset = static_cast<uint64>(PEEK_DWORD(pcPacketBuf + 16 + 3*4 + 4));
						if ((reqBlock.qwEndOffset - reqBlock.qwStartOffset) != 0)
							m_pClient->AddReqBlock(&reqBlock);

						reqBlock.qwStartOffset = static_cast<uint64>(PEEK_DWORD(pcPacketBuf + 16 + 2*4));
						reqBlock.qwEndOffset = static_cast<uint64>(PEEK_DWORD(pcPacketBuf + 16 + 3*4 + 2*4));
						if ((reqBlock.qwEndOffset - reqBlock.qwStartOffset) != 0)
							m_pClient->AddReqBlock(&reqBlock);
d800 11
a921 1
					{
a922 1
					}
d936 3
a938 1
							if ( (cur_file->GetPermissions() == PERM_ALL) || ((cur_file->GetPermissions() == PERM_FRIENDS) && m_pClient->IsFriend()) )
a1051 1
					{
a1052 1
					}
d1091 3
a1093 2
							if (strReqDir.CompareNoCase(strSharedFileDir) == 0
								&& (pKnownFile->GetPermissions() == PERM_ALL) || ((pKnownFile->GetPermissions() == PERM_FRIENDS) && m_pClient->IsFriend()))
d1257 1
a1257 1
							 m_pClient->GetClientNameWithSoftware(), error.GetBuffer() );
a1337 1

d1339 2
d1353 10
a1362 2
							g_App.m_pDownloadQueue->AddDownDataOverheadFileRequest(24);
							m_pClient->ProcessBlockPacket(packet, size, true, false);
@


1.249
log
@Corrected download state change for remote LowID sources.
@
text
@d164 1
a164 1
	EnumDLQState enumClientDLState;
a520 1
					enumClientDLState = m_pClient->GetDownloadState();
d524 1
d527 1
a527 1
						if (enumClientDLState == DS_DOWNLOADING)
d538 5
a542 5
						else if ( ( enumClientDLState == DS_CONNECTED
									|| enumClientDLState == DS_ONQUEUE
									|| enumClientDLState == DS_WAIT_FOR_FILE_REQUEST
									|| enumClientDLState == DS_LOWID_ON_OTHER_SERVER
									|| enumClientDLState == DS_LOWTOLOWID )
d554 1
a554 1
							if (enumClientDLState != DS_NONEEDEDPARTS)
d559 7
d569 9
a577 1
							throw CString(_T("wrong fileID sent (OP_ACCEPTUPLOADREQ => !m_pReqPartFile), file: ") + ((m_pClient->m_pReqPartFile != NULL) ? m_pClient->m_pReqPartFile->GetFileName() : _T("NULL")));
d665 1
a665 1
					enumClientDLState = m_pClient->GetDownloadState();
d667 1
a667 1
					if (enumClientDLState == DS_DOWNLOADING)
d1227 1
a1227 1
			EnumDLQState enumClientDLState = m_pClient->GetDownloadState();
d1294 1
a1294 1
					if (enumClientDLState == DS_DOWNLOADING)
d1335 1
a1335 1
					if (newrank && enumClientDLState == DS_DOWNLOADING)
@


1.248
log
@Simplified/speeded up processing of partfile status.
@
text
@d700 1
a700 1
						m_pClient->SetDownloadState(DS_ONQUEUE);
@


1.247
log
@Large file size support preparations.
@
text
@d544 1
a544 1
								&& (m_pClient->m_pReqPartFile->GetStatus(false) == PS_READY || m_pClient->m_pReqPartFile->GetStatus(false) == PS_EMPTY))
@


1.246
log
@Renamed DS_LOWTOLOWIP -> DS_LOWTOLOWID.
@
text
@d592 3
a594 4
						reqBlock.m_dwStartOffset = *reinterpret_cast<uint32*>(pcPacketBuf + 16);
						reqBlock.m_dwEndOffset = *reinterpret_cast<uint32*>(pcPacketBuf + 16 + 3*4);
						if ((reqBlock.m_dwEndOffset - reqBlock.m_dwStartOffset) != 0)
						{
a595 1
						}
d597 3
a599 4
						reqBlock.m_dwStartOffset = *reinterpret_cast<uint32*>(pcPacketBuf + 16 + 4);
						reqBlock.m_dwEndOffset = *reinterpret_cast<uint32*>(pcPacketBuf + 16 + 3*4 + 4);
						if ((reqBlock.m_dwEndOffset - reqBlock.m_dwStartOffset) != 0)
						{
a600 1
						}
d602 3
a604 4
						reqBlock.m_dwStartOffset = *reinterpret_cast<uint32*>(pcPacketBuf + 16 + 2*4);
						reqBlock.m_dwEndOffset = *reinterpret_cast<uint32*>(pcPacketBuf + 16 + 3*4 + 2*4);
						if ((reqBlock.m_dwEndOffset - reqBlock.m_dwStartOffset) != 0)
						{
a605 1
						}
@


1.245
log
@Comment.
@
text
@d404 1
a404 1
								case DS_LOWTOLOWIP:
d542 1
a542 1
									|| enumClientDLState == DS_LOWTOLOWIP )
@


1.244
log
@improved timeout processing on XP SP2
@
text
@d251 1
d1521 1
a1521 1
	//This socket may have been delayed by SP2 protection, lets make sure it doesn't time out instantly.
@


1.243
log
@change the detection of local LowID; added OnConnect()
@
text
@d77 10
a86 1
	if (m_pClient != NULL)
@


1.242
log
@Removed unused code.
@
text
@d1496 1
a1496 1
	return (CAsyncSocketEx::Create(0, SOCK_STREAM, FD_WRITE | FD_READ | FD_CLOSE) != FALSE);
d1505 13
@


1.241
log
@Improved string processing.
@
text
@d96 1
a96 1
void CClientReqSocket:: Close( )
a1639 23
void CListenSocket::RecalculateStats()
{
	memzero(m_ConnectionStates, 6);
	POSITION pos1, pos2;
	for (pos1 = m_openSocketList.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		m_openSocketList.GetNext(pos1);
		CClientReqSocket* cur_sock = m_openSocketList.GetAt(pos2);
		switch (cur_sock->GetConState())
		{
			case ES_DISCONNECTED:
			m_ConnectionStates[0]++;
			break;
			case ES_NOTCONNECTED:
			m_ConnectionStates[1]++;
			break;
			case ES_CONNECTED:
			m_ConnectionStates[2]++;
			break;
		}
	}
}

a1667 1

@


1.240
log
@roll back some changes for handshaking feature
@
text
@d178 1
a178 1
						AddDebugLogLine( RGB_LOG_ERROR + _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
d240 1
a240 1
						AddDebugLogLine( RGB_LOG_ERROR + _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
@


1.239
log
@prevent data exchange before hello-handshake will be finished (forgotten part)
@
text
@a175 2
					if (m_pClient)
					{
d177 2
a178 2
						if (m_pClient->IsHandshakeFinished())
							AddDebugLogLine( RGB_LOG_ERROR + _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
d180 8
a187 7
						m_pClient->ProcessHelloAnswer(pcPacketBuf, dwPacketSize);
					//	Start secure identification, if
					//	- we have received OP_EMULEINFO and OP_HELLOANSWER (old eMule)
					//	- we have received eMule-OP_HELLOANSWER (new eMule)
						if (m_pClient->GetInfoPacketsReceived() == IP_BOTH)
							m_pClient->InfoPacketsReceived();

d235 3
a237 5
					if (m_pClient)
					{
					//	Send a response packet with standard information
						if ((m_pClient->GetHashType() == SO_EMULE) && !bIsMuleHello)
							m_pClient->SendMuleInfoPacket(false);
d239 2
a240 2
						if (m_pClient->IsHandshakeFinished())
							AddDebugLogLine( RGB_LOG_ERROR + _T("Wrong HS status %s"), m_pClient->GetClientNameWithSoftware());
d242 5
a246 2
						m_pClient->SendHelloAnswer();

d252 2
a253 1
						m_pClient->ConnectionEstablished();
a254 3

				//	Update of client in Clientlist will lead to GUI update in ClientListCtrl as well as DownloadListCtrl
					g_App.m_pClientList->UpdateClient(m_pClient);
@


1.238
log
@prevent data exchange before hello-handshake will be finished
@
text
@d96 8
d119 1
a122 1
	{
a123 1
	}
d125 1
a125 4
	{
		if (m_pClient->Disconnected())
			m_pClient = NULL;
	}
d140 1
d145 2
d148 2
a149 2
	m_pClient = NULL;
	m_eConnectionState = ES_DISCONNECTED;
@


1.237
log
@Improved chat timeout handling to keep the same connection timeout (as before)
while extending timeout to keep active session alive.
@
text
@d56 2
d59 2
a60 1
	m_pClient = NULL;
d154 6
a159 1
			if (m_pClient == NULL && eOpcode != OP_HELLO)
a168 6
					m_pClient->ProcessHelloAnswer(pcPacketBuf, dwPacketSize);
				//	Start secure identification, if
				//	- we have received OP_EMULEINFO and OP_HELLOANSWER (old eMule)
				//	- we have received eMule-OP_HELLOANSWER (new eMule)
					if (m_pClient && (m_pClient->GetInfoPacketsReceived() == IP_BOTH))
						m_pClient->InfoPacketsReceived();
d171 11
a228 10
				//	Update of client in Clientlist will lead to GUI update in ClientListCtrl as well as DownloadListCtrl
					g_App.m_pClientList->UpdateClient(m_pClient);

				//	Send a response packet with standard information
					if ((m_pClient->GetHashType() == SO_EMULE) && !bIsMuleHello)
						m_pClient->SendMuleInfoPacket(false);

					m_pClient->SendHelloAnswer();
					if (m_pClient)
						m_pClient->ConnectionEstablished();
d231 9
d244 2
d247 3
@


1.236
log
@Minor preparations for 64bit file support.
@
text
@d80 2
a81 2
		if (m_pClient->GetChatState() != MS_NONE)
			dwCurTimeout += CONNECTION_TIMEOUT;
@


1.235
log
@Fixed timeout processing for chat session (timeout only in case when both sides don't send anything).
@
text
@d635 1
a635 1
							if (m_pClient->ProcessBlockPacket(pcPacketBuf, dwPacketSize) == 0)
d1261 1
a1261 1
							m_pClient->ProcessBlockPacket(packet, size, true);
@


1.234
log
@Improve timeout processing for open chat sessions.
@
text
@a1415 1

d1436 1
a1436 1
					ASSERT (false);
d1477 6
@


1.233
log
@1) keep ban reason information (part 1 - logic)
2) disable incoming FR for LowID if file was paused
@
text
@d66 1
a66 1
};
d72 11
a82 3
//	increase socket timeout for DL clients
	 if (m_pClient != NULL && m_pClient->GetDownloadState() == DS_DOWNLOADING)
	 	return false;
d84 1
a84 1
	if (::GetTickCount() - m_dwTimeoutTimer > CONNECTION_TIMEOUT)
d86 1
a86 2
	//	Reset the timeout timer
		m_dwTimeoutTimer = ::GetTickCount();
d91 1
a91 1
};
d98 1
a98 1
};
d119 1
a119 1
};
@


1.232
log
@Removed nesting of the same try/catch.
@
text
@d463 6
@


1.231
log
@AFAF fixes (see change log)
@
text
@d1333 2
a1334 3
					try
					{
						CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(packet), size);
d1336 1
a1336 1
						uchar				hash[16];
d1338 1
a1338 1
						packetStream.Read(hash, 16);
d1340 3
a1342 3
						CKnownFile			*pKnownFile = g_App.m_pDownloadQueue->GetFileByID(reinterpret_cast<BYTE*>(packet));

						if (pKnownFile != NULL)
d1344 6
a1349 9
							if (pKnownFile->IsPartFile())
							{
							//	Set the client's answer time
								m_pClient->SetLastSrcAnswerTime();
							//	and set the pKnownFile's last answer time
								((CPartFile*)pKnownFile)->SetLastAnsweredTime();
							//	Support Source Exchange v2
								((CPartFile*)pKnownFile)->AddClientSources(&packetStream, m_pClient->GetSourceExchangeVersion());
							}
a1351 6
					catch (CFileException * error)
					{
						OUTPUT_DEBUG_TRACE();
						error->Delete();
						throw CString(_T("invalid or corrupted packet received"));
					}
@


1.230
log
@Clean-up.
@
text
@d368 1
a368 1
									if (!m_pClient->SwapToAnotherFile(NULL, true))
@


1.229
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@a1567 2
	//	if (TooManySockets(true) && !g_eMuleApp.m_pServerConnect->IsConnecting())
	//	StopListening();
a1568 1

@


1.228
log
@renamed 3 variables
@
text
@d240 1
a240 1
					if (g_App.g_pPrefs->IsScanFilterEnabled() && m_pClient->GetFailedFileRequests() >= 3)
d245 1
a245 1
						if (!g_App.g_pPrefs->IsCMNotLog())
d277 1
a277 1
								if (g_App.g_pPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount())
d289 1
a289 1
							if (md4cmp(g_App.g_pPrefs->GetUserHash(), m_pClient->GetUserHash()) == 0)
d299 1
a299 1
								if (g_App.g_pPrefs->GetMaxSourcePerFile() > static_cast<CPartFile*>(pKnownFile)->GetSourceCount())
d422 1
a422 1
								if (g_App.g_pPrefs->GetMaxSourcePerFile() > ((CPartFile*)pKnownFile)->GetSourceCount()) //<<--
d531 1
a531 1
							if (!g_App.g_pPrefs->IsCMNotLog())
d574 1
a574 1
					if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d585 1
a585 1
						if (g_App.g_pPrefs->IsClientTransferLogEnabled())
d669 1
a669 1
					if (m_pClient->GetFailedFileRequests() >= 3 && g_App.g_pPrefs->IsScanFilterEnabled())
d672 1
a672 1
						if (!g_App.g_pPrefs->IsCMNotLog())
d691 1
a691 1
								if (g_App.g_pPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount()) //<<--
d709 1
a709 1
							if (g_App.g_pPrefs->GetMaxSourcePerFile() > ((CPartFile*)pKnownFile)->GetSourceCount())
d822 2
a823 2
					if ( g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					  || (g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
d881 2
a882 2
					if ( g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					  || (g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
d967 2
a968 2
					  && ( g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					    || (g_App.g_pPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) ) )
d1498 1
a1498 1
	return(this->Create(g_App.g_pPrefs->GetPort(), SOCK_STREAM, FD_ACCEPT) && this->Listen());
d1606 1
a1606 1
	if ((GetNumOpenSockets() + 5 < g_App.g_pPrefs->GetMaxConnections() 
d1681 1
a1681 1
	while (m_dwSocketOpenTime.size() >= g_App.g_pPrefs->GetMaxConPerFive())
d1694 1
a1694 1
	if (GetNumOpenSockets() > g_App.g_pPrefs->GetMaxConnections())
d1699 1
a1699 1
	if (m_dwSocketOpenTime.size() >= g_App.g_pPrefs->GetMaxConPerFive() && (::GetTickCount() - m_dwSocketOpenTime.front()) <= 5000)
@


1.227
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d47 1
a47 1
	g_eMuleApp.m_pListenSocket->AddSocket(this);
d58 1
a58 1
	g_eMuleApp.m_pListenSocket->RemoveSocket(this);
d60 1
a60 1
	DEBUG_ONLY (g_eMuleApp.m_pClientList->Debug_SocketDeleted(this));
d88 1
a88 1
	ASSERT (g_eMuleApp.m_pListenSocket->IsValidSocket(this));
d98 1
a98 1
	if (m_pClient != NULL && !g_eMuleApp.m_pClientList->IsValidClient(m_pClient))
d124 1
a124 1
	ASSERT (g_eMuleApp.m_pListenSocket->IsValidSocket(this));
d153 1
a153 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d164 1
a164 1
						g_eMuleApp.m_pClientList->UpdateClient(m_pClient);
d170 1
a170 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d192 1
a192 1
					if (g_eMuleApp.m_pClientList->AttachToAlreadyKnown(&m_pClient, this))
d201 1
a201 1
						if (!g_eMuleApp.m_pClientList->AddClient(m_pClient))
d210 1
a210 1
					g_eMuleApp.m_pClientList->UpdateClient(m_pClient);
d230 1
a230 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d240 1
a240 1
					if (g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled() && m_pClient->GetFailedFileRequests() >= 3)
d243 1
a243 1
						g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
d245 1
a245 1
						if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d261 1
a261 1
						CKnownFile	*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(requestedFileHash);
d271 1
a271 1
							CPartFile		*pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(requestedFileHash);
d277 1
a277 1
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount())
d279 1
a279 1
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource(pPartFile, m_pClient);
d289 1
a289 1
							if (md4cmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), m_pClient->GetUserHash()) == 0)
d299 1
a299 1
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > static_cast<CPartFile*>(pKnownFile)->GetSourceCount())
d301 1
a301 1
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);
d329 1
a329 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pcPacketBuf->m_dwSize);
d344 1
a344 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d348 1
a348 1
						CPartFile* pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
d369 1
a369 1
										g_eMuleApp.m_pDownloadQueue->RemoveSource(m_pClient, true);
d381 1
a381 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d387 1
a387 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d395 1
a395 1
					CPartFile	*pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pcFileHash);
d411 1
a411 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d417 1
a417 1
						pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(requestedFileHash);
d422 2
a423 2
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)pKnownFile)->GetSourceCount()) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);
d436 1
a436 1
							if (!g_eMuleApp.m_pDownloadQueue->GetFileByID(requestedFileHash))
d442 1
a442 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
d449 1
a449 1
						pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_pClient->m_reqFileHash);
d462 1
a462 1
						g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(m_pClient);
d468 1
a468 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d477 2
a478 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					if (m_pClient->m_pReqPartFile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(m_pClient->m_pReqPartFile))
d522 1
a522 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d530 2
a531 2
							g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
							if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d572 4
a575 4
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(m_pClient, ETS_CANCELED);
					if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
						g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("Client %s: upload session ended due to a cancelled transfer"), m_pClient->GetClientNameWithSoftware());
d581 1
a581 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d584 2
a585 2
						g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(m_pClient, ETS_END_OF_DOWNLOAD);
						if (g_eMuleApp.m_pGlobPrefs->IsClientTransferLogEnabled())
d593 1
a593 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d601 1
a601 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d621 1
a621 1
							g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(24);
d643 1
a643 1
							g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d650 1
a650 1
						g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d658 1
a658 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d667 1
a667 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d669 1
a669 1
					if (m_pClient->GetFailedFileRequests() >= 3 && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled())
d671 2
a672 2
						g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
						if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d681 1
a681 1
						CKnownFile	*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pcPacketBuf);
d688 1
a688 1
							CPartFile* pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
d691 2
a692 2
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount()) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource(pPartFile, m_pClient);
d700 1
a700 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
d709 2
a710 2
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)pKnownFile)->GetSourceCount())
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)pKnownFile, m_pClient);
d736 1
a736 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pcPacketBuf->m_dwSize);
d745 1
a745 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d754 1
a754 1
						CServer * pNewServer = g_eMuleApp.m_pServerList->GetServerByIP(nNewServerIP);
d767 1
a767 1
						CServer* pNewServer = g_eMuleApp.m_pServerList->GetServerByIP(nNewServerIP);
d778 1
a778 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(dwPacketSize);
d783 1
a783 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d805 1
a805 1
					g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlChatSelector.ProcessMessage(m_pClient, strMessage);
d812 1
a812 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d822 2
a823 2
					if ( g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					  || (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
d828 1
a828 1
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != NULL;)
d830 1
a830 1
							g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, cur_file);
d853 1
a853 1
						g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*static_cast<CKnownFile*>(list.GetHead()), packetStream, NULL, m_pClient);
d860 1
a860 1
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
d866 1
a866 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d872 1
a872 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d881 2
a882 2
					if ( g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					  || (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
d891 1
a891 1
						CMapStringToString			&mapVDirs = g_eMuleApp.m_pSharedFilesList->GetSharedVDirForList();
d925 1
a925 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
d935 1
a935 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
d942 1
a942 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d962 1
a962 1
					CMapStringToString		&mapVDirs = g_eMuleApp.m_pSharedFilesList->GetSharedVDirForList();
d967 2
a968 2
					  && ( g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY
					    || (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) ) )
d979 1
a979 1
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != NULL;)
d981 1
a981 1
							g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
d1008 1
a1008 1
							g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*list.GetHead(), packetStream, NULL, m_pClient);
d1015 1
a1015 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
d1026 1
a1026 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
d1033 1
a1033 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d1062 1
a1062 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
d1079 1
a1079 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d1114 1
a1114 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d1123 1
a1123 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d1128 1
a1128 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
d1169 1
a1169 1
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1179 1
a1179 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1190 1
a1190 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1193 1
a1193 1
					g_eMuleApp.m_pClientList->UpdateClient(m_pClient);
d1202 1
a1202 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1217 1
a1217 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1226 1
a1226 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1247 1
a1247 1
							g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(24);
d1259 1
a1259 1
							g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1266 1
a1266 1
						g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1274 1
a1274 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1287 1
a1287 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadSourceExchange(size);
d1296 1
a1296 1
						CKnownFile	   *file = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)packet);
d1299 1
a1299 1
							file = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
d1321 1
a1321 1
									g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(tosend->m_dwSize);
d1331 1
a1331 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadSourceExchange(size);
d1341 1
a1341 1
						CKnownFile			*pKnownFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(reinterpret_cast<BYTE*>(packet));
d1366 1
a1366 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d1372 1
a1372 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1471 1
a1471 1
	g_eMuleApp.m_pListenSocket->AddConnection();
d1498 1
a1498 1
	return(this->Create(g_eMuleApp.m_pGlobPrefs->GetPort(), SOCK_STREAM, FD_ACCEPT) && this->Listen());
d1533 1
a1533 1
		if (TooManySockets(true) && !g_eMuleApp.m_pServerConnect->IsConnecting())
d1555 1
a1555 1
				if (g_eMuleApp.m_pIPFilter->IsFiltered(UserIP))
d1557 2
a1558 2
					InterlockedIncrement(&g_eMuleApp.m_lIncomingFiltered);
					InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);
d1606 2
a1607 2
	if ((GetNumOpenSockets() + 5 < g_eMuleApp.m_pGlobPrefs->GetMaxConnections() 
		|| g_eMuleApp.m_pServerConnect->IsConnecting()) && !m_bListening)
d1681 1
a1681 1
	while (m_dwSocketOpenTime.size() >= g_eMuleApp.m_pGlobPrefs->GetMaxConPerFive())
d1694 1
a1694 1
	if (GetNumOpenSockets() > g_eMuleApp.m_pGlobPrefs->GetMaxConnections())
d1699 1
a1699 1
	if (m_dwSocketOpenTime.size() >= g_eMuleApp.m_pGlobPrefs->GetMaxConPerFive() && (::GetTickCount() - m_dwSocketOpenTime.front()) <= 5000)
@


1.226
log
@Unicode corrections {KuSh}.
@
text
@d610 1
a610 1
				//	haven't made a request) we switch him to an error state.
d612 2
a613 2
				//	If we're uploading to this client or there are already too many connections...
					if (enumClientDLState == DS_DOWNLOADING || enumClientDLState == DS_TOOMANYCONNS)
d1239 2
a1240 2
				//	we will switch him to error state.
					if (enumClientDLState == DS_DOWNLOADING || enumClientDLState == DS_TOOMANYCONNS)
@


1.225
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1451 2
a1452 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("%s: Unknown exception. Protocol=%#02x opcode=%#02x size=%u"), __FUNCTION__, packet != NULL ? packet->m_eProtocol : 0, packet != NULL ? packet->m_eOpcode : 0, packet != NULL ? packet->m_dwSize : 0);
@


1.224
log
@Added missed download data overhead statistics;
Added disconnection on reception of unexpected data packet [eklmn].
@
text
@d349 1
a349 1
						if (!pPartFile)
d353 1
a353 1
						if (!m_pClient->m_pReqPartFile)
d365 1
d496 2
a497 1
									|| enumClientDLState == DS_LOWID_ON_OTHER_SERVER )
@


1.223
log
@One more step to integrate eklmn's SSDQ;
Increased initial stream size to avoid memory reallocation for file status packet.
@
text
@d619 1
d641 1
d647 2
d650 2
a1233 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(24);
d1245 1
d1257 1
d1263 2
d1266 2
@


1.222
log
@new way of queue handling
@
text
@d358 1
d364 1
d372 1
d488 8
a495 2
					//	Ask while connecting, but don't ask for paused files
						else if ( (enumClientDLState == DS_CONNECTED || enumClientDLState == DS_ONQUEUE)
d710 3
a712 1
						CSafeMemFile packetStream(16 + 16);
@


1.221
log
@1. QR highlighting
2. output "Queue Full" if eMule client did not send QR
3. possible download abort
@
text
@a1255 1
					m_pClient->SetReceivedQueueRank();
@


1.220
log
@flood protection against block request packets
@
text
@a1254 1
					m_pClient->SetRemoteQueueFull(false);
d1256 1
@


1.219
log
@Limitation of possible chat message length;
More checks for message packet processing.
@
text
@d513 17
@


1.218
log
@Corrected addition of overhead statistics to appropriate group;
Added missed overhead statistics.
@
text
@a749 1
					memcpy2(&uMessageLen, pcPacketBuf, 2);
d751 9
a759 2
				//	Verify the packet size
					if (uMessageLen + 2 != dwPacketSize)
d761 3
@


1.217
log
@fixed for the reimplementation "connection in 5 sec" condition (thanks to Aw3)
@
text
@d1123 2
d1126 1
d1157 1
d1172 1
d1181 1
d1191 1
d1224 1
a1224 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d1317 1
a1317 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
@


1.216
log
@Changed statistics overhead type; Removed unused method.
@
text
@d1642 1
a1642 1
	if (!m_dwSocketOpenTime.empty() && (::GetTickCount() - m_dwSocketOpenTime.front()) <= 5000)
@


1.215
log
@Formatting.
@
text
@d740 1
a740 2
			//	Sometimes sent by Hybrid
				case OP_CHANGE_SLOT:
d742 1
a742 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
a1348 6
void CClientReqSocket::OnInit()
{
	byte tv = 1;
//SetSockOpt(SO_DONTLINGER,&tv,sizeof(BOOL));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d1415 1
a1415 3
	BOOL result = CAsyncSocketEx::Create(0, SOCK_STREAM, FD_WRITE | FD_READ | FD_CLOSE); // deadlake PROXYSUPPORT - changed to AsyncSocketEx
	OnInit();
	return result;
a1506 1
					pNewClientSocket->OnInit();
@


1.214
log
@Unified way to display client name and version; Improved string processing.
@
text
@d261 1
a261 1
						CKnownFile	*m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(requestedFileHash);
d264 1
a264 1
						if (!m_pReqSharedFile)
d296 1
a296 1
							if (m_pReqSharedFile->IsPartFile())
d299 1
a299 1
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > static_cast<CPartFile*>(m_pReqSharedFile)->GetSourceCount())
d301 1
a301 1
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqSharedFile, m_pClient);
d319 1
a319 1
							packetStream.Write(m_pReqSharedFile->GetFileHash(), 16);
d321 1
a321 1
							uint16		uNameLength = _tcslen(m_pReqSharedFile->GetFileName());
d324 1
a324 1
							packetStream.Write(m_pReqSharedFile->GetFileName(), uNameLength);
d331 1
a331 1
							m_pClient->SendCommentInfo(m_pReqSharedFile);
d401 1
a401 1
					CKnownFile* m_pReqSharedFile = NULL;
d413 2
a414 2
						m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(requestedFileHash);
						if (m_pReqSharedFile)
d417 3
a419 3
							if (m_pReqSharedFile->IsPartFile())
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqSharedFile)->GetSourceCount()) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqSharedFile, m_pClient);
d427 1
a427 1
							m_pClient->SendCommentInfo(m_pReqSharedFile);
d445 1
a445 1
						m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)m_pClient->m_reqFileHash);
d448 1
a448 1
					if (m_pReqSharedFile)
d450 1
a450 1
						m_pReqSharedFile->statistic.AddRequest();
d454 1
a454 1
							m_pReqSharedFile->AddClientToSourceList(m_pClient);
d647 1
d649 1
a649 3
						CKnownFile* m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pcPacketBuf);

						if (!m_pReqSharedFile)
d674 3
a676 3
						if (m_pReqSharedFile->IsPartFile())
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqSharedFile)->GetSourceCount())
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqSharedFile, m_pClient);
d685 7
a691 10
						packetStream.Write(m_pReqSharedFile->GetFileHash(), 16);
						if (m_pReqSharedFile->IsPartFile())
							((CPartFile*)m_pReqSharedFile)->WritePartStatus(&packetStream);

						else if (m_pReqSharedFile->GetJumpstartEnabled())
							m_pReqSharedFile->WriteJumpstartPartStatus(m_pClient, &packetStream);

						else if (m_pReqSharedFile->HasHiddenParts())
							m_pReqSharedFile->WritePartStatus(&packetStream);

@


1.213
log
@small correction for the reimplementation "connection in 5 sec" condition
@
text
@d246 2
a247 2
							AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) (IP: %s) added to filtered clients due to file scanning"),
											 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), m_pClient->GetFullIP() );
a256 1

d290 1
a290 2
								AddDebugLogLine(RGB_LOG_DIMMED + _T("Client %s (%s) (IP: %s) is using our userhash"), m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), m_pClient->GetFullIP());

d497 1
a497 1
						// don't change a state for client which don't have needed parts in order to prevent faster(addtional) file status request
d547 1
a547 1
						g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("Client '%s' (%s): upload session ended due to a cancelled transfer."), m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString());
d558 1
a558 1
							AddDebugLogLine(_T("Client '%s' (%s): upload session ended due to a completed transfer."), m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString());
d639 2
a640 2
							AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s) added to filtered clients due to file scanning"),
											 m_pClient->GetFullIP(), m_pClient->GetClientNameAndVersionString() );
d798 1
a798 1
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), GetResString(IDS_ACCEPTED) );
d803 1
a803 1
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), GetResString(IDS_DENIED) );
d844 2
a845 2
						AddLogLine( true, RGB_LOG_NOTICE + GetResString(IDS_SHAREDREQ1), m_pClient->GetUserName(),
							m_pClient->GetClientNameAndVersionString(), GetResString(IDS_ACCEPTED) );
d890 2
a891 2
						AddLogLine( true, RGB_LOG_WARNING + GetResString(IDS_SHAREDREQ1), m_pClient->GetUserName(),
							m_pClient->GetClientNameAndVersionString(), GetResString(IDS_DENIED) );
d930 2
a931 2
						AddDebugLogLine( _T("Client '%s' (%s) requested your list of shared files for directory '%s' ['%s'] (accepted)"),
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), strReqVDir, strReqDir );
d981 2
a982 2
						AddDebugLogLine( _T("Client '%s' (%s) requested your list of shared files for directory '%s' ['%s'] (denied)"),
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), strReqVDir, strReqDir );
d1010 2
a1011 2
							AddDebugLogLine( _T("Client '%s' (%s) shares directory '%s'"),
											 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), strDirName );
d1031 2
a1032 2
						AddDebugLogLine( _T("Client '%s' (%s) sent not requested list of shared directories - ignored"),
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString() );
d1056 2
a1057 2
						AddDebugLogLine( _T("Client '%s' (%s) sent list of shared files for directory '%s'"),
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), strDirName );
d1061 2
a1062 2
							AddDebugLogLine( _T("Client '%s' (%s) finished sending list of shared files"),
											 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString() );
d1067 2
a1068 2
						AddDebugLogLine( _T("Client '%s' (%s) sent not requested list of shared files for directory '%s' - ignored"),
										 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), strDirName);
d1076 1
a1076 1
					AddLogLine(true, IDS_SHAREDREQDENIED, m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString());
d1111 2
a1112 3
			AddDebugLogLine( _T("Client '%s' (%s) caused an error: %s. Disconnecting client!"),
							 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(),
						 	 error.GetBuffer() );
d1344 2
a1345 2
			AddDebugLogLine( _T("Client '%s' (%s) caused an error or did something bad: %s. Disconnecting client!"),
							 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), error.GetBuffer() );
d1370 2
a1371 2
		AddDebugLogLine( _T("Client '%s' (%s) (IP: %s) caused an error: %u. Disconnecting client!"),
						 m_pClient->GetUserName(), m_pClient->GetClientNameAndVersionString(), m_pClient->GetFullIP(), nErrorCode );
a1405 1
//		ASSERT(0);
@


1.212
log
@Removed unused code.
@
text
@d1641 2
a1642 1
	if (m_dwSocketOpenTime.size() >= g_eMuleApp.m_pGlobPrefs->GetMaxConPerFive())
@


1.211
log
@reimplemented "connection in 5 sec" condition, now it does not use average
@
text
@d42 1
a42 1
CClientReqSocket::CClientReqSocket(CPreferences* in_prefs, CUpDownClient* in_client)
a43 1
	m_pPrefs = in_prefs;
d1442 1
a1442 1
CListenSocket::CListenSocket(CPreferences *in_pPrefs)
d1504 1
a1504 1
			CClientReqSocket* pNewClientSocket = new CClientReqSocket(g_eMuleApp.m_pGlobPrefs);
d1654 1
a1654 1
	if ( GetNumOpenSockets() > g_eMuleApp.m_pGlobPrefs->GetMaxConnections())
d1658 1
a1658 1
// check if how much time time was gonne since maximal allowed connection during 5 sec was opened
d1662 1
a1662 1
		return false;
@


1.210
log
@name corretions according our name convetion
@
text
@a1444 1
	m_pPrefs = in_pPrefs;
a1445 1
	m_iOpenSocketsInterval = 0;
d1459 1
a1459 1
	return(this->Create(m_pPrefs->GetPort(), SOCK_STREAM, FD_ACCEPT) && this->Listen());
d1505 1
a1505 1
			CClientReqSocket* pNewClientSocket = new CClientReqSocket(m_pPrefs);
a1540 2
	m_iOpenSocketsInterval = 0;

d1568 3
a1570 1
	if ((GetNumOpenSockets() + 5 < m_pPrefs->GetMaxConnections() || g_eMuleApp.m_pServerConnect->IsConnecting()) && !m_bListening)
d1572 1
d1641 6
a1646 1
	m_iOpenSocketsInterval++;
d1655 6
a1660 4
	if ( GetNumOpenSockets() > m_pPrefs->GetMaxConnections()
	     || ( m_iOpenSocketsInterval > (g_eMuleApp.m_pGlobPrefs->GetMaxConPerFive() * g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetMaxConPerFiveModifier())
	          && !bIgnoreInterval ) )
	{
d1662 1
a1662 2
	}
	else
@


1.209
log
@new source exchange system
@
text
@d351 2
a352 2
						CPartFile* m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
						if (!m_pReqPartFile)
@


1.208
log
@Support new ed2k tag format (client<->server,
as well as used for shared list transfers to eMule v0.43a+ and eMule Plus v1.1a+).
@
text
@d455 1
d457 2
@


1.207
log
@Enabled shared files view permission settings (all, friends only, noone).
(have been reminded of this forgotten column when I saw it in tooltips :))
@
text
@d808 1
a808 1
					CSafeMemFile	packetStream(80);
d813 1
a813 1
						g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*static_cast<CKnownFile*>(list.GetHead()), packetStream, NULL);
d956 1
a956 1
						CSafeMemFile		packetStream(80);
d968 1
a968 1
							g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*list.GetHead(), packetStream, NULL);
@


1.206
log
@Removed unused code.
@
text
@d791 5
a795 1
							list.AddTail((void*&)cur_file);
d947 3
a949 1
							if (strReqDir.CompareNoCase(strSharedFileDir) == 0)
d951 1
@


1.205
log
@minor improvement
@
text
@a1435 1
	m_iNumOpenSockets = 0;
a1533 1
	m_iNumOpenSockets = 0;
a1541 2
		m_iNumOpenSockets++;

a1632 1
	m_iNumOpenSockets++;
@


1.204
log
@Removed sending of a spare byte in OP_SETREQFILEID packet.
@
text
@d497 3
a499 1
							m_pClient->SetDownloadState(DS_ONQUEUE); //???
@


1.203
log
@fixed exception on shutdown
@
text
@d697 1
a697 1
							packetStream.Write(&null, 3);
@


1.202
log
@Fixed client information update in the Known Clients list
(in some cases after handshaking Clientsoftware information could be not updated).
@
text
@a1372 20
	//	Filter clients that are violating the protocol
#ifdef OLD_SOCKETS_ENABLED
		SOCKADDR_IN sockAddr;
		memzero(&sockAddr, sizeof(sockAddr));
		uint32 nSockAddrLen = sizeof(sockAddr);
		GetPeerName((SOCKADDR*) & sockAddr, (int*) & nSockAddrLen);
		uint32 UserIP = sockAddr.sin_addr.S_un.S_addr;
		CString FullUserIP(inet_ntoa(sockAddr.sin_addr));
		if (g_eMuleApp.m_pIPFilter->IsFiltered(UserIP))
		{
			InterlockedIncrement(&g_eMuleApp.m_lIncomingFiltered);
			InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);
		//	Reset client to NULL in order don't let CUpDownClient::Disconnected be processed
		//	for a client which is not in the list of clients
			m_pClient = NULL;
			Disconnect();
			return;
		}
#endif //OLD_SOCKETS_ENABLED

d1496 3
a1498 3
			CClientReqSocket* newclient = new CClientReqSocket(m_pPrefs);
			if (!Accept(*newclient))
				newclient->Safe_Delete();
d1501 17
a1517 2
				newclient->AsyncSelect(FD_WRITE | FD_READ | FD_CLOSE);
				newclient->OnInit();
@


1.201
log
@Removed socket closure after sending cancel as it led to exceptions
(e.i. CClientReqSocket::PacketReceived: Unknown exception. Protocol=...).
@
text
@d1141 2
@


1.200
log
@Add ERROR color to exception message.
@
text
@d496 1
a496 1
							m_pClient->SendCancelTransfer(true);
d598 1
a598 1
									m_pClient->SendCancelTransfer(true);
d612 1
a612 1
							m_pClient->SendCancelTransfer(true);
d1196 1
a1196 1
								m_pClient->SendCancelTransfer(true);
d1202 1
a1202 1
							m_pClient->SendCancelTransfer(true);
@


1.199
log
@Removed old unused code.
@
text
@d1417 1
a1417 1
		AddDebugLogLine(_T("%s: Unknown exception. Protocol=0x%02x  opcode=0x%02x  size=%u"), __FUNCTION__, packet != NULL ? packet->m_eProtocol : 0, packet != NULL ? packet->m_eOpcode : 0, packet != NULL ? packet->m_dwSize : 0);
@


1.198
log
@improved socket usage (centralized cancel of the transfer)
@
text
@a1308 21
/*
				case OP_VERIFYUPSREQ:
				{
					CUpDownClient* vuclient = g_eMuleApp.m_pClientList->VUGetRandomClient();
					if (vuclient)
					{
						Packet* answer = new Packet(OP_VERIFYUPSANSWER,6,OP_EMULEPROT);
						uint32 ip = vuclient->GetIP();
						memcpy2(answer->m_pcBuffer,ip,4);
						uint16 udpport = vuclient->GetUDPPort();
						memcpy2(answer->m_pcBuffer,ip,4);
						g_eMuleApp.m_pUploadQueue->AddUpDataRateMSOverhead(packet->m_dwSize);
						SendPacket(answer,true,true);
					}
				}
				case OP_VERIFYUPSANSWER:
				{
					if (size != 12)
						throw CString("invalid size (OP_VERIFYUPSANSWER)");
				}
*/
@


1.197
log
@Updated eMule protocol up to version 0.4x (original).
@
text
@d496 2
a497 5
							Packet		*pcPacketBuf = new Packet(OP_CANCELTRANSFER);

							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pcPacketBuf->m_dwSize);
							m_pClient->m_pRequestSocket->SendPacket(pcPacketBuf, true, true);
							m_pClient->SetDownloadState(DS_ONQUEUE);
d598 1
a598 4
									Packet		*pPacket = new Packet(OP_CANCELTRANSFER);

									g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
									m_pClient->m_pRequestSocket->SendPacket(pPacket, true, true);
d612 1
a612 4
							Packet		*pPacket = new Packet(OP_CANCELTRANSFER);

							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
							m_pClient->m_pRequestSocket->SendPacket(pPacket, true, true);
d1196 1
a1196 3
								Packet * packet = new Packet(OP_CANCELTRANSFER);
								g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
								m_pClient->m_pRequestSocket->SendPacket(packet, true, true);
d1202 1
a1202 3
							Packet* packet = new Packet(OP_CANCELTRANSFER);
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
							m_pClient->m_pRequestSocket->SendPacket(packet, true, true);
@


1.196
log
@Services renaming according to the official.
@
text
@d156 5
d172 1
a172 1
					bool newClient = false;
d177 1
a177 1
						newClient = true;
d179 6
a184 4
				//	Originally we had try & catch here, but because our EMULE_TRY & EMULE_CATCH
				//	function in ProcessHelloPacket, local try & catch did work. That means even in case of exception
				//	we process the client without full information.
					if (!m_pClient->ProcessHelloPacket(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize))
d186 1
a186 1
						if (newClient)
d196 1
a196 1
						m_pClient->ProcessHelloPacket(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d214 1
a214 1
					if (m_pClient->GetHashType() == SO_EMULE)
d220 7
a226 1

d1139 4
d1150 4
@


1.195
log
@corrected source swap by file deletion & fixed competion hang up
@
text
@d216 1
a216 1
				case OP_FILEREQUEST:
d318 1
a318 1
							pcPacketBuf->m_eOpcode = OP_FILEREQANSWER;
d328 1
a328 1
						throw CString(_T("invalid OP_FILEREQUEST packet size (OP_FILEREQUEST)"));
d362 1
a362 1
					throw CString(_T("invalid OP_FILEREQUEST packet size (OP_FILEREQANSNOFIL)"));
d365 1
a365 1
				case OP_FILEREQANSWER:
d702 1
a702 1
						throw CString(_T("invalid OP_FILEREQUEST packet size (OP_SETREQFILEID)"));
@


1.194
log
@Added color to a couple of log messages.
@
text
@d354 2
a355 5
									m_pClient->SetDownloadState(DS_NONEEDEDPARTS);
									m_pClient->SwapToAnotherFile(NULL);
/*
									if (!m_pClient->SwapToAnotherFile(NULL))
									{	//eklmn: bugfix(08): A4AF switching (???)
a356 2
									}
*/
@


1.193
log
@fixed timeout for DL clients (thanks cmgrr)
@
text
@d839 1
a839 1
						AddLogLine( true, IDS_SHAREDREQ1, m_pClient->GetUserName(),
d885 1
a885 1
						AddLogLine( true, IDS_SHAREDREQ1, m_pClient->GetUserName(),
@


1.192
log
@Fixed set client state on received data;
Fixed exception caused by protection against bad RX data;
GetStatus() optimization.
@
text
@d73 3
@


1.191
log
@corrected debug output
@
text
@d577 2
d580 2
a581 3
						if ( m_pClient->m_pReqPartFile != NULL
						  && ( m_pClient->m_pReqPartFile->GetStatus() == PS_READY
						    || m_pClient->m_pReqPartFile->GetStatus() == PS_EMPTY ) )
d583 1
a583 6
							m_pClient->ProcessBlockPacket(pcPacketBuf, dwPacketSize);
						//	If the file is now in a stopped state (paused/stopped/error)
							if ( (m_pClient->m_pReqPartFile != NULL)
							  && ( m_pClient->m_pReqPartFile->GetStatus() == PS_PAUSED
							    || m_pClient->m_pReqPartFile->GetStatus() == PS_STOPPED
							    || m_pClient->m_pReqPartFile->GetStatus() == PS_ERROR ) )
d585 6
a590 1
								Packet		*pPacket = new Packet(OP_CANCELTRANSFER);
d592 10
a601 3
								g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
								m_pClient->m_pRequestSocket->SendPacket(pPacket, true, true);
								m_pClient->SetDownloadState(m_pClient->m_pReqPartFile == NULL ? DS_NONE : DS_ONQUEUE);
d611 1
a611 1
							m_pClient->SetDownloadState(m_pClient->m_pReqPartFile == NULL || m_pClient->m_pReqPartFile->IsStopped() ? DS_NONE : DS_ONQUEUE);
d1176 4
a1179 1
						if (m_pClient->m_pReqPartFile && (m_pClient->m_pReqPartFile->GetStatus() == PS_READY || m_pClient->m_pReqPartFile->GetStatus() == PS_EMPTY))
d1183 2
a1184 3
							     ( m_pClient->m_pReqPartFile->GetStatus() == PS_PAUSED
							       || m_pClient->m_pReqPartFile->GetStatus() == PS_STOPPED
							       || m_pClient->m_pReqPartFile->GetStatus() == PS_ERROR ) )
d1189 1
d1197 1
a1197 1
							m_pClient->SetDownloadState(m_pClient->m_pReqPartFile == NULL ? DS_NONE : DS_ONQUEUE);
@


1.190
log
@minor name correction
@
text
@d493 4
a496 1
						throw CString(_T("wrong fileID sent (OP_ACCEPTUPLOADREQ => !m_pReqPartFile), file: ") + ((m_pClient->m_pReqPartFile != NULL) ? m_pClient->m_pReqPartFile->GetFileName() : _T("NULL")));
@


1.189
log
@rollback of old waiting queue
@
text
@d447 1
a447 1
						g_eMuleApp.m_pUploadQueue->AddClientToQueue(m_pClient);
@


1.188
log
@1) the agressivity check moved in ListenSocket
2) optimized client addition to the waiting queue
@
text
@d443 5
a447 1
						m_pClient->AddRequestCount((uchar*)m_pClient->m_reqFileHash);
a448 2
				//	add file to queue
					g_eMuleApp.m_pUploadQueue->CheckAndAddClientToWaitingQueue(m_pClient);
@


1.187
log
@SSWQ
@
text
@d443 1
d446 1
a446 1
					g_eMuleApp.m_pUploadQueue->AddClientToWaitingQueue(m_pClient);
@


1.186
log
@Preparations for new client version report code.
@
text
@a241 2
						if (!m_pClient->GetWaitStartTime())
							m_pClient->SetWaitStartTime();
d393 6
d405 1
a405 1
						CKnownFile* m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(requestedFileHash);
d435 11
a445 1
					g_eMuleApp.m_pUploadQueue->AddClientToQueue(m_pClient);
a628 2
						if (!m_pClient->GetWaitStartTime())
							m_pClient->SetWaitStartTime();
@


1.185
log
@Basic shared file list messages are moved to emule.log and again displayed on status bar.
@
text
@d232 1
a232 1
											 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), m_pClient->GetFullIP() );
d278 1
a278 1
								AddDebugLogLine(RGB_LOG_DIMMED + _T("Client %s (%s) (IP: %s) is using our userhash"), m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), m_pClient->GetFullIP());
d517 1
a517 1
						g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("Client '%s' (%s): upload session ended due to a cancelled transfer."), m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
d528 1
a528 1
							AddDebugLogLine(_T("Client '%s' (%s): upload session ended due to a completed transfer."), m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
d608 1
a608 1
											 m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient) );
d764 1
a764 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), GetResString(IDS_ACCEPTED) );
d769 1
a769 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), GetResString(IDS_DENIED) );
d811 1
a811 1
							GetClientNameAndVersionString(m_pClient), GetResString(IDS_ACCEPTED) );
d857 1
a857 1
							GetClientNameAndVersionString(m_pClient), GetResString(IDS_DENIED) );
d897 1
a897 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strReqVDir, strReqDir );
d945 1
a945 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strReqVDir, strReqDir );
d974 1
a974 1
											 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strDirName );
d995 1
a995 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d1020 1
a1020 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strDirName );
d1025 1
a1025 1
											 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d1031 1
a1031 1
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strDirName);
d1039 1
a1039 1
					AddLogLine(true, IDS_SHAREDREQDENIED, m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
d1075 1
a1075 1
							 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient),
d1321 1
a1321 1
							 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), error.GetBuffer() );
d1347 1
a1347 1
						 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), m_pClient->GetFullIP(), nErrorCode );
@


1.184
log
@Fixed a GUI glitch in Messages window when multiple tabs are open and windows is themed;
Name changes, formatting etc.
@
text
@d763 2
a764 2
						AddDebugLogLine( RGB_LOG_NOTICE + _T("Client '%s' (%s) requested your sharedfiles-list (accepted)"),
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d768 2
a769 2
						AddDebugLogLine( RGB_LOG_WARNING + _T("Client '%s' (%s) requested your sharedfiles-list (denied)"),
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d810 2
a811 2
						AddDebugLogLine( _T("Client '%s' (%s) requested your list of shared directories (accepted)"),
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d856 2
a857 2
						AddDebugLogLine( _T("Client '%s' (%s) requested your list of shared directories (denied)"),
										 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d1039 1
a1039 2
					AddDebugLogLine( _T("Client '%s' (%s) denied sending list of shared files"),
									 m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
@


1.183
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d732 1
d735 1
a735 2

					g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ProcessMessage(m_pClient, strMessage);
d1403 1
a1403 1
		ASSERT(0);
@


1.182
log
@Fixed exception 'CClientReqSocket::PacketReceived: Unknown exception.
Protocol=0xe3 opcode=0x55 size=0'
[Amen!].
@
text
@d98 1
a98 1
		AddDebugLogLine(false, _T("Invalid client '%s'"), m_pClient->GetUserName());
d231 2
a232 2
							AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' (%s) (IP: %s) added to filtered clients due to file scanning"),
													m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), m_pClient->GetFullIP() );
d278 1
a278 1
								AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) (IP: %s) is using our userhash"), m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), m_pClient->GetFullIP());
d516 2
a517 1
					g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("Client '%s' (%s): upload session ended due to a cancelled transfer."), m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
d527 2
a528 1
						AddDebugLogLine(false, _T("Client '%s' (%s): upload session ended due to a completed transfer."), m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
d607 2
a608 2
							AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' (%s) added to filtered clients due to file scanning"),
													m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient) );
d763 2
a764 2
						AddDebugLogLine( false, RGB_LOG_NOTICE + _T("Client '%s' (%s) requested your sharedfiles-list (accepted)"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d768 2
a769 2
						AddDebugLogLine( false, RGB_LOG_WARNING + _T("Client '%s' (%s) requested your sharedfiles-list (denied)"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d810 2
a811 2
						AddDebugLogLine( false, _T("Client '%s' (%s) requested your list of shared directories (accepted)"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d856 2
a857 2
						AddDebugLogLine( false, _T("Client '%s' (%s) requested your list of shared directories (denied)"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d896 2
a897 2
						AddDebugLogLine( false, _T("Client '%s' (%s) requested your list of shared files for directory '%s' ['%s'] (accepted)"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strReqVDir, strReqDir );
d944 2
a945 2
						AddDebugLogLine( false, _T("Client '%s' (%s) requested your list of shared files for directory '%s' ['%s'] (denied)"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strReqVDir, strReqDir );
d973 2
a974 2
							AddDebugLogLine( false, _T("Client '%s' (%s) shares directory '%s'"),
													m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strDirName );
d994 2
a995 2
						AddDebugLogLine( false, _T("Client '%s' (%s) sent not requested list of shared directories - ignored"),
										 		m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d1019 2
a1020 2
						AddDebugLogLine( false, _T("Client '%s' (%s) sent list of shared files for directory '%s'"),
												m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strDirName );
d1024 2
a1025 2
							AddDebugLogLine( false, _T("Client '%s' (%s) finished sending list of shared files"),
													m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d1030 2
a1031 2
						AddDebugLogLine( false, _T("Client '%s' (%s) sent not requested list of shared files for directory '%s' - ignored"),
										 		m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), strDirName);
d1039 2
a1040 2
					AddDebugLogLine( false, _T("Client '%s' (%s) denied sending list of shared files"),
									  	   m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient) );
d1075 3
a1077 3
			AddDebugLogLine( false, _T("Client '%s' (%s) caused an error: %s. Disconnecting client!"),
									m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient),
									error.GetBuffer() );
d1319 1
a1319 1
			AddDebugLogLine(false, _T("A client caused an error or did something bad: %s. Disconnecting client!"), error.GetBuffer());
d1321 2
a1322 2
			AddDebugLogLine( false, _T("Client '%s' (%s) caused an error or did something bad: %s. Disconnecting client!"),
									m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), error.GetBuffer() );
d1347 2
a1348 2
		AddDebugLogLine( false, _T("Client '%s' (%s) (IP: %s) caused an error: %u. Disconnecting client!"),
								m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient), m_pClient->GetFullIP(), nErrorCode );
d1350 1
a1350 1
		AddDebugLogLine(false, _T("A client caused an error or did something bad: CClientReqSocket::OnError. Disconnecting client!"));
d1404 1
a1404 1
		AddDebugLogLine(false,_T("%s: Unknown exception. Protocol=0x%02x  opcode=0x%02x  size=%u"), __FUNCTION__, packet != NULL ? packet->m_eProtocol : 0, packet != NULL ? packet->m_eOpcode : 0, packet != NULL ? packet->m_dwSize : 0);
@


1.181
log
@Removed debug log translations + minor additions + minor change
@
text
@d476 1
a476 1
						throw CString(_T("wrong fileID sent (OP_ACCEPTUPLOADREQ => !m_pReqPartFile), file: ") + (m_pClient->m_pReqPartFile != NULL) ? m_pClient->m_pReqPartFile->GetFileName() : _T("NULL"));
@


1.180
log
@DebugLog lines shouldn't update taskbar
@
text
@d144 1
a144 1
				throw GetResString(IDS_ERR_NOHELLO);
d178 1
a178 1
						throw CString(_T("Unable to process HelloPacket"));
d195 1
a195 1
							throw CString(_T("Unable to add client in ClientList"));
d327 1
a327 1
						throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE) + _T(" (OP_FILEREQUEST)"));
d366 1
a366 1
					throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE) + _T(" (OP_FILEREQANSNOFIL)"));
d476 1
a476 1
						throw CString(GetResString(IDS_ERR_WRONGFILEID) + _T(" (OP_ACCEPTUPLOADREQ => !m_pReqPartFile)"));
d535 1
a535 1
						throw GetResString(IDS_ERR_WRONGHPACKAGESIZE);
d676 1
a676 1
						throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE) + _T(" (OP_SETREQFILEID)"));
d727 1
a727 1
						throw CString("invalid message pcPacketBuf");
d1058 1
a1058 1
			throw GetResString(IDS_ERR_INVALIDPACKAGE);
d1091 1
a1091 1
				throw GetResString(IDS_ERR_UNKNOWNCLIENTACTION);
d1178 1
a1178 1
						throw GetResString(IDS_ERR_BADSIZE);
d1196 1
a1196 1
							throw GetResString(IDS_ERR_BADSIZE);
d1263 1
a1263 1
						throw GetResString(IDS_ERR_INVALIDPACKAGE);
d1304 1
a1304 1
			throw GetResString(IDS_ERR_INVALIDPACKAGE);
d1400 1
a1400 1
	//	If we get here, we propable had an access violation
d1402 8
a1409 4
		AddDebugLogLine(false,_T("%s: Unknown exception"), __FUNCTION__);
		if (m_pClient)
			m_pClient->SetDownloadState(DS_ERROR);
		Disconnect();
@


1.179
log
@Added client version info to debug log messages.
@
text
@d1037 1
a1037 1
					AddDebugLogLine( true, _T("Client '%s' (%s) denied sending list of shared files"),
@


1.178
log
@another auto A4AF bugfix
@
text
@d231 2
a232 2
							AddDebugLogLine( false, RGB_LOG_DIMMED + _T("Client '%s' (%s) added to filtered clients due to file scanning"),
													m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient) );
d278 1
a278 1
								AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) is using our userhash"), m_pClient->GetUserName(), m_pClient->GetFullIP());
d516 1
a516 1
					g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("Client '%s': upload session ended due to a cancelled transfer."), m_pClient->GetUserName());
d526 1
a526 1
						AddDebugLogLine(false, _T("Client '%s': upload session ended due to a completed transfer."), m_pClient->GetUserName());
d761 2
a762 2
						AddDebugLogLine( false, RGB_LOG_NOTICE + _T("Client '%s' requested your sharedfiles-list (accepted)"),
												m_pClient->GetUserName() );
d766 2
a767 2
						AddDebugLogLine( false, RGB_LOG_WARNING + _T("Client '%s' requested your sharedfiles-list (denied)"),
												m_pClient->GetUserName() );
d808 2
a809 2
						AddDebugLogLine( false, _T("Client '%s' requested your list of shared directories (accepted)"),
												m_pClient->GetUserName() );
d854 2
a855 2
						AddDebugLogLine( false, _T("Client '%s' requested your list of shared directories (denied)"),
												m_pClient->GetUserName() );
d894 2
a895 2
						AddDebugLogLine( false, _T("Client '%s' requested your list of shared files for directory '%s' ['%s'] (accepted)"),
												m_pClient->GetUserName(), strReqVDir, strReqDir );
d942 2
a943 2
						AddDebugLogLine( false, _T("Client '%s' requested your list of shared files for directory '%s' ['%s'] (denied)"),
												m_pClient->GetUserName(), strReqVDir, strReqDir );
d971 2
a972 2
							AddDebugLogLine( false, _T("Client '%s' shares directory '%s'"),
													m_pClient->GetUserName(), strDirName );
d992 2
a993 2
						AddDebugLogLine( false, _T("Client '%s' sent not requested list of shared directories - ignored"),
										 		m_pClient->GetUserName() );
d1017 2
a1018 2
						AddDebugLogLine( false, _T("Client '%s' sent list of shared files for directory '%s'"),
												m_pClient->GetUserName(), strDirName );
d1022 2
a1023 2
							AddDebugLogLine( false, _T("Client '%s' finished sending lists of shared files"),
													m_pClient->GetUserName() );
d1028 2
a1029 2
						AddDebugLogLine( false, _T("Client '%s' sent not requested list of shared files for directory '%s' - ignored"),
										 		m_pClient->GetUserName(), strDirName);
d1037 2
a1038 2
					AddDebugLogLine( true, _T("Client '%s' denied sending list of shared files"),
									  	   m_pClient->GetUserName() );
d1345 2
a1346 2
		AddDebugLogLine( false, _T("Client '%s' (IP: %s) caused an error: %u. Disconnecting client!"),
								m_pClient->GetUserName(), m_pClient->GetFullIP(), nErrorCode );
@


1.177
log
@minor fix (wrong debuglog entry)
@
text
@d354 1
a354 1
									m_pClient->SwapToAnotherFile(NULL,true);
@


1.176
log
@Changed some logs
@
text
@d1037 1
a1037 1
					AddDebugLogLine( true, _T("Client '%s' sent not requested list of shared files for directory '%s' - ignored"),
@


1.175
log
@BUGFIX: permanently switching A4AF sources
@
text
@d125 1
a125 1
	if (m_SocketData.hSocket != INVALID_SOCKET) // deadlake PROXYSUPPORT - changed to AsyncSocketEx
d156 1
a156 1
						// update of client in Client list will lead to GUI update in ClientListCtrl as well as DownloadListCtrl
d171 3
a173 3
				//	eklmn: originally we had try & catch here, but cause our EMULE_TRY & EMULE_CATCH
				//	function in ProcessHelloPacket, local trycatch did work. That means even in case of exception
				//	we process the client without full information... so i changed a function to get some info back
d180 3
a182 4
				//	now we check if we now this client already. if yes this m_pRequestSocket will
				//	be attached to the known client, the new client will be deleted
				//	and the var. "client" will point to the known client.
				//	if not we keep our new-constructed client ;)
d185 1
a185 1
					//	update the old client informations
d187 1
a187 1
						m_pClient->DisableL2HAC(); //<<-- enkeyDEV(th1) -L2HAC- lowid side
d191 1
a191 1
						//eklmn: if new client was not created delete him
d200 1
a200 1
					// update of client in Client list will lead to GUI update in ClientListCtrl as well as DownloadListCtrl
d203 1
a203 1
				//	send a response packet with standard informations
d224 1
a224 1
				//		non-existant file more than three times...
d231 2
a232 1
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) added to filtered clients due to file scanning"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
a235 2
				//	Since we don't process extended information it is better for compatibility with rest of the network
				//		to always process a filehash & extended information only if the file exists and was activated by tag ET_EXTENDEDREQUEST
d237 3
a253 1
						//
d255 2
a256 2
						//		Moreover we need to check if the requested file exists in the DL queue
						//		in order to filter the clients correct way.
d261 1
a261 1
						//	If we've found the file and it hasn't completed...
d264 1
a264 1
							//	... and we don't already have enough sources...
d276 1
a276 1
						//	If the client is using our user hash (hash stealer)...
a279 8
						/*
						eklmn: removed at 12.12.2003 in order to save some traffic and not send FILEREQANSNOFIL twice
						//	send file request no such file pcPacketBuf (0x48)
							Packet * replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							md4cpy(replypacket->m_pcBuffer, pcPacketBuf);
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->m_dwSize);
							SendPacket(replypacket, true);
						*/
d287 1
a287 1
							//	... and we don't already have enough sources...
d294 1
a294 1
						//	If this client is requesting this file for the first time...
d336 1
a336 1
					//	if that client do not have my file maybe has another different
d341 1
a341 1
						//eklmn: do nothing if none-file was requested
d345 1
a345 1
					//	we try to swap to another file ignoring no needed parts files
d391 2
a392 2
				// eklmn: the old eMule clients (<0.26) as well as original eDonkey don't send a hash (dwPacketSize is 0)
				// so we gonna add client to UL-queue anyway, but inside AddClientToQueue() will be checked
d404 1
a404 1
						//	if wer are downloading this file, this could be a new source
d409 1
a409 1
						//	check to see if this is a new file they are asking for
d419 1
a419 1
						//eklmn: if client still asking for not existing, he is definitely violating eDonkey protocol
d423 1
a423 1
						//	Reply that requested file is not exist
a439 3
				//	eklmn: switch DL state in case newrank != 0
				//	if (rank && m_pClient->GetDownloadState() == DS_DOWNLOADING)
				//		m_pClient->SetDownloadState(DS_ONQUEUE);
a445 1
				//	modified by sivka [dont download if paused]
d448 2
a449 3
					//	If the client is in our download queue and the part file is downloading or waiting but
					//		isn't paused...
					//	DbT: ask for next block while downloading
d452 2
a453 2
						//	eklmn: sometimes remote client sends us OP_ACCEPTUPLOADREQ during DS_DOWNLOADING state
						//	to prevent desynconization of request we gonna clear the list of pending bloks
d457 1
a457 1
					//	eklmn: ask while connecting, but don't ask for paused files
d463 1
a463 1
							m_pClient->SetLastDownPartAsked(0xFFFF); // eklmn: feature(00): ICR 2.3 reset part before new download
d466 1
a466 1
						else // added by sivka [dont download if paused]
d471 1
a471 1
							m_pClient->m_pRequestSocket->SendPacket(pcPacketBuf, true, true); //eklmn: bugfix(05): Listen socket OP_ACCEPTUPLOADREQ
a541 2
				//if (m_pClient->GetDownloadState() != DS_REQHASHSET)
				//	throw CString("unwanted hashset");
d545 1
a545 1
				case OP_SENDINGPART:	// i.e source sending part to us
d561 1
a561 1
						//	If the file is now in a stopped state (paused/stopped/error)...
d574 1
a574 1
					//	If we didn't want this file (or don't now)...
a593 3
					//	this request ends in an endless loop !!!
					//	OP_REQUESTPARTS <-> OP_OUTOFPARTREQS
						//m_pClient->SendBlockRequests();
d605 2
a606 1
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) added to filtered clients due to file scanning"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d620 1
a620 1
						//	If we've just started a download we may want to use that client as a source.
d632 1
a632 1
						//	send file request no such file pcPacketBuf (0x48)
d640 1
a640 1
					//	eklmn: reset Failed Request Counter
d642 1
a642 1
					//	if we are downloading this file, this could be a new source
d647 1
a647 1
					//	check to see if this is a new file they are asking for
d651 1
a651 1
					//send filestatus
a652 1
					//md4cpy(m_pClient->m_reqFileHash,pcPacketBuf);
d687 1
d689 1
a689 1
					{ // client changed server and gots a LowID
d693 2
a694 1
							m_pClient->SetUserID(nNewUserID); // update UserID only if we know the server
d699 3
a701 2
					else if (nNewUserID == m_pClient->GetIP())
					{ // client changed server and gots a HighID(IP)
d712 1
a712 1

a715 1
				//	sometimes sent by Hybrid
d724 1
a724 1
				//
d761 2
a762 1
						AddDebugLogLine(false, RGB_LOG_NOTICE + _T("User %s (%u) requested your sharedfiles-list (accepted)"), m_pClient->GetUserName(), m_pClient->GetUserID());
d766 2
a767 1
						AddDebugLogLine(false, RGB_LOG_WARNING + _T("User %s (%u) requested your sharedfiles-list (denied)"), m_pClient->GetUserName(), m_pClient->GetUserID());
d808 2
a809 2
						AddDebugLogLine( false, _T("User %s (%u) requested your list of shared directories (accepted)"),
												m_pClient->GetUserName(), m_pClient->GetUserID() );
d830 1
a830 1
					//
d854 2
a855 2
						AddDebugLogLine( false, _T("User %s (%u) requested your list of shared directories (denied)"),
												m_pClient->GetUserName(), m_pClient->GetUserID() );
d894 2
a895 2
						AddDebugLogLine( false, _T("User %s (%u) requested your list of shared files for directory '%s' ['%s'] (accepted)"),
												m_pClient->GetUserName(), m_pClient->GetUserID(), strReqVDir, strReqDir );
d917 1
a917 3
						/*if (list.GetCount())*/
						{
							CSafeMemFile		packetStream(80);
d919 2
a920 2
							uint16		uDirNameLen = strReqVDir.GetLength();
							packetStream.Write(&uDirNameLen, 2);
d922 1
a922 1
							packetStream.Write(static_cast<LPCTSTR>(strReqVDir), uDirNameLen);
d924 2
a925 2
							uint32		dwNumFiles = list.GetCount();
							packetStream.Write(&dwNumFiles, 4);
d927 5
a931 5
							while (list.GetCount())
							{
								g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*list.GetHead(), packetStream, NULL);
								list.RemoveHead();
							}
d933 1
a933 1
							Packet		*pReplyPacket = new Packet(&packetStream);
d935 3
a937 4
							pReplyPacket->m_eOpcode = OP_ASKSHAREDFILESDIRANS;
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pReplyPacket->m_dwSize);
							SendPacket(pReplyPacket, true, true);
						}
d942 2
a943 2
						AddDebugLogLine( false, _T("User %s (%u) requested your list of shared files for directory '%s' ['%s'] (denied)"),
												m_pClient->GetUserName(), m_pClient->GetUserID(), strReqVDir, strReqDir );
d971 2
a972 4
						//	Better send the received and untouched directory string back to that client
						//	PathRemoveBackslash(strDirName.GetBuffer());
						//	strDirName.ReleaseBuffer();
							AddDebugLogLine(false, _T("User %s (%u) shares directory '%s'"), m_pClient->GetUserName(), m_pClient->GetUserID(), strDirName);
d992 2
a993 2
						AddDebugLogLine( false, _T("User %s (%u) sent not requested list of shared directories - ignored"),
										 		m_pClient->GetUserName(), m_pClient->GetUserID() );
d1003 1
a1003 1
				//
d1007 1
a1007 1
				//
d1017 2
a1018 2
						AddDebugLogLine( false, _T("User %s (%u) sent list of shared files for directory '%s'"),
												m_pClient->GetUserName(), m_pClient->GetUserID(), strDirName );
d1022 2
a1023 2
							AddDebugLogLine( false, _T("User %s (%u) finished sending lists of shared files"),
													m_pClient->GetUserName(), m_pClient->GetUserID() );
d1028 2
a1029 2
						AddDebugLogLine( false, _T("User %s (%u) sent not requested list of shared files for directory '%s' - ignored"),
										 		m_pClient->GetUserName(), m_pClient->GetUserID(), strDirName);
d1037 2
a1038 2
					AddDebugLogLine( true, _T("User %s (%u) sent not requested list of shared files for directory '%s' - ignored"),
									  m_pClient->GetUserName(), m_pClient->GetUserID() );
d1073 3
a1075 4
		//	TODO write this into a debugfile
			AddDebugLogLine( false, _T("Client '%s' (IP: %s | version: %s) caused an error: %s. Disconnecting client!"),
									m_pClient->GetUserName(), m_pClient->GetFullIP(),
									GetClientNameAndVersionString(m_pClient), error.GetBuffer() );
d1144 3
a1146 3
					// eklmn: before we process a packet we need to check Download State
					// if client send us a packet in unwanted state (we don't request (need) this packet)
					// we gonna switch him to error state.
d1183 1
a1183 1
				//	eklmn: switch DL state in case newrank != 0
d1198 1
a1198 1
					//first check shared file list, then download list
d1210 1
a1210 1
							//	if not complete and file is rare, allow once every 10 minutes
d1250 1
a1250 1
							//set the client's answer time
d1252 1
a1252 1
							//and set the pKnownFile's last answer time
d1254 1
a1254 2

							//v1:- eklmn: support Source Exchange v2
d1273 3
a1275 2
				/*
				case OP_VERIFYUPSREQ:{
d1277 2
a1278 1
					if (vuclient){
d1288 2
a1289 1
				case OP_VERIFYUPSANSWER:{
d1293 1
a1293 1
				*/
@


1.174
log
@Optimized OP_REQUESTPARTS handling;
Added(fixed) packet size check, which should've been there from the beginning;
Local variables are removed from the class to reduce memory usage.
@
text
@d360 10
a369 3
								if (!m_pClient->SwapToAnotherFile(NULL))
								{	//eklmn: bugfix(08): A4AF switching (???)
									g_eMuleApp.m_pDownloadQueue->RemoveSource(m_pClient, true);
a370 1
								break;
@


1.173
log
@Hope no more changes... :P
@
text
@d490 3
a492 1
					CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d494 1
a494 1
					uchar		reqfilehash[16];
d496 6
a501 1
					packetStream.Read(reqfilehash, 16);
d503 6
a508 4
					//reset previous value due to safety reason
					memzero(&m_sReqBlock1, sizeof(Requested_Block_Struct));
					memzero(&m_sReqBlock2, sizeof(Requested_Block_Struct));
					memzero(&m_sReqBlock3, sizeof(Requested_Block_Struct));
d510 6
a515 21
					packetStream.Read(&m_sReqBlock1.m_dwStartOffset, 4);
					packetStream.Read(&m_sReqBlock2.m_dwStartOffset, 4);
					packetStream.Read(&m_sReqBlock3.m_dwStartOffset, 4);
					packetStream.Read(&m_sReqBlock1.m_dwEndOffset, 4);
					packetStream.Read(&m_sReqBlock2.m_dwEndOffset, 4);
					packetStream.Read(&m_sReqBlock3.m_dwEndOffset, 4);
					md4cpy(&m_sReqBlock1.m_fileHash, reqfilehash);
					md4cpy(&m_sReqBlock2.m_fileHash, reqfilehash);
					md4cpy(&m_sReqBlock3.m_fileHash, reqfilehash);

					if (m_sReqBlock1.m_dwEndOffset - m_sReqBlock1.m_dwStartOffset != 0)
					{
						m_pClient->AddReqBlock(&m_sReqBlock1);
					}
					if (m_sReqBlock2.m_dwEndOffset - m_sReqBlock2.m_dwStartOffset != 0)
					{
						m_pClient->AddReqBlock(&m_sReqBlock2);
					}
					if (m_sReqBlock3.m_dwEndOffset - m_sReqBlock3.m_dwStartOffset != 0)
					{
						m_pClient->AddReqBlock(&m_sReqBlock3);
@


1.172
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d529 1
a529 1
					g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("Client '%s': Upload session ended due to a cancelled transfer."), m_pClient->GetUserName());
d539 1
a539 1
						AddDebugLogLine(false, _T("Client '%s': Upload session ended due to a completed transfer."), m_pClient->GetUserName());
@


1.171
log
@Formating changes
@
text
@d98 1
a98 1
		AddDebugLogLine(false, _T("%s: Invalid client %s"), __FUNCTION__, m_pClient->GetUserName());
d529 1
a529 1
					g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("%s: Upload session ended due to a cancelled transfer."), m_pClient->GetUserName());
d539 1
a539 1
						AddDebugLogLine(false, _T("%s: Upload session ended due to a completed transfer."), m_pClient->GetUserName());
@


1.170
log
@Final DebugLog formating and changes
@
text
@d1056 1
a1056 1
					AddLogLine( true, _T("User %s (%u) sent not requested list of shared files for directory '%s' - ignored"),
@


1.169
log
@More DebugLog formating and changes
@
text
@d1047 2
a1048 1
						AddDebugLogLine(false, IDS_SHAREDANSW3, m_pClient->GetUserName(), m_pClient->GetUserID(), strDirName);
@


1.168
log
@minor changes (SetDownloadState(...), exception handling)
@
text
@d96 1
a96 1
	if (m_pClient != NULL && !g_eMuleApp.m_pClientList->IsValidClient(m_pClient)) // obaldin: a quick fix for a strange bug
d98 1
a98 1
		AddDebugLogLine(false, _T("Invalid client in CClientReqSocket::Disconnect()"));
d777 1
a777 1
						AddDebugLogLine(false, IDS_REQ_SHAREDFILES, m_pClient->GetUserName(), m_pClient->GetUserID(), GetResString(IDS_ACCEPTED));
d781 1
a781 1
						AddDebugLogLine(false, IDS_REQ_SHAREDFILES, m_pClient->GetUserName(), m_pClient->GetUserID(), GetResString(IDS_DENIED));
d783 1
a783 1
				//
d822 2
a823 1
						AddDebugLogLine(false, IDS_SHAREDREQ1, m_pClient->GetUserName(), m_pClient->GetUserID(), GetResString(IDS_ACCEPTED));
d868 2
a869 1
						AddDebugLogLine(false, IDS_SHAREDREQ1, m_pClient->GetUserName(), m_pClient->GetUserID(), GetResString(IDS_DENIED));
d908 2
a909 1
						AddDebugLogLine(false, IDS_SHAREDREQ2, m_pClient->GetUserName(), m_pClient->GetUserID(), strReqVDir, strReqDir, GetResString(IDS_ACCEPTED));
d959 2
a960 1
						AddDebugLogLine(false, IDS_SHAREDREQ2, m_pClient->GetUserName(), m_pClient->GetUserID(), strReqVDir, strReqDir, GetResString(IDS_DENIED));
d991 1
a991 1
							AddDebugLogLine(false, IDS_SHAREDANSW, m_pClient->GetUserName(), m_pClient->GetUserID(), strDirName);
d1011 2
a1012 1
						AddDebugLogLine(false, IDS_SHAREDANSW2, m_pClient->GetUserName(), m_pClient->GetUserID());
d1036 2
a1037 1
						AddDebugLogLine(false, IDS_SHAREDINFO1, m_pClient->GetUserName(), m_pClient->GetUserID(), strDirName);
d1041 2
a1042 1
							AddDebugLogLine(false, IDS_SHAREDINFO2, m_pClient->GetUserName(), m_pClient->GetUserID());
d1055 2
a1056 1
					AddLogLine(true, IDS_SHAREDREQDENIED, m_pClient->GetUserName(), m_pClient->GetUserID());
a1068 2
//					AddDebugLogLine(false, RGB_LOG_WARNING + _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//					PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
d1075 1
a1075 1
			error->Delete();	//mf
d1092 3
a1094 3
			AddDebugLogLine(false, GetResString(IDS_ERR_CLIENTERROR) + _T(" (%s)"),
				m_pClient->GetUserName(), m_pClient->GetFullIP(), error.GetBuffer(), GetClientNameAndVersionString(m_pClient) );
//			PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown client eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
a1095 5
//		else
//		{
//			AddDebugLogLine(false, IDS_ERR_BADCLIENTACTION, error.GetBuffer());
//			PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown protocol eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
//		}
a1155 3
#ifdef DEBUG_SHOW_SECUREID
						DEBUG_ONLY(AddDebugLogLine(false, "-->Signature Received"));
#endif
a1244 1
								//	AddDebugLogLine(false, "RCV:Source Request User(%s) File(%s)", m_pClient->GetUserName(), file->GetFileName());
a1313 1
				//	AddDebugLogLine(false, RGB_LOG_WARNING + _T("unknown extended opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
d1334 1
a1334 1
			AddDebugLogLine(false, IDS_ERR_BADCLIENTACTION, error.GetBuffer());
d1336 2
a1337 1
			AddDebugLogLine(false, GetResString(IDS_ERR_BADCLIENTACTION) + _T(" (%s)"), error.GetBuffer(), GetClientNameAndVersionString(m_pClient));
d1362 2
a1363 1
		AddDebugLogLine(false, IDS_ERR_BADCLIENT2, m_pClient->GetUserName(), m_pClient->GetFullIP(), nErrorCode);
d1365 1
a1365 1
		AddDebugLogLine(false, IDS_ERR_BADCLIENTACTION, "CClientReqSocket::OnError");
d1373 1
a1373 2

		//v- eklmn: feature(01): Filter clients, which are violating protocol
a1382 4
			/*
			if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
				AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
			*/
d1384 3
a1386 2
			InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);	//g_eMuleApp.stat_filteredclients++;
			//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
a1391 1
//^- eklmn: feature(01): Filter clients, which are violating protocol
d1408 1
a1408 2
				//eklmn: let's free a socket from buggy and unknown clients
//			AddDebugLogLine(false, _T("Received unknown client TCP packet; IP=%s  protocol=0x%02x  opcode=0x%02x  size=%u"), FullUserIP, packet->m_eProtocol, packet->m_eOpcode, packet->m_dwSize);
d1419 2
a1420 2
		AddDebugLogLine(false,_T("Unknown exception in 'CClientReqSocket::PacketReceived'"));
		if (m_pClient) 
@


1.167
log
@minor changes, fixes and improvements
@
text
@d586 1
d596 1
a596 1
							m_pClient->SetDownloadState(m_pClient->m_pReqPartFile == NULL ? DS_NONE : DS_ONQUEUE);
d1321 1
a1321 1
		catch (CFileException * error)
d1327 6
d1373 4
a1376 1
//v- eklmn: feature(01): Filter clients, which are violating protocol
d1378 19
a1396 19
	SOCKADDR_IN sockAddr;
	memzero(&sockAddr, sizeof(sockAddr));
	uint32 nSockAddrLen = sizeof(sockAddr);
	GetPeerName((SOCKADDR*) & sockAddr, (int*) & nSockAddrLen);
	uint32 UserIP = sockAddr.sin_addr.S_un.S_addr;
	CString FullUserIP(inet_ntoa(sockAddr.sin_addr));
	if (g_eMuleApp.m_pIPFilter->IsFiltered(UserIP))
	{
		/*
		if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
		*/
		InterlockedIncrement(&g_eMuleApp.m_lIncomingFiltered);
		InterlockedIncrement(&g_eMuleApp.m_lTotalFiltered);	//g_eMuleApp.stat_filteredclients++;
		//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
		m_pClient = NULL;
		Disconnect();
		return;
	}
d1400 13
a1412 9
	switch (packet->m_eProtocol)
	{
		case OP_EDONKEYPROT:
			ProcessPacket(packet->m_pcBuffer, packet->m_dwSize, packet->m_eOpcode);
			break;
		case OP_PACKEDPROT:
			if (!packet->UnpackPacket())
			{
				ASSERT (false);
d1414 2
a1415 6
			}
		case OP_EMULEPROT:
			ProcessExtPacket(packet->m_pcBuffer, packet->m_dwSize, packet->m_eOpcode);
			break;
		default:
			//eklmn: let's free a socket from buggy and unknown clients
d1417 14
a1430 3
			if (m_pClient)
				m_pClient->SetDownloadState(DS_ERROR);
			Disconnect();
@


1.166
log
@fixed my really incorrect and bugged way of processing StatusFile packets
@
text
@d204 2
a205 2
				//	send a response pcPacketBuf with standard informations
					if (m_pClient->GetClientSoft() == SO_EMULE && m_pClient->GetHashType() == SO_EMULE)
@


1.165
log
@comments corrections (thanks to Aw3)
@
text
@d380 10
a389 1
					m_pClient->ProcessFileStatus(pcPacketBuf, dwPacketSize);
@


1.164
log
@Updated SourceExchange Protocol to v2
@
text
@d1202 1
a1202 1
				//	Original client don't answer if client's SourceExchange Version is blow or equal to 1
@


1.163
log
@Minor fix by xrmb
@
text
@d310 3
a321 3
						//	TODO: Don't let 'ProcessUpFileStatus' re-process the entire pcPacketBuf and search the fileid
						//	again in 'm_pSharedFilesList' -> waste of time.
							m_pClient->ProcessUpFileStatus(pcPacketBuf, dwPacketSize);
d491 1
a491 1
					
d501 1
a501 1
					
d1202 2
@


1.162
log
@minor changes (function renamings, unused typedef removal)
@
text
@d613 1
a613 1
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) added to filtered clients due to file scanning (%s)"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
@


1.161
log
@async update ClientListCtrl
@
text
@d231 1
a231 1
						if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
d612 1
a612 1
						if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
d1366 1
a1366 1
		if (!g_eMuleApp.m_pGlobPrefs->GetCMNotLog())
@


1.160
log
@reformatting
@
text
@d156 2
a157 1
						g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(m_pClient);
d201 2
a202 1
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(m_pClient);
@


1.159
log
@Updates before release (some leftovers)
@
text
@d1132 1
a1132 1
					if (m_pClient->IsBanned())
d1134 1
a1134 1
						break;
a1135 1
					m_pClient->ProcessPublicKeyPacket((uchar*)packet, size);
d1140 1
a1140 1
					if (m_pClient->IsBanned())
d1142 1
a1142 3
						break;
					}
					m_pClient->ProcessSignaturePacket((uchar*)packet, size);
d1144 1
a1144 2

					DEBUG_ONLY(AddDebugLogLine(false, "-->Signature Received"));
d1146 1
a1146 1

@


1.158
log
@Changed the fix for auto server connect and serverlist update on start as it brought problems to some users. Now it should be ok.
@
text
@d1141 4
@


1.157
log
@atomic pending socket counter
@
text
@d1472 1
a1472 1
			ASSERT(false);
@


1.156
log
@replaced  pos != 0 to pos != NULL
@
text
@d1427 1
a1427 1
	m_iNumPendingConnections = 0;
d1446 1
a1446 1
	if (m_iNumPendingConnections != 0)
a1447 1
		m_iNumPendingConnections--;
d1450 4
d1468 1
a1468 1
		m_iNumPendingConnections++;
d1470 1
a1470 1
		if (m_iNumPendingConnections < 1)
d1473 1
a1473 1
			m_iNumPendingConnections = 1;
d1483 1
a1483 1
		while (m_iNumPendingConnections)
d1485 1
a1485 1
			m_iNumPendingConnections--;
@


1.155
log
@better detection of leecher clients
@
text
@d760 1
a760 1
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition();pos != 0;)
d902 1
a902 1
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition();pos != 0;)
d1594 1
a1594 1
	for (POSITION pos = m_openSocketList.GetHeadPosition();pos != 0;pos = m_openSocketList.GetHeadPosition())
@


1.154
log
@corretions in "hash thieves", added Leecher type statistic
@
text
@d1107 1
a1107 16
					if (IsLeecherType(m_pClient->GetModVersion()))
					{
						const uint64 qwIPPortID = m_pClient->GetUID();
						uint32 dwUnfairClientActions = 0;
						OffenseCounterMap::iterator OffenseCounterIt = g_eMuleApp.m_pClientList->m_mapOffenseCounter.find(qwIPPortID);

						if (OffenseCounterIt != g_eMuleApp.m_pClientList->m_mapOffenseCounter.end())
						{
							dwUnfairClientActions = OffenseCounterIt->second;
						}
						InterlockedIncrement(&g_eMuleApp.m_lTotalNumLeecherTypeActions);
						g_eMuleApp.m_pClientList->m_mapOffenseCounter[qwIPPortID] = (dwUnfairClientActions++);
						m_pClient->Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
					}
					else
						m_pClient->SendMuleInfoPacket(true);
a1113 13
					if (IsLeecherType(m_pClient->GetModVersion()))
					{
						const uint64 qwIPPortID = m_pClient->GetUID();
						uint32 dwUnfairClientActions = 0;
						OffenseCounterMap::iterator OffenseCounterIt = g_eMuleApp.m_pClientList->m_mapOffenseCounter.find(qwIPPortID);

						if (OffenseCounterIt != g_eMuleApp.m_pClientList->m_mapOffenseCounter.end())
						{
							dwUnfairClientActions = OffenseCounterIt->second;
						}
						InterlockedIncrement(&g_eMuleApp.m_lTotalNumLeecherTypeActions);
						m_pClient->Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
					}
@


1.153
log
@feature: show number of complete files by search (untested)
@
text
@d1108 11
d1120 1
d1130 10
d1141 1
@


1.152
log
@some refactoring : IsStolenName & IsLeecherType were moved into otherfunctions.cpp
@
text
@d779 1
a779 1
						g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*static_cast<CKnownFile*>(list.GetHead()), packetStream);
d930 1
a930 1
								g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*list.GetHead(), packetStream);
@


1.151
log
@added variable reset for my last fix
@
text
@d1107 1
a1107 1
					if (m_pClient->IsLeecherType())
d1117 1
a1117 1
					if (m_pClient->IsLeecherType())
@


1.150
log
@possible memleak & loss of block request by OP_REQUESTPARTS
@
text
@d484 6
d499 1
@


1.149
log
@OP_OUTOFPARTREQS: reverse changing made by eklmn, because of endless loop
@
text
@d484 21
a504 28

					Requested_Block_Struct* reqblock1 = new Requested_Block_Struct;
					Requested_Block_Struct* reqblock2 = new Requested_Block_Struct;
					Requested_Block_Struct* reqblock3 = new Requested_Block_Struct;

					packetStream.Read(&reqblock1->m_dwStartOffset, 4);
					packetStream.Read(&reqblock2->m_dwStartOffset, 4);
					packetStream.Read(&reqblock3->m_dwStartOffset, 4);
					packetStream.Read(&reqblock1->m_dwEndOffset, 4);
					packetStream.Read(&reqblock2->m_dwEndOffset, 4);
					packetStream.Read(&reqblock3->m_dwEndOffset, 4);
					md4cpy(&reqblock1->m_fileHash, reqfilehash);
					md4cpy(&reqblock2->m_fileHash, reqfilehash);
					md4cpy(&reqblock3->m_fileHash, reqfilehash);
					if (reqblock1->m_dwEndOffset - reqblock1->m_dwStartOffset == 0)
						delete reqblock1;
					else
						m_pClient->AddReqBlock(reqblock1);

					if (reqblock2->m_dwEndOffset - reqblock2->m_dwStartOffset == 0)
						delete reqblock2;
					else
						m_pClient->AddReqBlock(reqblock2);

					if (reqblock3->m_dwEndOffset - reqblock3->m_dwStartOffset == 0)
						delete reqblock3;
					else
						m_pClient->AddReqBlock(reqblock3);
@


1.148
log
@formatting;
removed duplicate code for Starting a Search and Creates ED2KLinks;
first few changes in both code and gui to implement the new search method (ED2KProtocol), don't worry :)
@
text
@d595 6
a600 2
						m_pClient->SendBlockRequests();
						//m_pClient->SetDownloadState(DS_ONQUEUE);
d1049 2
a1050 2
//					AddDebugLogLine(false, RGB_LOG_WARNING _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//					PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
@


1.147
log
@formatting, removed some ending space and minor changes
removed some menus memleak in sharedctrl
fixed new 'LATER' code
changed new paused/stopped file sorting
removed a space not meant to be there in french.rcu
update changelog
@
text
@d1283 2
a1284 1
				/*case OP_VERIFYUPSREQ:{
d1299 2
a1300 1
				}*/
d1302 4
a1305 3
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
//				AddDebugLogLine(false, RGB_LOG_WARNING + _T("unknown extended opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));

@


1.146
log
@formatting; minor changes; something was missed in last commit (Aw3 ???); always keep paused and stopped files at bottom in downloadlist
@
text
@a427 1
					CSafeMemFile packetStream((BYTE*)pcPacketBuf, dwPacketSize);
d429 1
a429 1
					packetStream.Read(&rank, 4);
@


1.145
log
@prevent desyncronisation of requested blocks between local & remote client (fix for written from ... to ...)
@
text
@d216 6
d224 1
a224 1
					if (m_pClient->GetFailedFileRequests() >= 3 && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled())
d355 1
d449 2
a450 2
							//eklmn: sometimes remote client sends us OP_ACCEPTUPLOADREQ during DS_DOWNLOADING state
							// to prevent desynconization of request we gonna clear the list of pending bloks
d555 1
a555 1
				//	haven't made a request) we switch him to an error state. 
d800 1
d802 1
d867 1
d869 1
d1191 1
a1191 1
					memcpy2(&newrank, packet + 0, 2);
d1208 2
a1209 1
						CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)packet);
d1215 2
a1216 2
							DWORD dwTimePassed = ::GetTickCount() - m_pClient->GetLastSrcReqTime() + CONNECTION_LATENCY;
							bool bNeverAskedBefore = m_pClient->GetLastSrcReqTime() == 0;
d1219 6
a1224 8
						    //if not complete and file is rare, allow once every 10 minutes
							    ( file->IsPartFile() &&
							      ((CPartFile*)file)->GetSourceCount() <= RARE_FILE * 2 &&
							      (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK)
							    ) ||
						    //OR if file is not rare or if file is complete, allow every 90 minutes
							    ((bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY))
							)
d1229 2
a1230 1
								Packet		*tosend = file->CreateSrcInfoPacket(m_pClient);
d1235 1
a1235 1
								//AddDebugLogLine(false, "RCV:Source Request User(%s) File(%s)", m_pClient->GetUserName(), file->GetFileName());
@


1.144
log
@extended filtered stats
@
text
@d442 3
@


1.143
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d1352 2
a1353 1
		g_eMuleApp.stat_filteredclients++;
@


1.142
log
@removed MOBILE_MULE and JUMPSTART defines + minor improvements (thx aw3)
@
text
@d1316 1
a1316 1
	uint8 tv = 1;
@


1.141
log
@send a block requests if eDonkey says that he out of blocks
@
text
@a649 1
#if JUMPSTART
d653 1
a653 2
#endif // JUMPSTART
					//--- xrmb:partprio ---
d656 1
a656 1
					//--- :xrmb ---
@


1.140
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d586 2
a587 1
						m_pClient->SetDownloadState(DS_ONQUEUE);
@


1.139
log
@Formatting, comments, and name changes.
@
text
@d1342 1
a1342 1
	memset2(&sockAddr, 0, sizeof(sockAddr));
d1527 1
a1527 1
	memset2(m_ConnectionStates, 0, 6);
@


1.138
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d1444 1
a1444 1
//	OnAccept() is called to notify the m_pRequestSocket that it can accept pending connection requests by calling
d1484 1
a1484 1
//	Process() takes care of cleaning up invalid, deleted, and timed out sockets from the open m_pRequestSocket list.
d1492 1
a1492 1
//	For each open m_pRequestSocket...
d1501 1
a1501 1
	//	If the m_pRequestSocket is marked for deletion...
d1515 1
a1515 1
		//	If the m_pRequestSocket has timed out, disconnect it.
d1611 1
a1611 1
//	IsValidSocket() returns true if 'pSocket' is in the open m_pRequestSocket list.
@


1.137
log
@Formatting, comments, and name changes.
@
text
@d171 1
a171 1
				//	function in ProcessHelloPacket, local trycatch did work. That means even in case of exception 
d241 1
a241 1
						
d376 1
a376 1
				// so we gonna add client to UL-queue anyway, but inside AddClientToQueue() will be checked 
d601 1
a601 1
					
d622 1
a622 1
						
d748 1
a748 1
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition();pos != 0; )
d1084 1
a1084 1
			
@


1.136
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d1232 1
d1235 4
a1238 2
						CSafeMemFile packetStream((BYTE*)packet, size);
						uchar hash[16];
d1240 4
a1243 2
						CKnownFile* file = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
						if (file)
d1245 1
a1245 1
							if (file->IsPartFile())
d1249 2
a1250 2
							//and set the file's last answer time
								((CPartFile*)file)->SetLastAnsweredTime();
d1253 1
a1253 1
								((CPartFile*)file)->AddClientSources(&packetStream, m_pClient->GetSourceExchangeVersion());
@


1.135
log
@Formatting, comments, and name changes.
@
text
@a983 1

a1023 1

d1026 1
d1029 1
d1031 1
d1035 1
@


1.134
log
@minor changes to DebugLog and remove some marks
@
text
@d509 1
a509 1
					g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("%s: Upload session ended due to a canceled transfer."), m_pClient->GetUserName());
d519 1
a519 1
						AddDebugLogLine(false, _T("%s: Upload session ended due ended transfer."), m_pClient->GetUserName());
d543 3
a545 3
					// eklmn: before we process a packet we need to check Download State
					// if client send us a packet in unwanted state (we don't request (need) this packet)
					// we gonna switch him to error state. 
d547 1
d550 1
a550 1
					//	If we make a part file request of this client and the requested file is Waiting...
d556 1
d713 6
a718 3
					uint16 length;
					memcpy2(&length, pcPacketBuf, 2);
					if (length + 2 != dwPacketSize)
d720 7
a726 5
					char* message = new char[length + 1];
					memcpy2(message, pcPacketBuf + 2, length);
					message[length] = 0;
					g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ProcessMessage(m_pClient, message);
					delete[] message;
d730 2
a731 1
				{	// client wants to know what we have in share, let's see if we allow him to know that
d740 4
a743 3
					CPtrList list;
					if ( g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
					     (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
d745 4
a748 3
						CCKey bufKey;
						CKnownFile* cur_file;
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition();pos != 0;)
d756 1
d758 5
d764 1
a764 4
				//	now create the memfile for the pcPacketBuf
					uint32 iTotalCount = list.GetCount();
					CSafeMemFile tempfile(80);
					tempfile.Write(&iTotalCount, 4);
d767 1
a767 1
						g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*(CKnownFile*)list.GetHead(), tempfile);
d770 6
a775 5
				//	create a pcPacketBuf and send it
					Packet* replypacket = new Packet(&tempfile);
					replypacket->m_eOpcode = OP_ASKSHAREDFILESANSWER;
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->m_dwSize);
					SendPacket(replypacket, true, true);
d793 2
a794 2
					if ( g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
					     (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) )
d798 6
a803 1
						CString strDir, strTest;
a804 4
					//	virtual folder list
						CArray<CString, CString&> arFolders;
						CMapStringToString &mapVDirs = g_eMuleApp.m_pSharedFilesList->GetSharedVDirForList();
						POSITION pos = mapVDirs.GetStartPosition();
d807 2
a808 1
							CString strKey, strDir;
d810 4
a813 2
							int i = 0;
							while ((i < arFolders.GetCount()) && (strKey.CompareNoCase(arFolders.GetAt(i)) > 0))
d815 1
a815 1
							arFolders.InsertAt(i, strKey);
d817 11
d829 2
a830 10
					//build pcPacketBuf
						CSafeMemFile tempfile(80);
						uint32 uDirs = arFolders.GetCount();
						tempfile.Write(&uDirs, 4);
						for (int ix = 0; ix < arFolders.GetCount(); ix++)
						{
							const CString &strDir = arFolders.GetAt(ix);
							uint16 cnt = strDir.GetLength();
							tempfile.Write(&cnt, 2);
							tempfile.Write((LPCTSTR)strDir, cnt);
d832 6
a837 4
						Packet* replypacket = new Packet(&tempfile);
						replypacket->m_eOpcode = OP_ASKSHAREDDIRSANS;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->m_dwSize);
						SendPacket(replypacket, true, true);
d842 5
a846 3
						Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS);
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->m_dwSize);
						SendPacket(replypacket, true, true);
d858 8
a865 6
					CSafeMemFile packetStream((uchar*)pcPacketBuf, dwPacketSize);
					uint16 cnt;
					packetStream.Read(&cnt, 2);
					CString strReqDir, strReqVDir;		// #zegzav:vdir4list
					packetStream.Read(strReqVDir.GetBuffer(cnt), cnt);
					strReqVDir.ReleaseBuffer(cnt);
d869 8
a876 7
				//	retrieve real dir from virtual dir
					CMapStringToString &mapVDirs = g_eMuleApp.m_pSharedFilesList->GetSharedVDirForList();	// #zegzav:vdir4list
					bool bReqVDir = mapVDirs.Lookup(strReqVDir, strReqDir);

					if ( (bReqVDir) &&
					     ( g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
					       (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend()) ) )
d881 4
a884 3
						CCKey bufKey;
						CKnownFile* cur_file;
						CTypedPtrList<CPtrList, CKnownFile*> list;
d888 4
a891 2
							g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, cur_file);
							CString strSharedFileDir(cur_file->GetPath());
d895 1
a895 1
								list.AddTail(cur_file);
d902 10
a911 6
							CSafeMemFile tempfile(80);
							uint16 cnt = strReqVDir.GetLength();
							tempfile.Write(&cnt, 2);
							tempfile.Write((LPCTSTR)strReqVDir, cnt);
							uint32 uFiles = list.GetCount();
							tempfile.Write(&uFiles, 4);
d914 1
a914 1
								g_eMuleApp.m_pSharedFilesList->WriteToOfferedFilePacket(*list.GetHead(), tempfile);
d918 5
a922 4
							Packet* replypacket = new Packet(&tempfile);
							replypacket->m_eOpcode = OP_ASKSHAREDFILESDIRANS;
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->m_dwSize);
							SendPacket(replypacket, true, true);
d925 1
d929 5
a933 3
						Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS);
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->m_dwSize);
						SendPacket(replypacket, true, true);
d942 6
a947 4
						CSafeMemFile packetStream((uchar*)pcPacketBuf, dwPacketSize);
						uint32 uDirs;
						packetStream.Read(&uDirs, 4);
						for (UINT i = 0; i < uDirs; i++)
d949 7
a955 5
							uint16 cnt;
							packetStream.Read(&cnt, 2);
							CString strDir;
							packetStream.Read(strDir.GetBuffer(cnt), cnt);
							strDir.ReleaseBuffer(cnt);
d957 15
a971 12
						//PathRemoveBackslash(strDir.GetBuffer());
						//strDir.ReleaseBuffer();
							AddDebugLogLine(false, IDS_SHAREDANSW, m_pClient->GetUserName(), m_pClient->GetUserID(), strDir);

							CSafeMemFile tempfile(80);
							cnt = strDir.GetLength();
							tempfile.Write(&cnt, 2);
							tempfile.Write((LPCTSTR)strDir, cnt);
							Packet* replypacket = new Packet(&tempfile);
							replypacket->m_eOpcode = OP_ASKSHAREDFILESDIR;
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->m_dwSize);
							SendPacket(replypacket, true, true);
d975 1
a975 1
						m_pClient->SetFileListRequested(uDirs);
d978 1
d980 1
d988 14
a1001 8
					CSafeMemFile packetStream((uchar*)pcPacketBuf, dwPacketSize);
					uint16 cnt;
					packetStream.Read(&cnt, 2);
					CString strDir;
					packetStream.Read(strDir.GetBuffer(cnt), cnt);
					strDir.ReleaseBuffer(cnt);
					PathRemoveBackslash(strDir.GetBuffer());
					strDir.ReleaseBuffer();
d1004 2
a1005 2
						AddDebugLogLine(false, IDS_SHAREDINFO1, m_pClient->GetUserName(), m_pClient->GetUserID(), strDir);
						m_pClient->ProcessSharedFileList(pcPacketBuf + packetStream.GetPosition(), dwPacketSize - packetStream.GetPosition(), strDir);
d1007 1
d1009 1
d1012 3
a1014 1
						AddDebugLogLine(false, IDS_SHAREDANSW3, m_pClient->GetUserName(), m_pClient->GetUserID(), strDir);
d1028 2
a1029 2
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
				break;
d1031 3
a1033 3
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(dwPacketSize);
//				AddDebugLogLine(false, RGB_LOG_WARNING + _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//				PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
d1214 2
a1215 1
								Packet* tosend = file->CreateSrcInfoPacket(m_pClient);
@


1.133
log
@Formatting, comments, and name changes.
@
text
@a333 1
				//	DbT:FileRequest
a360 1
				//	DbT:End
a379 1
				//	DbT:StartUploadReq
a416 1
				//	DbT:End
a599 1
				//	DbT:FileRequest
a669 1
				//	DbT:End
d974 2
a975 2
//				AddDebugLogLine(false, RGB_LOG_WARNING _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//				PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d998 3
a1000 3
			AddDebugLogLine( false, GetResString(IDS_ERR_CLIENTERROR) + _T(" (%s)")
			                 , m_pClient->GetUserName(), m_pClient->GetFullIP(), error.GetBuffer(), GetClientNameAndVersionString(m_pClient) );
//			PacketToDebugLogLine(RGB_LOG_WARNING + _T("Unknown client eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d1265 1
a1265 2
		AddDebugLogLine( false, IDS_ERR_BADCLIENT2
		                 , m_pClient->GetUserName(), m_pClient->GetFullIP(), nErrorCode );
@


1.132
log
@Another not useful log line removed
@
text
@d166 1
a166 1
					//	create new client to save standard informations
d170 4
a173 4
					//eklmn: originally we had try & catch here, but cause our EMULE_TRY & EMULE_CATCH
					// function in ProcessHelloPacket, local try&catch did work. That means even in case of exception 
					// we process the client withou full information... so i changed a function to get some info back
					if (!m_pClient->ProcessHelloPacket(pcPacketBuf, dwPacketSize))
d186 1
a186 1
						m_pClient->ProcessHelloPacket(pcPacketBuf, dwPacketSize);
d191 1
a191 1
						//eklmn: if new clieent was not created delete him
a211 1

d215 3
a217 1
				//	check failed(error + scaning) file requests
d220 1
d222 1
d228 3
a230 2
					//eklmn: since we don't process extended information it is better for compatibility with rest of the network
					// alway process a filehas & extended information only if exist and was activated by tag ET_EXTENDEDREQUEST
d236 1
a236 2
						uchar reqfileid[16];
						md4cpy(reqfileid, pcPacketBuf);
d238 3
a240 1
						CKnownFile* m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
d242 1
d245 10
a254 5
						//	if we've just started a download we may want to use that client as a source
						//	eklmn: moreover we also need to check if requested file exist in DL queue
						//	--- in order to filter the clients correct way
							CPartFile* pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(reqfileid);
							if (pPartFile && pPartFile->IsPartFile())
d256 3
a258 1
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > pPartFile->GetSourceCount()) //<<--
d260 1
d262 1
d264 1
d266 1
d268 1
a268 1
						//	check if client are using our userhas (???)
d272 3
a274 3
							/*
							eklmn: removed at 12.12.2003 in order save some traffic & don't send it twice
							//	send file request no such file pcPacketBuf (0x48)
d279 1
a279 1
							*/
d281 1
d284 1
a284 1
							//if wer are downloading this file, this could be a new source
d287 3
a289 1
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqSharedFile)->GetSourceCount()) //<<--
d291 1
d294 1
a294 1
							//	check to see if this is a new file they are asking for
d296 1
d298 23
a320 16
							//	send filename etc
								m_pClient->ResetFailedFileRequests();
								m_pClient->SetUploadFileID((uchar*)pcPacketBuf);
								CSafeMemFile data(128);
								data.Write(m_pReqSharedFile->GetFileHash(), 16);
								uint16 namelength = (uint16)_tcslen(m_pReqSharedFile->GetFileName());
								data.Write(&namelength, 2);
								data.Write(m_pReqSharedFile->GetFileName(), namelength);
							//	TODO: Don't let 'ProcessUpFileStatus' re-process the entire pcPacketBuf and search the fileid
							//	again in 'm_pSharedFilesList' -> waste of time.
								m_pClient->ProcessUpFileStatus(pcPacketBuf, dwPacketSize);
								Packet* pcPacketBuf = new Packet(&data);
								pcPacketBuf->m_eOpcode = OP_FILEREQANSWER;
								g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pcPacketBuf->m_dwSize);
								SendPacket(pcPacketBuf, true);
								m_pClient->SendCommentInfo(m_pReqSharedFile);
d323 1
d385 2
a386 2
						uchar reqfileid[16];
						md4cpy(reqfileid, pcPacketBuf);
d388 1
a388 1
						CKnownFile* m_pReqSharedFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
d407 1
a407 1
							if (!g_eMuleApp.m_pDownloadQueue->GetFileByID(reqfileid))
d425 1
a425 1
					CSafeMemFile data((BYTE*)pcPacketBuf, dwPacketSize);
d427 1
a427 1
					data.Read(&rank, 4);
d438 1
a438 1
				//	modified by sivka [dont download if paused]
d441 2
d457 1
a457 1
						else // added by sivka [dont download if paused]
d459 2
a460 1
							Packet* pcPacketBuf = new Packet(OP_CANCELTRANSFER);
d462 1
a462 1
							m_pClient->m_pRequestSocket->SendPacket(pcPacketBuf, true, true); //eklmn: bugfix(05): Listen soket OP_ACCEPTUPLOADREQ
d473 7
a479 3
					CSafeMemFile data((BYTE*)pcPacketBuf, dwPacketSize);
					uchar reqfilehash[16];
					data.Read(reqfilehash, 16);
d483 7
a489 6
					data.Read(&reqblock1->m_dwStartOffset, 4);
					data.Read(&reqblock2->m_dwStartOffset, 4);
					data.Read(&reqblock3->m_dwStartOffset, 4);
					data.Read(&reqblock1->m_dwEndOffset, 4);
					data.Read(&reqblock2->m_dwEndOffset, 4);
					data.Read(&reqblock3->m_dwEndOffset, 4);
d547 1
a547 1
					// eklmn: before we process a packet we need to check Dowload State
d614 3
a616 3
							//eklmn: if we've just started a download we may want to use that client as a source
							//  moreover we also need to check if requested file exist in DL queue
							//  in order to filter the clients correct way
d626 1
a626 1
							// send file request no such file pcPacketBuf (0x48)
d648 2
a649 2
						CSafeMemFile data(16 + 16);
						data.Write(m_pReqSharedFile->GetFileHash(), 16);
d651 1
a651 1
							((CPartFile*)m_pReqSharedFile)->WritePartStatus(&data);
d655 1
a655 1
							m_pReqSharedFile->WriteJumpstartPartStatus(m_pClient, &data);
d659 1
a659 1
							m_pReqSharedFile->WritePartStatus(&data);
d664 1
a664 1
							data.Write(&null, 3);
d667 1
a667 1
						Packet* pcPacketBuf = new Packet(&data);
d680 1
a680 1
					CSafeMemFile data((BYTE*)pcPacketBuf, dwPacketSize);
d682 1
a682 1
					data.Read(&nNewUserID, 4);
d684 1
a684 1
					data.Read(&nNewServerIP, 4);
d839 1
a839 1
					CSafeMemFile data((uchar*)pcPacketBuf, dwPacketSize);
d841 1
a841 1
					data.Read(&cnt, 2);
d843 1
a843 1
					data.Read(strReqVDir.GetBuffer(cnt), cnt);
d857 1
a857 1
						ASSERT(data.GetPosition() == data.GetLength());
d909 1
a909 1
						CSafeMemFile data((uchar*)pcPacketBuf, dwPacketSize);
d911 1
a911 1
						data.Read(&uDirs, 4);
d915 1
a915 1
							data.Read(&cnt, 2);
d917 1
a917 1
							data.Read(strDir.GetBuffer(cnt), cnt);
d934 1
a934 1
						ASSERT(data.GetPosition() == data.GetLength());
d946 1
a946 1
					CSafeMemFile data((uchar*)pcPacketBuf, dwPacketSize);
d948 1
a948 1
					data.Read(&cnt, 2);
d950 1
a950 1
					data.Read(strDir.GetBuffer(cnt), cnt);
d957 1
a957 1
						m_pClient->ProcessSharedFileList(pcPacketBuf + data.GetPosition(), dwPacketSize - data.GetPosition(), strDir);
d1036 1
a1036 1
					m_pClient->ProcessMuleInfoPacket(packet, size);
d1046 1
a1046 1
					m_pClient->ProcessMuleInfoPacket(packet, size);
d1053 1
a1053 1
					m_pClient->ProcessSecIdentStatePacket((uchar*)packet, size);
d1055 1
d1057 1
d1088 1
a1088 1
					// eklmn: before we process a packet we need to check Dowload State
d1179 1
a1179 1
						CSafeMemFile data((BYTE*)packet, size);
d1181 1
a1181 1
						data.Read(hash, 16);
d1193 1
a1193 1
								((CPartFile*)file)->AddClientSources(&data, m_pClient->GetSourceExchangeVersion());
@


1.131
log
@bracket fault
@
text
@d970 3
a972 3
		else
		{
			AddDebugLogLine(false, IDS_ERR_BADCLIENTACTION, error.GetBuffer());
d974 1
a974 1
		}
@


1.130
log
@small correction
@
text
@d419 1
a419 1
								&& (m_pClient->m_pReqPartFile->GetStatus(false) == PS_READY || m_pClient->m_pReqPartFile->GetStatus(false) == PS_EMPTY)) )
@


1.129
log
@fixed OP_ACCEPTUPLOADREQ to ask for next block
while downloading or connecting
@
text
@d417 1
a417 2
						else if (enumClientDLState == DS_CONNECTED 
								|| (enumClientDLState == DS_ONQUEUE
@


1.128
log
@do not log "filtered"-messages if "do not log coutermeasures" is enabled
@
text
@d411 10
a420 3
					//	eklmn: don't ask for paused files
						if ( enumClientDLState == DS_ONQUEUE && !m_pClient->m_pReqPartFile->IsPaused()
						     && (m_pClient->m_pReqPartFile->GetStatus(false) == PS_READY || m_pClient->m_pReqPartFile->GetStatus(false) == PS_EMPTY) )
@


1.127
log
@roll back for my changes in 1g
@
text
@d220 2
a221 1
						AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) added to filtered clients due to file scanning"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d554 2
a555 1
						AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client %s (%s) added to filtered clients due to file scanning (%s)"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d1244 4
a1247 1
	//AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
d1249 1
a1249 1
	//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
@


1.126
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d399 2
a400 2
					if (rank && m_pClient->GetDownloadState() == DS_DOWNLOADING)
						m_pClient->SetDownloadState(DS_ONQUEUE);
@


1.125
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d220 1
a220 1
						AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Client %s (%s) added to filtered clients due to file scanning"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d252 1
a252 1
								AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Client %s (%s) is using our userhash"), m_pClient->GetUserName(), m_pClient->GetFullIP());
d553 1
a553 1
						AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Client %s (%s) added to filtered clients due to file scanning (%s)"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d934 2
a935 2
//				AddDebugLogLine(false, RGB_LIGHT_ORANGE _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//				PacketToDebugLogLine(RGB_LIGHT_ORANGE + _T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d960 1
a960 1
//			PacketToDebugLogLine(RGB_LIGHT_ORANGE + _T("Unknown client eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d965 1
a965 1
//			PacketToDebugLogLine(RGB_LIGHT_ORANGE + _T("Unknown protocol eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
d1181 1
a1181 1
//				AddDebugLogLine(false, RGB_LIGHT_ORANGE + _T("unknown extended opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
d1242 1
a1242 1
	//AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
@


1.124
log
@Added some colors to the logs...
@
text
@d220 1
a220 1
						AddDebugLogLine(false, _T("<COLOR=102,102,153>Client %s (%s) added to filtered clients due to file scanning"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d252 1
a252 1
								AddDebugLogLine(false, _T("<COLOR=102,102,153>Client %s (%s) is using our userhash"), m_pClient->GetUserName(), m_pClient->GetFullIP());
d553 1
a553 1
						AddDebugLogLine(false, _T("<COLOR=102,102,153>Client %s (%s) added to filtered clients due to file scanning (%s)"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d934 2
a935 2
//				AddDebugLogLine(false, _T("<COLOR=255,102,0>Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//				PacketToDebugLogLine(_T("<COLOR=255,102,0>Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d960 1
a960 1
//			PacketToDebugLogLine(_T("<COLOR=255,102,0>Unknown client eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d965 1
a965 1
//			PacketToDebugLogLine(_T("Unknown protocol eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
d1181 1
a1181 1
//				AddDebugLogLine(false, _T("<COLOR=255,102,0>unknown extended opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
d1242 1
a1242 1
	//AddDebugLogLine(false,_T("<COLOR=102,102,153>Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
d1268 1
a1268 1
//			AddDebugLogLine(false,_T("Received unknown client TCP packet; IP=%s  protocol=0x%02x  opcode=0x%02x  size=%u"), FullUserIP, packet->m_eProtocol, packet->m_eOpcode, packet->m_dwSize);
@


1.123
log
@corrected OP_FILEREQUEST handling
@
text
@d220 1
a220 1
						AddDebugLogLine(false, _T("Client %s (%s) added to filtered clients due to file scanning"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d252 1
a252 1
								AddDebugLogLine(false, _T("Client %s (%s) is using our userhash"), m_pClient->GetUserName(), m_pClient->GetFullIP());
d553 1
a553 1
						AddDebugLogLine(false, _T("Client %s (%s) added to filtered clients due to file scanning (%s)"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
d934 2
a935 2
//				AddDebugLogLine(false, _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
//				PacketToDebugLogLine(_T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d960 1
a960 1
//			PacketToDebugLogLine(_T("Unknown client eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d1181 1
a1181 1
//				AddDebugLogLine(false, _T("unknown extended opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
d1242 1
a1242 1
	//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
@


1.122
log
@1i public release preparations
@
text
@d224 3
a226 2

					if (dwPacketSize == 16 || (dwPacketSize > 16 && m_pClient->GetExtendedRequestsVersion() > 0))
d230 1
d233 1
d235 1
d254 3
a256 2
						//	DbT:FileRequest
						//	send file request no such file pcPacketBuf (0x48)
d261 1
a261 2
						//	DbT:End
							break;
d263 8
d272 20
a291 26
					//	if wer are downloading this file, this could be a new source

						if (m_pReqSharedFile->IsPartFile())
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqSharedFile)->GetSourceCount()) //<<--
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqSharedFile, m_pClient);

					//	check to see if this is a new file they are asking for
						if (md4cmp(m_pClient->m_reqFileHash, pcPacketBuf) != 0)
							m_pClient->SetCommentDirty();

					//	send filename etc
						m_pClient->ResetFailedFileRequests();
						m_pClient->SetUploadFileID((uchar*)pcPacketBuf);
						CSafeMemFile data(128);
						data.Write(m_pReqSharedFile->GetFileHash(), 16);
						uint16 namelength = (uint16)_tcslen(m_pReqSharedFile->GetFileName());
						data.Write(&namelength, 2);
						data.Write(m_pReqSharedFile->GetFileName(), namelength);
					//	TODO: Don't let 'ProcessUpFileStatus' re-process the entire pcPacketBuf and search the fileid
					//	again in 'm_pSharedFilesList' -> waste of time.
						m_pClient->ProcessUpFileStatus(pcPacketBuf, dwPacketSize);
						Packet* pcPacketBuf = new Packet(&data);
						pcPacketBuf->m_eOpcode = OP_FILEREQANSWER;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pcPacketBuf->m_dwSize);
						SendPacket(pcPacketBuf, true);
						m_pClient->SendCommentInfo(m_pReqSharedFile);
@


1.121
log
@prevent generation of the jumping clients (part2)
@
text
@d928 2
a929 2
				AddDebugLogLine(false, _T("Unknown eOpcode: %i %x from %s"), eOpcode, eOpcode, GetClientNameAndVersionString(m_pClient));
				PacketToDebugLogLine(_T("Unknown eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d954 1
a954 1
			PacketToDebugLogLine(_T("Unknown client eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);	// DbT:Logging
d959 1
a959 1
			PacketToDebugLogLine(_T("Unknown protocol eOpcode"), pcPacketBuf, dwPacketSize, eOpcode);
d1175 1
a1175 1
				AddDebugLogLine(false, _T("unknown extended opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
d1262 1
a1262 1
			AddDebugLogLine(false,_T("Received unknown client TCP packet; IP=%s  protocol=0x%02x  opcode=0x%02x  size=%u"), FullUserIP, packet->m_eProtocol, packet->m_eOpcode, packet->m_dwSize);
@


1.120
log
@prevent generation of the jumping clients
@
text
@d417 1
a417 3
							//eklmn: don't put a client in back on the queue if he was found as buggy
							if (enumClientDLState != DS_ERROR)
								m_pClient->SetDownloadState(DS_ONQUEUE);
d1074 1
a1074 1
					if (newrank && m_pClient->GetDownloadState() == DS_DOWNLOADING)
@


1.119
log
@fix in new behaviour after DL timeout
@
text
@d136 2
d399 1
d405 1
a405 1
						if ( m_pClient->GetDownloadState() == DS_ONQUEUE && !m_pClient->m_pReqPartFile->IsPaused()
a415 1
						//m_pClient->m_pRequestSocket->SendPacket(pcPacketBuf,false,true); //eklmn: bugfix(04):
d417 3
a419 1
							m_pClient->SetDownloadState(DS_ONQUEUE);
d501 1
a501 1
					EnumDLQState enumClientDLState = m_pClient->GetDownloadState();
d978 3
a1038 1
					EnumDLQState enumClientDLState = m_pClient->GetDownloadState();
@


1.118
log
@corrected handlilng of hello packet & behaviour after DL timeout
@
text
@d496 1
a496 1
					// we gonna switch him to error state. If client already had an error state we can disconnect him
a526 5
					else if (enumClientDLState == DS_ERROR)
					{
						AddDebugLogLine(false, _T("-eklmn-> Remove a client %s (%s), which send us a data in error state"),m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
						Disconnect();
					}
d1031 1
a1031 1
					// we gonna switch him to error state. If client already had an error state we can disconnect him
a1054 5
					}
					else if (enumClientDLState == DS_ERROR)
					{
						AddDebugLogLine(false, _T("-eklmn-> Remove a client %s (%s), which send us a data in error state"),m_pClient->GetUserName(), GetClientNameAndVersionString(m_pClient));
						Disconnect();
@


1.117
log
@infinite cancel issue
@
text
@d168 4
a171 5
					try
					{
						m_pClient->ProcessHelloPacket(pcPacketBuf, dwPacketSize);
					}
					catch (...)
a173 2
						//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed
						//------ for a client which is not in the list of clients.
d175 1
a176 2
					if (!m_pClient)
						throw CString(_T("Unable to process HelloPacket"));
d494 3
d527 5
d533 1
a533 2
						throw CString(_T("recieved packet in unwanted state. ")+GetStatusDLQueueString(enumClientDLState));
					
a562 7
						/*
						if (!m_pReqSharedFile)
						{
							// Need to send an OP_FILESTATUS for getting an answer for OP_REQUESTSOURCES!!!
							m_pReqSharedFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
						}
						*/
d1036 1
a1036 1
					// we gonna break a connection to force him stop a data transfer
d1061 5
d1067 1
a1067 1
						throw CString(_T("recieved packet in unwanted state. ")+GetStatusDLQueueString(enumClientDLState));
@


1.116
log
@1) remove file from m_otherRequestList in case Stop or Complete
2) handling of data blocks was slightly changed
@
text
@a177 1
						throw;
d179 2
d497 1
d1037 1
@


1.115
log
@Formatting, comments, and name changes.
@
text
@d496 22
a517 10
				//	If we make a part file request of this client and the requested file is Waiting...
					if ( m_pClient->m_pReqPartFile != NULL
					  && ( m_pClient->m_pReqPartFile->GetStatus() == PS_READY
					    || m_pClient->m_pReqPartFile->GetStatus() == PS_EMPTY ) )
					{
						m_pClient->ProcessBlockPacket(pcPacketBuf, dwPacketSize);
						if ( (m_pClient->m_pReqPartFile != NULL)
						  && ( m_pClient->m_pReqPartFile->GetStatus() == PS_PAUSED
						    || m_pClient->m_pReqPartFile->GetStatus() == PS_STOPPED
						    || m_pClient->m_pReqPartFile->GetStatus() == PS_ERROR ) )
d523 1
a525 1
				//	If we didn't want this file (or don't now)...
d527 2
a528 7
					{
						Packet		*pPacket = new Packet(OP_CANCELTRANSFER);

						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
						m_pClient->m_pRequestSocket->SendPacket(pPacket, true, true);
						m_pClient->SetDownloadState(m_pClient->m_pReqPartFile == NULL ? DS_NONE : DS_ONQUEUE);
					}
d1035 20
a1054 8
				//	g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(24);
					if (m_pClient->m_pReqPartFile && (m_pClient->m_pReqPartFile->GetStatus() == PS_READY || m_pClient->m_pReqPartFile->GetStatus() == PS_EMPTY))
					{
						m_pClient->ProcessBlockPacket(packet, size, true);
						if ( (m_pClient->m_pReqPartFile != NULL) &&
						     ( m_pClient->m_pReqPartFile->GetStatus() == PS_PAUSED
						       || m_pClient->m_pReqPartFile->GetStatus() == PS_STOPPED
						       || m_pClient->m_pReqPartFile->GetStatus() == PS_ERROR ) )
d1056 1
a1056 1
							Packet * packet = new Packet(OP_CANCELTRANSFER);
d1059 1
d1063 1
a1063 6
					{
						Packet* packet = new Packet(OP_CANCELTRANSFER);
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
						m_pClient->m_pRequestSocket->SendPacket(packet, true, true);
						m_pClient->SetDownloadState(m_pClient->m_pReqPartFile == NULL ? DS_NONE : DS_ONQUEUE);
					}
d1197 1
a1197 1
	//	Disconnect();
@


1.114
log
@break forgotten in OP_STARTUPLOADREQ (thanks DoubleT)
@
text
@d374 1
a374 1
							//DbT & eklmn: reply that requested file is not exist
d434 10
a443 10
					data.Read(&reqblock1->StartOffset, 4);
					data.Read(&reqblock2->StartOffset, 4);
					data.Read(&reqblock3->StartOffset, 4);
					data.Read(&reqblock1->EndOffset, 4);
					data.Read(&reqblock2->EndOffset, 4);
					data.Read(&reqblock3->EndOffset, 4);
					md4cpy(&reqblock1->FileID, reqfilehash);
					md4cpy(&reqblock2->FileID, reqfilehash);
					md4cpy(&reqblock3->FileID, reqfilehash);
					if (reqblock1->EndOffset - reqblock1->StartOffset == 0)
d448 1
a448 1
					if (reqblock2->EndOffset - reqblock2->StartOffset == 0)
d453 1
a453 1
					if (reqblock3->EndOffset - reqblock3->StartOffset == 0)
@


1.113
log
@disconnect a clients with unknown (buggy) protocol
@
text
@d374 1
a374 1
							// reply that requested file is not exist
d379 1
@


1.112
log
@bigfix in antiscannig feature
@
text
@d1235 2
a1236 2
		ProcessPacket(packet->m_pcBuffer, packet->m_dwSize, packet->m_eOpcode);
		break;
d1238 7
a1244 3
		if (!packet->UnpackPacket())
		{
			ASSERT (false);
a1245 4
		}
		case OP_EMULEPROT:
		ProcessExtPacket(packet->m_pcBuffer, packet->m_dwSize, packet->m_eOpcode);
		break;
d1247 5
a1251 1
		;
@


1.111
log
@stability improvements, i.e. delete a client (sorce) if addition to the client list was failed.
@
text
@d232 2
a233 2
						CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
						if (!m_pReqPartFile)
d237 3
a239 3
						//	--- in order to fileter the clients correct way
							CKnownFile * partfile = g_eMuleApp.m_pDownloadQueue->GetFileByID(reqfileid);
							if (partfile && partfile->IsPartFile())
d241 2
a242 2
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)partfile)->GetSourceCount()) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)partfile, m_pClient);
d248 1
a248 1
							if (!memcmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), m_pClient->GetUserHash(), 16))
d250 1
a250 3
						}
						if (!m_pReqPartFile)
						{
d260 1
d262 4
a265 3
						if (m_pReqPartFile->IsPartFile())
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqPartFile)->GetSourceCount()) //<<--
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqPartFile, m_pClient);
d275 2
a276 2
						data.Write(m_pReqPartFile->GetFileHash(), 16);
						uint16 namelength = (uint16)_tcslen(m_pReqPartFile->GetFileName());
d278 1
a278 1
						data.Write(m_pReqPartFile->GetFileName(), namelength);
d286 1
a286 1
						m_pClient->SendCommentInfo(m_pReqPartFile);
d302 1
a302 1
						CPartFile * m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
d306 4
d352 2
a353 2
						CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
						if (m_pReqPartFile)
d356 3
a358 3
							if (m_pReqPartFile->IsPartFile())
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqPartFile)->GetSourceCount()) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqPartFile, m_pClient);
d366 1
a366 1
							m_pClient->SendCommentInfo(m_pReqPartFile);
d533 9
d548 1
a548 1
						CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)pcPacketBuf);
d551 1
a551 1
						if (!m_pReqPartFile)
d554 1
a554 1
							m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf);
d557 1
a557 1
						if (!m_pReqPartFile)
d559 5
a563 3
							if (!g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)pcPacketBuf))
								m_pClient->UpdateFailedFileRequests();
							if (m_pClient->GetFailedFileRequests() >= 3 && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled())
d565 2
a566 4
								g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(m_pClient->GetIP());
								AddDebugLogLine(false, _T("Client %s (%s) added to filtered clients due to file scanning (%s)"), m_pClient->GetFullIP(), GetClientNameAndVersionString(m_pClient));
								Disconnect();
								break;
d568 4
a571 2

						//	send file request no such file pcPacketBuf (0x48)
d582 3
a584 3
						if (m_pReqPartFile->IsPartFile())
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)m_pReqPartFile)->GetSourceCount())
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)m_pReqPartFile, m_pClient);
d594 3
a596 3
						data.Write(m_pReqPartFile->GetFileHash(), 16);
						if (m_pReqPartFile->IsPartFile())
							((CPartFile*)m_pReqPartFile)->WritePartStatus(&data);
d599 2
a600 2
						else if (m_pReqPartFile->GetJumpstartEnabled())
							m_pReqPartFile->WriteJumpstartPartStatus(m_pClient, &data);
d603 2
a604 2
						else if (m_pReqPartFile->HasHiddenParts())
							m_pReqPartFile->WritePartStatus(&data);
@


1.110
log
@Formatting, comments, and name changes.
@
text
@d192 6
a197 1
						g_eMuleApp.m_pClientList->AddClient(m_pClient);
a199 10

				//	if IP is filtered, dont reply but disconnect...
					/*
					if (g_eMuleApp.m_pIPFilter->IsFiltered(client->GetIP())) {
						AddDebugLogLine(false,_T("Filtered: %s %s "), client->GetFullIP(),g_eMuleApp.m_pIPFilter->GetLastHit());
						client->Disconnected();
						g_eMuleApp.stat_filteredclients++;
						break;
					}
					*/
@


1.109
log
@1) "fixed" bug 0000295
2) some otimization in upload
3) don't upload the file if it has a status COMPLETING
@
text
@d938 1
a938 1
		//TODO write this into a debugfile
d1408 4
d1413 3
a1415 7

void CListenSocket::RemoveSocket(CClientReqSocket* todel)
{
	POSITION todel_pos;
	todel_pos = m_openSocketList.Find(todel);
	if (todel)
		m_openSocketList.RemoveAt(todel_pos);
@


1.108
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d342 3
a367 7
						//at this point client has to already know if file exist or not over OP_FILEREQEST & OP_SETREQFILEID
						//	if he still ask for not existing file, that means client is violated protocol, so we will not him to the UL-queue
						//	!!! Attention
						//	it could be, that there is a problem with the pcPacketBuf dwPacketSize (== 16),
						//	so we leave the function for the time being outside the case.
						//	eklmn will make a detailed test, so that we can be safe, which does not arise a problem
						//g_eMuleApp.m_pUploadQueue->AddClientToQueue(client);
d374 6
@


1.107
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d134 1
a134 1
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, EnumOpcodes opcode)
d140 2
a141 1
			if (!m_pClient && opcode != OP_HELLO)
d143 1
d145 1
a145 1
			switch (opcode)
d149 2
a150 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					m_pClient->ProcessHelloAnswer(packet, size);
d160 1
a160 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d170 1
a170 1
						m_pClient->ProcessHelloPacket(packet, size);
d187 1
a187 1
						m_pClient->ProcessHelloPacket(packet, size);
d208 1
a208 1
				//	send a response packet with standard informations
d221 1
a221 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d231 1
a231 1
					if (size == 16 || (size > 16 && m_pClient->GetExtendedRequestsVersion() > 0))
d236 1
a236 1
						md4cpy(reqfileid, packet);
d259 1
a259 1
						//	send file request no such file packet (0x48)
d261 1
a261 1
							md4cpy(replypacket->m_pcBuffer, packet);
d273 1
a273 1
						if (md4cmp(m_pClient->m_reqFileHash, packet) != 0)
d278 1
a278 1
						m_pClient->SetUploadFileID((uchar*)packet);
d284 1
a284 1
					//	TODO: Don't let 'ProcessUpFileStatus' re-process the entire packet and search the fileid
d286 5
a290 5
						m_pClient->ProcessUpFileStatus(packet, size);
						Packet* packet = new Packet(&data);
						packet->m_eOpcode = OP_FILEREQANSWER;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
						SendPacket(packet, true);
d302 1
a302 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d304 1
a304 1
					if (size == 16)
d307 1
a307 1
						CPartFile * m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
d331 2
a332 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					m_pClient->ProcessFileInfo(packet, size);
d337 2
a338 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					m_pClient->ProcessFileStatus(packet, size);
d343 1
a343 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d345 1
a345 1
					if (size == 16)
d348 1
a348 1
						md4cpy(reqfileid, packet);
d359 1
a359 1
							if (md4cmp(m_pClient->GetUploadFileID(), packet) != 0)
d363 1
a363 1
							m_pClient->SetUploadFileID((uchar*)packet);
d368 1
a368 1
						//	it could be, that there is a problem with the packet size (== 16),
d386 2
a387 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					CSafeMemFile data((BYTE*)packet, size);
d398 1
a398 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d407 1
a407 1
							m_pClient->SetLastDownPart(0xFFFF); // eklmn: feature(00): ICR 2.3 reset part before new download
d412 4
a415 4
							Packet* packet = new Packet(OP_CANCELTRANSFER);
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
						//m_pClient->m_pRequestSocket->SendPacket(packet,false,true); //eklmn: bugfix(04):
							m_pClient->m_pRequestSocket->SendPacket(packet, true, true); //eklmn: bugfix(05): Listen soket OP_ACCEPTUPLOADREQ
d425 2
a426 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					CSafeMemFile data((BYTE*)packet, size);
d459 1
a459 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d467 2
a468 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					if (size >= 16 && !md4cmp(m_pClient->GetUploadFileID(), packet))
d478 2
a479 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
					if (size != 16)
d481 1
a481 1
					m_pClient->SendHashsetPacket(packet);
d486 1
a486 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d489 1
a489 1
					m_pClient->ProcessHashSet(packet, size);
d492 1
a492 1
				case OP_SENDINGPART:
d494 4
a497 2
				//	g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(0, 24);
					if (m_pClient->m_pReqPartFile && (m_pClient->m_pReqPartFile->GetStatus() == PS_READY || m_pClient->m_pReqPartFile->GetStatus() == PS_EMPTY))
d499 5
a503 5
						m_pClient->ProcessBlockPacket(packet, size);
						if ( (m_pClient->m_pReqPartFile != NULL) &&
						     ( m_pClient->m_pReqPartFile->GetStatus() == PS_PAUSED
						       || m_pClient->m_pReqPartFile->GetStatus() == PS_STOPPED
						       || m_pClient->m_pReqPartFile->GetStatus() == PS_ERROR ) )
d505 4
a508 3
							Packet * packet = new Packet(OP_CANCELTRANSFER);
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
							m_pClient->m_pRequestSocket->SendPacket(packet, true, true);
d511 1
d514 4
a517 3
						Packet* packet = new Packet(OP_CANCELTRANSFER);
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
						m_pClient->m_pRequestSocket->SendPacket(packet, true, true);
d524 1
a524 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d531 1
a531 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadFileRequest(size);
d533 1
a533 1
					if (size == 16)
d538 1
a538 1
						CKnownFile* m_pReqPartFile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)packet);
d544 1
a544 1
							m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
d549 1
a549 1
							if (!g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet))
d559 1
a559 1
						//	send file request no such file packet (0x48)
d561 1
a561 1
							md4cpy(replypacket->m_pcBuffer, packet);
d575 1
a575 1
						if (md4cmp(m_pClient->GetUploadFileID(), packet) != 0)
d579 2
a580 2
						m_pClient->SetUploadFileID((uchar*)packet);
					//md4cpy(m_pClient->m_reqFileHash,packet);
d600 4
a603 4
						Packet* packet = new Packet(&data);
						packet->m_eOpcode = OP_FILESTATUS;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
						SendPacket(packet, true);
d612 2
a613 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					CSafeMemFile data((BYTE*)packet, size);
d643 1
a643 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d649 1
a649 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d651 3
a653 3
					memcpy2(&length, packet, 2);
					if (length + 2 != size)
						throw CString("invalid message packet");
d655 1
a655 1
					memcpy2(message, packet + 2, length);
d663 1
a663 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d687 1
a687 1
				//	now create the memfile for the packet
d696 1
a696 1
				//	create a packet and send it
d705 2
a706 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					m_pClient->ProcessSharedFileList(packet, size);
d711 2
a712 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					ASSERT(size == 0);
d739 1
a739 1
					//build packet
d766 1
a766 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d772 1
a772 1
					CSafeMemFile data((uchar*)packet, size);
d839 1
a839 1
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d842 1
a842 1
						CSafeMemFile data((uchar*)packet, size);
d878 2
a879 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					CSafeMemFile data((uchar*)packet, size);
d890 1
a890 1
						m_pClient->ProcessSharedFileList(packet + data.GetPosition(), size - data.GetPosition(), strDir);
d900 2
a901 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					ASSERT(size == 0);
d909 1
a909 1
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
d912 3
a914 3
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
				AddDebugLogLine(false, _T("Unknown opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
				PacketToDebugLogLine(_T("Unknown opcode"), packet, size, opcode);	// DbT:Logging
d939 1
a939 1
			PacketToDebugLogLine(_T("Unknown client opcode"), packet, size, opcode);	// DbT:Logging
d944 1
a944 1
			PacketToDebugLogLine(_T("Unknown protocol opcode"), packet, size, opcode);
@


1.106
log
@no message
@
text
@d56 1
a56 1
	if (m_pClient)
d127 1
a127 1
	if (m_pClient)
d235 2
a236 2
						CKnownFile* reqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
						if (!reqfile)
d254 1
a254 1
						if (!reqfile)
d266 3
a268 3
						if (reqfile->IsPartFile())
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount()) //<<--
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile, m_pClient);
d271 1
a271 1
						if (md4cmp(m_pClient->reqfileid, packet) != 0)
d278 2
a279 2
						data.Write(reqfile->GetFileHash(), 16);
						uint16 namelength = (uint16)_tcslen(reqfile->GetFileName());
d281 1
a281 1
						data.Write(reqfile->GetFileName(), namelength);
d289 1
a289 1
						m_pClient->SendCommentInfo(reqfile);
d305 2
a306 2
						CPartFile * reqfile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
						if (!reqfile)
d348 2
a349 2
						CKnownFile* reqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(reqfileid);
						if (reqfile)
d352 3
a354 3
							if (reqfile->IsPartFile())
								if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount()) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile, m_pClient);
d362 1
a362 1
							m_pClient->SendCommentInfo(reqfile);
d398 1
a398 1
					if (m_pClient->reqfile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(m_pClient->reqfile))
d401 2
a402 2
						if ( m_pClient->GetDownloadState() == DS_ONQUEUE && !m_pClient->reqfile->IsPaused()
						     && (m_pClient->reqfile->GetStatus(false) == PS_READY || m_pClient->reqfile->GetStatus(false) == PS_EMPTY) )
d418 1
a418 1
						throw CString(GetResString(IDS_ERR_WRONGFILEID) + _T(" (OP_ACCEPTUPLOADREQ => !reqfile)"));
d493 1
a493 1
					if (m_pClient->reqfile && (m_pClient->reqfile->GetStatus() == PS_READY || m_pClient->reqfile->GetStatus() == PS_EMPTY))
d496 4
a499 4
						if ( (m_pClient->reqfile != NULL) &&
						     ( m_pClient->reqfile->GetStatus() == PS_PAUSED
						       || m_pClient->reqfile->GetStatus() == PS_STOPPED
						       || m_pClient->reqfile->GetStatus() == PS_ERROR ) )
d511 1
a511 1
						m_pClient->SetDownloadState(m_pClient->reqfile == NULL ? DS_NONE : DS_ONQUEUE);
d531 1
a531 1
						CKnownFile* reqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)packet);
d534 1
a534 1
						if (!reqfile)
d537 1
a537 1
							reqfile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
d540 1
a540 1
						if (!reqfile)
d563 3
a565 3
						if (reqfile->IsPartFile())
							if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount())
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile, m_pClient);
d573 1
a573 1
					//md4cpy(m_pClient->reqfileid,packet);
d575 3
a577 3
						data.Write(reqfile->GetFileHash(), 16);
						if (reqfile->IsPartFile())
							((CPartFile*)reqfile)->WritePartStatus(&data);
d580 2
a581 2
						else if (reqfile->GetJumpstartEnabled())
							reqfile->WriteJumpstartPartStatus(m_pClient, &data);
d584 2
a585 2
						else if (reqfile->HasHiddenParts())
							reqfile->WritePartStatus(&data);
d611 1
a611 1
					if (nNewUserID < 16777216)
d1009 1
a1009 1
					if (m_pClient->reqfile && (m_pClient->reqfile->GetStatus() == PS_READY || m_pClient->reqfile->GetStatus() == PS_EMPTY))
d1012 4
a1015 4
						if ( (m_pClient->reqfile != NULL) &&
						     ( m_pClient->reqfile->GetStatus() == PS_PAUSED
						       || m_pClient->reqfile->GetStatus() == PS_STOPPED
						       || m_pClient->reqfile->GetStatus() == PS_ERROR ) )
d1027 1
a1027 1
						m_pClient->SetDownloadState(m_pClient->reqfile == NULL ? DS_NONE : DS_ONQUEUE);
d1408 15
@


1.105
log
@no message
@
text
@d128 2
a129 2
		m_pClient->m_pRequestSocket = 0;
	m_pClient = 0;
@


1.104
log
@A number of robustification changes.
@
text
@d17 1
a17 1
// ListenSocket.cpp : implementation file
d33 1
a33 1
static char THIS_FILE[]=__FILE__;
d41 3
a43 2
// CClientReqSocket
CClientReqSocket::CClientReqSocket(CPreferences* in_prefs,CUpDownClient* in_client){
d47 1
a47 1
		m_pClient->socket = this;
d54 2
a55 1
CClientReqSocket::~CClientReqSocket(){
d57 2
a58 2
		m_pClient->socket = 0;
	m_pClient = 0;
d64 2
a65 1
void CClientReqSocket::ResetTimeOutTimer(){
d69 2
a70 2
//	CheckTimeOut() checks the timeout timer, and, if it has expired, it disconnects the socket
//		and resets the timeout timer. It returns true if the timer has expired, false if it has not.
d84 2
a85 1
void CClientReqSocket::OnClose(int nErrorCode){
d93 1
a93 1
//	Tell the socket not to receive any more notifications
d96 1
a96 1
    if (m_pClient != NULL && !g_eMuleApp.m_pClientList->IsValidClient(m_pClient))// obaldin: a quick fix for a strange bug
d98 3
a100 3
        AddDebugLogLine(false, _T("Invalid client in CClientReqSocket::Disconnect()"));
        m_pClient = NULL;
    }
d102 1
d104 1
d106 4
a109 1
		m_pClient->Disconnected();	//TODO: Fix this so that 'm_pClient' is NULLed if the client is destroyed.
d114 1
a114 1
//	It seems that MFC Sockets call socketfunctions after they are deleted, even if the socket is closed
d120 2
a121 1
void CClientReqSocket::Safe_Delete(){
d128 1
a128 1
		m_pClient->socket = 0;
d136 4
a139 2
	try{
		try{
d142 5
a146 3
			
			switch(opcode){
				case OP_HELLOANSWER:{
d148 1
a148 1
					m_pClient->ProcessHelloAnswer(packet,size);
d156 2
a157 1
				case OP_HELLO:{
d160 3
a162 2
					if (!m_pClient){
						// create new client to save standard informations
d166 3
a168 2
					try {
						m_pClient->ProcessHelloPacket(packet,size);
d170 2
a171 1
					catch(...) {
d173 2
a174 2
							//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed
							//------ for a client which is not in the list of clients.
d178 8
a185 7
					// now we check if we now this client already. if yes this socket will
					// be attached to the known client, the new client will be deleted
					// and the var. "client" will point to the known client.
					// if not we keep our new-constructed client ;)
					if (g_eMuleApp.m_pClientList->AttachToAlreadyKnown(&m_pClient,this)){
						// update the old client informations
						m_pClient->ProcessHelloPacket(packet,size);
d188 2
a189 1
					else {
d194 1
a194 1
					// if IP is filtered, dont reply but disconnect...
d206 1
a206 1
					// send a response packet with standard informations
d209 1
a209 1
					
d220 1
a220 1
					// check failed(error + scaning) file requests
d224 1
a224 1
						AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due to file scanning"),m_pClient->GetFullIP(),GetClientNameAndVersionString(m_pClient));
d227 1
a227 1
					}	
d234 1
a234 1
						md4cpy(reqfileid,packet);
d238 4
a241 4
							// if we've just started a download we may want to use that client as a source
							// eklmn: moreover we also need to check if requested file exist in DL queue
							// --- in order to fileter the clients correct way
							CKnownFile* partfile = g_eMuleApp.m_pDownloadQueue->GetFileByID(reqfileid);
d244 2
a245 2
								if( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)partfile)->GetSourceCount() ) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)partfile,m_pClient);
d249 4
a252 4
								
							// check if client are using our userhas (???)
							if (!memcmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), m_pClient->GetUserHash(),16)) 
								AddDebugLogLine(false,_T("Client %s (%s) is using our userhash"),m_pClient->GetUserName(),m_pClient->GetFullIP());
d256 3
a258 3
							// DbT:FileRequest
							// send file request no such file packet (0x48)
							Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
d262 1
a262 1
							// DbT:End
d265 1
a265 1
						// if wer are downloading this file, this could be a new source
d267 5
a271 5
							if( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() ) //<<--
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile,m_pClient);
						
						// check to see if this is a new file they are asking for
						if(md4cmp(m_pClient->reqfileid, packet) != 0)
d274 1
a274 1
						// send filename etc
d278 1
a278 1
						data.Write(reqfile->GetFileHash(),16);
d280 5
a284 5
						data.Write(&namelength,2);
						data.Write(reqfile->GetFileName(),namelength);
						// TODO: Don't let 'ProcessUpFileStatus' re-process the entire packet and search the fileid
						// again in 'm_pSharedFilesList' -> waste of time.
						m_pClient->ProcessUpFileStatus(packet,size);
d288 1
a288 1
						SendPacket(packet,true);
d294 1
a294 1
						throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ _T(" (OP_FILEREQUEST)"));
d298 2
a299 1
				case OP_FILEREQANSNOFIL:{
d301 7
a307 6
				// DbT:FileRequest
				if (size == 16) {
					// if that client do not have my file maybe has another different
					CPartFile* reqfile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
					if (!reqfile)
						break;
d309 12
a320 7
					// we try to swap to another file ignoring no needed parts files
					if (m_pClient) switch (m_pClient->GetDownloadState()) {
						case DS_ONQUEUE:
						case DS_NONEEDEDPARTS:
						if (!m_pClient->SwapToAnotherFile(NULL)) {	//eklmn: bugfix(08): A4AF switching (???)
							g_eMuleApp.m_pDownloadQueue->RemoveSource(m_pClient, true);
						}
d323 1
d325 1
d327 2
a328 5
				throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ _T(" (OP_FILEREQANSNOFIL)")); 
				break;
				// DbT:End
				}
				case OP_FILEREQANSWER:{
d330 1
a330 1
					m_pClient->ProcessFileInfo(packet,size);
d333 2
a334 1
				case OP_FILESTATUS:{
d336 1
a336 1
					m_pClient->ProcessFileStatus(packet,size);
d342 2
a343 2
					// DbT:StartUploadReq
					if( size == 16 )
d346 2
a347 2
						md4cpy(reqfileid,packet);
						//check if file exits
d351 1
a351 1
							// if wer are downloading this file, this could be a new source
d353 2
a354 2
								if( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() ) //<<--
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile,m_pClient);
d356 2
a357 2
							// check to see if this is a new file they are asking for
							if(md4cmp(m_pClient->GetUploadFileID(), packet) != 0)
d363 7
a369 7
							//at this point client has to already know if file exist or not over OP_FILEREQEST & OP_SETREQFILEID
							// if he still ask for not existing file, that means client is violated protocol, so we will not him to the UL-queue
							// !!! Attention
							// it could be, that there is a problem with the packet size (== 16),
							// so we leave the function for the time being outside the case.
							// eklmn will make a detailed test, so that we can be safe, which does not arise a problem
							//g_eMuleApp.m_pUploadQueue->AddClientToQueue(client);
d373 1
a373 1
							//eklmn: if client still asking for not existing, he is definitely violating eDonkey protocol
d380 1
a380 1
					// DbT:End
d385 1
a385 1
					CSafeMemFile data((BYTE*)packet,size);
d387 3
a389 3
					data.Read(&rank,4);
					m_pClient->SetRemoteQueueRank(rank);					
					// eklmn: switch DL state in case newrank != 0
d397 2
a398 2
					// modified by sivka [dont download if paused]
					if(m_pClient->reqfile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(m_pClient->reqfile))
d400 3
a402 3
						// eklmn: don't ask for paused files
						if (m_pClient->GetDownloadState() == DS_ONQUEUE && !m_pClient->reqfile->IsPaused() 
						&& (m_pClient->reqfile->GetStatus(false) == PS_READY || m_pClient->reqfile->GetStatus(false) == PS_EMPTY))
d405 1
a405 1
							m_pClient->SetLastDownPart(0xFFFF); // eklmn: feature(00): ICR 2.3 reset part before new download 
d412 2
a413 2
							//m_pClient->socket->SendPacket(packet,false,true); //eklmn: bugfix(04): 
							m_pClient->socket->SendPacket(packet,true,true); //eklmn: bugfix(05): Listen soket OP_ACCEPTUPLOADREQ
d418 1
a418 1
						throw CString(GetResString(IDS_ERR_WRONGFILEID)+ _T(" (OP_ACCEPTUPLOADREQ => !reqfile)"));
d421 2
a422 1
				case OP_REQUESTPARTS:{
d424 1
a424 1
					CSafeMemFile data((BYTE*)packet,size);
d426 1
a426 1
					data.Read(reqfilehash,16);
d430 10
a439 10
					data.Read(&reqblock1->StartOffset,4);
					data.Read(&reqblock2->StartOffset,4);
					data.Read(&reqblock3->StartOffset,4);
					data.Read(&reqblock1->EndOffset,4);
					data.Read(&reqblock2->EndOffset,4);
					data.Read(&reqblock3->EndOffset,4);
					md4cpy(&reqblock1->FileID,reqfilehash);
					md4cpy(&reqblock2->FileID,reqfilehash);
					md4cpy(&reqblock3->FileID,reqfilehash);
					if (reqblock1->EndOffset-reqblock1->StartOffset == 0)			
d444 1
a444 1
					if (reqblock2->EndOffset-reqblock2->StartOffset == 0)			
d449 1
a449 1
					if (reqblock3->EndOffset-reqblock3->StartOffset == 0)			
d455 2
a456 1
				case OP_CANCELTRANSFER:{
d458 1
a458 1
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(m_pClient,ETS_CANCELED);
d466 3
a468 2
					if (size>=16 && !md4cmp(m_pClient->GetUploadFileID(),packet)){
						g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(m_pClient,ETS_END_OF_DOWNLOAD);
d473 3
a475 2
				}				
				case OP_HASHSETREQUEST:{
d482 2
a483 1
				case OP_HASHSETANSWER:{
d485 3
a487 3
                    //if (m_pClient->GetDownloadState() != DS_REQHASHSET)
                    //    throw CString("unwanted hashset");
					m_pClient->ProcessHashSet(packet,size);
d492 1
a492 1
//					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(0, 24);
d495 5
a499 5
						m_pClient->ProcessBlockPacket(packet,size);
						if ((m_pClient->reqfile != NULL) &&
							(m_pClient->reqfile->GetStatus()==PS_PAUSED 
							|| m_pClient->reqfile->GetStatus()==PS_STOPPED
							|| m_pClient->reqfile->GetStatus()==PS_ERROR))
d501 1
a501 1
							Packet* packet = new Packet(OP_CANCELTRANSFER);
d503 1
a503 1
							m_pClient->socket->SendPacket(packet,true,true);
d506 2
a507 1
					else{
d510 2
a511 2
						m_pClient->socket->SendPacket(packet,true,true);
						m_pClient->SetDownloadState(m_pClient->reqfile==NULL ? DS_NONE : DS_ONQUEUE);
d515 2
a516 1
				case OP_OUTOFPARTREQS:{
d525 1
a525 1
					// DbT:FileRequest
d528 1
a528 1
						if (!m_pClient->GetWaitStartTime()) 
d547 1
a547 1
								AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due to file scanning (%s)"),m_pClient->GetFullIP(),GetClientNameAndVersionString(m_pClient));
d551 2
a552 2
						
							// send file request no such file packet (0x48)
d560 1
a560 1
						// eklmn: reset Failed Request Counter
d562 1
a562 1
						// if we are downloading this file, this could be a new source
d564 2
a565 2
							if( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() )
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile,m_pClient); 
d567 2
a568 2
						// check to see if this is a new file they are asking for
						if(md4cmp(m_pClient->GetUploadFileID(), packet) != 0)
d571 1
a571 1
						//send filestatus
d573 3
a575 3
						//md4cpy(m_pClient->reqfileid,packet);
						CSafeMemFile data(16+16);
						data.Write(reqfile->GetFileHash(),16);
d579 2
a580 1
                    				else if (reqfile->GetJumpstartEnabled())
d583 2
a584 2
						//--- xrmb:partprio ---
						else if(reqfile->HasHiddenParts())
d586 2
a587 2
						//--- :xrmb ---
						else 
d590 1
a590 1
							data.Write(&null,3);
d596 1
a596 1
						SendPacket(packet,true);
d599 1
a599 1
						throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ _T(" (OP_SETREQFILEID)"));
d601 1
a601 1
					// DbT:End
d611 5
a615 3
					if (nNewUserID < 16777216){ // client changed server and gots a LowID
						CServer* pNewServer = g_eMuleApp.m_pServerList->GetServerByIP(nNewServerIP);
						if (pNewServer != NULL){
d621 2
a622 1
					else if (nNewUserID == m_pClient->GetIP()){ // client changed server and gots a HighID(IP)
d625 2
a626 1
						if (pNewServer != NULL){
d630 1
a630 1
					}					
d637 1
a637 1
					// sometimes sent by Hybrid
d640 2
a641 1
				case OP_MESSAGE:{
d644 2
a645 2
					memcpy2(&length,packet,2);
					if (length+2 != size)
d647 2
a648 2
					char* message = new char[length+1];
					memcpy2(message,packet+2,length);
d650 1
a650 1
					g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ProcessMessage(m_pClient,message);
d654 2
a655 1
				case OP_ASKSHAREDFILES:	{	// client wants to know what we have in share, let's see if we allow him to know that
d657 5
a661 4
					
					// IP banned, no answer for this request
					if (m_pClient->IsBanned() ){
						break;						
d665 2
a666 2
					if (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
						(g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend() ) )
d670 3
a672 2
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition();pos != 0;){
							g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos,bufKey,cur_file);
d675 4
a678 2
						AddDebugLogLine(false,IDS_REQ_SHAREDFILES,m_pClient->GetUserName(),m_pClient->GetUserID(),GetResString(IDS_ACCEPTED) );
					} else AddDebugLogLine(false,IDS_REQ_SHAREDFILES,m_pClient->GetUserName(),m_pClient->GetUserID(),GetResString(IDS_DENIED) );
d680 1
a680 1
					// now create the memfile for the packet
d689 1
a689 1
					// create a packet and send it
d696 2
a697 1
				case OP_ASKSHAREDFILESANSWER:{
d699 1
a699 1
					m_pClient->ProcessSharedFileList(packet,size);
d705 1
a705 11
					ASSERT( size == 0 );
					
					// IP banned, no answer for this request
					if (m_pClient->IsBanned() )	break;						

					if (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
						(g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend() ) )
					{
						AddDebugLogLine(false,IDS_SHAREDREQ1,m_pClient->GetUserName(),m_pClient->GetUserID(),GetResString(IDS_ACCEPTED) );
 
						CString strDir,strTest;
d707 12
a718 1
						// virtual folder list
d720 2
a721 2
						CMapStringToString &mapVDirs= g_eMuleApp.m_pSharedFilesList->GetSharedVDirForList();
						POSITION pos= mapVDirs.GetStartPosition();
d726 1
a726 1
							int i= 0;
d732 1
a732 1
						//build packet
d736 1
a736 1
						for (int ix= 0; ix < arFolders.GetCount(); ix++)
d750 1
a750 1
						AddDebugLogLine(false,IDS_SHAREDREQ1,m_pClient->GetUserName(),m_pClient->GetUserID(),GetResString(IDS_DENIED) );
d760 4
a763 3
					
					// IP banned, no answer for this request
					if (m_pClient->IsBanned() ) break;
d773 8
a780 8
 
					// retrieve real dir from virtual dir
					CMapStringToString &mapVDirs= g_eMuleApp.m_pSharedFilesList->GetSharedVDirForList();	// #zegzav:vdir4list
					bool bReqVDir= mapVDirs.Lookup(strReqVDir, strReqDir);

					if  ( (bReqVDir) &&
						  (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
						   (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && m_pClient->IsFriend() ) ) )
d782 2
a783 2
						AddDebugLogLine(false,IDS_SHAREDREQ2,m_pClient->GetUserName(),m_pClient->GetUserID(),strReqVDir,strReqDir,GetResString(IDS_ACCEPTED) );
						ASSERT( data.GetPosition() == data.GetLength() );
d788 1
a788 1
						
d795 2
a796 1
							if (strReqDir.CompareNoCase(strSharedFileDir) == 0) list.AddTail(cur_file);
d798 3
a800 3
 
						// Currently we are sending each shared directory, even if it does not contain any files.
						// Because of this we also have to send an empty shared files list..
d823 1
a823 1
						AddDebugLogLine(false,IDS_SHAREDREQ2,m_pClient->GetUserName(),m_pClient->GetUserID(),strReqVDir,strReqDir,GetResString(IDS_DENIED) );
d845 4
a848 4
							// Better send the received and untouched directory string back to that client
							//PathRemoveBackslash(strDir.GetBuffer());
							//strDir.ReleaseBuffer();
							AddDebugLogLine(false,IDS_SHAREDANSW,m_pClient->GetUserName(),m_pClient->GetUserID(),strDir);
d860 1
a860 1
						ASSERT( data.GetPosition() == data.GetLength() );
d864 1
a864 1
						AddDebugLogLine(false,IDS_SHAREDANSW2,m_pClient->GetUserName(),m_pClient->GetUserID());
d882 1
a882 1
						AddDebugLogLine(false,IDS_SHAREDINFO1,m_pClient->GetUserName(),m_pClient->GetUserID(),strDir);
d885 1
a885 1
							AddDebugLogLine(false,IDS_SHAREDINFO2,m_pClient->GetUserName(),m_pClient->GetUserID());
d888 1
a888 1
						AddDebugLogLine(false,IDS_SHAREDANSW3,m_pClient->GetUserName(),m_pClient->GetUserID(),strDir);
d894 2
a895 2
					ASSERT( size == 0 );
					AddLogLine(true,IDS_SHAREDREQDENIED,m_pClient->GetUserName(),m_pClient->GetUserID());
d902 2
a903 2
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					break;
d905 3
a907 3
					g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
					AddDebugLogLine(false,_T("Unknown opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(m_pClient));
					PacketToDebugLogLine(_T("Unknown opcode"), packet, size, opcode);	// DbT:Logging
d910 2
a911 1
		catch(CFileException* error){
d916 2
a917 1
		catch(CMemoryException* error){
d923 2
a924 1
	catch(CString error){
d926 6
a931 5
		if (m_pClient){
			m_pClient->SetDownloadState(DS_ERROR);	
			//TODO write this into a debugfile
			AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERROR)+ _T(" (%s)")
			,m_pClient->GetUserName(),m_pClient->GetFullIP(),error.GetBuffer(), GetClientNameAndVersionString(m_pClient));
d934 3
a936 2
		else {
			AddDebugLogLine(false,IDS_ERR_BADCLIENTACTION,error.GetBuffer());
d939 1
a939 1
			
d948 29
a976 23
	try{
		try{
		if (!m_pClient)
			throw GetResString(IDS_ERR_UNKNOWNCLIENTACTION);
		switch(opcode){
			case OP_EMULEINFO:{
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
				m_pClient->ProcessMuleInfoPacket(packet,size);
				if (m_pClient->IsLeecherType())
					m_pClient->Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
				else
				m_pClient->SendMuleInfoPacket(true);
				break;
			}
			case OP_EMULEINFOANSWER:{
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
				m_pClient->ProcessMuleInfoPacket(packet,size);
				if (m_pClient->IsLeecherType())
					m_pClient->Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
				break;
			}
				case OP_SECIDENTSTATE:{
					m_pClient->ProcessSecIdentStatePacket((uchar*)packet,size);
d979 2
a980 1
					else if (m_pClient->GetSecureIdentState() == IS_KEYANDSIGNEEDED){
d986 5
a990 3
				case OP_PUBLICKEY:{
					if (m_pClient->IsBanned() ){
						break;						
d992 1
a992 1
					m_pClient->ProcessPublicKeyPacket((uchar*)packet,size);
d995 3
a997 2
  				case OP_SIGNATURE:{
					m_pClient->ProcessSignaturePacket((uchar*)packet,size);
d999 2
a1000 1
					DEBUG_ONLY(AddDebugLogLine(false,"-->Signature Received"));
d1002 1
d1005 2
a1006 5
			
			case OP_COMPRESSEDPART:
			{
//				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(24);
				if (m_pClient->reqfile && (m_pClient->reqfile->GetStatus()==PS_READY || m_pClient->reqfile->GetStatus()==PS_EMPTY))
d1008 15
a1022 5
					m_pClient->ProcessBlockPacket(packet,size,true);
					if ((m_pClient->reqfile != NULL) &&
						(m_pClient->reqfile->GetStatus()==PS_PAUSED 
						|| m_pClient->reqfile->GetStatus()==PS_STOPPED
						|| m_pClient->reqfile->GetStatus()==PS_ERROR))
d1026 2
a1027 1
						m_pClient->socket->SendPacket(packet,true,true);
d1029 1
d1031 1
a1031 1
				else
d1033 11
a1043 4
					Packet* packet = new Packet(OP_CANCELTRANSFER);
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
					m_pClient->socket->SendPacket(packet,true,true);
					m_pClient->SetDownloadState(m_pClient->reqfile==NULL ? DS_NONE : DS_ONQUEUE);
d1045 1
a1045 18
				break;
			}
			case OP_QUEUERANKING:{
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
				if (size != 12)
					throw GetResString(IDS_ERR_BADSIZE);
				uint16 newrank;
				memcpy2(&newrank,packet+0,2);
				m_pClient->SetRemoteQueueFull(false);
				m_pClient->SetRemoteQueueRank(newrank);
				// eklmn: switch DL state in case newrank != 0
				if (newrank && m_pClient->GetDownloadState() == DS_DOWNLOADING)
					m_pClient->SetDownloadState(DS_ONQUEUE);
				break;
			}
 			case OP_REQUESTSOURCES:{
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadSourceExchange(size);
				if (m_pClient->GetSourceExchangeVersion() >= 1)
d1047 6
a1052 3
					if(size != 16)
						throw GetResString(IDS_ERR_BADSIZE);
	
d1054 10
a1063 10
					CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID((uchar*)packet);
					if(!file)
						file = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
	
					if(file) 
					{
						DWORD dwTimePassed = ::GetTickCount() - m_pClient->GetLastSrcReqTime() + CONNECTION_LATENCY;
						bool bNeverAskedBefore = m_pClient->GetLastSrcReqTime() == 0;
	
						if( 
d1065 4
a1068 4
						    ( file->IsPartFile() &&
						     ((CPartFile*)file)->GetSourceCount() <= RARE_FILE * 2 &&
						      (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK)
						    ) ||
d1070 10
a1079 8
						    ( (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY) )
						  ) {
	
							m_pClient->SetLastSrcReqTime();
							Packet* tosend = file->CreateSrcInfoPacket(m_pClient);
							if(tosend){
								g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(tosend->m_dwSize);
								SendPacket(tosend, true, true);
d1081 1
d1084 2
a1085 1
						}
d1087 13
a1099 11
				break;
			}
 			case OP_ANSWERSOURCES:{
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadSourceExchange(size);
				try{
					CSafeMemFile data((BYTE*)packet,size);
					uchar hash[16];
					data.Read(hash,16);
					CKnownFile* file = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)packet);
					if(file){
						if (file->IsPartFile()){
d1101 1
a1101 1
							m_pClient->SetLastSrcAnswerTime();
d1103 2
a1104 2
							((CPartFile*)file)->SetLastAnsweredTime();
	
d1106 2
a1107 1
							((CPartFile*)file)->AddClientSources(&data, m_pClient->GetSourceExchangeVersion());
d1110 7
d1118 5
a1122 4
				catch(CFileException* error){
					OUTPUT_DEBUG_TRACE();
					error->Delete();
					throw GetResString(IDS_ERR_INVALIDPACKAGE);
d1124 17
a1140 3
				break;
			}
			case OP_FILEDESC:{
d1142 2
a1143 23
				m_pClient->ProcessMuleCommentPacket(packet,size);
				break;
			}
			/*case OP_VERIFYUPSREQ:{
				CUpDownClient* vuclient = g_eMuleApp.m_pClientList->VUGetRandomClient();
				if (vuclient){
					Packet* answer = new Packet(OP_VERIFYUPSANSWER,6,OP_EMULEPROT);
					uint32 ip = vuclient->GetIP();
					memcpy2(answer->m_pcBuffer,ip,4);
					uint16 udpport = vuclient->GetUDPPort();
					memcpy2(answer->m_pcBuffer,ip,4);
					g_eMuleApp.m_pUploadQueue->AddUpDataRateMSOverhead(packet->m_dwSize);
					SendPacket(answer,true,true);
				}
			}
			case OP_VERIFYUPSANSWER:{
				if (size != 12)
					throw CString("invalid size (OP_VERIFYUPSANSWER)");
			}*/
			default:
				g_eMuleApp.m_pDownloadQueue->AddDownDataOverheadOther(size);
				AddDebugLogLine(false,_T("unknown extended opcode: %i %x from %s"),opcode,opcode, GetClientNameAndVersionString(m_pClient));
			  
d1146 2
a1147 1
		catch(CFileException* error){
d1153 2
a1154 1
	catch(CString error){
d1156 7
a1162 6
        if(!m_pClient)
		    AddDebugLogLine(false,IDS_ERR_BADCLIENTACTION,error.GetBuffer());
        else
		    AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION)+ _T(" (%s)"),error.GetBuffer(), GetClientNameAndVersionString(m_pClient));
		if (m_pClient) m_pClient->SetDownloadState(DS_ERROR);		
//		Disconnect();
d1168 2
a1169 1
void CClientReqSocket::OnInit(){
d1171 1
a1171 1
	//SetSockOpt(SO_DONTLINGER,&tv,sizeof(BOOL));
d1174 2
a1175 1
void CClientReqSocket::OnSend(int nErrorCode){
d1180 2
a1181 1
void CClientReqSocket::OnError(int nErrorCode){
d1184 2
a1185 2
		AddDebugLogLine(false,IDS_ERR_BADCLIENT2
		,m_pClient->GetUserName(),m_pClient->GetFullIP(),nErrorCode);
d1187 1
a1187 1
		AddDebugLogLine(false,IDS_ERR_BADCLIENTACTION,"CClientReqSocket::OnError");			
d1193 2
a1194 2
	//v- eklmn: feature(01): Filter clients, which are violating protocol
#ifdef OLD_SOCKETS_ENABLED	
d1198 1
a1198 1
	GetPeerName((SOCKADDR*)&sockAddr,(int*)&nSockAddrLen);
d1201 1
a1201 1
	if(g_eMuleApp.m_pIPFilter->IsFiltered(UserIP)) 
d1203 1
a1203 1
		//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
d1205 1
a1205 1
		//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
d1211 1
a1211 1
	//^- eklmn: feature(01): Filter clients, which are violating protocol
d1216 6
a1221 1
			ProcessPacket(packet->m_pcBuffer,packet->m_dwSize,packet->m_eOpcode);
d1223 1
a1223 5
		case OP_PACKEDPROT:
			if (!packet->UnpackPacket()){
				ASSERT ( false );
				break;
			}
d1225 4
a1228 3
			ProcessExtPacket(packet->m_pcBuffer,packet->m_dwSize,packet->m_eOpcode);
			break;
		default:;
d1238 2
a1239 1
bool CClientReqSocket::Create(){
d1241 1
a1241 1
	BOOL result = CAsyncSocketEx::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE); // deadlake PROXYSUPPORT - changed to AsyncSocketEx
d1248 1
a1248 1
// CListenSocket member functions
d1272 1
a1272 1
	return (this->Create(m_pPrefs->GetPort(),SOCK_STREAM,FD_ACCEPT) && this->Listen());
d1291 2
a1292 2
//	OnAccept() is called to notify the socket that it can accept pending connection requests by calling
//		Accept().
d1311 1
a1311 1
	
d1320 1
a1320 1
				newclient->AsyncSelect(FD_WRITE|FD_READ|FD_CLOSE);
d1325 2
a1326 2
//		if (TooManySockets(true) && !g_eMuleApp.m_pServerConnect->IsConnecting())
//			StopListening();
d1331 1
a1331 1
//	Process() takes care of cleaning up invalid, deleted, and timed out sockets from the open socket list.
d1334 1
a1334 1
	POSITION		pos2;
d1339 2
a1340 2
//	For each open socket...
	for (POSITION pos1 = m_openSocketList.GetHeadPosition(); (pos2 = pos1) != NULL; )
d1348 1
a1348 1
	//	If the socket is marked for deletion...
d1351 1
a1351 1
			if (pSocket->m_SocketData.hSocket != INVALID_SOCKET)// deadlake PROXYSUPPORT - changed to AsyncSocketEx
d1362 1
a1362 1
		//	If the socket has timed out, disconnect it.
d1367 2
a1368 2
//		or we're not within 5 connections of max then start listening again.
	if ((GetNumOpenSockets()+5 < m_pPrefs->GetMaxConnections() || g_eMuleApp.m_pServerConnect->IsConnecting()) && !m_bListening)
d1372 6
a1377 4
void CListenSocket::RecalculateStats(){
	memset2(m_ConnectionStates,0,6);
	POSITION pos1,pos2;
	for(pos1 = m_openSocketList.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
d1380 2
a1381 1
		switch (cur_sock->GetConState()){
d1383 2
a1384 2
				m_ConnectionStates[0]++;
				break;
d1386 2
a1387 2
				m_ConnectionStates[1]++;
				break;
d1389 2
a1390 2
				m_ConnectionStates[2]++;
				break;
d1395 2
a1396 1
void CListenSocket::AddSocket(CClientReqSocket* toadd){
d1409 5
a1413 3
void CListenSocket::KillAllSockets(){
	for (POSITION pos = m_openSocketList.GetHeadPosition();pos != 0;pos = m_openSocketList.GetHeadPosition()){
		CClientReqSocket* cur_socket = m_openSocketList.GetAt(pos);
d1428 3
a1430 3
//		in Preferences. If 'bIgnoreInterval' is false, it will also return true if the number of
//		new connections since the last Process() call is greater than the "connections per 5 secs"
//		setting in Preferences.
d1433 3
a1435 3
	if ( GetNumOpenSockets() > m_pPrefs->GetMaxConnections() 
	  || ( m_iOpenSocketsInterval > (g_eMuleApp.m_pGlobPrefs->GetMaxConPerFive()*g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetMaxConPerFiveModifier()) 
		&& !bIgnoreInterval ) )
d1443 1
a1443 1
//	IsValidSocket() returns true if 'pSocket' is in the open socket list.
d1449 2
a1450 1
void CListenSocket::Debug_ClientDeleted(CUpDownClient* deleted){
d1452 2
a1453 1
	for (pos1 = m_openSocketList.GetHeadPosition();( pos2 = pos1 ) != NULL;){
d1456 3
a1458 2
		if (!AfxIsValidAddress(cur_sock, sizeof(CClientReqSocket))) {
			AfxDebugBreak(); 
d1460 2
a1461 1
		if (cur_sock->m_pClient == deleted){
@


1.103
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d100 1
a100 1
		m_pClient->Disconnected();
@


1.102
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d138 1
a138 1
						g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(m_pClient);
d184 1
a184 1
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(m_pClient);
@


1.101
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d1053 1
a1053 1
					memcpy(answer->m_pcBuffer,ip,4);
d1055 1
a1055 1
					memcpy(answer->m_pcBuffer,ip,4);
d1114 1
a1114 1
	memset(&sockAddr, 0, sizeof(sockAddr));
d1288 1
a1288 1
	memset(m_ConnectionStates,0,6);
@


1.100
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d29 1
a29 1
#include "memcpy_amd.h"
d383 1
a383 1
							Packet* packet = new Packet(OP_CANCELTRANSFER,0);
d469 1
a469 1
							Packet* packet = new Packet(OP_CANCELTRANSFER,0);
d475 1
a475 1
						Packet* packet = new Packet(OP_CANCELTRANSFER,0);
d628 2
a629 2
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_Files_map.GetStartPosition();pos != 0;){
							g_eMuleApp.m_pSharedFilesList->m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
d641 1
a641 1
						g_eMuleApp.m_pSharedFilesList->CreateOfferedFilePacket(*(CKnownFile*)list.GetHead(), tempfile);
d704 1
a704 1
						Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);
d741 1
a741 1
						for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_Files_map.GetStartPosition();pos != 0;)
d743 1
a743 1
							g_eMuleApp.m_pSharedFilesList->m_Files_map.GetNextAssoc(pos, bufKey, cur_file);
d762 1
a762 1
								g_eMuleApp.m_pSharedFilesList->CreateOfferedFilePacket(*list.GetHead(), tempfile);
d775 1
a775 1
						Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);
d951 1
a951 1
						Packet* packet = new Packet(OP_CANCELTRANSFER,0);
d958 1
a958 1
					Packet* packet = new Packet(OP_CANCELTRANSFER,0);
@


1.99
log
@Formatting, comments, and name changes.
@
text
@d124 1
a124 1
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, uint8 opcode)
d239 2
a240 2
							md4cpy(replypacket->pBuffer, packet);
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->size);
d266 2
a267 2
						packet->opcode = OP_FILEREQANSWER;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d384 1
a384 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d470 1
a470 1
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d476 1
a476 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d520 2
a521 2
							md4cpy(replypacket->pBuffer, packet);
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(replypacket->size);
d559 2
a560 2
						packet->opcode = OP_FILESTATUS;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d646 2
a647 2
					replypacket->opcode = OP_ASKSHAREDFILESANSWER;
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->size);
d697 2
a698 2
						replypacket->opcode = OP_ASKSHAREDDIRSANS;
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->size);
d705 1
a705 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->size);
d767 2
a768 2
							replypacket->opcode = OP_ASKSHAREDFILESDIRANS;
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->size);
d776 1
a776 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->size);
d806 2
a807 2
							replypacket->opcode = OP_ASKSHAREDFILESDIR;
							g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(replypacket->size);
d892 1
a892 1
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, uint8 opcode)
d952 1
a952 1
						g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d959 1
a959 1
					g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d1008 1
a1008 1
								g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(tosend->size);
d1053 1
a1053 1
					memcpy(answer->pBuffer,ip,4);
d1055 2
a1056 2
					memcpy(answer->pBuffer,ip,4);
					g_eMuleApp.m_pUploadQueue->AddUpDataRateMSOverhead(packet->size);
d1131 1
a1131 1
	switch (packet->prot)
d1134 1
a1134 1
			ProcessPacket(packet->pBuffer,packet->size,packet->opcode);
d1137 1
a1137 1
			if (!packet->UnPackPacket()){
d1142 1
a1142 1
			ProcessExtPacket(packet->pBuffer,packet->size,packet->opcode);
@


1.98
log
@Formatting, comments, and name changes.
@
text
@d44 1
a44 1
	client = in_client;
d46 1
a46 1
		client->socket = this;
d49 2
a50 2
	deletethis = false;
	deltimer = 0;
d54 3
a56 3
	if (client)
		client->socket = 0;
	client = 0;
d63 1
a63 1
	timeout_timer = ::GetTickCount();
d66 9
a74 3
bool CClientReqSocket::CheckTimeOut(){
	if (::GetTickCount() - timeout_timer > CONNECTION_TIMEOUT){
		timeout_timer = ::GetTickCount();
d87 3
a89 1
void CClientReqSocket::Disconnect(){
d91 3
a93 2
	byConnected = ES_DISCONNECTED;
    if(client && !g_eMuleApp.m_pClientList->Debug_IsValidClient(client)) { // obaldin: a quick fix for a strange bug
d95 1
a95 1
        client = 0;
d97 1
a97 1
	if (!client)
d100 1
a100 1
		client->Disconnected();
d103 5
a107 4
void CClientReqSocket::Delete_Timed(){
// it seems that MFC Sockets call socketfunctions after they are deleted, even if the socket is closed
// and select(0) is set. So we need to wait some time to make sure this doesn't happens
	if (::GetTickCount() - deltimer > 10000)
d114 1
a114 1
	deltimer = ::GetTickCount();
d117 5
a121 5
	if (client)
		client->socket = 0;
	client = 0;
	byConnected = ES_DISCONNECTED;
	deletethis = true;
d128 1
a128 1
			if (!client && opcode != OP_HELLO)
d134 2
a135 2
					client->ProcessHelloAnswer(packet,size);
					if (client)
d137 2
a138 2
						client->ConnectionEstablished();
						g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(client);
d145 1
a145 1
					if (!client){
d147 1
a147 1
						client = new CUpDownClient(this);
d151 1
a151 1
						client->ProcessHelloPacket(packet,size);
d157 1
a157 1
							safe_delete(client);
d164 1
a164 1
					if (g_eMuleApp.m_pClientList->AttachToAlreadyKnown(&client,this)){
d166 2
a167 2
						client->ProcessHelloPacket(packet,size);
						client->DisableL2HAC(); //<<-- enkeyDEV(th1) -L2HAC- lowid side
d170 2
a171 2
						g_eMuleApp.m_pClientList->AddClient(client);
						client->SetCommentDirty();
d184 1
a184 1
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(client);
d187 2
a188 2
					if (client->GetClientSoft() == SO_EMULE && client->GetHashType() == SO_EMULE)
						client->SendMuleInfoPacket(false);
d190 3
a192 3
					client->SendHelloAnswer();
					if (client)
						client->ConnectionEstablished();
d201 1
a201 1
					if (client->GetFailedFileRequests() >= 3 && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled())
d203 2
a204 2
						g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(client->GetIP());
						AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due to file scanning"),client->GetFullIP(),GetClientNameAndVersionString(client));
d209 1
a209 1
					if (size == 16 || (size > 16 && client->GetExtendedRequestsVersion() > 0))
d211 2
a212 2
						if (!client->GetWaitStartTime())
							client->SetWaitStartTime();
d225 1
a225 1
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)partfile,client);
d228 1
a228 1
								client->UpdateFailedFileRequests();
d231 2
a232 2
							if (!memcmp(g_eMuleApp.m_pGlobPrefs->GetUserHash(), client->GetUserHash(),16)) 
								AddDebugLogLine(false,_T("Client %s (%s) is using our userhash"),client->GetUserName(),client->GetFullIP());
d248 1
a248 1
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
d251 2
a252 2
						if(md4cmp(client->reqfileid, packet) != 0)
							client->SetCommentDirty();
d255 2
a256 2
						client->ResetFailedFileRequests();
						client->SetUploadFileID((uchar*)packet);
d264 1
a264 1
						client->ProcessUpFileStatus(packet,size);
d269 1
a269 1
						client->SendCommentInfo(reqfile);
d273 1
a273 1
						client->UpdateFailedFileRequests();
d288 1
a288 1
					if (client) switch (client->GetDownloadState()) {
d291 2
a292 2
						if (!client->SwapToAnotherFile(NULL)) {	//eklmn: bugfix(08): A4AF switching (???)
							g_eMuleApp.m_pDownloadQueue->RemoveSource(client, true);
d304 1
a304 1
					client->ProcessFileInfo(packet,size);
d309 1
a309 1
					client->ProcessFileStatus(packet,size);
d327 1
a327 1
									g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
d330 2
a331 2
							if(md4cmp(client->GetUploadFileID(), packet) != 0)
								client->SetCommentDirty();
d333 3
a335 3
							client->ResetFailedFileRequests();
							client->SetUploadFileID((uchar*)packet);
							client->SendCommentInfo(reqfile);
d348 1
a348 1
								client->UpdateFailedFileRequests();
d351 1
a351 1
					g_eMuleApp.m_pUploadQueue->AddClientToQueue(client);
d361 1
a361 1
					client->SetRemoteQueueRank(rank);					
d363 2
a364 2
					if (rank && client->GetDownloadState() == DS_DOWNLOADING)
						client->SetDownloadState(DS_ONQUEUE);
d371 1
a371 1
					if(client->reqfile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(client->reqfile))
d374 2
a375 2
						if (client->GetDownloadState() == DS_ONQUEUE && !client->reqfile->IsPaused() 
						&& (client->reqfile->GetStatus(false) == PS_READY || client->reqfile->GetStatus(false) == PS_EMPTY))
d377 3
a379 3
							client->SetDownloadState(DS_DOWNLOADING);
							client->SetLastDownPart(0xFFFF); // eklmn: feature(00): ICR 2.3 reset part before new download 
							client->SendBlockRequests();
d385 3
a387 3
							//client->socket->SendPacket(packet,false,true); //eklmn: bugfix(04): 
							client->socket->SendPacket(packet,true,true); //eklmn: bugfix(05): Listen soket OP_ACCEPTUPLOADREQ
							client->SetDownloadState(DS_ONQUEUE);
d414 1
a414 1
						client->AddReqBlock(reqblock1);
d419 1
a419 1
						client->AddReqBlock(reqblock2);
d424 1
a424 1
						client->AddReqBlock(reqblock3);
d429 3
a431 3
					g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(client,ETS_CANCELED);
					g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("%s: Upload session ended due to a canceled transfer."), client->GetUserName());
					client->SetUploadFileID(NULL);
d437 4
a440 4
					if (size>=16 && !md4cmp(client->GetUploadFileID(),packet)){
						g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(client,ETS_END_OF_DOWNLOAD);
						AddDebugLogLine(false, _T("%s: Upload session ended due ended transfer."), client->GetUserName());
						client->SetUploadFileID(NULL);
d448 1
a448 1
					client->SendHashsetPacket(packet);
d453 1
a453 1
                    //if (client->GetDownloadState() != DS_REQHASHSET)
d455 1
a455 1
					client->ProcessHashSet(packet,size);
d461 1
a461 1
					if (client->reqfile && (client->reqfile->GetStatus() == PS_READY || client->reqfile->GetStatus() == PS_EMPTY))
d463 5
a467 5
						client->ProcessBlockPacket(packet,size);
						if ((client->reqfile != NULL) &&
							(client->reqfile->GetStatus()==PS_PAUSED 
							|| client->reqfile->GetStatus()==PS_STOPPED
							|| client->reqfile->GetStatus()==PS_ERROR))
d471 1
a471 1
							client->socket->SendPacket(packet,true,true);
d477 2
a478 2
						client->socket->SendPacket(packet,true,true);
						client->SetDownloadState(client->reqfile==NULL ? DS_NONE : DS_ONQUEUE);
d484 2
a485 2
					if (client->GetDownloadState() == DS_DOWNLOADING)
						client->SetDownloadState(DS_ONQUEUE);
d494 2
a495 2
						if (!client->GetWaitStartTime()) 
							client->SetWaitStartTime();
d509 2
a510 2
								client->UpdateFailedFileRequests();
							if (client->GetFailedFileRequests() >= 3 && g_eMuleApp.m_pGlobPrefs->IsScanFilterEnabled())
d512 2
a513 2
								g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(client->GetIP());
								AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due to file scanning (%s)"),client->GetFullIP(),GetClientNameAndVersionString(client));
d527 1
a527 1
						client->ResetFailedFileRequests();
d531 1
a531 1
								g_eMuleApp.m_pDownloadQueue->CheckAndAddKnownSource((CPartFile*)reqfile,client); 
d534 2
a535 2
						if(md4cmp(client->GetUploadFileID(), packet) != 0)
							client->SetCommentDirty();
d538 2
a539 2
						client->SetUploadFileID((uchar*)packet);
						//md4cpy(client->reqfileid,packet);
d546 1
a546 1
							reqfile->WriteJumpstartPartStatus(client, &data);
d579 3
a581 3
							client->SetUserID(nNewUserID); // update UserID only if we know the server
							client->SetServerIP(nNewServerIP);
							client->SetServerPort(pNewServer->GetPort());
d584 2
a585 2
					else if (nNewUserID == client->GetIP()){ // client changed server and gots a HighID(IP)
						client->SetUserID(nNewUserID);
d588 2
a589 2
							client->SetServerIP(nNewServerIP);
							client->SetServerPort(pNewServer->GetPort());
d610 1
a610 1
					g_eMuleApp.m_pdlgEmule->m_wndChat.chatselector.ProcessMessage(client,message);
d618 1
a618 1
					if (client->IsBanned() ){
d624 1
a624 1
						(g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && client->IsFriend() ) )
d632 2
a633 2
						AddDebugLogLine(false,IDS_REQ_SHAREDFILES,client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
					} else AddDebugLogLine(false,IDS_REQ_SHAREDFILES,client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
d653 1
a653 1
					client->ProcessSharedFileList(packet,size);
d662 1
a662 1
					if (client->IsBanned() )	break;						
d665 1
a665 1
						(g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && client->IsFriend() ) )
d667 1
a667 1
						AddDebugLogLine(false,IDS_SHAREDREQ1,client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
d703 1
a703 1
						AddDebugLogLine(false,IDS_SHAREDREQ1,client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
d715 1
a715 1
					if (client->IsBanned() ) break;
d732 1
a732 1
						   (g_eMuleApp.m_pGlobPrefs->CanSeeShares() == SEE_SHARE_FRIENDS && client->IsFriend() ) ) )
d734 1
a734 1
						AddDebugLogLine(false,IDS_SHAREDREQ2,client->GetUserName(),client->GetUserID(),strReqVDir,strReqDir,GetResString(IDS_ACCEPTED) );
d774 1
a774 1
						AddDebugLogLine(false,IDS_SHAREDREQ2,client->GetUserName(),client->GetUserID(),strReqVDir,strReqDir,GetResString(IDS_DENIED) );
d784 1
a784 1
					if (client->GetFileListRequested() == 1)
d799 1
a799 1
							AddDebugLogLine(false,IDS_SHAREDANSW,client->GetUserName(),client->GetUserID(),strDir);
d812 1
a812 1
						client->SetFileListRequested(uDirs);
d815 1
a815 1
						AddDebugLogLine(false,IDS_SHAREDANSW2,client->GetUserName(),client->GetUserID());
d831 1
a831 1
					if (client->GetFileListRequested() > 0)
d833 4
a836 4
						AddDebugLogLine(false,IDS_SHAREDINFO1,client->GetUserName(),client->GetUserID(),strDir);
						client->ProcessSharedFileList(packet + data.GetPosition(), size - data.GetPosition(), strDir);
						if (client->GetFileListRequested() == 0)
							AddDebugLogLine(false,IDS_SHAREDINFO2,client->GetUserName(),client->GetUserID());
d839 1
a839 1
						AddDebugLogLine(false,IDS_SHAREDANSW3,client->GetUserName(),client->GetUserID(),strDir);
d846 2
a847 2
					AddLogLine(true,IDS_SHAREDREQDENIED,client->GetUserName(),client->GetUserID());
					client->SetFileListRequested(0);
d857 1
a857 1
					AddDebugLogLine(false,_T("Unknown opcode: %i %x from %s"), opcode, opcode, GetClientNameAndVersionString(client));
d874 2
a875 2
		if (client){
			client->SetDownloadState(DS_ERROR);	
d878 1
a878 1
			,client->GetUserName(),client->GetFullIP(),error.GetBuffer(), GetClientNameAndVersionString(client));
d896 1
a896 1
		if (!client)
d901 3
a903 3
				client->ProcessMuleInfoPacket(packet,size);
				if (client->IsLeecherType())
					client->Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
d905 1
a905 1
				client->SendMuleInfoPacket(true);
d910 3
a912 3
				client->ProcessMuleInfoPacket(packet,size);
				if (client->IsLeecherType())
					client->Ban(_T("AUTOMATED MESSAGE: You're being banned because your client is leeching!"), "Leecher MOD");
d916 6
a921 6
					client->ProcessSecIdentStatePacket((uchar*)packet,size);
					if (client->GetSecureIdentState() == IS_SIGNATURENEEDED)
						client->SendSignaturePacket();
					else if (client->GetSecureIdentState() == IS_KEYANDSIGNEEDED){
						client->SendPublicKeyPacket();
						client->SendSignaturePacket();
d926 1
a926 1
					if (client->IsBanned() ){
d929 1
a929 1
					client->ProcessPublicKeyPacket((uchar*)packet,size);
d933 1
a933 1
					client->ProcessSignaturePacket((uchar*)packet,size);
d943 1
a943 1
				if (client->reqfile && (client->reqfile->GetStatus()==PS_READY || client->reqfile->GetStatus()==PS_EMPTY))
d945 5
a949 5
					client->ProcessBlockPacket(packet,size,true);
					if ((client->reqfile != NULL) &&
						(client->reqfile->GetStatus()==PS_PAUSED 
						|| client->reqfile->GetStatus()==PS_STOPPED
						|| client->reqfile->GetStatus()==PS_ERROR))
d953 1
a953 1
						client->socket->SendPacket(packet,true,true);
d960 2
a961 2
					client->socket->SendPacket(packet,true,true);
					client->SetDownloadState(client->reqfile==NULL ? DS_NONE : DS_ONQUEUE);
d971 2
a972 2
				client->SetRemoteQueueFull(false);
				client->SetRemoteQueueRank(newrank);
d974 2
a975 2
				if (newrank && client->GetDownloadState() == DS_DOWNLOADING)
					client->SetDownloadState(DS_ONQUEUE);
d980 1
a980 1
				if (client->GetSourceExchangeVersion() >= 1)
d992 2
a993 2
						DWORD dwTimePassed = ::GetTickCount() - client->GetLastSrcReqTime() + CONNECTION_LATENCY;
						bool bNeverAskedBefore = client->GetLastSrcReqTime() == 0;
d1005 2
a1006 2
							client->SetLastSrcReqTime();
							Packet* tosend = file->CreateSrcInfoPacket(client);
d1010 1
a1010 1
								//AddDebugLogLine(false, "RCV:Source Request User(%s) File(%s)", client->GetUserName(), file->GetFileName());
d1027 1
a1027 1
							client->SetLastSrcAnswerTime();
d1032 1
a1032 1
							((CPartFile*)file)->AddClientSources(&data, client->GetSourceExchangeVersion());
d1045 1
a1045 1
				client->ProcessMuleCommentPacket(packet,size);
d1066 1
a1066 1
				AddDebugLogLine(false,_T("unknown extended opcode: %i %x from %s"),opcode,opcode, GetClientNameAndVersionString(client));
d1078 1
a1078 1
        if(!client)
d1081 2
a1082 2
		    AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION)+ _T(" (%s)"),error.GetBuffer(), GetClientNameAndVersionString(client));
		if (client) client->SetDownloadState(DS_ERROR);		
d1101 1
a1101 1
	if (client)
d1103 1
a1103 1
		,client->GetUserName(),client->GetFullIP(),nErrorCode);
d1124 1
a1124 1
		client = NULL;
d1173 1
a1173 1
	m_OpenSocketsInterval = 0;
d1185 1
a1185 1
	bListening = true;
d1192 2
a1193 2
	bListening = true;
	if (m_iNumPendingConnections)
d1202 1
a1202 1
	bListening = false;
d1206 2
d1210 1
a1210 1
	if (!nErrorCode)
d1213 4
a1216 2
		if (m_iNumPendingConnections < 1){
			ASSERT ( false );
d1219 2
a1220 1
		if (TooManySockets(true) && !g_eMuleApp.m_pServerConnect->IsConnecting()){
d1224 1
a1224 1
		else if ( bListening == false )
d1245 5
d1251 1
a1251 3
void CListenSocket::Process(){
	POSITION pos2;
	m_OpenSocketsInterval = 0;
d1253 8
a1260 3
	for(POSITION pos1 = socket_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		socket_list.GetNext(pos1);
		CClientReqSocket* cur_sock = socket_list.GetAt(pos2);
d1263 22
a1284 13
	   if (cur_sock->deletethis){
		   if (cur_sock->m_SocketData.hSocket != INVALID_SOCKET){ // deadlake PROXYSUPPORT - changed to AsyncSocketEx
				cur_sock->Close();
		   }
		   else{
			   cur_sock->Delete_Timed();;
		   }
	   }
	   else
		socket_list.GetAt( pos2 )->CheckTimeOut();
   }
   if ( (GetOpenSockets()+5 < m_pPrefs->GetMaxConnections() || g_eMuleApp.m_pServerConnect->IsConnecting()) && !bListening)
	   RestartListening();
d1286 1
a1286 1

d1290 3
a1292 3
	for(pos1 = socket_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		socket_list.GetNext(pos1);
		CClientReqSocket* cur_sock = socket_list.GetAt(pos2);
d1308 1
a1308 1
	socket_list.AddTail(toadd);
d1315 1
a1315 1
	todel_pos = socket_list.Find(todel);
d1317 1
a1317 1
		socket_list.RemoveAt(todel_pos);
d1321 4
a1324 4
	for (POSITION pos = socket_list.GetHeadPosition();pos != 0;pos = socket_list.GetHeadPosition()){
		CClientReqSocket* cur_socket = socket_list.GetAt(pos);
		if (cur_socket->client)
			delete cur_socket->client;
d1329 4
a1332 3

void CListenSocket::AddConnection(){
	m_OpenSocketsInterval++;
d1335 10
a1344 5

bool CListenSocket::TooManySockets(bool bIgnoreInterval){
	if (GetOpenSockets() > m_pPrefs->GetMaxConnections() 
		|| (m_OpenSocketsInterval > (g_eMuleApp.m_pGlobPrefs->GetMaxConperFive()*g_eMuleApp.m_pdlgEmule->m_dlgStatistics.GetMaxConperFiveModifier()) 
		&& !bIgnoreInterval) )
d1351 5
a1355 3

bool CListenSocket::IsValidSocket(CClientReqSocket* totest){
	return socket_list.Find(totest);
d1357 1
a1357 1

d1360 3
a1362 3
	for (pos1 = socket_list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		socket_list.GetNext(pos1);
		CClientReqSocket* cur_sock = socket_list.GetAt(pos2);
d1366 1
a1366 1
		if (cur_sock->client == deleted){
@


1.97
log
@Temporary debug log spam control
@
text
@d361 1
a361 1
					if(client->reqfile && g_eMuleApp.m_pDownloadQueue->IsPartFile(client->reqfile))
@


1.96
log
@Customization for Scan Filter.
Fix for preferences toolbar button (take care when you do code renaming to keep the correct values)
@
text
@d924 1
d926 1
@


1.95
log
@Formatting, comments, and name changes.
@
text
@d191 1
a191 1
					if (client->GetFailedFileRequests() >= 3)
d500 1
a500 1
							if (client->GetFailedFileRequests() >= 3)
d503 1
a503 1
								AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due to file scanning"),client->GetFullIP(),GetClientNameAndVersionString(client));
d506 1
a506 1
							}	
@


1.94
log
@OP_STARTUPLOADREQ:
Take back the AddClientToQueue() function outside the case,
because we need a detailed test if it works well.
@
text
@d25 1
a25 1
#include "sharedfilelist.h"
d39 2
d52 1
a52 2


d61 1
a61 1

d65 1
a65 1

d74 1
a74 1

d80 1
a80 1

d93 1
a93 1

d100 1
a100 1

d113 1
a113 1

d881 1
a881 1

d1076 1
a1076 1

d1081 1
a1081 1

d1086 1
a1086 1

d1096 1
a1096 1

d1135 1
a1135 1

d1141 1
a1141 1

d1148 2
d1151 1
d1153 8
a1160 7

// CListenSocket
// CListenSocket member functions
CListenSocket::CListenSocket(CPreferences* in_prefs){
	m_pPrefs = in_prefs;
	opensockets = 0;
	maxconnectionreached = 0;
d1162 1
a1162 1
	m_nPeningConnections = 0;
d1164 3
a1166 2

CListenSocket::~CListenSocket(){
d1170 4
a1174 2
bool CListenSocket::StartListening(){
	bListening = true;
d1177 3
a1179 2

void CListenSocket::ReStartListening(){
d1181 3
a1183 2
	if (m_nPeningConnections){
		m_nPeningConnections--;
d1187 3
a1189 2

void CListenSocket::StopListening(){
d1191 1
a1191 1
	maxconnectionreached++;
d1193 1
a1193 2


d1198 2
a1199 2
		m_nPeningConnections++;
		if (m_nPeningConnections < 1){
d1201 1
a1201 1
			m_nPeningConnections = 1;
d1208 1
a1208 1
			ReStartListening(); //If the client is still at maxconnections, this will allow it to go above it.. But if you don't, you will get a lowID on all servers.
d1210 1
a1210 1
		while (m_nPeningConnections)
d1212 1
a1212 1
			m_nPeningConnections--;
d1232 1
a1232 1
	opensockets = 0;
d1236 1
a1236 1
		opensockets++;
d1250 1
a1250 1
	   ReStartListening();
d1298 1
a1298 1
	opensockets++;
@


1.93
log
@small aftershave (afterfix) thx SyruS
@
text
@d327 5
a331 1
							g_eMuleApp.m_pUploadQueue->AddClientToQueue(client);
d340 1
@


1.92
log
@fix antiscnanning feature
@
text
@d212 1
d215 1
@


1.91
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@a206 1
							client->UpdateFailedFileRequests();
d208 2
d214 2
d307 1
d320 1
d323 9
a333 1
					g_eMuleApp.m_pUploadQueue->AddClientToQueue(client);
d490 2
a491 1
							client->UpdateFailedFileRequests();
@


1.90
log
@removed LowId check by incomming fitering
@
text
@d125 1
d127 2
d172 2
@


1.89
log
@updated LowID filtering
@
text
@d1080 3
a1082 3
	// BavarianSnail - always filter out clients without a valid IP
	if(UserIP < 16777216) {
		AddDebugLogLine(false,_T("%s: Filtered client with invalid IP: UserIP: %u FullUserIP: %s THIS SHOULD NEVER HAPPEN!"), __FUNCTION__, UserIP,FullUserIP);
a1087 11
	} else {
	// -BavarianSnail
		if(g_eMuleApp.m_pIPFilter->IsFiltered(UserIP)) 
		{
			//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
			g_eMuleApp.stat_filteredclients++;
			//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
			client = NULL;
			Disconnect();
			return;
		}
@


1.88
log
@Formatting, comments, and name changes.
@
text
@d1080 1
a1080 1
// BavarianSnail - Don't search LowID IDs as IP in filter list
d1082 6
a1087 1
		AddDebugLogLine(false,_T("%s: Cannot filter client (no IP): UserIP: %u FullUserIP: %s"), __FUNCTION__, UserIP,FullUserIP);
d1089 1
a1089 1
// -BavarianSnail
@


1.87
log
@reinsert ipfilter patch for lowids
@
text
@d41 1
a41 1
	app_prefs = in_prefs;
d1133 1
a1133 1
	app_prefs = in_prefs;
d1147 1
a1147 1
	return (this->Create(app_prefs->GetPort(),SOCK_STREAM,FD_ACCEPT) && this->Listen());
d1183 1
a1183 1
			CClientReqSocket* newclient = new CClientReqSocket(app_prefs);
d1219 1
a1219 1
   if ( (GetOpenSockets()+5 < app_prefs->GetMaxConnections() || g_eMuleApp.m_pServerConnect->IsConnecting()) && !bListening)
d1272 1
a1272 1
	if (GetOpenSockets() > app_prefs->GetMaxConnections() 
@


1.86
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d1080 14
a1093 8
	if(g_eMuleApp.m_pIPFilter->IsFiltered(UserIP)) 
	{
		//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
		g_eMuleApp.stat_filteredclients++;
		//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
		client = NULL;
		Disconnect();
		return;
@


1.85
log
@handle LowIDs correctly in ipfilter search and debug output for clients with no IP (bug?) in m_dwUserIP
@
text
@d567 1
a567 5
					#ifndef AMD
					memcpy(&length,packet,2);
					#else
					memcpy_amd(&length,packet,2);
					#endif
d571 1
a571 5
					#ifndef AMD
					memcpy(message,packet+2,length);
					#else
					memcpy_amd(message,packet+2,length);
					#endif
d931 1
a931 5
				#ifndef AMD
				memcpy(&newrank,packet+0,2);
				#else
				memcpy_amd(&newrank,packet+0,2);
				#endif
d1080 8
a1087 14
// BavarianSnail - Don't search LowID IDs as IP in filter list
	if(UserIP < 16777216) {
		AddDebugLogLine(false,_T("%s: Cannot filter client (no IP): UserIP: %u FullUserIP: %s"), __FUNCTION__, UserIP,FullUserIP);
	} else {
// -BavarianSnail
		if(g_eMuleApp.m_pIPFilter->IsFiltered(UserIP)) 
		{
			//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
			g_eMuleApp.stat_filteredclients++;
			//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
			client = NULL;
			Disconnect();
			return;
		}
@


1.84
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d1092 14
a1105 8
	if(g_eMuleApp.m_pIPFilter->IsFiltered(UserIP)) 
	{
		//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,g_eMuleApp.m_pIPFilter->GetLastHit());
		g_eMuleApp.stat_filteredclients++;
		//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
		client = NULL;
		Disconnect();
		return;
@


1.83
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d26 1
a26 1
#include "uploadqueue.h"
d28 1
a28 1
#include "clientlist.h"
d45 1
a45 1
	theApp.listensocket->AddSocket(this);
d56 1
a56 1
	theApp.listensocket->RemoveSocket(this);
d58 1
a58 1
	DEBUG_ONLY (theApp.clientlist->Debug_SocketDeleted(this));
d75 1
a75 1
	ASSERT (theApp.listensocket->IsValidSocket(this));
d83 1
a83 1
    if(client && !theApp.clientlist->Debug_IsValidClient(client)) { // obaldin: a quick fix for a strange bug
d101 1
a101 1
	ASSERT (theApp.listensocket->IsValidSocket(this));
d122 1
a122 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d129 1
a129 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d150 1
a150 1
					if (theApp.clientlist->AttachToAlreadyKnown(&client,this)){
d156 1
a156 1
						theApp.clientlist->AddClient(client);
d162 2
a163 2
					if (theApp.ipfilter->IsFiltered(client->GetIP())) {
						AddDebugLogLine(false,_T("Filtered: %s %s "), client->GetFullIP(),theApp.ipfilter->GetLastHit());
d165 1
a165 1
						theApp.stat_filteredclients++;
d183 1
a183 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d187 1
a187 1
						theApp.ipfilter->AddTemporaryBannedIP(client->GetIP());
d199 1
a199 1
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID(reqfileid);
d204 1
a204 1
							CKnownFile* partfile = theApp.downloadqueue->GetFileByID(reqfileid);
d206 2
a207 2
								if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)partfile)->GetSourceCount() ) //<<--
									theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)partfile,client);
d210 1
a210 1
							if (!memcmp(theApp.glob_prefs->GetUserHash(), client->GetUserHash(),16)) 
d219 1
a219 1
							theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size);
d226 2
a227 2
							if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() ) //<<--
								theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
d242 1
a242 1
						// again in 'sharedfiles' -> waste of time.
d246 1
a246 1
						theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d258 1
a258 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d262 1
a262 1
					CPartFile* reqfile = theApp.downloadqueue->GetFileByID((uchar*)packet);
d271 1
a271 1
							theApp.downloadqueue->RemoveSource(client, true);
d282 1
a282 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d287 1
a287 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d293 1
a293 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d299 1
a299 1
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID(reqfileid);
d304 2
a305 2
								if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() ) //<<--
									theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
d315 1
a315 1
					theApp.uploadqueue->AddClientToQueue(client);
d321 1
a321 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d333 1
a333 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d335 1
a335 1
					if(client->reqfile && theApp.downloadqueue->IsPartFile(client->reqfile))
d348 1
a348 1
							theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d359 1
a359 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d392 3
a394 3
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
					theApp.uploadqueue->RemoveFromUploadQueue(client,ETS_CANCELED);
					theApp.emuledlg->AddDebugLogLine(false, _T("%s: Upload session ended due to a canceled transfer."), client->GetUserName());
d400 1
a400 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d402 1
a402 1
						theApp.uploadqueue->RemoveFromUploadQueue(client,ETS_END_OF_DOWNLOAD);
d409 1
a409 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d416 1
a416 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d424 1
a424 1
//					theApp.downloadqueue->AddDownDataOverheadOther(0, 24);
d434 1
a434 1
							theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d440 1
a440 1
						theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d447 1
a447 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d454 1
a454 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
d461 1
a461 1
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)packet);
d467 1
a467 1
							reqfile = theApp.downloadqueue->GetFileByID((uchar*)packet);
d475 1
a475 1
								theApp.ipfilter->AddTemporaryBannedIP(client->GetIP());
d484 1
a484 1
							theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size);
d493 2
a494 2
							if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() )
								theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client); 
d523 1
a523 1
						theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d533 1
a533 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d540 1
a540 1
						CServer* pNewServer = theApp.serverlist->GetServerByIP(nNewServerIP);
d549 1
a549 1
						CServer* pNewServer = theApp.serverlist->GetServerByIP(nNewServerIP);
d560 1
a560 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d565 1
a565 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d581 1
a581 1
					theApp.emuledlg->chatwnd.chatselector.ProcessMessage(client,message);
d586 1
a586 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d594 2
a595 2
					if (theApp.glob_prefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
						(theApp.glob_prefs->CanSeeShares() == SEE_SHARE_FRIENDS && client->IsFriend() ) )
d599 2
a600 2
						for (POSITION pos = theApp.sharedfiles->m_Files_map.GetStartPosition();pos != 0;){
							theApp.sharedfiles->m_Files_map.GetNextAssoc(pos,bufKey,cur_file);
d612 1
a612 1
						theApp.sharedfiles->CreateOfferedFilePacket(*(CKnownFile*)list.GetHead(), tempfile);
d618 1
a618 1
					theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
d623 1
a623 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d629 1
a629 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d635 2
a636 2
					if (theApp.glob_prefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
						(theApp.glob_prefs->CanSeeShares() == SEE_SHARE_FRIENDS && client->IsFriend() ) )
d644 1
a644 1
						CMapStringToString &mapVDirs= theApp.sharedfiles->GetSharedVDirForList();
d669 1
a669 1
						theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
d676 1
a676 1
						theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
d683 1
a683 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d698 1
a698 1
					CMapStringToString &mapVDirs= theApp.sharedfiles->GetSharedVDirForList();	// #zegzav:vdir4list
d702 2
a703 2
						  (theApp.glob_prefs->CanSeeShares() == SEE_SHARE_EVERYBODY ||
						   (theApp.glob_prefs->CanSeeShares() == SEE_SHARE_FRIENDS && client->IsFriend() ) ) )
d712 1
a712 1
						for (POSITION pos = theApp.sharedfiles->m_Files_map.GetStartPosition();pos != 0;)
d714 1
a714 1
							theApp.sharedfiles->m_Files_map.GetNextAssoc(pos, bufKey, cur_file);
d733 1
a733 1
								theApp.sharedfiles->CreateOfferedFilePacket(*list.GetHead(), tempfile);
d739 1
a739 1
							theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
d747 1
a747 1
						theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
d754 1
a754 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d778 1
a778 1
							theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
d793 1
a793 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d815 1
a815 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d824 1
a824 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d827 1
a827 1
					theApp.downloadqueue->AddDownDataOverheadOther(size);
d871 1
a871 1
				theApp.downloadqueue->AddDownDataOverheadOther(size);
d880 1
a880 1
				theApp.downloadqueue->AddDownDataOverheadOther(size);
d911 1
a911 1
//				theApp.downloadqueue->AddDownDataOverheadOther(24);
d921 1
a921 1
						theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d928 1
a928 1
					theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d935 1
a935 1
				theApp.downloadqueue->AddDownDataOverheadOther(size);
d952 1
a952 1
				theApp.downloadqueue->AddDownDataOverheadSourceExchange(size);
d959 1
a959 1
					CKnownFile* file = theApp.sharedfiles->GetFileByID((uchar*)packet);
d961 1
a961 1
						file = theApp.downloadqueue->GetFileByID((uchar*)packet);
d981 1
a981 1
								theApp.uploadqueue->AddUpDataOverheadSourceExchange(tosend->size);
d991 1
a991 1
				theApp.downloadqueue->AddDownDataOverheadSourceExchange(size);
d996 1
a996 1
					CKnownFile* file = theApp.downloadqueue->GetFileByID((uchar*)packet);
d1017 1
a1017 1
				theApp.downloadqueue->AddDownDataOverheadOther(size);
d1022 1
a1022 1
				CUpDownClient* vuclient = theApp.clientlist->VUGetRandomClient();
d1029 1
a1029 1
					theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size);
d1038 1
a1038 1
				theApp.downloadqueue->AddDownDataOverheadOther(size);
d1092 1
a1092 1
	if(theApp.ipfilter->IsFiltered(UserIP)) 
d1094 2
a1095 2
		//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,theApp.ipfilter->GetLastHit());
		theApp.stat_filteredclients++;
d1128 1
a1128 1
	theApp.listensocket->AddConnection();
d1179 1
a1179 1
		if (TooManySockets(true) && !theApp.serverconnect->IsConnecting()){
d1199 1
a1199 1
//		if (TooManySockets(true) && !theApp.serverconnect->IsConnecting())
d1225 1
a1225 1
   if ( (GetOpenSockets()+5 < app_prefs->GetMaxConnections() || theApp.serverconnect->IsConnecting()) && !bListening)
d1279 1
a1279 1
		|| (m_OpenSocketsInterval > (theApp.glob_prefs->GetMaxConperFive()*theApp.emuledlg->statisticswnd.GetMaxConperFiveModifier()) 
@


1.82
log
@minor change (debug log string)
@
text
@d132 1
a132 1
						// create new client to save standart informations
d170 1
a170 1
					// send a response packet with standart informations
@


1.81
log
@*** empty log message ***
@
text
@d188 1
a188 1
						AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due file scanning"),client->GetFullIP(),GetClientNameAndVersionString(client));
d476 1
a476 1
								AddDebugLogLine(false,_T("Client %s (%s) added to filtered clients due file scanning"),client->GetFullIP(),GetClientNameAndVersionString(client));
@


1.80
log
@antiscaning measures & some optimization
@
text
@d188 1
a188 1
						AddDebugLogLine(false,_T("Client %s (%s) added to fltered clients due file scaning"),client->GetFullIP(),GetClientNameAndVersionString(client));
d476 1
a476 1
								AddDebugLogLine(false,_T("Client %s (%s) added to fltered clients due file scaning"),client->GetFullIP(),GetClientNameAndVersionString(client));
@


1.79
log
@updated OP_ASKSHAREDDIRS for categories
@
text
@d113 2
a114 20
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, uint8 opcode){
	//v- eklmn: feature(01): Filter clients, which are violating protocol
#ifdef OLD_SOCKETS_ENABLED	
	SOCKADDR_IN sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));
	uint32 nSockAddrLen = sizeof(sockAddr);
	GetPeerName((SOCKADDR*)&sockAddr,(int*)&nSockAddrLen);
	uint32 UserIP = sockAddr.sin_addr.S_un.S_addr;
	CString FullUserIP(inet_ntoa(sockAddr.sin_addr));
	if(theApp.ipfilter->IsFiltered(UserIP)) 
	{
		//AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,theApp.ipfilter->GetLastHit());
		theApp.stat_filteredclients++;
		//eklmn: reset client to NULL in order don't let CUpDownClient::Disconnected be processed for a client which is not in the list of clients.
		client = NULL;
		Disconnect();
		return false;
	}
#endif //OLD_SOCKETS_ENABLED
	//^- eklmn: feature(01): Filter clients, which are violating protocol
d184 9
d202 1
d234 1
d251 2
d254 1
d472 9
d489 2
d627 4
a630 3
                case OP_ASKSHAREDDIRS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    ASSERT( size == 0 );
d633 1
a633 3
					if (client->IsBanned() ){
						break;						
					}
d647 1
a647 1
                        {
d654 1
a654 1
                        }
d657 1
a657 1
                        CSafeMemFile tempfile(80);
d659 1
a659 1
                        tempfile.Write(&uDirs, 4);
d663 4
a666 4
                            uint16 cnt = strDir.GetLength();
                            tempfile.Write(&cnt, 2);
                            tempfile.Write((LPCTSTR)strDir, cnt);
                        }
d668 3
a670 3
                        replypacket->opcode = OP_ASKSHAREDDIRSANS;
                        theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                        SendPacket(replypacket, true, true);
d672 2
a673 1
					else{
d675 1
a675 1
                        Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);
d677 7
a683 6
                        SendPacket(replypacket, true, true);
                    }
                    break;
                }
                case OP_ASKSHAREDFILESDIR:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
d686 1
a686 3
					if (client->IsBanned() ){
						break;						
					}
d688 8
a695 8
                    CSafeMemFile data((uchar*)packet, size);
                    uint16 cnt;
                    data.Read(&cnt, 2);
                    CString strReqDir, strReqVDir;		// #zegzav:vdir4list
                    data.Read(strReqVDir.GetBuffer(cnt), cnt);
                    strReqVDir.ReleaseBuffer(cnt);
                    PathRemoveBackslash(strReqVDir.GetBuffer());
                    strReqVDir.ReleaseBuffer();
d706 9
a714 7
                        ASSERT( data.GetPosition() == data.GetLength() );
 
                        CTypedPtrList<CPtrList, CKnownFile*> list;
                        for (POSITION pos = theApp.sharedfiles->m_Files_map.GetStartPosition();pos != 0;){
                            CCKey bufKey;
                            CKnownFile* cur_file;
                            theApp.sharedfiles->m_Files_map.GetNextAssoc(pos, bufKey, cur_file);
d718 2
a719 3
							if (strReqDir.CompareNoCase(strSharedFileDir) == 0)
                                list.AddTail(cur_file);
                        }
d723 22
a744 19
						/*if (list.GetCount())*/{
                            CSafeMemFile tempfile(80);
                            uint16 cnt = strReqVDir.GetLength();
                            tempfile.Write(&cnt, 2);
                            tempfile.Write((LPCTSTR)strReqVDir, cnt);
                            uint32 uFiles = list.GetCount();
                            tempfile.Write(&uFiles, 4);
                            while (list.GetCount()){
                                theApp.sharedfiles->CreateOfferedFilePacket(*list.GetHead(), tempfile);
                                list.RemoveHead();
                            }
 
                            Packet* replypacket = new Packet(&tempfile);
                            replypacket->opcode = OP_ASKSHAREDFILESDIRANS;
                            theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                            SendPacket(replypacket, true, true);
                        }
                    }
                    else{
d746 21
a766 18
                        Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);
                        theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                        SendPacket(replypacket, true, true);
                    }
                    break;
                }
                case OP_ASKSHAREDDIRSANS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    if (client->GetFileListRequested() == 1){
                        CSafeMemFile data((uchar*)packet, size);
                        uint32 uDirs;
                        data.Read(&uDirs, 4);
                        for (UINT i = 0; i < uDirs; i++){
                            uint16 cnt;
                            data.Read(&cnt, 2);
                            CString strDir;
                            data.Read(strDir.GetBuffer(cnt), cnt);
                            strDir.ReleaseBuffer(cnt);
d772 13
a784 12
                            CSafeMemFile tempfile(80);
                            cnt = strDir.GetLength();
                            tempfile.Write(&cnt, 2);
                            tempfile.Write((LPCTSTR)strDir, cnt);
                            Packet* replypacket = new Packet(&tempfile);
                            replypacket->opcode = OP_ASKSHAREDFILESDIR;
                            theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                            SendPacket(replypacket, true, true);
                        }
                        ASSERT( data.GetPosition() == data.GetLength() );
                        client->SetFileListRequested(uDirs);
                    }
d787 13
a799 10
                    break;
                }
                case OP_ASKSHAREDFILESDIRANS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    CSafeMemFile data((uchar*)packet, size);
                    uint16 cnt;
                    data.Read(&cnt, 2);
                    CString strDir;
                    data.Read(strDir.GetBuffer(cnt), cnt);
                    strDir.ReleaseBuffer(cnt);
d802 2
a803 1
                    if (client->GetFileListRequested() > 0){
d808 1
a808 1
                    }
d811 6
a816 5
                    break;
                }
                case OP_ASKSHAREDDENIEDANS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    ASSERT( size == 0 );
d819 2
a820 2
                    break;
                }
d863 2
a864 1
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, uint8 opcode){
d953 2
a954 1
				if (client->GetSourceExchangeVersion() >= 1){
d963 2
a964 1
					if(file) {
d1082 24
a1105 2
void CClientReqSocket::PacketReceived(Packet* packet){
	switch (packet->prot){
d1121 2
a1122 1
void CClientReqSocket::OnReceive(int nErrorCode){
d1170 4
a1173 2
void CListenSocket::OnAccept(int nErrorCode){
	if (!nErrorCode){
d1186 2
a1187 1
		while (m_nPeningConnections){
d1192 2
a1193 1
			else{
d1253 7
a1259 7
void CListenSocket::RemoveSocket(CClientReqSocket* todel){
	POSITION pos2,pos1;
	for(pos1 = socket_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
       socket_list.GetNext(pos1);
	   if ( socket_list.GetAt(pos2) == todel )
			socket_list.RemoveAt(pos2);
   }
@


1.78
log
@Fixes regarding Category directory handling
@
text
@a649 18
						// and the incoming folders
                       	for (int iCat=0;iCat<theApp.glob_prefs->GetCatCount();iCat++) {
							strDir = theApp.glob_prefs->GetCategory(iCat)->incomingpath;
							PathRemoveBackslash(strDir.GetBuffer());
							strDir.ReleaseBuffer();
							
							bool bFoundFolder=false;
							for (int ix=0;ix<arFolders.GetCount();ix++) {
								strTest=arFolders.GetAt(ix);
								if (strDir.CompareNoCase(strTest)==0) {
									bFoundFolder=true;
									break;
								}
							}
							if (!bFoundFolder)
								arFolders.Add(strDir);
						}

@


1.77
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d634 2
d649 18
@


1.76
log
@added OP_ASKSHAREDDIRS protocol
@
text
@d864 23
@


1.75
log
@extended Upload Session statistic
@
text
@d580 6
d620 181
@


1.74
log
@ban for Leecher MODs
@
text
@d397 1
a397 1
					theApp.uploadqueue->RemoveFromUploadQueue(client);
d406 1
a406 1
						theApp.uploadqueue->RemoveFromUploadQueue(client);
@


1.73
log
@- new unknown opcode 0x7a (size: 2 data: 00 d2)
@
text
@d664 3
d673 2
d1017 4
a1020 1
	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > (theApp.glob_prefs->GetMaxConperFive()*theApp.emuledlg->statisticswnd.GetMaxConperFiveModifier()) && !bIgnoreInterval) ){
@


1.72
log
@fixed access violation
@
text
@d219 1
a219 1
								AddDebugLogLine(false,_T("Client %s is using our userhash"),client->GetFullIP());
d615 1
@


1.71
log
@fixed access violation
@
text
@d677 2
a678 1
					if (client->reqfile->GetStatus()==PS_PAUSED 
d680 1
a680 1
						|| client->reqfile->GetStatus()==PS_ERROR)
@


1.70
log
@added new file state PS_STOPPED
@
text
@d432 2
a433 1
						if (client->reqfile->GetStatus()==PS_PAUSED 
d435 1
a435 1
							|| client->reqfile->GetStatus()==PS_ERROR)
@


1.69
log
@debug output for filtered clients removed
@
text
@d432 3
a434 1
						if (client->reqfile->GetStatus()==PS_PAUSED || client->reqfile->GetStatus()==PS_ERROR)
d676 3
a678 1
					if (client->reqfile->GetStatus()==PS_PAUSED || client->reqfile->GetStatus()==PS_ERROR)
@


1.68
log
@Commited for Eklmn
@
text
@d124 1
a124 1
		AddDebugLogLine(false,_T("Filtered: %s %s "), FullUserIP,theApp.ipfilter->GetLastHit());
@


1.67
log
@:) fix for new tag
@
text
@d122 2
a123 1
	if(theApp.ipfilter->IsFiltered(UserIP)) {
d126 2
d159 3
a161 1
							delete client;
d330 3
d703 2
a704 1
				if (newrank) client->SetDownloadState(DS_ONQUEUE);
@


1.66
log
@added new OP code (perhaps Horse) [DoubleT]
@
text
@d603 3
a781 4
			case OP_UNKNOWNx6A:
				theApp.downloadqueue->AddDownDataOverheadOther(size);
				break;

@


1.65
log
@all existing cases in ProcessPacket updated to 0.29b, optimization in case OP_QUEUERANKING
@
text
@d779 3
@


1.64
log
@unicode cleanup
@
text
@d184 1
a184 1
					if (client->GetClientSoft() == SO_EMULE )
d194 2
a195 18
				case OP_CHANGE_CLIENT_ID:{ //netwolf 05.05.03: support for incoming OP_CHANGE_CLIENT_ID (Maella)
					CSafeMemFile data((BYTE*)packet, size, 0);
					uint32 nOldUserID;
					data.Read(&nOldUserID, 4);
					uint32 nNewUserID;
					data.Read(&nNewUserID, 4); 
					if(nOldUserID == client->GetUserID()){
						theApp.emuledlg->AddDebugLogLine(false, _T("%s: Change ID old=%u new=%u"), client->GetUserName(), nOldUserID, nNewUserID);
					}
					else {
					// It could happend after a very first connection with a remote lowid
						theApp.emuledlg->AddDebugLogLine(false, _T("%s: Overwrite ID current=%u new=%u (wrong old=%u)"), client->GetUserName(), client->GetUserID(), nNewUserID, nOldUserID);
					}
					client->SetUserID(nNewUserID);
					break;
				}							// netwolf END

				case OP_FILEREQUEST:{
d197 2
a198 1
					if (size == 16 || (size > 16 && client->GetExtendedRequestsVersion() > 0)){
d204 14
a217 3
						if (!reqfile || !memcmp(theApp.glob_prefs->GetUserHash(), client->GetUserHash(),16)){
                            if (!memcmp(theApp.glob_prefs->GetUserHash(), client->GetUserHash(),16)) 
                                AddDebugLogLine(false,_T("Client %s is using our userhash"),client->GetFullIP());
d237 2
a238 2
						md4cpy(client->reqfileid,packet);
						CMemFile data;
d243 2
d247 1
a247 1
						packet->opcode = OP_FILEREQANSWER;						
a249 16
						/* done with "OP_SETREQFILEID" now
						//send filestatus
						data = new CMemFile();
						data->Write(reqfile->GetFileHash(),16);
						if (reqfile->IsPartFile())
							((CPartFile*)reqfile)->WritePartStatus(data);
						else{
							uint32 null = 0;
							data->Write(&null,3);
						}
						packet = new Packet(data);
						packet->opcode = OP_FILESTATUS;
						delete data;
						theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
						SendPacket(packet,true);
						*/
a250 1
						break;
d252 2
a253 1
					throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ _T(" (OP_FILEREQUEST)"));
d290 2
a291 1
				case OP_STARTUPLOADREQ:{
d294 8
a301 5
					if( size == 16 ){
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)packet);
						if (!reqfile)
							break;
						// if wer are downloading this file, this could be a new source
d305 2
a306 1
						// check to see if this is a new file they are asking for
d309 1
d313 1
d318 2
a319 1
				case OP_QUEUERANK:{
d327 2
a328 1
				case OP_ACCEPTUPLOADREQ:{
d331 1
a331 1
					if(theApp.downloadqueue->IsPartFile(client->reqfile))
d394 10
d418 2
a419 1
				case OP_SENDINGPART:{
d421 16
a436 1
					client->ProcessBlockPacket(packet,size);
d445 2
a446 1
				case OP_SETREQFILEID:{
d448 7
a454 4
				// DbT:FileRequest
				if (size == 16){
					if (!client->GetWaitStartTime())
						client->SetWaitStartTime();
d456 16
a471 1
					CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)packet);
d473 4
a476 4
					if (!reqfile){
						// Need to send an OP_FILESTATUS for getting an answer for OP_REQUESTSOURCES!!!
						reqfile = theApp.downloadqueue->GetFileByID((uchar*)packet);
					}
d478 3
a480 8
					if (!reqfile){
						// send file request no such file packet (0x48)
						Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							md4cpy(replypacket->pBuffer, packet);
						theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size);
						SendPacket(replypacket, true);
						break;
					}
d482 7
a488 15
					// if we are downloading this file, this could be a new source
					if (reqfile->IsPartFile())
						if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() )
							theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
				            
					// check to see if this is a new file they are asking for
					if(md4cmp(client->GetUploadFileID(), packet) != 0)
						client->SetCommentDirty();

					//send filestatus
					md4cpy(client->reqfileid,packet);
					CSafeMemFile data(16+16);
					data.Write(reqfile->GetFileHash(),16);
					if (reqfile->IsPartFile())
						((CPartFile*)reqfile)->WritePartStatus(&data);
d490 2
a491 2
                    else if (reqfile->GetJumpstartEnabled())
                        reqfile->WriteJumpstartPartStatus(client, &data);
d493 44
a536 12
					//--- xrmb:partprio ---
					else if(reqfile->HasHiddenParts())
						reqfile->WritePartStatus(&data);
					//--- :xrmb ---
					else {
						uint32 null = 0;
						data.Write(&null,3);
					}
					Packet* packet = new Packet(&data);
					packet->opcode = OP_FILESTATUS;
					theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
					SendPacket(packet,true);
d539 6
a544 3
				throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ _T(" (OP_SETREQFILEID)"));
				break;
				// DbT:End
a602 9
				case OP_END_OF_DOWNLOAD:{
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size);
					if (size>=16 && !md4cmp(client->GetUploadFileID(),packet)){
						theApp.uploadqueue->RemoveFromUploadQueue(client);
						AddDebugLogLine(false, _T("%s: Upload session ended due ended transfer."), client->GetUserName());
						client->SetUploadFileID(NULL);
					}
					break;
				}
d657 2
a658 1
			case OP_COMPRESSEDPART:{
d660 17
a676 1
				client->ProcessBlockPacket(packet,size,true);
d691 2
@


1.63
log
@added support for Source Exchange v2
@
text
@d557 1
a557 1
					PacketToDebugLogLine("Unknown opcode", packet, size, opcode);	// DbT:Logging
d578 1
a578 1
			PacketToDebugLogLine("Unknown client opcode", packet, size, opcode);	// DbT:Logging
d582 1
a582 1
			PacketToDebugLogLine("Unknown protocol opcode", packet, size, opcode);
@


1.62
log
@unicode cleanup
@
text
@d678 2
a679 1
							((CPartFile*)file)->AddClientSources(&data);
@


1.61
log
@Corrected a message (I'm picky)
@
text
@d121 1
a121 1
	CString FullUserIP = inet_ntoa(sockAddr.sin_addr);
@


1.60
log
@permanent filtering in Listensocket
@
text
@d399 1
a399 1
					theApp.emuledlg->AddDebugLogLine(false, _T("%s: Upload session ended due cancled transfer."), client->GetUserName());
@


1.59
log
@unicode cleanup
@
text
@d114 16
d134 1
d174 1
d176 1
a176 1
                        AddDebugLogLine(false,_T("Filtered: %s %s "), client->GetFullIP(),theApp.ipfilter->GetLastHit());
d181 1
@


1.58
log
@A4AF switching
@
text
@d84 1
a84 1
        AddDebugLogLine(false, "Invalid client in CClientReqSocket::Disconnect()");
d158 1
a158 1
                        AddDebugLogLine(false,"Filtered: %s %s ", client->GetFullIP(),theApp.ipfilter->GetLastHit());
d202 1
a202 1
                                AddDebugLogLine(false,"Client %s is using our userhash",client->GetFullIP());
d225 1
a225 1
						uint16 namelength = (uint16)strlen(reqfile->GetFileName());
d252 1
a252 1
					throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ " (OP_FILEREQUEST)");
d275 1
a275 1
				throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ " (OP_FILEREQANSNOFIL)"); 
d341 1
a341 1
						throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (OP_ACCEPTUPLOADREQ => !reqfile)");
d380 1
a380 1
					theApp.emuledlg->AddDebugLogLine(false, "%s: Upload session ended due cancled transfer.", client->GetUserName());
d465 1
a465 1
				throw CString(GetResString(IDS_ERR_WRONGPACKAGESIZE)+ " (OP_SETREQFILEID)");
d530 1
a530 1
						AddDebugLogLine(false, "%s: Upload session ended due ended transfer.", client->GetUserName());
d537 1
a537 1
					AddDebugLogLine(false,"Unknown opcode: %i %x from %s", opcode, opcode, GetClientNameAndVersionString(client));
d557 1
a557 1
			AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERROR)+ " (%s)"
d694 1
a694 1
				AddDebugLogLine(false,"unknown extended opcode: %i %x from %s",opcode,opcode, GetClientNameAndVersionString(client));
d709 1
a709 1
		    AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION)+ " (%s)",error.GetBuffer(), GetClientNameAndVersionString(client));
@


1.57
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d268 1
a268 1
						if (!client->SwapToAnotherFile(false)) {
@


1.56
log
@Preparing for new sockets
@
text
@d29 1
d472 1
d474 3
d480 1
d482 3
d599 1
d601 3
@


1.55
log
@FEATURE: data logging of unknown tags and packets [DoubleT]
@
text
@d36 1
d917 1
@


1.54
log
@bugfix #295 in case OP_STARTUPLOADREQ isn't required
@
text
@d527 2
a528 2
					AddDebugLogLine(false,"unknown opcode: %i %x from %s",opcode,opcode, GetClientNameAndVersionString(client));
				  
d549 1
d551 1
a551 1
		else
d553 2
@


1.53
log
@converted to new logger methods
@
text
@a300 8

						if(reqfile->IsPartFile()){
							if(!((CPartFile*)reqfile)->HasParts())
								break;
						} else {
							if(!reqfile->HasParts())
								break;
						}
@


1.52
log
@fixed access violation
@
text
@d500 2
a501 2
						AddDebugLogLine(false,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
					} else AddDebugLogLine(false,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
d559 1
a559 1
			AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
d698 1
a698 1
		    AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
d721 1
a721 1
		AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENT2)
d724 1
a724 1
		AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),"CClientReqSocket::OnError");			
@


1.51
log
@code cleanup
@
text
@a343 1
							delete packet;
@


1.50
log
@small correction in Listen soket (case:OP_ACCEPTUPLOADREQ)
@
text
@d510 1
a510 1
						theApp.sharedfiles->CreateOfferedFilePacket((CKnownFile*)list.GetHead(), &tempfile);
@


1.49
log
@DoubleT: bug #295 fixed (bypass part blocking on opcode StartUploadReq)
@
text
@d329 2
a330 1
						if (client->GetDownloadState() == DS_ONQUEUE
d339 5
a343 4
					        Packet* packet = new Packet(OP_CANCELTRANSFER,0);
					        theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
					        client->socket->SendPacket(packet,false,true);
					        client->SetDownloadState(DS_ONQUEUE);
@


1.48
log
@ICR Update up to v2.3
@
text
@d289 1
d291 4
a294 4
						uchar reqfileid[16];
						md4cpy(reqfileid,packet);
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID(reqfileid);
						if (reqfile){
d298 1
d301 8
a311 1
					}
d314 1
@


1.47
log
@fixed access violation
@
text
@d323 1
@


1.46
log
@minor changes
@
text
@d311 1
a311 2
					client->SetRemoteQueueRank(rank);
					delete data;
@


1.45
log
@fixed memory leak when invalid hello packet is received
@
text
@d250 1
a250 1
					throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
d273 1
a273 1
				throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
d460 1
a460 1
				throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
@


1.44
log
@minor fixes and improvements
@
text
@d126 1
d130 9
a139 1
					client->ProcessHelloPacket(packet,size);
@


1.43
log
@*** empty log message ***
@
text
@d195 1
a195 1
							memcpy(replypacket->pBuffer, packet, 16);
d207 1
a207 1
						if(memcmp(client->reqfileid, packet, 16) != 0)
d299 1
a299 1
					CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
d301 1
a301 1
					data->Read(&rank,4);
d332 1
a332 1
					CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
d334 1
a334 1
					data->Read(reqfilehash,16);
d338 6
a343 6
					data->Read(&reqblock1->StartOffset,4);
					data->Read(&reqblock2->StartOffset,4);
					data->Read(&reqblock3->StartOffset,4);
					data->Read(&reqblock1->EndOffset,4);
					data->Read(&reqblock2->EndOffset,4);
					data->Read(&reqblock3->EndOffset,4);
a360 1
					delete data;
d424 1
a424 1
					if(md4cmp(client->reqfileid, packet) != 0)
d429 2
a430 2
					CMemFile* data = new CMemFile();
					data->Write(reqfile->GetFileHash(),16);
d432 1
a432 1
						((CPartFile*)reqfile)->WritePartStatus(data);
d435 1
a435 1
                        reqfile->WriteJumpstartPartStatus(client, data);
d439 1
a439 1
						reqfile->WritePartStatus(data);
d443 1
a443 1
						data->Write(&null,3);
d445 1
a445 1
					Packet* packet = new Packet(data);
a446 1
					delete data;
d524 5
a735 4




@


1.42
log
@L2HAC by EnkeyDev
@
text
@d482 2
a483 2
						AddDebugLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );	// netwolf 09.05.03 moved to debug log (we all love old mldonkeys, dont we ;))
					} else AddDebugLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
@


1.41
log
@*** empty log message ***
@
text
@d138 1
@


1.40
log
@*** empty log message ***
@
text
@d481 2
a482 2
						AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
					} else AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
@


1.39
log
@fixed memory leak
@
text
@d162 18
@


1.38
log
@netwolf's changes
@
text
@d193 2
a194 2
						CMemFile* data = new CMemFile();
						data->Write(reqfile->GetFileHash(),16);
d196 2
a197 2
						data->Write(&namelength,2);
						data->Write(reqfile->GetFileName(),namelength);
d199 2
a200 3
						Packet* packet = new Packet(data);
						packet->opcode = OP_FILEREQANSWER;
						delete data;
@


1.37
log
@fixes by BavarianSnail/obaldin/kuchin. see changelog+
@
text
@d290 17
a306 3
					if (client->GetDownloadState() == DS_ONQUEUE ){
						client->SetDownloadState(DS_DOWNLOADING);
						client->SendBlockRequests();
d308 2
@


1.36
log
@Upgrade to 0.28a
@
text
@d372 5
@


1.35
log
@This check is not useful
@
text
@d102 1
a102 2
	// changed to AsyncSocketEx - deadlake / Maverick
	if (m_SocketData.hSocket != INVALID_SOCKET)
d168 1
a168 1
						memcpy(reqfileid,packet,16);
d192 1
a192 1
						memcpy(client->reqfileid,packet,16);
d262 14
d310 3
a312 3
					memcpy(&reqblock1->FileID,reqfilehash,16);
					memcpy(&reqblock2->FileID,reqfilehash,16);
					memcpy(&reqblock3->FileID,reqfilehash,16);
d333 2
d346 2
a347 2
                   if (client->GetDownloadState() != DS_REQHASHSET)
                        throw CString("unwanted hashset");
d358 1
a358 1
					if (client->GetDownloadState() == DS_DOWNLOADING)		//bluecow hybrid patch
d374 1
a374 1
						memcpy(replypacket->pBuffer, packet, 16);
d386 1
a386 1
					if(memcmp(client->reqfileid, packet, 16) != 0)
d390 1
a390 1
					memcpy(client->reqfileid,packet,16);
d467 1
a467 1
				case OP_END_OF_DOWNLOAD:
d469 1
a469 1
					if (size>=16 && memcmp(client->GetUploadFileID(),packet,16)==0){
d471 1
a471 1
						theApp.emuledlg->AddDebugLogLine(false, "%s: Upload session ended due ended transfer.", client->GetUserName());
d475 1
d507 1
d625 6
d690 1
a690 2
	// changed to AsyncSocketEx - deadlake / Maverick
	BOOL result = CAsyncSocketEx::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE);
d767 1
d770 3
a772 2
	for(POSITION pos = socket_list.GetHeadPosition();pos;){
		CClientReqSocket* cur_sock = socket_list.GetNext(pos);
d776 1
a776 2
		   // changed to AsyncSocketEx - deadlake / Maverick
		   if (cur_sock->m_SocketData.hSocket != INVALID_SOCKET){
d784 1
a784 1
		   cur_sock->CheckTimeOut();
d792 5
a796 2
	for(POSITION pos = socket_list.GetHeadPosition(); pos; ){
		switch (socket_list.GetNext(pos)->GetConState()){
d824 2
a825 3
	while (!socket_list.IsEmpty())
	{
		CClientReqSocket* cur_socket = socket_list.GetHead();
d839 5
a843 13
/*    static uint32 counter = 0;
    static uint16 maxconns = 0;
    static uint16 maxconnsper5 = 0;
    if(counter==0) {*/
        uint16 maxconns = app_prefs->GetMaxConnections();
        //maxconnsper5 = (theApp.glob_prefs->GetMaxConperFive()*theApp.emuledlg->statisticswnd.GetMaxConperFiveModifier());
        uint16 maxconnsper5 = theApp.glob_prefs->GetMaxConperFive();
/*	}
    counter++;
    if(counter>1000)
        counter = 0;
*/
	return (GetOpenSockets() > maxconns || (!bIgnoreInterval && m_OpenSocketsInterval > maxconnsper5));
d851 4
a854 2
	for (POSITION pos = socket_list.GetHeadPosition();pos;){
		CClientReqSocket* cur_sock = socket_list.GetNext(pos);
@


1.34
log
@reverted some changes
@
text
@d814 1
a814 1
    static uint32 counter = 0;
d817 2
a818 2
    if(counter==0) {
        maxconns = app_prefs->GetMaxConnections();
d820 2
a821 2
        maxconnsper5 = theApp.glob_prefs->GetMaxConperFive();
	}
d825 1
a825 1

@


1.33
log
@use app shutdown mutex
@
text
@a112 1
	CSingleLock lock(&theApp.shutdownMutex, TRUE);	//[TwoBottle Mod]
@


1.32
log
@changed some clunky code
@
text
@d113 1
@


1.32.2.1
log
@27a partial merge
@
text
@d189 1
a189 1
						if(memcmp(client->GetUploadFileID(), packet, 16) != 0)
d193 1
a193 2
						client->SetUploadFileID((uchar*)packet);
//						memcpy(client->reqfileid,packet,16);
a262 14
					if( size == 16 ){
						uchar reqfileid[16];
						memcpy(reqfileid,packet,16);
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID(reqfileid);
						if (reqfile){
							if (reqfile->IsPartFile())
								if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() ) //<<--
									theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
							if(memcmp(client->GetUploadFileID(), packet, 16) != 0)
								client->SetCommentDirty();
							client->SetUploadFileID((uchar*)packet);
							client->SendCommentInfo(reqfile);
						}
					}
a319 2
					theApp.emuledlg->AddDebugLogLine(false, "%s: Upload session ended due cancled transfer.", client->GetUserName());
					client->SetUploadFileID(NULL);
d371 1
a371 1
					if(memcmp(client->GetUploadFileID(), packet, 16) != 0)
d375 1
a375 2
					client->SetUploadFileID((uchar*)packet);
//					memcpy(client->reqfileid,packet,16);
a459 134
                case OP_ASKSHAREDDIRS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    ASSERT( size == 0 );
                    if (theApp.glob_prefs->CanSeeShares()==0 || (theApp.glob_prefs->CanSeeShares()==1 && client->IsFriend())){
						AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
 
                        CSafeMemFile tempfile(80);
                        uint32 uDirs = theApp.glob_prefs->shareddir_list.GetCount();
                        tempfile.Write(&uDirs, 4);
 
                        POSITION pos = theApp.glob_prefs->shareddir_list.GetHeadPosition();
                        while (pos){
                            CString strDir = theApp.glob_prefs->shareddir_list.GetNext(pos);
                            PathRemoveBackslash(strDir.GetBuffer());
                            strDir.ReleaseBuffer();
                            uint16 cnt = strDir.GetLength();
                            tempfile.Write(&cnt, 2);
                            tempfile.Write((LPCTSTR)strDir, cnt);
                        }
 
                        Packet* replypacket = new Packet(&tempfile);
                        replypacket->opcode = OP_ASKSHAREDDIRSANS;
                        theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                        SendPacket(replypacket, true, true);
                    }
                    else{
						AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
						Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);
                        theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                        SendPacket(replypacket, true, true);
                    }
                    break;
               }
				case OP_ASKSHAREDFILESDIR:{
					theApp.downloadqueue->AddDownDataOverheadOther(size);
					CSafeMemFile data((uchar*)packet, size, 0);
					uint16 cnt;
					data.Read(&cnt, 2);
					CString strReqDir;
					data.Read(strReqDir.GetBuffer(cnt), cnt);
					strReqDir.ReleaseBuffer(cnt);
                    PathRemoveBackslash(strReqDir.GetBuffer());
                    strReqDir.ReleaseBuffer();
 
                    if (theApp.glob_prefs->CanSeeShares()==0 || (theApp.glob_prefs->CanSeeShares()==1 && client->IsFriend())){
						AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
                        ASSERT( data.GetPosition() == data.GetLength() );
 
                        CTypedPtrList<CPtrList, CKnownFile*> list;
                        for (POSITION pos = theApp.sharedfiles->m_Files_map.GetStartPosition();pos != 0;){
                            CCKey bufKey;
                            CKnownFile* cur_file;
                            theApp.sharedfiles->m_Files_map.GetNextAssoc(pos, bufKey, cur_file);
                            CString strSharedFile(cur_file->GetPath());
                            PathRemoveFileSpec(strSharedFile.GetBuffer());
                            strSharedFile.ReleaseBuffer();
                            if (strReqDir.CompareNoCase(strSharedFile) == 0)
                                list.AddTail(cur_file);
                        }
 
                        if (list.GetCount()){
                            CSafeMemFile tempfile(80);
                            uint16 cnt = strReqDir.GetLength();
                            tempfile.Write(&cnt, 2);
                            tempfile.Write((LPCTSTR)strReqDir, cnt);
                            uint32 uFiles = list.GetCount();
                            tempfile.Write(&uFiles, 4);
                            while (list.GetCount()){
                                theApp.sharedfiles->CreateOfferedFilePacket(list.GetHead(), &tempfile);
                                list.RemoveHead();
                            }
 
                            Packet* replypacket = new Packet(&tempfile);
                            replypacket->opcode = OP_ASKSHAREDFILESDIRANS;
                            theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                            SendPacket(replypacket, true, true);
                        }
                    }
                    else{
						AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
						Packet* replypacket = new Packet(OP_ASKSHAREDDENIEDANS, 0);
                        theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                        SendPacket(replypacket, true, true);
                    }
                    break;
                }
                case OP_ASKSHAREDDIRSANS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    if (client->GetFileListRequested() == 1){
                        CSafeMemFile data((uchar*)packet, size, 0);
                        uint32 uDirs;
                        data.Read(&uDirs, 4);
                        for (UINT i = 0; i < uDirs; i++){
                            uint16 cnt;
                            data.Read(&cnt, 2);
                            CString strDir;
                            data.Read(strDir.GetBuffer(cnt), cnt);
                            strDir.ReleaseBuffer(cnt);
                            AddDebugLogLine(false,GetResString(IDS_SHAREDFILES_SHARESDIR),client->GetUserName(),client->GetUserID(),strDir);

                            CSafeMemFile tempfile(80);
                            cnt = strDir.GetLength();
                            tempfile.Write(&cnt, 2);
                            tempfile.Write((LPCTSTR)strDir, cnt);
                            Packet* replypacket = new Packet(&tempfile);
                            replypacket->opcode = OP_ASKSHAREDFILESDIR;
                            theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size);
                            SendPacket(replypacket, true, true);
                        }
                        ASSERT( data.GetPosition() == data.GetLength() );
                        client->SetFileListRequested(uDirs);
                    }
                    break;
                }
                case OP_ASKSHAREDFILESDIRANS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    if (client->GetFileListRequested() > 0){
                        CSafeMemFile data((uchar*)packet, size, 0);
                        uint16 cnt;
                        data.Read(&cnt, 2);
                        CString strDir;
                        data.Read(strDir.GetBuffer(cnt), cnt);
                        strDir.ReleaseBuffer(cnt);
                        AddDebugLogLine(false,GetResString(IDS_SHAREDFILES_SHAREDFILESLIST),client->GetUserName(),client->GetUserID(),strDir);
                        client->ProcessSharedFileList(packet + data.GetPosition(), size - data.GetPosition());
                    }
                    break;
                }
                case OP_ASKSHAREDDENIEDANS:{
                    theApp.downloadqueue->AddDownDataOverheadOther(size);
                    ASSERT( size == 0 );
                    AddDebugLogLine(false,GetResString(IDS_SHAREDFILES_ACCESSDENIED),client->GetUserName(),client->GetUserID());
                    break;
                }
@


1.32.2.2
log
@27c
@
text
@d723 1
a723 1
							((CPartFile*)file)->AddClientSources(&data, client->GetSourceExchangeVersion());
@


1.31
log
@reinstate buffer flush on timeout
@
text
@d452 8
a744 1
	POSITION pos2;
d747 2
a748 3
	for(POSITION pos1 = socket_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		socket_list.GetNext(pos1);
		CClientReqSocket* cur_sock = socket_list.GetAt(pos2);
d761 1
a761 1
		socket_list.GetAt( pos2 )->CheckTimeOut();
d769 2
a770 5
	POSITION pos1,pos2;
	for(pos1 = socket_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		socket_list.GetNext(pos1);
		CClientReqSocket* cur_sock = socket_list.GetAt(pos2);
		switch (cur_sock->GetConState()){
d781 1
a781 1
   }
d800 1
a800 1
		CClientReqSocket* cur_socket = socket_list.RemoveHead();
d834 2
a835 4
	POSITION pos1, pos2;
	for (pos1 = socket_list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		socket_list.GetNext(pos1);
		CClientReqSocket* cur_sock = socket_list.GetAt(pos2);
@


1.30
log
@fixed official code... again (saw wrongly and left something out, sorry :-)
@
text
@d475 1
a475 1
//		Disconnect();
@


1.29
log
@fixed official code... again
@
text
@d797 5
a801 2
		delete socket_list.GetHead();
		socket_list.RemoveHead();
@


1.28
log
@converted to new logging method
@
text
@d795 4
a798 6
	for (POSITION pos = socket_list.GetHeadPosition();pos != 0;pos = socket_list.GetHeadPosition()){
		CClientReqSocket* cur_socket = socket_list.GetAt(pos);
			if (cur_socket->client)
				delete cur_socket->client;
			else
				delete cur_socket;
@


1.27
log
@more Jumpstarter
@
text
@d82 1
a82 1
        theApp.emuledlg->AddDebugLogLine(false, "Invalid client in CClientReqSocket::Disconnect()");
d147 1
a147 1
                        theApp.emuledlg->AddDebugLogLine(false,"Filtered: %s %s ", client->GetFullIP(),theApp.ipfilter->GetLastHit());
d173 1
a173 1
                                theApp.emuledlg->AddDebugLogLine(false,"Client %s is using our userhash",client->GetFullIP());
d428 2
a429 2
						theApp.emuledlg->AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
					} else theApp.emuledlg->AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
d454 1
a454 1
					theApp.emuledlg->AddDebugLogLine(false,"unknown opcode: %i %x from %s",opcode,opcode, GetClientNameAndVersionString(client));
d469 1
a469 1
			theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERROR)+ " (%s)"
d473 1
a473 1
			theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
d542 1
a542 1
								//theApp.emuledlg->AddDebugLogLine(false, "RCV:Source Request User(%s) File(%s)", client->GetUserName(), file->GetFileName());
d598 1
a598 1
				theApp.emuledlg->AddDebugLogLine(false,"unknown extended opcode: %i %x from %s",opcode,opcode, GetClientNameAndVersionString(client));
d605 1
a605 1
		    theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
d607 1
a607 1
		    theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION)+ " (%s)",error.GetBuffer(), GetClientNameAndVersionString(client));
d628 1
a628 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENT2)
d631 1
a631 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),"CClientReqSocket::OnError");			
@


1.26
log
@bugfixed server & global search
@
text
@d380 4
@


1.25
log
@[patch] Better Compatibility With Hybrid by bluecow
@
text
@d343 1
a343 1
					if (client->GetDownloadState() == DS_DOWNLOADING)
@


1.24
log
@xrmb updated code for Part Traffic (not the last one).
@
text
@d343 2
@


1.23
log
@Proxy Support (deadlake)
@
text
@d378 4
@


1.22
log
@version displaying in messages, fixes in chunk selection
@
text
@d102 2
a103 1
	if (m_hSocket != INVALID_SOCKET)
d649 2
a650 1
	BOOL result = CAsyncSocket::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE);
d736 2
a737 1
		   if (cur_sock->m_hSocket != INVALID_SOCKET){
@


1.22.2.1
log
@Proxy support fixes from deadlake.
@
text
@d102 1
a102 2
	// changed to AsyncSocketEx - deadlake / Maverick
	if (m_SocketData.hSocket != INVALID_SOCKET)
d648 1
a648 2
	// changed to AsyncSocketEx - deadlake / Maverick
	BOOL result = CAsyncSocketEx::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE);
d734 1
a734 2
		   // changed to AsyncSocketEx - deadlake / Maverick
		   if (cur_sock->m_SocketData.hSocket != INVALID_SOCKET){
@


1.21
log
@the famous zz upload system! :)
@
text
@d443 1
a443 1
					theApp.emuledlg->AddDebugLogLine(false,"unknown opcode: %i %x",opcode,opcode);
d458 2
a459 2
			theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERROR)
			,client->GetUserName(),client->GetFullIP(),error.GetBuffer());
d587 1
a587 1
				theApp.emuledlg->AddDebugLogLine(false,"unknown opcode: %i %x",opcode,opcode);
d593 4
a596 1
		theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
@


1.21.2.1
log
@v1a upgrade
@
text
@d443 1
a443 1
					theApp.emuledlg->AddDebugLogLine(false,"unknown opcode: %i %x from %s",opcode,opcode, GetClientNameAndVersionString(client));
d458 2
a459 2
			theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_CLIENTERROR)+ " (%s)"
			,client->GetUserName(),client->GetFullIP(),error.GetBuffer(), GetClientNameAndVersionString(client));
d587 1
a587 1
				theApp.emuledlg->AddDebugLogLine(false,"unknown extended opcode: %i %x from %s",opcode,opcode, GetClientNameAndVersionString(client));
d593 1
a593 4
        if(!client)
		    theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
        else
		    theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION)+ " (%s)",error.GetBuffer(), GetClientNameAndVersionString(client));
@


1.21.2.2
log
@keeping in sync with the main cvs line
@
text
@d102 1
a102 2
	// changed to AsyncSocketEx - deadlake / Maverick
	if (m_SocketData.hSocket != INVALID_SOCKET)
a376 4
					//--- xrmb:partprio ---
					else if(reqfile->HasHiddenParts())
						reqfile->WritePartStatus(data);
					//--- :xrmb ---
d648 1
a648 2
	// changed to AsyncSocketEx - deadlake / Maverick
	BOOL result = CAsyncSocketEx::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE);
d734 1
a734 2
		   // changed to AsyncSocketEx - deadlake / Maverick
		   if (cur_sock->m_SocketData.hSocket != INVALID_SOCKET){
@


1.20
log
@disable "soft" max per 5 connections
@
text
@d531 1
a531 1
								theApp.emuledlg->AddDebugLogLine(false, "RCV:Source Request User(%s) File(%s)", client->GetUserName(), file->GetFileName());
@


1.19
log
@Code clean up and double check wit official code.
@
text
@d170 3
a172 1
						if (!reqfile){
d799 2
a800 1
        maxconnsper5 = (theApp.glob_prefs->GetMaxConperFive()*theApp.emuledlg->statisticswnd.GetMaxConperFiveModifier());
@


1.18
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d82 1
a82 1
        theApp.emuledlg->AddDebugLogLine(false, "DEBUG: Invalid client in CClientReqSocket::Disconnect()");
d146 1
a146 2
                        theApp.emuledlg->AddDebugLogLine(false,"Filtered: %s %s "/*GetResString(IDS_IPFILTERED)*/,
                            client->GetFullIP(),theApp.ipfilter->GetLastHit()); // if we decide we are going to keep this, we'll add a proper string
d529 1
a529 1
//								theApp.emuledlg->AddDebugLogLine( false, "RCV:Source Request User(%s) File(%s)", client->GetUserName(), file->GetFileName() );
d803 1
a803 2

	return (GetOpenSockets() > maxconns || (!bIgnoreInterval && m_OpenSocketsInterval > maxconnsper5) );
@


1.17
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d146 1
a146 1
                        theApp.emuledlg->AddLogLine(true,"Filtered: %s %s "/*GetResString(IDS_IPFILTERED)*/,
d442 1
a442 1
					theApp.emuledlg->AddDebugLogLine(false,"unknown opcode: %i %h",opcode,opcode);
d586 1
a586 1
				theApp.emuledlg->AddDebugLogLine(false,"unknown opcode: %i %h",opcode,opcode);
@


1.16
log
@better out-of-disk-space handling
@
text
@d30 6
@


1.15
log
@*** empty log message ***
@
text
@d138 9
@


1.14
log
@more 26b merges
@
text
@d515 1
a515 1
								theApp.emuledlg->AddDebugLogLine( false, "RCV:Source Request User(%s) File(%s)", client->GetUserName(), file->GetFileName() );
@


1.13
log
@removed extra unnecessary packet
@
text
@d112 1
a112 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d119 1
a119 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d139 1
a139 1
					if (client->GetClientSoft() == SO_EMULE || client->GetClientSoft() == SO_CDONKEY)
d141 1
d149 1
a149 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d161 1
a161 1
							theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size, 0);
d186 1
a186 1
						theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d211 1
a211 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d235 1
a235 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d240 1
a240 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d245 1
a245 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d250 1
a250 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d259 1
a259 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d267 1
a267 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d301 1
a301 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d306 1
a306 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d313 1
a313 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size,0);
d325 1
a325 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d329 1
a329 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d341 1
a341 1
						theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size, 0);
d368 1
a368 1
					theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d377 1
a377 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d390 1
a390 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d416 1
a416 1
					theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size, 0);
d421 1
a421 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d426 1
a426 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d460 1
a460 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d466 1
a466 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d471 1
a471 1
//				theApp.downloadqueue->AddDownDataOverheadOther(0, 24);
d476 1
a476 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d486 1
a486 1
				theApp.downloadqueue->AddDownDataOverheadSourceExchange(size, 0);
d513 1
a513 1
								theApp.uploadqueue->AddUpDataOverheadSourceExchange(tosend->size, 0);
d523 1
a523 1
				theApp.downloadqueue->AddDownDataOverheadSourceExchange(size, 0);
d548 1
a548 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d570 1
a570 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
@


1.12
log
@Small changes
@
text
@d187 1
d202 1
d312 3
a314 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
@


1.11
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d387 2
a388 2
					if (theApp.glob_prefs->CanSeeShares() == 0 ||					// everybody
						(theApp.glob_prefs->CanSeeShares() == 1 && client->IsFriend() ) )	// friend
@


1.10
log
@Coments exchange improvments added
@
text
@d75 4
a107 2
			if ( opcode != OP_SENDINGPART )
				theApp.downloadqueue->AddDownDataRateMSOverhead(size, 160);
d112 1
d119 1
d139 1
a139 1
					if (client->GetClientSoft() == SO_EMULE)
d148 1
d152 4
a155 3
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)packet);
						if (!reqfile)
						{
d160 1
a160 1
							theApp.uploadqueue->AddUpDataRateMSOverhead(replypacket->size, 160);
a162 1

d185 1
a185 1
						theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d199 1
a199 1
						theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d208 1
a208 1
					theApp.downloadqueue->AddDownDataRateMSOverhead(size, 160);
d232 1
d237 1
d242 1
d247 1
d256 1
d264 1
d298 1
d303 1
d310 1
d315 1
d320 1
d324 1
a324 1
					theApp.downloadqueue->AddDownDataRateMSOverhead(size, 160);
d336 1
a336 1
						theApp.uploadqueue->AddUpDataRateMSOverhead(replypacket->size, 160);
d363 1
a363 1
					theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d372 1
d384 2
a385 2
				case OP_ASKSHAREDFILES:
				{	// client wants to know what we have in share, let's see if we allow him to know that
d401 1
a401 1
					CSafeMemFile tempfile(100);
d411 1
a411 1
					theApp.uploadqueue->AddUpDataRateMSOverhead(replypacket->size, 160);
d415 2
a416 2
				case OP_ASKSHAREDFILESANSWER:
				{	
d421 1
d443 1
a443 1
		Disconnect();
a452 2
		if( opcode != OP_COMPRESSEDPART )
			theApp.downloadqueue->AddDownDataRateMSOverhead(size, 160);
d455 1
d461 1
d466 1
d471 1
d481 1
d508 1
a508 1
								theApp.uploadqueue->AddUpDataRateMSOverhead(tosend->size, 160);
d518 1
d543 1
d565 1
d573 2
a574 2
		client->SetDownloadState(DS_ERROR);		
		Disconnect();
d773 6
a778 2
	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > theApp.glob_prefs->GetMaxConperFive() && !bIgnoreInterval) ){
		return true;
d780 6
a785 2
	else
		return false;
@


1.9
log
@*** empty log message ***
@
text
@d308 41
a348 2
					if (size == 16)
						memcpy(client->reqfileid,packet,16);
d350 4
@


1.8
log
@Another check ported
@
text
@d154 1
a154 1
							theApp.uploadqueue->AddUpDataRateMSOverhead(replypacket->size, 0);
d201 24
@


1.7
log
@*** empty log message ***
@
text
@d144 1
a144 1
					if (size == 16){
@


1.6
log
@Hybrid clienr queue position reporting
@
text
@d149 9
d159 1
d176 1
@


1.5
log
@Merge from official sockets
@
text
@d203 8
@


1.5.2.1
log
@initial upgrade to .26
@
text
@d104 2
a109 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
a115 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d135 1
a135 1
					if (client->GetClientSoft() == SO_EMULE || client->GetClientSoft() == SO_CDONKEY)
d144 1
a144 2
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
					if (size == 16 || (size > 16 && client->GetExtendedRequestsVersion() > 0)){
d147 2
a148 11
						uchar reqfileid[16];
						memcpy(reqfileid,packet,16);
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID(reqfileid);
						if (!reqfile){
							// DbT:FileRequest
							// send file request no such file packet (0x48)
							Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							memcpy(replypacket->pBuffer, packet, 16);
							theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size, 0);
							SendPacket(replypacket, true);
							// DbT:End
a149 1
						}
a165 1
						client->ProcessUpFileStatus(packet,size);
d169 1
a169 1
						theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d183 1
a183 1
						theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
a190 24
				case OP_FILEREQANSNOFIL:{
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
				// DbT:FileRequest
				if (size == 16) {
					// if that client do not have my file maybe has another different
					CPartFile* reqfile = theApp.downloadqueue->GetFileByID((uchar*)packet);
					if (!reqfile)
						break;

					// we try to swap to another file ignoring no needed parts files
					if (client) switch (client->GetDownloadState()) {
						case DS_ONQUEUE:
						case DS_NONEEDEDPARTS:
						if (!client->SwapToAnotherFile(false)) {
							theApp.downloadqueue->RemoveSource(client, true);
						}
						break;
					}
					break;
				}
				throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
				break;
				// DbT:End
				}
a191 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a195 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a199 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a202 9
				case OP_QUEUERANK:{
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
					CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
					uint32 rank;
					data->Read(&rank,4);
					client->SetRemoteQueueRank(rank);
					delete data;
					break;
				}
a203 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a210 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a243 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a247 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a253 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
a257 1
//					theApp.downloadqueue->AddDownDataOverheadOther(0, 24);
a261 1
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
d265 2
a266 41
					theApp.downloadqueue->AddDownDataOverheadFileRequest(size, 0);
				// DbT:FileRequest
				if (size == 16){
					if (!client->GetWaitStartTime())
						client->SetWaitStartTime();

					CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)packet);

					if (!reqfile){
						// send file request no such file packet (0x48)
						Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
						memcpy(replypacket->pBuffer, packet, 16);
						theApp.uploadqueue->AddUpDataOverheadFileRequest(replypacket->size, 0);
						SendPacket(replypacket, true);
						break;
					}

					// if we are downloading this file, this could be a new source
					if (reqfile->IsPartFile())
						if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() )
							theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
				            
					// check to see if this is a new file they are asking for
					if(memcmp(client->reqfileid, packet, 16) != 0)
						client->SetCommentDirty();

					//send filestatus
					memcpy(client->reqfileid,packet,16);
					CMemFile* data = new CMemFile();
					data->Write(reqfile->GetFileHash(),16);
					if (reqfile->IsPartFile())
						((CPartFile*)reqfile)->WritePartStatus(data);
					else {
						uint32 null = 0;
						data->Write(&null,3);
					}
					Packet* packet = new Packet(data);
					packet->opcode = OP_FILESTATUS;
					delete data;
					theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
					SendPacket(packet,true);
a268 4
				throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
				break;
				// DbT:End
				}
a269 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d281 2
a282 2
				case OP_ASKSHAREDFILES:	{	// client wants to know what we have in share, let's see if we allow him to know that
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d298 1
a298 1
					CSafeMemFile tempfile(80);
d308 1
a308 1
					theApp.uploadqueue->AddUpDataOverheadOther(replypacket->size, 0);
d312 2
a313 2
				case OP_ASKSHAREDFILESANSWER:{
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
a317 1
					theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d339 1
a339 1
//		Disconnect();
d349 2
a352 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
a357 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
a361 1
//				theApp.downloadqueue->AddDownDataOverheadOther(0, 24);
a365 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
a374 1
				theApp.downloadqueue->AddDownDataOverheadSourceExchange(size, 0);
d401 1
a401 1
								theApp.uploadqueue->AddUpDataOverheadSourceExchange(tosend->size, 0);
a410 1
				theApp.downloadqueue->AddDownDataOverheadSourceExchange(size, 0);
a434 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
a455 1
				theApp.downloadqueue->AddDownDataOverheadOther(size, 0);
d463 2
a464 2
		if (client) client->SetDownloadState(DS_ERROR);		
//		Disconnect();
d663 1
a663 1
	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > (theApp.glob_prefs->GetMaxConperFive()*theApp.emuledlg->statisticswnd.GetMaxConperFiveModifier()) && !bIgnoreInterval) ){
@


1.5.2.2
log
@more speedups
@
text
@d769 5
a773 13
    static uint32 counter = 0;
    static uint16 maxconns = 0;
    static uint16 maxconnsper5 = 0;
    if(counter==0) {
        maxconns = app_prefs->GetMaxConnections();
        maxconnsper5 = (theApp.glob_prefs->GetMaxConperFive()*theApp.emuledlg->statisticswnd.GetMaxConperFiveModifier());
    }
    counter++;
    if(counter>1000)
        counter = 0;


	return (GetOpenSockets() > maxconns || (!bIgnoreInterval && m_OpenSocketsInterval > maxconnsper5) );
@


1.5.2.3
log
@put in some protection against a strange corruption bug (present since .25)
@
text
@d75 1
a75 2
	if (!client || !theApp.clientlist->Debug_IsValidClient(this)) // obaldin: a quick fix for a strange bug
        theApp.emuledlg->AddLogLine(false, "DEBUG: Invalid client in CClientReqSocket::Disconnect()");
@


1.5.2.4
log
@put in some protection against a strange corruption bug (present since .25)
@
text
@d75 1
a75 1
    if (!client || !theApp.clientlist->Debug_IsValidClient(client)) { // obaldin: a quick fix for a strange bug
a77 1
    }
@


1.5.2.5
log
@more fixes, more merging, try/catch balancing
@
text
@d75 1
a75 1
    if(!theApp.clientlist->Debug_IsValidClient(client)) { // obaldin: a quick fix for a strange bug
d77 1
a77 1
        client = 0;
a78 2
    if (!client)
		Safe_Delete();
@


1.5.2.6
log
@less messages
@
text
@d75 1
a75 1
    if(client && !theApp.clientlist->Debug_IsValidClient(client)) { // obaldin: a quick fix for a strange bug
@


1.4
log
@2.5 bugfixes
@
text
@d32 1
a32 4
CClientReqSocket::CClientReqSocket(CPreferences* in_prefs,CUpDownClient* in_client)
{
	EMULE_TRY

a40 2

	EMULE_CATCH
d44 1
a44 4
CClientReqSocket::~CClientReqSocket()
{
	EMULE_TRY

a50 2

	EMULE_CATCH
d53 1
a53 2
void CClientReqSocket::ResetTimeOutTimer()
{
d57 1
a57 4
bool CClientReqSocket::CheckTimeOut()
{
	EMULE_TRY

a62 3

	EMULE_CATCH

d66 1
a66 4
void CClientReqSocket::OnClose(int nErrorCode)
{
	EMULE_TRY

a69 2

	EMULE_CATCH
d72 1
a72 4
void CClientReqSocket::Disconnect()
{
	EMULE_TRY

a78 2

	EMULE_CATCH
d81 1
a81 3
void CClientReqSocket::Delete_Timed()
{
	EMULE_TRY
a85 2

	EMULE_CATCH
d88 1
a88 4
void CClientReqSocket::Safe_Delete()
{
	EMULE_TRY

d92 1
a92 1
	if (m_SocketData.hSocket != INVALID_SOCKET)  //Maverick
a98 2

	EMULE_CATCH
d101 1
a101 4
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, uint8 opcode)
{
	EMULE_TRY

d116 1
a116 2
					if (!client)
					{
d120 9
a128 10
					client->ProcessHelloPacket(packet,size); 
					// now we check if we now this client already. if yes this socket will 
					// be attached to the known client, the new client will be deleted 
					// and the var. "client" will point to the known client. 
					// if not we keep our new-constructed client ;) 
					if (theApp.clientlist->AttachToAlreadyKnown(&client,this))
					{ 
						// update the old client informations 
						client->ProcessHelloPacket(packet,size); 
					} 
d130 1
a130 1
						theApp.clientlist->AddClient(client); 
d134 7
a140 31
					// send a response packet with standart informations 
					if (client->GetClientSoft() == SO_EMULE) 
						client->SendMuleInfoPacket(false); 
					client->SendHelloAnswer(); 
					if (client) 
						client->ConnectionEstablished(); 

					break; 
				}
				case OP_FILEREQANSNOFIL:{
					// DbT:FileRequest
					if (size == 16) {
						// if that client do not have my file maybe has another different
						CPartFile* reqfile = theApp.downloadqueue->GetFileByID((uchar*)packet);
						if (!reqfile)
							break;
						
						// we try to swap to another file ignoring no needed parts files
						if (client) {
							switch (client->GetDownloadState()) {
								case DS_ONQUEUE:
								case DS_NONEEDEDPARTS:
									if (!client->SwapToAnotherFile(false)) {
										theApp.downloadqueue->RemoveSource(client, true);
									}
									break;
							}
						}
						break;
					}
					throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
a141 1
					// DbT:End
d148 1
a148 6
						if (!reqfile) {
							// DbT:FileRequest
							Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							memcpy(replypacket->pBuffer, packet, 16);
							SendPacket(replypacket, true);
							// DbT:End
d150 1
a150 2
						}
						// if we are downloading this file, this could be a new source
d152 3
a154 11
							if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount())
							{ 
                        		// [Lord KiRon] 
                           		if (!theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client)) 
                           		{ 
                              		client = NULL;
		                            break; 
                           		} 
                        		// [Lord KiRon] 
		                    } 

d171 14
d265 1
a265 31
					// DbT:FileRequest
					if (size == 16) {
						if (!client->GetWaitStartTime())
							client->SetWaitStartTime();
						CKnownFile* reqfile = theApp.sharedfiles->GetFileByID((uchar*)packet);

						// send file request no such file packet (0x48)
						if (!reqfile) {
							Packet* replypacket = new Packet(OP_FILEREQANSNOFIL, 16);
							memcpy(replypacket->pBuffer, packet, 16);
							SendPacket(replypacket, true);
							break;
						}
						
						// [Lord KiRon]
     					BOOL bDelete = FALSE;
     					// [/Lord KiRon]
						// if we are downloading this file, this could be a new source
						if (reqfile->IsPartFile())
							if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount())
							{ 
								// [Lord KiRon]
       							bDelete = !theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
       							// [/Lord KiRon]
		                    } 

						// check to see if this is a new file they are asking for
						if(memcmp(client->reqfileid, packet, 16) != 0)
							client->SetCommentDirty();
						
						//send filestatus
a266 29
						CMemFile* data = new CMemFile();
						data->Write(reqfile->GetFileHash(),16);
    //--- xrmb:partprio ---
						if (reqfile->IsPartFile())
							((CPartFile*)reqfile)->WritePartStatus(data);
    //--- xrmb:partprio ---
    else
      if(reqfile->HasHiddenParts())
        reqfile->WritePartStatus(data);
    //--- :xrmb ---
						else{
							uint32 null = 0;
							data->Write(&null,3);
						}
    //--- :xrmb ---
						Packet* packet = new Packet(data);
						packet->opcode = OP_FILESTATUS;
						delete data;
						SendPacket(packet,true);
						// [Lord KiRon]
					    if ( bDelete )
					    {
					    	delete client;
					      	client = NULL;
					    }
					    // [/Lord KiRon]
						break;
					}
					throw GetResString(IDS_ERR_WRONGPACKAGESIZE);
a267 1
					// DbT:End
d312 2
a313 2
				case OP_ASKSHAREDFILESANSWER: 
				{ 
d316 1
a316 1
					} 
d336 1
a336 1
		else if(theApp.glob_prefs->GetBugReport())
a342 4

	EMULE_CATCH

	return false;
d345 1
a345 4
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, uint8 opcode)
{
	EMULE_TRY

d354 1
a354 4
				// Added by Tarod <8/1/2002>
				// Test if remote client is really a eMule client. This avoid that MLDonkey try to
				// now if we are faking a MLDonkey client (indeed we do)
				if (client->GetClientSoft() == SO_EMULE) client->SendMuleInfoPacket(true);
a367 2
				// By Maverick
				// Extended Ranking Info
a368 5
				uint16 nBaseModifier;
				uint16 nRatio;
				uint32 nScore;
				uint8  nCommunity;
				uint16 nClientSpeed;
a370 5
				memcpy(&nBaseModifier,packet+2,1);
				memcpy(&nRatio,packet+3,2);
				memcpy(&nScore,packet+5,4);
				memcpy(&nCommunity,packet+9,1);
				memcpy(&nClientSpeed,packet+11,2);
a371 12
				if ((nBaseModifier > 0) && (nCommunity != 0))
				{
					client->SetRemoteBaseModifier(nBaseModifier);
					client->SetRemoteRatio(nRatio);
					client->SetRemoteScore(nScore);
					if (nCommunity == 1) client->SetRemoteCommunity(true);
					else client->SetRemoteCommunity(false);
					if (nCommunity == 2) client->SetRemoteCommunityEnabled(true);
					else client->SetRemoteCommunityEnabled(false);
				}
				client->SetRemoteClientSpeed(nClientSpeed);
				// END Maverick
a378 6

                    // Added by Tarod -in case that we disabled source exchange we do not send
                    // sources to anybody
                    if (theApp.glob_prefs->IsDisabledXS())
                        break;
				
d392 2
a393 1
                              (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK)) ||
d395 3
a397 3
                            // but only if we haven't asked someone else in last 10 minutes
                            ((bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY))) 
                        {
d406 1
a406 1
					}
d416 9
a424 7
					if (file && file->IsPartFile()){
						//set the client's answer time
						client->SetLastSrcAnswerTime();
						//and set the file's last answer time
						((CPartFile*)file)->SetLastAnsweredTime();

						((CPartFile*)file)->AddClientSources(&data);
d463 1
a463 3

		if(client)	// kuchin [1.1.2003]
			client->SetDownloadState(DS_ERROR);		
a467 4

	EMULE_CATCH

	return false;
d475 1
a475 4
void CClientReqSocket::OnSend(int nErrorCode)
{
	EMULE_TRY

a477 2

	EMULE_CATCH
d480 1
a480 3
void CClientReqSocket::OnError(int nErrorCode)
{
	EMULE_TRY
a487 2

	EMULE_CATCH
d490 1
a490 4
void CClientReqSocket::PacketReceived(Packet* packet)
{
	EMULE_TRY

a504 2

	EMULE_CATCH
d507 1
a507 4
void CClientReqSocket::OnReceive(int nErrorCode)
{
	EMULE_TRY

a509 2

	EMULE_CATCH
d512 1
a512 4
bool CClientReqSocket::Create()
{
	EMULE_TRY

d514 1
a514 2
    // Maverick
	//BOOL result = CListenSocketBaseClass::Create();
d516 1
a516 7
	//return result;
    return TRUE;
    // end Maverick

	EMULE_CATCH

	return false;
a518 40
int CClientReqSocket::OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2)
{
	EMULE_TRY
	ASSERT(pLayer);
	if (nType==LAYERCALLBACK_STATECHANGE)
	{
	}
	else if (nType==LAYERCALLBACK_LAYERSPECIFIC)
	{
		if (pLayer==m_pProxyLayer)
		{
			switch (nParam1)
			{
			case PROXYERROR_NOCONN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_NOCONN));
				break;
			case PROXYERROR_REQUESTFAILED:
				//theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_REQUESTFAILED));
				m_ProxyConnectFailed = true;
				break;
			case PROXYERROR_AUTHTYPEUNKNOWN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHTYPEUNKNOWN));
				break;
			case PROXYERROR_AUTHFAILED:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHFAILED));
				break;
			case PROXYERROR_AUTHNOLOGON:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHNOLOGON));
				break;
			case PROXYERROR_CANTRESOLVEHOST:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_CANTRESOLVEHOST));
				break;
			default:
				theApp.emuledlg->AddLogLine(false,__FILE__, __LINE__, _T("Unknown proxy error") );
			}
		}
	}
	EMULE_CATCH
	return 1;
}
d527 1
a527 4
CListenSocket::CListenSocket(CPreferences* in_prefs)
{
	EMULE_TRY

a532 4
	bProxyListening = false;
	m_pProxyLayer = NULL;

	EMULE_CATCH
d535 1
a535 4
CListenSocket::~CListenSocket()
{
	EMULE_TRY

a537 2

	EMULE_CATCH
d540 1
a540 4
bool CListenSocket::StartListening()
{
	EMULE_TRY

d542 1
a542 5
	return (Create(app_prefs->GetListenPort(),SOCK_STREAM,FD_ACCEPT) && Listen());

	EMULE_CATCH

	return false;
d545 1
a545 4
void CListenSocket::ReStartListening()
{
	EMULE_TRY

a550 2

	EMULE_CATCH
d553 1
a553 2
void CListenSocket::StopListening()
{
a557 3
void CListenSocket::OnAccept(int nErrorCode)
{
	EMULE_TRY
d559 1
d572 1
a572 1

d575 8
a582 8
		CClientReqSocket* newclient = new CClientReqSocket(app_prefs);
		if (!Accept(*newclient))
			newclient->Safe_Delete();
		else{
			newclient->AsyncSelect(FD_WRITE|FD_READ|FD_CLOSE);
			newclient->OnInit();
		}
		AddConnection();
a587 1
	EMULE_CATCH
d590 1
a590 4
void CListenSocket::Process()
{
	EMULE_TRY

d600 1
a600 1
		   if (cur_sock->m_SocketData.hSocket != INVALID_SOCKET){
a611 2

   EMULE_CATCH
d614 1
a614 4
void CListenSocket::RecalculateStats()
{
	EMULE_TRY

d631 1
a631 2
	}
	EMULE_CATCH
d634 1
a634 4
void CListenSocket::AddSocket(CClientReqSocket* toadd)
{
	EMULE_TRY

a635 2

	EMULE_CATCH
d638 1
a638 4
void CListenSocket::RemoveSocket(CClientReqSocket* todel)
{
	EMULE_TRY

d644 1
a644 3
	}

	EMULE_CATCH
d647 1
a647 4
void CListenSocket::KillAllSockets()
{
	EMULE_TRY

a654 2

	EMULE_CATCH
d657 1
a657 2
void CListenSocket::AddConnection()
{
d662 2
a663 5
bool CListenSocket::TooManySockets(bool bIgnoreInterval)
{
	EMULE_TRY

	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > theApp.glob_prefs->GetMaxConperFive() && !bIgnoreInterval) )
d665 3
a667 4

	EMULE_CATCH

	return false;
d670 1
a670 4
bool CListenSocket::IsValidSocket(CClientReqSocket* totest)
{
	EMULE_TRY

a671 4

	EMULE_CATCH

	return false;
d674 1
a674 4
void CListenSocket::Debug_ClientDeleted(CUpDownClient* deleted)
{
	EMULE_TRY

a685 113

	EMULE_CATCH
}

//void CListenSocket::OpenProxyListenSocket(ULONG ip, UINT port, CServerSocket* sender)
void CListenSocket::OpenProxyListenSocket(ULONG ip, UINT port)
{
	if(!bProxyListening)
	{
		//m_ListenRequestSender = sender;
		bProxyListening = false;
		CEMSocketBaseClass::Close();
		ProxySettings settings = theApp.glob_prefs->GetProxy();
		if (settings.UseProxy && settings.type!=PROXYTYPE_NOPROXY)
		{
			m_pProxyLayer=new CAsyncProxySocketLayer;
			switch (settings.type)
			{
				case PROXYTYPE_SOCKS4:
					m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS4,settings.name,settings.port);
					break;
				case PROXYTYPE_SOCKS4A:
					m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS4A,settings.name,settings.port);
					break;
				case PROXYTYPE_SOCKS5:
					if (settings.EnablePassword)
						m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS5,settings.name, settings.port, settings.user, settings.password);
					else
						m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS5,settings.name,settings.port);
					break;
				case PROXYTYPE_HTTP11:
					if (settings.EnablePassword)
						m_pProxyLayer->SetProxy(PROXYTYPE_HTTP11,settings.name,settings.port, settings.user, settings.password);
					else
						m_pProxyLayer->SetProxy(PROXYTYPE_HTTP11,settings.name,settings.port);
					break;
				default: ASSERT(FALSE);
			}
			m_pProxyLayer->PrepareListen(ip);
			AddLayer(m_pProxyLayer);
		}

		// Connection Initialisation
		bListening = true;
		Create();
		AsyncSelect(FD_ACCEPT);
		CEMSocketBaseClass::Listen();
		return;
	} else theApp.serverconnect->ListenPortEstablishedCallback();
}

int CListenSocket::OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2)
{
	EMULE_TRY
	ASSERT(pLayer);
	if (nType==LAYERCALLBACK_STATECHANGE)
	{
		CString logline;
		if (pLayer==m_pProxyLayer)
		{
			//logline.Format(_T("ProxyLayer changed state from %d to %d"), nParam2, nParam1);
			//theApp.emuledlg->AddLogLine(false,logline);
		}else
			//logline.Format(_T("Layer @@ %d changed state from %d to %d"), pLayer, nParam2, nParam1);
			//theApp.emuledlg->AddLogLine(false,logline);
		return 1;
	}
	else if (nType==LAYERCALLBACK_LAYERSPECIFIC)
	{
		CString logline;
		uint16 nPort;
		if (pLayer==m_pProxyLayer)
		{
			switch (nParam1)
			{
			case PROXYERROR_NOCONN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_NOCONN));
				break;
			case PROXYERROR_REQUESTFAILED:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_REQUESTFAILED));
				break;
			case PROXYERROR_AUTHTYPEUNKNOWN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHTYPEUNKNOWN));
				break;
			case PROXYERROR_AUTHFAILED:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHFAILED));
				break;
			case PROXYERROR_AUTHNOLOGON:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHNOLOGON));
				break;
			case PROXYERROR_CANTRESOLVEHOST:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_CANTRESOLVEHOST));
				break;
			case PROXYSTATUS_LISTENSOCKETCREATED:
				t_ListenSocketCreatedStruct* data;
				data = (t_ListenSocketCreatedStruct*) nParam2;
				nPort = data->nPort;
				nPort = (nPort & 0xFF) * 0x100 + (nPort & 0xFF00) / 0x100;
				logline.Format(_T("Listenport on IP %lu Port %lu"),data->ip,nPort);
				theApp.glob_prefs->SetListenPort(nPort);
				theApp.emuledlg->AddLogLine(false,logline);
				//bProxyListening = true;
				//m_ListenRequestSender->ProxyListenPortEstablished();
				//theApp.serverconnect->ConnectionEstablished(m_ListenRequestSender);
				theApp.serverconnect->ListenPortEstablishedCallback();
				break;
			default:
				theApp.emuledlg->AddLogLine(false,__FILE__, __LINE__, _T("Unknown proxy error") );
			}
		}
	}
	EMULE_CATCH
	return 1;
a686 2


@


1.3
log
@updated to .25b codebase
@
text
@a250 18
						//send filestatus
						data = new CMemFile();
						data->Write(reqfile->GetFileHash(),16);
						if (reqfile->IsPartFile())
							((CPartFile*)reqfile)->WritePartStatus(data);
						//--- xrmb:partprio ---
						else if(reqfile->HasHiddenParts())
							reqfile->WritePartStatus(data);
						//--- :xrmb ---
						else{
							uint32 null = 0;
							data->Write(&null,3);
						}
						packet = new Packet(data);
						packet->opcode = OP_FILESTATUS;
						delete data;
						theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
						SendPacket(packet,true);
d365 1
d368 5
d377 1
a381 1
						client->SendCommentInfo(reqfile);
d419 2
a420 2
						theApp.emuledlg->AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID,GetResString(IDS_ACCEPTED) );
					} else theApp.emuledlg->AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID,GetResString(IDS_DENIED) );
@


1.3.2.1
log
@official sockets
@
text
@d32 4
a35 1
CClientReqSocket::CClientReqSocket(CPreferences* in_prefs,CUpDownClient* in_client){
d44 2
d49 4
a52 1
CClientReqSocket::~CClientReqSocket(){
d59 2
d63 2
a64 1
void CClientReqSocket::ResetTimeOutTimer(){
d68 4
a71 1
bool CClientReqSocket::CheckTimeOut(){
d77 3
d83 4
a86 1
void CClientReqSocket::OnClose(int nErrorCode){
d90 2
d94 4
a97 1
void CClientReqSocket::Disconnect(){
d104 2
d108 3
a110 1
void CClientReqSocket::Delete_Timed(){
d115 2
d119 4
a122 1
void CClientReqSocket::Safe_Delete(){
d126 1
a126 1
	if (m_hSocket != INVALID_SOCKET)
d133 2
d137 4
a140 1
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, uint8 opcode){
d155 2
a156 1
					if (!client){
d160 10
a169 9
					client->ProcessHelloPacket(packet,size);
					// now we check if we now this client already. if yes this socket will
					// be attached to the known client, the new client will be deleted
					// and the var. "client" will point to the known client.
					// if not we keep our new-constructed client ;)
					if (theApp.clientlist->AttachToAlreadyKnown(&client,this)){
						// update the old client informations
						client->ProcessHelloPacket(packet,size);
					}
d171 1
a171 1
						theApp.clientlist->AddClient(client);
d175 31
a205 7
					// send a response packet with standart informations
					if (client->GetClientSoft() == SO_EMULE)
						client->SendMuleInfoPacket(false);
					client->SendHelloAnswer();
					if (client)
						client->ConnectionEstablished();

d207 1
d214 6
a219 1
						if (!reqfile)
d221 2
a222 1
						// if wer are downloading this file, this could be a new source
d224 11
a234 3
							if( theApp.glob_prefs->GetMaxSourcePerFile() > ((CPartFile*)reqfile)->GetSourceCount() ) //<<--
								theApp.downloadqueue->CheckAndAddKnownSource((CPartFile*)reqfile,client);
						
d256 4
d349 31
a379 1
					if (size == 16)
d381 23
d405 1
d431 2
a432 2
						theApp.emuledlg->AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_ACCEPTED) );
					} else theApp.emuledlg->AddLogLine(true,GetResString(IDS_REQ_SHAREDFILES),client->GetUserName(),client->GetUserID(),GetResString(IDS_DENIED) );
d450 2
a451 2
				case OP_ASKSHAREDFILESANSWER:
				{	
d454 1
a454 1
				}
d474 1
a474 1
		else
d481 4
d487 4
a490 1
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, uint8 opcode){
d499 4
a502 1
				client->SendMuleInfoPacket(true);
d516 2
d519 5
d526 5
d532 12
d551 6
d570 1
a570 2
						      (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK)
						    ) ||
d572 3
a574 3
						    ( (bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY) )
						  ) {
	
d583 1
a583 1
						}
d593 7
a599 9
					if(file){
						if (file->IsPartFile()){
							//set the client's answer time
							client->SetLastSrcAnswerTime();
							//and set the file's last answer time
							((CPartFile*)file)->SetLastAnsweredTime();
	
							((CPartFile*)file)->AddClientSources(&data);
						}
d638 3
a640 1
		client->SetDownloadState(DS_ERROR);		
d645 4
d656 4
a659 1
void CClientReqSocket::OnSend(int nErrorCode){
d662 2
d666 3
a668 1
void CClientReqSocket::OnError(int nErrorCode){
d676 2
d680 4
a683 1
void CClientReqSocket::PacketReceived(Packet* packet){
d698 2
d702 4
a705 1
void CClientReqSocket::OnReceive(int nErrorCode){
d708 2
d712 4
a715 1
bool CClientReqSocket::Create(){
d717 2
a718 1
	BOOL result = CAsyncSocket::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE);
d720 7
a726 1
	return result;
d729 40
d777 4
a780 1
CListenSocket::CListenSocket(CPreferences* in_prefs){
d786 4
d792 4
a795 1
CListenSocket::~CListenSocket(){
d798 2
d802 4
a805 1
bool CListenSocket::StartListening(){
d807 5
a811 1
	return (this->Create(app_prefs->GetPort(),SOCK_STREAM,FD_ACCEPT) && this->Listen());
d814 4
a817 1
void CListenSocket::ReStartListening(){
d823 2
d827 2
a828 1
void CListenSocket::StopListening(){
d833 3
a836 1
void CListenSocket::OnAccept(int nErrorCode){
d849 1
a849 1
	
d852 8
a859 8
			CClientReqSocket* newclient = new CClientReqSocket(app_prefs);
			if (!Accept(*newclient))
				newclient->Safe_Delete();
			else{
				newclient->AsyncSelect(FD_WRITE|FD_READ|FD_CLOSE);
				newclient->OnInit();
			}
			AddConnection();
d865 1
d868 4
a871 1
void CListenSocket::Process(){
d881 1
a881 1
		   if (cur_sock->m_hSocket != INVALID_SOCKET){
d893 2
d897 4
a900 1
void CListenSocket::RecalculateStats(){
d917 2
a918 1
   }
d921 4
a924 1
void CListenSocket::AddSocket(CClientReqSocket* toadd){
d926 2
d930 4
a933 1
void CListenSocket::RemoveSocket(CClientReqSocket* todel){
d939 3
a941 1
   }
d944 4
a947 1
void CListenSocket::KillAllSockets(){
d955 2
d959 2
a960 1
void CListenSocket::AddConnection(){
d965 5
a969 2
bool CListenSocket::TooManySockets(bool bIgnoreInterval){
	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > theApp.glob_prefs->GetMaxConperFive() && !bIgnoreInterval) ){
d971 4
a974 3
	}
	else
		return false;
d977 4
a980 1
bool CListenSocket::IsValidSocket(CClientReqSocket* totest){
d982 4
d988 4
a991 1
void CListenSocket::Debug_ClientDeleted(CUpDownClient* deleted){
d1003 2
d1006 113
@


1.3.2.2
log
@Merges from main thread
@
text
@d32 1
a32 4
CClientReqSocket::CClientReqSocket(CPreferences* in_prefs,CUpDownClient* in_client)
{
	EMULE_TRY

a40 2

	EMULE_CATCH
d44 1
a44 4
CClientReqSocket::~CClientReqSocket()
{
	EMULE_TRY

a50 2

	EMULE_CATCH
d53 1
a53 2
void CClientReqSocket::ResetTimeOutTimer()
{
d57 1
a57 4
bool CClientReqSocket::CheckTimeOut()
{
	EMULE_TRY

a62 3

	EMULE_CATCH

d66 1
a66 4
void CClientReqSocket::OnClose(int nErrorCode)
{
	EMULE_TRY

a69 2

	EMULE_CATCH
d72 1
a72 4
void CClientReqSocket::Disconnect()
{
	EMULE_TRY

a78 2

	EMULE_CATCH
d81 1
a81 3
void CClientReqSocket::Delete_Timed()
{
	EMULE_TRY
a85 2

	EMULE_CATCH
d88 1
a88 4
void CClientReqSocket::Safe_Delete()
{
	EMULE_TRY

a98 2

	EMULE_CATCH
d101 1
a101 4
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, uint8 opcode)
{
	EMULE_TRY

d120 9
a128 10
					client->ProcessHelloPacket(packet,size); 
					// now we check if we now this client already. if yes this socket will 
					// be attached to the known client, the new client will be deleted 
					// and the var. "client" will point to the known client. 
					// if not we keep our new-constructed client ;) 
					if (theApp.clientlist->AttachToAlreadyKnown(&client,this))
					{ 
						// update the old client informations 
						client->ProcessHelloPacket(packet,size); 
					} 
d130 1
a130 1
						theApp.clientlist->AddClient(client); 
d134 7
a140 6
					// send a response packet with standart informations 
					if (client->GetClientSoft() == SO_EMULE) 
						client->SendMuleInfoPacket(false); 
					client->SendHelloAnswer(); 
					if (client) 
						client->ConnectionEstablished(); 
d312 2
a313 2
				case OP_ASKSHAREDFILESANSWER: 
				{ 
d316 1
a316 1
					} 
a342 4

	EMULE_CATCH

	return false;
d345 1
a345 4
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, uint8 opcode)
{
	EMULE_TRY

a467 4

	EMULE_CATCH

	return false;
d475 1
a475 4
void CClientReqSocket::OnSend(int nErrorCode)
{
	EMULE_TRY

a477 2

	EMULE_CATCH
d480 1
a480 3
void CClientReqSocket::OnError(int nErrorCode)
{
	EMULE_TRY
a487 2

	EMULE_CATCH
d490 1
a490 4
void CClientReqSocket::PacketReceived(Packet* packet)
{
	EMULE_TRY

a504 2

	EMULE_CATCH
d507 1
a507 4
void CClientReqSocket::OnReceive(int nErrorCode)
{
	EMULE_TRY

a509 2

	EMULE_CATCH
d512 1
a512 4
bool CClientReqSocket::Create()
{
	EMULE_TRY

d527 1
a527 4
CListenSocket::CListenSocket(CPreferences* in_prefs)
{
	EMULE_TRY

a532 2

	EMULE_CATCH
d535 1
a535 4
CListenSocket::~CListenSocket()
{
	EMULE_TRY

a537 2

	EMULE_CATCH
d540 1
a540 4
bool CListenSocket::StartListening()
{
	EMULE_TRY

a542 4

	EMULE_CATCH

	return false;
d545 1
a545 4
void CListenSocket::ReStartListening()
{
	EMULE_TRY

a550 2

	EMULE_CATCH
d553 1
a553 2
void CListenSocket::StopListening()
{
a557 3
void CListenSocket::OnAccept(int nErrorCode)
{
	EMULE_TRY
d559 1
d572 1
a572 1

d575 8
a582 8
		CClientReqSocket* newclient = new CClientReqSocket(app_prefs);
		if (!Accept(*newclient))
			newclient->Safe_Delete();
		else{
			newclient->AsyncSelect(FD_WRITE|FD_READ|FD_CLOSE);
			newclient->OnInit();
		}
		AddConnection();
a587 1
	EMULE_CATCH
d590 1
a590 4
void CListenSocket::Process()
{
	EMULE_TRY

a611 2

   EMULE_CATCH
d614 1
a614 4
void CListenSocket::RecalculateStats()
{
	EMULE_TRY

d631 1
a631 2
	}
	EMULE_CATCH
d634 1
a634 4
void CListenSocket::AddSocket(CClientReqSocket* toadd)
{
	EMULE_TRY

a635 2

	EMULE_CATCH
d638 1
a638 4
void CListenSocket::RemoveSocket(CClientReqSocket* todel)
{
	EMULE_TRY

d644 1
a644 3
	}

	EMULE_CATCH
d647 1
a647 4
void CListenSocket::KillAllSockets()
{
	EMULE_TRY

a654 2

	EMULE_CATCH
d657 1
a657 2
void CListenSocket::AddConnection()
{
d662 2
a663 5
bool CListenSocket::TooManySockets(bool bIgnoreInterval)
{
	EMULE_TRY

	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > theApp.glob_prefs->GetMaxConperFive() && !bIgnoreInterval) )
d665 3
a667 4

	EMULE_CATCH

	return false;
d670 1
a670 4
bool CListenSocket::IsValidSocket(CClientReqSocket* totest)
{
	EMULE_TRY

a671 4

	EMULE_CATCH

	return false;
d674 1
a674 4
void CListenSocket::Debug_ClientDeleted(CUpDownClient* deleted)
{
	EMULE_TRY

a685 2

	EMULE_CATCH
a686 1

@


1.3.2.3
log
@Restored obaldin's version. NO MERGE on these files!!!!!!!
@
text
@d32 4
a35 1
CClientReqSocket::CClientReqSocket(CPreferences* in_prefs,CUpDownClient* in_client){
d44 2
d49 4
a52 1
CClientReqSocket::~CClientReqSocket(){
d59 2
d63 2
a64 1
void CClientReqSocket::ResetTimeOutTimer(){
d68 4
a71 1
bool CClientReqSocket::CheckTimeOut(){
d77 3
d83 4
a86 1
void CClientReqSocket::OnClose(int nErrorCode){
d90 2
d94 4
a97 1
void CClientReqSocket::Disconnect(){
d104 2
d108 3
a110 1
void CClientReqSocket::Delete_Timed(){
d115 2
d119 4
a122 1
void CClientReqSocket::Safe_Delete(){
d133 2
d137 4
a140 1
bool CClientReqSocket::ProcessPacket(char* packet, uint32 size, uint8 opcode){
d159 10
a168 9
					client->ProcessHelloPacket(packet,size);
					// now we check if we now this client already. if yes this socket will
					// be attached to the known client, the new client will be deleted
					// and the var. "client" will point to the known client.
					// if not we keep our new-constructed client ;)
					if (theApp.clientlist->AttachToAlreadyKnown(&client,this)){
						// update the old client informations
						client->ProcessHelloPacket(packet,size);
					}
d170 1
a170 1
						theApp.clientlist->AddClient(client);
d174 6
a179 7
					// send a response packet with standart informations
					if (client->GetClientSoft() == SO_EMULE)
						client->SendMuleInfoPacket(false);
					client->SendHelloAnswer();
					if (client)
						client->ConnectionEstablished();

d351 2
a352 2
				case OP_ASKSHAREDFILESANSWER:
				{	
d355 1
a355 1
				}
d382 4
d388 4
a391 1
bool CClientReqSocket::ProcessExtPacket(char* packet, uint32 size, uint8 opcode){
d514 4
d525 4
a528 1
void CClientReqSocket::OnSend(int nErrorCode){
d531 2
d535 3
a537 1
void CClientReqSocket::OnError(int nErrorCode){
d545 2
d549 4
a552 1
void CClientReqSocket::PacketReceived(Packet* packet){
d567 2
d571 4
a574 1
void CClientReqSocket::OnReceive(int nErrorCode){
d577 2
d581 4
a584 1
bool CClientReqSocket::Create(){
d599 4
a602 1
CListenSocket::CListenSocket(CPreferences* in_prefs){
d608 2
d612 4
a615 1
CListenSocket::~CListenSocket(){
d618 2
d622 4
a625 1
bool CListenSocket::StartListening(){
d628 4
d634 4
a637 1
void CListenSocket::ReStartListening(){
d643 2
d647 2
a648 1
void CListenSocket::StopListening(){
d653 3
a656 1
void CListenSocket::OnAccept(int nErrorCode){
d669 1
a669 1
	
d672 8
a679 8
			CClientReqSocket* newclient = new CClientReqSocket(app_prefs);
			if (!Accept(*newclient))
				newclient->Safe_Delete();
			else{
				newclient->AsyncSelect(FD_WRITE|FD_READ|FD_CLOSE);
				newclient->OnInit();
			}
			AddConnection();
d685 1
d688 4
a691 1
void CListenSocket::Process(){
d713 2
d717 4
a720 1
void CListenSocket::RecalculateStats(){
d737 2
a738 1
   }
d741 4
a744 1
void CListenSocket::AddSocket(CClientReqSocket* toadd){
d746 2
d750 4
a753 1
void CListenSocket::RemoveSocket(CClientReqSocket* todel){
d759 3
a761 1
   }
d764 4
a767 1
void CListenSocket::KillAllSockets(){
d775 2
d779 2
a780 1
void CListenSocket::AddConnection(){
d785 5
a789 2
bool CListenSocket::TooManySockets(bool bIgnoreInterval){
	if (GetOpenSockets() > app_prefs->GetMaxConnections() || (m_OpenSocketsInterval > theApp.glob_prefs->GetMaxConperFive() && !bIgnoreInterval) ){
d791 4
a794 3
	}
	else
		return false;
d797 4
a800 1
bool CListenSocket::IsValidSocket(CClientReqSocket* totest){
d802 4
d808 4
a811 1
void CListenSocket::Debug_ClientDeleted(CUpDownClient* deleted){
d823 2
d826 1
@


1.3.2.2.2.1
log
@Merged Proxy code
@
text
@d126 1
a126 1
	if (m_SocketData.hSocket != INVALID_SOCKET)  //Maverick
d586 1
a586 2
    // Maverick
	//BOOL result = CListenSocketBaseClass::Create();
d588 1
a588 7
	//return result;
    return TRUE;
    // end Maverick

	EMULE_CATCH

	return false;
a590 40
int CClientReqSocket::OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2)
{
	EMULE_TRY
	ASSERT(pLayer);
	if (nType==LAYERCALLBACK_STATECHANGE)
	{
	}
	else if (nType==LAYERCALLBACK_LAYERSPECIFIC)
	{
		if (pLayer==m_pProxyLayer)
		{
			switch (nParam1)
			{
			case PROXYERROR_NOCONN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_NOCONN));
				break;
			case PROXYERROR_REQUESTFAILED:
				//theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_REQUESTFAILED));
				m_ProxyConnectFailed = true;
				break;
			case PROXYERROR_AUTHTYPEUNKNOWN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHTYPEUNKNOWN));
				break;
			case PROXYERROR_AUTHFAILED:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHFAILED));
				break;
			case PROXYERROR_AUTHNOLOGON:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHNOLOGON));
				break;
			case PROXYERROR_CANTRESOLVEHOST:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_CANTRESOLVEHOST));
				break;
			default:
				theApp.emuledlg->AddLogLine(false,__FILE__, __LINE__, _T("Unknown proxy error") );
			}
		}
	}
	EMULE_CATCH
	return 1;
}
d701 1
a701 1
		   if (cur_sock->m_SocketData.hSocket != INVALID_SOCKET){
a825 112

//void CListenSocket::OpenProxyListenSocket(ULONG ip, UINT port, CServerSocket* sender)
void CListenSocket::OpenProxyListenSocket(ULONG ip, UINT port)
{
	if(!bProxyListening)
	{
		//m_ListenRequestSender = sender;
		bProxyListening = false;
		CEMSocketBaseClass::Close();
		ProxySettings settings = theApp.glob_prefs->GetProxy();
		if (settings.UseProxy && settings.type!=PROXYTYPE_NOPROXY)
		{
			m_pProxyLayer=new CAsyncProxySocketLayer;
			switch (settings.type)
			{
				case PROXYTYPE_SOCKS4:
					m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS4,settings.name,settings.port);
					break;
				case PROXYTYPE_SOCKS4A:
					m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS4A,settings.name,settings.port);
					break;
				case PROXYTYPE_SOCKS5:
					if (settings.EnablePassword)
						m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS5,settings.name, settings.port, settings.user, settings.password);
					else
						m_pProxyLayer->SetProxy(PROXYTYPE_SOCKS5,settings.name,settings.port);
					break;
				case PROXYTYPE_HTTP11:
					if (settings.EnablePassword)
						m_pProxyLayer->SetProxy(PROXYTYPE_HTTP11,settings.name,settings.port, settings.user, settings.password);
					else
						m_pProxyLayer->SetProxy(PROXYTYPE_HTTP11,settings.name,settings.port);
					break;
				default: ASSERT(FALSE);
			}
			m_pProxyLayer->PrepareListen(ip);
			AddLayer(m_pProxyLayer);
		}

		// Connection Initialisation
		bListening = true;
		Create();
		AsyncSelect(FD_ACCEPT);
		CEMSocketBaseClass::Listen();
		return;
	} else theApp.serverconnect->ListenPortEstablishedCallback();
}

int CListenSocket::OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2)
{
	EMULE_TRY
	ASSERT(pLayer);
	if (nType==LAYERCALLBACK_STATECHANGE)
	{
		CString logline;
		if (pLayer==m_pProxyLayer)
		{
			//logline.Format(_T("ProxyLayer changed state from %d to %d"), nParam2, nParam1);
			//theApp.emuledlg->AddLogLine(false,logline);
		}else
			//logline.Format(_T("Layer @@ %d changed state from %d to %d"), pLayer, nParam2, nParam1);
			//theApp.emuledlg->AddLogLine(false,logline);
		return 1;
	}
	else if (nType==LAYERCALLBACK_LAYERSPECIFIC)
	{
		CString logline;
		uint16 nPort;
		if (pLayer==m_pProxyLayer)
		{
			switch (nParam1)
			{
			case PROXYERROR_NOCONN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_NOCONN));
				break;
			case PROXYERROR_REQUESTFAILED:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_REQUESTFAILED));
				break;
			case PROXYERROR_AUTHTYPEUNKNOWN:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHTYPEUNKNOWN));
				break;
			case PROXYERROR_AUTHFAILED:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHFAILED));
				break;
			case PROXYERROR_AUTHNOLOGON:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_AUTHNOLOGON));
				break;
			case PROXYERROR_CANTRESOLVEHOST:
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERRORMSG_PROXY_CANTRESOLVEHOST));
				break;
			case PROXYSTATUS_LISTENSOCKETCREATED:
				t_ListenSocketCreatedStruct* data;
				data = (t_ListenSocketCreatedStruct*) nParam2;
				nPort = data->nPort;
				nPort = (nPort & 0xFF) * 0x100 + (nPort & 0xFF00) / 0x100;
				logline.Format(_T("Listenport on IP %lu Port %lu"),data->ip,nPort);
				theApp.glob_prefs->SetListenPort(nPort);
				theApp.emuledlg->AddLogLine(false,logline);
				//bProxyListening = true;
				//m_ListenRequestSender->ProxyListenPortEstablished();
				//theApp.serverconnect->ConnectionEstablished(m_ListenRequestSender);
				theApp.serverconnect->ListenPortEstablishedCallback();
				break;
			default:
				theApp.emuledlg->AddLogLine(false,__FILE__, __LINE__, _T("Unknown proxy error") );
			}
		}
	}
	EMULE_CATCH
	return 1;
}

@


1.2
log
@*** empty log message ***
@
text
@d143 2
d249 1
d267 1
d446 1
d456 1
a456 1
					;//theApp.emuledlg->AddLogLine(false,"unknown opcode: %i %h",opcode,opcode);
d466 1
a466 1
	catch(CString &error){
d471 1
a471 2
#ifdef _DEBUG
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_CLIENTERROR)
a472 1
#endif
d475 1
a475 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
d494 2
d525 1
d547 9
a555 7
				if (size != 16)
					throw GetResString(IDS_ERR_BADSIZE);

				// Added by Tarod -in case that we disabled source exchange we do not send
				// sources to anybody
				if (theApp.glob_prefs->IsDisabledXS())
					break;
d557 18
a574 18
				//first check shared file list, then download list
				CKnownFile* file = theApp.sharedfiles->GetFileByID((uchar*)packet);
				if (!file)
					file = theApp.downloadqueue->GetFileByID((uchar*)packet);

				if (file){
					DWORD dwTimePassed = ::GetTickCount() - client->GetLastSrcReqTime() + CONNECTION_LATENCY;
					bool bNeverAskedBefore = client->GetLastSrcReqTime() == 0;

					if( 
						//if not complete and file is rare, allow once every 10 minutes
					    	(file->IsPartFile() &&
						((CPartFile*)file)->GetSourceCount() <= RARE_FILE * 2 &&
						(bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK)) ||
						//OR if file is not rare or if file is complete, allow every 90 minutes,
						// but only if we haven't asked someone else in last 10 minutes
						((bNeverAskedBefore || dwTimePassed > SOURCECLIENTREASK * MINCOMMONPENALTY))) {

d577 6
a582 2
							if(tosend)
								SendPacket(tosend,true,true);
d621 1
d631 1
a631 1
				;//theApp.emuledlg->AddLogLine(false,"unknown opcode: %i %h",opcode,opcode);
d635 1
a635 1
	catch(CString &error){
d637 1
a637 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),error.GetBuffer());
a669 1
#ifdef _DEBUG
d671 1
a671 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_BADCLIENT2)
d674 1
a674 2
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_BADCLIENTACTION),"CClientReqSocket::OnError");			
#endif
d807 1
a807 1
	return (Create(app_prefs->GetPort(),SOCK_STREAM,FD_ACCEPT) && Listen());
d878 1
a878 1
			opensockets++;
@


1.1
log
@*** empty log message ***
@
text
@d126 1
a126 1
	if (m_hSocket != INVALID_SOCKET)
d511 2
d514 5
d520 5
d526 12
d706 2
a707 1
	BOOL result = CAsyncSocket::Create(0,SOCK_STREAM,FD_WRITE|FD_READ|FD_CLOSE);
d709 3
a711 1
	return result;
d717 47
d775 2
d870 1
a870 1
		   if (cur_sock->m_hSocket != INVALID_SOCKET){
d995 113
@

