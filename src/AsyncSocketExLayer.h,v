head	1.6;
access;
symbols
	PublicRelease_1_2e:1.6
	Interim_Release_1-2e_RC1:1.6
	PublicRelease_1_2d:1.6
	Interim_Release_1-2d_RC1:1.6
	Interim_Release_1-2d_beta1:1.6
	PublicRelease_1_2c:1.6
	Interim_Release_1-2c_RC1:1.6
	Interim_Release_1-2c_beta1:1.6
	PublicRelease_1_2b:1.6
	Interim_Release_1-2b_RC1:1.6
	PublicRelease_1_2a:1.6
	Interim_Release_1-2a_RC1:1.6
	Interim_Release_1-2a_beta2:1.6
	Interim_Release_1-2a_beta1:1.6
	PublicRelease_1_2:1.6
	Interim_Release_1-2_RC1:1.6
	Interim_Release_1-2_beta1:1.5
	PublicRelease_1_1g:1.5
	Interim_Release_1-1g_RC3:1.5
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	Interim_Release_1n_beta1:1.4
	PublicRelease_1m:1.4
	Interim_Release_1m_beta1:1.4
	PublicRelease_1l:1.4
	Interim_Release_1l_RC3:1.4
	Interim_Release_1l_RC2:1.4
	Interim_Release_1l_RC1:1.4
	Interim_Release_1l_beta2:1.4
	Interim_Release_1l_beta1:1.4
	PublicRelease_1k:1.4
	Interim_Release_1k_RC4:1.4
	Interim_1k_RC3:1.4
	Interim_1k_RC2:1.4
	Interim_Release_1k_RC1:1.4
	Interim_Release_1k_beta5:1.4
	Intrerim_Release_1k_beta4:1.4
	Interim_Release_1k_beta1:1.4
	PublicRelease_1j:1.4
	Interim_Release_1J_RC3:1.4
	Interim_Release_1j_RC3:1.4
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.4
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.4
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.14
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.12
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.10
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.8
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.1
	proxytest:1.1.2.1.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@ * @;


1.6
date	2006.02.15.05.25.53;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2005.12.11.00.09.54;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.12.22.39.04;	author dongato;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.30.10.20.52;	author dongato;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.22.16.32.29;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.15.36.57;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues.
@
text
@/*CAsyncSocketEx by Tim Kosse (Tim.Kosse@@gmx.de)
            Version 1.1 (2002-11-01)
--------------------------------------------------------

Introduction:
-------------

CAsyncSocketEx is a replacement for the MFC class CAsyncSocket.
This class was written because CAsyncSocket is not the fastest WinSock
wrapper and it's very hard to add new functionality to CAsyncSocket
derived classes. This class offers the same functionality as CAsyncSocket.
Also, CAsyncSocketEx offers some enhancements which were not possible with
CAsyncSocket without some tricks.

How do I use it?
----------------
Basically exactly like CAsyncSocket.
To use CAsyncSocketEx, just replace all occurrences of CAsyncSocket in your
code with CAsyncSocketEx, if you did not enhance CAsyncSocket yourself in
any way, you won't have to change anything else in your code.

Why is CAsyncSocketEx faster?
-----------------------------

CAsyncSocketEx is slightly faster when dispatching notification event messages.
First have a look at the way CAsyncSocket works. For each thread that uses
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with
the handle of that window. Until here, CAsyncSocketEx works the same way.
But CAsyncSocket uses only one window message (WM_SOCKET_NOTIFY) for all
sockets within one thread. When the window receive WM_SOCKET_NOTIFY, wParam
contains the socket handle and the window looks up an CAsyncSocket instance
using a map. CAsyncSocketEx works differently. It's helper window uses a
wide range of different window messages (WM_USER through 0xBFFF) and passes
a different message to WSAAsyncSelect for each socket. When a message in
the specified range is received, CAsyncSocketEx looks up the pointer to a
CAsyncSocketEx instance in an Array using the index of message - WM_USER.
As you can see, CAsyncSocketEx uses the helper window in a more efficient
way, as it don't have to use the slow maps to lookup it's own instance.
Still, speed increase is not very much, but it may be noticeable when using
a lot of sockets at the same time.
Please note that the changes do not affect the raw data throughput rate,
CAsyncSocketEx only dispatches the notification messages faster.

What else does CAsyncSocketEx offer?
------------------------------------

CAsyncSocketEx offers a flexible layer system. One example is the proxy layer.
Just create an instance of the proxy layer, configure it and add it to the layer
chain of your CAsyncSocketEx instance. After that, you can connect through
proxies.
Benefit: You don't have to change much to use the layer system.
Another layer that is currently in development is the SSL layer to establish
SSL encrypted connections.

License
-------

Feel free to use this class, as long as you don't claim that you wrote it
and this copyright notice stays intact in the source files.
If you use this class in commercial applications, please send a short message
to tim.kosse@@gmx.de

*/
#pragma once
#include "AsyncSocketEx.h"

class CAsyncSocketEx;
class CAsyncSocketExLayer
{
	friend CAsyncSocketEx;
	friend CAsyncSocketExHelperWindow;
protected:
	//Protected constructor so that CAsyncSocketExLayer can't be instantiated
	CAsyncSocketExLayer();
	virtual ~CAsyncSocketExLayer();

	//Notification event handlers
	virtual void OnAccept(int nErrorCode);
	virtual void OnClose(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
	virtual void OnReceive(int nErrorCode);
	virtual void OnSend(int nErrorCode);

	//Operations
	virtual BOOL Accept(CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual void Close();
	virtual BOOL Connect(LPCSTR lpszHostAddress, UINT nHostPort);
	virtual BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual BOOL Create(UINT nSocketPort = 0, int nSocketType = SOCK_STREAM,
				long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
				LPCSTR lpszSocketAddress = NULL);
	virtual BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
#ifdef _AFX
	virtual BOOL GetPeerName(CString& rPeerAddress, UINT& rPeerPort);
#endif
	virtual BOOL Listen(int nConnectionBacklog);
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);
	virtual BOOL ShutDown(int nHow = sends);
	enum { receives = 0, sends = 1, both = 2 };

	//Functions that will call next layer
	BOOL ShutDownNext(int nHow = sends);
	BOOL AcceptNext(CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	void CloseNext();
	BOOL ConnectNext(LPCSTR lpszHostAddress, UINT nHostPort);
	BOOL ConnectNext(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	BOOL CreateNext(UINT nSocketPort, int nSocketType, long lEvent, LPCSTR lpszSocketAddress);
#ifdef _AFX
		BOOL GetPeerNameNext(CString& rPeerAddress, UINT& rPeerPort);
#endif
	BOOL GetPeerNameNext(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
	BOOL ListenNext(int nConnectionBacklog);
	int ReceiveNext(void *lpBuf, int nBufLen, int nFlags = 0);
	int SendNext(const void *lpBuf, int nBufLen, int nFlags = 0);

	CAsyncSocketEx *m_pOwnerSocket;

	//Calls OnLayerCallback on owner socket
	int DoLayerCallback(int nType, int nCode, WPARAM wParam = 0, LPARAM lParam = 0);

	int GetLayerState();
	BOOL TriggerEvent(long lEvent, int nErrorCode, BOOL bPassThrough = FALSE);

	enum EnumLayerState
	{
		LAYERSTATE_NOTSOCK,
		LAYERSTATE_UNCONNECTED,
		LAYERSTATE_CONNECTING,
		LAYERSTATE_LISTENING,
		LAYERSTATE_CONNECTED,
		LAYERSTATE_CLOSED,
		LAYERSTATE_ABORTED
	};

private:
	//Layer state can't be set directly from derived classes
	void SetLayerState(int nLayerState);
	int m_nLayerState;

	//Called by helper window, dispatches event notification and updated layer state
	void CallEvent(int nEvent, int nErrorCode);

	int m_nCriticalError;

	void Init(CAsyncSocketExLayer *pPrevLayer, CAsyncSocketEx *pOwnerSocket);
	CAsyncSocketExLayer *AddLayer(CAsyncSocketExLayer *pLayer, CAsyncSocketEx *pOwnerSocket);

	CAsyncSocketExLayer *m_pNextLayer;
	CAsyncSocketExLayer *m_pPrevLayer;

	struct t_LayerNotifyMsg
	{
		CAsyncSocketExLayer *pLayer;
		long lEvent;
	};
};
@


1.5
log
@Removed non-English comments {brengarne}.
@
text
@d30 1
a30 1
sockets within one thread. When the window recieve WM_SOCKET_NOTIFY, wParam
d64 1
a64 3
#if !defined(AFX_ASYNCSOCKETEXLAYER_H__90C7FDB6_F3F1_4CC0_B77B_858458A563F3__INCLUDED_)
#define AFX_ASYNCSOCKETEXLAYER_H__90C7FDB6_F3F1_4CC0_B77B_858458A563F3__INCLUDED_

a65 3
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
d85 1
a85 1
	virtual BOOL Accept( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL );
d87 2
a88 2
	virtual BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	virtual BOOL Connect( const SOCKADDR* lpSockAddr, int nSockAddrLen );
d90 3
a92 4
				long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT |
							FD_CONNECT | FD_CLOSE,
				LPCTSTR lpszSocketAddress = NULL );
	virtual BOOL GetPeerName( SOCKADDR* lpSockAddr, int* lpSockAddrLen );
d94 1
a94 1
	virtual BOOL GetPeerName( CString& rPeerAddress, UINT& rPeerPort );
d96 1
a96 1
	virtual BOOL Listen( int nConnectionBacklog);
d99 1
a99 1
	virtual BOOL ShutDown( int nHow = sends );
d103 2
a104 2
	BOOL ShutDownNext( int nHow = sends );
	BOOL AcceptNext( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL );
d106 8
a113 8
	BOOL ConnectNext(LPCTSTR lpszHostAddress, UINT nHostPort);
	BOOL ConnectNext( const SOCKADDR* lpSockAddr, int nSockAddrLen );
	BOOL CreateNext(UINT nSocketPort, int nSocketType, long lEvent, LPCTSTR lpszSocketAddress);
	#ifdef _AFX
		BOOL GetPeerNameNext( CString& rPeerAddress, UINT& rPeerPort );
	#endif
	BOOL GetPeerNameNext( SOCKADDR* lpSockAddr, int* lpSockAddrLen );
	BOOL ListenNext( int nConnectionBacklog);
d120 1
a120 1
	int DoLayerCallback(int nType, int nParam1, int nParam2);
d123 1
a123 1
	BOOL TriggerEvent(long lEvent, int nErrorCode, BOOL bPassThrough = FALSE );
d134 1
a134 1
	} ;
a157 2

#endif // !defined(AFX_ASYNCSOCKETEXLAYER_H__90C7FDB6_F3F1_4CC0_B77B_858458A563F3__INCLUDED_)
@


1.4
log
@Katsyonak update
@
text
@d67 1
a67 1
#include "AsyncSocketEx.h"	// Hinzugefügt von der Klassenansicht
@


1.3
log
@Official code merge (katsyonak)
@
text
@d8 3
a10 3
CAsyncSocketEx is a replacement for the MFC class CAsyncSocket. 
This class was written because CAsyncSocket is not the fastest WinSock 
wrapper and it's very hard to add new functionality to CAsyncSocket 
d27 1
a27 1
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with 
d34 1
a34 1
a different message to WSAAsyncSelect for each socket. When a message in 
d37 1
a37 1
As you can see, CAsyncSocketEx uses the helper window in a more efficient 
d41 1
a41 1
Please note that the changes do not affect the raw data throughput rate, 
d73 1
a73 1
class CAsyncSocketExLayer  
d88 1
a88 1
	
d96 1
a96 1
							FD_CONNECT | FD_CLOSE, 
d107 1
a107 1
	
d130 1
a130 1
	
d141 1
a141 1
	
d151 1
a151 1
	
@


1.2
log
@Formatting, comments, and name changes.
@
text
@d63 2
a64 1
*/#if !defined(AFX_ASYNCSOCKETEXLAYER_H__90C7FDB6_F3F1_4CC0_B77B_858458A563F3__INCLUDED_)
a100 1
	virtual BOOL GetPeerName( ULONG& rPeerIP, UINT& rPeerPort );
d105 2
d109 1
a116 1
		BOOL GetPeerNameNext( ULONG& rPeerIP, UINT& rPeerPort );
@


1.1
log
@Maverick's proxy support
@
text
@d129 1
a129 1
	enum LayerState
d131 7
a137 7
		notsock,
		unconnected,
		connecting,
		listening,
		connected,
		closed,
		aborted
@


1.1.2.1
log
@updating this branch...
@
text
@@

