head	1.246;
access;
symbols
	PublicRelease_1_2e:1.241
	Interim_Release_1-2e_RC1:1.241
	PublicRelease_1_2d:1.235
	Interim_Release_1-2d_RC1:1.234
	Interim_Release_1-2d_beta1:1.232
	PublicRelease_1_2c:1.222
	Interim_Release_1-2c_RC1:1.222
	Interim_Release_1-2c_beta1:1.216
	PublicRelease_1_2b:1.214
	Interim_Release_1-2b_RC1:1.214
	PublicRelease_1_2a:1.210
	Interim_Release_1-2a_RC1:1.208
	Interim_Release_1-2a_beta2:1.200
	Interim_Release_1-2a_beta1:1.195
	PublicRelease_1_2:1.194
	Interim_Release_1-2_RC1:1.194
	Interim_Release_1-2_beta1:1.192
	PublicRelease_1_1g:1.191
	Interim_Release_1-1g_RC3:1.191
	Interim_Release_1-1g_RC2:1.191
	Interim_Release_1-1g_RC1:1.191
	Interim_Release_1-1g_beta2:1.187
	Interim_Release_1-1g_beta1:1.183
	PublicRelease_1_1f:1.179
	Interim_Release_1-1f_RC1:1.179
	PublicRelease_1_1e:1.178
	Interim_Release_1-1e_RC2:1.178
	Interim_Release_1-1e_RC1:1.177
	Interim_Release_1-1e_beta1:1.177
	PublicRelease_1_1d:1.174
	Interim_Release_1-1d_RC1:1.174
	PublicRelease_1_1c:1.167
	Interim_Release_1-1c_RC1:1.166
	Interim_Release_1-1c_beta2:1.164
	Interim_Release_1-1c_beta1:1.157
	PublicRelease_1_1b:1.154
	Interim_Release_1-1b_RC1:1.154
	PublicRelease_1_1a:1.154
	Interim_Release_1-1a_RC2:1.154
	Interim_Release_1-1a_RC1:1.152
	Interim_Release_1-1a_beta2:1.152
	Interim_Release_1-1a_beta1:1.149
	PublicRelease_1_1:1.148
	Interim_Release_1-1_beta1:1.147
	PublicRelease_1o:1.145
	Interim_Release_1o_RC1:1.145
	Interim_Release_1o_beta1:1.145
	PublicRelease_1n:1.144
	Interim_Release_1n_RC2:1.144
	Interim_Release_1n_RC1:1.144
	Interim_Release_1n_beta2:1.136
	Interim_Release_1n_beta1:1.134
	PublicRelease_1m:1.132
	Interim_Release_1m_beta1:1.132
	PublicRelease_1l:1.132
	Interim_Release_1l_RC3:1.132
	Interim_Release_1l_RC2:1.132
	Interim_Release_1l_RC1:1.132
	Interim_Release_1l_beta2:1.131
	Interim_Release_1l_beta1:1.125
	PublicRelease_1k:1.123
	Interim_Release_1k_RC4:1.123
	Interim_1k_RC3:1.123
	Interim_1k_RC2:1.122
	Interim_Release_1k_RC1:1.121
	Interim_Release_1k_beta5:1.115
	Intrerim_Release_1k_beta4:1.114
	Interim_Release_1k_beta1:1.109
	PublicRelease_1j:1.99
	Interim_Release_1J_RC3:1.99
	Interim_Release_1j_RC3:1.99
	Interim_Release_1j_RC2:1.98
	Interim_Release_1j_RC1:1.97
	Interim_Release_1j_beta2:1.94
	Interim_Release_1j_beta1:1.92
	PublicRelease_1i:1.89
	Interim_Release_1i_RC6:1.89
	Interim_Release_1i_RC3:1.86
	Interim_Release_1i_RC2:1.86
	Interim_Release_1i_RC1:1.84
	Interim_Release_1i_beta3:1.84
	Interim_Release_1i_beta2:1.81
	Interim_Release_1i_beta1:1.68
	PublicRelease_1h:1.60
	Interim_Release_1h_rc2:1.60
	Interim_Release_1h_RC1:1.60
	Interim_Release_1h_beta2:1.60
	Interim_Release_1h_beta1_now:1.58
	Interim_Release_1h_beta1:1.58
	PublicRelease_1g:1.54
	Interim_Release_1g_RC6_Final:1.54
	Interim_Release_1g_RC6:1.54
	Interim_Release_1g_RC5:1.54
	Interim_Release_1g_RC4:1.54
	Interim_Release_1g_RC3:1.54
	Interim_Release_1g_beta2:1.45
	Interim_Release_1g_beta1:1.38
	Interim_Release_1f_RC4:1.33
	Interim_Release_1f_RC3:1.33
	Interim_Release_1f_RC2:1.29
	Interim_Release_1f_RC:1.29
	Interim_Release_1f_beta2:1.29
	Interim_Release_1f_beta1:1.28
	PublicRelease_1e:1.26
	Interim_Release_1e_RC2:1.26
	Interim_Release_1e_RC:1.26
	Interim_Release_1e_beta3:1.26
	Interim_Release_1e_beta2:1.26
	Interim_Release_1e_beta2_before_kuchin:1.26
	Interim_Release_1e_beta1:1.26
	PublicRelease_1c:1.23
	featurestest:1.23.0.2
	Interim_Release_1c_RC:1.23
	Interim_Release_1c_beta2:1.23
	Interim_Release_1c_beta1:1.15
	threaded_downloadqueue:1.14.0.2
	PublicRelease_1b:1.12
	Interim_Release_1b_beta2:1.10
	Interim_Release_1b_beta1:1.8
	proxydeadlake:1.6.0.4
	PublicRelease_1a:1.6
	Interim_Release_1a_beta2:1.6
	BerkeleyDb:1.6.0.2
	Interim_Release_1a_beta1:1.6
	PublicRelease_1:1.6
	goldfish:1.6
	eMulePlus_1_RC2:1.5
	eMulePlus_26b_1RC1:1.5
	PreRelease_26b_i0e:1.5
	before_26d_merge:1.4
	Interim_Release_26b_i0d:1.3
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.3.0.4
	plus26based:1.3.0.2
	Interim_Release_25b_i0b:1.3
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.246
date	2009.10.29.03.36.33;	author aw3;	state Exp;
branches;
next	1.245;

1.245
date	2009.10.28.04.34.58;	author aw3;	state Exp;
branches;
next	1.244;

1.244
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.243;

1.243
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.242;

1.242
date	2009.04.26.03.15.59;	author aw3;	state Exp;
branches;
next	1.241;

1.241
date	2009.02.15.21.10.35;	author aw3;	state Exp;
branches;
next	1.240;

1.240
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.239;

1.239
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.238;

1.238
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.237;

1.237
date	2008.10.20.22.26.28;	author kush_eplus;	state Exp;
branches;
next	1.236;

1.236
date	2008.10.04.03.52.17;	author aw3;	state Exp;
branches;
next	1.235;

1.235
date	2008.04.22.03.24.20;	author aw3;	state Exp;
branches;
next	1.234;

1.234
date	2008.03.15.04.15.04;	author aw3;	state Exp;
branches;
next	1.233;

1.233
date	2008.03.03.05.16.03;	author aw3;	state Exp;
branches;
next	1.232;

1.232
date	2008.01.14.01.18.50;	author aw3;	state Exp;
branches;
next	1.231;

1.231
date	2008.01.02.05.30.52;	author aw3;	state Exp;
branches;
next	1.230;

1.230
date	2008.01.01.11.12.05;	author eklmn;	state Exp;
branches;
next	1.229;

1.229
date	2007.12.31.05.58.48;	author aw3;	state Exp;
branches;
next	1.228;

1.228
date	2007.12.16.21.38.00;	author aw3;	state Exp;
branches;
next	1.227;

1.227
date	2007.12.05.22.01.38;	author eklmn;	state Exp;
branches;
next	1.226;

1.226
date	2007.12.01.10.38.06;	author eklmn;	state Exp;
branches;
next	1.225;

1.225
date	2007.11.12.23.51.27;	author fuxie-dk;	state Exp;
branches;
next	1.224;

1.224
date	2007.10.24.19.09.35;	author fuxie-dk;	state Exp;
branches;
next	1.223;

1.223
date	2007.10.18.14.48.33;	author fuxie-dk;	state Exp;
branches;
next	1.222;

1.222
date	2007.08.08.01.55.57;	author aw3;	state Exp;
branches;
next	1.221;

1.221
date	2007.07.25.03.02.59;	author aw3;	state Exp;
branches;
next	1.220;

1.220
date	2007.07.23.03.47.57;	author aw3;	state Exp;
branches;
next	1.219;

1.219
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.218;

1.218
date	2007.06.01.04.49.26;	author aw3;	state Exp;
branches;
next	1.217;

1.217
date	2007.05.28.02.07.14;	author aw3;	state Exp;
branches;
next	1.216;

1.216
date	2007.02.15.02.15.04;	author aw3;	state Exp;
branches;
next	1.215;

1.215
date	2007.02.14.14.21.02;	author aw3;	state Exp;
branches;
next	1.214;

1.214
date	2007.01.17.07.40.13;	author aw3;	state Exp;
branches;
next	1.213;

1.213
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.212;

1.212
date	2006.11.16.05.43.23;	author aw3;	state Exp;
branches;
next	1.211;

1.211
date	2006.11.13.16.55.07;	author eklmn;	state Exp;
branches;
next	1.210;

1.210
date	2006.10.11.04.16.40;	author aw3;	state Exp;
branches;
next	1.209;

1.209
date	2006.10.03.02.30.30;	author aw3;	state Exp;
branches;
next	1.208;

1.208
date	2006.09.12.04.29.43;	author aw3;	state Exp;
branches;
next	1.207;

1.207
date	2006.09.04.18.25.29;	author aw3;	state Exp;
branches;
next	1.206;

1.206
date	2006.09.02.03.19.14;	author aw3;	state Exp;
branches;
next	1.205;

1.205
date	2006.08.21.03.47.45;	author aw3;	state Exp;
branches;
next	1.204;

1.204
date	2006.08.10.03.08.47;	author aw3;	state Exp;
branches;
next	1.203;

1.203
date	2006.07.24.12.54.50;	author aw3;	state Exp;
branches;
next	1.202;

1.202
date	2006.07.17.01.28.57;	author aw3;	state Exp;
branches;
next	1.201;

1.201
date	2006.07.04.04.42.47;	author aw3;	state Exp;
branches;
next	1.200;

1.200
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.199;

1.199
date	2006.05.18.03.50.46;	author aw3;	state Exp;
branches;
next	1.198;

1.198
date	2006.05.17.03.51.31;	author aw3;	state Exp;
branches;
next	1.197;

1.197
date	2006.05.13.04.49.28;	author aw3;	state Exp;
branches;
next	1.196;

1.196
date	2006.05.03.03.57.20;	author aw3;	state Exp;
branches;
next	1.195;

1.195
date	2006.04.22.21.58.08;	author aw3;	state Exp;
branches;
next	1.194;

1.194
date	2006.02.20.05.40.01;	author aw3;	state Exp;
branches;
next	1.193;

1.193
date	2006.02.06.01.18.09;	author aw3;	state Exp;
branches;
next	1.192;

1.192
date	2006.01.03.04.39.03;	author aw3;	state Exp;
branches;
next	1.191;

1.191
date	2005.11.30.05.09.33;	author aw3;	state Exp;
branches;
next	1.190;

1.190
date	2005.11.30.03.13.32;	author aw3;	state Exp;
branches;
next	1.189;

1.189
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.188;

1.188
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.187;

1.187
date	2005.09.26.00.29.07;	author aw3;	state Exp;
branches;
next	1.186;

1.186
date	2005.09.23.18.19.07;	author eklmn;	state Exp;
branches;
next	1.185;

1.185
date	2005.09.13.05.59.18;	author aw3;	state Exp;
branches;
next	1.184;

1.184
date	2005.08.28.08.28.56;	author eklmn;	state Exp;
branches;
next	1.183;

1.183
date	2005.08.21.23.05.20;	author aw3;	state Exp;
branches;
next	1.182;

1.182
date	2005.08.20.08.42.01;	author eklmn;	state Exp;
branches;
next	1.181;

1.181
date	2005.08.18.19.08.22;	author eklmn;	state Exp;
branches;
next	1.180;

1.180
date	2005.08.06.18.01.14;	author aw3;	state Exp;
branches;
next	1.179;

1.179
date	2005.07.15.04.48.11;	author aw3;	state Exp;
branches;
next	1.178;

1.178
date	2005.07.05.02.57.23;	author aw3;	state Exp;
branches;
next	1.177;

1.177
date	2005.06.06.04.37.46;	author aw3;	state Exp;
branches;
next	1.176;

1.176
date	2005.05.09.02.29.04;	author aw3;	state Exp;
branches;
next	1.175;

1.175
date	2005.03.26.04.32.57;	author aw3;	state Exp;
branches;
next	1.174;

1.174
date	2005.03.15.03.23.18;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2005.03.14.18.29.38;	author eklmn;	state Exp;
branches;
next	1.172;

1.172
date	2005.03.10.07.59.48;	author katsyonak;	state Exp;
branches;
next	1.171;

1.171
date	2005.03.07.03.27.43;	author aw3;	state Exp;
branches;
next	1.170;

1.170
date	2005.03.06.13.59.32;	author aw3;	state Exp;
branches;
next	1.169;

1.169
date	2005.03.03.21.39.28;	author eklmn;	state Exp;
branches;
next	1.168;

1.168
date	2005.03.03.20.38.36;	author eklmn;	state Exp;
branches;
next	1.167;

1.167
date	2005.02.25.04.39.37;	author aw3;	state Exp;
branches;
next	1.166;

1.166
date	2005.02.24.04.20.49;	author aw3;	state Exp;
branches;
next	1.165;

1.165
date	2005.02.17.20.06.47;	author aw3;	state Exp;
branches;
next	1.164;

1.164
date	2005.02.16.04.59.46;	author aw3;	state Exp;
branches;
next	1.163;

1.163
date	2005.02.14.22.46.36;	author aw3;	state Exp;
branches;
next	1.162;

1.162
date	2005.02.12.00.54.28;	author aw3;	state Exp;
branches;
next	1.161;

1.161
date	2005.02.04.21.27.01;	author aw3;	state Exp;
branches;
next	1.160;

1.160
date	2005.02.03.19.48.07;	author kuchin;	state Exp;
branches;
next	1.159;

1.159
date	2005.02.03.16.12.39;	author kuchin;	state Exp;
branches;
next	1.158;

1.158
date	2005.02.01.03.58.05;	author aw3;	state Exp;
branches;
next	1.157;

1.157
date	2005.01.23.13.58.01;	author aw3;	state Exp;
branches;
next	1.156;

1.156
date	2005.01.14.14.50.14;	author kush_eplus;	state Exp;
branches;
next	1.155;

1.155
date	2005.01.07.22.28.55;	author netwolf1;	state Exp;
branches;
next	1.154;

1.154
date	2004.12.03.20.59.18;	author aw3;	state Exp;
branches;
next	1.153;

1.153
date	2004.11.29.05.49.41;	author aw3;	state Exp;
branches;
next	1.152;

1.152
date	2004.11.20.07.16.07;	author eklmn;	state Exp;
branches;
next	1.151;

1.151
date	2004.11.14.23.35.32;	author aw3;	state Exp;
branches;
next	1.150;

1.150
date	2004.11.11.16.44.19;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2004.11.08.02.13.36;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2004.10.20.17.07.51;	author aw3;	state Exp;
branches;
next	1.147;

1.147
date	2004.10.05.15.40.33;	author aw3;	state Exp;
branches;
next	1.146;

1.146
date	2004.10.04.23.34.31;	author kush_eplus;	state Exp;
branches;
next	1.145;

1.145
date	2004.09.17.00.06.29;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2004.08.27.17.17.09;	author eklmn;	state Exp;
branches;
next	1.143;

1.143
date	2004.08.27.15.41.02;	author dongato;	state Exp;
branches;
next	1.142;

1.142
date	2004.08.27.15.07.28;	author eklmn;	state Exp;
branches;
next	1.141;

1.141
date	2004.08.27.05.47.13;	author aw3;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.20.07.37.26;	author eklmn;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.20.03.49.02;	author aw3;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.136;

1.136
date	2004.08.07.08.51.53;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.13.04.03.27;	author aw3;	state Exp;
branches;
next	1.133;

1.133
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.132;

1.132
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.131;

1.131
date	2004.05.21.15.50.01;	author dongato;	state Exp;
branches;
next	1.130;

1.130
date	2004.05.19.16.03.22;	author netwolf1;	state Exp;
branches;
next	1.129;

1.129
date	2004.05.19.10.14.28;	author netwolf1;	state Exp;
branches;
next	1.128;

1.128
date	2004.05.18.21.37.38;	author kush_eplus;	state Exp;
branches;
next	1.127;

1.127
date	2004.05.17.15.58.57;	author kush_eplus;	state Exp;
branches;
next	1.126;

1.126
date	2004.05.12.23.27.27;	author kush_eplus;	state Exp;
branches;
next	1.125;

1.125
date	2004.05.04.09.45.35;	author netwolf1;	state Exp;
branches;
next	1.124;

1.124
date	2004.05.01.05.37.21;	author aw3;	state Exp;
branches;
next	1.123;

1.123
date	2004.04.05.11.03.52;	author bavariansnail;	state Exp;
branches;
next	1.122;

1.122
date	2004.03.31.08.05.09;	author eklmn;	state Exp;
branches;
next	1.121;

1.121
date	2004.03.27.07.09.39;	author eklmn;	state Exp;
branches;
next	1.120;

1.120
date	2004.03.25.14.26.27;	author eklmn;	state Exp;
branches;
next	1.119;

1.119
date	2004.03.24.23.11.36;	author eklmn;	state Exp;
branches;
next	1.118;

1.118
date	2004.03.24.21.44.42;	author dongato;	state Exp;
branches;
next	1.117;

1.117
date	2004.03.24.16.34.23;	author eklmn;	state Exp;
branches;
next	1.116;

1.116
date	2004.03.23.16.20.52;	author eklmn;	state Exp;
branches;
next	1.115;

1.115
date	2004.03.22.22.36.12;	author eklmn;	state Exp;
branches;
next	1.114;

1.114
date	2004.03.22.18.45.17;	author eklmn;	state Exp;
branches;
next	1.113;

1.113
date	2004.03.12.06.13.23;	author aw3;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.09.05.25.20;	author aw3;	state Exp;
branches;
next	1.111;

1.111
date	2004.03.06.07.11.32;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2004.02.27.01.25.09;	author kush_eplus;	state Exp;
branches;
next	1.109;

1.109
date	2004.02.20.02.29.53;	author kush_eplus;	state Exp;
branches;
next	1.108;

1.108
date	2004.02.18.13.48.45;	author kush_eplus;	state Exp;
branches;
next	1.107;

1.107
date	2004.02.17.22.02.51;	author aw3;	state Exp;
branches;
next	1.106;

1.106
date	2004.02.16.23.24.56;	author aw3;	state Exp;
branches;
next	1.105;

1.105
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.104;

1.104
date	2004.02.13.16.13.34;	author netwolf1;	state Exp;
branches;
next	1.103;

1.103
date	2004.02.12.10.38.01;	author morevit;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.11.04.13.00;	author katsyonak;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.07.00.50.45;	author netwolf1;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.06.02.54.09;	author kush_eplus;	state Exp;
branches;
next	1.99;

1.99
date	2004.01.21.23.20.46;	author dongato;	state Exp;
branches;
next	1.98;

1.98
date	2004.01.11.11.46.01;	author katsyonak;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.10.13.44.22;	author dongato;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.10.11.37.47;	author dongato;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.10.00.07.49;	author dongato;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.05.23.17.17;	author dongato;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.05.21.38.36;	author dongato;	state Exp;
branches;
next	1.92;

1.92
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.91;

1.91
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.89;

1.89
date	2003.11.30.20.29.33;	author eklmn;	state Exp;
branches;
next	1.88;

1.88
date	2003.11.22.13.11.18;	author eklmn;	state Exp;
branches;
next	1.87;

1.87
date	2003.11.21.20.24.58;	author eklmn;	state Exp;
branches;
next	1.86;

1.86
date	2003.11.16.14.55.05;	author syrus77;	state Exp;
branches;
next	1.85;

1.85
date	2003.11.09.09.41.51;	author kuchin;	state Exp;
branches;
next	1.84;

1.84
date	2003.10.29.22.01.18;	author double_t;	state Exp;
branches;
next	1.83;

1.83
date	2003.10.28.12.07.55;	author katsyonak;	state Exp;
branches;
next	1.82;

1.82
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.81;

1.81
date	2003.10.20.13.19.59;	author morevit;	state Exp;
branches;
next	1.80;

1.80
date	2003.10.17.23.23.28;	author eklmn;	state Exp;
branches;
next	1.79;

1.79
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.15.14.15.34;	author morevit;	state Exp;
branches;
next	1.77;

1.77
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.76;

1.76
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.75;

1.75
date	2003.10.09.11.54.23;	author morevit;	state Exp;
branches;
next	1.74;

1.74
date	2003.10.09.09.25.17;	author morevit;	state Exp;
branches;
next	1.73;

1.73
date	2003.10.08.20.25.49;	author dongato;	state Exp;
branches;
next	1.72;

1.72
date	2003.10.08.15.43.05;	author eklmn;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.08.15.39.48;	author morevit;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.08.12.56.33;	author morevit;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.30.11.33.33;	author morevit;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.29.21.42.03;	author dongato;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.29.21.12.36;	author dongato;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.24.10.42.53;	author morevit;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.22.16.44.17;	author morevit;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.21.22.05.16;	author morevit;	state Exp;
branches;
next	1.62;

1.62
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.59;

1.59
date	2003.08.30.11.23.25;	author emoulari;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.17.23.06.26;	author zegzav;	state Exp;
branches;
next	1.57;

1.57
date	2003.08.04.21.24.38;	author zegzav;	state Exp;
branches;
next	1.56;

1.56
date	2003.07.29.13.16.52;	author bond006;	state Exp;
branches;
next	1.55;

1.55
date	2003.07.26.11.27.01;	author zegzav;	state Exp;
branches;
next	1.54;

1.54
date	2003.06.28.08.30.17;	author partyckip;	state Exp;
branches;
next	1.53;

1.53
date	2003.06.21.17.52.33;	author partyckip;	state Exp;
branches;
next	1.52;

1.52
date	2003.06.17.16.35.03;	author netwolf1;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.17.13.54.02;	author netwolf1;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.16.15.37.42;	author netwolf1;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.15.09.09.28;	author partyckip;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.12.22.25.46;	author syrus77;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.11.18.27.09;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.10.09.36.45;	author kuchin;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.06.19.56.46;	author partyckip;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.05.19.57.15;	author partyckip;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.05.06.03.25;	author partyckip;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.05.01.22.30;	author netwolf1;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.04.22.35.47;	author netwolf1;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.04.20.27.27;	author partyckip;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.31.08.50.54;	author partyckip;	state Exp;
branches;
next	1.37;

1.37
date	2003.05.30.21.26.58;	author partyckip;	state Exp;
branches;
next	1.36;

1.36
date	2003.05.29.04.45.17;	author partyckip;	state Exp;
branches;
next	1.35;

1.35
date	2003.05.27.23.03.06;	author partyckip;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.27.04.15.26;	author partyckip;	state Exp;
branches;
next	1.33;

1.33
date	2003.05.22.14.18.28;	author netwolf1;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.22.13.12.23;	author obaldin;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.20.20.46.27;	author netwolf1;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.20.16.30.40;	author netwolf1;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.08.21.02.35;	author syrus77;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.04.14.13.24;	author kuchin;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.04.10.05.33;	author kuchin;	state Exp;
branches;
next	1.26;

1.26
date	2003.04.11.21.58.03;	author obaldin;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.28.15.23.40;	author partyckip;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.27.11.04.32;	author recdvst;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.21.02.25.10;	author recdvst;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.03.21.00.30.29;	author cax2;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.20.20.20.44;	author lord_kiron;	state Exp;
branches;
next	1.20;

1.20
date	2003.03.20.20.19.48;	author lord_kiron;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.20.17.12.23;	author lord_kiron;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.18.12.59.34;	author lord_kiron;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.17.20.27.50;	author lord_kiron;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.15.19.41.52;	author lord_kiron;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.15.00.54.08;	author cax2;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.14.16.24.18;	author partyckip;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.12.17.33.15;	author obaldin;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.09.16.21.45;	author obaldin;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.09.09.55.53;	author obaldin;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.07.12.50.41;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.05.21.16.36;	author obaldin;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.03.22.09.46;	author moosetea;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.01.19.30.10;	author lord_kiron;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.20.14.29.01;	author dongato;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.02.17.09.15.14;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.02.10.47.20;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.25.18.10.10;	author kuchin;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.19;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.13;	author cax2;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.01.30.23.23.48;	author obaldin;	state Exp;
branches;
next	;

1.6.2.1
date	2003.03.01.20.59.35;	author obaldin;	state Exp;
branches;
next	;

1.23.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.246
log
@Fixed part traffic data collection for blocks requested in non-standard way (some eMule Mods request bigger blocks without following standard block boundaries -- part traffic could collect correct block transfer data for them);
Removed disabled code collecting part traffinc data for multiple chunk transfers, as implementation was wrong anyway.
@
text
@// parts of this file are based on work from pan One (http://home-3.tiscali.nl/~meost/pms/)
//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "updownclient.h"
#include "KnownFile.h"
#include "server.h"
#include "opcodes.h"
#include <io.h>
#include <sys/stat.h>
#ifndef NEW_SOCKETS_ENGINE
	#include "emule.h"
#endif //NEW_SOCKETS_ENGINE
#include "ini2.h"
#include "QArray.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#ifndef NEW_SOCKETS_ENGINE
	#include "Jumpstarter.h"
#endif //NEW_SOCKETS_ENGINE
#include "UploadQueue.h"
#include "otherstructs.h"
#include "packets.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

static const uint16 s_auSearchResID[ED2KFT_COUNT] =
{
	IDS_SEARCH_ANY,		// ED2KFT_ANY
	IDS_SEARCH_AUDIO,	// ED2KFT_AUDIO
	IDS_SEARCH_VIDEO,	// ED2KFT_VIDEO
	IDS_SEARCH_PICS,	// ED2KFT_IMAGE
	IDS_SEARCH_PRG,		// ED2KFT_PROGRAM
	IDS_SEARCH_DOC,		// ED2KFT_DOCUMENT
	IDS_SEARCH_ARC,		// ED2KFT_ARCHIVE
	IDS_SEARCH_CDIMG	// ED2KFT_CDIMAGE
};

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CAbstractFile::~CAbstractFile()
{
	for (int i = 0; i < m_tagArray.GetSize(); i++)
		safe_delete(m_tagArray[i]);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CAbstractFile::CreateED2kLink() const
{
	TCHAR	acHashStr[MAX_HASHSTR_SIZE];
	CString	strFName(g_App.StripInvalidFilenameChars(GetFileName(), false));	// spaces to dots
	CString	strLink;

	strLink.Format( _T("ed2k://|file|%s|%I64u|%s|/"),
#ifndef NEW_SOCKETS_ENGINE
		g_App.m_pPrefs->GetExportLocalizedLinks() ? strFName : Ed2kURIEncode(strFName),
#else
		GetFileName(),
#endif //NEW_SOCKETS_ENGINE
		GetFileSize(), md4str(GetFileHash(), acHashStr) );

	return strLink;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CAbstractFile::CreateED2kSourceLink() const
{
	CString		strLink = CreateED2kLink();
#ifdef OLD_SOCKETS_ENABLED

	if (g_App.m_pServerConnect->IsConnected() && !g_App.m_pServerConnect->IsLowID())
	{
		uint32			dwID = g_App.m_pServerConnect->GetClientID();

		strLink.AppendFormat( _T("|sources,%u.%u.%u.%u:%u|/"),
								static_cast<BYTE>(dwID),
								static_cast<BYTE>(dwID>>8),
								static_cast<BYTE>(dwID>>16),
								static_cast<BYTE>(dwID>>24),
								g_App.m_pPrefs->GetListenPort() );
	}
#endif //OLD_SOCKETS_ENABLED

	return strLink;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CAbstractFile::CreateHTMLED2kLink() const
{
	CString		strLink;

	strLink.Format(_T("<a href=\"%s\">%s</a>"), CreateED2kLink(),
#ifndef NEW_SOCKETS_ENGINE
		g_App.StripInvalidFilenameChars(GetFileName(), true) 
#else
		GetFileName()
#endif //NEW_SOCKETS_ENGINE
		);
	return strLink;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFileStatistic::CFileStatistic()
{
	partTraffic = NULL;
	partTrafficSession = NULL;

	blockTraffic = NULL;
	blockTrafficSession = NULL;

	partAccepted = NULL;
	partAcceptedSession = NULL;

	completeReleases = 0.0;
	m_iNumRequested = m_iNumAccepted = 0;
	m_dwAllTimeRequested = m_dwAllTimeAccepted = 0;
	m_qwNumTransferred = m_qwAllTimeTransferred = 0;
	fileParent = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFileStatistic::~CFileStatistic()
{
	EMULE_TRY

	if (partTraffic)			delete[] partTraffic;			partTraffic=NULL;
	if (partTrafficSession)		delete[] partTrafficSession;	partTrafficSession=NULL;

	if (partAccepted)			delete[] partAccepted;			partAccepted=NULL;
	if (partAcceptedSession)	delete[] partAcceptedSession;	partAcceptedSession=NULL;

	if (blockTraffic)			delete[] blockTraffic;			blockTraffic=NULL;
	if (blockTrafficSession)	delete[] blockTrafficSession;	blockTrafficSession=NULL;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::AddRequest()
{
	EMULE_TRY

	m_iNumRequested++;
	m_dwAllTimeRequested++;
#ifndef NEW_SOCKETS_ENGINE
	g_App.m_pKnownFilesList->m_iNumRequested++;
	if (::IsWindow(g_App.m_pMDlg->m_wndSharedFiles.m_hWnd))	//fix crash at exit [TwoBottle Mod]
	{
		fileParent->UpdateSharedFileDisplay();
	}
#endif //NEW_SOCKETS_ENGINE
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::AddAccepted()
{
	EMULE_TRY

	m_iNumAccepted++;
	m_dwAllTimeAccepted++;
#ifndef NEW_SOCKETS_ENGINE
	g_App.m_pKnownFilesList->m_iNumAccepted++;
#endif //NEW_SOCKETS_ENGINE
	fileParent->UpdateSharedFileDisplay();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::AddTransferred(uint32 dwBytes)
{
	EMULE_TRY

	m_qwNumTransferred += dwBytes;
	m_qwAllTimeTransferred += dwBytes;
#ifndef NEW_SOCKETS_ENGINE
	g_App.m_pKnownFilesList->m_qwNumTransferred += dwBytes;
#endif //NEW_SOCKETS_ENGINE
	fileParent->UpdateSharedFileDisplay();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CKnownFile::CKnownFile() : m_strComment(_T(""))
{
	m_timetLastWriteDate = 0;
	m_bytePriority = PR_NORMAL;

#ifndef NEW_SOCKETS_ENGINE
	m_bAutoPriority = g_App.m_pPrefs->IsUAPEnabled();
#endif //NEW_SOCKETS_ENGINE

	m_bytePermissions = g_App.m_pPrefs->GetFilePermission();
	statistic.fileParent = this;
	m_bCommentLoaded = false;
	m_byteMoviePreviewMode = 0;
	m_eRating = PF_RATING_NONE;
	m_nCompleteSourcesCount = 0;
	m_nCompleteSourcesCountLo = 0;
	m_nCompleteSourcesCountHi = 0;
	m_nCompleteSourcesTime = 0;

	m_sharedFile = false;
	md4clr(m_fileHash);

	m_Jumpstarter = NULL;
	m_pPartsHashSet = NULL;
	m_dblSizeRatio = 1.0;
	m_bIsCompressedTransferAllowed = true;
	m_bPublishedED2K = false;

	::InitializeCriticalSection(&m_csSourceList);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CKnownFile::~CKnownFile()
{
	EMULE_TRY

	CSingleLock Lock(&m_csHashList, TRUE);
	delete[] m_pPartsHashSet;
	Lock.Unlock();

#ifndef NEW_SOCKETS_ENGINE
	delete m_Jumpstarter;
#endif //NEW_SOCKETS_ENGINE

	::DeleteCriticalSection(&m_csSourceList);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::CalculateCompleteSources()
{
	EMULE_TRY

	uint32	dwCurTick;

#ifndef NEW_SOCKETS_ENGINE
	if ( (!IsPartFile() || IsPaused()) &&
		(((dwCurTick = ::GetTickCount()) - m_nCompleteSourcesTime) >= 2*60*1000) )	// 2 min.
	{
		CQArray<uint16,uint16> count;
		CTypedPtrList<CPtrList, CUpDownClient*> clientuploadlist;
		m_nCompleteSourcesCount= m_nCompleteSourcesCountLo= m_nCompleteSourcesCountHi= 0;
		g_App.m_pClientList->GetClientListByFileID(&clientuploadlist, GetFileHash());
		count.SetSize(0, clientuploadlist.GetSize());
		for (POSITION pos= clientuploadlist.GetHeadPosition(); pos != NULL; )
		{
			CUpDownClient *cur_src= clientuploadlist.GetNext(pos);
			uint16 cur_count= cur_src->GetUpCompleteSourcesCount();
			if ((cur_count) && ((dwCurTick - cur_src->GetUpCompleteSourcesTime()) < 30*60*1000))	// 30 min.
				count.Add(cur_count);
		}

		uint32 n= count.GetSize();
		if (n > 0)
		{
			count.QuickSort();

		//	Calculate range
			uint32 i= n >> 1;		// (n / 2)
			uint32 j= (n * 3) >> 2;	// (n * 3) / 4
			uint32 k= (n * 7) >> 3;	// (n * 7) / 8
			if (n < 5)
			{
				m_nCompleteSourcesCount= count.GetAt(i);
				m_nCompleteSourcesCountLo= 0;
				m_nCompleteSourcesCountHi= m_nCompleteSourcesCount;
			}
			else if (n < 10)
			{
				m_nCompleteSourcesCount= count.GetAt(i);
				m_nCompleteSourcesCountLo= count.GetAt(i - 1);
				m_nCompleteSourcesCountHi= count.GetAt(i + 1);
			}
			else if (n < 20)
			{
				m_nCompleteSourcesCount= count.GetAt(i);
				m_nCompleteSourcesCountLo= count.GetAt(i);
				m_nCompleteSourcesCountHi= count.GetAt(j);
			}
			else
			{
				m_nCompleteSourcesCount= count.GetAt(j);
				m_nCompleteSourcesCountLo= m_nCompleteSourcesCount;
				m_nCompleteSourcesCountHi= count.GetAt(k);
			}
		}

		m_nCompleteSourcesTime = dwCurTick;
	}

	UpdateUploadAutoPriority();
	UpdateSharedFileDisplay();
#endif //NEW_SOCKETS_ENGINE
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::UpdateSharedFileDisplay()
{
#ifndef NEW_SOCKETS_ENGINE
	if (g_App.m_pMDlg->m_wndSharedFiles.m_ctlSharedFilesList.m_hWnd != NULL)
	{
		g_App.m_pMDlg->m_wndSharedFiles.m_ctlSharedFilesList.PostMessage( WM_SFL_UPDATEITEM,
																				static_cast<WPARAM>(g_App.m_pMDlg->m_wndSharedFiles.IsWindowVisible()),
																				reinterpret_cast<LPARAM>(this) );
	}
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::SetFileSize(uint64 qwFileSize)
{
	CAbstractFile::SetFileSize(qwFileSize);

	// Examples of parthashs, hashsets and filehashs for different filesizes
	// according the ed2k protocol
	//----------------------------------------------------------------------
	//
	//File size: 3 bytes
	//File hash: 2D55E87D0E21F49B9AD25F98531F3724
	//Nr.hashes: 0
	//
	//
	//File size: 1*PARTSIZE
	//File hash: A72CA8DF7F07154E217C236C89C17619
	//Nr.hashes: 2
	//Hash[  0]: 4891ED2E5C9C49F442145A3A5F608299
	//Hash[  1]: 31D6CFE0D16AE931B73C59D7E0C089C0	*special part hash*
	//
	//
	//File size: 1*PARTSIZE + 1 byte
	//File hash: 2F620AE9D462CBB6A59FE8401D2B3D23
	//Nr.hashes: 2
	//Hash[  0]: 121795F0BEDE02DDC7C5426D0995F53F
	//Hash[  1]: C329E527945B8FE75B3C5E8826755747
	//
	//
	//File size: 2*PARTSIZE
	//File hash: A54C5E562D5E03CA7D77961EB9A745A4
	//Nr.hashes: 3
	//Hash[  0]: B3F5CE2A06BF403BFB9BFFF68BDDC4D9
	//Hash[  1]: 509AA30C9EA8FC136B1159DF2F35B8A9
	//Hash[  2]: 31D6CFE0D16AE931B73C59D7E0C089C0	*special part hash*
	//
	//
	//File size: 3*PARTSIZE
	//File hash: 5E249B96F9A46A18FC2489B005BF2667
	//Nr.hashes: 4
	//Hash[  0]: 5319896A2ECAD43BF17E2E3575278E72
	//Hash[  1]: D86EF157D5E49C5ED502EDC15BB5F82B
	//Hash[  2]: 10F2D5B1FCB95C0840519C58D708480F
	//Hash[  3]: 31D6CFE0D16AE931B73C59D7E0C089C0	*special part hash*
	//
	//
	//File size: 3*PARTSIZE + 1 byte
	//File hash: 797ED552F34380CAFF8C958207E40355
	//Nr.hashes: 4
	//Hash[  0]: FC7FD02CCD6987DCF1421F4C0AF94FB8
	//Hash[  1]: 2FE466AF8A7C06DA3365317B75A5ACFE
	//Hash[  2]: 873D3BF52629F7C1527C6E8E473C1C30
	//Hash[  3]: BCE50BEE7877BB07BB6FDA56BFE142FB
	//

	//   File size       Data parts      ED2K parts      ED2K part hashes
	// ---------------------------------------------------------------
	// 1..PARTSIZE-1     1               1                       0(!)
	// PARTSIZE            1               2(!)                   2(!)
	// PARTSIZE+1        2               2                       2
	// PARTSIZE*2        2               3(!)                   3(!)
	// PARTSIZE*2+1    3               3                       3

	if (qwFileSize == 0)
	{
		m_uPartCount = 0;
		m_dwED2KPartCount = 0;
		m_dwED2KPartHashCount = 0;
		m_dwBlockCount = 0;
		m_dwLastPartSz = 0;
		m_dwLastBlkSz = 0;
		return;
	}

	m_dwLastPartSz = static_cast<uint32>(qwFileSize % PARTSIZE);
	m_dwED2KPartHashCount = static_cast<uint32>(qwFileSize / PARTSIZE);
	m_uPartCount = static_cast<uint16>(m_dwED2KPartHashCount + ((m_dwLastPartSz != 0) ? 1 : 0));
	m_dwLastPartSz = (m_dwLastPartSz != 0) ? m_dwLastPartSz : PARTSZ32;

	m_dwED2KPartCount = m_dwED2KPartHashCount + 1;

	if (m_dwED2KPartHashCount != 0)
		m_dwED2KPartHashCount++;

//	Block traffic
	m_dwLastBlkSz = static_cast<uint32>(qwFileSize % EMBLOCKSIZE);
	m_dwBlockCount = static_cast<uint32>(qwFileSize / EMBLOCKSIZE) + ((m_dwLastBlkSz != 0) ? 1 : 0);
	m_dwLastBlkSz = (m_dwLastBlkSz != 0) ? m_dwLastBlkSz : EMBLOCKSZ32;

//	Calculate size ration (=SmallFilePushRatio)
	if (m_uPartCount < 2u)
	{
		m_dblSizeRatio = PARTSZ32 / static_cast<double>(static_cast<uint32>(qwFileSize));
		if (m_dblSizeRatio > 100.0)
			m_dblSizeRatio = 100.0;
	}

//	Intialize array with required status: all parts shared
//	Size must be m_dwED2KPartCount as WritePartStatus sends also status of "void" chunk when filesize % PARTSIZE = 0
	m_PartsStatusVector.resize(m_dwED2KPartCount, 0x00);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::SetFileName(const CString& NewName, bool bClearName)
{
//	Set the name & extension
	CAbstractFile::SetFileName(NewName, bClearName);
//	Update full file name
	if (!IsPartFile())	// don't update for part file as the name should point at xxx.part
	{
		if (m_strKnownFileDirectory.IsEmpty())	// don't create full name for non-existent known file
			m_strFilePath.Empty();
		else
			m_strFilePath.Format(_T("%s\\%s"), m_strKnownFileDirectory, m_strFileName);	//SetFilePath()
	}

//	Don't try to compress already compressed files
	m_bIsCompressedTransferAllowed = ((GetFileType() != ED2KFT_ARCHIVE) || (m_strFileExtension == _T("tar")));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::CreateFromFile(const CString &strDir, const CString &strFileName, bool bPartFile)
{
	EMULE_TRY

//	First create the filehashset

//	Try to open the specified file
	CFile					file;
	CArray<uchar*,uchar*>	partHashArray;
	uchar					fileHash[16];
	CString					strNameBuffer;

	SetPath(strDir);
	strNameBuffer.Format(_T("%s\\%s"), strDir, strFileName);
	SetFilePath(strNameBuffer);

//	If we failed to open the specified file, return false
	if ( !file.Open(strNameBuffer, CFile::modeRead | CFile::shareDenyNone |
		CFile::typeBinary | CFile::osSequentialScan) )
		return false;

	ULONGLONG qwFileSz = file.GetLength();

	if (qwFileSz > MAX_EMULE_FILE_SIZE)
	{
		file.Close();
		return false;
	}

	AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("File %s is being hashed"), (bPartFile) ? strNameBuffer : strFileName);

	//set member variables
	SetFileSize(qwFileSz);
	SetFileName(strFileName, false);
//	after filesize(m_lFileSize) was defined we can get number of hashes
	const uint32 dwHashCount = GetED2KPartHashCount();

//	Create hashset
	if (dwHashCount > 1)
	{
		//	allocate memory for hash array
		partHashArray.SetSize(dwHashCount);
		//	allocate memory for hashset
		uchar*	pPartsHashSet = new uchar[16*dwHashCount];

		for (uint32 i = 0; i < dwHashCount; i++)
		{
		//	get hash over global pointer
			uchar* pNewPartHash = pPartsHashSet + 16*i;

		//	Create a hash for the next part
			if (i == (dwHashCount - 1))
				CreateHashFromFile(&file, static_cast<uint32>(GetFileSize() - static_cast<uint64>(i) * PARTSIZE), pNewPartHash);
			else
				CreateHashFromFile(&file, PARTSZ32, pNewPartHash);
#ifndef NEW_SOCKETS_ENGINE
			if (!g_App.m_pMDlg->IsRunning())	// in case of shutdown while still hashing
			{
				file.Close();
				delete[] pPartsHashSet;
				return false;
			}
#endif //NEW_SOCKETS_ENGINE
			partHashArray.SetAt(i, pNewPartHash);
		}
		CreateHashFromString(pPartsHashSet, dwHashCount*16, fileHash);

		//copy(add) data from local to global
		CSingleLock Lock(&m_csHashList, TRUE);
		m_pPartsHashSet = pPartsHashSet;
		m_partHashArray.SetSize(dwHashCount);
		for (uint32 i = 0; i < dwHashCount; i++)
			m_partHashArray.SetAt(i, partHashArray[i]);

		md4cpy(m_fileHash, fileHash);
		Lock.Unlock();
	}
	else if (dwHashCount == 0)
	{
	//	Hash creation was split into 2 steps, because fuction CreateHashFromFile()
	//	takes some time to finish hashing. Therefore to prevent possible interference
	//	we create a local instance of file hash & then copy it into global one
		CreateHashFromFile(&file, static_cast<uint32>(GetFileSize()), fileHash);
		md4cpy(m_fileHash, fileHash);
	}

	file.Close();

//	Set last write time
	GetAdjustedFileTime(strNameBuffer, &m_timetLastWriteDate);

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	LoadHashsetFromFile() loads the KnownFile with a hashset from the file 'file' in the format of "known.met".
//		If 'bCheckHash' is true, the file hash in 'file' must match a file hash calculated from the part hashes
//		'file'. false is returned on failure, true on success.
bool CKnownFile::LoadHashsetFromFile(CFile &file, bool bCheckHash)
{
//	Needed for memfiles. It's probably better to switch everything to CFile...
	EMULE_TRY

	uchar					FileHash[16];
	uchar* 					pPartsHashSet = NULL;
	CArray<uchar*,uchar*>	partHashArray;
	uint16					uNumParts;

//	Read the file hash if required, or just skip it if we need just check a hash
	if (!bCheckHash)
		file.Read(&m_fileHash,16);			// <HASH> file hash
	else
		file.Seek(16, CFile::current);

//	Read the number of parts
	file.Read(&uNumParts,2);		// <count:WORD> number of parts

	INT_PTR		iParts = static_cast<uint16>(uNumParts);

	if (iParts < 0)		//Cax2 - why? MOREVIT - Yes, really. Why?? Not used elsewhere.
	{
		if (!m_strFileName.IsEmpty())
		{
		//	TODO: Add some way to tell if the file is really "known.met" or a memfile.
			AddLogLine(LOG_FL_DBG, _T("Loaded hashset size is corrupt in known.met, file: %s!"), m_strFileName);
		}
		else
			AddLogLine(LOG_FL_DBG, _T("Loaded hashset size is corrupt in known.met!"));
	}

	//load hash array in to local buffer
	if (uNumParts == 0)
	{
		if (!bCheckHash)
			return true;	// load was successfully
		else
			return false;	// any check for hash set is impossible
	}
	else		// need to load hashset
	{
	//	If the number of hashes doesn't match the number of hashes the file should have...
		if (bCheckHash && static_cast<uint32>(uNumParts) != GetED2KPartHashCount())
		{
		//	move a pointer to the begin of the file tags
			file.Seek(uNumParts*16, CFile::current);
			return false;
		}

	//	allocate memory for hash array
		partHashArray.SetSize(uNumParts);
	//	allocate memory for hashset
		pPartsHashSet = new uchar[16*uNumParts];

	//	Read the part hashes.
		for (int i = 0; i < static_cast<int>(uNumParts); i++)
		{
			//	get hash over global pointer
			uchar*	pPartHash = pPartsHashSet + 16*i;

			file.Read(pPartHash, 16);		// <HASH>[count] part hashes
			partHashArray.SetAt(i, pPartHash);
		}

	//	recreate a file hash from hash set
		CreateHashFromString(pPartsHashSet, uNumParts*16, FileHash);

	//	If the file hash from 'file' matches the calculated hash...
		if (md4cmp(m_fileHash,FileHash) == 0)
		{
			//lock access to global variables & change them
			CSingleLock Lock(&m_csHashList, TRUE);
			//check if hash set was allready loaded & delete previous one
			delete[] m_pPartsHashSet;
			m_pPartsHashSet = pPartsHashSet;
			m_partHashArray.SetSize(uNumParts);
			for (uint32 i = 0; i < static_cast<int>(uNumParts); i++)
			{
				m_partHashArray.SetAt(i, partHashArray[i]);
			}
			Lock.Unlock();
			return true;
		}
		else
		{
			delete[] pPartsHashSet;
			partHashArray.RemoveAll();
			return false;
		}
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	LoadTagsFromFile() parses what tags we know and stores the rest in 'm_tagArray' so they can be rewritten.
bool CKnownFile::LoadTagsFromFile(CFile &file)
{
	EMULE_TRY

	uint32		dwNumTags;

	file.Read(&dwNumTags, 4);							// {<TAGCOUNT:DWORD>

	for (uint32 j = 0; j < dwNumTags; j++)
	{
		CTag		*newtag = new CTag();

		newtag->FillFromStream(file);
		switch (newtag->GetTagID())
		{
			case FT_FILENAME:							// (FT_FILENAME:string) file name
				if (newtag->IsStr())
				{
#ifdef _UNICODE
					if (IsFileNameEmpty())
#endif
						SetFileName(newtag->GetStringValue());
				}
				break;

			case FT_FILESIZE:							// (FT_FILESIZE:int) file size (bytes)
				if (newtag->IsAnyInt())
					SetFileSize(newtag->GetInt64Value());
				break;

			case FT_ATTRANSFERRED:						// (FT_ATTRANSFERRED:int) all time transferred (low long)
				if (newtag->IsInt())
					statistic.m_qwAllTimeTransferred = (statistic.m_qwAllTimeTransferred & (0xFFFFFFFFi64 << 32)) | newtag->GetIntValue();
				break;

			case FT_ATTRANSFERREDHI:					// (FT_ATTRANSFERREDHI:int) all time transferred (high long)
				if (newtag->IsInt())
					statistic.m_qwAllTimeTransferred = (statistic.m_qwAllTimeTransferred & 0xFFFFFFFF) |
						(static_cast<uint64>(newtag->GetIntValue()) << 32);
				break;

			case FT_ATREQUESTED:						// (FT_ATREQUESTED:int) all time requested
				if (newtag->IsInt())
					statistic.m_dwAllTimeRequested = newtag->GetIntValue();
				break;

			case FT_ATACCEPTED:							// (FT_ATACCEPTED:int) all time accepted
				if (newtag->IsInt())
					statistic.m_dwAllTimeAccepted = newtag->GetIntValue();
				break;

			case FT_ULPRIORITY:							// (FT_ULPRIORITY:int) upload priority
				if (newtag->IsInt())
				{
					m_bytePriority = static_cast<byte>(newtag->GetIntValue());
					if (m_bytePriority == PR_AUTO)
					{
						SetAutoULPriority(true);
						SetULPriority(PR_RELEASE);
					}
					else
					{
						SetAutoULPriority(false);
						if ( (m_bytePriority != PR_VERYLOW) && (m_bytePriority != PR_LOW) &&
							(m_bytePriority != PR_NORMAL) && (m_bytePriority != PR_HIGH) && (m_bytePriority != PR_RELEASE) )
						{
							m_bytePriority = PR_NORMAL;
						}
					}
				}
				break;

			case FT_PERMISSIONS:						// (FT_PERMISSIONS:int) upload permissions
				if (newtag->IsInt() && (newtag->GetIntValue() <= PERM_NOONE))
					m_bytePermissions = static_cast<byte>(newtag->GetIntValue());
				break;

			case FT_PARTFILENAME:	//	This tag is used to keep part file name, delete it as file's already complete
				break;

			default:
				m_tagArray.Add(newtag);
				continue;
		}
		delete newtag;
	}
	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::LoadDateFromFile(CFile& file)
{
	EMULE_TRY

	file.Read(&m_timetLastWriteDate,4);
	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::LoadFromFile(CFile& file)
{
	EMULE_TRY

	bool		result, hashset_ok;

	result = LoadDateFromFile(file);				// <DATE:time_t> last write date/time
	hashset_ok = LoadHashsetFromFile(file,false);	// (HASHSET)
	result = result && LoadTagsFromFile(file);		// <Tag_set>
	result = result && hashset_ok && (GetED2KPartHashCount() == static_cast<uint32>(m_partHashArray.GetCount()));

//	Cax2 - if m_strFileName==NULL, don't report it, it should still be ok...
#ifndef NEW_SOCKETS_ENGINE
	if(!hashset_ok && !m_strFileName.IsEmpty())
		AddLogLine(LOG_RGB_WARNING, IDS_ERR_KNOWNHASHCORR, m_strFileName);
#endif //NEW_SOCKETS_ENGINE

#ifndef NEW_SOCKETS_ENGINE
	if (result && CJumpstarter::ShouldBeEnabledForFile(this))
	{
		m_Jumpstarter = new CJumpstarter(this);
		AddLogLine(0, IDS_JS_ENABLED, m_strFileName);
	}
#endif //NEW_SOCKETS_ENGINE

	return result;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::WriteToFile(CFile &file)
{
	byte		abyteBuf[22];
	CSingleLock	Lock(&m_csHashList, TRUE);
	CWrTag		tagWr;

	uint32	dwNumParts = m_partHashArray.GetCount();

	if ((dwNumParts != 0) && (m_pPartsHashSet == NULL))
		dwNumParts = 0;

	POKE_DWORD(&abyteBuf[0], m_timetLastWriteDate);				// <DATE:time_t> last write date/time
	md4cpy(&abyteBuf[4], m_fileHash);							// <HASH>
	POKE_WORD(&abyteBuf[20], static_cast<uint16>(dwNumParts));	// <count:WORD> number of chunk hashes

	file.Write(abyteBuf, sizeof(abyteBuf));
	if (m_pPartsHashSet != NULL)
		file.Write(m_pPartsHashSet, 16 * dwNumParts);			// <HASH>[count] part hashes

	Lock.Unlock();

//	Tags
	uint32	dwTagFilePos = static_cast<uint32>(file.GetPosition());
	uint32	dwTmp, dwTagCnt = 0;

	file.Write(&dwTagCnt, 4);									// <TAGCOUNT:DWORD>

	if (IsUTF8Required(GetFileName()))
	{
		tagWr.WriteToFile(FT_FILENAME, GetFileName(), file, cfUTF8withBOM);		// (FT_FILENAME:string) file name
		dwTagCnt++;
	}
	tagWr.WriteToFile(FT_FILENAME, GetFileName(), file);		// (FT_FILENAME:string) file name
	dwTagCnt++;
	tagWr.WriteToFile(FT_FILESIZE, GetFileSize(), file, IsLargeFile());
	dwTagCnt++;
	if (statistic.GetAllTimeTransferred() != 0)
	{
		tagWr.WriteToFile(FT_ATTRANSFERRED, static_cast<uint32>(statistic.GetAllTimeTransferred()), file);
		if ((dwTmp = static_cast<uint32>(statistic.GetAllTimeTransferred() >> 32)) != 0)
		{
			tagWr.WriteToFile(FT_ATTRANSFERREDHI, dwTmp, file);
			dwTagCnt++;
		}
		dwTagCnt++;
	}
	if (statistic.GetAllTimeRequests() != 0)
	{
		tagWr.WriteToFile(FT_ATREQUESTED, statistic.GetAllTimeRequests(), file);
		dwTagCnt++;
	}
	if (statistic.GetAllTimeAccepts() != 0)
	{
		tagWr.WriteToFile(FT_ATACCEPTED, statistic.GetAllTimeAccepts(), file);
		dwTagCnt++;
	}
	tagWr.WriteToFile(FT_ULPRIORITY, IsULAutoPrioritized() ? PR_AUTO : m_bytePriority, file);
	dwTagCnt++;
	tagWr.WriteToFile(FT_PERMISSIONS, m_bytePermissions, file);
	dwTagCnt++;

//	Unknown tags
	for (int j = 0; j < m_tagArray.GetCount(); j++)
	{
		if (m_tagArray[j]->IsStr() || m_tagArray[j]->IsInt())
		{
			m_tagArray[j]->WriteToFile(file);
			dwTagCnt++;
		}
	}
//	Save valid tag count
	file.Seek(dwTagFilePos, CFile::begin);
	file.Write(&dwTagCnt, 4);
	file.SeekToEnd();

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CreateHashFromInput() generates a hash from the next 'dwLength' bytes of 'file' or 'pbyteMem'
//		The hash is returned in '*pbyteHash'.
void CKnownFile::CreateHashFromInput(CFile *file, uint32 dwLength, uchar *pbyteHash, uchar *pbyteMem)
{
	uint32 *pdwHash = reinterpret_cast<uint32*>(pbyteHash);

	pdwHash[0] = 0x67452301;
	pdwHash[1] = 0xEFCDAB89;
	pdwHash[2] = 0x98BADCFE;
	pdwHash[3] = 0x10325476;

	uint32		dwRequired = dwLength;
	uchar		pbyteBuff[1024];	//	should be small enough to eliminate stack size check

	if (pbyteMem != NULL)
	{
	//	Process memory block
		while (dwRequired >= 64)
		{
			MD4Transform(pdwHash, reinterpret_cast<uint32*>(pbyteMem));
			pbyteMem += 64;
			dwRequired -= 64;
		}
	//	Copy the rest
		if (dwRequired != 0)
			memcpy2(pbyteBuff, pbyteMem, dwRequired);
	}
	else
	{
	//	Process a file
		uint32		dwBlockSz = 16 * 4096;
		void		*pAlloc = malloc(dwBlockSz);
		uchar		*pbytePtr = reinterpret_cast<uchar*>(pAlloc);

		if (pbytePtr == NULL)
		{
		//	Use small local buffer in case of low memory
			pbytePtr = pbyteBuff;
			dwBlockSz = sizeof(pbyteBuff);
		}

		while (dwRequired >= dwBlockSz)
		{
			file->Read(pbytePtr, dwBlockSz);
			uint32 i = 0;
			do
			{
				MD4Transform(pdwHash, (uint32*)(pbytePtr + i));
				i += 64;
			} while(i < dwBlockSz);
			dwRequired -= dwBlockSz;
		}
		if (dwRequired >= 64)
		{
			uint32 dwLen = dwRequired & ~63;

			file->Read(pbytePtr, dwLen);
			uint32 i = 0;
			do
			{
				MD4Transform(pdwHash, reinterpret_cast<uint32*>(pbytePtr + i));
				i += 64;
			} while(i < dwLen);
			dwRequired -= dwLen;
		}
	//	Read the rest
		if (dwRequired != 0)
			file->Read(pbyteBuff, dwRequired);
		if (pAlloc != NULL)
			free(pAlloc);
	}
	// in byte scale 512 = 64, 448 = 56
	pbyteBuff[dwRequired++] = 0x80;
	if (dwRequired > 56)
	{
		memzero(&pbyteBuff[dwRequired], 64 - dwRequired);
		MD4Transform(pdwHash, reinterpret_cast<uint32*>(pbyteBuff));
		dwRequired = 0;
	}
	memzero(&pbyteBuff[dwRequired], 56 - dwRequired);
// Add size (convert to bits)
	*reinterpret_cast<uint32*>(&pbyteBuff[56]) = (dwLength << 3);
	*reinterpret_cast<uint32*>(&pbyteBuff[60]) = (dwLength >> 29);

	MD4Transform(pdwHash, reinterpret_cast<uint32*>(pbyteBuff));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const uchar* CKnownFile::GetPartHash(uint32 dwPart) const
{
	EMULE_TRY
	if (dwPart >= static_cast<uint32>(m_partHashArray.GetCount()))
		return NULL;

	return m_partHashArray[dwPart];

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
double CKnownFile::GetPopularityRatio()
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	if (g_App.m_pKnownFilesList->GetTotalRequested()==0)
		return 1.0;
	if (statistic.GetRequests() == 0)
		return 2.0;

	double		dblRatio;

	dblRatio = (static_cast<double>(statistic.GetRequests())) / (static_cast<double>(g_App.m_pKnownFilesList->GetTotalRequested()));
	dblRatio = -4.0 * log10(static_cast<double>(g_App.m_pSharedFilesList->GetCount())) * dblRatio;
	dblRatio = 2.0 * exp(dblRatio);

	if (dblRatio < 1.0)
	{
		dblRatio = 1.0;
	}
	else if (dblRatio > 2.0)
	{
		dblRatio = 2.0;
	}

	return dblRatio;
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH

	return 1.0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void __fastcall MD4Transform(uint32 Hash[4], uint32 x[16])
{
	uint32 a = Hash[0];
	uint32 b = Hash[1];
	uint32 c = Hash[2];
	uint32 d = Hash[3];

	/* Round 1 */
	MD4_FF(a, b, c, d, x[ 0], S11); // 01
	MD4_FF(d, a, b, c, x[ 1], S12); // 02
	MD4_FF(c, d, a, b, x[ 2], S13); // 03
	MD4_FF(b, c, d, a, x[ 3], S14); // 04
	MD4_FF(a, b, c, d, x[ 4], S11); // 05
	MD4_FF(d, a, b, c, x[ 5], S12); // 06
	MD4_FF(c, d, a, b, x[ 6], S13); // 07
	MD4_FF(b, c, d, a, x[ 7], S14); // 08
	MD4_FF(a, b, c, d, x[ 8], S11); // 09
	MD4_FF(d, a, b, c, x[ 9], S12); // 10
	MD4_FF(c, d, a, b, x[10], S13); // 11
	MD4_FF(b, c, d, a, x[11], S14); // 12
	MD4_FF(a, b, c, d, x[12], S11); // 13
	MD4_FF(d, a, b, c, x[13], S12); // 14
	MD4_FF(c, d, a, b, x[14], S13); // 15
	MD4_FF(b, c, d, a, x[15], S14); // 16

	/* Round 2 */
	MD4_GG(a, b, c, d, x[ 0], S21); // 17
	MD4_GG(d, a, b, c, x[ 4], S22); // 18
	MD4_GG(c, d, a, b, x[ 8], S23); // 19
	MD4_GG(b, c, d, a, x[12], S24); // 20
	MD4_GG(a, b, c, d, x[ 1], S21); // 21
	MD4_GG(d, a, b, c, x[ 5], S22); // 22
	MD4_GG(c, d, a, b, x[ 9], S23); // 23
	MD4_GG(b, c, d, a, x[13], S24); // 24
	MD4_GG(a, b, c, d, x[ 2], S21); // 25
	MD4_GG(d, a, b, c, x[ 6], S22); // 26
	MD4_GG(c, d, a, b, x[10], S23); // 27
	MD4_GG(b, c, d, a, x[14], S24); // 28
	MD4_GG(a, b, c, d, x[ 3], S21); // 29
	MD4_GG(d, a, b, c, x[ 7], S22); // 30
	MD4_GG(c, d, a, b, x[11], S23); // 31
	MD4_GG(b, c, d, a, x[15], S24); // 32

	/* Round 3 */
	MD4_HH(a, b, c, d, x[ 0], S31); // 33
	MD4_HH(d, a, b, c, x[ 8], S32); // 34
	MD4_HH(c, d, a, b, x[ 4], S33); // 35
	MD4_HH(b, c, d, a, x[12], S34); // 36
	MD4_HH(a, b, c, d, x[ 2], S31); // 37
	MD4_HH(d, a, b, c, x[10], S32); // 38
	MD4_HH(c, d, a, b, x[ 6], S33); // 39
	MD4_HH(b, c, d, a, x[14], S34); // 40
	MD4_HH(a, b, c, d, x[ 1], S31); // 41
	MD4_HH(d, a, b, c, x[ 9], S32); // 42
	MD4_HH(c, d, a, b, x[ 5], S33); // 43
	MD4_HH(b, c, d, a, x[13], S34); // 44
	MD4_HH(a, b, c, d, x[ 3], S31); // 45
	MD4_HH(d, a, b, c, x[11], S32); // 46
	MD4_HH(c, d, a, b, x[ 7], S33); // 47
	MD4_HH(b, c, d, a, x[15], S34); // 48

	Hash[0] += a;
	Hash[1] += b;
	Hash[2] += c;
	Hash[3] += d;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Updates priority of file if autopriority is activated
void CKnownFile::UpdateUploadAutoPriority(void)
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	if (IsULAutoPrioritized() && !IsCompleting())
	{
		if (IsPartFile() && g_App.m_pDownloadQueue && !IsPaused())
		{
			CPartFile		*pPartFile = dynamic_cast<CPartFile*>(this);

			if(pPartFile != NULL)
			{
				int iValidSources = pPartFile->GetSourceCount() - pPartFile->GetNotCurrentSourcesCount();

				if (iValidSources < RARE_FILE)
					SetULPriority(PR_RELEASE);
				else if (iValidSources < 200)
					SetULPriority(PR_HIGH);
				else if (iValidSources < 400)
					SetULPriority(PR_NORMAL);
				else
					SetULPriority(PR_LOW);
			}
		}
		else
		{
			int iCompleteSources = GetCompleteSourcesCount();	// used KnownFile's method

			if (iCompleteSources < 5)
				SetULPriority(PR_RELEASE);
			else if (iCompleteSources < RARE_FILE)
				SetULPriority(PR_HIGH);
			else if (iCompleteSources < 200)
				SetULPriority(PR_NORMAL);
			else
				SetULPriority(PR_LOW);
		}
	}
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CAbstractFile::SetFileName(const CString& NewName, bool bClearName)
{
	m_strFileName = NewName;

	if (!m_strFileName.IsEmpty())
	{
		m_eFileType = GetED2KFileTypeID(m_strFileName);

		int		iIdxExtension = m_strFileName.ReverseFind(_T('.'));

		if (iIdxExtension != -1)
		{
			m_strFileExtension = m_strFileName.Mid(iIdxExtension + 1);
			m_strFileExtension.MakeLower();
		}
		else
			m_strFileExtension.Empty();
	}
	else
	{
		m_eFileType = ED2KFT_ANY;
		m_strFileExtension.Empty();
	}

	if (bClearName)
	{
		static const TCHAR s_acRepTbl[] =
		{
			_T('/'), _T('>'), _T('<'), _T('*'), _T(':'), _T('?'), _T('|'), _T('\"'), _T('\\')
		};

		for (unsigned ui = 0; ui < _countof(s_acRepTbl); ui++)
			m_strFileName.Replace(s_acRepTbl[ui], _T('-'));
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CAbstractFile::GetFileTypeString()
{
#ifndef NEW_SOCKETS_ENGINE
	unsigned	uiType = m_eFileType;

	if (uiType >= ED2KFT_COUNT)
		uiType = ED2KFT_ANY;

	return GetResString(s_auSearchResID[uiType]);
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CAbstractFile::CmpFileTypes(uint32 dwType2) const
{
#ifndef NEW_SOCKETS_ENGINE
	uint32	dwType1 = m_eFileType;

	if (dwType1 == dwType2)	//	the same type, no need to compare strings
		return 0;

	if (dwType1 >= ED2KFT_COUNT)
		dwType1 = ED2KFT_ANY;
	if (dwType2 >= ED2KFT_COUNT)
		dwType2 = ED2KFT_ANY;

//	As all types are predefined it's safe to use case sensitive compare to speed up
	return _tcscmp(GetResString(s_auSearchResID[dwType1]), GetResString(s_auSearchResID[dwType2]));
#else
	return 0;
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LPCSTR CAbstractFile::GetSearchFileType(uint32 *pdwType)
{
#ifndef NEW_SOCKETS_ENGINE
	static const char *const s_apcSearchTypes[] =
	{
		"",			// ED2KFT_ANY
		"Audio",	// ED2KFT_AUDIO
		"Video",	// ED2KFT_VIDEO
		"Image",	// ED2KFT_IMAGE
		"Pro",		// ED2KFT_PROGRAM, ED2KFT_ARCHIVE, ED2KFT_CDIMAGE
		"Doc"		// ED2KFT_DOCUMENT
	};
	unsigned	uiType = m_eFileType;

	if ((uiType == ED2KFT_ARCHIVE) || (uiType == ED2KFT_CDIMAGE))
		uiType = ED2KFT_PROGRAM;
	if (uiType >= ARRSIZE(s_apcSearchTypes))
		uiType = ED2KFT_ANY;
	*pdwType = uiType;

	return s_apcSearchTypes[uiType];
#else
	return "";
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet* CKnownFile::CreateSrcInfoPacket(const CUpDownClient *pForClient, byte byteRequestedVer, uint16 uRequestedOpt)
{
	NOPRM(uRequestedOpt);	// we don't support any special SX2 options yet, reserved for later use
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

// don't send the sources to the banned clients in order to save our bandwidth & don't help them to hurt the network
// note that at same time the banned clients will be sent to the normal clients, which can decide how to handle those banned sources 
	if (pForClient->IsBanned())
		return NULL;

	ClientList SourceList;

	GetCopySourceList(&SourceList);

	if (SourceList.empty())
		return NULL;

	CMemFile	packetStream(1024);
	uint32		dwCount = 0;
	byte		byteUsedVer;
	bool		bValidSource, bIsSX2Packet;

	if (pForClient->SupportsSourceExchange2() && (byteRequestedVer != 0))
	{
	//	Highest vesion supported by both clients
		byteUsedVer = min(byteRequestedVer, SOURCEEXCHANGE2_VERSION);
		packetStream.Write(&byteUsedVer, 1);
		bIsSX2Packet = true;
	}
	else
	{
		byteUsedVer = pForClient->GetSourceExchange1Version();
		bIsSX2Packet = false;
	}

	packetStream.Write(pForClient->m_reqFileHash, 16);
	packetStream.Write(&dwCount, 2);

	CUpDownClient  *pPotentialSource;
	uint32			dwID, dwSrvIP, dwRes, dwCurTime = ::GetTickCount();
	const byte		*pbyteForClientPartStatus, *pbytePotentialClientPartStatus;
	uint16			uPort, uSrvPort;

	for (ClientList::const_iterator cIt = SourceList.begin(); cIt != SourceList.end(); cIt++)
	{
		pPotentialSource = *cIt;

	//	Don't send a client to itself as a source (part 1)
		if (pForClient == pPotentialSource)
			continue;
	//	Don't send a client to itself as a source (part 2) or another client with same hash
		if ((dwRes = pForClient->Compare(pPotentialSource)) != 0)
			continue;
	//	Don't send a client using a hash that was identified for another client because he could be a hash stealer
		if (pPotentialSource->m_pCredits != NULL
			&& pPotentialSource->m_pCredits->GetCurrentIdentState(pPotentialSource->GetIP()) == IS_IDBADGUY)
			continue;
	//	Don't send a client that did only one request to prevent spreading of unstable clients
		if (pPotentialSource->GetAskedCount() < 2)
			continue;
	//	Don't send a client that did not request any file during MAX_PURGEQUEUETIME, because client is offline
		if (dwCurTime > (pPotentialSource->GetLastUpRequest() + MAX_PURGEQUEUETIME))
			continue;
	//	Check LowID status
		if (pPotentialSource->HasLowID())
		{
		//	Don't send a LowID client to LowID as they won't be able to connect
			if (pForClient->HasLowID())
				continue;
		//	Don't send a LowID client if server IP & server port are unknown
			if (pPotentialSource->GetServerIP() == 0 || pPotentialSource->GetServerPort() == 0)
				continue;
		//	Don't send a LowID client to HighID if client is on different server
			if ( pPotentialSource->GetServerIP() != pForClient->GetServerIP()
				|| pPotentialSource->GetServerPort() != pForClient->GetServerPort() )
				continue;
		}
	//	Don't share Lan clients sources as they are private ips/userids
		if (pPotentialSource->IsOnLAN())
			continue;

		bValidSource = true;
		pbytePotentialClientPartStatus = pPotentialSource->GetUpPartStatus();
	// check if potential source reported parts info with same file hash
		if (!md4cmp(pPotentialSource->m_reqFileHash, GetFileHash()) && pbytePotentialClientPartStatus != NULL)
		{
		//	Don't send clients that have no parts available
			if (pPotentialSource->GetAvailUpPartCount() == 0 && pForClient->GetUpPartCount() > 1)
				continue;
			pbyteForClientPartStatus = pForClient->GetUpPartStatus();
		// check if target client also reported parts status
			if (pbyteForClientPartStatus != NULL)
			{
			//	Don't send the clients that support the upload parts statuses & have different number of the parts
				if (pForClient->GetUpPartCount() != pPotentialSource->GetUpPartCount())
					continue;

			// Both clients support part statuses so we gonna check & exclude NNS source for target client
				bValidSource = false;
				for (uint32 i = 0; i < pForClient->GetUpPartCount(); i++)
				{
					if(pbytePotentialClientPartStatus[i] && !pbyteForClientPartStatus[i])
					{
						bValidSource = true;
						break;
					}
				}
			}
		}

		if (bValidSource)
		{
			if (byteUsedVer >= 3)
				dwID = pPotentialSource->GetUserIDHybrid();
			else	//	use the old ed2k user ID convention for LowID sources on the same server
			{
				if (pPotentialSource->HasLowID())
					dwID = pPotentialSource->GetUserIDHybrid();
				else
					dwID = pPotentialSource->GetIP();
			}
			uPort = pPotentialSource->GetUserPort();
			dwSrvIP = pPotentialSource->GetServerIP();
			uSrvPort = pPotentialSource->GetServerPort();

			packetStream.Write(&dwID, 4);
			packetStream.Write(&uPort, 2);
			packetStream.Write(&dwSrvIP, 4);
			packetStream.Write(&uSrvPort, 2);
			if (byteUsedVer > 1)
			{
				packetStream.Write(pPotentialSource->GetUserHash(), 16);
				if (byteUsedVer >= 4)	// CryptSettings - SourceExchange V4
				{
					// 5 Reserved
					// 1 CryptLayer Required
					// 1 CryptLayer Requested
					// 1 CryptLayer Supported
					const byte byteCryptOptions = pPotentialSource->GetCryptLayer();

					packetStream.Write(&byteCryptOptions, 1);
				}
			}
			if (++dwCount > 500)
				break;
		}
	}

	if (dwCount == 0)
		return NULL;

	packetStream.Seek((bIsSX2Packet) ? 17 : 16, 0);
	packetStream.Write(&dwCount, 2);

	Packet	*pPacket = new Packet(&packetStream,OP_EMULEPROT);

	pPacket->m_eOpcode = (bIsSX2Packet) ? OP_ANSWERSOURCES2 : OP_ANSWERSOURCES;
// (1+)16+2+501*(4+2+4+2+16+1) = 14547 (14548) bytes max.
	if (pPacket->m_dwSize > 354)
		pPacket->PackPacket();

	return pPacket;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	For File Comment
void CKnownFile::LoadComment()
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	CString		strFullPath;
	unsigned	uiRate;

	strFullPath.Format(_T("%sfileinfo.ini"), g_App.m_pPrefs->GetConfigDir());

	CIni ini(strFullPath, INI_MODE_READONLY);	// file is closed in destructor

	ini.SetDefaultCategory(HashToString(m_fileHash));
	m_strComment = ini.GetString(_T("Comment"), _T("")).Left(MAXFILECOMMENTLEN);
	uiRate = ini.GetInt(_T("Rate"), PF_RATING_NONE);
	if (uiRate > PF_RATING_EXCELLENT)
		uiRate = PF_RATING_NONE;
	m_eRating = static_cast<_EnumPartFileRating>(uiRate);
	m_bCommentLoaded = true;
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::RemoveFileCommentAndRating()
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	CString strFullPath;

	strFullPath.Format(_T("%sfileinfo.ini"),g_App.m_pPrefs->GetConfigDir());

	CIni ini(strFullPath);

	ini.DeleteCategory(HashToString(m_fileHash));
	ini.SaveAndClose();

	m_strComment.Empty();
	m_eRating = PF_RATING_NONE;

	if (IsPartFile())
		((CPartFile*)this)->UpdateFileRatingCommentAvail();
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::SetFileComment(const CString &strNewComment)
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	CString	strFullPath;

	strFullPath.Format(_T("%sfileinfo.ini"), g_App.m_pPrefs->GetConfigDir());

	CIni ini(strFullPath);

	ini.SetDefaultCategory(HashToString(m_fileHash));

	ini.SetString(_T("Comment"), strNewComment);
	m_strComment = strNewComment;

	ini.SaveAndClose();

	CTypedPtrList<CPtrList, CUpDownClient*> srclist;

	g_App.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());

	CUpDownClient	*pClient;

	for (POSITION pos = srclist.GetHeadPosition(); pos != NULL; )
	{
		pClient = srclist.GetNext(pos);
		pClient->SetCommentDirty();
	}

	if (IsPartFile())
		((CPartFile*)this)->SetHasComment(true);
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	For File rate
void CKnownFile::SetFileRating(EnumPartFileRating eNewRating)
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
//	Avoid unrequired saving and server republish if rating is still the same
	if (m_eRating != eNewRating)
	{
		CString strFullPath(g_App.m_pPrefs->GetConfigDir());

		strFullPath += _T("fileinfo.ini");

		CIni ini(strFullPath);

		ini.SetDefaultCategory(HashToString(m_fileHash));

		ini.SetInt(_T("Rate"), eNewRating);
		m_eRating = eNewRating;

		ini.SaveAndClose();

	//	Republish a file on the server (if possible) to update server file rating
	//	lugdunummaster: server handles the republishing of a file, taking into account
	//	a change in the rating (but if an already rated file is republished without a rating,
	//	no change is done on the rating - server keeps the previous rating for this file and client)
		if (eNewRating != PF_RATING_NONE)
			g_App.m_pSharedFilesList->RepublishFile(this, SRV_TCPFLG_TYPETAGINTEGER/*check feature support*/);

		CTypedPtrList<CPtrList, CUpDownClient*> srclist;
		g_App.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());

		CUpDownClient	*pClient;

		for (POSITION pos = srclist.GetHeadPosition(); pos != NULL;)
		{
			pClient = srclist.GetNext(pos);
			pClient->SetCommentDirty();
		}

		if (IsPartFile())
			((CPartFile*)this)->SetHasRating(true);
	}
#endif //NEW_SOCKETS_ENGINE
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::initTraffic()
{
	EMULE_TRY

	if(partTraffic==NULL)
	{
		uint16 p=fileParent->GetPartCount();
		partTraffic=new uint32[p];
		partTrafficSession=new uint32[p];
		for(uint16 i=0; i<p; i++)
		{
			partTraffic[i]=0;
			partTrafficSession[i]=0;
		}
	}

	if(partAccepted==NULL)
	{
		uint16 p=fileParent->GetPartCount();
		partAccepted=new uint32[p];
		partAcceptedSession=new uint32[p];
		for(uint16 i=0; i<p; i++)
		{
			partAccepted[i]=0;
			partAcceptedSession[i]=0;
		}
	}

	if(blockTraffic==NULL)
	{
		uint32 p=fileParent->GetBlockCount();
		blockTraffic=new uint32[p];
		blockTrafficSession=new uint32[p];
		for(uint32 i=0; i<p; i++)
		{
			blockTraffic[i]=0;
			blockTrafficSession[i]=0;
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::recalcCompleteReleases()
{
//	Recalculate complete releases factor
	uint32	dwBlocks = fileParent->GetBlockCount();
	uint32	s, m = 0xFFFFFFFF;
	double	dMin;

//	Find lowest parttraffic
	for (uint32 i = 0; i < dwBlocks; i++)
	{
		if (blockTraffic[i] == 0)
			continue;
		s = fileParent->GetBlockSize(i);

		uint32 f = (blockTraffic[i] + s - 1u) / s;

		if (f < m)
			m = f;
	}

//	Get average
	dMin = static_cast<double>(m);
	completeReleases = 0;
	for (uint32 i = 0; i < dwBlocks; i++)
	{
		if (blockTraffic[i] == 0)
			continue;
		s = fileParent->GetBlockSize(i);

		double f = static_cast<double>(blockTraffic[i]) / s;

		if (f > dMin)
			f = dMin;
		completeReleases += f;
	}

	completeReleases /= dwBlocks;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	This function may not return a 100% accurate value, because you can't fill a part with blocks
double CFileStatistic::GetCompletePartReleases(uint16 part)
{
//	Check part
	if((partTraffic == NULL) || (part >= fileParent->GetPartCount()) || (partTraffic[part] == 0))
		return 0;

//	Start and end block
	uint32	dwStartBlk = static_cast<uint32>(static_cast<uint64>(part) * PARTSIZE / EMBLOCKSIZE);
	uint32	dwEndBlk = static_cast<uint32>((static_cast<uint64>(part) * PARTSIZE + PARTSIZE - 1ui64) / EMBLOCKSIZE);

	if (dwEndBlk >= fileParent->GetBlockCount())
		dwEndBlk = fileParent->GetBlockCount() - 1;

//	Find lowest parttraffic
	uint32	s, m = 0xFFFFFFFF;
	double	dMin, completePartReleases = 0;
	for (uint32 i = dwStartBlk; i <= dwEndBlk; i++)
	{
		if (blockTraffic[i] == 0)
			continue;
		s = fileParent->GetBlockSize(i);

		uint32 f = (blockTraffic[i] + s - 1u) / s;

		if (f < m)
			m = f;
	}

//	Get avg.
	dMin = static_cast<double>(m);
	for (uint32 i = dwStartBlk; i <= dwEndBlk; i++)
	{
		if (blockTraffic[i] == 0)
			continue;
		s = fileParent->GetBlockSize(i);

		double f = static_cast<double>(blockTraffic[i]) / s;
		if (f > dMin)
			f = dMin;
		completePartReleases += f;
	}

	return completePartReleases * EMBLOCKSZ32 / fileParent->GetPartSize(part);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::AddTraffic(uint32 dwPart, const uint64 &qwStart, uint32 dwBytes)
{
	EMULE_TRY

	initTraffic();

	sint32	btg = static_cast<sint32>(dwBytes);

	uint32 p1 = min(static_cast<uint32>((static_cast<uint64>(dwPart) + 1ui64) * PARTSIZE - qwStart), dwBytes);
	partTraffic[dwPart] += p1;
	partTrafficSession[dwPart] += p1;
	partAccepted[dwPart]++;
	partAcceptedSession[dwPart]++;

//	Start block
	uint32	block = static_cast<uint32>(qwStart / EMBLOCKSIZE);
	btg = static_cast<sint32>(dwBytes);

	uint32 b1 = min(static_cast<uint32>((static_cast<uint64>(block) + 1ui64) * EMBLOCKSIZE - qwStart), dwBytes);
	blockTraffic[block]+=b1;
	blockTrafficSession[block]+=b1;
	btg-=b1;
	block++;
	while(btg>0)
	{
		b1 = (btg >= EMBLOCKSZ32) ? EMBLOCKSZ32 : btg;
		blockTraffic[block] += b1;
		blockTrafficSession[block] += b1;
		block++;
		btg -= b1;
	}

	recalcCompleteReleases();

	fileParent->UpdateSharedFileDisplay();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::SaveToFileTraffic(FILE* file)
{
	EMULE_TRY

	if(statistic.partTraffic)
	{
		uint16 parts=GetPartCount();
		if(fwrite(&parts, sizeof(parts), 1, file)!=1) return false;
		if(fwrite(statistic.partTraffic, 4, parts, file)!=parts) return false;

		uint32 blocks=GetBlockCount();
		if(fwrite(&blocks, sizeof(blocks), 1, file)!=1) return false;
		if(fwrite(statistic.blockTraffic, 4, blocks, file)!=blocks) return false;

		if(fwrite(statistic.partAccepted, 4, parts, file)!=parts) return false;
	}

//	This block shouldnt be used at all
	else
	{
		uint32	d=0;

		uint16 parts=GetPartCount();
		if(fwrite(&parts, sizeof(parts), 1, file)!=1) return false;
		for(uint16 part=0; part<parts; part++)
			if(fwrite(&d, sizeof(d), 1, file)!=1) return false;

		uint32 blocks=GetBlockCount();
		if(fwrite(&blocks, sizeof(blocks), 1, file)!=1) return false;
		for(uint32 block=0; block<blocks; block++)
			if(fwrite(&d, sizeof(d), 1, file)!=1) return false;

		for(uint16 part=0; part<parts; part++)
			if(fwrite(&d, sizeof(d), 1, file)!=1) return false;
	}

	return (ferror(file)) ? false : true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::LoadFromFileTraffic(FILE* file, byte version)
{
	EMULE_TRY

	// read parts
	uint16 parts=0;
	if(fread(&parts, sizeof(parts), 1, file)!=1) return false;

	// does part count match?
	if (parts != GetPartCount())
		return false;

	// get the memory
	statistic.initTraffic();

	// load all the parts traffic data
	if(fread(statistic.partTraffic, 4, parts, file)!=parts) return false;

	// read blocks
	uint32 blocks=0;
	if(fread(&blocks, sizeof(blocks), 1, file)!=1) return false;

	// does blocks count match?
	if (blocks != GetBlockCount())
		return false;

	// load all the parts traffic data
	if(fread(statistic.blockTraffic, 4, blocks, file)!=blocks) return false;

//	Versioning
	if(version>1)
	{
	//	Version 2 introduced part-accepted counter
		if(fread(statistic.partAccepted, 4, parts, file)!=parts) return false;
	}

//	Recalc something ---
	statistic.recalcCompleteReleases();

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CKnownFile::GetTrafficBlock(uint64 qwStart, uint64 qwEnd, bool bSession/*=false*/)
{
	uint32	*pdwData = (bSession) ? statistic.blockTrafficSession : statistic.blockTraffic;

	if ((pdwData == NULL) || (qwStart > GetFileSize()))
		return 0;

	if (qwEnd > GetFileSize())
		qwEnd = GetFileSize();

	uint32	block = static_cast<uint32>(qwStart / EMBLOCKSIZE);
	uint32	bftb = 0 - static_cast<uint32>(qwStart % EMBLOCKSIZE);
	uint32	dwEndMod = static_cast<uint32>(qwEnd % EMBLOCKSIZE);
	uint32	t = 0;

	while (qwStart < qwEnd)
	{
		if ((qwEnd - qwStart) > dwEndMod)
			bftb += EMBLOCKSZ32;
		else
			bftb += dwEndMod;

		if (bftb != EMBLOCKSZ32)
			t += static_cast<uint32>(pdwData[block] * (double)bftb / GetBlockSize(block));
		else
			t += pdwData[block];
		qwStart += bftb;
		bftb = 0;
		block++;
	}

	return t;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CKnownFile::GetTrafficPart(uint64 qwStart, uint64 qwEnd, bool bSession/*=false*/)
{
	uint32	*pdwData = (bSession) ? statistic.partTrafficSession : statistic.partTraffic;

	if ((pdwData == NULL) || (qwStart > GetFileSize()))
		return 0;

	if (qwEnd > GetFileSize())
		qwEnd = GetFileSize();

	uint32	dwPart = static_cast<uint32>(qwStart / PARTSIZE);
	uint32	bftp = 0 - static_cast<uint32>(qwStart % PARTSIZE);
	uint32	dwEndMod = static_cast<uint32>(qwEnd % PARTSIZE);
	uint32	t = 0;

	while (qwStart < qwEnd)
	{
		if ((qwEnd - qwStart) > dwEndMod)
			bftp += PARTSZ32;
		else
			bftp += dwEndMod;

		if (bftp != PARTSZ32)
			t += static_cast<uint32>(pdwData[dwPart] * (double)bftp / GetPartSize(dwPart));
		else
			t += pdwData[dwPart];
		qwStart += bftp;
		bftp = 0;
		dwPart++;
	}

	return t;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CKnownFile::GetPartTraffic(uint16 part, bool session)
{
	if(statistic.partTraffic==NULL)
		return 0;

	if(session)
		return statistic.partTrafficSession[part];
	else
		return statistic.partTraffic[part];
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CKnownFile::GetBlockTraffic(uint16 block, bool session)
{
	if(statistic.partTraffic==NULL)
		return 0;

	if(session)
		return statistic.blockTrafficSession[block];
	else
		return statistic.blockTraffic[block];
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CKnownFile::GetPartSize(uint32 dwPart) const
{
	return ((dwPart + 1) < GetPartCount()) ? PARTSZ32 : m_dwLastPartSz;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CKnownFile::GetBlockSize(uint32 dwBlock) const
{
	return ((dwBlock + 1) < GetBlockCount()) ? EMBLOCKSZ32 : m_dwLastBlkSz;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::resetStats(bool all)
{
	EMULE_TRY

	if (all)
	{
		if (partTraffic)		delete[] partTraffic;	partTraffic = NULL;
		if (partAccepted)	delete[] partAccepted;	partAccepted = NULL;
		if (blockTraffic)	delete[] blockTraffic;	blockTraffic = NULL;

		if (partTrafficSession)		delete[] partTrafficSession;	partTrafficSession = NULL;
		if (partAcceptedSession)		delete[] partAcceptedSession;	partAcceptedSession = NULL;
		if (blockTrafficSession)		delete[] blockTrafficSession;	blockTrafficSession = NULL;

		completeReleases = 0.0;

		m_dwAllTimeRequested = m_dwAllTimeAccepted = 0;
		m_qwAllTimeTransferred = 0;
	}
	else
	{
		if (partTrafficSession)
			for (uint16 part = 0; part < fileParent->GetPartCount(); part++)
				partTrafficSession[part] = 0;

		if (partAcceptedSession)
			for (uint16 part = 0; part < fileParent->GetPartCount(); part++)
				partAcceptedSession[part] = 0;

		if (blockTrafficSession)
			for (uint32 block = 0; block < fileParent->GetBlockCount(); block++)
				blockTrafficSession[block] = 0;
	}

	m_iNumRequested = m_iNumAccepted = 0;
	m_qwNumTransferred = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileStatistic::resetPartTraffic(uint16 part, bool all)
{
	EMULE_TRY

	if(partTraffic==NULL || part>=fileParent->GetPartCount())
		return;

	//--- this all is a little bit tricky, because the part and block size have no connections ---
	//--- so i have to remove some bytes only from the start and end block ---
	//--- all we try is to keep it as realistic as possible :) ---
	uint32	dwBlocks = fileParent->GetBlockCount();
	uint32	dwBlkStart = static_cast<uint32>((static_cast<uint64>(part) * PARTSIZE) / EMBLOCKSIZE);
	double	dPercentStart = static_cast<double>(static_cast<uint32>((static_cast<uint64>(part) * PARTSIZE) % EMBLOCKSIZE)) / EMBLOCKSZ32;
	uint32	dwBlkEnd = min(static_cast<uint32>((static_cast<uint64>(part + 1) * PARTSIZE) / EMBLOCKSIZE), dwBlocks - 1);
	double	dPercentEnd = 0.0;
	if (dwBlkEnd != (dwBlocks - 1))
		dPercentEnd = 1.0 - static_cast<double>(static_cast<uint32>((static_cast<uint64>(part + 1) * PARTSIZE) / EMBLOCKSIZE)) / EMBLOCKSZ32;

	if(all)
	{
		partTraffic[part] = 0;
		blockTraffic[dwBlkStart] = static_cast<uint32>(blockTraffic[dwBlkStart] * dPercentStart);
		blockTraffic[dwBlkEnd] = static_cast<uint32>(blockTraffic[dwBlkEnd] * dPercentEnd);
		for (uint32 block = dwBlkStart + 1; block < dwBlkEnd; block++)
			blockTraffic[block] = 0;
	}

	partTrafficSession[part] = 0;
	blockTrafficSession[dwBlkStart] = static_cast<uint32>(blockTrafficSession[dwBlkStart] * dPercentStart);
	blockTrafficSession[dwBlkEnd] = static_cast<uint32>(blockTrafficSession[dwBlkEnd] * dPercentEnd);
	for (uint32 block = dwBlkStart + 1; block < dwBlkEnd; block++)
		blockTrafficSession[block] = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CFileStatistic::GetPartAccepted(uint16 part, bool session) const
{
	EMULE_TRY

	if(partTraffic==NULL || part>=fileParent->GetPartCount())
		return 0;

	if(session==false)
		return partAccepted[part];
	else
		return partAcceptedSession[part];

	EMULE_CATCH

	return 0;
}
//--- :xrmb ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--- xrmb:allyaknow ---
//-------------------------------------------------------------------------------------------------
bool CFileStatistic::merge(CFileStatistic *m)
{
	EMULE_TRY

	m_dwAllTimeRequested += m->m_dwAllTimeRequested;
	m_dwAllTimeAccepted += m->m_dwAllTimeAccepted;
	m_qwAllTimeTransferred += m->m_qwAllTimeTransferred;

	m_iNumRequested	= m_iNumRequested + m->m_iNumRequested;
	m_iNumAccepted = m_iNumAccepted + m->m_iNumAccepted;
	m_qwNumTransferred += m->m_qwNumTransferred;

	//--- merge parttraffic ---

	//--- i dont have traffic, but the to merge has ---
	if(partTraffic==NULL && m->partTraffic)
		initTraffic();

	//--- merge traffic only if the to merge has some ---
	if(m->partTraffic)
	{
		for(uint16 part=0; part<fileParent->GetPartCount(); part++)
			partTraffic[part]+=m->partTraffic[part];

		for(uint32 block=0; block<fileParent->GetBlockCount(); block++)
			blockTraffic[block]+=m->blockTraffic[block];
	}

	return true;

	EMULE_CATCH

	return false;
}
//--- :xrmb ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::HasHiddenParts()
{
	EMULE_TRY

	for (uint16 i = 0; i < GetPartCount(); i++)
	{
		if (!IsPartShared(i))
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::WritePartStatus(CFile *file)
{
	EMULE_TRY

	uchar	byteTmpBuff[32];	// should be power of 2
	uint32	dwDone = 0, dwBuffIdx = 2, dwDiff, dwParts = m_partHashArray.GetCount();

	POKE_WORD(byteTmpBuff, static_cast<uint16>(dwParts));

	while ((dwDiff = (dwParts - dwDone)) != 0)
	{
		byte	byteMask = 1;
		uint32	dwLimit = dwDone + ((dwDiff > 8) ? 8 : dwDiff);

		byteTmpBuff[dwBuffIdx] = 0;
		do
		{
			if (IsPartShared(dwDone++))
				byteTmpBuff[dwBuffIdx] |= byteMask;
			byteMask <<= 1;
		} while (dwDone < dwLimit);
		dwBuffIdx = (dwBuffIdx + 1) & (sizeof(byteTmpBuff) - 1);
		if (dwBuffIdx == 0)
			file->Write(byteTmpBuff, sizeof(byteTmpBuff));
	}
	if (dwBuffIdx != 0)
		file->Write(byteTmpBuff, dwBuffIdx);

	EMULE_CATCH
}
//--- :xrmb/partprio ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::IsJsComplete()
{
#ifndef NEW_SOCKETS_ENGINE
	return CJumpstarter::IsJsCompleteForFile(this);
#else
	return true;
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::SetJumpstartEnabled(bool enabled)
{
#ifndef NEW_SOCKETS_ENGINE
	if(!enabled && m_Jumpstarter)
	{
		m_Jumpstarter->Disable();
		delete m_Jumpstarter;
		m_Jumpstarter = NULL;
	}
	else if(enabled && !m_Jumpstarter)
	{
		CJumpstarter::EnableForFile(this);
		m_Jumpstarter = new CJumpstarter(this);
	}
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::AddSentBlock(CUpDownClient *client, const uint64 &qwStartOffset, uint32 togo)
{
#ifndef NEW_SOCKETS_ENGINE
	m_Jumpstarter->AddSentBlock(client, qwStartOffset, togo);
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::WriteJumpstartPartStatus(CUpDownClient *client, CMemFile* data)
{
#ifndef NEW_SOCKETS_ENGINE
	m_Jumpstarter->WriteJumpstartPartStatus(client, data);
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFile::AllowChunkForClient(uint32 partNo, CUpDownClient* client)
{
#ifndef NEW_SOCKETS_ENGINE
	return (!m_Jumpstarter) || m_Jumpstarter->AllowChunkForClient(partNo, client);
#else
	return true;
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ReadFileForUpload() opens known file and read information.
//		Params:
//			qwOffset      - file offset to start reading from;
//			dwBytesToRead - number of bytes to read;
//			pbyteBuffer   - buffer to receive data.
//		Return:
//			< 0 in case of error, else 0.
int CKnownFile::ReadFileForUpload(uint64 qwOffset, uint32 dwBytesToRead, byte *pbyteBuffer)
{
	int	iRc = -1;

	EMULE_TRY

	CFile	file;

	if (file.Open(m_strFilePath, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
	{
		file.Seek(qwOffset, CFile::begin);
		if (file.Read(pbyteBuffer, dwBytesToRead) == dwBytesToRead)
			iRc = 0;
		file.Close();
	}

	EMULE_CATCH

	return iRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CKnownFile::GetPermissionString()
{
#ifndef NEW_SOCKETS_ENGINE
	static const uint16 s_auResTbl[] =
	{
		IDS_FSTATUS_PUBLIC,			//PERM_ALL
		IDS_FSTATUS_FRIENDSONLY,	//PERM_FRIENDS
		IDS_HIDDEN					//PERM_NOONE
	};
	unsigned	uiPerm = GetPermissions();

	if (uiPerm >= ARRSIZE(s_auResTbl))
		uiPerm = PERM_ALL;
	return GetResString(s_auResTbl[uiPerm]);
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::AddClientToSourceList(CUpDownClient* pClient)
{
	EnterCriticalSection(&m_csSourceList);

	if (find(m_SourceList.begin(), m_SourceList.end(), pClient) == m_SourceList.end())
		m_SourceList.push_back(pClient);

	LeaveCriticalSection(&m_csSourceList);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::RemoveClientFromSourceList(CUpDownClient* pClient)
{
	EnterCriticalSection(&m_csSourceList);

	m_SourceList.remove(pClient);

	LeaveCriticalSection(&m_csSourceList);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::GetCopySourceList(ClientList *pCopy)
{
	if (m_SourceList.empty())
		return;

	EnterCriticalSection(&m_csSourceList);

	pCopy->insert(pCopy->begin(), m_SourceList.begin(), m_SourceList.end());

	LeaveCriticalSection(&m_csSourceList);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetKnownFilePriorityString() returns file upload priority string
CString CKnownFile::GetKnownFilePriorityString() const
{
	static const uint16 s_auAutoPrioResID[] = {
		IDS_PRIOAUTOLOW,	//PR_LOW
		IDS_PRIOAUTONORMAL,	//PR_NORMAL
		IDS_PRIOAUTOHIGH,	//PR_HIGH
		IDS_PRIOAUTORELEASE	//PR_RELEASE
	};
	static const uint16 s_auPrioResID[] = {
		IDS_PRIOLOW,		//PR_LOW
		IDS_PRIONORMAL,		//PR_NORMAL
		IDS_PRIOHIGH,		//PR_HIGH
		IDS_PRIORELEASE,	//PR_RELEASE
		IDS_PRIOVERYLOW		//PR_VERYLOW
	};
	unsigned	uiPrio = m_bytePriority;
	uint32		dwResId;

	if (m_bAutoPriority)
	{
		if (uiPrio >= ARRSIZE(s_auAutoPrioResID))
			uiPrio = PR_LOW;
		dwResId = s_auAutoPrioResID[uiPrio];
	}
	else
	{
		if (uiPrio >= ARRSIZE(s_auPrioResID))
			uiPrio = PR_VERYLOW;
		dwResId = s_auPrioResID[uiPrio];
	}

	CString	strBuffer;

	if (GetJumpstartEnabled())
		strBuffer.Format(_T("JumpStart[%s]"), GetResString(dwResId));
	else
		GetResString(&strBuffer, dwResId);
	return strBuffer;
}
@


1.245
log
@Reduced H-file dependency.
@
text
@a1645 13
#if 0	// we upload only within one chunck!
	btg-=p1;
	dwPart++;
	while(btg > 0)
	{
		partTraffic[dwPart] += btg % PARTSZ32;
		partTrafficSession[dwPart] += btg % PARTSZ32;
		partAccepted[dwPart]++;
		partAcceptedSession[dwPart]++;
		dwPart++;
		btg -= PARTSZ32;
	}
#endif
d1658 3
a1660 2
		blockTraffic[block] += btg % EMBLOCKSZ32;
		blockTrafficSession[block] += btg % EMBLOCKSZ32;
d1662 1
a1662 1
		btg -= EMBLOCKSZ32;
@


1.244
log
@Reduced H-file dependency.
@
text
@d39 3
d571 1
a571 1
		if (!m_strFileName.IsEmpty() )
@


1.243
log
@Reduced H-file dependency.
@
text
@d38 1
@


1.242
log
@Removed duplicated attempts to close ini file (directly by the call and indirectly by destructor).
@
text
@d36 1
@


1.241
log
@Fixed limiting file comment on load from a file (issue was introduced after 1.2d).
@
text
@d1378 1
a1378 1
	CIni ini(strFullPath, INI_MODE_READONLY);
a1386 2

	ini.CloseWithoutSave();
@


1.240
log
@Simplified logging system implementation.
@
text
@d1381 1
a1381 2
	ini.GetString(&m_strComment, _T("Comment"), _T(""));
	m_strComment.Left(MAXFILECOMMENTLEN);
@


1.239
log
@Reduced H-file dependency.
@
text
@d471 1
a471 1
	AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("File %s is being hashed"), (bPartFile) ? strNameBuffer : strFileName);
d569 1
a569 1
			AddDebugLogLine(_T("Loaded hashset size is corrupt in known.met, file: %s!"), m_strFileName);
d572 1
a572 3
		{
			AddDebugLogLine(_T("Loaded hashset size is corrupt in known.met!"));
		}
d760 1
a760 1
		AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_KNOWNHASHCORR), m_strFileName);
d767 1
a767 1
		AddLogLine(false, IDS_JS_ENABLED, m_strFileName);
@


1.238
log
@Reduced H-file dependency.
@
text
@a1 1

d3 1
a3 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
d31 1
@


1.237
log
@Function body was moved to the H-file;
Minor optimization;
Formatting.
@
text
@d21 1
@


1.236
log
@Fixed incorrect destructor for some allocated buffers; Removed useless checks around delete operator; Stricter prototypes for some methods; Faster reading for some ini strings.
@
text
@a323 5
void CKnownFile::SetFilePath(LPCTSTR pszFilePath)
{
	m_strFilePath = pszFilePath;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.235
log
@Corrected reporting of corrupted part traffic data files (no multiple reports for traffic.dat corruption; report actual corrupted file name for .part.stats corruptions) {Vladimir (SV)}.
@
text
@d233 1
a233 2
	if (m_pPartsHashSet != NULL)
		delete m_pPartsHashSet;
d237 1
a237 2
	if (m_Jumpstarter)
		delete m_Jumpstarter;
d505 1
a505 1
				delete pPartsHashSet;
d610 1
a610 1
			file.Read(pPartHash,16);		// <HASH>[count] part hashes
d623 1
a623 1
			safe_delete(m_pPartsHashSet);
d635 1
a635 1
			safe_delete(pPartsHashSet);
d949 1
a949 1
uchar* CKnownFile::GetPartHash(uint32 dwPart)
d953 1
a953 1
		return 0;
d959 1
a959 1
	return 0;
d1387 2
a1388 1
	m_strComment = ini.GetString(_T("Comment"), _T("")).Left(MAXFILECOMMENTLEN);
@


1.234
log
@Allow export localized ed2k links (skip utf8 conversion) {DoubleT} -- GUI part will be added later;
Some optimization.
@
text
@d1741 1
a1741 7
	if(parts!=GetPartCount())
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_TRAFFICDAT_CORRUPT));
		g_App.m_pMDlg->DisableAutoBackup();
#endif //NEW_SOCKETS_ENGINE

a1742 1
	}
d1755 1
a1755 7
	if(blocks!=GetBlockCount())
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_TRAFFICDAT_CORRUPT));
		g_App.m_pMDlg->DisableAutoBackup();
#endif //NEW_SOCKETS_ENGINE

a1756 1
	}
@


1.233
log
@GetKnownFilePriorityString() functionality moved to knownfile class;
Sanity check for loaded known file rating value.
@
text
@d65 3
a67 1
	CString		strLink;
d71 1
a71 1
					Ed2kURIEncode(g_App.StripInvalidFilenameChars(GetFileName(), false)),	// spaces to dots
d73 1
a73 1
					GetFileName(),
d75 1
a75 1
					GetFileSize(), HashToString(GetFileHash()) );
d103 3
a105 1
	return _T("<a href=\"") + CreateED2kLink() + _T("\">") + 
d111 2
a112 1
		+ _T("</a>");
@


1.232
log
@Tag array was moved to abstract class to unify processing.
@
text
@d35 1
d1376 2
a1377 1
	CString	strFullPath;
d1385 4
a1388 1
	m_eRating = static_cast<_EnumPartFileRating>(ini.GetInt(_T("Rate"), PF_RATING_NONE));
d2192 41
@


1.231
log
@Fixed 'improved comment processing' which screwed comment processing big time.
@
text
@d56 6
a230 3
	for (int i = 0; i < m_tagArray.GetSize(); i++)
		safe_delete(m_tagArray[i]);

@


1.230
log
@improved comment processing
@
text
@d1380 1
a1380 1
	m_eRating = static_cast<EnumPartFileRating>(ini.GetInt(_T("Rate"), PF_RATING_NONE));
@


1.229
log
@Suppressed compiler warnings; Formatting.
@
text
@d1380 1
a1380 1
	m_eRating = static_cast<_EnumPartFileRating>(ini.GetInt(_T("Rate"), PF_RATING_NONE));
@


1.228
log
@Suppressed level 4 warnings; Formatting.
@
text
@d115 3
a117 1
	m_iNumRequested = m_qwNumTransferred = m_iNumAccepted = alltimerequested= alltimetransferred = alltimeaccepted = 0;
d142 1
a142 1
	alltimerequested++;
d158 1
a158 1
	alltimeaccepted++;
d167 1
a167 1
void CFileStatistic::AddTransferred(uint32 bytes)
d171 2
a172 2
	m_qwNumTransferred += bytes;
	alltimetransferred += bytes;
d174 1
a174 1
	g_App.m_pKnownFilesList->m_qwNumTransferred += bytes;
d672 1
a672 1
					statistic.alltimetransferred = (statistic.alltimetransferred & (0xFFFFFFFFi64 << 32)) | newtag->GetIntValue();
d677 1
a677 1
					statistic.alltimetransferred = (statistic.alltimetransferred & 0xFFFFFFFF) |
d683 1
a683 1
					statistic.alltimerequested = newtag->GetIntValue();
d688 1
a688 1
					statistic.alltimeaccepted = newtag->GetIntValue();
d1712 1
a1712 1
	return ferror(file);
d1802 1
a1802 1
			t += pdwData[block] * (double)bftb / GetBlockSize(block);
d1836 1
a1836 1
			t += pdwData[dwPart] * (double)bftp / GetPartSize(dwPart);
d1895 2
a1896 1
		alltimerequested = alltimetransferred = alltimeaccepted=0;
d1913 2
a1914 1
	m_iNumRequested = m_qwNumTransferred=m_iNumAccepted=0;
d1940 2
a1941 2
		blockTraffic[dwBlkStart] *= dPercentStart;
		blockTraffic[dwBlkEnd] *= dPercentEnd;
d1947 2
a1948 2
	blockTrafficSession[dwBlkStart] *= dPercentStart;
	blockTrafficSession[dwBlkEnd] *= dPercentEnd;
d1979 7
a1985 7
	alltimerequested	+= m->alltimerequested;
	alltimeaccepted		+= m->alltimeaccepted;
	alltimetransferred	+= m->alltimetransferred;

	m_iNumRequested	+= m->m_iNumRequested;
	m_iNumAccepted	+= m->m_iNumAccepted;
	m_qwNumTransferred	+= m->m_qwNumTransferred;
a2029 1
	uint16	uParts = m_partHashArray.GetCount();
d2031 1
a2031 1
	uint32	dwDone = 0, dwBuffIdx = 2, dwDiff, dwParts = static_cast<uint32>(uParts);
d2033 1
a2033 1
	*reinterpret_cast<uint16*>(&byteTmpBuff[0]) = uParts;
@


1.227
log
@splited the functions for ed2k link and URL generation
@
text
@d172 1
a172 1
	g_App.m_pKnownFilesList->m_iNumTransferred += bytes;
@


1.226
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d62 1
a62 1
					URLEncode(g_App.StripInvalidFilenameChars(GetFileName(), false)),	// spaces to dots
d802 5
@


1.225
log
@Suppressed compiler warnings [Aw3].
@
text
@d62 1
a62 1
					g_App.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
d1369 1
a1369 1
	CIni ini(strFullPath, true);
@


1.224
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d935 1
a935 1
uchar* CKnownFile::GetPartHash(uint16 part)
d938 1
a938 1
	if (part >= m_partHashArray.GetCount())
d941 1
a941 1
	return m_partHashArray[part];
@


1.223
log
@Extended INI interface to allow opening only in read-only mode (this way file isn't created when it didn't exist before) [Aw3].
@
text
@d752 1
a752 1
	result = result && hashset_ok && (GetED2KPartHashCount() == m_partHashArray.GetCount());
d1191 1
@


1.222
log
@Fixed source selection for p2p source exchange (for complete files: known NNS for remote source were sent to it).
@
text
@d1366 1
a1366 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.m_pPrefs->GetConfigDir());
d1368 1
a1368 1
	CIni ini(strFullPath);
@


1.221
log
@Don't precache pointers for better optimizations.
@
text
@d1179 1
a1179 1
	if (uiType >= ELEMENT_COUNT(s_apcSearchTypes))
d1271 1
a1271 1
		pbytePotentialClientPartStatus = pPotentialSource->GetPartStatus();
d1278 1
a1278 1
			pbyteForClientPartStatus = pForClient->GetPartStatus();
d2137 1
a2137 1
	if (uiPerm >= ELEMENT_COUNT(s_auResTbl))
@


1.220
log
@Formatting; Stricter pointer declaration.
@
text
@a1234 2
		pbyteForClientPartStatus = pForClient->GetPartStatus();
		pbytePotentialClientPartStatus = pPotentialSource->GetPartStatus();
d1271 1
d1278 1
@


1.219
log
@Reduced #include depedency.
@
text
@d330 1
a330 1
	//Nr. hashs: 0
d335 1
a335 1
	//Nr. hashs: 2
d342 1
a342 1
	//Nr. hashs: 2
d349 1
a349 1
	//Nr. hashs: 3
d357 1
a357 1
	//Nr. hashs: 4
d366 1
a366 1
	//Nr. hashs: 4
d373 1
a373 1
	//   File size       Data parts      ED2K parts      ED2K part hashs
d471 1
a471 1
//	after filesize(m_lFileSize) was defined we can get number of hashs
d1229 1
a1229 1
	byte			*pbyteForClientPartStatus, *pbytePotentialClientPartStatus;
@


1.218
log
@Added Source Exchange 2 support (adapted from original 0.48a).
@
text
@d22 1
a24 1
#include <sys/types.h>
@


1.217
log
@Updated Source Exchange Protocol to version 4 (ability to spread encryption capabilities);
Preparation to support Source Exchange 2 (0.48a).
@
text
@d1209 1
a1209 1
	bool		bValidSource, bIsSX2Packet = false;
d1211 12
a1222 1
	byteUsedVer = pForClient->GetSourceExchangeVersion();
@


1.216
log
@Function body was moved to the H-file.
@
text
@d1189 1
a1189 1
Packet* CKnownFile::CreateSrcInfoPacket(CUpDownClient *pForClient)
d1207 5
a1211 1
	uint16		uCount = 0;
d1214 1
a1214 1
	packetStream.Write(&uCount, 2);
d1217 1
a1217 2
	uint32			dwID, dwServerIP, dwRes, dwCurTime = ::GetTickCount();
	bool			bValidSource;
d1219 1
a1219 1
	uint16			uPort, uServerPort;
d1290 1
a1290 1
			if (pForClient->GetSourceExchangeVersion() >= 3)
d1300 2
a1301 2
			dwServerIP = pPotentialSource->GetServerIP();
			uServerPort = pPotentialSource->GetServerPort();
d1305 4
a1308 3
			packetStream.Write(&dwServerIP, 4);
			packetStream.Write(&uServerPort, 2);
			if (pForClient->GetSourceExchangeVersion() > 1)
d1310 12
a1321 1
			if (++uCount > 500)
d1326 1
a1326 1
	if (uCount == 0)
d1329 2
a1330 2
	packetStream.Seek(16, 0);
	packetStream.Write(&uCount, 2);
d1334 2
a1335 1
	pPacket->m_eOpcode = OP_ANSWERSOURCES;
@


1.215
log
@Fixed Shared Files List slow down while publishing a lot of files {Zom}.
@
text
@a2147 5
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFile::SetPublishedED2K(bool bVal)
{
	m_bPublishedED2K = bVal;
}
@


1.214
log
@Newly added stuff was renamed according to the original for easier reference.
@
text
@d310 1
a310 1
																				reinterpret_cast<LPARAM>(dynamic_cast<CKnownFile*>(this)) );
a2151 1
	g_App.m_pSharedFilesList->UpdateItem(this, false);
@


1.213
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d1288 2
a1289 2
				dwID = pPotentialSource->GetHybridUserID();
			else
a1290 1
			//	use the old ed2k user id convention for LowID sources on same server 
d1292 1
a1292 1
					dwID = pPotentialSource->GetHybridUserID();
@


1.212
log
@Formatting.
@
text
@d1287 10
a1296 1
			dwID = pPotentialSource->GetUserID();
@


1.211
log
@by SX don't spread a client use a hash that was identified for another client because he could be a hash stealer
@
text
@d1225 1
a1225 1
		if  (pForClient == pPotentialSource)
d1230 2
a1231 2
	//	Don't send a client use a hash that was identified for another client because he could be a hash stealer 
		if (pPotentialSource->m_pCredits != NULL 
@


1.210
log
@Fixed constant rehashing of files with some weird date {mamamia}.
@
text
@d1227 1
a1227 1
	//	Don't send a client to itself as a source (part 2)
a1228 7
		{
		//	Actually if function 'CClientList::AttachToAlreadyKnown()' is working properly, then we should never see this message
			AddDebugLogLine( RGB_BLUE_VIOLET_TXT _T("Found same client during SX c1=(%s,%s), c2=(%s,%s)"), 
							pPotentialSource->GetClientNameWithSoftware(),
							HashToString(pPotentialSource->GetUserHash()),
							pForClient->GetClientNameWithSoftware(),
							HashToString(pForClient->GetUserHash()) );
d1230 4
a1233 1
		}
@


1.209
log
@Don't republish a file on the server if only comment was changed in shared files list (republish only if file rating is different).
@
text
@a524 2
	struct _stat st;

d526 1
a526 5
	if (_tstat(strNameBuffer, &st) == 0)
	{
		m_timetLastWriteDate = st.st_mtime;
		AdjustNTFSDaylightFileTime(&m_timetLastWriteDate, strNameBuffer);
	}
@


1.208
log
@Configuration of default file permission {conman} [Aw3/DarkSoul].
@
text
@d1423 6
a1428 1
	CString strFullPath(g_App.m_pPrefs->GetConfigDir());
d1430 1
a1430 1
	strFullPath += _T("fileinfo.ini");
d1432 1
a1432 1
	CIni ini(strFullPath);
d1434 2
a1435 1
	ini.SetDefaultCategory(HashToString(m_fileHash));
d1437 1
a1437 2
	ini.SetInt(_T("Rate"), eNewRating);
	m_eRating = eNewRating;
d1439 6
a1444 1
	ini.SaveAndClose();
d1446 2
a1447 6
//	Republish a file on the server (if possible) to update server file rating
//	lugdunummaster: server handles the republishing of a file, taking into account
//	a change in the rating (but if an already rated file is republished without a rating,
//	no change is done on the rating - server keeps the previous rating for this file and client)
	if (eNewRating != PF_RATING_NONE)
		g_App.m_pSharedFilesList->RepublishFile(this, SRV_TCPFLG_TYPETAGINTEGER/*check feature support*/);
d1449 1
a1449 2
	CTypedPtrList<CPtrList, CUpDownClient*> srclist;
	g_App.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());
d1451 5
a1455 1
	CUpDownClient	*pClient;
d1457 2
a1458 4
	for (POSITION pos = srclist.GetHeadPosition(); pos != NULL;)
	{
		pClient = srclist.GetNext(pos);
		pClient->SetCommentDirty();
a1459 4

	if (IsPartFile())
		((CPartFile*)this)->SetHasRating(true);

@


1.207
log
@Fixed 64bit file size processing.
@
text
@d192 1
a192 1
	m_bytePermissions = PERM_ALL;
d834 2
a835 5
	if (m_bytePermissions != PERM_ALL)
	{
		tagWr.WriteToFile(FT_PERMISSIONS, m_bytePermissions, file);
		dwTagCnt++;
	}
@


1.206
log
@Large file size support preparations;
Fixed complete transfer calculation for part traffic;
Fixed part traffic chunk statistics reset;
Simplified small part ratio calculation, reduced threshold from 9961472 to partsize (9728000) for unification.
@
text
@d469 1
a469 1
	SetFileSize(static_cast<uint32>(qwFileSz));
@


1.205
log
@Added 64bit tag support.
@
text
@d405 1
a405 1
	m_dwLastBlkSz = (m_dwLastBlkSz != 0) ? m_dwLastBlkSz : EMBLOCKSIZE;
d408 1
a408 1
	if (qwFileSize < 9961472ui64)
d410 1
a410 1
		m_dblSizeRatio = 9961472.0 / static_cast<double>(qwFileSize);
d460 1
a460 1
	if (qwFileSz >= (ULONGLONG)0xFFFFFFFF)
d1510 2
a1511 3
	uint32 blocks=fileParent->GetBlockCount();
	uint32 fs=fileParent->GetFileSize();
	uint32	m = 0xFFFFFFFF;
d1515 1
a1515 1
	for(uint32 i=0; i<blocks; i++)
d1517 1
a1517 1
		if(blockTraffic[i]==0)
d1519 1
d1521 1
a1521 1
		uint32 s = ((fs - (i * EMBLOCKSIZE)) >= EMBLOCKSIZE) ? EMBLOCKSIZE : (fs % EMBLOCKSIZE);
d1523 2
a1524 5
		if(s)
		{
			uint32 f= blockTraffic[i] / s + ((blockTraffic[i] == s) ? 0 : 1);
			if(f<m) m=f;
		}
d1530 1
a1530 1
	for(uint32 i=0; i<blocks; i++)
d1532 1
a1532 1
		if(blockTraffic[i]==0)
d1534 1
d1536 1
a1536 1
		uint32 s = ((fs - (i * EMBLOCKSIZE)) >= EMBLOCKSIZE) ? EMBLOCKSIZE : (fs % EMBLOCKSIZE);
d1538 3
a1540 7
		if(s)
		{
			double f=(double)blockTraffic[i]/s;
			if (f > dMin)
				f = dMin;
			completeReleases+=f;
		}
d1543 1
a1543 1
	completeReleases/=blocks;
d1550 1
a1550 1
	if((partTraffic == NULL) || (part > fileParent->GetPartCount()) || (partTraffic[part] == 0))
d1554 5
a1558 3
	uint32	fs = fileParent->GetFileSize();
	uint32	startBlock=(part*PARTSIZE)/EMBLOCKSIZE;
	uint32	endBlock = ((fs - (part * PARTSIZE)) > PARTSIZE) ? (((part + 1) * PARTSIZE) / EMBLOCKSIZE) : (fileParent->GetBlockCount() - 1);
d1561 1
a1561 1
	uint32	m=0xFFFFFFFF;
d1563 1
a1563 1
	for(uint32 i=startBlock; i<=endBlock; i++)
d1565 1
a1565 1
		if(blockTraffic[i]==0)
d1567 1
d1569 1
a1569 1
		uint32 s = ((fs - (i * EMBLOCKSIZE)) >= EMBLOCKSIZE) ? EMBLOCKSIZE : (fs % EMBLOCKSIZE);
d1571 2
a1572 5
		if(s)
		{
			uint32 f = blockTraffic[i] / s + ((blockTraffic[i] == s) ? 0 : 1);
			if(f<m) m=f;
		}
d1577 1
a1577 1
	for(uint32 i=startBlock; i<=endBlock; i++)
d1579 1
a1579 1
		if(blockTraffic[i]==0)
d1581 1
d1583 4
a1586 9
		uint32 s = ((fs - (i * EMBLOCKSIZE)) >= EMBLOCKSIZE) ? EMBLOCKSIZE : (fs % EMBLOCKSIZE);

		if(s)
		{
			double f=(double)blockTraffic[i]/s;
			if (f > dMin)
				f = dMin;
			completePartReleases+=f;
		}
d1589 1
a1589 1
	return completePartReleases/(fileParent->GetPartSize(part)/EMBLOCKSIZE);
d1630 2
a1631 2
		blockTraffic[block]+=btg % EMBLOCKSIZE;
		blockTrafficSession[block]+=btg % EMBLOCKSIZE;
d1633 1
a1633 1
		btg-=EMBLOCKSIZE;
d1764 1
a1764 1
			bftb += EMBLOCKSIZE;
d1768 1
a1768 1
		if (bftb != EMBLOCKSIZE)
a1815 2
	EMULE_TRY

a1822 4

	EMULE_CATCH

	return 0;
a1826 2
	EMULE_TRY

a1833 4

	EMULE_CATCH

	return 0;
d1843 1
a1843 1
	return ((dwBlock + 1) < GetBlockCount()) ? EMBLOCKSIZE : m_dwLastBlkSz;
d1894 7
a1900 7
	uint32	blocks=fileParent->GetBlockCount();
	uint32	blockStart=(part*PARTSIZE)/EMBLOCKSIZE;
	uint32	blockEnd=min((((uint32)part+1)*PARTSIZE)/EMBLOCKSIZE+1, blocks-1);
	double	percentStart=(static_cast<double>((part*PARTSIZE)%EMBLOCKSIZE)/EMBLOCKSIZE);
	double	percentEnd=0.0;
	if(blockEnd!=blocks)
		percentEnd=1-(static_cast<double>(((part+1)*PARTSIZE)%EMBLOCKSIZE)/EMBLOCKSIZE);
d1904 5
a1908 5
		partTraffic[part]=0;
		blockTraffic[blockStart]*=percentStart;
		blockTraffic[blockEnd]*=percentEnd;
		for(uint32 block=blockStart+1; block<blockEnd; block++)
			blockTraffic[block]=0;
d1911 5
a1915 5
	partTrafficSession[part]=0;
	blockTrafficSession[blockStart]*=percentStart;
	blockTrafficSession[blockEnd]*=percentEnd;
	for(uint32 block=blockStart+1; block<blockEnd; block++)
		blockTrafficSession[block]=0;
@


1.204
log
@Simplified part traffic code taking in account that we upload only within one chunk.
@
text
@d670 2
a671 2
				if (newtag->IsInt())
					SetFileSize(newtag->GetIntValue());
d698 1
a698 1
					m_bytePriority = newtag->GetIntValue();
d718 1
a718 1
					m_bytePermissions = newtag->GetIntValue();
d810 1
a810 1
	tagWr.WriteToFile(FT_FILESIZE, GetFileSize(), file);		// (FT_FILESIZE:int) file size (bytes)
@


1.203
log
@Large file size support preparations;
Some optimization to compensate 64bit arithmetics.
@
text
@d1615 1
d1627 1
@


1.202
log
@Large file size support preparations.
@
text
@d1754 1
a1754 1
uint32 CKnownFile::GetTrafficBlock(uint32 start, uint32 end, bool session)
d1756 1
a1756 1
	EMULE_TRY
d1758 1
a1758 1
	if(statistic.blockTraffic==NULL)
d1761 2
a1762 2
	if(start > GetFileSize()) return 0;
	if(end > GetFileSize()) end=GetFileSize();
d1764 4
a1767 5
	uint32	*data;
	if(session)
		data=statistic.blockTrafficSession;
	else
		data=statistic.blockTraffic;
d1769 1
a1769 5
	uint32	block=start/EMBLOCKSIZE;
	uint32	pos=start;
	sint32	bftb;
	uint32	t=0;
	while(pos < end)
d1771 2
a1772 2
		if(end-pos > end % EMBLOCKSIZE)
			bftb=EMBLOCKSIZE;
d1774 1
a1774 2
			bftb=end % EMBLOCKSIZE;
		bftb-=pos % EMBLOCKSIZE;
d1776 2
a1777 2
		if(bftb != EMBLOCKSIZE)
			t+=data[block] * (double)bftb/GetBlockSize(block);
d1779 3
a1781 4
			t+=data[block];

		pos+=bftb;

a1785 4

	EMULE_CATCH

	return 0;
d1788 1
a1788 1
uint32 CKnownFile::GetTrafficPart(uint32 start, uint32 end, bool session)
d1790 1
a1790 1
	EMULE_TRY
d1792 1
a1792 1
	if(statistic.partTraffic==NULL)
d1795 2
a1796 2
	if(start > GetFileSize()) return 0;
	if(end > GetFileSize()) end=GetFileSize();
d1798 4
a1801 5
	uint32	*data;
	if(session)
		data=statistic.partTrafficSession;
	else
		data=statistic.partTraffic;
d1803 1
a1803 5
	uint32	part=start/PARTSIZE;
	uint32	pos=start;
	sint32	bftp;
	uint32	t=0;
	while(pos < end)
d1805 2
a1806 2
		if(end-pos > end % PARTSIZE)
			bftp=PARTSIZE;
d1808 1
a1808 2
			bftp=end % PARTSIZE;
		bftp-=pos % PARTSIZE;
d1810 2
a1811 2
		if(bftp != PARTSZ32)
			t += data[part] * (double)bftp / GetPartSize(part);
d1813 4
a1816 4
			t += data[part];

		pos += bftp;
		part++;
a1819 4

	EMULE_CATCH

	return 0;
@


1.201
log
@Variable casting.
@
text
@d2091 1
a2091 1
void CKnownFile::AddSentBlock(CUpDownClient *client, uint32 start_offset, uint32 togo)
d2094 1
a2094 1
	m_Jumpstarter->AddSentBlock(client, start_offset, togo);
@


1.200
log
@Large file size support preparations.
@
text
@d394 1
a394 1
	m_uPartCount = m_dwED2KPartHashCount + ((m_dwLastPartSz != 0) ? 1 : 0);
@


1.199
log
@Large file size support preparations.
@
text
@d60 1
a60 1
	strLink.Format( _T("ed2k://|file|%s|%u|%s|/"),
d66 1
a66 2
					GetFileSize(),
					HashToString(GetFileHash()) );
d489 1
a489 1
				CreateHashFromFile(&file, (GetFileSize() - PARTSIZE*i), pNewPartHash);
d519 1
a519 1
		CreateHashFromFile(&file, GetFileSize(), fileHash);
@


1.198
log
@Large file size support preparations;
Removed function reading file in a circular way as such possibility was removed long time ago.
@
text
@d117 1
a117 1
	fileParent	=	NULL;
d321 1
a321 1
void CKnownFile::SetFileSize(uint32 dwFileSize)
d323 1
a323 1
	CAbstractFile::SetFileSize(dwFileSize);
d382 1
a382 1
	if (dwFileSize == 0)
d393 3
a395 2
	m_dwLastPartSz = dwFileSize % PARTSIZE;
	m_uPartCount = (dwFileSize / PARTSIZE) + ((m_dwLastPartSz != 0) ? 1 : 0);
d398 1
a398 1
	m_dwED2KPartCount = dwFileSize / PARTSIZE + 1;
a399 1
	m_dwED2KPartHashCount = dwFileSize / PARTSIZE;
d404 2
a405 2
	m_dwLastBlkSz = dwFileSize % EMBLOCKSIZE;
	m_dwBlockCount = (dwFileSize / EMBLOCKSIZE) + ((m_dwLastBlkSz != 0) ? 1 : 0);
d409 1
a409 1
	if (dwFileSize > 0 && dwFileSize < 9961472)
d411 1
a411 1
		m_dblSizeRatio = 9961472.0 / static_cast<double>(dwFileSize);
a412 1
		{
a413 1
		}
d1199 1
a1199 1
Packet*	CKnownFile::CreateSrcInfoPacket(CUpDownClient *pForClient)
d1603 1
a1603 1
void CFileStatistic::AddTraffic(uint32 start, uint32 bytes)
d1609 1
a1609 3
//	Start block
	uint32	part=start/PARTSIZE;
	sint32	btg=(sint32)bytes;
d1611 5
a1615 5
	uint32 p1=min((part+1)*PARTSIZE-start, bytes);
	partTraffic[part]+=p1;
	partTrafficSession[part]+=p1;
	partAccepted[part]++;
	partAcceptedSession[part]++;
d1617 1
a1617 1
	part++;
d1620 5
a1624 5
		partTraffic[part] += btg % PARTSZ32;
		partTrafficSession[part] += btg % PARTSZ32;
		partAccepted[part]++;
		partAcceptedSession[part]++;
		part++;
d1629 2
a1630 2
	uint32	block=start/EMBLOCKSIZE;
	btg=(sint32)bytes;
d1632 1
a1632 1
	uint32 b1=min((block+1)*EMBLOCKSIZE-start, bytes);
d1962 1
a1962 1
uint32	CFileStatistic::GetPartAccepted(uint16 part, bool session) const
d2018 1
a2018 1
bool	CKnownFile::HasHiddenParts()
d2168 1
a2168 1
	
@


1.197
log
@Full path only for hashing log message of a partfile;
Recommitment after repository crash -- Fixed file hashing in case of file read error {Fuxie - DK}.
@
text
@a2069 1
// obaldin
d2073 1
a2073 1
     return CJumpstarter::IsJsCompleteForFile(this);
d2082 1
a2082 1
    if(!enabled && m_Jumpstarter)
d2084 4
a2087 4
        m_Jumpstarter->Disable();
        delete m_Jumpstarter;
        m_Jumpstarter = NULL;
    }
d2090 3
a2092 3
        CJumpstarter::EnableForFile(this);
        m_Jumpstarter = new CJumpstarter(this);
    }
d2096 1
a2096 1
void CKnownFile::AddSentBlock(CUpDownClient* client,uint32 start_offset, uint32 togo)
d2099 1
a2099 1
    m_Jumpstarter->AddSentBlock(client, start_offset, togo);
d2103 1
a2103 1
void CKnownFile::WriteJumpstartPartStatus(CUpDownClient* client, CMemFile* data)
d2106 1
a2106 1
    m_Jumpstarter->WriteJumpstartPartStatus(client, data);
d2113 1
a2113 1
    return (!m_Jumpstarter) || m_Jumpstarter->AllowChunkForClient(partNo, client);
d2119 1
a2119 1
//	ReadFileForUpload() opens known file and read information in circular way.
d2121 1
a2121 1
//			dwOffset      - file offset to start reading from;
d2126 1
a2126 1
int CKnownFile::ReadFileForUpload(uint32 dwOffset, uint32 dwBytesToRead, byte *pbyteBuffer)
d2128 17
a2144 1
	return (::CircularFileRead(m_strFilePath, dwOffset, dwBytesToRead, pbyteBuffer)) ? 0 : -1;
@


1.196
log
@More details for the log line.
@
text
@a400 1
	{
a401 1
	}
d440 1
a440 1
bool CKnownFile::CreateFromFile(const CString &strDirectory,const CString &strFileName)
a443 1
//
d452 2
a453 2
	SetPath(strDirectory);
	strNameBuffer.Format(_T("%s\\%s"), strDirectory, strFileName);
d469 1
a469 1
	AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("File %s is being hashed"), strNameBuffer);
a511 1
		{
d513 1
a513 1
		}
d519 3
a521 3
		//eklmn: hash creation was splitted to 2 steps, cause fuction CreateHashFromFile()
		// needs some time to finish a hashing process . Thefore to prevent possible
		// interference we create a local instance of file hash & then copy it into global
a524 1
	// TODO: Add filetags
a863 2
	EMULE_TRY

a944 2

	EMULE_CATCH
@


1.195
log
@Large file size support preparations.
@
text
@d472 1
a472 1
	AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("File %s is being hashed"), strFileName/*m_strFileName*/);
@


1.194
log
@Republish a file on file rating change to update server statistics.
@
text
@d395 1
a395 1
	m_dwLastPartSz = (m_dwLastPartSz != 0) ? m_dwLastPartSz : PARTSIZE;
d494 1
a494 2
			if (i == dwHashCount -1)
			{
a495 1
			}
d497 1
a497 3
			{
				CreateHashFromFile(&file, PARTSIZE, pNewPartHash);
			}
d1631 1
a1631 1
	while(btg>0)
d1633 2
a1634 2
		partTraffic[part]+=btg % PARTSIZE;
		partTrafficSession[part]+=btg % PARTSIZE;
d1638 1
a1638 1
		btg-=PARTSIZE;
d1841 2
a1842 2
		if(bftp != PARTSIZE)
			t+=data[part] * (double)bftp/GetPartSize(part);
d1844 1
a1844 3
			t+=data[part];

		pos+=bftp;
d1846 1
d1893 1
a1893 1
	return ((dwPart + 1) < GetPartCount()) ? PARTSIZE : m_dwLastPartSz;
@


1.193
log
@%i -> %u while preparing a link with sources.
@
text
@d1442 1
a1442 1
	CString strFullPath;
d1444 1
a1444 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.m_pPrefs->GetConfigDir());
d1450 1
a1450 1
	ini.SetInt (_T("Rate"), eNewRating);
d1455 7
d1467 1
a1467 1
	for (POSITION pos = srclist.GetHeadPosition(); pos != NULL; )
@


1.192
log
@Use base class instead of safe one; Formatting.
@
text
@d81 1
a81 1
		strLink.AppendFormat( _T("|sources,%i.%i.%i.%i:%i|/"),
@


1.191
log
@Improved string processing.
@
text
@d1231 2
a1232 2
	CSafeMemFile	packetStream(1024);
	uint16			uCount = 0;
d1272 1
a1272 1
		//	Don't send a LowID client to LowID as they will not able to connect
d1297 1
a1297 1
			// Don't send the clients that supports the upload parts statuses & have different number of the parts
a1315 1
			uCount++;
d1327 1
a1327 1
			if (uCount > 500)
@


1.190
log
@Define max comment length; Check comment length on loading.
@
text
@d1400 1
a1400 1
void CKnownFile::SetFileComment(CString strNewComment)
@


1.189
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1366 1
a1366 1
	m_strComment = ini.GetString(_T("Comment"),_T(""));
d1407 1
a1407 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.m_pPrefs->GetConfigDir());
d1413 1
a1413 1
	ini.SetString (_T("Comment"), strNewComment);
@


1.188
log
@renamed 3 variables
@
text
@d86 1
a86 1
								g_App.g_pPrefs->GetListenPort() );
d190 1
a190 1
	m_bAutoPriority = g_App.g_pPrefs->IsUAPEnabled();
d1361 1
a1361 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.g_pPrefs->GetConfigDir());
d1383 1
a1383 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.g_pPrefs->GetConfigDir());
d1407 1
a1407 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.g_pPrefs->GetConfigDir());
d1445 1
a1445 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_App.g_pPrefs->GetConfigDir());
@


1.187
log
@Unified processing of part and temporary file names.
@
text
@d62 1
a62 1
					g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
d77 1
a77 1
	if (g_eMuleApp.m_pServerConnect->IsConnected() && !g_eMuleApp.m_pServerConnect->IsLowID())
d79 1
a79 1
		uint32			dwID = g_eMuleApp.m_pServerConnect->GetClientID();
d86 1
a86 1
								g_eMuleApp.m_pGlobPrefs->GetListenPort() );
d97 1
a97 1
		g_eMuleApp.StripInvalidFilenameChars(GetFileName(), true) 
d143 2
a144 2
	g_eMuleApp.m_pKnownFilesList->m_iNumRequested++;
	if (::IsWindow(g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_hWnd))	//fix crash at exit [TwoBottle Mod]
d159 1
a159 1
	g_eMuleApp.m_pKnownFilesList->m_iNumAccepted++;
d173 1
a173 1
	g_eMuleApp.m_pKnownFilesList->m_iNumTransferred += bytes;
d190 1
a190 1
	m_bAutoPriority = g_eMuleApp.m_pGlobPrefs->IsUAPEnabled();
d250 1
a250 1
		g_eMuleApp.m_pClientList->GetClientListByFileID(&clientuploadlist, GetFileHash());
d307 1
a307 1
	if (g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.m_hWnd != NULL)
d309 2
a310 2
		g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.PostMessage( WM_SFL_UPDATEITEM,
																				static_cast<WPARAM>(g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.IsWindowVisible()),
d503 1
a503 1
			if (!g_eMuleApp.m_pdlgEmule->IsRunning())	// in case of shutdown while still hashing
d978 1
a978 1
	if (g_eMuleApp.m_pKnownFilesList->GetTotalRequested()==0)
d985 2
a986 2
	dblRatio = (static_cast<double>(statistic.GetRequests())) / (static_cast<double>(g_eMuleApp.m_pKnownFilesList->GetTotalRequested()));
	dblRatio = -4.0 * log10(static_cast<double>(g_eMuleApp.m_pSharedFilesList->GetCount())) * dblRatio;
d1081 1
a1081 1
		if (IsPartFile() && g_eMuleApp.m_pDownloadQueue && !IsPaused())
d1361 1
a1361 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d1383 1
a1383 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d1407 1
a1407 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d1420 1
a1420 1
	g_eMuleApp.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());
d1445 1
a1445 1
	strFullPath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d1457 1
a1457 1
	g_eMuleApp.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());
d1719 1
a1719 1
		g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d1740 1
a1740 1
		g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d2193 1
a2193 1
	g_eMuleApp.m_pSharedFilesList->UpdateItem(this, false);
@


1.186
log
@fixed source SX. thanks glaskrug
@
text
@d2137 1
a2137 5
	CString	strFullName;

	strFullName.Format(_T("%s\\%s"), m_strKnownFileDirectory, m_strFileName);

	return (::CircularFileRead(strFullName, dwOffset, dwBytesToRead, pbyteBuffer)) ? 0 : -1;
@


1.185
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1276 1
a1276 1
			if (pPotentialSource->GetServerIP() != 0 || pPotentialSource->GetServerPort() != 0)
d1280 1
a1280 1
				&& pPotentialSource->GetServerPort() != pForClient->GetServerPort() )
@


1.184
log
@fixed indefication of the client IP identiifcatio has more higher priority as Userhash.
@
text
@d1238 1
a1238 1
	uint32 dwCurTime = ::GetTickCount();
d1240 2
a1241 7
	byte		   *pbyteForClientPartStatus;
	byte		   *pbytePotentialClientPartStatus;

	uint32			dwID;
	uint16			uPort;
	uint32			dwServerIP;
	uint16			uServerPort;
d1253 1
a1253 1
		if (pForClient->Compare(pPotentialSource) != 0)
@


1.183
log
@Formatting.
@
text
@d1258 1
a1258 1
		if (pForClient->Compare(pPotentialSource))
@


1.182
log
@improved LowID check by SX
@
text
@d1254 1
a1254 1
	//	Don't send a client to himself as a source (part 1)
d1257 1
a1257 1
	//	Don't send a client to himself as a source (part 2)
d1260 2
a1261 2
		// actually if function 'CClientList::AttachToAlreadyKnown()' is working properly, then we should never see this message
			AddDebugLogLine(RGB_BLUE_VIOLET + _T("Found same client during SX c1=('%s', %s), c2=('%s',%s)"), 
d1265 1
a1265 2
							HashToString(pForClient->GetUserHash())
							);
d1274 2
a1275 2
	//	check LowID status
		if ( pPotentialSource->HasLowID())
d1277 1
a1277 1
		//	Don't send a LowID client to LowID they are will not able to connect
d1280 1
a1280 1
		//	Don't send a LowID client if server IP & server port are unknow
d1283 2
a1284 2
		//	Don't send a LowID client to HighID if client on different server
			if (pPotentialSource->GetServerIP() != pForClient->GetServerIP()
@


1.181
log
@indefication of the client by connection
@
text
@d1275 14
a1288 5
	//	Only send sources with LowID that are in same sever that client who is requesting sources
		if (pPotentialSource->HasLowID() 
			&&  (pPotentialSource->GetServerIP() != pForClient->GetServerIP() 
				|| pPotentialSource->GetServerPort() != pForClient->GetServerPort() ) )
			continue;
@


1.180
log
@File type as integer for the server to reduce traffic {lugdunummaster};
Separate GetFileTypeString for search type;
Faster sorting compare for file type columns.
@
text
@d1254 2
a1255 2
	//	Don't send a client to himself as a source
		if  (pForClient == pPotentialSource  || pForClient->Compare(pPotentialSource))
d1257 12
@


1.179
log
@Renaming.
@
text
@d42 12
d1154 35
a1188 1
CString CAbstractFile::GetFileTypeString(bool bLocalized)
d1191 1
a1191 12
	static const uint16 s_auResID[ED2KFT_COUNT] =
	{
		IDS_SEARCH_ANY,		// ED2KFT_ANY
		IDS_SEARCH_AUDIO,	// ED2KFT_AUDIO
		IDS_SEARCH_VIDEO,	// ED2KFT_VIDEO
		IDS_SEARCH_PICS,	// ED2KFT_IMAGE
		IDS_SEARCH_PRG,		// ED2KFT_PROGRAM
		IDS_SEARCH_DOC,		// ED2KFT_DOCUMENT
		IDS_SEARCH_ARC,		// ED2KFT_ARCHIVE
		IDS_SEARCH_CDIMG	// ED2KFT_CDIMAGE
	};
	static const char *const s_apcSearchTypes[ED2KFT_COUNT] =
d1197 2
a1198 4
		"Pro",		// ED2KFT_PROGRAM
		"Doc",		// ED2KFT_DOCUMENT
		"Pro",		// ED2KFT_ARCHIVE
		"Pro"		// ED2KFT_CDIMAGE
d1202 3
a1204 1
	if (uiType >= ED2KFT_COUNT)
d1206 1
d1208 1
a1208 4
	if (bLocalized)
		return GetResString(s_auResID[uiType]);
	else
		return s_apcSearchTypes[uiType];
d1210 1
a1210 1
	return _T("");
@


1.178
log
@Fixed upload autopriority calculation for paused/stopped files {KuSh}.
@
text
@d207 1
a207 1
	CSingleLock Lock(&m_mutexHashList,TRUE);
d503 1
a503 1
		CSingleLock Lock(&m_mutexHashList,TRUE);
d618 1
a618 1
			CSingleLock Lock(&m_mutexHashList,TRUE);
d784 1
a784 1
	CSingleLock	Lock(&m_mutexHashList,TRUE);
@


1.177
log
@Improved files publishing algorithm on the server.
@
text
@d232 2
a233 1
	if (!IsPartFile() && (((dwCurTick = ::GetTickCount()) - m_nCompleteSourcesTime) >= 2*60*1000))	// 2 min.
d1069 1
a1069 1
		if (IsPartFile() && g_eMuleApp.m_pDownloadQueue && !IsPaused() )
a1077 1
				{
a1078 1
				}
a1079 1
				{
a1080 1
				}
a1081 1
				{
a1082 1
				}
a1083 1
				{
a1084 2
				}

d1089 1
a1089 1
			int iCompleteSources = GetCompleteSourcesCount();
a1091 1
			{
a1092 1
			}
a1093 1
			{
a1094 1
			}
a1095 1
			{
a1096 1
			}
a1097 1
			{
a1098 1
			}
@


1.176
log
@Faster part traffic processing; Removed meaningless checks and castings.
@
text
@d198 1
d2161 6
a2166 1

@


1.175
log
@Fixed part file renaming {dirkmill};
Don't create full name for non-existent known file to save some memory.
@
text
@a1485 2
	EMULE_TRY

d1489 2
a1492 2
	uint32 m=0xFFFFFFFF;
	completeReleases=0;
d1502 1
a1502 1
			uint32 f=(uint32)(double)blockTraffic[i]/s+(blockTraffic[i]==s?0:1);
d1508 2
d1520 2
a1521 1
			if(f>m) f=m;
a1526 2

	EMULE_CATCH
a1531 2
	EMULE_TRY

d1533 1
a1533 1
	if(partTraffic==NULL || part<0 || part>fileParent->GetPartCount() || partTraffic[part]==0)
d1543 1
a1543 1
	double	completePartReleases=0;
d1553 1
a1553 1
			uint32 f=(uint32)(double)blockTraffic[i]/s+(blockTraffic[i]==s?0:1);
d1559 1
d1570 2
a1571 1
			if(f>m) f=m;
a1576 4

	EMULE_CATCH

	return 0;
@


1.174
log
@A minor correction for the previous commitment.
@
text
@a408 1

d416 7
a422 1
	m_strFilePath.Format(_T("%s\\%s"), m_strKnownFileDirectory, m_strFileName);	//SetFilePath()
a431 2
//	TODO: Errorhandling

a433 1
//
a434 1
//
d458 1
a458 1
	AddDebugLogLine(RGB_LOG_DIMMED + _T("File %s is being hashed"), strFileName/*m_strFileName*/);
@


1.173
log
@new SX: removed debug lines, redundancy...
@
text
@d1220 1
a1220 1
	bool 		bValidSource = true;
d1253 1
d1258 1
a1258 1
			if ( pPotentialSource->GetAvailUpPartCount() == 0 && pForClient->GetUpPartCount() > 1)
d1261 1
a1261 1
			if  (pbyteForClientPartStatus != NULL)
d1264 1
a1264 1
				if ( pForClient->GetUpPartCount() != pPotentialSource->GetUpPartCount())
d1293 1
a1293 1
			    packetStream.Write(pPotentialSource->GetUserHash(),16);
a1299 1
	{
a1300 1
	}
@


1.172
log
@Erasing own comment from shared files also removed rating display in download list.
@
text
@d1220 1
a1220 1
	bool 			bNeededPart;
a1227 6
	uint16 uUnstable = 0;
	uint16 uOffline = 0;
	uint16 uLowID = 0;
	uint16 uNoParts = 0;
	uint16 uLAN = 0;
	uint16 uPartDiff = 0;
d1240 1
a1240 3
		{
			uUnstable++; continue;
		}
d1243 1
a1243 3
		{
			uOffline++; continue;
		}
d1248 1
a1248 3
		{
			uLowID++; continue;
		}
d1251 3
a1253 3
		{
			uLAN++; continue;
		}
d1258 3
d1262 7
a1268 19
				uNoParts++; continue;
			}
		//	Don't send the clients that supports the upload parts statuses & have different number of the parts
			if  (pbyteForClientPartStatus != NULL 
				&& pForClient->GetUpPartCount() != pPotentialSource->GetUpPartCount())
			{
				uPartDiff++; continue;
			}
		}

		bNeededPart = false;

	// Both clients support part statuses so we try to find needed clients
		if (!md4cmp(pPotentialSource->m_reqFileHash, GetFileHash()) 
			&& pbyteForClientPartStatus != NULL && pbytePotentialClientPartStatus != NULL)
		{
			for (uint32 i = 0; i < pForClient->GetUpPartCount(); i++)
			{
				if(pbytePotentialClientPartStatus[i] && !pbyteForClientPartStatus[i])
d1270 5
a1274 2
					bNeededPart = true;
					break;
a1277 3
	// If not we give a sources with at least one part (for files that have more than one part)
		else
			bNeededPart = true;
d1279 1
a1279 1
		if (bNeededPart)
a1299 10
		AddDebugLogLine( RGB_BROWN + _T("No valid sources to exchange (%u: %u,%u,%u,%u,%u,%u) with a client '%s' (%s), file: %s"),
											SourceList.size(),
											uUnstable,
											uOffline,
											uLowID,
											uNoParts,
											uLAN,
											uPartDiff,
											pForClient->GetUserName(), pForClient->GetClientNameAndVersionString(),
											GetFileName());
a1311 6
	AddDebugLogLine( RGB_BROWN_TXT _T("Sent a source packet with %u sources to client '%s' (%s), file: %s"),
					uCount,
					pForClient->GetUserName(),
					pForClient->GetClientNameAndVersionString(),
					GetFileName());

@


1.171
log
@Removed importing of previous file statistics (< v1.1c).
@
text
@d1394 1
a1394 1
	m_strComment = _T("");
d1398 1
a1398 4
	{
		((CPartFile*)this)->SetHasComment(false);
		((CPartFile*)this)->SetHasRating(false);
	}
@


1.170
log
@Grammar corrections.
@
text
@a691 3
#if 1
			case 0x13:	//previously used value left in v1.1c for smooth upgrade, must be removed in v1.1d
#endif
@


1.169
log
@some fixes (sometimes it's good to write explanation posts)
@
text
@d1204 1
a1204 1
// note that at same time the banned clients will be sended to the normal clients, which can decide how to handle those banned sources 
d1346 1
a1346 1
	AddDebugLogLine( RGB_BROWN + _T("Sended a source packet with %u sources to client '%s' (%s), file: %s"),
@


1.168
log
@new source exchange system
@
text
@a1263 5
	//	Don't send clients that have no parts available
		if (pbytePotentialClientPartStatus != NULL && pPotentialSource->GetAvailUpPartCount() == 0 && pForClient->GetUpPartCount() > 1)
		{
			uNoParts++; continue;
		}
d1269 9
a1277 3
	//	Don't send the clients that supports the upload parts statuses & have different number of the parts
		if  (pbyteForClientPartStatus != NULL 
				&& pbytePotentialClientPartStatus != NULL 
d1279 3
a1281 2
		{
			uPartDiff++; continue;
d1286 3
a1288 2
	//	Both clients support part statuses so we try to find needed clients
		if (pbyteForClientPartStatus != NULL && pbytePotentialClientPartStatus != NULL)
d1299 1
a1299 1
	//	If not we give a sources with at least one part (for files that have more than one part)
@


1.167
log
@Removed unused code called "offered files to server".
@
text
@d198 2
d219 2
d1203 10
a1212 1
	if (g_eMuleApp.m_pUploadQueue->GetWaitingUserCount() == 0)
d1222 1
d1231 6
d1238 1
a1238 1
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
d1240 3
a1242 1
		pPotentialSource = g_eMuleApp.m_pUploadQueue->GetNext(pos);
d1245 12
d1258 6
d1265 4
d1270 11
a1280 9
		if ( md4cmp(pPotentialSource->m_reqFileHash, pForClient->m_reqFileHash) != 0
				|| pForClient == pPotentialSource || pForClient->Compare(pPotentialSource)
				|| ( pPotentialSource->HasLowID()
					&& ( pPotentialSource->GetServerIP() != pForClient->GetServerIP()
						|| pPotentialSource->GetServerPort() != pForClient->GetServerPort() ) )
				|| (pPotentialSource->GetAvailUpPartCount() == 0 && pForClient->GetUpPartCount() > 1)
				|| pPotentialSource->IsOnLAN()
				|| pForClient->GetUpPartCount() != pPotentialSource->GetUpPartCount() )
			continue;
a1283 4
	//	Only send source which have needed parts for this client if possible
		pbyteForClientPartStatus = pForClient->GetPartStatus();
		pbytePotentialClientPartStatus = pPotentialSource->GetPartStatus();

d1320 11
d1332 1
d1343 6
d2175 31
@


1.166
log
@Fixed weird issues caused by file renaming after completion (within current session) {DopeFish}.
@
text
@a194 2
	m_bOfferedToServer= true;

a195 1

a196 1

@


1.165
log
@More compatible way to save part file statistics: requests, accepted requests, transferred data
(saved in .part.met file like in official, before it was in .part.stats);
Save high dword of part and known file 'transferred data' statistics to .met files only
if it contains something (to reduce known.met and .part.met file sizes).
@
text
@d416 2
@


1.164
log
@Changed tag interface to avoid memory leaks which could be possible with
new tag object structure;
Removed unrequired array operations; Reduced number of get time calls.
@
text
@d802 1
a802 1
	uint32	dwTagCnt = 0;
d813 6
a818 2
		tagWr.WriteToFile(FT_ATTRANSFERREDHI, static_cast<uint32>(statistic.alltimetransferred >> 32), file);
		dwTagCnt += 2;
a1945 9
//--- xrmb:keepPartFileStats ---
void CFileStatistic::AddAll(uint32 _alltimerequested, uint32 _alltimeaccepted, uint64 _alltimetransferred)
{
	alltimerequested	+= _alltimerequested;
	alltimeaccepted		+= _alltimeaccepted;
	alltimetransferred	+= _alltimetransferred;
}
//--- :xrmb ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.163
log
@Minor changes related to tag processing.
@
text
@d172 1
a172 2
CKnownFile::CKnownFile() :
	m_strComment(_T(""))
a190 3
	m_partHashArray.RemoveAll();
	m_tagArray.RemoveAll();

d221 1
a221 1
    EMULE_CATCH
d228 2
d231 1
a231 1
	if ((!this->IsPartFile()) && ((::GetTickCount() - m_nCompleteSourcesTime) >= 2*60*1000))	// 2 min.
d242 1
a242 1
			if ((cur_count) && ((::GetTickCount() - cur_src->GetUpCompleteSourcesTime()) < 30*60*1000))	// 30 min.
a244 1
		count.FreeExtra();
d281 1
a281 1
		m_nCompleteSourcesTime= ::GetTickCount();
d649 1
a649 1
		CTag		*newtag = new CTag(file);
d651 1
@


1.162
log
@Several file tag codes changed to be more compatible (UL/DL priorities and category);
Don't save some tags with zero values to known.met file;
Changed writing method to known.met;
Delete FT_PARTFILENAME tags found in known.met on its load
(the tag's used to keep part file name in .part.met if a file is in known.met it's already complete);
Smarter reading of FT_ATTRANSFERRED from known.met
(now it can be anywhere, not only before high counter part as before);
Check possible values during parameters loading from known.met and .part.met.
@
text
@d652 1
a652 1
		CTag		*newtag = new CFileTag(file);
@


1.161
log
@Minor tag parsing improvement.
@
text
@a93 2
	EMULE_TRY

a105 2

	EMULE_CATCH
d182 1
a182 1
	m_iPermissions = PERM_ALL;
d198 1
a198 1
    m_Jumpstarter = NULL;
d652 1
a652 1
		CFileTag		*newtag = new CFileTag(file);
d657 7
a663 2
			{
				SetFileName(newtag->GetStringValue());
d665 1
a665 1
			}
d667 2
a668 2
			{
				SetFileSize(newtag->GetIntValue());
d670 1
a670 1
			}
d672 2
a673 2
			{
				statistic.alltimetransferred = newtag->GetIntValue();
d675 1
a675 1
			}
d677 4
a680 7
			{
				uint32		dwHigh,dwLow;

				dwLow = statistic.alltimetransferred;
				dwHigh = newtag->GetIntValue();

				uint64		qwHigh;
a681 5
				qwHigh = dwHigh;
				qwHigh <<= 32;
				statistic.alltimetransferred = dwLow+qwHigh;
				break;
			}
d683 2
a684 2
			{
				statistic.alltimerequested = newtag->GetIntValue();
d686 4
a689 4
			}
 			case FT_ATACCEPTED:							// (FT_ATACCEPTED:int) all time accepted
			{
				statistic.alltimeaccepted = newtag->GetIntValue();
d691 6
a696 5
			}
			case FT_PRIORITY:							// (FT_PRIORITY:int) upload priority
			{
				m_bytePriority = newtag->GetIntValue();
				if (m_bytePriority == PR_AUTO)
d698 15
a712 6
					SetAutoULPriority(true);
					SetULPriority(PR_RELEASE);			//m_iPriority = PR_RELEASE;
				}
				else
				{
					SetAutoULPriority(false);
d715 1
a715 1
			}
d717 5
a721 2
			{
				m_iPermissions = newtag->GetIntValue();
d723 1
a723 1
			}
d781 1
a781 1
bool CKnownFile::WriteToFile(FILE* file)
d783 3
a785 1
	long lFilePointerPosition = ftell(file);	// remember file position
d787 1
a787 1
	EMULE_TRY
d789 2
a790 1
	CSingleLock		Lock(&m_mutexHashList,TRUE);
d792 3
a794 1
	const uint16	uNumParts = m_partHashArray.GetCount();
d796 3
a798 6
//	if number of hash sets is not equal 0, then check if hash exist (allocated in the memory)
//	& return with FALSE to avoid the file corruption
	if (uNumParts != 0 && m_pPartsHashSet == NULL)
	{
			return false;
	}
d800 1
a800 2
//	write a time
	fwrite(&m_timetLastWriteDate,4,1,file);		// <DATE:time_t> last write date/time
d802 3
a804 2
//	hashset
	fwrite(&m_fileHash,16,1,file);				// <HASH>
d806 1
a806 2
//	number of hash
	fwrite(&uNumParts,2,1,file);				// <count:WORD> number of parts
d808 11
a818 18
//	save the hash set
	fwrite(m_pPartsHashSet, (16*uNumParts),  1 , file);	// <HASH>[count] part hashes

	Lock.Unlock();

	//tags
	const int iFixedTags = 8;
	uint32 tagcount = iFixedTags;
	// Float meta tags are currently not written. All older eMule versions < 0.28a have
	// a bug in the meta tag reading+writing code. To achive maximum backward
	// compatibility for met files with older eMule versions we just don't write float
	// tags. This is OK, because we (eMule) do not use float tags. The only float tags
	// we may have to handle is the '# Sent' tag from the Hybrid, which is pretty
	// useless but may be received from us via the servers.
	//
	// The code for writing the float tags SHOULD BE ENABLED in SOME MONTHS (after most
	// people are using the newer eMule versions which do not write broken float tags).
	for (int j = 0; j < m_tagArray.GetCount(); j++)
d820 2
a821 2
		if (m_tagArray[j]->IsStr() || m_tagArray[j]->IsInt())
			tagcount++;
d823 1
a823 36

//	Standard tags
	fwrite(&tagcount,4,1,file);							// {<TAGCOUNT:DWORD>

	CFileTag	nameTag(FT_FILENAME, GetFileName());

	nameTag.WriteToFile(file);							// (FT_FILENAME:string) file name

	CFileTag	sizeTag(FT_FILESIZE,GetFileSize());

	sizeTag.WriteToFile(file);							// (FT_FILESIZE:int) file size (bytes)

//	Statistic
	uint32		tran;

	tran = statistic.GetAllTimeTransferred();

	CFileTag	attag1(FT_ATTRANSFERRED, tran);

	attag1.WriteToFile(file);
	tran = statistic.alltimetransferred >> 32;

	CFileTag	attag4(FT_ATTRANSFERREDHI, tran);

	attag4.WriteToFile(file);

	CFileTag	attag2(FT_ATREQUESTED,statistic.GetAllTimeRequests());

	attag2.WriteToFile(file);

	CFileTag	attag3(FT_ATACCEPTED,statistic.GetAllTimeAccepts());

	attag3.WriteToFile(file);
//
//	priority & permissions
	if (IsULAutoPrioritized())
d825 2
a826 3
		CFileTag		prioTag(FT_PRIORITY,static_cast<byte>(PR_AUTO));

		prioTag.WriteToFile(file);
d828 3
a830 1
	else
d832 2
a833 3
		CFileTag		prioTag(FT_PRIORITY, m_bytePriority);

		prioTag.WriteToFile(file);
a835 4
	CFileTag	permTag(FT_PERMISSIONS, m_iPermissions);

	permTag.WriteToFile(file);

d840 1
d842 2
d845 4
a848 8

	//rollback the file pointer
	if (ferror(file) != 0)
	{
		clearerr(file);
		fseek(file, lFilePointerPosition, SEEK_SET);
		return false;
	}
a850 4

	EMULE_CATCH

	return false;
@


1.160
log
@More ifdefs for v2
@
text
@d652 1
a652 1
	file.Read(&dwNumTags,4);							// {<TAGCOUNT:DWORD>
d654 1
a654 1
	for (uint32 j = 0; j != dwNumTags; j++)
a661 1
				//m_strFileName = newtag->GetStringValue();
a662 1
				delete newtag;
a667 1
				delete newtag;
a672 1
				delete newtag;
a686 1
				delete newtag;
a691 1
				delete newtag;
a696 1
				delete newtag;
a710 1
				delete newtag;
a715 1
				delete newtag;
d720 1
d722 1
@


1.159
log
@Many ifdefs for v2
@
text
@d224 1
d227 1
@


1.158
log
@Preparations and minor corrections for new tag processing.
@
text
@d26 3
a28 1
#include "emule.h"
d32 3
a34 1
#include "Jumpstarter.h"
d49 1
d51 3
d83 7
a89 1
	return _T("<a href=\"") + CreateED2kLink() + _T("\">") + g_eMuleApp.StripInvalidFilenameChars(GetFileName(), true) + _T("</a>");
d134 1
d140 1
a140 1

d150 1
d152 1
d164 1
d166 1
d182 1
d184 1
d234 1
d291 1
a291 1

d297 1
d304 1
d490 1
d497 1
d760 1
d763 1
d765 1
d771 1
d1010 1
d1032 1
d1111 1
d1163 1
d1206 1
d1238 3
d1245 1
d1341 1
d1351 1
d1364 1
d1373 1
d1391 1
d1400 1
d1428 1
d1438 1
d1466 1
d1718 1
d1721 1
d1739 1
d1742 1
d2091 1
d2093 3
d2100 1
d2112 1
d2117 1
d2119 1
d2124 1
d2126 1
d2131 1
d2133 3
d2156 1
d2168 3
@


1.157
log
@Unified display of file permission and upload file priority.
@
text
@d630 1
a630 1
		switch (newtag->GetSpecialTag())
d795 1
a795 1
		if (m_tagArray[j]->GetType() == TAGTYPE_STRING || m_tagArray[j]->GetType() == TAGTYPE_UINT32)
d798 1
a798 1
//
d849 1
a849 1
//
d853 1
a853 1
		if (m_tagArray[j]->GetType() == TAGTYPE_STRING || m_tagArray[j]->GetType() == TAGTYPE_UINT32)
@


1.156
log
@Changed ::CreateED2kSourceLink() to give at least a link without source if IP isn't known
Removed multi init
Code refactoring
@
text
@d20 2
a21 2
#include "StdAfx.h"
#include "knownfile.h"
d2090 7
a2096 1
	UINT		dwResStrId;
d2098 3
a2100 20
	switch(GetPermissions())
	{
		case PERM_NOONE:
		{
			dwResStrId = IDS_HIDDEN;
			break;
		}
		case PERM_FRIENDS:
		{
			dwResStrId = IDS_FSTATUS_FRIENDSONLY;
			break;
		}
		default:
		case PERM_ALL:
		{
			dwResStrId = IDS_FSTATUS_PUBLIC;
			break;
		}
	}
	return GetResString(dwResStrId);
@


1.155
log
@Enabled shared files view permission settings (all, friends only, noone).
(have been reminded of this forgotten column when I saw it in tooltips :))
@
text
@d54 2
a55 1
	uint32		dwID = 0;
d57 1
a57 2
#ifdef OLD_SOCKETS_ENABLED
	if (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID())
d59 8
a66 1
		return _T("");
a67 1
	dwID = g_eMuleApp.m_pServerConnect->GetClientID();
a69 12
	CString		strLink;

	strLink.Format( _T("ed2k://|file|%s|%u|%s|/|sources,%i.%i.%i.%i:%i|/"),
					g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
					GetFileSize(),
					HashToString(GetFileHash()),
					static_cast<BYTE>(dwID),
					static_cast<BYTE>(dwID>>8),
					static_cast<BYTE>(dwID>>16),
					static_cast<BYTE>(dwID>>24),
					g_eMuleApp.m_pGlobPrefs->GetListenPort() );

d75 1
a75 1
	return CString(_T("<a href=\"") + CreateED2kLink() + _T("\">") + g_eMuleApp.StripInvalidFilenameChars(GetFileName(), true) + _T("</a>"));
a79 1
//--- xrmb:parttraffic ---
d157 2
a158 1
CKnownFile::CKnownFile()
d163 1
a163 4
	if (g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
		m_bAutoPriority = true;
	else
		m_bAutoPriority = false;
a169 1
	m_strComment = _T("");
a177 1
	//--- xrmb:allyaknow ---
a178 1
	//--- :xrmb ---
a188 2

	m_strComment = _T("");
d196 1
a196 1
	if (m_pPartsHashSet)
d234 1
a234 1
			// calculate range
a465 1
		//	SyruS SLUGFILLER: SafeHash - quick fallback
a965 2
	// Cax2 - better placing the mutex in PartFileHashFinished()...
	//CSingleLock Lock(&m_mutexHashList,TRUE);
a979 1
//	MatzeHH formula I think is better than herbert's one (Tarod)
d1172 10
a1181 9
	static const uint16 s_auResID[ED2KFT_COUNT] = {
		IDS_SEARCH_ANY,		//ED2KFT_ANY
		IDS_SEARCH_AUDIO,	//ED2KFT_AUDIO
		IDS_SEARCH_VIDEO,	//ED2KFT_VIDEO
		IDS_SEARCH_PICS,	//ED2KFT_IMAGE
		IDS_SEARCH_PRG,		//ED2KFT_PROGRAM
		IDS_SEARCH_DOC,		//ED2KFT_DOCUMENT
		IDS_SEARCH_ARC,		//ED2KFT_ARCHIVE
		IDS_SEARCH_CDIMG	//ED2KFT_CDIMAGE
d1183 10
a1192 9
	static const char *const s_apcSearchTypes[ED2KFT_COUNT] = {
		"",			//ED2KFT_ANY
		"Audio",	//ED2KFT_AUDIO
		"Video",	//ED2KFT_VIDEO
		"Image",	//ED2KFT_IMAGE
		"Pro",		//ED2KFT_PROGRAM
		"Doc",		//ED2KFT_DOCUMENT
		"Pro",		//ED2KFT_ARCHIVE
		"Pro"		//ED2KFT_CDIMAGE
d1469 1
a1469 1
	//--- recalculate complete releases factor ---
d1473 1
a1473 1
	//--- find lowest parttraffic ---
d1490 1
a1490 1
	//--- get avg. ---
d1511 1
a1511 1
//--- this function may not return a 100% accurate value, because you can't fill a part with blocks
d1516 1
a1516 1
	//--- check part, damn that all needs time, why we just cant trust the devs :) ---
d1520 1
a1520 1
	//--- start and end block ---
d1525 1
a1525 1
	//--- find lowest parttraffic ---
d1542 1
a1542 1
	//--- get avg. ---
d1571 1
a1571 1
	//--- start block ---
d1592 1
a1592 1
	//--- start block ---
a1629 1
		//--- added in version 2 ---
d1633 1
a1633 1
	//--- this block shouldnt be used at all ---
a1647 1
		//--- added version 2 ---
d1698 1
a1698 1
	//--- versioning ---
d1701 1
a1701 1
		//--- version 2 introduced part-accepted counter ---
d1705 1
a1705 1
	//--- recalc something ---
d1853 1
a1853 1
	if(all)
d1855 3
a1857 3
		if(partTraffic)		delete[] partTraffic;	partTraffic=NULL;
		if(partAccepted)	delete[] partAccepted;	partAccepted=NULL;
		if(blockTraffic)	delete[] blockTraffic;	blockTraffic=NULL;
d1859 3
a1861 3
		if(partTrafficSession)		delete[] partTrafficSession;	partTrafficSession=NULL;
		if(partAcceptedSession)		delete[] partAcceptedSession;	partAcceptedSession=NULL;
		if(blockTrafficSession)		delete[] blockTrafficSession;	blockTrafficSession=NULL;
d1863 1
a1863 1
		completeReleases=0.0;
d1865 1
a1865 1
		alltimerequested=alltimetransferred=alltimeaccepted=0;
d1869 3
a1871 3
		if(partTrafficSession)
			for(uint16 part=0; part<fileParent->GetPartCount(); part++)
				partTrafficSession[part]=0;
d1873 3
a1875 3
		if(partAcceptedSession)
			for(uint16 part=0; part<fileParent->GetPartCount(); part++)
				partAcceptedSession[part]=0;
d1877 3
a1879 3
		if(blockTrafficSession)
			for(uint32 block=0; block<fileParent->GetBlockCount(); block++)
				blockTrafficSession[block]=0;
d1882 1
a1882 1
	m_iNumRequested=m_qwNumTransferred=m_iNumAccepted=0;
@


1.154
log
@Fixed part traffic bar information for files with size = 0 modulo EMBLOCKSIZE (180KB)
(the last block was always shown as never transferred).
@
text
@d180 1
a180 2
	// m_iPartCount = 0;	//netwolf // commented out for Complete sources
	m_nCompleteSourcesCount = 0;		//  netwolf: complete sources (zegzav) 13.05.03
a795 4
//  DonGato: Deprecated
//	//tags
//	uint32 tagcount = m_tagArray.GetCount()+7;

d2106 26
@


1.153
log
@Added comment.
@
text
@d371 1
d388 3
a390 1
	m_dwBlockCount = (dwFileSize/EMBLOCKSIZE) + ((dwFileSize % EMBLOCKSIZE)? 1:0);
d1867 1
a1867 1
uint32 CKnownFile::GetBlockSize(uint32 block)
d1869 1
a1869 10
	EMULE_TRY

	if(block+1<GetBlockCount())
		return EMBLOCKSIZE;

	return GetFileSize() % EMBLOCKSIZE;

	EMULE_CATCH

	return 0;
@


1.152
log
@changes in part control; hidden & blocked statuses are merged
@
text
@d399 2
a400 1
// intialize array with required status: all parts shared
d2035 1
a2035 2
	//Cax2 - this lock here was pretty useless..
	//CSingleLock Lock(&m_mutexHashList,TRUE);
a2036 1
	//Lock.Unlock();
@


1.151
log
@Variable renaming.
@
text
@d399 3
a2015 14
//--- xrmb:partprio ---
byte	CKnownFile::GetPartStatus(uint16 part)
{
	EMULE_TRY

	byte r=PR_PART_ON;
	if(m_partStatus.Lookup(part, r))
		return r;

	EMULE_CATCH

	return PR_PART_ON;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d2020 1
a2020 4
	POSITION	pos=m_partStatus.GetStartPosition();
	uint16		part;
	byte		status;
	while(pos)
d2022 1
a2022 2
		m_partStatus.GetNextAssoc(pos, part, status);
		if(status!=PR_PART_ON)
d2051 1
a2051 1
			if (GetPartStatus(dwDone++) == PR_PART_ON)
@


1.150
log
@Faster file type to string conversion.
@
text
@d177 1
a177 1
	m_iMoviePreviewMode = 0;
@


1.149
log
@Updated tag types.
@
text
@d1188 21
a1208 1
	EMULE_TRY
d1210 2
d1214 1
a1214 22
	{
		switch (m_eFileType)
		{
			case ED2KFT_AUDIO :
				return GetResString(IDS_SEARCH_AUDIO);
			case ED2KFT_VIDEO :
				return GetResString(IDS_SEARCH_VIDEO);
			case ED2KFT_IMAGE :
				return GetResString(IDS_SEARCH_PICS);
			case ED2KFT_ARCHIVE :
				return GetResString(IDS_SEARCH_ARC);
			case ED2KFT_PROGRAM :
				return GetResString(IDS_SEARCH_PRG);
			case ED2KFT_CDIMAGE :
				return GetResString(IDS_SEARCH_CDIMG);
			case ED2KFT_DOCUMENT :
				return GetResString(IDS_SEARCH_DOC);
			case ED2KFT_ANY :
			default:
				return GetResString(IDS_SEARCH_ANY);
		}
	}
d1216 1
a1216 24
	{
		switch (m_eFileType)
		{
			case ED2KFT_AUDIO:
				return "Audio";
			case ED2KFT_VIDEO:
				return "Video";
			case ED2KFT_IMAGE:
				return "Image";
			case ED2KFT_ARCHIVE:
			case ED2KFT_CDIMAGE:
			case ED2KFT_PROGRAM:
				return "Pro";
			case ED2KFT_DOCUMENT:
				return "Doc";
			case ED2KFT_ANY:
			default:
				return "";
		}
	}

	EMULE_CATCH

	return "";
@


1.148
log
@Fixed rehashing on Daylight Saving Time change (official).
@
text
@d808 1
a808 1
		if (m_tagArray[j]->GetType() == TAGTYPE_STRING || m_tagArray[j]->GetType() == TAGTYPE_INT)
d866 1
a866 1
		if (m_tagArray[j]->GetType() == TAGTYPE_STRING || m_tagArray[j]->GetType() == TAGTYPE_INT)
@


1.147
log
@.tar is a library and can be compressed very well;
CString.Empty() releases string buffer, so don't use it when it isn't required to minimize reallocations.
@
text
@d514 1
@


1.146
log
@code optimisation
@
text
@d407 1
a407 1
	m_bIsCompressedTransferAllowed = (GetFileType() != ED2KFT_ARCHIVE);
a1152 2
	m_strFileExtension.Empty();

d1157 1
a1157 1
		int		idxExtension = m_strFileName.ReverseFind(_T('.'));
d1159 1
a1159 1
		if (idxExtension != -1)
d1161 1
a1161 1
			m_strFileExtension = m_strFileName.Mid(idxExtension + 1);
d1164 7
d1180 2
a1181 2
		for (uint16 i = 0; i < _countof(s_acRepTbl); i++)
			m_strFileName.Replace(s_acRepTbl[i], _T('-'));
@


1.145
log
@Fixed a string processing bug, fortunately it worked fine anyway [KuSh].
@
text
@d202 1
a202 1
 
d386 1
a386 1
	//block traffic
d389 1
a389 1
//	calculate size ration (=SmallFilePushRatio)
d403 1
a403 1
//	set the name & extension
a405 7
	CString strExt = GetFileExtension();
	static const TCHAR s_apcCompressedFileExt[][4] =
	{
		_T("zip"), _T("rar"), _T("ace"), _T("arj"),
		_T("cab"), _T("tgz"), _T("gz"), _T("bz2")
	};

d407 1
a407 9
	m_bIsCompressedTransferAllowed = true;
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcCompressedFileExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcCompressedFileExt[ui])) == 0)
		{
			m_bIsCompressedTransferAllowed = false;
			break;
		}
	}
a1148 1
// Adde by Tarod [Juanjo]
d1153 2
d1158 3
a1160 1
		int idxExtension = m_strFileName.ReverseFind(_T('.'));
a1165 2
		else
			m_strFileExtension.Empty();
a1166 2
	else
		m_strFileExtension.Empty();
d1170 7
a1176 9
		m_strFileName.Replace(_T('/'), _T('-'));
		m_strFileName.Replace(_T('>'), _T('-'));
		m_strFileName.Replace(_T('<'), _T('-'));
		m_strFileName.Replace(_T('*'), _T('-'));
		m_strFileName.Replace(_T(':'), _T('-'));
		m_strFileName.Replace(_T('?'), _T('-'));
		m_strFileName.Replace(_T('|'), _T('-'));
		m_strFileName.Replace(_T('\"'), _T('-'));
		m_strFileName.Replace(_T('\\'), _T('-'));
a1178 1
//End by Tarod
@


1.144
log
@final (at least i hope so) optimization for processing of file extension
@
text
@d1172 2
a1173 2
		int idxExtension = m_strFileName.ReverseFind('.');
		if (m_strFileExtension != -1)
d1186 9
a1194 10
		m_strFileName.Replace('/','-');
		m_strFileName.Replace('>','-');
		m_strFileName.Replace('<','-');
		m_strFileName.Replace('*','-');
		m_strFileName.Replace(':','-');
		m_strFileName.Replace('?','-');
		//SyruS: these 3 were missing.
		m_strFileName.Replace('|','-');
		m_strFileName.Replace('\"','-');
		m_strFileName.Replace('\\','-');
@


1.143
log
@Fix for the update of Download List comments when changed in Shared Files.
@
text
@d201 2
d401 24
a1176 16

			static const TCHAR s_apcCompressedFileExt[][4] =
			{
				_T("zip"), _T("rar"), _T("ace"), _T("arj"),
				_T("cab"), _T("tgz"), _T("gz"), _T("bz2")
			};

		//	Don't try to compress already compressed files
			for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcCompressedFileExt); ui++)
			{
				if (m_strFileExtension.Compare(reinterpret_cast<const TCHAR*>(&s_apcCompressedFileExt[ui])) == 0)
				{
					m_bIsCompressedTransferAllowed = false;
					break;
				}
			}
a1178 1
		{
a1179 2
			m_bIsCompressedTransferAllowed = true;
		}
a1181 1
	{
a1182 2
		m_bIsCompressedTransferAllowed = true;
	}
@


1.142
log
@UL speed optimization (archive extension check)
@
text
@d1389 6
d1427 3
d1462 3
@


1.141
log
@Fixed several issues processing files with size = 0 modulo PARTSIZE
(processing file corruption, jumpstart, statistics, etc.).
@
text
@d1151 16
d1169 1
d1171 7
@


1.140
log
@optimization in processing of file extension
@
text
@d368 1
d372 3
a374 1
	m_uPartCount = (dwFileSize/PARTSIZE) + ((dwFileSize % PARTSIZE)? 1:0);
d381 1
a381 1
		m_dwED2KPartHashCount += 1;
d390 1
a390 1
		m_dblSizeRatio = 9961472.0 /static_cast<double>(dwFileSize);
d1851 1
a1851 1
uint32 CKnownFile::GetPartSize(uint16 part)
d1853 1
a1853 10
	EMULE_TRY

	if(part+1<GetPartCount())
		return PARTSIZE;

	return GetFileSize() % PARTSIZE;

	EMULE_CATCH

	return 0;
@


1.139
log
@Removed unused code.
@
text
@d1141 1
d1143 9
@


1.138
log
@rollback of old waiting queue
@
text
@a1567 3
	//DEBUG_ONLY(AddLogLine(false, "--------------------------------------------------------------------------------------------------"));
	//DEBUG_ONLY(AddLogLine(false, "start %i, bytes %i ", start, bytes));

a2018 23
bool    CKnownFile::HasParts()
{
	EMULE_TRY

	POSITION    pos=m_partStatus.GetStartPosition();

	if (pos == NULL)
		return true;

	uint16      part;
	byte       status;
	while(pos)
	{
		m_partStatus.GetNextAssoc(pos, part, status);
		if (status!=PR_PART_OFF)
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.137
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d1237 1
a1237 3
	ClientList::iterator clientIt;

	for (clientIt = g_eMuleApp.m_pUploadQueue->m_waitingList.begin(); clientIt != g_eMuleApp.m_pUploadQueue->m_waitingList.end(); clientIt++)
d1239 1
a1239 1
		pPotentialSource = *clientIt;
d1372 1
a1372 2
	ClientDeque sourceDeque;
	ClientDeque::iterator clientIt;
d1374 1
a1374 2
//	get sources from UploadQueue
	g_eMuleApp.m_pUploadQueue->GetSourcesFromUploadQueueByFileID(&sourceDeque, GetFileHash());
d1376 1
a1376 2
//	get sources from WaitingQueue
	g_eMuleApp.m_pUploadQueue->GetSourcesFromWaitingQueueByFileID(&sourceDeque, GetFileHash());
d1378 1
a1378 1
	for (clientIt = sourceDeque.begin(); clientIt != sourceDeque.end(); clientIt++) 
d1380 1
a1380 1
		CUpDownClient* pClient = *clientIt;
d1405 2
a1406 5
	ClientDeque sourceDeque;
	ClientDeque::iterator clientIt;

//	get sources from UploadQueue
	g_eMuleApp.m_pUploadQueue->GetSourcesFromUploadQueueByFileID(&sourceDeque, GetFileHash());
d1408 1
a1408 2
//	get sources from WaitingQueue
	g_eMuleApp.m_pUploadQueue->GetSourcesFromWaitingQueueByFileID(&sourceDeque, GetFileHash());
d1410 1
a1410 1
	for (clientIt = sourceDeque.begin(); clientIt != sourceDeque.end(); clientIt++) 
d1412 1
a1412 1
		CUpDownClient* pClient = *clientIt;
a2150 22
void CKnownFile::SetULPriority(byte byteNewPriority)
{
	if (byteNewPriority != m_bytePriority)
	{
		m_bytePriority = byteNewPriority;

	//	check queue existence (required for call during the start)
		if (g_eMuleApp.m_pUploadQueue)
		{
			ClientDeque srcDeque;

			g_eMuleApp.m_pUploadQueue->GetSourcesFromWaitingQueueByFileID(&srcDeque, GetFileHash());
			while (!srcDeque.empty())
			{
			//	update the client position in waiting queue
				g_eMuleApp.m_pUploadQueue->UpdateClientInWaitingQueue(srcDeque.front());
				srcDeque.pop_front();
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.136
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d434 1
a434 1
	m_strFileName = strFileName;
d800 1
a800 1
	CFileTag	nameTag(FT_FILENAME,m_strFileName);
d1136 1
a1136 1
void CAbstractFile::SetFileName(const CString& NewName)
d1140 16
a1155 10
	m_strFileName.Replace('/','-');
	m_strFileName.Replace('>','-');
	m_strFileName.Replace('<','-');
	m_strFileName.Replace('*','-');
	m_strFileName.Replace(':','-');
	m_strFileName.Replace('?','-');
	//SyruS: these 3 were missing.
	m_strFileName.Replace('|','-');
	m_strFileName.Replace('\"','-');
	m_strFileName.Replace('\\','-');
d1159 1
a1159 1
CString CAbstractFile::GetFileType(bool bLocalized)
a1162 4
	EED2KFileType eFileType = ED2KFT_ANY;

	if (!m_strFileName.IsEmpty())
		eFileType = GetED2KFileTypeID(m_strFileName);
d1166 1
a1166 1
		switch (eFileType)
d1189 1
a1189 1
		switch (eFileType)
@


1.135
log
@SSWQ
@
text
@d199 2
d383 11
d976 1
a976 1
double CKnownFile::GetFileRatio()
d1001 1
a1001 1
	return dblRatio ;
d1372 2
a1373 1
	CTypedPtrList<CPtrList, CUpDownClient*> srclist;
d1375 2
a1376 1
	g_eMuleApp.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());
d1378 2
a1379 1
	CUpDownClient	*pClient;
d1381 1
a1381 1
	for (POSITION pos = srclist.GetHeadPosition(); pos != NULL; )
d1383 1
a1383 1
		pClient = srclist.GetNext(pos);
d1408 5
a1412 2
	CTypedPtrList<CPtrList, CUpDownClient*> srclist;
	g_eMuleApp.m_pUploadQueue->FindSourcesForFileById(&srclist, GetFileHash());
d1414 2
a1415 1
	CUpDownClient	*pClient;
d1417 1
a1417 1
	for (POSITION pos = srclist.GetHeadPosition(); pos != NULL; )
d1419 1
a1419 1
		pClient = srclist.GetNext(pos);
@


1.134
log
@More correct calculations (preparations for 4 Gb file sharing/downloading).
@
text
@d167 1
a167 1
	m_iPriority = PR_NORMAL;
d661 2
a662 2
				m_iPriority = newtag->GetIntValue();
				if (m_iPriority == PR_AUTO)
d664 2
a665 2
					SetAutoPriority(true);
					SetPriority(PR_RELEASE);
d669 1
a669 1
					SetAutoPriority(false);
d818 1
a818 1
	if (IsAutoPrioritized())
d826 1
a826 1
		CFileTag		prioTag(FT_PRIORITY, m_iPriority);
d1067 1
a1067 1
	if (IsAutoPrioritized() && !IsCompleting())
d1079 1
a1079 1
					SetPriority(PR_RELEASE);
d1083 1
a1083 1
					SetPriority(PR_HIGH);
d1087 1
a1087 1
					SetPriority(PR_NORMAL);
d1091 1
a1091 1
					SetPriority(PR_LOW);
d1102 1
a1102 1
				SetPriority(PR_RELEASE);
d1106 1
a1106 1
				SetPriority(PR_HIGH);
d1110 1
a1110 1
				SetPriority(PR_NORMAL);
d1114 1
a1114 1
				SetPriority(PR_LOW);
d1222 3
a1224 1
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
d1226 1
a1226 1
		pPotentialSource = g_eMuleApp.m_pUploadQueue->GetNext(pos);
d2138 22
@


1.133
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d1463 1
a1463 3
		uint32 s=EMBLOCKSIZE;
		if(EMBLOCKSIZE*(i+1) > fs)
			s = fs % EMBLOCKSIZE;
d1478 1
a1478 3
		uint32 s=EMBLOCKSIZE;
		if(EMBLOCKSIZE*(i+1) > fs)
			s = fs % EMBLOCKSIZE;
d1503 1
d1505 1
a1505 5
	uint32	endBlock=((part+1)*PARTSIZE)/EMBLOCKSIZE;
	if(endBlock >= fileParent->GetBlockCount())
		endBlock=fileParent->GetBlockCount()-1;

	uint32	fs=fileParent->GetFileSize();
d1515 1
a1515 3
		uint32 s=EMBLOCKSIZE;
		if(EMBLOCKSIZE*(i+1) > fs)
			s = fs % EMBLOCKSIZE;
d1530 1
a1530 3
		uint32 s=EMBLOCKSIZE;
		if(EMBLOCKSIZE*(i+1) > fs)
			s = fs % EMBLOCKSIZE;
@


1.132
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d417 1
a417 1
	AddDebugLogLine(false, RGB_LOG_DIMMED + _T("File %s is being hashed"), strFileName/*m_strFileName*/);
d525 1
a525 1
			AddDebugLogLine(false, _T("Loaded hashset size is corrupt in known.met, file: %s!"), m_strFileName);
d529 1
a529 1
			AddDebugLogLine(false, _T("Loaded hashset size is corrupt in known.met!"));
@


1.131
log
@More DebugLog formating and changes
@
text
@d525 1
a525 1
			AddDebugLogLine(false, _T("%s: Loaded hashset size is corrupt in known.met, file: %s!"), __FUNCTION__, m_strFileName);
d529 1
a529 1
			AddDebugLogLine(false, _T("%s: Loaded hashset size is corrupt in known.met!"), __FUNCTION__);
@


1.130
log
@Fixed bugs with AV-support; reverted unneeded changes, removed redundant try/catch (thanks to Aw3 !)
@
text
@d525 1
a525 1
			AddDebugLogLine(false, _T("Loaded hashset size is corrupt in known.met, file: %s!"), m_strFileName);
d529 1
a529 1
			AddDebugLogLine(false, _T("Loaded hashset size is corrupt in known.met !"));
@


1.129
log
@minor changes, fixes and improvements
@
text
@d148 1
a148 1
void CFileStatistic::AddTransferred(uint64 bytes)
@


1.128
log
@code optimization (thanks to Aw3)
@
text
@d148 1
a148 1
void CFileStatistic::AddTransferred(uint32 bytes)
@


1.127
log
@Updated and corrected the CreateSrcInfoPacket function part 2
@
text
@d1228 1
d1230 2
a1231 2
	//	Don't send clients that have no parts available
		if ( pForClient == pPotentialSource || pForClient->Compare(pPotentialSource)
d1235 1
d1237 1
a1237 3
				|| md4cmp(pPotentialSource->m_reqFileHash, pForClient->m_reqFileHash) != 0
				|| pForClient->GetUpPartCount() != pPotentialSource->GetUpPartCount()
				|| (pPotentialSource->GetAvailUpPartCount() == 0 && pForClient->GetUpPartCount() > 1) )
@


1.126
log
@Updated and corrected the CreateSrcInfoPacket function;
Updated SourceExchange Protocol to v2
@
text
@d1199 1
a1199 1
Packet*	CKnownFile::CreateSrcInfoPacket(CUpDownClient* pForClient)
d1217 4
a1220 4
	uint32	dwID;
	uint16	uPort;
	uint32	dwServerIP;
	uint16	uServerPort;
d1226 9
a1234 1
		if ( pPotentialSource->IsOnLAN() || pPotentialSource->HasLowID() || pPotentialSource == pForClient
d1236 2
a1237 1
				|| pPotentialSource->GetAvailUpPartCount() == 0 || pForClient->GetUpPartCount() != pPotentialSource->GetUpPartCount() )
d1242 1
d1246 1
a1246 1
	//	both clients support part statuses so we try to find needed clients
d1249 1
a1249 1
			for (uint16 i = 0; i < pForClient->GetUpPartCount(); i++)
d1258 1
a1258 1
	//	if not we give a sources with at least one part
d1276 1
a1276 1
			if (uCount >= 50)
@


1.125
log
@Disable scheduled backup and backup on exit if a file corruption is detected on start + minor changes
@
text
@d210 1
a210 1
	
d472 1
a472 1
		// needs some time to finish a hashing process . Thefore to prevent possible 
d550 1
a550 1
	
d741 1
a741 1
//	if number of hash sets is not equal 0, then check if hash exist (allocated in the memory) 
d1199 1
a1199 1
Packet*	CKnownFile::CreateSrcInfoPacket(CUpDownClient* forClient)
d1203 18
a1220 1
	CTypedPtrList<CPtrList, CUpDownClient*> srclist;
d1222 3
a1224 1
	g_eMuleApp.m_pUploadQueue->FindSourcesForFileById(&srclist, forClient->m_reqFileHash); //should we use "fileHash"?
d1226 4
a1229 2
	if (srclist.IsEmpty())
		return NULL;
d1231 1
a1231 2
	CMemFile	packetStream;
	uint16		nCount = 0;
d1233 2
a1234 2
	packetStream.Write(forClient->m_reqFileHash, 16);
	packetStream.Write(&nCount,2);
d1236 33
a1268 28
	uint32 lastRequest = forClient->GetLastSrcReqTime();
//	We are only taking 30 random sources since we can't be sure if they have parts we need
//	this is hard coded because its a temp solution until next(?) version
	srand(time(NULL));
	for (int i = 0; i < 30; i++)
	{
		int victim = ((rand() >> 7) % srclist.GetSize());

		POSITION pos = srclist.FindIndex(victim);

		CUpDownClient *cur_src = srclist.GetAt(pos);
	//	We don't share Lan clients sources as they are private ips/userids
		if (!cur_src->IsOnLAN() && !cur_src->HasLowID() && cur_src != forClient)
		{
			nCount++;
			uint32 dwID = cur_src->GetUserID();
			uint16 nPort = cur_src->GetUserPort();
			uint32 dwServerIP = cur_src->GetServerIP();
			uint16 nServerPort = cur_src->GetServerPort();
			packetStream.Write(&dwID,4);
			packetStream.Write(&nPort,2);
			packetStream.Write(&dwServerIP,4);
			packetStream.Write(&nServerPort,2);
		}

		srclist.RemoveAt(pos);
		if (srclist.GetSize() == 0)
			break;
d1270 2
a1271 1
	if (nCount == 0)
d1274 2
a1275 2
	packetStream.Seek(16,0);
	packetStream.Write(&nCount,2);
d1280 1
a1280 1
	if (nCount > 28)
@


1.124
log
@Fixed loss of client uploading turn during part file flushing and single part hashing;
Reworked file completion algorithm to eliminate file locking in completing state.
@
text
@d509 1
a509 1
//	Read the file hashif required, or just skip it if we need just check a hash
d1633 2
d1652 2
@


1.123
log
@xrmb bugfix for merging known files
@
text
@d2091 16
@


1.122
log
@replaced  pos != 0 to pos != NULL
@
text
@d1950 1
a1950 1
			partTraffic[part]=m->partTraffic[part];
@


1.121
log
@minor correction & improvements of "known.met" save process
@
text
@d231 1
a231 1
		for (POSITION pos= clientuploadlist.GetHeadPosition(); pos != 0; )
@


1.120
log
@fixed upload auto priority changes during file completion
@
text
@d733 2
d842 9
a850 1
	return ferror(file);
@


1.119
log
@fix for my minor optimization (thanks DonGato)
@
text
@d1057 1
a1057 1
	if (IsAutoPrioritized())
d1059 1
a1059 1
		if (IsPartFile() && g_eMuleApp.m_pDownloadQueue && !IsPaused() && !IsCompleting())
@


1.118
log
@Reverted eklmn changes (known.met corruption with >9Mb files)
@
text
@d737 5
a741 4
	uint16		dwNumParts = m_partHashArray.GetCount();
//
//	It's safer to do a check first to avoid file corruption
	for (int i = 0; i < dwNumParts; i++)
a742 1
		if (m_partHashArray[i] == NULL)
d746 1
d748 1
a748 1
//
d752 2
a753 1
	fwrite(&dwNumParts,2,1,file);				// <count:WORD> number of parts
d755 2
a756 4
	for (i = 0; i < dwNumParts; i++)
	{
		fwrite(m_partHashArray[i],16,1,file);	// <HASH>[count] part hashes
	}
@


1.117
log
@minor optimization to new hash code
@
text
@a734 4
//	check if hash exist (allocated in the memory) & return with FALSE to avoid the file corruption
	if (m_pPartsHashSet == NULL)
		return false;

d737 8
a744 1
	uint16	uNumParts = m_partHashArray.GetCount();
d751 1
a751 1
	fwrite(&uNumParts,2,1,file);				// <count:WORD> number of parts
d753 4
a756 2
//	save the hash set 
	fwrite(m_pPartsHashSet, 16*uNumParts,  1 , file);	// <HASH>[count] part hashes
@


1.116
log
@minor fix & some optimization. Thanks Aw3 again ;)
@
text
@d735 4
d741 1
a741 8
	uint16		dwNumParts = m_partHashArray.GetCount();
//
//	It's safer to do a check first to avoid file corruption
	for (int i = 0; i < dwNumParts; i++)
	{
		if (m_partHashArray[i] == NULL)
			return false;
	}
d748 1
a748 1
	fwrite(&dwNumParts,2,1,file);				// <count:WORD> number of parts
d750 2
a751 4
	for (i = 0; i < dwNumParts; i++)
	{
		fwrite(m_partHashArray[i],16,1,file);	// <HASH>[count] part hashes
	}
@


1.115
log
@fixed a hashing for files smaller then PARTSIZE
@
text
@d509 6
a514 2
//	Read the file hash
	file.Read(&FileHash,16);			// <HASH> file hash
a535 1
		md4cpy(m_fileHash, FileHash);
d543 8
a565 12
	//	copy filehas to member variable
		md4cpy(m_fileHash, FileHash);

	//	If the number of hashes doesn't match the number of hashes the file should have...
		if (bCheckHash && static_cast<uint32>(uNumParts) != GetED2KPartHashCount())
		{
		//	Delete local hashset & clear local array
			safe_delete(pPartsHashSet);
			partHashArray.RemoveAll();
			return false;
		}

d2080 1
a2080 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////@


1.114
log
@"SLUGFILLER:SafeHash" partialy replaced by code, that produce minimal lock & more rubust
@
text
@d469 1
a469 1
	else if (dwHashCount == 1)
@


1.113
log
@Optimized part status writing
@
text
@a165 1
	m_lFileSize = 0;
d196 4
d205 1
d207 2
a208 3
	for (int i = 0; i < m_partHashArray.GetSize(); i++)
		if (m_partHashArray[i])
			delete[] m_partHashArray[i];
d210 1
d299 84
d395 4
a398 1
	directory = strDirectory;
d400 2
a401 3
	CString			strNameBuffer;

	strNameBuffer.Format(_T("%s\\%s"),strDirectory,strFileName);
a403 2
	CFile		file;

d416 5
a420 1
	m_lFileSize = static_cast<uint32>(qwFileSz);
d422 2
a423 2

	AddDebugLogLine(false, RGB_LOG_DIMMED + _T("File %s is being hashed"), m_strFileName);
d426 1
a426 3
	uint32		dwBytesLeft = m_lFileSize;

	for (uint16 dwHashCount = 0; dwBytesLeft >= PARTSIZE;)
d428 4
a431 1
		uchar		*pNewHash = new uchar[16];
d433 1
a433 4
	//	Create a hash for the next PARTSIZE bytes of 'file'
		CreateHashFromFile(&file, PARTSIZE, pNewHash);
	//	SyruS SLUGFILLER: SafeHash - quick fallback
		if (!g_eMuleApp.m_pdlgEmule->IsRunning())	// in case of shutdown while still hashing
d435 20
a454 3
			file.Close();
			delete[] pNewHash;
			return false;
d456 1
d458 1
d460 8
a467 11
		m_partHashArray.Add(pNewHash);
		dwBytesLeft -= PARTSIZE;
		dwHashCount++;
	}
	uchar* lasthash = new uchar[16];

	CreateHashFromFile(&file, dwBytesLeft, lasthash);
	if (!dwHashCount)
	{
		md4cpy(m_fileHash,lasthash);
		delete[] lasthash;
d469 1
a469 1
	else
d471 5
a475 8
		CSingleLock Lock(&m_mutexHashList,TRUE);
		m_partHashArray.Add(lasthash);
		uchar* buffer = new uchar[m_partHashArray.GetCount()*16];
		for (int i = 0;i < m_partHashArray.GetCount();i++)
			md4cpy(buffer+(i*16),m_partHashArray[i]);
		CreateHashFromString(buffer,m_partHashArray.GetCount()*16,m_fileHash);
		Lock.Unlock();
		delete[] buffer;
d485 1
d487 1
d504 5
d510 1
a510 4
	uchar		checkid[16];

	file.Read(&checkid,16);			// <HASH> file hash

d512 1
a512 1
	uint16		iNumParts;
d514 1
a514 3
	file.Read(&iNumParts,2);		// <count:WORD> number of parts

	INT_PTR		iParts = static_cast<uint16>(iNumParts);
a527 1
	CSingleLock		Lock(&m_mutexHashList,TRUE);
d529 2
a530 3
//
//	Read the part hashes.
	for (int i = 0; i < iNumParts; i++)
d532 5
a536 4
		uchar		*pHash = new uchar[16];

		file.Read(pHash,16);		// <HASH>[count] part hashes
		m_partHashArray.Add(pHash);
d538 1
a538 2
//	SLUGFILLER: hashlistRecheck - always check m_partHashArray
	if (!bCheckHash)
d540 18
a557 8
		md4cpy(m_fileHash,checkid);
		if (!iNumParts) // nothing to check
			return true;
	}
	else
	{
		if (!iNumParts) // data not sent
			return false;
d559 1
a559 1
		if (iNumParts != GetED2KPartHashCount())
d561 3
a563 4
		//	Delete the part hash array
			for (int i = 0; i < m_partHashArray.GetSize(); i++)
				delete[] m_partHashArray[i];
			m_partHashArray.RemoveAll();
a565 3
	}
// SLUGFILLER: hashlistRecheck
// trust noone;-)
d567 2
a568 4
	if (!m_partHashArray.IsEmpty())
	{
	//	Glom all the part hashes into one big array and hash the hashes
		uchar		*buffer = new uchar[m_partHashArray.GetCount()*16];
d570 17
a586 12
		for (int i = 0; i < m_partHashArray.GetCount(); i++)
			md4cpy(buffer+(i*16),m_partHashArray[i]);
		CreateHashFromString(buffer,m_partHashArray.GetCount()*16,checkid);
		delete[] buffer;
	}
//	If the file hash from 'file' matches the calculated hash...
	if (md4cmp(m_fileHash,checkid) == 0)
		return true;
	else
	{
	//	Delete the part hash array
		for (int i = 0; i < m_partHashArray.GetSize(); i++)
d588 3
a590 2
			delete[] m_partHashArray[i];
			m_partHashArray[i]= NULL;	// most likely this is needless, but on the other hand...
a591 2
		m_partHashArray.RemoveAll();
		return false;
d623 1
a623 1
				m_lFileSize = newtag->GetIntValue();
d790 1
a790 1
	CFileTag	sizeTag(FT_FILESIZE,m_lFileSize);
a985 27
uint16 CKnownFile::GetPartCount()
{
	EMULE_TRY

	return (m_lFileSize/PARTSIZE) + ((m_lFileSize % PARTSIZE)? 1:0);

	EMULE_CATCH

	return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetED2KPartHashCount() returns number of parts to be used in hashset transfers
uint32 CKnownFile::GetED2KPartHashCount() const
{
	uint32 dwHashCnt = m_lFileSize / PARTSIZE;

	return dwHashCnt + ((dwHashCnt != 0) ? 1 : 0);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetED2KPartCount() returns number of of parts to be used with OP_FILESTATUS
uint32 CKnownFile::GetED2KPartCount() const
{
	return m_lFileSize / PARTSIZE + 1;
}

d1052 1
a1052 1

d1112 1
a1112 1

d1130 1
a1130 1

d1189 1
a1189 1

d1254 1
a1254 1

d1275 1
a1275 1

d1294 1
a1294 1

d1326 1
a1326 1

d1358 1
a1358 1

d1401 1
a1401 1

d1451 1
a1451 1

d1512 1
a1512 1

d1566 1
a1566 1

d1611 1
a1611 1

d1663 1
a1663 12

uint32 CKnownFile::GetBlockCount()
{
	EMULE_TRY

	return (m_lFileSize/EMBLOCKSIZE) + ((m_lFileSize % EMBLOCKSIZE)? 1:0);

	EMULE_CATCH

	return 0;
}

d1671 2
a1672 2
	if(start>m_lFileSize) return 0;
	if(end>m_lFileSize) end=m_lFileSize;
d1708 1
a1708 1

d1716 2
a1717 2
	if(start>m_lFileSize) return 0;
	if(end>m_lFileSize) end=m_lFileSize;
d1753 1
a1753 1

d1770 1
a1770 1

d1787 1
a1787 1

d1795 1
a1795 1
	return m_lFileSize % PARTSIZE;
d1801 1
a1801 1

d1809 1
a1809 1
	return m_lFileSize % EMBLOCKSIZE;
d1815 1
a1815 1

d1853 1
a1853 1

d1889 1
a1889 1

d1907 1
a1907 1

d1916 1
a1916 1

d1954 1
a1954 1

d1968 1
a1968 1

d1991 1
a1991 1

d2010 1
a2010 1

d2045 1
a2045 1

a2046 1

d2051 1
a2051 1

d2066 1
d2071 1
a2071 1

d2076 1
a2076 1

d2081 1
@


1.112
log
@Due to lame VS implementation of new(nothrow) in Debug mode it's replaced by malloc (thanks katsyonak).
@
text
@d1938 1
a1938 1
void CKnownFile::WritePartStatus(CFile* file)
d1943 1
a1943 1
	uint16 parts = m_partHashArray.GetCount();
d1945 6
a1950 3
	file->Write(&parts, 2);
	uint16 done = 0;
	while(done!=parts)
d1952 5
a1956 2
		byte towrite = 0;
		for (uint32 i = 0;i != 8;i++)
d1958 7
a1964 8
			if (GetPartStatus(done)==PR_PART_ON)
				towrite |= (1<<i);

			done++;
			if (done == parts)
				break;
		}
		file->Write(&towrite,1);
d1966 2
@


1.111
log
@Optimized hash calculation
@
text
@d770 2
a771 2
		uchar		*pbyteAlloc = new(nothrow) uchar[dwBlockSz];
		uchar		*pbytePtr = pbyteAlloc;
d807 2
a808 2
		if (pbyteAlloc != NULL)
			delete[] pbyteAlloc;
@


1.110
log
@list processing and other optimizations
@
text
@d314 1
a314 1
	FILE		*file = _tfopen(strNameBuffer,_T("rbS"));
d316 3
a318 2
//	If we failed to open the spec'd file, return false
	if (!file)
d321 8
a329 1
	m_lFileSize =_filelength(file->_file);
a339 2
		md4clr(pNewHash);	//SyruS needed or not...?

d341 1
a341 1
		CreateHashFromFile(file,PARTSIZE,pNewHash);
d345 1
a345 1
			fclose(file);
d356 2
a357 2
	md4clr(lasthash);	//SyruS ...why needed here?
	CreateHashFromFile(file,dwBytesLeft,lasthash);
d376 8
a383 6
	// set lastwrite date
	struct _stat fileinfo;
	_fstat(file->_file,&fileinfo);
	m_timetLastWriteDate = fileinfo.st_mtime;
	//finished
	fclose(file);
d737 3
a739 3
//	CreateHashFromInput() generates a hash from the next 'Length' bytes of one of 'file', 'file2', or 'in_string'
//		(the other two must be NULL (UGLY UGLY UGLY)). The hash is returned in '*Output'.
void CKnownFile::CreateHashFromInput(FILE* file,CFile* file2, int Length, uchar* Output, uchar* in_string)
d743 1
a743 7
	// time critial
	uint32 Hash[4];

	Hash[0] = 0x67452301;
	Hash[1] = 0xEFCDAB89;
	Hash[2] = 0x98BADCFE;
	Hash[3] = 0x10325476;
d745 4
a748 1
	CFile* data = 0;
d750 2
a751 2
	if (in_string)
		data = new CMemFile(in_string,Length);
d753 1
a753 4
	uint32 Required = Length;
	uchar   X[64*128];

	while (Required >= 64)
d755 2
a756 12
		uint32 len = Required & ~63;

		if (len > sizeof(X))
			len = sizeof(X);
		if (in_string)
			data->Read(&X,len);
		else if (file)
			fread(&X,len,1,file);
		else if (file2)
			file2->Read(&X,len);
		uint32 i = 0;
		do
d758 7
a764 4
			MD4Transform(Hash, (uint32*)(X + i));
			i += 64;
		} while(i < len);
		Required -= len;
d766 1
a766 2
	// bytes to read
	if (Required != 0)
d768 41
a808 6
		if (in_string)
			data->Read(&X,Required);
		else if (file)
			fread(&X,Required,1,file);
		else if (file2)
			file2->Read(&X,Required);
d811 2
a812 2
	X[Required++] = 0x80;
	if (Required > 56)
d814 10
a823 11
		memzero(&X[Required], 64 - Required);
		MD4Transform(Hash, (uint32*)X);
		Required = 0;
	}
	memzero(&X[Required], 56 - Required);
	// add size (convert to bits)
	uint32 Length2[2] = { Length << 3, (uint32)Length >> 29 };
	memcpy2(&X[56], Length2, 8);
	MD4Transform(Hash, (uint32*)X);
	md4cpy(Output, Hash);
	safe_delete(data);
d902 1
a902 1
static void MD4Transform(uint32 Hash[4], uint32 x[16])
a903 2
	EMULE_TRY

a966 2

	EMULE_CATCH
@


1.109
log
@fix: upload auto priority isn't set to release anymore when completing file
@
text
@d1087 1
d1090 2
a1091 2
	if(srclist.IsEmpty())
		return 0;
d1093 2
a1094 2
	CMemFile data;
	uint16 nCount = 0;
d1096 2
a1097 2
	data.Write(forClient->m_reqFileHash, 16);
	data.Write(&nCount,2);
d1100 2
a1101 2
	//we are only taking 30 random sources since we can't be sure if they have parts we need
	//this is hard coded because its a temp solution until next(?) version
d1103 2
a1104 1
	for(int i = 0; i < 30; i++) {
d1106 1
d1108 1
d1110 3
a1112 2
		// LANCAST (moosetea) - We don't share Lan clients sources as they are private ips/userids
		if(!cur_src->IsOnLAN() && !cur_src->HasLowID() && cur_src != forClient)  {
d1118 4
a1121 4
			data.Write(&dwID,4);
			data.Write(&nPort,2);
			data.Write(&dwServerIP,4);
			data.Write(&nServerPort,2);
d1125 1
a1125 1
		if(srclist.GetSize() == 0)
d1128 7
a1134 4
	if (!nCount)
		return 0;
	data.Seek(16,0);
	data.Write(&nCount,2);
d1136 1
a1136 2
	Packet* result = new Packet(&data,OP_EMULEPROT);
	result->m_eOpcode = OP_ANSWERSOURCES;
d1138 3
a1140 2
		result->PackPacket();
	return result;
d1147 1
a1147 1
//For File Comment //
d1152 1
a1152 1
	CString buffer = HashToString(m_fileHash);
d1154 5
a1158 4
	CString fullpath;
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
	CIni ini( fullpath );
	ini.SetDefaultCategory(buffer);
d1161 1
a1161 1
	m_bCommentLoaded=true;
d1172 3
a1174 1
	CString buffer = HashToString(m_fileHash);
d1176 3
a1178 4
	CString fullpath;
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
	CIni ini( fullpath );
	ini.DeleteCategory(buffer);
d1191 3
a1193 1
	CString buffer = HashToString(m_fileHash);
d1195 3
a1197 4
	CString fullpath;
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
	CIni ini( fullpath );
	ini.SetDefaultCategory(buffer);
d1205 1
d1208 6
a1213 3
	for (POSITION pos = srclist.GetHeadPosition();pos != 0;srclist.GetNext(pos)){
		CUpDownClient *cur_src = srclist.GetAt(pos);
		cur_src->SetCommentDirty();
d1219 1
a1219 1
// For File rate
d1224 1
a1224 1
	CString buffer = HashToString(m_fileHash);
d1226 5
a1230 4
	CString fullpath;
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir());
	CIni ini( fullpath );
	ini.SetDefaultCategory(buffer);
d1239 7
a1245 3
	for (POSITION pos = srclist.GetHeadPosition();pos != 0;srclist.GetNext(pos)){
		CUpDownClient *cur_src = srclist.GetAt(pos);
		cur_src->SetCommentDirty();
a1250 1
//--- xrmb:parttraffic ---
@


1.108
log
@formatting, removed some ending space and minor changes
removed some menus memleak in sharedctrl
fixed new 'LATER' code
changed new paused/stopped file sorting
removed a space not meant to be there in french.rcu
update changelog
@
text
@d952 1
a952 1
		if (IsPartFile() && g_eMuleApp.m_pDownloadQueue && (!IsPaused() || !IsStopped()))
@


1.107
log
@Improved hash to string conversion
@
text
@d59 1
a59 1
		return CString("");
d176 3
a178 3
	statistic.fileParent=this;
	m_bCommentLoaded=false;
	m_iMoviePreviewMode=0;
d180 1
a180 1
	m_strComment="";
d182 4
a185 4
	m_nCompleteSourcesCount= 0;		//  netwolf: complete sources (zegzav) 13.05.03
	m_nCompleteSourcesCountLo= 0;
	m_nCompleteSourcesCountHi= 0;
	m_nCompleteSourcesTime= 0;
d191 1
a191 1
	m_sharedFile=false;
d965 1
a965 1
				{				
d969 1
a969 1
				{				
d972 1
a972 1
				else 
d984 1
a984 1
			{			
d988 1
a988 1
			{			
d1171 1
a1171 1
	m_strComment = "";
@


1.106
log
@Processing files with size = 0 modulo PARTSIZE (as a result impossible to receive hashset, impossible to complete such file, incorrect average speed report, etc.);
Improved hash to string conversion
@
text
@d47 1
a47 1
					EncodeBase16(GetFileHash(),16) );
d69 1
a69 1
					EncodeBase16(GetFileHash(),16),
@


1.105
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d355 1
a355 1
        	delete[] lasthash; // i_a: memleak
d437 2
a438 2
	//	If the number of hashes doesn't match the number of parts in the file...
		if (iNumParts != GetPartCount())
d589 1
a589 2
    bool		result;
    bool		hashset_ok = true;
d592 3
a594 3
    hashset_ok = LoadHashsetFromFile(file,false);	// (HASHSET)
    result = result && LoadTagsFromFile(file);		// <Tag_set>
    result = result && hashset_ok;
d598 1
a598 1
        AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_KNOWNHASHCORR), m_strFileName);
d600 1
a600 6
	// SLUGFILLER: hashlistRecheck - read all data before error-checking
	if(result)
		if (GetPartCount() != 1 && GetPartCount() != m_partHashArray.GetCount())
			result = false;
	// SLUGFILLER: hashlistRecheck
    if (result)
d602 3
a604 6
		if(CJumpstarter::ShouldBeEnabledForFile(this))
		{
            m_Jumpstarter = new CJumpstarter(this);
            AddLogLine(false, IDS_JS_ENABLED, m_strFileName);
        }
    }
d608 1
a608 1
    EMULE_CATCH
d858 16
d1144 1
a1144 1
	CString buffer = FileHashToString(m_fileHash);
d1163 1
a1163 1
	CString buffer = FileHashToString(m_fileHash);
d1181 1
a1181 1
	CString buffer = FileHashToString(m_fileHash);
d1209 1
a1209 1
	CString buffer = FileHashToString(m_fileHash);
@


1.104
log
@removed MOBILE_MULE and JUMPSTART defines + minor improvements (thx aw3)
@
text
@d236 1
a236 1
		int32 n= count.GetSize();
d242 3
a244 3
			int32 i= n >> 1;		// (n / 2)
			int32 j= (n * 3) >> 2;	// (n * 3) / 4
			int32 k= (n * 7) >> 3;	// (n * 7) / 8
d401 1
a401 1
	INT_PTR		iParts = static_cast<int16>(iNumParts);
d709 1
a709 1
		CFileTag		prioTag(FT_PRIORITY,static_cast<uint8>(PR_AUTO));
d1478 1
a1478 1
bool CKnownFile::LoadFromFileTraffic(FILE* file, uint8 version)
d1833 1
a1833 1
uint8	CKnownFile::GetPartStatus(uint16 part)
d1837 1
a1837 1
	uint8 r=PR_PART_ON;
d1856 1
a1856 1
	uint8       status;
d1875 1
a1875 1
	uint8		status;
d1899 1
a1899 1
		uint8 towrite = 0;
@


1.103
log
@Formatting, comments, and name changes.
Removed old #defines
@
text
@d28 1
a28 1
#include "QArray.h"	//netwolf: complete sources (zegzav) 13.05.03
a29 2

#if JUMPSTART
a30 2
#endif

a194 1
#if JUMPSTART
a195 1
#endif
a209 1
#if JUMPSTART
a211 1
#endif
a605 1
#if JUMPSTART
a613 1
#endif // JUMPSTART
a1916 1
#if JUMPSTART
a1950 2

#endif
@


1.102
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d957 1
a957 1
			CPartFile* pPartFile = (CPartFile*)this;
@


1.101
log
@upload auto priority sets very well spread files to low prio + minor changes + cleanup
@
text
@d804 1
a804 1
		memset2(&X[Required], 0, 64 - Required);
d808 1
a808 1
	memset2(&X[Required], 0, 56 - Required);
@


1.100
log
@stopped and paused files are not considered as partfile for upload auto priorities + some changes to avoid a bug with PR_AUTO in my last changes + minor changes about priorities
@
text
@d555 1
a555 1
					SetPriority(PR_VERYHIGH);
d957 1
a957 1
			CPartFile* pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(GetFileHash());
d964 3
a966 1
					SetPriority(PR_VERYHIGH);
d968 1
d970 3
a972 1
				else
d974 6
d987 3
a989 1
				SetPriority(PR_VERYHIGH);
d991 1
d993 5
d999 3
a1001 1
				SetPriority(PR_NORMAL);
@


1.99
log
@More Kush changes for localization, minor optimizations and fix for Upload AutoPriority.
@
text
@d35 1
a35 1
	
d109 1
a109 1
CFileStatistic::~CFileStatistic()	
d190 1
a190 1
	
d215 1
a215 1
	
d322 1
a322 1
	FILE		*file = _tfopen(strNameBuffer,_T("rbS"));	
d365 1
a365 1
	else 
d384 1
a384 1
	return true;	
d420 1
a420 1
			AddDebugLogLine(false, _T("Loaded hashset size is corrupt in known.met !"));		
d475 1
a475 1
		{	
d555 1
a555 1
					UpdateUploadAutoPriority();
d572 1
a572 1
		}	
d642 1
a642 1
	{	
d644 1
a644 1
			return false; 
d655 1
a655 1
	{	
d668 5
a672 5
	// Float meta tags are currently not written. All older eMule versions < 0.28a have 
	// a bug in the meta tag reading+writing code. To achive maximum backward 
	// compatibility for met files with older eMule versions we just don't write float 
	// tags. This is OK, because we (eMule) do not use float tags. The only float tags 
	// we may have to handle is the '# Sent' tag from the Hybrid, which is pretty 
d674 3
a676 3
	// 
	// The code for writing the float tags SHOULD BE ENABLED in SOME MONTHS (after most 
	// people are using the newer eMule versions which do not write broken float tags).	
d750 1
a750 1
void CKnownFile::CreateHashFromInput(FILE* file,CFile* file2, int Length, uchar* Output, uchar* in_string) 
d772 1
a772 1
		uint32 len = Required & ~63; 
d774 1
a774 1
		if (len > sizeof(X)) 
d784 2
a785 2
		{ 
			MD4Transform(Hash, (uint32*)(X + i)); 
d955 1
a955 1
		if (IsPartFile() && g_eMuleApp.m_pDownloadQueue)
d958 1
a958 1
		
d988 4
a991 4
void CAbstractFile::SetFileName(const CString& NewName) 
{	
	m_strFileName = NewName; 
	      		
d1001 1
a1001 1
	m_strFileName.Replace('\\','-');	
d1121 1
a1121 1
//For File Comment // 
d1126 4
a1129 4
	CString buffer = FileHashToString(m_fileHash); 	
	
	CString fullpath; 
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir()); 
d1132 1
a1132 1
	m_strComment = ini.GetString(_T("Comment"),_T("")); 
d1134 1
a1134 1
	m_bCommentLoaded=true;	
d1139 1
a1139 1
}    
d1145 1
a1145 1
	CString buffer = FileHashToString(m_fileHash); 
d1147 2
a1148 2
	CString fullpath; 
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir()); 
d1163 4
a1166 4
	CString buffer = FileHashToString(m_fileHash); 
	       
	CString fullpath; 
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir()); 
d1169 2
a1170 2
	    
	ini.SetString (_T("Comment"), strNewComment); 
d1172 1
a1172 1
	
d1174 1
a1174 1
	   
d1186 1
a1186 1
// For File rate 
d1191 4
a1194 4
	CString buffer = FileHashToString(m_fileHash); 	
	       	
	CString fullpath; 
	fullpath.Format(_T("%sfileinfo.ini"),g_eMuleApp.m_pGlobPrefs->GetConfigDir()); 
d1197 2
a1198 2
	    
	ini.SetInt (_T("Rate"), eNewRating); 
d1274 3
a1276 3
		if(EMBLOCKSIZE*(i+1) > fs) 
			s = fs % EMBLOCKSIZE; 
		
d1291 1
a1291 1
		if(EMBLOCKSIZE*(i+1) > fs) 
d1333 3
a1335 3
		if(EMBLOCKSIZE*(i+1) > fs) 
			s = fs % EMBLOCKSIZE; 
		
d1350 1
a1350 1
		if(EMBLOCKSIZE*(i+1) > fs) 
d1416 1
a1416 1
	
d1474 1
a1474 1
	
d1491 1
a1491 1
	
d1691 1
a1691 1
	
d1714 1
a1714 1
	
d1823 1
a1823 1
{ 
d1826 3
a1828 3
	uint8 r=PR_PART_ON; 
	if(m_partStatus.Lookup(part, r)) 
		return r; 
d1832 1
a1832 1
	return PR_PART_ON; 
@


1.98
log
@Aw3's MD4 optimization
@
text
@d557 4
@


1.97
log
@Stupid me! Tried to localize a debug string. :P
@
text
@a750 1
	bool PaddingStarted = false;
d768 1
a768 1
		uint32 len = Required / 64; 
d770 2
a771 2
		if (len > sizeof(X)/(64 * sizeof(X[0]))) 
			len = sizeof(X)/(64 * sizeof(X[0])); 
d773 1
a773 1
			data->Read(&X,len*64);
d775 1
a775 1
			fread(&X,len*64,1,file);
d777 3
a779 2
			file2->Read(&X,len*64); 
		for (uint32 i = 0; i < len; i++)
d781 4
a784 3
			MD4Transform(Hash, (uint32*)(X + i*64)); 
		} 
		Required -= len*64; 
a786 1
	Required = Length % 64;
d797 2
a798 1
	if (Required >= 56)
d800 1
a800 3
		X[Required] = 0x80;
		PaddingStarted = TRUE;
		memset2(&X[Required + 1], 0, 63 - Required);
d804 1
a804 3
	if (!PaddingStarted)
		X[Required++] = 0x80;
	memset2(&X[Required], 0, 64 - Required);
d806 2
a807 4
	uint32 Length2 = Length >> 29;
	Length <<= 3;
	memcpy2(&X[56], &Length, 4);
	memcpy2(&X[60], &Length2, 4);
@


1.96
log
@Some fixes, added debug log for file starting to be hashed.
@
text
@d331 1
a331 1
	AddDebugLogLine(false, RGB_LOG_DIMMED + GetResString(IDS_TOBEHASHED), m_strFileName);
@


1.95
log
@Fixed documents search
@
text
@d331 2
@


1.94
log
@Some improvements over Upload Auto Priority
@
text
@d1029 3
a1031 1
			case ED2KFT_ANY:
@


1.93
log
@Auto Upload Priority for completed files
@
text
@d173 6
a180 1
	m_bAutoPriority = false ;
d182 1
a182 1
	m_iMoviePreviewMode=0; // DonGato - Moview Preview Mode
d191 2
a192 2
	m_partHashArray.RemoveAll();	// just in case
	m_tagArray.RemoveAll();	// you never know
d282 1
a282 3
	if(g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
		UpdateUploadAutoPriority();

d711 1
a711 1
	if (/*IsPartFile() &&*/ IsAutoPrioritized())
@


1.92
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d276 4
d708 1
a708 1
	if (IsPartFile() && IsAutoPrioritized())
d949 1
a949 1
	if (IsAutoPrioritized() && g_eMuleApp.m_pDownloadQueue )
d951 3
a953 1
		CPartFile* partfile = g_eMuleApp.m_pDownloadQueue->GetFileByID(GetFileHash()) ;
d955 17
a971 3
		if (partfile != NULL && partfile->IsPartFile()) {
			int valid_sources = partfile->GetSourceCount() - partfile->GetNotCurrentSourcesCount();
			if (valid_sources < RARE_FILE)
d973 1
a973 1
			else if (valid_sources < 200)
d1883 2
a1884 1
		for (uint32 i = 0;i != 8;i++){
d1902 2
a1903 1
bool CKnownFile::IsJsComplete() {
d1907 4
a1910 2
void CKnownFile::SetJumpstartEnabled(bool enabled) {
    if(!enabled && m_Jumpstarter) {
d1914 3
a1916 1
    } else if(enabled && !m_Jumpstarter) {
d1921 2
a1922 1
void CKnownFile::AddSentBlock(CUpDownClient* client,uint32 start_offset, uint32 togo) {
d1926 2
a1927 1
void CKnownFile::WriteJumpstartPartStatus(CUpDownClient* client, CMemFile* data) {
d1931 2
a1932 1
bool CKnownFile::AllowChunkForClient(uint32 partNo, CUpDownClient* client) {
@


1.91
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d594 1
a594 1
        AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_KNOWNHASHCORR), m_strFileName);
d1452 1
a1452 1
		AddLogLine(true, RGB_RED + GetResString(IDS_TRAFFICDAT_CORRUPT));
d1469 1
a1469 1
		AddLogLine(true, RGB_RED + GetResString(IDS_TRAFFICDAT_CORRUPT));
@


1.90
log
@Added some colors to the logs...
@
text
@d407 1
a407 1
			AddDebugLogLine(false,_T("Loaded hashset size is corrupt in known.met, file: %s!"), m_strFileName);
d411 1
a411 1
			AddDebugLogLine(false,_T("Loaded hashset size is corrupt in known.met !"));		
d594 1
a594 1
        AddLogLine(false,_T("<COLOR=255,102,0>") + GetResString(IDS_ERR_KNOWNHASHCORR), m_strFileName);
d1452 1
a1452 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_TRAFFICDAT_CORRUPT));
d1469 1
a1469 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_TRAFFICDAT_CORRUPT));
@


1.89
log
@type mismatch (thanks netwolf)
@
text
@d594 1
a594 1
        AddLogLine(false,IDS_ERR_KNOWNHASHCORR, m_strFileName);
d1452 1
a1452 1
		AddLogLine(true, IDS_TRAFFICDAT_CORRUPT);
d1469 1
a1469 1
		AddLogLine(true, IDS_TRAFFICDAT_CORRUPT);
@


1.88
log
@fix for serch with new filetyp
@
text
@d103 1
a103 1
	m_iNumRequested = m_iNumTransferred = m_iNumAccepted = alltimerequested= alltimetransferred = alltimeaccepted = 0;
d156 1
a156 1
	m_iNumTransferred += bytes;
d1689 1
a1689 1
	m_iNumRequested=m_iNumTransferred=m_iNumAccepted=0;
d1769 1
a1769 1
	m_iNumTransferred	+= m->m_iNumTransferred;
@


1.87
log
@File Type correction & related name changes
@
text
@d988 1
a988 1
		EED2KFileType eFileType = GetED2KFileTypeID(m_strFileName);
@


1.86
log
@preventing invalid filename-chars with SetFileName()
@
text
@a169 1
	m_dwFileType = 2;	
d980 57
@


1.85
log
@BUGFIX: inability to remove shared file comment (#278)
@
text
@d497 2
a498 1
				m_strFileName = newtag->GetStringValue();
@


1.84
log
@minor PartPrio bugfix
@
text
@d1058 18
@


1.83
log
@free disk space needed is now determined with respect to NTFS compression and/or sparse files
@
text
@a1733 1
// DbT:StartUploadReq
d1739 4
d1756 1
a1756 1
// DbT:End
@


1.82
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d292 5
d314 1
@


1.81
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d819 2
a820 3

// Added by Tarod to push RF files
float CKnownFile::GetFileRatio()
d824 7
a830 7
	// MatzeHH formula I think is better than herbert's one (Tarod)
	if (g_eMuleApp.m_pKnownFilesList->GetTotalRequested()==0) return 1.0f;	//Cax2 bugfix
	if (statistic.GetRequests() == 0) return 2.0f ;
	float ratio;
	ratio = ((float)statistic.GetRequests()) / ((float)g_eMuleApp.m_pKnownFilesList->GetTotalRequested()) ;
	ratio = -4.0f * log10f((float)g_eMuleApp.m_pSharedFilesList->GetCount()) * ratio ;
	ratio = 2.0f * expf(ratio) ;
d832 12
a843 4
	if (ratio < 1.0f) {
		ratio = 1.0f;
	} else if (ratio > 2.0f)
		ratio = 2.0f ;
d845 1
a845 1
	return ratio ;
d849 1
a849 1
	return 1.0f;
d851 1
a851 2
// End by Tarod

d1626 2
a1627 2
	float	percentStart=((float)((part*PARTSIZE)%EMBLOCKSIZE)/EMBLOCKSIZE);
	float	percentEnd=0.0;
d1629 1
a1629 1
		percentEnd=1-((float)(((part+1)*PARTSIZE)%EMBLOCKSIZE)/EMBLOCKSIZE);
@


1.80
log
@added "return xxx" outside try & catch
@
text
@d974 1
a974 1
	g_eMuleApp.m_pUploadQueue->FindSourcesForFileById(&srclist, forClient->reqfileid); //should we use "fileHash"?
d982 1
a982 1
	data.Write(forClient->reqfileid, 16);
d994 1
a994 1
		if(!cur_src->isOnLAN() && !cur_src->HasLowID() && cur_src != forClient)  {
@


1.79
log
@no message
@
text
@d1520 2
d1537 2
@


1.78
log
@More fixes for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@d284 6
a289 7
#ifndef ASYNC_UI_UPDATES
	g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.UpdateFileItem(dynamic_cast<CKnownFile*>(this));
#else
	g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.PostMessage( WM_SFL_UPDATEITEM,
																			   static_cast<WPARAM>(g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.IsWindowVisible()),
																			   reinterpret_cast<LPARAM>(dynamic_cast<CKnownFile*>(this)) );
#endif ASYNC_UI_UPDATES
@


1.77
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d285 1
a285 1
	g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.UpdateItem(dynamic_cast<CKnownFile*>(this));
@


1.76
log
@Formatting, comments, and name changes.
@
text
@d787 1
a787 1
		memset(&X[Required + 1], 0, 63 - Required);
d793 1
a793 1
	memset(&X[Required], 0, 64 - Required);
@


1.75
log
@Shouldn't try programming sober. Sorry.
@
text
@d179 1
a179 1
	m_iRate=0;
d1039 1
a1039 1
	m_iRate = ini.GetInt(_T("Rate"), 0);//For rate
d1075 1
a1075 1
void CKnownFile::SetFileRate(int8 iNewRate)
d1086 2
a1087 2
	ini.SetInt (_T("Rate"), iNewRate); 
	m_iRate = iNewRate;
@


1.74
log
@Formatting, comments, and name changes.
@
text
@d670 1
a670 1
	nameTag->WriteToFile(file);							// (FT_FILENAME:string) file name
d674 1
a674 1
	sizeTag->WriteToFile(file);							// (FT_FILESIZE:int) file size (bytes)
a698 1
	CFileTag* priotag;
d703 1
a703 1
		prioTag->WriteToFile(file);
d709 1
a709 1
		prioTag->WriteToFile(file);
@


1.73
log
@Fix for new code not using morevit code
@
text
@d42 2
a43 1

d46 7
a52 6
	CString strLink;
	strLink.Format(_T("ed2k://|file|%s|%u|%s|/"),
		g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
		GetFileSize(),
		EncodeBase16(GetFileHash(),16)	// netwolf 17.05.03
		);
d55 1
a55 1

d58 2
a59 1
	uint32 dwID = 0;
d61 2
a62 1
	if (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID()){
d67 13
a79 6
	CString strLink;
	strLink.Format(_T("ed2k://|file|%s|%u|%s|/|sources,%i.%i.%i.%i:%i|/"),	// netwolf 17.05.03
		g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
		GetFileSize(),
		EncodeBase16(GetFileHash(),16),	// netwolf 17.05.03
		(uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), g_eMuleApp.m_pGlobPrefs->GetListenPort()); //Maverick
d82 1
a82 1

d87 1
a87 3

//--- xrmb:parttraffic ---
//--- i don't like code in header files ---
d90 1
d93 2
a94 2
	partTraffic=NULL;
	partTrafficSession=NULL;
d96 2
a97 2
	blockTraffic=NULL;
	blockTrafficSession=NULL;
d99 2
a100 2
	partAccepted=NULL;
	partAcceptedSession=NULL;
d102 1
a102 1
	completeReleases=0.0;
d108 1
a108 1

d113 2
a114 2
	if(partTraffic)				delete[] partTraffic;			partTraffic=NULL;
	if(partTrafficSession)		delete[] partTrafficSession;	partTrafficSession=NULL;
d116 2
a117 2
	if(partAccepted)			delete[] partAccepted;			partAccepted=NULL;
	if(partAcceptedSession)		delete[] partAcceptedSession;	partAcceptedSession=NULL;
d119 2
a120 2
	if(blockTraffic)			delete[] blockTraffic;			blockTraffic=NULL;
	if(blockTrafficSession)		delete[] blockTrafficSession;	blockTrafficSession=NULL;
d124 1
a124 2
//--- :xrmb ---

d139 1
a139 1
	
d151 2
a152 2
	
void CFileStatistic::AddTransferd(uint32 bytes)
d163 2
d166 2
d200 1
a200 1

d219 1
a219 2

// netwolf complete sources (zegzav) - BEGIN
a280 1
// netwolf complete sources (zegzav) - END
d293 1
a293 1
bool CKnownFile::CreateFromFile(const CString& in_directory,const CString& in_filename)
d305 1
a305 1
	directory = in_directory;
d307 1
a307 1
	CString namebuffer;
d309 1
a309 1
	namebuffer.Format(_T("%s\\%s"),in_directory,in_filename);
d311 1
a311 1
	FILE* file = _tfopen(namebuffer,_T("rbS"));	
d317 1
a317 1
	m_strFileName = in_filename;
d321 1
a321 1
	uint32		togo = m_lFileSize;
d323 1
a323 1
	for (uint16 hashcount = 0; togo >= PARTSIZE;)
d325 1
a325 1
		uchar* newhash = new uchar[16];
d327 1
a327 1
		md4clr(newhash);	//SyruS needed or not...?
d330 2
a331 2
		CreateHashFromFile(file,PARTSIZE,newhash);
		//SyruS SLUGFILLER: SafeHash - quick fallback
d335 1
a335 1
			delete[] newhash;
d338 1
a338 1
		// SLUGFILLER: SafeHash
d340 3
a342 3
		m_partHashArray.Add(newhash);
		togo -= PARTSIZE;
		hashcount++;
d346 2
a347 2
	CreateHashFromFile(file,togo,lasthash);
	if (!hashcount)
d389 1
a389 1
	file.Read(&checkid,16);
d394 1
a394 1
	file.Read(&iNumParts,2);
d396 1
a396 1
	INT_PTR		iParts = (int16)iNumParts;
d418 1
a418 1
		file.Read(pHash,16);
d475 1
a475 1
//	LoadTagsFromFile() parses what tags we know, stores the rest in 'm_tagArray'.
d480 1
a480 1
	uint32		iNumTags;
d482 1
a482 1
	file.Read(&iNumTags,4);
d484 1
a484 1
	for (uint32 j = 0; j != iNumTags; j++)
d490 1
a490 1
			case FT_FILENAME:
d496 1
a496 1
			case FT_FILESIZE:
d502 1
a502 1
			case FT_ATTRANSFERRED:
d508 1
a508 1
			case FT_ATTRANSFERREDHI:
d510 10
a519 7
				uint32 hi,low;
				low = statistic.alltimetransferred;
				hi = newtag->GetIntValue();
				uint64 hi2;
				hi2 = hi;
				hi2 = hi2<<32;
				statistic.alltimetransferred = low+hi2;
d523 1
a523 1
			case FT_ATREQUESTED:
d529 1
a529 1
 			case FT_ATACCEPTED:
d535 1
a535 1
			case FT_PRIORITY:
d546 1
a546 1
			case FT_PERMISSIONS:
d582 3
a584 3
	result = LoadDateFromFile(file);
    hashset_ok = LoadHashsetFromFile(file,false);
    result = result && LoadTagsFromFile(file);
d587 2
a588 1
    if(!hashset_ok && !m_strFileName.IsEmpty())	//Cax2 - if m_strFileName==NULL, don't report it, it should still be ok...
d618 6
a623 4
	CSingleLock Lock(&m_mutexHashList,TRUE);
	uint16 parts = m_partHashArray.GetCount();
	// It's safer to do a check first to avoid file corruption
	for (int i = 0; i < parts; i++)
d625 1
a625 1
		if(m_partHashArray[i] == NULL)
d629 4
a632 5
	// date
	fwrite(&m_timetLastWriteDate,4,1,file);

	// hashset
	fwrite(&m_fileHash,16,1,file);
d634 1
a634 1
	fwrite(&parts,2,1,file);
d636 1
a636 1
	for (i = 0; i < parts; i++)
d638 1
a638 1
		fwrite(m_partHashArray[i],16,1,file);	
d661 1
a661 1
		if (m_tagArray[j]->GetType() == 2 || m_tagArray[j]->GetType() == 3)
d664 9
d674 1
a674 2
	// standard tags
	fwrite(&tagcount,4,1,file);
d676 6
a681 5
	CFileTag nametag(FT_FILENAME, m_strFileName);
	nametag.WriteToFile(file);
	
	CFileTag sizetag(FT_FILESIZE, m_lFileSize);
	sizetag.WriteToFile(file);
a682 4
	// statistic
	uint32 tran;
	tran=statistic.GetAllTimeTransferred();
	CFileTag attag1(FT_ATTRANSFERRED, tran);
d684 4
a687 2
	tran=statistic.alltimetransferred>>32;
	CFileTag attag4(FT_ATTRANSFERREDHI, tran);
d690 2
a691 1
	CFileTag attag2(FT_ATREQUESTED,statistic.GetAllTimeRequests());
d694 2
a695 1
	CFileTag attag3(FT_ATACCEPTED,statistic.GetAllTimeAccepts());
d697 6
d704 5
a708 3
	// priority N permission
	CFileTag priotag(FT_ULPRIORITY, IsAutoPrioritized() ? PR_AUTO : m_iPriority);
	priotag.WriteToFile(file);
d710 4
a713 2
	CFileTag permtag(FT_PERMISSIONS, m_iPermissions);
	permtag.WriteToFile(file);
d715 3
a717 1
	//other tags
d720 1
a720 1
		if (m_tagArray[j]->GetType() == 2 || m_tagArray[j]->GetType() == 3)
@


1.72
log
@some fixes in save of  known.met
@
text
@d652 2
a653 2
	CTag nametag(FT_FILENAME, m_strFileName);
	nametag.WriteTagToFile(file);
d655 2
a656 2
	CTag sizetag(FT_FILESIZE, m_lFileSize);
	sizetag.WriteTagToFile(file);
d674 2
a675 2
	CTag priotag(FT_ULPRIORITY, IsAutoPrioritized() ? PR_AUTO : m_iPriority);
	priotag.WriteTagToFile(file);
@


1.71
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d652 5
a656 7
	CFileTag* nametag = new CFileTag(FT_FILENAME,m_strFileName);
	nametag->WriteToFile(file);
	delete nametag;

	CFileTag* sizetag = new CFileTag(FT_FILESIZE,m_lFileSize);
	sizetag->WriteToFile(file);
	delete sizetag;
d674 2
a675 7
	CFileTag* priotag;
	if (IsPartFile() && IsAutoPrioritized())
		priotag = new CFileTag(FT_PRIORITY, (uint8)PR_AUTO);
	else
		priotag = new CFileTag(FT_PRIORITY, m_iPriority);
	priotag->WriteToFile(file);
	delete priotag;
@


1.70
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d124 3
a126 1
		g_eMuleApp.m_pSharedFilesList->UpdateItem(fileParent,g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.IsWindowVisible());
d138 1
a138 1
	g_eMuleApp.m_pSharedFilesList->UpdateItem(fileParent,g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.IsWindowVisible());
d150 1
a150 1
	g_eMuleApp.m_pSharedFilesList->UpdateItem(fileParent,g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.IsWindowVisible());
d265 1
a265 2

	g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.sharedfilesctrl.UpdateItem(this);
d271 11
d1276 1
a1276 1
	g_eMuleApp.m_pSharedFilesList->UpdateItem(fileParent,g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.IsWindowVisible());
@


1.69
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d29 1
a29 1
#include "memcpy_amd.h"
d155 1
a155 1
	filetype = 2;	
@


1.68
log
@Formatting, comments, and name changes.
@
text
@d463 1
a463 1
		CTag		*newtag = new CTag(file);
d640 2
a641 2
	CTag* nametag = new CTag(FT_FILENAME,m_strFileName);
	nametag->WriteTagToFile(file);
d644 2
a645 2
	CTag* sizetag = new CTag(FT_FILESIZE,m_lFileSize);
	sizetag->WriteTagToFile(file);
d651 2
a652 2
	CTag attag1(FT_ATTRANSFERRED, tran);
	attag1.WriteTagToFile(file);
d654 2
a655 2
	CTag attag4(FT_ATTRANSFERREDHI, tran);
	attag4.WriteTagToFile(file);
d657 2
a658 2
	CTag attag2(FT_ATREQUESTED,statistic.GetAllTimeRequests());
	attag2.WriteTagToFile(file);
d660 2
a661 2
	CTag attag3(FT_ATACCEPTED,statistic.GetAllTimeAccepts());
	attag3.WriteTagToFile(file);
d664 1
a664 1
	CTag* priotag;
d666 1
a666 1
		priotag = new CTag(FT_PRIORITY, (uint8)PR_AUTO);
d668 2
a669 2
		priotag = new CTag(FT_PRIORITY, m_iPriority);
	priotag->WriteTagToFile(file);
d672 2
a673 2
	CTag permtag(FT_PERMISSIONS, m_iPermissions);
	permtag.WriteTagToFile(file);
d679 1
a679 1
			m_tagArray[j]->WriteTagToFile(file);
d976 1
a976 1
	result->opcode = OP_ANSWERSOURCES;
@


1.67
log
@Reverted a change. :-(
@
text
@d463 1
a463 1
		CTag *newtag = new CTag(file);
d609 1
d611 1
@


1.66
log
@Changes from official about handling of known.met
@
text
@a293 1
	m_strFilePath = namebuffer;
a555 1

d572 1
a572 1
        if(CJumpstarter::ShouldBeEnabledForFile(this) && PathFileExists(m_strFilePath))
@


1.65
log
@Fixed a NEW_SOCKETS compiler warning.
@
text
@d294 1
d464 1
a464 1
		CTag		*newtag = new CTag(file);
d486 12
d557 2
a558 1
    result = LoadDateFromFile(file);
d574 1
a574 1
        if(CJumpstarter::ShouldBeEnabledForFile(this))
d601 1
d603 2
a604 1
	fwrite(&m_timetLastWriteDate,4,1,file); 
d609 1
a610 1
	{	
a611 1
	}
d614 5
d620 17
a636 1
	uint32 tagcount = m_tagArray.GetCount()+7;
d639 1
d643 1
d647 1
d649 3
a651 1
	CTag attag1(FT_ATTRANSFERRED,statistic.GetAllTimeTransferred());
d653 4
d659 1
d662 1
d671 1
d674 8
a681 3
		//other tags
	for (uint32 j = 0; j != tagcount-7;j++)
		m_tagArray[j]->WriteTagToFile(file);
a1743 2


a1773 1

@


1.64
log
@Formatting, comments, and name changes.
@
text
@d56 1
a56 1
	uint32 dwID;
@


1.63
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d93 1
a93 1
	requested = transferred = accepted = alltimerequested= alltimetransferred = alltimeaccepted = 0;
d120 1
a120 1
	requested++;
d122 1
a122 1
	g_eMuleApp.m_pKnownFilesList->requested++;
d133 1
a133 1
	accepted++;
d135 1
a135 1
	g_eMuleApp.m_pKnownFilesList->accepted++;
d145 1
a145 1
	transferred += bytes;
d147 1
a147 1
	g_eMuleApp.m_pKnownFilesList->transferred += bytes;
d157 1
a157 1
	date = 0;
d172 2
a173 2
	hashlist.RemoveAll();	// just in case
	taglist.RemoveAll();	// you never know
d189 4
a192 4
	CSingleLock Lock(&m_hashlistMutex,TRUE);
	for (int i = 0; i < hashlist.GetSize(); i++)
		if (hashlist[i])
			delete[] hashlist[i];
d194 2
a195 2
	for (int i = 0; i < taglist.GetSize(); i++)
		safe_delete(taglist[i]);
d316 2
a317 2
		CSingleLock Lock(&m_hashlistMutex,TRUE);
		hashlist.Add(newhash);
d331 6
a336 6
		CSingleLock Lock(&m_hashlistMutex,TRUE);
		hashlist.Add(lasthash);
		uchar* buffer = new uchar[hashlist.GetCount()*16];
		for (int i = 0;i < hashlist.GetCount();i++)
			md4cpy(buffer+(i*16),hashlist[i]);
		CreateHashFromString(buffer,hashlist.GetCount()*16,m_fileHash);
d345 1
a345 1
	date = fileinfo.st_mtime;
d355 4
a358 2
// needed for memfiles. its probably better to switch everything to CFile...
bool CKnownFile::LoadHashsetFromFile(CFile& file, bool checkhash)
d360 1
d363 3
a365 1
	uchar checkid[16];
d367 9
a375 4
	uint16	parts;
	file.Read(&parts,2);
	INT_PTR iParts = (int16)parts;
	if ( iParts < 0 )		//Cax2 - why?
d379 1
a379 1
		//	TODO: Add some way to tell if the file is known.met or a memfile.
d387 10
a396 5
	CSingleLock Lock(&m_hashlistMutex,TRUE);
	for (int i = 0; i < parts; i++){
		uchar* cur_hash = new uchar[16];
		file.Read(cur_hash,16);
		hashlist.Add(cur_hash);
d398 3
a400 2
	// SLUGFILLER: hashlistRecheck - always check hashlist
	if (!checkhash){
d402 1
a402 1
		if (!parts) // nothing to check
d405 11
a415 7
	else {
	if (!parts) // data not sent
		return false;
	if (parts != GetPartCount()){ // part count mismatch
		for (int i = 0; i < hashlist.GetSize(); i++)
		delete[] hashlist[i];
		hashlist.RemoveAll();
a416 1
			}
d418 1
d422 8
a429 5
	if (!hashlist.IsEmpty()){
		uchar* buffer = new uchar[hashlist.GetCount()*16];
		for (int i = 0;i < hashlist.GetCount();i++)
			md4cpy(buffer+(i*16),hashlist[i]);
		CreateHashFromString(buffer,hashlist.GetCount()*16,checkid);
d432 2
a433 1
	if (!md4cmp(m_fileHash,checkid))
d437 2
a438 1
		for (int i = 0; i < hashlist.GetSize(); i++)
d440 2
a441 2
			delete[] hashlist[i];
			hashlist[i]= NULL;	// most likely this is needless, but on the other hand...
d443 1
a443 1
		hashlist.RemoveAll();
d451 3
a453 2

bool CKnownFile::LoadTagsFromFile(CFile& file)
d457 12
a468 6
	uint32 tagcount;
	file.Read(&tagcount,4);
	for (uint32 j = 0; j != tagcount;j++){
		CTag* newtag = new CTag(file);
		switch(newtag->GetSpecialTag()){
			case FT_FILENAME:{
d473 2
a474 1
			case FT_FILESIZE:{
d479 2
a480 1
			case FT_ATTRANSFERRED:{
d485 2
a486 1
			case FT_ATREQUESTED:{
d491 2
a492 1
 			case FT_ATACCEPTED:{
d497 2
a498 1
			case FT_PRIORITY:{
d500 2
a501 1
				if (m_iPriority == PR_AUTO) {
d508 2
a509 1
			case FT_PERMISSIONS:{
d515 1
a515 1
				taglist.Add(newtag);
d524 1
a524 1

d529 1
a529 1
	file.Read(&date,4);
d536 1
a536 1

d541 2
a542 2
    bool result;
    bool hashset_ok = true;
d554 1
a554 1
		if (GetPartCount() != 1 && GetPartCount() != hashlist.GetCount())
d558 4
a561 2
    if(result) {
        if(CJumpstarter::ShouldBeEnabledForFile(this)) {
d574 1
a574 1

d579 2
a580 2
	CSingleLock Lock(&m_hashlistMutex,TRUE);
	uint16 parts = hashlist.GetCount();
d584 1
a584 1
		if(hashlist[i] == NULL)
d588 1
a588 1
	fwrite(&date,4,1,file); 
d595 1
a595 1
		fwrite(hashlist[i],16,1,file);	
d600 1
a600 1
	uint32 tagcount = taglist.GetCount()+7;
d628 1
a628 1
		taglist[j]->WriteTagToFile(file);
d716 2
a717 2
	//CSingleLock Lock(&m_hashlistMutex,TRUE);
	if (part >= hashlist.GetCount())
d720 1
a720 1
	return hashlist[part];
d1505 1
a1505 1
	requested=transferred=accepted=0;
d1575 1
a1575 1
bool	CFileStatistic::merge(CFileStatistic *m)
d1583 3
a1585 3
	requested	+= m->requested;
	accepted	+= m->accepted;
	transferred	+= m->transferred;
d1668 2
a1669 2
	//CSingleLock Lock(&m_hashlistMutex,TRUE);
	uint16 parts = hashlist.GetCount();
@


1.62
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d662 2
a663 7
	#ifndef AMD
	memcpy(&X[56], &Length, 4);
	memcpy(&X[60], &Length2, 4);
	#else
	memcpy_amd(&X[56], &Length, 4);
	memcpy_amd(&X[60], &Length2, 4);
	#endif
@


1.61
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d47 1
a47 1
		theApp.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
d58 1
a58 1
	if (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID()){
d61 1
a61 1
	dwID = theApp.serverconnect->GetClientID();
d65 1
a65 1
		theApp.StripInvalidFilenameChars(GetFileName(), false),	// spaces to dots
d68 1
a68 1
		(uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), theApp.glob_prefs->GetListenPort()); //Maverick
d74 1
a74 1
	return CString(_T("<a href=\"") + CreateED2kLink() + _T("\">") + theApp.StripInvalidFilenameChars(GetFileName(), true) + _T("</a>"));
d122 3
a124 3
	theApp.knownfiles->requested++;
	if (::IsWindow(theApp.emuledlg->sharedfileswnd.m_hWnd))	//fix crash at exit [TwoBottle Mod]
		theApp.sharedfiles->UpdateItem(fileParent,theApp.emuledlg->sharedfileswnd.IsWindowVisible());
d135 2
a136 2
	theApp.knownfiles->accepted++;
	theApp.sharedfiles->UpdateItem(fileParent,theApp.emuledlg->sharedfileswnd.IsWindowVisible());
d147 2
a148 2
	theApp.knownfiles->transferred += bytes;
	theApp.sharedfiles->UpdateItem(fileParent,theApp.emuledlg->sharedfileswnd.IsWindowVisible());
d215 1
a215 1
		theApp.clientlist->GetClientListByFileID(&clientuploadlist, GetFileHash());
d264 1
a264 1
	theApp.emuledlg->sharedfileswnd.sharedfilesctrl.UpdateItem(this);
d309 1
a309 1
		if (!theApp.emuledlg->IsRunning())	// in case of shutdown while still hashing
d697 1
a697 1
	if (theApp.knownfiles->GetTotalRequested()==0) return 1.0f;	//Cax2 bugfix
d700 2
a701 2
	ratio = ((float)statistic.GetRequests()) / ((float)theApp.knownfiles->GetTotalRequested()) ;
	ratio = -4.0f * log10f((float)theApp.sharedfiles->GetCount()) * ratio ;
d804 1
a804 1
	if (IsAutoPrioritized() && theApp.downloadqueue )
d806 1
a806 1
		CPartFile* partfile = theApp.downloadqueue->GetFileByID(GetFileHash()) ;
d845 1
a845 1
	theApp.uploadqueue->FindSourcesForFileById(&srclist, forClient->reqfileid); //should we use "m_fileHash"?
d905 1
a905 1
	fullpath.Format(_T("%sfileinfo.ini"),theApp.glob_prefs->GetConfigDir()); 
d924 1
a924 1
	fullpath.Format(_T("%sfileinfo.ini"),theApp.glob_prefs->GetConfigDir()); 
d934 1
a934 1
	theApp.uploadqueue->FindSourcesForFileById(&srclist, GetFileHash());
d952 1
a952 1
	fullpath.Format(_T("%sfileinfo.ini"),theApp.glob_prefs->GetConfigDir()); 
d962 1
a962 1
	theApp.uploadqueue->FindSourcesForFileById(&srclist, GetFileHash());
d1175 1
a1175 1
	theApp.sharedfiles->UpdateItem(fileParent,theApp.emuledlg->sharedfileswnd.IsWindowVisible());
@


1.60
log
@Implemented ConfigDir
@
text
@d93 1
a93 1
	requested = transfered = accepted = alltimerequested= alltimetransfered = alltimeaccepted = 0;
d145 3
a147 3
	transfered += bytes;
	alltimetransfered += bytes;
	theApp.knownfiles->transfered += bytes;
d156 1
a156 1
	filesize = 0;
d178 1
a178 1
	md4clr(filehash);
d269 1
a269 2


d274 8
a281 3
	// TODO Errorhandling
	//first create the filehashset
	// open file
d285 1
d287 1
d289 2
d293 9
a301 6
	// set filesize + name
	filename = in_filename;
	filesize =_filelength(file->_file);
	// create hashset
	uint32 togo = filesize;
	for (uint16 hashcount = 0;togo >= PARTSIZE;) {
d303 1
d305 2
d309 2
a310 1
		if (!theApp.emuledlg->IsRunning()){ // in case of shutdown while still hashing
d326 1
a326 1
		md4cpy(filehash,lasthash);
d336 1
a336 1
		CreateHashFromString(buffer,hashlist.GetCount()*16,filehash);
d354 1
a354 2


d367 1
a367 1
		if (!filename.IsEmpty() )
d369 2
a370 1
			AddDebugLogLine(false,_T("Loaded hashset size is corrupt in known.met, file: %s!"), filename);
d385 1
a385 1
		md4cpy(filehash,checkid);
d409 1
a409 1
	if (!md4cmp(filehash,checkid))
d437 1
a437 1
				filename = newtag->GetStringValue();
d442 1
a442 1
				filesize = newtag->GetIntValue();
d446 2
a447 2
			case FT_ATTRANSFERED:{
				statistic.alltimetransfered = newtag->GetIntValue();
d510 2
a511 2
    if(!hashset_ok && !filename.IsEmpty())	//Cax2 - if filename==NULL, don't report it, it should still be ok...
        AddLogLine(false,IDS_ERR_KNOWNHASHCORR, filename);
d522 1
a522 1
            AddLogLine(false, IDS_JS_ENABLED, filename);
d549 1
a549 1
	fwrite(&filehash,16,1,file);
d562 1
a562 1
	CTag* nametag = new CTag(FT_FILENAME,filename);
d565 1
a565 1
	CTag* sizetag = new CTag(FT_FILESIZE,filesize);
d569 1
a569 1
	CTag attag1(FT_ATTRANSFERED,statistic.GetAllTimeTransfered());
d594 3
a596 1

d604 1
d609 1
d611 1
d614 1
d617 3
a619 1
	while (Required >= 64){
d621 1
d638 2
a639 1
	if (Required != 0){
d648 2
a649 1
	if (Required >= 56){
d675 1
d721 1
a721 1
	return (filesize/PARTSIZE) + ((filesize % PARTSIZE)? 1:0);
d825 1
a825 1
	filename = NewName; 
d827 6
a832 6
	filename.Replace('/','-');
	filename.Replace('>','-');
	filename.Replace('<','-');
	filename.Replace('*','-');
	filename.Replace(':','-');
	filename.Replace('?','-');
d834 3
a836 3
	filename.Replace('|','-');
	filename.Replace('\"','-');
	filename.Replace('\\','-');	
d845 1
a845 1
	theApp.uploadqueue->FindSourcesForFileById(&srclist, forClient->reqfileid); //should we use "filehash"?
d902 1
a902 1
	CString buffer = FileHashToString(filehash); 	
d921 1
a921 1
	CString buffer = FileHashToString(filehash); 
d949 1
a949 1
	CString buffer = FileHashToString(filehash);
d1281 1
a1281 1
	return (filesize/EMBLOCKSIZE) + ((filesize % EMBLOCKSIZE)? 1:0);
d1295 2
a1296 2
	if(start>filesize) return 0;
	if(end>filesize) end=filesize;
d1340 2
a1341 2
	if(start>filesize) return 0;
	if(end>filesize) end=filesize;
d1415 1
a1415 1
	return filesize % PARTSIZE;
d1429 1
a1429 1
	return filesize % EMBLOCKSIZE;
d1452 1
a1452 1
		alltimerequested=alltimetransfered=alltimeaccepted=0;
d1469 1
a1469 1
	requested=transfered=accepted=0;
d1529 1
a1529 1
void CFileStatistic::AddAll(uint32 _alltimerequested, uint32 _alltimeaccepted, uint64 _alltimetransfered)
d1533 1
a1533 1
	alltimetransfered	+= _alltimetransfered;
d1545 1
a1545 1
	alltimetransfered	+= m->alltimetransfered;
d1549 1
a1549 1
	transfered	+= m->transfered;
@


1.59
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d878 1
a878 1
	fullpath.Format(_T("%sfileinfo.ini"),theApp.glob_prefs->GetAppDir()); 
d897 1
a897 1
	fullpath.Format(_T("%sfileinfo.ini"),theApp.glob_prefs->GetAppDir()); 
d922 1
a922 1
	CString buffer = FileHashToString(filehash); 	
d925 1
a925 1
	fullpath.Format(_T("%sfileinfo.ini"),theApp.glob_prefs->GetAppDir()); 
@


1.58
log
@small update cs0.07a
@
text
@d1004 3
a1006 3
		uint32 s=BLOCKSIZE;
		if(BLOCKSIZE*(i+1) > fs) 
			s = fs % BLOCKSIZE; 
d1021 3
a1023 3
		uint32 s=BLOCKSIZE;
		if(BLOCKSIZE*(i+1) > fs) 
			s = fs % BLOCKSIZE;
d1048 2
a1049 2
	uint32	startBlock=(part*PARTSIZE)/BLOCKSIZE;
	uint32	endBlock=((part+1)*PARTSIZE)/BLOCKSIZE;
d1063 3
a1065 3
		uint32 s=BLOCKSIZE;
		if(BLOCKSIZE*(i+1) > fs) 
			s = fs % BLOCKSIZE; 
d1080 3
a1082 3
		uint32 s=BLOCKSIZE;
		if(BLOCKSIZE*(i+1) > fs) 
			s = fs % BLOCKSIZE;
d1092 1
a1092 1
	return completePartReleases/(fileParent->GetPartSize(part)/BLOCKSIZE);
d1130 1
a1130 1
	uint32	block=start/BLOCKSIZE;
d1133 1
a1133 1
	uint32 b1=min((block+1)*BLOCKSIZE-start, bytes);
d1140 2
a1141 2
		blockTraffic[block]+=btg % BLOCKSIZE;
		blockTrafficSession[block]+=btg % BLOCKSIZE;
d1143 1
a1143 1
		btg-=BLOCKSIZE;
d1254 1
a1254 1
	return (filesize/BLOCKSIZE) + ((filesize % BLOCKSIZE)? 1:0);
d1277 1
a1277 1
	uint32	block=start/BLOCKSIZE;
d1283 2
a1284 2
		if(end-pos > end % BLOCKSIZE)
			bftb=BLOCKSIZE;
d1286 2
a1287 2
			bftb=end % BLOCKSIZE;
		bftb-=pos % BLOCKSIZE;
d1289 1
a1289 1
		if(bftb != BLOCKSIZE)
d1400 1
a1400 1
		return BLOCKSIZE;
d1402 1
a1402 1
	return filesize % BLOCKSIZE;
d1458 3
a1460 3
	uint32	blockStart=(part*PARTSIZE)/BLOCKSIZE;
	uint32	blockEnd=min((((uint32)part+1)*PARTSIZE)/BLOCKSIZE+1, blocks-1);
	float	percentStart=((float)((part*PARTSIZE)%BLOCKSIZE)/BLOCKSIZE);
d1463 1
a1463 1
		percentEnd=1-((float)(((part+1)*PARTSIZE)%BLOCKSIZE)/BLOCKSIZE);
@


1.57
log
@share files with soft limit
@
text
@d216 1
d224 2
d230 6
a235 2
			m_nCompleteSourcesCount= count.GetAt(n / 2);	// median value
			if (n <= 3)
d237 1
d241 1
a241 1
			else if (n == 4)
d243 11
a253 4
				m_nCompleteSourcesCountLo= count.GetAt((n / 2) - 1);
				m_nCompleteSourcesCountHi= m_nCompleteSourcesCount;
		}
		else
d255 3
a257 2
				m_nCompleteSourcesCountLo= count.GetAt((n / 2) - 1);
				m_nCompleteSourcesCountHi= count.GetAt((n / 2) + 1);
@


1.56
log
@changed INI file interface + little bugfix
@
text
@d183 1
d1644 1
@


1.55
log
@updated complete sources (0.06b: display range of values)
@
text
@d862 3
a864 2
	CIni ini( fullpath, buffer); 
	m_strComment = ini.GetString(_T("Comment")); 
d868 2
d881 2
a882 1
	CIni ini( fullpath, buffer ); 
d884 1
a884 1
	ini.WriteString (_T("Comment"), strNewComment); 
d887 1
d909 2
a910 1
	CIni ini( fullpath, buffer ); 
d912 4
a915 2
	ini.WriteInt (_T("Rate"), iNewRate); 
	m_iRate = iNewRate; 	
@


1.54
log
@unicode cleanup
@
text
@d168 2
a170 1
	m_nCompleteSourcesAccuracy= 0;
d213 1
a213 1
		m_nCompleteSourcesCount= 0;
d219 1
a219 1
			if ((cur_count) && ((::GetTickCount() - cur_src->GetLastUpRequest()) < 30*60*1000))	// 30 min.
a225 1
			// m_nCompleteSourcesCount= ((n == 1) ? count.GetAt(0) : count.GetAt((n + 1) / 2));	// median value
d227 9
a236 10
		if (n >= 50)
			m_nCompleteSourcesAccuracy= 5;	// 50+
		else if (n >= 30)
			m_nCompleteSourcesAccuracy= 4;	// 30-49
		else if (n >= 20)
			m_nCompleteSourcesAccuracy= 3;	// 20-29
		else if (n >= 10)
			m_nCompleteSourcesAccuracy= 2;	// 10-19
		else if (n >= 5)
			m_nCompleteSourcesAccuracy= 1;	// 5-9
d238 6
a243 1
			m_nCompleteSourcesAccuracy= 0;	// 0-4
@


1.53
log
@char * to CString conversion
@
text
@d46 1
a46 1
	strLink.Format("ed2k://|file|%s|%u|%s|/",
d64 1
a64 1
	strLink.Format("ed2k://|file|%s|%u|%s|/|sources,%i.%i.%i.%i:%i|/",	// netwolf 17.05.03
d74 1
a74 1
	return CString("<a href=\"" + CreateED2kLink() + "\">" + theApp.StripInvalidFilenameChars(GetFileName(), true) + "</a>");
d260 2
a261 2
	namebuffer.Format("%s\\%s",in_directory,in_filename);
	FILE* file = _tfopen(namebuffer,"rbS");	
d334 1
a334 1
			AddDebugLogLine(false,"Loaded hashset size is corrupt in known.met, file: %s!", filename);
d338 1
a338 1
			AddDebugLogLine(false,"Loaded hashset size is corrupt in known.met !");		
d857 1
a857 1
	fullpath.Format("%sfileinfo.ini",theApp.glob_prefs->GetAppDir()); 
d859 2
a860 2
	m_strComment = ini.GetString("Comment"); 
	m_iRate = ini.GetInt("Rate", 0);//For rate
d873 1
a873 1
	fullpath.Format("%sfileinfo.ini",theApp.glob_prefs->GetAppDir()); 
d876 1
a876 1
	ini.WriteString ("Comment", strNewComment); 
d899 1
a899 1
	fullpath.Format("%sfileinfo.ini",theApp.glob_prefs->GetAppDir()); 
d902 1
a902 1
	ini.WriteInt ("Rate", iNewRate); 
@


1.52
log
@some more localizations...
@
text
@d399 1
a399 1
		switch(newtag->specialtag){
d401 1
a401 1
				filename = CString(newtag->stringvalue);
d406 1
a406 1
				filesize = newtag->intvalue;
d411 1
a411 1
				statistic.alltimetransfered = newtag->intvalue;
d416 1
a416 1
				statistic.alltimerequested = newtag->intvalue;
d421 1
a421 1
				statistic.alltimeaccepted = newtag->intvalue;
d426 1
a426 1
				m_iPriority = newtag->intvalue;
d435 1
a435 1
				m_iPermissions = newtag->intvalue;
@


1.51
log
@added some localizations (Lancast, corrupt hashset)
@
text
@d1180 1
a1180 1
		AddLogLine(true, "traffic.dat is corrupted");
d1197 1
a1197 1
		AddLogLine(true, "traffic.dat is corrupted");
@


1.50
log
@minor changes (use md4... instead of mem...)
@
text
@d475 1
a475 1
        AddLogLine(false,"Loaded hashset is corrupt in known.met, file: %s!", filename);
@


1.49
log
@unicode cleanup
@
text
@d177 1
a177 1
	memset(filehash, 0, 16);
@


1.48
log
@1 more fix from safehash
@
text
@d261 1
a261 1
	FILE* file = fopen(namebuffer,"rbS");	
@


1.47
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d271 1
d273 7
d286 1
a286 1
	md4clr(lasthash);
@


1.46
log
@Preparing for new sockets
@
text
@d29 1
d607 1
d610 4
@


1.45
log
@converted to new logger methods
@
text
@d55 2
d60 2
a61 1
	uint32 dwID = theApp.serverconnect->GetClientID();
@


1.44
log
@code cleanup
@
text
@d474 1
a474 1
            AddLogLine(false,GetResString(IDS_JS_ENABLED), filename);
@


1.43
log
@removed Tag_Struct usage from sources
@
text
@d309 1
a309 1
bool CKnownFile::LoadHashsetFromFile(CFile* file, bool checkhash)
d314 1
a314 1
	file->Read(&checkid,16);
d316 1
a316 1
	file->Read(&parts,2);
d332 1
a332 1
		file->Read(cur_hash,16);
d379 1
a379 1
bool CKnownFile::LoadTagsFromFile(CFile* file)
d384 1
a384 1
	file->Read(&tagcount,4);
d438 1
a438 1
bool CKnownFile::LoadDateFromFile(CFile* file)
d442 1
a442 1
	file->Read(&date,4);
d450 1
a450 1
bool CKnownFile::LoadFromFile(CFile* file)
@


1.42
log
@changes reverted
@
text
@d387 1
a387 1
		switch(newtag->tag->specialtag){
d389 1
a389 1
				filename = CString(newtag->tag->stringvalue);
d394 1
a394 1
				filesize = newtag->tag->intvalue;
d399 1
a399 1
				statistic.alltimetransfered = newtag->tag->intvalue;
d404 1
a404 1
				statistic.alltimerequested = newtag->tag->intvalue;
d409 1
a409 1
				statistic.alltimeaccepted = newtag->tag->intvalue;
d414 1
a414 1
				m_iPriority = newtag->tag->intvalue;
d423 1
a423 1
				m_iPermissions = newtag->tag->intvalue;
@


1.41
log
@DoubleT: bug #295 fixed (bypass part blocking on opcode StartUploadReq)
@
text
@d387 1
a387 1
		switch(newtag->specialtag){
d389 1
a389 1
				filename = CString(newtag->stringvalue);
d394 1
a394 1
				filesize = newtag->intvalue;
d399 1
a399 1
				statistic.alltimetransfered = newtag->intvalue;
d404 1
a404 1
				statistic.alltimerequested = newtag->intvalue;
d409 1
a409 1
				statistic.alltimeaccepted = newtag->intvalue;
d414 1
a414 1
				m_iPriority = newtag->intvalue;
d423 1
a423 1
				m_iPermissions = newtag->intvalue;
@


1.40
log
@complete sources update (UDP)
@
text
@d1516 20
@


1.39
log
@removed Tag_Struct usage from sources
@
text
@d214 1
a214 1
			if (cur_count)
d493 1
a493 1
	for (int i = 0; i != parts; i++)
@


1.38
log
@code cleanup
@
text
@d387 1
a387 1
		switch(newtag->tag->specialtag){
d389 1
a389 1
				filename = CString(newtag->tag->stringvalue);
d394 1
a394 1
				filesize = newtag->tag->intvalue;
d399 1
a399 1
				statistic.alltimetransfered = newtag->tag->intvalue;
d404 1
a404 1
				statistic.alltimerequested = newtag->tag->intvalue;
d409 1
a409 1
				statistic.alltimeaccepted = newtag->tag->intvalue;
d414 1
a414 1
				m_iPriority = newtag->tag->intvalue;
d423 1
a423 1
				m_iPermissions = newtag->tag->intvalue;
@


1.37
log
@code cleanup
@
text
@d837 1
a837 5
	char buffer[100]; 
		   
	buffer[0] = 0;
	for (uint16 i = 0;i != 16;i++) 
		sprintf(buffer,"%s%02X",buffer,filehash[i]); 
d853 1
a853 1
	char buffer[100]; 
a854 4
	buffer[0] = 0; 
	for (uint16 i = 0;i != 16;i++) 
		sprintf(buffer,"%s%02X",buffer,filehash[i]); 

d879 2
a880 6
	char buffer[100]; 	
	       
	buffer[0] = 0; 
	for (uint16 i = 0;i != 16;i++) 
		sprintf(buffer,"%s%02X",buffer,filehash[i]); 
	
@


1.36
log
@coverted code from char * to CString
@
text
@d41 32
@


1.35
log
@coverted code from char * to CString
@
text
@d214 1
a214 1
bool CKnownFile::CreateFromFile(char* in_directory,char* in_filename)
@


1.34
log
@coverted code from char * to CString
@
text
@d119 1
a119 3
	filetype = 2;
	directory = 0;
	filename = 0;
d158 1
a158 5
//	if (filename)	// done by CAbstractFile destructor
//		delete[] filename;
	if (directory)
		delete[] directory;

a212 10
void CKnownFile::SetPath(char* path)
{
	EMULE_TRY

	if (directory)
		delete[] directory;
	directory = nstrdup(path);

	EMULE_CATCH
}
d221 1
a221 1
	directory = nstrdup(in_directory);
d229 1
a229 1
	filename = nstrdup(in_filename);
d288 1
a288 1
		if ( filename!=NULL )
d357 1
a357 1
				filename = nstrdup(newtag->tag->stringvalue);
d430 1
a430 1
    if(!hashset_ok && filename!=NULL)	//Cax2 - if filename==NULL, don't report it, it should still be ok...
d726 14
a739 26
void CAbstractFile::SetFileName(LPCSTR NewName) 
{
	EMULE_TRY

	if (filename!=NULL) { 
		delete[] filename; 
	  filename = NULL; // needed, because 'new' may fire an exception
		filename = new char[strlen(NewName)+1]; 
	      
		CString filenametemp;
		filenametemp=NewName;//.Format("%s",NewName);
		filenametemp.Replace('/','-');
		filenametemp.Replace('>','-');
		filenametemp.Replace('<','-');
		filenametemp.Replace('*','-');
		filenametemp.Replace(':','-');
		filenametemp.Replace('?','-');
		//SyruS: these 3 were missing.
		filenametemp.Replace('|','-');
		filenametemp.Replace('\"','-');
		filenametemp.Replace('\\','-');

		sprintf(filename, "%s", filenametemp);
	} 

	EMULE_CATCH
@


1.33
log
@Jumpstart localizations
@
text
@d239 3
a241 4
	char* namebuffer = new char[strlen(in_directory)+strlen(in_filename)+2];
	sprintf(namebuffer,"%s\\%s",in_directory,in_filename);
	FILE* file = fopen(namebuffer,"rbS");
	delete [] namebuffer;	//netwolf
d834 1
a834 3
	char* fullpath = new char[strlen(theApp.glob_prefs->GetAppDir())+13]; 
	sprintf(fullpath,"%sfileinfo.ini",theApp.glob_prefs->GetAppDir()); 
	   
d838 3
a840 1
	    
d844 1
a844 2
	m_bCommentLoaded=true;
	delete [] fullpath; //netwolf
a853 2
	char* fullpath = new char[strlen(theApp.glob_prefs->GetAppDir())+13]; 
	sprintf(fullpath,"%sfileinfo.ini",theApp.glob_prefs->GetAppDir()); 
d858 3
a860 1
	    
d865 1
a865 1
	delete [] fullpath;	//netwolf
d883 1
a883 3
	char buffer[100]; 
	char* fullpath = new char[strlen(theApp.glob_prefs->GetAppDir())+13]; 
	sprintf(fullpath,"%sfileinfo.ini",theApp.glob_prefs->GetAppDir()); 
d888 3
a890 1
	    
d894 1
a894 2
	m_iRate = iNewRate; 
	delete [] fullpath;
@


1.32
log
@fix for Jumpstart insisting on turning itself on
@
text
@d459 1
a459 1
            AddLogLine(false,"Jumpstart enabled for file: %s!", filename);
@


1.31
log
@minor fixes and improvements
@
text
@d1577 5
d1584 1
d1600 2
a1601 2
bool CKnownFile::IsJsChunkComplete(uint32 partNo) {
    return m_Jumpstarter && m_Jumpstarter->IsChunkComplete(partNo);
@


1.30
log
@complete sources column
@
text
@d154 1
a154 1
	for (int i = 0; i != hashlist.GetSize(); i++)
d158 1
a158 1
	for (int i = 0; i != taglist.GetSize(); i++)
d259 1
a259 1
	memset(lasthash,0,16);
d263 1
a263 1
		memcpy(filehash,lasthash,16);
d271 2
a272 2
		for (int i = 0;i != hashlist.GetCount();i++)
			memcpy(buffer+(i*16),hashlist[i],16);
d315 1
a315 1
	for (int i = 0; i != parts; i++){
d322 3
a324 3
		memcpy(filehash, checkid, 16);
	if (!parts) // nothing to check
		return true;
d330 5
a334 4
		for (int i = 0; i != hashlist.GetSize(); i++)
	delete[] hashlist[i];
	hashlist.RemoveAll();
		return false;
a335 1
	}
d341 2
a342 2
		for (int i = 0;i != hashlist.GetCount();i++)
			memcpy(buffer+(i*16),hashlist[i],16);
d346 1
a346 1
	if (!memcmp(filehash,checkid,16))
d350 1
a350 1
		for (int i = 0; i != hashlist.GetSize(); i++)
d489 1
a489 1
	for (i = 0; i != parts; i++)
d591 1
a591 1
	memcpy(Output, Hash, 16);
d749 1
d897 1
a897 1
	delete fullpath;
@


1.29
log
@added 3 missing invalid chars for filenames
@
text
@d28 1
d132 5
d173 46
d322 3
a324 3
		memcpy(filehash,checkid,16);
		if (!parts) // nothing to check
			return true;
d327 8
a334 8
	    if (!parts) // data not sent
		    return false;
	    if (parts != GetPartCount()){ // part count mismatch
		    for (int i = 0; i != hashlist.GetSize(); i++)
	    	delete[] hashlist[i];
	    	hashlist.RemoveAll();
		    return false;
	    }
d336 2
a337 2
	// SLUGFILLER: hashlistRecheck
	// trust noone ;-)
@


1.28
log
@More netwolf's changes
@
text
@d707 4
@


1.27
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d190 1
a190 1
	delete namebuffer;
d789 1
a789 1
	delete fullpath;
d810 1
a810 1
	delete fullpath;
@


1.26
log
@Jumpstart debug runtime check
@
text
@d268 1
d271 2
a272 1
		// return true;  // obaldin - do _some_ check anyways
d274 11
d398 5
@


1.25
log
@fix crash at exit
@
text
@d1518 5
@


1.24
log
@Fixed bugs #38 & #169
@
text
@d86 2
a87 1
	theApp.sharedfiles->UpdateItem(fileParent,theApp.emuledlg->sharedfileswnd.IsWindowVisible());
@


1.23
log
@fixed 0 upload when no files known
@
text
@d672 1
a672 1
void CAbstractFile::SetFileName(char* NewName) 
@


1.23.2.1
log
@27a partial merge
@
text
@d56 1
a56 1
	requested = transferred = accepted = alltimerequested= alltimetransferred = alltimeaccepted = 0;
d103 1
a103 1
void CFileStatistic::AddTransferred(uint64 bytes)
d107 3
a109 3
	transferred += bytes;
	alltimetransferred += bytes;
	theApp.knownfiles->transferred += bytes;
d318 1
a318 12
				statistic.alltimetransferred = newtag->tag->intvalue;
				delete newtag;
				break;
			}
			case FT_ATTRANSFEREDHI:{
				uint32 hi,low;
				low=statistic.alltimetransferred;
				hi = newtag->tag->intvalue;
				uint64 hi2;
				hi2=hi;
				hi2=hi2<<32;
				statistic.alltimetransferred=low+hi2;
d435 1
a435 3
	uint32 tran;
	tran=statistic.alltimetransferred;
	CTag attag1(FT_ATTRANSFERED, tran);
a436 4
	tran=statistic.alltimetransferred>>32;
	CTag attag4(FT_ATTRANSFEREDHI, tran);
	attag4.WriteTagToFile(file);

d701 1
a701 1
	theApp.uploadqueue->FindSourcesForFileById(&srclist, forClient->GetUploadFileID()); //should we use "filehash"?
d709 1
a709 1
	data.Write(forClient->GetUploadFileID(), 16);
d1314 1
a1314 1
		alltimerequested=alltimetransferred=alltimeaccepted=0;
d1331 1
a1331 1
	requested=transferred=accepted=0;
d1395 1
a1395 1
	alltimetransferred	+= _alltimetransfered;
d1407 1
a1407 1
	alltimetransferred	+= m->alltimetransferred;
d1411 1
a1411 1
	transferred	+= m->transferred;
@


1.23.2.2
log
@27c
@
text
@a747 2
			if (forClient->GetSourceExchangeVersion() > 1)
				data.Write(cur_src->GetUserHash(),16);
a762 1
	AddDebugLogLine( false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount );
@


1.22
log
@bugfixed bugfixes!
@
text
@d550 1
a550 1
	ratio = -4.0f * log10f(((float)theApp.knownfiles->GetCount())) * ratio ;
@


1.21
log
@*** empty log message ***
@
text
@d150 1
d221 1
d250 1
a250 1
	if ( iParts < 0 )
d254 1
a254 1
			AddLogLine(false,"Loaded hashset size is corrupt in known.met, file: %s!", filename);		
d258 1
a258 1
			AddLogLine(false,"Loaded hashset size is corrupt in known.met !");		
d528 2
a529 2

	CSingleLock Lock(&m_hashlistMutex,TRUE);
d1473 2
a1474 2

	CSingleLock Lock(&m_hashlistMutex,TRUE);
d1476 1
a1476 1
	Lock.Unlock();
@


1.20
log
@*** empty log message ***
@
text
@a401 4
	// date
	fwrite(&date,4,1,file); 
	// hashset
	fwrite(&filehash,16,1,file);
d410 5
@


1.19
log
@*** empty log message ***
@
text
@d408 1
a408 1
	fwrite(&parts,2,1,file);
d412 6
a417 2
			return false; // ? is this correct? i hope it doesn't corrupt the hashsets.
		fwrite(hashlist[i],16,1,file);
d419 1
@


1.18
log
@*** empty log message ***
@
text
@d146 1
a146 1

d199 1
d214 1
d259 1
d406 1
d415 1
d521 1
d524 1
d1466 1
d1468 1
@


1.17
log
@*** empty log message ***
@
text
@d245 12
@


1.16
log
@*** empty log message ***
@
text
@d86 1
a86 1
	theApp.sharedfiles->UpdateItem(fileParent);
d98 1
a98 1
	theApp.sharedfiles->UpdateItem(fileParent);
d110 1
a110 1
	theApp.sharedfiles->UpdateItem(fileParent);
d1010 1
a1010 1
	theApp.sharedfiles->UpdateItem(fileParent);
@


1.15
log
@further updated the addlog function + minor bugfix!
@
text
@d57 1
@


1.14
log
@converted to new logging method
@
text
@d363 1
a363 1
    if(!hashset_ok) {
a364 1
    }
@


1.13
log
@jumpstart fixes
@
text
@d364 1
a364 1
        theApp.emuledlg->AddLogLine(false,"Loaded hashset is corrupt in known.met, file: %s!", filename);
d371 1
a371 1
            theApp.emuledlg->AddLogLine(false,"Jumpstart enabled for file: %s!", filename);
d967 2
a968 2
	//DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "--------------------------------------------------------------------------------------------------"));
	//DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "start %i, bytes %i ", start, bytes));
d1071 1
a1071 1
		theApp.emuledlg->AddLogLine(true, "traffic.dat is corrupted");
d1088 1
a1088 1
		theApp.emuledlg->AddLogLine(true, "traffic.dat is corrupted");
@


1.12
log
@more Jumpstarter
@
text
@d156 6
a161 1
	EMULE_CATCH
@


1.11
log
@Changes protected by a #define, should have no effect
@
text
@d1479 4
@


1.10
log
@Bugfixes
@
text
@d28 5
d136 4
d362 9
d1462 18
@


1.9
log
@Protection from on-disk hashset corruption, proper check that we already have the data before sending
@
text
@d130 1
@


1.8
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d236 1
a236 1
		return true;
d340 11
a350 1
	return (LoadDateFromFile(file) && LoadHashsetFromFile(file,false) && LoadTagsFromFile(file)); 
d352 3
a354 1
	EMULE_CATCH
@


1.7
log
@Fixes the crash in CKnownFile::UpdateUploadAutoPriority(void) if theApp.downloadqueue==0
@
text
@d657 2
a658 1
		if(!cur_src->HasLowID() && cur_src != forClient) {
@


1.6
log
@Code clean up and double check wit official code.
@
text
@d590 1
a590 1
	if (IsAutoPrioritized())
@


1.6.2.1
log
@keeping in sync with the main cvs line
@
text
@d590 1
a590 1
	if (IsAutoPrioritized() && theApp.downloadqueue )
@


1.5
log
@SF & RF ratios bugfixed, added 'type' options to filedonkey search
@
text
@a19 1

a33 1

@


1.4
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d485 1
d487 1
a487 2

	float ratio ;
@


1.3
log
@Merge from official sockets
@
text
@d30 7
@


1.2
log
@*** empty log message ***
@
text
@d925 2
a926 2
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "--------------------------------------------------------------------------------------------------"));
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "start %i, bytes %i ", start, bytes));
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.2.2.2
log
@impossible to debug with all these messages :(
@
text
@d925 2
a926 2
	//DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "--------------------------------------------------------------------------------------------------"));
	//DEBUG_ONLY(theApp.emuledlg->AddLogLine(false, "start %i, bytes %i ", start, bytes));
@


1.1
log
@*** empty log message ***
@
text
@a1375 2
	else 
		return PR_PART_ON; 
d1378 2
a1394 1
	return false;
d1397 2
@

