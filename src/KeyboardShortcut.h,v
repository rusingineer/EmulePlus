head	1.5;
access;
symbols
	PublicRelease_1_2e:1.5
	Interim_Release_1-2e_RC1:1.5
	PublicRelease_1_2d:1.5
	Interim_Release_1-2d_RC1:1.5
	Interim_Release_1-2d_beta1:1.5
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.3
	Interim_Release_1l_RC1:1.3
	Interim_Release_1l_beta2:1.3
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.3
	Interim_Release_1k_RC4:1.3
	Interim_1k_RC3:1.3
	Interim_1k_RC2:1.3
	Interim_Release_1k_RC1:1.3
	Interim_Release_1k_beta5:1.3
	Intrerim_Release_1k_beta4:1.3
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1;
locks; strict;
comment	@ * @;


1.5
date	2007.12.29.05.48.24;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2004.08.04.04.17.05;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.30.17.52.44;	author eklmn;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.11.21.36.56;	author dropf;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.29.22.13.36;	author dropf;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Optimized string shortcut representation.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
/****************************************************************************************
 *                           * Keyboard Shortcut Management *                           *
 *                           *           by DropF           *                           *
 *                           ********************************                           *
 *                                                                                      *
 * To save the shortcut key combination, I use a 16-bit variable to store all the       *
 * needed information. The 3 first bits are unused. Then comes the bits repectively to: *
 *     - know if the shortcut is enabled                                                *
 *     - know if the shortcut combo uses the Alt key                                    *
 *     -      "          "           "       Ctrl key                                   *
 *     -      "          "           "       Shift key                                  *
 *     -      "          "           "       Win key                                    *
 * And finally, the last 8 bits are used to store the key                               *
 *                                                                                      *
 * Example: 0001100000001101                                                            *
 * -------                                                                              *
 *     - 000 --> aren't used                                                            *
 *     -  1  --> the shortcut is enabled                                                *
 *     -  1  --> the shortcut uses the Alt key                                          *
 *     -  0  --> the shortcut doesn't use the Ctrl key                                  *
 *     -  0  --> the shortcut doesn't use the Shift key                                 *
 *     -  0  --> the shortcut doesn't use the Win key                                   *
 *     - 00001101 = 13 = VK_RETURN --> the shortcuts uses the Enter key                 *
 * Finally, this shortcut is enabled and uses the combo Alt+Enter.                      *
 *                                                                                      *
 ****************************************************************************************/
#pragma once

#define	MASK_ENABLED	0x1000	// 0001000000000000
#define	MASK_ALT		0x0800	// 0000100000000000
#define	MASK_CTRL		0x0400	// 0000010000000000
#define	MASK_SHIFT		0x0200	// 0000001000000000
#define	MASK_WIN		0x0100	// 0000000100000000
#define	MASK_KEY		0x00FF	// 0000000011111111

#define SSP_TAB_PREFIX		0x01
#define SSP_SPACE_PREFIX	0x02
#define SSP_RETNONE			0x04	// return "None" if disabled

short GetCodeFromPressedKeys(MSG* pMsg);
CString GetStringFromShortcutCode(unsigned uiResID, int iIdx, int iMode);

class CKeyboardShortcut
{
public:
	CKeyboardShortcut(void);
	CKeyboardShortcut(short nCode);
	~CKeyboardShortcut(void);

	bool	IsEnabled(void) const	{ return m_bEnabled; }
	bool	IsAlt(void) const		{ return m_bAlt; }
	bool	IsCtrl(void) const	{ return m_bCtrl; }
	bool	IsShift(void) const	{ return m_bShift; }
	bool	IsWin(void) const	{ return m_bWin; }
	uchar	GetKey(void) const	{ return m_byteKey; }
	short	GetCode(void) const	{ return static_cast<short>((m_bEnabled ? MASK_ENABLED : 0) + (m_bAlt ? MASK_ALT : 0) + (m_bCtrl ? MASK_CTRL : 0) + (m_bShift ? MASK_SHIFT : 0) + (m_bWin ? MASK_WIN : 0) + static_cast<short>(m_byteKey)); }

	void SetEnabled(bool bEnabled)	{ m_bEnabled = bEnabled; }
	void SetAlt(bool bAlt)			{ m_bAlt = bAlt; }
	void SetCtrl(bool bCtrl)		{ m_bCtrl = bCtrl; }
	void SetShift(bool bShift)		{ m_bShift = bShift; }
	void SetWin(bool bWin)			{ m_bWin = bWin; }
	void SetKey(uchar byteKey)		{ m_byteKey = byteKey; }
	void SetCode(short nCode);

private:
	bool	m_bEnabled;
	bool	m_bAlt;
	bool	m_bCtrl;
	bool	m_bShift;
	bool	m_bWin;
	uchar	m_byteKey;
};
@


1.4
log
@Faster shortcuts handling.
@
text
@d1 16
a42 1

a43 1
#include "types.h"
d52 3
a54 6
enum EnumShortcutStringPrefix
{
	SSP_NO_PREFIX,
	SSP_TAB_PREFIX,
	SSP_SPACE_PREFIX
};
d57 1
a57 1
CString GetStringFromShortcutCode(int iIdx, EnumShortcutStringPrefix ePrefixType = SSP_NO_PREFIX, BOOL bReturnNoneIfDisabled = FALSE);
d65 1
a65 8
private:
	bool	m_bEnabled;
	bool	m_bAlt;
	bool	m_bCtrl;
	bool	m_bShift;
	bool	m_bWin;
	uchar	m_byteKey;
public:
d81 8
@


1.3
log
@fixed crash  due context menu, shortcut optimiation & update to UNICODE
@
text
@d46 1
a46 1
CString GetStringFromShortcutCode(short nCode, EnumShortcutStringPrefix ePrefixType = SSP_NO_PREFIX, BOOL bReturnNoneIfDisabled = FALSE);
d62 7
a68 7
	bool	IsEnabled(void)	{ return m_bEnabled; }
	bool	IsAlt(void)		{ return m_bAlt; }
	bool	IsCtrl(void)	{ return m_bCtrl; }
	bool	IsShift(void)	{ return m_bShift; }
	bool	IsWin(void)		{ return m_bWin; }
	uchar	GetKey(void)	{ return m_byteKey; }
	short	GetCode(void)	{ return static_cast<short>((m_bEnabled ? MASK_ENABLED : 0) + (m_bAlt ? MASK_ALT : 0) + (m_bCtrl ? MASK_CTRL : 0) + (m_bShift ? MASK_SHIFT : 0) + (m_bWin ? MASK_WIN : 0) + static_cast<short>(m_byteKey)); }
a76 1
	CString GetKeyComboString(void);
@


1.2
log
@Change to shortcut management code (it's easier to add an action now) / Added a lot of actions to shortcut management / Added some keys to shortcut management
@
text
@d38 7
d46 1
a46 1
CString GetStringFromShortcutCode(short nCode, BOOL bReturnNoneIfDisabled = FALSE);
@


1.1
log
@*** empty log message ***
@
text
@d15 1
a15 1
 * Exemple: 0001100000001101                                                            *
d39 1
a39 1
CString GetStringFromShortcutCode(short nCode, BOOL bReturnNoneIfEmpty = FALSE);
@

