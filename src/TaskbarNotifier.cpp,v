head	1.23;
access;
symbols
	PublicRelease_1_2e:1.23
	Interim_Release_1-2e_RC1:1.23
	PublicRelease_1_2d:1.18
	Interim_Release_1-2d_RC1:1.17
	Interim_Release_1-2d_beta1:1.17
	PublicRelease_1_2c:1.16
	Interim_Release_1-2c_RC1:1.16
	Interim_Release_1-2c_beta1:1.15
	PublicRelease_1_2b:1.15
	Interim_Release_1-2b_RC1:1.15
	PublicRelease_1_2a:1.15
	Interim_Release_1-2a_RC1:1.15
	Interim_Release_1-2a_beta2:1.13
	Interim_Release_1-2a_beta1:1.13
	PublicRelease_1_2:1.13
	Interim_Release_1-2_RC1:1.13
	Interim_Release_1-2_beta1:1.13
	PublicRelease_1_1g:1.13
	Interim_Release_1-1g_RC3:1.13
	Interim_Release_1-1g_RC2:1.12
	Interim_Release_1-1g_RC1:1.12
	Interim_Release_1-1g_beta2:1.12
	Interim_Release_1-1g_beta1:1.12
	PublicRelease_1_1f:1.12
	Interim_Release_1-1f_RC1:1.12
	PublicRelease_1_1e:1.12
	Interim_Release_1-1e_RC2:1.12
	Interim_Release_1-1e_RC1:1.12
	Interim_Release_1-1e_beta1:1.12
	PublicRelease_1_1d:1.12
	Interim_Release_1-1d_RC1:1.12
	PublicRelease_1_1c:1.12
	Interim_Release_1-1c_RC1:1.12
	Interim_Release_1-1c_beta2:1.11
	Interim_Release_1-1c_beta1:1.9
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.9
	PublicRelease_1_1a:1.9
	Interim_Release_1-1a_RC2:1.9
	Interim_Release_1-1a_RC1:1.9
	Interim_Release_1-1a_beta2:1.9
	Interim_Release_1-1a_beta1:1.9
	PublicRelease_1_1:1.9
	Interim_Release_1-1_beta1:1.9
	PublicRelease_1o:1.9
	Interim_Release_1o_RC1:1.9
	Interim_Release_1o_beta1:1.9
	PublicRelease_1n:1.9
	Interim_Release_1n_RC2:1.9
	Interim_Release_1n_RC1:1.9
	Interim_Release_1n_beta2:1.9
	Interim_Release_1n_beta1:1.9
	PublicRelease_1m:1.8
	Interim_Release_1m_beta1:1.8
	PublicRelease_1l:1.8
	Interim_Release_1l_RC3:1.8
	Interim_Release_1l_RC2:1.8
	Interim_Release_1l_RC1:1.8
	Interim_Release_1l_beta2:1.8
	Interim_Release_1l_beta1:1.8
	PublicRelease_1k:1.7
	Interim_Release_1k_RC4:1.7
	Interim_1k_RC3:1.7
	Interim_1k_RC2:1.7
	Interim_Release_1k_RC1:1.7
	Interim_Release_1k_beta5:1.7
	Intrerim_Release_1k_beta4:1.7
	Interim_Release_1k_beta1:1.7
	PublicRelease_1j:1.6
	Interim_Release_1J_RC3:1.6
	Interim_Release_1j_RC3:1.6
	Interim_Release_1j_RC2:1.6
	Interim_Release_1j_RC1:1.6
	Interim_Release_1j_beta2:1.6
	Interim_Release_1j_beta1:1.6
	PublicRelease_1i:1.6
	Interim_Release_1i_RC6:1.6
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.6
	Interim_Release_1i_beta3:1.6
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.5
	PublicRelease_1h:1.4
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.4
	Interim_Release_1h_beta1_now:1.4
	Interim_Release_1h_beta1:1.4
	PublicRelease_1g:1.4
	Interim_Release_1g_RC6_Final:1.4
	Interim_Release_1g_RC6:1.4
	Interim_Release_1g_RC5:1.4
	Interim_Release_1g_RC4:1.4
	Interim_Release_1g_RC3:1.4
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.8
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.2
	threaded_downloadqueue:1.2.0.6
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.23
date	2009.03.30.00.05.00;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.05.01.18.12;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.01.19.19.02;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.14.17.05.48;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.10.04.40.59;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2008.05.14.03.38.11;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.09.12.16.59;	author eklmn;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.08.00.15.48;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.04.18.25.53;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.27.01.58.52;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.11.00.09.54;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.22.22.30.25;	author netwolf1;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.13.17.14.40;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.13.11.32.31;	author katsyonak;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.29.14.14.57;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.22.19.40.56;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.11.04.13.01;	author katsyonak;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.21.22.05.18;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.15.13.41.14;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.11.18.27.13;	author eklmn;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.49;	author lord_kiron;	state Exp;
branches
	1.2.8.1;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.31;	author cax2;	state Exp;
branches;
next	;

1.2.8.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.2.8.2;

1.2.8.2
date	2003.03.24.10.40.39;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Minor formatting update from original.
@
text
@// TaskbarNotifier.cpp : implementation file
// By John O'Byrne
// 01 July 2008 - Corrected wrong window placement in Wine (which reports weird taskbar location)
// 08 February 2008 - replaced the window callback function AfxWndProc() to TaskbarWndProc() to fix the MSUL issue.
//                    (for more details see http://www.trigeminal.com/usenet/usenet031.asp?1033)
// 11 August 2002: - Timer precision is now determined automatically
//                 Complete change in the way the popup is showing (thanks to this,now the popup can be always on top, it shows even while watching a movie)
//                 The popup doesn't steal the focus anymore (by replacing ShowWindow(SW_SHOW) by ShowWindow(SW_SHOWNOACTIVATE))
//                 Thanks to Daniel Lohmann, update in the way the taskbar pos is determined (more flexible now)
// 17 July 2002: - Another big Change in the method for determining the pos of the taskbar (using the SHAppBarMessage function)
// 16 July 2002: - Thanks to the help of Daniel Lohmann, the Show Function timings work perfectly now ;)
// 15 July 2002: - Change in the method for determining the pos of the taskbar
//               (now handles the presence of quick launch or any other bar).
//               Remove the Handlers for WM_CREATE and WM_DESTROY
//               SetSkin is now called SetBitmap
// 14 July 2002: - Changed the GenerateRegion func by a new one (to correct a win98 bug)

#include "stdafx.h"
#include "TaskbarNotifier.h"
#include "otherfunctions.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


#define IDT_HIDDEN			0
#define IDT_APPEARING		1
#define IDT_WAITING			2
#define IDT_DISAPPEARING	3
#define TASKBAR_X_TOLERANCE	20
#define TASKBAR_Y_TOLERANCE 20

#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)	// System Hand cursor
#endif

static LRESULT CALLBACK TaskbarWndProc(HWND hWnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hWnd, uiMsg, wParam, lParam);
}

IMPLEMENT_DYNAMIC(CTaskbarNotifier, CWnd)
CTaskbarNotifier::CTaskbarNotifier() : m_strCaption(_T(""))
{
	m_pWndParent = NULL;
	m_bMouseIsOver = FALSE;
	m_bStarted = FALSE;
	m_hBitmapRegion = NULL;
	m_hCursor = NULL;
	m_crNormalTextColor = RGB(133, 146, 181);
	m_crSelectedTextColor = RGB(10, 36, 106);
	m_nBitmapHeight = 0;
	m_nBitmapWidth = 0;
	
	m_dwTimeToStay = 0;
	m_dwShowEvents = 0;
	m_dwHideEvents = 0;
	m_nCurrentPosX = 0;
	m_nCurrentPosY = 0;
	m_nCurrentWidth = 0;
	m_nCurrentHeight = 0;
	m_nIncrementShow = 0;
	m_nIncrementHide = 0;	
	m_nTaskbarPlacement = ABE_BOTTOM;
	m_nAnimStatus = IDT_HIDDEN;
	m_rcText.SetRect(0, 0, 0, 0);
	m_hCursor = ::LoadCursor(NULL, IDC_HAND);

	m_nActiveMessageType  = TBN_NULL;
	m_nMessageTypeClicked = TBN_NULL;
	
	// If running on NT, timer precision is 10 ms, if not timer precision is 50 ms
	OSVERSIONINFO	osvi;

	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
		m_dwTimerPrecision = 10;
	else
		m_dwTimerPrecision = 50;

	SetTextDefaultFont(); // We use default GUI Font
}

CTaskbarNotifier::~CTaskbarNotifier()
{
	// No need to delete the HRGN,  SetWindowRgn() owns it after being called
}

int CTaskbarNotifier::Create(CWnd *pWndParent)
{
	ASSERT(pWndParent != NULL);
	m_pWndParent = pWndParent;

	WNDCLASSEX		wcx;

	wcx.cbSize = sizeof(wcx);
	wcx.lpfnWndProc = TaskbarWndProc;
	wcx.style = CS_DBLCLKS | CS_SAVEBITS;
	wcx.cbClsExtra = 0;
	wcx.cbWndExtra = 0;
	wcx.hInstance = AfxGetInstanceHandle();
	wcx.hIcon = NULL;
	wcx.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcx.hbrBackground = ::GetSysColorBrush(COLOR_WINDOW);
	wcx.lpszMenuName = NULL;
	wcx.lpszClassName = _T("TaskbarNotifierClass");
	wcx.hIconSm = NULL;

	RegisterClassEx(&wcx);

	return CreateEx(WS_EX_TOPMOST, _T("TaskbarNotifierClass"), NULL, WS_POPUP, 0, 0, 0, 0, pWndParent->m_hWnd, NULL);
}

void CTaskbarNotifier::SetTextFont(LPCTSTR szFont, int nSize, int nNormalStyle, int nSelectedStyle)
{
	LOGFONT		lf;

	m_fontNormal.DeleteObject();
	m_fontNormal.CreatePointFont(nSize, szFont);
	m_fontNormal.GetLogFont(&lf);

	// We  set the Font of the unselected ITEM
	if (nNormalStyle & TN_TEXT_BOLD)
		lf.lfWeight = FW_BOLD;
	else
		lf.lfWeight = FW_NORMAL;

	if (nNormalStyle & TN_TEXT_ITALIC)
		lf.lfItalic = TRUE;
	else
		lf.lfItalic = FALSE;

	if (nNormalStyle & TN_TEXT_UNDERLINE)
		lf.lfUnderline = TRUE;
	else
		lf.lfUnderline = FALSE;

	m_fontNormal.DeleteObject();
	m_fontNormal.CreateFontIndirect(&lf);

	// We set the Font of the selected ITEM
	if (nSelectedStyle & TN_TEXT_BOLD)
		lf.lfWeight = FW_BOLD;
	else
		lf.lfWeight = FW_NORMAL;

	if (nSelectedStyle & TN_TEXT_ITALIC)
		lf.lfItalic = TRUE;
	else
		lf.lfItalic = FALSE;

	if (nSelectedStyle & TN_TEXT_UNDERLINE)
		lf.lfUnderline = TRUE;
	else
		lf.lfUnderline = FALSE;

	m_fontSelected.DeleteObject();
	m_fontSelected.CreateFontIndirect(&lf);
}

void CTaskbarNotifier::SetTextDefaultFont()
{
	LOGFONT		lf;
	CFont		*pFont = CFont::FromHandle((HFONT)GetStockObject(DEFAULT_GUI_FONT));

	pFont->GetLogFont(&lf);
	m_fontNormal.DeleteObject();
	m_fontSelected.DeleteObject();
	m_fontNormal.CreateFontIndirect(&lf);
	lf.lfUnderline = TRUE;
	m_fontSelected.CreateFontIndirect(&lf);
}

void CTaskbarNotifier::SetTextColor(COLORREF crNormalTextColor, COLORREF crSelectedTextColor)
{
	m_crNormalTextColor = crNormalTextColor;
	m_crSelectedTextColor = crSelectedTextColor;
	RedrawWindow(&m_rcText);
}

void CTaskbarNotifier::SetTextRect(RECT rcText)
{
	m_rcText = rcText;
}

BOOL CTaskbarNotifier::SetBitmap(UINT nBitmapID, int red, int green, int blue)
{
	BITMAP		bm;
	
	m_bitmapBackground.DeleteObject();
	if (m_bitmapBackground.LoadBitmap(nBitmapID) == NULL)
		return FALSE;

	m_bitmapBackground.GetBitmap(&bm);
	m_nBitmapWidth = bm.bmWidth;
	m_nBitmapHeight = bm.bmHeight;

	if (red != -1 && green != -1 && blue != -1)
	{
		// No need to delete the HRGN, SetWindowRgn() owns it after being called
		m_hBitmapRegion = CreateRgnFromBitmap(m_bitmapBackground, RGB(red, green, blue));
		SetWindowRgn(m_hBitmapRegion, true);
	}

	return TRUE;
}

BOOL CTaskbarNotifier::SetBitmap(CBitmap *pBitmap, int red, int green, int blue)
{
	BITMAP		bm;
	
	m_bitmapBackground.DeleteObject();
	if (m_bitmapBackground.Attach(pBitmap->Detach()) == NULL)
		return FALSE;

	m_bitmapBackground.GetBitmap(&bm);
	m_nBitmapWidth = bm.bmWidth;
	m_nBitmapHeight = bm.bmHeight;

	if (red != -1 && green != -1 && blue != -1)
	{
		// No need to delete the HRGN, SetWindowRgn() owns it after being called
		m_hBitmapRegion = CreateRgnFromBitmap(m_bitmapBackground, RGB(red, green, blue));
		SetWindowRgn(m_hBitmapRegion, true);
	}

	return TRUE;
}

BOOL CTaskbarNotifier::SetBitmap(LPCTSTR szFileName, int red, int green, int blue)
{
	BITMAP		bm;
	HBITMAP		hBmp = (HBITMAP)::LoadImage(AfxGetInstanceHandle(), szFileName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

	if (hBmp == NULL)
		return FALSE;

	m_bitmapBackground.DeleteObject();
	m_bitmapBackground.Attach(hBmp);
	m_bitmapBackground.GetBitmap(&bm);
	m_nBitmapWidth = bm.bmWidth;
	m_nBitmapHeight = bm.bmHeight;

	if (red != -1 && green != -1 && blue != -1)
	{
		// No need to delete the HRGN, SetWindowRgn() owns it after being called
		m_hBitmapRegion = CreateRgnFromBitmap(m_bitmapBackground, RGB(red, green, blue));
		SetWindowRgn(m_hBitmapRegion, true);
	}

	return TRUE;
}

void CTaskbarNotifier::Show(const CString &strCaption, int nMsgType, DWORD dwTimeToShow, DWORD dwTimeToStay, DWORD dwTimeToHide)
{
	int		iScreenWidth, iScreenHeight;
	UINT	nEvents, nBitmapSize;
	CRect	rcTaskbar;

	m_strCaption = strCaption;
	m_dwTimeToStay = dwTimeToStay;
	
	iScreenWidth = ::GetSystemMetrics(SM_CXSCREEN);
	iScreenHeight = ::GetSystemMetrics(SM_CYSCREEN);

	HWND	hWndTaskbar = ::FindWindow(_T("Shell_TrayWnd"), 0);

	::GetWindowRect(hWndTaskbar, &rcTaskbar);

	if (rcTaskbar.Width() >= rcTaskbar.Height())
	{
		// Taskbar is on top or on bottom
		m_nTaskbarPlacement = (((rcTaskbar.top + rcTaskbar.bottom) / 2) < (iScreenHeight >> 1)) ? ABE_TOP : ABE_BOTTOM;
	//	Correct weird taskbar position in Wine
		if (abs(iScreenWidth - rcTaskbar.right) > TASKBAR_X_TOLERANCE)
			rcTaskbar.right = iScreenWidth;
		nBitmapSize = m_nBitmapHeight;
	}
	else
	{
		// Taskbar is on left or on right
		m_nTaskbarPlacement = (((rcTaskbar.left + rcTaskbar.right) / 2) < (iScreenWidth >> 1)) ? ABE_LEFT : ABE_RIGHT;
	//	Correct weird taskbar position in Wine
		if (abs(iScreenHeight - rcTaskbar.bottom) > TASKBAR_Y_TOLERANCE)
			rcTaskbar.bottom = iScreenHeight;
		nBitmapSize = m_nBitmapWidth;
	}

	// We calculate the pixel increment and the timer value for the showing animation
	if (dwTimeToShow > m_dwTimerPrecision)
	{
		nEvents = min((dwTimeToShow / m_dwTimerPrecision) / 2, nBitmapSize);
		m_dwShowEvents = dwTimeToShow / nEvents;
		m_nIncrementShow = nBitmapSize / nEvents;
	}
	else
	{
		m_dwShowEvents = m_dwTimerPrecision;
		m_nIncrementShow = nBitmapSize;
	}

	// We calculate the pixel increment and the timer value for the hiding animation
	if (dwTimeToHide > m_dwTimerPrecision)
	{
		nEvents = min((dwTimeToHide / m_dwTimerPrecision / 2), nBitmapSize);
		m_dwHideEvents = dwTimeToHide / nEvents;
		m_nIncrementHide = nBitmapSize / nEvents;
	}
	else
	{
		m_dwShowEvents = m_dwTimerPrecision;
		m_nIncrementHide = nBitmapSize;
	}
	
	// Compute init values for the animation
	switch (m_nAnimStatus)
	{
		case IDT_HIDDEN:
		{
			if (m_nTaskbarPlacement == ABE_RIGHT)
			{
				m_nCurrentPosX = rcTaskbar.left;
				m_nCurrentPosY = rcTaskbar.bottom-m_nBitmapHeight;
				m_nCurrentWidth = 0;
				m_nCurrentHeight = m_nBitmapHeight;
			}
			else if (m_nTaskbarPlacement == ABE_LEFT)
			{
				m_nCurrentPosX = rcTaskbar.right;
				m_nCurrentPosY = rcTaskbar.bottom-m_nBitmapHeight;
				m_nCurrentWidth = 0;
				m_nCurrentHeight = m_nBitmapHeight;
			}
			else if (m_nTaskbarPlacement == ABE_TOP)
			{
				m_nCurrentPosX = rcTaskbar.right-m_nBitmapWidth;
				m_nCurrentPosY = rcTaskbar.bottom;
				m_nCurrentWidth = m_nBitmapWidth;
				m_nCurrentHeight = 0;
			}
			else //if (m_nTaskbarPlacement == ABE_BOTTOM)
			{
				// Taskbar is on the bottom or Invisible
				m_nCurrentPosX = rcTaskbar.right-m_nBitmapWidth;
				m_nCurrentPosY = rcTaskbar.top;
				m_nCurrentWidth = m_nBitmapWidth;
				m_nCurrentHeight = 0;
			}

			CWnd	*pWnd = GetForegroundWindow();

			ShowWindow(SW_SHOWNOACTIVATE);
			pWnd->SetForegroundWindow();
			m_nActiveMessageType = nMsgType;
			SetTimer(IDT_APPEARING, m_dwShowEvents, NULL);
			break;
		}
		case IDT_APPEARING:
			RedrawWindow(&m_rcText);
			break;

		case IDT_WAITING:
			RedrawWindow(&m_rcText);
			KillTimer(IDT_WAITING);
			SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
			break;

		case IDT_DISAPPEARING:
			KillTimer(IDT_DISAPPEARING);
			SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
			if (m_nTaskbarPlacement == ABE_RIGHT)
			{
				m_nCurrentPosX = rcTaskbar.left - m_nBitmapWidth;
				m_nCurrentWidth = m_nBitmapWidth;
			}
			else if (m_nTaskbarPlacement == ABE_LEFT)
			{
				m_nCurrentPosX = rcTaskbar.right;
				m_nCurrentWidth = m_nBitmapWidth;
			}
			else if (m_nTaskbarPlacement == ABE_TOP)
			{
				m_nCurrentPosY = rcTaskbar.bottom;
				m_nCurrentHeight = m_nBitmapHeight;
			}
			else //if (m_nTaskbarPlacement == ABE_BOTTOM)
			{
				m_nCurrentPosY = rcTaskbar.top - m_nBitmapHeight;
				m_nCurrentHeight = m_nBitmapHeight;
			}
			
			SetWindowPos(&wndTopMost, m_nCurrentPosX, m_nCurrentPosY, m_nCurrentWidth, m_nCurrentHeight, SWP_NOACTIVATE);
			RedrawWindow(&m_rcText);
			break;
	}
}

void CTaskbarNotifier::Hide()
{
	switch (m_nAnimStatus)
	{
		case IDT_APPEARING:
		case IDT_WAITING:
		case IDT_DISAPPEARING:
			KillTimer(m_nAnimStatus);
			break;
	}
	MoveWindow(0, 0, 0, 0);
	ShowWindow(SW_HIDE);
	m_nAnimStatus = IDT_HIDDEN;
	m_nActiveMessageType = TBN_NULL;
}

HRGN CTaskbarNotifier::CreateRgnFromBitmap(HBITMAP hBmp, COLORREF color)
{
	// this code is written by Davide Pizzolato

	if (hBmp == NULL)
		return NULL;

	CDC		*pDC = GetDC();

	if (pDC == NULL)
		return NULL;

	BITMAP		bm;
	CDC		dcBmp;

	GetObject(hBmp, sizeof(bm), &bm);	// get bitmap attributes

	dcBmp.CreateCompatibleDC(pDC);	//Creates a memory device context for the bitmap
	ReleaseDC(pDC);
	
	HGDIOBJ	hOldBitmap = dcBmp.SelectObject(hBmp); //selects the bitmap in the device context
	const	DWORD MAXBUF = 40;		// size of one block in RECTs

	// (i.e. MAXBUF * sizeof(RECT) in bytes)
	LPRECT	pRects;								
	DWORD	cBlocks = 0;			// number of allocated blocks

	INT		i, j;					// current position in mask image
	INT		first = 0;				// left position of current scan line
	// where mask was found
	bool	wasfirst = false;		// set when if mask was found in current scan line
	bool	ismask;					// set when current color is mask color

	// allocate memory for region data
	RGNDATAHEADER	*pRgnData = (RGNDATAHEADER*)new BYTE[sizeof(RGNDATAHEADER) + ++cBlocks * MAXBUF * sizeof(RECT)];
	
	memzero(pRgnData, sizeof(RGNDATAHEADER) + cBlocks * MAXBUF * sizeof(RECT));
	// fill it by default
	pRgnData->dwSize	= sizeof(RGNDATAHEADER);
	pRgnData->iType		= RDH_RECTANGLES;
	pRgnData->nCount	= 0;
	for (i = 0; i < bm.bmHeight; i++)
	{
		for (j = 0; j < bm.bmWidth; j++)
		{
			// get color
			ismask = (dcBmp.GetPixel(j, bm.bmHeight - i - 1) != color);
			// place part of scan line as RECT region if transparent color found after mask color or
			// mask color found at the end of mask image
			if (wasfirst && ((ismask && (j == (bm.bmWidth-1))) || (ismask ^ (j < bm.bmWidth))))
			{
				// get offset to RECT array if RGNDATA buffer
				pRects = (LPRECT)((LPBYTE)pRgnData + sizeof(RGNDATAHEADER));
				// save current RECT
				pRects[pRgnData->nCount++] = CRect(first, bm.bmHeight - i - 1, j + (j == (bm.bmWidth - 1)), bm.bmHeight - i);
				// if buffer full reallocate it
				if (pRgnData->nCount >= cBlocks * MAXBUF)
				{
					LPBYTE	pRgnDataNew = new BYTE[sizeof(RGNDATAHEADER) + ++cBlocks * MAXBUF * sizeof(RECT)];

					memcpy2(pRgnDataNew, pRgnData, sizeof(RGNDATAHEADER) + (cBlocks - 1) * MAXBUF * sizeof(RECT));
					delete[] pRgnData;
					pRgnData = (RGNDATAHEADER*)pRgnDataNew;
				}
				wasfirst = false;
			}
			else if (!wasfirst && ismask)
			{	// set wasfirst when mask is found
				first = j;
				wasfirst = true;
			}
		}
	}
	dcBmp.SelectObject(hOldBitmap); //restore default object
	dcBmp.DeleteDC();	//release the bitmap
	// create region
	/*  Under WinNT the ExtCreateRegion returns NULL (by Fable@@aramszu.net) */
	//	HRGN hRgn = ExtCreateRegion( NULL, sizeof(RGNDATAHEADER) + pRgnData->nCount * sizeof(RECT), (LPRGNDATA)pRgnData );
	/* ExtCreateRegion replacement { */
	HRGN	hRgn = CreateRectRgn(0, 0, 0, 0), hr;

	ASSERT( hRgn != NULL );
	pRects = (LPRECT)((LPBYTE)pRgnData + sizeof(RGNDATAHEADER));
	for (i=0; i < (int)pRgnData->nCount; i++)
	{
		hr = CreateRectRgn(pRects[i].left, pRects[i].top, pRects[i].right, pRects[i].bottom);
		VERIFY(CombineRgn(hRgn, hRgn, hr, RGN_OR) != ERROR);
		if (hr != NULL)
			DeleteObject(hr);
	}
	ASSERT( hRgn != NULL );
	/* } ExtCreateRegion replacement */

	delete[] pRgnData;
	ReleaseDC(pDC);
	return hRgn;
}

int CTaskbarNotifier::GetMessageType()
{	
	return m_nMessageTypeClicked;
}


BEGIN_MESSAGE_MAP(CTaskbarNotifier, CWnd)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONUP()
	ON_MESSAGE(WM_MOUSEHOVER, OnMouseHover)
	ON_MESSAGE(WM_MOUSELEAVE, OnMouseLeave)
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_SETCURSOR()
	ON_WM_TIMER()
END_MESSAGE_MAP()


// CTaskbarNotifier message handlers

void CTaskbarNotifier::OnMouseMove(UINT nFlags, CPoint point)
{
	TRACKMOUSEEVENT		tme;

	tme.cbSize      = sizeof(tme);
	tme.dwFlags     = TME_LEAVE | TME_HOVER;
	tme.hwndTrack   = m_hWnd;
	tme.dwHoverTime = 1;

	// We Tell Windows we want to receive WM_MOUSEHOVER and WM_MOUSELEAVE
	::_TrackMouseEvent(&tme);

	CWnd::OnMouseMove(nFlags, point);
}

void CTaskbarNotifier::OnLButtonUp(UINT nFlags, CPoint point)
{
	CRect		rClient;

	GetClientRect(&rClient);
	if (point.x >= rClient.right - 8 - 18 && point.x <= rClient.right - 8 &&
		point.y >= rClient.top + 12 && point.y <= rClient.top + 12 + 20)
	{
		KillTimer(IDT_WAITING);
		SetTimer(IDT_DISAPPEARING,m_dwHideEvents, NULL);
		return;
	}
	
	//	Store m_nActiveMessageType state before the timer expires
	m_nMessageTypeClicked = m_nActiveMessageType;
	// Notify the parent window that the Notifier popup was clicked
	m_pWndParent->PostMessage(WM_TASKBARNOTIFIERCLICKED, 0, 0);
	CWnd::OnLButtonUp(nFlags, point);
}

LRESULT CTaskbarNotifier::OnMouseHover(WPARAM wParam, LPARAM lParam)
{
	NOPRM(wParam); NOPRM(lParam);
	if (m_nAnimStatus == IDT_WAITING)
		KillTimer(IDT_WAITING);

	if (m_bMouseIsOver == FALSE)
	{
		m_bMouseIsOver = TRUE;
		RedrawWindow(&m_rcText);
		if (m_nAnimStatus == IDT_DISAPPEARING)
		{
			KillTimer(IDT_DISAPPEARING);
			m_nAnimStatus = IDT_APPEARING;
			SetTimer(IDT_APPEARING, m_dwShowEvents, NULL);
		}
	}
	return 0;
}

LRESULT CTaskbarNotifier::OnMouseLeave(WPARAM wParam, LPARAM lParam)
{
	NOPRM(wParam); NOPRM(lParam);
	if (m_bMouseIsOver == TRUE)
	{
		m_bMouseIsOver = FALSE;
		RedrawWindow(&m_rcText);
		if (m_nAnimStatus == IDT_WAITING)
			SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
	}
	return 0;
}

BOOL CTaskbarNotifier::OnEraseBkgnd(CDC* pDC)
{
	CDC			memDC;
	CBitmap		*pOldBitmap;
	
	memDC.CreateCompatibleDC(pDC);
	pOldBitmap = memDC.SelectObject(&m_bitmapBackground);
	pDC->BitBlt(0, 0, m_nCurrentWidth, m_nCurrentHeight, &memDC, 0, 0, SRCCOPY);
	memDC.SelectObject(pOldBitmap);

	return TRUE;
}

void CTaskbarNotifier::OnPaint()
{
	CPaintDC	dc(this);
	CFont		*pOldFont;
			
	if (m_bMouseIsOver)
	{
		dc.SetTextColor(m_crSelectedTextColor);
		pOldFont = dc.SelectObject(&m_fontSelected);
	}
	else
	{
		dc.SetTextColor(m_crNormalTextColor);
		pOldFont = dc.SelectObject(&m_fontNormal);
	}

	dc.SetBkMode(TRANSPARENT); 
	dc.DrawText(m_strCaption, m_rcText, DT_CENTER | DT_VCENTER | DT_NOPREFIX |
		DT_WORDBREAK | DT_END_ELLIPSIS | DT_PATH_ELLIPSIS);

	dc.SelectObject(pOldFont);
}

BOOL CTaskbarNotifier::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if (nHitTest == HTCLIENT)
	{
		::SetCursor(m_hCursor);
		return TRUE;
	}
	return CWnd::OnSetCursor(pWnd, nHitTest, message);
}

void CTaskbarNotifier::OnTimer(UINT nIDEvent)
{
	switch (nIDEvent)
	{
		case IDT_APPEARING:
			m_nAnimStatus = IDT_APPEARING;
			switch(m_nTaskbarPlacement)
			{
				case ABE_BOTTOM:
					if (m_nCurrentHeight < m_nBitmapHeight)
					{
						m_nCurrentPosY -= m_nIncrementShow;
						m_nCurrentHeight += m_nIncrementShow;
					}
					else
					{
						KillTimer(IDT_APPEARING);
						SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
						m_nAnimStatus = IDT_WAITING;
					}
					break;
				case ABE_TOP:
					if (m_nCurrentHeight < m_nBitmapHeight)
						m_nCurrentHeight += m_nIncrementShow;
					else
					{
						KillTimer(IDT_APPEARING);
						SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
						m_nAnimStatus = IDT_WAITING;
					}
					break;
				case ABE_LEFT:
					if (m_nCurrentWidth < m_nBitmapWidth)
						m_nCurrentWidth += m_nIncrementShow;
					else
					{
						KillTimer(IDT_APPEARING);
						SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
						m_nAnimStatus = IDT_WAITING;
					}
					break;
				case ABE_RIGHT:
					if (m_nCurrentWidth < m_nBitmapWidth)
					{
						m_nCurrentPosX -= m_nIncrementShow;
						m_nCurrentWidth += m_nIncrementShow;
					}
					else
					{
						KillTimer(IDT_APPEARING);
						SetTimer(IDT_WAITING, m_dwTimeToStay, NULL);
						m_nAnimStatus = IDT_WAITING;
					}
					break;
			}
			SetWindowPos(&wndTopMost, m_nCurrentPosX, m_nCurrentPosY, m_nCurrentWidth, m_nCurrentHeight, SWP_NOACTIVATE);
			break;

		case IDT_WAITING:
			KillTimer(IDT_WAITING);
			SetTimer(IDT_DISAPPEARING, m_dwHideEvents,NULL);
			break;

		case IDT_DISAPPEARING:
			m_nAnimStatus = IDT_DISAPPEARING;
			switch(m_nTaskbarPlacement)
			{
				case ABE_BOTTOM:
					if (m_nCurrentHeight > 0)
					{
						m_nCurrentPosY += m_nIncrementHide;
						m_nCurrentHeight -= m_nIncrementHide;
					}
					else
					{
						KillTimer(IDT_DISAPPEARING);
						Hide();
					}
					break;
				case ABE_TOP:
					if (m_nCurrentHeight > 0)
						m_nCurrentHeight -= m_nIncrementHide;
					else
					{
						KillTimer(IDT_DISAPPEARING);
						Hide();
					}
					break;
				case ABE_LEFT:
					if (m_nCurrentWidth > 0)
						m_nCurrentWidth -= m_nIncrementHide;
					else
					{
						KillTimer(IDT_DISAPPEARING);
						Hide();
					}
					break;
				case ABE_RIGHT:
					if (m_nCurrentWidth > 0)
					{
						m_nCurrentPosX += m_nIncrementHide;
						m_nCurrentWidth -= m_nIncrementHide;
					}
					else
					{
						KillTimer(IDT_DISAPPEARING);
						Hide();
					}
					break;
			}
			SetWindowPos(&wndTopMost, m_nCurrentPosX, m_nCurrentPosY, m_nCurrentWidth, m_nCurrentHeight, SWP_NOACTIVATE);
			break;
	}

	CWnd::OnTimer(nIDEvent);
}
@


1.22
log
@Removed debug code.
@
text
@d36 4
d70 1
a70 1
	m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(32649)); // System Hand cursor
d122 3
a124 3
	m_myNormalFont.DeleteObject();
	m_myNormalFont.CreatePointFont(nSize, szFont);
	m_myNormalFont.GetLogFont(&lf);
d142 2
a143 2
	m_myNormalFont.DeleteObject();
	m_myNormalFont.CreateFontIndirect(&lf);
d161 2
a162 2
	m_mySelectedFont.DeleteObject();
	m_mySelectedFont.CreateFontIndirect(&lf);
d171 3
a173 3
	m_myNormalFont.DeleteObject();
	m_mySelectedFont.DeleteObject();
	m_myNormalFont.CreateFontIndirect(&lf);
d175 1
a175 1
	m_mySelectedFont.CreateFontIndirect(&lf);
a194 1

d205 1
a205 1
		m_hBitmapRegion = CreateRgnFromBitmap((HBITMAP)m_bitmapBackground.GetSafeHandle(), RGB(red, green, blue));
d212 1
a212 1
BOOL CTaskbarNotifier::SetBitmap(CBitmap* Bitmap, int red, int green, int blue)
d217 1
a217 2

	if (m_bitmapBackground.Attach(Bitmap->Detach()) == NULL)
d226 2
a227 2
		// No need to delete the HRGN,  SetWindowRgn() owns it after being called
		m_hBitmapRegion = CreateRgnFromBitmap((HBITMAP)m_bitmapBackground.GetSafeHandle(), RGB(red, green, blue));
d251 1
a251 1
		m_hBitmapRegion = CreateRgnFromBitmap((HBITMAP)m_bitmapBackground.GetSafeHandle(), RGB(red, green, blue));
d425 1
a425 1
	BITMAP		bm;
d427 2
a428 1
	GetObject(hBmp, sizeof(BITMAP), &bm);	// get bitmap attributes
d430 1
a431 1
	CDC		*pDC = GetDC();
d433 1
a433 2
	if (pDC == NULL)
		return NULL;
a438 1
	const	DWORD RDHDR = sizeof(RGNDATAHEADER);
d452 1
a452 1
	RGNDATAHEADER	*pRgnData = (RGNDATAHEADER*)new BYTE[RDHDR + ++cBlocks * MAXBUF * sizeof(RECT)];
d454 1
a454 1
	memzero(pRgnData, RDHDR + cBlocks * MAXBUF * sizeof(RECT));
d456 1
a456 1
	pRgnData->dwSize	= RDHDR;
d460 1
d470 1
a470 1
				pRects = (LPRECT)((LPBYTE)pRgnData + RDHDR);
d476 1
a476 1
					LPBYTE	pRgnDataNew = new BYTE[RDHDR + ++cBlocks * MAXBUF * sizeof(RECT)];
d478 1
a478 1
					memcpy2(pRgnDataNew, pRgnData, RDHDR + (cBlocks - 1) * MAXBUF * sizeof(RECT));
d490 20
a509 19
		dcBmp.SelectObject(hOldBitmap); //restore default object
		dcBmp.DeleteDC();	//release the bitmap
		// create region
		/*  Under WinNT the ExtCreateRegion returns NULL (by Fable@@aramszu.net) */
		//	HRGN hRgn = ExtCreateRegion( NULL, RDHDR + pRgnData->nCount * sizeof(RECT), (LPRGNDATA)pRgnData );
		/* ExtCreateRegion replacement { */
		HRGN	hRgn = CreateRectRgn(0, 0, 0, 0), hr;

		ASSERT( hRgn != NULL );
		pRects = (LPRECT)((LPBYTE)pRgnData + RDHDR);
		for (i=0; i < (int)pRgnData->nCount; i++)
		{
			hr = CreateRectRgn(pRects[i].left, pRects[i].top, pRects[i].right, pRects[i].bottom);
			VERIFY(CombineRgn(hRgn, hRgn, hr, RGN_OR) != ERROR);
			if (hr != NULL)
				DeleteObject(hr);
		}
		ASSERT( hRgn != NULL );
		/* } ExtCreateRegion replacement */
d511 3
a513 3
		delete[] pRgnData;
		ReleaseDC(pDC);
		return hRgn;
d538 1
a538 1
	TRACKMOUSEEVENT		t_MouseEvent;
d540 4
a543 4
	t_MouseEvent.cbSize      = sizeof(t_MouseEvent);
	t_MouseEvent.dwFlags     = TME_LEAVE | TME_HOVER;
	t_MouseEvent.hwndTrack   = m_hWnd;
	t_MouseEvent.dwHoverTime = 1;
d546 1
a546 1
	::_TrackMouseEvent(&t_MouseEvent);
d571 1
a571 1
LRESULT CTaskbarNotifier::OnMouseHover(WPARAM w, LPARAM l)
d573 1
a573 1
	NOPRM(w); NOPRM(l);
d591 1
a591 1
LRESULT CTaskbarNotifier::OnMouseLeave(WPARAM w, LPARAM l)
d593 1
a593 1
	NOPRM(w); NOPRM(l);
d625 1
a625 1
		pOldFont = dc.SelectObject(&m_mySelectedFont);
d630 1
a630 1
		pOldFont = dc.SelectObject(&m_myNormalFont);
@


1.21
log
@Reworked notification window placement to overcome Wine issue (which reports weird system taskbar position) {Vladimir (SV)}.
@
text
@a20 3
#if 1
#include "emule.h"
#endif
a270 3
#if 1
	g_App.m_pMDlg->AddDebugLogLine(RGB_OLIVE_TXT _T("TaskbarDbg: ScrWid %d ScrHei %d hTray %#x rc %d.%d/%d.%d BmWid %d"), iScreenWidth, iScreenHeight, hWndTaskbar, rcTaskbar.left, rcTaskbar.top, rcTaskbar.right, rcTaskbar.bottom, m_nBitmapWidth);
#endif
@


1.20
log
@Minor goodies from original (smaller rectangular for forced redraw -- on mouse moves for example; Some formatting);
Added debug code to investigate out of screen problem.
@
text
@d3 1
d36 2
a37 8
#define TASKBAR_X_TOLERANCE	40
#define TASKBAR_Y_TOLERANCE 40


inline bool NearlyEqual(int a, int b, int iEpsilon)
{
	return abs(a - b) < iEpsilon / 2;
}
a43 2
// CTaskbarNotifier

d261 2
a262 1
	UINT	nScreenWidth, nScreenHeight, nEvents, nBitmapSize;
d268 2
a269 2
	nScreenWidth = ::GetSystemMetrics(SM_CXSCREEN);
	nScreenHeight = ::GetSystemMetrics(SM_CYSCREEN);
d275 1
a275 1
	g_App.m_pMDlg->AddDebugLogLine(RGB_OLIVE_TXT _T("TaskbarDbg: ScrWid %d ScrHei %d hTray %#x rc %d.%d/%d.%d BmWid %d"), nScreenWidth, nScreenHeight, hWndTaskbar, rcTaskbar.left, rcTaskbar.top, rcTaskbar.right, rcTaskbar.bottom, m_nBitmapWidth);
d278 1
a278 5
	// Daniel Lohmann: Calculate taskbar position from its window rect. However, on XP
	// it may be that the taskbar is slightly larger or smaller than the screen size.
	// Therefore we allow some tolerance here.

	if (NearlyEqual(rcTaskbar.left, 0, TASKBAR_X_TOLERANCE) && NearlyEqual(rcTaskbar.right, nScreenWidth, TASKBAR_X_TOLERANCE ))
d281 4
a284 1
		m_nTaskbarPlacement = NearlyEqual(rcTaskbar.top, 0, TASKBAR_Y_TOLERANCE ) ? ABE_TOP : ABE_BOTTOM;
d287 1
a287 1
	else 
d290 4
a293 1
		m_nTaskbarPlacement = NearlyEqual(rcTaskbar.left, 0, TASKBAR_X_TOLERANCE) ? ABE_LEFT : ABE_RIGHT;
@


1.19
log
@Fixed potential memory corruption while displaying notification window (caused by DT_MODIFYSTRING -- introduced in v1.2a);
Fixed text going beyond notification window (caused by DT_NOCLIP);
Removed unrequired code; Formatting.
@
text
@d20 3
d188 1
a188 1
	RedrawWindow();
d205 1
a205 1
	GetObject(m_bitmapBackground.GetSafeHandle(), sizeof(bm), &bm);
d228 1
a228 1
	GetObject(m_bitmapBackground.GetSafeHandle(), sizeof(bm), &bm);
d252 1
a252 1
	GetObject(m_bitmapBackground.GetSafeHandle(), sizeof(bm), &bm);
d280 3
d371 1
a371 1
			RedrawWindow();
d375 1
a375 1
			RedrawWindow();
d405 1
a405 1
			RedrawWindow();
d587 1
a587 1
		RedrawWindow();
d604 1
a604 1
		RedrawWindow();
@


1.18
log
@Suppressed compiler warnings.
@
text
@d3 2
a15 2
// 08 February 2008 - replaced the window callback function AfxWndProc() to TaskbarWndProc() to fix the MSUL issue.
//                    (for more details see http://www.trigeminal.com/usenet/usenet031.asp?1033)
d36 1
a36 1
inline bool NearlyEqual(int a, int b, int epsilon)
d38 1
a38 1
	return abs(a - b) < epsilon / 2;	
a204 1
	m_rcText.SetRect(0, 0, bm.bmWidth, bm.bmHeight);
d208 1
a208 1
		// No need to delete the HRGN,  SetWindowRgn() owns it after being called
a227 1
	m_rcText.SetRect(0, 0, bm.bmWidth, bm.bmHeight);
a251 1
	m_rcText.SetRect(0, 0, bm.bmWidth, bm.bmHeight);
d255 1
a255 1
		// No need to delete the HRGN,  SetWindowRgn() owns it after being called
d263 1
a263 1
void CTaskbarNotifier::Show(LPCTSTR szCaption,int nMsgType,DWORD dwTimeToShow,DWORD dwTimeToStay,DWORD dwTimeToHide)
d268 1
a268 1
	m_strCaption = szCaption;
d291 1
a291 1
		m_nTaskbarPlacement = NearlyEqual(rcTaskbar.left, 0, TASKBAR_X_TOLERANCE ) ? ABE_LEFT : ABE_RIGHT;
d541 1
a541 1
	t_MouseEvent.cbSize      = sizeof(TRACKMOUSEEVENT);
a620 1
	CRect		rcClient;
d635 3
a637 4
	rcClient.DeflateRect(10, 20, 10, 20);
	dc.DrawText(m_strCaption, m_rcText, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_NOCLIP |
		DT_WORDBREAK | DT_MODIFYSTRING | DT_END_ELLIPSIS | DT_PATH_ELLIPSIS);
	
@


1.17
log
@declare our own windows callback function to support MSLU
@
text
@a16 1

d116 1
a116 1
	ATOM classAtom = RegisterClassEx(&wcx);
d577 1
d597 1
@


1.16
log
@Optimized DrawText -- no need recalculate string length.
@
text
@d14 3
d42 5
d105 1
a105 1
	wcx.lpfnWndProc = AfxWndProc;
@


1.15
log
@Corrected some memory deallocations {tHeWiZaRdOfDoS}.
@
text
@a628 4
	TCHAR	*szBuffer = new TCHAR[m_strCaption.GetLength() + 10];

	_tcscpy(szBuffer, m_strCaption);

d631 1
a631 1
	dc.DrawText(szBuffer, -1, m_rcText, DT_CENTER | DT_VCENTER | DT_NOPREFIX | DT_NOCLIP |
a633 1
	delete[] szBuffer;
@


1.14
log
@Minor corrections and improvements (from original).
@
text
@d477 1
a477 1
					delete pRgnData;
d508 1
a508 1
		delete pRgnData;
@


1.13
log
@Removed non-English comments {brengarne}.
@
text
@d92 3
a94 3
    m_pWndParent = pWndParent;
	
	WNDCLASSEX		wcx; 
d110 1
a110 1
      
d121 1
a121 1
	
d127 1
a127 1
	
d132 1
a132 1
	
d140 1
a140 1
	
d146 1
a146 1
	
d151 1
a151 1
	
d166 1
a166 1
    pFont->GetLogFont(&lf);
d186 1
a186 1
BOOL CTaskbarNotifier::SetBitmap(UINT nBitmapID, short red, short green, short blue)
d210 1
a210 1
BOOL CTaskbarNotifier::SetBitmap(CBitmap* Bitmap, short red, short green, short blue)
d234 1
a234 1
BOOL CTaskbarNotifier::SetBitmap(LPCTSTR szFileName,short red,short green,short blue)
@


1.12
log
@More user friendly display of Files and User values in
 Server list + minor changes.
@
text
@d561 1
a561 4
	// Salva lo stato di activeMessagetype prima che il timer scada e azzeri la variabile
	// in questo modo il messaggio ritornato quando si chiama la funzione dalla 
	// callback di eMuleDlg sarà sempre quello corretto di quando l'utente ha cliccato
	// il messaggio
@


1.11
log
@Slightly better constructor.
@
text
@d430 3
d509 1
@


1.10
log
@Possible fix for Taskbar Notifier focus stealing + Formatting.
@
text
@d42 1
a42 1
CTaskbarNotifier::CTaskbarNotifier()
a43 1
	m_strCaption.Empty();
@


1.9
log
@Fix for taskbar notifier
@
text
@a25 1

d34 1
a34 2

inline bool NearlyEqual( int a, int b, int epsilon )
d36 1
a36 1
	return abs( a - b ) < epsilon / 2;	
d44 23
a66 23
	m_strCaption="";
	m_pWndParent=NULL;
	m_bMouseIsOver=FALSE;
	m_bStarted=FALSE;
	m_hBitmapRegion=NULL;
	m_hCursor=NULL;
	m_crNormalTextColor=RGB(133,146,181);
	m_crSelectedTextColor=RGB(10,36,106);
	m_nBitmapHeight=0;
	m_nBitmapWidth=0;
	
	m_dwTimeToStay=0;
	m_dwShowEvents=0;
	m_dwHideEvents=0;
	m_nCurrentPosX=0;
	m_nCurrentPosY=0;
	m_nCurrentWidth=0;
	m_nCurrentHeight=0;
	m_nIncrementShow=0;
	m_nIncrementHide=0;	
	m_nTaskbarPlacement=ABE_BOTTOM;
	m_nAnimStatus=IDT_HIDDEN;
	m_rcText.SetRect(0,0,0,0);
d69 2
a70 2
	m_nActiveMessageType  = TBN_NULL; //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
	m_nMessageTypeClicked = TBN_NULL; //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
d73 3
a75 2
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize=sizeof(OSVERSIONINFO);
d77 2
a78 2
	if (osvi.dwPlatformId==VER_PLATFORM_WIN32_NT)
		m_dwTimerPrecision=10;
d80 1
a80 1
		m_dwTimerPrecision=50;
d92 2
a93 2
	ASSERT(pWndParent!=NULL);
    m_pWndParent=pWndParent;
d95 1
a95 1
	WNDCLASSEX wcx; 
d99 1
a99 1
	wcx.style = CS_DBLCLKS|CS_SAVEBITS;
d104 2
a105 2
	wcx.hCursor = LoadCursor(NULL,IDC_ARROW);
	wcx.hbrBackground=::GetSysColorBrush(COLOR_WINDOW);
d112 1
a112 1
	return CreateEx(WS_EX_TOPMOST,_T("TaskbarNotifierClass"),NULL,WS_POPUP,0,0,0,0,pWndParent->m_hWnd,NULL);
d115 1
a115 1
void CTaskbarNotifier::SetTextFont(LPCTSTR szFont,int nSize,int nNormalStyle,int nSelectedStyle)
d117 2
a118 1
	LOGFONT lf;
d120 1
a120 1
	m_myNormalFont.CreatePointFont(nSize,szFont);
d130 1
a130 1
		lf.lfItalic=TRUE;
d132 1
a132 1
		lf.lfItalic=FALSE;
d135 1
a135 1
		lf.lfUnderline=TRUE;
d137 1
a137 1
		lf.lfUnderline=FALSE;
d149 1
a149 1
		lf.lfItalic=TRUE;
d151 1
a151 1
		lf.lfItalic=FALSE;
d154 1
a154 1
		lf.lfUnderline=TRUE;
d156 1
a156 1
		lf.lfUnderline=FALSE;
d164 3
a166 2
	LOGFONT lf;
	CFont *pFont=CFont::FromHandle((HFONT)GetStockObject(DEFAULT_GUI_FONT));
d171 1
a171 1
	lf.lfUnderline=TRUE;
d175 1
a175 1
void CTaskbarNotifier::SetTextColor(COLORREF crNormalTextColor,COLORREF crSelectedTextColor)
d177 2
a178 2
	m_crNormalTextColor=crNormalTextColor;
	m_crSelectedTextColor=crSelectedTextColor;
d184 1
a184 1
	m_rcText=rcText;
d187 1
a187 1
BOOL CTaskbarNotifier::SetBitmap(UINT nBitmapID,short red,short green,short blue)
d189 1
a189 1
	BITMAP bm;
d193 1
a193 1
	if (!m_bitmapBackground.LoadBitmap(nBitmapID))
d195 1
d197 3
a199 3
	m_nBitmapWidth=bm.bmWidth;
	m_nBitmapHeight=bm.bmHeight;
	m_rcText.SetRect(0,0,bm.bmWidth,bm.bmHeight);
d201 1
a201 1
	if (red!=-1 && green!=-1 && blue!=-1)
d204 1
a204 1
		m_hBitmapRegion=CreateRgnFromBitmap((HBITMAP)m_bitmapBackground.GetSafeHandle(),RGB(red,green,blue));
d211 1
a211 1
BOOL CTaskbarNotifier::SetBitmap(CBitmap* Bitmap,short red,short green,short blue)
d213 1
a213 1
	BITMAP bm;
d217 1
a217 1
	if (!m_bitmapBackground.Attach(Bitmap->Detach()))
d219 1
d221 3
a223 3
	m_nBitmapWidth=bm.bmWidth;
	m_nBitmapHeight=bm.bmHeight;
	m_rcText.SetRect(0,0,bm.bmWidth,bm.bmHeight);
d225 1
a225 1
	if (red!=-1 && green!=-1 && blue!=-1)
d228 1
a228 1
		m_hBitmapRegion=CreateRgnFromBitmap((HBITMAP)m_bitmapBackground.GetSafeHandle(),RGB(red,green,blue));
d237 4
a240 5
	BITMAP bm;
	HBITMAP hBmp;
	
	hBmp=(HBITMAP) ::LoadImage(AfxGetInstanceHandle(),szFileName,IMAGE_BITMAP,0,0, LR_LOADFROMFILE);
	if (!hBmp)
d246 3
a248 3
	m_nBitmapWidth=bm.bmWidth;
	m_nBitmapHeight=bm.bmHeight;
	m_rcText.SetRect(0,0,bm.bmWidth,bm.bmHeight);
d250 1
a250 1
	if (red!=-1 && green!=-1 && blue!=-1)
d253 1
a253 1
		m_hBitmapRegion=CreateRgnFromBitmap((HBITMAP)m_bitmapBackground.GetSafeHandle(),RGB(red,green,blue));
d262 12
a273 13
	UINT nScreenWidth;
	UINT nScreenHeight;
	UINT nEvents;
	UINT nBitmapSize;
	CRect rcTaskbar;

	m_strCaption=szCaption;
	m_dwTimeToStay=dwTimeToStay;
	
	nScreenWidth=::GetSystemMetrics(SM_CXSCREEN);
	nScreenHeight=::GetSystemMetrics(SM_CYSCREEN);
	HWND hWndTaskbar = ::FindWindow(_T("Shell_TrayWnd"),0);
	::GetWindowRect(hWndTaskbar,&rcTaskbar);
d276 2
a277 2
	// it may be that the taskbar is slightly larger or smaller than the
	// screen size. Therefore we allow some tolerance here.
d279 1
a279 1
	if( NearlyEqual( rcTaskbar.left, 0, TASKBAR_X_TOLERANCE ) && NearlyEqual( rcTaskbar.right, nScreenWidth, TASKBAR_X_TOLERANCE ) )
d282 2
a283 2
		m_nTaskbarPlacement = NearlyEqual( rcTaskbar.top, 0, TASKBAR_Y_TOLERANCE ) ? ABE_TOP : ABE_BOTTOM;
		nBitmapSize=m_nBitmapHeight;
d288 2
a289 2
		m_nTaskbarPlacement = NearlyEqual( rcTaskbar.left, 0, TASKBAR_X_TOLERANCE ) ? ABE_LEFT : ABE_RIGHT;
		nBitmapSize=m_nBitmapWidth;
d295 1
a295 1
		nEvents=min((dwTimeToShow / m_dwTimerPrecision) / 2, nBitmapSize); //<<-- enkeyDEV(Ottavio84) -Reduced frames of a half-
d306 1
a306 1
	if( dwTimeToHide > m_dwTimerPrecision )
d308 1
a308 1
		nEvents = min((dwTimeToHide / m_dwTimerPrecision / 2), nBitmapSize); //<<-- enkeyDEV(Ottavio84) -Reduced frames of a half-
d322 2
a323 1
			if (m_nTaskbarPlacement==ABE_RIGHT)
d325 4
a328 4
				m_nCurrentPosX=rcTaskbar.left;
				m_nCurrentPosY=rcTaskbar.bottom-m_nBitmapHeight;
				m_nCurrentWidth=0;
				m_nCurrentHeight=m_nBitmapHeight;
d330 1
a330 1
			else if (m_nTaskbarPlacement==ABE_LEFT)
d332 4
a335 4
				m_nCurrentPosX=rcTaskbar.right;
				m_nCurrentPosY=rcTaskbar.bottom-m_nBitmapHeight;
				m_nCurrentWidth=0;
				m_nCurrentHeight=m_nBitmapHeight;
d337 1
a337 1
			else if (m_nTaskbarPlacement==ABE_TOP)
d339 4
a342 4
				m_nCurrentPosX=rcTaskbar.right-m_nBitmapWidth;
				m_nCurrentPosY=rcTaskbar.bottom;
				m_nCurrentWidth=m_nBitmapWidth;
				m_nCurrentHeight=0;
d344 1
a344 1
			else //if (m_nTaskbarPlacement==ABE_BOTTOM)
d347 4
a350 4
				m_nCurrentPosX=rcTaskbar.right-m_nBitmapWidth;
				m_nCurrentPosY=rcTaskbar.top;
				m_nCurrentWidth=m_nBitmapWidth;
				m_nCurrentHeight=0;
d353 6
a358 3
			ShowWindow(SW_SHOWNOACTIVATE);	
			m_nActiveMessageType = nMsgType; //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
			SetTimer(IDT_APPEARING,m_dwShowEvents,NULL);			
d360 1
a360 1

d368 1
a368 1
			SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
d373 2
a374 2
			SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
			if (m_nTaskbarPlacement==ABE_RIGHT)
d376 2
a377 2
				m_nCurrentPosX=rcTaskbar.left-m_nBitmapWidth;
				m_nCurrentWidth=m_nBitmapWidth;
d379 1
a379 1
			else if (m_nTaskbarPlacement==ABE_LEFT)
d381 2
a382 2
				m_nCurrentPosX=rcTaskbar.right;
				m_nCurrentWidth=m_nBitmapWidth;
d384 1
a384 1
			else if (m_nTaskbarPlacement==ABE_TOP)
d386 2
a387 2
				m_nCurrentPosY=rcTaskbar.bottom;
				m_nCurrentHeight=m_nBitmapHeight;
d389 1
a389 1
			else //if (m_nTaskbarPlacement==ABE_BOTTOM)
d391 2
a392 2
				m_nCurrentPosY=rcTaskbar.top-m_nBitmapHeight;
				m_nCurrentHeight=m_nBitmapHeight;
d395 1
a395 1
			SetWindowPos(&wndTopMost,m_nCurrentPosX,m_nCurrentPosY,m_nCurrentWidth,m_nCurrentHeight,SWP_NOACTIVATE);
a405 2
			KillTimer(IDT_APPEARING);
			break;
a406 2
			KillTimer(IDT_WAITING);
			break;
d408 1
a408 1
			KillTimer(IDT_DISAPPEARING);
d411 1
a411 1
	MoveWindow(0,0,0,0);
d413 2
a414 2
	m_nAnimStatus=IDT_HIDDEN;
	m_nActiveMessageType=TBN_NULL; //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
d421 6
a426 1
	if (!hBmp) return NULL;
d428 2
a429 2
	BITMAP bm;
	GetObject( hBmp, sizeof(BITMAP), &bm );	// get bitmap attributes
a430 2
	CDC dcBmp;
	CDC *pDC = GetDC();	// FoRcHa
d433 4
a436 1
	HGDIOBJ hOldBitmap = dcBmp.SelectObject(hBmp);//selects the bitmap in the device context
d438 1
a438 3
	const DWORD RDHDR = sizeof(RGNDATAHEADER);
	const DWORD MAXBUF = 40;		// size of one block in RECTs
	// (i.e. MAXBUF*sizeof(RECT) in bytes)
d449 3
a451 2
	RGNDATAHEADER* pRgnData = (RGNDATAHEADER*)new BYTE[ RDHDR + ++cBlocks * MAXBUF * sizeof(RECT) ];
	memzero(pRgnData, RDHDR + cBlocks * MAXBUF * sizeof(RECT) );
d456 3
a458 2
	for ( i = 0; i < bm.bmHeight; i++ )
		for ( j = 0; j < bm.bmWidth; j++ ){
d460 1
a460 1
			ismask=(dcBmp.GetPixel(j,bm.bmHeight-i-1)!=color);
d463 2
a464 1
			if (wasfirst && ((ismask && (j==(bm.bmWidth-1)))||(ismask ^ (j<bm.bmWidth)))){
d468 1
a468 1
				pRects[ pRgnData->nCount++ ] = CRect( first, bm.bmHeight - i - 1, j+(j==(bm.bmWidth-1)), bm.bmHeight - i );
d470 5
a474 3
				if ( pRgnData->nCount >= cBlocks * MAXBUF ){
					LPBYTE pRgnDataNew = new BYTE[ RDHDR + ++cBlocks * MAXBUF * sizeof(RECT) ];
					memcpy2( pRgnDataNew, pRgnData, RDHDR + (cBlocks - 1) * MAXBUF * sizeof(RECT) );
d479 3
a481 1
			} else if ( !wasfirst && ismask ){		// set wasfirst when mask is found
d492 3
a494 2
		HRGN hRgn=CreateRectRgn(0, 0, 0, 0);
		ASSERT( hRgn!=NULL );
d496 1
a496 1
		for(i=0;i<(int)pRgnData->nCount;i++)
d498 4
a501 3
			HRGN hr=CreateRectRgn(pRects[i].left, pRects[i].top, pRects[i].right, pRects[i].bottom);
			VERIFY(CombineRgn(hRgn, hRgn, hr, RGN_OR)!=ERROR);
			if (hr) DeleteObject(hr);
d503 1
a503 1
		ASSERT( hRgn!=NULL );
d510 2
a511 2
//START - enkeyDEV(kei-kun) -TaskbarNotifier-
int CTaskbarNotifier::GetMessageType() {	
d532 2
a533 1
	TRACKMOUSEEVENT t_MouseEvent;
d547 2
a548 1
	CRect rClient;
d550 1
a550 1
	if(point.x >= rClient.right - 8 - 18 && point.x <= rClient.right - 8 &&
d554 1
a554 1
		SetTimer(IDT_DISAPPEARING,m_dwHideEvents,NULL);
d562 1
a562 1
	m_nMessageTypeClicked=m_nActiveMessageType; //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
d564 1
a564 1
	m_pWndParent->PostMessage(WM_TASKBARNOTIFIERCLICKED,0,0);
d570 2
a571 2
	if (m_nAnimStatus==IDT_WAITING) //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
		KillTimer(IDT_WAITING);    //
d573 1
a573 1
	if (m_bMouseIsOver==FALSE)
d575 1
a575 1
		m_bMouseIsOver=TRUE;
d577 2
a578 2
		//START - enkeyDEV(kei-kun) -TaskbarNotifier-
		if (m_nAnimStatus==IDT_DISAPPEARING) {
d580 2
a581 2
			m_nAnimStatus=IDT_APPEARING;
			SetTimer(IDT_APPEARING,m_dwShowEvents,NULL);
a582 1
		//END - enkeyDEV(kei-kun) -TaskbarNotifier-		
d589 1
a589 1
	if (m_bMouseIsOver==TRUE)
d591 1
a591 1
		m_bMouseIsOver=FALSE;
d593 2
a594 4
		//START - enkeyDEV(kei-kun) -TaskbarNotifier-
		if (m_nAnimStatus==IDT_WAITING)
			SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
		//END - enkeyDEV(kei-kun) -TaskbarNotifier-
d601 2
a602 2
	CDC memDC;
	CBitmap *pOldBitmap;
d605 2
a606 2
	pOldBitmap=memDC.SelectObject(&m_bitmapBackground);
	pDC->BitBlt(0,0,m_nCurrentWidth,m_nCurrentHeight,&memDC,0,0,SRCCOPY);
d614 3
a616 3
	CPaintDC dc(this);
	CRect rcClient;
	CFont *pOldFont;
d621 1
a621 1
		pOldFont=dc.SelectObject(&m_mySelectedFont);
d626 1
a626 1
		pOldFont=dc.SelectObject(&m_myNormalFont);
d629 3
a631 2
	TCHAR * szBuffer=new TCHAR[m_strCaption.GetLength()+10];
	_tcscpy(szBuffer,m_strCaption);
d634 1
a634 1
	rcClient.DeflateRect(10,20,10,20);
d636 1
a636 1
		DT_WORDBREAK | DT_MODIFYSTRING | DT_END_ELLIPSIS | DT_PATH_ELLIPSIS );
d657 1
a657 1
			m_nAnimStatus=IDT_APPEARING;
d661 1
a661 1
					if (m_nCurrentHeight<m_nBitmapHeight)
d663 2
a664 2
						m_nCurrentPosY-=m_nIncrementShow;
						m_nCurrentHeight+=m_nIncrementShow;
d669 2
a670 2
						SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
						m_nAnimStatus=IDT_WAITING;
d674 2
a675 2
					if (m_nCurrentHeight<m_nBitmapHeight)
						m_nCurrentHeight+=m_nIncrementShow;
d679 2
a680 2
						SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
						m_nAnimStatus=IDT_WAITING;
d684 2
a685 2
					if (m_nCurrentWidth<m_nBitmapWidth)
						m_nCurrentWidth+=m_nIncrementShow;
d689 2
a690 2
						SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
						m_nAnimStatus=IDT_WAITING;
d694 1
a694 1
					if (m_nCurrentWidth<m_nBitmapWidth)
d696 2
a697 2
						m_nCurrentPosX-=m_nIncrementShow;
						m_nCurrentWidth+=m_nIncrementShow;
d702 2
a703 2
						SetTimer(IDT_WAITING,m_dwTimeToStay,NULL);
						m_nAnimStatus=IDT_WAITING;
d707 1
a707 1
			SetWindowPos(&wndTopMost,m_nCurrentPosX,m_nCurrentPosY,m_nCurrentWidth,m_nCurrentHeight,SWP_NOACTIVATE);
d712 1
a712 1
			SetTimer(IDT_DISAPPEARING,m_dwHideEvents,NULL);
d716 1
a716 1
			m_nAnimStatus=IDT_DISAPPEARING;
d720 1
a720 1
					if (m_nCurrentHeight>0)
d722 2
a723 2
						m_nCurrentPosY+=m_nIncrementHide;
						m_nCurrentHeight-=m_nIncrementHide;
d732 2
a733 2
					if (m_nCurrentHeight>0)
						m_nCurrentHeight-=m_nIncrementHide;
d741 2
a742 2
					if (m_nCurrentWidth>0)
						m_nCurrentWidth-=m_nIncrementHide;
d750 1
a750 1
					if (m_nCurrentWidth>0)
d752 2
a753 2
						m_nCurrentPosX+=m_nIncrementHide;
						m_nCurrentWidth-=m_nIncrementHide;
d762 1
a762 1
			SetWindowPos(&wndTopMost,m_nCurrentPosX,m_nCurrentPosY,m_nCurrentWidth,m_nCurrentHeight,SWP_NOACTIVATE);
@


1.8
log
@More correct way to display '&' in Notifier window; slightly faster output mode;
Removal of unrequired method and class member.
@
text
@d49 1
@


1.7
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@a67 1
	m_uTextFormat=DT_CENTER | DT_VCENTER | DT_WORDBREAK | DT_MODIFYSTRING | DT_END_ELLIPSIS | DT_PATH_ELLIPSIS; // Default Text format (see DrawText in the win32 API for the different values)
a184 5
void CTaskbarNotifier::SetTextFormat(UINT uTextFormat)
{
	m_uTextFormat=uTextFormat;
}

d620 2
a621 1
	dc.DrawText(szBuffer,-1,m_rcText,m_uTextFormat);
@


1.6
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d450 1
a450 1
	memset2( pRgnData, 0, RDHDR + cBlocks * MAXBUF * sizeof(RECT) );
@


1.5
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d450 1
a450 1
	memset( pRgnData, 0, RDHDR + cBlocks * MAXBUF * sizeof(RECT) );
@


1.4
log
@unicode cleanup
@
text
@d17 1
a17 1
#include "memcpy_amd.h"
d469 1
a469 5
					#ifndef AMD
					memcpy( pRgnDataNew, pRgnData, RDHDR + (cBlocks - 1) * MAXBUF * sizeof(RECT) );
					#else
					memcpy_amd( pRgnDataNew, pRgnData, RDHDR + (cBlocks - 1) * MAXBUF * sizeof(RECT) );
					#endif
@


1.3
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d108 1
a108 1
	wcx.lpszClassName = "TaskbarNotifierClass";
d113 1
a113 1
	return CreateEx(WS_EX_TOPMOST,"TaskbarNotifierClass",NULL,WS_POPUP,0,0,0,0,pWndParent->m_hWnd,NULL);
d276 1
a276 1
	HWND hWndTaskbar = ::FindWindow("Shell_TrayWnd",0);
d613 1
a613 2
	char *szBuffer;
		
d625 2
a626 2
	szBuffer=new char[m_strCaption.GetLength()+10];
	strcpy(szBuffer,m_strCaption);
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d17 1
d469 1
d471 3
@


1.2.8.1
log
@27a partial merge
@
text
@d4 3
a6 3
//		   Complete change in the way the popup is showing (thanks to this,now the popup can be always on top, it shows even while watching a movie)
//		   The popup doesn't steal the focus anymore (by replacing ShowWindow(SW_SHOW) by ShowWindow(SW_SHOWNOACTIVATE))
//		   Thanks to Daniel Lohmann, update in the way the taskbar pos is determined (more flexible now)
d10 3
a12 3
//		 (now handles the presence of quick launch or any other bar).
//		 Remove the Handlers for WM_CREATE and WM_DESTROY
//		 SetSkin is now called SetBitmap
a13 3
// kei-kun modifications:
// 30 October  2002: - Added event type management (TBN_*) for eMule project
// 04 November 2002: - added skin support via .ini file
a15 2
#include "ini2.h"
#include "otherfunctions.h"
a16 2
#include "enbitmap.h"
#include "emule.h"
d18 11
a28 3
#define IDT_HIDDEN		0
#define IDT_APPEARING	1
#define IDT_WAITING		2
d30 4
a33 2
#define TASKBAR_X_TOLERANCE	10
#define TASKBAR_Y_TOLERANCE 10
a63 3
	m_dwTimeToShow=500;
	m_dwTimeToStay=4000;
	m_dwTimeToHide=200;
d67 1
a67 2
	m_rcCloseBtn.SetRect(0,0,0,0);
	m_uTextFormat=DT_MODIFYSTRING | DT_WORDBREAK | DT_PATH_ELLIPSIS | DT_END_ELLIPSIS; // Default Text format (see DrawText in the win32 API for the different values)
d70 2
a71 5
	m_nHistoryPosition = 0;
	m_nActiveMessageType  = TBN_NULL; 
	//m_nMessageTypeClicked = TBN_NULL; 
	m_bTextSelected = FALSE;
	m_bAutoClose = TRUE;
d87 1
a87 6
	// No need to delete the HRGN,	SetWindowRgn() owns it after being called
	CTaskbarNotifierHistory* messagePTR;
	while (m_MessageHistory.GetCount() > 0) {
		messagePTR = (CTaskbarNotifierHistory*) m_MessageHistory.RemoveTail();
		delete messagePTR;
	}
a114 82
BOOL CTaskbarNotifier::LoadConfiguration(LPCTSTR szFileName) {
	char buffer[510];
	int nRed, nGreen, nBlue, sRed, sGreen, sBlue;
	int rcLeft, rcTop, rcRight, rcBottom;	
	int bmpTrasparentRed, bmpTrasparentGreen, bmpTrasparentBlue;
	int fontSize;
	CString fontType, bmpFullPath;
	
	Hide();

	CIni ini(szFileName,"CONFIG" );
	_tcscpy(buffer, szFileName);
	LPTSTR pszFileName = _tcsrchr(buffer, '\\');

	if (pszFileName != NULL) {
		*(pszFileName+1) = '\0';
	}
	else
		return FALSE;

	nRed   = ini.GetInt("TextNormalRed",255);
	nGreen = ini.GetInt("TextNormalGreen",255);
	nBlue  = ini.GetInt("TextNormalBlue",255);
	sRed   = ini.GetInt("TextSelectedRed",255);
	sGreen = ini.GetInt("TextSelectedGreen",255);
	sBlue  = ini.GetInt("TextSelectedBlue",255);
	bmpTrasparentRed   = ini.GetInt("bmpTrasparentRed",255);
	bmpTrasparentGreen = ini.GetInt("bmpTrasparentGreen",0);
	bmpTrasparentBlue  = ini.GetInt("bmpTrasparentBlue",255);
	fontSize = ini.GetInt("TextFontSize",70);		
	//m_dwTimeToStay = ini.GetInt("TimeToStay", 4000);
	m_dwTimeToShow = ini.GetInt("TimeToShow", 500); 
	m_dwTimeToHide = ini.GetInt("TimeToHide", 200);
	fontType = ini.GetString("FontType", "Arial");
	bmpFullPath.Format("%s\\%s", buffer, ini.GetString("bmpFileName", "")); 

	// get text rectangle coordinates
	rcLeft = ini.GetInt("rcTextLeft",5);
	rcTop  = ini.GetInt("rcTextTop",45);	
	rcRight  = ini.GetInt("rcTextRight",220 );
	rcBottom = ini.GetInt("rcTextBottom", 85);
	if (rcLeft<=0)	  rcLeft=1;
	if (rcTop<=0)	  rcTop=1;	
	if (rcRight<=0)   rcRight=1;
	if (rcBottom<=0)  rcBottom=1;	
	SetTextRect(CRect(rcLeft,rcTop,rcRight,rcBottom));

	// get close button rectangle coordinates
	rcLeft = ini.GetInt("rcCloseBtnLeft",286);
	rcTop  = ini.GetInt("rcCloseBtnTop",40); 
	rcRight  = ini.GetInt("rcCloseBtnRight", 300);
	rcBottom = ini.GetInt("rcCloseBtnBottom", 54);
	if (rcLeft<=0)	  rcLeft=1;
	if (rcTop<=0)	  rcTop=1;	
	if (rcRight<=0)   rcRight=1;
	if (rcBottom<=0)  rcBottom=1;	
	SetCloseBtnRect(CRect(rcLeft,rcTop,rcRight,rcBottom));
	
	// get history button rectangle coordinates
	rcLeft = ini.GetInt("rcHistoryBtnLeft",283);
	rcTop  = ini.GetInt("rcHistoryBtnTop",14);	
	rcRight  = ini.GetInt("rcHistoryBtnRight", 299);
	rcBottom = ini.GetInt("rcHistoryBtnBottom", 39);
	if (rcLeft<=0)	  rcLeft=1;
	if (rcTop<=0)	  rcTop=1;	
	if (rcRight<=0)   rcRight=1;
	if (rcBottom<=0)  rcBottom=1;	
	SetHistoryBtnRect(CRect(rcLeft,rcTop,rcRight,rcBottom));

	if (!SetBitmap(bmpFullPath, bmpTrasparentRed, bmpTrasparentGreen, bmpTrasparentBlue))
	{
		CEnBitmap m_imgTaskbar;
		VERIFY (m_imgTaskbar.LoadImage(IDR_POPUP,"JPG"));
		if (!SetBitmap(&m_imgTaskbar, bmpTrasparentRed, bmpTrasparentGreen, bmpTrasparentBlue))
			return FALSE;
	}

	SetTextFont(fontType, fontSize,TN_TEXT_NORMAL,TN_TEXT_UNDERLINE);
	SetTextColor(RGB(nRed,nGreen,nBlue),RGB(sRed,sGreen,sBlue));	
	return TRUE;
}

a184 10
void CTaskbarNotifier::SetCloseBtnRect(RECT rcCloseBtn)
{
	m_rcCloseBtn=rcCloseBtn;
}
	
void CTaskbarNotifier::SetHistoryBtnRect(RECT rcHistoryBtn)
{
	m_rcHistoryBtn=rcHistoryBtn;
}

d201 1
a201 1
	//m_rcText.SetRect(0,0,bm.bmWidth,bm.bmHeight);
d205 1
a205 1
		// No need to delete the HRGN,	SetWindowRgn() owns it after being called
d212 1
d224 1
a224 1
	//m_rcText.SetRect(0,0,bm.bmWidth,bm.bmHeight);
d235 1
d250 1
a250 1
	//m_rcText.SetRect(0,0,bm.bmWidth,bm.bmHeight);
d254 1
a254 1
		// No need to delete the HRGN,	SetWindowRgn() owns it after being called
d262 1
a262 33
void CTaskbarNotifier::SetAutoClose(BOOL autoClose) {
		m_bAutoClose=autoClose;
		if (autoClose == TRUE) {
			switch (m_nAnimStatus)
			{
				case IDT_APPEARING:
					KillTimer(IDT_APPEARING);
					break;
				case IDT_WAITING:
					KillTimer(IDT_WAITING);
					break;
				case IDT_DISAPPEARING:
					KillTimer(IDT_DISAPPEARING);
					break;
			}		
			m_nAnimStatus=IDT_DISAPPEARING;
			SetTimer(IDT_DISAPPEARING,m_dwHideEvents,NULL);
		}
}

void CTaskbarNotifier::ShowLastHistoryMessage()
{
	CTaskbarNotifierHistory* messagePTR;
	if (m_MessageHistory.GetCount() > 0) {
		messagePTR = (CTaskbarNotifierHistory*) m_MessageHistory.RemoveHead();
		Show(messagePTR->m_strMessage,	messagePTR->m_nMessageType, TRUE,theApp.glob_prefs->NotificationDisplayTime());
		delete messagePTR;
	}	
	else
		Show(GetResString(IDS_TBN_NOMESSAGEHISTORY), TBN_NULL, TRUE,theApp.glob_prefs->NotificationDisplayTime());
}

void CTaskbarNotifier::Show(LPCTSTR szCaption,int nMsgType, BOOL bAutoClose, DWORD dwTimeToStay)
a263 2
	if (nMsgType == TBN_NONOTIFY)
		return;
a268 1
	CTaskbarNotifierHistory* messagePTR;
d271 1
a271 4
	m_nActiveMessageType = nMsgType;

	if (m_bAutoClose) // sets it only if already true, else wait for user action 
		m_bAutoClose=bAutoClose;
a272 14
	if ((nMsgType != TBN_NULL) && (nMsgType != TBN_LOG) //&& (nMsgType != TBN_ERROR)
		&& (nMsgType != TBN_IMPORTANTEVENT)) {
		//Add element into string list. Max 5 elements.
		if (m_MessageHistory.GetCount() == 5)	{
			messagePTR = (CTaskbarNotifierHistory*) m_MessageHistory.RemoveHead();
			delete messagePTR;
			messagePTR=NULL;
		}
		messagePTR = new CTaskbarNotifierHistory;
		messagePTR->m_strMessage=m_strCaption;
		messagePTR->m_nMessageType=nMsgType;
		m_MessageHistory.AddTail(messagePTR);
	}
		
d296 1
a296 1
	if (m_dwTimeToShow > m_dwTimerPrecision)
d298 2
a299 2
		nEvents=min((m_dwTimeToShow / m_dwTimerPrecision) / 2, nBitmapSize); //<<-- enkeyDEV(Ottavio84) -Reduced frames of a half-
		m_dwShowEvents = m_dwTimeToShow / nEvents;
d309 1
a309 1
	if( m_dwTimeToHide > m_dwTimerPrecision )
d311 2
a312 2
		nEvents = min((m_dwTimeToHide / m_dwTimerPrecision / 2), nBitmapSize); //<<-- enkeyDEV(Ottavio84) -Reduced frames of a half-
		m_dwHideEvents = m_dwTimeToHide / nEvents;
d355 2
a356 1
			ShowWindow(SW_SHOWNOACTIVATE);				
d427 1
a427 1
	GetObject( hBmp, sizeof(BITMAP), &bm ); // get bitmap attributes
d433 1
a433 1
	dcBmp.SelectObject(hBmp);			//selects the bitmap in the device context
d438 1
a438 1
	LPRECT	pRects; 							
d445 1
a445 1
	bool	ismask; 				// set when current color is mask color
d452 1
a452 1
	pRgnData->iType 	= RDH_RECTANGLES;
d478 1
d502 1
a502 2
	//return m_nMessageTypeClicked;
	return m_nActiveMessageType;
d521 1
a521 1
{		
d523 3
a525 3
	t_MouseEvent.cbSize	 = sizeof(TRACKMOUSEEVENT);
	t_MouseEvent.dwFlags	 = TME_LEAVE | TME_HOVER;
	t_MouseEvent.hwndTrack	 = m_hWnd;
d536 8
a543 22
	CTaskbarNotifierHistory* messagePTR;

	// close button clicked
	if (m_rcCloseBtn.PtInRect(point)) {
			m_bAutoClose=TRUE; // set true so next time arrive an autoclose event the popup will autoclose 
							   // (when m_bAutoClose is false a "true" event will be ignored until the user 
							   // manually close the windows)			
			switch (m_nAnimStatus)
			{
				case IDT_APPEARING:
					KillTimer(IDT_APPEARING);
					break;
				case IDT_WAITING:
					KillTimer(IDT_WAITING);
					break;
				case IDT_DISAPPEARING:
					KillTimer(IDT_DISAPPEARING);
					break;
			}		
			m_nAnimStatus=IDT_DISAPPEARING;
			SetTimer(IDT_DISAPPEARING,m_dwHideEvents,NULL);
			//Hide();					
d545 8
a552 16

	// cycle history button clicked
			if (m_rcHistoryBtn.PtInRect(point)) {			
			if (m_MessageHistory.GetCount() > 0) {
				messagePTR = (CTaskbarNotifierHistory*) m_MessageHistory.RemoveHead();
				Show(messagePTR->m_strMessage,	messagePTR->m_nMessageType, TRUE, theApp.glob_prefs->NotificationDisplayTime());
				delete messagePTR;
			}			
		}

	// message clicked
			if (m_rcText.PtInRect(point)) { 	 
			// Notify the parent window that the Notifier popup was clicked
			m_pWndParent->PostMessage(WM_TASKBARNOTIFIERCLICKED,0,0);
		}

d557 2
a558 2
{	
	if (m_nAnimStatus=IDT_WAITING) //<<--enkeyDEV(kei-kun) -TaskbarNotifier-
a560 5
	POINTS mp;
	mp = MAKEPOINTS(l);
	m_ptMousePosition.x =  mp.x;
	m_ptMousePosition.y = mp.y;
	
a563 1
		 
d565 7
a572 11
	else 
		if ((m_ptMousePosition.x >= m_rcText.left) && (m_ptMousePosition.x <= m_rcText.right)
			&& (m_ptMousePosition.y >= m_rcText.top) && (m_ptMousePosition.y <= m_rcText.bottom)) { 			
				if (!m_bTextSelected)
					RedrawWindow();
			}
		else {
				if (m_bTextSelected)
					RedrawWindow();
		}
	
d609 1
a609 1

d612 2
a613 12
		if ((m_ptMousePosition.x >= m_rcText.left) && (m_ptMousePosition.x <= m_rcText.right)
			&& (m_ptMousePosition.y >= m_rcText.top) && (m_ptMousePosition.y <= m_rcText.bottom)) { 	
				
				m_bTextSelected = TRUE;
				dc.SetTextColor(m_crSelectedTextColor);
				pOldFont=dc.SelectObject(&m_mySelectedFont);
			}
		else {
			m_bTextSelected = FALSE;
			dc.SetTextColor(m_crNormalTextColor);
			pOldFont=dc.SelectObject(&m_myNormalFont);
		}
d636 2
a637 6
		if (m_rcCloseBtn.PtInRect(m_ptMousePosition) ||
			m_rcHistoryBtn.PtInRect(m_ptMousePosition) ||
			m_rcText.PtInRect(m_ptMousePosition)) {
                ::SetCursor(m_hCursor);
                return TRUE;
			}
d702 1
a702 2
			if (m_bAutoClose)
				SetTimer(IDT_DISAPPEARING,m_dwHideEvents,NULL);
@


1.2.8.2
log
@*** empty log message ***
@
text
@d68 1
a68 1
	m_uTextFormat=DT_CENTER | DT_VCENTER | DT_WORDBREAK | DT_MODIFYSTRING | DT_END_ELLIPSIS | DT_PATH_ELLIPSIS; // Default Text format (see DrawText in the win32 API for the different values)
@


1.1
log
@*** empty log message ***
@
text
@d18 8
d32 2
@


1.1.4.1
log
@updating this branch...
@
text
@@

