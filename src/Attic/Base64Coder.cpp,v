head	1.4;
access;
symbols
	PublicRelease_1_2:1.3
	Interim_Release_1-2_RC1:1.3
	Interim_Release_1-2_beta1:1.3
	PublicRelease_1_1g:1.3
	Interim_Release_1-1g_RC3:1.3
	Interim_Release_1-1g_RC2:1.3
	Interim_Release_1-1g_RC1:1.3
	Interim_Release_1-1g_beta2:1.3
	Interim_Release_1-1g_beta1:1.3
	PublicRelease_1_1f:1.3
	Interim_Release_1-1f_RC1:1.3
	PublicRelease_1_1e:1.3
	Interim_Release_1-1e_RC2:1.3
	Interim_Release_1-1e_RC1:1.3
	Interim_Release_1-1e_beta1:1.3
	PublicRelease_1_1d:1.3
	Interim_Release_1-1d_RC1:1.3
	PublicRelease_1_1c:1.3
	Interim_Release_1-1c_RC1:1.3
	Interim_Release_1-1c_beta2:1.3
	Interim_Release_1-1c_beta1:1.3
	PublicRelease_1_1b:1.3
	Interim_Release_1-1b_RC1:1.3
	PublicRelease_1_1a:1.3
	Interim_Release_1-1a_RC2:1.3
	Interim_Release_1-1a_RC1:1.3
	Interim_Release_1-1a_beta2:1.3
	Interim_Release_1-1a_beta1:1.3
	PublicRelease_1_1:1.3
	Interim_Release_1-1_beta1:1.3
	PublicRelease_1o:1.3
	Interim_Release_1o_RC1:1.3
	Interim_Release_1o_beta1:1.3
	PublicRelease_1n:1.3
	Interim_Release_1n_RC2:1.3
	Interim_Release_1n_RC1:1.3
	Interim_Release_1n_beta2:1.3
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.3
	Interim_Release_1l_RC1:1.3
	Interim_Release_1l_beta2:1.3
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1;
locks; strict;
comment	@// @;


1.4
date	2006.04.04.23.43.28;	author kush_eplus;	state dead;
branches;
next	1.3;

1.3
date	2004.05.05.06.09.20;	author katsyonak;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.08.01.49.29;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.27.19.56.57;	author dongato;	state Exp;
branches;
next	;


desc
@@


1.4
log
@new email notifier code (adapted from original) - fully UNICODE ready
@
text
@/*
Module : Base64Coder.CPP
Purpose: Implementation for the Base64 encoder / decoder class
Created: PJN / 20-06-2000
History: None

Copyright (c) 1998 - 2002 by PJ Naughter.  
All rights reserved.

*/

//////////////// Includes ////////////////////////////////////////////

#include "stdafx.h"
#include "Base64Coder.h"



//////////////// Macros / Locals /////////////////////////////////////

static char	Base64Digits[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
BOOL CBase64Coder::m_Init		= FALSE;
char CBase64Coder::m_DecodeTable[256];

#ifndef PAGESIZE
#define PAGESIZE					4096
#endif

#ifndef ROUNDTOPAGE
#define ROUNDTOPAGE(a)			(((a/4096)+1)*4096)
#endif



////////////////// Implementation ////////////////////////////////////

CBase64Coder::CBase64Coder() : m_pDBuffer(NULL), m_pEBuffer(NULL),
	                           m_nDBufLen(0),	m_nEBufLen(0)
{
}

CBase64Coder::~CBase64Coder()
{
	if (m_pDBuffer != NULL)
  {
		delete [] m_pDBuffer;
    m_pDBuffer = NULL;
  }

	if (m_pEBuffer != NULL)
  {
		delete [] m_pEBuffer;
    m_pEBuffer = NULL;
  }
}

LPSTR CBase64Coder::DecodedMessage() const 
{ 
	return (LPSTR) m_pDBuffer;
}

LPSTR CBase64Coder::EncodedMessage() const
{ 
	return (LPSTR) m_pEBuffer;
}

LONG CBase64Coder::DecodedMessageSize() const 
{ 
	return m_nDDataLen;
}

LONG CBase64Coder::EncodedMessageSize() const
{ 
	return m_nEDataLen;
}

void CBase64Coder::AllocEncode(DWORD nSize)
{
	if (m_nEBufLen < nSize)
	{
		if (m_pEBuffer != NULL)
			delete [] m_pEBuffer;

		m_nEBufLen = ROUNDTOPAGE(nSize);
		m_pEBuffer = new BYTE[m_nEBufLen];
	}

	memzero(m_pEBuffer, m_nEBufLen);
	m_nEDataLen = 0;
}

void CBase64Coder::AllocDecode(DWORD nSize)
{
	if (m_nDBufLen < nSize)
	{
		if (m_pDBuffer != NULL)
			delete [] m_pDBuffer;

		m_nDBufLen = ROUNDTOPAGE(nSize);
		m_pDBuffer = new BYTE[m_nDBufLen];
	}

	memzero(m_pDBuffer, m_nDBufLen);
	m_nDDataLen = 0;
}

void CBase64Coder::SetEncodeBuffer(const PBYTE pbyteBuffer, DWORD nBufLen)
{
	DWORD	i = 0;

	AllocEncode(nBufLen);
	while(i < nBufLen)
	{
		if (!_IsBadMimeChar(pbyteBuffer[i]))
		{
			m_pEBuffer[m_nEDataLen] = pbyteBuffer[i];
			m_nEDataLen++;
		}
		i++;
	}
}

void CBase64Coder::SetDecodeBuffer(const PBYTE pbyteBuffer, DWORD nBufLen)
{
	AllocDecode(nBufLen);
	memcpy2(m_pDBuffer, pbyteBuffer, nBufLen);
	m_nDDataLen = nBufLen;
}

void CBase64Coder::Encode(const PBYTE pbyteBuffer, DWORD nBufLen)
{
	SetDecodeBuffer(pbyteBuffer, nBufLen);
	AllocEncode(nBufLen * 2);

	TempBucket Raw;
	DWORD	nIndex	= 0;
	while ((nIndex + 3) <= nBufLen)
	{
		Raw.Clear();
		memcpy2(&Raw, m_pDBuffer + nIndex, 3);
		Raw.nSize = 3;
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		nIndex += 3;
		m_nEDataLen	+= 4;
	}

	if (nBufLen > nIndex)
	{
		Raw.Clear();
		Raw.nSize = (BYTE) (nBufLen - nIndex);
		memcpy2(&Raw, m_pDBuffer + nIndex, nBufLen - nIndex);
		_EncodeToBuffer(Raw, m_pEBuffer + m_nEDataLen);
		m_nEDataLen += 4;
	}
}

void CBase64Coder::Encode(LPCSTR szMessage)
{
	if (szMessage != NULL)
		Encode((const PBYTE)szMessage, strlen(szMessage));
}

void CBase64Coder::Decode(const PBYTE pbyteBuffer, DWORD dwBufLen)
{
	if (!CBase64Coder::m_Init)
		_Init();

	SetEncodeBuffer(pbyteBuffer, dwBufLen);
	AllocDecode(dwBufLen);

	TempBucket Raw;
	DWORD	nIndex = 0;
	while((nIndex + 4) <= m_nEDataLen)
	{
		Raw.Clear();
		Raw.nData[0] = CBase64Coder::m_DecodeTable[m_pEBuffer[nIndex]];
		Raw.nData[1] = CBase64Coder::m_DecodeTable[m_pEBuffer[nIndex + 1]];
		Raw.nData[2] = CBase64Coder::m_DecodeTable[m_pEBuffer[nIndex + 2]];
		Raw.nData[3] = CBase64Coder::m_DecodeTable[m_pEBuffer[nIndex + 3]];

		if (Raw.nData[2] == 255)
			Raw.nData[2] = 0;
		if (Raw.nData[3] == 255)
			Raw.nData[3] = 0;
		
		Raw.nSize = 4;
		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		nIndex += 4;
		m_nDDataLen += 3;
	}
	
   // If nIndex < m_nEDataLen, then we got a decode message without padding.
   // We may want to throw some kind of warning here, but we are still required
   // to handle the decoding as if it was properly padded.
	if (nIndex < m_nEDataLen)
	{
		Raw.Clear();
		for (DWORD i=nIndex; i<m_nEDataLen; i++)
		{
			Raw.nData[i - nIndex] = CBase64Coder::m_DecodeTable[m_pEBuffer[i]];
			Raw.nSize++;
			if(Raw.nData[i - nIndex] == 255)
				Raw.nData[i - nIndex] = 0;
		}

		_DecodeToBuffer(Raw, m_pDBuffer + m_nDDataLen);
		m_nDDataLen += (m_nEDataLen - nIndex);
	}
}

void CBase64Coder::Decode(LPCSTR szMessage)
{
	if (szMessage != NULL)
		Decode((const PBYTE)szMessage, strlen(szMessage));
}

DWORD CBase64Coder::_DecodeToBuffer(const TempBucket &Decode, PBYTE pbyteBuffer)
{
	TempBucket	Data;
	DWORD	nCount = 0;

	_DecodeRaw(Data, Decode);

	for (int i=0; i<3; i++)
	{
		pbyteBuffer[i] = Data.nData[i];
		if(pbyteBuffer[i] != 255)
			nCount++;
	}

	return nCount;
}


void CBase64Coder::_EncodeToBuffer(const TempBucket &Decode, PBYTE pbyteBuffer)
{
	TempBucket Data;

	_EncodeRaw(Data, Decode);

	for (int i=0; i<4; i++)
		pbyteBuffer[i] = Base64Digits[Data.nData[i]];

	switch (Decode.nSize)
	{
	  case 1:
		  pbyteBuffer[2] = '=';
	  case 2:
		  pbyteBuffer[3] = '=';
	}
}

void CBase64Coder::_DecodeRaw(TempBucket &Data, const TempBucket &Decode)
{
	BYTE nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] <<= 2;

	nTemp = Decode.nData[1];
	nTemp >>= 4;
	nTemp &= 0x03;
	Data.nData[0] |= nTemp;

	Data.nData[1] = Decode.nData[1];
	Data.nData[1] <<= 4;

	nTemp = Decode.nData[2];
	nTemp >>= 2;
	nTemp &= 0x0F;
	Data.nData[1] |= nTemp;

	Data.nData[2] = Decode.nData[2];
	Data.nData[2] <<= 6;
	nTemp = Decode.nData[3];
	nTemp &= 0x3F;
	Data.nData[2] |= nTemp;
}

void CBase64Coder::_EncodeRaw(TempBucket &Data, const TempBucket &Decode)
{
	BYTE nTemp;

	Data.nData[0] = Decode.nData[0];
	Data.nData[0] >>= 2;
	
	Data.nData[1] = Decode.nData[0];
	Data.nData[1] <<= 4;
	nTemp = Decode.nData[1];
	nTemp >>= 4;
	Data.nData[1] |= nTemp;
	Data.nData[1] &= 0x3F;

	Data.nData[2] = Decode.nData[1];
	Data.nData[2] <<= 2;

	nTemp = Decode.nData[2];
	nTemp >>= 6;

	Data.nData[2] |= nTemp;
	Data.nData[2] &= 0x3F;

	Data.nData[3] = Decode.nData[2];
	Data.nData[3] &= 0x3F;
}

BOOL CBase64Coder::_IsBadMimeChar(BYTE nData)
{
	switch(nData)
	{
		case '\r': case '\n': case '\t': case ' ' :
		case '\b': case '\a': case '\f': case '\v':
			return TRUE;
		default:
			return FALSE;
	}
}

void CBase64Coder::_Init()
{  
  // Initialize Decoding table.
	int	i;
	for (i=0; i<256; i++)
		CBase64Coder::m_DecodeTable[i] = -2;

	for (i=0; i<64; i++)
	{
		CBase64Coder::m_DecodeTable[Base64Digits[i]]	= (char) i;
		CBase64Coder::m_DecodeTable[Base64Digits[i]|0x80] = (char) i;
	}

	CBase64Coder::m_DecodeTable['=']	= -1;
	CBase64Coder::m_DecodeTable['='|0x80] = -1;
	CBase64Coder::m_Init = TRUE;
}

@


1.3
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@@


1.2
log
@Formatting, comments, and name changes
@
text
@d88 1
a88 1
	::ZeroMemory(m_pEBuffer, m_nEBufLen);
d103 1
a103 1
	::ZeroMemory(m_pDBuffer, m_nDBufLen);
d126 1
a126 1
	::CopyMemory(m_pDBuffer, pbyteBuffer, nBufLen);
d140 1
a140 1
		::CopyMemory(&Raw, m_pDBuffer + nIndex, 3);
d151 1
a151 1
		::CopyMemory(&Raw, m_pDBuffer + nIndex, nBufLen - nIndex);
@


1.1
log
@SMTP Messenger: added authentication
@
text
@d107 1
a107 1
void CBase64Coder::SetEncodeBuffer(const PBYTE pBuffer, DWORD nBufLen)
d114 1
a114 1
		if (!_IsBadMimeChar(pBuffer[i]))
d116 1
a116 1
			m_pEBuffer[m_nEDataLen] = pBuffer[i];
d123 1
a123 1
void CBase64Coder::SetDecodeBuffer(const PBYTE pBuffer, DWORD nBufLen)
d126 1
a126 1
	::CopyMemory(m_pDBuffer, pBuffer, nBufLen);
d130 1
a130 1
void CBase64Coder::Encode(const PBYTE pBuffer, DWORD nBufLen)
d132 1
a132 1
	SetDecodeBuffer(pBuffer, nBufLen);
d163 1
a163 1
void CBase64Coder::Decode(const PBYTE pBuffer, DWORD dwBufLen)
d168 1
a168 1
	SetEncodeBuffer(pBuffer, dwBufLen);
d217 1
a217 1
DWORD CBase64Coder::_DecodeToBuffer(const TempBucket &Decode, PBYTE pBuffer)
d226 2
a227 2
		pBuffer[i] = Data.nData[i];
		if(pBuffer[i] != 255)
d235 1
a235 1
void CBase64Coder::_EncodeToBuffer(const TempBucket &Decode, PBYTE pBuffer)
d242 1
a242 1
		pBuffer[i] = Base64Digits[Data.nData[i]];
d247 1
a247 1
		  pBuffer[2] = '=';
d249 1
a249 1
		  pBuffer[3] = '=';
@

