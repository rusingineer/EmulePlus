head	1.3;
access;
symbols
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	Interim_Release_1n_beta2:1.2
	Interim_Release_1n_beta1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.1
	Interim_Release_1k_RC4:1.1
	Interim_1k_RC3:1.1
	Interim_1k_RC2:1.1
	Interim_Release_1k_RC1:1.1
	Interim_Release_1k_beta5:1.1
	Intrerim_Release_1k_beta4:1.1
	Interim_Release_1k_beta1:1.1
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1
	PublicRelease_1i:1.1
	Interim_Release_1i_RC6:1.1
	Interim_Release_1i_RC3:1.1
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.4
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.2
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1;
locks; strict;
comment	@// @;


1.3
date	2006.01.09.00.32.38;	author aw3;	state dead;
branches;
next	1.2;

1.2
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.08.12.09.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Removed unused source files {eklmn}.
@
text
@////////////////////////////////////////////////////////////////////
// PIDL.cpp: implementation of the CPIDL class.
//
// By Oz Solomonovich (osolo@@bigfoot.com)
// Additions/Fixes by Philip Oldaker (philip@@masmex.com)

#include "stdafx.h"
#include "PIDL.h"
#include "otherfunctions.h"

LPSHELLFOLDER CPIDL::m_sfDesktop  = NULL; // cached destkop folder
LPMALLOC      CPIDL::m_pAllocator = NULL; // cached system allocator

CPIDL::pidl_initializer CPIDL::m_initializer; // automatic init. obj


////////////////////////////////////////////////////////////////////
// Initialization object
////////////////////////////////////////////////////////////////////

// pidl_initializer is used to initialize the static data.  The 
// constructor and destructor are automatically called for us when
// the program starts/ends.

CPIDL::pidl_initializer::pidl_initializer()
{
    SHGetDesktopFolder(&m_sfDesktop); // cache d'top folder obj ptr 
    SHGetMalloc(&m_pAllocator);       // cache sys allocator obj ptr
}

CPIDL::pidl_initializer::~pidl_initializer()
{
    m_sfDesktop->Release();
    m_pAllocator->Release();
}


////////////////////////////////////////////////////////////////////
// CPIDL Implementation
////////////////////////////////////////////////////////////////////
CPIDL::CPIDL(LPCTSTR szPath, LPSHELLFOLDER psf) : m_pidl(NULL) 
{ 
    Set(szPath, psf); 
}


CPIDL::~CPIDL()
{
    Free();  // just free used memory
}


////////////////////////////////////////////////////////////////////
// Assignment Functions

HRESULT CPIDL::Set(const CPIDL& cpidl)
{
    return MakeCopyOf(cpidl.m_pidl);
}

HRESULT CPIDL::Set(LPITEMIDLIST pidl)
{
    Free();
    m_pidl = pidl;
    return ERROR_SUCCESS;
}

HRESULT CPIDL::Set(LPCTSTR szPath, LPSHELLFOLDER psf)
{
    OLECHAR olePath[MAX_PATH];
    ULONG   chEaten;
    ULONG   dwAttributes;
    
    Free();
#ifndef _UNICODE
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szPath, -1, 
        olePath, MAX_PATH);
#else
    lstrcpy(olePath,szPath);
#endif
    return psf->ParseDisplayName(NULL, NULL, olePath, &chEaten, 
        &m_pidl, &dwAttributes);
}

HRESULT CPIDL::MakeCopyOf(LPITEMIDLIST pidl)
{
    Free();
    if (pidl) {
        UINT sz = m_pAllocator->GetSize((LPVOID)pidl);
        AllocMem(sz);
        memcpy2((LPVOID)m_pidl, (LPVOID)pidl, sz);
    }
    return ERROR_SUCCESS;
}

HRESULT CPIDL::MakeAbsPIDLOf(LPSHELLFOLDER psf, LPITEMIDLIST pidl)
{
USES_CONVERSION;
    STRRET  str;
    HRESULT hr = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str);
    if (SUCCEEDED(hr)) {
        ExtractCStr(str);
        hr = Set(A2T(str.cStr));
    }
    return hr;
}


////////////////////////////////////////////////////////////////////
// CPIDL Operations

void CPIDL::Free()
{
    if (m_pidl) {
        m_pAllocator->Free(m_pidl);
        m_pidl = NULL;
    }
}

#define CB_SIZE  (sizeof(piid->cb))  // size of termination item

UINT CPIDL::GetSize() const
{
    UINT        cbTotal = 0;
    LPSHITEMID  piid    = GetFirstItemID();
    
    if (piid) {
        do {
            cbTotal += piid->cb;
            GetNextItemID(piid);
        } while (piid->cb);
        cbTotal += CB_SIZE; // count the terminator
    }
    
    return cbTotal;
}

void CPIDL::Split(CPIDL& parent, CPIDL& obj) const
{
    int         size = 0;
    SHITEMID    *piid, *piidLast;
    
    // find last item-id and calculate total size of pidl
    piid = piidLast = &m_pidl->mkid;
    while (piid->cb)
    {
        piidLast = piid;
        size += (piid->cb);
        piid =  (SHITEMID *)((LPBYTE)piid + (piid->cb));
    }
    
    // copy parent folder portion
    size -= piidLast->cb;  // don't count "object" item-id
    if (size > 0)
    {
        parent.AllocMem(size + CB_SIZE);
        memcpy2(parent.m_pidl, m_pidl, size);
        memzero((LPBYTE)parent.m_pidl + size, CB_SIZE); // terminator
    }
    // copy "object" portion
    size = piidLast->cb + CB_SIZE;
    if (size > 0)
    {
        obj.AllocMem(size);
        memcpy2(obj.m_pidl, piidLast, size);
    }
}

CPIDL CPIDL::operator + (CPIDL& pidl) const
{
    CPIDL ret;
    Concat(*this, pidl, ret);
    return ret;
}

void CPIDL::Concat(const CPIDL &a, const CPIDL& b, CPIDL& result)
{
    result.Free();
    
    // both empty->empty | a empty->return b | b empty->return a
    if (a.m_pidl == NULL  &&  b.m_pidl == NULL) return;
    if (a.m_pidl == NULL) { result.Set(b); return; }
    if (a.m_pidl == NULL) { result.Set(a); return; }
    
    UINT cb1 = a.GetSize() - sizeof(a.m_pidl->mkid.cb);
    UINT cb2 = b.GetSize(); 
    result.AllocMem(cb1 + cb2); // allocate enough memory 
    memcpy2(result.m_pidl, a.m_pidl, cb1);                 // 1st
    memcpy2(((LPBYTE)result.m_pidl) + cb1, b.m_pidl, cb2); // 2nd
}

HRESULT CPIDL::GetUIObjectOf(REFIID riid, LPVOID *ppvOut, 
    HWND hWnd /*= NULL*/, LPSHELLFOLDER psf /*= m_sfDesktop*/)
{
    CPIDL           parent, obj;
    LPSHELLFOLDER   psfParent;
    HRESULT         hr=S_OK;
    
    Split(parent, obj);
    // if no idl the use desktop folder
    if (parent.m_pidl == NULL || parent.m_pidl->mkid.cb == 0)
    {
        psfParent = psf;
    }
    else
    {
        // otherwise get the parent
         hr = psf->BindToObject(parent, NULL, IID_IShellFolder, 
            (LPVOID *)&psfParent); // get the IShellFolder of the parent
    }
    if (SUCCEEDED(hr)) 
    {
        hr = psfParent->GetUIObjectOf(hWnd, 1, obj, riid, 0, ppvOut);
        psfParent->Release();
    }
    return hr;
}

void CPIDL::ExtractCStr(STRRET& strRet) const
{
    switch (strRet.uType) 
    {
        case STRRET_WSTR:
        {
            // pOleStr points to a WCHAR string - convert it to ANSI
            LPWSTR pOleStr = strRet.pOleStr;
            WideCharToMultiByte(CP_ACP, 0, pOleStr, -1,
                strRet.cStr, MAX_PATH, NULL, NULL);
            m_pAllocator->Free(pOleStr);
            break;
        }
        
        case STRRET_OFFSET:
            // The string lives inside the pidl, so copy it out.
            strncpy(strRet.cStr, (LPSTR)
                ((LPBYTE)m_pidl + strRet.uOffset), MAX_PATH);
            break;
    }
}


////////////////////////////////////////////////////////////////////
// CPIDL Private Operations

void CPIDL::AllocMem(int iAllocSize)
{
    Free();
    m_pidl = (LPITEMIDLIST)m_pAllocator->Alloc(iAllocSize);
}
@


1.2
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@@


1.1
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d9 1
d91 1
a91 1
        CopyMemory((LPVOID)m_pidl, (LPVOID)pidl, sz);
d157 2
a158 2
        CopyMemory(parent.m_pidl, m_pidl, size);
        ZeroMemory((LPBYTE)parent.m_pidl + size, CB_SIZE); // terminator
d165 1
a165 1
        CopyMemory(obj.m_pidl, piidLast, size);
d188 2
a189 2
    CopyMemory(result.m_pidl, a.m_pidl, cb1);                 // 1st
    CopyMemory(((LPBYTE)result.m_pidl) + cb1, b.m_pidl, cb2); // 2nd
@

