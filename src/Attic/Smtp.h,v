head	1.9;
access;
symbols
	PublicRelease_1_2:1.8
	Interim_Release_1-2_RC1:1.8
	Interim_Release_1-2_beta1:1.8
	PublicRelease_1_1g:1.8
	Interim_Release_1-1g_RC3:1.8
	Interim_Release_1-1g_RC2:1.8
	Interim_Release_1-1g_RC1:1.8
	Interim_Release_1-1g_beta2:1.8
	Interim_Release_1-1g_beta1:1.8
	PublicRelease_1_1f:1.8
	Interim_Release_1-1f_RC1:1.8
	PublicRelease_1_1e:1.8
	Interim_Release_1-1e_RC2:1.8
	Interim_Release_1-1e_RC1:1.8
	Interim_Release_1-1e_beta1:1.8
	PublicRelease_1_1d:1.8
	Interim_Release_1-1d_RC1:1.8
	PublicRelease_1_1c:1.8
	Interim_Release_1-1c_RC1:1.8
	Interim_Release_1-1c_beta2:1.8
	Interim_Release_1-1c_beta1:1.8
	PublicRelease_1_1b:1.8
	Interim_Release_1-1b_RC1:1.8
	PublicRelease_1_1a:1.8
	Interim_Release_1-1a_RC2:1.8
	Interim_Release_1-1a_RC1:1.8
	Interim_Release_1-1a_beta2:1.8
	Interim_Release_1-1a_beta1:1.8
	PublicRelease_1_1:1.7
	Interim_Release_1-1_beta1:1.7
	PublicRelease_1o:1.7
	Interim_Release_1o_RC1:1.7
	Interim_Release_1o_beta1:1.7
	PublicRelease_1n:1.7
	Interim_Release_1n_RC2:1.7
	Interim_Release_1n_RC1:1.7
	Interim_Release_1n_beta2:1.7
	Interim_Release_1n_beta1:1.7
	PublicRelease_1m:1.7
	Interim_Release_1m_beta1:1.7
	PublicRelease_1l:1.7
	Interim_Release_1l_RC3:1.7
	Interim_Release_1l_RC2:1.7
	Interim_Release_1l_RC1:1.7
	Interim_Release_1l_beta2:1.7
	Interim_Release_1l_beta1:1.7
	PublicRelease_1k:1.6
	Interim_Release_1k_RC4:1.6
	Interim_1k_RC3:1.6
	Interim_1k_RC2:1.6
	Interim_Release_1k_RC1:1.6
	Interim_Release_1k_beta5:1.6
	Intrerim_Release_1k_beta4:1.6
	Interim_Release_1k_beta1:1.6
	PublicRelease_1j:1.6
	Interim_Release_1J_RC3:1.6
	Interim_Release_1j_RC3:1.6
	Interim_Release_1j_RC2:1.6
	Interim_Release_1j_RC1:1.6
	Interim_Release_1j_beta2:1.6
	Interim_Release_1j_beta1:1.6
	PublicRelease_1i:1.6
	Interim_Release_1i_RC6:1.6
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.6
	Interim_Release_1i_beta3:1.6
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.6
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.5
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.5
	Interim_Release_1h_beta1:1.5;
locks; strict;
comment	@ * @;


1.9
date	2006.04.04.23.43.29;	author kush_eplus;	state dead;
branches;
next	1.8;

1.8
date	2004.10.30.00.17.20;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.22.19.45.14;	author aw3;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.07.31.18.45.51;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.07.30.14.04.16;	author puritynn666;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.28.14.57.52;	author dongato;	state Exp;
branches;
next	1.2;

1.2
date	2003.07.27.19.56.57;	author dongato;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.27.17.43.39;	author dongato;	state Exp;
branches;
next	;


desc
@@


1.9
log
@new email notifier code (adapted from original) - fully UNICODE ready
@
text
@/*
Module : SMTP.H
Purpose: Defines the interface for a MFC class encapsulation of the SMTP protocol
Created: PJN / 22-05-1998

Copyright (c) 1998 - 2003 by PJ Naughter.  (Web: www.naughter.com, Email: pjna@@naughter.com)

All rights reserved.

Copyright / Usage Details:

You are allowed to include the source code in any product (commercial, shareware, freeware or otherwise) 
when your product is released in binary form. You are allowed to modify the source code in any way you want 
except you cannot modify the copyright details at the top of each module. If you want to distribute source 
code with your application, then you are only allowed to distribute versions released by the author. This is 
to maintain a single distribution point for the source code. 

Please note that I have been informed recently that CSMTPConnection is being used to develop and send unsolicted bulk mail. 
This was not the intention of the code and the author explicitly forbids use of the code for any software of this kind without 
my explicit written consent.
*/

/////////////////////////////// Defines ///////////////////////////////////////

#ifndef __SMTP_H__
#define __SMTP_H__

#ifndef __AFXTEMPL_H__
#pragma message("To avoid this message, put afxtempl.h in your PCH (usually stdafx.h)")
#include <afxtempl.h>
#endif

#ifndef _WINSOCKAPI_
#pragma message("To avoid this message, put afxsock.h or winsock.h in your PCH (usually stdafx.h)")
#include <winsock.h>
#endif

#ifndef __AFXPRIV_H__
#pragma message("To avoid this message, put afxpriv.h in your PCH (usually stdafx.h)")
#include <afxpriv.h>
#endif

#pragma warning(push, 3) //Avoid all the level 4 warnings in STL
#ifndef _STRING_
#pragma message("To avoid this message, put string in your PCH (usually stdafx.h)")
#include <string>
#endif
#pragma warning(pop)

#include "Base64Coder.h"
#include "Loggable.h"

/////////////////////////////// Classes ///////////////////////////////////////

//Simple Socket wrapper class
class CSMTPSocket
{
public:
	//Constructors / Destructors
	CSMTPSocket();
	virtual ~CSMTPSocket();

	//methods
	BOOL  Create();
	BOOL  Connect(LPCTSTR pszHostAddress, int nPort, LPCTSTR pszLocalBoundAddress);
	BOOL  Send(LPCSTR pszBuf, int nBuf);
	void  Close();
	int   Receive(LPSTR pszBuf, int nBuf);
	BOOL  IsReadable(BOOL& bReadible);

protected:
	BOOL   Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	SOCKET m_hSocket;
};


//Encapsulation of an SMTP email address, used for recipients and in the From: field
class CSMTPAddress
{
public: 
	//Constructors / Destructors
	CSMTPAddress();
	CSMTPAddress(const CSMTPAddress& address);
	CSMTPAddress(const CString& sAddress);
	CSMTPAddress(const CString& sFriendly, const CString& sAddress);
	CSMTPAddress& operator=(const CSMTPAddress& r);

	//Methods
	CString GetRegularFormat(BOOL bEncode, const CString& sCharset) const;

	//Data members
	CString m_sFriendlyName; //Would set it to contain something like "PJ Naughter"
	CString m_sEmailAddress; //Would set it to contains something like "pjna@@naughter.com"
};

//Encapsulatation of an SMTP MIME body part
class CSMTPBodyPart
{
public:
	//Constructors / Destructors
	CSMTPBodyPart();
	CSMTPBodyPart(const CSMTPBodyPart& bodyPart);
	CSMTPBodyPart& operator=(const CSMTPBodyPart& bodyPart);
	virtual ~CSMTPBodyPart();

	//Accessors / Mutators
	BOOL    SetFilename(const CString& sFilename);
	CString GetFilename() const { return m_sFilename; }; 

	void    SetText(const CString& sText);
	CString GetText() const { return m_sText; };

	void    SetTitle(const CString& sTitle) { m_sTitle = sTitle; };
	CString GetTitle() const { return m_sTitle; };

	void    SetContentType(const CString& sContentType) { m_sContentType = sContentType; };
	CString GetContentType() const { return m_sContentType; };

	void    SetCharset(const CString& sCharset) { m_sCharset = sCharset; };
	CString GetCharset() const { return m_sCharset; };

	void    SetContentBase(const CString& sContentBase) { m_sContentBase = sContentBase; };
	CString GetContentBase() const { return m_sContentBase; };

	void    SetContentID(const CString& sContentID);
	CString GetContentID() const;

	void    SetContentLocation(const CString& sContentLocation);
	CString GetContentLocation() const;

	CString GetBoundary() const { return m_sBoundary; };

	//Misc methods
	BOOL GetHeader(LPSTR& pszHeader, int& nHeaderSize);
	BOOL GetBody(LPSTR& pszBody, int& nBodySize);
	BOOL GetFooter(LPSTR& pszFooter, int& nFooterSize);
	void FreeHeader(LPSTR& pszHeader);
	void FreeBody(LPSTR& pszBody);
	void FreeFooter(LPSTR& pszFooter);
	CSMTPBodyPart* FindFirstBodyPart(const CString sContentType);
	void SetQuotedPrintable(BOOL bValue) { m_bQuotedPrintable = bValue; };
	BOOL GetQuotedPrintable() const { return m_bQuotedPrintable; };
	void SetBase64(BOOL bValue) { m_bBase64 = bValue; };
	BOOL GetBase64() const { return m_bBase64; };

	//Child Body part methods
	int            GetNumberOfChildBodyParts() const;
	int            AddChildBodyPart(CSMTPBodyPart& bodyPart);
	void           RemoveChildBodyPart(int nIndex);
	CSMTPBodyPart* GetChildBodyPart(int nIndex);
	CSMTPBodyPart* GetParentBodyPart();

	//Static methods
	static std::string QuotedPrintableEncode(const std::string& sText);
	static int         ConvertToUTF8(const CString& in, std::string &);
	static int         UnicodeToUTF8(LPCWSTR wszSrc, int nSrc, LPSTR szDest,int nDest);
	static char        HexDigit(int nDigit);
	static std::string HeaderEncode(const CString& sText, const CString& sCharset);
	static std::string QEncode(LPCSTR sText, LPCSTR sCharset);

	protected:
	//Member variables
	CString      m_sFilename;                                 //The file you want to attach
	CString      m_sTitle;                                    //What is it to be know as when emailed
	CString      m_sContentType;                              //The mime content type for this body part
	CString      m_sCharset;                                  //The charset for this body part
	CString      m_sContentBase;                              //The absolute URL to use for when you need to resolve any relative URL's in this body part
	CString      m_sContentID;                                //The uniqiue ID for this body part (allows other body parts to refer to us via a CID URL)
	CString      m_sContentLocation;                          //The relative URL for this body part (allows other body parts to refer to us via a relative URL)
	CString      m_sText;                                     //If using strings rather than file, then this is it!
	CBase64Coder m_Coder;	                                    //Base64 encoder / decoder instance for this body part
	CArray<CSMTPBodyPart*, CSMTPBodyPart*&> m_ChildBodyParts; //Child body parts for this body part
	CSMTPBodyPart* m_pParentBodyPart;                         //The parent body part for this body part
	CString      m_sBoundary;                                 //String which is used as the body separator for all child mime parts
	BOOL         m_bQuotedPrintable;                          //Should the body text by quoted printable encoded
	BOOL         m_bBase64;                                   //Should the body be base64 encoded. Overrides "bQuotedPrintable"

	//Methods
	void FixSingleDotA(std::string& sBody);
	void FixSingleDotT(CString& sBody);
	CString Replace(const CString& sText, const CString& sToBeReplaced, const CString& sReplaceWith);

	friend class CSMTPMessage;
	friend class CSMTPConnection;
};

////////////////// typedefs ////////////////////////////////////////////////////

typedef CArray<CSMTPAddress, CSMTPAddress&> CSMTPAddressArray;

////////////////// Forward declaration /////////////////////////////////////////

class CSMTPConnection;

//Encapsulation of an SMTP message
class CSMTPMessage
{
public:
	//Enums
	enum RECIPIENT_TYPE { TO, CC, BCC };

	//Constructors / Destructors
	CSMTPMessage();
	CSMTPMessage(const CSMTPMessage& message);
	CSMTPMessage& operator=(const CSMTPMessage& message);
	virtual ~CSMTPMessage();

	//Recipient support
	int           GetNumberOfRecipients(RECIPIENT_TYPE RecipientType = TO) const;
	int           AddRecipient(CSMTPAddress& recipient, RECIPIENT_TYPE RecipientType = TO);
	void          RemoveRecipient(int nIndex, RECIPIENT_TYPE RecipientType = TO);
	CSMTPAddress* GetRecipient(int nIndex, RECIPIENT_TYPE RecipientType = TO);
	BOOL          AddMultipleRecipients(const CString& sRecipients, RECIPIENT_TYPE RecipientType);
	static int    ParseMultipleRecipients(const CString& sRecipients, CSMTPAddressArray& recipients);

	//Body Part support
	int            GetNumberOfBodyParts() const;
	int            AddBodyPart(CSMTPBodyPart& bodyPart);
	void           RemoveBodyPart(int nIndex);
	CSMTPBodyPart* GetBodyPart(int nIndex);
	int            AddMultipleAttachments(const CString& sAttachments);

	//Misc methods
	virtual std::string  getHeader();
	void                 AddTextBody(const CString& sBody);
	CString              GetTextBody();
	void                 AddHTMLBody(const CString& sBody, const CString& sContentBase);
	CString              GetHTMLBody();
	void                 AddCustomHeader(const CString& sHeader);
	CString              GetCustomHeader(int nIndex);
	int                  GetNumberOfCustomHeaders() const;
	void                 RemoveCustomHeader(int nIndex);
	void                 SetCharset(const CString& sCharset);
	CString              GetCharset() const;
	void                 SetMime(BOOL bMime);
	BOOL                 GetMime() const { return m_bMime; };
	BOOL                 SaveToDisk(const CString& sFilename);

	//Data Members
	CSMTPAddress  m_From;
	CString       m_sSubject;
	CString       m_sXMailer;
	CSMTPAddress  m_ReplyTo;
	CSMTPBodyPart m_RootPart;

protected:
	//Methods
	BOOL        WriteToDisk(CFile& file, CSMTPBodyPart* pBodyPart, BOOL bRoot);
	CString     ConvertHTMLToPlainText(const CString& sHtml);

	//Member variables
	CArray<CSMTPAddress*, CSMTPAddress*&> m_ToRecipients;
	CArray<CSMTPAddress*, CSMTPAddress*&> m_CCRecipients;
	CArray<CSMTPAddress*, CSMTPAddress*&> m_BCCRecipients;
	CStringArray                          m_CustomHeaders;
	BOOL                                  m_bMime;

	friend class CSMTPConnection;
};



//The main class which encapsulates the SMTP connection
class CSMTPConnection : public CLoggable
{
public:

	//typedefs
	enum LoginMethod
	{
		NoLoginMethod=0,
		CramMD5Method=1,
		AuthLoginMethod=2,
		LoginPlainMethod=3
	};

	//Constructors / Destructors
	CSMTPConnection();
	virtual ~CSMTPConnection();

	//Methods
	BOOL    Connect(LPCTSTR pszHostName, LoginMethod lm=NoLoginMethod, LPCTSTR pszUsername=NULL, LPCTSTR pszPassword=NULL, int nPort=25, LPCTSTR pszLocalBoundAddress=NULL);
	BOOL    Disconnect(BOOL bGracefully = TRUE);
	CString GetLastCommandResponse() const { return m_sLastCommandResponse; };
	int     GetLastCommandResponseCode() const { return m_nLastCommandResponseCode; };
	DWORD   GetTimeout() const { return m_dwTimeout; };
	void    SetTimeout(DWORD dwTimeout) { m_dwTimeout = dwTimeout; };
	BOOL    SendMessage(CSMTPMessage& Message);
	BOOL    SendMessage(const CString& sMessageOnFile, CSMTPAddressArray& Recipients, const CSMTPAddress& From, DWORD dwSendBufferSize = 4096);
	BOOL    SendMessage(BYTE* pMessage, DWORD dwMessageSize, CSMTPAddressArray& Recipients, const CSMTPAddress& From, DWORD dwSendBufferSize = 4096);
	static DWORD WINAPI SendMuleMessage(LPVOID lpParameter);
	void	SendMail(const CString &strText, bool bMsgEnabled, bool bSendEnabled);
	void    SetHeloHostname(const CString& sHostname) { m_sHeloHostname = sHostname; };
	CString GetHeloHostName() const { return m_sHeloHostname; };

	//Static methods
	static BOOL ConnectToInternet();
	static BOOL CloseInternetConnection();

	//Virtual Methods
	virtual BOOL OnSendProgress(DWORD dwCurrentBytes, DWORD dwTotalBytes);

protected:
	//methods
#ifndef CSMTP_NORSA
	void MD5Digest(unsigned char*text, int text_len, unsigned char*key, int key_len, unsigned char* digest);
#endif
	BOOL ConnectESMTP(LPCTSTR pszLocalName, LPCTSTR pszUsername, LPCTSTR pszPassword, LoginMethod lm);
	BOOL ConnectSMTP(LPCTSTR pszLocalName);
#ifndef CSMTP_NORSA
	BOOL CramLogin(LPCTSTR pszUsername, LPCTSTR pszPassword);
#endif
	BOOL  AuthLogin(LPCTSTR pszUsername, LPCTSTR pszPassword);
	BOOL  AuthLoginPlain(LPCTSTR pszUsername, LPCTSTR pszPassword);
	BOOL  SendRCPTForRecipient(CSMTPAddress& recipient);
	BOOL  SendBodyPart(CSMTPBodyPart* pBodyPart, BOOL bRoot);
	virtual BOOL ReadCommandResponse(int nExpectedCode, BOOL bEHLO = FALSE);
	virtual BOOL ReadResponse(LPSTR pszBuffer, int nInitialBufSize, LPSTR pszTerminator,
	                        int nExpectedCode, LPSTR* ppszOverFlowBuffer, int nGrowBy=4096, BOOL bEHLO = FALSE);
	void SafeCloseFile(CFile& File, const CString& sError);
	virtual void OnError(const CString& sError);

	//Member variables
	CSMTPSocket m_SMTP;
	BOOL        m_bConnected;
	CString     m_sLastCommandResponse;
	CString     m_sHeloHostname;
	DWORD       m_dwTimeout;
	int         m_nLastCommandResponseCode;
};

#endif //__SMTP_H__
@


1.8
log
@Safer service prototype.
@
text
@@


1.7
log
@Improved string processing.
@
text
@d292 1
a292 1
	void	SendMail(CString &strText, bool bMsgEnabled, bool bSendEnabled);
@


1.6
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d76 1
a76 1
                     
d238 1
a238 1
	                            
d291 2
a292 2
	static DWORD WINAPI SendMuleMessage(LPVOID lpParameter); //DonGato
	void	SendMail(CString strText, bool bMsgEnabled, bool bSendEnabled);
d318 1
a318 1
	virtual BOOL ReadResponse(LPSTR pszBuffer, int nInitialBufSize, LPSTR pszTerminator, 
@


1.5
log
@Added threads to eMail Notifier
@
text
@d176 1
a176 1
	BOOL         m_bBase64;                                   //Should the body be base64 encoded. Overrides "m_bQuotedPrintable"
@


1.4
log
@added SendMail function ... can we add them to Cemuleapp ???
@
text
@d291 1
a291 1
	BOOL	SendMuleMessage(CString& txt); //DonGato
@


1.3
log
@Added simple encription of SMTP password.
@
text
@d292 1
@


1.2
log
@SMTP Messenger: added authentication
@
text
@d264 1
a264 1
class CSMTPConnection
@


1.1
log
@SMTP Messenger (ops!, forgot these files)
@
text
@d6 2
a7 1
Copyright (c) 1998 - 2000 by PJ Naughter.  
d9 12
d24 1
d29 2
a30 1
#pragma message("SMTP classes require afxtempl.h in your PCH")                                                                                
d34 2
a35 1
#pragma message("SMTP classes require afxsock.h or winsock.h in your PCH")
d39 2
a40 1
#pragma message("SMTP classes requires afxpriv.h in your PCH")
d43 8
a50 1
#pragma once
d61 1
a61 1
	~CSMTPSocket();
d65 1
a65 1
	BOOL  Connect(LPCTSTR pszHostAddress, int nPort = 110);
d69 1
a69 1
	BOOL  IsReadible(BOOL& bReadible);
d75 1
d89 1
a89 1
	CString GetRegularFormat() const;
d92 2
a93 2
	CString        m_sFriendlyName; //Would set it to contain something like "PJ Naughter"
	CString        m_sEmailAddress; //Would set it to contains something like "pjn@@indigo.ie"
d96 2
a97 2
//Encapsulation of an SMTP file attachment
class CSMTPAttachment
d101 8
a108 2
	CSMTPAttachment();
	~CSMTPAttachment();
d110 4
a113 5
	//methods
	BOOL Attach(const CString& sFilename);
	CString GetFilename() const { return m_sFilename; };
	const char* GetEncodedBuffer() const { return m_pszEncoded; };
	int GetEncodedSize() const { return m_nEncodedSize; };
a114 1
	void SetTitle(const CString& sTitle) { m_sTitle = sTitle; };
d116 69
a184 9
protected:
	int Base64BufferSize(int nInputSize);
	BOOL EncodeBase64(const char* aIn, int aInLen, char* aOut, int aOutSize, int* aOutLen);
	static char m_base64tab[];

	CString  m_sFilename;    //The filename you want to send
	CString  m_sTitle;       //What it is to be known as when emailed
	char*    m_pszEncoded;   //The encoded representation of the file
	int      m_nEncodedSize; //size of the encoded string
d187 6
a192 1
////////////////// Forward declaration
d204 3
a206 1
	~CSMTPMessage();
d209 13
a221 10
	int              GetNumberOfRecipients(RECIPIENT_TYPE RecipientType = TO) const;
	int              AddRecipient(CSMTPAddress& recipient, RECIPIENT_TYPE RecipientType = TO);
	void             RemoveRecipient(int nIndex, RECIPIENT_TYPE RecipientType = TO);
	CSMTPAddress     GetRecipient(int nIndex, RECIPIENT_TYPE RecipientType = TO) const;

	//Attachment support
	int              GetNumberOfAttachments() const;
	int              AddAttachment(CSMTPAttachment* pAttachment);
	void             RemoveAttachment(int nIndex);
	CSMTPAttachment* GetAttachment(int nIndex) const;
d224 15
a238 4
	virtual CString  GetHeader() const;
	void             AddBody(const CString& sBody);
	BOOL             AddMultipleRecipients(const CString& sRecipients, RECIPIENT_TYPE RecipientType);
	                          
d240 5
a244 4
	CSMTPAddress m_From;
	CString      m_sSubject;
	CString      m_sXMailer;
	CSMTPAddress m_ReplyTo;
d247 3
a249 1
	void FixSingleDot(CString& sBody);
d251 6
a256 5
	CString m_sBody;
	CArray<CSMTPAddress, CSMTPAddress&> m_ToRecipients;
	CArray<CSMTPAddress, CSMTPAddress&> m_CCRecipients;
	CArray<CSMTPAddress, CSMTPAddress&> m_BCCRecipients;
	CArray<CSMTPAttachment*, CSMTPAttachment*&> m_Attachments;
d261 2
d267 10
d279 1
a279 1
	~CSMTPConnection();
d282 2
a283 2
	BOOL    Connect(LPCTSTR pszHostName, int nPort=25);
	BOOL    Disconnect();
d289 12
a300 1
	BOOL	SendMuleMessage(CString& txt);
d303 14
a316 2
	BOOL SendRCPTForRecipient(CSMTPAddress& recipient);
	virtual BOOL ReadCommandResponse(int nExpectedCode);
d318 5
a322 1
	int nExpectedCode, LPSTR* ppszOverFlowBuffer, int nGrowBy=4096);
d326 1
@

