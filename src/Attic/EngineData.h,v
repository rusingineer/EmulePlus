head	1.14;
access;
symbols
	PublicRelease_1i:1.13
	Interim_Release_1i_RC6:1.13
	Interim_Release_1i_RC3:1.13
	Interim_Release_1i_RC2:1.11
	Interim_Release_1i_RC1:1.9
	Interim_Release_1i_beta3:1.9
	Interim_Release_1i_beta2:1.7
	Interim_Release_1i_beta1:1.5
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.2;
locks; strict;
comment	@ * @;


1.14
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.13;

1.13
date	2003.11.19.16.51.47;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.19.11.14.20;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.12.13.29.16;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.12.12.17.16;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.30.16.57.38;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.26.16.45.11;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.23.18.50.26;	author uid77509;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.22.17.30.37;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.16.16.34.38;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.11.15.59.28;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.08.17.55.36;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.04.11.19.25;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.03.17.56.27;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.14
log
@New engine
@
text
@// EngineData.h
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "Loggable.h"

#ifdef NEW_SOCKETS

enum EnumServerStates
{
	SERVER_DISCONNECTED,
	SERVER_CONNECTING,
	SERVER_WAITFORLOGIN,
	SERVER_CONNECTED
};

class CServer;
class CServerList;
class CPreferences;
struct CTask_ServerState;
struct CEmClient_Server;

struct ServerState
{
	SOCKET		hSocket;
	ULONG		nAddr;
	USHORT		nPort;
	CServer*	pServer;
	short		nConnState;
};

// One instance of that class inside worker engine,
// second instance in GUI, synchronization between both objects
class CEngineData : public CLoggable
{
public:
	CEngineData(CEmEngine& stEngine);
	~CEngineData();

	// Server Info
	bool IsConnecting();
	bool IsConnected();
	bool IsLowID();

	void ImportServerState(CTask_ServerState* pTask);

	// Update Server Info
	void SetConnectionState(bool bForConnected, short nConnectionState);
	void SetClientID(long cID);
	void ConnectingTo(CEmClient_Server* pClient);
	void ConnectedTo(CEmClient_Server* pClient);

	SOCKET GetConnectedServer(){ return m_stConnected.hSocket; }
	SOCKET GetConnectingServer(){ return m_stConnecting.hSocket; }

	ServerState* GetConnectedState(){ return &m_stConnected; }

	long GetClientID(){ return m_nClientID; }

	bool IsLocalServer(ULONG nAddr, USHORT uPort);

	// Global preferences
	BYTE* GetUserHash();
	LONG GetPort();
	CString GetUserNick();

private:
	void ExportServerState(bool bForConnected);

private:
	CEmEngine&		m_stEngine;

	ServerState		m_stConnected;
	ServerState		m_stConnecting;

	long			m_nClientID;

	CServerList*	m_pServerList;

	// +collection of CEmClientData objects
};

class CPartFile;

// Contain all information about connecting/connected client
class CEmClientData
{
public:
	CPartFile*	GetFile() const { return m_pPartFile; }

private:
	CPartFile	*m_pPartFile;
};

#endif //NEW_SOCKETS@


1.13
log
@New sockets
@
text
@@


1.12
log
@New sockets - can offer files to server
@
text
@d58 2
@


1.11
log
@New sockets
@
text
@d28 2
@


1.10
log
@New sockets
@
text
@d81 2
d86 5
@


1.9
log
@New sockets - more server code
@
text
@d32 2
d77 7
@


1.8
log
@New sockets - minor progress :(
@
text
@d56 2
@


1.7
log
@New sockets - more server code
@
text
@d11 1
a11 1
typedef enum
a13 1
	SERVER_FULL,
d17 1
a17 1
} enServerStates;
d25 1
a25 1
typedef struct
d30 1
a30 1
} ServerState;
@


1.6
log
@New sockets - more server code
@
text
@d55 2
@


1.5
log
@New sockets
@
text
@a7 1
#include "Sockets/Tasks.h"
d18 1
a18 1
} ServerStates;
d23 9
d47 1
a47 1
	void SetConnectionState(short nConnectionState);
d52 2
a53 2
	SOCKET GetConnectedServer(){ return m_hServer; }
	SOCKET GetConnectingServer(){ return m_hNewServer; }
d61 1
a61 1
	void ExportServerState();
d64 4
a67 2
	short	m_nConnectionState;
	long	m_nClientID;
d69 1
a69 1
	CEmEngine&	m_stEngine;
a70 2
	CServer*		m_pCurrentServer;
	CServer*		m_pNewServer;
a71 2
	SOCKET			m_hServer;
	SOCKET			m_hNewServer;
@


1.4
log
@New sockets
@
text
@d41 5
a45 1
	void ConnectedTo(CEmClient_Server* pClient, ULONG nAddr, USHORT nPort);
d61 5
a65 3
	CServer*			m_pCurrentServer;
	CEmClient_Server*	m_pServerClient;
	CServerList*		m_pServerList;
@


1.3
log
@New sockets - more server logic
@
text
@d23 1
d43 5
d54 1
d56 4
a59 3
	CServer*	m_pCurrentServer;
	CEmClient_Server* m_pServerClient;
	CServerList* m_pServerList;
@


1.2
log
@New sockets
@
text
@d21 3
d40 1
d48 4
a51 1
	CEmEngine& m_stEngine;
@


1.1
log
@New sockets
@
text
@d15 1
d17 1
d28 3
a30 3
	bool IsConnecting() { return (m_nServerState == SERVER_CONNECTING); }
	bool IsConnected()	{ return (m_nServerState == SERVER_CONNECTED); }
	bool IsLowID()		{ return (m_nClientID < 16777216); }
d32 1
a32 1
	void SetServerState(CTask_ServerState* pTask);
d35 1
a35 3
	void OnConnecting();
	void OnConnected();
	void OnDisconnected();
d42 1
a42 1
	long	m_nServerState;
@

