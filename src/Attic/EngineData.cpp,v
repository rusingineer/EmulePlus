head	1.18;
access;
symbols
	PublicRelease_1i:1.16
	Interim_Release_1i_RC6:1.16
	Interim_Release_1i_RC3:1.16
	Interim_Release_1i_RC2:1.14
	Interim_Release_1i_RC1:1.13
	Interim_Release_1i_beta3:1.13
	Interim_Release_1i_beta2:1.10
	Interim_Release_1i_beta1:1.6
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.2;
locks; strict;
comment	@// @;


1.18
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.17;

1.17
date	2003.12.11.14.32.47;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.19.11.14.20;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.19.09.23.29;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.15.12.31.43;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.30.16.57.38;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.26.16.45.10;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.23.18.50.26;	author uid77509;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.22.17.30.37;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.22.14.43.56;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.20.13.19.59;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.16.16.34.38;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.11.15.59.28;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.08.17.55.36;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.04.11.19.25;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.03.17.56.27;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.18
log
@New engine
@
text
@// EngineData.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Sockets/EmEngine.h"
#include "EngineData.h"
#include "Sockets/Tasks.h"

#ifdef NEW_SOCKETS

//////////////////////////////////////////////////////////////////////
CEngineData::CEngineData(CEmEngine& stEngine)
: m_stEngine(stEngine)
{
	m_stConnected.nConnState = SERVER_DISCONNECTED;
	m_stConnected.hSocket = NULL;
	m_stConnected.nAddr = 0;
	m_stConnected.nPort = 0;
	m_stConnected.pServer = NULL;

	m_stConnecting.nConnState = SERVER_DISCONNECTED;
	m_stConnecting.hSocket = NULL;
	m_stConnecting.nAddr = 0;
	m_stConnecting.nPort = 0;
	m_stConnecting.pServer = NULL;

	m_nClientID = 0;

	m_pServerList = NULL;
}

//////////////////////////////////////////////////////////////////////
CEngineData::~CEngineData()
{
}

//////////////////////////////////////////////////////////////////////
bool CEngineData::IsConnecting()
{
	return (m_stConnecting.nConnState == SERVER_CONNECTING || 
			m_stConnecting.nConnState == SERVER_WAITFORLOGIN); 
}

//////////////////////////////////////////////////////////////////////
bool CEngineData::IsConnected()
{ 
	return (m_stConnected.nConnState == SERVER_CONNECTED);
}

//////////////////////////////////////////////////////////////////////
bool CEngineData::IsLowID()
{ 
	return (m_nClientID < 0x1000000); 
}

//////////////////////////////////////////////////////////////////////
// Executed in GUI thread
void CEngineData::ImportServerState(CTask_ServerState* pTask)
{
/*	if(!pTask)
	{
		ASSERT(FALSE);
		return;
	}

	// should keep independent serverlist in the future
	if(!m_pServerList)
		m_pServerList = g_eMuleApp.m_pServerList;

	if(m_nClientID != pTask->m_nClientID)
	{
		m_nClientID = pTask->m_nClientID;
		AddLogLine(false, IDS_NEWCLIENTID, m_nClientID);
	}

	ServerState* pState = pTask->m_bForConnected ? &m_stConnected : &m_stConnecting;
	pState->hSocket = pTask->m_stState.hSocket;
	pState->nAddr = pTask->m_stState.nAddr;
	pState->nPort = pTask->m_stState.nPort;
	if(pState->pServer == NULL && m_pServerList && pState->nAddr != 0)
		pState->pServer = m_pServerList->GetServerByIP(pState->nAddr, pState->nPort);

	if(pState->nConnState != pTask->m_stState.nConnState)
	{
		pState->nConnState = pTask->m_stState.nConnState;
		switch(pState->nConnState)
		{
		case SERVER_DISCONNECTED:
			if(m_stConnected.nConnState == SERVER_DISCONNECTED)
				g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
			break;
		case SERVER_CONNECTING:
			g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
			break;
		case SERVER_WAITFORLOGIN:
			if(m_stConnecting.pServer)
				AddLogLine(false, IDS_CONNECTEDTOREQ,
					m_stConnecting.pServer->GetListName(),
					m_stConnecting.pServer->GetFullIP(),
					m_stConnecting.pServer->GetPort());
			break;
		case SERVER_CONNECTED:
			if(m_stConnected.pServer)
			{
				AddLogLine(true, IDS_CONNECTEDTO, m_stConnected.pServer->GetListName());
				g_eMuleApp.m_pdlgEmule->ShowConnectionState(true, m_stConnected.pServer->GetListName());
//				if(IsLowID())
//					AddLogLine(false, GetResString(IDS_GOTLOWID));

				// Write online signature
				g_eMuleApp.OnlineSig();

				// Resume downloading files
				g_eMuleApp.m_pDownloadQueue->ResumeFiles();

				m_stEngine.SendSharedListToServer();
			}
			break;
		}
	}*/
}

//////////////////////////////////////////////////////////////////////
void CEngineData::SetConnectionState(bool bForConnected, short nConnectionState)
{
	ServerState* pState = bForConnected ? &m_stConnected : &m_stConnecting;
	pState->nConnState = nConnectionState;	

	switch(nConnectionState)
	{
	case SERVER_DISCONNECTED:
		pState->hSocket = NULL;
		pState->nAddr = 0;
		pState->nPort = 0;
		pState->pServer = NULL;
		break;
	case SERVER_CONNECTING:
		break;
	case SERVER_WAITFORLOGIN:
		break;
	case SERVER_CONNECTED:
		m_stConnected.hSocket = m_stConnecting.hSocket;
		m_stConnected.nAddr = m_stConnecting.nAddr;
		m_stConnected.nPort = m_stConnecting.nPort;
		m_stConnected.pServer = m_stConnecting.pServer;
		m_stConnecting.hSocket = NULL;
		m_stConnecting.pServer = NULL;
		m_stConnected.nConnState = SERVER_CONNECTED;
		m_stConnecting.nConnState = SERVER_DISCONNECTED;
		bForConnected = true;
		break;
	}

	ExportServerState(bForConnected);
}

//////////////////////////////////////////////////////////////////////
void CEngineData::SetClientID(long cID)
{
	m_nClientID = cID; 

	ExportServerState(true);
}

//////////////////////////////////////////////////////////////////////
void CEngineData::ConnectingTo(CEmClient_Server* pClient)
{
	m_stConnecting.hSocket = pClient->m_hSocket;
//	m_stConnecting.pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_uPort);
	m_stConnecting.nAddr = pClient->m_nAddr;
	m_stConnecting.nPort = pClient->m_uPort;
	ExportServerState(false);
}

//////////////////////////////////////////////////////////////////////
void CEngineData::ConnectedTo(CEmClient_Server* pClient)
{
	m_stConnected.hSocket = pClient->m_hSocket;
//	m_stConnected.pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_uPort);
	m_stConnected.nAddr = pClient->m_nAddr;
	m_stConnected.nPort = pClient->m_uPort;
	ExportServerState(true);
}

//////////////////////////////////////////////////////////////////////
bool CEngineData::IsLocalServer(ULONG nAddr, USHORT uPort)
{
	if(!IsConnected())
		return false;
/*	if(m_stConnected.pServer)
	{
		if (m_stConnected.pServer->GetIP() == nAddr &&
			m_stConnected.pServer->GetPort() == uPort)
			return true;
	}*/
	return false;
}

//////////////////////////////////////////////////////////////////////
void CEngineData::ExportServerState(bool bForConnected)
{
	CTask_ServerState* pTask = new CTask_ServerState(
		bForConnected,
		bForConnected ? m_stConnected : m_stConnecting,
		m_nClientID
		);
	m_stEngine.m_stMain.Push(pTask);
}

//////////////////////////////////////////////////////////////////////
// in the future, those functions should get data from local storage,
// not from global preferences
BYTE* CEngineData::GetUserHash()
{
//	return g_eMuleApp.m_pGlobPrefs->GetUserHash();
	return NULL;
}

LONG CEngineData::GetPort()
{
//	return g_eMuleApp.m_pGlobPrefs->GetPort();
	return 0;
}

CString CEngineData::GetUserNick()
{
//	return g_eMuleApp.m_pGlobPrefs->GetUserNick();
	return _T("");
}
//////////////////////////////////////////////////////////////////////

#endif //NEW_SOCKETS@


1.17
log
@New engine
@
text
@@


1.16
log
@New sockets - can offer files to server
@
text
@a7 3
#include "resource.h"
#include "ServerList.h"
#include "emule.h"
d61 1
a61 1
	if(!pTask)
d121 1
a121 1
	}
d191 1
a191 1
	if(m_stConnected.pServer)
d196 1
a196 1
	}
d216 2
a217 1
	return g_eMuleApp.m_pGlobPrefs->GetUserHash();
d222 2
a223 1
	return g_eMuleApp.m_pGlobPrefs->GetPort();
d228 2
a229 1
	return g_eMuleApp.m_pGlobPrefs->GetUserNick();
@


1.15
log
@New sockets
@
text
@d21 2
d27 2
d33 1
a33 2
	// should keep independent serverlist in the future
	m_pServerList = g_eMuleApp.m_pServerList;
d70 4
d82 4
a85 1
	pState->pServer = pTask->m_stState.pServer;
d137 2
d147 2
d173 3
a175 1
	m_stConnecting.pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_uPort);
d183 3
a185 1
	m_stConnected.pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_uPort);
@


1.14
log
@New sockets
@
text
@d109 2
@


1.13
log
@New sockets - more server code
@
text
@d15 1
d29 1
d33 1
d38 1
d45 1
d51 1
d57 1
d115 1
d145 1
d153 1
d161 1
d169 1
d183 1
d194 3
d211 1
@


1.12
log
@Formatting, comments, and name changes.
@
text
@d99 3
d156 13
@


1.11
log
@New sockets - minor progress :(
@
text
@d144 1
a144 1
	m_stConnecting.pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_nPort);
d151 1
a151 1
	m_stConnected.pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_nPort);
@


1.10
log
@New sockets - more server code
@
text
@a78 2
		case SERVER_FULL:
			break;
a114 2
		break;
	case SERVER_FULL:
@


1.9
log
@New sockets - more server code
@
text
@d51 1
a51 1
// Runs in GUI thread
d60 6
d96 5
a103 5
	}
	if(m_nClientID != pTask->m_nClientID)
	{
		m_nClientID = pTask->m_nClientID;
		AddLogLine(false, IDS_NEWCLIENTID, m_nClientID);
@


1.8
log
@New Sockets + Russian update
@
text
@d11 1
d18 8
a25 1
	m_nConnectionState = SERVER_DISCONNECTED;
d27 1
a27 4
	m_pCurrentServer = NULL;
	m_pNewServer = NULL;
	m_hServer = NULL;
	m_hNewServer = NULL;
d37 2
a38 2
	return (m_nConnectionState == SERVER_CONNECTING || 
			m_nConnectionState == SERVER_WAITFORLOGIN); 
d43 1
a43 1
	return (m_nConnectionState == SERVER_CONNECTED);
d60 5
a64 3
	m_pCurrentServer = pTask->m_pCurrentServer;
	m_pNewServer = pTask->m_pNewServer;
	if(m_nConnectionState != pTask->m_nConnectionState)
d66 2
a67 2
		m_nConnectionState = pTask->m_nConnectionState;
		switch(m_nConnectionState)
d70 2
d76 1
d79 1
a79 1
			if(m_pNewServer)
d81 3
a83 3
					m_pNewServer->GetListName(),
					m_pNewServer->GetFullIP(),
					m_pNewServer->GetPort());
d86 1
a86 1
			if(m_pCurrentServer)
d88 2
a89 2
				AddLogLine(true, IDS_CONNECTEDTO, m_pCurrentServer->GetListName());
				g_eMuleApp.m_pdlgEmule->ShowConnectionState(true, m_pCurrentServer->GetListName());
d101 1
a101 1
void CEngineData::SetConnectionState(short nConnectionState)
d103 2
a104 1
	m_nConnectionState = nConnectionState;	
d106 1
a106 1
	switch(m_nConnectionState)
d109 2
a110 2
		m_pCurrentServer = NULL;
		m_hServer = NULL;
d119 7
a125 2
		m_pCurrentServer = m_pNewServer;
		m_hNewServer = NULL;
d129 1
a129 1
	ExportServerState();
d136 1
a136 1
	ExportServerState();
d141 3
a143 7
	m_hNewServer = pClient->m_hSocket;
	CServer* pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_nPort);
	if(pServer)
	{
		m_pNewServer = pServer;
		ExportServerState();
	}
d148 3
a150 7
	m_hServer = pClient->m_hSocket;
	CServer* pServer = m_pServerList->GetServerByIP(pClient->m_nAddr, pClient->m_nPort);
	if(pServer)
	{
		m_pCurrentServer = pServer;
		ExportServerState();
	}
d153 7
a159 3
void CEngineData::ExportServerState()
{
	CTask_ServerState* pTask = new CTask_ServerState(m_nConnectionState, m_nClientID, m_pCurrentServer, m_pNewServer);
@


1.7
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d49 1
a49 1
	if(pTask)
d51 10
a60 3
		m_pCurrentServer = pTask->m_pCurrentServer;
		m_pNewServer = pTask->m_pNewServer;
		if(m_nConnectionState != pTask->m_nConnectionState)
d62 15
a76 2
			m_nConnectionState = pTask->m_nConnectionState;
			switch(m_nConnectionState)
d78 2
a79 20
			case SERVER_DISCONNECTED:
				break;
			case SERVER_FULL:
				break;
			case SERVER_CONNECTING:
				break;
			case SERVER_WAITFORLOGIN:
				if(m_pNewServer)
					AddLogLine(false, IDS_CONNECTEDTOREQ,
						m_pNewServer->GetListName(),
						m_pNewServer->GetFullIP(),
						m_pNewServer->GetPort());
				break;
			case SERVER_CONNECTED:
				if(m_pCurrentServer)
				{
					AddLogLine(true, IDS_CONNECTEDTO, m_pCurrentServer->GetListName());
					g_eMuleApp.m_pdlgEmule->ShowConnectionState(true, m_pCurrentServer->GetListName());
				}
				break;
d81 1
d83 5
a87 5
		if(m_nClientID != pTask->m_nClientID)
		{
			m_nClientID = pTask->m_nClientID;
			AddLogLine(false, IDS_NEWCLIENTID, m_nClientID);
		}
d148 1
a148 7
	if(pTask)
		m_stEngine.m_stMain.Push(pTask);
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
	}
@


1.6
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d43 1
a43 1
	return (m_nClientID < 16777216); 
@


1.5
log
@New sockets
@
text
@d23 1
a23 1
	m_pServerList = theApp.serverlist;
d75 1
a75 1
					theApp.emuledlg->ShowConnectionState(true, m_pCurrentServer->GetListName());
d156 1
a156 1
	return theApp.glob_prefs->GetUserHash();
d161 1
a161 1
	return theApp.glob_prefs->GetPort();
d166 1
a166 1
	return theApp.glob_prefs->GetUserNick();
@


1.4
log
@New sockets
@
text
@d20 3
a22 1
	m_pServerClient = NULL;
d52 1
a52 1
		m_pServerClient = pTask->m_pServerClient;
d65 1
a65 1
				if(m_pCurrentServer)
d67 3
a69 3
						m_pCurrentServer->GetListName(),
						m_pCurrentServer->GetFullIP(),
						m_pCurrentServer->GetPort());
d96 1
d105 2
d120 1
a120 1
void CEngineData::ConnectedTo(CEmClient_Server* pClient, ULONG nAddr, USHORT nPort)
d122 2
a123 2
	m_pServerClient = pClient;
	CServer* pServer = m_pServerList->GetServerByIP(nAddr, nPort);
d125 12
d138 2
a139 2

	ExportServerState();
d144 1
a144 1
	CTask_ServerState* pTask = new CTask_ServerState(m_nConnectionState, m_nClientID, m_pCurrentServer, m_pServerClient);
@


1.3
log
@New sockets - more server logic
@
text
@d44 1
d90 15
d135 15
@


1.2
log
@New sockets
@
text
@d9 2
d19 3
d48 2
d53 23
d99 10
d111 1
a111 1
	CTask_ServerState* pTask = new CTask_ServerState(m_nConnectionState, m_nClientID);
@


1.1
log
@New sockets
@
text
@d8 1
d15 1
a15 1
	m_nServerState = SERVER_DISCONNECTED;
d23 1
a23 1
void CEngineData::SetServerState(CTask_ServerState* pTask)
d25 2
a26 5
	if(pTask)
	{
		m_nServerState = pTask->m_nServerState;
		m_nClientID = pTask->m_nClientID;
	}
d29 4
a32 3
void CEngineData::OnConnecting()
{
	m_nServerState = SERVER_CONNECTING; 
d34 3
a36 1
	ExportServerState();
d39 1
a39 1
void CEngineData::OnConnected()
d41 12
a52 3
	m_nServerState = SERVER_CONNECTED;	

	ExportServerState();
d55 1
a55 1
void CEngineData::OnDisconnected()
d57 1
a57 1
	m_nServerState = SERVER_DISCONNECTED; 
d71 1
a71 1
	CTask_ServerState* pTask = new CTask_ServerState(m_nServerState, m_nClientID);
@

