head	1.3;
access;
symbols
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.3
date	2003.08.23.00.20.51;	author forcha;	state dead;
branches;
next	1.2;

1.2
date	2003.06.09.21.59.35;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.38;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.3
log
@*** empty log message ***
@
text
@// XBMDraw.cpp: implementation of the XBMDraw class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "XBMDraw.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

XBMDraw::XBMDraw()
{
	m_nWidth = m_nHeight = 0;
	m_pImage = NULL;
}

XBMDraw::~XBMDraw()
{
	try
	{
		if(m_pImage)
			delete[] m_pImage;
	}
	catch(...)
	{
	}
}

bool XBMDraw::CreateImage(CString sName, int nWidth, int nHeight, BYTE bBackground)
{
	try
	{
		m_sName = sName;
		m_nWidth = nWidth;
		m_nHeight = nHeight;

		if(m_pImage)
			delete[] m_pImage;

		m_pImage = new BYTE[m_nWidth * m_nHeight];
		memset(m_pImage, bBackground, m_nWidth * m_nHeight);

		return true;
	}
	catch(...)
	{
	}
	return false;
}

bool XBMDraw::GetImage(CString &sImage)
{
	try
	{
		if(m_pImage)
		{
			int nRealWidth = m_nWidth / 8;
			if(m_nWidth % 8 != 0)
				nRealWidth++;
			long nSize = nRealWidth * m_nHeight * 6 + 1;
			BYTE *sBits = new BYTE[nSize];
			memset(sBits, 0, nSize);
			int nCount = 0;
			for(int i = 0; i < nRealWidth * m_nHeight; i++)
			{
				TCHAR sBit[20];
				_stprintf(sBit, _T("0x%x"), m_pImage[i]);
				if(i < (nRealWidth * m_nHeight - 1))
					_tcscat(sBit, _T(", "));

				for(unsigned int j = 0; j < _tcslen(sBit) + 1; j++)
					sBits[nCount + j] = sBit[j];

				nCount += _tcslen(sBit);
			}

			sImage.Format(_T("\n<script language=\"javascript\">\n%s = \'#define _width %d\\n#define _height %d\\nstatic unsigned char _bits[] = { %s }\'\n</script>\n"),
				m_sName.GetBuffer(0), m_nWidth, m_nHeight, sBits);

			delete[] sBits;

			return true;
		}
	}
	catch(...)
	{
	}
	return false;
}

bool XBMDraw::Plot(int x, int y, bool bXOR)
{
	try
	{
		if(m_pImage)
		{
			if(x >= 0 && x < m_nWidth && y >= 0 && y < m_nHeight)
			{
				int nRealWidth = m_nWidth / 8;
				if(m_nWidth % 8 != 0)
					nRealWidth++;
				int nPos = nRealWidth * (m_nHeight - y - 1) + (x / 8);
				BYTE nVal = 1 << (x % 8);
				if(m_pImage[nPos] & nVal && bXOR)
					m_pImage[nPos] &= (0xff & ~nVal);
				else
					m_pImage[nPos] |= nVal;
				
				return true;
			}
		}
	}
	catch(...)
	{
	}
	return false;
}

CString XBMDraw::GetImageTag()
{
	try
	{
		CString sRet;
		sRet.Format(_T("<img src=\"javascript:%s\" width=\"%d\" height=\"%d\">"), m_sName.GetBuffer(0), m_nWidth, m_nHeight);
		return sRet;
	}
	catch(...)
	{
	}
	return _T("");
}

bool XBMDraw::Line(int x1, int y1, int x2, int y2, bool bXOR)
{
	try
	{
		if(m_pImage)
		{
			int dX = abs(x2 - x1);
			int dY = abs(y2 - y1);
			int Xincr, Yincr;
			if (x1 > x2) { Xincr=-1; } else { Xincr=1; }
			if (y1 > y2) { Yincr=-1; } else { Yincr=1; }
			
			if (dX >= dY)
			{           
				int dPr 	= dY << 1;
				int dPru 	= dPr - (dX << 1);
				int P 		= dPr - dX;

				for (; dX >= 0; dX--)
				{
					Plot(x1, y1, bXOR);
					if (P > 0)
					{ 
						x1 += Xincr;
						y1 += Yincr;
						P += dPru;
					}
					else
					{
						x1 += Xincr;
						P += dPr;
					}
				}		
			}
			else
			{
				int dPr 	= dX << 1;
				int dPru 	= dPr - (dY << 1);
				int P 		= dPr - dY;

				for (; dY >= 0; dY--)
				{
					Plot(x1, y1, bXOR);
					if (P > 0)
					{ 
						x1 += Xincr;
						y1 += Yincr;
						P += dPru;
					}
					else
					{
						y1 += Yincr;
						P += dPr;
					}
				}		
			}		
				
			return true;
		}
	}
	catch(...)
	{
	}
	return false;
}
@


1.2
log
@unicode cleanup
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d74 1
a74 1
				sprintf(sBit, "0x%x", m_pImage[i]);
d76 1
a76 1
					strcat(sBit, ", ");
d78 1
a78 1
				for(unsigned int j = 0; j < strlen(sBit) + 1; j++)
d81 1
a81 1
				nCount += strlen(sBit);
d84 1
a84 1
			sImage.Format("\n<script language=\"javascript\">\n%s = \'#define _width %d\\n#define _height %d\\nstatic unsigned char _bits[] = { %s }\'\n</script>\n",
d131 1
a131 1
		sRet.Format("<img src=\"javascript:%s\" width=\"%d\" height=\"%d\">", m_sName.GetBuffer(0), m_nWidth, m_nHeight);
d137 1
a137 1
	return "";
@


1.1.4.1
log
@updating this branch...
@
text
@@

