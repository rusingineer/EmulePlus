head	1.16;
access;
symbols
	PublicRelease_1i:1.15
	Interim_Release_1i_RC6:1.15
	Interim_Release_1i_RC3:1.15
	Interim_Release_1i_RC2:1.14
	Interim_Release_1i_RC1:1.14
	Interim_Release_1i_beta3:1.13
	Interim_Release_1i_beta2:1.11
	Interim_Release_1i_beta1:1.11
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.8
	Interim_Release_1h_RC1:1.8
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.8
	Interim_Release_1h_beta1:1.8
	PublicRelease_1g:1.8
	Interim_Release_1g_RC6_Final:1.8
	Interim_Release_1g_RC6:1.8
	Interim_Release_1g_RC5:1.8
	Interim_Release_1g_RC4:1.8
	Interim_Release_1g_RC3:1.8
	Interim_Release_1g_beta2:1.8
	Interim_Release_1g_beta1:1.8
	Interim_Release_1f_RC4:1.8
	Interim_Release_1f_RC3:1.8
	Interim_Release_1f_RC2:1.7
	Interim_Release_1f_RC:1.7
	Interim_Release_1f_beta2:1.7
	Interim_Release_1f_beta1:1.7
	PublicRelease_1e:1.7
	Interim_Release_1e_RC2:1.7
	Interim_Release_1e_RC:1.7
	Interim_Release_1e_beta3:1.7
	Interim_Release_1e_beta2:1.7
	Interim_Release_1e_beta2_before_kuchin:1.7
	Interim_Release_1e_beta1:1.7
	PublicRelease_1c:1.7
	featurestest:1.7.0.2
	Interim_Release_1c_RC:1.7
	Interim_Release_1c_beta2:1.7
	Interim_Release_1c_beta1:1.6
	threaded_downloadqueue:1.6.0.2
	PublicRelease_1b:1.5
	Interim_Release_1b_beta2:1.5
	Interim_Release_1b_beta1:1.5
	proxydeadlake:1.5.0.4
	PublicRelease_1a:1.5
	Interim_Release_1a_beta2:1.5
	BerkeleyDb:1.5.0.2
	Interim_Release_1a_beta1:1.5
	PublicRelease_1:1.5
	goldfish:1.5
	eMulePlus_1_RC2:1.4
	eMulePlus_26b_1RC1:1.4
	PreRelease_26b_i0e:1.4
	before_26d_merge:1.4
	Interim_Release_26b_i0d:1.3
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.3.0.4
	plus26based:1.3.0.2
	Interim_Release_25b_i0b:1.3
	Proxy_Dev:1.3
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.16
date	2003.12.18.13.36.59;	author katsyonak;	state dead;
branches;
next	1.15;

1.15
date	2003.11.18.01.05.56;	author katsyonak;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.02.13.35.07;	author katsyonak;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.30.02.44.37;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.29.17.04.51;	author katsyonak;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.20.20.46.27;	author netwolf1;	state Exp;
branches;
next	1.7;

1.7
date	2003.03.18.04.10.48;	author recdvst;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.14.10.33.49;	author lord_kiron;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.20.14.29.01;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.02.03.39.55;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.18;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.10;	author cax2;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.02.02.02.36.26;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.16
log
@*** empty log message ***
@
text
@/********************************************************************
		HyperTextCtrl.h - Controls that shows hyperlinks 
		in text

		Copyright (C) 2001-2002 Magomed G. Abdurakhmanov			
********************************************************************/

//edited by (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//-> converted it to MFC
//-> included colored keywords
//-> fixed GPF bugs
//-> made it flickerfree
//-> some other small changes
// (the whole code still needs some work though)
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.


#include "stdafx.h"
#include "emule.h"
#include "hypertextctrl.h"
#include <deque>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// CHyperLink
CHyperLink::CHyperLink(int iBegin, uint16 iEnd, const CString& sTitle, const CString& sCommand, const CString& sDirectory)
{
	m_Type = lt_Shell;
	m_iBegin = iBegin;
	m_iEnd = iEnd;
	m_sTitle = sTitle;
	m_sCommand = sCommand;
	m_sDirectory = sDirectory;
   // [i_a] used for lt_Message  
    m_hWnd = 0; 
    m_uMsg = 0; 
    m_wParam = 0; 
    m_lParam = 0; 
} // [/i_a] 

CHyperLink::CHyperLink(int iBegin, uint16 iEnd, const CString& sTitle, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	m_Type = lt_Message;
	m_iBegin = iBegin;
	m_iEnd = iEnd;
	m_sTitle = sTitle;
	m_hWnd = hWnd;
	m_uMsg = uMsg;
	m_wParam = wParam;
	m_lParam = lParam;
}
 CHyperLink::CHyperLink()
 {  // [i_a] 
   m_Type = lt_Unknown; 
   m_iBegin = 0; 
   m_iEnd = 0; 
   m_sTitle.Empty(); 
   m_sCommand.Empty(); 
   m_sDirectory.Empty(); 
   m_hWnd = 0; 
   m_uMsg = 0; 
   m_wParam = 0; 
   m_lParam = 0; 
 } // [/i_a] 
CHyperLink::CHyperLink(const CHyperLink& Src)
{
	m_Type = Src.m_Type;
	m_iBegin = Src.m_iBegin;
	m_iEnd = Src.m_iEnd;
	m_sTitle = Src.m_sTitle;
	m_sCommand = Src.m_sCommand;
	m_sDirectory = Src.m_sDirectory;
	m_hWnd = Src.m_hWnd;
	m_uMsg = Src.m_uMsg;
	m_wParam = Src.m_wParam;
	m_lParam = Src.m_lParam;
}

void CHyperLink::Execute()
{
	EMULE_TRY
	switch(m_Type)
	{
	case lt_Shell:
		ShellExecute(NULL, NULL, m_sCommand, NULL, m_sDirectory, SW_SHOWDEFAULT);
		break;

	case lt_Message:
		PostMessage(m_hWnd, m_uMsg, m_wParam, m_lParam);
		break;
	}
	EMULE_CATCH
}

// CKeyWord
CKeyWord::CKeyWord(int iBegin, uint16 iEnd, COLORREF icolor)
{
	color = icolor;
	m_iBegin = iBegin;
	m_iEnd = iEnd;
}

// CPreparedHyperText
void CPreparedHyperText::PrepareText(const CString& sText)
{
	EMULE_TRY
	m_sText = sText;
	m_Links.clear();

	enum {
		unknown,
		space,
		http0,		/* http://		*/
		http1, http2, http3, http4, http5, http6,
		ftp0,		/* ftp://		*/
		ftp1, ftp2, ftp3, ftp4, ftp5,
		ftp,		/* ftp.			*/
		www0,		/* www.			*/
		www1, www2, www3,
		mailto0, 	/* mailto:		*/
		mailto1, mailto2, mailto3, mailto4, mailto5, mailto6,
		mail,		/* xxx@@yyy		*/
		ed2k0,		/* ed2k://		*/
		ed2k1, ed2k2, ed2k3, ed2k4, ed2k5, ed2k6
	} state = space;

	int WordPos = 0;
	TCHAR sz[2];
	TCHAR& c = sz[0];
	sz[1] = 0;
	int last = m_sText.GetLength() -1;
	for(int i = 0; i <= last; i++)
	{
		c = m_sText[i];
		_tcslwr(sz);

		switch(state)
		{
		case unknown:
			if(tspace(c))
				state = space;
			else
				if(c == _T('@@') && WordPos != i)
					state = mail;		
			break;

		case space:
			WordPos = i;
			switch(c)
			{
			case _T('h'): state = http0; break;
			case _T('f'): state = ftp0; break;
			case _T('w'): state = www0; break;
			case _T('m'): state = mailto0; break;
			case _T('e'): state = ed2k0; break;
			default:
				if(!tspace(c))
					state = unknown;
			}
			break;

			/*----------------- http -----------------*/
		case http0:
			if(c == _T('t'))
				state = http1;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case http1:
			if(c == _T('t'))
				state = http2;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case http2:
			if(c == _T('p'))
				state = http3;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case http3:
			if(c == _T(':'))
				state = http4;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case http4:
			if(c == _T('/'))
				state = http5;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case http5:
			if(c == _T('/'))
				state = http6;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case http6:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;

			/*----------------- ed2k -----------------*/
		case ed2k0:
			if(c == _T('d'))
				state = ed2k1;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ed2k1:
			if(c == _T('2'))
				state = ed2k2;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ed2k2:
			if(c == _T('k'))
				state = ed2k3;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ed2k3:
			if(c == _T(':'))
				state = ed2k4;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ed2k4:
			if(c == _T('/'))
				state = ed2k5;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ed2k5:
			if(c == _T('/'))
				state = ed2k6;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ed2k6:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;
			/*----------------- ftp -----------------*/
		case ftp0:
			if(c == _T('t'))
				state = ftp1;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ftp1:
			if(c == _T('p'))
				state = ftp2;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ftp2:
			if(c == _T(':'))
				state = ftp3;
			else
				if(c == _T('.'))
					state = ftp;
				else
					if(tspace(c))
						state = space;
					else
						state = unknown;
			break;

		case ftp3:
			if(c == _T('/'))
				state = ftp4;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ftp4:
			if(c == _T('/'))
				state = ftp5;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case ftp:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = CString(_T("ftp://")) + m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;

		case ftp5:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;

			/*----------------- www -----------------*/
		case www0:
			if(c == _T('w'))
				state = www1;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case www1:
			if(c == _T('w'))
				state = www2;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case www2:
			if(c == _T('.'))
				state = www3;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case www3:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = CString(_T("http://")) + m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;

			/*----------------- mailto -----------------*/
		case mailto0:
			if(c == _T('a'))
				state = mailto1;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case mailto1:
			if(c == _T('i'))
				state = mailto2;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case mailto2:
			if(c == _T('l'))
				state = mailto3;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case mailto3:
			if(c == _T('t'))
				state = mailto4;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case mailto4:
			if(c == _T('o'))
				state = mailto5;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case mailto5:
			if(c == _T(':'))
				state = mailto6;
			else
				if(tspace(c))
					state = space;
				else
					state = unknown;
			break;

		case mailto6:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;

			/*----------------- mailto -----------------*/
		case mail:
			if(tspace(c) || i == last)
			{
				int len = i == last ? i - WordPos + 1 : i - WordPos;
				CString s = CString(_T("mailto:")) + m_sText.Mid(WordPos, len);
				RemoveLastSign(s);
				m_Links.push_back(CHyperLink(WordPos, WordPos + len - 1, s, s, (LPCTSTR)NULL));
				state = space;
			}
			break;
		}
	}

	m_Links.sort();
	EMULE_CATCH
}

 void CPreparedHyperText::RemoveLastSign(CString& sLink)
{
	EMULE_TRY
	int len = sLink.GetLength();
	if(len > 0)
	{
		TCHAR c = sLink[len-1];
		switch(c)
		{
		case _T('.'):
		case _T(','):
		case _T(';'):
		case _T('\"'):
		case _T('\''):
		case _T('('):
		case _T(')'):
		case _T('['):
		case _T(']'):
		case _T('{'):
		case _T('}'):
			sLink.Delete(len -1, 1);
			break;
		}
	}
	EMULE_CATCH
}

CPreparedHyperText::CPreparedHyperText(const CString& sText)
{
	PrepareText(sText);
}

CPreparedHyperText::CPreparedHyperText(const CPreparedHyperText& src)
{
	EMULE_TRY
	m_sText = src.m_sText;
	m_Links.assign(src.m_Links.begin(), src.m_Links.end());
	EMULE_CATCH
}

void CPreparedHyperText::Clear()
{
	EMULE_TRY
	m_sText.Empty();
	m_Links.erase(m_Links.begin(), m_Links.end());
	EMULE_CATCH
}

void CPreparedHyperText::SetText(const CString& sText)
{
	Clear();
	PrepareText(sText);
}

void CPreparedHyperText::AppendText(const CString& sText)
{
	EMULE_TRY
	int len = m_sText.GetLength();
	////////////////////////////////////////////////
	//Top:The Original code didn't check to see if the buffer was full..
	////////////////////////////////////////////////
	bool flag = true;
	if( len > 60000 )
	{
		m_sText = m_sText.Right(50000);
		int shift = len - m_sText.GetLength();
		while( flag == true )
		{
			CHyperLink &test = m_Links.front();
			if( !m_Links.empty() )
			{
				if( test.Begin() < shift )
					m_Links.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		flag = true;
		while( flag == true )
		{
			CKeyWord &test = m_KeyWords.front();
			if( !m_KeyWords.empty() )
			{
				if( test.Begin() < shift )
					m_KeyWords.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		len = m_sText.GetLength();
		CHyperLink &ltest = m_Links.front();
		int litest = ltest.Begin() - shift;
		CKeyWord &wtest = m_KeyWords.front();
		int witest = wtest.Begin() - shift;
		flag = true;
		while( flag == true && !m_Links.empty() )
		{
			CHyperLink &temp = m_Links.front();
			CHyperLink backup( temp);
			backup.SetBegin( backup.Begin() - shift );
			backup.SetEnd( backup.End() - shift );
			m_Links.pop_front();
			m_Links.push_back( backup );
			if( ((CHyperLink)m_Links.front()).Begin() == litest )
				flag = false;
		}
		flag = true;
		while( flag == true && !m_KeyWords.empty() )
		{
			CKeyWord &temp = m_KeyWords.front();
			CKeyWord backup( temp.Begin()-shift, temp.End()-shift, temp.Color());
			m_KeyWords.pop_front();
			m_KeyWords.push_back( backup );
			if( ((CKeyWord)m_KeyWords.front()).Begin() == witest )
				flag = false;
		}
	}
	////////////////////////////////////////////////
	//Bottom: May not be the nicest code but it works.
	////////////////////////////////////////////////
	CPreparedHyperText ht(sText);
	m_sText+=sText;
	for(std::list<CHyperLink>::iterator it = ht.m_Links.begin(); it != ht.m_Links.end(); it++)
	{
		CHyperLink hl = *it;
		hl.m_iBegin += len;
		hl.m_iEnd += len;
		m_Links.push_back(hl);
	}

	EMULE_CATCH
}

void CPreparedHyperText::AppendHyperLink(const CString& sText, const CString& sTitle, const CString& sCommand, const CString& sDirectory)
{
	EMULE_TRY
	if (!(sText.GetLength() && sCommand.GetLength()))
		return;
	int len = m_sText.GetLength();
	////////////////////////////////////////////////
	//Top:The Original code didn't check to see if the buffer was full..
	////////////////////////////////////////////////
	bool flag = true;
	if( len > 60000 )
	{
		m_sText = m_sText.Right(50000);
		int shift = len - m_sText.GetLength();
		while( flag == true )
		{
			CHyperLink &test = m_Links.front();
			if( !m_Links.empty() )
			{
				if( test.Begin() < shift )
					m_Links.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		flag = true;
		while( flag == true )
		{
			CKeyWord &test = m_KeyWords.front();
			if( !m_KeyWords.empty() )
			{
				if( test.Begin() < shift )
					m_KeyWords.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		len = m_sText.GetLength();
		CHyperLink &ltest = m_Links.front();
		int litest = ltest.Begin() - shift;
		CKeyWord &wtest = m_KeyWords.front();
		int witest = wtest.Begin() - shift;
		flag = true;
		while( flag == true && !m_Links.empty() )
		{
			CHyperLink &temp = m_Links.front();
			CHyperLink backup( temp);
			backup.SetBegin( backup.Begin() - shift );
			backup.SetEnd( backup.End() - shift );
			m_Links.pop_front();
			m_Links.push_back( backup );
			if( ((CHyperLink)m_Links.front()).Begin() == litest )
				flag = false;
		}
		flag = true;
		while( flag == true && !m_KeyWords.empty() )
		{
			CKeyWord &temp = m_KeyWords.front();
			CKeyWord backup( temp.Begin()-shift, temp.End()-shift, temp.Color());
			m_KeyWords.pop_front();
			m_KeyWords.push_back( backup );
			if( ((CKeyWord)m_KeyWords.front()).Begin() == witest )
				flag = false;
		}
	}
	////////////////////////////////////////////////
	//Bottom: May not be the nicest code but it works.
	////////////////////////////////////////////////
	m_sText+=sText;
	m_Links.push_back(CHyperLink(len, len + sText.GetLength() - 1, sTitle, sCommand, sDirectory));
	EMULE_CATCH
}

void CPreparedHyperText::AppendHyperLink(const CString& sText, const CString& sTitle, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY
	if (!sText.GetLength())
		return;
	int len = m_sText.GetLength();
	////////////////////////////////////////////////
	//Top:The Original code didn't check to see if the buffer was full..
	////////////////////////////////////////////////
	bool flag = true;
	if( len > 60000 )
	{
		m_sText = m_sText.Right(50000);
		int shift = len - m_sText.GetLength();
		while( flag == true )
		{
			CHyperLink &test = m_Links.front();
			if( !m_Links.empty() )
			{
				if( test.Begin() < shift )
					m_Links.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		flag = true;
		while( flag == true )
		{
			CKeyWord &test = m_KeyWords.front();
			if( !m_KeyWords.empty() )
			{
				if( test.Begin() < shift )
					m_KeyWords.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		len = m_sText.GetLength();
		CHyperLink &ltest = m_Links.front();
		int litest = ltest.Begin() - shift;
		CKeyWord &wtest = m_KeyWords.front();
		int witest = wtest.Begin() - shift;
		flag = true;
		while( flag == true && !m_Links.empty() )
		{
			CHyperLink &temp = m_Links.front();
			CHyperLink backup( temp);
			backup.SetBegin( backup.Begin() - shift );
			backup.SetEnd( backup.End() - shift );
			m_Links.pop_front();
			m_Links.push_back( backup );
			if( ((CHyperLink)m_Links.front()).Begin() == litest )
				flag = false;
		}
		flag = true;
		while( flag == true && !m_KeyWords.empty() )
		{
			CKeyWord &temp = m_KeyWords.front();
			CKeyWord backup( temp.Begin()-shift, temp.End()-shift, temp.Color());
			m_KeyWords.pop_front();
			m_KeyWords.push_back( backup );
			if( ((CKeyWord)m_KeyWords.front()).Begin() == witest )
				flag = false;
		}
	}
	////////////////////////////////////////////////
	//Bottom: May not be the nicest code but it works.
	////////////////////////////////////////////////
	m_sText+=sText;
	m_Links.push_back(CHyperLink(len, len + sText.GetLength() - 1, sTitle, hWnd, uMsg, wParam, lParam));
	EMULE_CATCH
}

void CPreparedHyperText::AppendKeyWord(const CString& sText, COLORREF iColor)
{
	EMULE_TRY
	if (!sText.GetLength())
		return;
	int len = m_sText.GetLength();
	////////////////////////////////////////////////
	//Top:The Original code didn't check to see if the buffer was full..
	////////////////////////////////////////////////
	bool flag = true;
	if( len > 60000 )
	{
		m_sText = m_sText.Right(50000);
		int shift = len - m_sText.GetLength();
		while( flag == true )
		{
			CHyperLink &test = m_Links.front();
			if( !m_Links.empty() )
			{
				if( test.Begin() < shift )
					m_Links.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		flag = true;
		while( flag == true )
		{
			CKeyWord &test = m_KeyWords.front();
			if( !m_KeyWords.empty() )
			{
				if( test.Begin() < shift )
					m_KeyWords.pop_front();
				else
					flag = false;
			}
			else
				flag = false;
		}
		len = m_sText.GetLength();
		CHyperLink &ltest = m_Links.front();
		int litest = ltest.Begin() - shift;
		CKeyWord &wtest = m_KeyWords.front();
		int witest = wtest.Begin() - shift;
		flag = true;
		while( flag == true && !m_Links.empty() )
		{
			CHyperLink &temp = m_Links.front();
			CHyperLink backup( temp);
			backup.SetBegin( backup.Begin() - shift );
			backup.SetEnd( backup.End() - shift );
			m_Links.pop_front();
			m_Links.push_back( backup );
			if( ((CHyperLink)m_Links.front()).Begin() == litest )
				flag = false;
		}
		flag = true;
		while( flag == true && !m_KeyWords.empty() )
		{
			CKeyWord &temp = m_KeyWords.front();
			CKeyWord backup( temp.Begin()-shift, temp.End()-shift, temp.Color());
			m_KeyWords.pop_front();
			m_KeyWords.push_back( backup );
			if( ((CKeyWord)m_KeyWords.front()).Begin() == witest )
				flag = false;
		}
	}
	////////////////////////////////////////////////
	//Bottom: May not be the nicest code but it works.
	////////////////////////////////////////////////
	m_sText+=sText;
	m_KeyWords.push_back(CKeyWord(len, len + sText.GetLength() - 1, iColor));
	EMULE_CATCH
}

//CLinePartInfo

CLinePartInfo::CLinePartInfo(int iBegin, uint16 iEnd, CHyperLink* pHyperLink, CKeyWord* pKeyWord)
{
	m_xBegin = iBegin;
	m_xEnd = iEnd;
	m_pHyperLink = pHyperLink;
	m_pKeyWord = pKeyWord;
}

CLinePartInfo::CLinePartInfo(const CLinePartInfo& Src)
{
	m_xBegin = Src.m_xBegin;
	m_xEnd = Src.m_xEnd;
	m_pHyperLink = Src.m_pHyperLink;
	m_pKeyWord = Src.m_pKeyWord;
}


//CLineInfo

CLineInfo::CLineInfo(int iBegin, uint16 iEnd)
{
	m_iBegin = iBegin;
	m_iEnd = iEnd;
}

CLineInfo::CLineInfo(const CLineInfo& Src)
{
	m_iBegin = Src.m_iBegin;
	m_iEnd = Src.m_iEnd;
	assign(Src.begin(), Src.end());
}


//CVisPart
CVisPart::CVisPart(const CLinePartInfo& LinePartInfo, const CRect& rcBounds, int iRealBegin, uint16 iRealLen,CVisPart* pPrev,CVisPart* pNext) : CLinePartInfo(LinePartInfo)
{
	m_rcBounds = rcBounds;
	m_iRealBegin = iRealBegin;
	m_iRealLen = iRealLen;
	m_pPrev = pPrev;
	m_pNext = pNext;
}

CVisPart::CVisPart(const CVisPart& Src) : CLinePartInfo(Src)
{
	m_rcBounds = Src.m_rcBounds;
	m_iRealBegin = Src.m_iRealBegin;
	m_iRealLen = Src.m_iRealLen;
	m_pPrev = Src.m_pPrev;
	m_pNext = Src.m_pNext;
}



// --------------------------------------------------------------
// CHyperTextCtrl
IMPLEMENT_DYNAMIC(CHyperTextCtrl, CWnd)

BEGIN_MESSAGE_MAP(CHyperTextCtrl, CWnd)
	ON_MESSAGE(WM_PAINT,OnPaint)
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_MOUSEWHEEL()
	ON_MESSAGE(WM_SIZE, OnSize)
	ON_MESSAGE(WM_SHOWWINDOW, OnShowWindow)
	ON_MESSAGE(WM_CREATE, OnCreate)
	ON_MESSAGE(WM_DESTROY, OnDestroy)
	ON_MESSAGE(WM_SETTEXT, OnSetText)
	ON_MESSAGE(WM_GETTEXT, OnGetText)
	ON_MESSAGE(WM_SETFONT, OnSetFont)
	ON_MESSAGE(WM_GETFONT, OnGetFont)
	ON_WM_ERASEBKGND()
	ON_MESSAGE(WM_HSCROLL, OnHScroll)
	ON_MESSAGE(WM_VSCROLL, OnVScroll)
	ON_MESSAGE(WM_CAPTURECHANGED, OnCaptureChanged)
	ON_WM_SYSCOLORCHANGE()
	//REFLECT_NOTIFICATIONS()
END_MESSAGE_MAP()

CHyperTextCtrl::CHyperTextCtrl()
{
	m_Text = &standard_Text;
	vscrollon = false;
	m_Font = NULL;
	m_BkColor = RGB(0,0,0);
	m_TextColor = RGB(0,0,0);
	m_LinkColor = RGB(0,0,0);
	m_HoverColor = RGB(0,0,0);
	m_LinkCursor = NULL;
	m_DefaultCursor = NULL;
	vscrollon = false;
	m_iMaxWidth = 0;
	m_iLineHeight = 0;
	m_iLinesHeight = 0;
	m_bDontUpdateSizeInfo = false;
	m_iVertPos = 0;
	m_iHorzPos = 0;
	m_pActivePart = NULL;
	m_iWheelDelta = 0;
}

//message handlers

LRESULT CHyperTextCtrl::OnDestroy(WPARAM wParam, LPARAM lParam)
{
	if (m_LinkCursor)
	{
		SetCursor(m_DefaultCursor);
		VERIFY( DestroyCursor(m_LinkCursor) );
	}
	m_LinkCursor = NULL;

	return 0;
}

LRESULT CHyperTextCtrl::OnCreate(WPARAM wParam, LPARAM lParam)
{  
	//LPCREATESTRUCT lpCreateStruct = (LPCREATESTRUCT)lParam;
	m_iMaxWidth = 0;
	m_iLinesHeight = 0;
	m_bDontUpdateSizeInfo = false;
	m_iHorzPos = 0;
	m_iVertPos = 0;
	m_Font = &g_eMuleApp.m_pdlgEmule->m_fontDefault;
	SetColors(); 
	LoadHandCursor();
	m_DefaultCursor = LoadCursor(NULL,IDC_ARROW);
	m_pActivePart = NULL;
	m_iWheelDelta = 0;

	// create a tool tip
	m_tip.Create(this);
	if(m_tip)
		m_tip.Activate(TRUE);

	UpdateFonts();
	return 0; 
}

LRESULT CHyperTextCtrl::OnPaint(WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY
	CPaintDC dc(this); // device context for painting
	CFont* hOldFont = dc.SelectObject(m_Font);

	dc.SetBkColor(m_BkColor);

	int ypos = 0;
	LPCTSTR s = m_Text->GetText();

	CRect rc;
	CRect rcClient;
	GetClientRect(rcClient);
	rc.left = dc.m_ps.rcPaint.left;
	rc.right = 2;
	rc.top = dc.m_ps.rcPaint.top;
	rc.bottom = dc.m_ps.rcPaint.bottom;

	CBrush brBk;
	brBk.CreateSolidBrush(m_BkColor);
	CBrush* pOldBrush = dc.SelectObject(&brBk);		//eklmn: select a new brush
	dc.FillRect(rc, &brBk);

	for(std::vector<CVisLine>::iterator it = m_VisLines.begin(); it != m_VisLines.end(); it++)
	{
		int iLastX = dc.m_ps.rcPaint.left;

		for(CVisLine::iterator jt = it->begin(); jt != it->end(); jt++)
		{
			if (jt->m_pKeyWord)
				dc.SetTextColor(jt->m_pKeyWord->Color());
			else if(jt->m_pHyperLink == NULL)
				dc.SetTextColor(m_TextColor);
			else
			{
				if(m_pActivePart != NULL && m_pActivePart->m_pHyperLink == jt->m_pHyperLink)
				{
					dc.SetTextColor(m_HoverColor);
					dc.SelectObject(m_HoverFont);
				}
				else
				{
					dc.SetTextColor(m_LinkColor);
					dc.SelectObject(m_LinksFont);
				}
			}

			TextOut(dc, jt->m_rcBounds.left, jt->m_rcBounds.top, s + jt->m_iRealBegin, jt->m_iRealLen);

			if(jt->m_pHyperLink != NULL)
				dc.SelectObject(m_Font);

			iLastX = jt->m_rcBounds.right;
		}

		rc.left = iLastX;
		rc.right = dc.m_ps.rcPaint.right;
		rc.top = ypos;
		rc.bottom = ypos + m_iLineHeight;

		dc.FillRect(rc, &brBk);

		ypos+=m_iLineHeight;
	}

	rc.left = dc.m_ps.rcPaint.left;
	rc.right = dc.m_ps.rcPaint.right;
	rc.top = ypos;
	rc.bottom = dc.m_ps.rcPaint.bottom;
	dc.FillRect(rc, &brBk);

	dc.SelectObject(pOldBrush);
	dc.SelectObject(hOldFont);
	EMULE_CATCH
	return 0;
}

LRESULT CHyperTextCtrl::OnSize(WPARAM wParam, LPARAM lParam)
{
	WORD cx, cy;
	cx = LOWORD(lParam);
	cy = HIWORD(lParam);

	UpdateSize(IsWindowVisible() == TRUE);
	return 0;
}

LRESULT CHyperTextCtrl::OnShowWindow(WPARAM wParam, LPARAM lParam)
{
	if(TRUE == (BOOL)wParam)
		UpdateSize(false);
	return 0;
}

LRESULT CHyperTextCtrl::OnSetText(WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY
	m_Text->SetText((LPTSTR)lParam);
	UpdateSize(IsWindowVisible() == TRUE);

	EMULE_CATCH

	return TRUE;
}

LRESULT CHyperTextCtrl::OnGetText(WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY

	int bufsize = wParam;
	LPTSTR buf = (LPTSTR)lParam;
	if(lParam == NULL || bufsize == 0 || m_Text->GetText().IsEmpty())
		return 0;
	int cpy = m_Text->GetText().GetLength() > (bufsize-1) ? (bufsize-1) : m_Text->GetText().GetLength();
	_tcsncpy(buf, m_Text->GetText(), cpy);
	return cpy;

	EMULE_CATCH

	return 0;
}

LRESULT CHyperTextCtrl::OnSetFont(WPARAM wParam, LPARAM lParam)
{
	m_Font = CFont::FromHandle((HFONT)wParam);
	UpdateFonts();
	UpdateSize(LOWORD(lParam) != 0);
	return 0;
}

LRESULT CHyperTextCtrl::OnGetFont(WPARAM wParam, LPARAM lParam)
{
	return (LRESULT)m_Font->m_hObject;
}

LRESULT CHyperTextCtrl::OnHScroll(WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY

	SCROLLINFO si;
	si.cbSize = sizeof(si);
	si.fMask = SIF_ALL;

	GetScrollInfo(SB_HORZ, &si);

	switch(LOWORD(wParam))
	{
	case SB_LEFT:
		si.nPos=si.nMin;
		break;

	case SB_RIGHT:
		si.nPos=si.nMax;
		break;

	case SB_LINELEFT:
		if(si.nPos > si.nMin)
			si.nPos-=1;
		break;

	case SB_LINERIGHT:
		if(si.nPos < si.nMax)
			si.nPos+=1;
		break;

	case SB_PAGELEFT:
		if(si.nPos > si.nMin)
			si.nPos-=si.nPage;
		if(si.nPos < si.nMin)
			si.nPos = si.nMin;
		break;

	case SB_PAGERIGHT:
		if(si.nPos < si.nMax)
			si.nPos+=si.nPage;
		if(si.nPos > si.nMax)
			si.nPos = si.nMax;
		break;

	case SB_THUMBTRACK:
		si.nPos=si.nTrackPos;
		break;
	}

	if(si.nMax != si.nMin)
		m_iHorzPos = si.nPos * 100 / (si.nMax - si.nMin);
	SetScrollInfo(SB_HORZ, &si);
	UpdateVisLines();
	InvalidateRect(NULL,FALSE);

	EMULE_CATCH

	return TRUE;
}

LRESULT CHyperTextCtrl::OnVScroll(WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY

	SCROLLINFO si;
	si.cbSize = sizeof(si);
	si.fMask = SIF_ALL;
	GetScrollInfo(SB_VERT, &si);

	switch(LOWORD(wParam))
	{
	case SB_TOP:
		si.nPos=si.nMin;
		break;

	case SB_BOTTOM:
		si.nPos=si.nMax;
		break;

	case SB_LINEUP:
		if(si.nPos > si.nMin)
			si.nPos-=1;
		break;

	case SB_LINEDOWN:
		if(si.nPos < si.nMax)
			si.nPos+=1;
		break;

	case SB_PAGEUP:
		if(si.nPos > si.nMin)
			si.nPos-=si.nPage;
		if(si.nPos < si.nMin)
			si.nPos = si.nMin;
		break;

	case SB_PAGEDOWN:
		if(si.nPos < si.nMax)
			si.nPos+=si.nPage;
		if(si.nPos > si.nMax)
			si.nPos = si.nMax;
		break;

	case SB_THUMBTRACK:
		si.nPos=si.nTrackPos;
		break;
	}

	if(si.nMax != si.nMin)
		m_iVertPos = si.nPos * 100 / (si.nMax - si.nMin);
	SetScrollInfo(SB_VERT, &si);
	UpdateVisLines();
	InvalidateRect(NULL,FALSE);

	EMULE_CATCH

	return TRUE;
}

void CHyperTextCtrl::OnMouseMove(UINT nFlags,CPoint pt)
{
	EMULE_TRY

	CRect rcClient;
	GetClientRect(rcClient);
	if(PtInRect(rcClient, pt) && m_iLineHeight)
	{
		bool bFound = false;
		uint16 i = pt.y / m_iLineHeight;
		if(i < m_VisLines.size())
		{
			std::vector<CVisLine>::iterator it = m_VisLines.begin() + i;
			for(CVisLine::iterator jt = it->begin(); jt != it->end(); jt++)
				if(pt.x >= jt->m_rcBounds.left && pt.x <= jt->m_rcBounds.right)
				{
					if(jt->m_pHyperLink != NULL)
					{
						HighlightLink(&*jt, pt);
						bFound = true;
						if (GetCapture() != this)
							SetCapture();
					}
					break;
				}
		}
		if(!bFound)
		{
			RestoreLink();
			if (GetCapture() == this)
				ReleaseCapture(); 
		}
	}
	else
		ReleaseCapture();
	EMULE_CATCH
}

void CHyperTextCtrl::OnLButtonDown(UINT nFlags,CPoint pt)
{
	EMULE_TRY

	CRect rcClient;
	GetClientRect(rcClient);
	if(PtInRect(rcClient, pt) && m_iLineHeight)
	{
		bool bFound = false;
		uint16 i = pt.y / m_iLineHeight;
		if(i < m_VisLines.size())
		{
			std::vector<CVisLine>::iterator it = m_VisLines.begin() + i;
			for(CVisLine::iterator jt = it->begin(); jt != it->end(); jt++)
				if(pt.x >= jt->m_rcBounds.left && pt.x <= jt->m_rcBounds.right)
				{
					if(jt->m_pHyperLink != NULL)
					{
						jt->m_pHyperLink->Execute();
						bFound = true;
					}
					break;
				}
		}

	}
	//m_tip.OnLButtonDown(nFlags,pt);

	EMULE_CATCH
}

BOOL CHyperTextCtrl::OnMouseWheel(UINT nFlags,short zDelta,CPoint pt)
{
	EMULE_TRY

	CRect rc;
	GetWindowRect(rc);
	if(PtInRect(rc, pt))
	{
		int iScrollLines;
		SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 
			0, 
			&iScrollLines, 
			0);

		m_iWheelDelta -= zDelta;
		if(abs(m_iWheelDelta) >= WHEEL_DELTA)
		{
			if(m_iWheelDelta > 0)
			{
				for(int i = 0; i<iScrollLines; i++)
					PostMessage(WM_VSCROLL, SB_LINEDOWN, 0);
			}
			else
			{
				for(int i = 0; i<iScrollLines; i++)
					PostMessage(WM_VSCROLL, SB_LINEUP, 0);
			}

			m_iWheelDelta %= WHEEL_DELTA;
		}
	}

	EMULE_CATCH

	return true;
	//m_tip.OnMouseWheel(nFlags,zDelta,pt);
}

LRESULT CHyperTextCtrl::OnCaptureChanged(WPARAM wParam, LPARAM lParam)
{    
	RestoreLink();
	return 0;
}

BOOL CHyperTextCtrl::OnEraseBkgnd(CDC* pDC)
{
	return TRUE;
}

// Operations
CPreparedHyperText* CHyperTextCtrl::GetHyperText()
{
	return m_Text;
}

void CHyperTextCtrl::SetHyperText(CPreparedHyperText* Src, bool bInvalidate)
{
	EMULE_TRY

	if (Src)
		m_Text = Src;
	else
		m_Text = &standard_Text;
	UpdateSize(bInvalidate);

	EMULE_CATCH
}

void CHyperTextCtrl::AppendText(const CString& sText, bool bInvalidate)
{
	EMULE_TRY

	m_Text->AppendText(sText);
	UpdateSize(bInvalidate);

	EMULE_CATCH
}

void CHyperTextCtrl::AppendHyperLink(const CString& sText, const CString& sTitle, const CString& sCommand, const CString& sDirectory, bool bInvalidate)
{
	EMULE_TRY

	m_Text->AppendHyperLink(sText, sTitle, sCommand, sDirectory);
	UpdateSize(bInvalidate);

	EMULE_CATCH
}

void CHyperTextCtrl::AppendKeyWord(const CString& sText, COLORREF icolor)
{
	EMULE_TRY

	m_Text->AppendKeyWord(sText,icolor);
	UpdateSize(true);

	EMULE_CATCH
}

void CHyperTextCtrl::AppendHyperLink(const CString& sText, const CString& sTitle, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, bool bInvalidate)
{
	EMULE_TRY

	m_Text->AppendHyperLink(sText, sTitle, hWnd, uMsg, wParam, lParam);
	UpdateSize(bInvalidate);

	EMULE_CATCH
}

void CHyperTextCtrl::SetLinkColor(COLORREF LinkColor, bool bInvalidate)
{
	m_LinkColor = LinkColor;
	if(bInvalidate)
		InvalidateRect(NULL,FALSE);
}

void CHyperTextCtrl::UpdateSize(bool bRepaint)
{
	EMULE_TRY

	if(m_bDontUpdateSizeInfo)
		return;
	m_bDontUpdateSizeInfo = true;
	DWORD dwStyle = GetWindowLongPtr(m_hWnd,GWL_STYLE);
	bool vscrollneeded = false;

	CClientDC dc(this);
	CFont* hOldFont = dc.SelectObject(m_Font);
	

	int iScrollHeight = GetSystemMetrics(SM_CYHSCROLL);

	m_Lines.clear();
	CRect rc;
	GetClientRect(rc);
	rc.DeflateRect(2,0);
	m_iMaxWidth = 0;
	m_iLinesHeight = 0;
	long iMaxWidthChars = 0;
	SIZE sz;

	if(rc.Width() > 5 && rc.Height() > 5)
	{
		std::list<CHyperLink>::iterator it = m_Text->GetLinks().begin();
		std::list<CKeyWord>::iterator ht = m_Text->GetKeywords().begin();
		LPCTSTR s = m_Text->GetText();
		int len = m_Text->GetText().GetLength();
		int width = rc.Width();

		int npos, // new position
			pos = 0, // current position
			ll, // line length
			rll; // line length with wordwrap (if used)

		while(len>0)
		{
			ll = len;
			npos = ll;
			for(int i = 0; i < len; i++)
			{
				if(s[i] == _T('\r') || s[i] == _T('\n'))
				{
					if(s[i] == _T('\r') && ((i+1) < len) && s[i+1] == _T('\n'))
						npos = i + 2;
					else
						npos = i + 1;

					ll = i;
					break;
				}
			}

			if(!::GetTextExtentExPoint(dc, s , (ll > 512) ? 512 : ll, width, &rll, NULL, &sz) || sz.cy == 0)
			{
				::GetTextExtentExPoint(dc, _T(" ") , 1, 0, NULL, NULL, &sz);
				sz.cx = 0;
				rll = ll;
			}

			if(rll>ll)
				rll = ll;

			if(!check_bits(dwStyle, HTC_WORDWRAP))
				rll = ll;
			else
				if(rll < ll)
					npos = rll;

			if(rll>0)
			{
				if((rll < len) && !_istspace(s[rll]))
					for(int i = rll - 1; i >= 0; i--)
						if(_istspace(s[i]))
						{
							rll = i;
							npos = i + 1;
							break;
						}
			}

			if(npos == 0)
				npos = 1;

			CLineInfo li(pos, pos + rll - 1);
			CLinePartInfo pl(pos, pos + rll - 1);

			while(it != m_Text->GetLinks().end() && it->End() < pos)
				it++;
			while(ht != m_Text->GetKeywords().end() && ht->End() < pos)
				ht++;

			//split the line into parts of hypertext, normaltext, keywords etc 
			for (int i = pl.Begin(); i < pl.End(); i++)
			{
				if (it != m_Text->GetLinks().end() && i >= it->Begin() && it->End() > i)
				{ // i_a 
					if (i > pl.m_xBegin)
					{
						CLinePartInfo pln(pl.m_xBegin,i-1);
						li.push_back(pln);
					}

					if (it->End() > pl.End())
					{
						pl.m_xBegin =  pl.End() + 1;
						CLinePartInfo pln(i, pl.End(), &*it);
						li.push_back(pln);
						break;
					}
					else
					{
						pl.m_xBegin =  it->End() + 1;
						CLinePartInfo pln(i, it->End(), &*it);
						li.push_back(pln);
						i = pl.m_xBegin;
						it++;
					}

				}
				else if (ht != m_Text->GetKeywords().end() && i >= ht->Begin() && ht->End() > i)
				{ // i_a 
					if (i > pl.m_xBegin)
					{
							CLinePartInfo pln(pl.m_xBegin,i-1);
							li.push_back(pln);
					}
					if (ht->End() > pl.End())
					{
						pl.m_xBegin =  pl.End() + 1;
						CLinePartInfo pln(i, pl.End(),0, &*ht);
						li.push_back(pln);
						break;
					}
					else
					{
						pl.m_xBegin =  ht->End() + 1;
						CLinePartInfo pln(i, ht->End(),0, &*ht);
						li.push_back(pln);
						i = pl.m_xBegin;
						ht++;
					}

				}

			}

			if(pl.Len()>0)
				li.push_back(pl);

			m_iLineHeight = sz.cy;
			m_iLinesHeight+=m_iLineHeight;
			if(sz.cx > m_iMaxWidth)
				m_iMaxWidth = sz.cx;
			if(iMaxWidthChars < li.Len())
				iMaxWidthChars = li.Len();

			m_Lines.push_back(li);

			pos+=npos;
			s+=npos;
			len-=npos;

			if((m_iLinesHeight + iScrollHeight) > rc.Height())
				vscrollneeded = true;
		}
		if(bRepaint)
			InvalidateRect(rc);
	}
	
	dc.SelectObject(hOldFont);

	// Update scroll bars
	dwStyle = GetWindowLongPtr(m_hWnd,GWL_STYLE);
	if (check_bits(dwStyle, HTC_AUTO_SCROLL_BARS))
	{
		if (vscrollneeded)
		{
			if (!vscrollon)
				ShowScrollBar(SB_VERT,TRUE);
			dwStyle|=WS_VSCROLL;
			vscrollon = true;
		}
		else if (!vscrollneeded)
		{
			ShowScrollBar(SB_VERT,FALSE);
			vscrollon = false;
		}
	}

	if(check_bits(dwStyle, HTC_AUTO_SCROLL_BARS) && !check_bits(dwStyle, HTC_WORDWRAP))
	{
		if(m_iMaxWidth > rc.Width())
		{
			ShowScrollBar(SB_HORZ,TRUE);
			dwStyle|=WS_HSCROLL;
		};

	}

	SCROLLINFO si;
	si.cbSize = sizeof(si);
	si.fMask = SIF_PAGE | SIF_POS | SIF_RANGE;

	if(check_bits(dwStyle,WS_HSCROLL) && m_iMaxWidth != 0)
	{
		si.nMin = 0;
		si.nMax = iMaxWidthChars + iMaxWidthChars/2;
		si.nPos = (int)(double(si.nMax) * m_iHorzPos / 100);
		si.nPage = (rc.Width() * si.nMax)/m_iMaxWidth;
		SetScrollInfo(SB_HORZ, &si, FALSE);
	}

	if(check_bits(dwStyle,WS_VSCROLL) && m_iLinesHeight != 0)
	{
		si.nMin = 0;
		si.nMax = (int)m_Lines.size();
		si.nPos = si.nMax;//(int)(double(si.nMax) * m_iVertPos / 100);
		si.nPage = (rc.Height() * si.nMax)/m_iLinesHeight;
		SetScrollInfo(SB_VERT, &si, TRUE);
	}

	m_bDontUpdateSizeInfo = false;
	UpdateVisLines();

	EMULE_CATCH
}

void CHyperTextCtrl::UpdateFonts()
{
	EMULE_TRY

	DWORD dwStyle = GetWindowLongPtr(m_hWnd,GWL_STYLE);
	m_LinksFont.DeleteObject();
	m_HoverFont.DeleteObject();
	
	LOGFONT lf;
	m_Font->GetLogFont(&lf);
	if(check_bits(dwStyle, HTC_UNDERLINE_LINKS))
		lf.lfUnderline = TRUE;
	m_LinksFont.CreateFontIndirect(&lf);

	m_Font->GetLogFont(&lf);
	if(check_bits(dwStyle, HTC_UNDERLINE_HOVER))
		lf.lfUnderline = TRUE;
	m_HoverFont.CreateFontIndirect(&lf);

	EMULE_CATCH
}

void CHyperTextCtrl::UpdateVisLines()
{
	EMULE_TRY

	RestoreLink();
	DWORD dwStyle = ::GetWindowLongPtr(m_hWnd,GWL_STYLE);
	int id = 1;
	if(check_bits(dwStyle, HTC_ENABLE_TOOLTIPS))
	{
		for(std::vector<CVisLine>::iterator itv = m_VisLines.begin(); itv != m_VisLines.end(); itv++)
			for(CVisLine::iterator jt = itv->begin(); jt != itv->end(); jt++)
			{
				if(jt->m_pHyperLink != NULL)
					m_tip.DelTool(this, id++);
			}
	}

	m_VisLines.clear();

	std::vector<CLineInfo>::iterator it = m_Lines.begin();
	int iVertPos = 0;
	int iHorzPos = 0;
	if(check_bits(dwStyle,WS_VSCROLL))
		iVertPos = GetScrollPos(SB_VERT);
	if(check_bits(dwStyle,WS_HSCROLL))
		iHorzPos = GetScrollPos(SB_HORZ);

	if(iVertPos >= (int)m_Lines.size())
		return;

	it+=iVertPos;

	CClientDC dc(this); // device context for painting

	CFont* hOldFont = dc.SelectObject(m_Font);

	int ypos = 0;
	LPCTSTR s = m_Text->GetText();

	CRect rcClient;
	GetClientRect(rcClient);

	for(; it != m_Lines.end(); it++)
	{
		uint16 XPos = 2;
		uint16 LinePos = it->Begin();
		uint16 Offset = 0;
		uint16 Len = 0;

		CVisLine vl;
		CRect rcBounds;

		std::vector<CLinePartInfo>::iterator jt;

		for(jt = it->begin(); jt != it->end(); jt++)
		{
			if(jt->Begin() <= (LinePos + iHorzPos) && jt->End() >= (LinePos + iHorzPos))
			{
				Offset = LinePos + iHorzPos;
				Len = jt->Len() - ((LinePos + iHorzPos) - jt->Begin());
				break;
			}
		}

		while(jt != it->end())
		{
			if(Len > 0)
			{
				SIZE sz;
				::GetTextExtentExPoint(dc, s + Offset, Len, 0, NULL, NULL, &sz);

				rcBounds.left = XPos;
				XPos+=sz.cx;
				rcBounds.right = XPos;
				rcBounds.top = ypos;
				rcBounds.bottom = ypos+m_iLineHeight;

				vl.push_back(CVisPart(*jt, rcBounds, Offset, Len, NULL, NULL));
			}

			if(XPos > rcClient.Width())
				break;

			jt++;
			if (jt == it->end())
				break;
			Offset = jt->m_xBegin;
			Len = jt->Len();
			
		}

		m_VisLines.push_back(vl);
		ypos+=m_iLineHeight;
		if(ypos>rcClient.bottom)
			break;
	}

	CVisPart *pPrev = NULL, *pNext;

	id = 1;
	for(std::vector<CVisLine>::iterator it2 = m_VisLines.begin(); it2 != m_VisLines.end(); it2++)
		for(CVisLine::iterator jt = it2->begin(); jt != it2->end(); jt++)
		{
			pNext = &*jt;
			if(pPrev != NULL && 
				pPrev->m_pHyperLink != NULL && 
				pPrev->m_pHyperLink == pNext->m_pHyperLink &&
				pPrev != pNext)
			{
				pPrev->m_pNext = pNext;
				pNext->m_pPrev = pPrev;
			}
			pPrev = pNext;

			if(check_bits(dwStyle, HTC_ENABLE_TOOLTIPS) && jt->m_pHyperLink != NULL)
				m_tip.AddTool(this, (LPCTSTR)jt->m_pHyperLink->Title(), jt->m_rcBounds, id++);
		}

		dc.SelectObject(hOldFont);

	EMULE_CATCH
}

void CHyperTextCtrl::HighlightLink(CVisPart* Part, const CPoint& MouseCoords)
{
	EMULE_TRY

	if(m_pActivePart == Part)
		return;

	if(m_pActivePart != Part && m_pActivePart != NULL && Part != NULL && m_pActivePart->m_pHyperLink != Part->m_pHyperLink)
		RestoreLink();

	m_pActivePart = Part;
	while(m_pActivePart->m_pPrev != NULL)
		m_pActivePart = m_pActivePart->m_pPrev;

	CClientDC dc(this);
	CFont* hOldFont = dc.SelectObject(&m_HoverFont);
	dc.SetBkColor(m_BkColor);
	dc.SetTextColor(m_HoverColor);
	LPCTSTR s = m_Text->GetText();

	CVisPart* p = m_pActivePart;
	while(p != NULL)
	{
		TextOut(dc, p->m_rcBounds.left, p->m_rcBounds.top, 
			s + p->m_iRealBegin, p->m_iRealLen);
		p = p->m_pNext;
	}

	dc.SelectObject(hOldFont);

	SetCursor(m_LinkCursor);

	EMULE_CATCH
}

void CHyperTextCtrl::RestoreLink()
{
	EMULE_TRY

	if(m_pActivePart == NULL)
		return;

	CClientDC dc(this);
	CFont* hOldFont = dc.SelectObject(&m_LinksFont);
	dc.SetBkColor(m_BkColor);
	dc.SetTextColor(m_LinkColor);
	LPCTSTR s = m_Text->GetText();

	CVisPart* p = m_pActivePart;
	while(p != NULL)
	{
		TextOut(dc, p->m_rcBounds.left, p->m_rcBounds.top, 
			s + p->m_iRealBegin, p->m_iRealLen);
		p = p->m_pNext;
	}

	dc.SelectObject(hOldFont);

	m_pActivePart = NULL;
	SetCursor(m_DefaultCursor);

	EMULE_CATCH
}

void CHyperTextCtrl::OnSysColorChange()
{
	//adjust colors
	CWnd::OnSysColorChange();
	SetColors();
}

void CHyperTextCtrl::SetColors()
{
	m_BkColor = GetSysColor(COLOR_WINDOW);
	m_TextColor = GetSysColor(COLOR_WINDOWTEXT);
	//perhaps some sort of check against the bk and text color can be made
	//before blindly using these default link colors?
	m_LinkColor = RGB(0,0,255);
	m_HoverColor = RGB(255,0,0);
}

void CHyperTextCtrl::LoadHandCursor() 
{
	EMULE_TRY

	CString windir; 
	GetWindowsDirectory(windir.GetBuffer(MAX_PATH), MAX_PATH);
	windir.ReleaseBuffer();
	windir += _T("\\winhlp32.exe");
	HMODULE hModule = LoadLibrary(windir);
	ASSERT( m_LinkCursor == NULL );
	if (hModule)
	{
		HCURSOR hTempCursor = ::LoadCursor(hModule, MAKEINTRESOURCE(106));
		if (hTempCursor)
		{
			m_LinkCursor = CopyCursor(hTempCursor);
			VERIFY( DestroyCursor(hTempCursor) );
		}
		FreeLibrary(hModule);
	}

	if (m_LinkCursor == NULL)
		//this shouldn't happen... but just in case
		m_LinkCursor = LoadCursor(NULL,IDC_ARROW);

	EMULE_CATCH
}
@


1.15
log
@Formatting + minor changes
@
text
@@


1.14
log
@some fixes/changes
@
text
@d43 2
a44 1
CHyperLink::CHyperLink(int iBegin, uint16 iEnd, const CString& sTitle, const CString& sCommand, const CString& sDirectory){
d58 2
a59 1
CHyperLink::CHyperLink(int iBegin, uint16 iEnd, const CString& sTitle, HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam){
d69 2
a70 1
 CHyperLink::CHyperLink(){  // [i_a] 
d82 2
a83 1
CHyperLink::CHyperLink(const CHyperLink& Src){
d113 2
a114 1
CKeyWord::CKeyWord(int iBegin, uint16 iEnd, COLORREF icolor){
d557 2
a558 1
CPreparedHyperText::CPreparedHyperText(const CString& sText){
d578 2
a579 1
void CPreparedHyperText::SetText(const CString& sText){
d592 2
a593 1
	if( len > 60000 ){
d596 2
a597 1
		while( flag == true ){
d599 2
a600 1
			if( !m_Links.empty() ){
d610 2
a611 1
		while( flag == true ){
d613 2
a614 1
			if( !m_KeyWords.empty() ){
d629 2
a630 1
		while( flag == true && !m_Links.empty() ){
d641 2
a642 1
		while( flag == true && !m_KeyWords.empty() ){
d677 2
a678 1
	if( len > 60000 ){
d681 2
a682 1
		while( flag == true ){
d684 2
a685 1
			if( !m_Links.empty() ){
d695 2
a696 1
		while( flag == true ){
d698 2
a699 1
			if( !m_KeyWords.empty() ){
d714 2
a715 1
		while( flag == true && !m_Links.empty() ){
d726 2
a727 1
		while( flag == true && !m_KeyWords.empty() ){
d754 2
a755 1
	if( len > 60000 ){
d758 2
a759 1
		while( flag == true ){
d761 2
a762 1
			if( !m_Links.empty() ){
d772 2
a773 1
		while( flag == true ){
d775 2
a776 1
			if( !m_KeyWords.empty() ){
d791 2
a792 1
		while( flag == true && !m_Links.empty() ){
d803 2
a804 1
		while( flag == true && !m_KeyWords.empty() ){
d831 2
a832 1
	if( len > 60000 ){
d835 2
a836 1
		while( flag == true ){
d838 2
a839 1
			if( !m_Links.empty() ){
d849 2
a850 1
		while( flag == true ){
d852 2
a853 1
			if( !m_KeyWords.empty() ){
d868 2
a869 1
		while( flag == true && !m_Links.empty() ){
d880 2
a881 1
		while( flag == true && !m_KeyWords.empty() ){
d900 2
a901 1
 CLinePartInfo::CLinePartInfo(int iBegin, uint16 iEnd, CHyperLink* pHyperLink, CKeyWord* pKeyWord){
d908 2
a909 1
 CLinePartInfo::CLinePartInfo(const CLinePartInfo& Src){
d919 2
a920 1
 CLineInfo::CLineInfo(int iBegin, uint16 iEnd){
d925 2
a926 1
 CLineInfo::CLineInfo(const CLineInfo& Src){
d934 1
a934 1
 CVisPart::CVisPart(const CLinePartInfo& LinePartInfo, const CRect& rcBounds, int iRealBegin, uint16 iRealLen,CVisPart* pPrev,CVisPart* pNext) : CLinePartInfo(LinePartInfo)
d943 2
a944 1
 CVisPart::CVisPart(const CVisPart& Src) : CLinePartInfo(Src){
d1003 4
a1006 2
LRESULT CHyperTextCtrl::OnDestroy(WPARAM wParam, LPARAM lParam){
	if (m_LinkCursor){
d1015 2
a1016 1
LRESULT CHyperTextCtrl::OnCreate(WPARAM wParam, LPARAM lParam){  
d1063 2
a1064 1
	for(std::vector<CVisLine>::iterator it = m_VisLines.begin(); it != m_VisLines.end(); it++){
d1067 2
a1068 1
		for(CVisLine::iterator jt = it->begin(); jt != it->end(); jt++){
d1073 4
a1076 2
			else{
				if(m_pActivePart != NULL && m_pActivePart->m_pHyperLink == jt->m_pHyperLink){
d1080 2
a1081 1
				else{
d1117 2
a1118 1
LRESULT CHyperTextCtrl::OnSize(WPARAM wParam, LPARAM lParam){
d1127 2
a1128 1
LRESULT CHyperTextCtrl::OnShowWindow(WPARAM wParam, LPARAM lParam){
d1162 2
a1163 1
LRESULT CHyperTextCtrl::OnSetFont(WPARAM wParam, LPARAM lParam){
d1170 2
a1171 1
LRESULT CHyperTextCtrl::OnGetFont(WPARAM wParam, LPARAM lParam){
d1342 2
a1343 1
		if(i < m_VisLines.size()){
d1401 2
a1402 1
LRESULT CHyperTextCtrl::OnCaptureChanged(WPARAM wParam, LPARAM lParam){    
d1407 2
a1408 1
BOOL CHyperTextCtrl::OnEraseBkgnd(CDC* pDC){
d1413 2
a1414 1
CPreparedHyperText* CHyperTextCtrl::GetHyperText(){
d1471 2
a1472 1
void CHyperTextCtrl::SetLinkColor(COLORREF LinkColor, bool bInvalidate){
d1574 6
a1579 3
			for (int i = pl.Begin(); i < pl.End(); i++){
				if (it != m_Text->GetLinks().end() && i >= it->Begin() && it->End() > i){ // i_a 
					if (i > pl.m_xBegin){
d1584 2
a1585 1
					if (it->End() > pl.End()){
d1591 2
a1592 1
					else{
d1601 4
a1604 2
				else if (ht != m_Text->GetKeywords().end() && i >= ht->Begin() && ht->End() > i){ // i_a 
					if (i > pl.m_xBegin){
d1608 2
a1609 1
					if (ht->End() > pl.End()){
d1615 2
a1616 1
					else{
d1644 1
a1644 1
			if((m_iLinesHeight + iScrollHeight) > rc.Height()){
a1645 1
			}
d1655 4
a1658 2
	if (check_bits(dwStyle, HTC_AUTO_SCROLL_BARS)){
		if (vscrollneeded){
d1664 2
a1665 1
		else if (!vscrollneeded){
d1918 2
a1919 1
void CHyperTextCtrl::OnSysColorChange() {
d1925 2
a1926 1
void CHyperTextCtrl::SetColors() {
d1945 2
a1946 1
	if (hModule){
d1948 2
a1949 1
		if (hTempCursor){
d1956 1
a1956 1
	if (m_LinkCursor == NULL){
a1958 1
	}
@


1.13
log
@Formatting, comments, and name changes.
@
text
@d980 1
a980 2
	m_fontDefault.CreatePointFont(g_eMuleApp.m_pGlobPrefs->GetFontSize(),g_eMuleApp.m_pGlobPrefs->GetUsedFont());
	m_Font = &m_fontDefault;
d1815 2
@


1.12
log
@Rich Edit control for all logs (from official v0.30c) ;
Fixed bug #0000023 - Mouse wheel in Serverinfo window does not work
@
text
@d649 1
d1099 1
d1127 1
d1178 1
d1187 1
d1237 1
d1246 1
d1284 1
d1307 1
d1314 1
d1342 1
d1366 1
d1372 1
d1379 1
d1382 1
d1389 1
d1392 1
d1399 1
d1402 1
d1409 1
d1412 1
d1425 1
d1638 1
d1645 1
d1660 1
d1667 1
d1783 1
d1790 1
a1816 1
	SetCursor(m_LinkCursor);
d1823 1
d1845 1
d1867 1
d1887 1
@


1.11
log
@an incorrect use of GDI resources (CBrush class)
@
text
@a648 1

d925 1
d933 1
a933 1
	ON_MESSAGE(WM_MOUSELEAVE, OnCaptureChanged)
a935 1
	ON_WM_DESTROY()
d938 1
a938 1
CHyperTextCtrl::~CHyperTextCtrl()
d940 26
a965 4
	if ( m_LinkCursor )
	{
		DestroyCursor(m_LinkCursor);
		m_LinkCursor	=	NULL;
d967 3
a971 1
//message handlers
d973 1
a973 1
	LPCREATESTRUCT lpCreateStruct = (LPCREATESTRUCT)lParam;
d982 1
a982 1
	m_LinkCursor = LoadHandCursor();
a1097 1

d1119 1
a1119 1
	return (LRESULT)m_Font;
a1124 1

a1174 1

a1182 1

a1231 1

d1240 3
a1242 3

	static TRACKMOUSEEVENT trackmouseevent = {sizeof(TRACKMOUSEEVENT),TME_LEAVE,m_hWnd,0};
	if(m_iLineHeight)
d1256 2
d1263 1
d1265 2
a1266 8
		else
		{
			if(!tracked)
			{
				_TrackMouseEvent(&trackmouseevent);
				tracked=true;
			}
			SetCursor(m_LinkCursor);
d1269 2
a1270 3

	//m_tip.OnMouseMove(nFlags,pt);

a1276 1

a1298 1

a1304 1

a1331 1

a1339 1
	tracked=false;
a1354 1

a1359 1

a1365 1

a1367 1

a1373 1

a1375 1

a1381 1

a1383 1

a1389 1

a1391 1

a1403 1

a1615 1

a1621 1

a1635 1

a1641 1

a1756 1

a1762 1

d1789 1
a1795 1

a1816 1

d1835 1
a1835 1
HCURSOR CHyperTextCtrl::LoadHandCursor() 
a1837 2
	HCURSOR hHandCursor;

d1843 7
a1849 4
	HCURSOR hTempCursor;
	if (hModule && (hTempCursor = ::LoadCursor(hModule, MAKEINTRESOURCE(106)))) {
		hHandCursor = (HCURSOR)CopyImage(hTempCursor,IMAGE_CURSOR,0,0,LR_COPYDELETEORG);
		//DestroyCursor(hTempCursor);
d1851 3
a1853 1
	} else {
d1855 1
a1855 1
		hHandCursor = LoadCursor(NULL,IDC_ARROW);
a1856 2

	return hHandCursor;
a1857 1
	return NULL;
a1858 9
void CHyperTextCtrl::OnDestroy()
{
	CWnd::OnDestroy();
	if ( m_LinkCursor )
	{
		DestroyCursor(m_LinkCursor);
		m_LinkCursor	=	NULL;
	}
}@


1.10
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d994 1
d1040 1
@


1.9
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d956 2
a957 2
	m_DefaultFont.CreatePointFont(theApp.glob_prefs->GetFontSize(),theApp.glob_prefs->GetUsedFont());
	m_Font = &m_DefaultFont;
@


1.8
log
@minor fixes and improvements
@
text
@d1348 1
a1348 1
		m_Text = &standart_Text;
@


1.7
log
@Fixed bug #29
@
text
@a1418 1
	int w = rc.Width();
a1599 1
		int i = m_Text->GetText().GetLength();
@


1.6
log
@*** empty log message ***
@
text
@d933 1
a933 1
	ON_MESSAGE(WM_CAPTURECHANGED, OnCaptureChanged)
d1221 2
a1222 3
	CRect rcClient;
	GetClientRect(rcClient);
	if(PtInRect(rcClient, pt) && m_iLineHeight)
a1224 3
		if(GetCapture() != this)
			SetCapture();

d1242 9
d1252 1
a1252 2
	else
		ReleaseCapture();
d1328 1
a1796 2
	SetCursor(m_LinkCursor);

d1876 1
a1876 1
}
@


1.5
log
@Code clean up and double check wit official code.
@
text
@d936 1
d939 9
d1853 2
a1854 1
		hHandCursor = CopyCursor(hTempCursor);
d1864 10
a1873 1
}@


1.4
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@a35 1

a40 1

@


1.3
log
@bugfixes & control panel updates
@
text
@d36 8
@


1.2
log
@port to .25 b codebase...
@
text
@d940 1
a940 1
	m_DefaultFont.CreatePointFont(80,theApp.glob_prefs->GetUsedFont());
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.2.2.2
log
@updated control panes, and assorted bugfixes
@
text
@d940 1
a940 1
	m_DefaultFont.CreatePointFont(theApp.glob_prefs->GetFontSize(),theApp.glob_prefs->GetUsedFont());
@


1.1
log
@*** empty log message ***
@
text
@a88 1

a98 1

a112 1

a515 1

a521 1

a542 1

a552 1

a554 1

a560 1

a562 1

a573 1

a649 1

a713 1

a719 1

a783 1

a789 1

a853 1

a959 1

a1023 1

a1024 1

a1045 1

a1827 1

a1844 1

a1845 1

@

