head	1.3;
access;
symbols
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	Interim_Release_1n_beta2:1.2
	Interim_Release_1n_beta1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.4
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.2
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1;
locks; strict;
comment	@ * @;


1.3
date	2006.01.09.00.32.38;	author aw3;	state dead;
branches;
next	1.2;

1.2
date	2003.06.15.09.10.04;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.08.12.09.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Removed unused source files {eklmn}.
@
text
@////////////////////////////////////////////////////////////////////
// PIDL.h: interface for the CPIDL class.
//

#ifndef __PIDL_H
#define __PIDL_H

#include <shlobj.h>

class CPIDL
{
public:
    LPITEMIDLIST  m_pidl;

// == Construction/Destruction == //

    CPIDL() : m_pidl(NULL) {}

    // Copy constructor
    CPIDL(const CPIDL& cpidl) : m_pidl(NULL) { Set(cpidl); }

    // From path (szPath relative to the folder psf) - see Set()
    CPIDL(LPCTSTR szPath, LPSHELLFOLDER psf = m_sfDesktop);

    // From a list ptr - *doesn't* copy the actual data - see Set()
    CPIDL(LPITEMIDLIST pidl) : m_pidl(pidl) {}

    virtual ~CPIDL();


// == Assignment == //

    // Make a copy of cpidl's list data
    HRESULT Set(const CPIDL& cpidl);

    // Set by path: szPath relative to the folder psf.
    HRESULT Set(LPCTSTR szPath, LPSHELLFOLDER psf = m_sfDesktop);

    // Points the CPIDL to an existing item list: does *not* copy
    // the actual data - just the pointer (unlike MakeCopyOf()).
    HRESULT Set(LPITEMIDLIST pidl);

    // Special Assignment: Copies the data of an exisiting list.
    HRESULT MakeCopyOf(LPITEMIDLIST pidl);

    // Special Assignment: Makes a PIDL rooted at the desktop.
    HRESULT MakeAbsPIDLOf(LPSHELLFOLDER psf, LPITEMIDLIST pidl);


// == Item Access == //

    // Returns a pointer to the first item in the list
    LPSHITEMID GetFirstItemID() const { return (LPSHITEMID)m_pidl; }

    // Points to the next item in the list
    void GetNextItemID(LPSHITEMID& pid) const 
        { (LPBYTE &)pid += pid->cb; }


// == General Operations == //

    void Free();          // Frees the memory used by the item id list
    UINT GetSize() const; // Counts the actual memory in use

    // Split into direct parent and object pidls
    void Split(CPIDL& parent, CPIDL& obj) const;

    // Concatenation
    CPIDL operator + (CPIDL& pidl) const;  // using + operator
    static void Concat(const CPIDL &a, const CPIDL& b, 
        CPIDL& result);                    // result = a+b (faster)


// == Shell Name-space Access Helper Functions == //

    // 1) Won't always work: psf->GetUIObjectOf(pidl, ... )
    // 2) Will always work:  pidl.GetUIObjectOf(..., psf)
    HRESULT GetUIObjectOf(REFIID riid, LPVOID *ppvOut, 
        HWND hWnd = NULL, LPSHELLFOLDER psf = m_sfDesktop);

    // Places the STRRET string in the cStr field.  
    void ExtractCStr(STRRET& strRet) const;


// == Conversion Operators == //

    operator LPITEMIDLIST&  () { return m_pidl; }
    operator LPITEMIDLIST * () { return &m_pidl; }
    operator LPCITEMIDLIST  () const { return m_pidl; }
    operator LPCITEMIDLIST* () const 
        { return (LPCITEMIDLIST *)&m_pidl; }

protected:
    static LPSHELLFOLDER    m_sfDesktop;    // desktop object
    static LPMALLOC         m_pAllocator;   // system allocator

    // allocate memory for the pidl using the system allocator
    void AllocMem(int iAllocSize);

    // initializer (used for automatic initialization)
    static struct pidl_initializer {
        pidl_initializer();
        ~pidl_initializer();
    } m_initializer;
    friend struct pidl_initializer;
};

#endif  // __PIDL_H
@


1.2
log
@unicode cleanup
@
text
@@


1.1
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d23 1
a23 1
    CPIDL(LPCSTR szPath, LPSHELLFOLDER psf = m_sfDesktop);
d37 1
a37 1
    HRESULT Set(LPCSTR szPath, LPSHELLFOLDER psf = m_sfDesktop);
@

