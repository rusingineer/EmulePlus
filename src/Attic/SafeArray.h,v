head	1.8;
access;
symbols
	PublicRelease_1_1f:1.7
	Interim_Release_1-1f_RC1:1.7
	PublicRelease_1_1e:1.7
	Interim_Release_1-1e_RC2:1.7
	Interim_Release_1-1e_RC1:1.7
	Interim_Release_1-1e_beta1:1.7
	PublicRelease_1_1d:1.7
	Interim_Release_1-1d_RC1:1.7
	PublicRelease_1_1c:1.7
	Interim_Release_1-1c_RC1:1.7
	Interim_Release_1-1c_beta2:1.7
	Interim_Release_1-1c_beta1:1.7
	PublicRelease_1_1b:1.7
	Interim_Release_1-1b_RC1:1.7
	PublicRelease_1_1a:1.7
	Interim_Release_1-1a_RC2:1.7
	Interim_Release_1-1a_RC1:1.7
	Interim_Release_1-1a_beta2:1.7
	Interim_Release_1-1a_beta1:1.7
	PublicRelease_1_1:1.7
	Interim_Release_1-1_beta1:1.7
	PublicRelease_1o:1.7
	Interim_Release_1o_RC1:1.7
	Interim_Release_1o_beta1:1.7
	PublicRelease_1n:1.7
	Interim_Release_1n_RC2:1.7
	Interim_Release_1n_RC1:1.7
	Interim_Release_1n_beta2:1.7
	Interim_Release_1n_beta1:1.7
	PublicRelease_1m:1.7
	Interim_Release_1m_beta1:1.7
	PublicRelease_1l:1.7
	Interim_Release_1l_RC3:1.7
	Interim_Release_1l_RC2:1.7
	Interim_Release_1l_RC1:1.7
	Interim_Release_1l_beta2:1.7
	Interim_Release_1l_beta1:1.7
	PublicRelease_1k:1.6
	Interim_Release_1k_RC4:1.6
	Interim_1k_RC3:1.6
	Interim_1k_RC2:1.6
	Interim_Release_1k_RC1:1.6
	Interim_Release_1k_beta5:1.6
	Intrerim_Release_1k_beta4:1.6
	Interim_Release_1k_beta1:1.6
	PublicRelease_1j:1.6
	Interim_Release_1J_RC3:1.6
	Interim_Release_1j_RC3:1.6
	Interim_Release_1j_RC2:1.6
	Interim_Release_1j_RC1:1.6
	Interim_Release_1j_beta2:1.6
	Interim_Release_1j_beta1:1.6
	PublicRelease_1i:1.6
	Interim_Release_1i_RC6:1.6
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.6
	Interim_Release_1i_beta3:1.6
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.6
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.5
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.5
	Interim_Release_1h_beta1:1.5
	PublicRelease_1g:1.5
	Interim_Release_1g_RC6_Final:1.5
	Interim_Release_1g_RC6:1.5
	Interim_Release_1g_RC5:1.5
	Interim_Release_1g_RC4:1.5
	Interim_Release_1g_RC3:1.5
	Interim_Release_1g_beta2:1.4
	Interim_Release_1g_beta1:1.4
	Interim_Release_1f_RC4:1.4
	Interim_Release_1f_RC3:1.4
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.1;
locks; strict;
comment	@ * @;


1.8
date	2005.08.03.01.03.54;	author aw3;	state dead;
branches;
next	1.7;

1.7
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.15.22.22.29;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.17.18.37.08;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.15.17.56.29;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.11.19.25.47;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.10.15.06.13;	author lord_kiron;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Removed unused SafeArray stuff.
@
text
@#pragma once

#include <afxmt.h>
#include <search.h>
#include "otherfunctions.h"

// This template for safe multithreading self-grow array
//
// To makes this template work correctly it requares that
// operator= will be defined in <T> type class or <T> will
// be one of the basic classes (like int , long and so)
// Also please notice that this array is more like a list :) 
// you have first to "add" element to make the "slot" available 
// so please use GetCount() instead of GetSize() to get number of 
// position evailable to you for insertion
//
// By [Lord KiRon]
// You can use this code for eny use you see fit 
// Just don't blame me if you find the bug :) , no responsibility taken :)
// If you perform any major functionality change to this code , please 
// remove any refference to my nick , I wan't be responsable for your bugs either :)
// 

template <class T> class CSafeArray
{
// protected data members 
protected:
	INT_PTR	m_nSize;				// Size of the Array allocated
	CMutex	m_ExternalAccessMutex;  // Access control mutex
	T*		m_pArrayData;			// Pointer to the data stored
	INT_PTR	m_nCount;				// Count of elements in array
	INT_PTR	m_nGrowSize;			// Size top grow by
	friend T;
// private functions
private:
	// Grows array 
	BOOL GrowArray()
	{
		return ReallocateArray(m_nSize+m_nGrowSize);
	}
	// Reallocates new array to new size
	BOOL ReallocateArray(INT_PTR nNewSize)
	{
		if ( nNewSize < m_nSize )
		{
			ASSERT(FALSE);	// New size can't be smaller then old one
			return FALSE;
		}

		// if new size is the same as old size
		if (  nNewSize == m_nSize )
		{
			// do nothing
			return TRUE;
		}

		// allocate memory for new array
		T*	pTempArray	=	new	T[nNewSize];
		// if allocation failed
		if (!pTempArray)
		{
			ASSERT(FALSE);	// memory was not allocated
			return FALSE;
		}
		// Copy data from the old array to new one
		memcpy2(pTempArray,m_pArrayData,sizeof(T)*m_nSize);
		// release the old array memory , we doi not need it anymore
		delete []m_pArrayData;
		m_pArrayData	=	pTempArray;
		m_nSize	=	nNewSize;
		pTempArray		=	NULL; // just to "play safe"
		return TRUE;
	}

	// Allocates memory for new array (at start)
	BOOL AllocateNewArray()
	{
		ASSERT(!m_pArrayData);				// if you got here then your array pointer is not NULL
		m_pArrayData	=	new T[m_nSize];	// allocate array
		if ( !m_pArrayData)
		{
			ASSERT(m_pArrayData); // unable to allocate needed amount of memory
			m_nSize	=	0;
			return FALSE;
		}
		return TRUE;
	}

	// Default Compare function
	// will work only if relations < , > , == defined in class <T>
	static int __cdecl DefCompare(const void* pItem1, const void* pItem2)
	{

		if ( *((T*)pItem1) > *((T*)pItem2) )
		{
			return 1;
		}
		if ( *((T*)pItem1) < *((T*)pItem2) )
		{
			return -1;
		}
		return 0;
	}
public:
	// Empty constructor
	CSafeArray()
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		m_pArrayData	=	NULL;
		m_nCount		=	0;		// no elements allocated
		m_nSize			=	100;	// default allocate array size
		m_nGrowSize		=	50;		// default grow size
		AllocateNewArray();
	}

	// Constructor with size
	CSafeArray(INT_PTR nStartSize)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		m_pArrayData	=	NULL;
		m_nCount		=	0;			// no elements allocated
		m_nSize			=	nStartSize;	// default allocate array size
		m_nGrowSize		=	50;			// default grow size
		AllocateNewArray();
	}

	// Constructor with size
	CSafeArray(INT_PTR nStartSize,INT_PTR nGrowSize)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		m_pArrayData	=	NULL;
		m_nCount		=	0;			// no elements allocated
		m_nSize			=	nStartSize;	// default allocate array size
		m_nGrowSize		=	nGrowSize;		// default grow size
		AllocateNewArray();
	}

	// Destructor
	~CSafeArray()
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		if ( m_pArrayData )
		{
			delete []m_pArrayData;
			m_pArrayData	=	NULL; // just to be on the safe side :)
		}
	}

// Attributes

	// Returns number of "real" elements in array
	INT_PTR GetCount( ) 
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		return m_nCount;
	}

	// Returns current array size
	INT_PTR GetSize( ) 
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		return m_nSize;
	}

	// Determines wether array is empty 
	BOOL IsEmpty( ) 
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		return (BOOL)!m_nCount;
	}

	// Returns the current upper bound of this array
	// Because array indexes are zero-based, this function returns a value 1 less than GetSize
	INT_PTR GetUpperBound( ) 
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		return m_nSize	-	1;
	}

	void SetSize(INT_PTR nNewSize,INT_PTR nGrowBy = -1)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// filter out invalid arguments
		if ( nNewSize < 0 || nGrowBy < -1 || nGrowBy == 0)
		{
			ASSERT(FALSE);	// Invalid size or grow size requested
			return;
		}

		if ( nNewSize <= m_nSize && !m_nCount )
		{
			ASSERT(FALSE); // unlike CArray we allow only size greate then "nSize" to be set unless no elements added
			return;
		}
		
		// If we need to change GrowSize
		if ( nGrowBy != -1 )
		{
			m_nGrowSize	=	nGrowBy;
		}
		ReallocateArray(nNewSize);
	}

	// Checks if element index is valid
	BOOL IsValidIndex(INT_PTR nIndex)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		if ( nIndex < 0 || /* nIndex > m_nSize ||*/ nIndex > m_nCount)
		{
			return FALSE; //invalid range
		}
		return TRUE;
	}
// Operations

	// Removes all the elements from this array
	void RemoveAll( )
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		m_nCount	=	0;
	}

	// Frees any extra memory that was allocated while the array was grown
	void FreeExtra()
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		if ( m_nCount < m_nSize )
		{
			// allocate memory for new array
			T*	pTempArray	=	new	T[m_nCount==0?1:m_nCount];
			// if allocation failed
			if (!pTempArray)
			{
				ASSERT(FALSE);	// memory was not allocated
				return ;
			}
			memcpy2(pTempArray,m_pArrayData,sizeof(T)*m_nCount);
			delete []m_pArrayData;
			m_pArrayData	=	pTempArray;
			m_nSize	=	m_nCount==0?1:m_nCount;
			pTempArray		=	NULL; // just to "play safe"
		}
	}

// Element Accesses
	// Returns element at nIndex (0 based)
	T& ElementAt(INT_PTR nIndex )
	{	
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// check for valid range
		if ( nIndex < 0 || nIndex > m_nCount)
		{
			ASSERT(FALSE); //invalid range
		}
		return m_pArrayData[nIndex];
	}

	// Returns element at nIndex (0 based)
	const T& ElementAt(INT_PTR nIndex ) const
	{	
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// check for valid range
		if ( nIndex < 0 || nIndex > m_nCount)
		{
			ASSERT(FALSE); //invalid range
		}
		return m_pArrayData[nIndex];
	}

	// Returns element at nIndex (0 based)
	T& GetAt(INT_PTR nIndex )
	{
		return ElementAt(nIndex);
	}

	// Returns element at nIndex (0 based)
	const T& GetAt(INT_PTR nIndex ) const
	{
		return ElementAt(nIndex);
	}

	// Returns direct pointer to element at nIndex (0 based)
	// WARNING pointer returned makes code not thread safe and should not be
	// used , provedet for "compatibility" with CArray only
	T* GetData(INT_PTR nIndex )
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// check for valid range
		if ( nIndex < 0 || nIndex > m_nCount)
		{
			ASSERT(FALSE); //invalid range
			return NULL;
		}
		return &(m_pArrayData[nIndex]);
	}

	// Returns direct pointer to element at nIndex (0 based)
	// WARNING pointer returned makes code not thread safe and should not be
	// used , provedet for "compatibility" with CArray only
	const T* GetData(INT_PTR nIndex ) const
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// check for valid range
		if ( nIndex < 0 || nIndex > m_nCount)
		{
			ASSERT(FALSE); //invalid range
			return NULL;
		}
		return &(m_pArrayData[nIndex]);
	}

	// Set new value for the element
	// SetAt will not cause the array to grow, Use SetAtGrow if you want the array to grow automatically
	// also it will not set beyound number of elements set , we do not support "holes"
	void SetAt(INT_PTR nIndex,T NewValue)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// check for valid range
		if ( nIndex < 0 || nIndex > m_nCount )
		{
			ASSERT(FALSE); //invalid range
			return;
		}
		m_pArrayData[nIndex]	=	NewValue;
	}

// Growing the Array

	// Add ne element to array , returns new index ,  -1 in case of failure
	INT_PTR Add(T tNewElement)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		// check if we need to grow
		if ( m_nCount+1 >= m_nSize )
		{
			// try to grow
			if ( !GrowArray() )
			{
				// if failed to grow return -1
				return -1;
			}
		}
		// assign new element
		m_pArrayData[m_nCount]	=	tNewElement;
		// increment element count
		m_nCount++;
		// return new element index
		return (m_nCount-1);
	}

	// Call this member function to add the contents of one array to the end of another.
	// returns index of the first appended element
	INT_PTR Append(const CSafeArray<T>& src)
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		// if size of the new array will not fit into old one
		if ( src.m_nCount > m_nSize - m_nCount )
		{
			// allocate memory sufficient to hold new array data too
			INT_PTR	nNewSize	=	m_nCount + src.m_nCount +1;
			ReallocateArray(nNewSize);
		}
		// copy the new data 
		memcpy2(m_pArrayData+m_nCount,src.m_pArrayData,sizeof(T)* src.m_nCount);
		INT_PTR	nOldCount	=	m_nCount;
		m_nCount	+=	src.m_nCount;
		return m_nCount;
	}

	// Call this member function to overwrite the elements of one array with the elements of another array
	void Copy(const CSafeArray<T>& src )
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		if ( src.m_nCount >  m_nCount )
		{
			ReallocateArray(src.m_nCount);
		}
		memcpy2(m_pArrayData,src.m_pArrayData,sizeof(T)* src.m_nCount);
	}

	// Sets the array element at the specified index.
	// The array grows automatically if necessary 
	void SetAtGrow(INT_PTR nIndex,T newElement)
	{
		if ( nIndex >= m_nSize )
		{
			ReallocateArray(nIndex+1);
		}
		SetAt(nIndex,newElement);
	}

// Insertion/Removal

	// InsertAt inserts one element (or multiple copies of an element) at a specified index in an array
	// we insert only after up to m_nCount elements , no "holes" allowed
	void InsertAt(INT_PTR nIndex,T newElement,INT_PTR nCount = 1)
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		if ( nIndex < 0 || nCount < 1 || nIndex > m_nCount+1)
		{
			ASSERT(FALSE); // Invalid input
			return;
		}
		// first we have to make sure the new insertion fits
		if ( m_nCount + 1  >=  m_nSize )
		{
			ReallocateArray(m_nCount + nCount);
		}

		// Special case when adding at the end of the array
		if ( nIndex == m_nCount )
		{
			for ( INT_PTR i= 0; i < nCount ; i++ )
			{
				m_pArrayData[nIndex+i]	=	newElement;
			}
			m_nCount	=	m_nCount	+	nCount;
		}
		// when inserting in the middle of the array
		else
		{
			INT_PTR	nTempSize	=	m_nCount-nIndex;
			T *pTempArray	=	new T[nTempSize];
			if ( !pTempArray )
			{
				ASSERT(FALSE); // allocation failed
				return;
			}
			// Copy out the data after Index of insertion
			memcpy2(pTempArray,m_pArrayData+nIndex,sizeof(T)*nTempSize);
			// Set new data
			for ( INT_PTR i= 0; i < nCount ; i++ )
			{
				m_pArrayData[nIndex+i]	=	newElement;
			}
			// Set old data back after insertion point
			memcpy2(m_pArrayData+nIndex+nCount,pTempArray,sizeof(T)*nTempSize);
			m_nCount	=	m_nCount	+	nCount;
			delete []pTempArray;
		}
		
	}


	// InsertAt inserts array at a specified index in an array
	// we insert only after up to m_nCount elements , no "holes" allowed
	void InsertAt(INT_PTR nStartIndex,CSafeArray<T>* pNewArray)
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		CSingleLock CAccessLock2(&(pNewArray->m_ExternalAccessMutex),TRUE);
		if ( nStartIndex < 0 || pNewArray->m_nCount < 1 || nStartIndex > m_nCount+1)
		{
			ASSERT(FALSE); // Invalid input
			return;
		}
		// first we have to make sure the new insertion fits
		if ( m_nCount + pNewArray->m_nCount  >=  m_nSize )
		{
			ReallocateArray(m_nCount + pNewArray->m_nCount+1);
		}
		if ( nStartIndex == m_nCount )
		{
			for ( INT_PTR i= 0; i < pNewArray->m_nCount ; i++ )
			{
				m_pArrayData[nStartIndex+i]	=	pNewArray->m_pArrayData[i];
			}
			m_nCount	=	nStartIndex	+	pNewArray->m_nCount;
		}
		// when inserting in the middle of the array
		else
		{
			T *pTempArray	=	new T[m_nCount-nStartIndex];
			if ( !pTempArray )
			{
				ASSERT(FALSE); // allocation failed
				return;
			}
			// Copy out the data after Index of insertion
			memcpy2(pTempArray,m_pArrayData+nStartIndex,sizeof(T)*(m_nCount-nStartIndex));
			// Set new data
			for ( INT_PTR i= 0; i < pNewArray->m_nCount ; i++ )
			{
				m_pArrayData[nStartIndex+i]	=	pNewArray->m_pArrayData[i];
			}
			// Set old data back after insertion point
			memcpy2(m_pArrayData+nStartIndex+pNewArray->m_nCount,pTempArray,sizeof(T)*(m_nCount-nStartIndex));
			m_nCount	=	nStartIndex	+	pNewArray->m_nCount;
			delete []pTempArray;
		}
	}


	// Removes one or more elements starting at a specified index in an array
	void RemoveAt(INT_PTR nIndex,INT_PTR nCount = 1)
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		if ( nIndex < 0 || nIndex > m_nCount || nCount < 1 )
		{
			ASSERT(FALSE); // invalid parameters
			return;
		}

		// If nCount is too large
		if ( nIndex + nCount >= m_nCount )
		{
			nCount	=	m_nCount	-	nIndex;
		}
		
		// if we just need to remove last elements
		if ( nIndex+nCount	==	m_nCount )
		{
			// just mark that count starts earlier
			m_nCount	=	nIndex;
		}
		// if we meed to remove from the middle of the array
		else
		{
			T *pTempArray	=	new T[m_nCount-(nIndex+nCount)];
			if ( !pTempArray )
			{
				ASSERT(FALSE); // allocation failed
				return;
			}
			// Copy out the data after Index of removal + size of removal
			memcpy2(pTempArray,m_pArrayData+nIndex+nCount,sizeof(T)*(m_nCount-(nIndex+nCount)));
			memcpy2(m_pArrayData+nIndex,pTempArray,sizeof(T)*(m_nCount-(nIndex+nCount)));
			m_nCount	=	m_nCount	-	nCount;
			delete []pTempArray;
		}
	}

// operators 

	// operator [] These subscript operators are a convenient substitute for the SetAt and GetAt functions
	T& operator[](INT_PTR nIndex )
	{
		return ElementAt(nIndex);
	}


// Sort and find functions

	// Sort element of the array using quick sort 
	// and user supplyed compare function
	void Sort( SortFunction pCF = NULL )
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		// If compare function provided
		if ( pCF )
		{
			qsort(m_pArrayData,m_nCount,sizeof(T),pCF);
		}
		// if compare function not provided , make sure that relations in class T
		// are well defined , otherwise compiler will give an error
		else
		{
			qsort(m_pArrayData,m_nCount,sizeof(T),DefCompare);
		}
	}

	// Find "nCount" ocurence of the element in the array , returning it's index 
	// if element is not in the array , returns -1
	// since we can't assume array is sorted we use linear search 
	INT_PTR FindIndex(T ElementToFind,INT_PTR nCount = 1,int (__cdecl *pCF )(const void *, const void *) = NULL )
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		void *Result	=	(void*)m_pArrayData;
		// iterate until we reach "nCount" occurance of the element or no mor elements found
		for ( INT_PTR i	= 0; i < nCount  ; i++ )
		{
			// Calculate the size of the array we have left to search
        	//japg2000: BUGFIX: if we deduct -1 then the function doesnt find the last element
        	//UINT uSizeLeft = UINT(m_nCount - ((T*)Result - m_pArrayData) -1);
        	UINT uSizeLeft = UINT(m_nCount - ((T*)Result - m_pArrayData));
			// If compare function provided
			if ( pCF )
			{
				Result	=	_lfind(&ElementToFind,Result,&uSizeLeft,sizeof(T),pCF);
			}
			// if no compare function , use default , relations has to be defined in class T
			else
			{
				Result	=	_lfind(&ElementToFind,Result,&uSizeLeft,sizeof(T),DefCompare);
			}
			// if item not found - break the loop
			if ( !Result )
			{
				break;
			}
			// if result found 
			else
			{
				// we need to advance the result to sizeof(T) to skip the found element
				// but we can't do so with void* , so we use this "trick"
				T* pTemp	=	(T*)Result;
				pTemp++;
				Result	=	(void*)pTemp;
			}
		}
		
		if ( Result )
		{
			// search returns pointer to element , we need to get index
			//japg2000: BUGFIX: Result was advanced before, so we need to deduct 1
			//return (INT_PTR)((T*)Result - m_pArrayData);
        	return (INT_PTR)((T*)Result - m_pArrayData) -1; 
		}
		// nothing found
		return -1;
	}

	void operator= (CSafeArray<T> &source)
	{
		CSingleLock CAccessLock(&m_ExternalAccessMutex,TRUE);
		if ( m_pArrayData )
		{
			delete []m_pArrayData;
			m_pArrayData	=	NULL; // just to be on the safe side :)
		}
		m_nSize	=	source.m_nSize;
		AllocateNewArray();
		memcpy2(m_pArrayData,source.m_pArrayData,sizeof(T)*m_nSize);
		m_nCount	=	source.m_nCount;
		m_nGrowSize =   source.m_nGrowSize;
	}
};



template <class T> class CSafeArraySorted : public CSafeArray<T>
{
protected:
	SortFunction	m_pSortFunction;	
public:

	// constructor , sets sort function right away
	CSafeArraySorted(SortFunction pSortFunction = NULL)
		:CSafeArray<T>()
	{
		m_pSortFunction	=	pSortFunction;
	}


	CSafeArraySorted(INT_PTR nStartSize,SortFunction pSortFunction = NULL)
		:CSafeArray<T>(nStartSize)
	{
		m_pSortFunction	=	pSortFunction;
	}

	CSafeArraySorted(INT_PTR nStartSize,INT_PTR nGrowSize,SortFunction pSortFunction = NULL)
		:CSafeArray<T>(nStartSize,nGrowSize)
	{
		m_pSortFunction	=	pSortFunction;
	}

	void SetSortFunction(SortFunction pSortFunction)
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		m_pSortFunction	=	pSortFunction;

	}

	SortFunction GetSortFuncion()
	{
		CSingleLock CAccessLock1(&m_ExternalAccessMutex,TRUE);
		return m_pSortFunction;
	}
	
	void Sort( SortFunction pCF = NULL )
	{
		m_pSortFunction	=	pCF;
		__super::Sort(pCF);
	}

	void operator= (CSafeArraySorted<T> &source)
	{
		__super::operator =(CSafeArray<T>)source;
		m_pSortFunction	=	source.m_pSortFunction;
	}

	// this function inserts new element sorted using provided sort function
	INT_PTR Add(T tNewElement)
	{
		// if it's first element or we have no sort function
		if (!m_nCount || !m_pSortFunction )
		{
			return __super::Add(tNewElement);
		}

		INT_PTR	nStart	=	0;
		INT_PTR	nEnd	=	m_nCount;
		// Here we going to use binary search algoritm to find a place for insertion
		// the algorithm assumes that prev. array already sorted and we only need to find 
		// place for new element
		while(nStart != nEnd)
		{
			INT_PTR nHalf		=	nStart +(nEnd-nStart)/2;
			int iCompareHalf	=	m_pSortFunction(&m_pArrayData[nHalf],&tNewElement);
			// if equal then already in array 
			if ( !iCompareHalf ) // =0 - equal
			{
				nStart	=	nEnd	=	nHalf;
				break;
			}
			// if half is less then new element 
			if (  iCompareHalf < 0  ) // -1
			{
				// start from half
				nStart	=	nHalf+1;
			}
			// if half is greater then new element 
			else if (iCompareHalf > 0 ) //1
			{
				// go to half max
				nEnd	=	nHalf;
			}
		}
		InsertAt(nStart,tNewElement);
		return	nStart;
	}
};
@


1.7
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@@


1.6
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d66 1
a66 1
		::CopyMemory(pTempArray,m_pArrayData,sizeof(T)*m_nSize);
d237 1
a237 1
			::CopyMemory(pTempArray,m_pArrayData,sizeof(T)*m_nCount);
d364 1
a364 1
		::CopyMemory(m_pArrayData+m_nCount,src.m_pArrayData,sizeof(T)* src.m_nCount);
d378 1
a378 1
		::CopyMemory(m_pArrayData,src.m_pArrayData,sizeof(T)* src.m_nCount);
d430 1
a430 1
			::CopyMemory(pTempArray,m_pArrayData+nIndex,sizeof(T)*nTempSize);
d437 1
a437 1
			::CopyMemory(m_pArrayData+nIndex+nCount,pTempArray,sizeof(T)*nTempSize);
d479 1
a479 1
			::CopyMemory(pTempArray,m_pArrayData+nStartIndex,sizeof(T)*(m_nCount-nStartIndex));
d486 1
a486 1
			::CopyMemory(m_pArrayData+nStartIndex+pNewArray->m_nCount,pTempArray,sizeof(T)*(m_nCount-nStartIndex));
d525 2
a526 2
			::CopyMemory(pTempArray,m_pArrayData+nIndex+nCount,sizeof(T)*(m_nCount-(nIndex+nCount)));
			::CopyMemory(m_pArrayData+nIndex,pTempArray,sizeof(T)*(m_nCount-(nIndex+nCount)));
d622 1
a622 1
		::CopyMemory(m_pArrayData,source.m_pArrayData,sizeof(T)*m_nSize);
@


1.5
log
@Added countermeasures for unfair clients and some forum bugfixing
@
text
@d192 1
a192 1
			ASSERT(FALSE); // unlike CArray we allow only size greate then "m_nSize" to be set unless no elements added
@


1.4
log
@Another fix for not used yet code :)
@
text
@a23 2


d572 3
a574 1
			UINT	uSizeLeft	=	UINT(m_nCount - ((T*)Result - m_pArrayData) -1);
d604 3
a606 1
			return (INT_PTR)((T*)Result - m_pArrayData);
@


1.3
log
@small bug fixed in not used (yet) code
@
text
@d5 1
d407 1
a407 1
		if ( nIndex + nCount  >=  m_nSize )
d409 1
a409 1
			ReallocateArray(nIndex + nCount+1);
d419 1
a419 1
			m_nCount	=	nIndex	+	nCount;
d424 2
a425 1
			T *pTempArray	=	new T[m_nCount-nIndex];
d432 1
a432 1
			::CopyMemory(pTempArray,m_pArrayData+nIndex,sizeof(T)*(m_nCount-nIndex));
d439 2
a440 2
			::CopyMemory(m_pArrayData+nIndex+nCount,pTempArray,sizeof(T)*(m_nCount-nIndex));
			m_nCount	=	nIndex	+	nCount;
d459 1
a459 1
		if ( nStartIndex + pNewArray->m_nCount  >=  m_nSize )
d461 1
a461 1
			ReallocateArray(nStartIndex + pNewArray->m_nCount+1);
d547 1
a547 1
	void Sort( int (__cdecl *pCF )(const void *, const void *) = NULL )
d623 95
@


1.2
log
@CServerList moved to use new CSafe array , suppouse to work faster , safer  and to be the step to the virtual list controls .
@
text
@d170 1
a170 1
		return (BOOL)m_nCount;
d608 14
@


1.1
log
@Added quick sortable safe array class template for future use with virtual lists that will be implemented later .
@
text
@d153 1
a153 1
	INT_PTR GetCount( ) const
d160 1
a160 1
	INT_PTR GetSize( ) const
d167 1
a167 1
	BOOL IsEmpty( ) const
d175 1
a175 1
	INT_PTR GetUpperBound( ) const
@

