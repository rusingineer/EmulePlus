head	1.11;
access;
symbols
	Interim_Release_1k_beta1:1.10
	PublicRelease_1j:1.10
	Interim_Release_1J_RC3:1.10
	Interim_Release_1j_RC3:1.10
	Interim_Release_1j_RC2:1.10
	Interim_Release_1j_RC1:1.10
	Interim_Release_1j_beta2:1.10
	Interim_Release_1j_beta1:1.10
	PublicRelease_1i:1.10
	Interim_Release_1i_RC6:1.10
	Interim_Release_1i_RC3:1.10
	Interim_Release_1i_RC2:1.10
	Interim_Release_1i_RC1:1.10
	Interim_Release_1i_beta3:1.10
	Interim_Release_1i_beta2:1.9
	Interim_Release_1i_beta1:1.9
	PublicRelease_1h:1.6
	Interim_Release_1h_rc2:1.6
	Interim_Release_1h_RC1:1.6
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.6
	Interim_Release_1h_beta1:1.6
	PublicRelease_1g:1.6
	Interim_Release_1g_RC6_Final:1.6
	Interim_Release_1g_RC6:1.6
	Interim_Release_1g_RC5:1.6
	Interim_Release_1g_RC4:1.6
	Interim_Release_1g_RC3:1.6
	Interim_Release_1g_beta2:1.5
	Interim_Release_1g_beta1:1.5
	Interim_Release_1f_RC4:1.4
	Interim_Release_1f_RC3:1.4
	Interim_Release_1f_RC2:1.4
	Interim_Release_1f_RC:1.4
	Interim_Release_1f_beta2:1.4
	Interim_Release_1f_beta1:1.4
	PublicRelease_1e:1.4
	Interim_Release_1e_RC2:1.4
	Interim_Release_1e_RC:1.4
	Interim_Release_1e_beta3:1.4
	Interim_Release_1e_beta2:1.4
	Interim_Release_1e_beta2_before_kuchin:1.4
	Interim_Release_1e_beta1:1.4
	PublicRelease_1c:1.4
	featurestest:1.4.0.8
	Interim_Release_1c_RC:1.4
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.6
	PublicRelease_1b:1.4
	Interim_Release_1b_beta2:1.4
	Interim_Release_1b_beta1:1.4
	proxydeadlake:1.4.0.4
	PublicRelease_1a:1.4
	Interim_Release_1a_beta2:1.4
	BerkeleyDb:1.4.0.2
	Interim_Release_1a_beta1:1.4
	PublicRelease_1:1.4
	goldfish:1.4
	eMulePlus_1_RC2:1.3
	eMulePlus_26b_1RC1:1.3
	PreRelease_26b_i0e:1.3
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.11
date	2004.02.26.10.03.19;	author dongato;	state dead;
branches;
next	1.10;

1.10
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.02.22.36.08;	author netwolf1;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.16.04.44.44;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.31.17.14.28;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.20.14.29.00;	author dongato;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.10.19.24.49;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.08;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Fixed localization issues, removed old non-used code
@
text
@//this file is part of eMule
// added by quekky
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

// FileInfoDialog.cpp : implementation file

#include "stdafx.h"
#include "eMule.h"
#include "FileInfoDialog.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


// CFileInfoDialog dialog

IMPLEMENT_DYNAMIC(CFileInfoDialog, CDialog)
CFileInfoDialog::CFileInfoDialog(CPartFile* pfile)
	: CDialog(CFileInfoDialog::IDD, 0)
	, ARoundBitrate(FALSE)
{
	m_file = pfile;
}

BOOL CFileInfoDialog::OnInitDialog(){
	CDialog::OnInitDialog();
	ARoundBitrate = 1;
	CDialog::UpdateData(FALSE);
	Localize();
	UpdateData();

	return true;
}

void CFileInfoDialog::UpdateData(){
	CFile* file = &m_file->GetPartFileHandle();
	try{
		TCHAR stemp[5];
		CString buffer;
		uint32 u32;
		uint16 u16;

		if(!file)
			return;
		
		file->Seek(8, CFile::begin);
		file->Read(stemp, 4);
		stemp[4] = 0;
		if(_tcscmp(stemp, _T("AVI "))) // not avi
			return;
		


		// filesize
		long size;
		file->Seek(4, CFile::begin);
		file->Read(&size, 4);
		buffer.Format(_T("%.2f MB"),(static_cast<double>(size) / 1024.0 / 1024.0));
		GetDlgItem(IDC_FILESIZE)->SetWindowText(buffer);

		// header sizes
		long Aviheadersize,Vheadersize;
		file->Seek(28, CFile::begin);
		file->Read(&Aviheadersize, 4);

		long Aviheaderstart = 32;
		long Vheaderstart = Aviheaderstart + Aviheadersize + 20;

		// misc
		long Microsec;
		file->Seek(Aviheaderstart, CFile::begin);
		file->Read(&Microsec, 4);

		long LengthInFrames;
		file->Seek(Aviheaderstart + 16, CFile::begin);
		file->Read(&LengthInFrames, 4);

		// fps
		double fps = (double)1000000 / (double)Microsec;
		buffer.Format(_T("%.2f"), fps);
		GetDlgItem(IDC_VFPS)->SetWindowText(buffer);
		
		// length
		long LengthInSec = (long)(LengthInFrames / fps);
		GetDlgItem(IDC_LENGTH)->SetWindowText(CastSecondsToHM(LengthInSec));

		// video width
		file->Seek(Aviheaderstart + 32, CFile::begin);
		file->Read(&u32, 4);
		buffer.Format(_T("%d"), u32);
		GetDlgItem(IDC_VWIDTH)->SetWindowText(buffer);

		// video height
		file->Seek(Aviheaderstart + 36, CFile::begin);
		file->Read(&u32, 4);
		buffer.Format(_T("%d"), u32);
		GetDlgItem(IDC_VHEIGHT)->SetWindowText(buffer);


		// video codec
		file->Seek(Vheaderstart + 4, CFile::begin);
		file->Read(stemp, 4);
		stemp[4] = 0;
		if(!_tcscmp(stemp, _T("div3")) || !_tcscmp(stemp, _T("DIV3")))
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("DivX 3 Low-Motion")); // SeeWen
		else if(!_tcscmp(stemp, _T("div4")) || !_tcscmp(stemp, _T("DIV4")))
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("DivX 3 High-Motion"));
		else if(!_tcscmp(stemp, _T("divx")) || !_tcscmp(stemp, _T("DIVX")))
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("DivX 4"));
		else if(!_tcscmp(stemp, _T("DX50"))) //new By SeeWen
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("DivX 5")); //new
		else if(!_tcscmp(stemp, _T("div2")) || !_tcscmp(stemp, _T("DIV2")))
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("MS MPEG4 v2"));
		else if(!_tcscmp(stemp, _T("mp43")))
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("Microcrap MPEG4 v3"));
		else if(!_tcscmp(stemp, _T("xvid")) || !_tcscmp(stemp, _T("XVID"))) // SeeWen
			GetDlgItem(IDC_VCODEC)->SetWindowText(_T("XviD")); 
		else
			GetDlgItem(IDC_VCODEC)->SetWindowText(stemp);

		// header sizes
		file->Seek(Aviheaderstart + Aviheadersize + 4, CFile::begin);
		file->Read(&Vheadersize, 4);

		long Aheaderstart = Vheaderstart + Vheadersize + 8;	//first databyte of audio header

		long Astrhsize;
		file->Seek(Aheaderstart - 4, CFile::begin);
		file->Read(&Astrhsize, 4);

		// audio codec
		file->Seek(Aheaderstart + Astrhsize + 8, CFile::begin);
		file->Read(&u16, 2);
		switch(u16)
		{
			case 0:
			case 1:
				GetDlgItem(IDC_ACODEC)->SetWindowText(_T("PCM"));
				break;
			case 353:
				GetDlgItem(IDC_ACODEC)->SetWindowText(_T("DivX;-) Audio"));
				break;
			case 85:
				GetDlgItem(IDC_ACODEC)->SetWindowText(_T("MPEG Layer 3"));
				break;
			case 8192:
				GetDlgItem(IDC_ACODEC)->SetWindowText(_T("AC3-Digital"));
				break;
			case 8193:
				GetDlgItem(IDC_ACODEC)->SetWindowText(_T("DTS"));
				break;
			default:
				buffer.Format(_T("Unknown (%d)"), u16);
				GetDlgItem(IDC_ACODEC)->SetWindowText(buffer);
				break;
		}
			
			
		// audio channel
		file->Seek(Aheaderstart + 2 + Astrhsize + 8, CFile::begin);
		file->Read(&u16, 2);
		switch(u16)
		{
			case 1:
				GetDlgItem(IDC_ACHANNEL)->SetWindowText(_T("1 (mono)"));
				break;
			case 2:
				GetDlgItem(IDC_ACHANNEL)->SetWindowText(_T("2 (stereo)"));
				break;
			case 5:
				GetDlgItem(IDC_ACHANNEL)->SetWindowText(_T("5.1 (surround)"));
				break;
			default:
				buffer.Format(_T("%d"), u16);
				GetDlgItem(IDC_ACHANNEL)->SetWindowText(buffer);
				break;
		}
			
		// audio samplerate
		file->Seek(Aheaderstart + 4 + Astrhsize + 8, CFile::begin);
		file->Read(&u32, 2);
		buffer.Format(_T("%d"), u32);
		GetDlgItem(IDC_ASAMPLERATE)->SetWindowText(buffer);

		// audio bitrate
		file->Seek(Aheaderstart + 8 + Astrhsize + 8, CFile::begin);
		file->Read(&Abitrate, 4);
		OnBnClickedRoundbit();

		// video bitrate
		buffer.Format(_T("%d Kbit/s"), (size / LengthInSec - Abitrate) / 128);
		GetDlgItem(IDC_VBITRATE)->SetWindowText(buffer);

	}
	catch(CFileException* error){
		OUTPUT_DEBUG_TRACE();
		error->Delete();	//memleak fix
		return;
	}
}

CFileInfoDialog::~CFileInfoDialog()
{
}

void CFileInfoDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Check(pDX, IDC_ROUNDBIT, ARoundBitrate);
}


BEGIN_MESSAGE_MAP(CFileInfoDialog, CDialog)
	ON_BN_CLICKED(IDC_ROUNDBIT, OnBnClickedRoundbit)
END_MESSAGE_MAP()


// CFileInfoDialog message handlers

void CFileInfoDialog::OnBnClickedRoundbit()
{	
	if(Abitrate != 0)
	{
		CDialog::UpdateData();
		if(ARoundBitrate)
		{
			long t = Abitrate / (1024 / 8);
			if(t>=246 && t<=260)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("256 Kbit/s"));
			else if(t>=216 && t<=228)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("224 Kbit/s"));
			else if(t>=187 && t<=196)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("192 Kbit/s"));
			else if(t>=156 && t<=164)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("160 Kbit/s"));
			else if(t>=124 && t<=132)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("128 Kbit/s"));
			else if(t>=108 && t<=116)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("112 Kbit/s"));
			else if(t>=92 && t<=100)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("96 Kbit/s"));
			else if(t>=60 && t<=68)
				GetDlgItem(IDC_ABITRATE)->SetWindowText(_T("64 Kbit/s"));
			else
			{
				CString buffer;
				buffer.Format(_T("%d Kbit/s"), t);
				GetDlgItem(IDC_ABITRATE)->SetWindowText(buffer);
			}
		}
		else
		{
			CString buffer;
			buffer.Format(_T("%d Kbit/s"), Abitrate / (1024 / 8));
			GetDlgItem(IDC_ABITRATE)->SetWindowText(buffer);
		}
	}
	else
		GetDlgItem(IDC_ABITRATE)->SetWindowText(_T(""));
}

void CFileInfoDialog::Localize(){
	GetDlgItem(IDC_FD_XI1)->SetWindowText(GetResString(IDS_FD_SIZE));
	GetDlgItem(IDC_FD_XI2)->SetWindowText(GetResString(IDS_LENGTH)+_T(":"));
	GetDlgItem(IDC_FD_XI3)->SetWindowText(GetResString(IDS_VIDEO));
	GetDlgItem(IDC_FD_XI4)->SetWindowText(GetResString(IDS_AUDIO));
	GetDlgItem(IDOK)->SetWindowText( GetResString(IDS_FD_CLOSE));

	GetDlgItem(IDC_FD_XI5)->SetWindowText( GetResString(IDS_CODEC)+_T(":"));
	GetDlgItem(IDC_FD_XI6)->SetWindowText( GetResString(IDS_CODEC)+_T(":"));
	
	GetDlgItem(IDC_FD_XI7)->SetWindowText( GetResString(IDS_BITRATE)+_T(":"));
	GetDlgItem(IDC_FD_XI8)->SetWindowText( GetResString(IDS_BITRATE)+_T(":"));
	
	GetDlgItem(IDC_FD_XI9)->SetWindowText( GetResString(IDS_WIDTH)+_T(":"));
	GetDlgItem(IDC_FD_XI11)->SetWindowText( GetResString(IDS_HEIGHT)+_T(":"));
	GetDlgItem(IDC_FD_XI13)->SetWindowText( GetResString(IDS_FPS)+_T(":"));
	GetDlgItem(IDC_FD_XI10)->SetWindowText( GetResString(IDS_CHANNELS)+_T(":"));
	GetDlgItem(IDC_FD_XI12)->SetWindowText( GetResString(IDS_SAMPLERATE)+_T(":"));
	GetDlgItem(IDC_ROUNDBIT)->SetWindowText( GetResString(IDS_ROUNDBITRATE)+_T(":"));

	CString title=GetResString(IDS_FILEINFO); title.Remove('&');
	SetWindowText(title);
}
@


1.10
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@@


1.9
log
@minor change ("DTS" added to list of audio codecs) [quekky]
@
text
@d74 1
a74 1
		buffer.Format(_T("%.2f MB"),((float)size / 1024 / 1024));
@


1.8
log
@Second batch of name changes
@
text
@d165 3
@


1.7
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d52 1
a52 1
	CFile* file = &m_file->m_hPartFile;
@


1.6
log
@unicode cleanup
@
text
@d52 1
a52 1
	CFile* file = &m_file->m_hpartfile;
@


1.5
log
@code cleanup
@
text
@d54 1
a54 1
		char stemp[5];
d65 1
a65 1
		if(strcmp(stemp, "AVI ")) // not avi
d74 1
a74 1
		buffer.Format("%.2f MB",((float)size / 1024 / 1024));
d96 1
a96 1
		buffer.Format("%.2f", fps);
d106 1
a106 1
		buffer.Format("%d", u32);
d112 1
a112 1
		buffer.Format("%d", u32);
d120 14
a133 14
		if(!strcmp(stemp, "div3") || !strcmp(stemp, "DIV3"))
			GetDlgItem(IDC_VCODEC)->SetWindowText("DivX 3 Low-Motion"); // SeeWen
		else if(!strcmp(stemp, "div4") || !strcmp(stemp, "DIV4"))
			GetDlgItem(IDC_VCODEC)->SetWindowText("DivX 3 High-Motion");
		else if(!strcmp(stemp, "divx") || !strcmp(stemp, "DIVX"))
			GetDlgItem(IDC_VCODEC)->SetWindowText("DivX 4");
		else if(!strcmp(stemp, "DX50")) //new By SeeWen
			GetDlgItem(IDC_VCODEC)->SetWindowText("DivX 5"); //new
		else if(!strcmp(stemp, "div2") || !strcmp(stemp, "DIV2"))
			GetDlgItem(IDC_VCODEC)->SetWindowText("MS MPEG4 v2");
		else if(!strcmp(stemp, "mp43"))
			GetDlgItem(IDC_VCODEC)->SetWindowText("Microcrap MPEG4 v3");
		else if(!strcmp(stemp, "xvid") || !strcmp(stemp, "XVID")) // SeeWen
			GetDlgItem(IDC_VCODEC)->SetWindowText("XviD"); 
d154 1
a154 1
				GetDlgItem(IDC_ACODEC)->SetWindowText("PCM");
d157 1
a157 1
				GetDlgItem(IDC_ACODEC)->SetWindowText("DivX;-) Audio");
d160 1
a160 1
				GetDlgItem(IDC_ACODEC)->SetWindowText("MPEG Layer 3");
d163 1
a163 1
				GetDlgItem(IDC_ACODEC)->SetWindowText("AC3-Digital");
d166 1
a166 1
				buffer.Format("Unknown (%d)", u16);
d178 1
a178 1
				GetDlgItem(IDC_ACHANNEL)->SetWindowText("1 (mono)");
d181 1
a181 1
				GetDlgItem(IDC_ACHANNEL)->SetWindowText("2 (stereo)");
d184 1
a184 1
				GetDlgItem(IDC_ACHANNEL)->SetWindowText("5.1 (surround)");
d187 1
a187 1
				buffer.Format("%d", u16);
d195 1
a195 1
		buffer.Format("%d", u32);
d204 1
a204 1
		buffer.Format("%d Kbit/s", (size / LengthInSec - Abitrate) / 128);
d242 1
a242 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("256 Kbit/s");
d244 1
a244 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("224 Kbit/s");
d246 1
a246 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("192 Kbit/s");
d248 1
a248 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("160 Kbit/s");
d250 1
a250 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("128 Kbit/s");
d252 1
a252 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("112 Kbit/s");
d254 1
a254 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("96 Kbit/s");
d256 1
a256 1
				GetDlgItem(IDC_ABITRATE)->SetWindowText("64 Kbit/s");
d260 1
a260 1
				buffer.Format("%d Kbit/s", t);
d267 1
a267 1
			buffer.Format("%d Kbit/s", Abitrate / (1024 / 8));
d272 1
a272 1
		GetDlgItem(IDC_ABITRATE)->SetWindowText("");
d277 1
a277 1
	GetDlgItem(IDC_FD_XI2)->SetWindowText(GetResString(IDS_LENGTH)+":");
d282 2
a283 2
	GetDlgItem(IDC_FD_XI5)->SetWindowText( GetResString(IDS_CODEC)+":");
	GetDlgItem(IDC_FD_XI6)->SetWindowText( GetResString(IDS_CODEC)+":");
d285 2
a286 2
	GetDlgItem(IDC_FD_XI7)->SetWindowText( GetResString(IDS_BITRATE)+":");
	GetDlgItem(IDC_FD_XI8)->SetWindowText( GetResString(IDS_BITRATE)+":");
d288 6
a293 6
	GetDlgItem(IDC_FD_XI9)->SetWindowText( GetResString(IDS_WIDTH)+":");
	GetDlgItem(IDC_FD_XI11)->SetWindowText( GetResString(IDS_HEIGHT)+":");
	GetDlgItem(IDC_FD_XI13)->SetWindowText( GetResString(IDS_FPS)+":");
	GetDlgItem(IDC_FD_XI10)->SetWindowText( GetResString(IDS_CHANNELS)+":");
	GetDlgItem(IDC_FD_XI12)->SetWindowText( GetResString(IDS_SAMPLERATE)+":");
	GetDlgItem(IDC_ROUNDBIT)->SetWindowText( GetResString(IDS_ROUNDBITRATE)+":");
@


1.4
log
@Code clean up and double check wit official code.
@
text
@d234 1
a234 2
{
	char buffer[100];
d259 2
a260 1
				sprintf(buffer, "%d Kbit/s", t);
d266 2
a267 1
			sprintf(buffer, "%d Kbit/s", Abitrate / (1024 / 8));
@


1.3
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d55 1
a55 1
		char buffer[100];
d74 1
a74 1
		sprintf(buffer, "%.2f MB",((float)size / 1024 / 1024));
d96 1
a96 1
		sprintf(buffer, "%.2f", fps);
d106 1
a106 1
		sprintf(buffer, "%d", u32);
d112 1
a112 1
		sprintf(buffer, "%d", u32);
d127 1
a127 1
			GetDlgItem(IDC_VCODEC)->SetWindowText("DivX 5.0"); //new
d166 1
a166 1
				sprintf(buffer, "Unknown (%d)", u16);
d187 1
a187 1
				sprintf(buffer, "%d", u16);
d195 1
a195 1
		sprintf(buffer, "%d", u32);
d204 1
a204 1
		sprintf(buffer, "%d Kbit/s", (size / LengthInSec - Abitrate) / 128);
@


1.2
log
@.26b port
@
text
@d24 6
@


1.1
log
@*** empty log message ***
@
text
@d95 1
a95 2
		CastSecondsToHM(LengthInSec,buffer);
		GetDlgItem(IDC_LENGTH)->SetWindowText(buffer);
@


1.1.4.1
log
@updating this branch...
@
text
@@

