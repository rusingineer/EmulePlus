head	1.19;
access;
symbols
	PublicRelease_1_2e:1.19
	Interim_Release_1-2e_RC1:1.19
	PublicRelease_1_2d:1.19
	Interim_Release_1-2d_RC1:1.18
	Interim_Release_1-2d_beta1:1.18
	PublicRelease_1_2c:1.18
	Interim_Release_1-2c_RC1:1.18
	Interim_Release_1-2c_beta1:1.14
	PublicRelease_1_2b:1.14
	Interim_Release_1-2b_RC1:1.14
	PublicRelease_1_2a:1.14
	Interim_Release_1-2a_RC1:1.14
	Interim_Release_1-2a_beta2:1.13
	Interim_Release_1-2a_beta1:1.13
	PublicRelease_1_2:1.13
	Interim_Release_1-2_RC1:1.13
	Interim_Release_1-2_beta1:1.13
	PublicRelease_1_1g:1.12
	Interim_Release_1-1g_RC3:1.12
	Interim_Release_1-1g_RC2:1.12
	Interim_Release_1-1g_RC1:1.12
	Interim_Release_1-1g_beta2:1.12
	Interim_Release_1-1g_beta1:1.12
	PublicRelease_1_1f:1.12
	Interim_Release_1-1f_RC1:1.12
	PublicRelease_1_1e:1.12
	Interim_Release_1-1e_RC2:1.12
	Interim_Release_1-1e_RC1:1.12
	Interim_Release_1-1e_beta1:1.12
	PublicRelease_1_1d:1.12
	Interim_Release_1-1d_RC1:1.12
	PublicRelease_1_1c:1.12
	Interim_Release_1-1c_RC1:1.12
	Interim_Release_1-1c_beta2:1.12
	Interim_Release_1-1c_beta1:1.12
	PublicRelease_1_1b:1.12
	Interim_Release_1-1b_RC1:1.12
	PublicRelease_1_1a:1.12
	Interim_Release_1-1a_RC2:1.12
	Interim_Release_1-1a_RC1:1.12
	Interim_Release_1-1a_beta2:1.12
	Interim_Release_1-1a_beta1:1.12
	PublicRelease_1_1:1.12
	Interim_Release_1-1_beta1:1.12
	PublicRelease_1o:1.12
	Interim_Release_1o_RC1:1.12
	Interim_Release_1o_beta1:1.12
	PublicRelease_1n:1.12
	Interim_Release_1n_RC2:1.12
	Interim_Release_1n_RC1:1.12
	Interim_Release_1n_beta2:1.12
	Interim_Release_1n_beta1:1.12
	PublicRelease_1m:1.12
	Interim_Release_1m_beta1:1.12
	PublicRelease_1l:1.12
	Interim_Release_1l_RC3:1.12
	Interim_Release_1l_RC2:1.12
	Interim_Release_1l_RC1:1.12
	Interim_Release_1l_beta2:1.12
	Interim_Release_1l_beta1:1.12
	PublicRelease_1k:1.12
	Interim_Release_1k_RC4:1.12
	Interim_1k_RC3:1.12
	Interim_1k_RC2:1.12
	Interim_Release_1k_RC1:1.12
	Interim_Release_1k_beta5:1.11
	Intrerim_Release_1k_beta4:1.11
	Interim_Release_1k_beta1:1.11
	PublicRelease_1j:1.11
	Interim_Release_1J_RC3:1.11
	Interim_Release_1j_RC3:1.11
	Interim_Release_1j_RC2:1.11
	Interim_Release_1j_RC1:1.11
	Interim_Release_1j_beta2:1.11
	Interim_Release_1j_beta1:1.11
	PublicRelease_1i:1.11
	Interim_Release_1i_RC6:1.11
	Interim_Release_1i_RC3:1.11
	Interim_Release_1i_RC2:1.11
	Interim_Release_1i_RC1:1.9
	Interim_Release_1i_beta3:1.9
	Interim_Release_1i_beta2:1.9
	Interim_Release_1i_beta1:1.9
	PublicRelease_1h:1.6
	Interim_Release_1h_rc2:1.6
	Interim_Release_1h_RC1:1.6
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.6
	Interim_Release_1h_beta1:1.6
	PublicRelease_1g:1.6
	Interim_Release_1g_RC6_Final:1.6
	Interim_Release_1g_RC6:1.6
	Interim_Release_1g_RC5:1.6
	Interim_Release_1g_RC4:1.6
	Interim_Release_1g_RC3:1.6
	Interim_Release_1g_beta2:1.4
	Interim_Release_1g_beta1:1.4
	Interim_Release_1f_RC4:1.4
	Interim_Release_1f_RC3:1.4
	Interim_Release_1f_RC2:1.4
	Interim_Release_1f_RC:1.4
	Interim_Release_1f_beta2:1.4
	Interim_Release_1f_beta1:1.4
	PublicRelease_1e:1.4
	Interim_Release_1e_RC2:1.4
	Interim_Release_1e_RC:1.4
	Interim_Release_1e_beta3:1.4
	Interim_Release_1e_beta2:1.4
	Interim_Release_1e_beta2_before_kuchin:1.4
	Interim_Release_1e_beta1:1.4
	PublicRelease_1c:1.3
	featurestest:1.3.0.2
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.19
date	2008.04.24.05.04.15;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2007.07.27.06.22.17;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2007.07.08.00.14.18;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2007.03.20.19.36.53;	author kush_eplus;	state Exp;
branches;
next	1.15;

1.15
date	2007.03.19.19.18.41;	author kush_eplus;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.12.17.39.37;	author kush_eplus;	state Exp;
branches;
next	1.13;

1.13
date	2005.12.29.05.35.35;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2004.03.23.18.09.27;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.11.00.22.59;	author katsyonak;	state Exp;
branches;
next	1.10;

1.10
date	2003.11.10.11.58.12;	author katsyonak;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.05.10.29.06;	author eklmn;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.28.20.31.14;	author eklmn;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.27.22.08.47;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.19.16.48.04;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.15.09.10.04;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.13.17.48.31;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.19.18.42.51;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.16.18.33.25;	author forcha;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.07.05;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.00;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Fixed stuck credits control and about dialog when focus is lost while holding mouse -- credit control is control with scrolling credits inside about dialog (ways to reproduce: Alt-Tab);
Suppressed compiler warnings.
@
text
@// CreditsCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "CreditsCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define CCREDITCTRL_TIMER1	100

// use transparent BitBlts if supported? ( UNTESTED!! )
//#define CCREDITCTRL_USE_TRANSPARENT_BITBLT

// stuff that _should_ have been defined in some header :-/
#ifndef C1_TRANSPARENT
    #define C1_TRANSPARENT 0x0001
#endif
#ifndef CAPS1
    #define CAPS1 94
#endif
#ifndef NEWTRANSPARENT
    #define NEWTRANSPARENT 3
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreditsCtrl
LPCTSTR CCreditsCtrl::m_lpszClassName = NULL;

CCreditsCtrl::CCreditsCtrl()
{
	m_nTimerSpeed = 40;
	m_nCurBitmapOffset = 0;
	m_crInternalTransparentColor = RGB(255, 0, 255);
	m_pBackgroundPaint = CCreditsCtrl::DrawBackground;
	m_dwBackgroundPaintLParam = GetSysColor(COLOR_BTNFACE);//(DWORD)m_crBackgroundColor;
	m_hLinkCursor = NULL;
	m_hDefaultCursor = NULL;
	m_bCanScroll = TRUE;
	m_bIsScrolling = FALSE;

	m_rcHotRect = CRect(0, 0, 0, 0);
	m_oldcx = 0;
	m_oldcy = 0;
}

CCreditsCtrl::~CCreditsCtrl()
{
//	Destroy copied cursor on exit
	if (m_hLinkCursor)
		DestroyCursor(m_hLinkCursor);
}


BEGIN_MESSAGE_MAP(CCreditsCtrl, CWnd)
	ON_WM_PAINT()
	ON_WM_TIMER()
	ON_WM_SIZE()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_CANCELMODE()
END_MESSAGE_MAP()


BOOL CCreditsCtrl::Create(DWORD dwExStyle, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, UINT nDefaultCursorID, UINT nLinkCursorID)
{
	EMULE_TRY
	m_hDefaultCursor = nDefaultCursorID == 0 ? AfxGetApp()->LoadStandardCursor(IDC_ARROW) : AfxGetApp()->LoadCursor(nDefaultCursorID);
	if (nLinkCursorID == 0)
		SetDefaultLinkCursor();
	else
		m_hLinkCursor = AfxGetApp()->LoadCursor(nLinkCursorID);

	// register window class & create CWnd object
	if (m_lpszClassName == NULL)
		m_lpszClassName = AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW);

	BOOL bResult = CreateEx(dwExStyle, m_lpszClassName, _T(""), dwStyle,
		rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
		pParentWnd->GetSafeHwnd(), (HMENU)nID, NULL );

	// start scrolling
	if (bResult)
		SetTimer(CCREDITCTRL_TIMER1, m_nTimerSpeed * 5, NULL);

	return bResult;
	EMULE_CATCH2
	return FALSE;
}

BOOL CCreditsCtrl::Create(DWORD dwExStyle, DWORD dwStyle, UINT nPlaceholderID, CWnd* pParentWnd, UINT nID, UINT nDefaultCursorID, UINT nLinkCursorID)
{
	EMULE_TRY
	// get rect from placeholder and call create with the found rect
	RECT rect;
	pParentWnd->GetDlgItem(nPlaceholderID)->GetWindowRect(&rect);
	pParentWnd->ScreenToClient(&rect);
	return Create(dwExStyle, dwStyle, rect, pParentWnd, nID, nDefaultCursorID, nLinkCursorID);
	EMULE_CATCH2
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CCreditsCtrl message handlers

void CCreditsCtrl::OnPaint()
{
	EMULE_TRY
	static BOOL bFirstDraw = TRUE;

	CPaintDC dc(this); // device context for painting

	// init memory DC
	CDC memDC;
	memDC.CreateCompatibleDC(&dc);
	int nMemDCSave = memDC.SaveDC();
	CBitmap memBmp;
	memBmp.CreateCompatibleBitmap(&dc, m_rcClient.Width(), m_rcClient.Height());
	CBitmap* pOldBitmap = memDC.SelectObject(&memBmp);

	// draw background
	if (m_pBackgroundPaint!=NULL)
		(*m_pBackgroundPaint)(&memDC, m_rcClient, m_bIsScrolling || bFirstDraw, m_dwBackgroundPaintLParam);

	// calculate hot rectagle position and save background at that location
	CDC hotBgDC;
	CBitmap hotbgBmp;
	CBitmap* pOldHBgBmp;
	CRect rcHotRect;
	if (m_rcHotRect != CRect(0, 0, 0, 0))
	{
		hotBgDC.CreateCompatibleDC(&memDC);
		hotbgBmp.CreateCompatibleBitmap(&memDC, m_rcHotRect.Width(), m_rcHotRect.Height());
		pOldHBgBmp = hotBgDC.SelectObject(&hotbgBmp);

		if (m_nBitmapHeight <= m_rcClient.bottom)
			rcHotRect = m_rcHotRect;
		else if (m_nBitmapHeight - m_nCurBitmapOffset + m_rcHotRect.top < m_rcClient.bottom)
			rcHotRect.SetRect(m_rcHotRect.left, m_nBitmapHeight - m_nCurBitmapOffset + m_rcHotRect.top, m_rcHotRect.right, m_nBitmapHeight - m_nCurBitmapOffset + m_rcHotRect.bottom);
		else
			rcHotRect.SetRect(m_rcHotRect.left, m_rcHotRect.top - m_nCurBitmapOffset, m_rcHotRect.right, m_rcHotRect.bottom - m_nCurBitmapOffset);

		hotBgDC.BitBlt(0, 0, m_rcHotRect.Width(), m_rcHotRect.Height(), &memDC, rcHotRect.left, rcHotRect.top, SRCCOPY);
	}

	// draw normal bitmap
	if (m_nBitmapHeight <= m_rcClient.bottom)
	{
		CRect rect = m_rcClient;
		rect.bottom = m_nBitmapHeight;
		DrawTransparentBitmap(&m_bmpNormal, &memDC, m_crInternalTransparentColor, rect, rect);
	}
	else
	{
		DrawTransparentBitmap(&m_bmpNormal, &memDC, m_crInternalTransparentColor, CRect(0, 0, m_rcClient.right, min(m_nBitmapHeight - m_nCurBitmapOffset, m_rcClient.bottom)), CRect(0, m_nCurBitmapOffset, 0, 0/*the two last values are not taken into account by DrawTransparentBitmap anyway*/));
		if (m_nBitmapHeight - m_nCurBitmapOffset < m_rcClient.bottom)
			DrawTransparentBitmap(&m_bmpNormal, &memDC, m_crInternalTransparentColor, CRect(0, m_nBitmapHeight - m_nCurBitmapOffset, m_rcClient.right, m_rcClient.bottom), CRect(0, 0, 0, 0/*the two last values are not taken into account by DrawTransparentBitmap anyway*/));
	}

	// draw hot rect onto generic background
	if (m_rcHotRect != CRect(0, 0, 0, 0))
	{
		memDC.BitBlt(rcHotRect.left, rcHotRect.top, rcHotRect.Width(), rcHotRect.Height(), &hotBgDC, 0, 0, SRCCOPY);
		DrawTransparentBitmap(&m_bmpHot, &memDC, m_crInternalTransparentColor, rcHotRect, m_rcHotRect);
		hotBgDC.SelectObject(pOldHBgBmp);
	}

	// copy memory DC to screen
	dc.BitBlt(0, 0, m_rcClient.Width(), m_rcClient.Height(), &memDC, 0, 0, SRCCOPY);

	//eklmn(27.09.2003) deselect a bitmap
	memDC.SelectObject(pOldBitmap);
	memDC.RestoreDC(nMemDCSave);

	if (bFirstDraw)
		bFirstDraw = FALSE;
	EMULE_CATCH2
}

CString CCreditsCtrl::SetDataString(LPCTSTR lpszNewString)
{
	CString sOldString = m_sData;
	m_sData = lpszNewString;
	if (IsWindow(m_hWnd))
		Initialize();
	return sOldString;
}

CString CCreditsCtrl::SetDataString(UINT nStringResourceID)
{
	CString sOldString = m_sData;
	m_sData.LoadString(nStringResourceID);
	if (IsWindow(m_hWnd))
		Initialize();
	return sOldString;
}

CString CCreditsCtrl::FormatDataString(LPCTSTR lpszFormat, ...)
{
	ASSERT(AfxIsValidString(lpszFormat));

	CString sOldString = m_sData; // store old string

	// let CString do the formatting
	va_list argList;
	va_start(argList, lpszFormat);
	m_sData.FormatV(lpszFormat, argList);
	va_end(argList);

	if (IsWindow(m_hWnd)) // Initialize bitmaps if we have already been Create()d
		Initialize();

	return sOldString;
}

CString CCreditsCtrl::FormatDataString(UINT nFormatID, ...)
{
	CString strFormat;
	VERIFY(strFormat.LoadString(nFormatID) != 0); // load resource string

	CString sOldString = m_sData; // store old string

	// let CString do the formatting
	va_list argList;
	va_start(argList, nFormatID);
	m_sData.FormatV(strFormat, argList);
	va_end(argList);

	if (IsWindow(m_hWnd)) // Initialize bitmaps if we have already been Create()d
		Initialize();

	return sOldString;
}

CString CCreditsCtrl::GetDataString()
{
	return m_sData;
}

void CCreditsCtrl::SetDefaultLinkCursor()
{
	// following code is taken from Chris Maunders hyperlink control (http://www.codeproject.com) - tnx
	if (m_hLinkCursor == NULL)		// No cursor handle - load our own
	{
        // Get the windows directory
		CString strWndDir;
		GetWindowsDirectory(strWndDir.GetBuffer(MAX_PATH), MAX_PATH);
		strWndDir.ReleaseBuffer();

		strWndDir += _T("\\winhlp32.exe");
		// This retrieves cursor #106 from winhlp32.exe, which is a hand pointer
		HMODULE hModule = LoadLibrary(strWndDir);
		if (hModule) {
			HCURSOR hHandCursor = ::LoadCursor(hModule, MAKEINTRESOURCE(106));
			if (hHandCursor)
				m_hLinkCursor = CopyCursor(hHandCursor);
		}
		FreeLibrary(hModule);
	}
}

void CCreditsCtrl::OnTimer(UINT nIDEvent)
{
	EMULE_TRY
	if (nIDEvent == CCREDITCTRL_TIMER1)
	{
		if (IsWindowVisible())
		{
			// increment bitmap offset
			if (++m_nCurBitmapOffset > m_nBitmapHeight)
				m_nCurBitmapOffset = 1;

			// update cursor
			CPoint point, pt;
			GetCursorPos(&point);
			pt = point;
			ScreenToClient(&point);
			if (m_rcClient.PtInRect(point) && WindowFromPoint(pt) == this)
			{
				CRect rect;
				int n;
				if ((n = HitTest(point)) != -1)
				{
					rect = m_HotRects[n];
					SetCursor(m_hLinkCursor);
				}
				else
				{
					rect = CRect(0, 0, 0, 0);
					SetCursor(m_hDefaultCursor);
				}
				if (rect != m_rcHotRect)
					m_rcHotRect = rect;
			}

			// update window
			Invalidate(FALSE);
			UpdateWindow();

			// set timer
			SetTimer(CCREDITCTRL_TIMER1, m_nTimerSpeed, NULL);
		}
	}
	else
		CWnd::OnTimer(nIDEvent);
	EMULE_CATCH2
}

void CCreditsCtrl::OnSize(UINT nType, int cx, int cy)
{
	if ((!cx && !cy) || (cx == m_oldcx && cy == m_oldcy))
		return;

	CWnd::OnSize(nType, cx, cy);
	m_oldcx = cx;
	m_oldcy = cy;

	if (IsWindow(m_hWnd))
		GetClientRect(m_rcClient);

	Initialize();
}

void CCreditsCtrl::TransparentBlt(CDC *pSrcDC, CDC* pDestDC, COLORREF crTrans, const CRect& rcDest, const CRect& rcSrc)
{
	EMULE_TRY
	int SaveDestDC = pDestDC->SaveDC();
	int SaveSrcDC = pSrcDC->SaveDC();

#ifdef CCREDITCTRL_USE_TRANSPARENT_BITBLT	// use transparent BitBlts if supported?
	// Only attempt this if device supports functionality. ( untested!! )
	if (pDestDC->GetDeviceCaps(CAPS1) & C1_TRANSPARENT)
	{
		// Special transparency background mode
		pDestDC->SetBkMode(NEWTRANSPARENT);
		pDestDC->SetBkColor(crTrans);
		// Actual blt is a simple source copy; transparency is automatic.
		pDestDC->BitBlt(rcDest.left, rcDest.top, rcDest.Width(), rcDest.Height(), pSrcDC, rcSrc.left, rcSrc.top, SRCCOPY);
	}
	else	// if driver doesn't support transparent BitBlts, do it the hard way
	{
#endif
		// initialize memory DC and monochrome mask DC
		CDC tmpDC, maskDC;
		CBitmap bmpTmp, bmpMask;
		int SaveTmpDC, SaveMaskDC;
		tmpDC.CreateCompatibleDC(pDestDC);
		maskDC.CreateCompatibleDC(pDestDC);
		SaveTmpDC = tmpDC.SaveDC();
		SaveMaskDC = maskDC.SaveDC();
		bmpTmp.CreateCompatibleBitmap(pDestDC, rcDest.Width(), rcDest.Height());
		bmpMask.CreateBitmap(rcDest.Width(), rcDest.Height(), 1, 1, NULL);
		CBitmap* pOldBitmap = tmpDC.SelectObject(&bmpTmp);
		CBitmap* pOldBitmapMask = maskDC.SelectObject(&bmpMask);

		// copy existing data from destination dc to memory dc
		tmpDC.BitBlt(0, 0, rcDest.Width(), rcDest.Height(), pDestDC, rcDest.left, rcDest.top, SRCCOPY);

		// create mask
		pSrcDC->SetBkColor(crTrans);
		maskDC.BitBlt(0, 0, rcDest.Width(), rcDest.Height(), pSrcDC, rcSrc.left, rcSrc.top, SRCCOPY);

		// do some BitBlt magic
		tmpDC.SetBkColor(RGB(255, 255, 255));
		tmpDC.SetTextColor(RGB(0, 0, 0));
		tmpDC.BitBlt(0, 0, rcDest.Width(), rcDest.Height(), pSrcDC, rcSrc.left, rcSrc.top, SRCINVERT);
		tmpDC.BitBlt(0, 0, rcDest.Width(), rcDest.Height(), &maskDC, 0, 0, SRCAND);
		tmpDC.BitBlt(0, 0, rcDest.Width(), rcDest.Height(), pSrcDC, rcSrc.left, rcSrc.top, SRCINVERT);

		// copy what we have in our memory DC to the destination DC
		pDestDC->BitBlt(rcDest.left, rcDest.top, rcDest.Width(), rcDest.Height(), &tmpDC, 0, 0, SRCCOPY);

		// eklmn(27.09.2003): deselect an objects
		maskDC.SelectObject(pOldBitmapMask);
		tmpDC.SelectObject(pOldBitmap);

		// clean up (based on LIFO)
		maskDC.RestoreDC(SaveMaskDC);
		tmpDC.RestoreDC(SaveTmpDC);

#ifdef CCREDITCTRL_USE_TRANSPARENT_BITBLT
	}
#endif
	pDestDC->RestoreDC(SaveDestDC);
	pSrcDC->RestoreDC(SaveSrcDC);
	EMULE_CATCH2
}

void CCreditsCtrl::DrawTransparentBitmap(CBitmap* pBitmap, CDC* pDC, COLORREF crTrans, const CRect& rcDest, const CRect& rcSrc)
{
	EMULE_TRY
	int SaveImageDC;

	// initialize image DC
	CDC imageDC;
	imageDC.CreateCompatibleDC(pDC);
	SaveImageDC = imageDC.SaveDC();
	CBitmap* pOldBitmap = imageDC.SelectObject(pBitmap);

	TransparentBlt(&imageDC, pDC, crTrans, rcDest, rcSrc);

	//eklmn(27.09.2003) deselect a bitmap
	imageDC.SelectObject(pOldBitmap);
	// clean up
	imageDC.RestoreDC(SaveImageDC);
	EMULE_CATCH2
}

void CCreditsCtrl::Initialize()
{
	EMULE_TRY
	//// [Initialize] ///////////////////////////////////////
	//                                                     //
	//  Create bitmaps and calc hot regions from m_sData   //
	//                                                     //
	/////////////////////////////////////////////////////////
	int nMaxHeight = 5000;

	// initialize normal and hot DCs
	CDC* pDC = GetDC();
	CDC normalDC, hotDC;
	normalDC.CreateCompatibleDC(pDC);
	hotDC.CreateCompatibleDC(pDC);
	int nSaveDCNormal = normalDC.SaveDC();
	int nSaveDCHot = hotDC.SaveDC();

	// initialize bitmaps
	if (m_bmpNormal.m_hObject)
		m_bmpNormal.DeleteObject();
	m_bmpNormal.CreateCompatibleBitmap(pDC, m_rcClient.Width(), nMaxHeight);
	if (m_bmpHot.m_hObject)
		m_bmpHot.DeleteObject();
	m_bmpHot.CreateCompatibleBitmap(pDC, m_rcClient.Width(), nMaxHeight);

	// select bitmaps into DCs
	CBitmap* pOldBitmapNormal = normalDC.SelectObject(&m_bmpNormal);
	CBitmap* pOldBitmapHot = hotDC.SelectObject(&m_bmpHot);

	// fill with transparent color
	normalDC.FillSolidRect(0, 0, m_rcClient.right, nMaxHeight, m_crInternalTransparentColor);
	hotDC.FillSolidRect(0, 0, m_rcClient.right, nMaxHeight, m_crInternalTransparentColor);

	CString sData = m_sData;

	// make sure we get the last line displayed
	sData += _T('\n');

	// variables used for parsing
	CList<font_attribs, font_attribs&> font_attribs_tree;
	font_attribs fa;
	fa.bBold = FALSE;
	fa.bItalic = FALSE;
	fa.bUnderline = FALSE;
	fa.bStrikeout = FALSE;
	fa.crBkColor = CLR_NONE;
	fa.crColor = RGB(0, 0, 0);
	fa.nSize = 12;
	_tcscpy(fa.szName, _T("Arial"));
	font_attribs_tree.AddTail(fa); // default font
	CList<general_attribs, general_attribs&> general_attribs_tree;
	general_attribs ga;
	ga.nAlign = 1;
	ga.nVAlign = 1;
	ga.nMaxWidth = m_rcClient.Width();
	ga.nMaxHeight = nMaxHeight;
	general_attribs_tree.AddTail(ga); // default alignment
	font_attribs link = { NULL };
	BOOL bInsideTag = FALSE;
	CString sCurTagName;
	CString sCurElement;
	CString sCurOption;
	int nCurHPos = 0;
	int nCurVPos = 0;
	int nCurLineHeight = 0;
	CArray<line_rect, line_rect&> arcLineRects; // list containg information about the elements in the current line. used for vertical alignment of these element at line break.
	BOOL bIsLineEmpty = TRUE;
	BOOL bIsOption = FALSE;
	TCHAR cTmp;
	COLORREF crHrColor;
	int nHrWidth;
	int nHrSize;
	int nHrAlign;
	CString sCurLink;
	COLORREF crBitmap;
	int nBitmapBorder;
	CString sBitmap;

	CDC lineDC;
	lineDC.CreateCompatibleDC(&normalDC);
	CBitmap lineBmp;
	lineBmp.CreateCompatibleBitmap(&normalDC, ga.nMaxWidth, ga.nMaxHeight);
	CBitmap* pOldBmp = lineDC.SelectObject(&lineBmp);

	CDC hover_lineDC;
	hover_lineDC.CreateCompatibleDC(&hotDC);
	CBitmap hover_lineBmp;
	hover_lineBmp.CreateCompatibleBitmap(&hotDC, ga.nMaxWidth, ga.nMaxHeight);
	CBitmap* pOldHoverBmp = hover_lineDC.SelectObject(&hover_lineBmp);

	// main parsing loop... processing character by character
	//  (don't even _try_ to understand what's going on here :)
	for(int i = 0; i < sData.GetLength() && i >= 0; i++)
	{
		if (!bInsideTag)
		{
			if (sData[i] == _T('<'))
			{
				if (!sCurElement.IsEmpty())
				{
					Parse_AppendText(&lineDC, &hover_lineDC, &nCurHPos, &nCurVPos, &nCurLineHeight, &arcLineRects, &general_attribs_tree.GetTail(), &font_attribs_tree.GetTail(), sCurElement, sCurLink, link);
					bIsLineEmpty = FALSE;
				}
				sCurTagName = _T("");
				sCurElement = _T("");
				bInsideTag = TRUE;
				continue;
			}
			if (sData[i] == _T('\n')) // line break
			{
				if (bIsLineEmpty) // if line is empty add the height of a space with the current font
				{
					fa = font_attribs_tree.GetTail();
					CFont font;
					font.CreateFont( -fa.nSize, 0, 0, 0, fa.bBold ? FW_BOLD : 0,
						(BYTE)fa.bItalic, (BYTE)fa.bUnderline, (BYTE)fa.bStrikeout, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, &fa.szName[0] );
					CFont* pOldFont = lineDC.SelectObject(&font);
					CRect rect(0, 0, ga.nMaxWidth, ga.nMaxHeight);
					lineDC.DrawText(_T(" "), CSTRLEN(_T(" ")), rect, DT_CALCRECT);
					lineDC.SelectObject(pOldFont);
					nCurVPos += rect.Height();
				}
				else
				{
					if (!sCurElement.IsEmpty())
						Parse_AppendText(&lineDC, &hover_lineDC, &nCurHPos, &nCurVPos, &nCurLineHeight, &arcLineRects, &general_attribs_tree.GetTail(), &font_attribs_tree.GetTail(), sCurElement, sCurLink, link);
					Parse_VAlignLine(&normalDC, &hotDC, &lineDC, &hover_lineDC, nCurHPos, nCurVPos, nCurLineHeight, &arcLineRects, &general_attribs_tree.GetTail());
					nCurVPos += nCurLineHeight;
					bIsLineEmpty = TRUE;
				}
				arcLineRects.RemoveAll();
				nCurLineHeight = 0;
				nCurHPos = 0;
				sCurElement = _T("");
				continue;
			}
			sCurElement += sData[i];
			bIsLineEmpty = FALSE;
		}
		else
		{
			if (sData[i] == _T('>'))
			{
				if (sCurTagName == _T("font")) // <font face="s" size="n" style="[-b|b][-i|i][-u|u][-s|s]" color="n,n,n" background="n,n,n">
				{
					font_attribs_tree.AddTail(fa);
					general_attribs_tree.AddTail(ga);
				}
				else if (sCurTagName.IsEmpty() && sCurElement == _T("/font")) // closing font tag.. revove the last attributes from the lists
				{
					if (font_attribs_tree.GetCount() > 1)
						font_attribs_tree.RemoveTail();
					if (general_attribs_tree.GetCount() > 1)
						general_attribs_tree.RemoveTail();
				}
				else if (sCurTagName.IsEmpty() && sCurElement == _T("hr")) // no parameters specified for the hr tag.. use the defaults
				{
					crHrColor = GetSysColor(COLOR_BTNSHADOW); // default color
					nHrWidth = ga.nMaxWidth - 100; // default width
					nHrSize = 2;	// default height
					nHrAlign = 1;	// center by default
					sCurTagName = _T("hr");
				}
				if (sCurTagName == _T("hr")) // wrap line is needed and draw rect
				{
					if (!bIsLineEmpty)
					{
						Parse_VAlignLine(&normalDC, &hotDC, &lineDC, &hover_lineDC, nCurHPos, nCurVPos, nCurLineHeight, &arcLineRects, &general_attribs_tree.GetTail());
						nCurVPos += nCurLineHeight;
						bIsLineEmpty = TRUE;
					}
					arcLineRects.RemoveAll();
					nCurLineHeight = 0;
					nCurHPos = 0;
					CRect rect;
					rect.left = nHrAlign == 0 ? 0 : (nHrAlign == 2 ? ga.nMaxWidth - nHrWidth : ga.nMaxWidth / 2 - nHrWidth / 2);
					rect.right = rect.left + nHrWidth;
					rect.top = nCurVPos + 2;
					rect.bottom = rect.top + nHrSize;
					normalDC.FillSolidRect(rect, crHrColor);
					nCurVPos += 4 + nHrSize;
				}
				else if (sCurTagName.IsEmpty() && sCurElement == _T("/a") && !sCurLink.IsEmpty()) // if we have an ending link tag AND valid link action and link region...
					sCurLink = _T("");
				else if (sCurTagName == _T("img") && !sBitmap.IsEmpty())
				{
					if (sBitmap[0] == _T('#')) // only resource bitmaps allowed at this time
					{
						CBitmap bmp;
						bmp.LoadBitmap(_tstoi(sBitmap.Mid(1)));
						Parse_AppendBitmap(&lineDC, &hover_lineDC, &nCurHPos, &nCurVPos, &nCurLineHeight, &arcLineRects, &general_attribs_tree.GetTail(), &bmp, crBitmap, nBitmapBorder, sCurLink, link);
						bIsLineEmpty = FALSE;
					}
					crBitmap = CLR_NONE;
					nBitmapBorder = 0;
					sBitmap = _T("");
				}
				else if (sCurTagName == _T("br") || (sCurTagName.IsEmpty() && sCurElement == _T("br"))) // just substitute with newline character
				{
					sData.SetAt(i, _T('\n'));
					i--;
				}
				else if (sCurTagName == _T("p") || (sCurTagName.IsEmpty() && sCurElement == _T("p"))) // just substitute with 2 newline characters
				{
					sData.SetAt(i, _T('\n'));
					sData.SetAt(i - 1, _T('\n'));
					i-= 2;
				}
				sCurElement = _T("");
				bInsideTag = FALSE;
				continue;
			}
			if (sData[i] == _T(' ') && !bIsOption)
			{
				if (!sCurElement.IsEmpty())
				{
					if (sCurTagName.IsEmpty())
					{
						sCurTagName = sCurElement;
						sCurTagName.MakeLower();
						if (sCurTagName == _T("font")) // store latest font attributes. these are the ones that are modified by the font tags parameters
						{
							fa = font_attribs_tree.GetTail();
							ga = general_attribs_tree.GetTail();
						}
						else if (sCurTagName == _T("hr")) // set default hr options...
						{
							crHrColor = GetSysColor(COLOR_BTNSHADOW);
							nHrWidth = ga.nMaxWidth - 10;
							nHrSize = 2;
							nHrAlign = 1;
						}
						else if (sCurTagName == _T("a")) // init link hot attributes
						{
							link = font_attribs_tree.GetTail();
							link.crColor = 0xeeffffff;
							link.crBkColor = 0xeeffffff;
							link.bBold = -10;
							link.bItalic = -10;
							link.bUnderline = -10;
							link.bStrikeout = -10;
							link.nSize = 0;
							link.szName[0] = _T('\0');
						}
						else if (sCurTagName == _T("img"))
						{
							nBitmapBorder = 2;
							crBitmap = CLR_NONE;
							sBitmap = _T("");
						}
					}
					else
					{
						sCurOption = sCurTagName;
						sCurOption.MakeLower();
					}
				}
				sCurElement = _T("");
				continue;
			}
			if (sData[i] == _T('"') || sData[i] == _T('\'')) // this happens when we have a new parameter value to parse
			{
				if (bIsOption && sData[i] == cTmp) // "sData[i]==cTmp" : closing (double)quote has to match opening quote
				{
					if (sCurTagName == _T("font")) // parse font tag paramaters
					{
						if (sCurOption == _T("size")) // font size
						{
							int	nSize = _tstoi(sCurElement);

							if (nSize > 0 && nSize < 2000) // let's be reasonable
								fa.nSize = nSize;
						}
						else if (sCurOption == _T("face")) // font face
							_tcscpy(fa.szName, sCurElement.Left(MAX_PATH - 1));
						else if (sCurOption == _T("style")) // font style (bold (b) , italic (i) , underline (u) , strikeout (s) )
						{
							if (sCurElement.Find(_T("-b")) != -1 || sCurElement.Find(_T("-B")) != -1)
								fa.bBold = FALSE;
							else if (sCurElement.FindOneOf(_T("bB")) != -1)
								fa.bBold = TRUE;
							if (sCurElement.Find(_T("-i")) != -1 || sCurElement.Find(_T("-I")) != -1)
								fa.bItalic = FALSE;
							else if (sCurElement.FindOneOf(_T("iI")) != -1)
								fa.bItalic = TRUE;
							if (sCurElement.Find(_T("-u")) != -1 || sCurElement.Find(_T("-U")) != -1)
								fa.bUnderline = FALSE;
							else if (sCurElement.FindOneOf(_T("uU")) != -1)
								fa.bUnderline = TRUE;
							if (sCurElement.Find(_T("-s")) != -1 || sCurElement.Find(_T("-S")) != -1)
								fa.bStrikeout = FALSE;
							else if (sCurElement.FindOneOf(_T("sS")) != -1)
								fa.bStrikeout = TRUE;
						}
						else if (sCurOption == _T("color")) // font color
							StringToColor(sCurElement, fa.crColor);
						else if (sCurOption == _T("background")) // font background-color
							StringToColor(sCurElement, fa.crBkColor);
						else if (sCurOption == _T("align")) // horisontal font alignment. here we change the "general_attribs"
						{					// only the latest open font tag with this parameter takes effect at a line break!!
							sCurElement.MakeLower();
							if (sCurElement == _T("left"))
								ga.nAlign = 0;
							else if (sCurElement == _T("center"))
								ga.nAlign = 1;
							else if (sCurElement == _T("right"))
								ga.nAlign = 2;
						}
						else if (sCurOption == _T("valign")) // vertical font alignment. here we change the "general_attribs"
						{
							sCurElement.MakeLower();
							if (sCurElement == _T("top"))
								ga.nVAlign = 0;
							else if (sCurElement == _T("middle"))
								ga.nVAlign = 1;
							else if (sCurElement == _T("bottom"))
								ga.nVAlign = 2;
						}
					}
					else if (sCurTagName == _T("a"))
					{
						if (sCurOption == _T("href")) // what to do
							sCurLink = sCurElement;
						else if (sCurOption == _T("size")) // font size
						{
							int	nSize = _tstoi(sCurElement);

							if (nSize > 0 && nSize < 2000) // let's be reasonable
								link.nSize = nSize;
						}
						else if (sCurOption == _T("face")) // font face
						{
							_tcscpy(link.szName, sCurElement.Left(MAX_PATH - 1));
						}
						else if (sCurOption == _T("style")) // font style (bold (b) , italic (i) , underline (u) , strikeout (s) )
						{
							if (sCurElement.Find(_T("-b")) != -1 || sCurElement.Find(_T("-B")) != -1)
								link.bBold = FALSE;
							else if (sCurElement.FindOneOf(_T("bB")) != -1)
								link.bBold = TRUE;
							if (sCurElement.Find(_T("-i")) != -1 || sCurElement.Find(_T("-I")) != -1)
								link.bItalic = FALSE;
							else if (sCurElement.FindOneOf(_T("iI")) != -1)
								link.bItalic = TRUE;
							if (sCurElement.Find(_T("-u")) != -1 || sCurElement.Find(_T("-U")) != -1)
								link.bUnderline = FALSE;
							else if (sCurElement.FindOneOf(_T("uU")) != -1)
								link.bUnderline = TRUE;
							if (sCurElement.Find(_T("-s")) != -1 || sCurElement.Find(_T("-S")) != -1)
								link.bStrikeout = FALSE;
							else if (sCurElement.FindOneOf(_T("sS")) != -1)
								link.bStrikeout = TRUE;
						}
						else if (sCurOption == _T("color")) // font color
							StringToColor(sCurElement, link.crColor);
						else if (sCurOption == _T("background")) // font background-color
							StringToColor(sCurElement, link.crBkColor);
					}
					else if (sCurTagName == _T("img")) // image tag: <img src="#resourceID">
					{
						// TODO: alow usage of filenames in <img> tag
						if (sCurOption == _T("src") && !sCurElement.IsEmpty())
							sBitmap = sCurElement;
						if (sCurOption == _T("color"))
							StringToColor(sCurElement, crBitmap);
						if (sCurOption == _T("border") && !sCurElement.IsEmpty())
							nBitmapBorder = _tstoi(sCurElement);
					}
					else if (sCurTagName == _T("hr")) // horisontal ruler
					{
						if (!sCurElement.IsEmpty())
						{
							if (sCurOption == _T("color")) // color
								StringToColor(sCurElement, crHrColor);
							else if (sCurOption == _T("width")) // width
								nHrWidth = _tstoi(sCurElement);
							else if (sCurOption == _T("size")) // height
								nHrSize = _tstoi(sCurElement);
							else if (sCurOption == _T("align")) // horz alignment
							{
								sCurElement.MakeLower();
								if (sCurElement == _T("left"))
									nHrAlign = 0;
								else if (sCurElement == _T("right"))
									nHrAlign = 2;
								else
									nHrAlign = 1;
							}
						}
					}
					else if ((sCurTagName == _T("vspace")) && (sCurOption == _T("size"))) // vertical space
					{
						if (!bIsLineEmpty) // insert linebreak only is line isn't empty
						{
							Parse_VAlignLine(&normalDC, &hotDC, &lineDC, &hover_lineDC, nCurHPos, nCurVPos, nCurLineHeight, &arcLineRects, &general_attribs_tree.GetTail());
							nCurVPos += nCurLineHeight;
							bIsLineEmpty = TRUE;
						}
						arcLineRects.RemoveAll();
						nCurLineHeight = 0;
						nCurHPos = 0;
						nCurVPos += _tstoi(sCurElement); // add "size" parameters value to vertical offset
					}
					else if ((sCurTagName == _T("hspace")) && (sCurOption == _T("size"))) // horisontal space
						nCurHPos += _tstoi(sCurElement); // add "size" parameters value to horisontal offset
					sCurElement = _T("");
					bIsOption = FALSE;
				}
				else if (sData[i - 1] == _T('=')) // parameter is beginning
				{
					sCurOption = sCurElement;
					sCurOption = sCurOption.Left(sCurOption.GetLength() - 1); // remove trailing "=";
					sCurOption.MakeLower();
					sCurOption.TrimRight();
					sCurElement = _T("");
					cTmp = sData[i];
					bIsOption = TRUE;
				}
				continue;
			}
			sCurElement += sData[i]; // append non-formatting-significant character to curent element
		}
	}
	lineDC.SelectObject(pOldBmp);
	hover_lineDC.SelectObject(pOldHoverBmp);

	// deselect bitmap
	normalDC.SelectObject(pOldBitmapNormal);
	hotDC.SelectObject(pOldBitmapHot);
	//... finished parsing

	m_nBitmapHeight = nCurVPos;

	// clean up (based on LIFO)
	hotDC.RestoreDC(nSaveDCHot);
	normalDC.RestoreDC(nSaveDCNormal);

	EMULE_CATCH2
}

void CCreditsCtrl::DrawBackground(CDC *pDC, RECT rect, BOOL bAnimate, DWORD lParam)
{
	NOPRM(bAnimate);
	pDC->FillSolidRect(&rect, (COLORREF)lParam);
}

void CCreditsCtrl::SetDefaultBkColor(COLORREF crColor)
{
	m_dwBackgroundPaintLParam = (DWORD)crColor; // default background color
}

void CCreditsCtrl::Parse_AppendText(CDC *pDC, CDC *pHoverDC, int *pnCurHPos, int *pnCurVPos, int *pnCurHeight, CArray<line_rect, line_rect&>* parcLineRects, general_attribs *pga, font_attribs *pfa, CString sText, CString sCurLink, font_attribs link)
{
	EMULE_TRY
	CRect rect(0, 0, pga->nMaxWidth, pga->nMaxHeight);
	CDC dc, hoverDC;
	CBitmap hoverBmp, bmp, *pOldHBmp;
	dc.CreateCompatibleDC(pDC);

	CFont font, hover_font, *pOldHFont;
	font.CreateFont( -pfa->nSize, 0, 0, 0, pfa->bBold ? FW_BOLD : 0,
		(BYTE)pfa->bItalic, (BYTE)pfa->bUnderline, (BYTE)pfa->bStrikeout, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, pfa->szName );
	CFont *pOldFont = dc.SelectObject(&font);

	dc.SetTextColor(pfa->crColor == CLR_NONE ? m_crInternalTransparentColor : pfa->crColor);
	dc.SetBkColor(pfa->crBkColor == CLR_NONE ? m_crInternalTransparentColor : pfa->crBkColor);
	dc.SetBkMode(OPAQUE);

	dc.DrawText(sText, rect, DT_CALCRECT | DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE);

	if (!sCurLink.IsEmpty())
	{
		if (link.bBold == -10) link.bBold = pfa->bBold;
		if (link.bItalic == -10) link.bItalic = pfa->bItalic;
		if (link.bUnderline == -10) link.bUnderline = pfa->bUnderline;
		if (link.bStrikeout == -10) link.bStrikeout = pfa->bStrikeout;
		if (link.crColor == 0xeeffffff) link.crColor = pfa->crColor;
		if (link.crBkColor == 0xeeffffff) link.crBkColor = pfa->crBkColor;
		if (link.nSize == 0) link.nSize = pfa->nSize;
		if (link.szName[0] == _T('\0')) _tcscpy(link.szName, pfa->szName);

		CRect rect2(0, 0, pga->nMaxWidth, pga->nMaxHeight);

		hoverDC.CreateCompatibleDC(pDC);

		hover_font.CreateFont( -link.nSize, 0, 0, 0, link.bBold ? FW_BOLD : 0,
			(BYTE)link.bItalic, (BYTE)link.bUnderline, (BYTE)link.bStrikeout, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, link.szName );
		pOldHFont = hoverDC.SelectObject(&hover_font);

		hoverDC.DrawText(sText, rect2, DT_CALCRECT | DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE);

		if (rect.Width() < rect2.Width())
			rect = rect2;

		hoverBmp.CreateCompatibleBitmap(pDC, rect.right, rect.bottom);
		pOldHBmp = hoverDC.SelectObject(&hoverBmp);

		hoverDC.FillSolidRect(rect, m_crInternalTransparentColor);
		hoverDC.SetTextColor(link.crColor == CLR_NONE ? m_crInternalTransparentColor : link.crColor);
		hoverDC.SetBkColor(link.crBkColor == CLR_NONE ? m_crInternalTransparentColor : link.crBkColor);
		hoverDC.SetBkMode(OPAQUE);

		hoverDC.DrawText(sText, rect, DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE);
	}

	bmp.CreateCompatibleBitmap(pDC, rect.right, rect.bottom);
	CBitmap *pOldBmp = dc.SelectObject(&bmp);

	dc.FillSolidRect(rect, m_crInternalTransparentColor);
	dc.SetBkColor(pfa->crBkColor == CLR_NONE ? m_crInternalTransparentColor : pfa->crBkColor);
	dc.DrawText(sText, rect, DT_NOPREFIX | DT_NOCLIP | DT_SINGLELINE);

	if (!sCurLink.IsEmpty())
	{
		Parse_AppendElement(pDC, pHoverDC, pnCurHPos, pnCurVPos, pnCurHeight, parcLineRects, pga, rect.Width(), rect.Height(), &dc, &hoverDC, sCurLink);
		hoverDC.SelectObject(pOldHBmp);
		hoverDC.SelectObject(pOldHFont);
	}
	else
		Parse_AppendElement(pDC, pHoverDC, pnCurHPos, pnCurVPos, pnCurHeight, parcLineRects, pga, rect.Width(), rect.Height(), &dc, &dc, sCurLink);

	// clean up
	dc.SelectObject(pOldBmp);
	dc.SelectObject(pOldFont);
	EMULE_CATCH2
}

void CCreditsCtrl::Parse_AppendBitmap(CDC *pDC, CDC *pHoverDC, int *pnCurHPos, int *pnCurVPos, int *pnCurHeight, CArray<line_rect, line_rect&>* parcLineRects, general_attribs *pga, CBitmap *pBitmap, COLORREF crBorder, int nBorder, CString sCurLink, font_attribs link)
{
	EMULE_TRY
	BITMAP bm;
	pBitmap->GetBitmap(&bm);

	CDC bmpDC;
	bmpDC.CreateCompatibleDC(pDC);
	CBitmap *pOldBmp1 = bmpDC.SelectObject(pBitmap);

	CDC dc;
	dc.CreateCompatibleDC(pDC);
	CBitmap bmp;
	bmp.CreateCompatibleBitmap(pDC, bm.bmWidth + nBorder * 2, bm.bmHeight + nBorder * 2);
	CBitmap *pOldBmp2 = dc.SelectObject(&bmp);
	dc.FillSolidRect(0, 0, bm.bmWidth + nBorder * 2, bm.bmHeight + nBorder * 2, crBorder == CLR_NONE ? m_crInternalTransparentColor : crBorder);
	dc.BitBlt(nBorder, nBorder, bm.bmWidth, bm.bmHeight, &bmpDC, 0, 0, SRCCOPY);

	if (sCurLink.IsEmpty())
		Parse_AppendElement(pDC, pHoverDC, pnCurHPos, pnCurVPos, pnCurHeight, parcLineRects, pga, bm.bmWidth + nBorder * 2, bm.bmHeight + nBorder * 2, &dc, &dc, sCurLink);
	else
	{
		CDC hoverDC;
		hoverDC.CreateCompatibleDC(pDC);
		CBitmap bmp;
		bmp.CreateCompatibleBitmap(pDC, bm.bmWidth + nBorder * 2, bm.bmHeight + nBorder * 2);
		CBitmap *pOldBmp = hoverDC.SelectObject(&bmp);
		hoverDC.FillSolidRect(0, 0, bm.bmWidth + nBorder * 2, bm.bmHeight + nBorder * 2, link.crColor == CLR_NONE ? m_crInternalTransparentColor : link.crColor == 0xeeffffff ? crBorder : link.crColor);
		hoverDC.BitBlt(nBorder, nBorder, bm.bmWidth, bm.bmHeight, &bmpDC, 0, 0, SRCCOPY);
		Parse_AppendElement(pDC, pHoverDC, pnCurHPos, pnCurVPos, pnCurHeight, parcLineRects, pga, bm.bmWidth + nBorder * 2, bm.bmHeight + nBorder * 2, &dc, &hoverDC, sCurLink);
		hoverDC.SelectObject(pOldBmp);
	}

	// clean up
	dc.SelectObject(pOldBmp2);
	bmpDC.SelectObject(pOldBmp1);
	EMULE_CATCH2
}

void CCreditsCtrl::Parse_AppendElement(CDC *pDC, CDC *pHoverDC, int *pnCurHPos, int *pnCurVPos, int *pnCurHeight, CArray<line_rect, line_rect&>* parcLineRects, general_attribs *pga, int nElementWidth, int nElementHeight, CDC *pElementDC, CDC *pHoverElementDC, CString sCurLink)
{
	NOPRM(pnCurVPos);

	EMULE_TRY

	if (*pnCurHeight < nElementHeight)
		*pnCurHeight = nElementHeight;

	CRect rect;
	rect.left = *pnCurHPos;
	rect.top = 0;
	rect.right = rect.left + nElementWidth;
	rect.bottom = nElementHeight;

	line_rect lr;
	lr.rcRect = rect;
	lr.nVAlign = pga->nVAlign;
	lr.sLink = sCurLink;
	parcLineRects->Add(lr);

	pDC->BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), pElementDC, 0, 0, SRCCOPY);
	pHoverDC->BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), pHoverElementDC, 0, 0, SRCCOPY);
	*pnCurHPos += nElementWidth;

	EMULE_CATCH2
}

void CCreditsCtrl::Parse_VAlignLine(CDC *pDestDC, CDC *pHoverDestDC, CDC *pLineDC, CDC *pHoverLineDC, int nCurHPos, int nCurVPos, int nCurHeight, CArray<line_rect, line_rect&>* parcLineRects, general_attribs *pga)
{
	EMULE_TRY
	{
		CArray<line_rect, line_rect&> LinkElements;
		CRect	rect;
		CDC		memDC;
		CBitmap	memBmp, *pOldBmp;
		int		i;

		memDC.CreateCompatibleDC(pDestDC);
		memBmp.CreateCompatibleBitmap(pDestDC, nCurHPos, nCurHeight);
		pOldBmp = memDC.SelectObject(&memBmp);
		memDC.FillSolidRect(0, 0, nCurHPos, nCurHeight, m_crInternalTransparentColor);
		for(i = 0; i < parcLineRects->GetSize(); i++)
		{
			rect.left = (*parcLineRects)[i].rcRect.left;
			// calculate elements vertical position
			if ((*parcLineRects)[i].nVAlign == 0) // top align
				rect.top = 0;
			else if ((*parcLineRects)[i].nVAlign == 1) // middle align
				rect.top = nCurHeight / 2 - (*parcLineRects)[i].rcRect.bottom / 2;
			else // bottom align
				rect.top = nCurHeight - (*parcLineRects)[i].rcRect.bottom;
			rect.bottom = rect.top + (*parcLineRects)[i].rcRect.bottom;
			// don't touch horz alignment
			rect.left = (*parcLineRects)[i].rcRect.left;
			rect.right = (*parcLineRects)[i].rcRect.right;

			// draw element
			memDC.BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), pLineDC, (*parcLineRects)[i].rcRect.left, (*parcLineRects)[i].rcRect.top, SRCCOPY);

			// add link to list(if necessary)
			if (!(*parcLineRects)[i].sLink.IsEmpty())
			{
				line_rect lr;
				lr.sLink = (*parcLineRects)[i].sLink;
				lr.rcRect = rect;
				LinkElements.Add(lr);
			}
		}

		rect.top = nCurVPos;
		rect.bottom = rect.top + nCurHeight;
		if (pga->nAlign == 0) // left align
			rect.left = 0;
		else if (pga->nAlign == 1) // center align
			rect.left = pga->nMaxWidth / 2 - nCurHPos / 2;
		else // right align
			rect.left = pga->nMaxWidth - nCurHPos;
		rect.right = rect.left + nCurHPos;

		TransparentBlt(&memDC, pDestDC, m_crInternalTransparentColor, rect, CRect(0, 0, rect.Width(), rect.Height()));
		memDC.SelectObject(pOldBmp);

		// calculate horisontal offset of links in list and add them to global list
		for(i = 0; i < LinkElements.GetSize(); i++)
		{
			CRect rc = LinkElements[i].rcRect;
			rc.OffsetRect(rect.left, nCurVPos);
			m_HotRects.Add(rc);
			m_HotRectActions.Add(LinkElements[i].sLink);
		}
	}

	// do the same, but this time for the hover CD
	{
		CRect rect;
		CDC memDC;
		memDC.CreateCompatibleDC(pHoverDestDC);
		CBitmap memBmp;
		memBmp.CreateCompatibleBitmap(pHoverDestDC, nCurHPos, nCurHeight);
		CBitmap *pOldBmp = memDC.SelectObject(&memBmp);
		memDC.FillSolidRect(0, 0, nCurHPos, nCurHeight, m_crInternalTransparentColor);
		for(int i = 0; i < parcLineRects->GetSize(); i++)
		{
			rect.left = (*parcLineRects)[i].rcRect.left;
			// calculate elements vertical position
			if ((*parcLineRects)[i].nVAlign == 0) // top align
				rect.top = 0;
			else if ((*parcLineRects)[i].nVAlign == 1) // middle align
				rect.top = nCurHeight / 2 - (*parcLineRects)[i].rcRect.bottom / 2;
			else // bottom align
				rect.top = nCurHeight - (*parcLineRects)[i].rcRect.bottom;
			rect.bottom = rect.top + (*parcLineRects)[i].rcRect.bottom;
			// don't touch horz alignment
			rect.left = (*parcLineRects)[i].rcRect.left;
			rect.right = (*parcLineRects)[i].rcRect.right;

			// draw element
			memDC.BitBlt(rect.left, rect.top, rect.Width(), rect.Height(), pHoverLineDC, (*parcLineRects)[i].rcRect.left, (*parcLineRects)[i].rcRect.top, SRCCOPY);
		}

		rect.top = nCurVPos;
		rect.bottom = rect.top + nCurHeight;
		if (pga->nAlign == 0) // left align
			rect.left = 0;
		else if (pga->nAlign == 1) // center align
			rect.left = pga->nMaxWidth / 2 - nCurHPos / 2;
		else // right align
			rect.left = pga->nMaxWidth - nCurHPos;
		rect.right = rect.left + nCurHPos;

		TransparentBlt(&memDC, pHoverDestDC, m_crInternalTransparentColor, rect, CRect(0, 0, rect.Width(), rect.Height()));
		memDC.SelectObject(pOldBmp);
	}
	EMULE_CATCH2
}

BOOL CCreditsCtrl::StringToColor(CString string, COLORREF &cr)
{
	int	i, r, g, b;

	if (string.IsEmpty())
		return FALSE;
	else if ((string == _T("none")) || (string == _T("transparant")))
		cr = CLR_NONE;
	else if ((i = string.Find(_T(','))) == -1)
		return FALSE;
	else
	{
		r = _tstoi(string.Left(i));
		string.Delete(0, i + 1);
		if ((i = string.Find(_T(','))) == -1)
			return FALSE;
		else
		{
			g = _tstoi(string.Left(i));
			string.Delete(0, i + 1);
			b = _tstoi(string);
			cr = RGB(r, g, b);
		}
	}
	return TRUE;
}

void CCreditsCtrl::OnMouseMove(UINT nFlags, CPoint point)
{
	NOPRM(nFlags);

	if (m_bIsScrolling)
	{
		m_nCurBitmapOffset = m_nScrollStart - point.y;
		m_nCurBitmapOffset %= m_nBitmapHeight;
		if (m_nCurBitmapOffset < 0)
			m_nCurBitmapOffset = m_nCurBitmapOffset + m_nBitmapHeight;
		Invalidate(FALSE);
		UpdateWindow();
		return;
	}
	if (GetCapture() == this)
		ReleaseCapture();
	else
		SetCapture();

	if (m_rcClient.PtInRect(point))
	{
		int n;
		CRect rect;
		if ((n = HitTest(point)) != -1)
		{
			rect = m_HotRects[n];
			SetCursor(m_hLinkCursor);
		}
		else
		{
			rect = CRect(0, 0, 0, 0);
			SetCursor(m_hDefaultCursor);
		}
		if (rect != m_rcHotRect)
		{
			m_rcHotRect = rect;
//			Invalidate(FALSE);
//			UpdateWindow();
		}
	}
}

void CCreditsCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	int n = HitTest(point);
	NOPRM(nFlags);

	if (n != -1)
	{
		m_rcHotRect = CRect(0, 0, 0, 0); // will be update next timer tick
		CString s = m_HotRectActions[n];
		if (s[0] == _T('#'))
		{
			int		i = s.Find(_T('#'), 1);
			CString	strArg;

			if (i >= 0)
				strArg = s.Mid(1, i - 1);
			s = s.Mid(i==-1 ? 1 : i + 1);

			void(*func)(LPCTSTR) = (void(*)(LPCTSTR))_tstol(s);

			if (func != NULL)
				(*func)((LPCTSTR)strArg);
		}
		else
			ShellExecute(NULL, NULL, s, NULL, NULL, SW_SHOW);
	}
	else if (m_bCanScroll && (m_nBitmapHeight > m_rcClient.bottom))
	{
		KillTimer(CCREDITCTRL_TIMER1);
		m_bIsScrolling = TRUE;
		m_nScrollStart = point.y + m_nCurBitmapOffset;
		Invalidate();
		UpdateWindow();
		SetCapture();
	}
}

void CCreditsCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	NOPRM(nFlags); NOPRM(point);

	if (m_bIsScrolling)
	{
		ReleaseCapture();
		m_bIsScrolling = FALSE;
		OnTimer(CCREDITCTRL_TIMER1);
	}
}

void CCreditsCtrl::OnCancelMode()
{
	if (m_bIsScrolling)
	{
		m_bIsScrolling = FALSE;
		OnTimer(CCREDITCTRL_TIMER1);
	}
	CWnd::OnCancelMode();
}

int CCreditsCtrl::HitTest(CPoint pt)
{
	if (m_nBitmapHeight <= m_rcClient.bottom)
	{
		for(int i = 0; i < m_HotRects.GetSize(); i++)
		{
			if (m_HotRects[i].PtInRect(pt))
				return i;
		}
		return -1;
	}

	pt.y += m_nCurBitmapOffset;
	CPoint pt0 = pt;
	if (pt0.y > m_nBitmapHeight - m_nCurBitmapOffset)
		pt0.y -= m_nBitmapHeight;

	for(int i = 0; i < m_HotRects.GetSize(); i++)
	{
		if (m_HotRects[i].PtInRect(pt) || m_HotRects[i].PtInRect(pt0))
			return i;
	}
	return -1;
}
@


1.18
log
@Introduces usage of new macro CSTRLEN.
@
text
@a6 2
#include <afxtempl.h>

a58 1
	//{{AFX_MSG_MAP(CCreditsCtrl)
d65 1
a65 1
	//}}AFX_MSG_MAP
d125 1
a125 1
	// draw backgorund
d528 2
a529 1
					font.CreateFont(-fa.nSize, 0, 0, 0, fa.bBold ? FW_BOLD : 0, fa.bItalic, fa.bUnderline, fa.bStrikeout, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, &fa.szName[0]);
d856 1
d874 2
a875 1
	font.CreateFont(-pfa->nSize, 0, 0, 0, pfa->bBold ? FW_BOLD : 0, pfa->bItalic, pfa->bUnderline, pfa->bStrikeout, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, pfa->szName);
d899 2
a900 1
		hover_font.CreateFont(-link.nSize, 0, 0, 0, link.bBold ? FW_BOLD : 0, link.bItalic, link.bUnderline, link.bStrikeout, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH | FF_DONTCARE, link.szName);
d982 2
d985 1
d1004 1
d1146 2
d1189 2
d1225 2
d1235 10
@


1.17
log
@Optimized DrawText -- no need to create temporary CString.
@
text
@d534 1
a534 1
					lineDC.DrawText(_T(" "), sizeof(_T(" "))/sizeof(TCHAR) - 1, rect, DT_CALCRECT);
@


1.16
log
@revert my latest change (1.15) as it is uneeded and bogus {Aw3}
@
text
@d534 1
a534 1
					lineDC.DrawText(_T(" "), rect, DT_CALCRECT);
@


1.15
log
@Fix window positioning in case of WS_POPUP usage (shouldn't happen)
@
text
@d104 1
a104 2
	if ((dwStyle & WS_CHILD) != 0)
		pParentWnd->ScreenToClient(&rect);
@


1.14
log
@UNICODE preparations
@
text
@d104 2
a105 1
	pParentWnd->ScreenToClient(&rect);
@


1.13
log
@Compatibility with VC2005 [brengarne]; Formatting.
@
text
@d23 1
a23 1
#endif 
d26 1
a26 1
#endif 
d39 1
a39 1
	m_crInternalTransparentColor = RGB(255,0,255);
d47 1
a47 1
	m_rcHotRect = CRect(0,0,0,0);
d54 3
a56 2
	//eklmn: destroy copied cursor on exit
	if (m_hLinkCursor) DestroyCursor(m_hLinkCursor);
d76 1
a76 1
	if(nLinkCursorID == 0)
d83 1
a83 1
		m_lpszClassName = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW);
d90 3
a92 3
	if(bResult)
		SetTimer(CCREDITCTRL_TIMER1,m_nTimerSpeed*5,NULL);
	
d113 1
a113 1
void CCreditsCtrl::OnPaint() 
d125 1
a125 1
	memBmp.CreateCompatibleBitmap(&dc,m_rcClient.Width(),m_rcClient.Height());
d129 2
a130 2
	if(m_pBackgroundPaint!=NULL)
		(*m_pBackgroundPaint)(&memDC,m_rcClient,m_bIsScrolling||bFirstDraw,m_dwBackgroundPaintLParam);
d137 1
a137 1
	if(m_rcHotRect != CRect(0,0,0,0))
d140 1
a140 1
		hotbgBmp.CreateCompatibleBitmap(&memDC,m_rcHotRect.Width(),m_rcHotRect.Height());
d143 1
a143 1
		if(m_nBitmapHeight <= m_rcClient.bottom)
d145 2
a146 2
		else if(m_nBitmapHeight-m_nCurBitmapOffset+m_rcHotRect.top < m_rcClient.bottom)
			rcHotRect.SetRect(m_rcHotRect.left,m_nBitmapHeight-m_nCurBitmapOffset+m_rcHotRect.top,m_rcHotRect.right,m_nBitmapHeight-m_nCurBitmapOffset+m_rcHotRect.bottom);
d148 1
a148 1
			rcHotRect.SetRect(m_rcHotRect.left,m_rcHotRect.top-m_nCurBitmapOffset,m_rcHotRect.right,m_rcHotRect.bottom-m_nCurBitmapOffset);
d150 1
a150 1
		hotBgDC.BitBlt(0,0,m_rcHotRect.Width(),m_rcHotRect.Height(),&memDC,rcHotRect.left,rcHotRect.top,SRCCOPY);
d154 1
a154 1
	if(m_nBitmapHeight <= m_rcClient.bottom)
d158 3
a160 2
		DrawTransparentBitmap(&m_bmpNormal,&memDC,m_crInternalTransparentColor,rect,rect);
	} else
d162 3
a164 3
		DrawTransparentBitmap(&m_bmpNormal,&memDC,m_crInternalTransparentColor,CRect(0,0,m_rcClient.right,min(m_nBitmapHeight-m_nCurBitmapOffset,m_rcClient.bottom)),CRect(0,m_nCurBitmapOffset,0,0/*the two last values are not taken into account by DrawTransparentBitmap anyway*/));
		if(m_nBitmapHeight-m_nCurBitmapOffset < m_rcClient.bottom)
			DrawTransparentBitmap(&m_bmpNormal,&memDC,m_crInternalTransparentColor,CRect(0,m_nBitmapHeight-m_nCurBitmapOffset,m_rcClient.right,m_rcClient.bottom),CRect(0,0,0,0/*the two last values are not taken into account by DrawTransparentBitmap anyway*/));
d168 1
a168 1
	if(m_rcHotRect != CRect(0,0,0,0))
d170 2
a171 2
		memDC.BitBlt(rcHotRect.left,rcHotRect.top,rcHotRect.Width(),rcHotRect.Height(),&hotBgDC,0,0,SRCCOPY);
		DrawTransparentBitmap(&m_bmpHot,&memDC,m_crInternalTransparentColor,rcHotRect,m_rcHotRect);
d174 1
a174 1
	
d176 1
a176 1
	dc.BitBlt(0,0,m_rcClient.Width(),m_rcClient.Height(),&memDC,0,0,SRCCOPY);
d182 1
a182 1
	if(bFirstDraw)
d191 1
a191 1
	if(IsWindow(m_hWnd))
d200 1
a200 1
	if(IsWindow(m_hWnd))
d208 1
a208 1
	
d217 1
a217 1
	if(IsWindow(m_hWnd)) // Initialize bitmaps if we have already been Create()d
d227 1
a227 1
	
d236 1
a236 1
	if(IsWindow(m_hWnd)) // Initialize bitmaps if we have already been Create()d
d251 1
a251 1
	{		
d269 1
a269 1
void CCreditsCtrl::OnTimer(UINT nIDEvent) 
d272 1
a272 1
	if(nIDEvent == CCREDITCTRL_TIMER1)
d274 1
a274 1
		if(IsWindowVisible())
d277 1
a277 1
			if(++m_nCurBitmapOffset > m_nBitmapHeight)
d281 1
a281 1
			CPoint point,pt;
d285 1
a285 1
			if(m_rcClient.PtInRect(point) && WindowFromPoint(pt)==this)
d289 1
a289 1
				if((n = HitTest(point)) != -1)
d296 1
a296 1
					rect = CRect(0,0,0,0);
d299 1
a299 1
				if(rect != m_rcHotRect)
d308 1
a308 1
			SetTimer(CCREDITCTRL_TIMER1,m_nTimerSpeed,NULL);
d310 2
a311 1
	} else
d316 1
a316 1
void CCreditsCtrl::OnSize(UINT nType, int cx, int cy) 
d318 3
a320 2
	if ((!cx && !cy) || (cx==m_oldcx && cy==m_oldcy)) return;
	
d322 4
a325 3
	m_oldcx=cx;m_oldcy=cy;
	
	if(IsWindow(m_hWnd))
d327 1
a327 1
	
d331 1
a331 1
void CCreditsCtrl::TransparentBlt(CDC *pSrcDC, CDC* pDestDC,COLORREF crTrans,const CRect& rcDest,const CRect& rcSrc)
d339 1
a339 1
	if(pDestDC->GetDeviceCaps(CAPS1) & C1_TRANSPARENT)
d346 2
a347 1
	} else	// if driver doesn't support transparent BitBlts, do it the hard way
d358 2
a359 2
		bmpTmp.CreateCompatibleBitmap(pDestDC,rcDest.Width(),rcDest.Height());
		bmpMask.CreateBitmap(rcDest.Width(),rcDest.Height(),1,1,NULL);
d364 1
a364 1
		tmpDC.BitBlt(0,0,rcDest.Width(),rcDest.Height(),pDestDC,rcDest.left,rcDest.top,SRCCOPY);
d368 1
a368 1
		maskDC.BitBlt(0,0,rcDest.Width(),rcDest.Height(),pSrcDC,rcSrc.left,rcSrc.top,SRCCOPY);
d371 6
a376 6
		tmpDC.SetBkColor(RGB(255,255,255));
		tmpDC.SetTextColor(RGB(0,0,0));
		tmpDC.BitBlt(0,0,rcDest.Width(),rcDest.Height(),pSrcDC,rcSrc.left,rcSrc.top,SRCINVERT);
		tmpDC.BitBlt(0,0,rcDest.Width(),rcDest.Height(),&maskDC,0,0,SRCAND);
		tmpDC.BitBlt(0,0,rcDest.Width(),rcDest.Height(),pSrcDC,rcSrc.left,rcSrc.top,SRCINVERT);
		
d378 1
a378 1
		pDestDC->BitBlt(rcDest.left,rcDest.top,rcDest.Width(),rcDest.Height(),&tmpDC,0,0,SRCCOPY);
d383 1
a383 1
		
d396 1
a396 1
void CCreditsCtrl::DrawTransparentBitmap(CBitmap* pBitmap, CDC* pDC,COLORREF crTrans,const CRect& rcDest,const CRect& rcSrc)
d407 1
a407 1
	TransparentBlt(&imageDC,pDC,crTrans,rcDest,rcSrc);
d435 1
a435 1
	if(m_bmpNormal.m_hObject)
d437 2
a438 2
	m_bmpNormal.CreateCompatibleBitmap(pDC,m_rcClient.Width(),nMaxHeight);
	if(m_bmpHot.m_hObject)
d440 1
a440 1
	m_bmpHot.CreateCompatibleBitmap(pDC,m_rcClient.Width(),nMaxHeight);
d447 2
a448 2
	normalDC.FillSolidRect(0,0,m_rcClient.right,nMaxHeight,m_crInternalTransparentColor);
	hotDC.FillSolidRect(0,0,m_rcClient.right,nMaxHeight,m_crInternalTransparentColor);
a450 5
	
	// substitute line break tags with newline characters
//	sData.Remove('\n');
//	sData.Replace("<br>","\n");
//	sData.Replace("<p>","\n\n");
d453 1
a453 1
	sData += '\n';
d456 1
a456 1
	CList<font_attribs,font_attribs&> font_attribs_tree;
d463 1
a463 1
	fa.crColor = RGB(0,0,0);
d465 1
a465 1
	_tcscpy(fa.szName,_T("Arial"));
d467 1
a467 1
	CList<general_attribs,general_attribs&> general_attribs_tree;
d482 1
a482 1
	CArray<line_rect,line_rect&> arcLineRects; // list containg information about the elements in the current line. used for vertical alignment of these element at line break.
d498 1
a498 1
	lineBmp.CreateCompatibleBitmap(&normalDC,ga.nMaxWidth,ga.nMaxHeight);
d504 1
a504 1
	hover_lineBmp.CreateCompatibleBitmap(&hotDC,ga.nMaxWidth,ga.nMaxHeight);
d511 1
a511 1
		if(!bInsideTag)
d513 1
a513 1
			if(sData[i] == '<')
d515 1
a515 1
				if(sCurElement != "")
d517 1
a517 1
					Parse_AppendText(&lineDC,&hover_lineDC,&nCurHPos,&nCurVPos,&nCurLineHeight,&arcLineRects,&general_attribs_tree.GetTail(),&font_attribs_tree.GetTail(),sCurElement, sCurLink, link);
d520 2
a521 2
				sCurTagName = "";
				sCurElement = "";
d525 1
a525 1
			if(sData[i] == '\n') // line break
d527 1
a527 1
				if(bIsLineEmpty) // if line is empty add the height of a space with the current font
d531 1
a531 1
					font.CreateFont(-fa.nSize,0,0,0,fa.bBold?FW_BOLD:0,fa.bItalic,fa.bUnderline,fa.bStrikeout,0,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,PROOF_QUALITY,DEFAULT_PITCH|FF_DONTCARE,&fa.szName[0]);
d533 2
a534 2
					CRect rect(0,0,ga.nMaxWidth,ga.nMaxHeight);
					lineDC.DrawText(_T(" "),rect,DT_CALCRECT);
d537 1
a537 1
				} 
d540 3
a542 3
					if(sCurElement != "")
						Parse_AppendText(&lineDC,&hover_lineDC,&nCurHPos,&nCurVPos,&nCurLineHeight,&arcLineRects,&general_attribs_tree.GetTail(),&font_attribs_tree.GetTail(),sCurElement,sCurLink,link);
					Parse_VAlignLine(&normalDC,&hotDC,&lineDC,&hover_lineDC,nCurHPos,nCurVPos,nCurLineHeight,&arcLineRects,&general_attribs_tree.GetTail());
d549 1
a549 1
				sCurElement = "";
d554 1
a554 1
		} 
d557 1
a557 1
			if(sData[i] == '>')
d559 1
a559 1
				if(sCurTagName == "font") // <font face="s" size="n" style="[-b|b][-i|i][-u|u][-s|s]" color="n,n,n" background="n,n,n">
d563 2
a564 2
				} 
				else if(sCurTagName == "" && sCurElement == "/font") // closing font tag.. revove the last attributes from the lists
d566 1
a566 1
					if(font_attribs_tree.GetCount() > 1)
d568 1
a568 1
					if(general_attribs_tree.GetCount() > 1)
d570 2
a571 2
				} 
				else if(sCurTagName == "" && sCurElement == "hr") // no parameters specified for the hr tag.. use the defaults
d574 1
a574 1
					nHrWidth = ga.nMaxWidth-100; // default width
d577 1
a577 1
					sCurTagName = "hr";
d579 1
a579 1
				if(sCurTagName == "hr") // wrap line is needed and draw rect
d581 1
a581 1
					if(!bIsLineEmpty)
d583 1
a583 1
						Parse_VAlignLine(&normalDC,&hotDC,&lineDC,&hover_lineDC,nCurHPos,nCurVPos,nCurLineHeight,&arcLineRects,&general_attribs_tree.GetTail());
d591 1
a591 1
					rect.left = nHrAlign == 0 ? 0 : (nHrAlign == 2 ? ga.nMaxWidth-nHrWidth : ga.nMaxWidth/2-nHrWidth/2);
d595 6
a600 6
					normalDC.FillSolidRect(rect,crHrColor);
					nCurVPos += 4+nHrSize;
				} 
				else if(sCurTagName == "" && sCurElement== "/a" && sCurLink != "") // if we have an ending link tag AND valid link action and link region...
					sCurLink = "";
				else if(sCurTagName == "img" && sBitmap != "")
d602 1
a602 1
					if(sBitmap[0]=='#') // only resource bitmaps allowed at this time
d606 1
a606 1
						Parse_AppendBitmap(&lineDC,&hover_lineDC,&nCurHPos,&nCurVPos,&nCurLineHeight,&arcLineRects,&general_attribs_tree.GetTail(),&bmp, crBitmap, nBitmapBorder, sCurLink, link);
d611 3
a613 3
					sBitmap = "";
				} 
				else if(sCurTagName == "br" || (sCurTagName == "" && sCurElement== "br")) // just substitute with newline character
d615 1
a615 1
					sData.SetAt(i,'\n');
d617 2
a618 2
				} 
				else if(sCurTagName == "p" || (sCurTagName == "" && sCurElement== "p")) // just substitute with 2 newline characters
d620 2
a621 2
					sData.SetAt(i,'\n');
					sData.SetAt(i-1,'\n');
d624 1
a624 1
				sCurElement = "";
d628 1
a628 1
			if(sData[i] == ' ' && !bIsOption)
d630 1
a630 1
				if(sCurElement != "")
d632 1
a632 1
					if(sCurTagName == "")
d636 1
a636 1
						if(sCurTagName == "font") // store latest font attributes. these are the ones that are modified by the font tags parameters
d640 2
a641 2
						} 
						else if(sCurTagName == "hr") // set default hr options...
d644 1
a644 1
							nHrWidth = ga.nMaxWidth-10;
d647 2
a648 2
						} 
						else if(sCurTagName == "a") // init link hot attributes
d658 3
a660 3
							link.szName[0] = '\0';
						} 
						else if(sCurTagName == "img")
d664 1
a664 1
							sBitmap = "";
d666 1
a666 1
					} 
d673 1
a673 1
				sCurElement = "";
d676 1
a676 1
			if(sData[i] == '"' || sData[i] == '\'') // this happens when we have a new parameter value to parse
d678 1
a678 1
				if(bIsOption && sData[i]==cTmp) // "sData[i]==cTmp" : closing (double)quote has to match opening quote
d680 1
a680 1
					if(sCurTagName == "font") // parse font tag paramaters
d682 1
a682 1
						if(sCurOption == "size") // font size
d684 3
a686 2
							int nSize = _tstoi(sCurElement);
							if(nSize > 0 && nSize < 2000) // let's be reasonable
d688 4
a691 2
						} 
						else if(sCurOption == "face") // font face
d693 1
a693 5
							_tcscpy(fa.szName,sCurElement.Left(MAX_PATH-1));
						} 
						else if(sCurOption == "style") // font style (bold (b) ,italic (i) ,underline (u) ,strikeout (s) )
						{
							if(sCurElement.Find(_T("-b"))!=-1 || sCurElement.Find(_T("-B"))!=-1)
d695 1
a695 1
							else if(sCurElement.FindOneOf(_T("bB"))!=-1)
d697 1
a697 1
							if(sCurElement.Find(_T("-i"))!=-1 || sCurElement.Find(_T("-I"))!=-1)
d699 1
a699 1
							else if(sCurElement.FindOneOf(_T("iI"))!=-1)
d701 1
a701 1
							if(sCurElement.Find(_T("-u"))!=-1 || sCurElement.Find(_T("-U"))!=-1)
d703 1
a703 1
							else if(sCurElement.FindOneOf(_T("uU"))!=-1)
d705 1
a705 1
							if(sCurElement.Find(_T("-s"))!=-1 || sCurElement.Find(_T("-S"))!=-1)
d707 1
a707 1
							else if(sCurElement.FindOneOf(_T("sS"))!=-1)
d709 6
a714 6
						} 
						else if(sCurOption == "color") // font color
							StringToColor(sCurElement,fa.crColor);
						else if(sCurOption == "background") // font background-color
							StringToColor(sCurElement,fa.crBkColor);
						else if(sCurOption == "align") // horisontal font alignment. here we change the "general_attribs"
d717 1
a717 1
							if(sCurElement == "left")
d719 1
a719 1
							else if(sCurElement == "center")
d721 1
a721 1
							else if(sCurElement == "right")
d723 2
a724 2
						} 
						else if(sCurOption == "valign") // vertical font alignment. here we change the "general_attribs"
d727 1
a727 1
							if(sCurElement == "top")
d729 1
a729 1
							else if(sCurElement == "middle")
d731 1
a731 1
							else if(sCurElement == "bottom")
d734 2
a735 2
					} 
					else if(sCurTagName == "a")
d737 1
a737 1
						if(sCurOption == "href") // what to do
d739 1
a739 1
						else if(sCurOption == "size") // font size
d741 3
a743 2
							int nSize = _tstoi(sCurElement);
							if(nSize > 0 && nSize < 2000) // let's be reasonable
d745 2
a746 2
						} 
						else if(sCurOption == "face") // font face
d748 3
a750 3
							_tcscpy(link.szName,sCurElement.Left(MAX_PATH-1));
						} 
						else if(sCurOption == "style") // font style (bold (b) ,italic (i) ,underline (u) ,strikeout (s) )
d752 1
a752 1
							if(sCurElement.Find(_T("-b"))!=-1 || sCurElement.Find(_T("-B"))!=-1)
d754 1
a754 1
							else if(sCurElement.FindOneOf(_T("bB"))!=-1)
d756 1
a756 1
							if(sCurElement.Find(_T("-i"))!=-1 || sCurElement.Find(_T("-I"))!=-1)
d758 1
a758 1
							else if(sCurElement.FindOneOf(_T("iI"))!=-1)
d760 1
a760 1
							if(sCurElement.Find(_T("-u"))!=-1 || sCurElement.Find(_T("-U"))!=-1)
d762 1
a762 1
							else if(sCurElement.FindOneOf(_T("uU"))!=-1)
d764 1
a764 1
							if(sCurElement.Find(_T("-s"))!=-1 || sCurElement.Find(_T("-S"))!=-1)
d766 1
a766 1
							else if(sCurElement.FindOneOf(_T("sS"))!=-1)
d768 7
a774 7
						} 
						else if(sCurOption == "color") // font color
							StringToColor(sCurElement,link.crColor);
						else if(sCurOption == "background") // font background-color
							StringToColor(sCurElement,link.crBkColor);
					} 
					else if(sCurTagName == "img") // image tag: <img src="#resourceID">
d777 1
a777 1
						if(sCurOption == "src" && sCurElement != "")
d779 3
a781 3
						if(sCurOption == "color")
							StringToColor(sCurElement,crBitmap);
						if(sCurOption == "border" && sCurElement != "")
d783 2
a784 2
					} 
					else if(sCurTagName == "hr") // horisontal ruler
d786 1
a786 1
						if(sCurElement != "")
d788 3
a790 3
							if(sCurOption == "color") // color
								StringToColor(sCurElement,crHrColor);
							else if(sCurOption == "width") // width
d792 1
a792 1
							else if(sCurOption == "size") // height
d794 1
a794 1
							else if(sCurOption == "align") // horz alignment
d797 1
a797 1
								if(sCurElement=="left")
d799 1
a799 1
								else if(sCurElement=="right")
d805 2
a806 2
					} 
					else if((sCurTagName == "vspace") && (sCurOption == "size")) // vertical space
d808 1
a808 1
						if(!bIsLineEmpty) // insert linebreak only is line isn't empty
d810 1
a810 1
							Parse_VAlignLine(&normalDC,&hotDC,&lineDC,&hover_lineDC,nCurHPos,nCurVPos,nCurLineHeight,&arcLineRects,&general_attribs_tree.GetTail());
d818 2
a819 2
					} 
					else if((sCurTagName == "hspace") && (sCurOption == "size")) // horisontal space
d821 1
a821 1
					sCurElement = "";
d823 2
a824 2
				} 
				else if(sData[i-1] == '=') // parameter is beginning
d827 1
a827 1
					sCurOption = sCurOption.Left(sCurOption.GetLength()-1); // remove trailing "=";
d830 1
a830 1
					sCurElement = "";
d852 1
a852 1
	
d858 1
a858 1
	pDC->FillSolidRect(&rect,(COLORREF)lParam);
d863 1
a863 1
	m_dwBackgroundPaintLParam = (DWORD)crColor; // default background color	
d866 1
a866 1
void CCreditsCtrl::Parse_AppendText(CDC *pDC, CDC *pHoverDC, int *pnCurHPos, int *pnCurVPos, int *pnCurHeight, CArray<line_rect,line_rect&>* parcLineRects, general_attribs *pga, font_attribs *pfa, CString sText, CString sCurLink, font_attribs link)
d869 3
a871 3
	CRect rect(0,0,pga->nMaxWidth,pga->nMaxHeight);
	CDC dc,hoverDC;
	CBitmap hoverBmp,bmp,*pOldHBmp;
d874 2
a875 2
	CFont font,hover_font,*pOldHFont;
	font.CreateFont(-pfa->nSize,0,0,0,pfa->bBold?FW_BOLD:0,pfa->bItalic,pfa->bUnderline,pfa->bStrikeout,0,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,PROOF_QUALITY,DEFAULT_PITCH|FF_DONTCARE,pfa->szName);
d877 1
a877 1
	
a880 2
		
	dc.DrawText(sText,rect,DT_CALCRECT|DT_NOPREFIX|DT_NOCLIP|DT_SINGLELINE);
d882 3
a884 1
	if(sCurLink != "")
d886 8
a893 8
		if(link.bBold == -10) link.bBold = pfa->bBold;
		if(link.bItalic == -10) link.bItalic = pfa->bItalic;
		if(link.bUnderline == -10) link.bUnderline = pfa->bUnderline;
		if(link.bStrikeout == -10) link.bStrikeout = pfa->bStrikeout;
		if(link.crColor == 0xeeffffff) link.crColor = pfa->crColor;
		if(link.crBkColor == 0xeeffffff) link.crBkColor = pfa->crBkColor;
		if(link.nSize == 0) link.nSize = pfa->nSize;
		if(link.szName[0] == '\0') _tcscpy(link.szName,pfa->szName);
d895 1
a895 1
		CRect rect2(0,0,pga->nMaxWidth,pga->nMaxHeight);
d899 1
a899 1
		hover_font.CreateFont(-link.nSize,0,0,0,link.bBold?FW_BOLD:0,link.bItalic,link.bUnderline,link.bStrikeout,0,OUT_DEFAULT_PRECIS,CLIP_DEFAULT_PRECIS,PROOF_QUALITY,DEFAULT_PITCH|FF_DONTCARE,link.szName);
d902 1
a902 1
		hoverDC.DrawText(sText,rect2,DT_CALCRECT|DT_NOPREFIX|DT_NOCLIP|DT_SINGLELINE);
d904 1
a904 1
		if(rect.Width() < rect2.Width())
d907 1
a907 1
		hoverBmp.CreateCompatibleBitmap(pDC,rect.right,rect.bottom);
d910 1
a910 1
		hoverDC.FillSolidRect(rect,m_crInternalTransparentColor);
d915 1
a915 1
		hoverDC.DrawText(sText,rect,DT_NOPREFIX|DT_NOCLIP|DT_SINGLELINE);
d917 2
a918 2
	
	bmp.CreateCompatibleBitmap(pDC,rect.right,rect.bottom);
d921 1
a921 1
	dc.FillSolidRect(rect,m_crInternalTransparentColor);
d923 1
a923 1
	dc.DrawText(sText,rect,DT_NOPREFIX|DT_NOCLIP|DT_SINGLELINE);
d925 1
a925 1
	if(sCurLink != "")
d927 1
a927 1
		Parse_AppendElement(pDC,pHoverDC,pnCurHPos,pnCurVPos,pnCurHeight,parcLineRects,pga,rect.Width(),rect.Height(),&dc,&hoverDC,sCurLink);
d932 1
a932 1
		Parse_AppendElement(pDC,pHoverDC,pnCurHPos,pnCurVPos,pnCurHeight,parcLineRects,pga,rect.Width(),rect.Height(),&dc,&dc,sCurLink);
d940 1
a940 1
void CCreditsCtrl::Parse_AppendBitmap(CDC *pDC, CDC *pHoverDC, int *pnCurHPos, int *pnCurVPos, int *pnCurHeight, CArray<line_rect,line_rect&>* parcLineRects, general_attribs *pga, CBitmap *pBitmap, COLORREF crBorder, int nBorder, CString sCurLink, font_attribs link)
d945 1
a945 1
	
d953 1
a953 1
	bmp.CreateCompatibleBitmap(pDC,bm.bmWidth+nBorder*2,bm.bmHeight+nBorder*2);
d955 2
a956 2
	dc.FillSolidRect(0,0,bm.bmWidth+nBorder*2,bm.bmHeight+nBorder*2,crBorder==CLR_NONE?m_crInternalTransparentColor:crBorder);
	dc.BitBlt(nBorder,nBorder,bm.bmWidth,bm.bmHeight,&bmpDC,0,0,SRCCOPY);
d958 2
a959 2
	if(sCurLink == "")
		Parse_AppendElement(pDC,pHoverDC,pnCurHPos,pnCurVPos,pnCurHeight,parcLineRects,pga,bm.bmWidth+nBorder*2,bm.bmHeight+nBorder*2,&dc,&dc,sCurLink);
d965 5
a969 5
		bmp.CreateCompatibleBitmap(pDC,bm.bmWidth+nBorder*2,bm.bmHeight+nBorder*2);
		CBitmap *pOldBmp = hoverDC.SelectObject(&bmp);	
		hoverDC.FillSolidRect(0,0,bm.bmWidth+nBorder*2,bm.bmHeight+nBorder*2,link.crColor==CLR_NONE?m_crInternalTransparentColor:link.crColor==0xeeffffff?crBorder:link.crColor);
		hoverDC.BitBlt(nBorder,nBorder,bm.bmWidth,bm.bmHeight,&bmpDC,0,0,SRCCOPY);
		Parse_AppendElement(pDC,pHoverDC,pnCurHPos,pnCurVPos,pnCurHeight,parcLineRects,pga,bm.bmWidth+nBorder*2,bm.bmHeight+nBorder*2,&dc,&hoverDC,sCurLink);
d979 1
a979 1
void CCreditsCtrl::Parse_AppendElement(CDC *pDC, CDC *pHoverDC, int *pnCurHPos, int *pnCurVPos, int *pnCurHeight, CArray<line_rect,line_rect&>* parcLineRects, general_attribs *pga, int nElementWidth, int nElementHeight, CDC *pElementDC, CDC *pHoverElementDC, CString sCurLink)
d982 1
a982 1
	if(*pnCurHeight < nElementHeight)
d984 1
a984 1
	
d988 1
a988 1
	rect.right = rect.left+nElementWidth;
d997 3
a999 3
	pDC->BitBlt(rect.left,rect.top,rect.Width(),rect.Height(),pElementDC,0,0,SRCCOPY);
	pHoverDC->BitBlt(rect.left,rect.top,rect.Width(),rect.Height(),pHoverElementDC,0,0,SRCCOPY);
	*pnCurHPos += nElementWidth;	
d1003 1
a1003 1
void CCreditsCtrl::Parse_VAlignLine(CDC *pDestDC, CDC *pHoverDestDC, CDC *pLineDC, CDC *pHoverLineDC, int nCurHPos, int nCurVPos, int nCurHeight, CArray<line_rect,line_rect&>* parcLineRects, general_attribs *pga)
d1007 1
a1007 1
		CArray<line_rect,line_rect&> LinkElements;
d1021 1
a1021 1
			if((*parcLineRects)[i].nVAlign == 0) // top align
d1023 2
a1024 2
			else if((*parcLineRects)[i].nVAlign == 1) // middle align
				rect.top = nCurHeight/2-(*parcLineRects)[i].rcRect.bottom/2;
d1033 1
a1033 1
			memDC.BitBlt(rect.left,rect.top,rect.Width(),rect.Height(),pLineDC,(*parcLineRects)[i].rcRect.left,(*parcLineRects)[i].rcRect.top,SRCCOPY);
d1036 1
a1036 1
			if((*parcLineRects)[i].sLink != "")
d1047 1
a1047 1
		if(pga->nAlign == 0) // left align
d1049 2
a1050 2
		else if(pga->nAlign == 1) // center align
			rect.left = pga->nMaxWidth/2 - nCurHPos/2;
d1055 1
a1055 1
		TransparentBlt(&memDC,pDestDC,m_crInternalTransparentColor,rect,CRect(0,0,rect.Width(),rect.Height()));
d1062 1
a1062 1
			rc.OffsetRect(rect.left,nCurVPos);
d1074 1
a1074 1
		memBmp.CreateCompatibleBitmap(pHoverDestDC,nCurHPos,nCurHeight);
d1076 1
a1076 1
		memDC.FillSolidRect(0,0,nCurHPos,nCurHeight,m_crInternalTransparentColor);
d1081 1
a1081 1
			if((*parcLineRects)[i].nVAlign == 0) // top align
d1083 2
a1084 2
			else if((*parcLineRects)[i].nVAlign == 1) // middle align
				rect.top = nCurHeight/2-(*parcLineRects)[i].rcRect.bottom/2;
d1093 1
a1093 1
			memDC.BitBlt(rect.left,rect.top,rect.Width(),rect.Height(),pHoverLineDC,(*parcLineRects)[i].rcRect.left,(*parcLineRects)[i].rcRect.top,SRCCOPY);
d1098 1
a1098 1
		if(pga->nAlign == 0) // left align
d1100 2
a1101 2
		else if(pga->nAlign == 1) // center align
			rect.left = pga->nMaxWidth/2 - nCurHPos/2;
d1106 1
a1106 1
		TransparentBlt(&memDC,pHoverDestDC,m_crInternalTransparentColor,rect,CRect(0,0,rect.Width(),rect.Height()));
d1114 3
a1116 2
	int i,r,g,b;
	if(string=="")
d1118 1
a1118 1
	else if((string=="none")||(string=="transparant"))
d1120 1
a1120 1
	else if((i = string.Find(','))==-1)
d1125 2
a1126 2
		string.Delete(0,i+1);
		if((i = string.Find(','))==-1)
d1131 1
a1131 1
			string.Delete(0,i+1);
d1133 1
a1133 1
			cr = RGB(r,g,b);
d1139 1
a1139 1
void CCreditsCtrl::OnMouseMove(UINT nFlags, CPoint point) 
d1141 1
a1141 1
	if(m_bIsScrolling)
d1143 1
a1143 1
		m_nCurBitmapOffset = m_nScrollStart-point.y;
d1145 2
a1146 2
		if(m_nCurBitmapOffset < 0)
			m_nCurBitmapOffset = m_nCurBitmapOffset+m_nBitmapHeight;
d1151 1
a1151 1
	if(GetCapture()==this)
d1156 1
a1156 1
	if(m_rcClient.PtInRect(point))
d1160 1
a1160 1
		if((n = HitTest(point)) != -1)
d1167 1
a1167 1
			rect = CRect(0,0,0,0);
d1170 1
a1170 1
		if(rect != m_rcHotRect)
d1179 1
a1179 1
void CCreditsCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
d1182 1
a1182 1
	if(n != -1)
d1184 1
a1184 1
		m_rcHotRect = CRect(0,0,0,0); // will be update next timer tick
d1186 1
a1186 1
		if(s[0] == '#')
d1188 7
a1194 3
			int i = s.Find('#',1);
			CString arg = i==-1?_T(""):s.Mid(1,i-1);
			s = s.Mid(i==-1?1:i+1);
d1196 8
a1203 5
			if(func)
				(*func)(i==-1?NULL:(LPCTSTR)arg);
		} else
			ShellExecute(NULL,NULL,s,NULL,NULL,SW_SHOW);
	} else if(m_bCanScroll && (m_nBitmapHeight > m_rcClient.bottom))
d1214 1
a1214 1
void CCreditsCtrl::OnLButtonUp(UINT nFlags, CPoint point) 
d1216 1
a1216 1
	if(m_bIsScrolling)
d1226 1
a1226 1
	if(m_nBitmapHeight <= m_rcClient.bottom)
d1230 1
a1230 1
			if(m_HotRects[i].PtInRect(pt))
d1238 1
a1238 1
	if(pt0.y > m_nBitmapHeight-m_nCurBitmapOffset)
d1243 1
a1243 1
		if(m_HotRects[i].PtInRect(pt) || m_HotRects[i].PtInRect(pt0))
@


1.12
log
@Corrected output of '&' in Credit Control.
@
text
@d1007 4
a1011 2
		CRect rect;
		CDC memDC;
d1013 4
a1016 5
		CBitmap memBmp;
		memBmp.CreateCompatibleBitmap(pDestDC,nCurHPos,nCurHeight);
		CBitmap *pOldBmp = memDC.SelectObject(&memBmp);
		memDC.FillSolidRect(0,0,nCurHPos,nCurHeight,m_crInternalTransparentColor);
		for(int i = 0; i < parcLineRects->GetSize(); i++)
@


1.11
log
@minor changes
@
text
@d881 1
a881 1
	dc.DrawText(sText,rect,DT_CALCRECT|DT_SINGLELINE);
d901 1
a901 1
		hoverDC.DrawText(sText,rect2,DT_CALCRECT|DT_SINGLELINE);
d914 1
a914 1
		hoverDC.DrawText(sText,rect,DT_SINGLELINE);
d922 1
a922 1
	dc.DrawText(sText,rect,DT_SINGLELINE);
@


1.10
log
@Fade-in effect for Splash & About dialogs (Windows 2000 and above only)
@
text
@d90 1
a90 1
		SetTimer(CCREDITCTRL_TIMER1,m_nTimerSpeed*6,NULL);
@


1.9
log
@intialization some variables in constructor
@
text
@d90 1
a90 1
		SetTimer(CCREDITCTRL_TIMER1,m_nTimerSpeed*10,NULL);
@


1.8
log
@resource leak by copying of cursor
@
text
@d46 4
@


1.7
log
@1) bugfixing in resource cleanup
2) optimizazion in OnSize
@
text
@d50 2
@


1.6
log
@unicode cleanup
@
text
@d119 1
a119 1
	memDC.SelectObject(&memBmp);
d127 2
a128 1
	CBitmap hotbgBmp,*pOldHBgBmp;
d170 2
d309 2
d312 1
d316 1
d327 1
a327 1
		// Only attempt this if device supports functionality. ( untested!! )
d348 2
a349 2
		tmpDC.SelectObject(&bmpTmp);
		maskDC.SelectObject(&bmpMask);
d368 6
a373 1
		// clean up
a374 1
		maskDC.RestoreDC(SaveMaskDC);
d384 1
a384 1
void CCreditsCtrl::DrawTransparentBitmap(CBitmap *pBitmap, CDC* pDC,COLORREF crTrans,const CRect& rcDest,const CRect& rcSrc)
d393 1
a393 1
	imageDC.SelectObject(pBitmap);
d397 2
d415 1
a415 1
	CDC *pDC = GetDC();
d431 2
a432 2
	normalDC.SelectObject(&m_bmpNormal);
	hotDC.SelectObject(&m_bmpHot);
d492 1
a492 1
	CBitmap *pOldBmp = lineDC.SelectObject(&lineBmp);
d498 1
a498 1
	CBitmap *pOldHoverBmp = hover_lineDC.SelectObject(&hover_lineBmp);
d525 1
a525 1
					CFont *pOldFont = lineDC.SelectObject(&font);
d834 4
d842 2
a843 1
	// clean up
d845 1
a845 1
	hotDC.RestoreDC(nSaveDCHot);
d1231 1
a1231 1
}@


1.5
log
@unicode cleanup
@
text
@d445 1
a445 1
	strcpy(fa.szName,"Arial");
d514 1
a514 1
					lineDC.DrawText(" ",rect,DT_CALCRECT);
d670 1
a670 1
							strcpy(fa.szName,sCurElement.Left(MAX_PATH-1));
d674 1
a674 1
							if(sCurElement.Find("-b")!=-1 || sCurElement.Find("-B")!=-1)
d676 1
a676 1
							else if(sCurElement.FindOneOf("bB")!=-1)
d678 1
a678 1
							if(sCurElement.Find("-i")!=-1 || sCurElement.Find("-I")!=-1)
d680 1
a680 1
							else if(sCurElement.FindOneOf("iI")!=-1)
d682 1
a682 1
							if(sCurElement.Find("-u")!=-1 || sCurElement.Find("-U")!=-1)
d684 1
a684 1
							else if(sCurElement.FindOneOf("uU")!=-1)
d686 1
a686 1
							if(sCurElement.Find("-s")!=-1 || sCurElement.Find("-S")!=-1)
d688 1
a688 1
							else if(sCurElement.FindOneOf("sS")!=-1)
d728 1
a728 1
							strcpy(link.szName,sCurElement.Left(MAX_PATH-1));
d732 1
a732 1
							if(sCurElement.Find("-b")!=-1 || sCurElement.Find("-B")!=-1)
d734 1
a734 1
							else if(sCurElement.FindOneOf("bB")!=-1)
d736 1
a736 1
							if(sCurElement.Find("-i")!=-1 || sCurElement.Find("-I")!=-1)
d738 1
a738 1
							else if(sCurElement.FindOneOf("iI")!=-1)
d740 1
a740 1
							if(sCurElement.Find("-u")!=-1 || sCurElement.Find("-U")!=-1)
d742 1
a742 1
							else if(sCurElement.FindOneOf("uU")!=-1)
d744 1
a744 1
							if(sCurElement.Find("-s")!=-1 || sCurElement.Find("-S")!=-1)
d746 1
a746 1
							else if(sCurElement.FindOneOf("sS")!=-1)
d868 1
a868 1
		if(link.szName[0] == '\0') strcpy(link.szName,pfa->szName);
d1162 1
a1162 1
			CString arg = i==-1?"":s.Mid(1,i-1);
@


1.4
log
@More try/catch according to crash dumps
@
text
@d585 1
a585 1
						bmp.LoadBitmap(atoi(sBitmap.Mid(1)));
d664 1
a664 1
							int nSize = atoi(sCurElement);
d722 1
a722 1
							int nSize = atoi(sCurElement);
d762 1
a762 1
							nBitmapBorder = atoi(sCurElement);
d771 1
a771 1
								nHrWidth = atoi(sCurElement);
d773 1
a773 1
								nHrSize = atoi(sCurElement);
d797 1
a797 1
						nCurVPos += atoi(sCurElement); // add "size" parameters value to vertical offset
d800 1
a800 1
						nCurHPos += atoi(sCurElement); // add "size" parameters value to horisontal offset
d1097 1
a1097 1
		r = atoi(string.Left(i));
d1103 1
a1103 1
			g = atoi(string.Left(i));
d1105 1
a1105 1
			b = atoi(string);
d1164 1
a1164 1
			void(*func)(LPCTSTR) = (void(*)(LPCTSTR))atol(s);
@


1.3
log
@*** empty log message ***
@
text
@d67 1
d87 2
d93 1
d99 2
d108 1
d173 1
d260 1
d301 1
d315 1
d370 1
d375 1
d388 1
d393 1
d828 1
d843 1
d912 1
d917 1
d951 1
d956 1
d975 1
d980 1
d1083 1
@


1.2
log
@new logo from DrSirius
@
text
@a835 3
	LOGFONT lfFont1;
	font.GetLogFont(&lfFont1);

@


1.1
log
@*** empty log message ***
@
text
@d502 2
a503 1
				} else
d519 2
a520 1
		} else
d528 2
a529 1
				} else if(sCurTagName == "" && sCurElement == "/font") // closing font tag.. revove the last attributes from the lists
d535 2
a536 1
				} else if(sCurTagName == "" && sCurElement == "hr") // no parameters specified for the hr tag.. use the defaults
d562 2
a563 1
				} else if(sCurTagName == "" && sCurElement== "/a" && sCurLink != "") // if we have an ending link tag AND valid link action and link region...
d577 2
a578 1
				} else if(sCurTagName == "br" || (sCurTagName == "" && sCurElement== "br")) // just substitute with newline character
d582 2
a583 1
				} else if(sCurTagName == "p" || (sCurTagName == "" && sCurElement== "p")) // just substitute with 2 newline characters
d605 2
a606 1
						} else if(sCurTagName == "hr") // set default hr options...
d612 2
a613 1
						} else if(sCurTagName == "a") // init link hot attributes
d624 2
a625 1
						} else if(sCurTagName == "img")
d631 2
a632 1
					} else
d652 2
a653 1
						} else if(sCurOption == "face") // font face
d656 2
a657 1
						} else if(sCurOption == "style") // font style (bold (b) ,italic (i) ,underline (u) ,strikeout (s) )
d675 2
a676 1
						} else if(sCurOption == "color") // font color
d689 2
a690 1
						} else if(sCurOption == "valign") // vertical font alignment. here we change the "general_attribs"
d700 2
a701 1
					} else if(sCurTagName == "a")
d710 2
a711 1
						} else if(sCurOption == "face") // font face
d714 2
a715 1
						} else if(sCurOption == "style") // font style (bold (b) ,italic (i) ,underline (u) ,strikeout (s) )
d733 2
a734 1
						} else if(sCurOption == "color") // font color
d738 2
a739 1
					} else if(sCurTagName == "img") // image tag: <img src="#resourceID">
d748 2
a749 1
					} else if(sCurTagName == "hr") // horisontal ruler
d770 2
a771 1
					} else if((sCurTagName == "vspace") && (sCurOption == "size")) // vertical space
d783 2
a784 1
					} else if((sCurTagName == "hspace") && (sCurOption == "size")) // horisontal space
d788 2
a789 1
				} else if(sData[i-1] == '=') // parameter is beginning
a802 1

d835 4
d842 1
a842 1
	
@


1.1.4.1
log
@updating this branch...
@
text
@@

