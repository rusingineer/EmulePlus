head	1.163;
access;
symbols
	PublicRelease_1_2e:1.153
	Interim_Release_1-2e_RC1:1.152
	PublicRelease_1_2d:1.149
	Interim_Release_1-2d_RC1:1.149
	Interim_Release_1-2d_beta1:1.149
	PublicRelease_1_2c:1.147
	Interim_Release_1-2c_RC1:1.147
	Interim_Release_1-2c_beta1:1.143
	PublicRelease_1_2b:1.143
	Interim_Release_1-2b_RC1:1.143
	PublicRelease_1_2a:1.142
	Interim_Release_1-2a_RC1:1.142
	Interim_Release_1-2a_beta2:1.139
	Interim_Release_1-2a_beta1:1.139
	PublicRelease_1_2:1.132
	Interim_Release_1-2_RC1:1.132
	Interim_Release_1-2_beta1:1.132
	PublicRelease_1_1g:1.131
	Interim_Release_1-1g_RC3:1.131
	Interim_Release_1-1g_RC2:1.131
	Interim_Release_1-1g_RC1:1.131
	Interim_Release_1-1g_beta2:1.129
	Interim_Release_1-1g_beta1:1.126
	PublicRelease_1_1f:1.125
	Interim_Release_1-1f_RC1:1.125
	PublicRelease_1_1e:1.125
	Interim_Release_1-1e_RC2:1.125
	Interim_Release_1-1e_RC1:1.125
	Interim_Release_1-1e_beta1:1.124
	PublicRelease_1_1d:1.122
	Interim_Release_1-1d_RC1:1.122
	PublicRelease_1_1c:1.122
	Interim_Release_1-1c_RC1:1.121
	Interim_Release_1-1c_beta2:1.121
	Interim_Release_1-1c_beta1:1.118
	PublicRelease_1_1b:1.118
	Interim_Release_1-1b_RC1:1.118
	PublicRelease_1_1a:1.118
	Interim_Release_1-1a_RC2:1.118
	Interim_Release_1-1a_RC1:1.117
	Interim_Release_1-1a_beta2:1.117
	Interim_Release_1-1a_beta1:1.117
	PublicRelease_1_1:1.116
	Interim_Release_1-1_beta1:1.116
	PublicRelease_1o:1.116
	Interim_Release_1o_RC1:1.116
	Interim_Release_1o_beta1:1.116
	PublicRelease_1n:1.116
	Interim_Release_1n_RC2:1.116
	Interim_Release_1n_RC1:1.116
	Interim_Release_1n_beta2:1.116
	Interim_Release_1n_beta1:1.116
	PublicRelease_1m:1.115
	Interim_Release_1m_beta1:1.115
	PublicRelease_1l:1.115
	Interim_Release_1l_RC3:1.115
	Interim_Release_1l_RC2:1.115
	Interim_Release_1l_RC1:1.112
	Interim_Release_1l_beta2:1.107
	Interim_Release_1l_beta1:1.105
	PublicRelease_1k:1.103
	Interim_Release_1k_RC4:1.103
	Interim_1k_RC3:1.102
	Interim_1k_RC2:1.102
	Interim_Release_1k_RC1:1.101
	Interim_Release_1k_beta5:1.100
	Intrerim_Release_1k_beta4:1.100
	Interim_Release_1k_beta1:1.100
	PublicRelease_1j:1.98
	Interim_Release_1J_RC3:1.95
	Interim_Release_1j_RC3:1.95
	Interim_Release_1j_RC2:1.94
	Interim_Release_1j_RC1:1.94
	Interim_Release_1j_beta2:1.94
	Interim_Release_1j_beta1:1.92
	PublicRelease_1i:1.82
	Interim_Release_1i_RC6:1.82
	Interim_Release_1i_RC3:1.80
	Interim_Release_1i_RC2:1.80
	Interim_Release_1i_RC1:1.80
	Interim_Release_1i_beta3:1.77
	Interim_Release_1i_beta2:1.74
	Interim_Release_1i_beta1:1.64
	PublicRelease_1h:1.61
	Interim_Release_1h_rc2:1.61
	Interim_Release_1h_RC1:1.61
	Interim_Release_1h_beta2:1.58
	Interim_Release_1h_beta1_now:1.57
	Interim_Release_1h_beta1:1.57
	PublicRelease_1g:1.51
	Interim_Release_1g_RC6_Final:1.51
	Interim_Release_1g_RC6:1.43
	Interim_Release_1g_RC5:1.37
	Interim_Release_1g_RC4:1.37
	Interim_Release_1g_RC3:1.36
	Interim_Release_1g_beta2:1.29
	Interim_Release_1g_beta1:1.26
	Interim_Release_1f_RC4:1.25
	Interim_Release_1f_RC3:1.25
	Interim_Release_1f_RC2:1.25
	Interim_Release_1f_RC:1.25
	Interim_Release_1f_beta2:1.22
	Interim_Release_1f_beta1:1.20
	PublicRelease_1e:1.19
	Interim_Release_1e_RC2:1.19
	Interim_Release_1e_RC:1.19
	Interim_Release_1e_beta3:1.19
	Interim_Release_1e_beta2:1.18
	Interim_Release_1e_beta2_before_kuchin:1.17
	Interim_Release_1e_beta1:1.16
	PublicRelease_1c:1.16
	featurestest:1.16.0.2
	Interim_Release_1c_RC:1.16
	Interim_Release_1c_beta2:1.14
	Interim_Release_1c_beta1:1.14
	threaded_downloadqueue:1.14.0.2
	PublicRelease_1b:1.12
	Interim_Release_1b_beta2:1.12
	Interim_Release_1b_beta1:1.12
	proxydeadlake:1.11.0.4
	PublicRelease_1a:1.11
	Interim_Release_1a_beta2:1.11
	BerkeleyDb:1.11.0.2
	Interim_Release_1a_beta1:1.11
	PublicRelease_1:1.11
	goldfish:1.11
	eMulePlus_1_RC2:1.11
	eMulePlus_26b_1RC1:1.11
	PreRelease_26b_i0e:1.11
	before_26d_merge:1.10
	Interim_Release_26b_i0d:1.10
	Interim_Release_26b_i0c:1.9
	Interim_Release_26b_i0b:1.8
	Interim_Release_26b_i0a:1.8
	systraydlg:1.7.0.4
	plus26based:1.7.0.2
	Interim_Release_25b_i0b:1.7
	Proxy_Dev:1.6
	Interim_Release_25b_i0a:1.5.2.3
	proxytest:1.5.2.2.0.2
	official_sockets:1.5.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.163
date	2010.08.11.04.37.50;	author aw3;	state Exp;
branches;
next	1.162;

1.162
date	2010.05.13.04.48.49;	author aw3;	state Exp;
branches;
next	1.161;

1.161
date	2009.12.11.06.32.14;	author aw3;	state Exp;
branches;
next	1.160;

1.160
date	2009.11.03.02.21.05;	author aw3;	state Exp;
branches;
next	1.159;

1.159
date	2009.10.30.01.59.03;	author aw3;	state Exp;
branches;
next	1.158;

1.158
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.157;

1.157
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.156;

1.156
date	2009.06.16.01.37.41;	author aw3;	state Exp;
branches;
next	1.155;

1.155
date	2009.06.12.02.03.19;	author aw3;	state Exp;
branches;
next	1.154;

1.154
date	2009.06.10.02.49.36;	author aw3;	state Exp;
branches;
next	1.153;

1.153
date	2009.04.10.03.37.49;	author aw3;	state Exp;
branches;
next	1.152;

1.152
date	2008.12.15.22.39.31;	author aw3;	state Exp;
branches;
next	1.151;

1.151
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.150;

1.150
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2008.02.10.04.59.46;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2007.10.11.18.06.27;	author fuxie-dk;	state Exp;
branches;
next	1.147;

1.147
date	2007.07.25.02.53.12;	author aw3;	state Exp;
branches;
next	1.146;

1.146
date	2007.07.14.20.34.57;	author aw3;	state Exp;
branches;
next	1.145;

1.145
date	2007.07.07.04.11.27;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2007.07.01.05.33.40;	author aw3;	state Exp;
branches;
next	1.143;

1.143
date	2006.11.16.05.51.47;	author aw3;	state Exp;
branches;
next	1.142;

1.142
date	2006.09.17.13.44.42;	author aw3;	state Exp;
branches;
next	1.141;

1.141
date	2006.09.05.01.10.47;	author aw3;	state Exp;
branches;
next	1.140;

1.140
date	2006.07.25.04.28.12;	author aw3;	state Exp;
branches;
next	1.139;

1.139
date	2006.04.19.06.14.00;	author aw3;	state Exp;
branches;
next	1.138;

1.138
date	2006.04.18.15.46.48;	author eklmn;	state Exp;
branches;
next	1.137;

1.137
date	2006.04.05.01.48.59;	author aw3;	state Exp;
branches;
next	1.136;

1.136
date	2006.04.04.22.28.42;	author kush_eplus;	state Exp;
branches;
next	1.135;

1.135
date	2006.03.26.21.08.56;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2006.03.19.23.44.11;	author aw3;	state Exp;
branches;
next	1.133;

1.133
date	2006.03.04.04.29.11;	author aw3;	state Exp;
branches;
next	1.132;

1.132
date	2006.01.15.07.19.52;	author aw3;	state Exp;
branches;
next	1.131;

1.131
date	2005.11.27.22.11.52;	author eklmn;	state Exp;
branches;
next	1.130;

1.130
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.129;

1.129
date	2005.11.23.04.00.32;	author aw3;	state Exp;
branches;
next	1.128;

1.128
date	2005.09.01.03.48.16;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2005.08.29.03.05.28;	author aw3;	state Exp;
branches;
next	1.126;

1.126
date	2005.08.04.03.32.16;	author aw3;	state Exp;
branches;
next	1.125;

1.125
date	2005.06.20.05.18.10;	author eklmn;	state Exp;
branches;
next	1.124;

1.124
date	2005.06.06.04.37.46;	author aw3;	state Exp;
branches;
next	1.123;

1.123
date	2005.05.29.18.51.20;	author aw3;	state Exp;
branches;
next	1.122;

1.122
date	2005.02.25.04.39.37;	author aw3;	state Exp;
branches;
next	1.121;

1.121
date	2005.02.16.05.10.11;	author aw3;	state Exp;
branches;
next	1.120;

1.120
date	2005.02.14.22.42.43;	author aw3;	state Exp;
branches;
next	1.119;

1.119
date	2005.02.04.23.41.56;	author aw3;	state Exp;
branches;
next	1.118;

1.118
date	2004.12.08.19.31.43;	author aw3;	state Exp;
branches;
next	1.117;

1.117
date	2004.11.06.04.43.11;	author aw3;	state Exp;
branches;
next	1.116;

1.116
date	2004.06.30.13.38.44;	author dongato;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.27.10.20.01;	author dongato;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.27.09.23.08;	author dongato;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.27.08.42.19;	author dongato;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.26.16.21.05;	author kuchin;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.25.18.18.44;	author dongato;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.25.10.28.43;	author dongato;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.24.09.53.43;	author dongato;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.21.18.37.19;	author dongato;	state Exp;
branches;
next	1.106;

1.106
date	2004.05.14.13.59.54;	author dongato;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.05.19.04.49;	author katsyonak;	state Exp;
branches;
next	1.104;

1.104
date	2004.04.24.00.01.27;	author aw3;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.06.18.45.39;	author dongato;	state Exp;
branches;
next	1.102;

1.102
date	2004.03.31.22.26.56;	author dropf;	state Exp;
branches;
next	1.101;

1.101
date	2004.03.25.20.29.37;	author aw3;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.20.00.22.26;	author kush_eplus;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.12.10.38.01;	author morevit;	state Exp;
branches;
next	1.98;

1.98
date	2004.01.25.22.55.17;	author kush_eplus;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.25.20.45.20;	author dongato;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.24.20.14.28;	author dongato;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.21.10.32.32;	author dongato;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.05.11.02.01;	author dongato;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.01.07.31.06;	author katsyonak;	state Exp;
branches;
next	1.92;

1.92
date	2003.12.27.11.26.50;	author katsyonak;	state Exp;
branches;
next	1.91;

1.91
date	2003.12.25.16.42.31;	author dongato;	state Exp;
branches;
next	1.90;

1.90
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.89;

1.89
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.88;

1.88
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.87;

1.87
date	2003.12.22.15.44.11;	author dongato;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.22.15.35.09;	author dongato;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.22.13.16.54;	author dongato;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.21.00.10.51;	author netwolf1;	state Exp;
branches;
next	1.83;

1.83
date	2003.12.18.21.52.47;	author dongato;	state Exp;
branches;
next	1.82;

1.82
date	2003.12.08.15.30.58;	author dongato;	state Exp;
branches;
next	1.81;

1.81
date	2003.12.08.15.11.41;	author dongato;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.04.04.49.11;	author dongato;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.02.11.17.17;	author eklmn;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.01.12.21.01;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2003.10.30.02.44.37;	author morevit;	state Exp;
branches;
next	1.76;

1.76
date	2003.10.29.17.04.52;	author katsyonak;	state Exp;
branches;
next	1.75;

1.75
date	2003.10.27.17.25.09;	author eklmn;	state Exp;
branches;
next	1.74;

1.74
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.73;

1.73
date	2003.10.20.09.32.03;	author netwolf1;	state Exp;
branches;
next	1.72;

1.72
date	2003.10.20.08.50.03;	author morevit;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.09.09.25.17;	author morevit;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.08.15.39.48;	author morevit;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.08.12.56.34;	author morevit;	state Exp;
branches;
next	1.66;

1.66
date	2003.10.08.01.53.33;	author morevit;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.27.19.59.42;	author dongato;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.22.16.43.19;	author morevit;	state Exp;
branches;
next	1.62;

1.62
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.61;

1.61
date	2003.09.11.10.04.10;	author dongato;	state Exp;
branches;
next	1.60;

1.60
date	2003.09.11.02.36.43;	author dongato;	state Exp;
branches;
next	1.59;

1.59
date	2003.09.09.22.21.17;	author dongato;	state Exp;
branches;
next	1.58;

1.58
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	1.57;

1.57
date	2003.08.04.21.24.38;	author zegzav;	state Exp;
branches;
next	1.56;

1.56
date	2003.08.02.11.51.11;	author dongato;	state Exp;
branches;
next	1.55;

1.55
date	2003.08.02.08.58.07;	author eklmn;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.31.15.02.20;	author puritynn666;	state Exp;
branches;
next	1.53;

1.53
date	2003.07.30.20.47.40;	author dongato;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.30.12.29.32;	author kuchin;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.23.21.28.46;	author eklmn;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.23.13.26.07;	author dongato;	state Exp;
branches;
next	1.49;

1.49
date	2003.07.22.16.31.58;	author eklmn;	state Exp;
branches;
next	1.48;

1.48
date	2003.07.20.16.51.07;	author eklmn;	state Exp;
branches;
next	1.47;

1.47
date	2003.07.20.15.55.03;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2003.07.20.12.11.24;	author eklmn;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.20.10.37.37;	author eklmn;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.20.09.17.58;	author eklmn;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.18.18.21.12;	author eklmn;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.18.18.10.30;	author eklmn;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.18.17.38.17;	author eklmn;	state Exp;
branches;
next	1.40;

1.40
date	2003.07.18.17.26.55;	author eklmn;	state Exp;
branches;
next	1.39;

1.39
date	2003.07.17.16.14.20;	author eklmn;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.15.20.57.31;	author syrus77;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.04.16.18.05;	author eklmn;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.24.18.06.07;	author eklmn;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.19.16.48.05;	author partyckip;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.16.10.42.14;	author kuchin;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.10.20.50.30;	author eklmn;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.10.12.53.59;	author kuchin;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.10.09.36.49;	author kuchin;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.08.07.36.58;	author partyckip;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.06.20.37.18;	author partyckip;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.04.19.57.49;	author partyckip;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.30.20.35.20;	author partyckip;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.12.19.04.34;	author lord_kiron;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.12.18.38.43;	author lord_kiron;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.12.12.04.22;	author partyckip;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.08.23.20.03;	author partyckip;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.08.08.23.31;	author partyckip;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.04.11.52.29;	author partyckip;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.24.08.35.42;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.22.12.41.52;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.18.11.10.04;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.22.01.14.00;	author cax2;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.21.18.48.52;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.14.16.24.23;	author partyckip;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.12.16.53.04;	author cax2;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.28.18.43.59;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches
	1.11.2.1
	1.11.4.1;
next	1.10;

1.10
date	2003.02.13.14.57.48;	author obaldin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.11.13.34.35;	author cax2;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.02.10.47.20;	author cax2;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.02.02.03.39.56;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.25.17.26.12;	author cax2;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.01.24.14.05.04;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.12.49.07;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.17.19.35;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.25;	author cax2;	state Exp;
branches;
next	;

1.5.2.1
date	2003.01.28.14.55.47;	author obaldin;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.01.28.22.27.11;	author maverick65;	state Exp;
branches
	1.5.2.2.2.1;
next	1.5.2.3;

1.5.2.3
date	2003.01.29.10.36.29;	author cax2;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.02.02.02.36.29;	author cax2;	state Exp;
branches;
next	;

1.5.2.2.2.1
date	2003.01.28.23.51.14;	author maverick65;	state Exp;
branches;
next	;

1.7.2.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.11.2.1
date	2003.03.01.20.59.38;	author obaldin;	state Exp;
branches;
next	;

1.11.4.1
date	2003.02.28.10.48.31;	author dongato;	state Exp;
branches;
next	;


desc
@@


1.163
log
@Minor renaming.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "packets.h"
#include "ServerSocket.h"
#include "server.h"
#include "SharedFileList.h"
#include "ServerListCtrl.h"
#include "ServerList.h"
#include "sockets.h"
#include "emuleDlg.h"
#include "opcodes.h"
#include "SearchList.h"
#include "UDPSocket.h"
#include "UploadQueue.h"
#include "HTRichEditCtrl.h"
#include "ListenSocket.h"
#include "SafeFile.h"
#include <afxinet.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#ifdef OLD_SOCKETS_ENABLED

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServerConnect::CServerConnect()
{
	EMULE_TRY

	m_pConnectedSocket = NULL;
	m_bConnecting = false;
	m_bConnected = false;
	m_bTryObfuscated = false;
	m_dwClientID = 0;
	m_pUDPSocket = new CUDPSocket();
	m_pUDPSocket->Create();
	m_iRetryTimerID = 0;
	m_iLastServerListStartPos = 0;
	m_iCheckTimerID = 0;
	m_byteNumConnAttempts = 0;
	m_pConnectedServerSocket = NULL;
	m_hICCThread = 0;

	InitLocalIP();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServerConnect::~CServerConnect()
{
	EMULE_TRY

//	Exit ICC Thread if exist
	if (m_hICCThread != 0)
		TerminateThread(m_hICCThread, 0);
//	Stop all connections
	StopConnectionTry();
//	Close connected socket, if any
	DestroySocket(m_pConnectedSocket);
	m_pConnectedSocket = NULL;
//	Close UDP socket
	m_pUDPSocket->Close();
	delete m_pUDPSocket;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::TryAnotherConnectionRequest()
{
	EMULE_TRY

//	Skip server connection if ICC thread is working, wait for thread selftermination
//	to avoid rough thread killing inside ConnectToServer(), as it will leave
//	DLL attached to the thread (wininet) in unpredictable state
	if ( (m_mapConnectionAttempts.GetCount() == 0) &&
		((m_hICCThread == 0) || (WaitForSingleObject(m_hICCThread, 0) != WAIT_TIMEOUT)) )
	{
		CServer	*pNextServer = g_App.m_pServerList->GetNextServer(m_bTryObfuscated);

		if (pNextServer == NULL)
		{
			if (m_mapConnectionAttempts.GetCount() == 0)
			{
				if (m_bTryObfuscated && !g_App.m_pPrefs->IsClientCryptLayerRequired())
				{
				//	Try all servers on the non-obfuscated port next
					m_bTryObfuscated = false;
					ConnectToAnyServer(~0u, true, true, true);
				}
				else
				{
					AddLogLine(LOG_FL_SBAR, IDS_OUTOFSERVERS);
					ConnectToAnyServer(m_iLastServerListStartPos, false);
				}
			}
		}
	//	Auto-connect to static servers only option
		else if (!g_App.m_pPrefs->AutoConnectStaticOnly() || pNextServer->IsStaticMember())
			ConnectToServer(pNextServer, !m_bTryObfuscated);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::ConnectToAnyServer(uint32 iStartIndex/*=0xFFFFFFFF*/,
	bool bPrioSort/*=true*/, bool bIsAuto/*=true*/, bool bNoCrypt/*=false*/)
{
	EMULE_TRY

	CServer		*pNextServer;

//	If no start position is specified start with the next unused server in the list
	if (iStartIndex == 0xFFFFFFFF)
		iStartIndex = g_App.m_pServerList->GetServerPosition();
	m_iLastServerListStartPos = iStartIndex;
//	Cancel any ongoing connection attempts
	StopConnectionTry();
//	If we're currently connected to a server, disconnect from it.
	Disconnect();

	m_bTryObfuscated = g_App.m_pPrefs->IsServerCryptLayerTCPRequested() && !bNoCrypt;
//	If the server list is empty, output an error message and return
	if (g_App.m_pServerList->GetServerCount() == 0)
	{
		AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_NOVALIDSERVERSFOUND);
		return;
	}
	if (g_App.m_pPrefs->GetUseServerPriorities() && bPrioSort)
		g_App.m_pServerList->Sort();

	g_App.m_pServerList->SetServerPosition(iStartIndex);
//	If we're auto-connecting and the "only auto-connect to static server" preference is set...
	if (g_App.m_pPrefs->AutoConnectStaticOnly() && bIsAuto)
	{
		bool	bAnyStatic = false;

	//	Scan all servers in the list to find a static one
		for (uint32 i = 0; i < g_App.m_pServerList->GetServerCount(); i++)
		{
			pNextServer = g_App.m_pServerList->GetNextServer(false);

		//	If we are at the end of the list, 'pNextServer' will be NULL.
		//	Since the list has at least one server, we just need to repeat operation.
			if (pNextServer == NULL)
				pNextServer = g_App.m_pServerList->GetNextServer(false);

			if (pNextServer->IsStaticMember())
			{
				bAnyStatic = true;
				break;
			}
		}
	//	If we couldn't find a static server, output an error message and return
		if (!bAnyStatic)
		{
			AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_NOVALIDSERVERSFOUND);
			return;
		}
	}
//	If we're not auto-connecting or the "only auto-connect to static server" preference is not set...
	else
	{
		pNextServer = g_App.m_pServerList->GetNextServer(false);
	//	If we are at the end of the list, 'pNextServer' will be NULL.
	//	Since the list has at least one server, we just need to repeat operation.
		if (pNextServer == NULL)
			pNextServer = g_App.m_pServerList->GetNextServer(false);
	}
//	Get ready for new upload client connections.
	g_App.m_pListenSocket->Process();

//	At this point we have a server object -- connect to it
	if (pNextServer != NULL)
		ConnectToServer(pNextServer, !m_bTryObfuscated);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::ConnectToServer(CServer *pSrv, bool bNoCrypt)
{
	EMULE_TRY

	StopConnectionTry();
	Disconnect();

	CServerSocket		*pNewSocket = new CServerSocket(this);

	if (pNewSocket != NULL)
	{
		m_bConnecting = true;
		m_pConnectedServerSocket = pSrv;
		m_openSocketList.AddTail(pNewSocket);
		pNewSocket->Create(0, SOCK_STREAM, FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT, g_App.m_pPrefs->GetBindAddrA());
		pNewSocket->ConnectTo(pSrv, bNoCrypt);
		m_mapConnectionAttempts.SetAt(::GetTickCount(), pNewSocket);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	StopConnectionTry() cancels any ongoing server connection attempts and closes all but the currently connected socket.
void CServerConnect::StopConnectionTry()
{
	EMULE_TRY

	m_mapConnectionAttempts.RemoveAll();
	m_bConnecting = false;

	if (m_iRetryTimerID)
	{
		KillTimer(NULL, m_iRetryTimerID);
		m_iRetryTimerID = 0;
	}

//	Close all currently opened sockets except the one which is connected to our current server
	POSITION		pos1, pos2;

	for (pos1 = m_openSocketList.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
	{
		CServerSocket		*pSck = m_openSocketList.GetNext(pos1);
	//	Don't destroy socket which is connected to server
	//	Don't destroy socket if it is going to destroy itself later on
		if (pSck != m_pConnectedSocket)
			DestroySocket(pSck);
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::ConnectionEstablished(CServerSocket* pServerSocket)
{
	EMULE_TRY

//	Reset the retry code - Don't make any further attempts to connect.
	m_byteNumConnAttempts = 0;
	if (m_iCheckTimerID)
		KillTimer(NULL, m_iCheckTimerID);
	m_iCheckTimerID = 0;

//	We are already connected to another server, so just destroy this socket
	if (!m_bConnecting)
	{
		if (pServerSocket != m_pConnectedSocket)
			DestroySocket(pServerSocket);
		return;
	}
//	Get the IP of the local computer
	InitLocalIP();
//	If we're connected and waiting for the server to log us on...
	if (pServerSocket->GetConnectionState() == CS_WAITFORLOGIN)
	{
	//	If there's an entry for the connected socket in the set of connection
	//	attempts, update the attempt time.
		DWORD			dwAttemptTime;
		CServerSocket  *pTempSocket;
		POSITION		pos = m_mapConnectionAttempts.GetStartPosition();

	//	Until we've run out of connecting sockets...
		while (pos)
		{
		//	Retrieve the next key/value entry from the map
			m_mapConnectionAttempts.GetNextAssoc(pos,dwAttemptTime,pTempSocket);
		//	If the entry is for the connected socket...
			if (pTempSocket == pServerSocket)
			{
			//	Remove the entry
				m_mapConnectionAttempts.RemoveKey(dwAttemptTime);
			//	Re-add the entry with the current time
				dwAttemptTime = GetTickCount();
				m_mapConnectionAttempts.SetAt(dwAttemptTime,pServerSocket);
				break;
			}
		}

		AddLogLine( 0, IDS_CONNECTEDTOREQ, pServerSocket->m_pServer->GetListName(),
											   pServerSocket->m_pServer->GetAddress(),
											   pServerSocket->m_pServer->GetPort() );

	//	Send the login packet
		CServer		*pServer = g_App.m_pServerList->GetServerByAddress( pServerSocket->m_pServer->GetAddress(),
																			 pServerSocket->m_pServer->GetPort() );
	//	If the server we're connecting to is in the server list...
		if (pServer)
		{
			pServer->ResetFailedCount();
		//	Update its information in the Server Window.
			g_App.m_pMDlg->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
		}

	//	Construct the LOGINREQUEST packet byte stream
		CMemFile	packetStream(128);
		CWrTag		tagWr;

		packetStream.Write(g_App.m_pPrefs->GetUserHash(), 16);	// <HASH> Our userhash

		uint32		dwClientID = GetClientID();				// <ID:DWORD> Our client ID
		uint16		nPort = g_App.m_pPrefs->GetPort();			// <PORT:WORD> Our TCP port

		packetStream.Write(&dwClientID, sizeof(uint32));
		packetStream.Write(&nPort, sizeof(uint16));

		uint32		dwTagCount = 4;

		packetStream.Write(&dwTagCount, sizeof(uint32));				// <Tag_set> <TAGCOUNT:DWORD>

		g_App.m_pPrefs->WritePreparedNameTag(packetStream);	// (CT_NAME:string) Our nick
		tagWr.WriteToFile(CT_VERSION, EDONKEYVERSION, packetStream);	// (CT_VERSION:int) Our software version #

		uint32		dwFlags = SRVCAP_ZLIB | SRVCAP_AUXPORT |
#ifdef _UNICODE
			SRVCAP_UNICODE |
#endif
			SRVCAP_NEWTAGS | SRVCAP_LARGEFILES;

#ifdef _CRYPT_READY
		dwCryptFlags |= (g_App.m_pPrefs->IsClientCryptLayerSupported()) ? SRVCAP_SUPPORTCRYPT : 0;
		dwCryptFlags |= (g_App.m_pPrefs->IsClientCryptLayerRequested()) ? SRVCAP_REQUESTCRYPT : 0;
		dwCryptFlags |= (g_App.m_pPrefs->IsClientCryptLayerRequired()) ? SRVCAP_REQUIRECRYPT : 0;
#endif
		tagWr.WriteToFile(CT_SERVER_FLAGS, dwFlags, packetStream);

	//	eMule Version (14-Mar-2004: requested by lugdunummaster (need for LowID clients which have no chance
	//	to send Hello packet to the server during the callback test))
		tagWr.WriteToFile( CT_EMULE_VERSION, (PLUS_COMPATIBLECLIENTID << 24) | ((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
			((CURRENT_PLUS_VERSION & 0xF0) << 6) | ((CURRENT_PLUS_VERSION & 0x7) << 7), packetStream );

		Packet			*pPacket = new Packet(&packetStream);

		pPacket->m_eOpcode = OP_LOGINREQUEST;
		g_App.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
		this->SendPacket(pPacket, true, pServerSocket);
	}
//	If we thought we already were connected...
	else if (pServerSocket->GetConnectionState() == CS_CONNECTED)
	{
		g_App.stat_reconnects++;
		g_App.stat_serverConnectTime = GetTickCount();
		m_bConnected = true;
		AddLogLine( LOG_FL_SBAR, (pServerSocket->IsObfusicating()) ? IDS_CONNECTEDTOOBFUSCATED : IDS_CONNECTEDTO,
			pServerSocket->m_pServer->GetListName() );
		g_App.m_pMDlg->ShowConnectionState(true, pServerSocket->m_pServer->GetListName());
		m_pConnectedSocket = pServerSocket;
		StopConnectionTry();
		g_App.m_pSharedFilesList->ClearED2KPublishInfo();
		g_App.m_pSharedFilesList->SendListToServer();
		g_App.m_pMDlg->m_wndServer.m_ctlServerList.RemoveDeadServer();

		if (g_App.m_pPrefs->GetAddServersFromServer())
		{
			Packet		*pPacket = new Packet(OP_GETSERVERLIST, 0);

			g_App.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
			SendPacket(pPacket, true);
		}
		if(g_App.m_pPrefs->RestartWaiting())
			g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.RestartWaitingDownloads();

		g_App.m_pMDlg->m_wndServer.m_pctlServerMsgBox->AppendText(_T("\n"), CSTRLEN(_T("\n")), CLR_DEFAULT, CLR_DEFAULT, HTC_HAVENOLINK);

	//	Reset a request timer after reconnection
		if (pServerSocket->m_pServer != g_App.m_pDownloadQueue->GetLastTCPSrcReqServer())
		{
			g_App.m_pDownloadQueue->ResetLastTCPRequestTime();
			g_App.m_pDownloadQueue->SetLastTCPSrcReqServer(pServerSocket->m_pServer);
		}

	// update the download states of the client
		g_App.m_pDownloadQueue->UpdateSourceStatesAfterServerChange();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerConnect::SendPacket(Packet *pPacket, bool bDelPkt, CServerSocket *pSrvSocket/*=NULL*/)
{
	EMULE_TRY

	if (pSrvSocket == NULL)	//	If there's no server socket spec'd...
	{
		if (m_bConnected)	//	... and we're connected...
		{
			m_pConnectedSocket->SendPacket(pPacket, bDelPkt, true);
			m_pConnectedSocket->m_dwLastTransmission = GetTickCount();
		}
		else
		{
			if (bDelPkt)
				delete pPacket;

			return false;
		}
	}
	else
	{
		pSrvSocket->SendPacket(pPacket, bDelPkt, true);
		pSrvSocket->m_dwLastTransmission = GetTickCount();
	}

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerConnect::SendUDPPacket(Packet *pPacket, CServer *pHostSrv, bool bDelPkt,
	uint16 uSpecPort/*=0*/, byte *pbyteRawPkt/*=NULL*/, uint32 dwLen/*=0*/)
{
	EMULE_TRY

	if (m_bConnected && (pHostSrv != NULL))
		m_pUDPSocket->SendPacket(pPacket, pHostSrv, uSpecPort, pbyteRawPkt, dwLen);
	if (bDelPkt)
	{
		delete pPacket;
		delete[] pbyteRawPkt;
	}

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::ConnectionFailed(CServerSocket *pSrvSocket)
{
	EMULE_TRY

	if (!m_bConnecting && (pSrvSocket != m_pConnectedSocket))
		return;	//	Just return, cleanup is done by the socket itself

	CServer		*pServer = g_App.m_pServerList->GetServerByAddress( pSrvSocket->m_pServer->GetAddress(),
																		 pSrvSocket->m_pServer->GetPort() );

	switch (pSrvSocket->GetConnectionState())
	{
		case CS_FATALERROR:
		{
		//	Sending message when internet connection down
			CString		strMessageText = GetResString(IDS_ERR_FATAL);

			g_App.m_pMDlg->SendMail( strMessageText,
													g_App.m_pPrefs->GetNotifierPopOnServerError(),
													g_App.m_pPrefs->IsSMTPWarningEnabled() );
			g_App.m_pMDlg->ShowNotifier( strMessageText, TBN_SERVER, false,
												  g_App.m_pPrefs->GetNotifierPopOnServerError() );
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, strMessageText);
			m_byteNumConnAttempts++;
			break;
		}
		case CS_DISCONNECTED:
		{
		//	Sending message when connection lost to server
			CString		strMessageText;

			g_App.m_pSharedFilesList->ClearED2KPublishInfo();

			strMessageText.Format( GetResString(IDS_ERR_LOSTC),
								   pSrvSocket->m_pServer->GetListName(),
								   pSrvSocket->m_pServer->GetAddress(),
								   pSrvSocket->m_pServer->GetPort() );
			g_App.m_pMDlg->SendMail( strMessageText,
													g_App.m_pPrefs->GetNotifierPopOnServerError(),
													g_App.m_pPrefs->IsSMTPInfoEnabled() );
			g_App.m_pMDlg->ShowNotifier( strMessageText, TBN_SERVER, false,
												  g_App.m_pPrefs->GetNotifierPopOnServerError() );
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, _T("%s"), strMessageText);
			break;
		}
		case CS_SERVERDEAD:
		{
			AddLogLine(0, IDS_ERR_DEAD, pSrvSocket->m_pServer->GetListName(),
						pSrvSocket->m_pServer->GetAddress(), pSrvSocket->m_pServer->GetPort() );
			if (pServer != NULL)
			{
				pServer->AddFailedCount();
				g_App.m_pMDlg->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
			}
			m_byteNumConnAttempts++;
			break;
		}
		case CS_ERROR:
			m_byteNumConnAttempts++;
			break;

		case CS_SERVERFULL:
			AddLogLine( 0, IDS_ERR_FULL, pSrvSocket->m_pServer->GetListName(),
				pSrvSocket->m_pServer->GetAddress(), pSrvSocket->m_pServer->GetPort() );
			break;

		case CS_NOTCONNECTED:
			m_byteNumConnAttempts++;
			break;
	}

	if (m_byteNumConnAttempts >= 3)
	{
		if (!m_iCheckTimerID)
		{
			CString		strUrl;

			strUrl.Format(_T("http://%s"), g_App.m_ICCURLs[rand() % g_App.m_ICCURLs.GetSize()]);
			AddLogLine(0, IDS_NET_CHECKING, strUrl);

			if (IsAliveURL(strUrl))
				m_byteNumConnAttempts = 0;
			else if (m_bConnecting)
			{
				StopConnectionTry();
				m_iCheckTimerID = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, static_cast<TIMERPROC>(CheckInternetCallback));

			//	Refreshing server in list when disconnection occurs
				if (pServer)
					g_App.m_pMDlg->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
				return;
			}
			else
				return;
		}
	}

	switch (pSrvSocket->GetConnectionState())
	{
		case CS_FATALERROR:
		{
			StopConnectionTry();
			if (g_App.m_pPrefs->Reconnect() && (m_iRetryTimerID == 0))
			{
			//	Sending message when reconnecting after 30 seconds
				CString		strMessage;

				strMessage.Format(GetResString(IDS_RECONNECT), CS_RETRYCONNECTTIME);
				g_App.m_pMDlg->SendMail( strMessage,
														g_App.m_pPrefs->GetNotifierPopOnServerError(),
														g_App.m_pPrefs->IsSMTPWarningEnabled() );
				g_App.m_pMDlg->ShowNotifier( strMessage,
													  TBN_SERVER,
													  false,
													  g_App.m_pPrefs->GetNotifierPopOnServerError() );
				AddLogLine(0, IDS_RECONNECT, CS_RETRYCONNECTTIME);
				m_iRetryTimerID = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, static_cast<TIMERPROC>(RetryConnectCallback));
			}
			break;
		}
		case CS_DISCONNECTED:
		{
			g_App.m_pSharedFilesList->ClearED2KPublishInfo();
			m_bConnected = false;
			if (m_pConnectedSocket)
				DestroySocket(m_pConnectedSocket);
			m_pConnectedSocket = NULL;
			g_App.m_pMDlg->m_dlgSearch.OnBnClickedCancel();

			g_App.stat_serverConnectTime = 0;
			g_App.m_pMDlg->m_dlgStatistics.Add2TotalServerDuration();

			if (g_App.m_pPrefs->Reconnect() && !m_bConnecting)
			{
				ConnectToAnyServer();
			}
		//	Sending message when connection lost
			CString		strMessage = GetResString(IDS_CONNECTIONLOST);

			g_App.m_pMDlg->SendMail( strMessage,
													g_App.m_pPrefs->GetNotifierPopOnServerError(),
													g_App.m_pPrefs->IsSMTPWarningEnabled() );
			g_App.m_pMDlg->ShowNotifier( strMessage,
												  TBN_SERVER,
												  false,
												  g_App.m_pPrefs->GetNotifierPopOnServerError() );
			break;
		}
		case CS_ERROR:
		case CS_NOTCONNECTED:
			if (!m_bConnecting)
				break;
			AddLogLine( 0, IDS_ERR_CONFAILED, pSrvSocket->m_pServer->GetListName(),
				pSrvSocket->m_pServer->GetAddress(), pSrvSocket->m_pServer->GetPort() );
		case CS_SERVERDEAD:
		case CS_SERVERFULL:
		{
			if (!m_bConnecting)
				break;

#ifdef _CRYPT_READY
			if ( (pServer != NULL) && pSrvSocket->IsServerCryptEnabledConnection() &&
				!g_App.m_pPrefs->IsClientCryptLayerRequired() )
			{
			//	Try reconnecting without obfuscation
				ConnectToServer(pServer, false, true);
				break;
			}
#endif

			DWORD				dwTempKey;
			CServerSocket	   *pTempSocket;
			POSITION			pos = m_mapConnectionAttempts.GetStartPosition();

			while (pos)
			{
				m_mapConnectionAttempts.GetNextAssoc(pos, dwTempKey, pTempSocket);
				if (pTempSocket == pSrvSocket)
				{
					m_mapConnectionAttempts.RemoveKey(dwTempKey);
					break;
				}
			}
			TryAnotherConnectionRequest();
		}
	}
//	Refreshing server in list when disconnection occurs
	if (pServer)
		g_App.m_pMDlg->m_wndServer.m_ctlServerList.RefreshServer(*pServer);

	g_App.m_pMDlg->ShowConnectionState(false);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID CALLBACK CServerConnect::RetryConnectCallback(HWND hWnd, UINT nMsg, UINT nId, DWORD dwTime)
{
	NOPRM(hWnd); NOPRM(nMsg); NOPRM(nId); NOPRM(dwTime);
	EMULE_TRY

//	Always handle all type of MFC exceptions in TimerProcs - otherwise we'll get mem leaks
	CServerConnect		*_this = g_App.m_pServerConnect;

	ASSERT(_this);

//	Check if the thread is already running
	if (_this->m_hICCThread && WaitForSingleObject(_this->m_hICCThread, 0) == WAIT_TIMEOUT)
		return;

	_this->StopConnectionTry();

	if (_this->IsConnected())
		return;

	_this->ConnectToAnyServer();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
VOID CALLBACK CServerConnect::CheckInternetCallback(HWND hWnd, UINT nMsg, UINT nId, DWORD dwTime)
{
	NOPRM(hWnd); NOPRM(nMsg); NOPRM(nId); NOPRM(dwTime);
	EMULE_TRY

	CServerConnect		*_this = g_App.m_pServerConnect;

	ASSERT(_this);

//	Check if the thread is already running
	if (_this->m_hICCThread && WaitForSingleObject(_this->m_hICCThread, 0) == WAIT_TIMEOUT)
		return;

	KillTimer(NULL, _this->m_iCheckTimerID);
	_this->m_iCheckTimerID = 0;

	if (_this->IsConnected())
		return;

	CString		strURL;

	strURL.Format(_T("http://%s"), g_App.m_ICCURLs[rand() % g_App.m_ICCURLs.GetSize()]);
	AddLogLine(0, IDS_NET_CHECKING, strURL);

	if(_this->IsAliveURL(strURL))
	{
		_this->m_byteNumConnAttempts = 0;
		if(!_this->IsConnecting())
			_this->ConnectToAnyServer();
	}
	else
	{
		_this->m_iCheckTimerID = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, static_cast<TIMERPROC>(CheckInternetCallback));
		if(_this->IsConnecting())
			_this->StopConnectionTry();
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
struct StructIsAliveURL
{
	StructIsAliveURL(const CString &strUrl, int iRet) : strURL(strUrl), iRC(iRet)	{}
	CString	strURL;
	int		iRC;
};

bool CServerConnect::IsAliveURL(const CString &strURL)
{
	StructIsAliveURL stData(strURL, -1);
	bool	bAppClose = false;

	EMULE_TRY

	m_hICCThread = (HANDLE)_beginthread(IsAliveURLThread, 0, &stData);

	MSG	msg;
	for(bool bDone = false; !bDone; WaitMessage())
	{
		while(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))
		{
			if(msg.message == WM_QUIT)
			{
				bDone = true;
				bAppClose = true;
				m_hICCThread = 0;
				PostMessage(NULL, WM_QUIT, 0, 0);
				break;
			}
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if ( (WaitForSingleObject(m_hICCThread, 0) != WAIT_TIMEOUT) ||
				((bAppClose = !g_App.m_pMDlg->IsRunning()) == true) )
			{
				bDone = true;
				m_hICCThread = 0;
				break;
			}
		}
	}

	EMULE_CATCH

	if (!bAppClose)
	{
		if (stData.iRC == HTTP_STATUS_OK)
			AddLogLine(0, IDS_NET_WORKING);
		else
			AddLogLine(LOG_RGB_ERROR, IDS_ICC_FAILED, stData.iRC);
	}

	return (stData.iRC == HTTP_STATUS_OK);
}

void CServerConnect::IsAliveURLThread(void *pCtx)
{
	EMULE_TRY

	StructIsAliveURL *stData = (StructIsAliveURL *)pCtx;
	stData->iRC = -2;

//	Ping method is used for fast connectivity check
	if (InternetCheckConnection(stData->strURL, FLAG_ICC_FORCE_CONNECTION, 0))
		stData->iRC = HTTP_STATUS_OK;
	else
		stData->iRC = GetLastError();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::CheckForTimeout()
{
	EMULE_TRY

	DWORD			dwTmpKey, dwCurTick = GetTickCount(), dwSrvConnectTimeout = CONSERVTIMEOUT;
	CServerSocket  *pTmpSrvSocket;
	POSITION		pos = m_mapConnectionAttempts.GetStartPosition();

// In case of proxy, limit minimum connection timeout with default connection timeout
	if (g_App.m_pPrefs->GetProxySettings().m_bUseProxy)
		dwSrvConnectTimeout = max(dwSrvConnectTimeout, CONNECTION_TIMEOUT);

	while (pos)
	{
		m_mapConnectionAttempts.GetNextAssoc(pos, dwTmpKey, pTmpSrvSocket);

		if (pTmpSrvSocket == NULL)
		{
			AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T(__FUNCTION__) _T(": Invalid socket during timeout check"));
			m_mapConnectionAttempts.RemoveKey(dwTmpKey);
			return;
		}

		if (dwCurTick - dwTmpKey > dwSrvConnectTimeout)
		{
			AddLogLine( 0, IDS_ERR_CONTIMEOUT, pTmpSrvSocket->m_pServer->GetListName(),
												   pTmpSrvSocket->m_pServer->GetAddress(),
												   pTmpSrvSocket->m_pServer->GetPort() );
			m_mapConnectionAttempts.RemoveKey(dwTmpKey);
			TryAnotherConnectionRequest();
		}
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerConnect::Disconnect()
{
	EMULE_TRY

//	We clear any timer that was left set
	if (m_iCheckTimerID)
	{
		KillTimer(NULL, m_iCheckTimerID);
		m_iCheckTimerID = 0;
	}

	if (m_hICCThread != 0)	//	If the ICC thread is running, we terminate it
	{
	//	Such rough thread killing can leave DLL
	//	attached to the thread (wininet) in unpredictable state
		if (!TerminateThread(m_hICCThread, 0))
			AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Can't terminate IsAliveURL Thread!"));
	}

//	Socket won't be destroyed if server is changed during connecting
	if ((m_bConnected || m_bConnecting) && m_pConnectedSocket)
	{
		CServer		*pServer = g_App.m_pServerList->GetServerByAddress(m_pConnectedSocket->m_pServer->GetAddress(), m_pConnectedSocket->m_pServer->GetPort());

		g_App.m_pSharedFilesList->ClearED2KPublishInfo();
#ifdef _CRYPT_READY
		g_App.SetPublicIP(0);
#endif
		DestroySocket(m_pConnectedSocket);

		m_pConnectedSocket = NULL;
		m_bConnected = false;
	//	Socket won't be destroyed if server is changed during connecting
		m_bConnecting = false;
		g_App.m_pMDlg->ShowConnectionState(false, _T(""));
		g_App.stat_serverConnectTime = 0;
	//	Tell our total server duration to update...
		g_App.m_pMDlg->m_dlgStatistics.Add2TotalServerDuration();
		if (pServer != NULL)
			g_App.m_pMDlg->m_wndServer.m_ctlServerList.RefreshServer(*pServer);

		return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServer *CServerConnect::GetCurrentServer()
{
	EMULE_TRY

	if (IsConnected() && m_pConnectedSocket != NULL)
	{
		return m_pConnectedSocket->m_pServer;
	}

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServer* CServerConnect::GetConnectingServer()
{
	return (m_bConnecting) ? m_pConnectedServerSocket : NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::SetClientID(uint32 newid)
{
	EMULE_TRY

	m_dwClientID = newid;
	if (!::IsLowID(newid))
		g_App.SetPublicIP(newid);
	g_App.m_pMDlg->ShowConnectionState(IsConnected(), GetCurrentServer()->GetListName());

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	DestroySocket() closes and destroys socket 'pSck' and removes it from the open socket list.
void CServerConnect::DestroySocket(CServerSocket *pSck)
{
	EMULE_TRY

	if (pSck == NULL)
		return;

//	Remove the socket from the open socket list
	POSITION	posDel = m_openSocketList.Find(pSck);

	if (posDel != NULL)
	{
		m_openSocketList.RemoveAt(posDel);
	}

	if (pSck->m_SocketData.hSocket != INVALID_SOCKET)
	{
	//	Indicate that we don't want notifications for this socket any more.
		pSck->AsyncSelect(0);
	//	Close the socket and release the socket descriptor.
		pSck->Close();
	}

	delete pSck;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort)
{
	EMULE_TRY

	if (IsConnected())
	{
		if (m_pConnectedSocket->m_pServer->GetIP() == dwIP && m_pConnectedSocket->m_pServer->GetPort() == nPort)
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	InitLocalIP() gets the IP address of the local computer and stores it in 'm_dwLocalIP'.
void CServerConnect::InitLocalIP()
{
	EMULE_TRY

	m_dwLocalIP = 0;

	// Using 'gethostname/gethostbyname' does not solve the problem when we have more than 
	// one IP address. Using 'gethostname/gethostbyname' even seems to return the last IP 
	// address which we got. E.g. if we already got an IP from our ISP, 
	// 'gethostname/gethostbyname' will returned that (primary) IP, but if we add another
	// IP by opening a VPN connection, 'gethostname' will still return the same hostname, 
	// but 'gethostbyname' will return the 2nd IP.
	// To weaken that problem at least for users which are binding eMule to a certain IP,
	// we use the explicitly specified bind address as our local IP address.
	if (g_App.m_pPrefs->GetBindAddrA() != NULL)
	{
		unsigned long ulBindAddr = inet_addr(g_App.m_pPrefs->GetBindAddrA());
		if (ulBindAddr != INADDR_ANY && ulBindAddr != INADDR_NONE) {
			m_dwLocalIP = ulBindAddr;
			return;
		}
	}

//	Don't use 'gethostbyname(NULL)'. The winsock DLL may be replaced by a DLL from a third party
//	which is not fully compatible to the original winsock DLL. ppl reported crash with SCORSOCK.DLL
//	when using 'gethostbyname(NULL)'.
	char		szHost[256];

//	Try to get the standard host name for the local computer. If successful...
	if (gethostname(szHost, sizeof szHost) == 0)
	{
		hostent		*pHostEnt = gethostbyname(szHost);

	//	If we received a 4-byte address...
		if (pHostEnt != NULL && pHostEnt->h_length == 4 && pHostEnt->h_addr_list[0] != NULL)
			m_dwLocalIP = *(reinterpret_cast<uint32*>(pHostEnt->h_addr_list[0]));
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerConnect::KeepConnectionAlive()
{
	EMULE_TRY

	DWORD dwServerKeepAliveTimeout = g_App.m_pPrefs->GetServerKeepAliveTimeout();

	if (dwServerKeepAliveTimeout && m_bConnected && m_pConnectedSocket && m_pConnectedSocket->GetConnectionState() == CS_CONNECTED &&
		GetTickCount() - m_pConnectedSocket->m_dwLastTransmission >= dwServerKeepAliveTimeout)
	{
	//	"Ping" the server if the TCP connection was not used for the specified interval with
	//	an empty publish files packet -> recommended by lugdunummaster himself!
		CSafeMemFile files(4);
		uint32 nFiles = 0;
		files.Write(&nFiles,4);
		Packet *pPacket = new Packet(&files);
		pPacket->m_eOpcode = OP_OFFERFILES;
		g_App.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
		AddLogLine(LOG_FL_DBG, _T("Refreshing server connection for %s"), m_pConnectedSocket->m_pServer->GetListName());
		m_pConnectedSocket->SendPacket(pPacket,true);
		m_pConnectedSocket->m_dwLastTransmission = GetTickCount();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// true if the IP is one of the servers we currently connecting to
bool CServerConnect::AwaitingTestFromIP(uint32 dwIP) const
{
	if (m_mapConnectionAttempts.IsEmpty())
		return false;

	DWORD tmpkey;
	CServerSocket	*pTmpSock;
	POSITION pos = m_mapConnectionAttempts.GetStartPosition();
	while (pos)
	{
		m_mapConnectionAttempts.GetNextAssoc(pos, tmpkey, pTmpSock);
		if ( (pTmpSock != NULL) && (pTmpSock->m_pServer != NULL) &&
			(pTmpSock->m_pServer->GetIP() == dwIP) &&
			(pTmpSock->GetConnectionState() == CS_WAITFORLOGIN) )
		{
			return true;
		}
	}
	return false;
}

bool CServerConnect::IsConnectedObfuscated() const
{
	return (m_pConnectedSocket != NULL) && (m_pConnectedSocket->IsObfusicating());
}
#endif //OLD_SOCKETS_ENABLED
@


1.162
log
@Added an option to bind to specific network interface (from original) {Zom}.
@
text
@d572 1
a572 1
			g_App.m_pMDlg->m_dlgSearch.OnBnClickedCancels();
@


1.161
log
@Encryption preparations.
@
text
@d213 1
a213 1
		pNewSocket->Create(0, SOCK_STREAM, FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT, NULL);
d939 17
@


1.160
log
@Encryption preparations.
@
text
@a357 1
#ifdef _CRYPT_READY
a359 3
#else
		AddLogLine(LOG_FL_SBAR, IDS_CONNECTEDTO, pServerSocket->m_pServer->GetListName());
#endif
d1003 5
@


1.159
log
@Fixed a bunch of DynIP server related issues.
@
text
@d986 5
d992 15
@


1.158
log
@Reduced H-file dependency.
@
text
@d295 1
a295 1
											   pServerSocket->m_pServer->GetFullIP(),
d602 1
a602 1
				pSrvSocket->m_pServer->GetFullIP(), pSrvSocket->m_pServer->GetPort() );
@


1.157
log
@Reduced H-file dependency.
@
text
@a29 1
#include <afxinet.h>
d33 1
d35 1
@


1.156
log
@Removed duplicate search for the server in the list; Brought some updates from original regarding DynIP servers.
@
text
@d32 1
d608 1
a608 1
#if _CRYPT_READY
@


1.155
log
@Some clean-up.
@
text
@a453 1
	CServer		*pUpdateServer;
d482 1
a482 1
								   pSrvSocket->m_pServer->GetFullIP(),
d495 2
a496 4
						pSrvSocket->m_pServer->GetFullIP(), pSrvSocket->m_pServer->GetPort() );
			pUpdateServer = g_App.m_pServerList->GetServerByAddress( pSrvSocket->m_pServer->GetAddress(),
																		  pSrvSocket->m_pServer->GetPort() );
			if (pUpdateServer)
d498 2
a499 2
				pUpdateServer->AddFailedCount();
				g_App.m_pMDlg->m_wndServer.m_ctlServerList.RefreshServer(*pUpdateServer);
d510 1
a510 1
				pSrvSocket->m_pServer->GetFullIP(), pSrvSocket->m_pServer->GetPort() );
d549 1
a549 1
			if ((g_App.m_pPrefs->Reconnect()) && (!m_iRetryTimerID))
d623 1
a623 1
				m_mapConnectionAttempts.GetNextAssoc(pos,dwTempKey,pTempSocket);
d801 1
a801 1
												   pTmpSrvSocket->m_pServer->GetFullIP(),
@


1.154
log
@Encryption preparations.
@
text
@d53 1
a53 1
	m_pUDPSocket = new CUDPSocket(this);
d374 1
a374 1
			SendPacket(pPacket,true);
d395 1
a395 1
bool CServerConnect::SendPacket(Packet *pPacket,bool bDelPkt, CServerSocket *pSrvSocket/*=NULL*/)
@


1.153
log
@Reduced H-file dependency.
@
text
@d138 2
d325 2
a326 1
		tagWr.WriteToFile( CT_SERVER_FLAGS, SRVCAP_ZLIB | SRVCAP_AUXPORT |
d330 8
a337 1
			SRVCAP_NEWTAGS | SRVCAP_LARGEFILES, packetStream );
d356 4
d361 1
a432 1
#ifdef _CRYPT_READY
a433 3
#else
		m_pUDPSocket->SendPacket(pPacket, pHostSrv);
#endif
@


1.152
log
@Optimized link identification and output to RichEdit controls (logs, chats, IRC).
@
text
@d33 1
@


1.151
log
@Simplified logging system implementation.
@
text
@d363 1
a363 1
		g_App.m_pMDlg->m_wndServer.m_pctlServerMsgBox->AppendText(_T("\n"));
@


1.150
log
@Reduced H-file dependency.
@
text
@d109 1
a109 1
					AddLogLine(true, IDS_OUTOFSERVERS);
d140 1
a140 1
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d171 1
a171 1
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d289 1
a289 1
		AddLogLine( false, IDS_CONNECTEDTOREQ, pServerSocket->m_pServer->GetListName(),
d345 1
a345 1
		AddLogLine(true, IDS_CONNECTEDTO, pServerSocket->m_pServer->GetListName());
d458 1
a458 1
			AddLogLine(true, RGB_LOG_ERROR + strMessageText);
d478 1
a478 1
			AddLogLine(true, RGB_LOG_ERROR_TXT _T("%s"), strMessageText);
d483 1
a483 1
			AddLogLine(false, IDS_ERR_DEAD, pSrvSocket->m_pServer->GetListName(),
d500 1
a500 1
			AddLogLine( false, IDS_ERR_FULL, pSrvSocket->m_pServer->GetListName(),
d516 1
a516 1
			AddLogLine(false, IDS_NET_CHECKING, strUrl);
d553 1
a553 1
				AddLogLine(false, IDS_RECONNECT, CS_RETRYCONNECTTIME);
d590 1
a590 1
			AddLogLine( false, IDS_ERR_CONFAILED, pSrvSocket->m_pServer->GetListName(),
d679 1
a679 1
	AddLogLine(false, IDS_NET_CHECKING, strURL);
d742 1
a742 1
			AddLogLine(false, IDS_NET_WORKING);
d744 1
a744 1
			AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ICC_FAILED), stData.iRC);
d784 1
a784 1
			AddDebugLogLine(RGB_LOG_ERROR_TXT _T(__FUNCTION__) _T(": Invalid socket during timeout check"));
d791 1
a791 1
			AddLogLine( false, IDS_ERR_CONTIMEOUT, pTmpSrvSocket->m_pServer->GetListName(),
d817 1
a817 1
			AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Can't terminate IsAliveURL Thread!"));
d967 1
a967 1
		AddDebugLogLine(_T("Refreshing server connection for %s"), m_pConnectedSocket->m_pServer->GetListName());
@


1.149
log
@Unicode preparations; Suppressed compiler warnings.
@
text
@d23 1
a41 2
// CServerConnect

@


1.148
log
@Generate less code for some logging; Clean-up [Aw3].
@
text
@d106 1
a106 1
					ConnectToAnyServer(~0, true, true, true);
a322 1
#ifdef _UNIREADY
d324 2
a325 3
			SRVCAP_NEWTAGS | SRVCAP_LARGEFILES | SRVCAP_UNICODE, packetStream );
#else
		tagWr.WriteToFile(CT_SERVER_FLAGS, SRVCAP_ZLIB | SRVCAP_AUXPORT | SRVCAP_NEWTAGS | SRVCAP_LARGEFILES, packetStream);
d327 1
d636 1
d660 1
@


1.147
log
@Encryption preparations.
@
text
@d518 1
a518 1
			AddLogLine(false, GetResString(IDS_NET_CHECKING), strUrl);
d679 1
a679 1
	AddLogLine(false, GetResString(IDS_NET_CHECKING), strURL);
@


1.146
log
@Encryption preparations.
@
text
@d96 1
a96 1
		CServer		*pNextServer = g_App.m_pServerList->GetNextServer(false);
d102 11
a112 2
				AddLogLine(true, IDS_OUTOFSERVERS);
				ConnectToAnyServer(m_iLastServerListStartPos, false);
d256 1
a256 1
	if (m_bConnecting == false)
@


1.145
log
@Encryption preparations; Clean-up.
@
text
@d114 2
a115 1
void CServerConnect::ConnectToAnyServer(uint32 iStartIndex/*=0xFFFFFFFF*/,bool bPrioritySort/*=true*/,bool bIsAuto/*=true*/)
d135 1
a135 1
	if (g_App.m_pPrefs->GetUseServerPriorities() && bPrioritySort)
d404 2
a405 1
bool CServerConnect::SendUDPPacket(Packet *pPacket,CServer *pHostServer,bool bDeletePacket)
d409 7
a415 1
	if (m_bConnected && (pHostServer != NULL))
d417 2
a418 1
		m_pUDPSocket->SendPacket(pPacket,pHostServer);
a419 2
	if (bDeletePacket)
		delete pPacket;
d817 3
d865 3
a867 1
	g_App.m_pMDlg->ShowConnectionState(IsConnected(),GetCurrentServer()->GetListName());
@


1.144
log
@Encryption preparations; Code clean-up and simplification;
Removed local CServerList pointer; Removed unused #include.
@
text
@d96 1
a96 1
		CServer		*pNextServer = g_App.m_pServerList->GetNextServer();
d146 1
a146 1
			pNextServer = g_App.m_pServerList->GetNextServer();
d151 1
a151 1
				pNextServer = g_App.m_pServerList->GetNextServer();
d169 1
a169 1
		pNextServer = g_App.m_pServerList->GetNextServer();
d173 1
a173 1
			pNextServer = g_App.m_pServerList->GetNextServer();
d371 1
a371 1
bool CServerConnect::SendPacket(Packet *pPacket,bool bDelPacket, CServerSocket *pServerSocket/*=NULL*/)
d375 1
a375 2
//	If there's no server socket spec'd...
	if (pServerSocket == NULL)
d377 1
a377 2
	//	... and we're connected...
		if (m_bConnected)
d379 1
a379 1
			m_pConnectedSocket->SendPacket(pPacket,bDelPacket,true);
d384 1
a384 1
      		if (bDelPacket)
d392 2
a393 2
		pServerSocket->SendPacket(pPacket,bDelPacket,true);
		pServerSocket->m_dwLastTransmission = GetTickCount();
d820 1
a820 1
		if (pServer)
@


1.143
log
@Modified constructors to avoid potential compiling issue due to type collision.
@
text
@a28 1
#include <time.h>
d44 1
a44 1
CServerConnect::CServerConnect(CServerList *pServerList)
a48 1
	m_pUsedServerList = pServerList;
d51 1
d58 1
a58 1
	m_iNumConnectionAttempts = 0;
d96 1
a96 1
		CServer		*pNextServer = m_pUsedServerList->GetNextServer();
d108 1
a108 1
			ConnectToServer(*pNextServer);
d122 1
a122 1
		iStartIndex = m_pUsedServerList->GetServerPosition();
d129 1
a129 1
	if (m_pUsedServerList->GetServerCount() == 0)
d135 1
a135 1
		m_pUsedServerList->Sort();
d137 1
a137 1
	m_pUsedServerList->SetServerPosition(iStartIndex);
d144 1
a144 1
		for (uint32 i = 0; i < m_pUsedServerList->GetServerCount(); i++)
d146 1
a146 1
			pNextServer = m_pUsedServerList->GetNextServer();
d151 1
a151 1
				pNextServer = m_pUsedServerList->GetNextServer();
d169 1
a169 1
		pNextServer = m_pUsedServerList->GetNextServer();
d173 1
a173 1
			pNextServer = m_pUsedServerList->GetNextServer();
d178 1
a178 1
//	At this point we have a server object 'pNextServer'. Connect to it.
d180 1
a180 1
		ConnectToServer(*pNextServer);
d185 1
a185 1
void CServerConnect::ConnectToServer(CServer &server)
a191 2
	m_pConnectedServerSocket = &server;

d197 1
d199 3
a201 6
		pNewSocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL);
		pNewSocket->ConnectToServer(server);

		DWORD		dwCurTick = GetTickCount();

		m_mapConnectionAttempts.SetAt(dwCurTick,pNewSocket);
d240 1
a240 1
	m_iNumConnectionAttempts = 0;
d423 1
a423 1
void CServerConnect::ConnectionFailed(CServerSocket *pServerSocket)
d427 2
a428 5
	if (m_bConnecting == false && pServerSocket != m_pConnectedSocket)
	{
	//	Just return, cleanup is done by the socket itself
		return;
	}
d431 2
a432 2
	CServer		*pServer = g_App.m_pServerList->GetServerByAddress( pServerSocket->m_pServer->GetAddress(),
																		 pServerSocket->m_pServer->GetPort() );
d434 1
a434 1
	switch (pServerSocket->GetConnectionState())
d447 1
a447 1
			m_iNumConnectionAttempts++;
d458 3
a460 3
								   pServerSocket->m_pServer->GetListName(),
								   pServerSocket->m_pServer->GetFullIP(),
								   pServerSocket->m_pServer->GetPort() );
d471 4
a474 4
			AddLogLine(false, IDS_ERR_DEAD, pServerSocket->m_pServer->GetListName(),
						pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort() );
			pUpdateServer = g_App.m_pServerList->GetServerByAddress( pServerSocket->m_pServer->GetAddress(),
																		  pServerSocket->m_pServer->GetPort() );
d480 1
a480 1
			m_iNumConnectionAttempts++;
d484 1
a484 2
		{
			m_iNumConnectionAttempts++;
d486 1
a486 1
		}
d488 2
a489 2
		{
			AddLogLine(false, IDS_ERR_FULL,pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
d491 1
a491 1
		}
d493 1
a493 2
		{
			m_iNumConnectionAttempts++;
a494 1
		}
d497 1
a497 1
	if (m_iNumConnectionAttempts >= 3)
d507 1
a507 3
			{
				m_iNumConnectionAttempts = 0;
			}
a515 1

d523 1
a523 1
	switch (pServerSocket->GetConnectionState())
d530 1
a530 1
   			//	Sending message when reconnecting after 30 seconds
a575 1
		{
d578 2
a579 2
			AddLogLine(false, IDS_ERR_CONFAILED,pServerSocket->m_pServer->GetListName(), pServerSocket->m_pServer->GetFullIP(), pServerSocket->m_pServer->GetPort() );
		}
d586 10
d603 1
a603 1
				if (pTempSocket == pServerSocket)
d669 1
a669 1
		_this->m_iNumConnectionAttempts = 0;
d757 1
a757 1
	CServerSocket  *pTempServerSocket;
d766 1
a766 1
		m_mapConnectionAttempts.GetNextAssoc(pos, dwTmpKey, pTempServerSocket);
d768 1
a768 1
		if (!pTempServerSocket)
d777 3
a779 3
			AddLogLine( false, IDS_ERR_CONTIMEOUT, pTempServerSocket->m_pServer->GetListName(),
												   pTempServerSocket->m_pServer->GetFullIP(),
												   pTempServerSocket->m_pServer->GetPort() );
d847 1
a847 1
CServer *CServerConnect::GetConnectingServer()
d849 1
a849 8
	EMULE_TRY

	if (m_bConnecting && m_pConnectedServerSocket != NULL)
		return m_pConnectedServerSocket;

	EMULE_CATCH

	return NULL;
@


1.142
log
@Server list update option was split into update from servers and clients {ElAguila}.
@
text
@d352 1
a352 1
			Packet		*pPacket = new Packet(OP_GETSERVERLIST);
@


1.141
log
@Large file size support (max file size 512 GB - 1 = 549,755,813,887).
@
text
@d350 1
a350 1
		if (g_App.m_pPrefs->GetAddServersFromConn())
@


1.140
log
@Large file size support preparations.
@
text
@a321 1
#if _LARGEFILE_READY
a322 3
#else
		tagWr.WriteToFile(CT_SERVER_FLAGS, SRVCAP_ZLIB | SRVCAP_AUXPORT | SRVCAP_NEWTAGS, packetStream);
#endif
@


1.139
log
@Fixed Internet Connection Check stuck in some cases {DoubleT/xalbux};
Used lighter way to detect Internet connectivity.
@
text
@d319 5
a323 2
		tagWr.WriteToFile( CT_SERVER_FLAGS,
			SRVCAP_ZLIB | SRVCAP_AUXPORT | SRVCAP_NEWTAGS | SRVCAP_UNICODE, packetStream );
d327 1
@


1.138
log
@update the state for LowID clients only after server change
@
text
@d91 5
a95 1
	if (m_mapConnectionAttempts.GetCount() == 0)
d104 1
a104 1
				ConnectToAnyServer(m_iLastServerListStartPos,false);
a105 1
			return;
a106 1

d108 1
a108 7
		if (g_App.m_pPrefs->AutoConnectStaticOnly())
		{
			if (pNextServer->IsStaticMember())
				ConnectToServer(*pNextServer);
		}
		else
		{
a109 1
		}
d748 5
a752 33
	HINTERNET		hOpen = InternetOpen(_T(""), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);

	if (!hOpen)
#if 1//just for debugging
	{
		int err = GetLastError();
		AddLogLine(false, RGB_LOG_ERROR_TXT _T("IsAliveThd:ErrInetOpen %d(%#x)"), err, err);
		return;
	}
#else
		return;
#endif

	HINTERNET		hURL = InternetOpenUrl(hOpen, stData->strURL, _T(""), 0, INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_NO_COOKIES, NULL);

	stData->iRC = -3;
	if (hURL)
	{
		DWORD	dwHTTPRc = 0, dwSz = sizeof(dwHTTPRc);
		BOOL	bQuery = HttpQueryInfo(hURL, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &dwHTTPRc, &dwSz, NULL);

		stData->iRC = (bQuery) ? dwHTTPRc : -4;

		InternetCloseHandle(hURL);
	}
#if 1//just for debugging
	else {
		int err = GetLastError();
		AddLogLine(false, RGB_LOG_ERROR_TXT _T("IsAliveThd:ErrInetOpenUrl %d(%#x)"), err, err);
		return;
	}
#endif
	InternetCloseHandle(hOpen);
d803 1
a803 2
//	If an ICC Thread is running we terminate it
	if (m_hICCThread != 0)
d805 2
@


1.137
log
@Added some temporary debug messages to track ICC issue.
@
text
@d373 3
@


1.136
log
@new email notifier code (adapted from original) - fully UNICODE ready;
option to send email notification messages in subject
@
text
@d753 7
d761 1
d775 7
@


1.135
log
@Simplified obtaining of HTTP response values;
Report HTTP response on the failed Internet connection check {xalbux};
Don't send any cookie while checking for the Internet connection;
Improved string processing.
@
text
@a31 1
#include "Smtp.h"
d451 1
a451 1
			g_App.m_pSMTPConnection->SendMail( strMessageText,
d471 1
a471 1
			g_App.m_pSMTPConnection->SendMail( strMessageText,
d550 1
a550 1
				g_App.m_pSMTPConnection->SendMail( strMessage,
d581 1
a581 1
			g_App.m_pSMTPConnection->SendMail( strMessage,
@


1.134
log
@Limit minimum server connection timeout (min 40 sec) for connection though proxy (original);
Ranamed GetProxy into GetProxySettings.
@
text
@a521 1
				AddLogLine(false, IDS_NET_WORKING);
a525 1
				AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FATAL));
d656 1
a656 1
	CServerConnect		*_this= g_App.m_pServerConnect;
a676 1
		AddLogLine(false, IDS_NET_WORKING);
d692 3
a694 2
	CString	sURL;
	bool	bSuccess;
d697 1
a697 1
bool CServerConnect::IsAliveURL(LPCTSTR strURL)
d699 3
a703 3
	StructIsAliveURL stData;
	stData.sURL = strURL;
	stData.bSuccess = false;
d709 1
a709 1
		while(PeekMessage(&msg,0,0,0,PM_REMOVE))
d714 1
d716 1
a716 1
				PostMessage(NULL,WM_QUIT,0,0);
d721 2
a722 2
			if(WaitForSingleObject(m_hICCThread, 0) != WAIT_TIMEOUT ||
				!g_App.m_pMDlg->IsRunning())
d731 1
a731 1
	return stData.bSuccess;
d733 7
a739 1
	EMULE_CATCH
d741 1
a741 1
	return false;
d744 1
a744 1
void CServerConnect::IsAliveURLThread(void *pT)
d748 2
a749 2
	StructIsAliveURL *stData = (StructIsAliveURL *)pT;
	stData->bSuccess = false;
d756 1
a756 1
	HINTERNET		hURL = InternetOpenUrl(hOpen, stData->sURL, _T(""), 0, INTERNET_FLAG_NO_CACHE_WRITE, NULL);
d758 2
a759 1
	if (!hURL)
d761 2
a762 3
		InternetCloseHandle(hOpen);
		return;
	}
d764 1
a764 4
	TCHAR		szBuffer[100];
	DWORD		dwBytes = 100;
	DWORD		dwIndex = 0;
	BOOL		bQuery = HttpQueryInfo(hURL, HTTP_QUERY_STATUS_CODE, szBuffer, &dwBytes, &dwIndex);
d766 2
a767 3
	stData->bSuccess = bQuery && !_tcscmp(szBuffer, _T("200"));

	InternetCloseHandle(hURL);
@


1.133
log
@Formatting.
@
text
@d776 1
a776 2
	DWORD			dwCurTick = GetTickCount();
	DWORD			dwTmpKey;
d780 4
d786 1
a786 1
		m_mapConnectionAttempts.GetNextAssoc(pos,dwTmpKey,pTempServerSocket);
d795 1
a795 1
		if (dwCurTick - dwTmpKey > CONSERVTIMEOUT)
@


1.132
log
@Added some Unicode capabilities code (so far disabled).
@
text
@d746 1
a746 1
	HINTERNET		hOpen = InternetOpen(_T(""), INTERNET_OPEN_TYPE_PRECONFIG , NULL, NULL, 0);
d751 1
a751 1
	HINTERNET		hURL =  InternetOpenUrl(hOpen, stData->sURL, _T(""), NULL, /*INTERNET_FLAG_NO_AUTH | */INTERNET_FLAG_NO_CACHE_WRITE, NULL);
d764 1
a764 1
	bool		bSuccess = bQuery && !_tcscmp(szBuffer, _T("200"));
a768 2
	stData->bSuccess = bSuccess;

@


1.131
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d324 4
d329 1
@


1.130
log
@renamed 3 variables
@
text
@d107 1
a107 1
		if (g_App.g_pPrefs->AutoConnectStaticOnly())
d141 1
a141 1
	if (g_App.g_pPrefs->GetUseServerPriorities() && bPrioritySort)
d146 1
a146 1
	if (g_App.g_pPrefs->AutoConnectStaticOnly() && bIsAuto)
d310 1
a310 1
		packetStream.Write(g_App.g_pPrefs->GetUserHash(), 16);	// <HASH> Our userhash
d313 1
a313 1
		uint16		nPort = g_App.g_pPrefs->GetPort();			// <PORT:WORD> Our TCP port
d322 1
a322 1
		g_App.g_pPrefs->WritePreparedNameTag(packetStream);	// (CT_NAME:string) Our nick
d351 1
a351 1
		if (g_App.g_pPrefs->GetAddServersFromConn())
d358 1
a358 1
		if(g_App.g_pPrefs->RestartWaiting())
d448 2
a449 2
													g_App.g_pPrefs->GetNotifierPopOnServerError(),
													g_App.g_pPrefs->IsSMTPWarningEnabled() );
d451 1
a451 1
												  g_App.g_pPrefs->GetNotifierPopOnServerError() );
d468 2
a469 2
													g_App.g_pPrefs->GetNotifierPopOnServerError(),
													g_App.g_pPrefs->IsSMTPInfoEnabled() );
d471 1
a471 1
												  g_App.g_pPrefs->GetNotifierPopOnServerError() );
d542 1
a542 1
			if ((g_App.g_pPrefs->Reconnect()) && (!m_iRetryTimerID))
d549 2
a550 2
														g_App.g_pPrefs->GetNotifierPopOnServerError(),
														g_App.g_pPrefs->IsSMTPWarningEnabled() );
d554 1
a554 1
													  g_App.g_pPrefs->GetNotifierPopOnServerError() );
d572 1
a572 1
			if (g_App.g_pPrefs->Reconnect() && !m_bConnecting)
d580 2
a581 2
													g_App.g_pPrefs->GetNotifierPopOnServerError(),
													g_App.g_pPrefs->IsSMTPWarningEnabled() );
d585 1
a585 1
												  g_App.g_pPrefs->GetNotifierPopOnServerError() );
d955 1
a955 1
	DWORD dwServerKeepAliveTimeout = g_App.g_pPrefs->GetServerKeepAliveTimeout();
@


1.129
log
@Unicode corrections {KuSh}.
@
text
@d107 1
a107 1
		if (g_eMuleApp.m_pGlobPrefs->AutoConnectStaticOnly())
d141 1
a141 1
	if (g_eMuleApp.m_pGlobPrefs->GetUseServerPriorities() && bPrioritySort)
d146 1
a146 1
	if (g_eMuleApp.m_pGlobPrefs->AutoConnectStaticOnly() && bIsAuto)
d183 1
a183 1
	g_eMuleApp.m_pListenSocket->Process();
d296 1
a296 1
		CServer		*pServer = g_eMuleApp.m_pServerList->GetServerByAddress( pServerSocket->m_pServer->GetAddress(),
d303 1
a303 1
			g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d310 1
a310 1
		packetStream.Write(g_eMuleApp.m_pGlobPrefs->GetUserHash(), 16);	// <HASH> Our userhash
d313 1
a313 1
		uint16		nPort = g_eMuleApp.m_pGlobPrefs->GetPort();			// <PORT:WORD> Our TCP port
d322 1
a322 1
		g_eMuleApp.m_pGlobPrefs->WritePreparedNameTag(packetStream);	// (CT_NAME:string) Our nick
d334 1
a334 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
d340 2
a341 2
		g_eMuleApp.stat_reconnects++;
		g_eMuleApp.stat_serverConnectTime = GetTickCount();
d344 1
a344 1
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(true, pServerSocket->m_pServer->GetListName());
d347 3
a349 3
		g_eMuleApp.m_pSharedFilesList->ClearED2KPublishInfo();
		g_eMuleApp.m_pSharedFilesList->SendListToServer();
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RemoveDeadServer();
d351 1
a351 1
		if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn())
d355 1
a355 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
d358 2
a359 2
		if(g_eMuleApp.m_pGlobPrefs->RestartWaiting())
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.RestartWaitingDownloads();
d361 1
a361 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_pctlServerMsgBox->AppendText(_T("\n"));
d364 1
a364 1
		if (pServerSocket->m_pServer != g_eMuleApp.m_pDownloadQueue->GetLastTCPSrcReqServer())
d366 2
a367 2
			g_eMuleApp.m_pDownloadQueue->ResetLastTCPRequestTime();
			g_eMuleApp.m_pDownloadQueue->SetLastTCPSrcReqServer(pServerSocket->m_pServer);
d437 1
a437 1
	CServer		*pServer = g_eMuleApp.m_pServerList->GetServerByAddress( pServerSocket->m_pServer->GetAddress(),
d447 5
a451 5
			g_eMuleApp.m_pSMTPConnection->SendMail( strMessageText,
													g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(),
													g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled() );
			g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessageText, TBN_SERVER, false,
												  g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError() );
d461 1
a461 1
			g_eMuleApp.m_pSharedFilesList->ClearED2KPublishInfo();
d467 5
a471 5
			g_eMuleApp.m_pSMTPConnection->SendMail( strMessageText,
													g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(),
													g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled() );
			g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessageText, TBN_SERVER, false,
												  g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError() );
d479 1
a479 1
			pUpdateServer = g_eMuleApp.m_pServerList->GetServerByAddress( pServerSocket->m_pServer->GetAddress(),
d484 1
a484 1
				g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pUpdateServer);
d512 1
a512 1
			strUrl.Format(_T("http://%s"), g_eMuleApp.m_ICCURLs[rand() % g_eMuleApp.m_ICCURLs.GetSize()]);
d528 1
a528 1
					g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d542 1
a542 1
			if ((g_eMuleApp.m_pGlobPrefs->Reconnect()) && (!m_iRetryTimerID))
d548 4
a551 4
				g_eMuleApp.m_pSMTPConnection->SendMail( strMessage,
														g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(),
														g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled() );
				g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessage,
d554 1
a554 1
													  g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError() );
d562 1
a562 1
			g_eMuleApp.m_pSharedFilesList->ClearED2KPublishInfo();
d567 1
a567 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.OnBnClickedCancels();
d569 2
a570 2
			g_eMuleApp.stat_serverConnectTime = 0;
			g_eMuleApp.m_pdlgEmule->m_dlgStatistics.Add2TotalServerDuration();
d572 1
a572 1
			if (g_eMuleApp.m_pGlobPrefs->Reconnect() && !m_bConnecting)
d579 4
a582 4
			g_eMuleApp.m_pSMTPConnection->SendMail( strMessage,
													g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(),
													g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled() );
			g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessage,
d585 1
a585 1
												  g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError() );
d619 1
a619 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d621 1
a621 1
	g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
d631 1
a631 1
	CServerConnect		*_this = g_eMuleApp.m_pServerConnect;
d653 1
a653 1
	CServerConnect		*_this= g_eMuleApp.m_pServerConnect;
d669 1
a669 1
	strURL.Format(_T("http://%s"), g_eMuleApp.m_ICCURLs[rand() % g_eMuleApp.m_ICCURLs.GetSize()]);
d718 1
a718 1
				!g_eMuleApp.m_pdlgEmule->IsRunning())
d822 1
a822 1
		CServer		*pServer = g_eMuleApp.m_pServerList->GetServerByAddress(m_pConnectedSocket->m_pServer->GetAddress(), m_pConnectedSocket->m_pServer->GetPort());
d824 1
a824 1
		g_eMuleApp.m_pSharedFilesList->ClearED2KPublishInfo();
d831 2
a832 2
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(false, _T(""));
		g_eMuleApp.stat_serverConnectTime = 0;
d834 1
a834 1
		g_eMuleApp.m_pdlgEmule->m_dlgStatistics.Add2TotalServerDuration();
d836 1
a836 1
			g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d877 1
a877 1
	g_eMuleApp.m_pdlgEmule->ShowConnectionState(IsConnected(),GetCurrentServer()->GetListName());
d955 1
a955 1
	DWORD dwServerKeepAliveTimeout = g_eMuleApp.m_pGlobPrefs->GetServerKeepAliveTimeout();
d967 1
a967 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(pPacket->m_dwSize);
@


1.128
log
@Don't send duplicate information in CT_PORT tag in server login request {Avi-3k/lugdunummaster}.
@
text
@d784 1
a784 1
			AddDebugLogLine(RGB_LOG_ERROR_TXT __FUNCTION__ _T(": Invalid socket during timeout check"));
@


1.127
log
@Renamed service to follow real actions.
@
text
@d318 1
a318 1
		uint32		dwTagCount = 5;
a323 1
		tagWr.WriteToFile(CT_PORT, g_eMuleApp.m_pGlobPrefs->GetPort(), packetStream);	// (CT_PORT:int)
@


1.126
log
@Slightly cleaned a mess of including one H-file into another;
Global preferences reference instead of local pointer;
Removed double #include of afxmt.h (once in stdafx.h is enough).
@
text
@d141 1
a141 3
//	If the "Use priority system" preference is set...
	if (g_eMuleApp.m_pGlobPrefs->Score() && bPrioritySort)
	{
d143 1
a143 1
	}
@


1.125
log
@fixed incorrect socket closure if connection was lost
@
text
@a17 1

d21 4
a29 1
#include <afxmt.h>
d46 1
a46 1
CServerConnect::CServerConnect(CServerList *pServerList, CPreferences *pPrefs)
a50 1
	m_pPrefs = pPrefs;
d315 1
a315 1
		uint16		nPort = m_pPrefs->GetPort();						// <PORT:WORD> Our TCP port
d324 1
a324 1
		m_pPrefs->WritePreparedNameTag(packetStream);					// (CT_NAME:string) Our nick
d326 1
a326 1
		tagWr.WriteToFile(CT_PORT, m_pPrefs->GetPort(), packetStream);	// (CT_PORT:int)
d545 1
a545 1
			if ((m_pPrefs->Reconnect()) && (!m_iRetryTimerID))
d575 1
a575 1
			if (m_pPrefs->Reconnect() && !m_bConnecting)
@


1.124
log
@Improved files publishing algorithm on the server.
@
text
@d567 1
a567 1
				m_pConnectedSocket->Close();
@


1.123
log
@Added operand to IDS_NET_CHECKING;
Simplified string processing; Some Unicode corrections.
@
text
@d349 1
d463 2
d564 1
d826 1
@


1.122
log
@Removed unused code called "offered files to server".
@
text
@d345 2
a346 2
		AddLogLine(true, IDS_CONNECTEDTO,pServerSocket->m_pServer->GetListName());
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(true,pServerSocket->m_pServer->GetListName());
d351 1
a378 1

d469 1
a469 3
			g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessageText,
												  TBN_SERVER,
												  false,
d471 1
a471 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_LOSTC),pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
d476 1
a476 1
			AddLogLine(false, IDS_ERR_DEAD,pServerSocket->m_pServer->GetListName(),
d509 1
a509 1
			CString		sUrl;
d511 2
a512 1
			sUrl.Format(_T("http://%s"), g_eMuleApp.m_ICCURLs[rand() % g_eMuleApp.m_ICCURLs.GetSize()]);
d514 1
a514 5
			CString		strMessage = GetResString(IDS_NET_CHECKING) + " [" + sUrl + "]";

			AddLogLine(false, _T("%s"), strMessage);

			if (IsAliveURL(sUrl))
d668 1
a668 4

	CString		strMessage = GetResString(IDS_NET_CHECKING) + " [" + strURL + "]";

	AddLogLine(false, _T("%s"), strMessage);
d782 1
a782 1
			AddDebugLogLine(RGB_LOG_ERROR + _T("%s: Invalid socket during timeout check"), __FUNCTION__);
d814 1
a814 1
			AddDebugLogLine(RGB_LOG_WARNING + _T("Can't terminate IsAliveURL Thread!"));
@


1.121
log
@Support new ed2k tag format (client<->server,
as well as used for shared list transfers to eMule v0.43a+ and eMule Plus v1.1a+).
@
text
@a472 1
			g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.PostMessage(WM_SFL_UPDATEOFFEREDITEMS);
a831 2
		bool		bPreviouslyConnected = m_bConnected;

d836 1
a836 1
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(false,_T(""));
a839 3
	//	If previously connected, refresh offered files
		if (bPreviouslyConnected)
			g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.UpdateOfferedItems();
@


1.120
log
@Better way to prepare user name tag.
@
text
@d326 1
a326 1
		tagWr.WriteToFile(CT_SERVER_FLAGS, SRVCAP_ZLIB | SRVCAP_AUXPORT, packetStream);
@


1.119
log
@Optimized parameter tag processing (preparation and parsing).
@
text
@d308 2
a309 2
		CMemFile		packetStream;
		CWrTag			tagWr;
d311 1
a311 1
		packetStream.Write(g_eMuleApp.m_pGlobPrefs->GetUserHash(),16);	// <HASH> Our userhash
d313 1
a313 1
		uint32		dwClientID = GetClientID();							// <ID:DWORD> Our client ID
d321 1
a321 1
		packetStream.Write(&dwTagCount,sizeof(uint32));					// <Tag_set> {<TAGCOUNT:DWORD> 3 tags follow
d323 3
a325 6
		CClientTag	tag1(CT_NAME, m_pPrefs->GetUserNick().GetBuffer());

		tag1.WriteToFile(packetStream);									// (CT_NAME:string) Our nick

		tagWr.WriteToFile(CT_VERSION, EDONKEYVERSION, packetStream);				// (CT_VERSION:int) Our software version #
		tagWr.WriteToFile(CT_PORT, m_pPrefs->GetPort(), packetStream);				// (CT_PORT:int)
d329 1
a329 1
	//	to send an Hello packet to the server during the callback test))
d337 1
a337 1
		this->SendPacket(pPacket,true,pServerSocket);
@


1.118
log
@Improved string processing; Formatting.
@
text
@d309 1
d327 3
a329 10
		CClientTag	tag2(CT_VERSION, EDONKEYVERSION);				// (CT_VERSION:int) Our software version #

		tag2.WriteToFile(packetStream);

		CClientTag	tag3(CT_PORT, m_pPrefs->GetPort());				// (CT_PORT:int) Our port again? }

		tag3.WriteToFile(packetStream);

		CClientTag	tag4(CT_SERVER_FLAGS, SRVCAP_ZLIB | SRVCAP_AUXPORT);
		tag4.WriteToFile(packetStream);
d333 2
a334 3
		CClientTag	tag5( CT_EMULE_VERSION, (PLUS_COMPATIBLECLIENTID << 24) | ((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
			((CURRENT_PLUS_VERSION & 0xF0) << 6) | ((CURRENT_PLUS_VERSION & 0x7) << 7) );
		tag5.WriteToFile(packetStream);
@


1.117
log
@New eMule Plus identification; Added server capabilities;
CT_SUPPORTED_FEATURES is renamed into CT_SERVER_FLAGS.
@
text
@d254 1
a254 1
	  	KillTimer(NULL, m_iCheckTimerID);
d461 1
a461 3
			g_eMuleApp.m_pdlgEmule->ShowNotifier( strMessageText,
												  TBN_SERVER,
												  false,
d463 1
a463 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_FATAL));
d825 1
a825 1
	  	KillTimer(NULL, m_iCheckTimerID);
@


1.116
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d264 1
a264 1
//	Get the IP of the local computer.
d299 1
a299 1
	//	If the server we connected to is in the server list...
a312 3

		packetStream.Write(&dwClientID,sizeof(uint32));

d315 2
a316 1
		packetStream.Write(&nPort,sizeof(uint16));
d318 1
a318 1
		uint32		dwTagCount = 4;
d322 1
a322 1
		CClientTag		tag1(CT_NAME,m_pPrefs->GetUserNick().GetBuffer());
d326 1
a326 1
		CClientTag		tag2(CT_VERSION,EDONKEYVERSION);				// (CT_VERSION:int) Our software version #
d330 1
a330 1
		CClientTag		tag3(CT_PORT,m_pPrefs->GetPort());				// (CT_PORT:int) Our port again? }
d334 1
a334 1
		CClientTag 		tag4(CT_SUPPORTED_FEATURES,SRV_TCPFLG_COMPRESSION | SRV_TCPFLG_AUXPORT);
d337 6
d371 1
a371 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_pctlServerMsgBox->AppendText(CString("\n"));
a378 1

@


1.115
log
@What a mess... this is final (kuchin and I hope so :P)
@
text
@d800 1
a800 1
			AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Invalid socket during timeout check"), __FUNCTION__);
d832 1
a832 1
			AddDebugLogLine(false, RGB_LOG_WARNING + _T("Can't terminate IsAliveURL Thread!"));
d988 1
a988 1
		AddDebugLogLine(false, _T("Refreshing server connection for %s"), m_pConnectedSocket->m_pServer->GetListName());
@


1.114
log
@Some changes (thanks kuchin)
@
text
@d534 1
a534 1
			else
d546 2
d649 1
a649 1
	if (WaitForSingleObject(_this->m_hICCThread, 0) == WAIT_TIMEOUT)
d671 1
a671 1
	if (WaitForSingleObject(_this->m_hICCThread, 0) == WAIT_TIMEOUT)
d717 1
a717 1
	HANDLE m_hICCThread = (HANDLE)_beginthread(IsAliveURLThread, 0, &stData);
d727 1
d737 1
@


1.113
log
@Fix for ICC keep trying after disconnect because of thread usage
@
text
@d645 5
d651 1
d668 4
d715 1
a715 1
	HANDLE hThread = (HANDLE)_beginthread(IsAliveURLThread, 0, &stData);
d730 1
a730 1
			if(WaitForSingleObject(hThread, 0) != WAIT_TIMEOUT ||
d817 14
a856 10
//	We clear any timer that was left set
	if (m_iCheckTimerID)
	{
	  	KillTimer(NULL, m_iCheckTimerID);
		m_iCheckTimerID = 0;
		if (m_hICCThread != 0)
			if (!TerminateThread(m_hICCThread, 0))
				AddDebugLogLine(false, RGB_LOG_WARNING + _T("Can't terminate IsAliveURL Thread!"));
	}

@


1.112
log
@Internet connection check fix - GUI is not freezing anymore
@
text
@d61 2
d72 3
d838 3
@


1.111
log
@Minor fixes...
@
text
@d687 6
d697 41
d741 1
a741 1
		return false;
d743 1
a743 1
	HINTERNET		hURL =  InternetOpenUrl(hOpen, strURL, _T(""), NULL, /*INTERNET_FLAG_NO_AUTH | */INTERNET_FLAG_NO_CACHE_WRITE, NULL);
d748 1
a748 1
		return false;
d761 1
a761 1
	return bSuccess;
a763 2

	return false;
@


1.110
log
@Minor changes and hopefully fixed the problem with disconnected servers highlighting not being removed
@
text
@a757 1

d780 7
a786 2
		if (m_iCheckTimerID)
		  	KillTimer(NULL, m_iCheckTimerID);
a787 2

		return true;
@


1.109
log
@Fixed checking Internet Connection even after you forced a disconnect
@
text
@d438 1
a438 1
//	Messages + fail tries count
d440 2
a446 6
		//	Refreshing server in list when internet connection is lost
			CServer *pServer = g_eMuleApp.m_pServerList->GetServerByAddress(pServerSocket->m_pServer->GetAddress(), pServerSocket->m_pServer->GetPort());

			if (pServer)
				g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);

a462 6
		//	Refreshing server in list when disconnection occurs
			CServer *pServer = g_eMuleApp.m_pServerList->GetServerByAddress(pServerSocket->m_pServer->GetAddress(), pServerSocket->m_pServer->GetPort());

			if (pServer)
				g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);

d534 5
d623 4
@


1.108
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d782 4
@


1.107
log
@Final DebugLog formating and changes
@
text
@d912 1
a912 1
		AddDebugLogLine(false, _T("%s: Refreshing server connection"), __FUNCTION__);
@


1.106
log
@Minor fix for server list update on forced server disconnect or internet connection loss.
@
text
@d737 1
a737 1
			AddDebugLogLine(false, RGB_LOG_ERROR + _T("Error: Socket invalid at timeoutcheck") );
d912 1
a912 1
		AddDebugLogLine(false, _T("Refreshing server connection"));
@


1.105
log
@redraw last connected server on disconnect
@
text
@d54 1
a54 1
	m_pUDPSocket = new CUDPSocket(this); // initalize socket for udp packets
a85 1
//	eklmn: change funny condition :) (m_mapConnectionAttempts.GetCount() < ((m_pPrefs->IsSafeConnectEnabled()) ? 1 : 2))
d100 1
a100 1
	//	Barry - Only auto-connect to static server option
a124 1

a128 1

a139 1

a140 1

a145 1
	//
a200 1
//		AddDebugLogLine(false, "-server->: Socket was created (connecting = true). ");
d214 1
a214 2
//	StopConnectionTry() cancels any ongoing server connection attempts and closes all but the currently
//		connected socket.
d245 1
a245 1
//
a263 1
	//
d265 1
a265 2
	//		attempts, update the attempt time.
	//
d287 4
a290 2
		AddLogLine(false, IDS_CONNECTEDTOREQ,pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
	//
a291 1
	//
d301 1
a301 1
	//
d307 1
a307 1
		uint32		dwClientID = GetClientID();						// <ID:DWORD> Our client ID
d311 1
a311 1
		uint16		nPort = m_pPrefs->GetPort();					// <PORT:WORD> Our TCP port
d317 1
a317 1
		packetStream.Write(&dwTagCount,sizeof(uint32));				// <Tag_set> {<TAGCOUNT:DWORD> 3 tags follow
d321 1
a321 1
		tag1.WriteToFile(packetStream);								// (CT_NAME:string) Our nick
d323 1
a323 1
		CClientTag		tag2(CT_VERSION,EDONKEYVERSION);			// (CT_VERSION:int) Our software version #
d327 1
a327 1
		CClientTag		tag3(CT_PORT,m_pPrefs->GetPort());			// (CT_PORT:int) Our port again? }
d364 1
a364 1
		//eklmn: reset a request timer after reconnection
d381 1
a381 1
	//	If there's no server socket spec'd...
d445 6
d467 7
a473 1
		//	Purity - Sending message when connection lost to server
d556 1
a556 1
   			//	Purity - Sending message when reconnecting after 30 seconds
d637 1
a637 1
//	SyruS (0.29c) NOTE: Always handle all type of MFC exceptions in TimerProcs - otherwise we'll get mem leaks
d744 3
a746 1
			AddLogLine(false, IDS_ERR_CONTIMEOUT,pTempServerSocket->m_pServer->GetListName(), pTempServerSocket->m_pServer->GetFullIP(), pTempServerSocket->m_pServer->GetPort());
d758 1
a758 1
//	eklmn: bugfix(10): socket will be not destroyed if server is changed during connecting
d770 1
a770 1
	//	eklmn: bugfix(10): socket will be not destroyed if server is changed during connecting
a772 1
	//	g_eMuleApp.m_pdlgEmule->m_wndServer.m_pctlServerMsgBox->AppendText(CString("\n"));
d774 1
a774 1
	//	Tell our total server duration thinkymajig to update...
a833 1
//
d842 1
a842 1
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET) // deadlake PROXYSUPPORT - changed to AsyncSocketEx
d876 1
a876 1
//
a879 1
//
d885 1
a885 1
		hostent		*pHostEnt = gethostbyname(szHost); //<= MOREVIT - deprecated in favor of getaddrinfo()
d904 2
a905 2
		// "Ping" the server if the TCP connection was not used for the specified interval with
		// an empty publish files packet -> recommended by lugdunummaster himself!
@


1.104
log
@Improved string processing.
@
text
@d757 2
d775 2
@


1.103
log
@Changed the fix for auto server connect and serverlist update on start as it brought problems to some users. Now it should be ok.
@
text
@d454 2
a455 2
		//	Purity - Sending message when internet connection down
			CString		strMessageText;
a456 1
			strMessageText.Format(GetResString(IDS_ERR_FATAL));
d584 2
a585 2
		//	Purity - Sending message when connection lost
			CString		strMessage;
a586 1
			strMessage.Format(GetResString(IDS_CONNECTIONLOST));
@


1.102
log
@added auxiliary port support from KuSh (commited with eklmn's authorization)
@
text
@a131 3
//	Update statusbar
	g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);

@


1.101
log
@Solved potential crashes when filename contains '%'.
@
text
@d343 1
a343 1
		CClientTag 		tag4(CT_SUPPORTED_FEATURES,SRV_TCPFLG_COMPRESSION);
@


1.100
log
@formatting;
little optimiZation of the DownloadList sorting code;
fixed sorting of ETA, AVG ETA, TimeRemaining, AvgTimeRemaining columns;
changed and fixed new option 'Show paused and stopped files last', it works and now with all column sort
@
text
@d533 1
a533 1
			AddLogLine(false, strMessage);
d672 1
a672 1
	AddLogLine(false, strMessage);
@


1.99
log
@Formatting, comments, and name changes.
Removed old #defines
@
text
@d56 2
a57 2
	m_iRetryTimerID= 0;
	m_iLastServerListStartPos=0;
@


1.98
log
@typo correction + prevent from connect to the same server every time
@
text
@a248 13
#ifdef OLD
		if ((pSck != NULL) && (pSck != m_pConnectedSocket))
		{
			m_openSocketList.RemoveAt(pos2);

			if (pSck->m_SocketData.hSocket != INVALID_SOCKET)
			{
				pSck->AsyncSelect(0);
				pSck->Close();
			}
			delete pSck;
		}
#endif OLD
@


1.97
log
@Reverted a change
@
text
@d124 1
a124 1
		iStartIndex = m_pUsedServerList->GetServerPostion();
d146 3
a153 1
		m_pUsedServerList->SetServerPosition(iStartIndex);
d181 1
a181 2
		m_pUsedServerList->SetServerPosition(iStartIndex);
		pNextServer = m_pUsedServerList->GetServerAt(iStartIndex);
@


1.96
log
@Minor changes
@
text
@a191 2
	else
		ConnectToAnyServer();
@


1.95
log
@More Kush changes for localization
@
text
@d192 2
@


1.94
log
@Reverted a change and added more debug log for unknown problem.
@
text
@d126 1
a126 1
  
d131 3
a133 2
	
	g_eMuleApp.m_pdlgEmule->ShowConnectionState(false,_T(""),true);
d202 1
a202 1
	
d232 5
a236 5
	if (m_iRetryTimerID) 
	{ 
		KillTimer(NULL, m_iRetryTimerID); 
		m_iRetryTimerID = 0; 
	} 
d249 2
a250 2
		if ((pSck != NULL) && (pSck != m_pConnectedSocket))	
		{			
d362 1
a362 1
		this->SendPacket(pPacket,true,pServerSocket);		
d394 1
a394 1
		
d470 1
a470 1
			CString		strMessageText; 
d580 1
a580 1
				AddLogLine(false, IDS_RECONNECT, CS_RETRYCONNECTTIME); 
a582 1
			g_eMuleApp.m_pdlgEmule->ShowConnectionState(false,_T(""),true);
d588 1
a588 1
			if (m_pConnectedSocket) 
d592 1
a592 1
			
d598 1
a598 1
				ConnectToAnyServer();		
a610 1
			g_eMuleApp.m_pdlgEmule->ShowConnectionState(false,_T(""),true);
d638 1
a638 1
			}			
d642 2
a643 1
	g_eMuleApp.m_pdlgEmule->ShowConnectionState(false,_T(""),true);
d647 2
a648 2
VOID CALLBACK CServerConnect::RetryConnectCallback(HWND hWnd, UINT nMsg, UINT nId, DWORD dwTime) 
{ 
d652 1
a652 1
	CServerConnect		*_this = g_eMuleApp.m_pServerConnect; 
d654 1
a654 1
	ASSERT(_this); 
d657 1
a657 1
		return; 
d664 1
a664 1
VOID CALLBACK CServerConnect::CheckInternetCallback(HWND hWnd, UINT nMsg, UINT nId, DWORD dwTime) 
a666 2
	
	CServerConnect		*_this= g_eMuleApp.m_pServerConnect; 
d668 3
a670 1
	ASSERT(_this); 
d691 1
a691 1
			_this->ConnectToAnyServer(); 
d710 1
a710 1
 
d718 1
a718 1
 
d728 1
a728 1
 
d849 1
a849 1
		m_openSocketList.RemoveAt(posDel);		
d851 1
a851 1
	
d861 1
a861 1
	
d915 1
a915 1
		// "Ping" the server if the TCP connection was not used for the specified interval with 
@


1.93
log
@Fixed log clear from WebServer + Some measurements in try to prevent log lines gaps
@
text
@d385 1
a385 1
		//g_eMuleApp.m_pdlgEmule->m_wndServer.m_pctlServerMsgBox->AppendText(CString("\n"));
@


1.92
log
@Better URL detection + minor changes
@
text
@d385 1
a385 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_pctlServerMsgBox->AppendText(CString("\n"));
@


1.91
log
@Color logs
@
text
@d553 1
a553 1
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_FATAL));
@


1.90
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d137 1
a137 1
		AddLogLine(true, IDS_ERR_NOVALIDSERVERSFOUND);
a171 1
			g_eMuleApp.m_pdlgEmule->ShowConnectionState(false,_T(""));
d479 1
a479 1
			AddLogLine(true, IDS_ERR_FATAL);
d500 1
a500 1
			AddLogLine(true, IDS_ERR_LOSTC,pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
d553 1
a553 1
				AddLogLine(false, IDS_ERR_FATAL);
@


1.89
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d171 1
a171 1
			AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d752 1
a752 1
			AddDebugLogLine(false, RGB_RED + _T("Error: Socket invalid at timeoutcheck") );
@


1.88
log
@Added some colors to the logs...
@
text
@d95 1
a95 1
				AddLogLine(true,IDS_OUTOFSERVERS);
d137 1
a137 1
		AddLogLine(true,IDS_ERR_NOVALIDSERVERSFOUND);
d171 1
a171 1
			AddLogLine(true,_T("<COLOR=255,102,0>") + GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d312 1
a312 1
		AddLogLine(false,IDS_CONNECTEDTOREQ,pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
d370 1
a370 1
		AddLogLine(true,IDS_CONNECTEDTO,pServerSocket->m_pServer->GetListName());
d480 1
a480 1
			AddLogLine(true,IDS_ERR_FATAL);
d501 1
a501 1
			AddLogLine(true,IDS_ERR_LOSTC,pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
d506 1
a506 1
			AddLogLine( false,IDS_ERR_DEAD,pServerSocket->m_pServer->GetListName(),
d525 1
a525 1
			AddLogLine(false,IDS_ERR_FULL,pServerSocket->m_pServer->GetListName(),pServerSocket->m_pServer->GetFullIP(),pServerSocket->m_pServer->GetPort());
d549 1
a549 1
				AddLogLine(false,IDS_NET_WORKING);
d554 1
a554 1
				AddLogLine(false,IDS_ERR_FATAL);
d580 1
a580 1
				AddLogLine(false,IDS_RECONNECT, CS_RETRYCONNECTTIME); 
d620 1
a620 1
			AddLogLine(false,IDS_ERR_CONFAILED,pServerSocket->m_pServer->GetListName(), pServerSocket->m_pServer->GetFullIP(), pServerSocket->m_pServer->GetPort() );
d689 1
a689 1
		AddLogLine(false,IDS_NET_WORKING);
d752 1
a752 1
			AddDebugLogLine(false,_T("<COLOR=255,0,0>Error: Socket invalid at timeoutcheck") );
d759 1
a759 1
			AddLogLine(false,IDS_ERR_CONTIMEOUT,pTempServerSocket->m_pServer->GetListName(), pTempServerSocket->m_pServer->GetFullIP(), pTempServerSocket->m_pServer->GetPort());
@


1.87
log
@Changed fix for 255.255.255.255 server issue
@
text
@d171 1
a171 1
			AddLogLine(true,IDS_ERR_NOVALIDSERVERSFOUND);
d752 1
a752 1
			AddDebugLogLine(false,_T("Error: Socket invalid at timeoutcheck") );
@


1.86
log
@Fix for 255.255.255.255 server issue.
@
text
@d806 1
a806 6
		CServer* pServer = g_eMuleApp.m_pServerList->GetServerByAddress( m_pConnectedSocket->m_pServer->GetAddress(), m_pConnectedSocket->m_pServer->GetPort() );

		if (pServer)
			return pServer;
		else
			return m_pConnectedSocket->m_pServer;
d810 1
@


1.85
log
@Fixed server keep-alive
@
text
@d807 5
a811 1
		return pServer;
@


1.84
log
@fix for wrong server duration times (current and total)
@
text
@d926 1
@


1.83
log
@Keep-Alive for server connections
@
text
@d593 4
@


1.82
log
@Minor fix for display of no connection when no static servers with connect to static only
@
text
@d404 2
a405 1
//	If there's no server socket spec'd...
d412 1
d425 1
d898 24
@


1.81
log
@Fix for server connection problems (with eklmn help)
@
text
@d172 1
@


1.80
log
@Fix for WebServer Current Server Users and Files values
@
text
@a50 1
	m_iMaxSimultaneousConnects = 1;
d123 1
a123 1
  	if (iStartIndex == 0xFFFFFFFF)
d156 6
d181 1
a181 1
	//		Since the list has at least one srever, we just need to repeat operation.
@


1.79
log
@server zlib support indentification bug
@
text
@d793 2
a794 1
		return m_pConnectedSocket->m_pServer;
@


1.78
log
@Added Date and Time to serverlog messages
@
text
@d333 1
a333 1
		uint32		dwTagCount = 3;
d348 3
@


1.77
log
@Formatting, comments, and name changes.
@
text
@d377 2
d768 1
a768 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_pctlServerMsgBox->AppendText(CString("\n\n\n\n"));
@


1.76
log
@Rich Edit control for all logs (from official v0.30c) ;
Fixed bug #0000023 - Mouse wheel in Serverinfo window does not work
@
text
@d766 1
a766 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerMsgBox->AppendText(CString("\n\n\n\n"));
@


1.75
log
@quantized sources request from the server
@
text
@d31 1
d766 1
a766 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerMsgBox.AppendText(CString("\n\n\n\n"));
@


1.74
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d375 8
@


1.73
log
@minor fix
@
text
@d320 1
a320 1
		CMemFile		packetFile;
d322 1
a322 1
		packetFile.Write(g_eMuleApp.m_pGlobPrefs->GetUserHash(),16);	// <HASH> Our userhash
d326 1
a326 1
		packetFile.Write(&dwClientID,sizeof(uint32));
d330 1
a330 1
		packetFile.Write(&nPort,sizeof(uint16));
d334 1
a334 1
		packetFile.Write(&dwTagCount,sizeof(uint32));				// <Tag_set> {<TAGCOUNT:DWORD> 3 tags follow
d338 1
a338 1
		tag1.WriteToFile(packetFile);								// (CT_NAME:string) Our nick
d342 1
a342 1
		tag2.WriteToFile(packetFile);
d346 1
a346 1
		tag3.WriteToFile(packetFile);
d348 1
a348 1
		Packet			*pPacket = new Packet(&packetFile);
@


1.72
log
@Fixed "crash on connect to dynamic IP server".
@
text
@d593 1
a593 1
			AddLogLine(false,IDS_ERR_CONFAILED,pServerSocket->m_strInfo, pServerSocket->m_pServer->GetFullIP(), pServerSocket->m_pServer->GetPort() );
@


1.71
log
@no message
@
text
@d271 2
a272 1
		DestroySocket(pServerSocket);
d778 1
d780 1
@


1.70
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@a475 3
#ifndef ASYNC_UI_UPDATES
			g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.m_ctlSharedFilesList.UpdateOfferedItems();	// refresh offered files
#else
a476 1
#endif ASYNC_UI_UPDATES
@


1.69
log
@Formatting, comments, and name changes.
@
text
@d373 1
a373 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.RestartWaitingDownloads();
@


1.68
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d43 1
a43 1
CServerConnect::CServerConnect(CServerList *in_pServerList, CPreferences *in_pPrefs)
d48 2
a49 2
	m_pPrefs = in_pPrefs;
	m_pUsedServerList = in_pServerList;
d333 1
a333 1
		packetFile.Write(&dwTagCount,sizeof(uint32));					// <Tag_set> {<TAGCOUNT:DWORD> 3 tags follow
d337 1
a337 1
		tag1.WriteToFile(packetFile);									// (CT_NAME:string) Our nick
d411 1
a411 1
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket)
d414 8
a421 5
		if (m_bConnected && (host != NULL)){
			m_pUDPSocket->SendPacket(packet,host);
		}
		if (delpacket)
			delete packet;
d423 1
d425 1
d428 2
a429 2

void CServerConnect::ConnectionFailed(CServerSocket* sender)
d432 2
a433 1
	if (m_bConnecting == false && sender != m_pConnectedSocket)
d435 1
a435 1
		// just return, cleanup is done by the socket itself
d438 4
a441 3
	//messages + fail tries count
	CServer* update;
	switch (sender->GetConnectionState())
d444 12
a455 5
			// Purity - Sending message when internet connection down
			{ CString MessageText; 
			MessageText.Format(GetResString(IDS_ERR_FATAL));
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(), g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SERVER, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError()); }
d459 1
d461 15
a475 5
			// Purity - Sending message when connection lost to server
			{ CString MessageText;
			MessageText.Format(GetResString(IDS_ERR_LOSTC),sender->m_pServer->GetListName(),sender->m_pServer->GetFullIP(),sender->m_pServer->GetPort());
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SERVER, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError()); }
d481 1
a481 1
			AddLogLine(true,IDS_ERR_LOSTC,sender->m_pServer->GetListName(),sender->m_pServer->GetFullIP(),sender->m_pServer->GetPort());
d483 1
d485 9
a493 5
			AddLogLine(false,IDS_ERR_DEAD,sender->m_pServer->GetListName(),sender->m_pServer->GetFullIP(),sender->m_pServer->GetPort()); //<<--
			update = g_eMuleApp.m_pServerList->GetServerByAddress( sender->m_pServer->GetAddress(), sender->m_pServer->GetPort() );
			if(update){
				update->AddFailedCount();
				g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*update );
d497 1
d499 1
d502 1
d504 2
a505 1
			AddLogLine(false,IDS_ERR_FULL,sender->m_pServer->GetListName(),sender->m_pServer->GetFullIP(),sender->m_pServer->GetPort());
d507 3
a509 1
		case CS_NOTCONNECTED: 
d511 2
a512 1
			break; 
d515 1
a515 1
	if(m_iNumConnectionAttempts >= 3)
d517 1
a517 1
		if(!m_iCheckTimerID)
d519 2
a520 1
			CString sUrl;
d523 1
a523 1
			CString message = GetResString(IDS_NET_CHECKING) + " [" + sUrl + "]";
d525 1
a525 1
			AddLogLine(false, message);
d527 1
a527 1
			if(IsAliveURL(sUrl))
d536 1
a536 1
				m_iCheckTimerID = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)CheckInternetCallback);
d542 1
a542 1
	switch (sender->GetConnectionState())
d544 2
a545 1
		case CS_FATALERROR:{
d547 13
a559 6
			if ((m_pPrefs->Reconnect()) && (!m_iRetryTimerID)){ 
   				// Purity - Sending message when reconnecting after 30 seconds
				CString MessageText;
				MessageText.Format(GetResString(IDS_RECONNECT), CS_RETRYCONNECTTIME);
				g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(), g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled());
				g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SERVER, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError());
d561 1
a561 1
				m_iRetryTimerID = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)RetryConnectCallback);
d566 2
a567 1
		case CS_DISCONNECTED:{
d573 2
a574 1
			if (m_pPrefs->Reconnect() && !m_bConnecting){
d577 11
a587 5
			// Purity - Sending message when connection lost
			CString MessageText;
			MessageText.Format(GetResString(IDS_CONNECTIONLOST));
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError(), g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_SERVER, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnServerError());
d592 2
a593 1
		case CS_NOTCONNECTED:{
d596 1
a596 1
			AddLogLine(false,IDS_ERR_CONFAILED,sender->m_strInfo, sender->m_pServer->GetFullIP(), sender->m_pServer->GetPort() );
d599 2
a600 1
		case CS_SERVERFULL:{
d604 10
a613 7
			DWORD tmpkey;
			CServerSocket* tmpsock;
			POSITION pos = m_mapConnectionAttempts.GetStartPosition();
			while (pos){
				m_mapConnectionAttempts.GetNextAssoc(pos,tmpkey,tmpsock);
				if (tmpsock==sender) {
					m_mapConnectionAttempts.RemoveKey(tmpkey);
d623 1
a623 2

// 09/28/02, by zegzav
d626 5
a630 2
	EMULE_TRY	//SyruS (0.29c) NOTE: Always handle all type of MFC exceptions in TimerProcs - otherwise we'll get mem leaks
	CServerConnect *_this= g_eMuleApp.m_pServerConnect; 
d633 2
a634 1
	if (_this->IsConnected()) return; 
d637 1
d640 1
a640 2


d644 3
a646 1
	CServerConnect *_this= g_eMuleApp.m_pServerConnect; 
d652 4
a655 1
	if(_this->IsConnected()) return;
d657 1
a657 2
	CString sUrl;
	sUrl.Format(_T("http://%s"), g_eMuleApp.m_ICCURLs[rand() % g_eMuleApp.m_ICCURLs.GetSize()]);
d659 1
a659 2
	CString message = GetResString(IDS_NET_CHECKING) + " [" + sUrl + "]";
	AddLogLine(false, message);
d661 3
a663 1
	if(_this->IsAliveURL(sUrl))
d672 1
a672 1
		_this->m_iCheckTimerID = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)CheckInternetCallback);
d678 2
a679 2

bool CServerConnect::IsAliveURL(LPCTSTR sURL)
d682 4
a685 2
	HINTERNET hOpen = InternetOpen(_T(""), INTERNET_OPEN_TYPE_PRECONFIG , NULL, NULL, 0);
	if(!hOpen)
d688 3
a690 2
	HINTERNET hUrl =  InternetOpenUrl(hOpen, sURL, _T(""), NULL, /*INTERNET_FLAG_NO_AUTH | */INTERNET_FLAG_NO_CACHE_WRITE, NULL);
	if(!hUrl)
d696 4
a699 4
	TCHAR szBuffer[100];
	DWORD dwBytes = 100;
	DWORD dwIndex = 0;
	BOOL bQ = HttpQueryInfo(hUrl, HTTP_QUERY_STATUS_CODE, szBuffer, &dwBytes, &dwIndex);
d701 1
a701 1
	bool bSuccess = bQ && !_tcscmp(szBuffer, _T("200"));
d703 1
a703 1
	InternetCloseHandle(hUrl);
d707 1
d709 1
d712 1
a712 1

d716 12
a727 8
	//SyruS (0,29c) DWORD maxage=GetTickCount() - CONSERVTIMEOUT;	// this gives us problems when TickCount < TIMEOUT (may occure right after system start)
	DWORD dwCurTick = GetTickCount();
	DWORD tmpkey;
	CServerSocket* tmpsock;
	POSITION pos = m_mapConnectionAttempts.GetStartPosition();
	while (pos){
		m_mapConnectionAttempts.GetNextAssoc(pos,tmpkey,tmpsock);
		if (!tmpsock) {
d729 1
a729 1
			m_mapConnectionAttempts.RemoveKey(tmpkey);
d733 4
a736 4
		//SyruS (0,29c) if (tmpkey<=maxage) {
		if (dwCurTick - tmpkey > CONSERVTIMEOUT){
			AddLogLine(false,IDS_ERR_CONTIMEOUT,tmpsock->m_pServer->GetListName(), tmpsock->m_pServer->GetFullIP(), tmpsock->m_pServer->GetPort() );
			m_mapConnectionAttempts.RemoveKey(tmpkey);
a737 1
			//DestroySocket(tmpsock);	//eklmn: socket will be destroyed over TryAnotherConnectionRequest()
d776 1
a776 1
CServer* CServerConnect::GetCurrentServer()
d779 2
a780 1
	if (IsConnected() && m_pConnectedSocket)
d782 1
d786 2
a787 3

//purity (Server status in WebServer)
CServer* CServerConnect::GetConnectingServer()
d790 1
d793 1
d795 1
d798 1
a798 1

d802 1
d804 2
a805 1
	g_eMuleApp.m_pdlgEmule->ShowConnectionState(IsConnected(),GetCurrentServer()->GetListName() );
d842 3
a844 1
	if (IsConnected()){
d848 1
d850 1
@


1.67
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d451 5
a455 1
			g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.sharedfilesctrl.UpdateOfferedItems();	// refresh offered files
d691 1
a691 1
			g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.sharedfilesctrl.UpdateOfferedItems();
@


1.66
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d69 2
a70 1
	// stop all connections
d72 1
a72 1
	// close connected socket, if any
d75 1
a75 1
	// close udp socket
d78 1
d84 4
a87 3
  EMULE_TRY
  	//eklmn: change funny condition :) (m_mapConnectionAttempts.GetCount() < ((m_pPrefs->IsSafeConnectEnabled()) ? 1 : 2))
	if ( m_mapConnectionAttempts.GetCount() == 0)
d89 1
a89 1
		CServer*  next_server = m_pUsedServerList->GetNextServer();
d91 1
a91 1
		if (!next_server)
d93 2
a94 1
			if (m_mapConnectionAttempts.GetCount()==0){
d101 1
a101 1
		// Barry - Only auto-connect to static server option
d104 2
a105 2
			if (next_server->IsStaticMember())
				ConnectToServer(*next_server);
d108 3
a110 1
			ConnectToServer(*next_server);
d112 2
a113 1
  EMULE_CATCH
d212 1
d241 1
a241 1
		/*
d246 2
a247 1
			if (pSck->m_SocketData.hSocket != INVALID_SOCKET){ // deadlake PROXYSUPPORT - changed to AsyncSocketEx
d253 1
a253 1
		*/
d258 1
a258 1
void CServerConnect::ConnectionEstablished(CServerSocket *pServerSocket)
d318 2
a319 2
	//	Construct the packet byte stream
		CMemFile		dataFile;
d321 1
a321 1
		dataFile.Write(g_eMuleApp.m_pGlobPrefs->GetUserHash(),16);	// Our userhash
d323 1
a323 1
		uint32		dwClientID = GetClientID();						// Our client ID
d325 1
a325 1
		dataFile.Write(&dwClientID,sizeof(uint32));
d327 1
a327 1
		uint16		nPort = m_pPrefs->GetPort();					// Our TCP port
d329 1
a329 1
		dataFile.Write(&nPort,sizeof(uint16));
d333 1
a333 1
		dataFile.Write(&dwTagCount,sizeof(uint32));					// 3 tags follow
d337 1
a337 1
		tag1.WriteToFile(dataFile);									// Our nick
d339 1
a339 1
		CClientTag		tag2(CT_VERSION,EDONKEYVERSION);			// Our software version #
d341 1
a341 1
		tag2.WriteToFile(dataFile);
d343 1
a343 1
		CClientTag		tag3(CT_PORT,m_pPrefs->GetPort());			// Our port again?
d345 1
a345 1
		tag3.WriteToFile(dataFile);
d347 1
a347 1
		Packet			*pPacket = new Packet(&dataFile);
d353 1
d357 1
a357 1
		g_eMuleApp.stat_serverConnectTime=GetTickCount();
a364 1
		// tecxx 1609 2002 - m_pServerList update
d367 4
a370 3
			Packet* packet = new Packet(OP_GETSERVERLIST,0);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
			SendPacket(packet,true);
@


1.65
log
@Formatting, comments, and name changes.
@
text
@d53 1
a53 1
	m_iClientID = 0;
d56 1
a56 1
	m_idRetryTimer= 0;
d58 1
a58 1
	m_idCheckTimer = 0;
d185 1
a185 1
		
d217 1
a217 1
	if (m_idRetryTimer) 
d219 2
a220 2
		KillTimer(NULL, m_idRetryTimer); 
		m_idRetryTimer = 0; 
d249 1
a249 1
void CServerConnect::ConnectionEstablished(CServerSocket* sender)
d251 3
a253 1
  EMULE_TRY
d255 3
a257 3
	if(m_idCheckTimer)
	  	KillTimer(NULL, m_idCheckTimer);
	m_idCheckTimer = 0;
d259 1
d262 1
a262 2
		// we are already connected to another server
		DestroySocket(sender);
d265 1
d267 12
a278 5
	if (sender->GetConnectionState() == CS_WAITFORLOGIN){
		//Cax2 - reset the timeout timer
		ULONG tmpkey;
		CServerSocket* tmpsock;
		POSITION pos = m_mapConnectionAttempts.GetStartPosition();
d281 4
a284 2
			m_mapConnectionAttempts.GetNextAssoc(pos,tmpkey,tmpsock);
			if (tmpsock==sender)
d286 5
a290 3
				m_mapConnectionAttempts.RemoveKey(tmpkey);
				tmpkey=GetTickCount();
				m_mapConnectionAttempts.SetAt(tmpkey,sender);
d294 49
a342 30
		//Cax2 - end reset the timeout timer
		AddLogLine(false,IDS_CONNECTEDTOREQ,sender->m_pServer->GetListName(),sender->m_pServer->GetFullIP(),sender->m_pServer->GetPort());
		//send loginpacket
		CServer* update = g_eMuleApp.m_pServerList->GetServerByAddress( sender->m_pServer->GetAddress(), sender->m_pServer->GetPort() );
		if (update){
			update->ResetFailedCount();
			g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*update );
		}
		CMemFile data;
		data.Write(g_eMuleApp.m_pGlobPrefs->GetUserHash(),16);
		uint32 iClientID = GetClientID();
		data.Write(&iClientID,4);
		uint16 port = m_pPrefs->GetPort();
		data.Write(&port,2);
		uint32 tagcount = 3;
		data.Write(&tagcount,4);
		CTag* tag = new CTag(CT_NAME,m_pPrefs->GetUserNick().GetBuffer());
		tag->WriteTagToFile(data);
		delete tag;
		tag = new CTag(CT_VERSION,EDONKEYVERSION);
		tag->WriteTagToFile(data);
		delete tag;
		tag = new CTag(CT_PORT,m_pPrefs->GetPort());
		tag->WriteTagToFile(data);
		delete tag;

		Packet* packet = new Packet(&data);
		packet->opcode = OP_LOGINREQUEST;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
		this->SendPacket(packet,true,sender);		
d344 2
a345 1
	else if (sender->GetConnectionState() == CS_CONNECTED){	
d349 3
a351 3
		AddLogLine(true,IDS_CONNECTEDTO,sender->m_pServer->GetListName());
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(true,sender->m_pServer->GetListName());
		m_pConnectedSocket = sender;
d359 1
a359 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
d365 2
a366 1
  EMULE_CATCH
d368 2
a369 2

bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to)
d372 8
a379 3
	if (!to){
		if (m_bConnected){
			m_pConnectedSocket->SendPacket(packet,delpacket,true);
d381 5
a385 3
		else{
      		if (delpacket)
        	delete packet;
d389 3
a391 2
	else{
		to->SendPacket(packet,delpacket,true);
d393 1
d395 1
d397 1
d400 1
a400 1

d466 1
a466 1
		if(!m_idCheckTimer)
d484 1
a484 1
				m_idCheckTimer = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)CheckInternetCallback);
d494 1
a494 1
			if ((m_pPrefs->Reconnect()) && (!m_idRetryTimer)){ 
d501 1
a501 1
				m_idRetryTimer = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)RetryConnectCallback);
d571 2
a572 2
	KillTimer(NULL, _this->m_idCheckTimer);
	_this->m_idCheckTimer = 0;
d591 1
a591 1
		_this->m_idCheckTimer = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)CheckInternetCallback);
d709 1
a709 1
	m_iClientID = newid;
d754 2
a755 1

d759 15
a773 7
	m_iLocalIP = 0;
	// Don't use 'gethostbyname(NULL)'. The winsock DLL may be replaced by a DLL from a third party
	// which is not fully compatible to the original winsock DLL. ppl reported crash with SCORSOCK.DLL
	// when using 'gethostbyname(NULL)'.
	char szHost[256];
	if (gethostname(szHost, sizeof szHost) == 0){
		hostent* pHostEnt = gethostbyname(szHost);
d775 1
a775 1
			m_iLocalIP = *((uint32*)pHostEnt->h_addr_list[0]);
d777 1
d780 1
@


1.64
log
@Some statistics fixes
@
text
@d83 2
a84 2
  	//eklmn: change funny condition :) (connectionattemps.GetCount() < ((m_pPrefs->IsSafeConnectEnabled()) ? 1 : 2))
	if ( connectionattemps.GetCount() == 0)
d90 1
a90 1
			if (connectionattemps.GetCount()==0){
d108 4
d113 1
a113 3
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto)
{
  EMULE_TRY
d115 4
a118 4
 	CServer *next_server; 
  	if (startAt == 0xFFFFFFFF)
		startAt = m_pUsedServerList->GetServerPostion();
	m_iLastServerListStartPos = startAt;
d120 1
d122 1
d126 3
a128 4
	// connectig will be set to true only when socket will be created
	//m_bConnecting = true;
	// eklmn: check size of the list
	if (m_pUsedServerList->GetServerCount()==0 )
a129 1
		//m_bConnecting = false;
d133 14
a146 9
	// eklmn: now sort the list
	if( g_eMuleApp.m_pGlobPrefs->Score() && prioSort ) m_pUsedServerList->Sort();
	// Barry - Only auto-connect to static server option
	if (g_eMuleApp.m_pGlobPrefs->AutoConnectStaticOnly() && isAuto)
	{
		bool anystatic = false;
		m_pUsedServerList->SetServerPosition( startAt );
		//eklmn: scan all servers in the list
		for (uint32 i=0; i<m_pUsedServerList->GetServerCount();i++)		//while ((next_server = m_pUsedServerList->GetNextServer()) != NULL)
d148 2
a149 2
			next_server = m_pUsedServerList->GetNextServer();
			if (next_server->IsStaticMember())
d151 1
a151 1
				anystatic = true;
d155 2
a156 1
		if (!anystatic)
a157 1
			//m_bConnecting = false;
d162 2
a163 1
	else		// eklmn: just pick up new server
d165 6
a170 6
		m_pUsedServerList->SetServerPosition( startAt );
		next_server = m_pUsedServerList->GetServerAt(startAt);
		// eklmn: if we are in the end of m_pServerList, we gonna to become next_server = NULL.
		// since list has at least one srever, we just need to repeat operation
		if (next_server == NULL)
			next_server = m_pUsedServerList->GetNextServer();
d172 1
d175 5
a179 5
	// at this point we have a server object "next_server" let's connect to him
	if (next_server != NULL)
		ConnectToServer(*next_server);
	//TryAnotherConnectionRequest();
  EMULE_CATCH
d181 2
a182 2

void CServerConnect::ConnectToServer(CServer& server)
d189 1
a189 1
	m_pConnectedServerSocket = &server;	//purity (Server status in WebServer)
d191 5
a195 3
	CServerSocket* newsocket = new CServerSocket(this);
	if (newsocket) {
		//AddDebugLogLine(false, "-server->: Socket was created (m_bConnecting = true). ");
d197 7
a203 5
		m_lstOpenSockets.AddTail(newsocket);
		newsocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL);
		newsocket->ConnectToServer(server);
		ULONG x=GetTickCount();
		connectionattemps.SetAt(x,newsocket);
d207 3
a209 1

d212 3
a214 2
  EMULE_TRY
	connectionattemps.RemoveAll();
d220 1
a220 1
		m_idRetryTimer= 0; 
d223 4
a226 3
	// close all currently opened sockets except the one which is connected to our current server
	POSITION pos1, pos2;
	for(pos1 = m_lstOpenSockets.GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
d228 3
a230 4
	
		CServerSocket* pSck = m_lstOpenSockets.GetNext(pos1);
		// don't destroy socket which is connected to server
		// don't destroy socket if it is going to destroy itself later on
d236 1
a236 1
			m_lstOpenSockets.RemoveAt(pos2);
d246 1
a246 1
  EMULE_CATCH
d248 1
a248 1

d268 1
a268 1
		POSITION pos = connectionattemps.GetStartPosition();
d271 1
a271 1
			connectionattemps.GetNextAssoc(pos,tmpkey,tmpsock);
d274 1
a274 1
				connectionattemps.RemoveKey(tmpkey);
d276 1
a276 1
				connectionattemps.SetAt(tmpkey,sender);
d281 1
a281 1
		AddLogLine(false,IDS_CONNECTEDTOREQ,sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d283 1
a283 1
		CServer* update = g_eMuleApp.m_pServerList->GetServerByAddress( sender->cur_server->GetAddress(), sender->cur_server->GetPort() );
d286 1
a286 1
			g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*update );
d315 2
a316 2
		AddLogLine(true,IDS_CONNECTEDTO,sender->cur_server->GetListName());
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(true,sender->cur_server->GetListName());
d320 1
a320 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RemoveDeadServer();
d392 1
a392 1
			MessageText.Format(GetResString(IDS_ERR_LOSTC),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d396 1
a396 1
			AddLogLine(true,IDS_ERR_LOSTC,sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d399 2
a400 2
			AddLogLine(false,IDS_ERR_DEAD,sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort()); //<<--
			update = g_eMuleApp.m_pServerList->GetServerByAddress( sender->cur_server->GetAddress(), sender->cur_server->GetPort() );
d403 1
a403 1
				g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*update );
d411 1
a411 1
			AddLogLine(false,IDS_ERR_FULL,sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d481 1
a481 1
			AddLogLine(false,IDS_ERR_CONFAILED,sender->info, sender->cur_server->GetFullIP(), sender->cur_server->GetPort() );
d490 1
a490 1
			POSITION pos = connectionattemps.GetStartPosition();
d492 1
a492 1
				connectionattemps.GetNextAssoc(pos,tmpkey,tmpsock);
d494 1
a494 1
					connectionattemps.RemoveKey(tmpkey);
d588 1
a588 1
	POSITION pos = connectionattemps.GetStartPosition();
d590 1
a590 1
		connectionattemps.GetNextAssoc(pos,tmpkey,tmpsock);
d593 1
a593 1
			connectionattemps.RemoveKey(tmpkey);
d599 2
a600 2
			AddLogLine(false,IDS_ERR_CONTIMEOUT,tmpsock->cur_server->GetListName(), tmpsock->cur_server->GetFullIP(), tmpsock->cur_server->GetPort() );
			connectionattemps.RemoveKey(tmpkey);
d607 1
a607 1

d611 5
a615 1
	if ((m_bConnected || m_bConnecting) && m_pConnectedSocket){ // eklmn: bugfix(10): socket will be not destoyed if server is changed during connecting
d617 3
a619 1
		bool prevconnected= m_bConnected;
d622 2
a623 1
		m_bConnecting =false;	// eklmn: bugfix(10): socket will be not destoyed if server is changed during connecting
d625 3
a627 3
		g_eMuleApp.m_pdlgEmule->m_wndServer.servermsgbox.AppendText(CString("\n\n\n\n"));
		g_eMuleApp.stat_serverConnectTime=0;
		// -khaos--+++> Tell our total server duration thinkymajig to update...
d629 4
a632 3
		// <-----khaos-
		if (prevconnected)
			g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.sharedfilesctrl.UpdateOfferedItems();	// refresh offered files
d635 1
d637 1
d640 1
a640 2


d645 1
a645 1
		return m_pConnectedSocket->cur_server;
d667 3
a669 2

void CServerConnect::DestroySocket(CServerSocket* pSck)
d672 1
d676 7
a682 3
	POSITION posDel = m_lstOpenSockets.Find(pSck);
	if (posDel != NULL) {
		m_lstOpenSockets.RemoveAt(posDel);		
d685 3
a687 1
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET){ // deadlake PROXYSUPPORT - changed to AsyncSocketEx
d689 1
d697 1
a697 1

d702 1
a702 1
		if (m_pConnectedSocket->cur_server->GetIP() == dwIP && m_pConnectedSocket->cur_server->GetPort() == nPort)
@


1.63
log
@Formatting, comments, and name changes.
@
text
@d604 3
@


1.62
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@a37 12
/*
static TCHAR g_Urls[7][50] = {
	_T("www.microsoft.com"),
	_T("www.yahoo.com"),
	_T("www.ibm.com"),
	_T("www.army.mil"),
	_T("www.networksolutions.com"),
	_T("www.ripe.net"),
	_T("www.w3.org")
};
*/

d42 39
a80 1
void CServerConnect::TryAnotherConnectionrequest()
d83 1
a83 1
  	//eklmn: change funny condition :) (connectionattemps.GetCount() < ((app_prefs->IsSafeConnectEnabled()) ? 1 : 2))
d86 1
a86 1
		CServer*  next_server = used_list->GetNextServer();
d92 1
a92 1
				ConnectToAnyServer(lastStartAt,false);
d115 2
a116 2
		startAt = used_list->GetServerPostion();
	lastStartAt=startAt;
d123 1
a123 1
	//connecting = true;
d125 1
a125 1
	if (used_list->GetServerCount()==0 )
d127 1
a127 1
		//connecting = false;
d132 1
a132 1
	if( g_eMuleApp.m_pGlobPrefs->Score() && prioSort ) used_list->Sort();
d137 1
a137 1
		used_list->SetServerPosition( startAt );
d139 1
a139 1
		for (uint32 i=0; i<used_list->GetServerCount();i++)		//while ((next_server = used_list->GetNextServer()) != NULL)
d141 1
a141 1
			next_server = used_list->GetNextServer();
d150 1
a150 1
			//connecting = false;
d157 2
a158 2
		used_list->SetServerPosition( startAt );
		next_server = used_list->GetServerAt(startAt);
d162 1
a162 1
			next_server = used_list->GetNextServer();
d169 1
a169 1
	//TryAnotherConnectionrequest();
d180 1
a180 1
	ConnectingToServer = &server;	//purity (Server status in WebServer)
d184 2
a185 2
		//AddDebugLogLine(false, "-server->: Socket was created (connecting = true). ");
		connecting = true;
d199 1
a199 1
	connecting = false;
d207 1
a207 1
	// close all currenty opened sockets except the one which is connected to our current server
d215 1
a215 1
		if (pSck != connectedsocket)
d218 1
a218 1
		if ((pSck != NULL) && (pSck != connectedsocket))	
d236 1
a236 1
	m_nConnectionAttempts = 0;
d241 1
a241 1
	if (connecting == false)
d274 3
a276 3
		uint32 clientid = GetClientID();
		data.Write(&clientid,4);
		uint16 port = app_prefs->GetPort();
d280 1
a280 1
		CTag* tag = new CTag(CT_NAME,app_prefs->GetUserNick().GetBuffer());
d286 1
a286 1
		tag = new CTag(CT_PORT,app_prefs->GetPort());
d298 1
a298 1
		connected = true;
d301 1
a301 1
		connectedsocket = sender;
d322 2
a323 2
		if (connected){
			connectedsocket->SendPacket(packet,delpacket,true);
d342 2
a343 2
		if (connected && (host != NULL)){
			udpsocket->SendPacket(packet,host);
d355 1
a355 1
	if (connecting == false && sender != connectedsocket)
d371 1
a371 1
			m_nConnectionAttempts++;
d389 1
a389 1
			m_nConnectionAttempts++;
d392 1
a392 1
			m_nConnectionAttempts++;
d398 1
a398 1
			m_nConnectionAttempts++;
d402 1
a402 1
	if(m_nConnectionAttempts >= 3)
d407 1
a407 1
			sUrl.Format(_T("http://%s"), g_eMuleApp.g_Urls[rand() % g_eMuleApp.g_Urls.GetSize()]);
d416 1
a416 1
				m_nConnectionAttempts = 0;
d432 1
a432 1
			if ((app_prefs->Reconnect()) && (!m_idRetryTimer)){ 
d445 4
a448 4
			connected = false;
			if (connectedsocket) 
				connectedsocket->Close();
			connectedsocket = NULL;
d450 1
a450 1
			if (app_prefs->Reconnect() && !connecting){
d463 1
a463 1
			if (!connecting)
d469 1
a469 1
			if (!connecting)
d482 1
a482 1
			TryAnotherConnectionrequest();
d515 1
a515 1
	sUrl.Format(_T("http://%s"), g_eMuleApp.g_Urls[rand() % g_eMuleApp.g_Urls.GetSize()]);
d523 1
a523 1
		_this->m_nConnectionAttempts = 0;
d585 2
a586 2
			TryAnotherConnectionrequest();
			//DestroySocket(tmpsock);	//eklmn: socket will be destroyed over TryAnotherConnectionrequest()
d595 6
a600 6
	if ((connected || connecting) && connectedsocket){ // eklmn: bugfix(10): socket will be not destoyed if server is changed during connecting
		DestroySocket(connectedsocket);
		bool prevconnected= connected;
		connectedsocket = NULL;
		connected = false;
		connecting =false;	// eklmn: bugfix(10): socket will be not destoyed if server is changed during connecting
a611 34
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs)
{
	EMULE_TRY
	connectedsocket = NULL;
	app_prefs = in_prefs;
	used_list = in_serverlist;
	max_simcons = 1;
	connecting = false;
	connected = false;
	clientid = 0;
	udpsocket = new CUDPSocket(this); // initalize socket for udp packets
	udpsocket->Create();
	m_idRetryTimer= 0;
	lastStartAt=0;
	m_idCheckTimer = 0;
	m_nConnectionAttempts = 0;
	ConnectingToServer = NULL;
	InitLocalIP();
	EMULE_CATCH
}

CServerConnect::~CServerConnect()
{
	EMULE_TRY
	// stop all connections
	StopConnectionTry();
	// close connected socket, if any
	DestroySocket(connectedsocket);
	connectedsocket = NULL;
	// close udp socket
	udpsocket->Close();
	delete udpsocket;
	EMULE_CATCH
}
d616 2
a617 2
	if (IsConnected() && connectedsocket)
		return connectedsocket->cur_server;
d626 2
a627 2
	if (connecting && ConnectingToServer)
		return ConnectingToServer;
d635 1
a635 1
	clientid = newid;
d665 1
a665 1
		if (connectedsocket->cur_server->GetIP() == dwIP && connectedsocket->cur_server->GetPort() == nPort)
d675 1
a675 1
	m_nLocalIP = 0;
d683 1
a683 1
			m_nLocalIP = *((uint32*)pHostEnt->h_addr_list[0]);
@


1.61
log
@Server connection minor changes & update to Light Template
@
text
@d25 1
a25 1
#include "searchlist.h"
d72 1
a72 1
		if (theApp.glob_prefs->AutoConnectStaticOnly())
d95 1
a95 1
	theApp.emuledlg->ShowConnectionState(false,_T(""),true);
d106 1
a106 1
	if( theApp.glob_prefs->Score() && prioSort ) used_list->Sort();
d108 1
a108 1
	if (theApp.glob_prefs->AutoConnectStaticOnly() && isAuto)
d133 1
a133 1
		// eklmn: if we are in the end of serverlist, we gonna to become next_server = NULL.
d138 1
a138 1
	theApp.listensocket->Process();
d241 1
a241 1
		CServer* update = theApp.serverlist->GetServerByAddress( sender->cur_server->GetAddress(), sender->cur_server->GetPort() );
d244 1
a244 1
			theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*update );
d247 1
a247 1
		data.Write(theApp.glob_prefs->GetUserHash(),16);
d266 1
a266 1
		theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
d270 2
a271 2
		theApp.stat_reconnects++;
		theApp.stat_serverConnectTime=GetTickCount();
d274 1
a274 1
		theApp.emuledlg->ShowConnectionState(true,sender->cur_server->GetListName());
d277 4
a280 4
		theApp.sharedfiles->SendListToServer();
		theApp.emuledlg->serverwnd.serverlistctrl.RemoveDeadServer();
		// tecxx 1609 2002 - serverlist update
		if (theApp.glob_prefs->GetAddServersFromConn())
d283 1
a283 1
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
d286 2
a287 2
		if(theApp.glob_prefs->RestartWaiting())
			theApp.emuledlg->transferwnd.m_wndDownloadList.RestartWaitingDownloads();
d342 2
a343 2
			theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnServerError(), theApp.glob_prefs->IsSMTPWarningEnabled());
			theApp.emuledlg->ShowNotifier(MessageText, TBN_SERVER, false, theApp.glob_prefs->GetNotifierPopOnServerError()); }
d351 3
a353 3
			theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnServerError(), theApp.glob_prefs->IsSMTPInfoEnabled());
			theApp.emuledlg->ShowNotifier(MessageText, TBN_SERVER, false, theApp.glob_prefs->GetNotifierPopOnServerError()); }
			theApp.emuledlg->sharedfileswnd.sharedfilesctrl.UpdateOfferedItems();	// refresh offered files
d358 1
a358 1
			update = theApp.serverlist->GetServerByAddress( sender->cur_server->GetAddress(), sender->cur_server->GetPort() );
d361 1
a361 1
				theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*update );
d381 1
a381 1
			sUrl.Format(_T("http://%s"), theApp.g_Urls[rand() % theApp.g_Urls.GetSize()]);
d410 2
a411 2
				theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnServerError(), theApp.glob_prefs->IsSMTPWarningEnabled());
				theApp.emuledlg->ShowNotifier(MessageText, TBN_SERVER, false, theApp.glob_prefs->GetNotifierPopOnServerError());
d415 1
a415 1
			theApp.emuledlg->ShowConnectionState(false,_T(""),true);
d423 1
a423 1
			theApp.emuledlg->searchwnd.OnBnClickedCancels();
d430 3
a432 3
			theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnServerError(), theApp.glob_prefs->IsSMTPWarningEnabled());
			theApp.emuledlg->ShowNotifier(MessageText, TBN_SERVER, false, theApp.glob_prefs->GetNotifierPopOnServerError());
			theApp.emuledlg->ShowConnectionState(false,_T(""),true);
d459 1
a459 1
	theApp.emuledlg->ShowConnectionState(false,_T(""),true);
d467 1
a467 1
	CServerConnect *_this= theApp.serverconnect; 
d480 1
a480 1
	CServerConnect *_this= theApp.serverconnect; 
d489 1
a489 1
	sUrl.Format(_T("http://%s"), theApp.g_Urls[rand() % theApp.g_Urls.GetSize()]);
d575 3
a577 3
		theApp.emuledlg->ShowConnectionState(false,_T(""));
		theApp.emuledlg->serverwnd.servermsgbox.AppendText(CString("\n\n\n\n"));
		theApp.stat_serverConnectTime=0;
d579 1
a579 1
			theApp.emuledlg->sharedfileswnd.sharedfilesctrl.UpdateOfferedItems();	// refresh offered files
d644 1
a644 1
	theApp.emuledlg->ShowConnectionState(IsConnected(),GetCurrentServer()->GetListName() );
@


1.60
log
@First step of ICC (Internet Connection Check) configuration. Only in ini for now.
@
text
@a97 1
	singleconnecting = false;
a139 1
	// DonGato: removed because it tries to connect to the same server multiple times
d141 3
a143 3
	//if (next_server != NULL)
	//	ConnectToServer(*next_server, true);
	TryAnotherConnectionrequest();
d147 1
a147 1
void CServerConnect::ConnectToServer(CServer& server, bool multiconnect)
d151 2
a152 4
	if (!multiconnect) {
		StopConnectionTry();
		Disconnect();
	}
a154 1
	//singleconnecting = !multiconnect;	// eklmn: there is no point to have this variable here
a173 1
	singleconnecting = false;
d383 3
a385 1
			AddLogLine(false, IDS_NET_CHECKING + "[" + sUrl + "]");
d394 1
a404 1
			bool autoretry= !singleconnecting;
d406 1
a406 1
			if ((app_prefs->Reconnect()) && (autoretry) && (!m_idRetryTimer)){ 
a444 5
			/*if (singleconnecting){
				StopConnectionTry();
				break;
			}
			*/
a485 2
	AddLogLine(false, IDS_NET_CHECKING);

d490 4
a595 1
	singleconnecting = false;
@


1.59
log
@Fix for multiple server connections time
@
text
@d38 1
a38 1

d48 1
a385 1
			AddLogLine(false, IDS_NET_CHECKING);
d387 4
a390 1
			sUrl.Format(_T("http://%s"), g_Urls[rand() % 7]);
d500 1
a500 1
	sUrl.Format(_T("http://%s"), g_Urls[rand() % 7]);
@


1.58
log
@*** empty log message ***
@
text
@d57 1
a57 1
	if ( connectionattemps.GetCount() == 0) 
d140 1
d142 3
a144 3
	if (next_server != NULL)
		ConnectToServer(*next_server, true);
	//TryAnotherConnectionrequest();
@


1.57
log
@share files with soft limit
@
text
@d291 1
a291 1
			theApp.emuledlg->transferwnd.downloadlistctrl.RestartWaitingDownloads();
@


1.56
log
@Removed Safe Connect
@
text
@d357 1
d574 1
d581 2
@


1.55
log
@fix for "SafeConnect" :) it just removed
@
text
@d591 1
a591 1
	max_simcons = (app_prefs->IsSafeConnectEnabled()) ? 1 : 2;
@


1.54
log
@eMailNotifier and PopUp CleanUp
@
text
@d56 3
a58 2
	if ( connectionattemps.GetCount()< ((app_prefs->IsSafeConnectEnabled()) ? 1 : 2)) {

@


1.53
log
@restart waiting downloads option wasn't used
@
text
@d343 4
a346 7
			if(theApp.glob_prefs->IsSMTPInfoEnabled())
			{
				CSMTPConnection mail;
				CString txt;
				txt.Format(GetResString(IDS_ERR_FATAL));
				mail.SendMuleMessage(txt);
			}
d352 4
a355 7
			if(theApp.glob_prefs->IsSMTPInfoEnabled())
			{
				CSMTPConnection mail;
				CString txt;
				txt.Format(GetResString(IDS_ERR_LOSTC),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
				mail.SendMuleMessage(txt);
			}
d406 4
a409 7
				if(theApp.glob_prefs->IsSMTPWarningEnabled())
				{
					CSMTPConnection mail;
					CString txt;
					txt.Format(GetResString(IDS_RECONNECT), CS_RETRYCONNECTTIME);
					mail.SendMuleMessage(txt);
				}
d425 5
a429 11
			if (theApp.glob_prefs->GetNotifierPopOnImportantError()) {
				// Purity - Sending message when connection lost
				if(theApp.glob_prefs->IsSMTPWarningEnabled())
				{
					CSMTPConnection mail;
					CString txt;
					txt.Format(GetResString(IDS_CONNECTIONLOST));
					mail.SendMuleMessage(txt);
				}
				theApp.emuledlg->ShowNotifier(GetResString(IDS_CONNECTIONLOST), TBN_IMPORTANTEVENT, false);
			}
@


1.52
log
@Purity's changes
@
text
@d289 2
a290 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RestartWaitingDownloads();
@


1.51
log
@removed a debug output for Connection Problem
@
text
@d30 1
d341 8
d353 8
d410 8
d434 8
@


1.50
log
@Small fix for a log line
@
text
@d159 1
a159 1
		AddDebugLogLine(false, "-server->: Socket was created (connecting = true). ");
@


1.49
log
@fixed search of static servers (now will be scanned all servers in the list)
@
text
@d539 1
a539 1
			AddLogLine(false,IDS_ERR_CONTIMEOUT,tmpsock->info, tmpsock->cur_server->GetFullIP(), tmpsock->cur_server->GetPort() );
@


1.48
log
@double deletion of the socket after timeout
@
text
@d110 2
a111 1
		while ((next_server = used_list->GetNextServer()) != NULL)
d113 1
@


1.47
log
@fixed server full issue & memleak over TryAnotherConnectionrequest()
@
text
@d540 1
a540 1
			DestroySocket(tmpsock);
@


1.46
log
@futher change of ConnectToAnyServer()
@
text
@d72 1
a72 1
                ConnectToServer(*next_server,true);
d75 1
a75 1
			ConnectToServer(*next_server,true);
d138 1
a138 1
		ConnectToServer(*next_server,false);
d153 1
a153 1
	singleconnecting = !multiconnect;
d422 1
a422 1
			if (singleconnecting){
d426 1
@


1.45
log
@fixed one condition :)
@
text
@d63 1
a63 1
				ConnectToAnyServer(lastStartAt);
d85 2
@


1.44
log
@ConnectToAnyServer was rewritten
@
text
@d135 1
a135 1
	if (next_server == NULL)
@


1.43
log
@variable "connecting" will used slightly other way
@
text
@d83 2
d86 1
d89 1
d94 9
a102 1

a106 1
		CServer *next_server; 
d123 8
a130 8

	used_list->SetServerPosition( startAt );
	if( theApp.glob_prefs->Score() && prioSort ) used_list->Sort();

	if (used_list->GetServerCount()==0 ){
		//connecting = false;
		AddLogLine(true,IDS_ERR_NOVALIDSERVERSFOUND);
		return;
d134 4
a137 1
	TryAnotherConnectionrequest();
@


1.42
log
@roll back 2 previous fix
@
text
@d87 2
a88 1
	connecting = true;
d107 1
a107 1
			connecting = false;
d117 1
a117 1
		connecting = false;
a157 1
	connectedsocket = NULL;
@


1.41
log
@fix over fix :)
@
text
@d157 1
d169 1
a170 3
		DestroySocket(pSck);
		if (pSck == connectedsocket)
			connectedsocket = NULL;
d173 2
@


1.40
log
@infinite delete loop by loosing server connection (thanks partyskip)
@
text
@d170 2
@


1.39
log
@auto reconnection fix
@
text
@d169 1
a169 1

d172 1
d183 1
d611 1
a611 1
	
d623 1
a625 1

@


1.38
log
@bugfix for CServerConnect::CheckForTimeout (from 0.29c)
more try&catch
@
text
@d128 2
a129 1
  EMULE_TRY
d134 1
a134 1
	connecting = true;
d139 10
a148 6
	m_lstOpenSockets.AddTail(newsocket);
	newsocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL);
	newsocket->ConnectToServer(server);
	ULONG x=GetTickCount();
	connectionattemps.SetAt(x,newsocket);
  EMULE_CATCH
@


1.37
log
@merge CloseSocket & DestroySocket (LowID problem)
@
text
@d126 2
a127 1
void CServerConnect::ConnectToServer(CServer& server, bool multiconnect){
d146 2
a147 1
void CServerConnect::StopConnectionTry(){
d265 3
a267 1
bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to){
d282 2
d286 3
a288 1
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket){
d295 2
d299 3
a301 1
void CServerConnect::ConnectionFailed(CServerSocket* sender){
d309 2
a310 1
	switch (sender->GetConnectionState()){
a355 2
		

a356 1

d359 2
a360 1
	switch (sender->GetConnectionState()){
d415 1
d421 1
d427 2
a428 1
	_this->ConnectToAnyServer(); 
d433 2
a434 1
{ 
a458 1

d460 1
d465 1
d488 2
d493 4
a496 2
{ 
	DWORD maxage=GetTickCount() - CONSERVTIMEOUT;
d508 2
a509 1
		if (tmpkey<=maxage) {
d516 1
d519 3
a521 1
bool CServerConnect::Disconnect(){
d532 2
a533 2
	else
		return false;
d536 3
a538 1
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs){
d555 1
d558 3
a560 1
CServerConnect::~CServerConnect(){
d569 1
d572 3
a574 1
CServer* CServerConnect::GetCurrentServer(){
d577 1
d582 3
a584 1
CServer* CServerConnect::GetConnectingServer(){
d587 2
a588 2
	else
		return NULL;
d591 3
a593 1
void CServerConnect::SetClientID(uint32 newid){
d596 1
d599 3
a601 2
void CServerConnect::DestroySocket(CServerSocket* pSck){

d616 1
d620 3
a622 1
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort){
d627 1
d631 2
a632 2
void CServerConnect::InitLocalIP(){

a633 1
		
a643 1

@


1.36
log
@added InitLocalIP fuction....
@
text
@d561 5
a565 2
void CServerConnect::CloseSocket(CServerSocket* pSck){
		
a574 1
}
a575 6
void CServerConnect::DestroySocket(CServerSocket* pSck){
	if (pSck == NULL)
		return;

	CloseSocket(pSck);
	
@


1.35
log
@unicode cleanup
@
text
@d193 1
d528 1
d590 18
@


1.34
log
@Purity's webserver enhancements
@
text
@d86 1
a86 1
	theApp.emuledlg->ShowConnectionState(false,"",true);
d330 1
a330 1
			sUrl.Format("http://%s", g_Urls[rand() % 7]);
d356 1
a356 1
			theApp.emuledlg->ShowConnectionState(false,"",true);
d371 1
a371 1
			theApp.emuledlg->ShowConnectionState(false,"",true);
d402 1
a402 1
	theApp.emuledlg->ShowConnectionState(false,"",true);
d430 1
a430 1
	sUrl.Format("http://%s", g_Urls[rand() % 7]);
d465 1
a465 1
	bool bSuccess = bQ && !strcmp(szBuffer, _T("200"));
d482 1
a482 1
			AddDebugLogLine(false,"Error: Socket invalid at timeoutcheck" );
d502 1
a502 1
		theApp.emuledlg->ShowConnectionState(false,"");
@


1.33
log
@unicode cleanup
@
text
@d133 1
d526 1
d544 8
@


1.32
log
@socket will be not destoyed if server is changed during connecting
@
text
@d446 1
a446 1
bool CServerConnect::IsAliveURL(LPCSTR sURL)
@


1.31
log
@Small bugfix
@
text
@d496 1
a496 1
	if (connected && connectedsocket){
d500 1
@


1.30
log
@Preparing for new sockets
@
text
@d38 2
a39 2
static TCHAR g_Urls[4][50] = {
	/*_T("www.microsoft.com"),
d41 1
a41 1
	_T("www.ibm.com"),*/
a324 10
/*		connected = false;
		if (connectedsocket) 
			connectedsocket->Close();
		connectedsocket = NULL;
		AddLogLine(false, GetResString(IDS_NET_CHECKING));
		theApp.emuledlg->searchwnd.OnBnClickedCancels();
		theApp.emuledlg->ShowConnectionState(false,"",true);
		StopConnectionTry();
		if(m_idCheckTimer)
			KillTimer(NULL, m_idCheckTimer);*/
d329 1
a329 1
			sUrl.Format("http://%s", g_Urls[rand() % 4]);
d333 1
d429 1
a429 1
	sUrl.Format("http://%s", g_Urls[rand() % 4]);
d433 1
@


1.29
log
@converted to new logger methods
@
text
@d48 1
d585 3
a587 1
}@


1.28
log
@code cleanup
@
text
@d61 1
a61 1
				AddLogLine(true,GetResString(IDS_OUTOFSERVERS));
d106 1
a106 1
			AddLogLine(true,GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d116 1
a116 1
		AddLogLine(true,GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d208 1
a208 1
		AddLogLine(false,GetResString(IDS_CONNECTEDTOREQ),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d242 1
a242 1
		AddLogLine(true,GetResString(IDS_CONNECTEDTO),sender->cur_server->GetListName());
d296 1
a296 1
			AddLogLine(true,GetResString(IDS_ERR_FATAL));
d300 1
a300 1
			AddLogLine(true,GetResString(IDS_ERR_LOSTC),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d303 1
a303 1
			AddLogLine(false,GetResString(IDS_ERR_DEAD),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort()); //<<--
d315 1
a315 1
			AddLogLine(false,GetResString(IDS_ERR_FULL),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d336 1
a336 1
			AddLogLine(false, GetResString(IDS_NET_CHECKING));
d341 1
a341 1
				AddLogLine(false,GetResString(IDS_NET_WORKING));
d360 1
a360 1
				AddLogLine(false,GetResString(IDS_RECONNECT), CS_RETRYCONNECTTIME); 
d385 1
a385 1
			AddLogLine(false,GetResString(IDS_ERR_CONFAILED),sender->info, sender->cur_server->GetFullIP(), sender->cur_server->GetPort() );
d432 1
a432 1
	AddLogLine(false, GetResString(IDS_NET_CHECKING));
d440 1
a440 1
		AddLogLine(false,GetResString(IDS_NET_WORKING));
d494 1
a494 1
			AddLogLine(false,GetResString(IDS_ERR_CONTIMEOUT),tmpsock->info, tmpsock->cur_server->GetFullIP(), tmpsock->cur_server->GetPort() );
@


1.27
log
@small optimisations in server list handling
@
text
@d215 2
a216 2
		CMemFile* data = new CMemFile();
		data->Write(theApp.glob_prefs->GetUserHash(),16);
d218 1
a218 1
		data->Write(&clientid,4);
d220 1
a220 1
		data->Write(&port,2);
d222 1
a222 1
		data->Write(&tagcount,4);
d233 1
a233 1
		Packet* packet = new Packet(data);
d236 1
a236 2
		this->SendPacket(packet,true,sender);
		delete data;
@


1.26
log
@code cleanup
@
text
@d213 1
a213 1
			theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer( update );
d308 1
a308 1
				theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer( update );
@


1.25
log
@second part of the con. fix , forgot this :(
@
text
@d71 1
a71 1
                ConnectToServer(next_server,true);
d74 1
a74 1
			ConnectToServer(next_server,true);
d125 1
a125 1
void CServerConnect::ConnectToServer(CServer* server, bool multiconnect){
@


1.24
log
@Fixed internet connection test causing attempts to connect to only few first servers if they are  "dead"
@
text
@d347 2
d350 1
a350 1
			//m_idCheckTimer = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)CheckInternetCallback);
d353 1
a353 1
		//return;
@


1.23
log
@fixed access violation
@
text
@d38 11
d325 1
a325 1
		connected = false;
d334 18
a351 3
			KillTimer(NULL, m_idCheckTimer);
		m_idCheckTimer = SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)CheckInternetCallback);
		return;
a421 9
static TCHAR g_Urls[4][50] = {
	/*_T("www.microsoft.com"),
	_T("www.yahoo.com"),
	_T("www.ibm.com"),*/
	_T("www.army.mil"),
	_T("www.networksolutions.com"),
	_T("www.ripe.net"),
	_T("www.w3.org")
};
a434 3
	if(_this->IsConnecting())
		_this->StopConnectionTry();

d440 2
a441 1
		_this->ConnectToAnyServer(); 
d446 3
@


1.22
log
@code cleanup
@
text
@d268 1
a268 1
		if (connected){
@


1.21
log
@fixed memory leak when lowid happened
@
text
@d152 1
a152 1
		if ((pSck != NULL) && (pSck != connectedsocket) && !pSck->m_bIsDeleting)	
d536 2
a537 8

void CServerConnect::DestroySocket(CServerSocket* pSck){
	if (pSck == NULL)
		return;

	pSck->m_bIsDeleting = true;

	// remove socket from list of opened sockets
d539 2
a540 3
	if (posDel != NULL)
	{
		m_lstOpenSockets.RemoveAt(posDel);
d547 5
d553 2
@


1.20
log
@optimisations (don't scan socket list twice)
@
text
@a311 4
	// IMPORTANT: mark this socket not to be deleted in StopConnectionTry(), 
	// because it will delete itself after this function!
	sender->m_bIsDeleting = true;

d540 3
@


1.19
log
@Small check
@
text
@d124 1
a124 1
	m_lstOpenSockets.AddTail((void*&)newsocket);
d145 2
a146 1
	for( POSITION pos = m_lstOpenSockets.GetHeadPosition(); pos != NULL; )
d148 14
a161 7
		CServerSocket* pSck = (CServerSocket*)m_lstOpenSockets.GetNext(pos);
		if (pSck == connectedsocket)		// don't destroy socket which is connected to server
			continue;
		if (pSck == NULL)
			continue;
		if (pSck->m_bIsDeleting == false)	// don't destroy socket if it is going to destroy itself later on
			DestroySocket(pSck);
d540 1
d545 2
a546 1
	for( POSITION pos = m_lstOpenSockets.GetHeadPosition(); pos != NULL; )
d548 1
a548 7
		POSITION posDel = pos;
		CServerSocket* pTestSck = (CServerSocket*)m_lstOpenSockets.GetNext(pos);
		if (pTestSck == pSck)
		{
			m_lstOpenSockets.RemoveAt(posDel);
			break;
		}
d550 1
d558 1
@


1.18
log
@Upgrade to 0.28a
@
text
@d150 2
@


1.17
log
@Reask sources when reconnected to server after disconnect
@
text
@d245 3
a247 1
		else
d249 1
a455 1
	//AddDebugLogLine(false,"checking timeout: %u",CONSERVTIMEOUT/6000 );
a461 1
		//AddDebugLogLine(false,"tmpkey: %u - maxage: %u",tmpkey ,maxage);
d544 1
a544 2
	// changed to AsyncSocketEx - deadlake / Maverick
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET){
@


1.16
log
@last bugfixes!
@
text
@d235 1
@


1.15
log
@Check if internet connection is down
@
text
@d308 1
a308 1
		AddLogLine(false, "Probably internet connection is down. Checking.");
d386 2
a387 2
static TCHAR g_Urls[7][50] = {
	_T("www.microsoft.com"),
d389 1
a390 1
	_T("www.ibm.com"),
d404 1
a404 1
	AddLogLine(false, "Checking internet connection.");
d412 1
a412 1
	sUrl.Format("http://%s", g_Urls[rand() % 7]);
d415 1
a415 1
		AddLogLine(false, "Internet connection is working. Starting connection...");
a419 1
		AddLogLine(false, "Internet connection is NOT working. Waiting...");
@


1.14
log
@converted to new logging method
@
text
@d28 1
d159 5
d268 1
a268 1
	//messages
d273 1
d285 1
d288 1
d293 2
a294 1
		case CS_NOTCONNECTED:; 
d302 16
d324 1
a324 1
				m_idRetryTimer= SetTimer(NULL, 0, 1000*CS_RETRYCONNECTTIME, (TIMERPROC)RetryConnectCallback);
d386 65
d503 2
@


1.13
log
@bugfix: server connect timeout, averaged file rating
@
text
@d49 1
a49 1
				theApp.emuledlg->AddLogLine(true,GetResString(IDS_OUTOFSERVERS));
d94 1
a94 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d104 1
a104 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_NOVALIDSERVERSFOUND));
d181 1
a181 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_CONNECTEDTOREQ),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d216 1
a216 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_CONNECTEDTO),sender->cur_server->GetListName());
d266 1
a266 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_FATAL));
d269 1
a269 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_LOSTC),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d272 1
a272 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_DEAD),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort()); //<<--
d282 1
a282 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_FULL),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
d297 1
a297 1
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_RECONNECT), CS_RETRYCONNECTTIME); 
d322 1
a322 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_CONFAILED),sender->info, sender->cur_server->GetFullIP(), sender->cur_server->GetPort() );
d362 1
a362 1
	//theApp.emuledlg->AddDebugLogLine(false,"checking timeout: %u",CONSERVTIMEOUT/6000 );
d369 1
a369 1
		//theApp.emuledlg->AddDebugLogLine(false,"tmpkey: %u - maxage: %u",tmpkey ,maxage);
d371 1
a371 1
			theApp.emuledlg->AddDebugLogLine(false,"Error: Socket invalid at timeoutcheck" );
d377 1
a377 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_CONTIMEOUT),tmpsock->info, tmpsock->cur_server->GetFullIP(), tmpsock->cur_server->GetPort() );
@


1.12
log
@Proxy Support (deadlake)
@
text
@d165 16
d362 1
d369 1
@


1.11
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d432 2
a433 1
	if (pSck->m_hSocket != INVALID_SOCKET){
@


1.11.2.1
log
@keeping in sync with the main cvs line
@
text
@d432 1
a432 2
	// changed to AsyncSocketEx - deadlake / Maverick
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET){
@


1.11.4.1
log
@Proxy support fixes from deadlake.
@
text
@d432 1
a432 2
	// changed to AsyncSocketEx - deadlake / Maverick
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET){
@


1.10
log
@overhead parameters change
@
text
@d30 7
d42 1
a42 1
	while ( connectionattemps.GetCount()< ((app_prefs->IsSafeConnectEnabled()) ? 1 : 2)) {
a212 1
		theApp.serverlist->SaveServermetToFile();
@


1.9
log
@restored safe connect functionality
@
text
@d185 1
a185 1
		theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
d203 1
a203 1
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
@


1.8
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d32 4
a35 2
void CServerConnect::TryAnotherConnectionrequest(){
	while ( connectionattemps.GetCount()< 2 ) {
d57 1
d60 3
a62 1
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto){
d103 1
d107 1
a107 1
	
d121 1
d125 1
d145 1
d148 3
a150 1
void CServerConnect::ConnectionEstablished(CServerSocket* sender){
d208 1
d210 1
d379 1
a379 1
	max_simcons =  1;
@


1.7
log
@Merge from official sockets
@
text
@d174 1
d192 1
a198 1
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d366 1
a366 1
	max_simcons =  2;
@


1.7.2.1
log
@initial upgrade to .26
@
text
@a173 1
		theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
a190 1
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
d197 1
d365 1
a365 1
	max_simcons =  1;
@


1.6
log
@bugfixes & control panel updates
@
text
@d32 2
a33 5
void CServerConnect::TryAnotherConnectionrequest()
{
	EMULE_TRY

	while ( connectionattemps.GetCount()<((app_prefs->IsSafeConnectEnabled()) ? 1 : 2) ) {
d53 1
a53 1
		ConnectToServer(next_server,true);
a54 2

	EMULE_CATCH
d57 1
a57 4
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto)
{
	EMULE_TRY

d64 1
a64 1
	
a97 2

	EMULE_CATCH
d100 1
a100 3
void CServerConnect::ConnectToServer(CServer* server, bool multiconnect)
{
	EMULE_TRY
d111 1
a111 2
	//now the socket is created in emsocket::connect
	//newsocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL); // Maverick
a114 2

	EMULE_CATCH
d117 1
a117 4
void CServerConnect::StopConnectionTry()
{
	EMULE_TRY

a136 2

	EMULE_CATCH
d139 1
a139 4
void CServerConnect::ConnectionEstablished(CServerSocket* sender)
{
	EMULE_TRY

d155 21
a175 24
		if(data != NULL)
		{
			data->Write(theApp.glob_prefs->GetUserHash(),16);
			uint32 clientid = GetClientID();
			data->Write(&clientid,4);
			uint16 port = app_prefs->GetListenPort(); // Maverick
			data->Write(&port,2);
			uint32 tagcount = 3;
			data->Write(&tagcount,4);
			CTag* tag = new CTag(CT_NAME,app_prefs->GetUserNick().GetBuffer());
			tag->WriteTagToFile(data);
			delete tag;
			tag = new CTag(CT_VERSION,EDONKEYVERSION);
			tag->WriteTagToFile(data);
			delete tag;
			tag = new CTag(CT_PORT,port);  // Maverick
			tag->WriteTagToFile(data);
			delete tag;

			Packet* packet = new Packet(data);
			packet->opcode = OP_LOGINREQUEST;
			SendPacket(packet,true,sender);
			delete data;
		}
a194 37
	else if (sender->GetConnectionState() == CS_WAITFORPROXYLISTENING)  // Maverick
	{
		//theApp.emuledlg->AddLogLine(false,GetResString(IDS_CONNECTEDTOREQ),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
		ULONG ip;
		UINT port;
		sender->GetPeerName(ip,port);

		// Renew Timout settings
		DWORD tmpkey;
		CServerSocket* tmpsock;
		POSITION pos = connectionattemps.GetStartPosition();
		while (pos){
			connectionattemps.GetNextAssoc(pos,tmpkey,tmpsock);
			if (!tmpsock) {
				if(theApp.glob_prefs->GetBugReport())
					theApp.emuledlg->AddLogLine(false,"Error: Socket invalid at timeoutcheck");
				connectionattemps.RemoveKey(tmpkey);
				return;
			}
			ULONG ip2;
			UINT port2;
			tmpsock->GetPeerName(ip2,port2);

			if (ip2 == ip && port2 == port) {
				connectionattemps.RemoveKey(tmpkey);
				DWORD newage=GetTickCount();
				connectionattemps.SetAt(newage,tmpsock);
			}
		}
		if (!m_ListenRequestSender)
		{
			m_ListenRequestSender = sender;
			theApp.listensocket->OpenProxyListenSocket(ip,port);
		}
	}

	EMULE_CATCH
d196 1
a196 5

bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to)
{
	EMULE_TRY

a208 4

	EMULE_CATCH

	return false;
d211 6
a216 10
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket)
{
	EMULE_TRY

	if (connected){
		udpsocket->SendPacket(packet,host);
	}
	if (delpacket)
		delete packet;

a217 4

	EMULE_CATCH

	return false;
d220 1
a220 4
void CServerConnect::ConnectionFailed(CServerSocket* sender)
{
	EMULE_TRY

a310 2

	EMULE_CATCH
a315 2
	EMULE_TRY

a321 2

	EMULE_CATCH
a325 2
	EMULE_TRY

a344 2

	EMULE_CATCH
d347 1
a347 4
bool CServerConnect::Disconnect()
{
	EMULE_TRY

d357 2
a358 4

	EMULE_CATCH

	return false;
d361 1
a361 4
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs)
{
	EMULE_TRY

d365 1
a365 1
	max_simcons = (app_prefs->IsSafeConnectEnabled()) ? 1 : 2;
a373 3
	m_ListenRequestSender = NULL; // Maverick

	EMULE_CATCH
d376 1
a376 4
CServerConnect::~CServerConnect()
{
	EMULE_TRY

a384 2

	EMULE_CATCH
d387 1
a387 4
CServer* CServerConnect::GetCurrentServer()
{
	EMULE_TRY

a389 3

	EMULE_CATCH

d393 1
a393 4
void CServerConnect::SetClientID(uint32 newid)
{
	EMULE_TRY

a395 2

	EMULE_CATCH
d398 1
a398 4
void CServerConnect::DestroySocket(CServerSocket* pSck)
{
	EMULE_TRY

d412 1
a412 1
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET){ // Maverick
a417 2

	EMULE_CATCH
d420 1
a420 4
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort)
{
	EMULE_TRY

a424 3

	EMULE_CATCH

d426 1
a426 16
}

// Maverick
void CServerConnect::ListenPortEstablishedCallback()
{
	EMULE_TRY

	if (m_ListenRequestSender)
	{
		m_ListenRequestSender->ProxyListenPortEstablished();
		ConnectionEstablished(m_ListenRequestSender);
		m_ListenRequestSender = NULL;
	}

	EMULE_CATCH
}
@


1.5
log
@just for clarity
@
text
@d214 1
a214 1
		if (theApp.glob_prefs->AddServersFromServer())
@


1.5.2.1
log
@official sockets
@
text
@d32 5
a36 2
void CServerConnect::TryAnotherConnectionrequest(){
	while ( connectionattemps.GetCount()< 2 ) {
d56 1
a56 1
			ConnectToServer(next_server,true);
d58 2
d62 4
a65 1
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto){
d72 1
a72 1

d106 2
d110 3
a112 1
void CServerConnect::ConnectToServer(CServer* server, bool multiconnect){
d123 2
a124 1
	newsocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL);
d128 2
d132 4
a135 1
void CServerConnect::StopConnectionTry(){
d155 2
d159 4
a162 1
void CServerConnect::ConnectionEstablished(CServerSocket* sender){
d178 24
a201 21
		data->Write(theApp.glob_prefs->GetUserHash(),16);
		uint32 clientid = GetClientID();
		data->Write(&clientid,4);
		uint16 port = app_prefs->GetPort();
		data->Write(&port,2);
		uint32 tagcount = 3;
		data->Write(&tagcount,4);
		CTag* tag = new CTag(CT_NAME,app_prefs->GetUserNick().GetBuffer());
		tag->WriteTagToFile(data);
		delete tag;
		tag = new CTag(CT_VERSION,EDONKEYVERSION);
		tag->WriteTagToFile(data);
		delete tag;
		tag = new CTag(CT_PORT,app_prefs->GetPort());
		tag->WriteTagToFile(data);
		delete tag;

		Packet* packet = new Packet(data);
		packet->opcode = OP_LOGINREQUEST;
		this->SendPacket(packet,true,sender);
		delete data;
d221 37
d259 5
a263 1
bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to){
d276 4
d282 10
a291 6
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket){
		if (connected){
			udpsocket->SendPacket(packet,host);
		}
		if (delpacket)
			delete packet;
d293 4
d299 4
a302 1
void CServerConnect::ConnectionFailed(CServerSocket* sender){
d393 2
d400 2
d408 2
d414 2
d435 2
d439 4
a442 1
bool CServerConnect::Disconnect(){
d452 4
a455 2
	else
		return false;
d458 4
a461 1
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs){
d465 1
a465 1
	max_simcons =  2;
d474 3
d479 4
a482 1
CServerConnect::~CServerConnect(){
d491 2
d495 4
a498 1
CServer* CServerConnect::GetCurrentServer(){
d501 3
d507 4
a510 1
void CServerConnect::SetClientID(uint32 newid){
d513 2
d517 4
a520 1
void CServerConnect::DestroySocket(CServerSocket* pSck){
d534 1
a534 1
	if (pSck->m_hSocket != INVALID_SOCKET){
d540 2
d544 4
a547 1
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort){
d552 3
d556 16
a571 1
}@


1.5.2.2
log
@Merges from main thread
@
text
@d32 1
a32 4
void CServerConnect::TryAnotherConnectionrequest()
{
	EMULE_TRY

a54 2

	EMULE_CATCH
d57 1
a57 4
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto)
{
	EMULE_TRY

d64 1
a64 1
	
a97 2

	EMULE_CATCH
d100 1
a100 3
void CServerConnect::ConnectToServer(CServer* server, bool multiconnect)
{
	EMULE_TRY
a114 2

	EMULE_CATCH
d117 1
a117 4
void CServerConnect::StopConnectionTry()
{
	EMULE_TRY

a136 2

	EMULE_CATCH
d139 1
a139 4
void CServerConnect::ConnectionEstablished(CServerSocket* sender)
{
	EMULE_TRY

a194 2

	EMULE_CATCH
d196 1
a196 5

bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to)
{
	EMULE_TRY

a208 4

	EMULE_CATCH

	return false;
d211 6
a216 10
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket)
{
	EMULE_TRY

	if (connected){
		udpsocket->SendPacket(packet,host);
	}
	if (delpacket)
		delete packet;

a217 4

	EMULE_CATCH

	return false;
d220 1
a220 4
void CServerConnect::ConnectionFailed(CServerSocket* sender)
{
	EMULE_TRY

a310 2

	EMULE_CATCH
a315 2
	EMULE_TRY

a321 2

	EMULE_CATCH
a325 2
	EMULE_TRY

a344 2

	EMULE_CATCH
d347 1
a347 4
bool CServerConnect::Disconnect()
{
	EMULE_TRY

d357 2
a358 4

	EMULE_CATCH

	return false;
d361 1
a361 4
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs)
{
	EMULE_TRY

a373 2

	EMULE_CATCH
d376 1
a376 4
CServerConnect::~CServerConnect()
{
	EMULE_TRY

a384 2

	EMULE_CATCH
d387 1
a387 4
CServer* CServerConnect::GetCurrentServer()
{
	EMULE_TRY

a389 3

	EMULE_CATCH

d393 1
a393 4
void CServerConnect::SetClientID(uint32 newid)
{
	EMULE_TRY

a395 2

	EMULE_CATCH
d398 1
a398 4
void CServerConnect::DestroySocket(CServerSocket* pSck)
{
	EMULE_TRY

a417 2

	EMULE_CATCH
d420 1
a420 4
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort)
{
	EMULE_TRY

a424 3

	EMULE_CATCH

d426 1
a426 1
}
@


1.5.2.3
log
@Restored obaldin's version. NO MERGE on these files!!!!!!!
@
text
@d32 4
a35 1
void CServerConnect::TryAnotherConnectionrequest(){
d58 2
d62 4
a65 1
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto){
d72 1
a72 1

d106 2
d110 3
a112 1
void CServerConnect::ConnectToServer(CServer* server, bool multiconnect){
d127 2
d131 4
a134 1
void CServerConnect::StopConnectionTry(){
d154 2
d158 4
a161 1
void CServerConnect::ConnectionEstablished(CServerSocket* sender){
d217 2
d220 5
a224 1
bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to){
d237 4
d243 10
a252 6
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket){
		if (connected){
			udpsocket->SendPacket(packet,host);
		}
		if (delpacket)
			delete packet;
d254 4
d260 4
a263 1
void CServerConnect::ConnectionFailed(CServerSocket* sender){
d354 2
d361 2
d369 2
d375 2
d396 2
d400 4
a403 1
bool CServerConnect::Disconnect(){
d413 4
a416 2
	else
		return false;
d419 4
a422 1
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs){
d435 2
d439 4
a442 1
CServerConnect::~CServerConnect(){
d451 2
d455 4
a458 1
CServer* CServerConnect::GetCurrentServer(){
d461 3
d467 4
a470 1
void CServerConnect::SetClientID(uint32 newid){
d473 2
d477 4
a480 1
void CServerConnect::DestroySocket(CServerSocket* pSck){
d500 2
d504 4
a507 1
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort){
d512 3
d516 1
a516 1
}@


1.5.2.4
log
@updated control panes, and assorted bugfixes
@
text
@d188 1
a188 1
		if (theApp.glob_prefs->GetAddServersFromConn())
@


1.5.2.2.2.1
log
@Merged Proxy code
@
text
@d123 1
a123 2
	//now the socket is created in emsocket::connect
	//newsocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL); // Maverick
a216 35
	else if (sender->GetConnectionState() == CS_WAITFORPROXYLISTENING)  // Maverick
	{
		//theApp.emuledlg->AddLogLine(false,GetResString(IDS_CONNECTEDTOREQ),sender->cur_server->GetListName(),sender->cur_server->GetFullIP(),sender->cur_server->GetPort());
		ULONG ip;
		UINT port;
		sender->GetPeerName(ip,port);

		// Renew Timout settings
		DWORD tmpkey;
		CServerSocket* tmpsock;
		POSITION pos = connectionattemps.GetStartPosition();
		while (pos){
			connectionattemps.GetNextAssoc(pos,tmpkey,tmpsock);
			if (!tmpsock) {
				if(theApp.glob_prefs->GetBugReport())
					theApp.emuledlg->AddLogLine(false,"Error: Socket invalid at timeoutcheck");
				connectionattemps.RemoveKey(tmpkey);
				return;
			}
			ULONG ip2;
			UINT port2;
			tmpsock->GetPeerName(ip2,port2);

			if (ip2 == ip && port2 == port) {
				connectionattemps.RemoveKey(tmpkey);
				DWORD newage=GetTickCount();
				connectionattemps.SetAt(newage,tmpsock);
			}
		}
		if (!m_ListenRequestSender)
		{
			m_ListenRequestSender = sender;
			theApp.listensocket->OpenProxyListenSocket(ip,port);
		}
	}
a434 1
	m_ListenRequestSender = NULL; // Maverick
d494 1
a494 1
	if (pSck->m_SocketData.hSocket != INVALID_SOCKET){ // Maverick
a515 15
}

// Maverick
void CServerConnect::ListenPortEstablishedCallback()
{
	EMULE_TRY

	if (m_ListenRequestSender)
	{
		m_ListenRequestSender->ProxyListenPortEstablished();
		ConnectionEstablished(m_ListenRequestSender);
		m_ListenRequestSender = NULL;
	}

	EMULE_CATCH
@


1.4
log
@*** empty log message ***
@
text
@d123 1
@


1.3
log
@port to .25 b codebase...
@
text
@d32 4
a35 1
void CServerConnect::TryAnotherConnectionrequest(){
d58 2
d62 4
a65 1
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort,bool isAuto){
d106 2
d110 3
a112 1
void CServerConnect::ConnectToServer(CServer* server, bool multiconnect){
d127 2
d131 4
a134 1
void CServerConnect::StopConnectionTry(){
d154 2
d158 4
a161 1
void CServerConnect::ConnectionEstablished(CServerSocket* sender){
d177 24
a200 21
		data->Write(theApp.glob_prefs->GetUserHash(),16);
		uint32 clientid = GetClientID();
		data->Write(&clientid,4);
		uint16 port = app_prefs->GetListenPort(); // Maverick
		data->Write(&port,2);
		uint32 tagcount = 3;
		data->Write(&tagcount,4);
		CTag* tag = new CTag(CT_NAME,app_prefs->GetUserNick().GetBuffer());
		tag->WriteTagToFile(data);
		delete tag;
		tag = new CTag(CT_VERSION,EDONKEYVERSION);
		tag->WriteTagToFile(data);
		delete tag;
		tag = new CTag(CT_PORT,port);  // Maverick
		tag->WriteTagToFile(data);
		delete tag;

		Packet* packet = new Packet(data);
		packet->opcode = OP_LOGINREQUEST;
		SendPacket(packet,true,sender);
		delete data;
d255 2
d258 5
a262 1
bool CServerConnect::SendPacket(Packet* packet,bool delpacket, CServerSocket* to){
d275 4
d281 10
a290 6
bool CServerConnect::SendUDPPacket(Packet* packet,CServer* host,bool delpacket){
		if (connected){
			udpsocket->SendPacket(packet,host);
		}
		if (delpacket)
			delete packet;
d292 4
d298 4
a301 1
void CServerConnect::ConnectionFailed(CServerSocket* sender){
d392 2
d399 2
d407 2
d413 2
d434 2
d438 4
a441 1
bool CServerConnect::Disconnect(){
d451 4
a454 2
	else
		return false;
d457 4
a460 1
CServerConnect::CServerConnect(CServerList* in_serverlist, CPreferences* in_prefs){
d474 2
d478 4
a481 1
CServerConnect::~CServerConnect(){
d490 2
d494 4
a497 1
CServer* CServerConnect::GetCurrentServer(){
d500 3
d506 4
a509 1
void CServerConnect::SetClientID(uint32 newid){
d512 2
d516 4
a519 1
void CServerConnect::DestroySocket(CServerSocket* pSck){
d539 2
d543 4
a546 1
bool CServerConnect::IsLocalServer(uint32 dwIP, uint16 nPort){
d551 3
d560 2
d568 2
@


1.2
log
@*** empty log message ***
@
text
@d46 7
d57 1
a57 1
void CServerConnect::ConnectToAnyServer(uint32 startAt,bool prioSort){
d65 22
d232 1
d368 1
a368 1
			theApp.emuledlg->AddLogLine(false,"Error: Socket invalid at timeoutcheck" );
@


1.1
log
@*** empty log message ***
@
text
@d82 1
a82 1
	newsocket->Create(0,SOCK_STREAM,FD_READ|FD_WRITE|FD_CLOSE|FD_CONNECT,NULL);
d129 1
a129 1
		uint16 port = app_prefs->GetPort();
d139 1
a139 1
		tag = new CTag(CT_PORT,app_prefs->GetPort());
d166 35
d379 1
d418 1
a418 1
	if (pSck->m_hSocket != INVALID_SOCKET){
d432 12
a443 1
}@

