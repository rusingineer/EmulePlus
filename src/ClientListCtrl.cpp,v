head	1.141;
access;
symbols
	PublicRelease_1_2e:1.139
	Interim_Release_1-2e_RC1:1.139
	PublicRelease_1_2d:1.132
	Interim_Release_1-2d_RC1:1.132
	Interim_Release_1-2d_beta1:1.126
	PublicRelease_1_2c:1.123
	Interim_Release_1-2c_RC1:1.123
	Interim_Release_1-2c_beta1:1.122
	PublicRelease_1_2b:1.120
	Interim_Release_1-2b_RC1:1.119
	PublicRelease_1_2a:1.117
	Interim_Release_1-2a_RC1:1.117
	Interim_Release_1-2a_beta2:1.117
	Interim_Release_1-2a_beta1:1.116
	PublicRelease_1_2:1.115
	Interim_Release_1-2_RC1:1.114
	Interim_Release_1-2_beta1:1.114
	PublicRelease_1_1g:1.113
	Interim_Release_1-1g_RC3:1.113
	Interim_Release_1-1g_RC2:1.113
	Interim_Release_1-1g_RC1:1.113
	Interim_Release_1-1g_beta2:1.111
	Interim_Release_1-1g_beta1:1.107
	PublicRelease_1_1f:1.104
	Interim_Release_1-1f_RC1:1.104
	PublicRelease_1_1e:1.104
	Interim_Release_1-1e_RC2:1.104
	Interim_Release_1-1e_RC1:1.104
	Interim_Release_1-1e_beta1:1.101
	PublicRelease_1_1d:1.99
	Interim_Release_1-1d_RC1:1.99
	PublicRelease_1_1c:1.99
	Interim_Release_1-1c_RC1:1.99
	Interim_Release_1-1c_beta2:1.99
	Interim_Release_1-1c_beta1:1.99
	PublicRelease_1_1b:1.96
	Interim_Release_1-1b_RC1:1.96
	PublicRelease_1_1a:1.96
	Interim_Release_1-1a_RC2:1.96
	Interim_Release_1-1a_RC1:1.96
	Interim_Release_1-1a_beta2:1.96
	Interim_Release_1-1a_beta1:1.96
	PublicRelease_1_1:1.94
	Interim_Release_1-1_beta1:1.94
	PublicRelease_1o:1.94
	Interim_Release_1o_RC1:1.94
	Interim_Release_1o_beta1:1.93
	PublicRelease_1n:1.93
	Interim_Release_1n_RC2:1.93
	Interim_Release_1n_RC1:1.93
	Interim_Release_1n_beta2:1.91
	Interim_Release_1n_beta1:1.86
	PublicRelease_1m:1.84
	Interim_Release_1m_beta1:1.83
	PublicRelease_1l:1.82
	Interim_Release_1l_RC3:1.82
	Interim_Release_1l_RC2:1.80
	Interim_Release_1l_RC1:1.79
	Interim_Release_1l_beta2:1.79
	Interim_Release_1l_beta1:1.75
	PublicRelease_1k:1.59
	Interim_Release_1k_RC4:1.59
	Interim_1k_RC3:1.59
	Interim_1k_RC2:1.59
	Interim_Release_1k_RC1:1.59
	Interim_Release_1k_beta5:1.58
	Intrerim_Release_1k_beta4:1.58
	Interim_Release_1k_beta1:1.52
	PublicRelease_1j:1.47
	Interim_Release_1J_RC3:1.47
	Interim_Release_1j_RC3:1.47
	Interim_Release_1j_RC2:1.39
	Interim_Release_1j_RC1:1.39
	Interim_Release_1j_beta2:1.39
	Interim_Release_1j_beta1:1.38
	PublicRelease_1i:1.34
	Interim_Release_1i_RC6:1.34
	Interim_Release_1i_RC3:1.29
	Interim_Release_1i_RC2:1.29
	Interim_Release_1i_RC1:1.26
	Interim_Release_1i_beta3:1.25
	Interim_Release_1i_beta2:1.22
	Interim_Release_1i_beta1:1.12;
locks; strict;
comment	@// @;


1.141
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.140;

1.140
date	2009.05.14.03.10.30;	author aw3;	state Exp;
branches;
next	1.139;

1.139
date	2008.11.07.05.30.24;	author aw3;	state Exp;
branches;
next	1.138;

1.138
date	2008.11.03.05.57.15;	author aw3;	state Exp;
branches;
next	1.137;

1.137
date	2008.10.29.03.37.16;	author aw3;	state Exp;
branches;
next	1.136;

1.136
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.135;

1.135
date	2008.09.02.02.49.55;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2008.08.13.13.11.46;	author kush_eplus;	state Exp;
branches;
next	1.133;

1.133
date	2008.07.26.03.32.22;	author aw3;	state Exp;
branches;
next	1.132;

1.132
date	2008.04.16.19.44.17;	author eklmn;	state Exp;
branches;
next	1.131;

1.131
date	2008.04.10.01.41.30;	author aw3;	state Exp;
branches;
next	1.130;

1.130
date	2008.04.06.11.34.43;	author eklmn;	state Exp;
branches;
next	1.129;

1.129
date	2008.04.05.20.22.49;	author eklmn;	state Exp;
branches;
next	1.128;

1.128
date	2008.04.05.09.49.08;	author eklmn;	state Exp;
branches;
next	1.127;

1.127
date	2008.03.10.04.09.38;	author aw3;	state Exp;
branches;
next	1.126;

1.126
date	2007.12.29.05.48.24;	author aw3;	state Exp;
branches;
next	1.125;

1.125
date	2007.12.01.11.17.49;	author eklmn;	state Exp;
branches;
next	1.124;

1.124
date	2007.10.24.19.09.34;	author fuxie-dk;	state Exp;
branches;
next	1.123;

1.123
date	2007.07.08.00.11.57;	author aw3;	state Exp;
branches;
next	1.122;

1.122
date	2007.02.20.04.57.35;	author aw3;	state Exp;
branches;
next	1.121;

1.121
date	2007.02.19.03.41.21;	author aw3;	state Exp;
branches;
next	1.120;

1.120
date	2007.01.27.05.33.59;	author aw3;	state Exp;
branches;
next	1.119;

1.119
date	2006.11.17.05.26.11;	author aw3;	state Exp;
branches;
next	1.118;

1.118
date	2006.11.16.11.57.00;	author eklmn;	state Exp;
branches;
next	1.117;

1.117
date	2006.05.13.04.40.28;	author aw3;	state Exp;
branches;
next	1.116;

1.116
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.115;

1.115
date	2006.02.26.22.42.16;	author aw3;	state Exp;
branches;
next	1.114;

1.114
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.113;

1.113
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.112;

1.112
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.111;

1.111
date	2005.11.25.05.11.43;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2005.09.19.11.17.43;	author aw3;	state Exp;
branches;
next	1.108;

1.108
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.107;

1.107
date	2005.08.17.18.49.43;	author eklmn;	state Exp;
branches;
next	1.106;

1.106
date	2005.08.14.22.15.40;	author aw3;	state Exp;
branches;
next	1.105;

1.105
date	2005.08.10.05.20.40;	author eklmn;	state Exp;
branches;
next	1.104;

1.104
date	2005.06.20.04.06.19;	author aw3;	state Exp;
branches;
next	1.103;

1.103
date	2005.06.19.05.09.32;	author aw3;	state Exp;
branches;
next	1.102;

1.102
date	2005.06.11.14.38.36;	author aw3;	state Exp;
branches;
next	1.101;

1.101
date	2005.05.21.20.13.53;	author aw3;	state Exp;
branches;
next	1.100;

1.100
date	2005.05.10.04.01.32;	author aw3;	state Exp;
branches;
next	1.99;

1.99
date	2005.01.23.13.52.56;	author aw3;	state Exp;
branches;
next	1.98;

1.98
date	2005.01.19.21.10.44;	author netwolf1;	state Exp;
branches;
next	1.97;

1.97
date	2005.01.14.14.47.22;	author kush_eplus;	state Exp;
branches;
next	1.96;

1.96
date	2004.11.06.04.47.39;	author aw3;	state Exp;
branches;
next	1.95;

1.95
date	2004.10.28.15.24.22;	author aw3;	state Exp;
branches;
next	1.94;

1.94
date	2004.09.25.07.32.25;	author aw3;	state Exp;
branches;
next	1.93;

1.93
date	2004.08.28.04.51.48;	author aw3;	state Exp;
branches;
next	1.92;

1.92
date	2004.08.11.03.06.58;	author aw3;	state Exp;
branches;
next	1.91;

1.91
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.90;

1.90
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.89;

1.89
date	2004.08.04.04.17.05;	author aw3;	state Exp;
branches;
next	1.88;

1.88
date	2004.07.24.06.57.22;	author aw3;	state Exp;
branches;
next	1.87;

1.87
date	2004.07.22.23.44.33;	author aw3;	state Exp;
branches;
next	1.86;

1.86
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.85;

1.85
date	2004.06.30.13.38.40;	author dongato;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.22.17.32.56;	author aw3;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.20.01.02.55;	author aw3;	state Exp;
branches;
next	1.82;

1.82
date	2004.06.06.04.59.22;	author aw3;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.03.05.20.52;	author aw3;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.01.22.30.45;	author aw3;	state Exp;
branches;
next	1.79;

1.79
date	2004.05.21.18.37.18;	author dongato;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.21.14.37.56;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2004.05.11.02.41.13;	author aw3;	state Exp;
branches;
next	1.76;

1.76
date	2004.05.07.04.56.18;	author aw3;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.06.01.39.08;	author katsyonak;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.05.17.17.42;	author netwolf1;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.05.15.38.39;	author netwolf1;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.04.06.09.32;	author aw3;	state Exp;
branches;
next	1.71;

1.71
date	2004.04.28.19.47.17;	author aw3;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.26.14.23.38;	author katsyonak;	state Exp;
branches;
next	1.69;

1.69
date	2004.04.26.14.08.33;	author katsyonak;	state Exp;
branches;
next	1.68;

1.68
date	2004.04.26.07.45.00;	author katsyonak;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.26.06.14.45;	author katsyonak;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.25.20.00.24;	author katsyonak;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.25.13.04.10;	author katsyonak;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.25.12.11.39;	author katsyonak;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.25.11.58.00;	author katsyonak;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.25.08.33.00;	author dongato;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.25.06.03.18;	author katsyonak;	state Exp;
branches;
next	1.60;

1.60
date	2004.04.23.22.13.42;	author katsyonak;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.25.14.29.19;	author dongato;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.06.19.50.59;	author eklmn;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.03.15.18.58;	author aw3;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.27.01.25.09;	author kush_eplus;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.25.17.58.54;	author kush_eplus;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.25.04.46.32;	author aw3;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.24.03.44.41;	author aw3;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.16.23.29.53;	author aw3;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.12.10.37.49;	author morevit;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.31.13.08.02;	author syrus77;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.47;

1.47
date	2004.01.23.05.20.18;	author kush_eplus;	state Exp;
branches;
next	1.46;

1.46
date	2004.01.21.23.20.45;	author dongato;	state Exp;
branches;
next	1.45;

1.45
date	2004.01.19.21.21.54;	author eklmn;	state Exp;
branches;
next	1.44;

1.44
date	2004.01.19.18.21.28;	author dropf;	state Exp;
branches;
next	1.43;

1.43
date	2004.01.16.22.03.10;	author eklmn;	state Exp;
branches;
next	1.42;

1.42
date	2004.01.16.12.25.53;	author dongato;	state Exp;
branches;
next	1.41;

1.41
date	2004.01.15.23.27.53;	author dongato;	state Exp;
branches;
next	1.40;

1.40
date	2004.01.14.23.13.26;	author eklmn;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.31.14.01.53;	author dongato;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.24.01.21.13;	author katsyonak;	state Exp;
branches;
next	1.37;

1.37
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.36;

1.36
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.14.08.02.00;	author dongato;	state Exp;
branches;
next	1.34;

1.34
date	2003.11.30.17.52.44;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.27.13.57.18;	author eklmn;	state Exp;
branches;
next	1.32;

1.32
date	2003.11.23.13.33.37;	author katsyonak;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.20.20.07.24;	author katsyonak;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.20.09.56.46;	author katsyonak;	state Exp;
branches;
next	1.29;

1.29
date	2003.11.11.21.36.56;	author dropf;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.09.16.02.51;	author eklmn;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.05.01.07.20;	author katsyonak;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.04.19.02.58;	author eklmn;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.30.02.44.37;	author morevit;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.29.22.13.31;	author dropf;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.28.21.28.33;	author morevit;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.20.13.19.57;	author morevit;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.19.16.01.42;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.17.10.29.05;	author morevit;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.13.15.03.37;	author morevit;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.10.04.12.21;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.08.15.39.47;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.05.06.22.51;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.04.10.03.15;	author morevit;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.04.00.48.37;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.03.23.18.49;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.03.13.04.36;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.02.00.58.14;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.28.15.40.36;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.28.14.58.08;	author dongato;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.27.07.52.17;	author dongato;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.25.01.09.10;	author dongato;	state Exp;
branches;
next	1.1;

1.1
date	2003.09.24.21.06.11;	author dongato;	state Exp;
branches;
next	;


desc
@@


1.141
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "updownclient.h"
#include "ClientListCtrl.h"
#include "TitleMenu.h"
#include "otherfunctions.h"
#include "opcodes.h"
#include "Details\clientdetails.h"
#include "ListenSocket.h"
#include "IP2Country.h"
#include "MemDC.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CClientListCtrl, CMuleListCtrl)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnClick)
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMDblclk)
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
	ON_WM_KEYUP()
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CClientListCtrl, CMuleListCtrl)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CClientListCtrl::CClientListCtrl()
{
	SetGeneralPurposeFind(true);

	m_pvecDirtyClients = new ClientVector();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CClientListCtrl::~CClientListCtrl()
{
	safe_delete(m_pvecDirtyClients);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::Init()
{
	static const uint16 s_auColHdr[][2] =
	{
		{ LVCFMT_LEFT, 150 },	// CLCOL_USERNAME
		{ LVCFMT_LEFT, 100 },	// CLCOL_UPLOADSTATUS
		{ LVCFMT_LEFT, 100 },	// CLCOL_TRANSFERREDUP
		{ LVCFMT_LEFT, 100 },	// CLCOL_DOWNLOADSTATUS
		{ LVCFMT_LEFT, 100 },	// CLCOL_TRANSFERREDDOWN
		{ LVCFMT_LEFT, 120 },	// CLCOL_CLIENTSOFTWARE
		{ LVCFMT_LEFT,  80 },	// CLCOL_CONNECTEDTIME
		{ LVCFMT_LEFT, 210 },	// CLCOL_USERHASH
		{ LVCFMT_LEFT, 150 }	// CLCOL_COUNTRY
	};
	CImageList		ilDummyImageList;

	ilDummyImageList.Create(1, 17, g_App.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
	SetImageList(&ilDummyImageList, LVSIL_SMALL);
	ilDummyImageList.Detach();

	memzero(m_iColumnMaxWidths, sizeof(m_iColumnMaxWidths));
//	Index of the column being measured. -1 for none.
	m_iMeasuringColumn = -1;

	SetExtendedStyle(LVS_EX_FULLROWSELECT);
	for (unsigned ui = 0; ui < ARRSIZE(s_auColHdr); ui++)
		InsertColumn(ui, _T(""), static_cast<int>(s_auColHdr[ui][0]), static_cast<int>(s_auColHdr[ui][1]), ui);

	Localize();

	LoadSettings(CPreferences::TABLE_CLIENTLIST);
	SetSortProcedure(SortProc);
	if (g_App.m_pPrefs->DoUseSort())
		SortInit(g_App.m_pPrefs->GetClientListSortCol());
	else
		SortInit(g_App.m_pPrefs->GetColumnSortCode(CPreferences::TABLE_CLIENTLIST));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::Localize()
{
	static const uint16 s_auResTbl[] =
	{
		IDS_QL_USERNAME,				// CLCOL_USERNAME
		IDS_CL_UPLOADSTATUS,			// CLCOL_UPLOADSTATUS
		IDS_CL_TRANSFUP,				// CLCOL_TRANSFERREDUP
		IDS_CL_DOWNLSTATUS,				// CLCOL_DOWNLOADSTATUS
		IDS_CL_TRANSFDOWN,				// CLCOL_TRANSFERREDDOWN
		IDS_INFLST_USER_CLIENTSOFTWARE,	// CLCOL_CLIENTSOFTWARE
		IDS_CONNECTED,					// CLCOL_CONNECTEDTIME
		IDS_INFLST_USER_USERHASH,		// CLCOL_USERHASH
		IDS_COUNTRY						// CLCOL_COUNTRY
	};

	CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
	CString		strRes;
	HDITEM		hdi;

	hdi.mask = HDI_TEXT;

	for (unsigned ui = 0; ui < ARRSIZE(s_auResTbl); ui++)
	{
		::GetResString(&strRes, static_cast<UINT>(s_auResTbl[ui]));
		hdi.pszText = const_cast<LPTSTR>(strRes.GetString());
		pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::ShowKnownClients()
{
	DeleteAllItems();

	int			i = 0;
	CUpDownClient		*pClient;

	SetRedraw(FALSE);
	for (POSITION pos = g_App.m_pClientList->m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = g_App.m_pClientList->m_clientList.GetNext(pos);

		InsertItem(LVIF_TEXT|LVIF_PARAM,i,LPSTR_TEXTCALLBACK,0,0,0,reinterpret_cast<LPARAM>(pClient));
		i++;
	}
	SetRedraw(TRUE);
	g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::AddClient(CUpDownClient *pClient)
{
	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;

	if ((FindItem(&find) < 0) && (pClient != NULL))
	{
		InsertItem(LVIF_TEXT|LVIF_PARAM, GetItemCount(), LPSTR_TEXTCALLBACK, 0, 0, 1, reinterpret_cast<LPARAM>(pClient));
		g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::RemoveClient(CUpDownClient* pClient)
{
	if (!g_App.m_pMDlg->IsRunning() || (pClient == NULL))
		return;

	if (g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE)
	{
		if (g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetClient() == pClient)
			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
	}
	sint32		iResult;
	LVFINDINFO	find;

	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;
	
	if ((iResult = FindItem(&find)) >= 0)
	{
		DeleteItem(iResult);
		g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::UpdateClient(CUpDownClient* pClient)
{
	if (pClient != NULL)
	{
		if (AddDirtyClient(pClient))
			PostUniqueMessage(WM_CL_REFRESH);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DLC_DT_TEXT (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
#define LIST_CELL_PADDING	6		//should be even number
	EMULE_TRY

	if (!g_App.m_pMDlg->IsRunning() || !lpDrawItemStruct->itemData)
		return;

	CDC			   *odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	BOOL			bCtrlFocused = ((GetFocus() == this) || (GetStyle() & LVS_SHOWSELALWAYS));
	COLORREF		crBk, crWinBk;

	crWinBk = crBk = GetBkColor();
	if (lpDrawItemStruct->itemState & ODS_SELECTED)
		crBk = (bCtrlFocused) ? m_crHighlight : m_crNoHighlight;

	CUpDownClient	   *pClient = (CUpDownClient*)lpDrawItemStruct->itemData;
	CMemDC				dc(odc, &lpDrawItemStruct->rcItem, crWinBk, crBk);
	CFont			   *pOldFont = dc.SelectObject(GetFont());
	COLORREF			crOldTextColor = dc.SetTextColor(m_crWindowText);
	int					iWidth, iColumn;
	bool				bMeasuring = (m_iMeasuringColumn >= 0);
	UINT				iCalcFlag = bMeasuring ? (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_CALCRECT) : (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
	UINT				dwResStrId;

	if (IsRightToLeftLanguage())
		iCalcFlag |= DT_RTLREADING;

	RECT			r = lpDrawItemStruct->rcItem;
	CString			strBuffer;
	CHeaderCtrl	   *pHeaderCtrl = GetHeaderCtrl();
	int				iNumColumns = pHeaderCtrl->GetItemCount();

	r.right = r.left - LIST_CELL_PADDING / 2;
	r.left += LIST_CELL_PADDING / 2;
	iWidth = LIST_CELL_PADDING;

	for (int iCurrent = 0; iCurrent < iNumColumns; iCurrent++)
	{
		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
		if (IsColumnHidden(iColumn) || (bMeasuring && iColumn != m_iMeasuringColumn))
			continue;

		r.right += CListCtrl::GetColumnWidth(iColumn);
		switch (iColumn)
		{
			case CLCOL_USERNAME:
			{
				if (!bMeasuring)
				{
					POINT			point = {r.left, r.top + 1};
					int				iImgLstIdx = CLIENT_IMGLST_PLAIN;

				//	Select corresponding image list depending on client properties
					if (pClient->IsBanned())
						iImgLstIdx = CLIENT_IMGLST_BANNED;
					else if (pClient->IsFriend())
						iImgLstIdx = CLIENT_IMGLST_FRIEND;
					else if (pClient->m_pCredits->HasHigherScoreRatio(pClient->GetIP()))
						iImgLstIdx = CLIENT_IMGLST_CREDITUP;

				//	Display Client icon
					g_App.m_pMDlg->m_clientImgLists[iImgLstIdx].Draw(dc, pClient->GetClientIconIndex(), point, ILD_NORMAL);

					r.left += 20;
					if (g_App.m_pIP2Country->ShowCountryFlag())
					{
						point.x += 20;
						point.y += 2;
						g_App.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryIndex(), point, ILD_NORMAL);
						r.left += 22;
					}
				}
				else
				{
					iWidth += 20;
					if (g_App.m_pIP2Country->ShowCountryFlag())
						iWidth += 22;
				}

				try
				{
					strBuffer = pClient->GetUserName();
				}
				catch(...)
				{	//	can crash here if name string object is wrong, probably because
				}	//	client was just deleted or user name object is currently updating
				if (strBuffer.IsEmpty())
					strBuffer.Format(_T("[%s]"), GetResString(IDS_UNKNOWN));
				break;
			}
			case CLCOL_UPLOADSTATUS:
			{
				switch (pClient->GetUploadState())
				{
					case US_ONUPLOADQUEUE:
						dwResStrId = IDS_ONQUEUE;
						break;
					case US_BANNED:
						dwResStrId = IDS_BANNED;
						break;
					case US_CONNECTING:
						dwResStrId = IDS_CONNECTING;
						break;
					case US_UPLOADING:
						dwResStrId = IDS_TRANSFERRING;
						break;
					default:
						strBuffer.Truncate(0);
						dwResStrId = 0;
				}
				if (dwResStrId != 0)
					GetResString(&strBuffer, dwResStrId);
				break;
			}
			case CLCOL_TRANSFERREDUP:
				if (pClient->m_pCredits)
					strBuffer = CastItoXBytes(pClient->m_pCredits->GetUploadedTotal());
				else
					strBuffer = _T("");
				break;

			case CLCOL_DOWNLOADSTATUS:
			{
				switch (pClient->GetDownloadState())
				{
					case DS_CONNECTING:
						dwResStrId = IDS_CONNECTING;
						break;
					case DS_CONNECTED:
						dwResStrId = IDS_ASKING;
						break;
					case DS_WAITCALLBACK:
						dwResStrId = IDS_CONNVIASERVER;
						break;
					case DS_ONQUEUE:
						dwResStrId = pClient->IsRemoteQueueFull()  ? IDS_QUEUEFULL : IDS_ONQUEUE;
						break;
					case DS_DOWNLOADING:
						dwResStrId = IDS_TRANSFERRING;
						break;
					case DS_REQHASHSET:
						dwResStrId = IDS_RECHASHSET;
						break;
					case DS_NONEEDEDPARTS:
						dwResStrId = IDS_NONEEDEDPARTS;
						break;
					case DS_LOWTOLOWID:
						dwResStrId = IDS_NOCONNECTLOW2LOW;
						break;
					case DS_LOWID_ON_OTHER_SERVER:
						dwResStrId = IDS_ANOTHER_SERVER_LOWID;
						break;
					case DS_WAIT_FOR_FILE_REQUEST:
						dwResStrId = IDS_WAITFILEREQ;
						break;
					default:
						strBuffer.Truncate(0);
						dwResStrId = 0;
				}
				if (dwResStrId != 0)
					GetResString(&strBuffer, dwResStrId);
				break;
			}
			case CLCOL_TRANSFERREDDOWN:
				if(pClient->m_pCredits)
					strBuffer = CastItoXBytes(pClient->m_pCredits->GetDownloadedTotal());
				else
					strBuffer = _T("");
				break;

			case CLCOL_CLIENTSOFTWARE:
				strBuffer = pClient->GetFullSoftVersionString();
				break;

			case CLCOL_CONNECTEDTIME:
#ifdef OLD_SOCKETS_ENABLED
				strBuffer = YesNoStr(pClient->m_pRequestSocket != NULL && pClient->m_pRequestSocket->IsConnected());
#endif //OLD_SOCKETS_ENABLED
				break;

			case CLCOL_USERHASH:
				strBuffer = HashToString(pClient->GetUserHash());
				break;

			case CLCOL_COUNTRY:
				strBuffer = pClient->GetCountryName();
				break;
		}
		{
			dc->DrawText(strBuffer, &r, iCalcFlag);
			if (bMeasuring && !strBuffer.IsEmpty())
				iWidth += r.right - r.left + 1;
		}
		r.left = r.right + LIST_CELL_PADDING;

		if (bMeasuring)
		{
		//	Pin the column widths at some reasonable value.
			if (iWidth < 40)
				iWidth = 40;
			if (iWidth > m_iColumnMaxWidths[m_iMeasuringColumn])
				m_iColumnMaxWidths[m_iMeasuringColumn] = iWidth;
		}
	}
//	Draw rectangle around selected item(s)
	if (!bMeasuring && (lpDrawItemStruct->itemState & ODS_SELECTED))
	{
		RECT	rOutline = lpDrawItemStruct->rcItem;
		CBrush	FrmBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine);

		rOutline.left++;
		rOutline.right--;
		dc->FrameRect(&rOutline, &FrmBrush);
	}

	if (pOldFont)
		dc.SelectObject(pOldFont);
	if (crOldTextColor)
		dc.SetTextColor(crOldTextColor);

	EMULE_CATCH
#undef LIST_CELL_PADDING
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CClientListCtrl::OnWndMsg(UINT iMessage,WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
	BOOL		bHandled = TRUE;

	EMULE_TRY

	switch (iMessage)
	{
		case WM_CL_REFRESH:
		{
			CClientListCtrl::ClientVector	   *pvecDirtyClients = GetDirtyClients();

			if (pvecDirtyClients != NULL)
			{
				SetRedraw(FALSE);

				int		iNumDirtySources = pvecDirtyClients->size();

				for (int i = 0; i < iNumDirtySources; i++)
				{
					LVFINDINFO		find;
					int			iResult;

					find.flags = LVFI_PARAM;
					find.lParam = (LPARAM)(*pvecDirtyClients)[i];

					iResult = FindItem(&find);
					if (iResult != -1)
						Update(iResult);
				}

				delete pvecDirtyClients;

				SetRedraw(TRUE);
			}
			break;
		}
		default:
		{
			bHandled = FALSE;
			break;
		}
	}

	EMULE_CATCH

	if (!bHandled)
		bHandled = CMuleListCtrl::OnWndMsg(iMessage, wParam, lParam, pResult);

	return bHandled;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader)
{
	EMULE_TRY

	int		iColumn = pHeader->iItem;

	m_iColumnMaxWidths[iColumn] = 0;
	m_iMeasuringColumn = iColumn;
	Invalidate();
	UpdateWindow();
	m_iMeasuringColumn = -1;
	if (m_iColumnMaxWidths[iColumn] > 0)
		SetColumnWidth(iColumn, m_iColumnMaxWidths[iColumn]);
	else
		CMuleListCtrl::OnNMDividerDoubleClick(pHeader);
	Invalidate();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	NOPRM(pWnd);
	EMULE_TRY

	CTitleMenu		menuClient;
	POSITION		posSelClient = GetFirstSelectedItemPosition();
	UINT			dwMenuFlags = MF_STRING | MF_GRAYED;
	CUpDownClient	*pClient = NULL;

	if (posSelClient)
	{
		dwMenuFlags = MF_STRING;
		pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

		if (pClient)
		{
			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,pClient);
		}
	}

	menuClient.CreatePopupMenu();
	menuClient.AddMenuTitle(GetResString(IDS_CLIENTLIST));
	menuClient.AppendMenu(dwMenuFlags, MP_DETAIL, GetStringFromShortcutCode(IDS_SHOWDETAILS, SCUT_SRC_DETAILS, SSP_TAB_PREFIX));

	UINT_PTR	dwRes = MP_ADDFRIEND;
	UINT		dwResStrId = IDS_ADDFRIEND;

	if (pClient && pClient->IsFriend())
	{
		dwRes = MP_REMOVEFRIEND;
		dwResStrId = IDS_REMOVEFRIEND;
	}
	menuClient.AppendMenu(dwMenuFlags, dwRes, GetStringFromShortcutCode(dwResStrId, SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwMenuFlags, MP_MESSAGE, GetStringFromShortcutCode(IDS_SEND_MSG, SCUT_SRC_MSG, SSP_TAB_PREFIX));
	menuClient.AppendMenu( dwMenuFlags | ((pClient && pClient->GetViewSharedFilesSupport()) ? MF_ENABLED : MF_GRAYED),
		MP_SHOWLIST, GetStringFromShortcutCode(IDS_VIEWFILES, SCUT_SRC_SHAREDFILES, SSP_TAB_PREFIX) );
	menuClient.AppendMenu(dwMenuFlags | ((pClient && pClient->IsBanned()) ? MF_ENABLED : MF_GRAYED), MP_UNBAN, GetResString(IDS_UNBAN) );

	menuClient.SetDefaultItem((g_App.m_pPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
	menuClient.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);

//	Menu objects are destroyed in their destructor

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CClientListCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	POSITION posSelClient = GetFirstSelectedItemPosition();
	NOPRM(lParam);

	if (posSelClient)
	{
		CUpDownClient* 	pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

		switch (wParam)
		{
			case MP_SHOWLIST:
				pClient->RequestSharedFileList();
				break;

			case MP_MESSAGE:
				g_App.m_pMDlg->m_wndChat.StartSession(pClient);
				break;

			case MP_ADDFRIEND:
				g_App.m_pFriendList->AddFriend(pClient);
				UpdateClient(pClient);
				break;

			case MP_REMOVEFRIEND:
				g_App.m_pFriendList->RemoveFriend(pClient);
				UpdateClient(pClient);
				break;

			case MP_UNBAN:
				if (pClient->IsBanned())
				{
					pClient->UnBan();
					UpdateClient(pClient);
				}
				break;

			case MP_DETAIL:
			{
				CClientDetails		dialog(IDS_CD_TITLE, pClient, this, 0);
				dialog.DoModal();
				break;
			}
		}
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CClientListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CUpDownClient*	pClient1 = reinterpret_cast<CUpDownClient*>(lParam1);
	CUpDownClient*	pClient2 = reinterpret_cast<CUpDownClient*>(lParam2);

	if (pClient1 == NULL || pClient2 == NULL)
		return 0;

	int	iCompare = 0;
	int	iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 1 : -1;
	int	iSortColumn = (lParamSort & MLC_COLUMNMASK);

	switch (iSortColumn)
	{
		case CLCOL_USERNAME:
		{
			iCompare = pClient1->CmpUserNames(pClient2->GetUserName());
			break;
		}
		case CLCOL_COUNTRY:
		{
			CString strCountry1 = pClient1->GetCountryName();
			CString strCountry2 = pClient2->GetCountryName();

			if (!strCountry1.IsEmpty() && !strCountry2.IsEmpty())
			{
				iCompare = _tcsicmp(strCountry1, strCountry2);
			}
			else
			{
				iCompare = strCountry1.IsEmpty() ? (strCountry2.IsEmpty() ? 0 : 1) : -1;
			//	Empty entries at the bottom in any case
				iSortMod = 1;
			}

			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1, lParam2, CLCOL_USERNAME);
			//	Sort always in ascending order
				iSortMod = 1;
			}
			break;
		}
		case CLCOL_UPLOADSTATUS:
		{
			iCompare = pClient1->GetUploadState()-pClient2->GetUploadState();
			if ((pClient1->GetUploadState() == US_NONE) || (pClient2->GetUploadState() == US_NONE))
				iSortMod = 1;
			break;
		}
		case CLCOL_TRANSFERREDUP:
		{
		//	We are using a 64 bit variables for the credits
			if (pClient1->m_pCredits && pClient2->m_pCredits)
			{
				uint64	qwClient1Credits = pClient1->m_pCredits->GetUploadedTotal();
				uint64	qwClient2Credits = pClient2->m_pCredits->GetUploadedTotal();

				if (qwClient1Credits > qwClient2Credits)
					iCompare = 1;
				else if (qwClient1Credits < qwClient2Credits)
					iCompare = -1;
				else
					iCompare = 0;
			}
			else
			{
				iCompare = (!pClient1->m_pCredits) ? ( (!pClient2->m_pCredits)? 0:1) : -1;
				iSortMod = 1;
			}
			break;
		}
		case CLCOL_DOWNLOADSTATUS:
		{
			if (pClient1->GetDownloadState() == pClient2->GetDownloadState())
			{
				if (pClient1->GetDownloadState() == DS_ONQUEUE)
					iCompare = pClient1->IsRemoteQueueFull() ? 1 : (pClient2->IsRemoteQueueFull() ? -1:0);
			}
			else
				iCompare = pClient1->GetDownloadState() - pClient2->GetDownloadState();
			if ((pClient1->GetDownloadState() == DS_WAIT_FOR_FILE_REQUEST) || (pClient2->GetDownloadState() == DS_WAIT_FOR_FILE_REQUEST))
				iSortMod = 1;
			break;
		}
		case CLCOL_TRANSFERREDDOWN:
		{
		//	We are using a 64 bit variables for the credits
			if (pClient1->m_pCredits && pClient2->m_pCredits)
			{
				uint64	qwClient1Credits = pClient1->m_pCredits->GetDownloadedTotal();
				uint64	qwClient2Credits = pClient2->m_pCredits->GetDownloadedTotal();

				if (qwClient1Credits > qwClient2Credits)
					iCompare = 1;
				else if (qwClient1Credits < qwClient2Credits)
					iCompare = -1;
				else
					iCompare = 0;
			}
			else
			{
				iCompare = (!pClient1->m_pCredits) ? ( (!pClient2->m_pCredits)? 0:1) : -1;
				iSortMod = 1;
			}
			break;
		}
		case CLCOL_CLIENTSOFTWARE:
		{
			iCompare = SortClient(pClient1, pClient2, iSortMod);
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1, lParam2, CLCOL_USERNAME);
			//	Sort always in ascending order
				iSortMod = 1;
			}
			break;
		}
		case CLCOL_CONNECTEDTIME:
		{
#ifdef OLD_SOCKETS_ENABLED
			bool	bConnected1 = false, bConnected2 = false;

			if (pClient1->m_pRequestSocket != NULL)
				bConnected1 = pClient1->m_pRequestSocket->IsConnected();
			if (pClient2->m_pRequestSocket != NULL)
				bConnected2 = pClient2->m_pRequestSocket->IsConnected();

			iCompare = bConnected1 - bConnected2;
#endif //OLD_SOCKETS_ENABLED
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1, lParam2, CLCOL_USERNAME);
				iSortMod = 1;	//	Sort always in ascending order
			}
			break;
		}
		case CLCOL_USERHASH:
		{
			iCompare = memcmp(pClient1->GetUserHash(), pClient2->GetUserHash(), 16);
			break;
		}
	}

	return iCompare * iSortMod;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::OnNMClick(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pNMHDR);
//	Reset selection in DL list
	POSITION posSelClient = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetFirstSelectedItemPosition();

	while (posSelClient != NULL)
	{
		int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetNextSelectedItem(posSelClient);
		g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, 0, LVIS_SELECTED);
	}

	RefreshInfo();
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::OnNMDblclk(NMHDR *pNMHDR, LRESULT *pResult)
{
	POSITION posSelClient = GetFirstSelectedItemPosition();
	NOPRM(pNMHDR);

	if (posSelClient)
	{
		CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

		if (g_App.m_pPrefs->GetDetailsOnClick())
		{
			CClientDetails			dialog(IDS_CD_TITLE, pClient, this, 0);
			dialog.DoModal();
		}
		else
		{
			g_App.m_pMDlg->m_wndChat.StartSession(pClient);
		}
	}
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	RefreshInfo();
	CMuleListCtrl::OnKeyUp(nChar, nRepCnt, nFlags);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::RefreshInfo(void)
{
	if (GetFocus() == this)
	{
		POSITION		posSelClient = GetFirstSelectedItemPosition();

		if (posSelClient == 0)
		{
	 		g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
		}
		else
		{
			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, pClient);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVDISPINFO	*pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);

	if (g_App.m_pMDlg->IsRunning())
	{
	// Although we have an owner drawn listview control we store the text for the primary item in the listview, to be
	// capable of quick searching those items via the keyboard. Because our listview items may change their contents,
	// we do this via a text callback function. The listview control will send us the LVN_DISPINFO notification if
	// it needs to know the contents of the primary item.
	//
	// But, the listview control sends this notification all the time, even if we do not search for an item. At least
	// this notification is only sent for the visible items and not for all items in the list. Though, because this
	// function is invoked *very* often, no *NOT* put any time consuming code here in.

		if ((pDispInfo->item.mask & LVIF_TEXT) != 0)
		{
		//	Check for own search request, the rest of the flood comes from list control
		//	and isn't used as list is drawn by us
			if (pDispInfo->item.cchTextMax == ML_SEARCH_SZ)
			{
				CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);

				if (pClient != NULL)
				{
					switch (pDispInfo->item.iSubItem)
					{
						case CLCOL_USERNAME:
							_tcsncpy(pDispInfo->item.pszText, pClient->GetUserName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						case CLCOL_CLIENTSOFTWARE:
							_tcsncpy(pDispInfo->item.pszText, pClient->GetFullSoftVersionString(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						case CLCOL_USERHASH:
						{
							TCHAR	acHashStr[MAX_HASHSTR_SIZE];

						// As hash is short and has a fixed size, not buffer size check is performed
							_tcscpy(pDispInfo->item.pszText, md4str(pClient->GetUserHash(), acHashStr));
							break;
						}
						case CLCOL_COUNTRY:
							_tcsncpy(pDispInfo->item.pszText, pClient->GetCountryName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						default:
							pDispInfo->item.pszText[0] = _T('\0');
							break;
					}
				}
			}
			else if (pDispInfo->item.cchTextMax != 0)
				pDispInfo->item.pszText[0] = _T('\0');
		}
	}
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SortClient() compares two clients by software type/version/mod and returns -1,0,1. If 'iSortMode' is
//		1 then the sort is ascending, if -1 then descending. If the two clients can't be sorted by
//		software then they're sorted by user name.
int CClientListCtrl::SortClient(CUpDownClient *pClient1, CUpDownClient *pClient2, int iSortMode)
{
	int		iCompare = 0;

//	If either client is using unknown software, sort them by software ID (putting them at the end)
	if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN)
	{
		iCompare = (pClient1->GetClientSoft() - pClient2->GetClientSoft()) * iSortMode;	//append all unknown ones at the end
	}
//	If the clients are using the same software...
	else
	{
		if ((iCompare = (pClient1->GetClientSoft() - pClient2->GetClientSoft())) == 0)
		{
		//	Sort by mod version
			if ((iCompare = (pClient2->GetVersion() - pClient1->GetVersion())) == 0)
			{
				if (!pClient1->IsModStringEmpty())
					iCompare = (!pClient2->IsModStringEmpty()) ?
						_tcsicmp(pClient1->GetModString(), pClient2->GetModString()) : -1;
				else if (!pClient2->IsModStringEmpty())
					iCompare = 1;
			}
		}
	}
	return iCompare;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientListCtrl::AddDirtyClient(CUpDownClient *pClient)
{
	bool bResult = false;

//	If 'pClient' is not already in the dirty client list...
	if (m_pvecDirtyClients != NULL
		&& ::find(m_pvecDirtyClients->begin(),m_pvecDirtyClients->end(),pClient) == m_pvecDirtyClients->end())
	{
		m_pvecDirtyClients->push_back(pClient);
		bResult = true;
	}

	return bResult;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetDirtyClients() detaches the current dirty client list and returns it to the caller (who's responsible
//	for destroying it). This allows the client list control to update without locking down the client list.
CClientListCtrl::ClientVector* CClientListCtrl::GetDirtyClients()
{
	ClientVector		*pvecDirtyClients = NULL;

	if (!m_pvecDirtyClients->empty())
	{
		pvecDirtyClients = m_pvecDirtyClients;
		m_pvecDirtyClients = new ClientVector();
	}

	return pvecDirtyClients;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CClientListCtrl::PreTranslateMessage(MSG *pMsg)
{
	if ((pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_SYSKEYDOWN))
	{
		int		 iMessage	  = 0;
		POSITION posSelClient = GetFirstSelectedItemPosition();

		if (posSelClient != NULL)
		{
			short			nCode = GetCodeFromPressedKeys(pMsg);
			CUpDownClient	*pSource = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

			iMessage = GetClientListActionFromShortcutCode(nCode, pSource);

			if (iMessage > 0)
			{
				PostMessage(WM_COMMAND, static_cast<WPARAM>(iMessage));
				return TRUE;
			}
		}
	}

	return CMuleListCtrl::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::ShowSelectedUserDetails()
{
	POINT point;

	::GetCursorPos(&point);

	CPoint p = point;

	ScreenToClient(&p);

	int it = HitTest(p);

	if (it == -1)
		return;

	SetSelectionMark(it);

	CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetSelectionMark()));

	if (pClient != NULL)
	{
		CClientDetails dialog(IDS_CD_TITLE, pClient, this, 0);
		dialog.DoModal();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.140
log
@Save sorting directions for all GUI lists; Unified list sort initialization and click processing;
Simplified list arrow configuration interface.
@
text
@d26 1
@


1.139
log
@Slightly more efficient GetColumnWidth to speed up list drawing.
@
text
@d37 1
a37 1
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
a48 1
	memset(&m_bSortAscending, true, sizeof(m_bSortAscending));
d90 1
a90 1

a91 1
	{
a92 1
	}
d94 1
a94 18
	{
		int		iSortCode = g_App.m_pPrefs->GetColumnSortItem(CPreferences::TABLE_CLIENTLIST);

		iSortCode |= g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_CLIENTLIST) ? MLC_SORTASC : MLC_SORTDESC;
		SortInit(iSortCode);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::SortInit(int iSortCode)
{
//	Get the sort column
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);
//	Get the sort order
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;

	SetSortArrow(iSortColumn,bSortAscending);
	SortItems(SortProc, iSortCode);
	m_bSortAscending[iSortColumn] = bSortAscending;
a586 17
void CClientListCtrl::OnColumnClick(NMHDR *pNMHDR, LRESULT *pResult)
{
	NM_LISTVIEW	*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);
	int			iSubItem = pNMListView->iSubItem;
	bool		bSortOrder = m_bSortAscending[iSubItem];

// Reverse sorting direction for the same column and keep the same if column was changed
	if (static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
		m_bSortAscending[iSubItem] = bSortOrder = !bSortOrder;

	SetSortArrow(iSubItem, bSortOrder);
	SortItems(SortProc, iSubItem + ((bSortOrder) ? MLC_SORTASC : MLC_SORTDESC));
	g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_CLIENTLIST, iSubItem);
	g_App.m_pPrefs->SetColumnSortAscending(CPreferences::TABLE_CLIENTLIST, bSortOrder);
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.138
log
@Simplified column resize interface; Minor generic optimization.
@
text
@d258 1
a258 1
		r.right += GetColumnWidth(iColumn);
@


1.137
log
@Optimized list drawing; Slightly reduced column margins (space between actual data).
@
text
@d235 1
a235 1
	int					iWidth, iRight, iColumn;
a258 1
		iRight = r.right;
d409 1
a409 1
		r.left = iRight + LIST_CELL_PADDING;
d492 1
a492 1
BOOL CClientListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader, LRESULT *pResult)
d504 1
a504 1
		SetColumnWidth(iColumn,m_iColumnMaxWidths[iColumn]);
d506 1
a506 1
		CMuleListCtrl::OnNMDividerDoubleClick(pHeader,pResult);
a509 2

	return *pResult = TRUE;
d780 1
a780 1
		g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, (UINT)~LVIS_SELECTED, LVIS_SELECTED);
@


1.136
log
@Reduced H-file dependency.
@
text
@d217 1
d235 1
a235 1
	int					iWidth;
d248 3
a250 3
	r.right = r.left - 4;
	r.left += 4;
	iWidth = 8;
d254 3
a256 1
		int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
d258 3
a260 1
		if (!IsColumnHidden(iColumn) && !(bMeasuring && iColumn != m_iMeasuringColumn))
d262 1
a262 2
			r.right += GetColumnWidth(iColumn);
			switch (iColumn)
d264 1
a264 1
				case CLCOL_USERNAME:
d266 2
a267 1
					RECT			r2 = r;
d269 7
a275 12
					if (!bMeasuring)
					{
						POINT			point = {r2.left, r2.top + 1};
						int				iImgLstIdx = CLIENT_IMGLST_PLAIN;

					//	Select corresponding image list depending on client properties
						if (pClient->IsBanned())
							iImgLstIdx = CLIENT_IMGLST_BANNED;
						else if (pClient->IsFriend())
							iImgLstIdx = CLIENT_IMGLST_FRIEND;
						else if (pClient->m_pCredits->HasHigherScoreRatio(pClient->GetIP()))
							iImgLstIdx = CLIENT_IMGLST_CREDITUP;
d277 2
a278 2
					//	Display Client icon
						g_App.m_pMDlg->m_clientImgLists[iImgLstIdx].Draw(dc, pClient->GetClientIconIndex(), point, ILD_NORMAL);
d280 2
a281 10
						r2.left += 20;
						if (g_App.m_pIP2Country->ShowCountryFlag())
						{
							point.x += 20;
							point.y += 2;
							g_App.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryIndex(), point, ILD_NORMAL);
							r2.left += 22;
						}
					}
					else
d283 4
a286 3
						iWidth += 20;
						if (g_App.m_pIP2Country->ShowCountryFlag())
							iWidth += 22;
d288 7
d296 3
a298 14
					try
					{
						strBuffer = pClient->GetUserName();
					}
					catch(...)
					{	//	can crash here if name string object is wrong, probably because
					}	//	client was just deleted or user name object is currently updating
					if (strBuffer.IsEmpty())
						strBuffer.Format(_T("[%s]"), GetResString(IDS_UNKNOWN));
					dc->DrawText(strBuffer, &r2, iCalcFlag);

					if (bMeasuring && strBuffer.GetLength() != 0)
						iWidth += (r2.right - r2.left + 1);
					break;
d300 10
a309 1
				case CLCOL_UPLOADSTATUS:
d311 15
a325 21
					switch (pClient->GetUploadState())
					{
						case US_ONUPLOADQUEUE:
							dwResStrId = IDS_ONQUEUE;
							break;
						case US_BANNED:
							dwResStrId = IDS_BANNED;
							break;
						case US_CONNECTING:
							dwResStrId = IDS_CONNECTING;
							break;
						case US_UPLOADING:
							dwResStrId = IDS_TRANSFERRING;
							break;
						default:
							strBuffer = _T("");
							dwResStrId = 0;
					}
					if (dwResStrId != 0)
						GetResString(&strBuffer, dwResStrId);
					break;
d327 10
a336 6
				case CLCOL_TRANSFERREDUP:
					if (pClient->m_pCredits)
						strBuffer = CastItoXBytes(pClient->m_pCredits->GetUploadedTotal());
					else
						strBuffer = _T("");
					break;
d338 3
a340 1
				case CLCOL_DOWNLOADSTATUS:
d342 33
a374 39
					switch (pClient->GetDownloadState())
					{
						case DS_CONNECTING:
							dwResStrId = IDS_CONNECTING;
							break;
						case DS_CONNECTED:
							dwResStrId = IDS_ASKING;
							break;
						case DS_WAITCALLBACK:
							dwResStrId = IDS_CONNVIASERVER;
							break;
						case DS_ONQUEUE:
							dwResStrId = pClient->IsRemoteQueueFull()  ? IDS_QUEUEFULL : IDS_ONQUEUE;
							break;
						case DS_DOWNLOADING:
							dwResStrId = IDS_TRANSFERRING;
							break;
						case DS_REQHASHSET:
							dwResStrId = IDS_RECHASHSET;
							break;
						case DS_NONEEDEDPARTS:
							dwResStrId = IDS_NONEEDEDPARTS;
							break;
						case DS_LOWTOLOWID:
							dwResStrId = IDS_NOCONNECTLOW2LOW;
							break;
						case DS_LOWID_ON_OTHER_SERVER:
							dwResStrId = IDS_ANOTHER_SERVER_LOWID;
							break;
						case DS_WAIT_FOR_FILE_REQUEST:
							dwResStrId = IDS_WAITFILEREQ;
							break;
						default:
							strBuffer = _T("");
							dwResStrId = 0;
					}
					if (dwResStrId != 0)
						GetResString(&strBuffer, dwResStrId);
					break;
d376 14
a389 10
				case CLCOL_TRANSFERREDDOWN:
					if(pClient->m_pCredits)
						strBuffer = CastItoXBytes(pClient->m_pCredits->GetDownloadedTotal());
					else
						strBuffer = _T("");
					break;

				case CLCOL_CLIENTSOFTWARE:
					strBuffer = pClient->GetFullSoftVersionString();
					break;
d391 1
a391 1
				case CLCOL_CONNECTEDTIME:
d393 1
a393 1
					strBuffer = YesNoStr(pClient->m_pRequestSocket != NULL && pClient->m_pRequestSocket->IsConnected());
d395 1
a395 1
					break;
d397 3
a399 3
				case CLCOL_USERHASH:
					strBuffer = HashToString(pClient->GetUserHash());
					break;
d401 18
a418 20
				case CLCOL_COUNTRY:
					strBuffer = pClient->GetCountryName();
					break;
			}
			if (iColumn != CLCOL_USERNAME)
			{
				dc->DrawText(strBuffer, &r, iCalcFlag);
				if (bMeasuring && strBuffer.GetLength() != 0)
					iWidth += r.right - r.left + 1;
			}
			r.left += GetColumnWidth(iColumn);

			if (bMeasuring)
			{
			//	Pin the column widths at some reasonable value.
				if (iWidth < 40 && iWidth != 0)
					iWidth = 40;
				if (iWidth > m_iColumnMaxWidths[m_iMeasuringColumn])
					m_iColumnMaxWidths[m_iMeasuringColumn] = iWidth;
			}
d438 1
@


1.135
log
@Allow search by file, hash, country and client software in source lists on transfer page (by client software in the download source list; by file and country in the upload and wait lists; by client software, hash and country in the known client list);
Fixed recently broken search in the transfer pane lists;
Increased transfer page list performance by not processing meaningless list control GetDispInfo requests.
@
text
@d20 1
@


1.134
log
@Fixed crash caused by invalid pointers casting {Nestor}.
@
text
@d856 1
a856 1
		if ((pDispInfo->item.mask & (LVIF_TEXT | LVIF_PARAM)) == (LVIF_TEXT | LVIF_PARAM))
d858 5
a862 1
			CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);
d864 1
a864 3
			if (pClient != NULL)
			{
				switch (pDispInfo->item.iSubItem)
d866 3
a868 3
					case 0:
						if (!pClient->IsUserNameEmpty() && (pDispInfo->item.cchTextMax > 0))
						{
d871 14
d886 9
a894 5
						break;
					default:
					//	Shouldn't happen
						pDispInfo->item.pszText[0] = _T('\0');
						break;
d897 2
@


1.133
log
@Removed unused client upload states.
@
text
@d843 1
a843 1
	NMLVDISPINFO		*pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);
d856 1
a856 1
		if (pDispInfo->item.mask & LVIF_TEXT)
d858 1
a858 1
			CUpDownClient		*pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);
@


1.132
log
@removed duplicated GetuserName() method
@
text
@a316 3
						case US_PENDING:
							dwResStrId = IDS_CL_PENDING;
							break;
a319 3
						case US_ERROR:
							dwResStrId = IDS_ERRORLIKE;
							break;
a322 3
						case US_WAITCALLBACK:
							dwResStrId = IDS_CONNVIASERVER;
							break;
@


1.131
log
@Rolled back recent change 'do not send an update messages if windows is not visible' as it broke proper list sorting.
@
text
@d297 1
a297 1
						pClient->GetUserName(&strBuffer);
@


1.130
log
@do not send an update messages if windows is not visible
@
text
@d203 1
a203 1
	if (IsWindowVisible() && pClient != NULL)
a205 1
		{
a206 1
		}
@


1.129
log
@rolled back last changes.
@
text
@d203 1
a203 1
	if (pClient != NULL)
@


1.128
log
@changed the handlig of embedded GUI list header
@
text
@a86 2
	InitHeader();

d131 1
d141 1
a141 1
		m_pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d245 2
a246 1
	int				iNumColumns = m_pHeaderCtrl->GetItemCount();
d254 1
a254 1
		int		iColumn = m_pHeaderCtrl->OrderToIndex(iCurrent);
@


1.127
log
@Optimized setting title for client details dialog.
@
text
@d87 2
a132 1
	CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
d142 1
a142 1
		pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d246 1
a246 2
	CHeaderCtrl	   *pHeaderCtrl = GetHeaderCtrl();
	int				iNumColumns = pHeaderCtrl->GetItemCount();
d254 1
a254 1
		int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
@


1.126
log
@Optimized string shortcut representation.
@
text
@d616 1
a616 1
				CClientDetails		dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
d816 1
a816 1
			CClientDetails			dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
d1000 1
a1000 1
		CClientDetails dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
@


1.125
log
@removed the set of ODA_SELECT action on item drawing
@
text
@d553 1
a553 1
	menuClient.AppendMenu(dwMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(SCUT_SRC_DETAILS, SSP_TAB_PREFIX));
d563 2
a564 2
	menuClient.AppendMenu(dwMenuFlags, dwRes, GetResString(dwResStrId) + GetStringFromShortcutCode(SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(SCUT_SRC_MSG, SSP_TAB_PREFIX));
d566 1
a566 1
		MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(SCUT_SRC_SHAREDFILES, SSP_TAB_PREFIX) );
d795 1
a795 1
	if (posSelClient)
d797 2
a798 5
		while (posSelClient)
		{
			int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetNextSelectedItem(posSelClient);
			g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, (UINT)~LVIS_SELECTED, LVIS_SELECTED);
		}
@


1.124
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d228 1
a228 1
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d438 1
a438 1
	if (!bMeasuring && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
@


1.123
log
@Simplified DrawText code -- no logic changed.
@
text
@d84 1
a84 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auColHdr); ui++)
d137 1
a137 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auResTbl); ui++)
d440 2
a441 1
		RECT		rOutline = lpDrawItemStruct->rcItem;
d445 1
a445 1
		dc->FrameRect(&rOutline, &CBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine));
d532 1
d577 1
a577 1
BOOL CClientListCtrl::OnCommand(WPARAM wParam,LPARAM lParam)
d580 1
a588 1
			{
d591 1
a591 1
			}
a592 1
			{
d595 1
a595 1
			}
a596 1
			{
d600 1
a600 1
			}
a601 1
			{
d605 1
a605 1
			}
a606 1
			{
d613 1
a613 1
			}
d632 1
a632 1
	if ((m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
d791 1
a791 1

d800 1
a800 1
			g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
a801 1

d811 1
@


1.122
log
@One more level of protection against potential crashes; Minor formatting.
@
text
@d306 1
a306 1
					dc->DrawText(strBuffer, strBuffer.GetLength(), &r2, iCalcFlag);
d421 1
a421 1
				dc->DrawText(strBuffer, strBuffer.GetLength(), &r, iCalcFlag);
@


1.121
log
@Fixed rare crash while processing client lists (score access when pClient->m_pCredits = NULL) {ompz};
Optimized score calculation and higher score status detection.
@
text
@d24 1
a24 1
#include "Details\ClientDetails.h"
d218 1
a218 2
	if (!g_App.m_pMDlg->IsRunning())
		return;
d220 1
a220 1
	if (!lpDrawItemStruct->itemData)
d407 1
a408 1
					strBuffer = YesNoStr(pClient->m_pRequestSocket != NULL && pClient->m_pRequestSocket->IsConnected());
d451 2
d852 1
a852 1
	 		g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,pClient);
d1005 2
a1006 2
			CClientDetails dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
			dialog.DoModal();
@


1.120
log
@Fixed rare crash on known client list update {davide} (thanks KuSh for debugging).
@
text
@d225 1
a225 1
	BOOL			bCtrlFocused = ((GetFocus() == this ) || (GetStyle() & LVS_SHOWSELALWAYS));
d276 1
a276 1
						else if (pClient->m_pCredits->GetScoreRatio(pClient->GetIP()) > 1)
@


1.119
log
@Rolled back "don't process invisible GUI lists" - reason: current list positions and visible view regions are not preserved.
@
text
@d298 7
a304 1
					pClient->GetUserName(&strBuffer);
d307 1
a307 1
					dc->DrawText(strBuffer,strBuffer.GetLength(),&r2, iCalcFlag);
d422 1
a422 1
				dc->DrawText(strBuffer,strBuffer.GetLength(),&r,iCalcFlag);
@


1.118
log
@don't process invisible GUI lists
@
text
@a50 2
	m_bIsVisible = false;

d145 1
a145 1
BOOL CClientListCtrl::ShowWindow(int iCmdShow)
d147 1
a147 10
	if (iCmdShow == SW_HIDE)
	{
		m_bIsVisible = false;
		DeleteAllItems();
	}
	else if(iCmdShow == SW_SHOW)
	{
		m_bIsVisible = true;
		ShowKnownClients();
	}
a148 5
	return CMuleListCtrl::ShowWindow(iCmdShow);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::ShowKnownClients()
{
d166 1
a166 3
	if (m_bIsVisible)
	{
		LVFINDINFO		find;
d168 2
a169 2
		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pClient;
d171 4
a174 5
		if ((FindItem(&find) < 0) && (pClient != NULL))
		{
			InsertItem(LVIF_TEXT|LVIF_PARAM, GetItemCount(), LPSTR_TEXTCALLBACK, 0, 0, 1, reinterpret_cast<LPARAM>(pClient));
			g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
		}
d188 2
d191 4
a194 1
	if (m_bIsVisible)
d196 2
a197 11
		sint32		iResult;
		LVFINDINFO	find;

		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pClient;
		
		if ((iResult = FindItem(&find)) >= 0)
		{
			DeleteItem(iResult);
			g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
		}
d203 1
a203 1
	if (m_bIsVisible && (pClient != NULL))
d464 3
a466 1
				if (m_bIsVisible)
d468 2
a469 6
					int		iNumDirtySources = pvecDirtyClients->size();

					for (int i = 0; i < iNumDirtySources; i++)
					{
						LVFINDINFO		find;
						int			iResult;
d471 2
a472 2
						find.flags = LVFI_PARAM;
						find.lParam = (LPARAM)(*pvecDirtyClients)[i];
d474 3
a476 5
						iResult = FindItem(&find);

						if (iResult != -1)
							Update(iResult);
					}
@


1.117
log
@Renamed DS_LOWTOLOWIP -> DS_LOWTOLOWID.
@
text
@d51 2
d147 16
d165 2
a166 5
	DeleteAllItems();

	int					i = 0;
	CString				strTemp;
	CUpDownClient	   *pClient;
d168 1
a173 1
		UpdateClient(pClient);
d176 1
d182 3
a184 1
	LVFINDINFO		find;
d186 2
a187 2
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;
d189 5
a193 6
	sint32		iResult = FindItem(&find);

	if ((iResult < 0) && (pClient != NULL))
	{
		InsertItem(LVIF_TEXT|LVIF_PARAM, GetItemCount(), LPSTR_TEXTCALLBACK, 0, 0, 1, (LPARAM)pClient);
		g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
a206 2
	sint32		iResult;
	LVFINDINFO	find;
d208 1
a208 4
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;
	
	if ((iResult = FindItem(&find)) >= 0)
d210 11
a220 2
		DeleteItem(iResult);
		g_App.m_pMDlg->m_wndTransfer.UpdateKnown();
d226 1
a226 1
	if (pClient != NULL)
d487 3
a489 1
				int		iNumDirtySources = pvecDirtyClients->size();
d491 4
a494 3
				for (int i = 0; i < iNumDirtySources; i++)
				{
					LVFINDINFO		find;
d496 2
a497 2
					find.flags = LVFI_PARAM;
					find.lParam = (LPARAM)(*pvecDirtyClients)[i];
d499 1
a499 1
					int	iResult = FindItem(&find);
d501 3
a503 2
					if (iResult != -1)
						Update(iResult);
@


1.116
log
@Reduced H-file dependency.
@
text
@d374 1
a374 1
						case DS_LOWTOLOWIP:
@


1.115
log
@Formatting.
@
text
@d21 1
d26 1
@


1.114
log
@UNICODE preparation (first shot)
@
text
@a614 2


d985 1
a985 1
    ScreenToClient(&p);
d987 1
a987 1
    int it = HitTest(p);
d989 1
a989 2
    if (it == -1)
	{
d991 1
a991 1
	}
@


1.113
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d138 1
a138 1
		hdi.pszText = (LPSTR)strRes.GetString();
@


1.112
log
@renamed 3 variables
@
text
@d89 1
a89 1
	if (g_App.g_pPrefs->DoUseSort())
d91 1
a91 1
		SortInit(g_App.g_pPrefs->GetClientListSortCol());
d95 1
a95 1
		int		iSortCode = g_App.g_pPrefs->GetColumnSortItem(CPreferences::TABLE_CLIENTLIST);
d97 1
a97 1
		iSortCode |= g_App.g_pPrefs->GetColumnSortAscending(CPreferences::TABLE_CLIENTLIST) ? MLC_SORTASC : MLC_SORTDESC;
d560 1
a560 1
	menuClient.SetDefaultItem((g_App.g_pPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
d634 2
a635 2
	g_App.g_pPrefs->SetColumnSortItem(CPreferences::TABLE_CLIENTLIST, iSubItem);
	g_App.g_pPrefs->SetColumnSortAscending(CPreferences::TABLE_CLIENTLIST, bSortOrder);
d814 1
a814 1
		if (g_App.g_pPrefs->GetDetailsOnClick())
@


1.111
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d73 1
a73 1
	ilDummyImageList.Create(1, 17, g_eMuleApp.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
d89 1
a89 1
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())
d91 1
a91 1
		SortInit(g_eMuleApp.m_pGlobPrefs->GetClientListSortCol());
d95 1
a95 1
		int		iSortCode = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_CLIENTLIST);
d97 1
a97 1
		iSortCode |= g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_CLIENTLIST) ? MLC_SORTASC : MLC_SORTDESC;
d151 1
a151 1
	for (POSITION pos = g_eMuleApp.m_pClientList->m_clientList.GetHeadPosition(); pos != NULL; )
d153 1
a153 1
		pClient = g_eMuleApp.m_pClientList->m_clientList.GetNext(pos);
d159 1
a159 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateKnown();
d174 1
a174 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateKnown();
d180 1
a180 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning() || (pClient == NULL))
d183 1
a183 1
	if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE)
d185 2
a186 2
		if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == pClient)
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d197 1
a197 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateKnown();
d218 1
a218 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d280 1
a280 1
						g_eMuleApp.m_pdlgEmule->m_clientImgLists[iImgLstIdx].Draw(dc, pClient->GetClientIconIndex(), point, ILD_NORMAL);
d283 1
a283 1
						if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d287 1
a287 1
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryIndex(), point, ILD_NORMAL);
d294 1
a294 1
						if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d538 1
a538 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,pClient);
d560 1
a560 1
	menuClient.SetDefaultItem((g_eMuleApp.m_pGlobPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
d585 1
a585 1
				g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(pClient);
d590 1
a590 1
				g_eMuleApp.m_pFriendList->AddFriend(pClient);
d596 1
a596 1
				g_eMuleApp.m_pFriendList->RemoveFriend(pClient);
d634 2
a635 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_CLIENTLIST, iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_CLIENTLIST, bSortOrder);
d790 1
a790 1
	POSITION posSelClient = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.GetFirstSelectedItemPosition();
d796 2
a797 2
			int iSelClientListIndex = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.GetNextSelectedItem(posSelClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d814 1
a814 1
		if (g_eMuleApp.m_pGlobPrefs->GetDetailsOnClick())
d821 1
a821 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(pClient);
d841 1
a841 1
	 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d847 1
a847 1
	 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,pClient);
d856 1
a856 1
	if (g_eMuleApp.m_pdlgEmule->IsRunning())
@


1.110
log
@One more step to integrate eklmn's SSDQ.
@
text
@d378 1
a378 1
						case DS_TOOMANYCONNS:
d720 1
a720 1
			if ((pClient1->GetDownloadState() == DS_NONE) || (pClient2->GetDownloadState() == DS_NONE))
@


1.109
log
@Fixed compilation.
@
text
@d375 3
@


1.108
log
@Some eklmn's modifications.
@
text
@a316 3
						case US_LOWTOLOWIP:
							dwResStrId = IDS_CL_LOW2LOW;
							break;
@


1.107
log
@new way of queue handling
@
text
@d379 1
a379 1
							dwResStrId = IDS_TOOMANYCONNS;
@


1.106
log
@In case of client addition/removal, update known client count only in case of successful operation;
Removed suspicious loop while removing known client from the list.
@
text
@d364 1
a364 4
							if (pClient->IsQueueRankReceived())
								dwResStrId = pClient->IsRemoteQueueFull()  ? IDS_QUEUEFULL : IDS_ONQUEUE;
							else
								dwResStrId = pClient->IsEmuleClient()  ? IDS_QUEUEFULL : IDS_ONQUEUE;
d715 2
a716 18
				if (pClient1->GetDownloadState() != DS_ONQUEUE)
					iCompare = 0;
				else
				{
					if ( (pClient1->IsQueueRankReceived() && pClient1->IsRemoteQueueFull()) 
						|| (!pClient1->IsQueueRankReceived() && pClient1->IsEmuleClient()) )
					{
						iCompare = 1;
					}
					else if ( (pClient2->IsQueueRankReceived() && pClient2->IsRemoteQueueFull()) 
							|| (!pClient2->IsQueueRankReceived() && pClient2->IsEmuleClient()) )
					{
						iCompare = -1;
					}
					else
						iCompare = 0;
				}
					
@


1.105
log
@1. QR highlighting
2. output "Queue Full" if eMule client did not send QR
3. possible download abort
@
text
@d171 1
a171 1
	if (iResult == (-1) && pClient != NULL)
d173 2
a174 3
		uint32		iNumItems = GetItemCount();

		iNumItems = InsertItem(LVIF_TEXT|LVIF_PARAM,iNumItems,LPSTR_TEXTCALLBACK,0,0,1,(LPARAM)pClient);
a175 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateKnown();
d180 1
a180 3
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
		return;
	if (pClient == NULL)
a185 1
		{
a186 1
		}
d188 2
d191 4
a194 3
	sint32		iResult = 0;

	while (iResult != -1)
d196 2
a197 7
		LVFINDINFO		find;

		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pClient;
		iResult = FindItem(&find);
		if (iResult != (-1))
			DeleteItem(iResult);
a198 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateKnown();
@


1.104
log
@Unified way to show source with empty name (like in download list).
@
text
@d373 4
a376 1
							dwResStrId = (pClient->IsRemoteQueueFull()) ? IDS_QUEUEFULL : IDS_ONQUEUE;
d726 20
a745 1
				iCompare = pClient1->IsRemoteQueueFull() ? 1 : (pClient2->IsRemoteQueueFull() ? -1: 0);
@


1.103
log
@Faster remote client name handling.
@
text
@d309 1
a309 1
						strBuffer.Format(_T("(%s)"), GetResString(IDS_UNKNOWN));
@


1.102
log
@Unified and regrouped shortcuts.
@
text
@d307 1
a307 1
					strBuffer = pClient->GetUserName();
d406 1
a406 1
					strBuffer = pClient->GetClientNameAndVersionString();
d664 1
a664 1
			iCompare = _tcsicmp(pClient1->GetUserName(), pClient2->GetUserName());
d882 1
a882 1
						if (!pClient->GetUserName().IsEmpty() && pDispInfo->item.cchTextMax > 0)
d885 1
a885 1
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
@


1.101
log
@Unified and slightly faster way to draw list cursor;
More space for data in upload pane lists (reduced column margins).
@
text
@d553 1
a553 1
	menuClient.AppendMenu(dwMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(IndexULDetails, SSP_TAB_PREFIX));
d563 2
a564 2
	menuClient.AppendMenu(dwMenuFlags, dwRes, GetResString(dwResStrId) + GetStringFromShortcutCode(IndexULFriend, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(IndexULMessage, SSP_TAB_PREFIX));
d566 1
a566 1
		MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(IndexULFiles, SSP_TAB_PREFIX) );
@


1.100
log
@Faster drawing of some list elements.
@
text
@d235 1
d237 3
a239 4
	if (odc && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
		odc->SetBkColor((bCtrlFocused) ? m_crHighlight : m_crNoHighlight);
	else
		odc->SetBkColor(GetBkColor());
d242 1
a242 1
	CMemDC				dc(CDC::FromHandle(lpDrawItemStruct->hDC),&CRect(lpDrawItemStruct->rcItem));
d245 1
a245 1
	int					iWidth = 0;
a254 1

d258 1
a258 1
	r.right = r.left - 8;
d260 1
a260 1
	iWidth = 12;
a352 1
				{
d358 1
a358 1
				}
a398 1
				{
d404 1
a404 1
				}
a405 1
				{
d408 1
a408 1
				}
a409 1
				{
d414 1
a414 1
				}
a415 1
				{
d418 1
a418 1
				}
a419 1
				{
a421 1
				}
d444 1
a444 1
		RECT		outline_rec = lpDrawItemStruct->rcItem;
d446 3
a448 4
		dc->FrameRect(&outline_rec, &CBrush(GetBkColor()));
		outline_rec.left++;
		outline_rec.right--;
		dc->FrameRect(&outline_rec, &CBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine));
@


1.99
log
@Corrected sorting by Connected in Known Clients list
(Note: this didn't solve current sorting issue completely).
@
text
@d236 2
a237 7
	if( odc && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED ))
	{
		if(bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	}
d454 1
a454 8
		outline_rec.top--;
		outline_rec.bottom++;
		CBrush gdiBrush(GetBkColor());
		CBrush *pOldBrush = dc->SelectObject(&gdiBrush);
		dc->FrameRect(&outline_rec, &gdiBrush);
		dc->SelectObject(pOldBrush);
		outline_rec.top++;
		outline_rec.bottom--;
d457 1
a457 15

		if (bCtrlFocused)
		{
			CBrush		fl_Brush(m_crFocusLine);
			dc->SelectObject(&fl_Brush);
			dc->FrameRect(&outline_rec, &fl_Brush);
		}
		else
		{
			CBrush nfl_Brush(m_crNoFocusLine);
			dc->SelectObject(&nfl_Brush);
			dc->FrameRect(&outline_rec, &nfl_Brush);
		}

		dc->SelectObject(pOldBrush);
@


1.98
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d46 1
a46 1
	memset2(&m_bSortAscending, true, sizeof(m_bSortAscending));
d801 10
a810 3
			if (pClient1->m_pRequestSocket != NULL && pClient2->m_pRequestSocket != NULL)
				iCompare = pClient1->m_pRequestSocket->IsConnected() - pClient2->m_pRequestSocket->IsConnected();
			else
d812 2
a813 2
				iCompare = (pClient1->m_pRequestSocket != NULL) ? 1: ((pClient2->m_pRequestSocket != NULL) ? -1 : 0);
				iSortMod = 1;
a814 1
#endif //OLD_SOCKETS_ENABLED
a821 2
		default:
			iCompare = 0;
@


1.97
log
@Use of CPU optimised memset2 function
Code refactoring
@
text
@d73 1
a73 1
	ilDummyImageList.Create(1, 17, ILC_COLOR32 | ILC_MASK, 1, 1);
@


1.96
log
@Inform a remote client when 'See my share = No one' to save traffic (original).
@
text
@d46 1
a46 1
	memset(&m_bSortAscending, true, sizeof(m_bSortAscending));
d61 9
a69 9
		{ LVCFMT_LEFT, 150 },	//CLCOL_USERNAME
		{ LVCFMT_LEFT, 100 },	//CLCOL_UPLOADSTATUS
		{ LVCFMT_LEFT, 100 },	//CLCOL_TRANSFERREDUP
		{ LVCFMT_LEFT, 100 },	//CLCOL_DOWNLOADSTATUS
		{ LVCFMT_LEFT, 100 },	//CLCOL_TRANSFERREDDOWN
		{ LVCFMT_LEFT, 120 },	//CLCOL_CLIENTSOFTWARE
		{ LVCFMT_LEFT,  80 },	//CLCOL_CONNECTEDTIME
		{ LVCFMT_LEFT, 210 },	//CLCOL_USERHASH
		{ LVCFMT_LEFT, 150 }	//CLCOL_COUNTRY
d118 9
a126 9
		IDS_QL_USERNAME,				//CLCOL_USERNAME
		IDS_CL_UPLOADSTATUS,			//CLCOL_UPLOADSTATUS
		IDS_CL_TRANSFUP,				//CLCOL_TRANSFERREDUP
		IDS_CL_DOWNLSTATUS,				//CLCOL_DOWNLOADSTATUS
		IDS_CL_TRANSFDOWN,				//CLCOL_TRANSFERREDDOWN
		IDS_INFLST_USER_CLIENTSOFTWARE,	//CLCOL_CLIENTSOFTWARE
		IDS_CONNECTED,					//CLCOL_CONNECTEDTIME
		IDS_INFLST_USER_USERHASH,		//CLCOL_USERHASH
		IDS_COUNTRY						//CLCOL_COUNTRY
d284 1
a284 1
						int			iImgLstIdx = CLIENT_IMGLST_PLAIN;
d286 1
a286 1
					// Select corresponding image list depending on client properties
d507 1
a507 1
			
d516 1
a516 1
						
d530 1
d533 1
d698 1
d701 1
a701 1

d708 1
d710 1
d727 1
d732 1
d734 1
d754 1
d756 1
d764 1
d766 1
d786 1
d788 1
d797 1
d799 1
d810 1
d812 1
d815 1
d817 1
a817 1
			return 0;
d966 1
a966 1
	if (m_pvecDirtyClients != NULL 
d1016 1
a1016 1
void CClientListCtrl::ShowSelectedUserDetails() 
d1022 1
a1022 1
	CPoint p = point; 
d1024 1
a1024 1
    ScreenToClient(&p); 
d1026 1
a1026 1
    int it = HitTest(p); 
@


1.95
log
@Probable solution for crashes reported by users crash dumps.
@
text
@d598 3
a600 2
	menuClient.AppendMenu(dwMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(IndexULFiles, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwMenuFlags | (((pClient && pClient->IsBanned()) ? MF_ENABLED : MF_GRAYED)), MP_UNBAN, GetResString(IDS_UNBAN) );
@


1.94
log
@Own client type for eMule Plus clients.
@
text
@d494 1
a494 1
	BOOL		bHandled = FALSE;
a526 1
			bHandled = true;
d529 3
d537 1
a537 3
	{
		bHandled = CMuleListCtrl::OnWndMsg(iMessage,wParam,lParam,pResult);
	}
@


1.93
log
@Faster sorting by client software and user name;
Faster client software version processing; Fixed eMule Plus identification;
Completely reworked remote clients version detection.
@
text
@d927 2
a928 9
			uint32	dwPlus1 = pClient1->GetPlusVersion();
			uint32	dwPlus2 = pClient2->GetPlusVersion();

			if (dwPlus1 != 0)
				iCompare = (dwPlus2 != 0) ? (dwPlus2 - dwPlus1) : -1;
			else if (dwPlus2 != 0)
				iCompare = 1;
		//	If neither is e+ and they're the same eMule version...
			else
d930 5
a934 9
			//	Sort by mod version
				if ((iCompare = (pClient2->GetVersion() - pClient1->GetVersion())) == 0)
				{
					if (!pClient1->IsModStringEmpty())
						iCompare = (!pClient2->IsModStringEmpty()) ?
							_tcsicmp(pClient1->GetModString(), pClient2->GetModString()) : -1;
					else if (!pClient2->IsModStringEmpty())
						iCompare = 1;
				}
@


1.92
log
@Fixed Info header update on key navigation in Known Clients list [reported by Fuxie - DK].
@
text
@d695 1
a695 7
			if (pClient1->GetUserName() && pClient2->GetUserName())
				iCompare = _tcsicmp(pClient1->GetUserName(),pClient2->GetUserName());
			else
			{
				iCompare = (!pClient1->GetUserName()) ? ( (!pClient2->GetUserName())? 0:1) : -1;
				iSortMod = 1;
			}
d697 1
d714 2
a715 2
				iCompare = SortProc(lParam1,lParam2,CLCOL_USERNAME);
			//	Sort allways in ascending order
d775 6
d918 1
a918 1
	if (pClient1->GetClientSoft() == SO_UNKNOWN || pClient2->GetClientSoft() == SO_UNKNOWN )
d920 1
a920 1
		iCompare = (pClient1->GetClientSoft()-pClient2->GetClientSoft())*iSortMode;		//Cax2 append all unknown ones at the end
d923 1
a923 1
	else if (pClient1->GetClientSoft() == pClient2->GetClientSoft())
d925 1
a925 2
	//	... and they're both eMule...
		if (pClient1->IsEmuleClient())
d927 2
a928 2
			uint32		plus1 = (pClient1->GetPlusVersion() < 0x2600) ? pClient1->GetPlusVersion() : 0;
			uint32		plus2 = (pClient2->GetPlusVersion() < 0x2600) ? pClient2->GetPlusVersion() : 0;
d930 4
a933 6
		//	If they're both e+...
			if (plus1 && plus2)
				iCompare = plus2 - plus1;
		//	If only one is e+...
			else if (plus1 || plus2)
				iCompare = (plus1) ? -1 : 1;
d935 1
a935 1
			else if (pClient1->GetMuleVersion() == pClient2->GetMuleVersion())
d938 8
a945 4
				if (!pClient1->GetModVersion().IsEmpty() && !pClient2->GetModVersion().IsEmpty())
					iCompare = _tcsicmp(pClient1->GetModVersion(), pClient2->GetModVersion());
				else if (!pClient1->GetModVersion().IsEmpty() || !pClient2->GetModVersion().IsEmpty())
					iCompare = (pClient1->GetModVersion().IsEmpty()) ? 1 : -1;
a946 8
			else
				iCompare = pClient2->GetMuleVersion() - pClient1->GetMuleVersion();
		}
	//	... but they're not eMule...
		else
		{
		//	Sort them by software _version_
			iCompare = pClient2->GetVersion() - pClient1->GetVersion();
a948 15
//	Sort the clients by software ID
	else
	{
		iCompare = pClient1->GetClientSoft() - pClient2->GetClientSoft();
	}

//	If the sort is still ambiguous, do a secondary sort on user name
	if (iCompare == 0)
	{
		if (pClient1->GetUserName() && pClient2->GetUserName())
			iCompare = _tcsicmp(pClient1->GetUserName(),pClient2->GetUserName());
		else
			iCompare = (!pClient1->GetUserName()) ? ( (!pClient1->GetUserName())? 0:1) : -1;
		iCompare *= iSortMode;
	}
@


1.91
log
@SSWQ
@
text
@d23 1
a23 1
#include ".\Details\ClientDetails.h"
d38 1
@


1.90
log
@Preparations for new client version report code.
@
text
@a174 1
		UpdateClient(pClient);
d213 4
a216 3
		AddDirtyClient(pClient);

		PostRefreshMessage();
d516 1
a516 1
					sint16	result = FindItem(&find);
d518 2
a519 2
					if (result != -1)
						Update(result);
d972 1
a972 3
//	PostRefreshMessage() puts a message into the list control's message queue telling it it needs to
//	refresh dirty clients and then immediately returns.
void CClientListCtrl::PostRefreshMessage()
d974 1
a974 3
	if (::IsWindow(GetSafeHwnd()))
	{
		MSG		msg;
a975 11
	//	If there's no refresh message already in the message queue... (don't want to flood it)
		if (!::PeekMessage(&msg,m_hWnd,WM_CL_REFRESH,WM_CL_REFRESH,false))
		{
		//	... then post one with the current time so we know how long the request has been pending when we get it.
			PostMessage(WM_CL_REFRESH,0,static_cast<LPARAM>(::GetCurrentTime()));
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientListCtrl::AddDirtyClient(CUpDownClient *pClient)
{
d977 2
a978 1
	if (::find(m_pvecDirtyClients->begin(),m_pvecDirtyClients->end(),pClient) == m_pvecDirtyClients->end())
d981 1
d983 2
@


1.89
log
@Faster shortcuts handling.
@
text
@d414 1
a414 1
					strBuffer = GetClientNameAndVersionString(pClient);
@


1.88
log
@Faster client icon drawing in the lists;
Unified processing of client icon images; Minor optimization.
@
text
@d585 1
a585 1
	menuClient.AppendMenu(dwMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails),SSP_TAB_PREFIX));
d595 3
a597 3
	menuClient.AppendMenu(dwMenuFlags, dwRes, GetResString(dwResStrId) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend), SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage),SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles),SSP_TAB_PREFIX));
d1013 1
a1013 1
BOOL CClientListCtrl::PreTranslateMessage(MSG* pMsg)
d1015 1
a1015 1
	if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
a1017 1
		short	 nCode		  = GetCodeFromPressedKeys(pMsg);
d1022 2
a1023 1
			CUpDownClient* pSource = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));
@


1.87
log
@Corrected several list column labels; Unified list column creature;
Set list column labels only in one place to avoid future incorrections.
@
text
@d23 1
a23 1
#include ".\\Details\\ClientDetails.h"
a52 1
	m_imageList.DeleteImageList();
a57 15
	static const uint16 s_auIconResID[] =
	{
		IDI_NORMAL,			// 0
		IDI_COMPROT,		// 1
		IDI_MLDONKEY,		// 2
		IDI_EDONKEYHYBRID,	// 3
		IDI_CREDIT_ONLY,	// 4
		IDI_FRIEND_ONLY,	// 5
		IDI_BANNED_ONLY,	// 6
		IDI_UNKNOWN,		// 7
		IDI_AMULE,			// 8
		IDI_LMULE,			// 9
		IDI_SHAREAZA,		// 10
		IDI_SECUREHASH		// 11
	};
a83 5
	m_imageList.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	m_imageList.SetBkColor(CLR_NONE);
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ELEMENT_COUNT(s_auIconResID));
	SetImageList(&m_imageList,LVSIL_SMALL);

d283 1
a283 1
						EnumClientListIcons	enumClientIcon;
d285 1
a285 34
					//	Display pClient icon
						switch (pClient->GetClientSoft())
						{
							case SO_AMULE:
								enumClientIcon = CL_ICON_AMULE;
								break;
							case SO_LMULE:
								enumClientIcon = CL_ICON_LMULE;
								break;
							case SO_SHAREAZA:
								enumClientIcon = CL_ICON_SHAREAZA;
								break;
							case SO_EDONKEYHYBRID:
								enumClientIcon = CL_ICON_EDONKEYHYBRID;
								break;
							case SO_MLDONKEY:
								enumClientIcon = CL_ICON_MLDONKEY;
								break;
							case SO_EMULE:
							case SO_OLDEMULE:
								if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) != IS_IDENTIFIED)
									enumClientIcon = CL_ICON_SECUREHASH;
								else
									enumClientIcon = CL_ICON_COMPROT;
								break;
							case SO_EDONKEY:
								enumClientIcon = CL_ICON_NORMAL;
								break;
							default:
								enumClientIcon = CL_ICON_UNKNOWN;
								break;
						}
						m_imageList.Draw(dc, enumClientIcon, point, ILD_TRANSPARENT);
					//	Display any Extra Overlay icons
d287 1
a287 1
							m_imageList.Draw(dc, CL_ICON_BANNED_ONLY, point, ILD_TRANSPARENT);
d289 1
a289 1
							m_imageList.Draw(dc, CL_ICON_FRIEND_ONLY, point, ILD_TRANSPARENT);
d291 4
a294 1
							m_imageList.Draw(dc, CL_ICON_CREDIT_ONLY, point, ILD_TRANSPARENT);
d296 1
d302 1
a302 1
							r2.left += 42;
a303 2
						else
							r2.left += 20;
d307 1
d309 1
a309 3
							iWidth += 42;
						else
							iWidth += 20;
@


1.86
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@d74 12
d88 1
a88 1
	ilDummyImageList.Create(1, 17,ILC_COLOR32 | ILC_MASK, 1, 1);
d97 2
a98 16
	InsertColumn(CLCOL_USERNAME,GetResString(IDS_QL_USERNAME),LVCFMT_LEFT,150,0);
	InsertColumn(CLCOL_UPLOADSTATUS,GetResString(IDS_CL_UPLOADSTATUS),LVCFMT_LEFT,100,1);
	InsertColumn(CLCOL_TRANSFERREDUP,GetResString(IDS_CL_TRANSFUP),LVCFMT_LEFT,100,2);
	InsertColumn(CLCOL_DOWNLOADSTATUS,GetResString(IDS_CL_DOWNLSTATUS),LVCFMT_LEFT,100,3);
	InsertColumn(CLCOL_TRANSFERREDDOWN,GetResString(IDS_CL_TRANSFDOWN),LVCFMT_LEFT,100,4);
	InsertColumn(CLCOL_COUNTRY,GetResString(IDS_COUNTRY),LVCFMT_LEFT,150,5);

	CString		strColTemp;

	strColTemp = GetResString(IDS_CD_CSOFT);
	strColTemp.Remove(':');
	InsertColumn(CLCOL_CLIENTSOFTWARE,strColTemp,LVCFMT_LEFT,120,5);
	InsertColumn(CLCOL_CONNECTEDTIME,GetResString(IDS_CONNECTED),LVCFMT_LEFT,80,6);
	strColTemp = GetResString(IDS_CD_UHASH);
	strColTemp.Remove(':');
	InsertColumn(CLCOL_USERHASH,strColTemp,LVCFMT_LEFT,210,7);
@


1.85
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d46 1
d48 1
a48 9
//	Refresh the list every 10 secs
	m_hTimer = ::SetTimer( NULL,											// Window to associate with
						   NULL,											// ID of timer (ignored if window = null)
						   30000,											// Time out duration
						   (TIMERPROC)CClientListCtrl::ListUpdateTimer);	// Proc to run
	if (!m_hTimer)
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(RGB_LOG_ERROR + _T("%s: Fatal Error, failed to create Timer"), __FUNCTION__);

	SetGeneralPurposeFind(true);
d54 1
d235 3
a237 9
//	There is some type of timing issue here.. If you click on item in the queue or upload and leave
//	the focus on it when you exit the cient, it breaks on line 854 of emuleDlg.cpp..
//	I added this IsRunning() check to this function and the DrawItem method and
//	this seems to keep it from crashing. This is not the fix but a patch until
//	someone points out what is going wrong.. Also, it will still assert in debug mode..
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
		return;
	if (pClient == NULL)
		return;
d239 2
a240 9
	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = reinterpret_cast<LPARAM>(pClient);

	sint16		iResult = FindItem(&find);

	if (iResult != -1)
		Update(iResult);
d556 1
a556 1
			CClientList::ClientVector	   *pvecDirtyClients = g_eMuleApp.m_pClientList->GetDirtyClients();
d560 3
a562 1
				int		iNumDirtyClients = pvecDirtyClients->size();
d564 1
a564 1
				for (int i = 0; i < iNumDirtyClients; i++)
d566 9
a574 1
					UpdateClient((*pvecDirtyClients)[i]);
d578 2
a654 5
	menuClient.AppendMenu(MF_SEPARATOR);
	menuClient.AppendMenu( MF_STRING |
		((g_eMuleApp.m_pGlobPrefs->GetUpdateKnownList()) ? MF_CHECKED : MF_UNCHECKED),
		MP_UPDATEQQUEUE, GetResString(IDS_UPDATEQUEUE) );

a713 8
	switch(wParam)
	{
		case MP_UPDATEQQUEUE:
		{
			g_eMuleApp.m_pGlobPrefs->SetUpdateKnownList(!g_eMuleApp.m_pGlobPrefs->GetUpdateKnownList());
			break;
		}
	}
d1044 12
a1055 2
// Refresh the queue every 10 secs
void CALLBACK CClientListCtrl::ListUpdateTimer(HWND hwnd, UINT uiMsg, UINT idEvent, DWORD dwTime)
d1057 1
a1057 8
// 	Don't do anything if the app is shutting down - can cause unhandled exceptions
	if ((g_eMuleApp.m_pClientList == NULL) || !g_eMuleApp.m_pdlgEmule->IsRunning() || !g_eMuleApp.m_pGlobPrefs->GetUpdateKnownList())
		return;

	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.DeleteAllItems();

	int					i = 0;
	CUpDownClient	   *pClient;
d1059 1
a1059 1
	for ( POSITION pos = g_eMuleApp.m_pClientList->m_clientList.GetHeadPosition(); pos != NULL; )
d1061 3
a1063 1
		pClient = g_eMuleApp.m_pClientList->m_clientList.GetNext(pos);
d1065 1
a1065 4
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.InsertItem(LVIF_TEXT|LVIF_PARAM,i,LPSTR_TEXTCALLBACK,0,0,0,reinterpret_cast<LPARAM>(pClient));
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
		i++;
	}
@


1.84
log
@Improved string processing.
@
text
@d53 1
a53 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Fatal Error, failed to create Timer"), __FUNCTION__);
@


1.83
log
@Faster list header localizations.
@
text
@d294 1
d400 1
a400 1
							strBuffer = GetResString(IDS_ONQUEUE);
d403 1
a403 1
							strBuffer = GetResString(IDS_CL_PENDING);
d406 1
a406 1
							strBuffer = GetResString(IDS_CL_LOW2LOW);
d409 1
a409 1
							strBuffer = GetResString(IDS_BANNED);
d412 1
a412 1
							strBuffer = GetResString(IDS_ERRORLIKE);
d415 1
a415 1
							strBuffer = GetResString(IDS_CONNECTING);
d418 1
a418 1
							strBuffer = GetResString(IDS_CONNVIASERVER);
d421 1
a421 1
							strBuffer = GetResString(IDS_TRANSFERRING);
d424 2
a425 1
							strBuffer.Empty();
d427 2
d436 1
a436 1
						strBuffer.Empty();
d444 1
a444 1
							strBuffer = GetResString(IDS_CONNECTING);
d447 1
a447 1
							strBuffer = GetResString(IDS_ASKING);
d450 1
a450 1
							strBuffer = GetResString(IDS_CONNVIASERVER);
d453 1
a453 4
							if (pClient->IsRemoteQueueFull())
								strBuffer = GetResString(IDS_QUEUEFULL);
							else
								strBuffer = GetResString(IDS_ONQUEUE);
d456 1
a456 1
							strBuffer = GetResString(IDS_TRANSFERRING);
d459 1
a459 1
							strBuffer = GetResString(IDS_RECHASHSET);
d462 1
a462 1
							strBuffer = GetResString(IDS_NONEEDEDPARTS);
d465 1
a465 1
							strBuffer = GetResString(IDS_NOCONNECTLOW2LOW);
d468 1
a468 1
							strBuffer = GetResString(IDS_TOOMANYCONNS);
d471 2
a472 1
							strBuffer.Empty();
d474 2
d483 1
a483 1
						strBuffer.Empty();
@


1.82
log
@Fixed Client & Upload lists initial sort direction when sort settings aren't in use.
@
text
@d144 16
a159 2
	CHeaderCtrl	   *pHeaderCtrl = GetHeaderCtrl();
	HDITEM			hdi;
d163 1
a163 1
	if (pHeaderCtrl->GetItemCount() != 0)
d165 3
a167 48
		CString		strRes;

		strRes = GetResString(IDS_QL_USERNAME);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_USERNAME, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_CL_UPLOADSTATUS);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_UPLOADSTATUS, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_CL_TRANSFUP);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_TRANSFERREDUP, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_CL_DOWNLSTATUS);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_DOWNLOADSTATUS, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_CL_TRANSFDOWN);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_TRANSFERREDDOWN, &hdi);
		strRes.ReleaseBuffer();

		strRes=GetResString(IDS_CD_CSOFT);
		strRes.Remove(':');
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_CLIENTSOFTWARE, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_CONNECTED);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_CONNECTEDTIME, &hdi);
		strRes.ReleaseBuffer();

		strRes=GetResString(IDS_CD_UHASH);
		strRes.Remove(':');
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_USERHASH, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_COUNTRY);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_COUNTRY, &hdi);
		strRes.ReleaseBuffer();
d484 1
a484 1
					strBuffer.Format(_T("%s"),GetClientNameAndVersionString(pClient));
@


1.81
log
@Fixed list sorting direction while switching <thanks xrmb>; minor optimization.
@
text
@d123 1
a123 2
		int		iSortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_CLIENTLIST);
		bool	bSortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_CLIENTLIST);
d125 2
a126 2
		SetSortArrow(iSortItem, bSortAscending);
		SortItems(SortProc, iSortItem + (bSortAscending ? MLC_SORTASC : MLC_SORTDESC));
@


1.80
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d45 1
a45 1
	memzero(&m_bSortAscending, sizeof(m_bSortAscending));
d139 1
a139 1
	SortItems(&SortProc, iSortCode);
d765 1
a765 1
void CClientListCtrl::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
d767 12
a778 7
	NM_LISTVIEW		*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);

//	If it's a second click on the same column then reverse the sort order,
//	otherwise sort the new column in ascending order.
	m_bSortAscending[pNMListView->iSubItem] = !m_bSortAscending[pNMListView->iSubItem];
	SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem]);
	SortItems(SortProc, pNMListView->iSubItem + ((m_bSortAscending[pNMListView->iSubItem]) ? MLC_SORTASC : MLC_SORTDESC));
a779 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_CLIENTLIST, pNMListView->iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_CLIENTLIST, m_bSortAscending[pNMListView->iSubItem]);
@


1.79
log
@Final DebugLog formating and changes
@
text
@d75 1
a75 1
		IDI_CDONKEY,		// 8
d361 2
a362 2
							case SO_CDONKEY:
								enumClientIcon = CL_ICON_CDONKEY;
@


1.78
log
@DebugLog formating and changes
@
text
@d53 1
a53 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.77
log
@Show default context menu item in client lists (thanks xrmb for the idea).
@
text
@a17 3
// ClientListCtrl.cpp : implementation file
//

a39 2
// CClientListCtrl

d48 3
a50 3
	m_hTimer = ::SetTimer( NULL,				// Window to associate with
						   NULL,				// ID of timer (ignored if window = null)
						   30000,				// Time out duration
a255 1
//g_eMuleApp.AddDebugLogLine(false, _T("%s: Removing client %s addr(0x%08x) from client list ctrl"),__FUNCTION__,pClient->GetUserName(),pClient);
d358 1
a358 1
						// Display pClient icon
d391 1
a391 1
						//	Display any Extra Overlay icons
a652 4

// CClientListCtrl message handlers

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d767 1
a767 1
	NM_LISTVIEW		*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR); //<= Yeeeech
d770 1
a770 1
//		otherwise sort the new column in ascending order.
d812 2
a813 1
				iSortMod = 1;		//empty entries at the bottom in any case
d819 2
a820 1
				iSortMod = 1;		//sort allways in ascending order
a828 1
		//eklmn: we are using a 64 bit variables for the credits
d830 1
a856 1
		//eklmn: we are using a 64 bit variables for the credits
d858 1
d904 1
a904 1
	//eklmn: reset selection in DL list
d1073 1
a1073 1
//		refresh dirty clients and then immediately returns.
d1092 1
a1092 1
	// Don't do anything if the app is shutting down - can cause unhandled exceptions
@


1.76
log
@Totally reworked country information feature to minimaze memory usage.
@
text
@d705 1
@


1.75
log
@added tooltips to the Server list
@
text
@d409 1
a409 1
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryFlagIndex(), point, ILD_NORMAL);
@


1.74
log
@Find in lists
@
text
@a527 8
					if (pClient->m_pRequestSocket != NULL)
					{
						if (pClient->m_pRequestSocket->IsConnected())
						{
							strBuffer = GetResString(IDS_YES);
							break;
						}
					}
d529 1
a529 1
					strBuffer = GetResString(IDS_NO);
@


1.73
log
@Middle mouse button click opens details of selected client or file
@
text
@d59 2
@


1.72
log
@Improve image list filling.
@
text
@d1149 27
@


1.71
log
@Deleted icon top & bottom transparent margins to save memory & speed up drawing;
Better drawing method.
@
text
@d68 15
d89 1
a89 4
	for (int i = 0; i < ULCOL_NUMCOLUMNS; i++)
	{
		m_iColumnMaxWidths[i] = 0;
	}
d113 1
a113 14
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));			// 0
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));		// 1
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));		// 2
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  // 3
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));    // 4
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));    // 5
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));    // 6
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  		// 7
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  		// 8
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  		// 9
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  		// 10
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  	// 11

	LoadImgLstIcon(NULL,0,0);
@


1.70
log
@minor changes
@
text
@d407 2
a408 1
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
@


1.69
log
@added tooltips in On Queue & Known Clients lists
@
text
@a402 1
						r2.left += 20;
d408 1
a408 1
							r2.left += 22;
d410 2
@


1.68
log
@increased icon/username spacing to 2 pixels + minor improvement
@
text
@a403 1
						point.x += 20;
d407 1
@


1.67
log
@no longer loading mid size names + some small changes
@
text
@d404 1
d408 2
a409 4
							POINT		point2 = {r2.left, r2.top + 1};

							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point2, CSize(18,16), CPoint(0,0), ILD_NORMAL);
							r2.left += 20;
d415 1
a415 1
							iWidth += 40;
d421 1
a421 1
					if (strBuffer == _T(""))
d1003 1
a1003 1
						if (pClient->GetUserName() != _T("") && pDispInfo->item.cchTextMax > 0)
@


1.66
log
@reduced the space between flag and user name + minor fix in client details
@
text
@d545 1
a545 1
					strBuffer = pClient->GetCountryName(true);
@


1.65
log
@moved the country icon back near the client type icon
@
text
@d356 2
d360 1
a360 1
						POINT				point = {r.left, r.top+1};
a394 1

d396 1
a396 2

					//	Display any Extra Overlay icons
d403 1
a403 2

						r.left += 20;
d407 1
a407 1
							POINT		point2 = {r.left, r.top + 1};
d410 1
a410 1
							r.left += 25;
d416 1
a416 1
							iWidth += 45;
d421 2
a422 1
					if (pClient->GetUserName() == _T(""))
d424 1
a424 3
					else
						strBuffer = pClient->GetUserName();
					dc->DrawText(strBuffer,strBuffer.GetLength(),&r, iCalcFlag);
d427 1
a427 5
						iWidth += (r.right - r.left + 1);
					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
						r.left -= 45;
					else
						r.left -= 20;
@


1.64
log
@minor changes
@
text
@d405 8
d415 6
a420 1
						iWidth += 20;
d430 4
a433 1
					r.left -= 20;
d551 1
a551 17
					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
					{
						if (!bMeasuring)
						{

							POINT point = {r.left,r.top + 1};
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
							strBuffer = pClient->GetCountryName(true);
							r.left += 25;
							dc->DrawText(strBuffer,strBuffer.GetLength(),&r, iCalcFlag);
							r.left -= 25;
						}
						else
							iWidth += 25;
					}
					else
						iWidth += r.right - r.left + 1;
d555 1
a555 1
			if (iColumn != CLCOL_USERNAME && iColumn != CLCOL_COUNTRY)
@


1.63
log
@minor changes
@
text
@d551 1
a551 1
						iWidth += r.right-r.left+1;
d557 1
a557 3
				RECT		r2 = r;

				dc->DrawText(strBuffer,strBuffer.GetLength(),&r2,iCalcFlag);
d559 1
a559 1
					iWidth += r2.right - r2.left + 1;
@


1.62
log
@Please, DO NOT alter column order. This messes with users column customization and don't bring a standard as people likings are different.
@
text
@d83 5
a87 5
	InsertColumn(CLCOL_UPLOADSTATUS,GetResString(IDS_CL_UPLOADSTATUS),LVCFMT_LEFT,100,2);
	InsertColumn(CLCOL_TRANSFERREDUP,GetResString(IDS_CL_TRANSFUP),LVCFMT_LEFT,100,3);
	InsertColumn(CLCOL_DOWNLOADSTATUS,GetResString(IDS_CL_DOWNLSTATUS),LVCFMT_LEFT,100,4);
	InsertColumn(CLCOL_TRANSFERREDDOWN,GetResString(IDS_CL_TRANSFDOWN),LVCFMT_LEFT,100,5);
	InsertColumn(CLCOL_COUNTRY,GetResString(IDS_COUNTRY),LVCFMT_LEFT,150,1);
@


1.61
log
@Added "Country" column in Uploads/On Queue/Known Clients lists
@
text
@a82 1
	InsertColumn(CLCOL_COUNTRY,GetResString(IDS_COUNTRY),LVCFMT_LEFT,150,1);
d87 1
a162 5
		strRes = GetResString(IDS_COUNTRY);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(CLCOL_COUNTRY, &hdi);
		strRes.ReleaseBuffer();

d199 5
a419 21
				case CLCOL_COUNTRY:
				{
					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
					{
						if (!bMeasuring)
						{

							POINT point = {r.left,r.top + 1};
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
							strBuffer = pClient->GetCountryName(true);
							r.left += 25;
							dc->DrawText(strBuffer,strBuffer.GetLength(),&r, iCalcFlag);
							r.left -= 25;
						}
						else
							iWidth += 25;
					}
					else
						iWidth += r.right-r.left+1;
					break;
				}
d529 1
d532 22
@


1.60
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d83 5
a87 4
	InsertColumn(CLCOL_UPLOADSTATUS,GetResString(IDS_CL_UPLOADSTATUS),LVCFMT_LEFT,100,1);
	InsertColumn(CLCOL_TRANSFERREDUP,GetResString(IDS_CL_TRANSFUP),LVCFMT_LEFT,100,2);
	InsertColumn(CLCOL_DOWNLOADSTATUS,GetResString(IDS_CL_DOWNLSTATUS),LVCFMT_LEFT,100,3);
	InsertColumn(CLCOL_TRANSFERREDDOWN,GetResString(IDS_CL_TRANSFDOWN),LVCFMT_LEFT,100,4);
d163 5
a412 14

					SIZE TextSize;

					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
					{
						POINT point2 = {r.left,r.top + 1};
						g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point2, CSize(18,16), CPoint(0,0), ILD_NORMAL);
						r.left += 20;
						GetTextExtentPoint32(dc, _T("N/A  "), 5, &TextSize);
						CString strBuffer2 = pClient->GetCountryName();
						strBuffer2 += _T("  ");
						dc->DrawText(strBuffer2,strBuffer2.GetLength(),&r, iCalcFlag);
						r.left += TextSize.cx;
					}
d417 9
d427 10
a436 2
					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
						r.left -= (40 + TextSize.cx);
d438 1
a438 1
						r.left -= 20;
d553 1
a553 1
			if (iColumn != CLCOL_USERNAME)
d823 20
@


1.59
log
@Minor context menu fix
@
text
@d27 1
d408 1
a408 1
					RECT	r2 = r;
d410 12
a421 1
					dc->DrawText(strBuffer,strBuffer.GetLength(),&r2,iCalcFlag);
d424 1
a424 1
						iWidth += (r2.right - r2.left + 1);
d426 4
a429 1
					r.left -=20;
@


1.58
log
@replaced "TrackPopupMenu" to "TrackPopupMenuEx"
@
text
@d686 1
a686 2
	menuClient.AppendMenu( dwMenuFlags | ((pClient->IsBanned() ? MF_ENABLED : MF_GRAYED)),
		MP_UNBAN, GetResString(IDS_UNBAN) );
@


1.57
log
@SetMenu shouldn't be called for popup menu (removed)
@
text
@d694 1
a694 1
	menuClient.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.56
log
@list processing and other optimizations
@
text
@a693 1
	SetMenu(reinterpret_cast<CMenu*>(&menuClient));
@


1.55
log
@list processing optimization
@
text
@d51 5
a55 5
	// Refresh the list every 10 secs
	m_hTimer = ::SetTimer(NULL,				// Window to associate with
						NULL,				// ID of timer (ignored if window = null)
						30000,				// Time out duration
						(TIMERPROC)CClientListCtrl::ListUpdateTimer);	// Proc to run
d136 1
a136 1
	int iSortColumn = (iSortCode & MLC_COLUMNMASK);
d138 1
a138 1
	bool bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
d147 1
a147 1
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
d181 2
a182 1
		strRes=GetResString(IDS_CD_CSOFT);strRes.Remove(':');
d192 2
a193 1
		strRes=GetResString(IDS_CD_UHASH);strRes.Remove(':');
d204 3
a206 2
	int			i = 0;
	CString		strTemp;
d208 1
a208 3
	for ( POSITION pos = g_eMuleApp.m_pClientList->m_clientList.GetHeadPosition();
		  pos != NULL;
		  g_eMuleApp.m_pClientList->m_clientList.GetNext(pos) )
d210 1
a210 1
		CUpDownClient	*pClient = g_eMuleApp.m_pClientList->m_clientList.GetAt(pos);
d228 1
a228 1
	if (iResult == (-1) && pClient)
d242 1
a242 1
	if (!pClient)
d278 1
a278 1
	if (!pClient)
d304 1
a304 1
	CDC				*odc = CDC::FromHandle(lpDrawItemStruct->hDC);
d306 3
a308 1
	if( odc && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED )){
d317 7
a323 7
	CUpDownClient	*pClient = (CUpDownClient*)lpDrawItemStruct->itemData;
	CMemDC			dc(CDC::FromHandle(lpDrawItemStruct->hDC),&CRect(lpDrawItemStruct->rcItem));
	CFont			*pOldFont = dc.SelectObject(GetFont());
	COLORREF		crOldTextColor = dc.SetTextColor(m_crWindowText);
	int				iWidth = 0;
	bool			bMeasuring = (m_iMeasuringColumn >= 0);
	UINT			iCalcFlag = bMeasuring ? (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_CALCRECT) : (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
d331 1
a331 1
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
d351 2
a352 1
						POINT	point = {r.left, r.top+1};
d358 1
a358 1
								m_imageList.Draw(dc, CL_ICON_CDONKEY, point, ILD_TRANSPARENT);
d361 1
a361 1
								m_imageList.Draw(dc, CL_ICON_LMULE, point, ILD_TRANSPARENT);
d364 1
a364 1
								m_imageList.Draw(dc, CL_ICON_SHAREAZA, point, ILD_TRANSPARENT);
d367 1
a367 1
								m_imageList.Draw(dc, CL_ICON_EDONKEYHYBRID, point, ILD_TRANSPARENT);
d370 1
a370 1
								m_imageList.Draw(dc, CL_ICON_MLDONKEY, point, ILD_TRANSPARENT);
d375 1
a375 1
									m_imageList.Draw(dc, CL_ICON_SECUREHASH, point, ILD_TRANSPARENT);
d377 1
a377 1
									m_imageList.Draw(dc, CL_ICON_COMPROT, point, ILD_TRANSPARENT);
d380 1
a380 1
								m_imageList.Draw(dc, CL_ICON_NORMAL, point, ILD_TRANSPARENT);
d383 1
a383 1
								m_imageList.Draw(dc, CL_ICON_UNKNOWN, point, ILD_TRANSPARENT);
d387 2
d1075 2
a1076 1
	int			i = 0;
d1078 1
a1078 3
	for ( POSITION pos = g_eMuleApp.m_pClientList->m_clientList.GetHeadPosition();
		  pos != NULL;
		  g_eMuleApp.m_pClientList->m_clientList.GetNext(pos) )
d1080 1
a1080 1
		CUpDownClient	*pClient = g_eMuleApp.m_pClientList->m_clientList.GetAt(pos);
@


1.54
log
@minor memory copy improvements
@
text
@d396 2
a397 2
					if (pClient->GetUserName()=="")
						strBuffer.Format("(%s)", GetResString(IDS_UNKNOWN));
d684 1
a684 1
	menuClient.AppendMenu( MF_STRING | 
d962 1
a962 1
						if (pClient->GetUserName() != "" && pDispInfo->item.cchTextMax > 0)
@


1.53
log
@Improved context menu creation
@
text
@a317 1
	RECT			r;
d325 1
a325 2
	memcpy2(&r,&lpDrawItemStruct->rcItem,sizeof(RECT));

d546 1
a546 2
		RECT		outline_rec;
		memcpy2(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
@


1.52
log
@Service name changed
@
text
@a649 4
	UINT			iMenuFlags = MF_STRING|MF_GRAYED;
	CTitleMenu*		pMenuClient = NULL;
	CUpDownClient	*pClient = NULL;

d652 4
a655 1
	POSITION posSelClient = GetFirstSelectedItemPosition();
d659 1
a665 1
		iMenuFlags = MF_STRING;
d668 6
a674 4
	pMenuClient = new CTitleMenu();
	pMenuClient->CreatePopupMenu();
	pMenuClient->AddMenuTitle(GetResString(IDS_CLIENTLIST));
	pMenuClient->AppendMenu(iMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails),SSP_TAB_PREFIX));
d676 14
a689 12
		pMenuClient->AppendMenu(iMenuFlags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend),SSP_TAB_PREFIX));
	else
		pMenuClient->AppendMenu(iMenuFlags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend),SSP_TAB_PREFIX));
	pMenuClient->AppendMenu(iMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage),SSP_TAB_PREFIX));
	pMenuClient->AppendMenu(iMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles),SSP_TAB_PREFIX));
	pMenuClient->AppendMenu(iMenuFlags,MP_UNBAN, GetResString(IDS_UNBAN));
	if (pClient)
		pMenuClient->EnableMenuItem(MP_UNBAN,(pClient->IsBanned() ? MF_ENABLED:MF_GRAYED));

	pMenuClient->AppendMenu(MF_SEPARATOR);
	pMenuClient->AppendMenu(MF_STRING,MP_UPDATEQQUEUE, GetResString(IDS_UPDATEQUEUE));
	pMenuClient->CheckMenuItem(MP_UPDATEQQUEUE,(g_eMuleApp.m_pGlobPrefs->GetUpdateKnownList() ? MF_CHECKED:MF_UNCHECKED));
d691 2
a692 2
	SetMenu(reinterpret_cast<CMenu*>(pMenuClient));
	pMenuClient->TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
d694 1
a694 1
	pMenuClient->DestroyMenu();
a696 2

	safe_delete(pMenuClient);
@


1.51
log
@Formatting, comments, and name changes.
Removed old #defines
@
text
@d522 1
a522 1
					strBuffer = md4str(pClient->GetUserHash());
@


1.50
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@a591 16
#ifdef OLD
		case WM_CL_REFRESHCLIENT:
		{
			CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(lParam);
//g_eMuleApp.AddDebugLogLine(false, _T("%s: Refreshing client (addr 0x%08X)"),__FUNCTION__,pClient);
		//
		//	Because we're handling this asynchronously, the client may have already been deleted.
		//		If so it won't be in the client list anymore because the client destructor removes it.
			if (g_eMuleApp.m_pClientList->IsValidClient(pClient))
			{
				UpdateClient(pClient);
			}
			bHandled = true;
			break;
		}
#endif OLD
@


1.49
log
@forgotten name changes :o) don't u compile b4 commit, morevit?
@
text
@d49 1
a49 1
	memset2(&m_bSortAscending, 0, sizeof(m_bSortAscending));
@


1.48
log
@Formatting, comments, and name changes.
@
text
@d941 1
a941 1
		POSITION		pos = GetFirstSelectedItemPosition();
@


1.47
log
@better sort Proc, unknow things are kept at the end of the list
@
text
@d920 1
a920 1
			CClientDetails dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
d941 1
a941 1
		POSITION posSelClient = GetFirstSelectedItemPosition();
d943 1
a943 1
		if(posSelClient == 0)
@


1.46
log
@More Kush changes for localization, minor optimizations and fix for Upload AutoPriority.
@
text
@d808 4
a811 1
				iCompare = (!pClient1->GetUserName()) ? ( (!pClient1->GetUserName())? 0:1) : -1;
d815 2
d834 2
a835 6
				if (pClient1->m_pCredits && !pClient2->m_pCredits)
					iCompare = -iSortMod;
				else if (!pClient1->m_pCredits && pClient2->m_pCredits)
					iCompare = iSortMod;
				else
					iCompare = 0;
d843 2
d862 2
a863 6
				if (pClient1->m_pCredits && !pClient2->m_pCredits)
					iCompare = -iSortMod;
				else if (!pClient1->m_pCredits && pClient2->m_pCredits)
					iCompare = iSortMod;
				else
					iCompare = 0;
d867 1
a867 6
			iCompare = SortClient(pClient1, pClient2, 1);
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2, CLCOL_USERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
d874 1
d876 2
d1052 2
a1053 20
		CString		sName1, sName2;

		try
		{
			sName1 = CString(pClient1->GetUserName());
		}
		catch(...)
		{
			sName1 = _T("");
		}
		try
		{
			sName2 = CString(pClient2->GetUserName());
		}
		catch(...)
		{
			sName2 = _T("");
		}
		if (sName1.IsEmpty() || sName2.IsEmpty())
			iCompare = (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0 : iSortMode) : -1 * iSortMode;
d1055 2
a1056 1
			iCompare = _tcsicmp(sName1, sName2);
d1058 1
a1058 1
	return iCompare * iSortMode;
@


1.45
log
@small corrections & some optimizations
@
text
@d69 1
a69 1
	ilDummyImageList.Create(1, 17,ILC_COLOR32 | ILC_MASK, 1, 1); 
d96 1
a96 1
	
d202 1
a202 1
	int			i = 0; 
d208 1
a208 1
	{ 
d213 1
a213 1
		i++; 
d251 1
a251 1
	
d271 1
a271 1
//	the focus on it when you exit the cient, it breaks on line 854 of emuleDlg.cpp.. 
d351 1
a351 1
		
d409 1
a409 1
					
d662 1
a662 1
	
d671 1
a671 1
	
d677 1
a677 1
		
d684 1
a684 1
	
d699 1
a699 1
	
d706 1
a706 1
	
d774 1
a774 1
} 
d819 1
a819 1
				
d827 9
a835 2
			else 
				iCompare = (!pClient1->m_pCredits) ? ((!pClient2->m_pCredits)? 0:1) : -1;
d849 1
a849 1
				
d857 9
a865 2
			else 
				iCompare = (!pClient1->m_pCredits) ? ( (!pClient2->m_pCredits)? 0:1)  : -1;
d906 1
a906 1
		
d920 1
a920 1
		
d925 2
a926 2
		} 
		else 
d945 1
a945 1
		
d953 1
a953 1
			
d1022 1
a1022 1
			if (plus1 && plus2) 
d1104 1
a1104 1
	
d1107 1
a1107 1
	int			i = 0; 
d1112 1
a1112 1
	{ 
d1117 1
a1117 1
		i++; 
d1132 1
a1132 1
			
@


1.44
log
@Some corrections in shortcut management code to keep new engine hierarchy (thanks to eklmn ;-))
@
text
@d1106 1
a1106 1

d1118 1
a1119 1
		}
d1121 5
a1125 4
		if (iMessage > 0)
		{
			PostMessage(WM_COMMAND, iMessage);
			return TRUE;
d1131 1
@


1.43
log
@solution for selection & clicking (hopefuilly it will be final)
@
text
@d1106 24
@


1.42
log
@Some changes to fix blank infolist even while selecting a file and some GUI issues.
@
text
@d671 2
d674 1
a674 3
	const int 			iClientListIndex = GetSelectionMark();

	if (iClientListIndex != -1)
d676 3
a678 3
		if (GetSelectedCount() > 0)
			iMenuFlags = MF_STRING;
		if (pClient = reinterpret_cast<CUpDownClient*>(GetItemData(iClientListIndex)))
d680 1
a680 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, pClient);
d682 1
d684 1
d716 1
a716 1
	const int iClientListIndex = GetSelectionMark();
d718 1
a718 1
	if (iClientListIndex != (-1))
d720 1
a720 1
		CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(GetItemData(iClientListIndex));
d881 14
d901 1
a901 2
	if(GetFirstSelectedItemPosition() == NULL)
		return;
d903 1
a903 3
	int		iSel = GetSelectionMark();

	if (iSel != -1)
d905 3
a907 3
		CUpDownClient		*pClient = reinterpret_cast<CUpDownClient*>(GetItemData(iSel));

		if (pClient)
d909 1
a909 1
			CClientDetails			dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
d911 4
d930 1
a930 1
		POSITION		pos = GetFirstSelectedItemPosition();
d932 2
a933 2
		if(pos == NULL)
		{			
d938 1
a938 3
			const int iSelClientListIndex = GetSelectionMark();

			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(iSelClientListIndex));
@


1.41
log
@Minor fix on item selection and InfoList update
@
text
@a670 3
	
	if(GetFirstSelectedItemPosition() == NULL)
		return;
@


1.40
log
@refresh an InfoList only if ListCtrl is active
@
text
@d672 3
d888 3
d916 1
a916 1
		const int iSelClientListIndex = GetSelectionMark();
d918 1
a918 1
		if(iSelClientListIndex == -1)
d924 2
@


1.39
log
@Changed the way the preference for update of upload lists is handled
@
text
@d908 1
a908 3
	POSITION		pos = GetFirstSelectedItemPosition();

	if (pos == NULL)
d910 12
a921 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
a922 6
	else
	{
		CUpDownClient		*pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetSelectionMark()));

		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, pClient);
	}	
@


1.38
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d698 4
d759 10
d1065 1
a1065 1
	if ((g_eMuleApp.m_pClientList == NULL) || !g_eMuleApp.m_pdlgEmule->IsRunning() || !g_eMuleApp.m_pGlobPrefs->GetUpdateQueueList())
@


1.37
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d57 1
a57 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(false, RGB_RED + GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.36
log
@Added some colors to the logs...
@
text
@d57 1
a57 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_TIMERCREATEFAILED));
d252 1
a252 1
//g_eMuleApp.AddDebugLogLine(false,_T("%s: Removing client %s addr(0x%08x) from client list ctrl"),__FUNCTION__,pClient->GetUserName(),pClient);
d596 1
a596 1
//g_eMuleApp.AddDebugLogLine(false,_T("%s: Refreshing client (addr 0x%08X)"),__FUNCTION__,pClient);
@


1.35
log
@Added forced update fro Known List.
@
text
@d57 1
a57 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(false, IDS_ERR_TIMERCREATEFAILED);
@


1.34
log
@fixed crash  due context menu, shortcut optimiation & update to UNICODE
@
text
@d50 8
d1047 22
@


1.33
log
@proper InfoList handling
@
text
@d658 3
a660 2
	UINT				iMenuFlags = MF_STRING|MF_GRAYED;
	CUpDownClient		*pClient = NULL;
d662 5
a666 1
	if (GetSelectionMark() != -1)
d670 1
a670 1
		if (pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetSelectionMark())))
d676 4
a679 3
	m_menuClient.CreatePopupMenu();
	m_menuClient.AddMenuTitle(GetResString(IDS_CLIENTLIST));
	m_menuClient.AppendMenu(iMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails)));
d681 1
a681 1
		m_menuClient.AppendMenu(iMenuFlags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
d683 4
a686 4
		m_menuClient.AppendMenu(iMenuFlags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
	m_menuClient.AppendMenu(iMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage)));
	m_menuClient.AppendMenu(iMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles)));
	m_menuClient.AppendMenu(iMenuFlags,MP_UNBAN, GetResString(IDS_UNBAN));
d688 4
a691 1
		m_menuClient.EnableMenuItem(MP_UNBAN,(pClient->IsBanned() ? MF_ENABLED:MF_GRAYED));
d693 5
a697 3
	SetMenu(&m_menuClient);
	m_menuClient.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
	m_menuClient.DestroyMenu();
d702 3
a704 1
	if (GetSelectionMark() != (-1))
d706 1
a706 1
		CUpDownClient		*pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetSelectionMark()));
@


1.32
log
@Correct localization of decimal point & thousands seperator + Correct encoding for Hebrew language in WebServer
@
text
@d240 1
a240 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d667 1
a667 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser(pClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d877 1
a877 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d883 1
a883 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser(pClient);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
@


1.31
log
@Added a function: bool IsRightToLeftLanguage(); + Fixed Hebrew text alignment in Shared Files list + Hebrew translation update
@
text
@d317 1
a317 1
		iCalcFlag = (iCalcFlag | DT_RTLREADING);
@


1.30
log
@Fixed Hebrew text alignment in Client, Downlod, Queue & Upload lists to Right-To-Left
@
text
@d316 1
a316 1
	if ( g_eMuleApp.m_pGlobPrefs->GetLanguageID() == 1037 )
@


1.29
log
@Change to shortcut management code (it's easier to add an action now) / Added a lot of actions to shortcut management / Added some keys to shortcut management
@
text
@d316 3
@


1.28
log
@fixed sorting by "ClientSoftware"
@
text
@d672 1
a672 1
	m_menuClient.AppendMenu(iMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientDetailsShortcutCode()));
d674 1
a674 1
		m_menuClient.AppendMenu(iMenuFlags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));
d676 3
a678 3
		m_menuClient.AppendMenu(iMenuFlags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));
	m_menuClient.AppendMenu(iMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadSendMessageClientShortcutCode()));
	m_menuClient.AppendMenu(iMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientFilesShortcutCode()));
@


1.27
log
@Fixed selection background color on Uploads, On Queue & Known Clients lists and some other fixes
@
text
@d817 1
a817 1
			if (iCompare)
@


1.26
log
@1) sorting update
2) double-click issue
@
text
@d298 8
a305 2

	odc->SetBkColor(GetBkColor());
d310 1
d346 1
a346 1
								m_imageList.Draw(dc, CL_ICON_CDONKEY, point, ILD_NORMAL);
d349 1
a349 1
								m_imageList.Draw(dc, CL_ICON_LMULE, point, ILD_NORMAL);
d352 1
a352 1
								m_imageList.Draw(dc, CL_ICON_SHAREAZA, point, ILD_NORMAL);
d355 1
a355 1
								m_imageList.Draw(dc, CL_ICON_EDONKEYHYBRID, point, ILD_NORMAL);
d358 1
a358 1
								m_imageList.Draw(dc, CL_ICON_MLDONKEY, point, ILD_NORMAL);
d363 1
a363 1
									m_imageList.Draw(dc, CL_ICON_SECUREHASH, point, ILD_NORMAL);
d365 1
a365 1
									m_imageList.Draw(dc, CL_ICON_COMPROT, point, ILD_NORMAL);
d368 1
a368 1
								m_imageList.Draw(dc, CL_ICON_NORMAL, point, ILD_NORMAL);
d371 1
a371 1
								m_imageList.Draw(dc, CL_ICON_UNKNOWN, point, ILD_NORMAL);
a538 2
		CBrush		*pOldBrush;

d543 2
a544 4

		CBrush		gdiBrush(GetBkColor());

		pOldBrush = dc->SelectObject(&gdiBrush);	//eklmn: select a new brush
d546 1
d555 1
a555 2

			dc->SelectObject(&fl_Brush);	//eklmn: select a new brush
d561 1
a561 1
			dc->SelectObject(&nfl_Brush);	//eklmn: select a new brush
d565 1
a565 1
		dc->SelectObject(pOldBrush);		//eklmn: recover an old brush
a568 1
	{
d570 2
a571 1
	}
@


1.25
log
@Formatting, comments, and name changes.
@
text
@d127 4
a130 1
	int		iCurrentSortItem = (iSortCode & MLC_SORTDESC) == 0 ? iSortCode : iSortCode - MLC_SORTDESC;
d132 1
a132 1
	SetSortArrow(iCurrentSortItem,(iSortCode & MLC_SORTDESC) == 0);
d134 1
d751 2
a752 2
	CUpDownClient	*pClient1 = reinterpret_cast<CUpDownClient*>(lParam1);
	CUpDownClient	*pClient2 = reinterpret_cast<CUpDownClient*>(lParam2);
d754 8
a761 1
	switch (lParamSort)
d765 1
a765 3
				return _tcsicmp(pClient1->GetUserName(), pClient2->GetUserName());
			else if (pClient1->GetUserName())
				return 1;
d767 2
a768 8
				return -1;
		case CLCOL_USERNAME + MLC_SORTDESC:
			if (pClient1->GetUserName() && pClient2->GetUserName())
				return _tcsicmp(pClient2->GetUserName(), pClient1->GetUserName());
			else if (pClient2->GetUserName())
				return 1;
			else
				return -1;
d770 3
a772 3
			return pClient1->GetUploadState()-pClient2->GetUploadState();
		case CLCOL_UPLOADSTATUS + MLC_SORTDESC:
			return pClient2->GetUploadState()-pClient1->GetUploadState();
d775 17
a791 3
				return pClient1->m_pCredits->GetUploadedTotal()-pClient2->m_pCredits->GetUploadedTotal();
			else if (!pClient1->m_pCredits)
				return 1;
d793 3
a795 34
				return -1;
		case CLCOL_TRANSFERREDUP + MLC_SORTDESC:
			if (pClient1->m_pCredits && pClient2->m_pCredits)
				return pClient2->m_pCredits->GetUploadedTotal()-pClient1->m_pCredits->GetUploadedTotal();
			else if (!pClient1->m_pCredits)
				return 1;
			else
				return -1;
		case CLCOL_DOWNLOADSTATUS:
		    if (pClient1->GetDownloadState() == pClient2->GetDownloadState())
		    {
			    if (pClient1->IsRemoteQueueFull() && pClient2->IsRemoteQueueFull())
				    return 0;
			    else if (pClient1->IsRemoteQueueFull())
				    return 1;
			    else if (pClient2->IsRemoteQueueFull())
				    return -1;
			    else
				    return 0;
		    }
			return pClient1->GetDownloadState() - pClient2->GetDownloadState();
		case CLCOL_DOWNLOADSTATUS + MLC_SORTDESC:
		    if (pClient2->GetDownloadState() == pClient1->GetDownloadState())
		    {
			    if (pClient2->IsRemoteQueueFull() && pClient1->IsRemoteQueueFull())
				    return 0;
			    else if (pClient2->IsRemoteQueueFull())
				    return 1;
			    else if (pClient1->IsRemoteQueueFull())
				    return -1;
			    else
				    return 0;
		    }
			return pClient2->GetDownloadState()-pClient1->GetDownloadState();
d798 14
a811 12
				return pClient1->m_pCredits->GetDownloadedTotal()-pClient2->m_pCredits->GetDownloadedTotal();
			else if (!pClient1->m_pCredits)
				return 1;
			else
				return -1;
		case CLCOL_TRANSFERREDDOWN + MLC_SORTDESC:
			if (pClient1->m_pCredits && pClient2->m_pCredits)
				return pClient2->m_pCredits->GetDownloadedTotal()-pClient1->m_pCredits->GetDownloadedTotal();
			else if (!pClient1->m_pCredits)
				return 1;
			else
				return -1;
d813 7
a819 3
			return SortClient(pClient1, pClient2, 1);
		case CLCOL_CLIENTSOFTWARE + MLC_SORTDESC:
			return SortClient(pClient1, pClient2, -1);
d823 1
a823 3
				return pClient1->m_pRequestSocket->IsConnected() - pClient2->m_pRequestSocket->IsConnected();
			else if (pClient1->m_pRequestSocket == NULL)
				return -1;
d825 1
d827 1
a827 10
				return 1;
		case CLCOL_CONNECTEDTIME + MLC_SORTDESC:
#ifdef OLD_SOCKETS_ENABLED
			if (pClient1->m_pRequestSocket != NULL && pClient2->m_pRequestSocket != NULL)
				return pClient2->m_pRequestSocket->IsConnected() - pClient1->m_pRequestSocket->IsConnected();
			else if (pClient2->m_pRequestSocket == NULL)
				return -1;
			else
#endif //OLD_SOCKETS_ENABLED
				return 1;
d829 2
a830 3
			return memcmp(pClient1->GetUserHash(), pClient2->GetUserHash(), 16);
		case CLCOL_USERHASH + MLC_SORTDESC:
			return memcmp(pClient2->GetUserHash(), pClient1->GetUserHash(), 16);
d834 2
@


1.24
log
@*** empty log message ***
@
text
@d665 1
a665 1
	m_menuClient.AppendMenu(iMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientDetailsShortcutCode()));	// DropF - Keyboard Shortcuts
d667 1
a667 1
		m_menuClient.AppendMenu(iMenuFlags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));	// DropF - Keyboard Shortcuts
d669 3
a671 3
		m_menuClient.AppendMenu(iMenuFlags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));	// DropF - Keyboard Shortcuts
	m_menuClient.AppendMenu(iMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadSendMessageClientShortcutCode()));	// DropF - Keyboard Shortcuts
	m_menuClient.AppendMenu(iMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientFilesShortcutCode()));	// DropF - Keyboard Shortcuts
@


1.23
log
@Formatting, comments, and name changes.
@
text
@d665 1
a665 1
	m_menuClient.AppendMenu(iMenuFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
d667 1
a667 1
		m_menuClient.AppendMenu(iMenuFlags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d669 3
a671 3
		m_menuClient.AppendMenu(iMenuFlags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
	m_menuClient.AppendMenu(iMenuFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG));
	m_menuClient.AppendMenu(iMenuFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
@


1.22
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d961 2
a962 2
			uint32		plus1 = (pClient1->PlusVersion() < 0x2600) ? pClient1->PlusVersion() : 0;
			uint32		plus2 = (pClient2->PlusVersion() < 0x2600) ? pClient2->PlusVersion() : 0;
@


1.21
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d121 1
a121 1
		SortItems(SortProc, iSortItem + (bSortAscending ? CL_SORTASC : CL_SORTDESC));
d127 1
a127 1
	int		iCurrentSortItem = (iSortCode < CL_SORTDESC) ? iSortCode : iSortCode - CL_SORTDESC;
d129 1
a129 1
	SetSortArrow(iCurrentSortItem,(iSortCode < CL_SORTDESC));
d739 1
a739 1
	SortItems(SortProc, pNMListView->iSubItem + ((m_bSortAscending[pNMListView->iSubItem]) ? CL_SORTASC : DL_SORTDESC));
d759 1
a759 1
		case CLCOL_USERNAME + CL_SORTDESC:
d768 1
a768 1
		case CLCOL_UPLOADSTATUS + CL_SORTDESC:
d777 1
a777 1
		case CLCOL_TRANSFERREDUP + CL_SORTDESC:
d797 1
a797 1
		case CLCOL_DOWNLOADSTATUS + CL_SORTDESC:
d817 1
a817 1
		case CLCOL_TRANSFERREDDOWN + CL_SORTDESC:
d826 1
a826 1
		case CLCOL_CLIENTSOFTWARE + CL_SORTDESC:
d837 1
a837 1
		case CLCOL_CONNECTEDTIME + CL_SORTDESC:
d848 1
a848 1
		case CLCOL_USERHASH + CL_SORTDESC:
@


1.20
log
@Updated configurations, added VS2002 build config, continuing new sockets.
@
text
@d351 1
a351 1
								if (pClient->credits->GetCurrentIdentState(pClient->GetIP()) != IS_IDENTIFIED)
d369 1
a369 1
						else if (pClient->credits->GetScoreRatio(pClient->GetIP()) > 1)
d427 2
a428 2
					if (pClient->credits)
						strBuffer = CastItoXBytes(pClient->credits->GetUploadedTotal());
d474 2
a475 2
					if(pClient->credits)
						strBuffer = CastItoXBytes(pClient->credits->GetDownloadedTotal());
d771 3
a773 3
			if (pClient1->credits && pClient2->credits)
				return pClient1->credits->GetUploadedTotal()-pClient2->credits->GetUploadedTotal();
			else if (!pClient1->credits)
d778 3
a780 3
			if (pClient1->credits && pClient2->credits)
				return pClient2->credits->GetUploadedTotal()-pClient1->credits->GetUploadedTotal();
			else if (!pClient1->credits)
d811 3
a813 3
			if (pClient1->credits && pClient2->credits)
				return pClient1->credits->GetDownloadedTotal()-pClient2->credits->GetDownloadedTotal();
			else if (!pClient1->credits)
d818 3
a820 3
			if (pClient1->credits && pClient2->credits)
				return pClient2->credits->GetDownloadedTotal()-pClient1->credits->GetDownloadedTotal();
			else if (!pClient1->credits)
@


1.19
log
@no message
@
text
@d487 1
d496 1
d829 1
d835 1
d838 1
d844 1
@


1.18
log
@no message
@
text
@d487 1
a487 1
					if(pClient->m_pRequestSocket)
d489 1
a489 1
						if(pClient->m_pRequestSocket->IsConnected())
d827 3
a829 3
			if (pClient1->m_pRequestSocket && pClient2->m_pRequestSocket)
				return pClient1->m_pRequestSocket->IsConnected()-pClient2->m_pRequestSocket->IsConnected();
			else if (!pClient1->m_pRequestSocket)
d834 3
a836 3
			if (pClient1->m_pRequestSocket && pClient2->m_pRequestSocket)
				return pClient2->m_pRequestSocket->IsConnected()-pClient1->m_pRequestSocket->IsConnected();
			else if (!pClient2->m_pRequestSocket)
@


1.17
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d121 1
a121 1
		SortItems(SortProc, iSortItem + (bSortAscending ? CLCOL_USERNAME : CLCOL_USERNAME+CL_SORTDESC));
d487 1
a487 1
					if(pClient->socket)
d489 1
a489 1
						if(pClient->socket->IsConnected())
d737 1
a737 1
	SortItems(SortProc, pNMListView->iSubItem + ((m_bSortAscending[pNMListView->iSubItem]) ? CLCOL_USERNAME : CLCOL_USERNAME+CL_SORTDESC));
d827 3
a829 3
			if (pClient1->socket && pClient2->socket)
				return pClient1->socket->IsConnected()-pClient2->socket->IsConnected();
			else if (!pClient1->socket)
d834 3
a836 3
			if (pClient1->socket && pClient2->socket)
				return pClient2->socket->IsConnected()-pClient1->socket->IsConnected();
			else if (!pClient2->socket)
@


1.16
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d34 1
a34 1
BEGIN_MESSAGE_MAP(CWndClientList, CMuleListCtrl)
d42 1
a42 1
// CWndClientList
d44 1
a44 1
IMPLEMENT_DYNAMIC(CWndClientList, CMuleListCtrl)
d47 1
a47 1
CWndClientList::CWndClientList()
d52 1
a52 1
CWndClientList::~CWndClientList()
d57 1
a57 1
void CWndClientList::Init()
d125 1
a125 1
void CWndClientList::SortInit(int iSortCode)
d133 1
a133 1
void CWndClientList::Localize()
d186 1
a186 1
void CWndClientList::ShowKnownClients()
d193 1
a193 1
	for ( POSITION pos = g_eMuleApp.m_pClientList->list.GetHeadPosition();
d195 1
a195 1
		  g_eMuleApp.m_pClientList->list.GetNext(pos) )
d197 1
a197 1
		CUpDownClient	*pClient = g_eMuleApp.m_pClientList->list.GetAt(pos);
d200 1
a200 1
		RefreshClient(pClient);
d206 1
a206 1
void CWndClientList::AddClient(CUpDownClient *pClient)
d220 1
a220 1
		RefreshClient(pClient);
d225 1
a225 1
void CWndClientList::RemoveClient(CUpDownClient* pClient)
d257 1
a257 1
void CWndClientList::RefreshClient(CUpDownClient* pClient)
d284 1
a284 1
void CWndClientList::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
d565 1
a565 1
BOOL CWndClientList::OnWndMsg(UINT iMessage,WPARAM wParam, LPARAM lParam, LRESULT *pResult)
d573 1
d583 20
a602 1
				RefreshClient(pClient);
d619 1
a619 1
BOOL CWndClientList::OnNMDividerDoubleClick(NMHEADER *pHeader, LRESULT *pResult)
d642 1
a642 1
// CWndClientList message handlers
d645 1
a645 1
void CWndClientList::OnContextMenu(CWnd *pWnd, CPoint point)
d679 1
a679 1
BOOL CWndClientList::OnCommand(WPARAM wParam,LPARAM lParam)
d700 1
a700 1
				RefreshClient(pClient);
d706 1
a706 1
				RefreshClient(pClient);
d714 1
a714 1
					RefreshClient(pClient);
d729 1
a729 1
void CWndClientList::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
d743 1
a743 1
int CWndClientList::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
d849 1
a849 1
void CWndClientList::OnNMClick(NMHDR *pNMHDR, LRESULT *pResult)
d855 1
a855 1
void CWndClientList::OnNMDblclk(NMHDR *pNMHDR, LRESULT *pResult)
d872 1
a872 1
void CWndClientList::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
d878 1
a878 1
void CWndClientList::RefreshInfo(void)
d896 1
a896 1
void CWndClientList::OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)
d940 1
a940 1
int CWndClientList::SortClient(CUpDownClient *pClient1, CUpDownClient *pClient2, int iSortMode)
d1016 17
@


1.15
log
@Fixed the async update code in OnWndMsg() by having it do a check on the client list to verify the client it's going to refresh isn't destroyed already.
@
text
@d49 1
a49 1
	memset(&m_bSortAscending, 0, sizeof(m_bSortAscending));
@


1.14
log
@Removed old details code, added more keyboard shortcuts (now with only Ctrl instead of all three keys)
@
text
@d241 1
d576 8
a583 2

			RefreshClient(pClient);
@


1.13
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@a25 1
#ifdef _USE_NEW_DETAILS_
a26 3
#else
#include "ClientDetailDialog.h"
#endif
a692 1
#if _USE_NEW_DETAILS_
a693 3
#else
				CClientDetailDialog	dialog(pClient);
#endif
d838 2
a839 6
#if _USE_NEW_DETAILS_
				CClientDetails			dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
#else
				CClientDetailDialog		dialog(pClient);
#endif
				dialog.DoModal();
@


1.12
log
@Localization update
@
text
@d568 28
@


1.11
log
@Formatting, comments, and name changes.
Fixed column resizing on double-click.
@
text
@d670 1
a670 1
				CClientDetails		dialog("Client Details", pClient, this, 0);
d819 1
a819 1
				CClientDetails			dialog("Client Details", pClient, this, 0);
@


1.10
log
@Formatting, comments, and name changes.
@
text
@d96 6
a101 6
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));			// 1
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));			// 2
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  	// 3
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));      // 4
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      // 5
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      // 6
d104 1
a104 1
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  			// 9
d106 1
a106 1
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  		// 11
d108 1
a108 1
	LoadImgLstIcon(NULL,0,0);	// delete temp-icon
d125 1
a125 1
		SortItems(SortProc, iSortItem + (bSortAscending ? 0 : 100));
d131 1
a131 1
	int		iCurrentSortItem = (iSortCode < 100) ? iSortCode : iSortCode - 100;
d133 1
a133 1
	SetSortArrow(iCurrentSortItem,(iSortCode < 100));
d289 1
a289 1
	if( !g_eMuleApp.m_pdlgEmule->IsRunning() )
d295 3
a297 2
	CDC* odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	BOOL bCtrlFocused = ((GetFocus() == this ) || (GetStyle() & LVS_SHOWSELALWAYS));
a298 4
	CUpDownClient* client = (CUpDownClient*)lpDrawItemStruct->itemData;
	CMemDC dc(CDC::FromHandle(lpDrawItemStruct->hDC),&CRect(lpDrawItemStruct->rcItem));
	CFont* pOldFont = dc.SelectObject(GetFont());
	RECT cur_rec;
d300 9
a308 1
	memcpy2(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
d310 4
a313 1
	CString Sbuffer;
d315 3
a317 4
	CHeaderCtrl *pHeaderCtrl = GetHeaderCtrl();
	int iCount = pHeaderCtrl->GetItemCount();
	cur_rec.right = cur_rec.left - 8;
	cur_rec.left += 4;
d319 1
a319 1
	for(int iCurrent = 0; iCurrent < iCount; iCurrent++)
d321 3
a323 2
		int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
		if(!IsColumnHidden(iColumn))
d325 2
a326 2
			cur_rec.right += GetColumnWidth(iColumn);
			switch(iColumn)
d328 1
a328 1
				case 0:
d330 46
a375 32
				    POINT point = {cur_rec.left, cur_rec.top+1};
	
					// Display client icon
					switch(client->GetClientSoft()) {
						case SO_CDONKEY:
							m_imageList.Draw(dc, 8, point, ILD_NORMAL);
							break;
						case SO_LMULE:
							m_imageList.Draw(dc, 9, point, ILD_NORMAL);
							break;
						case SO_SHAREAZA:
							m_imageList.Draw(dc, 10, point, ILD_NORMAL);
							break;
						case SO_EDONKEYHYBRID:
							m_imageList.Draw(dc, 3, point, ILD_NORMAL);
							break;
						case SO_MLDONKEY:
							m_imageList.Draw(dc, 2, point, ILD_NORMAL);
							break;
						case SO_EMULE:
						case SO_OLDEMULE:
							if (client->credits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED)
								m_imageList.Draw(dc, 11, point, ILD_NORMAL);
							else
								m_imageList.Draw(dc, 1, point, ILD_NORMAL);
							break;
						case SO_EDONKEY:
							m_imageList.Draw(dc, 0, point, ILD_NORMAL);
							break;
						default:
							m_imageList.Draw(dc, 7, point, ILD_NORMAL);
							break;
d377 7
d385 1
a385 7
					// Display any Extra Overlay icons
					if (client->IsBanned())
						m_imageList.Draw(dc, 6, point, ILD_TRANSPARENT);
					else if (client->IsFriend())
						m_imageList.Draw(dc, 5, point, ILD_TRANSPARENT);
					else if (client->credits->GetScoreRatio(client->GetIP()) > 1)
						m_imageList.Draw(dc, 4, point, ILD_TRANSPARENT);
d387 1
a387 4
					if (client->GetUserName()=="")
						Sbuffer.Format("(%s)", GetResString(IDS_UNKNOWN));
					else
						Sbuffer = client->GetUserName();
d389 4
a392 3
					cur_rec.left +=20;
					dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DLC_DT_TEXT);
					cur_rec.left -=20;
d395 1
a395 1
				case 1:
d397 1
a397 1
					switch (client->GetUploadState())
d400 1
a400 1
							Sbuffer = GetResString(IDS_ONQUEUE);
d403 1
a403 1
							Sbuffer = GetResString(IDS_CL_PENDING);
d406 1
a406 1
							Sbuffer = GetResString(IDS_CL_LOW2LOW);
d409 1
a409 1
							Sbuffer = GetResString(IDS_BANNED);
d412 1
a412 1
							Sbuffer = GetResString(IDS_ERRORLIKE);
d415 1
a415 1
							Sbuffer = GetResString(IDS_CONNECTING);
d418 1
a418 1
							Sbuffer = GetResString(IDS_CONNVIASERVER);
d421 1
a421 1
							Sbuffer = GetResString(IDS_TRANSFERRING);
d424 1
a424 1
							Sbuffer.Empty();
d428 1
a428 1
				case 2:
d430 2
a431 2
					if(client->credits)
						Sbuffer = CastItoXBytes(client->credits->GetUploadedTotal());
d433 1
a433 1
						Sbuffer.Empty();
d436 1
a436 1
				case 3:
d438 1
a438 1
					switch (client->GetDownloadState())
d441 1
a441 1
							Sbuffer = GetResString(IDS_CONNECTING);
d444 1
a444 1
							Sbuffer = GetResString(IDS_ASKING);
d447 1
a447 1
							Sbuffer = GetResString(IDS_CONNVIASERVER);
d450 2
a451 2
							if( client->IsRemoteQueueFull() )
								Sbuffer = GetResString(IDS_QUEUEFULL);
d453 1
a453 1
								Sbuffer = GetResString(IDS_ONQUEUE);
d456 1
a456 1
							Sbuffer = GetResString(IDS_TRANSFERRING);
d459 1
a459 1
							Sbuffer = GetResString(IDS_RECHASHSET);
d462 1
a462 1
							Sbuffer = GetResString(IDS_NONEEDEDPARTS);
d465 1
a465 1
							Sbuffer = GetResString(IDS_NOCONNECTLOW2LOW);
d468 1
a468 1
							Sbuffer = GetResString(IDS_TOOMANYCONNS);
d471 1
a471 1
							Sbuffer.Empty();
d475 1
a475 1
				case 4:
d477 2
a478 2
					if(client->credits)
						Sbuffer = CastItoXBytes(client->credits->GetDownloadedTotal());
d480 1
a480 1
						Sbuffer.Empty();
d483 1
a483 1
				case 5:
d485 1
a485 1
					Sbuffer.Format(_T("%s"),GetClientNameAndVersionString(client));
d488 1
a488 1
				case 6:
d490 1
a490 1
					if(client->socket)
d492 1
a492 1
						if(client->socket->IsConnected())
d494 1
a494 1
							Sbuffer = GetResString(IDS_YES);
d498 1
a498 1
					Sbuffer = GetResString(IDS_NO);
d501 2
a502 2
				case 7:
					Sbuffer = md4str(client->GetUserHash());
d505 18
a522 3
			if( iColumn != 0)
				dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DLC_DT_TEXT);
			cur_rec.left += GetColumnWidth(iColumn);
d526 1
a526 1
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d528 3
a530 2
		RECT outline_rec;
		CBrush* pOldBrush;
d535 3
a537 1
		CBrush gdiBrush(GetBkColor());
d545 1
a545 1
		if(bCtrlFocused)
d547 2
a548 1
			CBrush fl_Brush(m_crFocusLine);
a550 1
			//eklmn: recover of old brush will be done below
a556 1
			//eklmn: recover of old brush will be done below
d558 1
d562 1
a562 1
	if ( pOldFont )
d579 4
a582 1
	SetColumnWidth(iColumn,m_iColumnMaxWidths[iColumn]);
a590 1

d593 2
a594 1
void CWndClientList::OnContextMenu(CWnd* pWnd, CPoint point)
d596 3
a598 2
	UINT flags=MF_STRING|MF_GRAYED;
	const CUpDownClient* client = NULL;
d601 3
a603 3
		if(GetSelectedCount()>0)
			flags=MF_STRING;
		if(client = (CUpDownClient*)GetItemData(GetSelectionMark()))
d605 1
a605 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser((CUpDownClient*)client);
d612 3
a614 3
	m_menuClient.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
	if(client && client->IsFriend())
		m_menuClient.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d616 6
a621 6
		m_menuClient.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
	m_menuClient.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG));
	m_menuClient.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
	m_menuClient.AppendMenu(flags,MP_UNBAN, GetResString(IDS_UNBAN));
	if(client)
		m_menuClient.EnableMenuItem(MP_UNBAN,(client->IsBanned() ? MF_ENABLED:MF_GRAYED));
d627 2
a628 2

BOOL CWndClientList::OnCommand(WPARAM wParam,LPARAM lParam )
d632 2
a633 1
		CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());
d637 2
a638 1
				client->RequestSharedFileList();
d640 1
d643 1
a643 1
				g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(client);
d648 2
a649 2
				g_eMuleApp.m_pFriendList->AddFriend(client);
				RefreshClient(client);
d653 3
a655 2
				g_eMuleApp.m_pFriendList->RemoveFriend(client);
				RefreshClient(client);
d657 1
d660 1
a660 1
				if(client->IsBanned())
d662 2
a663 2
					client->UnBan();
					RefreshClient(client);
d669 5
a673 5
			#if _USE_NEW_DETAILS_
				CClientDetails dialog("Client Details", client, this, 0);
			#else
				CClientDetailDialog dialog(client);
			#endif
d681 4
d686 2
a687 5
void CWndClientList::OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// if it's a second click on the same column then reverse the sort order,
	// otherwise sort the new column in ascending order.
d690 1
a690 1
	SortItems(SortProc, pNMListView->iSubItem + ((m_bSortAscending[pNMListView->iSubItem]) ? 0:100));
d695 1
a695 1

d698 9
a706 8
	CUpDownClient* item1 = (CUpDownClient*)lParam1;
	CUpDownClient* item2 = (CUpDownClient*)lParam2;
	switch(lParamSort)
	{
		case 0: 
			if(item1->GetUserName() && item2->GetUserName())
				return _tcsicmp(item1->GetUserName(), item2->GetUserName());
			else if(item1->GetUserName())
d710 4
a713 4
		case 100:
			if(item1->GetUserName() && item2->GetUserName())
				return _tcsicmp(item2->GetUserName(), item1->GetUserName());
			else if(item2->GetUserName())
d717 8
a724 8
		case 1:
			return item1->GetUploadState()-item2->GetUploadState();
		case 101:
			return item2->GetUploadState()-item1->GetUploadState();
		case 2:
			if(item1->credits && item2->credits)
				return item1->credits->GetUploadedTotal()-item2->credits->GetUploadedTotal();
			else if(!item1->credits)
d728 4
a731 4
		case 102:
			if(item1->credits && item2->credits)
				return item2->credits->GetUploadedTotal()-item1->credits->GetUploadedTotal();
			else if(!item1->credits)
d735 2
a736 2
		case 3:
		    if(item1->GetDownloadState() == item2->GetDownloadState())
d738 1
a738 1
			    if(item1->IsRemoteQueueFull() && item2->IsRemoteQueueFull())
d740 1
a740 1
			    else if(item1->IsRemoteQueueFull())
d742 1
a742 1
			    else if(item2->IsRemoteQueueFull())
d747 3
a749 3
			return item1->GetDownloadState()-item2->GetDownloadState();
		case 103:
		    if(item2->GetDownloadState() == item1->GetDownloadState())
d751 1
a751 1
			    if(item2->IsRemoteQueueFull() && item1->IsRemoteQueueFull())
d753 1
a753 1
			    else if(item2->IsRemoteQueueFull())
d755 1
a755 1
			    else if(item1->IsRemoteQueueFull())
d760 5
a764 5
			return item2->GetDownloadState()-item1->GetDownloadState();
		case 4:
			if(item1->credits && item2->credits)
				return item1->credits->GetDownloadedTotal()-item2->credits->GetDownloadedTotal();
			else if(!item1->credits)
d768 4
a771 4
		case 104:
			if(item1->credits && item2->credits)
				return item2->credits->GetDownloadedTotal()-item1->credits->GetDownloadedTotal();
			else if(!item1->credits)
d775 8
a782 8
		case 5:
			return SortClient(item1, item2, 1);
		case 105:
			return SortClient(item1, item2, -1);
		case 6:
			if(item1->socket && item2->socket)
				return item1->socket->IsConnected()-item2->socket->IsConnected();
			else if(!item1->socket)
d786 4
a789 4
		case 106:
			if(item1->socket && item2->socket)
				return item2->socket->IsConnected()-item1->socket->IsConnected();
			else if(!item2->socket)
d793 4
a796 4
		case 7:
			return memcmp(item1->GetUserHash(), item2->GetUserHash(), 16);
		case 107:
			return memcmp(item2->GetUserHash(), item1->GetUserHash(), 16);
d801 1
a801 1

d807 1
a807 1

d810 2
a811 1
	int iSel = GetSelectionMark();
d814 3
a816 2
		CUpDownClient* client = (CUpDownClient*)GetItemData(iSel);
		if (client)
d818 5
a822 5
			#if _USE_NEW_DETAILS_
				CClientDetails dialog("Client Details", client, this, 0);
			#else
				CClientDetailDialog dialog(client);
			#endif
d828 1
a828 1

d834 1
a834 1

d837 3
a839 2
	POSITION pos = GetFirstSelectedItemPosition();
	if(pos == NULL)
d846 3
a848 2
		const CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser((CUpDownClient*) client);
d852 1
a852 1

d855 1
a855 1
	NMLVDISPINFO *pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);
d859 8
a866 8
		// Although we have an owner drawn listview control we store the text for the primary item in the listview, to be
		// capable of quick searching those items via the keyboard. Because our listview items may change their contents,
		// we do this via a text callback function. The listview control will send us the LVN_DISPINFO notification if
		// it needs to know the contents of the primary item.
		//
		// But, the listview control sends this notification all the time, even if we do not search for an item. At least
		// this notification is only sent for the visible items and not for all items in the list. Though, because this
		// function is invoked *very* often, no *NOT* put any time consuming code here in.
d870 4
a873 2
			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);
			if (pClient != NULL){
d884 1
a884 1
						// shouldn't happen
d893 5
a897 2

int CWndClientList::SortClient(CUpDownClient* item1, CUpDownClient* item2, int sortMod)
d899 1
a899 1
	int	iCompare = 0;
d901 2
a902 1
	if (item1->GetClientSoft() == SO_UNKNOWN || item2->GetClientSoft() == SO_UNKNOWN )
d904 1
a904 1
		iCompare = (item1->GetClientSoft()-item2->GetClientSoft())*sortMod;		//Cax2 append all unknown ones at the end
d906 2
a907 1
	else if (item1->GetClientSoft() == item2->GetClientSoft())
d909 2
a910 1
		if (item1->IsEmuleClient())
d912 4
a915 2
			uint32 plus1=(item1->PlusVersion()<0x2600)?item1->PlusVersion():0;
			uint32 plus2=(item2->PlusVersion()<0x2600)?item2->PlusVersion():0;
d918 1
d921 2
a922 1
			else if (item1->GetMuleVersion() == item2->GetMuleVersion())
d924 5
a928 4
				if (!item1->GetModVersion().IsEmpty() && !item2->GetModVersion().IsEmpty())
					iCompare = _tcsicmp(item1->GetModVersion(), item2->GetModVersion());
				else if (!item1->GetModVersion().IsEmpty() || !item2->GetModVersion().IsEmpty())
					iCompare = (item1->GetModVersion().IsEmpty()) ? 1 : -1;
d931 1
a931 1
				iCompare = item2->GetMuleVersion() - item1->GetMuleVersion();
d933 1
d936 2
a937 1
			iCompare = item2->GetVersion() - item1->GetVersion();
d940 1
d943 1
a943 1
		iCompare = item1->GetClientSoft() - item2->GetClientSoft();
d946 1
d952 3
a954 1
		{ sName1 = CString(item1->GetUserName()); }
d956 3
a958 1
		{ sName1 = _T(""); }
d960 3
a962 1
		{ sName2 = CString(item2->GetUserName()); }
d964 3
a966 1
		{ sName2 = _T(""); }
d968 1
a968 1
			iCompare = (sName1.IsEmpty()) ? ((sName2.IsEmpty()) ? 0 : sortMod) : -1 * sortMod;
d972 3
a974 2
	return iCompare * sortMod;
}@


1.9
log
@Formatting, comments, and name changes.
@
text
@d38 7
d49 10
a58 2
CWndClientList::CWndClientList(){
	memset(&m_bSortAscending, 0, sizeof(m_bSortAscending)); // i_a 
d60 1
a60 1

d63 2
a64 1
	CImageList ilDummyImageList;
d69 7
d77 15
a91 10
	InsertColumn(0,GetResString(IDS_QL_USERNAME),LVCFMT_LEFT,150,0);
	InsertColumn(1,GetResString(IDS_CL_UPLOADSTATUS),LVCFMT_LEFT,100,1);
	InsertColumn(2,GetResString(IDS_CL_TRANSFUP),LVCFMT_LEFT,100,2);
	InsertColumn(3,GetResString(IDS_CL_DOWNLSTATUS),LVCFMT_LEFT,100,3);
	InsertColumn(4,GetResString(IDS_CL_TRANSFDOWN),LVCFMT_LEFT,100,4);
	CString coltemp;coltemp=GetResString(IDS_CD_CSOFT);coltemp.Remove(':');
	InsertColumn(5,coltemp,LVCFMT_LEFT,120,5);
	InsertColumn(6,GetResString(IDS_CONNECTED),LVCFMT_LEFT,80,6);
	coltemp=GetResString(IDS_CD_UHASH);coltemp.Remove(':');
	InsertColumn(7,coltemp,LVCFMT_LEFT,210,7);
d93 14
a106 14
	imagelist.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	imagelist.SetBkColor(CLR_NONE);
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));			// 0
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));			// 1
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));			// 2
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  	// 3
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));      // 4
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      // 5
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      // 6
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  		// 7
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  		// 8
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  			// 9
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  		// 10
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  		// 11
d109 1
a109 1
	SetImageList(&imagelist,LVSIL_SMALL);
d116 1
d118 1
d121 5
a125 4
		int sortItem = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_CLIENTLIST);
		bool sortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_CLIENTLIST);
		SetSortArrow(sortItem, sortAscending);
		SortItems(SortProc, sortItem + (sortAscending ? 0:100));
d128 2
a129 2

void CWndClientList::SortInit(int sortCode)
d131 1
a131 4
	int m_iCurrentSortItem=(sortCode<100)?sortCode:sortCode-100;
	SetSortArrow(m_iCurrentSortItem,(sortCode<100));
	SortItems(&SortProc, sortCode);
}
d133 2
a134 3
CWndClientList::~CWndClientList()
{
	imagelist.DeleteImageList();
d136 1
a136 1

d139 3
a141 2
	CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
	HDITEM hdi;
d144 1
a144 1
	if(pHeaderCtrl->GetItemCount() != 0)
d146 1
a146 1
		CString strRes;
d150 1
a150 1
		pHeaderCtrl->SetItem(0, &hdi);
d155 1
a155 1
		pHeaderCtrl->SetItem(1, &hdi);
d160 1
a160 1
		pHeaderCtrl->SetItem(2, &hdi);
d165 1
a165 1
		pHeaderCtrl->SetItem(3, &hdi);
d170 1
a170 1
		pHeaderCtrl->SetItem(4, &hdi);
d175 1
a175 1
		pHeaderCtrl->SetItem(5, &hdi);
d180 1
a180 1
		pHeaderCtrl->SetItem(6, &hdi);
d185 1
a185 1
		pHeaderCtrl->SetItem(7, &hdi);
d189 1
a189 1

d192 8
a199 4
	DeleteAllItems(); 
	int i=0; 
	CString temp; 
	for(POSITION pos = g_eMuleApp.m_pClientList->list.GetHeadPosition(); pos != NULL;g_eMuleApp.m_pClientList->list.GetNext(pos))
d201 4
a204 3
		CUpDownClient* cur_client = g_eMuleApp.m_pClientList->list.GetAt(pos); 
		InsertItem(LVIF_TEXT|LVIF_PARAM,i,LPSTR_TEXTCALLBACK,0,0,0,(LPARAM)cur_client);
		RefreshClient( cur_client );
d209 4
a213 3
void CWndClientList::AddClient(CUpDownClient* client)
{
	LVFINDINFO find;
d215 5
a219 3
	find.lParam = (LPARAM)client;
	sint32 result = FindItem(&find);
	if (result == (-1) && client)
d221 4
a224 3
		uint32 itemnr = GetItemCount();
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,LPSTR_TEXTCALLBACK,0,0,1,(LPARAM)client);
		RefreshClient(client);
d228 2
a229 2

void CWndClientList::RemoveClient(CUpDownClient* client)
d231 4
a234 2
	if (!g_eMuleApp.m_pdlgEmule->IsRunning()) return;
	if (!client) return;	//check NULL case
d236 1
a236 1
	if(g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE)
d238 1
a238 1
		if(g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == client)
d245 3
a247 2
	sint32 result = 0;
	while( result != -1 )
d249 2
a250 1
		LVFINDINFO find;
d252 4
a255 4
		find.lParam = (LPARAM)client;
		result = FindItem(&find);
		if (result != (-1) )
			DeleteItem(result);
d259 12
d272 1
a272 9
void CWndClientList::RefreshClient(CUpDownClient* client)
{
	// There is some type of timing issue here.. If you click on item in the queue or upload and leave
	// the focus on it when you exit the cient, it breaks on line 854 of emuleDlg.cpp.. 
	// I added this IsRunning() check to this function and the DrawItem method and
	// this seems to keep it from crashing. This is not the fix but a patch until
	// someone points out what is going wrong.. Also, it will still assert in debug mode..
	if(!g_eMuleApp.m_pdlgEmule->IsRunning()) return;
	if (!client) return;	//check NULL case
a273 1
	LVFINDINFO find;
d275 6
a280 4
	find.lParam = (LPARAM)client;
	sint16 result = FindItem(&find);
	if(result != -1)
		Update(result);
d282 1
d286 1
d327 1
a327 1
							imagelist.Draw(dc, 8, point, ILD_NORMAL);
d330 1
a330 1
							imagelist.Draw(dc, 9, point, ILD_NORMAL);
d333 1
a333 1
							imagelist.Draw(dc, 10, point, ILD_NORMAL);
d336 1
a336 1
							imagelist.Draw(dc, 3, point, ILD_NORMAL);
d339 1
a339 1
							imagelist.Draw(dc, 2, point, ILD_NORMAL);
d344 1
a344 1
								imagelist.Draw(dc, 11, point, ILD_NORMAL);
d346 1
a346 1
								imagelist.Draw(dc, 1, point, ILD_NORMAL);
d349 1
a349 1
							imagelist.Draw(dc, 0, point, ILD_NORMAL);
d352 1
a352 1
							imagelist.Draw(dc, 7, point, ILD_NORMAL);
d358 1
a358 1
						imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
d360 1
a360 1
						imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
d362 1
a362 1
						imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
d528 20
a548 7
BEGIN_MESSAGE_MAP(CWndClientList, CMuleListCtrl)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMDblclk)
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
END_MESSAGE_MAP()
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d43 1
a43 1
	memset(&asc_sort, 0, sizeof(asc_sort)); // i_a 
d578 3
a580 3
	asc_sort[pNMListView->iSubItem] = !asc_sort[pNMListView->iSubItem];
	SetSortArrow(pNMListView->iSubItem, asc_sort[pNMListView->iSubItem]);
	SortItems(SortProc, pNMListView->iSubItem + ((asc_sort[pNMListView->iSubItem]) ? 0:100));
d583 1
a583 1
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_CLIENTLIST, asc_sort[pNMListView->iSubItem]);
@


1.7
log
@Formatting, comments, and name changes.
@
text
@d100 2
a101 2
	int m_CurrentSortItem=(sortCode<100)?sortCode:sortCode-100;
	SetSortArrow(m_CurrentSortItem,(sortCode<100));
d506 3
a508 3
	m_ClientMenu.CreatePopupMenu();
	m_ClientMenu.AddMenuTitle(GetResString(IDS_CLIENTLIST));
	m_ClientMenu.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
d510 1
a510 1
		m_ClientMenu.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d512 4
a515 4
		m_ClientMenu.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
	m_ClientMenu.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG));
	m_ClientMenu.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
	m_ClientMenu.AppendMenu(flags,MP_UNBAN, GetResString(IDS_UNBAN));
d517 1
a517 1
		m_ClientMenu.EnableMenuItem(MP_UNBAN,(client->IsBanned() ? MF_ENABLED:MF_GRAYED));
d519 3
a521 3
	SetMenu(&m_ClientMenu);
	m_ClientMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
	m_ClientMenu.DestroyMenu();
@


1.6
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d441 1
a441 1
	//draw rectangle around selected item(s)
@


1.5
log
@Added new details IFDEF
@
text
@d441 1
a441 1
//draw rectangle around selected item(s)
d445 1
d450 3
a452 1
		dc->FrameRect(&outline_rec, &CBrush(GetBkColor()));
d459 6
a464 1
			dc->FrameRect(&outline_rec, &CBrush(m_crFocusLine));
d466 7
a472 1
			dc->FrameRect(&outline_rec, &CBrush(m_crNoFocusLine));
@


1.4
log
@Fixed sort for clients in Known List
@
text
@d26 3
d30 1
d546 3
d550 1
a676 19
void CWndClientList::ShowSelectedUserDetails()
{
	POINT point;
	::GetCursorPos(&point);
	CPoint p = point; 
    ScreenToClient(&p); 
    int it = HitTest(p); 
    if (it == -1) return;
	SetSelectionMark(it);   // display selection mark correctly! 

	CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());

	if (client)
	{
		CClientDetailDialog dialog(client);
		dialog.DoModal();
	}
}

d691 6
a696 2
			CClientDetailDialog dialog(client);
			dialog.DoModal();
@


1.3
log
@Fix for Client version
@
text
@d643 1
a643 3
			if(item1->GetClientSoft() == item2->GetClientSoft())
				return item2->GetVersion() - item1->GetVersion();
			return item1->GetClientSoft() - item2->GetClientSoft();
d645 1
a645 3
			if(item1->GetClientSoft() == item2->GetClientSoft())
				return item1->GetVersion() - item2->GetVersion();
			return item2->GetClientSoft() - item1->GetClientSoft();
d769 58
@


1.2
log
@Empy Incoming dir for category fix, Official fix [Katsyonak], WS templates updated for file status icons.
@
text
@d51 4
a54 4
	InsertColumn(1,GetResString(IDS_CL_UPLOADSTATUS),LVCFMT_LEFT,150,1);
	InsertColumn(2,GetResString(IDS_CL_TRANSFUP),LVCFMT_LEFT,150,2);
	InsertColumn(3,GetResString(IDS_CL_DOWNLSTATUS),LVCFMT_LEFT,150,3);
	InsertColumn(4,GetResString(IDS_CL_TRANSFDOWN),LVCFMT_LEFT,150,4);
d56 2
a57 2
	InsertColumn(5,coltemp,LVCFMT_LEFT,150,5);
	InsertColumn(6,GetResString(IDS_CONNECTED),LVCFMT_LEFT,150,6);
d59 1
a59 1
	InsertColumn(7,coltemp,LVCFMT_LEFT,150,7);
d412 1
a412 15
					switch (client->GetClientSoft()) 
					{
						case SO_EDONKEY:
						case SO_EDONKEYHYBRID: 
						case SO_EMULE:
						case SO_OLDEMULE:
						case SO_CDONKEY:
						case SO_SHAREAZA:
						case SO_LMULE:
						case SO_MLDONKEY:
							Sbuffer.Format(_T("%s v%s"),GetClientNameString(client->GetClientSoft()), GetClientVersionString(client->GetClientSoft(),client->GetMuleVersion()));
							break;
						default:
							Sbuffer = GetResString(IDS_UNKNOWN);
					}
@


1.1
log
@Added Known List to transfer window (missing files).
@
text
@d245 1
a245 9
	if( (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
	{
		if(bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	}
	else
		odc->SetBkColor(GetBkColor());
d250 1
a251 1
	COLORREF crOldTextColor = dc.SetTextColor(m_crWindowText);
d305 6
a310 4
                    if (client->IsFriend())
                        imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
                    else if (client->credits->GetScoreRatio(client->GetIP()) > 1)
                        imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
d471 4
a474 2
	dc.SelectObject(pOldFont);
	dc.SetTextColor(crOldTextColor);
@

