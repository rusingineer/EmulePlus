head	1.2;
access;
symbols
	PublicRelease_1_2:1.1
	Interim_Release_1-2_RC1:1.1
	Interim_Release_1-2_beta1:1.1
	PublicRelease_1_1g:1.1
	Interim_Release_1-1g_RC3:1.1
	Interim_Release_1-1g_RC2:1.1
	Interim_Release_1-1g_RC1:1.1
	Interim_Release_1-1g_beta2:1.1
	Interim_Release_1-1g_beta1:1.1
	PublicRelease_1_1f:1.1
	Interim_Release_1-1f_RC1:1.1
	PublicRelease_1_1e:1.1
	Interim_Release_1-1e_RC2:1.1
	Interim_Release_1-1e_RC1:1.1
	Interim_Release_1-1e_beta1:1.1
	PublicRelease_1_1d:1.1
	Interim_Release_1-1d_RC1:1.1
	PublicRelease_1_1c:1.1
	Interim_Release_1-1c_RC1:1.1
	Interim_Release_1-1c_beta2:1.1
	Interim_Release_1-1c_beta1:1.1
	PublicRelease_1_1b:1.1
	Interim_Release_1-1b_RC1:1.1
	PublicRelease_1_1a:1.1
	Interim_Release_1-1a_RC2:1.1
	Interim_Release_1-1a_RC1:1.1
	Interim_Release_1-1a_beta2:1.1
	Interim_Release_1-1a_beta1:1.1
	PublicRelease_1_1:1.1
	Interim_Release_1-1_beta1:1.1
	PublicRelease_1o:1.1
	Interim_Release_1o_RC1:1.1
	Interim_Release_1o_beta1:1.1
	PublicRelease_1n:1.1
	Interim_Release_1n_RC2:1.1
	Interim_Release_1n_RC1:1.1
	PublicRelease_1m:1.1
	Interim_Release_1m_beta1:1.1
	PublicRelease_1l:1.1
	Interim_Release_1l_RC3:1.1
	Interim_Release_1l_RC2:1.1
	Interim_Release_1l_RC1:1.1
	Interim_Release_1l_beta2:1.1
	Interim_Release_1l_beta1:1.1
	PublicRelease_1k:1.1
	Interim_Release_1k_RC4:1.1
	Interim_1k_RC3:1.1
	Interim_1k_RC2:1.1
	Interim_Release_1k_RC1:1.1
	Interim_Release_1k_beta5:1.1
	Intrerim_Release_1k_beta4:1.1
	Interim_Release_1k_beta1:1.1
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1
	PublicRelease_1i:1.1
	Interim_Release_1i_RC6:1.1
	Interim_Release_1i_RC3:1.1
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1;
locks; strict;
comment	@ * @;


1.2
date	2006.04.09.00.53.56;	author aw3;	state dead;
branches;
next	1.1;

1.1
date	2003.10.06.23.43.03;	author dongato;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Removed CxImage library as not used,
@
text
@#if !defined(__xmemfile_h)
#define __xmemfile_h

#include "xfile.h"

//////////////////////////////////////////////////////////
class DLL_EXP CxMemFile : public CxFile
	{
public:
	CxMemFile(BYTE* pBuffer = NULL, DWORD size = 0)
	{
		m_pBuffer = pBuffer;
		m_Position = 0;
		m_Size = m_Edge = size;
		m_bFreeOnClose = (bool)(pBuffer==0);
	}
//////////////////////////////////////////////////////////
	~CxMemFile()
	{
		Close();
	}
//////////////////////////////////////////////////////////
	virtual bool Close()
	{
		if ( (m_pBuffer) && (m_bFreeOnClose) ){
			free(m_pBuffer);
			m_pBuffer = NULL;
			m_Size = 0;
		}
		return true;
	}
//////////////////////////////////////////////////////////
	bool Open()
	{
		if (m_pBuffer) return false;	// Can't re-open without closing first

		m_Position = m_Size = m_Edge = 0;
		m_pBuffer=(BYTE*)malloc(0);
		m_bFreeOnClose = true;

		return (m_pBuffer!=0);
	}
//////////////////////////////////////////////////////////
	BYTE*	GetBuffer() { m_bFreeOnClose = false; return m_pBuffer;}
//////////////////////////////////////////////////////////
	virtual size_t	Read(void *buffer, size_t size, size_t count);
	virtual size_t	Write(const void *buffer, size_t size, size_t count);
	virtual bool	Seek(long offset, int origin);
	virtual long	Tell();
	virtual long	Size();
	virtual bool	Flush();
	virtual bool	Eof();
	virtual long	Error();
	virtual bool	PutC(unsigned char c);
	virtual long	GetC();

protected:
	void	Alloc(DWORD nBytes);
	void	Free();

protected:
	BYTE*	m_pBuffer;
	DWORD	m_Size;
	bool	m_bFreeOnClose;
	long	m_Position;	//current position
	long	m_Edge;		//buffer size
	};

#endif
@


1.1
log
@Updates
@
text
@@

