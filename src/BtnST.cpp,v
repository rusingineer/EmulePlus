head	1.21;
access;
symbols
	PublicRelease_1_2e:1.21
	Interim_Release_1-2e_RC1:1.21
	PublicRelease_1_2d:1.19
	Interim_Release_1-2d_RC1:1.19
	Interim_Release_1-2d_beta1:1.18
	PublicRelease_1_2c:1.17
	Interim_Release_1-2c_RC1:1.17
	Interim_Release_1-2c_beta1:1.16
	PublicRelease_1_2b:1.16
	Interim_Release_1-2b_RC1:1.16
	PublicRelease_1_2a:1.16
	Interim_Release_1-2a_RC1:1.16
	Interim_Release_1-2a_beta2:1.16
	Interim_Release_1-2a_beta1:1.16
	PublicRelease_1_2:1.16
	Interim_Release_1-2_RC1:1.16
	Interim_Release_1-2_beta1:1.16
	PublicRelease_1_1g:1.16
	Interim_Release_1-1g_RC3:1.16
	Interim_Release_1-1g_RC2:1.16
	Interim_Release_1-1g_RC1:1.16
	Interim_Release_1-1g_beta2:1.14
	Interim_Release_1-1g_beta1:1.14
	PublicRelease_1_1f:1.14
	Interim_Release_1-1f_RC1:1.14
	PublicRelease_1_1e:1.14
	Interim_Release_1-1e_RC2:1.14
	Interim_Release_1-1e_RC1:1.12
	Interim_Release_1-1e_beta1:1.12
	PublicRelease_1_1d:1.12
	Interim_Release_1-1d_RC1:1.12
	PublicRelease_1_1c:1.12
	Interim_Release_1-1c_RC1:1.12
	Interim_Release_1-1c_beta2:1.12
	Interim_Release_1-1c_beta1:1.12
	PublicRelease_1_1b:1.12
	Interim_Release_1-1b_RC1:1.12
	PublicRelease_1_1a:1.12
	Interim_Release_1-1a_RC2:1.12
	Interim_Release_1-1a_RC1:1.12
	Interim_Release_1-1a_beta2:1.12
	Interim_Release_1-1a_beta1:1.12
	PublicRelease_1_1:1.12
	Interim_Release_1-1_beta1:1.12
	PublicRelease_1o:1.12
	Interim_Release_1o_RC1:1.12
	Interim_Release_1o_beta1:1.12
	PublicRelease_1n:1.12
	Interim_Release_1n_RC2:1.12
	Interim_Release_1n_RC1:1.12
	Interim_Release_1n_beta2:1.10
	Interim_Release_1n_beta1:1.9
	PublicRelease_1m:1.9
	Interim_Release_1m_beta1:1.9
	PublicRelease_1l:1.9
	Interim_Release_1l_RC3:1.9
	Interim_Release_1l_RC2:1.9
	Interim_Release_1l_RC1:1.9
	Interim_Release_1l_beta2:1.9
	Interim_Release_1l_beta1:1.9
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.7
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.5
	Interim_Release_1j_RC1:1.5
	Interim_Release_1j_beta2:1.5
	Interim_Release_1j_beta1:1.5
	PublicRelease_1i:1.5
	Interim_Release_1i_RC6:1.5
	Interim_Release_1i_RC3:1.5
	Interim_Release_1i_RC2:1.5
	Interim_Release_1i_RC1:1.5
	Interim_Release_1i_beta3:1.5
	Interim_Release_1i_beta2:1.5
	Interim_Release_1i_beta1:1.4
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.21
date	2009.01.08.05.20.18;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.23.20.12.55;	author eklmn;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.10.04.10.04;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.10.05.05.48;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.30.01.53.35;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.01.16.02.05;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.27.05.20.52;	author eklmn;	state Exp;
branches;
next	1.12;

1.12
date	2004.08.16.06.20.18;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2004.08.15.11.30.31;	author katsyonak;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.05.19.58.23;	author katsyonak;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.18.15.41.44;	author katsyonak;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.3;

1.3
date	2003.07.29.19.43.59;	author bond006;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.22.12.41.50;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.17.59.08;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Removed preparation for pushlike button because it's not required anymore and on top it wasn't working anyway;
Reverted back simple memset as it's faster to use intrinsic function for small constant structures.
@
text
@#include "stdafx.h"
#include "BtnST.h"
#include "otherfunctions.h"
#include "emule.h"

#ifdef	BTNST_USE_SOUND
#pragma comment(lib, "winmm.lib")
#include <Mmsystem.h>
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CButtonST

// Mask for control's type
#ifdef BS_TYPEMASK
#undef BS_TYPEMASK
#endif
#define BS_TYPEMASK SS_TYPEMASK

#ifndef TTS_BALLOON
#define TTS_BALLOON	0x40
#endif

#ifndef	TTM_SETTITLE
#define TTM_SETTITLEA           (WM_USER + 32)  // wParam = TTI_*, lParam = char* szTitle
#define TTM_SETTITLEW           (WM_USER + 33)  // wParam = TTI_*, lParam = wchar* szTitle
#ifdef	UNICODE
#define TTM_SETTITLE            TTM_SETTITLEW
#else
#define TTM_SETTITLE            TTM_SETTITLEA
#endif
#endif

CButtonST::CButtonST()
{
	m_bIsPressed		= FALSE;
	m_bIsFocused		= FALSE;
	m_bIsDisabled		= FALSE;
	m_bMouseOnButton	= FALSE;

	FreeResources(FALSE);

	// Default type is "flat" button
	m_bIsFlat = TRUE;
	// Button will be tracked also if when the window is inactive (like Internet Explorer)
	m_bAlwaysTrack = TRUE;
  
	// By default draw border in "flat" button 
	m_bDrawBorder = TRUE; 
  
	// By default icon is aligned horizontally
	m_byAlign = ST_ALIGN_HORIZ; 

	// By default use usual pressed style
	SetPressedStyle(BTNST_PRESSED_LEFTRIGHT, FALSE);
  
	// By default, for "flat" button, don't draw the focus rect
	m_bDrawFlatFocus = FALSE;

	// By default, for "flat" button, don't draw as PushLike
	m_bIsPushLike = FALSE;

	// By default the button is not the default button
	m_bIsDefault = FALSE;
	// Invalid value, since type still unknown
	m_nTypeStyle = BS_TYPEMASK;

	// By default the button is not a checkbox
	m_bIsCheckBox = FALSE;
	m_nCheck = 0;

	// Set default colors
	SetDefaultColors(FALSE);

	// No tooltip created
	m_ToolTip.m_hWnd = NULL;
	m_dwToolTipStyle = 0;

	// Do not draw as a transparent button
	m_bDrawTransparent = FALSE;
	m_pbmpOldBk = NULL;

	// No URL defined
	SetURL(NULL);

	// No cursor defined
	m_hCursor = NULL;

	// No associated menu
#ifndef	BTNST_USE_BCMENU
	m_hMenu = NULL;
#endif
	m_hParentWndMenu = NULL;
	m_bMenuDisplayed = FALSE;

	m_bShowDisabledBitmap = TRUE;

	m_ptImageOrg.x = 3;
	m_ptImageOrg.y = 3;

	// No defined callbacks
	memset(&m_csCallbacks, 0, sizeof(m_csCallbacks));

#ifdef	BTNST_USE_SOUND
	// No defined sounds
	memzero(&m_csSounds, sizeof(m_csSounds));
#endif
} // End of CButtonST

CButtonST::~CButtonST()
{
	// Restore old bitmap (if any)
	if (m_dcBk.m_hDC && m_pbmpOldBk)
	{
		m_dcBk.SelectObject(m_pbmpOldBk);
	} // if

	FreeResources();

	// Destroy the cursor (if any)
	if (m_hCursor)
		::DestroyCursor(m_hCursor);

	// Destroy the menu (if any)
#ifdef	BTNST_USE_BCMENU
	if (m_menuPopup.m_hMenu)
		VERIFY( m_menuPopup.DestroyMenu() );
#else
	if (m_hMenu)
		VERIFY( ::DestroyMenu(m_hMenu) );
#endif
} // End of ~CButtonST

BEGIN_MESSAGE_MAP(CButtonST, CButton)
	ON_WM_SETCURSOR()
	ON_WM_KILLFOCUS()
	ON_WM_MOUSEMOVE()
	ON_WM_SYSCOLORCHANGE()
	ON_CONTROL_REFLECT_EX(BN_CLICKED, OnClicked)
	ON_WM_ACTIVATE()
	ON_WM_ENABLE()
	ON_WM_CANCELMODE()
	ON_WM_GETDLGCODE()
	ON_WM_CTLCOLOR_REFLECT()
#ifdef	BTNST_USE_BCMENU
	ON_WM_MENUCHAR()
	ON_WM_MEASUREITEM()
#endif

	ON_MESSAGE(BM_SETSTYLE, OnSetStyle)
	ON_MESSAGE(WM_MOUSELEAVE, OnMouseLeave)
	ON_MESSAGE(BM_SETCHECK, OnSetCheck)
	ON_MESSAGE(BM_GETCHECK, OnGetCheck)
END_MESSAGE_MAP()

void CButtonST::FreeResources(BOOL bCheckForNULL)
{
	if (bCheckForNULL)
	{
		// Destroy icons
		// Note: the following two lines MUST be here! even if
		// BoundChecker says they are unnecessary!
		if (m_csIcons[0].hIcon)
			::DestroyIcon(m_csIcons[0].hIcon);
		if (m_csIcons[1].hIcon)
			::DestroyIcon(m_csIcons[1].hIcon);

		// Destroy bitmaps
		if (m_csBitmaps[0].hBitmap)
			::DeleteObject(m_csBitmaps[0].hBitmap);
		if (m_csBitmaps[1].hBitmap)
			::DeleteObject(m_csBitmaps[1].hBitmap);

		// Destroy mask bitmaps
		if (m_csBitmaps[0].hMask)
			::DeleteObject(m_csBitmaps[0].hMask);
		if (m_csBitmaps[1].hMask)
			::DeleteObject(m_csBitmaps[1].hMask);
	} // if

	memzero(&m_csIcons, sizeof(m_csIcons));
	memzero(&m_csBitmaps, sizeof(m_csBitmaps));
} // End of FreeResources

void CButtonST::PreSubclassWindow() 
{
	UINT nBS;

	nBS = GetButtonStyle();

	// Set initial control type
	m_nTypeStyle = nBS & BS_TYPEMASK;

	// Check if this is a checkbox
	if (nBS & BS_CHECKBOX)
		m_bIsCheckBox = TRUE;

	// Set initial default state flag
	if (m_nTypeStyle == BS_DEFPUSHBUTTON)
	{
		// Set default state for a default button
		m_bIsDefault = TRUE;

		// Adjust style for default button
		m_nTypeStyle = BS_PUSHBUTTON;
	} // If

	// You should not set the Owner Draw before this call
	// (don't use the resource editor "Owner Draw" or
	// ModifyStyle(0, BS_OWNERDRAW) before calling PreSubclassWindow() )
	ASSERT(m_nTypeStyle != BS_OWNERDRAW);

	// Switch to owner-draw
	ModifyStyle(BS_TYPEMASK, BS_OWNERDRAW, SWP_FRAMECHANGED);

	CButton::PreSubclassWindow();
} // End of PreSubclassWindow

UINT CButtonST::OnGetDlgCode() 
{
	UINT nCode = CButton::OnGetDlgCode();

	// Tell the system if we want default state handling
	// (losing default state always allowed)
	nCode |= (m_bIsDefault ? DLGC_DEFPUSHBUTTON : DLGC_UNDEFPUSHBUTTON);

	return nCode;
} // End of OnGetDlgCode

BOOL CButtonST::PreTranslateMessage(MSG* pMsg) 
{
	InitToolTip();
	m_ToolTip.RelayEvent(pMsg);
	
	if (pMsg->message == WM_LBUTTONDBLCLK)
		pMsg->message = WM_LBUTTONDOWN;

	return CButton::PreTranslateMessage(pMsg);
} // End of PreTranslateMessage

HBRUSH CButtonST::CtlColor(CDC* pDC, UINT nCtlColor) 
{
	NOPRM(pDC); NOPRM(nCtlColor);
	return (HBRUSH)::GetStockObject(NULL_BRUSH); 
} // End of CtlColor

void CButtonST::OnSysColorChange() 
{
	CButton::OnSysColorChange();

	m_dcBk.DeleteDC();
	m_bmpBk.DeleteObject();	
	SetDefaultColors();
} // End of OnSysColorChange

LRESULT CButtonST::OnSetStyle(WPARAM wParam, LPARAM lParam)
{
	UINT		nNewType = (wParam & BS_TYPEMASK);

	// Update default state flag
	if (nNewType == BS_DEFPUSHBUTTON)
	{
		m_bIsDefault = TRUE;
	} // if
	else if (nNewType == BS_PUSHBUTTON)
	{
		// Losing default state always allowed
		m_bIsDefault = FALSE;
	} // if

	// Can't change control type after owner-draw is set.
	// Let the system process changes to other style bits
	// and redrawing, while keeping owner-draw style
	return DefWindowProc(BM_SETSTYLE,
		(wParam & ~BS_TYPEMASK) | BS_OWNERDRAW, lParam);
} // End of OnSetStyle

LRESULT CButtonST::OnSetCheck(WPARAM wParam, LPARAM lParam)
{
	NOPRM(lParam);
	ASSERT(m_bIsCheckBox);

	switch (wParam)
	{
		case BST_CHECKED:
		case BST_INDETERMINATE:	// Indeterminate state is handled like checked state
			SetCheck(1);
			break;
		default:
			SetCheck(0);
			break;
	} // switch

	return 0;
} // End of OnSetCheck

LRESULT CButtonST::OnGetCheck(WPARAM wParam, LPARAM lParam)
{
	NOPRM(wParam); NOPRM(lParam);
	ASSERT(m_bIsCheckBox);
	return GetCheck();
} // End of OnGetCheck

#ifdef	BTNST_USE_BCMENU
LRESULT CButtonST::OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu) 
{
	LRESULT		lResult;

	if (BCMenu::IsMenu(pMenu))
		lResult = BCMenu::FindKeyboardShortcut(nChar, nFlags, pMenu);
	else
		lResult = CButton::OnMenuChar(nChar, nFlags, pMenu);
	return lResult;
} // End of OnMenuChar
#endif

#ifdef	BTNST_USE_BCMENU
void CButtonST::OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct) 
{
	BOOL		bSetFlag = FALSE;

	if (lpMeasureItemStruct->CtlType == ODT_MENU)
	{
		if (IsMenu((HMENU)lpMeasureItemStruct->itemID) && BCMenu::IsMenu((HMENU)lpMeasureItemStruct->itemID))
		{
			m_menuPopup.MeasureItem(lpMeasureItemStruct);
			bSetFlag = TRUE;
		} // if
	} // if
	if (!bSetFlag)
		CButton::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
} // End of OnMeasureItem
#endif

void CButtonST::OnEnable(BOOL bEnable) 
{
	CButton::OnEnable(bEnable);
	
	if (!bEnable)	
	{
		CWnd*		pWnd = GetParent()->GetNextDlgTabItem(this);

		if (pWnd)
			pWnd->SetFocus();
		else
			GetParent()->SetFocus();

		CancelHover();
	} // if
} // End of OnEnable

void CButtonST::OnKillFocus(CWnd * pNewWnd)
{
	CButton::OnKillFocus(pNewWnd);

	CancelHover();
} // End of OnKillFocus

void CButtonST::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) 
{
	CButton::OnActivate(nState, pWndOther, bMinimized);

	if (nState == WA_INACTIVE)
		CancelHover();
} // End of OnActivate

void CButtonST::OnCancelMode() 
{
	CButton::OnCancelMode();

	CancelHover();
} // End of OnCancelMode

BOOL CButtonST::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
	// If a cursor was specified then use it!
	if (m_hCursor != NULL)
	{
		::SetCursor(m_hCursor);
		return TRUE;
	} // if

	return CButton::OnSetCursor(pWnd, nHitTest, message);
} // End of OnSetCursor

void CButtonST::CancelHover()
{
	// Only for flat buttons
	if (m_bIsFlat && m_bMouseOnButton)
	{
		m_bMouseOnButton = FALSE;
		Invalidate();
	} // if
} // End of CancelHover

void CButtonST::OnMouseMove(UINT nFlags, CPoint point)
{
	CWnd*				wndUnderMouse = NULL;
	CWnd*				wndActive = this;
	TRACKMOUSEEVENT		csTME;

	CButton::OnMouseMove(nFlags, point);

	ClientToScreen(&point);
	wndUnderMouse = WindowFromPoint(point);

	// If the mouse enter the button with the left button pressed then do nothing
	if (nFlags & MK_LBUTTON && !m_bMouseOnButton)
		return;

	// If our button is not flat then do nothing
	if (!m_bIsFlat)
		return;

	if (!m_bAlwaysTrack)
		wndActive = GetActiveWindow();

	if (wndUnderMouse && wndUnderMouse->m_hWnd == m_hWnd && wndActive)
	{
		if (!m_bMouseOnButton)
		{
			m_bMouseOnButton = TRUE;

			Invalidate();

#ifdef	BTNST_USE_SOUND
			// Play sound ?
			if (m_csSounds[0].lpszSound)
				::PlaySound(m_csSounds[0].lpszSound, m_csSounds[0].hMod, m_csSounds[0].dwFlags);
#endif

			csTME.cbSize = sizeof(csTME);
			csTME.dwFlags = TME_LEAVE;
			csTME.hwndTrack = m_hWnd;
			::_TrackMouseEvent(&csTME);
		} // if
	}
	else
		CancelHover();
} // End of OnMouseMove

// Handler for WM_MOUSELEAVE
LRESULT CButtonST::OnMouseLeave(WPARAM wParam, LPARAM lParam)
{
	NOPRM(wParam); NOPRM(lParam);
	CancelHover();
	return 0;
} // End of OnMouseLeave

BOOL CButtonST::OnClicked() 
{	
	SetFocus();

#ifdef	BTNST_USE_SOUND
	// Play sound ?
	if (m_csSounds[1].lpszSound)
		::PlaySound(m_csSounds[1].lpszSound, m_csSounds[1].hMod, m_csSounds[1].dwFlags);
#endif

	if (m_bIsCheckBox)
	{
		m_nCheck = !m_nCheck;
		Invalidate();
	} // if
	else
	{
		// Handle the menu (if any)
#ifdef	BTNST_USE_BCMENU
		if (m_menuPopup.m_hMenu)
#else
		if (m_hMenu)
#endif
		{
			CRect		rWnd;

			GetWindowRect(rWnd);

			m_bMenuDisplayed = TRUE;
			Invalidate();

#ifdef	BTNST_USE_BCMENU
			BCMenu		*psub = (BCMenu*)m_menuPopup.GetSubMenu(0);

			if (m_csCallbacks.hWnd != NULL)
				::SendMessage(m_csCallbacks.hWnd, m_csCallbacks.nMessage, (WPARAM)psub, m_csCallbacks.lParam);

			DWORD		dwRetValue = psub->TrackPopupMenuEx(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, rWnd.left, rWnd.bottom, this, NULL);

#else
			HMENU		hSubMenu = ::GetSubMenu(m_hMenu, 0);

			if (m_csCallbacks.hWnd != NULL)
				::SendMessage(m_csCallbacks.hWnd, m_csCallbacks.nMessage, (WPARAM)hSubMenu, m_csCallbacks.lParam);

			DWORD		dwRetValue = ::TrackPopupMenuEx(hSubMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, rWnd.left, rWnd.bottom, m_hParentWndMenu, NULL);

#endif

			m_bMenuDisplayed = FALSE;
			Invalidate();

			if (dwRetValue != 0)
				::PostMessage(m_hParentWndMenu, WM_COMMAND, MAKEWPARAM(dwRetValue, 0), (LPARAM)NULL);
		} // if
		else
		{
			// Handle the URL (if any)
			if (_tcslen(m_szURL) > 0)
			{
				SHELLEXECUTEINFO		csSEI;

				memzero(&csSEI, sizeof(csSEI));
				csSEI.cbSize = sizeof(SHELLEXECUTEINFO);
				csSEI.fMask = SEE_MASK_FLAG_NO_UI;
				csSEI.lpVerb = _T("open");
				csSEI.lpFile = m_szURL;
				csSEI.nShow = SW_SHOWMAXIMIZED;
				::ShellExecuteEx(&csSEI);
			} // if
		} // else
	} // else

	return FALSE;
} // End of OnClicked

void CButtonST::DrawItem(LPDRAWITEMSTRUCT lpDIS)
{
	CDC*		pDC = CDC::FromHandle(lpDIS->hDC);

	// Checkbox?
	if (m_bIsCheckBox)
	{
		m_bIsPressed  =  (lpDIS->itemState & ODS_SELECTED) || (m_nCheck != 0);
	} // if
	else	// Normal button OR other button style ...
	{
		m_bIsPressed = (lpDIS->itemState & ODS_SELECTED);

		// If there is a menu and it's displayed, draw the button as pressed
		if (
#ifdef	BTNST_USE_BCMENU
			m_menuPopup.m_hMenu 
#else
			m_hMenu 
#endif
			&& m_bMenuDisplayed)	m_bIsPressed = TRUE;
	} // else

	m_bIsFocused  = (lpDIS->itemState & ODS_FOCUS);
	m_bIsDisabled = (lpDIS->itemState & ODS_DISABLED);

	CRect		itemRect = lpDIS->rcItem;

	pDC->SetBkMode(TRANSPARENT);

	// Prepare draw... paint button background

	// Draw transparent?
	if (m_bDrawTransparent)
		PaintBk(pDC);
	else
		OnDrawBackground(pDC, &itemRect);

	// Draw button border
	OnDrawBorder(pDC, &itemRect);

	// Read the button's title
	CString			strTitle;

	GetWindowText(strTitle);

	CRect			captionRect = lpDIS->rcItem;

	// Draw the icon
	if (m_csIcons[0].hIcon)
	{
		DrawTheIcon(pDC, !strTitle.IsEmpty(), &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
	} // if

	if (m_csBitmaps[0].hBitmap)
	{
		pDC->SetBkColor(RGB(255,255,255));
		DrawTheBitmap(pDC, !strTitle.IsEmpty(), &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
	} // if

	// Write the button title (if any)
	if (!strTitle.IsEmpty())
		DrawTheText(pDC, (LPCTSTR)strTitle, &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);

	if (m_bIsFocused && g_App.m_pPrefs->GetWindowsVersion() != _WINVER_XP_
		&& (!m_bIsFlat || (m_bIsFlat && m_bDrawFlatFocus)))
	{
		// Draw the focus rect
		CRect		focusRect = itemRect;

		focusRect.DeflateRect(2, 2);
		pDC->DrawFocusRect(&focusRect);
	} // if
} // End of DrawItem

void CButtonST::PaintBk(CDC* pDC)
{
	CClientDC		clDC(GetParent());
	CRect			rect;
	CRect			rect1;

	GetClientRect(rect);

	GetWindowRect(rect1);
	GetParent()->ScreenToClient(rect1);

	if (m_dcBk.m_hDC == NULL)
	{
		m_dcBk.CreateCompatibleDC(&clDC);
		m_bmpBk.CreateCompatibleBitmap(&clDC, rect.Width(), rect.Height());
		m_pbmpOldBk = m_dcBk.SelectObject(&m_bmpBk);
		m_dcBk.BitBlt(0, 0, rect.Width(), rect.Height(), &clDC, rect1.left, rect1.top, SRCCOPY);
	} // if

	pDC->BitBlt(0, 0, rect.Width(), rect.Height(), &m_dcBk, 0, 0, SRCCOPY);
} // End of PaintBk

HBITMAP CButtonST::CreateBitmapMask(HBITMAP hSourceBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTransColor)
{
	HBITMAP		hMask = ::CreateBitmap(dwWidth, dwHeight, 1, 1, NULL);

	if (hMask == NULL)
		return NULL;

	HDC			hdcSrc	= ::CreateCompatibleDC(NULL);
	HDC			hdcDest	= ::CreateCompatibleDC(NULL);
	HBITMAP		hbmSrcT = (HBITMAP)::SelectObject(hdcSrc, hSourceBitmap);
	HBITMAP		hbmDestT = (HBITMAP)::SelectObject(hdcDest, hMask);
	COLORREF	crSaveBk = ::SetBkColor(hdcSrc, crTransColor);

	::BitBlt(hdcDest, 0, 0, dwWidth, dwHeight, hdcSrc, 0, 0, SRCCOPY);

	COLORREF	crSaveDestText = ::SetTextColor(hdcSrc, RGB(255, 255, 255));

	::SetBkColor(hdcSrc, RGB(0, 0, 0));

	::BitBlt(hdcSrc, 0, 0, dwWidth, dwHeight, hdcDest, 0, 0, SRCAND);

	SetTextColor(hdcDest, crSaveDestText);

	::SetBkColor(hdcSrc, crSaveBk);
	::SelectObject(hdcSrc, hbmSrcT);
	::SelectObject(hdcDest, hbmDestT);

	::DeleteDC(hdcSrc);
	::DeleteDC(hdcDest);

	return hMask;
} // End of CreateBitmapMask

//
// Parameters:
//		[IN]	bHasTitle
//				TRUE if the button has a text
//		[IN]	rpItem
//				A pointer to a RECT structure indicating the allowed paint area
//		[IN/OUT]rpTitle
//				A pointer to a CRect object indicating the paint area reserved for the
//				text. This structure will be modified if necessary.
//		[IN]	bIsPressed
//				TRUE if the button is currently pressed
//		[IN]	dwWidth
//				Width of the image (icon or bitmap)
//		[IN]	dwHeight
//				Height of the image (icon or bitmap)
//		[OUT]	rpImage
//				A pointer to a CRect object that will receive the area available to the image
//
void CButtonST::PrepareImageRect(BOOL bHasTitle, RECT* rpItem, CRect* rpTitle, BOOL bIsPressed, DWORD dwWidth, DWORD dwHeight, CRect* rpImage)
{
	CRect		rBtn;

	rpImage->CopyRect(rpItem);

	if (bHasTitle)
		rpImage->left += 4;

	switch (m_byAlign)
	{
		case ST_ALIGN_HORIZ:
			if (!bHasTitle)
			{
				// Center image horizontally
				rpImage->left += ((rpImage->Width() - (long)dwWidth) / 2);
			}
			else
			{
				// Image must be placed just inside the focus rect
				rpImage->left += m_ptImageOrg.x;  
				rpTitle->left += dwWidth + m_ptImageOrg.x;
			}
			// Center image vertically
			rpImage->top += ((rpImage->Height() - (long)dwHeight) / 2);
			break;

		case ST_ALIGN_HORIZ_RIGHT:
			GetClientRect(&rBtn);
			if (!bHasTitle)
			{
				// Center image horizontally
				rpImage->left += ((rpImage->Width() - (long)dwWidth) / 2);
			}
			else
			{
				// Image must be placed just inside the focus rect
				rpTitle->right = rpTitle->Width() - dwWidth - m_ptImageOrg.x;
				rpTitle->left = m_ptImageOrg.x;
				rpImage->left = rBtn.right - dwWidth - m_ptImageOrg.x;
				// Center image vertically
				rpImage->top += ((rpImage->Height() - (long)dwHeight) / 2);
			}
			break;
		
		case ST_ALIGN_VERT:
			// Center image horizontally
			rpImage->left += ((rpImage->Width() - (long)dwWidth) / 2);
			if (!bHasTitle)
			{
				// Center image vertically
				rpImage->top += ((rpImage->Height() - (long)dwHeight) / 2);           
			}
			else
			{
				rpImage->top = m_ptImageOrg.y;
				rpTitle->top += dwHeight;
			}
			break;

		case ST_ALIGN_OVERLAP:
			break;
	} // switch

	// If button is pressed then press image also
	if (bIsPressed && !m_bIsCheckBox)
		rpImage->OffsetRect(m_ptPressedOffset.x, m_ptPressedOffset.y);
} // End of PrepareImageRect

void CButtonST::DrawTheIcon(CDC* pDC, BOOL bHasTitle, RECT* rpItem, CRect* rpCaption, BOOL bIsPressed, BOOL bIsDisabled)
{
	BYTE		byIndex;

	// Select the icon to use
	if ((m_bIsCheckBox && bIsPressed) || (!m_bIsCheckBox && (bIsPressed || m_bMouseOnButton)))
		byIndex = 0;
	else
		byIndex = (m_csIcons[1].hIcon == NULL ? 0 : 1);

	CRect		rImage;

	PrepareImageRect(bHasTitle, rpItem, rpCaption, bIsPressed, m_csIcons[byIndex].dwWidth, m_csIcons[byIndex].dwHeight, &rImage);

	// Ole'!
	pDC->DrawState(	rImage.TopLeft(),
					rImage.Size(), 
					m_csIcons[byIndex].hIcon,
					(bIsDisabled ? DSS_DISABLED : DSS_NORMAL), 
					(CBrush*)NULL);
} // End of DrawTheIcon

void CButtonST::DrawTheBitmap(CDC* pDC, BOOL bHasTitle, RECT* rpItem, CRect* rpCaption, BOOL bIsPressed, BOOL bIsDisabled)
{
	BYTE		byIndex;

	// Select the bitmap to use
	if ((m_bIsCheckBox && bIsPressed) || (!m_bIsCheckBox && (bIsPressed || m_bMouseOnButton)))
		byIndex = 0;
	else
		byIndex = (m_csBitmaps[1].hBitmap == NULL ? 0 : 1);

	CRect		rImage;

	PrepareImageRect(bHasTitle, rpItem, rpCaption, bIsPressed, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, &rImage);

	HDC			hdcBmpMem = ::CreateCompatibleDC(pDC->m_hDC);
	HBITMAP		hbmOldBmp = (HBITMAP)::SelectObject(hdcBmpMem, m_csBitmaps[byIndex].hBitmap);
	HDC			hdcMem = ::CreateCompatibleDC(NULL);
	HBITMAP		hbmT = (HBITMAP)::SelectObject(hdcMem, m_csBitmaps[byIndex].hMask);

	if (bIsDisabled && m_bShowDisabledBitmap)
	{
		HDC			hDC = ::CreateCompatibleDC(pDC->m_hDC);
		HBITMAP		hBitmap = ::CreateCompatibleBitmap(pDC->m_hDC, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight);
		HBITMAP		hOldBmp2 = (HBITMAP)::SelectObject(hDC, hBitmap);
		RECT		rRect;

		rRect.left = 0;
		rRect.top = 0;
		rRect.right = rImage.right + 1;
		rRect.bottom = rImage.bottom + 1;
		::FillRect(hDC, &rRect, (HBRUSH)RGB(255, 255, 255));

		COLORREF	crOldColor = ::SetBkColor(hDC, RGB(255,255,255));

		::BitBlt(hDC, 0, 0, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, hdcMem, 0, 0, SRCAND);
		::BitBlt(hDC, 0, 0, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, hdcBmpMem, 0, 0, SRCPAINT);

		::SetBkColor(hDC, crOldColor);
		::SelectObject(hDC, hOldBmp2);
		::DeleteDC(hDC);

		pDC->DrawState(	CPoint(rImage.left/*+1*/, rImage.top), 
						CSize(m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight), 
						hBitmap, DST_BITMAP | DSS_DISABLED);

		::DeleteObject(hBitmap);
	} // if
	else
	{
		::BitBlt(pDC->m_hDC, rImage.left, rImage.top, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, hdcMem, 0, 0, SRCAND);
		::BitBlt(pDC->m_hDC, rImage.left, rImage.top, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight, hdcBmpMem, 0, 0, SRCPAINT);
	} // else

	::SelectObject(hdcMem, hbmT);
	::DeleteDC(hdcMem);

	::SelectObject(hdcBmpMem, hbmOldBmp);
	::DeleteDC(hdcBmpMem);
} // End of DrawTheBitmap

void CButtonST::DrawTheText(CDC* pDC, LPCTSTR lpszText, RECT* rpItem, CRect* rpCaption, BOOL bIsPressed, BOOL bIsDisabled)
{
	NOPRM(rpItem); NOPRM(bIsPressed); NOPRM(bIsDisabled);
	// Draw the button's title
	// If button is pressed then "press" title also
	if (m_bIsPressed && !m_bIsCheckBox)
		rpCaption->OffsetRect(m_ptPressedOffset.x, m_ptPressedOffset.y);

	// ONLY FOR DEBUG 
	//CBrush brBtnShadow(RGB(255, 0, 0));
	//pDC->FrameRect(rCaption, &brBtnShadow);

	// Center text
	CRect		centerRect = rpCaption;

	pDC->DrawText(lpszText, -1, rpCaption, DT_WORDBREAK | DT_CENTER | DT_CALCRECT);
	rpCaption->OffsetRect((centerRect.Width() - rpCaption->Width())/2, (centerRect.Height() - rpCaption->Height())/2);
	/* RFU
	rpCaption->OffsetRect(0, (centerRect.Height() - rpCaption->Height())/2);
	rpCaption->OffsetRect((centerRect.Width() - rpCaption->Width())-4, (centerRect.Height() - rpCaption->Height())/2);
	*/

	pDC->SetBkMode(TRANSPARENT);
	/*
	pDC->DrawState(rCaption->TopLeft(), rCaption->Size(), (LPCTSTR)sTitle, (bIsDisabled ? DSS_DISABLED : DSS_NORMAL), 
					TRUE, 0, (CBrush*)NULL);
	*/
	if (m_bIsDisabled)
	{
		rpCaption->OffsetRect(1, 1);
		pDC->SetTextColor(::GetSysColor(COLOR_3DHILIGHT));
		pDC->DrawText(lpszText, -1, rpCaption, DT_WORDBREAK | DT_CENTER);
		rpCaption->OffsetRect(-1, -1);
		pDC->SetTextColor(::GetSysColor(COLOR_3DSHADOW));
		pDC->DrawText(lpszText, -1, rpCaption, DT_WORDBREAK | DT_CENTER);
	} // if
	else
	{
		if (m_bMouseOnButton || m_bIsPressed) 
		{
			pDC->SetTextColor(m_crColors[BTNST_COLOR_FG_IN]);
			pDC->SetBkColor(m_crColors[BTNST_COLOR_BK_IN]);
		} // if
		else 
		{
			if (m_bIsFocused)
			{ 
				pDC->SetTextColor(m_crColors[BTNST_COLOR_FG_FOCUS]); 
				pDC->SetBkColor(m_crColors[BTNST_COLOR_BK_FOCUS]); 
			} // if
			else 
			{
				pDC->SetTextColor(m_crColors[BTNST_COLOR_FG_OUT]); 
				pDC->SetBkColor(m_crColors[BTNST_COLOR_BK_OUT]); 
			} // else
		} // else
		pDC->DrawText(lpszText, -1, rpCaption, DT_WORDBREAK | DT_CENTER);
	} // if
} // End of DrawTheText

// This function creates a grayscale bitmap starting from a given bitmap.
// The resulting bitmap will have the same size of the original one.
//
// Parameters:
//		[IN]	hBitmap
//				Handle to the original bitmap.
//		[IN]	dwWidth
//				Specifies the bitmap width, in pixels.
//		[IN]	dwHeight
//				Specifies the bitmap height, in pixels.
//		[IN]	crTrans
//				Color to be used as transparent color. This color will be left unchanged.
//
// Return value:
//		If the function succeeds, the return value is the handle to the newly created
//		grayscale bitmap.
//		If the function fails, the return value is NULL.
//
HBITMAP CButtonST::CreateGrayscaleBitmap(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTrans)
{
	HDC			hMainDC = ::GetDC(NULL);

	if (hMainDC == NULL)
		return NULL;

	HDC			hMemDC1 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC1 == NULL)
	{
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	} // if

	HDC			hMemDC2 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC2 == NULL)
	{
		::DeleteDC(hMemDC1);
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	} // if

	HBITMAP		hGrayBitmap = ::CreateCompatibleBitmap(hMainDC, dwWidth, dwHeight);

	if (hGrayBitmap != NULL)
	{
		HBITMAP		hOldBmp1 = (HBITMAP)::SelectObject(hMemDC1, hGrayBitmap);
		HBITMAP		hOldBmp2 = (HBITMAP)::SelectObject(hMemDC2, hBitmap);
		DWORD		dwLoopY, dwLoopX;
		COLORREF	crPixel;
		BYTE		byNewPixel;

		for (dwLoopY = 0; dwLoopY < dwHeight; dwLoopY++)
		{
			for (dwLoopX = 0; dwLoopX < dwWidth; dwLoopX++)
			{
				crPixel = ::GetPixel(hMemDC2, dwLoopX, dwLoopY);
				byNewPixel = (BYTE)((GetRValue(crPixel) * 0.299) + (GetGValue(crPixel) * 0.587) + (GetBValue(crPixel) * 0.114));

				if (crPixel != crTrans)
					::SetPixel(hMemDC1, dwLoopX, dwLoopY, RGB(byNewPixel, byNewPixel, byNewPixel));
				else
					::SetPixel(hMemDC1, dwLoopX, dwLoopY, crPixel);
			} // for
		} // for

		::SelectObject(hMemDC1, hOldBmp1);
		::SelectObject(hMemDC2, hOldBmp2);
	} // if

	::DeleteDC(hMemDC1);
	::DeleteDC(hMemDC2);
	::ReleaseDC(NULL, hMainDC);

	return hGrayBitmap;
} // End of CreateGrayscaleBitmap

// This function creates a bitmap that is 25% darker than the original.
// The resulting bitmap will have the same size of the original one.
//
// Parameters:
//		[IN]	hBitmap
//				Handle to the original bitmap.
//		[IN]	dwWidth
//				Specifies the bitmap width, in pixels.
//		[IN]	dwHeight
//				Specifies the bitmap height, in pixels.
//		[IN]	crTrans
//				Color to be used as transparent color. This color will be left unchanged.
//
// Return value:
//		If the function succeeds, the return value is the handle to the newly created
//		darker bitmap.
//		If the function fails, the return value is NULL.
//
HBITMAP CButtonST::CreateDarkerBitmap(HBITMAP hBitmap, DWORD dwWidth, DWORD dwHeight, COLORREF crTrans)
{
	HDC			hMainDC = ::GetDC(NULL);

	if (hMainDC == NULL)
		return NULL;

	HDC			hMemDC1 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC1 == NULL)
	{
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	} // if

	HDC			hMemDC2 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC2 == NULL)
	{
		::DeleteDC(hMemDC1);
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	} // if

	HBITMAP		hGrayBitmap = ::CreateCompatibleBitmap(hMainDC, dwWidth, dwHeight);

	if (hGrayBitmap)
	{
		HBITMAP		hOldBmp1 = (HBITMAP)::SelectObject(hMemDC1, hGrayBitmap);
		HBITMAP		hOldBmp2 = (HBITMAP)::SelectObject(hMemDC2, hBitmap);
		DWORD		dwLoopY, dwLoopX;
		COLORREF	crPixel;

		for (dwLoopY = 0; dwLoopY < dwHeight; dwLoopY++)
		{
			for (dwLoopX = 0; dwLoopX < dwWidth; dwLoopX++)
			{
				crPixel = ::GetPixel(hMemDC2, dwLoopX, dwLoopY);

				if (crPixel != crTrans)
					::SetPixel(hMemDC1, dwLoopX, dwLoopY, DarkenColor(crPixel, 0.25));
				else
					::SetPixel(hMemDC1, dwLoopX, dwLoopY, crPixel);
			} // for
		} // for

		::SelectObject(hMemDC1, hOldBmp1);
		::SelectObject(hMemDC2, hOldBmp2);
	} // if

	::DeleteDC(hMemDC1);
	::DeleteDC(hMemDC2);
	::ReleaseDC(NULL, hMainDC);

	return hGrayBitmap;
} // End of CreateDarkerBitmap

// This function creates a grayscale icon starting from a given icon.
// The resulting icon will have the same size of the original one.
//
// Parameters:
//		[IN]	hIcon
//				Handle to the original icon.
//
// Return value:
//		If the function succeeds, the return value is the handle to the newly created
//		grayscale icon.
//		If the function fails, the return value is NULL.
//
// Updates:
//		26/Nov/2002	Restored 1 BitBlt operation
//		03/May/2002	Removed dependancy from m_hWnd
//					Removed 1 BitBlt operation
//
HICON CButtonST::CreateGrayscaleIcon(HICON hIcon)
{
	ICONINFO	csII;
	
	if (!::GetIconInfo(hIcon, &csII))
		return NULL;

	HDC			hMainDC = ::GetDC(HWND_DESKTOP);

	if (hMainDC == NULL)
		return NULL;

	HDC			hMemDC1 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC1 == NULL)
	{
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	}

	HDC			hMemDC2 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC2 == NULL)
	{
		::DeleteDC(hMemDC1);
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	}

	HICON		hGrayIcon = NULL;
	BITMAP		bmp;
	ICONINFO	csGrayII;

	if (::GetObject(csII.hbmColor, sizeof(BITMAP), &bmp))
	{
		DWORD		dwWidth = csII.xHotspot * 2;
		DWORD		dwHeight = csII.yHotspot * 2;

		csGrayII.hbmColor = ::CreateBitmap(dwWidth, dwHeight, bmp.bmPlanes, bmp.bmBitsPixel, NULL);

		if (csGrayII.hbmColor)
		{
			HBITMAP		hOldBmp1 = (HBITMAP)::SelectObject(hMemDC1, csII.hbmColor);
			HBITMAP		hOldBmp2 = (HBITMAP)::SelectObject(hMemDC2, csGrayII.hbmColor);
			DWORD		dwLoopY, dwLoopX;
			COLORREF	crPixel;
			BYTE		byNewPixel;

			for (dwLoopY = 0; dwLoopY < dwHeight; dwLoopY++)
			{
				for (dwLoopX = 0; dwLoopX < dwWidth; dwLoopX++)
				{
					crPixel = ::GetPixel(hMemDC1, dwLoopX, dwLoopY);

					byNewPixel = (BYTE)((GetRValue(crPixel) * 0.299) + (GetGValue(crPixel) * 0.587) + (GetBValue(crPixel) * 0.114));
					if (crPixel)
						::SetPixel(hMemDC2, dwLoopX, dwLoopY, DarkenColor(crPixel, 0.25));
					else
						::SetPixel(hMemDC2, dwLoopX, dwLoopY, crPixel);
				} // for
			} // for

			::SelectObject(hMemDC1, hOldBmp1);
			::SelectObject(hMemDC2, hOldBmp2);

			csGrayII.hbmMask = csII.hbmMask;

			csGrayII.fIcon = TRUE;
			hGrayIcon = ::CreateIconIndirect(&csGrayII);
		} // if

		::DeleteObject(csGrayII.hbmColor);
		//::DeleteObject(csGrayII.hbmMask);
	} // if

	::DeleteObject(csII.hbmColor);
	::DeleteObject(csII.hbmMask);
	::DeleteDC(hMemDC1);
	::DeleteDC(hMemDC2);
	::ReleaseDC(NULL, hMainDC);

	return hGrayIcon;
} // End of CreateGrayscaleIcon

// This function creates a icon that is 25% darker than the original.
// The resulting icon will have the same size of the original one.
//
// Parameters:
//		[IN]	hIcon
//				Handle to the original icon.
//
// Return value:
//		If the function succeeds, the return value is the handle to the newly created
//		darker icon.
//		If the function fails, the return value is NULL.
//
HICON CButtonST::CreateDarkerIcon(HICON hIcon)
{
	ICONINFO	csII;

	if (!::GetIconInfo(hIcon, &csII))
		return NULL;

	HDC			hMainDC = ::GetDC(NULL);

	if (hMainDC == NULL)
		return NULL;

	HDC			hMemDC1 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC1 == NULL)
	{
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	}

	HDC			hMemDC2 = ::CreateCompatibleDC(hMainDC);

	if (hMemDC2 == NULL)
	{
		::DeleteDC(hMemDC1);
		::ReleaseDC(NULL, hMainDC);
		return NULL;
	}

	HICON		hGrayIcon = NULL;
	BITMAP		bmp;
	ICONINFO	csGrayII;

	if (::GetObject(csII.hbmColor, sizeof(BITMAP), &bmp))
	{
		DWORD	dwWidth = csII.xHotspot * 2;
		DWORD	dwHeight = csII.yHotspot * 2;

		csGrayII.hbmColor = ::CreateBitmap(dwWidth, dwHeight, bmp.bmPlanes, bmp.bmBitsPixel, NULL);
		if (csGrayII.hbmColor)
		{
			HBITMAP		hOldBmp1 = (HBITMAP)::SelectObject(hMemDC1, csII.hbmColor);
			HBITMAP		hOldBmp2 = (HBITMAP)::SelectObject(hMemDC2, csGrayII.hbmColor);
			DWORD		dwLoopY, dwLoopX;
			COLORREF	crPixel;

			for (dwLoopY = 0; dwLoopY < dwHeight; dwLoopY++)
			{
				for (dwLoopX = 0; dwLoopX < dwWidth; dwLoopX++)
				{
					crPixel = ::GetPixel(hMemDC1, dwLoopX, dwLoopY);

					if (crPixel)	
						::SetPixel(hMemDC2, dwLoopX, dwLoopY, DarkenColor(crPixel, 0.25));
					else
						::SetPixel(hMemDC2, dwLoopX, dwLoopY, crPixel);
				} // for
			} // for

			::SelectObject(hMemDC1, hOldBmp1);
			::SelectObject(hMemDC2, hOldBmp2);

			csGrayII.hbmMask = csII.hbmMask;

			csGrayII.fIcon = TRUE;
			hGrayIcon = ::CreateIconIndirect(&csGrayII);
		} // if

		::DeleteObject(csGrayII.hbmColor);
		//::DeleteObject(csGrayII.hbmMask);
	} // if

	::DeleteObject(csII.hbmColor);
	::DeleteObject(csII.hbmMask);
	::DeleteDC(hMemDC1);
	::DeleteDC(hMemDC2);
	::ReleaseDC(NULL, hMainDC);

	return hGrayIcon;
} // End of CreateDarkerIcon

COLORREF CButtonST::DarkenColor(COLORREF crColor, double dFactor)
{
	if (dFactor > 0.0 && dFactor <= 1.0)
	{
		BYTE		byRed = GetRValue(crColor);
		BYTE		byGreen = GetGValue(crColor);
		BYTE		byBlue = GetBValue(crColor);

		crColor = RGB((BYTE)(byRed - (dFactor * byRed)), (BYTE)(byGreen - (dFactor * byGreen)), (BYTE)(byBlue - (dFactor * byBlue)));
	} // if

	return crColor;
} // End of DarkenColor

// This function assigns icons to the button.
// Any previous icon or bitmap will be removed.
//
// Parameters:
//		[IN]	nIconIn
//				ID number of the icon resource to show when the mouse is over the button.
//				Pass NULL to remove any icon from the button.
//		[IN]	nCxDesiredIn
//				Specifies the width, in pixels, of the icon to load.
//		[IN]	nCyDesiredIn
//				Specifies the height, in pixels, of the icon to load.
//		[IN]	nIconOut
//				ID number of the icon resource to show when the mouse is outside the button.
//				Can be NULL.
//				If this parameter is the special value BTNST_AUTO_GRAY (cast to int) the second
//				icon will be automatically created starting from nIconIn and converted to grayscale.
//				If this parameter is the special value BTNST_AUTO_DARKER (cast to int) the second
//				icon will be automatically created 25% darker starting from nIconIn.
//		[IN]	nCxDesiredOut
//				Specifies the width, in pixels, of the icon to load.
//		[IN]	nCyDesiredOut
//				Specifies the height, in pixels, of the icon to load.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//
DWORD CButtonST::SetIcon(int nIconIn, int nCxDesiredIn, int nCyDesiredIn, int nIconOut, int nCxDesiredOut, int nCyDesiredOut)
{
	NOPRM(nCxDesiredIn); NOPRM(nCyDesiredIn);
	// Find correct resource handle
	HINSTANCE	hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nIconIn), RT_GROUP_ICON);
	// Set icon when the mouse is IN the button
	HICON		hIconIn = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nIconIn), IMAGE_ICON, 0, 0, 0), hIconOut = NULL;

  	// Set icon when the mouse is OUT the button
	switch (nIconOut)
	{
		case NULL:
			break;
		case (int)BTNST_AUTO_GRAY:
			hIconOut = BTNST_AUTO_GRAY;
			break;
		case (int)BTNST_AUTO_DARKER:
			hIconOut = BTNST_AUTO_DARKER;
			break;
		default:
			hIconOut = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nIconOut), IMAGE_ICON, nCxDesiredOut, nCyDesiredOut, 0);
			break;
	} // switch

	return SetIcon(hIconIn, hIconOut);
} // End of SetIcon

// This function assigns icons to the button.
// Any previous icon or bitmap will be removed.
//
// Parameters:
//		[IN]	nIconIn
//				ID number of the icon resource to show when the mouse is over the button.
//				Pass NULL to remove any icon from the button.
//		[IN]	nIconOut
//				ID number of the icon resource to show when the mouse is outside the button.
//				Can be NULL.
//				If this parameter is the special value BTNST_AUTO_GRAY (cast to int) the second
//				icon will be automatically created starting from nIconIn and converted to grayscale.
//				If this parameter is the special value BTNST_AUTO_DARKER (cast to int) the second
//				icon will be automatically created 25% darker starting from nIconIn.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//
DWORD CButtonST::SetIcon(int nIconIn, int nIconOut)
{
	return SetIcon(nIconIn, 0, 0, nIconOut, 0, 0);
} // End of SetIcon

// This function assigns icons to the button.
// Any previous icon or bitmap will be removed.
//
// Parameters:
//		[IN]	hIconIn
//				Handle fo the icon to show when the mouse is over the button.
//				Pass NULL to remove any icon from the button.
//		[IN]	hIconOut
//				Handle to the icon to show when the mouse is outside the button.
//				Can be NULL.
//				If this parameter is the special value BTNST_AUTO_GRAY the second
//				icon will be automatically created starting from hIconIn and converted to grayscale.
//				If this parameter is the special value BTNST_AUTO_DARKER the second
//				icon will be automatically created 25% darker starting from hIconIn.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//
DWORD CButtonST::SetIcon(HICON hIconIn, HICON hIconOut)
{
	// Free any loaded resource
	FreeResources();

	if (hIconIn != NULL)
	{
		ICONINFO	ii;

		// Icon when mouse over button?
		m_csIcons[0].hIcon = hIconIn;
		// Get icon dimension
		memzero(&ii, sizeof(ICONINFO));

		if (!::GetIconInfo(hIconIn, &ii))
		{
			FreeResources();
			return BTNST_INVALIDRESOURCE;
		} // if

		m_csIcons[0].dwWidth	= (DWORD)(ii.xHotspot * 2);
		m_csIcons[0].dwHeight	= (DWORD)(ii.yHotspot * 2);
		::DeleteObject(ii.hbmMask);
		::DeleteObject(ii.hbmColor);

		// Icon when mouse outside button?
		if (hIconOut != NULL)
		{
			switch ((int)hIconOut)
			{
				case (int)BTNST_AUTO_GRAY:
					hIconOut = CreateGrayscaleIcon(hIconIn);
					break;
				case (int)BTNST_AUTO_DARKER:
					hIconOut = CreateDarkerIcon(hIconIn);
					break;
			} // switch

			m_csIcons[1].hIcon = hIconOut;
			// Get icon dimension
			memzero(&ii, sizeof(ICONINFO));

			if (!::GetIconInfo(hIconOut, &ii))
			{
				FreeResources();
				return BTNST_INVALIDRESOURCE;
			} // if

			m_csIcons[1].dwWidth	= (DWORD)(ii.xHotspot * 2);
			m_csIcons[1].dwHeight	= (DWORD)(ii.yHotspot * 2);
			::DeleteObject(ii.hbmMask);
			::DeleteObject(ii.hbmColor);
		} // if
	} // if

	Invalidate();

	return BTNST_OK;
} // End of SetIcon

// This function assigns bitmaps to the button.
// Any previous icon or bitmap will be removed.
//
// Parameters:
//		[IN]	nBitmapIn
//				ID number of the bitmap resource to show when the mouse is over the button.
//				Pass NULL to remove any bitmap from the button.
//		[IN]	crTransColorIn
//				Color (inside nBitmapIn) to be used as transparent color.
//		[IN]	nBitmapOut
//				ID number of the bitmap resource to show when the mouse is outside the button.
//				Can be NULL.
//		[IN]	crTransColorOut
//				Color (inside nBitmapOut) to be used as transparent color.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//		BTNST_FAILEDMASK
//			Failed creating mask bitmap.
//
DWORD CButtonST::SetBitmaps(int nBitmapIn, COLORREF crTransColorIn, int nBitmapOut, COLORREF crTransColorOut)
{
	// Find correct resource handle
	HINSTANCE		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapIn), RT_BITMAP);
	// Load bitmap In
	HBITMAP			hBitmapIn = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nBitmapIn), IMAGE_BITMAP, 0, 0, 0);
	HBITMAP			hBitmapOut = NULL;

	// Load bitmap Out
	switch (nBitmapOut)
	{
		case NULL:
			break;
		case (int)BTNST_AUTO_GRAY:
			hBitmapOut = (HBITMAP)BTNST_AUTO_GRAY;
			break;
		case (int)BTNST_AUTO_DARKER:
			hBitmapOut = (HBITMAP)BTNST_AUTO_DARKER;
			break;
		default:
			hBitmapOut = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nBitmapOut), IMAGE_BITMAP, 0, 0, 0);
			break;
	} // switch

	return SetBitmaps(hBitmapIn, crTransColorIn, hBitmapOut, crTransColorOut);
} // End of SetBitmaps

// This function assigns bitmaps to the button.
// Any previous icon or bitmap will be removed.
//
// Parameters:
//		[IN]	hBitmapIn
//				Handle fo the bitmap to show when the mouse is over the button.
//				Pass NULL to remove any bitmap from the button.
//		[IN]	crTransColorIn
//				Color (inside hBitmapIn) to be used as transparent color.
//		[IN]	hBitmapOut
//				Handle to the bitmap to show when the mouse is outside the button.
//				Can be NULL.
//		[IN]	crTransColorOut
//				Color (inside hBitmapOut) to be used as transparent color.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//		BTNST_FAILEDMASK
//			Failed creating mask bitmap.
//
DWORD CButtonST::SetBitmaps(HBITMAP hBitmapIn, COLORREF crTransColorIn, HBITMAP hBitmapOut, COLORREF crTransColorOut)
{
	// Free any loaded resource
	FreeResources();

	if (hBitmapIn != NULL)
	{
		m_csBitmaps[0].hBitmap = hBitmapIn;
		m_csBitmaps[0].crTransparent = crTransColorIn;

		BITMAP		csBitmapSize;

		// Get bitmap size
		if (::GetObject(hBitmapIn, sizeof(csBitmapSize), &csBitmapSize) == 0)
		{
			FreeResources();
			return BTNST_INVALIDRESOURCE;
		} // if
		m_csBitmaps[0].dwWidth = (DWORD)csBitmapSize.bmWidth;
		m_csBitmaps[0].dwHeight = (DWORD)csBitmapSize.bmHeight;

		// Create grayscale/darker bitmap BEFORE mask (of hBitmapIn)
		switch ((int)hBitmapOut)
		{
			case (int)BTNST_AUTO_GRAY:
				hBitmapOut = CreateGrayscaleBitmap(hBitmapIn, m_csBitmaps[0].dwWidth, m_csBitmaps[0].dwHeight, crTransColorIn);
				m_csBitmaps[1].hBitmap = hBitmapOut;
				crTransColorOut = crTransColorIn;
				break;
			case (int)BTNST_AUTO_DARKER:
				hBitmapOut = CreateDarkerBitmap(hBitmapIn, m_csBitmaps[0].dwWidth, m_csBitmaps[0].dwHeight, crTransColorIn);
				m_csBitmaps[1].hBitmap = hBitmapOut;
				crTransColorOut = crTransColorIn;
				break;
		} // switch

		// Create mask for bitmap In
		m_csBitmaps[0].hMask = CreateBitmapMask(hBitmapIn, m_csBitmaps[0].dwWidth, m_csBitmaps[0].dwHeight, crTransColorIn);
		if (m_csBitmaps[0].hMask == NULL)
		{
			FreeResources();
			return BTNST_FAILEDMASK;
		} // if

		if (hBitmapOut != NULL)
		{
			m_csBitmaps[1].hBitmap = hBitmapOut;
			m_csBitmaps[1].crTransparent = crTransColorOut;
			// Get bitmap size
			if (::GetObject(hBitmapOut, sizeof(csBitmapSize), &csBitmapSize) == 0)
			{
				FreeResources();
				return BTNST_INVALIDRESOURCE;
			} // if
			m_csBitmaps[1].dwWidth = (DWORD)csBitmapSize.bmWidth;
			m_csBitmaps[1].dwHeight = (DWORD)csBitmapSize.bmHeight;

			// Create mask for bitmap Out
			m_csBitmaps[1].hMask = CreateBitmapMask(hBitmapOut, m_csBitmaps[1].dwWidth, m_csBitmaps[1].dwHeight, crTransColorOut);
			if (m_csBitmaps[1].hMask == NULL)
			{
				FreeResources();
				return BTNST_FAILEDMASK;
			} // if
		} // if
	} // if

	Invalidate();

	return BTNST_OK;
} // End of SetBitmaps

// This functions sets the button to have a standard or flat style.
//
// Parameters:
//		[IN]	bFlat
//				If TRUE the button will have a flat style, else
//				will have a standard style.
//				By default, CButtonST buttons are flat.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetFlat(BOOL bFlat, BOOL bRepaint)
{
	m_bIsFlat = bFlat;
	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetFlat

// This functions sets the button to have a PushLike style.
//
// Parameters:
//		[IN]	bPushLike
//				If TRUE the button will have a PushLike style, else
//				will have a standard style.
//				By default, CButtonST buttons are not PushLike.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetPushLike(BOOL bPushLike, BOOL bRepaint)
{
	m_bIsPushLike = bPushLike;
	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetPushLike

// This function sets the alignment type between icon/bitmap and text.
//
// Parameters:
//		[IN]	byAlign
//				Alignment type. Can be one of the following values:
//				ST_ALIGN_HORIZ			Icon/bitmap on the left, text on the right
//				ST_ALIGN_VERT			Icon/bitmap on the top, text on the bottom
//				ST_ALIGN_HORIZ_RIGHT	Icon/bitmap on the right, text on the left
//				ST_ALIGN_OVERLAP		Icon/bitmap on the same space as text
//				By default, CButtonST buttons have ST_ALIGN_HORIZ alignment.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDALIGN
//			Alignment type not supported.
//
DWORD CButtonST::SetAlign(BYTE byAlign, BOOL bRepaint)
{
	switch (byAlign)
	{    
		case ST_ALIGN_HORIZ:
		case ST_ALIGN_HORIZ_RIGHT:
		case ST_ALIGN_VERT:
		case ST_ALIGN_OVERLAP:
			m_byAlign = byAlign;
			if (bRepaint)
				Invalidate();
			return BTNST_OK;
	} // switch

	return BTNST_INVALIDALIGN;
} // End of SetAlign

// This function sets the pressed style.
//
// Parameters:
//		[IN]	byStyle
//				Pressed style. Can be one of the following values:
//				BTNST_PRESSED_LEFTRIGHT		Pressed style from left to right (as usual)
//				BTNST_PRESSED_TOPBOTTOM		Pressed style from top to bottom
//				By default, CButtonST buttons have BTNST_PRESSED_LEFTRIGHT style.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDPRESSEDSTYLE
//			Pressed style not supported.
//
DWORD CButtonST::SetPressedStyle(BYTE byStyle, BOOL bRepaint)
{
	switch (byStyle)
	{
		case BTNST_PRESSED_LEFTRIGHT:
			m_ptPressedOffset.x = 1;
			m_ptPressedOffset.y = 1;
			break;
		case BTNST_PRESSED_TOPBOTTOM:
			m_ptPressedOffset.x = 0;
			m_ptPressedOffset.y = 2;
			break;
		default:
			return BTNST_INVALIDPRESSEDSTYLE;
	} // switch

	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetPressedStyle

// This function sets the state of the checkbox.
// If the button is not a checkbox, this function has no meaning.
//
// Parameters:
//		[IN]	nCheck
//				1 to check the checkbox.
//				0 to un-check the checkbox.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetCheck(int nCheck, BOOL bRepaint)
{
	if (m_bIsCheckBox)
	{
		m_nCheck = (bool)(nCheck != 0);

		if (bRepaint)
			Invalidate();
	} // if

	return BTNST_OK;
} // End of SetCheck

// This function returns the current state of the checkbox.
// If the button is not a checkbox, this function has no meaning.
//
// Return value:
//		The current state of the checkbox.
//			1 if checked.
//			0 if not checked or the button is not a checkbox.
//
int CButtonST::GetCheck()
{
	return m_nCheck;
} // End of GetCheck

// This function sets all colors to a default value.
//
// Parameters:
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetDefaultColors(BOOL bRepaint)
{
	m_crColors[BTNST_COLOR_BK_IN]		= ::GetSysColor(COLOR_BTNFACE);
	m_crColors[BTNST_COLOR_FG_IN]		= ::GetSysColor(COLOR_BTNTEXT);
	m_crColors[BTNST_COLOR_BK_OUT]		= ::GetSysColor(COLOR_BTNFACE);
	m_crColors[BTNST_COLOR_FG_OUT]		= ::GetSysColor(COLOR_BTNTEXT);
	m_crColors[BTNST_COLOR_BK_FOCUS]	= ::GetSysColor(COLOR_BTNFACE);
	m_crColors[BTNST_COLOR_FG_FOCUS]	= ::GetSysColor(COLOR_BTNTEXT);

	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetDefaultColors

// This function sets the color to use for a particular state.
//
// Parameters:
//		[IN]	byColorIndex
//				Index of the color to set. Can be one of the following values:
//				BTNST_COLOR_BK_IN		Background color when mouse is over the button
//				BTNST_COLOR_FG_IN		Text color when mouse is over the button
//				BTNST_COLOR_BK_OUT		Background color when mouse is outside the button
//				BTNST_COLOR_FG_OUT		Text color when mouse is outside the button
//				BTNST_COLOR_BK_FOCUS	Background color when the button is focused
//				BTNST_COLOR_FG_FOCUS	Text color when the button is focused
//		[IN]	crColor
//				New color.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDINDEX
//			Invalid color index.
//
DWORD CButtonST::SetColor(BYTE byColorIndex, COLORREF crColor, BOOL bRepaint)
{
	if (byColorIndex >= BTNST_MAX_COLORS)
		return BTNST_INVALIDINDEX;

	// Set new color
	m_crColors[byColorIndex] = crColor;

	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetColor

// This functions returns the color used for a particular state.
//
// Parameters:
//		[IN]	byColorIndex
//				Index of the color to get.
//				See SetColor for the list of available colors.
//		[OUT]	crpColor
//				A pointer to a COLORREF that will receive the color.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDINDEX
//			Invalid color index.
//
DWORD CButtonST::GetColor(BYTE byColorIndex, COLORREF* crpColor)
{
	if (byColorIndex >= BTNST_MAX_COLORS)
		return BTNST_INVALIDINDEX;

	// Get color
	*crpColor = m_crColors[byColorIndex];

	return BTNST_OK;
} // End of GetColor

// This function applies an offset to the RGB components of the specified color.
// This function can be seen as an easy way to make a color darker or lighter than
// its default value.
//
// Parameters:
//		[IN]	byColorIndex
//				Index of the color to set.
//				See SetColor for the list of available colors.
//		[IN]	shOffsetColor
//				A short value indicating the offset to apply to the color.
//				This value must be between -255 and 255.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDINDEX
//			Invalid color index.
//		BTNST_BADPARAM
//			The specified offset is out of range.
//
DWORD CButtonST::OffsetColor(BYTE byColorIndex, short shOffset, BOOL bRepaint)
{
	if (byColorIndex >= BTNST_MAX_COLORS)
		return BTNST_INVALIDINDEX;

	if (shOffset < -255 || shOffset > 255)
		return BTNST_BADPARAM;

	short		shOffsetR = shOffset;
	short		shOffsetG = shOffset;
	short		shOffsetB = shOffset;
	// Get RGB components of specified color
	BYTE		byRed = GetRValue(m_crColors[byColorIndex]);
	BYTE		byGreen = GetGValue(m_crColors[byColorIndex]);
	BYTE		byBlue = GetBValue(m_crColors[byColorIndex]);

	// Calculate max. allowed real offset
	if (shOffset > 0)
	{
		if (byRed + shOffset > 255)
			shOffsetR = 255 - byRed;
		if (byGreen + shOffset > 255)
			shOffsetG = 255 - byGreen;
		if (byBlue + shOffset > 255)
			shOffsetB = 255 - byBlue;

		shOffset = min(min(shOffsetR, shOffsetG), shOffsetB);
	} // if
	else
	{
		if (byRed + shOffset < 0)
			shOffsetR = -byRed;
		if (byGreen + shOffset < 0)
			shOffsetG = -byGreen;
		if (byBlue + shOffset < 0)
			shOffsetB = -byBlue;

		shOffset = max(max(shOffsetR, shOffsetG), shOffsetB);
	} // else

	// Set new color
	m_crColors[byColorIndex] = RGB(byRed + shOffset, byGreen + shOffset, byBlue + shOffset);

	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of OffsetColor

// This function sets the hilight logic for the button.
// Applies only to flat buttons.
//
// Parameters:
//		[IN]	bAlwaysTrack
//				If TRUE the button will be hilighted even if the window that owns it, is
//				not the active window.
//				If FALSE the button will be hilighted only if the window that owns it,
//				is the active window.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetAlwaysTrack(BOOL bAlwaysTrack)
{
	m_bAlwaysTrack = bAlwaysTrack;
	return BTNST_OK;
} // End of SetAlwaysTrack

// This function sets the cursor to be used when the mouse is over the button.
//
// Parameters:
//		[IN]	nCursorId
//				ID number of the cursor resource.
//				Pass NULL to remove a previously loaded cursor.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//
DWORD CButtonST::SetBtnCursor(int nCursorId, BOOL bRepaint)
{
	// Destroy any previous cursor
	if (m_hCursor != NULL)
	{
		::DestroyCursor(m_hCursor);
		m_hCursor = NULL;
	} // if

	// Load cursor
	if (nCursorId != NULL)
	{
		HINSTANCE		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nCursorId), RT_GROUP_CURSOR);

		// Load cursor resource
		m_hCursor = (HCURSOR)::LoadImage(hInstResource, MAKEINTRESOURCE(nCursorId), IMAGE_CURSOR, 0, 0, 0);
		// Repaint the button
		if (bRepaint)
			Invalidate();
		// If something wrong
		if (m_hCursor == NULL)
			return BTNST_INVALIDRESOURCE;
	} // if

	return BTNST_OK;
} // End of SetBtnCursor

// This function sets if the button border must be drawn.
// Applies only to flat buttons.
//
// Parameters:
//		[IN]	bDrawBorder
//				If TRUE the border will be drawn.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::DrawBorder(BOOL bDrawBorder, BOOL bRepaint)
{
	m_bDrawBorder = bDrawBorder;
	// Repaint the button
	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of DrawBorder

// This function sets if the focus rectangle must be drawn for flat buttons.
//
// Parameters:
//		[IN]	bDrawFlatFocus
//				If TRUE the focus rectangle will be drawn also for flat buttons.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::DrawFlatFocus(BOOL bDrawFlatFocus, BOOL bRepaint)
{
	m_bDrawFlatFocus = bDrawFlatFocus;
	// Repaint the button
	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of DrawFlatFocus

void CButtonST::InitToolTip()
{
	if (m_ToolTip.m_hWnd == NULL)
	{
		// Create ToolTip control
		m_ToolTip.Create(this, m_dwToolTipStyle);
		// Create inactive
		m_ToolTip.Activate(FALSE);
		// Enable multiline
		m_ToolTip.SendMessage(TTM_SETMAXTIPWIDTH, 0, 400);
		//m_ToolTip.SendMessage(TTM_SETTITLE, TTI_INFO, (LPARAM)_T("Title"));
	} // if
} // End of InitToolTip

// This function sets the text to show in the button tooltip.
//
// Parameters:
//		[IN]	nText
//				ID number of the string resource containing the text to show.
//		[IN]	bActivate
//				If TRUE the tooltip will be created active.
//
void CButtonST::SetTooltipText(int nText, BOOL bActivate)
{
	CString		strText;

	// Load string resource
	strText.LoadString(nText);
	// If string resource is not empty
	if (!strText.IsEmpty())
		SetTooltipText((LPCTSTR)strText, bActivate);
} // End of SetTooltipText

// This function sets the text to show in the button tooltip.
//
// Parameters:
//		[IN]	lpszText
//				Pointer to a null-terminated string containing the text to show.
//		[IN]	bActivate
//				If TRUE the tooltip will be created active.
//
void CButtonST::SetTooltipText(LPCTSTR lpszText, BOOL bActivate)
{
	// We cannot accept NULL pointer
	if (lpszText == NULL)
		return;

	// Initialize ToolTip
	InitToolTip();

	// If there is no tooltip defined then add it
	if (m_ToolTip.GetToolCount() == 0)
	{
		CRect		rectBtn; 

		GetClientRect(rectBtn);
		m_ToolTip.AddTool(this, lpszText, rectBtn, 1);
	} // if

	// Set text for tooltip
	m_ToolTip.UpdateTipText(lpszText, this, 1);
	m_ToolTip.Activate(bActivate);
} // End of SetTooltipText

// This function enables or disables the button tooltip.
//
// Parameters:
//		[IN]	bActivate
//				If TRUE the tooltip will be activated.
//
void CButtonST::ActivateTooltip(BOOL bActivate)
{
	// If there is no tooltip then do nothing
	if (m_ToolTip.GetToolCount() == 0)
		return;

	// Activate tooltip
	m_ToolTip.Activate(bActivate);
} // End of EnableTooltip

// This function enables the tooltip to be displayed using the balloon style.
// This function must be called before any call to SetTooltipText is made.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::EnableBalloonTooltip()
{
	m_dwToolTipStyle |= TTS_BALLOON;

	return BTNST_OK;
} // End of EnableBalloonTooltip

// This function returns if the button is the default button.
//
// Return value:
//		TRUE
//			The button is the default button.
//		FALSE
//			The button is not the default button.
//
BOOL CButtonST::GetDefault()
{
	return m_bIsDefault;
} // End of GetDefault

// This function enables the transparent mode.
// Note: this operation is not reversible.
// DrawTransparent should be called just after the button is created.
// Do not use trasparent buttons until you really need it (you have a bitmapped
// background) since each transparent button makes a copy in memory of its background.
// This may bring unnecessary memory use and execution overload.
//
// Parameters:
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
void CButtonST::DrawTransparent(BOOL bRepaint)
{
	m_bDrawTransparent = TRUE;

	// Restore old bitmap (if any)
	if (m_dcBk.m_hDC != NULL && m_pbmpOldBk != NULL)
		m_dcBk.SelectObject(m_pbmpOldBk);

	m_bmpBk.DeleteObject();
	m_dcBk.DeleteDC();

	// Repaint the button
	if (bRepaint)
		Invalidate();
} // End of DrawTransparent

DWORD CButtonST::SetBk(CDC* pDC)
{
	if (m_bDrawTransparent && pDC != NULL)
	{
		// Restore old bitmap (if any)
		if (m_dcBk.m_hDC != NULL && m_pbmpOldBk != NULL)
			m_dcBk.SelectObject(m_pbmpOldBk);

		m_bmpBk.DeleteObject();
		m_dcBk.DeleteDC();

		CRect		rect, rect1;

		GetClientRect(rect);
		GetWindowRect(rect1);
		GetParent()->ScreenToClient(rect1);

		m_dcBk.CreateCompatibleDC(pDC);
		m_bmpBk.CreateCompatibleBitmap(pDC, rect.Width(), rect.Height());
		m_pbmpOldBk = m_dcBk.SelectObject(&m_bmpBk);
		m_dcBk.BitBlt(0, 0, rect.Width(), rect.Height(), pDC, rect1.left, rect1.top, SRCCOPY);

		return BTNST_OK;
	} // if

	return BTNST_BADPARAM;
} // End of SetBk

// This function sets the URL that will be opened when the button is clicked.
//
// Parameters:
//		[IN]	lpszURL
//				Pointer to a null-terminated string that contains the URL.
//				Pass NULL to removed any previously specified URL.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetURL(LPCTSTR lpszURL)
{
	m_szURL[0] = _T('\0');	// Remove any existing URL

	if (lpszURL != NULL)
	{
		_tcsncpy(m_szURL, lpszURL, ARRSIZE(m_szURL));	// Store the URL
		m_szURL[ARRSIZE(m_szURL) - 1] = _T('\0');
	}

	return BTNST_OK;
}

// This function associates a menu to the button.
// The menu will be displayed clicking the button.
//
// Parameters:
//		[IN]	nMenu
//				ID number of the menu resource.
//				Pass NULL to remove any menu from the button.
//		[IN]	hParentWnd
//				Handle to the window that owns the menu.
//				This window receives all messages from the menu.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//
#ifndef	BTNST_USE_BCMENU
DWORD CButtonST::SetMenu(UINT nMenu, HWND hParentWnd, BOOL bRepaint)
{
	// Destroy any previous menu
	if (m_hMenu != NULL)
	{
		VERIFY( ::DestroyMenu(m_hMenu) );
		m_hMenu = NULL;
		m_hParentWndMenu = NULL;
		m_bMenuDisplayed = FALSE;
	} // if

	// Load menu
	if (nMenu != NULL)
	{
		// Find correct resource handle
		HINSTANCE		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nMenu), RT_MENU);
		// Load menu resource
		m_hMenu = ::LoadMenu(hInstResource, MAKEINTRESOURCE(nMenu));
		m_hParentWndMenu = hParentWnd;
		// If something wrong
		if (m_hMenu == NULL)
			return BTNST_INVALIDRESOURCE;
	} // if

	// Repaint the button
	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetMenu
#endif

// This function associates a menu to the button.
// The menu will be displayed clicking the button.
// The menu will be handled by the BCMenu class.
//
// Parameters:
//		[IN]	nMenu
//				ID number of the menu resource.
//				Pass NULL to remove any menu from the button.
//		[IN]	hParentWnd
//				Handle to the window that owns the menu.
//				This window receives all messages from the menu.
//		[IN]	bWinXPStyle
//				If TRUE the menu will be displayed using the new Windows XP style.
//				If FALSE the menu will be displayed using the standard style.
//		[IN]	nToolbarID
//				Resource ID of the toolbar to be associated to the menu.
//		[IN]	sizeToolbarIcon
//				A CSize object indicating the size (in pixels) of each icon into the toolbar.
//				All icons into the toolbar must have the same size.
//		[IN]	crToolbarBk
//				A COLORREF value indicating the color to use as background for the icons into the toolbar.
//				This color will be used as the "transparent" color.
//		[IN]	bRepaint
//				If TRUE the control will be repainted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//		BTNST_INVALIDRESOURCE
//			Failed loading the specified resource.
//
#ifdef	BTNST_USE_BCMENU
DWORD CButtonST::SetMenu(UINT nMenu, HWND hParentWnd, BOOL bWinXPStyle, UINT nToolbarID, CSize sizeToolbarIcon, COLORREF crToolbarBk, BOOL bRepaint)
{
	// Destroy any previous menu
	if (m_menuPopup.m_hMenu != NULL)
	{
		VERIFY( m_menuPopup.DestroyMenu() );
		m_hParentWndMenu = NULL;
		m_bMenuDisplayed = FALSE;
	} // if

	// Load menu
	if (nMenu != NULL)
	{
		m_menuPopup.SetMenuDrawMode(bWinXPStyle);
		// Load menu
		if (!m_menuPopup.LoadMenu(nMenu))
			return BTNST_INVALIDRESOURCE;

		// Load toolbar
		if (nToolbarID != NULL)
		{
			m_menuPopup.SetBitmapBackground(crToolbarBk);
			m_menuPopup.SetIconSize(sizeToolbarIcon.cx, sizeToolbarIcon.cy);

			if (!m_menuPopup.LoadToolbar(nToolbarID)) 
			{
				VERIFY( m_menuPopup.DestroyMenu() );
				return BTNST_INVALIDRESOURCE;
			} // if
		} // if

		m_hParentWndMenu = hParentWnd;
	} // if

	// Repaint the button
	if (bRepaint)
		Invalidate();

	return BTNST_OK;
} // End of SetMenu
#endif

// This function sets the callback message that will be sent to the
// specified window just before the menu associated to the button is displayed.
//
// Parameters:
//		[IN]	hWnd
//				Handle of the window that will receive the callback message.
//				Pass NULL to remove any previously specified callback message.
//		[IN]	nMessage
//				Callback message to send to window.
//		[IN]	lParam
//				A 32 bits user specified value that will be passed to the callback function.
//
// Remarks:
//		the callback function must be in the form:
//		LRESULT On_MenuCallback(WPARAM wParam, LPARAM lParam)
//		Where:
//				[IN]	wParam
//						If support for BCMenu is enabled: a pointer to BCMenu
//						else a HMENU handle to the menu that is being to be displayed.
//				[IN]	lParam
//						The 32 bits user specified value.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::SetMenuCallback(HWND hWnd, UINT nMessage, LPARAM lParam)
{
	m_csCallbacks.hWnd = hWnd;
	m_csCallbacks.nMessage = nMessage;
	m_csCallbacks.lParam = lParam;

	return BTNST_OK;
} // End of SetMenuCallback

// This function resizes the button to the same size of the image.
// To get good results both the IN and OUT images should have the same size.
//
void CButtonST::SizeToContent()
{
	if (m_csIcons[0].hIcon)
	{
		m_ptImageOrg.x = 0;
		m_ptImageOrg.y = 0;
	    SetWindowPos(NULL, -1, -1, m_csIcons[0].dwWidth, m_csIcons[0].dwHeight,
						SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
	} // if
	else if (m_csBitmaps[0].hBitmap)
	{
		m_ptImageOrg.x = 0;
		m_ptImageOrg.y = 0;
	    SetWindowPos(NULL, -1, -1, m_csBitmaps[0].dwWidth, m_csBitmaps[0].dwHeight,
						SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE);
	} // if
} // End of SizeToContent

// This function sets the sound that must be played on particular button states.
//
// Parameters:
//		[IN]	lpszSound
//				A string that specifies the sound to play.
//				If hMod is NULL this string is interpreted as a filename, else it
//				is interpreted as a resource identifier.
//				Pass NULL to remove any previously specified sound.
//		[IN]	hMod
//				Handle to the executable file that contains the resource to be loaded.
//				This parameter must be NULL unless lpszSound specifies a resource identifier.
//		[IN]	bPlayOnClick
//				TRUE if the sound must be played when the button is clicked.
//				FALSE if the sound must be played when the mouse is moved over the button.
//		[IN]	bPlayAsync
//				TRUE if the sound must be played asynchronously.
//				FALSE if the sound must be played synchronously. The application takes control
//				when the sound is completely played.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
#ifdef	BTNST_USE_SOUND
DWORD CButtonST::SetSound(LPCTSTR lpszSound, HMODULE hMod, BOOL bPlayOnClick, BOOL bPlayAsync)
{
	BYTE		byIndex = bPlayOnClick ? 1 : 0;

	// Store new sound
	if (lpszSound != NULL)
	{
		if (hMod != NULL)	// From resource identifier ?
			m_csSounds[byIndex].lpszSound = lpszSound;
		else
		{
			_tcscpy(m_csSounds[byIndex].szSound, lpszSound);
			m_csSounds[byIndex].lpszSound = m_csSounds[byIndex].szSound;
		} // else

		m_csSounds[byIndex].hMod = hMod;
		m_csSounds[byIndex].dwFlags = SND_NODEFAULT | SND_NOWAIT;
		m_csSounds[byIndex].dwFlags |= hMod ? SND_RESOURCE : SND_FILENAME;
		m_csSounds[byIndex].dwFlags |= bPlayAsync ? SND_ASYNC : SND_SYNC;
	} // if
	else
	{
		// Or remove any existing
		memzero(&m_csSounds[byIndex], sizeof(STRUCT_SOUND));
	} // else

	return BTNST_OK;
} // End of SetSound
#endif

// This function is called every time the button background needs to be painted.
// If the button is in transparent mode this function will NOT be called.
// This is a virtual function that can be rewritten in CButtonST-derived classes
// to produce a whole range of buttons not available by default.
//
// Parameters:
//		[IN]	pDC
//				Pointer to a CDC object that indicates the device context.
//		[IN]	pRect
//				Pointer to a CRect object that indicates the bounds of the
//				area to be painted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::OnDrawBackground(CDC* pDC, CRect* pRect)
{
	if (!m_bIsFlat && (m_bIsFocused || m_bIsDefault))
	{
		CBrush		br(RGB(0,0,0));

		pDC->FrameRect(pRect, &br);
		pRect->DeflateRect(1, 1);
	} // if

	COLORREF		crColor;

	if (m_bMouseOnButton || m_bIsPressed)
		crColor = m_crColors[BTNST_COLOR_BK_IN];
	else
	{
		if (m_bIsFocused)
			crColor = m_crColors[BTNST_COLOR_BK_FOCUS];
		else
			crColor = m_crColors[BTNST_COLOR_BK_OUT];
	} // else

	CBrush		brBackground(crColor);

	pDC->FillRect(pRect, &brBackground);

	return BTNST_OK;
} // End of OnDrawBackground

// This function is called every time the button border needs to be painted.
// This is a virtual function that can be rewritten in CButtonST-derived classes
// to produce a whole range of buttons not available by default.
//
// Parameters:
//		[IN]	pDC
//				Pointer to a CDC object that indicates the device context.
//		[IN]	pRect
//				Pointer to a CRect object that indicates the bounds of the
//				area to be painted.
//
// Return value:
//		BTNST_OK
//			Function executed successfully.
//
DWORD CButtonST::OnDrawBorder(CDC* pDC, CRect* pRect)
{
	// Draw pressed button
	if (!m_bIsPushLike || (m_bIsPushLike && m_bIsPressed))
	{
		if (m_bIsFlat)
		{
			if (m_bDrawBorder)
				pDC->Draw3dRect(pRect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHILIGHT));
		}
		else if (!m_bIsPushLike)
		{
			CBrush		brBtnBorder(RGB(0, 0, 0));
			CBrush		brBtnInnerBorder(GetSysColor(COLOR_WINDOW));

			pDC->FrameRect(pRect, &brBtnBorder);
			pRect->DeflateRect(1, 1);
			pDC->FrameRect(pRect, &brBtnInnerBorder);
		}
		else
		{
			CBrush		brBtnShadow(GetSysColor(COLOR_BTNSHADOW));

			pDC->FrameRect(pRect, &brBtnShadow);
		}
	}
	else // ...else draw non pressed button
	{
		CPen	penBtnHiLight(PS_SOLID, 0, GetSysColor(COLOR_BTNHILIGHT)); // White
		CPen	pen3DLight(PS_SOLID, 0, GetSysColor(COLOR_3DLIGHT));       // Light gray
		CPen	penBtnShadow(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));   // Dark gray
		CPen	pen3DDKShadow(PS_SOLID, 0, GetSysColor(COLOR_3DDKSHADOW)); // Black

		if (m_bIsFlat)
		{
			if (m_bMouseOnButton && m_bDrawBorder)
				pDC->Draw3dRect(pRect, ::GetSysColor(COLOR_BTNHILIGHT), ::GetSysColor(COLOR_BTNSHADOW));
		}
		else
		{
			// Draw top-left borders
			// White line
			CPen	*pOldPen = pDC->SelectObject(&penBtnHiLight);

			pDC->MoveTo(pRect->left, pRect->bottom - 1);
			pDC->LineTo(pRect->left, pRect->top);
			pDC->LineTo(pRect->right, pRect->top);
			// Light gray line
			pDC->SelectObject(pen3DLight);
			pDC->MoveTo(pRect->left + 1, pRect->bottom - 1);
			pDC->LineTo(pRect->left + 1, pRect->top + 1);
			pDC->LineTo(pRect->right, pRect->top + 1);
			// Draw bottom-right borders
			// Black line
			pDC->SelectObject(pen3DDKShadow);
			pDC->MoveTo(pRect->left, pRect->bottom - 1);
			pDC->LineTo(pRect->right - 1, pRect->bottom - 1);
			pDC->LineTo(pRect->right - 1, pRect->top - 1);
			// Dark gray line
			pDC->SelectObject(penBtnShadow);
			pDC->MoveTo(pRect->left + 1, pRect->bottom - 2);
			pDC->LineTo(pRect->right - 2, pRect->bottom - 2);
			pDC->LineTo(pRect->right - 2, pRect->top);
			//
			pDC->SelectObject(pOldPen);
		} // else
	} // else

	return BTNST_OK;
} // End of OnDrawBorder

#undef BS_TYPEMASK
@


1.20
log
@added support of BS_PUSHLIKE;
remove useless comments
@
text
@d108 1
a108 1
	memzero(&m_csCallbacks, sizeof(m_csCallbacks));
a140 1
    //{{AFX_MSG_MAP(CButtonST)
a150 1
	//}}AFX_MSG_MAP
a203 3
	if (nBS & BS_PUSHLIKE)
		m_bIsPushLike = TRUE;

@


1.19
log
@Removed meaningless set/restore brush around FillRect.
@
text
@d206 3
a2275 1
			// If something wrong
a2285 1
				// If something wrong
@


1.18
log
@Suppressed compiler warnings; Protection against too long URLs (this functionality is not used at the moment).
@
text
@a2449 1
	CBrush		*pOldBrush = pDC->SelectObject(&brBackground);
a2451 1
	pDC->SelectObject(pOldBrush);
@


1.17
log
@Use proper define instead of the constant (from original).
@
text
@d251 1
d288 1
d307 1
d453 1
d835 1
d1284 1
d2162 1
a2162 2
	// Remove any existing URL
	memzero(m_szURL, sizeof(m_szURL));
d2164 1
a2164 1
	if (lpszURL)
d2166 3
a2168 3
		// Store the URL
		_tcsncpy(m_szURL, lpszURL, _MAX_PATH);
	} // if
d2171 1
a2171 1
} // End of SetURL
@


1.16
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1064 1
a1064 1
	HDC			hMainDC = ::GetDC(NULL);
@


1.15
log
@renamed 3 variables
@
text
@d594 1
a594 1
	if (m_bIsFocused && g_App.g_pPrefs->GetWindowsVersion() != _WINVER_XP_
@


1.14
log
@Rolled back last changes not to increase number of GDI resources.
@
text
@d594 1
a594 1
	if (m_bIsFocused && g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() != _WINVER_XP_
@


1.13
log
@small optimizations
@
text
@a113 2

	m_brush000.CreateSolidBrush(RGB(0, 0, 0));
a137 1
	m_brush000.DeleteObject();
d2426 3
a2428 1
		pDC->FrameRect(pRect, &m_brush000);
d2480 1
d2483 1
a2483 1
			pDC->FrameRect(pRect, &m_brush000);
@


1.12
log
@Change focus frame size to be like for standard control.
@
text
@d114 2
d140 1
d2429 1
a2429 3
		CBrush		br(RGB(0,0,0));

		pDC->FrameRect(pRect, &br);
a2480 1
			CBrush		brBtnBorder(RGB(0, 0, 0));
d2483 1
a2483 1
			pDC->FrameRect(pRect, &brBtnBorder);
@


1.11
log
@Shifted iconed buttons icon 4 pixels to the right & fixed focus rect.
@
text
@d4 1
a4 1
#include "eMule.h"
d600 1
a600 1
		focusRect.DeflateRect(1, 1);
@


1.10
log
@Iconed buttons border is now visible also in a non-themed environment.
Updated BtnST code to v3.9 + Formatted & Optimized.
Shiftet Underline icon one pixel to the right.
Changed IRC text and color formatting buttons to look correct on both themed & not themed environment.
@
text
@d4 1
d594 2
a595 1
	/*if ((!m_bIsFlat || (m_bIsFlat && m_bDrawFlatFocus)) && m_bIsFocused)
d600 1
a600 1
		focusRect.DeflateRect(3, 3);
d602 1
a602 1
	} // if*/
d684 3
d741 1
a741 1
    
d749 1
a749 1
	BYTE		byIndex		= 0;
d1694 1
a1694 4
		if (nCheck == 0)
			m_nCheck = 0;
		else
			m_nCheck = 1;
d2126 1
a2126 2
		CRect		rect;
		CRect		rect1;
@


1.9
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d65 3
d264 1
a264 1
	UINT nNewType = (wParam & BS_TYPEMASK);
d311 2
a312 1
	LRESULT lResult;
d324 2
a325 1
	BOOL bSetFlag = FALSE;
d343 1
a343 1
	if (bEnable == FALSE)	
d345 2
a346 1
		CWnd*	pWnd = GetParent()->GetNextDlgTabItem(this);
d359 1
d366 1
d374 1
d393 1
a393 1
	if (m_bIsFlat)
d395 2
a396 5
		if (m_bMouseOnButton)
		{
			m_bMouseOnButton = FALSE;
			Invalidate();
		} // if
d412 1
a412 1
	if (nFlags & MK_LBUTTON && m_bMouseOnButton == FALSE)
d416 1
a416 1
	if (m_bIsFlat == FALSE)
d419 2
a420 1
	if (m_bAlwaysTrack == FALSE)	wndActive = GetActiveWindow();
d477 2
a478 1
			CRect	rWnd;
d485 3
a487 2
			BCMenu* psub = (BCMenu*)m_menuPopup.GetSubMenu(0);
			if (m_csCallbacks.hWnd)
d489 3
a491 1
			DWORD dwRetValue = psub->TrackPopupMenuEx(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, rWnd.left, rWnd.bottom, this, NULL);
d493 3
a495 2
			HMENU hSubMenu = ::GetSubMenu(m_hMenu, 0);
			if (m_csCallbacks.hWnd)
d497 3
a499 1
			DWORD dwRetValue = ::TrackPopupMenuEx(hSubMenu, TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, rWnd.left, rWnd.bottom, m_hParentWndMenu, NULL);
d505 1
a505 1
			if (dwRetValue)
d513 1
a513 1
				SHELLEXECUTEINFO	csSEI;
d531 1
a531 1
	CDC*	pDC = CDC::FromHandle(lpDIS->hDC);
d555 1
a555 1
	CRect itemRect = lpDIS->rcItem;
d571 1
a571 2
	CString sTitle;
	GetWindowText(sTitle);
d573 3
a575 1
	CRect captionRect = lpDIS->rcItem;
d580 1
a580 1
		DrawTheIcon(pDC, !sTitle.IsEmpty(), &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
d586 1
a586 1
		DrawTheBitmap(pDC, !sTitle.IsEmpty(), &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
d590 2
a591 4
	if (sTitle.IsEmpty() == FALSE)
	{
		DrawTheText(pDC, (LPCTSTR)sTitle, &lpDIS->rcItem, &captionRect, m_bIsPressed, m_bIsDisabled);
	} // if
d593 1
a593 1
	if (m_bIsFlat == FALSE || (m_bIsFlat && m_bDrawFlatFocus))
d596 5
a600 7
		if (m_bIsFocused)
		{
			CRect focusRect = itemRect;
			focusRect.DeflateRect(3, 3);
			pDC->DrawFocusRect(&focusRect);
		} // if
	} // if
d605 3
a607 3
	CClientDC clDC(GetParent());
	CRect rect;
	CRect rect1;
d627 1
a627 7
	HBITMAP		hMask		= NULL;
	HDC			hdcSrc		= NULL;
	HDC			hdcDest		= NULL;
	HBITMAP		hbmSrcT		= NULL;
	HBITMAP		hbmDestT	= NULL;
	COLORREF	crSaveBk;
	COLORREF	crSaveDestText;
a628 1
	hMask = ::CreateBitmap(dwWidth, dwHeight, 1, 1, NULL);
d632 5
a636 2
	hdcSrc	= ::CreateCompatibleDC(NULL);
	hdcDest	= ::CreateCompatibleDC(NULL);
d638 1
a638 2
	hbmSrcT = (HBITMAP)::SelectObject(hdcSrc, hSourceBitmap);
	hbmDestT = (HBITMAP)::SelectObject(hdcDest, hMask);
d640 1
a640 1
	crSaveBk = ::SetBkColor(hdcSrc, crTransColor);
d642 1
a642 4
	::BitBlt(hdcDest, 0, 0, dwWidth, dwHeight, hdcSrc, 0, 0, SRCCOPY);

	crSaveDestText = ::SetTextColor(hdcSrc, RGB(255, 255, 255));
	::SetBkColor(hdcSrc,RGB(0, 0, 0));
d678 1
a678 1
	CRect rBtn;
d685 1
a685 1
			if (bHasTitle == FALSE)
d688 1
a688 1
				rpImage->left += ((rpImage->Width() - (long)dwWidth)/2);
d697 1
a697 1
			rpImage->top += ((rpImage->Height() - (long)dwHeight)/2);
d702 1
a702 1
			if (bHasTitle == FALSE)
d705 1
a705 1
				rpImage->left += ((rpImage->Width() - (long)dwWidth)/2);
d714 1
a714 1
				rpImage->top += ((rpImage->Height() - (long)dwHeight)/2);
d720 2
a721 2
			rpImage->left += ((rpImage->Width() - (long)dwWidth)/2);
			if (bHasTitle == FALSE)
d724 1
a724 1
				rpImage->top += ((rpImage->Height() - (long)dwHeight)/2);           
d738 1
a738 1
	if (bIsPressed && m_bIsCheckBox == FALSE)
d752 2
a753 1
	CRect	rImage;
d766 1
a766 6
	HDC			hdcBmpMem	= NULL;
	HBITMAP		hbmOldBmp	= NULL;
	HDC			hdcMem		= NULL;
	HBITMAP		hbmT		= NULL;

	BYTE		byIndex		= 0;
d774 2
a775 1
	CRect	rImage;
d778 4
a781 7
	hdcBmpMem = ::CreateCompatibleDC(pDC->m_hDC);

	hbmOldBmp = (HBITMAP)::SelectObject(hdcBmpMem, m_csBitmaps[byIndex].hBitmap);

	hdcMem = ::CreateCompatibleDC(NULL);

	hbmT = (HBITMAP)::SelectObject(hdcMem, m_csBitmaps[byIndex].hMask);
d785 4
a788 6
		HDC		hDC = NULL;
		HBITMAP	hBitmap = NULL;

		hDC = ::CreateCompatibleDC(pDC->m_hDC);
		hBitmap = ::CreateCompatibleBitmap(pDC->m_hDC, m_csBitmaps[byIndex].dwWidth, m_csBitmaps[byIndex].dwHeight);
		HBITMAP	hOldBmp2 = (HBITMAP)::SelectObject(hDC, hBitmap);
a789 1
		RECT	rRect;
d796 1
a796 1
		COLORREF crOldColor = ::SetBkColor(hDC, RGB(255,255,255));
a813 1

d828 1
a828 1
	if (m_bIsPressed && m_bIsCheckBox == FALSE)
d836 2
a837 1
	CRect centerRect = rpCaption;
d883 152
d1048 1
d1054 11
a1064 6
	HICON		hGrayIcon = NULL;
	HDC			hMainDC = NULL, hMemDC1 = NULL, hMemDC2 = NULL;
	BITMAP		bmp;
	HBITMAP		hOldBmp1 = NULL, hOldBmp2 = NULL;
	ICONINFO	csII, csGrayII;
	BOOL		bRetValue = FALSE;
d1066 3
a1068 2
	bRetValue = ::GetIconInfo(hIcon, &csII);
	if (bRetValue == FALSE)
d1070 3
d1074 4
a1077 4
	hMainDC = ::GetDC(NULL);
	hMemDC1 = ::CreateCompatibleDC(hMainDC);
	hMemDC2 = ::CreateCompatibleDC(hMainDC);
	if (hMainDC == NULL || hMemDC1 == NULL || hMemDC2 == NULL)
d1079 6
a1084 1
  
d1087 2
a1088 2
		DWORD	dwWidth = csII.xHotspot*2;
		DWORD	dwHeight = csII.yHotspot*2;
d1091 1
d1094 5
a1098 8
			hOldBmp1 = (HBITMAP)::SelectObject(hMemDC1, csII.hbmColor);
			hOldBmp2 = (HBITMAP)::SelectObject(hMemDC2, csGrayII.hbmColor);

			//::BitBlt(hMemDC2, 0, 0, dwWidth, dwHeight, hMemDC1, 0, 0, SRCCOPY);

			DWORD		dwLoopY = 0, dwLoopX = 0;
			COLORREF	crPixel = 0;
			BYTE		byNewPixel = 0;
d1108 3
a1110 1
						::SetPixel(hMemDC2, dwLoopX, dwLoopY, RGB(byNewPixel, byNewPixel, byNewPixel));
d1136 107
d1250 4
d1257 8
d1272 1
a1272 1
DWORD CButtonST::SetIcon(int nIconIn, int nIconOut)
a1273 4
	HICON		hIconIn			= NULL;
	HICON		hIconOut		= NULL;
	HINSTANCE	hInstResource	= NULL;

d1275 1
a1275 2
	hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nIconIn), RT_GROUP_ICON);

d1277 1
a1277 1
	hIconIn = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nIconIn), IMAGE_ICON, 0, 0, 0);
d1280 1
a1280 1
	if (nIconOut)
d1282 3
a1284 1
		if (nIconOut == (int)BTNST_AUTO_GRAY)
d1286 8
a1293 3
		else
			hIconOut = (HICON)::LoadImage(hInstResource, MAKEINTRESOURCE(nIconOut), IMAGE_ICON, 0, 0, 0);
	} // if
d1302 26
d1334 4
a1346 3
	BOOL		bRetValue;
	ICONINFO	ii;

d1350 1
a1350 1
	if (hIconIn)
d1352 2
d1358 2
a1359 2
		bRetValue = ::GetIconInfo(hIconIn, &ii);
		if (bRetValue == FALSE)
d1371 1
a1371 1
		if (hIconOut)
d1373 1
a1373 1
			if (hIconOut == BTNST_AUTO_GRAY)
d1375 7
a1381 2
				hIconOut = CreateGrayscaleIcon(hIconIn);
			} // if
d1386 2
a1387 2
			bRetValue = ::GetIconInfo(hIconOut, &ii);
			if (bRetValue == FALSE)
a1429 4
	HBITMAP		hBitmapIn		= NULL;
	HBITMAP		hBitmapOut		= NULL;
	HINSTANCE	hInstResource	= NULL;
	
d1431 1
a1431 2
	hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nBitmapIn), RT_BITMAP);

d1433 2
a1434 1
	hBitmapIn = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nBitmapIn), IMAGE_BITMAP, 0, 0, 0);
d1437 14
a1450 2
	if (nBitmapOut)
		hBitmapOut = (HBITMAP)::LoadImage(hInstResource, MAKEINTRESOURCE(nBitmapOut), IMAGE_BITMAP, 0, 0, 0);
a1479 3
	int		nRetValue;
	BITMAP	csBitmapSize;

d1483 1
a1483 1
	if (hBitmapIn)
d1487 3
d1491 1
a1491 2
		nRetValue = ::GetObject(hBitmapIn, sizeof(csBitmapSize), &csBitmapSize);
		if (nRetValue == 0)
d1499 15
d1522 1
a1522 1
		if (hBitmapOut)
d1527 1
a1527 2
			nRetValue = ::GetObject(hBitmapOut, sizeof(csBitmapSize), &csBitmapSize);
			if (nRetValue == 0)
d1573 23
a1626 1
			break;
a1824 7
	BYTE	byRed = 0;
	BYTE	byGreen = 0;
	BYTE	byBlue = 0;
	short	shOffsetR = shOffset;
	short	shOffsetG = shOffset;
	short	shOffsetB = shOffset;

d1827 1
d1831 3
d1835 3
a1837 3
	byRed = GetRValue(m_crColors[byColorIndex]);
	byGreen = GetGValue(m_crColors[byColorIndex]);
	byBlue = GetBValue(m_crColors[byColorIndex]);
a1908 1
	HINSTANCE	hInstResource = NULL;
d1910 1
a1910 1
	if (m_hCursor)
d1917 1
a1917 1
	if (nCursorId)
d1919 2
a1920 1
		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nCursorId), RT_GROUP_CURSOR);
d2003 1
a2003 1
	CString sText;
d2006 1
a2006 1
	sText.LoadString(nText);
d2008 2
a2009 2
	if (sText.IsEmpty() == FALSE)
		SetTooltipText((LPCTSTR)sText, bActivate);
d2032 2
a2033 1
		CRect rectBtn; 
d2069 1
a2102 1
	{
a2103 1
	} // if
d2115 1
a2115 1
	if (m_bDrawTransparent && pDC)
a2118 1
		{
a2119 1
		} // if
d2124 2
a2125 2
		CRect rect;
		CRect rect1;
a2127 1

a2188 2
	HINSTANCE	hInstResource	= NULL;

d2190 1
a2190 1
	if (m_hMenu)
d2199 1
a2199 1
	if (nMenu)
d2202 1
a2202 1
		hInstResource = AfxFindResourceHandle(MAKEINTRESOURCE(nMenu), RT_MENU);
a2252 2
	BOOL	bRetValue = FALSE;

d2254 1
a2254 1
	if (m_menuPopup.m_hMenu)
d2262 1
a2262 1
	if (nMenu)
d2266 2
a2267 3
		bRetValue = m_menuPopup.LoadMenu(nMenu);
		// If something wrong
		if (bRetValue == FALSE)
d2271 1
a2271 1
		if (nToolbarID)
d2276 1
a2276 3
			bRetValue = m_menuPopup.LoadToolbar(nToolbarID);
			// If something wrong
			if (bRetValue == FALSE) 
d2278 1
d2339 1
a2339 1
	    SetWindowPos(	NULL, -1, -1, m_csIcons[0].dwWidth, m_csIcons[0].dwHeight,
d2342 1
a2342 2
	else
	if (m_csBitmaps[0].hBitmap)
d2346 1
a2346 1
	    SetWindowPos(	NULL, -1, -1, m_csBitmaps[0].dwWidth, m_csBitmaps[0].dwHeight,
d2377 1
a2377 1
	BYTE	byIndex = bPlayOnClick ? 1 : 0;
d2380 1
a2380 1
	if (lpszSound)
d2382 1
a2382 2
		if (hMod)	// From resource identifier ?
		{
a2383 1
		} // if
d2423 3
a2425 1
	COLORREF	crColor;
d2427 2
a2428 8
	if (m_bIsFlat == FALSE)
	{
		if (m_bIsFocused || m_bIsDefault)
		{
			CBrush br(RGB(0,0,0));  
			pDC->FrameRect(pRect, &br);
			pRect->DeflateRect(1, 1);
		} // if
d2431 2
d2444 2
a2445 1
	CBrush*	pOldBrush = pDC->SelectObject(&brBackground);
d2470 1
a2470 1
	if (m_bIsPressed)
d2475 10
a2484 1
		pDC->Draw3dRect(pRect, ::GetSysColor(COLOR_BTNSHADOW), ::GetSysColor(COLOR_BTNHILIGHT));
d2486 1
a2486 1
	else
d2488 2
a2489 1
			CBrush brBtnShadow(GetSysColor(COLOR_BTNSHADOW));
d2495 4
a2498 4
		CPen penBtnHiLight(PS_SOLID, 0, GetSysColor(COLOR_BTNHILIGHT)); // White
		CPen pen3DLight(PS_SOLID, 0, GetSysColor(COLOR_3DLIGHT));       // Light gray
		CPen penBtnShadow(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));   // Dark gray
		CPen pen3DDKShadow(PS_SOLID, 0, GetSysColor(COLOR_3DDKSHADOW)); // Black
d2509 3
a2511 2
			CPen* pOldPen = pDC->SelectObject(&penBtnHiLight);
			pDC->MoveTo(pRect->left, pRect->bottom-1);
d2516 3
a2518 3
			pDC->MoveTo(pRect->left+1, pRect->bottom-1);
			pDC->LineTo(pRect->left+1, pRect->top+1);
			pDC->LineTo(pRect->right, pRect->top+1);
d2522 3
a2524 3
			pDC->MoveTo(pRect->left, pRect->bottom-1);
			pDC->LineTo(pRect->right-1, pRect->bottom-1);
			pDC->LineTo(pRect->right-1, pRect->top-1);
d2527 3
a2529 3
			pDC->MoveTo(pRect->left+1, pRect->bottom-2);
			pDC->LineTo(pRect->right-2, pRect->bottom-2);
			pDC->LineTo(pRect->right-2, pRect->top);
@


1.8
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d104 1
a104 1
	::ZeroMemory(&m_csCallbacks, sizeof(m_csCallbacks));
d108 1
a108 1
	::ZeroMemory(&m_csSounds, sizeof(m_csSounds));
d185 2
a186 2
	::ZeroMemory(&m_csIcons, sizeof(m_csIcons));
	::ZeroMemory(&m_csBitmaps, sizeof(m_csBitmaps));
d1046 1
a1046 1
		::ZeroMemory(&ii, sizeof(ICONINFO));
d1069 1
a1069 1
			::ZeroMemory(&ii, sizeof(ICONINFO));
d2054 1
a2054 1
		::ZeroMemory(&m_csSounds[byIndex], sizeof(STRUCT_SOUND));
@


1.7
log
@Fixed Mantis bug #500 - Display bug in Server window (buttons) when using XP Visual Styles
@
text
@d480 1
a480 1
			DWORD dwRetValue = psub->TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON | TPM_NONOTIFY | TPM_RETURNCMD, rWnd.left, rWnd.bottom, this, NULL);
@


1.6
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d25 14
a44 2
	leftAligned			= false;
	marked				= false;
d79 1
d123 2
a124 1
	if (m_hCursor) ::DestroyCursor(m_hCursor);
d128 2
a129 1
	if (m_menuPopup.m_hMenu)	VERIFY( m_menuPopup.DestroyMenu() );//bond006: upgrade to 0.29c
d131 2
a132 1
	if (m_hMenu)	VERIFY( ::DestroyMenu(m_hMenu) );//bond006: upgrade to 0.29c
d167 4
a170 2
		if (m_csIcons[0].hIcon)	::DestroyIcon(m_csIcons[0].hIcon);
		if (m_csIcons[1].hIcon)	::DestroyIcon(m_csIcons[1].hIcon);
d173 4
a176 2
		if (m_csBitmaps[0].hBitmap)	::DeleteObject(m_csBitmaps[0].hBitmap);
		if (m_csBitmaps[1].hBitmap)	::DeleteObject(m_csBitmaps[1].hBitmap);
d179 4
a182 2
		if (m_csBitmaps[0].hMask)	::DeleteObject(m_csBitmaps[0].hMask);
		if (m_csBitmaps[1].hMask)	::DeleteObject(m_csBitmaps[1].hMask);
d199 2
a200 1
	if (nBS & BS_CHECKBOX) m_bIsCheckBox = TRUE;
d329 2
a330 1
	if (!bSetFlag) CButton::OnMeasureItem(nIDCtl, lpMeasureItemStruct);
d359 2
a360 1
	if (nState == WA_INACTIVE && !marked)	CancelHover();
d406 2
a407 1
	if (nFlags & MK_LBUTTON && m_bMouseOnButton == FALSE) return;
d410 2
a411 1
	if (m_bIsFlat == FALSE) return;
d434 3
a436 1
	} else CancelHover();
d478 2
a479 1
			if (m_csCallbacks.hWnd)	::SendMessage(m_csCallbacks.hWnd, m_csCallbacks.nMessage, (WPARAM)psub, m_csCallbacks.lParam);
d483 2
a484 1
			if (m_csCallbacks.hWnd)	::SendMessage(m_csCallbacks.hWnd, m_csCallbacks.nMessage, (WPARAM)hSubMenu, m_csCallbacks.lParam);
a517 1
	CPen*	pOldPen;
d522 1
a522 1
		m_bIsPressed  =  ((lpDIS->itemState & ODS_SELECTED) || (m_nCheck != 0) || marked );
d526 1
a526 1
		m_bIsPressed = ((lpDIS->itemState & ODS_SELECTED) || marked);
a544 12
	if (m_bIsFlat == FALSE)
	{
		if (m_bIsFocused || m_bIsDefault)
		{
			CBrush br(RGB(0,0,0));  
			CBrush* pOldBrush = pDC->SelectObject(&br);	//eklmn: select a new brush
			pDC->FrameRect(&itemRect, &br);
			pDC->SelectObject(pOldBrush);		//eklmn: recover an old brush
			itemRect.DeflateRect(1, 1);
		} // if
	} // if

d553 2
a554 56
	// Draw pressed button
	if (m_bIsPressed)
	{
		if (m_bIsFlat)
		{
			if (m_bDrawBorder)
				OnDrawBorder(pDC, &itemRect);
		}
		else    
		{
			CBrush brBtnShadow(GetSysColor(COLOR_BTNSHADOW));
			CBrush* pOldBrush = pDC->SelectObject(&brBtnShadow);	//eklmn: select a new brush
			pDC->FrameRect(&itemRect, &brBtnShadow);
			pDC->SelectObject(pOldBrush);		//eklmn: recover an old brush
		}
	}
	else // ...else draw non pressed button
	{
		CPen penBtnHiLight(PS_SOLID, 0, GetSysColor(COLOR_BTNHILIGHT)); // White
		CPen pen3DLight(PS_SOLID, 0, GetSysColor(COLOR_3DLIGHT));       // Light gray
		CPen penBtnShadow(PS_SOLID, 0, GetSysColor(COLOR_BTNSHADOW));   // Dark gray
		CPen pen3DDKShadow(PS_SOLID, 0, GetSysColor(COLOR_3DDKSHADOW)); // Black

		if (m_bIsFlat)
		{
			if (m_bMouseOnButton && m_bDrawBorder)
				OnDrawBorder(pDC, &itemRect);
		}
		else
		{
			// Draw top-left borders
			// White line
			pOldPen = pDC->SelectObject(&penBtnHiLight);
			pDC->MoveTo(itemRect.left, itemRect.bottom-1);
			pDC->LineTo(itemRect.left, itemRect.top);
			pDC->LineTo(itemRect.right, itemRect.top);
			// Light gray line
			pDC->SelectObject(pen3DLight);
			pDC->MoveTo(itemRect.left+1, itemRect.bottom-1);
			pDC->LineTo(itemRect.left+1, itemRect.top+1);
			pDC->LineTo(itemRect.right, itemRect.top+1);
			// Draw bottom-right borders
			// Black line
			pDC->SelectObject(pen3DDKShadow);
			pDC->MoveTo(itemRect.left, itemRect.bottom-1);
			pDC->LineTo(itemRect.right-1, itemRect.bottom-1);
			pDC->LineTo(itemRect.right-1, itemRect.top-1);
			// Dark gray line
			pDC->SelectObject(penBtnShadow);
			pDC->MoveTo(itemRect.left+1, itemRect.bottom-2);
			pDC->LineTo(itemRect.right-2, itemRect.bottom-2);
			pDC->LineTo(itemRect.right-2, itemRect.top);
			//
			pDC->SelectObject(pOldPen);
		} // else
	} // else
d625 2
a626 1
	if (hMask == NULL)	return NULL;
d845 1
a845 4

	if (!leftAligned) rpCaption->OffsetRect((centerRect.Width() - rpCaption->Width())/2, (centerRect.Height() - rpCaption->Height())/2); 
		else rpCaption->OffsetRect( 8, (centerRect.Height() - rpCaption->Height())/2);
	
d874 10
a883 2
			pDC->SetTextColor(m_crColors[BTNST_COLOR_FG_OUT]);
			pDC->SetBkColor(m_crColors[BTNST_COLOR_BK_OUT]);
d915 2
a916 1
	if (bRetValue == FALSE)	return NULL;
d921 2
a922 1
	if (hMainDC == NULL || hMemDC1 == NULL || hMemDC2 == NULL)	return NULL;
d948 2
a949 1
					if (crPixel)	::SetPixel(hMemDC2, dwLoopX, dwLoopY, RGB(byNewPixel, byNewPixel, byNewPixel));
d1230 2
a1231 1
	if (bRepaint)	Invalidate();
d1264 2
a1265 1
			if (bRepaint)	Invalidate();
d1306 2
a1307 1
	if (bRepaint)	Invalidate();
d1330 4
a1333 2
		if (nCheck == 0) m_nCheck = 0;
		else m_nCheck = 1;
d1335 2
a1336 1
		if (bRepaint) Invalidate();
d1374 2
a1375 1
	if (bRepaint)	Invalidate();
d1404 2
a1405 1
	if (byColorIndex >= BTNST_MAX_COLORS)	return BTNST_INVALIDINDEX;
d1410 2
a1411 1
	if (bRepaint)	Invalidate();
d1433 2
a1434 1
	if (byColorIndex >= BTNST_MAX_COLORS)	return BTNST_INVALIDINDEX;
d1473 4
a1476 2
	if (byColorIndex >= BTNST_MAX_COLORS)	return BTNST_INVALIDINDEX;
	if (shOffset < -255 || shOffset > 255)	return BTNST_BADPARAM;
d1486 6
a1491 3
		if (byRed + shOffset > 255)		shOffsetR = 255 - byRed;
		if (byGreen + shOffset > 255)	shOffsetG = 255 - byGreen;
		if (byBlue + shOffset > 255)	shOffsetB = 255 - byBlue;
d1497 6
a1502 3
		if (byRed + shOffset < 0)		shOffsetR = -byRed;
		if (byGreen + shOffset < 0)		shOffsetG = -byGreen;
		if (byBlue + shOffset < 0)		shOffsetB = -byBlue;
d1510 2
a1511 1
	if (bRepaint)	Invalidate();
d1568 2
a1569 1
		if (bRepaint) Invalidate();
d1571 2
a1572 1
		if (m_hCursor == NULL) return BTNST_INVALIDRESOURCE;
d1595 2
a1596 1
	if (bRepaint) Invalidate();
d1617 2
a1618 1
	if (bRepaint) Invalidate();
d1628 1
a1628 1
		m_ToolTip.Create(this);
d1633 1
d1652 2
a1653 1
	if (sText.IsEmpty() == FALSE) SetTooltipText((LPCTSTR)sText, bActivate);
d1667 2
a1668 1
	if (lpszText == NULL) return;
d1695 2
a1696 1
	if (m_ToolTip.GetToolCount() == 0) return;
d1702 13
d1753 2
a1754 1
	if (bRepaint) Invalidate();
d1841 1
a1841 1
		VERIFY( ::DestroyMenu(m_hMenu) );//bond006: upgrade to 0.29c
d1856 2
a1857 1
		if (m_hMenu == NULL) return BTNST_INVALIDRESOURCE;
d1861 2
a1862 1
	if (bRepaint) Invalidate();
d1907 1
a1907 1
		VERIFY( m_menuPopup.DestroyMenu() );//bond006: upgrade to 0.29c
d1919 2
a1920 1
		if (bRetValue == FALSE) return BTNST_INVALIDRESOURCE;
d1932 1
a1932 1
				VERIFY( m_menuPopup.DestroyMenu() );//bond006: upgrade to 0.29c
d1941 2
a1942 1
	if (bRepaint) Invalidate();
d2077 1
a2077 1
DWORD CButtonST::OnDrawBackground(CDC* pDC, LPCRECT pRect)
d2081 10
d2102 1
a2102 1
	CBrush*	pOldBrush = pDC->SelectObject(&brBackground);		//eklmn: select a new brush
d2104 1
a2104 1
	pDC->SelectObject(pOldBrush);		//eklmn: recover an old brush
a2109 1
// If the button is in standard (not flat) mode this function will NOT be called.
d2124 1
a2124 1
DWORD CButtonST::OnDrawBorder(CDC* pDC, LPCRECT pRect)
d2126 1
d2128 4
d2133 1
d2135 45
a2179 1
		pDC->Draw3dRect(pRect, ::GetSysColor(COLOR_BTNHILIGHT), ::GetSysColor(COLOR_BTNSHADOW));
@


1.5
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d470 1
a470 1
				memset2(&csSEI, 0, sizeof(csSEI));
d1789 1
a1789 1
	memset2(m_szURL, 0, sizeof(m_szURL));
@


1.4
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d3 1
d470 1
a470 1
				memset(&csSEI, 0, sizeof(csSEI));
d1789 1
a1789 1
	memset(m_szURL, 0, sizeof(m_szURL));
@


1.3
log
@updated BtnST.cpp to official 0.29c for improved debugging
@
text
@d519 1
d521 1
d545 1
d547 1
d2073 1
a2073 1

d2075 1
@


1.2
log
@Upgrade to 0.28a
@
text
@d113 1
a113 1
	if (m_menuPopup.m_hMenu)	m_menuPopup.DestroyMenu();
d115 1
a115 1
	if (m_hMenu)	::DestroyMenu(m_hMenu);
d1822 1
a1822 1
		::DestroyMenu(m_hMenu);
d1886 1
a1886 1
		m_menuPopup.DestroyMenu();
d1910 1
a1910 1
				m_menuPopup.DestroyMenu();
@


1.1
log
@*** empty log message ***
@
text
@d19 3
@


1.1.4.1
log
@updating this branch...
@
text
@@

