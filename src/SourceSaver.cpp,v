head	1.50;
access;
symbols
	PublicRelease_1_2e:1.48
	Interim_Release_1-2e_RC1:1.48
	PublicRelease_1_2d:1.44
	Interim_Release_1-2d_RC1:1.44
	Interim_Release_1-2d_beta1:1.43
	PublicRelease_1_2c:1.42
	Interim_Release_1-2c_RC1:1.42
	Interim_Release_1-2c_beta1:1.42
	PublicRelease_1_2b:1.42
	Interim_Release_1-2b_RC1:1.42
	PublicRelease_1_2a:1.40
	Interim_Release_1-2a_RC1:1.40
	Interim_Release_1-2a_beta2:1.40
	Interim_Release_1-2a_beta1:1.40
	PublicRelease_1_2:1.40
	Interim_Release_1-2_RC1:1.40
	Interim_Release_1-2_beta1:1.39
	PublicRelease_1_1g:1.39
	Interim_Release_1-1g_RC3:1.39
	Interim_Release_1-1g_RC2:1.39
	Interim_Release_1-1g_RC1:1.39
	Interim_Release_1-1g_beta2:1.36
	Interim_Release_1-1g_beta1:1.34
	PublicRelease_1_1f:1.31
	Interim_Release_1-1f_RC1:1.31
	PublicRelease_1_1e:1.31
	Interim_Release_1-1e_RC2:1.31
	Interim_Release_1-1e_RC1:1.31
	Interim_Release_1-1e_beta1:1.31
	PublicRelease_1_1d:1.31
	Interim_Release_1-1d_RC1:1.31
	PublicRelease_1_1c:1.31
	Interim_Release_1-1c_RC1:1.31
	Interim_Release_1-1c_beta2:1.31
	Interim_Release_1-1c_beta1:1.30
	PublicRelease_1_1b:1.28
	Interim_Release_1-1b_RC1:1.28
	PublicRelease_1_1a:1.28
	Interim_Release_1-1a_RC2:1.28
	Interim_Release_1-1a_RC1:1.28
	Interim_Release_1-1a_beta2:1.28
	Interim_Release_1-1a_beta1:1.28
	PublicRelease_1_1:1.28
	Interim_Release_1-1_beta1:1.28
	PublicRelease_1o:1.28
	Interim_Release_1o_RC1:1.28
	Interim_Release_1o_beta1:1.28
	PublicRelease_1n:1.28
	Interim_Release_1n_RC2:1.28
	Interim_Release_1n_RC1:1.28
	Interim_Release_1n_beta2:1.28
	Interim_Release_1n_beta1:1.28
	PublicRelease_1m:1.27
	Interim_Release_1m_beta1:1.27
	PublicRelease_1l:1.27
	Interim_Release_1l_RC3:1.27
	Interim_Release_1l_RC2:1.27
	Interim_Release_1l_RC1:1.27
	Interim_Release_1l_beta2:1.26
	Interim_Release_1l_beta1:1.26
	PublicRelease_1k:1.24
	Interim_Release_1k_RC4:1.24
	Interim_1k_RC3:1.24
	Interim_1k_RC2:1.24
	Interim_Release_1k_RC1:1.23
	Interim_Release_1k_beta5:1.23
	Intrerim_Release_1k_beta4:1.23
	Interim_Release_1k_beta1:1.23
	PublicRelease_1j:1.20
	Interim_Release_1J_RC3:1.20
	Interim_Release_1j_RC3:1.20
	Interim_Release_1j_RC2:1.20
	Interim_Release_1j_RC1:1.19
	Interim_Release_1j_beta2:1.18
	Interim_Release_1j_beta1:1.18
	PublicRelease_1i:1.14
	Interim_Release_1i_RC6:1.14
	Interim_Release_1i_RC3:1.14
	Interim_Release_1i_RC2:1.14
	Interim_Release_1i_RC1:1.14
	Interim_Release_1i_beta3:1.14
	Interim_Release_1i_beta2:1.14
	Interim_Release_1i_beta1:1.7
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1;
locks; strict;
comment	@// @;


1.50
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.49;

1.49
date	2009.05.31.02.22.29;	author aw3;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.47;

1.47
date	2008.10.29.03.47.45;	author aw3;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.45;

1.45
date	2008.05.25.01.27.01;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2008.03.15.04.14.22;	author aw3;	state Exp;
branches;
next	1.43;

1.43
date	2008.01.13.19.36.31;	author aw3;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.17.07.57.21;	author aw3;	state Exp;
branches;
next	1.41;

1.41
date	2007.01.11.19.57.05;	author eklmn;	state Exp;
branches;
next	1.40;

1.40
date	2006.02.19.22.54.30;	author kush_eplus;	state Exp;
branches;
next	1.39;

1.39
date	2005.11.28.03.11.13;	author aw3;	state Exp;
branches;
next	1.38;

1.38
date	2005.11.27.22.11.50;	author eklmn;	state Exp;
branches;
next	1.37;

1.37
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.26.00.29.07;	author aw3;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.25.11.57.47;	author aw3;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.21.21.26.41;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2005.08.11.05.19.37;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.09.15.37.02;	author eklmn;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.03.19.48.07;	author kuchin;	state Exp;
branches;
next	1.30;

1.30
date	2005.01.28.20.39.21;	author aw3;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.17.14.26.44;	author dongato;	state Exp;
branches;
next	1.28;

1.28
date	2004.06.30.13.38.42;	author dongato;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.24.12.34.03;	author netwolf1;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.05.21.10.51;	author aw3;	state Exp;
branches;
next	1.25;

1.25
date	2004.05.01.05.38.16;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2004.03.31.08.05.09;	author eklmn;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.15.11.55.58;	author morevit;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.05.00.00.02;	author kush_eplus;	state Exp;
branches;
next	1.21;

1.21
date	2004.01.26.21.25.22;	author kush_eplus;	state Exp;
branches;
next	1.20;

1.20
date	2004.01.11.05.09.57;	author dongato;	state Exp;
branches;
next	1.19;

1.19
date	2004.01.10.21.02.27;	author dongato;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.21.15.24.19;	author netwolf1;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.21.14.33.59;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.20.15.49.35;	author eklmn;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.06.23.43.00;	author dongato;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.06.13.24.12;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.05.05.20.01;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.30.07.15.45;	author dongato;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.29.02.57.43;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.26.23.34.24;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.07.05.11.56.27;	author dongato;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Fast byte swap for ntohl and ntohs.
@
text
@#include "stdafx.h"
#include "updownclient.h"
#include "SourceSaver.h"
#include "PartFile.h"
#ifndef NEW_SOCKETS_ENGINE
#include "emule.h"
#else
#include "otherfunctions.h"
#endif //NEW_SOCKETS_ENGINE

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CSourceData
{
public:
	CSourceData(uint32 dwIP, uint16 uPort, LPCTSTR pachExpDate);
#ifndef NEW_SOCKETS_ENGINE
	CSourceData(CUpDownClient *pClient, LPCTSTR pachExpDate);
#endif //NEW_SOCKETS_ENGINE

	bool Compare(const CSourceData *pSourceData);

	uint32	m_dwSrcIDHyb;
	uint32	m_dwPartsAvailable;
	uint16	m_uSourcePort;
	TCHAR	m_pachExpDate[7];
};

#ifndef NEW_SOCKETS_ENGINE
CSourceData::CSourceData(CUpDownClient *pClient, LPCTSTR pachExpDate)
{
	m_dwSrcIDHyb = pClient->GetUserIDHybrid();
	m_uSourcePort = pClient->GetUserPort();
	m_dwPartsAvailable = pClient->GetAvailablePartCount();
	_tcscpy(m_pachExpDate, pachExpDate);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#endif //NEW_SOCKETS_ENGINE
CSourceData::CSourceData(uint32 dwIP, uint16 uPort, LPCTSTR pachExpDate)
{
	m_dwSrcIDHyb = fast_ntohl(dwIP);
	m_uSourcePort = uPort;
	m_dwPartsAvailable = 0;
	_tcscpy(m_pachExpDate, pachExpDate);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CSourceData::Compare(const CSourceData *pSrcData)
{
	return ( (m_dwSrcIDHyb == pSrcData->m_dwSrcIDHyb)
		&& (m_uSourcePort == pSrcData->m_uSourcePort) );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSourceSaver::CSourceSaver()
{
	m_dwLastTimeSaved = ::GetTickCount() - (rand() >> 1);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Process() saves/loads up to 'iMaxSourcesToSave' sources for 'pPartFile' if the auto save/load timer
//		have expired. It returns false if the sources were not saved.
bool CSourceSaver::Process(CPartFile *pPartFile, int iMaxSourcesToSave/* = 10*/, bool bIgnoreTimer/* = false */)
{
	uint32	dwTicks = ::GetTickCount();

//	If the auto-save time (fixed 120 minutes) has passed...
	if (bIgnoreTimer || ((dwTicks - m_dwLastTimeSaved) > RESAVETIME))
	{
	//	Set next auto-save time + random 0..16 seconds
		m_dwLastTimeSaved = dwTicks - (rand() >> 1);
		SaveSources(pPartFile, iMaxSourcesToSave);

		return true;
	}

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	LoadSources() loads the sources for part file 'pPartFile' and adds them to the download queue
void CSourceSaver::LoadSources(CPartFile *pPartFile)
{
//	Load sources from file
	SourceList	srcList;

	LoadSourcesFromFile(pPartFile, &srcList);

#ifndef NEW_SOCKETS_ENGINE
	CSourceData		*pSrcData;
	CUpDownClient	*pNewSrc;
	uint32			dwAddedSources = 0;

//	For each SourceData...
	while (srcList.GetCount() > 0)
	{
		pSrcData = srcList.RemoveHead();

	//	If we reach the maximum number of sources allowed, stop adding more
		if (pPartFile->GetSourceCount() < g_App.m_pPrefs->GetMaxSourcePerFile())
		{
		 	pNewSrc = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile, pSrcData->m_dwSrcIDHyb, pSrcData->m_uSourcePort, 0, 0, NULL);

			if (pNewSrc != NULL)
			{
				pNewSrc->SetUserName(GetResString(IDS_SAVED_SOURCE));
				dwAddedSources++;
			}
		}
		delete pSrcData;
	}

	if (dwAddedSources != 0)
		g_App.m_pMDlg->AddLogLine(LOG_FL_DBG, _T("Loaded %u sources for file %s"), dwAddedSources, pPartFile->GetFileName());
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	LoadSourcesFromFile() loads the sources for part file 'pPartFile' from the sources file 'srcFile'
//		and adds them to the source list 'pSrcList'.
void CSourceSaver::LoadSourcesFromFile(CPartFile *pPartFile, SourceList *pSrcList)
{
//	Sources filename is .met filename with leading .txtsrc in temp directory
	CStdioFile	srcFile;
	CString		strSrcFile = pPartFile->GetFilePath();

	strSrcFile += _T(".txtsrc");

//	Open the sources file. If it can't be opened, just return.
	if (!srcFile.Open(strSrcFile, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
		return;

	int		iPos;
	CString	strLine, strExpDate;
	uint32	dwIP;
	uint16	uPort;

//	Until we hit the EOF...
	while (srcFile.ReadString(strLine))
	{
	//	If it's a comment or an empty line, skip it
		if (strLine.IsEmpty() || strLine.GetAt(0) == _T('#'))
			continue;

	//	If the line doesn't contain the ':' for an ip:port pair, skip it
		if ((iPos = strLine.Find(_T(':'))) < 0)
			continue;

	//	Strip off the IP and convert it to a 32bit integer
	//	If the IP is invalid, skip the line
		if ((dwIP = inet_addr(strLine.Left(iPos))) == INADDR_NONE)
			continue;

		strLine = strLine.Mid(iPos + 1);

	//	If the line doesn't contain the ',' seperating the date, skip it
		if ((iPos = strLine.Find(_T(','))) < 0)
			continue;

	//	Strip off the port and convert it to an integer
	//	If the port is invalid, skip the line
		if ((uPort = static_cast<uint16>(_tstoi(strLine.Left(iPos)))) == 0)
			continue;

		strLine = strLine.Mid(iPos + 1);

	//	If the line doesn't contain the terminating ';', skip it
		if ((iPos = strLine.Find(_T(';'))) < 0)
			continue;

	//	Strip off the expiration date
		strExpDate = strLine.Left(iPos);

		if (IsExpired(strExpDate))
			continue;

	//	If we got a valid, unexpired source, add it to the 'srcList' list
		pSrcList->AddTail(new CSourceData(dwIP, uPort, strExpDate));
	}
	srcFile.Close();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SaveSources() writes to file 'srcFile' a list of up to 'iMaxSourcesToSave' sources composed of the
//		currently available sources with the highest number of available parts and the previously saved sources if needed.
void CSourceSaver::SaveSources(CPartFile *pPartFile, int iMaxSourcesToSave)
{
#ifndef NEW_SOCKETS_ENGINE
	POSITION		pos1, pos2;
	SourceList		srcList(iMaxSourcesToSave);
	CSourceData		*pSrcData;
	CString			strBuf1 = CalcExpiration(EXPIREIN);
	ClientList		clientListCopy;
	CUpDownClient	*pCurSrc;

//	Choose best sources for the file
	pPartFile->GetCopySourceLists(SLM_ALLOWED_TO_SAVE, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pCurSrc = *cIt;
		if ((pCurSrc == NULL) || pCurSrc->HasLowID())	//skip LowID sources
			continue;

		if (srcList.IsEmpty())
			srcList.AddHead(new CSourceData(pCurSrc, strBuf1));
	//	If the list isn't full or the source has more parts than the lowest in the list...
		else if ((srcList.GetCount() < iMaxSourcesToSave) || (pCurSrc->GetAvailablePartCount() > srcList.GetTail()->m_dwPartsAvailable))
		{
		//	If the list is full, remove the source with the lowest number of parts
			if (srcList.GetCount() == iMaxSourcesToSave)
				delete srcList.RemoveTail();

			ASSERT(srcList.GetCount() < iMaxSourcesToSave);

		//	Add the new source to the list in "# avail parts" order
			bool	bInserted = false;

		//	For each SourceData, (backwards starting with the last)...
			for (pos1 = srcList.GetTailPosition(); (pos2 = pos1) != NULL;)
			{
				pSrcData = srcList.GetPrev(pos1);
				if (pSrcData->m_dwPartsAvailable > pCurSrc->GetAvailablePartCount())
				{
					srcList.InsertAfter(pos2, new CSourceData(pCurSrc, strBuf1));
					bInserted = true;
					break;
				}
			}
			if (!bInserted)
				srcList.AddHead(new CSourceData(pCurSrc, strBuf1));
		}
	}

//	Add A4AF sources if number of source is less than the limit
	if (srcList.GetCount() < iMaxSourcesToSave)
	{
		pPartFile->GetCopyA4AFSourceList(&clientListCopy);
		for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
		{
			pCurSrc = *cIt;
			if ((pCurSrc == NULL) || pCurSrc->HasLowID())	//skip LowID sources
				continue;
			srcList.AddTail(new CSourceData(pCurSrc, strBuf1));
			if (srcList.GetCount() >= iMaxSourcesToSave)
				break;
		}
	}

//	Add previously saved sources if found sources does not reach the limit
	if (srcList.GetCount() < iMaxSourcesToSave)
	{
		SourceList	listOldSources(iMaxSourcesToSave);

		LoadSourcesFromFile(pPartFile, &listOldSources);

		bool	bFound;

		while (!listOldSources.IsEmpty())
		{
			pSrcData = listOldSources.RemoveHead();

			if (srcList.GetCount() < iMaxSourcesToSave)
			{
				bFound = false;

				for (pos1 = srcList.GetHeadPosition(); pos1 != NULL;)
				{
					if (srcList.GetNext(pos1)->Compare(pSrcData))
					{
						bFound = true;
						break;
					}
				}

				if (!bFound)
				{
					srcList.AddTail(pSrcData);
					pSrcData = NULL;	// Prevent deletion of needed object
				}
			}
			delete pSrcData;
		}
	}

	CStdioFile	srcFile;
	CString		strBuf2 = pPartFile->GetFilePath();

	strBuf2 += _T(".txtsrc");

//	Open the sources file. If it can't be opened, just return.
	if (!srcFile.Open(strBuf2, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::typeText))
	{
		while (!srcList.IsEmpty())
			delete srcList.RemoveHead();
		return;
	}

	CString	strSrcList;

//	Create the ED2K source link and the formatted sources list
	strBuf2 = pPartFile->CreateED2kLink();

	if (!srcList.IsEmpty())
	{
		strBuf2 += _T("|sources@@");
		strBuf2 += strBuf1;

		uint32	dwSrcCnt = 0, dwID;

		while (!srcList.IsEmpty())
		{
			pSrcData = srcList.RemoveHead();
			dwID = pSrcData->m_dwSrcIDHyb;
			strBuf1.Format( _T("%u.%u.%u.%u:%u"),
				static_cast<byte>(dwID >> 24), static_cast<byte>(dwID >> 16),
				static_cast<byte>(dwID >> 8), static_cast<byte>(dwID),
				pSrcData->m_uSourcePort );

			if (dwSrcCnt++ < 10)
				strBuf2.AppendFormat(_T(",%s"), strBuf1);

			strSrcList.AppendFormat(_T("%s,%s;\n"), strBuf1, pSrcData->m_pachExpDate);

			delete pSrcData;
		}
	}

//	For some settings file name in the link can be localized (save it using local code page)
	CStringA	strBufA(strBuf2);

	srcFile.WriteString(_T("#link: "));
	srcFile.Write(strBufA, strBufA.GetLength());
	srcFile.WriteString(_T("|/\n\n#format: ip:port,expirationdate(yymmdd);\n"));
	srcFile.WriteString(strSrcList);
	srcFile.Close();
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CalcExpiration() calculates a date 'dwDays' from the current date and returns it as a string in
//		'yymmdd' format.
CString CSourceSaver::CalcExpiration(uint32 dwDays)
{
	CTime	timeExpDate = CTime::GetCurrentTime() + CTimeSpan(dwDays, 0, 0, 0);

	return timeExpDate.Format(_T("%y%m%d"));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsExpired() returns true if 'strExpirationDate' is less than the current date or if it has an invalid format.
bool CSourceSaver::IsExpired(const CString &strExpirationDate)
{
	bool	bResult = true;

//	Check strExpDate format
	if (strExpirationDate.GetLength() == 6)
	{
		const TCHAR	*pcStr = strExpirationDate.GetString();
		TCHAR		acNum[2][3];

		acNum[0][0] = pcStr[0];
		acNum[0][1] = pcStr[1];
		acNum[0][2] = _T('\0');
		acNum[1][0] = pcStr[2];
		acNum[1][1] = pcStr[3];
		acNum[1][2] = _T('\0');

		CTime			timeExpDate( _tstoi(acNum[0]) + 2000,
			_tstoi(acNum[1]), _tstoi(&pcStr[4]), 0, 0, 0 );

		bResult = (timeExpDate < CTime::GetCurrentTime());
	}

	return bResult;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.49
log
@A source picked at configured limit for Save/Load Sources might not be the best one (initial logic broken in v1.2 revision 40 was sorting sources based on the available parts, last source selected at the configured limit was random instead of being the best from the left sources);
Selected A4AF sources for Save/Load Sources feature could go over configured limit.
@
text
@d41 1
a41 1
	m_dwSrcIDHyb = ntohl(dwIP);
@


1.48
log
@Simplified logging system implementation.
@
text
@d202 1
a202 1
		else if ((srcList.GetCount() <= iMaxSourcesToSave) || (pCurSrc->GetAvailablePartCount() > srcList.GetTail()->m_dwPartsAvailable))
a216 1

d239 2
d309 1
a309 1
			strBuf1.Format( _T("%u.%u.%u.%u"),
d311 2
a312 1
				static_cast<byte>(dwID >> 8), static_cast<byte>(dwID) );
d315 1
a315 1
				strBuf2.AppendFormat(_T(",%s:%u"), strBuf1, pSrcData->m_uSourcePort);
d317 1
a317 1
			strSrcList.AppendFormat(_T("%s:%u,%s;\n"), strBuf1, pSrcData->m_uSourcePort, pSrcData->m_pachExpDate);
@


1.47
log
@Save A4AF sources for Save/Load Sources feature {muleteer} (when not enough generic sources available save A4AF sources up to the set limit);
Fixed memory leak when writing to .txtsrc files fails.
@
text
@d111 1
a111 1
		g_App.m_pMDlg->AddDebugLogLine(_T("Loaded %u sources for file %s"), dwAddedSources, pPartFile->GetFileName());
@


1.46
log
@Reduced H-file dependency.
@
text
@d230 13
d286 3
d290 1
@


1.45
log
@Optimized expiry date parsing of the saved sources.
@
text
@d2 1
d196 1
a196 2
	//	If it's a LOWID source, skip it
		if ((pCurSrc == NULL) || pCurSrc->HasLowID())
@


1.44
log
@Allow export localized ed2k links (skip utf8 conversion) {DoubleT} -- GUI part will be added later; Allow saving link file name in .txtsrc using local code page.
@
text
@d329 1
a329 1
//	Check strExpDate format.
d332 12
a343 3
		CTime	timeExpDate( _tstoi(strExpirationDate.Left(2)) + 2000,
			_tstoi(strExpirationDate.Mid(2, 2)),
			_tstoi(strExpirationDate.Right(2)), 0, 0, 0 );
@


1.43
log
@Updated comment; Supressed compiler warnings.
@
text
@d304 3
d308 1
a308 1
	srcFile.WriteString(strBuf2);
@


1.42
log
@Local class was moved to the .cpp file;
Inverted variable keeping ID/IP to reduce IP conversion load.
@
text
@d64 1
a64 1
//	If the auto-save time (fixed 30 minutes) has passed...
d157 1
a157 1
		if ((uPort = _tstoi(strLine.Left(iPos))) == 0)
@


1.41
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d12 16
d31 1
a31 1
	m_dwSourceIP = ntohl(pClient->GetHybridUserID());
d40 1
a40 1
	m_dwSourceIP = dwIP;
d48 1
a48 1
	return ( (m_dwSourceIP == pSrcData->m_dwSourceIP)
d98 1
a98 1
		 	pNewSrc = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile, ntohl(pSrcData->m_dwSourceIP), pSrcData->m_uSourcePort, 0, 0, NULL);
d285 1
a285 1
		uint32	dwSrcCnt = 0, dwIP;
d290 1
a290 1
			dwIP = pSrcData->m_dwSourceIP;
d292 2
a293 4
								static_cast<byte>(dwIP),
								static_cast<byte>(dwIP >> 8),
								static_cast<byte>(dwIP >> 16),
								static_cast<byte>(dwIP >> 24) );
@


1.40
log
@UNICODE preparations; optimizations; formattings
@
text
@d15 1
a15 1
	m_dwSourceID = pClient->GetUserID();
d22 1
a22 1
CSourceData::CSourceData(uint32 dwID, uint16 uPort, LPCTSTR pachExpDate)
d24 1
a24 1
	m_dwSourceID = dwID;
d32 1
a32 1
	return ( (m_dwSourceID == pSrcData->m_dwSourceID)
d82 1
a82 1
		 	pNewSrc = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile, pSrcData->m_dwSourceID, pSrcData->m_uSourcePort, 0, 0, NULL);
d114 1
a114 1
	uint32	dwID;
d130 1
a130 1
		if ((dwID = inet_addr(strLine.Left(iPos))) == INADDR_NONE)
d157 1
a157 1
		pSrcList->AddTail(new CSourceData(dwID, uPort, strExpDate));
d269 1
a269 1
		uint32	dwSrcCnt = 0, dwID;
d274 1
a274 1
			dwID = pSrcData->m_dwSourceID;
d276 4
a279 4
								static_cast<byte>(dwID),
								static_cast<byte>(dwID >> 8),
								static_cast<byte>(dwID >> 16),
								static_cast<byte>(dwID >> 24) );
@


1.39
log
@Renaming in comments.
@
text
@d13 1
a13 1
CSourceSaver::CSourceData::CSourceData(CUpDownClient *pClient, const char *exp)
d15 4
a18 5
	sourceID = pClient->GetUserID();
	sourcePort = pClient->GetUserPort();
	partsavailable = pClient->GetAvailablePartCount();
	memcpy(expiration, exp, 6);
	expiration[6] = 0;
d20 1
d22 1
a22 2
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSourceSaver::CSourceData::CSourceData(uint32 dwID, uint16 uPort, const char *exp)
d24 4
a27 4
	sourceID = dwID;
	sourcePort = uPort;
	memcpy(expiration, exp, 6);
	expiration[6] = 0;
d30 1
a30 1
CSourceSaver::CSourceData::CSourceData(CSourceData *pOld)
d32 2
a33 5
	sourceID = pOld->sourceID; 
	sourcePort = pOld->sourcePort; 
	memcpy(expiration, pOld->expiration, 6); 
	partsavailable = pOld->partsavailable;
	expiration[6] = 0;
d37 1
a37 6
CSourceSaver::CSourceSaver(void)
{
	m_dwLastTimeSaved = ::GetTickCount() - rand() / 2;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSourceSaver::~CSourceSaver(void)
d39 1
d42 1
a42 1
//	Process() saves/loads up to 'maxSourcesToSave' sources for 'file' if the auto save/load timers
d44 1
a44 1
bool CSourceSaver::Process(CPartFile *file, int maxSourcesToSave, bool bIgnoreTimer /* = false */)
d48 2
a49 2
	//	If the auto-save time (fixed 30 minutes) has passed...
	if (((dwTicks - m_dwLastTimeSaved) > RESAVETIME) || bIgnoreTimer)
d51 3
a53 15
		//	Set next auto-save time + random 0..16 seconds
		m_dwLastTimeSaved = dwTicks - rand() / 2;

		SourceList srcs;

		//	Source file name is .part.txtsrc in temporary directory
		CString strSrcFile = file->GetFilePath();
		
		strSrcFile += _T(".txtsrc");
		LoadSourcesFromFile(file, &srcs, strSrcFile);
		SaveSources(file, &srcs, strSrcFile, maxSourcesToSave);

		//	Delete the old sources list
		while (!srcs.IsEmpty())
			delete srcs.RemoveHead();
d57 1
d61 2
a62 1
void CSourceSaver::LoadSources(CPartFile* file)
d64 14
a77 1
	SourceList srcs;
d79 4
a82 5
	//	Source file name is .part.txtsrc in temporary directory
	CString strSrcFile = file->GetFilePath();
	
	strSrcFile += _T(".txtsrc");
	LoadSourcesFromFile(file, &srcs, strSrcFile);
d84 8
a91 1
	AddSourcesToDownload(file, &srcs);
d93 3
a95 2
	while (!srcs.IsEmpty())
		delete srcs.RemoveHead();
d98 9
a106 5
//	LoadSourcesFromFile() loads the sources for part file 'file' from the source file 'slsfile'
//		and adds them to the source list 'sources'.
void CSourceSaver::LoadSourcesFromFile(CPartFile* file, SourceList* sources, const CString& slsfile)
{
	CStdioFile f;
d108 2
a109 2
//	Open the source file. If it can't be opened, just return.
	if (!f.Open(slsfile, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
d112 4
a115 1
	CString strLine, strTmp;
d117 2
a118 2
	//	Until we hit the EOF...
	while(f.ReadString(strLine))
d120 2
a121 2
	//	If it's a comment line, skip it
		if (strLine.GetAt(0) == '#')
a123 2
		int pos = strLine.Find(':');

d125 1
a125 1
		if (pos < 0)
a128 5
		strTmp = strLine.Left(pos);
		strLine = strLine.Mid(pos+1);

		uint32 dwID = inet_addr(strTmp);

d130 1
a130 1
		if (dwID == INADDR_NONE)
d133 2
d136 1
a136 2
		pos = strLine.Find(',');
		if (pos < 0)
a139 5
		strTmp = strLine.Left(pos);
		strLine = strLine.Mid(pos+1);

		uint16 wPort = atoi(strTmp);

d141 1
a141 1
		if (!wPort)
d144 2
d147 1
a147 2
		pos = strLine.Find(';');
		if (pos < 0)
d151 3
a153 2
		strTmp = strLine.Left(pos);
		if (IsExpired(strTmp))
d156 2
a157 4
	//	If we got a valid, unexpired source, add it to the 'sources' list
		CSourceData* newsource = new CSourceData(dwID, wPort, strTmp);

		sources->AddTail(newsource);
d159 1
a159 1
	f.Close();
d162 3
a164 1
void CSourceSaver::AddSourcesToDownload(CPartFile* file, SourceList* sources)
d167 6
a172 15
	//	For each SourceData...
	for (POSITION pos = sources->GetHeadPosition(); pos; sources->GetNext(pos))
	{
	//	If we did not reach  the maximum number of sources, allow to add some more
		if (file->GetSourceCount() < g_App.m_pPrefs->GetMaxSourcePerFile())
		{
			CSourceData* cur_src = sources->GetAt(pos);
			//CUpDownClient* newclient = new CUpDownClient(cur_src->sourcePort, cur_src->sourceID, 0, 0, file);
			//g_App.m_pDownloadQueue->CheckAndAddSource(file, newclient);

		 	CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(file, cur_src->sourceID, cur_src->sourcePort, 0, 0, NULL);
			if (pNewSource)
				pNewSource->SetUserName(GetResString(IDS_SAVED_SOURCE));
		}
	}
d174 1
a174 17
	if (sources->GetCount() > 0)
		g_App.m_pMDlg->AddDebugLogLine(_T("Loaded %i sources for file %s"), sources->GetCount(), file->GetFileName());
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SaveSources() writes to file 'slsfile' a list of up to 'maxSourcesToSave' sources composed of the
//		currently available sources with the highest number of available parts and the previously
//		saved sources in 'prevsources'.
void CSourceSaver::SaveSources(CPartFile *pPartFile, SourceList *prevsources, const CString &slsfile, int maxSourcesToSave)
{
#ifndef NEW_SOCKETS_ENGINE
	SourceList	srcstosave;
	CSourceData	*sourcedata;
	POSITION	pos, pos2;
	ClientList	clientListCopy;

// Choose best sources for the file
d178 1
a178 2
		CUpDownClient	*pCurSrc = *cIt;

d183 4
a186 8
		if (srcstosave.IsEmpty())
		{
			sourcedata = new CSourceData(pCurSrc, CalcExpiration(EXPIREIN));
			srcstosave.AddHead(sourcedata);
			continue;
		}
		//	If the list isn't full or the source has more parts than the lowest in the list...
		if ((srcstosave.GetCount() < maxSourcesToSave) || (pCurSrc->GetAvailablePartCount() > srcstosave.GetTail()->partsavailable))
d189 2
a190 2
			if (srcstosave.GetCount() == maxSourcesToSave)
				delete srcstosave.RemoveTail();
d192 1
a192 1
			ASSERT(srcstosave.GetCount() < maxSourcesToSave);
a193 1
		//
d195 1
a195 2
		//
			bool bInserted = false;
d198 1
a198 1
			for (pos2 = srcstosave.GetTailPosition();pos2 != 0;srcstosave.GetPrev(pos2))
d200 1
a200 1
				CSourceData* cur_srctosave = srcstosave.GetAt(pos2);
d202 1
a202 1
				if (cur_srctosave->partsavailable > pCurSrc->GetAvailablePartCount())
d204 1
a204 2
					sourcedata = new CSourceData(pCurSrc, CalcExpiration(EXPIREIN));
					srcstosave.InsertAfter(pos2, sourcedata);
d210 1
a210 4
			{
				sourcedata = new CSourceData(pCurSrc, CalcExpiration(EXPIREIN));
				srcstosave.AddHead(sourcedata);
			}
d214 2
a215 2
	// Add previously saved sources if found sources does not reach the limit
	for (pos = prevsources->GetHeadPosition(); pos; prevsources->GetNext(pos))
d217 1
a217 1
		CSourceData* cur_sourcedata = prevsources->GetAt(pos);
d219 1
a219 2
		if (srcstosave.GetCount() == maxSourcesToSave)
			break;
d221 1
a221 1
		ASSERT(srcstosave.GetCount() <= maxSourcesToSave);
d223 3
a225 1
		bool bFound = false;
d227 1
a227 3
		for (pos2 = srcstosave.GetHeadPosition(); pos2; srcstosave.GetNext(pos2))
		{
			if (srcstosave.GetAt(pos2)->Compare(cur_sourcedata))
d229 16
a244 2
				bFound = true;
				break;
d246 1
a246 4
		}
		if (!bFound)
		{
			srcstosave.AddTail(new CSourceData(cur_sourcedata));
d250 2
a251 2
	CString strLine;
	CStdioFile f;
d253 4
a256 1
	if (!f.Open(slsfile, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::typeText))
d258 7
a264 3
	f.WriteString("#link: " + pPartFile->CreateED2KSourceLink(2,10, true) + "\n\n");
	f.WriteString("#format: a.b.c.d:port,expirationdate(yymmdd);\n");
	while (!srcstosave.IsEmpty())
d266 22
a287 7
		CSourceData* cur_src = srcstosave.RemoveHead();
		uint32 dwID = cur_src->sourceID;
		uint16 wPort = cur_src->sourcePort;

		strLine.Format("%i.%i.%i.%i:%i,%s;\n", (byte)dwID,(byte)(dwID>>8),(byte)(dwID>>16),(byte)(dwID>>24), wPort, cur_src->expiration);
		delete cur_src;
		f.WriteString(strLine);
d289 6
a294 1
	f.Close();
d298 1
a298 1
//	CalcExpiration() calculates a date 'nDays' from the current date and returns it as a string in
d300 1
a300 1
CString CSourceSaver::CalcExpiration(int nDays)
d302 1
a302 8
	CTime expiration = CTime::GetCurrentTime();
	CTimeSpan timediff(nDays, 0, 0, 0);

	expiration += timediff;

	CString strExpiration;

	strExpiration.Format("%02i%02i%02i", (expiration.GetYear() % 100), expiration.GetMonth(), expiration.GetDay());
d304 1
a304 1
	return strExpiration;
d307 1
a307 1
//	IsExpired() returns true if 'expirationdate' is less than the current date or if it has an invalid format.
d310 3
a312 1
	//	Format check. CSourceData code naively relies on correct format
d315 3
a317 3
		int		year = atoi(strExpirationDate.Mid(0, 2)) + 2000;
		int		month = atoi(strExpirationDate.Mid(2, 2));
		int		day = atoi(strExpirationDate.Mid(4, 2));
d319 2
a320 1
		CTime	expiration(year, month, day, 0, 0, 0);
d322 1
a322 4
		return (expiration < CTime::GetCurrentTime());
	}
	else
		return true;
@


1.38
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d175 1
a175 1
			//g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(file, newclient);
@


1.37
log
@renamed 3 variables
@
text
@d171 1
a171 1
		if (file->GetSourceCount() < g_App.g_pPrefs->GetMaxSourcePerFile())
@


1.36
log
@Unified processing of part and temporary file names.
@
text
@d171 1
a171 1
		if (file->GetSourceCount() < g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile())
d177 1
a177 1
		 	CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(file, cur_src->sourceID, cur_src->sourcePort, 0, 0, NULL);
d184 1
a184 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("Loaded %i sources for file %s"), sources->GetCount(), file->GetFileName());
@


1.35
log
@Corrections for SSDQ integration.
@
text
@d64 2
a65 2
		//	Source file name is .met file name .txtsrc in temp directory
		CString strSrcFile = RemoveFileExtension(file->GetFullName());
d84 2
a85 2
	//	Source file name is .met file name .txtsrc in temp directory
	CString strSrcFile = RemoveFileExtension(file->GetFullName());
@


1.34
log
@improved LowID check by SX (part 2)
@
text
@d199 2
a200 2
	// Choose best sources for the file
	pPartFile->GetCopySourceList(DS_DOWNLOADING, DS_LAST_QUEUED_STATE, &clientListCopy);
@


1.33
log
@Simplified transition to eklmn's SSDQ.
@
text
@d177 1
a177 1
		 	CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(file, cur_src->sourceID, cur_src->sourcePort, 0, 0);
@


1.32
log
@changed the variable names according our convection
@
text
@d191 1
a191 1
void CSourceSaver::SaveSources(CPartFile* pPartFile, SourceList* prevsources, const CString& slsfile, int maxSourcesToSave)
d194 4
a197 2
	SourceList srcstosave;
	CSourceData* sourcedata;
d199 5
a203 1
	ASSERT(srcstosave.IsEmpty());
d205 3
a207 1
	POSITION pos, pos2;
d209 19
a227 3
	//
	// Choose best sources for the file
	//
d229 2
a230 8
	//	For each source slot...
	for (int sl=0;sl<SOURCESSLOTS;sl++)
	{
		//	If the slot contains sources...
		if (!pPartFile->m_srcLists[sl].IsEmpty())
		{
			//	For each source in the slot...
			for (pos = pPartFile->m_srcLists[sl].GetHeadPosition(); pos != NULL; pPartFile->m_srcLists[sl].GetNext(pos))
d232 1
a232 5
				CUpDownClient* pCurSource = pPartFile->m_srcLists[sl].GetAt(pos);

			//	If it's a LOWID source, skip it
				if (pCurSource->HasLowID())
					continue;
d234 1
a234 1
				if (srcstosave.IsEmpty())
d236 4
a239 36
					sourcedata = new CSourceData(pCurSource, CalcExpiration(EXPIREIN));
					srcstosave.AddHead(sourcedata);
					continue;
				}
				//	If the list isn't full or the source has more parts than the lowest in the list...
				if ((srcstosave.GetCount() < maxSourcesToSave) || (pCurSource->GetAvailablePartCount() > srcstosave.GetTail()->partsavailable))
				{
				//	If the list is full, remove the source with the lowest number of parts
					if (srcstosave.GetCount() == maxSourcesToSave)
						delete srcstosave.RemoveTail();

					ASSERT(srcstosave.GetCount() < maxSourcesToSave);

				//
				//	Add the new source to the list in "# avail parts" order
				//
					bool bInserted = false;

				//	For each SourceData, (backwards starting with the last)...
					for (pos2 = srcstosave.GetTailPosition();pos2 != 0;srcstosave.GetPrev(pos2))
					{
						CSourceData* cur_srctosave = srcstosave.GetAt(pos2);

						if (cur_srctosave->partsavailable > pCurSource->GetAvailablePartCount())
						{
							sourcedata = new CSourceData(pCurSource, CalcExpiration(EXPIREIN));
							srcstosave.InsertAfter(pos2, sourcedata);
							bInserted = true;
							break;
						}
					}
					if (!bInserted)
					{
						sourcedata = new CSourceData(pCurSource, CalcExpiration(EXPIREIN));
						srcstosave.AddHead(sourcedata);
					}
d241 5
a275 2
//	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("Saving %i sources for file %s to slsfile"), srcstosave.GetCount(), file->GetFileName());

@


1.31
log
@More ifdefs for v2
@
text
@d191 1
a191 1
void CSourceSaver::SaveSources(CPartFile* file, SourceList* prevsources, const CString& slsfile, int maxSourcesToSave)
d209 1
a209 1
		if (!file->m_srcLists[sl].IsEmpty())
d212 1
a212 1
			for (pos = file->m_srcLists[sl].GetHeadPosition(); pos != NULL; file->m_srcLists[sl].GetNext(pos))
d214 1
a214 1
				CUpDownClient* cur_src = file->m_srcLists[sl].GetAt(pos);
d217 1
a217 1
				if (cur_src->HasLowID())
d222 1
a222 1
					sourcedata = new CSourceData(cur_src, CalcExpiration(EXPIREIN));
d227 1
a227 1
				if ((srcstosave.GetCount() < maxSourcesToSave) || (cur_src->GetAvailablePartCount() > srcstosave.GetTail()->partsavailable))
d245 1
a245 1
						if (cur_srctosave->partsavailable > cur_src->GetAvailablePartCount())
d247 1
a247 1
							sourcedata = new CSourceData(cur_src, CalcExpiration(EXPIREIN));
d255 1
a255 1
						sourcedata = new CSourceData(cur_src, CalcExpiration(EXPIREIN));
d296 1
a296 1
	f.WriteString("#link: " + file->CreateED2KSourceLink(2,10, true) + "\n\n");
@


1.30
log
@Removed one extra file sources saving attempt (initial attempt right after start);
Improved string processing and other minor optimization.
@
text
@d4 1
d6 3
d12 1
d21 1
d166 1
d185 1
d193 1
d309 1
@


1.29
log
@Fix for my last change...
@
text
@d1 2
a2 2
#include "StdAfx.h"
#include "sourcesaver.h"
d8 1
a8 1
CSourceSaver::CSourceData::CSourceData(CUpDownClient* client, const char* exp)
d10 21
a30 4
	sourceID = client->GetUserID();
	sourcePort = client->GetUserPort();
	partsavailable = client->GetAvailablePartCount();
	memcpy2(expiration, exp, 7);
d37 1
a37 1
m_dwLastTimeSaved = ::GetTickCount() + (rand() * 30000 / RAND_MAX) - 15000 - RESAVETIME;
d48 2
d51 1
a51 1
	if (((int)(::GetTickCount() - m_dwLastTimeSaved) > RESAVETIME) || bIgnoreTimer)
d53 2
a54 2
		//	Set next auto-save time +/- random 15 seconds
		m_dwLastTimeSaved = ::GetTickCount() + (rand() * 30000 / RAND_MAX) - 15000;
d59 3
a61 1
		CString strSrcFile = CString(RemoveFileExtension(file->GetFullName())) + CString(".txtsrc");
d79 3
a81 1
	CString strSrcFile = CString(RemoveFileExtension(file->GetFullName())) + CString(".txtsrc");
d92 1
a92 1
void CSourceSaver::LoadSourcesFromFile(CPartFile* file, SourceList* sources, CString& slsfile)
d100 1
a100 1
	CString strLine;
d112 1
a112 1
		if (pos == -1)
a114 1
	//
d116 1
a116 2
		CString strIP = strLine.Left(pos);

d119 1
a119 1
		uint32 dwID = inet_addr(strIP);
d127 1
a127 1
		if (pos == -1)
d131 1
a131 2
		CString strPort = strLine.Left(pos);

d134 1
a134 1
		uint16 wPort = atoi(strPort);
d142 1
a142 1
		if (pos == -1)
d146 2
a147 2
		CString strExpiration = strLine.Left(pos);
		if (IsExpired(strExpiration))
d151 1
a151 1
		CSourceData* newsource = new CSourceData(dwID, wPort, strExpiration);
d183 1
a183 1
void CSourceSaver::SaveSources(CPartFile* file, SourceList* prevsources, CString& slsfile, int maxSourcesToSave)
d319 1
a319 1
bool CSourceSaver::IsExpired(CString expirationdate)
a320 1
	//
d322 1
a322 1
	if (expirationdate.GetLength() == 6)
d324 3
a326 3
		int		year = atoi(expirationdate.Mid(0, 2)) + 2000;
		int		month = atoi(expirationdate.Mid(2, 2));
		int		day = atoi(expirationdate.Mid(4, 2));
@


1.28
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d29 1
a29 1
bool CSourceSaver::Process(CPartFile *file, int maxSourcesToSave)
d32 1
a32 1
	if ((int)(::GetTickCount() - m_dwLastTimeSaved) > RESAVETIME)
@


1.27
log
@Increased sources resave time (no need to save them every 10 min.)
@
text
@d157 1
a157 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(/*TBN_NONOTIFY, */false, "Loaded %i sources for file %s", sources->GetCount(), file->GetFileName());
d260 1
a260 1
//	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(/*TBN_NONOTIFY, */false, "Saving %i sources for file %s to slsfile", srcstosave.GetCount(), file->GetFileName());
@


1.26
log
@Fixed open of configuration files accessed for reading by other processes
<thanks Fuxie - DK for report and testing>;
Improved string processing.
@
text
@a19 1
// m_dwLastTimeLoaded = ::GetTickCount() - RELOADTIME;
d31 1
a31 1
	//	If the auto-save time (fixed 10 minutes) has passed...
d43 2
a44 9
/*
		if ((int)(::GetTickCount() - m_dwLastTimeLoaded) > RELOADTIME)
		{
			m_dwLastTimeLoaded = ::GetTickCount() + (rand() * 30000 / RAND_MAX) - 15000;
			AddSourcesToDownload(file, &srcs);
		}
*/
	//
	//	Delete the old sources list
a108 1
	//
@


1.25
log
@Method removal (deletion now is implemented during part file processing).
@
text
@a78 1
	CString strLine;
d81 2
a82 2
	//	Open the source file. If it can't be opened, just return.
	if (!f.Open(slsfile, CFile::modeRead | CFile::typeText))
d85 2
d144 1
a144 1
    f.Close();
d274 1
a274 1
	if (!f.Open(slsfile, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
@


1.24
log
@replaced  pos != 0 to pos != NULL
@
text
@a74 8
void CSourceSaver::DeleteFile(CPartFile* file)
{
	//	Source file name is .met file name .txtsrc in temp directory
	CString strSrcFile = CString(RemoveFileExtension(file->GetFullName())) + CString(".txtsrc");
	if (_tremove(strSrcFile) && errno != ENOENT)
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strSrcFile);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.23
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d199 1
a199 1
			for (pos = file->m_srcLists[sl].GetHeadPosition();pos != 0;file->m_srcLists[sl].GetNext(pos))
@


1.22
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d291 1
a291 1
		strLine.Format("%i.%i.%i.%i:%i,%s;\n", (uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), wPort, cur_src->expiration);
@


1.21
log
@final fixes for ed2k source links
@
text
@d8 1
a8 1
CSourceSaver::CSourceData::CSourceData(CUpDownClient* client, const char* exp) 
d10 2
a11 2
	sourceID = client->GetUserID(); 
	sourcePort = client->GetUserPort(); 
d44 1
a44 1
/*	
d53 1
a53 1
		while (!srcs.IsEmpty()) 
d55 1
a55 1
		
d70 2
a71 2
	
	while (!srcs.IsEmpty()) 
d116 1
a116 1
		if (dwID == INADDR_NONE) 
d154 1
a154 1
void CSourceSaver::AddSourcesToDownload(CPartFile* file, SourceList* sources) 
d171 1
a171 1
	
d193 1
a193 1
	for (int sl=0;sl<SOURCESSLOTS;sl++) 
d246 1
a246 1
			}	
d249 1
a249 1
	
d306 1
a306 1
    
@


1.20
log
@Fixed debuglog problem with a SourceSaver change.
Reinstated removal of ? clients on queue.
@
text
@d283 1
a283 1
	f.WriteString("#link: " + file->CreateED2KSourceLink(2,10, false) + "\n\n");
@


1.19
log
@Minor changes
@
text
@d283 1
a283 1
	f.WriteString("#link: " + file->CreateED2KSourceLink(2,10) + "\n\n");
@


1.18
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d283 1
a283 1
	f.WriteString("#link: " + file->CreateED2kLink() + "\n\n");
@


1.17
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d80 1
a80 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), strSrcFile);
@


1.16
log
@Added some colors to the logs...
@
text
@d80 1
a80 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), strSrcFile);
@


1.15
log
@added ed2k-link to .txtsrc files
@
text
@d80 1
a80 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, IDS_ERR_DELETEFAILED, strSrcFile);
@


1.14
log
@Removed NNS feature and changed SLS
@
text
@d283 1
@


1.13
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d20 1
a20 1
m_dwLastTimeLoaded = ::GetTickCount() - RELOADTIME;
d44 1
a44 1
	
d50 1
a50 1

d61 14
d171 3
a173 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(/*TBN_NONOTIFY, */false, "Loaded %i sources for file %s", sources->GetCount(), file->GetFileName());
@


1.12
log
@new way of adding sources
@
text
@d145 2
a146 2
		//If we did not rich  the maximum number of sources, allow to add some more
		if ( file->GetSourceCount() < g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile())
@


1.11
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d145 2
a146 2
	//	If we already have the maximum number of sources allowed for 'file', just return
		if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() <= file->GetSourceCount())
d148 7
a154 1
			break;
a155 5
    
		CSourceData* cur_src = sources->GetAt(pos);
		CUpDownClient* newclient = new CUpDownClient(cur_src->sourcePort, cur_src->sourceID, 0, 0, file);

	 	g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(file, newclient);
@


1.10
log
@Updates
@
text
@d13 1
a13 1
	memcpy(expiration, exp, 7);
@


1.9
log
@Removed option to disable File Status icons
Added old actions to new File Status icons
Removed spamming log from Source Saver
Removed old non used icons from resources
Updated +/- icons with Psy suggestion
@
text
@a38 1
		CString slsfilepath;
d41 3
a43 4
		CString strTempPath = RemoveFileExtension(file->GetFullName());
		slsfilepath.Format("%s\\%s.txtsrc", strTempPath, file->GetPartMetFileName());
		LoadSourcesFromFile(file, &srcs, slsfilepath);
		SaveSources(file, &srcs, slsfilepath, maxSourcesToSave);
d63 4
a66 5
	CString slsfilepath;

	slsfilepath.Format("%s\\%s.txtsrc", g_eMuleApp.m_pGlobPrefs->GetTempDir(), file->GetPartMetFileName());
	if (_tremove(slsfilepath) && errno != ENOENT)
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, IDS_ERR_DELETEFAILED, slsfilepath);
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d262 1
a262 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(/*TBN_NONOTIFY, */false, "Saving %i sources for file %s to slsfile", srcstosave.GetCount(), file->GetFileName());
@


1.7
log
@Localization and some fixes for new detail dialogs by FoRcHa
@
text
@d182 1
a182 1
		if (!file->srclists[sl].IsEmpty())
d185 1
a185 1
			for (pos = file->srclists[sl].GetHeadPosition();pos != 0;file->srclists[sl].GetNext(pos))
d187 1
a187 1
				CUpDownClient* cur_src = file->srclists[sl].GetAt(pos);
@


1.6
log
@More information in a DebugLog message
@
text
@d42 2
a43 1
		slsfilepath.Format("%s\\%s.txtsrc", g_eMuleApp.m_pGlobPrefs->GetTempDir(), file->GetPartMetFileName());
@


1.5
log
@fix for errors on removing a file when no space on Temp disk (#0000284)
fix for queue filtering (forgot that the list is updated :P)
@
text
@a172 2
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(/*TBN_NONOTIFY, */false, "Saving sources to slsfile");

d261 1
a261 2
//	*Please don't delete*
//	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddDebugLogLine(/*TBN_NONOTIFY, */false, "Saving %i sources for file %s to slsfile", srcstosave.GetCount(), file->GetFileName()));
@


1.4
log
@Tried to reduce the amount of log output and make it more useful.
@
text
@d67 2
a68 3
	if (remove(slsfilepath))
		if (errno != ENOENT)
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, "Failed to delete %s, you will need to do this by hand", slsfilepath);    
@


1.3
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d159 1
a159 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddLogLine(/*TBN_NONOTIFY, */false, "Loaded %i sources for file %s", sources->GetCount(), file->GetFileName()));	
d174 2
d264 2
a265 1
	DEBUG_ONLY(g_eMuleApp.m_pdlgEmule->AddLogLine(/*TBN_NONOTIFY, */false, "Saving %i sources for file %s to slsfile", srcstosave.GetCount(), file->GetFileName()));
@


1.2
log
@Second batch of name changes
@
text
@d42 1
a42 1
		slsfilepath.Format("%s\\%s.txtsrc", theApp.glob_prefs->GetTempDir(), file->GetPartMetFileName());
d66 1
a66 1
	slsfilepath.Format("%s\\%s.txtsrc", theApp.glob_prefs->GetTempDir(), file->GetPartMetFileName());
d69 1
a69 1
		theApp.emuledlg->AddLogLine(true, "Failed to delete %s, you will need to do this by hand", slsfilepath);    
d149 1
a149 1
		if (theApp.glob_prefs->GetMaxSourcePerFile() <= file->GetSourceCount())
d157 1
a157 1
	 	theApp.downloadqueue->CheckAndAddSource(file, newclient);
d159 1
a159 1
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(/*TBN_NONOTIFY, */false, "Loaded %i sources for file %s", sources->GetCount(), file->GetFileName()));	
d262 1
a262 1
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(/*TBN_NONOTIFY, */false, "Saving %i sources for file %s to slsfile", srcstosave.GetCount(), file->GetFileName()));
@


1.1
log
@Missing files :P
@
text
@d6 2
a7 6
CSourceSaver::CSourceSaver(void)
{
m_dwLastTimeLoaded = ::GetTickCount() - RELOADTIME;
m_dwLastTimeSaved = ::GetTickCount() + (rand() * 30000 / RAND_MAX) - 15000 - RESAVETIME;
}

d16 8
a23 2


d27 4
a30 2

bool CSourceSaver::Process(CPartFile* file, int maxSourcesToSave) // return false if sources not saved
d32 1
d35 1
d37 1
d40 2
d52 2
d61 1
a61 1

d65 1
d67 2
a68 1
	if (remove(slsfilepath)) if (errno != ENOENT)
d71 3
a73 1

d78 2
d82 2
d86 1
d89 1
d91 2
d95 3
d99 1
d101 1
d103 2
d107 2
d112 3
d116 1
d118 1
d120 2
d124 2
d129 2
d135 1
d137 1
a138 1
		
d142 1
a142 1

d145 1
d148 1
d150 3
a152 1
			return;
d156 1
d161 4
a164 1

d174 1
d176 3
d181 1
d184 1
d188 2
d192 3
a194 1
				if (srcstosave.IsEmpty()) {
d199 1
d202 1
d205 1
d207 4
d212 2
d217 1
d237 2
a238 1
	for (pos = prevsources->GetHeadPosition(); pos; prevsources->GetNext(pos)) {
d240 1
d243 1
d247 5
a251 2
		for (pos2 = srcstosave.GetHeadPosition(); pos2; srcstosave.GetNext(pos2)) {
			if (srcstosave.GetAt(pos2)->Compare(cur_sourcedata)) {
d256 2
a257 1
		if (!bFound) {
a259 1
			
d262 1
a262 1
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(/*TBN_NONOTIFY, */false, "Saving %i sources for file %s", srcstosave.GetCount(), file->GetFileName()));	
d266 1
d275 1
d282 3
a284 1

d289 1
d293 1
d298 2
a299 1

d302 9
a310 3
	int year = atoi(expirationdate.Mid(0, 2)) + 2000;
	int month = atoi(expirationdate.Mid(2, 2));
	int day = atoi(expirationdate.Mid(4, 2));
d312 4
a315 2
	CTime expiration(year, month, day, 0, 0, 0);
	return (expiration < CTime::GetCurrentTime());
d317 1
@

