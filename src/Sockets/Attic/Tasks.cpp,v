head	1.20;
access;
symbols
	PublicRelease_1i:1.18
	Interim_Release_1i_RC6:1.18
	Interim_Release_1i_RC3:1.17
	Interim_Release_1i_RC2:1.15
	Interim_Release_1i_RC1:1.13
	Interim_Release_1i_beta3:1.13
	Interim_Release_1i_beta2:1.12
	Interim_Release_1i_beta1:1.11
	PublicRelease_1h:1.10
	Interim_Release_1h_rc2:1.9
	Interim_Release_1h_RC1:1.9
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.20
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.19;

1.19
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.03.19.28.01;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2003.11.19.11.14.32;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.19.09.23.41;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.17.10.24.33;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.29.14.14.25;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.17.30.41;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.20.15.44.22;	author morevit;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.16.16.34.40;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.08.17.55.38;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.04.11.19.28;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.03.17.56.29;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.03.11.50.54;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.15.10.08.19;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.20
log
@New engine
@
text
@// Tasks.cpp: implementation of the CTasks class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "Tasks.h"
#include "EmEngine.h"
#include "../EngineData.h"
#include "TaskProcessor_Main.h"
#include "OpCode.h"

//////////////////////////////////////////////////////////////////////
// global and sockets task functions
CTask::~CTask()
{
}

bool CTask::OnException(CEmEngine&)
{
	// delete this buggy task
	return true;
}

bool CTask::ProcessForUI(CEmEngine&)
{
	return true;
}

bool CTask_Tcp_Err::Post(CEmEngine& stEngine, SOCKET hSocket, int nErrorCode)
{
	CTask_Tcp_Err* pTask = new CTask_Tcp_Err;
	if (pTask)
	{
		pTask->m_hSocket = hSocket;
		pTask->m_nError = nErrorCode;
		stEngine.m_stMain.Push(pTask);
	} 
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
	}

	return NULL != pTask;
}

bool CTask_Tcp_Err::Process(CEmEngine& stEngine)
{
	// check if we still have this client
	CEmClient* pClient = stEngine.m_stMain.Lookup(m_hSocket);
	if (pClient)
	{
		ASSERT(pClient->m_hSocket == m_hSocket);
		// here we can write to the log that this client has disconnected from us

		stEngine.m_stMain.KillClient(pClient);
	}

	return true;
}

bool CTask_Tcp_Accepted::Process(CEmEngine& stEngine)
{
	CEmClient* pClient = stEngine.m_stMain.AllocClient(m_eType);
	ASSERT(pClient);
	if (pClient)
	{
		pClient->m_hSocket = m_hSocket;
		pClient->m_bIsConnected = true;
		stEngine.m_stMain.m_mapClients[m_hSocket] = pClient;

		pClient->OnAccepted(stEngine);

	} else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
		if (closesocket(m_hSocket))
			AddDebugLogLine(false, "closesocket failed");
	}

	return true;
}

bool CTask_Tcp_Connected::Process(CEmEngine& stEngine)
{
	CEmClient* pClient = stEngine.m_stMain.Lookup(m_hSocket);
	if (pClient)
	{
		ASSERT(!pClient->m_bIsConnected);
		pClient->m_bIsConnected = true;

		pClient->OnConnected(stEngine);
	}
	return true;
}

bool CTask_Tcp_Web::Process(CEmEngine& stEngine)
{
	CEmClient_Web* pClient = (CEmClient_Web*) stEngine.m_stMain.Lookup(m_hSocket);
	if (pClient)
	{
		ASSERT(T_CLIENT_WEB == pClient->GetType());

		  CString strTxt;
		  strTxt.Format("Currently I have %d clients", stEngine.m_stMain.m_mapClients.size());
		  stEngine.m_stTcp.AllocSend(m_hSocket, (LPCTSTR) strTxt, strTxt.GetLength());
		  stEngine.m_stTcp.AllocDisconnect(m_hSocket);
	}

	return true;
}
// end of global and socket task functions
//////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////
// connect
CTask_Connect::CTask_Connect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType)
	: m_nAddr(nAddr), m_uPort(nPort), m_eType(eType)
{
}

//////////////////////////////////////////////////////////////////////
CTask_Connect::CTask_Connect(LPCTSTR sAddr, USHORT nPort, T_CLIENT_TYPE eType) 
	: m_nAddr(inet_addr(sAddr)), m_uPort(nPort), m_eType(eType)
{
}

//////////////////////////////////////////////////////////////////////
CTask_Connect::CTask_Connect(CServer* pServer /* = NULL*/)
{
	EMULE_TRY

/*	if(pServer)
	{
		AddLogLine(false, IDS_CONNECTINGTO, pServer->GetListName(), pServer->GetAddress(), pServer->GetPort());

		m_nAddr = inet_addr(pServer->GetAddress());
		m_uPort = pServer->GetPort();
	}
	else
		m_nAddr = m_uPort = NULL;
*/
	m_eType = T_CLIENT_SERVER;

	EMULE_CATCH2
}

//////////////////////////////////////////////////////////////////////
bool CTask_Connect::Process(CEmEngine& stEngine)
{
	if(m_nAddr && m_uPort)
		stEngine.m_stMain.AllocTcpConnect(m_nAddr, m_uPort, m_eType);
	else
	{
		// Connect to any server
	}

	return true;
}

//////////////////////////////////////////////////////////////////////
// disconnect
CTask_KillClient::CTask_KillClient(CEmClient* pClient)
	: m_pClient(pClient)
{
}

//////////////////////////////////////////////////////////////////////
bool CTask_KillClient::Process(CEmEngine& stEngine)
{
	stEngine.m_stMain.KillClient(m_pClient);

	return true;
}

//////////////////////////////////////////////////////////////////////
// synchronize server state
CTask_ServerState::CTask_ServerState(bool bForConnected, ServerState stState, long nClientID)
{
	m_bForConnected = bForConnected;
	m_stState = stState;
	m_nClientID = nClientID;
}

//////////////////////////////////////////////////////////////////////
bool CTask_ServerState::Process(CEmEngine& stEngine)
{
	stEngine.PushToUI(this);

	return false;
}

//////////////////////////////////////////////////////////////////////
bool CTask_ServerState::ProcessForUI(CEmEngine&)
{
/*	if(g_eMuleApp.m_pdlgEmule->m_pEngineData)
		g_eMuleApp.m_pdlgEmule->m_pEngineData->ImportServerState(this);
*/
	return true;
}

//////////////////////////////////////////////////////////////////////
// send list of shared files
CTask_SendSharedList::CTask_SendSharedList()
{
	m_bProcessedUI = false;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendSharedList::Process(CEmEngine& stEngine)
{
	if(!stEngine.m_stData.IsConnected())
		return true;

	// first collect shared files info
	if(!m_bProcessedUI)
	{
		stEngine.PushToUI(this);
		return false;
	}

	// afterwards, send it
/*	COpCode_OFFERFILES stMsg;
	for(int i = 0; i < m_Files.GetCount(); i++)
	{
		COpCode_OFFERFILES::CStruct_Files file;
		md4cpy(file._Hash, m_Files[i]._Hash);
		file._Client._Addr = 0;
		file._Client._Port = 0;
		file._FileName.m_strValue = m_Files[i]._FileName;
		file._FileName.m_bValid = true;
		file._FileSize.m_dwValue = m_Files[i]._FileSize;
		file._FileSize.m_bValid = true;
		stMsg._Files.Add(file);
	}
	stEngine.m_stTcp.AllocSend(stEngine.m_stData.GetConnectedServer(), stMsg);
*/
	return true;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendSharedList::ProcessForUI(CEmEngine& stEngine)
{
/*	CKnownFile	*pKnownFile;
	CCKey		bufKey;
	for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != 0; )
	{
		g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
		if(pKnownFile)
		{
			OFFEREDFILE File;

			md4cpy(File._Hash, pKnownFile->GetFileHash());
			File._Addr = 0;
			File._Port = 0;
			File._FileName = pKnownFile->GetFileName();
			File._FileSize = pKnownFile->GetFileSize();

			m_Files.Add(File);

			pKnownFile->SetOfferedToServer(true);
		}
	}
*/
	m_bProcessedUI = true;

	stEngine.m_stMain.Push(this);

	return false;
}
@


1.19
log
@New engine
@
text
@@


1.18
log
@New sockets
@
text
@a5 1
#ifdef NEW_SOCKETS
a8 1
#include "../emule.h"
a9 1
#include "../server.h"
d71 1
a71 1
		stEngine.m_stMain.m_mapClients.SetAt(m_hSocket, pClient);
d107 1
a107 1
		  strTxt.Format("Currently I have %d clients", stEngine.m_stMain.m_mapClients.GetCount());
d136 1
a136 1
	if(pServer)
d145 1
a145 1

d199 1
a199 1
	if(g_eMuleApp.m_pdlgEmule->m_pEngineData)
d201 1
a201 1

d226 1
a226 1
	COpCode_OFFERFILES stMsg;
d240 1
a240 1

d247 1
a247 1
	CKnownFile	*pKnownFile;
d267 1
a267 1

a273 3


#endif@


1.17
log
@New sockets - can offer files to server
@
text
@d229 1
d232 9
a240 11
		COpCode_OFFERFILES stMsg;
		stMsg._Count = 1;
		md4cpy(stMsg._Hash, m_Files[i]._Hash);
		stMsg._Client._Addr = 0;
		stMsg._Client._Port = 0;
		stMsg._FileName.m_strValue = m_Files[i]._FileName;
		stMsg._FileName.m_bValid = true;
		stMsg._FileSize.m_dwValue = m_Files[i]._FileSize;
		stMsg._FileSize.m_bValid = true;

		stEngine.m_stTcp.AllocSend(stEngine.m_stData.GetConnectedServer(), stMsg);
d242 1
@


1.16
log
@New sockets
@
text
@d229 11
a239 2
	COpCode_OFFERFILES stMsg;
	stMsg._Files.Copy(m_Files);
d241 2
a242 1
	stEngine.m_stTcp.AllocSend(stEngine.m_stData.GetConnectedServer(), stMsg);
d262 2
a263 12
			File._Filename.m_nType = OP_TAG_STRING;
			File._Filename.m_nNameLen = 1;
			File._Filename.m_dwName = FT_FILENAME;
			File._Filename.m_pTag = new CTag_String;
			((CTag_String*)File._Filename.m_pTag)->m_strValue = pKnownFile->GetFileName();
			((CTag_String*)File._Filename.m_pTag)->m_bValid = true;
			File._Filesize.m_nType = OP_TAG_DWORD;
			File._Filesize.m_nNameLen = 1;
			File._Filesize.m_dwName = FT_FILESIZE;
			File._Filesize.m_pTag = new CTag_DWORD;
			((CTag_DWORD*)File._Filesize.m_pTag)->m_dwValue = pKnownFile->GetFileSize();
			((CTag_DWORD*)File._Filesize.m_pTag)->m_bValid = true;
@


1.15
log
@New sockets
@
text
@d14 1
d218 3
d227 1
d229 4
a232 2
	else
	{
d234 1
a234 1
	}
d240 1
a240 1
/*	CKnownFile	*pKnownFile;
d247 2
a248 1
			HASHADDRPORT File;
d250 17
a266 1
			File._Addr = 
a268 1
		WriteToOfferedFilePacket(*pKnownFile, packetStream);	// (offered file info)[count]
d270 3
a272 1
*/
@


1.14
log
@New sockets
@
text
@d27 1
a27 1
void CTask::ProcessForUI(CEmEngine&)
d29 1
d199 1
a199 1
void CTask_ServerState::ProcessForUI(CEmEngine&)
d203 9
d213 40
@


1.13
log
@Formatting, comments, and name changes.
@
text
@d15 2
d115 2
d118 3
d126 1
d132 1
d152 1
d165 2
d172 1
d180 2
d189 1
d197 1
@


1.12
log
@New sockets - more server code
@
text
@d115 1
a115 1
	: m_nAddr(nAddr), m_nPort(nPort), m_eType(eType)
d120 1
a120 1
	: m_nAddr(inet_addr(sAddr)), m_nPort(nPort), m_eType(eType)
d133 1
a133 1
		m_nPort = pServer->GetPort();
d136 1
a136 1
		m_nAddr = m_nPort = NULL;
d145 2
a146 2
	if(m_nAddr && m_nPort)
		stEngine.m_stMain.AllocTcpConnect(m_nAddr, m_nPort, m_eType);
@


1.11
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d167 1
a167 2
CTask_ServerState::CTask_ServerState(long nConnectionState, long nClientID, CServer* pServer, CServer* pNewServer)
	: m_nConnectionState(nConnectionState), m_nClientID(nClientID), m_pCurrentServer(pServer), m_pNewServer(pNewServer)
d169 3
@


1.10
log
@New sockets
@
text
@d181 2
a182 2
	if(theApp.emuledlg->m_pEngineData)
		theApp.emuledlg->m_pEngineData->ImportServerState(this);
@


1.9
log
@New sockets - more server logic
@
text
@a52 1
		ASSERT(pClient);
d54 1
d56 1
a56 5
		pClient->OnDisconnected(stEngine);

		// here we can write to the log that this client has disconnected from us
		delete pClient;
		stEngine.m_stMain.m_mapClients.RemoveKey(m_hSocket);
d124 19
d145 18
a162 1
	stEngine.m_stMain.AllocTcpConnect(m_nAddr, m_nPort, m_eType);
d167 2
a168 2
CTask_ServerState::CTask_ServerState(long nConnectionState, long nClientID, CServer* pServer, CEmClient_Server* pClient)
	: m_nConnectionState(nConnectionState), m_nClientID(nClientID), m_pCurrentServer(pServer), m_pServerClient(pClient)
@


1.8
log
@New sockets
@
text
@d12 2
d135 2
a136 2
CTask_ServerState::CTask_ServerState(long nConnectionState, long nClientID)
	: m_nConnectionState(nConnectionState), m_nClientID(nClientID)
@


1.7
log
@New sockets
@
text
@d133 2
a134 2
CTask_ServerState::CTask_ServerState(long nServerState, long nClientID)
	: m_nServerState(nServerState), m_nClientID(nClientID)
d148 1
a148 1
		theApp.emuledlg->m_pEngineData->SetServerState(this);
@


1.6
log
@New sockets
@
text
@d10 2
d131 18
@


1.5
log
@New sockets. Connecting to server from server list
@
text
@d21 4
@


1.4
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d29 4
a32 1
	} else
d34 1
d72 1
d109 18
@


1.3
log
@Another new sockets cumulative update
@
text
@d7 4
d43 2
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d90 4
a93 12
		if (pClient->m_bIsJunky)
		{
			CString strTxt((PCSTR) m_pBuf, m_dwHeaderLen + m_dwContentLen);
			OutputDebugString(strTxt);
		} else
		{
			CString strTxt;
			strTxt.Format("Currently I have %d clients", stEngine.m_stMain.m_mapClients.GetCount());
			stEngine.m_stTcp.AllocSend(m_hSocket, (LPCTSTR) strTxt, strTxt.GetLength());
			stEngine.m_stTcp.AllocDisconnect(m_hSocket);
		}

@


1.1
log
@*** empty log message ***
@
text
@d25 3
a27 1
	}
d31 1
a31 1
bool CTask_Tcp_Err::Process(CEmEngine&)
d33 12
d50 19
a68 2
	char szSend[] = "Hello, World!";
	stEngine.m_stTcp.AllocSend(m_hSocket, szSend, sizeof(szSend) - 1);
d70 7
a76 2
	if (shutdown(m_hSocket, SD_SEND))
		AddDebugLogLine(false, "shutdown failed");
d78 2
d83 23
@

