head	1.3;
access;
symbols
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.3
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.2;

1.2
date	2003.08.26.16.54.25;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.3
log
@New engine
@
text
@// ThreadPool.cpp: implementation of the CThreadPool class.
//
//////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#ifdef NEW_SOCKETS

#include "ThreadPool.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CThreadPool::~CThreadPool()
{
	UninitPool();
}

DWORD CThreadPool::InitPool(DWORD dwThreads /* = 0 */, DWORD dwMaxConcurrent /* = 0 */)
{
	ASSERT(!m_hIoCompletionPort && !m_dwThreads & !m_pThreads);

	if (!CEmWinNT::s_stWinNT.IsInitialized())
		return 0; // not running on windows NT. Cannot create the thread pool.

	if (!dwThreads)
	{
		// Determine the number of processors on this machine
		SYSTEM_INFO stSysInfo;
		GetSystemInfo(&stSysInfo);
		dwThreads = stSysInfo.dwNumberOfProcessors;
	}

	m_hIoCompletionPort = CEmWinNT::s_stWinNT.m_pfnCreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, dwMaxConcurrent);
	if (!m_hIoCompletionPort)
		return 0;

	// Create now threads.
	m_pThreads = new HANDLE[dwThreads];
	if (m_pThreads)
	{
		for (; m_dwThreads < dwThreads; m_dwThreads++)
		{
			UINT nThreadID;
			m_pThreads[m_dwThreads] = (HANDLE) _beginthreadex(NULL, 0, CompletionFunc, this, 0, &nThreadID);
			if (!m_pThreads[m_dwThreads])
				break;

		}

		if (!m_dwThreads)
		{
			// cannot create even one thread!
			delete[] m_pThreads;
			m_pThreads = NULL;
		}
	}

	return m_dwThreads;
}

void CThreadPool::UninitPool(DWORD dwMaxWaitTimeout /* = 500 */)
{
	if (m_hIoCompletionPort)
	{
		if (m_pThreads)
		{
			if (m_dwThreads)
			{
				// post all threads instruction to terminate
				for (DWORD dwThread = 0; dwThread < m_dwThreads; dwThread++)
					VERIFY(CEmWinNT::s_stWinNT.m_pfnPostQueuedCompletionStatus(m_hIoCompletionPort, 0, 0xFFFFFFFF, NULL));

				BOOL bAllShutDown = TRUE;
				if (m_dwThreads <= MAXIMUM_WAIT_OBJECTS)
				{
					DWORD dwRes = WaitForMultipleObjects(m_dwThreads, m_pThreads, TRUE, dwMaxWaitTimeout);
					bAllShutDown = (dwRes >= WAIT_OBJECT_0) && (dwRes < WAIT_OBJECT_0 + m_dwThreads);
				}
				else
				{
					// because there is a huge amount of threads - we can't use WaitForMultipleObjects.
					// Ensure manually that threads are terminated
					DWORD dwTicksBeg = GetTickCount();
					for (dwThread = 0; dwThread < m_dwThreads; dwThread++)
					{
						DWORD dwWait = GetTickCount() - dwTicksBeg;
						if (dwWait < dwMaxWaitTimeout)
							dwWait = dwMaxWaitTimeout - dwWait;
						else
							dwWait = 0;

						if (WAIT_OBJECT_0 != WaitForSingleObject(m_pThreads[dwThread], dwWait))
							bAllShutDown = FALSE;
					}
				}

				for (dwThread = 0; dwThread < m_dwThreads; dwThread++)
				{
					if (!bAllShutDown && (WAIT_OBJECT_0 != WaitForSingleObject(m_pThreads[dwThread], 0)))
						VERIFY(TerminateThread(m_pThreads[dwThread], -1));

					VERIFY(CloseHandle(m_pThreads[dwThread]));
				}

				m_dwThreads = 0;
			}

			delete[] m_pThreads;
			m_pThreads = NULL;
		}

		VERIFY(CloseHandle(m_hIoCompletionPort));
		m_hIoCompletionPort = NULL;
	}
}

UINT WINAPI CThreadPool::CompletionFunc(PVOID pPtr)
{
	CThreadPool* pThis = (CThreadPool*) pPtr;
	ASSERT(pThis);
	if (pThis)
		while (true)
		{
			DWORD dwBytes = 0, dwKey = 0;
			OVERLAPPED* pOverlapped = NULL;

			BOOL bRes = CEmWinNT::s_stWinNT.m_pfnGetQueuedCompletionStatus(pThis->m_hIoCompletionPort, &dwBytes, &dwKey, &pOverlapped, pThis->m_dwWaitTimeout);
			if (bRes && !dwBytes && !pOverlapped && (0xFFFFFFFF == dwKey))
				break;

			pThis->ProcessCompletion(bRes, dwBytes, dwKey, pOverlapped);
		}
	return 0;
}


//////////////////////////////////////////////////////////////////////
// Implementation of CDataQueue
//////////////////////////////////////////////////////////////////////


bool CDataQueue::Push(PVOID pData, DWORD dwDataSize)
{
	if (!IsInitialized())
	{
		ASSERT(FALSE);
		return false; // not initialized!
	}

	// allocate a new tail
	TAIL* pTail = new (dwDataSize) TAIL;
	ASSERT(pTail);
	if (!pTail)
		return false;

	pTail->m_dwSize = dwDataSize;
	CopyMemory(pTail->m_pData, pData, dwDataSize);

	CPtrQueue<TAIL>::Push(pTail);
	return true;
}
#endif@


1.2
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d7 3
@

