head	1.8;
access;
symbols
	PublicRelease_1i:1.7
	Interim_Release_1i_RC6:1.7
	Interim_Release_1i_RC3:1.7
	Interim_Release_1i_RC2:1.7
	Interim_Release_1i_RC1:1.6
	Interim_Release_1i_beta3:1.6
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.5
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.5
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@ * @;


1.8
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.7;

1.7
date	2003.11.17.10.24.33;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.22.14.43.59;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.03.11.50.54;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.8
log
@New engine
@
text
@// TaskProcessor.h: interface for the CTaskProcessor class.
//
//////////////////////////////////////////////////////////////////////
#ifdef NEW_SOCKETS
#if !defined(AFX_TASKPROCESSOR_H__186018D8_26C9_4A91_9F7C_DDC406696088__INCLUDED_)
#define AFX_TASKPROCESSOR_H__186018D8_26C9_4A91_9F7C_DDC406696088__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "../Loggable.h"
#include "ThreadPool.h"

class CEmEngine;
struct CTask : public CLoggable {
public:
	virtual ~CTask();
	virtual bool Process(CEmEngine&) = 0;
	virtual bool OnException(CEmEngine&); // usually DB exception
	virtual bool ProcessForUI(CEmEngine&);
};


class CTaskProcessor : public CLoggable
{
	HANDLE m_hThread;
	HANDLE m_hStop;

	CTask* m_pCurrent;

	struct THREAD_INIT_PARAM {
		CTaskProcessor*	m_pThis;
		HANDLE		m_hInitEvent;
		bool		m_bInitResult;
	};

	static UINT WINAPI ProcessingFunc(PVOID pPtr);

	CPtrQueue<CTask> m_queueTasks;

	virtual bool Start();
	virtual void Stop();
	virtual void ProcessTimeout();
	bool ProcessTask(CTask&);

protected:
	DWORD m_dwWaitTimeout;

public:

	CEmEngine& m_stEngine;

	bool Init();
	void Uninit();

	CTaskProcessor(CEmEngine& stEngine) :
		m_hThread(NULL),
		m_hStop(NULL),
		m_pCurrent(NULL),
		m_stEngine(stEngine)
	{}
	~CTaskProcessor() { Uninit(); };

	inline void Push(CTask* pTask) 
	{
		if (pTask) 
			m_queueTasks.Push(pTask); 
		else
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, _T("no memory"));
		}
	}
	inline bool IsInContext(const CTask& stTask) { return &stTask == m_pCurrent; }
};

#endif // !defined(AFX_TASKPROCESSOR_H__186018D8_26C9_4A91_9F7C_DDC406696088__INCLUDED_)
#endif@


1.7
log
@New sockets
@
text
@@


1.6
log
@New Sockets + Russian update
@
text
@d21 1
a21 1
	virtual void ProcessForUI(CEmEngine&);
@


1.5
log
@New sockets
@
text
@d65 10
a74 1
	inline void Push(CTask* pTask) { if (pTask) m_queueTasks.Push(pTask); }
@


1.4
log
@New sockets. Connecting to server from server list
@
text
@d21 1
@


1.3
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d16 1
a16 1
struct CTask {
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d12 2
a13 1
#include "Loggable.h"
@


1.1
log
@*** empty log message ***
@
text
@d18 1
a18 1
	virtual bool Process(CEmEngine&) = NULL;
d28 2
d58 1
d64 1
@

