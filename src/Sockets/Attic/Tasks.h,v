head	1.16;
access;
symbols
	PublicRelease_1i:1.14
	Interim_Release_1i_RC6:1.14
	Interim_Release_1i_RC3:1.13
	Interim_Release_1i_RC2:1.12
	Interim_Release_1i_RC1:1.10
	Interim_Release_1i_beta3:1.10
	Interim_Release_1i_beta2:1.9
	Interim_Release_1i_beta1:1.8
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.7
	Interim_Release_1h_RC1:1.7
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@ * @;


1.16
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.15;

1.15
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.03.19.28.01;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.19.11.14.32;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.17.10.24.33;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.29.14.14.25;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.22.17.30.41;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.16.16.34.40;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.08.17.55.38;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.04.11.19.29;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.03.17.56.29;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@New engine
@
text
@// Tasks.h
//
//////////////////////////////////////////////////////////////////////
#ifdef NEW_SOCKETS
#if !defined(AFX_TASKS_H__595D01B7_787E_4BAA_8F57_B70CFE759503__INCLUDED_)
#define AFX_TASKS_H__595D01B7_787E_4BAA_8F57_B70CFE759503__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "../Loggable.h"

#include "TaskProcessor.h"

#include "../EngineData.h"

class CServer;
struct CEmClient;
struct CEmClient_Server;


struct OFFEREDFILE
{
	BYTE		_Hash[16];
	ULONG		_Addr; // client ID? = 0
	USHORT		_Port; // client port? = 0
	CString		_FileName;
	DWORD		_FileSize;
};

//////////////////////////////////////////////////////////////////////
// Internal socket tasks
struct CTask_Tcp : public CTask
{
	SOCKET m_hSocket;
	CTask_Tcp() : m_hSocket(INVALID_SOCKET) {}
};

struct CTask_Tcp_Accepted : public CTask_Tcp {
	virtual bool Process(CEmEngine&);
	in_addr m_nAddr;
	USHORT m_uPort;
	T_CLIENT_TYPE m_eType;
};

struct CTask_Tcp_Connected : public CTask_Tcp {
	virtual bool Process(CEmEngine&);
};

struct CTask_Tcp_Web : public CTask_Tcp {
	virtual bool Process(CEmEngine&);
	DWORD m_dwHeaderLen;
	DWORD m_dwContentLen;
	BYTE m_pBuf[0]; // variable size
	void* operator new (size_t nSize, DWORD dwDataSize) { return malloc(nSize + dwDataSize); }
	void operator delete (void* pPtr) { free(pPtr); }
	void operator delete (void* pPtr, DWORD) { free(pPtr); }
};

struct CTask_Tcp_Err : public CTask_Tcp {
	virtual bool Process(CEmEngine&);
	int m_nError;

	static bool Post(CEmEngine& stEngine, SOCKET hSocket, int nErrorCode);
};
// End of internal socket tasks
//////////////////////////////////////////////////////////////////////



//////////////////////////////////////////////////////////////////////
// connect to any client (or server)
struct CTask_Connect : public CTask {
	CTask_Connect(CServer* pServer = NULL);
	CTask_Connect(ULONG, USHORT, T_CLIENT_TYPE);
	CTask_Connect(LPCTSTR, USHORT, T_CLIENT_TYPE);
	virtual bool Process(CEmEngine&);

	ULONG	m_nAddr;
	USHORT	m_uPort;
	T_CLIENT_TYPE m_eType;
};

//////////////////////////////////////////////////////////////////////
// disconnect from any client
struct CTask_KillClient : public CTask {
	CTask_KillClient(CEmClient*);
	virtual bool Process(CEmEngine&);

	CEmClient* m_pClient;
};

//////////////////////////////////////////////////////////////////////
// synchronize server state between EngineData objects
struct CTask_ServerState : public CTask {
	CTask_ServerState(bool bForConnected, ServerState stState, long nClientID);

	virtual bool Process(CEmEngine&);
	virtual bool ProcessForUI(CEmEngine&);

	bool		m_bForConnected;
	ServerState	m_stState;
	long		m_nClientID;
};

//////////////////////////////////////////////////////////////////////
// send list of shared files
struct CTask_SendSharedList : public CTask {
	CTask_SendSharedList();
	virtual bool Process(CEmEngine&);
	virtual bool ProcessForUI(CEmEngine&);

	bool m_bProcessedUI;
//	CArray<OFFEREDFILE, OFFEREDFILE&> m_Files;
};


#endif // !defined(AFX_TASKS_H__595D01B7_787E_4BAA_8F57_B70CFE759503__INCLUDED_)
#endif@


1.15
log
@New engine
@
text
@@


1.14
log
@New sockets
@
text
@d115 1
a115 1
	CArray<OFFEREDFILE, OFFEREDFILE&> m_Files;
@


1.13
log
@New sockets - can offer files to server
@
text
@a22 21
struct CTag_Pure { // not a valid class.
	bool m_bValid;
	CTag_Pure() : m_bValid(false) {}
};

struct CTag_DWORD : public CTag_Pure {
	DWORD m_dwValue;
	CTag_DWORD() : m_dwValue(0) {}
};

struct CTag_String : public CTag_Pure {
	CString m_strValue;
};

struct CTagEntry {
	CTag_Pure*	m_pTag;
	BYTE		m_nType;
	USHORT		m_nNameLen;
	DWORD		m_dwName; // either string or number
};

@


1.12
log
@New sockets
@
text
@d49 2
a50 2
	CTagEntry	_Filename;
	CTagEntry	_Filesize;
@


1.11
log
@New sockets
@
text
@d22 31
d121 1
a121 1
	virtual void ProcessForUI(CEmEngine&);
d127 12
@


1.10
log
@Formatting, comments, and name changes.
@
text
@d22 2
d57 2
d60 4
d75 2
d84 2
@


1.9
log
@New sockets - more server code
@
text
@d31 1
a31 1
	USHORT m_nPort;
d63 1
a63 1
	USHORT	m_nPort;
@


1.8
log
@New sockets
@
text
@d16 2
d75 1
a75 1
	CTask_ServerState(long, long, CServer*, CServer*);
d80 2
a81 1
	long		m_nConnectionState;
a82 2
	CServer*	m_pCurrentServer;
	CServer*	m_pNewServer;
@


1.7
log
@New sockets - more server logic
@
text
@d17 1
d55 3
a57 2
	CTask_Connect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType);
	CTask_Connect(LPCTSTR sAddr, USHORT nPort, T_CLIENT_TYPE eType);
d65 7
d73 1
a73 1
	CTask_ServerState(long nConnectionState, long nClientID, CServer* pServer, CEmClient_Server* pClient);
d81 1
a81 1
	CEmClient_Server* m_pServerClient;
@


1.6
log
@New sockets
@
text
@d16 3
d64 1
a64 1
	CTask_ServerState(long nConnectionState, long nClientID);
d69 4
a72 2
	long	m_nConnectionState;
	long	m_nClientID;
@


1.5
log
@New sockets
@
text
@d61 1
a61 1
	CTask_ServerState(long nServerState, long nClientID);
d66 1
a66 1
	long	m_nServerState;
@


1.4
log
@New sockets. Connecting to server from server list
@
text
@d60 10
@


1.3
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d16 1
a16 1
struct CTask_Tcp : public CTask, CLoggable
d48 10
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d12 3
a14 1
#include "Loggable.h"
@


1.1
log
@*** empty log message ***
@
text
@d17 1
d24 5
d37 2
@

