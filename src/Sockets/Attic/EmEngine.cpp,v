head	1.20;
access;
symbols
	PublicRelease_1i:1.15
	Interim_Release_1i_RC6:1.15
	Interim_Release_1i_RC3:1.15
	Interim_Release_1i_RC2:1.14
	Interim_Release_1i_RC1:1.12
	Interim_Release_1i_beta3:1.12
	Interim_Release_1i_beta2:1.12
	Interim_Release_1i_beta1:1.10
	PublicRelease_1h:1.10
	Interim_Release_1h_rc2:1.9
	Interim_Release_1h_RC1:1.9
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.20
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.19;

1.19
date	2003.12.16.14.28.59;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.15.14.47.32;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.14.17.15.56;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.19.09.23.40;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.17.10.24.33;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.17.30.41;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.22.14.43.59;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.16.16.34.40;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.08.17.55.38;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.04.11.19.28;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.03.17.56.29;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.03.11.50.54;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.15.10.08.19;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.20
log
@New engine
@
text
@// EmEngine.cpp: implementation of the CEmEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifdef NEW_SOCKETS

#include "EmWinNT.h"
#include "EmMt.h"
#include "ThreadPool.h"
#include "TaskProcessor.h"
#include "EmEngine.h"
#include "Tasks.h"

#include "../Engine/Data/Server.h"

//#include "../resource.h"
//#include "../server.h"

//////////////////////////////////////////////////////////////////////
// start
bool CEmEngine::Init(HWND hWndUI)
{
	if(!InitializeDatabases())
		return false;

//	CServer stSrv;
//	stSrv.ImportFromServerMet(*this, _T("./Db/server.met"));

/*	Dbc *pCursor;
	m_pDbServersAddr->cursor(NULL, &pCursor, 0);
	Dbt key, data;
	int nRet;
	while ((nRet = pCursor->get(&key, &data, DB_NEXT)) == 0)
	{
		CServerPrimaryKey *pKey = (CServerPrimaryKey *)key.get_data();
		CServerData *pData = (CServerData *)data.get_data();
		int a = 0;
	}
	pCursor->close();
*/
	m_hWndUI = hWndUI;
	if (m_hStop = CreateEvent(NULL, TRUE, FALSE, NULL))
		if (m_stMain.Init())
			if (m_stTcp.Init())
			{
				// add relevant interfaces
				//m_stTcp.AddInterface(80, T_CLIENT_WEB);
				//m_stTcp.AddInterface(7821, T_CLIENT_PEER);
				return true;
			} else
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "Failed to initialize tcp engine");
			}
		else
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "Failed to initialize main engine");
		}
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "CreateEvent failed");
	}

	return false;
}

#define SERVERLIST_DB _T("Servers.db")

bool CEmEngine::InitializeDatabases()
{
	try
	{
		CString sDbHome = _T("./Db"); //CString(m_pGlobPrefs->GetAppDir()) + _T("Db");

		::CreateDirectory(sDbHome, NULL);	// In case it doesn't exist

		// Create environment
		m_pDbEnv = new DbEnv(0);
		m_pDbEnv->set_cachesize(0, 256 * 1024, 0);	// 256kb cache size
		USES_CONVERSION;
		m_pDbEnv->open( CT2CA(sDbHome), DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG
			| DB_INIT_MPOOL | DB_INIT_TXN | DB_RECOVER
			| DB_THREAD, 0 );

		m_pDbEnv->set_flags(DB_AUTO_COMMIT, 1);

		// Servers list
		m_pDbServers = new Db(m_pDbEnv, 0);
		m_pDbServers->set_pagesize(16 * 1024); // 16Kb page m_lSize
		m_pDbServers->open(NULL, SERVERLIST_DB, _T("Server-List"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		// Servers list - primary index by addr/port
		m_pDbServersAddr = new Db(m_pDbEnv, 0);
		m_pDbServersAddr->open(NULL, SERVERLIST_DB, _T("Server-List-Addr"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersAddr, CServer::PrimaryIndex, NULL);

		// Servers list - secondary index by 'static' field
		m_pDbServersStatic = new Db(m_pDbEnv, 0);
		m_pDbServersStatic->set_flags(DB_DUP | DB_DUPSORT);
		m_pDbServersStatic->open(NULL, SERVERLIST_DB, _T("Server-List-Static"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersStatic, CServer::SecondaryIndexStatic, NULL);

		// Servers list - secondary index by 'priority' field
		m_pDbServersPriority = new Db(m_pDbEnv, 0);
		m_pDbServersPriority->set_flags(DB_DUP | DB_DUPSORT);
		m_pDbServersPriority->open(NULL, SERVERLIST_DB, _T("Server-List-Priority"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersPriority, CServer::SecondaryIndexPriority, NULL);
	}
	catch (DbRunRecoveryException &dbe)
	{
		TRACE(CString(dbe.what()));
		return false;
	}
	catch (DbException &dbe)
	{
		m_pDbServers = NULL;
		m_pDbServersAddr = NULL;
		m_pDbServersStatic = NULL;
		m_pDbServersPriority = NULL;
		m_pDbEnv = NULL;
		TRACE("Problems create database objects: %s. Closing.\n", dbe.what());
		return false;
	}
	catch(...)
	{
		m_pDbServers = NULL;
		m_pDbServersAddr = NULL;
		m_pDbServersStatic = NULL;
		m_pDbServersPriority = NULL;
		m_pDbEnv = NULL;
		TRACE("Problems create database objects. Closing.\n");
		return false;
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// stop
void CEmEngine::Uninit()
{
	if (m_hStop)
	{
		if (!SetEvent(m_hStop))
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "SetEvent failed");
		}

		m_stTcp.Uninit(false);
		m_stMain.Uninit();

		m_stTcp.Uninit(); // final

		if (!CloseHandle(m_hStop))
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "CloseHandle failed");
		}
		m_hStop = NULL;
	}
	CloseDatabases();
}

void CEmEngine::CloseDatabases()
{
	try
	{
		if(m_pDbServersPriority)
		{
			m_pDbServersPriority->close(0);
			safe_delete(m_pDbServersPriority);
		}

		if(m_pDbServersStatic)
		{
			m_pDbServersStatic->close(0);
			safe_delete(m_pDbServersStatic);
		}

		if(m_pDbServersAddr)
		{
			m_pDbServersAddr->close(0);
			safe_delete(m_pDbServersAddr);
		}

		if(m_pDbServers)
		{
			m_pDbServers->close(0);
			safe_delete(m_pDbServers);
		}

		if(m_pDbEnv)
		{
			m_pDbEnv->txn_checkpoint(0,0,0);
			m_pDbEnv->close(0);
			safe_delete(m_pDbEnv);
		}
	}
	catch(DbException &dbe)
	{
		TRACE("Problems delete database objects: %s.\n", dbe.what());
	}
	catch(...)
	{
		TRACE("Problems delete database objects.\n");
	}

}

//////////////////////////////////////////////////////////////////////
// connecting to given server (or any server, if pServer is NULL)
void CEmEngine::ConnectToServer(CServer* pServer /* = NULL */)
{
	EMULE_TRY

	if(m_stData.GetConnectingServer())
		DisconnectFromServer(m_stData.GetConnectingServer());

	CTask_Connect *pTask = new CTask_Connect(pServer);
	m_stData.SetConnectionState(false, SERVER_CONNECTING);
	m_stMain.Push(pTask);

	EMULE_CATCH2
}

//////////////////////////////////////////////////////////////////////
// connect to any server
void CEmEngine::ConnectToAnyServer()
{
	ConnectToServer();
}

//////////////////////////////////////////////////////////////////////
// disconnect from connected server
void CEmEngine::DisconnectFromServer(SOCKET hPrevServer /* = NULL */)
{
	if(!hPrevServer)
	{
		if(m_stData.GetConnectingServer())
			DisconnectFromServer(m_stData.GetConnectingServer());
		else if(m_stData.GetConnectedServer())
			DisconnectFromServer(m_stData.GetConnectedServer());
		else
			m_stData.SetConnectionState(false, SERVER_DISCONNECTED);
		return;
	}

	CEmClient* pServer = m_stMain.Lookup(hPrevServer);
	if(!pServer)
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, _T("lookup for server failed"));
		return;
	}
	CTask_KillClient* pTask = new CTask_KillClient(pServer);
	m_stMain.Push(pTask);
}

//////////////////////////////////////////////////////////////////////
// send list of shared files
void CEmEngine::SendSharedListToServer()
{
	EMULE_TRY

	CTask_SendSharedList *pTask = new CTask_SendSharedList();
	m_stMain.Push(pTask);

	EMULE_CATCH2
}


#endif@


1.19
log
@New engine - server classes, database
@
text
@@


1.18
log
@New engine - server classes, database
@
text
@d27 2
a28 2
	CServer stSrv;
	stSrv.ImportFromServerMet(*this, _T("./Db/server.met"));
d30 12
d88 2
d93 1
a93 1
		m_pDbServers->open(NULL, SERVERLIST_DB, _T("Server-List"), DB_HASH, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);
a100 6
		// Servers list - primary index by dynIP/port
		m_pDbServersDynIP = new Db(m_pDbEnv, 0);
		m_pDbServersDynIP->open(NULL, SERVERLIST_DB, _T("Server-List-DynIP"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersDynIP, CServer::PrimaryIndex2, NULL);

a123 1
		m_pDbServersDynIP = NULL;
a133 1
		m_pDbServersDynIP = NULL;
a183 6
		}

		if(m_pDbServersDynIP)
		{
			m_pDbServersDynIP->close(0);
			safe_delete(m_pDbServersDynIP);
@


1.17
log
@New engine - server classes, database
@
text
@d27 3
d79 13
a91 1
		m_pDbServers->open(NULL, SERVERLIST_DB, _T("Server-List"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);
d115 2
d126 2
d178 12
@


1.16
log
@New engine
@
text
@d14 3
d24 3
d55 63
d142 41
@


1.15
log
@New sockets
@
text
@d14 2
a15 2
#include "../resource.h"
#include "../server.h"
@


1.14
log
@New sockets
@
text
@a129 3
	if(!m_stData.IsConnected())
		return;

@


1.13
log
@New sockets
@
text
@d124 16
@


1.12
log
@New sockets - more server code
@
text
@d17 2
d49 2
d75 2
d91 2
d98 2
@


1.11
log
@New Sockets + Russian update
@
text
@d75 3
d79 1
a79 1
	m_stData.SetConnectionState(SERVER_CONNECTING);
d93 7
a99 2
		hPrevServer = m_stData.GetConnectedServer();
	if(!hPrevServer)
d101 1
@


1.10
log
@New sockets
@
text
@d76 2
a77 10
	if(pTask)
	{
		m_stData.SetConnectionState(SERVER_CONNECTING);
		m_stMain.Push(pTask);
	}
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
	}
a91 3
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, _T("can't find connected server"));
d93 1
a93 1
	}
d102 1
a102 9
	if(pTask)
	{
		m_stMain.Push(pTask);
	}
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, _T("no memory"));
	}
@


1.9
log
@New sockets - more server logic
@
text
@d71 1
a71 1
void CEmEngine::ConnectToServer(CServer* pServer)
d75 1
a75 3
	AddLogLine(false, IDS_CONNECTINGTO, pServer->GetListName(), pServer->GetAddress(), pServer->GetPort());

	CTask_Connect *pTask = new CTask_Connect(pServer->GetAddress(), pServer->GetPort(), T_CLIENT_SERVER);
d88 34
@


1.8
log
@New sockets
@
text
@d15 1
d71 1
a71 1
void CEmEngine::ConnectToServer(LPCTSTR sAddr, USHORT nPort, LPCTSTR sName)
d73 1
a73 1
	AddLogLine(false, IDS_CONNECTINGTO, sName, sAddr, nPort);
d75 3
a77 1
	CTask_Connect *pTask = new CTask_Connect(sAddr, nPort, T_CLIENT_SERVER);
d79 2
d82 1
d88 2
@


1.7
log
@New sockets
@
text
@a14 1
#include "../EngineData.h"
a17 2
	m_pEngineData = new CEngineData(*this);

a47 3
	if(m_pEngineData)
		delete m_pEngineData;

@


1.6
log
@New sockets
@
text
@d15 1
d19 2
d51 3
@


1.5
log
@New sockets. Connecting to server from server list
@
text
@d16 1
a16 1
bool CEmEngine::Init()
d18 1
@


1.4
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d14 1
d27 2
d30 1
d32 2
d35 1
d37 2
d40 1
d50 2
d53 1
d61 2
d64 1
d66 14
@


1.3
log
@Another new sockets cumulative update
@
text
@d7 5
d13 1
d22 2
a23 3
				m_stTcp.AddInterface(80, T_CLIENT_WEB);
				m_stTcp.AddInterface(7821, T_CLIENT_PEER);

@


1.2
log
@Cumulative update. Not working yet.
@
text
@d17 1
@


1.1
log
@*** empty log message ***
@
text
@d16 1
a16 1
				m_stTcp.AddInterface(90, false);
@

