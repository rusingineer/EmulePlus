head	1.3;
access;
symbols
	PublicRelease_1i:1.1
	Interim_Release_1i_RC6:1.1
	Interim_Release_1i_RC3:1.1
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.2;

1.2
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.3
log
@New engine
@
text
@// ThreadPool.h: interface for the CThreadPool class.
//
//////////////////////////////////////////////////////////////////////

#ifdef NEW_SOCKETS
#if !defined(AFX_THREADPOOL_H__92402536_5AEB_467C_9302_98CD441A7981__INCLUDED_)
#define AFX_THREADPOOL_H__92402536_5AEB_467C_9302_98CD441A7981__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "EmMt.h"

class CThreadPool  
{
	HANDLE m_hIoCompletionPort;
	HANDLE* m_pThreads;
	DWORD m_dwThreads;

	static UINT WINAPI CompletionFunc(PVOID);

protected:
	virtual void ProcessCompletion(BOOL bResult, DWORD dwBytes, DWORD dwKey, OVERLAPPED*) = NULL;

	DWORD m_dwWaitTimeout; // infinite by default

public:
	
	CThreadPool() :
		m_hIoCompletionPort(NULL),
		m_pThreads(NULL),
		m_dwThreads(0),
		m_dwWaitTimeout(INFINITE)
	{}
	virtual ~CThreadPool();

	DWORD InitPool(DWORD dwThreads = 0, DWORD dwMaxConcurrent = 0);
	void UninitPool(DWORD dwMaxWaitTimeout = 1000);

	inline HANDLE zget_CompletionPort() const { return m_hIoCompletionPort; }
	__declspec (property(get=zget_CompletionPort)) HANDLE _CompletionPort;

	inline DWORD zget_Threads() const { return m_dwThreads; }
	__declspec (property(get=zget_Threads)) DWORD _Threads;
};

template <class T>
class CPtrQueue {
	CCriticalSection_INL m_csLock;
	HANDLE m_hSemaphore; // semaphore
	std::queue<T*> m_queueData;

	T* FetchFront()
	{
		CCriticalSection_INL::CScope stScope(m_csLock);
		ASSERT(!m_queueData.empty());

		T* pObject = m_queueData.front();
		m_queueData.pop();

		return pObject;
	}
public:

	CPtrQueue() : m_hSemaphore(NULL) {}
	~CPtrQueue() { Uninit(); }

	bool Init()
	{
		Uninit();

		m_hSemaphore = CreateSemaphore(NULL, 0, 0xFFFF, NULL);
		return NULL != m_hSemaphore;
	}
	void Uninit()
	{
		if (m_hSemaphore)
		{
			VERIFY(CloseHandle(m_hSemaphore));
			m_hSemaphore = NULL;
		}

		CCriticalSection_INL::CScope stScope(m_csLock);

		for (; !m_queueData.empty(); m_queueData.pop())
		{
			T* pObject = m_queueData.front();
			if (pObject)
				delete pObject;
		}
	}
	bool IsInitialized() { return NULL != m_hSemaphore; }

	void Push(T* pObject)
	{
		ASSERT(m_hSemaphore);

		m_csLock.Enter();
		m_queueData.push(pObject);
		m_csLock.Leave();

		VERIFY(ReleaseSemaphore(m_hSemaphore, 1, NULL));
	}
	T* Pop(DWORD dwTimeout = INFINITE)
	{
		if (m_hSemaphore && (WAIT_OBJECT_0 == WaitForSingleObject(m_hSemaphore, dwTimeout)))
			return FetchFront();
		return NULL;
	}
	T* PopEx(HANDLE hInterrupt, DWORD dwTimeout = INFINITE)
	{
		if (m_hSemaphore)
		{
			HANDLE pWait[] = { m_hSemaphore, hInterrupt };
			if (WAIT_OBJECT_0 == WaitForMultipleObjects(2, pWait, FALSE, dwTimeout))
				return FetchFront();
		}
		return NULL;
	}
};

struct TAIL
{
	DWORD m_dwSize;
	char m_pData[0]; // variable length
	inline void* operator new (size_t nSize, DWORD dwSizeExtra)
	{
		return malloc(nSize + dwSizeExtra);
		nSize += dwSizeExtra;
	}
	inline void operator delete (void* pPtr)
	{
		free(pPtr);
	}
};

class CDataQueue : public CPtrQueue<TAIL> {

public:

	bool Push(PVOID pData, DWORD dwDataSize);
};

#endif // !defined(AFX_THREADPOOL_H__92402536_5AEB_467C_9302_98CD441A7981__INCLUDED_)
#endif@


1.2
log
@New engine
@
text
@@


1.1
log
@*** empty log message ***
@
text
@a12 1
#include <queue>
@

