head	1.6;
access;
symbols
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.4
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@ * @;


1.6
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.5;

1.5
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.29.14.14.25;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.26.16.54.25;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.6
log
@New engine
@
text
@// TcpEngine.h: interface for the CTcpEngine class.
//
//////////////////////////////////////////////////////////////////////
#ifdef NEW_SOCKETS
#if !defined(AFX_TCPENGINE_H__F572FB64_4C8F_4112_A2B3_CE1A75ACCF86__INCLUDED_)
#define AFX_TCPENGINE_H__F572FB64_4C8F_4112_A2B3_CE1A75ACCF86__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "../Loggable.h"

class CEmEngine;
class COpCode;

const UINT INTERFACE_FLAG_SHUTDOWN	= 0x01;

const UINT WM_EMSOCKET			= WM_USER + 1;
const UINT WM_EM_ADDINTERFACE	= WM_USER + 2;
const UINT WM_EM_CONNECT		= WM_USER + 3;
const UINT WM_EM_SEND			= WM_USER + 4;
const UINT WM_EM_DISCONNECT		= WM_USER + 5;

const UINT TCP_OPTIMAL_BUF		= 0x1000; // 4k
const UINT TCP_MAX_BUF_SIZE		= 200000;

const UINT TCP_RECV_FLAG_CONNECTED = 0x01;
const UINT TCP_RECV_FLAG_FIRSTTIME = 0x02;

class CTcpEngine : public CLoggable // : protected CThreadPool
{
	bool m_bWinsockInit;

	struct CInterface {
		USHORT	m_uPort;
		SOCKET	m_hSocket;
		long	m_nPendingAccepts;
		UINT	m_nFlags;
		T_CLIENT_TYPE	m_eType;
	};
	struct CState;

	std::queue<CInterface*> m_queueInterfaces;

	struct OVERLAPPED_TCP : public OVERLAPPED {

		union {
			struct {
				OVERLAPPED_TCP* m_pPrev;
				OVERLAPPED_TCP* m_pNext;
			};
			CTcpEngine* m_pEngine;
		};

		SOCKET		m_hSocket;
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		virtual void ProcessEvent(CState&, int nEvent, int nError);

		OVERLAPPED_TCP() :
			m_pPrev(NULL),
			m_pNext(NULL)
			{ ZeroMemory((OVERLAPPED*) this, sizeof(OVERLAPPED)); }
		virtual ~OVERLAPPED_TCP();

		static void WINAPI OverlappedCompletionFunc(DWORD, DWORD, OVERLAPPED*, DWORD);
	};
	struct OVERLAPPED_ACCEPT : public OVERLAPPED_TCP {
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		virtual void ProcessEvent(CState&, int nEvent, int nError);
		CInterface& m_stInterface;
		char		m_pBuf[(sizeof(SOCKADDR_IN) + 16) * 2]; // used with AcceptEx function

		OVERLAPPED_ACCEPT(CInterface& stInterface) : m_stInterface(stInterface) { InterlockedIncrement(&m_stInterface.m_nPendingAccepts); }
		virtual ~OVERLAPPED_ACCEPT();
	};
	struct OVERLAPPED_RECV : public OVERLAPPED_TCP, public WSABUF {
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		virtual void ProcessEvent(CState&, int nEvent, int nError);
		char m_pBuf[TCP_OPTIMAL_BUF];
		DWORD	m_dwBufUsage;
		DWORD	m_dwBufSize;
		UINT	m_nFlags;

		ULONG	m_nPeerAddr;
		USHORT	m_nPeerPort;

		char* m_pBufExtra;
		inline char* GetBuffer() { return m_pBufExtra ? m_pBufExtra : m_pBuf; }

		void DisableTcpBufs(CTcpEngine&);
		void ClearBufs();

		inline OVERLAPPED_RECV() :
			m_pBufExtra(NULL),
			m_dwBufUsage(0),
			m_dwBufSize(sizeof(m_pBuf))
			{}
		virtual ~OVERLAPPED_RECV();

		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv) = NULL;
	};
	struct OVERLAPPED_RECV_WEB : public OVERLAPPED_RECV {
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);

		DWORD m_dwHttpHeaderLen;
		DWORD m_dwHttpContentLen;

		inline OVERLAPPED_RECV_WEB() :
			m_dwHttpHeaderLen(0),
			m_dwHttpContentLen(0)
			{}
	};
	struct OVERLAPPED_RECV_OPCODES : public OVERLAPPED_RECV {
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);
		const T_CLIENT_TYPE m_eType;

		OVERLAPPED_RECV_OPCODES(T_CLIENT_TYPE eType) : m_eType(eType) {}

	};
	struct OVERLAPPED_SEND : public OVERLAPPED_TCP, public WSABUF {
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		BYTE m_pBuf[0];
		void* operator new (size_t nSize, DWORD dwDataSize) { return malloc(nSize + dwDataSize); }
		void operator delete(void* pPtr, DWORD) { free(pPtr); }
		void operator delete(void* pPtr) { free(pPtr); }
	};

	//////////////////////////////////////////////////////////////////////
	// Asynchronous engine
	bool InitAsync();
	void UninitAsync();

	HANDLE	m_hAsyncInit; // initialization completion event
	HANDLE	m_hAsyncThread;
	HWND	m_hSocketWnd;
	long	m_nOverlappedIOs;

	static UINT WINAPI SocketWndFunc(PVOID);
	static LRESULT WINAPI SocketWndProc(HWND, UINT, WPARAM, LPARAM);

	struct CState {

		CTcpEngine& m_stEngine;
		OVERLAPPED_TCP* m_pHashTable[997];

		CState(CTcpEngine& stEngine) : m_stEngine(stEngine)
		{
			ZeroMemory(m_pHashTable, sizeof(m_pHashTable));
		}

		void AddClient(OVERLAPPED_TCP&);
		OVERLAPPED_TCP* LookupClient(SOCKET hSocket);
		void DeleteClient(OVERLAPPED_TCP&);

		void OnAddInterface(CInterface&);
	};

	OVERLAPPED_RECV* AllocRecv(T_CLIENT_TYPE eType);

	friend struct CState;
	friend struct OVERLAPPED_TCP;
	friend struct OVERLAPPED_RECV;
	friend struct OVERLAPPED_ACCEPT;

	//////////////////////////////////////////////////////////////////////
	// Overlapped engine

public:

	CEmEngine& m_stEngine;

	bool Init();
	void Uninit(bool bCleanupWinsock = true);

	CTcpEngine(CEmEngine& stEngine) :
		m_stEngine(stEngine),
		m_bWinsockInit(false),
		m_hAsyncInit(NULL),
		m_hAsyncThread(NULL),
		m_hSocketWnd(NULL),
		m_nOverlappedIOs(0)
	{}
	~CTcpEngine() { Uninit(); }

	bool AddInterface(USHORT nPort, T_CLIENT_TYPE);

	bool AllocSend(SOCKET hSocket, PCVOID, DWORD);
	bool AllocSend(SOCKET hSocket, const COpCode&);
	void AllocDisconnect(SOCKET hSocket);
	SOCKET AllocConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE);
};

#endif // !defined(AFX_TCPENGINE_H__F572FB64_4C8F_4112_A2B3_CE1A75ACCF86__INCLUDED_)
#endif@


1.5
log
@New engine
@
text
@@


1.4
log
@Formatting, comments, and name changes.
@
text
@a30 2
#include <queue>

@


1.3
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d38 1
a38 1
		USHORT	m_nPort;
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d12 1
a12 1
#include "Loggable.h"
d118 4
@


1.1
log
@*** empty log message ***
@
text
@d15 1
a17 1
const UINT INTERFACE_FLAG_WEB		= 0x02;
d22 2
d42 1
d91 1
d103 1
a103 1
		virtual DWORD ParseRecv(char* pData, DWORD dwSize, bool bIsLastRecv) = NULL;
d106 1
a106 1
		virtual DWORD ParseRecv(char* pData, DWORD dwSize, bool bIsLastRecv);
d116 3
d135 1
d157 2
d160 1
d162 1
d179 2
a180 1
		m_hSocketWnd(NULL)
d184 1
a184 1
	bool AddInterface(USHORT nPort, bool bWebInterface);
d187 3
a189 1
	SOCKET AllocConnect(ULONG nAddr, USHORT nPort);
@

