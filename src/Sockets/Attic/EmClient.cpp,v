head	1.17;
access;
symbols
	PublicRelease_1i:1.16
	Interim_Release_1i_RC6:1.16
	Interim_Release_1i_RC3:1.16
	Interim_Release_1i_RC2:1.15
	Interim_Release_1i_RC1:1.14
	Interim_Release_1i_beta3:1.14
	Interim_Release_1i_beta2:1.13
	Interim_Release_1i_beta1:1.11
	PublicRelease_1h:1.11
	Interim_Release_1h_rc2:1.10
	Interim_Release_1h_RC1:1.9
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3;
locks; strict;
comment	@// @;


1.17
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.16;

1.16
date	2003.11.19.16.51.52;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.30.16.57.42;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.23.18.50.26;	author uid77509;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.17.30.41;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.16.16.34.40;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.11.15.59.29;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.08.17.55.38;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.04.11.19.28;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.03.17.56.29;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.24.16.36.22;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.24.06.17.30;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.15.12.51.25;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.15.10.08.19;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.17
log
@New engine
@
text
@// EmClient.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#ifdef NEW_SOCKETS

#include "OpCode.h"
#include "TaskProcessor_Main.h"
#include "EmEngine.h"
#include "../otherfunctions.h"
#include "../EngineData.h"

CEmClient::~CEmClient()
{
	if (closesocket(m_hSocket))
		AddDebugLogLine(false, "closesocket failed");
}

T_CLIENT_TYPE CEmClient_Peer::GetType() const
{
	return T_CLIENT_PEER;
}
T_CLIENT_TYPE CEmClient_Server::GetType() const
{
	return T_CLIENT_SERVER;
}
T_CLIENT_TYPE CEmClient_Web::GetType() const
{
	return T_CLIENT_WEB;
}

void CEmClient::OnConnected(CEmEngine&)
{
}
void CEmClient::OnAccepted(CEmEngine&)
{
}
void CEmClient::OnDisconnected(CEmEngine&)
{
}

//////////////////////////////////////////////////////////////////////
// client connected
// (!) can be both we connected to him or he connected to us
// sending HELLO opcode
void CEmClient_Peer::OnConnected(CEmEngine& stEngine)
{
	COpCode_HELLO stMsg;
	md4cpy(stMsg._Hash, stEngine.m_stData.GetUserHash());
	stMsg._Client._Addr = stEngine.m_stData.GetClientID();
	stMsg._Client._Port = stEngine.m_stData.GetPort();
	stMsg._UserName.m_strValue = stEngine.m_stData.GetUserNick();
	stMsg._UserName.m_bValid = TRUE;
	stMsg._ClientVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientVersion.m_bValid = TRUE;
	stMsg._UserPort.m_dwValue = stEngine.m_stData.GetPort();
	stMsg._UserPort.m_bValid = TRUE;
	if(stEngine.m_stData.IsConnected())
	{
		stMsg._Server._Addr = stEngine.m_stData.GetConnectedState()->nAddr;
		stMsg._Server._Port = stEngine.m_stData.GetConnectedState()->nPort;
	}
	else
	{
		stMsg._Server._Addr = 0;
		stMsg._Server._Port = 0;
	}

	stEngine.m_stTcp.AllocSend(m_hSocket, stMsg);
}

//////////////////////////////////////////////////////////////////////
// connected to server
// disconnecting from previous connected server (if any)
// sending LOGINREQUEST opcode
void CEmClient_Server::OnConnected(CEmEngine& stEngine)
{
	// Reset message count
	m_nMsgCount = 0;

	// Disconnect from previous connected server, if any
	if(stEngine.m_stData.GetConnectingServer() != m_hSocket &&
		stEngine.m_stData.GetConnectingServer())
		stEngine.DisconnectFromServer(stEngine.m_stData.GetConnectingServer());

	// Set connection info
	stEngine.m_stData.ConnectingTo(this);
	stEngine.m_stData.SetConnectionState(false, SERVER_WAITFORLOGIN);

	COpCode_LOGINREQUEST stMsg;
	md4cpy(stMsg._Hash, stEngine.m_stData.GetUserHash());
	stMsg._ClientID = stEngine.m_stData.GetClientID();
	stMsg._ClientPort = stEngine.m_stData.GetPort();
	stMsg._UserName.m_strValue = stEngine.m_stData.GetUserNick();
	stMsg._UserName.m_bValid = true;
	stMsg._ClientVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientVersion.m_bValid = true;
	stMsg._UserPort.m_dwValue = stEngine.m_stData.GetPort();
	stMsg._UserPort.m_bValid = true;

	stEngine.m_stTcp.AllocSend(m_hSocket, stMsg);
}

//////////////////////////////////////////////////////////////////////
// disconnected from server
// (!) at any reason, can be even if we tried to connect and failed
void CEmClient_Server::OnDisconnected(CEmEngine& stEngine)
{
	// Set connection info
	if(stEngine.m_stData.GetConnectedServer() == m_hSocket)
		stEngine.m_stData.SetConnectionState(true, SERVER_DISCONNECTED);
	else
		// removed if, because we can get 'disconnected' even if we didn't
		// succeeded to connect yet, thus GetConnectingServer() won't return
		// correct value
		// if(stEngine.m_stData.GetConnectingServer() == m_hSocket)
		stEngine.m_stData.SetConnectionState(false, SERVER_DISCONNECTED);
		// TODO: mark somewhere that server is dead
}

//////////////////////////////////////////////////////////////////////
// in the future - move webserver to this engine
void CEmClient_Web::OnConnected(CEmEngine& stEngine)
{
	// say something...
	char szSend[] = "GET / HTTP 1.1\r\n\r\n";
	stEngine.m_stTcp.AllocSend(m_hSocket, szSend, sizeof(szSend) - 1);
}

#endif@


1.16
log
@New sockets
@
text
@@


1.15
log
@New sockets
@
text
@d51 2
a52 1
	stMsg._Client._Addr = 175;
d56 1
a56 1
	stMsg._ClientVersion.m_dwValue = 45;
d60 10
@


1.14
log
@New sockets - more server code
@
text
@d44 4
a49 1
	// send it a hello opcode
d63 4
a80 1
	// Send LOGIN REQUEST
d95 3
d112 2
@


1.13
log
@New sockets - more server code
@
text
@d100 1
@


1.12
log
@New sockets - more server code
@
text
@d62 3
d77 1
a77 1
	stMsg._ClientID = 0; // Must fill prev. client id
@


1.11
log
@New sockets
@
text
@d63 3
a65 1
	stEngine.DisconnectFromServer(stEngine.m_stData.GetConnectingServer());
d69 1
a69 1
	stEngine.m_stData.SetConnectionState(SERVER_WAITFORLOGIN);
d90 7
a96 1
		stEngine.m_stData.SetConnectionState(SERVER_DISCONNECTED);
@


1.10
log
@New sockets
@
text
@d62 5
a66 1
	stEngine.m_stData.ConnectedTo(this, m_nAddr, m_nPort);
d69 1
d86 3
a88 1
	stEngine.m_stData.SetConnectionState(SERVER_DISCONNECTED);
@


1.9
log
@New sockets - more server logic
@
text
@a12 1
#include "../emule.h"
d49 2
a50 2
	stMsg._Client._Port = 7723;
	stMsg._UserName.m_strValue = "valdo";
d54 1
a54 1
	stMsg._UserPort.m_dwValue = 7723;
d66 1
a66 1
	md4cpy(stMsg._Hash, theApp.glob_prefs->GetUserHash());
d68 2
a69 2
	stMsg._ClientPort = theApp.glob_prefs->GetPort();
	stMsg._UserName.m_strValue = theApp.glob_prefs->GetUserNick();
d73 1
a73 1
	stMsg._UserPort.m_dwValue = theApp.glob_prefs->GetPort();
@


1.8
log
@New sockets
@
text
@d63 1
@


1.7
log
@New sockets
@
text
@d14 1
d63 2
d79 1
a79 1
void CEmClient_Server::OnDisconnected(CEmEngine&)
d81 1
@


1.6
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d76 4
@


1.5
log
@New sockets
@
text
@d10 4
d40 3
d62 12
@


1.4
log
@New sockets
@
text
@a54 3
	// send it a hello opcode
	COpCode_HELLO stMsg;
	stEngine.m_stTcp.AllocSend(m_hSocket, stMsg);
@


1.3
log
@Server OpCodes
@
text
@d41 2
a42 2
	stMsg._ClientID = 175;
	stMsg._ClientPort = 7723;
@


1.2
log
@Another new sockets cumulative update
@
text
@d41 1
a41 1
	stMsg._UserID = 175;
@


1.1
log
@Cumulative update. Not working yet.
@
text
@d14 1
a14 1
		ELOG("closesocket failed");
d41 9
@

