head	1.7;
access;
symbols
	PublicRelease_1i:1.6
	Interim_Release_1i_RC6:1.6
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.4
	PublicRelease_1h:1.4
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.4
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.7
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.6;

1.6
date	2003.11.16.15.20.07;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@New engine
@
text
@// TaskProcessor.cpp: implementation of the CTaskProcessor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifdef NEW_SOCKETS

#include "TaskProcessor.h"
#include "EmEngine.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

bool CTaskProcessor::Init()
{
	Uninit(); // if already initialized

	if (m_queueTasks.Init())
		if (m_hStop = CreateEvent(NULL, TRUE, FALSE, NULL))
		{
			THREAD_INIT_PARAM stParam;
			stParam.m_pThis = this;
			stParam.m_bInitResult = false;
			if (stParam.m_hInitEvent = CreateEvent(NULL, TRUE, FALSE, NULL))
			{
				UINT nThread = 0;
				if (m_hThread = (HANDLE) _beginthreadex(NULL, 0, ProcessingFunc, &stParam, 0, &nThread))
				{
					DWORD dwRes = WaitForSingleObject(stParam.m_hInitEvent, 1000);
					if (WAIT_OBJECT_0 == dwRes)
						if (stParam.m_bInitResult)
							return true;
						else
						{
							ASSERT(FALSE);
							AddDebugLogLine(false, "Task processor failed to initialize");
						}
					else
						if (WAIT_TIMEOUT == dwRes)
						{
							ASSERT(FALSE);
							AddDebugLogLine(false, "Task processor initialization timed out");
						}
						else
						{
							ASSERT(FALSE);
							AddDebugLogLine(false, "WaitForSingleObject failed");
						}
				} 
				else
				{
					ASSERT(FALSE);
					AddDebugLogLine(false, "_beginthreadex failed");
				}

			} 
			else
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "CreateEvent failed");
			}

		} 
		else
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "CreateEvent failed");
		}
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "Failed to create the queue");
	}

	Uninit();
	return false;
}

//////////////////////////////////////////////////////////////////////
// destruction
void CTaskProcessor::Uninit()
{
	if (m_hStop)
	{
		if (m_hThread)
		{
			if (!SetEvent(m_hStop))
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "SetEvent failed");
			}

			if (WAIT_TIMEOUT == WaitForSingleObject(m_hThread, 2000))
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "Failed to uninitialize. Terminating");
				if (!TerminateThread(m_hThread, -1))
					AddDebugLogLine(false, "TerminateThread failed");
			}

			if (!CloseHandle(m_hThread))
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "CloseHandle failed");
			}
			m_hThread = NULL;
		}

		if (!CloseHandle(m_hStop))
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "CloseHandle failed");
		}
		m_hStop = NULL;
	}
	m_queueTasks.Uninit();
}

//////////////////////////////////////////////////////////////////////
// processing
UINT WINAPI CTaskProcessor::ProcessingFunc(PVOID pPtr)
{
	THREAD_INIT_PARAM* pParam = (THREAD_INIT_PARAM*) pPtr;
	if (pParam)
	{
		CTaskProcessor* pThis = pParam->m_pThis;
		bool bRes = pParam->m_bInitResult = pThis->Start();
		SetEvent(pParam->m_hInitEvent);

		if (bRes)
			for (DWORD dwWaitLast = GetTickCount(); ; )
			{
				DWORD dwWait = INFINITE;
				if (INFINITE != pThis->m_dwWaitTimeout)
				{
					DWORD dwElapsed = GetTickCount() - dwWaitLast;
					if (dwElapsed < pThis->m_dwWaitTimeout)
						dwWait = pThis->m_dwWaitTimeout - dwElapsed;
					else
					{
						pThis->ProcessTimeout();
						dwWaitLast = GetTickCount();
						dwWait = pThis->m_dwWaitTimeout;
					}
				}

				CTask* pTask = pThis->m_queueTasks.PopEx(pThis->m_hStop, dwWait); 
				if (pTask)
				{
					pThis->m_pCurrent = pTask;
					if (pThis->ProcessTask(*pTask))
						delete pTask;
					pThis->m_pCurrent = NULL;
				}
				else
					if (pThis->m_stEngine.IsShuttingDown())
						break; // finished!

			}

		pThis->Stop();
	}
	return 0;
}

//////////////////////////////////////////////////////////////////////
// those functions are defined in child classes
bool CTaskProcessor::Start()
{
	return true;
}

void CTaskProcessor::Stop()
{
}

void CTaskProcessor::ProcessTimeout()
{
}

//////////////////////////////////////////////////////////////////////
// process single task
bool CTaskProcessor::ProcessTask(CTask& stTask)
{
	try
	{
		return stTask.Process(m_stEngine);
	}
	catch (_com_error& e)
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, _T("ATL Exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
	}
	catch (...)
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "Unhandled exception while processing task");
	}

	try
	{
		// give it another chance
		return stTask.OnException(m_stEngine);
	}
	catch(_com_error& e)
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, _T("Second ATL exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
	}
	catch (...)
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "Second unhandled exception while processing task");
	}

	return true; // delete this buggy task!
}

#endif@


1.6
log
@Minor fixes
@
text
@@


1.5
log
@New sockets
@
text
@d94 1
a94 1
			if (WAIT_TIMEOUT == WaitForSingleObject(m_hThread, 1000))
@


1.4
log
@New sockets. Connecting to server from server list
@
text
@d80 2
d120 2
d167 2
d182 2
@


1.3
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d35 2
d38 1
d41 2
d44 1
d46 2
d49 5
a53 1
				} else
d55 1
d57 4
a60 1
			} else
d62 1
d64 4
a67 1
		} else
d69 1
d71 2
d74 1
d87 2
d90 1
d94 1
d101 2
d104 1
d109 2
d112 1
d184 1
d189 1
d200 1
d205 1
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d7 4
@


1.1
log
@*** empty log message ***
@
text
@d108 2
d112 2
a113 1
					else;
@

