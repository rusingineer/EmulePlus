head	1.10;
access;
symbols
	PublicRelease_1i:1.9
	Interim_Release_1i_RC6:1.9
	Interim_Release_1i_RC3:1.8
	Interim_Release_1i_RC2:1.8
	Interim_Release_1i_RC1:1.7
	Interim_Release_1i_beta3:1.7
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.5
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.5
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.10
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.9;

1.9
date	2003.12.03.19.28.01;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.29.14.14.25;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.23.18.50.26;	author uid77509;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.26.16.54.25;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.15.10.08.19;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@New engine
@
text
@// TcpEngine.cpp: implementation of the CTcpEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifdef NEW_SOCKETS
#include "TcpEngine.h"
#include "OpCode.h"
#include "EmEngine.h"

//////////////////////////////////////////////////////////////////////
// start
bool CTcpEngine::InitAsync()
{
	if (m_hAsyncInit = CreateEvent(NULL, TRUE, FALSE, NULL))
	{
		// create a thread for handling standard sockets events
		UINT nThread = 0;
		if (m_hAsyncThread = (HANDLE) _beginthreadex(NULL, 0, SocketWndFunc, this, 0, &nThread))
		{
			// very well. Wait now until it finishes its initialization
			HANDLE pWait[] = { m_hAsyncInit, m_hAsyncThread };
			if (WAIT_OBJECT_0 == WaitForMultipleObjects(_countof(pWait), pWait, FALSE, 2000))
				// everything is ok
				return true;
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
// stop
void CTcpEngine::UninitAsync()
{
	if (m_hAsyncInit)
	{
		if (m_hAsyncThread)
		{
			if (m_hSocketWnd)
				VERIFY(PostMessage(m_hSocketWnd, WM_QUIT, 0, 0));

			if (WAIT_OBJECT_0 != WaitForSingleObject(m_hAsyncThread, 2000))
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "Thread has not terminated.");
				if (!TerminateThread(m_hAsyncThread, -1))
					AddDebugLogLine(false, "TerminateThread failed");
			}
			VERIFY(CloseHandle(m_hAsyncThread));
			m_hAsyncThread = NULL;
		}

		VERIFY(CloseHandle(m_hAsyncInit));
		m_hAsyncInit = NULL;
	}
	m_nOverlappedIOs = 0;
}

//////////////////////////////////////////////////////////////////////
UINT WINAPI CTcpEngine::SocketWndFunc(PVOID pPtr)
{
	CTcpEngine* pThis = (CTcpEngine*) pPtr;
	ASSERT(pThis);
	if (pThis)
	{
		ASSERT(!pThis->m_hSocketWnd);
		HINSTANCE hInstance = GetModuleHandle(NULL);

		WNDCLASS stWC;
		ZeroMemory(&stWC, sizeof(stWC));
		stWC.hInstance = hInstance;
		stWC.lpfnWndProc = SocketWndProc;
		stWC.lpszClassName = _T("EM_SockWnd");
		stWC.cbWndExtra = sizeof(ULONG_PTR);

		ATOM aClass = RegisterClass(&stWC);
		ASSERT(aClass);

		if (aClass)
		{
			if (pThis->m_hSocketWnd = CreateWindow((LPCTSTR) aClass, _T(""), 0, 0, 0, 0, 0, NULL, NULL, hInstance, NULL))
			{
				CState stState(*pThis);

				SetWindowLong(pThis->m_hSocketWnd, GWL_USERDATA, (long) &stState);

				VERIFY(SetEvent(pThis->m_hAsyncInit));

				// From now on - run the message loop, so that this thread most of the time
				// is in alertable state.
				for (bool bRun = true; bRun; )
				{
					MsgWaitForMultipleObjectsEx(0, NULL, INFINITE, QS_ALLEVENTS, MWMO_ALERTABLE);

					MSG stMsg;
					while (PeekMessage(&stMsg, NULL, 0, 0, PM_REMOVE))
						if (WM_QUIT == stMsg.message)
							bRun = false;
						else
							DispatchMessage(&stMsg);
				}

				if (IsWindow(pThis->m_hSocketWnd))
					VERIFY(DestroyWindow(pThis->m_hSocketWnd));

				// destroy all our possibly left clients
				for (UINT nIndex = 0; nIndex < _countof(stState.m_pHashTable); nIndex++)
				{
					OVERLAPPED_TCP* pClient = stState.m_pHashTable[nIndex];
					while (pClient)
					{
						OVERLAPPED_TCP* pNext = pClient->m_pNext;
						delete pClient;
						pClient = pNext;
					}
				}

				// Wait until all pending IO operations return with error
				const DWORD PENDING_WAIT_MAX = 1000;
				DWORD dwTicks = GetTickCount();
				while (true)
				{
					if (pThis->m_nOverlappedIOs <= 0)
						break;

					DWORD dwWait = GetTickCount() - dwTicks;
					if (dwWait >= PENDING_WAIT_MAX)
						break;

					dwWait = PENDING_WAIT_MAX - dwWait;
					MsgWaitForMultipleObjectsEx(0, NULL, dwWait, QS_ALLEVENTS, MWMO_ALERTABLE);
				}

				if (pThis->m_nOverlappedIOs)
				{
					ASSERT(FALSE);
					AddDebugLogLine(false, _T("Overlapped IOs counter is %d"), pThis->m_nOverlappedIOs);
				}

			} else
				ASSERT(FALSE);

			VERIFY(UnregisterClass((LPCTSTR) aClass, hInstance));
		}
	}
	
	return 0;
}

//////////////////////////////////////////////////////////////////////
LRESULT WINAPI CTcpEngine::SocketWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
	case WM_EMSOCKET:
	case WM_EM_ADDINTERFACE:
	case WM_EM_CONNECT:
	case WM_EM_SEND:
	case WM_EM_DISCONNECT:
		break;
	default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}

	CState* pState = (CState*) GetWindowLong(hWnd, GWL_USERDATA);
	ASSERT(pState);
	if (pState)
		switch (uMsg)
		{
		case WM_EMSOCKET:
			{
				OVERLAPPED_TCP* pClient = pState->LookupClient(wParam);
				if (pClient)
					pClient->ProcessEvent(*pState, LOWORD(lParam), HIWORD(lParam));
			}
			break;
		case WM_EM_ADDINTERFACE:
			{
				CInterface* pInterface = (CInterface*) wParam;
				ASSERT(pInterface);
				if (pInterface)
				{
					// associate now a 'client' with this interface
					OVERLAPPED_ACCEPT* pClient = new OVERLAPPED_ACCEPT(*pInterface);
					ASSERT(pClient);
					if (pClient)
					{
						pClient->m_hSocket = pInterface->m_hSocket;
						pState->AddClient(*pClient);

						// just in case there are already pending accept operations
						pClient->ProcessEvent(*pState, FD_ACCEPT, 0);

					} else
					{
						ASSERT(FALSE);
						AddDebugLogLine(false, "no memory");
						InterlockedDecrement(&pInterface->m_nPendingAccepts);
					}
				}

				InterlockedDecrement(&pInterface->m_nPendingAccepts);

				if (lParam && !SetEvent((HANDLE) lParam))
				{
					ASSERT(FALSE);
					AddDebugLogLine(false, "SetEvent failed");
				}
			}
			break;
		case WM_EM_CONNECT:
			{
				OVERLAPPED_RECV* pClient = (OVERLAPPED_RECV*) wParam;
				ASSERT(pClient);
				if (pClient)
				{
					pState->AddClient(*pClient);

					SOCKADDR_IN stAddr;
					stAddr.sin_family = AF_INET;
					stAddr.sin_addr.S_un.S_addr = pClient->m_nPeerAddr;
					stAddr.sin_port = pClient->m_nPeerPort;

					if (connect(pClient->m_hSocket, (sockaddr*) &stAddr, sizeof(stAddr)))
					{
						int nError = WSAGetLastError();
						if (WSAEWOULDBLOCK != nError)
							pClient->ProcessEvent(*pState, FD_CONNECT, nError);
					} else
						pClient->ProcessEvent(*pState, FD_CONNECT, 0);
				}
			}
			break;

		case WM_EM_SEND:
			{
				OVERLAPPED_SEND* pSend = (OVERLAPPED_SEND*) lParam;
				ASSERT(pSend);
				DWORD dwSize = 0;

				InterlockedIncrement(&pState->m_stEngine.m_nOverlappedIOs);

				if (pSend && WSASend(pSend->m_hSocket, pSend, 1, &dwSize, 0, pSend, OVERLAPPED_TCP::OverlappedCompletionFunc))
					{
						int nError = WSAGetLastError();
						if (WSA_IO_PENDING != nError)
						{
							InterlockedDecrement(&pState->m_stEngine.m_nOverlappedIOs);

							// notify the EMEngine about this.
							CTask_Tcp_Err::Post(pState->m_stEngine.m_stEngine, pSend->m_hSocket, nError);
							delete pSend;
						}
					}
			}
			break;

		case WM_EM_DISCONNECT:
			ASSERT(INVALID_SOCKET != lParam);
			if ((INVALID_SOCKET != lParam) && shutdown((SOCKET) lParam, SD_SEND))
				CTask_Tcp_Err::Post(pState->m_stEngine.m_stEngine, (SOCKET) lParam, WSAGetLastError());

			break;

		default:
			ASSERT(FALSE);
		}

	return 0;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_TCP::OverlappedCompletionFunc(DWORD dwError, DWORD dwBytes, OVERLAPPED* pOverlapped, DWORD dwFlags)
{
	OVERLAPPED_TCP* pOverlappedTcp = (OVERLAPPED_TCP*) pOverlapped;
	ASSERT(pOverlappedTcp && pOverlappedTcp->m_pEngine);
	if (pOverlappedTcp && pOverlappedTcp->m_pEngine)
	{
		InterlockedDecrement(&pOverlappedTcp->m_pEngine->m_nOverlappedIOs);
		pOverlappedTcp->ProcessCompletion(*pOverlappedTcp->m_pEngine, dwError, dwBytes);
	}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_TCP::ProcessEvent(CTcpEngine::CState&, int, int)
{
	ASSERT(FALSE);
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_TCP::ProcessCompletion(CTcpEngine&, int, DWORD)
{
	ASSERT(FALSE);
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_TCP::~OVERLAPPED_TCP()
{
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_RECV* CTcpEngine::AllocRecv(T_CLIENT_TYPE eType)
{
	switch (eType)
	{
	case T_CLIENT_PEER:
	case T_CLIENT_SERVER:
		return new OVERLAPPED_RECV_OPCODES(eType);
	case T_CLIENT_WEB:
		return new OVERLAPPED_RECV_WEB;

	default:
		ASSERT(FALSE); // invalid type
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_ACCEPT::ProcessEvent(CTcpEngine::CState& stState, int nEvent, int nError)
{
	if (nError)
		if (INTERFACE_FLAG_SHUTDOWN & m_stInterface.m_nFlags)
		{
			// self destruct
			stState.DeleteClient(*this);
			delete this;
		}
		else
			AddDebugLogLine(false, "Accept operation has failed");
	else
		while (true)
		{
			SOCKADDR_IN stAddr;
			int nLen = sizeof(stAddr);
			SOCKET hSocket = accept(m_hSocket, (sockaddr*) &stAddr, &nLen);
			if (INVALID_SOCKET == hSocket)
			{
				if (WSAEWOULDBLOCK != (nError = WSAGetLastError()))
				{
					ASSERT(FALSE);
					AddDebugLogLine(false, "acept failed");
				}
				break;
			}

			// create now a 'receiver' of relevant type
			OVERLAPPED_RECV* pOverlapped = stState.m_stEngine.AllocRecv(m_stInterface.m_eType);
			if (pOverlapped)
			{
				pOverlapped->m_hSocket = hSocket;
				pOverlapped->m_pEngine = &stState.m_stEngine;
				pOverlapped->m_nFlags = TCP_RECV_FLAG_CONNECTED | TCP_RECV_FLAG_FIRSTTIME;
				pOverlapped->m_nPeerAddr = stAddr.sin_addr.S_un.S_addr;
				pOverlapped->m_nPeerPort = stAddr.sin_port;

				// notify the EmEngine about new connection accepted
				CTask_Tcp_Accepted* pTask = new CTask_Tcp_Accepted;
				if (pTask)
				{
					pTask->m_hSocket = hSocket;
					pTask->m_nAddr.S_un.S_addr = stAddr.sin_addr.S_un.S_addr;
					pTask->m_uPort = stAddr.sin_port;
					pTask->m_eType = m_stInterface.m_eType;
					stState.m_stEngine.m_stEngine.m_stMain.Push(pTask);
				} 
				else
				{
					ASSERT(FALSE);
					AddDebugLogLine(false, "no memory");
				}

				pOverlapped->DisableTcpBufs(stState.m_stEngine);
				pOverlapped->ProcessCompletion(stState.m_stEngine, 0, 0); // will initiate the 1st read operation

			} 
			else
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "no memory");
				if (closesocket(hSocket))
					AddDebugLogLine(false, "closesocket failed");
			}
		}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_ACCEPT::ProcessCompletion(CTcpEngine& stEngine, int nError, DWORD dwBytes)
{
	// completion of AcceptEx operation
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_ACCEPT::~OVERLAPPED_ACCEPT()
{
	InterlockedDecrement(&m_stInterface.m_nPendingAccepts);
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ProcessEvent(CTcpEngine::CState& stState, int nEvent, int nError)
{
	stState.DeleteClient(*this);
	m_pEngine = &stState.m_stEngine;

	// the only event we expect is FD_CONNECT
	if (FD_CONNECT == nEvent)
		if (nError)
		{
			// Notify the EMEngine about unsuccessful connection attempt
			CTask_Tcp_Err::Post(stState.m_stEngine.m_stEngine, m_hSocket, nError);
			
			delete this;
		} else
		{
			CTask_Tcp_Connected* pTask = new CTask_Tcp_Connected;
			if (pTask)
			{
				pTask->m_hSocket = m_hSocket;
				stState.m_stEngine.m_stEngine.m_stMain.Push(pTask);

			} 
			else
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "no memory");
			}

			DisableTcpBufs(stState.m_stEngine);

			m_nFlags |= TCP_RECV_FLAG_CONNECTED | TCP_RECV_FLAG_FIRSTTIME;
			ProcessCompletion(stState.m_stEngine, 0, 0); // initiate read operation
		}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ProcessCompletion(CTcpEngine& stEngine, int nError, DWORD dwBytes)
{
	if (nError)
		dwBytes = 0; // of course

	if (TCP_RECV_FLAG_FIRSTTIME & m_nFlags)
		m_nFlags &= ~TCP_RECV_FLAG_FIRSTTIME;
	else
		if (dwBytes && (dwBytes + m_dwBufUsage <= m_dwBufSize))
		{
			m_dwBufUsage += dwBytes;

			DWORD dwParsed = ParseRecv(stEngine, false);
			if (dwParsed)
			{
				ASSERT(dwParsed <= m_dwBufUsage);
				if (!(m_dwBufUsage -= dwParsed))
					ClearBufs();
			} else
				if (m_dwBufSize == m_dwBufUsage)
					if (m_dwBufSize >= TCP_MAX_BUF_SIZE)
					{
						AddDebugLogLine(false, _T("The limit has been reached. Discarding."));
						ClearBufs();
					}
					else
					{
						// extend the buffer
						DWORD dwSizeNew = m_dwBufUsage + TCP_OPTIMAL_BUF;
						char* pBufNew = new char[dwSizeNew];
						if (pBufNew)
						{
							CopyMemory(pBufNew, GetBuffer(), m_dwBufUsage);
							if (m_pBufExtra)
								delete[] m_pBufExtra;
							m_pBufExtra = pBufNew;
							m_dwBufSize = dwSizeNew;

						} else
						{
							ASSERT(FALSE);
							AddDebugLogLine(false, "no memory");
							ClearBufs();
						}
					}

		} else
		{
			// the peer has called shutdown
			ParseRecv(stEngine, true);

			CTask_Tcp_Err::Post(stEngine.m_stEngine, m_hSocket, 0);

			delete this;
			return;
		}

	// initiate another read operation
	buf = GetBuffer() + m_dwBufUsage;
	VERIFY(len = m_dwBufSize - m_dwBufUsage);

	ZeroMemory((OVERLAPPED*) this, sizeof(OVERLAPPED)); // for more safety

	InterlockedIncrement(&stEngine.m_nOverlappedIOs);

	DWORD dwFlag = 0;
	if (WSARecv(m_hSocket, this, 1, &dwBytes, &dwFlag, this, OverlappedCompletionFunc))
	{
		int nError = WSAGetLastError();
		if (WSA_IO_PENDING != nError)
		{
			// oops
			InterlockedDecrement(&stEngine.m_nOverlappedIOs);
			// notify EMEngine about this error
			CTask_Tcp_Err::Post(stEngine.m_stEngine, m_hSocket, nError);
			delete this;
		}
	}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::DisableTcpBufs(CTcpEngine& stEngine)
{
	// From now on we are not interested in futher notifications
	if (WSAAsyncSelect(m_hSocket, stEngine.m_hSocketWnd, 0, 0))
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "WSAAsyncSelect failed");
	}

	// disable both read and write built-in socket buffers
	DWORD dwZero = 0;
	if (setsockopt(m_hSocket, SOL_SOCKET, SO_RCVBUF, (char*) &dwZero, sizeof(dwZero)) ||
		setsockopt(m_hSocket, SOL_SOCKET, SO_SNDBUF, (char*) &dwZero, sizeof(dwZero)))
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "setsockopt failed");
	}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ClearBufs()
{
	if (m_pBufExtra)
	{
		delete[] m_pBufExtra;
		m_pBufExtra = NULL;
	}
	m_dwBufUsage = 0;
	m_dwBufSize = sizeof(m_pBuf);
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_RECV::~OVERLAPPED_RECV()
{
	ClearBufs();
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_SEND::ProcessCompletion(CTcpEngine& stEngine, int nError, DWORD dwBytes)
{
	if (nError)
		// notify EMEngine about this error
		CTask_Tcp_Err::Post(stEngine.m_stEngine, m_hSocket, nError);
	delete this;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::CState::AddClient(OVERLAPPED_TCP& stClient)
{
	OVERLAPPED_TCP*& pFirst = m_pHashTable[stClient.m_hSocket % _countof(m_pHashTable)];
	if (pFirst)
	{
		ASSERT(!pFirst->m_pPrev);
		pFirst->m_pPrev = &stClient;
	}
	stClient.m_pNext = pFirst;
	pFirst = &stClient;
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_TCP* CTcpEngine::CState::LookupClient(SOCKET hSocket)
{
	for (OVERLAPPED_TCP* pClient = m_pHashTable[hSocket % _countof(m_pHashTable)]; pClient; pClient = pClient->m_pNext)
		if (pClient->m_hSocket == hSocket)
			break;

	return pClient;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::CState::DeleteClient(CTcpEngine::OVERLAPPED_TCP& stClient)
{
	if (stClient.m_pNext)
	{
		ASSERT(stClient.m_pNext->m_pPrev == &stClient);
		stClient.m_pNext->m_pPrev = stClient.m_pPrev;
	}
	if (stClient.m_pPrev)
	{
		ASSERT(stClient.m_pPrev->m_pNext == &stClient);
		stClient.m_pPrev->m_pNext = stClient.m_pNext;
	} else
	{
		OVERLAPPED_TCP*& pFirst = m_pHashTable[stClient.m_hSocket % _countof(m_pHashTable)];
		if (pFirst == &stClient)
			pFirst = stClient.m_pNext;
		else
			ASSERT(FALSE); // must not happen !!!
	}
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::Init()
{
	WSADATA stData;
	if (WSAStartup(MAKEWORD(2, 2), &stData))
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "WSAStartup failed");
	}
	else
	{
		m_bWinsockInit = true;
		return InitAsync();
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::AddInterface(USHORT nPort, T_CLIENT_TYPE eType)
{
	SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (INVALID_SOCKET != hSocket)
	{
		SOCKADDR_IN stAddr;
		stAddr.sin_family = AF_INET;
		stAddr.sin_addr.S_un.S_addr = INADDR_ANY;
		stAddr.sin_port = htons(nPort);

		if (!bind(hSocket, (sockaddr*) &stAddr, sizeof(stAddr)) &&
			!WSAAsyncSelect(hSocket, m_hSocketWnd, WM_EMSOCKET, FD_ACCEPT) &&
			!listen(hSocket, SOMAXCONN))
		{
			// very well.
			CInterface* pInterface = new CInterface;
			ASSERT(pInterface);
			if (pInterface)
			{
				pInterface->m_hSocket = hSocket;
				pInterface->m_uPort = nPort;
				pInterface->m_eType = eType;
				pInterface->m_nPendingAccepts = 1;

				if (PostMessage(m_hSocketWnd, WM_EM_ADDINTERFACE, (WPARAM) pInterface, 0))
				{
					AddDebugLogLine(false, _T("Added interface for port %u."), nPort);
					m_queueInterfaces.push(pInterface);
					return true; // success
				}

				ASSERT(FALSE);
				AddDebugLogLine(false, "PostMessage failed");
				delete pInterface;
			} 
			else
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "no memory");
			}
		}
		else
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, _T("Failed to bind to port %u. (already in use ?)"), nPort);
		}

		if (closesocket(hSocket))
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "closesocket failed");
		}
	}
	return false; // failed
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::Uninit(bool bCleanupWinsock /* = true */)
{
	if (m_bWinsockInit)
	{
		// purge all interfaces
		for (; !m_queueInterfaces.empty(); m_queueInterfaces.pop())
		{
			CInterface* pInterface = m_queueInterfaces.front();
			ASSERT(pInterface);

			pInterface->m_nFlags |= INTERFACE_FLAG_SHUTDOWN;

			if (closesocket(pInterface->m_hSocket))
				AddDebugLogLine(false, "closesocket failed");

			if (m_hSocketWnd && !PostMessage(m_hSocketWnd, WM_EMSOCKET, pInterface->m_hSocket, MAKELONG(FD_ACCEPT, -1)))
				AddDebugLogLine(false, "PostMessage failed");

			// wait now until all accept operations return with an error
			for (DWORD dwTicks = GetTickCount(); pInterface->m_nPendingAccepts; Sleep(0))
				if (GetTickCount() - dwTicks > 1000)
				{
					ASSERT(FALSE);
					AddDebugLogLine(false, "Not all accept operations returned");
					break;
				}

			delete pInterface;
		}

		if (bCleanupWinsock)
		{
			UninitAsync();

			if (WSACleanup())
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "WSACleanup failed");
			}
			m_bWinsockInit = false;
		}
	}
}

//////////////////////////////////////////////////////////////////////
SOCKET CTcpEngine::AllocConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType)
{
	OVERLAPPED_RECV* pClient = AllocRecv(eType);
	ASSERT(pClient);
	if (pClient)
	{
		SOCKET hSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
		if (INVALID_SOCKET == (pClient->m_hSocket = hSocket))
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "WSASocket failed");
		}
		else
		{
			if (WSAAsyncSelect(pClient->m_hSocket, m_hSocketWnd, WM_EMSOCKET, FD_CONNECT))
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "WSAAsyncSelect failed");
			}
			else
			{
				pClient->m_nFlags = 0;
				pClient->m_nPeerAddr = nAddr;
				pClient->m_nPeerPort = htons(nPort);

				if (PostMessage(m_hSocketWnd, WM_EM_CONNECT, (WPARAM) pClient, 0))
					return hSocket;

			}
			ASSERT(FALSE);
			AddDebugLogLine(false, "PostMessage failed");
			if (closesocket(pClient->m_hSocket))
				AddDebugLogLine(false, "closesocket failed");
		}
		delete pClient;
	} 
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
	}

	return INVALID_SOCKET;
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwSize)
{
	OVERLAPPED_SEND* pOverlapped = new (dwSize) OVERLAPPED_SEND;
	ASSERT(pOverlapped);
	if (pOverlapped)
	{
		CopyMemory(pOverlapped->m_pBuf, pData, dwSize);
		pOverlapped->buf = (char*) pOverlapped->m_pBuf;
		pOverlapped->len = dwSize;
		pOverlapped->m_pEngine = this;
		pOverlapped->m_hSocket = hSocket;

		if (PostMessage(m_hSocketWnd, WM_EM_SEND, 0, (LPARAM) pOverlapped))
			return true; // ok

		ASSERT(FALSE);
		AddDebugLogLine(false, "PostMessage failed");

	}
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
	}

	CTask_Tcp_Err::Post(m_stEngine, hSocket, -1);
	return false;
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::AllocSend(SOCKET hSocket, const COpCode& stOpCode)
{
	BYTE pBuf[TCP_OPTIMAL_BUF];
	CStream_MemEx stStream;
	stStream.m_pPtr = pBuf;
	stStream.m_dwSize = sizeof(pBuf);

	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP));
	if (!stStream.m_dwSizeExtra)
		return AllocSend(hSocket, pBuf, sizeof(pBuf) - stStream.m_dwSize);

	// this opcode seems to be huge.
	DWORD dwSizeHuge = sizeof(pBuf) + stStream.m_dwSizeExtra;
	PBYTE pBufDyn = new BYTE[dwSizeHuge];
	if (!pBufDyn)
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
		CTask_Tcp_Err::Post(m_stEngine, hSocket, -1);
		return false;
	}

	stStream.m_pPtr = pBufDyn;
	stStream.m_dwSize = dwSizeHuge;
	stStream.m_dwSizeExtra = 0;
	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP));

	bool bSend = AllocSend(hSocket, pBufDyn, dwSizeHuge);
	delete[] pBufDyn;

	return bSend;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::AllocDisconnect(SOCKET hSocket)
{
	if (!PostMessage(m_hSocketWnd, WM_EM_DISCONNECT, 0, (LPARAM) hSocket))
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "PostMessage failed");
		CTask_Tcp_Err::Post(m_stEngine, hSocket, -1);
	}
}

//////////////////////////////////////////////////////////////////////
DWORD CTcpEngine::OVERLAPPED_RECV_WEB::ParseRecv(CTcpEngine& stEngine, bool bIsLastRecv)
{
	char* pData = GetBuffer();
	ASSERT(pData);

	if (!m_dwHttpHeaderLen)
	{
		// try to find it
		bool bPrevEndl = false;
		for (DWORD dwPos = 0; dwPos < m_dwBufUsage; dwPos++)
			if ('\n' == pData[dwPos])
				if (bPrevEndl)
				{
					// We just found the end of the http header
					// Now write the message's position into two first DWORDs of the buffer
					m_dwHttpHeaderLen = dwPos + 1;

					// try to find now the 'Content-Length' header
					for (dwPos = 0; dwPos < m_dwHttpHeaderLen; )
					{
						PVOID pPtr = memchr(pData + dwPos, '\n', m_dwHttpHeaderLen - dwPos);
						if (!pPtr)
							break;
						DWORD dwNextPos = ((DWORD) pPtr) - ((DWORD) pData);

						// check this header
						char szMatch[] = "content-length";
						if (!strnicmp(pData + dwPos, szMatch, sizeof(szMatch) - 1))
						{
							dwPos += sizeof(szMatch) - 1;
							pPtr = memchr(pData + dwPos, ':', m_dwHttpHeaderLen - dwPos);
							if (pPtr)
								m_dwHttpContentLen = atol(((char*) pPtr) + 1);

							break;
						}
						dwPos = dwNextPos + 1;
					}

					break;
				}
				else
				{
					bPrevEndl = true;
				}
			else
				if ('\r' != pData[dwPos])
					bPrevEndl = false;
	}

	DWORD dwParsed = 0;
	if (m_dwHttpHeaderLen)
	{
		if (bIsLastRecv && !m_dwHttpContentLen)
			m_dwHttpContentLen = m_dwBufUsage - m_dwHttpHeaderLen;

		if (m_dwHttpHeaderLen + m_dwHttpContentLen <= m_dwBufUsage)
		{
			dwParsed = m_dwHttpHeaderLen + m_dwHttpContentLen;

			CTask_Tcp_Web* pTask = new (dwParsed) CTask_Tcp_Web;
			if (pTask)
			{
				CopyMemory(pTask->m_pBuf, pData, dwParsed);
				pTask->m_hSocket = m_hSocket;
				pTask->m_dwHeaderLen = m_dwHttpHeaderLen;
				pTask->m_dwContentLen = m_dwHttpContentLen;

				stEngine.m_stEngine.m_stMain.Push(pTask);

			} 
			else
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, "no memory");
			}

			m_dwHttpHeaderLen = m_dwHttpContentLen = 0;
		}
	}
	return dwParsed;
}

//////////////////////////////////////////////////////////////////////
DWORD CTcpEngine::OVERLAPPED_RECV_OPCODES::ParseRecv(CTcpEngine& stEngine, bool)
{
	char* pData = GetBuffer();
	ASSERT(pData);

	
	for (DWORD dwParsed = 0; ;)
	{
		// over tcp transport opcodes always have a header of 6 bytes
		if (m_dwBufUsage < 6 + dwParsed)
			break;

		DWORD dwOpCodeLen = *((DWORD*) (pData + 1));
		if (!dwOpCodeLen)
		{
			ASSERT(FALSE);
			AddDebugLogLine(false, "Invalid recv data");
			return m_dwBufUsage; // will discard all the buffer
		}

		if (dwOpCodeLen + 5 + dwParsed > m_dwBufUsage)
			break;

		CStream_Mem stStream;
		stStream.m_pPtr = (PBYTE) pData + 6;
		stStream.m_dwSize = dwOpCodeLen - 1;

		COpCode* pOpCode = COpCode::Read(stStream, pData[5], pData[0], m_eType);
		if (pOpCode)
		{
			if (stStream.m_dwSize)
			{
				ASSERT(FALSE);
				AddDebugLogLine(false, _T("%u bytes left from OpCode initialization, id=%u"), stStream.m_dwSize, pOpCode->GetID());
			}

			pOpCode->m_hSocket = m_hSocket;
			stEngine.m_stEngine.m_stMain.Push(pOpCode);
		}
		else
		{
			AddDebugLogLine(false, _T("Can't receive opcode %x"), pData[5]);
//			ASSERT(FALSE);
		}

		dwOpCodeLen += 5;
		pData += dwOpCodeLen;
		dwParsed += dwOpCodeLen;
	}
	return dwParsed;
}

#endif@


1.9
log
@New sockets
@
text
@@


1.8
log
@New sockets
@
text
@d974 1
a974 1
			ASSERT(FALSE);
@


1.7
log
@Formatting, comments, and name changes.
@
text
@d11 2
d31 2
d59 1
d150 1
d272 1
d284 1
d289 2
d295 2
d301 1
d318 1
d385 2
d392 1
d398 1
d434 1
d515 1
d535 1
d547 1
d553 1
d562 1
d574 2
d585 1
d607 1
a607 1

d624 1
d681 1
d726 1
d772 1
d802 1
d836 1
d847 1
d931 1
d983 1
@


1.6
log
@New sockets - more server code
@
text
@d348 1
a348 1
					pTask->m_nPort = stAddr.sin_port;
d617 1
a617 1
				pInterface->m_nPort = nPort;
@


1.5
log
@New sockets. Connecting to server from server list
@
text
@d342 1
a342 1
				// notify the EMEngine about new connection accepted
@


1.4
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d40 1
d130 2
d133 1
d190 1
d199 2
d202 1
d325 2
d328 1
d351 4
a354 1
				} else
d356 1
d361 2
a362 1
			} else
d364 1
d402 4
a405 1
			} else
d407 1
d456 1
d500 2
d503 1
d509 2
d512 1
d585 2
d588 1
d628 1
d631 4
a634 1
			} else
d636 5
a640 1
		} else
d642 1
d645 2
d648 1
d675 1
d688 2
d691 1
d705 2
d708 1
d712 2
d715 1
d726 1
d732 4
a735 1
	} else
d737 1
d757 1
d760 4
a763 1
	} else
d765 1
d787 1
d808 1
d884 4
a887 1
			} else
d889 1
d912 1
d928 2
d931 1
d937 4
a940 1
			TRACE1(_T("Can't receive opcode %x"), pData[5]);
@


1.3
log
@Another new sockets cumulative update
@
text
@d9 1
d287 1
a287 1
		return new OVERLAPPED_RECV_OPCODES;
d854 1
a854 1
		COpCode* pOpCode = COpCode::Read(stStream, pData[5]);
d863 2
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d8 1
d123 1
a123 1
					dwWait = PENDING_WAIT_MAX - dwTicks;
a637 2
		UninitAsync();

d640 2
d859 1
@


1.1
log
@*** empty log message ***
@
text
@d49 1
d110 19
d146 2
d219 30
d261 2
d264 1
d279 16
d320 1
a320 1
			OVERLAPPED_RECV* pOverlapped = new OVERLAPPED_RECV_WEB;
d336 1
d362 31
d395 3
d405 1
a405 1
			DWORD dwParsed = ParseRecv(m_pBufExtra ? m_pBufExtra : m_pBuf, m_dwBufUsage, false);
d425 1
a425 1
							CopyMemory(pBufNew, m_pBufExtra ? m_pBufExtra : m_pBuf, m_dwBufUsage);
d441 1
a441 1
			ParseRecv(m_pBufExtra ? m_pBufExtra : m_pBuf, m_dwBufUsage, true);
d450 1
a450 2
	buf = m_pBufExtra ? m_pBufExtra : m_pBuf;
	buf += m_dwBufUsage;
d455 2
d464 1
a471 21
void CTcpEngine::OVERLAPPED_RECV::ProcessEvent(CTcpEngine::CState& stState, int nEvent, int nError)
{
	stState.DeleteClient(*this);
	m_pEngine = &stState.m_stEngine;

	// the only event we expect is FD_CONNECT
	if (!nError && (FD_CONNECT == nEvent))
	{
		DisableTcpBufs(stState.m_stEngine);

		m_nFlags |= TCP_RECV_FLAG_CONNECTED | TCP_RECV_FLAG_FIRSTTIME;
		ProcessCompletion(stState.m_stEngine, 0, 0); // initiate read operation
	} else
	{
		// Notify the EMEngine about unsuccessful connection attempt
		CTask_Tcp_Err::Post(stState.m_stEngine.m_stEngine, m_hSocket, nError);
		
		delete this;
	}
}

d564 1
a564 1
bool CTcpEngine::AddInterface(USHORT nPort, bool bWebInterface)
d585 1
a585 1
				pInterface->m_nFlags = bWebInterface ? INTERFACE_FLAG_WEB : 0;
d648 1
a648 1
SOCKET CTcpEngine::AllocConnect(ULONG nAddr, USHORT nPort)
d650 1
a650 1
	OVERLAPPED_RECV* pClient = new OVERLAPPED_RECV_WEB;
d694 4
a697 11
		if (WSASend(hSocket, pOverlapped, 1, &(dwSize = 0), 0, pOverlapped, OVERLAPPED_TCP::OverlappedCompletionFunc))
		{
			int nError = WSAGetLastError();
			if (WSA_IO_PENDING != nError)
			{
				// notify the EMEngine about this.
				delete pOverlapped;
				return false;
			}
		}
		return true;
d702 1
d706 1
a706 1
DWORD CTcpEngine::OVERLAPPED_RECV_WEB::ParseRecv(char* pData, DWORD dwSize, bool bIsLastRecv)
d708 89
a796 1
	ASSERT(pData && dwSize);
d798 46
d845 20
@

