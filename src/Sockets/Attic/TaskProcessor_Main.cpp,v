head	1.11;
access;
symbols
	PublicRelease_1i:1.9
	Interim_Release_1i_RC6:1.9
	Interim_Release_1i_RC3:1.9
	Interim_Release_1i_RC2:1.9
	Interim_Release_1i_RC1:1.8
	Interim_Release_1i_beta3:1.8
	Interim_Release_1i_beta2:1.7
	Interim_Release_1i_beta1:1.7
	PublicRelease_1h:1.7
	Interim_Release_1h_rc2:1.6
	Interim_Release_1h_RC1:1.6
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.11
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.10;

1.10
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.29.14.14.25;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.16.16.34.40;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.08.17.55.38;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.15.10.08.19;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@New engine
@
text
@// TaskProcessor_Main.cpp: implementation of the CTaskProcessor_Main class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifdef NEW_SOCKETS

#include "TaskProcessor_Main.h"
#include "EmEngine.h"

//////////////////////////////////////////////////////////////////////
// starting
bool CTaskProcessor_Main::Start()
{
//	m_mapClients.InitHashTable(997);
	m_dwWaitTimeout = 500;
	return true;
}

//////////////////////////////////////////////////////////////////////
// destroy all clients that are possibly left in our map
void CTaskProcessor_Main::Stop()
{
	
	for (SocketClientMap::iterator pos = m_mapClients.begin(); pos != m_mapClients.end(); pos++)
	{
		CEmClient* pClient = (*pos).second;
		ASSERT(pClient);
		delete pClient;
	}
	m_mapClients.clear();
}

//////////////////////////////////////////////////////////////////////
// processing timeout
// this should replace all old Process() functions
void CTaskProcessor_Main::ProcessTimeout()
{
	// keep connection alive once per minute
	// recommended by lugdunummaster
	if(m_stEngine.m_stData.IsConnected())
	{
		// sending empty OFFER FILES opcode
	}

	m_dwWaitTimeout = 1000; // perform check once per second
}

//////////////////////////////////////////////////////////////////////
// creating new client object
CEmClient* CTaskProcessor_Main::AllocClient(T_CLIENT_TYPE eType)
{
	switch (eType)
	{
	case T_CLIENT_PEER:
		return new CEmClient_Peer;
		break;
	case T_CLIENT_SERVER:
		return new CEmClient_Server;
		break;
	case T_CLIENT_WEB:
		return new CEmClient_Web;
		break;
	default:
		ASSERT(FALSE); // invalid type ???
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////
// connecting to any client (or server)
CEmClient* CTaskProcessor_Main::AllocTcpConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eClientType)
{
	CEmClient* pClient = AllocClient(eClientType);
	if (pClient)
	{
		pClient->m_nAddr = nAddr;
		pClient->m_uPort = nPort;
		SOCKET hSocket = m_stEngine.m_stTcp.AllocConnect(nAddr, nPort, eClientType);
		if (INVALID_SOCKET == hSocket)
		{
			delete pClient;
			pClient = NULL;
		} else
		{
			pClient->m_hSocket = hSocket;
			pClient->m_bIsConnected = false;

			m_mapClients[hSocket] = pClient;
		}
	} 
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine(false, "no memory");
	}

	return pClient;
}

//////////////////////////////////////////////////////////////////////
// disconnect existing client and destroy its object
void CTaskProcessor_Main::KillClient(CEmClient* pClient)
{
	ASSERT(pClient);
	SOCKET hSocket = pClient->m_hSocket;
	pClient->OnDisconnected(m_stEngine);
	delete pClient;
	m_mapClients.erase(hSocket);
}

#endif@


1.10
log
@New engine
@
text
@@


1.9
log
@New sockets
@
text
@d15 1
a15 1
	m_mapClients.InitHashTable(997);
d24 2
a25 1
	for (POSITION pos = m_mapClients.GetStartPosition(); pos; )
d27 1
a27 3
		CEmClient* pClient;
		SOCKET hSocket;
		m_mapClients.GetNextAssoc(pos, hSocket, pClient);
d31 1
a31 1
	m_mapClients.RemoveAll();
d89 1
a89 1
			m_mapClients.SetAt(hSocket, pClient);
d109 1
a109 1
	m_mapClients.RemoveKey(hSocket);
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d11 2
d20 2
a23 1
	// destroy all clients that are possibly left in our map
d35 3
d40 6
a45 1
//	AllocTcpConnect(inet_addr("193.111.198.139"), 4242, T_CLIENT_SERVER);
d47 1
a47 4
//	CEmClient_Web* pClient = (CEmClient_Web*) AllocTcpConnect(inet_addr("216.109.125.70"), 80, T_CLIENT_WEB);
//	if (pClient)
//		pClient->m_bIsJunky = true;
	m_dwWaitTimeout = INFINITE;
d50 2
d71 2
d102 2
@


1.7
log
@New sockets
@
text
@d67 1
a67 1
		pClient->m_nPort = nPort;
@


1.6
log
@New sockets - more server logic
@
text
@d90 9
@


1.5
log
@New sockets. Connecting to server from server list
@
text
@d66 2
@


1.4
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d34 2
a35 1
	AllocTcpConnect(inet_addr("193.111.198.139"), 4242, T_CLIENT_SERVER);
d78 4
a81 1
	} else
d83 1
@


1.3
log
@Another new sockets cumulative update
@
text
@d8 3
d34 1
a34 1
	AllocTcpConnect(inet_addr("212.143.141.24"), 4662, T_CLIENT_PEER);
@


1.2
log
@Cumulative update. Not working yet.
@
text
@d31 5
a35 3
	CEmClient_Web* pClient = (CEmClient_Web*) AllocTcpConnect(inet_addr("216.109.125.70"), 80, T_CLIENT_WEB);
	if (pClient)
		pClient->m_bIsJunky = true;
d75 1
a75 1
		ELOG("no memory");
@


1.1
log
@*** empty log message ***
@
text
@d7 1
d10 2
d17 10
d31 45
@

