head	1.12;
access;
symbols
	PublicRelease_1i:1.10
	Interim_Release_1i_RC6:1.10
	Interim_Release_1i_RC3:1.9
	Interim_Release_1i_RC2:1.9
	Interim_Release_1i_RC1:1.7
	Interim_Release_1i_beta3:1.7
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.6
	PublicRelease_1h:1.6
	Interim_Release_1h_rc2:1.6
	Interim_Release_1h_RC1:1.6
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.4
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1;
locks; strict;
comment	@// @;


1.12
date	2003.12.16.17.48.07;	author kuchin;	state dead;
branches;
next	1.11;

1.11
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.03.19.28.01;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.17.10.24.33;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.15.12.31.46;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.30.16.57.42;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.08.27.09.27.14;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.08.26.16.54.24;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.08.19.06.52.40;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.15.10.08.19;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.10.14.19.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.23.18.06.39;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@New engine
@
text
@// OpCode.cpp: implementation of the COpCode class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifdef NEW_SOCKETS
#include "OpCode.h"
#include "EmEngine.h"

//////////////////////////////////////////////////////////////////////
template <> void CStream::operator << (const CString& strTxt)
{
	*this << (USHORT) strTxt.GetLength();
	DumpString(strTxt);
}

//////////////////////////////////////////////////////////////////////
void CStream::DumpString(const CString& strTxt)
{
	USHORT nLen = (USHORT) strTxt.GetLength();

#ifdef UNICODE
	if (m_bUnicode)
		Write((LPCWSTR) strTxt, nLen * sizeof(WCHAR));
	else
	{
		// convert it to ANSI string
		CQuickBuf stBuf;
		stBuf.Alloc(nLen);
		if (nLen != WideCharToMultiByte(AP_ACP, 0, strTxt, nLen, (PSTR) stBuf.m_pBufUse, nLen, NULL, NULL))
			Exception();

		Write(stBuf.m_pBufUse, nLen);
	}

#else // UNICODE

	if (m_bUnicode)
	{
		// convert it to unicode
		CQuickBuf stBuf;
		stBuf.Alloc(nLen * sizeof(WCHAR));
		if (nLen != MultiByteToWideChar(CP_ACP, 0, strTxt, nLen, (PWSTR) stBuf.m_pBufUse, nLen))
			Exception();

		Write(stBuf.m_pBufUse, nLen * sizeof(WCHAR));
	} else
		Write((LPCSTR) strTxt, nLen);

#endif // UNICODE
}

//////////////////////////////////////////////////////////////////////
template <> void CStream::operator >> (CString& strTxt)
{
	ushort nLen;
	*this >> nLen;
	InitString(strTxt, nLen);
}

//////////////////////////////////////////////////////////////////////
void CStream::InitTrailingString(CString& strTxt) {
	DWORD dwSize = SizeLeft();
	if (m_bUnicode)
		dwSize >>= 1; // /= 2
	if (dwSize > 0xFFFF)
		Exception();
	InitString(strTxt, SizeLeft());
}

//////////////////////////////////////////////////////////////////////
void CStream::InitString(CString& strTxt, ushort nLen)
{
	strTxt.Empty();
	PVOID pStr = strTxt.GetBuffer(nLen);

#ifdef UNICODE

	if (m_bUnicode)
		Read(pStr, nLen * sizeof(WCHAR));
	} else
	{
		// convert it to unicode
		CQuickBuf stBuf;
		stBuf.Alloc(nLen);
		Read(stBuf.m_pBufUse, nLen);

		if (nLen != MultiByteToWideChar(CP_ACP, 0, (PCSTR) stBuf.m_pBufUse, nLen, (PWSTR) pStr, nLen))
			Exception();
	}
#else // UNICODE
	if (m_bUnicode)
	{
		// convert it to ansi
		CQuickBuf stBuf;
		stBuf.Alloc(nLen * sizeof(WCHAR));
		Read(stBuf.m_pBufUse, nLen * sizeof(WCHAR));

		if (nLen != WideCharToMultiByte(CP_ACP, 0, (PCWSTR) stBuf.m_pBufUse, nLen, (PSTR) pStr, nLen, NULL, NULL))
			Exception();
	} else
		Read(pStr, nLen);
#endif // UNICODE

	strTxt.ReleaseBuffer(nLen);
}

//////////////////////////////////////////////////////////////////////
void CStream::DumpTags(CTagEntry* pTags, DWORD dwCount)
{
	// count how many tags we have
	DWORD dwTagsCount = 0;
	for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
		if (pTags[dwIndex].m_pTag->m_bValid)
			dwTagsCount++;

	*this << dwTagsCount;

	// dump tags
	for (; dwCount--; pTags++)
		if (pTags->m_pTag->m_bValid)
		{
			*this << pTags->m_nType;

			// put this tag's id (or name)
			*this << pTags->m_nNameLen;
			if (1 == pTags->m_nNameLen)
				*this << (BYTE) pTags->m_dwName;
			else
				Write((PVOID) pTags->m_dwName, pTags->m_nNameLen);
			
			// tag's value
			switch (pTags->m_nType)
			{
			case OP_TAG_DWORD:
				*this << ((CTag_DWORD*) pTags->m_pTag)->m_dwValue;
				break;

			case OP_TAG_STRING:
				*this << ((CTag_String*) pTags->m_pTag)->m_strValue;
				break;

			default:
				Exception();
			}

		}
}

template <class T> void StreamDumpElement(CStream& stStream, const T& stElement)
{
	stStream << stElement;
}
template <class T> void StreamInitElement(CStream& stStream, T& stElement)
{
	stStream >> stElement;
}

//////////////////////////////////////////////////////////////////////
template <class T>
void CStream::DumpArr(const vector<T>& arrValue, int nCounterLen)
{
	int nSize = arrValue.size();
	ASSERT(nCounterLen <= sizeof(nSize));
	if((sizeof(nCounterLen) == 1 && nSize > 255) || (sizeof(nCounterLen) == 2 && nSize > 65535))
		Exception(); // too long

	Write(&nSize, nCounterLen);
	for (int nItem = 0; nItem < nSize; nItem++)
		StreamDumpElement(*this, arrValue[nItem]);
}

//////////////////////////////////////////////////////////////////////
template <class T>
void CStream::InitArr(vector<T>& arrValue, int nCounterLen)
{
	int nSize;
	ASSERT(nCounterLen <= sizeof(nSize));
	Read(&nSize, nCounterLen);

//	arrValue.SetSize(nSize);
	arrValue.resize(nSize);
	for (int nItem = 0; nItem < nSize; nItem++)
		StreamInitElement(*this, arrValue[nItem]);
}

//////////////////////////////////////////////////////////////////////
void CStream::InitTags(CTagEntry* pTags, DWORD dwCount)
{
	DWORD dwTagsCount;
	*this >> dwTagsCount;

	while (dwTagsCount--)
	{
		BYTE nType;
		*this >> nType;

		USHORT nLen;
		*this >> nLen;

		BYTE nTagID;
		CQuickBuf stTagName;

		if (1 == nLen)
			*this >> nTagID;
		else
		{
			stTagName.Alloc(nLen);
			Read(stTagName.m_pBufUse, nLen);
		}

		// check if we have such a tag id (or name)
		for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
			if ((pTags[dwIndex].m_nNameLen == nLen) &&
				((1 == nLen) ? (nTagID == (BYTE) pTags[dwIndex].m_dwName) : !memcmp(stTagName.m_pBufUse, (PVOID) pTags[dwIndex].m_dwName, nLen)))
				break; // match

		CTagEntry* pTarget = (dwIndex < dwCount) ? pTags + dwIndex : NULL;

		if (pTarget && (pTarget->m_nType != nType))
			Exception(); // type mismatch

		switch (nType)
		{
		case OP_TAG_DWORD:
			if (pTarget)
				*this >> ((CTag_DWORD*) pTarget->m_pTag)->m_dwValue;
			else
			{
				DWORD dwVal;
				*this >> dwVal;
			}
			break;
		case OP_TAG_STRING:
			if (pTarget)
				*this >> ((CTag_String*) pTarget->m_pTag)->m_strValue;
			else
			{
				CString strVal;
				*this >> strVal; // This is a bit heave. Better just to skip this string
			}
			break;
		default:
			Exception();
		}

		if (pTarget)
			pTarget->m_pTag->m_bValid = true;
	}
}

//////////////////////////////////////////////////////////////////////
void CStream::Write(PCVOID, DWORD)
{
	Exception(); // not implemented
}

//////////////////////////////////////////////////////////////////////
void CStream::Read(PVOID, DWORD)
{
	Exception(); // not implemented
}

//////////////////////////////////////////////////////////////////////
DWORD CStream::SizeLeft()
{
	Exception(); // not implemented
	return 0;
}

//////////////////////////////////////////////////////////////////////
void CStream::Skip(DWORD dwSize)
{
	BYTE pBuf[0x1000];
	while (dwSize)
	{
		DWORD dwPortion = min(dwSize, sizeof(pBuf));
		Read(pBuf, dwPortion);
		dwSize -= dwPortion;
	}
}

//////////////////////////////////////////////////////////////////////
void CStream::Exception()
{
	CException stException;
	throw stException;
}

//////////////////////////////////////////////////////////////////////
void CStream_Measure::Write(PCVOID, DWORD dwSize)
{
	m_dwSize += dwSize;
}

//////////////////////////////////////////////////////////////////////
void CStream_Mem::Write(PCVOID pBuf, DWORD dwSize)
{
	if (dwSize > m_dwSize)
		Exception();
	CopyMemory(m_pPtr, pBuf, dwSize);
	m_pPtr += dwSize;
	m_dwSize -= dwSize;
}

//////////////////////////////////////////////////////////////////////
void CStream_Mem::Read(PVOID pBuf, DWORD dwSize)
{
	if (dwSize > m_dwSize)
		Exception();
	CopyMemory(pBuf, m_pPtr, dwSize);
	m_pPtr += dwSize;
	m_dwSize -= dwSize;
}

//////////////////////////////////////////////////////////////////////
void CStream_MemEx::Write(PCVOID pBuf, DWORD dwSize)
{
	if (dwSize > m_dwSize)
	{
		m_dwSizeExtra += dwSize;
		if (m_dwSize)
		{
			m_dwSizeExtra -= m_dwSize;
			m_dwSize = 0;
		}

	} else
	{
		CopyMemory(m_pPtr, pBuf, dwSize);
		m_pPtr += dwSize;
		m_dwSize -= dwSize;
	}
}

//////////////////////////////////////////////////////////////////////
COpCode::~COpCode()
{
}

//////////////////////////////////////////////////////////////////////
bool COpCode::Write(CStream& stStream, BYTE nTransport) const
{
	try
	{
		BYTE nProtocol = Z_Protocol();
		stStream.m_bUnicode = (OP_PROT_UNICODE == nProtocol);
		stStream << nProtocol;

		switch (nTransport)
		{
		case OP_TRANSPORT_TCP:
			{
				// write the body size
				CStream_Measure stMeasure;
				Z_Dump(stMeasure);

				stStream << stMeasure.m_dwSize + 1;
			}
			break;
		case OP_TRANSPORT_UDP:
			break;
		default:
			stStream.Exception(); // undefined transport format
		}

		stStream << GetID();

		// dump the rest of the opcode
		Z_Dump(stStream);

	}
	catch (CStream::CException)
	{
		return false;
	}
	return true; // ok
}

//////////////////////////////////////////////////////////////////////
COpCode* COpCode::CreateRaw(BYTE nID, BYTE nProtocol, T_CLIENT_TYPE eType)
{
	switch ((eType << 16) | (nProtocol << 8) | nID)
	{


#define BEGIN_OPCODE(id, name, prot, source)	case (T_CLIENT_##source << 16) | (OP_PROT_##prot << 8) | id: return new COpCode_##name;
		#define END_OPCODE
		#define PARAM_BYTE_JUNK(value)
		#define PARAM_BUF(name, type, count)
		#define PARAM_SIMPLE(name, type)
		#define PARAM_TAGS_BEGIN
		#define PARAM_TAGS_END
		#define PARAM_TAG_STR(name, id)
		#define PARAM_TAG_DWORD(name, id)
		#define PARAM_NTAG_DWORD(name, id)
		#define PARAM_TEXT_TRAILING(name)
		#define PARAM_ARRAY(name, type, counter)
		#define PARAM_COMPLEXARRAY_BEGIN(msg, name)
		#define PARAM_COMPLEXARRAY_END(name)

		#include "EmMsgs.h"

		#undef BEGIN_OPCODE
		#undef END_OPCODE
		#undef PARAM_BYTE_JUNK
		#undef PARAM_BUF
		#undef PARAM_SIMPLE
		#undef PARAM_TAGS_BEGIN
		#undef PARAM_TAGS_END
		#undef PARAM_TAG_STR
		#undef PARAM_TAG_DWORD
		#undef PARAM_NTAG_DWORD
		#undef PARAM_TEXT_TRAILING
		#undef PARAM_ARRAY
		#undef PARAM_COMPLEXARRAY_BEGIN
		#undef PARAM_COMPLEXARRAY_END
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////
COpCode* COpCode::Read(CStream& stStream, BYTE nID, BYTE nProtocol, T_CLIENT_TYPE eType)
{
	COpCode* pRet = CreateRaw(nID, nProtocol, eType);
	if (pRet)
		try
		{
			stStream.m_bUnicode = (OP_PROT_UNICODE == nProtocol);
			pRet->Z_Init(stStream);
		}
		catch (CStream::CException)
		{
			delete pRet;
			pRet = NULL;
		}

	return pRet;
}

//////////////////////////////////////////////////////////////////////
DWORD COpCode::GetSize(BYTE nTransport) const
{
	CStream_Measure stStream;
	return Write(stStream, nTransport) ? stStream.m_dwSize : 0;
}

//////////////////////////////////////////////////////////////////////
bool COpCode::Process(CEmEngine& stEngine)
{
	CEmClient* pClient = NULL;
	if (stEngine.m_stMain.IsInContext(*this))
	{
		pClient = stEngine.m_stMain.Lookup(m_hSocket);
		if (!pClient)
			return true; // no more relevant!
	}

	TRACE2(_T("\nProcessing opcode=%x, (socket=%u)"), GetID(), pClient ? pClient->m_hSocket : 0);
#ifdef _DEBUG
	ShowSelf(false);
#endif //_DEBUG

	return ProcessForClient(stEngine, pClient);
}

//////////////////////////////////////////////////////////////////////
// Debug stuff
#ifndef OPCODE_SKIP_DBGDUMP

void COpCode::CDbgDump::WriteParam(LPCTSTR szName, DWORD dwValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = %u"), szName, dwValue);
	m_strTxt += strDelta;
}
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CString& strValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = %s"), szName, strValue);
	m_strTxt += strDelta;
}
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const ADDRPORT& stValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = %u.%u.%u.%u:%u"), szName,
		((in_addr&)stValue._Addr).S_un.S_un_b.s_b1,
		((in_addr&)stValue._Addr).S_un.S_un_b.s_b2,
		((in_addr&)stValue._Addr).S_un.S_un_b.s_b3,
		((in_addr&)stValue._Addr).S_un.S_un_b.s_b4,
		stValue._Port);

	m_strTxt += strDelta;
}
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const void*, DWORD dwCount, DWORD)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = [Count=%u]"), szName, dwCount);
	m_strTxt += strDelta;
}
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CTag_DWORD& stValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = [%c] %u"), stValue.m_bValid ? _T('+') : _T('-'), stValue.m_dwValue);
	m_strTxt += strDelta;
}
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CTag_String& stValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = [%c] %s"), stValue.m_bValid ? _T('+') : _T('-'), stValue.m_strValue);
	m_strTxt += strDelta;
}
template <class T>
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const vector<T>& arrValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = [Count=%u]"), szName, arrValue.size());
	m_strTxt += strDelta;
}

int COpCode::ShowSelf(bool bMessageBox /* = true */, int nStyle /* = MB_ICONINFORMATION | MB_OK | MB_TOPMOST */)
{
	CDbgDump stDump;
	stDump.m_strTxt.Format(_T("Opcode ID=%u, Ptr=%08X"), GetID(), this);
	Z_DbgDump(stDump);

	if(bMessageBox)
		return ::MessageBox(NULL, stDump.m_strTxt, _T("Opcode parameters"), nStyle);

	TRACE("%s", stDump.m_strTxt);

	return 0;
}
#endif // OPCODE_SKIP_DBGDUMP


//////////////////////////////////////////////////////////////////////
// All OpCodes
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Constructors

#undef PARAM_SIMPLE_ORD
#define BEGIN_OPCODE(id, name, prot, source)	COpCode_##name::COpCode_##name() {
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)
#define PARAM_BUF(name, type, count)	ZeroMemory(_##name, count * sizeof(type));
#define PARAM_SIMPLE(name, type)
#define PARAM_SIMPLE_ORD(name, type)	_##name = 0;
#define PARAM_TAGS_BEGIN
#define PARAM_TAGS_END
#define PARAM_TAG_STR(name, id)
#define PARAM_TAG_DWORD(name, id)
#define PARAM_NTAG_DWORD(name, id)
#define PARAM_TEXT_TRAILING(name)
#define PARAM_ARRAY(name, type, counter)
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) } COpCode_##msg::CStruct_##name::CStruct_##name() {
#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_SIMPLE_ORD
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END
#define PARAM_SIMPLE_ORD PARAM_SIMPLE

//////////////////////////////////////////////////////////////////////
// Destructors


#define BEGIN_OPCODE(id, name, prot, source)	COpCode_##name::~COpCode_##name() {
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)
#define PARAM_BUF(name, type, count)
#define PARAM_SIMPLE(name, type)
#define PARAM_TAGS_BEGIN
#define PARAM_TAGS_END
#define PARAM_TAG_STR(name, id)
#define PARAM_TAG_DWORD(name, id)
#define PARAM_NTAG_DWORD(name, id)
#define PARAM_TEXT_TRAILING(name)
#define PARAM_ARRAY(name, type, counter)
#define PARAM_COMPLEXARRAY_BEGIN(msg, name)
#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END

//////////////////////////////////////////////////////////////////////
// GetID()

#define BEGIN_OPCODE(id, name, prot, source)	BYTE COpCode_##name::GetID() const { return id;
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)
#define PARAM_BUF(name, type, count)
#define PARAM_SIMPLE(name, type)
#define PARAM_TAGS_BEGIN
#define PARAM_TAGS_END
#define PARAM_TAG_STR(name, id)
#define PARAM_TAG_DWORD(name, id)
#define PARAM_NTAG_DWORD(name, id)
#define PARAM_TEXT_TRAILING(name)
#define PARAM_ARRAY(name, type, counter)
#define PARAM_COMPLEXARRAY_BEGIN(msg, name)
#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END

//////////////////////////////////////////////////////////////////////
// Z_Protocol()

#define BEGIN_OPCODE(id, name, prot, source)	BYTE COpCode_##name::Z_Protocol() const { return OP_PROT_##prot;
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)
#define PARAM_BUF(name, type, count)
#define PARAM_SIMPLE(name, type)
#define PARAM_TAGS_BEGIN
#define PARAM_TAGS_END
#define PARAM_TAG_STR(name, id)
#define PARAM_TAG_DWORD(name, id)
#define PARAM_NTAG_DWORD(name, id)
#define PARAM_TEXT_TRAILING(name)
#define PARAM_ARRAY(name, type, counter)
#define PARAM_COMPLEXARRAY_BEGIN(msg, name)
#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END

//////////////////////////////////////////////////////////////////////
// Z_Dump

#define BEGIN_OPCODE(id, name, prot, source)	void COpCode_##name::Z_Dump(CStream& stStream) const {
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)			stStream << (BYTE) value;
#define PARAM_BUF(name, type, count)	stStream.Write(_##name, count * sizeof(type));
#define PARAM_SIMPLE(name, type)		stStream << _##name;
#define PARAM_TAGS_BEGIN				CTagEntry pTagsInfo[] = { 
#define PARAM_TAGS_END					}; stStream.DumpTags(pTagsInfo, _countof(pTagsInfo));
#define PARAM_TAG_STR(name, id)			(CTag_Pure*) &_##name, OP_TAG_STRING, 1, id,
#define PARAM_TAG_DWORD(name, id)		(CTag_Pure*) &_##name, OP_TAG_DWORD, 1, id,
#define PARAM_NTAG_DWORD(name, id)		(CTag_Pure*) &_##name, OP_TAG_DWORD, sizeof(id) - 1, (DWORD) id,
#define PARAM_TEXT_TRAILING(name)		stStream.DumpString(_##name);
#define PARAM_ARRAY(name, type, counter) stStream.DumpArr(_##name, sizeof(counter));
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) stStream.DumpArr(_##name, sizeof(DWORD)); } template <> void StreamDumpElement(CStream& stStream, const COpCode_##msg::CStruct_##name& stElement) { stElement.Z_Dump(stStream); } void COpCode_##msg::CStruct_##name::Z_Dump(CStream& stStream) const {
#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END

//////////////////////////////////////////////////////////////////////
// Z_Init

#define BEGIN_OPCODE(id, name, prot, source)	void COpCode_##name::Z_Init(CStream& stStream) {
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)			BYTE nJunk; stStream >> nJunk; if (value != nJunk) stStream.Exception();
#define PARAM_BUF(name, type, count)	stStream.Read(_##name, count * sizeof(type));
#define PARAM_SIMPLE(name, type)		stStream >> _##name;
#define PARAM_TAGS_BEGIN				CTagEntry pTagsInfo[] = { 
#define PARAM_TAGS_END					}; stStream.InitTags(pTagsInfo, _countof(pTagsInfo));
#define PARAM_TAG_STR(name, id)			(CTag_Pure*) &_##name, OP_TAG_STRING, 1, id,
#define PARAM_TAG_DWORD(name, id)		(CTag_Pure*) &_##name, OP_TAG_DWORD, 1, id,
#define PARAM_NTAG_DWORD(name, id)		(CTag_Pure*) &_##name, OP_TAG_DWORD, sizeof(id) - 1, (DWORD) id,
#define PARAM_TEXT_TRAILING(name)		stStream.InitTrailingString(_##name);
#define PARAM_ARRAY(name, type, counter) stStream.InitArr(_##name, sizeof(counter));
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) stStream.InitArr(_##name, sizeof(DWORD)); } template <> void StreamInitElement(CStream& stStream, COpCode_##msg::CStruct_##name& stElement) { stElement.Z_Init(stStream); } void COpCode_##msg::CStruct_##name::Z_Init(CStream& stStream) {
#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END

//////////////////////////////////////////////////////////////////////
// Z_DbgDump

#ifndef OPCODE_SKIP_DBGDUMP

#define BEGIN_OPCODE(id, name, prot, source)	void COpCode_##name::Z_DbgDump(CDbgDump& stDump) const { stDump.m_strTxt.Format("%s (%u)  Ptr=%08X  Protocol=%u  Size=%u\n", #name, id, this, OP_PROT_##prot, GetSize(OP_TRANSPORT_UDP));
#define END_OPCODE						}
#define PARAM_BYTE_JUNK(value)
#define PARAM_BUF(name, type, count)	stDump.WriteParam(#name, _##name, count, sizeof(type));
#define PARAM_SIMPLE(name, type)		stDump.WriteParam(#name, _##name);
#define PARAM_TAGS_BEGIN
#define PARAM_TAGS_END
#define PARAM_TAG_STR(name, id)			stDump.WriteParam(#name, _##name);
#define PARAM_TAG_DWORD(name, id)		stDump.WriteParam(#name, _##name);
#define PARAM_NTAG_DWORD(name, id)		stDump.WriteParam(#name, _##name);
#define PARAM_TEXT_TRAILING(name)		stDump.WriteParam(#name, _##name);
#define PARAM_ARRAY(name, type, counter) stDump.WriteParam(#name, _##name);
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) stDump.WriteParam(#name, _##name); } void COpCode_##msg::CStruct_##name::Z_DbgDump(CDbgDump& stDump) const {
#define PARAM_COMPLEXARRAY_END(name)
//#define PARAM_COMPLEXARRAY_BEGIN(msg, name) stStream.InitArr(_##name, sizeof(DWORD)); } template <> void StreamInitElement(CStream& stStream, COpCode_##msg::CStruct_##name& stElement) { stElement.Z_Init(stStream); } void COpCode_##msg::CStruct_##name::Z_Init(CStream& stStream) {
//#define PARAM_COMPLEXARRAY_END(name)

#include "EmMsgs.h"

#undef BEGIN_OPCODE
#undef END_OPCODE
#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END

#endif // OPCODE_SKIP_DBGDUMP

#endif
@


1.11
log
@New engine
@
text
@@


1.10
log
@New sockets
@
text
@d161 1
a161 1
void CStream::DumpArr(const CArray<T, T&>& arrValue, int nCounterLen)
d163 1
a163 1
	int nSize = arrValue.GetSize();
d170 1
a170 1
		StreamDumpElement(*this, arrValue.GetAt(nItem));
d175 1
a175 1
void CStream::InitArr(CArray<T, T&>& arrValue, int nCounterLen)
d181 2
a182 1
	arrValue.SetSize(nSize);
d184 1
a184 1
		StreamInitElement(*this, arrValue.GetAt(nItem));
d514 1
a514 1
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CArray<T, T&>& arrValue)
d517 1
a517 1
	strDelta.Format(_T("\r\n%s = [Count=%u]"), szName, arrValue.GetSize());
@


1.9
log
@New sockets
@
text
@d150 9
d165 1
a165 1
	if (nSize >= (1 << (nCounterLen << 3)))
d170 1
a170 1
		*this << arrValue.GetAt(nItem);
d183 1
a183 1
		*this >> arrValue.GetAt(nItem);
d398 2
d415 2
d512 2
a513 8
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CArray<ADDRPORT, ADDRPORT&>& arrValue)
{
	CString strDelta;
	strDelta.Format(_T("\r\n%s = [Count=%u]"), szName, arrValue.GetSize());
	m_strTxt += strDelta;
}

void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CArray<OFFEREDFILE, OFFEREDFILE&>& arrValue)
a528 1
	AddDebugLogLine(false, stDump.m_strTxt);
d557 2
d575 2
d582 1
d595 2
d612 2
d630 2
d647 2
d665 2
d682 2
d700 2
d717 2
d735 2
d752 2
d772 4
d791 2
@


1.8
log
@New sockets
@
text
@d506 1
a506 1
void COpCode::CDbgDump::WriteParam(LPCTSTR szName, const CArray<HASHADDRPORT, HASHADDRPORT&>& arrValue)
d670 1
a670 1
#define PARAM_TAGS_BEGIN				CStream::CTagEntry pTagsInfo[] = { 
d701 1
a701 1
#define PARAM_TAGS_BEGIN				CStream::CTagEntry pTagsInfo[] = { 
@


1.7
log
@New sockets - more server code
@
text
@d10 1
d16 2
d53 1
d61 1
d71 1
a71 1

d108 1
d150 1
d164 1
d177 1
d242 1
d247 2
d253 2
d260 2
d273 1
d279 2
d286 1
d296 1
d306 1
d326 1
a326 1

d331 1
d370 1
d408 1
d427 1
d434 1
d506 7
d529 1
d532 1
d534 1
d569 1
d600 1
d631 1
d662 1
d693 1
d724 1
d726 1
@


1.6
log
@New sockets. Connecting to server from server list
@
text
@d418 1
a418 1
	TRACE2(_T("Processing opcode=%x, (socket=%u)"), GetID(), pClient ? pClient->m_hSocket : 0);
@


1.5
log
@New sockets - finally, can connect to server and even send/receive some opcodes. To be continued...
@
text
@d420 1
a420 1
	MessageBox();
d479 1
a479 1
int COpCode::MessageBox(int nStyle /* = MB_ICONINFORMATION | MB_OK | MB_TOPMOST */)
d485 7
a491 1
	return ::MessageBox(NULL, stDump.m_strTxt, _T("Opcode parameters"), nStyle);
d685 1
a685 1
#define BEGIN_OPCODE(id, name, prot, source)	void COpCode_##name::Z_DbgDump(CDbgDump& stDump) const { stDump.m_strTxt.Format("%s (%u)\nPtr=%08X\nProtocol=%u\nSize=%u\n----------\n", #name, id, this, OP_PROT_##prot, GetSize(OP_TRANSPORT_UDP));
@


1.4
log
@New sockets update
@
text
@d8 1
d347 1
a347 1
COpCode* COpCode::CreateFromID(BYTE nID)
d349 1
a349 1
	switch (nID)
d352 2
a353 1
		#define BEGIN_OPCODE(id, name, prot)	case OP_CODE_##name: return new COpCode_##name;
d384 1
a384 1
COpCode* COpCode::Read(CStream& stStream, BYTE nID)
d386 1
a386 1
	COpCode* pRet = CreateFromID(nID);
d390 1
a390 1
			stStream.m_bUnicode = (OP_PROT_UNICODE == pRet->Z_Protocol());
d417 6
d427 63
d495 1
a495 1
#define BEGIN_OPCODE(id, name, prot)	COpCode_##name::COpCode_##name() {
d528 1
a528 1
#define BEGIN_OPCODE(id, name, prot)	COpCode_##name::~COpCode_##name() {
d558 1
a558 1
#define BEGIN_OPCODE(id, name, prot)	BYTE COpCode_##name::GetID() const { return id;
d588 1
a588 1
#define BEGIN_OPCODE(id, name, prot)	BYTE COpCode_##name::Z_Protocol() const { return OP_PROT_##prot;
d618 1
a618 1
#define BEGIN_OPCODE(id, name, prot)	void COpCode_##name::Z_Dump(CStream& stStream) const {
d625 3
a627 3
#define PARAM_TAG_STR(name, id)			(CTag*) &_##name, OP_TAG_STRING, 1, id,
#define PARAM_TAG_DWORD(name, id)		(CTag*) &_##name, OP_TAG_DWORD, 1, id,
#define PARAM_NTAG_DWORD(name, id)		(CTag*) &_##name, OP_TAG_DWORD, sizeof(id) - 1, (DWORD) id,
d648 1
a648 1
#define BEGIN_OPCODE(id, name, prot)	void COpCode_##name::Z_Init(CStream& stStream) {
d655 3
a657 3
#define PARAM_TAG_STR(name, id)			(CTag*) &_##name, OP_TAG_STRING, 1, id,
#define PARAM_TAG_DWORD(name, id)		(CTag*) &_##name, OP_TAG_DWORD, 1, id,
#define PARAM_NTAG_DWORD(name, id)		(CTag*) &_##name, OP_TAG_DWORD, sizeof(id) - 1, (DWORD) id,
d679 1
a679 1
#define BEGIN_OPCODE(id, name, prot)	void COpCode_##name::Z_DbgDump(CDbgDump& stDump) const { stDump.m_strTxt.Format("%s (%u)\nPtr=%08X\nProtocol=%u\nSize=%u\n----------\n", #name, id, this, OP_PROT_##prot, GetSize(OP_TRANSPORT_UDP));
@


1.3
log
@Another new sockets cumulative update
@
text
@d11 5
a16 1
	*this << nLen;
d51 1
a51 1
	USHORT nLen;
d53 2
d56 12
d143 25
d240 5
d361 2
d376 2
d423 1
d428 2
a429 1
#define PARAM_SIMPLE(name, type)		_##name = 0;
d435 2
d450 4
d467 2
d482 2
d497 2
d512 2
d527 2
d542 2
d557 2
d572 2
d587 2
d602 35
d638 1
a638 1
#endif@


1.2
log
@Cumulative update. Not working yet.
@
text
@d152 1
a152 1
				((1 == nLen) ? (nTagID == (BYTE) pTags[dwIndex].m_nNameLen) : !memcmp(stTagName.m_pBufUse, (PVOID) pTags[dwIndex].m_dwName, nLen)))
d184 2
a185 1
		pTarget->m_pTag->m_bValid = true;
@


1.1
log
@*** empty log message ***
@
text
@d9 35
a43 3
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
d45 1
a45 1
COpCode::COpCode()
d47 2
d50 32
d84 1
a84 1
COpCode::~COpCode()
d86 13
d100 23
d125 1
a125 1
void CStream::Write_T(const CString& strObj)
d127 59
a185 3
	USHORT nLen = (USHORT) strObj.GetLength();
	Write_T(nLen);
	Write((PCSTR) strObj, nLen);
d188 5
a192 1
void CStream::Read_T(CString& strObj)
d194 1
a194 3
	USHORT nLen = 0;
	Read_T(nLen);
	Read_Str(strObj, nLen);
d196 1
a196 2

void CStream::Read_Str(CString& strObj, USHORT nLen)
d198 2
a199 1
	if (nLen)
d201 5
a205 2
		PSTR szBuf = strObj.GetBuffer(nLen + 1);
		ASSERT(szBuf); // rather throws an exception
d207 8
a214 3
		Read(szBuf, nLen);
		strObj.ReleaseBuffer(nLen);
	} 
d217 1
a217 1
void CStream::Write_T(const CTag& stTag)
d219 5
a223 5
	WriteTag(
		stTag.m_nTagID,
		stTag.m_nTagID ? NULL : &stTag.m_strTagName,
		stTag.m_dwValue,
		stTag.m_bIsString ? &stTag.m_strValue : NULL);
d226 1
a226 1
void CStream::Read_T(CTag& stTag)
d228 5
a232 14
	BYTE nType = 0;
	Read_T(nType);

	USHORT nTagIdLen = 0;
	Read_T(nTagIdLen);
	if (sizeof(stTag.m_nTagID) == nTagIdLen)
		Read_T(stTag.m_nTagID);
	else
		Read_Str(stTag.m_strTagName, nTagIdLen);

	if (stTag.m_bIsString = (2 == nType))
		Read_T(stTag.m_strValue);
	else
		Read_T(stTag.m_dwValue);
d235 1
a235 1
void CStream::WriteTag(BYTE nTagID, const CString* pTagName, DWORD dwValue, const CString* pValue)
d237 8
a244 2
	BYTE nType = pValue ? 2 : 3;
	Write_T(nType);
d246 1
a246 3
	if (pTagName)
		Write_T(*pTagName);
	else
d248 3
a250 3
		USHORT nTagIdLen = sizeof(nTagID);
		Write_T(nTagIdLen);
		Write_T(nTagID);
d252 1
d254 3
a256 4
	if (pValue)
		Write_T(*pValue);
	else
		Write_T(dwValue);
d259 1
a259 1
void COpCode_HELLO_TYPE::Z_Write(CStream& stStream)
d261 24
a284 5
	BYTE nHashSize = sizeof(m_pHash);
	stStream.Write_T(nHashSize);
	stStream.Write_T(m_pHash);
	stStream.Write_T(m_dwClientID);
	stStream.Write_T(m_nPort);
d286 10
a295 2
	DWORD dwTagCount = 3;
	stStream.Write_T(dwTagCount);
d297 4
a300 3
	stStream.WriteTag(CT_NAME, NULL, 0, &m_strNick);
	stStream.WriteTag(CT_VERSION, NULL, m_dwVersion, NULL);
	stStream.WriteTag(CT_PORT, NULL, m_nPort, NULL);
d302 25
a326 2
	stStream.Write_T(m_dwServerIp);
	stStream.Write_T(m_nServerPort);
d329 1
a329 1
void COpCode_HELLO_TYPE::Z_Read(CStream& stStream)
d331 12
a342 4
	BYTE nHashSize = 0;
	stStream.Read_T(nHashSize);
	if (sizeof(m_pHash) != nHashSize)
		CStream::CException::Throw();
d344 2
a345 3
	stStream.Read_T(m_pHash);
	stStream.Read_T(m_dwClientID);
	stStream.Read_T(m_nPort);
d347 5
a351 2
	DWORD dwTagCount = 0;
	stStream.Read_T(dwTagCount);
d353 4
a356 1
	while (dwTagCount--)
d358 6
a363 2
		CTag stTag;
		stStream.Read_T(stTag);
d365 4
a368 16
		switch (stTag.m_nTagID)
		{
		case CT_NAME:
			if (stTag.m_bIsString)
				m_strNick = stTag.m_strValue;
			break;
		case CT_VERSION:
			if (!stTag.m_bIsString)
				m_dwVersion = stTag.m_dwValue;
			break;
		case CT_PORT:
//			if (!stTag.m_bIsString)
//				m_nPort = (USHORT) stTag.m_dwValue;
			break;
		}
	}
d370 153
a522 3
	stStream.Read_T(m_dwServerIp);
	stStream.Read_T(m_nServerPort);
}
@

