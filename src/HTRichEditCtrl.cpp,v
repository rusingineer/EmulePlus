head	1.111;
access;
symbols
	PublicRelease_1_2e:1.111
	Interim_Release_1-2e_RC1:1.111
	PublicRelease_1_2d:1.109
	Interim_Release_1-2d_RC1:1.109
	Interim_Release_1-2d_beta1:1.102
	PublicRelease_1_2c:1.98
	Interim_Release_1-2c_RC1:1.98
	Interim_Release_1-2c_beta1:1.96
	PublicRelease_1_2b:1.95
	Interim_Release_1-2b_RC1:1.94
	PublicRelease_1_2a:1.94
	Interim_Release_1-2a_RC1:1.94
	Interim_Release_1-2a_beta2:1.92
	Interim_Release_1-2a_beta1:1.92
	PublicRelease_1_2:1.91
	Interim_Release_1-2_RC1:1.91
	Interim_Release_1-2_beta1:1.91
	PublicRelease_1_1g:1.91
	Interim_Release_1-1g_RC3:1.91
	Interim_Release_1-1g_RC2:1.91
	Interim_Release_1-1g_RC1:1.91
	Interim_Release_1-1g_beta2:1.89
	Interim_Release_1-1g_beta1:1.89
	PublicRelease_1_1f:1.89
	Interim_Release_1-1f_RC1:1.89
	PublicRelease_1_1e:1.89
	Interim_Release_1-1e_RC2:1.89
	Interim_Release_1-1e_RC1:1.89
	Interim_Release_1-1e_beta1:1.89
	PublicRelease_1_1d:1.89
	Interim_Release_1-1d_RC1:1.89
	PublicRelease_1_1c:1.89
	Interim_Release_1-1c_RC1:1.89
	Interim_Release_1-1c_beta2:1.89
	Interim_Release_1-1c_beta1:1.89
	PublicRelease_1_1b:1.89
	Interim_Release_1-1b_RC1:1.89
	PublicRelease_1_1a:1.89
	Interim_Release_1-1a_RC2:1.89
	Interim_Release_1-1a_RC1:1.89
	Interim_Release_1-1a_beta2:1.89
	Interim_Release_1-1a_beta1:1.89
	PublicRelease_1_1:1.89
	Interim_Release_1-1_beta1:1.89
	PublicRelease_1o:1.89
	Interim_Release_1o_RC1:1.89
	Interim_Release_1o_beta1:1.89
	PublicRelease_1n:1.89
	Interim_Release_1n_RC2:1.89
	Interim_Release_1n_RC1:1.89
	Interim_Release_1n_beta2:1.89
	Interim_Release_1n_beta1:1.78
	PublicRelease_1m:1.68
	Interim_Release_1m_beta1:1.65
	PublicRelease_1l:1.58
	Interim_Release_1l_RC3:1.57
	Interim_Release_1l_RC2:1.56
	Interim_Release_1l_RC1:1.55
	Interim_Release_1l_beta2:1.52
	Interim_Release_1l_beta1:1.51
	PublicRelease_1k:1.47
	Interim_Release_1k_RC4:1.47
	Interim_1k_RC3:1.47
	Interim_1k_RC2:1.47
	Interim_Release_1k_RC1:1.47
	Interim_Release_1k_beta5:1.47
	Intrerim_Release_1k_beta4:1.47
	Interim_Release_1k_beta1:1.44
	PublicRelease_1j:1.39
	Interim_Release_1J_RC3:1.37
	Interim_Release_1j_RC3:1.37
	Interim_Release_1j_RC2:1.33
	Interim_Release_1j_RC1:1.32
	Interim_Release_1j_beta2:1.32
	Interim_Release_1j_beta1:1.22
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1;
locks; strict;
comment	@// @;


1.111
date	2008.12.15.22.39.52;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2008.07.31.12.05.17;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2008.04.15.04.25.37;	author aw3;	state Exp;
branches;
next	1.108;

1.108
date	2008.03.19.09.25.16;	author eklmn;	state Exp;
branches;
next	1.107;

1.107
date	2008.03.09.14.27.14;	author eklmn;	state Exp;
branches;
next	1.106;

1.106
date	2008.03.08.05.10.49;	author aw3;	state Exp;
branches;
next	1.105;

1.105
date	2008.03.05.21.46.15;	author eklmn;	state Exp;
branches;
next	1.104;

1.104
date	2008.03.02.14.14.19;	author aw3;	state Exp;
branches;
next	1.103;

1.103
date	2008.02.28.19.46.05;	author eklmn;	state Exp;
branches;
next	1.102;

1.102
date	2008.01.24.09.51.37;	author eklmn;	state Exp;
branches;
next	1.101;

1.101
date	2008.01.23.05.12.43;	author aw3;	state Exp;
branches;
next	1.100;

1.100
date	2008.01.17.22.02.50;	author eklmn;	state Exp;
branches;
next	1.99;

1.99
date	2007.12.12.20.15.31;	author eklmn;	state Exp;
branches;
next	1.98;

1.98
date	2007.07.29.04.14.24;	author aw3;	state Exp;
branches;
next	1.97;

1.97
date	2007.07.27.06.21.19;	author aw3;	state Exp;
branches;
next	1.96;

1.96
date	2007.02.18.05.30.28;	author aw3;	state Exp;
branches;
next	1.95;

1.95
date	2007.02.04.11.00.12;	author kush_eplus;	state Exp;
branches;
next	1.94;

1.94
date	2006.08.27.17.42.44;	author aw3;	state Exp;
branches;
next	1.93;

1.93
date	2006.07.25.04.28.51;	author aw3;	state Exp;
branches;
next	1.92;

1.92
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.91;

1.91
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.90;

1.90
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.89;

1.89
date	2004.07.29.14.02.32;	author katsyonak;	state Exp;
branches;
next	1.88;

1.88
date	2004.07.29.02.13.01;	author katsyonak;	state Exp;
branches;
next	1.87;

1.87
date	2004.07.28.04.12.00;	author aw3;	state Exp;
branches;
next	1.86;

1.86
date	2004.07.27.17.38.16;	author katsyonak;	state Exp;
branches;
next	1.85;

1.85
date	2004.07.27.11.14.40;	author katsyonak;	state Exp;
branches;
next	1.84;

1.84
date	2004.07.26.02.29.42;	author katsyonak;	state Exp;
branches;
next	1.83;

1.83
date	2004.07.26.00.54.55;	author katsyonak;	state Exp;
branches;
next	1.82;

1.82
date	2004.07.25.23.10.00;	author katsyonak;	state Exp;
branches;
next	1.81;

1.81
date	2004.07.25.15.35.47;	author katsyonak;	state Exp;
branches;
next	1.80;

1.80
date	2004.07.25.15.15.47;	author katsyonak;	state Exp;
branches;
next	1.79;

1.79
date	2004.07.25.11.50.14;	author katsyonak;	state Exp;
branches;
next	1.78;

1.78
date	2004.07.18.17.37.25;	author katsyonak;	state Exp;
branches;
next	1.77;

1.77
date	2004.07.17.15.37.49;	author aw3;	state Exp;
branches;
next	1.76;

1.76
date	2004.07.17.09.16.00;	author eklmn;	state Exp;
branches;
next	1.75;

1.75
date	2004.07.17.03.52.53;	author aw3;	state Exp;
branches;
next	1.74;

1.74
date	2004.07.15.09.59.16;	author katsyonak;	state Exp;
branches;
next	1.73;

1.73
date	2004.07.13.15.10.39;	author katsyonak;	state Exp;
branches;
next	1.72;

1.72
date	2004.07.11.16.24.58;	author katsyonak;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.07.14.28.36;	author katsyonak;	state Exp;
branches;
next	1.70;

1.70
date	2004.07.07.10.17.26;	author katsyonak;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.28.02.31.29;	author katsyonak;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.23.21.10.47;	author katsyonak;	state Exp;
branches;
next	1.67;

1.67
date	2004.06.23.04.59.34;	author katsyonak;	state Exp;
branches;
next	1.66;

1.66
date	2004.06.22.17.04.03;	author katsyonak;	state Exp;
branches;
next	1.65;

1.65
date	2004.06.21.13.41.14;	author katsyonak;	state Exp;
branches;
next	1.64;

1.64
date	2004.06.21.12.28.43;	author katsyonak;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.20.20.59.38;	author katsyonak;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.20.19.15.24;	author katsyonak;	state Exp;
branches;
next	1.61;

1.61
date	2004.06.15.23.13.58;	author katsyonak;	state Exp;
branches;
next	1.60;

1.60
date	2004.06.15.21.12.20;	author katsyonak;	state Exp;
branches;
next	1.59;

1.59
date	2004.06.15.05.05.47;	author katsyonak;	state Exp;
branches;
next	1.58;

1.58
date	2004.06.09.20.24.50;	author katsyonak;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.04.13.29.40;	author katsyonak;	state Exp;
branches;
next	1.56;

1.56
date	2004.06.02.15.07.13;	author katsyonak;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.25.13.11.46;	author katsyonak;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.23.22.16.53;	author katsyonak;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.23.15.00.05;	author katsyonak;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.16.21.37.30;	author katsyonak;	state Exp;
branches;
next	1.51;

1.51
date	2004.05.05.01.17.20;	author katsyonak;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.30.09.06.12;	author katsyonak;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.18.16.16.22;	author katsyonak;	state Exp;
branches;
next	1.48;

1.48
date	2004.04.13.01.01.35;	author katsyonak;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.13.05.33.36;	author aw3;	state Exp;
branches;
next	1.45;

1.45
date	2004.03.03.15.22.58;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.11.04.13.00;	author katsyonak;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.10.01.06.24;	author katsyonak;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.08.11.35.17;	author katsyonak;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.04.23.59.59;	author kush_eplus;	state Exp;
branches;
next	1.40;

1.40
date	2004.02.04.21.56.49;	author katsyonak;	state Exp;
branches;
next	1.39;

1.39
date	2004.01.26.01.30.19;	author kush_eplus;	state Exp;
branches;
next	1.38;

1.38
date	2004.01.26.00.25.23;	author kush_eplus;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.15.00.47.43;	author katsyonak;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.14.08.58.47;	author katsyonak;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.13.22.11.13;	author katsyonak;	state Exp;
branches;
next	1.34;

1.34
date	2004.01.13.20.33.37;	author katsyonak;	state Exp;
branches;
next	1.33;

1.33
date	2004.01.12.10.40.08;	author katsyonak;	state Exp;
branches;
next	1.32;

1.32
date	2004.01.07.14.40.42;	author katsyonak;	state Exp;
branches;
next	1.31;

1.31
date	2004.01.06.13.11.50;	author katsyonak;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.05.20.26.56;	author katsyonak;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.05.13.18.24;	author katsyonak;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.05.11.19.55;	author katsyonak;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.05.08.09.11;	author katsyonak;	state Exp;
branches;
next	1.26;

1.26
date	2004.01.04.11.44.40;	author katsyonak;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.31.12.17.26;	author katsyonak;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.31.07.04.15;	author katsyonak;	state Exp;
branches;
next	1.23;

1.23
date	2003.12.30.17.44.39;	author katsyonak;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.28.14.25.30;	author katsyonak;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.28.12.46.54;	author katsyonak;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.27.11.26.50;	author katsyonak;	state Exp;
branches;
next	1.19;

1.19
date	2003.12.25.08.06.24;	author katsyonak;	state Exp;
branches;
next	1.18;

1.18
date	2003.12.25.05.16.54;	author katsyonak;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.25.02.51.47;	author katsyonak;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.23.23.41.12;	author katsyonak;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.23.12.05.02;	author katsyonak;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.22.22.41.31;	author katsyonak;	state Exp;
branches;
next	1.13;

1.13
date	2003.12.22.18.28.27;	author katsyonak;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.22.02.37.35;	author katsyonak;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.22.00.18.46;	author katsyonak;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.21.15.15.20;	author katsyonak;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.21.14.24.33;	author katsyonak;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.20.21.45.22;	author katsyonak;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.20.21.27.36;	author katsyonak;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.19.11.05.30;	author katsyonak;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.18.13.35.30;	author katsyonak;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.19.14.51.33;	author katsyonak;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.18.01.05.56;	author katsyonak;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.11.16.06.12;	author katsyonak;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.29.17.24.23;	author katsyonak;	state Exp;
branches;
next	;


desc
@@


1.111
log
@Fixed link highlighting for long IRC links {Paola} (only the first line was identified as a link for links broken in several lines);
Fixed link highlighting in logs and chats (Unicode migration issue);
Optimized link identification and output to RichEdit controls (logs, chats, IRC).
@
text
@//this file is part of eMule
//Copyright (C)2002-2007 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

//	NOTE: MSLU & RichEditCtrl
//	If you have a RichEdit control supporting Unicode (using the RichEd20W class name)
//	and you attempt to use the GetWindowTextW API or the WM_GETTEXT message to retrieve
//	the text it contains, the text will be garbled. A fix is not currently under consideration
//	because the EM_GETTEXTEX message is available and will work properly, and it will not convert
//	the text via the default system codepage the way that MSLU would for WM_GETTEXT or GetWindowTextW.
//	(see http://www.trigeminal.com/usenet/usenet035.asp?01000000)

#include "stdafx.h"
#include "eMule.h"
#include "HTRichEditCtrl.h"
#include "TitleMenu.h"
#include "otherfunctions.h"
#include <share.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

LinkDetect_Table _apszSchemes[LINKDETECT_TABLESZ] =
{
	{ _T("ed2k://"), CSTRLEN(_T("ed2k://")) },
	{ _T("ftp."), CSTRLEN(_T("ftp.")) },
	{ _T("ftp://"), CSTRLEN(_T("ftp://")) },
	{ _T("http://"), CSTRLEN(_T("http://")) },
	{ _T("https://"), CSTRLEN(_T("https://")) },
	{ _T("mailto:"), CSTRLEN(_T("mailto:")) },
	{ _T("www."), CSTRLEN(_T("www.")) },
	{ _T("www1."), CSTRLEN(_T("www1.")) },
	{ _T("www2."), CSTRLEN(_T("www2.")) },
	{ _T("www3."), CSTRLEN(_T("www3.")) },
	{ _T("www4."), CSTRLEN(_T("www4.")) },
	{ _T("www5."), CSTRLEN(_T("www5.")) }
};

IMPLEMENT_DYNAMIC(CHTRichEditCtrl, CRichEditCtrl)

BEGIN_MESSAGE_MAP(CHTRichEditCtrl, CRichEditCtrl)
	ON_WM_CONTEXTMENU()
	ON_WM_LBUTTONDOWN()
	ON_WM_SETCURSOR()
	ON_WM_KEYDOWN()
	ON_NOTIFY_REFLECT_EX(EN_LINK, OnEnLink)
	ON_WM_CREATE()
END_MESSAGE_MAP()

CHTRichEditCtrl::CHTRichEditCtrl() : m_strTitle(_T("")), m_strURL(_T(""))
{
	m_dwFlags = HTC_ISAUTOSCROLL | HTC_ISDEFAULTLINKS;
	m_crDefaultForeground = GetSysColor(COLOR_WINDOWTEXT);
	m_crDefaultBackground = GetSysColor(COLOR_WINDOW);

	if (g_App.m_pPrefs->GetWindowsVersion() == _WINVER_95_)
		m_lMaxBufSize = 64 * 1024 - 1;
	else
		m_lMaxBufSize = 128 * 1024;
	m_hArrowCursor = ::LoadCursor(NULL, IDC_ARROW);
}

CHTRichEditCtrl::~CHTRichEditCtrl()
{
	//	Shared cursors mustn't be destroyed
}

void CHTRichEditCtrl::SetTitle(LPCTSTR pszTitle)
{
	m_strTitle = g_App.StripInvalidFilenameChars(pszTitle);
}

int CHTRichEditCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CRichEditCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;

	VERIFY( SendMessage(EM_SETUNDOLIMIT, 0, 0) == 0 );

#ifdef _UNICODE
//	Win9x: Explicitly set to Unicode to receive Unicode notifications.
	SendMessage(CCM_SETUNICODEFORMAT, TRUE);
#endif

	LimitText(m_lMaxBufSize);
	SetTargetDevice(NULL, (m_dwFlags & HTC_ISWORDWRAP) == 0);	// 1: off, 0: on word wrap
	SetEventMask(GetEventMask() | ENM_LINK);

	return 0;
}

void CHTRichEditCtrl::AppendText(const CString &strMsg, COLORREF crTextColor/*=CLR_DEFAULT*/, COLORREF crBackColor/*=CLR_DEFAULT*/, DWORD dwFlags/*=0*/)
{
	AppendText(strMsg.GetString(), strMsg.GetLength(), crTextColor, crBackColor, dwFlags);
}

void CHTRichEditCtrl::AppendText(LPCTSTR pszMsg, int iMsgLen, COLORREF crTextColor/*=CLR_DEFAULT*/, COLORREF crBackColor/*=CLR_DEFAULT*/, DWORD dwFlags/*=0*/)
{
//	When actual length is passed, the string has to be zero terminated right after it
	if (iMsgLen < 0)
		iMsgLen = _tcslen(pszMsg);

	if (iMsgLen == 0 || !::IsWindow(m_hWnd))
		return;

	long		lStartChar, lEndChar, lTextEnd = GetTextLengthEx(GTL_PRECISE | GTL_NUMCHARS);

	GetSel(lStartChar, lEndChar);

	BOOL			bIsVisible = IsWindowVisible();
	bool			bIsEndSel = (lStartChar == lEndChar && lStartChar == lTextEnd);
	CHARFORMAT2		cf2;
	POINT			ptOldPos;

	if (bIsVisible)
		SetRedraw(false);

	if (lTextEnd >= m_lMaxBufSize)
	{
		int iLineStart = LineIndex(LineFromChar(m_lMaxBufSize >> 3));

		SetSel(0, iLineStart);
		ReplaceSel(_T(""));
	}
	SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptOldPos);
	SetSel(-1, -1);
	memzero(&cf2, sizeof(cf2));
	cf2.cbSize = sizeof(cf2);
	GetSelectionCharFormat(cf2);
	cf2.crTextColor = (crTextColor == CLR_DEFAULT) ? m_crDefaultForeground : crTextColor;
	cf2.crBackColor = (crBackColor == CLR_DEFAULT) ? m_crDefaultBackground : crBackColor;
	cf2.dwEffects &= ~(CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR | CFE_BOLD | CFE_ITALIC | CFE_LINK | CFE_STRIKEOUT | CFE_UNDERLINE);
	cf2.dwEffects |= (dwFlags & HTC_BOLD) ? CFE_BOLD : 0;
	cf2.dwEffects |= (dwFlags & HTC_ITALIC) ? CFE_ITALIC : 0;
	cf2.dwEffects |= (dwFlags & HTC_LINK) ? CFE_LINK : 0;
	cf2.dwEffects |= (dwFlags & HTC_STRIKEOUT) ? CFE_STRIKEOUT : 0;
	cf2.dwEffects |= (dwFlags & HTC_UNDERLINE) ? CFE_UNDERLINE : 0;
	SetSelectionCharFormat(cf2);
	ReplaceSel(pszMsg);

	if ((dwFlags & (HTC_LINK | HTC_HAVENOLINK)) == 0 && (m_dwFlags & HTC_ISDEFAULTLINKS) != 0)
	{
		CString		strLine(pszMsg, iMsgLen);
		int			iIndex = 0, iScheme, iLen, iLinkEnd, iLnkIdx;
		const TCHAR	*pcLine, *pcTmp, *pcLink;

		lTextEnd = GetTextLengthEx(GTL_PRECISE | GTL_NUMCHARS, 1200/*Unicode CodePage*/) - iMsgLen;
		cf2.dwEffects |= CFE_LINK;

		//	Convert string to lower case only once
		strLine.MakeLower();
		pcLine = strLine.GetString();
		while (iMsgLen > iIndex)
		{
			pcLink = reinterpret_cast<const TCHAR*>(~0);
			for (iScheme = 0, iLnkIdx = -1; iScheme < ARRSIZE(_apszSchemes); iScheme++)
			{
				iLen = _apszSchemes[iScheme].uiLen;
				iLinkEnd = iIndex + iLen;

				if (iMsgLen <= iLinkEnd)
					continue;
				pcTmp = _tcsstr(pcLine + iIndex, _apszSchemes[iScheme].pszScheme);
			//	Choose a link closest to the beginning of the string
				if ((pcTmp != NULL) && (pcTmp < pcLink))
				{
					pcLink = pcTmp;
					iLnkIdx = iScheme;
				}
			}
			if (iLnkIdx < 0)	//no links were found
				break;
			iLen = _apszSchemes[iLnkIdx].uiLen;
			iIndex = pcLink - pcLine;
			iLinkEnd = iIndex + iLen;

		//	Find the first occurence of any following character
			pcTmp = _tcspbrk(pcLine + iLinkEnd, _T(" \n\\\r\t"));
			iLinkEnd = (pcTmp == NULL) ? iMsgLen : (pcTmp - pcLine);

			while ((iLinkEnd > iIndex + iLen) && 
				!((pcLine[iLinkEnd - 1] >= _T('/') && pcLine[iLinkEnd - 1] <= _T('9'))
				||(pcLine[iLinkEnd - 1] >= _T('a') && pcLine[iLinkEnd - 1] <= _T('z'))
				|| (pcLine[iLinkEnd - 1] == _T('|'))))
			{
				iLinkEnd--;
			}

			if (iLinkEnd > iIndex + iLen)
			{
				SetSel(lTextEnd + iIndex, lTextEnd + iLinkEnd);
				SetSelectionCharFormat(cf2);
				iIndex = iLinkEnd;
			}
			else
				iIndex += iLen;
		}
	}

	if (bIsEndSel)
		SetSel(-1, -1);
	else
		SetSel(lStartChar, lEndChar);

	if ((m_dwFlags & HTC_ISAUTOSCROLL) != 0 && (_tcschr(pszMsg, _T('\n')) != NULL))
	{
		ScrollToLastLine();

		POINT			ptNewPos;

		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptNewPos);
		ptOldPos.y = ptNewPos.y;
	}

	if ((m_dwFlags & HTC_ISWORDWRAP) != 0)
		ptOldPos.x = 0;

	SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptOldPos);

	if (bIsVisible)
	{
		SetRedraw();
		Invalidate();
	}
}

void CHTRichEditCtrl::ScrollToLastLine()
{
	long		lFirstVisible = GetFirstVisibleLine();

	if (lFirstVisible > 0)
		LineScroll(-lFirstVisible, 0);

	// WM_VSCROLL does not work correctly under Win98 (or older versions of comctl.dll)
	SendMessage(WM_VSCROLL, SB_BOTTOM);
	SendMessage(WM_VSCROLL, SB_LINEUP);
	if (g_App.m_pPrefs->GetWindowsVersion() == _WINVER_95_)
	{
		// older versions of comctl.dll seem to need this to properly update the display
		SendMessage(WM_VSCROLL, MAKELONG(SB_THUMBPOSITION, GetScrollPos(SB_VERT)));
		SendMessage(WM_VSCROLL, SB_ENDSCROLL);
	}
}

void CHTRichEditCtrl::Reset()
{
	SetRedraw(false);
	SetWindowText(_T(""));
	SetRedraw();
	Invalidate();
}

void CHTRichEditCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	long			lSelStart, lSelEnd;
	CTitleMenu		menuLog;
	NOPRM(pWnd);

	GetSel(lSelStart, lSelEnd);
	m_dwFlags |= HTC_ISARROWCURSOR;
	menuLog.CreatePopupMenu();
	if ((m_dwFlags & HTC_ISLIMITED) == 0)
		menuLog.AddMenuTitle(GetResString(IDS_LOGENTRY));
	menuLog.AppendMenu(MF_STRING | ((lSelEnd > lSelStart) ? MF_ENABLED : MF_GRAYED), MP_COPYSELECTED, GetResString(IDS_COPY));

	UINT			dwFlags = MF_STRING | ((GetWindowTextLength() > 0) ? MF_ENABLED : MF_GRAYED);
	CString			strBuffer = GetResString(IDS_SAVETOFILE);

	if ((m_dwFlags & HTC_ISLIMITED) == 0)
	{
		menuLog.AppendMenu(dwFlags, MP_SAVELOG, strBuffer + _T(" (.log)"));
		menuLog.AppendMenu(dwFlags, MP_SAVERTF, strBuffer + _T(" (.rtf)"));
	}
	menuLog.AppendMenu(MF_SEPARATOR);
	menuLog.AppendMenu(dwFlags, MP_SELECTALL, GetResString(IDS_SELECTALL));

	if ((m_dwFlags & HTC_ISLIMITED) == 0)
	{
		menuLog.AppendMenu(dwFlags, MP_REMOVEALL, GetResString(IDS_PW_RESET));
		menuLog.AppendMenu(MF_SEPARATOR);
		menuLog.AppendMenu(MF_STRING | ((m_dwFlags & HTC_ISAUTOSCROLL) != 0 ? MF_CHECKED : MF_UNCHECKED), MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
		menuLog.AppendMenu(MF_STRING | ((m_dwFlags & HTC_ISWORDWRAP) != 0 ? MF_CHECKED : MF_UNCHECKED), MP_WORDWRAP, GetResString(IDS_WORDWRAP));
	}

	menuLog.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);
	m_dwFlags &= ~HTC_ISARROWCURSOR;
}

BOOL CHTRichEditCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	NOPRM(lParam);

	switch (wParam)
	{
		case MP_COPYSELECTED:
			Copy();
			break;
		case MP_SAVELOG:
			SaveLogToDisk();
			break;
		case MP_SAVERTF:
			SaveRtfToDisk();
			break;
		case MP_SELECTALL:
			SetSel(0, -1);
			break;
		case MP_REMOVEALL:
			Reset();
			break;
		case MP_AUTOSCROLL:
			m_dwFlags ^= HTC_ISAUTOSCROLL;
			break;
		case MP_WORDWRAP:
			m_dwFlags ^= HTC_ISWORDWRAP;
			SetTargetDevice(NULL, (m_dwFlags & HTC_ISWORDWRAP) == 0);	// 1: off, 0: on word wrap
			break;
	}
	return true;
}

BOOL CHTRichEditCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	if ((m_dwFlags & HTC_ISARROWCURSOR) != 0)
	{
		::SetCursor(m_hArrowCursor);
		return true;
	}

	return CRichEditCtrl::OnSetCursor(pWnd, nHitTest, message);
}

void CHTRichEditCtrl::GetLastLogEntry(CString *pstrOut)
{
	int		iLastLine = GetLineCount() - 2;

	if (iLastLine >= 0)
	{
		pstrOut->ReleaseBufferSetLength(GetLine(iLastLine, pstrOut->GetBuffer(1024), 1024));
		pstrOut->TrimRight(_T("\r\n"));
	}
	else
		pstrOut->Truncate(0);
}

void CHTRichEditCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	if (GetKeyState(VK_CONTROL) & 0x8000)
	{
		if (nChar == _T('A'))
			//////////////////////////////////////////////////////////////////
			// Ctrl+A: Select all items
			SetSel(0, -1);
		else if (nChar == _T('C'))
			//////////////////////////////////////////////////////////////////
			// Ctrl+C: Copy listview items to clipboard
			Copy();
	}
	else if (nChar == VK_ESCAPE)
		return;	// don't minimize CHTRichEditCtrl

	CRichEditCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}

BOOL CHTRichEditCtrl::OnEnLink(NMHDR *pNMHDR, LRESULT *pResult)
{
	bool	bHandled = false;
	ENLINK	*pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);

	if ((pEnLink != NULL) && (pEnLink->msg == WM_LBUTTONDOWN))
	{
		CString		strURL;

		GetTextRange(pEnLink->chrg.cpMin, pEnLink->chrg.cpMax, strURL);

		for (int iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
		{
			if (_tcsnicmp(strURL.GetString(), _apszSchemes[iScheme].pszScheme, _apszSchemes[iScheme].uiLen) == 0)
			{
				ShellExecute(NULL, NULL, strURL, NULL, NULL, SW_SHOWDEFAULT);
				bHandled = true;
				break;
			}
		}
	}

	*pResult = bHandled;
	return bHandled;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHTRichEditCtrl::SaveLogToDisk()
{
	static const TCHAR *s_apcExtension = _T(".log");
	CString			strLog, strTemp;

	if (DialogBrowseFile(strTemp, _T("Log (*.log)|*.log||"), m_strTitle + s_apcExtension, 0, false, g_App.m_pPrefs->GetAppDir()))
	{
		if (strTemp.Right(4) != s_apcExtension)
			strTemp.Append(s_apcExtension);

		FILE	*pLogFile = _tfsopen(strTemp, _T("wb"), _SH_DENYWR);

		if (pLogFile != NULL)
		{
			EDITSTREAM		es;

			es.dwCookie = (DWORD)&strLog;
#ifdef _UNICODE
			es.pfnCallback = MEditStreamOutCallbackW;
			StreamOut(SF_UNICODE | SF_TEXT, es);
			fputwc(0xFEFF, pLogFile);
#else
			es.pfnCallback = MEditStreamOutCallbackA;
			StreamOut(SF_TEXT, es);
#endif
			fwrite(strLog, sizeof(TCHAR), strLog.GetLength(), pLogFile);
			fclose(pLogFile);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHTRichEditCtrl::SaveRtfToDisk()
{
	static const TCHAR *s_apcExtension = _T(".rtf");
	CString			strTemp;

	if (DialogBrowseFile(strTemp, _T("Rich Text Format (RTF)|*.rtf||"), m_strTitle + s_apcExtension, 0, false, g_App.m_pPrefs->GetAppDir()))
	{
		if (strTemp.Right(4) != s_apcExtension)
			strTemp.Append(s_apcExtension);

		FILE	*pRtfFile = _tfsopen(strTemp, _T("wb"), _SH_DENYWR);

		if (pRtfFile != NULL)
		{
			EDITSTREAM		es;
			CStringA			strRTF;

			es.dwCookie = (DWORD)&strRTF;
			es.pfnCallback = MEditStreamOutCallbackA;
			StreamOut(SF_RTF, es);
			fwrite(strRTF.GetString(), strRTF.GetLength(), 1, pRtfFile);
			fclose(pRtfFile);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CHTRichEditCtrl::GetHtml()
{
	CStringA		strRtfUtf8;
	CString			strTemp, strText;
	EDITSTREAM		es;

	es.dwCookie = (DWORD)&strRtfUtf8;
	es.pfnCallback = MEditStreamOutCallbackA;
	StreamOut((CP_UTF8 << 16) | SF_USECODEPAGE | SF_RTF, es);
	MB2Str(cfUTF8, &strTemp, strRtfUtf8);

	strTemp.Replace(_T("&"), _T("&amp;"));
	strTemp.Replace(_T("<"), _T("&lt;"));
	strTemp.Replace(_T(">"), _T("&gt;"));
	strTemp.Replace(_T("\""), _T("&quot;"));
	strTemp.Replace(_T("\\\'"), _T(" \\\'"));

	int				iTableStart = strTemp.Find(_T("\n{\\colortbl ;"));
	int				iTableEnd = strTemp.Find(_T(";}"), iTableStart + 1);

	if ((iTableStart != -1) && (iTableEnd != -1))
	{
		CStringArray	astrColorsRtf, astrColorsHtml;
		int				iRtfColor = 0, iColorEnd;
		long			lHtmlColor = 0;
		CString			strColor;

		while ((iTableStart < iTableEnd) && (iTableStart != -1))
		{
			iTableStart = strTemp.Find(_T("\\red"), iTableStart + 1);
			strColor.Format(_T("\\cf%i"), iRtfColor);
			astrColorsRtf.Add(strColor);
			strColor.Format(_T(" </font><font color=\"#%06x\">"), lHtmlColor);
			astrColorsHtml.Add(strColor);
			iRtfColor++;
			if (iTableStart >= 0)
			{
				iColorEnd = strTemp.Find(_T('\\'), iTableStart + 1);
				if (iColorEnd >= 0)
				{
					lHtmlColor = (_tstoi(strTemp.Mid(iTableStart + 4, iColorEnd - (iTableStart + 4))) << 16);
					iTableStart = iColorEnd + 6;
					iColorEnd = strTemp.Find(_T('\\'), iTableStart + 1);
					if (iColorEnd >= 0)
					{
						lHtmlColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 8);
						iTableStart = iColorEnd + 5;
						iColorEnd = strTemp.Find(_T(';'), iTableStart + 1);
						if (iColorEnd >= 0)
							lHtmlColor += _tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart));
					}
				}
			}
		}
		for (int i = 0; i < astrColorsRtf.GetSize(); i++)
		{
			strTemp.Replace(astrColorsRtf[i] + _T(" \\\'"), astrColorsHtml[i] + _T(" \\\'"));
			strTemp.Replace(astrColorsRtf[i] + _T(' '), astrColorsHtml[i]);
			strTemp.Replace(astrColorsRtf[i] + _T('\\'), astrColorsHtml[i] + _T('\\'));
		}

		LPCTSTR			psz = strTemp.GetString();

		psz += strTemp.Find(_T('\\'), iTableEnd);

		LPCTSTR			pszStart = psz;
		TCHAR			strChar[2];
		long			lLen;

		while (*psz != _T('\0'))
		{
			if (*psz == _T('\\'))
			{
				if (*(psz + 1) == _T('\\'))
				{
					strText.Append(pszStart, 1 + psz - pszStart);
					psz += 2;
				}
				else if (*(psz + 1) == _T('\''))
				{
					if ((psz - pszStart) > 0)
						strText.Append(pszStart, psz - pszStart - 1);

					strChar[0] = *(psz + 2);
					strChar[1] = *(psz + 3);
					strText += (TCHAR)_tcstol(strChar, NULL, 16);
					psz += 4;
				}
				else
				{
					if ((psz - pszStart) > 0)
						strText.Append(pszStart, psz - pszStart);

					lLen = _tcscspn(psz, _T(" \n"));
					if (lLen == 0)
						psz += _tcslen(psz);
					else
					{
						psz += lLen;
						if (*psz == _T(' '))
							psz++;
					}
				}
				pszStart = psz;
			}
			else
				psz++;
		}
		if (pszStart != psz)
			strText += pszStart;
	}

	iTableEnd = strText.ReverseFind(_T('}'));
	if (iTableEnd != -1)
		strText.Truncate(iTableEnd);
	strText.TrimRight(_T('\n'));
	strText.Replace(_T(" </font><font color"), _T("</font><font color"));

	return strText;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CHTRichEditCtrl::GetToolTip()
{
	CStringA		strRtfUtf8;
	CString			strTemp, strText;
	EDITSTREAM		es;

	es.dwCookie = (DWORD)&strRtfUtf8;
	es.pfnCallback = MEditStreamOutCallbackA;
	StreamOut((CP_UTF8 << 16) | SF_USECODEPAGE | SF_RTF, es);
	MB2Str(cfUTF8, &strTemp, strRtfUtf8);

	strTemp.Replace(_T("<"), _T("<<"));
	strTemp.Replace(_T("\\\'"), _T(" \\\'"));

	int				iTableStart = strTemp.Find(_T("\n{\\colortbl ;"));
	int				iTableEnd = strTemp.Find(_T(";}"), iTableStart + 1);

	if ((iTableStart >= 0) && (iTableEnd >= 0))
	{
		CStringArray	astrColorsRtf, astrColorsTT;
		int				iTTColor = 0, iRtfColor = 0, iColorEnd;
		CString			strColor;

		while ((iTableStart < iTableEnd) && (iTableStart != -1))
		{
			iTableStart = strTemp.Find(_T("\\red"), iTableStart + 1);
			strColor.Format(_T("\\cf%i"), iRtfColor);
			astrColorsRtf.Add(strColor);
			if ((iRtfColor == 0) || (iTTColor == static_cast<int>(GetSysColor(COLOR_WINDOWTEXT))))
				strColor = _T(" <ct>");
			else
				strColor.Format(_T(" <ct=0x%06x>"), iTTColor);
			astrColorsTT.Add(strColor);
			iRtfColor++;
			if (iTableStart != -1)
			{
				iColorEnd = strTemp.Find(_T('\\'), iTableStart + 1);
				if (iColorEnd >= 0)
				{
					iTTColor = _tstoi(strTemp.Mid(iTableStart + 4, iColorEnd - (iTableStart + 4)));
					iTableStart = iColorEnd + 6;
					iColorEnd = strTemp.Find(_T('\\'), iTableStart + 1);
					if (iColorEnd >= 0)
					{
						iTTColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 8);
						iTableStart = iColorEnd + 5;
						iColorEnd = strTemp.Find(_T(';'), iTableStart + 1);
						if (iColorEnd >= 0)
							iTTColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 16);
					}
				}
			}
		}
		for (int i = 0; i < astrColorsRtf.GetSize(); i++)
		{
			strTemp.Replace(astrColorsRtf[i] + _T(" \\\'"), astrColorsTT[i] + _T(" \\\'"));
			strTemp.Replace(astrColorsRtf[i] + _T(' '), astrColorsTT[i]);
			strTemp.Replace(astrColorsRtf[i] + _T('\\'), astrColorsTT[i] + _T('\\'));
		}

		int			iLines = 0, iStrEnd = strTemp.ReverseFind(_T('}'));

		if (iStrEnd != -1)
			strTemp.Truncate(iStrEnd);
		strTemp.TrimRight(_T('\n'));

		LPCTSTR		pszStart = strTemp;
		LPCTSTR		psz = pszStart;

		pszStart += strTemp.Find(_T('\\'), iTableEnd);
		psz += strTemp.GetLength() - 1;

		CString		strLog, strStatus = g_App.m_pMDlg->m_ctlStatusBar.GetText(SB_MESSAGETEXT, 0);
		int			iLastFound, iNextFound, iCount = 11;

#ifdef _UNICODE
		es.dwCookie = (DWORD)&strLog;
		es.pfnCallback = MEditStreamOutCallbackW;
		StreamOut(SF_UNICODE | SF_TEXT, es);
#else
		GetWindowText(strLog);
#endif
		iLastFound = strLog.Find(strStatus);
		iNextFound = iLastFound;
		while (iNextFound >= 0)
		{
			iLastFound = iNextFound;
			iNextFound = strLog.Find(strStatus, iLastFound + 1);
		}
		
		if (iLastFound >= 0)
		{
			iCount = 0;
			iNextFound = strLog.Find(_T("\n"), iLastFound + 1);
			while (iNextFound >= 0)
			{
				iCount++;
				iNextFound = strLog.Find(_T("\n"), iNextFound + 1);
			}
			
			while (iCount > 0 && psz > pszStart)
			{
				if (*psz == _T('\n'))
					iCount--;
				psz--;
			}
			iCount = 10 - iCount;
			strTemp.Truncate(psz - strTemp.GetString());
		}

		while (iLines < iCount && psz > pszStart)
		{
			if (*psz == _T('\n'))
				iLines++;
			psz--;
		}

		if (psz > pszStart)
			psz++;

		pszStart = psz;

		TCHAR		strChar[2];
		long		lLen;

		while (*psz != _T('\0'))
		{
			if (*psz == _T('\\'))
			{
				if (*(psz + 1) == _T('\\'))
				{
					strText.Append(pszStart, (1 + psz - pszStart));
					psz += 2;
				}
				else if (*(psz + 1) == _T('\''))
				{
					if ((psz - pszStart) > 0)
						strText.Append(pszStart, (psz - pszStart - 1));

					strChar[0] = *(psz + 2);
					strChar[1] = *(psz + 3);
					strText += (TCHAR)_tcstol(strChar, NULL, 16);
					psz += 4;
				}
				else
				{
					if ((psz - pszStart) > 0)
						strText.Append(pszStart, (psz - pszStart));

					lLen = _tcscspn(psz, _T(" \n"));
					if (lLen == 0)
						psz += _tcslen(psz);
					else
					{
						psz += lLen;
						if (*psz == _T(' '))
							psz++;
					}
				}
				pszStart = psz;
			}
			else
				psz++;
		}
		if (pszStart != psz)
			strText.Append(pszStart);
	}

	strText.Trim(_T('\n'));
	strText.Replace(_T(" <ct"), _T("<ct"));
	while (strText.Right(4) == _T("<ct>"))
		strText.Truncate(strText.GetLength() - CSTRLEN(_T("<ct>")));
	strText.TrimRight(_T('\n'));
	strText.Replace(_T("\n"), _T("<br>"));
	if (strText[0] != _T('<'))
		strText.Insert(0, _T("<"));

	return strText;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CHTRichEditCtrl::SetFont(CFont* pFont, bool bRedraw /*= true*/)
{
	SetBackgroundColor(false, m_crDefaultBackground);
	
	LOGFONT			lf = {0};
	CHARFORMAT2		cf2;

	pFont->GetLogFont(&lf);
	memzero(&cf2, sizeof(cf2));
	cf2.cbSize = sizeof(cf2);
	cf2.dwMask = CFM_FACE | CFM_SIZE /*| CFM_CHARSET*/;

	if (GetWindowTextLength() == 0)
		cf2.dwMask |= CFM_BACKCOLOR | CFM_BOLD | CFM_COLOR | CFM_ITALIC | CFM_LINK | CFM_STRIKEOUT | CFM_UNDERLINE;

	cf2.crTextColor = m_crDefaultForeground;
	cf2.crBackColor = m_crDefaultBackground;

	HDC				hDC = ::GetDC(NULL);

	cf2.yHeight = (-MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY))) * 20;
	::ReleaseDC(NULL, hDC);

	cf2.bPitchAndFamily = lf.lfPitchAndFamily;
	_tcsncpy(cf2.szFaceName, lf.lfFaceName, ARRSIZE(cf2.szFaceName));
	cf2.szFaceName[ARRSIZE(cf2.szFaceName) - 1] = _T('\0');

	// although this should work correctly (according SDK) it may give false results (e.g. the "click here..." text
	// which is shown in the server info window may not be entirely used as a hyperlink???)
	//cf2.bCharSet = lf.lfCharSet;
	//cf2.yOffset = 0;
	VERIFY( SetDefaultCharFormat(cf2) );

	if (bRedraw)
	{
		Invalidate();
		UpdateWindow();
	}
}
@


1.110
log
@Fixed WebServer last log message report for Servers and Shared Files (broken since v1g; it displays last log message on adding new server, updating server list and shared files reload).
@
text
@a38 4
#ifndef IDC_HAND
#define IDC_HAND            MAKEINTRESOURCE(32649)
#endif

d68 1
a68 1
	m_dwFlags = (HTC_ISAUTOSCROLL | HTC_ISDEFAULTLINKS);
d71 5
a75 15
	switch (get_cpu_type())
	{
		case 1:
			m_lMaxBufSize = (32 * 1024);
			break;
		case 2:
			m_lMaxBufSize = (64 * 1024);
			break;
		default:
			if (g_App.m_pPrefs->GetWindowsVersion() == _WINVER_95_)
				m_lMaxBufSize = (64 * 1024);
			else
				m_lMaxBufSize = (128 * 1024);
			break;
	}
a76 1
	m_hHandCursor = ::LoadCursor(NULL, IDC_HAND);
d101 1
a101 1
	LimitText((g_App.m_pPrefs->GetWindowsVersion() == _WINVER_95_) ? ((64 * 1024) - 1) : (128 * 1024));
d108 1
a108 1
void CHTRichEditCtrl::AppendText(LPCTSTR pszMsg, COLORREF crTextColor /*= CLR_DEFAULT*/, COLORREF crBackColor /*= CLR_DEFAULT*/, DWORD dwFlags /*= 0*/)
d110 8
a117 1
	long		lMsgLen = _tcslen(pszMsg);
d119 1
a119 1
	if (lMsgLen == 0 || !::IsWindow(m_hWnd))
d122 1
a122 1
	long		lStartChar, lEndChar, lTextEnd = GetTextLengthEx(GTL_PRECISE);
a145 1
	cf2.dwEffects &= ~(CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR | CFE_BOLD | CFE_ITALIC | CFE_LINK | CFE_STRIKEOUT | CFE_UNDERLINE);
d148 6
a153 10
	if ((dwFlags & HTC_BOLD) != 0)
		cf2.dwEffects |= CFE_BOLD;
	if ((dwFlags & HTC_ITALIC) != 0)
		cf2.dwEffects |= CFE_ITALIC;
	if ((dwFlags & HTC_LINK) != 0)
		cf2.dwEffects |= CFE_LINK;
	if ((dwFlags & HTC_STRIKEOUT) != 0)
		cf2.dwEffects |= CFE_STRIKEOUT;
	if ((dwFlags & HTC_UNDERLINE) != 0)
		cf2.dwEffects |= CFE_UNDERLINE;
d157 1
a157 1
	if ((dwFlags & HTC_LINK) == 0 && (m_dwFlags & HTC_ISDEFAULTLINKS) != 0)
d159 3
a161 2
		CString		strLineOrginal(pszMsg, lMsgLen), strLine(strLineOrginal);
		int			iIndex = 0, iScheme, iLen, iLinkEnd;
d163 1
a163 1
		lTextEnd = GetTextLengthEx(GTL_PRECISE) - strLineOrginal.GetLength();
d168 2
a169 1
		while (strLineOrginal.GetLength() > iIndex)
d171 2
a172 1
			for (iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
d177 5
a181 2
				if ((strLine.GetLength() > iLinkEnd) &&
					(strLine.Mid(iIndex, iLen).Compare(_apszSchemes[iScheme].pszScheme) == 0))
d183 21
a203 6
					while (strLine.GetLength() > iLinkEnd && strLine[iLinkEnd] != _T(' ')
						&& strLine[iLinkEnd] != _T('\n') && strLine[iLinkEnd] != _T('\\') &&
						strLine[iLinkEnd] != _T('\r') && strLine[iLinkEnd] != _T('\t'))
					{
						iLinkEnd++;
					}
d205 5
a209 19
					while ((iLinkEnd > iIndex + iLen) && 
						!((strLine[iLinkEnd - 1] >= _T('/') && strLine[iLinkEnd - 1] <= _T('9'))
						||(strLine[iLinkEnd - 1] >= _T('a') && strLine[iLinkEnd - 1] <= _T('z'))
						|| (strLine[iLinkEnd - 1] == _T('|'))))
					{
						iLinkEnd--;
					}

					if (iLinkEnd > iIndex + iLen)
					{
						SetSel(lTextEnd + iIndex, lTextEnd + iLinkEnd);
						SetSelectionCharFormat(cf2);
						iIndex = iLinkEnd;
					}
					else
						iIndex += iLen;

					break;
				}
d211 2
a212 2
			if (iScheme >= ARRSIZE(_apszSchemes))
				iIndex++;
a336 8
void CHTRichEditCtrl::OnLButtonDown(UINT nFlags, CPoint point)
{
	if ((m_dwFlags & HTC_ISDEFAULTLINKS) == 0 && (m_dwFlags & HTC_ISHANDCURSOR) != 0 && !m_strURL.IsEmpty())
		ShellExecute(NULL, NULL, m_strURL, NULL, NULL, SW_SHOWDEFAULT);
	else
		CRichEditCtrl::OnLButtonDown(nFlags, point);
}

a343 5
	else if ((m_dwFlags & HTC_ISHANDCURSOR) != 0)
	{
		::SetCursor(m_hHandCursor);
		return true;
	}
d382 2
a383 1
	ENLINK		*pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);
d385 1
a385 1
	if (pEnLink != NULL)
d393 1
a393 1
			if (strURL.Left(_apszSchemes[iScheme].uiLen).CompareNoCase(_apszSchemes[iScheme].pszScheme) == 0)
d395 3
a397 8
				m_strURL = strURL;
				
				if (pEnLink->msg == WM_LBUTTONDOWN)
				{
					ShellExecute(NULL, NULL, m_strURL, NULL, NULL, SW_SHOWDEFAULT);
					*pResult = 1;
					return true;
				}
d402 2
a403 2
	*pResult = 0;
	return false;
@


1.109
log
@Minor improvements and formatting.
@
text
@d367 13
@


1.108
log
@fixed GetWindowText issue
@
text
@d548 1
a548 1
					strText += CString(pszStart, 1 + psz - pszStart);
d553 2
a554 2
					if (psz - pszStart > 0)
						strText += CString(pszStart, psz - pszStart - 1);
d563 2
a564 2
					if (psz - pszStart > 0)
						strText += CString(pszStart, psz - pszStart);
d669 1
d673 3
d765 1
a765 1
		strText.Truncate(strText.GetLength() - 4);
@


1.107
log
@faster range detection of the removed text
@
text
@d18 8
d669 3
a671 1
		GetWindowText(strLog);
d697 1
a697 1
			strTemp.Truncate(psz - strTemp);
d721 1
a721 1
					strText += CString(pszStart, 1 + psz - pszStart);
d726 2
a727 2
					if (psz - pszStart > 0)
						strText += CString(pszStart, psz - pszStart - 1);
d736 2
a737 2
					if (psz - pszStart > 0)
						strText += CString(pszStart, psz - pszStart);
d755 1
a755 1
			strText += pszStart;
@


1.106
log
@Formatting and minor optimization.
@
text
@d136 1
a136 1
		CString		strLog;
d138 1
a138 11
		GetWindowText(strLog);

		long		lLen = strLog.Find(_T('\n'), m_lMaxBufSize >> 3);

		if (lLen < 0)
			lLen = m_lMaxBufSize >> 3;

		strLog.Truncate(lLen);
		strLog.Remove(_T('\n'));
		lLen = strLog.GetLength();
		SetSel(0, lLen);
@


1.105
log
@fixed output into log file on Win9x systems
@
text
@d2 1
a2 1
//Copyright (C)2002-2006 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
d31 4
d69 4
a72 8
	case 1:
		m_lMaxBufSize = (32 * 1024);
		break;
	case 2:
		m_lMaxBufSize = (64 * 1024);
		break;
	default:
		if (g_App.m_pPrefs->GetWindowsVersion() == _WINVER_95_)
d74 7
a80 3
		else
			m_lMaxBufSize = (128 * 1024);
		break;
d83 1
a83 1
	m_hHandCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(32649));
d142 1
a142 1
		if (lLen == -1)
d153 2
a154 2
	memzero(&cf2, sizeof cf2);
	cf2.cbSize = sizeof cf2;
d174 1
a174 1
		CString		strLineOrginal = pszMsg, strLine = strLineOrginal;
d509 2
a510 2
			iRtfColor ++;
			if (iTableStart != -1)
d513 1
a513 1
				if (iColorEnd != -1)
d518 1
a518 1
					if (iColorEnd != -1)
d523 1
a523 1
						if (iColorEnd != -1)
d529 1
a529 1
		if (astrColorsRtf.GetSize() > 0)
d531 3
a533 6
			for (int i = 0; i < astrColorsRtf.GetSize(); i++)
			{
				strTemp.Replace(astrColorsRtf[i] + _T(" \\\'"), astrColorsHtml[i] + _T(" \\\'"));
				strTemp.Replace(astrColorsRtf[i] + _T(' '), astrColorsHtml[i]);
				strTemp.Replace(astrColorsRtf[i] + _T('\\'), astrColorsHtml[i] + _T('\\'));
			}
d613 1
a613 1
	if ((iTableStart != -1) && (iTableEnd != -1))
d633 1
a633 1
				if (iColorEnd != -1)
d638 1
a638 1
					if (iColorEnd != -1)
d643 1
a643 1
						if (iColorEnd != -1)
d649 1
a649 1
		if (astrColorsRtf.GetSize() > 0)
d651 3
a653 6
			for (int i = 0; i < astrColorsRtf.GetSize(); i++)
			{
				strTemp.Replace(astrColorsRtf[i] + _T(" \\\'"), astrColorsTT[i] + _T(" \\\'"));
				strTemp.Replace(astrColorsRtf[i] + _T(' '), astrColorsTT[i]);
				strTemp.Replace(astrColorsRtf[i] + _T('\\'), astrColorsTT[i] + _T('\\'));
			}
d674 1
a674 1
		while (iNextFound != -1)
d680 1
a680 1
		if (iLastFound != -1)
d684 1
a684 1
			while (iNextFound != -1)
d778 2
a779 2
	memzero(&cf2, sizeof cf2);
	cf2.cbSize = sizeof cf2;
@


1.104
log
@Formatting.
@
text
@d428 3
a430 1
			GetWindowText(strLog);
d432 2
d435 3
@


1.103
log
@fixed log output in tooltip and webserver that was brocken after unicode switch
@
text
@d472 1
a472 1
	StreamOut(((CP_UTF8 << 16) | SF_USECODEPAGE | SF_RTF), es);
d528 1
a528 1
		LPCTSTR			psz = strTemp.GetBuffer();		//Note: buffer will be released in destructor
d596 1
a596 1
	StreamOut(((CP_UTF8 << 16) | SF_USECODEPAGE | SF_RTF), es);
d598 1
a598 1
	
@


1.102
log
@fixed duplicated CR in RTF file
@
text
@d413 1
a413 1

d448 1
a448 1
		FILE	*pRtfFile = _tfsopen(strTemp, _T("wt"), _SH_DENYWR);
d453 1
a453 1
			CString			strRTF;
d456 1
a456 1
			es.pfnCallback = MEditStreamOutCallback;
d458 1
a458 2
			strRTF.Replace(_T("\r\n"),_T("\n"));
			_fputts(strRTF, pRtfFile);
d463 1
a463 1

d466 1
d470 5
a474 3
	es.dwCookie = (DWORD)&strTemp;
	es.pfnCallback = MEditStreamOutCallback;
	StreamOut(SF_RTF, es);
d528 1
a528 1
		LPCTSTR			psz = strTemp;
d587 1
a587 1

d590 1
d594 5
a598 3
	es.dwCookie = (DWORD)&strTemp;
	es.pfnCallback = MEditStreamOutCallback;
	StreamOut(SF_RTF, es);
d764 1
a764 1

@


1.101
log
@Proper share mode for open files (before other applications could write to a file while we were reading);
Suppressed compiler warnings.
@
text
@d448 1
a448 1
		FILE	*pRtfFile = _tfsopen(strTemp, _T("w"), _SH_DENYWR);
d458 1
@


1.100
log
@set Unicode message format for Win9x systems
@
text
@d23 1
d105 1
a105 1
	SetTargetDevice(NULL, (bool)(m_dwFlags & HTC_ISWORDWRAP) == 0);
d122 2
a123 1
	bool			bIsVisible = IsWindowVisible(), bIsEndSel = (lStartChar == lEndChar && lStartChar == lTextEnd);
d335 1
a335 1
			SetTargetDevice(NULL, (bool)(m_dwFlags & HTC_ISWORDWRAP) == 0);
d424 1
a424 1
		FILE	*pLogFile = _tfopen(strTemp, _T("wb"));
d432 1
a432 1
			_fputts(strLog, pLogFile);
d448 1
a448 1
		FILE	*pRtfFile = _tfopen(strTemp, _T("wt"));
@


1.99
log
@added unicode support for log files (emule, debug, upload, download, status, backup)
@
text
@d98 5
@


1.98
log
@Avoid multiple instances of _apszSchemes table (static declaration in H-file creates multiple instances).
@
text
@d409 1
d412 1
a412 1
	if (DialogBrowseFile(strTemp, _T("Log (*.log)|*.log||"), m_strTitle + _T(".log"), 0, false, g_App.m_pPrefs->GetAppDir()))
d414 2
a415 1
		HANDLE		hFile = CreateFile(strTemp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
d417 3
a419 1
		if (hFile != INVALID_HANDLE_VALUE)
d422 5
a426 5

			DWORD		dwWritten;

			WriteFile(hFile, strLog, strLog.GetLength(), &dwWritten, NULL);
			CloseHandle(hFile);
d430 1
a430 1

d433 1
d436 1
a436 1
	if (DialogBrowseFile(strTemp, _T("Rich Text Format (RTF)|*.rtf||"), m_strTitle + _T(".rtf"), 0, false, g_App.m_pPrefs->GetAppDir()))
d438 4
a441 1
		HANDLE		hFile = CreateFile(strTemp, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
d443 1
a443 1
		if (hFile != INVALID_HANDLE_VALUE)
a446 1
			DWORD			dwWritten;
d451 2
a452 2
			WriteFile(hFile, strRTF, strRTF.GetLength(), &dwWritten, NULL);
			CloseHandle(hFile);
@


1.97
log
@Suppressed level 4 warnings.
@
text
@d30 16
@


1.96
log
@Default browsing directory for WebServer templates and while saving logs (default is main e+ dir) {muleteer}.
@
text
@d254 1
d288 2
d292 22
a313 22
	case MP_COPYSELECTED:
		Copy();
		break;
	case MP_SAVELOG:
		SaveLogToDisk();
		break;
	case MP_SAVERTF:
		SaveRtfToDisk();
		break;
	case MP_SELECTALL:
		SetSel(0, -1);
		break;
	case MP_REMOVEALL:
		Reset();
		break;
	case MP_AUTOSCROLL:
		m_dwFlags ^= HTC_ISAUTOSCROLL;
		break;
	case MP_WORDWRAP:
		m_dwFlags ^= HTC_ISWORDWRAP;
		SetTargetDevice(NULL, (bool)(m_dwFlags & HTC_ISWORDWRAP) == 0);
		break;
d572 1
a572 2
		int				iRtfColor = 0, iColorEnd;
		long			lTTColor = 0;
d580 4
a583 1
			(iRtfColor == 0 || lTTColor == GetSysColor(COLOR_WINDOWTEXT)) ? strColor = _T(" <ct>") : strColor.Format(_T(" <ct=0x%06x>"), lTTColor);
d591 1
a591 1
					lTTColor = _tstoi(strTemp.Mid(iTableStart + 4, iColorEnd - (iTableStart + 4)));
d596 1
a596 1
						lTTColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 8);
d600 1
a600 1
							lTTColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 16);
@


1.95
log
@avoid outputting log on shutdown
@
text
@d392 1
a392 1
	if (DialogBrowseFile(strTemp, _T("Log (*.log)|*.log||"), m_strTitle + _T(".log"), 0, false))
d412 1
a412 1
	if (DialogBrowseFile(strTemp, _T("Rich Text Format (RTF)|*.rtf||"), m_strTitle + _T(".rtf"), 0, false))
@


1.94
log
@Fixed disappearance of the chat message pane after pressed <Esc> (from original).
@
text
@d93 1
a93 1
	if (lMsgLen == 0)
@


1.93
log
@Fixed cursor destruction {SlugFiller}.
@
text
@a340 1

d352 2
@


1.92
log
@Reduced H-file dependency.
@
text
@d1 17
d61 1
a61 1
	m_hArrowCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(32512));
d67 1
a67 4
	if (m_hArrowCursor != NULL)
		::DestroyCursor(m_hArrowCursor);
	if (m_hHandCursor != NULL)
		::DestroyCursor(m_hHandCursor);
d761 1
a761 1
}@


1.91
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d4 1
@


1.90
log
@renamed 3 variables
@
text
@d37 1
a37 1
		if (g_App.g_pPrefs->GetWindowsVersion() == _WINVER_95_)
d67 1
a67 1
	LimitText((g_App.g_pPrefs->GetWindowsVersion() == _WINVER_95_) ? ((64 * 1024) - 1) : (128 * 1024));
d219 1
a219 1
	if (g_App.g_pPrefs->GetWindowsVersion() == _WINVER_95_)
@


1.89
log
@A more correct way to set the ENM_LINK event for the RichEdit control + Minor changes.
@
text
@d37 1
a37 1
		if (g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() == _WINVER_95_)
d57 1
a57 1
	m_strTitle = g_eMuleApp.StripInvalidFilenameChars(pszTitle);
d67 1
a67 1
	LimitText((g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() == _WINVER_95_) ? ((64 * 1024) - 1) : (128 * 1024));
d219 1
a219 1
	if (g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() == _WINVER_95_)
d606 1
a606 1
		CString		strLog, strStatus = g_eMuleApp.m_pdlgEmule->m_ctlStatusBar.GetText(SB_MESSAGETEXT, 0);
@


1.88
log
@Added an option in IRC to send Bold, Underline & Colored messages.
Small optimization in IRC and some minor changes/fixes.
@
text
@d67 1
a67 2
	LimitText((g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() == _WINVER_95_) ? ((64*1024) - 1) : (128*1024));
	
d69 1
@


1.87
log
@Constructor improvement.
@
text
@d74 1
a74 1
void CHTRichEditCtrl::AppendText(LPCTSTR pszMsg, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, DWORD dwFlags /*= 0*/)
d115 2
a116 2
	cf2.crTextColor = ((crTextColor & 0x1000000) == 0) ? (crTextColor & 0xFFFFFF) : m_crDefaultForeground;
	cf2.crBackColor = ((crBackColor & 0x1000000) == 0) ? (crBackColor & 0xFFFFFF) : m_crDefaultBackground;
@


1.86
log
@Different way to handle IRC links + Minor fix in rich edit color handling.
@
text
@d23 1
a23 1
CHTRichEditCtrl::CHTRichEditCtrl()
a27 2
	m_strTitle.Empty();
	m_strURL.Empty();
@


1.85
log
@Auto-detected IRC links are not marked.
@
text
@a11 20
static const struct
{
	LPCTSTR		pszScheme;
	unsigned	uiLen;
} _apszSchemes[] =
{
	{ _T("ed2k://"), sizeof(_T("ed2k://")) / sizeof(TCHAR) - 1 },
	{ _T("ftp."), sizeof(_T("ftp.")) / sizeof(TCHAR) - 1 },
	{ _T("ftp://"), sizeof(_T("ftp://")) / sizeof(TCHAR) - 1 },
	{ _T("http://"), sizeof(_T("http://")) / sizeof(TCHAR) - 1 },
	{ _T("https://"), sizeof(_T("https://")) / sizeof(TCHAR) - 1 },
	{ _T("mailto:"), sizeof(_T("mailto:")) / sizeof(TCHAR) - 1 },
	{ _T("www."), sizeof(_T("www.")) / sizeof(TCHAR) - 1 },
	{ _T("www1."), sizeof(_T("www1.")) / sizeof(TCHAR) - 1 },
	{ _T("www2."), sizeof(_T("www2.")) / sizeof(TCHAR) - 1 },
	{ _T("www3."), sizeof(_T("www3.")) / sizeof(TCHAR) - 1 },
	{ _T("www4."), sizeof(_T("www4.")) / sizeof(TCHAR) - 1 },
	{ _T("www5."), sizeof(_T("www5.")) / sizeof(TCHAR) - 1 }
};

a15 1
	ON_WM_MOUSEMOVE()
d26 2
d116 3
a118 12
	cf2.dwEffects |= (CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR);
	cf2.dwEffects &= ~(CFE_BOLD | CFE_ITALIC | CFE_LINK | CFE_STRIKEOUT | CFE_UNDERLINE);
	if ((crTextColor & 0x1000000) == 0)
	{
		cf2.dwEffects &= ~CFE_AUTOCOLOR;
		cf2.crTextColor = (crTextColor & 0xFFFFFF);
	}
	if ((crBackColor & 0x1000000) == 0)
	{
		cf2.dwEffects &= ~CFE_AUTOBACKCOLOR;
		cf2.crBackColor = (crBackColor & 0xFFFFFF);
	}
a301 78
void CHTRichEditCtrl::OnMouseMove(UINT nFlags, CPoint point) 
{
	CRichEditCtrl::OnMouseMove(nFlags, point);

	if ((m_dwFlags & HTC_ISDEFAULTLINKS) != 0)
		return;
	
	m_dwFlags &= ~HTC_ISHANDCURSOR;

	int			iCharPos = CharFromPos(point);
	int			iLine = LineFromChar(iCharPos);
	int			iLineIndex = LineIndex(iLine);
	int			iLen = LineLength(iLineIndex);

	if (iLen <= 3)
		return;

	TCHAR		*pBuffer = new TCHAR[iLen + 3];

	memzero(pBuffer, sizeof(TCHAR) * (iLen + 3));
	GetLine(iLine, pBuffer, iLen);

	CString		strLineOrginal = CString(pBuffer, iLen);

	delete pBuffer;

	CString		strLine = strLineOrginal;
	int			iIndex = 0, iScheme, iLinkEnd;

	iCharPos -= iLineIndex;
	//	Convert string to lower case only once
	strLine.MakeLower();
	while (strLineOrginal.GetLength() > iIndex)
	{
		for (iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
		{
			iLen = _apszSchemes[iScheme].uiLen;
			iLinkEnd = iIndex + iLen;

			if ((strLine.GetLength() > iLinkEnd) &&
				(strLine.Mid(iIndex, iLen).Compare(_apszSchemes[iScheme].pszScheme) == 0))
			{
				while (strLine.GetLength() > iLinkEnd && strLine[iLinkEnd] != _T(' ')
					&& strLine[iLinkEnd] != _T('\n') && strLine[iLinkEnd] != _T('\\') &&
					strLine[iLinkEnd] != _T('\r') && strLine[iLinkEnd] != _T('\t'))
				{
					iLinkEnd++;
				}

				while ((iLinkEnd > iIndex + iLen) && 
					!((strLine[iLinkEnd - 1] >= _T('/') && strLine[iLinkEnd - 1] <= _T('9'))
					||(strLine[iLinkEnd - 1] >= _T('a') && strLine[iLinkEnd - 1] <= _T('z'))
					|| (strLine[iLinkEnd - 1] == _T('|'))))
				{
					iLinkEnd--;
				}

				if (iLinkEnd > iIndex + iLen)
				{
					if (iCharPos > iIndex && iCharPos < iLinkEnd)
					{
						m_strURL = strLineOrginal.Mid(iIndex, iLinkEnd - iIndex);
						m_dwFlags |= HTC_ISHANDCURSOR;
						return;
					}
					iIndex = iLinkEnd;
				}
				else
					iIndex += iLen;

				break;
			}
		}
		if (iScheme >= ARRSIZE(_apszSchemes))
			iIndex++;
	}
}

d712 2
d725 2
a726 2
	cf2.crTextColor = GetSysColor(COLOR_WINDOWTEXT);
	cf2.crBackColor = GetSysColor(COLOR_WINDOW);
@


1.84
log
@Small optimization + Removed unused code.
@
text
@d40 1
d46 1
a46 1
	m_dwFlags = HTC_ISAUTOSCROLL;
d160 52
d327 1
a327 1
	return TRUE;
d332 5
a338 2
	CRichEditCtrl::OnMouseMove(nFlags, point);

d410 1
a410 1
	if ((m_dwFlags & HTC_ISHANDCURSOR) != 0 && !m_strURL.IsEmpty())
d421 1
a421 1
		return TRUE;
d426 1
a426 1
		return TRUE;
d432 48
a522 18
void CHTRichEditCtrl::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{

	if (GetKeyState(VK_CONTROL) & 0x8000)
	{
		if (nChar == _T('A'))
			//////////////////////////////////////////////////////////////////
			// Ctrl+A: Select all items
			SetSel(0, -1);
		else if (nChar == _T('C'))
			//////////////////////////////////////////////////////////////////
			// Ctrl+C: Copy listview items to clipboard
			Copy();
	}

	CRichEditCtrl::OnKeyDown(nChar, nRepCnt, nFlags);
}

@


1.83
log
@Removed an unused variable + Minor correction in link detection.
@
text
@a39 1
	ON_WM_PAINT()
d45 1
a45 4
	m_bAutoScroll = true;
	m_bWordWrap = false;
	m_bLimited = false;
	m_byCursorIndex = 0;
d89 1
a89 1
	SetTargetDevice(NULL, !m_bWordWrap);
d164 1
a164 1
	if (m_bAutoScroll && (_tcschr(pszMsg, _T('\n')) != NULL))
d174 1
a174 1
	if (m_bWordWrap)
d218 1
a218 1
	m_byCursorIndex = 1;
d220 1
a220 1
	if (!m_bLimited)
d227 1
a227 1
	if (!m_bLimited)
d235 1
a235 1
	if (!m_bLimited)
d239 2
a240 2
		menuLog.AppendMenu(MF_STRING | (m_bAutoScroll ? MF_CHECKED : MF_UNCHECKED), MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
		menuLog.AppendMenu(MF_STRING | (m_bWordWrap ? MF_CHECKED : MF_UNCHECKED), MP_WORDWRAP, GetResString(IDS_WORDWRAP));
d244 1
a244 1
	m_byCursorIndex = 0;
d267 1
a267 1
		m_bAutoScroll = !m_bAutoScroll;
d270 2
a271 2
		SetTargetDevice(NULL, m_bWordWrap);
		m_bWordWrap = !m_bWordWrap;
d279 1
a279 1
	m_byCursorIndex = 0;
d303 1
a305 1
	iLineIndex = iCharPos - iLineIndex;
d333 1
a333 1
					if (iLineIndex > iIndex && iLineIndex < iLinkEnd)
d336 1
a336 1
						m_byCursorIndex = 2;
d354 1
a354 1
	if (m_byCursorIndex == 2 && !m_strURL.IsEmpty())
d362 1
a362 1
	switch (m_byCursorIndex)
d364 7
a370 10
		case 1:
		{
			::SetCursor(m_hArrowCursor);
			return TRUE;
		}
		case 2:
		{
			::SetCursor(m_hHandCursor);
			return TRUE;
		}
d372 1
a436 8
CString CHTRichEditCtrl::GetText() const
{
	CString			strText;

	GetWindowText(strText);
	return strText;
}

@


1.82
log
@More link detection corrections.
@
text
@d305 1
a305 1
	int			iIndex = 0, iLastIndex = 0, iScheme, iLinkEnd;
d337 1
a337 1
					if (iLineIndex >= iIndex && iLineIndex < iLinkEnd)
a343 1
					iLastIndex = iIndex;
@


1.81
log
@Minor correction on mouse move handling.
@
text
@d285 2
d288 8
a295 1
	int			iLen = LineLength(iCharPos) + 1;
d297 4
a300 5
	if (iLen > 3)
	{
		int			iLine = LineFromChar(iCharPos);
		int			iLineIndex = iCharPos - LineIndex(iLine);
		CString		strLineOrginal;
d302 1
a302 2
		GetLine(iLine, strLineOrginal.GetBuffer(iLen));
		strLineOrginal.ReleaseBuffer();
d304 2
a305 2
		CString		strLine = strLineOrginal;
		int			iIndex = 0, iLastIndex = 0, iScheme, iLinkEnd;
d307 6
a312 3
		//	Convert string to lower case only once
		strLine.MakeLower();
		while (strLineOrginal.GetLength() > iIndex)
d314 5
a318 1
			for (iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
d320 6
a325 2
				iLen = _apszSchemes[iScheme].uiLen;
				iLinkEnd = iIndex + iLen;
d327 4
a330 2
				if ((strLine.GetLength() > iLinkEnd) &&
					(strLine.Mid(iIndex, iLen).Compare(_apszSchemes[iScheme].pszScheme) == 0))
d332 2
a333 6
					while (strLine.GetLength() > iLinkEnd && strLine[iLinkEnd] != _T(' ')
						&& strLine[iLinkEnd] != _T('\n') && strLine[iLinkEnd] != _T('\\') &&
						strLine[iLinkEnd] != _T('\r') && strLine[iLinkEnd] != _T('\t'))
					{
						iLinkEnd++;
					}
d335 3
a337 4
					while ((iLinkEnd > iIndex + iLen) && 
						!((strLine[iLinkEnd - 1] >= _T('/') && strLine[iLinkEnd - 1] <= _T('9'))
						||(strLine[iLinkEnd - 1] >= _T('a') && strLine[iLinkEnd - 1] <= _T('z'))
						|| (strLine[iLinkEnd - 1] == _T('|'))))
d339 3
a341 1
						iLinkEnd--;
d343 5
d349 1
a349 16
					if (iLinkEnd > iIndex + iLen)
					{
						if (iLineIndex >= iIndex && iLineIndex < iLinkEnd)
						{
							m_strURL = strLineOrginal.Mid(iIndex, iLinkEnd - iIndex);
							m_byCursorIndex = 2;
							break;
						}
						iIndex = iLinkEnd;
						iLastIndex = iIndex;
					}
					else
						iIndex += iLen;

					break;
				}
a350 4
			if (iScheme >= ARRSIZE(_apszSchemes))
				iIndex++;
			else if (m_byCursorIndex == 2)
				break;
d352 2
a354 1
	CWnd::OnMouseMove(nFlags, point);
d362 1
a362 1
		CWnd::OnLButtonDown(nFlags, point);
d380 1
a380 1
	return CWnd::OnSetCursor(pWnd, nHitTest, message);
@


1.80
log
@Links are no longer marked in Logs/IRC/Messages.
@
text
@a285 2
	int			iLine = LineFromChar(iCharPos);
	int			iLineIndex = iCharPos - LineIndex(iLine);
d288 5
a292 4
	if (iLen < 4)
		return;

	CString		strLineOrginal;
d294 2
a295 2
	GetLine(iLine, strLineOrginal.GetBuffer(iLen));
	strLineOrginal.ReleaseBuffer();
d297 2
a298 2
	CString		strLine = strLineOrginal;
	int			iIndex = 0, iLastIndex = 0, iScheme, iLinkEnd;
d300 3
a302 5
//	Convert string to lower case only once
	strLine.MakeLower();
	while (strLineOrginal.GetLength() > iIndex)
	{
		for (iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
d304 4
a307 2
			iLen = _apszSchemes[iScheme].uiLen;
			iLinkEnd = iIndex + iLen;
d309 2
a310 6
			if ((strLine.GetLength() > iLinkEnd) &&
				(strLine.Mid(iIndex, iLen).Compare(_apszSchemes[iScheme].pszScheme) == 0))
			{
				while (strLine.GetLength() > iLinkEnd && strLine[iLinkEnd] != _T(' ')
					&& strLine[iLinkEnd] != _T('\n') && strLine[iLinkEnd] != _T('\\') &&
					strLine[iLinkEnd] != _T('\r') && strLine[iLinkEnd] != _T('\t'))
d312 6
a317 2
					iLinkEnd++;
				}
d319 7
a325 7
				while ((iLinkEnd > iIndex + iLen) && 
					!((strLine[iLinkEnd - 1] >= _T('/') && strLine[iLinkEnd - 1] <= _T('9'))
					||(strLine[iLinkEnd - 1] >= _T('a') && strLine[iLinkEnd - 1] <= _T('z'))
					|| (strLine[iLinkEnd - 1] == _T('|'))))
				{
					iLinkEnd--;
				}
d327 1
a327 3
				if (iLinkEnd > iIndex + iLen)
				{
					if (iLineIndex >= iIndex && iLineIndex < iLinkEnd)
d329 8
a336 3
						m_strURL = strLineOrginal.Mid(iIndex, iLinkEnd - iIndex);
						m_byCursorIndex = 2;
						break;
d338 4
a341 2
					iIndex = iLinkEnd;
					iLastIndex = iIndex;
d343 4
a346 3
				else
					iIndex += iLen;

a347 1
			}
a348 4
		if (iScheme >= ARRSIZE(_apszSchemes))
			iIndex++;
		else if (m_byCursorIndex == 2)
			break;
@


1.79
log
@Minor link detection correction.
@
text
@d36 2
a40 1
	ON_NOTIFY_REFLECT_EX(EN_LINK, OnEnLink)
d49 1
a49 1
	m_bInMenu = false;
d51 1
d67 2
a68 1
	m_hCursor = ::LoadCursor(NULL, MAKEINTRESOURCE(32512));
d73 4
a76 2
	if (m_hCursor != NULL)
		::DestroyCursor(m_hCursor);
d98 1
a98 1
void CHTRichEditCtrl::AddLine(LPCTSTR pszMsg, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, DWORD dwFlags /*= 0*/)
d177 4
d222 1
a222 1
	m_bInMenu = true;
d248 1
a248 1
	m_bInMenu = false;
d281 80
d363 1
a363 1
	if (m_bInMenu)
d365 10
a374 2
		::SetCursor(m_hCursor);
		return TRUE;
a400 2
	EMULE_TRY

d410 1
a410 2
			CString			strLineOrginal, strLog;
			int				iIndex = 0, iLastIndex = 0, iScheme, iLen, iLinkEnd;
d413 1
a413 1
			es.dwCookie = (DWORD)&strLineOrginal;
d416 1
a416 53

			strTemp = strLineOrginal;
		//	Convert string to lower case only once
			strTemp.MakeLower();
			while (strLineOrginal.GetLength() > iIndex)
			{
				for (iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
				{
					iLen = _apszSchemes[iScheme].uiLen;
					iLinkEnd = iIndex + iLen;

					if ((strTemp.GetLength() > iLinkEnd) &&
						(strTemp.Mid(iIndex, iLen).Compare(_apszSchemes[iScheme].pszScheme) == 0))
					{
						while (strTemp.GetLength() > iLinkEnd && strTemp[iLinkEnd] != _T(' ')
							&& strTemp[iLinkEnd] != _T('\n') && strTemp[iLinkEnd] != _T('\\') &&
							strTemp[iLinkEnd] != _T('\r') && strTemp[iLinkEnd] != _T('\t'))
						{
							iLinkEnd++;
						}

						while ((iLinkEnd > iIndex + iLen) && 
							!((strTemp[iLinkEnd - 1] >= _T('/') && strTemp[iLinkEnd - 1] <= _T('9'))
							||(strTemp[iLinkEnd - 1] >= _T('a') && strTemp[iLinkEnd - 1] <= _T('z'))
							|| (strTemp[iLinkEnd - 1] == _T('|'))))
						{
							iLinkEnd--;
						}

						if (iLinkEnd > iIndex + iLen)
						{
							if (iIndex > iLastIndex)
								strLog += strLineOrginal.Mid(iLastIndex, iIndex - iLastIndex);
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"");
							strLog += strLineOrginal.Mid(iIndex, iLinkEnd - iIndex);
							strLog += _T("\"}}{\\fldrslt{{");
							strLog += strLineOrginal.Mid(iIndex, iLinkEnd - iIndex);
							strLog += _T("}}}}");
							iIndex = iLinkEnd;
							iLastIndex = iIndex;
						}
						else
							iIndex += iLen;

						break;
					}
				}
				if (iScheme >= ARRSIZE(_apszSchemes))
					iIndex++;
			}
			if (iLastIndex < iIndex)
				strLog += strLineOrginal.Mid(iLastIndex, iIndex - iLastIndex);
			WriteFile(hFile, strLog, strLog.GetLength(), &dwWritten, NULL);
a419 2

	EMULE_CATCH
a439 87
void CHTRichEditCtrl::AppendText(const CString &strText, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, DWORD dwFlags /*= 0*/)
{
	EMULE_TRY
	
	if (strText.IsEmpty())
		return;
	
	CString		strLineOrginal = strText, strLine = strText;
	int			iIndex = 0, iLastIndex = 0, iScheme, iLen, iLinkEnd;

//	Convert string to lower case only once
	strLine.MakeLower();
	while (strLineOrginal.GetLength() > iIndex)
	{
		for (iScheme = 0; iScheme < ARRSIZE(_apszSchemes); iScheme++)
		{
			iLen = _apszSchemes[iScheme].uiLen;
			iLinkEnd = iIndex + iLen;

			if ((strLine.GetLength() > iLinkEnd) &&
				(strLine.Mid(iIndex, iLen).Compare(_apszSchemes[iScheme].pszScheme) == 0))
			{
				while (strLine.GetLength() > iLinkEnd && strLine[iLinkEnd] != _T(' ')
					&& strLine[iLinkEnd] != _T('\n') && strLine[iLinkEnd] != _T('\\') &&
					strLine[iLinkEnd] != _T('\r') && strLine[iLinkEnd] != _T('\t'))
				{
					iLinkEnd++;
				}

				while ((iLinkEnd > iIndex + iLen) && 
					!((strLine[iLinkEnd - 1] >= _T('/') && strLine[iLinkEnd - 1] <= _T('9'))
					||(strLine[iLinkEnd - 1] >= _T('a') && strLine[iLinkEnd - 1] <= _T('z'))
					|| (strLine[iLinkEnd - 1] == _T('|'))))
				{
					iLinkEnd--;
				}

				if (iLinkEnd > iIndex + iLen)
				{
					if (iIndex > iLastIndex)
						AddLine(strLineOrginal.Mid(iLastIndex, iIndex - iLastIndex), crTextColor, crBackColor, dwFlags);
					AddLine(strLineOrginal.Mid(iIndex, iLinkEnd - iIndex), crTextColor, crBackColor, (dwFlags | HTC_LINK));
					iIndex = iLinkEnd;
					iLastIndex = iIndex;
				}
				else
					iIndex += iLen;

				break;
			}
		}
		if (iScheme >= ARRSIZE(_apszSchemes))
			iIndex++;
	}
	if (iLastIndex < iIndex)
		AddLine(strLineOrginal.Mid(iLastIndex, iIndex - iLastIndex), crTextColor, crBackColor, dwFlags);

	EMULE_CATCH
}

BOOL CHTRichEditCtrl::OnEnLink(NMHDR *pNMHDR, LRESULT *pResult)
{
	bool		bMsgHandled = false;
	ENLINK		*pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);

	*pResult = 0;

	if (pEnLink && pEnLink->msg == WM_LBUTTONDOWN)
	{
		CString			strUrl;

		GetTextRange(pEnLink->chrg.cpMin, pEnLink->chrg.cpMax, strUrl);

		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
		{
			if (strUrl.Left(_tcslen(_apszSchemes[i].pszScheme)).MakeLower() == CString(_apszSchemes[i].pszScheme))
			{
				ShellExecute(NULL, NULL, strUrl, NULL, NULL, SW_SHOWDEFAULT);
				*pResult = 1;
				bMsgHandled = true;
				break;
			}
		}
	}
	return bMsgHandled;
}

@


1.78
log
@opimized some more + minor fix
@
text
@d333 1
a333 1
					if ((strTemp.GetLength() > (iLinkEnd + 1)) &&
d419 1
a419 1
			if ((strLine.GetLength() > (iLinkEnd + 1)) &&
@


1.77
log
@Fixed 2 bugs created by previous optimization (v1.76);
Faster constant string length calculation.
@
text
@d315 3
d319 1
a319 2
			strTemp.Empty();
			es.dwCookie = (DWORD)&strTemp;
d323 4
a326 7
			LPCTSTR			psz = strTemp;
			LPCTSTR			pszStart = psz;
			CString			strLog, strURL;
			long			lLen;
			int				i;

			while (*psz != _T('\0'))
d328 1
a328 1
				for (i = 0; i < ARRSIZE(_apszSchemes); i++)
d330 5
a334 1
					if (CString(psz, _tcslen(_apszSchemes[i].pszScheme)).MakeLower() == CString(_apszSchemes[i].pszScheme))
d336 11
a346 10
						if (psz - pszStart > 0)
							strLog += CString(pszStart, psz - pszStart);
						lLen = _tcscspn(psz, _T(" \n\r\t\\"));
						while ((lLen > 0) && !((*(psz + lLen - 1) >= _T('/') && *(psz + lLen - 1) <= _T('9')) ||
							(*(psz + lLen - 1) >= _T('A') && *(psz + lLen - 1) <= _T('Z')) ||
							(*(psz + lLen - 1) >= _T('a') && *(psz + lLen - 1) <= _T('z')) ||
							(*(psz + lLen - 1) == _T('|'))))
							lLen --;
						strURL = (lLen == 0) ? CString(psz) : CString(psz, lLen);
						if (strURL.GetLength() > (long)_tcslen(_apszSchemes[i].pszScheme))
d348 7
d356 1
a356 1
							strLog += strURL;
d358 1
a358 1
							strLog += strURL;
d360 2
d364 2
a365 3
							strLog += strURL;
						psz += strURL.GetLength();
						pszStart = psz;
d369 2
a370 4
				if (strURL.IsEmpty())
					psz++;
				else
					strURL.Empty();
d372 2
a373 6

			if (pszStart != psz)
				strLog += pszStart;

			DWORD		dwWritten;

d407 2
a408 2
	CString	strLineOrginal = strText, strLine = strText;
	int		iIndex = 0, iScheme, iLen, iLinkEnd;
d412 1
a412 1
	while (!strLineOrginal.IsEmpty())
d417 1
a417 1
			iLinkEnd = 0;
d419 1
a419 1
			if ((strLine.GetLength() > (iIndex + iLen + 1)) &&
d422 1
a422 3
				iLinkEnd = iIndex + iLen;

				while (strLine.GetLength() > iLinkEnd + 1 && strLine[iLinkEnd] != _T(' ')
d439 2
a440 2
					if (iIndex > 0)
						AddLine(strLineOrginal.Left(iIndex), crTextColor, crBackColor, dwFlags);
d442 2
a443 4
				//	update both strings
					strLine = strLine.Mid(iLinkEnd);
					strLineOrginal = strLineOrginal.Mid(iLinkEnd);
					iIndex = 0;
d451 1
a451 1
		if (iLinkEnd == 0)
a452 6

		if (iIndex >= strLine.GetLength())
		{
			AddLine(strLineOrginal, crTextColor, crBackColor, dwFlags);
			break;
		}
d454 2
@


1.76
log
@futher speed optimization...
@
text
@d14 2
a15 1
	LPCTSTR pszScheme;
d18 12
a29 12
	{ _T("ed2k://") },
	{ _T("ftp.") },
	{ _T("ftp://") },
	{ _T("http://") },
	{ _T("https://") },
	{ _T("mailto:") },
	{ _T("www.") },
	{ _T("www1.") },
	{ _T("www2.") },
	{ _T("www3.") },
	{ _T("www4.") },
	{ _T("www5.") }
d401 1
a401 2
	CString		strLineOrginal = strText;
	int		iStrLength = 0;
d404 2
a407 8
		CString strLine = strText;

	//	convert string to lower case only once
		strLine.MakeLower();
		
	//	cache the string length
		iStrLength = strLine.GetLength();
	
d410 1
a410 1
			iLen = _tcslen(_apszSchemes[iScheme].pszScheme);
d413 1
a413 1
			if ((iStrLength > (iIndex + iLen + 1)) &&
d418 1
a418 1
				while (iStrLength > iLinkEnd + 1 && strLine[iLinkEnd] != _T(' ')
a426 1
					//|| (strLine[iLinkEnd - 1] >= _T('A') && strLine[iLinkEnd - 1] <= _T('Z'))
d438 1
a438 1
				//	update both string & length
d440 1
a440 1
					strLineOrginal= strLineOrginal.Mid(iLinkEnd);
d452 1
a452 1
		if (iIndex >= iStrLength)
@


1.75
log
@AppendText prototype rollback to have better performance;
Removed forgotten debug code; String processing optimization.
@
text
@d400 3
a402 2
	CString			strLine = strText;
	int				iIndex = 0, iScheme, iLen, iLinkEnd;
d404 1
a404 1
	while (!strLine.IsEmpty())
d406 8
d419 2
a420 2
			if ((strLine.GetLength() > (iIndex + iLen + 1)) &&
				(strLine.Mid(iIndex, iLen).MakeLower().Compare(_apszSchemes[iScheme].pszScheme) == 0))
d424 1
a424 1
				while (strLine.GetLength() > iLinkEnd + 1 && strLine[iLinkEnd] != _T(' ')
d427 1
d429 1
d433 1
a433 1
					|| (strLine[iLinkEnd - 1] >= _T('A') && strLine[iLinkEnd - 1] <= _T('Z'))
d436 1
d438 1
d443 3
a445 2
						AddLine(strLine.Left(iIndex), crTextColor, crBackColor, dwFlags);
					AddLine(strLine.Mid(iIndex, iLinkEnd - iIndex), crTextColor, crBackColor, (dwFlags | HTC_LINK));
d447 1
d459 1
a459 1
		if (iIndex >= strLine.GetLength())
d461 1
a461 1
			AddLine(strLine, crTextColor, crBackColor, dwFlags);
@


1.74
log
@changed some code
@
text
@d393 1
a393 1
void CHTRichEditCtrl::AppendText(CString strText, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, DWORD dwFlags /*= 0*/)
d410 2
a411 4
			CString strTemp1 = strLine.Mid(iIndex, iLen).MakeLower();
			CString strTemp2 = CString(_apszSchemes[iScheme].pszScheme, iLen);
			
			if (strLine.GetLength() > iIndex + iLen + 1 && strLine.Mid(iIndex, iLen).MakeLower() == CString(_apszSchemes[iScheme].pszScheme, iLen))
d447 1
a447 1
			strLine.Empty();
@


1.73
log
@some more fixes and changes
@
text
@d303 2
d371 2
d393 1
a393 1
void CHTRichEditCtrl::AppendText(const CString& strText, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, DWORD dwFlags /*= 0*/)
d395 2
d400 2
a401 5
	LPCTSTR			psz = strText;
	LPCTSTR			pszStart = psz;
	CString			strTemp;
	long			lLen;
	int				i;
d403 1
a403 1
	while (*psz != _T('\0'))
d405 1
a405 1
		for (i = 0; i < ARRSIZE(_apszSchemes); i++)
d407 7
a413 1
			if (CString(psz, _tcslen(_apszSchemes[i].pszScheme)).MakeLower() == CString(_apszSchemes[i].pszScheme))
d415 24
a438 2
				if (psz - pszStart > 0)
					AddLine(CString(pszStart, psz - pszStart), crTextColor, crBackColor, dwFlags);
a439 10
				lLen = _tcscspn(psz, _T(" \n\r\t\\"));
				while ((lLen > 0) && !((*(psz + lLen - 1) >= _T('/') && *(psz + lLen - 1) <= _T('9')) ||
						(*(psz + lLen - 1) >= _T('A') && *(psz + lLen - 1) <= _T('Z')) ||
						(*(psz + lLen - 1) >= _T('a') && *(psz + lLen - 1) <= _T('z')) ||
						(*(psz + lLen - 1) == _T('|'))))
					lLen--;
				strTemp = (lLen == 0) ? CString(psz) : CString(psz, lLen);
				AddLine(strTemp, crTextColor, crBackColor, (strTemp.GetLength() > (long)_tcslen(_apszSchemes[i].pszScheme)) ? (dwFlags | HTC_LINK) : dwFlags);
				psz += strTemp.GetLength();
				pszStart = psz;
d443 8
a450 4
		if (strTemp.IsEmpty())
			psz++;
		else
			strTemp.Empty();
d452 2
a453 2
	if (pszStart != psz)
		AddLine(pszStart, crTextColor, crBackColor, dwFlags);
@


1.72
log
@Color coded IRC channel title
@
text
@d75 1
a75 1
	m_strTitle = pszTitle;
@


1.71
log
@fix for previous commit
@
text
@d46 1
d158 1
a158 4
	{
		lTextEnd = GetTextLengthEx(GTL_PRECISE);
		SetSel(lTextEnd, lTextEnd);
	}
d214 2
a215 1
	menuLog.AddMenuTitle(GetResString(IDS_LOGENTRY));
d221 5
a225 2
	menuLog.AppendMenu(dwFlags, MP_SAVELOG, strBuffer + _T(" (.log)"));
	menuLog.AppendMenu(dwFlags, MP_SAVERTF, strBuffer + _T(" (.rtf)"));
a227 1
	menuLog.AppendMenu(dwFlags, MP_REMOVEALL, GetResString(IDS_PW_RESET));
d229 7
a235 3
	menuLog.AppendMenu(MF_SEPARATOR);
	menuLog.AppendMenu(MF_STRING | (m_bAutoScroll ? MF_CHECKED : MF_UNCHECKED), MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
	menuLog.AppendMenu(MF_STRING | (m_bWordWrap ? MF_CHECKED : MF_UNCHECKED), MP_WORDWRAP, GetResString(IDS_WORDWRAP));
@


1.70
log
@minor changes
@
text
@d51 1
a51 1
		m_lMaxBufSize = (32*1024);
d54 1
a54 1
		m_lMaxBufSize = (64*1024);
d58 1
a58 1
			m_lMaxBufSize = (64*1024);
d60 1
a60 1
			m_lMaxBufSize = (128*1024);
a102 1
	bool			bScroll = (_tcschr(pszMsg, _T('\n')) != NULL);
d126 1
a126 2
	if (bScroll)
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptOldPos);
d164 1
a164 1
	if (bScroll)
d166 1
a166 3
		if (m_bAutoScroll)
		{
			ScrollToLastLine();
d168 1
a168 1
			POINT			ptNewPos;
d170 2
a171 4
			SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptNewPos);
			ptOldPos.y = ptNewPos.y;
		}
		SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptOldPos);
d173 1
d259 1
a260 1
		SetTargetDevice(NULL, !m_bWordWrap);
@


1.69
log
@some fixes/changes
@
text
@d103 1
d127 2
a128 2

	SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptOldPos);
d166 1
a166 1
	if (m_bAutoScroll)
d168 3
a170 1
		ScrollToLastLine();
d172 1
a172 1
		POINT			ptNewPos;
d174 4
a177 2
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptNewPos);
		ptOldPos.y = ptNewPos.y;
a178 1
	SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptOldPos);
d303 1
a303 1
	CString			strLog, strTemp, strURL;
a310 3
			strTemp.Empty();
			strLog.Empty();

d313 1
d320 1
d322 1
a322 1
			bool			bFoundScheme;
d326 1
a326 3
				bFoundScheme = false;

				for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d339 10
a348 5
						strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"");
						strLog += strURL;
						strLog += _T("\"}}{\\fldrslt{{");
						strLog += strURL;
						strLog += _T("}}}}");
a350 1
						bFoundScheme = true;
d354 1
a354 1
				if (!bFoundScheme)
d356 2
d398 1
a398 1
	bool			bFoundScheme;
d402 1
a402 3
		bFoundScheme = false;

		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d414 1
a414 1
					lLen --;
d416 1
a416 1
				AddLine(strTemp, crTextColor, crBackColor, (dwFlags | HTC_LINK));
a418 1
				bFoundScheme = true;
d422 1
a422 1
		if (!bFoundScheme)
d424 2
@


1.68
log
@small improvement and some minor fixes
@
text
@a45 1
	m_bNoPaint = false;
d68 1
a68 1
	if (m_hCursor)
d77 1
a77 1
void CHTRichEditCtrl::Init()
d79 3
d83 2
a84 4
	if (g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() == _WINVER_95_)
		LimitText((64*1024)-1);
	else
		LimitText(128*1024);
a86 1
}
a87 5
int CHTRichEditCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CRichEditCtrl::OnCreate(lpCreateStruct) == -1)
		return -1;
	Init();
a90 8
LRESULT CHTRichEditCtrl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
	if ((message == WM_ERASEBKGND || message == WM_PAINT) && m_bNoPaint)
		return true;

	return CRichEditCtrl::WindowProc(message, wParam, lParam);
}

a106 2
	{
		m_bNoPaint = true;
a107 1
	}
a124 1
		lTextEnd = GetTextLengthEx(GTL_PRECISE);
d128 1
a128 3
	if (!bIsEndSel)
		SetSel(lTextEnd, lTextEnd);

a177 1
		m_bNoPaint = false;
d299 1
a299 1
	CString			strLog, strTemp;
d337 7
a343 10
						if (lLen == 0)
						{
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz) + _T("\"}}{\\fldrslt{{") + CString(psz) + _T("}}}}");
							psz += _tcslen(psz);
						}
						else
						{
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz, lLen) + _T("\"}}{\\fldrslt{{") + CString(psz, lLen) + _T("}}}}");
							psz += lLen;
						}
d350 1
a350 1
					psz = _tcsinc(psz);
d366 2
a367 1
	if (nChar == 'A' && (GetKeyState(VK_CONTROL) & 0x8000))
d369 8
a376 9
		//////////////////////////////////////////////////////////////////
		// Ctrl+A: Select all items
		SetSel(0, -1);
	}
	else if (nChar == 'C' && (GetKeyState(VK_CONTROL) & 0x8000))
	{
		//////////////////////////////////////////////////////////////////
		// Ctrl+C: Copy listview items to clipboard
		Copy();
d384 3
d389 1
d404 1
a404 1
				lLen = _tcscspn(psz, _T(" \n\r\t"));
d410 3
a412 10
				if (lLen == 0)
				{
					AddLine(psz, crTextColor, crBackColor, (dwFlags | HTC_LINK));
					psz += _tcslen(psz);
				}
				else
				{
					AddLine(CString(psz, lLen), crTextColor, crBackColor, (dwFlags | HTC_LINK));
					psz += lLen;
				}
d419 1
a419 1
			psz = _tcsinc(psz);
d575 1
a575 1
	strText.TrimRight('\n');
d643 1
a643 1
		strTemp.TrimRight('\n');
d747 1
a747 1
	if (strText.GetAt(0) != _T('<'))
@


1.67
log
@more fixes/changes
@
text
@d105 1
a105 1
void CHTRichEditCtrl::AddLine(LPCTSTR pszMsg, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, bool bLink /*= false*/, bool bBold /*= false*/, bool bItalic /*= false*/, bool bStrikeout /*= false*/, bool bUnderline /*= false*/)
d148 1
d152 3
a154 21
	if (bLink)
		cf2.dwEffects |= CFE_LINK;
	else
		cf2.dwEffects &= ~CFE_LINK;
	if (bBold)
		cf2.dwEffects |= CFE_BOLD;
	else if ((crTextColor & 0x00000002) == 0)
		cf2.dwEffects &= ~CFE_BOLD;
	if (bItalic)
		cf2.dwEffects |= CFE_ITALIC;
	else if ((crTextColor & 0x00000002) == 0)
		cf2.dwEffects &= ~CFE_ITALIC;
	if (bStrikeout)
		cf2.dwEffects |= CFE_STRIKEOUT;
	else if ((crTextColor & 0x00000002) == 0)
		cf2.dwEffects &= ~CFE_STRIKEOUT;
	if (bUnderline)
		cf2.dwEffects |= CFE_UNDERLINE;
	else if ((crTextColor & 0x00000002) == 0)
		cf2.dwEffects &= ~CFE_UNDERLINE;
	if (((crTextColor & 0x1000000) == 0) && ((crTextColor & 0xFFFFFF) != GetSysColor(COLOR_WINDOWTEXT)))
d159 1
a159 3
	else if ((crTextColor & 0x00000002) == 0)
		cf2.dwEffects |= CFE_AUTOCOLOR;
	if (((crBackColor & 0x1000000) == 0) && ((crBackColor & 0xFFFFFF) != GetSysColor(COLOR_WINDOW)))
d164 10
a173 2
	else if ((crTextColor & 0x00000002) == 0)
		cf2.dwEffects |= CFE_AUTOBACKCOLOR;
d406 1
a406 1
void CHTRichEditCtrl::AppendText(const CString& strText, COLORREF crTextColor /*= 0x1000000*/, COLORREF crBackColor /*= 0x1000000*/, bool bBold /*= false*/, bool bItalic /*= false*/, bool bStrikeout /*= false*/, bool bUnderline /*= false*/)
d422 1
a422 1
					AddLine(CString(pszStart, psz - pszStart), crTextColor, crBackColor, false, bBold, bItalic, bStrikeout, bUnderline);
d432 1
a432 1
					AddLine(psz, crTextColor, crBackColor, true, bBold, bItalic, bStrikeout, bUnderline);
d437 1
a437 1
					AddLine(CString(psz, lLen), crTextColor, crBackColor, true, bBold, bItalic, bStrikeout, bUnderline);
d449 1
a449 9
		AddLine(pszStart, crTextColor, crBackColor, false, bBold, bItalic, bStrikeout, bUnderline);
}

void CHTRichEditCtrl::AppendHyperLink(const CString& strText, const CString& strTitle, const CString& strCommand, const CString& strDirectory)
{
	ASSERT( strText.IsEmpty() );
	ASSERT( strTitle.IsEmpty() );
	ASSERT( strDirectory.IsEmpty() );
	AddLine(strCommand, 0x3000000, 0x1000000, true);
@


1.66
log
@Expanded [+]/[-] test area by 3 pixels from each side + minor change
@
text
@a48 1
	m_ptOldPos = CPoint(0, 0);
d99 3
a101 7
	switch (message)
	{
		case WM_ERASEBKGND:
		case WM_PAINT:
			if (m_bNoPaint)
				return TRUE;
	}
d112 1
a112 1
	long		lStartChar, lEndChar, lTextEnd = GetTextLengthEx(GTL_DEFAULT);
d118 1
d142 1
a142 1
		lTextEnd = GetTextLengthEx(GTL_DEFAULT);
d145 3
a147 2
	SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&m_ptOldPos);
	SetSel(lTextEnd, lTextEnd);
d190 1
a190 1
		lTextEnd = GetTextLengthEx(GTL_DEFAULT);
d203 1
a203 1
		m_ptOldPos.y = ptNewPos.y;
d205 1
a205 1
	SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&m_ptOldPos);
a242 3
	if (m_bWordWrap)
		SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&m_ptOldPos);

@


1.65
log
@minor fixes
@
text
@d49 1
a121 1
	POINT			ptOldPos;
d149 1
a149 1
	SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptOldPos);
d206 1
a206 1
		ptOldPos.y = ptNewPos.y;
d208 1
a208 1
	SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptOldPos);
d246 3
@


1.64
log
@minor changes; removed unused functions
@
text
@d810 5
a814 1
	cf2.dwMask = CFM_BACKCOLOR | CFM_BOLD | /*CFM_CHARSET |*/ CFM_COLOR | CFM_FACE | CFM_ITALIC | CFM_LINK | CFM_SIZE | CFM_STRIKEOUT | CFM_UNDERLINE;
@


1.63
log
@minor changes
@
text
@d122 1
a122 1
	CHARFORMAT2		cf;
d151 3
a153 3
	memzero(&cf, sizeof cf);
	cf.cbSize = sizeof cf;
	GetSelectionCharFormat(cf);
d155 1
a155 1
		cf.dwEffects |= CFE_LINK;
d157 1
a157 1
		cf.dwEffects &= ~CFE_LINK;
d159 1
a159 1
		cf.dwEffects |= CFE_BOLD;
d161 1
a161 1
		cf.dwEffects &= ~CFE_BOLD;
d163 1
a163 1
		cf.dwEffects |= CFE_ITALIC;
d165 1
a165 1
		cf.dwEffects &= ~CFE_ITALIC;
d167 1
a167 1
		cf.dwEffects |= CFE_STRIKEOUT;
d169 1
a169 1
		cf.dwEffects &= ~CFE_STRIKEOUT;
d171 1
a171 1
		cf.dwEffects |= CFE_UNDERLINE;
d173 1
a173 1
		cf.dwEffects &= ~CFE_UNDERLINE;
d176 2
a177 2
		cf.dwEffects &= ~CFE_AUTOCOLOR;
		cf.crTextColor = (crTextColor & 0xFFFFFF);
d180 1
a180 1
		cf.dwEffects |= CFE_AUTOCOLOR;
d183 2
a184 2
		cf.dwEffects &= ~CFE_AUTOBACKCOLOR;
		cf.crBackColor = (crBackColor & 0xFFFFFF);
d187 2
a188 2
		cf.dwEffects |= CFE_AUTOBACKCOLOR;
	SetSelectionCharFormat(cf);
a311 21
CString CHTRichEditCtrl::GetLastLogEntry()
{
	CString			strLog;
	long			lLastLine = GetLineCount() - 2;

	if (lLastLine >= 0)
	{
		GetLine(lLastLine, strLog.GetBuffer(1024), 1024);
		strLog.ReleaseBuffer();
	}
	return strLog;
}

CString CHTRichEditCtrl::GetAllLogEntries()
{
	CString			strLog;

	GetWindowText(strLog);
	return strLog;
}

d349 1
a349 1
			StreamOut(SF_RTF,es);
d374 1
a374 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz) + _T("\"}}{\\fldrslt{{\\ul") + CString(psz) + _T("}}}}");
d379 1
a379 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz, lLen) + _T("\"}}{\\fldrslt{{\\ul") + CString(psz, lLen) + _T("}}}}");
d808 2
a809 2
	memzero(&cf2, sizeof(CHARFORMAT2));
	cf2.cbSize = sizeof(CHARFORMAT2);
a833 6
}

CFont* CHTRichEditCtrl::GetFont() const
{
	ASSERT(0);
	return NULL;
@


1.62
log
@Removed CPreparedRTFText class
@
text
@d174 1
a174 1
	if (((crTextColor & 0x1000000) == 0) && ((crTextColor & 0xFFFFFF) != COLOR_WINDOWTEXT))
d181 1
a181 1
	if (((crBackColor & 0x1000000) == 0) && ((crBackColor & 0xFFFFFF) != COLOR_WINDOW))
d826 1
a826 1
	CHARFORMAT		cf = {0};
d829 5
a833 17

	cf.cbSize = sizeof cf;
	cf.dwMask = CFM_COLOR | CFM_BACKCOLOR | CFM_LINK | CFM_BOLD | CFM_ITALIC | CFM_UNDERLINE | CFM_STRIKEOUT;

	if (lf.lfWeight == FW_BOLD)
		cf.dwEffects |= CFE_BOLD;

	if (lf.lfItalic != 0)
		cf.dwEffects |= CFE_ITALIC;

	if (lf.lfUnderline != 0)
		cf.dwEffects |= CFE_UNDERLINE;

	if (lf.lfStrikeOut != 0)
		cf.dwEffects |= CFE_STRIKEOUT;

	cf.dwMask |= CFM_SIZE;
a835 1
	int				iPointSize = -MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
d837 1
a837 1
	cf.yHeight = iPointSize * 20;
d840 3
a842 4
	cf.dwMask |= CFM_FACE;
	cf.bPitchAndFamily = lf.lfPitchAndFamily;
	_tcsncpy(cf.szFaceName, lf.lfFaceName, ARRSIZE(cf.szFaceName));
	cf.szFaceName[ARRSIZE(cf.szFaceName) - 1] = _T('\0');
d846 3
a848 4
	//cf.dwMask |= CFM_CHARSET;
	//cf.bCharSet = lf.lfCharSet;
	cf.yOffset = 0;
	VERIFY( SetDefaultCharFormat(cf) );
@


1.61
log
@Fixed tooltips foreground color
@
text
@a30 2
CString strRtfHeader = _T("{\\rtf\\ansi");

a46 1
	m_pPreparedText = NULL;
a86 1
	FlushBuffer();
d109 1
a109 25
void CHTRichEditCtrl::FlushBuffer()
{
	if (m_astrBuff.GetSize() > 0)
	{
		for (int i = 0; i < m_astrBuff.GetSize(); i++)
			AddLine(m_astrBuff[i]);
		m_astrBuff.RemoveAll();
	}
}

void CHTRichEditCtrl::AddEntry(LPCTSTR pszMsg)
{
	CString			strLine(pszMsg);

	strLine += _T("\n");
	if (m_hWnd == NULL)
		m_astrBuff.Add(strLine);
	else
	{
		FlushBuffer();
		AddLine(strLine);
	}
}

void CHTRichEditCtrl::AddLine(LPCTSTR pszMsg, bool bLink /*= false*/, COLORREF crColor /*= 0x1000000*/)
d152 1
a154 2
	{
		cf.dwMask |= CFM_LINK;
d156 19
a174 2
	}
	if (((crColor & 0x1000000) == 0) && ((crColor & 0xFFFFFF) != COLOR_WINDOWTEXT))
a175 1
		cf.dwMask |= CFM_COLOR;
d177 1
a177 1
		cf.crTextColor = (crColor & 0xFFFFFF);
d179 1
a179 1
	else
d181 7
a237 10
	if (m_pPreparedText != NULL)
	{
		m_pPreparedText->m_strRtfHeader = strRtfHeader;
		m_pPreparedText->m_strText.Empty();
		m_pPreparedText->m_lTextEnd = 0;
		m_pPreparedText->m_lLastTextPos = 0;
		m_pPreparedText->m_aiLinkStart.RemoveAll();
		m_pPreparedText->m_aiLinkSize.RemoveAll();
	}
	m_astrBuff.RemoveAll();
d265 2
a266 10
	if (m_pPreparedText != NULL)
	{
		menuLog.AppendMenu(MF_STRING | (m_pPreparedText->m_bAutoScroll ? MF_CHECKED : MF_UNCHECKED), MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
		menuLog.AppendMenu(MF_STRING | (m_pPreparedText->m_bWordWrap ? MF_CHECKED : MF_UNCHECKED), MP_WORDWRAP, GetResString(IDS_WORDWRAP));
	}
	else
	{
		menuLog.AppendMenu(MF_STRING | (m_bAutoScroll ? MF_CHECKED : MF_UNCHECKED), MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
		menuLog.AppendMenu(MF_STRING | (m_bWordWrap ? MF_CHECKED : MF_UNCHECKED), MP_WORDWRAP, GetResString(IDS_WORDWRAP));
	}
d292 1
a292 4
		if (m_pPreparedText != NULL)
			m_pPreparedText->m_bAutoScroll = !m_pPreparedText->m_bAutoScroll;
		else
			m_bAutoScroll = !m_bAutoScroll;
d295 2
a296 10
		if (m_pPreparedText != NULL)
		{
			m_pPreparedText->m_bWordWrap = !m_pPreparedText->m_bWordWrap;
			SetTargetDevice(NULL, !m_pPreparedText->m_bWordWrap);
		}
		else
		{
			m_bWordWrap = !m_bWordWrap;
			SetTargetDevice(NULL, !m_bWordWrap);
		}
a373 1
			CString			strColor;
a386 1
						strColor.Format(_T("\\cf%i "), m_pPreparedText->GetColorIndex(strLog, RGB(0, 0, 255)));
d395 1
a395 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz) + _T("\"}}{\\fldrslt{{\\ul") + strColor + CString(psz) + _T("}}}}");
d400 1
a400 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz, lLen) + _T("\"}}{\\fldrslt{{\\ul") + strColor + CString(psz, lLen) + _T("}}}}");
d441 1
a441 1
void CHTRichEditCtrl::AppendText(const CString& strText, COLORREF crColor /*= 0x1000000*/)
d457 1
a457 1
					AddLine(CString(pszStart, psz - pszStart), false, crColor);
d467 1
a467 1
					AddLine(psz, true);
d472 1
a472 1
					AddLine(CString(psz, lLen), true);
d484 1
a484 1
		AddLine(pszStart, false, crColor);
d492 1
a492 1
	AddLine(strCommand, true);
a822 160
CPreparedRTFText* CHTRichEditCtrl::GetHyperText()
{
	return m_pPreparedText;
}

void CHTRichEditCtrl::SetHyperText(CPreparedRTFText* pPreparedText)
{
	UINT		iFlags = 0;
	
	if (m_pPreparedText == NULL)
		iFlags |= 0x00000003;
	else if (m_pPreparedText != pPreparedText)
	{
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&m_pPreparedText->m_ptLastPos);
		GetSel(m_pPreparedText->m_lLastStartChar, m_pPreparedText->m_lLastEndChar);
		iFlags |= 0x00000002;
	}
	m_pPreparedText = pPreparedText;
	UpdateSize(iFlags);
}

void CHTRichEditCtrl::UpdateSize(UINT iFlags)
{
	if (m_pPreparedText == NULL)
		return;

	POINT			ptOldPos;
	long			lStartChar, lEndChar, lTextEnd;
	bool			bIsVisible = IsWindowVisible();
	CString			strOutText;
	SETTEXTEX		st = {0};
	long			lLen = m_pPreparedText->m_strText.GetLength();

	if (lLen >= m_lMaxBufSize)
	{
		lLen = m_pPreparedText->m_strText.Find(_T("\n\\par"), (m_lMaxBufSize >> 2)) + 5;

		int		iLen = m_pPreparedText->GetUnformattedLength(m_pPreparedText->m_strRtfHeader, m_pPreparedText->m_strText.Left(lLen));
		
		m_pPreparedText->m_strText.Delete(0, lLen);
		
		(m_pPreparedText->m_lTextEnd >= iLen) ?	m_pPreparedText->m_lTextEnd -= iLen : m_pPreparedText->m_lTextEnd = 0;
		m_pPreparedText->m_lLastTextPos = 0;

		if (m_pPreparedText->m_aiLinkStart.GetSize() > 0)
		{
			int			i = 0;

			while (i < m_pPreparedText->m_aiLinkStart.GetSize())
			{
				if (m_pPreparedText->m_aiLinkStart[i] >= (unsigned int)iLen)
				{
					m_pPreparedText->m_aiLinkStart[i] -= iLen;
					i++;
				}
				else
				{
					m_pPreparedText->m_aiLinkStart.RemoveAt(i);
					m_pPreparedText->m_aiLinkSize.RemoveAt(i);
				}
			}
		}
		iFlags |= 0x00000004;
	}
	
	if (bIsVisible)
	{
		m_bNoPaint = true;
		SetRedraw(false);
	}

	((iFlags & 0x00000003) == 0) ? lTextEnd = GetTextLengthEx(GTL_DEFAULT) : lTextEnd = m_pPreparedText->m_lTextEnd;
		
	if ((iFlags & 0x00000002) != 0)
	{
        ptOldPos = m_pPreparedText->m_ptLastPos;
		SetTargetDevice(NULL, !m_pPreparedText->m_bWordWrap);
		m_pPreparedText->m_lLastTextPos = 0;
		
		if (m_pPreparedText->m_lLastStartChar == m_pPreparedText->m_lLastEndChar)
			lStartChar = lEndChar = lTextEnd;
		else
		{
			lStartChar = m_pPreparedText->m_lLastStartChar;
			lEndChar = m_pPreparedText->m_lLastEndChar;
		}
	}
	else
	{
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptOldPos);
		GetSel(lStartChar, lEndChar);
	}
	
	bool		bIsEndSel = (lStartChar == lEndChar && lStartChar == lTextEnd);

	strOutText = m_pPreparedText->m_strRtfHeader;
	strOutText += _T("\\rtlch");
	if (m_pPreparedText->m_lLastTextPos == 0)
	{
		strOutText += m_pPreparedText->m_strText;
		strOutText += _T("\n\\par}");
		st.flags = ST_DEFAULT;
	}
	else
	{
		strOutText += m_pPreparedText->m_strText.Mid(m_pPreparedText->m_lLastTextPos);
		strOutText += _T("}");
		st.flags = ST_SELECTION;
		SetSel(lTextEnd, lTextEnd);
	}
	st.codepage = CP_ACP;
	SendMessage(EM_SETTEXTEX, (WPARAM)&st, (LPARAM)(LPCTSTR)strOutText);

	if (m_pPreparedText->m_aiLinkStart.GetSize() > 0)
	{
		CHARFORMAT2		cf;

		for (int i = 0; i < m_pPreparedText->m_aiLinkStart.GetSize(); i++)
		{
			SetSel(m_pPreparedText->m_aiLinkStart[i], m_pPreparedText->m_aiLinkStart[i] + m_pPreparedText->m_aiLinkSize[i]);
			memzero(&cf, sizeof cf);
			GetSelectionCharFormat(cf);
			cf.dwMask |= CFM_LINK;
			cf.dwEffects |= CFE_LINK;
			SetSelectionCharFormat(cf);
		}
	}

	m_pPreparedText->m_lLastTextPos = m_pPreparedText->m_strText.GetLength();
	m_pPreparedText->m_lTextEnd = GetTextLengthEx(GTL_DEFAULT);

	if (bIsEndSel)
		lStartChar = lEndChar = m_pPreparedText->m_lTextEnd;
	SetSel(lStartChar, lEndChar);
	m_pPreparedText->m_lLastStartChar = lStartChar;
	m_pPreparedText->m_lLastEndChar = lEndChar;

	if (m_pPreparedText->m_bAutoScroll)
	{
		ScrollToLastLine();
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&m_pPreparedText->m_ptLastPos);
		ptOldPos.y = m_pPreparedText->m_ptLastPos.y;
	}
	SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptOldPos);
	m_pPreparedText->m_ptLastPos = ptOldPos;

	if ((iFlags & 0x00000004) != 0 && !m_pPreparedText->m_bAutoScroll)
	{
		SendMessage(WM_VSCROLL, SB_LINEDOWN);
		SendMessage(WM_VSCROLL, SB_LINEUP);
	}

	if (bIsVisible)
	{
		m_bNoPaint = false;
		SetRedraw();
		Invalidate();
	}
}

d825 2
a826 1
	LOGFONT		lf = {0};
a829 2
	CHARFORMAT	cf = {0};

d831 1
d833 2
a834 2
	cf.dwMask |= CFM_BOLD;
	cf.dwEffects |= (lf.lfWeight == FW_BOLD) ? CFE_BOLD : 0;
d836 2
a837 2
	cf.dwMask |= CFM_ITALIC;
	cf.dwEffects |= (lf.lfItalic) ? CFE_ITALIC : 0;
d839 2
a840 2
	cf.dwMask |= CFM_UNDERLINE;
	cf.dwEffects |= (lf.lfUnderline) ? CFE_UNDERLINE : 0;
d842 2
a843 2
	cf.dwMask |= CFM_STRIKEOUT;
	cf.dwEffects |= (lf.lfStrikeOut) ? CFE_STRIKEOUT : 0;
d847 2
a848 2
	HDC			hDC = ::GetDC(NULL);
	int			iPointSize = -MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
d876 1
a876 163
}

///////////////////////////////////////////////////////////////////////////////
// CPreparedRTFText

CPreparedRTFText::CPreparedRTFText()
{
	m_strRtfHeader = strRtfHeader;
	m_strText.Empty();
	m_lTextEnd = 0;
	m_lLastTextPos = 0;
	m_lLastStartChar = 0;
	m_lLastEndChar = 0;
	m_aiLinkStart.RemoveAll();
	m_aiLinkSize.RemoveAll();
	m_bAutoScroll = true;
	m_bWordWrap = true;
	m_ptLastPos = CPoint(0, 0);
}

CPreparedRTFText::~CPreparedRTFText()
{
}

int CPreparedRTFText::GetColorIndex(CString& strTable, COLORREF crColor)
{
	int			iColor = 0;
	COLORREF	crDefault = GetSysColor(((crColor & 0x2000000) == 0) ? COLOR_WINDOWTEXT : COLOR_WINDOW);

	if (((crColor & 0x1000000) == 0) && ((crColor & 0xFFFFFF) != crDefault))
	{
		int			iTableStart = strTable.Find(_T("\n{\\colortbl ;"));
		CString		strColor;

		strColor.Format(_T("\\red%i\\green%i\\blue%i;"), GetRValue(crColor), GetGValue(crColor), GetBValue(crColor));
		if (iTableStart == -1)
		{
			strTable += _T("\n{\\colortbl ;") + strColor + _T("}\n");
			iColor ++;
		}
		else
		{
			int			iTableEnd = strTable.Find(_T(";}"), iTableStart + 1);

			while ((iTableStart < iTableEnd) && (iTableStart != -1))
			{
				iColor ++;
				iTableStart = strTable.Find(_T("\\red"), iTableStart + 1);
				if ((iTableStart >= 0) && (strTable.Mid(iTableStart, strColor.GetLength()) == strColor))
					return iColor;
			}
			strTable.Insert(iTableEnd + 1, strColor);
		}
	}
	return iColor;
}

int CPreparedRTFText::GetUnformattedLength(CString& strTable, CString& strText)
{
	CString			strClean = strText, strColor;
	int				iTableStart = strTable.Find(_T("\n{\\colortbl ;"));
	int				iTableEnd = strTable.Find(_T(";}"), iTableStart + 1);
	int				iColor = 0;

	strClean.Replace(_T("\n\\par"), _T("\n"));
	strClean.Replace(_T("\\b0 "), _T(""));
	strClean.Replace(_T("\\b "), _T(""));
	strClean.Replace(_T("\\i0 "), _T(""));
	strClean.Replace(_T("\\i "), _T(""));
	strClean.Replace(_T("\\ul0 "), _T(""));
	strClean.Replace(_T("\\ul "), _T(""));

	while ((iTableStart < iTableEnd) && (iTableStart != -1))
	{
		iTableStart = strTable.Find(_T("\\red"), iTableStart + 1);
		strColor.Format(_T("\\cf%i "), iColor);
		strClean.Replace(strColor, _T(""));
		strColor.Format(_T("\\highlight%i "), iColor);
		strClean.Replace(strColor, _T(""));
		iColor ++;
	}
	strClean.Replace(_T("\\}"),_T("}"));
	strClean.Replace(_T("\\{"),_T("{"));
	strClean.Replace(_T("\\\\"),_T("\\"));

	return (int)strClean.GetLength();
}

void CPreparedRTFText::AppendText(const CString& strLine, COLORREF crColor /*= 0x1000000*/)
{
	CString			strColor, strText = strLine;

	strColor.Format(_T("\\cf%i "), GetColorIndex(m_strRtfHeader, crColor));
	if ((crColor & 0x4000000) == 0)
		strText.Replace(_T("\\"),_T("\\\\"));
	strText.Replace(_T("{"),_T("\\{"));
	strText.Replace(_T("}"),_T("\\}"));
	strText.Replace(_T("\n"),_T("\n\\par"));
	strText.Insert(0, strColor);

	LPCTSTR			psz = strText;
	LPCTSTR			pszStart = psz;
	bool			bFoundScheme;
	long			lLen;
	CString			strTemp, strColor2;

	while (*psz != _T('\0'))
	{
		bFoundScheme = false;

		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
		{
			if (CString(psz, _tcslen(_apszSchemes[i].pszScheme)).MakeLower() == CString(_apszSchemes[i].pszScheme))
			{
				if (psz - pszStart > 0)
				{
					strTemp = CString(pszStart, psz - pszStart);
					m_lTextEnd += GetUnformattedLength(m_strRtfHeader, strTemp);
					m_strText += strTemp;
				}
				strColor2.Format(_T("\\cf%i "), GetColorIndex(m_strRtfHeader, RGB(0, 0, 255)));

				lLen = _tcscspn(psz, _T(" \n\r\t\\"));
				while ((lLen > 0) && !((*(psz + lLen - 1) >= _T('/') && *(psz + lLen - 1) <= _T('9')) ||
						(*(psz + lLen - 1) >= _T('A') && *(psz + lLen - 1) <= _T('Z')) ||
						(*(psz + lLen - 1) >= _T('a') && *(psz + lLen - 1) <= _T('z')) ||
						(*(psz + lLen - 1) == _T('|'))))
					lLen --;
				if (lLen == 0)
				{
					m_aiLinkStart.Add(m_lTextEnd);
					m_aiLinkSize.Add(_tcslen(psz));
					m_lTextEnd += _tcslen(psz);
					m_strText += _T("\\ul ") + strColor2 + CString(psz) + _T("\\ul0 ") + strColor;
					psz += _tcslen(psz);
				}
				else
				{
					m_aiLinkStart.Add(m_lTextEnd);
					m_aiLinkSize.Add(lLen);
					m_lTextEnd += lLen;
					m_strText += _T("\\ul ") + strColor2 + CString(psz, lLen) + _T("\\ul0 ") + strColor;
					psz += lLen;
				}
				pszStart = psz;
				bFoundScheme = true;
				break;
			}
		}
		if (!bFoundScheme)
			psz = _tcsinc(psz);
	}
	if (pszStart != psz)
	{
		m_lTextEnd += GetUnformattedLength(m_strRtfHeader, CString(pszStart));
		m_strText += pszStart;
	}
}

const CString& CPreparedRTFText::GetText()
{
	return m_strText;
}
@


1.60
log
@Fixed IRC Status sorting + minor other fix
@
text
@d714 1
a714 6
			
			if (iRtfColor == 0)
				strColor = _T(" <ct>");
			else
				strColor.Format(_T(" <ct=0x%06x>"), lTTColor);

d716 1
a716 1
			iRtfColor ++;
@


1.59
log
@IRC channel messages now supports background color coded messages (Thanks SyruS!);
Added a Word Wrap context menu option to logs, IRC & messages;
Fixed category tabs padding (Mantis bug #0000415);
Improved logs, IRC & messages code + formatting & name changes
@
text
@a151 2
	m_bNoPaint = true;

d153 2
d156 1
a215 1
	m_bNoPaint = false;
d218 1
d927 1
a929 2
	m_bNoPaint = true;

d931 2
d934 1
d1011 6
a1016 1
	m_bNoPaint = false;
d1019 1
@


1.58
log
@minor fix
@
text
@d47 1
d55 1
a55 1
		m_iMaxBufSize = (32*1024);
d58 1
a58 1
		m_iMaxBufSize = (64*1024);
d62 1
a62 1
			m_iMaxBufSize = (64*1024);
d64 1
a64 1
			m_iMaxBufSize = (128*1024);
a66 1
	m_iTextEnd = 0;
d88 2
a105 2
			if (m_bNoPaint)
				return TRUE;
d137 1
a137 1
void CHTRichEditCtrl::AddLine(LPCTSTR pszMsg, bool bLink, COLORREF crColor)
d139 1
a139 1
	long		iMsgLen = _tcslen(pszMsg);
d141 1
a141 1
	if (iMsgLen == 0)
d144 1
a144 2
	// Get cursor position
	long		iStartChar, iEndChar;
d146 1
a146 1
	GetSel(iStartChar, iEndChar);
d148 3
a150 1
	long		iOldTextEnd = m_iTextEnd;
a151 1
	// Reduce flicker by ignoring WM_PAINT
a153 2
	bool		bIsVisible = IsWindowVisible();

d157 1
a157 1
	if (m_iTextEnd >= m_iMaxBufSize)
d159 1
a159 1
		CString			strLog;
d163 1
a163 1
		long			len = strLog.Find(_T('\n'), m_iMaxBufSize >> 3);
d165 4
a168 3
		if (len == -1)
			len = m_iMaxBufSize >> 3;
		strLog.Truncate(len);
d170 2
a171 2
		len = strLog.GetLength();
		SetSel(0, len);
d173 1
a173 1
		m_iTextEnd -= len;
a175 4
	// Remember where we are
	//int nFirstLine = !m_bAutoScroll ? GetFirstVisibleLine() : 0;
	POINT ptOldPos;

d177 1
a177 7

	// Select at the end of text and replace the selection
	// This is a very fast way to add text to an edit control
	SetSel(m_iTextEnd, m_iTextEnd);

	CHARFORMAT2			cf;

d185 1
a185 1
	if ((crColor != -1) && (crColor != GetSysColor(COLOR_WINDOWTEXT)))
d189 1
a189 1
		cf.crTextColor = crColor;
d196 5
a200 3
	m_iTextEnd += iMsgLen;
	if (iStartChar == iOldTextEnd && iOldTextEnd == iEndChar)
		SetSel(m_iTextEnd, m_iTextEnd);
d202 2
a203 1
		SetSel(iStartChar, iEndChar);
d225 5
a229 4
	//LineScroll(GetLineCount());
	long iFirstVisible = GetFirstVisibleLine();
	if (iFirstVisible > 0)
		LineScroll(-iFirstVisible, 0);
d232 1
a232 2
	if (m_pPreparedText == NULL)
		SendMessage(WM_VSCROLL, SB_LINEUP);
d236 1
a236 3
		int			iPos = GetScrollPos(SB_VERT);

		SendMessage(WM_VSCROLL, MAKELONG(SB_THUMBPOSITION, iPos));
d243 1
a243 1
	if (m_pPreparedText)
d245 4
a248 3
		m_pPreparedText->m_sRtfHeader = strRtfHeader;
		m_pPreparedText->m_sText.Empty();
		m_pPreparedText->m_iTextEnd = 0;
a252 1
	m_iTextEnd = 0;
a254 9
	switch(g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctrlBoxSwitcher.GetCurSel())
	{
		case 0:
		case 2:
			g_eMuleApp.m_pdlgEmule->m_ctlStatusBar.SetText(_T(""),SB_MESSAGETEXT,0);
			break;
		default:
			break;
	}
d280 10
a289 1
	menuLog.AppendMenu(MF_STRING | (m_bAutoScroll ? MF_CHECKED : MF_UNCHECKED), MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
a292 1
//	Menu objects are destroyed in their destructor
d300 1
a300 1
		CopySelectedItems();
d309 1
a309 1
		SelectAllItems();
d315 16
a330 1
		m_bAutoScroll = !m_bAutoScroll;
d349 1
a349 1
	long			iLastLine = GetLineCount() - 2;
d351 1
a351 1
	if (iLastLine >= 0)
d353 1
a353 1
		GetLine(iLastLine, strLog.GetBuffer(1024), 1024);
a366 5
void CHTRichEditCtrl::SelectAllItems()
{
	SetSel(0, -1);
}

d371 1
a371 1
	if (DialogBrowseFile(strTemp, _T("Log (*.log)|*.log||"), m_strTitle + _T(".log"), 0, FALSE))
d373 1
a373 1
		HANDLE		hFile = CreateFile(strTemp, GENERIC_WRITE, 0,NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE, NULL);
d378 4
a381 2
			DWORD written;
			WriteFile(hFile, strLog, strLog.GetLength(), &written, NULL);
d391 1
a391 1
	if (DialogBrowseFile(strTemp, _T("Rich Text Format (RTF)|*.rtf||"), m_strTitle + _T(".rtf"), 0, FALSE))
d393 1
a393 1
		HANDLE		hFile = CreateFile(strTemp, GENERIC_WRITE,0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_ARCHIVE,NULL);
d408 2
a409 2
			CString			sColor;
			long			iLen;
d422 8
a429 8
						m_pPreparedText->CheckTable(sColor, strLog, RGB(0, 0, 255));
						iLen = _tcscspn(psz, _T(" \n\r\t\\"));
						while ((iLen > 0) && !((*(psz + iLen - 1) >= _T('/') && *(psz + iLen - 1) <= _T('9')) ||
							(*(psz + iLen - 1) >= _T('A') && *(psz + iLen - 1) <= _T('Z')) ||
							(*(psz + iLen - 1) >= _T('a') && *(psz + iLen - 1) <= _T('z')) ||
							(*(psz + iLen - 1) == _T('|'))))
							iLen --;
						if (iLen == 0)
d431 1
a431 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz) + _T("\"}}{\\fldrslt{{\\ul") + sColor + CString(psz) + _T("}}}}");
d436 2
a437 2
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz, iLen) + _T("\"}}{\\fldrslt{{\\ul") + sColor + CString(psz, iLen) + _T("}}}}");
							psz += iLen;
d451 1
a451 1
			DWORD		written;
d453 1
a453 1
			WriteFile(hFile, strLog, strLog.GetLength(), &written, NULL);
a458 5
void CHTRichEditCtrl::CopySelectedItems()
{
	Copy();
}

d465 1
a465 1
		SelectAllItems();
d471 1
a471 1
		CopySelectedItems();
d477 1
a477 1
void CHTRichEditCtrl::AppendText(const CString& sText, COLORREF crColor)
d479 1
a479 1
	LPCTSTR			psz = sText;
d481 1
a481 1
	long			iLen;
a491 1
				// output everything before the URL
d495 7
a501 9
				// search next space or EOL
				iLen = _tcscspn(psz, _T(" \n\r\t"));

				while ((iLen > 0) && !((*(psz + iLen - 1) >= _T('/') && *(psz + iLen - 1) <= _T('9')) ||
						(*(psz + iLen - 1) >= _T('A') && *(psz + iLen - 1) <= _T('Z')) ||
						(*(psz + iLen - 1) >= _T('a') && *(psz + iLen - 1) <= _T('z')) ||
						(*(psz + iLen - 1) == _T('|'))))
					iLen --;
				if (iLen == 0)
d508 2
a509 2
					AddLine(CString(psz, iLen), true);
					psz += iLen;
d523 1
a523 1
void CHTRichEditCtrl::AppendHyperLink(const CString& sText, const CString& sTitle, const CString& sCommand, const CString& sDirectory)
d525 4
a528 4
	ASSERT( sText.IsEmpty() );
	ASSERT( sTitle.IsEmpty() );
	ASSERT( sDirectory.IsEmpty() );
	AddLine(sCommand, true);
a543 2
		// check if that "URL" has a valid URL scheme. if it does not have, pass that notification up to the
		// parent window which may interpret that "URL" in some other way.
d550 1
a550 1
				bMsgHandled = true; // do not route this message to any parent
d585 4
a588 6
		CStringArray	astrColorsRtf;
		CStringArray	astrColorsHtml;
		int				iRtfColor = 0;
		long			iHtmlColor = 0;
		int				iColorEnd;
		CString			sColor;
d593 4
a596 4
			sColor.Format(_T("\\cf%i"), iRtfColor);
			astrColorsRtf.Add(sColor);
			sColor.Format(_T(" </font><font color=\"#%06x\">"), iHtmlColor);
			astrColorsHtml.Add(sColor);
d603 1
a603 1
					iHtmlColor = (_tstoi(strTemp.Mid(iTableStart + 4, iColorEnd - (iTableStart + 4))) << 16);
d608 1
a608 1
						iHtmlColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 8);
d612 1
a612 1
							iHtmlColor += _tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart));
d633 1
a633 1
		long			iLen;
d659 2
a660 3
					iLen = _tcscspn(psz, _T(" \n"));

					if (iLen == 0)
d664 1
a664 1
						psz += iLen;
d678 3
a680 4
	int			iStrEnd = strText.ReverseFind(_T('}'));

	if (iStrEnd != -1)
		strText.Truncate(iStrEnd);
d703 4
a706 6
		CStringArray	astrColorsRtf;
		CStringArray	astrColorsTT;
		int				iRtfColor = 0;
		long			iHtmlColor = 0;
		int				iColorEnd;
		CString			sColor;
d711 2
a712 2
			sColor.Format(_T("\\cf%i"), iRtfColor);
			astrColorsRtf.Add(sColor);
d715 1
a715 1
				sColor = _T(" <ct>");
d717 1
a717 1
				sColor.Format(_T(" <ct=0x%06x>"), iHtmlColor);
d719 1
a719 1
			astrColorsTT.Add(sColor);
d726 1
a726 1
					iHtmlColor = _tstoi(strTemp.Mid(iTableStart + 4, iColorEnd - (iTableStart + 4)));
d731 1
a731 1
						iHtmlColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 8);
d735 1
a735 1
							iHtmlColor += (_tstoi(strTemp.Mid(iTableStart, iColorEnd - iTableStart)) << 16);
d807 1
a807 1
		long		iLen;
d833 2
a834 3
					iLen = _tcscspn(psz, _T(" \n"));

					if (iLen == 0)
d838 1
a838 1
						psz += iLen;
d869 1
a869 1
void CHTRichEditCtrl::SetHyperText(CPreparedRTFText* pPreparedText, bool bInvalidate)
d871 10
d882 1
a882 2
	if (bInvalidate)
		UpdateSize();
d885 1
a885 1
void CHTRichEditCtrl::UpdateSize()
d890 17
a906 2
	POINT		ptOldPos;
	long		iStartChar, iEndChar;
d908 3
a910 2
	SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptOldPos);
	GetSel(iStartChar, iEndChar);
d912 17
a928 1
	bool		bIsVisible = IsWindowVisible();
d931 1
a931 1
		SetRedraw(FALSE);
d933 23
a955 2
	long		iLastEnd = GetTextLength() - GetLineCount() + 1;
	CString		m_sOutText = m_pPreparedText->m_sRtfHeader + m_pPreparedText->m_sText + _T("}");
d957 15
a971 2
	SETTEXTEX st = {0};
	st.flags = ST_DEFAULT;
d973 2
a974 1
	SendMessage(EM_SETTEXTEX, (WPARAM)&st, (LPARAM)(LPCTSTR)m_sOutText);
d989 11
a999 5
	if (iStartChar == iLastEnd && iLastEnd == iEndChar)
		SetSel(m_pPreparedText->m_iTextEnd, m_pPreparedText->m_iTextEnd);
	else
		SetSel(iStartChar, iEndChar);
	if (m_bAutoScroll)
d1002 2
a1003 5

		POINT			ptNewPos;

		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptNewPos);
		ptOldPos.y = ptNewPos.y;
d1006 1
d1008 1
d1016 1
a1016 1
void CHTRichEditCtrl::SetFont(CFont* pFont, BOOL bRedraw)
a1054 1

a1070 1

d1076 6
a1081 3
	m_sRtfHeader = strRtfHeader;
	m_sText.Empty();
	m_iTextEnd = 0;
d1084 3
a1086 12
	switch (get_cpu_type())
	{
	case 1:
		m_iMaxBufSize = (16*1024);
		break;
	case 2:
		m_iMaxBufSize = (24*1024);
		break;
	default:
		m_iMaxBufSize = (32*1024);
		break;
	}
d1093 1
a1093 1
void CPreparedRTFText::CheckTable(CString& sColor, CString& sTable, COLORREF crColor) const
d1096 1
d1098 1
a1098 1
	if (((crColor & 0x1000000) == 0) && ((crColor & 0xFFFFFF) != GetSysColor(COLOR_WINDOWTEXT)))
d1100 2
a1101 1
		sColor.Format(_T("\\red%i\\green%i\\blue%i;"), GetRValue(crColor), GetGValue(crColor), GetBValue(crColor));
d1103 1
a1103 1
		int iTableStart = sTable.Find(_T("\n{\\colortbl ;"));
d1106 1
a1106 1
			sTable += _T("\n{\\colortbl ;") + sColor + _T("}\n");
d1111 1
a1111 1
			int			iTableEnd = sTable.Find(_T(";}"), iTableStart + 1);
d1116 3
a1118 6
				iTableStart = sTable.Find(_T("\\red"), iTableStart + 1);
				if ((iTableStart >= 0) && (sTable.Mid(iTableStart, sColor.GetLength()) == sColor))
				{
					sColor.Format(_T("\\cf%i "), iColor);
					return;
				}
d1120 1
a1120 1
			sTable.Insert(iTableEnd + 1, sColor);
d1123 1
a1123 1
	sColor.Format(_T("\\cf%i "), iColor);
d1126 1
a1126 1
void CPreparedRTFText::AppendText(const CString& strLine, COLORREF crColor)
d1128 4
a1131 1
	long		len = m_sText.GetLength();
d1133 9
a1141 1
	if (len >= m_iMaxBufSize)
d1143 10
a1152 1
		len	= m_sText.Find(_T("\n\\par"), (m_iMaxBufSize >> 2)) + 5;
d1154 2
a1155 1
		CString			strCut = m_sText.Left(len);
d1157 3
a1159 26
		m_sText.Delete(0, len);
		strCut.Replace(_T("\n\\par"), _T("\n"));
		strCut.Replace(_T("\\b0 "), _T(""));
		strCut.Replace(_T("\\b "), _T(""));
		strCut.Replace(_T("\\i0 "), _T(""));
		strCut.Replace(_T("\\i "), _T(""));
		strCut.Replace(_T("\\ul0 "), _T(""));
		strCut.Replace(_T("\\ul "), _T(""));

		int			iTableStart = m_sRtfHeader.Find(_T("\n{\\colortbl ;"));
		int			iTableEnd = m_sRtfHeader.Find(_T(";}"), iTableStart + 1);
		CString		sColor;
		int			iColor = 0;

		while ((iTableStart < iTableEnd) && (iTableStart != -1))
		{
			iTableStart = m_sRtfHeader.Find(_T("\\red"), iTableStart + 1);
			sColor.Format(_T("\\cf%i "), iColor);
			strCut.Replace(sColor, _T(""));
			iColor ++;
		}
		strCut.Replace(_T("\\}"),_T("}"));
		strCut.Replace(_T("\\{"),_T("{"));
		strCut.Replace(_T("\\\\"),_T("\\"));
		len = strCut.GetLength();
		m_iTextEnd -= len;
d1161 7
a1167 28
		if (m_aiLinkStart.GetSize() > 0)
		{
			int			i = 0;

			while (i < m_aiLinkStart.GetSize())
			{
				if (m_aiLinkStart[i] >= (unsigned int)len)
				{
					m_aiLinkStart[i] -= len;
					i++;
				}
				else
				{
					m_aiLinkStart.RemoveAt(i);
					m_aiLinkSize.RemoveAt(i);
				}
			}
		}
	}
	CString			sColor, sColor2, sText = strLine;

	CheckTable(sColor, m_sRtfHeader, crColor);
	if ((crColor & 0x2000000) == 0)
		sText.Replace(_T("\\"),_T("\\\\"));
	sText.Replace(_T("{"),_T("\\{"));
	sText.Replace(_T("}"),_T("\\}"));
	sText.Replace(_T("\n"),_T("\n\\par"));
	sText.Insert(0, sColor);
d1169 1
a1169 1
	LPCTSTR			psz = sText;
d1172 2
a1173 1
	long			iLen;
d1185 3
a1187 15
					CString			strClean = CString(pszStart, psz - pszStart);

					strClean.Replace(_T("\\b0 "),_T(""));
					strClean.Replace(_T("\\b "),_T(""));
					strClean.Replace(_T("\\i0 "),_T(""));
					strClean.Replace(_T("\\i "),_T(""));
					strClean.Replace(_T("\\ul0 "),_T(""));
					strClean.Replace(_T("\\ul "),_T(""));
					strClean.Replace(_T("\n\\par"), _T("\n"));
					strClean.Replace(_T("\\}"), _T("}"));
					strClean.Replace(_T("\\{"), _T("{"));
					strClean.Replace(_T("\\\\"), _T("\\"));
					strClean.Replace(sColor, _T(""));
					m_iTextEnd += strClean.GetLength();
					m_sText += CString(pszStart, psz - pszStart);
d1189 1
a1189 1
				CheckTable(sColor2, m_sRtfHeader, RGB(0, 0, 255));
d1191 7
a1197 7
				iLen = _tcscspn(psz, _T(" \n\r\t\\"));
				while ((iLen > 0) && !((*(psz + iLen - 1) >= _T('/') && *(psz + iLen - 1) <= _T('9')) ||
						(*(psz + iLen - 1) >= _T('A') && *(psz + iLen - 1) <= _T('Z')) ||
						(*(psz + iLen - 1) >= _T('a') && *(psz + iLen - 1) <= _T('z')) ||
						(*(psz + iLen - 1) == _T('|'))))
					iLen --;
				if (iLen == 0)
d1199 1
a1199 1
					m_aiLinkStart.Add(m_iTextEnd);
d1201 2
a1202 2
					m_iTextEnd += _tcslen(psz);
					m_sText += _T("\\ul ") + sColor2 + CString(psz) + _T("\\ul0 ") + sColor;
d1207 5
a1211 5
					m_aiLinkStart.Add(m_iTextEnd);
					m_aiLinkSize.Add(iLen);
					m_iTextEnd += iLen;
					m_sText += _T("\\ul ") + sColor2 + CString(psz, iLen) + _T("\\ul0 ") + sColor;
					psz += iLen;
d1223 2
a1224 15
		CString			strClean = CString(pszStart);

		strClean.Replace(_T("\\b0 "), _T(""));
		strClean.Replace(_T("\\b "), _T(""));
		strClean.Replace(_T("\\i0 "), _T(""));
		strClean.Replace(_T("\\i "), _T(""));
		strClean.Replace(_T("\\ul0 "), _T(""));
		strClean.Replace(_T("\\ul "), _T(""));
		strClean.Replace(_T("\n\\par"), _T("\n"));
		strClean.Replace(_T("\\}"), _T("}"));
		strClean.Replace(_T("\\{"), _T("{"));
		strClean.Replace(_T("\\\\"), _T("\\"));
		strClean.Replace(sColor, _T(""));
		m_iTextEnd += strClean.GetLength();
		m_sText += pszStart;
d1230 1
a1230 1
	return m_sText;
@


1.57
log
@Formatting, old code removal and a minor fix
@
text
@d1169 1
a1169 2
				iLen = _tcscspn(psz, _T(" \n\r\t"));

@


1.56
log
@Fix for WebServer logs for Mozila
@
text
@a39 2
	/*ON_CONTROL_REFLECT(EN_ERRSPACE, OnEnErrspace)
	ON_CONTROL_REFLECT(EN_MAXTEXT, OnEnMaxtext)*/
a47 1
	//m_bEnErrSpace = false;
d125 2
a126 1
	CString strLine(pszMsg);
d139 2
a140 1
	long iMsgLen = _tcslen(pszMsg);
d145 2
a146 1
	long iStartChar, iEndChar;
d148 2
a149 1
	long iOldTextEnd = m_iTextEnd;
d153 3
a155 1
	BOOL bIsVisible = IsWindowVisible();
d157 1
a157 1
		SetRedraw(FALSE);
d159 1
a159 1
	if( m_iTextEnd >= m_iMaxBufSize )
d161 2
a162 1
		CString strLog;
d164 3
a166 1
		long len = strLog.Find(_T('\n'), m_iMaxBufSize >> 3);
d180 1
a184 1
	//m_bEnErrSpace = false;
d186 3
a188 1
	CHARFORMAT2 cf;
a206 50
	/*if (m_bEnErrSpace)
	{
		bool bOldNoPaint = m_bNoPaint;
		m_bNoPaint = true;
		BOOL bIsVisible = IsWindowVisible();
		if (bIsVisible)
			SetRedraw(FALSE);

		// remove the first line as long as we are capable of adding the new line
		int iSafetyCounter = 0;
		while (m_bEnErrSpace && iSafetyCounter < 10)
		{
			// delete the previous partially added line
			SetSel(m_iTextEnd, -1);
			ReplaceSel(_T(""));

			// delete 1st line
			int iLine0Len = LineLength(0) + 2; // add NL character
			SetSel(0, iLine0Len);
			ReplaceSel(_T(""));

			// update any possible available selection
			iStartChar -= iLine0Len;
			if (iStartChar < 0)
				iStartChar = 0;
			iEndChar -= iLine0Len;
			if (iEndChar < 0)
				iEndChar = 0;

			// add the new line again
			long nPos = GetWindowTextLength();
			SetSel(nPos, nPos);
			m_bEnErrSpace = false;
			ReplaceSel(pszMsg);

			if (m_bEnErrSpace && nPos == 0)
				// should never happen: if we tried to add the line another time in the 1st line, there
				// will be no chance to add the line at all -> avoid endless loop!
				break;
			iSafetyCounter++; // never ever create an endless loop!
		}
		m_bNoPaint = bOldNoPaint;
		if (bIsVisible && !m_bNoPaint)
		{
			SetRedraw();
			if (m_bRichEdit)
				Invalidate();
		}
	}*/

d215 3
a217 1
		POINT ptNewPos;
a230 10
/*void CHTRichEditCtrl::OnEnErrspace()
{
	m_bEnErrSpace = true;
}

void CHTRichEditCtrl::OnEnMaxtext()
{
	m_bEnErrSpace = true;
}*/

d244 2
a245 1
		int iPos = GetScrollPos(SB_VERT);
d263 1
a263 1
	SetRedraw(FALSE);
d280 2
a281 2
	long		lSelStart, lSelEnd;
	CTitleMenu	menuLog;
d287 1
a287 2
	menuLog.AppendMenu(MF_STRING | ((lSelEnd > lSelStart) ? MF_ENABLED : MF_GRAYED),
		MP_COPYSELECTED, GetResString(IDS_COPY));
d289 2
a290 2
	UINT		dwFlags = MF_STRING | ((GetWindowTextLength() > 0) ? MF_ENABLED : MF_GRAYED);
	CString		strBuffer = GetResString(IDS_SAVETOFILE);
d344 3
a346 2
	CString strLog;
	long iLastLine = GetLineCount() - 2;
d357 1
a357 1
	CString strLog;
d370 1
a370 1
	CString strLog,strTemp;
d374 2
a375 1
		HANDLE hFile=CreateFile(strTemp,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);
d388 1
a388 1
	CString strLog,strTemp;
d392 2
a393 1
		HANDLE hFile=CreateFile(strTemp,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);
d399 1
a399 1
			EDITSTREAM es;
d405 5
a409 3
			LPCTSTR psz = strTemp;
			LPCTSTR pszStart = psz;
			CString sColor;
d413 2
a414 1
				bool bFoundScheme = false;
d422 1
a422 3
						
						long iLen = _tcscspn(psz, _T(" \n\r\t\\"));

d450 1
a450 1
			DWORD written;
d483 4
a486 2
	LPCTSTR psz = sText;
	LPCTSTR pszStart = psz;
d490 2
a491 1
		bool bFoundScheme = false;
d499 1
d501 2
a502 1
				long iLen = _tcscspn(psz, _T(" \n\r\t"));
d540 2
a541 1
	BOOL bMsgHandled = FALSE;
a544 2
	ENLINK* pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);

d547 2
a548 1
		CString strUrl;
d559 1
a559 1
				bMsgHandled = TRUE; // do not route this message to any parent
d569 1
a569 1
	CString strText;
d577 2
a578 2
	CString		strTemp, strText;
	EDITSTREAM	es;
d589 2
a590 2
	int			iTableStart = strTemp.Find(_T("\n{\\colortbl ;"));
	int			iTableEnd = strTemp.Find(_T(";}"), iTableStart + 1);
d644 1
d670 1
a670 1
					long	iLen = _tcscspn(psz, _T(" \n"));
d702 2
a703 2
	CString		strTemp, strText;
	EDITSTREAM	es;
d711 2
a712 2
	int			iTableStart = strTemp.Find(_T("\n{\\colortbl ;"));
	int			iTableEnd = strTemp.Find(_T(";}"), iTableStart + 1);
d822 1
d848 1
a848 1
					long	iLen = _tcscspn(psz, _T(" \n"));
d870 2
a871 1
	strText.TrimRight(_T("<ct>"));
d875 1
a875 1
		strText.Insert(0,_T("<"));
d897 3
a899 1
	POINT ptOldPos;
d901 1
d903 1
a903 2
	long iStartChar, iEndChar;
	GetSel(iStartChar, iEndChar);
a904 1
	BOOL bIsVisible = IsWindowVisible();
d908 3
a910 2
	long iLastEnd = GetTextLength() - GetLineCount() + 1;
	CString m_sOutText = m_pPreparedText->m_sRtfHeader + m_pPreparedText->m_sText + _T("}");
d917 2
a918 1
		CHARFORMAT2 cf;
d936 3
a938 1
		POINT ptNewPos;
d953 2
a954 1
	LOGFONT lf = {0};
d957 2
a958 1
	CHARFORMAT cf = {0};
d974 4
a977 2
	HDC hDC = ::GetDC(NULL);
	int iPointSize = -MulDiv(lf.lfHeight, 72, GetDeviceCaps(hDC, LOGPIXELSY));
d1038 1
a1038 1
	int iColor = 0;
d1052 2
a1053 1
			int iTableEnd = sTable.Find(_T(";}"), iTableStart + 1);
d1072 1
a1072 1
	long len = m_sText.GetLength();
d1074 1
a1074 1
	if( len >= m_iMaxBufSize )
d1078 1
a1078 1
		CString strCut = m_sText.Left(len);
d1089 4
a1092 4
		int iTableStart = m_sRtfHeader.Find(_T("\n{\\colortbl ;"));
		int iTableEnd = m_sRtfHeader.Find(_T(";}"), iTableStart + 1);
		CString sColor;
		int iColor = 0;
d1109 1
a1109 1
			int i = 0;
d1126 1
a1126 1
	CString sColor, sColor2, sText = strLine;
d1136 4
a1139 2
	LPCTSTR psz = sText;
	LPCTSTR pszStart = psz;
d1143 1
a1143 1
		bool bFoundScheme = false;
d1151 1
a1151 1
					CString strClean = CString(pszStart, psz - pszStart);
d1169 1
a1169 1
				long iLen = _tcscspn(psz, _T(" \n\r\t"));
d1202 1
a1202 1
		CString strClean = CString(pszStart);
@


1.55
log
@Removed unneeded code + name changes (Thx Aw3)
@
text
@d647 1
a647 1
			sColor.Format(_T(" <font color=\"#%06x\">"), iHtmlColor);
d735 1
a735 1
	strText.Replace(_T(" <font color"), _T("<font color"));
@


1.54
log
@minor correction
@
text
@d635 2
a636 6
		CStringArray	m_astrColorsRtf;
		CStringArray	m_astrColorsHtml;

		m_astrColorsRtf.RemoveAll();
		m_astrColorsHtml.RemoveAll();

d646 1
a646 1
			m_astrColorsRtf.Add(sColor);
d648 1
a648 1
			m_astrColorsHtml.Add(sColor);
d669 1
a669 1
		if (m_astrColorsRtf.GetSize() > 0)
d671 1
a671 1
			for (int i = 0; i < m_astrColorsRtf.GetSize(); i++)
d673 3
a675 3
				strTemp.Replace(m_astrColorsRtf[i] + _T(" \\\'"), m_astrColorsHtml[i] + _T(" \\\'"));
				strTemp.Replace(m_astrColorsRtf[i] + _T(' '), m_astrColorsHtml[i]);
				strTemp.Replace(m_astrColorsRtf[i] + _T('\\'), m_astrColorsHtml[i] + _T('\\'));
a676 2
			m_astrColorsRtf.RemoveAll();
			m_astrColorsHtml.RemoveAll();
d756 2
a757 6
		CStringArray	m_astrColorsRtf;
		CStringArray	m_astrColorsHtml;

		m_astrColorsRtf.RemoveAll();
		m_astrColorsHtml.RemoveAll();

d767 1
a767 1
			m_astrColorsRtf.Add(sColor);
d774 1
a774 1
			m_astrColorsHtml.Add(sColor);
d795 1
a795 1
		if (m_astrColorsRtf.GetSize() > 0)
d797 1
a797 1
			for (int i = 0; i < m_astrColorsRtf.GetSize(); i++)
d799 3
a801 3
				strTemp.Replace(m_astrColorsRtf[i] + _T(" \\\'"), m_astrColorsHtml[i] + _T(" \\\'"));
				strTemp.Replace(m_astrColorsRtf[i] + _T(' '), m_astrColorsHtml[i]);
				strTemp.Replace(m_astrColorsRtf[i] + _T('\\'), m_astrColorsHtml[i] + _T('\\'));
a802 2
			m_astrColorsRtf.RemoveAll();
			m_astrColorsHtml.RemoveAll();
@


1.53
log
@Advanced Log tooltip on status bar;
Tooltip width should be now correct
@
text
@d628 1
a628 1
	strTemp.Replace(_T("\\'"), _T(" \\'"));
d677 1
d755 1
a755 1
	strTemp.Replace(_T("\\'"), _T(" \\'"));
d809 1
@


1.52
log
@IRC now supports font style coded messages + some fixes
@
text
@a318 1
			g_eMuleApp.m_pdlgEmule->m_ctlStatusBar.SetTipText(SB_MESSAGETEXT,_T(""));
d407 1
d420 1
d437 1
d445 1
d447 1
d451 1
d455 1
d466 1
d468 1
d495 1
d497 1
d531 1
d582 1
d584 1
d586 1
d611 1
d618 1
a618 1
	CString		strTemp,strText;
d623 1
a623 1
	StreamOut(SF_RTF,es);
d745 183
@


1.51
log
@WebServer bug fix for some special characters not displaying in the logs
@
text
@d880 2
a881 1
	if ((crColor != -1) && (crColor != GetSysColor(COLOR_WINDOWTEXT)))
d913 1
d917 1
d919 1
d921 8
a928 3
		strCut.Replace(_T("\n\\par"),_T("\n"));
		strCut.Replace(_T("\\ul0"),_T(""));
		strCut.Replace(_T("\\ul"),_T(""));
d933 1
d950 1
d966 2
a967 1
	CString sColor, sColor2;
d969 2
a970 2
	CString sText = strLine;
	sText.Replace(_T("\\"),_T("\\\\"));
d974 2
a975 1
	sText = sColor + sText;
d978 1
d982 1
d990 12
a1001 5
					strClean.Replace(_T("\n\\par"),_T("\n"));
					strClean.Replace(_T("\\}"),_T("}"));
					strClean.Replace(_T("\\{"),_T("{"));
					strClean.Replace(_T("\\\\"),_T("\\"));
					strClean.Replace(sColor,_T(""));
d1006 1
d1008 1
d1019 1
a1019 1
					m_sText += _T("\\ul") + sColor2 + CString(psz) + _T("\\ul0") + sColor;
d1027 1
a1027 1
					m_sText += _T("\\ul") + sColor2 + CString(psz, iLen) + _T("\\ul0") + sColor;
d1041 12
a1052 5
		strClean.Replace(_T("\n\\par"),_T("\n"));
		strClean.Replace(_T("\\}"),_T("}"));
		strClean.Replace(_T("\\{"),_T("{"));
		strClean.Replace(_T("\\\\"),_T("\\"));
		strClean.Replace(sColor,_T(""));
@


1.50
log
@better string processing
@
text
@d613 1
d674 1
d682 12
a693 3
					psz = _tcsinc(psz);
					strText += CString(pszStart, psz - pszStart);
					psz = _tcsinc(psz);
d708 1
a708 1
							psz = _tcsinc(psz);
d714 1
a714 1
				psz = _tcsinc(psz);
@


1.49
log
@new string for save log context menu
@
text
@d53 1
a53 1
	m_strTitle = _T("");
d305 1
a305 1
		m_pPreparedText->m_sText = _T("");
d441 2
a442 2
			strTemp = _T("");
			strLog = _T("");
d603 1
a603 2
	CString		strTemp = _T("");
	CString		strText = _T("");
d844 1
a844 1
	m_sText = _T("");
@


1.48
log
@Some string processing improvements (thx Aw3)
@
text
@d341 1
a341 1
	CString		strBuffer = GetResString(IDS_LOGTOFILE);
@


1.47
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d163 1
a163 1
		strLog = strLog.Left(len);
d713 1
a713 1
		strText = strText.Left(iStrEnd);
@


1.46
log
@Improved string processing
@
text
@d352 1
a352 1
	menuLog.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.45
log
@Improved context menu creation
@
text
@d160 1
a160 1
		long len = strLog.Find(_T("\n"), m_iMaxBufSize >> 3);
d164 1
a164 1
		strLog.Replace(_T("\n"),_T(""));
d662 2
a663 2
				strTemp.Replace(m_astrColorsRtf[i] + _T(" "), m_astrColorsHtml[i]);
				strTemp.Replace(m_astrColorsRtf[i] + _T("\\"), m_astrColorsHtml[i] + _T("\\"));
@


1.44
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d328 1
a328 1
void CHTRichEditCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
d330 4
a333 3
	long iSelStart, iSelEnd;
	GetSel(iSelStart, iSelEnd);
	long iTextLen = GetWindowTextLength();
d335 18
a352 18
	m_LogMenu.CreatePopupMenu();
	m_LogMenu.AddMenuTitle(GetResString(IDS_LOGENTRY));
	m_LogMenu.AppendMenu(MF_STRING,MP_COPYSELECTED, GetResString(IDS_COPY));
	m_LogMenu.EnableMenuItem(MP_COPYSELECTED, iSelEnd > iSelStart ? MF_ENABLED : MF_GRAYED);
	m_LogMenu.AppendMenu(MF_STRING,MP_SAVELOG, GetResString(IDS_LOGTOFILE) + _T(" (.log)"));
	m_LogMenu.EnableMenuItem(MP_SAVELOG, iTextLen > 0 ? MF_ENABLED : MF_GRAYED);
	m_LogMenu.AppendMenu(MF_STRING,MP_SAVERTF, GetResString(IDS_LOGTOFILE) + _T(" (.rtf)"));
	m_LogMenu.EnableMenuItem(MP_SAVERTF, iTextLen > 0 ? MF_ENABLED : MF_GRAYED);
	m_LogMenu.AppendMenu(MF_SEPARATOR);
	m_LogMenu.AppendMenu(MF_STRING,MP_SELECTALL, GetResString(IDS_SELECTALL));
	m_LogMenu.EnableMenuItem(MP_SELECTALL, iTextLen > 0 ? MF_ENABLED : MF_GRAYED);
	m_LogMenu.AppendMenu(MF_STRING,MP_REMOVEALL, GetResString(IDS_PW_RESET));
	m_LogMenu.EnableMenuItem(MP_REMOVEALL, iTextLen > 0 ? MF_ENABLED : MF_GRAYED);
	m_LogMenu.AppendMenu(MF_SEPARATOR);
	m_LogMenu.AppendMenu(MF_STRING,MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));
	m_LogMenu.CheckMenuItem(MP_AUTOSCROLL, m_bAutoScroll ? MF_CHECKED : MF_UNCHECKED);
	m_LogMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
	m_LogMenu.DestroyMenu();
d354 1
@


1.43
log
@Fix for my fix
@
text
@d181 1
a181 1
	memset2(&cf, 0, sizeof cf);
d757 1
a757 1
			memset2(&cf, 0, sizeof cf);
@


1.42
log
@minor fix
@
text
@d675 1
a675 1
			if ((*psz == _T('\\')) && (*(psz + 1) != _T('\\')))
d677 3
a679 1
				if (psz - pszStart > 0)
d681 6
d688 1
a688 1
				long	iLen = _tcscspn(psz, _T(" \n"));
d690 8
a697 7
				if (iLen == 0)
					psz += _tcslen(psz);
				else
				{
					psz += iLen;
					if (*psz == _T(' '))
						psz = _tcsinc(psz);
@


1.41
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d675 1
a675 1
			if (*psz == _T('\\'))
@


1.40
log
@added color to the WebServer logs
@
text
@d601 4
a604 3
	CString strTemp = _T("");
	CString strText = _T("");
	EDITSTREAM es;
d612 4
a615 2
	int iTableStart = strTemp.Find(_T("\n{\\colortbl ;"));
	int iTableEnd = strTemp.Find(_T(";}"), iTableStart + 1);
d618 3
a620 2
		CStringArray m_astrColorsRtf;
		CStringArray m_astrColorsHtml;
d623 6
a628 4
		int iRtfColor = 0;
		long iHtmlColor = 0;
		int iColorEnd;
		CString sColor;
d666 3
a668 1
		LPCTSTR psz = strTemp;
d670 3
a672 1
		LPCTSTR pszStart = psz;
d679 3
a681 1
				long iLen = _tcscspn(psz, _T(" \n"));
d698 3
a700 1
	int iStrEnd = strText.ReverseFind(_T('}'));
@


1.39
log
@fix to prevent an ASSERT error (it crashes my debug build)
@
text
@d599 96
@


1.38
log
@erase status bar when log or debug log are erased
@
text
@d766 1
a766 1
				if (sTable.Mid(iTableStart, sColor.GetLength()) == sColor)
@


1.37
log
@reverted a change
@
text
@d15 1
a15 1
} _apszSchemes[] = 
d235 1
a235 1
				// should never happen: if we tried to add the line another time in the 1st line, there 
d314 10
d381 1
a381 1
BOOL CHTRichEditCtrl::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
d427 1
a427 1
		}				
d442 1
a442 1
			es.dwCookie = (DWORD)&strTemp; 
d488 1
a488 1
		}				
d598 1
a598 1
 
d768 1
a768 1
					sColor.Format(_T("\\cf%i "), iColor);				
d849 1
a849 1
					m_iTextEnd += strClean.GetLength();		
d871 1
a871 1
					m_iTextEnd += iLen; 
@


1.36
log
@minor change
@
text
@a144 1
	CWnd *focusWnd = GetFocus();
a261 2
	if (focusWnd != (CWnd *) NULL)
		focusWnd->SetFocus();
@


1.35
log
@another small change
@
text
@d149 1
a249 1
	long iOldTextEnd = m_iTextEnd;
@


1.34
log
@small change
@
text
@a155 2
	HideSelection(TRUE, TRUE);

a254 1
	HideSelection(FALSE, TRUE);
@


1.33
log
@minor fixes & cleanup
@
text
@d145 2
a146 1
	// Get Edit contents dimensions and cursor position
d149 9
a172 6
	// Reduce flicker by ignoring WM_PAINT
	m_bNoPaint = true;
	BOOL bIsVisible = IsWindowVisible();
	if (bIsVisible)
		SetRedraw(FALSE);

a177 2
	// Note: This will flicker, if someone has a good idea how to prevent this - let me know

a179 1

d257 1
d266 2
@


1.32
log
@minor change
@
text
@d84 1
a84 1
void CHTRichEditCtrl::Init(LPCTSTR pszTitle)
d98 1
a98 1
	Init(NULL);
d291 2
a292 1
	SendMessage(WM_VSCROLL, SB_LINEUP);
d600 1
a600 1
		UpdateSize(true);
d603 1
a603 1
void CHTRichEditCtrl::UpdateSize(bool bRepaint)
d619 1
a619 1
	CString m_sOutText = m_pPreparedText->m_sRtfHeader + m_pPreparedText->m_sText + _T('}');
@


1.31
log
@minor changes
@
text
@d289 1
a289 1
	// WM_VSCROLL does not work correctly under Win98 (or older version of comctl.dll)
d294 1
a294 1
		// older version of comctl.dll seem to need this to properly update the display
a297 1
		SendMessage(WM_VSCROLL, SB_LINEUP);
@


1.30
log
@more changes
@
text
@d63 4
a66 1
		m_iMaxBufSize = (128*1024);
d148 1
a148 1
	if( m_iTextEnd > m_iMaxBufSize )
d251 1
a251 1
	m_iTextEnd += _tcslen(pszMsg);
a286 2
	// Scroll the rich edit control so that the first visible line
	// is the first line of text.
d773 1
a773 1
	if( len > m_iMaxBufSize )
@


1.29
log
@a different way to get the last character in the control
@
text
@d290 1
d297 1
@


1.28
log
@and s'more changes...
@
text
@d66 1
d145 1
a145 2
	long iSize = GetTextLength() - GetLineCount() + 1;
	if( iSize > m_iMaxBufSize )
d157 1
a157 1
		iSize -= len;
d177 1
a177 1
	SetSel(iSize, iSize);
d210 1
a210 1
			SetSel(iSize, -1);
d247 4
a250 2
	if (iStartChar == iSize && iSize == iEndChar)
		SetSel(iEndChar + _tcslen(pszMsg), iEndChar + _tcslen(pszMsg));
d310 1
@


1.27
log
@some more changes
@
text
@a174 45
	SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, crColor);
	if (iStartChar == iSize && iSize == iEndChar)
		SetSel(iEndChar + _tcslen(pszMsg), iEndChar + _tcslen(pszMsg));
	else
		SetSel(iStartChar, iEndChar);
	if (m_bAutoScroll)
	{
		ScrollToLastLine();
		POINT ptNewPos;
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptNewPos);
		ptOldPos.y = ptNewPos.y;
	}
	SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptOldPos);

	m_bNoPaint = false;
	if (bIsVisible)
	{
		SetRedraw();
		Invalidate();
	}
}

/*void CHTRichEditCtrl::OnEnErrspace()
{
	m_bEnErrSpace = true;
}

void CHTRichEditCtrl::OnEnMaxtext()
{
	m_bEnErrSpace = true;
}*/

void CHTRichEditCtrl::ScrollToLastLine()
{
	LineScroll(GetLineCount());
	// WM_VSCROLL does not work correctly under Win98 (or older version of comctl.dll)
	SendMessage(WM_VSCROLL, SB_BOTTOM);
	if (g_eMuleApp.m_pGlobPrefs->GetWindowsVersion() == _WINVER_95_)
	{
		// older version of comctl.dll seem to need this to properly update the display
		int iPos = GetScrollPos(SB_VERT);
		SendMessage(WM_VSCROLL, MAKELONG(SB_THUMBPOSITION, iPos));
		SendMessage(WM_VSCROLL, SB_ENDSCROLL);
	}
}
a175 2
void CHTRichEditCtrl::SafeAddLine(long nPos, LPCTSTR pszLine, long& iStartChar, long& iEndChar, bool bLink, COLORREF crColor)
{
d177 1
a177 1
	SetSel(nPos, nPos);
d195 1
a195 1
	ReplaceSel(pszLine);
d210 1
a210 1
			SetSel(nPos, -1);
d227 1
a227 1
			nPos = GetWindowTextLength();
d230 1
a230 1
			ReplaceSel(pszLine);
d246 49
@


1.26
log
@reverted some changes
@
text
@d40 2
a41 2
	ON_CONTROL_REFLECT(EN_ERRSPACE, OnEnErrspace)
	ON_CONTROL_REFLECT(EN_MAXTEXT, OnEnMaxtext)
a47 1
	m_bRichEdit = true;
d50 1
a50 1
	m_bEnErrSpace = false;
d125 1
a125 1
	strLine += _T("\r\n");
a139 4
#ifdef _DEBUG
//	if (pszMsg[iMsgLen - 1] == _T('\n'))
//		ASSERT( iMsgLen >= 2 && pszMsg[iMsgLen - 2] == _T('\r') );
#endif
d144 1
a144 4
	CString strLog;
	GetWindowText(strLog);
	strLog.Replace(_T("\n"),_T(""));
	long iSize = strLog.GetLength();
d147 8
a154 2
		strLog = strLog.Left(m_iMaxBufSize >> 3);
		long len = strLog.ReverseFind(_T('\r')) + 1;
a170 24
	if (iStartChar != iEndChar)
	{
		// If we are currently selecting some text, we have to find out
		// if the caret is near the beginning of this block or near the end.
		// Note that this does not always work. Because of the EM_CHARFROMPOS
		// message returning only 16 bits this will fail if the user has selected 
		// a block with a length dividable by 64k.

		// NOTE: This may cause a lot of terrible CRASHES within the RichEdit control when used for a RichEdit control!?
		// To reproduce the crash: click in the RE control while it's drawing a line an start a selection!
		if (!m_bRichEdit)
		{
			CPoint pt;
			::GetCaretPos(&pt);
			int nCaretPos = CharFromPos(pt);
			if (abs((iStartChar % 0xffff - nCaretPos)) < abs((iEndChar % 0xffff - nCaretPos)))
			{
				nCaretPos = iStartChar;
				iStartChar = iEndChar;
				iEndChar = nCaretPos;
			}
		}
	}

d193 1
a193 2
		if (m_bRichEdit)
			Invalidate();
d197 1
a197 1
void CHTRichEditCtrl::OnEnErrspace()
d205 1
a205 1
}
d223 1
a223 1
	m_bEnErrSpace = false;
d244 1
a244 1
	if (m_bEnErrSpace)
d292 1
a292 1
	}
d309 1
a309 2
	if (m_bRichEdit)
		Invalidate();
d467 1
a467 1
			if (*pszStart != _T('\0'))
d538 1
a538 1
	if (*pszStart != _T('\0'))
d645 1
a645 2
		if (m_bRichEdit)
			Invalidate();
d867 1
a867 1
	if (*pszStart != _T('\0'))
@


1.25
log
@Fixed a problem with log cutting when size limit is reached - Thanks BavarianSnail ;-)
@
text
@d149 4
a152 1
	long iSize = GetTextLength() - GetLineCount() + 1;
a154 2
		CString strLog;
		GetWindowText(strLog);
a155 1
		strLog.Replace(_T("\n"),_T(""));
@


1.24
log
@Maximum log size by CPU: 32KB for PI, 64KB for PII, anything else 128KB
@
text
@d58 1
a58 1
		MaxBufSize = (32*1024);
d61 1
a61 1
		MaxBufSize = (64*1024);
d63 2
a64 4
	case 3:
	case 4:
	case 5:
		MaxBufSize = (128*1024);
d150 1
a150 1
	if( iSize > MaxBufSize )
d154 2
a155 1
		strLog = strLog.Left(MaxBufSize >> 3);
d744 1
a744 1
		MaxBufSize = (16*1024);
d747 1
a747 1
		MaxBufSize = (24*1024);
d749 2
a750 4
	case 3:
	case 4:
	case 5:
		MaxBufSize = (32*1024);
d794 1
a794 1
	if( len > MaxBufSize )
d796 1
a796 1
		len	= m_sText.Find(_T("\n\\par"), (MaxBufSize >> 2)) + 5;
@


1.23
log
@fixes/changes
@
text
@d55 14
d152 1
a152 1
	if( iSize > (128*1024) )
d156 1
a156 1
		strLog = strLog.Left(16*1024);
d742 14
d797 1
a797 1
	if( len > (32*1024) )
d799 1
a799 1
		len	= m_sText.Find(_T("\n\\par"), (8*1024)) + 5;
@


1.22
log
@fix for URL click
@
text
@d54 1
d64 1
a64 1
void CHTRichEditCtrl::Localize()
d66 1
d126 1
a126 1
	int iMsgLen = _tcslen(pszMsg);
d137 1
a137 4
	CString strLog;
	GetWindowText(strLog);
	strLog.Replace(_T("\n"),_T(""));
	long iSize = strLog.GetLength();
d140 2
d143 1
a143 1
		int len	= strLog.ReverseFind(_T('\r')) + 1;
d315 3
d393 1
a393 1
	int iLastLine = GetLineCount() - 2;
d417 1
a417 1
	if (DialogBrowseFile(strTemp, _T("Log (*.log)|*.log||"), _T(".log"), 0, FALSE))
d433 1
a433 1
	if (DialogBrowseFile(strTemp, _T("Rich Text Format (RTF)|*.rtf||"), _T(".rtf"), 0, FALSE))
d457 1
a457 1
						int iLen = _tcscspn(psz, _T(" \n\r\t\\"));
d529 1
a529 1
				int iLen = _tcscspn(psz, _T(" \n\r\t"));
d625 1
a625 4
	CString strLog;
	GetWindowText(strLog);
	strLog.Replace(_T("\n"),_T(""));
	long iOldSize = strLog.GetLength();
d631 1
a631 8
	GetWindowText(strLog);
	strLog.Replace(_T("\n"),_T(""));
	long iNewSize = strLog.GetLength();
	LPCTSTR psz = strLog;
	LPCTSTR pszStart = psz;
	CHARFORMAT2 cf;

	while (*psz != _T('\0'))
d633 2
a634 2
		bool bFoundScheme = false;
		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d636 6
a641 32
			if (CString(psz, _tcslen(_apszSchemes[i].pszScheme)).MakeLower() == CString(_apszSchemes[i].pszScheme))
			{
				int iLen = _tcscspn(psz, _T(" \n\r\t"));
				while ((iLen > 0) && !((*(psz + iLen - 1) >= _T('/') && *(psz + iLen - 1) <= _T('9')) ||
						(*(psz + iLen - 1) >= _T('A') && *(psz + iLen - 1) <= _T('Z')) ||
						(*(psz + iLen - 1) >= _T('a') && *(psz + iLen - 1) <= _T('z')) ||
						(*(psz + iLen - 1) == _T('|'))))
					iLen --;
				if (iLen == 0)
				{
					memset2(&cf, 0, sizeof cf);
					SetSel(psz - (LPCTSTR)strLog, psz - (LPCTSTR)strLog + _tcslen(psz));
					GetSelectionCharFormat(cf);
					cf.dwMask |= CFM_LINK;
					cf.dwEffects |= CFE_LINK;
					SetSelectionCharFormat(cf);
					psz += _tcslen(psz);
				}
				else
				{
					memset2(&cf, 0, sizeof cf);
					SetSel(psz - (LPCTSTR)strLog, psz - (LPCTSTR)strLog + iLen);
					GetSelectionCharFormat(cf);
					cf.dwMask |= CFM_LINK;
					cf.dwEffects |= CFE_LINK;
					SetSelectionCharFormat(cf);
					psz += iLen;
				}
				pszStart = psz;
				bFoundScheme = true;
				break;
			}
a642 2
		if (!bFoundScheme)
			psz = _tcsinc(psz);
d644 2
a645 3

	if (iStartChar == iOldSize && iOldSize == iEndChar)
		SetSel(iNewSize, iNewSize);
d725 3
d768 1
a768 1
	int len = m_sText.GetLength();
d771 40
a810 3
		m_sText = m_sText.Right(24*1024);
		len = m_sText.Find(_T("\n\\par"));
		m_sText.Delete(0, len + 5);
d830 8
d839 1
d841 1
a841 1
				int iLen = _tcscspn(psz, _T(" \n\r\t"));
d849 3
d857 3
d872 8
d881 1
@


1.21
log
@VS2002 compatibility fix
@
text
@d575 1
a575 1
			if (strUrl.MakeLower() == CString(_apszSchemes[i].pszScheme))
@


1.20
log
@Better URL detection + minor changes
@
text
@d14 2
a15 2
	CString strScheme;
} _astrSchemes[] = 
d446 1
a446 1
				for (int i = 0; i < ARRSIZE(_astrSchemes); i++)
d448 1
a448 1
					if (CString(psz, _astrSchemes[i].strScheme.GetLength()).MakeLower() == _astrSchemes[i].strScheme)
d517 1
a517 1
		for (int i = 0; i < ARRSIZE(_astrSchemes); i++)
d519 1
a519 1
			if (CString(psz, _astrSchemes[i].strScheme.GetLength()).MakeLower() == _astrSchemes[i].strScheme)
d573 1
a573 1
		for (int i = 0; i < ARRSIZE(_astrSchemes); i++)
d575 1
a575 1
			if (strUrl.MakeLower() == _astrSchemes[i].strScheme)
d640 1
a640 1
		for (int i = 0; i < ARRSIZE(_astrSchemes); i++)
d642 1
a642 1
			if (CString(psz, _astrSchemes[i].strScheme.GetLength()).MakeLower() == _astrSchemes[i].strScheme)
d820 1
a820 1
		for (int i = 0; i < ARRSIZE(_astrSchemes); i++)
d822 1
a822 1
			if (CString(psz, _astrSchemes[i].strScheme.GetLength()).MakeLower() == _astrSchemes[i].strScheme)
@


1.19
log
@re-added the option to save as .log
@
text
@d14 15
a28 16
	LPCTSTR pszScheme;
	int iLen;
} _apszSchemes[] = 
{
	{ _T("ed2k://"),  _tcslen(_T("ed2k://")) },
	{ _T("ftp."),     _tcslen(_T("ftp.")) },
	{ _T("ftp://"),   _tcslen(_T("ftp://")) },
	{ _T("http://"),  _tcslen(_T("http://")) },
	{ _T("https://"), _tcslen(_T("https://")) },
	{ _T("mailto:"),  _tcslen(_T("mailto:")) },
	{ _T("www."),     _tcslen(_T("www.")) },
	{ _T("www1."),    _tcslen(_T("www1.")) },
	{ _T("www2."),    _tcslen(_T("www2.")) },
	{ _T("www3."),    _tcslen(_T("www3.")) },
	{ _T("www4."),    _tcslen(_T("www4.")) },
	{ _T("www5."),    _tcslen(_T("www5.")) }
d442 1
d446 1
a446 1
				for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d448 1
a448 1
					if (_tcsncmp(psz, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0)
d451 1
a451 5
						{
							CString str(pszStart, psz - pszStart);
							strLog += str;
						}
						CString sColor;
d454 5
d466 1
a466 2
							CString str(psz, iLen);
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + str + _T("\"}}{\\fldrslt{{\\ul") + sColor + str + _T("}}}}");
d517 1
a517 1
		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d519 1
a519 1
			if (_tcsncmp(psz, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0)
d523 1
a523 4
				{
					CString str(pszStart, psz - pszStart);
					AddLine(str, false, crColor);
				}
d526 5
d538 1
a538 2
					CString str(psz, iLen);
					AddLine(str, true);
d573 1
a573 1
		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d575 1
a575 1
			if (_tcsncmp(strUrl, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0)
d640 1
a640 1
		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d642 1
a642 1
			if (_tcsncmp(psz, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0)
d645 5
d807 1
a807 1
	CString sColor;
d820 1
a820 1
		for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
d822 1
a822 1
			if (_tcsncmp(psz, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0)
d825 1
a825 5
				{
					CString str(pszStart, psz - pszStart);
					m_sText += str;
				}
				CString sColor2; 
d828 5
d840 1
a840 2
					CString str(psz, iLen);
					m_sText += _T("\\ul") + sColor2 + str + _T("\\ul0") + sColor;
@


1.18
log
@fixed a problem with log saving
@
text
@d334 1
a334 1
	m_LogMenu.AppendMenu(MF_STRING,MP_SAVELOG, GetResString(IDS_LOGTOFILE)); 
d336 2
d361 3
d412 16
@


1.17
log
@fixes...
@
text
@d435 1
a435 5
						int iOldSize = strTemp.GetLength();
						m_pPreparedText->CheckTable(sColor, strTemp, RGB(0, 0, 255));
						iOldSize = strTemp.GetLength() - iOldSize;
						if (iOldSize > 0)
							psz = psz + iOldSize;
@


1.16
log
@some more fixes
@
text
@d136 4
a139 2
	long iSize = GetWindowTextLength();

a141 2
		CString strLog;
		GetWindowText(strLog);
d143 2
a144 3
		strLog.Replace(_T("\n"),_T(""));
		int len	= strLog.ReverseFind(_T('\r'));
		SetSel(0, len + 1);
d146 1
d149 22
a170 14
	if (iStartChar == iSize && iSize == iEndChar)
	{
		// The cursor resides at the end of text
		SCROLLINFO si;
		si.cbSize = sizeof si;
		si.fMask = SIF_ALL;
		if (m_bAutoScroll && GetScrollInfo(SB_VERT, &si) && si.nPos >= (int)(si.nMax - si.nPage + 1))
		{
			// Not scrolled away
			SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, crColor);
			if (m_bAutoScroll && !IsWindowVisible())
				ScrollToLastLine();
		}
		else
d172 4
a175 21
			// Reduce flicker by ignoring WM_PAINT
			m_bNoPaint = true;
			BOOL bIsVisible = IsWindowVisible();
			if (bIsVisible)
				SetRedraw(FALSE);

			// Remember where we are
			int nFirstLine = !m_bAutoScroll ? GetFirstVisibleLine() : 0;
		
			// Select at the end of text and replace the selection
			// This is a very fast way to add text to an edit control
			SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, crColor);
			SetSel(iStartChar, iEndChar); // Restore our previous selection

			if (!m_bAutoScroll)
				LineScroll(nFirstLine - GetFirstVisibleLine());
			else
				ScrollToLastLine();

			m_bNoPaint = false;
			if (bIsVisible)
d177 3
a179 3
				SetRedraw();
				if (m_bRichEdit)
					Invalidate();
d183 8
d192 2
d195 6
a200 1
		// We should add the text anyway...
d202 6
a207 56
		// Reduce flicker by ignoring WM_PAINT
		m_bNoPaint = true;
		BOOL bIsVisible = IsWindowVisible();
		if (bIsVisible)
			SetRedraw(FALSE);

		// Remember where we are
		//int nFirstLine = !m_bAutoScroll ? GetFirstVisibleLine() : 0;
		POINT ptPos;
		if (!m_bAutoScroll)
			SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptPos);
	
		if (iStartChar != iEndChar)
		{
			// If we are currently selecting some text, we have to find out
			// if the caret is near the beginning of this block or near the end.
			// Note that this does not always work. Because of the EM_CHARFROMPOS
			// message returning only 16 bits this will fail if the user has selected 
			// a block with a length dividable by 64k.

			// NOTE: This may cause a lot of terrible CRASHES within the RichEdit control when used for a RichEdit control!?
			// To reproduce the crash: click in the RE control while it's drawing a line an start a selection!
			if (!m_bRichEdit)
			{
			    CPoint pt;
			    ::GetCaretPos(&pt);
			    int nCaretPos = CharFromPos(pt);
			    if (abs((iStartChar % 0xffff - nCaretPos)) < abs((iEndChar % 0xffff - nCaretPos)))
			    {
				    nCaretPos = iStartChar;
				    iStartChar = iEndChar;
				    iEndChar = nCaretPos;
			    }
		    }
		}

		// Note: This will flicker, if someone has a good idea how to prevent this - let me know
		
		// Select at the end of text and replace the selection
		// This is a very fast way to add text to an edit control
		SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, crColor);
		SetSel(iStartChar, iEndChar); // Restore our previous selection

		if (!m_bAutoScroll)
			//LineScroll(nFirstLine - GetFirstVisibleLine());
			SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptPos);
		else
			ScrollToLastLine();

		m_bNoPaint = false;
		if (bIsVisible)
		{
			SetRedraw();
			if (m_bRichEdit)
				Invalidate();
		}
d593 2
a594 3
	POINT ptPos;
	if (!m_bAutoScroll)
		SendMessage(EM_GETSCROLLPOS, 0, (LPARAM)&ptPos);
d603 4
a607 1

a611 2

	CString strLog;
d614 1
d656 2
a657 4
	SetSel(iStartChar, iEndChar);

	if (!m_bAutoScroll)
		SendMessage(EM_SETSCROLLPOS, 0, (LPARAM)&ptPos);
d659 3
d663 5
@


1.15
log
@removed prepared RTF predefined colors (uses RGB(#, #, #) now) + some fixes
@
text
@d478 6
d487 1
a487 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz) + _T("\"}}{\\fldrslt{{\\ul\\cf3 ") + CString(psz) + _T("}}}}");
d493 1
a493 1
							strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + str + _T("\"}}{\\fldrslt{{\\ul\\cf3 ") + str + _T("}}}}");
d780 1
a780 1
void CPreparedRTFText::AppendText(const CString& strLine, COLORREF crColor)
a781 7
	int len = m_sText.GetLength();
	if( len > (32*1024) )
	{
		m_sText = m_sText.Right(24*1024);
		len = m_sText.Find(_T("\n\\par"));
		m_sText.Delete(0, len + 5);
	}
a782 1
	CString sColor;
d786 3
a788 1
		if (m_sRtfHeader.GetLength() == strRtfHeader.GetLength())
d790 1
a790 1
			m_sRtfHeader += _T("\n{\\colortbl ;") + sColor + _T("}\n");
d795 2
a796 3
			int iIndex = 0;
			bool bFound = false;
			while (iIndex != -1 && !bFound)
d799 6
a804 7
				iIndex = m_sRtfHeader.Find(_T("\\red"), iIndex + 1);
				if (m_sRtfHeader.Mid(iIndex, sColor.GetLength()) == sColor)
					bFound = true;
			}
			if (!bFound)
			{
				m_sRtfHeader.Insert(m_sRtfHeader.GetLength() - 2, sColor);
d806 1
d810 13
d843 2
d848 1
a848 1
					m_sText += _T("\\ul\\cf14 ") + CString(psz) + _T("\\ul0") + sColor;
d854 1
a854 1
					m_sText += _T("\\ul\\cf14 ") + str + _T("\\ul0") + sColor;
@


1.14
log
@more fixes/changes
@
text
@d32 1
a32 44
/* - Prepared RTF Color Table
 0 Automatic
 1 Black			->	RGB(0, 0, 0)
 2 Brown			->	RGB(153, 51, 0)
 3 Olive Green		->	RGB(51, 51, 0)
 4 Dark Green		->	RGB(0, 51, 0)
 5 Dark Teal		->	RGB(0, 51, 102)
 6 Dark Blue		->	RGB(0, 0, 128)
 7 Indigo			->	RGB(51, 51, 153)
 8 Gray-80%			->	RGB(51, 51, 51)
 9 Dark Red			->	RGB(128, 0, 0)
10 Orange			->	RGB(255 102, 0)
11 Dark Yello		->	RGB(128, 128, 0)
12 Green			->	RGB(0, 128, 0)
13 Teal				->	RGB(0, 128, 128)
14 Blue				->	RGB(0, 0, 255)
15 Blue-Gray		->	RGB(102, 102, 153)
16 Gray-50%			->	RGB(128, 128, 128)
17 Red				->	RGB(255, 0, 0)
18 Light Orange		->	RGB(255, 153, 0)
19 Lime				->	RGB(153, 204, 0)
20 Sea Green		->	RGB(51, 153, 102)
21 Aqua				->	RGB(51, 204, 204)
22 Light Blue		->	RGB(51, 102, 255)
23 Violet			->	RGB(128, 0, 128)
24 Gray-40%			->	RGB(153, 153, 153)
25 Pink				->	RGB(255, 0, 255)
26 Gold				->	RGB(255, 204, 0)
27 Yellow			->	RGB(255, 255, 0)
28 Bright Green		->	RGB(0, 255, 0)
29 Turquoise		->	RGB(0, 255, 255)
30 Sky Blue			->	RGB(0, 204, 255)
31 Plum				->	RGB(153, 51, 102)
32 Gray-25%			->	RGB(192, 192, 192)
33 Rose				->	RGB(255, 153, 204)
34 Tan				->	RGB(255, 204, 153)
35 Light Yellow		->	RGB(255, 255, 153)
36 Light Green		->	RGB(204, 255, 204)
37 Light Turquoise	->	RGB(204, 255, 255)
38 Pale Blue		->	RGB(153, 204, 255)
39 Lavender			->	RGB(204, 153, 255)
40 White			->	RGB(255, 255, 255)
*/
CString strRrfHeader = _T("{\\rtf\\ansi\n{\\colortbl ;\\red0\\green0\\blue0;\\red153\\green51\\blue0;\\red51\\green51\\blue0;\\red0\\green51\\blue0;\\red0\\green51\\blue102;\\red0\\green0\\blue128;\\red51\\green51\\blue153;\\red51\\green51\\blue51;\\red128\\green0\\blue0;\\red255\\green102\\blue0;\\red128\\green128\\blue0;\\red0\\green128\\blue0;\\red0\\green128\\blue128;\\red0\\green0\\blue255;\\red102\\green102\\blue153;\\red128\\green128\\blue128;\\red255\\green0\\blue0;\\red255\\green153\\blue0;\\red153\\green204\\blue0;\\red51\\green153\\blue102;\\red51\\green204\\blue204;\\red51\\green102\\blue255;\\red128\\green0\\blue128;\\red153\\green153\\blue153;\\red255\\green0\\blue255;\\red255\\green204\\blue0;\\red255\\green255\\blue0;\\red0\\green255\\blue0;\\red0\\green255\\blue255;\\red0\\green204\\blue255;\\red153\\green51\\blue102;\\red192\\green192\\blue192;\\red255\\green153\\blue204;\\red255\\green204\\blue153;\\red255\\green255\\blue153;\\red204\\green255\\blue204;\\red204\\green255\\blue255;\\red153\\green204\\blue255;\\red204\\green153\\blue255;\\red255\\green255\\blue255;}");
d123 1
a123 1
void CHTRichEditCtrl::AddLine(LPCTSTR pszMsg, bool bLink, bool bColor, COLORREF crColor)
d158 1
a158 1
			SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, bColor, crColor);
d175 1
a175 1
			SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, bColor, crColor);
d236 1
a236 1
		SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink, bColor, crColor);
d279 1
a279 1
void CHTRichEditCtrl::SafeAddLine(long nPos, LPCTSTR pszLine, long& iStartChar, long& iEndChar, bool bLink, bool bColor, COLORREF crColor)
d291 1
a291 1
	if (bColor)
d356 4
a359 1
		m_pPreparedText->m_sText = strRrfHeader;
d458 9
a466 1
			if (m_pPreparedText)
d468 2
a469 4
				int index1 = 0;
				int index2;
				strLog = m_pPreparedText->GetText() + _T("}");
				while( index1 != -1 )
d471 1
a471 3
					index1 = strLog.Find(_T("\\ul\\cf14 "));
					index2 = strLog.Find(_T("\\ul0"));
					if (( index1 != -1 ) && ( index2 != -1 ))
d473 12
a484 25
						strLog.Delete(index2, 4);
						strLog.Delete(index1, 9);
						strTemp = strLog.Mid(index1, index2 - index1 - 9);
						strLog.Insert(index2 - 9,_T("\"}}{\\fldrslt{{\\ul\\cf6 ") + strTemp + _T("}}}}"));
						strLog.Insert(index1,_T("{\\field{\\*\\fldinst {HYPERLINK \""));
					}
				}
				strLog.Replace(_T("\\ul\\cf6 "),_T("\\ul\\cf14 "));
			}
			else
			{
				strTemp = _T("");
				strLog = _T("");
				EDITSTREAM es;
				es.dwCookie = (DWORD)&strTemp; 
				es.pfnCallback = MEditStreamOutCallback;
				StreamOut(SF_RTF,es);
				LPCTSTR psz = strTemp;
				LPCTSTR pszStart = psz;
				while (*psz != _T('\0'))
				{
					bool bFoundScheme = false;
					for (int i = 0; i < ARRSIZE(_apszSchemes); i++)
					{
						if (_tcsncmp(psz, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0)
d486 3
a488 20
							if (psz - pszStart > 0)
							{
								CString str(pszStart, psz - pszStart);
								strLog += str;
							}
							int iLen = _tcscspn(psz, _T(" \n\r\t\\"));
							if (iLen == 0)
							{
								strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + CString(psz) + _T("\"}}{\\fldrslt{{\\ul\\cf3 ") + CString(psz) + _T("}}}}");
								psz += _tcslen(psz);
							}
							else
							{
								CString str(psz, iLen);
								strLog += _T("{\\field{\\*\\fldinst {HYPERLINK \"") + str + _T("\"}}{\\fldrslt{{\\ul\\cf3 ") + str + _T("}}}}");
								psz += iLen;
							}
							pszStart = psz;
							bFoundScheme = true;
							break;
d490 3
a493 2
					if (!bFoundScheme)
						psz = _tcsinc(psz);
d495 3
d499 2
a500 3
				if (*pszStart != _T('\0'))
					strLog += pszStart;
			}
d531 1
a531 1
void CHTRichEditCtrl::AppendText(const CString& sText, bool bInvalidate)
d546 1
a546 1
					AddLine(str);
a568 1

d570 1
a570 1
		AddLine(pszStart);
d573 1
a573 6
void CHTRichEditCtrl::AppendKeyWord(const CString& sText, COLORREF crColor)
{
	AddLine(sText, false, true, crColor);
}

void CHTRichEditCtrl::AppendHyperLink(const CString& sText, const CString& sTitle, const CString& sCommand, const CString& sDirectory, bool bInvalidate)
d642 2
a643 1
	m_pPreparedText->m_sText.AppendChar(_T('}'));
d647 1
a647 2
	SendMessage(EM_SETTEXTEX, (WPARAM)&st, (LPARAM)(LPCTSTR)m_pPreparedText->GetText());
	m_pPreparedText->m_sText.Delete(m_pPreparedText->m_sText.GetLength()-1);
d766 2
a767 1
	m_sText = strRrfHeader;
d774 1
a774 1
void CPreparedRTFText::AppendText(const CString& strLine, int iColor)
a781 1
		m_sText.Insert(0, strRrfHeader);
d783 1
d785 25
@


1.13
log
@some more fixing + added more predefined colors to prepared rtf
@
text
@d506 1
a506 1
					index2 = strLog.Find(_T("\\ul0\\cf0 "));
d509 1
a509 1
						strLog.Delete(index2, 9);
d842 1
a842 1
void CPreparedRTFText::AppendKeyWord(const CString& str, int iColor)
d852 3
a854 2

	CString sText = str;
d859 1
a859 26
	if (iColor != 0)
	{
		m_sText.AppendFormat(_T("\\cf%i "),iColor);
		m_sText += sText + _T("\\cf0 ");
	}
	else
		m_sText += sText;
}

void CPreparedRTFText::AppendText(const CString& str)
{
	int len = m_sText.GetLength();
	if( len > (32*1024) )
	{
		m_sText = m_sText.Right(24*1024);
		len = m_sText.Find(_T("\n\\par"));
		m_sText.Delete(0, len + 5);
		m_sText.Insert(0, strRrfHeader);
	}
	
	CString sText = str;
	sText.Replace(_T("\\"),_T("\\\\"));
	sText.Replace(_T("{"),_T("\\{"));
	sText.Replace(_T("}"),_T("\\}"));
	sText.Replace(_T("\n"),_T("\n\\par"));

d877 1
a877 1
					m_sText += _T("\\ul\\cf14 ") + CString(psz) + _T("\\ul0\\cf0 ");
d883 1
a883 1
					m_sText += _T("\\ul\\cf14 ") + str + _T("\\ul0\\cf0 ");
a893 1

@


1.12
log
@some changes & fixes
@
text
@d32 44
a75 1
CString strRrfHeader = _T("{\\rtf\\ansi\n{\\colortbl;\\red0\\green0\\blue0;\\red150\\green0\\blue0;\\red1\\green100\\blue1;\\red128\\green128\\blue0;\\red1\\green20\\blue130;\\red128\\green0\\blue128;\\red0\\green128\\blue128;\\red128\\green128\\blue128;\\red192\\green192\\blue192;\\red255\\green0\\blue0;\\red1\\green180\\blue20;\\red255\\green255\\blue0;\\red0\\green0\\blue255;\\red255\\green0\\blue255;\\red50\\green200\\blue250;\\red255\\green255\\blue255;}");
d505 1
a505 1
					index1 = strLog.Find(_T("\\ul\\cf13 "));
d512 1
a512 1
						strLog.Insert(index2 - 9,_T("\"}}{\\fldrslt{{\\ul\\cf3 ") + strTemp + _T("}}}}"));
d516 1
a516 1
				strLog.Replace(_T("\\ul\\cf3 "),_T("\\ul\\cf13 "));
d844 9
d858 7
a864 2
	m_sText.AppendFormat(_T("\\cf%i "),iColor);
	m_sText += sText + _T("\\cf0 ");
d873 1
a873 1
		len = m_sText.Find(_T("\\par\n"));
d901 1
a901 1
					m_sText += _T("\\ul\\cf13 ") + CString(psz) + _T("\\ul0\\cf0 ");
d907 1
a907 1
					m_sText += _T("\\ul\\cf13 ") + str + _T("\\ul0\\cf0 ");
@


1.11
log
@Fixed "Clear" command for prepared RTF
@
text
@a456 1
				strLog = m_pPreparedText->GetText() + _T("}");
d459 1
a459 1
				int index3;
a463 8
					index3 = strLog.Find(_T("\\par\\ul0\\cf0 "));
					if (( index3 != -1 ) && ( index3 < index2 ))
					{
						index2 = index3;
						index3 = 13;
					}
					else 
						index3 = 9;
d466 1
a466 1
						strLog.Delete(index2, index3);
d468 1
a468 3
						strTemp = strLog;
						strTemp.Delete(index2 - 9, strLog.GetLength() - (index2 - index1));
						strTemp.Delete(0, index1);
d805 1
a805 1
	sText.Replace(_T("\n"),_T("\\par\n"));
d825 1
a825 1
	sText.Replace(_T("\n"),_T("\\par\n"));
@


1.10
log
@small fix
@
text
@d32 2
d355 2
d803 1
a803 1
	m_sText = _T("{\\rtf\\ansi\n{\\colortbl;\\red0\\green0\\blue0;\\red150\\green0\\blue0;\\red1\\green100\\blue1;\\red128\\green128\\blue0;\\red1\\green20\\blue130;\\red128\\green0\\blue128;\\red0\\green128\\blue128;\\red128\\green128\\blue128;\\red192\\green192\\blue192;\\red255\\green0\\blue0;\\red1\\green180\\blue20;\\red255\\green255\\blue0;\\red0\\green0\\blue255;\\red255\\green0\\blue255;\\red50\\green200\\blue250;\\red255\\green255\\blue255;}");
d829 1
a829 1
		m_sText.Insert(0,_T("{\\rtf\\ansi\n{\\colortbl;\\red0\\green0\\blue0;\\red150\\green0\\blue0;\\red1\\green100\\blue1;\\red128\\green128\\blue0;\\red1\\green20\\blue130;\\red128\\green0\\blue128;\\red0\\green128\\blue128;\\red128\\green128\\blue128;\\red192\\green192\\blue192;\\red255\\green0\\blue0;\\red1\\green180\\blue20;\\red255\\green255\\blue0;\\red0\\green0\\blue255;\\red255\\green0\\blue255;\\red50\\green200\\blue250;\\red255\\green255\\blue255;}"));
@


1.9
log
@Fixed mouse cursor on logs context menu + All logs are now saved as RTF
@
text
@d281 3
a285 3
		CHARFORMAT2 cf;
		memset2(&cf, 0, sizeof cf);
		GetSelectionCharFormat(cf);
a287 1
		SetSelectionCharFormat(cf);
d289 1
a289 1
	else if (bColor)
a290 3
		CHARFORMAT2 cf;
		memset2(&cf, 0, sizeof cf);
		GetSelectionCharFormat(cf);
a293 1
		SetSelectionCharFormat(cf);
d295 3
@


1.8
log
@small fix
@
text
@d12 20
d36 1
a44 1

d52 2
d58 2
d141 2
a142 2
		strLog.Replace("\n","");
		int len	= strLog.ReverseFind('\r');
d368 1
a368 1

d385 1
d411 10
d447 2
a448 2
	CString strLog,tmpPath;
	if (m_pPreparedText)
d450 2
a451 1
		if (DialogBrowseFile(tmpPath, _T("Rich Text Format (RTF)|*.rtf||"), _T(".rtf"), 0, FALSE))
d453 1
a453 2
			HANDLE hFile=CreateFile(tmpPath,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);
			if (hFile != INVALID_HANDLE_VALUE)
a454 1
				DWORD written;
a458 1
				CString strURL;
d475 4
a478 4
						strURL = strLog;
						strURL.Delete(index2 - 9, strLog.GetLength() - (index2 - index1));
						strURL.Delete(0, index1);
						strLog.Insert(index2 - 9,_T("\"}}{\\fldrslt{{\\ul\\cf3 ") + strURL + _T("}}}}"));
d482 48
a529 11
				strLog.Replace("\\ul\\cf3 ","\\ul\\cf13 ");
				WriteFile(hFile,strLog,strLog.GetLength(),&written,NULL);
				CloseHandle(hFile);
			}				
		}
	}
	else if (DialogBrowseFile(tmpPath, _T("Log (*.log)|*.log||"), _T(".log"), 0, FALSE))
	{
		HANDLE hFile=CreateFile(tmpPath,GENERIC_WRITE,0,NULL,CREATE_ALWAYS,FILE_ATTRIBUTE_ARCHIVE,NULL);
		if (hFile != INVALID_HANDLE_VALUE)
		{
d531 1
a531 3
			GetWindowText(strLog);
			strLog.Replace("\n","\r\n");
			WriteFile(hFile,strLog,strLog.GetLength(),&written,NULL);
a559 15
static const struct
{
	LPCTSTR pszScheme;
	int iLen;
} _apszSchemes[] = 
{
	{ _T("ed2k://"),  7 },
	{ _T("http://"),  7 },
	{ _T("https://"), 8 },
	{ _T("ftp://"),   6 },
	{ _T("www."),     4 },
	{ _T("ftp."),     4 },
	{ _T("mailto:"),  7 }
};

d677 1
a677 1
	m_pPreparedText->m_sText.AppendChar('}');
d686 1
a686 1
	strLog.Replace("\n","");
d811 4
a814 4
	sText.Replace("\\","\\\\");
	sText.Replace("{","\\{");
	sText.Replace("}","\\}");
	sText.Replace("\n","\\par\n");
d831 4
a834 4
	sText.Replace("\\","\\\\");
	sText.Replace("{","\\{");
	sText.Replace("}","\\}");
	sText.Replace("\n","\\par\n");
a844 1
				// output everything before the URL
a849 1
				// search next space or EOL
@


1.7
log
@Fix for text size limit
@
text
@d253 1
a253 1
void CHTRichEditCtrl::SafeAddLine(int nPos, LPCTSTR pszLine, long& iStartChar, long& iEndChar, bool bLink, bool bColor, COLORREF crColor)
d343 1
a343 1
	int iTextLen = GetWindowTextLength();
@


1.6
log
@Got rid of LogEditCtrl + Some minor changes
@
text
@d112 11
@


1.5
log
@Converted IRC/Messages to Rich Edit  (added copy text to clipboard & save logs with colors as RTF)
@
text
@d87 1
a87 1
	strLine += _T("\n");
d97 1
a97 1
void CHTRichEditCtrl::AddLine(LPCTSTR pszMsg, bool bLink)
d121 1
a121 1
			SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink);
d138 1
a138 1
			SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink);
d199 1
a199 1
		SafeAddLine(iSize, pszMsg, iStartChar, iEndChar, bLink);
d203 1
d242 1
a242 1
void CHTRichEditCtrl::SafeAddLine(int nPos, LPCTSTR pszLine, long& iStartChar, long& iEndChar, bool bLink)
d255 10
d537 5
@


1.4
log
@Log menues localization fix
@
text
@d24 1
a202 2
		{
			//LineScroll(nFirstLine - GetFirstVisibleLine());
a203 1
		}
d229 1
d327 2
d348 3
d388 59
a501 1

d585 11
a595 1
	//SetWindowText(m_pPreparedText->GetText());
d603 58
d721 1
a721 1
	m_sText = _T("{\\rtf\\ansi");
d728 1
a728 1
void CPreparedRTFText::AppendKeyWord(const CString& str, COLORREF cr)
d730 7
a736 7
	if (!m_sText.IsEmpty() && m_sText[m_sText.GetLength()-1] == _T('\n'))
	{
		m_sText.Delete(m_sText.GetLength()-1);
		m_sText += _T("\\par");
	}
	m_sText.AppendFormat(_T("\\red%u\\green%u\\blue%u"), GetRValue(cr), GetGValue(cr), GetBValue(cr));
	m_sText += str;
d741 18
a758 1
	if (!m_sText.IsEmpty() && m_sText[m_sText.GetLength()-1] == _T('\n'))
d760 31
a790 2
		m_sText.Delete(m_sText.GetLength()-1);
		m_sText += _T("\\par");
d792 3
a794 1
	m_sText += str;
@


1.3
log
@Formatting + minor changes
@
text
@a42 9
	m_LogMenu.CreatePopupMenu();
	m_LogMenu.AddMenuTitle(GetResString(IDS_LOGENTRY));
	m_LogMenu.AppendMenu(MF_STRING,MP_COPYSELECTED, GetResString(IDS_COPY));
	m_LogMenu.AppendMenu(MF_SEPARATOR);
	m_LogMenu.AppendMenu(MF_STRING,MP_SELECTALL, GetResString(IDS_SELECTALL));
	m_LogMenu.AppendMenu(MF_STRING,MP_REMOVEALL, GetResString(IDS_PW_RESET));
	m_LogMenu.AppendMenu(MF_SEPARATOR);
	m_LogMenu.AppendMenu(MF_STRING,MP_AUTOSCROLL, GetResString(IDS_AUTOSCROLL));

d324 3
d328 4
d333 2
a334 1
	m_LogMenu.EnableMenuItem(MP_SELECTALL, iTextLen > 0 ? MF_ENABLED : MF_GRAYED);
d337 1
@


1.2
log
@minor changes
@
text
@d24 2
a25 1
CHTRichEditCtrl::CHTRichEditCtrl(){
d33 2
a34 1
CHTRichEditCtrl::~CHTRichEditCtrl(){
d37 2
a38 1
void CHTRichEditCtrl::Localize(){
d70 2
a71 1
	switch (message) {
d84 2
a85 1
	if (m_astrBuff.GetSize() > 0){ // flush buffer
d96 1
a96 1
	if (m_hWnd == NULL){
d98 2
a99 2
	}
	else{
d155 2
a156 1
			if (bIsVisible){
d189 2
a190 1
			if (!m_bRichEdit){
d210 2
a211 1
		if (!m_bAutoScroll){
d219 2
a220 1
		if (bIsVisible){
d255 2
a256 1
	if (bLink){
d301 1
a301 1
			if (m_bEnErrSpace && nPos == 0){
a304 1
			}
d308 2
a309 1
		if (bIsVisible && !m_bNoPaint){
d317 2
a318 1
void CHTRichEditCtrl::Reset(){
d327 2
a328 1
void CHTRichEditCtrl::OnContextMenu(CWnd* pWnd, CPoint point){
d340 4
a343 2
BOOL CHTRichEditCtrl::OnCommand(WPARAM wParam, LPARAM lParam){
	switch (wParam) {
d360 2
a361 1
CString CHTRichEditCtrl::GetLastLogEntry(){
d364 2
a365 1
	if (iLastLine >= 0){
d372 2
a373 1
CString CHTRichEditCtrl::GetAllLogEntries(){
d434 2
a435 1
				if (psz - pszStart > 0){
d442 2
a443 1
				if (iLen == 0){
d447 2
a448 1
				else{
d486 4
a489 2
		for (int i = 0; i < ARRSIZE(_apszSchemes); i++){
			if (_tcsncmp(strUrl, _apszSchemes[i].pszScheme, _apszSchemes[i].iLen) == 0){
d566 2
a567 2
//	cf.dwMask |= CFM_CHARSET;
//	cf.bCharSet = lf.lfCharSet;
d572 2
a573 1
	if (bRedraw){
@


1.1
log
@*** empty log message ***
@
text
@a11 2
#define MAX_LOG_BUF		(64*1024)-1

d50 5
a54 1
	LimitText(MAX_LOG_BUF);
d78 9
d95 1
a95 5
		if (m_astrBuff.GetSize() > 0){ // flush buffer
			for (int i = 0; i < m_astrBuff.GetSize(); i++)
				AddLine(m_astrBuff[i]);
			m_astrBuff.RemoveAll();
		}
d233 7
@

