head	1.4;
access;
symbols
	PublicRelease_1_2e:1.4
	Interim_Release_1-2e_RC1:1.4
	PublicRelease_1_2d:1.4
	Interim_Release_1-2d_RC1:1.4
	Interim_Release_1-2d_beta1:1.4
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.3
	Interim_Release_1-1d_RC1:1.3
	PublicRelease_1_1c:1.3
	Interim_Release_1-1c_RC1:1.3
	Interim_Release_1-1c_beta2:1.3
	Interim_Release_1-1c_beta1:1.3
	PublicRelease_1_1b:1.3
	Interim_Release_1-1b_RC1:1.3
	PublicRelease_1_1a:1.3
	Interim_Release_1-1a_RC2:1.3
	Interim_Release_1-1a_RC1:1.3
	Interim_Release_1-1a_beta2:1.3
	Interim_Release_1-1a_beta1:1.3
	PublicRelease_1_1:1.3
	Interim_Release_1-1_beta1:1.3
	PublicRelease_1o:1.3
	Interim_Release_1o_RC1:1.3
	Interim_Release_1o_beta1:1.3
	PublicRelease_1n:1.3
	Interim_Release_1n_RC2:1.3
	Interim_Release_1n_RC1:1.3
	Interim_Release_1n_beta2:1.3
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.3
	Interim_Release_1l_RC1:1.3
	Interim_Release_1l_beta2:1.3
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.3
	Interim_Release_1k_RC4:1.3
	Interim_1k_RC3:1.3
	Interim_1k_RC2:1.3
	Interim_Release_1k_RC1:1.3
	Interim_Release_1k_beta5:1.3
	Intrerim_Release_1k_beta4:1.3
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.3
	Interim_Release_1i_RC2:1.3
	Interim_Release_1i_RC1:1.3
	Interim_Release_1i_beta3:1.3
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2005.05.21.20.09.25;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.13.17.48.31;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.20;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.16;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Unified and slightly faster way to draw list cursor; Remove unrequired class MemDC2.
@
text
@//////////////////////////////////////////////////
// CMemDC - memory DC
//
// Author: Keith Rule
// Email:  keithr@@europa.com
// Copyright 1996-2002, Keith Rule
//
// You may freely use or modify this code provided this
// Copyright is included in all derived versions.
//
// History - 10/3/97 Fixed scrolling bug.
//               Added print support. - KR
//
//       11/3/99 Fixed most common complaint. Added
//            background color fill. - KR
//
//       11/3/99 Added support for mapping modes other than
//            MM_TEXT as suggested by Lee Sang Hun. - KR
//
//       02/11/02 Added support for CScrollView as supplied
//             by Gary Kirkham. - KR
//
// This class implements a memory Device Context which allows
// flicker free drawing.

#pragma once

class CMemDC : public CDC
{
private:
	CBitmap		m_bitmap;		// Offscreen bitmap
	CBitmap		*m_oldBitmap;	// bitmap originally found in CMemDC
	CDC			*m_pDC;			// Saves CDC passed in constructor
	CRect		m_rect;			// Rectangle of drawing area
	bool		m_bMemDC;		// TRUE if CDC really is a Memory DC
	bool		m_bFlushed;
public:

	CMemDC(CDC *pDC, const RECT *pRect, COLORREF crWinBk, COLORREF crBk) : CDC()
	{
		EMULE_TRY
		ASSERT(pDC != NULL);

		// Some initialization
		m_pDC = pDC;
		m_oldBitmap = NULL;
		m_bMemDC = !pDC->IsPrinting();
		m_bFlushed = false;
		m_rect = *pRect;

		if (m_bMemDC)
		{
			// Create a Memory DC
			CreateCompatibleDC(pDC);
			//pDC->LPtoDP(&m_rect);

			m_bitmap.CreateCompatibleBitmap(pDC, m_rect.Width(), m_rect.Height());
			m_oldBitmap = SelectObject(&m_bitmap);

			SetMapMode(pDC->GetMapMode());

			SetWindowExt(pDC->GetWindowExt());
			SetViewportExt(pDC->GetViewportExt());

			//pDC->DPtoLP(&m_rect);
			SetWindowOrg(m_rect.left, m_rect.top);
		} else {
			m_bPrinting = pDC->m_bPrinting;
			m_hDC       = pDC->m_hDC;
			m_hAttribDC = pDC->m_hAttribDC;
		}

	// Fill background
		if (crWinBk != crBk)
		{
		//	Draw cursor
			long	lRight = m_rect.right, lLeft = m_rect.left;

		//	Margins around cursor
			SetBkColor(crWinBk);
			m_rect.right = lLeft + 1;
			ExtTextOut(0, 0, ETO_OPAQUE, m_rect, NULL, 0, NULL);	// fast fill rectangle
			m_rect.right = lRight;
			m_rect.left = lRight - 1;
			ExtTextOut(0, 0, ETO_OPAQUE, m_rect, NULL, 0, NULL);

			m_rect.right = lRight - 1;
			m_rect.left = lLeft + 1;
			FillSolidRect(m_rect, crBk);
			m_rect.right++;
			m_rect.left--;
		}
		else
			FillSolidRect(m_rect, crBk);
		EMULE_CATCH2
	}
	
	~CMemDC()
	{
		Flush();
	}

	void Flush()
	{
		if (!m_bFlushed){
			m_bFlushed = true;
			if (m_bMemDC) {
				// Copy the offscreen bitmap onto the screen
				m_pDC->BitBlt(m_rect.left, m_rect.top, m_rect.Width(),
					m_rect.Height(), this, m_rect.left, m_rect.top, SRCCOPY);

				// Swap back the original bitmap
				SelectObject(m_oldBitmap);
			}
			else
				m_hDC = m_hAttribDC = NULL;
		}
	}

// Allow usage as a pointer
	CMemDC* operator->()
	{
		return this;
	}

// Allow usage as a pointer
	operator CMemDC*()
	{
		return this;
	}
};
@


1.3
log
@*** empty log message ***
@
text
@d28 9
a36 8
class CMemDC : public CDC {
private:       
    CBitmap    m_bitmap;        // Offscreen bitmap
    CBitmap*       m_oldBitmap; // bitmap originally found in CMemDC
    CDC*       m_pDC;           // Saves CDC passed in constructor
    CRect      m_rect;          // Rectangle of drawing area.
    BOOL       m_bMemDC;        // TRUE if CDC really is a Memory DC.
	bool	   m_bFlushed;
d38 3
a40 3
    
    CMemDC(CDC* pDC, const CRect* pRect = NULL) : CDC()
    {
d42 6
a47 6
        ASSERT(pDC != NULL); 
 
        // Some initialization
        m_pDC = pDC;
        m_oldBitmap = NULL;
        m_bMemDC = !pDC->IsPrinting();
d49 3
a51 3
 
        // Get the rectangle to draw
        if (pRect == NULL) 
d53 22
a74 6
             pDC->GetClipBox(&m_rect);
        } else {
             m_rect = *pRect;
        }
 
        if (m_bMemDC) 
d76 19
a94 23
             // Create a Memory DC
             CreateCompatibleDC(pDC);
             pDC->LPtoDP(&m_rect);
 
             m_bitmap.CreateCompatibleBitmap(pDC, m_rect.Width(), 
                                                  m_rect.Height());
             m_oldBitmap = SelectObject(&m_bitmap);
 
             SetMapMode(pDC->GetMapMode());
 
             SetWindowExt(pDC->GetWindowExt());
             SetViewportExt(pDC->GetViewportExt());
 
             pDC->DPtoLP(&m_rect);
             SetWindowOrg(m_rect.left, m_rect.top);
        } else {
             m_bPrinting = pDC->m_bPrinting;
             m_hDC       = pDC->m_hDC;
             m_hAttribDC = pDC->m_hAttribDC;
        }
 
        // Fill background 
        FillSolidRect(m_rect, pDC->GetBkColor());
d96 4
a99 4
    }
    
    ~CMemDC()      
    {
d101 1
a101 1
    }
d108 6
a113 7
				// Copy the offscreen bitmap onto the screen.
				m_pDC->BitBlt(m_rect.left, m_rect.top, 
							m_rect.Width(),  m_rect.Height(),
					this, m_rect.left, m_rect.top, SRCCOPY);            
	             
				//Swap back the original bitmap.
				SelectObject(m_oldBitmap);        
d116 1
a116 1
				m_hDC = m_hAttribDC = NULL;  
a118 13
    
    // Allow usage as a pointer    
    CMemDC* operator->() 
    {
        return this;
    }       
 
    // Allow usage as a pointer    
    operator CMemDC*() 
    {
        return this;
    }
};
d120 4
a123 68
// 13.11.02: obsolet now?
// added by FoRcHa (used for flicker free drawing of ListCtrls)

class CMemDC2 : public CDC {
private:       
    CBitmap    m_bitmap;        // Offscreen bitmap
    CBitmap*       m_oldBitmap; // bitmap originally found in CMemDC
    CDC*       m_pDC;           // Saves CDC passed in constructor
    CRect      m_rect;          // Rectangle of drawing area.
    BOOL       m_bMemDC;        // TRUE if CDC really is a Memory DC.
	bool	   m_bFlushed;
public:
    
    CMemDC2(CDC* pDC, const CRect* pRect = NULL) : CDC()
    {
		EMULE_TRY
        ASSERT(pDC != NULL); 
 
        // Some initialization
        m_pDC = pDC;
        m_oldBitmap = NULL;
        m_bMemDC = !pDC->IsPrinting();
		m_bFlushed = false;
 
        // Get the rectangle to draw
        if (pRect == NULL) 
		{
			CWnd* wndPdc = pDC->GetWindow();
			wndPdc->GetClientRect( &m_rect);
        } 
		else 
		{
             m_rect = *pRect;
        }
 
        if(m_bMemDC) 
		{
             // Create a Memory DC
             CreateCompatibleDC(pDC);
             pDC->LPtoDP(&m_rect);
 
             m_bitmap.CreateCompatibleBitmap(pDC, m_rect.Width(), 
                                                  m_rect.Height());
             m_oldBitmap = SelectObject(&m_bitmap);
 
             SetMapMode(pDC->GetMapMode());
 
             SetWindowExt(pDC->GetWindowExt());
             SetViewportExt(pDC->GetViewportExt());
 
             pDC->DPtoLP(&m_rect);
             SetWindowOrg(m_rect.left, m_rect.top);
        } 
		else 
		{
             m_bPrinting = pDC->m_bPrinting;
             m_hDC       = pDC->m_hDC;
             m_hAttribDC = pDC->m_hAttribDC;
        }
 
        // Fill background 
        FillSolidRect(m_rect, pDC->GetBkColor());
		EMULE_CATCH2
    }
    
    ~CMemDC2()      
    {   
		Flush();
d126 2
a127 1
	void Flush()
d129 2
a130 35
		EMULE_TRY

		if(!m_bFlushed)
		{
			m_bFlushed = true;

			if(m_bMemDC) 
			{
				 // Copy the offscreen bitmap onto the screen.
				m_pDC->BitBlt(m_rect.left, m_rect.top, m_rect.Width(),  m_rect.Height(),
								this, m_rect.left, m_rect.top, SRCCOPY);            
             
				//Swap back the original bitmap.
				SelectObject(m_oldBitmap);        
			}
			else
			{
				m_hDC = m_hAttribDC = NULL;  
			}
		}

		EMULE_CATCH2
    }
    
    // Allow usage as a pointer    
    CMemDC2* operator->() 
    {
        return this;
    }       
 
    // Allow usage as a pointer    
    operator CMemDC2*() 
    {
        return this;
    }
@


1.2
log
@More try/catch according to crash dumps
@
text
@d35 1
d47 1
d86 2
a87 15
    {          
		EMULE_TRY
        if (m_bMemDC) {
             // Copy the offscreen bitmap onto the screen.
             m_pDC->BitBlt(m_rect.left, m_rect.top, 
                           m_rect.Width(),  m_rect.Height(),
                  this, m_rect.left, m_rect.top, SRCCOPY);            
             
             //Swap back the original bitmap.
             if(m_oldBitmap)
             	SelectObject(m_oldBitmap);        
        }
		else
            m_hDC = m_hAttribDC = NULL;  
		EMULE_CATCH2
d89 18
d131 1
d143 1
d188 5
d194 2
a195 1
        if(m_bMemDC) 
d197 7
a203 3
             // Copy the offscreen bitmap onto the screen.
             m_pDC->BitBlt(m_rect.left, m_rect.top, m_rect.Width(),  m_rect.Height(),
                  this, m_rect.left, m_rect.top, SRCCOPY);            
d205 9
a213 5
             //Swap back the original bitmap.
             SelectObject(m_oldBitmap);        
        }
		else
            m_hDC = m_hAttribDC = NULL;  
@


1.1
log
@*** empty log message ***
@
text
@d39 1
d49 1
a49 1
	{
d80 1
d85 1
d98 1
d128 1
d174 1
d178 2
a179 1
    {          
d181 1
a181 1
	{
d189 1
a189 1
	else
d191 1
@


1.1.4.1
log
@updating this branch...
@
text
@@

