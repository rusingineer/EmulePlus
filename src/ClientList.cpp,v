head	1.94;
access;
symbols
	PublicRelease_1_2e:1.91
	Interim_Release_1-2e_RC1:1.91
	PublicRelease_1_2d:1.88
	Interim_Release_1-2d_RC1:1.88
	Interim_Release_1-2d_beta1:1.88
	PublicRelease_1_2c:1.86
	Interim_Release_1-2c_RC1:1.86
	Interim_Release_1-2c_beta1:1.86
	PublicRelease_1_2b:1.84
	Interim_Release_1-2b_RC1:1.80
	PublicRelease_1_2a:1.72
	Interim_Release_1-2a_RC1:1.71
	Interim_Release_1-2a_beta2:1.71
	Interim_Release_1-2a_beta1:1.71
	PublicRelease_1_2:1.71
	Interim_Release_1-2_RC1:1.71
	Interim_Release_1-2_beta1:1.71
	PublicRelease_1_1g:1.70
	Interim_Release_1-1g_RC3:1.70
	Interim_Release_1-1g_RC2:1.68
	Interim_Release_1-1g_RC1:1.68
	Interim_Release_1-1g_beta2:1.67
	Interim_Release_1-1g_beta1:1.63
	PublicRelease_1_1f:1.61
	Interim_Release_1-1f_RC1:1.61
	PublicRelease_1_1e:1.61
	Interim_Release_1-1e_RC2:1.61
	Interim_Release_1-1e_RC1:1.61
	Interim_Release_1-1e_beta1:1.61
	PublicRelease_1_1d:1.61
	Interim_Release_1-1d_RC1:1.61
	PublicRelease_1_1c:1.60
	Interim_Release_1-1c_RC1:1.60
	Interim_Release_1-1c_beta2:1.60
	Interim_Release_1-1c_beta1:1.60
	PublicRelease_1_1b:1.60
	Interim_Release_1-1b_RC1:1.60
	PublicRelease_1_1a:1.60
	Interim_Release_1-1a_RC2:1.60
	Interim_Release_1-1a_RC1:1.60
	Interim_Release_1-1a_beta2:1.59
	Interim_Release_1-1a_beta1:1.59
	PublicRelease_1_1:1.58
	Interim_Release_1-1_beta1:1.58
	PublicRelease_1o:1.58
	Interim_Release_1o_RC1:1.58
	Interim_Release_1o_beta1:1.57
	PublicRelease_1n:1.56
	Interim_Release_1n_RC2:1.56
	Interim_Release_1n_RC1:1.56
	Interim_Release_1n_beta2:1.53
	Interim_Release_1n_beta1:1.51
	PublicRelease_1m:1.50
	Interim_Release_1m_beta1:1.50
	PublicRelease_1l:1.50
	Interim_Release_1l_RC3:1.50
	Interim_Release_1l_RC2:1.50
	Interim_Release_1l_RC1:1.48
	Interim_Release_1l_beta2:1.48
	Interim_Release_1l_beta1:1.47
	PublicRelease_1k:1.44
	Interim_Release_1k_RC4:1.44
	Interim_1k_RC3:1.44
	Interim_1k_RC2:1.44
	Interim_Release_1k_RC1:1.44
	Interim_Release_1k_beta5:1.44
	Intrerim_Release_1k_beta4:1.44
	Interim_Release_1k_beta1:1.43
	PublicRelease_1j:1.40
	Interim_Release_1J_RC3:1.40
	Interim_Release_1j_RC3:1.40
	Interim_Release_1j_RC2:1.40
	Interim_Release_1j_RC1:1.40
	Interim_Release_1j_beta2:1.40
	Interim_Release_1j_beta1:1.40
	PublicRelease_1i:1.39
	Interim_Release_1i_RC6:1.39
	Interim_Release_1i_RC3:1.39
	Interim_Release_1i_RC2:1.39
	Interim_Release_1i_RC1:1.39
	Interim_Release_1i_beta3:1.39
	Interim_Release_1i_beta2:1.37
	Interim_Release_1i_beta1:1.30
	PublicRelease_1h:1.25
	Interim_Release_1h_rc2:1.25
	Interim_Release_1h_RC1:1.25
	Interim_Release_1h_beta2:1.25
	Interim_Release_1h_beta1_now:1.25
	Interim_Release_1h_beta1:1.25
	PublicRelease_1g:1.23
	Interim_Release_1g_RC6_Final:1.23
	Interim_Release_1g_RC6:1.23
	Interim_Release_1g_RC5:1.23
	Interim_Release_1g_RC4:1.23
	Interim_Release_1g_RC3:1.23
	Interim_Release_1g_beta2:1.22
	Interim_Release_1g_beta1:1.22
	Interim_Release_1f_RC4:1.21
	Interim_Release_1f_RC3:1.21
	Interim_Release_1f_RC2:1.19
	Interim_Release_1f_RC:1.19
	Interim_Release_1f_beta2:1.19
	Interim_Release_1f_beta1:1.17
	PublicRelease_1e:1.17
	Interim_Release_1e_RC2:1.17
	Interim_Release_1e_RC:1.17
	Interim_Release_1e_beta3:1.17
	Interim_Release_1e_beta2:1.17
	Interim_Release_1e_beta2_before_kuchin:1.17
	Interim_Release_1e_beta1:1.17
	PublicRelease_1c:1.17
	featurestest:1.17.0.8
	Interim_Release_1c_RC:1.17
	Interim_Release_1c_beta2:1.17
	Interim_Release_1c_beta1:1.17
	threaded_downloadqueue:1.17.0.6
	PublicRelease_1b:1.17
	Interim_Release_1b_beta2:1.17
	Interim_Release_1b_beta1:1.17
	proxydeadlake:1.17.0.4
	PublicRelease_1a:1.17
	Interim_Release_1a_beta2:1.17
	BerkeleyDb:1.17.0.2
	Interim_Release_1a_beta1:1.17
	PublicRelease_1:1.17
	goldfish:1.17
	eMulePlus_1_RC2:1.17
	eMulePlus_26b_1RC1:1.17
	PreRelease_26b_i0e:1.17
	before_26d_merge:1.17
	Interim_Release_26b_i0d:1.15
	Interim_Release_26b_i0c:1.10
	Interim_Release_26b_i0b:1.10
	Interim_Release_26b_i0a:1.10
	systraydlg:1.7.0.6
	plus26based:1.7.0.4
	Interim_Release_25b_i0b:1.7
	Proxy_Dev:1.7
	Interim_Release_25b_i0a:1.7.2.1
	proxytest:1.7.2.1.0.2
	official_sockets:1.7.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.94
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.93;

1.93
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.92;

1.92
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.91;

1.91
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.90;

1.90
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.89;

1.89
date	2008.07.26.03.32.22;	author aw3;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.31.18.18.52;	author fuxie-dk;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.18.18.55.32;	author fuxie-dk;	state Exp;
branches;
next	1.86;

1.86
date	2007.02.17.10.40.13;	author eklmn;	state Exp;
branches;
next	1.85;

1.85
date	2007.02.16.22.23.07;	author eklmn;	state Exp;
branches;
next	1.84;

1.84
date	2007.01.31.19.59.23;	author eklmn;	state Exp;
branches;
next	1.83;

1.83
date	2007.01.30.06.04.56;	author aw3;	state Exp;
branches;
next	1.82;

1.82
date	2007.01.28.15.04.24;	author aw3;	state Exp;
branches;
next	1.81;

1.81
date	2007.01.26.21.26.03;	author eklmn;	state Exp;
branches;
next	1.80;

1.80
date	2007.01.17.07.40.13;	author aw3;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.78;

1.78
date	2007.01.08.10.01.21;	author eklmn;	state Exp;
branches;
next	1.77;

1.77
date	2006.12.05.21.59.24;	author eklmn;	state Exp;
branches;
next	1.76;

1.76
date	2006.11.23.10.49.17;	author eklmn;	state Exp;
branches;
next	1.75;

1.75
date	2006.11.15.12.17.26;	author eklmn;	state Exp;
branches;
next	1.74;

1.74
date	2006.11.13.16.53.09;	author eklmn;	state Exp;
branches;
next	1.73;

1.73
date	2006.11.10.14.42.32;	author eklmn;	state Exp;
branches;
next	1.72;

1.72
date	2006.10.08.09.28.03;	author eklmn;	state Exp;
branches;
next	1.71;

1.71
date	2005.12.29.05.34.52;	author aw3;	state Exp;
branches;
next	1.70;

1.70
date	2005.12.13.01.58.02;	author aw3;	state Exp;
branches;
next	1.69;

1.69
date	2005.12.12.16.33.52;	author eklmn;	state Exp;
branches;
next	1.68;

1.68
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.67;

1.67
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.66;

1.66
date	2005.09.05.18.17.17;	author eklmn;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.29.03.00.34;	author aw3;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.28.08.28.56;	author eklmn;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.21.21.26.40;	author eklmn;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.14.22.06.36;	author aw3;	state Exp;
branches;
next	1.61;

1.61
date	2005.03.03.20.38.35;	author eklmn;	state Exp;
branches;
next	1.60;

1.60
date	2004.11.27.05.01.39;	author aw3;	state Exp;
branches;
next	1.59;

1.59
date	2004.10.25.20.41.10;	author aw3;	state Exp;
branches;
next	1.58;

1.58
date	2004.09.25.07.30.06;	author aw3;	state Exp;
branches;
next	1.57;

1.57
date	2004.09.21.20.15.04;	author aw3;	state Exp;
branches;
next	1.56;

1.56
date	2004.08.28.04.58.42;	author aw3;	state Exp;
branches;
next	1.55;

1.55
date	2004.08.17.14.06.16;	author aw3;	state Exp;
branches;
next	1.54;

1.54
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.53;

1.53
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.52;

1.52
date	2004.08.03.03.48.58;	author aw3;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.02.21.04.16;	author aw3;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.01.22.30.45;	author aw3;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.21.14.37.56;	author dongato;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.02.15.51.35;	author katsyonak;	state Exp;
branches;
next	1.46;

1.46
date	2004.04.23.22.13.41;	author katsyonak;	state Exp;
branches;
next	1.45;

1.45
date	2004.04.17.03.28.36;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.25.17.58.54;	author kush_eplus;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.16.15.45.52;	author netwolf1;	state Exp;
branches;
next	1.42;

1.42
date	2004.02.16.15.27.54;	author netwolf1;	state Exp;
branches;
next	1.41;

1.41
date	2004.02.07.01.26.46;	author netwolf1;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.29.14.14.17;	author morevit;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.26.12.02.50;	author eklmn;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.20.15.49.35;	author eklmn;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.20.13.19.57;	author morevit;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.17.10.29.05;	author morevit;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.13.15.01.57;	author morevit;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.05.10.18.46;	author eklmn;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.30.11.31.28;	author morevit;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.24.20.37.29;	author dongato;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.22.15.52.42;	author morevit;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.25;

1.25
date	2003.08.16.18.26.58;	author eklmn;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.09.15.14.37;	author kuchin;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.30.21.26.57;	author partyckip;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.20.20.46.25;	author netwolf1;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.20.16.30.40;	author netwolf1;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.09.23.07.44;	author moosetea;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.06.23.11.20;	author moosetea;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches
	1.17.8.1;
next	1.16;

1.16
date	2003.02.13.20.56.38;	author lord_kiron;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.12.20.41.20;	author lord_kiron;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.12.20.39.51;	author lord_kiron;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.12.20.34.41;	author lord_kiron;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.12.20.18.21;	author obaldin;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.12.18.03.59;	author lord_kiron;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.09.18.39.40;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.06.21.15.44;	author lord_kiron;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.06.21.13.55;	author lord_kiron;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.25.16.10.38;	author maverick65;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2003.01.25.15.03.03;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.24.22.07.46;	author maverick65;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.24.14.04.26;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.14.14.22;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.07.05;	author cax2;	state Exp;
branches;
next	;

1.7.2.1
date	2003.01.28.16.53.59;	author cax2;	state Exp;
branches;
next	;

1.7.4.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.02.08.18.03.55;	author obaldin;	state Exp;
branches;
next	;

1.17.8.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.17.8.2;

1.17.8.2
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.94
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "updownclient.h"
#include "ClientList.h"
#include "emule.h"
#include "UploadQueue.h"
#include "otherfunctions.h"
#include "ListenSocket.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CClientList::CClientList() : m_clientList(100)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CClientList::~CClientList()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::GetStatistics(uint32 &totalclient, uint32 stats[], ClientsData *pData, uint32 &totalMODs, uint32 *pdwTotalPlusMODs, CMap<POSITION, POSITION, uint32, uint32> *MODs, CMap<POSITION, POSITION, uint32, uint32> *PlusMODs, CMap<int, int, uint32, uint32> *pCountries)
{
	EMULE_TRY
	if (!pData)
		return;

	POSITION			pos_MOD;
	CUpDownClient		*pClient;
	CString				strMODName;
	uint32				dwCount;
	int					i, iCountryIdx;

	totalclient = m_clientList.GetCount();

	for (i = 0; i < SO_LAST; i++)
	{
		pData->m_pClients[i].RemoveAll();
		stats[i] = 0;
	}
	pData->m_pClients[i].RemoveAll(); // reset the last one

//	Reset MODs variables
	totalMODs = 0;
	*pdwTotalPlusMODs = 0;
	MODs->RemoveAll();
	PlusMODs->RemoveAll();

//	Reset Countries variables
	pCountries->RemoveAll();

//	Reset SUI, LowID and Problematic clients info
	stats[14] = 0;	//	SUI success
	stats[15] = 0;	//	SUI failed
	stats[16] = 0;	//	LowID
	stats[17] = 0;	//	Problematic clients (DS_ERROR)

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = m_clientList.GetNext(pos);

		int		iVersion = pClient->GetVersion();
		uint32	dwClientSoft = pClient->GetClientSoft();

		if (dwClientSoft >= SO_UNKNOWN)
			stats[SO_UNKNOWN]++;
		else
		{
			stats[dwClientSoft]++;
			(pData->m_pClients[dwClientSoft])[iVersion]++;
		}

		(pData->m_pClients[SO_LAST])[pClient->GetDownloadState()]++;

		if (pClient->Credits() != NULL)
		{
			switch(pClient->Credits()->GetCurrentIdentState(pClient->GetIP()))
			{
				case IS_IDENTIFIED:
					stats[14]++;
					break;
				case IS_IDFAILED:
				case IS_IDNEEDED:
				case IS_IDBADGUY:
					stats[15]++;
			}
		}

		if (pClient->HasLowID())
			stats[16]++;

		if (pClient->GetDownloadState() == DS_ERROR)
			stats[17]++;

	//	Count MODs
		if ((dwClientSoft == SO_EMULE) || (dwClientSoft == SO_OLDEMULE))
		{
			strMODName = pClient->GetModString();
			if (!strMODName.IsEmpty())
			{
				totalMODs++;
				pos_MOD = liMODsTypes.Find(strMODName);
				if (!pos_MOD)
				{
					pos_MOD = liMODsTypes.AddTail(strMODName);
					MODs->SetAt(pos_MOD, 1);
				}
				else
				{
					dwCount = 0;
					MODs->Lookup(pos_MOD, dwCount);
					MODs->SetAt(pos_MOD, ++dwCount);
				}
			}
		}
		else if (dwClientSoft == SO_PLUS)
		{
			strMODName = pClient->GetModString();
			if (!strMODName.IsEmpty())
			{
				++*pdwTotalPlusMODs;
				pos_MOD = liMODsTypes.Find(strMODName);
				if (!pos_MOD)
				{
					pos_MOD = liMODsTypes.AddTail(strMODName);
					PlusMODs->SetAt(pos_MOD, 1);
				}
				else
				{
					dwCount = 0;
					PlusMODs->Lookup(pos_MOD, dwCount);
					PlusMODs->SetAt(pos_MOD, ++dwCount);
				}
			}
		}

	//	Count Countries
		CMap<int, int, uint32, uint32>::CPair *pPair;

		iCountryIdx = pClient->GetCountryIndex();
		pPair = pCountries->PLookup(iCountryIdx);
		if (pPair != NULL)
			pPair->value++;
		else
			pCountries->SetAt(iCountryIdx, 1);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientList::AddClient(CUpDownClient* toadd, bool bSkipDupTest)
{
	EMULE_TRY

	if (toadd == NULL)
		return false;

	if ( !bSkipDupTest)
	{
		if (m_clientList.Find(toadd))
			return false;
	}
	if (m_pctlClientList != NULL && m_pctlClientList->m_hWnd != NULL)
		m_pctlClientList->AddClient(toadd);
	m_clientList.AddTail(toadd);

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::RemoveClient(CUpDownClient *pClient)
{
	EMULE_TRY

	POSITION		pos = m_clientList.Find(pClient);

	if (pos != NULL)
	{
		g_App.m_pUploadQueue->RemoveFromUploadQueue(pClient, ETS_DISCONNECT);
		g_App.m_pUploadQueue->RemoveFromWaitingQueue(pClient);
		g_App.m_pDownloadQueue->RemoveSource(pClient);
		m_pctlClientList->RemoveClient(pClient);
		pClient->LeaveSourceLists();
		m_clientList.RemoveAt(pos);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::DeleteAll()
{
	EMULE_TRY

	g_App.m_pUploadQueue->DeleteAll();
	g_App.m_pDownloadQueue->DeleteAll();

	POSITION			pos1, pos2;
	CUpDownClient	   *pClient;

	for (pos1 = m_clientList.GetHeadPosition(); (pos2 = pos1) != NULL; )
	{
		pClient = m_clientList.GetNext(pos1);
		m_clientList.RemoveAt(pos2);
		if (pClient != NULL)
			delete pClient;
	}
	liMODsTypes.RemoveAll();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef OLD_SOCKETS_ENABLED
bool CClientList::AttachToAlreadyKnown(CUpDownClient **ppClient, CClientReqSocket *pSocket)
{
	EMULE_TRY

	if (pSocket == NULL)
		return false;

	CUpDownClient	*pClient = (*ppClient);
	CUpDownClient	*pClientInList;
	CUpDownClient	*pFoundClient = NULL;
	uint32 		dwRes = 0;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL;)
	{
		pClientInList = m_clientList.GetNext(pos);
		if (pClientInList != NULL && pClient != pClientInList)
		{
			dwRes = pClient->Compare(pClientInList);

			if ((dwRes & (CLIENT_COMPARE_SAME_ID | CLIENT_COMPARE_SAME_IP)) != 0)
			{
				pFoundClient = pClientInList;
				break;
			}
			else if ((dwRes & CLIENT_COMPARE_SAME_HASH) != 0)
			{
				pFoundClient = pClientInList;
			}
		}
	}

	if (pFoundClient != NULL)
	{
	//	don't allow to reattach the socket 
		if (pFoundClient == pClient)
			return true;

		if (pFoundClient->m_pRequestSocket != NULL)
		{
		//	Check if in the list client is connected to us and new client has only same hash
			if (pFoundClient->m_pRequestSocket->IsConnected()
				&& (dwRes & (CLIENT_COMPARE_SAME_ID | CLIENT_COMPARE_SAME_IP)) == 0)
			{
				if (pFoundClient->m_pCredits != NULL &&
					pFoundClient->m_pCredits->GetCurrentIdentState(pFoundClient->GetIP()) == IS_IDENTIFIED)
				{
				//	If client in the list was properly identified then ban new client with same hash
					pClient->Ban(BAN_CLIENT_HASH_STEALER);
					if (!g_App.m_pPrefs->IsCMNotLog())
					{
						AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Ban new client instance %s (%s:%u) that used protected userhash (identified client %s, %s:%u)"),
							pClient->GetClientNameWithSoftware(), pClient->GetFullIP(), pClient->GetUserPort(),
							pFoundClient->GetClientNameWithSoftware(), pFoundClient->GetFullIP(), pFoundClient->GetUserPort() );
					}
				}

				return false;
			}
#if 0
		//	Check special case when both clients are trying to connect at same time
			else if (pFoundClient->m_pRequestSocket->IsConnecting()
				|| (pFoundClient->m_pRequestSocket->IsConnected()
					&& ((dwRes & (CLIENT_COMPARE_SAME_ID | CLIENT_COMPARE_SAME_IP)) != 0) ))
			{
				AddLogLine( LOG_FL_DBG | LOG_RGB_WARNING, _T("Connection collision: try to attach incoming client (%s, %s:%u) to the client with active socket (%s, %s:%u)"),
					pClient->GetClientNameWithSoftware(), pClient->GetFullIP(), pClient->GetUserPort(),
					pFoundClient->GetClientNameWithSoftware(), pFoundClient->GetFullIP(), pFoundClient->GetUserPort() );
			}
#endif

			pFoundClient->m_pRequestSocket->Safe_Delete();
		}
	//	Check if remote client tries to change a hash
		else if ( ((dwRes & (CLIENT_COMPARE_SAME_ID | CLIENT_COMPARE_SAME_IP)) != 0)
				&& ((dwRes & CLIENT_COMPARE_SAME_HASH) == 0)
				&& pFoundClient->HasValidHash())
		{
			pFoundClient->Ban(BAN_CLIENT_HASH_STEALER);
			if (!g_App.m_pPrefs->IsCMNotLog())
			{
				AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Ban client instance %s (%s:%u) with userhash %s that changes userhash to %s"),
					pFoundClient->GetClientNameWithSoftware(),
					pFoundClient->GetFullIP(), pFoundClient->GetUserPort(),
					HashToString(pFoundClient->GetUserHash()),
					HashToString(pClient->GetUserHash()) );
			}
		}

		pFoundClient->m_pRequestSocket = pSocket;
		pClient->m_pRequestSocket = NULL;

	// overwrite the pointer
		*ppClient = pFoundClient;
	// now we can delete the client
		delete pClient;
		return true;
	}

	EMULE_CATCH

	return false;
}
#endif //OLD_SOCKETS_ENABLED
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CClientList::FindClientByIP(uint32 clientip, uint16 port)
{
	EMULE_TRY

	CUpDownClient	   *pClient;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = m_clientList.GetNext(pos);
		if (pClient)
			if (pClient->GetIP() == clientip && pClient->GetUserPort() == port)
				return pClient;
	}

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CClientList::FindClientByUserHash(uchar* clienthash)
{
	EMULE_TRY

	CUpDownClient	   *pClient;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = m_clientList.GetNext(pos);
		if (pClient)
			if (!md4cmp(pClient->GetUserHash(), clienthash))
				return pClient;
	}

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CUpDownClient* CClientList::FindClient(uint32 dwUserIDHyb, uint16 uUserPort, uint32 dwSrvIP, uint16 uSrvPort, uchar *pbyteUserHash)
{
	EMULE_TRY

	CUpDownClient	*pClient;
	CUpDownClient	*pFoundClient = NULL;
	bool			bValidSrv = ((dwSrvIP != 0) && (uSrvPort != 0));

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL;)
	{
		pClient = m_clientList.GetNext(pos);
		if (pClient == NULL)
			continue;

		if (IsLowID(dwUserIDHyb))
		{
			if (bValidSrv && (dwSrvIP == pClient->GetServerIP())
				&& uSrvPort == pClient->GetServerPort())
			{
				if (pClient->HasLowID())
				{
				//	Compare the real LowID clients
					if (dwUserIDHyb == pClient->GetUserIDHybrid())
					{
						pFoundClient = pClient;
						break;
					}
				}
				else
				{
				//	Compare new LowID source from server with x.x.x.0 HighID client
				//	that was already added over SX
					if (dwUserIDHyb == fast_ntohl(pClient->GetUserIDHybrid()))
					{
						pFoundClient = pClient;
						break;
					}
				}
			}
		}
		else if ((dwUserIDHyb != 0) && (uUserPort == pClient->GetUserPort()))
		{
			if (dwUserIDHyb == pClient->GetUserIDHybrid())
			{
				pFoundClient = pClient;
				break;
			}

			if (pClient->HasLowID() && bValidSrv
				&& dwSrvIP == pClient->GetServerIP()
				&& uSrvPort == pClient->GetServerPort())
			{
				if (pClient->GetIP() == 0)
				{
				//	A x.x.x.0 HighID client has been already received from the server,
				//	added to the list as LowID and wasn't connected yet
					if (dwUserIDHyb == fast_ntohl(pClient->GetUserIDHybrid()))
					{
						pClient->SetUserIDHybrid(dwUserIDHyb);
						pFoundClient = pClient;
						break;
					}
				}
				else
				{
				//	When a user changed LowID to HighID on same server and we got
				//	him as a HighID source over SX or from server over UDP request
					if (dwUserIDHyb == fast_ntohl(pClient->GetIP()))
					{
						pClient->SetUserIDHybrid(dwUserIDHyb);
						pFoundClient = pClient;
						break;
					}
				}
			}
		}

		if (pbyteUserHash != NULL && (md4cmp(pbyteUserHash, pClient->GetUserHash()) == 0) && pClient->HasValidHash())
			pFoundClient = pClient;
	}

	return pFoundClient;

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef OLD_SOCKETS_ENABLED
void CClientList::Debug_SocketDeleted(CClientReqSocket *pSocket)
{
	EMULE_TRY

	CUpDownClient	   *pClient;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{

		pClient = m_clientList.GetNext(pos);

		if (!AfxIsValidAddress(pClient, sizeof(CUpDownClient)))
		{
			AfxDebugBreak();
		}
		if (pClient && pClient->m_pRequestSocket == pSocket)
		{
		//	AfxDebugBreak();
		}
	}

	EMULE_CATCH
}
#endif //OLD_SOCKETS_ENABLED
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CClientList::IsValidClient(CUpDownClient *pClient)
{
	EMULE_TRY

	if (pClient == NULL)
		return false;

	return (m_clientList.Find(pClient) != NULL);

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::GetClientListByFileID(CTypedPtrList<CPtrList, CUpDownClient*> *pClientList, const uchar *fileid)
{
	EMULE_TRY

	pClientList->RemoveAll();

	CUpDownClient	   *pClient;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = m_clientList.GetNext(pos);
		if (md4cmp(pClient->GetUploadFileID(), fileid) == 0)
			pClientList->AddTail(pClient);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CClientList::GetA4AFSourcesCount()
{
	EMULE_TRY

	CUpDownClient	   *pClient;
	uint32				dwCountA4AF = 0;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = m_clientList.GetNext(pos);
		if (!pClient->m_otherRequestsList.IsEmpty())
			dwCountA4AF++;
	}

	return dwCountA4AF;

	EMULE_CATCH
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::UpdateClient(CUpDownClient *pClient)
{
	if (pClient != NULL)
	{
		POSITION		posClient = m_clientList.Find(pClient);

	//	If the client is in the list...
		if (posClient != NULL)
		{
			g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
			g_App.m_pDownloadList->UpdateSource(pClient);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::ResetIP2Country()
{
	CUpDownClient *pClient;

	for(POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; m_clientList.GetNext(pos))
	{ 
		pClient = g_App.m_pClientList->m_clientList.GetAt(pos); 
		pClient->ResetIP2Country();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CClientList::UpdateBanCounters()
{
	EMULE_TRY

	uint32			dwUploadCount = 0, dwDownloadCount = 0;
	CUpDownClient	*pClient;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL;)
	{
		pClient = m_clientList.GetNext(pos);
		if ((pClient != NULL) && pClient->IsBanned())
		{
			if (pClient->GetUploadState() == US_ONUPLOADQUEUE)
				dwUploadCount++;
			if (pClient->GetDownloadState() != DS_NONE && pClient->GetDownloadState() != DS_ERROR)
				dwDownloadCount++;
		}
	}

	g_App.m_pUploadQueue->SetBanCount(dwUploadCount);
	g_App.m_pDownloadQueue->SetBanCount(dwDownloadCount);

	EMULE_CATCH
}
@


1.93
log
@Reduced H-file dependency.
@
text
@d24 1
@


1.92
log
@Fast byte swap for ntohl and ntohs.
@
text
@d22 1
@


1.91
log
@Simplified logging system implementation.
@
text
@d366 1
a366 1
			if (!md4cmp(pClient->GetUserHash() , clienthash))
d407 1
a407 1
					if (dwUserIDHyb == ntohl(pClient->GetUserIDHybrid()))
d431 1
a431 1
					if (dwUserIDHyb == ntohl(pClient->GetUserIDHybrid()))
d442 1
a442 1
					if (dwUserIDHyb == ntohl(pClient->GetIP()))
@


1.90
log
@Reduced H-file dependency.
@
text
@d283 1
a283 1
						AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Ban new client instance %s (%s:%u) that used protected userhash (identified client %s, %s:%u)"),
d297 1
a297 1
				AddDebugLogLine( RGB_LOG_WARNING_TXT _T("Connection collision: try to attach incoming client (%s, %s:%u) to the client with active socket (%s, %s:%u)"),
d313 1
a313 1
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Ban client instance %s (%s:%u) with userhash %s that changes userhash to %s"),
@


1.89
log
@Removed unused client upload states.
@
text
@d19 1
d224 1
a224 1
		if (pClient)
@


1.88
log
@Suppressed compiler warnings [Aw3].
@
text
@d72 1
a72 1
	stats[17] = 0;	//	Problematic clients (DS_ERROR || US_ERROR)
d108 1
a108 1
		if (pClient->GetDownloadState() == DS_ERROR || pClient->GetUploadState() == US_ERROR)
@


1.87
log
@Comment: Minor correction for debug compilation {DoubleT} [Aw3]
@
text
@d495 1
a495 1
	return m_clientList.Find(pClient);
@


1.86
log
@1) removed detection over the country
2) removed port statistic (part1)
@
text
@d242 1
a242 1
	uint32 		dwRes;
d244 1
a244 1
	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
d284 1
a284 1
							pFoundClient->GetClientNameWithSoftware(), pClientInList->GetFullIP(), pFoundClient->GetUserPort() );
@


1.85
log
@improved detection client over comparison of country index. note: the method was added with debug messages for reliability test in nightlies
@
text
@a21 1
#include "IP2Country.h"
d38 1
a38 1
void CClientList::GetStatistics(uint32 &totalclient, uint32 stats[], uint32 clientsPorts[], ClientsData *pData, uint32 &totalMODs, uint32 *pdwTotalPlusMODs, CMap<POSITION, POSITION, uint32, uint32> *MODs, CMap<POSITION, POSITION, uint32, uint32> *PlusMODs, CMap<int, int, uint32, uint32> *pCountries)
a58 4
//	Reset ports information
	clientsPorts[0] = 0;
	clientsPorts[1] = 0;

a110 6
	//	Default port or not
		if (pClient->GetUserPort() == 4662)
			++clientsPorts[0];
		else
			++clientsPorts[1];

a318 12
	//	the following method is based on assumption that client from with dynamic IP can change IP, but not a country
		else if ((dwRes & (CLIENT_COMPARE_SAME_ID | CLIENT_COMPARE_SAME_IP)) == 0
			&& (pFoundClient->GetCountryIndex() != NO_COUNTRY_INFO) && (pClient->GetCountryIndex() != NO_COUNTRY_INFO)
			&& (pFoundClient->GetCountryIndex() != pClient->GetCountryIndex()))
		{
#if 1
			AddDebugLogLine( RGB_VIOLET_TXT _T("Client with same hash but from other country ci=%s, %s:%u, %s,cl=%s, %s:%u, %s"),
				pClient->GetClientNameWithSoftware(), pClient->GetFullIP(), pClient->GetUserPort(), pClient->GetCountryName(),
				pFoundClient->GetClientNameWithSoftware(), pFoundClient->GetFullIP(), pFoundClient->GetUserPort(), pFoundClient->GetCountryName());
#endif
			return false;
		}
@


1.84
log
@temporary disable detection for connection collision
@
text
@d22 1
d309 1
a309 1
					pFoundClient->GetClientNameWithSoftware(), pClientInList->GetFullIP(), pFoundClient->GetUserPort() );
d330 12
@


1.83
log
@Formatting.
@
text
@d300 1
d310 1
@


1.82
log
@Some optimization and formatting.
@
text
@d281 2
a282 2
		//	Check if in the list client is connected to us and new client has only same hash 
			if (pFoundClient->m_pRequestSocket->IsConnected() 
d285 2
a286 2
				if (pFoundClient->m_pCredits != NULL 
					&& pFoundClient->m_pCredits->GetCurrentIdentState(pFoundClient->GetIP()) == IS_IDENTIFIED)
d293 2
a294 2
										pClient->GetClientNameWithSoftware(), pClient->GetFullIP(), pClient->GetUserPort(),
										pFoundClient->GetClientNameWithSoftware(), pClientInList->GetFullIP(), pFoundClient->GetUserPort());
d302 1
a302 1
				|| (pFoundClient->m_pRequestSocket->IsConnected() 
d306 2
a307 2
									pClient->GetClientNameWithSoftware(), pClient->GetFullIP(), pClient->GetUserPort(),
									pFoundClient->GetClientNameWithSoftware(), pClientInList->GetFullIP(), pFoundClient->GetUserPort());
d320 5
a324 5
				AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Ban client instance %s (%s:%u) with userhash '%s' that changes userhash to '%s'"),
								pFoundClient->GetClientNameWithSoftware(),
								pFoundClient->GetFullIP(), pFoundClient->GetUserPort(),
								HashToString(pFoundClient->GetUserHash()),
								HashToString(pClient->GetUserHash()));
@


1.81
log
@added new identification cases introduced by HybridID
@
text
@d386 3
a388 2
	CUpDownClient		*pClient;
	CUpDownClient		*pFoundClient = NULL;
d390 1
a390 1
	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
d393 4
a396 1
		if(pClient != NULL)
d398 2
a399 1
			if (IsLowID(dwUserIDHyb))
d401 1
a401 3
				if (dwSrvIP != 0 && uSrvPort != 0
					&& dwSrvIP == pClient->GetServerIP()
					&& uSrvPort == pClient->GetServerPort())
d403 2
a404 1
					if (pClient->HasLowID())
d406 9
a414 8
					//	Compare the real LowID clients
						if (dwUserIDHyb == pClient->GetUserIDHybrid())
						{
							pFoundClient = pClient;
							break;
						}
					} 
					else
d416 2
a417 7
					//	Compare new LowID source from server with x.x.x.0 HighID client
					//	that was already added over SX
						if (dwUserIDHyb == ntohl(pClient->GetUserIDHybrid()))
						{
							pFoundClient = pClient;
							break;
						}
d421 4
a424 1
			else
d426 9
a434 1
				if (dwUserIDHyb != 0 && uUserPort == pClient->GetUserPort())
d436 3
a438 1
					if (dwUserIDHyb == pClient->GetUserIDHybrid())
d440 1
d444 6
a449 5

					if (pClient->HasLowID()
						&& dwSrvIP != 0 && uSrvPort != 0
						&& dwSrvIP == pClient->GetServerIP()
						&& uSrvPort == pClient->GetServerPort())
d451 3
a453 22
						if (pClient->GetIP() == 0)
						{
						//	A x.x.x.0 HighID client was already received from the server ,
						//	added to list as LowID and was not connected  
							if (dwUserIDHyb == ntohl(pClient->GetUserIDHybrid()))
							{
								pClient->SetUserIDHybrid(dwUserIDHyb);
								pFoundClient = pClient;
								break;
							}
						}
						else
						{
						//	When user changed LowID to HighID on same server
						//	and we got him as a HighID source over SX or from server over UDP request
							if (dwUserIDHyb == ntohl(pClient->GetIP()))
							{
								pClient->SetUserIDHybrid(dwUserIDHyb);
								pFoundClient = pClient;
								break;
							}
						}
d457 1
d459 2
a460 3
			if (pbyteUserHash != NULL && pClient->HasValidHash() && md4cmp(pbyteUserHash, pClient->GetUserHash()) == 0)
				pFoundClient = pClient;
		}
@


1.80
log
@Newly added stuff was renamed according to the original for easier reference.
@
text
@d392 1
a392 1
		if(pClient)
d396 1
a396 2
				if ( dwUserIDHyb == pClient->GetUserIDHybrid()
					&& dwSrvIP != 0 
a397 1
					&& uSrvPort != 0
d400 19
a418 2
					pFoundClient = pClient;
					break;
d431 2
a432 4
				// check a special case when user changed LowID to HighID on same server
				// and we got him as a HighID source over SX or from server over UDP request
					if (dwUserIDHyb == ntohl(pClient->GetIP())
						&& dwSrvIP != 0 
a433 1
						&& uSrvPort != 0
d436 22
a457 3
						pClient->SetUserIDHybrid(dwUserIDHyb);
						pFoundClient = pClient;
						break;
@


1.79
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d382 1
a382 1
CUpDownClient* CClientList::FindClient(uint32 dwHybridUsedID, uint16 nUserPort, uint32 dwServerIP, uint16 nServerPort, uchar *pbyteUserHash)
d394 1
a394 1
			if (IsLowID(dwHybridUsedID))
d396 5
a400 5
				if ( dwHybridUsedID == pClient->GetHybridUserID()
					&& dwServerIP != 0 
					&& dwServerIP == pClient->GetServerIP()
					&& nServerPort != 0
					&& nServerPort == pClient->GetServerPort())
d408 1
a408 1
				if (dwHybridUsedID != 0 && nUserPort == pClient->GetUserPort())
d410 1
a410 1
					if (dwHybridUsedID == pClient->GetHybridUserID())
d418 5
a422 5
					if (dwHybridUsedID == ntohl(pClient->GetIP())
						&& dwServerIP != 0 
						&& dwServerIP == pClient->GetServerIP()
						&& nServerPort != 0
						&& nServerPort == pClient->GetServerPort())
d424 1
a424 1
						pClient->SetHybridUserID(dwHybridUsedID);
@


1.78
log
@improved detection of connection collision,
change the message status to warnig since result of such colision is undefined.
@
text
@d382 1
a382 1
CUpDownClient* CClientList::FindClient(uint32 dwUserID, uint16 nUserPort, uint32 dwServerIP, uint16 nServerPort, uchar *pbyteUserHash)
d394 1
a394 1
			if (dwUserID < 0x1000000)
d396 1
a396 1
				if ( dwUserID == pClient->GetUserID()
d408 1
a408 1
				if (dwUserID != 0 && nUserPort == pClient->GetUserPort())
d410 1
a410 1
					if (dwUserID == pClient->GetUserID())
d418 1
a418 1
					if (dwUserID == pClient->GetIP()
d424 1
a424 1
						pClient->SetUserID(dwUserID);
@


1.77
log
@removed "unfair *" statistic
@
text
@d301 3
a303 1
			else if (pFoundClient->m_pRequestSocket->IsConnecting())
d305 1
a305 1
				AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Connection collision: try to attach client %s, %s:%u, while connecting to client %s, %s:%u"),
@


1.76
log
@use HasValidHash() for faster valid hash detection
@
text
@a289 2
					InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
					InterlockedIncrement(&g_App.m_lTotalNumHashChangeActions);
d316 8
a323 9
			InterlockedIncrement(&g_App.m_lTotalNumUnfairActions);
			InterlockedIncrement(&g_App.m_lTotalNumHashChangeActions);
#if 1
			AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Ban client instance %s (%s:%u) with userhash '%s' that changes userhash to '%s'"),
							pFoundClient->GetClientNameWithSoftware(),
							pFoundClient->GetFullIP(), pFoundClient->GetUserPort(),
							HashToString(pFoundClient->GetUserHash()),
							HashToString(pClient->GetUserHash()) );
#endif
@


1.75
log
@corrected tex in debug lines (hash->userhash)
@
text
@d315 1
a315 1
				&& (md4cmp0(pFoundClient->GetUserHash()) != 0))
@


1.74
log
@improved the client identification in AttachToAlreadyKnown(). note: i left  the debug messages to get some addtional statistic about two identification cases.
@
text
@d294 1
a294 1
						AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Ban new client instance %s (%s:%u) that used protected hash (identified client %s, %s:%u)"),
d321 1
a321 1
			AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Ban client instance %s (%s:%u) with hash '%s' that changes hash to '%s'"),
@


1.73
log
@formating according to coding guidelines
@
text
@d246 3
d278 2
a279 2
	
		if (pSocket != NULL)
d281 3
a283 1
			if (pFoundClient->m_pRequestSocket != NULL)
d285 16
a300 1
				pFoundClient->m_pRequestSocket->Safe_Delete();
d302 9
a310 2
			pFoundClient->m_pRequestSocket = pSocket;
			pClient->m_pRequestSocket = NULL;
d312 20
@


1.72
log
@don't allow to reattach the socket
@
text
@d437 1
a437 1
void CClientList::GetClientListByFileID(CTypedPtrList<CPtrList, CUpDownClient*> *m_pClientList, const uchar *fileid)
d441 1
a441 1
	m_pClientList->RemoveAll();
d449 1
a449 1
			m_pClientList->AddTail(pClient);
@


1.71
log
@Compatibility with VC2005 [brengarne].
@
text
@d272 4
@


1.70
log
@Removed superseded service FindClientByPortAndID.
@
text
@d48 1
a48 1
	int					iCountryIdx;
d52 1
a52 1
	for (int i = 0; i < SO_LAST; i++)
@


1.69
log
@improved source search in list in case of clients with same hash
@
text
@a331 19
CUpDownClient* CClientList::FindClientByPortAndID(uint32 dwUserID,uint16 nPort)
{
	EMULE_TRY

	CUpDownClient	   *pClient;

	for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
	{
		pClient = m_clientList.GetNext(pos);
		if(pClient)
			if (pClient->GetUserID() == dwUserID && pClient->GetUserPort() == nPort)
				return pClient;
	}

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.68
log
@renamed 3 variables
@
text
@d355 2
a356 1
	CUpDownClient	   *pClient;
d370 4
a373 1
					return pClient;
d380 4
a383 1
						return pClient;
d394 2
a395 1
						return pClient;
d401 1
a401 1
				return pClient;
d405 2
@


1.67
log
@One more step to integrate eklmn's SSDQ.
@
text
@d208 3
a210 3
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(pClient, ETS_DISCONNECT);
		g_eMuleApp.m_pUploadQueue->RemoveFromWaitingQueue(pClient);
		g_eMuleApp.m_pDownloadQueue->RemoveSource(pClient);
d223 2
a224 2
	g_eMuleApp.m_pUploadQueue->DeleteAll();
	g_eMuleApp.m_pDownloadQueue->DeleteAll();
d489 2
a490 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(pClient);
			g_eMuleApp.m_pDownloadList->UpdateSource(pClient);
d501 1
a501 1
		pClient = g_eMuleApp.m_pClientList->m_clientList.GetAt(pos); 
d525 2
a526 2
	g_eMuleApp.m_pUploadQueue->SetBanCount(dwUploadCount);
	g_eMuleApp.m_pDownloadQueue->SetBanCount(dwDownloadCount);
@


1.66
log
@fixed incorrect identification in case of search by hash (stupid me)
@
text
@d506 24
@


1.65
log
@Formatting.
@
text
@d247 1
a247 1
	CUpDownClient	*pClient2;
d249 1
d253 2
a254 4
		pClient2 = m_clientList.GetNext(pos);

	//	I dont know how and why this can happen... but eMule crashed here all the time for me!
		if (pClient2 != NULL && pClient != pClient2)
d256 1
a256 1
			uint32 dwRes = pClient->Compare(pClient2);
d260 1
a260 1
				pFoundClient = pClient2;
d265 1
a265 1
				pFoundClient = pClient2;
d274 1
a274 1
			if (pClient2->m_pRequestSocket != NULL)
d276 1
a276 1
				pClient2->m_pRequestSocket->Safe_Delete();
d278 1
a278 1
			pClient2->m_pRequestSocket = pSocket;
d281 3
a283 1
		*ppClient = NULL;
a284 1
		*ppClient = pClient2;
@


1.64
log
@fixed indefication of the client IP identiifcatio has more higher priority as Userhash.
@
text
@d246 3
a248 3
	CUpDownClient	   *pClient = (*ppClient);
	CUpDownClient	   *pClient2;
	CUpDownClient	   *pFoundClient = NULL;
a251 1

d259 1
a259 1
			if ((dwRes & (CLIENT_COMPARE_SAME_ID |CLIENT_COMPARE_SAME_IP)) != 0)
d264 1
a264 1
			else if ((dwRes & CLIENT_COMPARE_SAME_HASH ) != 0)
@


1.63
log
@improved LowID check by SX (part 2)
@
text
@d248 1
d256 1
a256 1
		if (pClient2 != NULL && pClient != pClient2 && pClient->Compare(pClient2) != 0)
d258 19
a276 2
			ASSERT ( (pClient != pClient2) );
			if (pSocket != NULL)
d278 1
a278 6
				if (pClient2->m_pRequestSocket != NULL)
				{
					pClient2->m_pRequestSocket->Safe_Delete();
				}
				pClient2->m_pRequestSocket = pSocket;
				pClient->m_pRequestSocket = NULL;
d280 2
a281 4
			*ppClient = NULL;
			delete pClient;
			*ppClient = pClient2;
			return true;
d283 4
@


1.62
log
@Remove a client from the known client list earlier.
@
text
@d337 51
@


1.61
log
@new source exchange system
@
text
@a207 1
	//	Just to be sure...
d211 1
a213 1
		m_pctlClientList->RemoveClient(pClient);
@


1.60
log
@Added MODs client statistics for eMule Plus.
@
text
@d212 2
a214 1
		m_clientList.RemoveAt(pos);
@


1.59
log
@A little bit faster gathering of clients statistics.
@
text
@d18 1
a18 1
#include "StdAfx.h"
d38 1
a38 1
void CClientList::GetStatistics(uint32 &totalclient, uint32 stats[], uint32 clientsPorts[], ClientsData *pData, uint32 &totalMODs, CMap<POSITION, POSITION, uint32, uint32> *MODs, CMap<int, int, uint32, uint32> *pCountries)
d52 1
a52 1
	for (int i = 0;i < SO_LAST;i++)
d65 1
d67 1
a109 1
		{
a110 1
		}
d122 1
a122 1
		if ((pClient->GetClientSoft() == SO_EMULE) || (pClient->GetClientSoft() == SO_OLDEMULE))
d142 20
@


1.58
log
@Own client type for eMule Plus clients; Separate eMule Plus statistics.
@
text
@d81 1
d83 3
a85 1
		switch (pClient->GetClientSoft())
d87 2
a88 43
			case SO_UNKNOWN :
				stats[SO_UNKNOWN]++;
				break;
			case SO_EDONKEY :
				stats[SO_EDONKEY]++;
				(pData->m_pClients[SO_EDONKEY])[iVersion]++;
				break;
			case SO_EDONKEYHYBRID :
				stats[SO_EDONKEYHYBRID]++;
				(pData->m_pClients[SO_EDONKEYHYBRID])[iVersion]++;
				break;
			case SO_EMULE :
				stats[SO_EMULE]++;
				(pData->m_pClients[SO_EMULE])[iVersion]++;
				break;
			case SO_PLUS :
				stats[SO_PLUS]++;
				(pData->m_pClients[SO_PLUS])[iVersion]++;
				break;
			case SO_OLDEMULE:
				stats[SO_OLDEMULE]++;
				(pData->m_pClients[SO_OLDEMULE])[iVersion]++;
				break;
			case SO_AMULE:
				stats[SO_AMULE]++;
				(pData->m_pClients[SO_AMULE])[iVersion]++;
				break;
			case SO_SHAREAZA:
				stats[SO_SHAREAZA]++;
				(pData->m_pClients[SO_SHAREAZA])[iVersion]++;
				break;
			case SO_XMULE:
				stats[SO_XMULE]++;
				(pData->m_pClients[SO_XMULE])[iVersion]++;
				break;
			case SO_MLDONKEY:
				stats[SO_MLDONKEY]++;
				(pData->m_pClients[SO_MLDONKEY])[iVersion]++;
				break;
			case SO_LPHANT:
				stats[SO_LPHANT]++;
				(pData->m_pClients[SO_LPHANT])[iVersion]++;
				break;
d112 1
a112 1
		if (pClient->GetDownloadState() == DS_ERROR || pClient->GetUploadState() == US_ERROR )
d115 5
a119 10
		switch (pClient->GetUserPort())
		{
		//	Default Port
			case 4662:
				++clientsPorts[0];
				break;
		//	Other Port
 	 		default:
				++clientsPorts[1];
		}
@


1.57
log
@LMULE -> XMULE.
@
text
@a96 7
			//	Add eMule Plus to the base eMule version (temporary solution)
				if ((iVersion >= FORM_CLIENT_VER(1, 0, 0)) && (iVersion <= FORM_CLIENT_VER(2, 0, 15)))
				{
					uint32	dwMuleVer = pClient->GetMuleVersion();

					iVersion = FORM_CLIENT_VER(0, (dwMuleVer >> 4) * 10 + (dwMuleVer & 0xF), 0);
				}
d99 4
@


1.56
log
@Completely reworked remote clients version detection.
@
text
@d118 3
a120 3
			case SO_LMULE:
				stats[SO_LMULE]++;
				(pData->m_pClients[SO_LMULE])[iVersion]++;
@


1.55
log
@lphant client support.
@
text
@a80 1
		int		iMuleVersion = pClient->GetMuleVersion();
d97 8
a104 1
				(pData->m_pClients[SO_EMULE])[iMuleVersion]++;
d108 1
a108 1
				(pData->m_pClients[SO_OLDEMULE])[iMuleVersion]++;
d112 1
a112 1
				(pData->m_pClients[SO_AMULE])[iMuleVersion]++;
d116 1
a116 1
				(pData->m_pClients[SO_SHAREAZA])[iMuleVersion]++;
d120 1
a120 1
				(pData->m_pClients[SO_LMULE])[iMuleVersion]++;
d124 1
a124 1
				(pData->m_pClients[SO_MLDONKEY])[0]++;
d128 1
a128 1
				(pData->m_pClients[SO_LPHANT])[0]++;
d170 1
a170 1
			strMODName = pClient->GetModVersion();
@


1.54
log
@rollback of old waiting queue
@
text
@d120 4
@


1.53
log
@SSWQ
@
text
@d226 1
a226 1
		g_eMuleApp.m_pUploadQueue->RemoveClientFromWaitingQueue(pClient);
@


1.52
log
@Reduced memory used by country statistics.
@
text
@d226 1
a226 1
		g_eMuleApp.m_pUploadQueue->RemoveFromWaitingQueue(pClient);
@


1.51
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@d38 1
a38 1
void CClientList::GetStatistics(uint32 &totalclient, uint32 stats[], uint32 clientsPorts[], ClientsData *pData, uint32 &totalMODs, CMap<POSITION, POSITION, uint32, uint32> *MODs, CMap<POSITION, POSITION, uint32, uint32> *Countries)
d44 1
a44 1
	POSITION			pos_MOD, pos_Country;
d46 1
a46 1
	CString				strMODName, strCountryName;
d48 1
d68 1
a68 1
	Countries->RemoveAll();
d180 8
a187 16
		strCountryName = pClient->GetCountryName();
		if (!strCountryName.IsEmpty())
		{
			pos_Country = liCountryNames.Find(strCountryName);
			if (!pos_Country)
			{
				pos_Country = liCountryNames.AddTail(strCountryName);
				Countries->SetAt(pos_Country, 1);
			}
			else
			{
				dwCount = 0;
				Countries->Lookup(pos_Country, dwCount);
				Countries->SetAt(pos_Country, ++dwCount);
			}
		}
@


1.50
log
@A fix - add only eMule clients to the MODs client statistics section;
Improved string processing.
@
text
@a31 1
	m_pvecDirtyClients = new ClientVector();
a35 1
	delete m_pvecDirtyClients;
a399 21
void CClientList::ResetAllValueCaches()
{
	EMULE_TRY

	if (!m_clientList.IsEmpty())
	{

		CUpDownClient	   *pClient;

		for (POSITION pos = m_clientList.GetHeadPosition(); pos != NULL; )
		{
			pClient = m_clientList.GetNext(pos);
			ASSERT(pClient);
			if (pClient)
				pClient->ResetValueCache();
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d447 1
a447 5
			AddDirtyClient(pClient);

		//	Send a notification to the client list control
			m_pctlClientList->PostRefreshMessage();

a452 24
void CClientList::AddDirtyClient(CUpDownClient *pClient)
{
//	If 'pClient' is not already in the dirty client list...
	if (::find(m_pvecDirtyClients->begin(),m_pvecDirtyClients->end(),pClient) == m_pvecDirtyClients->end())
	{
		m_pvecDirtyClients->push_back(pClient);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetDirtyClients() detaches the current dirty client list and returns it to the caller (who's responsible
//	for destroying it). This allows the client list control to update without locking down the client list.
CClientList::ClientVector *CClientList::GetDirtyClients()
{
	ClientVector		*pvecDirtyClients = NULL;

	if (!m_pvecDirtyClients->empty())
	{
		pvecDirtyClients = m_pvecDirtyClients;
		m_pvecDirtyClients = new ClientVector();
	}

	return pvecDirtyClients;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.49
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d46 4
a49 5
	POSITION			pos_MOD;
	POSITION			pos_Country;
	CUpDownClient	   *pClient;
	CString MOD_name, Country_Name;
	uint32 MOD_count, Country_Count;
a136 1

d145 1
a145 1
				stats[17]++;
d159 1
a159 2
		MOD_name = pClient->GetModVersion();
		if (!MOD_name.IsEmpty())
d161 2
a162 3
			totalMODs++;
			pos_MOD = liMODsTypes.Find(CString(MOD_name));
			if (!pos_MOD)
d164 13
a176 9
				pos_MOD = liMODsTypes.AddTail(MOD_name);
				MODs->SetAt(pos_MOD, 1);
			}
			else
			{
				MOD_count = 0;
				MODs->Lookup(pos_MOD, MOD_count);
				MOD_count++;
				MODs->SetAt(pos_MOD, MOD_count);
a177 1
			MOD_name.Empty();
d181 2
a182 2
		Country_Name = pClient->GetCountryName();
		if (!Country_Name.IsEmpty())
d184 1
a184 1
			pos_Country = liCountryNames.Find(CString(Country_Name));
d187 1
a187 1
				pos_Country = liCountryNames.AddTail(Country_Name);
d192 3
a194 4
				Country_Count = 0;
				Countries->Lookup(pos_Country, Country_Count);
				Country_Count++;
				Countries->SetAt(pos_Country, Country_Count);
a195 1
			Country_Name.Empty();
@


1.48
log
@DebugLog formating and changes
@
text
@d43 2
a44 2
	if (!pData )
		return ;
d106 3
a108 3
			case SO_CDONKEY :
				stats[SO_CDONKEY]++;
				(pData->m_pClients[SO_CDONKEY])[iMuleVersion]++;
@


1.47
log
@added connected clients country statistics
@
text
@a39 1
//	xrmb : statsclientstatus
d61 1
a61 1
//	reset ports information
d65 1
a65 1
//	reset MODs variables
d69 1
a69 1
//	reset Countries variables
d151 1
d153 1
a153 1
				++clientsPorts[0]; // Default Port
d155 3
a157 2
			default:
				++clientsPorts[1]; // Other Port
a235 2
	//	g_eMuleApp.AddDebugLogLine(false, _T("%s: Removing client %s addr(0x%08X) from client list"),__FUNCTION__,pClient->GetUserName(),pClient);

a240 3

	//	g_eMuleApp.AddDebugLogLine(false, _T("%s: REALLY removing client %s addr(0x%08X) from client list"),__FUNCTION__,pClient->GetUserName(),pClient);

d262 1
a262 1
			delete pClient; // recursiv: this will call RemoveClient
d282 1
a282 1
	//	I dont know how and why this can happen... but emule crashed here all the time for me!
d409 1
a409 1
	if (!m_clientList.IsEmpty()) // Fix reCDVst
d474 1
a474 1
		//
d493 1
a493 1
//		for destroying it). This allows the client list control to update without locking down the client list.
a508 1

@


1.46
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d41 1
a41 1
void CClientList::GetStatistics(uint32 &totalclient, uint32 stats[], uint32 clientsPorts[], ClientsData *pData, uint32 &totalMODs, CMap<POSITION, POSITION, uint32, uint32> *MODs)
d48 1
d50 2
a51 3
//	CMap<POSITION,POSITION, uint32, uint32> MODs;
	CString MOD_name;
	uint32 MOD_count;
d70 3
d168 1
a168 1
				MODs->SetAt(pos_MOD, 1 );
d179 20
@


1.45
log
@Increase granularity for long lists (that reduces memory fragmentation and slightly reduces memory usage).
@
text
@d488 12
@


1.44
log
@list processing optimization
@
text
@d30 1
a30 1
CClientList::CClientList()
@


1.43
log
@minor correction...
@
text
@d47 2
a48 2
	POSITION pos1, pos2, pos_MOD;
	CUpDownClient* cur_client;
d76 1
a76 1
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d78 1
a78 3
		m_clientList.GetNext(pos1);
		cur_client = m_clientList.GetAt(pos2);
		int version	= 0;
d80 4
a83 1
		switch (cur_client->GetClientSoft())
d90 1
a90 1
				(pData->m_pClients[SO_EDONKEY])[cur_client->GetVersion()]++;
d94 1
a94 1
				(pData->m_pClients[SO_EDONKEYHYBRID])[cur_client->GetVersion()]++;
d98 1
a98 2
				version = cur_client->GetMuleVersion();
				(pData->m_pClients[SO_EMULE])[version]++;
d102 1
a102 2
				version = cur_client->GetMuleVersion();
				(pData->m_pClients[SO_OLDEMULE])[version]++;
d106 1
a106 2
				version = cur_client->GetMuleVersion();
				(pData->m_pClients[SO_CDONKEY])[version]++;
d110 1
a110 2
				version = cur_client->GetMuleVersion();
				(pData->m_pClients[SO_SHAREAZA])[version]++;
d114 1
a114 2
				version = cur_client->GetMuleVersion();
				(pData->m_pClients[SO_LMULE])[version]++;
a115 1

d118 1
a118 1
				(pData->m_pClients[SO_MLDONKEY])[version]++;
d122 1
a122 1
		(pData->m_pClients[SO_LAST])[cur_client->GetDownloadState()]++;
d124 1
a124 1
		if (cur_client->Credits() != NULL)
d126 1
a126 1
			switch(cur_client->Credits()->GetCurrentIdentState(cur_client->GetIP()))
d139 2
a140 2
		if (cur_client->HasLowID()) 
		{	
d144 1
a144 1
		if (cur_client->GetDownloadState()==DS_ERROR || cur_client->GetUploadState()==US_ERROR )
d147 1
a147 1
		switch (cur_client->GetUserPort())
d157 1
a157 1
		MOD_name = cur_client->GetModVersion();
d200 1
a200 1
		
d234 5
a238 2
	POSITION pos1, pos2;
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d240 1
a240 2
		m_clientList.GetNext(pos1);
		CUpDownClient* cur_client = m_clientList.GetAt(pos2);
d242 2
a243 2
		if (cur_client)
			delete cur_client; // recursiv: this will call RemoveClient
a254 1
	POSITION			pos1, pos2;
d256 1
d258 1
a258 1
	for (pos1 = m_clientList.GetHeadPosition(); (pos2 = pos1) != NULL;)
a259 1
		m_clientList.GetNext(pos1);
d261 1
a261 1
		CUpDownClient		*pClient2 = m_clientList.GetAt(pos2);
d293 3
a295 2
	POSITION pos1, pos2;
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d297 4
a300 5
		m_clientList.GetNext(pos1);
		CUpDownClient* cur_client = m_clientList.GetAt(pos2);
		if (cur_client)
			if (cur_client->GetIP() == clientip && cur_client->GetUserPort() == port)
				return cur_client;
d312 3
a314 2
	POSITION pos1, pos2;
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d316 4
a319 5
		m_clientList.GetNext(pos1);
		CUpDownClient* cur_client = m_clientList.GetAt(pos2);
		if (cur_client)
			if (!md4cmp(cur_client->GetUserHash() , clienthash))
				return cur_client;
d331 3
a333 3
	POSITION pos1, pos2;
	CUpDownClient* pClient;
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d335 1
a335 2
		m_clientList.GetNext(pos1);
		pClient = m_clientList.GetAt(pos2);
d340 1
a340 1
	
d351 1
a351 1
	POSITION		pos1, pos2;
d353 1
a353 1
	for (pos1 = m_clientList.GetHeadPosition(); (pos2 = pos1) != NULL;)
a354 1
		m_clientList.GetNext(pos1);
d356 1
a356 1
		CUpDownClient		*pClient = m_clientList.GetAt(pos2);
d370 1
a370 1
#endif //OLD_SOCKETS_ENABLED 
d391 5
a395 1
		for (POSITION pos = m_clientList.GetHeadPosition(); pos != 0; m_clientList.GetNext(pos))
d397 4
a400 4
			CUpDownClient * cur_client = m_clientList.GetAt(pos);
			ASSERT(cur_client);
			if (cur_client)
				cur_client->ResetValueCache();
d402 1
d412 4
a415 1
	for (POSITION pos = m_clientList.GetHeadPosition(); pos != 0; )
d417 3
a419 3
		CUpDownClient *cur_src = m_clientList.GetNext(pos);
		if (md4cmp(cur_src->GetUploadFileID(), fileid) == 0)
			m_pClientList->AddTail(cur_src);
d429 2
a430 3
	CUpDownClient * cur_client;
	POSITION pos1, pos2;
	uint32 countA4AF = 0;
d432 1
a432 1
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d434 3
a436 4
		m_clientList.GetNext(pos1);
		cur_client = m_clientList.GetAt(pos2);
		if (!cur_client->m_otherRequestsList.IsEmpty())
			countA4AF++;
d439 1
a439 1
	return countA4AF;
@


1.42
log
@added SUI and LowID stats + more accurate clients stats ouput
@
text
@d142 5
a146 4
			if (cur_client->HasLowID()) 
			{	
				stats[16]++;
			}
@


1.41
log
@avoid some not necessary disc writes
@
text
@d66 1
a66 1
//reset MODs variables
d70 6
d129 22
@


1.40
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d99 1
a99 1
			case SO_CDONKEY :  //Didn't get much time to test this "eMule Compatable" feature, so for this version they will just be added to our total.
d132 1
a132 1
	//	eklmn: count a MODs
a362 1
//	[i_a]
a378 1
//netwolf: complete sources (zegzav) 13.05.03 - BEGIN
a392 1
//netwolf: complete sources (zegzav) 13.05.03 - END
a393 1
//eklmn: count A4AF sources
@


1.39
log
@Formatting, comments, and name changes.
@
text
@d188 1
a188 1
	//	g_eMuleApp.AddDebugLogLine(false,_T("%s: Removing client %s addr(0x%08X) from client list"),__FUNCTION__,pClient->GetUserName(),pClient);
d196 1
a196 1
	//	g_eMuleApp.AddDebugLogLine(false,_T("%s: REALLY removing client %s addr(0x%08X) from client list"),__FUNCTION__,pClient->GetUserName(),pClient);
@


1.38
log
@stability improvements, i.e. delete a client (sorce) if addition to the client list was failed.
@
text
@d180 1
a180 1
void CClientList::RemoveClient(CUpDownClient* toremove)
d184 3
a186 2
	POSITION pos = m_clientList.Find(toremove);
	if (pos)
d188 10
a197 7
	//g_eMuleApp.AddDebugLogLine(false,_T("%s: Removing client %s addr(0x%08X) from client list"),__FUNCTION__,toremove->GetUserName(),toremove);
	//just to be sure...
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(toremove, ETS_DISCONNECT);
		g_eMuleApp.m_pUploadQueue->RemoveFromWaitingQueue(toremove);
		g_eMuleApp.m_pDownloadQueue->RemoveSource(toremove);
		m_pctlClientList->RemoveClient(toremove);
	//g_eMuleApp.AddDebugLogLine(false,_T("%s: REALLY removing client %s addr(0x%08X) from client list"),__FUNCTION__,toremove->GetUserName(),toremove);
d203 1
a203 1

@


1.37
log
@new way of adding sources
@
text
@d157 1
a157 1
void CClientList::AddClient(CUpDownClient* toadd, bool bSkipDupTest)
d162 1
a162 1
		return ;
d167 1
a167 1
			return ;
d173 2
d176 2
d276 1
a276 1
	return 0;
@


1.36
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d156 1
a156 2


d175 1
a175 1

d274 1
a274 1

d294 20
a354 1

d371 1
a371 1

a383 1
//netwolf: complete sources (zegzav) 13.05.03 - END
d387 2
a388 1

@


1.35
log
@no message
@
text
@d216 1
a216 1

d218 1
a218 1
bool CClientList::AttachToAlreadyKnown(CUpDownClient** client, CClientReqSocket* sender)
d222 4
a225 3
	POSITION pos1, pos2;
	CUpDownClient* tocheck = (*client);
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d228 5
a232 4
		CUpDownClient* cur_client = m_clientList.GetAt(pos2);
	//	xrmb : crashfix
	//	i dont know how and why this can happen... but emule crashed here all the time for me!
		if (cur_client && tocheck != cur_client && tocheck->Compare(cur_client))
d234 2
a235 2
			ASSERT ( (tocheck != cur_client) );
			if (sender)
d237 1
a237 1
				if (cur_client->m_pRequestSocket != NULL)
d239 1
a239 2
					cur_client->m_pRequestSocket->m_pClient = NULL;
					cur_client->m_pRequestSocket->Safe_Delete();
d241 2
a242 2
				cur_client->m_pRequestSocket = sender;
				tocheck->m_pRequestSocket = NULL;
d244 3
a246 3
			*client = 0;
			delete tocheck;
			*client = cur_client;
d256 1
a256 1

d294 1
a294 1

d296 1
a296 1
void CClientList::Debug_SocketDeleted(CClientReqSocket* deleted)
d299 4
a302 2
	POSITION pos1, pos2;
	for (pos1 = m_clientList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d305 4
a308 2
		CUpDownClient* cur_client = m_clientList.GetAt(pos2);
		if (!AfxIsValidAddress(cur_client, sizeof(CUpDownClient)))
d312 1
a312 1
		if (cur_client && cur_client->m_pRequestSocket == deleted)
d384 1
a384 1
		if (!cur_client->m_OtherRequests_list.IsEmpty())
@


1.34
log
@no message
@
text
@d235 1
a235 1
				if (cur_client->m_pRequestSocket)
d237 1
a237 1
					cur_client->m_pRequestSocket->m_pClient = 0;
d241 1
a241 1
				tocheck->m_pRequestSocket = 0;
@


1.33
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d235 1
a235 1
				if (cur_client->socket)
d237 2
a238 2
					cur_client->socket->m_pClient = 0;
					cur_client->socket->Safe_Delete();
d240 2
a241 2
				cur_client->socket = sender;
				tocheck->socket = 0;
d307 1
a307 1
		if (cur_client && cur_client->socket == deleted)
@


1.32
log
@Fixed a crash-on-exit bug where AddClient() refreshes client after window is destroyed.
@
text
@d25 1
a25 1
static char THIS_FILE[]=__FILE__;
d32 1
d37 1
d40 2
a41 2
// xrmb : statsclientstatus
void CClientList::GetStatistics(uint32 &totalclient, uint32 stats[], uint32 clientsPorts[], ClientsData *pData, uint32 &totalMODs, CMap<POSITION,POSITION,uint32, uint32> *MODs)
d44 2
a45 1
	if (!pData ) return;
d49 1
a49 1
	//CMap<POSITION,POSITION, uint32, uint32> MODs;
d53 1
a53 1
	totalclient = list.GetCount();
d55 1
a55 1
	for (int i=0;i<SO_LAST;i++)
d58 1
a58 1
		stats[i]=0;
d61 2
a62 2
	
	// reset ports information
d65 2
a66 2
	
	//reset MODs variables
d70 1
a70 1
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d72 5
a76 5
		list.GetNext(pos1);
		cur_client = list.GetAt(pos2);
		int version	=	0;
		
		switch (cur_client->GetClientSoft()) 
d78 1
a78 1
			case SO_UNKNOWN : 
d81 1
a81 1
			case SO_EDONKEY : 
d85 1
a85 1
			case SO_EDONKEYHYBRID : 
d89 1
a89 1
			case SO_EMULE   :
d99 1
a99 1
			case SO_CDONKEY : //Didn't get much time to test this "eMule Compatable" feature, so for this version they will just be added to our total.
d122 2
a123 2
		
		switch (cur_client->GetUserPort()) 
d131 2
a132 2
		
		//eklmn: count a MODs
d138 1
a138 1
			if (!pos_MOD) 
d146 1
a146 1
				MODs->Lookup(pos_MOD,MOD_count);
d148 1
a148 1
				MODs->SetAt(pos_MOD,MOD_count);
a151 1
		
d158 1
a158 1
void CClientList::AddClient(CUpDownClient* toadd,bool bSkipDupTest)
d162 2
a163 2
	if(toadd == NULL)
		return;
d165 4
a168 3
	if ( !bSkipDupTest){
		if(list.Find(toadd))
			return;
d170 3
a172 3
	if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.m_hWnd != NULL)
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.AddClient(toadd);
	list.AddTail(toadd);
d181 6
a186 5
	POSITION pos = list.Find(toremove);
	if (pos){
//g_eMuleApp.AddDebugLogLine(false,_T("%s: Removing client %s addr(0x%08X) from client list"),__FUNCTION__,toremove->GetUserName(),toremove);
		//just to be sure...
		g_eMuleApp.m_pUploadQueue->RemoveFromUploadQueue(toremove,ETS_DISCONNECT);
d189 3
a191 3
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RemoveClient(toremove);
//g_eMuleApp.AddDebugLogLine(false,_T("%s: REALLY removing client %s addr(0x%08X) from client list"),__FUNCTION__,toremove->GetUserName(),toremove);
		list.RemoveAt(pos);
d204 6
a209 5
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		list.GetNext(pos1);
		CUpDownClient* cur_client =	list.GetAt(pos2);
		list.RemoveAt(pos2);
		if(cur_client)
d224 13
a236 10
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		list.GetNext(pos1);
		CUpDownClient* cur_client =	list.GetAt(pos2);
		// xrmb : crashfix
      	// i dont know how and why this can happen... but emule crashed here all the time for me! 
      	if (cur_client && tocheck!=cur_client && tocheck->Compare(cur_client))
		{ 
 			ASSERT ( (tocheck != cur_client) );
			if (sender){
				if (cur_client->socket){
d256 1
a256 1
CUpDownClient* CClientList::FindClientByIP(uint32 clientip,uint16 port)
d261 5
a265 4
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		list.GetNext(pos1);
		CUpDownClient* cur_client =	list.GetAt(pos2);
		if(cur_client)
d269 1
a269 1
	
d280 6
a285 5
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		list.GetNext(pos1);
		CUpDownClient* cur_client =	list.GetAt(pos2);
		if(cur_client)
			if (!md4cmp(cur_client->GetUserHash() ,clienthash))
d299 1
a299 1
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d301 2
a302 2
		list.GetNext(pos1);
		CUpDownClient* cur_client =	list.GetAt(pos2);
d309 1
a309 1
//			AfxDebugBreak();
d315 1
a315 1
#endif //OLD_SOCKETS_ENABLED
d324 1
a324 1
	return list.Find(pClient);
d332 2
a333 2
// [i_a] 
void CClientList::ResetAllValueCaches() 
d337 7
a343 7
	if(!list.IsEmpty()) // Fix reCDVst
		for (POSITION pos = list.GetHeadPosition(); pos != 0; list.GetNext(pos)) 
		{ 
			CUpDownClient* cur_client = list.GetAt(pos); 
			ASSERT(cur_client); 
			if(cur_client)
				cur_client->ResetValueCache(); 
d347 1
a347 1
} 
d355 1
a355 1
	for (POSITION pos = list.GetHeadPosition(); pos != 0; ) 
d357 1
a357 1
		CUpDownClient *cur_src= list.GetNext(pos);
d371 1
a371 1
	CUpDownClient* cur_client;
d374 2
a375 2
	
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;)
d377 4
a380 3
		list.GetNext(pos1);
		cur_client = list.GetAt(pos2);
		if (!cur_client->m_OtherRequests_list.IsEmpty()) countA4AF++;
d388 44
@


1.31
log
@Formatting, comments, and name changes.
@
text
@d167 2
a168 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.AddClient(toadd);
d180 1
d186 1
@


1.30
log
@initialization of some variables were skipped
@
text
@d60 2
a61 1
	clientsPorts[0] = 0;	clientsPorts[1] = 0;
d226 1
a226 1
					cur_client->socket->client = 0;
d303 2
a304 2

bool CClientList::Debug_IsValidClient(CUpDownClient* tocheck)
d308 1
a308 1
	if(tocheck == NULL)
d311 1
a311 1
	return list.Find(tocheck);
d317 1
@


1.29
log
@Commented out frequently hit debug break. Please either add code to handle this error condition or fix the bug that causes it.
@
text
@d58 4
d128 1
a128 1
		//eklmn: caculate a MODs
a137 1
				//AddDebugLogLine(false, "_MOD's: %s", MOD_name);
@


1.28
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d292 1
a292 1
			AfxDebugBreak();
@


1.27
log
@Formatting, comments, and name changes.
@
text
@d163 1
d179 1
@


1.26
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d29 3
a31 2

CClientList::CClientList(){
d33 3
a35 2

CClientList::~CClientList(){
d37 1
a37 1

@


1.25
log
@extended UL session statistic
@
text
@d19 1
a19 1
#include "clientlist.h"
d173 3
a175 3
		theApp.uploadqueue->RemoveFromUploadQueue(toremove,ETS_DISCONNECT);
		theApp.uploadqueue->RemoveFromWaitingQueue(toremove);
		theApp.downloadqueue->RemoveSource(toremove);
d186 2
a187 2
	theApp.uploadqueue->DeleteAll();
	theApp.downloadqueue->DeleteAll();
d328 1
a328 1
void CClientList::GetClientListByFileID(CTypedPtrList<CPtrList, CUpDownClient*> *clientlist, const uchar *fileid)
d332 1
a332 1
	clientlist->RemoveAll();
d337 1
a337 1
			clientlist->AddTail(cur_src);
@


1.24
log
@new statistic (khaos based)
@
text
@d173 1
a173 1
		theApp.uploadqueue->RemoveFromUploadQueue(toremove);
@


1.23
log
@Preparing for new sockets
@
text
@d37 1
a37 1
void CClientList::GetStatistics(uint32 &totalclient, int stats[], ClientsData *pData )
d40 1
a40 5
	if ( !pData ) 
	{
		return;
	}
	totalclient = list.GetCount();
d42 5
d48 1
a48 1
	POSITION pos1, pos2;
d56 3
d60 2
a61 1
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
d63 1
a63 1
		CUpDownClient* cur_client =	list.GetAt(pos2);
d66 2
a67 1
		switch (cur_client->GetClientSoft()) {
d112 32
d196 1
d342 22
@


1.22
log
@code cleanup
@
text
@d162 1
d196 1
d234 1
d255 1
@


1.21
log
@minor fixes and improvements
@
text
@d285 1
a285 1
void CClientList::GetClientListByFileID(CTypedPtrList<CPtrList, CUpDownClient*> *clientlist, uchar *fileid)
@


1.20
log
@complete sources column
@
text
@d211 1
a211 1
	return NULL;
d223 1
a223 1
			if (memcmp(cur_client->GetUserHash() ,clienthash,16))
d229 1
a229 1
	return NULL;
@


1.19
log
@Added lmule detection, better mldonkey detection and fixed bug 208
@
text
@d283 17
@


1.18
log
@shareaza identification.
@
text
@d88 1
a88 1
			case SO_SHAREAZA:  //MTSHAZ
d93 6
@


1.17
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d88 5
@


1.17.8.1
log
@27a partial merge
@
text
@d83 1
a83 1
			case SO_CDONKEY : //Didn't get much time to test this "eMule Compatible" feature, so for this version they will just be added to our total.
a90 5
				break;
			case SO_LMULE:
				stats[SO_LMULE]++;
				version = cur_client->GetMuleVersion();
				(pData->m_pClients[SO_LMULE])[version]++;
@


1.17.8.2
log
@27c
@
text
@d83 1
a83 1
			case SO_CDONKEY :
@


1.16
log
@Final client statistics changes
@
text
@d23 7
@


1.15
log
@*** empty log message ***
@
text
@a38 7
	pData->clientStatus.RemoveAll();
	pData->clientVersionEMule.RemoveAll();
	pData->clientVersionCDonkey.RemoveAll();
	pData->clientVersionEDonkeyHybrid.RemoveAll();
	pData->clientVersionEDonkey.RemoveAll();
	pData->clientVersionMLDonkey.RemoveAll();
	pData->clientVersionOldEMule.RemoveAll();
d42 6
a47 1
	for (int i=0;i<SO_LAST;i++) stats[i]=0;
d60 1
a60 1
				(pData->clientVersionEDonkey)[cur_client->GetVersion()]++;
d64 1
a64 1
				(pData->clientVersionEDonkeyHybrid)[cur_client->GetVersion()]++;
d69 1
a69 3
				if(version == 0x2B)
					version = 0x22;
				(pData->clientVersionEMule)[version]++;
d74 2
a75 3
				if(version == 0x2B)
					version = 0x22;
				(pData->clientVersionOldEMule)[version]++;
d79 1
a79 1
				(pData->clientVersionEMule)[version]++;
d83 1
a83 1
				(pData->clientVersionMLDonkey)[version]++;
d87 1
a87 1
		(pData->clientStatus)[cur_client->GetDownloadState()]++;
@


1.14
log
@*** empty log message ***
@
text
@d82 1
a82 1
				stats[2]++;
@


1.13
log
@*** empty log message ***
@
text
@a75 1
<<<<<<< ClientList.cpp
a80 1
=======
d83 2
a84 3
					version = cur_client->GetMuleVersion();
					(pData->clientVersionEMule)[version]++;
>>>>>>> 1.12
@


1.12
log
@more 26b merges
@
text
@d37 2
d40 3
a42 1
	totalclient = list.GetCount();
d44 3
a46 2
	pData->clientVersionEDonkeyHybrid.RemoveAll();
	pData->clientVersionEMule.RemoveAll();
d49 1
a49 1
	for (int i=0;i<6;i++) stats[i]=0;
d57 3
a59 1
			case SO_UNKNOWN : stats[0]++;break;
d61 2
a62 2
				stats[1]++;
					(pData->clientVersionEDonkey)[cur_client->GetVersion()]++;
d65 2
a66 2
				stats[4]++;
					(pData->clientVersionEDonkeyHybrid)[cur_client->GetVersion()]++;
d69 6
d76 7
d87 1
d90 2
a91 1
				stats[3]++;
@


1.11
log
@Less parameters for GetStatistics()  function , first step before redesign
@
text
@d63 1
a65 2
					if(version == 0x2B)
						version = 0x22;
@


1.10
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d30 1
a30 1
void CClientList::GetStatistics(uint32 &totalclient, int stats[], CMap<uint8, uint8, uint32, uint32> *clientStatus, CMap<uint32, uint32, uint32, uint32> *clientVersionEDonkey, CMap<uint32, uint32, uint32, uint32> *clientVersionEDonkeyHybrid, CMap<uint8, uint8, uint32, uint32> *clientVersionEMule)
d33 5
a37 2

	if(clientStatus)		clientStatus->RemoveAll();
d39 3
a41 3
	if(clientVersionEDonkey)	clientVersionEDonkey->RemoveAll();
	if(clientVersionEDonkeyHybrid)		clientVersionEDonkeyHybrid->RemoveAll();
	if(clientVersionEMule)		clientVersionEMule->RemoveAll();
d49 1
d55 1
a55 2
				if(clientVersionEDonkey)
					(*clientVersionEDonkey)[cur_client->GetVersion()]++;
d59 1
a59 2
				if(clientVersionEDonkeyHybrid)
					(*clientVersionEDonkeyHybrid)[cur_client->GetVersion()]++;
d64 1
a64 2
				if(clientVersionEMule) {
					int version = cur_client->GetMuleVersion();
d67 1
a67 2
					(*clientVersionEMule)[version]++;
				}
d74 1
a74 2
		if(clientStatus)
			(*clientStatus)[cur_client->GetDownloadState()]++;
@


1.9
log
@*** empty log message ***
@
text
@d37 1
a38 1
	if(clientVersionEDonkeyHybrid)		clientVersionEDonkeyHybrid->RemoveAll();
@


1.8
log
@Hybrid client and CDonkey detection
@
text
@d38 1
@


1.7
log
@Low ID Bugfix
@
text
@d30 1
a30 1
void CClientList::GetStatistics(uint32 &totalclient, int stats[], CMap<uint8, uint8, uint32, uint32> *clientStatus, CMap<uint8, uint8, uint32, uint32> *clientVersionEDonkey, CMap<uint8, uint8, uint32, uint32> *clientVersionEMule)
d52 5
@


1.7.4.1
log
@initial upgrade to .26
@
text
@d30 2
a31 1
void CClientList::GetStatistics(uint32 &totalclient, int stats[], CMap<uint8, uint8, uint32, uint32> *clientStatus, CMap<uint32, uint32, uint32, uint32> *clientVersionEDonkey, CMap<uint32, uint32, uint32, uint32> *clientVersionEDonkeyHybrid, CMap<uint8, uint8, uint32, uint32> *clientVersionEMule){
a51 5
				break;
			case SO_EDONKEYHYBRID : 
				stats[4]++;
				if(clientVersionEDonkeyHybrid)
					(*clientVersionEDonkeyHybrid)[cur_client->GetVersion()]++;
@


1.7.4.2
log
@fixed versions in statistics
@
text
@a35 1
	if(clientVersionEDonkeyHybrid)	clientVersionEDonkeyHybrid->RemoveAll();
@


1.7.2.1
log
@updating this branch...
@
text
@@


1.6
log
@warning fixed
@
text
@d200 2
a201 1
	for (pos1 = list.GetHeadPosition();( pos2 = pos1 ) != NULL;){
d205 1
d207 3
a209 1
		if(cur_client && cur_client->socket == deleted)
d211 1
@


1.5
log
@updated to .25b codebase
@
text
@d205 1
a205 2
		if(cur_client)
			if (cur_client->socket == deleted)
@


1.4
log
@*** empty log message ***
@
text
@d65 1
a65 1
				 break;
a198 1

@


1.3
log
@port to .25 b codebase...
@
text
@d30 4
a33 1
void CClientList::GetStatistics(uint32 &totalclient, int stats[], CMap<uint8, uint8, uint32, uint32> *clientStatus, CMap<uint8, uint8, uint32, uint32> *clientVersionEDonkey, CMap<uint8, uint8, uint32, uint32> *clientVersionEMule){
d71 2
d76 7
a82 1
void CClientList::AddClient(CUpDownClient* toadd,bool bSkipDupTest){
d88 2
d92 4
a95 1
void CClientList::RemoveClient(CUpDownClient* toremove){
d104 2
d108 4
a111 1
void CClientList::DeleteAll(){
d119 2
a120 1
		delete cur_client; // recursiv: this will call RemoveClient
d122 2
d126 4
a129 1
bool CClientList::AttachToAlreadyKnown(CUpDownClient** client, CClientReqSocket* sender){
d136 3
a138 3
      		// i dont know how and why this can happen... but emule crashed here all the time for me! 
      		if (tocheck!=cur_client && tocheck->Compare(cur_client)){ 
		// if (tocheck->Compare(cur_client)){
d154 3
d160 4
a163 1
CUpDownClient* CClientList::FindClientByIP(uint32 clientip,uint16 port){
d168 3
a170 2
		if (cur_client->GetIP() == clientip && cur_client->GetUserPort() == port)
			return cur_client;
d172 4
a175 1
	return 0;
d178 4
a181 1
CUpDownClient* CClientList::FindClientByUserHash(uchar* clienthash){
d186 2
a187 1
		if (memcmp(cur_client->GetUserHash() ,clienthash,16)  )
d190 4
a193 1
	return 0;
d196 4
a199 1
void CClientList::Debug_SocketDeleted(CClientReqSocket* deleted){
d204 1
a204 1
		if (!AfxIsValidAddress(cur_client, sizeof(CUpDownClient))) {
d206 2
a207 2
		}
		if (cur_client->socket == deleted){
a208 1
		}
d210 2
d214 7
a220 1
bool CClientList::Debug_IsValidClient(CUpDownClient* tocheck){
d222 4
d231 2
d238 2
a239 1
			cur_client->ResetValueCache(); 
d241 2
@


1.2
log
@*** empty log message ***
@
text
@d30 1
a30 1
void CClientList::GetStatistics(int stats[], CMap<uint8, uint8, uint32, uint32> *clientStatus, CMap<uint8, uint8, uint32, uint32> *clientVersionEDonkey, CMap<uint8, uint8, uint32, uint32> *clientVersionEMule){
d32 1
@


1.1
log
@*** empty log message ***
@
text
@d52 9
a60 2
				if(clientVersionEMule)
					(*clientVersionEMule)[cur_client->GetMuleVersion()]++;
a61 1
			case SO_MLDONKEY: stats[3]++;break;
@

