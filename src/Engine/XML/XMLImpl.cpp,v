head	1.16;
access;
symbols
	PublicRelease_1_2e:1.16
	Interim_Release_1-2e_RC1:1.16
	PublicRelease_1_2d:1.16
	Interim_Release_1-2d_RC1:1.16
	Interim_Release_1-2d_beta1:1.16
	PublicRelease_1_2c:1.16
	Interim_Release_1-2c_RC1:1.16
	Interim_Release_1-2c_beta1:1.16
	PublicRelease_1_2b:1.16
	Interim_Release_1-2b_RC1:1.16
	PublicRelease_1_2a:1.16
	Interim_Release_1-2a_RC1:1.16
	Interim_Release_1-2a_beta2:1.16
	Interim_Release_1-2a_beta1:1.16
	PublicRelease_1_2:1.16
	Interim_Release_1-2_RC1:1.16
	Interim_Release_1-2_beta1:1.16
	PublicRelease_1_1g:1.16
	Interim_Release_1-1g_RC3:1.16
	Interim_Release_1-1g_RC2:1.16
	Interim_Release_1-1g_RC1:1.16
	Interim_Release_1-1g_beta2:1.16
	Interim_Release_1-1g_beta1:1.16
	PublicRelease_1_1f:1.16
	Interim_Release_1-1f_RC1:1.16
	PublicRelease_1_1e:1.16
	Interim_Release_1-1e_RC2:1.16
	Interim_Release_1-1e_RC1:1.16
	Interim_Release_1-1e_beta1:1.16
	PublicRelease_1_1d:1.11
	Interim_Release_1-1d_RC1:1.11
	PublicRelease_1_1c:1.11
	Interim_Release_1-1c_RC1:1.10
	Interim_Release_1-1c_beta2:1.6
	Interim_Release_1-1c_beta1:1.5
	PublicRelease_1_1b:1.1;
locks; strict;
comment	@// @;


1.16
date	2005.04.16.00.05.00;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.11.16.32.38;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.06.18.31.27;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.05.05.49.06;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.27.05.01.53;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.26.17.52.05;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.23.18.58.06;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.20.19.44.49;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.18.18.31.25;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.18.18.03.29;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.05.13.57.12;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.29.14.55.02;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.28.20.13.53;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.26.15.45.32;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.16
log
@v2 - Xml events and other improvements
@
text
@#include "stdafx.h"
#include "../Sockets/TasksSockets.h"
#include "../Database/TaskProcessorDB.h"
#include "../Files/TaskProcessorFiles.h"
#include "../../SharedFileList.h"
#include "../Data/Prefs.h"
#ifdef USE_BERKELEY_DB
	#include "../../BerkeleyDb/build_win32/db_cxx.h"
#endif //USE_BERKELEY_DB

#include "XML.h"
#include "XMLEvents.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_FUNC(connect)
{
	g_stEngine.ConnectToServer(m_sAddr, m_dwPort);

	//PrepareResult();
	return true;
}
XML_RESULT_EMPTY(connect)
XML_EVENT_EMPTY(connect)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_FUNC(disconnect)
{
	g_stEngine.DisconnectFromServer();

	//PrepareResult();
	return true;
}
XML_RESULT_EMPTY(disconnect)
XML_EVENT_EMPTY(disconnect)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_FUNC(hello)
{
	// Meanwhile automatically subscribe to events
	g_stEngine.XmlEvents.SubscribeToEvent(m_pClient->m_hSocket, XML_EVENT_SERVER);

	SendBuf((LPCTSTR)PrepareResult()->xml);

	return true;
}
XML_RESULT_EMPTY(hello)
XML_EVENT_EMPTY(hello)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_FUNC(quit)
{
//	::MessageBox(NULL, _T("quit"), _T(""), MB_OK|MB_TOPMOST);

	SendBuf((LPCTSTR)PrepareResult()->xml);

	g_stEngine.ShutDown();

	return true;
}
XML_RESULT_EMPTY(quit)
XML_EVENT_EMPTY(quit)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_FUNC(get_logs)
{
	switch(m_nState)
	{
	case XML_GET_START:
		m_spDoc = PrepareResult();
		m_nState = XML_GET_READ;
		g_stEngine.DB.Push(this);
		return false;
	case XML_GET_READ:
		// Get all records from logs
		for(LogLineList::iterator it = g_stEngine.DB.m_LogsList.begin(); it != g_stEngine.DB.m_LogsList.end(); it++)
		{
			if(it->eType >= m_dwTypeMin && it->eType <= m_dwTypeMax)
			{
				XmlElement spElem = XmlCreateElement(m_spDoc, m_spDoc->documentElement, _T("log"));
				XmlSetAttribute(spElem, _T("time"),		it->tmTime.Time);
				XmlSetAttribute(spElem, _T("precision"),it->tmTime.Precision);
				XmlSetAttribute(spElem, _T("debug"),	it->eType);
				XmlSetAttribute(spElem, _T("text"),		(LPCTSTR)(it->sLine));
			}
		}
		m_nState = XML_GET_SEND;
		g_stEngine.Sockets.Push(this);
		return false;
	case XML_GET_SEND:
		SendBuf((LPCTSTR)m_spDoc->xml);
		return true;
	}
	return true;
}

/*
#ifdef USE_BERKELEY_DB
	switch(m_nState)
	{
	case XML_GET_START:
		m_nState = XML_GET_READ;
		m_spDoc = PrepareResult();
		g_stEngine.DB.Push(this);
		return false;
	case XML_GET_READ:
		m_nState = XML_GET_SEND;
		// Get all records from logs
		try 
		{
			Dbc *dbcp;
			g_stEngine.DB.Logs.cursor(NULL, &dbcp, 0);
			Dbt key;
			Dbt data;
			while (dbcp->get(&key, &data, DB_NEXT) == 0) 
			{
				long lTime = *((long*)key.get_data());
				BYTE *pData = (BYTE*)data.get_data();
				BOOL bDebug = *((BOOL*)pData);
				LPCTSTR sLine = (LPCTSTR)(pData + sizeof(BOOL));
				XmlElement spElem = XmlCreateElement(m_spDoc, m_spDoc->documentElement, _T("log"));
				XmlSetAttribute(spElem, _T("time"), lTime);
				XmlSetAttribute(spElem, _T("debug"), bDebug);
				XmlSetAttribute(spElem, _T("text"), sLine);
			}
			dbcp->close();
		}
		catch (DbException &dbe) 
		{
			AddLog(LOG_ERROR, "Xml problems: %s", dbe.what());
		}
		catch(...)
		{
			AddLog(LOG_ERROR, "Xml problems read log from database.");
		}
		g_stEngine.Sockets.Push(this);
		return false;
	case XML_GET_SEND:
		SendBuf((LPCTSTR)m_spDoc->xml);
		return true;
	}
#endif //USE_BERKELEY_DB
*/

XML_RESULT_EMPTY(get_logs)
XML_EVENT_EMPTY(get_logs)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_FUNC(get_shared)
{
	switch(m_nState)
	{
	case XML_GET_START:
		m_nState = XML_GET_READ;
		m_spDoc = PrepareResult();
		g_stEngine.Files.Push(this);
		return false;
	case XML_GET_READ:
		m_nState = XML_GET_SEND;
		// Get all shared files
		try 
		{
			for(POSITION pos = g_stEngine.Files.SharedFiles.m_mapSharedFiles.GetStartPosition(); pos != NULL; )
			{
				CCKey		bufKey;
				CKnownFile*	pKnownFile = NULL;
				g_stEngine.Files.SharedFiles.m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
				if(pKnownFile && !pKnownFile->IsPartFile())
				{
					XmlElement spElem = XmlCreateElement(m_spDoc, m_spDoc->documentElement, _T("file"));
					XmlSetAttribute(spElem, _T("hash"), (LPCTSTR)HashToString(pKnownFile->GetFileHash()));
					XmlSetAttribute(spElem, _T("name"), (LPCTSTR)pKnownFile->GetFileName());
					XmlSetAttribute(spElem, _T("size"), pKnownFile->GetFileSize());
					XmlSetAttribute(spElem, _T("type"), pKnownFile->GetFileType());
					XmlSetAttribute(spElem, _T("link"), (LPCTSTR)pKnownFile->CreateED2kLink());
				}
			}
		}
		catch(...)
		{
			AddLog(LOG_ERROR, "Xml problems read shared files.");
		}
		g_stEngine.Sockets.Push(this);
		return false;
	case XML_GET_SEND:
		SendBuf((LPCTSTR)m_spDoc->xml);
		return true;
	}
	return true;
}
XML_RESULT_EMPTY(get_shared)
XML_EVENT_EMPTY(get_shared)

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_RESULT_EMPTY(set_param)
XML_EVENT_EMPTY(set_param)

XML_PROCESS_FUNC(set_param)
{
	switch(m_dwType)
	{
	case PARAM_UPLOAD_LIMIT:
		g_stEngine.Prefs.SetMaxUpload(m_dwValue);
		AddLog(LOG_DEBUG, _T("Set upload limit to %ld.%ld"), m_dwValue / 10, m_dwValue % 10);
		break;
	}
	return true;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_EMPTY(server_connected)
XML_RESULT_EMPTY(server_connected)
XML_EVENT_EMPTY(server_connected)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
XML_PROCESS_EMPTY(server_disconnected)
XML_RESULT_EMPTY(server_disconnected)
XML_EVENT_EMPTY(server_disconnected)
@


1.15
log
@v2 - logging subsystem
@
text
@d6 1
d12 1
d22 3
a24 4
XML_RESULT_FUNC(connect)
{
	return true;
}
d33 3
a35 4
XML_RESULT_FUNC(disconnect)
{
	return true;
}
d39 2
a40 1
//	::MessageBox(NULL, _T("hello"), _T(""), MB_OK|MB_TOPMOST);
d46 3
a48 4
XML_RESULT_FUNC(hello)
{
	return true;
}
d60 3
a62 4
XML_RESULT_FUNC(quit)
{
	return true;
}
d144 3
a146 4
XML_RESULT_FUNC(get_logs)
{
	return true;
}
d190 8
a197 1
XML_RESULT_FUNC(get_shared)
d199 7
d208 6
d215 3
@


1.14
log
@v2 - upload works (basic implementation)
@
text
@d15 1
a15 1
	g_stEngine.ConnectToServer(m_sAddr, m_ulPort);
d67 31
d143 2
a144 2
	return true;
}
@


1.13
log
@v2 - more upload logic, light configuration (without BerkeleyDb)
@
text
@a120 1
#ifdef USE_BERKELEY_DB
d126 1
a126 1
		g_stEngine.DB.Push(this);
a158 1
#endif //USE_BERKELEY_DB
@


1.12
log
@v2 - minor improvements
@
text
@d6 3
a8 1
#include "../../BerkeleyDb/build_win32/db_cxx.h"
d67 1
d111 1
d121 1
d160 1
@


1.11
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d96 1
a96 1
			TRACE("Problems: %s.\n", dbe.what());
d100 1
a100 1
			TRACE("Problems read log from database.\n");
d147 1
a147 1
			TRACE("Problems read shared files.\n");
@


1.10
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d4 2
d67 2
a68 2
	case XML_GETLOGS_START:
		m_nState = XML_GETLOGS_READ;
d72 2
a73 2
	case XML_GETLOGS_READ:
		m_nState = XML_GETLOGS_SEND;
d104 1
a104 1
	case XML_GETLOGS_SEND:
d115 47
@


1.9
log
@v2 - more shared files, other minor changes
@
text
@a5 7
enum
{
	XML_GETLOGS_START	= 0,
	XML_GETLOGS_READ	= 1,
	XML_GETLOGS_SEND	= 2
};

d21 12
@


1.8
log
@v2 - more minor rearrangements
@
text
@d5 8
d60 2
a61 2
	case 0:
		m_nState = 1;
d65 2
a66 2
	case 1:
		m_nState = 2;
d97 1
a97 1
	case 2:
@


1.7
log
@v2 - minor rearrangements, fixes for EngineTray compilation
@
text
@d87 1
a87 1
		g_stEngine.PushToSocketsTP(this);
@


1.6
log
@Connecting preferences and known/shared files
@
text
@d55 1
a55 1
		g_stEngine.PushToDB(this);
@


1.5
log
@Xml and database functionality
@
text
@d63 1
a63 1
			g_stEngine.m_pDbProcessor->m_pDbLogs->cursor(NULL, &dbcp, 0);
@


1.4
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@a1 1
#include "../EmEngine.h"
d3 2
d12 1
a12 1
	PrepareResult();
d22 1
a22 1
	::MessageBox(NULL, _T("hello"), _T(""), MB_OK|MB_TOPMOST);
d24 1
a24 1
	SendBuf(PrepareResult());
d35 1
a35 1
	::MessageBox(NULL, _T("quit"), _T(""), MB_OK|MB_TOPMOST);
d37 1
a37 1
	SendBuf(PrepareResult());
d48 52
@


1.3
log
@XML connecting, tray app
@
text
@d2 1
d38 1
a38 4
//	g_stEngine.Uninit();

//	PostQuitMessage(0);
	TerminateProcess(GetCurrentProcess(), 0);
@


1.2
log
@There can be only one engine :-)
@
text
@d2 1
a2 1
#include "../EmEngine.h"
d11 25
d37 9
@


1.1
log
@Rearrangements
@
text
@d8 1
a8 1
	stEngine.ConnectToServer(m_sAddr, m_ulPort);
@

