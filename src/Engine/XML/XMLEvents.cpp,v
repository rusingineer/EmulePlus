head	1.1;
access;
symbols
	PublicRelease_1_2e:1.1
	Interim_Release_1-2e_RC1:1.1
	PublicRelease_1_2d:1.1
	Interim_Release_1-2d_RC1:1.1
	Interim_Release_1-2d_beta1:1.1
	PublicRelease_1_2c:1.1
	Interim_Release_1-2c_RC1:1.1
	Interim_Release_1-2c_beta1:1.1
	PublicRelease_1_2b:1.1
	Interim_Release_1-2b_RC1:1.1
	PublicRelease_1_2a:1.1
	Interim_Release_1-2a_RC1:1.1
	Interim_Release_1-2a_beta2:1.1
	Interim_Release_1-2a_beta1:1.1
	PublicRelease_1_2:1.1
	Interim_Release_1-2_RC1:1.1
	Interim_Release_1-2_beta1:1.1
	PublicRelease_1_1g:1.1
	Interim_Release_1-1g_RC3:1.1
	Interim_Release_1-1g_RC2:1.1
	Interim_Release_1-1g_RC1:1.1
	Interim_Release_1-1g_beta2:1.1
	Interim_Release_1-1g_beta1:1.1
	PublicRelease_1_1f:1.1
	Interim_Release_1-1f_RC1:1.1
	PublicRelease_1_1e:1.1
	Interim_Release_1-1e_RC2:1.1
	Interim_Release_1-1e_RC1:1.1
	Interim_Release_1-1e_beta1:1.1;
locks; strict;
comment	@// @;


1.1
date	2005.04.16.00.05.00;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.1
log
@v2 - Xml events and other improvements
@
text
@#include "stdafx.h"
#include "XMLEvents.h"
#include "../Sockets/TasksSockets.h"
#include "XML.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLEvents::SetXmlResponse(ULONG ulId, LPCTSTR sResponse)
{
	//	CMutexLock stLock(m_mutexXmlResponses, true);
	m_stXmlResponses[ulId] = sResponse;
	//	stLock.Unlock();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This can be implemented better
CString CXMLEvents::WaitForXmlResponse(ULONG ulId, DWORD dwTimeout)
{
	CPreciseTime tmStart = CPreciseTime::GetCurrentTime();
	while(CPreciseTime::GetCurrentTime() - tmStart < (long)dwTimeout)
	{
		if(WaitForSingleObject(m_hStop, 100) != WAIT_TIMEOUT)
			return _T("");
		//		CMutexLock stLock(m_mutexXmlResponses, true);
		XmlRespMap::iterator it = m_stXmlResponses.find(ulId);
		if(it != m_stXmlResponses.end())
		{
			CString sRes = m_stXmlResponses[ulId];
			m_stXmlResponses.erase(ulId);
			//			stLock.Unlock();
			return sRes;
		}
		//		stLock.Unlock();
	}
	return _T("");
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLEvents::SubscribeToEvent(SOCKET hSocket, EnumXmlEvents eType)
{
	m_stEventMap.insert(EventSocketPair(eType, hSocket));
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLEvents::FireEventToSubscribed(EnumXmlEvents eType, CString sData)
{
	pair<EventSocketMap::iterator, EventSocketMap::iterator> 
		itRange = m_stEventMap.equal_range(eType);
	for(EventSocketMap::iterator it = itRange.first; it != itRange.second; it++)
	{
		CTask_SendXml* pTask = new CTask_SendXml(it->second, sData);
		if(pTask)
			g_stEngine.Sockets.Push(pTask);
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLEvents::Fire_OnConnectedToServer(DWORD dwAddr, USHORT uPort, long lClientID)
{
	XmlDoc spDoc = CXmlTask::PrepareDocument(_T("server_connected"), _T("event"));
	if(spDoc) 
	{
		XmlElement spElem = spDoc->documentElement;
		XmlSetAttribute(spElem, _T("Addr"), (long)dwAddr);
		XmlSetAttribute(spElem, _T("Port"), (long)uPort);
		XmlSetAttribute(spElem, _T("ClientID"), lClientID);
		FireEventToSubscribed(XML_EVENT_SERVER, (LPCTSTR)(spDoc->xml));
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CXMLEvents::Fire_OnDisconnectedFromServer()
{
	XmlDoc spDoc = CXmlTask::PrepareDocument(_T("server_disconnected"), _T("event"));
	if(spDoc) 
	{
		FireEventToSubscribed(XML_EVENT_SERVER, (LPCTSTR)(spDoc->xml));
	}
}

@
