head	1.51;
access;
symbols
	PublicRelease_1_2e:1.51
	Interim_Release_1-2e_RC1:1.51
	PublicRelease_1_2d:1.51
	Interim_Release_1-2d_RC1:1.51
	Interim_Release_1-2d_beta1:1.51
	PublicRelease_1_2c:1.51
	Interim_Release_1-2c_RC1:1.51
	Interim_Release_1-2c_beta1:1.51
	PublicRelease_1_2b:1.51
	Interim_Release_1-2b_RC1:1.51
	PublicRelease_1_2a:1.51
	Interim_Release_1-2a_RC1:1.51
	Interim_Release_1-2a_beta2:1.51
	Interim_Release_1-2a_beta1:1.51
	PublicRelease_1_2:1.51
	Interim_Release_1-2_RC1:1.51
	Interim_Release_1-2_beta1:1.51
	PublicRelease_1_1g:1.51
	Interim_Release_1-1g_RC3:1.51
	Interim_Release_1-1g_RC2:1.51
	Interim_Release_1-1g_RC1:1.51
	Interim_Release_1-1g_beta2:1.51
	Interim_Release_1-1g_beta1:1.51
	PublicRelease_1_1f:1.51
	Interim_Release_1-1f_RC1:1.51
	PublicRelease_1_1e:1.51
	Interim_Release_1-1e_RC2:1.51
	Interim_Release_1-1e_RC1:1.51
	Interim_Release_1-1e_beta1:1.51
	PublicRelease_1_1d:1.39
	Interim_Release_1-1d_RC1:1.38
	PublicRelease_1_1c:1.37
	Interim_Release_1-1c_RC1:1.36
	Interim_Release_1-1c_beta2:1.31
	Interim_Release_1-1c_beta1:1.29
	PublicRelease_1_1b:1.25
	Interim_Release_1-1b_RC1:1.24
	PublicRelease_1_1a:1.24
	Interim_Release_1-1a_RC2:1.24
	Interim_Release_1-1a_RC1:1.24
	Interim_Release_1-1a_beta2:1.24
	Interim_Release_1-1a_beta1:1.24
	PublicRelease_1_1:1.24
	Interim_Release_1-1_beta1:1.24
	PublicRelease_1o:1.24
	Interim_Release_1o_RC1:1.24
	Interim_Release_1o_beta1:1.24
	PublicRelease_1n:1.24
	Interim_Release_1n_RC2:1.24
	Interim_Release_1n_RC1:1.24
	PublicRelease_1m:1.22
	Interim_Release_1m_beta1:1.22
	PublicRelease_1l:1.22
	Interim_Release_1l_RC3:1.21
	Interim_Release_1l_RC2:1.21
	Interim_Release_1l_RC1:1.21
	Interim_Release_1l_beta2:1.17
	Interim_Release_1l_beta1:1.17
	PublicRelease_1k:1.16
	Interim_Release_1k_RC4:1.16
	Interim_1k_RC3:1.16
	Interim_1k_RC2:1.16
	Interim_Release_1k_RC1:1.16
	Interim_Release_1k_beta5:1.16
	Intrerim_Release_1k_beta4:1.16
	Interim_Release_1k_beta1:1.16
	PublicRelease_1j:1.11
	Interim_Release_1J_RC3:1.11
	Interim_Release_1j_RC3:1.11
	Interim_Release_1j_RC2:1.10
	Interim_Release_1j_RC1:1.10
	Interim_Release_1j_beta2:1.10
	Interim_Release_1j_beta1:1.6;
locks; strict;
comment	@// @;


1.51
date	2005.04.17.05.16.25;	author kuchin;	state Exp;
branches;
next	1.50;

1.50
date	2005.04.16.00.04.59;	author kuchin;	state Exp;
branches;
next	1.49;

1.49
date	2005.04.11.16.32.20;	author kuchin;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.08.14.16.36;	author kuchin;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.08.11.09.34;	author kuchin;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.07.17.24.48;	author kuchin;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.06.05.25.02;	author kuchin;	state Exp;
branches;
next	1.44;

1.44
date	2005.04.05.05.48.56;	author kuchin;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.29.14.36.13;	author kuchin;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.27.05.01.50;	author kuchin;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.22.22.02.09;	author kuchin;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.22.15.54.09;	author kuchin;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.18.15.36.50;	author kuchin;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.13.19.29.58;	author kuchin;	state Exp;
branches;
next	1.37;

1.37
date	2005.02.26.17.52.05;	author kuchin;	state Exp;
branches;
next	1.36;

1.36
date	2005.02.23.18.57.46;	author kuchin;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.20.19.44.45;	author kuchin;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.19.20.40.56;	author kuchin;	state Exp;
branches;
next	1.33;

1.33
date	2005.02.18.18.31.24;	author kuchin;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.18.18.03.29;	author kuchin;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.05.13.57.11;	author kuchin;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.03.15.14.14;	author kuchin;	state Exp;
branches;
next	1.29;

1.29
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.28.20.13.52;	author kuchin;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.26;

1.26
date	2004.12.29.16.04.22;	author kuchin;	state Exp;
branches;
next	1.25;

1.25
date	2004.12.26.06.50.22;	author kuchin;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.09.14.15.51;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2004.06.30.13.39.02;	author dongato;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.13.21.56.43;	author eklmn;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.23.15.41.25;	author eklmn;	state Exp;
branches;
next	1.20;

1.20
date	2004.05.23.15.32.19;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.23.15.30.34;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.23.14.55.09;	author eklmn;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.21.16.29.43;	author eklmn;	state Exp;
branches;
next	1.16;

1.16
date	2004.02.07.11.37.09;	author morevit;	state Exp;
branches;
next	1.15;

1.15
date	2004.02.07.11.31.47;	author morevit;	state Exp;
branches;
next	1.14;

1.14
date	2004.02.06.13.57.28;	author morevit;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.05.19.31.57;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.16.14.50.55;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2004.01.07.10.54.30;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2004.01.07.09.17.54;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2004.01.06.11.13.13;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.03.11.19.55;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.23.18.13.43;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.23.10.20.34;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.22.16.34.49;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.21.16.49.43;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.21.10.29.05;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.51
log
@v2 - corrected protocol, tags
@
text
@// EmEngine.cpp: implementation of the CEmEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "Files/TaskProcessorFiles.h"
#include "Database/TaskProcessorDB.h"
#include "Other/TaskProcessorLogger.h"

#include "Other/EmWinNT.h"
#include "Other/EmMt.h"
#include "Other/ThreadPool.h"
#include "TaskProcessor.h"
#include "EmEngine.h"
#include "Sockets/TasksSockets.h"
#include "Sockets/TasksOpcodes.h"
#include "Sockets/TcpEngineMule.h"
#include "Data/ClientList.h"
#include "Data/Prefs.h"
#include "XML/XMLEvents.h"

#include "Data/Server.h"
//#include "Files/KnownFile.h"
//#include "Other/ed2k_filetype.h" included indirect over KnownFile.h

#include "XML/XML.h"

//////////////////////////////////////////////////////////////////////
// Constructor
CEmEngine::CEmEngine()
	:m_pTcpEngineMule(NULL)
	,m_pMainProcessor(NULL)
	,m_pFilesProcessor(NULL)
	,m_pLoggerProcessor(NULL)
	,m_pDbProcessor(NULL)
	,m_pClientList(NULL)
	,m_pPreferences(NULL)
	,m_pXmlEvents(NULL)
{
	ServerState.nConnState = SERVER_DISCONNECTED;
	ServerState.hSocket = NULL;
	ServerState.dwAddr = 0;
	ServerState.uPort = 0;
	ServerState.nClientID = 0;

	m_dwThreadId = GetCurrentThreadId();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start
bool CEmEngine::Init()
{
/*	CServer stSrv;
	stSrv.ImportFromServerMet(*this, _T("./Db/server.met"));

	if(stSrv.ListStartByStatic(*this))
	{
		while(stSrv.ListGetNext())
		{
			int a = 1;
		}
		stSrv.ListFinish();
	}*/

	// Clients list
	m_pClientList = new CClientList;

	// Preferences
	m_pPreferences = new CPrefs;

	// Xml events
	m_pXmlEvents = new CXMLEvents;

	m_pTcpEngineMule = new CTcpEngineMule;

	// Base class init
	if(!CEmEngineBase::Init())
		return false;

	//	Try to initialize the Logger
	m_pLoggerProcessor = new CTaskProcessor_Logger;
	if (!m_pLoggerProcessor->Init())
	{
		AddLog(LOG_ERROR, _T("Failed to initialize logger processor"));
		return false;
	}

	//	Try to initialize the DB TaskProcessor
	m_pDbProcessor = new CTaskProcessor_DB;
	if (!m_pDbProcessor->Init())
	{
		AddLog(LOG_ERROR, _T("Failed to initialize database processor"));
		return false;
	}
	//	Try to initialize the Files TaskProcessor
	m_pFilesProcessor = new CTaskProcessor_Files;
	if (!m_pFilesProcessor->Init())
	{
		AddLog(LOG_ERROR, _T("Failed to initialize files processor"));
		return false;
	}
	m_pMainProcessor = new CTaskProcessor_Main;
	if (!m_pMainProcessor->Init())
	{
		AddLog(LOG_ERROR, _T("Failed to initialize main processor"));
		return false;
	}
	//initial sort file types array
/*	if (!InitFileTypeArray())
	{
		ASSERT(FALSE);
		AddDebugLogLine("Failed to initialize filetype array");
		return false;
	}*/

	// add relevant interfaces
	GetTcpEngine()->AddInterface(Prefs.PortXml,		T_CLIENT_XML,	Prefs.XmlLocalBind ? LISTEN_TO_LOOPBACK : LISTEN_TO_INTERNET);
	GetTcpEngine()->AddInterface(Prefs.GetPort(),	T_CLIENT_PEER);

	//TcpEngine.AddInterface(80, T_CLIENT_WEB);

	return true;
}

void CEmEngine::UninitMiddle()
{
	m_pMainProcessor->Uninit();
	delete m_pMainProcessor;
}

void CEmEngine::UninitFinal()
{
	EMULE_TRY

	m_pLoggerProcessor->Uninit();
	delete m_pLoggerProcessor;

	m_pFilesProcessor->Uninit();
	delete m_pFilesProcessor;

	m_pDbProcessor->Uninit();
	delete m_pDbProcessor;

	delete m_pTcpEngineMule;

	delete m_pXmlEvents;

	delete m_pPreferences;

	delete m_pClientList;

	EMULE_CATCH2
}

bool CEmEngine::SendOpCode(SOCKET hSocket, const COpCode &stOpCode, CEmClient* pClient, EnumQueuePriority ePriority)
{
	if(pClient && Prefs.SaveLogsIO)
		m_pLoggerProcessor->Post(stOpCode, pClient->GetType(), pClient->m_nClientID, TRUE);
	return TcpEngineMule.AllocSend(hSocket, stOpCode, ePriority);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Connecting to given server addr/port
void CEmEngine::ConnectToServer(CString sAddr/* = "" */, ULONG ulPort/* = 0 */)
{
	EMULE_TRY

	if (GetServerSocket())
	{
		DisconnectFromServer(GetServerSocket());
	}

	AddLog(LOG_DEBUG, _T("Connecting to server (%s:%d)"), sAddr, ulPort);

	CTask_LoginToServer	*pCompletionTask = new CTask_LoginToServer();
	CTask_Connect		*pTask = new CTask_Connect(sAddr, (USHORT) ulPort, T_CLIENT_SERVER, pCompletionTask);

	SetConnectionState(SERVER_CONNECTING);
	m_pSocketsProcessor->Push(pTask);

	EMULE_CATCH2
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Connect to any server
void CEmEngine::ConnectToAnyServer()
{
	ConnectToServer();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Disconnect from connected server
void CEmEngine::DisconnectFromServer(SOCKET hPrevServer /* = NULL */)
{
	if(!hPrevServer)
	{
		if(GetServerSocket())
			DisconnectFromServer(GetServerSocket());
		else
			SetConnectionState(SERVER_DISCONNECTED);
		return;
	}

	CEmClient* pServer = m_pSocketsProcessor->Lookup(hPrevServer);
	if(!pServer)
	{
		AddLog(LOG_ERROR, _T("lookup for server failed"));
		return;
	}
	AddLog(LOG_DEBUG, _T("Disconnecting from server (%s:%d)"), inet_ntoa(*reinterpret_cast<in_addr*>(&pServer->m_dwAddr)), pServer->m_uPort);
	CTask_KillClient* pTask = new CTask_KillClient(pServer);
	m_pSocketsProcessor->Push(pTask);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmEngine::SetConnectionState(short nConnectionState)
{
	ServerState.nConnState = nConnectionState;

//	Export connection state
	switch (nConnectionState)
	{
		case SERVER_DISCONNECTED:
		{
			ServerState.hSocket = NULL;
			ServerState.dwAddr = 0;
			ServerState.uPort = 0;
			ServerState.nClientID = 0;
			AddLog(LOG_NOTICE, "Disconnected from server");

			XmlEvents.Fire_OnDisconnectedFromServer();
			break;
		}
		case SERVER_CONNECTING:
		{
			AddLog(LOG_DEBUG, "Connection state: connecting");
			break;
		}
		case SERVER_WAITFORLOGIN:
		{
			AddLog(LOG_DEBUG, "Connection state: waiting for login");
			break;
		}
		case SERVER_CONNECTED:
		{
			AddLog(LOG_DEBUG, "Connection state: connected");
			// send list of shared files
			CTask_SendSharedList* pTask = new CTask_SendSharedList();
			if(pTask)
				Sockets.Push(pTask);
			break;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmEngine::SetClientID(long cID)
{
	ServerState.nClientID = cID; 
	AddLog(LOG_NOTICE, _T("New client ID: %ld"), cID);

	XmlEvents.Fire_OnConnectedToServer(ServerState.dwAddr, ServerState.uPort, ServerState.nClientID);
}

//////////////////////////////////////////////////////////////////////
void CEmEngine::ConnectedTo(CEmClient_Server* pClient)
{
	ServerState.hSocket = pClient->m_hSocket;
	ServerState.dwAddr = pClient->m_dwAddr;
	ServerState.uPort = pClient->m_uPort;
}

//////////////////////////////////////////////////////////////////////
bool CEmEngine::IsLocalServer(ULONG nAddr, USHORT uPort)
{
	if(!ServerState.IsConnected())
		return false;
	/*	if(m_stConnected.pServer)
	{
	if (m_stConnected.pServer->GetIP() == nAddr &&
	m_stConnected.pServer->GetPort() == uPort)
	return true;
	}*/
	return false;
}

//////////////////////////////////////////////////////////////////////
void CEmEngine::ProcessSocketsTimeout()
{
	ClientList.PurgeBadClients();
	ClientList.CheckAcceptNewClient();
	ClientList.ProcessUpload();
}

bool CEmEngine::AlertOnErrors() const	
{ 
	return Prefs.AlertOnErrors; 
}
@


1.50
log
@v2 - Xml events and other improvements
@
text
@d118 1
a118 1
	GetTcpEngine()->AddInterface(Prefs.PortXml,		T_CLIENT_XML);
@


1.49
log
@v2 - logging subsystem
@
text
@d21 1
d39 1
d43 2
a44 2
	ServerState.nAddr = 0;
	ServerState.nPort = 0;
d72 3
d134 2
d147 2
d152 2
d225 2
a226 2
			ServerState.nAddr = 0;
			ServerState.nPort = 0;
d228 3
a230 1
			AddLog(LOG_DEBUG, "Connection state: disconnected");
d258 3
a260 1
	AddLog(LOG_DEBUG, _T("New client ID: %ld"), cID);
d267 2
a268 2
	ServerState.nAddr = pClient->m_dwAddr;
	ServerState.nPort = pClient->m_uPort;
@


1.48
log
@v2 - more abstraction + logic
@
text
@d35 1
a37 3
#ifdef USE_BERKELEY_DB
	,m_pDbProcessor(NULL)
#endif //USE_BERKELEY_DB
a83 1
#ifdef USE_BERKELEY_DB
a90 1
#endif //USE_BERKELEY_DB
a134 1
#ifdef USE_BERKELEY_DB
a136 1
#endif //USE_BERKELEY_DB
@


1.47
log
@v2 - increased level of abstraction + minor improvements
@
text
@d18 1
d31 9
d72 2
d117 2
a118 2
	Sockets.m_stTcp.AddInterface(9090, T_CLIENT_XML);
	Sockets.m_stTcp.AddInterface(Prefs.GetPort(), T_CLIENT_PEER);
d120 1
a120 1
	//m_stTcp.AddInterface(80, T_CLIENT_WEB);
d144 2
d155 1
a155 1
	return m_pSocketsProcessor->m_stTcp.AllocSend(hSocket, stOpCode, ePriority);
a287 65

/*

//////////////////////////////////////////////////////////////////////
// Executed in GUI thread
void CEngineData::ImportServerState(CTask_ServerState* pTask)
{
	if(!pTask)
	{
		ASSERT(FALSE);
		return;
	}

	// should keep independent server list in the future
	if(!m_pServerList)
		m_pServerList = g_eMuleApp.m_pServerList;

	if(m_nClientID != pTask->m_nClientID)
	{
		m_nClientID = pTask->m_nClientID;
		AddLogLine(false, IDS_NEWCLIENTID, m_nClientID);
	}

	pState->pServer = m_pServerList->GetServerByIP(pState->nAddr, pState->nPort);

	if(pState->nConnState != pTask->m_stState.nConnState)
	{
		pState->nConnState = pTask->m_stState.nConnState;
		switch(pState->nConnState)
		{
		case SERVER_DISCONNECTED:
			if(m_stConnected.nConnState == SERVER_DISCONNECTED)
				g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
			break;
		case SERVER_CONNECTING:
			g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
			break;
		case SERVER_WAITFORLOGIN:
			if(m_stConnecting.pServer)
				AddLogLine(false, IDS_CONNECTEDTOREQ,
				m_stConnecting.pServer->GetListName(),
				m_stConnecting.pServer->GetFullIP(),
				m_stConnecting.pServer->GetPort());
			break;
		case SERVER_CONNECTED:
			if(m_stConnected.pServer)
			{
				AddLogLine(true, IDS_CONNECTEDTO, m_stConnected.pServer->GetListName());
				g_eMuleApp.m_pdlgEmule->ShowConnectionState(true, m_stConnected.pServer->GetListName());
				//				if(IsLowID())
				//					AddLogLine(false, GetResString(IDS_GOTLOWID));

				// Write online signature
				g_eMuleApp.OnlineSig();

				// Resume downloading files
				g_eMuleApp.m_pDownloadQueue->ResumeFiles();

				m_stEngine.SendSharedListToServer();
			}
			break;
		}
	}
}
*/
@


1.46
log
@v2 - fixes for upload logic
@
text
@a6 1
#include "Sockets/TaskProcessorSockets.h"
d29 1
a29 2
CEmEngine::CEmEngine() :
	 m_hStop(NULL)
d62 7
a68 2
	// Create an Event which can be asserted to stop the Engine. If successful...
	if (m_hStop = CreateEvent(NULL, TRUE, FALSE, NULL))
d70 4
a73 7
		//	Try to initialize the Logger
		m_pLoggerProcessor = new CTaskProcessor_Logger;
		if (!m_pLoggerProcessor->Init())
		{
			AddLog(LOG_ERROR, _T("Failed to initialize logger processor"));
			return false;
		}
d75 7
a81 7
		//	Try to initialize the DB TaskProcessor
		m_pDbProcessor = new CTaskProcessor_DB;
		if (!m_pDbProcessor->Init())
		{
			AddLog(LOG_ERROR, _T("Failed to initialize database processor"));
			return false;
		}
d83 6
a88 45
		//	Try to initialize the Files TaskProcessor
		m_pFilesProcessor = new CTaskProcessor_Files;
		if (!m_pFilesProcessor->Init())
		{
			AddLog(LOG_ERROR, _T("Failed to initialize files processor"));
			return false;
		}
		//	Initialize the Sockets TaskProcessor
		m_pSocketsProcessor = new CTaskProcessor_Sockets;
		if (m_pSocketsProcessor->Init())
		{
			//	Initialize the TCP "Engine".
			if (m_pSocketsProcessor->m_stTcp.Init())
			{
				// add relevant interfaces
				Sockets.m_stTcp.AddInterface(9090, T_CLIENT_XML);
				Sockets.m_stTcp.AddInterface(Prefs.GetPort(), T_CLIENT_PEER);
				//m_stTcp.AddInterface(80, T_CLIENT_WEB);
			}
			else
			{
				AddLog(LOG_ERROR, _T("Failed to initialize sockets processor"));
				return false;
			}
		}
		else
		{
			AddLog(LOG_ERROR, _T("Failed to initialize sockets processor"));
			return false;
		}
		m_pMainProcessor = new CTaskProcessor_Main;
		if (!m_pMainProcessor->Init())
		{
			AddLog(LOG_ERROR, _T("Failed to initialize main processor"));
			return false;
		}
		//initial sort file types array
/*		if (!InitFileTypeArray())
		{
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize filetype array");
			return false;
		}*/

		return true;
d90 2
a91 1
	else
d93 1
a93 1
		AddLog(LOG_ERROR, _T("CreateEvent failed"));
d96 2
a97 6
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Stop
void CEmEngine::Uninit()
{
	if (m_hStop)
d99 4
a102 2
		if (!SetEvent(m_hStop))
			AddLog(LOG_ERROR, _T("SetEvent failed"));
d104 3
a106 2
		m_pSocketsProcessor->m_stTcp.Uninit(false);
		m_pSocketsProcessor->Uninit();
d108 1
a108 2
		m_pMainProcessor->Uninit();
		delete m_pMainProcessor;
d110 2
a111 2
		m_pSocketsProcessor->m_stTcp.Uninit(); // final
		delete m_pSocketsProcessor;
d113 5
a117 2
		m_pLoggerProcessor->Uninit();
		delete m_pLoggerProcessor;
d119 7
a125 2
		m_pFilesProcessor->Uninit();
		delete m_pFilesProcessor;
d128 2
a129 2
		m_pDbProcessor->Uninit();
		delete m_pDbProcessor;
d132 1
a132 3
		delete m_pPreferences;

		delete m_pClientList;
d134 1
a134 4
		if (!CloseHandle(m_hStop))
			AddLog(LOG_ERROR, _T("CloseHandle failed"));
		m_hStop = NULL;
	}
d139 1
a139 1
	if (pClient)
d270 5
@


1.45
log
@v2 - more upload logic
@
text
@d174 1
a174 1
bool CEmEngine::SendOpCode(SOCKET hSocket, const COpCode &stOpCode, CEmClient* pClient)
d178 1
a178 1
	return m_pSocketsProcessor->m_stTcp.AllocSend(hSocket, stOpCode);
@


1.44
log
@v2 - more upload logic, light configuration (without BerkeleyDb)
@
text
@d304 1
@


1.43
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d74 1
d82 1
d159 1
d162 1
@


1.42
log
@v2 - minor improvements
@
text
@d19 1
a19 1
#include "Data/Client.h"
@


1.41
log
@v2 - enhancing logging subsystem
@
text
@d188 1
a188 2
//	AddLogLine(false, IDS_CONNECTINGTO, pServer->GetListName(), pServer->GetAddress(), pServer->GetPort());
	AddLog(LOG_DEBUG, _T("Connecting to server (%s:%d)\n"), sAddr, ulPort);
d223 1
d242 1
a242 1
			AddLog(LOG_DEBUG, "\nCONNECTION STATE CHANGE: DISCONNECTED");
d247 1
a247 1
			AddLog(LOG_DEBUG, "\nCONNECTION STATE CHANGE: CONNECTING");
d252 1
a252 1
			AddLog(LOG_DEBUG, "\nCONNECTION STATE CHANGE: WAITING FOR LOGIN");
d257 1
a257 1
			AddLog(LOG_DEBUG, "\nCONNECTION STATE CHANGE: CONNECTED");
d270 1
@


1.40
log
@v2 - more upload logic
@
text
@d43 1
a43 1
// start
d71 1
a71 2
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize logger processor");
d78 1
a78 2
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize database processor");
d85 1
a85 2
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize files processor");
d102 1
a102 2
				ASSERT(FALSE);
				AddDebugLogLine("Failed to initialize sockets processor");
d108 1
a108 2
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize sockets processor");
d114 1
a114 2
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize main processor");
d129 1
a129 2
		ASSERT(FALSE);
		AddDebugLogLine("CreateEvent failed");
d134 1
a134 1
// stop
d140 1
a140 4
		{
			ASSERT(FALSE);
			AddDebugLogLine("SetEvent failed");
		}
d165 1
a165 4
		{
			ASSERT(FALSE);
			AddDebugLogLine("CloseHandle failed");
		}
d178 1
a178 1
// connecting to given server addr/port
d189 1
a189 1
	TRACE(_T("Connecting to server (%s:%d)\n"), sAddr, ulPort);
d200 1
a200 1
// connect to any server
d206 1
a206 1
// disconnect from connected server
d221 1
a221 2
		ASSERT(FALSE);
		AddDebugLogLine(_T("lookup for server failed"));
d242 1
a242 1
			TRACE("\nCONNECTION STATE CHANGE: DISCONNECTED\n");
d247 1
a247 1
			TRACE("\nCONNECTION STATE CHANGE: CONNECTING\n");
d252 1
a252 1
			TRACE("\nCONNECTION STATE CHANGE: WAITING FOR LOGIN\n");
d257 1
a257 1
			TRACE("\nCONNECTION STATE CHANGE: CONNECTED\n");
d297 1
@


1.39
log
@v2 - more upload logic
@
text
@d20 1
a20 2

#include "../Preferences.h"
d62 1
a62 1
	m_pPreferences = new CPreferences;
d311 1
@


1.38
log
@v2 - little improvements
@
text
@d310 1
a310 22
/*
#ifdef _DEBUG
static BYTE g_arrUserHash[16] = { 0x6c, 0x7c, 0x5d, 0x3b, 0x90, 0x0e, 0x11, 0x3f, 0xb1, 0x5c, 0x1c, 0x2e, 0xe8, 0x19, 0x6f, 0x59 };
#endif //_DEBUG

BYTE* CEmEngine::GetUserHash()
{
	//	return g_eMuleApp.m_pGlobPrefs->GetUserHash();
#ifdef _DEBUG
	return g_arrUserHash;
#else
	return NULL;
#endif
}

USHORT CEmEngine::GetPort()
{
	//	return g_eMuleApp.m_pGlobPrefs->GetPort();
	return 4662;
}

CString CEmEngine::GetUserNick()
a311 2
	//	return g_eMuleApp.m_pGlobPrefs->GetUserNick();
	return _T("ePlus v2 debug (rus)(de)");
a313 6
CString	CEmEngine::ConfigDirTemp()
{
	return _T("./temp");
}
*/

a314 10
// Contain all information about connecting/connected client
class CEmClientData
{
public:
	CPartFile*	GetFile() const { return m_pPartFile; }

private:
	CPartFile	*m_pPartFile;
};

d326 1
a326 1
	// should keep independent serverlist in the future
@


1.37
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d19 1
d59 3
a61 1
//	Create an Event which can be asserted to stop the Engine. If successful...
d64 2
d76 1
a76 1
		//	Try to initialize the Logger
d84 1
a84 1
		//	Try to initialize the Logger
d173 2
@


1.36
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@a235 13
//////////////////////////////////////////////////////////////////////
// send list of shared files
void CEmEngine::SendSharedListToServer()
{
	EMULE_TRY

	CTask_SendSharedList	   *pTask = new CTask_SendSharedList();

	m_pSocketsProcessor->Push(pTask);

	EMULE_CATCH2
}

d266 4
@


1.35
log
@v2 - more shared files, other minor changes
@
text
@d33 5
a37 5
	m_stServer.nConnState = SERVER_DISCONNECTED;
	m_stServer.hSocket = NULL;
	m_stServer.nAddr = 0;
	m_stServer.nPort = 0;
	m_stServer.nClientID = 0;
a248 18
//////////////////////////////////////////////////////////////////////
bool CEmEngine::IsConnecting()
{
	return ( m_stServer.nConnState == SERVER_CONNECTING
		  || m_stServer.nConnState == SERVER_WAITFORLOGIN ); 
}

//////////////////////////////////////////////////////////////////////
bool CEmEngine::IsConnected()
{ 
	return (m_stServer.nConnState == SERVER_CONNECTED);
}

//////////////////////////////////////////////////////////////////////
bool CEmEngine::IsLowID()
{ 
	return (m_stServer.nClientID < 0x1000000); 
}
d252 1
a252 1
	m_stServer.nConnState = nConnectionState;
d259 4
a262 4
			m_stServer.hSocket = NULL;
			m_stServer.nAddr = 0;
			m_stServer.nPort = 0;
			m_stServer.nClientID = 0;
d286 1
a286 1
	m_stServer.nClientID = cID; 
d292 3
a294 3
	m_stServer.hSocket = pClient->m_hSocket;
	m_stServer.nAddr = pClient->m_dwAddr;
	m_stServer.nPort = pClient->m_uPort;
d300 1
a300 1
	if(!IsConnected())
@


1.34
log
@v2 - connecting to server, updated protocol, bugfixes
@
text
@d281 1
a281 1
			TRACE("CONNECTION STATE CHANGE: DISCONNECTED\n");
d286 1
a286 1
			TRACE("CONNECTION STATE CHANGE: CONNECTING\n");
d291 1
a291 1
			TRACE("CONNECTION STATE CHANGE: WAITING FOR LOGIN\n");
d296 1
a296 1
			TRACE("CONNECTION STATE CHANGE: CONNECTED\n");
@


1.33
log
@v2 - more minor rearrangements
@
text
@d95 2
a96 1
				m_pSocketsProcessor->m_stTcp.AddInterface(9090, T_CLIENT_XML);
a97 1
				//m_stTcp.AddInterface(7821, T_CLIENT_PEER);
@


1.32
log
@v2 - minor rearrangements, fixes for EngineTray compilation
@
text
@a176 40
void CEmEngine::PushToSocketsTP(CTask *pTask)
{
	m_pSocketsProcessor->Push(pTask);
}

void CEmEngine::PushToLogger(CTask *pTask)
{
	m_pLoggerProcessor->Push(pTask);
}

void CEmEngine::KillClient(CEmClient *pClient)
{
	m_pSocketsProcessor->KillClient(pClient);
}

CEmClient* CEmEngine::LookupClient(SOCKET hSocket)
{
	return m_pSocketsProcessor->Lookup(hSocket);
}

CEmClient* CEmEngine::AllocClient(T_CLIENT_TYPE eType)
{
	return m_pSocketsProcessor->AllocClient(eType);
}

void CEmEngine::AddClientToMap(SOCKET hSocket, CEmClient *pClient)
{
	m_pSocketsProcessor->m_mapClients[hSocket] = pClient;
}

CEmClient* CEmEngine::AllocTcpConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType, CTcpCompletionTask *pOnCompletionTask)
{
	return m_pSocketsProcessor->AllocTcpConnect(nAddr, nPort, eType, pOnCompletionTask);
}

bool CEmEngine::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwLen)
{
	return m_pSocketsProcessor->m_stTcp.AllocSend(hSocket, pData, dwLen);
}

@


1.31
log
@Connecting preferences and known/shared files
@
text
@a181 5
void CEmEngine::PushToDB(CTask *pTask)
{
	m_pDbProcessor->Push(pTask);
}

@


1.30
log
@Ideological switch (may be considered as temporary, but for long term) - ATL to MFC
Actually we don't need them both, but I want to work with our current KnownFile-based classes, which use MFC a lot
@
text
@d8 1
d20 2
a31 1
	,m_hWndUI(NULL)
d44 1
a44 1
bool CEmEngine::Init(HWND hWndUI)
a57 1
	m_hWndUI = hWndUI;
d59 2
d79 8
d160 3
d166 2
d375 1
a375 1

d406 1
a406 1

@


1.29
log
@Xml and database functionality
@
text
@d386 6
@


1.28
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@d7 4
d20 1
a20 1
#include "Files/KnownFile.h"
d61 2
a62 1
		if (!m_stLoggerTP.Init())
d69 2
a70 1
		if (!m_stDBTP.Init())
d77 2
a78 1
		if (m_stSocketsTP.Init())
d81 1
a81 1
			if (m_stSocketsTP.m_stTcp.Init())
d84 1
a84 1
				m_stSocketsTP.m_stTcp.AddInterface(9090, T_CLIENT_XML);
d101 2
a102 1
		if (!m_stMainTP.Init())
d109 1
a109 1
		if (!InitFileTypeArray())
d114 1
a114 1
		}
d137 14
a150 7
		m_stSocketsTP.m_stTcp.Uninit(false);
		m_stSocketsTP.Uninit();
		m_stMainTP.Uninit();

		m_stSocketsTP.m_stTcp.Uninit(); // final
		m_stLoggerTP.Uninit();
		m_stDBTP.Uninit();
d161 52
d231 1
a231 1
	m_stSocketsTP.Push(pTask);
d254 1
a254 1
	CEmClient* pServer = m_stSocketsTP.Lookup(hPrevServer);
d262 1
a262 1
	m_stSocketsTP.Push(pTask);
d273 1
a273 1
	m_stSocketsTP.Push(pTask);
@


1.27
log
@XML connecting, tray app
@
text
@a25 4
	,m_pDbEnv(NULL)
	,m_pDbServers(NULL)
	,m_pDbFiles(NULL)
	,m_pDbMD4Parts(NULL)
d32 2
a39 3
	if(!InitializeDatabases())
		return false;

d56 2
a57 2
		//	Try to initialize the Logger. If we fail...
		if (!m_stLogger.Init())
d60 8
a67 1
			AddDebugLogLine("Failed to initialize logger engine");
d84 1
a84 1
				AddDebugLogLine("Failed to initialize TCP engine");
a117 95

#define SERVERLIST_DB _T("Servers.db")
#define FILES_DB _T("files.db")

bool CEmEngine::InitializeDatabases()
{
	try
	{
		CString sDbHome = _T("./Db"); //CString(m_pGlobPrefs->GetAppDir()) + _T("Db");

		::CreateDirectory(sDbHome, NULL);	// In case it doesn't exist

		// Create environment
		m_pDbEnv = new DbEnv(0);
		m_pDbEnv->set_cachesize(0, 256 * 1024, 0);	// 256kb cache size
		m_pDbEnv->set_alloc(&malloc,&realloc,&free);
		USES_CONVERSION;
		m_pDbEnv->open( CT2CA(sDbHome), DB_CREATE | DB_INIT_LOCK | DB_INIT_LOG
			| DB_INIT_MPOOL | DB_INIT_TXN | DB_RECOVER
			| DB_THREAD, 0 );

		m_pDbEnv->set_flags(DB_AUTO_COMMIT, 1);

		// Servers list
		m_pDbServers = new Db(m_pDbEnv, 0);
		m_pDbServers->set_pagesize(16 * 1024); // 16Kb page m_lSize
		m_pDbServers->open(NULL, SERVERLIST_DB, _T("Server-List"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

/*		// Servers list - primary index by addr/port
		m_pDbServersAddr = new Db(m_pDbEnv, 0);
		m_pDbServersAddr->open(NULL, SERVERLIST_DB, _T("Server-List-Addr"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersAddr, CServer::PrimaryIndex, NULL);

		// Servers list - secondary index by 'static' field
		m_pDbServersStatic = new Db(m_pDbEnv, 0);
		m_pDbServersStatic->set_flags(DB_DUP | DB_DUPSORT);
		m_pDbServersStatic->open(NULL, SERVERLIST_DB, _T("Server-List-Static"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersStatic, CServer::SecondaryIndexStatic, NULL);

		// Servers list - secondary index by 'priority' field
		m_pDbServersPriority = new Db(m_pDbEnv, 0);
		m_pDbServersPriority->set_flags(DB_DUP | DB_DUPSORT);
		m_pDbServersPriority->open(NULL, SERVERLIST_DB, _T("Server-List-Priority"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

		m_pDbServers->associate(NULL, m_pDbServersPriority, CServer::SecondaryIndexPriority, NULL);
*/
		// files DB
		m_pDbFiles = new Db(m_pDbEnv, 0);
		m_pDbFiles->set_pagesize(16 * 1024); // 16Kb page m_lSize
		m_pDbFiles->open(NULL, FILES_DB, _T("FileDB"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

/*		// files DB - secondary index by hash
		m_pDbFilesHash = new Db(m_pDbEnv, 0);
		m_pDbFilesHash->set_flags(DB_DUP | DB_DUPSORT);
		m_pDbFilesHash->open(NULL, FILES_DB, _T("FileDB-Hash"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

///		m_pDbFiles->associate(NULL, m_pDbFilesHash, CKnownFile::FileHashIndex, NULL);
*/
		// part DB
		m_pDbMD4Parts = new Db(m_pDbEnv, 0);
		m_pDbMD4Parts->set_pagesize(16 * 1024); // 16Kb page m_lSize
		m_pDbMD4Parts->open(NULL, FILES_DB, _T("MD4PartDB"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);

	}
	catch (DbRunRecoveryException &dbe)
	{
		TRACE(CString(dbe.what()));
		return false;
	}
	catch (DbException &dbe)
	{
		m_pDbServers = NULL;
//		m_pDbServersAddr = NULL;
//		m_pDbServersStatic = NULL;
//		m_pDbServersPriority = NULL;
		m_pDbEnv = NULL;
		TRACE("Problems create database objects: %s. Closing.\n", dbe.what());
		return false;
	}
	catch(...)
	{
		m_pDbServers = NULL;
//		m_pDbServersAddr = NULL;
//		m_pDbServersStatic = NULL;
//		m_pDbServersPriority = NULL;
		m_pDbEnv = NULL;
		TRACE("Problems create database objects. Closing.\n");
		return false;
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
d134 2
a135 1
		m_stLogger.Uninit();
a143 1
	CloseDatabases();
a145 65
void CEmEngine::CloseDatabases()
{
	try
	{
/*		if(m_pDbServersPriority)
		{
			m_pDbServersPriority->close(0);
			safe_delete(m_pDbServersPriority);
		}

		if(m_pDbServersStatic)
		{
			m_pDbServersStatic->close(0);
			safe_delete(m_pDbServersStatic);
		}

		if(m_pDbServersAddr)
		{
			m_pDbServersAddr->close(0);
			safe_delete(m_pDbServersAddr);
		}
*/
		if(m_pDbServers)
		{
			m_pDbServers->close(0);
			safe_delete(m_pDbServers);
		}

/*		//close file DB
		if(m_pDbFilesHash)
		{
			m_pDbFilesHash->close(0);
			safe_delete(m_pDbFilesHash);
		}
*/
		if(m_pDbFiles)
		{
			m_pDbFiles->close(0);
			safe_delete(m_pDbFiles);
		}

		if(m_pDbEnv)
		{
			m_pDbEnv->txn_checkpoint(0,0,0);
			m_pDbEnv->close(0);
			safe_delete(m_pDbEnv);
		}

		if(m_pDbMD4Parts)
		{
			m_pDbMD4Parts->close(0);
			safe_delete(m_pDbMD4Parts);
		}

	}
	catch(DbException &dbe)
	{
		TRACE("Problems delete database objects: %s.\n", dbe.what());
	}
	catch(...)
	{
		TRACE("Problems delete database objects.\n");
	}

}
a147 1
//	MOREVIT: Port is LONG why?
@


1.26
log
@There can be only one engine :-)
@
text
@d61 1
a61 1
	//	Try to initialize the Logger. If we fail...
d68 1
a68 1
	//	Initialize the Sockets TaskProcessor
d71 1
a71 1
		//	Initialize the TCP "Engine".		// MOREVIT - Too many engines in this thing.
d75 1
d82 1
a82 1
				AddDebugLogLine("Failed to initialize tcp engine");
@


1.25
log
@*** empty log message ***
@
text
@d13 1
d24 6
a29 11
	m_hStop(NULL),
	m_stMainTP(*this),
	m_stSocketsTP(*this),
	m_stTcp(*this),
	m_stLogger(*this),
	m_hWndUI(NULL),
	m_pDbServers(NULL),
	m_pDbServersAddr(NULL),
	m_pDbServersStatic(NULL),
	m_pDbServersPriority(NULL),
	m_pDbEnv(NULL)
d72 1
a72 1
			if (m_stTcp.Init())
d143 1
a143 1
		// Servers list - primary index by addr/port
d162 1
a162 1

d168 1
a168 1
		// files DB - secondary index by hash
d174 1
a174 1

d189 3
a191 3
		m_pDbServersAddr = NULL;
		m_pDbServersStatic = NULL;
		m_pDbServersPriority = NULL;
d199 3
a201 3
		m_pDbServersAddr = NULL;
		m_pDbServersStatic = NULL;
		m_pDbServersPriority = NULL;
d221 1
a221 1
		m_stTcp.Uninit(false);
d225 1
a225 1
		m_stTcp.Uninit(); // final
d242 1
a242 1
		if(m_pDbServersPriority)
d259 1
a259 1

d266 1
a266 1
		//close file DB
d272 1
a272 1

@


1.24
log
@Compilation fix
@
text
@d28 6
a33 1
	m_hWndUI(NULL)
d108 1
@


1.23
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d171 1
a171 1
		m_pDbFiles->associate(NULL, m_pDbFilesHash, CKnownFile::FileHashIndex, NULL);
@


1.22
log
@changed the way of data storage in file classes, add new classes
@
text
@d64 1
a64 1
			AddDebugLogLine(false, "Failed to initialize logger engine");
d80 1
a80 1
				AddDebugLogLine(false, "Failed to initialize tcp engine");
d87 1
a87 1
			AddDebugLogLine(false, "Failed to initialize sockets processor");
d93 1
a93 1
			AddDebugLogLine(false, "Failed to initialize main processor");
d100 1
a100 1
			AddDebugLogLine(false, "Failed to initialize filetype array");
d108 1
a108 1
		AddDebugLogLine(false, "CreateEvent failed");
d216 1
a216 1
			AddDebugLogLine(false, "SetEvent failed");
d229 1
a229 1
			AddDebugLogLine(false, "CloseHandle failed");
d347 1
a347 1
		AddDebugLogLine(false, _T("lookup for server failed"));
@


1.21
log
@index correction :) RTFM me
@
text
@d128 1
d173 4
d283 7
@


1.20
log
@Fix2
@
text
@d170 1
a170 1
		m_pDbFiles->associate(NULL, m_pDbFilesHash, CKnownFile::PrimaryIndex, NULL);
@


1.19
log
@Fix
@
text
@d167 1
a167 1
		m_pDbServersPriority->set_flags(DB_DUP | DB_DUPSORT);
@


1.18
log
@basic support of tags save into DB
@
text
@d165 4
a168 3
		// files DB - primary index by TAGs
		m_pDbFileTags = new Db(m_pDbEnv, 0);
		m_pDbFileTags->open(NULL, SERVERLIST_DB, _T("FileDB-Tags"), DB_BTREE, DB_CREATE | DB_THREAD | DB_AUTO_COMMIT, 0);
d170 1
a170 1
		m_pDbFiles->associate(NULL, m_pDbFileTags, CKnownFile::PrimaryIndex, NULL);
d260 1
a260 1
		if(m_pDbFileTags)
d262 2
a263 2
			m_pDbFileTags->close(0);
			safe_delete(m_pDbFileTags);
@


1.17
log
@filetype init
@
text
@a9 1
#include "Other/ed2k_filetype.h"
d15 2
d115 1
d159 13
d258 13
@


1.16
log
@Modified my modifications for better genericness (I like genericity but it's not in the dictionary :P ).
@
text
@d10 1
d95 7
d507 1
a507 1
*/@


1.15
log
@Modified code so Task caller can specify completion behavior.
@
text
@d267 2
a268 2
	CTask_LoginToServer	*pNextTask = new CTask_LoginToServer();
	CTask_Connect		*pTask = new CTask_Connect(sAddr, (USHORT) ulPort, T_CLIENT_SERVER, pNextTask);
@


1.14
log
@Formatting, comments, and name changes.
@
text
@d267 2
a268 1
	CTask_Connect		*pTask = new CTask_Connect(sAddr, (USHORT) ulPort, T_CLIENT_SERVER);
d407 1
d409 3
@


1.13
log
@Formatting, comments, and name changes.
@
text
@d65 1
a65 1
	//	Initialize the TaskProcessor sockets
d252 1
a252 2

//////////////////////////////////////////////////////////////////////
d259 2
a260 1
	if(GetServerSocket())
d262 1
d274 1
a274 2

//////////////////////////////////////////////////////////////////////
d280 1
a280 2

//////////////////////////////////////////////////////////////////////
d335 1
a335 2

//////////////////////////////////////////////////////////////////////
d339 3
a341 2
	// Export connection state
	switch(nConnectionState)
d343 24
a366 16
	case SERVER_DISCONNECTED:
		m_stServer.hSocket = NULL;
		m_stServer.nAddr = 0;
		m_stServer.nPort = 0;
		m_stServer.nClientID = 0;
		TRACE("CONNECTION STATE CHANGE: DISCONNECTED\n");
		break;
	case SERVER_CONNECTING:
		TRACE("CONNECTION STATE CHANGE: CONNECTING\n");
		break;
	case SERVER_WAITFORLOGIN:
		TRACE("CONNECTION STATE CHANGE: WAITING FOR LOGIN\n");
		break;
	case SERVER_CONNECTED:
		TRACE("CONNECTION STATE CHANGE: CONNECTED\n");
		break;
d369 1
a369 2

//////////////////////////////////////////////////////////////////////
@


1.12
log
@Formatting, comments, and name changes, the usual.
@
text
@d255 2
a256 1
void CEmEngine::ConnectToServer(CString sAddr, ULONG ulPort)
d265 3
a267 1
	CTask_Connect *pTask = new CTask_Connect(sAddr, (USHORT) ulPort, T_CLIENT_SERVER);
d278 1
a278 1
//	ConnectToServer();
d311 2
a312 1
	CTask_SendSharedList *pTask = new CTask_SendSharedList();
d321 2
a322 2
	return (m_stServer.nConnState == SERVER_CONNECTING || 
		m_stServer.nConnState == SERVER_WAITFORLOGIN); 
d373 1
a373 1
	m_stServer.nAddr = pClient->m_nAddr;
@


1.11
log
@*** empty log message ***
@
text
@d35 1
a35 1
//////////////////////////////////////////////////////////////////////
d55 1
d58 1
d65 1
d67 2
d74 2
a75 1
			} else
d81 1
d103 1
@


1.10
log
@New engine - cosmetic changes
@
text
@d25 1
d57 6
d187 1
d256 1
a256 1
	CTask_Connect *pTask = new CTask_Connect(sAddr, ulPort, T_CLIENT_SERVER);
@


1.9
log
@New engine - cosmetic changes
@
text
@d19 16
d243 2
a244 2
	if(m_stData.GetServerSocket())
		DisconnectFromServer(m_stData.GetServerSocket());
d249 1
a249 1
	m_stData.SetConnectionState(SERVER_CONNECTING);
d268 2
a269 2
		if(m_stData.GetServerSocket())
			DisconnectFromServer(m_stData.GetServerSocket());
d271 1
a271 1
			m_stData.SetConnectionState(SERVER_DISCONNECTED);
d297 172
@


1.8
log
@New engine - even more XML
@
text
@a5 1
#ifdef NEW_SOCKETS
a280 3


#endif@


1.7
log
@New engine - XML
@
text
@d40 1
a46 1
				return true;
d51 1
d56 8
a63 1
			AddDebugLogLine(false, "Failed to initialize main engine");
d65 2
d71 1
a72 2

	return false;
d162 1
a219 74
}

CString GetShortSuccessXml(ULONG ulId)
{
/*	bool bOk = true;
	CMuleXml xml;
	bOk &= xml.Create();
	bOk &= xml.CreateElement(_T("result"));
	bOk &= xml.SetAttribute(_T("id"), ulId);
	CString sXml = xml.GetXml();
	if(!bOk || sXml.IsEmpty())
		throw CString(_T("Can't create XML"));
	return sXml;*/
	return _T("");
//	TRACE("RETURN: %s (XML)\n", sXml2);
}


//////////////////////////////////////////////////////////////////////
// Parse XML command
// Each call to this function should be in separate thread,
// cause it won't return until command execution is finished.
// E.g. if you command to connect to server, it will return
// immediately - cause connection task is asynchronous,
// but if you will demand file or client list, it will wait until
// list is populated and only then return.
CString CEmEngine::ParseXmlCommand(CString sXml)
{
/*	try
	{
		CMuleXml xml;
		if(!xml.Load(sXml))
			throw CString(_T("Bad XML"));
		if(!xml.SelectNode(_T("./cmd")))
			throw CString(_T("Can't find <cmd> tag"));
		CString sCmd = xml.GetAttribute(_T("name"));
		if(sCmd.IsEmpty())
			throw CString(_T("Error reading \"name\" parameter of <cmd> tag"));
		ULONG ulId = _ttol(xml.GetAttribute(_T("id")));
		if(!ulId)
			throw CString(_T("Error reading \"id\" parameter of <cmd> tag"));


		///////////////////////////////////////////////////////////
		// Commands

		// Connect to server
		if(sCmd == _T("connect"))
		{
			CString sAddr = xml.GetAttribute(_T("addr"));
			if(sAddr.IsEmpty())
				throw CString(_T("Error reading \"addr\" parameter of \"connect\" command"));
			ULONG ulPort = _ttol(xml.GetAttribute(_T("port")));
			if(!ulPort)
				throw CString(_T("Error reading \"port\" parameter of \"connect\" command"));

			ConnectToServer(sAddr, ulPort);
			return GetShortSuccessXml(ulId);
		}

	}
	catch(CString &obj)
	{
		// should return <result id="0" error="..." />
		TRACE("ERROR: (XML) %s\n", obj);
		ASSERT(FALSE);
	}
	catch(...)
	{
		// should return <result id="0" error="bad xml" />
		TRACE("ERROR: (XML) Unknown\n");
		ASSERT(FALSE);
	}*/
	return _T("");
@


1.6
log
@New engine - connecting to server
@
text
@d17 1
a17 1
#include "Other/XML.h"
d214 1
a214 1
	bool bOk = true;
d222 2
a223 1
	return sXml;
d238 1
a238 1
	try
d282 1
a282 1
	}
@


1.5
log
@New engine - XML
@
text
@d212 15
d229 7
a235 1
void CEmEngine::ParseXmlCommand(CString sXml)
d246 22
a267 5
			throw CString(_T("Can't read \"name\" parameter of <cmd> tag"));
		long lId = _ttol(xml.GetAttribute(_T("id")));
		if(!lId)
			throw CString(_T("Can't read \"id\" parameter of <cmd> tag"));

a268 9
		CMuleXml xml2;
		if(!xml2.Create())
			throw CString(_T("Can't create XML"));
		if(!xml2.CreateElement(_T("result")))
			throw CString(_T("Can't create <result> tag"));
		if(!xml2.SetAttribute(_T("id"), lId))
			throw CString(_T("Can't set \"id\" parameter of <cmd> tag"));
		CString sXml2 = xml2.GetXml();
		TRACE("RETURN: %s (XML)\n", sXml2);
d273 2
a274 1
		TRACE("ERROR: %s (XML)\n", obj);
d279 2
a280 1
		TRACE("ERROR: unknown (XML)\n");
d282 1
a284 1

d286 2
a287 2
// connecting to given server (or any server, if pServer is NULL)
void CEmEngine::ConnectToServer(CServer* pServer /* = NULL */)
d291 2
a292 2
	if(m_stData.GetConnectingServer())
		DisconnectFromServer(m_stData.GetConnectingServer());
d294 4
a297 2
	CTask_Connect *pTask = new CTask_Connect(pServer);
	m_stData.SetConnectionState(false, SERVER_CONNECTING);
d307 1
a307 1
	ConnectToServer();
d316 2
a317 4
		if(m_stData.GetConnectingServer())
			DisconnectFromServer(m_stData.GetConnectingServer());
		else if(m_stData.GetConnectedServer())
			DisconnectFromServer(m_stData.GetConnectedServer());
d319 1
a319 1
			m_stData.SetConnectionState(false, SERVER_DISCONNECTED);
@


1.4
log
@New engine - XML
@
text
@d17 1
a17 1
#import "msxml.dll"
a211 18
MSXML::IXMLDOMNodePtr GetSingleNode(MSXML::IXMLDOMDocumentPtr pDoc, LPCTSTR sNodeName)
{
	MSXML::IXMLDOMNode *pResult;
	if(FAILED(pDoc->raw_selectSingleNode(bstr_t(sNodeName), &pResult)))
		return NULL;
	return MSXML::IXMLDOMNodePtr(pResult);
}

CString GetAttribute(MSXML::IXMLDOMNodePtr pNode, LPCTSTR sAttribName)
{
	MSXML::IXMLDOMNodePtr pName = pNode->attributes->getNamedItem(bstr_t(sAttribName));
	if(pName == NULL)
		return _T("");
	bstr_t bsResult = pName->text;
	return (LPCTSTR)bsResult;
}


d218 2
a219 4
		MSXML::IXMLDOMDocumentPtr pDoc;
		pDoc.CreateInstance(_T("msxml.domdocument"));
		pDoc->async = VARIANT_FALSE;
		if(pDoc->loadXML(bstr_t(sXml)) == VARIANT_FALSE)
d221 1
a221 2
		MSXML::IXMLDOMNodePtr pCmd = GetSingleNode(pDoc, _T("./cmd"));
		if(pCmd == NULL)
d223 1
a223 1
		CString sCmd = GetAttribute(pCmd, _T("name"));
d226 1
a226 1
		long lId = _ttol(GetAttribute(pCmd, _T("id")));
d229 11
@


1.3
log
@New engine
@
text
@d17 1
a17 2
//#include "../resource.h"
//#include "../server.h"
d211 52
@


1.2
log
@New engine - name changes
@
text
@d27 2
a28 2
//	CServer stSrv;
//	stSrv.ImportFromServerMet(*this, _T("./Db/server.met"));
d30 1
a30 5
/*	Dbc *pCursor;
	m_pDbServersAddr->cursor(NULL, &pCursor, 0);
	Dbt key, data;
	int nRet;
	while ((nRet = pCursor->get(&key, &data, DB_NEXT)) == 0)
d32 7
a38 6
		CServerPrimaryKey *pKey = (CServerPrimaryKey *)key.get_data();
		CServerData *pData = (CServerData *)data.get_data();
		int a = 0;
	}
	pCursor->close();
*/
@


1.1
log
@New engine
@
text
@d44 1
a44 1
		if (m_stMain.Init())
d156 1
a156 1
		m_stMain.Uninit();
d227 1
a227 1
	m_stMain.Push(pTask);
d254 1
a254 1
	CEmClient* pServer = m_stMain.Lookup(hPrevServer);
d262 1
a262 1
	m_stMain.Push(pTask);
d272 1
a272 1
	m_stMain.Push(pTask);
@

