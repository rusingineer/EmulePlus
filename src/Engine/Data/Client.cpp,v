head	1.14;
access;
symbols
	PublicRelease_1_2e:1.14
	Interim_Release_1-2e_RC1:1.14
	PublicRelease_1_2d:1.14
	Interim_Release_1-2d_RC1:1.14
	Interim_Release_1-2d_beta1:1.14
	PublicRelease_1_2c:1.14
	Interim_Release_1-2c_RC1:1.14
	Interim_Release_1-2c_beta1:1.14
	PublicRelease_1_2b:1.14
	Interim_Release_1-2b_RC1:1.14
	PublicRelease_1_2a:1.14
	Interim_Release_1-2a_RC1:1.14
	Interim_Release_1-2a_beta2:1.14
	Interim_Release_1-2a_beta1:1.14
	PublicRelease_1_2:1.14
	Interim_Release_1-2_RC1:1.14
	Interim_Release_1-2_beta1:1.14
	PublicRelease_1_1g:1.14
	Interim_Release_1-1g_RC3:1.14
	Interim_Release_1-1g_RC2:1.14
	Interim_Release_1-1g_RC1:1.14
	Interim_Release_1-1g_beta2:1.14
	Interim_Release_1-1g_beta1:1.14
	PublicRelease_1_1f:1.14
	Interim_Release_1-1f_RC1:1.14
	PublicRelease_1_1e:1.14
	Interim_Release_1-1e_RC2:1.14
	Interim_Release_1-1e_RC1:1.14
	Interim_Release_1-1e_beta1:1.14
	PublicRelease_1_1d:1.6
	Interim_Release_1-1d_RC1:1.3;
locks; strict;
comment	@// @;


1.14
date	2005.04.07.17.24.47;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.06.18.31.18;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.06.05.24.57;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.04.06.07.10;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.29.14.36.12;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.27.05.01.42;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.22.22.02.08;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.22.15.54.09;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.18.15.35.54;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.17.19.28.43;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.15.20.00.27;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.13.19.29.58;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.11.14.44.43;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.08.17.09.25;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.14
log
@v2 - fixes for upload logic
@
text
@// Client.cpp: implementation of the CClient class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ClientList.h"
#include "../Sockets/OpCode.h"
#include "../Sockets/TasksOpcodes.h"
#include "../Files/TaskProcessorFiles.h"

//////////////////////////////////////////////////////////////////////
CClient::CClient()
	:m_pParent(NULL)
	,m_bConnected(false)
	,m_uCountry(0)
	,m_sFullIP(_T(""))
	,m_sUserName(_T(""))
	,m_pReqFile(NULL)
	,m_eUploadState(US_NONE)
	,m_eDownloadState(DS_NONE)
{
	m_Addr.Addr = 0;
	m_Addr.Port = 0;
}

//////////////////////////////////////////////////////////////////////
CClient::~CClient()
{
}

//////////////////////////////////////////////////////////////////////
bool CClient::operator==(const AddrPort Addr)
{
	return (m_Addr.Addr == Addr.Addr && m_Addr.Port == Addr.Port);
}

//////////////////////////////////////////////////////////////////////
CClientMule::CClientMule(AddrPort Addr, HashType Hash)
{
	m_Addr.Addr = Addr.Addr;
	m_Addr.Port = Addr.Port;
	md4cpy(&m_Hash, &Hash);
	m_eClientSoft = SO_UNKNOWN;
}

//////////////////////////////////////////////////////////////////////
CClientMule::~CClientMule()
{
}

//////////////////////////////////////////////////////////////////////
bool CClientMule::operator==(const CClient* pClient)
{
	return false;
}

//////////////////////////////////////////////////////////////////////
bool CClientMule::operator==(const HashType Hash)
{
	return !md4cmp(&m_Hash, &Hash);
}

//////////////////////////////////////////////////////////////////////
void CClientMule::_PutMuleVersion(BYTE nMuleVersion)
{
	m_dwClientVersion = nMuleVersion;
	m_nCompatibleClient = (m_dwClientVersion >> 24);
	m_dwClientVersion &= 0x00FFFFFF;
	m_nEmuleVersion = 0x99;
//	m_fSupportsAskSharedDirs = 1;
}

//////////////////////////////////////////////////////////////////////
EnumClientTypes CClientMule::GetHashType()
{
	if (m_Hash.hash[5] == 14 && m_Hash.hash[14] == 111)
		return SO_EMULE;
	else if (m_Hash.hash[5] == 13 && m_Hash.hash[14] == 110)
		return SO_OLDEMULE;
	else if (m_Hash.hash[5] == 'M' && m_Hash.hash[14] == 'L')
		return SO_MLDONKEY;
	else
		return SO_UNKNOWN;
}

//////////////////////////////////////////////////////////////////////
void CClientMule::OnConnected()
{
	CClient::OnConnected();
}

//////////////////////////////////////////////////////////////////////
void CClientMule::OnDisconnected()
{
	CClient::OnDisconnected();
	// change state, take care of upload/download statuses, etc
}

//////////////////////////////////////////////////////////////////////
void CClientMule::RequestFile(CKnownFile* pFile)
{
	m_pReqFile = pFile;
	m_tmLastUpRequest = CPreciseTime::GetCurrentTime();

	// Add client to waiting queue
	g_stEngine.ClientList.AddToWaitingQueue(this);

	// Check requests limit and ban - CUpDownClient::AddRequestCount
}

//////////////////////////////////////////////////////////////////////
void CClientMule::RequestFileBlock(CKnownFile* pFile, DWORD dwStart, DWORD dwEnd)
{
	if(pFile)
	{
		// Check that we don't have already this request
		pair <RequestedBlocksMap::iterator, RequestedBlocksMap::iterator> 
			itRange = m_RequestedBlocks.equal_range(pFile);
		for(RequestedBlocksMap::iterator it = itRange.first; it != itRange.second; it++)
		{
			if(it->second.dwStart == dwStart && it->second.dwEnd == dwEnd)
				break;
		}
		// If not found, add it to the map
		m_RequestedBlocks.insert(BlocksMapPair(pFile, RequestRange(dwStart, dwEnd)));
	}
}

//////////////////////////////////////////////////////////////////////
bool CClientMule::SendNextBlockData(DWORD dwMaxSize, bool bPrioritized)
{
	RequestedBlocksMap::iterator it = m_RequestedBlocks.begin();
	// If we don't have blocks to send...
	if(it == m_RequestedBlocks.end())
		return false;

	CKnownFile* pFile	= it->first;
	DWORD dwStart		= it->second.dwStart;
	DWORD dwEnd			= it->second.dwEnd;
	if((dwEnd - dwStart) > dwMaxSize)
	{
		// Only cut [dwMaxSize] block from request
		dwEnd = dwStart + dwMaxSize;
		it->second.dwStart += dwMaxSize;
	}
	else
	{
		// Request completed and can be erased
		m_RequestedBlocks.erase(it);
	}
	CTask_SendBlock* pTask = new CTask_SendBlock(pFile, m_pParent, dwStart, dwEnd);
	if(pTask)
	{
		g_stEngine.Files.Push(pTask);
		m_LastUploadTime = CPreciseTime::GetCurrentTime();
	}
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

const UINT MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS = 2540;

//////////////////////////////////////////////////////////////////////
bool CClientMule::IsNeedMercyPacket()
{
	return (CPreciseTime::GetCurrentTime() - m_LastUploadTime) > MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS;
}

//////////////////////////////////////////////////////////////////////
void CClientMule::SendRankingInfo()
{
	if(!MuleProtocol)
		return;

	USHORT uRank = g_stEngine.ClientList.GetWaitingPosition(this);

	if (uRank == 0)
		return;

	COpCode_QUEUERANKING stMsg;
	stMsg._Rank = uRank;
	g_stEngine.SendOpCode(Parent->m_hSocket, stMsg, Parent, QUE_HIGH);
}


@


1.13
log
@v2 - upload works (basic implementation)
@
text
@d130 1
a130 1
BOOL CClientMule::SendNextBlockData(DWORD dwMaxSize, bool bPrioritized)
d135 1
a135 1
		return FALSE;
d153 1
d155 2
d160 9
a168 1
	return TRUE;
d184 1
a184 1
	g_stEngine.SendOpCode(Parent->m_hSocket, stMsg, Parent);
@


1.12
log
@v2 - more upload logic
@
text
@d8 2
d132 26
a157 2
	// move code from CTask_SendBlock implementation
	return FALSE;
@


1.11
log
@v2 - more upload logic
@
text
@d128 7
@


1.10
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d110 18
@


1.9
log
@v2 - minor improvements
@
text
@d6 1
a6 2
#include "../../otherfunctions.h"
#include "Client.h"
a7 2
#include "Prefs.h"

a125 214
//////////////////////////////////////////////////////////////////////
// ClientList
CClientList::CClientList()
{
}

//////////////////////////////////////////////////////////////////////
CClientList::~CClientList()
{
	for(ClientMap::iterator it = m_Clients.begin(); it != m_Clients.end(); it++)
	{
		CClient* pClient = (*it).first;
		if(pClient)
			delete pClient;
	}
	m_Clients.erase(m_Clients.begin(), m_Clients.end());
}

//////////////////////////////////////////////////////////////////////
void CClientList::AddClient(CClient* pClient)
{
	m_Clients[pClient] = true;
}

//////////////////////////////////////////////////////////////////////
void CClientList::RemoveClient(CClient* pClient)
{
}

//////////////////////////////////////////////////////////////////////
CClientMule* CClientList::FindMuleClient(AddrPort Addr)
{
	for(ClientMap::iterator it = m_Clients.begin(); it != m_Clients.end(); it++)
	{
		CClient* pClient = (*it).first;
		if(pClient && pClient->Type == CLIENT_MULE)
		{
			if(*pClient == Addr)
				return reinterpret_cast<CClientMule*>(pClient);
		}
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////
CClientMule* CClientList::FindMuleClient(HashType Hash)
{
	for(ClientMap::iterator it = m_Clients.begin(); it != m_Clients.end(); it++)
	{
		CClient* pClient = (*it).first;
		if(pClient && pClient->Type == CLIENT_MULE)
		{
			CClientMule* pMule = reinterpret_cast<CClientMule*>(pClient);
			if(*pMule == Hash)
				return pMule;
		}
	}
	return NULL;
}

//////////////////////////////////////////////////////////////////////
bool CClientList::IsValidClient(CClient* pClient)
{
	return (m_Clients.find(pClient) != m_Clients.end());
}

//////////////////////////////////////////////////////////////////////
void CClientList::AddToWaitingQueue(CClient* pClient)
{
	if(pClient && pClient->Type == CLIENT_MULE)
	{
		CClientMule* pMule = reinterpret_cast<CClientMule*>(pClient);

		// Filtering invalid eMule clients
		if(pMule->MuleVersion == 0 && pMule->ClientVersion == 0 &&
			(pMule->ClientSoft == SO_EMULE || pMule->ClientSoft == SO_PLUS || pMule->ClientSoft == SO_OLDEMULE))
		{
			AddLog(LOG_DEBUG, _T("Client (%s:%d) was filtered as invalid"), inet_ntoa(pMule->ClientAddr), pMule->ClientPort);
			return;
		}

		// If we're already uploading to that client, it probably asks for another file
		if(pMule->UploadState == US_UPLOADING && pMule->Parent)
		{
			COpCode_ACCEPTUPLOADREQ stMsg;
			g_stEngine.SendOpCode(pMule->Parent->m_hSocket, stMsg, pMule->Parent);
			AddLog(LOG_DEBUG, _T("Client (%s:%d) is already downloading from us, accept request"), inet_ntoa(pMule->ClientAddr), pMule->ClientPort);
			return;
		}

		// Add to queue
		m_Waiting[pClient] = true;

		AddLog(LOG_DEBUG, _T("Client (%s:%d) has been added to waiting queue"), inet_ntoa(pMule->ClientAddr), pMule->ClientPort);

		// Set states
		pMule->UploadState = US_ONUPLOADQUEUE;
		pMule->WaitStartTime = CPreciseTime::GetCurrentTime();

		// Send ranking info back to client
		pMule->SendRankingInfo();
	}
}

//////////////////////////////////////////////////////////////////////
bool CClientList::RemoveFromWaitingQueue(CClient* pClient)
{
	if(pClient == NULL)
		return false;
	ClientMap::iterator it = m_Waiting.find(pClient);
	if(it != m_Waiting.end())
	{
		AddLog(LOG_DEBUG, _T("Client (%s:%d) has been removed from waiting queue"), inet_ntoa(pClient->ClientAddr), pClient->ClientPort);
		m_Waiting.erase(it);
		return true;
	}
	else
		AddLog(LOG_ERROR, _T("Can't find client (%s:%d) to remove from waiting queue"), inet_ntoa(pClient->ClientAddr), pClient->ClientPort);
	return false;
}

//////////////////////////////////////////////////////////////////////
int CClientList::GetWaitingPosition(CClientMule* pClient)
{
//	if (!IsOnUploadQueue(client))
//		return 0;

	USHORT uRank = 1;

/*	if (client->IsBanned())
	{
		uRank = waitinglist.GetCount();
	}
	else*/
	{
		int nClientScore = pClient->Score;

		for(ClientMap::iterator it = m_Waiting.begin(); it != m_Waiting.end(); it++)
		{
			CClient* pClient = (*it).first;
			if(pClient && pClient->Type == CLIENT_MULE)
			{
				CClientMule* pMule = reinterpret_cast<CClientMule*>(pClient);
				if(pMule->Score > nClientScore)
					uRank++;
			}
		}
	}
	return uRank;
}

//////////////////////////////////////////////////////////////////////
void CClientList::PurgeBadClients()
{
	for(ClientMap::iterator it = m_Waiting.begin(); it != m_Waiting.end();)
	{
		CClient* pClient = (*it).first;
		if(CPreciseTime::GetCurrentTime() - pClient->LastUploadRequest > MAX_PURGEQUEUETIME)
//			|| !g_stEngine.SharedFiles.GetFileByID(pClient->ReqFile) )
		{
			RemoveFromWaitingQueue(pClient);
			if(pClient->Parent)
				g_stEngine.Sockets.KillClient(pClient->Parent);

			it = m_Waiting.begin();
		}
		else
			it++;
	}
}

//////////////////////////////////////////////////////////////////////
void CClientList::CheckAcceptNewClient()
{
	if (m_Waiting.size() > 0 && 
		m_Uploading.size() < MAX_UP_CLIENTS_ALLOWED &&
		m_Uploading.size() < g_stEngine.Prefs.MaxUploadSlots)
	{
//		if (g_eMuleApp.m_pListenSocket->TooManySockets())
//			return;

		// Find best rating client
		CClientMule* pFound = NULL;
		for(ClientMap::iterator it = m_Waiting.begin(); it != m_Waiting.end(); it++)
		{
			CClient* pClient = (*it).first;
			if(pClient && pClient->Type == CLIENT_MULE)
			{
				CClientMule* pMule = reinterpret_cast<CClientMule*>(pClient);
				if(pFound == NULL || pMule->Score > pFound->Score)
					pFound = pMule;
			}
		}
		if(pFound)
		{
			RemoveFromWaitingQueue(pFound);
			if(pFound->Parent)
			{
				// If we're already connected
				COpCode_ACCEPTUPLOADREQ stMsg;
				g_stEngine.SendOpCode(pFound->Parent->m_hSocket, stMsg, pFound->Parent);
				pFound->UploadState = US_UPLOADING;
			}
			else
			{
				pFound->UploadState = US_CONNECTING;
				// Try to connect to this client
				// CUpDownClient::TryToConnect
			}
			AddLog(LOG_DEBUG, _T("Client (%s:%d) has been added to uploading queue, %s"), inet_ntoa(pFound->ClientAddr), pFound->ClientPort, pFound->UploadState == US_CONNECTING ? _T("connecting") : _T("uploading"));
			m_Uploading[pFound] = true;
		}
	}
}
@


1.8
log
@v2 - enhancing logging subsystem
@
text
@d206 1
d214 2
a215 1
			g_stEngine.SendOpCode(pClient->Parent->m_hSocket, stMsg, pClient->Parent);
d222 2
d241 1
d245 2
d338 1
@


1.7
log
@v2 - more upload logic
@
text
@d9 1
d210 1
a210 1
		if(pMule->UploadState == US_UPLOADING)
d274 20
d296 3
a298 1
	if(m_Waiting.size() > 0)
d300 33
@


1.6
log
@v2 - more upload logic
@
text
@d8 1
d19 2
d108 17
a124 1
	// Check requests, etc - CUpDownClient::AddRequestCount
d208 9
d218 7
d241 38
@


1.5
log
@v2 - minor improvements
@
text
@d12 2
a13 1
	:m_bConnected(false)
d99 3
@


1.4
log
@v2 - little improvements
@
text
@d9 2
d22 1
d27 1
d33 1
d42 1
d47 1
d53 1
d59 1
d69 1
d82 1
d88 1
d95 9
d105 1
d111 1
d123 1
d129 1
d134 1
d149 1
d165 1
d171 1
d189 1
@


1.3
log
@v2 - little improvements
@
text
@d34 1
d51 1
a51 1
void CClientMule::_PutMuleVersion(DWORD dwMuleVersion)
d53 1
a53 1
	m_dwClientVersion = dwMuleVersion;
d114 1
a114 1
		if(pClient && pClient->ClientType() == CLIENT_MULE)
d128 1
a128 1
		if(pClient && pClient->ClientType() == CLIENT_MULE)
d142 30
@


1.2
log
@v2 - more improvements
@
text
@d10 2
a11 1
	:m_uCountry(0)
d71 13
a94 1
		m_Clients.erase(m_Clients.begin(), m_Clients.end());
d96 1
@


1.1
log
@v2 - minor rearrangements, started defining client and clientlist
@
text
@d13 1
d23 4
a43 5
bool CClientMule::operator==(const AddrPort Addr)
{
	return (m_Addr.Addr == Addr.Addr && m_Addr.Port == Addr.Port);
}

d76 1
a76 1
	while(m_Clients.size() > 0)
d78 1
a78 2
		CClient* pClient = m_Clients.back();
		m_Clients.pop_back();
d81 1
d87 1
a87 1
	m_Clients.push_back(pClient);
d96 1
a96 1
	for(UINT i = 0; i < m_Clients.size(); i++)
d98 1
a98 1
		CClient* pClient = m_Clients[i];
d101 2
a102 3
			CClientMule* pMule = reinterpret_cast<CClientMule*>(pClient);
			if(*pMule == Addr)
				return pMule;
d110 1
a110 1
	for(UINT i = 0; i < m_Clients.size(); i++)
d112 1
a112 1
		CClient* pClient = m_Clients[i];
d122 5
@

