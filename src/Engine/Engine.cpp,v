head	1.11;
access;
symbols
	PublicRelease_1_2e:1.11
	Interim_Release_1-2e_RC1:1.11
	PublicRelease_1_2d:1.11
	Interim_Release_1-2d_RC1:1.11
	Interim_Release_1-2d_beta1:1.11
	PublicRelease_1_2c:1.11
	Interim_Release_1-2c_RC1:1.11
	Interim_Release_1-2c_beta1:1.11
	PublicRelease_1_2b:1.11
	Interim_Release_1-2b_RC1:1.11
	PublicRelease_1_2a:1.11
	Interim_Release_1-2a_RC1:1.11
	Interim_Release_1-2a_beta2:1.11
	Interim_Release_1-2a_beta1:1.11
	PublicRelease_1_2:1.11
	Interim_Release_1-2_RC1:1.11
	Interim_Release_1-2_beta1:1.11
	PublicRelease_1_1g:1.11
	Interim_Release_1-1g_RC3:1.11
	Interim_Release_1-1g_RC2:1.11
	Interim_Release_1-1g_RC1:1.11
	Interim_Release_1-1g_beta2:1.11
	Interim_Release_1-1g_beta1:1.11
	PublicRelease_1_1f:1.11
	Interim_Release_1-1f_RC1:1.11
	PublicRelease_1_1e:1.11
	Interim_Release_1-1e_RC2:1.11
	Interim_Release_1-1e_RC1:1.11
	Interim_Release_1-1e_beta1:1.11
	PublicRelease_1_1d:1.11
	Interim_Release_1-1d_RC1:1.11
	PublicRelease_1_1c:1.11
	Interim_Release_1-1c_RC1:1.11
	Interim_Release_1-1c_beta2:1.11
	Interim_Release_1-1c_beta1:1.9
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.8
	PublicRelease_1_1a:1.8
	Interim_Release_1-1a_RC2:1.8
	Interim_Release_1-1a_RC1:1.8
	Interim_Release_1-1a_beta2:1.8
	Interim_Release_1-1a_beta1:1.8
	PublicRelease_1_1:1.8
	Interim_Release_1-1_beta1:1.8
	PublicRelease_1o:1.8
	Interim_Release_1o_RC1:1.8
	Interim_Release_1o_beta1:1.8
	PublicRelease_1n:1.8
	Interim_Release_1n_RC2:1.8
	Interim_Release_1n_RC1:1.8
	PublicRelease_1m:1.8
	Interim_Release_1m_beta1:1.8
	PublicRelease_1l:1.8
	Interim_Release_1l_RC3:1.8
	Interim_Release_1l_RC2:1.8
	Interim_Release_1l_RC1:1.8
	Interim_Release_1l_beta2:1.8
	Interim_Release_1l_beta1:1.8
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.7
	Interim_Release_1J_RC3:1.7
	Interim_Release_1j_RC3:1.7
	Interim_Release_1j_RC2:1.7
	Interim_Release_1j_RC1:1.7
	Interim_Release_1j_beta2:1.7
	Interim_Release_1j_beta1:1.7;
locks; strict;
comment	@// @;


1.11
date	2005.02.05.13.57.11;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.03.15.14.15;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.26.15.45.32;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.05.19.31.57;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.22.16.34.49;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.21.14.01.37;	author forcha;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.15.14.47.32;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.11.15.26.01;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.11.14.32.48;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.10.14.49.57;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Connecting preferences and known/shared files
@
text
@// Engine.cpp : main source file for Engine.exe
//

#include "stdafx.h"
/*
#include <atlframe.h>
#include <atlctrls.h>
#include <atldlgs.h>

CAppModule _Module;
*/
#include "resource.h"

#include "EmEngine.h"

CEmEngine g_stEngine;
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int Run(LPTSTR lpstrCmdLine = NULL, int nCmdShow = SW_SHOWDEFAULT)
{
	CMessageLoop theLoop;
	_Module.AddMessageLoop(&theLoop);

	if(!g_stEngine.Init(NULL))
		return -1;

	int nRet = theLoop.Run();

	g_stEngine.Uninit();

	_Module.RemoveMessageLoop();
	return nRet;
}
*/
int Run()
{
	BOOL bRet;
	MSG msg;

	for(;;)
	{
		bRet = ::GetMessage(&msg, NULL, 0, 0);

		if(bRet == -1)
			continue;   // error, don't process
		else if(!bRet)
			break;   // WM_QUIT, exit message loop

		::TranslateMessage(&msg);
		::DispatchMessage(&msg);
	}

	return (int)msg.wParam;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpstrCmdLine, int nCmdShow)
{
	HRESULT hRes = ::CoInitialize(NULL);

//	If you are running on NT 4.0 or higher you can use the following call instead to 
//	make the EXE free threaded. This means that calls come in on a random RPC thread.
//	HRESULT hRes = ::CoInitializeEx(NULL, COINIT_MULTITHREADED);
	ASSERT(SUCCEEDED(hRes));

/*
//	This resolves ATL window thunking problem when Microsoft Layer for Unicode (MSLU) is used
//	(I thunk, he thank, we're gethunken?)
	::DefWindowProc(NULL, 0, 0, 0L);

	AtlInitCommonControls(ICC_BAR_CLASSES);	// Add flags to support other controls

	hRes = _Module.Init(NULL, hInstance);
	ATLASSERT(SUCCEEDED(hRes));

	int nRet = Run(lpstrCmdLine, nCmdShow);

	_Module.Term();
*/
	if(!g_stEngine.Init())
		return -1;
	int nRet = Run();
	g_stEngine.Uninit();

	::CoUninitialize();

	return nRet;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.10
log
@Ideological switch (may be considered as temporary, but for long term) - ATL to MFC
Actually we don't need them both, but I want to work with our current KnownFile-based classes, which use MFC a lot
@
text
@d80 1
a80 1
	if(!g_stEngine.Init(NULL))
@


1.9
log
@Rearrangements
@
text
@d5 1
a5 1

d10 2
a15 2
CAppModule _Module;

d17 1
a17 1

d19 1
a19 1
int Run(LPTSTR /*lpstrCmdLine*/ = NULL, int nCmdShow = SW_SHOWDEFAULT)
d34 22
d57 1
a57 1
int WINAPI _tWinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPTSTR lpstrCmdLine, int nCmdShow)
d60 1
d64 1
a64 1
	ATLASSERT(SUCCEEDED(hRes));
d66 1
d79 6
@


1.8
log
@Formatting, comments, and name changes, the usual.
@
text
@a17 2
#include ".\GUI\MainDlg.h"

a26 10
	CMainDlg dlgMain;

	if(dlgMain.Create(NULL) == NULL)
	{
		ATLTRACE(_T("Main dialog creation failed!\n"));
		return 0;
	}

	dlgMain.ShowWindow(SW_HIDE/*nCmdShow*/);

@


1.7
log
@New engine - XML
@
text
@d20 1
d46 1
a46 1

d50 2
a51 2
// If you are running on NT 4.0 or higher you can use the following call instead to 
// make the EXE free threaded. This means that calls come in on a random RPC thread.
d55 2
a56 1
	// this resolves ATL window thunking problem when Microsoft Layer for Unicode (MSLU) is used
d59 1
a59 1
	AtlInitCommonControls(ICC_BAR_CLASSES);	// add flags to support other controls
d71 1
@


1.6
log
@gui
@
text
@a11 2
#include ".\GUI\MainDlg.h"

d17 2
@


1.5
log
@New engine
@
text
@d12 1
a12 1
#include "MainDlg.h"
@


1.4
log
@New engine - server classes, database
@
text
@d14 1
a14 1
#include "../Sockets/EmEngine.h"
@


1.3
log
@New engine - database added
@
text
@d25 2
a26 1
	g_stEngine.Init(NULL);
@


1.2
log
@New engine
@
text
@d25 2
@


1.1
log
@New engine
@
text
@d14 2
d18 2
d36 2
@

