head	1.14;
access;
symbols
	PublicRelease_1_2e:1.14
	Interim_Release_1-2e_RC1:1.14
	PublicRelease_1_2d:1.14
	Interim_Release_1-2d_RC1:1.14
	Interim_Release_1-2d_beta1:1.14
	PublicRelease_1_2c:1.14
	Interim_Release_1-2c_RC1:1.14
	Interim_Release_1-2c_beta1:1.14
	PublicRelease_1_2b:1.14
	Interim_Release_1-2b_RC1:1.14
	PublicRelease_1_2a:1.14
	Interim_Release_1-2a_RC1:1.14
	Interim_Release_1-2a_beta2:1.14
	Interim_Release_1-2a_beta1:1.14
	PublicRelease_1_2:1.14
	Interim_Release_1-2_RC1:1.14
	Interim_Release_1-2_beta1:1.14
	PublicRelease_1_1g:1.14
	Interim_Release_1-1g_RC3:1.14
	Interim_Release_1-1g_RC2:1.14
	Interim_Release_1-1g_RC1:1.14
	Interim_Release_1-1g_beta2:1.14
	Interim_Release_1-1g_beta1:1.14
	PublicRelease_1_1f:1.14
	Interim_Release_1-1f_RC1:1.14
	PublicRelease_1_1e:1.14
	Interim_Release_1-1e_RC2:1.14
	Interim_Release_1-1e_RC1:1.14
	Interim_Release_1-1e_beta1:1.14
	PublicRelease_1_1d:1.12
	Interim_Release_1-1d_RC1:1.12
	PublicRelease_1_1c:1.12
	Interim_Release_1-1c_RC1:1.12
	Interim_Release_1-1c_beta2:1.10
	Interim_Release_1-1c_beta1:1.10
	PublicRelease_1_1b:1.7
	Interim_Release_1-1b_RC1:1.7
	PublicRelease_1_1a:1.7
	Interim_Release_1-1a_RC2:1.7
	Interim_Release_1-1a_RC1:1.7
	Interim_Release_1-1a_beta2:1.7
	Interim_Release_1-1a_beta1:1.7
	PublicRelease_1_1:1.7
	Interim_Release_1-1_beta1:1.7
	PublicRelease_1o:1.7
	Interim_Release_1o_RC1:1.7
	Interim_Release_1o_beta1:1.7
	PublicRelease_1n:1.7
	Interim_Release_1n_RC2:1.7
	Interim_Release_1n_RC1:1.7
	PublicRelease_1m:1.6
	Interim_Release_1m_beta1:1.6
	PublicRelease_1l:1.6
	Interim_Release_1l_RC3:1.6
	Interim_Release_1l_RC2:1.6
	Interim_Release_1l_RC1:1.6
	Interim_Release_1l_beta2:1.6
	Interim_Release_1l_beta1:1.6
	PublicRelease_1k:1.6
	Interim_Release_1k_RC4:1.6
	Interim_1k_RC3:1.6
	Interim_1k_RC2:1.6
	Interim_Release_1k_RC1:1.6
	Interim_Release_1k_beta5:1.6
	Intrerim_Release_1k_beta4:1.6
	Interim_Release_1k_beta1:1.6
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.1;
locks; strict;
comment	@// @;


1.14
date	2005.04.08.14.16.36;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.22.22.02.09;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.23.19.35.29;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.23.18.57.47;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.28.20.13.52;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.29.16.04.22;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.30.13.39.02;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.07.11.31.47;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.05.19.31.57;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.07.09.17.54;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.06.11.13.13;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.14
log
@v2 - more abstraction + logic
@
text
@// TaskProcessor.cpp: implementation of the CTaskProcessor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TaskProcessor.h"
#include <process.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTaskProcessor::Init()
{
	Uninit(); // if already initialized

//	Initialize the Task Queue. If successful...
	if (m_queueTasks.Init())
	{
	//	Create an Event which can be asserted to stop the processor. If successful...
		if (m_hStop = CreateEvent(NULL, TRUE, FALSE, NULL))
		{
			THREAD_INIT_PARAM		stParam;

			stParam.m_pThis = this;
			stParam.m_bInitResult = false;
		//	Create an Event which, when asserted, will signal that the thread is initialized.
		//	If successful...
			if (stParam.m_hInitEvent = CreateEvent(NULL, TRUE, FALSE, NULL))
			{
				UINT nThread = 0;

				if (m_hThread = (HANDLE) _beginthreadex(NULL, 0, ProcessingFunc, &stParam, 0, &nThread))
				{
					DWORD dwRes = WaitForSingleObject(stParam.m_hInitEvent, m_dwStartupTimeout);

					if (WAIT_OBJECT_0 == dwRes)
					{
						if (stParam.m_bInitResult)
							return true;
						else
							AddLog(LOG_ERROR, _T("Task processor failed to initialize"));
					}
					else
					{
						if (WAIT_TIMEOUT == dwRes)
							AddLog(LOG_ERROR, _T("Task processor initialization timed out"));
						else
							AddLog(LOG_ERROR, _T("WaitForSingleObject failed"));
					}
				} 
				else
					AddLog(LOG_ERROR, _T("_beginthreadex failed"));
			} 
			else
				AddLog(LOG_ERROR, _T("CreateEvent failed"));
		} 
		else
			AddLog(LOG_ERROR, _T("CreateEvent failed"));
	}
	else
		AddLog(LOG_ERROR, _T("Failed to create the queue"));

	Uninit();
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// destruction
void CTaskProcessor::Uninit()
{
	if (m_hStop)
	{
		if (m_hThread)
		{
			if (!SetEvent(m_hStop))
				AddLog(LOG_ERROR, _T("SetEvent failed"));

			if (WAIT_TIMEOUT == WaitForSingleObject(m_hThread, 2000))
			{
				AddLog(LOG_ERROR, _T("Failed to uninitialize. Terminating"));
				if (!TerminateThread(m_hThread, -1))
					AddLog(LOG_ERROR, _T("TerminateThread failed"));
			}

			if (!CloseHandle(m_hThread))
				AddLog(LOG_ERROR, _T("CloseHandle failed"));
			m_hThread = NULL;
		}

		if (!CloseHandle(m_hStop))
			AddLog(LOG_ERROR, _T("CloseHandle failed"));

		m_hStop = NULL;
	}
	m_queueTasks.Uninit();
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// processing
UINT WINAPI CTaskProcessor::ProcessingFunc(PVOID pPtr)
{
	THREAD_INIT_PARAM* pParam = (THREAD_INIT_PARAM*)pPtr;

	if (pParam != NULL)
	{
		CoInitialize(NULL);

		CTaskProcessor*	pThis = pParam->m_pThis;
		bool			bRes  = pParam->m_bInitResult = pThis->Start();

		SetEvent(pParam->m_hInitEvent);

		if (bRes)
		{
			for (DWORD dwWaitLast = GetTickCount(); ; )
			{
				DWORD dwWait = INFINITE;

			//	If a timeout has been specified...
				if (INFINITE != pThis->m_dwWaitTimeout)
				{
					DWORD dwElapsed = GetTickCount() - dwWaitLast;

				//	If less than the timeout period has elapsed...
					if (dwElapsed < pThis->m_dwWaitTimeout)
					{
						dwWait = pThis->m_dwWaitTimeout - dwElapsed;
					}
					else
					{
						pThis->ProcessTimeout();
						dwWaitLast = GetTickCount();
						dwWait = pThis->m_dwWaitTimeout;
					}
				}
			//	MOREVIT: Ah grasshopper. Completely inscrutable are we? Is it really helpful to hide the 
			//		synchronization code this way?

			//	Get the next Task or wait up to 'dwWait' milliseconds for one to become available or for
			//		the processor to be stopped.
				CTask* pTask = pThis->m_queueTasks.PopEx(pThis->m_hStop, dwWait); 

			//	If the processor hasn't been stopped and a Task became available before the timeout...
				if (pTask != NULL)
				{
					pThis->m_pCurrent = pTask;
					if (pThis->ProcessTask(*pTask))
					{
						delete pTask;
					}
					pThis->m_pCurrent = NULL;
				}
				else
				{
					if (g_stEngine.IsShuttingDown())
						break; // finished!
				}
			}
		}

		pThis->Stop();
	}
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// those functions are defined in child classes
bool CTaskProcessor::Start()
{
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTaskProcessor::Stop()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTaskProcessor::ProcessTimeout()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// process single task
bool CTaskProcessor::ProcessTask(CTask& stTask)
{
	TCHAR strTaskName[100];
	try
	{
		_tcscpy(strTaskName, stTask.TaskName());
		return stTask.Process();
	}
	catch (_com_error& e)
	{
		AddLog(LOG_ERROR, _T("ATL Exception while processing task: Source=%s; Description=%s"), (LPCTSTR) e.Source(), (PCTSTR) e.Description());
	}
	catch (...)
	{
		AddLog(LOG_ERROR, _T("Unhandled exception while processing task %s"), strTaskName);
	}

	try
	{
		// give it another chance
		return stTask.OnException();
	}
	catch(_com_error& e)
	{
		AddLog(LOG_ERROR, _T("Second ATL exception while processing task: Source=%s; Description=%s"), (LPCTSTR) e.Source(), (PCTSTR) e.Description());
	}
	catch (...)
	{
		AddLog(LOG_ERROR, _T("Second unhandled exception while processing task %s"), strTaskName);
	}

	return true; // delete this buggy task!
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.13
log
@v2 - enhancing logging subsystem
@
text
@d192 1
a192 1
		AddLog(LOG_ERROR, _T("ATL Exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
d206 1
a206 1
		AddLog(LOG_ERROR, _T("Second ATL exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
@


1.12
log
@v2 - updated protocol, need to fix packed protocol
@
text
@d32 1
a32 1
				UINT		nThread = 0;
d36 1
a36 1
					DWORD		dwRes = WaitForSingleObject(stParam.m_hInitEvent, m_dwStartupTimeout);
a40 1
						{
a41 1
						}
d43 1
a43 4
						{
							ASSERT(FALSE);
							AddDebugLogLine("Task processor failed to initialize");
						}
d48 1
a48 4
						{
							ASSERT(FALSE);
							AddDebugLogLine("Task processor initialization timed out");
						}
d50 1
a50 4
						{
							ASSERT(FALSE);
							AddDebugLogLine("WaitForSingleObject failed");
						}
d54 1
a54 5
				{
					ASSERT(FALSE);
					AddDebugLogLine("_beginthreadex failed");
				}

d57 1
a57 5
			{
				ASSERT(FALSE);
				AddDebugLogLine("CreateEvent failed");
			}

d60 1
a60 4
		{
			ASSERT(FALSE);
			AddDebugLogLine("CreateEvent failed");
		}
d63 1
a63 4
	{
		ASSERT(FALSE);
		AddDebugLogLine("Failed to create the queue");
	}
d77 1
a77 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("SetEvent failed");
			}
d81 1
a81 2
				ASSERT(FALSE);
				AddDebugLogLine("Failed to uninitialize. Terminating");
d83 1
a83 1
					AddDebugLogLine("TerminateThread failed");
d87 1
a87 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("CloseHandle failed");
			}
d92 2
a93 4
		{
			ASSERT(FALSE);
			AddDebugLogLine("CloseHandle failed");
		}
d103 1
a103 1
	THREAD_INIT_PARAM	*pParam = (THREAD_INIT_PARAM*)pPtr;
d109 2
a110 2
		CTaskProcessor		*pThis = pParam->m_pThis;
		bool				bRes = pParam->m_bInitResult = pThis->Start();
d118 1
a118 1
				DWORD		dwWait = INFINITE;
d123 1
a123 1
					DWORD		dwElapsed = GetTickCount() - dwWaitLast;
d142 1
a142 1
				CTask		*pTask = pThis->m_queueTasks.PopEx(pThis->m_hStop, dwWait); 
d192 1
a192 2
		ASSERT(FALSE);
		AddDebugLogLine(_T("ATL Exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
d196 1
a196 2
		ASSERT(FALSE);
		AddDebugLogLine("Unhandled exception while processing task %s", strTaskName);
d206 1
a206 2
		ASSERT(FALSE);
		AddDebugLogLine(_T("Second ATL exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
d210 1
a210 2
		ASSERT(FALSE);
		AddDebugLogLine("Second unhandled exception while processing task %s", strTaskName);
@


1.11
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d221 1
a221 1
		_tccpy(strTaskName, stTask.TaskName());
@


1.10
log
@Xml and database functionality
@
text
@d218 1
d221 1
d232 1
a232 1
		AddDebugLogLine("Unhandled exception while processing task");
d248 1
a248 1
		AddDebugLogLine("Second unhandled exception while processing task");
@


1.9
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@a5 1
#include "EmEngine.h"
@


1.8
log
@There can be only one engine :-)
@
text
@d6 1
a6 1

d37 1
a37 1
					DWORD		dwRes = WaitForSingleObject(stParam.m_hInitEvent, 1000);
@


1.7
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a7 1
#include "EmEngine.h"
d191 1
a191 1
					if (pThis->m_stEngine.IsShuttingDown())
d221 1
a221 1
		return stTask.Process(m_stEngine);
d237 1
a237 1
		return stTask.OnException(m_stEngine);
@


1.6
log
@Modified code so Task caller can specify completion behavior.
@
text
@d49 1
a49 1
							AddDebugLogLine(false, "Task processor failed to initialize");
d57 1
a57 1
							AddDebugLogLine(false, "Task processor initialization timed out");
d62 1
a62 1
							AddDebugLogLine(false, "WaitForSingleObject failed");
d69 1
a69 1
					AddDebugLogLine(false, "_beginthreadex failed");
d76 1
a76 1
				AddDebugLogLine(false, "CreateEvent failed");
d83 1
a83 1
			AddDebugLogLine(false, "CreateEvent failed");
d89 1
a89 1
		AddDebugLogLine(false, "Failed to create the queue");
d106 1
a106 1
				AddDebugLogLine(false, "SetEvent failed");
d112 1
a112 1
				AddDebugLogLine(false, "Failed to uninitialize. Terminating");
d114 1
a114 1
					AddDebugLogLine(false, "TerminateThread failed");
d120 1
a120 1
				AddDebugLogLine(false, "CloseHandle failed");
d128 1
a128 1
			AddDebugLogLine(false, "CloseHandle failed");
d227 1
a227 1
		AddDebugLogLine(false, _T("ATL Exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
d232 1
a232 1
		AddDebugLogLine(false, "Unhandled exception while processing task");
d243 1
a243 1
		AddDebugLogLine(false, _T("Second ATL exception while processing task: Source=%s; Description=%s"), (PCTSTR) e.Source(), (PCTSTR) e.Description());
d248 1
a248 1
		AddDebugLogLine(false, "Second unhandled exception while processing task");
@


1.5
log
@Formatting, comments, and name changes.
@
text
@d9 1
@


1.4
log
@Formatting, comments, and name changes, the usual.
@
text
@d94 1
a94 2

//////////////////////////////////////////////////////////////////////
d155 1
d160 1
d172 2
d175 2
d179 1
d207 1
a207 1

d211 1
a211 1

d215 1
a215 2

//////////////////////////////////////////////////////////////////////
d252 1
@


1.3
log
@New engine - cosmetic changes
@
text
@d14 1
d19 1
d21 2
d25 2
a26 1
			THREAD_INIT_PARAM stParam;
d29 2
d33 2
a34 1
				UINT nThread = 0;
d37 2
a38 1
					DWORD dwRes = WaitForSingleObject(stParam.m_hInitEvent, 1000);
d40 1
d42 1
d44 1
d50 1
d52 1
d63 1
d84 1
d135 1
a135 1
//////////////////////////////////////////////////////////////////////
d139 3
a141 2
	THREAD_INIT_PARAM* pParam = (THREAD_INIT_PARAM*) pPtr;
	if (pParam)
d145 3
a147 2
		CTaskProcessor* pThis = pParam->m_pThis;
		bool bRes = pParam->m_bInitResult = pThis->Start();
d151 1
d154 2
a155 1
				DWORD dwWait = INFINITE;
d158 2
a159 1
					DWORD dwElapsed = GetTickCount() - dwWaitLast;
d161 1
d163 1
d172 3
a174 2
				CTask* pTask = pThis->m_queueTasks.PopEx(pThis->m_hStop, dwWait); 
				if (pTask)
d178 1
d180 1
d184 1
d187 1
a187 1

d189 1
d195 1
a195 2

//////////////////////////////////////////////////////////////////////
@


1.2
log
@New engine - even more XML
@
text
@a5 1
#ifdef NEW_SOCKETS
a219 2

#endif@


1.1
log
@New engine
@
text
@d127 2
@

