head	1.2;
access;
symbols
	PublicRelease_1_2e:1.2
	Interim_Release_1-2e_RC1:1.2
	PublicRelease_1_2d:1.2
	Interim_Release_1-2d_RC1:1.2
	Interim_Release_1-2d_beta1:1.2
	PublicRelease_1_2c:1.2
	Interim_Release_1-2c_RC1:1.2
	Interim_Release_1-2c_beta1:1.2
	PublicRelease_1_2b:1.2
	Interim_Release_1-2b_RC1:1.2
	PublicRelease_1_2a:1.2
	Interim_Release_1-2a_RC1:1.2
	Interim_Release_1-2a_beta2:1.2
	Interim_Release_1-2a_beta1:1.2
	PublicRelease_1_2:1.2
	Interim_Release_1-2_RC1:1.2
	Interim_Release_1-2_beta1:1.2
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.1
	Interim_Release_1-1b_RC1:1.1
	PublicRelease_1_1a:1.1
	Interim_Release_1-1a_RC2:1.1
	Interim_Release_1-1a_RC1:1.1
	Interim_Release_1-1a_beta2:1.1
	Interim_Release_1-1a_beta1:1.1
	PublicRelease_1_1:1.1
	Interim_Release_1-1_beta1:1.1
	PublicRelease_1o:1.1
	Interim_Release_1o_RC1:1.1
	Interim_Release_1o_beta1:1.1
	PublicRelease_1n:1.1
	Interim_Release_1n_RC2:1.1
	Interim_Release_1n_RC1:1.1
	PublicRelease_1m:1.1
	Interim_Release_1m_beta1:1.1
	PublicRelease_1l:1.1;
locks; strict;
comment	@// @;


1.2
date	2004.12.29.16.04.22;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.13.21.56.45;	author eklmn;	state Exp;
branches;
next	;


desc
@@


1.2
log
@There can be only one engine :-)
@
text
@#include "StdAfx.h"
#include "FileMD4Part.h"
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFileMD4Part::CFileMD4Part(UCHAR* pFileHash, USHORT uNumber)
{
	m_pcFileHash = pFileHash;
	m_uNumber = uNumber;
	m_pcPartHash = NULL;
	m_bSharedPart = FALSE;
	m_dwTransfered = 0;
	m_uFullTrasfer = 0;
	m_uPartTrasfer = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CFileMD4Part::~CFileMD4Part()
{
	if (m_pcPartHash)
		delete m_pcPartHash;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CFileMD4Part::SetHash(UCHAR* pcHash)
{
	//allocate hash if required
	if (m_pcPartHash == NULL)
	{
		m_pcPartHash = new uchar[16];
	}
//	check allocation
	if (m_pcPartHash == NULL)
		return FALSE;

//	copy hash
	memcpy(m_pcPartHash, pcHash, 16);
//	set part as shared
	m_bSharedPart = TRUE;
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileMD4Part::CountTransferSession(BOOL bFullPartTransfer)
{
	if (bFullPartTransfer)
		m_uFullTrasfer++;
	else
		m_uPartTrasfer++;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileMD4Part::AddTransferred(uint32 dwBytes)
{
	m_dwTransfered += dwBytes; 
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileMD4Part::GetPartTagsFromStream(CTagStream* pTagStream)
{
	BYTE byteTemp;

	while (pTagStream->GetTagName() != 0)
	{
		switch(pTagStream->GetTagName())
		{
			case DBMD4PT_HASH:
				//allocate hash if required
				if (m_pcPartHash == NULL)
				{
					m_pcPartHash = new uchar[16];
				}
				pTagStream->GetTagValue(m_pcPartHash);
				break;

			case DBMD4PT_SHARED_STATUS:
				pTagStream->GetTagValue(&byteTemp);
				if (byteTemp != 0)
					m_bSharedPart = TRUE;
				else
					m_bSharedPart = FALSE;
				break;

			case DBMD4PT_TRANSFERRED:
				pTagStream->GetTagValue(&m_dwTransfered);
				break;

			case DBMD4PT_FULL_TRANSFER:
				pTagStream->GetTagValue(&m_uFullTrasfer);
				break;

			case DBMD4PT_PART_TRANSFER:
				pTagStream->GetTagValue(&m_uPartTrasfer);
				break;

			default:
				break;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CFileMD4Part::PutPartTagsInStream(CTagStream* pTagStream)
{
	BYTE byteTemp;

	if (m_pcPartHash)
	{
		pTagStream->PutTag(DBMD4PT_HASH, 16, m_pcPartHash);
	}

	if (m_bSharedPart)
		byteTemp = 0x5A;
	else
		byteTemp = 0x00;
	pTagStream->PutTag(DBMD4PT_SHARED_STATUS, sizeof(byteTemp), &byteTemp);
	pTagStream->PutTag(DBMD4PT_TRANSFERRED, sizeof(m_dwTransfered), &m_dwTransfered);
	pTagStream->PutTag(DBMD4PT_FULL_TRANSFER, sizeof(m_uFullTrasfer), &m_uFullTrasfer);
	pTagStream->PutTag(DBMD4PT_PART_TRANSFER, sizeof(m_uPartTrasfer), &m_uPartTrasfer);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CFileMD4Part::Load()
{
	Dbt key, data;
	MD4PartKey stKey;

	try
	{
		memset(&stKey, 0, sizeof(stKey));
		memcpy(stKey.fileHash, m_pcFileHash, 16);
		stKey.uPartNumber = m_uNumber;

		key.set_data(&stKey);
		key.set_size(sizeof(stKey));
		key.set_ulen(sizeof(stKey));
		key.set_flags(DB_DBT_USERMEM);

		// allow Db allocate the memory for tag stream
		data.set_data(NULL);
		data.set_size(0);
		data.set_ulen(0);
		data.set_flags(DB_DBT_MALLOC);

		int nRet = stEngine.m_pDbFiles->get(NULL, &key, &data, 0);
		if(nRet)
			return false;

		CTagStream* pTagStream = new CTagStream(data.get_data(), data.get_size());

		GetPartTagsFromStream(pTagStream);

		//the memory allocated by Db will be freed inside CTagStream
		safe_delete(pTagStream);
	}
	catch (DbRunRecoveryException &dbe)
	{
		TRACE(CString(dbe.what()));
		return false;
	}
	catch (DbException &dbe)
	{
		TRACE("Problems working with database objects: %s.\n", dbe.what());
		return false;
	}
	catch(...)
	{
		TRACE("Problems working with database objects.\n");
		return false;
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CFileMD4Part::Save()
{
	Dbt key, data;
	MD4PartKey stKey;
	CTagStream* pTagStream;

	try
	{
		pTagStream = new CTagStream();

		PutPartTagsInStream(pTagStream);

		memset(&stKey, 0, sizeof(stKey));
		memcpy(stKey.fileHash, m_pcFileHash, 16);
		stKey.uPartNumber = m_uNumber;

		key.set_data(&stKey);
		key.set_size(sizeof(stKey));

		data.set_data(pTagStream->GetStream());
		data.set_size(pTagStream->GetStreamSize());

		int nRet = stEngine.m_pDbFiles->put(NULL, &key, &data, 0);
		safe_delete(pTagStream);
		if(nRet)
		{
			stEngine.m_pDbFiles->err(nRet, "CKnownFile::SaveTag");
			ASSERT(FALSE);
			return false;
		}
	}
	catch (DbRunRecoveryException &dbe)
	{
		TRACE(CString(dbe.what()));
		safe_delete(pTagStream);
		return false;
	}
	catch (DbException &dbe)
	{
		TRACE("Problems working with database objects: %s.\n", dbe.what());
		safe_delete(pTagStream);
		return false;
	}
	catch(...)
	{
		TRACE("Problems working with database objects.\n");
		safe_delete(pTagStream);
		return false;
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

@


1.1
log
@changed the way of data storage in file classes, add new classes
@
text
@d39 1
a39 1
void CFileMD4Part::CountTransferSession(CEmEngine& stEngine, BOOL bFullPartTransfer)
d47 1
a47 1
void CFileMD4Part::AddTransferred(CEmEngine& stEngine, uint32 dwBytes)
d114 1
a114 1
bool CFileMD4Part::Load(CEmEngine& stEngine)
d166 1
a166 1
bool CFileMD4Part::Save(CEmEngine &stEngine)
@

