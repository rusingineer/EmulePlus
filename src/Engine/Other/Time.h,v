head	1.4;
access;
symbols
	PublicRelease_1_2e:1.4
	Interim_Release_1-2e_RC1:1.4
	PublicRelease_1_2d:1.4
	Interim_Release_1-2d_RC1:1.4
	Interim_Release_1-2d_beta1:1.4
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.1;
locks; strict;
comment	@ * @;


1.4
date	2005.04.16.00.05.00;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.28.19.40.06;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.22.22.02.09;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.18.15.36.52;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@v2 - Xml events and other improvements
@
text
@// Time.h: interface for the CPreciseTime class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <time.h>

class CPreciseTime
{
public:
	CPreciseTime()
		:m_nRegularTime(0)
		,m_uPrecision(0)
	{ }
	CPreciseTime(time_t nRegular, USHORT uPrecision)
		:m_nRegularTime(nRegular)
		,m_uPrecision(uPrecision)
	{ }
	static CPreciseTime GetCurrentTime()
	{
		SYSTEMTIME stSystemTime;
		GetSystemTime(&stSystemTime);
		return CPreciseTime(time(NULL), stSystemTime.wMilliseconds);
	}
	long operator -(CPreciseTime& tm)
	{
		return ((long)(m_nRegularTime - tm.m_nRegularTime) * 1000 + m_uPrecision - tm.m_uPrecision);
	}

	__declspec(property(get=_GetRegular))	time_t	Time;
	__declspec(property(get=_GetPrecision))	USHORT	Precision;
	__declspec(property(get=_GetIsNull))	bool	IsNull;
	__declspec(property(get=_GetFullTime))	LPCTSTR	FullTime;

	time_t	_GetRegular() const { return m_nRegularTime; }
	USHORT	_GetPrecision() const { return m_uPrecision; }
	bool	_GetIsNull() const { return (m_nRegularTime == 0 && m_uPrecision == 0); }
	LPCTSTR _GetFullTime()
	{
		struct tm* tmInfo = localtime(&m_nRegularTime);
		_stprintf(m_szFullTime, _T("%d/%02d/%04d %d:%02d:%02d")
			,tmInfo->tm_mday
			,tmInfo->tm_mon
			,tmInfo->tm_year + 1900
			,tmInfo->tm_hour
			,tmInfo->tm_min
			,tmInfo->tm_sec
			);
		return m_szFullTime;
	}
protected:
	time_t	m_nRegularTime;
	USHORT	m_uPrecision;
	TCHAR	m_szFullTime[100];
};
@


1.3
log
@v2 - more upload logic, limiting total upload speed
@
text
@d26 1
a26 1
	UINT operator -(CPreciseTime& tm)
d28 1
a28 1
		return ((m_nRegularTime - tm.m_nRegularTime) * 1000 + m_uPrecision - tm.m_uPrecision);
@


1.2
log
@v2 - enhancing logging subsystem
@
text
@d22 3
a24 1
		return CPreciseTime(time(NULL), ::GetTickCount() % 1000);
@


1.1
log
@v2 - more upload logic
@
text
@d7 2
d24 5
d32 19
a50 4
	time_t	_GetRegular(){ return m_nRegularTime; }
	USHORT	_GetPrecision(){ return m_uPrecision; }
	bool	_GetIsNull(){ return (m_nRegularTime == 0 && m_uPrecision == 0); }
private:
d53 1
@

