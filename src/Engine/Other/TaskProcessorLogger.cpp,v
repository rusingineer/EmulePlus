head	1.7;
access;
symbols
	PublicRelease_1_2e:1.7
	Interim_Release_1-2e_RC1:1.7
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.7
	Interim_Release_1-2c_RC1:1.7
	Interim_Release_1-2c_beta1:1.7
	PublicRelease_1_2b:1.7
	Interim_Release_1-2b_RC1:1.7
	PublicRelease_1_2a:1.7
	Interim_Release_1-2a_RC1:1.7
	Interim_Release_1-2a_beta2:1.7
	Interim_Release_1-2a_beta1:1.7
	PublicRelease_1_2:1.7
	Interim_Release_1-2_RC1:1.7
	Interim_Release_1-2_beta1:1.7
	PublicRelease_1_1g:1.7
	Interim_Release_1-1g_RC3:1.7
	Interim_Release_1-1g_RC2:1.7
	Interim_Release_1-1g_RC1:1.7
	Interim_Release_1-1g_beta2:1.7
	Interim_Release_1-1g_beta1:1.7
	PublicRelease_1_1f:1.7
	Interim_Release_1-1f_RC1:1.7
	PublicRelease_1_1e:1.7
	Interim_Release_1-1e_RC2:1.7
	Interim_Release_1-1e_RC1:1.7
	Interim_Release_1-1e_beta1:1.7
	PublicRelease_1_1d:1.6
	Interim_Release_1-1d_RC1:1.6
	PublicRelease_1_1c:1.6
	Interim_Release_1-1c_RC1:1.6
	Interim_Release_1-1c_beta2:1.6
	Interim_Release_1-1c_beta1:1.6
	PublicRelease_1_1b:1.3
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1;
locks; strict;
comment	@// @;


1.7
date	2005.04.17.05.16.25;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.28.20.13.52;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.29.16.04.22;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.26.15.45.32;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.06.20.50.07;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2004.01.16.14.51.00;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@v2 - corrected protocol, tags
@
text
@// Logger.cpp: implementation of the CTaskProcessor_Logger class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TaskProcessorLogger.h"

bool CTaskProcessor_Logger::Start()
{
	m_dwWaitTimeout = 1000;

	m_hFile = CreateFile(_T("C:\\Io.em"), GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (INVALID_HANDLE_VALUE == m_hFile)
		return false;

	DWORD dwSize = GetFileSize(m_hFile, NULL);
	SetFilePointer(m_hFile, dwSize, NULL, FILE_BEGIN);
	return true;
}

void CTaskProcessor_Logger::Stop()
{
	if (INVALID_HANDLE_VALUE != m_hFile)
	{
		VERIFY(CloseHandle(m_hFile));
		m_hFile = INVALID_HANDLE_VALUE;
	}
}

void CTaskProcessor_Logger::Post(const COpCode& stMsg, T_CLIENT_TYPE eType, ULONG nClientID, BOOL bOut)
{
	DWORD dwSize = stMsg.GetSize(OP_TRANSPORT_UDP, stMsg.m_bSupportNewTags);
	CTask_LogOpcode* pTask = new (dwSize) CTask_LogOpcode;
	ASSERT(pTask);
	if (pTask)
	{
		pTask->m_nIdProtoType = (eType << 16) | (stMsg.GetProtocol() << 8) | stMsg.GetID();
		pTask->m_nClientID = nClientID;
		pTask->m_bOut = bOut;
		pTask->m_dwSize = dwSize;

		CStream_Mem stStream;
		stStream.m_pPtr = pTask->m_pBuf;
		stStream.m_dwSize = dwSize;
		VERIFY(stMsg.Write(stStream, OP_TRANSPORT_UDP, stMsg.m_bSupportNewTags));
		Push(pTask);
	}
}

void CTaskProcessor_Logger::Write(PCVOID pData, DWORD dwSize)
{
	DWORD dwWritten;
	VERIFY(WriteFile(m_hFile, pData, dwSize, &dwWritten, NULL));
	ASSERT(dwWritten = dwSize);
}

bool CTask_LogOpcode::Process()
{
	CTaskProcessor_Logger* pLogger = g_stEngine.m_pLoggerProcessor;
	DWORD dwValue = 0xF00FC55C; // our so-called safe value. It is written at the beginning of each record
	pLogger->Write(&dwValue, sizeof(dwValue));

	FILETIME stTime;
	GetSystemTimeAsFileTime(&stTime);
	pLogger->Write(&stTime, sizeof(stTime));
	pLogger->Write(&m_nClientID, sizeof(m_nClientID));
	pLogger->Write(&m_nIdProtoType, sizeof(m_nIdProtoType));
	pLogger->Write(&m_bOut, 1);
	pLogger->Write(&m_dwSize, sizeof(m_dwSize));
	pLogger->Write(m_pBuf, m_dwSize);
	return true;
}

void CTaskProcessor_Logger::ProcessTimeout()
{
	m_dwWaitTimeout = 1000; // perform check once per second
	// possibly we'll later add checking for file's size overflow
}
@


1.6
log
@Xml and database functionality
@
text
@d32 1
a32 1
	DWORD dwSize = stMsg.GetSize(OP_TRANSPORT_UDP);
d45 1
a45 1
		VERIFY(stMsg.Write(stStream, OP_TRANSPORT_UDP));
@


1.5
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@d6 1
a6 2

#include "../EmEngine.h"
d59 1
a59 1
	CTaskProcessor_Logger& stLogger = g_stEngine.m_stLoggerTP;
d61 1
a61 1
	stLogger.Write(&dwValue, sizeof(dwValue));
d65 6
a70 6
	stLogger.Write(&stTime, sizeof(stTime));
	stLogger.Write(&m_nClientID, sizeof(m_nClientID));
	stLogger.Write(&m_nIdProtoType, sizeof(m_nIdProtoType));
	stLogger.Write(&m_bOut, 1);
	stLogger.Write(&m_dwSize, sizeof(m_dwSize));
	stLogger.Write(m_pBuf, m_dwSize);
@


1.4
log
@There can be only one engine :-)
@
text
@d60 1
a60 1
	CTaskProcessor_Logger& stLogger = g_stEngine.m_stLogger;
@


1.3
log
@Rearrangements
@
text
@d58 1
a58 1
bool CTask_LogOpcode::Process(CEmEngine& stEngine)
d60 1
a60 1
	CTaskProcessor_Logger& stLogger = stEngine.m_stLogger;
@


1.2
log
@New engine - logging
@
text
@d11 2
d77 1
@


1.1
log
@*** empty log message ***
@
text
@d36 1
a36 1
		pTask->m_eType = eType;
d65 3
a67 6
	
	dwValue = (DWORD) m_eType;
	if (m_bOut)
		dwValue |= 0x100;
	stLogger.Write(&dwValue, sizeof(dwValue));

@

