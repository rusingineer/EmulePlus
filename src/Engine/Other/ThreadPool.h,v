head	1.2;
access;
symbols
	PublicRelease_1_2e:1.2
	Interim_Release_1-2e_RC1:1.2
	PublicRelease_1_2d:1.2
	Interim_Release_1-2d_RC1:1.2
	Interim_Release_1-2d_beta1:1.2
	PublicRelease_1_2c:1.2
	Interim_Release_1-2c_RC1:1.2
	Interim_Release_1-2c_beta1:1.2
	PublicRelease_1_2b:1.2
	Interim_Release_1-2b_RC1:1.2
	PublicRelease_1_2a:1.2
	Interim_Release_1-2a_RC1:1.2
	Interim_Release_1-2a_beta2:1.2
	Interim_Release_1-2a_beta1:1.2
	PublicRelease_1_2:1.2
	Interim_Release_1-2_RC1:1.2
	Interim_Release_1-2_beta1:1.2
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1;
locks; strict;
comment	@ * @;


1.2
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Formatting, comments, and name changes.
@
text
@// ThreadPool.h: interface for the CThreadPool class.
//
//////////////////////////////////////////////////////////////////////

#ifdef NEW_SOCKETS
#if !defined(AFX_THREADPOOL_H__92402536_5AEB_467C_9302_98CD441A7981__INCLUDED_)
#define AFX_THREADPOOL_H__92402536_5AEB_467C_9302_98CD441A7981__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "EmMt.h"

class CThreadPool  
{
	HANDLE m_hIoCompletionPort;
	HANDLE* m_pThreads;
	DWORD m_dwThreads;

	static UINT WINAPI CompletionFunc(PVOID);

protected:
	virtual void ProcessCompletion(BOOL bResult, DWORD dwBytes, DWORD dwKey, OVERLAPPED*) = NULL;

	DWORD m_dwWaitTimeout; // infinite by default

public:
	
	CThreadPool() :
		m_hIoCompletionPort(NULL),
		m_pThreads(NULL),
		m_dwThreads(0),
		m_dwWaitTimeout(INFINITE)
	{}
	virtual ~CThreadPool();

	DWORD InitPool(DWORD dwThreads = 0, DWORD dwMaxConcurrent = 0);
	void UninitPool(DWORD dwMaxWaitTimeout = 1000);

	inline HANDLE zget_CompletionPort() const { return m_hIoCompletionPort; }
	__declspec (property(get=zget_CompletionPort)) HANDLE _CompletionPort;

	inline DWORD zget_Threads() const { return m_dwThreads; }
	__declspec (property(get=zget_Threads)) DWORD _Threads;
};

template <class T>
class CPtrQueue {
	CCriticalSection_INL m_csLock;
	HANDLE m_hSemaphore; // semaphore
	std::queue<T*> m_queueData;

	T* FetchFront()
	{
		CCriticalSection_INL::CScope stScope(m_csLock);
		ASSERT(!m_queueData.empty());

		T* pObject = m_queueData.front();
		m_queueData.pop();

		return pObject;
	}
public:

	CPtrQueue() : m_hSemaphore(NULL) {}
	~CPtrQueue() { Uninit(); }

	bool Init()
	{
		Uninit();

		m_hSemaphore = CreateSemaphore(NULL, 0, 0xFFFF, NULL);
		return NULL != m_hSemaphore;
	}
	void Uninit()
	{
		if (m_hSemaphore)
		{
			VERIFY(CloseHandle(m_hSemaphore));
			m_hSemaphore = NULL;
		}

		CCriticalSection_INL::CScope stScope(m_csLock);

		for (; !m_queueData.empty(); m_queueData.pop())
		{
			T* pObject = m_queueData.front();
			if (pObject)
				delete pObject;
		}
	}
	bool IsInitialized() { return NULL != m_hSemaphore; }

	void Push(T* pObject)
	{
		ASSERT(m_hSemaphore);	// LOL, now is this confusing or what?

		m_csLock.Enter();
		m_queueData.push(pObject);
		m_csLock.Leave();

		VERIFY(ReleaseSemaphore(m_hSemaphore, 1, NULL));
	}
	T* Pop(DWORD dwTimeout = INFINITE)
	{
	//	If the queue is empty, wait for the next push until the timeout. If the queue isn't
	//		empty or it's fed in time, return the next queue entry...
		if (m_hSemaphore && (WAIT_OBJECT_0 == WaitForSingleObject(m_hSemaphore, dwTimeout)))
			return FetchFront();
		return NULL;
	}
	T* PopEx(HANDLE hInterrupt, DWORD dwTimeout = INFINITE)
	{
		if (m_hSemaphore)
		{
			HANDLE pWait[] = { m_hSemaphore, hInterrupt };
		//	If the queue is empty or 'hInterrupt' is signaled, wait until the timeout
		//		for the next push or for 'hInterrupt' to become unsignaled . If the queue isn't
		//		empty or it's fed in time, return the next queue entry...
			if (WAIT_OBJECT_0 == WaitForMultipleObjects(2, pWait, FALSE, dwTimeout))
				return FetchFront();
		}
		return NULL;
	}
};

struct TAIL
{
	DWORD m_dwSize;
	char m_pData[0]; // variable length
	inline void* operator new (size_t nSize, DWORD dwSizeExtra)
	{
		return malloc(nSize + dwSizeExtra);
		nSize += dwSizeExtra;
	}
	inline void operator delete (void* pPtr)
	{
		free(pPtr);
	}
};

class CDataQueue : public CPtrQueue<TAIL> {

public:

	bool Push(PVOID pData, DWORD dwDataSize);
};

#endif // !defined(AFX_THREADPOOL_H__92402536_5AEB_467C_9302_98CD441A7981__INCLUDED_)
#endif@


1.1
log
@New engine
@
text
@d97 1
a97 1
		ASSERT(m_hSemaphore);
d107 2
d118 3
@

