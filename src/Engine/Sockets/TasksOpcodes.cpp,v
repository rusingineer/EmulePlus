head	1.33;
access;
symbols
	PublicRelease_1_2e:1.33
	Interim_Release_1-2e_RC1:1.33
	PublicRelease_1_2d:1.33
	Interim_Release_1-2d_RC1:1.33
	Interim_Release_1-2d_beta1:1.33
	PublicRelease_1_2c:1.33
	Interim_Release_1-2c_RC1:1.33
	Interim_Release_1-2c_beta1:1.33
	PublicRelease_1_2b:1.33
	Interim_Release_1-2b_RC1:1.33
	PublicRelease_1_2a:1.33
	Interim_Release_1-2a_RC1:1.33
	Interim_Release_1-2a_beta2:1.33
	Interim_Release_1-2a_beta1:1.33
	PublicRelease_1_2:1.33
	Interim_Release_1-2_RC1:1.33
	Interim_Release_1-2_beta1:1.33
	PublicRelease_1_1g:1.33
	Interim_Release_1-1g_RC3:1.33
	Interim_Release_1-1g_RC2:1.33
	Interim_Release_1-1g_RC1:1.33
	Interim_Release_1-1g_beta2:1.33
	Interim_Release_1-1g_beta1:1.33
	PublicRelease_1_1f:1.33
	Interim_Release_1-1f_RC1:1.33
	PublicRelease_1_1e:1.33
	Interim_Release_1-1e_RC2:1.33
	Interim_Release_1-1e_RC1:1.33
	Interim_Release_1-1e_beta1:1.33
	PublicRelease_1_1d:1.28
	Interim_Release_1-1d_RC1:1.25
	PublicRelease_1_1c:1.22
	Interim_Release_1-1c_RC1:1.20
	Interim_Release_1-1c_beta2:1.16
	Interim_Release_1-1c_beta1:1.15
	PublicRelease_1_1b:1.13
	Interim_Release_1-1b_RC1:1.13
	PublicRelease_1_1a:1.13
	Interim_Release_1-1a_RC2:1.13
	Interim_Release_1-1a_RC1:1.13
	Interim_Release_1-1a_beta2:1.13
	Interim_Release_1-1a_beta1:1.13
	PublicRelease_1_1:1.13
	Interim_Release_1-1_beta1:1.13
	PublicRelease_1o:1.13
	Interim_Release_1o_RC1:1.13
	Interim_Release_1o_beta1:1.13
	PublicRelease_1n:1.13
	Interim_Release_1n_RC2:1.13
	Interim_Release_1n_RC1:1.13
	PublicRelease_1m:1.10
	Interim_Release_1m_beta1:1.10
	PublicRelease_1l:1.10
	Interim_Release_1l_RC3:1.10
	Interim_Release_1l_RC2:1.10
	Interim_Release_1l_RC1:1.10
	Interim_Release_1l_beta2:1.10
	Interim_Release_1l_beta1:1.10
	PublicRelease_1k:1.10
	Interim_Release_1k_RC4:1.10
	Interim_1k_RC3:1.10
	Interim_1k_RC2:1.10
	Interim_Release_1k_RC1:1.10
	Interim_Release_1k_beta5:1.10
	Intrerim_Release_1k_beta4:1.10
	Interim_Release_1k_beta1:1.10
	PublicRelease_1j:1.6
	Interim_Release_1J_RC3:1.6
	Interim_Release_1j_RC3:1.6
	Interim_Release_1j_RC2:1.5
	Interim_Release_1j_RC1:1.5
	Interim_Release_1j_beta2:1.5
	Interim_Release_1j_beta1:1.3;
locks; strict;
comment	@// @;


1.33
date	2005.04.07.17.24.49;	author kuchin;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.04.06.07.28;	author kuchin;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.29.14.36.14;	author kuchin;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.27.05.01.51;	author kuchin;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.22.15.54.10;	author kuchin;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.18.15.36.51;	author kuchin;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.17.19.29.31;	author kuchin;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.15.20.00.31;	author kuchin;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.13.19.30.16;	author kuchin;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.11.14.45.20;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.08.17.09.08;	author kuchin;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.26.17.52.05;	author kuchin;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.26.09.48.22;	author kuchin;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.23.18.58.05;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.20.19.44.49;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.19.20.40.57;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.18.18.31.25;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.05.13.57.12;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.09.14.16.13;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.14.14.19.30;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.30.13.39.04;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.15.11.55.58;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.07.11.37.09;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.05.19.31.56;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.16.14.51.00;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.07.10.54.33;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.07.09.18.16;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.23.18.13.48;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.21.10.29.05;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.33
log
@v2 - fixes for upload logic
@
text
@// TasksOpcodes.cpp: implementation of client opcodes.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "OpCode.h"
#include "TasksOpcodes.h"
#include "../Files/TaskProcessorFiles.h"
#include "../../SharedFileList.h"
#include "../../SafeFile.h"
#include "../Data/ClientList.h"
#include "../Data/Prefs.h"

OFFEREDFILE& OFFEREDFILE::operator = (const OFFEREDFILE& stObj)
{
	md4cpy(_Hash, stObj._Hash);
	_ClientID	= stObj._ClientID;
	_ClientPort	= stObj._ClientPort;
	_FileName	= stObj._FileName;
	_FileSize	= stObj._FileSize;
	_FileType	= stObj._FileType;

	return *this;
}


//////////////////////////////////////////////////////////////////////
// Client OpCodes
//////////////////////////////////////////////////////////////////////

void SendEmuleInfoAnswer(SOCKET hSocket, CEmClient_Peer* pClient)
{
	COpCode_EMULEINFOANSWER stMsg;
	stMsg._ClientVersion = CURRENT_VERSION_SHORT;
	stMsg._ProtocolVersion = EMULE_PROTOCOL;
	stMsg._Compression = 1;
	stMsg._UdpVersion = 4;
	stMsg._UdpPort = g_stEngine.Prefs.GetUDPPort();
	stMsg._SourceExchange = 0;//2;
	stMsg._Comments = 1;
	stMsg._ModPlus = CURRENT_PLUS_VERSION;
	stMsg._ExtendedRequest = 2;
	stMsg._ModVersion = _T(PLUS_VERSION_STR);
	stMsg._L2Hac = FILEREASKTIME;
	stMsg._Features = 0; // g_eMuleApp.m_pClientCreditList->CryptoAvailable() ? 3 : 0

	g_stEngine.SendOpCode(hSocket, stMsg, pClient, QUE_HIGH);
}

//////////////////////////////////////////////////////////////////////
// HELLO opcode
bool COpCode_HELLO::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Find client in the list of known clients
	if(pClient->Mule == NULL)
		 pClient->Mule = g_stEngine.ClientList.FindMuleClient(_UserHash);
	// If not found, create it
	if(pClient->Mule == NULL)
	{
		CClientMule* pMule = new CClientMule(_ClientAddr, _UserHash);
		if(pMule)
		{
			g_stEngine.ClientList.AddClient(pMule);
			pClient->Mule = pMule;
		}
		else
			AddLog(LOG_ERROR, _T("No memory"));
	}
	// Setting parent
	pClient->Mule->Parent = pClient;
	// Connected state
	pClient->Mule->OnConnected();

	// Update client information
	if(_UserName.Valid)		pClient->Mule->UserName = _UserName;
	if(_SoftVersion.Valid)	pClient->Mule->ClientVersion = _SoftVersion;
	if(_UserPort.Valid)		pClient->Mule->ClientPort = _UserPort;
	// to do ModVersion
	if(_UserUDPPort.Valid)	pClient->Mule->ClientUDPPort = _UserUDPPort;
	// to do MiscOptions
	if(_MuleVersion.Valid)	pClient->Mule->MuleVersion = _MuleVersion;

	// Send the answer
	CTask_SayHelloToPeer* pTask = new CTask_SayHelloToPeer();
	if(pTask)
	{
		pTask->SetClient(pClient);
		pTask->m_bManual = true;
		g_stEngine.Sockets.Push(pTask);
	}
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

//////////////////////////////////////////////////////////////////////
// HELLO answer
bool COpCode_HELLOANSWER::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

//////////////////////////////////////////////////////////////////////
// eMule info
bool COpCode_EMULEINFO::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	SendEmuleInfoAnswer(m_hSocket, pClient);

	return true;
}

//////////////////////////////////////////////////////////////////////
// eMule info answer
bool COpCode_EMULEINFOANSWER::ProcessForClient(CEmClient_Peer* pClient)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Request filename
bool COpCode_REQUESTFILENAME::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Just send requested filename
	CTask_SendRequestedFileName* pTask = new CTask_SendRequestedFileName(_Hash, pClient);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Request filename answer
bool COpCode_REQFILENAMEANSWER::ProcessForClient(CEmClient_Peer* pClient)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start file upload
bool COpCode_STARTUPLOADREQ::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Check that we have that file, and add client to waiting queue
	CTask_UploadReqResult* pTask = new CTask_UploadReqResult(_Hash, pClient);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Accept upload request
bool COpCode_ACCEPTUPLOADREQ::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// No such file
bool COpCode_FILEREQANSNOFIL::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Request parts
bool COpCode_REQUESTPARTS::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Request file blocks
	// To optimize (maybe) - pass all 3 ranges in one task instead of 3 tasks
	CTask_RequestBlock* 
	pTask = new CTask_RequestBlock(_Hash, pClient, _Start1, _End1);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));
	pTask = new CTask_RequestBlock(_Hash, pClient, _Start2, _End2);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));
	pTask = new CTask_RequestBlock(_Hash, pClient, _Start3, _End3);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sending file part
bool COpCode_SENDINGPART::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Get file status
bool COpCode_SETREQFILEID::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Send file status, if we have it
	CTask_SendFileStatus* pTask = new CTask_SendFileStatus(_Hash, pClient);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// File status
bool COpCode_FILESTATUS::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Hash request
bool COpCode_HASHSETREQUEST::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Send file hashsets, if we have the file
	CTask_SendHashsets* pTask = new CTask_SendHashsets(_Hash, pClient);
	if(pTask)
		g_stEngine.Files.Push(pTask);
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Hash request answer
bool COpCode_HASHSETANSWER::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Offer files
bool COpCode_OFFERFILES::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Send ranking info
bool COpCode_QUEUERANKING::ProcessForClient(CEmClient_Peer*)
{
	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Cancel transfer
bool COpCode_CANCELTRANSFER::ProcessForClient(CEmClient_Peer* pClient)
{
	g_stEngine.ClientList.RemoveFromUploadQueue(pClient->Mule, ETS_CANCELED);
	return true;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// (!) Can be both we connected to him or he connected to us
// Sending HELLO/HELLOANSWER opcode.

#define FillHelloMessage() \
	md4cpy(&stMsg._UserHash, g_stEngine.Prefs.GetUserHash()); \
	stMsg._ClientAddr.Addr = g_stEngine.GetClientID(); \
	stMsg._ClientAddr.Port = g_stEngine.Prefs.GetPort(); \
	stMsg._UserName = g_stEngine.Prefs.GetUserNick(); \
	stMsg._SoftVersion = EDONKEYVERSION; \
	stMsg._UserUDPPort = g_stEngine.Prefs.GetUDPPort(); \
	stMsg._MiscOptions = \
		(4						<< 4*6) |	/* UDP version */ \
		(1						<< 4*5) |	/* Data compression version */ \
		(0/*dwSupportSecIdent*/	<< 4*4) |	/* Secure Ident */ \
		(0/*2*/					<< 4*3) |	/* Source Exchange */ \
		(2						<< 4*2) |	/* Ext. Requests */ \
		(1						<< 4*1) |	/* Comments */ \
		(1/*dwNoViewSharedFiles*/<< 1*2);	/* No View Shared files */ \
	stMsg._MuleVersion = \
		(PLUS_COMPATIBLECLIENTID << 24) | \
		((CURRENT_PLUS_VERSION & 0x7F00) << 9) | \
		((CURRENT_PLUS_VERSION & 0xF0) << 6) | \
		((CURRENT_PLUS_VERSION & 0x7) << 7);

bool CTask_SayHelloToPeer::Process()
{
	if (m_pPeer == NULL)
		return true;

	if((m_iMessage == FD_CONNECT && !m_pPeer->m_bFromOutside) || m_bManual)
	{
		if(m_bManual)
		{
			COpCode_HELLOANSWER stMsg;
			FillHelloMessage();
			g_stEngine.SendOpCode(m_pPeer->m_hSocket, stMsg, m_pPeer, QUE_HIGH);
		}
		else
		{
			COpCode_HELLO stMsg;
			FillHelloMessage();
			g_stEngine.SendOpCode(m_pPeer->m_hSocket, stMsg, m_pPeer, QUE_HIGH);
		}
		/*	if(g_stEngine.ServerState.IsConnecting() || g_stEngine.ServerState.IsConnected())
		{
		stMsg._ServerAddr._IPAddr = g_stEngine.ServerState.nAddr;
		stMsg._ServerAddr._Port = g_stEngine.ServerState.nPort;
		}
		else
		{
		stMsg._ServerAddr._IPAddr = 0;
		stMsg._ServerAddr._Port = 0;
		}*/

		if(m_pPeer->Mule && m_pPeer->Mule->MuleProtocol)
			SendEmuleInfoAnswer(m_pPeer->m_hSocket, m_pPeer);
	}
	else
	{
		ASSERT(FALSE);
	}

	return true;
}
@


1.32
log
@v2 - more upload logic
@
text
@d47 1
a47 1
	g_stEngine.SendOpCode(hSocket, stMsg, pClient);
d317 1
a317 1
			g_stEngine.SendOpCode(m_pPeer->m_hSocket, stMsg, m_pPeer);
d323 1
a323 1
			g_stEngine.SendOpCode(m_pPeer->m_hSocket, stMsg, m_pPeer);
@


1.31
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d183 4
a186 4
	// Prepare and send the blocks
	// Actually, we should remember those blocks' offsets to send them later
	CTask_SendBlock* 
	pTask = new CTask_SendBlock(_Hash, pClient, _Start1, _End1);
d191 1
a191 1
	pTask = new CTask_SendBlock(_Hash, pClient, _Start2, _End2);
d196 1
a196 1
	pTask = new CTask_SendBlock(_Hash, pClient, _Start3, _End3);
@


1.30
log
@v2 - minor improvements
@
text
@d11 1
a11 1
#include "../Data/Client.h"
d100 1
a100 1
// HELLO ANSWER
d106 2
d117 2
d271 1
d273 6
@


1.29
log
@v2 - more upload logic
@
text
@d63 7
a69 2
		g_stEngine.ClientList.AddClient(pMule);
		pClient->Mule = pMule;
d93 2
d130 2
d153 2
d185 2
d190 2
d195 2
d218 2
d241 2
d325 1
a325 2
		if (1/*emule protocol supported*/)
		{
a326 1
		}
d330 1
@


1.28
log
@v2 - more upload logic
@
text
@d12 1
d239 7
d250 24
a273 2
// (!) can be both we connected to him or he connected to us
// sending HELLO/HELLOANSWER opcode.
d281 12
a292 20
		COpCode_HELLOANSWER stMsg;
		md4cpy(&stMsg._UserHash, g_stEngine.Prefs.GetUserHash());
		stMsg._ClientAddr.Addr = g_stEngine.GetClientID();
		stMsg._ClientAddr.Port = g_stEngine.Prefs.GetPort();
		stMsg._UserName = g_stEngine.Prefs.GetUserNick();
		stMsg._SoftVersion = EDONKEYVERSION;
		stMsg._UserUDPPort = g_stEngine.Prefs.GetUDPPort();
		stMsg._MiscOptions = 		
			(4						<< 4*6) |	// UDP version
			(1						<< 4*5) |	// Data compression version
			(0/*dwSupportSecIdent*/	<< 4*4) |	// Secure Ident
			(0/*2*/					<< 4*3) |	// Source Exchange
			(2						<< 4*2) |	// Ext. Requests
			(1						<< 4*1) |	// Comments
			(1/*dwNoViewSharedFiles*/<< 1*2);	// No View Shared files
		stMsg._MuleVersion = 
			(PLUS_COMPATIBLECLIENTID << 24) | 
			((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
			((CURRENT_PLUS_VERSION & 0xF0) << 6) | 
			((CURRENT_PLUS_VERSION & 0x7) << 7);
a303 2
		g_stEngine.SendOpCode(m_pPeer->m_hSocket, stMsg, m_pPeer);

a314 363

enum
{
	TASK_START	= 0,
	TASK_READ	= 1,
	TASK_SEND	= 2
};

//////////////////////////////////////////////////////////////////////
// Send list of shared files
CTask_SendSharedList::CTask_SendSharedList()
{
	m_nState = TASK_START;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendSharedList::Process()
{
	if(!g_stEngine.ServerState.IsConnected())
		return true;

	switch(m_nState)
	{
	case TASK_START:
		m_nState = TASK_READ;
		g_stEngine.Files.Push(this);
		return false;
	case TASK_READ:
		if(g_stEngine.Files.SharedFiles.m_mapSharedFiles.IsEmpty())
			return true;
		for(POSITION pos = g_stEngine.Files.SharedFiles.m_mapSharedFiles.GetStartPosition(); pos != NULL; )
		{
			CCKey		bufKey;
			CKnownFile*	pKnownFile = NULL;
			g_stEngine.Files.SharedFiles.m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
			if(pKnownFile)
			{
				OFFEREDFILE stFile;
				md4cpy(stFile._Hash, pKnownFile->GetFileHash());

				uint32		dwClientID = 0;
				uint16		uClientPort = 0;

				if (false) // pServer && (pServer->GetTCPFlags() & SRV_TCPFLG_COMPRESSION)
				{
					if (pKnownFile->IsPartFile())
					{
						stFile._ClientID	= 0xFCFCFCFC;
						stFile._ClientPort	= 0xFCFC;
					}
					else
					{
						// Publishing a complete files
						stFile._ClientID	= 0xFBFBFBFB;
						stFile._ClientPort	= 0xFBFB;
					}
				}
				else
				{
					//	If connected and highID, set client ID and port
					if(true) // m_pServerConnect->IsConnected() && !m_pServerConnect->IsLowID()
					{
						stFile._ClientID	= g_stEngine.GetClientID();
						stFile._ClientPort	= g_stEngine.Prefs.GetPort();
					}
				}
				stFile._FileName = pKnownFile->GetFileName();
				stFile._FileSize = pKnownFile->GetFileSize();
				stFile._FileType = pKnownFile->GetFileTypeString();

				//	There's no need to send FT_FILEFORMAT (file extension without ".") here as a server takes it from the file name
				/*if ( ((pServer != NULL) && (pServer->GetTCPFlags() & SRV_TCPFLG_NEWTAGS)) ||
					( (pClient != NULL) && pClient->IsEmuleClient() &&
					( ((pClient->GetClientSoft() == SO_EMULE) && (pClient->GetVersion() >= FORM_CLIENT_VER(0, 42, 7))) ||
					((pClient->GetClientSoft() == SO_PLUS) && (pClient->GetVersion() > FORM_CLIENT_VER(1, 1, 0))) ) ) )
				*/
				m_Files.Add(stFile);
			}
		}
		m_nState = TASK_SEND;
		g_stEngine.Sockets.Push(this);
		return false;
	case TASK_SEND:
		if(m_Files.GetCount() > 0)
		{
			COpCode_OFFERFILES stMsg;
			for(int i = 0; i < m_Files.GetCount(); i++)
			{
				COpCode_OFFERFILES::CStruct_Files stFile;
				md4cpy(&stFile._Hash, m_Files[i]._Hash);
				stFile._ClientAddr.Addr	= m_Files[i]._ClientID;
				stFile._ClientAddr.Port	= m_Files[i]._ClientPort;
				stFile._FileName			= m_Files[i]._FileName;
				stFile._FileSize			= m_Files[i]._FileSize;
				stFile._FileType			= m_Files[i]._FileType;
				stMsg._Files.push_back(stFile);
			}

			SOCKET hServerSocket = g_stEngine.ServerState.hSocket;
			CEmClient* pClient = g_stEngine.Sockets.Lookup(hServerSocket);
			if(pClient)
				g_stEngine.SendOpCode(hServerSocket, stMsg, pClient);
		}
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// Send requested filename
CTask_SendRequestedFileName::CTask_SendRequestedFileName(HashType Hash, CEmClient* pClient)
{
	m_nState = TASK_READ;
	md4cpy(&m_Hash, &Hash);
	m_pClient = pClient;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendRequestedFileName::Process()
{
	switch(m_nState)
	{
	case TASK_READ:
		if(!g_stEngine.Files.SharedFiles.m_mapSharedFiles.IsEmpty())
		{
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash.hash);
			if(pFile)
			{
				m_strFileName	= pFile->GetFileName();
				m_nState = TASK_SEND;
				g_stEngine.Sockets.Push(this);
				return false;
			}
		}
		return true;
	case TASK_SEND:
		if(!m_strFileName.IsEmpty() && m_pClient)
		{
			COpCode_REQFILENAMEANSWER stMsg;
			md4cpy(&stMsg._Hash, &m_Hash);
			stMsg._FileName	= m_strFileName;
			g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);
		}
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// Start file upload
CTask_UploadReqResult::CTask_UploadReqResult(HashType Hash, CEmClient_Peer* pClient)
	:m_nState(TASK_READ)
	,m_pFile(NULL)
	,m_pClient(pClient)
{
	md4cpy(&m_Hash, &Hash);
}

//////////////////////////////////////////////////////////////////////
bool CTask_UploadReqResult::Process()
{
	switch(m_nState)
	{
	case TASK_READ:
		// If file does not exists, m_pFile becomes NULL
		if(!g_stEngine.Files.SharedFiles.m_mapSharedFiles.IsEmpty())
			m_pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash.hash);
		m_nState = TASK_SEND;
		g_stEngine.Sockets.Push(this);
		return false;
	case TASK_SEND:
		if(m_pClient)
		{
			if(m_pFile != NULL)
			{
				//COpCode_ACCEPTUPLOADREQ stMsg;
				//g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);

				//m_pClient->Mule->ReqFile = m_pFile;
				// Request this file
				if(m_pClient->Mule)
					m_pClient->Mule->RequestFile(m_pFile);
			}
			else
			{
				// We don't have the file
				COpCode_FILEREQANSNOFIL stMsg;
				md4cpy(&stMsg._Hash, &m_Hash);
				g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);
			}
		}
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// Send requested block
CTask_SendBlock::CTask_SendBlock(HashType Hash, CEmClient_Peer* pClient, DWORD dwStart, DWORD dwEnd)
{
	m_nState = TASK_READ;
	md4cpy(&m_Hash, &Hash);
	m_pClient = pClient;
	m_dwStart = dwStart;
	m_dwEnd = dwEnd;
	m_dwToGo = 0;
	m_pFileData = NULL;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendBlock::Process()
{
	switch(m_nState)
	{
	case TASK_READ:
		if(!g_stEngine.Files.SharedFiles.m_mapSharedFiles.IsEmpty())
		{
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash.hash);
			if(pFile && m_dwStart < pFile->GetFileSize())
			{
				// Check if this file was requested
				if(m_pClient->Mule == NULL || m_pClient->Mule->ReqFile != pFile)
					return true;

				DWORD dwPart = m_dwStart / PARTSIZE;
				DWORD dwStart = dwPart * PARTSIZE;
				DWORD dwEnd = ((pFile->GetFileSize() - dwStart) > PARTSIZE) ? (dwStart + PARTSIZE) : pFile->GetFileSize();
				//	Everyone is limited to a single chunk.
				//	Check that m_dwStartOffset and m_dwEndOffset are in the same chunk and
				//	make sure we don't pass the end of the file.
				if((dwPart != ((m_dwEnd - 1) / PARTSIZE)) || (m_dwEnd > dwEnd))
				{
					//	m_dwEnd goes into the next chunk or is beyond the file end.
					//	Set it to the end of the chunk that m_dwStartOffset is in.
					m_dwEnd = dwEnd;
				}
				//	This can't be a wrapped around request, since it has been limited to a single chunk.
				m_dwToGo = m_dwEnd - m_dwStart;
				//	Create a buffer for file data before we start to work with the file
				m_pFileData = new BYTE[m_dwToGo + 500];
				int	iRc = pFile->ReadFileForUpload(m_dwStart, m_dwToGo, m_pFileData);
				if (iRc >= 0)
				{
					m_nState = TASK_SEND;
					g_stEngine.Sockets.Push(this);
					return false;
				}
				else
					delete[] m_pFileData;
			}
		}
		return true;
	case TASK_SEND:
		if(m_pClient && m_pFileData)
		{
			COpCode_SENDINGPART stMsg;
			md4cpy(&stMsg._Hash, &m_Hash);
			stMsg._StartData = m_dwStart;
			stMsg._EndData = m_dwEnd;
			stMsg._Data = new BYTE[m_dwToGo];
			CopyMemory(stMsg._Data, m_pFileData, m_dwToGo);
			g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);
			delete[] m_pFileData;
		}
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// Send file status
CTask_SendFileStatus::CTask_SendFileStatus(HashType Hash, CEmClient* pClient)
{
	m_nState = TASK_READ;
	md4cpy(&m_Hash, &Hash);
	m_pClient = pClient;
	m_pFileStatus = NULL;
	m_nStatusSize = 0;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendFileStatus::Process()
{
	switch(m_nState)
	{
	case TASK_READ:
		if(!g_stEngine.Files.SharedFiles.m_mapSharedFiles.IsEmpty())
		{
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash.hash);
			if(pFile)
			{
//				CSafeMemFile packetStream(16);
//				((CPartFile*)pFile)->WritePartStatus(&packetStream);
//				m_nStatusSize = packetStream.GetLength();
//				m_pFileStatus = new BYTE[m_nStatusSize];
//				packetStream.Write(m_pFileStatus, m_nStatusSize);

				m_nStatusSize = pFile->GetED2KPartCount();
				m_pFileStatus = new BYTE[m_nStatusSize];
				for(int i = 0; i < m_nStatusSize; i++)
					m_pFileStatus[i] = 1;

				m_nState = TASK_SEND;
				g_stEngine.Sockets.Push(this);
				return false;
			}
		}
		return true;
	case TASK_SEND:
		if(m_pClient && m_pFileStatus)
		{
			COpCode_FILESTATUS stMsg;
			md4cpy(&stMsg._Hash, &m_Hash);
			for(int i = 0; i < m_nStatusSize; i++)
				stMsg._FileStatus.push_back(m_pFileStatus[i]);
			g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);
			delete[] m_pFileStatus;
		}
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
// Send file hashsets
CTask_SendHashsets::CTask_SendHashsets(HashType Hash, CEmClient* pClient)
{
	m_nState = TASK_READ;
	md4cpy(&m_Hash, &Hash);
	m_pClient = pClient;
	m_pFileHashes = NULL;
	m_nHashCount = 0;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendHashsets::Process()
{
	switch(m_nState)
	{
	case TASK_READ:
		if(!g_stEngine.Files.SharedFiles.m_mapSharedFiles.IsEmpty())
		{
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash.hash);
			if(pFile && pFile->GetHashSet() != NULL)
			{
				m_nHashCount = pFile->GetHashCount();
				m_pFileHashes = new HashType[m_nHashCount];
				CopyMemory(m_pFileHashes, pFile->GetHashSet(), sizeof(HashType)*m_nHashCount);

				m_nState = TASK_SEND;
				g_stEngine.Sockets.Push(this);
				return false;
			}
		}
		return true;
	case TASK_SEND:
		if(m_pClient && m_pFileHashes)
		{
			COpCode_HASHSETANSWER stMsg;
			md4cpy(&stMsg._Hash, &m_Hash);
			for(int i = 0; i < m_nHashCount; i++)
				stMsg._Hashsets.push_back(m_pFileHashes[i]);
			g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);
			delete[] m_pFileHashes;
		}
	}
	return true;
}
@


1.27
log
@v2 - minor improvements
@
text
@d65 2
d80 2
a81 34
	COpCode_HELLOANSWER stMsg;
	md4cpy(&stMsg._UserHash, g_stEngine.Prefs.GetUserHash());
	stMsg._ClientAddr.Addr = g_stEngine.GetClientID();
	stMsg._ClientAddr.Port = g_stEngine.Prefs.GetPort();
	stMsg._UserName = g_stEngine.Prefs.GetUserNick();
	stMsg._SoftVersion = EDONKEYVERSION;
	stMsg._UserUDPPort = g_stEngine.Prefs.GetUDPPort();
	stMsg._MiscOptions = 		
		(4						<< 4*6) |	// UDP version
		(1						<< 4*5) |	// Data compression version
		(0/*dwSupportSecIdent*/	<< 4*4) |	// Secure Ident
		(0/*2*/					<< 4*3) |	// Source Exchange
		(2						<< 4*2) |	// Ext. Requests
		(1						<< 4*1) |	// Comments
		(1/*dwNoViewSharedFiles*/<< 1*2);	// No View Shared files
	stMsg._MuleVersion = 
		(PLUS_COMPATIBLECLIENTID << 24) | 
		((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
		((CURRENT_PLUS_VERSION & 0xF0) << 6) | 
		((CURRENT_PLUS_VERSION & 0x7) << 7);
	/*	if(g_stEngine.ServerState.IsConnecting() || g_stEngine.ServerState.IsConnected())
	{
	stMsg._ServerAddr._IPAddr = g_stEngine.ServerState.nAddr;
	stMsg._ServerAddr._Port = g_stEngine.ServerState.nPort;
	}
	else
	{
	stMsg._ServerAddr._IPAddr = 0;
	stMsg._ServerAddr._Port = 0;
	}*/

	g_stEngine.SendOpCode(m_hSocket, stMsg, pClient);

	if (1/*emule protocol supported*/)
d83 3
a85 1
		SendEmuleInfoAnswer(m_hSocket, pClient);
d243 1
a243 6
// sending HELLO opcode.
//	MOREVIT: If I'm understanding this correctly, you're saying that
//		when another client connects to us to say HELLO, we're going
//		a HELLO back. What's the point in that? Once the HELLOANSWER
//		is received, both sides have all the information they need
//		about the other.
d249 1
a249 1
	if (m_iMessage == FD_CONNECT && !m_pPeer->m_bFromOutside)
d251 1
a251 2
		COpCode_HELLO		stMsg;

d257 15
a271 3
		stMsg._UserPort = g_stEngine.Prefs.GetPort();

		if (g_stEngine.ServerState.IsConnected())
d273 2
a274 2
			stMsg._ServerAddr.Addr = g_stEngine.ServerState.nAddr;
			stMsg._ServerAddr.Port = g_stEngine.ServerState.nPort;
d278 3
a280 3
			stMsg._ServerAddr.Addr = 0;
			stMsg._ServerAddr.Port = 0;
		}
d283 5
a465 2
			if(m_pClient->Mule)
				m_pClient->Mule->ReqFile = m_pFile;
d471 1
d473 2
a474 1
				m_pClient->Mule->RequestFile(m_pFile);
@


1.26
log
@v2 - little improvements
@
text
@d490 2
a491 2
				// Add client to waiting queue
				g_stEngine.ClientList.AddToWaitingQueue(m_pClient->Mule);
@


1.25
log
@v2 - little improvements
@
text
@d146 1
d167 1
d195 2
d224 1
d245 1
d474 1
d487 5
a491 2
				COpCode_ACCEPTUPLOADREQ stMsg;
				g_stEngine.SendOpCode(m_pClient->m_hSocket, stMsg, m_pClient);
d495 1
@


1.24
log
@v2 - more improvements
@
text
@a8 1
#include "../../OtherFunctions.h"
d11 1
a11 1

d57 1
a57 1
		 pClient->Mule = g_stEngine.Sockets.m_ClientList.FindMuleClient(_UserHash);
d62 1
a62 1
		g_stEngine.Sockets.m_ClientList.AddClient(pMule);
d65 2
@


1.23
log
@v2 - minor rearrangements, started defining client and clientlist
@
text
@d1 1
a1 1
// Tasks.cpp: implementation of the CTasks class.
a9 1
#include "../../Preferences.h"
d57 2
a58 2
	if(pClient->m_pMule == NULL)
		 pClient->m_pMule = g_stEngine.Sockets.m_ClientList.FindMuleClient(_UserHash);
d60 1
a60 1
	if(pClient->m_pMule == NULL)
d62 3
a64 2
		pClient->m_pMule = new CClientMule(_ClientAddr, _UserHash);
		g_stEngine.Sockets.m_ClientList.AddClient(pClient->m_pMule);
d68 3
a70 3
	if(_UserName.Valid)		pClient->m_pMule->UserName = _UserName;
	if(_SoftVersion.Valid)	pClient->m_pMule->ClientVersion = _SoftVersion;
	if(_UserPort.Valid)		pClient->m_pMule->ClientPort = _UserPort;
d72 1
a72 1
	if(_UserUDPPort.Valid)	pClient->m_pMule->ClientUDPPort = _UserUDPPort;
d74 1
a74 1
	if(_MuleVersion.Valid)	pClient->m_pMule->MuleVersion = _MuleVersion;
a260 279
//////////////////////////////////////////////////////////////////////
// Server OpCodes
//////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER MESSAGE
bool COpCode_SERVERMESSAGE::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	CEmClient_Server* pSrv = reinterpret_cast<CEmClient_Server*>(pClient);

	// Increase message count
	m_nMsgCount = pSrv->m_nMsgCount++;

	TRACE("MESSAGE FROM SERVER: %s\n", _Msg);

//	m_Server._Addr = pSrv->m_dwAddr;
//	m_Server._Port = pSrv->m_uPort;

//	stEngine.PushToUI(this);

	return false; // Always return false when going to GUI, otherwise this object will be destroyed!
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER MESSAGE in GUI
/*bool COpCode_SERVERMESSAGE::ProcessForUI()
{
	// Print message
	g_eMuleApp.m_pdlgEmule->AddServerMessageLine(_Msg);

	// Check for server version
	if ((m_nMsgCount < 2) && (_Msg.Left(14).CompareNoCase(_T("server version")) == 0))
	{
		CString strVer = _Msg.Mid(14);
		strVer.Trim();
		strVer = strVer.Left(64); // Truncate string to avoid misuse by servers in showing ads
		int n = strVer.FindOneOf("\x09\x0A\x0D");
		if (n >= 0)
			strVer = strVer.Left(n);
		CServer* pServer = g_eMuleApp.m_pServerList->GetServerByIP(m_Server._Addr, m_Server._Port);
		if (pServer)
			pServer->SetVersion(strVer);
	}

	// Check for dynamic IP
	int nDynIP = _Msg.Find(_T("[emDynIP: "));
	int nCloseBracket = _Msg.Find(_T("]"));
	if (nDynIP != -1 && nCloseBracket != -1 && nDynIP < nCloseBracket)
	{
		CString sDynIP = _Msg.Mid(nDynIP + 10, nCloseBracket - (nDynIP + 10));
		sDynIP.Trim(_T(" "));
		if (sDynIP.GetLength() && sDynIP.GetLength() < 51)
		{
			CServer* pServer = g_eMuleApp.m_pServerList->GetServerByIP(m_Server._Addr, m_Server._Port);
			if (pServer)
			{
				pServer->SetDynIP(sDynIP.GetBuffer());
				g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
			}
		}
	}

	return true;
}*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ID CHANGE
bool COpCode_IDCHANGE::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// TODO: Smart ID checks, notifiers

	// Disconnect from previous connected server, if any
	if(g_stEngine.GetServerSocket() != pClient->m_hSocket &&
		g_stEngine.GetServerSocket())
		g_stEngine.DisconnectFromServer(g_stEngine.GetServerSocket());

	// Set server connection info
	g_stEngine.ConnectedTo(reinterpret_cast<CEmClient_Server*>(pClient));
	g_stEngine.SetClientID(_NewClientID);
	g_stEngine.SetConnectionState(SERVER_CONNECTED);

/*
	if (g_eMuleApp.m_pGlobPrefs.GetAddServersFromConn())
	{
		Packet* packet = new Packet(OP_GETSERVERLIST);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
		SendPacket(packet,true);
	}
	if(g_eMuleApp.m_pGlobPrefs.RestartWaiting())
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.RestartWaitingDownloads();
 */

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SEARCH RESULT
bool COpCode_SEARCHRESULT::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// FOUND SOURCES
bool COpCode_FOUNDSOURCES::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER STATUS
bool COpCode_SERVERSTATUS::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	// Set address and port
//	m_Server._Addr = pClient->m_dwAddr;
//	m_Server._Port = pClient->m_uPort;

//	stEngine.PushToUI(this);

	TRACE("SERVER STATUS: %u users, %u files\n", _NumberOfUsers, _NumberOfFiles);

	return false; // Always return false when going to GUI, otherwise this object will be destroyed!
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER STATUS in GUI
/*bool COpCode_SERVERSTATUS::ProcessForUI()
{
	CServer* pServer = g_eMuleApp.m_pServerList->GetServerByIP(m_Server._Addr, m_Server._Port);
	if (pServer)
	{
		pServer->SetUserCount(_NumberOfUsers); 
		pServer->SetFileCount(_NumberOfFiles);
		g_eMuleApp.m_pdlgEmule->ShowUserCount(_NumberOfUsers, _NumberOfFiles);
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
	}

	return true;
}*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER IDENTification
bool COpCode_SERVERIDENT::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SERVER LIST
bool COpCode_SERVERLIST::ProcessForClient(CEmClient_Peer* pClient)
{
	ASSERT(pClient); // this opcode is processed only in the main context

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CALLBACKREQUEST is a Client => Server message and should never be
//		received by a client.
bool COpCode_CALLBACKREQUEST::ProcessForClient(CEmClient_Peer *pClient)
{
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CALLBACKFAIL (if it is ever received by a client) is ignored by
//		eMulePlus.
bool COpCode_CALLBACKFAIL::ProcessForClient(CEmClient_Peer *pClient)
{
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CALLBACK REQUESTED
bool COpCode_CALLBACKREQUESTED::ProcessForClient(CEmClient_Peer* )
{
	CTask_SayHelloToPeer   *pSayHelloTask = new CTask_SayHelloToPeer();
	CTask_Connect		   *pTask = new CTask_Connect(_ClientAddr.Addr, _ClientAddr.Port, T_CLIENT_PEER, pSayHelloTask);

	g_stEngine.Sockets.Push(pTask);

	AddDebugLogLine("Callback requested");

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LOGIN REQUEST
bool COpCode_LOGINREQUEST::ProcessForClient(CEmClient_Peer* )
{
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_LoginToServer::Process()
{
	//	Reset message count
	//	m_pServer->m_nMsgCount = 0;
	if (m_pServer == NULL)
	{
		//	Report error...
		return true;
	}
	if (m_iMessage == FD_CONNECT)
	{
		//
		//	We've just connected. Make sure we're prepared to handle disconnect.
		CTask_DisconnectServer		*pOnDisconnectTask = new CTask_DisconnectServer();

		pOnDisconnectTask->m_pServer = m_pServer;
		m_pServer->m_pOnCompletionTask = pOnDisconnectTask;

		//	Disconnect from previous connected server, if any
		if ( g_stEngine.GetServerSocket() != m_pServer->m_hSocket
			&& g_stEngine.GetServerSocket() != 0 )
		{
			g_stEngine.DisconnectFromServer(g_stEngine.GetServerSocket());
		}

		//	Set connection info
		g_stEngine.ConnectedTo(m_pServer);
		g_stEngine.SetConnectionState(SERVER_WAITFORLOGIN);

		COpCode_LOGINREQUEST		stMsg;

		md4cpy(&stMsg._UserHash, g_stEngine.Prefs.GetUserHash());
		stMsg._ClientAddr.Addr = g_stEngine.GetClientID();
		stMsg._ClientAddr.Port = g_stEngine.Prefs.GetPort();
		stMsg._UserName = g_stEngine.Prefs.GetUserNick();
		stMsg._ClientSoftVersion = EDONKEYVERSION;
		stMsg._UserPort = g_stEngine.Prefs.GetPort();
		stMsg._Flags = SRVCAP_ZLIB | SRVCAP_AUXPORT | SRVCAP_NEWTAGS;
		stMsg._eMuleVersion = (PLUS_COMPATIBLECLIENTID << 24) | ((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
			((CURRENT_PLUS_VERSION & 0xF0) << 6) | ((CURRENT_PLUS_VERSION & 0x7) << 7);

		g_stEngine.SendOpCode(m_pServer->m_hSocket, stMsg, m_pServer);
	}
	else
	{
		//	We're not expecting this.
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_DisconnectServer::Process()
{
	if (m_pServer == NULL)
		return true;

	// (!) at any reason, can be even if we tried to connect and failed

	if (m_iMessage == FD_CLOSE)
	{
		// Set connection info
		if (g_stEngine.GetServerSocket() == m_pServer->m_hSocket)
		{
			g_stEngine.SetConnectionState(SERVER_DISCONNECTED);
		}
		else
		{
			// removed if, because we can get 'disconnected' even if we didn't
			// succeeded to connect yet, thus GetConnectingServer() won't return
			// correct value
			// if(rEngine.GetConnectingServer() == m_hSocket)
			g_stEngine.SetConnectionState(SERVER_DISCONNECTED);
			// TODO: mark somewhere that server is dead
		}
	}
	else
	{
		//	We're not expecting this.
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d453 4
a456 1
CTask_UploadReqResult::CTask_UploadReqResult(HashType Hash, CEmClient* pClient)
a457 1
	m_nState = TASK_READ;
a458 1
	m_pClient = pClient;
a466 1
		m_bFound = false;
d468 1
a468 5
		{
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash.hash);
			if(pFile)
				m_bFound = true;
		}
d475 3
a477 1
			if(m_bFound)
d495 1
a495 1
CTask_SendBlock::CTask_SendBlock(HashType Hash, CEmClient* pClient, DWORD dwStart, DWORD dwEnd)
d517 4
@


1.22
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d57 18
a74 3
//	CTask_HelloAnswer* pTask = new CTask_HelloAnswer(m_hSocket, pClient);
//	if(pTask)
//		g_stEngine.Sockets.Push(pTask);
d76 1
a76 1
	//	// here we should grab all user's info
d78 3
a80 3
	md4cpy(stMsg._UserHash, g_stEngine.Prefs.GetUserHash());
	stMsg._ClientAddr._IPAddr = g_stEngine.GetClientID();
	stMsg._ClientAddr._Port = g_stEngine.Prefs.GetPort();
d82 1
a82 1
	stMsg._ClientSoftVersion = EDONKEYVERSION;
d92 1
a92 1
	stMsg._ClientMuleVersion = 
d440 1
a440 1
	CTask_Connect		   *pTask = new CTask_Connect(_ClientAddr._IPAddr, _ClientAddr._Port, T_CLIENT_PEER, pSayHelloTask);
d488 3
a490 3
		md4cpy(stMsg._UserHash, g_stEngine.Prefs.GetUserHash());
		stMsg._ClientAddr._IPAddr = g_stEngine.GetClientID();
		stMsg._ClientAddr._Port = g_stEngine.Prefs.GetPort();
d558 3
a560 3
		md4cpy(stMsg._UserHash, g_stEngine.Prefs.GetUserHash());
		stMsg._ClientAddr._IPAddr = g_stEngine.GetClientID();
		stMsg._ClientAddr._Port = g_stEngine.Prefs.GetPort();
d562 1
a562 1
		stMsg._ClientSoftVersion = EDONKEYVERSION;
d567 2
a568 2
			stMsg._ServerAddr._IPAddr = g_stEngine.ServerState.nAddr;
			stMsg._ServerAddr._Port = g_stEngine.ServerState.nPort;
d572 2
a573 2
			stMsg._ServerAddr._IPAddr = 0;
			stMsg._ServerAddr._Port = 0;
d673 3
a675 3
				md4cpy(stFile._Hash, m_Files[i]._Hash);
				stFile._ClientAddr._IPAddr	= m_Files[i]._ClientID;
				stFile._ClientAddr._Port	= m_Files[i]._ClientPort;
d693 1
a693 1
CTask_SendRequestedFileName::CTask_SendRequestedFileName(BYTE Hash[16], CEmClient* pClient)
d696 1
a696 1
	md4cpy(m_Hash, Hash);
d708 1
a708 1
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash);
d722 1
a722 1
			md4cpy(stMsg._Hash, m_Hash);
d732 1
a732 1
CTask_UploadReqResult::CTask_UploadReqResult(BYTE Hash[16], CEmClient* pClient)
d735 1
a735 1
	md4cpy(m_Hash, Hash);
d748 1
a748 1
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash);
d766 1
a766 1
				md4cpy(stMsg._Hash, m_Hash);
d776 1
a776 1
CTask_SendBlock::CTask_SendBlock(BYTE Hash[16], CEmClient* pClient, DWORD dwStart, DWORD dwEnd)
d779 1
a779 1
	md4cpy(m_Hash, Hash);
d795 1
a795 1
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash);
d830 1
a830 1
			md4cpy(stMsg._Hash, m_Hash);
d844 1
a844 1
CTask_SendFileStatus::CTask_SendFileStatus(BYTE Hash[16], CEmClient* pClient)
d847 1
a847 1
	md4cpy(m_Hash, Hash);
d861 1
a861 1
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash);
d885 1
a885 1
			md4cpy(stMsg._Hash, m_Hash);
d897 1
a897 1
CTask_SendHashsets::CTask_SendHashsets(BYTE Hash[16], CEmClient* pClient)
d900 1
a900 1
	md4cpy(m_Hash, Hash);
d914 1
a914 1
			CKnownFile* pFile = g_stEngine.Files.SharedFiles.GetFileByID(m_Hash);
d918 2
a919 2
				m_pFileHashes = new HASH[m_nHashCount];
				CopyMemory(m_pFileHashes, pFile->GetHashSet(), sizeof(HASH)*m_nHashCount);
d931 1
a931 1
			md4cpy(stMsg._Hash, m_Hash);
@


1.21
log
@v2 - opcodes handling improvement, webserver enhancement
@
text
@a5 1

d7 2
a9 1
#include "TasksOpcodes.h"
d11 16
a26 1
#include "../Files/TaskProcessorFiles.h"
d32 19
d53 1
a53 1
bool COpCode_HELLO::ProcessForClient(CEmClient* pClient)
d72 2
a73 2
		(1/*dwSupportSecIdent*/	<< 4*4) |	// Secure Ident
		(2						<< 4*3) |	// Source Exchange
d97 1
a97 1
		// send emuleinfo
d105 35
a139 1
bool COpCode_HELLOANSWER::ProcessForClient(CEmClient*)
d144 3
a146 1
bool COpCode_EMULEINFO::ProcessForClient(CEmClient* pClient)
d148 5
a152 1
	// send answer
d157 3
a159 1
bool COpCode_EMULEINFOANSWER::ProcessForClient(CEmClient* pClient)
d165 76
a240 2
// OFFER FILES
bool COpCode_OFFERFILES::ProcessForClient(CEmClient*)
d252 1
a252 1
bool COpCode_SERVERMESSAGE::ProcessForClient(CEmClient* pClient)
d254 2
d313 1
a313 1
bool COpCode_IDCHANGE::ProcessForClient(CEmClient* pClient)
d344 1
a344 1
bool COpCode_SEARCHRESULT::ProcessForClient(CEmClient* pClient)
d352 1
a352 1
bool COpCode_FOUNDSOURCES::ProcessForClient(CEmClient* pClient)
a355 43
	// Checking and adding sources (logic moved from PartFile.cpp, later should make this separate task),
	// later rebuild (?) PartFile to separate task processor
/*	if (CPartFile* pFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(_Hash))
	{
		if(  !(pFile->GetStatus() == PS_STOPPED
			|| pFile->GetStatus() == PS_COMPLETE
			|| pFile->GetStatus() == PS_COMPLETING))
		{
			byte debug_lowiddropped = 0;
			byte debug_possiblesources = 0;

			//	If there is needed place for more sources, just remove NNS
			if ( pFile->GetSourceCount() + _Sources.GetSize() > g_eMuleApp.m_pGlobPrefs.GetMaxSourcePerFile()
				&& ((pFile->GetLastPurgeTime() == 0) || (::GetTickCount() - pFile->GetLastPurgeTime()) > PURGE_TIME) )
			{
				pFile->RemoveNoNeededSources(pFile->GetSourceCount() + _Sources.GetSize() - g_eMuleApp.m_pGlobPrefs.GetMaxSourcePerFile());
			}

			for (int i = 0; i < _Sources.GetSize(); i++)
			{
				//	check first if we are this source
				if (stEngine.IsConnected() && stEngine.IsLowID())
				{
					if ((stEngine.GetClientID() == _Sources[i]._Addr) )
// should fix that later, when add FullIP workout
//						&& inet_addr(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetFullIP()) == pClient->m_dwAddr)
						continue;
				}
				else if (stEngine.GetClientID() == _Sources[i]._Addr)
					continue;
				else if (_Sources[i]._Addr < 0x1000000 && !stEngine.IsLocalServer(pClient->m_dwAddr, pClient->m_uPort))
					continue;

				if (g_eMuleApp.m_pGlobPrefs.GetMaxSourcePerFile() > pFile->GetSourceCount())
				{
					CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(pFile, _Sources[i]._Addr, _Sources[i]._Port, pClient->m_dwAddr, pClient->m_uPort);
					if (pNewSource)
						pNewSource->SetUserName(GetResString(IDS_SERVER_SOURCE));
				}

			}
		}
	}*/
d360 1
a360 1
bool COpCode_SERVERSTATUS::ProcessForClient(CEmClient* pClient)
d391 1
a391 1
bool COpCode_SERVERIDENT::ProcessForClient(CEmClient* pClient)
d400 1
a400 1
bool COpCode_SERVERLIST::ProcessForClient(CEmClient* pClient)
d409 1
a409 1
bool COpCode_CALLBACKREQUEST::ProcessForClient(CEmClient *pClient)
d416 1
a416 1
bool COpCode_CALLBACKFAIL::ProcessForClient(CEmClient *pClient)
d422 1
a422 1
bool COpCode_CALLBACKREQUESTED::ProcessForClient(CEmClient* )
d435 1
a435 1
bool COpCode_LOGINREQUEST::ProcessForClient(CEmClient* )
d572 3
a574 3
	TASK_SHARED_START	= 0,
	TASK_SHARED_GETLIST	= 1,
	TASK_SHARED_SEND	= 2
d578 1
a578 1
// send list of shared files
d581 1
a581 1
	m_nState = TASK_SHARED_START;
d592 2
a593 2
	case TASK_SHARED_START:
		m_nState = TASK_SHARED_GETLIST;
d596 53
a648 2
	case TASK_SHARED_GETLIST:
		m_nState = TASK_SHARED_SEND;
d651 21
a671 2
	case TASK_SHARED_SEND:
		return true;
d673 2
d676 13
a688 2
	// first collect shared files info
	/*	if(!m_bProcessedUI)
d690 21
a710 15
	stEngine.PushToUI(this);
	return false;
	}
	*/
	// afterwards, send it
	/*	COpCode_OFFERFILES stMsg;
	for(int i = 0; i < m_Files.GetCount(); i++)
	{
	COpCode_OFFERFILES::CStruct_Files file;
	md4cpy(file._Hash, m_Files[i]._Hash);
	file._Client._Addr = 0;
	file._Client._Port = 0;
	file._FileName = m_Files[i]._FileName;
	file._FileSize = m_Files[i]._FileSize;
	stMsg._Files.Add(file);
a711 2
	stEngine.m_stTcp.AllocSend(stEngine.m_stData.GetConnectedServer(), stMsg);
	*/
d714 4
a717 2
/*
bool CTask_HelloAnswer::Process()
d719 4
d724 32
d758 1
a758 1
*/
d760 2
a761 1
/*bool CTask_SendSharedList::ProcessForUI()
d763 11
a773 3
CKnownFile	*pKnownFile;
CCKey		bufKey;
for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != 0; )
d775 55
a829 2
g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
if(pKnownFile)
d831 6
a836 1
OFFEREDFILE File;
d838 41
a878 5
md4cpy(File._Hash, pKnownFile->GetFileHash());
File._Addr = 0;
File._Port = 0;
File._FileName = pKnownFile->GetFileName();
File._FileSize = pKnownFile->GetFileSize();
d880 9
a888 4
m_Files.Add(File);

pKnownFile->SetOfferedToServer(true);
}
d891 33
a923 5
m_bProcessedUI = true;

stEngine.m_stSocketsTP.Push(this);

return false;
a924 1
*/@


1.20
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d32 4
a35 7
	stMsg._UserName.m_strValue = g_stEngine.Prefs.GetUserNick();
	stMsg._UserName.m_bValid = TRUE;
	stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientSoftVersion.m_bValid = TRUE;
	stMsg._UserUDPPort.m_dwValue = g_stEngine.Prefs.GetUDPPort();
	stMsg._UserUDPPort.m_bValid = TRUE;
	stMsg._MiscOptions.m_dwValue = 		
d43 1
a43 2
	stMsg._MiscOptions.m_bValid = TRUE;
	stMsg._ClientMuleVersion.m_dwValue = 
a47 1
	stMsg._ClientMuleVersion.m_bValid = TRUE;
d367 5
a371 9
		stMsg._UserName.m_strValue = g_stEngine.Prefs.GetUserNick();
		stMsg._UserName.m_bValid = true;
		stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
		stMsg._ClientSoftVersion.m_bValid = true;
		stMsg._UserPort.m_dwValue = g_stEngine.Prefs.GetPort();
		stMsg._UserPort.m_bValid = true;
		stMsg._Flags.m_dwValue = SRVCAP_ZLIB | SRVCAP_AUXPORT | SRVCAP_NEWTAGS;
		stMsg._Flags.m_bValid = true;
		stMsg._eMuleVersion.m_dwValue = (PLUS_COMPATIBLECLIENTID << 24) | ((CURRENT_PLUS_VERSION & 0x7F00) << 9) |
a372 1
		stMsg._eMuleVersion.m_bValid = true;
d437 3
a439 6
		stMsg._UserName.m_strValue = g_stEngine.Prefs.GetUserNick();
		stMsg._UserName.m_bValid = TRUE;
		stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
		stMsg._ClientSoftVersion.m_bValid = TRUE;
		stMsg._UserPort.m_dwValue = g_stEngine.Prefs.GetPort();
		stMsg._UserPort.m_bValid = TRUE;
d510 2
a511 4
	file._FileName.m_strValue = m_Files[i]._FileName;
	file._FileName.m_bValid = true;
	file._FileSize.m_dwValue = m_Files[i]._FileSize;
	file._FileSize.m_bValid = true;
@


1.19
log
@v2 - more shared files, other minor changes
@
text
@d23 5
a27 1
//	// here we should grab all user's info
d36 18
a53 1
	if(g_stEngine.IsConnected())
d55 2
a56 2
		stMsg._ServerAddr._IPAddr = g_stEngine.GetConnectedState()->nAddr;
		stMsg._ServerAddr._Port = g_stEngine.GetConnectedState()->nPort;
d60 3
a62 3
		stMsg._ServerAddr._IPAddr = 0;
		stMsg._ServerAddr._Port = 0;
	}
d454 1
a454 1
		if (g_stEngine.IsConnected())
d456 2
a457 2
			stMsg._ServerAddr._IPAddr = g_stEngine.GetConnectedState()->nAddr;
			stMsg._ServerAddr._Port = g_stEngine.GetConnectedState()->nPort;
d491 1
a491 1
	if(!g_stEngine.IsConnected())
d533 3
d537 3
@


1.18
log
@v2 - connecting to server, updated protocol, bugfixes
@
text
@d11 1
d349 2
a350 2
		stMsg._ClientID = g_stEngine.GetClientID();
		stMsg._ClientPort = g_stEngine.Prefs.GetPort();
d453 7
d464 1
a464 1
	m_bProcessedUI = false;
d473 14
@


1.17
log
@v2 - more minor rearrangements
@
text
@d356 5
@


1.16
log
@Connecting preferences and known/shared files
@
text
@d301 1
a301 1
	g_stEngine.PushToSocketsTP(pTask);
@


1.15
log
@Xml and database functionality
@
text
@d10 1
d24 1
a24 1
	md4cpy(stMsg._UserHash, g_stEngine.GetUserHash());
d26 2
a27 2
	stMsg._ClientAddr._Port = g_stEngine.GetPort();
	stMsg._UserName.m_strValue = g_stEngine.GetUserNick();
d161 1
a161 1
	if (g_eMuleApp.m_pGlobPrefs->GetAddServersFromConn())
d167 1
a167 1
	if(g_eMuleApp.m_pGlobPrefs->RestartWaiting())
d199 1
a199 1
			if ( pFile->GetSourceCount() + _Sources.GetSize() > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
d202 1
a202 1
				pFile->RemoveNoNeededSources(pFile->GetSourceCount() + _Sources.GetSize() - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
d220 1
a220 1
				if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > pFile->GetSourceCount())
d347 1
a347 1
		md4cpy(stMsg._UserHash, g_stEngine.GetUserHash());
d349 2
a350 2
		stMsg._ClientPort = g_stEngine.GetPort();
		stMsg._UserName.m_strValue = g_stEngine.GetUserNick();
d354 1
a354 1
		stMsg._UserPort.m_dwValue = g_stEngine.GetPort();
d417 1
a417 1
		md4cpy(stMsg._UserHash, g_stEngine.GetUserHash());
d419 2
a420 2
		stMsg._ClientAddr._Port = g_stEngine.GetPort();
		stMsg._UserName.m_strValue = g_stEngine.GetUserNick();
d424 1
a424 1
		stMsg._UserPort.m_dwValue = g_stEngine.GetPort();
@


1.14
log
@There can be only one engine :-)
@
text
@a7 1
#include "../EmEngine.h"
@


1.13
log
@Compilation fix
@
text
@d10 1
d18 1
a18 1
bool COpCode_HELLO::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d24 4
a27 4
	md4cpy(stMsg._UserHash, stEngine.GetUserHash());
	stMsg._ClientAddr._IPAddr = stEngine.GetClientID();
	stMsg._ClientAddr._Port = stEngine.GetPort();
	stMsg._UserName.m_strValue = stEngine.GetUserNick();
d31 1
a31 1
	if(stEngine.IsConnected())
d33 2
a34 2
		stMsg._ServerAddr._IPAddr = stEngine.GetConnectedState()->nAddr;
		stMsg._ServerAddr._Port = stEngine.GetConnectedState()->nPort;
d42 1
a42 1
	stEngine.SendOpCode(m_hSocket, stMsg, pClient);
d54 1
a54 1
bool COpCode_HELLOANSWER::ProcessForClient(CEmEngine& stEngine, CEmClient*)
d59 1
a59 1
bool COpCode_EMULEINFO::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d66 1
a66 1
bool COpCode_EMULEINFOANSWER::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d73 1
a73 1
bool COpCode_OFFERFILES::ProcessForClient(CEmEngine& stEngine, CEmClient*)
d85 1
a85 1
bool COpCode_SERVERMESSAGE::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d103 1
a103 1
/*bool COpCode_SERVERMESSAGE::ProcessForUI(CEmEngine&)
d144 1
a144 1
bool COpCode_IDCHANGE::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d151 3
a153 3
	if(stEngine.GetServerSocket() != pClient->m_hSocket &&
		stEngine.GetServerSocket())
		stEngine.DisconnectFromServer(stEngine.GetServerSocket());
d156 3
a158 3
	stEngine.ConnectedTo(reinterpret_cast<CEmClient_Server*>(pClient));
	stEngine.SetClientID(_NewClientID);
	stEngine.SetConnectionState(SERVER_CONNECTED);
d175 1
a175 1
bool COpCode_SEARCHRESULT::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d183 1
a183 1
bool COpCode_FOUNDSOURCES::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d234 1
a234 1
bool COpCode_SERVERSTATUS::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d250 1
a250 1
/*bool COpCode_SERVERSTATUS::ProcessForUI(CEmEngine&)
d265 1
a265 1
bool COpCode_SERVERIDENT::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d274 1
a274 1
bool COpCode_SERVERLIST::ProcessForClient(CEmEngine& stEngine, CEmClient* pClient)
d283 1
a283 1
bool COpCode_CALLBACKREQUEST::ProcessForClient(CEmEngine& stEngine, CEmClient *pClient)
d290 1
a290 1
bool COpCode_CALLBACKFAIL::ProcessForClient(CEmEngine &stEngine, CEmClient *pClient)
d296 1
a296 1
bool COpCode_CALLBACKREQUESTED::ProcessForClient(CEmEngine& stEngine, CEmClient* )
d301 1
a301 1
	stEngine.PushToSocketsTP(pTask);
d309 1
a309 1
bool COpCode_LOGINREQUEST::ProcessForClient(CEmEngine& stEngine, CEmClient* )
d314 203
@


1.12
log
@v2 - compressed opcodes
@
text
@d43 1
a43 1
	if (/*emule protocol supported*/)
@


1.11
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d28 2
a29 2
	stMsg._ClientVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientVersion.m_bValid = TRUE;
d43 5
d58 12
@


1.10
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d285 1
a285 1
	AddDebugLogLine(false, "Callback requested");
@


1.9
log
@Modified my modifications for better genericness (I like genericity but it's not in the dictionary :P ).
@
text
@d177 2
a178 2
			uint8 debug_lowiddropped = 0;
			uint8 debug_possiblesources = 0;
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d280 3
a282 1
	CTask_Connect *pTask = new CTask_Connect(_ClientAddr._IPAddr, _ClientAddr._Port, T_CLIENT_PEER);
@


1.7
log
@Formatting, comments, and name changes, the usual.
@
text
@d53 1
a53 1
//////////////////////////////////////////////////////////////////////
d59 1
d65 1
a65 1
//////////////////////////////////////////////////////////////////////
d76 1
a76 1
//	m_Server._Addr = pSrv->m_nAddr;
d83 1
a83 2

//////////////////////////////////////////////////////////////////////
d124 1
a124 2

//////////////////////////////////////////////////////////////////////
d139 1
a139 1
	stEngine.SetClientID(_ClientID);
d155 1
a155 2

//////////////////////////////////////////////////////////////////////
d163 1
a163 2

//////////////////////////////////////////////////////////////////////
d194 1
a194 1
//						&& inet_addr(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetFullIP()) == pClient->m_nAddr)
d199 1
a199 1
				else if (_Sources[i]._Addr < 0x1000000 && !stEngine.IsLocalServer(pClient->m_nAddr, pClient->m_uPort))
d204 1
a204 1
					CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(pFile, _Sources[i]._Addr, _Sources[i]._Port, pClient->m_nAddr, pClient->m_uPort);
d214 1
a214 2

//////////////////////////////////////////////////////////////////////
d221 1
a221 1
//	m_Server._Addr = pClient->m_nAddr;
d230 1
a230 2

//////////////////////////////////////////////////////////////////////
d245 1
a245 2

//////////////////////////////////////////////////////////////////////
d254 1
a254 1
//////////////////////////////////////////////////////////////////////
d262 15
a276 2

//////////////////////////////////////////////////////////////////////
d287 1
a287 2

//////////////////////////////////////////////////////////////////////
d293 1
@


1.6
log
@*** empty log message ***
@
text
@d23 3
a25 3
	md4cpy(stMsg._Hash, stEngine.GetUserHash());
	stMsg._Client._Addr = stEngine.GetClientID();
	stMsg._Client._Port = stEngine.GetPort();
d32 2
a33 2
		stMsg._Server._Addr = stEngine.GetConnectedState()->nAddr;
		stMsg._Server._Port = stEngine.GetConnectedState()->nPort;
d37 2
a38 2
		stMsg._Server._Addr = 0;
		stMsg._Server._Port = 0;
d273 1
a273 1
	CTask_Connect *pTask = new CTask_Connect(_Client._Addr, _Client._Port, T_CLIENT_PEER);
@


1.5
log
@New engine - cosmetic changes
@
text
@d41 1
a41 1
	stEngine.SendOpCode(m_hSocket, stMsg);
@


1.4
log
@New engine - cosmetic changes
@
text
@a8 1
#include "../EngineData.h"
d23 4
a26 4
	md4cpy(stMsg._Hash, stEngine.m_stData.GetUserHash());
	stMsg._Client._Addr = stEngine.m_stData.GetClientID();
	stMsg._Client._Port = stEngine.m_stData.GetPort();
	stMsg._UserName.m_strValue = stEngine.m_stData.GetUserNick();
d30 1
a30 1
	if(stEngine.m_stData.IsConnected())
d32 2
a33 2
		stMsg._Server._Addr = stEngine.m_stData.GetConnectedState()->nAddr;
		stMsg._Server._Port = stEngine.m_stData.GetConnectedState()->nPort;
d41 1
a41 1
	stEngine.m_stTcp.AllocSend(m_hSocket, stMsg);
d134 3
a136 3
	if(stEngine.m_stData.GetServerSocket() != pClient->m_hSocket &&
		stEngine.m_stData.GetServerSocket())
		stEngine.DisconnectFromServer(stEngine.m_stData.GetServerSocket());
d139 3
a141 3
	stEngine.m_stData.ConnectedTo(reinterpret_cast<CEmClient_Server*>(pClient));
	stEngine.m_stData.SetClientID(_ClientID);
	stEngine.m_stData.SetConnectionState(SERVER_CONNECTED);
d193 1
a193 1
				if (stEngine.m_stData.IsConnected() && stEngine.m_stData.IsLowID())
d195 1
a195 1
					if ((stEngine.m_stData.GetClientID() == _Sources[i]._Addr) )
d200 1
a200 1
				else if (stEngine.m_stData.GetClientID() == _Sources[i]._Addr)
d202 1
a202 1
				else if (_Sources[i]._Addr < 0x1000000 && !stEngine.m_stData.IsLocalServer(pClient->m_nAddr, pClient->m_uPort))
d274 1
a274 1
	stEngine.m_stSocketsTP.Push(pTask);
@


1.3
log
@New engine - connecting to server
@
text
@a6 1
#ifdef NEW_SOCKETS
a287 2

#endif@


1.2
log
@New engine - name changes
@
text
@d75 4
a78 3
	// Set address and port
	m_Server._Addr = pSrv->m_nAddr;
	m_Server._Port = pSrv->m_uPort;
d80 1
a80 2
	// Push itself to GUI processing thread
	stEngine.PushToUI(this);
d136 3
a138 6
	if(stEngine.m_stData.GetConnectingServer() != pClient->m_hSocket &&
		stEngine.m_stData.GetConnectingServer())
		stEngine.DisconnectFromServer(stEngine.m_stData.GetConnectingServer());
	if(stEngine.m_stData.GetConnectedServer() != pClient->m_hSocket &&
		stEngine.m_stData.GetConnectedServer())
		stEngine.DisconnectFromServer(stEngine.m_stData.GetConnectedServer());
d143 1
a143 1
	stEngine.m_stData.SetConnectionState(true, SERVER_CONNECTED);
d227 4
a230 2
	m_Server._Addr = pClient->m_nAddr;
	m_Server._Port = pClient->m_uPort;
d232 1
a232 2
	// Push itself to GUI processing thread
	stEngine.PushToUI(this);
@


1.1
log
@New engine
@
text
@d278 1
a278 1
	stEngine.m_stMain.Push(pTask);
@

