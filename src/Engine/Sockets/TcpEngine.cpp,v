head	1.24;
access;
symbols
	PublicRelease_1_2e:1.24
	Interim_Release_1-2e_RC1:1.24
	PublicRelease_1_2d:1.24
	Interim_Release_1-2d_RC1:1.24
	Interim_Release_1-2d_beta1:1.24
	PublicRelease_1_2c:1.24
	Interim_Release_1-2c_RC1:1.24
	Interim_Release_1-2c_beta1:1.24
	PublicRelease_1_2b:1.24
	Interim_Release_1-2b_RC1:1.24
	PublicRelease_1_2a:1.24
	Interim_Release_1-2a_RC1:1.24
	Interim_Release_1-2a_beta2:1.24
	Interim_Release_1-2a_beta1:1.24
	PublicRelease_1_2:1.24
	Interim_Release_1-2_RC1:1.24
	Interim_Release_1-2_beta1:1.24
	PublicRelease_1_1g:1.24
	Interim_Release_1-1g_RC3:1.24
	Interim_Release_1-1g_RC2:1.24
	Interim_Release_1-1g_RC1:1.24
	Interim_Release_1-1g_beta2:1.24
	Interim_Release_1-1g_beta1:1.24
	PublicRelease_1_1f:1.24
	Interim_Release_1-1f_RC1:1.24
	PublicRelease_1_1e:1.24
	Interim_Release_1-1e_RC2:1.24
	Interim_Release_1-1e_RC1:1.24
	Interim_Release_1-1e_beta1:1.24
	PublicRelease_1_1d:1.18
	Interim_Release_1-1d_RC1:1.18
	PublicRelease_1_1c:1.18
	Interim_Release_1-1c_RC1:1.17
	Interim_Release_1-1c_beta2:1.13
	Interim_Release_1-1c_beta1:1.13
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.9
	PublicRelease_1_1a:1.9
	Interim_Release_1-1a_RC2:1.9
	Interim_Release_1-1a_RC1:1.9
	Interim_Release_1-1a_beta2:1.9
	Interim_Release_1-1a_beta1:1.9
	PublicRelease_1_1:1.9
	Interim_Release_1-1_beta1:1.9
	PublicRelease_1o:1.9
	Interim_Release_1o_RC1:1.9
	Interim_Release_1o_beta1:1.9
	PublicRelease_1n:1.9
	Interim_Release_1n_RC2:1.9
	Interim_Release_1n_RC1:1.9
	PublicRelease_1m:1.8
	Interim_Release_1m_beta1:1.8
	PublicRelease_1l:1.8
	Interim_Release_1l_RC3:1.8
	Interim_Release_1l_RC2:1.8
	Interim_Release_1l_RC1:1.8
	Interim_Release_1l_beta2:1.8
	Interim_Release_1l_beta1:1.8
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.2;
locks; strict;
comment	@// @;


1.24
date	2005.04.17.05.16.25;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.07.17.24.50;	author kuchin;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.29.14.36.14;	author kuchin;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.28.19.40.22;	author kuchin;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.27.05.01.52;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.22.22.02.10;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.26.17.52.05;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.23.20.40.43;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.23.19.34.41;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.23.18.58.05;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.18.18.31.25;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.28.20.13.52;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.30.13.39.04;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.11.31.46;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.06.13.57.27;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.05.19.31.56;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.16.14.51.00;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.07.10.54.33;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.07.09.18.16;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.21.10.29.05;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.24
log
@v2 - corrected protocol, tags
@
text
@// TcpEngine.cpp: implementation of the CTcpEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TcpEngine.h"

#include "TasksSockets.h"

#include <process.h>



//////////////////////////////////////////////////////////////////////
// Start
bool CTcpEngine::InitAsync()
{
	if (m_hAsyncInit = CreateEvent(NULL, TRUE, FALSE, NULL))
	{
		// Create a thread for handling standard sockets events
		UINT nThread = 0;
		if (m_hAsyncThread = (HANDLE) _beginthreadex(NULL, 0, SocketWndFunc, this, 0, &nThread))
		{
			// Very well. Wait now until it finishes its initialization
			HANDLE pWait[] = { m_hAsyncInit, m_hAsyncThread };
			if (WAIT_OBJECT_0 == WaitForMultipleObjects(_countof(pWait), pWait, FALSE, 2000))
				return true;	// Everything is ok
		}
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
// stop
void CTcpEngine::UninitAsync()
{
	if (m_hAsyncInit)
	{
		if (m_hAsyncThread)
		{
			if (m_hSocketWnd)
				VERIFY(PostMessage(m_hSocketWnd, WM_QUIT, 0, 0));

			if (WAIT_OBJECT_0 != WaitForSingleObject(m_hAsyncThread, 2000))
			{
				AddLog(LOG_ERROR, _T("Thread has not terminated."));
				if (!TerminateThread(m_hAsyncThread, -1))
					AddLog(LOG_ERROR, _T("TerminateThread failed"));
			}
			VERIFY(CloseHandle(m_hAsyncThread));
			m_hAsyncThread = NULL;
		}

		VERIFY(CloseHandle(m_hAsyncInit));
		m_hAsyncInit = NULL;
	}
	m_nOverlappedIOs = 0;
}

//////////////////////////////////////////////////////////////////////
UINT WINAPI CTcpEngine::SocketWndFunc(PVOID pPtr)
{
	CTcpEngine* pThis = (CTcpEngine*) pPtr;
	ASSERT(pThis);
	if (pThis)
	{
		ASSERT(!pThis->m_hSocketWnd);
		HINSTANCE hInstance = GetModuleHandle(NULL);

		WNDCLASS stWC;
		ZeroMemory(&stWC, sizeof(stWC));
		stWC.hInstance = hInstance;
		stWC.lpfnWndProc = SocketWndProc;
		stWC.lpszClassName = _T("EM_SockWnd");
		stWC.cbWndExtra = sizeof(ULONG_PTR);

		ATOM aClass = RegisterClass(&stWC);
		ASSERT(aClass);

		if (aClass)
		{
			if (pThis->m_hSocketWnd = CreateWindow((LPCTSTR) aClass, _T(""), 0, 0, 0, 0, 0, NULL, NULL, hInstance, NULL))
			{
				CState stState(*pThis);

				SetWindowLong(pThis->m_hSocketWnd, GWL_USERDATA, (long) &stState);

				VERIFY(SetEvent(pThis->m_hAsyncInit));

				SetTimer(pThis->m_hSocketWnd, 1, TIMER_CHECK_TIME, NULL);

				// From now on - run the message loop, so that this thread most of the time
				// is in alertable state.
				for (bool bRun = true; bRun; )
				{
					MsgWaitForMultipleObjectsEx(0, NULL, INFINITE, QS_ALLEVENTS, MWMO_ALERTABLE);

					MSG stMsg;
					while (PeekMessage(&stMsg, NULL, 0, 0, PM_REMOVE))
						if (WM_QUIT == stMsg.message)
							bRun = false;
						else
							DispatchMessage(&stMsg);
				}

				if (IsWindow(pThis->m_hSocketWnd))
					VERIFY(DestroyWindow(pThis->m_hSocketWnd));

				// destroy all our possibly left clients
				for (UINT nIndex = 0; nIndex < _countof(stState.m_pHashTable); nIndex++)
				{
					OVERLAPPED_TCP* pClient = stState.m_pHashTable[nIndex];
					while (pClient)
					{
						OVERLAPPED_TCP* pNext = pClient->m_pNext;
						delete pClient;
						pClient = pNext;
					}
				}

				// Wait until all pending IO operations return with error
				const DWORD PENDING_WAIT_MAX = 1000;
				DWORD dwTicks = GetTickCount();
				while (true)
				{
					if (pThis->m_nOverlappedIOs <= 0)
						break;

					DWORD dwWait = GetTickCount() - dwTicks;
					if (dwWait >= PENDING_WAIT_MAX)
						break;

					dwWait = PENDING_WAIT_MAX - dwWait;
					MsgWaitForMultipleObjectsEx(0, NULL, dwWait, QS_ALLEVENTS, MWMO_ALERTABLE);
				}

				if (pThis->m_nOverlappedIOs)
					AddLog(LOG_ERROR, _T("Overlapped IOs counter is %d"), pThis->m_nOverlappedIOs);
			} else
				ASSERT(FALSE);

			VERIFY(UnregisterClass((LPCTSTR) aClass, hInstance));
		}
	}
	
	return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
LRESULT WINAPI CTcpEngine::SocketWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg)
	{
		case WM_EMSOCKET:
		case WM_EM_ADDINTERFACE:
		case WM_EM_CONNECT:
		case WM_EM_SEND:
		case WM_EM_DISCONNECT:
		case WM_TIMER:
		{
			break;
		}
		default:
		{
			return DefWindowProc(hWnd, uMsg, wParam, lParam);
		}
	}

	CState* pState = (CState*) GetWindowLong(hWnd, GWL_USERDATA);

	ASSERT(pState);

	if (pState)
	{
		switch (uMsg)
		{
			case WM_EMSOCKET:
			{
				OVERLAPPED_TCP* pClient = pState->LookupClient(wParam);

				if (pClient)
				{
					pClient->ProcessEvent(*pState, LOWORD(lParam), HIWORD(lParam));
				}
				break;
			}
			case WM_EM_ADDINTERFACE:
			{
				CInterface* pInterface = (CInterface*) wParam;
				ASSERT(pInterface);
				if (pInterface)
				{
					// associate now a 'client' with this interface
					OVERLAPPED_ACCEPT* pClient = new OVERLAPPED_ACCEPT(*pInterface);
					ASSERT(pClient);
					if (pClient)
					{
						pClient->m_hSocket = pInterface->m_hSocket;
						pState->AddClient(*pClient);

						// just in case there are already pending accept operations
						pClient->ProcessEvent(*pState, FD_ACCEPT, 0);

					} 
					else
					{
						AddLog(LOG_ERROR, _T("No memory"));
						InterlockedDecrement(&pInterface->m_nPendingAccepts);
					}
				}

				InterlockedDecrement(&pInterface->m_nPendingAccepts);

				if (lParam && !SetEvent((HANDLE) lParam))
					AddLog(LOG_ERROR, _T("SetEvent failed"));
				break;
			}
			case WM_EM_CONNECT:
			{
				OVERLAPPED_RECV* pClient = (OVERLAPPED_RECV*)wParam;

				ASSERT(pClient);

				if (pClient != NULL)
				{
					pState->AddClient(*pClient);

					SOCKADDR_IN stAddr;

					stAddr.sin_family = AF_INET;
					stAddr.sin_addr.S_un.S_addr = pClient->m_nPeerAddr;
					stAddr.sin_port = pClient->m_nPeerPort;

					if (connect(pClient->m_hSocket, (sockaddr*)&stAddr, sizeof(stAddr)))
					{
						int		nError = WSAGetLastError();

						if (nError != WSAEWOULDBLOCK)
						{
							pClient->ProcessEvent(*pState, FD_CONNECT, nError);
						}
					}
					else
					{
						pClient->ProcessEvent(*pState, FD_CONNECT, 0);
					}
				}
				break;
			}
			case WM_EM_SEND:
			{
				pState->m_stEngine.OnSend(pState, (OVERLAPPED_SEND*)lParam, (EnumQueuePriority)wParam);
				break;
			}
			case WM_TIMER:
			{
				pState->m_stEngine.OnTimer(pState);
				break;
			}
			case WM_EM_DISCONNECT:
			{
				ASSERT(INVALID_SOCKET != lParam);
				if ((INVALID_SOCKET != lParam) && shutdown((SOCKET) lParam, SD_SEND))
					CTask_Tcp_Err::Post((SOCKET) lParam, WSAGetLastError());

				break;
			}
			default:
			{
				ASSERT(FALSE);
			}
		}
	}

	return 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OnSend(CState* pState, OVERLAPPED_SEND* pSend, EnumQueuePriority ePriority)
{
	pState->SendBlock(pSend);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OnTimer(CState* pState)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTcpEngine::CState::SendBlock(OVERLAPPED_SEND* pSend)
{
	DWORD dwSize = 0;

	InterlockedIncrement(&m_stEngine.m_nOverlappedIOs);

	if (pSend && WSASend(pSend->m_hSocket, pSend, 1, &dwSize, 0, pSend, OVERLAPPED_TCP::OverlappedCompletionFunc))
	{
		int nError = WSAGetLastError();
		// If error happened...
		if (WSA_IO_PENDING != nError)
		{
			InterlockedDecrement(&m_stEngine.m_nOverlappedIOs);

			// Notify the EmEngine about this.
			CTask_Tcp_Err::Post(pSend->m_hSocket, nError);
			delete pSend;

			return false;
		}
	}

	return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_TCP::OverlappedCompletionFunc(DWORD dwError, DWORD dwBytes, OVERLAPPED* pOverlapped, DWORD dwFlags)
{
	OVERLAPPED_TCP* pOverlappedTcp = (OVERLAPPED_TCP*) pOverlapped;
	ASSERT(pOverlappedTcp && pOverlappedTcp->m_pEngine);
	if (pOverlappedTcp && pOverlappedTcp->m_pEngine)
	{
		InterlockedDecrement(&pOverlappedTcp->m_pEngine->m_nOverlappedIOs);
		pOverlappedTcp->ProcessCompletion(*pOverlappedTcp->m_pEngine, dwError, dwBytes);
	}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_TCP::ProcessEvent(CTcpEngine::CState&, int, int)
{
	ASSERT(FALSE);
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_TCP::ProcessCompletion(CTcpEngine&, int, DWORD)
{
	ASSERT(FALSE);
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_TCP::~OVERLAPPED_TCP()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_RECV *CTcpEngine::AllocRecv(T_CLIENT_TYPE eType)
{
	switch (eType)
	{
	case T_CLIENT_WEB:
		return new OVERLAPPED_RECV_WEB;
	case T_CLIENT_XML:
		return new OVERLAPPED_RECV_XML;
	default:
		ASSERT(FALSE); // invalid type
	}

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_ACCEPT::ProcessEvent(CTcpEngine::CState& stState, int nEvent, int nError)
{
	if (nError)
	{
		if (INTERFACE_FLAG_SHUTDOWN & m_stInterface.m_nFlags)
		{
			// self destruct
			stState.DeleteClient(*this);
			delete this;
		}
		else
			AddLog(LOG_ERROR, _T("Accept operation has failed"));
	}
	else
	{
		while (true)
		{
			SOCKADDR_IN		stAddr;
			int				nLen = sizeof(stAddr);
			SOCKET			hSocket = accept(m_hSocket, (sockaddr*) &stAddr, &nLen);

			if (INVALID_SOCKET == hSocket)
			{
				if (WSAEWOULDBLOCK != (nError = WSAGetLastError()))
					AddLog(LOG_ERROR, _T("accept failed"));
				break;
			}

		//	Create now a 'receiver' of relevant type
			OVERLAPPED_RECV* pOverlapped = stState.m_stEngine.AllocRecv(m_stInterface.m_eType);

			if (pOverlapped != NULL)
			{
				pOverlapped->m_hSocket = hSocket;
				pOverlapped->m_pEngine = &stState.m_stEngine;
				pOverlapped->m_nFlags = TCP_RECV_FLAG_CONNECTED | TCP_RECV_FLAG_FIRSTTIME;
				pOverlapped->m_nPeerAddr = stAddr.sin_addr.S_un.S_addr;
				pOverlapped->m_nPeerPort = stAddr.sin_port;

			//	Notify the EmEngine about new connection accepted
				CTask_Tcp_Accepted* pTask = new CTask_Tcp_Accepted;

				if (pTask != NULL)
				{
					pTask->m_hSocket = hSocket;
					pTask->m_nAddr.S_un.S_addr = stAddr.sin_addr.S_un.S_addr;
					pTask->m_uPort = stAddr.sin_port;
					pTask->m_eType = m_stInterface.m_eType;
					g_stEngine.Sockets.Push(pTask);
				} 
				else
					AddLog(LOG_ERROR, _T("No memory"));

				pOverlapped->DisableTcpBufs(stState.m_stEngine);
				pOverlapped->ProcessCompletion(stState.m_stEngine, 0, 0); // will initiate the 1st read operation

			} 
			else
			{
				AddLog(LOG_ERROR, _T("No memory"));
				if(closesocket(hSocket))
					AddLog(LOG_ERROR, _T("closesocket failed"));
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_ACCEPT::ProcessCompletion(CTcpEngine& stEngine, int nError, DWORD dwBytes)
{
	// completion of AcceptEx operation
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_ACCEPT::~OVERLAPPED_ACCEPT()
{
	InterlockedDecrement(&m_stInterface.m_nPendingAccepts);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ProcessEvent(CTcpEngine::CState& stState, int nEvent, int nError)
{
	stState.DeleteClient(*this);
	m_pEngine = &stState.m_stEngine;

//	The only event we expect is FD_CONNECT
	if (FD_CONNECT == nEvent)
	{
		if (nError)
		{
		//	Notify the EMEngine about unsuccessful connection attempt
			CTask_Tcp_Err::Post(m_hSocket, nError);
			
			delete this;
		}
		else
		{
			CTask_Tcp_Connected		*pTask = new CTask_Tcp_Connected;

			if (pTask != NULL)
			{
				pTask->m_hSocket = m_hSocket;
				g_stEngine.Sockets.Push(pTask);
			} 
			else
				AddLog(LOG_ERROR, _T("No memory"));

			DisableTcpBufs(stState.m_stEngine);

			m_nFlags |= TCP_RECV_FLAG_CONNECTED | TCP_RECV_FLAG_FIRSTTIME;
			ProcessCompletion(stState.m_stEngine, 0, 0); // initiate read operation
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ProcessCompletion(CTcpEngine &stEngine, int nError, DWORD dwBytes)
{
	if (nError)
		dwBytes = 0; // of course

	if (TCP_RECV_FLAG_FIRSTTIME & m_nFlags)
	{
		m_nFlags &= ~TCP_RECV_FLAG_FIRSTTIME;
	}
	else
	{
	//	If the packet contains data and it's not too much to fit in the buffer...
		if (dwBytes != 0 && (dwBytes + m_dwBufUsage <= m_dwBufSize))
		{
			m_dwBufUsage += dwBytes;

			DWORD		dwParsed = ParseRecv(stEngine, false);

			if (dwParsed != 0)
			{
				ASSERT(dwParsed <= m_dwBufUsage);

				if (!(m_dwBufUsage -= dwParsed))
				{
					ClearBufs();
				}
			}
			else
			{
				if (m_dwBufSize == m_dwBufUsage)
				{
					if (m_dwBufSize >= TCP_MAX_BUF_SIZE)
					{
						AddLog(LOG_WARNING, _T("The limit has been reached. Discarding."));
						ClearBufs();
					}
					else
					{
					//	Extend the buffer
						DWORD		dwSizeNew = m_dwBufUsage + TCP_OPTIMAL_BUF;
						char	   *pBufNew = new char[dwSizeNew];

						if (pBufNew != NULL)
						{
							CopyMemory(pBufNew, GetBuffer(), m_dwBufUsage);
							if (m_pBufExtra != NULL)
							{
								delete[] m_pBufExtra;
							}
							m_pBufExtra = pBufNew;
							m_dwBufSize = dwSizeNew;

						}
						else
						{
							AddLog(LOG_ERROR, _T("No memory"));
							ClearBufs();
						}
					}
				}
			}
		}
		else
		{
			// the peer has called shutdown
			ParseRecv(stEngine, true);

			CTask_Tcp_Err::Post(m_hSocket, 0);

			delete this;
			return;
		}
	}

	// initiate another read operation
	buf = GetBuffer() + m_dwBufUsage;
	VERIFY(len = m_dwBufSize - m_dwBufUsage);

	ZeroMemory((OVERLAPPED*) this, sizeof(OVERLAPPED)); // for more safety

	InterlockedIncrement(&stEngine.m_nOverlappedIOs);

	DWORD dwFlag = 0;
	if (WSARecv(m_hSocket, this, 1, &dwBytes, &dwFlag, this, OverlappedCompletionFunc))
	{
		int nError = WSAGetLastError();
		if (WSA_IO_PENDING != nError)
		{
			// oops
			InterlockedDecrement(&stEngine.m_nOverlappedIOs);
			// notify EMEngine about this error
			CTask_Tcp_Err::Post(m_hSocket, nError);
			delete this;
		}
	}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::DisableTcpBufs(CTcpEngine& stEngine)
{
	// From now on we are not interested in futher notifications
	if (WSAAsyncSelect(m_hSocket, stEngine.m_hSocketWnd, 0, 0))
		AddLog(LOG_ERROR, _T("WSAAsyncSelect failed"));

	// disable both read and write built-in socket buffers
	DWORD dwZero = 0;
	if (setsockopt(m_hSocket, SOL_SOCKET, SO_RCVBUF, (char*) &dwZero, sizeof(dwZero)) ||
		setsockopt(m_hSocket, SOL_SOCKET, SO_SNDBUF, (char*) &dwZero, sizeof(dwZero)))
	{
		AddLog(LOG_ERROR, _T("setsockopt failed"));
	}
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ClearBufs()
{
	if (m_pBufExtra)
	{
		delete[] m_pBufExtra;
		m_pBufExtra = NULL;
	}
	m_dwBufUsage = 0;
	m_dwBufSize = sizeof(m_pBuf);
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_RECV::~OVERLAPPED_RECV()
{
	ClearBufs();
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_SEND::ProcessCompletion(CTcpEngine& stEngine, int nError, DWORD dwBytes)
{
	if (nError)
		// notify EMEngine about this error
		CTask_Tcp_Err::Post(m_hSocket, nError);
	delete this;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::CState::AddClient(OVERLAPPED_TCP& stClient)
{
	OVERLAPPED_TCP*& pFirst = m_pHashTable[stClient.m_hSocket % _countof(m_pHashTable)];
	if (pFirst)
	{
		ASSERT(!pFirst->m_pPrev);
		pFirst->m_pPrev = &stClient;
	}
	stClient.m_pNext = pFirst;
	pFirst = &stClient;
}

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_TCP* CTcpEngine::CState::LookupClient(SOCKET hSocket)
{
	for (OVERLAPPED_TCP* pClient = m_pHashTable[hSocket % _countof(m_pHashTable)]; pClient; pClient = pClient->m_pNext)
		if (pClient->m_hSocket == hSocket)
			break;

	return pClient;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::CState::DeleteClient(CTcpEngine::OVERLAPPED_TCP& stClient)
{
	if (stClient.m_pNext)
	{
		ASSERT(stClient.m_pNext->m_pPrev == &stClient);
		stClient.m_pNext->m_pPrev = stClient.m_pPrev;
	}
	if (stClient.m_pPrev)
	{
		ASSERT(stClient.m_pPrev->m_pNext == &stClient);
		stClient.m_pPrev->m_pNext = stClient.m_pNext;
	} else
	{
		OVERLAPPED_TCP*& pFirst = m_pHashTable[stClient.m_hSocket % _countof(m_pHashTable)];
		if (pFirst == &stClient)
			pFirst = stClient.m_pNext;
		else
			ASSERT(FALSE); // must not happen !!!
	}
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::Init()
{
	WSADATA stData;
	if (WSAStartup(MAKEWORD(2, 2), &stData))
		AddLog(LOG_ERROR, _T("WSAStartup failed"));
	else
	{
		m_bWinsockInit = true;
		return InitAsync();
	}
	return false;
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::AddInterface(USHORT nPort, T_CLIENT_TYPE eType, ULONG uListen)
{
	SOCKET hSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (INVALID_SOCKET != hSocket)
	{
		SOCKADDR_IN stAddr;
		stAddr.sin_family = AF_INET;
		stAddr.sin_addr.S_un.S_addr = uListen;	// INADDR_ANY
		stAddr.sin_port = htons(nPort);

		if (!bind(hSocket, (sockaddr*) &stAddr, sizeof(stAddr)) &&
			!WSAAsyncSelect(hSocket, m_hSocketWnd, WM_EMSOCKET, FD_ACCEPT) &&
			!listen(hSocket, SOMAXCONN))
		{
			// very well.
			CInterface* pInterface = new CInterface;
			ASSERT(pInterface);
			if (pInterface)
			{
				pInterface->m_hSocket = hSocket;
				pInterface->m_uPort = nPort;
				pInterface->m_eType = eType;
				pInterface->m_nPendingAccepts = 1;

				if (PostMessage(m_hSocketWnd, WM_EM_ADDINTERFACE, (WPARAM) pInterface, 0))
				{
					AddLog(LOG_DEBUG, _T("Added interface for port %u."), nPort);
					m_queueInterfaces.push(pInterface);
					return true; // success
				}

				AddLog(LOG_ERROR, _T("PostMessage failed"));
				delete pInterface;
			} 
			else
				AddLog(LOG_ERROR, _T("No memory"));
		}
		else
			AddLog(LOG_ERROR, _T("Failed to bind to port %u. Error %d (already in use ?)"), nPort, WSAGetLastError());

		if (closesocket(hSocket))
			AddLog(LOG_ERROR, _T("closesocket failed"));
	}
	return false; // failed
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::Uninit(bool bCleanupWinsock /* = true */)
{
	if (m_bWinsockInit)
	{
		// purge all interfaces
		for (; !m_queueInterfaces.empty(); m_queueInterfaces.pop())
		{
			CInterface* pInterface = m_queueInterfaces.front();
			ASSERT(pInterface);

			pInterface->m_nFlags |= INTERFACE_FLAG_SHUTDOWN;

			if (closesocket(pInterface->m_hSocket))
				AddLog(LOG_ERROR, _T("closesocket failed"));

			if (m_hSocketWnd && !PostMessage(m_hSocketWnd, WM_EMSOCKET, pInterface->m_hSocket, MAKELONG(FD_ACCEPT, -1)))
				AddLog(LOG_ERROR, _T("PostMessage failed"));

			// wait now until all accept operations return with an error
			for (DWORD dwTicks = GetTickCount(); pInterface->m_nPendingAccepts; Sleep(0))
				if (GetTickCount() - dwTicks > 1000)
				{
					AddLog(LOG_ERROR, _T("Not all accept operations returned"));
					break;
				}

			delete pInterface;
		}

		if (bCleanupWinsock)
		{
			UninitAsync();

			if (WSACleanup())
				AddLog(LOG_ERROR, _T("WSACleanup failed"));
			m_bWinsockInit = false;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SOCKET CTcpEngine::AllocConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType)
{
	OVERLAPPED_RECV* pClient = AllocRecv(eType);

	ASSERT(pClient);

	if (pClient != NULL)
	{
		SOCKET		hSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);

		if (INVALID_SOCKET == (pClient->m_hSocket = hSocket))
			AddLog(LOG_ERROR, _T("WSASocket failed"));
		else
		{
			if (WSAAsyncSelect(pClient->m_hSocket, m_hSocketWnd, WM_EMSOCKET, FD_CONNECT))
				AddLog(LOG_ERROR, _T("WSAAsyncSelect failed"));
			else
			{
				pClient->m_nFlags = 0;
				pClient->m_nPeerAddr = nAddr;
				pClient->m_nPeerPort = htons(nPort);

				if (PostMessage(m_hSocketWnd, WM_EM_CONNECT, (WPARAM) pClient, 0))
					return hSocket;

			}
			AddLog(LOG_ERROR, _T("PostMessage failed"));
			if (closesocket(pClient->m_hSocket))
				AddLog(LOG_ERROR, _T("closesocket failed"));
		}
		delete pClient;
	} 
	else
		AddLog(LOG_ERROR, _T("No memory"));

	return INVALID_SOCKET;
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngine::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwSize, EnumQueuePriority ePriority)
{
	while(dwSize)
	{
		DWORD dwPortion = min(UPLOAD_BLOCK_SIZE, dwSize);
		OVERLAPPED_SEND* pOverlapped = new(dwPortion) OVERLAPPED_SEND;
		if (pOverlapped)
		{
			CopyMemory(pOverlapped->m_pBuf, pData, dwPortion);
			pOverlapped->buf = (char*) pOverlapped->m_pBuf;
			pOverlapped->len = dwPortion;
			pOverlapped->m_pEngine = this;
			pOverlapped->m_hSocket = hSocket;

			if(!PostMessage(m_hSocketWnd, WM_EM_SEND, (WPARAM)ePriority, (LPARAM)pOverlapped))
			{
				AddLog(LOG_ERROR, _T("PostMessage failed"));
				CTask_Tcp_Err::Post(hSocket, -1);
				return false;
			}
		}
		else
			AddLog(LOG_ERROR, _T("No memory"));

		dwSize -= dwPortion;
		((PBYTE&) pData) += dwPortion;
	}
	return true;
}

//////////////////////////////////////////////////////////////////////
void CTcpEngine::AllocDisconnect(SOCKET hSocket)
{
	if (!PostMessage(m_hSocketWnd, WM_EM_DISCONNECT, 0, (LPARAM) hSocket))
	{
		AddLog(LOG_ERROR, _T("PostMessage failed"));
		CTask_Tcp_Err::Post(hSocket, -1);
	}
}

//////////////////////////////////////////////////////////////////////
DWORD CTcpEngine::OVERLAPPED_RECV_WEB::ParseRecv(CTcpEngine& stEngine, bool bIsLastRecv)
{
	char* pData = GetBuffer();
	ASSERT(pData);

	if (!m_dwHttpHeaderLen)
	{
		// try to find it
		bool bPrevEndl = false;
		for (DWORD dwPos = 0; dwPos < m_dwBufUsage; dwPos++)
			if ('\n' == pData[dwPos])
				if (bPrevEndl)
				{
					// We just found the end of the http header
					// Now write the message's position into two first DWORDs of the buffer
					m_dwHttpHeaderLen = dwPos + 1;

					// try to find now the 'Content-Length' header
					for (dwPos = 0; dwPos < m_dwHttpHeaderLen; )
					{
						PVOID pPtr = memchr(pData + dwPos, '\n', m_dwHttpHeaderLen - dwPos);
						if (!pPtr)
							break;
						DWORD dwNextPos = ((DWORD) pPtr) - ((DWORD) pData);

						// check this header
						char szMatch[] = "content-length";
						if (!strnicmp(pData + dwPos, szMatch, sizeof(szMatch) - 1))
						{
							dwPos += sizeof(szMatch) - 1;
							pPtr = memchr(pData + dwPos, ':', m_dwHttpHeaderLen - dwPos);
							if (pPtr)
								m_dwHttpContentLen = atol(((char*) pPtr) + 1);

							break;
						}
						dwPos = dwNextPos + 1;
					}

					break;
				}
				else
				{
					bPrevEndl = true;
				}
			else
				if ('\r' != pData[dwPos])
					bPrevEndl = false;
	}

	DWORD dwParsed = 0;
	if (m_dwHttpHeaderLen)
	{
		if (bIsLastRecv && !m_dwHttpContentLen)
			m_dwHttpContentLen = m_dwBufUsage - m_dwHttpHeaderLen;

		if (m_dwHttpHeaderLen + m_dwHttpContentLen <= m_dwBufUsage)
		{
			dwParsed = m_dwHttpHeaderLen + m_dwHttpContentLen;

			CTask_Tcp_Web* pTask = new (dwParsed) CTask_Tcp_Web;
			if (pTask)
			{
				CopyMemory(pTask->m_pBuf, pData, dwParsed);
				pTask->m_hSocket = m_hSocket;
				pTask->m_dwHeaderLen = m_dwHttpHeaderLen;
				pTask->m_dwContentLen = m_dwHttpContentLen;

				g_stEngine.Sockets.Push(pTask);

			} 
			else
				AddLog(LOG_ERROR, _T("No memory"));

			m_dwHttpHeaderLen = m_dwHttpContentLen = 0;
		}
	}
	return dwParsed;
}
//////////////////////////////////////////////////////////////////////
DWORD CTcpEngine::OVERLAPPED_RECV_XML::ParseRecv(CTcpEngine& stEngine, bool bIsLastRecv)
{
	char* pData = GetBuffer();
	ASSERT(pData);

	if (!m_dwLength && m_dwBufUsage >= sizeof(DWORD))
	{
		DWORD *pdwLen = (DWORD*)pData;
		m_dwLength = *pdwLen;
	}

	if (bIsLastRecv && m_dwBufUsage)
		m_dwLength = m_dwBufUsage - sizeof(DWORD);
	DWORD dwParsed = 0;
	if (m_dwLength)
	{
		if (m_dwLength <= (m_dwBufUsage - sizeof(DWORD)))
		{
			dwParsed = m_dwLength + sizeof(DWORD);

			CTask_Tcp_Xml* pTask = new (m_dwLength + 1) CTask_Tcp_Xml;
			if (pTask)
			{
				CopyMemory(pTask->m_pBuf, pData + sizeof(DWORD), m_dwLength);
				pTask->m_pBuf[m_dwLength] = '\0';
				pTask->m_hSocket = m_hSocket;
				pTask->m_dwLength = m_dwLength;

				g_stEngine.Sockets.Push(pTask);

			} 
			else
				AddLog(LOG_ERROR, _T("No memory"));

			m_dwLength = 0;
		}
	}
	return dwParsed;
}
@


1.23
log
@v2 - fixes for upload logic
@
text
@d672 1
a672 1
bool CTcpEngine::AddInterface(USHORT nPort, T_CLIENT_TYPE eType)
d679 1
a679 1
		stAddr.sin_addr.S_un.S_addr = INADDR_ANY;
d710 1
a710 1
			AddLog(LOG_ERROR, _T("Failed to bind to port %u. (already in use ?)"), nPort);
@


1.22
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d252 1
a252 1
				pState->m_stEngine.OnSend(pState, (OVERLAPPED_SEND*)lParam, (bool)wParam);
d279 1
a279 1
void CTcpEngine::OnSend(CState* pState, OVERLAPPED_SEND* pSend, bool bToEnd)
d798 1
a798 1
bool CTcpEngine::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwSize, bool bToEnd)
d812 1
a812 1
			if(!PostMessage(m_hSocketWnd, WM_EM_SEND, (WPARAM)bToEnd, (LPARAM)pOverlapped))
@


1.21
log
@v2 - more upload logic, limiting total upload speed
@
text
@a7 5
#ifdef PROCESS_OPCODES
#include "OpCode.h"
#include "../Data/Prefs.h"
#endif //PROCESS_OPCODES

d90 1
a90 1
				SetTimer(pThis->m_hSocketWnd, 1, 100, NULL);
d252 1
a252 1
				pState->m_stUploadQueue.push((OVERLAPPED_SEND*) lParam);
d257 1
a257 67
				// 1st of all - approximate how much data we can send now.
				DWORD dwTicks = GetTickCount();

				DWORD dwPeriod = 0, dwSizeSent = 0;
				for (int i = 0; i < UPLOAD_MAX_STATS_RESULTS; i++)
				{
					dwPeriod += pState->m_arrUploadTicks[i];
					dwSizeSent += pState->m_arrUploadStats[i];
				}

				DWORD dwBytesToSend = 1024;	// if we're only starting, let's send 1kb
#ifdef PROCESS_OPCODES
				if (dwPeriod)
				{
					dwBytesToSend = g_stEngine.Prefs.GetMaxUpload() * 1024 * dwPeriod / 10000;
					if (dwBytesToSend > dwSizeSent)
						dwBytesToSend -= dwSizeSent;
					else
						dwBytesToSend = 0;
				}
#endif //PROCESS_OPCODES

				dwSizeSent = 0;

				while(!pState->m_stUploadQueue.empty())
				{
					OVERLAPPED_SEND* pSend = pState->m_stUploadQueue.front();
					ASSERT(pSend);
					if (pSend->len > dwBytesToSend)
						break;

					pState->m_stUploadQueue.pop();

					DWORD dwSize = 0;

					DWORD dwLen = pSend->len;

					InterlockedIncrement(&pState->m_stEngine.m_nOverlappedIOs);

					if (pSend && WSASend(pSend->m_hSocket, pSend, 1, &dwSize, 0, pSend, OVERLAPPED_TCP::OverlappedCompletionFunc))
					{
						{
							int nError = WSAGetLastError();
							if (WSA_IO_PENDING != nError)
							{
								InterlockedDecrement(&pState->m_stEngine.m_nOverlappedIOs);

								// Notify the EmEngine about this.
								CTask_Tcp_Err::Post(pSend->m_hSocket, nError);
								delete pSend;

								// In case of error we don't count this packet
								dwLen = 0;
							}
						}
					}

					dwBytesToSend -= dwLen;
					dwSizeSent += dwLen;
				}

				pState->m_arrUploadStats[pState->m_nUploadIndex] = dwSizeSent;
				pState->m_arrUploadTicks[pState->m_nUploadIndex] = dwTicks - pState->m_dwLastTick;

				pState->m_dwLastTick = dwTicks;
				pState->m_nUploadIndex = (pState->m_nUploadIndex + 1) % UPLOAD_MAX_STATS_RESULTS;

d277 38
d348 6
a353 17
#ifdef PROCESS_OPCODES
		case T_CLIENT_PEER:
		case T_CLIENT_SERVER:
		{
			return new OVERLAPPED_RECV_OPCODES(eType);
		}
#endif //PROCESS_OPCODES
		case T_CLIENT_WEB:
		{
			return new OVERLAPPED_RECV_WEB;
		}
		case T_CLIENT_XML:
		{
			return new OVERLAPPED_RECV_XML;
		}
		default:
			ASSERT(FALSE); // invalid type
d798 1
a798 1
bool CTcpEngine::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwSize)
d812 1
a812 1
			if(!PostMessage(m_hSocketWnd, WM_EM_SEND, 0, (LPARAM) pOverlapped))
a828 37
#ifdef PROCESS_OPCODES
bool CTcpEngine::AllocSend(SOCKET hSocket, const COpCode &stOpCode)
{
	BYTE			pBuf[TCP_OPTIMAL_BUF];
	CStream_MemEx	stStream;

	stStream.m_pPtr = pBuf;
	stStream.m_dwSize = sizeof(pBuf);

	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP));
	if (!stStream.m_dwSizeExtra)
		return AllocSend(hSocket, pBuf, sizeof(pBuf) - stStream.m_dwSize);

//	This opcode seems to be huge.
	DWORD dwSizeHuge = sizeof(pBuf) + stStream.m_dwSizeExtra;
	PBYTE pBufDyn = new BYTE[dwSizeHuge];

	if (!pBufDyn)
	{
		AddLog(LOG_ERROR, _T("No memory"));
		CTask_Tcp_Err::Post(hSocket, -1);
		return false;
	}

	stStream.m_pPtr = pBufDyn;
	stStream.m_dwSize = dwSizeHuge;
	stStream.m_dwSizeExtra = 0;
	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP));

	bool bSend = AllocSend(hSocket, pBufDyn, dwSizeHuge);
	delete[] pBufDyn;

	return bSend;
}
#endif //PROCESS_OPCODES

//////////////////////////////////////////////////////////////////////
a957 62
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef PROCESS_OPCODES
DWORD CTcpEngine::OVERLAPPED_RECV_OPCODES::ParseRecv(CTcpEngine &stEngine, bool)
{
	char* pData = GetBuffer();

	ASSERT(pData);
	
	for (DWORD dwParsed = 0; ;)
	{
	//	Over tcp transport, opcodes always have a header of 6 bytes
		if (m_dwBufUsage < 6 + dwParsed)
		{
			break;
		}

		DWORD dwOpCodeLen = *((DWORD*) (pData + 1));

		if (dwOpCodeLen == 0)
		{
			AddLog(LOG_ERROR, _T("Invalid recv data"));
			return m_dwBufUsage; // will discard all the buffer
		}

		if (dwOpCodeLen + 5 + dwParsed > m_dwBufUsage)
			break;

		CStream_Mem stStream;

		stStream.m_pPtr = (PBYTE) pData + 6;
		stStream.m_dwSize = dwOpCodeLen - 1;

		TCHAR strOpCode[100];
		strOpCode[0] = NULL;
		COpCode* pOpCode = COpCode::Read(stStream, ((PBYTE)pData)[5], ((PBYTE)pData)[0], m_eType, strOpCode);

		if (pOpCode != NULL)
		{
			if (stStream.m_dwSize)
			{
//				ASSERT(FALSE);
				AddLog(LOG_WARNING, _T("%u bytes left from OpCode initialization, id=%s (%x)"), stStream.m_dwSize, pOpCode->TaskName(), pOpCode->GetID());
			}

			pOpCode->m_hSocket = m_hSocket;
			g_stEngine.Sockets.Push(pOpCode);
		//	g_stEngine.PushToLogger(pOpCode);
		}
		else
		{
			AddLog(LOG_WARNING, _T("Can't receive opcode %s (%x) protocol=%x"), strOpCode, ((PBYTE)pData)[5], ((PBYTE)pData)[0]);
//			ASSERT(FALSE);
		}

		dwOpCodeLen += 5;
		pData += dwOpCodeLen;
		dwParsed += dwOpCodeLen;
	}
	return dwParsed;
}
#endif //PROCESS_OPCODES
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.20
log
@v2 - minor improvements
@
text
@d10 1
d17 2
d32 1
a32 7
			{
				// Create upload limiter thread
				nThread = 0;
				if(m_hLimitSendThread = (HANDLE)_beginthreadex(NULL, 0, LimitSendFunc, this, 0, &nThread))
					// Everything is ok
					return true;
			}
d95 2
a152 8
//////////////////////////////////////////////////////////////////////
UINT WINAPI CTcpEngine::LimitSendFunc(PVOID pPtr)
{
	CTcpEngine* pThis = (CTcpEngine*) pPtr;
	ASSERT(pThis);
	if (pThis)
	{
	}
a153 2
	return 0;
}
d164 1
d257 26
a282 3
				OVERLAPPED_SEND* pSend = (OVERLAPPED_SEND*) lParam;
				ASSERT(pSend);
				DWORD dwSize = 0;
d284 1
a284 1
				InterlockedIncrement(&pState->m_stEngine.m_nOverlappedIOs);
d286 1
a286 1
				if (pSend && WSASend(pSend->m_hSocket, pSend, 1, &dwSize, 0, pSend, OVERLAPPED_TCP::OverlappedCompletionFunc))
d288 14
a302 2
						int nError = WSAGetLastError();
						if (WSA_IO_PENDING != nError)
d304 8
a311 1
							InterlockedDecrement(&pState->m_stEngine.m_nOverlappedIOs);
d313 3
a315 3
							// notify the EmEngine about this.
							CTask_Tcp_Err::Post(pSend->m_hSocket, nError);
							delete pSend;
d318 3
d322 7
d844 1
a844 2
	OVERLAPPED_SEND* pOverlapped = new(dwSize) OVERLAPPED_SEND;
	if (pOverlapped)
d846 9
a854 5
		CopyMemory(pOverlapped->m_pBuf, pData, dwSize);
		pOverlapped->buf = (char*) pOverlapped->m_pBuf;
		pOverlapped->len = dwSize;
		pOverlapped->m_pEngine = this;
		pOverlapped->m_hSocket = hSocket;
d856 9
a864 2
		if (PostMessage(m_hSocketWnd, WM_EM_SEND, 0, (LPARAM) pOverlapped))
			return true; // ok
d866 2
a867 1
		AddLog(LOG_ERROR, _T("PostMessage failed"));
d869 1
a869 5
	else
		AddLog(LOG_ERROR, _T("No memory"));

	CTask_Tcp_Err::Post(hSocket, -1);
	return false;
@


1.19
log
@v2 - enhancing logging subsystem
@
text
@d17 1
a17 1
// start
d22 1
a22 1
		// create a thread for handling standard sockets events
d26 1
a26 1
			// very well. Wait now until it finishes its initialization
d29 7
a35 2
				// everything is ok
				return true;
d154 11
d184 1
a184 1
	CState		*pState = (CState*) GetWindowLong(hWnd, GWL_USERDATA);
d194 1
a194 1
				OVERLAPPED_TCP		*pClient = pState->LookupClient(wParam);
d235 1
a235 1
				OVERLAPPED_RECV		*pClient = (OVERLAPPED_RECV*)wParam;
d243 1
a243 1
					SOCKADDR_IN		stAddr;
d281 1
a281 1
							// notify the EMEngine about this.
d390 1
a390 1
			OVERLAPPED_RECV		*pOverlapped = stState.m_stEngine.AllocRecv(m_stInterface.m_eType);
d401 1
a401 1
				CTask_Tcp_Accepted		*pTask = new CTask_Tcp_Accepted;
d763 1
a763 1
	OVERLAPPED_RECV		*pClient = AllocRecv(eType);
a802 1
	ASSERT(pOverlapped);
d827 2
a828 2
	BYTE				pBuf[TCP_OPTIMAL_BUF];
	CStream_MemEx		stStream;
d838 2
a839 2
	DWORD		dwSizeHuge = sizeof(pBuf) + stStream.m_dwSizeExtra;
	PBYTE		pBufDyn = new BYTE[dwSizeHuge];
d994 1
a994 1
	char		*pData = GetBuffer();
d1006 1
a1006 1
		DWORD		dwOpCodeLen = *((DWORD*) (pData + 1));
d1017 1
a1017 1
		CStream_Mem		stStream;
d1024 1
a1024 1
		COpCode		*pOpCode = COpCode::Read(stStream, ((PBYTE)pData)[5], ((PBYTE)pData)[0], m_eType, strOpCode);
@


1.18
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d49 1
a49 2
				ASSERT(FALSE);
				AddDebugLogLine("Thread has not terminated.");
d51 1
a51 1
					AddDebugLogLine("TerminateThread failed");
d139 1
a139 5
				{
					ASSERT(FALSE);
					AddDebugLogLine(_T("Overlapped IOs counter is %d"), pThis->m_nOverlappedIOs);
				}

d203 2
a204 1
					} else
d206 1
a206 2
						ASSERT(FALSE);
						AddDebugLogLine("no memory");
d214 1
a214 4
				{
					ASSERT(FALSE);
					AddDebugLogLine("SetEvent failed");
				}
d356 1
a356 1
			AddDebugLogLine("Accept operation has failed");
d369 1
a369 4
				{
					ASSERT(FALSE);
					AddDebugLogLine("accept failed");
				}
d396 1
a396 4
				{
					ASSERT(FALSE);
					AddDebugLogLine("no memory");
				}
d404 3
a406 4
				ASSERT(FALSE);
				AddDebugLogLine("no memory");
				if (closesocket(hSocket))
					AddDebugLogLine("closesocket failed");
d448 1
a448 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("no memory");
			}
d491 1
a491 1
						AddDebugLogLine(_T("The limit has been reached. Discarding."));
d513 1
a513 2
							ASSERT(FALSE);
							AddDebugLogLine("no memory");
d560 1
a560 4
	{
		ASSERT(FALSE);
		AddDebugLogLine("WSAAsyncSelect failed");
	}
d567 1
a567 2
		ASSERT(FALSE);
		AddDebugLogLine("setsockopt failed");
d648 1
a648 4
	{
		ASSERT(FALSE);
		AddDebugLogLine("WSAStartup failed");
	}
d684 1
a684 1
					AddDebugLogLine(_T("Added interface for port %u."), nPort);
d689 1
a689 2
				ASSERT(FALSE);
				AddDebugLogLine("PostMessage failed");
d693 1
a693 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("no memory");
			}
d696 1
a696 4
		{
			ASSERT(FALSE);
			AddDebugLogLine(_T("Failed to bind to port %u. (already in use ?)"), nPort);
		}
d699 1
a699 4
		{
			ASSERT(FALSE);
			AddDebugLogLine("closesocket failed");
		}
d718 1
a718 1
				AddDebugLogLine("closesocket failed");
d721 1
a721 1
				AddDebugLogLine("PostMessage failed");
d727 1
a727 2
					ASSERT(FALSE);
					AddDebugLogLine("Not all accept operations returned");
d739 1
a739 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("WSACleanup failed");
			}
d756 1
a756 4
		{
			ASSERT(FALSE);
			AddDebugLogLine("WSASocket failed");
		}
d760 1
a760 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("WSAAsyncSelect failed");
			}
d771 1
a771 2
			ASSERT(FALSE);
			AddDebugLogLine("PostMessage failed");
d773 1
a773 1
				AddDebugLogLine("closesocket failed");
d778 1
a778 4
	{
		ASSERT(FALSE);
		AddDebugLogLine("no memory");
	}
d799 1
a799 3
		ASSERT(FALSE);
		AddDebugLogLine("PostMessage failed");

d802 1
a802 4
	{
		ASSERT(FALSE);
		AddDebugLogLine("no memory");
	}
d828 1
a828 2
		ASSERT(FALSE);
		AddDebugLogLine("no memory");
d850 1
a850 2
		ASSERT(FALSE);
		AddDebugLogLine("PostMessage failed");
d928 1
a928 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("no memory");
			}
d968 1
a968 4
			{
				ASSERT(FALSE);
				AddDebugLogLine("no memory");
			}
d995 1
a995 2
			ASSERT(FALSE);
			AddDebugLogLine("Invalid recv data");
d1016 1
a1016 1
				AddDebugLogLine(_T("%u bytes left from OpCode initialization, id=%s (%x)"), stStream.m_dwSize, pOpCode->TaskName(), pOpCode->GetID());
d1025 1
a1025 1
			AddDebugLogLine(_T("Can't receive opcode %s (%x) protocol=%x"), strOpCode, ((PBYTE)pData)[5], ((PBYTE)pData)[0]);
@


1.17
log
@v2 - packed protocol fixed
@
text
@d1079 1
a1079 1
				ASSERT(FALSE);
@


1.16
log
@v2 - updated protocol, need to fix packed protocol
@
text
@d1073 1
a1073 1
		COpCode		*pOpCode = COpCode::Read(stStream, pData[5], pData[0], m_eType, strOpCode);
d1089 1
a1089 1
			AddDebugLogLine(_T("Can't receive opcode %s (%x) protocol=%x client=%x"), strOpCode, pData[5], pData[0] & 0xFF, m_eType);
@


1.15
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d1071 3
a1073 1
		COpCode		*pOpCode = COpCode::Read(stStream, pData[5], pData[0], m_eType);
d1089 1
a1089 1
			AddDebugLogLine(_T("Can't receive opcode %x"), pData[5]);
@


1.14
log
@v2 - more minor rearrangements
@
text
@d1078 1
a1078 1
				AddDebugLogLine(_T("%u bytes left from OpCode initialization, id=%u"), stStream.m_dwSize, pOpCode->GetID());
@


1.13
log
@Xml and database functionality
@
text
@d404 1
a404 1
					g_stEngine.PushToSocketsTP(pTask);
d460 1
a460 1
				g_stEngine.PushToSocketsTP(pTask);
d981 1
a981 1
				g_stEngine.PushToSocketsTP(pTask);
d1024 1
a1024 1
				g_stEngine.PushToSocketsTP(pTask);
d1082 1
a1082 1
			g_stEngine.PushToSocketsTP(pOpCode);
@


1.12
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@a5 1
#include "../EmEngine.h"
@


1.11
log
@XML connecting, tray app
@
text
@d6 1
a6 1

@


1.10
log
@There can be only one engine :-)
@
text
@d343 4
d996 43
@


1.9
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d8 2
d11 4
a14 1
#include "../EmEngine.h"
d275 1
a275 1
							CTask_Tcp_Err::Post(pState->m_stEngine.m_stEngine, pSend->m_hSocket, nError);
d286 1
a286 1
					CTask_Tcp_Err::Post(pState->m_stEngine.m_stEngine, (SOCKET) lParam, WSAGetLastError());
d332 1
d338 1
d401 1
a401 1
					stState.m_stEngine.m_stEngine.PushToSocketsTP(pTask);
d446 1
a446 1
			CTask_Tcp_Err::Post(stState.m_stEngine.m_stEngine, m_hSocket, nError);
d457 1
a457 1
				stState.m_stEngine.m_stEngine.PushToSocketsTP(pTask);
d541 1
a541 1
			CTask_Tcp_Err::Post(stEngine.m_stEngine, m_hSocket, 0);
d565 1
a565 1
			CTask_Tcp_Err::Post(stEngine.m_stEngine, m_hSocket, nError);
d614 1
a614 1
		CTask_Tcp_Err::Post(stEngine.m_stEngine, m_hSocket, nError);
d856 1
a856 1
	CTask_Tcp_Err::Post(m_stEngine, hSocket, -1);
d861 1
d882 1
a882 1
		CTask_Tcp_Err::Post(m_stEngine, hSocket, -1);
d896 1
d905 1
a905 1
		CTask_Tcp_Err::Post(m_stEngine, hSocket, -1);
d978 1
a978 1
				stEngine.m_stEngine.PushToSocketsTP(pTask);
d993 1
d1036 2
a1037 2
			stEngine.m_stEngine.PushToSocketsTP(pOpCode);
		//	stEngine.m_stEngine.PushToLogger(pOpCode);
d1051 1
@


1.8
log
@Modified code so Task caller can specify completion behavior.
@
text
@d46 1
a46 1
				AddDebugLogLine(false, "Thread has not terminated.");
d48 1
a48 1
					AddDebugLogLine(false, "TerminateThread failed");
d138 1
a138 1
					AddDebugLogLine(false, _T("Overlapped IOs counter is %d"), pThis->m_nOverlappedIOs);
d207 1
a207 1
						AddDebugLogLine(false, "no memory");
d217 1
a217 1
					AddDebugLogLine(false, "SetEvent failed");
d354 1
a354 1
			AddDebugLogLine(false, "Accept operation has failed");
d369 1
a369 1
					AddDebugLogLine(false, "accept failed");
d399 1
a399 1
					AddDebugLogLine(false, "no memory");
d409 1
a409 1
				AddDebugLogLine(false, "no memory");
d411 1
a411 1
					AddDebugLogLine(false, "closesocket failed");
d455 1
a455 1
				AddDebugLogLine(false, "no memory");
d499 1
a499 1
						AddDebugLogLine(false, _T("The limit has been reached. Discarding."));
d522 1
a522 1
							AddDebugLogLine(false, "no memory");
d571 1
a571 1
		AddDebugLogLine(false, "WSAAsyncSelect failed");
d580 1
a580 1
		AddDebugLogLine(false, "setsockopt failed");
d663 1
a663 1
		AddDebugLogLine(false, "WSAStartup failed");
d700 1
a700 1
					AddDebugLogLine(false, _T("Added interface for port %u."), nPort);
d706 1
a706 1
				AddDebugLogLine(false, "PostMessage failed");
d712 1
a712 1
				AddDebugLogLine(false, "no memory");
d718 1
a718 1
			AddDebugLogLine(false, _T("Failed to bind to port %u. (already in use ?)"), nPort);
d724 1
a724 1
			AddDebugLogLine(false, "closesocket failed");
d744 1
a744 1
				AddDebugLogLine(false, "closesocket failed");
d747 1
a747 1
				AddDebugLogLine(false, "PostMessage failed");
d754 1
a754 1
					AddDebugLogLine(false, "Not all accept operations returned");
d768 1
a768 1
				AddDebugLogLine(false, "WSACleanup failed");
d788 1
a788 1
			AddDebugLogLine(false, "WSASocket failed");
d795 1
a795 1
				AddDebugLogLine(false, "WSAAsyncSelect failed");
d808 1
a808 1
			AddDebugLogLine(false, "PostMessage failed");
d810 1
a810 1
				AddDebugLogLine(false, "closesocket failed");
d817 1
a817 1
		AddDebugLogLine(false, "no memory");
d840 1
a840 1
		AddDebugLogLine(false, "PostMessage failed");
d846 1
a846 1
		AddDebugLogLine(false, "no memory");
d873 1
a873 1
		AddDebugLogLine(false, "no memory");
d895 1
a895 1
		AddDebugLogLine(false, "PostMessage failed");
d975 1
a975 1
				AddDebugLogLine(false, "no memory");
d1003 1
a1003 1
			AddDebugLogLine(false, "Invalid recv data");
d1022 1
a1022 1
				AddDebugLogLine(false, _T("%u bytes left from OpCode initialization, id=%u"), stStream.m_dwSize, pOpCode->GetID());
d1031 1
a1031 1
			AddDebugLogLine(false, _T("Can't receive opcode %x"), pData[5]);
@


1.7
log
@Formatting, comments, and name changes.
@
text
@d10 1
@


1.6
log
@Formatting, comments, and name changes, the usual.
@
text
@d149 1
a149 2

//////////////////////////////////////////////////////////////////////
d154 12
a165 8
	case WM_EMSOCKET:
	case WM_EM_ADDINTERFACE:
	case WM_EM_CONNECT:
	case WM_EM_SEND:
	case WM_EM_DISCONNECT:
		break;
	default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
d168 2
a169 1
	CState* pState = (CState*) GetWindowLong(hWnd, GWL_USERDATA);
d171 1
d173 1
d176 1
a176 1
		case WM_EMSOCKET:
d178 2
a179 1
				OVERLAPPED_TCP* pClient = pState->LookupClient(wParam);
d181 1
d183 2
d186 1
a186 2
			break;
		case WM_EM_ADDINTERFACE:
d218 1
d220 1
a220 2
			break;
		case WM_EM_CONNECT:
d222 2
a223 1
				OVERLAPPED_RECV* pClient = (OVERLAPPED_RECV*) wParam;
d225 2
a226 1
				if (pClient)
d230 2
a231 1
					SOCKADDR_IN stAddr;
d236 1
a236 1
					if (connect(pClient->m_hSocket, (sockaddr*) &stAddr, sizeof(stAddr)))
d238 4
a241 2
						int nError = WSAGetLastError();
						if (WSAEWOULDBLOCK != nError)
d243 4
a246 1
					} else
d248 1
d250 1
d252 1
a252 3
			break;

		case WM_EM_SEND:
d261 1
d273 2
d276 5
a280 1
			break;
d282 6
a287 9
		case WM_EM_DISCONNECT:
			ASSERT(INVALID_SOCKET != lParam);
			if ((INVALID_SOCKET != lParam) && shutdown((SOCKET) lParam, SD_SEND))
				CTask_Tcp_Err::Post(pState->m_stEngine.m_stEngine, (SOCKET) lParam, WSAGetLastError());

			break;

		default:
			ASSERT(FALSE);
d289 1
d293 1
a293 2

//////////////////////////////////////////////////////////////////////
d321 2
a322 3

//////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_RECV* CTcpEngine::AllocRecv(T_CLIENT_TYPE eType)
d326 12
a337 5
	case T_CLIENT_PEER:
	case T_CLIENT_SERVER:
		return new OVERLAPPED_RECV_OPCODES(eType);
	case T_CLIENT_WEB:
		return new OVERLAPPED_RECV_WEB;
a338 3
	default:
		ASSERT(FALSE); // invalid type
	}
d341 1
a341 2

//////////////////////////////////////////////////////////////////////
d345 1
d354 1
d356 1
d359 4
a362 3
			SOCKADDR_IN stAddr;
			int nLen = sizeof(stAddr);
			SOCKET hSocket = accept(m_hSocket, (sockaddr*) &stAddr, &nLen);
d368 1
a368 1
					AddDebugLogLine(false, "acept failed");
d373 4
a376 3
			// create now a 'receiver' of relevant type
			OVERLAPPED_RECV* pOverlapped = stState.m_stEngine.AllocRecv(m_stInterface.m_eType);
			if (pOverlapped)
d384 4
a387 3
				// notify the EmEngine about new connection accepted
				CTask_Tcp_Accepted* pTask = new CTask_Tcp_Accepted;
				if (pTask)
d413 1
d415 1
a415 2

//////////////////////////////////////////////////////////////////////
d426 1
a426 2

//////////////////////////////////////////////////////////////////////
d432 1
a432 1
	// the only event we expect is FD_CONNECT
d434 1
d437 1
a437 1
			// Notify the EMEngine about unsuccessful connection attempt
d441 2
a442 1
		} else
d444 3
a446 2
			CTask_Tcp_Connected* pTask = new CTask_Tcp_Connected;
			if (pTask)
a449 1

d462 1
d464 2
a465 3

//////////////////////////////////////////////////////////////////////
void CTcpEngine::OVERLAPPED_RECV::ProcessCompletion(CTcpEngine& stEngine, int nError, DWORD dwBytes)
d471 1
d473 1
d475 3
a477 1
		if (dwBytes && (dwBytes + m_dwBufUsage <= m_dwBufSize))
d481 3
a483 2
			DWORD dwParsed = ParseRecv(stEngine, false);
			if (dwParsed)
d486 1
d488 1
d490 4
a493 1
			} else
d495 1
d503 5
a507 4
						// extend the buffer
						DWORD dwSizeNew = m_dwBufUsage + TCP_OPTIMAL_BUF;
						char* pBufNew = new char[dwSizeNew];
						if (pBufNew)
d510 2
a511 1
							if (m_pBufExtra)
d513 1
d517 2
a518 1
						} else
d525 4
a528 2

		} else
d538 1
d773 1
a773 2

//////////////////////////////////////////////////////////////////////
d776 2
a777 1
	OVERLAPPED_RECV* pClient = AllocRecv(eType);
d779 2
a780 1
	if (pClient)
d782 2
a783 1
		SOCKET hSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED);
d853 1
a853 1
bool CTcpEngine::AllocSend(SOCKET hSocket, const COpCode& stOpCode)
d855 3
a857 2
	BYTE pBuf[TCP_OPTIMAL_BUF];
	CStream_MemEx stStream;
d865 4
a868 3
	// this opcode seems to be huge.
	DWORD dwSizeHuge = sizeof(pBuf) + stStream.m_dwSizeExtra;
	PBYTE pBufDyn = new BYTE[dwSizeHuge];
d982 4
a986 4
//////////////////////////////////////////////////////////////////////
DWORD CTcpEngine::OVERLAPPED_RECV_OPCODES::ParseRecv(CTcpEngine& stEngine, bool)
{
	char* pData = GetBuffer();
a987 1

d991 1
a991 1
		// over tcp transport opcodes always have a header of 6 bytes
d993 1
d995 3
d999 1
a999 2
		DWORD dwOpCodeLen = *((DWORD*) (pData + 1));
		if (!dwOpCodeLen)
d1009 2
a1010 1
		CStream_Mem stStream;
d1014 3
a1016 2
		COpCode* pOpCode = COpCode::Read(stStream, pData[5], pData[0], m_eType);
		if (pOpCode)
d1026 1
a1026 1
			//stEngine.m_stEngine.PushToLogger(pOpCode);
d1040 1
@


1.5
log
@*** empty log message ***
@
text
@d775 1
a775 1
	OVERLAPPED_SEND* pOverlapped = new (dwSize) OVERLAPPED_SEND;
@


1.4
log
@New engine - cosmetic changes
@
text
@d970 1
@


1.3
log
@New engine - cosmetic changes
@
text
@d364 1
a364 1
					stState.m_stEngine.m_stEngine.m_stSocketsTP.Push(pTask);
d418 1
a418 1
				stState.m_stEngine.m_stEngine.m_stSocketsTP.Push(pTask);
d916 1
a916 1
				stEngine.m_stEngine.m_stSocketsTP.Push(pTask);
d969 1
a969 1
			stEngine.m_stEngine.m_stSocketsTP.Push(pOpCode);
@


1.2
log
@New engine - name changes
@
text
@d6 1
a6 1
#ifdef NEW_SOCKETS
a982 2

#endif@


1.1
log
@New engine
@
text
@d364 1
a364 1
					stState.m_stEngine.m_stEngine.m_stMain.Push(pTask);
d418 1
a418 1
				stState.m_stEngine.m_stEngine.m_stMain.Push(pTask);
d916 1
a916 1
				stEngine.m_stEngine.m_stMain.Push(pTask);
d969 1
a969 1
			stEngine.m_stEngine.m_stMain.Push(pOpCode);
@

