head	1.21;
access;
symbols
	PublicRelease_1_2e:1.21
	Interim_Release_1-2e_RC1:1.21
	PublicRelease_1_2d:1.21
	Interim_Release_1-2d_RC1:1.21
	Interim_Release_1-2d_beta1:1.21
	PublicRelease_1_2c:1.21
	Interim_Release_1-2c_RC1:1.21
	Interim_Release_1-2c_beta1:1.21
	PublicRelease_1_2b:1.21
	Interim_Release_1-2b_RC1:1.21
	PublicRelease_1_2a:1.21
	Interim_Release_1-2a_RC1:1.21
	Interim_Release_1-2a_beta2:1.21
	Interim_Release_1-2a_beta1:1.21
	PublicRelease_1_2:1.21
	Interim_Release_1-2_RC1:1.21
	Interim_Release_1-2_beta1:1.21
	PublicRelease_1_1g:1.21
	Interim_Release_1-1g_RC3:1.21
	Interim_Release_1-1g_RC2:1.21
	Interim_Release_1-1g_RC1:1.21
	Interim_Release_1-1g_beta2:1.21
	Interim_Release_1-1g_beta1:1.21
	PublicRelease_1_1f:1.21
	Interim_Release_1-1f_RC1:1.21
	PublicRelease_1_1e:1.21
	Interim_Release_1-1e_RC2:1.21
	Interim_Release_1-1e_RC1:1.21
	Interim_Release_1-1e_beta1:1.21
	PublicRelease_1_1d:1.16
	Interim_Release_1-1d_RC1:1.15
	PublicRelease_1_1c:1.14
	Interim_Release_1-1c_RC1:1.14
	Interim_Release_1-1c_beta2:1.13
	Interim_Release_1-1c_beta1:1.13
	PublicRelease_1_1b:1.11
	Interim_Release_1-1b_RC1:1.11
	PublicRelease_1_1a:1.11
	Interim_Release_1-1a_RC2:1.11
	Interim_Release_1-1a_RC1:1.11
	Interim_Release_1-1a_beta2:1.11
	Interim_Release_1-1a_beta1:1.11
	PublicRelease_1_1:1.11
	Interim_Release_1-1_beta1:1.11
	PublicRelease_1o:1.11
	Interim_Release_1o_RC1:1.11
	Interim_Release_1o_beta1:1.11
	PublicRelease_1n:1.11
	Interim_Release_1n_RC2:1.11
	Interim_Release_1n_RC1:1.11
	PublicRelease_1m:1.10
	Interim_Release_1m_beta1:1.10
	PublicRelease_1l:1.10
	Interim_Release_1l_RC3:1.10
	Interim_Release_1l_RC2:1.10
	Interim_Release_1l_RC1:1.10
	Interim_Release_1l_beta2:1.10
	Interim_Release_1l_beta1:1.10
	PublicRelease_1k:1.10
	Interim_Release_1k_RC4:1.10
	Interim_1k_RC3:1.10
	Interim_1k_RC2:1.10
	Interim_Release_1k_RC1:1.10
	Interim_Release_1k_beta5:1.10
	Intrerim_Release_1k_beta4:1.10
	Interim_Release_1k_beta1:1.10
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.2;
locks; strict;
comment	@// @;


1.21
date	2005.04.08.14.16.36;	author kuchin;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.07.17.24.49;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.29.14.36.13;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.22.22.02.10;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.22.15.54.10;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.18.15.36.51;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.13.19.30.16;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.18.18.31.25;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.30.13.39.04;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.07.11.37.09;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.07.11.31.46;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.06.13.57.27;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.05.19.31.56;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.16.14.51.00;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.07.10.54.33;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.07.09.18.16;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.21.10.29.05;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.21
log
@v2 - more abstraction + logic
@
text
@// TaskProcessor_Main.cpp: implementation of the CTaskProcessor_Sockets class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "TaskProcessorSockets.h"
#include "TasksSockets.h"
#include "TcpEngine.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// starting
bool CTaskProcessor_Sockets::Start()
{
//	m_mapClients.InitHashTable(997);
	m_dwWaitTimeout = 500;
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// destroy all clients that are possibly left in our map
//	MOREVIT: I'm thinking that some clients may be destroyed from our side (such as we currently do with unwanted
//		sources.) If we don't communicate that here we'll run into some of the same problems we had before with
//		calls being invoked on dead clients. Client should have a backpointer to processor?
void CTaskProcessor_Sockets::Stop()
{
	for (SocketClientMap::iterator pos = m_mapClients.begin(); pos != m_mapClients.end(); pos++)
	{
		CEmClient* pClient = (*pos).second;

//		ASSERT(pClient != NULL);	<= This is unnecessary. The C++ standard says delete MUST accept NULL gracefully.
		delete pClient;
	}
	m_mapClients.clear();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// processing timeout
// this should replace all old Process() functions
void CTaskProcessor_Sockets::ProcessTimeout()
{
/*
//	Keep connection alive once per minute
//	Recommended by lugdunummaster
	if (g_stEngine.IsConnected())
	{
		// sending empty OFFER FILES opcode
	}
*/
	// Execute this in engine cause we use TaskProcessor_Sockets in several modules
	g_stEngine.ProcessSocketsTimeout();

	// Perform check 10 times per second
	m_dwWaitTimeout = 100;
}
//////////////////////////////////////////////////////////////////////
// creating new client object
CEmClient *CTaskProcessor_Sockets::AllocClient(T_CLIENT_TYPE eType)
{
	CEmClient* pClient;

	switch (eType)
	{
#ifdef SUPPORT_CLIENT_PEER
		case T_CLIENT_PEER:
			pClient = new CEmClient_Peer;
			break;
		case T_CLIENT_SERVER:
			pClient = new CEmClient_Server;
			break;
#endif //SUPPORT_CLIENT_PEER
		case T_CLIENT_WEB:
			pClient = new CEmClient_Web;
			break;
		case T_CLIENT_XML:
			pClient = new CEmClient_Xml;
			break;
		default:
			ASSERT(FALSE); // invalid type ???
			return NULL;
	}
	if (pClient != NULL)
	{
		pClient->m_nClientID = ++m_nLastClientID;
	}

	return pClient;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// connecting to any client (or server)
CEmClient *CTaskProcessor_Sockets::AllocTcpConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eClientType,
												   CTcpCompletionTask *pOnCompletionTask )
{
	CEmClient* pClient = AllocClient(eClientType);

	if (pClient != NULL)
	{
		pClient->m_bFromOutside = false;
		pClient->m_dwAddr = nAddr;
		pClient->m_uPort = nPort;
		pClient->m_pOnCompletionTask = pOnCompletionTask;
		if(pOnCompletionTask)
			pOnCompletionTask->SetClient(pClient);

		SOCKET		hSocket = g_stEngine.GetTcpEngine()->AllocConnect(nAddr, nPort, eClientType);

		if (INVALID_SOCKET == hSocket)
		{
			delete pClient;
			pClient = NULL;
		}
		else
		{
			pClient->m_hSocket = hSocket;
			pClient->m_bIsConnected = false;

			m_mapClients[hSocket] = pClient;
		}
	} 
	else
	{
		AddLog(LOG_ERROR, _T("No memory"));
	}

	return pClient;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// disconnect existing client and destroy its object
void CTaskProcessor_Sockets::KillClient(CEmClient *pClient)
{
	ASSERT(pClient);

	SOCKET hSocket = pClient->m_hSocket;

	pClient->OnDisconnected();
	delete pClient;

	m_mapClients.erase(hSocket);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CTaskProcessor_Sockets::AddClientToMap(SOCKET hSocket, CEmClient *pClient)
{
	m_mapClients[hSocket] = pClient;
}

bool CTaskProcessor_Sockets::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwLen, EnumQueuePriority ePriority)
{
	return g_stEngine.GetTcpEngine()->AllocSend(hSocket, pData, dwLen, ePriority);
}
@


1.20
log
@v2 - fixes for upload logic
@
text
@d9 1
d103 1
a103 1
		SOCKET		hSocket = m_stTcp.AllocConnect(nAddr, nPort, eClientType);
d147 1
a147 1
	return m_stTcp.CTcpEngine::AllocSend(hSocket, pData, dwLen, ePriority);
@


1.19
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d144 1
a144 1
bool CTaskProcessor_Sockets::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwLen, bool bToEnd)
d146 1
a146 1
	return m_stTcp.CTcpEngine::AllocSend(hSocket, pData, dwLen, bToEnd);
@


1.18
log
@v2 - enhancing logging subsystem
@
text
@d144 1
a144 1
bool CTaskProcessor_Sockets::AllocSend(SOCKET hSocket, PCVOID pData, DWORD dwLen)
d146 1
a146 1
	return m_stTcp.AllocSend(hSocket, pData, dwLen);
@


1.17
log
@v2 - more upload logic
@
text
@d119 1
a119 2
		ASSERT(FALSE);
		AddDebugLogLine("no memory");
@


1.16
log
@v2 - more upload logic
@
text
@d50 2
a51 2
	// Perform check once per second
	m_dwWaitTimeout = 1000;
@


1.15
log
@v2 - little improvements
@
text
@d39 1
d42 1
a42 1
/*	if (g_stEngine.IsConnected())
d47 5
a51 1
	m_dwWaitTimeout = 1000; // perform check once per second
@


1.14
log
@v2 - more minor rearrangements
@
text
@d27 1
a27 1
		CEmClient		*pClient = (*pos).second;
d52 1
a52 1
	CEmClient	   *pClient;
d56 1
d63 1
d86 1
a86 1
	CEmClient		*pClient = AllocClient(eClientType);
d126 1
a126 1
	SOCKET		hSocket = pClient->m_hSocket;
@


1.13
log
@XML connecting, tray app
@
text
@d132 10
@


1.12
log
@There can be only one engine :-)
@
text
@d65 3
d92 2
a93 1
		pOnCompletionTask->SetClient(pClient);
@


1.11
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d8 1
a8 1
#include "../EmEngine.h"
d41 1
a41 1
	if (m_stEngine.IsConnected())
d45 1
a45 1

d91 1
a91 1
		SOCKET		hSocket = m_stEngine.m_stTcp.AllocConnect(nAddr, nPort, eClientType);
d122 1
a122 1
	pClient->OnDisconnected(m_stEngine);
@


1.10
log
@Modified my modifications for better genericness (I like genericity but it's not in the dictionary :P ).
@
text
@d109 1
a109 1
		AddDebugLogLine(false, "no memory");
@


1.9
log
@Modified code so Task caller can specify completion behavior.
@
text
@d79 1
a79 1
												   COnConnectedTask *pOnConnectedTask )
d88 2
a89 2
		pClient->m_pOnConnectedTask = pOnConnectedTask;
		pOnConnectedTask->SetClient(pClient);
d116 1
a116 1
void CTaskProcessor_Sockets::KillClient(CEmClient* pClient)
d119 3
a121 1
	SOCKET hSocket = pClient->m_hSocket;
d124 1
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d78 2
a79 1
CEmClient *CTaskProcessor_Sockets::AllocTcpConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eClientType)
d88 2
@


1.7
log
@Formatting, comments, and name changes.
@
text
@d76 1
a76 1
//////////////////////////////////////////////////////////////////////
d78 1
a78 1
CEmClient* CTaskProcessor_Sockets::AllocTcpConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eClientType)
@


1.6
log
@Formatting, comments, and name changes, the usual.
@
text
@d20 3
a24 1
	
d27 3
a29 2
		CEmClient* pClient = (*pos).second;
		ASSERT(pClient);
d39 3
a41 3
	// keep connection alive once per minute
	// recommended by lugdunummaster
	if(m_stEngine.IsConnected())
a47 1

d50 1
a50 1
CEmClient* CTaskProcessor_Sockets::AllocClient(T_CLIENT_TYPE eType)
d52 2
a53 1
	CEmClient* pClient;
d56 12
a67 12
	case T_CLIENT_PEER:
		pClient = new CEmClient_Peer;
		break;
	case T_CLIENT_SERVER:
		pClient = new CEmClient_Server;
		break;
	case T_CLIENT_WEB:
		pClient = new CEmClient_Web;
		break;
	default:
		ASSERT(FALSE); // invalid type ???
		return NULL;
d69 2
a70 1
	if (pClient)
d72 2
a75 1

d80 3
a82 2
	CEmClient* pClient = AllocClient(eClientType);
	if (pClient)
d85 1
a85 1
		pClient->m_nAddr = nAddr;
d87 3
a89 1
		SOCKET hSocket = m_stEngine.m_stTcp.AllocConnect(nAddr, nPort, eClientType);
@


1.5
log
@*** empty log message ***
@
text
@d10 1
a10 1
//////////////////////////////////////////////////////////////////////
d18 1
a18 2

//////////////////////////////////////////////////////////////////////
d31 1
a31 2

//////////////////////////////////////////////////////////////////////
d86 2
a87 1
		} else
d103 1
a103 2

//////////////////////////////////////////////////////////////////////
d113 1
@


1.4
log
@New engine - cosmetic changes
@
text
@d52 1
d56 1
a56 1
		return new CEmClient_Peer;
d59 1
a59 1
		return new CEmClient_Server;
d62 1
a62 1
		return new CEmClient_Web;
d66 1
d68 3
a70 1
	return NULL;
@


1.3
log
@New engine - cosmetic changes
@
text
@d40 1
a40 1
	if(m_stEngine.m_stData.IsConnected())
@


1.2
log
@New engine - name changes
@
text
@a5 1
#ifdef NEW_SOCKETS
a110 2

#endif@


1.1
log
@New engine
@
text
@d1 1
a1 1
// TaskProcessor_Main.cpp: implementation of the CTaskProcessor_Main class.
d13 1
a13 1
bool CTaskProcessor_Main::Start()
d22 1
a22 1
void CTaskProcessor_Main::Stop()
d37 1
a37 1
void CTaskProcessor_Main::ProcessTimeout()
d51 1
a51 1
CEmClient* CTaskProcessor_Main::AllocClient(T_CLIENT_TYPE eType)
d72 1
a72 1
CEmClient* CTaskProcessor_Main::AllocTcpConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eClientType)
d104 1
a104 1
void CTaskProcessor_Main::KillClient(CEmClient* pClient)
@

