head	1.4;
access;
symbols
	PublicRelease_1_2e:1.4
	Interim_Release_1-2e_RC1:1.4
	PublicRelease_1_2d:1.4
	Interim_Release_1-2d_RC1:1.4
	Interim_Release_1-2d_beta1:1.4
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4;
locks; strict;
comment	@ * @;


1.4
date	2005.04.07.17.24.51;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.06.18.31.27;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.05.05.49.06;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.29.14.36.14;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.4
log
@v2 - fixes for upload logic
@
text
@// TcpEngineMule.h: interface for the CTcpEngineMule class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "TcpEngine.h"

class COpCode;

// Constants
const UINT UPLOAD_MAX_STATS_RESULTS = 20;

// Time in milliseconds
const UINT TIME_RANGE_FOR_UPLOAD = 1000;	// calculate available bandwidth for next second


class CTcpEngineMule : public CTcpEngine
{
protected:
	struct OVERLAPPED_RECV_OPCODES : public OVERLAPPED_RECV
	{
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);

		const T_CLIENT_TYPE m_eType;

		OVERLAPPED_RECV_OPCODES(T_CLIENT_TYPE eType) : m_eType(eType) {}
	};

	virtual OVERLAPPED_RECV* AllocRecv(T_CLIENT_TYPE eType);

	virtual void OnSend(CState* pState, OVERLAPPED_SEND* pSend, EnumQueuePriority ePriority);
	virtual void OnTimer(CState* pState);

	// Upload limit
	typedef deque<OVERLAPPED_SEND*> UploadQueue;
	UploadQueue m_stUploadQueue[QUEUE_SIZE];
	ULONG m_arrUploadStats[UPLOAD_MAX_STATS_RESULTS];
	DWORD m_arrUploadTicks[UPLOAD_MAX_STATS_RESULTS];

	int m_nUploadIndex;
	CPreciseTime m_tmLastCheck;
	DWORD	m_dwAvailableBandwidth;

public:
	CTcpEngineMule();
	virtual ~CTcpEngineMule();
	bool	AllocSend(SOCKET hSocket, const COpCode&, EnumQueuePriority);
	DWORD	GetAvailableBandwidth(){ return m_dwAvailableBandwidth; }
};
@


1.3
log
@v2 - upload works (basic implementation)
@
text
@d15 1
a15 1
const UINT TIME_RANGE_FOR_UPLOAD	= 1000;	// calculate available bandwidth for next second
d32 1
a32 1
	virtual void OnSend(CState* pState, OVERLAPPED_SEND* pSend, bool bToEnd);
d37 1
a37 1
	UploadQueue m_stUploadQueue;
d48 1
a48 1
	bool	AllocSend(SOCKET hSocket, const COpCode&);
@


1.2
log
@v2 - more upload logic, light configuration (without BerkeleyDb)
@
text
@a11 1
const UINT UPLOAD_BLOCK_SIZE		= 512;
a14 1
const UINT TIMER_CHECK_TIME			= 100;	// for limiting bandwidth on timer
d43 1
d49 1
a49 1
	DWORD	GetAvailableBandwidth();
@


1.1
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d11 9
d37 9
d47 4
a50 1
	bool AllocSend(SOCKET hSocket, const COpCode&);
@

