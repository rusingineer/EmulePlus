head	1.5;
access;
symbols
	PublicRelease_1_2e:1.5
	Interim_Release_1-2e_RC1:1.5
	PublicRelease_1_2d:1.5
	Interim_Release_1-2d_RC1:1.5
	Interim_Release_1-2d_beta1:1.5
	PublicRelease_1_2c:1.5
	Interim_Release_1-2c_RC1:1.5
	Interim_Release_1-2c_beta1:1.5
	PublicRelease_1_2b:1.5
	Interim_Release_1-2b_RC1:1.5
	PublicRelease_1_2a:1.5
	Interim_Release_1-2a_RC1:1.5
	Interim_Release_1-2a_beta2:1.5
	Interim_Release_1-2a_beta1:1.5
	PublicRelease_1_2:1.5
	Interim_Release_1-2_RC1:1.5
	Interim_Release_1-2_beta1:1.5
	PublicRelease_1_1g:1.5
	Interim_Release_1-1g_RC3:1.5
	Interim_Release_1-1g_RC2:1.5
	Interim_Release_1-1g_RC1:1.5
	Interim_Release_1-1g_beta2:1.5
	Interim_Release_1-1g_beta1:1.5
	PublicRelease_1_1f:1.5
	Interim_Release_1-1f_RC1:1.5
	PublicRelease_1_1e:1.5
	Interim_Release_1-1e_RC2:1.5
	Interim_Release_1-1e_RC1:1.5
	Interim_Release_1-1e_beta1:1.5;
locks; strict;
comment	@// @;


1.5
date	2005.04.17.05.16.25;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.07.17.24.51;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.06.18.31.27;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2005.04.05.05.49.06;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.29.14.36.14;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.5
log
@v2 - corrected protocol, tags
@
text
@// TcpEngineMule.cpp: implementation of the CTcpEngineMule class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TcpEngineMule.h"

#include "OpCode.h"
#include "../Data/Prefs.h"

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTcpEngineMule::CTcpEngineMule()
{
	ZeroMemory(m_arrUploadStats, sizeof(m_arrUploadStats));
	ZeroMemory(m_arrUploadTicks, sizeof(m_arrUploadTicks));
	m_nUploadIndex = 0;
	m_tmLastCheck = CPreciseTime::GetCurrentTime();
	m_dwAvailableBandwidth = 0;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTcpEngineMule::~CTcpEngineMule()
{
	// Destroy all unsent packets
	for(int i = 0; i < QUEUE_SIZE; i++)
	{
		while(!m_stUploadQueue[i].empty())
		{
			OVERLAPPED_SEND* pSend = m_stUploadQueue[i].front();
			delete pSend;
			m_stUploadQueue[i].pop_front();
		}
	}
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTcpEngine::OVERLAPPED_RECV *CTcpEngineMule::AllocRecv(T_CLIENT_TYPE eType)
{
	switch (eType)
	{
	case T_CLIENT_PEER:
	case T_CLIENT_SERVER:
		return new OVERLAPPED_RECV_OPCODES(eType);
	default:
		return CTcpEngine::AllocRecv(eType);
	}

	return NULL;
}

//////////////////////////////////////////////////////////////////////
bool CTcpEngineMule::AllocSend(SOCKET hSocket, const COpCode &stOpCode, EnumQueuePriority ePriority)
{
	BYTE			pBuf[TCP_OPTIMAL_BUF];
	CStream_MemEx	stStream;

	stStream.m_pPtr = pBuf;
	stStream.m_dwSize = sizeof(pBuf);

	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP, stOpCode.m_bSupportNewTags));
	if (!stStream.m_dwSizeExtra)
		return CTcpEngine::AllocSend(hSocket, pBuf, sizeof(pBuf) - stStream.m_dwSize, ePriority);

	//	This opcode seems to be huge.
	DWORD dwSizeHuge = sizeof(pBuf) + stStream.m_dwSizeExtra;
	PBYTE pBufDyn = new BYTE[dwSizeHuge];

	if (!pBufDyn)
	{
		AddLog(LOG_ERROR, _T("No memory"));
		CTask_Tcp_Err::Post(hSocket, -1);
		return false;
	}

	stStream.m_pPtr = pBufDyn;
	stStream.m_dwSize = dwSizeHuge;
	stStream.m_dwSizeExtra = 0;
	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP, stOpCode.m_bSupportNewTags));

	bool bSend = CTcpEngine::AllocSend(hSocket, pBufDyn, dwSizeHuge, ePriority);
	delete[] pBufDyn;

	return bSend;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CTcpEngineMule::OVERLAPPED_RECV_OPCODES::ParseRecv(CTcpEngine &stEngine, bool)
{
	char* pData = GetBuffer();

	ASSERT(pData);

	for (DWORD dwParsed = 0; ;)
	{
		//	Over tcp transport, opcodes always have a header of 6 bytes
		if (m_dwBufUsage < 6 + dwParsed)
		{
			break;
		}

		DWORD dwOpCodeLen = *((DWORD*) (pData + 1));

		if (dwOpCodeLen == 0)
		{
			AddLog(LOG_ERROR, _T("Invalid recv data"));
			return m_dwBufUsage; // will discard all the buffer
		}

		if (dwOpCodeLen + 5 + dwParsed > m_dwBufUsage)
			break;

		CStream_Mem stStream;

		stStream.m_pPtr = (PBYTE) pData + 6;
		stStream.m_dwSize = dwOpCodeLen - 1;

		TCHAR strOpCode[100];
		strOpCode[0] = NULL;
		COpCode* pOpCode = COpCode::Read(stStream, ((PBYTE)pData)[5], ((PBYTE)pData)[0], m_eType, strOpCode);

		if (pOpCode != NULL)
		{
			if (stStream.m_dwSize)
			{
				//				ASSERT(FALSE);
				AddLog(LOG_WARNING, _T("%u bytes left from OpCode initialization, id=%s (%x)"), stStream.m_dwSize, pOpCode->TaskName(), pOpCode->GetID());
			}

			pOpCode->m_hSocket = m_hSocket;
			g_stEngine.Sockets.Push(pOpCode);
			//	g_stEngine.PushToLogger(pOpCode);
		}
		else
		{
			AddLog(LOG_WARNING, _T("Can't receive opcode %s (%x) protocol=%x"), strOpCode, ((PBYTE)pData)[5], ((PBYTE)pData)[0]);
			//			ASSERT(FALSE);
		}

		dwOpCodeLen += 5;
		pData += dwOpCodeLen;
		dwParsed += dwOpCodeLen;
	}
	return dwParsed;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngineMule::OnSend(CState* pState, OVERLAPPED_SEND* pSend, EnumQueuePriority ePriority)
{
	m_stUploadQueue[ePriority].push_back(pSend);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTcpEngineMule::OnTimer(CState* pState)
{
	// 1st of all - approximate how much data we can send now.
	CPreciseTime tmNow = CPreciseTime::GetCurrentTime();

	DWORD dwPeriod = 0, dwSizeSent = 0;
	for (int i = 0; i < UPLOAD_MAX_STATS_RESULTS; i++)
	{
		dwPeriod += m_arrUploadTicks[i];
		dwSizeSent += m_arrUploadStats[i];
	}

	// If we're only starting, let's send 100 bytes per cycle
	DWORD dwBytesToSend = 100;

	if (dwPeriod)
	{
		// GetMaxUpload() returns 15 for 1.5 kb/sec, 
		// Therefore we multiply it by 1kb and divide by 10
		// (another 1000 for convert time from milliseconds to seconds)
		dwBytesToSend = g_stEngine.Prefs.GetMaxUpload() * 1024 * (dwPeriod + TIMER_CHECK_TIME) / 10000;
		if (dwBytesToSend > dwSizeSent)
			dwBytesToSend -= dwSizeSent;
		else
			dwBytesToSend = 0;
	}

	dwSizeSent = 0;

	for(int i = 0; i < QUEUE_SIZE; i++)
	{
		while(!m_stUploadQueue[i].empty())
		{
			OVERLAPPED_SEND* pSend = m_stUploadQueue[i].front();
			ASSERT(pSend);

			// If this block's size is too much, we stop until next check
			if (pSend->len > dwBytesToSend)
				break;

			m_stUploadQueue[i].pop_front();

			DWORD dwLen = pSend->len;

			if(!pState->SendBlock(pSend))
			{
				// In case of error we don't count this packet
				dwLen = 0;
			}

			dwBytesToSend -= dwLen;
			dwSizeSent += dwLen;
		}
	}

	// Fill in values for bandwidth approximation
	m_arrUploadStats[m_nUploadIndex] = dwSizeSent;
	m_arrUploadTicks[m_nUploadIndex] = tmNow - m_tmLastCheck;

	m_tmLastCheck = tmNow;
	m_nUploadIndex = (m_nUploadIndex + 1) % UPLOAD_MAX_STATS_RESULTS;


	// Calculate occupied bandwidth
	DWORD dwSizeToSend = 0;
	for(int i = 0; i < QUEUE_SIZE; i++)
	{
		for(UploadQueue::iterator it = m_stUploadQueue[i].begin(); it != m_stUploadQueue[i].end(); it++)
		{
			OVERLAPPED_SEND* pSend = *it;
			ASSERT(pSend);
			dwSizeToSend += pSend->len;
		}
	}

	// GetMaxUpload() returns 15 for 1.5 kb/sec, 
	// Therefore we multiply it by 1kb and divide by 10
	// (another 1000 for convert time from milliseconds to seconds)
	DWORD dwUpperLimit = g_stEngine.Prefs.GetMaxUpload() * 1024 * TIME_RANGE_FOR_UPLOAD / 10000;
	if (dwSizeToSend < dwUpperLimit)
		m_dwAvailableBandwidth = dwUpperLimit - dwSizeToSend;
	else
		m_dwAvailableBandwidth = 0;	// all bandwidth for next second is already taken out
}
@


1.4
log
@v2 - fixes for upload logic
@
text
@d60 1
a60 1
	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP));
d78 1
a78 1
	VERIFY(stOpCode.Write(stStream, OP_TRANSPORT_TCP));
@


1.3
log
@v2 - upload works (basic implementation)
@
text
@d25 1
a25 1
	while(!m_stUploadQueue.empty())
d27 6
a32 3
		OVERLAPPED_SEND* pSend = m_stUploadQueue.front();
		delete pSend;
		m_stUploadQueue.pop_front();
d52 1
a52 1
bool CTcpEngineMule::AllocSend(SOCKET hSocket, const COpCode &stOpCode)
d62 1
a62 1
		return CTcpEngine::AllocSend(hSocket, pBuf, sizeof(pBuf) - stStream.m_dwSize);
d80 1
a80 1
	bool bSend = CTcpEngine::AllocSend(hSocket, pBufDyn, dwSizeHuge);
d147 1
a147 1
void CTcpEngineMule::OnSend(CState* pState, OVERLAPPED_SEND* pSend, bool bToEnd)
d149 1
a149 4
	if(bToEnd)
		m_stUploadQueue.push_back(pSend);
	else
		m_stUploadQueue.push_front(pSend);
d182 1
a182 1
	while(!m_stUploadQueue.empty())
d184 8
a191 2
		OVERLAPPED_SEND* pSend = m_stUploadQueue.front();
		ASSERT(pSend);
d193 1
a193 3
		// If this block's size is too much, we stop until next check
		if (pSend->len > dwBytesToSend)
			break;
d195 1
a195 1
		m_stUploadQueue.pop_front();
d197 5
a201 1
		DWORD dwLen = pSend->len;
d203 2
a204 4
		if(!pState->SendBlock(pSend))
		{
			// In case of error we don't count this packet
			dwLen = 0;
a205 3

		dwBytesToSend -= dwLen;
		dwSizeSent += dwLen;
d218 1
a218 1
	for(UploadQueue::iterator it = m_stUploadQueue.begin(); it != m_stUploadQueue.end(); it++)
d220 6
a225 3
		OVERLAPPED_SEND* pSend = *it;
		ASSERT(pSend);
		dwSizeToSend += pSend->len;
@


1.2
log
@v2 - more upload logic, light configuration (without BerkeleyDb)
@
text
@d18 1
a210 1
}
d212 1
a212 3
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
DWORD CTcpEngineMule::GetAvailableBandwidth()
{
d227 1
a227 1
		return dwUpperLimit - dwSizeToSend;
d229 1
a229 1
		return 0;	// all bandwidth for next second is already taken out
@


1.1
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d12 21
d146 1
a146 1
		pState->m_stUploadQueue.push_back(pSend);
d148 1
a148 1
		pState->m_stUploadQueue.push_front(pSend);
d160 2
a161 2
		dwPeriod += pState->m_arrUploadTicks[i];
		dwSizeSent += pState->m_arrUploadStats[i];
d181 1
a181 1
	while(!pState->m_stUploadQueue.empty())
d183 1
a183 1
		OVERLAPPED_SEND* pSend = pState->m_stUploadQueue.front();
d190 1
a190 1
		pState->m_stUploadQueue.pop_front();
d205 2
a206 2
	pState->m_arrUploadStats[pState->m_nUploadIndex] = dwSizeSent;
	pState->m_arrUploadTicks[pState->m_nUploadIndex] = tmNow - pState->m_tmLastCheck;
d208 24
a231 2
	pState->m_tmLastCheck = tmNow;
	pState->m_nUploadIndex = (pState->m_nUploadIndex + 1) % UPLOAD_MAX_STATS_RESULTS;
@

