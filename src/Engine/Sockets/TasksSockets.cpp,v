head	1.17;
access;
symbols
	PublicRelease_1_2e:1.17
	Interim_Release_1-2e_RC1:1.17
	PublicRelease_1_2d:1.17
	Interim_Release_1-2d_RC1:1.17
	Interim_Release_1-2d_beta1:1.17
	PublicRelease_1_2c:1.17
	Interim_Release_1-2c_RC1:1.17
	Interim_Release_1-2c_beta1:1.17
	PublicRelease_1_2b:1.17
	Interim_Release_1-2b_RC1:1.17
	PublicRelease_1_2a:1.17
	Interim_Release_1-2a_RC1:1.17
	Interim_Release_1-2a_beta2:1.17
	Interim_Release_1-2a_beta1:1.17
	PublicRelease_1_2:1.17
	Interim_Release_1-2_RC1:1.17
	Interim_Release_1-2_beta1:1.17
	PublicRelease_1_1g:1.17
	Interim_Release_1-1g_RC3:1.17
	Interim_Release_1-1g_RC2:1.17
	Interim_Release_1-1g_RC1:1.17
	Interim_Release_1-1g_beta2:1.17
	Interim_Release_1-1g_beta1:1.17
	PublicRelease_1_1f:1.17
	Interim_Release_1-1f_RC1:1.17
	PublicRelease_1_1e:1.17
	Interim_Release_1-1e_RC2:1.17
	Interim_Release_1-1e_RC1:1.17
	Interim_Release_1-1e_beta1:1.17
	PublicRelease_1_1d:1.16
	Interim_Release_1-1d_RC1:1.16
	PublicRelease_1_1c:1.16
	Interim_Release_1-1c_RC1:1.16
	Interim_Release_1-1c_beta2:1.14
	Interim_Release_1-1c_beta1:1.13
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.9
	PublicRelease_1_1a:1.9
	Interim_Release_1-1a_RC2:1.9
	Interim_Release_1-1a_RC1:1.9
	Interim_Release_1-1a_beta2:1.9
	Interim_Release_1-1a_beta1:1.9
	PublicRelease_1_1:1.9
	Interim_Release_1-1_beta1:1.9
	PublicRelease_1o:1.9
	Interim_Release_1o_RC1:1.9
	Interim_Release_1o_beta1:1.9
	PublicRelease_1n:1.9
	Interim_Release_1n_RC2:1.9
	Interim_Release_1n_RC1:1.9
	PublicRelease_1m:1.8
	Interim_Release_1m_beta1:1.8
	PublicRelease_1l:1.8
	Interim_Release_1l_RC3:1.8
	Interim_Release_1l_RC2:1.8
	Interim_Release_1l_RC1:1.8
	Interim_Release_1l_beta2:1.8
	Interim_Release_1l_beta1:1.8
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.4
	Interim_Release_1J_RC3:1.4
	Interim_Release_1j_RC3:1.4
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.3;
locks; strict;
comment	@// @;


1.17
date	2005.03.22.22.02.10;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.18.18.31.25;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.18.18.03.29;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.03.15.14.16;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.28.20.13.52;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2004.06.30.13.39.04;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.07.11.37.09;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.07.11.31.46;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.06.13.57.27;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.06.13.55.06;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.07.10.54.33;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.23.18.13.48;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.21.10.29.05;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.17
log
@v2 - enhancing logging subsystem
@
text
@// Tasks.cpp: implementation of the CTasks class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TasksSockets.h"
#include "TaskProcessorSockets.h"
#include "../XML/XML.h"

//////////////////////////////////////////////////////////////////////
// global and sockets task functions
CTask::~CTask()
{
}

bool CTask::OnException()
{
	// delete this buggy task
	return true;
}

bool CTask_Tcp_Err::Post(SOCKET hSocket, int nErrorCode)
{
	CTask_Tcp_Err* pTask = new CTask_Tcp_Err;
	if (pTask)
	{
		pTask->m_hSocket = hSocket;
		pTask->m_nError = nErrorCode;
		g_stEngine.Sockets.Push(pTask);
	} 
	else
	{
		AddLog(LOG_ERROR, _T("No memory"));
	}

	return NULL != pTask;
}

bool CTask_Tcp_Err::Process()
{
	// check if we still have this client
	CEmClient* pClient = g_stEngine.Sockets.Lookup(m_hSocket);
	if (pClient)
	{
		ASSERT(pClient->m_hSocket == m_hSocket);
		// here we can write to the log that this client has disconnected from us

		g_stEngine.Sockets.KillClient(pClient);
	}

	return true;
}

bool CTask_Tcp_Accepted::Process()
{
	CEmClient* pClient = g_stEngine.Sockets.AllocClient(m_eType);
	ASSERT(pClient);
	if (pClient)
	{
		pClient->m_bFromOutside = true;
		pClient->m_hSocket = m_hSocket;
		pClient->m_bIsConnected = true;
		g_stEngine.Sockets.AddClientToMap(m_hSocket, pClient);

		pClient->OnAccepted();

	} else
	{
		AddLog(LOG_ERROR, _T("No memory"));
		if(closesocket(m_hSocket))
			AddLog(LOG_ERROR, _T("closesocket failed"));
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_Tcp_Connected::Process()
{
	CEmClient *pClient = g_stEngine.Sockets.Lookup(m_hSocket);

	if (pClient != NULL)
	{
		ASSERT(!pClient->m_bIsConnected);
		pClient->m_bIsConnected = true;

		pClient->OnConnected();
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_Tcp_Web::Process()
{
	CEmClient_Web* pClient = (CEmClient_Web*) g_stEngine.Sockets.Lookup(m_hSocket);
	if (pClient)
	{
		ASSERT(T_CLIENT_WEB == pClient->GetType());

/*		  CString strTxt;
		  strTxt.Format("Currently I have %d clients", g_stEngine.m_stSocketsTP.m_mapClients.size());
		  g_stEngine.m_stTcp.AllocSend(m_hSocket, (LPCTSTR) strTxt, strTxt.GetLength());
		  g_stEngine.m_stTcp.AllocDisconnect(m_hSocket);*/
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_Tcp_Xml::Process()
{
	CEmClient_Xml* pClient = (CEmClient_Xml*) g_stEngine.Sockets.Lookup(m_hSocket);
	if (pClient)
	{
		ASSERT(T_CLIENT_XML == pClient->GetType());

		//AddDebugLogLine(_T("Received: %s"), m_pBuf);
		CString sXml((LPCTSTR)m_pBuf);
		CXmlTask* pTask = CXmlTask::ParseXml(sXml);
		if(pTask)
		{
			pTask->SetClient(pClient);
			g_stEngine.Sockets.Push(pTask);
		}
/*		CString strTxt;
		strTxt.Format("Currently I have %d clients", g_stEngine.m_stSocketsTP.m_mapClients.size());
		g_stEngine.m_stTcp.AllocSend(m_hSocket, (LPCTSTR) strTxt, strTxt.GetLength());
		g_stEngine.m_stTcp.AllocDisconnect(m_hSocket);*/
	}

	return true;
}
// end of global and socket task functions
//////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// connect
CTask_Connect::CTask_Connect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType, CTcpCompletionTask *pOnCompletionTask/*= NULL*/)
	: m_dwAddr(nAddr), m_uPort(nPort), m_eType(eType), m_pOnCompletionTask(pOnCompletionTask)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTask_Connect::CTask_Connect(LPCTSTR sAddr, USHORT nPort, T_CLIENT_TYPE eType, CTcpCompletionTask *pOnCompletionTask/*= NULL*/) 
	: m_dwAddr(inet_addr(sAddr)), m_uPort(nPort), m_eType(eType), m_pOnCompletionTask(pOnCompletionTask)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_Connect::Process()
{
	if (m_dwAddr != 0 && m_uPort != 0)
	{
		g_stEngine.Sockets.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnCompletionTask);
	}
	else
	{
	//	Connect to any server
	//	For now, we'll hardcode Razorback say?
		m_dwAddr = inet_addr(_T("195.245.244.243"));
		m_uPort = 4661;
		g_stEngine.Sockets.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnCompletionTask);
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// disconnect
CTask_KillClient::CTask_KillClient(CEmClient *pClient)
	: m_pClient(pClient)
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_KillClient::Process()
{
	g_stEngine.Sockets.KillClient(m_pClient);

	return true;
}

@


1.16
log
@v2 - more minor rearrangements
@
text
@d33 1
a33 2
		ASSERT(FALSE);
		AddDebugLogLine("no memory");
d69 3
a71 4
		ASSERT(FALSE);
		AddDebugLogLine("no memory");
		if (closesocket(m_hSocket))
			AddDebugLogLine("closesocket failed");
@


1.15
log
@v2 - minor rearrangements, fixes for EngineTray compilation
@
text
@d29 1
a29 1
		g_stEngine.PushToSocketsTP(pTask);
d43 1
a43 1
	CEmClient* pClient = g_stEngine.LookupClient(m_hSocket);
d49 1
a49 1
		g_stEngine.KillClient(pClient);
d57 1
a57 1
	CEmClient* pClient = g_stEngine.AllocClient(m_eType);
d64 1
a64 1
		g_stEngine.AddClientToMap(m_hSocket, pClient);
d81 1
a81 1
	CEmClient *pClient = g_stEngine.LookupClient(m_hSocket);
d95 1
a95 1
	CEmClient_Web* pClient = (CEmClient_Web*) g_stEngine.LookupClient(m_hSocket);
d111 1
a111 1
	CEmClient_Xml* pClient = (CEmClient_Xml*) g_stEngine.LookupClient(m_hSocket);
d122 1
a122 1
			g_stEngine.PushToSocketsTP(pTask);
d151 1
a151 1
		g_stEngine.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnCompletionTask);
d159 1
a159 1
		g_stEngine.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnCompletionTask);
d173 1
a173 1
	g_stEngine.KillClient(m_pClient);
@


1.14
log
@Ideological switch (may be considered as temporary, but for long term) - ATL to MFC
Actually we don't need them both, but I want to work with our current KnownFile-based classes, which use MFC a lot
@
text
@a7 3
//#include "OpCode.h"
//#include "../Data/Server.h"
#include "../../otherfunctions.h"
@


1.13
log
@Xml and database functionality
@
text
@d124 1
a124 1
			pTask->m_pClient = pClient;
@


1.12
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@a5 1
#include "../EmEngine.h"
@


1.11
log
@XML connecting, tray app
@
text
@d6 1
a6 1

@


1.10
log
@There can be only one engine :-)
@
text
@d12 1
d112 24
d160 2
a161 2
	//	For now, we'll hardcode Razorback say? I know there's got to be a macro for this.
		m_dwAddr = 195 * 0x1000 + 245 * 0x100 + 244 * 10 + 243;
@


1.9
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a7 1
#include "../EmEngine.h"
d9 2
a10 2
#include "OpCode.h"
#include "../Data/Server.h"
d19 1
a19 1
bool CTask::OnException(CEmEngine&)
d25 1
a25 1
bool CTask_Tcp_Err::Post(CEmEngine& stEngine, SOCKET hSocket, int nErrorCode)
d32 1
a32 1
		stEngine.PushToSocketsTP(pTask);
d43 1
a43 1
bool CTask_Tcp_Err::Process(CEmEngine& stEngine)
d46 1
a46 1
	CEmClient* pClient = stEngine.m_stSocketsTP.Lookup(m_hSocket);
d52 1
a52 1
		stEngine.m_stSocketsTP.KillClient(pClient);
d58 1
a58 1
bool CTask_Tcp_Accepted::Process(CEmEngine& stEngine)
d60 1
a60 1
	CEmClient* pClient = stEngine.m_stSocketsTP.AllocClient(m_eType);
d67 1
a67 1
		stEngine.m_stSocketsTP.m_mapClients[m_hSocket] = pClient;
d69 1
a69 1
		pClient->OnAccepted(stEngine);
d82 1
a82 1
bool CTask_Tcp_Connected::Process(CEmEngine &stEngine)
d84 1
a84 1
	CEmClient		*pClient = stEngine.m_stSocketsTP.Lookup(m_hSocket);
d91 1
a91 1
		pClient->OnConnected(stEngine);
d96 1
a96 1
bool CTask_Tcp_Web::Process(CEmEngine& stEngine)
d98 1
a98 1
	CEmClient_Web* pClient = (CEmClient_Web*) stEngine.m_stSocketsTP.Lookup(m_hSocket);
d103 4
a106 4
		  CString strTxt;
		  strTxt.Format("Currently I have %d clients", stEngine.m_stSocketsTP.m_mapClients.size());
		  stEngine.m_stTcp.AllocSend(m_hSocket, (LPCTSTR) strTxt, strTxt.GetLength());
		  stEngine.m_stTcp.AllocDisconnect(m_hSocket);
a114 131
bool CTask_LoginToServer::Process(CEmEngine &rEngine)
{
//	Reset message count
//	m_pServer->m_nMsgCount = 0;
	if (m_pServer == NULL)
	{
	//	Report error...
		return true;
	}
	if (m_iMessage == FD_CONNECT)
	{
	//
	//	We've just connected. Make sure we're prepared to handle disconnect.
		CTask_DisconnectServer		*pOnDisconnectTask = new CTask_DisconnectServer();

		pOnDisconnectTask->m_pServer = m_pServer;
		m_pServer->m_pOnCompletionTask = pOnDisconnectTask;

	//	Disconnect from previous connected server, if any
		if ( rEngine.GetServerSocket() != m_pServer->m_hSocket
		&& rEngine.GetServerSocket() != 0 )
		{
			rEngine.DisconnectFromServer(rEngine.GetServerSocket());
		}

	//	Set connection info
		rEngine.ConnectedTo(m_pServer);
		rEngine.SetConnectionState(SERVER_WAITFORLOGIN);

		COpCode_LOGINREQUEST		stMsg;

		md4cpy(stMsg._UserHash, rEngine.GetUserHash());
		stMsg._ClientID = rEngine.GetClientID();
		stMsg._ClientPort = rEngine.GetPort();
		stMsg._UserName.m_strValue = rEngine.GetUserNick();
		stMsg._UserName.m_bValid = true;
		stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
		stMsg._ClientSoftVersion.m_bValid = true;
		stMsg._UserPort.m_dwValue = rEngine.GetPort();
		stMsg._UserPort.m_bValid = true;

		rEngine.SendOpCode(m_pServer->m_hSocket, stMsg, m_pServer);
	}
	else
	{
	//	We're not expecting this.
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTask_DisconnectServer::Process(CEmEngine &rEngine)
{
	if (m_pServer == NULL)
		return true;

	// (!) at any reason, can be even if we tried to connect and failed

	if (m_iMessage == FD_CLOSE)
	{
		// Set connection info
		if (rEngine.GetServerSocket() == m_pServer->m_hSocket)
		{
			rEngine.SetConnectionState(SERVER_DISCONNECTED);
		}
		else
		{
			// removed if, because we can get 'disconnected' even if we didn't
			// succeeded to connect yet, thus GetConnectingServer() won't return
			// correct value
			// if(rEngine.GetConnectingServer() == m_hSocket)
			rEngine.SetConnectionState(SERVER_DISCONNECTED);
			// TODO: mark somewhere that server is dead
		}
	}
	else
	{
	//	We're not expecting this.
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// (!) can be both we connected to him or he connected to us
// sending HELLO opcode.
//	MOREVIT: If I'm understanding this correctly, you're saying that
//		when another client connects to us to say HELLO, we're going
//		a HELLO back. What's the point in that? Once the HELLOANSWER
//		is received, both sides have all the information they need
//		about the other.
bool CTask_SayHelloToPeer::Process(CEmEngine &rEngine)
{
	if (m_pPeer == NULL)
		return true;

	if (m_iMessage == FD_CONNECT && !m_pPeer->m_bFromOutside)
	{
		COpCode_HELLO		stMsg;

		md4cpy(stMsg._UserHash, rEngine.GetUserHash());
		stMsg._ClientAddr._IPAddr = rEngine.GetClientID();
		stMsg._ClientAddr._Port = rEngine.GetPort();
		stMsg._UserName.m_strValue = rEngine.GetUserNick();
		stMsg._UserName.m_bValid = TRUE;
		stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
		stMsg._ClientSoftVersion.m_bValid = TRUE;
		stMsg._UserPort.m_dwValue = rEngine.GetPort();
		stMsg._UserPort.m_bValid = TRUE;

		if (rEngine.IsConnected())
		{
			stMsg._ServerAddr._IPAddr = rEngine.GetConnectedState()->nAddr;
			stMsg._ServerAddr._Port = rEngine.GetConnectedState()->nPort;
		}
		else
		{
			stMsg._ServerAddr._IPAddr = 0;
			stMsg._ServerAddr._Port = 0;
		}

		rEngine.SendOpCode(m_pPeer->m_hSocket, stMsg, m_pPeer);
	}
	else
	{
	}

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d126 1
a126 1
bool CTask_Connect::Process(CEmEngine &stEngine)
d130 1
a130 1
		stEngine.m_stSocketsTP.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnCompletionTask);
d138 1
a138 1
		stEngine.m_stSocketsTP.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnCompletionTask);
d150 1
a150 16
bool CTask_KillClient::Process(CEmEngine &stEngine)
{
	stEngine.KillClient(m_pClient);

	return true;
}

//////////////////////////////////////////////////////////////////////
// send list of shared files
CTask_SendSharedList::CTask_SendSharedList()
{
	m_bProcessedUI = false;
}

//////////////////////////////////////////////////////////////////////
bool CTask_SendSharedList::Process(CEmEngine& stEngine)
d152 1
a152 2
	if(!stEngine.IsConnected())
		return true;
a153 23
	// first collect shared files info
/*	if(!m_bProcessedUI)
	{
		stEngine.PushToUI(this);
		return false;
	}
*/
	// afterwards, send it
/*	COpCode_OFFERFILES stMsg;
	for(int i = 0; i < m_Files.GetCount(); i++)
	{
		COpCode_OFFERFILES::CStruct_Files file;
		md4cpy(file._Hash, m_Files[i]._Hash);
		file._Client._Addr = 0;
		file._Client._Port = 0;
		file._FileName.m_strValue = m_Files[i]._FileName;
		file._FileName.m_bValid = true;
		file._FileSize.m_dwValue = m_Files[i]._FileSize;
		file._FileSize.m_bValid = true;
		stMsg._Files.Add(file);
	}
	stEngine.m_stTcp.AllocSend(stEngine.m_stData.GetConnectedServer(), stMsg);
*/
a156 31
//////////////////////////////////////////////////////////////////////
/*bool CTask_SendSharedList::ProcessForUI(CEmEngine& stEngine)
{
	CKnownFile	*pKnownFile;
	CCKey		bufKey;
	for (POSITION pos = g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetStartPosition(); pos != 0; )
	{
		g_eMuleApp.m_pSharedFilesList->m_mapSharedFiles.GetNextAssoc(pos, bufKey, pKnownFile);
		if(pKnownFile)
		{
			OFFEREDFILE File;

			md4cpy(File._Hash, pKnownFile->GetFileHash());
			File._Addr = 0;
			File._Port = 0;
			File._FileName = pKnownFile->GetFileName();
			File._FileSize = pKnownFile->GetFileSize();

			m_Files.Add(File);

			pKnownFile->SetOfferedToServer(true);
		}
	}

	m_bProcessedUI = true;

	stEngine.m_stSocketsTP.Push(this);

	return false;
}
*/@


1.8
log
@Modified my modifications for better genericness (I like genericity but it's not in the dictionary :P ).
@
text
@d38 1
a38 1
		AddDebugLogLine(false, "no memory");
d75 1
a75 1
		AddDebugLogLine(false, "no memory");
d77 1
a77 1
			AddDebugLogLine(false, "closesocket failed");
@


1.7
log
@Modified code so Task caller can specify completion behavior.
@
text
@d125 1
a125 10
//
//	We've just connected. Make sure we're prepared to handle disconnect.
	CTask_DisconnectServer		*pOnDisconnectTask = new CTask_DisconnectServer();

	pOnDisconnectTask->m_pServer = m_pServer;
	m_pServer->m_pOnDisconnectedTask = pOnDisconnectTask;

//	Disconnect from previous connected server, if any
	if ( rEngine.GetServerSocket() != m_pServer->m_hSocket
	  && rEngine.GetServerSocket() != 0 )
d127 13
a139 2
		rEngine.DisconnectFromServer(rEngine.GetServerSocket());
	}
d141 3
a143 3
//	Set connection info
	rEngine.ConnectedTo(m_pServer);
	rEngine.SetConnectionState(SERVER_WAITFORLOGIN);
d145 1
a145 1
	COpCode_LOGINREQUEST		stMsg;
d147 9
a155 9
	md4cpy(stMsg._UserHash, rEngine.GetUserHash());
	stMsg._ClientID = rEngine.GetClientID();
	stMsg._ClientPort = rEngine.GetPort();
	stMsg._UserName.m_strValue = rEngine.GetUserNick();
	stMsg._UserName.m_bValid = true;
	stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientSoftVersion.m_bValid = true;
	stMsg._UserPort.m_dwValue = rEngine.GetPort();
	stMsg._UserPort.m_bValid = true;
d157 6
a162 1
	rEngine.SendOpCode(m_pServer->m_hSocket, stMsg, m_pServer);
d174 1
a174 2
	// Set connection info
	if (rEngine.GetServerSocket() == m_pServer->m_hSocket)
d176 14
a189 1
		rEngine.SetConnectionState(SERVER_DISCONNECTED);
d193 1
a193 6
		// removed if, because we can get 'disconnected' even if we didn't
		// succeeded to connect yet, thus GetConnectingServer() won't return
		// correct value
		// if(rEngine.GetConnectingServer() == m_hSocket)
		rEngine.SetConnectionState(SERVER_DISCONNECTED);
		// TODO: mark somewhere that server is dead
d213 1
a213 1
	if (!m_pPeer->m_bFromOutside)
d240 3
d248 2
a249 2
CTask_Connect::CTask_Connect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType, COnConnectedTask *pOnConnectedTask/*= NULL*/)
	: m_dwAddr(nAddr), m_uPort(nPort), m_eType(eType), m_pOnConnectedTask(pOnConnectedTask)
d253 2
a254 2
CTask_Connect::CTask_Connect(LPCTSTR sAddr, USHORT nPort, T_CLIENT_TYPE eType, COnConnectedTask *pOnConnectedTask/*= NULL*/) 
	: m_dwAddr(inet_addr(sAddr)), m_uPort(nPort), m_eType(eType), m_pOnConnectedTask(pOnConnectedTask)
d262 1
a262 1
		stEngine.m_stSocketsTP.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnConnectedTask);
d270 1
a270 1
		stEngine.m_stSocketsTP.AllocTcpConnect(m_dwAddr, m_uPort, m_eType, m_pOnConnectedTask);
@


1.6
log
@Formatting, comments, and name changes.
@
text
@d12 1
d116 114
d231 2
a232 2
CTask_Connect::CTask_Connect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE eType)
	: m_dwAddr(nAddr), m_uPort(nPort), m_eType(eType)
d236 2
a237 2
CTask_Connect::CTask_Connect(LPCTSTR sAddr, USHORT nPort, T_CLIENT_TYPE eType) 
	: m_dwAddr(inet_addr(sAddr)), m_uPort(nPort), m_eType(eType)
d245 1
a245 1
		stEngine.m_stSocketsTP.AllocTcpConnect(m_dwAddr, m_uPort, m_eType);
d253 1
a253 1
		stEngine.m_stSocketsTP.AllocTcpConnect(m_dwAddr, m_uPort, m_eType);
@


1.5
log
@Formatting, comments, and name changes.
@
text
@d81 4
d86 1
a86 4
bool CTask_Tcp_Connected::Process(CEmEngine& stEngine)
{
	CEmClient* pClient = stEngine.m_stSocketsTP.Lookup(m_hSocket);
	if (pClient)
d95 1
a95 1

d114 1
a114 2

//////////////////////////////////////////////////////////////////////
d120 1
a120 2

//////////////////////////////////////////////////////////////////////
d125 2
a126 3

//////////////////////////////////////////////////////////////////////
bool CTask_Connect::Process(CEmEngine& stEngine)
d143 1
a143 2

//////////////////////////////////////////////////////////////////////
d145 1
a145 1
CTask_KillClient::CTask_KillClient(CEmClient* pClient)
d149 2
a150 3

//////////////////////////////////////////////////////////////////////
bool CTask_KillClient::Process(CEmEngine& stEngine)
@


1.4
log
@New engine - cosmetic changes
@
text
@d117 1
a117 1
	: m_nAddr(nAddr), m_uPort(nPort), m_eType(eType)
d123 1
a123 1
	: m_nAddr(inet_addr(sAddr)), m_uPort(nPort), m_eType(eType)
d130 4
a133 2
	if(m_nAddr && m_uPort)
		stEngine.m_stSocketsTP.AllocTcpConnect(m_nAddr, m_uPort, m_eType);
d136 5
a140 1
		// Connect to any server
@


1.3
log
@New engine - connecting to server
@
text
@a8 1
#include "../EngineData.h"
d32 1
a32 1
		stEngine.m_stSocketsTP.Push(pTask);
d150 1
a150 1
	stEngine.m_stSocketsTP.KillClient(m_pClient);
d165 1
a165 1
	if(!stEngine.m_stData.IsConnected())
@


1.2
log
@New engine - name changes
@
text
@a128 21
CTask_Connect::CTask_Connect(CServer* pServer /* = NULL*/)
{
	EMULE_TRY

	if(pServer)
	{
//		AddLogLine(false, IDS_CONNECTINGTO, pServer->GetListName(), pServer->GetAddress(), pServer->GetPort());
		TRACE(_T("Connecting to server %s (%s:%d)\n"), pServer->GetName(), pServer->GetStrAddress(), pServer->GetPort());

		m_nAddr = inet_addr(pServer->GetStrAddress());
		m_uPort = pServer->GetPort();
	}
	else
		m_nAddr = m_uPort = NULL;

	m_eType = T_CLIENT_SERVER;

	EMULE_CATCH2
}

//////////////////////////////////////////////////////////////////////
d170 1
a170 1
	if(!m_bProcessedUI)
d175 1
a175 1

@


1.1
log
@New engine
@
text
@d33 1
a33 1
		stEngine.m_stMain.Push(pTask);
d47 1
a47 1
	CEmClient* pClient = stEngine.m_stMain.Lookup(m_hSocket);
d53 1
a53 1
		stEngine.m_stMain.KillClient(pClient);
d61 1
a61 1
	CEmClient* pClient = stEngine.m_stMain.AllocClient(m_eType);
d68 1
a68 1
		stEngine.m_stMain.m_mapClients[m_hSocket] = pClient;
d85 1
a85 1
	CEmClient* pClient = stEngine.m_stMain.Lookup(m_hSocket);
d98 1
a98 1
	CEmClient_Web* pClient = (CEmClient_Web*) stEngine.m_stMain.Lookup(m_hSocket);
d104 1
a104 1
		  strTxt.Format("Currently I have %d clients", stEngine.m_stMain.m_mapClients.size());
d153 1
a153 1
		stEngine.m_stMain.AllocTcpConnect(m_nAddr, m_uPort, m_eType);
d172 1
a172 1
	stEngine.m_stMain.KillClient(m_pClient);
d242 1
a242 1
	stEngine.m_stMain.Push(this);
@

