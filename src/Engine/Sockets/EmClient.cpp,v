head	1.24;
access;
symbols
	PublicRelease_1_2e:1.24
	Interim_Release_1-2e_RC1:1.24
	PublicRelease_1_2d:1.24
	Interim_Release_1-2d_RC1:1.24
	Interim_Release_1-2d_beta1:1.24
	PublicRelease_1_2c:1.24
	Interim_Release_1-2c_RC1:1.24
	Interim_Release_1-2c_beta1:1.24
	PublicRelease_1_2b:1.24
	Interim_Release_1-2b_RC1:1.24
	PublicRelease_1_2a:1.24
	Interim_Release_1-2a_RC1:1.24
	Interim_Release_1-2a_beta2:1.24
	Interim_Release_1-2a_beta1:1.24
	PublicRelease_1_2:1.24
	Interim_Release_1-2_RC1:1.24
	Interim_Release_1-2_beta1:1.24
	PublicRelease_1_1g:1.24
	Interim_Release_1-1g_RC3:1.24
	Interim_Release_1-1g_RC2:1.24
	Interim_Release_1-1g_RC1:1.24
	Interim_Release_1-1g_beta2:1.24
	Interim_Release_1-1g_beta1:1.24
	PublicRelease_1_1f:1.24
	Interim_Release_1-1f_RC1:1.24
	PublicRelease_1_1e:1.24
	Interim_Release_1-1e_RC2:1.24
	Interim_Release_1-1e_RC1:1.24
	Interim_Release_1-1e_beta1:1.24
	PublicRelease_1_1d:1.21
	Interim_Release_1-1d_RC1:1.21
	PublicRelease_1_1c:1.18
	Interim_Release_1-1c_RC1:1.18
	Interim_Release_1-1c_beta2:1.15
	Interim_Release_1-1c_beta1:1.15
	PublicRelease_1_1b:1.11
	Interim_Release_1-1b_RC1:1.11
	PublicRelease_1_1a:1.11
	Interim_Release_1-1a_RC2:1.11
	Interim_Release_1-1a_RC1:1.11
	Interim_Release_1-1a_beta2:1.11
	Interim_Release_1-1a_beta1:1.11
	PublicRelease_1_1:1.11
	Interim_Release_1-1_beta1:1.11
	PublicRelease_1o:1.11
	Interim_Release_1o_RC1:1.11
	Interim_Release_1o_beta1:1.11
	PublicRelease_1n:1.11
	Interim_Release_1n_RC2:1.11
	Interim_Release_1n_RC1:1.11
	PublicRelease_1m:1.10
	Interim_Release_1m_beta1:1.10
	PublicRelease_1l:1.10
	Interim_Release_1l_RC3:1.10
	Interim_Release_1l_RC2:1.10
	Interim_Release_1l_RC1:1.10
	Interim_Release_1l_beta2:1.10
	Interim_Release_1l_beta1:1.10
	PublicRelease_1k:1.10
	Interim_Release_1k_RC4:1.10
	Interim_1k_RC3:1.10
	Interim_1k_RC2:1.10
	Interim_Release_1k_RC1:1.10
	Interim_Release_1k_beta5:1.10
	Intrerim_Release_1k_beta4:1.10
	Interim_Release_1k_beta1:1.10
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.2;
locks; strict;
comment	@// @;


1.24
date	2005.03.29.14.36.13;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.27.05.01.51;	author kuchin;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.22.22.02.10;	author kuchin;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.13.19.30.16;	author kuchin;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.11.14.45.20;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.08.17.09.07;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.23.18.57.48;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.18.18.31.25;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.18.18.03.29;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.29.14.55.01;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.28.20.13.52;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.30.13.39.04;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2004.02.07.11.37.09;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2004.02.07.11.31.46;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.06.13.57.27;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.05.19.31.56;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.16.14.50.59;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2004.01.07.10.54.33;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.07.09.18.16;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.23.18.13.48;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.24
log
@v2 - increasing level of abstraction, more upload logic
@
text
@// EmClient.cpp
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "OpCode.h"
#include "TaskProcessorSockets.h"
#ifdef SUPPORT_CLIENT_PEER
	#include "../Data/ClientList.h"
#endif //SUPPORT_CLIENT_PEER

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CEmClient::~CEmClient()
{
	if(closesocket(m_hSocket))
		AddLog(LOG_ERROR, _T("closesocket failed"));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef SUPPORT_CLIENT_PEER
T_CLIENT_TYPE CEmClient_Peer::GetType() const
{
	return T_CLIENT_PEER;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
T_CLIENT_TYPE CEmClient_Server::GetType() const
{
	return T_CLIENT_SERVER;
}
#endif //SUPPORT_CLIENT_PEER
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
T_CLIENT_TYPE CEmClient_Web::GetType() const
{
	return T_CLIENT_WEB;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
T_CLIENT_TYPE CEmClient_Xml::GetType() const
{
	return T_CLIENT_XML;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmClient::OnConnected()
{
	if (m_pOnCompletionTask != NULL)
	{
		m_pOnCompletionTask->m_iMessage = FD_CONNECT;
		g_stEngine.Sockets.Push(m_pOnCompletionTask);
		m_pOnCompletionTask = NULL;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmClient::OnAccepted()
{
	if (m_pOnCompletionTask != NULL)
	{
		m_pOnCompletionTask->m_iMessage = FD_ACCEPT;
		g_stEngine.Sockets.Push(m_pOnCompletionTask);
		m_pOnCompletionTask = NULL;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmClient::OnDisconnected()
{
	if (m_pOnCompletionTask != NULL)
	{
		m_pOnCompletionTask->m_iMessage = FD_CLOSE;
		g_stEngine.Sockets.Push(m_pOnCompletionTask);
		m_pOnCompletionTask = NULL;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef SUPPORT_CLIENT_PEER
CEmClient_Peer::CEmClient_Peer()
{
	m_pMule = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmClient_Peer::OnDisconnected()
{ 
	if(m_pMule)
	{
		m_pMule->OnDisconnected();
		// Do not delete the object, it remains in the client list (until I decide other :)
		m_pMule = NULL; 
	}
	CEmClient::OnDisconnected(); 
}

CClientMule* CEmClient_Peer::_GetClientMule()
{
	if(m_pMule != NULL && g_stEngine.ClientList.IsValidClient(m_pMule))
		return m_pMule;
	else
	{
		// Removed from list...
		if(m_pMule != NULL)
		{
			AddLog(LOG_DEBUG, _T("Client mule has been removed? client (%s:%d)"), inet_ntoa(*reinterpret_cast<in_addr*>(&m_dwAddr)), m_uPort);
			m_pMule->OnDisconnected();
			m_pMule = NULL;
		}
		return NULL;
	}
}
#endif //SUPPORT_CLIENT_PEER

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// in the future - move webserver to this engine
//void CEmClient_Web::OnConnected()
//{
//	// say something...
//	char szSend[] = "GET / HTTP 1.1\r\n\r\n";
//	stEngine.m_stTcp.AllocSend(m_hSocket, szSend, sizeof(szSend) - 1);
//}
@


1.23
log
@v2 - minor improvements
@
text
@d9 1
a9 1
	#include "../Data/Client.h"
@


1.22
log
@v2 - enhancing logging subsystem
@
text
@d97 1
@


1.21
log
@v2 - little improvements
@
text
@d15 2
a16 2
	if (closesocket(m_hSocket))
		AddDebugLogLine("closesocket failed");
@


1.20
log
@v2 - more improvements
@
text
@d8 3
d19 1
d29 1
d71 1
a73 1
#ifndef NEW_SOCKETS_TRAY
a74 1
#endif //NEW_SOCKETS_TRAY
d79 6
a84 3
#ifndef NEW_SOCKETS_TRAY
	m_pMule = NULL; 
#endif //NEW_SOCKETS_TRAY
a87 2
#ifndef NEW_SOCKETS_TRAY

d90 1
a90 1
	if(m_pMule != NULL && g_stEngine.Sockets.m_ClientList.IsValidClient(m_pMule))
d93 7
d101 1
d103 1
a103 2

#endif //NEW_SOCKETS_TRAY
@


1.19
log
@v2 - minor rearrangements, started defining client and clientlist
@
text
@d81 11
@


1.18
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d66 17
@


1.17
log
@v2 - more minor rearrangements
@
text
@d42 1
d52 1
d62 1
@


1.16
log
@v2 - minor rearrangements, fixes for EngineTray compilation
@
text
@d41 1
a41 1
		g_stEngine.PushToSocketsTP(m_pOnCompletionTask);
d50 1
a50 1
		g_stEngine.PushToSocketsTP(m_pOnCompletionTask);
d59 1
a59 1
		g_stEngine.PushToSocketsTP(m_pOnCompletionTask);
@


1.15
log
@Xml and database functionality
@
text
@a7 1
#include "../../OtherFunctions.h"
@


1.14
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@a5 1
#include "../EmEngine.h"
@


1.13
log
@XML connecting, tray app
@
text
@d6 1
a6 1

@


1.12
log
@There can be only one engine :-)
@
text
@d33 5
@


1.11
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a8 1
#include "../EmEngine.h"
d33 1
a33 1
void CEmClient::OnConnected(CEmEngine &rEngine)
d38 1
a38 1
		rEngine.PushToSocketsTP(m_pOnCompletionTask);
d42 1
a42 1
void CEmClient::OnAccepted(CEmEngine &rEngine)
d47 1
a47 1
		rEngine.PushToSocketsTP(m_pOnCompletionTask);
d51 1
a51 1
void CEmClient::OnDisconnected(CEmEngine &rEngine)
d56 1
a56 1
		rEngine.PushToSocketsTP(m_pOnCompletionTask);
d61 1
a61 1
//void CEmClient_Web::OnConnected(CEmEngine& stEngine)
@


1.10
log
@Modified my modifications for better genericness (I like genericity but it's not in the dictionary :P ).
@
text
@d16 1
a16 1
		AddDebugLogLine(false, "closesocket failed");
@


1.9
log
@Modified code so Task caller can specify completion behavior.
@
text
@d36 1
a36 1
	if (m_pOnConnectedTask != NULL)
d38 2
a39 1
		rEngine.PushToSocketsTP(m_pOnConnectedTask);
d45 1
a45 1
	if (m_pOnAcceptedTask != NULL)
d47 2
a48 1
		rEngine.PushToSocketsTP(m_pOnAcceptedTask);
d54 1
a54 1
	if (m_pOnDisconnectedTask != NULL)
d56 2
a57 1
		rEngine.PushToSocketsTP(m_pOnDisconnectedTask);
@


1.8
log
@Formatting, comments, and name changes.
@
text
@d12 1
d18 1
a18 1

d23 1
d28 1
d33 2
a34 2

void CEmClient::OnConnected(CEmEngine&)
d36 4
d41 2
a42 1
void CEmClient::OnAccepted(CEmEngine&)
d44 4
d49 2
a50 14
void CEmClient::OnDisconnected(CEmEngine&)
{
}

//////////////////////////////////////////////////////////////////////
// client connected
// (!) can be both we connected to him or he connected to us
// sending HELLO opcode.
//	MOREVIT: If I'm understanding this correctly, you're saying that
//		when another client connects to us to say HELLO, we're going
//		a HELLO back. What's the point in that? Once the HELLOANSWER
//		is received, both sides have all the information they need
//		about the other.
void CEmClient_Peer::OnConnected(CEmEngine& stEngine)
d52 1
a52 1
	if(!m_bFromOutside)
d54 1
a54 22
		COpCode_HELLO stMsg;
		md4cpy(stMsg._UserHash, stEngine.GetUserHash());
		stMsg._ClientAddr._IPAddr = stEngine.GetClientID();
		stMsg._ClientAddr._Port = stEngine.GetPort();
		stMsg._UserName.m_strValue = stEngine.GetUserNick();
		stMsg._UserName.m_bValid = TRUE;
		stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
		stMsg._ClientSoftVersion.m_bValid = TRUE;
		stMsg._UserPort.m_dwValue = stEngine.GetPort();
		stMsg._UserPort.m_bValid = TRUE;
		if(stEngine.IsConnected())
		{
			stMsg._ServerAddr._IPAddr = stEngine.GetConnectedState()->nAddr;
			stMsg._ServerAddr._Port = stEngine.GetConnectedState()->nPort;
		}
		else
		{
			stMsg._ServerAddr._IPAddr = 0;
			stMsg._ServerAddr._Port = 0;
		}

		stEngine.SendOpCode(m_hSocket, stMsg, this);
a57 49
// connected to server
// disconnecting from previous connected server (if any)
// sending LOGINREQUEST opcode
void CEmClient_Server::OnConnected(CEmEngine& stEngine)
{
//	Reset message count
	m_nMsgCount = 0;

//	Disconnect from previous connected server, if any
	if(stEngine.GetServerSocket() != m_hSocket &&
		stEngine.GetServerSocket())
		stEngine.DisconnectFromServer(stEngine.GetServerSocket());

//	Set connection info
	stEngine.ConnectedTo(this);
	stEngine.SetConnectionState(SERVER_WAITFORLOGIN);

	COpCode_LOGINREQUEST		stMsg;

	md4cpy(stMsg._UserHash, stEngine.GetUserHash());
	stMsg._ClientID = stEngine.GetClientID();
	stMsg._ClientPort = stEngine.GetPort();
	stMsg._UserName.m_strValue = stEngine.GetUserNick();
	stMsg._UserName.m_bValid = true;
	stMsg._ClientSoftVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientSoftVersion.m_bValid = true;
	stMsg._UserPort.m_dwValue = stEngine.GetPort();
	stMsg._UserPort.m_bValid = true;

	stEngine.SendOpCode(m_hSocket, stMsg, this);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// disconnected from server
// (!) at any reason, can be even if we tried to connect and failed
void CEmClient_Server::OnDisconnected(CEmEngine& stEngine)
{
	// Set connection info
	if(stEngine.GetServerSocket() == m_hSocket)
		stEngine.SetConnectionState(SERVER_DISCONNECTED);
	else
		// removed if, because we can get 'disconnected' even if we didn't
		// succeeded to connect yet, thus GetConnectingServer() won't return
		// correct value
		// if(stEngine.GetConnectingServer() == m_hSocket)
		stEngine.SetConnectionState(SERVER_DISCONNECTED);
		// TODO: mark somewhere that server is dead
}

//////////////////////////////////////////////////////////////////////
d59 6
a64 6
void CEmClient_Web::OnConnected(CEmEngine& stEngine)
{
	// say something...
	char szSend[] = "GET / HTTP 1.1\r\n\r\n";
	stEngine.m_stTcp.AllocSend(m_hSocket, szSend, sizeof(szSend) - 1);
}
@


1.7
log
@Formatting, comments, and name changes.
@
text
@d44 6
a49 1
// sending HELLO opcode
d78 1
a78 2

//////////////////////////////////////////////////////////////////////
d84 1
a84 1
	// Reset message count
d87 1
a87 1
	// Disconnect from previous connected server, if any
d92 1
a92 1
	// Set connection info
d96 2
a97 1
	COpCode_LOGINREQUEST stMsg;
d110 1
a110 2

//////////////////////////////////////////////////////////////////////
@


1.6
log
@Formatting, comments, and name changes, the usual.
@
text
@d93 1
a93 1
	md4cpy(stMsg._Hash, stEngine.GetUserHash());
d98 2
a99 2
	stMsg._ClientVersion.m_dwValue = EDONKEYVERSION;
	stMsg._ClientVersion.m_bValid = true;
@


1.5
log
@*** empty log message ***
@
text
@d50 3
a52 3
		md4cpy(stMsg._Hash, stEngine.GetUserHash());
		stMsg._Client._Addr = stEngine.GetClientID();
		stMsg._Client._Port = stEngine.GetPort();
d55 2
a56 2
		stMsg._ClientVersion.m_dwValue = EDONKEYVERSION;
		stMsg._ClientVersion.m_bValid = TRUE;
d61 2
a62 2
			stMsg._Server._Addr = stEngine.GetConnectedState()->nAddr;
			stMsg._Server._Port = stEngine.GetConnectedState()->nPort;
d66 2
a67 2
			stMsg._Server._Addr = 0;
			stMsg._Server._Port = 0;
@


1.4
log
@New engine - cosmetic changes
@
text
@d70 1
a70 1
		stEngine.SendOpCode(m_hSocket, stMsg);
d103 1
a103 1
	stEngine.SendOpCode(m_hSocket, stMsg);
@


1.3
log
@New engine - cosmetic changes
@
text
@a10 1
#include "../EngineData.h"
d50 4
a53 4
		md4cpy(stMsg._Hash, stEngine.m_stData.GetUserHash());
		stMsg._Client._Addr = stEngine.m_stData.GetClientID();
		stMsg._Client._Port = stEngine.m_stData.GetPort();
		stMsg._UserName.m_strValue = stEngine.m_stData.GetUserNick();
d57 1
a57 1
		stMsg._UserPort.m_dwValue = stEngine.m_stData.GetPort();
d59 1
a59 1
		if(stEngine.m_stData.IsConnected())
d61 2
a62 2
			stMsg._Server._Addr = stEngine.m_stData.GetConnectedState()->nAddr;
			stMsg._Server._Port = stEngine.m_stData.GetConnectedState()->nPort;
d70 1
a70 1
		stEngine.m_stTcp.AllocSend(m_hSocket, stMsg);
d84 3
a86 3
	if(stEngine.m_stData.GetServerSocket() != m_hSocket &&
		stEngine.m_stData.GetServerSocket())
		stEngine.DisconnectFromServer(stEngine.m_stData.GetServerSocket());
d89 2
a90 2
	stEngine.m_stData.ConnectedTo(this);
	stEngine.m_stData.SetConnectionState(SERVER_WAITFORLOGIN);
d93 4
a96 4
	md4cpy(stMsg._Hash, stEngine.m_stData.GetUserHash());
	stMsg._ClientID = stEngine.m_stData.GetClientID();
	stMsg._ClientPort = stEngine.m_stData.GetPort();
	stMsg._UserName.m_strValue = stEngine.m_stData.GetUserNick();
d100 1
a100 1
	stMsg._UserPort.m_dwValue = stEngine.m_stData.GetPort();
d103 1
a103 1
	stEngine.m_stTcp.AllocSend(m_hSocket, stMsg);
d112 2
a113 2
	if(stEngine.m_stData.GetServerSocket() == m_hSocket)
		stEngine.m_stData.SetConnectionState(SERVER_DISCONNECTED);
d118 2
a119 2
		// if(stEngine.m_stData.GetConnectingServer() == m_hSocket)
		stEngine.m_stData.SetConnectionState(SERVER_DISCONNECTED);
@


1.2
log
@New engine - connecting to server
@
text
@a6 2
#ifdef NEW_SOCKETS

a131 2

#endif@


1.1
log
@New engine
@
text
@d87 3
a89 3
	if(stEngine.m_stData.GetConnectingServer() != m_hSocket &&
		stEngine.m_stData.GetConnectingServer())
		stEngine.DisconnectFromServer(stEngine.m_stData.GetConnectingServer());
d92 2
a93 2
	stEngine.m_stData.ConnectingTo(this);
	stEngine.m_stData.SetConnectionState(false, SERVER_WAITFORLOGIN);
d115 2
a116 2
	if(stEngine.m_stData.GetConnectedServer() == m_hSocket)
		stEngine.m_stData.SetConnectionState(true, SERVER_DISCONNECTED);
d122 1
a122 1
		stEngine.m_stData.SetConnectionState(false, SERVER_DISCONNECTED);
@

