head	1.19;
access;
symbols
	PublicRelease_1_2e:1.19
	Interim_Release_1-2e_RC1:1.19
	PublicRelease_1_2d:1.19
	Interim_Release_1-2d_RC1:1.19
	Interim_Release_1-2d_beta1:1.19
	PublicRelease_1_2c:1.19
	Interim_Release_1-2c_RC1:1.19
	Interim_Release_1-2c_beta1:1.19
	PublicRelease_1_2b:1.19
	Interim_Release_1-2b_RC1:1.19
	PublicRelease_1_2a:1.19
	Interim_Release_1-2a_RC1:1.19
	Interim_Release_1-2a_beta2:1.19
	Interim_Release_1-2a_beta1:1.19
	PublicRelease_1_2:1.19
	Interim_Release_1-2_RC1:1.19
	Interim_Release_1-2_beta1:1.19
	PublicRelease_1_1g:1.19
	Interim_Release_1-1g_RC3:1.19
	Interim_Release_1-1g_RC2:1.19
	Interim_Release_1-1g_RC1:1.19
	Interim_Release_1-1g_beta2:1.19
	Interim_Release_1-1g_beta1:1.19
	PublicRelease_1_1f:1.19
	Interim_Release_1-1f_RC1:1.19
	PublicRelease_1_1e:1.19
	Interim_Release_1-1e_RC2:1.19
	Interim_Release_1-1e_RC1:1.19
	Interim_Release_1-1e_beta1:1.19
	PublicRelease_1_1d:1.18
	Interim_Release_1-1d_RC1:1.18
	PublicRelease_1_1c:1.17
	Interim_Release_1-1c_RC1:1.15
	Interim_Release_1-1c_beta2:1.9
	Interim_Release_1-1c_beta1:1.9
	PublicRelease_1_1b:1.8
	Interim_Release_1-1b_RC1:1.8
	PublicRelease_1_1a:1.8
	Interim_Release_1-1a_RC2:1.8
	Interim_Release_1-1a_RC1:1.8
	Interim_Release_1-1a_beta2:1.8
	Interim_Release_1-1a_beta1:1.8
	PublicRelease_1_1:1.8
	Interim_Release_1-1_beta1:1.8
	PublicRelease_1o:1.8
	Interim_Release_1o_RC1:1.8
	Interim_Release_1o_beta1:1.8
	PublicRelease_1n:1.8
	Interim_Release_1n_RC2:1.8
	Interim_Release_1n_RC1:1.8
	PublicRelease_1m:1.7
	Interim_Release_1m_beta1:1.7
	PublicRelease_1l:1.7
	Interim_Release_1l_RC3:1.7
	Interim_Release_1l_RC2:1.7
	Interim_Release_1l_RC1:1.7
	Interim_Release_1l_beta2:1.7
	Interim_Release_1l_beta1:1.7
	PublicRelease_1k:1.7
	Interim_Release_1k_RC4:1.7
	Interim_1k_RC3:1.7
	Interim_1k_RC2:1.7
	Interim_Release_1k_RC1:1.7
	Interim_Release_1k_beta5:1.7
	Intrerim_Release_1k_beta4:1.7
	Interim_Release_1k_beta1:1.7
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.1;
locks; strict;
comment	@ * @;


1.19
date	2005.04.17.05.16.25;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.08.17.09.08;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2005.02.26.17.52.05;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.26.09.48.22;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.23.22.13.02;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.23.20.40.42;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2005.02.23.19.34.41;	author kuchin;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.23.18.58.05;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.20.19.44.49;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.19.20.40.57;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.14.14.19.30;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.06.20.50.07;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.06.13.57.27;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.06.13.55.47;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2004.02.05.19.31.56;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2004.01.16.14.51.00;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2004.01.07.09.18.16;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.19
log
@v2 - corrected protocol, tags
@
text
@// OpCode.h: interface for the COpCode class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OPCODE_H__E3263944_435F_44B4_A12E_EAA19AAE08AD__INCLUDED_)
#define AFX_OPCODE_H__E3263944_435F_44B4_A12E_EAA19AAE08AD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "../TaskProcessor.h"
#include "TasksSockets.h"
#include "../../OpCodes.h"

#include "../../zlib/zlib.h"

#pragma pack(1)

#define OPCODE_SKIP_DBGDUMP

struct CEmClient;

const BYTE OP_PROT_EDONKEY		= OP_EDONKEYPROT;
const BYTE OP_PROT_EMULE		= OP_EMULEPROT;
const BYTE OP_PROT_PACKED		= OP_PACKEDPROT;
const int  OP_PROT_EDONKEY_EMULE= -1;
const int  OP_PROT_UNICODE		= -2;

const BYTE OP_TRANSPORT_TCP = 0x00;
const BYTE OP_TRANSPORT_UDP = 0x01;

struct CTag_Pure { // not a valid class.
	bool m_bValid;
	CTag_Pure() : m_bValid(false) {}
	__declspec(property(get=_IsValid)) bool Valid;
	bool _IsValid() const { return m_bValid; }
};

struct CTag_DWORD : public CTag_Pure {
	DWORD m_dwValue;
	CTag_DWORD() : m_dwValue(0) {}
	CTag_DWORD& operator = (const DWORD dwValue)
	{ 
		m_dwValue = dwValue; 
		m_bValid = true; 
		return *this; 
	}
	operator DWORD() const { return m_dwValue; }
};

struct CTag_String : public CTag_Pure {
	CString m_strValue;
	CTag_String& operator = (LPCTSTR strValue)
	{ 
		m_strValue = strValue; 
		m_bValid = true; 
		return *this;
	}
	operator CString() const { return m_strValue; }
};

struct CTagEntry {
	CTag_Pure*	m_pTag;
	DWORD		m_dwName; // either string or number
	USHORT		m_nNameLen;
	BYTE		m_nType;
};

struct CStream {

	bool m_bUnicode; // reserved for use with our new protocol.
	CStream() : m_bUnicode(false) {}

	class CException {};

	virtual void Write(PCVOID, DWORD);
	virtual DWORD ReadData(PVOID, DWORD);
	virtual DWORD GetSize() = 0;

	void Read(PVOID pBuf, DWORD dwSize)
	{
		while (dwSize)
		{
			DWORD dwProgress = ReadData(pBuf, dwSize);
			if (!dwProgress)
				Exception();

			if (!(dwSize -= dwProgress))
				break;

			((PBYTE&) pBuf) += dwProgress;
		}
	}

	void Skip(DWORD);

	virtual ~CStream();

	static void Exception();

	template <class T> void operator << (const T& stObj) { Write(&stObj, sizeof(stObj)); }
	template <class T> void operator >> (T& stObj) { Read(&stObj, sizeof(stObj)); }
	
	template <> void operator << (const CString& strTxt);
	template <> void operator >> (CString& strTxt);

	void DumpString(const CString&);
	void InitString(CString&, USHORT nLen);
	//void InitTrailingString(CString& strTxt);

	template <class T> void DumpArr(const vector<T>& arrValue, int nCounterLen, bool bSupportNewTags);
	template <class T> void InitArr(vector<T>& arrValue, int nCounterLen);

	void DumpBitArray(const vector<BYTE>& arrValue);

	void DumpTags(bool bNewTagsFormat, CTagEntry* pTags, DWORD dwCount);
	void InitTags(CTagEntry* pTags, DWORD dwCount);

private:

	struct CQuickBuf {
		BYTE m_pBuf[0x1000]; // usually enough
		PVOID m_pBufUse;
		
		CQuickBuf() : m_pBufUse(m_pBuf) {}
		~CQuickBuf() { Free(); }

		void Alloc(DWORD dwSize)
		{
			Free();
			if ((dwSize > sizeof(m_pBuf)) &&
				!(m_pBufUse = new BYTE[dwSize]))
				CStream::Exception();

		}
		void Free()
		{
			if (m_pBufUse && (m_pBuf != m_pBufUse))
				delete[] m_pBufUse;
			m_pBufUse = m_pBuf;
		}
	};
};

// does not really store info. Just counts
struct CStream_Measure : public CStream {
	DWORD m_dwSize;
	virtual void Write(PCVOID, DWORD);
	virtual DWORD GetSize(){ return m_dwSize; }

	inline CStream_Measure() : m_dwSize(0) {}
};

struct CStream_Mem : public CStream {
	PBYTE m_pPtr;
	DWORD m_dwSize;
	virtual void Write(PCVOID, DWORD);
	virtual DWORD ReadData(PVOID, DWORD);
	virtual DWORD GetSize(){ return m_dwSize; }

	inline CStream_Mem() : m_pPtr(NULL), m_dwSize(0) {}
};

struct CStream_ZLib : public CStream {
	virtual void Write(PCVOID, DWORD);
	virtual DWORD ReadData(PVOID, DWORD);
	virtual DWORD GetSize(){ return 0; }

	PBYTE		m_pBuf;
	CStream&	m_stSrc;
	CStream_Mem	m_stUnpacked;

	inline CStream_ZLib(CStream& stSrc) 
		:m_stSrc(stSrc)
		,m_pBuf(NULL)
	{ }
	~CStream_ZLib();
};

struct CStream_MemEx : public CStream {
	PBYTE m_pPtr;
	DWORD m_dwSize;
	DWORD m_dwSizeExtra;
	virtual void Write(PCVOID, DWORD);
	virtual DWORD GetSize(){ return m_dwSize; }

	inline CStream_MemEx() : m_pPtr(NULL), m_dwSize(0), m_dwSizeExtra(0) {}
};


class COpCode : public CTask_Tcp
{
protected:

	virtual void Z_Dump(CStream&, bool bSupportNewTags) const = 0;
	virtual void Z_Init(CStream&) = 0;

#ifndef OPCODE_SKIP_DBGDUMP
	struct CDbgDump {
		CString m_strTxt;
		void WriteParam(LPCTSTR szName, DWORD dwValue);
		void WriteParam(LPCTSTR szName, const CString&);
		void WriteParam(LPCTSTR szName, const AddrPort&);
		void WriteParam(LPCTSTR szName, const void* pBuf, DWORD dwCount, DWORD dwElementSize);
		void WriteParam(LPCTSTR szName, const CTag_DWORD&);
		void WriteParam(LPCTSTR szName, const CTag_String&);
		template <class T> void WriteParam(LPCTSTR szName, const vector<T>&);
	};
	virtual void Z_DbgDump(CDbgDump&) const = 0;
#endif // OPCODE_SKIP_DBGDUMP

	// CTask overridables
	virtual bool Process();
	virtual bool ProcessForClient(CEmClient_Peer* pClient) = 0;

public:

	bool m_bJustReceived;
	bool m_bSupportNewTags;
	COpCode() 
		:m_bJustReceived(true) 
		,m_bSupportNewTags(false)
		{}
	virtual ~COpCode();

	bool Write(CStream&, BYTE nTransport, bool bSupportNewTags) const;
	static COpCode* CreateRaw(BYTE nID, BYTE nProtocol, T_CLIENT_TYPE, LPTSTR strOpCode);
	static COpCode* Read(CStream&, BYTE nID, BYTE nProtocol, T_CLIENT_TYPE eType, LPTSTR strOpCode);

	virtual BYTE GetID() const = 0;
	virtual BYTE GetProtocol() const = 0;
	DWORD GetSize(BYTE nTransport, bool bSupportNewTags) const;

#ifndef OPCODE_SKIP_DBGDUMP

	int ShowSelf(bool bMessageBox = true, int nStyle = MB_ICONINFORMATION | MB_OK | MB_TOPMOST);

#endif // OPCODE_SKIP_DBGDUMP

};

/*template<class T>
class CField
{
public:
	T		m_data;

			CField<T>() {}
			CField<T>(T &data)
				: m_data(data) {}
	operator T()<T> { return(m_data); }
	operator const T()<T> const { return(m_data); }

};*/

// declare opcodes
#define PARAM_DWORD(name)	PARAM_SIMPLE_ORD(name, DWORD)
#define PARAM_USHORT(name)	PARAM_SIMPLE_ORD(name, USHORT)
#define PARAM_BYTE(name)	PARAM_SIMPLE_ORD(name, BYTE)

#define PARAM_ADDRPORT(name)	PARAM_SIMPLE(name, AddrPort)
#define PARAM_STRING(name)		PARAM_SIMPLE(name, CString)
#define PARAM_HASH(name)		PARAM_SIMPLE(name, HashType)	//PARAM_BUF(name, BYTE, 16)

#define PARAM_INTERNAL_DEFINITION
#define PARAM_SIMPLE_ORD PARAM_SIMPLE

#ifndef OPCODE_SKIP_DBGDUMP

#define BEGIN_OPCODE(id, name, prot, source) \
	const BYTE OP_CODE_##name = id; \
	class COpCode_##name : public COpCode { \
		virtual void Z_Dump(CStream&, bool bSupportNewTags) const;\
		virtual void Z_Init(CStream&);\
		virtual void Z_DbgDump(CDbgDump&) const;\
		virtual bool ProcessForClient(CEmClient_Peer* pClient);\
	public:\
		virtual BYTE GetID() const;\
		virtual BYTE GetProtocol() const;\
		COpCode_##name();\
		virtual ~COpCode_##name();\
		virtual LPCTSTR TaskName(){ return _T(#name); }\

#else // OPCODE_SKIP_DBGDUMP

#define BEGIN_OPCODE(id, name, prot, source) \
	const BYTE OP_CODE_##name = id; \
	class COpCode_##name : public COpCode { \
		virtual void Z_Dump(CStream&, bool bSupportNewTags) const;\
		virtual void Z_Init(CStream&);\
		virtual bool ProcessForClient(CEmClient_Peer* pClient);\
	public:\
		virtual BYTE GetID() const;\
		virtual BYTE GetProtocol() const;\
		COpCode_##name();\
		virtual ~COpCode_##name();\
		virtual LPCTSTR TaskName(){ return _T(#name); }\

#endif // OPCODE_SKIP_DBGDUMP

#define END_OPCODE };

#define PARAM_BYTE_JUNK(value)
#define PARAM_BUF(name, type, count) type _##name[count];
#define PARAM_DATABLOCK(name) BYTE* _##name; DWORD _Start##name; DWORD _End##name;
#define PARAM_SIMPLE(name, type) type _##name;
#define PARAM_TAGS_BEGIN
#define PARAM_TAGS_END
#define PARAM_TAG_STR(name, id) CTag_String _##name;
#define PARAM_TAG_DWORD(name, id) CTag_DWORD _##name;
//#define PARAM_TEXT_TRAILING(name) CString _##name;
#define PARAM_ARRAY(name, type, counter) vector<type> _##name;
#define PARAM_BITARRAY(name) vector<BYTE> _##name;

#ifndef OPCODE_SKIP_DBGDUMP
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) struct CStruct_##name { CStruct_##name(); void Z_Dump(CStream&, bool) const; void Z_Init(CStream&); void Z_DbgDump(CDbgDump&) const;
#else
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) struct CStruct_##name { CStruct_##name(); void Z_Dump(CStream&, bool) const; void Z_Init(CStream&);
#endif // OPCODE_SKIP_DBGDUMP

#define PARAM_COMPLEXARRAY_END(name) }; vector<CStruct_##name> _##name;

#include "EmMsgs.h"
#include "EmUndef.h"

#pragma pack()

#endif // !defined(AFX_OPCODE_H__E3263944_435F_44B4_A12E_EAA19AAE08AD__INCLUDED_)
@


1.18
log
@v2 - minor rearrangements, started defining client and clientlist
@
text
@d112 1
a112 1
	template <class T> void DumpArr(const vector<T>& arrValue, int nCounterLen);
d117 1
a117 1
	void DumpTags(CTagEntry* pTags, DWORD dwCount);
d196 1
a196 1
	virtual void Z_Dump(CStream&) const = 0;
d219 6
a224 2
	BOOL m_bJustReceived;
	COpCode() : m_bJustReceived(TRUE) {}
d227 1
a227 1
	bool Write(CStream&, BYTE nTransport) const;
d233 1
a233 1
	DWORD GetSize(BYTE nTransport) const;
d274 1
a274 1
		virtual void Z_Dump(CStream&) const;\
d290 1
a290 1
		virtual void Z_Dump(CStream&) const;\
d317 1
a317 1
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) struct CStruct_##name { CStruct_##name(); void Z_Dump(CStream&) const; void Z_Init(CStream&); void Z_DbgDump(CDbgDump&) const;
d319 1
a319 1
#define PARAM_COMPLEXARRAY_BEGIN(msg, name) struct CStruct_##name { CStruct_##name(); void Z_Dump(CStream&) const; void Z_Init(CStream&);
@


1.17
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d36 2
d49 1
d60 1
a190 10
struct ADDRPORT
{
	ULONG	_IPAddr;
	USHORT	_Port;
};

struct HASH
{
	BYTE	_Hash[16];
};
d204 1
a204 1
		void WriteParam(LPCTSTR szName, const ADDRPORT&);
d258 1
a258 1
#define PARAM_ADDRPORT(name)	PARAM_SIMPLE(name, ADDRPORT)
d260 1
a260 1
#define PARAM_HASH(name)		PARAM_BUF(name, BYTE, 16)
@


1.16
log
@v2 - opcodes handling improvement, webserver enhancement
@
text
@d24 5
a28 5
const BYTE OP_PROT_EDONKEY	= 0xE3;
const BYTE OP_PROT_EMULE	= 0xC5;
const BYTE OP_PROT_PACKED	= 0xD4;
const BYTE OP_PROT_UNICODE	= 0xAA; // must be agreed
const int  OP_PROT_EDONKEY_EMULE = -1;
d111 2
d193 5
d221 1
a221 1
	virtual bool ProcessForClient(CEmClient* pClient) = 0;
d279 1
a279 1
		virtual bool ProcessForClient(CEmClient* pClient);\
d294 1
a294 1
		virtual bool ProcessForClient(CEmClient* pClient);\
d308 1
d316 1
@


1.15
log
@v2 - minor improvements
@
text
@d41 6
d51 6
d61 1
a62 1
	DWORD		m_dwName; // either string or number
d318 1
a318 17

#undef BEGIN_OPCODE
#undef END_OPCODE

#undef PARAM_BYTE_JUNK
#undef PARAM_BUF
#undef PARAM_SIMPLE
#undef PARAM_TAGS_BEGIN
#undef PARAM_TAGS_END
#undef PARAM_TAG_STR
#undef PARAM_TAG_DWORD
#undef PARAM_NTAG_DWORD
//#undef PARAM_TEXT_TRAILING
#undef PARAM_ARRAY
#undef PARAM_INTERNAL_DEFINITION
#undef PARAM_COMPLEXARRAY_BEGIN
#undef PARAM_COMPLEXARRAY_END
@


1.14
log
@v2 - packed protocol fixed
@
text
@a48 1
	BYTE		m_nType;
d51 1
@


1.13
log
@v2 - updated protocol, need to fix packed protocol
@
text
@d63 1
d122 1
a122 1
				delete m_pBufUse;
d132 1
d142 1
d150 1
d152 8
a159 8
	z_stream m_stStream;
	BYTE m_pBuf[0x1000];
	CStream& m_stSrc;

	inline CStream_ZLib(CStream& stSrc) : m_stSrc(stSrc)
	{
		ZeroMemory(&m_stStream, sizeof(m_stStream));
	}
d168 1
@


1.12
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d28 1
d206 2
a207 2
	static COpCode* CreateRaw(BYTE nID, BYTE nProtocol, T_CLIENT_TYPE);
	static COpCode* Read(CStream&, BYTE nID, BYTE nProtocol, T_CLIENT_TYPE eType);
@


1.11
log
@v2 - more shared files, other minor changes
@
text
@d248 1
a248 1
#	define BEGIN_OPCODE(id, name, prot, source) \
d260 1
d264 1
a264 1
#	define BEGIN_OPCODE(id, name, prot, source) \
d266 10
a275 9
class COpCode_##name : public COpCode { \
	virtual void Z_Dump(CStream&) const;\
	virtual void Z_Init(CStream&);\
	virtual bool ProcessForClient(CEmClient* pClient);\
public:\
	virtual BYTE GetID() const;\
	virtual BYTE GetProtocol() const;\
	COpCode_##name();\
	virtual ~COpCode_##name();\
@


1.10
log
@v2 - connecting to server, updated protocol, bugfixes
@
text
@d20 2
@


1.9
log
@There can be only one engine :-)
@
text
@d18 2
a29 3
const BYTE OP_TAG_DWORD = 3;
const BYTE OP_TAG_STRING = 2;

d314 1
@


1.8
log
@v2 - compressed opcodes
@
text
@d194 2
a195 2
	virtual bool Process(CEmEngine&);
	virtual bool ProcessForClient(CEmEngine&, CEmClient* pClient) = 0;
d253 1
a253 1
		virtual bool ProcessForClient(CEmEngine&, CEmClient* pClient);\
d267 1
a267 1
	virtual bool ProcessForClient(CEmEngine&, CEmClient* pClient);\
@


1.7
log
@New engine - logging
@
text
@d16 2
d60 17
a76 2
	virtual void Read(PVOID, DWORD);
	virtual DWORD SizeLeft();
d79 2
d91 1
a91 1
	void InitTrailingString(CString& strTxt);
d137 1
a137 1
	virtual void Read(PVOID, DWORD);
d142 15
d285 1
a285 1
#define PARAM_TEXT_TRAILING(name) CString _##name;
d309 1
a309 1
#undef PARAM_TEXT_TRAILING
@


1.6
log
@Formatting, comments, and name changes.
@
text
@a143 1
	virtual BYTE Z_Protocol() const = 0;
d174 1
a217 1
		virtual BYTE Z_Protocol() const;\
d222 1
a232 1
	virtual BYTE Z_Protocol() const;\
d236 1
a248 2
//	"O" as in optional as in eMulePlus doesn't send. We should handle on receive. How?
#define PARAM_OTAG_STR(name, id)
a249 1
#define PARAM_OTAG_DWORD(name, id)
a250 1
#define PARAM_NTAG_DWORD(name, id) CTag_DWORD _##name;
@


1.5
log
@Formatting, comments, and name changes.
@
text
@d185 14
@


1.4
log
@Formatting, comments, and name changes, the usual.
@
text
@d235 2
d238 1
@


1.3
log
@*** empty log message ***
@
text
@d132 3
a134 2
struct ADDRPORT {
	ULONG	_Addr;
@


1.2
log
@New engine - cosmetic changes
@
text
@d165 2
a183 1

@


1.1
log
@New engine
@
text
@d4 1
a4 1
#ifdef NEW_SOCKETS
a267 1
#endif@

