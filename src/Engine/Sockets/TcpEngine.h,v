head	1.12;
access;
symbols
	PublicRelease_1_2e:1.12
	Interim_Release_1-2e_RC1:1.12
	PublicRelease_1_2d:1.12
	Interim_Release_1-2d_RC1:1.12
	Interim_Release_1-2d_beta1:1.12
	PublicRelease_1_2c:1.12
	Interim_Release_1-2c_RC1:1.12
	Interim_Release_1-2c_beta1:1.12
	PublicRelease_1_2b:1.12
	Interim_Release_1-2b_RC1:1.12
	PublicRelease_1_2a:1.12
	Interim_Release_1-2a_RC1:1.12
	Interim_Release_1-2a_beta2:1.12
	Interim_Release_1-2a_beta1:1.12
	PublicRelease_1_2:1.12
	Interim_Release_1-2_RC1:1.12
	Interim_Release_1-2_beta1:1.12
	PublicRelease_1_1g:1.12
	Interim_Release_1-1g_RC3:1.12
	Interim_Release_1-1g_RC2:1.12
	Interim_Release_1-1g_RC1:1.12
	Interim_Release_1-1g_beta2:1.12
	Interim_Release_1-1g_beta1:1.12
	PublicRelease_1_1f:1.12
	Interim_Release_1-1f_RC1:1.12
	PublicRelease_1_1e:1.12
	Interim_Release_1-1e_RC2:1.12
	Interim_Release_1-1e_RC1:1.12
	Interim_Release_1-1e_beta1:1.12
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1;
locks; strict;
comment	@ * @;


1.12
date	2005.04.17.05.16.25;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.07.17.24.51;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.06.18.31.27;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.05.05.49.06;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.29.14.36.14;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.28.19.40.23;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.27.05.01.52;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.22.22.02.10;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.04.13.21.28;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.29.16.04.23;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.06.13.57.03;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.16.17.44.22;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@v2 - corrected protocol, tags
@
text
@// TcpEngine.h: interface for the CTcpEngine class.
//
//////////////////////////////////////////////////////////////////////

#ifdef NEW_SOCKETS
#if !defined(AFX_TCPENGINE_H__F572FB64_4C8F_4112_A2B3_CE1A75ACCF86__INCLUDED_)
#define AFX_TCPENGINE_H__F572FB64_4C8F_4112_A2B3_CE1A75ACCF86__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <deque>

// Constants
const UINT INTERFACE_FLAG_SHUTDOWN	= 0x01;

const UINT WM_EMSOCKET			= WM_USER + 1;
const UINT WM_EM_ADDINTERFACE	= WM_USER + 2;
const UINT WM_EM_CONNECT		= WM_USER + 3;
const UINT WM_EM_SEND			= WM_USER + 4;
const UINT WM_EM_DISCONNECT		= WM_USER + 5;

const UINT TCP_OPTIMAL_BUF		= 0x1000; // 4k
const UINT TCP_MAX_BUF_SIZE		= 200000;

const UINT TCP_RECV_FLAG_CONNECTED = 0x01;
const UINT TCP_RECV_FLAG_FIRSTTIME = 0x02;

const UINT UPLOAD_BLOCK_SIZE		= 512;

// Time in milliseconds
const UINT TIMER_CHECK_TIME			= 100;	// for limiting bandwidth on timer

const ULONG LISTEN_TO_INTERNET	= INADDR_ANY;
const ULONG LISTEN_TO_LOOPBACK	= htonl(INADDR_LOOPBACK);

class CTcpEngine : public CLoggable2 // : protected CThreadPool
{
protected:
	bool m_bWinsockInit;

	struct CInterface {
		USHORT	m_uPort;
		SOCKET	m_hSocket;
		long	m_nPendingAccepts;
		UINT	m_nFlags;
		T_CLIENT_TYPE	m_eType;
	};
	struct CState;

	std::queue<CInterface*> m_queueInterfaces;

	struct OVERLAPPED_TCP : public OVERLAPPED
	{
		union
		{
			struct
			{
				OVERLAPPED_TCP* m_pPrev;
				OVERLAPPED_TCP* m_pNext;
			};
			CTcpEngine* m_pEngine;
		};

		SOCKET m_hSocket;

		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		virtual void ProcessEvent(CState&, int nEvent, int nError);

		OVERLAPPED_TCP() :
			m_pPrev(NULL),
			m_pNext(NULL)
			{ ZeroMemory((OVERLAPPED*) this, sizeof(OVERLAPPED)); }
		virtual ~OVERLAPPED_TCP();

		static void WINAPI OverlappedCompletionFunc(DWORD, DWORD, OVERLAPPED*, DWORD);
	};
	struct OVERLAPPED_ACCEPT : public OVERLAPPED_TCP 
	{
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		virtual void ProcessEvent(CState&, int nEvent, int nError);
		CInterface& m_stInterface;
		char m_pBuf[(sizeof(SOCKADDR_IN) + 16) * 2]; // used with AcceptEx function

		OVERLAPPED_ACCEPT(CInterface& stInterface) : m_stInterface(stInterface) { InterlockedIncrement(&m_stInterface.m_nPendingAccepts); }
		virtual ~OVERLAPPED_ACCEPT();
	};
	struct OVERLAPPED_RECV : public OVERLAPPED_TCP, public WSABUF
	{
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		virtual void ProcessEvent(CState&, int nEvent, int nError);
		char	m_pBuf[TCP_OPTIMAL_BUF];
		DWORD	m_dwBufUsage;
		DWORD	m_dwBufSize;
		UINT	m_nFlags;

		ULONG	m_nPeerAddr;
		USHORT	m_nPeerPort;

		char*	m_pBufExtra;
		inline char* GetBuffer() { return m_pBufExtra ? m_pBufExtra : m_pBuf; }

		void DisableTcpBufs(CTcpEngine&);
		void ClearBufs();

		inline OVERLAPPED_RECV() :
			m_pBufExtra(NULL),
			m_dwBufUsage(0),
			m_dwBufSize(sizeof(m_pBuf))
			{}
		virtual ~OVERLAPPED_RECV();

		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv) = NULL;
	};
	struct OVERLAPPED_RECV_WEB : public OVERLAPPED_RECV {
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);

		DWORD m_dwHttpHeaderLen;
		DWORD m_dwHttpContentLen;

		inline OVERLAPPED_RECV_WEB() :
			m_dwHttpHeaderLen(0),
			m_dwHttpContentLen(0)
			{}
	};
	struct OVERLAPPED_RECV_XML : public OVERLAPPED_RECV {
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);

		DWORD m_dwLength;

		inline OVERLAPPED_RECV_XML() :
			m_dwLength(0)
			{}
	};

	struct OVERLAPPED_SEND : public OVERLAPPED_TCP, public WSABUF {
		virtual void ProcessCompletion(CTcpEngine&, int nError, DWORD dwBytes);
		BYTE m_pBuf[0];
		void* operator new (size_t nSize, DWORD dwDataSize) { return malloc(nSize + dwDataSize); }
		void operator delete(void* pPtr, DWORD) { free(pPtr); }
		void operator delete(void* pPtr) { free(pPtr); }
	};

	//////////////////////////////////////////////////////////////////////
	// Asynchronous engine
	bool InitAsync();
	void UninitAsync();

	HANDLE	m_hAsyncInit; // initialization completion event
	HANDLE	m_hAsyncThread;
	HWND	m_hSocketWnd;
	long	m_nOverlappedIOs;

	static UINT WINAPI SocketWndFunc(PVOID);
	static LRESULT WINAPI SocketWndProc(HWND, UINT, WPARAM, LPARAM);

	virtual void OnSend(CState* pState, OVERLAPPED_SEND* pSend, EnumQueuePriority ePriority);
	virtual void OnTimer(CState* pState);

	struct CState 
	{


		CTcpEngine& m_stEngine;
		OVERLAPPED_TCP* m_pHashTable[997];

		CState(CTcpEngine& stEngine) : m_stEngine(stEngine)
		{
			ZeroMemory(m_pHashTable, sizeof(m_pHashTable));
		}

		void AddClient(OVERLAPPED_TCP&);
		OVERLAPPED_TCP* LookupClient(SOCKET hSocket);
		void DeleteClient(OVERLAPPED_TCP&);

		void OnAddInterface(CInterface&);

		bool SendBlock(OVERLAPPED_SEND* pSend);
	};

	virtual OVERLAPPED_RECV* AllocRecv(T_CLIENT_TYPE eType);

	friend struct CState;
	friend struct OVERLAPPED_TCP;
	friend struct OVERLAPPED_RECV;
	friend struct OVERLAPPED_ACCEPT;

	//////////////////////////////////////////////////////////////////////
	// Overlapped engine

public:

	bool Init();
	void Uninit(bool bCleanupWinsock = true);

	CTcpEngine() 
		:m_bWinsockInit(false)
		,m_hAsyncInit(NULL)
		,m_hAsyncThread(NULL)
		,m_hSocketWnd(NULL)
		,m_nOverlappedIOs(0)
	{}
	~CTcpEngine() { Uninit(); }

	bool AddInterface(USHORT nPort, T_CLIENT_TYPE, ULONG uListen = LISTEN_TO_INTERNET);

	bool AllocSend(SOCKET hSocket, PCVOID, DWORD, EnumQueuePriority);

	void AllocDisconnect(SOCKET hSocket);
	SOCKET AllocConnect(ULONG nAddr, USHORT nPort, T_CLIENT_TYPE);
};

#endif // !defined(AFX_TCPENGINE_H__F572FB64_4C8F_4112_A2B3_CE1A75ACCF86__INCLUDED_)
#endif@


1.11
log
@v2 - fixes for upload logic
@
text
@d35 2
a36 1

d206 1
a206 1
	bool AddInterface(USHORT nPort, T_CLIENT_TYPE);
@


1.10
log
@v2 - upload works (basic implementation)
@
text
@d35 2
d157 1
a157 1
	virtual void OnSend(CState* pState, OVERLAPPED_SEND* pSend, bool bToEnd);
d207 1
a207 1
	bool AllocSend(SOCKET hSocket, PCVOID, DWORD, bool bToEnd = true);
@


1.9
log
@v2 - more upload logic, light configuration (without BerkeleyDb)
@
text
@d30 4
@


1.8
log
@v2 - increasing level of abstraction, more upload logic
@
text
@d15 1
a29 4
const UINT TIMER_CHECK_TIME			= 100;	// milliseconds

const UINT UPLOAD_BLOCK_SIZE		= 512;
const UINT UPLOAD_MAX_STATS_RESULTS = 20;
a146 1
	HANDLE	m_hLimitSendThread;
a156 6
		deque<OVERLAPPED_SEND*>	m_stUploadQueue;
		ULONG m_arrUploadStats[UPLOAD_MAX_STATS_RESULTS];
		DWORD m_arrUploadTicks[UPLOAD_MAX_STATS_RESULTS];

		int m_nUploadIndex;
		CPreciseTime m_tmLastCheck;
a163 15
			ZeroMemory(m_arrUploadStats, sizeof(m_arrUploadStats));
			ZeroMemory(m_arrUploadTicks, sizeof(m_arrUploadTicks));
			m_nUploadIndex = 0;
			m_tmLastCheck = CPreciseTime::GetCurrentTime();
		}

		~CState()
		{
			// Destroy all unsent packets
			while(!m_stUploadQueue.empty())
			{
				OVERLAPPED_SEND* pSend = m_stUploadQueue.front();
				delete pSend;
				m_stUploadQueue.pop_front();
			}
a195 1
		,m_hLimitSendThread(NULL)
@


1.7
log
@v2 - more upload logic, limiting total upload speed
@
text
@d4 1
d13 1
a13 3
#ifdef PROCESS_OPCODES
class COpCode;
#endif //PROCESS_OPCODES
d29 1
a29 1
const UINT UPLOAD_BLOCK_SIZE = 512;
d31 1
d36 1
a132 10
#ifdef PROCESS_OPCODES
	struct OVERLAPPED_RECV_OPCODES : public OVERLAPPED_RECV
	{
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);

		const T_CLIENT_TYPE m_eType;

		OVERLAPPED_RECV_OPCODES(T_CLIENT_TYPE eType) : m_eType(eType) {}
	};
#endif //PROCESS_OPCODES
d155 3
d161 1
a161 1
		queue<OVERLAPPED_SEND*>	m_stUploadQueue;
d166 1
a166 1
		DWORD m_dwLastTick;
d177 1
a177 1
			m_dwLastTick = GetTickCount();
d182 1
d187 1
a187 1
				m_stUploadQueue.pop();
d196 2
d200 1
a200 1
	OVERLAPPED_RECV* AllocRecv(T_CLIENT_TYPE eType);
d227 2
a228 4
	bool AllocSend(SOCKET hSocket, PCVOID, DWORD);
#ifdef PROCESS_OPCODES
	bool AllocSend(SOCKET hSocket, const COpCode&);
#endif //PROCESS_OPCODES
@


1.6
log
@v2 - minor improvements
@
text
@d30 4
a161 1
	static UINT WINAPI LimitSendFunc(PVOID);
d167 7
d180 14
@


1.5
log
@v2 - enhancing logging subsystem
@
text
@d51 2
a52 2
				OVERLAPPED_TCP		*m_pPrev;
				OVERLAPPED_TCP		*m_pNext;
d54 1
a54 1
			CTcpEngine		*m_pEngine;
d57 1
a57 1
		SOCKET		m_hSocket;
d70 2
a71 1
	struct OVERLAPPED_ACCEPT : public OVERLAPPED_TCP {
d75 1
a75 1
		char		m_pBuf[(sizeof(SOCKADDR_IN) + 16) * 2]; // used with AcceptEx function
d84 1
a84 1
		char m_pBuf[TCP_OPTIMAL_BUF];
d92 1
a92 1
		char* m_pBufExtra;
d131 1
a131 1
		virtual DWORD			ParseRecv(CTcpEngine&, bool bIsLastRecv);
d133 1
a133 1
		const T_CLIENT_TYPE		m_eType;
d155 1
d158 1
d161 2
a162 1
	struct CState {
d194 7
a200 6
	CTcpEngine() :
		m_bWinsockInit(false),
		m_hAsyncInit(NULL),
		m_hAsyncThread(NULL),
		m_hSocketWnd(NULL),
		m_nOverlappedIOs(0)
@


1.4
log
@XML connecting, tray app
@
text
@a11 2
#include "../../Loggable.h"

d30 1
a30 1
class CTcpEngine : public CLoggable // : protected CThreadPool
@


1.3
log
@There can be only one engine :-)
@
text
@d119 9
@


1.2
log
@Formatting, comments, and name changes.
@
text
@d14 1
a14 1
class CEmEngine;
d16 1
d120 1
d129 1
a129 1

a179 2
	CEmEngine& m_stEngine;

d183 1
a183 2
	CTcpEngine(CEmEngine& stEngine) :
		m_stEngine(stEngine),
d195 1
d197 1
@


1.1
log
@New engine
@
text
@d46 8
a53 6
	struct OVERLAPPED_TCP : public OVERLAPPED {

		union {
			struct {
				OVERLAPPED_TCP* m_pPrev;
				OVERLAPPED_TCP* m_pNext;
d55 1
a55 1
			CTcpEngine* m_pEngine;
d59 1
d80 2
a81 1
	struct OVERLAPPED_RECV : public OVERLAPPED_TCP, public WSABUF {
d118 6
a123 3
	struct OVERLAPPED_RECV_OPCODES : public OVERLAPPED_RECV {
		virtual DWORD ParseRecv(CTcpEngine&, bool bIsLastRecv);
		const T_CLIENT_TYPE m_eType;
d126 1
a127 1
	};
@

