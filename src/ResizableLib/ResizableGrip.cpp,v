head	1.4;
access;
symbols
	PublicRelease_1_2e:1.4
	Interim_Release_1-2e_RC1:1.4
	PublicRelease_1_2d:1.4
	Interim_Release_1-2d_RC1:1.4
	Interim_Release_1-2d_beta1:1.4
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	PublicRelease_1m:1.4
	Interim_Release_1m_beta1:1.4
	PublicRelease_1l:1.4
	Interim_Release_1l_RC3:1.4
	Interim_Release_1l_RC2:1.4
	Interim_Release_1l_RC1:1.4
	Interim_Release_1l_beta2:1.4
	Interim_Release_1l_beta1:1.4
	PublicRelease_1k:1.4
	Interim_Release_1k_RC4:1.4
	Interim_1k_RC3:1.4
	Interim_1k_RC2:1.4
	Interim_Release_1k_RC1:1.4
	Interim_Release_1k_beta5:1.4
	Intrerim_Release_1k_beta4:1.4
	Interim_Release_1k_beta1:1.4
	PublicRelease_1j:1.4
	Interim_Release_1J_RC3:1.4
	Interim_Release_1j_RC3:1.4
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.4
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.4
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.4
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.3
	Interim_Release_1g_beta1:1.3
	Interim_Release_1f_RC4:1.3
	Interim_Release_1f_RC3:1.3
	Interim_Release_1f_RC2:1.3
	Interim_Release_1f_RC:1.3
	Interim_Release_1f_beta2:1.3
	Interim_Release_1f_beta1:1.3
	PublicRelease_1e:1.3
	Interim_Release_1e_RC2:1.3
	Interim_Release_1e_RC:1.3
	Interim_Release_1e_beta3:1.3
	Interim_Release_1e_beta2:1.3
	Interim_Release_1e_beta2_before_kuchin:1.3
	Interim_Release_1e_beta1:1.3
	PublicRelease_1c:1.3
	featurestest:1.3.0.4
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.2
	PublicRelease_1b:1.3
	Interim_Release_1b_beta2:1.3
	Interim_Release_1b_beta1:1.3
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.4
date	2003.10.03.08.12.26;	author eklmn;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.05.08.35.52;	author recdvst;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.22.05.01.38;	author recdvst;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.27.08;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.17.20.21;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.4
log
@fixed creattion of grip window from ResizableDialog
@
text
@// ResizableGrip.cpp: implementation of the CResizableGrip class.
//
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) 2000-2002 by Paolo Messina
// (http://www.geocities.com/ppescher - ppescher@@yahoo.com)
//
// The contents of this file are subject to the Artistic License (the "License").
// You may not use this file except in compliance with the License. 
// You may obtain a copy of the License at:
// http://www.opensource.org/licenses/artistic-license.html
//
// If you find this code useful, credits would be nice!
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ResizableGrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CResizableGrip::CResizableGrip()
{
	m_nShowCount = 0;
}

CResizableGrip::~CResizableGrip()
{

}

void CResizableGrip::UpdateSizeGrip()
{
	ASSERT(::IsWindow(m_wndGrip.m_hWnd));

	// size-grip goes bottom right in the client area
	// (any right-to-left adjustment should go here)

	RECT rect;
	GetResizableWnd()->GetClientRect(&rect);

	rect.left = rect.right - m_wndGrip.m_size.cx;
	rect.top = rect.bottom - m_wndGrip.m_size.cy;

	// must stay below other children
	m_wndGrip.SetWindowPos(&CWnd::wndBottom, rect.left, rect.top, 0, 0,
		SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOREPOSITION
		| (IsSizeGripVisible() ? SWP_SHOWWINDOW : SWP_HIDEWINDOW));
}

// pbStatus points to a variable, maintained by the caller, that
// holds its visibility status. Initialize the variable with 1
// to allow to temporarily hide the grip, 0 to allow to
// temporarily show the grip (with respect to the dwMask bit).

// NB: visibility is effective only after an update

void CResizableGrip::ShowSizeGrip(DWORD* pStatus, DWORD dwMask /*= 1*/)
{
	ASSERT(pStatus != NULL);

	if (!(*pStatus & dwMask))
	{
		m_nShowCount++;
		(*pStatus) |= dwMask;
	}
}

void CResizableGrip::HideSizeGrip(DWORD* pStatus, DWORD dwMask /*= 1*/)
{
	ASSERT(pStatus != NULL);

	if (*pStatus & dwMask)
	{
		m_nShowCount--;
		(*pStatus) &= ~dwMask;
	}
}

BOOL CResizableGrip::IsSizeGripVisible()
{
	// NB: visibility is effective only after an update
	return (m_nShowCount > 0);
}

void CResizableGrip::SetSizeGripVisibility(BOOL bVisible)
{
	if (bVisible)
		m_nShowCount = 1;
	else
		m_nShowCount = 0;
}

BOOL CResizableGrip::SetSizeGripBkMode(int nBkMode)
{
	if (::IsWindow(m_wndGrip.m_hWnd))
	{
		if (nBkMode == OPAQUE)
			m_wndGrip.SetTransparency(FALSE);
		else if (nBkMode == TRANSPARENT)
			m_wndGrip.SetTransparency(TRUE);
		else
			return FALSE;
		return TRUE;
	}
	return FALSE;
}

void CResizableGrip::SetSizeGripShape(BOOL bTriangular)
{
	m_wndGrip.SetTriangularShape(bTriangular);
}

BOOL CResizableGrip::CreateSizeGrip(LPCREATESTRUCT lpCreateStruct, BOOL bVisible /*= TRUE*/,
		BOOL bTriangular /*= TRUE*/, BOOL bTransparent /*= FALSE*/)
{
	// create grip
	m_wndGrip.m_size.cx = lpCreateStruct->cx;
	m_wndGrip.m_size.cy = lpCreateStruct->cy;
	
	CRect rect(0 , 0, m_wndGrip.m_size.cx, m_wndGrip.m_size.cy);
	BOOL bRet = m_wndGrip.Create(WS_CHILD | WS_CLIPSIBLINGS
		| SBS_SIZEGRIP, rect, GetResizableWnd(), 0);

	if (bRet)
	{
		// set options
		m_wndGrip.SetTriangularShape(bTriangular);
		m_wndGrip.SetTransparency(bTransparent);
		SetSizeGripVisibility(bVisible);
	
		// update position
		UpdateSizeGrip();
	}

	return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// CSizeGrip implementation

BOOL CResizableGrip::CSizeGrip::IsRTL()
{
	return GetExStyle() & 0x00400000L/*WS_EX_LAYOUTRTL*/;
}

BOOL CResizableGrip::CSizeGrip::PreCreateWindow(CREATESTRUCT& cs) 
{
	// set window size
	m_size.cx = GetSystemMetrics(SM_CXVSCROLL);
	m_size.cy = GetSystemMetrics(SM_CYHSCROLL);

	cs.cx = m_size.cx;
	cs.cy = m_size.cy;
	
	return CScrollBar::PreCreateWindow(cs);
}

LRESULT CResizableGrip::CSizeGrip::WindowProc(UINT message,
											  WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_GETDLGCODE:
		// fix to prevent the control to gain focus, using arrow keys
		// (standard grip returns DLGC_WANTARROWS, like any standard scrollbar)
		return DLGC_STATIC;

	case WM_SETFOCUS:
		// fix to prevent the control to gain focus, if set directly
		// (for example when it's the only one control in a dialog)
		return 0;

	case WM_NCHITTEST:
		// choose proper cursor shape
		if (IsRTL())
			return HTBOTTOMLEFT;
		else
			return HTBOTTOMRIGHT;
		break;

	case WM_SETTINGCHANGE:
		{
			// update grip's size
			CSize sizeOld = m_size;
			m_size.cx = GetSystemMetrics(SM_CXVSCROLL);
			m_size.cy = GetSystemMetrics(SM_CYHSCROLL);

			// resize transparency bitmaps
			if (m_bTransparent)
			{
				CClientDC dc(this);

				// destroy bitmaps
				m_bmGrip.DeleteObject();
				m_bmMask.DeleteObject();

				// re-create bitmaps
				m_bmGrip.CreateCompatibleBitmap(&dc, m_size.cx, m_size.cy);
				m_bmMask.CreateBitmap(m_size.cx, m_size.cy, 1, 1, NULL);
			}

			// re-calc shape
			if (m_bTriangular)
				SetTriangularShape(m_bTriangular);

			// reposition the grip
			CRect rect;
			GetWindowRect(rect);
			rect.InflateRect(m_size.cx - sizeOld.cx, m_size.cy - sizeOld.cy, 0, 0);
			::MapWindowPoints(NULL, GetParent()->GetSafeHwnd(), (LPPOINT)&rect, 2);
			MoveWindow(rect, TRUE);
		}
		break;

	case WM_DESTROY:
		// perform clean up
		if (m_bTransparent)
			SetTransparency(FALSE);
		break;

	case WM_PAINT:
	case WM_PRINTCLIENT:
		if (m_bTransparent)
		{
			PAINTSTRUCT ps;
			CDC* pDC = (message == WM_PAINT && wParam == 0) ?
				BeginPaint(&ps) : CDC::FromHandle((HDC)wParam);

			// select bitmaps
			CBitmap *pOldGrip, *pOldMask;

			pOldGrip = m_dcGrip.SelectObject(&m_bmGrip);
			pOldMask = m_dcMask.SelectObject(&m_bmMask);

			// obtain original grip bitmap, make the mask and prepare masked bitmap
			CScrollBar::WindowProc(message, (WPARAM)m_dcGrip.GetSafeHdc(), lParam);
			m_dcGrip.SetBkColor(m_dcGrip.GetPixel(0, 0));
			m_dcMask.BitBlt(0, 0, m_size.cx, m_size.cy, &m_dcGrip, 0, 0, SRCCOPY);
			m_dcGrip.BitBlt(0, 0, m_size.cx, m_size.cy, &m_dcMask, 0, 0, 0x00220326);
			
			// draw transparently
			pDC->BitBlt(0, 0, m_size.cx, m_size.cy, &m_dcMask, 0, 0, SRCAND);
			pDC->BitBlt(0, 0, m_size.cx, m_size.cy, &m_dcGrip, 0, 0, SRCPAINT);

			// unselect bitmaps
			m_dcGrip.SelectObject(pOldGrip);
			m_dcMask.SelectObject(pOldMask);

			if (message == WM_PAINT && wParam == 0)
				EndPaint(&ps);
			return 0;
		}
		break;
	}

	return CScrollBar::WindowProc(message, wParam, lParam);
}

void CResizableGrip::CSizeGrip::SetTransparency(BOOL bActivate)
{
	// creates or deletes DCs and Bitmaps used for
	// implementing a transparent size grip

	if (bActivate && !m_bTransparent)
	{
		m_bTransparent = TRUE;

		CClientDC dc(this);

		// create memory DCs and bitmaps
		m_dcGrip.CreateCompatibleDC(&dc);
		m_bmGrip.CreateCompatibleBitmap(&dc, m_size.cx, m_size.cy);

		m_dcMask.CreateCompatibleDC(&dc);
		m_bmMask.CreateBitmap(m_size.cx, m_size.cy, 1, 1, NULL);
	}
	else if (!bActivate && m_bTransparent)
	{
		m_bTransparent = FALSE;

		// destroy memory DCs and bitmaps
		m_dcGrip.DeleteDC();
		m_bmGrip.DeleteObject();

		m_dcMask.DeleteDC();
		m_bmMask.DeleteObject();
	}
}

void CResizableGrip::CSizeGrip::SetTriangularShape(BOOL bEnable)
{
	m_bTriangular = bEnable;

	if (bEnable)
	{
		// set a triangular window region
		CRect rect;
		GetWindowRect(rect);
		rect.OffsetRect(-rect.TopLeft());
		POINT arrPoints[] =
		{
			{ rect.left, rect.bottom },
			{ rect.right, rect.bottom },
			{ rect.right, rect.top }
		};
		CRgn rgnGrip;
		rgnGrip.CreatePolygonRgn(arrPoints, 3, WINDING);
		SetWindowRgn((HRGN)rgnGrip.Detach(), IsWindowVisible());
	}
	else
	{
		SetWindowRgn((HRGN)NULL, IsWindowVisible());
	}
}
@


1.3
log
@updates from latest ResizableLib cvs
@
text
@d122 1
a122 1
BOOL CResizableGrip::CreateSizeGrip(BOOL bVisible /*= TRUE*/,
d126 3
@


1.2
log
@Updates from latest cvs source
@
text
@d228 1
d231 3
a233 1
			CPaintDC dc(this);
d242 1
a242 1
			CScrollBar::WindowProc(WM_PAINT, (WPARAM)m_dcGrip.GetSafeHdc(), lParam);
d248 2
a249 2
			dc.BitBlt(0, 0, m_size.cx, m_size.cy, &m_dcMask, 0, 0, SRCAND);
			dc.BitBlt(0, 0, m_size.cx, m_size.cy, &m_dcGrip, 0, 0, SRCPAINT);
d255 2
@


1.1
log
@*** empty log message ***
@
text
@d174 5
@


1.1.4.1
log
@added to branch
@
text
@@

