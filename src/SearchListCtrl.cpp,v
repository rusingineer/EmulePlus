head	1.114;
access;
symbols
	PublicRelease_1_2e:1.111
	Interim_Release_1-2e_RC1:1.111
	PublicRelease_1_2d:1.108
	Interim_Release_1-2d_RC1:1.108
	Interim_Release_1-2d_beta1:1.106
	PublicRelease_1_2c:1.102
	Interim_Release_1-2c_RC1:1.102
	Interim_Release_1-2c_beta1:1.98
	PublicRelease_1_2b:1.98
	Interim_Release_1-2b_RC1:1.98
	PublicRelease_1_2a:1.97
	Interim_Release_1-2a_RC1:1.97
	Interim_Release_1-2a_beta2:1.93
	Interim_Release_1-2a_beta1:1.93
	PublicRelease_1_2:1.92
	Interim_Release_1-2_RC1:1.92
	Interim_Release_1-2_beta1:1.90
	PublicRelease_1_1g:1.89
	Interim_Release_1-1g_RC3:1.89
	Interim_Release_1-1g_RC2:1.89
	Interim_Release_1-1g_RC1:1.89
	Interim_Release_1-1g_beta2:1.87
	Interim_Release_1-1g_beta1:1.86
	PublicRelease_1_1f:1.84
	Interim_Release_1-1f_RC1:1.84
	PublicRelease_1_1e:1.81
	Interim_Release_1-1e_RC2:1.81
	Interim_Release_1-1e_RC1:1.81
	Interim_Release_1-1e_beta1:1.80
	PublicRelease_1_1d:1.78
	Interim_Release_1-1d_RC1:1.78
	PublicRelease_1_1c:1.77
	Interim_Release_1-1c_RC1:1.77
	Interim_Release_1-1c_beta2:1.77
	Interim_Release_1-1c_beta1:1.77
	PublicRelease_1_1b:1.75
	Interim_Release_1-1b_RC1:1.75
	PublicRelease_1_1a:1.74
	Interim_Release_1-1a_RC2:1.74
	Interim_Release_1-1a_RC1:1.74
	Interim_Release_1-1a_beta2:1.74
	Interim_Release_1-1a_beta1:1.74
	PublicRelease_1_1:1.72
	Interim_Release_1-1_beta1:1.72
	PublicRelease_1o:1.71
	Interim_Release_1o_RC1:1.71
	Interim_Release_1o_beta1:1.71
	PublicRelease_1n:1.71
	Interim_Release_1n_RC2:1.71
	Interim_Release_1n_RC1:1.71
	Interim_Release_1n_beta2:1.70
	Interim_Release_1n_beta1:1.69
	PublicRelease_1m:1.69
	Interim_Release_1m_beta1:1.69
	PublicRelease_1l:1.68
	Interim_Release_1l_RC3:1.68
	Interim_Release_1l_RC2:1.67
	Interim_Release_1l_RC1:1.67
	Interim_Release_1l_beta2:1.65
	Interim_Release_1l_beta1:1.65
	PublicRelease_1k:1.61
	Interim_Release_1k_RC4:1.61
	Interim_1k_RC3:1.61
	Interim_1k_RC2:1.61
	Interim_Release_1k_RC1:1.61
	Interim_Release_1k_beta5:1.58
	Intrerim_Release_1k_beta4:1.58
	Interim_Release_1k_beta1:1.54
	PublicRelease_1j:1.48
	Interim_Release_1J_RC3:1.48
	Interim_Release_1j_RC3:1.48
	Interim_Release_1j_RC2:1.48
	Interim_Release_1j_RC1:1.48
	Interim_Release_1j_beta2:1.48
	Interim_Release_1j_beta1:1.48
	PublicRelease_1i:1.47
	Interim_Release_1i_RC6:1.47
	Interim_Release_1i_RC3:1.46
	Interim_Release_1i_RC2:1.46
	Interim_Release_1i_RC1:1.46
	Interim_Release_1i_beta3:1.45
	Interim_Release_1i_beta2:1.43
	Interim_Release_1i_beta1:1.37
	PublicRelease_1h:1.29
	Interim_Release_1h_rc2:1.29
	Interim_Release_1h_RC1:1.24
	Interim_Release_1h_beta2:1.24
	Interim_Release_1h_beta1_now:1.24
	Interim_Release_1h_beta1:1.24
	PublicRelease_1g:1.23
	Interim_Release_1g_RC6_Final:1.23
	Interim_Release_1g_RC6:1.23
	Interim_Release_1g_RC5:1.23
	Interim_Release_1g_RC4:1.23
	Interim_Release_1g_RC3:1.23
	Interim_Release_1g_beta2:1.22
	Interim_Release_1g_beta1:1.22
	Interim_Release_1f_RC4:1.20
	Interim_Release_1f_RC3:1.20
	Interim_Release_1f_RC2:1.19
	Interim_Release_1f_RC:1.19
	Interim_Release_1f_beta2:1.17
	Interim_Release_1f_beta1:1.17
	PublicRelease_1e:1.16
	Interim_Release_1e_RC2:1.16
	Interim_Release_1e_RC:1.16
	Interim_Release_1e_beta3:1.13
	Interim_Release_1e_beta2:1.13
	Interim_Release_1e_beta2_before_kuchin:1.13
	Interim_Release_1e_beta1:1.13
	PublicRelease_1c:1.13
	featurestest:1.13.0.2
	Interim_Release_1c_RC:1.13
	Interim_Release_1c_beta2:1.13
	Interim_Release_1c_beta1:1.12
	threaded_downloadqueue:1.12.0.2
	PublicRelease_1b:1.12
	Interim_Release_1b_beta2:1.12
	Interim_Release_1b_beta1:1.9
	proxydeadlake:1.9.0.2
	PublicRelease_1a:1.8
	Interim_Release_1a_beta2:1.8
	BerkeleyDb:1.8.0.2
	Interim_Release_1a_beta1:1.8
	PublicRelease_1:1.6
	goldfish:1.6
	eMulePlus_1_RC2:1.4
	eMulePlus_26b_1RC1:1.4
	PreRelease_26b_i0e:1.4
	before_26d_merge:1.4
	Interim_Release_26b_i0d:1.3
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.114
date	2009.10.28.04.34.59;	author aw3;	state Exp;
branches;
next	1.113;

1.113
date	2009.09.10.03.13.18;	author aw3;	state Exp;
branches;
next	1.112;

1.112
date	2009.05.14.03.14.15;	author aw3;	state Exp;
branches;
next	1.111;

1.111
date	2008.11.07.05.29.23;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2008.07.01.22.48.11;	author aw3;	state Exp;
branches;
next	1.108;

1.108
date	2008.04.05.20.22.49;	author eklmn;	state Exp;
branches;
next	1.107;

1.107
date	2008.04.05.09.49.09;	author eklmn;	state Exp;
branches;
next	1.106;

1.106
date	2007.12.29.05.48.24;	author aw3;	state Exp;
branches;
next	1.105;

1.105
date	2007.12.28.09.48.50;	author eklmn;	state Exp;
branches;
next	1.104;

1.104
date	2007.12.01.11.17.50;	author eklmn;	state Exp;
branches;
next	1.103;

1.103
date	2007.10.24.19.09.36;	author fuxie-dk;	state Exp;
branches;
next	1.102;

1.102
date	2007.07.08.22.31.19;	author kush_eplus;	state Exp;
branches;
next	1.101;

1.101
date	2007.07.08.00.15.48;	author aw3;	state Exp;
branches;
next	1.100;

1.100
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.99;

1.99
date	2007.04.19.02.57.28;	author aw3;	state Exp;
branches;
next	1.98;

1.98
date	2007.01.11.17.11.48;	author eklmn;	state Exp;
branches;
next	1.97;

1.97
date	2006.08.16.04.23.41;	author aw3;	state Exp;
branches;
next	1.96;

1.96
date	2006.08.14.02.38.44;	author aw3;	state Exp;
branches;
next	1.95;

1.95
date	2006.07.13.03.56.33;	author aw3;	state Exp;
branches;
next	1.94;

1.94
date	2006.07.12.17.40.42;	author kush_eplus;	state Exp;
branches;
next	1.93;

1.93
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.92;

1.92
date	2006.02.14.03.55.34;	author aw3;	state Exp;
branches;
next	1.91;

1.91
date	2006.02.13.05.40.00;	author aw3;	state Exp;
branches;
next	1.90;

1.90
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.89;

1.89
date	2005.11.27.22.11.49;	author eklmn;	state Exp;
branches;
next	1.88;

1.88
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.87;

1.87
date	2005.08.29.03.08.32;	author aw3;	state Exp;
branches;
next	1.86;

1.86
date	2005.08.11.03.49.28;	author aw3;	state Exp;
branches;
next	1.85;

1.85
date	2005.08.06.17.58.07;	author aw3;	state Exp;
branches;
next	1.84;

1.84
date	2005.07.30.02.20.30;	author aw3;	state Exp;
branches;
next	1.83;

1.83
date	2005.07.28.02.24.03;	author aw3;	state Exp;
branches;
next	1.82;

1.82
date	2005.07.27.11.08.32;	author aw3;	state Exp;
branches;
next	1.81;

1.81
date	2005.06.13.04.11.15;	author aw3;	state Exp;
branches;
next	1.80;

1.80
date	2005.04.02.22.33.19;	author aw3;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.29.01.31.56;	author aw3;	state Exp;
branches;
next	1.78;

1.78
date	2005.03.06.17.38.13;	author aw3;	state Exp;
branches;
next	1.77;

1.77
date	2005.01.19.21.10.49;	author netwolf1;	state Exp;
branches;
next	1.76;

1.76
date	2005.01.16.21.46.11;	author netwolf1;	state Exp;
branches;
next	1.75;

1.75
date	2004.12.16.00.26.16;	author aw3;	state Exp;
branches;
next	1.74;

1.74
date	2004.11.08.00.28.42;	author aw3;	state Exp;
branches;
next	1.73;

1.73
date	2004.11.02.17.21.18;	author aw3;	state Exp;
branches;
next	1.72;

1.72
date	2004.10.18.04.41.38;	author aw3;	state Exp;
branches;
next	1.71;

1.71
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.70;

1.70
date	2004.07.22.23.46.03;	author aw3;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.20.01.02.55;	author aw3;	state Exp;
branches;
next	1.68;

1.68
date	2004.06.06.05.02.11;	author aw3;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.25.03.23.35;	author kush_eplus;	state Exp;
branches;
next	1.66;

1.66
date	2004.05.24.17.51.45;	author dongato;	state Exp;
branches;
next	1.65;

1.65
date	2004.05.05.17.17.43;	author netwolf1;	state Exp;
branches;
next	1.64;

1.64
date	2004.05.03.08.24.59;	author katsyonak;	state Exp;
branches;
next	1.63;

1.63
date	2004.04.22.05.51.51;	author kush_eplus;	state Exp;
branches;
next	1.62;

1.62
date	2004.04.13.01.01.35;	author katsyonak;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.26.10.55.37;	author dongato;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.25.20.22.12;	author aw3;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.25.09.17.18;	author eklmn;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.57;

1.57
date	2004.03.03.21.45.23;	author dropf;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.28.13.56.45;	author dongato;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.23.03.34.09;	author aw3;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.17.22.02.51;	author aw3;	state Exp;
branches;
next	1.53;

1.53
date	2004.02.16.23.22.39;	author aw3;	state Exp;
branches;
next	1.52;

1.52
date	2004.02.11.04.13.01;	author katsyonak;	state Exp;
branches;
next	1.51;

1.51
date	2004.02.09.16.39.50;	author kush_eplus;	state Exp;
branches;
next	1.50;

1.50
date	2004.02.09.02.31.48;	author netwolf1;	state Exp;
branches;
next	1.49;

1.49
date	2004.02.05.19.28.09;	author kush_eplus;	state Exp;
branches;
next	1.48;

1.48
date	2003.12.12.03.49.46;	author dongato;	state Exp;
branches;
next	1.47;

1.47
date	2003.11.21.20.24.58;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.04.18.52.21;	author eklmn;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.27.12.52.36;	author dongato;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.26.15.57.56;	author morevit;	state Exp;
branches;
next	1.43;

1.43
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.42;

1.42
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.13.15.14.07;	author morevit;	state Exp;
branches;
next	1.39;

1.39
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.06.21.57.05;	author puritynn666;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.04.22.20.21;	author morevit;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.03.23.18.49;	author morevit;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.03.13.04.36;	author morevit;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.25.01.09.10;	author dongato;	state Exp;
branches;
next	1.33;

1.33
date	2003.09.23.20.26.30;	author dongato;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.16.11.09.20;	author dongato;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.15.14.26.31;	author dongato;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.14.13.48.42;	author dongato;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.12.16.05.53;	author dongato;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.12.04.46.59;	author dongato;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.07.20.26.59;	author syrus77;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.15.13.41.14;	author partyckip;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.31.08.50.54;	author partyckip;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.30.21.26.59;	author partyckip;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.18.13.29.14;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.11.12.18.01;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.11.11.37.48;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.04.10.05.33;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.26.20.53.29;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.26.20.34.26;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.25.21.29.57;	author lord_kiron;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.15.19.50.54;	author dongato;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.08.19.27.12;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.08.17.33.32;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.08.12.09.42;	author recdvst;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.28.00.53.24;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.23.20.15.52;	author obaldin;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2003.02.22.14.20.54;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.20.23.21.19;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.20.14.48.17;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.16.22.01.48;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.10.19.24.49;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.24.22.07.49;	author maverick65;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.25;	author cax2;	state Exp;
branches;
next	;

1.8.2.1
date	2003.02.28.22.44.56;	author obaldin;	state Exp;
branches;
next	;


desc
@@


1.114
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "server.h"
#include "SearchListCtrl.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "FakeCheck.h"
#include "TitleMenu.h"
#include "MemDC.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CSearchListCtrl, CMuleListCtrl)

BEGIN_MESSAGE_MAP(CSearchListCtrl, CMuleListCtrl)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnClick)
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSearchListCtrl::CSearchListCtrl()
{
	m_pSearchList = NULL;
	m_dwResultsID = 0;
	SetGeneralPurposeFind(true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::Init(CSearchList *pSearchList)
{
	static const int s_aiDoubleLevelCols[] = { SEARCHCOL_SOURCES };
	static const uint16 s_auColHdr[][2] =
	{
		{ LVCFMT_LEFT,  250 },	//SEARCHCOL_FILENAME
		{ LVCFMT_RIGHT, 100 },	//SEARCHCOL_SIZE
		{ LVCFMT_RIGHT,  50 },	//SEARCHCOL_SOURCES
		{ LVCFMT_LEFT,   65 },	//SEARCHCOL_TYPE
		{ LVCFMT_LEFT,  220 },	//SEARCHCOL_FILEHASH
		{ LVCFMT_LEFT,  220 },	//SEARCHCOL_FAKECHECK
		{ LVCFMT_LEFT,  130 },	//SEARCHCOL_LASTSEENCOMPLETE
		{ LVCFMT_LEFT,  150 },	//SEARCHCOL_FOLDER
		{ LVCFMT_RIGHT,  70 },	//SEARCHCOL_LENGTH
		{ LVCFMT_RIGHT,  70 },	//SEARCHCOL_BITRATE
		{ LVCFMT_LEFT,   60 }	//SEARCHCOL_CODEC
	};
	static const uint16 s_auIconResID[] =
	{
		IDI_RATING_FAKE,
		IDI_RATING_POOR,
		IDI_RATING_FAIR,
		IDI_RATING_GOOD,
		IDI_RATING_EXCELLENT
	};

	CImageList ilDummyImageList;
	ilDummyImageList.Create(1, 17, ILC_COLOR, 1, 1);
	SetImageList(&ilDummyImageList, LVSIL_SMALL);
	ilDummyImageList.Detach();

	SetExtendedStyle(LVS_EX_FULLROWSELECT);
	ModifyStyle(LVS_SINGLESEL, 0);

	m_pSearchList = pSearchList;

	for (unsigned ui = 0; ui < ARRSIZE(s_auColHdr); ui++)
		InsertColumn(ui, _T(""), static_cast<int>(s_auColHdr[ui][0]), static_cast<int>(s_auColHdr[ui][1]), ui);

	m_imageList.Create(16, 16, g_App.m_iDfltImageListColorFlags | ILC_MASK, ARRSIZE(s_auIconResID), 0);
	m_imageList.SetBkColor(CLR_NONE);
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ARRSIZE(s_auIconResID));

	LoadSettings(CPreferences::TABLE_SEARCH);
	SetSortProcedure(SortProc);
	SetDoubleLayerSort(s_aiDoubleLevelCols, ARRSIZE(s_aiDoubleLevelCols));
	if (g_App.m_pPrefs->DoUseSort())
		SortInit(g_App.m_pPrefs->GetSearchSortCol());
	else
		SortInit(g_App.m_pPrefs->GetColumnSortCode(CPreferences::TABLE_SEARCH));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CSearchListCtrl::~CSearchListCtrl()
{
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::Localize()
{
	static const uint16 s_auResTbl[] =
	{
		IDS_DL_FILENAME,
		IDS_DL_SIZE,
		IDS_DL_SOURCES,
		IDS_TYPE,
		IDS_FILEHASH,
		IDS_FAKE_CHECK_HEADER,
		IDS_LASTSEENCOMPLETE,
		IDS_SF_FOLDER,
		IDS_LENGTH,
		IDS_BITRATE,
		IDS_CODEC
	};

	if (GetSafeHwnd() != NULL)
	{
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
		CString		strRes;
		HDITEM		hdi;

		hdi.mask = HDI_TEXT;

		for (unsigned ui = 0; ui < ARRSIZE(s_auResTbl); ui++)
		{
			::GetResString(&strRes, static_cast<UINT>(s_auResTbl[ui]));
			hdi.pszText = const_cast<LPTSTR>(strRes.GetString());
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::AddResult(CSearchFile *pSearchFile)
{
	EMULE_TRY

//	If there's at least one search tab...
	if (g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.GetItemCount() > 0)
	{
	//	Update tab-iWebServiceCounter for the given search pSearchFile
		CString		strName, strSource;
		int		j;
		int		iTabCounter;
		TCHAR		acText[510];
		TCITEM		tabItem;

		tabItem.mask = TCIF_PARAM;

		for (iTabCounter = 0; iTabCounter < g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.GetItemCount(); iTabCounter++)
		{
			g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.GetItem(iTabCounter, &tabItem);
			if (tabItem.lParam == static_cast<LONG>(pSearchFile->GetSearchID()))
				break;
		}

		if (tabItem.lParam == static_cast<LONG>(pSearchFile->GetSearchID()))
		{
			tabItem.pszText = acText;
			tabItem.cchTextMax = ARRSIZE(acText);
			tabItem.mask = TCIF_TEXT;
			g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.GetItem(iTabCounter, &tabItem);

			strName = acText;

			tabItem.mask = TCIF_PARAM;
			g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.GetItem(iTabCounter, &tabItem);

			strSource.Format(_T(" (%u)"), m_pSearchList->GetFoundFiles(pSearchFile->GetSearchID()));

			j = strName.ReverseFind(_T('('));
			if (j > 0)
				strName.Truncate(j - 1);
			strName.Append(strSource);

			tabItem.mask = TCIF_TEXT;
			tabItem.pszText = strName.LockBuffer();
			g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.SetItem(iTabCounter, &tabItem);
			strName.UnlockBuffer();
		}
	}

	if (pSearchFile->GetSearchID() != m_dwResultsID)
		return;

	uint32		dwIndex = GetItemCount();

	dwIndex = InsertItem(LVIF_TEXT | LVIF_PARAM, dwIndex, pSearchFile->GetFileName(), 0, 0, 0, (LPARAM)pSearchFile);

	CString		strTmp;

	UpdateLine(dwIndex, pSearchFile);

	SetItemText(dwIndex, SEARCHCOL_SIZE, CastItoXBytes(pSearchFile->GetFileSize()));
	SetItemText(dwIndex, SEARCHCOL_TYPE, pSearchFile->GetFileTypeString());
	strTmp = HashToString(pSearchFile->GetFileHash());
	SetItemText(dwIndex, SEARCHCOL_FILEHASH, strTmp);
 //	FakeCheck
	if (IsColumnHidden(SEARCHCOL_FAKECHECK))
		SetItemText(dwIndex, SEARCHCOL_FAKECHECK, _T(""));
	else
	{
		g_App.m_pFakeCheck->GetFakeComment(strTmp, pSearchFile->GetFileSize(), &strTmp);
		SetItemText(dwIndex, SEARCHCOL_FAKECHECK, strTmp);
	}

	SetItemText(dwIndex, SEARCHCOL_FOLDER, pSearchFile->GetSearchFileDir());

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::UpdateChangingColumns(CSearchFile *pSearchFile)
{
	EMULE_TRY

	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = reinterpret_cast<LPARAM>(pSearchFile);

	int		iIndex = FindItem(&find);

	if (iIndex != -1)
	{
		UpdateLine(iIndex, pSearchFile);
		Update(iIndex);
		RedrawItems(iIndex, iIndex);
		SortInit(m_dwParamSort);
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::UpdateLine(int iIndex, CSearchFile *pSearchFile)
{
	CString		strTmp;
	uint32		dwTmp, dwLastSeenVal;

	strTmp.Format(_T("%u (%u)"), pSearchFile->GetSourceCount(), pSearchFile->GetCompleteSourceCount());
	SetItemText(iIndex, SEARCHCOL_SOURCES, strTmp);

	if ((dwLastSeenVal = pSearchFile->GetLastSeenCompleteValue()) == 0)
		SetItemText(iIndex, SEARCHCOL_LASTSEENCOMPLETE, _T(""));	//currently available
	else
	{
		if (dwLastSeenVal == 0x7FFFFFFF)
			GetResString(&strTmp, IDS_NEVER);	//complete file wasn't seen
		else
		{
			COleDateTime lastSeenTime = COleDateTime::GetCurrentTime() - COleDateTimeSpan(0, 0, 0, dwLastSeenVal - 1);

			strTmp = lastSeenTime.Format(_T("%c"));
		}
		SetItemText(iIndex, SEARCHCOL_LASTSEENCOMPLETE, strTmp);
	}

	if ((dwTmp = pSearchFile->GetMediaLength()) != 0)
		SetItemText(iIndex, SEARCHCOL_LENGTH, CastSecondsToHM(dwTmp));
	else
		SetItemText(iIndex, SEARCHCOL_LENGTH, _T(""));

	if ((dwTmp = pSearchFile->GetMediaBitrate()) != 0)
	{
		strTmp.Format(_T("%u kbps"), dwTmp);
		SetItemText(iIndex, SEARCHCOL_BITRATE, strTmp);
	}
	else
		SetItemText(iIndex, SEARCHCOL_BITRATE, _T(""));
	SetItemText(iIndex, SEARCHCOL_CODEC, pSearchFile->GetMediaCodec());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::RemoveResult(CSearchFile *pSearchFile)
{
	EMULE_TRY

	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = reinterpret_cast<LPARAM>(pSearchFile);

	sint32		lIndex = FindItem(&find);

	if (lIndex != -1)
		DeleteItem(lIndex);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::ShowResults(uint32 dwResultsID)
{
	EMULE_TRY

	DeleteAllItems();
	m_dwResultsID = dwResultsID;
	if (m_pSearchList != NULL)
		m_pSearchList->ShowResults(m_dwResultsID);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	EMULE_TRY

	if (!lpDrawItemStruct->itemData)
		return;

	CSearchFile	*pSearchFile = reinterpret_cast<CSearchFile*>(lpDrawItemStruct->itemData);
	CDC			*odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	UINT		iCalcFlag = (DT_SINGLELINE | DT_VCENTER | DT_NOPREFIX | DT_END_ELLIPSIS);
	COLORREF	crBk, crWinBk;

	if (IsRightToLeftLanguage())
		iCalcFlag |= DT_RTLREADING;

	crWinBk = crBk = GetBkColor();
	if (lpDrawItemStruct->itemState & ODS_SELECTED)
		crBk = (GetFocus() == this) ? m_crHighlight : m_crNoHighlight;

	CMemDC		dc(odc, &lpDrawItemStruct->rcItem, crWinBk, crBk);
	CFont		*pOldFont = dc->SelectObject(GetFont());
	COLORREF	crText = ::GetSysColor(COLOR_WINDOWTEXT);
	uint32		dwRed = GetRValue(crText);
	uint32		dwGreen = GetGValue(crText);
	uint32		dwBlue = GetGValue(crText);
	CKnownFile	*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pSearchFile->GetFileHash());

//	If it's not a completed shared file, check to see if it's a part file
	if (pKnownFile == NULL)
		pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pSearchFile->GetFileHash());
	if (pKnownFile != NULL)
	{
	//	Currently downloading (-> red)
		if (pKnownFile->IsPartFile())
		{
			dwRed = (pSearchFile->GetSourceCount() + 4) * 20;
			if (dwRed > 255)
				dwRed = 255;
		}
		else	//	Already downloaded and currently shared (-> green)
			dwGreen = 128;
	}
	else
	{
		pKnownFile = g_App.m_pKnownFilesList->FindKnownFileByID(pSearchFile->GetFileHash());

	//	Known but currently not shared (-> Orange)
		if (pKnownFile != NULL)
		{
			dwRed = 255;
			dwGreen = 165;
			dwBlue = 0;
		}
		else	//	Not known at all (-> indicate availability in shades of blue)
		{
			dwBlue = (pSearchFile->GetSourceCount() == 0) ? 0 : ((pSearchFile->GetSourceCount() - 1) * 20);
			if (dwBlue > 255)
				dwBlue = 255;
		}
	}

	COLORREF	crOldText = dc->SetTextColor(RGB(dwRed, dwGreen, dwBlue));
	RECT		r = lpDrawItemStruct->rcItem;
	CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
	int			iImgIdx, iCol, iNumCols = pHeaderCtrl->GetItemCount();

	r.right = r.left - 2;
	r.left += 3;

	for (int iColIdx = 0; iColIdx < iNumCols; iColIdx++)
	{
		iCol = pHeaderCtrl->OrderToIndex(iColIdx);
		if (IsColumnHidden(iCol))
			continue;
		r.right += CListCtrl::GetColumnWidth(iCol);
		switch (iCol)
		{
			case SEARCHCOL_FILENAME:
				// File Type
				if (g_App.m_pPrefs->ShowFileTypeIcon())
				{
					iImgIdx = g_App.GetFileTypeSystemImageIdx(pSearchFile->GetFileName());
					if (g_App.GetSystemImageList() != NULL)
						::ImageList_Draw(g_App.GetSystemImageList(), iImgIdx, dc->GetSafeHdc(), r.left, r.top + 1, ILD_TRANSPARENT);
					r.left += 19;
				}
				// File Rating
				if (g_App.m_pPrefs->ShowRatingIcons())
				{
					if ((iImgIdx = pSearchFile->GetSrvFileRating()) != PF_RATING_NONE)
						m_imageList.Draw(dc, iImgIdx - 1, CPoint(r.left - 4, r.top + 2), ILD_TRANSPARENT);
					r.left += 10;
				}
			default:
				dc->DrawText(GetItemText(lpDrawItemStruct->itemID, iCol), &r, DT_LEFT | iCalcFlag);
				break;

			case SEARCHCOL_SIZE:
			case SEARCHCOL_SOURCES:
			case SEARCHCOL_LENGTH:
			case SEARCHCOL_BITRATE:
				dc->DrawText(GetItemText(lpDrawItemStruct->itemID, iCol), &r, DT_RIGHT | iCalcFlag);
				break;
		}
		r.left = r.right + 5;
	}

	if(lpDrawItemStruct->itemState & ODS_FOCUS)
	{
		RECT	rOutline = lpDrawItemStruct->rcItem;
		CBrush	FrmBrush((GetFocus() == this) ? m_crFocusLine : m_crNoFocusLine);

		rOutline.left++;
		rOutline.right--;
		dc->FrameRect(&rOutline, &FrmBrush);
	}

	dc->SelectObject(pOldFont);
	dc->SetTextColor(crOldText);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader)
{
	int		iWidth, iColumn = pHeader->iItem;

	SetRedraw(false);
	CMuleListCtrl::OnNMDividerDoubleClick(pHeader);
	if ((iColumn == SEARCHCOL_FILENAME) && (g_App.m_pPrefs->ShowRatingIcons() || g_App.m_pPrefs->ShowFileTypeIcon()))
	{
	//	Base class sets max width for a label, adjusting according to used icons
		iWidth = GetColumnWidth(iColumn);
		if (g_App.m_pPrefs->ShowFileTypeIcon())
			iWidth += 19;
		if (g_App.m_pPrefs->ShowRatingIcons())
			iWidth += 10;
		SetColumnWidth(iColumn, iWidth);
	}
	SetRedraw(true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CSearchListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	EMULE_TRY
	CSearchFile		*pSearchFile1 = reinterpret_cast<CSearchFile*>(lParam1);
	CSearchFile		*pSearchFile2 = reinterpret_cast<CSearchFile*>(lParam2);

	if (pSearchFile1 == NULL || pSearchFile2 == NULL)
		return 0;

	uint32	dwVal1, dwVal2;
	int		iCompare = 0;
	int		iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 1 : -1;
	int		iSortAltFlag = (lParamSort & MLC_SORTALT);
	int		iSortCol = lParamSort & MLC_COLUMNMASK;

	for (;;)
	{
		switch (iSortCol)
		{
			case SEARCHCOL_FILENAME:
				iCompare = pSearchFile1->CmpFileNames(pSearchFile2->GetFileName());
				break;

			case SEARCHCOL_SIZE:
				iCompare = CompareInt64(pSearchFile1->GetFileSize(), pSearchFile2->GetFileSize());
				break;

			case SEARCHCOL_SOURCES:
				if (iSortAltFlag == 0)
				{
					iCompare = pSearchFile1->GetSourceCount() - pSearchFile2->GetSourceCount();
					if (iCompare == 0)
						iCompare = pSearchFile1->GetCompleteSourceCount() - pSearchFile2->GetCompleteSourceCount();
				}
				else
				{
					iCompare = pSearchFile1->GetCompleteSourceCount() - pSearchFile2->GetCompleteSourceCount();
					if (iCompare == 0)
						iCompare = pSearchFile1->GetSourceCount() - pSearchFile2->GetSourceCount();
				}
				if (iCompare == 0)
				{
					iSortCol = SEARCHCOL_FILENAME;
					iSortMod = 1;		//sort always in ascending order
					continue;
				}
				break;

			case SEARCHCOL_TYPE:
				iCompare = pSearchFile1->CmpFileTypes(pSearchFile2->GetFileType());
				if (iCompare == 0)
				{
					iSortMod = 1;		//sort always in ascending order
					if ((iCompare = pSearchFile1->GetFileExtension().Compare(pSearchFile2->GetFileExtension())) == 0)
					{
						iSortCol = SEARCHCOL_FILENAME;
						continue;
					}
				}
				break;

			case SEARCHCOL_FILEHASH:
				iCompare = memcmp(pSearchFile1->GetFileHash(), pSearchFile2->GetFileHash(), 16);
				break;

			case SEARCHCOL_FAKECHECK:
			{
				CString strVal1;
				CString strVal2;

				g_App.m_pFakeCheck->GetFakeComment(HashToString(pSearchFile1->GetFileHash()), pSearchFile1->GetFileSize(), &strVal1);
				g_App.m_pFakeCheck->GetFakeComment(HashToString(pSearchFile2->GetFileHash()), pSearchFile2->GetFileSize(), &strVal2);
				iCompare = _tcscmp(strVal1, strVal2);
				break;
			}

			case SEARCHCOL_LASTSEENCOMPLETE:
				iCompare = pSearchFile1->GetLastSeenCompleteValue() - pSearchFile2->GetLastSeenCompleteValue();
				if (iCompare == 0)
				{
					iSortCol = SEARCHCOL_SOURCES;
					iSortMod = -1;		//in descending order
					continue;
				}
				break;

			case SEARCHCOL_FOLDER:
				iCompare = _tcsicmp(pSearchFile1->GetSearchFileDir(), pSearchFile2->GetSearchFileDir());
				if (iCompare == 0)
				{
					iSortCol = SEARCHCOL_FILENAME;
					iSortMod = 1;		//sort always in ascending order
					continue;
				}
				break;

			case SEARCHCOL_LENGTH:
				dwVal1 = pSearchFile1->GetMediaLength();
				dwVal2 = pSearchFile2->GetMediaLength();
				iCompare = CompareUnsigned(dwVal1, dwVal2);
				if ((dwVal1 == 0) || (dwVal2 == 0))
					iSortMod = -1;	// not specified values always at the end
				break;

			case SEARCHCOL_BITRATE:
				dwVal1 = pSearchFile1->GetMediaBitrate();
				dwVal2 = pSearchFile2->GetMediaBitrate();
				iCompare = CompareUnsigned(dwVal1, dwVal2);
				if ((dwVal1 == 0) || (dwVal2 == 0))
					iSortMod = -1;	// not specified values always at the end
				break;

			case SEARCHCOL_CODEC:
			{
				CString strVal1 = pSearchFile1->GetMediaCodec();
				CString strVal2 = pSearchFile2->GetMediaCodec();

				iCompare = _tcsicmp(strVal1, strVal2);
				if (strVal1.IsEmpty() || strVal2.IsEmpty())
					iSortMod = -1;	// not specified values always at the end
				break;
			}
		}
		break;
	}
	return iCompare * iSortMod;

	EMULE_CATCH
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CSearchListCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	NOPRM(pWnd);
	EMULE_TRY

	CTitleMenu	menuSearchFile;
	CMenu		menuED2K, menuWebServices;

	menuSearchFile.CreatePopupMenu();
	menuSearchFile.AddMenuTitle(GetResString(IDS_FILE));

	CServer		*pCurServer;
	int			iSelectionMark = GetSelectionMark();
	UINT		dwFlags2, dwSelectedCount = GetSelectedCount();
	UINT		dwMenuFlags = MF_STRING | (((iSelectionMark != -1) && (dwSelectedCount > 0)) ? MF_ENABLED : MF_GRAYED);

	menuSearchFile.AppendMenu(dwMenuFlags, MP_RESUME, GetResString(IDS_DOWNLOAD_VERB));
	menuSearchFile.AppendMenu(dwMenuFlags, MP_RESUMEPAUSED, GetResString(IDS_DOWNLOAD_VERB) + _T(" (") + GetResString(IDS_PAUSED) + _T(")"));
	menuSearchFile.AppendMenu( MF_STRING |
		((iSelectionMark != -1) && (dwSelectedCount > 0) &&
		g_App.m_pServerConnect->IsConnected() &&
		((pCurServer = g_App.m_pServerConnect->GetCurrentServer()) != NULL) &&
		(pCurServer->GetTCPFlags() & SRV_TCPFLG_RELATEDSEARCH)
		) ? MF_ENABLED : MF_GRAYED, MP_SEARCHRELATED, GetResString(IDS_SEARCHRELATED) );

	menuSearchFile.SetDefaultItem(
		(g_App.m_pPrefs->StartDownloadPaused()) ? MP_RESUMEPAUSED : MP_RESUME );

	menuSearchFile.AppendMenu(MF_SEPARATOR);

	menuSearchFile.AppendMenu(dwMenuFlags, MP_REMOVESELECTED, GetResString(IDS_REMOVESELECTED));
	dwFlags2 = MF_STRING | ((g_App.m_pMDlg->m_dlgSearch.m_ctlSearchTabs.GetItemCount() > 0) ? MF_ENABLED : MF_GRAYED);
	menuSearchFile.AppendMenu(dwFlags2, MP_REMOVEALL, GetResString(IDS_REMOVEALLSEARCH));

	menuSearchFile.AppendMenu(MF_SEPARATOR);

	menuED2K.CreateMenu();
	menuED2K.AppendMenu(MF_STRING, MP_GETED2KLINK, GetStringFromShortcutCode(IDS_DL_LINK1, SCUT_LINK, SSP_TAB_PREFIX));
	menuED2K.AppendMenu(MF_STRING, MP_GETHTMLED2KLINK, GetStringFromShortcutCode(IDS_DL_LINK2, SCUT_LINK_HTML, SSP_TAB_PREFIX));
	menuED2K.AppendMenu(MF_STRING, MP_GETHASH, GetStringFromShortcutCode(IDS_COPYHASH, SCUT_LINK_HASH, SSP_TAB_PREFIX));
	menuSearchFile.AppendMenu(dwMenuFlags | MF_POPUP, (UINT_PTR)menuED2K.m_hMenu, GetResString(IDS_ED2KLINKFIX));

	menuWebServices.CreateMenu();

	dwMenuFlags |= ( ( (UpdateURLMenu(menuWebServices) == 0) ||
		((iSelectionMark != -1) && (dwSelectedCount > 1)) ) ? MF_GRAYED : 0 );

	menuSearchFile.AppendMenu(dwMenuFlags | MF_POPUP, (UINT_PTR)menuWebServices.m_hMenu, GetResString(IDS_WEBSERVICES));

	menuSearchFile.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);

//	Menu objects are destroyed in their destructor

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CSearchListCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	NOPRM(lParam);
	EMULE_TRY

//	For multiple selections
	CTypedPtrList<CPtrList, CSearchFile*> selectedList;
	int			iIdx;
	POSITION	pos = GetFirstSelectedItemPosition();

	while (pos != NULL)
	{
		if ((iIdx = GetNextSelectedItem(pos)) >= 0)
			selectedList.AddTail(reinterpret_cast<CSearchFile*>(GetItemData(iIdx)));
	}

	if (selectedList.GetCount() > 0)
	{
		switch (wParam)
		{
			case MP_GETED2KLINK:
			{
				CString		str;

				while (!selectedList.IsEmpty())
				{
					str += selectedList.RemoveHead()->CreateED2kLink();
					if (!selectedList.IsEmpty())
						str += _T("\r\n");
				}
				g_App.CopyTextToClipboard(str);
				return true;
			}
			case MP_GETHTMLED2KLINK:
			{
				CString		str;

				while (!selectedList.IsEmpty())
				{
					str += selectedList.RemoveHead()->CreateHTMLED2kLink();
					if (!selectedList.IsEmpty())
						str += _T("\r\n");
				}
				g_App.CopyTextToClipboard(str);
				return true;
			}
			case MP_GETHASH:
			{
				CString str;

				while (!selectedList.IsEmpty())
				{
					str += HashToString(selectedList.RemoveHead()->GetFileHash());
					if (!selectedList.IsEmpty())
						str += _T("\r\n");
				}
				g_App.CopyTextToClipboard(str);
				return true;
			}
			case MP_RESUMEPAUSED:
			case MP_RESUME:
				g_App.m_pMDlg->m_dlgSearch.DownloadSelected(wParam == MP_RESUMEPAUSED);
				return true;

			case MP_REMOVESELECTED:
				SetRedraw(false);
				while (!selectedList.IsEmpty())
					g_App.m_pSearchList->RemoveResults(selectedList.RemoveHead());
				SetRedraw(true);
				return true;

			case MP_SEARCHRELATED:
			{
				CString	strSearch(_T("related"));

			//	Just a shortcut for a user typing into the search field "related::[filehash]"
			//	Limit is used to protect against very long request
				for (iIdx = 0; !selectedList.IsEmpty() && (iIdx < 10); iIdx++)
				{
					CSearchFile	*pSearchFile = selectedList.RemoveHead();

					strSearch += _T("::");
					strSearch += HashToString(pSearchFile->GetFileHash());
				}
				g_App.m_pMDlg->m_dlgSearch.DoNewEd2kSearch(strSearch, GetResString(IDS_SEARCH_ANY), 0, 0, 0, _T(""), false, _T(""));
				return true;
			}
			default:
				if ((wParam >= MP_WEBURL) && (wParam <= MP_WEBURL + 64))
				{
					RunURL(selectedList.GetHead(), g_App.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
					return true;
				}
				break;
		}
	}
//	Commands which don't depend on selection
	switch (wParam)
	{
		case MP_REMOVEALL:
			g_App.m_pMDlg->m_dlgSearch.DeleteAllSearches();
			break;
	}
	EMULE_CATCH
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CSearchListCtrl::PreTranslateMessage(MSG *pMsg)
{
	if ((pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_SYSKEYDOWN))
	{
		POSITION	posSelClient = GetFirstSelectedItemPosition();

		if (posSelClient != NULL)
		{
			int		iMessage = 0;
			short	nCode = GetCodeFromPressedKeys(pMsg);

			if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK))
				iMessage = MP_GETED2KLINK;
			else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK_HTML))
				iMessage = MP_GETHTMLED2KLINK;
			else if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK_HASH))
				iMessage = MP_GETHASH;

			if (iMessage > 0)
			{
				PostMessage(WM_COMMAND, static_cast<WPARAM>(iMessage));
				return TRUE;
			}
		}
	}

	return CMuleListCtrl::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.113
log
@Show media information in the search results received from consecutive servers (before media information was shown only when the server provided file information was attaching it; media information wasn't added to the list even when next server sent it for the same file).
@
text
@d27 3
@


1.112
log
@Save sorting directions for all GUI lists; Unified list sort initialization and click processing;
Simplified list arrow configuration interface; Unified list column definitions.
@
text
@d191 1
a191 1
	uint32		dwTmp, dwIndex = GetItemCount();
a213 14
	if ((dwTmp = pSearchFile->GetMediaLength()) != 0)
		SetItemText(dwIndex, SEARCHCOL_LENGTH, CastSecondsToHM(dwTmp));
	else
		SetItemText(dwIndex, SEARCHCOL_LENGTH, _T(""));

	if ((dwTmp = pSearchFile->GetMediaBitrate()) != 0)
	{
		strTmp.Format(_T("%u kbps"), dwTmp);
		SetItemText(dwIndex, SEARCHCOL_BITRATE, strTmp);
	}
	else
		SetItemText(dwIndex, SEARCHCOL_BITRATE, _T(""));
	SetItemText(dwIndex, SEARCHCOL_CODEC, pSearchFile->GetMediaCodec());

d241 1
a241 1
	uint32		dwLastSeenVal;
d260 14
@


1.111
log
@Fixed auto-resize for the first column of the shared files and search lists;
Slightly more efficient GetColumnWidth to speed up list drawing.
@
text
@d37 1
a37 1
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
d51 1
d54 11
a64 11
		{ LVCFMT_LEFT,  250 },	//SL_COLUMN_FILENAME
		{ LVCFMT_RIGHT, 100 },	//SL_COLUMN_SIZE
		{ LVCFMT_RIGHT,  50 },	//SL_COLUMN_SOURCES
		{ LVCFMT_LEFT,   65 },	//SL_COLUMN_TYPE
		{ LVCFMT_LEFT,  220 },	//SL_COLUMN_FILEHASH
		{ LVCFMT_LEFT,  220 },	//SL_COLUMN_FAKECHECK
		{ LVCFMT_LEFT,  130 },	//SL_COLUMN_LASTSEENCOMPLETE
		{ LVCFMT_LEFT,  150 },	//SL_COLUMN_FOLDER
		{ LVCFMT_RIGHT,  70 },	//SL_COLUMN_LENGTH
		{ LVCFMT_RIGHT,  70 },	//SL_COLUMN_BITRATE
		{ LVCFMT_LEFT,   60 }	//SL_COLUMN_CODEC
a91 2
	memzero(&m_bSortAscending, SL_NUMCOLUMNS * sizeof(m_bSortAscending[0]));
	m_bSortAscending[SL_NUMCOLUMNS] = true;	//disable double-level sorting by default
d93 2
d98 1
a98 6
	{
		int		iSortCode = g_App.m_pPrefs->GetColumnSortItem(CPreferences::TABLE_SEARCH);

		iSortCode |= g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_SEARCH) ? MLC_SORTASC : MLC_SORTDESC;
		SortInit(iSortCode);
	}
a104 25
void CSearchListCtrl::SortInit(int iSortCode)
{
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);			//the sort column
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;	//the sort order
	int		iSortAltFlag = (iSortCode & MLC_SORTALT);			//the alternate sort

	if (iSortColumn != SL_COLUMN_SOURCES)
		iSortAltFlag = 0;

	m_bSortAscending[iSortColumn] = bSortAscending;
	if (iSortAltFlag == 0)
	{
		if (iSortColumn == SL_COLUMN_SOURCES)
			m_bSortAscending[SL_NUMCOLUMNS] = true;
		SetSortArrow(iSortColumn, bSortAscending);
	}
	else
	{
		if (iSortColumn == SL_COLUMN_SOURCES)
			m_bSortAscending[SL_NUMCOLUMNS] = false;
		SetSortArrow(iSortColumn, (bSortAscending) ? CMuleListCtrl::arrowDoubleUp : CMuleListCtrl::arrowDoubleDown);
	}
	SortItems(SortProc, iSortCode);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d199 2
a200 2
	SetItemText(dwIndex, SL_COLUMN_SIZE, CastItoXBytes(pSearchFile->GetFileSize()));
	SetItemText(dwIndex, SL_COLUMN_TYPE, pSearchFile->GetFileTypeString());
d202 1
a202 1
	SetItemText(dwIndex, SL_COLUMN_FILEHASH, strTmp);
d204 2
a205 2
	if (IsColumnHidden(SL_COLUMN_FAKECHECK))
		SetItemText(dwIndex, SL_COLUMN_FAKECHECK, _T(""));
d209 1
a209 1
		SetItemText(dwIndex, SL_COLUMN_FAKECHECK, strTmp);
d212 1
a212 1
	SetItemText(dwIndex, SL_COLUMN_FOLDER, pSearchFile->GetSearchFileDir());
d215 1
a215 1
		SetItemText(dwIndex, SL_COLUMN_LENGTH, CastSecondsToHM(dwTmp));
d217 1
a217 1
		SetItemText(dwIndex, SL_COLUMN_LENGTH, _T(""));
d222 1
a222 1
		SetItemText(dwIndex, SL_COLUMN_BITRATE, strTmp);
d225 2
a226 2
		SetItemText(dwIndex, SL_COLUMN_BITRATE, _T(""));
	SetItemText(dwIndex, SL_COLUMN_CODEC, pSearchFile->GetMediaCodec());
d258 1
a258 1
	SetItemText(iIndex, SL_COLUMN_SOURCES, strTmp);
d261 1
a261 1
		SetItemText(iIndex, SL_COLUMN_LASTSEENCOMPLETE, _T(""));	//currently available
d272 1
a272 1
		SetItemText(iIndex, SL_COLUMN_LASTSEENCOMPLETE, strTmp);
d382 1
a382 1
			case SL_COLUMN_FILENAME:
d402 4
a405 4
			case SL_COLUMN_SIZE:
			case SL_COLUMN_SOURCES:
			case SL_COLUMN_LENGTH:
			case SL_COLUMN_BITRATE:
a427 34
void CSearchListCtrl::OnColumnClick(NMHDR *pNMHDR, LRESULT *pResult)
{
	EMULE_TRY

	NM_LISTVIEW	*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);
	int			iFlags = 0, iSubItem = pNMListView->iSubItem;
	bool		bSortOrder = m_bSortAscending[iSubItem];

//	For the double-level sorting columns, toggle the Alt column flag when the arrow is facing up
	if (iSubItem == SL_COLUMN_SOURCES)
	{
		if ((static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem) && bSortOrder)
			m_bSortAscending[SL_NUMCOLUMNS] = !m_bSortAscending[SL_NUMCOLUMNS];
		iFlags = m_bSortAscending[SL_NUMCOLUMNS] ? 0 : MLC_SORTALT;
	}

// Reverse sorting direction for the same column and keep the same if column was changed
	if (static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
		m_bSortAscending[iSubItem] = bSortOrder = !bSortOrder;

	if (iFlags == 0)
		SetSortArrow(iSubItem, bSortOrder);
	else
		SetSortArrow(iSubItem, (bSortOrder) ? arrowDoubleUp : arrowDoubleDown);
	SortItems(SortProc, iSubItem | iFlags | ((bSortOrder) ? MLC_SORTASC : MLC_SORTDESC));

	g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, iSubItem | iFlags);	//allow to save alternate criterion
	g_App.m_pPrefs->SetColumnSortAscending(CPreferences::TABLE_SEARCH, bSortOrder);

	*pResult = 0;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d434 1
a434 1
	if ((iColumn == SL_COLUMN_FILENAME) && (g_App.m_pPrefs->ShowRatingIcons() || g_App.m_pPrefs->ShowFileTypeIcon()))
d466 1
a466 1
			case SL_COLUMN_FILENAME:
d470 1
a470 1
			case SL_COLUMN_SIZE:
d474 1
a474 1
			case SL_COLUMN_SOURCES:
d489 1
a489 1
					iSortCol = SL_COLUMN_FILENAME;
d495 1
a495 1
			case SL_COLUMN_TYPE:
d502 1
a502 1
						iSortCol = SL_COLUMN_FILENAME;
d508 1
a508 1
			case SL_COLUMN_FILEHASH:
d512 1
a512 1
			case SL_COLUMN_FAKECHECK:
d523 1
a523 1
			case SL_COLUMN_LASTSEENCOMPLETE:
d527 1
a527 1
					iSortCol = SL_COLUMN_SOURCES;
d533 1
a533 1
			case SL_COLUMN_FOLDER:
d537 1
a537 1
					iSortCol = SL_COLUMN_FILENAME;
d543 1
a543 1
			case SL_COLUMN_LENGTH:
d551 1
a551 1
			case SL_COLUMN_BITRATE:
d559 1
a559 1
			case SL_COLUMN_CODEC:
@


1.110
log
@Reduced H-file dependency.
@
text
@d408 1
a408 1
		r.right += GetColumnWidth(iCol);
d491 19
@


1.109
log
@Sort by extension as the second criterion while sorting by file type (1: file type, 2: extension, 3: file name) {muleteer};
Sort by file name when sorting by sources doesn't give any difference.
@
text
@a17 2
//	SearchListCtrl.cpp : implementation file

d22 1
a33 2
//	CSearchListCtrl

d398 1
a398 1
	int			iColWidth, iImgIdx, iCol, iNumCols = pHeaderCtrl->GetItemCount();
d408 1
a408 2
		iColWidth = GetColumnWidth(iCol);
		r.right += iColWidth;
@


1.108
log
@rolled back last changes.
@
text
@d535 6
a546 1
					iSortCol = SL_COLUMN_FILENAME;
d548 5
a552 1
					continue;
@


1.107
log
@changed the handlig of embedded GUI list header
@
text
@d76 1
a77 1

a89 2
	InitHeader();

d156 1
d166 1
a166 1
			m_pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d400 2
a401 1
	int			iColWidth, iImgIdx, iCol, iNumCols = m_pHeaderCtrl->GetItemCount();
d408 1
a408 1
		iCol = m_pHeaderCtrl->OrderToIndex(iColIdx);
@


1.106
log
@Optimized string shortcut representation.
@
text
@d76 1
a77 1
	CImageList ilDummyImageList;
d90 2
a157 1
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
d167 1
a167 1
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d401 1
a401 2
	CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
	int			iColWidth, iImgIdx, iCol, iNumCols = pHeaderCtrl->GetItemCount();
d408 1
a408 1
		iCol = pHeaderCtrl->OrderToIndex(iColIdx);
@


1.105
log
@1) renamed GetFakeCheckComment() into GetFakeComment()
2) GetFakeComment() returns the string over parameter
3) removed LastHit interface
@
text
@d654 3
a656 3
	menuED2K.AppendMenu(MF_STRING, MP_GETED2KLINK, GetResString(IDS_DL_LINK1) + GetStringFromShortcutCode(SCUT_LINK, SSP_TAB_PREFIX));
	menuED2K.AppendMenu(MF_STRING, MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2) + GetStringFromShortcutCode(SCUT_LINK_HTML, SSP_TAB_PREFIX));
	menuED2K.AppendMenu(MF_STRING, MP_GETHASH, GetResString(IDS_COPYHASH) + GetStringFromShortcutCode(SCUT_LINK_HASH, SSP_TAB_PREFIX));
@


1.104
log
@removed the set of ODA_SELECT action on item drawing
@
text
@d239 4
a242 1
		SetItemText(dwIndex, SL_COLUMN_FAKECHECK, g_App.m_pFakeCheck->GetFakeCheckComment(strTmp, pSearchFile->GetFileSize()));
d552 7
a558 3
				iCompare = _tcscmp(
					g_App.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile1->GetFileHash()), pSearchFile1->GetFileSize()),
					g_App.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile2->GetFileHash()), pSearchFile2->GetFileSize()) );
d560 1
@


1.103
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d350 1
a350 1
	if((lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
@


1.102
log
@fix time disappearing at midnight
@
text
@d87 1
a87 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auColHdr); ui++)
d90 1
a90 1
	m_imageList.Create(16, 16, g_App.m_iDfltImageListColorFlags | ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
d92 1
a92 1
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ELEMENT_COUNT(s_auIconResID));
d162 1
a162 1
		for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auResTbl); ui++)
d190 1
a190 1
			if (tabItem.lParam == pSearchFile->GetSearchID())
d194 1
a194 1
		if (tabItem.lParam == pSearchFile->GetSearchID())
d445 1
d449 1
a449 1
		dc->FrameRect(&rOutline, &CBrush((GetFocus() == this) ? m_crFocusLine : m_crNoFocusLine));
d469 1
a469 1
		if (((m_dwParamSort & MLC_COLUMNMASK) == iSubItem) && bSortOrder)
d475 1
a475 1
	if ((m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
d611 1
d667 1
@


1.101
log
@Optimized DrawText -- no need recalculate string length.
@
text
@d299 1
a299 1
			strTmp = lastSeenTime.Format();
@


1.100
log
@Reduced #include depedency.
@
text
@d429 1
a429 1
				dc->DrawText(GetItemText(lpDrawItemStruct->itemID, iCol), -1, &r, DT_LEFT | iCalcFlag);
d436 1
a436 1
				dc->DrawText(GetItemText(lpDrawItemStruct->itemID, iCol), -1, &r, DT_RIGHT | iCalcFlag);
@


1.99
log
@Extended related search to send combined requests {lugdunummaster};
Optimized processing of several lists;
Faster exit from copy hash context menu processing.
@
text
@d22 1
@


1.98
log
@tiny optimization
@
text
@d625 1
a625 1
		((iSelectionMark != -1) && (dwSelectedCount == 1) &&
d687 1
a687 2
					str += selectedList.GetHead()->CreateED2kLink();
					selectedList.RemoveHead();
d700 1
a700 2
					str += selectedList.GetHead()->CreateHTMLED2kLink();
					selectedList.RemoveHead();
d718 1
a718 1
				break;
d728 11
d740 4
a743 2
					g_App.m_pSearchList->RemoveResults(selectedList.GetHead());
					selectedList.RemoveHead();
d745 1
a745 1
				SetRedraw(true);
d747 1
a747 1

a754 12

			case MP_SEARCHRELATED:
			//	Just a shortcut for a user typing into the search field "related::[filehash]"
				if (selectedList.GetCount() == 1)
				{
					CSearchFile	*pSearchFile = selectedList.GetHead();
					CString		strSearch(_T("related::"));

					strSearch += HashToString(pSearchFile->GetFileHash());
					g_App.m_pMDlg->m_dlgSearch.DoNewEd2kSearch(strSearch, GetResString(IDS_SEARCH_ANY), 0, 0, 0, _T(""), false, _T(""));
				}
				return true;
@


1.97
log
@Faster sorting by size in the search list.
@
text
@d178 1
a178 1
		CString	strName, strSource;
d180 3
a182 2
		TCHAR	acText[510];
		TCITEM	tabItem;
a185 2
		int	iTabCounter;

@


1.96
log
@Large file size support preparations.
@
text
@d515 1
a515 1
				iCompare = CompareInt64(pSearchFile1->GetIntTagValue(FT_FILESIZE), pSearchFile2->GetIntTagValue(FT_FILESIZE));
@


1.95
log
@Simplified code.
@
text
@d515 1
a515 1
				iCompare = CompareUnsigned(pSearchFile1->GetIntTagValue(FT_FILESIZE), pSearchFile2->GetIntTagValue(FT_FILESIZE));
d754 1
a754 1
					g_App.m_pMDlg->m_dlgSearch.DoNewSearch(strSearch, GetResString(IDS_SEARCH_ANY), 0, 0, 0, _T(""), false, _T(""));
d763 1
a763 1
			g_App.m_pMDlg->m_dlgSearch.DeleteAllSearchs();
@


1.94
log
@UNICODE preparations; optimizations; formattings.
@
text
@a648 2
	int	iURLCnt;

a649 1
	UpdateURLMenu(menuWebServices, &iURLCnt);
d651 1
a651 1
	dwMenuFlags |= ( ( (iURLCnt == 0) ||
@


1.93
log
@Reduced H-file dependency.
@
text
@d649 1
a649 1
	int		iWebServiceCounter;
d652 1
a652 1
	UpdateURLMenu(menuWebServices, iWebServiceCounter);
d654 1
a654 1
	dwMenuFlags |= ( ( (iWebServiceCounter == 0) ||
@


1.92
log
@Corrected line height in the search list {roytam1/DoubleT}.
@
text
@a18 1
//
d25 2
@


1.91
log
@More space for data in the search lists (reduced column margins);
Show file rating received from the server in the search list;
Rewritten drawing of the search list.
@
text
@d75 5
@


1.90
log
@UNICODE preparation (first shot)
@
text
@a17 1

a37 1
	ON_NOTIFY_REFLECT (NM_CUSTOMDRAW, OnCustomdraw)
a46 1
	m_bSetImageList = false;
d66 8
d83 4
d219 1
a219 18
	if (g_App.m_pPrefs->ShowFileTypeIcon())
	{
		int		iImage = g_App.GetFileTypeSystemImageIdx(pSearchFile->GetFileName());

		if (!m_bSetImageList && g_App.GetSystemImageList() != NULL)
		{
		//	ASSERT( GetStyle() & LVS_SHAREIMAGELISTS );
			ApplyImageList(g_App.GetSystemImageList());
			m_bSetImageList = true;
		}
		dwIndex = InsertItem(LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, dwIndex, pSearchFile->GetFileName(), 0, 0, iImage, (LPARAM)pSearchFile);
	}
	else
	{
		ApplyImageList(NULL);
		m_bSetImageList = false;
		dwIndex = InsertItem(LVIF_TEXT | LVIF_PARAM, dwIndex, pSearchFile->GetFileName(), 0, 0, 1, (LPARAM)pSearchFile);
	}
d328 1
a328 1
void CSearchListCtrl::OnCustomdraw(NMHDR *pNMHDR, LRESULT *pResult)
d332 2
a333 3
	NMLVCUSTOMDRAW		*pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>(pNMHDR);

	*pResult = CDRF_DODEFAULT;
d335 24
a358 1
	if (CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage)
d360 9
a368 1
		*pResult = CDRF_NOTIFYITEMDRAW;
d370 1
a370 1
	else if (CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage)
d372 1
a372 4
		COLORREF	crText = ::GetSysColor(COLOR_WINDOWTEXT);
		uint32		dwRed = GetRValue(crText);
		uint32		dwGreen = GetGValue(crText);
		uint32		dwBlue = GetGValue(crText);
d374 2
a375 9
		CSearchFile		*pSearchFile = reinterpret_cast<CSearchFile*>(pLVCD->nmcd.lItemlParam);

		if (pSearchFile == NULL)
			return ;

		CKnownFile		*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pSearchFile->GetFileHash());

	//	If it's not a completed shared file, check to see if it's a part file
		if (pKnownFile == NULL)
d377 3
a379 1
			pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pSearchFile->GetFileHash());
d381 1
a381 1
		if (pKnownFile != NULL)
d383 3
a385 12
		//	Currently downloading (-> red)
			if (pKnownFile->IsPartFile())
			{
				dwRed = (pSearchFile->GetSourceCount() + 4) * 20;
				if (dwRed > 255)
					dwRed = 255;
			}
			else
			{
			//	Already downloaded and currently shared (-> green)
				dwGreen = 128;
			}
d387 18
a404 1
		else
d406 3
a408 14
			pKnownFile = g_App.m_pKnownFilesList->FindKnownFileByID(pSearchFile->GetFileHash());

		//	Known but currently not shared (-> Orange)
			if  (pKnownFile != NULL)
			{
				dwRed = 255;
				dwGreen = 165;
				dwBlue = 0;
			}
		//	Not known at all (-> indicate availability in shades of blue)
			else
			{
				dwBlue = (pSearchFile->GetSourceCount() == 0) ? 0 : ((pSearchFile->GetSourceCount() - 1) * 20);
				if (dwBlue > 255)
d410 11
a420 1
					dwBlue = 255;
d422 10
a431 1
			}
d433 6
a438 1
		pLVCD->clrText = RGB(dwRed, dwGreen , dwBlue);
d440 3
a442 1
		*pResult = CDRF_DODEFAULT;
d444 4
@


1.89
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d138 1
a138 1
	if (GetSafeHwnd())
d149 1
a149 1
			hdi.pszText = (LPSTR)strRes.GetString();
d163 4
a166 5
		CString		strName, strSource;
		int			j;
		TCHAR		tstrText[510];

		TCITEM		tabItem;
d170 1
a170 1
		int		iTabCounter;
d181 2
a182 2
			tabItem.pszText = tstrText;
			tabItem.cchTextMax = sizeof(tstrText);
d186 1
a186 1
			strName = tstrText;
@


1.88
log
@renamed 3 variables
@
text
@d81 2
a82 2
	if (g_App.g_pPrefs->DoUseSort())
		SortInit(g_App.g_pPrefs->GetSearchSortCol());
d85 1
a85 1
		int		iSortCode = g_App.g_pPrefs->GetColumnSortItem(CPreferences::TABLE_SEARCH);
d87 1
a87 1
		iSortCode |= g_App.g_pPrefs->GetColumnSortAscending(CPreferences::TABLE_SEARCH) ? MLC_SORTASC : MLC_SORTDESC;
d211 1
a211 1
	if (g_App.g_pPrefs->ShowFileTypeIcon())
d437 2
a438 2
	g_App.g_pPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, iSubItem | iFlags);	//allow to save alternate criterion
	g_App.g_pPrefs->SetColumnSortAscending(CPreferences::TABLE_SEARCH, bSortOrder);
d587 1
a587 1
		(g_App.g_pPrefs->StartDownloadPaused()) ? MP_RESUMEPAUSED : MP_RESUME );
d738 1
a738 1
			if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK))
d740 1
a740 1
			else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK_HTML))
d742 1
a742 1
			else if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK_HASH))
@


1.87
log
@Modified preparation of the server search request packet to make it clearer.
@
text
@d81 2
a82 2
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())
		SortInit(g_eMuleApp.m_pGlobPrefs->GetSearchSortCol());
d85 1
a85 1
		int		iSortCode = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_SEARCH);
d87 1
a87 1
		iSortCode |= g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_SEARCH) ? MLC_SORTASC : MLC_SORTDESC;
d160 1
a160 1
	if (g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.GetItemCount() > 0)
d173 1
a173 1
		for (iTabCounter = 0; iTabCounter < g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.GetItemCount(); iTabCounter++)
d175 1
a175 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.GetItem(iTabCounter, &tabItem);
d185 1
a185 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.GetItem(iTabCounter, &tabItem);
d190 1
a190 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.GetItem(iTabCounter, &tabItem);
d201 1
a201 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.SetItem(iTabCounter, &tabItem);
d211 1
a211 1
	if (g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
d213 1
a213 1
		int		iImage = g_eMuleApp.GetFileTypeSystemImageIdx(pSearchFile->GetFileName());
d215 1
a215 1
		if (!m_bSetImageList && g_eMuleApp.GetSystemImageList() != NULL)
d218 1
a218 1
			ApplyImageList(g_eMuleApp.GetSystemImageList());
d242 1
a242 1
		SetItemText(dwIndex, SL_COLUMN_FAKECHECK, g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(strTmp, pSearchFile->GetFileSize()));
d361 1
a361 1
		CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pSearchFile->GetFileHash());
d366 1
a366 1
			pKnownFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pSearchFile->GetFileHash());
d385 1
a385 1
			pKnownFile = g_eMuleApp.m_pKnownFilesList->FindKnownFileByID(pSearchFile->GetFileHash());
d437 2
a438 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, iSubItem | iFlags);	//allow to save alternate criterion
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SEARCH, bSortOrder);
d503 2
a504 2
					g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile1->GetFileHash()), pSearchFile1->GetFileSize()),
					g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile2->GetFileHash()), pSearchFile2->GetFileSize()) );
d581 2
a582 2
		g_eMuleApp.m_pServerConnect->IsConnected() &&
		((pCurServer = g_eMuleApp.m_pServerConnect->GetCurrentServer()) != NULL) &&
d587 1
a587 1
		(g_eMuleApp.m_pGlobPrefs->StartDownloadPaused()) ? MP_RESUMEPAUSED : MP_RESUME );
d592 1
a592 1
	dwFlags2 = MF_STRING | ((g_eMuleApp.m_pdlgEmule->m_dlgSearch.m_ctlSearchTabs.GetItemCount() > 0) ? MF_ENABLED : MF_GRAYED);
d650 1
a650 1
				g_eMuleApp.CopyTextToClipboard(str);
d664 1
a664 1
				g_eMuleApp.CopyTextToClipboard(str);
d677 1
a677 1
				g_eMuleApp.CopyTextToClipboard(str);
d682 1
a682 1
				g_eMuleApp.m_pdlgEmule->m_dlgSearch.DownloadSelected(wParam == MP_RESUMEPAUSED);
d689 1
a689 1
					g_eMuleApp.m_pSearchList->RemoveResults(selectedList.GetHead());
d698 1
a698 1
					RunURL(selectedList.GetHead(), g_eMuleApp.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
d711 1
a711 1
					g_eMuleApp.m_pdlgEmule->m_dlgSearch.DoNewSearch(strSearch, GetResString(IDS_SEARCH_ANY), 0, 0, 0, _T(""), false, _T(""));
d720 1
a720 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.DeleteAllSearchs();
d738 1
a738 1
			if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK))
d740 1
a740 1
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK_HTML))
d742 1
a742 1
			else if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK_HASH))
@


1.86
log
@Copy file hash to clipboard (context menu and shortcut) {DoubleT}.
@
text
@d711 1
a711 1
					g_eMuleApp.m_pdlgEmule->m_dlgSearch.DoNewSearch(strSearch, GetResString(IDS_SEARCH_ANY), 0, 0, -1, _T(""), false, _T(""));
@


1.85
log
@Separate GetFileTypeString for search type;
Faster sorting compare for file type columns.
@
text
@d600 1
d667 13
d742 2
@


1.84
log
@Added Related File Search.
@
text
@d235 1
a235 1
	SetItemText(dwIndex, SL_COLUMN_TYPE, pSearchFile->GetFileTypeString(true));
d488 1
a488 2
				//	As all types are predefined it's safe to use case sensitive compare to speed up
				iCompare = _tcscmp(pSearchFile1->GetFileTypeString(true), pSearchFile2->GetFileTypeString(true));
@


1.83
log
@Removed useless search list context menu 'Remove this Searchresult'.
@
text
@d573 1
d580 6
d689 12
@


1.82
log
@Faster processing of commands for search list;
Fixed 'Clear All' & 'Remove this Searchresult' context menus which were disabled without selection.
@
text
@a586 1
	menuSearchFile.AppendMenu(dwFlags2, MP_REMOVE, GetResString(IDS_REMOVESEARCHSTRING));
a686 4
		case MP_REMOVE:
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.DeleteSearch(m_dwResultsID);
			break;

@


1.81
log
@ED2K link shortcuts for Server and Search lists;
Some Unicode corrections; Removed unrequired list cleanups.
@
text
@d574 1
a574 1
	UINT		dwSelectedCount = GetSelectedCount();
d586 3
a588 2
	menuSearchFile.AppendMenu(dwMenuFlags, MP_REMOVE, GetResString(IDS_REMOVESEARCHSTRING));
	menuSearchFile.AppendMenu(dwMenuFlags, MP_REMOVEALL, GetResString(IDS_REMOVEALLSEARCH));
d618 6
a623 1
	if (GetSelectionMark() != -1)
d625 3
a627 17
		CSearchFile		*pSearchFile = reinterpret_cast<CSearchFile*>(GetItemData(GetSelectionMark()));

		if (wParam >= MP_WEBURL && wParam <= MP_WEBURL + 64)
		{
			RunURL(pSearchFile, g_eMuleApp.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
		}
	//	For multiple selections
		UINT		dwNumSelectedFiles = GetSelectedCount();
		CTypedPtrList<CPtrList, CSearchFile*> selectedList;
		int			iIndex;
		POSITION	pos = GetFirstSelectedItemPosition();

		while (pos != NULL)
		{
			if ((iIndex = GetNextSelectedItem(pos)) >= 0)
				selectedList.AddTail(reinterpret_cast<CSearchFile*>(GetItemData(iIndex)));
		}
d629 2
d645 1
a645 1
				break;
d659 1
a659 1
				break;
d664 1
a664 5
				break;

			case MP_REMOVEALL:
				g_eMuleApp.m_pdlgEmule->m_dlgSearch.DeleteAllSearchs();
				break;
d674 8
d685 1
a688 1
		{
d691 4
a694 1
		}
@


1.80
log
@Show media information (length, bitrate and codec) for search results.
@
text
@d592 2
a593 2
	menuED2K.AppendMenu(MF_STRING, MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
	menuED2K.AppendMenu(MF_STRING, MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
d617 1
a617 1
	if (GetSelectionMark() != ( -1))
a626 1

d628 1
a628 2

		int			iIndex = -1;
d633 1
a633 3
			iIndex = GetNextSelectedItem(pos);
			if (iIndex > -1)
			{
a634 1
			}
d648 1
a648 1
						str += "\r\n";
d662 1
a662 1
						str += "\r\n";
a668 1
			{
d671 1
a671 1
			}
a672 1
			{
d675 1
a675 1
			}
a676 1
			{
a684 1
			}
a685 1
		selectedList.RemoveAll();
d699 27
@


1.79
log
@Optimized search list sorting;
Faster sorting compare for fake and type columns;
Added Filename sorting criterion when items in Folder column are equal;
Preparations to show media information.
@
text
@d65 3
a67 3
		{ LVCFMT_RIGHT,  65 },	//SL_COLUMN_LENGTH
		{ LVCFMT_RIGHT,  65 },	//SL_COLUMN_BITRATE
		{ LVCFMT_LEFT,   65 }	//SL_COLUMN_CODEC
d209 1
a209 1
	uint32		dwIndex = GetItemCount();
d246 14
d454 1
d527 27
@


1.78
log
@Faster sorting by file name.
@
text
@d64 4
a67 1
		{ LVCFMT_LEFT,  150 }	//SL_COLUMN_FOLDER
d132 4
a135 1
		IDS_SF_FOLDER
d445 1
a445 1
	switch (iSortCol)
d447 1
a447 1
		case SL_COLUMN_FILENAME:
d449 26
a474 13
			iCompare = pSearchFile1->CmpFileNames(pSearchFile2->GetFileName());
			break;
		}
		case SL_COLUMN_SIZE:
		{
			iCompare = CompareUnsigned(pSearchFile1->GetIntTagValue(FT_FILESIZE), pSearchFile2->GetIntTagValue(FT_FILESIZE));
			break;
		}
		case SL_COLUMN_SOURCES:
		{
			if (iSortAltFlag == 0)
			{
				iCompare = pSearchFile1->GetSourceCount() - pSearchFile2->GetSourceCount();
d476 19
a494 5
					iCompare = pSearchFile1->GetCompleteSourceCount() - pSearchFile2->GetCompleteSourceCount();
			}
			else
			{
				iCompare = pSearchFile1->GetCompleteSourceCount() - pSearchFile2->GetCompleteSourceCount();
d496 6
a501 23
					iCompare = pSearchFile1->GetSourceCount() - pSearchFile2->GetSourceCount();
			}
			break;
		}
		case SL_COLUMN_TYPE:
		{
			iCompare = _tcsicmp(pSearchFile1->GetFileTypeString(true), pSearchFile2->GetFileTypeString(true));
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2, SL_COLUMN_FILENAME);
				iSortMod = 1;		//sort always in ascending order
			}
			break;
		}
		case SL_COLUMN_FILEHASH:
		{
			iCompare = memcmp(pSearchFile1->GetFileHash(), pSearchFile2->GetFileHash(), 16);
			break;
		}
		case SL_COLUMN_FAKECHECK:
		{
			CString	strFake1 = g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile1->GetFileHash()), pSearchFile1->GetFileSize());
			CString	strFake2 = g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile2->GetFileHash()), pSearchFile2->GetFileSize());
d503 9
a511 19
			iCompare = ((strFake1 > strFake2) ? 1 : ((strFake1 < strFake2) ? -1 : 0));
			break;
		}
		case SL_COLUMN_LASTSEENCOMPLETE:
			iCompare = pSearchFile1->GetLastSeenCompleteValue() - pSearchFile2->GetLastSeenCompleteValue();
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1, lParam2, SL_COLUMN_SOURCES);
				iSortMod = -1;		//in descending order
			}
			break;
		case SL_COLUMN_FOLDER:
		{
			iCompare = _tcsicmp(pSearchFile1->GetSearchFileDir(), pSearchFile2->GetSearchFileDir()) ;
			break;
		}
		default:
		{
			return 0;
d513 1
@


1.77
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d443 1
a443 1
			iCompare = _tcsicmp(pSearchFile1->GetFileName(), pSearchFile2->GetFileName()) ;
@


1.76
log
@Added 'Folder' column to Search window (shows the location of the remote client's files).
@
text
@d177 1
a177 1
			tabItem.cchTextMax = 510;
d181 1
a181 1
			strName.Format(_T("%s"), tstrText);
d377 1
a377 1
				dwBlue = (pSearchFile->GetSourceCount() - 1) * 20;
@


1.75
log
@Search list sorting by Complete Sources; Removed some non-required code.
@
text
@d63 2
a64 1
		{ LVCFMT_LEFT,  130 }	//SL_COLUMN_LASTSEENCOMPLETE
d128 2
a129 1
		IDS_LASTSEENCOMPLETE
d238 2
d498 5
@


1.74
log
@Renamed resource strings tags for better meaning.
@
text
@d74 2
a75 1
	memzero(&m_bSortAscending, sizeof(m_bSortAscending));
a77 2
	{
		m_dwLastSortCode = g_eMuleApp.m_pGlobPrefs->GetSearchSortCol();
a78 1
	}
a83 1
		m_dwLastSortCode = iSortCode;
d94 6
a99 4
//	Get the sort column
	int	iSortColumn = (iSortCode & MLC_COLUMNMASK);
//	Get the sort order
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
d101 13
a113 1
	SetSortArrow(iSortColumn, bSortAscending);
a114 1
	m_bSortAscending[iSortColumn] = bSortAscending;
d255 1
a255 1
		SortInit(m_dwLastSortCode);
d392 1
a392 1
	int			iSubItem = pNMListView->iSubItem;
d395 8
d407 7
a413 4
	SetSortArrow(iSubItem, bSortOrder);
	m_dwLastSortCode = iSubItem | ((bSortOrder) ? MLC_SORTASC : MLC_SORTDESC);
	SortItems(SortProc, m_dwLastSortCode);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, iSubItem);
a426 1
	//eklmn: don't sort
d430 4
a433 3
	int				iCompare = 0;
	int				iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 1 : -1;
	int				iSortCol = lParamSort & MLC_COLUMNMASK;
d449 12
a460 1
			iCompare = pSearchFile1->GetSourceCount() - pSearchFile2->GetSourceCount();
@


1.73
log
@Last Seen Complete was added to search results;
Unified way to update changing columns; Improved string processing.
@
text
@d487 2
a488 2
	menuSearchFile.AppendMenu(dwMenuFlags, MP_RESUME, GetResString(IDS_DOWNLOAD));
	menuSearchFile.AppendMenu(dwMenuFlags, MP_RESUMEPAUSED, GetResString(IDS_DOWNLOAD) + _T(" (") + GetResString(IDS_PAUSED) + _T(")"));
@


1.72
log
@Unified GUI strings for "file hash" (removed duplicate,
new full form is "File Hash" instead of "FileID").
@
text
@d62 2
a63 1
		{ LVCFMT_LEFT,  220 }	//SL_COLUMN_FAKECHECK
d116 2
a117 1
		IDS_FAKE_CHECK_HEADER
a140 10
	CString		strNumSources;
	uint32		dwFileSize = pSearchFile->GetIntTagValue(FT_FILESIZE);
	uint32		dwNumSources = pSearchFile->GetIntTagValue(FT_SOURCES);
	uint32		dwCompleteSources = pSearchFile->GetIntTagValue(FT_COMPLETE_SOURCES);

	if (dwFileSize <= PARTSIZE)
	{
		dwCompleteSources = dwNumSources;
	}

d189 1
a189 1
		return ;
d212 3
a214 1
	strNumSources.Format(_T("%u (%u)"),dwNumSources, dwCompleteSources);
d216 4
a219 4
	SetItemText(dwIndex, 1, CastItoXBytes(dwFileSize));
	SetItemText(dwIndex, 2, strNumSources);
	SetItemText(dwIndex, 3, pSearchFile->GetFileTypeString(true));
	SetItemText(dwIndex, 4, HashToString(pSearchFile->GetFileHash()));
d222 1
a222 1
        SetItemText(dwIndex, 5, _T(""));
d224 1
a224 1
        SetItemText(dwIndex, 5, g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile->GetFileHash()), pSearchFile->GetFileSize()));
d229 1
a229 1
void CSearchListCtrl::UpdateSources(CSearchFile *pSearchFile)
d242 1
a242 4
		CString		strNumSources;

		strNumSources.Format(_T("%u(%u)"), pSearchFile->GetSourceCount(), pSearchFile->GetCompleteSourceCount());
		SetItemText(iIndex, 2, strNumSources);
d244 1
a244 1
		RedrawItems(iIndex, iIndex); // Lord KiRon
d250 24
d428 1
a428 1
			iCompare = pSearchFile1->GetIntTagValue(FT_SOURCES) - pSearchFile2->GetIntTagValue(FT_SOURCES);
d437 1
a437 1
				iSortMod = 1;		//eklmn: sort allways in ascending order
d454 8
@


1.71
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d114 1
a114 1
		IDS_FILEID,
@


1.70
log
@Unified list column creature;
Set list column labels only in one place to avoid future incorrections.
@
text
@d224 1
a224 1
	SetItemText(dwIndex, 3, pSearchFile->GetFileType(true));
d418 1
a418 1
			iCompare = _tcsicmp(pSearchFile1->GetFileType(true), pSearchFile2->GetFileType(true));
@


1.69
log
@Faster list header localizations.
@
text
@d26 1
a26 1
#include "fakecheck.h" //FakeCheck
d55 10
d70 2
a71 6
	InsertColumn(SL_COLUMN_FILENAME, GetResString(IDS_DL_FILENAME), LVCFMT_LEFT, 250, 1);
	InsertColumn(SL_COLUMN_SIZE, GetResString(IDS_DL_SIZE), LVCFMT_RIGHT, 100, 2);
	InsertColumn(SL_COLUMN_SOURCES, GetResString(IDS_DL_SOURCES), LVCFMT_RIGHT, 50, 3);
	InsertColumn(SL_COLUMN_TYPE, GetResString(IDS_TYPE), LVCFMT_LEFT, 65, 4);
	InsertColumn(SL_COLUMN_FILEHASH, GetResString(IDS_FILEID), LVCFMT_LEFT, 220, 5);
	InsertColumn(SL_COLUMN_FAKECHECK, GetResString(IDS_FAKE_CHECK_HEADER), LVCFMT_LEFT, 220); //FakeCheck
@


1.68
log
@Fixed list sorting direction while switching <thanks xrmb>;
Removed unrequired class member.
@
text
@d102 10
d114 3
a116 2
		CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
		HDITEM			hdi;
d120 6
a125 32
		CString			strRes;

		strRes = GetResString(IDS_DL_FILENAME);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(0, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_SIZE);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(1, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DL_SOURCES);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(2, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_TYPE);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(3, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_FILEID);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(4, &hdi);
		strRes.ReleaseBuffer();

	//	FakeCheck
		strRes = GetResString(IDS_FAKE_CHECK_HEADER);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(5, &hdi);
		strRes.ReleaseBuffer();
d461 2
a462 8
	if (!g_eMuleApp.m_pGlobPrefs->StartDownloadPaused())
	{
		menuSearchFile.SetDefaultItem(MP_RESUME);
	}
	else
	{
		menuSearchFile.SetDefaultItem(MP_RESUMEPAUSED);
	}
@


1.67
log
@updated code to follow meaning of the ContextMenu :
now even with Donwload paused option enabled using "download" and not "download (paused)" will start the download unpaused !
@
text
@a46 1
	memzero(&m_bSortAscending, 6);
d67 1
a67 4
	for (int i = 0; i < SL_NUMCOLUMNS; i++)
	{
		m_bSortAscending[i] = true;
	}
d71 2
a72 2
		m_dwLastSortCode= g_eMuleApp.m_pGlobPrefs->GetSearchSortCol();
		SortInit(g_eMuleApp.m_pGlobPrefs->GetSearchSortCol()); //Cax2 sortdlg
d76 1
a76 2
		m_iSortColumn = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_SEARCH);
		m_bSortAscending[m_iSortColumn] = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_SEARCH);
d78 3
a80 2
		m_dwLastSortCode = m_iSortColumn | (m_bSortAscending[m_iSortColumn] ? MLC_SORTASC : MLC_SORTDESC);
		SortInit(m_dwLastSortCode);
d96 1
a96 1
	SortItems(&SortProc, iSortCode);
d375 13
a387 11
	NM_LISTVIEW		*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);

//	If it's a second click on the same column then reverse the sort order,
//	otherwise sort the new column in ascending order.
	m_iSortColumn = pNMListView->iSubItem;
	m_bSortAscending[m_iSortColumn] = !m_bSortAscending[m_iSortColumn];
	SetSortArrow(m_iSortColumn, m_bSortAscending[m_iSortColumn]);
	m_dwLastSortCode = m_iSortColumn | (m_bSortAscending[m_iSortColumn] ? MLC_SORTASC : MLC_SORTDESC);
	SortItems(&SortProc, m_dwLastSortCode);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, m_iSortColumn);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SEARCH, m_bSortAscending[m_iSortColumn]);
@


1.66
log
@Don't check FakeCheck database if column is disabled (speed up the search)
@
text
@d477 9
a485 1
	menuSearchFile.SetDefaultItem(MP_RESUME);
d579 1
a579 1
				g_eMuleApp.m_pdlgEmule->m_dlgSearch.DownloadSelected(wParam==MP_RESUMEPAUSED);
@


1.65
log
@Find in lists
@
text
@d239 6
a244 1
	SetItemText(dwIndex, 5, g_eMuleApp.m_pFakeCheck->GetFakeCheckComment(HashToString(pSearchFile->GetFileHash()), pSearchFile->GetFileSize())); //FakeCheck
@


1.64
log
@added 'Download (Paused)' to Searchlist context menu
@
text
@d50 2
a51 1
	m_bSetImageList = false; // katsyonak 05/08/2003
@


1.63
log
@always show files smaller than or equal to a PARTSIZE as complete in search results
@
text
@d470 1
d562 1
d565 1
a565 1
				g_eMuleApp.m_pdlgEmule->m_dlgSearch.OnBnClickedSdownload();
@


1.62
log
@Some string processing improvements (thx Aw3)
@
text
@d156 5
@


1.61
log
@Fixes for Search "xxx (x)" and WebServer progress bar. :P
@
text
@d191 1
a191 1
			j = strName.ReverseFind( '(' );
d193 1
a193 1
				strName = strName.Left(j - 1);
@


1.60
log
@Improved string processing
@
text
@d227 1
a227 1
	strNumSources.Format(_T("%u(%u)"),dwNumSources, dwCompleteSources);
@


1.59
log
@feature: show number of complete files by search (untested)
@
text
@a241 1
	CString			strNumSources;
d250 2
@


1.58
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d151 1
d154 1
d227 1
a227 1
	TCHAR		tstrBuffer[50];
d230 1
a230 2
	_itot(dwNumSources, tstrBuffer, 10);
	SetItemText(dwIndex, 2, tstrBuffer);
d242 1
d251 2
a252 4
		TCHAR		strBuffer[50];

		_itot(pSearchFile->GetSourceCount(), strBuffer, 10);
		SetItemText(iIndex, 2, strBuffer);
@


1.57
log
@improved fakelist download, and added fakes.rar file support
@
text
@d489 1
a489 1
	menuSearchFile.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.56
log
@Changed confusing color in search (shades of blue are used for availability)
@
text
@d232 1
a232 1
	SetItemText(dwIndex, 5, g_eMuleApp.m_pFakeCheck->IsFake(HashToString(pSearchFile->GetFileHash()), pSearchFile->GetFileSize())); //FakeCheck
d432 2
a433 2
			CString	strFake1 = g_eMuleApp.m_pFakeCheck->IsFake(HashToString(pSearchFile1->GetFileHash()), pSearchFile1->GetFileSize());
			CString	strFake2 = g_eMuleApp.m_pFakeCheck->IsFake(HashToString(pSearchFile2->GetFileHash()), pSearchFile2->GetFileSize());
@


1.55
log
@Improved context menu creation;
Multiple link copy to clipboard is more compatible.
@
text
@d339 1
a339 1
		//	Known but currently not shared (-> sky blue)
d342 3
a344 2
				dwGreen = 204;
				dwBlue = 255;
@


1.54
log
@Improved hash to string conversion
@
text
@a451 2
	UINT		dwMenuFlags = (GetSelectionMark() != (-1) && GetSelectedCount() > 0) ? MF_ENABLED : MF_GRAYED;

d453 1
a453 1
	CMenu		menuED2K;
d458 5
a462 2
	menuSearchFile.AppendMenu(MF_STRING, MP_RESUME, GetResString(IDS_DOWNLOAD));
	menuSearchFile.EnableMenuItem(MP_RESUME, dwMenuFlags);
d467 3
a469 6
	menuSearchFile.AppendMenu(MF_STRING, MP_REMOVESELECTED, GetResString(IDS_REMOVESELECTED));
	menuSearchFile.EnableMenuItem(MP_REMOVESELECTED, dwMenuFlags);
	menuSearchFile.AppendMenu(MF_STRING, MP_REMOVE, GetResString(IDS_REMOVESEARCHSTRING));
	menuSearchFile.EnableMenuItem(MP_REMOVE, dwMenuFlags);
	menuSearchFile.AppendMenu(MF_STRING, MP_REMOVEALL, GetResString(IDS_REMOVEALLSEARCH));
	menuSearchFile.EnableMenuItem(MP_REMOVEALL, dwMenuFlags);
d476 1
a476 2
	menuSearchFile.AppendMenu(MF_STRING | MF_POPUP, (UINT_PTR)menuED2K.m_hMenu, GetResString(IDS_ED2KLINKFIX));
	menuSearchFile.EnableMenuItem((UINT_PTR)menuED2K.m_hMenu, dwMenuFlags);
a478 1
	CMenu	menuWebServices;
d483 2
a484 1
	UINT		dwMenuFlags2;
d486 1
a486 1
	dwMenuFlags2 = (iWebServiceCounter == 0) ? MF_GRAYED : MF_STRING;
d488 1
a488 4
	menuSearchFile.AppendMenu(dwMenuFlags2 | MF_POPUP, (UINT_PTR)menuWebServices.m_hMenu, GetResString(IDS_WEBSERVICES));
	menuSearchFile.EnableMenuItem((UINT_PTR)menuWebServices.m_hMenu, dwMenuFlags);
	if (GetSelectionMark() != ( -1) && GetSelectedCount() > 1)
		menuSearchFile.EnableMenuItem((UINT_PTR)menuWebServices.m_hMenu, MF_GRAYED);
d490 1
a490 3
	menuSearchFile.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
	menuWebServices.DestroyMenu();
	menuSearchFile.DestroyMenu();
d535 1
a535 1
						str += "\n";
d549 1
a549 1
						str += "\n";
@


1.53
log
@Improved hash to string conversion
@
text
@d232 1
a232 1
	SetItemText(dwIndex, 5, g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(pSearchFile->GetFileHash(), 16), pSearchFile->GetFileSize())); //FakeCheck
d431 2
a432 2
			CString	strFake1 = g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(pSearchFile1->GetFileHash(), 16), pSearchFile1->GetFileSize());
			CString	strFake2 = g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(pSearchFile2->GetFileHash(), 16), pSearchFile2->GetFileSize());
@


1.52
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d231 1
a231 1
	SetItemText(dwIndex, 4, FileHashToString(pSearchFile->GetFileHash()));
@


1.51
log
@formating
@
text
@d47 1
a47 1
	memset2(&m_bSortAscending, 0, 6);
@


1.50
log
@BUGFIX: proper display of auto priorized Jumpstart files + FEATURE: display known unshared files in different color (in Search window)
@
text
@d348 2
a349 2
			dwBlue = (pSearchFile->GetSourceCount() - 1) * 20;
			if (dwBlue > 255)
d351 2
a352 2
				dwBlue = 255;
		}
@


1.49
log
@optimisation of the file processing + some formatting, comments and deletions of spaces and tabs at end of lines
@
text
@d317 1
d319 1
a319 1

d322 1
a324 1
			//	Already downloading
d331 1
a331 1
			//	Already downloaded
d337 11
d350 1
d353 2
a354 1

@


1.48
log
@Fixed complete icon/Fixed search sorting
@
text
@d375 1
a375 1
	//eklmn: don't sort 
@


1.47
log
@File Type correction & related name changes
@
text
@d392 1
a392 1
			iCompare = pSearchFile1->GetIntTagValue(FT_FILESIZE) - pSearchFile2->GetIntTagValue(FT_FILESIZE);
@


1.46
log
@1) sorting updated
2) double-click issue
@
text
@d230 1
a230 1
	SetItemText(dwIndex, 3, GetFiletypeByName(pSearchFile->GetFileName()));
d402 1
a402 3
			CString strFileType1 = GetFiletypeByName(pSearchFile1->GetFileName());
			CString strFileType2 = GetFiletypeByName(pSearchFile2->GetFileName());
			iCompare = _tcsicmp(strFileType1, strFileType2);
@


1.45
log
@Fix for sorting in search window by selected sorting preferences
@
text
@d93 4
a96 1
	int		iCurrentSortItem = (iSortCode & MLC_SORTDESC) == 0 ? iSortCode : iSortCode - MLC_SORTDESC;
d98 1
a98 1
	SetSortArrow(iCurrentSortItem, (iSortCode & MLC_SORTDESC) == 0);
d100 1
d374 6
d387 2
a388 1
			return _tcsicmp(pSearchFile1->GetFileName(), pSearchFile2->GetFileName()) * iSortMod;
d392 2
a393 1
			return ((pSearchFile1->GetIntTagValue(FT_FILESIZE) > pSearchFile2->GetIntTagValue(FT_FILESIZE)) ? 1 : -1) * iSortMod;
d397 2
a398 1
			return (pSearchFile1->GetIntTagValue(FT_SOURCES) - pSearchFile2->GetIntTagValue(FT_SOURCES)) * iSortMod;
d402 9
a410 1
			return GetFiletypeByName(pSearchFile1->GetFileName()).Compare(GetFiletypeByName(pSearchFile2->GetFileName())) * iSortMod;
d414 2
a415 1
			return memcmp(pSearchFile1->GetFileHash(), pSearchFile2->GetFileHash(), 16) * iSortMod;
d419 2
a420 2
			CString		strFake1 = g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(pSearchFile1->GetFileHash(), 16), pSearchFile1->GetFileSize());
			CString		strFake2 = g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(pSearchFile2->GetFileHash(), 16), pSearchFile2->GetFileSize());
d422 2
a423 1
			return ((strFake1 > strFake2) ? 1 : ((strFake1 < strFake2) ? -1 : 0)) * iSortMod;
d430 2
@


1.44
log
@Formatting, comments, and name changes.
Fixed a couple of sorting related bugs in SearchListCtrl.
@
text
@d74 1
@


1.43
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d37 8
d48 2
a49 2
	m_pSearchList = 0;  // i_a
	m_nResultsID = 0; // i_a
d52 2
a53 2

void CSearchListCtrl::Init(CSearchList* in_searchlist)
a56 1
	m_pSearchList = in_searchlist;
d58 8
a65 6
	InsertColumn(0, GetResString(IDS_DL_FILENAME), LVCFMT_LEFT, 250, 1);
	InsertColumn(1, GetResString(IDS_DL_SIZE), LVCFMT_RIGHT, 100, 2);
	InsertColumn(2, GetResString(IDS_DL_SOURCES), LVCFMT_RIGHT, 50, 3);
	InsertColumn(3, GetResString(IDS_TYPE), LVCFMT_LEFT, 65, 4);
	InsertColumn(4, GetResString(IDS_FILEID), LVCFMT_LEFT, 220, 5);
	InsertColumn(5, GetResString(IDS_FAKE_CHECK_HEADER), LVCFMT_LEFT, 220); //FakeCheck
d67 4
a70 2
	m_bSortAscending[2] = true;
	m_bSortAscending[3] = true;
d73 1
d75 1
d77 7
a83 1
		SortInit(2+MLC_SORTDESC);
d85 1
a85 1

d89 4
d94 2
a95 5
void CSearchListCtrl::SortInit(int sortCode)
{
	int iCurrentSortItem = (sortCode & MLC_SORTDESC) == 0 ? sortCode : sortCode - MLC_SORTDESC;
	SetSortArrow(iCurrentSortItem, (sortCode & MLC_SORTDESC) == 0);
	SortItems(&SortProc, sortCode);
d97 1
a97 1

d102 3
a104 2
		CHeaderCtrl * pHeaderCtrl = GetHeaderCtrl();
		HDITEM hdi;
d106 2
a107 1
		CString strRes;
d141 4
d146 10
a155 5
BEGIN_MESSAGE_MAP(CSearchListCtrl, CMuleListCtrl)
	ON_NOTIFY_REFLECT (NM_CUSTOMDRAW, OnCustomdraw)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()
d157 1
a157 1
//	CSearchListCtrl message handlers
d159 1
a159 11
void CSearchListCtrl::AddResult(CSearchFile* toshow)
{
	EMULE_TRY
	uint32 filesize = toshow->GetIntTagValue(FT_FILESIZE);
	uint32 nSources = toshow->GetIntTagValue(FT_SOURCES);
	if (g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItemCount() > 0)
	{
	//	update tab-counter for the given searchfile
		CString csName, sourceStr;
		int j;
		TCHAR szText[510];
d161 1
a161 2
		TCITEM tabitem;
		tabitem.mask = TCIF_PARAM;
d163 1
a163 2
		int tabCounter;
		for (tabCounter = 0; tabCounter < g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItemCount();tabCounter++)
d165 2
a166 2
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItem(tabCounter, &tabitem);
			if (tabitem.lParam == toshow->GetSearchID())
d170 1
a170 1
		if (tabitem.lParam == toshow->GetSearchID())
d172 4
a175 4
			tabitem.pszText = szText;
			tabitem.cchTextMax = 510;
			tabitem.mask = TCIF_TEXT;
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItem(tabCounter, &tabitem);
d177 1
a177 1
			csName.Format(_T("%s"), szText);
d179 2
a180 2
			tabitem.mask = TCIF_PARAM;
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItem(tabCounter, &tabitem);
d182 1
a182 1
			sourceStr.Format(_T(" (%u)"), m_pSearchList->GetFoundFiles(toshow->GetSearchID()));
d184 1
a184 1
			j = csName.ReverseFind( '(' );
d186 2
a187 2
				csName = csName.Left(j - 1);
			csName.Append(sourceStr);
d189 4
a192 4
			tabitem.mask = TCIF_TEXT;
			tabitem.pszText = csName.LockBuffer();
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.SetItem(tabCounter, &tabitem);
			csName.UnlockBuffer();
d196 2
d199 1
a199 2
	if (toshow->GetSearchID() != m_nResultsID)
		return ;
a200 2
	uint32 itemnr = GetItemCount();
//	katsyonak 05/08/2003 Start
d203 2
a204 1
		int iImage = g_eMuleApp.GetFileTypeSystemImageIdx(toshow->GetFileName());
d211 1
a211 1
		itemnr = InsertItem(LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE, itemnr, toshow->GetFileName(), 0, 0, iImage, (LPARAM)toshow);
d217 1
a217 1
		itemnr = InsertItem(LVIF_TEXT | LVIF_PARAM, itemnr, toshow->GetFileName(), 0, 0, 1, (LPARAM)toshow);
a218 1
//	katsyonak 05/08/2003 End
d220 1
a220 1
	TCHAR buffer[50];
d222 6
a227 6
	SetItemText(itemnr, 1, CastItoXBytes(filesize));
	_itot(nSources, buffer, 10);
	SetItemText(itemnr, 2, buffer);
	SetItemText(itemnr, 3, GetFiletypeByName(toshow->GetFileName()));
	SetItemText(itemnr, 4, FileHashToString(toshow->GetFileHash()));
	SetItemText(itemnr, 5, g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(toshow->GetFileHash(), 16), toshow->GetFileSize())); //FakeCheck
d230 2
a231 2

void CSearchListCtrl::UpdateSources(CSearchFile* toupdate)
d234 3
a236 1
	LVFINDINFO find;
d238 13
a250 9
	find.lParam = (LPARAM)toupdate;
	int index = FindItem(&find);
	if (index != ( -1))
	{
		TCHAR buffer[50];
		_itot(toupdate->GetSourceCount(), buffer, 10);
		SetItemText(index, 2, buffer);
		Update(index);
		RedrawItems(index, index); // Lord KiRon
d254 2
a255 2

void CSearchListCtrl::RemoveResult(CSearchFile* toremove)
d258 3
a260 1
	LVFINDINFO find;
d262 7
a268 4
	find.lParam = (LPARAM)toremove;
	sint32 result = FindItem(&find);
	if (result != ( -1))
		DeleteItem(result);
d271 2
a272 2

void CSearchListCtrl::ShowResults(uint32 nResultsID)
d275 1
d277 4
a280 3
	m_nResultsID = nResultsID;
	if (m_pSearchList)
		m_pSearchList->ShowResults(m_nResultsID);
d283 2
a284 2

void CSearchListCtrl::OnCustomdraw(NMHDR* pNMHDR, LRESULT* pResult)
d287 2
a288 1
	NMLVCUSTOMDRAW * pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>(pNMHDR);
d298 6
a303 4
		COLORREF crText = ::GetSysColor(COLOR_WINDOWTEXT);
		uint32 red = GetRValue(crText);
		uint32 green = GetGValue(crText);
		uint32 blue = GetGValue(crText);
d305 1
a305 2
		CSearchFile* file = (CSearchFile*)pLVCD->nmcd.lItemlParam;
		if (!file)
d308 1
a308 3
		CKnownFile* sameFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(file->GetFileHash());
		if (!sameFile)
			sameFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(file->GetFileHash());
d310 5
a314 1
		if (sameFile)
d316 1
a316 1
			if (sameFile->IsPartFile())
d319 3
a321 3
				red = (file->GetSourceCount() + 4) * 20;
				if (red > 255)
					red = 255;
d326 1
a326 1
				green = 128;
d331 3
a333 3
			blue = (file->GetSourceCount() - 1) * 20;
			if (blue > 255)
				blue = 255;
d336 2
a337 1
		pLVCD->clrText = RGB(red, green , blue);
d342 2
a343 2

void CSearchListCtrl::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult)
d346 4
a349 2
	NM_LISTVIEW * pNMListView = (NM_LISTVIEW*)pNMHDR;
//	if it's a second click on the same column then reverse the sort order,
d351 8
a358 5
	m_bSortAscending[pNMListView->iSubItem] = !m_bSortAscending[pNMListView->iSubItem];
	SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem]);
	SortItems(&SortProc, pNMListView->iSubItem + ((m_bSortAscending[pNMListView->iSubItem]) ? MLC_SORTASC : MLC_SORTDESC));
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, pNMListView->iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SEARCH, m_bSortAscending[pNMListView->iSubItem]);
d360 1
d363 1
a363 1

d367 2
a368 2
	CSearchFile		*item1 = (CSearchFile*)lParam1;
	CSearchFile		*item2 = (CSearchFile*)lParam2;
d374 1
a374 1
		case 0:                       //filename asc
d376 1
a376 1
			return _tcsicmp(item1->GetFileName(), item2->GetFileName()) * iSortMod;
d378 1
a378 1
		case 1:                       //size asc
d380 1
a380 1
			return ((item1->GetIntTagValue(FT_FILESIZE) > item2->GetIntTagValue(FT_FILESIZE)) ? 1 : -1) * iSortMod;
d382 1
a382 1
		case 2:                       //sources asc
d384 1
a384 1
			return (item1->GetIntTagValue(FT_SOURCES) - item2->GetIntTagValue(FT_SOURCES)) * iSortMod;
d386 1
a386 1
		case 3:                       //type asc
d388 1
a388 1
			return GetFiletypeByName(item1->GetFileName()).Compare(GetFiletypeByName(item2->GetFileName())) * iSortMod;
d390 1
a390 1
		case 4:                       //filahash asc
d392 1
a392 1
			return memcmp(item1->GetFileHash(), item2->GetFileHash(), 16) * iSortMod;
d394 1
a394 1
		case 5:
d396 2
a397 2
			CString		strFake1 = g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(item1->GetFileHash(), 16), item1->GetFileSize());
			CString		strFake2 = g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(item2->GetFileHash(), 16), item2->GetFileSize());
d409 2
a410 2

void CSearchListCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
a412 1
	UINT flag = (GetSelectionMark() != ( -1) && GetSelectedCount() > 0) ? MF_ENABLED : MF_GRAYED;
d414 31
a444 2
	CTitleMenu	m_SearchFileMenu;
	CMenu	m_ed2kMenu;
d446 2
a447 2
	m_SearchFileMenu.CreatePopupMenu();
	m_SearchFileMenu.AddMenuTitle(GetResString(IDS_FILE));
d449 1
a449 27
	m_SearchFileMenu.AppendMenu(MF_STRING, MP_RESUME, GetResString(IDS_DOWNLOAD));
	m_SearchFileMenu.EnableMenuItem(MP_RESUME, flag);
	m_SearchFileMenu.SetDefaultItem(MP_RESUME);

	m_SearchFileMenu.AppendMenu(MF_SEPARATOR);

	m_SearchFileMenu.AppendMenu(MF_STRING, MP_REMOVESELECTED, GetResString(IDS_REMOVESELECTED));
	m_SearchFileMenu.EnableMenuItem(MP_REMOVESELECTED, flag);
	m_SearchFileMenu.AppendMenu(MF_STRING, MP_REMOVE, GetResString(IDS_REMOVESEARCHSTRING));
	m_SearchFileMenu.EnableMenuItem(MP_REMOVE, flag);
	m_SearchFileMenu.AppendMenu(MF_STRING, MP_REMOVEALL, GetResString(IDS_REMOVEALLSEARCH));
	m_SearchFileMenu.EnableMenuItem(MP_REMOVEALL, flag);

	m_SearchFileMenu.AppendMenu(MF_SEPARATOR);

	m_ed2kMenu.CreateMenu();
	m_ed2kMenu.AppendMenu(MF_STRING, MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
	m_ed2kMenu.AppendMenu(MF_STRING, MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
	m_SearchFileMenu.AppendMenu(MF_STRING | MF_POPUP, (UINT_PTR)m_ed2kMenu.m_hMenu, GetResString(IDS_ED2KLINKFIX));
	m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_ed2kMenu.m_hMenu, flag);

	int counter;
	CMenu m_menuWeb;
	m_menuWeb.CreateMenu();
	UpdateURLMenu(m_menuWeb, counter);
	UINT flag2;
	flag2 = (counter == 0) ? MF_GRAYED : MF_STRING;
d451 4
a454 2
	m_SearchFileMenu.AppendMenu(flag2 | MF_POPUP, (UINT_PTR)m_menuWeb.m_hMenu, GetResString(IDS_WEBSERVICES));
	m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_menuWeb.m_hMenu, flag);
d456 5
a460 1
		m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_menuWeb.m_hMenu, MF_GRAYED);
a461 4
	m_SearchFileMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
//	m_SearchFileMenu.RemoveMenu(10,MF_BYPOSITION);
	m_menuWeb.DestroyMenu();
	m_SearchFileMenu.DestroyMenu();
d464 1
a464 1

d468 1
d471 2
a472 1
		CSearchFile * file = (CSearchFile*)GetItemData(GetSelectionMark());
d475 1
a475 1
			RunURL(file, g_eMuleApp.m_strWebServiceURLArray.GetAt(wParam - MP_WEBURL));
d477 3
a479 2
	//	for multiple selections
		UINT selectedCount = GetSelectedCount();
d481 4
a484 2
		int index = -1;
		POSITION pos = GetFirstSelectedItemPosition();
d487 2
a488 2
			index = GetNextSelectedItem(pos);
			if (index > -1)
d490 1
a490 1
				selectedList.AddTail((CSearchFile*)GetItemData(index));
d498 2
a499 1
				CString str;
d512 2
a513 1
				CString str;
d552 1
a552 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.DeleteSearch(m_nResultsID);
d559 1
@


1.42
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d64 1
a64 1
		SortInit(12);
d72 3
a74 3
{	//Cax2 sortdlg
	int m_iCurrentSortItem = (sortCode < 10) ? sortCode : sortCode - 10;
	SetSortArrow(m_iCurrentSortItem, (sortCode < 10));
d315 1
a315 1
	SortItems(&SortProc, pNMListView->iSubItem + ((m_bSortAscending[pNMListView->iSubItem]) ? 0 : 10));
d325 6
a330 3
	CSearchFile * item1 = (CSearchFile*)lParam1;
	CSearchFile* item2 = (CSearchFile*)lParam2;
	switch (lParamSort)
d334 1
a334 5
			return _tcsicmp(item1->GetFileName(), item2->GetFileName());
		}
		case 10:                       //filename desc
		{
			return _tcsicmp(item2->GetFileName(), item1->GetFileName());
d338 1
a338 5
			return (item1->GetIntTagValue(FT_FILESIZE) > item2->GetIntTagValue(FT_FILESIZE)) ? 1 : -1;
		}
		case 11:                       //size desc
		{
			return (item2->GetIntTagValue(FT_FILESIZE) > item1->GetIntTagValue(FT_FILESIZE)) ? 1 : -1;
d342 1
a342 5
			return item1->GetIntTagValue(FT_SOURCES) - item2->GetIntTagValue(FT_SOURCES);
		}
		case 12:                       //sources desc
		{
			return item2->GetIntTagValue(FT_SOURCES) - item1->GetIntTagValue(FT_SOURCES);
d346 1
a346 5
			return GetFiletypeByName(item1->GetFileName()).Compare(GetFiletypeByName(item2->GetFileName()));
		}
		case 13:                       //type  desc
		{
			return GetFiletypeByName(item2->GetFileName()).Compare(GetFiletypeByName(item1->GetFileName()));
d350 1
a350 1
			return memcmp(item1->GetFileHash(), item2->GetFileHash(), 16);
d352 1
a352 1
		case 14:                       //filehash desc
d354 4
a357 1
			return memcmp(item2->GetFileHash(), item1->GetFileHash(), 16);
@


1.41
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d19 1
a19 1
// SearchListCtrl.cpp : implementation file
d30 1
a30 1
static char THIS_FILE[]=__FILE__;
d34 1
a34 1
// CSearchListCtrl
d39 3
a41 3
	memset2(&m_bSortAscending,0,6);
	m_pSearchList = 0;  // i_a 
	m_nResultsID = 0; // i_a 
d45 2
a46 1
void CSearchListCtrl::Init(CSearchList* in_searchlist){
d48 1
a48 1
	ModifyStyle(LVS_SINGLESEL,0);
d51 6
a56 6
	InsertColumn(0,GetResString(IDS_DL_FILENAME),LVCFMT_LEFT,250,1);
	InsertColumn(1,GetResString(IDS_DL_SIZE),LVCFMT_RIGHT,100,2);
	InsertColumn(2,GetResString(IDS_DL_SOURCES),LVCFMT_RIGHT,50,3);
	InsertColumn(3,GetResString(IDS_TYPE),LVCFMT_LEFT,65,4);
	InsertColumn(4,GetResString(IDS_FILEID),LVCFMT_LEFT,220,5);
	InsertColumn(5,GetResString(IDS_FAKE_CHECK_HEADER),LVCFMT_LEFT,220); //FakeCheck
d58 2
a59 1
	m_bSortAscending[2]=true;m_bSortAscending[3]=true;
d61 4
a64 2
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())	SortInit(g_eMuleApp.m_pGlobPrefs->GetSearchSortCol());//Cax2 sortdlg
	else SortInit(12);
d71 4
a74 3
void CSearchListCtrl::SortInit(int sortCode){	//Cax2 sortdlg
	int m_iCurrentSortItem=(sortCode<10)?sortCode:sortCode-10;
	SetSortArrow(m_iCurrentSortItem,(sortCode<10));
d78 1
a78 1
void CSearchListCtrl::Localize() 
d80 1
a80 1
	if(GetSafeHwnd())
d82 35
a116 35
	CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
	HDITEM hdi;
	hdi.mask = HDI_TEXT;
	CString strRes;

	strRes = GetResString(IDS_DL_FILENAME);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(0, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_DL_SIZE);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(1, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_DL_SOURCES);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(2, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_TYPE);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(3, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_FILEID);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(4, &hdi);
	strRes.ReleaseBuffer();

	//FakeCheck
	strRes = GetResString(IDS_FAKE_CHECK_HEADER);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(5, &hdi);
	strRes.ReleaseBuffer();
d121 1
a121 1
	ON_NOTIFY_REFLECT ( NM_CUSTOMDRAW, OnCustomdraw )
d126 1
a126 1
// CSearchListCtrl message handlers
d131 1
a131 1
	uint32 filesize = toshow->GetIntTagValue(FT_FILESIZE); 
d133 1
a133 1
	if (g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItemCount()>0)
d135 2
a136 2
		// update tab-counter for the given searchfile
		CString csName,sourceStr;
d146 1
a146 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItem(tabCounter,&tabitem);
d156 3
a158 3
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItem(tabCounter,&tabitem);
			
			csName.Format(_T("%s"),szText);
d161 1
a161 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItem(tabCounter,&tabitem);
d165 3
a167 2
			j=csName.ReverseFind('(');
			if (j>0) csName=csName.Left(j-1);
d172 1
a172 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.SetItem(tabCounter,&tabitem);
d179 1
a179 1
		return;
d182 2
a183 2
	// katsyonak 05/08/2003 Start
	if(g_eMuleApp.m_pGlobPrefs->ShowFileTypeIcon())
d188 1
a188 1
			//ASSERT( GetStyle() & LVS_SHAREIMAGELISTS );
d192 3
a194 2
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE,itemnr,toshow->GetFileName(),0,0,iImage,(LPARAM)toshow);
	} else
d198 1
a198 1
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,toshow->GetFileName(),0,0,1,(LPARAM)toshow);
d200 1
a200 1
	// katsyonak 05/08/2003 End
d203 7
a209 7
	
	SetItemText(itemnr,1,CastItoXBytes(filesize));
	_itot(nSources,buffer,10);
	SetItemText(itemnr,2,buffer);
	SetItemText(itemnr,3,GetFiletypeByName(toshow->GetFileName()));	
	SetItemText(itemnr,4,FileHashToString(toshow->GetFileHash()));
	SetItemText(itemnr,5,g_eMuleApp.m_pFakeCheck->IsFake(EncodeBase16(toshow->GetFileHash(), 16),toshow->GetFileSize())); //FakeCheck
d220 1
a220 1
	if (index != (-1))
d223 2
a224 2
		_itot(toupdate->GetSourceCount(),buffer,10);
		SetItemText(index,2,buffer);
d226 2
a227 2
		RedrawItems(index,index); // Lord KiRon
 	}
d238 1
a238 1
	if(result != (-1) )
d248 1
a248 1
	if(m_pSearchList)
d253 1
a253 1
void CSearchListCtrl::OnCustomdraw(NMHDR* pNMHDR, LRESULT* pResult )
d256 1
a256 1
	NMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>( pNMHDR );
d258 1
a258 1
    *pResult = CDRF_DODEFAULT;
d260 6
a265 6
    if (CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage)
    {
        *pResult = CDRF_NOTIFYITEMDRAW;
    }
    else if (CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage)
    {
d273 1
a273 1
			return;
d283 4
a286 3
				// Already downloading
				red = (file->GetSourceCount()+4) * 20;
				if (red > 255) red = 255;
d290 1
a290 1
				// Already downloaded
d296 3
a298 2
			blue = (file->GetSourceCount()-1) * 20;
			if (blue > 255) blue = 255;
d301 3
a303 3
		pLVCD->clrText = RGB(red, green ,blue);
        *pResult = CDRF_DODEFAULT;
     }
d307 1
a307 1
void CSearchListCtrl::OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult)
d310 3
a312 3
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// if it's a second click on the same column then reverse the sort order,
	// otherwise sort the new column in ascending order.
d315 1
a315 1
	SortItems(&SortProc,pNMListView->iSubItem+ ((m_bSortAscending[pNMListView->iSubItem])? 0:10));
d325 3
a327 3
	CSearchFile* item1 = (CSearchFile*)lParam1;
	CSearchFile* item2 = (CSearchFile*)lParam2;	
	switch(lParamSort)
d329 18
a346 9
		case 0: //filename asc
			return _tcsicmp(item1->GetFileName(),item2->GetFileName());
		case 10: //filename desc
			return _tcsicmp(item2->GetFileName(),item1->GetFileName());
		case 1: //size asc
			return (item1->GetIntTagValue(FT_FILESIZE) > item2->GetIntTagValue(FT_FILESIZE))?1:-1;
		case 11: //size desc
			return (item2->GetIntTagValue(FT_FILESIZE) > item1->GetIntTagValue(FT_FILESIZE))?1:-1;
		case 2: //sources asc
d348 3
a350 1
		case 12: //sources desc
d352 3
a354 1
		case 3: //type asc
d356 3
a358 1
		case 13: //type  desc
d360 9
a368 4
		case 4: //filahash asc
			return memcmp(item1->GetFileHash(),item2->GetFileHash(),16);
		case 14: //filehash desc
			return memcmp(item2->GetFileHash(),item1->GetFileHash(),16);
d370 1
d372 1
d381 1
a381 1
	UINT flag=(GetSelectionMark()!=(-1) && GetSelectedCount()>0) ? MF_ENABLED:MF_GRAYED;
d384 1
a384 1
	CMenu		m_ed2kMenu;
d389 2
a390 2
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DOWNLOAD));
	m_SearchFileMenu.EnableMenuItem(MP_RESUME,flag);
d395 6
a400 6
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_REMOVESELECTED, GetResString(IDS_REMOVESELECTED));
	m_SearchFileMenu.EnableMenuItem(MP_REMOVESELECTED,flag);
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_REMOVE, GetResString(IDS_REMOVESEARCHSTRING));
	m_SearchFileMenu.EnableMenuItem(MP_REMOVE,flag);
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_REMOVEALL, GetResString(IDS_REMOVEALLSEARCH));
	m_SearchFileMenu.EnableMenuItem(MP_REMOVEALL,flag);
d405 4
a408 4
	m_ed2kMenu.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
	m_ed2kMenu.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
	m_SearchFileMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_ed2kMenu.m_hMenu, GetResString(IDS_ED2KLINKFIX));
	m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_ed2kMenu.m_hMenu,flag);
d413 1
a413 1
	UpdateURLMenu(m_menuWeb,counter);
d415 8
a422 8
	flag2=(counter==0) ? MF_GRAYED:MF_STRING;
	
	m_SearchFileMenu.AppendMenu(flag2|MF_POPUP,(UINT_PTR)m_menuWeb.m_hMenu, GetResString(IDS_WEBSERVICES));
	m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_menuWeb.m_hMenu,flag);
	if(GetSelectionMark()!=(-1) && GetSelectedCount()>1)
		m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_menuWeb.m_hMenu,MF_GRAYED);
	
	m_SearchFileMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON,point.x,point.y,this);
d432 1
a432 1
	if (GetSelectionMark() != (-1))
d434 2
a435 2
 		CSearchFile* file = (CSearchFile*)GetItemData(GetSelectionMark());
		if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+64)
d437 1
a437 1
			RunURL(file, g_eMuleApp.m_strWebServiceURLArray.GetAt(wParam-MP_WEBURL));
d439 1
a439 1
		//for multiple selections
d444 1
a444 1
		while(pos != NULL)
d447 1
a447 1
			if(index > -1)
d456 3
d460 4
a463 10
					CString str;
					while(!selectedList.IsEmpty())
					{
						str += selectedList.GetHead()->CreateED2kLink();
						selectedList.RemoveHead();
						if(!selectedList.IsEmpty())
							str += "\n";
					}
					g_eMuleApp.CopyTextToClipboard(str);
					break;
d465 3
d469 3
d473 4
a476 10
					CString str;
					while(!selectedList.IsEmpty())
					{
						str += selectedList.GetHead()->CreateHTMLED2kLink();
						selectedList.RemoveHead();
						if(!selectedList.IsEmpty())
							str += "\n";
					}
					g_eMuleApp.CopyTextToClipboard(str);
					break;
d478 3
d482 4
a485 4
				{
					g_eMuleApp.m_pdlgEmule->m_dlgSearch.OnBnClickedSdownload();
					break;
				}
d487 4
a490 4
				{
					g_eMuleApp.m_pdlgEmule->m_dlgSearch.DeleteAllSearchs();
					break;
				}
d492 3
d496 2
a497 8
					SetRedraw(false);
					while(!selectedList.IsEmpty())
					{
						g_eMuleApp.m_pSearchList->RemoveResults(selectedList.GetHead());
						selectedList.RemoveHead();
					}
					SetRedraw(true);
					break;
d499 3
d503 1
a503 1
		selectedList.RemoveAll(); 
d505 7
a511 6
	switch (wParam){
			case MP_REMOVE:
				{
					g_eMuleApp.m_pdlgEmule->m_dlgSearch.DeleteSearch(m_nResultsID);
					break;
				}
@


1.40
log
@Formatting, comments, and name changes.
@
text
@d39 1
a39 1
	memset(&m_bSortAscending,0,6);
@


1.39
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d406 1
a406 1
			RunURL(file, g_eMuleApp.webservices.GetAt(wParam-MP_WEBURL));
@


1.38
log
@FakeCheck for Search Result and Download List (Check and Report ... made by milobac ... merged by DropF ... tested by n@@boleo and me)
@
text
@d307 2
@


1.37
log
@Fixed "sort settings not saved".
@
text
@d26 1
d55 1
d106 6
d202 1
a306 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SEARCH, pNMListView->iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SEARCH, m_bSortAscending[pNMListView->iSubItem]);
@


1.36
log
@Formatting, comments, and name changes.
@
text
@d298 2
@


1.35
log
@Formatting, comments, and name changes.
@
text
@d38 1
a38 1
	memset(&asc_sort,0,6);
d55 1
a55 1
	asc_sort[2]=true;asc_sort[3]=true;
d295 3
a297 3
	asc_sort[pNMListView->iSubItem] = !asc_sort[pNMListView->iSubItem];
	SetSortArrow(pNMListView->iSubItem, asc_sort[pNMListView->iSubItem]);
	SortItems(&SortProc,pNMListView->iSubItem+ ((asc_sort[pNMListView->iSubItem])? 0:10));
@


1.34
log
@Empy Incoming dir for category fix, Official fix [Katsyonak], WS templates updated for file status icons.
@
text
@d66 2
a67 2
	int m_CurrentSortItem=(sortCode<10)?sortCode:sortCode-10;
	SetSortArrow(m_CurrentSortItem,(sortCode<10));
d369 3
a371 3
	CMenu m_Web;
	m_Web.CreateMenu();
	UpdateURLMenu(m_Web,counter);
d375 2
a376 2
	m_SearchFileMenu.AppendMenu(flag2|MF_POPUP,(UINT_PTR)m_Web.m_hMenu, GetResString(IDS_WEBSERVICES));
	m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_Web.m_hMenu,flag);
d378 1
a378 1
		m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_Web.m_hMenu,MF_GRAYED);
d382 1
a382 1
	m_Web.DestroyMenu();
@


1.33
log
@Reduced MP_WEBURL to 64 options
@
text
@d49 5
a53 5
	InsertColumn(1,GetResString(IDS_DL_FILENAME),LVCFMT_LEFT,250,1);
	InsertColumn(2,GetResString(IDS_DL_SIZE),LVCFMT_RIGHT,100,2);
	InsertColumn(3,GetResString(IDS_DL_SOURCES),LVCFMT_RIGHT,50,3);
	InsertColumn(4,GetResString(IDS_TYPE),LVCFMT_LEFT,65,4);
	InsertColumn(5,GetResString(IDS_FILEID),LVCFMT_LEFT,220,5);
d61 2
a62 1
CSearchListCtrl::~CSearchListCtrl(){
d115 2
a116 1
void CSearchListCtrl::AddResult(CSearchFile* toshow){
d120 2
a121 1
	if (g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItemCount()>0) {
d131 2
a132 1
		for (tabCounter = 0; tabCounter < g_eMuleApp.m_pdlgEmule->m_dlgSearch.searchselect.GetItemCount();tabCounter++){
d138 2
a139 1
		if (tabitem.lParam == toshow->GetSearchID()) {
d150 1
a150 1
			sourceStr.Format(_T(" (%u)"), m_pSearchList->GetFoundFiles(toshow->GetSearchID()) );
d197 2
a198 1
void CSearchListCtrl::UpdateSources(CSearchFile* toupdate){
d204 2
a205 1
	if (index != (-1)){
d215 2
a216 1
void CSearchListCtrl::RemoveResult(CSearchFile* toremove){
d227 2
a228 1
void CSearchListCtrl::ShowResults(uint32 nResultsID){
d237 2
a238 1
void CSearchListCtrl::OnCustomdraw(NMHDR* pNMHDR, LRESULT* pResult ){
d244 2
a245 1
    if (CDDS_PREPAINT == pLVCD->nmcd.dwDrawStage){
d248 2
a249 1
    else if (CDDS_ITEMPREPAINT == pLVCD->nmcd.dwDrawStage){
d263 4
a266 2
		if (sameFile) {
			if (sameFile->IsPartFile()) {
d271 2
a272 1
			else {
d277 2
a278 1
		else {
d289 2
a290 1
void CSearchListCtrl::OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult){
d302 2
a303 1
int CSearchListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){
d307 2
a308 1
	switch(lParamSort){
d393 3
a395 2
		if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+64) {
			RunURL(file, g_eMuleApp.webservices.GetAt(wParam-MP_WEBURL) );
@


1.32
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d374 1
a374 1
		if (wParam>=MP_WEBURL && wParam<=MP_WEBURL+256) {
@


1.31
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d56 1
a56 1
	LoadSettings(CPreferences::tableSearch);
@


1.30
log
@Second batch of name changes
@
text
@d39 1
a39 1
	searchlist = 0;  // i_a 
d47 1
a47 1
	searchlist = in_searchlist;
d57 1
a57 1
	if (theApp.glob_prefs->DoUseSort())	SortInit(theApp.glob_prefs->GetSearchSortCol());//Cax2 sortdlg
d118 1
a118 1
	if (theApp.emuledlg->searchwnd.searchselect.GetItemCount()>0) {
d128 2
a129 2
		for (tabCounter = 0; tabCounter < theApp.emuledlg->searchwnd.searchselect.GetItemCount();tabCounter++){
			theApp.emuledlg->searchwnd.searchselect.GetItem(tabCounter,&tabitem);
d138 1
a138 1
			theApp.emuledlg->searchwnd.searchselect.GetItem(tabCounter,&tabitem);
d143 1
a143 1
			theApp.emuledlg->searchwnd.searchselect.GetItem(tabCounter,&tabitem);
d145 1
a145 1
			sourceStr.Format(_T(" (%u)"), searchlist->GetFoundFiles(toshow->GetSearchID()) );
d153 1
a153 1
			theApp.emuledlg->searchwnd.searchselect.SetItem(tabCounter,&tabitem);
d164 1
a164 1
	if(theApp.glob_prefs->ShowFileTypeIcon())
d166 2
a167 2
		int iImage = theApp.GetFileTypeSystemImageIdx(toshow->GetFileName());
		if (!m_bSetImageList && theApp.GetSystemImageList() != NULL)
d170 1
a170 1
			ApplyImageList(theApp.GetSystemImageList());
d223 2
a224 2
	if(searchlist)
		searchlist->ShowResults(m_nResultsID);
d247 1
a247 1
		CKnownFile* sameFile = theApp.sharedfiles->GetFileByID(file->GetFileHash());
d249 1
a249 1
			sameFile = theApp.downloadqueue->GetFileByID(file->GetFileHash());
d375 1
a375 1
			RunURL(file, theApp.webservices.GetAt(wParam-MP_WEBURL) );
d403 1
a403 1
					theApp.CopyTextToClipboard(str);
d416 1
a416 1
					theApp.CopyTextToClipboard(str);
d421 1
a421 1
					theApp.emuledlg->searchwnd.OnBnClickedSdownload();
d426 1
a426 1
					theApp.emuledlg->searchwnd.DeleteAllSearchs();
d434 1
a434 1
						theApp.searchlist->RemoveResults(selectedList.GetHead());
d446 1
a446 1
					theApp.emuledlg->searchwnd.DeleteSearch(m_nResultsID);
@


1.29
log
@Katsyonak fix
@
text
@d452 1
a452 1
}@


1.28
log
@Minor fixes (ops!)
@
text
@d177 1
@


1.27
log
@Fix for lists navigation [from official]
@
text
@d173 1
a173 1
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE,itemnr,LPSTR_TEXTCALLBACK,0,0,iImage,(LPARAM)toshow);
d177 1
a177 1
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,LPSTR_TEXTCALLBACK,0,0,1,(LPARAM)toshow);
d451 1
a451 36
}

void CSearchListCtrl::OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVDISPINFO *pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);

	if (theApp.emuledlg->IsRunning()){
		// Although we have an owner drawn listview control we store the text for the primary item in the listview, to be
		// capable of quick searching those items via the keyboard. Because our listview items may change their contents,
		// we do this via a text callback function. The listview control will send us the LVN_DISPINFO notification if
		// it needs to know the contents of the primary item.
		//
		// But, the listview control sends this notification all the time, even if we do not search for an item. At least
		// this notification is only sent for the visible items and not for all items in the list. Though, because this
		// function is invoked *very* often, no *NOT* put any time consuming code here in.

		if (pDispInfo->item.mask & LVIF_TEXT){
			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);
			if (pClient != NULL){
				switch (pDispInfo->item.iSubItem){
					case 0:
						if (pClient->GetUserName() && pDispInfo->item.cchTextMax > 0){
							_tcsncpy(pDispInfo->item.pszText, pClient->GetUserName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
						}
						break;
					default:
						// shouldn't happen
						pDispInfo->item.pszText[0] = _T('\0');
						break;
				}
			}
		}
	}
	*pResult = 0;
}
@


1.26
log
@Fixed HTMLExport, update SharedList when name is changed, minor fix (not propper) to FileTypeIcon disable in search.
@
text
@d173 1
a173 1
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM|LVIF_IMAGE,itemnr,toshow->GetFileName(),0,0,iImage,(LPARAM)toshow);
d177 1
a177 1
		itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,toshow->GetFileName(),0,0,1,(LPARAM)toshow);
d453 34
@


1.25
log
@Added UDP Search to statistics.
@
text
@d174 5
a178 1
	} else itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,toshow->GetFileName(),0,0,1,(LPARAM)toshow);
@


1.24
log
@FEATURE: show filetype icons on searchlist [katsyonak]
@
text
@d169 1
a169 1
			ASSERT( GetStyle() & LVS_SHAREIMAGELISTS );
@


1.23
log
@unicode cleanup
@
text
@d41 1
d163 14
a176 1
	itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,toshow->GetFileName(),0,0,1,(LPARAM)toshow);
@


1.22
log
@code cleanup
@
text
@d121 1
a121 1
		char szText[510];
d139 1
a139 1
			csName.Format("%s",szText);
d144 1
a144 1
			sourceStr.Format(" (%u)", searchlist->GetFoundFiles(toshow->GetSearchID()) );
d163 1
a163 1
	char buffer[50];
d166 1
a166 1
	itoa(nSources,buffer,10);
d180 2
a181 2
		char buffer[50];
		itoa(toupdate->GetSourceCount(),buffer,10);
d272 1
a272 1
			return strcmpi(item1->GetFileName(),item2->GetFileName());
d274 1
a274 1
			return strcmpi(item2->GetFileName(),item1->GetFileName());
@


1.21
log
@code cleanup
@
text
@d168 2
a169 5
	SetItemText(itemnr,3,GetFiletypeByName(toshow->GetFileName()));
	buffer[0] = 0;
	for (uint16 i = 0;i != 16;i++) // hmm I wonder if there is a standart function for this
		sprintf(buffer,"%s%02X",buffer,toshow->GetFileHash()[i]);
	SetItemText(itemnr,4,buffer);
@


1.20
log
@Small fixes
@
text
@d382 1
a382 1
						str += theApp.CreateED2kLink(selectedList.GetHead());
d395 1
a395 1
						str += theApp.CreateHTMLED2kLink(selectedList.GetHead());
@


1.19
log
@Code cleanup
@
text
@d346 1
a346 1
	m_SearchFileMenu.RemoveMenu(10,MF_BYPOSITION);
d348 1
@


1.18
log
@documents search and 'NOT' search filter
@
text
@a116 10
	if(!filesize || /* !nSources || */ !strlen(toshow->GetFileName()))
		return;
	CString sNotSearch = theApp.emuledlg->searchwnd.GetNotSearch(toshow->GetSearchID());
	if(!sNotSearch.IsEmpty())
	{
		CString sFileName = CString(toshow->GetFileName());
		sFileName.MakeLower();
		if(sFileName.Find(sNotSearch) != -1)
			return;
	}
@


1.17
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d119 8
@


1.16
log
@Warning fix
@
text
@d117 1
a117 1
	if(!filesize || !nSources || !strlen(toshow->GetFileName()))
@


1.15
log
@search 0-sources/0-filesize/empty-name bugfix
@
text
@d300 1
@


1.14
log
@Removing results options in Search window context menu now disabled if no results to remove
@
text
@d114 5
a118 1

a164 1
	uint32 filesize = toshow->GetIntTagValue(FT_FILESIZE); 
d168 1
a168 1
	itoa(toshow->GetIntTagValue(FT_SOURCES),buffer,10);
d175 1
a175 1

d179 1
d191 1
d195 1
d202 1
d206 1
d209 3
a211 1
	searchlist->ShowResults(m_nResultsID);
d215 2
a216 1
NMLVCUSTOMDRAW* pLVCD = reinterpret_cast<NMLVCUSTOMDRAW*>( pNMHDR );
d256 1
d260 1
d268 1
d272 1
d299 1
d304 1
d349 1
d354 1
d434 1
@


1.13
log
@Changes to credits and ed2k links.
@
text
@d305 1
d307 1
@


1.12
log
@Last changes to context menues and Fakecheck code removal.
@
text
@d361 1
a361 1
						str += theApp.CreateED2kLink(selectedList.GetHead()) + "\n";
d363 2
d374 1
a374 1
						str += theApp.CreateHTMLED2kLink(selectedList.GetHead()) + "\n";
d376 2
@


1.11
log
@Updates to reCDVst changes (missing strings) and some changes to the context menu (lost an hour for a f****** define). Added standard web services.
@
text
@a53 18
	m_FakeCheckMenu.CreateMenu();
	m_FakeCheckMenu.AppendMenu(MF_STRING,MP_FAKECHECK1, (LPCTSTR)"Jigle");
	m_FakeCheckMenu.AppendMenu(MF_STRING,MP_FAKECHECK2, (LPCTSTR)"DonkeyFakes"); // SeeWen
	m_FakeCheckMenu.AppendMenu(MF_STRING,MP_FAKECHECK3, (LPCTSTR)"ed2kfiles"); // DonGato

	m_SearchFileMenu.CreatePopupMenu();
	m_SearchFileMenu.AddMenuTitle(GetResString(IDS_FILE));
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DOWNLOAD));
	m_SearchFileMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_FakeCheckMenu.m_hMenu, (LPCTSTR)"FakeCheck");
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_GETHTMLED2KLINK, GetResString(IDS_DL_LINK2));
	m_SearchFileMenu.AppendMenu(MF_SEPARATOR);
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_REMOVESELECTED, GetResString(IDS_REMOVESELECTED));
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_REMOVE, GetResString(IDS_REMOVESEARCHSTRING));
	m_SearchFileMenu.AppendMenu(MF_STRING,MP_REMOVEALL, GetResString(IDS_REMOVEALLSEARCH));
	m_SearchFileMenu.SetDefaultItem(MP_RESUME);
	m_SearchFileMenu.AppendMenu(MF_SEPARATOR);

d290 7
d298 17
a314 7
	m_SearchFileMenu.EnableMenuItem(MP_GETED2KLINK,flag);
	m_SearchFileMenu.EnableMenuItem(MP_GETHTMLED2KLINK,flag);
	m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_FakeCheckMenu.m_hMenu,flag);
	
	if (GetSelectedCount() > 1)
		m_SearchFileMenu.EnableMenuItem((UINT_PTR)m_FakeCheckMenu.m_hMenu,MF_GRAYED);
	
d324 2
a380 18
					break;
				}
			case MP_FAKECHECK1: //deltaHF
				{
					if(selectedCount > 1) break;
					theApp.Action(NULL,NULL,file);
					break;
				}
			case MP_FAKECHECK2: // SeeWen
				{
					if(selectedCount > 1) break;
					theApp.emuledlg->searchwnd.OnBnClickedFakecheck();
					break;
				}
			case MP_FAKECHECK3: // DonGato
				{
					if(selectedCount > 1) break;
					theApp.emuledlg->searchwnd.ed2kfilesFakecheck();
@


1.10
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d323 2
a324 1
	m_SearchFileMenu.AppendMenu(flag2|MF_POPUP,(UINT_PTR)m_Web.m_hMenu, GetResString(IDS_WEBSERVICES) );
@


1.9
log
@Messages friend details working & solved context menu problems (Damn! we need a redesign of that). Now version 1b beta 1.
@
text
@d70 1
d316 9
d326 2
d335 3
a337 1
 
@


1.8
log
@Simplified a couple of lines
@
text
@d305 1
a305 1
	UINT flag=(GetSelectionMark()!=(-1)) ? MF_ENABLED:MF_GRAYED;
@


1.8.2.1
log
@v1a upgrade
@
text
@d305 1
a305 1
	UINT flag=(GetSelectionMark()!=(-1) && GetSelectedCount()>0) ? MF_ENABLED:MF_GRAYED;
@


1.7
log
@Added ed2k multiple export and some context menu corrections.
@
text
@d322 1
a322 1
 		CMuleCtrlItem* content = (CMuleCtrlItem*)GetItemData(GetSelectionMark());
d334 1
a334 1
				selectedList.AddTail((CSearchFile*)((CMuleCtrlItem*)GetItemData(index)));
a337 2
		CSearchFile* file = (CSearchFile*)content;
		
@


1.6
log
@bugfixes: sort in search window, unknown % in stats, dowload speed at startup updated search layout
@
text
@d310 4
d320 17
a336 2
	CSearchFile* file ;
	int item;
d338 4
a341 3
	if (GetSelectionMark() != (-1)){
		file = (CSearchFile*)GetItemData(GetSelectionMark());
		switch (wParam){
d344 7
a350 1
					theApp.CopyTextToClipboard(theApp.CreateED2kLink(file));
d355 7
a361 1
					theApp.CopyTextToClipboard(theApp.CreateHTMLED2kLink(file));
d371 1
d373 1
a373 1
						break;
d377 1
d379 1
a379 1
						break;
d383 1
d385 1
a385 1
						break;
d395 1
a395 2
					POSITION pos;
					while (GetFirstSelectedItemPosition()!=NULL) 
d397 2
a398 3
						pos=GetFirstSelectedItemPosition();
						item = GetNextSelectedItem(pos); 
						theApp.searchlist->RemoveResults((CSearchFile*)this->GetItemData(item));
d404 1
d415 1
@


1.5
log
@End of double check with official code.
@
text
@d283 1
a283 1
			return item1->GetIntTagValue(FT_FILESIZE) - item2->GetIntTagValue(FT_FILESIZE);
d285 1
a285 1
			return item2->GetIntTagValue(FT_FILESIZE) - item1->GetIntTagValue(FT_FILESIZE);
a291 1

a293 1

@


1.4
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@a315 2


@


1.3
log
@.26b port
@
text
@d27 5
@


1.2
log
@updated to .25b codebase
@
text
@d175 2
a176 2
	CastItoXBytes(filesize,buffer);
	SetItemText(itemnr,1,buffer);
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d31 2
a32 1
CSearchListCtrl::CSearchListCtrl(){
@

