head	1.29;
access;
symbols
	PublicRelease_1_2e:1.26
	Interim_Release_1-2e_RC1:1.26
	PublicRelease_1_2d:1.24
	Interim_Release_1-2d_RC1:1.24
	Interim_Release_1-2d_beta1:1.24
	PublicRelease_1_2c:1.22
	Interim_Release_1-2c_RC1:1.22
	Interim_Release_1-2c_beta1:1.22
	PublicRelease_1_2b:1.22
	Interim_Release_1-2b_RC1:1.22
	PublicRelease_1_2a:1.22
	Interim_Release_1-2a_RC1:1.22
	Interim_Release_1-2a_beta2:1.22
	Interim_Release_1-2a_beta1:1.22
	PublicRelease_1_2:1.21
	Interim_Release_1-2_RC1:1.21
	Interim_Release_1-2_beta1:1.20
	PublicRelease_1_1g:1.19
	Interim_Release_1-1g_RC3:1.19
	Interim_Release_1-1g_RC2:1.19
	Interim_Release_1-1g_RC1:1.19
	Interim_Release_1-1g_beta2:1.19
	Interim_Release_1-1g_beta1:1.19
	PublicRelease_1_1f:1.19
	Interim_Release_1-1f_RC1:1.19
	PublicRelease_1_1e:1.19
	Interim_Release_1-1e_RC2:1.19
	Interim_Release_1-1e_RC1:1.19
	Interim_Release_1-1e_beta1:1.19
	PublicRelease_1_1d:1.19
	Interim_Release_1-1d_RC1:1.19
	PublicRelease_1_1c:1.19
	Interim_Release_1-1c_RC1:1.19
	Interim_Release_1-1c_beta2:1.19
	Interim_Release_1-1c_beta1:1.19
	PublicRelease_1_1b:1.19
	Interim_Release_1-1b_RC1:1.19
	PublicRelease_1_1a:1.19
	Interim_Release_1-1a_RC2:1.19
	Interim_Release_1-1a_RC1:1.19
	Interim_Release_1-1a_beta2:1.19
	Interim_Release_1-1a_beta1:1.19
	PublicRelease_1_1:1.19
	Interim_Release_1-1_beta1:1.19
	PublicRelease_1o:1.19
	Interim_Release_1o_RC1:1.19
	Interim_Release_1o_beta1:1.19
	PublicRelease_1n:1.19
	Interim_Release_1n_RC2:1.19
	Interim_Release_1n_RC1:1.19
	Interim_Release_1n_beta2:1.19
	Interim_Release_1n_beta1:1.19
	PublicRelease_1m:1.19
	Interim_Release_1m_beta1:1.19
	PublicRelease_1l:1.19
	Interim_Release_1l_RC3:1.19
	Interim_Release_1l_RC2:1.19
	Interim_Release_1l_RC1:1.19
	Interim_Release_1l_beta2:1.19
	Interim_Release_1l_beta1:1.19
	PublicRelease_1k:1.19
	Interim_Release_1k_RC4:1.19
	Interim_1k_RC3:1.18
	Interim_1k_RC2:1.18
	Interim_Release_1k_RC1:1.18
	Interim_Release_1k_beta5:1.18
	Intrerim_Release_1k_beta4:1.18
	Interim_Release_1k_beta1:1.18
	PublicRelease_1j:1.17
	Interim_Release_1J_RC3:1.17
	Interim_Release_1j_RC3:1.17
	Interim_Release_1j_RC2:1.17
	Interim_Release_1j_RC1:1.17
	Interim_Release_1j_beta2:1.17
	Interim_Release_1j_beta1:1.17
	PublicRelease_1i:1.16
	Interim_Release_1i_RC6:1.16
	Interim_Release_1i_RC3:1.16
	Interim_Release_1i_RC2:1.16
	Interim_Release_1i_RC1:1.16
	Interim_Release_1i_beta3:1.16
	Interim_Release_1i_beta2:1.16
	Interim_Release_1i_beta1:1.12
	PublicRelease_1h:1.7
	Interim_Release_1h_rc2:1.7
	Interim_Release_1h_RC1:1.7
	Interim_Release_1h_beta2:1.7
	Interim_Release_1h_beta1_now:1.7
	Interim_Release_1h_beta1:1.7
	PublicRelease_1g:1.7
	Interim_Release_1g_RC6_Final:1.7
	Interim_Release_1g_RC6:1.7
	Interim_Release_1g_RC5:1.7
	Interim_Release_1g_RC4:1.7
	Interim_Release_1g_RC3:1.7
	Interim_Release_1g_beta2:1.5
	Interim_Release_1g_beta1:1.5
	Interim_Release_1f_RC4:1.5
	Interim_Release_1f_RC3:1.5
	Interim_Release_1f_RC2:1.5
	Interim_Release_1f_RC:1.5
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.4
	Interim_Release_1e_beta1:1.4
	PublicRelease_1c:1.4
	featurestest:1.4.0.4
	Interim_Release_1c_RC:1.4
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.10
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.8
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2;
locks; strict;
comment	@// @;


1.29
date	2011.09.29.03.20.46;	author aw3;	state Exp;
branches;
next	1.28;

1.28
date	2011.09.05.19.27.29;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2009.03.01.20.45.49;	author aw3;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.17.05.01.21;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.05.05.20.16;	author aw3;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.26.20.06.46;	author eklmn;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.16.04.14.58;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.15.05.29.47;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.29.05.34.52;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2004.04.07.02.07.32;	author katsyonak;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.17;

1.17
date	2003.12.16.14.02.46;	author dongato;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.20.11.02.57;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.12.22.39.04;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.04.02.25.50;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.30.10.20.52;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.22.16.31.08;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.21.22.05.12;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.21.12.59.44;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.15.09.10.04;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.11.18.27.05;	author eklmn;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.22.12.41.50;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.14.16.24.15;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.14.12.45.16;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.28.04.47.19;	author pooz;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.22.15.36.56;	author kuchin;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Asynchronous host name resolution and unused GetPeerName() change to align with original implementation.
@
text
@/*CAsyncSocketEx by Tim Kosse (Tim.Kosse@@gmx.de)
            Version 1.2 (2003-03-28)
--------------------------------------------------------

Introduction:
-------------

CAsyncSocketEx is a replacement for the MFC class CAsyncSocket.
This class was written because CAsyncSocket is not the fastest WinSock
wrapper and it's very hard to add new functionality to CAsyncSocket
derived classes. This class offers the same functionality as CAsyncSocket.
Also, CAsyncSocketEx offers some enhancements which were not possible with
CAsyncSocket without some tricks.

How do I use it?
----------------
Basically exactly like CAsyncSocket.
To use CAsyncSocketEx, just replace all occurrences of CAsyncSocket in your
code with CAsyncSocketEx, if you did not enhance CAsyncSocket yourself in
any way, you won't have to change anything else in your code.

Why is CAsyncSocketEx faster?
-----------------------------

CAsyncSocketEx is slightly faster when dispatching notification event messages.
First have a look at the way CAsyncSocket works. For each thread that uses
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with
the handle of that window. Until here, CAsyncSocketEx works the same way.
But CAsyncSocket uses only one window message (WM_SOCKET_NOTIFY) for all
sockets within one thread. When the window receive WM_SOCKET_NOTIFY, wParam
contains the socket handle and the window looks up an CAsyncSocket instance
using a map. CAsyncSocketEx works differently. It's helper window uses a
wide range of different window messages (WM_USER through 0xBFFF) and passes
a different message to WSAAsyncSelect for each socket. When a message in
the specified range is received, CAsyncSocketEx looks up the pointer to a
CAsyncSocketEx instance in an Array using the index of message - WM_USER.
As you can see, CAsyncSocketEx uses the helper window in a more efficient
way, as it don't have to use the slow maps to lookup it's own instance.
Still, speed increase is not very much, but it may be noticeable when using
a lot of sockets at the same time.
Please note that the changes do not affect the raw data throughput rate,
CAsyncSocketEx only dispatches the notification messages faster.

What else does CAsyncSocketEx offer?
------------------------------------

CAsyncSocketEx offers a flexible layer system. One example is the proxy layer.
Just create an instance of the proxy layer, configure it and add it to the layer
chain of your CAsyncSocketEx instance. After that, you can connect through
proxies.
Benefit: You don't have to change much to use the layer system.
Another layer that is currently in development is the SSL layer to establish
SSL encrypted connections.

License
-------

Feel free to use this class, as long as you don't claim that you wrote it
and this copyright notice stays intact in the source files.
If you use this class in commercial applications, please send a short message
to tim.kosse@@gmx.de
*/

#include "stdafx.h"
#include "AsyncSocketEx.h"
#include "emule.h"
#include "otherfunctions.h"

#ifndef NOLAYERS
#include "AsyncSocketExLayer.h"
#endif //NOLAYERS

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#ifndef CCRITICALSECTIONWRAPPERINCLUDED
class CCriticalSectionWrapper
{
public:
	CCriticalSectionWrapper()
	{
		InitializeCriticalSection(&m_criticalSection);
	}

	~CCriticalSectionWrapper()
	{
		DeleteCriticalSection(&m_criticalSection);
	}

	void Lock()
	{
		EnterCriticalSection(&m_criticalSection);
	}
	void Unlock()
	{
		LeaveCriticalSection(&m_criticalSection);
	}
protected:
	CRITICAL_SECTION m_criticalSection;
};
#define CCRITICALSECTIONWRAPPERINCLUDED
#endif

CCriticalSectionWrapper CAsyncSocketEx::m_sGlobalCriticalSection;
CAsyncSocketEx::t_AsyncSocketExThreadDataList *CAsyncSocketEx::m_spAsyncSocketExThreadDataList = 0;

#ifndef _AFX
#ifndef VERIFY
#define VERIFY(x) (void(x))
#endif //VERIFY
#ifndef ASSERT
#define ASSERT(x)
#endif //ASSERT
#endif //_AFX

// Taken from Windows Platform SDK (WinUser.h)
#ifndef HWND_MESSAGE
#define HWND_MESSAGE     ((HWND)-3)
#endif

/////////////////////////////
//Helper Window class

class CAsyncSocketExHelperWindow
{
public:
	CAsyncSocketExHelperWindow()
	{
		EMULE_TRY
		//Initialize data
		m_pAsyncSocketExWindowData = new t_AsyncSocketExWindowData[512]; //Reserve space for 512 active sockets
		memzero(m_pAsyncSocketExWindowData, 512 * sizeof(t_AsyncSocketExWindowData));
		m_nWindowDataSize = 512;
		m_nSocketCount = 0;
		m_nWindowDataPos = 0;

		//Create window
		WNDCLASSEX wndclass;
		wndclass.cbSize = sizeof(wndclass);
		wndclass.style = 0;
		wndclass.lpfnWndProc = WindowProc;
		wndclass.cbClsExtra = 0;
		wndclass.cbWndExtra = 0;
		wndclass.hInstance = GetModuleHandle(0);
		wndclass.hIcon = 0;
		wndclass.hCursor = 0;
		wndclass.hbrBackground = 0;
		wndclass.lpszMenuName = 0;
		wndclass.lpszClassName = _T("CAsyncSocketEx Helper Window");
		wndclass.hIconSm = 0;
		RegisterClassEx(&wndclass);

	//	Starting from Win2000 system supports the message-only window that is not visible,
	//	has no z-order, cannot be enumerated, and does not receive broadcast messages.
	//	Enable this window type for Win2000 & later versions to reduce sockets handling overhead
		HWND hParent = 0;

		if ((g_App.m_pPrefs->GetWindowsVersion() & 0x00FF) >= _WINVER_2K_)
			hParent = HWND_MESSAGE;

		m_hWnd = CreateWindowEx(0,_T("CAsyncSocketEx Helper Window"), _T("CAsyncSocketEx Helper Window"), 0, 0, 0, 0, 0, hParent, 0, 0, GetModuleHandle(0));

		ASSERT(m_hWnd);
		SetWindowLong(m_hWnd, GWL_USERDATA, (LONG)this);
		EMULE_CATCH
	};

	virtual ~CAsyncSocketExHelperWindow()
	{
		EMULE_TRY
		//Clean up socket storage
		delete[] m_pAsyncSocketExWindowData;
		m_pAsyncSocketExWindowData = 0;
		m_nWindowDataSize = 0;
		m_nSocketCount = 0;

		//Destroy window
		if (m_hWnd)
		{
			DestroyWindow(m_hWnd);
			m_hWnd = 0;
		}
		EMULE_CATCH
	}

	//Adds a socket to the list of attached sockets
	BOOL AddSocket(CAsyncSocketEx *pSocket, int &nSocketIndex)
	{
		EMULE_TRY
		ASSERT(pSocket);
		if (!m_nWindowDataSize)
		{
			ASSERT(!m_nSocketCount);
			m_nWindowDataSize = 512;
			m_pAsyncSocketExWindowData = new t_AsyncSocketExWindowData[512]; //Reserve space for 512 active sockets
			memzero(m_pAsyncSocketExWindowData, 512 * sizeof(t_AsyncSocketExWindowData));
		}

		if (nSocketIndex != -1)
		{
			ASSERT(m_pAsyncSocketExWindowData);
			ASSERT(m_nWindowDataSize>nSocketIndex);
			ASSERT(m_pAsyncSocketExWindowData[nSocketIndex].m_pSocket == pSocket);
			ASSERT(m_nSocketCount);
			return TRUE;
		}

		//Increase socket storage if too small
		if (m_nSocketCount >= (m_nWindowDataSize - 10))
		{
			int nOldWindowDataSize = m_nWindowDataSize;
			ASSERT(m_nWindowDataSize < MAX_SOCKETS);
			m_nWindowDataSize += 512;
			if (m_nWindowDataSize > MAX_SOCKETS)
				m_nWindowDataSize = MAX_SOCKETS;

			t_AsyncSocketExWindowData *tmp = m_pAsyncSocketExWindowData;
			m_pAsyncSocketExWindowData = new t_AsyncSocketExWindowData[m_nWindowDataSize];
			memcpy2(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize * sizeof(t_AsyncSocketExWindowData));
			memzero(m_pAsyncSocketExWindowData + nOldWindowDataSize, (m_nWindowDataSize - nOldWindowDataSize) * sizeof(t_AsyncSocketExWindowData));
			delete[] tmp;
		}

		//Search for free slot
		for (int i = m_nWindowDataPos; i < (m_nWindowDataSize + m_nWindowDataPos); i++)
		{
			if (m_pAsyncSocketExWindowData[i % m_nWindowDataSize].m_pSocket == NULL)
			{
				m_pAsyncSocketExWindowData[i % m_nWindowDataSize].m_pSocket = pSocket;
				nSocketIndex = i % m_nWindowDataSize;
				m_nWindowDataPos = (i + 1) % m_nWindowDataSize;
				m_nSocketCount++;
				return TRUE;
			}
		}

		EMULE_CATCH
		//No slot found, maybe there are too much sockets!
		return FALSE;
	}

	//Removes a socket from the socket storage
	BOOL RemoveSocket(CAsyncSocketEx *pSocket, int &nSocketIndex)
	{
		UNREFERENCED_PARAMETER(pSocket);
		EMULE_TRY
		ASSERT(pSocket);

		if (nSocketIndex == -1)
			return TRUE;

		ASSERT(m_pAsyncSocketExWindowData);
		ASSERT(m_nWindowDataSize > 0);
		ASSERT(m_nSocketCount > 0);
		ASSERT(m_pAsyncSocketExWindowData[nSocketIndex].m_pSocket == pSocket);
		m_pAsyncSocketExWindowData[nSocketIndex].m_pSocket = 0;
		nSocketIndex = -1;
		m_nSocketCount--;

		return TRUE;
		EMULE_CATCH
		return FALSE;
	}

	//Processes event notifications sent by the sockets or the layers
	static LRESULT CALLBACK WindowProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
	{
		try
		{
			if (message >= WM_SOCKETEX_NOTIFY)
			{
				//Verify parameters
				ASSERT(hWnd);
				CAsyncSocketExHelperWindow *pWnd = (CAsyncSocketExHelperWindow *)GetWindowLong(hWnd, GWL_USERDATA);
				ASSERT(pWnd);

				if (message < static_cast<UINT>(WM_SOCKETEX_NOTIFY + pWnd->m_nWindowDataSize)) //Index is within socket storage
				{
					//Lookup socket and verify if it's valid
					CAsyncSocketEx *pSocket = pWnd->m_pAsyncSocketExWindowData[message - WM_SOCKETEX_NOTIFY].m_pSocket;
					SOCKET hSocket = wParam;
					if (!pSocket)
						return 0;
					if (hSocket == INVALID_SOCKET)
						return 0;
					if (pSocket->m_SocketData.hSocket != hSocket)
						return 0;

					int nEvent = lParam & 0xFFFF;
					int nErrorCode = lParam >> 16;

					//Dispatch notification
	#ifndef NOLAYERS
					if (!pSocket->m_pFirstLayer)
					{
	#endif //NOLAYERS
						//Dispatch to CAsyncSocketEx instance
						switch (nEvent)
						{
							case FD_READ:
							{
								DWORD nBytes;
								if (!pSocket->IOCtl(FIONREAD, &nBytes))
									nErrorCode = WSAGetLastError();
								if (nBytes != 0 || nErrorCode != 0)
									pSocket->OnReceive(nErrorCode);
								break;
							}
							case FD_FORCEREAD: //Forceread does not check if there's data waiting
								pSocket->OnReceive(nErrorCode);
								break;
							case FD_WRITE:
								pSocket->OnSend(nErrorCode);
								break;
							case FD_CONNECT:
								pSocket->OnConnect(nErrorCode);
								break;
							case FD_ACCEPT:
								pSocket->OnAccept(nErrorCode);
								break;
							case FD_CLOSE:
								pSocket->OnClose(nErrorCode);
								break;
						}
					}
	#ifndef NOLAYERS
					else //Dispatch notification to the lowest layer
					{
						if (nEvent == FD_READ)
						{
							DWORD nBytes;
							if (!pSocket->IOCtl(FIONREAD, &nBytes))
								nErrorCode = WSAGetLastError();
							if (nBytes != 0 || nErrorCode != 0)
								pSocket->m_pLastLayer->CallEvent(nEvent, nErrorCode);
						}
						else
							pSocket->m_pLastLayer->CallEvent(nEvent, nErrorCode);
					}
				}
	#endif //NOLAYERS
				return 0;
			}
	#ifndef NOLAYERS
			else if (message == WM_SOCKETEX_TRIGGER) //Notification event sent by a layer
			{
				//Verify parameters, lookup socket and notification message
				if (!wParam)
					return 0;
				CAsyncSocketEx *pSocket = (CAsyncSocketEx *)wParam;
				CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg = (CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;
				if (pSocket->m_SocketData.hSocket == INVALID_SOCKET)
				{
					delete pMsg;
					return 0;
				}
				int nEvent = pMsg->lEvent & 0xFFFF;
				int nErrorCode = pMsg->lEvent >> 16;

				//Dispatch to layer
				if (pMsg->pLayer)
					pMsg->pLayer->CallEvent(nEvent, nErrorCode);
				else
				{
					//Dispatch to socket class
					switch (nEvent)
					{
						case FD_READ:
							if (pSocket->m_lEvent & FD_READ)
								pSocket->OnReceive(nErrorCode);
							break;
						case FD_FORCEREAD:
							if (pSocket->m_lEvent & FD_FORCEREAD)
								pSocket->OnReceive(nErrorCode);
							break;
						case FD_WRITE:
							if (pSocket->m_lEvent & FD_WRITE)
								pSocket->OnSend(nErrorCode);
							break;
						case FD_CONNECT:
							if (pSocket->m_lEvent & FD_CONNECT)
								pSocket->OnConnect(nErrorCode);
							break;
						case FD_ACCEPT:
							if (pSocket->m_lEvent & FD_ACCEPT)
								pSocket->OnAccept(nErrorCode);
							break;
						case FD_CLOSE:
							if (pSocket->m_lEvent & FD_CLOSE)
								pSocket->OnClose(nErrorCode);
							break;
					}
				}
				delete pMsg;
				return 0;
			}
	#endif //NOLAYERS
			else if (message == WM_SOCKETEX_GETHOST)
			{
				//WSAAsyncGetHostByName reply

				//Verify parameters
				ASSERT(hWnd);
				CAsyncSocketExHelperWindow *pWnd = (CAsyncSocketExHelperWindow *)GetWindowLong(hWnd, GWL_USERDATA);
				ASSERT(pWnd);

				CAsyncSocketEx	*pSocket = NULL;
				int				i;

				for (i = 0; i < pWnd->m_nWindowDataSize; i++)
				{
					pSocket = pWnd->m_pAsyncSocketExWindowData[i].m_pSocket;
					if (pSocket && pSocket->m_hAsyncGetHostByNameHandle &&
						pSocket->m_hAsyncGetHostByNameHandle == (HANDLE)wParam)
						break;
				}
				if (i == pWnd->m_nWindowDataSize)
					return 0;

				int nErrorCode = lParam >> 16;
				if (nErrorCode)
				{
					pSocket->OnConnect(nErrorCode);
					// Do *NOT* access 'pSocket', it may already have been deleted (CServerConnect)
					return 0;
				}

				SOCKADDR_IN sockAddr = {0};
				sockAddr.sin_family = AF_INET;
				sockAddr.sin_addr.s_addr = ((LPIN_ADDR)((LPHOSTENT)pSocket->m_pAsyncGetHostByNameBuffer)->h_addr)->s_addr;
				sockAddr.sin_port = fast_htons(static_cast<u_short>(pSocket->m_nAsyncGetHostByNamePort));

				if (!pSocket->OnHostNameResolved(&sockAddr)) {
					// Do *NOT* access 'pSocket', it may already have been deleted (CServerConnect)
					return 0;
				}

				BOOL res = pSocket->Connect((SOCKADDR*)&sockAddr, sizeof(sockAddr));
				delete[] pSocket->m_pAsyncGetHostByNameBuffer;
				pSocket->m_pAsyncGetHostByNameBuffer = 0;
				pSocket->m_hAsyncGetHostByNameHandle = 0;

				if (!res && GetLastError() != WSAEWOULDBLOCK)
					pSocket->OnConnect(GetLastError());
				return 0;
			}
			return DefWindowProc(hWnd, message, wParam, lParam);
		}
		catch(CException* e){
			TCHAR szError[1024];
			e->GetErrorMessage(szError, ARRSIZE(szError));
			const CRuntimeClass* pRuntimeClass = e->GetRuntimeClass();
			LPCSTR pszClassName = (pRuntimeClass) ? pRuntimeClass->m_lpszClassName : NULL;
			if (!pszClassName)
				pszClassName = "CException";
			TRACE(_T("*** Unknown %hs exception in CAsyncSocketExHelperWindow::WindowProc - %s\n"), pszClassName, szError);
			e->Delete();
		}
		catch (...) {
			// TODO: This exception handler should definitively *not* be here. Though we seem to need it to
			// catch some very strange crashs which deal with socket deletion problems in the client's TCP socket.
			TRACE("*** Unknown exception in CAsyncSocketExHelperWindow::WindowProc\n");
		}
		return 0;
	}

	HWND CAsyncSocketExHelperWindow::GetHwnd()
	{
		return m_hWnd;
	}

private:
	HWND m_hWnd;
	struct t_AsyncSocketExWindowData
	{
		CAsyncSocketEx *m_pSocket;
	} *m_pAsyncSocketExWindowData;
	int m_nWindowDataSize;
	int m_nWindowDataPos;
	int m_nSocketCount;
};

//////////////////////////////////////////////////////////////////////
// Konstruktion/Destruktion
//////////////////////////////////////////////////////////////////////

CAsyncSocketEx::CAsyncSocketEx()
{
	m_SocketData.hSocket = INVALID_SOCKET;
	m_SocketData.nSocketIndex = -1;
	m_pLocalAsyncSocketExThreadData = 0;
#ifndef NOLAYERS
	m_pFirstLayer = 0;
	m_pLastLayer = 0;
#endif //NOLAYERS
	m_pAsyncGetHostByNameBuffer = NULL;
	m_hAsyncGetHostByNameHandle = NULL;
}

CAsyncSocketEx::~CAsyncSocketEx()
{
	Close();
	FreeAsyncSocketExInstance();
}

BOOL CAsyncSocketEx::Create(UINT nSocketPort /*=0*/, int nSocketType /*=SOCK_STREAM*/,
														long lEvent /*=FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE*/,
														LPCSTR lpszSocketAddress /*=NULL*/)
{
	EMULE_TRY
	// ASSERT(GetSocketHandle()==INVALID_SOCKET);

	//Close the socket, although this should not happen
	if (GetSocketHandle() != INVALID_SOCKET)
	{
		WSASetLastError(WSAEALREADY);
		return FALSE;
	}

	if (!InitAsyncSocketExInstance())
	{
		ASSERT(0);
		WSASetLastError(WSANOTINITIALISED);
		return FALSE;
	}

#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->Create(nSocketPort, nSocketType, lEvent, lpszSocketAddress);
	else
#endif //NOLAYERS
	{
		SOCKET hSocket = socket(AF_INET, nSocketType, 0);
		if (hSocket == INVALID_SOCKET)
			return FALSE;
		m_SocketData.hSocket = hSocket;

		AttachHandle(hSocket);
		if (!AsyncSelect(lEvent))
		{
			Close();
			return FALSE;
		}
#ifndef NOLAYERS
		if (m_pFirstLayer)
		{
			if (WSAAsyncSelect(m_SocketData.hSocket, GetHelperWindowHandle(), m_SocketData.nSocketIndex+WM_SOCKETEX_NOTIFY, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE))
			{
				Close();
				return FALSE;
			}
		}
#endif //NOLAYERS

		if (!Bind(nSocketPort, lpszSocketAddress))
		{
			Close();
			return FALSE;
		}
	}
	return TRUE;

	EMULE_CATCH
	return FALSE;
}

void CAsyncSocketEx::OnReceive(int nErrorCode)
{
	NOPRM(nErrorCode);
}

void CAsyncSocketEx::OnSend(int nErrorCode)
{
	NOPRM(nErrorCode);
}

void CAsyncSocketEx::OnConnect(int nErrorCode)
{
	NOPRM(nErrorCode);
}

void CAsyncSocketEx::OnAccept(int nErrorCode)
{
	NOPRM(nErrorCode);
}

void CAsyncSocketEx::OnClose(int nErrorCode)
{
	NOPRM(nErrorCode);
}

BOOL CAsyncSocketEx::OnHostNameResolved(const SOCKADDR_IN *pSockAddr)
{
	NOPRM(pSockAddr);
	return TRUE;
}

BOOL CAsyncSocketEx::Bind(UINT nSocketPort, LPCSTR lpszSocketAddress)
{
	EMULE_TRY

	SOCKADDR_IN sockAddr = {0};

	if (lpszSocketAddress == NULL)
		sockAddr.sin_addr.s_addr = fast_htonl(INADDR_ANY);
	else
	{
		sockAddr.sin_addr.s_addr = inet_addr(lpszSocketAddress);
		if (sockAddr.sin_addr.s_addr == INADDR_NONE)
		{
			WSASetLastError(WSAEINVAL);
			return FALSE;
		}
	}
	sockAddr.sin_family = AF_INET;
	sockAddr.sin_port = fast_htons((u_short)nSocketPort);
	return Bind((SOCKADDR*)&sockAddr, sizeof(sockAddr));

	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncSocketEx::Bind(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	EMULE_TRY
	if (!bind(m_SocketData.hSocket, lpSockAddr, nSockAddrLen))
		return TRUE;
	else
		return FALSE;
	EMULE_CATCH
	return FALSE;
}

void CAsyncSocketEx::AttachHandle(SOCKET hSocket)
{
	NOPRM(hSocket);

	EMULE_TRY
	ASSERT(m_pLocalAsyncSocketExThreadData);
	VERIFY(m_pLocalAsyncSocketExThreadData->m_pHelperWindow->AddSocket(this, m_SocketData.nSocketIndex));
	EMULE_CATCH
}

void CAsyncSocketEx::DetachHandle(SOCKET hSocket)
{
	NOPRM(hSocket);

	EMULE_TRY
	ASSERT(m_pLocalAsyncSocketExThreadData);
	if (!m_pLocalAsyncSocketExThreadData)
		return;

	ASSERT(m_pLocalAsyncSocketExThreadData->m_pHelperWindow);
	if (!m_pLocalAsyncSocketExThreadData->m_pHelperWindow)
		return;

	VERIFY(m_pLocalAsyncSocketExThreadData->m_pHelperWindow->RemoveSocket(this, m_SocketData.nSocketIndex));
	EMULE_CATCH
}

void CAsyncSocketEx::Close()
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		m_pFirstLayer->Close();
#endif //NOLAYERS
	if (m_SocketData.hSocket != INVALID_SOCKET)
	{
		VERIFY(closesocket(m_SocketData.hSocket) != SOCKET_ERROR);
		DetachHandle(m_SocketData.hSocket);
		m_SocketData.hSocket = INVALID_SOCKET;
	}
#ifndef NOLAYERS
	RemoveAllLayers();
#endif //NOLAYERS
	delete[] m_pAsyncGetHostByNameBuffer;
	m_pAsyncGetHostByNameBuffer = NULL;
	if (m_hAsyncGetHostByNameHandle)
	{
		WSACancelAsyncRequest(m_hAsyncGetHostByNameHandle);
		m_hAsyncGetHostByNameHandle = NULL;
	}
	EMULE_CATCH
}

BOOL CAsyncSocketEx::InitAsyncSocketExInstance()
{
	//Check if already initialized
	if (m_pLocalAsyncSocketExThreadData)
		return TRUE;

	DWORD id = GetCurrentThreadId();
	BOOL bResult = TRUE;
	m_sGlobalCriticalSection.Lock();

	try{
	    //Get thread specific data
	    if (m_spAsyncSocketExThreadDataList)
	    {
		    t_AsyncSocketExThreadDataList *pList = m_spAsyncSocketExThreadDataList;
		    while (pList)
		    {
			    ASSERT(pList->pThreadData);
			    ASSERT(pList->pThreadData->nInstanceCount > 0);
    
			    if (pList->pThreadData->nThreadId == id)
			    {
				    m_pLocalAsyncSocketExThreadData = pList->pThreadData;
				    m_pLocalAsyncSocketExThreadData->nInstanceCount++;
				    break;
			    }
			    pList = pList->pNext;
		    }
		    //Current thread yet has no sockets
		    if (!pList)
		    {
			    //Initialize data for current thread
			    pList = new t_AsyncSocketExThreadDataList;
			    pList->pNext = m_spAsyncSocketExThreadDataList;
			    m_spAsyncSocketExThreadDataList = pList;
			    m_pLocalAsyncSocketExThreadData = new t_AsyncSocketExThreadData;
			    m_pLocalAsyncSocketExThreadData->nInstanceCount = 1;
			    m_pLocalAsyncSocketExThreadData->nThreadId = id;
			    m_pLocalAsyncSocketExThreadData->m_pHelperWindow = new CAsyncSocketExHelperWindow;
			    m_spAsyncSocketExThreadDataList->pThreadData = m_pLocalAsyncSocketExThreadData;
		    }
	    }
	    else
	    {	//No thread has instances of CAsyncSocketEx; Initialize data
		    m_spAsyncSocketExThreadDataList = new t_AsyncSocketExThreadDataList;
		    m_spAsyncSocketExThreadDataList->pNext = 0;
		    m_pLocalAsyncSocketExThreadData = new t_AsyncSocketExThreadData;
		    m_pLocalAsyncSocketExThreadData->nInstanceCount = 1;
		    m_pLocalAsyncSocketExThreadData->nThreadId = id;
		    m_pLocalAsyncSocketExThreadData->m_pHelperWindow = new CAsyncSocketExHelperWindow;
		    m_spAsyncSocketExThreadDataList->pThreadData = m_pLocalAsyncSocketExThreadData;
	    }
	}
	catch(...){
		TRACE("Unknown exception in CAsyncSocketEx::InitAsyncSocketExInstance()\n");
		ASSERT(0);
		bResult = FALSE;
	}

	m_sGlobalCriticalSection.Unlock();

	return bResult;
}

void CAsyncSocketEx::FreeAsyncSocketExInstance()
{
	EMULE_TRY
	//Check if already freed
	if (!m_pLocalAsyncSocketExThreadData)
		return;

	DWORD id = m_pLocalAsyncSocketExThreadData->nThreadId;
	m_sGlobalCriticalSection.Lock();

	try{
	    ASSERT(m_spAsyncSocketExThreadDataList);
	    t_AsyncSocketExThreadDataList *pList = m_spAsyncSocketExThreadDataList;
	    t_AsyncSocketExThreadDataList *pPrev = 0;
    
	    //Search for data for current thread and decrease instance count
	    while (pList)
	    {
		    ASSERT(pList->pThreadData);
		    ASSERT(pList->pThreadData->nInstanceCount > 0);
    
		    if (pList->pThreadData->nThreadId == id)
		    {
			    ASSERT(m_pLocalAsyncSocketExThreadData == pList->pThreadData);
			    m_pLocalAsyncSocketExThreadData->nInstanceCount--;
    
			    //Freeing last instance?
			    //If so, destroy helper window
			    if (!m_pLocalAsyncSocketExThreadData->nInstanceCount)
			    {
				    delete m_pLocalAsyncSocketExThreadData->m_pHelperWindow;
				    delete m_pLocalAsyncSocketExThreadData;
				    if (pPrev)
					    pPrev->pNext = pList->pNext;
				    else
					    m_spAsyncSocketExThreadDataList = pList->pNext;
				    delete pList;
				    break;
			    }
			    break;
		    }
		    pPrev = pList;
		    pList = pList->pNext;
		    ASSERT(pList);
	    }
	}
	catch(...){
		TRACE("Unknown exception in CAsyncSocketEx::FreeAsyncSocketExInstance()\n");
		ASSERT(0);
	}

	m_sGlobalCriticalSection.Unlock();
	EMULE_CATCH
}

int CAsyncSocketEx::Receive(void* lpBuf, int nBufLen, int nFlags /*=0*/)
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->Receive(lpBuf, nBufLen, nFlags);
	else
#endif //NOLAYERS
		return recv(m_SocketData.hSocket, (LPSTR)lpBuf, nBufLen, nFlags);
	EMULE_CATCH
	return 0;
}

int CAsyncSocketEx::Send(const void* lpBuf, int nBufLen, int nFlags /*=0*/)
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->Send(lpBuf, nBufLen, nFlags);
	else
#endif //NOLAYERS
		return send(m_SocketData.hSocket, (LPSTR)lpBuf, nBufLen, nFlags);
	EMULE_CATCH
	return 0;
}

BOOL CAsyncSocketEx::Connect(LPCSTR lpszHostAddress, UINT nHostPort)
{
	ASSERT( lpszHostAddress != NULL );

	EMULE_TRY

#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->Connect(lpszHostAddress, nHostPort);
	else
#endif //NOLAYERS
	{
		SOCKADDR_IN sockAddr = {0};

		sockAddr.sin_addr.s_addr = inet_addr(lpszHostAddress);
		if (sockAddr.sin_addr.s_addr == INADDR_NONE)
		{
			m_pAsyncGetHostByNameBuffer = new char[MAXGETHOSTSTRUCT];
			m_nAsyncGetHostByNamePort = nHostPort;
			m_hAsyncGetHostByNameHandle = WSAAsyncGetHostByName(GetHelperWindowHandle(), WM_SOCKETEX_GETHOST, lpszHostAddress, m_pAsyncGetHostByNameBuffer, MAXGETHOSTSTRUCT);
			if (!m_hAsyncGetHostByNameHandle)
				return FALSE;
			WSASetLastError(WSAEWOULDBLOCK);
			return TRUE;
		}
		sockAddr.sin_family = AF_INET;
		sockAddr.sin_port = fast_htons((u_short)nHostPort);
		return CAsyncSocketEx::Connect((SOCKADDR*)&sockAddr, sizeof(sockAddr));
	}

	EMULE_CATCH

	return FALSE;
}

BOOL CAsyncSocketEx::Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->Connect(lpSockAddr, nSockAddrLen);
	else
#endif //NOLAYERS
		return connect(m_SocketData.hSocket, lpSockAddr, nSockAddrLen) != SOCKET_ERROR;
	EMULE_CATCH
	return FALSE;
}

#ifdef _AFX
BOOL CAsyncSocketEx::GetPeerName(CString& rPeerAddress, UINT& rPeerPort)
{
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->GetPeerName(rPeerAddress, rPeerPort);
#endif NOLAYERS

	SOCKADDR_IN sockAddr = {0};
	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetPeerName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		rPeerPort = fast_ntohs(sockAddr.sin_port);
		ipstr(&rPeerAddress, sockAddr.sin_addr);
	}
	return bResult;
}
#endif //AFX

BOOL CAsyncSocketEx::GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->GetPeerName(lpSockAddr, lpSockAddrLen);
#endif //NOLAYERS

	if (!getpeername(m_SocketData.hSocket, lpSockAddr, lpSockAddrLen))
		return TRUE;
	else
		return FALSE;
	EMULE_CATCH
	return FALSE;
}

#ifdef _AFX
BOOL CAsyncSocketEx::GetSockName(CString& rSocketAddress, UINT& rSocketPort)
{
	SOCKADDR_IN sockAddr = {0};
	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetSockName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		rSocketPort = fast_ntohs(sockAddr.sin_port);
		ipstr(&rSocketAddress, sockAddr.sin_addr);
	}
	return bResult;
}
#endif

BOOL CAsyncSocketEx::GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
{
	if (!getsockname(m_SocketData.hSocket, lpSockAddr, lpSockAddrLen))
		return TRUE;
	else
		return FALSE;
}

BOOL CAsyncSocketEx::ShutDown(int nHow /*=sends*/)
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
	{
		return m_pFirstLayer->ShutDown();
	}
	else
#endif
	{
		if (!shutdown(m_SocketData.hSocket, nHow))
			return TRUE;
		else
			return FALSE;
	}
	EMULE_CATCH
	return FALSE;
}

SOCKET CAsyncSocketEx::Detach()
{
	SOCKET socket = m_SocketData.hSocket;
	DetachHandle(socket);
	m_SocketData.hSocket = INVALID_SOCKET;
	return socket;
}

BOOL CAsyncSocketEx::Attach(SOCKET hSocket, long lEvent /*= FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE*/)
{
	if (hSocket == INVALID_SOCKET || !hSocket)
		return FALSE;

	VERIFY(InitAsyncSocketExInstance());
	m_SocketData.hSocket = hSocket;
	AttachHandle(hSocket);

	return AsyncSelect(lEvent);
}

BOOL CAsyncSocketEx::AsyncSelect(long lEvent /*= FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE*/)
{
	EMULE_TRY
	ASSERT(m_pLocalAsyncSocketExThreadData);
	m_lEvent = lEvent;
#ifndef NOLAYERS
	if (!m_pFirstLayer)
#endif //NOLAYERS
	{
		if (!WSAAsyncSelect(m_SocketData.hSocket, GetHelperWindowHandle(), m_SocketData.nSocketIndex + WM_SOCKETEX_NOTIFY, lEvent))
			return TRUE;
		else
			return FALSE;
	}
	return TRUE;
	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncSocketEx::Listen(int nConnectionBacklog /*=5*/)
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->Listen(nConnectionBacklog);
#endif //NOLAYERS

	if (!listen(m_SocketData.hSocket, nConnectionBacklog))
		return TRUE;
	else
		return FALSE;
	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncSocketEx::Accept(CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr /*=NULL*/, int* lpSockAddrLen /*=NULL*/)
{
	EMULE_TRY
	ASSERT(rConnectedSocket.m_SocketData.hSocket == INVALID_SOCKET);
#ifndef NOLAYERS
	if (m_pFirstLayer)
	{
		return m_pFirstLayer->Accept(rConnectedSocket, lpSockAddr, lpSockAddrLen);
	}
	else
#endif //NOLAYERS
	{
		SOCKET hTemp = accept(m_SocketData.hSocket, lpSockAddr, lpSockAddrLen);

		if (hTemp == INVALID_SOCKET)
			return FALSE;
		VERIFY(rConnectedSocket.InitAsyncSocketExInstance());
		rConnectedSocket.m_SocketData.hSocket=hTemp;
		rConnectedSocket.AttachHandle(hTemp);
	}
	return TRUE;
	EMULE_CATCH
	return FALSE;
}

BOOL CAsyncSocketEx::IOCtl(long lCommand, DWORD* lpArgument)
{
	return ioctlsocket(m_SocketData.hSocket, lCommand, lpArgument) != SOCKET_ERROR;
}

int CAsyncSocketEx::GetLastError()
{
	return WSAGetLastError();
}

BOOL CAsyncSocketEx::TriggerEvent(long lEvent)
{
	EMULE_TRY
	if (m_SocketData.hSocket == INVALID_SOCKET)
		return FALSE;

	ASSERT(m_pLocalAsyncSocketExThreadData);
	ASSERT(m_pLocalAsyncSocketExThreadData->m_pHelperWindow);
	ASSERT(m_SocketData.nSocketIndex != -1);

#ifndef NOLAYERS
	if (m_pFirstLayer)
	{
		CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg = new CAsyncSocketExLayer::t_LayerNotifyMsg;
		pMsg->lEvent = lEvent & 0xFFFF;
		pMsg->pLayer = 0;
		BOOL res = PostMessage(GetHelperWindowHandle(), WM_SOCKETEX_TRIGGER, (WPARAM)this, (LPARAM)pMsg);
		if (!res)
			delete pMsg;
		return res;
	}
	else
#endif //NOLAYERS
		return PostMessage(GetHelperWindowHandle(), m_SocketData.nSocketIndex + WM_SOCKETEX_NOTIFY, m_SocketData.hSocket, lEvent & 0xFFFF);

	EMULE_CATCH
	return FALSE;
}

SOCKET CAsyncSocketEx::GetSocketHandle()
{
	return m_SocketData.hSocket;
}

HWND CAsyncSocketEx::GetHelperWindowHandle()
{
	EMULE_TRY
	if (!m_pLocalAsyncSocketExThreadData)
		return 0;
	if (!m_pLocalAsyncSocketExThreadData->m_pHelperWindow)
		return 0;
	return m_pLocalAsyncSocketExThreadData->m_pHelperWindow->GetHwnd();
	EMULE_CATCH
	return NULL;
}

#ifndef NOLAYERS
BOOL CAsyncSocketEx::AddLayer(CAsyncSocketExLayer *pLayer)
{
	EMULE_TRY
	ASSERT(pLayer);
	if (m_SocketData.hSocket != INVALID_SOCKET)
		return FALSE;
	if (m_pFirstLayer)
	{
		ASSERT(m_pLastLayer);
		m_pLastLayer = m_pLastLayer->AddLayer(pLayer, this);
		return m_pLastLayer ? TRUE : FALSE;
	}
	else
	{
		ASSERT(!m_pLastLayer);
		pLayer->Init(0, this);
		m_pFirstLayer = pLayer;
		m_pLastLayer = m_pFirstLayer;
	}

	return TRUE;
	EMULE_CATCH
	return FALSE;
}

void CAsyncSocketEx::RemoveAllLayers()
{
	m_pFirstLayer = 0;
	m_pLastLayer = 0;
}

int CAsyncSocketEx::OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nCode, WPARAM wParam, LPARAM lParam)
{
	NOPRM(pLayer); NOPRM(nType); NOPRM(nCode); NOPRM(wParam); NOPRM(lParam);
	ASSERT(pLayer);
	return 1;
}
#endif //NOLAYERS

BOOL CAsyncSocketEx::GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel /*=SOL_SOCKET*/)
{
	return getsockopt(m_SocketData.hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen) != SOCKET_ERROR;
}

BOOL CAsyncSocketEx::SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel /*=SOL_SOCKET*/)
{
	return setsockopt(m_SocketData.hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, nOptionLen) != SOCKET_ERROR;
}
@


1.28
log
@dynIP server filtering from original.
@
text
@d161 1
a161 1
		if ((g_App.m_pPrefs->GetWindowsVersion() & 0x00FF) >= 0x0005)
d852 4
a855 9
			LPHOSTENT lphost = gethostbyname(lpszHostAddress);

			if (lphost != NULL)
			{
				sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
			}
			else
			{
				WSASetLastError(WSAEINVAL);
d857 2
a858 1
			}
a885 2
	EMULE_TRY
	return FALSE;
a899 2
	EMULE_CATCH
	return FALSE;
@


1.27
log
@Fast byte swap for ntohl and ntohs.
@
text
@d427 1
d432 1
a432 1
				sockAddr.sin_family=AF_INET;
d436 5
d595 6
@


1.26
log
@Minor updates according to last version original changes.
@
text
@d890 1
a890 1
		rPeerPort = ntohs(sockAddr.sin_port);
d923 1
a923 1
		rSocketPort = ntohs(sockAddr.sin_port);
@


1.25
log
@Faster (intrinsic) htonl and htons implementation.
@
text
@a65 3
#include "wtypes.h"
#include "oleauto.h"
#include "atlconv.h"
@


1.24
log
@Suppressed compiler warnings.
@
text
@d436 1
a436 1
				sockAddr.sin_port = htons(static_cast<u_short>(pSocket->m_nAsyncGetHostByNamePort));
d599 1
a599 1
		sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
d610 1
a610 1
	sockAddr.sin_port = htons((u_short)nSocketPort);
d856 1
a856 1
		sockAddr.sin_port = htons((u_short)nHostPort);
@


1.23
log
@improved the socket handling
@
text
@d413 1
a413 1
				CAsyncSocketEx	*pSocket;
d569 1
d574 1
d579 1
d584 1
d589 1
d630 2
d640 2
d1131 1
a1131 1
	UNREFERENCED_PARAMETER(pLayer);
@


1.22
log
@Unicode preparations.
@
text
@d122 5
d159 10
a168 1
		m_hWnd = CreateWindow(_T("CAsyncSocketEx Helper Window"), _T("CAsyncSocketEx Helper Window"), 0, 0, 0, 0, 0, 0, 0, 0, GetModuleHandle(0));
@


1.21
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues.
@
text
@d871 1
a871 1
		rPeerAddress = inet_ntoa(sockAddr.sin_addr);
d904 1
a904 1
		rSocketAddress = inet_ntoa(sockAddr.sin_addr);
@


1.20
log
@Compatibility with VC2005 [brengarne].
@
text
@d30 1
a30 1
sockets within one thread. When the window recieve WM_SOCKET_NOTIFY, wParam
d111 1
a111 1
CAsyncSocketEx::t_AsyncSocketExThreadDataList *CAsyncSocketEx::m_spAsyncSocketExThreadDataList=0;
d132 5
a136 5
		m_pAsyncSocketExWindowData=new t_AsyncSocketExWindowData[512]; //Reserve space for 512 active sockets
		memzero(m_pAsyncSocketExWindowData, 512*sizeof(t_AsyncSocketExWindowData));
		m_nWindowDataSize=512;
		m_nSocketCount=0;
		m_nWindowDataPos=0;
d140 12
a151 13
		wndclass.cbSize=sizeof wndclass;
		wndclass.style=0;
		wndclass.lpfnWndProc=WindowProc;
		wndclass.cbClsExtra=0;
		wndclass.cbWndExtra=0;
		wndclass.hInstance=GetModuleHandle(0);
		wndclass.hIcon=0;
		wndclass.hCursor=0;
		wndclass.hbrBackground=0;
		wndclass.lpszMenuName=0;
		wndclass.lpszClassName=_T("CAsyncSocketEx Helper Window");
		wndclass.hIconSm=0;

d154 1
a154 1
		m_hWnd=CreateWindow(_T("CAsyncSocketEx Helper Window"), _T("CAsyncSocketEx Helper Window"), 0, 0, 0, 0, 0, 0, 0, 0, GetModuleHandle(0));
d164 4
a167 4
		delete [] m_pAsyncSocketExWindowData;
		m_pAsyncSocketExWindowData=0;
		m_nWindowDataSize=0;
		m_nSocketCount=0;
d173 1
a173 1
			m_hWnd=0;
d186 3
a188 3
			m_nWindowDataSize=512;
			m_pAsyncSocketExWindowData=new t_AsyncSocketExWindowData[512]; //Reserve space for 512 active sockets
			memzero(m_pAsyncSocketExWindowData, 512*sizeof(t_AsyncSocketExWindowData));
d191 1
a191 1
		if (nSocketIndex!=-1)
d195 1
a195 1
			ASSERT(m_pAsyncSocketExWindowData[nSocketIndex].m_pSocket==pSocket);
d201 1
a201 1
		if (m_nSocketCount>=(m_nWindowDataSize-10))
d203 7
a209 6
			int nOldWindowDataSize=m_nWindowDataSize;
			ASSERT(m_nWindowDataSize<MAX_SOCKETS);
			m_nWindowDataSize+=512;
			if (m_nWindowDataSize>MAX_SOCKETS)
				m_nWindowDataSize=MAX_SOCKETS;
			t_AsyncSocketExWindowData *tmp=m_pAsyncSocketExWindowData;
d212 2
a213 2
			memzero(m_pAsyncSocketExWindowData+nOldWindowDataSize, (m_nWindowDataSize-nOldWindowDataSize)*sizeof(t_AsyncSocketExWindowData));
			delete [] tmp;
d217 1
a217 1
		for (int i=m_nWindowDataPos;i<(m_nWindowDataSize+m_nWindowDataPos);i++)
d219 1
a219 1
			if (!m_pAsyncSocketExWindowData[i%m_nWindowDataSize].m_pSocket)
d221 3
a223 3
				m_pAsyncSocketExWindowData[i%m_nWindowDataSize].m_pSocket=pSocket;
				nSocketIndex=i%m_nWindowDataSize;
				m_nWindowDataPos=(i+1)%m_nWindowDataSize;
d237 1
d240 2
a241 1
		if (nSocketIndex==-1)
d245 5
a249 5
		ASSERT(m_nWindowDataSize>0);
		ASSERT(m_nSocketCount>0);
		ASSERT(m_pAsyncSocketExWindowData[nSocketIndex].m_pSocket==pSocket);
		m_pAsyncSocketExWindowData[nSocketIndex].m_pSocket=0;
		nSocketIndex=-1;
d258 1
a258 1
	static LRESULT CALLBACK WindowProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
d262 1
a262 1
			if (message>=WM_SOCKETEX_NOTIFY)
d266 1
a266 1
				CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLong(hWnd, GWL_USERDATA);
d269 1
a269 1
				if (message<static_cast<UINT>(WM_SOCKETEX_NOTIFY+pWnd->m_nWindowDataSize)) //Index is within socket storage
d272 2
a273 2
					CAsyncSocketEx *pSocket=pWnd->m_pAsyncSocketExWindowData[message-WM_SOCKETEX_NOTIFY].m_pSocket;
					SOCKET hSocket=wParam;
d276 1
a276 1
					if (hSocket==INVALID_SOCKET)
d278 1
a278 1
					if (pSocket->m_SocketData.hSocket!=hSocket)
d281 2
a282 2
					int nEvent=lParam&0xFFFF;
					int nErrorCode=lParam>>16;
d292 1
a292 1
						case FD_READ:
d299 1
d301 15
a315 16
							break;
						case FD_FORCEREAD: //Forceread does not check if there's data waiting
							pSocket->OnReceive(nErrorCode);
							break;
						case FD_WRITE:
							pSocket->OnSend(nErrorCode);
							break;
						case FD_CONNECT:
							pSocket->OnConnect(nErrorCode);
							break;
						case FD_ACCEPT:
							pSocket->OnAccept(nErrorCode);
							break;
						case FD_CLOSE:
							pSocket->OnClose(nErrorCode);
							break;
d321 1
a321 1
						if (nEvent==FD_READ)
d337 1
a337 1
			else if (message==WM_SOCKETEX_TRIGGER) //Notification event sent by a layer
d342 3
a344 3
				CAsyncSocketEx *pSocket=(CAsyncSocketEx *)wParam;
				CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg=(CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;
				if (pSocket->m_SocketData.hSocket==INVALID_SOCKET)
d349 2
a350 2
				int nEvent=pMsg->lEvent&0xFFFF;
				int nErrorCode=pMsg->lEvent>>16;
d360 24
a383 24
					case FD_READ:
						if (pSocket->m_lEvent&FD_READ)
							pSocket->OnReceive(nErrorCode);
						break;
					case FD_FORCEREAD:
						if (pSocket->m_lEvent&FD_FORCEREAD)
							pSocket->OnReceive(nErrorCode);
						break;
					case FD_WRITE:
						if (pSocket->m_lEvent&FD_WRITE)
							pSocket->OnSend(nErrorCode);
						break;
					case FD_CONNECT:
						if (pSocket->m_lEvent&FD_CONNECT)
							pSocket->OnConnect(nErrorCode);
						break;
					case FD_ACCEPT:
						if (pSocket->m_lEvent&FD_ACCEPT)
							pSocket->OnAccept(nErrorCode);
						break;
					case FD_CLOSE:
						if (pSocket->m_lEvent&FD_CLOSE)
							pSocket->OnClose(nErrorCode);
						break;
d396 1
a396 1
				CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLong(hWnd, GWL_USERDATA);
d419 1
a419 2
				SOCKADDR_IN sockAddr;
				memzero(&sockAddr, sizeof(sockAddr));
d422 1
d424 4
a427 1
				sockAddr.sin_port = htons(pSocket->m_nAsyncGetHostByNamePort);
d429 2
a430 8
				BOOL res = pSocket->Connect((SOCKADDR*)&sockAddr, sizeof(sockAddr));
				delete [] pSocket->m_pAsyncGetHostByNameBuffer;
				pSocket->m_pAsyncGetHostByNameBuffer=0;
				pSocket->m_hAsyncGetHostByNameHandle=0;

				if (!res)
					if (GetLastError()!=WSAEWOULDBLOCK)
						pSocket->OnConnect(GetLastError());
d439 1
a439 1
			LPCTSTR pszClassName = (pRuntimeClass) ? pRuntimeClass->m_lpszClassName : NULL;
d441 2
a442 2
				pszClassName = _T("CException");
			TRACE("*** Unknown %s exception in CAsyncSocketExHelperWindow::WindowProc - %s\n", pszClassName, szError);
d475 3
a477 3
	m_SocketData.hSocket=INVALID_SOCKET;
	m_SocketData.nSocketIndex=-1;
	m_pLocalAsyncSocketExThreadData=0;
d479 2
a480 2
	m_pFirstLayer=0;
	m_pLastLayer=0;
d492 3
a494 1
BOOL CAsyncSocketEx::Create( UINT nSocketPort /*=0*/, int nSocketType /*=SOCK_STREAM*/, long lEvent /*=FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE*/, LPCTSTR lpszSocketAddress /*=NULL*/ )
d506 1
a506 3
	BOOL res=InitAsyncSocketExInstance();
	ASSERT(res);
	if (!res)
d508 1
d519 2
a520 2
		SOCKET hSocket=socket(AF_INET, nSocketType, 0);
		if (hSocket==INVALID_SOCKET)
d522 2
a523 1
		m_SocketData.hSocket=hSocket;
d533 1
a533 1
			if (WSAAsyncSelect(m_SocketData.hSocket, GetHelperWindowHandle(), m_SocketData.nSocketIndex+WM_SOCKETEX_NOTIFY, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE) )
a545 1
		return TRUE;
d547 2
a552 2


d573 1
a573 1
BOOL CAsyncSocketEx::Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress)
a575 1
	USES_CONVERSION;
d577 1
a577 2
	SOCKADDR_IN sockAddr;
	memzero(&sockAddr, sizeof(sockAddr));
d579 1
a579 4
	LPSTR lpszAscii = T2A((LPTSTR)lpszSocketAddress);
	sockAddr.sin_family = AF_INET;

	if (lpszAscii == NULL)
d583 2
a584 2
		DWORD lResult = inet_addr(lpszAscii);
		if (lResult == INADDR_NONE)
a588 1
		sockAddr.sin_addr.s_addr = lResult;
d590 1
a590 1

d592 1
a593 1
	return Bind((SOCKADDR*)&sockAddr, sizeof(sockAddr));
d623 1
d627 1
d641 1
a641 1
		VERIFY(closesocket(m_SocketData.hSocket)!=SOCKET_ERROR);
d643 1
a643 1
		m_SocketData.hSocket=INVALID_SOCKET;
d648 1
a648 1
	delete [] m_pAsyncGetHostByNameBuffer;
d651 1
d653 2
a654 1
	m_hAsyncGetHostByNameHandle = NULL;
d664 1
a664 2
	DWORD id=GetCurrentThreadId();

d672 1
a672 1
		    t_AsyncSocketExThreadDataList *pList=m_spAsyncSocketExThreadDataList;
d676 1
a676 1
			    ASSERT(pList->pThreadData->nInstanceCount>0);
d678 1
a678 1
			    if (pList->pThreadData->nThreadId==id)
d680 1
a680 1
				    m_pLocalAsyncSocketExThreadData=pList->pThreadData;
d684 1
a684 1
			    pList=pList->pNext;
d690 8
a697 8
			    pList=new t_AsyncSocketExThreadDataList;
			    pList->pNext=m_spAsyncSocketExThreadDataList;
			    m_spAsyncSocketExThreadDataList=pList;
			    m_pLocalAsyncSocketExThreadData=new t_AsyncSocketExThreadData;
			    m_pLocalAsyncSocketExThreadData->nInstanceCount=1;
			    m_pLocalAsyncSocketExThreadData->nThreadId=id;
			    m_pLocalAsyncSocketExThreadData->m_pHelperWindow=new CAsyncSocketExHelperWindow;
			    m_spAsyncSocketExThreadDataList->pThreadData=m_pLocalAsyncSocketExThreadData;
d702 7
a708 7
		    m_spAsyncSocketExThreadDataList=new t_AsyncSocketExThreadDataList;
		    m_spAsyncSocketExThreadDataList->pNext=0;
		    m_pLocalAsyncSocketExThreadData=new t_AsyncSocketExThreadData;
		    m_pLocalAsyncSocketExThreadData->nInstanceCount=1;
		    m_pLocalAsyncSocketExThreadData->nThreadId=id;
		    m_pLocalAsyncSocketExThreadData->m_pHelperWindow=new CAsyncSocketExHelperWindow;
		    m_spAsyncSocketExThreadDataList->pThreadData=m_pLocalAsyncSocketExThreadData;
d729 1
a729 1
	DWORD id=m_pLocalAsyncSocketExThreadData->nThreadId;
d734 2
a735 2
	    t_AsyncSocketExThreadDataList *pList=m_spAsyncSocketExThreadDataList;
	    t_AsyncSocketExThreadDataList *pPrev=0;
d737 1
a737 1
	    //Serach for data for current thread and decrease instance count
d741 1
a741 1
		    ASSERT(pList->pThreadData->nInstanceCount>0);
d743 1
a743 1
		    if (pList->pThreadData->nThreadId==id)
d745 1
a745 1
			    ASSERT(m_pLocalAsyncSocketExThreadData==pList->pThreadData);
d755 1
a755 1
					    pPrev->pNext=pList->pNext;
d757 1
a757 1
					    m_spAsyncSocketExThreadDataList=pList->pNext;
a760 1
    
d763 2
a764 2
		    pPrev=pList;
		    pList=pList->pNext;
a789 1

d803 1
a803 1
BOOL CAsyncSocketEx::Connect(LPCTSTR lpszHostAddress, UINT nHostPort)
d805 2
d815 1
a815 10
		USES_CONVERSION;

		ASSERT(lpszHostAddress != NULL);

		SOCKADDR_IN sockAddr;
		memzero(&sockAddr, sizeof(sockAddr));

		LPSTR lpszAscii = T2A((LPTSTR)lpszHostAddress);
		sockAddr.sin_family = AF_INET;
		sockAddr.sin_addr.s_addr = inet_addr(lpszAscii);
d817 1
d820 2
a821 2
			LPHOSTENT lphost;
			lphost = gethostbyname(lpszAscii);
d832 1
a832 1

a833 1

d842 1
a842 1
BOOL CAsyncSocketEx::Connect( const SOCKADDR* lpSockAddr, int nSockAddrLen )
d850 1
a850 1
		return SOCKET_ERROR!=connect(m_SocketData.hSocket, lpSockAddr, nSockAddrLen);
a854 1

d856 1
a856 1
BOOL CAsyncSocketEx::GetPeerName( CString& rPeerAddress, UINT& rPeerPort )
d865 1
a865 3
	SOCKADDR_IN sockAddr;
	memzero(&sockAddr, sizeof(sockAddr));

d879 1
a879 1
BOOL CAsyncSocketEx::GetPeerName( SOCKADDR* lpSockAddr, int* lpSockAddrLen )
d887 1
a887 1
	if ( !getpeername(m_SocketData.hSocket, lpSockAddr, lpSockAddrLen) )
d898 1
a898 4
	EMULE_TRY
	SOCKADDR_IN sockAddr;
	memzero(&sockAddr, sizeof(sockAddr));

a906 2
	EMULE_CATCH
	return FALSE;
d910 1
a910 1
BOOL CAsyncSocketEx::GetSockName( SOCKADDR* lpSockAddr, int* lpSockAddrLen )
d912 1
a912 2
	EMULE_TRY
	if ( !getsockname(m_SocketData.hSocket, lpSockAddr, lpSockAddrLen) )
a915 2
	EMULE_CATCH
	return FALSE;
d918 1
a918 1
BOOL CAsyncSocketEx::ShutDown( int nHow /*=sends*/ )
d929 1
a929 1
		if ( !shutdown(m_SocketData.hSocket, nHow) )
d938 1
a938 1
SOCKET CAsyncSocketEx::Detach( )
d940 1
a940 2
	EMULE_TRY
	SOCKET socket=m_SocketData.hSocket;
d942 1
a942 1
	m_SocketData.hSocket=INVALID_SOCKET;
a943 2
	EMULE_CATCH
	return NULL;
d946 1
a946 1
BOOL CAsyncSocketEx::Attach( SOCKET hSocket, long lEvent /*= FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE*/ )
d948 1
a948 2
	EMULE_TRY
	if (hSocket==INVALID_SOCKET || !hSocket)
d952 1
a952 1
	m_SocketData.hSocket=hSocket;
a955 2
	EMULE_CATCH
	return FALSE;
d958 1
a958 1
BOOL CAsyncSocketEx::AsyncSelect( long lEvent /*= FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE*/ )
d962 1
a962 1
	m_lEvent=lEvent;
d967 1
a967 1
		if ( !WSAAsyncSelect(m_SocketData.hSocket, GetHelperWindowHandle(), m_SocketData.nSocketIndex+WM_SOCKETEX_NOTIFY, lEvent) )
d977 1
a977 1
BOOL CAsyncSocketEx::Listen( int nConnectionBacklog /*=5*/ )
d993 1
a993 1
BOOL CAsyncSocketEx::Accept( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr /*=NULL*/, int* lpSockAddrLen /*=NULL*/ )
d1018 1
a1018 1
BOOL CAsyncSocketEx::IOCtl( long lCommand, DWORD* lpArgument )
a1019 1
	EMULE_TRY
a1020 2
	EMULE_CATCH
	return FALSE;
a1024 1
	EMULE_TRY
a1025 2
	EMULE_CATCH
	return -1;
d1031 1
a1031 1
	if (m_SocketData.hSocket==INVALID_SOCKET)
d1036 1
a1036 1
	ASSERT(m_SocketData.nSocketIndex!=-1);
d1041 4
a1044 4
		CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg=new CAsyncSocketExLayer::t_LayerNotifyMsg;
		pMsg->lEvent=lEvent%0xFFFF;
		pMsg->pLayer=0;
		BOOL res=PostMessage(GetHelperWindowHandle(), WM_SOCKETEX_TRIGGER, (WPARAM)this, (LPARAM)pMsg);
d1051 1
a1051 1
		return PostMessage(GetHelperWindowHandle(), m_SocketData.nSocketIndex+WM_SOCKETEX_NOTIFY, m_SocketData.hSocket, lEvent%0xFFFF);
a1058 1
	EMULE_TRY
a1059 2
	EMULE_CATCH
	return NULL;
d1079 1
a1079 1
	if (m_SocketData.hSocket!=INVALID_SOCKET)
d1084 2
a1085 2
		m_pLastLayer=m_pLastLayer->AddLayer(pLayer, this);
		return m_pLastLayer?TRUE:FALSE;
d1091 2
a1092 2
		m_pFirstLayer=pLayer;
		m_pLastLayer=m_pFirstLayer;
d1102 2
a1103 4
	EMULE_TRY
	m_pFirstLayer=0;
	m_pLastLayer=0;
	EMULE_CATCH
d1106 1
a1106 1
int CAsyncSocketEx::OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2)
d1108 1
a1108 1
	EMULE_TRY
a1109 1
	EMULE_CATCH
d1116 1
a1116 1
	return (SOCKET_ERROR != getsockopt(m_SocketData.hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen));
d1121 1
a1121 1
	return (SOCKET_ERROR != setsockopt(m_SocketData.hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, nOptionLen));
@


1.19
log
@minor changes
@
text
@d397 4
a400 2
				CAsyncSocketEx *pSocket;
				for (int i=0; i<pWnd->m_nWindowDataSize; i++)
@


1.18
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@a408 1
				int len = lParam % 0xFFFF;
@


1.17
log
@Fix for serverlist sort & reverted a change that rendered the dyndns connection unusable
@
text
@d133 1
a133 1
		memset2(m_pAsyncSocketExWindowData, 0, 512*sizeof(t_AsyncSocketExWindowData));
d189 1
a189 1
			memset2(m_pAsyncSocketExWindowData, 0, 512*sizeof(t_AsyncSocketExWindowData));
d212 1
a212 1
			memset2(m_pAsyncSocketExWindowData+nOldWindowDataSize, 0, (m_nWindowDataSize-nOldWindowDataSize)*sizeof(t_AsyncSocketExWindowData));
d417 1
a417 1
				memset2(&sockAddr,0,sizeof(sockAddr));
d578 1
a578 1
	memset2(&sockAddr,0,sizeof(sockAddr));
d822 1
a822 1
		memset2(&sockAddr,0,sizeof(sockAddr));
d878 1
a878 1
	memset2(&sockAddr, 0, sizeof(sockAddr));
d914 1
a914 1
	memset2(&sockAddr, 0, sizeof(sockAddr));
@


1.16
log
@return NULL outside try & catch
@
text
@d810 1
d830 9
a838 6
			m_pAsyncGetHostByNameBuffer=new char[MAXGETHOSTSTRUCT];

			m_nAsyncGetHostByNamePort=nHostPort;

			m_hAsyncGetHostByNameHandle=WSAAsyncGetHostByName(GetHelperWindowHandle(), WM_SOCKETEX_GETHOST, lpszAscii, m_pAsyncGetHostByNameBuffer, MAXGETHOSTSTRUCT);
			if (!m_hAsyncGetHostByNameHandle)
d840 1
a840 3

			WSASetLastError(WSAEWOULDBLOCK);
			return TRUE;
d847 1
d849 1
@


1.15
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d1092 1
@


1.14
log
@Katsyonak update
@
text
@d133 1
a133 1
		memset(m_pAsyncSocketExWindowData, 0, 512*sizeof(t_AsyncSocketExWindowData));
d189 1
a189 1
			memset(m_pAsyncSocketExWindowData, 0, 512*sizeof(t_AsyncSocketExWindowData));
d212 1
a212 1
			memset(m_pAsyncSocketExWindowData+nOldWindowDataSize, 0, (m_nWindowDataSize-nOldWindowDataSize)*sizeof(t_AsyncSocketExWindowData));
d417 1
a417 1
				memset(&sockAddr,0,sizeof(sockAddr));
d578 1
a578 1
	memset(&sockAddr,0,sizeof(sockAddr));
d821 1
a821 1
		memset(&sockAddr,0,sizeof(sockAddr));
d874 1
a874 1
	memset(&sockAddr, 0, sizeof(sockAddr));
d910 1
a910 1
	memset(&sockAddr, 0, sizeof(sockAddr));
@


1.13
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d8 3
a10 3
CAsyncSocketEx is a replacement for the MFC class CAsyncSocket. 
This class was written because CAsyncSocket is not the fastest WinSock 
wrapper and it's very hard to add new functionality to CAsyncSocket 
d27 1
a27 1
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with 
d34 1
a34 1
a different message to WSAAsyncSelect for each socket. When a message in 
d37 1
a37 1
As you can see, CAsyncSocketEx uses the helper window in a more efficient 
d41 1
a41 1
Please note that the changes do not affect the raw data throughput rate, 
d103 1
a103 1
}
d139 13
a151 13
		WNDCLASSEX wndclass; 
		wndclass.cbSize=sizeof wndclass; 
		wndclass.style=0; 
		wndclass.lpfnWndProc=WindowProc; 
		wndclass.cbClsExtra=0; 
		wndclass.cbWndExtra=0; 
		wndclass.hInstance=GetModuleHandle(0); 
		wndclass.hIcon=0; 
		wndclass.hCursor=0; 
		wndclass.hbrBackground=0; 
		wndclass.lpszMenuName=0; 
		wndclass.lpszClassName=_T("CAsyncSocketEx Helper Window"); 
		wndclass.hIconSm=0; 
d178 1
a178 1
	
d189 1
a189 1
			memset(m_pAsyncSocketExWindowData, 0, 512*sizeof(t_AsyncSocketExWindowData));		
d200 1
a200 1
		
d233 1
a233 1
	
d258 1
a258 2
		EMULE_TRY
		if (message>=WM_SOCKETEX_NOTIFY)
d260 1
a260 6
			//Verify parameters
			ASSERT(hWnd);
			CAsyncSocketExHelperWindow *pWnd=(CAsyncSocketExHelperWindow *)GetWindowLong(hWnd, GWL_USERDATA);
			ASSERT(pWnd);

			if (message<static_cast<UINT>(WM_SOCKETEX_NOTIFY+pWnd->m_nWindowDataSize)) //Index is within socket storage
d262 4
a265 14
				try
				{
				//Lookup socket and verify if it's valid
				CAsyncSocketEx *pSocket=pWnd->m_pAsyncSocketExWindowData[message-WM_SOCKETEX_NOTIFY].m_pSocket;
				SOCKET hSocket=wParam;
				if (!pSocket)
					return 0;
				if (hSocket==INVALID_SOCKET)
					return 0;
				if (pSocket->m_SocketData.hSocket!=hSocket)
					return 0;
				
				int nEvent=lParam&0xFFFF;
				int nErrorCode=lParam>>16;
d267 1
a267 3
				//Dispatch notification
#ifndef NOLAYERS
				if (!pSocket->m_pFirstLayer)
d269 49
a317 3
#endif //NOLAYERS
					//Dispatch to CAsyncSocketEx instance
					switch (nEvent)
d319 1
a319 1
					case FD_READ:
d325 1
a325 1
								pSocket->OnReceive(nErrorCode);
d327 34
d362 3
a364 2
					case FD_FORCEREAD: //Forceread does not check if there's data waiting
						pSocket->OnReceive(nErrorCode);
d367 2
a368 1
						pSocket->OnSend(nErrorCode);
d371 2
a372 1
						pSocket->OnConnect(nErrorCode);
d375 2
a376 1
						pSocket->OnAccept(nErrorCode);
d379 2
a380 1
						pSocket->OnClose(nErrorCode);
a383 29
#ifndef NOLAYERS
				else //Dispatch notification to the lowest layer
				{
					if (nEvent==FD_READ)
					{
						DWORD nBytes;
						if (!pSocket->IOCtl(FIONREAD, &nBytes))
							nErrorCode = WSAGetLastError();
						if (nBytes != 0 || nErrorCode != 0)
							pSocket->m_pLastLayer->CallEvent(nEvent, nErrorCode);
					}
					else
						pSocket->m_pLastLayer->CallEvent(nEvent, nErrorCode);
				}
	#endif //NOLAYERS
			} catch (...) {return 0;}
			}
			return 0;
		}
#ifndef NOLAYERS
			else if (message==WM_SOCKETEX_TRIGGER) //Notification event sent by a layer
		{
			//Verify parameters, lookup socket and notification message
			if (!wParam)
				return 0;
			CAsyncSocketEx *pSocket=(CAsyncSocketEx *)wParam;
			CAsyncSocketExLayer::t_LayerNotifyMsg *pMsg=(CAsyncSocketExLayer::t_LayerNotifyMsg *)lParam;
			if (pSocket->m_SocketData.hSocket==INVALID_SOCKET)
			{
d387 1
a387 41
			int nEvent=pMsg->lEvent&0xFFFF;
			int nErrorCode=pMsg->lEvent>>16;
			
			//Dispatch to layer
			if (pMsg->pLayer)
				pMsg->pLayer->CallEvent(nEvent, nErrorCode);
			else
			{
				//Dispatch to socket class
				switch (nEvent)
				{
				case FD_READ:
					if (pSocket->m_lEvent&FD_READ)
						pSocket->OnReceive(nErrorCode);
					break;
				case FD_FORCEREAD:
					if (pSocket->m_lEvent&FD_FORCEREAD)
						pSocket->OnReceive(nErrorCode);
					break;
				case FD_WRITE:
						if (pSocket->m_lEvent&FD_WRITE)
						pSocket->OnSend(nErrorCode);
					break;
				case FD_CONNECT:
					if (pSocket->m_lEvent&FD_CONNECT)
						pSocket->OnConnect(nErrorCode);
					break;
				case FD_ACCEPT:
					if (pSocket->m_lEvent&FD_ACCEPT)
						pSocket->OnAccept(nErrorCode);
					break;
				case FD_CLOSE:
					if (pSocket->m_lEvent&FD_CLOSE)
						pSocket->OnClose(nErrorCode);
					break;
				}
			}
			delete pMsg;
			return 0;
		}
#endif //NOLAYERS
d433 17
a449 2
		return DefWindowProc(hWnd, message, wParam, lParam);
		EMULE_CATCH
d495 1
d503 1
a503 1
	
d618 1
a618 1
	VERIFY(m_pLocalAsyncSocketExThreadData->m_pHelperWindow->AddSocket(this, m_SocketData.nSocketIndex));	
d631 1
a631 1
	VERIFY(m_pLocalAsyncSocketExThreadData->m_pHelperWindow->RemoveSocket(this, m_SocketData.nSocketIndex));	
d644 1
a644 1
		VERIFY (closesocket(m_SocketData.hSocket)!=SOCKET_ERROR);
d649 1
a649 1
	RemoveAllLayers();	
a660 1
	EMULE_TRY
d667 1
d670 47
a716 40
	//Get thread specific data
	if (m_spAsyncSocketExThreadDataList)
	{
		t_AsyncSocketExThreadDataList *pList=m_spAsyncSocketExThreadDataList;
		while (pList)
		{
			ASSERT(pList->pThreadData);
			ASSERT(pList->pThreadData->nInstanceCount>0);
			
			if (pList->pThreadData->nThreadId==id)
			{
				m_pLocalAsyncSocketExThreadData=pList->pThreadData;
				m_pLocalAsyncSocketExThreadData->nInstanceCount++;
				break;
			}
			pList=pList->pNext;
		}
		//Current thread yet has no sockets
		if (!pList)
		{
			//Initialize data for current thread
			pList=new t_AsyncSocketExThreadDataList;
			pList->pNext=m_spAsyncSocketExThreadDataList;
			m_spAsyncSocketExThreadDataList=pList;
			m_pLocalAsyncSocketExThreadData=new t_AsyncSocketExThreadData;
			m_pLocalAsyncSocketExThreadData->nInstanceCount=1;
			m_pLocalAsyncSocketExThreadData->nThreadId=id;
			m_pLocalAsyncSocketExThreadData->m_pHelperWindow=new CAsyncSocketExHelperWindow;
			m_spAsyncSocketExThreadDataList->pThreadData=m_pLocalAsyncSocketExThreadData;		
		}
	}
	else
	{	//No thread has instances of CAsyncSocketEx; Initialize data
		m_spAsyncSocketExThreadDataList=new t_AsyncSocketExThreadDataList;
		m_spAsyncSocketExThreadDataList->pNext=0;
		m_pLocalAsyncSocketExThreadData=new t_AsyncSocketExThreadData;
		m_pLocalAsyncSocketExThreadData->nInstanceCount=1;
		m_pLocalAsyncSocketExThreadData->nThreadId=id;
		m_pLocalAsyncSocketExThreadData->m_pHelperWindow=new CAsyncSocketExHelperWindow;
		m_spAsyncSocketExThreadDataList->pThreadData=m_pLocalAsyncSocketExThreadData;		
d718 1
d720 2
a721 3
	return TRUE;
	EMULE_CATCH
	return FALSE;
d734 40
a773 34
	ASSERT(m_spAsyncSocketExThreadDataList);
	t_AsyncSocketExThreadDataList *pList=m_spAsyncSocketExThreadDataList;
	t_AsyncSocketExThreadDataList *pPrev=0;

	//Serach for data for current thread and decrease instance count
	while (pList)
	{
		ASSERT(pList->pThreadData);
		ASSERT(pList->pThreadData->nInstanceCount>0);
		
		if (pList->pThreadData->nThreadId==id)
		{
			ASSERT(m_pLocalAsyncSocketExThreadData==pList->pThreadData);
			m_pLocalAsyncSocketExThreadData->nInstanceCount--;

			//Freeing last instance?
			//If so, destroy helper window
			if (!m_pLocalAsyncSocketExThreadData->nInstanceCount)
			{
				delete m_pLocalAsyncSocketExThreadData->m_pHelperWindow;
				delete m_pLocalAsyncSocketExThreadData;
				if (pPrev)
					pPrev->pNext=pList->pNext;
				else
					m_spAsyncSocketExThreadDataList=pList->pNext;
				delete pList;
				break;
			}
			
			break;
		}
		pPrev=pList;
		pList=pList->pNext;
		ASSERT(pList);
d792 1
a792 1
	
d817 1
a817 1
		
d819 1
a819 1
		
d822 1
a822 1
		
d826 1
a826 1
		
d840 1
a840 1
		
d842 1
a842 1
		
d861 1
a861 1
	
d947 4
a950 4
	if ( !shutdown(m_SocketData.hSocket, nHow) )
		return TRUE;
	else
		return FALSE;
d977 1
a977 1
	return AsyncSelect(lEvent);	
d1025 1
a1025 1
	}	
d1030 1
a1030 1
	
d1067 2
a1068 2
	
#ifndef NOLAYERS	
d1082 1
a1082 1
	
a1157 175

// By Maverick
int CAsyncSocketEx::ReceiveFrom(void* lpBuf, int nBufLen, CString& rSocketAddress, UINT& rSocketPort, int nFlags)
{
	EMULE_TRY
	SOCKADDR_IN sockAddr;

	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	int nResult = ReceiveFrom(lpBuf, nBufLen, (SOCKADDR*)&sockAddr, &nSockAddrLen, nFlags);
	if(nResult != SOCKET_ERROR)
	{
		rSocketPort = ntohs(sockAddr.sin_port);
		rSocketAddress = inet_ntoa(sockAddr.sin_addr);
	}
	return nResult;
	EMULE_CATCH
	return FALSE;
}

int CAsyncSocketEx::SendTo(const void* lpBuf, int nBufLen, UINT nHostPort, LPCTSTR lpszHostAddress, int nFlags)
{
	EMULE_TRY
	USES_CONVERSION;
 
	SOCKADDR_IN sockAddr;

	memset(&sockAddr,0,sizeof(sockAddr));

	LPSTR lpszAscii = T2A((LPTSTR)lpszHostAddress);
	sockAddr.sin_family = AF_INET;

	if (lpszAscii == NULL)
		sockAddr.sin_addr.s_addr = htonl(INADDR_BROADCAST);
	else
	{
		sockAddr.sin_addr.s_addr = inet_addr(lpszAscii);
		if (sockAddr.sin_addr.s_addr == INADDR_NONE)
		{
			LPHOSTENT lphost;
			lphost = gethostbyname(lpszAscii);
			if (lphost != NULL)
				sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
			else
			{
				WSASetLastError(WSAEINVAL);
				return SOCKET_ERROR;
			}
		}
	}

	sockAddr.sin_port = htons((u_short)nHostPort);

	return SendTo(lpBuf, nBufLen, (SOCKADDR*)&sockAddr, sizeof(sockAddr), nFlags);
	EMULE_CATCH
	return 0;
}


CAsyncSocketEx* PASCAL CAsyncSocketEx::LookupHandle(SOCKET hSocket, BOOL bDead)
{
	EMULE_TRY
	CAsyncSocketEx* pSocket;
	_AFX_SOCK_THREAD_STATE* pState = _afxSockThreadState;
	if (!bDead)
	{
		pSocket = (CAsyncSocketEx*)
			pState->m_pmapSocketHandle->GetValueAt((void*)hSocket);
		if (pSocket != NULL)
			return pSocket;
	}
	else
	{
		pSocket = (CAsyncSocketEx*)
			pState->m_pmapDeadSockets->GetValueAt((void*)hSocket);
		if (pSocket != NULL)
			return pSocket;
	}
	EMULE_CATCH
	return NULL;
}

void PASCAL CAsyncSocketEx::DoCallBack(WPARAM wParam, LPARAM lParam)
{
	EMULE_TRY
	if (wParam == 0 && lParam == 0)
		return;

	// Has the socket been closed?
	CAsyncSocketEx* pSocket = CAsyncSocketEx::LookupHandle((SOCKET)wParam, TRUE);

	// If yes ignore message
	if (pSocket != NULL)
		return;

	pSocket = CAsyncSocketEx::LookupHandle((SOCKET)wParam, FALSE);
	if (pSocket == NULL)
	{
		// Must be in the middle of an Accept call
		pSocket = CAsyncSocketEx::LookupHandle(INVALID_SOCKET, FALSE);
		ASSERT(pSocket != NULL);
		pSocket->m_SocketData.hSocket = (SOCKET)wParam;
		CAsyncSocketEx::DetachHandle(INVALID_SOCKET);
		pSocket->AttachHandle(pSocket->m_SocketData.hSocket);
	}

	int nErrorCode = WSAGETSELECTERROR(lParam);
	switch (WSAGETSELECTEVENT(lParam))
	{
	case FD_READ:
		{
			fd_set fds;
			int nReady;
			timeval timeout;

			timeout.tv_sec = 0;
			timeout.tv_usec = 0;

			FD_ZERO(&fds);
			FD_SET(pSocket->m_SocketData.hSocket, &fds);
			nReady = select(0, &fds, NULL, NULL, &timeout);
			if (nReady == SOCKET_ERROR)
				nErrorCode = WSAGetLastError();
			if ((nReady == 1) || (nErrorCode != 0))
				pSocket->OnReceive(nErrorCode);
		}
		break;
	case FD_WRITE:
		pSocket->OnSend(nErrorCode);
		break;
	case FD_OOB:
		pSocket->OnOutOfBandData(nErrorCode);
		break;
	case FD_ACCEPT:
		pSocket->OnAccept(nErrorCode);
		break;
	case FD_CONNECT:
		pSocket->OnConnect(nErrorCode);
		break;
	case FD_CLOSE:
		pSocket->OnClose(nErrorCode);
		break;
	}
	EMULE_CATCH
}

void CAsyncSocketEx::OnOutOfBandData(int nErrorCode)
{
}

int CAsyncSocketEx::ReceiveFromHelper(void* lpBuf, int nBufLen, SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags)
{
	EMULE_TRY
	return recvfrom(m_SocketData.hSocket, (LPSTR)lpBuf, nBufLen, nFlags, lpSockAddr, lpSockAddrLen);
	EMULE_CATCH
	return 0;
}

int CAsyncSocketEx::SendToHelper(const void* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags)
{
	EMULE_TRY
	return sendto(m_SocketData.hSocket, (LPSTR)lpBuf, nBufLen, nFlags, lpSockAddr, nSockAddrLen);
	EMULE_CATCH
	return 0;
}

BOOL CAsyncSocketEx::ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	EMULE_TRY
	return connect(m_SocketData.hSocket, lpSockAddr, nSockAddrLen) != SOCKET_ERROR;
	EMULE_CATCH
	return 0;
}

@


1.12
log
@Minor fix to set focus in text input on chat send.
@
text
@d70 1
a70 1
#include "memcpy_amd.h"
@


1.11
log
@Official code merge (katsyonak)
@
text
@d482 1
a482 2
	ASSERT(GetSocketHandle()==INVALID_SOCKET);
	
@


1.10
log
@Fixed some typos.
@
text
@d2 1
a2 1
            Version 1.1 (2002-11-01)
d82 2
a83 1
CRITICAL_SECTION InitializeCriticalSectionEx()
d85 18
a102 3
	CRITICAL_SECTION criticalsection;
	InitializeCriticalSection(&criticalsection);
	return criticalsection;
d104 5
d110 1
a110 1
CRITICAL_SECTION CAsyncSocketEx::m_sGlobalCriticalSection=InitializeCriticalSectionEx();
a123 2
#define WM_SOCKETEX_NOTIFY (WM_USER+1)
#define MAX_SOCKETS (0xBFFF-WM_SOCKETEX_NOTIFY+1)
d331 1
a331 1
#endif //NOLAYERS
d337 1
a337 1
		else if (message==WM_USER) //Notification event sent by a layer
d369 1
a369 1
					if (pSocket->m_lEvent&FD_WRITE/* && pSocket->m_lEvent >= 0*/)
d390 45
d469 2
a481 1
	if (GetSocketHandle()!=INVALID_SOCKET) AddLogLine(false,_T("Crash Assert in CREATE"));
d609 1
a609 1
void PASCAL CAsyncSocketEx::DetachHandle(SOCKET hSocket)
d638 5
d655 1
a655 1
	EnterCriticalSection(&m_sGlobalCriticalSection);
d698 1
a698 1
	LeaveCriticalSection(&m_sGlobalCriticalSection);
d712 1
a712 1
	EnterCriticalSection(&m_sGlobalCriticalSection);
d750 1
a750 1
	LeaveCriticalSection(&m_sGlobalCriticalSection);
d803 6
a808 7
			LPHOSTENT lphost;
			lphost = gethostbyname(lpszAscii);
			if (lphost != NULL)
				sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
			else
			{
				WSASetLastError(WSAEINVAL);
d810 3
a812 1
			}
a860 24

BOOL CAsyncSocketEx::GetPeerName( ULONG& rPeerIP, UINT& rPeerPort )
{
	EMULE_TRY
#ifndef NOLAYERS
	if (m_pFirstLayer)
		return m_pFirstLayer->GetPeerName(rPeerIP, rPeerPort);
#endif NOLAYERS

	SOCKADDR_IN sockAddr;
	memset(&sockAddr, 0, sizeof(sockAddr));

	int nSockAddrLen = sizeof(sockAddr);
	BOOL bResult = GetPeerName((SOCKADDR*)&sockAddr, &nSockAddrLen);
	if (bResult)
	{
		rPeerPort = ntohs(sockAddr.sin_port);
		rPeerIP = sockAddr.sin_addr.S_un.S_addr;
	}
	return bResult;
	EMULE_CATCH
	return FALSE;
}

d913 8
d925 1
d1019 1
a1019 4
	if ( !ioctlsocket(m_SocketData.hSocket, lCommand, lpArgument) )
		return FALSE;
	else
		return TRUE;
d1024 1
a1024 1
CAsyncSocketEx::GetLastError()
d1048 1
a1048 1
		BOOL res=PostMessage(GetHelperWindowHandle(), WM_USER, (WPARAM)this, (LPARAM)pMsg);
d1122 10
@


1.9
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d1158 1
a1158 1
	// Has the socket be closed?
@


1.8
log
@Fixed someone's hack in window helper AddSocket() that was putting bad data in the socket table and causing errors on closing the client socket.
@
text
@d192 1
a192 5
			#ifndef AMD
			memcpy(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize * sizeof(t_AsyncSocketExWindowData));
			#else
			memcpy_amd(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize * sizeof(t_AsyncSocketExWindowData));
			#endif
@


1.7
log
@unicode cleanup
@
text
@d193 1
a193 1
			memcpy(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize/* *sizeof(t_AsyncSocketExWindowData)*/);
d195 1
a195 1
			memcpy_amd(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize/* *sizeof(t_AsyncSocketExWindowData)*/);
@


1.6
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d420 1
a420 1
	if (GetSocketHandle()!=INVALID_SOCKET) AddLogLine(false,"Crash Assert in CREATE");
@


1.5
log
@Upgrade to 0.28a
@
text
@d70 1
d192 1
d194 3
@


1.4
log
@converted to new logging method
@
text
@d81 1
a81 1
/*CRITICAL_SECTION InitializeCriticalSectionEx()
d88 1
a88 2
CRITICAL_SECTION CAsyncSocketEx::m_sGlobalCriticalSection=InitializeCriticalSectionEx();*/
CMutex CAsyncSocketEx::m_sGlobalMutex;
d191 1
a191 1
			memcpy(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize*sizeof(t_AsyncSocketExWindowData));
d248 2
d311 2
a313 1
#endif //NOLAYERS
d349 1
a349 1
					if (pSocket->m_lEvent&FD_WRITE && pSocket->m_lEvent >= 0)
d584 1
a584 2
	CSingleLock Lock(&m_sGlobalMutex,TRUE);
	//EnterCriticalSection(&m_sGlobalCriticalSection);
d627 1
a627 1
	// LeaveCriticalSection(&m_sGlobalCriticalSection);
d641 1
a641 2
	CSingleLock Lock(&m_sGlobalMutex,TRUE);
	//EnterCriticalSection(&m_sGlobalCriticalSection);
d679 1
a679 1
	//LeaveCriticalSection(&m_sGlobalCriticalSection);
@


1.3
log
@*** empty log message ***
@
text
@d413 1
a413 1
	if (GetSocketHandle()!=INVALID_SOCKET) theApp.emuledlg->AddLogLine(false,"Crash Assert in CREATE");
@


1.2
log
@Fixed too many async connections not to kill the program.
@
text
@d81 1
a81 1
CRITICAL_SECTION InitializeCriticalSectionEx()
d88 2
a89 1
CRITICAL_SECTION CAsyncSocketEx::m_sGlobalCriticalSection=InitializeCriticalSectionEx();
d582 2
a583 1
	EnterCriticalSection(&m_sGlobalCriticalSection);
d626 1
a626 1
	LeaveCriticalSection(&m_sGlobalCriticalSection);
d640 2
a641 1
	EnterCriticalSection(&m_sGlobalCriticalSection);
d679 1
a679 1
	LeaveCriticalSection(&m_sGlobalCriticalSection);
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@Maverick's proxy support
@
text
@d191 1
a191 1
			memcpy(m_pAsyncSocketExWindowData, tmp, nOldWindowDataSize);
@

