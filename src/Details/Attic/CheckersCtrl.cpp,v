head	1.3;
access;
symbols
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	Interim_Release_1n_beta2:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1;
locks; strict;
comment	@// @;


1.3
date	2004.11.27.05.27.07;	author aw3;	state dead;
branches;
next	1.2;

1.2
date	2003.10.14.18.41.00;	author syrus77;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.23.00.32.24;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Detailed file parts information (removed old implementation).
@
text
@/*=============================================================================
 * This is an MFC based extension class.
 * Copyright (C) 2001 YEAsoft Int'l.
 * All rights reserved.
 *=============================================================================
 * Copyright (c) 2001 YEAsoft Int'l (Leo Moll, Andrea Pennelli).
 * This software is provided 'as-is', without any express or implied warranty.
 * In no event will the authors be held liable for any damages arising from the
 * use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software in
 *    a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 
 * 3. This notice may not be removed or altered from any source distribution.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *=============================================================================
 * FILENAME		:	CheckersCtrl.cpp
 * PURPOSE		:	Implementation of the Checkers Control class
 * SCOPE		:	
 * HISTORY		: =============================================================
 * 
 * $Log: CheckersCtrl.cpp,v $
 * Revision 1.2  2003/10/14 18:41:00  syrus77
 * Added MMX/AMD/SSE optimized memset [katsyonak]
 *
 * Revision 1.1  2003/08/23 00:32:24  forcha
 * *** empty log message ***
 *
 * Revision 1.10  2001/11/28 18:12:42  leo
 * Fixed initialisation
 * Repaired mouse click behaviour
 *
 * Revision 1.9  2001/11/27 12:46:50  leo
 * Added support for deferred redraw
 *
 * Revision 1.8  2001/11/26 17:23:34  leo
 * Added missing update to CCheckersCtrl::SetDefaultColors
 *
 * Revision 1.7  2001/11/24 16:50:37  leo
 * Fixed overridables. Added missing methods
 *
 * Revision 1.6  2001/11/23 21:36:32  leo
 * Implemented CCheckersCtrl::EnableToolTips
 *
 * Revision 1.5  2001/11/23 21:28:20  leo
 * Fixed scrollbar calculation
 * Implemented EnsureVisible
 *
 * Revision 1.4  2001/11/23 19:11:51  leo
 * Added more functionality (Insert and Delete items)
 *
 * Revision 1.3  2001/11/23 16:47:14  leo
 * Optimized allocation algorithm and reposition/size/tooltip stuff
 *
 * Revision 1.2  2001/11/23 15:06:06  leo
 * Improved color support
 *
 * Revision 1.1  2001/11/22 19:01:12  leo
 * Initial revision
 *
 *============================================================================*/
#include "StdAfx.h"
#include "CheckersCtrl.h"
#include <math.h>
#include "..\otherfunctions.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*=============================================================================
 * INTERNAL MACRO
 *============================================================================*/
#define IDC_VSCROLL				0x00003548

/*=============================================================================
 * CHECKERS CONTROL CLASS IMPLEMENTATION
 *============================================================================*/
IMPLEMENT_DYNCREATE(CCheckersCtrl, CWnd);

COLORREF	CCheckersCtrl::m_crDefArray[16] = {
	RGB(255,255,255),	RGB(192,192,192),		RGB(255,0,0),
	RGB(0,255,0),		RGB(0,0,255),			RGB(255,255,0),
	RGB(0,255,255),		RGB(255,0,255),			RGB(128,0,0),
	RGB(0,128,0),		RGB(0,0,128),			RGB(128,128,0),
	RGB(0,128,128),		RGB(128,0,128),			RGB(128,128,128),
	RGB(0,0,0)
};

CCheckersCtrl::CCheckersCtrl ()
{
	CommonConstructor ();
}

CCheckersCtrl::~CCheckersCtrl ()
{
	UninitializeControl ();
}

void CCheckersCtrl::CommonConstructor ()
{
	m_bInitialized	= FALSE;
	m_bHasToolTips	= TRUE;
	m_iMinSize		= 6;
	m_iMaxSize		= 24;
	m_iSize			= 8;
	m_iCheckers		= 0;
	m_iAllocItems	= 0;
	m_iColors		= 0;
	m_crArray		= NULL;
	m_stArray		= NULL;
	m_dwArray		= NULL;
	m_crDynArray	= NULL;
}

BOOL CCheckersCtrl::InitializeControl ()
{
	if ( m_bInitialized ) {
		return TRUE;
	}
	if ( !m_crArray ) {
		SetDefaultColors ();
	}
	if ( !m_ilCheckers.m_hImageList && !RegenerateImageList () ) {
		TRACE(_T("CCheckersCtrl::InitializeControl - Failed to regenerate image list\n"));
		return FALSE;
	}
	if ( !CreateScrollBar () ) {
		return FALSE;
	}
	if ( !CreateToolTip () ) {
		return FALSE;
	}
	m_bInitialized = TRUE;
	return TRUE;
}

void CCheckersCtrl::UninitializeControl ()
{
	SetDefaultColors ();
	if ( m_stArray ) {
		free (m_stArray);
		m_stArray		= NULL;
		m_dwArray		= NULL;
		m_iCheckers		= 0;
		m_iAllocItems	= 0;
	}

	if ( m_ilCheckers.m_hImageList ) {
		m_ilCheckers.DeleteImageList ();
		m_ilCheckers.m_hImageList = NULL;
	}
	
	m_bInitialized = FALSE;
}

BOOL CCheckersCtrl::CreateToolTip ()
{
	CRect rect; GetClientRect (&rect);

	if ( !m_ctrlToolTip.Create (this, TTS_ALWAYSTIP) ) {
		TRACE(_T("Failed to create tooltip control\n"));
		return FALSE;
	}
	m_ctrlToolTip.Activate (TRUE);
	m_ctrlToolTip.SetMaxTipWidth (min (300, max(rect.Width () / 2, 600)));
	m_ctrlToolTip.SetDelayTime (TTDT_AUTOPOP, 32767);
	return TRUE;
}

BOOL CCheckersCtrl::CreateScrollBar ()
{
	RECT rect;
	GetClientRect (&rect);
	if ( !m_ctrlScroll.Create (WS_CHILD|SBS_VERT|SBS_RIGHTALIGN, rect, this, IDC_VSCROLL) ) {
		TRACE(_T("Failed to create vertical scrollbar\n"));
		return FALSE;
	}
	m_ctrlScroll.ShowWindow (SW_HIDE);
	m_ctrlScroll.EnableWindow (FALSE);
	return TRUE;
}

BOOL CCheckersCtrl::CheckScrollBar (CRect &rc, int iSize, int iCheckers)
{
	int iColCount = rc.Width () / (iSize + 2);
	int iRowCount = (iCheckers / iColCount) + ((iCheckers % iColCount) ? (1) : (0));

	if ( (iRowCount * (iSize + 2)) <= rc.Height () ) {
		// it fits! No ScrollBar
		if ( IsScrollBarVisible () ) {
			EnableScrollBar (FALSE);
			TRACE(_T("ScrollBar DEACTIVATED\n"));
			return TRUE;
		}
		return FALSE;
	}
	SCROLLINFO	sci;

	sci.cbSize	= sizeof (SCROLLINFO);
	sci.fMask	= SIF_PAGE | SIF_POS | SIF_RANGE;
	if ( !IsScrollBarVisible () ) {
		EnableScrollBar ();
		rc.right	-= ::GetSystemMetrics (SM_CXVSCROLL);
		iColCount	= rc.Width () / (iSize + 2);
		iRowCount	= (iCheckers / iColCount) + ((iCheckers % iColCount) ? (1) : (0));
		sci.nPage	= rc.Height ();
		sci.nPos	= 0;
		sci.nMin	= 0;
		sci.nMax	= (iRowCount * (iSize + 2)) - 1;
		m_ctrlScroll.SetScrollInfo (&sci);
		TRACE(_T("ScrollBar ACTIVATED\n"));
		return TRUE;
	}

	// scrollbar will be modified
	m_ctrlScroll.GetScrollInfo (&sci);
	if ( ((int) sci.nPage != rc.Height ()) || (sci.nMax != ((iRowCount * (iSize + 2)) - (int) sci.nPage - 1)) ) {
		sci.fMask	= SIF_PAGE | SIF_RANGE;
		sci.nPage	= rc.Height ();
		sci.nMax	= (iRowCount * (iSize + 2)) - 1;
		if ( sci.nPos > sci.nMax ) {
			sci.fMask	|= SIF_POS;
			sci.nPos	= sci.nMax;
		}
		m_ctrlScroll.SetScrollInfo (&sci);
	}

	return FALSE;
}

void CCheckersCtrl::EnableScrollBar (BOOL bEnable /* = TRUE */)
{
	if ( !bEnable ) {
		m_ctrlScroll.SetScrollPos (0, FALSE);
	}
	m_ctrlScroll.ShowScrollBar (bEnable);
}

void CCheckersCtrl::UpdateTips ()
{
	if ( m_bHasToolTips ) {
		m_ctrlToolTip.Update ();
	}
}

BOOL CCheckersCtrl::Realloc (int iCheckers)
{
	if ( (iCheckers > m_iAllocItems) || ((m_iAllocItems - iCheckers) > 64) ) {
		// allocate or reallocate
		// round up to 64
		int iAllocItems	= iCheckers + (64 - (iCheckers % 64));
		// allocate new
		BYTE *		pST = (BYTE *) malloc (iAllocItems * (sizeof (BYTE) + sizeof (DWORD)));
		DWORD *		pDW = (DWORD *) (pST + iAllocItems);
		if ( !pST ) {
			TRACE(_T("CCheckersCtrl::Realloc - Memory allocation error\n"));
			return FALSE;
		}
		// in case save old data and free memory
		if ( m_stArray ) {
			memcpy2 (pST, m_stArray, sizeof (BYTE) * min (iCheckers, m_iCheckers));
			memcpy2 (pDW, m_dwArray, sizeof (DWORD) * min (iCheckers, m_iCheckers));
			free (m_stArray);
		}
		// assign
		m_stArray		= pST;
		m_dwArray		= pDW;
		m_iAllocItems	= iAllocItems;
	}
	return TRUE;
}

BOOL CCheckersCtrl::RecalcSizes ()
{
	if ( !m_bInitialized || !m_iCheckers ) {
		return FALSE;
	}
	BOOL bDummy;
	return RecalcSizes (m_iCheckers, bDummy);
}

BOOL CCheckersCtrl::RecalcSizes (int iCheckers, BOOL &bNeedsRepos)
{
	bNeedsRepos = FALSE;

	CRect rc; GetClientRect (rc);

	if ( m_iMinSize == m_iMaxSize ) {
		bNeedsRepos = CheckScrollBar (rc, m_iMaxSize, iCheckers);
		if ( m_iSize == m_iMaxSize ) {
			return FALSE;
		}
		m_iSize		= m_iMaxSize;
		bNeedsRepos	= TRUE;
		return TRUE;
	}


	double dCArea	= (double) (rc.Width () * rc.Height ()) / iCheckers;
	double dWidth	= sqrt (dCArea);
	int iSize		= (int) dWidth - 2;
	if ( iSize > m_iMaxSize ) {
		iSize = m_iMaxSize;
	}

	while ( iSize ) {
		if ( iSize < m_iMinSize ) {
			iSize = m_iMinSize;
			if ( CheckScrollBar (rc, iSize, iCheckers) ) {
				bNeedsRepos = TRUE;
			}
			if ( iSize == m_iSize ) {
				return FALSE;
			}
			m_iSize		= iSize;
			bNeedsRepos	= TRUE;
			return TRUE;
		}

		int iColCount = rc.Width () / (iSize + 2);
		int iRowCount = (iCheckers / iColCount) + ((iCheckers % iColCount) ? (1) : (0));
		if ( (iRowCount * (iSize + 2)) <= rc.Height () ) {
			// it fits!
			if ( IsScrollBarVisible () ) {
				EnableScrollBar (FALSE);
				TRACE(_T("ScrollBar DEACTIVATED\n"));
			}
			if ( iSize == m_iSize ) {
				return FALSE;
			}
			m_iSize		= iSize;
			bNeedsRepos	= TRUE;
			return TRUE;
		}
		--iSize;
	}
	// unreachable
	return FALSE;
}

void CCheckersCtrl::RepositionToolTips ()
{
	if ( m_bHasToolTips ) {
		CRect rc; GetClientRect (rc);
		if ( IsScrollBarVisible () ) {
			rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
		}
		int		iColCount	= rc.Width () / (m_iSize + 2);
		int		iScrollPos	= (IsScrollBarVisible ()) ? (m_ctrlScroll.GetScrollPos ()) : (0);
		CRect	rcTool;

		for ( int i = 0; i < m_iCheckers; i++ ) {
			int iCol = i % iColCount;
			int iRow = i / iColCount;
			rcTool.left		= 1 + (iCol * (m_iSize + 2));
			rcTool.right	= rcTool.left + m_iSize;
			rcTool.top		= 1 + (iRow * (m_iSize + 2)) - iScrollPos;
			rcTool.bottom	= rcTool.top + m_iSize;
			m_ctrlToolTip.SetToolRect (this, i + 1, rcTool);
		}
	}
}

BOOL CCheckersCtrl::RegenerateImageList ()
{
	if ( !m_iSize || !m_iColors ) {
		return FALSE;
	}

	CDC			cdc;
	CDC *		pDC;
	CBitmap		bmp;
	CBitmap	*	pBM;
	CBrush		bru;
	CBrush *	pBR;
	CPen		pen;
	CPen *		pPN;
	BITMAP		bit;
	UINT		nFlags;

	if ( !(pDC = GetDC ()) ) {
		TRACE(_T("CCheckersCtrl::RegenerateImageList - Failed to get DC\n"));
		return FALSE;
	}
	if ( !cdc.CreateCompatibleDC (pDC) ) {
		TRACE(_T("CCheckersCtrl::RegenerateImageList - Failed to create compatible DC\n"));
		return FALSE;
	}
	if ( !bmp.CreateCompatibleBitmap (pDC, m_iSize + 2, m_iSize + 2) ) {
		TRACE(_T("CCheckersCtrl::RegenerateImageList - Failed to create temporary Bitmap\n"));
		return FALSE;
	}
	if ( !bru.CreateSolidBrush (::GetSysColor (COLOR_WINDOW)) ) {
		TRACE(_T("CCheckersCtrl::RegenerateImageList - Failed to create brush\n"));
		return FALSE;
	}
	if ( !pen.CreatePen (PS_SOLID, 1, ::GetSysColor (COLOR_WINDOWTEXT)) ) {
		TRACE(_T("CCheckersCtrl::RegenerateImageList - Failed to create pen\n"));
		return FALSE;
	}

	pBM = cdc.SelectObject (&bmp);
	pBR = cdc.SelectObject (&bru);
	pPN = cdc.SelectObject (&pen);

	// draw background
	cdc.PatBlt (0, 0, m_iSize + 2, m_iSize + 2, PATCOPY);

	cdc.SelectObject (pBR);
	cdc.SelectObject (pBM);
	bru.DeleteObject ();

	if ( m_ilCheckers.m_hImageList ) {
		m_ilCheckers.DeleteImageList ();
		m_ilCheckers.m_hImageList = NULL;
	}

	bmp.GetBitmap (&bit);
	switch ( bit.bmBitsPixel ) {
	case 4:
		nFlags = ILC_COLOR4;
		break;
	case 8:
		nFlags = ILC_COLOR8;
		break;
	case 16:
		nFlags = ILC_COLOR16;
		break;
	case 24:
		nFlags = ILC_COLOR24;
		break;
	case 32:
		nFlags = ILC_COLOR32;
		break;
	default:
		nFlags = ILC_COLORDDB;
		break;
	}

	if ( !m_ilCheckers.Create (m_iSize + 2, m_iSize + 2, nFlags, 0, 1) ) {
		TRACE1(_T("CCheckersCtrl::RegenerateImageList - Failed to create imagelist (%i)\n"), ::GetLastError ());
		return FALSE;
	}
	m_ilCheckers.SetImageCount (m_iColors);

	for ( int i = 0; i < m_iColors; i++ ) {
		bru.CreateSolidBrush (m_crArray[i]);
		pBM = cdc.SelectObject (&bmp);
		pBR = cdc.SelectObject (&bru);
		cdc.Rectangle (1, 1, m_iSize + 1, m_iSize + 1);
		cdc.SelectObject (pBR);
		cdc.SelectObject (pBM);
		bru.DeleteObject ();

		m_ilCheckers.Replace (i, &bmp, NULL);
	}
	return TRUE;
}

void CCheckersCtrl::SendClickNotification (UINT code, UINT nFlags, int nItem, DWORD dwData, CPoint point)
{
	ClientToScreen (&point);

	NMMOUSE		nmm;

	nmm.hdr.hwndFrom	= m_hWnd;
	nmm.hdr.idFrom		= GetDlgCtrlID ();
	nmm.hdr.code		= code;
    nmm.dwItemSpec		= nItem;
    nmm.dwItemData		= dwData;
	nmm.pt				= point;
	nmm.dwHitInfo		= nFlags;

	GetParent ()->SendMessage (WM_NOTIFY, (WPARAM) nmm.hdr.idFrom, (LPARAM) &nmm);
}

void CCheckersCtrl::Redraw (BOOL bRedraw)
{
	if ( bRedraw ) {
		CDC	*pDC = GetDC ();
		Redraw (pDC);
		ReleaseDC (pDC);
	}
}

void CCheckersCtrl::Redraw (CDC	*pDC)
{
	CRect rc; GetClientRect (rc);
	if ( IsScrollBarVisible () ) {
		rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
	}
	CRect rcCli = rc;

	int iColCount = rc.Width () / (m_iSize + 2);
	int iFulCount = m_iCheckers / iColCount;
	int iRstCount = m_iCheckers % iColCount;
	int iRowCount = iFulCount + ((iRstCount) ? (1) : (0));
	int iCurCheck = 0;

	if ( rc.bottom < (iRowCount * (m_iSize + 2)) ) {
		rc.bottom = iRowCount * (m_iSize + 2);
	}


	CDC			cdc; cdc.CreateCompatibleDC (pDC);
	CBitmap		bmp; bmp.CreateCompatibleBitmap (pDC, rc.Width (), rc.Height ());
	CBitmap *	pBI; pBI = cdc.SelectObject (&bmp);
	CBrush		brs (::GetSysColor (COLOR_WINDOW));
	CBrush *	pBR; pBR = cdc.SelectObject (&brs);
	CPoint		pt;

	cdc.PatBlt (0, 0, rc.Width (), rc.Height (), PATCOPY);

	int iScrollPos = m_ctrlScroll.GetScrollPos ();


	for ( int iRow = 0; iRow < iFulCount; iRow++ ) {
		pt.y = iRow * (m_iSize + 2);
		for ( int iCol = 0; iCol < iColCount; iCol++, iCurCheck++ ) {
			pt.x = iCol * (m_iSize + 2);
			m_ilCheckers.Draw (&cdc, m_stArray[iCurCheck] % m_iColors, pt, ILD_NORMAL);
		}
	}
	if ( iRstCount ) {
		pt.y = iRow * (m_iSize + 2);
		for ( int iCol = 0; iCol < iRstCount; iCol++, iCurCheck++ ) {
			pt.x = iCol * (m_iSize + 2);
			m_ilCheckers.Draw (&cdc, m_stArray[iCurCheck] % m_iColors, pt, ILD_NORMAL);
		}
	}

	pDC->BitBlt (0, 0, rcCli.Width (), rcCli.Height (), &cdc, 0, m_ctrlScroll.GetScrollPos (), SRCCOPY);
	cdc.SelectObject (pBI);
	cdc.SelectObject (pBR);
}

BOOL CCheckersCtrl::SetSizeLimits (int iMinSize, int iMaxSize, BOOL bRedraw /* = TRUE */)
{
	if ( !m_bInitialized ) {
		return FALSE;
	}
	if ( iMinSize < 0 ) {
		iMinSize = m_iMinSize;
	}
	if ( iMaxSize < 0 ) {
		iMaxSize = m_iMaxSize;
	}
	if ( iMinSize < 6 ) {
		return FALSE;
	}
	if ( iMaxSize > 1024 ) {
		return FALSE;
	}
	m_iMinSize = iMinSize;
	m_iMaxSize = iMaxSize;

	if ( RecalcSizes () ) {
		RepositionToolTips ();
		RegenerateImageList ();
		Redraw (bRedraw);
	}

	return TRUE;
}

BOOL CCheckersCtrl::SetItemCount (int iCheckers, BYTE bInitialState /* = 0 */, DWORD dwData /* = 0 */, LPCTSTR pszTip /* = LPSTR_TEXTCALLBACK */, BOOL bRedraw /* = TRUE */)
{
	if ( !m_bInitialized ) {
		return FALSE;
	}
	if ( iCheckers < 0 ) {
		// crap
		return FALSE;
	}
	if ( iCheckers > 16384 ) {
		// senseless
		return FALSE;
	}
	if ( iCheckers == m_iCheckers ) {
		// nuthing to do
		return TRUE;
	}

	if ( m_bHasToolTips ) {
		// delete unused tooltips
		for ( int i = m_ctrlToolTip.GetToolCount (); i > iCheckers; i-- ) {
			m_ctrlToolTip.DelTool (this, i);
		}
	}

	if ( !iCheckers ) {
		// delete all....
		if ( m_stArray ) {
			free (m_stArray);
			m_stArray = NULL;
			m_dwArray = NULL;
		}
		m_iCheckers = m_iAllocItems = 0;
		Redraw (bRedraw);
		return TRUE;
	}

	if ( !Realloc (iCheckers) ) {
		return FALSE;
	}

	BOOL bNeedsRepos, bSizeChanged = RecalcSizes (iCheckers, bNeedsRepos);

	if ( m_iCheckers < iCheckers ) {
		if ( m_bHasToolTips ) {
			// initialize the tooltips and the new items
			CRect rc; GetClientRect (rc);
			if ( IsScrollBarVisible () ) {
				rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
			}
			int		iColCount	= rc.Width () / (m_iSize + 2);
			int		iScrollPos	= (IsScrollBarVisible ()) ? (m_ctrlScroll.GetScrollPos ()) : (0);
			CRect	rcTool;

			for ( int i = m_iCheckers; i < iCheckers; i++ ) {
				m_stArray[i] = bInitialState;
				m_dwArray[i] = dwData;

				int iCol = i % iColCount;
				int iRow = i / iColCount;
				rcTool.left		= 1 + (iCol * (m_iSize + 2));
				rcTool.right	= rcTool.left + m_iSize;
				rcTool.top		= 1 + (iRow * (m_iSize + 2)) - iScrollPos;
				rcTool.bottom	= rcTool.top + m_iSize;
				VERIFY(m_ctrlToolTip.AddTool (this, pszTip, rcTool, i + 1));
			}
		}
		else {
			// initialize the new items
			for ( int i = m_iCheckers; i < iCheckers; i++ ) {
				m_stArray[i] = bInitialState;
				m_dwArray[i] = dwData;
			}
		}
	}

	m_iCheckers	= iCheckers;
	if ( bSizeChanged ) {
		RegenerateImageList ();
	}
	if ( bNeedsRepos ) {
		RepositionToolTips ();
	}
	Redraw (bRedraw);
	return TRUE;
}

BOOL CCheckersCtrl::SetColorsArray (COLORREF *pColors, int iNumColors, BOOL bRedraw /* = TRUE */)
{
	if ( !pColors || !iNumColors ) {
		SetDefaultColors (bRedraw);
	}
	else if ( iNumColors <= 16 ) {
		// use small array and free dynamic array
		if ( m_crDynArray ) {
			free (m_crDynArray);
			m_crDynArray = NULL;
		}
		memcpy2 (m_crSmaArray, pColors, iNumColors * sizeof (COLORREF));
		m_crArray	= m_crSmaArray;
		m_iColors	= iNumColors;
	}
	else {
		if ( iNumColors > m_iColors ) {
			// reallocation needed
			COLORREF *pCR = (COLORREF *) malloc (iNumColors * sizeof (COLORREF));
			if ( !pCR ) {
				return FALSE;
			}
			if ( m_crDynArray ) {
				free (m_crDynArray);
			}
			m_crDynArray = pCR;
			m_crArray = m_crDynArray;
		}
		memcpy2 (m_crArray , pColors, iNumColors * sizeof (COLORREF));
		m_iColors = iNumColors;
	}
	if ( m_bInitialized ) {
		RegenerateImageList ();
		Redraw (bRedraw);
	}
	return TRUE;
}

void CCheckersCtrl::SetDefaultColors (BOOL bRedraw /* = TRUE */)
{
	if ( m_crArray == m_crDefArray ) {
		return;
	}
	if ( m_crDynArray ) {
		free (m_crDynArray);
		m_crDynArray = NULL;
	}

	m_crArray	= m_crDefArray;
	m_iColors	= 16;
	if ( m_bInitialized ) {
		RegenerateImageList ();
		Redraw (bRedraw);
	}
}

BOOL CCheckersCtrl::SetItemData (int nItem, DWORD dwData)
{
	if ( (nItem >= 0) && (nItem < m_iCheckers) ) {
		m_dwArray[nItem] = dwData;
		UpdateTips ();
		return TRUE;
	}
	return FALSE;
}

DWORD CCheckersCtrl::GetItemData (int nItem) const
{
	if ( (nItem >= 0) && (nItem < m_iCheckers) ) {
		return m_dwArray[nItem];
	}
	return (DWORD) -1;
}

BOOL CCheckersCtrl::SetItemState (int nItem, BYTE bState, BOOL bRedraw /* = TRUE */)
{
	if ( (nItem >= 0) && (nItem < m_iCheckers) ) {
		if ( bState != m_stArray[nItem] ) {
			m_stArray[nItem] = bState;
			UpdateTips ();
			Redraw (bRedraw);
		}
		return TRUE;
	}
	return FALSE;
}

BYTE CCheckersCtrl::GetItemState (int nItem) const
{
	if ( (nItem >= 0) && (nItem < m_iCheckers) ) {
		return m_stArray[nItem];
	}
	return 0;
}

BOOL CCheckersCtrl::SetItemStateArray (BYTE *baState, int cbSize /* = -1 */, BOOL bRedraw /* = TRUE */)
{
	cbSize = (cbSize < 0) ? (m_iCheckers) : (min(cbSize, m_iCheckers));
	if ( !baState || !cbSize ) {
		return FALSE;
	}
	if ( memcmp (m_stArray, baState, cbSize) ) {
		memcpy2 (m_stArray, baState, cbSize);
		UpdateTips ();
		Redraw (bRedraw);
	}
	return TRUE;
}

BOOL CCheckersCtrl::GetItemStateArray (BYTE *baState, int cbSize) const
{
	cbSize = min(cbSize, m_iCheckers);
	if ( baState && (cbSize > 0) ) {
		memcpy2 (baState, m_stArray, cbSize);
		return TRUE;
	}
	return FALSE;
}

BOOL CCheckersCtrl::SetItemToolTip (int nItem, LPCTSTR pszTip /* = LPSTR_TEXTCALLBACK */)
{
	if ( !m_bInitialized || !m_bHasToolTips || (nItem < 0) || (nItem > m_iCheckers) ) {
		return FALSE;
	}
	CToolInfo ti;
	if ( m_ctrlToolTip.GetToolInfo (ti, this, nItem + 1) ) {
		ti.lpszText = (LPTSTR) pszTip;
		m_ctrlToolTip.SetToolInfo (&ti);
		m_ctrlToolTip.Update ();
		return TRUE;
	}
	return FALSE;
}

BOOL CCheckersCtrl::GetItemToolTip (int nItem, CString& str) const
{
	if ( !m_bInitialized || !m_bHasToolTips || (nItem < 0) || (nItem > m_iCheckers) ) {
		return FALSE;
	}
	m_ctrlToolTip.GetText (str, (CWnd *) this, nItem + 1);
	return TRUE;
}

BOOL CCheckersCtrl::Create (DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	if ( !pParentWnd ) {
		return FALSE;
	}
	return CWnd::Create(NULL, _T("CheckersCtrl"), dwStyle | WS_CHILD | WS_VISIBLE | WS_BORDER, rect, pParentWnd, nID);
}

BOOL CCheckersCtrl::ResetState (BYTE bState /* = 0 */, BOOL bRedraw /* = TRUE */)
{
	if ( m_stArray && m_iCheckers ) {
		memset2 (m_stArray, bState, m_iCheckers);
		Redraw (bRedraw);
		return TRUE;
	}
	return FALSE;
}

BOOL CCheckersCtrl::InsertItems (int nItem, int nCount /* = 1 */, BYTE bInitialState /* = 0 */, DWORD dwData /* = 0 */, LPCTSTR pszTip /* = LPSTR_TEXTCALLBACK */, BOOL bRedraw /* = TRUE */)
{
	if ( !m_bInitialized || (nCount < 1) || (nCount > 16384) || (nItem < 0) || (nItem > m_iCheckers) ) {
		return FALSE;
	}

	int iCheckers = m_iCheckers + nCount;

	// reallocate in case
	if ( !Realloc (iCheckers) ) {
		return FALSE;
	}

	BOOL bNeedsRepos, bSizeChanged = RecalcSizes (iCheckers, bNeedsRepos);

	// in case shift arrays
	if ( nItem < m_iCheckers ) {
		memmove (m_stArray + nItem + nCount, m_stArray + nItem, (m_iCheckers - nItem) * sizeof (BYTE));
		memmove (m_dwArray + nItem + nCount, m_dwArray + nItem, (m_iCheckers - nItem) * sizeof (DWORD));
	}

	// initialize the new items
	for ( int i = nItem; i < (nItem + nCount); i++ ) {
		m_stArray[i] = bInitialState;
		m_dwArray[i] = dwData;
	}

	if ( m_bHasToolTips ) {
		// add new tooltips
		CRect rc; GetClientRect (rc);
		if ( IsScrollBarVisible () ) {
			rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
		}
		int		iColCount	= rc.Width () / (m_iSize + 2);
		int		iScrollPos	= (IsScrollBarVisible ()) ? (m_ctrlScroll.GetScrollPos ()) : (0);
		CRect	rcTool;

		for ( int i = m_iCheckers; i < iCheckers; i++ ) {
			int iCol = i % iColCount;
			int iRow = i / iColCount;
			rcTool.left		= 1 + (iCol * (m_iSize + 2));
			rcTool.right	= rcTool.left + m_iSize;
			rcTool.top		= 1 + (iRow * (m_iSize + 2)) - iScrollPos;
			rcTool.bottom	= rcTool.top + m_iSize;
			VERIFY(m_ctrlToolTip.AddTool (this, LPSTR_TEXTCALLBACK, rcTool, i + 1));
		}

		// in case shift tooltips
		if ( nItem < m_iCheckers ) {
			for ( i = m_iCheckers; i > nItem; i-- ) {
				CToolInfo tiSrc, tiDst;
				if ( m_ctrlToolTip.GetToolInfo (tiSrc, this, i) && (tiSrc.lpszText != LPSTR_TEXTCALLBACK) ) {
					if ( m_ctrlToolTip.GetToolInfo (tiDst, this, i + nCount) ) {
						tiDst.lpszText = tiSrc.lpszText;
						m_ctrlToolTip.SetToolInfo (&tiDst);
					}
				}
			}
		}

		// set text of new items
		for ( i = nItem; i < (nItem + nCount); i++ ) {
			CToolInfo ti;
			if ( m_ctrlToolTip.GetToolInfo (ti, this, i + 1) ) {
				ti.lpszText = (LPTSTR) pszTip;
				m_ctrlToolTip.SetToolInfo (&ti);
			}
		}
	}

	m_iCheckers	= iCheckers;
	if ( bNeedsRepos ) {
		RepositionToolTips ();
	}
	if ( bSizeChanged ) {
		RegenerateImageList ();
	}
	Redraw (bRedraw);
	UpdateTips ();
	return TRUE;
}

BOOL CCheckersCtrl::DeleteItems (int nItem, int nCount /* = 1 */, BOOL bRedraw /* = TRUE */)
{
	if ( !m_bInitialized || (nItem < 0) || (nItem >= m_iCheckers) ) {
		// bad param
		return FALSE;
	}
	else if ( nCount == 0 ) {
		// nothing to do
		return FALSE;
	}

	if ( (nItem + nCount) > m_iCheckers ) {
		// compute the real remove count
		nCount = m_iCheckers - nItem;
	}
	else if ( (nItem + nCount) < m_iCheckers ) {
		// shift data
		memmove (m_stArray + nItem, m_stArray + nItem + nCount, (m_iCheckers - (nItem + nCount)) * sizeof (BYTE));
		memmove (m_dwArray + nItem, m_dwArray + nItem + nCount, (m_iCheckers - (nItem + nCount)) * sizeof (DWORD));
		// shift tooltips
		if ( m_bHasToolTips ) {
			for ( int i = nItem; i < (m_iCheckers - nCount); i++ ) {
				CToolInfo tiSrc, tiDst;
				if ( m_ctrlToolTip.GetToolInfo (tiSrc, this, i + nCount + 1) ) {
					if ( m_ctrlToolTip.GetToolInfo (tiDst, this, i + 1) ) {
						tiDst.lpszText = tiSrc.lpszText;
						m_ctrlToolTip.SetToolInfo (&tiDst);
					}
				}
			}
		}
	}

	// delete unused tooltips
	if ( m_bHasToolTips ) {
		for ( int i = m_iCheckers - nCount; i < m_iCheckers; i++ ) {
			m_ctrlToolTip.DelTool (this, i + 1);
		}
	}

	m_iCheckers -= nCount;

	BOOL bNeedsRepos;
	if ( RecalcSizes (m_iCheckers, bNeedsRepos) ) {
		RegenerateImageList ();
	}
	if ( bNeedsRepos ) {
		RepositionToolTips ();
	}
	Redraw (bRedraw);
	UpdateTips ();
	return TRUE;
}

int CCheckersCtrl::FindItem (DWORD dwData) const
{
	for ( int i = 0; i < m_iCheckers; i++ ) {
		if ( m_dwArray[i] == dwData ) {
			return i;
		}
	}
	return -1;
}

int CCheckersCtrl::HitTest (CPoint pt) const
{
	CRect rc; GetClientRect (rc);
	if ( IsScrollBarVisible () ) {
		rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
	}
	if ( !rc.PtInRect (pt) ) {
		// point outside client rect
		return -1;
	}
	int iColOffset	= pt.x % (m_iSize + 2);
	if ( (iColOffset < 1) || (iColOffset > m_iSize) ) {
		// pointer in col gap
		return -1;
	}
	pt.y += (IsScrollBarVisible ()) ? (m_ctrlScroll.GetScrollPos ()) : (0);
	int iRowOffset	= pt.y % (m_iSize + 2);
	if ( (iRowOffset < 1) || (iRowOffset > m_iSize) ) {
		// pointer in row gap
		return -1;
	}

	int	iColCount	= rc.Width () / (m_iSize + 2);
	int iCol		= pt.x / (m_iSize + 2);
	int iRow		= pt.y / (m_iSize + 2);

	return (iRow * iColCount) + iCol;
}

BOOL CCheckersCtrl::EnsureVisible (int nItem, BOOL bPartialOK)
{
	if ( !m_bInitialized || (nItem < 0) || (nItem >= m_iCheckers) ) {
		return FALSE;
	}
	if ( !IsScrollBarVisible () ) {
		return TRUE;
	}

	CRect rc; GetClientRect (rc);
	if ( IsScrollBarVisible () ) {
		rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
	}
	rc.top			= m_ctrlScroll.GetScrollPos ();
	rc.bottom		+= rc.top;

	int	iColCount	= rc.Width () / (m_iSize + 2);
	int iRow		= nItem / iColCount;
	int y1			= iRow * (m_iSize + 2);
	int y2			= y1 + m_iSize + 1;
	if ( y1 >= rc.top ) {
		if ( y2 < rc.bottom ) {
			// fully visible
			return TRUE;
		}
		else if ( y1 < (rc.bottom - 2) ) {
			// partial visible
			if ( bPartialOK ) {
				return TRUE;
			}
			// scroll down!
			m_ctrlScroll.SetScrollPos (m_ctrlScroll.GetScrollPos () + (y2 - rc.bottom) + 1);
			RepositionToolTips ();
			Redraw (TRUE);
			return TRUE;
		}
		else {
			// not visible scroll down!
			m_ctrlScroll.SetScrollPos (m_ctrlScroll.GetScrollPos () + (y2 - rc.bottom) + 1);
			RepositionToolTips ();
			Redraw (TRUE);
			return TRUE;
		}
	}
	else {
		if ( y2 > (rc.top - 2) ) {
			// partially visible
			if ( bPartialOK ) {
				return TRUE;
			}
		}
		// scroll up!
		m_ctrlScroll.SetScrollPos (m_ctrlScroll.GetScrollPos () - (rc.top - y1));
		RepositionToolTips ();
		Redraw (TRUE);
		return TRUE;
	}
}

BOOL CCheckersCtrl::EnableToolTips (BOOL bEnable)
{
	if ( !m_bInitialized ) {
		return FALSE;
	}
	if ( m_bHasToolTips == bEnable ) {
		return TRUE;
	}
	if ( bEnable ) {
		m_ctrlToolTip.Activate (TRUE);
		CRect rc; GetClientRect (rc);
		if ( IsScrollBarVisible () ) {
			rc.right -= ::GetSystemMetrics (SM_CXVSCROLL);
		}
		int		iColCount	= rc.Width () / (m_iSize + 2);
		int		iScrollPos	= (IsScrollBarVisible ()) ? (m_ctrlScroll.GetScrollPos ()) : (0);
		CRect	rcTool;

		for ( int i = 0; i < m_iCheckers; i++ ) {
			int iCol = i % iColCount;
			int iRow = i / iColCount;
			rcTool.left		= 1 + (iCol * (m_iSize + 2));
			rcTool.right	= rcTool.left + m_iSize;
			rcTool.top		= 1 + (iRow * (m_iSize + 2)) - iScrollPos;
			rcTool.bottom	= rcTool.top + m_iSize;
			VERIFY(m_ctrlToolTip.AddTool (this, LPSTR_TEXTCALLBACK, rcTool, i + 1));
		}
	}
	else {
		for ( int i = m_iCheckers; i > 0; i-- ) {
			m_ctrlToolTip.DelTool (this, i);
		}
		m_ctrlToolTip.Activate (FALSE);
	}
	m_bHasToolTips = bEnable;
	return FALSE;
}

BOOL CCheckersCtrl::OnGetToolTipText (int nItem, BYTE bState, DWORD dwParam, TOOLTIPTEXT *pTTT)
{
	_stprintf (pTTT->szText, _T("Item %i: dwData=(%d,0x%08x)"), nItem, dwParam, dwParam);
	return TRUE;
}

void CCheckersCtrl::PreSubclassWindow()
{
	ModifyStyleEx (0, WS_EX_CLIENTEDGE);
	ModifyStyle (WS_VSCROLL|WS_HSCROLL, 0);
	VERIFY(InitializeControl ());
}

BOOL CCheckersCtrl::PreCreateWindow(CREATESTRUCT& cs) 
{	
//	cs.lpszClass = ::AfxRegisterWndClass (
//		CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW,
//		AfxGetApp()->LoadStandardCursor (IDC_ARROW),
//		(HBRUSH) (COLOR_BTNFACE + 1),
//		NULL
//	);
	cs.dwExStyle |= WS_EX_CLIENTEDGE;
	cs.style &= ~(WS_VSCROLL|WS_HSCROLL);

	return CWnd::PreCreateWindow(cs);
}

BOOL CCheckersCtrl::PreTranslateMessage(MSG* pMsg) 
{
	if ( (pMsg->message >= WM_MOUSEFIRST) && (pMsg->message <= WM_MOUSELAST) ) {
		MSG msg = *pMsg;
		if ( msg.hwnd ) {
			m_ctrlToolTip.RelayEvent (&msg);
		}
	}
	
	return CWnd::PreTranslateMessage (pMsg);
}

BEGIN_MESSAGE_MAP(CCheckersCtrl, CWnd)
	//{{AFX_MSG_MAP(CCheckersCtrl)
	ON_WM_CREATE()
	ON_WM_SETFOCUS()
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_WM_SIZE()
	ON_WM_VSCROLL()
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MBUTTONUP()
	ON_WM_MBUTTONDBLCLK()
	ON_WM_RBUTTONUP()
	ON_WM_RBUTTONDBLCLK()
	ON_WM_SETTINGCHANGE()
	ON_WM_SYSCOLORCHANGE()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_NOTIFY_EX(TTN_NEEDTEXT, 0, OnToolTipNeedText)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheckersCtrl message handlers
int CCheckersCtrl::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if ( CWnd::OnCreate(lpCreateStruct) == -1 ) {
		return -1;
	}
	if ( !InitializeControl () ) {
		return -1;
	}
	return 0;
}

void CCheckersCtrl::OnSetFocus(CWnd* pOldWnd)
{
	if ( IsScrollBarVisible () ) {
		m_ctrlScroll.SetFocus ();
	}
}

void CCheckersCtrl::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);

	m_ctrlScroll.MoveWindow (
		cx - ::GetSystemMetrics (SM_CXVSCROLL),
		0,
		::GetSystemMetrics (SM_CXVSCROLL),
		cy
	);
	BOOL bNeedsRepos;
	if ( RecalcSizes (m_iCheckers, bNeedsRepos) ) {
		RegenerateImageList ();
		Redraw (TRUE);
	}
	if ( bNeedsRepos ) {
		RepositionToolTips ();
	}
}

void CCheckersCtrl::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	// Get the minimum and maximum scroll-bar positions.
	SCROLLINFO	info;
	int			iMinPos;
	int			iMaxPos;

	pScrollBar->GetScrollRange (&iMinPos, &iMaxPos); 
	iMaxPos = pScrollBar->GetScrollLimit ();

	// Get the current position of scroll box.
	int iCurPos = pScrollBar->GetScrollPos ();

	// Determine the new position of scroll box.
	switch ( nSBCode ) {
	case SB_LEFT:      // Scroll to far left.
		iCurPos = iMinPos;
		break;
	case SB_RIGHT:      // Scroll to far right.
		iCurPos = iMaxPos;
		break;
	case SB_ENDSCROLL:   // End scroll.
		break;
	case SB_LINELEFT:      // Scroll left.
		if ( iCurPos > iMinPos )
			iCurPos--;
		break;
	case SB_LINERIGHT:   // Scroll right.
		if ( iCurPos < iMaxPos )
			iCurPos++;
		break;
	case SB_PAGELEFT:    // Scroll one page left.
		// Get the page size. 
		pScrollBar->GetScrollInfo (&info, SIF_ALL);
		if ( iCurPos > iMinPos )
			iCurPos = max (iMinPos, iCurPos - (int) info.nPage);
		break;
	case SB_PAGERIGHT:      // Scroll one page right.
		// Get the page size. 
		pScrollBar->GetScrollInfo (&info, SIF_ALL);
		if ( iCurPos < iMaxPos )
			iCurPos = min(iMaxPos, iCurPos + (int) info.nPage);
		break;
	case SB_THUMBPOSITION: // Scroll to absolute position. nPos is the position
		iCurPos = nPos;      // of the scroll box at the end of the drag operation.
		break;
	case SB_THUMBTRACK:   // Drag scroll box to specified position. nPos is the
		iCurPos = nPos;     // position that the scroll box has been dragged to.
		break;
	}

	// Set the new position of the thumb (scroll box).
	pScrollBar->SetScrollPos (iCurPos);
	RepositionToolTips ();
	Redraw (TRUE);
}

void CCheckersCtrl::OnLButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonUp(nFlags, point);
	int nItem = HitTest (point);
	if ( nItem != -1 ) {
		BYTE	bState = GetItemState (nItem);
		DWORD	dwData = GetItemData (nItem);
		if ( !OnLeftClick (FALSE, nFlags, point, nItem, bState, dwData) ) {
			SendClickNotification (NM_CLICK, nFlags, nItem, dwData, point);
		}
	}
	else {
		SendClickNotification (NM_CLICK, nFlags, -1, -1, point);
	}
}

void CCheckersCtrl::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnLButtonDblClk(nFlags, point);
	int nItem = HitTest (point);
	if ( nItem != -1 ) {
		BYTE	bState = GetItemState (nItem);
		DWORD	dwData = GetItemData (nItem);
		if ( !OnLeftClick (TRUE, nFlags, point, nItem, bState, dwData) ) {
			SendClickNotification (NM_DBLCLK, nFlags, nItem, dwData, point);
		}
	}
	else {
		SendClickNotification (NM_DBLCLK, nFlags, -1, -1, point);
	}
}

void CCheckersCtrl::OnMButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnMButtonUp(nFlags, point);
	int nItem = HitTest (point);
	if ( nItem != -1 ) {
		BYTE	bState = GetItemState (nItem);
		DWORD	dwData = GetItemData (nItem);
		OnMiddleClick (FALSE, nFlags, point, nItem, bState, dwData);
	}
}

void CCheckersCtrl::OnMButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnMButtonDblClk(nFlags, point);
	int nItem = HitTest (point);
	if ( nItem != -1 ) {
		BYTE	bState = GetItemState (nItem);
		DWORD	dwData = GetItemData (nItem);
		OnMiddleClick (TRUE, nFlags, point, nItem, bState, dwData);
	}
}

void CCheckersCtrl::OnRButtonUp(UINT nFlags, CPoint point)
{
	CWnd::OnRButtonUp(nFlags, point);
	int nItem = HitTest (point);
	if ( nItem != -1 ) {
		BYTE	bState = GetItemState (nItem);
		DWORD	dwData = GetItemData (nItem);
		if ( !OnRightClick (FALSE, nFlags, point, nItem, bState, dwData) ) {
			SendClickNotification (NM_RCLICK, nFlags, nItem, dwData, point);
		}
	}
	else {
		SendClickNotification (NM_RCLICK, nFlags, -1, -1, point);
	}
}

void CCheckersCtrl::OnRButtonDblClk(UINT nFlags, CPoint point)
{
	CWnd::OnRButtonDblClk(nFlags, point);
	int nItem = HitTest (point);
	if ( nItem != -1 ) {
		BYTE	bState = GetItemState (nItem);
		DWORD	dwData = GetItemData (nItem);
		if ( !OnRightClick (TRUE, nFlags, point, nItem, bState, dwData) ) {
			SendClickNotification (NM_RCLICK, nFlags, nItem, dwData, point);
		}
	}
	else {
		SendClickNotification (NM_RCLICK, nFlags, -1, -1, point);
	}
}

BOOL CCheckersCtrl::OnEraseBkgnd (CDC* pDC) 
{
	return TRUE;
}

void CCheckersCtrl::OnPaint()
{
	CPaintDC dc (this);
	Redraw (&dc);
}

void CCheckersCtrl::OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
{
	RegenerateImageList ();
	Redraw (TRUE);
}

void CCheckersCtrl::OnSysColorChange()
{
	RegenerateImageList ();
	Redraw (TRUE);
}

void CCheckersCtrl::OnDestroy ()
{
	UninitializeControl ();
}

BOOL CCheckersCtrl::OnToolTipNeedText(UINT id, NMHDR * pTTTStruct, LRESULT * pResult)
{
	TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *) pTTTStruct;

	int		nItem = pTTTStruct->idFrom - 1;
	if ( (nItem < 0) || (nItem >= m_iCheckers) ) {
		return FALSE;
	}
	return OnGetToolTipText (nItem, m_stArray[nItem], m_dwArray[nItem], pTTT);
}

//
// EoF
////////
@


1.2
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d35 3
@


1.1
log
@*** empty log message ***
@
text
@d35 3
d74 1
d273 2
a274 2
			memcpy (pST, m_stArray, sizeof (BYTE) * min (iCheckers, m_iCheckers));
			memcpy (pDW, m_dwArray, sizeof (DWORD) * min (iCheckers, m_iCheckers));
d676 1
a676 1
		memcpy (m_crSmaArray, pColors, iNumColors * sizeof (COLORREF));
d693 1
a693 1
		memcpy (m_crArray , pColors, iNumColors * sizeof (COLORREF));
d767 1
a767 1
		memcpy (m_stArray, baState, cbSize);
d778 1
a778 1
		memcpy (baState, m_stArray, cbSize);
d819 1
a819 1
		memset (m_stArray, bState, m_iCheckers);
@

