head	1.4;
access;
symbols
	PublicRelease_1_2e:1.4
	Interim_Release_1-2e_RC1:1.4
	PublicRelease_1_2d:1.4
	Interim_Release_1-2d_RC1:1.4
	Interim_Release_1-2d_beta1:1.4
	PublicRelease_1_2c:1.4
	Interim_Release_1-2c_RC1:1.4
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	PublicRelease_1m:1.4
	Interim_Release_1m_beta1:1.4
	PublicRelease_1l:1.4
	Interim_Release_1l_RC3:1.4
	Interim_Release_1l_RC2:1.4
	Interim_Release_1l_RC1:1.4
	Interim_Release_1l_beta2:1.4
	Interim_Release_1l_beta1:1.4
	PublicRelease_1k:1.4
	Interim_Release_1k_RC4:1.4
	Interim_1k_RC3:1.4
	Interim_1k_RC2:1.4
	Interim_Release_1k_RC1:1.4
	Interim_Release_1k_beta5:1.4
	Intrerim_Release_1k_beta4:1.4
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1;
locks; strict;
comment	@// @;


1.4
date	2004.03.02.00.45.19;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.21.18.56.50;	author katsyonak;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.21.21.23;	author katsyonak;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.23.00.32.24;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Speed up dialog information drawing
@
text
@/////////////////////////////////////////////////////////////////////////////
// Separator.cpp : source file for CSeparator.
//
// Written by Michael Dunn (mdunn at inreach dot com).  Copyright and all
// that stuff.  Use however you like but give me credit where it's due.  I'll
// know if you don't. bwa ha ha ha ha!
//
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Separator.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSeparator

CSeparator::CSeparator()
{
}

CSeparator::~CSeparator()
{
}


BEGIN_MESSAGE_MAP(CSeparator, CStatic)
	//{{AFX_MSG_MAP(CSeparator)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSeparator message handlers

// This function draws the horizontal line, followed by the text. The general
// idea for the line drawing comes from Hans Buehler's article at
// http://www.codeguru.com/staticctrl/draw_bevel.shtml
//
// Note that this class is intended to be just a simple separator, so the
// only static styles I implement here are SS_LEFT, SS_CENTER, SS_RIGHT, and
// SS_NOPREFIX.  Also note that the line is always drawn vertically centered
// in the control, so if you make the control tall enough you can get the 
// text totally above the line.

void CSeparator::OnPaint() 
{
	CPaintDC dc(this);                      // device context for painting
	CRect    rectWnd;                       // RECT of the static control
	CRect    rectText;                      // RECT in which text will be drawn
	CString  cstrText;                      // text to draw
	CFont*   pfontOld;
	DWORD    dwStyle = GetStyle();          // this window's style

	// Get the screen & client coords.
	GetWindowRect ( rectWnd );
	GetClientRect ( rectText );

	// Get the text to be drawn.
	GetWindowText ( cstrText );

	// If the control is taller than it is wide, draw a vertical line.
	// No text is drawn in this case.
	if ( rectWnd.Height() > rectWnd.Width() )
	{
		dc.Draw3dRect( 
			rectWnd.Width()/2, 0,       // upper-left point
			2, rectWnd.Height(),        // width & height  
			::GetSysColor(COLOR_3DSHADOW),
			::GetSysColor(COLOR_3DHIGHLIGHT) );

		/************************************************************
		If you feel adventurous, here is the code to do vertical text
		drawing.  I have it commented out because getting the text
		aligned correctly over the line looks like it'll be a pain.

		// Start by getting this control's font, and then tweak it a bit.

		LOGFONT lf;
		GetFont()->GetObject ( sizeof(LOGFONT), &lf );

		// Text will be rotated counter-clockwise 90 degrees.
		lf.lfOrientation = lf.lfEscapement = 900;

		// We need a TrueType font to get rotated text.  MS Sans Serif
		// won't cut it!
		lstrcpy ( lf.lfFaceName, _T("Tahoma") );

		// Create a font with the tweaked attributes.
		CFont font;
		font.CreateFontIndirect ( &lf );

		pfontOld = dc.SelectObject ( &font );

		dc.SetBkColor ( ::GetSysColor(COLOR_BTNFACE) );

		GetWindowText ( cstrText );

		dc.DrawText ( cstrText, rectText,
		DT_VCENTER | DT_CENTER | DT_SINGLELINE );

		dc.SelectObject ( pfontOld );
		font.DeleteObject();
		************************************************************/
	}
	else
	{

		// Get the font for the text.
		pfontOld = dc.SelectObject ( GetFont() );

		SIZE TextSize;
		GetTextExtentPoint32(dc, cstrText, cstrText.GetLength(), &TextSize);

		// We're drawing a horizontal separator.
		// The text will always be at the top of the control.  Also check
		// if the SS_NOPREFIX style is set.                                        

		// Voila!  One 3D line coming up.

		UINT uFormat = DT_TOP | DT_NOCLIP;

		if ( dwStyle & SS_NOPREFIX )
			uFormat |= DT_NOPREFIX;

		if ( dwStyle & SS_RIGHT )
		{
			uFormat |= DT_RIGHT;
			dc.Draw3dRect (0, rectWnd.Height() / 2, rectWnd.Width() - TextSize.cx - 10, 2,
				::GetSysColor(COLOR_3DSHADOW),
				::GetSysColor(COLOR_3DHIGHLIGHT) );
		}
		else if ( dwStyle & SS_CENTER )
		{
			uFormat |= DT_CENTER;
			dc.Draw3dRect (0, rectWnd.Height() / 2, ((rectWnd.Width() - TextSize.cx) / 2) - 10, 2,
				::GetSysColor(COLOR_3DSHADOW),
				::GetSysColor(COLOR_3DHIGHLIGHT) );
			dc.Draw3dRect (((rectWnd.Width() - TextSize.cx) / 2) + TextSize.cx + 10, rectWnd.Height() / 2, ((rectWnd.Width() - TextSize.cx) / 2) - 10, 2,
				::GetSysColor(COLOR_3DSHADOW),
				::GetSysColor(COLOR_3DHIGHLIGHT) );
		}
		else
		{
			uFormat |= DT_LEFT;
			dc.Draw3dRect (TextSize.cx + 10, rectWnd.Height() / 2,	rectWnd.Width() - TextSize.cx - 10, 2,
				::GetSysColor(COLOR_3DSHADOW),
				::GetSysColor(COLOR_3DHIGHLIGHT) );
		}

		dc.SetBkMode(TRANSPARENT);
		dc.DrawText ( cstrText, rectText, uFormat );

		// Clean up GDI objects like a good lil' programmer.
		dc.SelectObject ( pfontOld );
	}
}
@


1.3
log
@Fixed bug #0000466 - White areas in file details
@
text
@d125 1
a125 1
		UINT uFormat = DT_TOP;
@


1.2
log
@Fixed background color on labeled seperators (like in Client Details -> Scores)
@
text
@d52 109
a160 123
CPaintDC dc(this);                      // device context for painting
CRect    rectWnd;                       // RECT of the static control
CRect    rectText;                      // RECT in which text will be drawn
CString  cstrText;                      // text to draw
CFont*   pfontOld;
UINT     uFormat;                       // format for CDC::DrawText()
DWORD    dwStyle = GetStyle();          // this window's style


    // Get the screen & client coords.

    GetWindowRect ( rectWnd );
    GetClientRect ( rectText );

    // If the control is taller than it is wide, draw a vertical line.
    // No text is drawn in this case.

    if ( rectWnd.Height() > rectWnd.Width() )
        {
        dc.Draw3dRect( 
            rectWnd.Width()/2, 0,       // upper-left point
            2, rectWnd.Height(),        // width & height  
            ::GetSysColor(COLOR_3DSHADOW),
            ::GetSysColor(COLOR_3DHIGHLIGHT) );

        /************************************************************
        If you feel adventurous, here is the code to do vertical text
        drawing.  I have it commented out because getting the text
        aligned correctly over the line looks like it'll be a pain.

        // Start by getting this control's font, and then tweak it a bit.

        LOGFONT lf;
        GetFont()->GetObject ( sizeof(LOGFONT), &lf );

        // Text will be rotated counter-clockwise 90 degrees.
        lf.lfOrientation = lf.lfEscapement = 900;

        // We need a TrueType font to get rotated text.  MS Sans Serif
        // won't cut it!
        lstrcpy ( lf.lfFaceName, _T("Tahoma") );

        // Create a font with the tweaked attributes.
        CFont font;
        font.CreateFontIndirect ( &lf );

        pfontOld = dc.SelectObject ( &font );

        dc.SetBkColor ( ::GetSysColor(COLOR_BTNFACE) );

        GetWindowText ( cstrText );

        dc.DrawText ( cstrText, rectText,
                      DT_VCENTER | DT_CENTER | DT_SINGLELINE );

        dc.SelectObject ( pfontOld );
        font.DeleteObject();
        ************************************************************/
        }
    else
        {
        // We're drawing a horizontal separator.
        // The text will always be at the top of the control.  Also check
        // if the SS_NOPREFIX style is set.                                        

        uFormat = DT_TOP;

        if ( dwStyle & SS_NOPREFIX )
            uFormat |= DT_NOPREFIX;

        // Voila!  One 3D line coming up.

        dc.Draw3dRect (
            0, rectWnd.Height()/2,      // upper-left point
            rectWnd.Width(), 2,         // width & height
            ::GetSysColor(COLOR_3DSHADOW),
            ::GetSysColor(COLOR_3DHIGHLIGHT) );


        // Now get the text to be drawn.  I add two spaces to the string
        // to make a bit of space between the end of the line and the text.
        // Space is added to one or both ends of the text as appropriate.
        // Along the way, I add another formatting flag to uFormat.

        GetWindowText ( cstrText );

        if ( dwStyle & SS_CENTER )
            {
            cstrText = _T("  ") + cstrText;
            cstrText += _T("  ");

            uFormat |= DT_CENTER;
            }
        else if ( dwStyle & SS_RIGHT )
            {
            cstrText = _T("  ") + cstrText;

            uFormat |= DT_RIGHT;
            }
        else
            {
            cstrText += _T("  ");
        
            uFormat |= DT_LEFT;
            }

        // Get the font for the text.
    
        pfontOld = dc.SelectObject ( GetFont() );

        // Set the background color to the same as the dialog, so the text
        // will be opaque.  This erases all traces of the 3D line as the
        // text is drawn over it.  (No need to call CDC::SetBkMode() because
        // the default mode for a DC is opaque.)

        //dc.SetBkColor ( ::GetSysColor(COLOR_BTNFACE) );
		dc.SetBkColor(dc.GetBkColor());
        dc.DrawText ( cstrText, rectText, uFormat );

        // Clean up GDI objects like a good lil' programmer.

        dc.SelectObject ( pfontOld );
        }
@


1.1
log
@*** empty log message ***
@
text
@a119 1
            {
a120 1
            }
d167 2
a168 1
        dc.SetBkColor ( ::GetSysColor(COLOR_BTNFACE) );
@

