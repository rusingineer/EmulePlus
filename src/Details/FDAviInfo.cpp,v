head	1.22;
access;
symbols
	PublicRelease_1_2e:1.22
	Interim_Release_1-2e_RC1:1.22
	PublicRelease_1_2d:1.21
	Interim_Release_1-2d_RC1:1.21
	Interim_Release_1-2d_beta1:1.20
	PublicRelease_1_2c:1.20
	Interim_Release_1-2c_RC1:1.20
	Interim_Release_1-2c_beta1:1.20
	PublicRelease_1_2b:1.20
	Interim_Release_1-2b_RC1:1.20
	PublicRelease_1_2a:1.20
	Interim_Release_1-2a_RC1:1.19
	Interim_Release_1-2a_beta2:1.19
	Interim_Release_1-2a_beta1:1.19
	PublicRelease_1_2:1.18
	Interim_Release_1-2_RC1:1.18
	Interim_Release_1-2_beta1:1.17
	PublicRelease_1_1g:1.15
	Interim_Release_1-1g_RC3:1.15
	Interim_Release_1-1g_RC2:1.15
	Interim_Release_1-1g_RC1:1.15
	Interim_Release_1-1g_beta2:1.15
	Interim_Release_1-1g_beta1:1.14
	PublicRelease_1_1f:1.14
	Interim_Release_1-1f_RC1:1.14
	PublicRelease_1_1e:1.14
	Interim_Release_1-1e_RC2:1.14
	Interim_Release_1-1e_RC1:1.14
	Interim_Release_1-1e_beta1:1.14
	PublicRelease_1_1d:1.13
	Interim_Release_1-1d_RC1:1.13
	PublicRelease_1_1c:1.13
	Interim_Release_1-1c_RC1:1.13
	Interim_Release_1-1c_beta2:1.13
	Interim_Release_1-1c_beta1:1.13
	PublicRelease_1_1b:1.11
	Interim_Release_1-1b_RC1:1.11
	PublicRelease_1_1a:1.11
	Interim_Release_1-1a_RC2:1.11
	Interim_Release_1-1a_RC1:1.11
	Interim_Release_1-1a_beta2:1.11
	Interim_Release_1-1a_beta1:1.11
	PublicRelease_1_1:1.11
	Interim_Release_1-1_beta1:1.11
	PublicRelease_1o:1.11
	Interim_Release_1o_RC1:1.11
	Interim_Release_1o_beta1:1.11
	PublicRelease_1n:1.11
	Interim_Release_1n_RC2:1.11
	Interim_Release_1n_RC1:1.10
	Interim_Release_1n_beta2:1.10
	PublicRelease_1m:1.10
	Interim_Release_1m_beta1:1.10
	PublicRelease_1l:1.9
	Interim_Release_1l_RC3:1.9
	Interim_Release_1l_RC2:1.9
	Interim_Release_1l_RC1:1.9
	Interim_Release_1l_beta2:1.9
	Interim_Release_1l_beta1:1.9
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.5
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.5
	Interim_Release_1j_RC1:1.5
	Interim_Release_1j_beta2:1.5
	Interim_Release_1j_beta1:1.5
	PublicRelease_1i:1.5
	Interim_Release_1i_RC6:1.5
	Interim_Release_1i_RC3:1.5
	Interim_Release_1i_RC2:1.5
	Interim_Release_1i_RC1:1.5
	Interim_Release_1i_beta3:1.5
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.4;
locks; strict;
comment	@// @;


1.22
date	2008.09.29.04.36.40;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2008.03.03.04.38.40;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.12.13.01.55;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.15.22.53.19;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2006.02.07.02.42.43;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.07.03.39.34;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2006.01.06.20.05.56;	author kush_eplus;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.26.00.29.07;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.02.04.45.19;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.24.03.50.40;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.14.14.46.21;	author kush_eplus;	state Exp;
branches;
next	1.11;

1.11
date	2004.09.04.05.35.59;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.22.05.42.08;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.22.18.20.53;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.20.01.34.38;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.26.22.03.02;	author aw3;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.25.04.59.15;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.26.13.50.18;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.05.12.24.27;	author forcha;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.05.10.45.18;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.05.05.19.58;	author dongato;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.05.00.02.23;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.22
log
@Some local functions were made static.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "FDAviInfo.h"
#include "..\emule.h"
#include "..\otherfunctions.h"
#include <mmsystem.h>
#include <avifmt.h>

IMPLEMENT_DYNCREATE(CFDAviInfo, CPropertyPage)

CFDAviInfo::CFDAviInfo() : CPropertyPage(CFDAviInfo::IDD)
, m_bARoundBitrate(FALSE)
{
	m_pFile = NULL;
}

CFDAviInfo::~CFDAviInfo()
{
}

void CFDAviInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_WIDTH_VAL, m_ctrlWidth);
	DDX_Control(pDX, IDC_VIDEOCODEC_VAL, m_ctrlVideoCodec);
	DDX_Control(pDX, IDC_VIDEOBITRATE_VAL, m_ctrlVideoBitrate);
	DDX_Control(pDX, IDC_SAMPLERATE_VAL, m_ctrlSamplerate);
	DDX_Control(pDX, IDC_HEIGHT_VAL, m_ctrlHeight);
	DDX_Control(pDX, IDC_FPS_VAL, m_ctrlFPS);
	DDX_Control(pDX, IDC_CHANNEL_VAL, m_ctrlChannel);
	DDX_Control(pDX, IDC_AUDIOCODEC_VAL, m_ctrlAudioCodec);
	DDX_Control(pDX, IDC_AUDIOBITRATE_VAL, m_ctrlAudioBitrate);
	DDX_Control(pDX, IDC_VIDEO_LBL, m_ctrlVideoLbl);
	DDX_Control(pDX, IDC_PICTURE_LBL, m_ctrlPictureLbl);
	DDX_Control(pDX, IDC_AUDIO_LBL, m_ctrlAudioLbl);
	DDX_Check(pDX, IDC_ROUNDBITRATE_BTN, m_bARoundBitrate);
	DDX_Control(pDX, IDC_FILESIZE_VAL, m_ctrlFilesize);
	DDX_Control(pDX, IDC_FILELENGTH_VAL, m_ctrlFilelength);
}


BEGIN_MESSAGE_MAP(CFDAviInfo, CPropertyPage)
	ON_BN_CLICKED(IDC_ROUNDBITRATE_BTN, OnBnClickedRoundbitrateBtn)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFDAviInfo message handlers

BOOL CFDAviInfo::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_bARoundBitrate = TRUE;
	m_dwAbitrate = 0;
	CPropertyPage::UpdateData(FALSE);
	Localize();
	Update();

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

static bool AVIReadChunkHdr(CFile *file, uint32 *pdwFCC, uint32 *pdwLen)
{
	uint32		dwTmp[2];
	bool		bResult = (file->Read(dwTmp, 8) == 8);

	if (bResult)
	{
		*pdwFCC = dwTmp[0];
		*pdwLen = dwTmp[1];
	}

	return bResult;
}

void CFDAviInfo::Update()
{
	EMULE_TRY

	if ((m_pFile == NULL) || !::IsWindow(GetSafeHwnd()))
		return;

	CFile		file;

	if ( file.Open(m_pFile->GetFilePath(), CFile::modeRead | CFile::shareDenyNone |
		CFile::typeBinary | CFile::osSequentialScan) )
	{
		bool	bAVIHdr = false, bVideoFmt = false, bAudioFmt = false;
		int		iVideoStrm = -1, iAudioStrm = -1, iCurrStrm;
		uint32	dwTmp, dwAVISize = 0;
		uint64	qwAVISize;
		AVIStreamHeader		strmAVIHdr[2];
		MainAVIHeader		mainAVIHdr;
		BITMAPINFOHEADER	vidFormat;
		WAVEFORMATEX		audFormat;

		try
		{
			uint32	dwFCC, dwLen, dwLeft, dwStrmIdx = 0;

		//	Read file header and check 'RIFF' signature
			if (AVIReadChunkHdr(&file, &dwFCC, &dwAVISize) && (dwFCC == FOURCC_RIFF))
			{
			//	Some AVI can be > 4GB, but standard file header field is 32bit;
			//	So we use actual file size for large files and still header field for small,
			//	as it is more precise in some cases
				if (m_pFile->GetFileSize() > 0xFFFFFFFFui64)
					qwAVISize = m_pFile->GetFileSize();
				else
					qwAVISize = static_cast<uint64>(dwAVISize);
			//	Check AVI signature
				if ((file.Read(&dwFCC, 4) == 4) && (dwFCC == formtypeAVI))
				{
				//	Dispatch chunks
					while (AVIReadChunkHdr(&file, &dwFCC, &dwLen))
					{
					//	Check for potentially incorrect FCC (nonprintable characters)
						if ( ((dwTmp = dwFCC & 0xFF) < 0x20) || (dwTmp > 0x7E) ||
							((dwTmp = (dwFCC >>  8) & 0xFF) < 0x20) || (dwTmp > 0x7E) ||
							((dwTmp = (dwFCC >> 16) & 0xFF) < 0x20) || (dwTmp > 0x7E) ||
							((dwTmp = (dwFCC >> 24)) < 0x20) || (dwTmp > 0x7E) )
						{
							goto while_end;
						}
						switch (dwFCC)
						{
							case FOURCC_LIST:
							//	Read sub-chunk name and check LIST chunk minimal size
							//	(excluding main header as LIST chunk size doesn't required here)
								if ((file.Read(&dwFCC, 4) != 4) || ((dwLen < 4) && (dwFCC != listtypeAVIHEADER)))
									goto while_end;

							//	Reduce the length by just read sub-chunk name size
								dwLen -= 4;
								switch (dwFCC)
								{
									case listtypeAVIMOVIE:	// data section, header must have been before
										goto while_end;
									case listtypeAVIHEADER:	// 'hdrl' main header
										dwLen = 0;	// process sub-chunks in the next iteration
										break;
									case listtypeSTREAMHEADER:
										dwLeft = dwLen;
									//	Stream header type as well as protection that stream header was found
										iCurrStrm = 0;
										while((dwLeft >= 8) && AVIReadChunkHdr(&file, &dwFCC, &dwLen))
										{
											dwLeft -= 8;
											if (dwLen > dwLeft)
												goto while_end;
											dwTmp = dwLeft;
											dwLeft -= dwLen + (dwLen & 1);
											if (dwLeft > dwTmp)
												dwLeft = 0;

											if (dwFCC == ckidSTREAMHEADER)
											{
												if (dwLen < sizeof(strmAVIHdr[0]))
												{
													memset(&strmAVIHdr[dwStrmIdx], 0, sizeof(strmAVIHdr[0]));
													if (file.Read(&strmAVIHdr[dwStrmIdx], dwLen) != dwLen)
														goto while_end;
													if ((dwLen & 1) != 0)
														file.Seek(1, CFile::current);
													dwLen = 0;
												}
												else
												{
													if (file.Read(&strmAVIHdr[dwStrmIdx], sizeof(strmAVIHdr[0])) != sizeof(strmAVIHdr[0]))
														goto while_end;
													dwLen -= sizeof(strmAVIHdr[0]);
												}
											//	NB: AVI Type-1 is not supported
												if ((strmAVIHdr[dwStrmIdx].fccType == streamtypeVIDEO) && (iVideoStrm < 0))
													iCurrStrm = dwStrmIdx + 1;
												else if ((strmAVIHdr[dwStrmIdx].fccType == streamtypeAUDIO) && (iAudioStrm < 0))
													iCurrStrm = -static_cast<int>(dwStrmIdx + 1);
											}
										//	Stream header tag should have been before
											else if ((dwFCC == ckidSTREAMFORMAT) && (iCurrStrm != 0))
											{
												void	*pPtr;

												dwTmp = (iCurrStrm > 0) ?
													(pPtr = &vidFormat, sizeof(vidFormat)) : (pPtr = &audFormat, sizeof(audFormat));
											//	Data reading
												if (dwLen < dwTmp)
												{
													memset(pPtr, 0, dwTmp);
													if (file.Read(pPtr, dwLen) != dwLen)
														goto while_end;
													if ((dwLen & 1) != 0)
														file.Seek(1, CFile::current);
													dwLen = 0;
												}
												else
												{
													if (file.Read(pPtr, dwTmp) != dwTmp)
														goto while_end;
													if ((dwLen -= dwTmp) != 0)
														file.Seek(dwLen + (dwLen & 1), CFile::current);
												}
											//	Mark the corresponding structure as filled
												if (iCurrStrm > 0)
													bVideoFmt = true;
												else
													bAudioFmt = true;
											//	One stream specification per LIST section
												break;
											}
											if (dwLen != 0)
												file.Seek(dwLen + (dwLen & 1), CFile::current);
										}
										if (iCurrStrm != 0)
										{
											if (iCurrStrm > 0)
												iVideoStrm = dwStrmIdx;
											else
												iAudioStrm = dwStrmIdx;
										//	Nothing to do here anymore if video and audio streams were parsed
											if (++dwStrmIdx >= 2)
												goto while_end;
										}

										dwLen = dwLeft;
										break;
								}
								break;

							case ckidAVIMAINHDR:	// 'avih' main AVI header
							//	Consider only the first one
								if (!bAVIHdr)
								{
									dwTmp = (dwLen > sizeof(mainAVIHdr)) ? sizeof(mainAVIHdr) : dwLen;
									memset(&mainAVIHdr, 0, sizeof(mainAVIHdr));
									if (file.Read(&mainAVIHdr, dwTmp) != dwTmp)
										goto while_end;

									dwLen -= dwTmp;
									bAVIHdr = true;
								}
								break;

							case ckidAVINEWINDEX:	// 'idx1' chunk, it's the end of the file -- finish search
								goto while_end;
						}
						if (dwLen != 0)
							file.Seek(dwLen + (dwLen & 1), CFile::current);
					}
while_end: ;
				}
			}
		}
		catch(CFileException *error)
		{
			OUTPUT_DEBUG_TRACE();
			error->Delete();
		}
		file.Close();

	//	AVI header was dispatched
		if (bAVIHdr)
		{
			CString	strBuffer;
			uint32	dwLengthInSec = 0;

			m_ctrlFilesize.SetWindowText(CastItoXBytes(qwAVISize));

		//	Protect from division by zero
			if (mainAVIHdr.dwMicroSecPerFrame != 0)
			{
			//	FPS
				double dFps = 1000000.0 / (double)mainAVIHdr.dwMicroSecPerFrame;

				strBuffer.Format(_T("%.3f"), dFps);
				m_ctrlFPS.SetWindowText(strBuffer);

			//	Duration
				dwLengthInSec = static_cast<uint32>(mainAVIHdr.dwTotalFrames / dFps);
				m_ctrlFilelength.SetWindowText(CastSecondsToHM(dwLengthInSec));
			}

		//	Video width
			strBuffer.Format(_T("%u"), mainAVIHdr.dwWidth);
			m_ctrlWidth.SetWindowText(strBuffer);
		//	Video height
			strBuffer.Format(_T("%u"), mainAVIHdr.dwHeight);
			m_ctrlHeight.SetWindowText(strBuffer);

		//	Audio stream with audio format was found
			if ((iAudioStrm >= 0) && bAudioFmt)
			{
			//	Audio codec
				dwTmp = audFormat.wFormatTag;
				switch (dwTmp)
				{
					case 0:
					case 1:
						m_ctrlAudioCodec.SetWindowText(_T("PCM"));
						break;
					case 2:
						m_ctrlAudioCodec.SetWindowText(_T("ADPCM"));
						break;
					case 353:
						m_ctrlAudioCodec.SetWindowText(_T("DivX;-) Audio"));
						break;
					case 85:
						m_ctrlAudioCodec.SetWindowText(_T("MPEG Layer 3"));
						break;
					case 8192:
						m_ctrlAudioCodec.SetWindowText(_T("AC3-Digital"));
						break;
					case 0x674F:
						m_ctrlAudioCodec.SetWindowText(_T("Ogg Vorbis (mode 1)"));
						break;
					case 0x6750:
						m_ctrlAudioCodec.SetWindowText(_T("Ogg Vorbis (mode 2)"));
						break;
					case 0x6751:
						m_ctrlAudioCodec.SetWindowText(_T("Ogg Vorbis (mode 3)"));
						break;
					case 0x676F:
						m_ctrlAudioCodec.SetWindowText(_T("Ogg Vorbis (mode 1+)"));
						break;
					case 0x6770:
						m_ctrlAudioCodec.SetWindowText(_T("Ogg Vorbis (mode 2+)"));
						break;
					case 0x6771:
						m_ctrlAudioCodec.SetWindowText(_T("Ogg Vorbis (mode 3+)"));
						break;
					default:
						GetResString(&strBuffer, IDS_UNKNOWN);
						strBuffer.AppendFormat(_T(" (%#x)"), dwTmp);
						m_ctrlAudioCodec.SetWindowText(strBuffer);
						break;
				}
			//	Audio channel
				dwTmp = audFormat.nChannels;
				switch (dwTmp)
				{
					case 1:
						m_ctrlChannel.SetWindowText(_T("1 (mono)"));
						break;
					case 2:
						m_ctrlChannel.SetWindowText(_T("2 (stereo)"));
						break;
					default:
						if ((dwTmp == 5) && (audFormat.wFormatTag == 8192))
							m_ctrlChannel.SetWindowText(_T("5.1 (surround)"));
						else
						{
							strBuffer.Format(_T("%u"), dwTmp);
							m_ctrlChannel.SetWindowText(strBuffer);
						}
						break;
				}
			//	Audio samplerate
				strBuffer.Format(_T("%u"), audFormat.nSamplesPerSec);
				m_ctrlSamplerate.SetWindowText(strBuffer);
			//	Audio bitrate
				m_dwAbitrate = audFormat.nAvgBytesPerSec;
				GetDlgItem(IDC_ROUNDBITRATE_BTN)->EnableWindow(true);
				OnBnClickedRoundbitrateBtn();
			}

		//	Video stream was found
			if (iVideoStrm >= 0)
			{
			//	Video codec
				if (!bVideoFmt || ((dwTmp = vidFormat.biCompression) != '05XD'))
					dwTmp = strmAVIHdr[iVideoStrm].fccHandler;
				if ((dwTmp == 'divx') || (dwTmp == 'DIVX'))
					m_ctrlVideoCodec.SetWindowText(_T("XviD"));
				else if (dwTmp == '05XD')
					m_ctrlVideoCodec.SetWindowText(_T("DivX 5"));
				else if ((dwTmp == 'xvid') || (dwTmp == 'XVID'))
					m_ctrlVideoCodec.SetWindowText(_T("DivX 4"));
				else if ((dwTmp == '3vid') || (dwTmp == '3VID'))
					m_ctrlVideoCodec.SetWindowText(_T("DivX 3 Low-Motion"));
				else if ((dwTmp == '4vid') || (dwTmp == '4VID'))
					m_ctrlVideoCodec.SetWindowText(_T("DivX 3 High-Motion"));
				else if ((dwTmp == '2vid') || (dwTmp == '2VID'))
					m_ctrlVideoCodec.SetWindowText(_T("MS MPEG4 v2"));
				else if (dwTmp == '34pm')
					m_ctrlVideoCodec.SetWindowText(_T("MS MPEG4 v3"));
				else
				{
					char	acTmp[5];

					*reinterpret_cast<uint32*>(acTmp) = dwTmp;
					acTmp[4] = '\0';
					strBuffer.Format(_T("%hs"), acTmp);
					m_ctrlVideoCodec.SetWindowText(strBuffer);
				}

			//	Protect from division by zero
				if (dwLengthInSec != 0)
				{
				//	Video bitrate (1 Kbit = 1000 bits)
					strBuffer.Format(_T("%u kbps"), ( (dwAVISize - mainAVIHdr.dwTotalFrames * 24) /
						dwLengthInSec - m_dwAbitrate ) / (1000 / 8));
					m_ctrlVideoBitrate.SetWindowText(strBuffer);
				}
			}
		}
	}

	EMULE_CATCH
}

void CFDAviInfo::OnBnClickedRoundbitrateBtn()
{
	EMULE_TRY

	if (m_dwAbitrate != 0)
	{
		CPropertyPage::UpdateData();

		uint32		dwKbit = m_dwAbitrate / (1000 / 8);	// 1 Kbit = 1000 bits

		if (m_bARoundBitrate)
		{
			if ((dwKbit >= 246) && (dwKbit <= 260))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("256 kbps"));
			}
			else if ((dwKbit >= 216) && (dwKbit <= 228))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("224 kbps"));
			}
			else if ((dwKbit >= 187) && (dwKbit <= 196))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("192 kbps"));
			}
			else if ((dwKbit >= 156) && (dwKbit <= 164))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("160 kbps"));
			}
			else if ((dwKbit >= 124) && (dwKbit <= 132))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("128 kbps"));
			}
			else if ((dwKbit >= 108) && (dwKbit <= 116))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("112 kbps"));
			}
			else if ((dwKbit >= 92) && (dwKbit <= 100))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("96 kbps"));
			}
			else if ((dwKbit >= 60) && (dwKbit <= 68))
			{
				m_ctrlAudioBitrate.SetWindowText(_T("64 kbps"));
			}
			else
			{
				CString strBuffer;
				strBuffer.Format(_T("%u kbps"), dwKbit);
				m_ctrlAudioBitrate.SetWindowText(strBuffer);
			}
		}
		else
		{
			CString strBuffer;
			strBuffer.Format(_T("%u kbps"), dwKbit);
			m_ctrlAudioBitrate.SetWindowText(strBuffer);
		}
	}
	else
	{
		m_ctrlAudioBitrate.SetWindowText(_T("-"));
	}

	EMULE_CATCH
}

void CFDAviInfo::Localize()
{
	static const uint16 s_auResTbl[][2] =
	{
		{ IDC_PICTURE_LBL, IDS_FD_PICTURE },
		{ IDC_AUDIO_LBL, IDS_AUDIO },
		{ IDC_ROUNDBITRATE_BTN, IDS_ROUNDBITRATE },
		{ IDC_VIDEO_LBL, IDS_VIDEO },
		{ IDC_FILESIZE_LBL, IDS_FD_SIZE }
	};
	static const uint16 s_auResTbl2[][2] =
	{
		{ IDC_WIDTH_LBL, IDS_WIDTH },
		{ IDC_HEIGHT_LBL, IDS_HEIGHT },
		{ IDC_AUDIOCODEC_LBL, IDS_CODEC },
		{ IDC_AUDIOBITRATE_LBL, IDS_BITRATE },
		{ IDC_SAMPLERATE_LBL, IDS_SAMPLERATE },
		{ IDC_CHANNEL_LBL, IDS_CHANNELS },
		{ IDC_VIDEOCODEC_LBL, IDS_CODEC },
		{ IDC_VIDEOBITRATE_LBL, IDS_BITRATE },
		{ IDC_FPS_LBL, IDS_FPS },
		{ IDC_FILELENGTH_LBL, IDS_LENGTH }
	};

	if (GetSafeHwnd())
	{
		CString strBuffer;

		for (uint32 i = 0; i < ARRSIZE(s_auResTbl); i++)
		{
			GetResString(&strBuffer, static_cast<UINT>(s_auResTbl[i][1]));
			SetDlgItemText(s_auResTbl[i][0], strBuffer);
		}

		for (uint32 i = 0; i < ARRSIZE(s_auResTbl2); i++)
		{
			GetResString(&strBuffer, static_cast<UINT>(s_auResTbl2[i][1]));
			strBuffer += _T(":");
			SetDlgItemText(s_auResTbl2[i][0], strBuffer);
		}
	}
}
@


1.21
log
@ELEMENT_COUNT -> ARRSIZE.
@
text
@d78 1
a78 1
bool AVIReadChunkHdr(CFile *file, uint32 *pdwFCC, uint32 *pdwLen)
@


1.20
log
@Workaround to show correct file size for AVI > 4GB {Fuxie - DK}.
@
text
@d1 1
a1 1
// FDAviInfo.cpp : implementation file
d3 13
d21 2
a22 4
#include "mmsystem.h"
#include "avifmt.h"

// CFDAviInfo dialog
a38 1
	//{{AFX_DATA_MAP(CFDAviInfo)
a50 1
	//}}AFX_DATA_MAP
a57 3
	//{{AFX_MSG_MAP(CFDAviInfo)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
d495 1
a495 1
	static const int s_aiResTbl[][2] =
d503 1
a503 1
	static const int s_aiResTbl2[][2] =
d521 1
a521 1
		for (uint32 i = 0; i < ELEMENT_COUNT(s_aiResTbl); i++)
d523 2
a524 2
			GetResString(&strBuffer, static_cast<UINT>(s_aiResTbl[i][1]));
			SetDlgItemText(s_aiResTbl[i][0], strBuffer);
d527 1
a527 1
		for (uint32 i = 0; i < ELEMENT_COUNT(s_aiResTbl2); i++)
d529 1
a529 1
			GetResString(&strBuffer, static_cast<UINT>(s_aiResTbl2[i][1]));
d531 1
a531 1
			SetDlgItemText(s_aiResTbl2[i][0], strBuffer);
@


1.19
log
@Added detection of ADPCM audio stream for AVI info {Fuxie - DK};
Fixed display of unknown video codec in AVI info {Fuxie - DK}
(introduced by Unicode modifications in the previous version).
@
text
@d101 1
d114 7
d277 1
a277 1
			m_ctrlFilesize.SetWindowText(CastItoXBytes(dwAVISize));
@


1.18
log
@Added detection of Ogg Vorbis in AVI info {Fuxie - DK}.
@
text
@d303 3
d394 1
a394 1
					strBuffer.Format(_T("%4hc"), acTmp);
@


1.17
log
@Minor formatting.
@
text
@d312 18
@


1.16
log
@UNICODE preparation (first shot)
@
text
@a17 3
	//{{AFX_DATA_INIT(CFDAviInfo)
	//}}AFX_DATA_INIT

d373 1
a373 1
				    strBuffer.Format(_T("%4hc"), acTmp);
@


1.15
log
@Unified processing of part and temporary file names.
@
text
@a356 1
				{
a357 1
				}
a358 1
				{
a359 1
				}
a360 1
				{
a361 1
				}
a362 1
				{
a363 1
				}
a364 1
				{
a365 1
				}
a366 1
				{
a367 1
				}
d369 1
a369 3
				{
					m_ctrlVideoCodec.SetWindowText(_T("Microcrap MPEG4 v3"));
				}
d376 2
a377 1
					m_ctrlVideoCodec.SetWindowText(acTmp);
@


1.14
log
@Display "kbps" instead of "Kbit/s" in media information.
@
text
@a96 1
	CString		strFileName = m_pFile->GetFullName();
d98 1
a98 6
	if (strFileName.Right(4) == _T(".met"))
	{
	//	Get the .part file name if file isn't complete yet
		strFileName.Truncate(strFileName.GetLength() - 4);
	}
	if ( file.Open(strFileName, CFile::modeRead | CFile::shareDenyNone |
@


1.13
log
@memzero rollback.
@
text
@d403 1
a403 1
					strBuffer.Format(_T("%u Kbit/s"), ( (dwAVISize - mainAVIHdr.dwTotalFrames * 24) /
d428 1
a428 1
				m_ctrlAudioBitrate.SetWindowText(_T("256 Kbit/s"));
d432 1
a432 1
				m_ctrlAudioBitrate.SetWindowText(_T("224 Kbit/s"));
d436 1
a436 1
				m_ctrlAudioBitrate.SetWindowText(_T("192 Kbit/s"));
d440 1
a440 1
				m_ctrlAudioBitrate.SetWindowText(_T("160 Kbit/s"));
d444 1
a444 1
				m_ctrlAudioBitrate.SetWindowText(_T("128 Kbit/s"));
d448 1
a448 1
				m_ctrlAudioBitrate.SetWindowText(_T("112 Kbit/s"));
d452 1
a452 1
				m_ctrlAudioBitrate.SetWindowText(_T("96 Kbit/s"));
d456 1
a456 1
				m_ctrlAudioBitrate.SetWindowText(_T("64 Kbit/s"));
d461 1
a461 1
				strBuffer.Format(_T("%u Kbit/s"), dwKbit);
d468 1
a468 1
			strBuffer.Format(_T("%u Kbit/s"), dwKbit);
@


1.12
log
@Use of CPU optimised memzero function
Code refactoring
@
text
@d171 1
a171 1
													memzero(&strmAVIHdr[dwStrmIdx], sizeof(strmAVIHdr[0]));
d200 1
a200 1
													memzero(pPtr, dwTmp);
d246 1
a246 1
									memzero(&mainAVIHdr, sizeof(mainAVIHdr));
@


1.11
log
@Fixed incorrect parsing of AVI header for Media Info [reported by Fuxie - DK];
Fixed localization issues of Media Info;
Fixed crashes while processing incorrect AVI header;
Fixed audio and video bitrate calculation for Media Info;
Disable Media Info checkbox by default.
@
text
@d77 2
a78 1
	uint32	dwRc, dwTmp[2];
d80 7
a86 6
	dwRc = file->Read(dwTmp, 8);
	if (dwRc != 8)
		return false;
	*pdwFCC = dwTmp[0];
	*pdwLen = dwTmp[1];
	return true;
d171 1
a171 1
													memset(&strmAVIHdr[dwStrmIdx], 0, sizeof(strmAVIHdr[0]));
d200 1
a200 1
													memset(pPtr, 0, dwTmp);
d246 1
a246 1
									memset(&mainAVIHdr, 0, sizeof(mainAVIHdr));
d265 1
a265 1
		catch(CFileException* error)
d306 1
a306 1
				switch(dwTmp)
d329 1
a329 1
				switch(dwTmp)
d394 1
a394 1
          *reinterpret_cast<uint32*>(acTmp) = dwTmp;
d422 1
a422 1
		uint32		dwKbit = m_dwAbitrate / (1000 / 8);	//1 Kbit = 1000 bits
d427 1
a427 1
			{	
d429 1
a429 1
			}	
d439 1
a439 1
			{	
d443 1
a443 1
			{	
d447 1
a447 1
			{	
d451 1
a451 1
			{	
d455 1
a455 1
			{	
d473 1
a473 1
	{	
@


1.10
log
@Improved string processing; EMULE_TRY/EMULE_CATCH are removed from
localization routines, because almost nothing to catch here, but this pair adds a lot of code.
@
text
@d8 2
d75 12
d105 8
d115 4
a118 7
			TCHAR szTemp[5];
			uint32 u32;
			uint16 u16;

			file.Seek(8, CFile::begin);
			file.Read(&u32, 4);
			if (u32 == 0x20495641)	// "AVI "
d120 155
a274 2
				CString		strBuffer;
				uint32		dwSize;
d276 1
a276 22
			//	Filesize
				file.Seek(4, CFile::begin);
				file.Read(&dwSize, 4);
				strBuffer.Format(_T("%.2f MB"), (static_cast<double>(dwSize) / 1024.0 / 1024.0));
				m_ctrlFilesize.SetWindowText(strBuffer);
				
			//	Header sizes
				long lAviheadersize, lVheadersize;
				file.Seek(28, CFile::begin);
				file.Read(&lAviheadersize, 4);

				long lAviheaderstart = 32;
				long lVheaderstart = lAviheaderstart + lAviheadersize + 20;

			//	Misc
				long lMicrosec;
				file.Seek(lAviheaderstart, CFile::begin);
				file.Read(&lMicrosec, 4);

				long lLengthInFrames;
				file.Seek(lAviheaderstart + 16, CFile::begin);
				file.Read(&lLengthInFrames, 4);
d278 3
d282 3
a284 2
				double dFps = (double)1000000 / (double)lMicrosec;
				strBuffer.Format(_T("%.2f"), dFps);
d287 2
a288 2
			//	Length
				uint32 dwLengthInSec = (long)(lLengthInFrames / dFps);
d290 1
d292 6
a297 58
			//	Video width
				file.Seek(lAviheaderstart + 32, CFile::begin);
				file.Read(&u32, 4);
				strBuffer.Format(_T("%u"), u32);
				m_ctrlWidth.SetWindowText(strBuffer);

			//	Video height
				file.Seek(lAviheaderstart + 36, CFile::begin);
				file.Read(&u32, 4);
				strBuffer.Format(_T("%u"), u32);
				m_ctrlHeight.SetWindowText(strBuffer);

			//	Video codec
				file.Seek(lVheaderstart + 4, CFile::begin);
				file.Read(szTemp, 4);
				szTemp[4] = 0;
				if(!_tcscmp(szTemp, _T("div3")) || !_tcscmp(szTemp, _T("DIV3")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("DivX 3 Low-Motion"));
				}
				else if(!_tcscmp(szTemp, _T("div4")) || !_tcscmp(szTemp, _T("DIV4")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("DivX 3 High-Motion"));
				}
				else if(!_tcscmp(szTemp, _T("divx")) || !_tcscmp(szTemp, _T("DIVX")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("DivX 4"));
				}
				else if(!_tcscmp(szTemp, _T("DX50")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("DivX 5"));
				}
				else if(!_tcscmp(szTemp, _T("div2")) || !_tcscmp(szTemp, _T("DIV2")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("MS MPEG4 v2"));
				}
				else if(!_tcscmp(szTemp, _T("mp43")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("Microcrap MPEG4 v3"));
				}
				else if(!_tcscmp(szTemp, _T("xvid")) || !_tcscmp(szTemp, _T("XVID")))
				{
					m_ctrlVideoCodec.SetWindowText(_T("XviD"));
				}
				else
				{
					m_ctrlVideoCodec.SetWindowText(szTemp);
				}
				
			//	Header sizes
				file.Seek(lAviheaderstart + lAviheadersize + 4, CFile::begin);
				file.Read(&lVheadersize, 4);

				long lAheaderstart = lVheaderstart + lVheadersize + 8;	//first databyte of audio header

				long lAstrhsize;
				file.Seek(lAheaderstart - 4, CFile::begin);
				file.Read(&lAstrhsize, 4);
d299 3
d303 2
a304 3
				file.Seek(lAheaderstart + lAstrhsize + 8, CFile::begin);
				file.Read(&u16, 2);
				switch(u16)
d320 2
a321 1
						strBuffer.Format(_T("Unknown (%u)"), u16);
a324 1

d326 2
a327 3
				file.Seek(lAheaderstart + 2 + lAstrhsize + 8, CFile::begin);
				file.Read(&u16, 2);
				switch(u16)
a334 3
					case 5:
						m_ctrlChannel.SetWindowText(_T("5.1 (surround)"));
						break;
d336 7
a342 2
						strBuffer.Format(_T("%u"), u16);
						m_ctrlChannel.SetWindowText(strBuffer);
a344 1

d346 1
a346 3
				file.Seek(lAheaderstart + 4 + lAstrhsize + 8, CFile::begin);
				file.Read(&u32, 4);
				strBuffer.Format(_T("%u"), u32);
a347 1

d349 2
a350 2
				file.Seek(lAheaderstart + 8 + lAstrhsize + 8, CFile::begin);
				file.Read(&m_dwAbitrate, 4);
d352 44
d397 8
a404 3
			//	Video bitrate
				strBuffer.Format(_T("%u Kbit/s"), (dwSize / dwLengthInSec - m_dwAbitrate) / 128);
				m_ctrlVideoBitrate.SetWindowText(strBuffer);
a406 6
		catch(CFileException* error)
		{
			OUTPUT_DEBUG_TRACE();
			error->Delete();
		}
		file.Close();
d420 1
a420 1
		uint32		dwKbit = m_dwAbitrate / (1024 / 8);
d472 1
a472 1
		m_ctrlAudioBitrate.SetWindowText(_T(""));
@


1.9
log
@Fix rare rx/tx stream corruption caused by reading Media Info for File Details;
Corrected reading of audio sample rate;
Added possibility to see Media Info for complete files.
@
text
@d6 1
a6 1
#include "..\eMule.h"
d334 1
a334 1
	static const int aiResTbl[][2] =
d342 1
a342 1
	static const int aiResTbl2[][2] =
a355 2
	EMULE_TRY

d358 1
a358 2
		for (uint32 i = 0; i < ELEMENT_COUNT(aiResTbl); i++)
			SetDlgItemText(aiResTbl[i][0], GetResString(static_cast<UINT>(aiResTbl[i][1])));
d360 5
a364 1
		CString strBuffer;
d366 1
a366 1
		for (uint32 i = 0; i < ELEMENT_COUNT(aiResTbl2); i++)
d368 3
a370 2
			strBuffer.Format("%s:", GetResString(static_cast<UINT>(aiResTbl2[i][1])));
			SetDlgItemText(aiResTbl2[i][0], strBuffer);
a372 2

	EMULE_CATCH
@


1.8
log
@minor optimization
@
text
@d77 1
a77 4
	if(m_pFile == NULL)
		return;
	
	if(!::IsWindow(GetSafeHwnd()))
d80 4
a83 2
	CFile *pFile = &m_pFile->m_hPartFile;
	try
d85 7
a91 5
		TCHAR szTemp[5];
		uint32 u32;
		uint16 u16;

		if(pFile == NULL)
d93 10
a102 2
			return;
		}
d104 150
a253 90
		pFile->Seek(8, CFile::begin);
		pFile->Read(szTemp, 4);
		szTemp[4] = 0;
		if(_tcscmp(szTemp, _T("AVI "))) // not avi
		{
			return;
		}

		CString		strBuffer;
		uint32		dwSize;

	//	Filesize
		pFile->Seek(4, CFile::begin);
		pFile->Read(&dwSize, 4);
		strBuffer.Format(_T("%.2f MB"), (static_cast<double>(dwSize) / 1024.0 / 1024.0));
		m_ctrlFilesize.SetWindowText(strBuffer);
		
	//	Header sizes
		long lAviheadersize, lVheadersize;
		pFile->Seek(28, CFile::begin);
		pFile->Read(&lAviheadersize, 4);

		long lAviheaderstart = 32;
		long lVheaderstart = lAviheaderstart + lAviheadersize + 20;

	//	Misc
		long lMicrosec;
		pFile->Seek(lAviheaderstart, CFile::begin);
		pFile->Read(&lMicrosec, 4);

		long lLengthInFrames;
		pFile->Seek(lAviheaderstart + 16, CFile::begin);
		pFile->Read(&lLengthInFrames, 4);

	//	FPS
		double dFps = (double)1000000 / (double)lMicrosec;
		strBuffer.Format(_T("%.2f"), dFps);
		m_ctrlFPS.SetWindowText(strBuffer);

	//	Length
		uint32 dwLengthInSec = (long)(lLengthInFrames / dFps);
		m_ctrlFilelength.SetWindowText(CastSecondsToHM(dwLengthInSec));

	//	Video width
		pFile->Seek(lAviheaderstart + 32, CFile::begin);
		pFile->Read(&u32, 4);
		strBuffer.Format(_T("%u"), u32);
		m_ctrlWidth.SetWindowText(strBuffer);

	//	Video height
		pFile->Seek(lAviheaderstart + 36, CFile::begin);
		pFile->Read(&u32, 4);
		strBuffer.Format(_T("%u"), u32);
		m_ctrlHeight.SetWindowText(strBuffer);

	//	Video codec
		pFile->Seek(lVheaderstart + 4, CFile::begin);
		pFile->Read(szTemp, 4);
		szTemp[4] = 0;
		if(!_tcscmp(szTemp, _T("div3")) || !_tcscmp(szTemp, _T("DIV3")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("DivX 3 Low-Motion"));
		}
		else if(!_tcscmp(szTemp, _T("div4")) || !_tcscmp(szTemp, _T("DIV4")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("DivX 3 High-Motion"));
		}
		else if(!_tcscmp(szTemp, _T("divx")) || !_tcscmp(szTemp, _T("DIVX")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("DivX 4"));
		}
		else if(!_tcscmp(szTemp, _T("DX50")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("DivX 5"));
		}
		else if(!_tcscmp(szTemp, _T("div2")) || !_tcscmp(szTemp, _T("DIV2")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("MS MPEG4 v2"));
		}
		else if(!_tcscmp(szTemp, _T("mp43")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("Microcrap MPEG4 v3"));
		}
		else if(!_tcscmp(szTemp, _T("xvid")) || !_tcscmp(szTemp, _T("XVID")))
		{
			m_ctrlVideoCodec.SetWindowText(_T("XviD"));
		}
		else
		{
			m_ctrlVideoCodec.SetWindowText(szTemp);
d255 1
a255 15
		
	//	Header sizes
		pFile->Seek(lAviheaderstart + lAviheadersize + 4, CFile::begin);
		pFile->Read(&lVheadersize, 4);

		long lAheaderstart = lVheaderstart + lVheadersize + 8;	//first databyte of audio header

		long lAstrhsize;
		pFile->Seek(lAheaderstart - 4, CFile::begin);
		pFile->Read(&lAstrhsize, 4);

	//	Audio codec
		pFile->Seek(lAheaderstart + lAstrhsize + 8, CFile::begin);
		pFile->Read(&u16, 2);
		switch(u16)
d257 2
a258 17
			case 0:
			case 1:
				m_ctrlAudioCodec.SetWindowText(_T("PCM"));
				break;
			case 353:
				m_ctrlAudioCodec.SetWindowText(_T("DivX;-) Audio"));
				break;
			case 85:
				m_ctrlAudioCodec.SetWindowText(_T("MPEG Layer 3"));
				break;
			case 8192:
				m_ctrlAudioCodec.SetWindowText(_T("AC3-Digital"));
				break;
			default:
				strBuffer.Format(_T("Unknown (%u)"), u16);
				m_ctrlAudioCodec.SetWindowText(strBuffer);
				break;
d260 1
a260 42

	//	Audio channel
		pFile->Seek(lAheaderstart + 2 + lAstrhsize + 8, CFile::begin);
		pFile->Read(&u16, 2);
		switch(u16)
		{
			case 1:
				m_ctrlChannel.SetWindowText(_T("1 (mono)"));
				break;
			case 2:
				m_ctrlChannel.SetWindowText(_T("2 (stereo)"));
				break;
			case 5:
				m_ctrlChannel.SetWindowText(_T("5.1 (surround)"));
				break;
			default:
				strBuffer.Format(_T("%u"), u16);
				m_ctrlChannel.SetWindowText(strBuffer);
				break;
		}

	//	Audio samplerate
		pFile->Seek(lAheaderstart + 4 + lAstrhsize + 8, CFile::begin);
		pFile->Read(&u32, 2);
		strBuffer.Format(_T("%u"), u32);
		m_ctrlSamplerate.SetWindowText(strBuffer);

	//	Audio bitrate
		pFile->Seek(lAheaderstart + 8 + lAstrhsize + 8, CFile::begin);
		pFile->Read(&m_dwAbitrate, 4);
		OnBnClickedRoundbitrateBtn();

	//	Video bitrate
		strBuffer.Format(_T("%u Kbit/s"), (dwSize / dwLengthInSec - m_dwAbitrate) / 128);
		m_ctrlVideoBitrate.SetWindowText(strBuffer);

	}
	catch(CFileException* error)
	{
		OUTPUT_DEBUG_TRACE();
		error->Delete();
		return;
@


1.7
log
@Fixed AVI file information for file size > 2Gb; minor improvements;
Fixed bogus display of AVI audio bitrate for complete file and when header hasn't received yet.
@
text
@d361 2
a362 2
		for (uint32 i = 0; i < (sizeof(aiResTbl) / sizeof(aiResTbl[0])); i++)
			GetDlgItem(aiResTbl[i][0])->SetWindowText(GetResString(static_cast<UINT>(aiResTbl[i][1])));
d366 1
a366 1
		for (uint32 i = 0; i < (sizeof(aiResTbl2) / sizeof(aiResTbl2[0])); i++)
d369 1
a369 1
			GetDlgItem(aiResTbl2[i][0])->SetWindowText(strBuffer);
@


1.6
log
@Unified localization; whitespace corrections
@
text
@d64 1
d83 1
a83 1
	CFile* pFile = &m_pFile->m_hPartFile;
a86 1
		CString strBuffer;
d103 4
a106 2
		// filesize
		long lSize;
d108 2
a109 2
		pFile->Read(&lSize, 4);
		strBuffer.Format(_T("%.2f MB"), (static_cast<double>(lSize) / 1024.0 / 1024.0));
d112 1
a112 1
		// header sizes
d120 1
a120 1
		// misc
d129 1
a129 1
		// fps
d134 3
a136 3
		// length
		long lLengthInSec = (long)(lLengthInFrames / dFps);
		m_ctrlFilelength.SetWindowText(CastSecondsToHM(lLengthInSec));
d138 1
a138 1
		// video width
d141 1
a141 1
		strBuffer.Format(_T("%d"), u32);
d144 1
a144 1
		// video height
d147 1
a147 1
		strBuffer.Format(_T("%d"), u32);
d150 1
a150 1
		// video codec
d187 1
a187 1
		// header sizes
d197 1
a197 1
		// audio codec
d216 1
a216 1
				strBuffer.Format(_T("Unknown (%d)"), u16);
d221 1
a221 1
		// audio channel
d236 1
a236 1
				strBuffer.Format(_T("%d"), u16);
d241 1
a241 1
		// audio samplerate
d244 1
a244 1
		strBuffer.Format(_T("%d"), u32);
d247 1
a247 1
		// audio bitrate
d249 1
a249 1
		pFile->Read(&m_lAbitrate, 4);
d252 2
a253 2
		// video bitrate
		strBuffer.Format(_T("%d Kbit/s"), (lSize / lLengthInSec - m_lAbitrate) / 128);
d260 1
a260 1
		error->Delete();	//memleak fix
d271 1
a271 1
	if(m_lAbitrate != 0)
d275 3
a277 1
		if(m_bARoundBitrate)
d279 1
a279 2
			long t = m_lAbitrate / (1024 / 8);
			if(t >= 246 && t <= 260)
d283 1
a283 1
			else if(t >= 216 && t <= 228)
d287 1
a287 1
			else if(t >= 187 && t <= 196)
d291 1
a291 1
			else if(t >= 156 && t <= 164)
d295 1
a295 1
			else if(t >= 124 && t <= 132)
d299 1
a299 1
			else if(t >= 108 && t <= 116)
d303 1
a303 1
			else if(t >= 92 && t <= 100)
d307 1
a307 1
			else if(t >= 60 && t <= 68)
d314 1
a314 1
				strBuffer.Format(_T("%d Kbit/s"), t);
d321 1
a321 1
			strBuffer.Format(_T("%d Kbit/s"), m_lAbitrate / (1024 / 8));
@


1.5
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d91 1
a91 1
		{	
d94 1
a94 1
		
d99 1
a99 1
		{	
d102 1
a102 1
		
d131 1
a131 1
				
d135 1
a135 1
		
d141 1
a141 1
		
d147 1
a147 1
		
d157 1
a157 1
		{	
d159 1
a159 1
		}	
d161 1
a161 1
		{	
d181 1
a181 1
		{	
d217 2
a218 2
		}			
			
d238 1
a238 1
			
d332 22
d356 1
a356 1
	if(GetSafeHwnd())
d358 3
d363 5
a367 25
		GetDlgItem(IDC_PICTURE_LBL)->SetWindowText(GetResString(IDS_FD_PICTURE));
		strBuffer.Format("%s:", GetResString(IDS_WIDTH));
		GetDlgItem(IDC_WIDTH_LBL)->SetWindowText(strBuffer);
		strBuffer.Format("%s:", GetResString(IDS_HEIGHT));
		GetDlgItem(IDC_HEIGHT_LBL)->SetWindowText(strBuffer);
		GetDlgItem(IDC_AUDIO_LBL)->SetWindowText(GetResString(IDS_AUDIO));
		strBuffer.Format("%s:", GetResString(IDS_CODEC));
		GetDlgItem(IDC_AUDIOCODEC_LBL)->SetWindowText(strBuffer);
		strBuffer.Format("%s:", GetResString(IDS_BITRATE));
		GetDlgItem(IDC_AUDIOBITRATE_LBL)->SetWindowText(strBuffer);
		GetDlgItem(IDC_ROUNDBITRATE_BTN)->SetWindowText(GetResString(IDS_ROUNDBITRATE));
		strBuffer.Format("%s:", GetResString(IDS_SAMPLERATE));
		GetDlgItem(IDC_SAMPLERATE_LBL)->SetWindowText(strBuffer);
		strBuffer.Format("%s:", GetResString(IDS_CHANNELS));
		GetDlgItem(IDC_CHANNEL_LBL)->SetWindowText(strBuffer);
		GetDlgItem(IDC_VIDEO_LBL)->SetWindowText(GetResString(IDS_VIDEO));
		strBuffer.Format("%s:", GetResString(IDS_CODEC));
		GetDlgItem(IDC_VIDEOCODEC_LBL)->SetWindowText(strBuffer);
		strBuffer.Format("%s:", GetResString(IDS_BITRATE));
		GetDlgItem(IDC_VIDEOBITRATE_LBL)->SetWindowText(strBuffer);
		strBuffer.Format("%s:", GetResString(IDS_FPS));
		GetDlgItem(IDC_FPS_LBL)->SetWindowText(strBuffer);
		GetDlgItem(IDC_FILESIZE_LBL)->SetWindowText(GetResString(IDS_FD_SIZE));
		strBuffer.Format("%s:", GetResString(IDS_LENGTH));
		GetDlgItem(IDC_FILELENGTH_LBL)->SetWindowText(strBuffer);
@


1.4
log
@added missing include
@
text
@d107 1
a107 1
		strBuffer.Format(_T("%.2f MB"), ((float)lSize / 1024 / 1024));
@


1.3
log
@TRY & CATCH
@
text
@d6 1
@


1.2
log
@Localization and some fixes for new detail dialogs by FoRcHa
@
text
@d73 2
d260 2
d266 2
d325 2
d331 2
d363 2
@


1.1
log
@new dialogs for file- & client-details
@
text
@d58 13
a259 18
void CFDAviInfo::Localize()
{

}

BOOL CFDAviInfo::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	m_bARoundBitrate = TRUE;
	CPropertyPage::UpdateData(FALSE);
	Localize();
	Update();

	return TRUE;  // return TRUE unless you set the focus to a control
	// EXCEPTION: OCX Property Pages should return FALSE
}

d319 35
a353 1
}@

