head	1.7;
access;
symbols
	PublicRelease_1_2e:1.7
	Interim_Release_1-2e_RC1:1.7
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.5
	Interim_Release_1-2c_RC1:1.5
	Interim_Release_1-2c_beta1:1.5
	PublicRelease_1_2b:1.5
	Interim_Release_1-2b_RC1:1.5
	PublicRelease_1_2a:1.5
	Interim_Release_1-2a_RC1:1.5
	Interim_Release_1-2a_beta2:1.5
	Interim_Release_1-2a_beta1:1.5
	PublicRelease_1_2:1.5
	Interim_Release_1-2_RC1:1.5
	Interim_Release_1-2_beta1:1.5
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	PublicRelease_1m:1.4
	Interim_Release_1m_beta1:1.4
	PublicRelease_1l:1.4
	Interim_Release_1l_RC3:1.4
	Interim_Release_1l_RC2:1.4
	Interim_Release_1l_RC1:1.4
	Interim_Release_1l_beta2:1.4
	Interim_Release_1l_beta1:1.4
	PublicRelease_1k:1.4
	Interim_Release_1k_RC4:1.4
	Interim_1k_RC3:1.4
	Interim_1k_RC2:1.4
	Interim_Release_1k_RC1:1.4
	Interim_Release_1k_beta5:1.4
	Intrerim_Release_1k_beta4:1.4
	Interim_Release_1k_beta1:1.3
	PublicRelease_1j:1.3
	Interim_Release_1J_RC3:1.3
	Interim_Release_1j_RC3:1.3
	Interim_Release_1j_RC2:1.3
	Interim_Release_1j_RC1:1.3
	Interim_Release_1j_beta2:1.3
	Interim_Release_1j_beta1:1.3
	PublicRelease_1i:1.3
	Interim_Release_1i_RC6:1.3
	Interim_Release_1i_RC3:1.3
	Interim_Release_1i_RC2:1.3
	Interim_Release_1i_RC1:1.3
	Interim_Release_1i_beta3:1.3
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2;
locks; strict;
comment	@// @;


1.7
date	2007.11.03.09.51.28;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.03.09.42.35;	author eklmn;	state Exp;
branches;
next	1.5;

1.5
date	2006.01.06.20.05.56;	author kush_eplus;	state Exp;
branches;
next	1.4;

1.4
date	2004.03.02.00.47.18;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.07.22.31.48;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.08.23.14.03.48;	author dongato;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.23.00.32.24;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.7
log
@remove includes of "UseDialogFont.h"
@
text
@// ScrollStatic.cpp : implementation file
// (p) 2003 by FoRcHa

#include "stdafx.h"
#include "ScrollStatic.h"

#include "..\resource.h"
#include ".\scrollstatic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CScrollStatic

CScrollStatic::CScrollStatic()
{
	m_nOffset = 0;
	m_nTextWidth = 0;
	m_bMouseIn = FALSE;
	m_bLButtonDown = FALSE;
	m_hOldCursor = NULL;
}

CScrollStatic::~CScrollStatic()
{
}


BEGIN_MESSAGE_MAP(CScrollStatic, CStatic)
	//{{AFX_MSG_MAP(CScrollStatic)
	ON_WM_PAINT()
	ON_WM_MOUSEMOVE()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScrollStatic message handlers

void CScrollStatic::OnPaint()
{
	CPaintDC dc(this); // device context for painting
	CRect rClient;
	GetClientRect(rClient);

	CDC MemDC;
	CBitmap MemBMP;

	MemDC.CreateCompatibleDC(&dc);
	MemBMP.CreateCompatibleBitmap(&dc, rClient.Width(), rClient.Height());

	CBitmap *pOldBMP = MemDC.SelectObject(&MemBMP);
	CGdiObject* pOldFont = MemDC.SelectStockObject(DEFAULT_GUI_FONT);

	CStatic::DefWindowProc(WM_PAINT, (WPARAM)MemDC.m_hDC, NULL);
	MemDC.SetBkMode(TRANSPARENT);

	CRect rText = rClient;
	rText.left -= m_nOffset;

	MemDC.DrawText(m_strText, rText, DT_NOPREFIX|DT_NOCLIP|DT_SINGLELINE|DT_LEFT|DT_VCENTER);

	CRect rTest = rClient;
	MemDC.DrawText(m_strText, rTest, DT_CALCRECT|DT_NOPREFIX|DT_NOCLIP|DT_SINGLELINE|DT_LEFT|DT_VCENTER);
	m_nTextWidth = rTest.Width();

	dc.BitBlt(0, 0, rClient.Width(), rClient.Height(), &MemDC, 0, 0, SRCCOPY);

	MemDC.SelectObject(pOldFont);
	MemDC.SelectObject(pOldBMP);
}

BOOL CScrollStatic::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
	return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

void CScrollStatic::OnMouseMove(UINT nFlags, CPoint point)
{
	CRect rClient;
	GetClientRect(rClient);
	ClientToScreen(&rClient);

	CPoint cpPoint = point;
	ClientToScreen(&cpPoint);

	if(rClient.PtInRect(cpPoint))
	{
		if(!m_bMouseIn)
		{
			m_bMouseIn = TRUE;
			SetCapture();

			if(m_nTextWidth > rClient.Width())
			{
				m_hOldCursor = ::SetCursor(::LoadCursor(NULL, IDC_SIZEWE));
			}
		}
	}
	else
	{
		if(!m_bLButtonDown)
		{
			ReleaseCapture();

			if(m_hOldCursor != NULL)
			{
				::SetCursor(m_hOldCursor);
				m_hOldCursor = NULL;
			}
		}

		m_bMouseIn = FALSE;
	}

	if(m_bLButtonDown)
	{
		int nLastOffset = m_nOffset;
		CPoint cpDiff = m_cpLastPoint - point;
		m_cpLastPoint = point;
		m_nOffset = min(m_nOffset + cpDiff.x, m_nTextWidth - rClient.Width());
		m_nOffset = max(0, m_nOffset);
		if(nLastOffset != m_nOffset)
		{
			Invalidate();
		}
	}

	CStatic::OnMouseMove(nFlags, point);
}

void CScrollStatic::OnLButtonDown(UINT nFlags, CPoint point)
{
	m_cpLastPoint = point;
	m_bLButtonDown = TRUE;
	CStatic::OnLButtonDown(nFlags, point);
}

void CScrollStatic::OnLButtonUp(UINT nFlags, CPoint point)
{
	m_bLButtonDown = FALSE;

	if(!m_bMouseIn)
	{
		ReleaseCapture();

		if(m_hOldCursor != NULL)
		{
			::SetCursor(m_hOldCursor);
			m_hOldCursor = NULL;
		}
	}

	CStatic::OnLButtonUp(nFlags, point);
}

void CScrollStatic::SetWindowText(LPCTSTR lpszString)
{
	m_strText = lpszString;
	CStatic::SetWindowText(_T(""));
	if (GetSafeHwnd() != NULL)
		Invalidate();
}
@


1.6
log
@1) don't use a class to get the dialog font
2) change font from ANSI to default
@
text
@a5 1
#include "..\UseDialogFont.h"
@


1.5
log
@UNICODE preparation (first shot)
@
text
@d54 1
d57 1
d59 1
a61 2

	CUseDialogFont Font(&MemDC);
d74 2
@


1.4
log
@Solved all problems with display of '&' in File and Client Details dialogs;
Speed up dialog information drawing.
@
text
@d46 1
a46 1
void CScrollStatic::OnPaint() 
d51 1
a51 1
	
d59 1
a59 1
	
d62 1
a62 1
		
d67 1
a67 1
	
d71 1
a71 1
	
d76 1
a76 1
BOOL CScrollStatic::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
d81 1
a81 1
void CScrollStatic::OnMouseMove(UINT nFlags, CPoint point) 
d86 1
a86 1
	
d89 1
a89 1
	
d96 1
a96 1
			
d98 1
a98 1
			{				
d100 1
a100 1
			}		
d106 1
a106 1
		{			
d108 1
a108 1
			
d123 1
a123 1
		m_cpLastPoint = point;	
d135 1
a135 1
void CScrollStatic::OnLButtonDown(UINT nFlags, CPoint point) 
d138 1
a138 1
	m_bLButtonDown = TRUE;	
d142 1
a142 1
void CScrollStatic::OnLButtonUp(UINT nFlags, CPoint point) 
d144 1
a144 1
	m_bLButtonDown = FALSE;	
d163 2
a164 2
	CStatic::SetWindowText("");
	if(GetSafeHwnd())
@


1.3
log
@small fix
@
text
@d66 1
a66 1
	MemDC.DrawText(m_strText, rText, DT_SINGLELINE|DT_LEFT|DT_VCENTER);
d69 1
a69 1
	MemDC.DrawText(m_strText, rTest, DT_CALCRECT|DT_SINGLELINE|DT_LEFT|DT_VCENTER);
@


1.2
log
@Fixes
@
text
@d9 1
d51 1
a51 1

d57 2
a60 1
	MemDC.FillSolidRect(rClient, GetSysColor(COLOR_3DFACE));
d66 1
a66 3
	CString strText;
	GetWindowText(strText);
	MemDC.DrawText(strText, rText, DT_SINGLELINE|DT_LEFT|DT_VCENTER);
d69 1
a69 1
	MemDC.DrawText(strText, rTest, DT_CALCRECT|DT_SINGLELINE|DT_LEFT|DT_VCENTER);
d158 8
@


1.1
log
@*** empty log message ***
@
text
@d8 1
a8 1
#include "resource.h"
@

