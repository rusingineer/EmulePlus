head	1.764;
access;
symbols
	PublicRelease_1_2e:1.754
	Interim_Release_1-2e_RC1:1.751
	PublicRelease_1_2d:1.743
	Interim_Release_1-2d_RC1:1.742
	Interim_Release_1-2d_beta1:1.739
	PublicRelease_1_2c:1.718
	Interim_Release_1-2c_RC1:1.718
	Interim_Release_1-2c_beta1:1.707
	PublicRelease_1_2b:1.706
	Interim_Release_1-2b_RC1:1.705
	PublicRelease_1_2a:1.701
	Interim_Release_1-2a_RC1:1.696
	Interim_Release_1-2a_beta2:1.681
	Interim_Release_1-2a_beta1:1.665
	PublicRelease_1_2:1.652
	Interim_Release_1-2_RC1:1.651
	Interim_Release_1-2_beta1:1.642
	PublicRelease_1_1g:1.636
	Interim_Release_1-1g_RC3:1.635
	Interim_Release_1-1g_RC2:1.633
	Interim_Release_1-1g_RC1:1.631
	Interim_Release_1-1g_beta2:1.626
	Interim_Release_1-1g_beta1:1.605
	PublicRelease_1_1f:1.594
	Interim_Release_1-1f_RC1:1.594
	PublicRelease_1_1e:1.592
	Interim_Release_1-1e_RC2:1.592
	Interim_Release_1-1e_RC1:1.590
	Interim_Release_1-1e_beta1:1.590
	PublicRelease_1_1d:1.582
	Interim_Release_1-1d_RC1:1.581
	PublicRelease_1_1c:1.580
	Interim_Release_1-1c_RC1:1.578
	Interim_Release_1-1c_beta2:1.574
	Interim_Release_1-1c_beta1:1.564
	PublicRelease_1_1b:1.554
	Interim_Release_1-1b_RC1:1.553
	PublicRelease_1_1a:1.551
	Interim_Release_1-1a_RC2:1.550
	Interim_Release_1-1a_RC1:1.548
	Interim_Release_1-1a_beta2:1.547
	Interim_Release_1-1a_beta1:1.540
	PublicRelease_1_1:1.536
	Interim_Release_1-1_beta1:1.535
	PublicRelease_1o:1.528
	Interim_Release_1o_RC1:1.528
	Interim_Release_1o_beta1:1.528
	PublicRelease_1n:1.525
	Interim_Release_1n_RC2:1.525
	Interim_Release_1n_RC1:1.522
	Interim_Release_1n_beta2:1.503
	Interim_Release_1n_beta1:1.499
	PublicRelease_1m:1.476
	Interim_Release_1m_beta1:1.476
	PublicRelease_1l:1.475
	Interim_Release_1l_RC3:1.474
	Interim_Release_1l_RC2:1.472
	Interim_Release_1l_RC1:1.460
	Interim_Release_1l_beta2:1.457
	Interim_Release_1l_beta1:1.443
	PublicRelease_1k:1.423
	Interim_Release_1k_RC4:1.422
	Interim_1k_RC3:1.422
	Interim_1k_RC2:1.420
	Interim_Release_1k_RC1:1.419
	Interim_Release_1k_beta5:1.412
	Intrerim_Release_1k_beta4:1.412
	Interim_Release_1k_beta1:1.394
	PublicRelease_1j:1.359
	Interim_Release_1J_RC3:1.359
	Interim_Release_1j_RC3:1.359
	Interim_Release_1j_RC2:1.345
	Interim_Release_1j_RC1:1.344
	Interim_Release_1j_beta2:1.343
	Interim_Release_1j_beta1:1.336
	PublicRelease_1i:1.323
	Interim_Release_1i_RC6:1.322
	Interim_Release_1i_RC3:1.315
	Interim_Release_1i_RC2:1.310
	Interim_Release_1i_RC1:1.298
	Interim_Release_1i_beta3:1.293
	Interim_Release_1i_beta2:1.284
	Interim_Release_1i_beta1:1.266
	PublicRelease_1h:1.236
	Interim_Release_1h_rc2:1.236
	Interim_Release_1h_RC1:1.235
	Interim_Release_1h_beta2:1.224
	Interim_Release_1h_beta1_now:1.213
	Interim_Release_1h_beta1:1.213
	PublicRelease_1g:1.201
	Interim_Release_1g_RC6_Final:1.201
	Interim_Release_1g_RC6:1.193
	Interim_Release_1g_RC5:1.192
	Interim_Release_1g_RC4:1.189
	Interim_Release_1g_RC3:1.180
	Interim_Release_1g_beta2:1.134
	Interim_Release_1g_beta1:1.117
	Interim_Release_1f_RC4:1.108
	Interim_Release_1f_RC3:1.108
	Interim_Release_1f_RC2:1.100
	Interim_Release_1f_RC:1.98
	Interim_Release_1f_beta2:1.96
	Interim_Release_1f_beta1:1.94
	PublicRelease_1e:1.90
	Interim_Release_1e_RC2:1.90
	Interim_Release_1e_RC:1.90
	Interim_Release_1e_beta3:1.87
	Interim_Release_1e_beta2:1.87
	Interim_Release_1e_beta2_before_kuchin:1.87
	Interim_Release_1e_beta1:1.87
	PublicRelease_1c:1.78
	featurestest:1.78.0.2
	Interim_Release_1c_RC:1.78
	Interim_Release_1c_beta2:1.73
	Interim_Release_1c_beta1:1.61
	threaded_downloadqueue:1.61.0.2
	PublicRelease_1b:1.55
	Interim_Release_1b_beta2:1.55
	Interim_Release_1b_beta1:1.49
	proxydeadlake:1.40.0.2
	PublicRelease_1a:1.40
	Interim_Release_1a_beta2:1.38
	BerkeleyDb:1.32.0.2
	Interim_Release_1a_beta1:1.30
	PublicRelease_1:1.27
	goldfish:1.27
	eMulePlus_1_RC2:1.26
	eMulePlus_26b_1RC1:1.24
	PreRelease_26b_i0e:1.24
	before_26d_merge:1.18
	Interim_Release_26b_i0d:1.15
	Interim_Release_26b_i0c:1.13
	Interim_Release_26b_i0b:1.13
	Interim_Release_26b_i0a:1.13
	systraydlg:1.10.0.4
	plus26based:1.10.0.2
	Interim_Release_25b_i0b:1.10
	Proxy_Dev:1.8
	Interim_Release_25b_i0a:1.5.2.2
	proxytest:1.5.2.1.0.2
	official_sockets:1.5.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.764
date	2010.02.10.23.58.21;	author aw3;	state Exp;
branches;
next	1.763;

1.763
date	2009.10.28.04.34.59;	author aw3;	state Exp;
branches;
next	1.762;

1.762
date	2009.10.12.04.42.01;	author aw3;	state Exp;
branches;
next	1.761;

1.761
date	2009.07.31.12.42.32;	author aw3;	state Exp;
branches;
next	1.760;

1.760
date	2009.06.02.02.19.42;	author aw3;	state Exp;
branches;
next	1.759;

1.759
date	2009.05.31.02.23.27;	author aw3;	state Exp;
branches;
next	1.758;

1.758
date	2009.05.22.01.03.00;	author aw3;	state Exp;
branches;
next	1.757;

1.757
date	2009.05.01.04.16.33;	author aw3;	state Exp;
branches;
next	1.756;

1.756
date	2009.04.26.03.15.59;	author aw3;	state Exp;
branches;
next	1.755;

1.755
date	2009.04.21.02.48.41;	author aw3;	state Exp;
branches;
next	1.754;

1.754
date	2009.04.10.03.37.49;	author aw3;	state Exp;
branches;
next	1.753;

1.753
date	2009.04.04.20.14.22;	author aw3;	state Exp;
branches;
next	1.752;

1.752
date	2009.04.04.05.34.38;	author aw3;	state Exp;
branches;
next	1.751;

1.751
date	2009.01.20.03.38.27;	author aw3;	state Exp;
branches;
next	1.750;

1.750
date	2009.01.13.05.16.00;	author aw3;	state Exp;
branches;
next	1.749;

1.749
date	2008.12.03.05.10.36;	author aw3;	state Exp;
branches;
next	1.748;

1.748
date	2008.11.24.03.13.33;	author aw3;	state Exp;
branches;
next	1.747;

1.747
date	2008.11.19.13.59.29;	author aw3;	state Exp;
branches;
next	1.746;

1.746
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.745;

1.745
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.744;

1.744
date	2008.10.13.03.32.18;	author aw3;	state Exp;
branches;
next	1.743;

1.743
date	2008.04.22.03.24.20;	author aw3;	state Exp;
branches;
next	1.742;

1.742
date	2008.03.15.04.18.05;	author aw3;	state Exp;
branches;
next	1.741;

1.741
date	2008.03.12.04.46.19;	author aw3;	state Exp;
branches;
next	1.740;

1.740
date	2008.03.03.05.26.17;	author aw3;	state Exp;
branches;
next	1.739;

1.739
date	2008.02.04.05.45.17;	author aw3;	state Exp;
branches;
next	1.738;

1.738
date	2008.01.31.22.50.30;	author eklmn;	state Exp;
branches;
next	1.737;

1.737
date	2008.01.23.05.10.47;	author aw3;	state Exp;
branches;
next	1.736;

1.736
date	2008.01.20.16.19.02;	author aw3;	state Exp;
branches;
next	1.735;

1.735
date	2008.01.16.00.56.06;	author aw3;	state Exp;
branches;
next	1.734;

1.734
date	2008.01.03.13.51.36;	author eklmn;	state Exp;
branches;
next	1.733;

1.733
date	2008.01.02.05.30.52;	author aw3;	state Exp;
branches;
next	1.732;

1.732
date	2008.01.01.11.12.05;	author eklmn;	state Exp;
branches;
next	1.731;

1.731
date	2007.12.31.05.59.09;	author aw3;	state Exp;
branches;
next	1.730;

1.730
date	2007.12.30.06.11.47;	author aw3;	state Exp;
branches;
next	1.729;

1.729
date	2007.12.28.04.05.03;	author aw3;	state Exp;
branches;
next	1.728;

1.728
date	2007.12.05.22.02.47;	author eklmn;	state Exp;
branches;
next	1.727;

1.727
date	2007.12.01.10.38.06;	author eklmn;	state Exp;
branches;
next	1.726;

1.726
date	2007.11.13.22.12.39;	author kush_eplus;	state Exp;
branches;
next	1.725;

1.725
date	2007.11.12.23.49.44;	author fuxie-dk;	state Exp;
branches;
next	1.724;

1.724
date	2007.11.02.14.41.47;	author kush_eplus;	state Exp;
branches;
next	1.723;

1.723
date	2007.10.24.19.09.35;	author fuxie-dk;	state Exp;
branches;
next	1.722;

1.722
date	2007.10.18.14.48.19;	author fuxie-dk;	state Exp;
branches;
next	1.721;

1.721
date	2007.10.17.14.17.20;	author fuxie-dk;	state Exp;
branches;
next	1.720;

1.720
date	2007.10.11.18.06.25;	author fuxie-dk;	state Exp;
branches;
next	1.719;

1.719
date	2007.09.27.14.28.11;	author fuxie-dk;	state Exp;
branches;
next	1.718;

1.718
date	2007.08.13.04.12.01;	author aw3;	state Exp;
branches;
next	1.717;

1.717
date	2007.08.09.02.59.39;	author aw3;	state Exp;
branches;
next	1.716;

1.716
date	2007.08.04.01.21.59;	author aw3;	state Exp;
branches;
next	1.715;

1.715
date	2007.07.24.00.56.23;	author aw3;	state Exp;
branches;
next	1.714;

1.714
date	2007.07.23.04.32.19;	author aw3;	state Exp;
branches;
next	1.713;

1.713
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.712;

1.712
date	2007.06.14.03.25.12;	author aw3;	state Exp;
branches;
next	1.711;

1.711
date	2007.06.04.01.32.15;	author aw3;	state Exp;
branches;
next	1.710;

1.710
date	2007.06.01.04.49.26;	author aw3;	state Exp;
branches;
next	1.709;

1.709
date	2007.05.28.02.07.14;	author aw3;	state Exp;
branches;
next	1.708;

1.708
date	2007.03.18.15.36.51;	author aw3;	state Exp;
branches;
next	1.707;

1.707
date	2007.02.08.03.58.47;	author aw3;	state Exp;
branches;
next	1.706;

1.706
date	2007.01.25.13.25.00;	author aw3;	state Exp;
branches;
next	1.705;

1.705
date	2007.01.17.08.03.42;	author aw3;	state Exp;
branches;
next	1.704;

1.704
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.703;

1.703
date	2006.11.13.16.55.07;	author eklmn;	state Exp;
branches;
next	1.702;

1.702
date	2006.11.05.04.56.24;	author aw3;	state Exp;
branches;
next	1.701;

1.701
date	2006.10.13.04.28.42;	author aw3;	state Exp;
branches;
next	1.700;

1.700
date	2006.10.11.04.16.40;	author aw3;	state Exp;
branches;
next	1.699;

1.699
date	2006.10.07.09.13.18;	author kush_eplus;	state Exp;
branches;
next	1.698;

1.698
date	2006.09.23.16.47.52;	author aw3;	state Exp;
branches;
next	1.697;

1.697
date	2006.09.21.03.28.34;	author aw3;	state Exp;
branches;
next	1.696;

1.696
date	2006.09.18.13.25.08;	author aw3;	state Exp;
branches;
next	1.695;

1.695
date	2006.09.12.04.29.43;	author aw3;	state Exp;
branches;
next	1.694;

1.694
date	2006.09.05.01.13.20;	author aw3;	state Exp;
branches;
next	1.693;

1.693
date	2006.08.28.00.35.34;	author aw3;	state Exp;
branches;
next	1.692;

1.692
date	2006.08.26.21.32.36;	author aw3;	state Exp;
branches;
next	1.691;

1.691
date	2006.08.23.03.01.17;	author aw3;	state Exp;
branches;
next	1.690;

1.690
date	2006.08.21.03.49.37;	author aw3;	state Exp;
branches;
next	1.689;

1.689
date	2006.08.20.03.32.22;	author aw3;	state Exp;
branches;
next	1.688;

1.688
date	2006.08.18.04.19.18;	author aw3;	state Exp;
branches;
next	1.687;

1.687
date	2006.08.14.02.18.02;	author aw3;	state Exp;
branches;
next	1.686;

1.686
date	2006.07.16.04.31.42;	author aw3;	state Exp;
branches;
next	1.685;

1.685
date	2006.07.13.12.07.27;	author aw3;	state Exp;
branches;
next	1.684;

1.684
date	2006.07.02.18.59.07;	author aw3;	state Exp;
branches;
next	1.683;

1.683
date	2006.07.01.15.51.33;	author aw3;	state Exp;
branches;
next	1.682;

1.682
date	2006.06.27.04.40.22;	author aw3;	state Exp;
branches;
next	1.681;

1.681
date	2006.06.19.04.22.45;	author aw3;	state Exp;
branches;
next	1.680;

1.680
date	2006.06.15.04.36.18;	author aw3;	state Exp;
branches;
next	1.679;

1.679
date	2006.06.11.23.21.06;	author aw3;	state Exp;
branches;
next	1.678;

1.678
date	2006.06.05.04.32.15;	author aw3;	state Exp;
branches;
next	1.677;

1.677
date	2006.05.27.02.46.30;	author aw3;	state Exp;
branches;
next	1.676;

1.676
date	2006.05.23.04.34.54;	author aw3;	state Exp;
branches;
next	1.675;

1.675
date	2006.05.22.22.33.11;	author aw3;	state Exp;
branches;
next	1.674;

1.674
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.673;

1.673
date	2006.05.21.06.14.29;	author aw3;	state Exp;
branches;
next	1.672;

1.672
date	2006.05.17.03.51.31;	author aw3;	state Exp;
branches;
next	1.671;

1.671
date	2006.05.15.05.51.10;	author aw3;	state Exp;
branches;
next	1.670;

1.670
date	2006.05.14.03.37.53;	author aw3;	state Exp;
branches;
next	1.669;

1.669
date	2006.05.13.04.51.22;	author aw3;	state Exp;
branches;
next	1.668;

1.668
date	2006.05.13.01.47.33;	author aw3;	state Exp;
branches;
next	1.667;

1.667
date	2006.05.07.05.03.08;	author aw3;	state Exp;
branches;
next	1.666;

1.666
date	2006.05.05.11.55.42;	author aw3;	state Exp;
branches;
next	1.665;

1.665
date	2006.05.01.01.25.12;	author aw3;	state Exp;
branches;
next	1.664;

1.664
date	2006.04.30.14.01.16;	author aw3;	state Exp;
branches;
next	1.663;

1.663
date	2006.04.27.11.33.24;	author aw3;	state Exp;
branches;
next	1.662;

1.662
date	2006.04.26.11.56.28;	author aw3;	state Exp;
branches;
next	1.661;

1.661
date	2006.04.26.03.21.48;	author aw3;	state Exp;
branches;
next	1.660;

1.660
date	2006.04.22.21.58.08;	author aw3;	state Exp;
branches;
next	1.659;

1.659
date	2006.04.22.15.46.05;	author aw3;	state Exp;
branches;
next	1.658;

1.658
date	2006.04.18.15.46.48;	author eklmn;	state Exp;
branches;
next	1.657;

1.657
date	2006.04.08.07.44.11;	author eklmn;	state Exp;
branches;
next	1.656;

1.656
date	2006.04.04.22.28.40;	author kush_eplus;	state Exp;
branches;
next	1.655;

1.655
date	2006.03.27.03.46.40;	author aw3;	state Exp;
branches;
next	1.654;

1.654
date	2006.03.21.21.51.27;	author eklmn;	state Exp;
branches;
next	1.653;

1.653
date	2006.03.17.07.03.27;	author aw3;	state Exp;
branches;
next	1.652;

1.652
date	2006.02.26.21.44.05;	author aw3;	state Exp;
branches;
next	1.651;

1.651
date	2006.02.19.22.56.57;	author kush_eplus;	state Exp;
branches;
next	1.650;

1.650
date	2006.02.19.22.16.16;	author aw3;	state Exp;
branches;
next	1.649;

1.649
date	2006.02.14.15.51.10;	author aw3;	state Exp;
branches;
next	1.648;

1.648
date	2006.02.14.06.49.59;	author eklmn;	state Exp;
branches;
next	1.647;

1.647
date	2006.02.13.05.36.44;	author aw3;	state Exp;
branches;
next	1.646;

1.646
date	2006.02.12.17.40.29;	author eklmn;	state Exp;
branches;
next	1.645;

1.645
date	2006.02.10.17.09.42;	author eklmn;	state Exp;
branches;
next	1.644;

1.644
date	2006.02.05.03.51.46;	author aw3;	state Exp;
branches;
next	1.643;

1.643
date	2006.02.02.07.02.09;	author eklmn;	state Exp;
branches;
next	1.642;

1.642
date	2006.01.25.05.23.50;	author aw3;	state Exp;
branches;
next	1.641;

1.641
date	2006.01.14.19.53.10;	author aw3;	state Exp;
branches;
next	1.640;

1.640
date	2006.01.03.13.11.37;	author eklmn;	state Exp;
branches;
next	1.639;

1.639
date	2006.01.03.04.40.57;	author aw3;	state Exp;
branches;
next	1.638;

1.638
date	2005.12.29.05.34.52;	author aw3;	state Exp;
branches;
next	1.637;

1.637
date	2005.12.28.21.52.52;	author eklmn;	state Exp;
branches;
next	1.636;

1.636
date	2005.12.20.06.41.53;	author eklmn;	state Exp;
branches;
next	1.635;

1.635
date	2005.12.12.18.25.53;	author eklmn;	state Exp;
branches;
next	1.634;

1.634
date	2005.12.10.05.51.33;	author aw3;	state Exp;
branches;
next	1.633;

1.633
date	2005.12.08.05.49.25;	author aw3;	state Exp;
branches;
next	1.632;

1.632
date	2005.12.03.07.57.57;	author eklmn;	state Exp;
branches;
next	1.631;

1.631
date	2005.12.01.06.49.41;	author eklmn;	state Exp;
branches;
next	1.630;

1.630
date	2005.11.28.05.27.37;	author aw3;	state Exp;
branches;
next	1.629;

1.629
date	2005.11.28.03.11.13;	author aw3;	state Exp;
branches;
next	1.628;

1.628
date	2005.11.27.22.11.48;	author eklmn;	state Exp;
branches;
next	1.627;

1.627
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.626;

1.626
date	2005.11.27.03.27.22;	author aw3;	state Exp;
branches;
next	1.625;

1.625
date	2005.11.26.08.48.32;	author eklmn;	state Exp;
branches;
next	1.624;

1.624
date	2005.11.25.05.11.44;	author aw3;	state Exp;
branches;
next	1.623;

1.623
date	2005.11.23.03.29.17;	author aw3;	state Exp;
branches;
next	1.622;

1.622
date	2005.11.16.20.55.30;	author eklmn;	state Exp;
branches;
next	1.621;

1.621
date	2005.11.16.05.57.03;	author aw3;	state Exp;
branches;
next	1.620;

1.620
date	2005.11.15.06.05.11;	author aw3;	state Exp;
branches;
next	1.619;

1.619
date	2005.10.17.04.01.59;	author aw3;	state Exp;
branches;
next	1.618;

1.618
date	2005.10.04.03.27.25;	author aw3;	state Exp;
branches;
next	1.617;

1.617
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.616;

1.616
date	2005.09.26.03.17.59;	author aw3;	state Exp;
branches;
next	1.615;

1.615
date	2005.09.26.00.31.31;	author aw3;	state Exp;
branches;
next	1.614;

1.614
date	2005.09.23.18.19.07;	author eklmn;	state Exp;
branches;
next	1.613;

1.613
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.612;

1.612
date	2005.09.13.05.56.49;	author aw3;	state Exp;
branches;
next	1.611;

1.611
date	2005.09.05.21.43.14;	author aw3;	state Exp;
branches;
next	1.610;

1.610
date	2005.09.01.03.47.05;	author aw3;	state Exp;
branches;
next	1.609;

1.609
date	2005.08.31.04.19.50;	author aw3;	state Exp;
branches;
next	1.608;

1.608
date	2005.08.28.08.28.56;	author eklmn;	state Exp;
branches;
next	1.607;

1.607
date	2005.08.27.15.10.09;	author aw3;	state Exp;
branches;
next	1.606;

1.606
date	2005.08.25.11.57.47;	author aw3;	state Exp;
branches;
next	1.605;

1.605
date	2005.08.24.03.32.32;	author aw3;	state Exp;
branches;
next	1.604;

1.604
date	2005.08.21.23.05.20;	author aw3;	state Exp;
branches;
next	1.603;

1.603
date	2005.08.21.21.26.41;	author eklmn;	state Exp;
branches;
next	1.602;

1.602
date	2005.08.20.08.42.01;	author eklmn;	state Exp;
branches;
next	1.601;

1.601
date	2005.08.18.19.08.22;	author eklmn;	state Exp;
branches;
next	1.600;

1.600
date	2005.08.17.18.49.43;	author eklmn;	state Exp;
branches;
next	1.599;

1.599
date	2005.08.14.03.14.13;	author aw3;	state Exp;
branches;
next	1.598;

1.598
date	2005.08.11.05.19.37;	author aw3;	state Exp;
branches;
next	1.597;

1.597
date	2005.08.10.05.20.40;	author eklmn;	state Exp;
branches;
next	1.596;

1.596
date	2005.08.07.17.13.29;	author aw3;	state Exp;
branches;
next	1.595;

1.595
date	2005.08.04.03.34.40;	author aw3;	state Exp;
branches;
next	1.594;

1.594
date	2005.07.25.03.40.19;	author aw3;	state Exp;
branches;
next	1.593;

1.593
date	2005.07.15.04.48.11;	author aw3;	state Exp;
branches;
next	1.592;

1.592
date	2005.07.06.02.07.43;	author aw3;	state Exp;
branches;
next	1.591;

1.591
date	2005.06.28.03.54.50;	author aw3;	state Exp;
branches;
next	1.590;

1.590
date	2005.06.06.04.38.54;	author aw3;	state Exp;
branches;
next	1.589;

1.589
date	2005.05.23.19.44.00;	author aw3;	state Exp;
branches;
next	1.588;

1.588
date	2005.04.28.03.42.28;	author aw3;	state Exp;
branches;
next	1.587;

1.587
date	2005.03.31.02.08.39;	author aw3;	state Exp;
branches;
next	1.586;

1.586
date	2005.03.28.12.49.15;	author aw3;	state Exp;
branches;
next	1.585;

1.585
date	2005.03.28.08.43.32;	author bavariansnail;	state Exp;
branches;
next	1.584;

1.584
date	2005.03.24.04.14.33;	author aw3;	state Exp;
branches;
next	1.583;

1.583
date	2005.03.22.15.54.10;	author kuchin;	state Exp;
branches;
next	1.582;

1.582
date	2005.03.15.04.43.25;	author aw3;	state Exp;
branches;
next	1.581;

1.581
date	2005.03.07.03.27.43;	author aw3;	state Exp;
branches;
next	1.580;

1.580
date	2005.02.28.00.53.19;	author aw3;	state Exp;
branches;
next	1.579;

1.579
date	2005.02.26.17.52.05;	author kuchin;	state Exp;
branches;
next	1.578;

1.578
date	2005.02.24.04.20.49;	author aw3;	state Exp;
branches;
next	1.577;

1.577
date	2005.02.22.01.46.37;	author aw3;	state Exp;
branches;
next	1.576;

1.576
date	2005.02.19.09.56.39;	author eklmn;	state Exp;
branches;
next	1.575;

1.575
date	2005.02.17.20.06.48;	author aw3;	state Exp;
branches;
next	1.574;

1.574
date	2005.02.16.05.07.47;	author aw3;	state Exp;
branches;
next	1.573;

1.573
date	2005.02.14.22.46.36;	author aw3;	state Exp;
branches;
next	1.572;

1.572
date	2005.02.13.19.41.06;	author aw3;	state Exp;
branches;
next	1.571;

1.571
date	2005.02.12.21.46.43;	author aw3;	state Exp;
branches;
next	1.570;

1.570
date	2005.02.12.00.52.00;	author aw3;	state Exp;
branches;
next	1.569;

1.569
date	2005.02.08.05.50.47;	author aw3;	state Exp;
branches;
next	1.568;

1.568
date	2005.02.07.22.38.57;	author aw3;	state Exp;
branches;
next	1.567;

1.567
date	2005.02.04.23.41.56;	author aw3;	state Exp;
branches;
next	1.566;

1.566
date	2005.02.03.19.48.07;	author kuchin;	state Exp;
branches;
next	1.565;

1.565
date	2005.02.01.03.58.05;	author aw3;	state Exp;
branches;
next	1.564;

1.564
date	2005.01.28.19.45.09;	author aw3;	state Exp;
branches;
next	1.563;

1.563
date	2005.01.27.17.44.03;	author aw3;	state Exp;
branches;
next	1.562;

1.562
date	2005.01.27.00.14.02;	author aw3;	state Exp;
branches;
next	1.561;

1.561
date	2005.01.24.03.38.04;	author aw3;	state Exp;
branches;
next	1.560;

1.560
date	2005.01.19.21.10.47;	author netwolf1;	state Exp;
branches;
next	1.559;

1.559
date	2005.01.19.14.04.41;	author kush_eplus;	state Exp;
branches;
next	1.558;

1.558
date	2005.01.12.15.35.09;	author katsyonak;	state Exp;
branches;
next	1.557;

1.557
date	2005.01.07.22.28.55;	author netwolf1;	state Exp;
branches;
next	1.556;

1.556
date	2005.01.07.03.43.01;	author netwolf1;	state Exp;
branches;
next	1.555;

1.555
date	2005.01.06.18.59.45;	author netwolf1;	state Exp;
branches;
next	1.554;

1.554
date	2004.12.25.09.15.18;	author aw3;	state Exp;
branches;
next	1.553;

1.553
date	2004.12.15.00.15.56;	author aw3;	state Exp;
branches;
next	1.552;

1.552
date	2004.12.13.05.25.08;	author aw3;	state Exp;
branches;
next	1.551;

1.551
date	2004.12.10.00.39.31;	author aw3;	state Exp;
branches;
next	1.550;

1.550
date	2004.12.03.21.00.14;	author aw3;	state Exp;
branches;
next	1.549;

1.549
date	2004.12.02.07.25.45;	author aw3;	state Exp;
branches;
next	1.548;

1.548
date	2004.11.26.18.59.51;	author aw3;	state Exp;
branches;
next	1.547;

1.547
date	2004.11.20.07.16.07;	author eklmn;	state Exp;
branches;
next	1.546;

1.546
date	2004.11.18.06.57.49;	author aw3;	state Exp;
branches;
next	1.545;

1.545
date	2004.11.18.03.30.12;	author aw3;	state Exp;
branches;
next	1.544;

1.544
date	2004.11.15.19.08.51;	author aw3;	state Exp;
branches;
next	1.543;

1.543
date	2004.11.15.05.55.47;	author aw3;	state Exp;
branches;
next	1.542;

1.542
date	2004.11.14.23.39.10;	author aw3;	state Exp;
branches;
next	1.541;

1.541
date	2004.11.10.17.24.33;	author aw3;	state Exp;
branches;
next	1.540;

1.540
date	2004.11.07.12.28.54;	author eklmn;	state Exp;
branches;
next	1.539;

1.539
date	2004.11.02.17.08.17;	author aw3;	state Exp;
branches;
next	1.538;

1.538
date	2004.11.01.04.40.15;	author aw3;	state Exp;
branches;
next	1.537;

1.537
date	2004.10.31.11.18.36;	author dongato;	state Exp;
branches;
next	1.536;

1.536
date	2004.10.20.17.08.05;	author aw3;	state Exp;
branches;
next	1.535;

1.535
date	2004.10.18.04.41.38;	author aw3;	state Exp;
branches;
next	1.534;

1.534
date	2004.10.17.20.03.52;	author aw3;	state Exp;
branches;
next	1.533;

1.533
date	2004.10.14.19.17.23;	author aw3;	state Exp;
branches;
next	1.532;

1.532
date	2004.10.14.05.09.40;	author aw3;	state Exp;
branches;
next	1.531;

1.531
date	2004.10.09.11.45.20;	author dongato;	state Exp;
branches;
next	1.530;

1.530
date	2004.10.08.15.46.47;	author dongato;	state Exp;
branches;
next	1.529;

1.529
date	2004.10.08.03.28.31;	author dongato;	state Exp;
branches;
next	1.528;

1.528
date	2004.09.24.03.17.51;	author aw3;	state Exp;
branches;
next	1.527;

1.527
date	2004.09.17.03.08.49;	author aw3;	state Exp;
branches;
next	1.526;

1.526
date	2004.09.15.01.48.48;	author aw3;	state Exp;
branches;
next	1.525;

1.525
date	2004.09.07.19.54.26;	author aw3;	state Exp;
branches;
next	1.524;

1.524
date	2004.09.05.22.13.40;	author aw3;	state Exp;
branches;
next	1.523;

1.523
date	2004.08.31.05.18.05;	author eklmn;	state Exp;
branches;
next	1.522;

1.522
date	2004.08.27.17.17.10;	author eklmn;	state Exp;
branches;
next	1.521;

1.521
date	2004.08.27.05.52.12;	author aw3;	state Exp;
branches;
next	1.520;

1.520
date	2004.08.23.22.44.02;	author syrus77;	state Exp;
branches;
next	1.519;

1.519
date	2004.08.23.19.32.12;	author eklmn;	state Exp;
branches;
next	1.518;

1.518
date	2004.08.23.18.46.33;	author eklmn;	state Exp;
branches;
next	1.517;

1.517
date	2004.08.23.12.45.34;	author eklmn;	state Exp;
branches;
next	1.516;

1.516
date	2004.08.21.08.06.21;	author aw3;	state Exp;
branches;
next	1.515;

1.515
date	2004.08.20.12.03.36;	author syrus77;	state Exp;
branches;
next	1.514;

1.514
date	2004.08.20.11.17.48;	author syrus77;	state Exp;
branches;
next	1.513;

1.513
date	2004.08.20.07.37.26;	author eklmn;	state Exp;
branches;
next	1.512;

1.512
date	2004.08.20.02.37.23;	author syrus77;	state Exp;
branches;
next	1.511;

1.511
date	2004.08.20.02.32.02;	author syrus77;	state Exp;
branches;
next	1.510;

1.510
date	2004.08.19.00.33.07;	author syrus77;	state Exp;
branches;
next	1.509;

1.509
date	2004.08.17.05.21.19;	author eklmn;	state Exp;
branches;
next	1.508;

1.508
date	2004.08.16.15.37.55;	author aw3;	state Exp;
branches;
next	1.507;

1.507
date	2004.08.16.13.36.12;	author eklmn;	state Exp;
branches;
next	1.506;

1.506
date	2004.08.15.20.55.41;	author eklmn;	state Exp;
branches;
next	1.505;

1.505
date	2004.08.15.08.12.25;	author eklmn;	state Exp;
branches;
next	1.504;

1.504
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.503;

1.503
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.502;

1.502
date	2004.08.06.04.40.01;	author aw3;	state Exp;
branches;
next	1.501;

1.501
date	2004.08.02.04.31.50;	author aw3;	state Exp;
branches;
next	1.500;

1.500
date	2004.07.29.04.49.51;	author aw3;	state Exp;
branches;
next	1.499;

1.499
date	2004.07.16.19.08.06;	author dongato;	state Exp;
branches;
next	1.498;

1.498
date	2004.07.15.18.18.27;	author eklmn;	state Exp;
branches;
next	1.497;

1.497
date	2004.07.15.17.58.14;	author eklmn;	state Exp;
branches;
next	1.496;

1.496
date	2004.07.14.15.09.36;	author eklmn;	state Exp;
branches;
next	1.495;

1.495
date	2004.07.14.15.07.30;	author eklmn;	state Exp;
branches;
next	1.494;

1.494
date	2004.07.14.04.52.35;	author aw3;	state Exp;
branches;
next	1.493;

1.493
date	2004.07.13.04.02.00;	author aw3;	state Exp;
branches;
next	1.492;

1.492
date	2004.07.11.21.51.46;	author aw3;	state Exp;
branches;
next	1.491;

1.491
date	2004.07.11.05.43.55;	author aw3;	state Exp;
branches;
next	1.490;

1.490
date	2004.07.09.22.43.17;	author aw3;	state Exp;
branches;
next	1.489;

1.489
date	2004.07.09.19.48.22;	author aw3;	state Exp;
branches;
next	1.488;

1.488
date	2004.07.09.18.39.19;	author eklmn;	state Exp;
branches;
next	1.487;

1.487
date	2004.07.09.17.35.01;	author eklmn;	state Exp;
branches;
next	1.486;

1.486
date	2004.07.07.16.19.04;	author dongato;	state Exp;
branches;
next	1.485;

1.485
date	2004.07.07.12.32.50;	author dongato;	state Exp;
branches;
next	1.484;

1.484
date	2004.07.07.05.14.39;	author aw3;	state Exp;
branches;
next	1.483;

1.483
date	2004.07.06.19.13.45;	author eklmn;	state Exp;
branches;
next	1.482;

1.482
date	2004.07.06.16.54.44;	author eklmn;	state Exp;
branches;
next	1.481;

1.481
date	2004.07.05.20.50.57;	author dongato;	state Exp;
branches;
next	1.480;

1.480
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.479;

1.479
date	2004.06.29.17.18.28;	author dongato;	state Exp;
branches;
next	1.478;

1.478
date	2004.06.27.02.56.11;	author dongato;	state Exp;
branches;
next	1.477;

1.477
date	2004.06.26.15.10.13;	author dongato;	state Exp;
branches;
next	1.476;

1.476
date	2004.06.17.12.23.06;	author netwolf1;	state Exp;
branches;
next	1.475;

1.475
date	2004.06.10.22.04.19;	author netwolf1;	state Exp;
branches;
next	1.474;

1.474
date	2004.06.07.21.01.24;	author syrus77;	state Exp;
branches;
next	1.473;

1.473
date	2004.06.04.16.39.09;	author dongato;	state Exp;
branches;
next	1.472;

1.472
date	2004.06.02.22.15.04;	author syrus77;	state Exp;
branches;
next	1.471;

1.471
date	2004.06.02.21.11.44;	author aw3;	state Exp;
branches;
next	1.470;

1.470
date	2004.05.31.23.44.54;	author syrus77;	state Exp;
branches;
next	1.469;

1.469
date	2004.05.31.23.05.25;	author aw3;	state Exp;
branches;
next	1.468;

1.468
date	2004.05.30.19.44.08;	author bavariansnail;	state Exp;
branches;
next	1.467;

1.467
date	2004.05.29.19.25.22;	author syrus77;	state Exp;
branches;
next	1.466;

1.466
date	2004.05.29.19.15.41;	author syrus77;	state Exp;
branches;
next	1.465;

1.465
date	2004.05.29.12.30.21;	author dropf;	state Exp;
branches;
next	1.464;

1.464
date	2004.05.29.08.39.48;	author bavariansnail;	state Exp;
branches;
next	1.463;

1.463
date	2004.05.29.01.08.48;	author aw3;	state Exp;
branches;
next	1.462;

1.462
date	2004.05.28.17.01.08;	author aw3;	state Exp;
branches;
next	1.461;

1.461
date	2004.05.27.01.54.48;	author aw3;	state Exp;
branches;
next	1.460;

1.460
date	2004.05.26.06.22.57;	author aw3;	state Exp;
branches;
next	1.459;

1.459
date	2004.05.25.19.11.15;	author bavariansnail;	state Exp;
branches;
next	1.458;

1.458
date	2004.05.23.10.11.58;	author dongato;	state Exp;
branches;
next	1.457;

1.457
date	2004.05.21.15.50.02;	author dongato;	state Exp;
branches;
next	1.456;

1.456
date	2004.05.19.16.03.22;	author netwolf1;	state Exp;
branches;
next	1.455;

1.455
date	2004.05.19.10.14.29;	author netwolf1;	state Exp;
branches;
next	1.454;

1.454
date	2004.05.18.21.37.38;	author kush_eplus;	state Exp;
branches;
next	1.453;

1.453
date	2004.05.18.21.07.56;	author katsyonak;	state Exp;
branches;
next	1.452;

1.452
date	2004.05.18.16.23.06;	author dongato;	state Exp;
branches;
next	1.451;

1.451
date	2004.05.17.16.51.10;	author kush_eplus;	state Exp;
branches;
next	1.450;

1.450
date	2004.05.17.15.57.52;	author kush_eplus;	state Exp;
branches;
next	1.449;

1.449
date	2004.05.16.23.59.48;	author aw3;	state Exp;
branches;
next	1.448;

1.448
date	2004.05.16.06.05.03;	author aw3;	state Exp;
branches;
next	1.447;

1.447
date	2004.05.13.03.21.04;	author kush_eplus;	state Exp;
branches;
next	1.446;

1.446
date	2004.05.12.08.30.30;	author netwolf1;	state Exp;
branches;
next	1.445;

1.445
date	2004.05.11.14.03.18;	author katsyonak;	state Exp;
branches;
next	1.444;

1.444
date	2004.05.10.01.25.32;	author katsyonak;	state Exp;
branches;
next	1.443;

1.443
date	2004.05.05.22.36.30;	author netwolf1;	state Exp;
branches;
next	1.442;

1.442
date	2004.05.05.21.12.24;	author aw3;	state Exp;
branches;
next	1.441;

1.441
date	2004.05.04.21.24.29;	author katsyonak;	state Exp;
branches;
next	1.440;

1.440
date	2004.05.04.14.45.23;	author dropf;	state Exp;
branches;
next	1.439;

1.439
date	2004.05.04.09.45.35;	author netwolf1;	state Exp;
branches;
next	1.438;

1.438
date	2004.05.04.05.51.00;	author aw3;	state Exp;
branches;
next	1.437;

1.437
date	2004.05.03.09.59.44;	author netwolf1;	state Exp;
branches;
next	1.436;

1.436
date	2004.05.01.05.49.21;	author aw3;	state Exp;
branches;
next	1.435;

1.435
date	2004.04.29.18.03.35;	author aw3;	state Exp;
branches;
next	1.434;

1.434
date	2004.04.24.22.59.38;	author aw3;	state Exp;
branches;
next	1.433;

1.433
date	2004.04.22.02.54.02;	author kush_eplus;	state Exp;
branches;
next	1.432;

1.432
date	2004.04.21.05.19.38;	author aw3;	state Exp;
branches;
next	1.431;

1.431
date	2004.04.18.23.17.36;	author aw3;	state Exp;
branches;
next	1.430;

1.430
date	2004.04.16.15.19.38;	author dongato;	state Exp;
branches;
next	1.429;

1.429
date	2004.04.15.17.07.57;	author aw3;	state Exp;
branches;
next	1.428;

1.428
date	2004.04.12.19.55.48;	author dongato;	state Exp;
branches;
next	1.427;

1.427
date	2004.04.12.18.59.01;	author dongato;	state Exp;
branches;
next	1.426;

1.426
date	2004.04.11.14.42.56;	author eklmn;	state Exp;
branches;
next	1.425;

1.425
date	2004.04.09.20.57.16;	author dongato;	state Exp;
branches;
next	1.424;

1.424
date	2004.04.09.13.15.56;	author dongato;	state Exp;
branches;
next	1.423;

1.423
date	2004.04.08.12.27.52;	author dongato;	state Exp;
branches;
next	1.422;

1.422
date	2004.04.06.04.14.33;	author aw3;	state Exp;
branches;
next	1.421;

1.421
date	2004.04.01.12.05.16;	author eklmn;	state Exp;
branches;
next	1.420;

1.420
date	2004.03.31.08.05.09;	author eklmn;	state Exp;
branches;
next	1.419;

1.419
date	2004.03.27.21.59.45;	author dongato;	state Exp;
branches;
next	1.418;

1.418
date	2004.03.27.21.20.31;	author dongato;	state Exp;
branches;
next	1.417;

1.417
date	2004.03.25.09.13.54;	author eklmn;	state Exp;
branches;
next	1.416;

1.416
date	2004.03.25.06.22.16;	author aw3;	state Exp;
branches;
next	1.415;

1.415
date	2004.03.24.21.44.42;	author dongato;	state Exp;
branches;
next	1.414;

1.414
date	2004.03.24.19.18.02;	author syrus77;	state Exp;
branches;
next	1.413;

1.413
date	2004.03.24.16.34.23;	author eklmn;	state Exp;
branches;
next	1.412;

1.412
date	2004.03.22.18.45.17;	author eklmn;	state Exp;
branches;
next	1.411;

1.411
date	2004.03.22.02.37.03;	author aw3;	state Exp;
branches;
next	1.410;

1.410
date	2004.03.21.20.07.11;	author kush_eplus;	state Exp;
branches;
next	1.409;

1.409
date	2004.03.20.01.44.02;	author aw3;	state Exp;
branches;
next	1.408;

1.408
date	2004.03.19.21.58.16;	author eklmn;	state Exp;
branches;
next	1.407;

1.407
date	2004.03.16.18.45.09;	author kush_eplus;	state Exp;
branches;
next	1.406;

1.406
date	2004.03.15.22.38.46;	author aw3;	state Exp;
branches;
next	1.405;

1.405
date	2004.03.15.06.00.20;	author kush_eplus;	state Exp;
branches;
next	1.404;

1.404
date	2004.03.15.04.16.56;	author kush_eplus;	state Exp;
branches;
next	1.403;

1.403
date	2004.03.14.21.10.11;	author aw3;	state Exp;
branches;
next	1.402;

1.402
date	2004.03.12.06.26.12;	author aw3;	state Exp;
branches;
next	1.401;

1.401
date	2004.03.07.12.01.22;	author eklmn;	state Exp;
branches;
next	1.400;

1.400
date	2004.03.06.09.44.23;	author bavariansnail;	state Exp;
branches;
next	1.399;

1.399
date	2004.03.05.21.20.00;	author bavariansnail;	state Exp;
branches;
next	1.398;

1.398
date	2004.03.02.06.26.59;	author eklmn;	state Exp;
branches;
next	1.397;

1.397
date	2004.02.29.20.42.49;	author eklmn;	state Exp;
branches;
next	1.396;

1.396
date	2004.02.24.12.47.52;	author kush_eplus;	state Exp;
branches;
next	1.395;

1.395
date	2004.02.21.04.07.47;	author aw3;	state Exp;
branches;
next	1.394;

1.394
date	2004.02.20.14.17.33;	author dongato;	state Exp;
branches;
next	1.393;

1.393
date	2004.02.18.13.48.45;	author kush_eplus;	state Exp;
branches;
next	1.392;

1.392
date	2004.02.17.22.02.51;	author aw3;	state Exp;
branches;
next	1.391;

1.391
date	2004.02.17.01.58.30;	author kush_eplus;	state Exp;
branches;
next	1.390;

1.390
date	2004.02.16.23.28.04;	author aw3;	state Exp;
branches;
next	1.389;

1.389
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.388;

1.388
date	2004.02.15.03.41.59;	author kush_eplus;	state Exp;
branches;
next	1.387;

1.387
date	2004.02.13.16.13.35;	author netwolf1;	state Exp;
branches;
next	1.386;

1.386
date	2004.02.13.01.47.11;	author aw3;	state Exp;
branches;
next	1.385;

1.385
date	2004.02.12.10.38.01;	author morevit;	state Exp;
branches;
next	1.384;

1.384
date	2004.02.11.21.33.37;	author eklmn;	state Exp;
branches;
next	1.383;

1.383
date	2004.02.09.23.10.53;	author netwolf1;	state Exp;
branches;
next	1.382;

1.382
date	2004.02.08.22.45.43;	author kush_eplus;	state Exp;
branches;
next	1.381;

1.381
date	2004.02.08.10.28.11;	author eklmn;	state Exp;
branches;
next	1.380;

1.380
date	2004.02.07.11.53.18;	author dongato;	state Exp;
branches;
next	1.379;

1.379
date	2004.02.07.00.50.45;	author netwolf1;	state Exp;
branches;
next	1.378;

1.378
date	2004.02.06.19.55.05;	author morevit;	state Exp;
branches;
next	1.377;

1.377
date	2004.02.06.02.54.09;	author kush_eplus;	state Exp;
branches;
next	1.376;

1.376
date	2004.02.05.11.56.06;	author morevit;	state Exp;
branches;
next	1.375;

1.375
date	2004.02.05.00.00.00;	author kush_eplus;	state Exp;
branches;
next	1.374;

1.374
date	2004.02.04.19.05.58;	author morevit;	state Exp;
branches;
next	1.373;

1.373
date	2004.02.04.14.45.18;	author bavariansnail;	state Exp;
branches;
next	1.372;

1.372
date	2004.02.04.12.06.20;	author netwolf1;	state Exp;
branches;
next	1.371;

1.371
date	2004.02.03.14.28.06;	author kush_eplus;	state Exp;
branches;
next	1.370;

1.370
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.369;

1.369
date	2004.02.03.01.20.31;	author double_t;	state Exp;
branches;
next	1.368;

1.368
date	2004.02.02.08.43.01;	author kush_eplus;	state Exp;
branches;
next	1.367;

1.367
date	2004.02.01.13.53.54;	author netwolf1;	state Exp;
branches;
next	1.366;

1.366
date	2004.02.01.07.03.17;	author eklmn;	state Exp;
branches;
next	1.365;

1.365
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.364;

1.364
date	2004.01.30.20.33.57;	author eklmn;	state Exp;
branches;
next	1.363;

1.363
date	2004.01.28.20.41.51;	author dongato;	state Exp;
branches;
next	1.362;

1.362
date	2004.01.27.14.03.00;	author dongato;	state Exp;
branches;
next	1.361;

1.361
date	2004.01.26.21.24.56;	author kush_eplus;	state Exp;
branches;
next	1.360;

1.360
date	2004.01.26.18.06.33;	author dongato;	state Exp;
branches;
next	1.359;

1.359
date	2004.01.23.13.38.12;	author dongato;	state Exp;
branches;
next	1.358;

1.358
date	2004.01.22.01.23.35;	author dongato;	state Exp;
branches;
next	1.357;

1.357
date	2004.01.21.23.20.46;	author dongato;	state Exp;
branches;
next	1.356;

1.356
date	2004.01.21.19.04.51;	author eklmn;	state Exp;
branches;
next	1.355;

1.355
date	2004.01.21.17.54.29;	author dongato;	state Exp;
branches;
next	1.354;

1.354
date	2004.01.21.13.30.49;	author dongato;	state Exp;
branches;
next	1.353;

1.353
date	2004.01.18.13.43.37;	author eklmn;	state Exp;
branches;
next	1.352;

1.352
date	2004.01.16.21.31.29;	author bavariansnail;	state Exp;
branches;
next	1.351;

1.351
date	2004.01.16.19.46.50;	author eklmn;	state Exp;
branches;
next	1.350;

1.350
date	2004.01.14.23.00.37;	author netwolf1;	state Exp;
branches;
next	1.349;

1.349
date	2004.01.14.22.30.32;	author netwolf1;	state Exp;
branches;
next	1.348;

1.348
date	2004.01.14.21.51.38;	author syrus77;	state Exp;
branches;
next	1.347;

1.347
date	2004.01.14.17.47.53;	author netwolf1;	state Exp;
branches;
next	1.346;

1.346
date	2004.01.13.22.50.06;	author netwolf1;	state Exp;
branches;
next	1.345;

1.345
date	2004.01.11.05.09.57;	author dongato;	state Exp;
branches;
next	1.344;

1.344
date	2004.01.10.12.36.11;	author bavariansnail;	state Exp;
branches;
next	1.343;

1.343
date	2004.01.07.03.18.40;	author dongato;	state Exp;
branches;
next	1.342;

1.342
date	2004.01.05.21.38.36;	author dongato;	state Exp;
branches;
next	1.341;

1.341
date	2004.01.05.04.12.18;	author dongato;	state Exp;
branches;
next	1.340;

1.340
date	2004.01.05.03.33.04;	author dongato;	state Exp;
branches;
next	1.339;

1.339
date	2004.01.04.21.30.10;	author dongato;	state Exp;
branches;
next	1.338;

1.338
date	2004.01.04.15.13.17;	author dongato;	state Exp;
branches;
next	1.337;

1.337
date	2004.01.04.04.25.36;	author dongato;	state Exp;
branches;
next	1.336;

1.336
date	2003.12.29.13.05.15;	author eklmn;	state Exp;
branches;
next	1.335;

1.335
date	2003.12.25.17.18.25;	author syrus77;	state Exp;
branches;
next	1.334;

1.334
date	2003.12.25.16.29.23;	author dongato;	state Exp;
branches;
next	1.333;

1.333
date	2003.12.25.07.25.00;	author dongato;	state Exp;
branches;
next	1.332;

1.332
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.331;

1.331
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.330;

1.330
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.329;

1.329
date	2003.12.22.15.08.16;	author dongato;	state Exp;
branches;
next	1.328;

1.328
date	2003.12.21.02.08.00;	author netwolf1;	state Exp;
branches;
next	1.327;

1.327
date	2003.12.19.09.23.46;	author eklmn;	state Exp;
branches;
next	1.326;

1.326
date	2003.12.19.09.07.58;	author eklmn;	state Exp;
branches;
next	1.325;

1.325
date	2003.12.12.19.53.51;	author dongato;	state Exp;
branches;
next	1.324;

1.324
date	2003.12.11.05.04.54;	author dongato;	state Exp;
branches;
next	1.323;

1.323
date	2003.12.08.22.04.11;	author eklmn;	state Exp;
branches;
next	1.322;

1.322
date	2003.12.07.09.09.16;	author eklmn;	state Exp;
branches;
next	1.321;

1.321
date	2003.12.06.19.03.28;	author eklmn;	state Exp;
branches;
next	1.320;

1.320
date	2003.12.06.12.28.19;	author eklmn;	state Exp;
branches;
next	1.319;

1.319
date	2003.12.05.15.51.25;	author eklmn;	state Exp;
branches;
next	1.318;

1.318
date	2003.11.30.17.58.59;	author eklmn;	state Exp;
branches;
next	1.317;

1.317
date	2003.11.23.22.54.12;	author netwolf1;	state Exp;
branches;
next	1.316;

1.316
date	2003.11.19.18.02.42;	author katsyonak;	state Exp;
branches;
next	1.315;

1.315
date	2003.11.19.16.17.26;	author netwolf1;	state Exp;
branches;
next	1.314;

1.314
date	2003.11.19.11.52.50;	author eklmn;	state Exp;
branches;
next	1.313;

1.313
date	2003.11.19.11.36.36;	author kuchin;	state Exp;
branches;
next	1.312;

1.312
date	2003.11.19.09.23.29;	author kuchin;	state Exp;
branches;
next	1.311;

1.311
date	2003.11.18.19.58.02;	author katsyonak;	state Exp;
branches;
next	1.310;

1.310
date	2003.11.17.17.20.58;	author eklmn;	state Exp;
branches;
next	1.309;

1.309
date	2003.11.16.22.05.25;	author katsyonak;	state Exp;
branches;
next	1.308;

1.308
date	2003.11.16.14.55.05;	author syrus77;	state Exp;
branches;
next	1.307;

1.307
date	2003.11.13.03.00.32;	author katsyonak;	state Exp;
branches;
next	1.306;

1.306
date	2003.11.13.02.33.48;	author katsyonak;	state Exp;
branches;
next	1.305;

1.305
date	2003.11.12.13.49.53;	author katsyonak;	state Exp;
branches;
next	1.304;

1.304
date	2003.11.10.19.45.11;	author dongato;	state Exp;
branches;
next	1.303;

1.303
date	2003.11.09.16.39.13;	author eklmn;	state Exp;
branches;
next	1.302;

1.302
date	2003.11.09.16.28.47;	author dongato;	state Exp;
branches;
next	1.301;

1.301
date	2003.11.07.05.34.29;	author dongato;	state Exp;
branches;
next	1.300;

1.300
date	2003.11.05.15.49.26;	author katsyonak;	state Exp;
branches;
next	1.299;

1.299
date	2003.11.05.06.11.32;	author dongato;	state Exp;
branches;
next	1.298;

1.298
date	2003.11.02.13.07.47;	author dongato;	state Exp;
branches;
next	1.297;

1.297
date	2003.11.02.12.38.12;	author dongato;	state Exp;
branches;
next	1.296;

1.296
date	2003.11.02.10.00.58;	author dongato;	state Exp;
branches;
next	1.295;

1.295
date	2003.11.01.13.30.41;	author dongato;	state Exp;
branches;
next	1.294;

1.294
date	2003.10.31.19.45.02;	author morevit;	state Exp;
branches;
next	1.293;

1.293
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.292;

1.292
date	2003.10.28.21.36.51;	author morevit;	state Exp;
branches;
next	1.291;

1.291
date	2003.10.28.12.07.55;	author katsyonak;	state Exp;
branches;
next	1.290;

1.290
date	2003.10.27.20.53.22;	author dongato;	state Exp;
branches;
next	1.289;

1.289
date	2003.10.27.20.17.08;	author dongato;	state Exp;
branches;
next	1.288;

1.288
date	2003.10.27.17.25.09;	author eklmn;	state Exp;
branches;
next	1.287;

1.287
date	2003.10.26.15.00.57;	author eklmn;	state Exp;
branches;
next	1.286;

1.286
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.285;

1.285
date	2003.10.26.12.02.51;	author eklmn;	state Exp;
branches;
next	1.284;

1.284
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.283;

1.283
date	2003.10.23.18.56.51;	author uid110194;	state Exp;
branches;
next	1.282;

1.282
date	2003.10.21.16.45.06;	author dongato;	state Exp;
branches;
next	1.281;

1.281
date	2003.10.21.14.33.58;	author dongato;	state Exp;
branches;
next	1.280;

1.280
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.279;

1.279
date	2003.10.20.15.49.35;	author eklmn;	state Exp;
branches;
next	1.278;

1.278
date	2003.10.20.13.19.59;	author morevit;	state Exp;
branches;
next	1.277;

1.277
date	2003.10.17.10.29.06;	author morevit;	state Exp;
branches;
next	1.276;

1.276
date	2003.10.15.14.15.35;	author morevit;	state Exp;
branches;
next	1.275;

1.275
date	2003.10.15.10.25.12;	author morevit;	state Exp;
branches;
next	1.274;

1.274
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.273;

1.273
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.272;

1.272
date	2003.10.08.15.39.48;	author morevit;	state Exp;
branches;
next	1.271;

1.271
date	2003.10.08.12.56.33;	author morevit;	state Exp;
branches;
next	1.270;

1.270
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.269;

1.269
date	2003.10.06.23.43.00;	author dongato;	state Exp;
branches;
next	1.268;

1.268
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.267;

1.267
date	2003.10.05.14.31.04;	author bavariansnail;	state Exp;
branches;
next	1.266;

1.266
date	2003.10.05.05.20.01;	author dongato;	state Exp;
branches;
next	1.265;

1.265
date	2003.10.04.22.22.37;	author morevit;	state Exp;
branches;
next	1.264;

1.264
date	2003.10.04.21.26.44;	author dongato;	state Exp;
branches;
next	1.263;

1.263
date	2003.10.04.16.54.07;	author dongato;	state Exp;
branches;
next	1.262;

1.262
date	2003.10.04.12.52.23;	author dongato;	state Exp;
branches;
next	1.261;

1.261
date	2003.10.03.23.18.49;	author morevit;	state Exp;
branches;
next	1.260;

1.260
date	2003.10.03.21.38.46;	author dongato;	state Exp;
branches;
next	1.259;

1.259
date	2003.10.03.18.26.10;	author dongato;	state Exp;
branches;
next	1.258;

1.258
date	2003.10.03.10.40.53;	author dongato;	state Exp;
branches;
next	1.257;

1.257
date	2003.10.02.14.26.00;	author dongato;	state Exp;
branches;
next	1.256;

1.256
date	2003.10.02.11.11.32;	author dongato;	state Exp;
branches;
next	1.255;

1.255
date	2003.10.02.00.58.14;	author morevit;	state Exp;
branches;
next	1.254;

1.254
date	2003.10.01.16.40.45;	author morevit;	state Exp;
branches;
next	1.253;

1.253
date	2003.10.01.15.10.20;	author eklmn;	state Exp;
branches;
next	1.252;

1.252
date	2003.09.29.02.57.43;	author dongato;	state Exp;
branches;
next	1.251;

1.251
date	2003.09.25.18.19.11;	author andrerib;	state Exp;
branches;
next	1.250;

1.250
date	2003.09.25.11.23.58;	author morevit;	state Exp;
branches;
next	1.249;

1.249
date	2003.09.25.10.37.41;	author dongato;	state Exp;
branches;
next	1.248;

1.248
date	2003.09.25.10.35.35;	author dongato;	state Exp;
branches;
next	1.247;

1.247
date	2003.09.24.16.49.55;	author morevit;	state Exp;
branches;
next	1.246;

1.246
date	2003.09.24.10.44.44;	author morevit;	state Exp;
branches;
next	1.245;

1.245
date	2003.09.24.09.28.06;	author netwolf1;	state Exp;
branches;
next	1.244;

1.244
date	2003.09.23.23.36.25;	author dongato;	state Exp;
branches;
next	1.243;

1.243
date	2003.09.23.16.52.49;	author morevit;	state Exp;
branches;
next	1.242;

1.242
date	2003.09.22.16.24.05;	author morevit;	state Exp;
branches;
next	1.241;

1.241
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.240;

1.240
date	2003.09.21.22.05.16;	author morevit;	state Exp;
branches;
next	1.239;

1.239
date	2003.09.21.12.58.01;	author morevit;	state Exp;
branches;
next	1.238;

1.238
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.237;

1.237
date	2003.09.19.00.13.38;	author morevit;	state Exp;
branches;
next	1.236;

1.236
date	2003.09.15.16.34.03;	author bavariansnail;	state Exp;
branches;
next	1.235;

1.235
date	2003.09.10.02.40.11;	author dongato;	state Exp;
branches;
next	1.234;

1.234
date	2003.09.10.01.51.42;	author dongato;	state Exp;
branches;
next	1.233;

1.233
date	2003.09.10.01.35.53;	author dongato;	state Exp;
branches;
next	1.232;

1.232
date	2003.09.09.21.36.02;	author dongato;	state Exp;
branches;
next	1.231;

1.231
date	2003.09.09.16.21.59;	author dongato;	state Exp;
branches;
next	1.230;

1.230
date	2003.09.09.01.16.58;	author dongato;	state Exp;
branches;
next	1.229;

1.229
date	2003.09.08.18.12.19;	author eklmn;	state Exp;
branches;
next	1.228;

1.228
date	2003.09.08.17.36.01;	author eklmn;	state Exp;
branches;
next	1.227;

1.227
date	2003.09.07.20.00.21;	author dongato;	state Exp;
branches;
next	1.226;

1.226
date	2003.09.07.19.21.08;	author dongato;	state Exp;
branches;
next	1.225;

1.225
date	2003.09.07.05.20.38;	author dongato;	state Exp;
branches;
next	1.224;

1.224
date	2003.09.04.23.05.27;	author dongato;	state Exp;
branches;
next	1.223;

1.223
date	2003.09.03.19.44.21;	author dongato;	state Exp;
branches;
next	1.222;

1.222
date	2003.08.31.20.48.06;	author dongato;	state Exp;
branches;
next	1.221;

1.221
date	2003.08.30.11.23.25;	author emoulari;	state Exp;
branches;
next	1.220;

1.220
date	2003.08.24.22.58.34;	author zegzav;	state Exp;
branches;
next	1.219;

1.219
date	2003.08.24.20.28.03;	author zegzav;	state Exp;
branches;
next	1.218;

1.218
date	2003.08.24.15.55.18;	author bond006;	state Exp;
branches;
next	1.217;

1.217
date	2003.08.24.06.17.27;	author kuchin;	state Exp;
branches;
next	1.216;

1.216
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.215;

1.215
date	2003.08.21.00.56.03;	author dongato;	state Exp;
branches;
next	1.214;

1.214
date	2003.08.20.20.57.28;	author dongato;	state Exp;
branches;
next	1.213;

1.213
date	2003.08.17.13.15.04;	author puritynn666;	state Exp;
branches;
next	1.212;

1.212
date	2003.08.10.16.42.02;	author kuchin;	state Exp;
branches;
next	1.211;

1.211
date	2003.08.10.14.12.52;	author zegzav;	state Exp;
branches;
next	1.210;

1.210
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.209;

1.209
date	2003.08.10.01.25.41;	author dongato;	state Exp;
branches;
next	1.208;

1.208
date	2003.08.03.20.42.05;	author forcha;	state Exp;
branches;
next	1.207;

1.207
date	2003.07.31.15.02.19;	author puritynn666;	state Exp;
branches;
next	1.206;

1.206
date	2003.07.30.18.21.33;	author dongato;	state Exp;
branches;
next	1.205;

1.205
date	2003.07.30.12.29.31;	author kuchin;	state Exp;
branches;
next	1.204;

1.204
date	2003.07.30.00.35.15;	author netwolf1;	state Exp;
branches;
next	1.203;

1.203
date	2003.07.29.13.16.52;	author bond006;	state Exp;
branches;
next	1.202;

1.202
date	2003.07.27.19.29.37;	author forcha;	state Exp;
branches;
next	1.201;

1.201
date	2003.07.24.17.18.35;	author eklmn;	state Exp;
branches;
next	1.200;

1.200
date	2003.07.23.22.05.22;	author netwolf1;	state Exp;
branches;
next	1.199;

1.199
date	2003.07.22.16.42.48;	author eklmn;	state Exp;
branches;
next	1.198;

1.198
date	2003.07.22.10.59.05;	author netwolf1;	state Exp;
branches;
next	1.197;

1.197
date	2003.07.21.23.50.56;	author netwolf1;	state Exp;
branches;
next	1.196;

1.196
date	2003.07.21.15.59.01;	author eklmn;	state Exp;
branches;
next	1.195;

1.195
date	2003.07.20.15.58.43;	author eklmn;	state Exp;
branches;
next	1.194;

1.194
date	2003.07.20.07.27.30;	author eklmn;	state Exp;
branches;
next	1.193;

1.193
date	2003.07.18.14.52.38;	author eklmn;	state Exp;
branches;
next	1.192;

1.192
date	2003.07.12.06.17.50;	author eklmn;	state Exp;
branches;
next	1.191;

1.191
date	2003.07.10.23.32.44;	author syrus77;	state Exp;
branches;
next	1.190;

1.190
date	2003.07.09.16.17.26;	author dongato;	state Exp;
branches;
next	1.189;

1.189
date	2003.07.07.16.07.46;	author eklmn;	state Exp;
branches;
next	1.188;

1.188
date	2003.07.07.16.03.13;	author eklmn;	state Exp;
branches;
next	1.187;

1.187
date	2003.07.07.06.51.01;	author dongato;	state Exp;
branches;
next	1.186;

1.186
date	2003.07.06.03.10.26;	author dongato;	state Exp;
branches;
next	1.185;

1.185
date	2003.07.05.16.23.15;	author eklmn;	state Exp;
branches;
next	1.184;

1.184
date	2003.07.05.15.20.08;	author eklmn;	state Exp;
branches;
next	1.183;

1.183
date	2003.07.05.11.53.08;	author dongato;	state Exp;
branches;
next	1.182;

1.182
date	2003.07.04.05.37.13;	author eklmn;	state Exp;
branches;
next	1.181;

1.181
date	2003.07.02.22.40.33;	author syrus77;	state Exp;
branches;
next	1.180;

1.180
date	2003.07.02.16.07.37;	author eklmn;	state Exp;
branches;
next	1.179;

1.179
date	2003.06.30.17.44.36;	author eklmn;	state Exp;
branches;
next	1.178;

1.178
date	2003.06.30.16.44.51;	author eklmn;	state Exp;
branches;
next	1.177;

1.177
date	2003.06.29.20.17.12;	author syrus77;	state Exp;
branches;
next	1.176;

1.176
date	2003.06.28.18.17.24;	author eklmn;	state Exp;
branches;
next	1.175;

1.175
date	2003.06.28.10.28.30;	author partyckip;	state Exp;
branches;
next	1.174;

1.174
date	2003.06.28.09.10.59;	author eklmn;	state Exp;
branches;
next	1.173;

1.173
date	2003.06.28.09.05.33;	author partyckip;	state Exp;
branches;
next	1.172;

1.172
date	2003.06.28.07.48.31;	author eklmn;	state Exp;
branches;
next	1.171;

1.171
date	2003.06.27.12.35.36;	author syrus77;	state Exp;
branches;
next	1.170;

1.170
date	2003.06.27.01.23.59;	author syrus77;	state Exp;
branches;
next	1.169;

1.169
date	2003.06.25.18.27.29;	author eklmn;	state Exp;
branches;
next	1.168;

1.168
date	2003.06.24.22.27.40;	author eklmn;	state Exp;
branches;
next	1.167;

1.167
date	2003.06.24.21.10.52;	author eklmn;	state Exp;
branches;
next	1.166;

1.166
date	2003.06.24.18.14.47;	author eklmn;	state Exp;
branches;
next	1.165;

1.165
date	2003.06.22.13.13.29;	author partyckip;	state Exp;
branches;
next	1.164;

1.164
date	2003.06.22.12.52.07;	author partyckip;	state Exp;
branches;
next	1.163;

1.163
date	2003.06.22.10.38.05;	author partyckip;	state Exp;
branches;
next	1.162;

1.162
date	2003.06.22.09.35.43;	author eklmn;	state Exp;
branches;
next	1.161;

1.161
date	2003.06.21.18.50.04;	author partyckip;	state Exp;
branches;
next	1.160;

1.160
date	2003.06.21.17.52.33;	author partyckip;	state Exp;
branches;
next	1.159;

1.159
date	2003.06.20.19.18.47;	author eklmn;	state Exp;
branches;
next	1.158;

1.158
date	2003.06.20.17.44.29;	author partyckip;	state Exp;
branches;
next	1.157;

1.157
date	2003.06.20.05.47.30;	author partyckip;	state Exp;
branches;
next	1.156;

1.156
date	2003.06.19.16.48.04;	author partyckip;	state Exp;
branches;
next	1.155;

1.155
date	2003.06.19.10.21.55;	author partyckip;	state Exp;
branches;
next	1.154;

1.154
date	2003.06.18.15.50.28;	author eklmn;	state Exp;
branches;
next	1.153;

1.153
date	2003.06.18.08.57.06;	author dongato;	state Exp;
branches;
next	1.152;

1.152
date	2003.06.18.01.14.49;	author dongato;	state Exp;
branches;
next	1.151;

1.151
date	2003.06.17.23.08.06;	author syrus77;	state Exp;
branches;
next	1.150;

1.150
date	2003.06.17.16.35.03;	author netwolf1;	state Exp;
branches;
next	1.149;

1.149
date	2003.06.17.13.54.02;	author netwolf1;	state Exp;
branches;
next	1.148;

1.148
date	2003.06.17.10.46.33;	author dongato;	state Exp;
branches;
next	1.147;

1.147
date	2003.06.16.19.29.38;	author eklmn;	state Exp;
branches;
next	1.146;

1.146
date	2003.06.16.15.37.42;	author netwolf1;	state Exp;
branches;
next	1.145;

1.145
date	2003.06.15.19.32.06;	author eklmn;	state Exp;
branches;
next	1.144;

1.144
date	2003.06.15.19.11.18;	author dongato;	state Exp;
branches;
next	1.143;

1.143
date	2003.06.15.09.11.57;	author partyckip;	state Exp;
branches;
next	1.142;

1.142
date	2003.06.15.09.09.28;	author partyckip;	state Exp;
branches;
next	1.141;

1.141
date	2003.06.15.07.41.36;	author eklmn;	state Exp;
branches;
next	1.140;

1.140
date	2003.06.13.17.17.09;	author eklmn;	state Exp;
branches;
next	1.139;

1.139
date	2003.06.12.14.59.42;	author eklmn;	state Exp;
branches;
next	1.138;

1.138
date	2003.06.11.18.30.56;	author eklmn;	state Exp;
branches;
next	1.137;

1.137
date	2003.06.10.09.36.45;	author kuchin;	state Exp;
branches;
next	1.136;

1.136
date	2003.06.09.23.43.56;	author syrus77;	state Exp;
branches;
next	1.135;

1.135
date	2003.06.09.15.14.37;	author kuchin;	state Exp;
branches;
next	1.134;

1.134
date	2003.06.09.11.49.12;	author eklmn;	state Exp;
branches;
next	1.133;

1.133
date	2003.06.08.18.06.18;	author partyckip;	state Exp;
branches;
next	1.132;

1.132
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.131;

1.131
date	2003.06.07.14.46.41;	author eklmn;	state Exp;
branches;
next	1.130;

1.130
date	2003.06.07.12.07.49;	author eklmn;	state Exp;
branches;
next	1.129;

1.129
date	2003.06.07.12.03.12;	author eklmn;	state Exp;
branches;
next	1.128;

1.128
date	2003.06.06.20.37.17;	author partyckip;	state Exp;
branches;
next	1.127;

1.127
date	2003.06.06.19.56.46;	author partyckip;	state Exp;
branches;
next	1.126;

1.126
date	2003.06.06.00.47.52;	author syrus77;	state Exp;
branches;
next	1.125;

1.125
date	2003.06.05.19.57.16;	author partyckip;	state Exp;
branches;
next	1.124;

1.124
date	2003.06.05.17.23.25;	author partyckip;	state Exp;
branches;
next	1.123;

1.123
date	2003.06.05.06.02.28;	author partyckip;	state Exp;
branches;
next	1.122;

1.122
date	2003.06.05.01.22.31;	author netwolf1;	state Exp;
branches;
next	1.121;

1.121
date	2003.06.04.20.27.28;	author partyckip;	state Exp;
branches;
next	1.120;

1.120
date	2003.06.04.16.10.45;	author eklmn;	state Exp;
branches;
next	1.119;

1.119
date	2003.06.03.18.59.09;	author dongato;	state Exp;
branches;
next	1.118;

1.118
date	2003.06.02.19.59.39;	author eklmn;	state Exp;
branches;
next	1.117;

1.117
date	2003.06.01.08.59.02;	author kuchin;	state Exp;
branches;
next	1.116;

1.116
date	2003.05.31.06.15.55;	author partyckip;	state Exp;
branches;
next	1.115;

1.115
date	2003.05.30.17.14.10;	author syrus77;	state Exp;
branches;
next	1.114;

1.114
date	2003.05.30.05.03.45;	author partyckip;	state Exp;
branches;
next	1.113;

1.113
date	2003.05.29.04.45.19;	author partyckip;	state Exp;
branches;
next	1.112;

1.112
date	2003.05.28.22.13.53;	author partyckip;	state Exp;
branches;
next	1.111;

1.111
date	2003.05.27.23.03.07;	author partyckip;	state Exp;
branches;
next	1.110;

1.110
date	2003.05.27.04.15.26;	author partyckip;	state Exp;
branches;
next	1.109;

1.109
date	2003.05.26.21.46.10;	author partyckip;	state Exp;
branches;
next	1.108;

1.108
date	2003.05.21.14.55.19;	author netwolf1;	state Exp;
branches;
next	1.107;

1.107
date	2003.05.20.20.46.30;	author netwolf1;	state Exp;
branches;
next	1.106;

1.106
date	2003.05.20.16.30.41;	author netwolf1;	state Exp;
branches;
next	1.105;

1.105
date	2003.05.18.11.40.31;	author obaldin;	state Exp;
branches;
next	1.104;

1.104
date	2003.05.18.09.34.14;	author obaldin;	state Exp;
branches;
next	1.103;

1.103
date	2003.05.17.09.49.59;	author partyckip;	state Exp;
branches;
next	1.102;

1.102
date	2003.05.16.18.10.53;	author netwolf1;	state Exp;
branches;
next	1.101;

1.101
date	2003.05.15.22.03.54;	author syrus77;	state Exp;
branches;
next	1.100;

1.100
date	2003.05.14.11.19.02;	author kuchin;	state Exp;
branches;
next	1.99;

1.99
date	2003.05.14.00.13.25;	author netwolf1;	state Exp;
branches;
next	1.98;

1.98
date	2003.05.12.15.29.18;	author kuchin;	state Exp;
branches;
next	1.97;

1.97
date	2003.05.12.13.22.09;	author kuchin;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.09.11.57.06;	author kuchin;	state Exp;
branches;
next	1.95;

1.95
date	2003.05.08.17.08.25;	author netwolf1;	state Exp;
branches;
next	1.94;

1.94
date	2003.05.04.14.13.24;	author kuchin;	state Exp;
branches;
next	1.93;

1.93
date	2003.05.04.10.05.33;	author kuchin;	state Exp;
branches;
next	1.92;

1.92
date	2003.04.30.11.37.57;	author kuchin;	state Exp;
branches;
next	1.91;

1.91
date	2003.04.29.08.37.44;	author kuchin;	state Exp;
branches;
next	1.90;

1.90
date	2003.04.26.19.46.44;	author lord_kiron;	state Exp;
branches;
next	1.89;

1.89
date	2003.04.26.17.36.13;	author ultras;	state Exp;
branches;
next	1.88;

1.88
date	2003.04.25.21.51.03;	author lord_kiron;	state Exp;
branches;
next	1.87;

1.87
date	2003.04.03.18.37.53;	author lord_kiron;	state Exp;
branches;
next	1.86;

1.86
date	2003.04.03.10.12.17;	author kuchin;	state Exp;
branches;
next	1.85;

1.85
date	2003.03.30.13.12.28;	author moosetea;	state Exp;
branches;
next	1.84;

1.84
date	2003.03.30.12.10.20;	author moosetea;	state Exp;
branches;
next	1.83;

1.83
date	2003.03.29.13.42.29;	author dongato;	state Exp;
branches;
next	1.82;

1.82
date	2003.03.28.10.19.08;	author dongato;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.27.09.40.14;	author recdvst;	state Exp;
branches;
next	1.80;

1.80
date	2003.03.25.18.16.45;	author kuchin;	state Exp;
branches;
next	1.79;

1.79
date	2003.03.24.20.38.50;	author kuchin;	state Exp;
branches;
next	1.78;

1.78
date	2003.03.22.14.27.16;	author cax2;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2003.03.22.08.02.19;	author recdvst;	state Exp;
branches;
next	1.76;

1.76
date	2003.03.22.01.13.59;	author cax2;	state Exp;
branches;
next	1.75;

1.75
date	2003.03.21.17.24.43;	author cax2;	state Exp;
branches;
next	1.74;

1.74
date	2003.03.21.11.40.44;	author cax2;	state Exp;
branches;
next	1.73;

1.73
date	2003.03.21.00.30.29;	author cax2;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.20.17.12.31;	author lord_kiron;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.20.13.42.54;	author obaldin;	state Exp;
branches;
next	1.70;

1.70
date	2003.03.19.18.58.08;	author cax2;	state Exp;
branches;
next	1.69;

1.69
date	2003.03.19.18.55.18;	author cax2;	state Exp;
branches;
next	1.68;

1.68
date	2003.03.19.18.34.49;	author cax2;	state Exp;
branches;
next	1.67;

1.67
date	2003.03.19.18.09.27;	author cax2;	state Exp;
branches;
next	1.66;

1.66
date	2003.03.19.00.35.55;	author recdvst;	state Exp;
branches;
next	1.65;

1.65
date	2003.03.17.07.31.47;	author recdvst;	state Exp;
branches;
next	1.64;

1.64
date	2003.03.16.06.09.31;	author cax2;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.16.04.37.59;	author recdvst;	state Exp;
branches;
next	1.62;

1.62
date	2003.03.16.01.53.14;	author recdvst;	state Exp;
branches;
next	1.61;

1.61
date	2003.03.14.14.31.43;	author lord_kiron;	state Exp;
branches;
next	1.60;

1.60
date	2003.03.14.11.56.30;	author partyckip;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.12.17.32.45;	author cax2;	state Exp;
branches;
next	1.58;

1.58
date	2003.03.12.16.53.02;	author cax2;	state Exp;
branches;
next	1.57;

1.57
date	2003.03.11.21.19.42;	author dongato;	state Exp;
branches;
next	1.56;

1.56
date	2003.03.10.18.00.15;	author cax2;	state Exp;
branches;
next	1.55;

1.55
date	2003.03.08.12.09.42;	author recdvst;	state Exp;
branches;
next	1.54;

1.54
date	2003.03.07.12.50.20;	author kuchin;	state Exp;
branches;
next	1.53;

1.53
date	2003.03.06.17.46.03;	author obaldin;	state Exp;
branches;
next	1.52;

1.52
date	2003.03.06.00.37.24;	author recdvst;	state Exp;
branches;
next	1.51;

1.51
date	2003.03.05.23.17.39;	author cax2;	state Exp;
branches;
next	1.50;

1.50
date	2003.03.05.21.16.37;	author obaldin;	state Exp;
branches;
next	1.49;

1.49
date	2003.03.05.11.23.43;	author recdvst;	state Exp;
branches;
next	1.48;

1.48
date	2003.03.03.22.09.48;	author moosetea;	state Exp;
branches;
next	1.47;

1.47
date	2003.03.03.19.03.26;	author lord_kiron;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.03.18.14.10;	author cax2;	state Exp;
branches;
next	1.45;

1.45
date	2003.03.03.18.11.34;	author lord_kiron;	state Exp;
branches;
next	1.44;

1.44
date	2003.03.02.18.29.41;	author lord_kiron;	state Exp;
branches;
next	1.43;

1.43
date	2003.03.01.12.48.30;	author dongato;	state Exp;
branches;
next	1.42;

1.42
date	2003.03.01.02.01.26;	author cax2;	state Exp;
branches;
next	1.41;

1.41
date	2003.02.28.14.20.10;	author cax2;	state Exp;
branches;
next	1.40;

1.40
date	2003.02.27.19.15.51;	author cax2;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.27.10.02.10;	author cax2;	state Exp;
branches;
next	1.38;

1.38
date	2003.02.26.21.33.10;	author obaldin;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.26.21.12.32;	author cax2;	state Exp;
branches;
next	1.36;

1.36
date	2003.02.26.15.55.36;	author dongato;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.26.15.07.44;	author dongato;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.25.18.08.00;	author cax2;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.25.11.49.16;	author kuchin;	state Exp;
branches;
next	1.32;

1.32
date	2003.02.24.21.01.24;	author dongato;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2003.02.24.20.09.48;	author dongato;	state Exp;
branches;
next	1.30;

1.30
date	2003.02.23.19.16.13;	author cax2;	state Exp;
branches;
next	1.29;

1.29
date	2003.02.23.13.30.21;	author obaldin;	state Exp;
branches;
next	1.28;

1.28
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.20.14.29.03;	author dongato;	state Exp;
branches;
next	1.26;

1.26
date	2003.02.20.07.25.21;	author cax2;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.18.22.47.35;	author dongato;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.18.19.10.38;	author cax2;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.18.15.21.23;	author dongato;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.17.22.09.46;	author obaldin;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.17.19.17.11;	author dongato;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.17.15.02.39;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.16.22.01.48;	author lord_kiron;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.16.17.30.57;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.14.14.22.40;	author obaldin;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.12.22.30.38;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.12.20.18.23;	author obaldin;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.10.18.43.25;	author obaldin;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.09.22.04.26;	author obaldin;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.09.18.39.41;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.02.16.46.57;	author cax2;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2003.02.02.14.58.53;	author obaldin;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.02.03.39.55;	author cax2;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.01.14.45.39;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.29.14.37.05;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.28.11.04.36;	author dongato;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2003.01.27.22.22.29;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.17.00.44;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.15.05.38;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.21;	author cax2;	state Exp;
branches;
next	;

1.5.2.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2003.01.29.00.25.45;	author cax2;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.02.02.02.36.27;	author cax2;	state Exp;
branches;
next	;

1.10.2.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2003.02.06.08.51.10;	author obaldin;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2003.02.06.19.01.02;	author obaldin;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2003.02.06.22.12.01;	author obaldin;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2003.02.08.13.37.05;	author obaldin;	state Exp;
branches;
next	;

1.32.2.1
date	2003.03.01.11.25.55;	author obaldin;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2003.03.01.20.59.36;	author obaldin;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2003.03.02.08.46.05;	author obaldin;	state Exp;
branches;
next	;

1.78.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.78.2.2;

1.78.2.2
date	2003.03.24.09.39.43;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.764
log
@Simplified stream manipulation while saving server.met and .part.met files.
@
text
@//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "PartFile.h"
#include "SafeFile.h"
#ifndef NEW_SOCKETS_ENGINE
#include "BarShader.h"
	#include "emule.h"
	#include "updownclient.h"
#else
	#include "Engine/Data/Prefs.h"
#endif //NEW_SOCKETS_ENGINE
#include "server.h"
#include "ED2KLink.h"
#include "Preview.h"
#include "ini2.h"
#include "SharedFileList.h"
#include "ArchiveRecovery.h"
#include <sys/stat.h>
#include <share.h>
#include <io.h>
#include "MMServer.h"
#include "otherstructs.h"
#include "ListenSocket.h"
#include "packets.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

#define PROGRESS_HEIGHT 4

CPartFile::CPartFile()
{
	Init();
}

CPartFile::CPartFile(CSearchFile* searchresult, EnumCategories eCatID)
{
	EMULE_TRY
#ifndef NEW_SOCKETS_ENGINE
	Init();

	md4cpy(m_fileHash, searchresult->GetFileHash());
	for (int i = 0; i < searchresult->m_tagArray.GetCount(); i++)
	{
		const CTag *pTag = searchresult->m_tagArray[i];

		switch (pTag->GetTagID())
		{
			case FT_FILENAME:
				if (pTag->IsStr())
				{
#ifdef _UNICODE
					if (IsFileNameEmpty())
#endif
						SetFileName(pTag->GetStringValue());
				}
				break;

			case FT_FILESIZE:
				SetFileSize(searchresult->GetFileSize());
				break;

			default:
			{
			//	Keep only known and valid tags to avoid possible side effects
				if ( (pTag->GetTagID() != 0) && (pTag->GetTagName() == NULL) &&
					(pTag->IsStr() || pTag->IsInt()) )
				{
					static const struct
					{
						byte	byteID;
						byte	byteType;
					} s_aTags[] =
					{
						{ FT_MEDIA_ARTIST,	TAGTYPE_STRING },
						{ FT_MEDIA_ALBUM,	TAGTYPE_STRING },
						{ FT_MEDIA_TITLE,	TAGTYPE_STRING },
						{ FT_MEDIA_LENGTH,	TAGTYPE_UINT32 },
						{ FT_MEDIA_BITRATE,	TAGTYPE_UINT32 },
						{ FT_MEDIA_CODEC,	TAGTYPE_STRING },
						{ FT_FILETYPE,		TAGTYPE_STRING },
						{ FT_FILEFORMAT,	TAGTYPE_STRING }
					};

					for (unsigned ui = 0; ui < ARRSIZE(s_aTags); ui++)
					{
						if (pTag->GetTagID() == s_aTags[ui].byteID && pTag->GetType() == s_aTags[ui].byteType)
						{
						//	Skip string tags with empty string values
							if (pTag->IsStr() && pTag->IsStringValueEmpty())
								break;
						//	Skip integer tags with '0' values
							if (pTag->IsInt() && (pTag->GetIntValue() == 0))
								break;

							CTag	*pNewTag = new CTag(*pTag);
							m_tagArray.Add(pNewTag);
							break;
						}
					}
				}
			}
		}
	}
//	Don't ask for a hashset, if there is none
	if (GetFileSize() < PARTSIZE)
		m_bHashSetNeeded = false;

//	Set Category, don't save data yet
	if (eCatID == CAT_NONE)
		g_App.m_pDownloadQueue->SetAutoCat(this);
	else
		SetCatID(eCatID);

	CreatePartFile();

#endif //NEW_SOCKETS_ENGINE
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CPartFile::CPartFile(CString edonkeylink, EnumCategories eCatID)
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	CED2KLink* pLink = NULL;
	try
	{
		pLink = CED2KLink::CreateLinkFromUrl(edonkeylink);
		_ASSERT(pLink != NULL);
		CED2KFileLink* pFileLink = pLink->GetFileLink();
		if (pFileLink == NULL)
			throw CString(_T("not an ed2k server or file link"));
		InitializeFromLink(pFileLink, eCatID);
	}
	catch (CString error)
	{
		OUTPUT_DEBUG_TRACE();
		AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_INVALIDLINK, error);
		SetStatus(PS_ERROR);
	}
	delete pLink;
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CPartFile::CPartFile(CED2KFileLink* fileLink, EnumCategories eCatID)
{
	InitializeFromLink(fileLink, eCatID);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::InitializeFromLink(CED2KFileLink* fileLink, EnumCategories eCatID)
{
	EMULE_TRY

	Init();

	try
	{
		SetFileName(fileLink->GetName());
		SetFileSize(fileLink->GetSize());
	//	Prevent to donload an empty file
		if (!GetFileSize())
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_SKIPZEROLENGTHFILE, m_strFileName);
#endif
			SetStatus(PS_ERROR);
			return;
		}
	//	Don't ask for a hashset, if there is none
		if (GetFileSize() < PARTSIZE)
			m_bHashSetNeeded = false;
		md4cpy(m_fileHash, fileLink->GetHashKey());
#ifndef NEW_SOCKETS_ENGINE
		if (!g_App.m_pDownloadQueue->FileExists(m_fileHash))
		{
		//	Set Category, don't save data yet
			if (eCatID == CAT_NONE)
				g_App.m_pDownloadQueue->SetAutoCat(this);
			else
				SetCatID(eCatID);

			CreatePartFile();
		}
		else
#endif //NEW_SOCKETS_ENGINE
			SetStatus(PS_ERROR);
	}
	catch (CString error)
	{
		OUTPUT_DEBUG_TRACE();
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_INVALIDLINK, error);
#endif
		SetStatus(PS_ERROR);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::Init()
{
	EMULE_TRY

	m_strTempDir = _T("");
	m_dwLastFileSourcesRequestTime = 0;
	m_nLastBufferFlushTime = m_dwLastPurgeTime = ::GetTickCount();
	m_bPaused = false;
	m_bStopped = false;
	SetStatus(PS_EMPTY);
	m_qwBytesTransferred = 0;
	priority = PR_NORMAL;
	m_uNumTransferringSrcs = 0;
	m_uSrcNNP = 0;
	m_uSrcOnQueue = 0;
	m_uSrcHighQR = 0;
	m_uSrcConnecting = 0;
	m_uSrcWaitForFileReq = 0;
	m_uSrcConnected = 0;
	m_uSrcConnViaServer = 0;
	m_uSrcLowToLow = 0;
	m_uSrcLowIDOnOtherServer = 0;
	m_uSrcQueueFull = 0;
	m_uSrcA4AF = 0;
	m_dwDataRate = 0;
	m_bHashSetNeeded = true;
	m_uProcessCounter = 0;
	m_dblPercentCompleted = 0.0;
	m_strPartMetFileName = _T("");
	m_qwCompletedSize = 0;
	m_bPreviewing = false;
	lastseencomplete = NULL;
	m_dwAvailablePartsCount = 0;
	m_ClientSrcAnswered = 0;
	m_LastNoNeededCheck = 0;
	m_eRating = PF_RATING_NONE;
	m_nTotalBufferData = 0;
	m_bRecoveringArchive = false;
	m_qwGainDueToCompression = 0;
	m_qwLostDueToCorruption = 0;
	m_iTotalPacketsSavedDueToICH = 0;
	m_bHasRating = false;
	m_bHasComment = false;
	m_uLastCompleteSrcCount = 0;
	m_SessionStartTime = m_timeLastDownTransfer = CTime::GetCurrentTime();
	m_qwSessionStartSize = 0;
	m_AvgDataRate = 0;
	m_StartTimeReset = false;
	m_eCategoryID = CAT_NONE;
	m_bIsBeingDeleted = false;
	m_bIsPreallocated = false;
//	Async data flush (i.e. only in process)
	m_bDataFlushReq = false;
//	Set to true for fakes.rar download
	m_bIsFakesDotRar = false;
//	Set intial gaps sum to 0
	m_qwGapsSum = 0;
//	Set total size of completed parts to 0
	m_qwCompletedPartsSize = 0;

#ifndef NEW_SOCKETS_ENGINE
	if (g_App.m_pPrefs->IsDAPEnabled())
		m_bAutoPriority = true;
	else
#endif //NEW_SOCKETS_ENGINE
		m_bAutoPriority = false;

	m_bIsPreviewableArchive = false;
	m_cIsMovie = 0;
	m_bIsMpgMovie  = false;
	m_bIsMpgAudio = false;

	::InitializeCriticalSection(&m_csSourceLists);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CPartFile::~CPartFile()
{
	EMULE_TRY

	if (!m_bIsBeingDeleted && (m_hPartFileWrite.m_hFile != INVALID_HANDLE_VALUE))
	{
	//	Ensure all buffered data is written
		FlushBuffer();

		ClosePartFile();
	//	Update met file
		SavePartFile();
	}

	m_srcPartFrequencies.RemoveAll();
	m_PartsStatusVector.clear();

//	Will be unlocked on exit
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);

	while (!gaplist.IsEmpty())
		delete gaplist.RemoveHead();

	::DeleteCriticalSection(&m_csSourceLists);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::CreatePartFile()
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	m_strTempDir = g_App.m_pPrefs->GetTempDir();
#else
	m_strTempDir = g_stEngine.Prefs.GetTempDir();
#endif //NEW_SOCKETS_ENGINE

	if (GetCatID() != CAT_NONE)
	{
		CString strCatTempDir =	CCat::GetCatByID(GetCatID())->GetTempPath();
		if (!strCatTempDir.IsEmpty())
			m_strTempDir = strCatTempDir;
	}

	if (m_strTempDir.Right(1) == _T('\\'))
	{
		m_strTempDir.Truncate(m_strTempDir.GetLength() - 1);
	}

//	Check that file size is supported by the protocol and the current partition
	if (GetFileSize() > 0xFFFFFFFFui64)
	{
		UINT	dwResStrId;

		for (;;)
		{
			if (GetFileSize() > MAX_EMULE_FILE_SIZE)
				dwResStrId = IDS_ERR_TOOLARGEFILE;
			else if (IsFileOnFATVolume(m_strTempDir))
				dwResStrId = IDS_ERR_TOOLARGEFILE4FS;
			else
				break;
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_FILEOPEN, GetFileName(), GetResString(dwResStrId));
			SetStatus(PS_ERROR);
			return;
		}
	}

	SetPath(m_strTempDir);

	int iPartNumber = 0;
	CString strFullPartFileName;

	do
	{
		strFullPartFileName.Format(_T("%s\\%03u.part"), m_strTempDir, ++iPartNumber);
	}
	while (PathFileExists(strFullPartFileName));

	m_strPartMetFileName.Format(_T("%03u.part.met"), iPartNumber);
	m_strFullName.Format(_T("%s.met"), strFullPartFileName);
	SetFilePath(strFullPartFileName);

	CString	buffer = m_strPartMetFileName.Left(m_strPartMetFileName.GetLength() - 4);
	CTag	*pPartNameTag = new CTag(FT_PARTFILENAME, buffer);

	m_tagArray.Add(pPartNameTag);

	if (!m_hPartFileWrite.Open(strFullPartFileName, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
	{
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_CREATEPARTFILE);
		SetStatus(PS_ERROR);
	}
	if (!m_hPartFileRead.Open(strFullPartFileName, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
	{
		m_hPartFileWrite.Close();
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_CREATEPARTFILE);
		SetStatus(PS_ERROR);
	}

	const uint32 dwPartCnt = GetPartCount();

	m_srcPartFrequencies.SetSize(dwPartCnt);
	m_PartsStatusVector.resize(dwPartCnt);

	for (uint32 i = 0; i < dwPartCnt; i++)
	{
		m_srcPartFrequencies[i] = 0;
		m_PartsStatusVector[i] = 0;
	}

//	Note: the gap should be initialized after parts status vector was filled
	AddGap(0, GetFileSize() - 1ui64);

	m_bPaused = false;

#ifndef NEW_SOCKETS_ENGINE
//	Before we save file we need to establish UAP
	if (g_App.m_pPrefs->IsUAPEnabled())
	{
		SetAutoULPriority(true);
		SetULPriority(PR_RELEASE);
		UpdateSharedFileDisplay();
	}
#endif //NEW_SOCKETS_ENGINE

//	Don't request hashset for file which size < PARTSIZE
//	NB! file with size = PARTSIZE has hashset consisted of two hashes
	if (GetFileSize() < PARTSIZE)
		m_bHashSetNeeded = false;

#ifndef NEW_SOCKETS_ENGINE
//	Filename cleanup
	if (g_App.m_pPrefs->GetAutoFilenameCleanup())
		SetFileName(CleanupFilename(GetFileName()));
#endif //NEW_SOCKETS_ENGINE

	SavePartFile();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::LoadPartFile(LPCTSTR in_directory, LPCTSTR in_filename)
{
	EMULE_TRY

	CMap<uint16, uint16, Gap_Struct*, Gap_Struct*> gap_map;
	CSafeBufferedFile file;
	CString	strCorruptedParts;

	m_qwBytesTransferred = 0;
	m_strPartMetFileName = in_filename;
	m_strTempDir = in_directory;
	if (m_strTempDir.Right(1) == _T('\\'))
		m_strTempDir.Truncate(m_strTempDir.GetLength() - 1);
	SetPath(m_strTempDir);

	m_strFullName.Format(_T("%s\\%s"), m_strTempDir, m_strPartMetFileName);
	SetFilePath(m_strFullName.Left(m_strFullName.GetLength() - 4));

	try
	{
	//	Read file data form part.met file
		if (!file.Open(m_strFullName, CFile::modeRead | CFile::typeBinary | CFile::shareDenyWrite))
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_RGB_ERROR, IDS_ERR_OPENMET, m_strPartMetFileName, m_strFileName);
			g_App.m_pMDlg->DisableAutoBackup();
#endif
			return false;
		}
		byte version;
		file.Read(&version, 1);
		if ((version != PARTFILE_VERSION) && (version != PARTFILE_VERSION_LARGEFILE))
		{
			file.Close();
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_RGB_ERROR, IDS_ERR_BADMETVERSION, m_strPartMetFileName, m_strFileName);
			g_App.m_pMDlg->DisableAutoBackup();
#endif
			return false;
		}
		LoadDateFromFile(file);
		if (!LoadHashsetFromFile(file, false))
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_HASHSETCORR, in_filename);
#endif
		}
		LoadSettingsFile();

		uint32	dwTagCnt;

		file.Read(&dwTagCnt, 4);
		for (uint32 j = 0; j < dwTagCnt; j++)
		{
			CTag* newtag = new CTag();

			newtag->FillFromStream(file);
			switch (newtag->GetTagID())
			{
				case FT_FILENAME:
					if (!newtag->IsStr())
					{
#ifndef NEW_SOCKETS_ENGINE
						AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_METCORRUPT, m_strPartMetFileName, m_strFileName);
						delete newtag;
						g_App.m_pMDlg->DisableAutoBackup();
#endif //NEW_SOCKETS_ENGINE

						return false;
					}
#ifdef _UNICODE
					if (IsFileNameEmpty())
#endif
						SetFileName(newtag->GetStringValue());
					break;

				case FT_LASTSEENCOMPLETE:
					if (newtag->IsInt())
						lastseencomplete = newtag->GetIntValue();
					break;

				case FT_FILESIZE:
					if (newtag->IsAnyInt())
						SetFileSize(newtag->GetInt64Value());
					break;

				case FT_TRANSFERRED:
					if (newtag->IsAnyInt())
						newtag->GetInt64Value(&m_qwBytesTransferred);
					break;

				case FT_COMPRESSION:
					if (newtag->IsAnyInt())
						newtag->GetInt64Value(&m_qwGainDueToCompression);
					break;

				case FT_CORRUPTED:
					if (newtag->IsAnyInt())
						newtag->GetInt64Value(&m_qwLostDueToCorruption);
					break;

				case FT_DLPRIORITY:
					if (newtag->IsInt())
					{
						if ((priority = static_cast<byte>(newtag->GetIntValue())) == PR_AUTO)
						{
							SetAutoPriority(true);
							priority = PR_HIGH;
						}
						else
						{
							SetAutoPriority(false);
							if ((priority != PR_LOW) && (priority != PR_NORMAL) && (priority != PR_HIGH))
								priority = PR_NORMAL;
						}
					}
					break;

				case FT_STATUS:
					if (newtag->IsInt())
						m_bPaused = (newtag->GetIntValue() != 0);
					break;

				case FT_ULPRIORITY:
					if (newtag->IsInt())
					{
						byte	byteULPrio = static_cast<byte>(newtag->GetIntValue());

						if (byteULPrio == PR_AUTO)
						{
							SetAutoULPriority(true);
							SetULPriority(PR_RELEASE);
						}
						else
						{
							SetAutoULPriority(false);
							if ( (byteULPrio != PR_VERYLOW) && (byteULPrio != PR_LOW) &&
								(byteULPrio != PR_NORMAL) && (byteULPrio != PR_HIGH) && (byteULPrio != PR_RELEASE) )
							{
								byteULPrio = PR_NORMAL;
							}
							SetULPriority(byteULPrio);
						}
					}
					break;

				case FT_CATEGORY:
					if (newtag->IsInt())
					{
						m_eCategoryID = static_cast<_EnumCategories>(newtag->GetIntValue());
						if (CCat::GetCatIndexByID(m_eCategoryID) < 0)
							m_eCategoryID = CAT_NONE;
					}
					break;

				case FT_PERMISSIONS:
					if (newtag->IsInt() && (newtag->GetIntValue() <= PERM_NOONE))
						SetPermissions((byte)newtag->GetIntValue());
					break;

				case FT_ATTRANSFERRED:						// (FT_ATTRANSFERRED:int) all time transferred (low long)
					if (newtag->IsInt())
						statistic.m_qwAllTimeTransferred = (statistic.m_qwAllTimeTransferred & (0xFFFFFFFFi64 << 32)) | newtag->GetIntValue();
					break;

				case FT_ATTRANSFERREDHI:					// (FT_ATTRANSFERREDHI:int) all time transferred (high long)
					if (newtag->IsInt())
						statistic.m_qwAllTimeTransferred = (statistic.m_qwAllTimeTransferred & 0xFFFFFFFF) |
							(static_cast<uint64>(newtag->GetIntValue()) << 32);
					break;

				case FT_ATREQUESTED:						// (FT_ATREQUESTED:int) all time requested
					if (newtag->IsInt())
						statistic.m_dwAllTimeRequested = newtag->GetIntValue();
					break;

				case FT_ATACCEPTED:							// (FT_ATACCEPTED:int) all time accepted
					if (newtag->IsInt())
						statistic.m_dwAllTimeAccepted = newtag->GetIntValue();
					break;

				case FT_CORRUPTEDPARTS:
					if (newtag->IsStr())
						newtag->GetStringValue(&strCorruptedParts);
					break;

				default:
				{
					const char	*pcTagName = newtag->GetTagName();

					if ((newtag->GetTagID() == 0) && (pcTagName == NULL))
						break;
					if ((pcTagName != NULL) && (pcTagName[0] == FT_GAPSTART || pcTagName[0] == FT_GAPEND))
					{
						if (newtag->IsAnyInt())
						{
							Gap_Struct *gap;
							uint16 gapkey = static_cast<uint16>(atoi(&pcTagName[1]));

							if (!gap_map.Lookup(gapkey, gap))
							{
								gap = new Gap_Struct;
								gap_map.SetAt(gapkey, gap);
								gap->qwStartOffset = ~0ui64;
								gap->qwEndOffset = ~0ui64;
							}
							if (pcTagName[0] == FT_GAPSTART)
								newtag->GetInt64Value(&gap->qwStartOffset);
							if (pcTagName[0] == FT_GAPEND)
							{
								newtag->GetInt64Value(&gap->qwEndOffset);
								gap->qwEndOffset--;
							}
						}
					}
					else
					{
						m_tagArray.Add(newtag);
						continue;
					}
				}
			}
			delete newtag;
		}
		file.Close();
	}
	catch (CFileException * error)
	{
		OUTPUT_DEBUG_TRACE();
#ifndef NEW_SOCKETS_ENGINE
		if (error->m_cause == CFileException::endOfFile)
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_METCORRUPT, m_strPartMetFileName, m_strFileName);
		else
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_FILEERROR, m_strPartMetFileName, m_strFileName, GetErrorMessage(error));
#endif //NEW_SOCKETS_ENGINE
		error->Delete();
		for (POSITION pos = gap_map.GetStartPosition(); pos != NULL;)
		{
			Gap_Struct* gap;
			uint16 gapkey;
			gap_map.GetNextAssoc(pos, gapkey, gap);
			delete gap;
		}
#ifndef NEW_SOCKETS_ENGINE
		g_App.m_pMDlg->DisableAutoBackup();
#endif //NEW_SOCKETS_ENGINE

		return false;
	}

//	At this point, the file size was defined. initialize related variables
	const uint32 dwPartCnt = GetPartCount();

	m_srcPartFrequencies.SetSize(dwPartCnt);
	m_PartsStatusVector.resize(dwPartCnt);

	for (uint32 i = 0; i < dwPartCnt; i++)
	{
		m_srcPartFrequencies[i] = 0;
		m_PartsStatusVector[i] = PART_VERIFIED;	// AddGap will reset this where required
	}

//	Now to flush the map into the list
	for (POSITION pos = gap_map.GetStartPosition(); pos != NULL;)
	{
		Gap_Struct* gap;
		uint16 gapkey;
		gap_map.GetNextAssoc(pos, gapkey, gap);

		if ( (gap->qwStartOffset != ~0ui64) && (gap->qwEndOffset != ~0ui64) &&
			(gap->qwStartOffset <= gap->qwEndOffset) && (gap->qwStartOffset < GetFileSize()) )
		{
			if (gap->qwEndOffset >= GetFileSize())
				gap->qwEndOffset = GetFileSize() - 1ui64;	// Clipping
			AddGap(gap->qwStartOffset, gap->qwEndOffset);	// All tags accounted for, use safe adding
		}
		delete gap;
	}

//	Check that file size is supported by the protocol and the current partition
	if (GetFileSize() > 0xFFFFFFFFui64)
	{
		UINT	dwResStrId;

		for (;;)
		{
			if (GetFileSize() > MAX_EMULE_FILE_SIZE)
				dwResStrId = IDS_ERR_TOOLARGEFILE;
			else if (IsFileOnFATVolume(m_strTempDir))
				dwResStrId = IDS_ERR_TOOLARGEFILE4FS;
			else
				break;
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_FILEOPEN, m_strFilePath, GetResString(dwResStrId));
			return false;
		}
	}

	if (!strCorruptedParts.IsEmpty())
	{
		CString	strPart;
		uint32	dwPart;

		for (int iPos = 0;;)
		{
			strPart = strCorruptedParts.Tokenize(_T(","), iPos);
			if (strPart.IsEmpty())
				break;

			if (_stscanf(strPart, _T("%u"), &dwPart) == 1)
			{
				if (dwPart < dwPartCnt)
				{
					m_csGapListAndPartStatus.Lock();
					m_PartsStatusVector[dwPart] |= PART_CORRUPTED;
					m_csGapListAndPartStatus.Unlock();
				}
			}
		}
	}

//	Calculate the size of completed parts
	for (uint32 i = 0; i < GetPartCount(); i++)
	{
		uint64 qwStart, qwEnd;

		if (IsPartComplete(i, &qwStart, &qwEnd))
			m_qwCompletedPartsSize += qwEnd - qwStart + 1ui64;
	}

	EMULE_TRY

	LoadPartFileStats();

	EMULE_CATCH

//	Open permanent handles
	if (!m_hPartFileWrite.Open(m_strFilePath, CFile::modeWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_FILEOPEN, m_strFilePath, m_strFileName);
#endif
		return false;
	}
	if (!m_hPartFileRead.Open(m_strFilePath, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
	{
		m_hPartFileWrite.Close();
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_FILEOPEN, m_strFilePath, m_strFileName);
#endif
		return false;
	}

	uint64	qwFileSz = m_hPartFileWrite.GetLength();

	if (qwFileSz < GetFileSize())
		AddGap(qwFileSz, GetFileSize() - 1ui64);

//	Goes both ways - Partfile should never be too large
	if (qwFileSz > GetFileSize())
	{
		TRACE("Partfile \"%s\" is too large! Truncating %I64u bytes.\n", GetFileName(), qwFileSz - GetFileSize());
		m_hPartFileWrite.SetLength(GetFileSize());
	}

	SetStatus(PS_EMPTY);

	UpdateCompletedInfos();
//	Smoothed "remaining time" calculation
	m_qwSessionStartSize = m_qwCompletedSize;

	FILETIME	ftModify;

	if (::GetFileTime(m_hPartFileWrite, NULL, NULL, &ftModify))
		m_timeLastDownTransfer = CTime(ftModify);

//	Check hashcount, filestatus etc.
	CSingleLock Lock(&m_csHashList, TRUE);
	uint32 dwSize = m_partHashArray.GetCount();
	Lock.Unlock();
	if (dwSize != GetED2KPartHashCount())
	{
		m_bHashSetNeeded = true;
		return true;
	}
	else
	{
		m_bHashSetNeeded = false;
		for (int i = 0; i < GetPartCount(); i++)
		{
			if (IsPartComplete(i))
			{
				SetStatus(PS_READY);
				break;
			}
		}
	}
	m_csGapListAndPartStatus.Lock();

	bool	bIsGapListEmpty = B2b(gaplist.IsEmpty());

	m_csGapListAndPartStatus.Unlock();

// Is this file complete already?
	if (bIsGapListEmpty)
	{
		CompleteFile(false);
		return true;
	}

//	Check file integrity only when at least one full chunk is available
//	to make it faster and to avoid adding of a non-shareable file to the shared files list
	if (m_eStatus == PS_READY)
	{
		uint32	dwFileDate = static_cast<uint32>(m_timeLastDownTransfer.GetTime());

	//	Check date of .part file - if it's wrong, rehash file
		AdjustNTFSDaylightFileTime(&dwFileDate, m_strFilePath);
		if (m_timetLastWriteDate != dwFileDate)
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_RGB_WARNING, IDS_ERR_REHASH, m_strFileName);
#endif
		//	Rehash
			SetStatus(PS_WAITINGFORHASH);
#ifndef NEW_SOCKETS_ENGINE
			CHashFileThread* addfilethread = (CHashFileThread*) AfxBeginThread(RUNTIME_CLASS(CHashFileThread), THREAD_PRIORITY_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
			addfilethread->SetValues(true, GetPath(), m_hPartFileWrite.GetFileName().GetBuffer(), this);
			addfilethread->ResumeThread();
#endif
		}
	}

	if (m_bPaused)
		SetStartTimeReset(true);

//	load own file comments and ratings
	UpdateFileRatingCommentAvail();

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::TryToRecoverPartFile(LPCTSTR in_directory, LPCTSTR in_filename)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	CString strTempName;

	m_strPartMetFileName = in_filename;
	m_strTempDir = in_directory;
	if (m_strTempDir.Right(1) == _T('\\'))
		m_strTempDir.Truncate(m_strTempDir.GetLength() - 1);
	SetPath(m_strTempDir);

	m_strFullName.Format(_T("%s\\%s"), m_strTempDir, m_strPartMetFileName);
	SetFilePath(m_strFullName.Left(m_strFullName.GetLength() - 4));

//	Rename ".met" to ".met.bad"
	strTempName.Format(_T("%s.bad"), m_strFullName);
	if (_trename(m_strFullName, strTempName) != 0)
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to rename part.met file '%s' to '%s' - %s"), m_strFullName, strTempName, _tcserror(errno));

//	Copy ".met.bak" to ".met"
	strTempName.Format(_T("%s.bak"), m_strFullName);
	if (CopyFile(strTempName, m_strFullName, false) == 0)
	{
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to copy .bak file '%s' to '%s'"), strTempName, m_strFullName);
		AddLogLine(LOG_RGB_ERROR, IDS_TRYTORECOVER_FAIL, m_strFullName);
		return false;
	}

	AddLogLine(0, IDS_TRYTORECOVER, m_strFullName);

	bool bLoadPartFileStatus = LoadPartFile(in_directory, in_filename);

	if (bLoadPartFileStatus)
		AddLogLine(LOG_RGB_SUCCESS, IDS_RECOVERED_PARTMET, GetFileName());
	else
		AddLogLine(LOG_RGB_ERROR, IDS_TRYTORECOVER_FAIL, m_strFullName);

	return bLoadPartFileStatus;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return false;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::SavePartFile()
{
	EMULE_TRY

	switch (m_eStatus)
	{
		case PS_WAITINGFORHASH:
		case PS_HASHING:
		case PS_COMPLETING:
		case PS_COMPLETE:
			return false;
	}

//	Protect file corruption during calling from different threads
//	will be unlocked on exit
	CSingleLock sLock(&m_csSavePartFile, TRUE);

//	Get filedate
	CFileFind ff;
	bool bEnd = !ff.FindFile(m_strFilePath, 0);
	if (!bEnd)
		ff.FindNextFile();
	if (bEnd || ff.IsDirectory())
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_SAVEMET, GetResString(IDS_ERR_PART_FNF), m_strPartMetFileName, m_strFileName);
#endif
		return false;
	}

//	Create a backup of ".met"
	::CopyFile(m_strFullName, m_strFullName + _T(".bak"), FALSE);

	CTime lwtime;
	ff.GetLastWriteTime(lwtime);
	m_timetLastWriteDate = static_cast<uint32>(lwtime.GetTime());
	AdjustNTFSDaylightFileTime(&m_timetLastWriteDate, ff.GetFilePath());
	ff.Close();

//	Create a temporary file
	CString strTempName(m_strFullName);

	strTempName.Append(_T(".tmp"));

//	To save data safely CMemFile is used first to prepare the whole output (to reduce
//	number of filesystem I/O), then data is flushed to CFile in one shot.
//	Previous solution based on CStdioFile is not suitable for this case, as
//	CStdioFile can't generate proper exceptions due to the fact that it buffers
//	data before writing. As a result exceptions were not generated for many error cases
//	causing different file corruptions...
	CFile			file;
	CSafeMemFile	MFile(8 * 1024);

	bool	bLargeFile = IsLargeFile();
	byte	byteVer = (bLargeFile) ? PARTFILE_VERSION_LARGEFILE : PARTFILE_VERSION;

	MFile.Write(&byteVer, 1);	//	Version
	MFile.Write(&m_timetLastWriteDate, 4);	//	Date
	MFile.Write(&m_fileHash, 16);	//	Hash

	CSingleLock Lock(&m_csHashList, TRUE);
	uint16 uParts = static_cast<uint16>(m_partHashArray.GetCount());
	MFile.Write(&uParts, 2);
	for (int x = 0; x != uParts; x++)
		MFile.Write(m_partHashArray[x], 16);
	Lock.Unlock();

//	Tags
	CArray<Gap_Struct, Gap_Struct> aGaps;
	CWrTag	tagWr;
	uint32	dwTmp, dwTagFilePos, dwTagCount = 0;

	dwTagFilePos = static_cast<uint32>(MFile.GetPosition());
	MFile.Write(&dwTagCount, 4);

	if (IsUTF8Required(GetFileName()))
	{
		tagWr.WriteToFile(FT_FILENAME, GetFileName(), MFile, cfUTF8withBOM);
		dwTagCount++;
	}
	tagWr.WriteToFile(FT_FILENAME, GetFileName(), MFile);
	dwTagCount++;
	tagWr.WriteToFile(FT_FILESIZE, GetFileSize(), MFile, bLargeFile);
	dwTagCount++;
	if (m_qwBytesTransferred != 0)
	{
		tagWr.WriteToFile(FT_TRANSFERRED, m_qwBytesTransferred, MFile, bLargeFile);
		dwTagCount++;
	}
//	Compression gain can be negative in case of disconnection in the middle of
//	compressed stream, but we're not going to save it for compatibility purposes
	if (static_cast<sint64>(m_qwGainDueToCompression) > 0)
	{
		for (;;)
		{
			if (m_qwGainDueToCompression <= 0xFFFFFFFFui64)
				dwTmp = static_cast<uint32>(m_qwGainDueToCompression);
			else if (!bLargeFile)
				dwTmp = 0xFFFFFFFF;
			else
			{
				tagWr.WriteToFile(FT_COMPRESSION, m_qwGainDueToCompression, MFile, true);
				break;
			}
			tagWr.WriteToFile(FT_COMPRESSION, dwTmp, MFile);
			break;
		}
		dwTagCount++;
	}
	if (m_qwLostDueToCorruption != 0)
	{
		for (;;)
		{
			if (m_qwLostDueToCorruption <= 0xFFFFFFFFui64)
				dwTmp = static_cast<uint32>(m_qwLostDueToCorruption);
			else if (!bLargeFile)
				dwTmp = 0xFFFFFFFF;
			else
			{
				tagWr.WriteToFile(FT_CORRUPTED, m_qwLostDueToCorruption, MFile, true);
				break;
			}
			tagWr.WriteToFile(FT_CORRUPTED, dwTmp, MFile);
			break;
		}
		dwTagCount++;
	}
	if (m_bPaused)
	{
		tagWr.WriteToFile(FT_STATUS, 1, MFile);
		dwTagCount++;
	}
	tagWr.WriteToFile(FT_DLPRIORITY, (IsAutoPrioritized()) ? PR_AUTO : priority, MFile);
	dwTagCount++;
	tagWr.WriteToFile(FT_ULPRIORITY, (IsULAutoPrioritized()) ? PR_AUTO : GetULPriority(), MFile);
	dwTagCount++;
	if (static_cast<uint32>(lastseencomplete.GetTime()) != 0)
	{
		tagWr.WriteToFile(FT_LASTSEENCOMPLETE, static_cast<uint32>(lastseencomplete.GetTime()), MFile);
		dwTagCount++;
	}
	if (m_eCategoryID != CAT_NONE)
	{
		tagWr.WriteToFile(FT_CATEGORY, static_cast<uint32>(m_eCategoryID), MFile);
		dwTagCount++;
	}
	if (statistic.GetAllTimeTransferred() != 0)
	{
		tagWr.WriteToFile(FT_ATTRANSFERRED, static_cast<uint32>(statistic.GetAllTimeTransferred()), MFile);
		if ((dwTmp = static_cast<uint32>(statistic.GetAllTimeTransferred() >> 32)) != 0)
		{
			tagWr.WriteToFile(FT_ATTRANSFERREDHI, dwTmp, MFile);
			dwTagCount++;
		}
		dwTagCount++;
	}
	if (statistic.GetAllTimeRequests() != 0)
	{
		tagWr.WriteToFile(FT_ATREQUESTED, statistic.GetAllTimeRequests(), MFile);
		dwTagCount++;
	}
	if (statistic.GetAllTimeAccepts() != 0)
	{
		tagWr.WriteToFile(FT_ATACCEPTED, statistic.GetAllTimeAccepts(), MFile);
		dwTagCount++;
	}
//	Store corrupted part numbers
	CString	strCorruptedParts;
	uint32	j, dwTagNum;

	for (j = 0; j < GetPartCount(); j++)
	{
		if (IsCorruptedPart(j))
			strCorruptedParts.AppendFormat((strCorruptedParts.IsEmpty()) ? _T("%u") : _T(",%u"), j);
	}
	if (!strCorruptedParts.IsEmpty())
	{
		tagWr.WriteToFile(FT_CORRUPTEDPARTS, strCorruptedParts, MFile);
		dwTagCount++;
	}
	tagWr.WriteToFile(FT_PERMISSIONS, GetPermissions(), MFile);
	dwTagCount++;

	dwTagNum = m_tagArray.GetCount();
	dwTagCount += dwTagNum;
	for (j = 0; j < dwTagNum; j++)
		m_tagArray[j]->WriteToFile(MFile);

//	Make a gap list copy to avoid synchronization object allocation for a long time
	GetGapListCopy(&aGaps);

	char	acNameBuffer[16];
	uint32	dwPos = 0;

	Gap_Struct	*pGap = aGaps.GetData();
	Gap_Struct	*pGapMax = pGap + aGaps.GetCount();

	dwTagCount += 2 * aGaps.GetCount();
	for (; pGap < pGapMax; pGap++)
	{
		itoa(dwPos++, &acNameBuffer[1], 10);
		acNameBuffer[0] = FT_GAPSTART;
		tagWr.WriteToFile(acNameBuffer, pGap->qwStartOffset, MFile, bLargeFile);
	//	gap start = first missing byte but gap ends = first non-missing byte in edonkey
	//	but I think its easier to user the real limits
		acNameBuffer[0] = FT_GAPEND;
		tagWr.WriteToFile(acNameBuffer, pGap->qwEndOffset + 1ui64, MFile, bLargeFile);
	}

//	Save valid tag count
	MFile.Seek(dwTagFilePos, CFile::begin);
	MFile.Write(&dwTagCount, 4);

	try
	{
		if (!file.Open(strTempName, CFile::modeCreate | CFile::modeWrite))
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERROR_SAVEFILE, strTempName);
#endif
			return false;
		}
	//	Steal stream buffer pointer and length without detaching it for easier destruction
		file.Write(MFile.GetBuffer(), static_cast<unsigned>(MFile.GetLength()));
		file.Flush();

		file.Close();	// Close can generate an exception as well - keep in try/catch
	}
	catch (CFileException *error)
	{
		OUTPUT_DEBUG_TRACE();
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_SAVEMET, GetErrorMessage(error), m_strPartMetFileName, m_strFileName);
#endif
		error->Delete();
	//	About is used instead of Close as it doesn't generate exception which we don't need here
		file.Abort();
 	//	Remove the partially written or otherwise damaged temporary file
 		::DeleteFile(strTempName);
		return false;
	}

//	Delete original ".met", after successfully writing the temporary part.met file...
	if (_tremove(m_strFullName) != 0 && errno != ENOENT)
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to remove '%s' - %s"), m_strFullName, _tcserror(errno));

//	Rename ".met.tmp" to ".met"
	if (_trename(strTempName, m_strFullName) != 0)
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to move temporary part.met file '%s' to '%s' - %s"), strTempName, m_strFullName, _tcserror(errno));

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::FileRehashingStarted()
{
	if (m_eStatus == PS_WAITINGFORHASH)
		SetStatus(PS_HASHING);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::PartFileHashFinished(CKnownFile *pKnownFile)
{
	EMULE_TRY

	bool	bErrorFound = false;

	CSingleLock Lock(&m_csHashList, TRUE);

	uint32	dwGoodParts = 0, dwCount = static_cast<uint32>(m_partHashArray.GetSize());

//	Number of parts to check taking into consideration files with size % PARTSIZE = 0 and size < PARTSIZE
	dwCount = (dwCount > GetPartCount()) ? GetPartCount() : dwCount;

	for (uint32 i = 0; i < dwCount; i++)
	{
		uint64 qwPartStart, qwPartEnd;

		if (IsPartComplete(i, &qwPartStart, &qwPartEnd))
		{
			if ((pKnownFile->GetPartHash(i) == NULL) || (md4cmp(pKnownFile->GetPartHash(i), GetPartHash(i)) != 0))
			{
#ifndef NEW_SOCKETS_ENGINE
				AddLogLine(LOG_RGB_WARNING, IDS_ERR_FOUNDCORRUPTION, i, GetFileName());
#endif
				AddGap(qwPartStart, qwPartEnd);
				m_csGapListAndPartStatus.Lock();
				m_PartsStatusVector[i] |= PART_CORRUPTED;
				m_csGapListAndPartStatus.Unlock();
			//	Increment corruption statistics
				AddRxCorruptedAmount(static_cast<uint32>(qwPartEnd - qwPartStart + 1));
				bErrorFound = true;
			}
			else
				dwGoodParts++;
		}
	}
	Lock.Unlock();
	delete pKnownFile;

	if (!bErrorFound)
	{
		if (m_eStatus == PS_COMPLETING)
		{
			CompleteFile(true);
			return;
		}
#ifndef NEW_SOCKETS_ENGINE
		else
			AddLogLine(0, IDS_HASHINGDONE, GetFileName());
#endif
		SetStatus(PS_READY);
		SavePartFile();
	}
	else
	{
		if (m_eStatus == PS_COMPLETING)	// file completion
		{
			SetStatus(PS_READY);
			SavePartFile();
		//	If a file is "ready" it can't be paused
			m_bPaused = false;
			return;
		}
		else	// file rehashing on startup
		{
			SetStatus((dwGoodParts == 0) ? PS_EMPTY : PS_READY);
			SavePartFile();
			if (dwGoodParts == 0)	// don't publish on server when there're no chunks available
				return;
		}
	}
#ifndef NEW_SOCKETS_ENGINE
	g_App.m_pSharedFilesList->SafeAddKnownFile(this);
#endif

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddGap(uint64 qwStart, uint64 qwEnd)
{
	EMULE_TRY

	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);

	POSITION pos1, pos2;

	for (pos1 = gaplist.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		Gap_Struct	*pGap = gaplist.GetNext(pos1);

		if (pGap->qwStartOffset > qwStart)
		{
			if (pGap->qwStartOffset <= (qwEnd + 1ui64))
			{
				if (pGap->qwEndOffset <= qwEnd)
				{	//	(As [Gs Ge] Ae) this gap is inside the new gap - delete
					gaplist.RemoveAt(pos2);
					m_qwGapsSum -= pGap->qwEndOffset - pGap->qwStartOffset + 1ui64;
					FillGapInParts(pGap->qwStartOffset, pGap->qwEndOffset);
					delete pGap;
				}
				else
				{	//	(As [Gs Ae) Ge] or (As Ae)[Gs Ge] a part of this gap is in the new gap - extend limit and delete
					qwEnd = pGap->qwEndOffset;
					gaplist.RemoveAt(pos2);
					m_qwGapsSum -= qwEnd - pGap->qwStartOffset + 1ui64;
					FillGapInParts(pGap->qwStartOffset, qwEnd);
					delete pGap;
				}
			}
		}
		else if ((pGap->qwEndOffset + 1ui64) >= qwStart)
		{
			if (pGap->qwEndOffset < qwEnd)
			{ //	[Gs (As Ge] Ae) or [Gs Ge](As Ae) a part of this gap is in the new gap - extend limit and delete
				qwStart = pGap->qwStartOffset;
				gaplist.RemoveAt(pos2);
				m_qwGapsSum -= pGap->qwEndOffset - qwStart + 1ui64;
				FillGapInParts(qwStart, pGap->qwEndOffset);
				delete pGap;
			}
			else	//	[Gs (As Ae) Ge] new gap is already inside this gap - return
				return;
		}
	}
	Gap_Struct* new_gap = new Gap_Struct;
	new_gap->qwStartOffset = qwStart;
	new_gap->qwEndOffset = qwEnd;
	m_qwGapsSum += qwEnd - qwStart + 1ui64;
	AddGapToParts(qwStart, qwEnd);
	gaplist.AddTail(new_gap);

	lockGap.Unlock();

	UpdateDisplayedInfo();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsComplete() returns false if there are gaps in the range 'qwStart' to 'qwEnd' (inclusive).
bool CPartFile::IsComplete(uint64 qwStart, uint64 qwEnd)
{
	EMULE_TRY

	if (qwEnd >= GetFileSize())
		qwEnd = GetFileSize() - 1ui64;

	bool	bRc = true;

// 	Will be unlocked on exit
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);

	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
	{
		Gap_Struct	*pGap = gaplist.GetNext(pos);

		if ( (pGap->qwStartOffset >= qwStart && pGap->qwEndOffset <= qwEnd)			// gap is inside range (this check is unnecessary)
		     || (pGap->qwStartOffset >= qwStart && pGap->qwStartOffset <= qwEnd)	// gap starts inside range
		     || (pGap->qwEndOffset <= qwEnd && pGap->qwEndOffset >= qwStart)		// gap ends inside range
		     || (qwStart >= pGap->qwStartOffset && qwEnd <= pGap->qwEndOffset) )	// range is inside gap
		{
			bRc = false;
			break;
		}
	}
	return bRc;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsPartComplete() returns true if a part is complete and verified.
bool CPartFile::IsPartComplete(uint32 dwPart) const
{
	return (m_PartsStatusVector[dwPart] == PART_VERIFIED);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsPartComplete() returns true if a part is complete and verified.
//		Params:
//			dwPart   - part number;
//			pqwStart - pointer to get part start offset;
//			pqwEnd   - pointer to get part end offset (inclusive).
bool CPartFile::IsPartComplete(uint32 dwPart, uint64 *pqwStart, uint64 *pqwEnd) const
{
	uint64 qwStart = static_cast<uint64>(dwPart) * PARTSIZE;
	uint64 qwEnd = ((qwStart + PARTSIZE - 1ui64) >= GetFileSize()) ? (GetFileSize() - 1ui64) : (qwStart + PARTSIZE - 1ui64);

	*pqwStart = qwStart;
	*pqwEnd = qwEnd;

	return (m_PartsStatusVector[dwPart] == PART_VERIFIED);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsPartFull() returns true if all its data was received
bool CPartFile::IsPartFull(uint32 dwPart) const
{
	return ((m_PartsStatusVector[dwPart] & 0xFFFFFF) == 0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsPartDownloading(uint32 dwPart) const
{
	EMULE_TRY

	for (POSITION pos = requestedblocks_list.GetHeadPosition(); pos != NULL;)
	{
		Requested_Block_Struct *pReqBlock = requestedblocks_list.GetNext(pos);

		if (dwPart == static_cast<uint32>(pReqBlock->qwStartOffset / PARTSIZE))
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsAlreadyRequested(uint64 qwStart, uint64 qwEnd)
{
	EMULE_TRY

	for (POSITION pos = requestedblocks_list.GetHeadPosition(); pos != NULL;)
	{
		Requested_Block_Struct	*cur_block = requestedblocks_list.GetNext(pos);

		if ((qwStart <= cur_block->qwEndOffset) && (qwEnd >= cur_block->qwStartOffset))
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetGapsInPart() return request blocks for the corresponding part
//		Params:
//			dwPartNum   - a part to examine;
//			ppNewBlocks - output array for allocated request blocks (can be NULL to check for block allocation);
//			dwCount     - number of blocks to allocate.
//		Return:
//			number of allocated blocks or number of possible blocks to allocate if newblocks = NULL.
uint32 CPartFile::GetGapsInPart(uint32 dwPartNum, Requested_Block_Struct **ppNewBlocks, uint32 dwCount)
{
	uint32	dwNewBlockCount = 0;

	EMULE_TRY

//	Calculate offsets of the Part
	const uint64 qwPartStart = static_cast<uint64>(dwPartNum) * PARTSIZE;
	const uint64 qwPartEnd = ((qwPartStart + PARTSIZE - 1ui64) >= GetFileSize()) ? (GetFileSize() - 1ui64) : (qwPartStart + PARTSIZE - 1ui64);

	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on exit

//	Retrieve Gap(s) matching the part
	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
	{
		Gap_Struct *pGap = gaplist.GetNext(pos);

	//	Check if Gap is inside the limit
		if ((pGap->qwStartOffset > qwPartEnd) || (pGap->qwEndOffset < qwPartStart))
			continue;

	//	Calculate offsets of the Gap within the part
		uint64 qwGapStart = (pGap->qwStartOffset < qwPartStart) ? qwPartStart : pGap->qwStartOffset;
		const uint64 qwGapEnd = (pGap->qwEndOffset > qwPartEnd) ? qwPartEnd : pGap->qwEndOffset;

	//	Create n request block(s)
		while ((qwGapEnd >= qwGapStart) && (dwNewBlockCount < dwCount))
		{
		//	Calculate offsets of the block
			const uint64 qwStartOffset = qwGapStart;
			const uint64 qwEndOffset = ((qwGapStart + EMBLOCKSIZE - 1ui64) >= qwGapEnd) ? qwGapEnd : ((qwGapStart + EMBLOCKSIZE - 1ui64) - (qwGapStart % EMBLOCKSIZE));

		//	Prepare offset of next block
			qwGapStart = qwEndOffset + 1ui64;

		//	Check if block has already been requested
			if (!IsAlreadyRequested(qwStartOffset, qwEndOffset))
			{
				if (ppNewBlocks != NULL)
				{
				//	Create 1 request block
					Requested_Block_Struct *block = new Requested_Block_Struct;

					block->qwStartOffset = qwStartOffset;
					block->qwEndOffset = qwEndOffset;
					md4cpy(block->m_fileHash, GetFileHash());

				//	Flag the block as 'requested'
					requestedblocks_list.AddTail(block);

				//	Return the block to the source
					ppNewBlocks[dwNewBlockCount] = block;
				}
				dwNewBlockCount++;
			}
		}
	}

	EMULE_CATCH

	return dwNewBlockCount;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::FillGap(uint64 qwStart, uint64 qwEnd)
{
	EMULE_TRY

	POSITION pos1, pos2;

	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);

	for (pos1 = gaplist.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		Gap_Struct	*pGap = gaplist.GetNext(pos1);

		if (pGap->qwStartOffset >= qwStart)
		{
			if (pGap->qwStartOffset <= qwEnd)
			{
				if (pGap->qwEndOffset <= qwEnd)
				{ //	(Fs [Gs Ge] Fe) our part fills this gap completely
					gaplist.RemoveAt(pos2);
					m_qwGapsSum -= pGap->qwEndOffset - pGap->qwStartOffset + 1ui64;
					FillGapInParts(pGap->qwStartOffset, pGap->qwEndOffset);
					delete pGap;
				}
				else
				{	//	(Fs [Gs Fe) Ge] a part of this gap is in the part - set limit
					m_qwGapsSum -= qwEnd - pGap->qwStartOffset + 1ui64;
					FillGapInParts(pGap->qwStartOffset, qwEnd);
					pGap->qwStartOffset = qwEnd + 1ui64;
				}
			}
		}
		else if (pGap->qwEndOffset >= qwStart)
		{
			if (pGap->qwEndOffset <= qwEnd)
			{	//	[Gs (Fs Ge] Fe) a part of this gap is in the part - set limit
				m_qwGapsSum -= pGap->qwEndOffset - qwStart + 1ui64;
				FillGapInParts(qwStart, pGap->qwEndOffset);
				pGap->qwEndOffset = qwStart - 1ui64;
			}
			else	//	[Gs (Fs Fe) Ge]
			{
				uint64 qwTmp = pGap->qwEndOffset;

				pGap->qwEndOffset = qwStart - 1;
				pGap = new Gap_Struct;
				pGap->qwStartOffset = qwEnd + 1;
				pGap->qwEndOffset = qwTmp;
				m_qwGapsSum -= qwEnd - qwStart + 1ui64;
				FillGapInParts(qwStart, qwEnd);
				gaplist.InsertAfter(pos1, pGap);
				break;
			}
		}
	}
	lockGap.Unlock();

	UpdateCompletedInfos();
	UpdateDisplayedInfo();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function updates the part status vector based on gap information
// Must be called only under m_csGapListAndPartStatus protection
void CPartFile::FillGapInParts(uint64 qwGapStart, uint64 qwGapEnd)
{
	uint32	dwBegPart = static_cast<uint32>(qwGapStart / PARTSIZE);
	uint32	dwEndPart = static_cast<uint32>(qwGapEnd / PARTSIZE);
	uint64	qwPartStart = static_cast<uint64>(dwBegPart) * PARTSIZE;

	for (uint32 dwPart = dwBegPart; dwPart <= dwEndPart; dwPart++, qwPartStart += PARTSIZE)
	{
		uint64 qwPartEnd = ((qwPartStart + PARTSIZE - 1ui64) >= GetFileSize()) ? (GetFileSize() - 1ui64) : (qwPartStart + PARTSIZE - 1ui64);
		uint32 dwPartFilledSize = GetPartLeftToDLSize(dwPart);

		if (qwGapStart <= qwPartStart)
		{
			if (qwGapEnd >= qwPartEnd)	//	[Gs (Ps Pe) Ge]
				dwPartFilledSize = 0;
			else						//	[Gs (Ps Ge] Pe)
				dwPartFilledSize -= static_cast<uint32>(qwGapEnd - qwPartStart + 1);
		}
		else
		{
			if (qwGapEnd < qwPartEnd)	//	(Ps [Gs Ge] Pe) else (Ps [Gs Pe) Ge]
				qwPartEnd = qwGapEnd;
			dwPartFilledSize -= static_cast<uint32>(qwPartEnd - qwGapStart + 1);
		}

		m_PartsStatusVector[dwPart] = (m_PartsStatusVector[dwPart] & 0xFF000000) | dwPartFilledSize;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This function updates the part status vector based on gap information
// Must be called only under m_csGapListAndPartStatus protection
void CPartFile::AddGapToParts(uint64 qwGapStart, uint64 qwGapEnd)
{
	uint32	dwBegPart = static_cast<uint32>(qwGapStart / PARTSIZE);
	uint32	dwEndPart = static_cast<uint32>(qwGapEnd / PARTSIZE);
	uint64	qwPartStart = static_cast<uint64>(dwBegPart) * PARTSIZE;

	for (uint32 dwPart = dwBegPart; dwPart <= dwEndPart; dwPart++, qwPartStart += PARTSIZE)
	{
		uint64 qwPartEnd = ((qwPartStart + PARTSIZE - 1ui64) >= GetFileSize()) ? (GetFileSize() - 1ui64) : (qwPartStart + PARTSIZE - 1ui64);
		uint32 dwPartFilledSize = GetPartLeftToDLSize(dwPart);

		if (qwGapStart <= qwPartStart)
		{
			if (qwGapEnd >= qwPartEnd)	//	[Gs (Ps Pe) Ge]
				dwPartFilledSize = static_cast<uint32>(qwPartEnd - qwPartStart + 1);
			else						//	[Gs (Ps Ge] Pe)
				dwPartFilledSize += static_cast<uint32>(qwGapEnd - qwPartStart + 1);
		}
		else
		{
			if (qwGapEnd < qwPartEnd)	//	(Ps [Gs Ge] Pe) else (Ps [Gs Pe) Ge]
				qwPartEnd = qwGapEnd;
			dwPartFilledSize += static_cast<uint32>(qwPartEnd - qwGapStart + 1);
		}
	//	Reset PART_VERIFIED status as a gap was added to this part
		m_PartsStatusVector[dwPart] =
			(m_PartsStatusVector[dwPart] & (0xFF000000 & ~PART_VERIFIED)) | dwPartFilledSize;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::UpdateCompletedInfos()
{
	EMULE_TRY

	if ((m_qwGapsSum != 0) || (requestedblocks_list.GetCount() != 0))
	{
		m_dblPercentCompleted = (1.0 - static_cast<double>(m_qwGapsSum) / static_cast<double>(GetFileSize())) * 100;
		m_qwCompletedSize = GetFileSize() - m_qwGapsSum;
	}
	else
	{
		m_dblPercentCompleted = 100.0;
		m_qwCompletedSize = GetFileSize();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::DrawStatusBar(CDC* dc, RECT* rect, bool bFlat)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	const COLORREF crProgress = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);
	COLORREF crHave, crPending, crMissing;

//	grayPause - Colors by status
	EnumPartFileStatuses	eFileStatus = GetStatus();
	bool			bNotPaused = (eFileStatus == PS_EMPTY) || (eFileStatus == PS_READY);

	if (bNotPaused)
	{
		crHave = (bFlat) ? RGB(0, 0, 0) : RGB(95, 95, 95);
		crPending = RGB(255, 208, 0);
		crMissing = RGB(255, 0, 0);
	}
	else
	{
		crHave = (bFlat) ? RGB(105, 105, 105) : RGB(142, 142, 142);
		crPending = RGB(255, 240, 142);
		crMissing = RGB(255, 142, 142);
	}

	CBarShader s_ChunkBar(rect->bottom - rect->top, rect->right - rect->left, crHave, GetFileSize());

	if (m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING)
	{
		s_ChunkBar.Fill(crProgress);
		s_ChunkBar.Draw(dc, rect->left, rect->top, bFlat);
		m_dblPercentCompleted = 100.0;
		m_qwCompletedSize = GetFileSize();
		return;
	}

//	Red gaps
	CArray<Gap_Struct, Gap_Struct> aGaps;

//	Make a gap list copy to avoid synchronization object allocation for a long time
	GetGapListCopy(&aGaps);

	Gap_Struct	*pGap = aGaps.GetData();
	Gap_Struct	*pGapMax = pGap + aGaps.GetCount();

	for (; pGap < pGapMax; pGap++)
	{
		uint64	qwGapBeg = pGap->qwStartOffset;
		uint64	qwGapEnd = pGap->qwEndOffset + 1ui64;

		for (uint32 i = static_cast<uint32>(qwGapBeg / PARTSIZE); i < GetPartCount(); i++)
		{
			const uint64 qwPartStart = static_cast<uint64>(i) * PARTSIZE;
			const uint64 qwPartEnd = ((qwPartStart + PARTSIZE) > GetFileSize()) ? GetFileSize() : (qwPartStart + PARTSIZE);

			if (qwGapEnd > qwPartEnd)
				qwGapEnd = qwPartEnd;	// The rest is in the next part

			COLORREF	color;
			int			iFreq;

			if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && ((iFreq = m_srcPartFrequencies[i] - 1) >= 0))
			{
				if (bNotPaused)
				{
					if (IsPartDownloading(i))
						color = crPending;	// Downloading part in yellow
					else
						color = RGB(0, ((210 - 8 * iFreq) < 0) ? 0 : (210 - 8 * iFreq), 255);
				}
				else
					color = RGB(100, ((210 - 8 * iFreq) < 0) ? 0 : (255 - 8 * iFreq), 255);
			}
			else
				color = crMissing;

			s_ChunkBar.FillRange(qwGapBeg, qwGapEnd, color);

			qwGapBeg = qwGapEnd;
			qwGapEnd = pGap->qwEndOffset + 1ui64;
			if (qwGapBeg == qwGapEnd)	// Finished?
				break;
		}
	}

	s_ChunkBar.Draw(dc, rect->left, rect->top, bFlat);

//	Green progress
	RECT gaprect;
	gaprect.top = rect->top;
	gaprect.bottom = gaprect.top + PROGRESS_HEIGHT;
	gaprect.left = rect->left;

	uint32	w = rect->right - rect->left + 1;
	uint32	wp = (uint32)(m_dblPercentCompleted / 100.0 * w + 0.5);

	if (!bFlat)
	{
		CBarShader	s_LoadBar(PROGRESS_HEIGHT, wp, crPending, m_qwCompletedSize);

		s_LoadBar.FillRange(0, m_qwCompletedPartsSize, crProgress);
		s_LoadBar.Draw(dc, gaprect.left, gaprect.top, false);
	}
	else
	{
		uint32		wc = (uint32)(static_cast<double>(m_qwCompletedPartsSize) / static_cast<double>(GetFileSize()) * w + 0.5);
		int			left = rect->left;

	//	Green
		gaprect.right = left + wc;
		CBrush pr_Brush(crProgress);
		dc->FillRect(&gaprect, &pr_Brush);

	//	Yellow
		gaprect.left = left + wc;
		gaprect.right = left + wp;
		CBrush pe_Brush(crPending);
		dc->FillRect(&gaprect, &pe_Brush);

	//	Draw gray progress only if flat
		gaprect.left = left + wp;
		gaprect.right = left + w;
		CBrush rgb_Brush(RGB(224, 224, 224));
		dc->FillRect(&gaprect, &rgb_Brush);
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::WritePartStatus(CFile* file)
{
	EMULE_TRY

	uint32	dwDone = 0, dwParts = GetED2KPartCount();

	file->Write(&dwParts, 2);
	while (dwDone != dwParts)
	{
		byte towrite = 0;
		for (uint32 i = 0; i < 8; i++)
		{
		//	Report that we have "void" part for files with size % PARTSIZE = 0
			if ( ((dwDone == (dwParts - 1)) && (dwParts != GetPartCount())) ||
				(IsPartShared(dwDone) && IsPartComplete(dwDone)) )
				towrite |= (1 << i);

			if (++dwDone == dwParts)
				break;
		}
		file->Write(&towrite, 1);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::WriteCompleteSourcesCount(CFile* file)
{
	uint16 completecount = GetCompleteSourcesCount();
	file->Write(&completecount, 2);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CPartFile::GetValidSourcesCount()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	uint32	dwListsMask = SLM_VALID_SOURCES;
	uint32	dwCounter = 0;

	for (EnumDLQState eDS = DS_DOWNLOADING; eDS < DS_LAST_QUEUED_STATE; ++eDS, dwListsMask >>= 1)
	{
		if ((dwListsMask & 1) != 0)
			dwCounter += m_SourceLists[eDS].size();
	}

	return dwCounter;

	EMULE_CATCH

#endif //NEW_SOCKETS_ENGINE
	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CPartFile::GetNotCurrentSourcesCount()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	uint32	dwCounter = 0;

	for (int iDS = 0; iDS < DS_LAST_QUEUED_STATE; iDS++)
	{
		if ((iDS != DS_ONQUEUE) && (iDS != DS_DOWNLOADING) && (iDS != DS_LOWID_ON_OTHER_SERVER))
			dwCounter += m_SourceLists[iDS].size();
	}

	return dwCounter;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EnumPartFileStatuses CPartFile::GetStatus() const
{
	if (!m_bPaused || m_eStatus == PS_ERROR || m_eStatus == PS_COMPLETING || m_eStatus == PS_COMPLETE)
		return m_eStatus;
	else if (m_bStopped)
		return PS_STOPPED;
	else
		return PS_PAUSED;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Remove no needed sources from download queue
//	[In] dwNumberSources2Remove: Number of sources to be removed from list
void CPartFile::RemoveNoNeededSources(uint32 dwNumberSources2Remove)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	ClientList	sourceListCopy;
	uint32		dwIdx = 0, dwRemoved;

//	First remove clients with "NNS" status
	GetCopySourceList(DS_NONEEDEDPARTS, &sourceListCopy);
	dwRemoved = (sourceListCopy.size() > dwNumberSources2Remove) ? dwNumberSources2Remove : sourceListCopy.size();

	for (ClientList::const_iterator cIt = sourceListCopy.begin(); dwIdx < dwRemoved; dwIdx++)
		g_App.m_pDownloadQueue->RemoveSource(*cIt++);

	if (dwRemoved < dwNumberSources2Remove)
	{
	//	Remove clients with "Queue Full" status
		GetCopySourceList(DS_ONQUEUE, &sourceListCopy);
		for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
		{
			CUpDownClient	*pSource = *cIt;

		//	The sources will be dropped in 2 cases:
		//	1) the remote client does not have required parts
		//	2) the remote queue is still full & we waited at least 3 reasks to enter into the queue
			if (pSource->IsRemoteQueueFull() && (pSource->GetAskedCountDown() > 3))
			{
				g_App.m_pDownloadQueue->RemoveSource(pSource);
				if (++dwRemoved >= dwNumberSources2Remove)
					break;
			}
		}
	}

	EMULE_CATCH

	m_dwLastPurgeTime = ::GetTickCount();
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CPartFile::Process(uint32 dwReduceDownload /*in percent*/, uint32 dwIteration)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	ClientList		sourceListCopy;
	uint16			nOldTransSourceCount = GetTransferringSrcCount();
	uint16			iOldSrcOnQueueCount = GetOnQueueSrcCount();
	DWORD			dwCurTick = ::GetTickCount();
	CUpDownClient  *pSource = NULL;
	uint32			dwCurrentDataRate = 0;
	uint32			dwLastNoNeededCheckTime = 0;
	uint32			dwDataRate = 0;

//	flush the data to disk if:
//	1. it was requested
//	2. buffer size exceeds limit
//	3. data was not written within time limit
	if ( m_bDataFlushReq
		|| (m_nTotalBufferData > g_App.m_pPrefs->GetFileBufferSize())
		|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)) )
	{
	//	Avoid flushing while copying preview file
		if (!m_bPreviewing)
			FlushBuffer();
	}

//	Always process the transferring sources
//	Note: in case of disconnection sources will be put back to queue after download timeout
	if (!m_SourceLists[DS_DOWNLOADING].empty())
	{
		GetCopySourceList(DS_DOWNLOADING, &sourceListCopy);
		for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
		{
			pSource = *cIt;

		// Check if new client has non DL state, then it was removed after creation of the list copy, so ignore it
			if (pSource->GetDownloadState() != DS_DOWNLOADING)
				continue;

			dwCurrentDataRate = pSource->DownloadProcess(dwReduceDownload);

		//	Since client can be dropped due timeout we need to check the state again
			if (pSource->GetDownloadState() != DS_DOWNLOADING)
				continue;
			dwDataRate += dwCurrentDataRate;
		}
	}
	m_dwDataRate = dwDataRate;
	m_uNumTransferringSrcs = static_cast<uint16>(m_SourceLists[DS_DOWNLOADING].size());

//	count & process every 10th time the "connecting" sources
	if (dwIteration == 8)
	{
	//	Count connecting sources
		m_uSrcConnecting = static_cast<uint16>(m_SourceLists[DS_CONNECTING].size());
	//	Process passive sources that are waiting on connection
		if (!m_SourceLists[DS_WAITCALLBACK].empty())
		{
			GetCopySourceList(DS_WAITCALLBACK, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;

#ifdef OLD_SOCKETS_ENABLED
			//	If the request socket still doesn't exist & we waited more than
			//	double connection time (as connection is done through the server)
				if ( (pSource->m_pRequestSocket == NULL) &&
					(dwCurTick - pSource->GetLastAskedTime() > (2 * CONNECTION_TIMEOUT)) )
				{
				//	Remote sources may not answer to callback if we're a NNS for them;
				//	A new source (which was never contacted) has GetClientNeededParts() = 0
					if ( ( (pSource->GetUploadState() == US_ONUPLOADQUEUE) ||
						(pSource->GetClientNeededParts() != 0) ) &&
						((dwCurTick - pSource->GetEnteredConnectedState()) < MAX_PURGEQUEUETIME) )
					{
						pSource->UpdateDownloadStateAfterFileReask();
					}
					else
					{
					//	Remove the source (from download and upload queues) in the following cases:
					//	1) we have nothing to get from it and it is not in our upload queue
					//	in the most cases it happens when we try to initiate a connection to a
					//	new source; if a source is really good it will find us or we'll find it again
					//	2) source became inactive as it stopped contacting us
						delete pSource;
					}
				}
#endif //OLD_SOCKETS_ENABLED
			}
		}	
		m_uSrcConnViaServer = static_cast<uint16>(m_SourceLists[DS_WAITCALLBACK].size());
	}

	if ((g_App.m_pServerConnect == NULL) || !g_App.m_pServerConnect->IsConnected())
		return m_dwDataRate;

//	Process every 10th time the rest of the sources
	if (dwIteration == 1)
	{
		if (!m_SourceLists[DS_CONNECTED].empty())
		{
			GetCopySourceList(DS_CONNECTED, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;

#ifdef OLD_SOCKETS_ENABLED
			//	If the request socket doesn't exist or isn't connected
				if ((pSource->m_pRequestSocket == NULL) || !pSource->m_pRequestSocket->IsConnected())
				{
					pSource->SetDownloadState(DS_ERROR);
					pSource->Disconnected();
				}
				else if (pSource->GetDownloadState() == DS_CONNECTED
					&& (dwCurTick - pSource->GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000))
				{
					pSource->UpdateDownloadStateAfterFileReask();
				}
#endif //OLD_SOCKETS_ENABLED
			}
		}
		m_uSrcConnected = static_cast<uint16>(m_SourceLists[DS_CONNECTED].size());
	}
	else if (dwIteration == 2)	// process NNS sources
	{
		if (!m_SourceLists[DS_NONEEDEDPARTS].empty())
		{
			CServer	*pCurSrv = g_App.m_pServerConnect->GetCurrentServer();
			uint32	dwLocalSrvIP = (pCurSrv != NULL) ? pCurSrv->GetIP() : 0xFFFFFFFF;

			GetCopySourceList(DS_NONEEDEDPARTS, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;

			//	Process remote LowID sources
				if (pSource->HasLowID() && (pSource->GetServerIP() != dwLocalSrvIP))
				{
					if (pSource->m_pRequestSocket == NULL)
					{
					//	Since we can't connect to a remote LowID client, it can be kept only if it keeps requesting our files
						if ((dwCurTick - pSource->GetEnteredConnectedState()) > MAX_PURGEQUEUETIME)
						{
						//	Remove the source (from download and upload queues) in the following cases:
						//	1) some ed2k clients send UDP reasks when they're LowID, as we can't contact
						//	them in this case, we keep it for a while and remove after some time to avoid leeching
						//	2) source became inactive as it stopped contacting us (we drop from
						//	upload queue here to free room in it faster)
							delete pSource;
						}
					}
				//	If remote LowID is downloading from us, what can be happening for a pretty long time,
				//	it doesn't contact us at that time, so we need to send reask in the same session from
				//	time to time, otherwise we can be purged from the remote upload queue due to inactivity
					else if ((pSource->GetUploadState() == US_UPLOADING) && pSource->m_pRequestSocket->IsConnected())
					{
						if (dwCurTick > pSource->GetNextFileReaskTime())
							pSource->AskForDownload();
					}
					continue;
				}

				if (dwCurTick > pSource->GetNextFileReaskTime())
					pSource->AskForDownload();
			}
		}
		m_uSrcNNP = static_cast<uint16>(m_SourceLists[DS_NONEEDEDPARTS].size());
	}
	else if (dwIteration == 3)	// process the sources on the queue
	{
		if (!m_SourceLists[DS_ONQUEUE].empty())
		{
			uint16	uSrcQueueFull = 0;
			uint16	uSrcHighQR = 0;

			GetCopySourceList(DS_ONQUEUE, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;

				if (pSource->IsRemoteQueueFull())
					uSrcQueueFull++;
				else if (pSource->GetRemoteQueueRank() > QUEUERANK_HIGH)
					uSrcHighQR++;

				if (dwCurTick > pSource->GetNextFileReaskTime())
					pSource->SendReask();
			}
			m_uSrcQueueFull = uSrcQueueFull;
			m_uSrcHighQR = uSrcHighQR;
			m_uSrcOnQueue = static_cast<uint16>(m_SourceLists[DS_ONQUEUE].size());
		}
		else
		{
			m_uSrcOnQueue = m_uSrcQueueFull = m_uSrcHighQR = 0;
		}
	}
	else if (dwIteration == 4)	// process LowID clients on other servers
	{
		if (!m_SourceLists[DS_LOWID_ON_OTHER_SERVER].empty())
		{
			GetCopySourceList(DS_LOWID_ON_OTHER_SERVER, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;

				if (pSource->GetDownloadState() != DS_LOWID_ON_OTHER_SERVER)
					continue;
				if (pSource->m_pRequestSocket == NULL)
				{
				//	Since we can't connect to a remote LowID client, it can be kept only if it keeps requesting our files
					if ((dwCurTick - pSource->GetEnteredConnectedState()) > MAX_PURGEQUEUETIME)
					{
					//	Remove the source (from download and upload queues) in the following cases:
					//	1) some ed2k clients send UDP reasks when they're LowID, as we can't contact
					//	them in this case, we keep it for a while and remove after some time to avoid leeching
					//	2) source became inactive as it stopped contacting us (we drop from
					//	upload queue here to free room in it faster)
						delete pSource;
					}
				}
			//	If remote LowID is downloading from us, what can be happening for a pretty long time,
			//	it doesn't contact us at that time, so we need to send reask in the same session from
			//	time to time, otherwise we can be purged from the remote upload queue due to inactivity
				else if ((pSource->GetUploadState() == US_UPLOADING) && pSource->m_pRequestSocket->IsConnected())
				{
					if (dwCurTick > pSource->GetNextFileReaskTime())
						pSource->AskForDownload();
				}
			}
		}
		m_uSrcLowIDOnOtherServer = static_cast<uint16>(m_SourceLists[DS_LOWID_ON_OTHER_SERVER].size());
	}
	else if (dwIteration == 5)	// process sources which haven't requested file yet
	{
		if (!m_SourceLists[DS_WAIT_FOR_FILE_REQUEST].empty())
		{
			GetCopySourceList(DS_WAIT_FOR_FILE_REQUEST, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
			//	The first request is always TCP request
				(*cIt)->AskForDownload();
			}
		}
		m_uSrcWaitForFileReq = static_cast<uint16>(m_SourceLists[DS_WAIT_FOR_FILE_REQUEST].size());
	}
	else if (dwIteration == 6)	// process LowID to LowID clients
	{
		if (!m_SourceLists[DS_LOWTOLOWID].empty())
		{
			GetCopySourceList(DS_LOWTOLOWID, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;

				if (pSource->GetDownloadState() != DS_LOWTOLOWID)
					continue;
				if (pSource->m_pRequestSocket == NULL)
				{
				//	Since we can't connect to a remote LowID client, it can be kept only if it keeps requesting our files
					if ((dwCurTick - pSource->GetEnteredConnectedState()) > MAX_PURGEQUEUETIME)
					{
					//	Remove the source (from download and upload queues) in the following cases:
					//	1) some ed2k clients send UDP reasks when they're LowID, as we can't contact
					//	them in this case, we keep it for a while and remove after some time to avoid leeching
					//	2) source became inactive as it stopped contacting us (we drop from
					//	upload queue here to free room in it faster)
						delete pSource;
					}
				}
			//	If remote LowID is downloading from us, what can be happening for a pretty long time,
			//	it doesn't contact us at that time, so we need to send reask in the same session from
			//	time to time, otherwise we can be purged from the remote upload queue due to inactivity
				else if ((pSource->GetUploadState() == US_UPLOADING) && pSource->m_pRequestSocket->IsConnected())
				{
					if (dwCurTick > pSource->GetNextFileReaskTime())
						pSource->AskForDownload();
				}
			}
		}
		m_uSrcLowToLow = static_cast<uint16>(m_SourceLists[DS_LOWTOLOWID].size());
	}
	else if (dwIteration == 7)	// manage other sources (A4AF, request from the server)
	{
		uint16	uSourceNumber = GetSourceCount();

	//	A4AF management
	//	Swap sources with NNS status if possible
		BOOL bIsNNS;

		if (((!m_LastNoNeededCheck) || (dwCurTick - m_LastNoNeededCheck) > 30000))
		{
			m_LastNoNeededCheck = dwCurTick;
			GetCopySourceList(DS_NONEEDEDPARTS, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;
			//	Check if A4AF Auto file is enable
				if (g_App.m_pDownloadQueue->GetA4AFAutoFile() == NULL)
				//	A4AF auto is disable => switch to any file
					pSource->SwapToAnotherFile(NULL);
				else if (g_App.m_pDownloadQueue->GetA4AFAutoFile() != this)
				{
				//	A4AF auto is enable & isn't current file => switch to A4AF auto file
					if (pSource->m_otherNoNeededMap.IsEmpty())
					{
						pSource->SwapToAnotherFile(g_App.m_pDownloadQueue->GetA4AFAutoFile());
					}
					else
					{
						bIsNNS = pSource->m_otherNoNeededMap.Lookup(g_App.m_pDownloadQueue->GetA4AFAutoFile(), dwLastNoNeededCheckTime);
						if (!bIsNNS || (dwCurTick - dwLastNoNeededCheckTime) > FILEREASKTIME)
						{
							pSource->SwapToAnotherFile(g_App.m_pDownloadQueue->GetA4AFAutoFile());
						}
					}
				}
			}
		}

	//	If this "File" is A4AF auto & A4AF list isn't empty,
	//	then check A4AF list and swap source to "this", if source isn't NNS
		if (g_App.m_pDownloadQueue->GetA4AFAutoFile() == this && !m_A4AFSourceLists.empty())
		{
			GetCopyA4AFSourceList(&sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
				pSource = *cIt;
			// allow A4AF switch only for clients with static states 
			// with one exception "DS_WAIT_FOR_FILE_REQUEST" for paused files
				if ( (pSource != NULL) 
					&& (pSource->GetDownloadState() == DS_ONQUEUE 
						|| pSource->GetDownloadState() == DS_NONEEDEDPARTS
						|| pSource->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER
						|| (pSource->GetDownloadState() == DS_WAIT_FOR_FILE_REQUEST
							&& GetStatus() == PS_PAUSED)) )
				{
					if (pSource->m_otherNoNeededMap.IsEmpty())
						pSource->SwapToAnotherFile(this);
					else
					{
						bIsNNS = pSource->m_otherNoNeededMap.Lookup(this, dwLastNoNeededCheckTime);
						if (!bIsNNS || (dwCurTick - dwLastNoNeededCheckTime) > FILEREASKTIME)
						{
							pSource->SwapToAnotherFile(this);
						}
					}
				}
			}
		}
		m_uSrcA4AF = static_cast<uint16>(m_A4AFSourceLists.size());

	//	Check if we want new sources from server
	//	1. connection state will be checked in DL-queue manager, so we don't need to do it here
	//	2. we can call SetRequiredSourcesRefresh() so many time as we want, cause this function
	//	   checks if the file exists.
		if ( ( (!m_dwLastFileSourcesRequestTime) || (dwCurTick - m_dwLastFileSourcesRequestTime) > SERVERREASKTIME)
			&& g_App.m_pPrefs->GetMaxSourcePerFileSoft() > uSourceNumber )
		{
		//	Local server
			m_dwLastFileSourcesRequestTime = dwCurTick;
			g_App.m_pDownloadQueue->SetRequiredSourcesRefresh(this);
		}

	//	Save sources in case there isn't DL (no need to do it so precise, so we can easily skip some ticks)
#ifdef OLD_SOCKETS_ENABLED
		if (g_App.m_pPrefs->SLSEnable() && m_SourceLists[DS_DOWNLOADING].empty() && g_App.m_pServerConnect->IsConnected())
		{
			m_sourcesaver.Process(this, g_App.m_pPrefs->SLSMaxSourcesPerFile());
		}
#endif //OLD_SOCKETS_ENABLED

	//	Calculate data rate, set limit etc. (every 5 sec)
		m_uProcessCounter++;
		if (m_uProcessCounter == 5)
		{
			m_uProcessCounter = 0;
			UpdateCompletedInfos();
			UpdateDisplayedInfo();
		}
	}

//	For status category filters check the status change
//	1. is transfering <-> is not transfering
//	2. is on the queue <-> is not on the queue
	if ( (nOldTransSourceCount == 0 && GetTransferringSrcCount() != 0)
		|| (nOldTransSourceCount != 0 && GetTransferringSrcCount() == 0)
	     || (iOldSrcOnQueueCount == 0 && GetOnQueueSrcCount() != 0)
	     || (iOldSrcOnQueueCount != 0 && GetOnQueueSrcCount() == 0) )
	{
		UpdateGUIAfterStateChange();
	}

	return m_dwDataRate;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddServerSources(CMemFile &pSources, uint32 dwSrvIP, uint16 uSrvPort, bool bWithObfuscationAndHash)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

//	If this part file is paused or complete/completing or erroneous, no sources needed any more
	EnumPartFileStatuses	eFileStatus = GetStatus();
	bool			bSkip = ( eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE ||
		eFileStatus == PS_COMPLETING || eFileStatus == PS_ERROR );
	CUpDownClient	*pNewSource;
	uint32			dwUserID, dwUserIDHyb;
	uint16			uUserPort;
	uchar			abyteUserHash[16], byteCount, byteCryptOpt;

	pSources.Read(&byteCount, 1);

//	If there is a need for more sources just remove NNS
	uint32	dwSrcCountPlusNew = GetSourceCount() + byteCount;

	if ( (dwSrcCountPlusNew > g_App.m_pPrefs->GetMaxSourcePerFile())
		&& (m_dwLastPurgeTime + PURGE_TIME) < ::GetTickCount() )
	{
		RemoveNoNeededSources(dwSrcCountPlusNew - g_App.m_pPrefs->GetMaxSourcePerFile());
	}

	for (int i = 0; i < static_cast<int>(byteCount); i++)
	{
		pSources.Read(&dwUserID, 4);
		pSources.Read(&uUserPort, 2);

		byteCryptOpt = 0;
		if (bWithObfuscationAndHash)
		{
			pSources.Read(&byteCryptOpt, 1);
			if ((byteCryptOpt & 0x80) != 0)
				pSources.Read(abyteUserHash, 16);
		}

	//	Since we may received multiple search source UDP results we have to "consume" all data of that packet
		if (bSkip)
			continue;

#ifdef OLD_SOCKETS_ENABLED
	//	Don't add the sources if we are not connected to a server
		if (!g_App.m_pServerConnect->IsConnected())
			break;
	//	Check first if we are this source
		if (g_App.m_pServerConnect->IsLowID())
		{
			if ( g_App.m_pServerConnect->GetClientID() == dwUserID &&
				 (g_App.m_pPrefs->GetPort() == uUserPort) &&
				 inet_addr(g_App.m_pServerConnect->GetCurrentServer()->GetFullIP()) == dwSrvIP )
			{
				continue;
			}
		}
		else if ( g_App.m_pServerConnect->GetClientID() == dwUserID &&
				(g_App.m_pPrefs->GetPort() == uUserPort) )
		{
			continue;
		}
		else if ( IsLowID(dwUserID) &&
				  !g_App.m_pServerConnect->IsLocalServer(dwSrvIP, uSrvPort) )
		{
			continue;
		}
#endif //OLD_SOCKETS_ENABLED

		if (g_App.m_pPrefs->GetMaxSourcePerFile() > GetSourceCount())
		{
			dwUserIDHyb = IsLowID(dwUserID) ? dwUserID : fast_ntohl(dwUserID);
			pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, dwUserIDHyb, uUserPort, dwSrvIP, uSrvPort, NULL);
			if (pNewSource != NULL)
				pNewSource->SetUserName(GetResString(IDS_SERVER_SOURCE));
		}
		else
		{	//	Since we may received multiple search source UDP results we have to "consume" all data of that packet
			bSkip = true;
			continue;
		}
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	NewSrcPartsInfo & UpdateAvailablePartsCount & CompleteSourcesCount merged (CPU load)
void CPartFile::NewSrcPartsInfo()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	EnumPartFileStatuses eStatus = GetStatus();

//	Don't update the source related info when sources will be removed
	if ((eStatus == PS_STOPPED) || (eStatus == PS_COMPLETING) || (eStatus == PS_COMPLETE))
		return;

//	Cache part count
	uint32		dwPartCount = GetPartCount();

	CUpDownClient			*pSource;
	uint16					uNewCompleteSrcCount = 0;
	CArray<uint16,uint16>	PartFrequencyArray;
	ClientList				clientListCopy;

	PartFrequencyArray.SetSize(dwPartCount);	//	array is zero initialized inside

	GetCopySourceLists(SLM_ALL, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pSource = *cIt;

		uint32		dwSourcePartsCounter = 0;
	//	Count available parts from source
		for (uint32 i = 0; i < dwPartCount; i++)
		{
			if (pSource->IsPartAvailable(i))
			{
				PartFrequencyArray[i]++;
				dwSourcePartsCounter++;
			}
		}
	//	Count full sources
		if (dwSourcePartsCounter == dwPartCount)
			uNewCompleteSrcCount++;
	}

	m_uLastCompleteSrcCount = uNewCompleteSrcCount;

//	Increase size if necessary
	if (static_cast<uint32>(m_srcPartFrequencies.GetSize()) < dwPartCount)
		m_srcPartFrequencies.SetSize(dwPartCount);

	uint32	dwTmp, dwNewMaxSrcPartFrequency = 0;
	uint32	dwNewAvailablePartsCount = 0;
//	Count available parts over all sources
	for (uint32 i = 0; i < dwPartCount; i++)
	{
		dwTmp = static_cast<uint32>(PartFrequencyArray[i]);
		m_srcPartFrequencies[i] = static_cast<uint16>(dwTmp);

		if (dwTmp != 0)
		{
			dwNewAvailablePartsCount++;
			if (dwTmp > dwNewMaxSrcPartFrequency)
				dwNewMaxSrcPartFrequency = dwTmp;
		}
	}

	m_uMaxSrcPartFrequency = static_cast<uint16>(dwNewMaxSrcPartFrequency);
	m_dwAvailablePartsCount = dwNewAvailablePartsCount;

	if (dwNewAvailablePartsCount == dwPartCount)
	{
		lastseencomplete = CTime::GetCurrentTime();
	}

	UpdateDisplayedInfo();

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Intelligent Chunk Request(ICR)
uint16 CPartFile::GetNextRequiredPart(CUpDownClient *pSource)
{
#ifdef OLD_SOCKETS_ENABLED
	EMULE_TRY

	if (pSource == NULL)
		return 0xFFFF;

	uint32	dwGoodPart = pSource->GetLastDownPartAsked();

	if ((dwGoodPart != 0xFFFF) && (GetGapsInPart(dwGoodPart, NULL, 1) != 0))
	{
//		AddLogLine(LOG_FL_DBG, _T("Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
		return static_cast<uint16>(dwGoodPart);
	}

	const uint32		dwPartCnt = GetPartCount();
	std::vector<uint32> PartsFilledSizeVector(dwPartCnt, NOT_AVAILABLE);	// Mark parts as not available to save CPU load
	uint32				dwNumAvailableNeededParts = 0;
	uint32				i, dwNumPartiallyBlockedParts = 0;

//	Scan for requested chunks in order to find out how much they're filled
	for (i = 0; i < dwPartCnt; i++)
	{
		if (pSource->IsPartAvailable(i))
		{
			if ((PartsFilledSizeVector[i] = GetPartLeftToDLSize(i)) != 0)
				dwNumAvailableNeededParts++;
		}
	}
	if (dwNumAvailableNeededParts == 0)
		return 0xFFFF;

//	Scan DownloadList for Blocked parts
	std::vector<byte>	abyteBlockedParts(dwPartCnt, FREE_TO_DL);
	uint32				dwTmp;

	for (POSITION pos = requestedblocks_list.GetHeadPosition(); pos != NULL;)
	{
		Requested_Block_Struct *pReqBlock = requestedblocks_list.GetNext(pos);

		dwTmp = static_cast<uint32>(pReqBlock->qwStartOffset / PARTSIZE);
		if ((PartsFilledSizeVector[dwTmp] == NOT_AVAILABLE)
			|| (abyteBlockedParts[dwTmp] == PARTIALLY_BLOCKED) || (abyteBlockedParts[dwTmp] == FULLY_BLOCKED))
			continue;
	//	Let's check if all gaps in part were already requested.
		if (GetGapsInPart(dwTmp, NULL, 1) == 0)
		{
		//	If we can't get this part from this client, reduce the count
			if (PartsFilledSizeVector[dwTmp] != 0)
				dwNumAvailableNeededParts--;
		//	No gaps found => fully blocked
			abyteBlockedParts[dwTmp] = FULLY_BLOCKED;
		}
		else
		{
		//	Count the blocked parts only in case if they are available & was not counted before
			dwNumPartiallyBlockedParts++;
			abyteBlockedParts[dwTmp] = PARTIALLY_BLOCKED;
		}
	}

//	All arrays/lists self-destruct in their destructors on return
	std::vector<uint32>	adwRareParts(dwPartCnt);	// Priority 2
	uint32				adwMovieParts[3];			// Priority 1 => only first+last parts
	std::vector<uint32>	adwRandomParts(dwPartCnt);	// Priority 4
	const uint32		dwPartCnt1 = dwPartCnt - 1, dwLastPartSize = GetLastPartSize();
	const uint32		dwPreviewMode = GetMovieMode();
//	Mode 0=NoPreview, 1=AVI(1F,1L), 4=MPG(1F), 5=MPG(2F), 7=AVI(1F,2L) F=First,L=Last

//	Define condition of rareness
//	Reduce this threshold for low number of sources to avoid downloading of the same part from several sources
	uint32		dwRarestPart = (m_uMaxSrcPartFrequency > 11) ? 4 : (m_uMaxSrcPartFrequency / 4 + 1);

//	Define a shortest-to-complete condition, cause it will be inverted if all needed parts are downloaded
	const bool	bShortestToComplete = (dwNumAvailableNeededParts > dwNumPartiallyBlockedParts);
	byte		byteMostCompletedRareState = PARTIALLY_BLOCKED;

	uint32		dwMostCompletedRarePartIdx = 0, dwMostCompletedPartIdx = 0;
	uint32		dwMostCompletedRarePartSz = PARTSZ32, dwMoviePartsCnt = 0;
	uint32		dwMostCompletedPartSz = (bShortestToComplete) ? PARTSZ32 : 0;
	uint32		dwRareRank = ~0u, dwRandomRank = ~0u, dwRareVirginCnt = 0;
	uint32		dwRareFilledRank = 0, dwRarePartCnt = 0, dwRandomPartCnt = 0;

//	For each part in the part file...
	for (i = 0; i < dwPartCnt; i++)
	{
	//	If the part is available and it hasn't been completed...
		if (PartsFilledSizeVector[i] != NOT_AVAILABLE && abyteBlockedParts[i] != FULLY_BLOCKED && PartsFilledSizeVector[i] != 0)
		{
		//	------------------------ Rare Parts -------------------------
			if (dwRarestPart >= (dwTmp = m_srcPartFrequencies[i]))
			{
				if (PartsFilledSizeVector[i] == PARTSZ32 || ((i == dwPartCnt1) && PartsFilledSizeVector[i] == dwLastPartSize))
				{
					if (dwTmp <= dwRareRank)	// Select the rarest parts
					{
						if (dwTmp < dwRareRank)
						{
							dwRareRank = dwTmp;
							dwRarePartCnt = 0;
							dwRareVirginCnt = 0;
						}
						adwRareParts[dwRarePartCnt++] = i;
					//	Calculate a number of untouched rare parts (which aren't currently requested)
						if (abyteBlockedParts[i] != PARTIALLY_BLOCKED)
							dwRareVirginCnt++;
					}
				}
			//	There can be situations when several rare sources are available for downloading,
			//	they can have the same rare parts, better to start downloading of different rare parts
			//	than download one from several sources. Besides selecting the shortest part to complete,
			//	we also take into account is this part already requested from another rare source or not
				else if ( ((byteMostCompletedRareState == abyteBlockedParts[i]) && (PartsFilledSizeVector[i] < dwMostCompletedRarePartSz)) ||
					((byteMostCompletedRareState != abyteBlockedParts[i]) && (byteMostCompletedRareState == PARTIALLY_BLOCKED)) )
				{
					byteMostCompletedRareState = abyteBlockedParts[i];
					dwMostCompletedRarePartSz = PartsFilledSizeVector[i];
					dwMostCompletedRarePartIdx = i;
					dwRareFilledRank = dwTmp;
				}
			}
		//	--------------------------- Movie or Archive ---------------------------
			switch (dwPreviewMode)
			{
				case 7:	// AVI(1F,2L) downloading sequence: chunk 0, last, next to last
					if ((i == 0) || ((dwPartCnt > 2) && (i == dwPartCnt - 2)))
						adwMovieParts[dwMoviePartsCnt++] = i;
					if (dwPartCnt > 2 && (i == dwPartCnt - 1))
					{
						if ((dwMoviePartsCnt != 0) && (adwMovieParts[dwMoviePartsCnt - 1] != 0))
						{
							adwMovieParts[dwMoviePartsCnt] = adwMovieParts[dwMoviePartsCnt - 1];
							adwMovieParts[dwMoviePartsCnt - 1] = i;
							dwMoviePartsCnt++;
						}
						else
							adwMovieParts[dwMoviePartsCnt++] = i;
					}
					break;

				case 5:	// MPG(2F) downloading sequence: chunk 0, chunk 1
					if ((i == 0) || ((i == 1) && (dwPartCnt > 1)))
						adwMovieParts[dwMoviePartsCnt++] = i;
					break;

				case 1:	// AVI(1F,1L) downloading sequence: chunk 0, last chunk
					if (dwPartCnt > 1 && (i == dwPartCnt1))
						adwMovieParts[dwMoviePartsCnt++] = i;
				case 4:	// MPG(1F)
					if (i == 0)
						adwMovieParts[dwMoviePartsCnt++] = 0;
			}
		//	--------------------- widespreaded parts ---------------------
		//	Check blocked parts - don't download already downloading parts unless there's something else
			if ((abyteBlockedParts[i] == PARTIALLY_BLOCKED) && bShortestToComplete)
				continue;

			if (PartsFilledSizeVector[i] == PARTSZ32 || ((i == dwPartCnt1) && PartsFilledSizeVector[i] == dwLastPartSize))
			{
			//	Fresh part
				if ((dwTmp = m_srcPartFrequencies[i]) <= dwRandomRank)
				{
					if (dwTmp < dwRandomRank)	// Select the rarest parts among them
					{
						dwRandomRank = dwTmp;
						dwRandomPartCnt = 0;
					}
					adwRandomParts[dwRandomPartCnt++] = i;
				}
			}
			else
			{
			//	Invert condition shortest-to-complete condition if all parts are partially blocked:
			//	1) select the most completed part if there're chunks not in downloading state
			//	2) select the most incomplete part if all available parts from this source're in downloading state
				if (!((PartsFilledSizeVector[i] < dwMostCompletedPartSz) ^ bShortestToComplete))
				{
					dwMostCompletedPartIdx = i;
					dwMostCompletedPartSz = PartsFilledSizeVector[i];
				}
			}
		}
	}

//	Select final result
//	---------------------------------- Movies Part  -----------------------------------------------------
//	The preview parts have highest priority in order to provide the user information about the file as soon as possible
//	This will lead to the faster decision about futher download
	if (dwMoviePartsCnt != 0)
	{
	//	Select the most appropriate part (for the case when all preview parts are already in downloading)
		dwGoodPart = adwMovieParts[0];
	//	Avoid several downloads for the same part if there's a preview part which isn't in downloading state yet
		i = 0;
		do
		{
			dwTmp = adwMovieParts[i];
			if (abyteBlockedParts[dwTmp] != PARTIALLY_BLOCKED)
			{
				dwGoodPart = dwTmp;
				break;
			}
		} while (++i < dwMoviePartsCnt);
//		AddLogLine(LOG_FL_DBG, _T("Priority 1 (Preview part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
	}
//	---------------------------------- Rare Parts ------------------------------------------------------
	else if ((dwRarePartCnt != 0) || (dwRareFilledRank != 0))
	{
	//	Download an incomplete part first, but if there're more than one source for an incomplete part
	//	and there's a fresh part with only one source, start downloading of the unique fresh part;
	//	Also if an incomplete part is currently being downloading and there is a chance
	//	to start download of fresh rare part, choose the fresh one
		if ((dwRareFilledRank != 0) && ( (dwRareFilledRank == 1) || (dwRarePartCnt == 0) ||
			((dwRareRank != 1) && (abyteBlockedParts[dwMostCompletedRarePartIdx] != PARTIALLY_BLOCKED)) ) )
		{
			dwGoodPart = dwMostCompletedRarePartIdx;
//			AddLogLine(LOG_FL_DBG, _T("Priority 2 (Rarest unfinished part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
		}
		else
		{
		//	If there is only one rare part, then take it, otherwise take random one
			if (dwRarePartCnt == 1)
				dwTmp = 0;
			else
			{
			//	There can be situations when several rare sources are available for downloading,
			//	they can have the same rare parts, better to start downloading of different rare parts
			//	than download one from several sources. Also due to reply delay and data buffering,
			//	a part can be seen as untouched (PartsFilledSizeVector[i] == PARTSIZE), but as
			//	the download request was already sent, this part also should be treated as occupied
				if ((dwRarePartCnt == dwRareVirginCnt) || (dwRareVirginCnt == 0))
					dwTmp = static_cast<uint32>(rand() * (dwRarePartCnt - 1) + RAND_MAX / 2) / RAND_MAX;
				else
				{
					dwTmp = static_cast<uint32>(rand() * (dwRareVirginCnt - 1) + RAND_MAX / 2) / RAND_MAX;
					for (i = 0;; i++)
					{
						if ((abyteBlockedParts[adwRareParts[i]] != PARTIALLY_BLOCKED) && (static_cast<int>(--dwTmp) < 0))
						{
							dwTmp = i;
							break;
						}
					}
				}
			}
			dwGoodPart = adwRareParts[dwTmp];
//			AddLogLine(LOG_FL_DBG, _T("Priority 3 (Rarest unrequested part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
		}
	}
//	--------------------------------------- Requested ----------------------------------------------------
//	Try to complete an UnfinishedPart and MostDownloaded as soon as possible to become a new source
//	it doesn't matter which one to download, if there are same filled parts.
	else if ((dwMostCompletedPartSz != PARTSZ32) && (dwMostCompletedPartSz != 0))
	{
		dwGoodPart = dwMostCompletedPartIdx;
//		AddLogLine(LOG_FL_DBG, _T("Priority 4 (Widespread unfinished part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
	}
//	-------------------------------- Unrequested & Random -------------------------------------------------
	else if (dwRandomPartCnt != 0)
	{
		if (dwRandomPartCnt == 1)
			dwTmp = 0;
		else
			dwTmp = static_cast<uint32>(rand() * (dwRandomPartCnt - 1) + RAND_MAX / 2) / RAND_MAX;
		dwGoodPart = adwRandomParts[dwTmp];
//		AddLogLine(LOG_FL_DBG, _T("Priority 5 (Widespread unrequested part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
	}
	else
	{
		dwGoodPart = 0xFFFF;
	}

/*
	CString strDebug;

	strDebug.Format(_T("ICR-Test: File: %s, A-parts : %u, BP-Parts %u. Choosen Part: %u"),
						GetFileName(), dwNumAvailableNeededParts, dwNumPartiallyBlockedParts, dwGoodPart);
	if (dwGoodPart < dwPartCnt)
	{
		strDebug.AppendFormat(_T(", P-Freq: %u, blocked %s"), m_srcPartFrequencies[dwGoodPart], ((abyteBlockedParts[dwGoodPart] == PARTIALLY_BLOCKED)? _T("yes"):_T("no")));
	}
	AddLogLine(LOG_FL_DBG, strDebug);
*/

	return static_cast<uint16>(dwGoodPart);

	EMULE_CATCH
#endif //OLD_SOCKETS_ENABLED
	return 0xFFFF;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemoveBlockFromList(const uint64 &qwStart, const uint64 &qwEnd)
{
	EMULE_TRY

	POSITION pos1, pos2;
	for (pos1 = requestedblocks_list.GetHeadPosition(); (pos2 = pos1) != NULL;)
	{
		Requested_Block_Struct	*pReqBlock = requestedblocks_list.GetNext(pos1);

		if ((pReqBlock->qwStartOffset <= qwStart) && (pReqBlock->qwEndOffset >= qwEnd))
			requestedblocks_list.RemoveAt(pos2);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemoveAllRequestedBlocks(void)
{
	EMULE_TRY

	requestedblocks_list.RemoveAll();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::CompleteFile(bool bIsHashingDone)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	StopFile(false);

//	Show completing instead of paused
	SetStatus(PS_COMPLETING);

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	UpdateDisplayedInfo();

//	If the part file isn't already hashed...
	if (!bIsHashingDone)
	{
	//	Create a thread to hash the part file in the background
		m_dwDataRate = 0;

		CString	partFileNameBase = m_strPartMetFileName.Left(m_strPartMetFileName.GetLength() - 4);
		CHashFileThread	*addFileThread;

		addFileThread = (CHashFileThread*)AfxBeginThread( RUNTIME_CLASS(CHashFileThread),
		                THREAD_PRIORITY_BELOW_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(),
		                0,
		                CREATE_SUSPENDED );
		addFileThread->SetValues(false, m_strTempDir, partFileNameBase, this);
		addFileThread->ResumeThread();
		return;
	}
	else
	{
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC)CompleteThreadProc, this, THREAD_PRIORITY_BELOW_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(), 0, 0);

		if (pThread == NULL)
			throw CString(_T("error creating file complete thread"));
	}
	GetAvgDataRate(true);

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	UpdateDisplayedInfo();
	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
static void GenerateNewFileName(const CString& outputDir, CString& newname)
{
	ASSERT(!newname.IsEmpty());

	int namecount = 0;

	TCHAR p_fname[_MAX_FNAME];
	TCHAR p_fext[_MAX_EXT];
	_tsplitpath(newname, NULL, NULL, p_fname, p_fext);

	CString fname(p_fname);
	CString fext(p_fext);

//	Search for matching ()s and check if it contains a number inside
	if (fname.Right(1) == _T(')'))
	{
		int ll = fname.GetLength();
		int ob = fname.ReverseFind(_T('('));
	//	Check for ) existence or () situation
		if (ob != -1 && ob + 2 != ll)
		{
			bool found = true;
			for (int i = ob + 1; i < ll - 1; i++)
			{
			//	Check for digits inside brackets
				if (!_istdigit(fname[i]))
				{
					found = false;
					break;
				}
			}
			if (found)
			{
				namecount = _ttoi(fname.Mid(ob + 1, ll - ob - 2));
				fname.Truncate(ob);
			}
		}
	}

	do
	{
		namecount++;
		newname.Format(_T("%s\\%s(%d)%s"), outputDir, fname, namecount, fext);
	}
	while (PathFileExists(newname));
}

//	Use threads for file completion
BOOL CPartFile::PerformFileComplete(void)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

//	Removes any old fakes.rar that may exist in shared directories before completing the newest fakes.rar
	if (IsFakesDotRar())
	{
		CStringList	strSharedDirsList;
		CString		strFakesFile;

		strFakesFile.Format(_T("%s\\fakes.rar"), g_App.m_pPrefs->GetIncomingDir());
		if (PathFileExists(strFakesFile))
			if (!::DeleteFile(strFakesFile))
				AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Couldn't delete fakes.rar (%s)"), strFakesFile);


		g_App.m_pPrefs->SharedDirListCopy(&strSharedDirsList);

		for (POSITION pos = strSharedDirsList.GetHeadPosition(); pos != NULL; )
		{
			strFakesFile.Format(_T("%s\\fakes.rar"), strSharedDirsList.GetNext(pos));
			if (PathFileExists(strFakesFile))
				if (!::DeleteFile(strFakesFile))
					AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Couldn't delete fakes.rar (%s)"), strFakesFile);
		}
	}

//	Get current category
	EnumCategories eCatID = GetCatID();

	CString strFullPartFileName(m_strFilePath);	// save .part file name for deletion

	CString newname, strOutputDir = GetOutputDir();
	newname.Format(_T("%s\\%s"), strOutputDir, g_App.StripInvalidFilenameChars(GetFileName()));

//	Create all required directories
	CreateAllDirectories(&strOutputDir);

	bool bRenamed = false;
	if (PathFileExists(newname))
	{
		bRenamed = true;
		GenerateNewFileName(strOutputDir, newname);
	}

//	Save full .met file name for temp. file deletions, because a name is altered before it
	CString	strTempFullName = m_strFullName;

//	Make copy if files are on different partitions and a file isn't small (> 1 Mb)
//	Small files will be copied by system routine which blocks uploading start of the same file
	if ( (_totupper(m_strFilePath[0]) != _totupper(newname[0])) &&
		(m_strFilePath[1] == _T(':') && newname[1] == _T(':')) && (GetFileSize() > 1024ui64 * 1024ui64) )
	{
		bool	bException = false;
		CFile	fInputFile, fOutputFile;
		CString	strTempNew = newname;

		strTempNew += _T(".$$$");
		try
		{
			if ((GetFileSize() > 0xFFFFFFFFui64) && IsFileOnFATVolume(newname))
			{
			//	FAT partition doesn't support file > 4 GB, we check it on completion as
			//	destination directory can be changed several times in several places
				CString	strErr;

				strErr.Format(GetResString(IDS_ERR_COMPLETIONFAILED), newname, GetResString(IDS_ERR_TOOLARGEFILE4FS));
				throw strErr;
			}
		//	We going to write everything into the temporary file at the same place the newname located
		//	and after we finished - rename, this will take care of synchronization problem with SharedFiles
			if ( !fInputFile.Open( m_strFilePath, CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary
			                       | CFile::osSequentialScan ) )
			{
			//	Let's catch to care about closing everything
				throw CString(_T("can't open file for reading (") + m_strFilePath + _T(')'));
			}
			if ( !fOutputFile.Open( strTempNew, CFile::modeWrite | CFile::shareExclusive | CFile::osSequentialScan
								   | CFile::modeCreate ) )
			{
			//	Let's catch to care about closing everything
				throw CString(_T("can't open file for writing (") + strTempNew + _T(')'));
			}

			int		iBlockSize = g_App.m_pPrefs->SlowCompleteBlockSize() * 1024;
			char	*pcBuffer = new char[iBlockSize];
			DWORD	dwRead;

		//	Only one extensive hard drive access at a time to reduce I/O load
			CSingleLock Lock(&g_App.m_csPreventExtensiveHDAccess, TRUE);

		//	Most of the work done here
		//	just copy the file data from one to another
			do
			{
				dwRead = fInputFile.Read(pcBuffer, iBlockSize);
				fOutputFile.Write(pcBuffer, dwRead);
			//	Release the CPU for other processes
				Sleep(0);
			}
			while (dwRead > 0);

			Lock.Unlock();
			delete []pcBuffer;

			fInputFile.Close();
			fOutputFile.Close();

		//	Rename temporary file back to normal name
			if (_trename(strTempNew, newname))
			{
			//	Lets catch to care about closing everything
				throw CString(_T("renaming of completed file failed"));
			}

		//	Synchronization with reading upload thread
			CSingleLock lockComplete(&m_csFileCompletion, TRUE);

			SetPath(strOutputDir);
			SetFilePath(newname);
			m_bPaused = false;
			m_eStatus = PS_COMPLETE;
			m_uSrcA4AF = 0;

			lockComplete.Unlock();

		//	Update GUI after synchronization is released
			UpdateGUIAfterStateChange();

		//	Close permanent handles
			try
			{
				ClosePartFile();
			}
			catch (CFileException *error)
			{
				OUTPUT_DEBUG_TRACE();
				AddLogLine(LOG_FL_DBG, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
				error->Delete();
			}
			::DeleteFile(strFullPartFileName);
		}
	//	Check for exception that will be thrown by "new"
		catch (CMemoryException * error)
		{
			error->Delete();
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_OUTMEM);
			bException = true;
		}
		catch (CString str)
		{
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, str);
			bException = true;
		}
		catch (CException *error)
		{
		//	Sending message for erroneous file
			CString MessageText;
			MessageText.Format(GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), GetErrorMessage(error));
			g_App.m_pMDlg->SendMail(MessageText, g_App.m_pPrefs->GetNotifierPopOnImportantError(), g_App.m_pPrefs->IsSMTPWarningEnabled());
			g_App.m_pMDlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_App.m_pPrefs->GetNotifierPopOnImportantError());
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_COMPLETIONFAILED, GetFileName(), GetErrorMessage(error));
			error->Delete();
			bException = true;
		}
		if (bException)
		{
		//	File should be closed to make Initialization possible
			try
			{
				ClosePartFile();
			}
			catch (CFileException *error)
			{
				OUTPUT_DEBUG_TRACE();
				AddLogLine(LOG_FL_DBG, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
				error->Delete();
			}

			if (fOutputFile.m_hFile != INVALID_HANDLE_VALUE)
				fOutputFile.Close();
		//	Delete temporary file if it still exists
			::DeleteFile(strTempNew);

			m_bPaused = true;
			SetStatus(PS_ERROR);
			AddLogLine(LOG_RGB_ERROR, IDS_ERR_COMPLETIONFAILED2);
		//	If fInputFile is still opened, it will be closed here in its destructor
			return FALSE;
		}
	}
	else
	{
	//	Synchronization with reading upload thread
		CSingleLock lockComplete(&m_csFileCompletion, TRUE);

	//	Close permanent handles
		try
		{
			ClosePartFile();
		}
		catch (CFileException *error)
		{
			OUTPUT_DEBUG_TRACE();
			AddLogLine(LOG_FL_DBG, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
			error->Delete();
		}

		if (_trename(m_strFilePath, newname))
		{
			lockComplete.Unlock();

		//	Sending message for erroneous file
			CString MessageText;
			MessageText.Format(GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), _tcserror(errno));
			g_App.m_pMDlg->SendMail(MessageText, g_App.m_pPrefs->GetNotifierPopOnImportantError(), g_App.m_pPrefs->IsSMTPWarningEnabled());
			g_App.m_pMDlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_App.m_pPrefs->GetNotifierPopOnImportantError());
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_COMPLETIONFAILED, GetFileName(), _tcserror(errno));
			AddLogLine(LOG_RGB_ERROR, IDS_ERR_COMPLETIONFAILED2);
			m_bPaused = true;
			SetStatus(PS_ERROR);
			return FALSE;
		}

		SetPath(strOutputDir);
		SetFilePath(newname);
		m_bPaused = false;
		m_eStatus = PS_COMPLETE;
		m_uSrcA4AF = 0;

		lockComplete.Unlock();

	//	Update GUI after synchronization is released
		UpdateGUIAfterStateChange();
	}

//	To have the accurate date stored in known.met we have to update the 'date' of a just completed file.
//	If we don't update the file date here (after committing the file and before adding the record to known.met),
//	that file will be rehashed at next startup and there would also be a duplicate entry (hash+size) in known.met because of different file date!
	GetAdjustedFileTime(newname, &m_timetLastWriteDate);

	if (_tremove(strTempFullName))
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strTempFullName);

	CString	strFileToRemove;

//	Remove .bak file
	strFileToRemove = strTempFullName + _T(".bak");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove .bad file
	strFileToRemove = strTempFullName + _T(".bad");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove .settings file
	strFileToRemove = strFullPartFileName + _T(".settings");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove .txtsrc file
	strFileToRemove = strFullPartFileName + _T(".txtsrc");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove the stats file
	strFileToRemove = strFullPartFileName + _T(".stats");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Change AutoPriority to NORMAL when UAP is disabled
	if (IsULAutoPrioritized() && !g_App.m_pPrefs->IsUAPEnabled())
	{
		SetAutoULPriority(false);
		SetULPriority(PR_NORMAL);
	}

	UpdateDisplayedInfo();

	CCat		*pCat = CCat::GetCatByID(GetCatID());
	CString		strCategory = (pCat != NULL) ? pCat->GetTitle() : GetResString(IDS_CAT_UNCATEGORIZED);

	AddLogLine(LOG_FL_SBAR | LOG_RGB_SUCCESS, IDS_DOWNLOADDONE, GetFileName(), strCategory);

//	Sending message for completed file
	CString MessageText;
	MessageText.Format(GetResString(IDS_TBN_DOWNLOADDONE), GetFileName(), strCategory);
	g_App.m_pMDlg->SendMail(MessageText, g_App.m_pPrefs->GetUseDownloadNotifier(), g_App.m_pPrefs->IsSMTPInfoEnabled());
	g_App.m_pMDlg->ShowNotifier(MessageText, TBN_DLOAD, false, g_App.m_pPrefs->GetUseDownloadNotifier());
	if (bRenamed)
		AddLogLine(LOG_FL_SBAR, IDS_DOWNLOADRENAMED, _tcsrchr(newname, _T('\\')) + 1);
	g_App.m_pKnownFilesList->SafeAddKnownFile(this);
	g_App.m_pDownloadQueue->RemoveFile(this);
	UpdateDisplayedInfo();

#ifdef OLD_SOCKETS_ENABLED
	g_App.m_pMMServer->AddFinishedFile(this);
#endif //OLD_SOCKETS_ENABLED

//	Starts next paused file
	if (g_App.m_pPrefs->DownloadPausedOnComplete() && !IsFakesDotRar())
	{
		g_App.m_pDownloadQueue->StartNextFile(eCatID);
	}

	g_App.m_pPrefs->Add2DownCompletedFiles();			// Increments cumDownCompletedFiles in prefs struct
	g_App.m_pPrefs->Add2DownSessionCompletedFiles(); 	// Increments sesDownCompletedFiles in prefs struct

//	Republish a file on the server to update server complete sources counter
	g_App.m_pSharedFilesList->RepublishFile(this, SRV_TCPFLG_COMPRESSION/*check feature support*/);

	if (GetPath() != g_App.m_pPrefs->GetIncomingDir())
	{
		if (g_App.m_pPrefs->SharedDirListCheckAndAdd(GetPath(), true))
		{
		//	New path was added to the list, scan for files
			g_App.m_pSharedFilesList->Reload();
		}
	}

	if (g_App.m_pPrefs->IsAutoClearCompleted())
	{
		g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetRedraw(false);
		g_App.m_pDownloadList->ClearCompleted(this);
		g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetRedraw(true);
	}

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

//	Scan completed files for viruses
	if (g_App.m_pPrefs->IsAVEnabled() &&
		g_App.m_pPrefs->IsAVScanCompleted() && !g_App.m_pPrefs->GetAVPath().IsEmpty())
	{
		strTempFullName.Format(_T("%s \"%s\""), g_App.m_pPrefs->GetAVParams(), m_strFilePath);
		ShellExecute(NULL, _T("open"), g_App.m_pPrefs->GetAVPath(), strTempFullName, NULL, SW_SHOW);
	}

//	FakeCheck
	if (IsFakesDotRar())
	{
		CFakeCheck	*pFakeCheck = g_App.m_pFakeCheck;
		CString		strFakesDotDatPath = g_App.m_pPrefs->GetConfigDir() + _T("fakes.dat");
		CString		strBackupFilePath(strFakesDotDatPath);

		strBackupFilePath += _T(".bak");

	//	Backups fakes.dat
		::MoveFile(strFakesDotDatPath, strBackupFilePath);

		if (pFakeCheck->ExtractRARArchive(m_strFilePath, g_App.m_pPrefs->GetConfigDir()))
		{
			g_App.AddLogLine(LOG_FL_SBAR | LOG_RGB_SUCCESS, IDS_FAKE_SUCCESS_UPDATE, g_App.m_pPrefs->GetFakesDatVersion(), g_App.m_pPrefs->GetDLingFakeListVersion());
			g_App.m_pPrefs->SetFakesDatVersion(g_App.m_pPrefs->GetDLingFakeListVersion());
			g_App.m_pPrefs->SetDLingFakeListVersion(0);
			g_App.m_pPrefs->SetDLingFakeListLink(_T(""));
			pFakeCheck->LoadFromDatFile();
			::DeleteFile(strBackupFilePath);
		}
		else
		{
		//	The extraction was unsuccessful, so we restore fakes.dat
			::DeleteFile(strFakesDotDatPath);
			::MoveFile(strBackupFilePath, strFakesDotDatPath);
		}

		CKnownFile	*pThisFile = g_App.m_pSharedFilesList->GetFileByID(GetFileHash());

		if (pThisFile != NULL)
		{
			pThisFile->SetAutoULPriority(false);
			pThisFile->SetULPriority(PR_RELEASE);
			g_App.m_pSharedFilesList->Reload();
		}
	}

	return TRUE;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemoveAllSources()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	CUpDownClient	*pRemoveSrc;
	ClientList		clientListCopy;

	GetCopySourceLists(SLM_ALL, &clientListCopy, true);

	m_uMaxSrcPartFrequency = 0;
	m_dwAvailablePartsCount = 0;
	for (uint32 i = 0; i < GetPartCount(); i++)
		m_srcPartFrequencies[i] = 0;

	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pRemoveSrc = *cIt;

	//	Transfer sources to other downloading files if possible
		if (!pRemoveSrc->SwapToAnotherFile(NULL, A4AF_REMOVE))
		{
		//	If the switching wasn't successful we remove the source from the download queue
			if ((pRemoveSrc->GetUploadState() == US_NONE) && (pRemoveSrc->GetChatState() == MS_NONE))
				delete pRemoveSrc;
			else
				g_App.m_pDownloadQueue->RemoveSource(pRemoveSrc);
		}
		else
		{
		//	If the switching was successful we need to remove the entry from graphical list
			g_App.m_pDownloadList->RemoveSource(pRemoveSrc, this);
		}
	}

//	Remove A4AF entries from graphical list & anotherRequestList
	if (!m_A4AFSourceLists.empty())
	{
		GetCopyA4AFSourceList(&clientListCopy, true);
		for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
		{
			pRemoveSrc = *cIt;
			g_App.m_pDownloadList->RemoveSource(pRemoveSrc, this);
			pRemoveSrc->RemoveRequestForAnotherFile(this);
		}
	}

	m_uNumTransferringSrcs = 0;
	m_uSrcNNP = 0;
	m_uSrcOnQueue = 0;
	m_uSrcHighQR = 0;
	m_uSrcConnecting = 0;
	m_uSrcWaitForFileReq = 0;
	m_uSrcConnected = 0;
	m_uSrcConnViaServer = 0;
	m_uSrcLowToLow = 0;
	m_uSrcLowIDOnOtherServer = 0;
	m_uSrcQueueFull = 0;
	m_uSrcA4AF = 0;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::DeleteFile()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	ASSERT (!m_bPreviewing);

	CString	strFileToRemove;

	GetResString(&strFileToRemove, IDS_CANCELLED);
	strFileToRemove += _T(": %s");
	AddLogLine(0, strFileToRemove, GetFileName());

	m_bIsBeingDeleted = true;

	StopFile();

	ClosePartFile();

	if (_tremove(m_strFullName))
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, m_strFullName);

	if (_tremove(m_strFilePath))
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, m_strFilePath);

	CString	strFilePath = RemoveFileExtension(m_strFullName);

//	Remove .bak file
	strFileToRemove = m_strFullName + _T(".bak");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove .bad file
	strFileToRemove = m_strFullName + _T(".bad");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove .settings file
	strFileToRemove = strFilePath + _T(".settings");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove .txtsrc file
	strFileToRemove = strFilePath + _T(".txtsrc");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	Remove the stats file
	strFileToRemove = strFilePath + _T(".stats");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);

//	File properties get deleted inside one of these calls now...
	g_App.m_pSharedFilesList->RemoveFile(this);
	g_App.m_pDownloadQueue->RemoveFile(this);
	g_App.m_pDownloadList->RemoveFile(this);

	delete this;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::HashSinglePart(uint32 dwPartNum)
{
#ifndef NEW_SOCKETS_ENGINE
	CFile	*pFile = NULL;

	EMULE_TRY

	UINT dwResErrStrID;
	uint32 dwPartCnt = static_cast<uint32>(GetPartCount());

	if ((GetHashCount() <= dwPartNum) && (dwPartCnt > 1))
		dwResErrStrID = IDS_ERR_HASHERRORWARNING;
	else if ((dwPartCnt != 1) && (GetPartHash(dwPartNum) == NULL))
		dwResErrStrID = IDS_ERR_INCOMPLETEHASH;
	else
	{
		uchar	hashresult[16];

	//	Duplicate part file read handle to eliminate read collisions
		pFile = m_hPartFileRead.Duplicate();
		pFile->Seek(static_cast<uint64>(dwPartNum) * PARTSIZE, CFile::begin);

		CreateHashFromFile(pFile, GetPartSize(dwPartNum), hashresult);

	//	File handle is closed in destructor
		delete pFile;
		pFile = NULL;

		return (md4cmp(hashresult, (GetFileSize() >= PARTSIZE) ? GetPartHash(dwPartNum) : m_fileHash) == 0) ? true : false;
	}

	AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, dwResErrStrID, GetFileName());
	this->m_bHashSetNeeded = true;
	return true;

	EMULE_CATCH

	delete pFile;
#endif //NEW_SOCKETS_ENGINE
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsArchive() const
{
	return (ED2KFT_ARCHIVE == GetFileType());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::SetPriority(byte byteNewPriority, bool bSaveSettings /*= true*/)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	priority = byteNewPriority;
	g_App.m_pDownloadQueue->SortByPriority();
	UpdateDisplayedInfo();
	if (bSaveSettings)
		SavePartFile();

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::StopFile(bool bUpdateDisplay /* TRUE */)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING)
		return;

	ClientList	DownloadingListCopy;

//	Change status as soon as possible in order to prevent
//	unpredictable behaviour	during the source removal
	m_bPaused = true;
	m_bStopped = true;

//	Need to tell any connected clients to stop sending the file
//	and send downloading clients a cancel (NOT if completing)
	GetCopySourceList(DS_DOWNLOADING, &DownloadingListCopy, true);
	for (ClientList::const_iterator cIt = DownloadingListCopy.begin(); cIt != DownloadingListCopy.end(); cIt++)
	{
		CUpDownClient	*pSource = *cIt;

#ifdef OLD_SOCKETS_ENABLED
		pSource->SendCancelTransfer();
		pSource->SetDownloadState(DS_ONQUEUE);
#endif //OLD_SOCKETS_ENABLED
	}

//	Reset A4AF auto file
	if (g_App.m_pDownloadQueue->GetA4AFAutoFile() == this)
	{
		g_App.m_pDownloadQueue->SetA4AFAutoFile(NULL);
	}

	RemoveAllSources();

	m_dwDataRate = 0;

//	Save info to disk
	if (!m_bIsBeingDeleted)
	{
		FlushBuffer();
		SavePartFile();
		SaveSettingsFile();
	}

//	Update GUI information (if the file was stopped for completing GUI will be updated in CompleteFile)
	if (bUpdateDisplay)
	{
		UpdateDisplayedInfo();
		g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::PauseFile()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if ((m_eStatus == PS_COMPLETE) || (m_eStatus == PS_COMPLETING))
		return;

	CUpDownClient	*pSource;
	ClientList		clientListCopy;

//	Reset A4AF auto file
	if (g_App.m_pDownloadQueue->GetA4AFAutoFile() == this)
	{
		g_App.m_pDownloadQueue->SetA4AFAutoFile(NULL);
	}

//	Send CANCEL to downloading clients
	GetCopySourceList(DS_DOWNLOADING, &clientListCopy, true);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pSource = *cIt;
		pSource->SendCancelTransfer();
		pSource->SetDownloadState(DS_ONQUEUE);
	}
//	At this point nobody is downloading so we can try to swap sources
	GetCopySourceLists(SLM_ALL, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pSource = *cIt;
		pSource->SwapToAnotherFile(NULL, A4AF_IGNORE_TIME_LIMIT);
	}

	m_bPaused = true;
	m_bStopped = false;

	UpdateGUIAfterStateChange();

	m_dwDataRate = 0;
	m_uNumTransferringSrcs = 0;
	UpdateDisplayedInfo();

	if (!m_bIsBeingDeleted)
	{
		SavePartFile();
		SaveSettingsFile();
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::ResumeFile()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING)
		return;

//	Check if chunks are availible & set status
	EnumPartFileStatuses	eNewStatus = PS_EMPTY;

	for (uint32 ui = 0; ui < GetPartCount(); ui++)
	{
		if (IsPartComplete(ui))
		{
			eNewStatus = PS_READY;
			break;
		}
	}
	SetStatus(eNewStatus);

	if (GetStartTimeReset())
	{
	//	Needed for files which are paused after adding or loading
		m_SessionStartTime = CTime::GetCurrentTime();
		SetStartTimeReset(false);
	}

	m_bPaused = false;
	m_bStopped = false;
	m_dwLastFileSourcesRequestTime = 0;
	SavePartFile();
	SaveSettingsFile();
	UpdateDisplayedInfo();

	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Used to load initial sources from Server right after connect
void CPartFile::GetSourcesAfterServerConnect()
{
	EMULE_TRY

	if (m_dwLastFileSourcesRequestTime > 0)
	{
		m_dwLastFileSourcesRequestTime = 0;
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CPartFile::GetPartFileStatus()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	UINT		dwResStrId;

	if (GetTransferringSrcCount() > 0)
		dwResStrId = IDS_DOWNLOADING;
	else
		dwResStrId = (!IsStalled()) ? IDS_WAITING : IDS_STALLED;

	switch (GetStatus())
	{
		case PS_HASHING:
		case PS_WAITINGFORHASH:
			dwResStrId = IDS_HASHING;
			break;
		case PS_COMPLETING:
			dwResStrId = IDS_COMPLETING;
			break;
		case PS_COMPLETE:
			dwResStrId = IDS_COMPLETE;
			break;
		case PS_PAUSED:
			dwResStrId = IDS_PAUSED;
			break;
		case PS_ERROR:
			dwResStrId = IDS_ERRORLIKE;
			break;
		case PS_STOPPED:
			dwResStrId = IDS_STOPPED;
			break;
	}
	return GetResString(dwResStrId);

	EMULE_CATCH

#endif //NEW_SOCKETS_ENGINE
	return _T("");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CPartFile::GetPartFileStatusID() const
{
	EMULE_TRY

	int	iFileStatus, iStatus = 0;

	if (GetTransferringSrcCount() > 0)
		iStatus = PS_DOWNLOADING;
	else
		iStatus = (!IsStalled()) ? PS_WAITINGFORSOURCE : PS_STALLED;

	iFileStatus = GetStatus();
	switch (iFileStatus)
	{
		case PS_HASHING:
		case PS_WAITINGFORHASH:
		case PS_COMPLETING:
		case PS_COMPLETE:
		case PS_PAUSED:
		case PS_ERROR:
		case PS_STOPPED:
			iStatus = iFileStatus;
			break;
	}
	return iStatus;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CPartFile::GetPartFileStatusRang()
{
	EMULE_TRY

//	Sort order is Complete - Completing - Downloading - Waiting - Stalled - Paused - Hashing - Stopped - Errors
	int status = 2;
	if (GetTransferringSrcCount() == 0)
		status = (!IsStalled()) ? 3 : 4;

	switch (GetStatus())
	{
		case PS_HASHING:
		case PS_WAITINGFORHASH:
			status = 6;
			break;
		case PS_COMPLETING:
			status = 1;
			break;
		case PS_COMPLETE:
			status = 0;
			break;
		case PS_PAUSED:
			status = 5;
			break;
		case PS_STOPPED:
			status = 7;
			break;
		case PS_ERROR:
			status = 8;
			break;
	}
	return status;

	EMULE_CATCH

	return 1;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
sint32 CPartFile::GetTimeRemaining(bool bAverage /*=false*/)
{
	uint32	dwDataRate = (bAverage) ? GetAvgDataRate() : GetDataRate();
	sint32	iTimeRemaining;

	iTimeRemaining = (dwDataRate != 0) ? static_cast<sint32>((GetFileSize() - GetCompletedSize()) / static_cast<uint64>(dwDataRate)) : -1;
	return ((iTimeRemaining > 0 && iTimeRemaining <= 8640000 /*100 days*/) ? iTimeRemaining : -1);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetAvgDataRate() recalculates the average bytes/second for the session. It stores the
//	average in 'm_AvgDataRate' as well as returning it.
uint32 CPartFile::GetAvgDataRate(bool bUpdated /*=false*/)
{
	EMULE_TRY

	if (bUpdated)
	{
		CTimeSpan	timeSpan;

	//	Calc on last FlushBuffer() to keep sessionstats for completed files
		if ((m_eStatus == PS_COMPLETE) || (m_eStatus == PS_COMPLETING))
			timeSpan = GetFlushTimeSpan();
		else
		{
		//	TODO: Modify to use time since first data
			timeSpan = GetSessionTimeSpan();
		}

	//	Delay 1st calculation a bit & dont use datarate for balancing (peak-stopper?)
		uint32	dwSecs = static_cast<uint32>(timeSpan.GetTotalSeconds());

		if (dwSecs > 10)
			m_AvgDataRate = static_cast<uint32>(GetSessionTransferred() / static_cast<uint64>(dwSecs));
		else
			m_AvgDataRate = 0;
	}

	EMULE_CATCH
	return m_AvgDataRate;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::PreviewFile()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (IsArchivePreviewable())
	{
		if ((!m_bRecoveringArchive) && (!m_bPreviewing))
			CArchiveRecovery::recover(this);
		return;
	}

	if (!PreviewAvailable())
		return;

	if (g_App.m_pPrefs->BackupPreview())
	{
		m_bPreviewing = true;
		CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
		pThread->SetValues(this, g_App.m_pPrefs->GetVideoPlayer(), g_App.m_pPrefs->GetVideoPlayerArgs());
		pThread->ResumeThread();
	}
	else
	{
		CString strLine(m_strFilePath);
		CString strPlayer(g_App.m_pPrefs->GetVideoPlayer());

	//	If path has spaces use quotes
		if (strLine.Find(_T(' ')) >= 0)
			strLine = _T('\"') + strLine + _T('\"');

		if (strPlayer.IsEmpty())
			ShellExecute(NULL, NULL, strLine, NULL, NULL, SW_SHOWNORMAL);
		else
		{
			CString strPlayerPath, strArgs(g_App.m_pPrefs->GetVideoPlayerArgs());
			int i = strPlayer.ReverseFind('\\');

			if (i >= 0)
				strPlayerPath = strPlayer.Left(i + 1);
			if (!strArgs.IsEmpty())
				strArgs += _T(' ');
			strArgs += strLine;
			ShellExecute(NULL, _T("open"), strPlayer, strArgs, strPlayerPath, SW_SHOWNORMAL);
		}
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::PreviewAvailable()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	EnumPartFileStatuses	eFileStatus = GetStatus();

// 	No preview while completing or hashing or when file is already complete
	if (eFileStatus == PS_COMPLETING || eFileStatus == PS_COMPLETE || eFileStatus == PS_HASHING)
		return false;

//	Allow preview of archives of any length > 1k
	if (IsArchivePreviewable())
	{
	//	Preview creates two files: a file copy of complete data (file size is up to
	//	the most distant received data block) and reconstructed archive. So the required
	//	free space is the current file size (equal to the most distant data block except
	//	for preallocated files) plus total complete data size (the size of reconstructed
	//	archive will be close or less than that)
	//	plus some extra just in case (also not to fill the whole partition)
		return ( (GetFileSize() > 1024ui64) && (GetCompletedSize() > 1024ui64) && !m_bRecoveringArchive
			&& (GetFreeDiskSpaceX(m_strTempDir) > (m_hPartFileRead.GetLength() + GetCompletedSize() + 20ui64 * 1024ui64 * 1024ui64)) );
	}

	byte	byteMovieMode = GetMovieMode();

	if (byteMovieMode == 0)
	{
	//	Check only for AVI style movie, as below first chunk check is enough for all MPG-style ones
		if (IsAviKindMovie())
			byteMovieMode = (GetLastPartSize() < static_cast<uint32>(GetFileSize() / 100ui64)) ? 7 : 1;
	}

	if (g_App.m_pPrefs->BackupPreview())
	{
		return ( ((eFileStatus == PS_READY) || IsPaused())
				&& !m_bPreviewing && (GetPartCount() > 2) && IsMovie() && IsPartComplete(0)
				&& (((byteMovieMode != 1) && (byteMovieMode != 7)) || IsPartComplete(GetPartCount() - 1))
				&& ((byteMovieMode != 7) || IsPartComplete(GetPartCount() - 2))
				&& (GetFreeDiskSpaceX(m_strTempDir) >= (GetFileSize() + 50ui64 * 1024ui64 * 1024ui64)) );
	}
	else
	{
		TCHAR szVideoPlayerFileName[_MAX_FNAME];
		_tsplitpath(g_App.m_pPrefs->GetVideoPlayer(), NULL, NULL, szVideoPlayerFileName, NULL);

	//	Enable the preview command if the according option is specified 'PreviewSmallBlocks'
	//	or if VideoLAN client is specified
		if (g_App.m_pPrefs->GetPreviewSmallBlocks() || !_tcsicmp(szVideoPlayerFileName, _T("vlc")))
		{
			if (m_bPreviewing)
				return false;

			if (!(eFileStatus == PS_READY || eFileStatus == PS_EMPTY || IsPaused()))
				return false;

			EED2KFileType	eFileType = GetFileType();

			if (eFileType != ED2KFT_VIDEO && eFileType != ED2KFT_AUDIO && eFileType != ED2KFT_CDIMAGE)
				return false;

		//	If it's an MPEG file, VLC is even capable of showing parts of the file if the beginning of the file is missing!
			if (IsMpgMovie() || IsMpgAudio())
			{
			//	TODO: search a block which is at least 16K (Audio) or 256K (Video)
				if (GetCompletedSize() < 16ui64 * 1024ui64)
					return false;
			}
			else
			{
			//	For AVI files it depends on the used codec..
				if (!IsComplete(0, 256 * 1024))
					return false;
			}

			return true;
		}
		else
		{
			return ( ((eFileStatus == PS_READY) || IsPaused())
					&& !m_bPreviewing && (GetPartCount() > 2) && IsMovie() && IsPartComplete(0)
					&& (((byteMovieMode != 1) && (byteMovieMode != 7)) || IsPartComplete(GetPartCount() - 1))
					&& ((byteMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) );
		}
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::AllowGet1stLast()
{
	if (!(IsMovie() || IsArchivePreviewable()) || (GetPartCount() < 3))
		return false;

	byte	byteMovieMode = GetMovieMode();

	if (byteMovieMode == 0)
	{
	//	Check only for AVI style movie, as below first chunk check is enough for all MPG-style ones
		if (IsAviKindMovie())
			byteMovieMode = (GetLastPartSize() < static_cast<uint32>(GetFileSize() / 100ui64)) ? 7 : 1;
	}
	return !( IsPartComplete(0)
				&& (((byteMovieMode != 1) && (byteMovieMode != 7)) || IsPartComplete(GetPartCount() - 1))
				&& ((byteMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) );
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet* CPartFile::CreateSrcInfoPacket(const CUpDownClient *pForClient, byte byteRequestedVer, uint16 uRequestedOpt)
{
	NOPRM(uRequestedOpt);	// We don't support any special SX2 options yet, reserved for later use

#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (pForClient->m_pReqPartFile != this)
		return NULL;

	if (!IsPartFile() || (GetSourceCount() == 0))
		return CKnownFile::CreateSrcInfoPacket(pForClient, byteRequestedVer, uRequestedOpt);

	CMemFile	packetStream(1024);
	uint32		dwCount = 0;
	byte		byteUsedVer;
	bool		bNeededPart, bIsSX2Packet;

	if (pForClient->SupportsSourceExchange2() && (byteRequestedVer != 0))
	{
	//	Highest vesion supported by both clients
		byteUsedVer = min(byteRequestedVer, SOURCEEXCHANGE2_VERSION);
		packetStream.Write(&byteUsedVer, 1);
		bIsSX2Packet = true;
	}
	else
	{
		byteUsedVer = pForClient->GetSourceExchange1Version();
		bIsSX2Packet = false;
	}

	packetStream.Write(m_fileHash, 16);
	packetStream.Write(&dwCount, 2);

	CUpDownClient  *pPotentialSource;
	const byte		*pbyteForClientPartStatus, *pbytePotentialClientPartStatus;
	uint32			dwID, dwSrvIP, dwRes;
	uint16			uPort, uSrvPort;
	ClientList		clientListCopy;
	const uint16	uPartCount = GetPartCount();

	GetCopySourceLists(SLM_ALL, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pPotentialSource = *cIt;

	//	Don't send a client to itself as a source (part 1)
		if (pForClient == pPotentialSource)
			continue;
	//	Don't send a client to itself as a source (part 2) or another client with same hash
		if ((dwRes = pForClient->Compare(pPotentialSource)) != 0)
			continue;
	//	Don't send a client using a hash that was identified for another client because he could be a hash stealer
		if (pPotentialSource->m_pCredits != NULL
			&& pPotentialSource->m_pCredits->GetCurrentIdentState(pPotentialSource->GetIP()) == IS_IDBADGUY)
			continue;
	//	Check LowID status
		if (pPotentialSource->HasLowID())
		{
		//	Don't send a LowID client to LowID as they will not able to connect
			if (pForClient->HasLowID())
				continue;
		//	Don't send a LowID client if server IP & server port are unknown
			if (pPotentialSource->GetServerIP() == 0 || pPotentialSource->GetServerPort() == 0)
				continue;
		//	Don't send a LowID client to HighID if client on different server
			if ( pPotentialSource->GetServerIP() != pForClient->GetServerIP()
				|| pPotentialSource->GetServerPort() != pForClient->GetServerPort() )
				continue;
		}
	//	Don't send clients that have no parts available
		if (pPotentialSource->GetAvailablePartCount() == 0)
			continue;
	//	Don't share Lan clients sources as they are private ips/userids
		if (pPotentialSource->IsOnLAN())
			continue;
	//	don't send erroneous or fake sources
		if (uPartCount != pPotentialSource->GetPartCount())
			continue;

		bNeededPart = false;

	//	Only send source which have needed parts for this client if possible
		pbyteForClientPartStatus = pForClient->GetPartStatus();
		pbytePotentialClientPartStatus = pPotentialSource->GetPartStatus();

	//	Both clients support part statuses so we try to find needed clients
		if (pbyteForClientPartStatus != NULL && pbytePotentialClientPartStatus != NULL)
		{
			for (uint32 i = 0; i < uPartCount; i++)
			{
				if (pbytePotentialClientPartStatus[i] && !pbyteForClientPartStatus[i])
				{
					bNeededPart = true;
					break;
				}
			}
		}
	//	If not we give a sources with at least one part (for files that have more than one part)
		else
			bNeededPart = true;

		if (bNeededPart)
		{
			if (byteUsedVer >= 3)
				dwID = pPotentialSource->GetUserIDHybrid();
			else	//	use the old ed2k user ID convention for LowID sources on the same server
			{
				if (pPotentialSource->HasLowID())
					dwID = pPotentialSource->GetUserIDHybrid();
				else
					dwID = pPotentialSource->GetIP();
			}
			uPort = pPotentialSource->GetUserPort();
			dwSrvIP = pPotentialSource->GetServerIP();
			uSrvPort = pPotentialSource->GetServerPort();

			packetStream.Write(&dwID, 4);
			packetStream.Write(&uPort, 2);
			packetStream.Write(&dwSrvIP, 4);
			packetStream.Write(&uSrvPort, 2);
			if (byteUsedVer > 1)
			{
				packetStream.Write(pPotentialSource->GetUserHash(), 16);
				if (byteUsedVer >= 4)	// ConnectSettings - SourceExchange V4
				{
					// 4 Reserved
					// 1 DirectCallback Supported/Available
					// 1 CryptLayer Required
					// 1 CryptLayer Requested
					// 1 CryptLayer Supported
					const byte byteCryptOptions = pPotentialSource->GetCryptLayer();

					packetStream.Write(&byteCryptOptions, 1);
				}
			}
			if (++dwCount > 500)
				break;
		}
	}

	if (dwCount == 0)
		return NULL;

	packetStream.Seek((bIsSX2Packet) ? 17 : 16, 0);
	packetStream.Write(&dwCount, 2);

	Packet	*pPacket = new Packet(&packetStream, OP_EMULEPROT);

	pPacket->m_eOpcode = (bIsSX2Packet) ? OP_ANSWERSOURCES2 : OP_ANSWERSOURCES;
// (1+)16+2+501*(4+2+4+2+16+1) = 14547 (14548) bytes max.
	if (pPacket->m_dwSize > 354)
		pPacket->PackPacket();

	return pPacket;

	EMULE_CATCH

#endif //NEW_SOCKETS_ENGINE
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddClientSources(CMemFile *packetStream, byte byteSXVer, bool bSX2, const CUpDownClient *pClient/*=NULL*/)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

//	If this part file is paused or complete/completing or erroneous no sources needed any more.
	EnumPartFileStatuses	eFileStatus = GetStatus();

	if ( (eFileStatus == PS_PAUSED) || (eFileStatus == PS_STOPPED)
		|| (eFileStatus == PS_COMPLETE) || (eFileStatus == PS_COMPLETING)
		|| (eFileStatus == PS_ERROR) )
		return;

	uint32		dwNumSources = 0, dwPktSXVer = 0, dwDataSize, dwSz;

	if (!bSX2)	//	For SX1 (deprecated)
	{
	//	Check if the data size matches the number of sources and eventually correct the source
	//	exchange version while reading the packet data. Otherwise we could experience a higher
	//	chance in dealing with wrong source data, user hashes and finally duplicate sources
		packetStream->Read(&dwNumSources, 2);
		dwDataSize = static_cast<uint32>(packetStream->GetLength() - packetStream->GetPosition());

	//	If a newer version inserts additional data (like v2), the below code will correctly filter those packets.
	//	If it appends additional data after <count>(<Sources>)[count], we are in trouble with the
	//	below code. Thus a client which doesn't understand newer version should never receive such a packet.
		if (dwNumSources * (4u + 2u + 4u + 2u + 16u + 1u) == dwDataSize)	//	Check for v4 packet
		{
			if (byteSXVer >= 4)
				dwPktSXVer = 4;
		}
		else if (dwNumSources * (4u + 2u + 4u + 2u + 16u) == dwDataSize)	//	Check for v2/v3 packet
		{
			if (byteSXVer >= 2)
				dwPktSXVer = (byteSXVer == 2) ? 2 : 3;
		}
		else if (dwNumSources * (4u + 2u + 4u + 2u) == dwDataSize)	//	Check for v1 packet
		{
			if (byteSXVer >= 1)
				dwPktSXVer = 1;
		}
	}
	else	//	For SX2
	{
		//	Check if a version is known by us and do quick sanity check on known version
		//	Unlike SX1, packet will be ignored in case of any error
		if ((static_cast<unsigned>(byteSXVer) - 1u) > static_cast<unsigned>(SOURCEEXCHANGE2_VERSION - 1))
		{
			g_App.m_pMDlg->AddLogLine(LOG_FL_DBG, _T("Received invalid SX2 packet (v%u) from %s for %s"),
				byteSXVer, (pClient != NULL) ? pClient->GetClientNameWithSoftware() : _T("???"), GetFileName());
			return;
		}
	//	All known versions have first 2 bytes as count; unknown version were already filtered out above
		packetStream->Read(&dwNumSources, 2);
		dwDataSize = static_cast<uint32>(packetStream->GetLength() - packetStream->GetPosition());

		dwSz = ~dwDataSize;
		switch (byteSXVer)
		{
			case 1:
				dwSz = dwNumSources * (4u + 2u + 4u + 2u);
				break;
			case 2:
			case 3:
				dwSz = dwNumSources * (4u + 2u + 4u + 2u + 16u);
				break;
			case 4:
				dwSz = dwNumSources * (4u + 2u + 4u + 2u + 16u + 1u);
				break;
		}
		if (dwSz == dwDataSize)
			dwPktSXVer = byteSXVer;
	}

	if (dwPktSXVer == 0)
	{
		g_App.m_pMDlg->AddLogLine(LOG_FL_DBG, _T("Received invalid SX%c packet (v%u) of data size %u (%u) from %s for %s"),
			(bSX2) ? _T('2') : _T('1'), byteSXVer, dwDataSize, dwNumSources,
			(pClient != NULL) ? pClient->GetClientNameWithSoftware() : _T("???"), GetFileName());
		return;
	}

	CClientSource	source;

	for (uint32 i = 0; i < dwNumSources; i++)
	{
		packetStream->Read(&source.dwSrcIDHybrid, 4);
	//	Convert the ed2k ID into Hybrid ID for SX v1 & v2
		if ((dwPktSXVer < 3) && !IsLowID(source.dwSrcIDHybrid))
			source.dwSrcIDHybrid = fast_ntohl(source.dwSrcIDHybrid);
		packetStream->Read(&source.sourcePort, 2);
		packetStream->Read(&source.serverIP, 4);
		packetStream->Read(&source.serverPort, 2);
		if (dwPktSXVer > 1)
		{
			packetStream->Read(&source.achUserHash, 16);
			if (dwPktSXVer >= 4)
			{
				byte byteCryptOptions;
				
				packetStream->Read(&byteCryptOptions, 1);
			}
		}
		else
			md4clr(source.achUserHash);
		AddClientSource(&source, i, true, static_cast<byte>(dwPktSXVer));
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Updates priority of file if autopriority is activated
void CPartFile::UpdateDownloadAutoPriority(void)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (IsAutoPrioritized())
	{
		int iValidSources = GetSourceCount() - GetNotCurrentSourcesCount();

		if (iValidSources < g_App.m_pPrefs->PriorityHigh() && priority != PR_HIGH)
			SetPriority(PR_HIGH);
		else if (iValidSources >= g_App.m_pPrefs->PriorityHigh() && iValidSources < g_App.m_pPrefs->PriorityLow() && priority != PR_NORMAL)
			SetPriority(PR_NORMAL);
		else if (iValidSources >= g_App.m_pPrefs->PriorityLow() && priority != PR_LOW)
			SetPriority(PR_LOW);
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CPartFile::GetStatsFullPath() const
{
	return m_strFilePath + _T(".stats");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--- xrmb:keepPartFileStats ---
bool CPartFile::LoadPartFileStats()
{
	EMULE_TRY

	byte	abyteTmp[4 + 4 + 8];
	FILE	*fh = _tfsopen(GetStatsFullPath(), _T("rb"), _SH_DENYWR);

//	If we cant open this file you lose the stats
	if (fh == NULL)
		return false;

//	Get version
	byte	version = 0;
	if (fread(&version, sizeof(version), 1, fh) != 1)
	{
		fclose(fh);
		return false;
	}

//	Skip the former storage place for part file requests/accepted/tranfer statistics
//	Starting from v1.1c this data is kept in .part.met
//	'fread' is used instead of 'fseek' to increase performance of file stream buffering
	if (fread(abyteTmp, sizeof(abyteTmp), 1, fh) != 1)
	{
		fclose(fh);
		return false;
	}

//	This is for the parttraffic
//	I thought about explicit adding the traffic like for the other stats above
//	but it doesnt make sense, because you'll no transfer if you reach this
	if (!LoadFromFileTraffic(fh, version))
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_TRAFFICDAT_CORRUPT, GetStatsFullPath());
		g_App.m_pMDlg->DisableAutoBackup();
#endif
		fclose(fh);
		return false;
	}

	fclose(fh);

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::SavePartFileStats()
{
	static const uint32 s_adwDummy[4] = { 0, 0, 0, 0 };
	EMULE_TRY

//	Don't save for completing file as .part.stats is deleted anyway after completion;
//	Don't save for complete to avoid creation of wrong .stats in the destination
//	directory, as filenames are already changed
	if ((m_eStatus == PS_COMPLETING) || (m_eStatus == PS_COMPLETE))
		return false;

	FILE *fh = _tfsopen(GetStatsFullPath(), _T("wb"), _SH_DENYWR);

//	If we can't open this file you lose the stats
	if (fh == NULL)
		return false;

//	Set version
	byte	version = 2;
	if (fwrite(&version, sizeof(version), 1, fh) != 1)
	{
		fclose(fh);
		return false;
	}

//	Fill with zeroes the former storage place for part file requests/accepted/tranfer statistics
//	Starting from v1.1c this data is kept in .part.met
	if (fwrite(s_adwDummy, sizeof(s_adwDummy), 1, fh) != 1)
	{
		fclose(fh);
		return false;
	}

//	This is for the parttraffic
	if (SaveToFileTraffic(fh) == false)
	{
		fclose(fh);
		return false;
	}

	fclose(fh);

	return true;

	EMULE_CATCH

	return false;
}
//--- :xrmb ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Used as separate thread to complete file
UINT CPartFile::CompleteThreadProc(CPartFile* pFile)
{
#ifndef NEW_SOCKETS_ENGINE
#ifdef EP_SPIDERWEB
//	Setup Structured Exception handler for the this thread
	_set_se_translator(StructuredExceptionHandler);
#endif

	EMULE_TRY

	g_App.m_pPrefs->InitThreadLocale();

	if (pFile == NULL)
		return ~0u;

	pFile->PerformFileComplete();

	return 0;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return ~0u;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CPartFile::DtLocale(CTime dt)
{
#ifndef NEW_SOCKETS_ENGINE
	static const UINT		s_adwDayResId[] =
	{
		IDS_SCH_EXCEPT_SUN, IDS_SCH_EXCEPT_MON, IDS_SCH_EXCEPT_TUE, IDS_SCH_EXCEPT_WED,
		IDS_SCH_EXCEPT_THU, IDS_SCH_EXCEPT_FRI, IDS_SCH_EXCEPT_SAT
	};
	SYSTEMTIME st;
	dt.GetAsSystemTime(st);

	int		nDateSize = GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0);
	int		nTimeSize = GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0);
	CString	strDate, strTime, strBuffer;

	GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, strDate.GetBuffer(nDateSize), nDateSize);
	strDate.ReleaseBuffer();

	GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, strTime.GetBuffer(nTimeSize), nTimeSize);
	strTime.ReleaseBuffer();

	strBuffer.Format(_T("%s, %s, %s"),
		GetResString(s_adwDayResId[dt.GetDayOfWeek() - 1]), strDate, strTime);
	return strBuffer;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	LoadSettingsFile() loads settings for partfiles (Movie Preview Mode, Stopped status, Preallocation)
void CPartFile::LoadSettingsFile()
{
	EMULE_TRY

	CString	strIniFile(m_strFilePath);
	uint32	dwMode;

	strIniFile += _T(".settings");

	CIni filesettings(strIniFile, INI_MODE_READONLY | INI_MODE_ANSIONLY);	// file is closed in destructor

	filesettings.SetDefaultCategory(_T("Settings"));
	dwMode = filesettings.GetUInt32(_T("MoviePreviewMode"), 0);
	if ((dwMode > 7) || ((dwMode & 6) == 2) || (dwMode == 6))	// Check for valid values 0, 1, 4, 5, 7
		dwMode = 0;
	CKnownFile::SetMovieMode(static_cast<byte>(dwMode));
	m_bStopped = filesettings.GetBool(_T("StoppedStatus"), m_bStopped);
	m_bIsPreallocated = filesettings.GetBool(_T("Preallocated"), m_bIsPreallocated);
	filesettings.GetString(&m_strAlternativePath, _T("AltDestDir"), _T(""));

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SaveSettingsFile() save settings for partfiles (Movie Preview Mode, Stopped status, Preallocation)
void CPartFile::SaveSettingsFile()
{
	EMULE_TRY

	CString strIniFile(m_strFilePath);

	strIniFile += _T(".settings");

	CIni filesettings(strIniFile, INI_MODE_ANSIONLY);

	filesettings.SetDefaultCategory(_T("Settings"));
	filesettings.SetInt(_T("MoviePreviewMode"), ((CKnownFile*)this)->GetMovieMode());
	filesettings.SetBool(_T("StoppedStatus"), m_bStopped);
	filesettings.SetBool(_T("Preallocated"), m_bIsPreallocated);
	filesettings.SetString(_T("AltDestDir"), m_strAlternativePath);

	filesettings.SaveAndClose();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	WriteToBuffer() buffer rx data which will be flushed later by timer or size threshold.
//		Params:
//			iComprGain - number of bytes saved by compression (it can be negative
//			             after connection loss in the middle of compressed block);
//			data       - pointer to data buffer;
//			qwStart    - data start offset;
//			qwEnd      - data end offset (inclusive);
//			iFlags     - additional flags.
//				PF_WR2BUF_FL_FREEBUFFER - data buffer can be used for further operations (caller doesn't free it)
//				PF_WR2BUF_FL_ENDOFBLOCK - current data is the last portion of the requested block
//		Return: number of buffered bytes
uint32 CPartFile::WriteToBuffer(sint32 iComprGain, BYTE *data, uint64 qwStart, uint64 qwEnd, int iFlags)
{
	EMULE_TRY

	uint32	dwDataLen = static_cast<uint32>(qwEnd - qwStart + 1);

	if (iComprGain != 0)
	{
	//	Compression gain can be negative in case of disconnection in the middle of compressed stream
		m_qwGainDueToCompression += static_cast<sint64>(iComprGain);
		g_App.m_pPrefs->Add2SavedFromCompression(iComprGain);
	}

//	Occasionally packets are duplicated, no point writing it twice
	if (IsComplete(qwStart, qwEnd))
	{
		AddLogLine(LOG_FL_DBG, _T("File '%s' has already been written from %I64u to %I64u size %u"), GetFileName(), qwStart, qwEnd, dwDataLen);
	}
	else
	{
	//	Create a new buffered queue entry
		PartFileBufferedData *item = new PartFileBufferedData;

		item->qwStartOffset = qwStart;
		item->qwEndOffset = qwEnd;

		if ((iFlags & PF_WR2BUF_FL_FREEBUFFER) == 0)
		{
		//	Create copy of data as new buffer
			BYTE *buffer = new BYTE[dwDataLen];

			memcpy2(buffer, data, dwDataLen);
			data = buffer;
		}
		item->pbyteBuffer = data;

	//	Add to the queue in the correct position (most likely the end)
		PartFileBufferedData *queueItem;
		bool added = false;
		POSITION pos = m_BufferedData_list.GetTailPosition();
		if (pos != NULL)
		{
			do
			{
				POSITION posNext = pos;

				queueItem = m_BufferedData_list.GetPrev(pos);
				if (item->qwEndOffset > queueItem->qwEndOffset)
				{
					added = true;
					m_BufferedData_list.InsertAfter(posNext, item);
					break;
				}
			} while (pos != NULL);
		}
	//	Reset timer for empty cache to buffer more effectively, otherwise timer
	//	running all the time can flush just a little data to the disk on the first hit
		else
			m_nLastBufferFlushTime = ::GetTickCount();
		if (!added)
			m_BufferedData_list.AddHead(item);

	//	Increment buffer size marker
		m_nTotalBufferData += dwDataLen;

	//	Mark this small section of the file as filled
		FillGap(item->qwStartOffset, item->qwEndOffset);

		uint32 dwPartNum = static_cast<uint32>(qwStart / PARTSIZE);

	//	Check that all data of the part is received
		if (IsPartFull(dwPartNum))
		{
		//	Prevent data flush during processesing of the data from the sockets
			m_bDataFlushReq = true;
		}
		else if (((iFlags & PF_WR2BUF_FL_ENDOFBLOCK) != 0) && IsCorruptedPart(dwPartNum))
		{
		//	Flush and check data to minimize amount of additional unrequired redownloads
		//	Do it only by end of the block basis to minimize system load as some clients send by small portions
			m_bDataFlushReq = true;
		}

		m_timeLastDownTransfer = CTime::GetCurrentTime();

	//	Return the length of data written to the buffer
		return dwDataLen;
	}

	EMULE_CATCH

	if ((iFlags & PF_WR2BUF_FL_FREEBUFFER) != 0)
		delete[] data;

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	FlushBuffer() flushes buffered data from the source to the part file
void CPartFile::FlushBuffer(void)
{
	EMULE_TRY

	m_bDataFlushReq = false;

	m_nLastBufferFlushTime = ::GetTickCount();

//	If there's no buffered data to flush, just return
	if (m_BufferedData_list.IsEmpty())
		return;

//	Reset the Last Down Transfer timer
	m_timeLastDownTransfer = CTime::GetCurrentTime();
	GetAvgDataRate(true);

//	Calculate the number of parts in the part file
	uint32	dwBegPart, dwEndPart, dwPartCount = GetPartCount();
	bool *changedPart = new bool[dwPartCount];

	try
	{
	//	Remember which parts need to be checked at the end of the flush
		for (uint32 dwPartNum = 0; dwPartNum < dwPartCount; dwPartNum++)
			changedPart[dwPartNum] = false;

	//	Ensure file is big enough to write data to (the last item will be the furthest from the start)
		PartFileBufferedData *item = m_BufferedData_list.GetTail();

	//	If the end of the buffered data is past the current end of the part file, extend it
		if (m_hPartFileWrite.GetLength() <= item->qwEndOffset)
			m_hPartFileWrite.SetLength(item->qwEndOffset + 1);

	//	For each block of buffered data...
		for (int i = m_BufferedData_list.GetCount(); i > 0; i--)
		{
		//	Remove item from queue
			item = m_BufferedData_list.RemoveHead();

		//	For each part spanned by the buffered data, set the part's changed flag
			dwBegPart = static_cast<uint32>(item->qwStartOffset / PARTSIZE);
			dwEndPart = static_cast<uint32>(item->qwEndOffset / PARTSIZE);
			for (uint32 dwPart = dwBegPart; dwPart <= dwEndPart; dwPart++)
				changedPart[dwPart] = true;

		//	Go to the correct position in file and write block of data
			m_hPartFileWrite.Seek(item->qwStartOffset, CFile::begin);

			uint32 lenData = static_cast<uint32>(item->qwEndOffset - item->qwStartOffset + 1);

		//	Decrease buffer size
			m_nTotalBufferData -= lenData;
			m_hPartFileWrite.Write(item->pbyteBuffer, lenData);

		//	Release memory used by this item
			delete[] item->pbyteBuffer;
			delete item;
		}

	//	If the size of the part file is greater than the size of the target file,
	//	set it to the size of the target file.
		if (m_hPartFileWrite.GetLength() > GetFileSize())
			m_hPartFileWrite.SetLength(GetFileSize());

	//	Flush to disk
		m_hPartFileWrite.Flush();

	//	Check each part of the file
		uint32	partRange = GetLastPartSize() - 1;
		uint64	qwPartBeg, qwPartEnd;

	//	For each part in the part file (in reverse)...
		for (int iPartNum = (int)dwPartCount - 1; iPartNum >= 0; iPartNum--)
		{
		//	If we didn't just write it, skip it
			if (changedPart[iPartNum] == false)
			{
			//	Any parts other than last must be full size
				partRange = PARTSZ32 - 1;
				continue;
			}

			qwPartBeg = static_cast<uint64>(static_cast<uint32>(iPartNum)) * PARTSIZE;
			qwPartEnd = qwPartBeg + static_cast<uint64>(partRange);
		//	Is this 9MB part complete
			if (IsComplete(qwPartBeg, qwPartEnd))
			{
			//	Is part corrupt
				if (!HashSinglePart(iPartNum))
				{
#ifndef NEW_SOCKETS_ENGINE
					AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_PARTCORRUPT, iPartNum, GetFileName());
#endif
					AddGap(qwPartBeg, qwPartEnd);
					m_csGapListAndPartStatus.Lock();
					m_PartsStatusVector[iPartNum] |= PART_CORRUPTED;
					m_csGapListAndPartStatus.Unlock();
				//	Increment corruption statistics
					AddRxCorruptedAmount(partRange + 1);
				}
				else
				{
					m_csGapListAndPartStatus.Lock();
					m_PartsStatusVector[iPartNum] = (m_PartsStatusVector[iPartNum] & 0xFFFFFF) | PART_VERIFIED;
					m_csGapListAndPartStatus.Unlock();

				//	Successfully completed part, make it available for sharing
					if (m_eStatus == PS_EMPTY)
					{
						SetStatus(PS_READY);
#ifndef NEW_SOCKETS_ENGINE
					//	Delay publishing a little to avoid double publishing of small files
						g_App.m_pSharedFilesList->SafeAddKnownFile(this, false, true);
#endif //NEW_SOCKETS_ENGINE
					}

					m_qwCompletedPartsSize += static_cast<uint64>(partRange + 1);
				}
			}
			else if (IsCorruptedPart(iPartNum))
			{
			//	Try to recover with minimal loss
				if (HashSinglePart(iPartNum))
				{
					m_csGapListAndPartStatus.Lock();
					m_PartsStatusVector[iPartNum] = (m_PartsStatusVector[iPartNum] & 0xFFFFFF) | PART_VERIFIED;
					m_csGapListAndPartStatus.Unlock();

					m_iTotalPacketsSavedDueToICH++;
#ifndef NEW_SOCKETS_ENGINE
					g_App.m_pPrefs->IncSessionPartsSavedByICH();
#endif //NEW_SOCKETS_ENGINE

					uint32 dwSaved = GetPartLeftToDLSize(iPartNum);

					FillGap(qwPartBeg, qwPartEnd);
					RemoveBlockFromList(qwPartBeg, qwPartEnd);
#ifndef NEW_SOCKETS_ENGINE
					AddLogLine(LOG_FL_SBAR | LOG_RGB_SUCCESS, IDS_ICHWORKED, iPartNum, m_strFileName, CastItoXBytes(dwSaved));
#endif

				//	Decrement corruption statistics by the number of saved bytes
					m_qwLostDueToCorruption -= dwSaved;
					g_App.m_pPrefs->SubLostFromCorruption(dwSaved);

				//	Successfully completed part, make it available for sharing
					if (m_eStatus == PS_EMPTY)
					{
						SetStatus(PS_READY);
#ifndef NEW_SOCKETS_ENGINE
					//	Delay publishing a little to avoid double publishing of small files
						g_App.m_pSharedFilesList->SafeAddKnownFile(this, false, true);
#endif //NEW_SOCKETS_ENGINE
					}
					m_qwCompletedPartsSize += static_cast<uint64>(partRange + 1);
				}
			}
		//	Any parts other than last must be full size
			partRange = PARTSZ32 - 1;
		}

	//	Update met file
		SavePartFile();

	//	Is this file finished?
		m_csGapListAndPartStatus.Lock();

		bool	bIsFileFinished = gaplist.IsEmpty() && !m_bHashSetNeeded;	// can't complete without a hashset

		m_csGapListAndPartStatus.Unlock();

		if (bIsFileFinished)
			CompleteFile(false);
	}
	catch (CFileException * error)
	{
		OUTPUT_DEBUG_TRACE();

#ifndef NEW_SOCKETS_ENGINE
		if (g_App.m_pPrefs->IsErrorBeepEnabled())
			Beep(800, 200);
#endif //NEW_SOCKETS_ENGINE

		if (error->m_cause == CFileException::diskFull)
		{
			CString strSpace = CastItoXBytes(GetFreeDiskSpaceX(m_strTempDir));
			CString strTemp;

			strTemp.Format(_T("%s (%s)"), strSpace, m_strTempDir);
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_OUTOFSPACE, GetFileName());
			AddLogLine(LOG_RGB_ERROR, IDS_DWTOT_FS, strTemp);
		//	Sending message for insufficient diskspace
			CString MessageText;
			MessageText.Format(GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
			g_App.m_pMDlg->SendMail(MessageText, g_App.m_pPrefs->GetNotifierPopOnImportantError(), g_App.m_pPrefs->IsSMTPWarningEnabled());
			g_App.m_pMDlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_App.m_pPrefs->GetNotifierPopOnImportantError());
#endif //NEW_SOCKETS_ENGINE
		}
		else
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_WRITEERROR, GetFileName(), GetErrorMessage(error));
#endif
			SetStatus(PS_ERROR);
		}
	//	Don't pause stopped file to keep the state
		if (!m_bStopped)
			PauseFile();
		error->Delete();
	}
	catch (...)
	{
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_WRITEERROR, GetFileName(), GetResString(IDS_UNKNOWN));
#endif
		SetStatus(PS_ERROR);
		PauseFile();

	//	When ERRONEOUS close PartFile to allow Initialize
		ClosePartFile();
	}
	delete[] changedPart;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This will invert the gap list, up to caller to delete gaps when done
// 'Gaps' returned are really the filled areas, and guaranteed to be in order
// Returned format is like for 'gaplist' -- the end is inclusive
void CPartFile::GetFilledList(CTypedPtrList<CPtrList, Gap_Struct*> *filled)
{
	EMULE_TRY

	Gap_Struct	*gap, *best = NULL;
	POSITION	pos;
	uint64		qwBestEnd, qwStart = 0;

//	Will be unlocked on exit
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);

//	Loop until done
	bool finished = B2b(gaplist.IsEmpty());	//	no need to crash on the empty list...

	while (!finished)
	{
		finished = true;
	//	Find first gap after current start pos
		qwBestEnd = GetFileSize();
		pos = gaplist.GetHeadPosition();
		while (pos != NULL)
		{
			gap = gaplist.GetNext(pos);
			if ((gap->qwStartOffset > qwStart) && (gap->qwEndOffset < qwBestEnd))
			{
				best = gap;
				qwBestEnd = best->qwEndOffset;
				finished = false;
			}
		}

		if (!finished)
		{
		//	Invert this gap
			gap = new Gap_Struct;
			gap->qwStartOffset = qwStart;
			gap->qwEndOffset = best->qwStartOffset - 1ui64;
			qwStart = best->qwEndOffset + 1ui64;
			filled->AddTail(gap);
		}
		else
		{
		//	This is possible if there's only one gap in the beginning of the file
			if (best == NULL)
				best = gaplist.GetHead();
			qwBestEnd = GetFileSize() - 1ui64;
			if (best->qwEndOffset < qwBestEnd)	//	Don't add anything beyond file size
			{
				gap = new Gap_Struct;
				gap->qwStartOffset = best->qwEndOffset + 1ui64;
				gap->qwEndOffset = qwBestEnd;
				filled->AddTail(gap);
			}
		}
	}
	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::UpdateFileRatingCommentAvail()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (!this)
		return;

	bool prev = (m_bHasComment || m_bHasRating);

	m_bHasComment = false;
	m_bHasRating = false;

	ClientList	clientListCopy;

	GetCopySourceLists(SLM_ALL, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		CUpDownClient	*pSource = *cIt;

		if (!pSource->IsFileCommentEmpty())
			m_bHasComment = true;
		if (pSource->GetFileRating() != PF_RATING_NONE)
			m_bHasRating = true;
		if (m_bHasComment && m_bHasRating)
			break;
	}

	if ((!m_bHasComment) || (!m_bHasRating))
	{
		for (POSITION pos = m_pastCommentList.GetHeadPosition(); pos != NULL;)
		{
			CPastComment &pc = m_pastCommentList.GetNext(pos);
			if (pc.GetComment().GetLength() > 0)
				m_bHasComment = true;
			if (pc.GetRating() > 0)
				m_bHasRating = true;
			if (m_bHasComment && m_bHasRating)
				break;
		}
	}

	if ((!m_bHasComment) || (!m_bHasRating))
	{
		EnumPartFileRating	eRated = GetFileRating();

		if (!GetFileComment().IsEmpty())
			m_bHasComment = true;
		if (eRated != PF_RATING_NONE)
			m_bHasRating = true;
	}

	if (prev != (m_bHasComment || m_bHasRating))
		UpdateDisplayedInfo();

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint16 CPartFile::GetSourceCount()
{
	uint32	dwCount = 0;

	for (EnumDLQState eDS = DS_DOWNLOADING; eDS < DS_LAST_QUEUED_STATE; ++eDS)
		dwCount += m_SourceLists[eDS].size();
	return static_cast<uint16>(dwCount);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EnumPartFileRating CPartFile::GetRating()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (!m_bHasRating)
		return PF_RATING_NONE;

	uint32	dwNum = 0, dwTot = 0, dwRate;
	ClientList	clientListCopy;

	GetCopySourceLists(SLM_ALL, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		CUpDownClient	*pSource = *cIt;

		dwRate = pSource->GetFileRating();
		if (dwRate != 0)
		{
			dwNum++;
		//	Bugfix: for some $%#ing reason fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
			if (dwRate == PF_RATING_GOOD || dwRate == PF_RATING_FAIR)
				dwRate = (dwRate == PF_RATING_GOOD) ? 4 : 3;

			dwTot += dwRate;
		}
	}

	for (POSITION pos = m_pastCommentList.GetHeadPosition(); pos != NULL;)
	{
		dwRate = m_pastCommentList.GetNext(pos).GetRating();

		if (dwRate != 0)
		{
			dwNum++;
		//	Bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
			if (dwRate == PF_RATING_GOOD || dwRate == PF_RATING_FAIR)
				dwRate = (dwRate == PF_RATING_GOOD) ? 4 : 3;

			dwTot += dwRate;
		}
	}

	dwRate = GetFileRating();
	if (dwRate != 0)
	{
		dwNum++;
	//	Bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
		if (dwRate == PF_RATING_GOOD || dwRate == PF_RATING_FAIR)
			dwRate = (dwRate == PF_RATING_GOOD) ? 4 : 3;

		dwTot += dwRate;
	}

	if (dwNum != 0)
	{
		dwNum = (dwTot + (dwNum >> 1u)) / dwNum;	//Cax2 - get the average of all the ratings
	//	Bugfix: for some $%#ing reason good=3 & fair=4, breaking the progression from fake(1) to excellent(5)
		if (dwNum == 3 || dwNum == 4)
			dwNum = (dwNum == 3) ? PF_RATING_FAIR : PF_RATING_GOOD;
	}
	return static_cast<_EnumPartFileRating>(dwNum);	//0 returned if no ratings found

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return PF_RATING_NONE;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	UpdateDisplayedInfo() causes the DownloadList ctrl to redisplay the item for this file if either
void CPartFile::UpdateDisplayedInfo()
{
	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	g_App.m_pDownloadList->UpdateFile(this);
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Hostname sources in ED2K superLink supporting Source Exchange v2
void CPartFile::AddClientSource(CClientSource *pSource, int iSource/*=0*/, bool bExchanged/*=false*/, byte byteSXVer/*=0*/, int iMode/*=0*/)
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
//	Check first if we are this source
	if (g_App.m_pServerConnect->IsLowID() && g_App.m_pServerConnect->IsConnected())
	{
		if ( g_App.m_pServerConnect->GetClientID() == pSource->dwSrcIDHybrid &&
			 g_App.m_pPrefs->GetPort() == pSource->sourcePort )
		{
			return;
		}

	//	Although we are currently having a LowID, we could have had a HighID before, which
	//	that client is sending us now! seems unlikely ... it happend!
		if ( (g_App.m_pPrefs->GetPort() == pSource->sourcePort) &&
			(fast_ntohl(g_App.m_pServerConnect->GetLocalIP()) == pSource->dwSrcIDHybrid) )
		{
			return;
		}
	}
	else if ( (g_App.m_pPrefs->GetPort() == pSource->sourcePort) &&
		(fast_ntohl(g_App.m_pServerConnect->GetClientID()) == pSource->dwSrcIDHybrid) )
	{
		return;
	}
//	Use LowID source only if it's on the same server with us
	else if ( IsLowID(pSource->dwSrcIDHybrid) &&
			  !g_App.m_pServerConnect->IsLocalServer(pSource->serverIP, pSource->serverPort) )
	{
	//	Don't drop known source (it's A4AF for some other file)
		if ((iMode & ADDSRC_KNOWNSRC) == 0)
			return;
	}
#endif //OLD_SOCKETS_ENABLED

#ifndef NEW_SOCKETS_ENGINE
	if ( g_App.m_pPrefs->GetMaxSourcePerFile() > GetSourceCount()
	     && iSource < static_cast<int>(g_App.m_pPrefs->GetMaxSourcePerFileSoft()) )
	{
		CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, pSource->dwSrcIDHybrid, pSource->sourcePort, pSource->serverIP, pSource->serverPort, pSource->achUserHash, iMode);
		if (bExchanged && (pNewSource != NULL))
		{
		//	Name the exchanged source
			pNewSource->SetUserName(GetResString(IDS_EXCHANGEDSOURCE));
		//	Check exchange version
			if (byteSXVer > 1)
				pNewSource->SetUserHash(pSource->achUserHash);
		}
	}
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddClientSources(CTypedPtrList<CPtrList, CClientSource*>* sources)
{
	EMULE_TRY

	POSITION pos;
	pos = sources->GetHeadPosition();
	while (pos != NULL)
	{
		CClientSource	*pSrc = (CClientSource*)sources->GetAt(pos);

		if (pSrc->sourceType != ED2KLINK_SOURCE_IP)
		{
			sources->GetNext(pos);
			continue;
		}

		POSITION removePos = pos;
		sources->GetNext(pos);
		sources->RemoveAt(removePos);

		AddClientSource(pSrc);
		delete pSrc;
	}
#ifndef NEW_SOCKETS_ENGINE
	g_App.m_pDownloadQueue->AddClientHostnameToResolve(sources);
#endif //NEW_SOCKETS_ENGINE

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Create source ed2k from downloads
CString CPartFile::CreateED2KSourceLink(uint32 dwExpireIn, int iSourceCnt)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	CTypedPtrList<CPtrList, CUpDownClient*>	newSourceList;
	ClientList		clientListCopy;
	CUpDownClient	*pSource;

	GetCopySourceLists(SLM_ALL, &clientListCopy);
	for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
	{
		pSource = *cIt;
		if (pSource->HasLowID())
			continue;
		if (newSourceList.IsEmpty())
			newSourceList.AddHead(pSource);
		else if ((iSourceCnt == 0) || (newSourceList.GetCount() < iSourceCnt) || (pSource->GetAvailablePartCount() > newSourceList.GetTail()->GetAvailablePartCount()))
		{
			if ((iSourceCnt != 0) && (newSourceList.GetCount() == iSourceCnt))
				newSourceList.RemoveTail();

			POSITION	pos, pos2;
			bool		bInserted = false;

			for (pos = newSourceList.GetTailPosition(); (pos2 = pos) != NULL;)
			{
				if (newSourceList.GetPrev(pos)->GetAvailablePartCount() > pSource->GetAvailablePartCount())
				{
					newSourceList.InsertAfter(pos2, pSource);
					bInserted = true;
					break;
				}
			}
			if (!bInserted)
				newSourceList.AddHead(pSource);
		}
	}

//	Add A4AF sources if number of source is less than the limit
	if (newSourceList.GetCount() < iSourceCnt)
	{
		GetCopyA4AFSourceList(&clientListCopy);
		for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
		{
			pSource = *cIt;
			if ((pSource == NULL) || pSource->HasLowID())	//skip LowID sources
				continue;
			newSourceList.AddTail(pSource);
			if (newSourceList.GetCount() >= iSourceCnt)
				break;
		}
	}

	if (newSourceList.IsEmpty())
	{
#ifdef OLD_SOCKETS_ENABLED
		if (!g_App.m_pServerConnect->IsConnected() || g_App.m_pServerConnect->IsLowID())
		{
			AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_SOURCELINKFAILED);
			return _T("");
		}
#else
		return _T("");
#endif //OLD_SOCKETS_ENABLED
	}

#ifdef OLD_SOCKETS_ENABLED
	uint32	dwID = g_App.m_pServerConnect->GetClientID();
#else
	uint32	dwID = 0;
#endif //OLD_SOCKETS_ENABLED

	CString	strLink(CreateED2kLink());

	strLink += _T("|sources");
	if (dwExpireIn != 0)
	{
		CTime	timeExpirationDate = CTime::GetCurrentTime() + CTimeSpan(dwExpireIn, 0, 0, 0);

		strLink += timeExpirationDate.Format(_T("@@%y%m%d"));
	}

	if (!IsLowID(dwID))
		strLink.AppendFormat(_T(",%u.%u.%u.%u:%u"), (byte)dwID, (byte)(dwID >> 8), (byte)(dwID >> 16), (byte)(dwID >> 24), g_App.m_pPrefs->GetPort());

	AddLogLine(LOG_FL_DBG, _T("Generated ed2k link with %u sources for file '%s' (part count %u)"), newSourceList.GetCount(), GetFileName(), GetPartCount());

	while (!newSourceList.IsEmpty())
	{
		pSource = newSourceList.RemoveHead();
		AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("| User: %s - Available part count: %u"), pSource->GetUserName(), pSource->GetAvailablePartCount());
		strLink.AppendFormat(_T(",%s:%u"), pSource->GetFullIP(), pSource->GetUserPort());
	}

	strLink += _T("|/");
	return strLink;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return _T("");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::SetAlternativeOutputDir(CString *path)
{
	path->TrimRight(_T('\\'));
	m_strAlternativePath = *path;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetOutputDir() returns the appropriate destination directory path for this file.
CString CPartFile::GetOutputDir()
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	CString	strRetPath = g_App.m_pPrefs->GetIncomingDir();
	CString	strCatPath;

	if (GetCatID() != CAT_NONE)
		strCatPath = CCat::GetCatByID(GetCatID())->GetPath();

//	If no alternative path defined
	if (m_strAlternativePath.IsEmpty())
	{
	//	... and a category dir is defined...
		if (strCatPath != _T(""))
			return strCatPath; // Return the category dir
		else
			return strRetPath;	// Return the incoming dir
	}

//	MOREVIT - Why all the heavy duty shell call nonsense? You could replace all of this
//	with a single call to PathFileExists(). Somebody just thought they were more
//	clever than they were methinks.

//	We're going to use desktop folder "static" functions , we need an object
//	of IShellFolder type and DeskTop always exists
	IShellFolder	*pDesktop = NULL;
	ITEMIDLIST	*pList = NULL;
	CString	strDir;

//	Try to create DeskTop folder object
	if (SHGetDesktopFolder(&pDesktop) == NOERROR)
	{
		ULONG	uAttrib	= SFGAO_FOLDER; //we're going to look for the "folder" attribute

		strDir = m_strAlternativePath;
	//	"ParseDisplayName" uses UNICODE so BSTR will go
	//	We have to remember to release it
		BSTR	pData	= strDir.AllocSysString();

		if (pData)
		{
		//	'm_strAlternativePath' is always created without "\" but this was the way
		//	the original code was, maybe it was for a reason :) , so I am going to leave
		//	first check without adding "\" as well ...

		//	So here we convert "display name" (path string) into ID list used by Shell
			pDesktop->ParseDisplayName(NULL, NULL, pData, NULL, &pList, &uAttrib);
		//	Release the BSTR
			::SysFreeString(pData);
		//	If list we got is null then no such object exists
			if (!pList)
			{
			//	Add "\" to get folder name
				strDir += _T('\\');
			//	Allocate new search BSTR
				pData = strDir.AllocSysString();
				if (pData)
				{
				//	We're going to look for "folder" attribute
					uAttrib	= SFGAO_FOLDER ;
				//	We convert "display name" (path string) into ID list used by Shell
					pDesktop->ParseDisplayName(NULL, NULL, pData, NULL, &pList, &uAttrib);
				//	Release the BSTR
					::SysFreeString(pData);
				}
			}
		//	If we found the object and it's "folder" type
			if (pList && (uAttrib & SFGAO_FOLDER))
			{
				LPMALLOC	ppMalloc;

				if (SHGetMalloc(&ppMalloc) == NOERROR)
				{
					ppMalloc->Free(pList);
					ppMalloc->Release();
				}

			//	Share the destination directory
				if (g_App.m_pPrefs->SharedDirListCheckAndAdd(strDir, true))
				{
				//	New path was added to the list, scan for files
					g_App.m_pSharedFilesList->Reload();
				}
				return m_strAlternativePath;
			}
		//	Just in case the object is not folder we have to release memory
			else if (pList)
			{
				LPMALLOC	ppMalloc;

				if (SHGetMalloc(&ppMalloc) == NOERROR)
				{
					ppMalloc->Free(pList);
					ppMalloc->Release();
				}
			}
		}
		pDesktop->Release();
	}

//	Default return
	strRetPath.TrimRight(_T('\\'));
	return strRetPath;

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE

	return _T("");
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CPartFile::GetDownloadFileInfo()
{
#ifndef NEW_SOCKETS_ENGINE
	CString strInfo, strLastSeenComplete, strLastProgress, strTimeLeft, strFileSz = CastItoXBytes(GetFileSize());
	double dblAvailability = 0.0;

	if (lastseencomplete == NULL)
		GetResString(&strLastSeenComplete, IDS_NEVER);
	else
		strLastSeenComplete = LocalizeLastSeenComplete();

	if (GetTransferred() == 0)
		GetResString(&strLastProgress, IDS_NEVER);
	else
		strLastProgress = LocalizeLastDownTransfer();

	if (GetPartCount() != 0)
		dblAvailability = GetAvailablePartCount() * 100 / GetPartCount();

	EnumPartFileStatuses	eFileStatus = GetStatus();

	if ((eFileStatus != PS_COMPLETING) && (eFileStatus != PS_COMPLETE))
		strTimeLeft = CastSecondsToHM(GetTimeRemaining());
	else
		strTimeLeft = _T("-");

	strInfo.Format( _T("%s (%s)\n\n%s: %s\n\n%s: %s\n") + GetResString(IDS_PARTINFOS),
		GetFileName(), strFileSz,
		GetResString(IDS_STATUS), GetPartFileStatus(),
		GetResString(IDS_FILEHASH), HashToString(GetFileHash()),
		GetResString(IDS_DL_FILENAME), m_strFilePath,
		GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), dblAvailability,
		static_cast<int>(GetPercentCompleted()),
		CastItoXBytes(GetCompletedSize()), strFileSz, GetTransferringSrcCount(),
		GetResString(IDS_LASTSEENCOMPLETE), strLastSeenComplete,
		GetResString(IDS_LASTRECEPTION), strLastProgress,
		GetResString(IDS_DLCOL_REMAININGTIME), strTimeLeft,
		GetOnQueueSrcCount(), GetQueueFullSrcCount(), GetNoNeededPartsSrcCount(),
		GetSrcA4AFCount(), GetConnectingSrcCount() );

	return strInfo;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Improved Tooltips
CString CPartFile::GetDownloadFileInfo4Tooltips()
{
#ifndef NEW_SOCKETS_ENGINE
	CString strInfo, strLastSeenComplete, strLastProgress, strTransferSrcCount, strFileSz = CastItoXBytes(GetFileSize());
	double dblAvailability = 0.0;

	if (lastseencomplete == NULL)
		GetResString(&strLastSeenComplete, IDS_NEVER);
	else
		strLastSeenComplete = LocalizeLastSeenComplete();

	if (GetTransferred() == 0)
		GetResString(&strLastProgress, IDS_NEVER);
	else
		strLastProgress = LocalizeLastDownTransfer();

	if (GetPartCount() != 0)
		dblAvailability = GetAvailablePartCount() * 100 / GetPartCount();

	if (GetTransferringSrcCount() > 0)
		strTransferSrcCount.Format(GetResString(IDS_TT_PARTINFOS3), GetTransferringSrcCount());

	strInfo.Format(_T("<t=2><b>%s</b><br><t=2>%s (%s %s)<br><t=2>%d%s (%s / %s) %s<br><hr=100%%><br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s<t></b>%s<br><b>%s:<t></b>%d, %s: %d (%.1f%%)<br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>")
		+ GetResString(IDS_TT_STATUS2) + _T("<br><b>%s:<t></b>%s"),
		GetFileName(), strFileSz, CastItoThousands(GetFileSize()), GetResString(IDS_BYTES),
		static_cast<int>(GetPercentCompleted()), GetResString(IDS_PROCDONE), CastItoXBytes(GetCompletedSize()), strFileSz, strTransferSrcCount,
		GetResString(IDS_STATUS), GetPartFileStatus(),
		GetResString(IDS_FILEHASH), HashToString(GetFileHash()),
		GetResString(IDS_DL_FILENAME), m_strFilePath,
		GetResString(IDS_FD_OUTPUT), GetOutputDir(),
		GetResString(IDS_UP_PARTS), GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), dblAvailability,
		GetResString(IDS_LASTSEENCOMPLETE), strLastSeenComplete,
		GetResString(IDS_LASTRECEPTION), strLastProgress,
		GetResString(IDS_DL_SOURCES), GetOnQueueSrcCount(),
		GetQueueFullSrcCount(),
		GetNoNeededPartsSrcCount(),
		GetSrcA4AFCount(),
		GetConnectingSrcCount(),
		GetResString(IDS_SIZE_ON_DISK), CastItoXBytes(GetRealFileSize()) );

	return strInfo;
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Generate file progress bar for WebServer
void CPartFile::GetProgressString(CString *pstrChunkBar, uint32 dwSize)
{
	EMULE_TRY

	const TCHAR crProgress = _T('9');	// Green
	EnumPartFileStatuses	eFileStatus = GetStatus();

	if ((eFileStatus == PS_COMPLETE) || (eFileStatus == PS_COMPLETING))
	{
		for (uint32 i = 0; i < dwSize; i++)
			pstrChunkBar->AppendChar(crProgress);
	}
	else
	{
		CArray<Gap_Struct, Gap_Struct> aGaps;
		const COLORREF	crHave = RGB(0, 0, 0);			// Black
		const COLORREF	crPending = RGB(0, 255, 0);		// Yellow
		const COLORREF	crMissing = RGB(255, 0, 0);		// Red
		CBarShader		ChunkBar(0, dwSize, crHave, GetFileSize());

	//	Make a gap list copy to avoid synchronization object allocation for a long time
		GetGapListCopy(&aGaps);

		Gap_Struct	*pGap = aGaps.GetData();
		Gap_Struct	*pGapMax = pGap + aGaps.GetCount();

		for (; pGap < pGapMax; pGap++)
		{
			uint64	qwGapBeg = pGap->qwStartOffset;
			uint64	qwGapEnd = pGap->qwEndOffset + 1ui64;

			for (uint32 i = static_cast<uint32>(qwGapBeg / PARTSIZE); i < GetPartCount(); i++)
			{
				const uint64 qwPartStart = static_cast<uint64>(i) * PARTSIZE;
				const uint64 qwPartEnd = ((qwPartStart + PARTSIZE) > GetFileSize()) ? GetFileSize() : (qwPartStart + PARTSIZE);
				unsigned	uiFreq;
				COLORREF	color;

				if (qwGapEnd > qwPartEnd)
					qwGapEnd = qwPartEnd;	// The rest is in the next part

				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && ((uiFreq = m_srcPartFrequencies[i]) != 0))
				{
					if (IsPartDownloading(i))
						color = crPending;	// Downloading part in yellow
					else
						color = RGB(0, 0, (uiFreq < 11) ? (6 - ((uiFreq - 1u) >> 1u)) : 1);	//1(dark blue)..6(light blue)
				}
				else
					color = crMissing;

				ChunkBar.FillRange(qwGapBeg, qwGapEnd, color);

				qwGapBeg = qwGapEnd;
				qwGapEnd = pGap->qwEndOffset + 1ui64;
				if (qwGapBeg == qwGapEnd) // finished?
					break;
			}
		}
		ChunkBar.GenerateWSBar(pstrChunkBar);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A4AF management
void CPartFile::DownloadAllA4AF(bool bSameCat /* FALSE */)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (!m_A4AFSourceLists.empty())
	{
		ClientList			clientListCopy;
		CUpDownClient*		pClient;
	
		GetCopyA4AFSourceList(&clientListCopy);
		for (ClientList::const_iterator cIt = clientListCopy.begin(); cIt != clientListCopy.end(); cIt++)
		{
			pClient = *cIt;

			if(bSameCat)
			{
				if (pClient->m_pReqPartFile->GetCatID() == GetCatID())
					pClient->SwapToAnotherFile(this);
			}
			else
			{
				pClient->SwapToAnotherFile(this);
			}
		}
	}

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
byte* CPartFile::MMCreatePartStatus()
{
	EMULE_TRY

//	Create partstatus + info in mobilemule protocol specs
//	result needs to be deleted[] | slow, but not timecritical
	byte		*result = new byte[GetPartCount() + 1];
	uint64		qwPartBeg;
	unsigned	uiFreq, uiOctet;

	for (unsigned ui = 0; ui < GetPartCount(); ui++)
	{
		uiOctet = 0;
		if (IsPartComplete(ui))
			uiOctet = 1;
		else
		{
			qwPartBeg = static_cast<uint64>(ui) * PARTSIZE;
			if (IsComplete(qwPartBeg + static_cast<uint64>(0 * (PARTSIZE / 3)), qwPartBeg + static_cast<uint64>(1 * (PARTSIZE / 3) - 1)))
				uiOctet += 2;
			if (IsComplete(qwPartBeg + static_cast<uint64>(1 * (PARTSIZE / 3)), qwPartBeg + static_cast<uint64>(2 * (PARTSIZE / 3) - 1)))
				uiOctet += 4;
			if (IsComplete(qwPartBeg + static_cast<uint64>(2 * (PARTSIZE / 3)), qwPartBeg + static_cast<uint64>(3 * (PARTSIZE / 3) - 1)))
				uiOctet += 8;

			if ((uiFreq = static_cast<unsigned>(m_srcPartFrequencies[ui])) > 42)
				uiOctet += 0xF0;
			else
				uiOctet += (((uiFreq + 2u) / 3u) << 4u);
		}
		result[ui] = static_cast<byte>(uiOctet);
	}
	return result;

	EMULE_CATCH

	return NULL;
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::CheckAndAddPastComment(CUpDownClient *pClient)
{
#ifndef NEW_SOCKETS_ENGINE
	if (pClient->IsFileCommentEmpty() && (pClient->GetFileRating() == PF_RATING_NONE))
		return;

	if (pClient->m_pReqPartFile != this)
		return;

	m_pastCommentList.Add(pClient->GetUserHash(), pClient->GetUserName(), GetFileName(), pClient->GetFileComment(), pClient->GetFileRating());
	UpdateFileRatingCommentAvail();
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemovePastComment(CUpDownClient *pClient, bool bRestore)
{
#ifndef NEW_SOCKETS_ENGINE
	EMULE_TRY

	if (!pClient)
		return;

	if (bRestore)
	{
		CString	strPastComment;
		EnumPartFileRating	ePastRating;

		if ( (m_pastCommentList.GetCommentRating(pClient->GetUserHash(), &strPastComment, &ePastRating))
		     && (pClient->IsFileCommentEmpty())
		     && (pClient->GetFileRating() == PF_RATING_NONE) )
		{
		//	Restore past comment
			pClient->SetFileComment(strPastComment);
			pClient->SetFileRating(ePastRating);
		}
	}

	m_pastCommentList.Remove(pClient->GetUserHash());

	EMULE_CATCH
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
EnumCategories CPartFile::GetCatID() const
{
//	If catID is valid... (valid range is 1..CAT_PREDEFINED-1 but a
//	real check would have to scan the category map. This isn't the
//	best place to do that.
#ifndef VS2002 // In VS2002 the const cast operator causes an ambiguity
	if (static_cast<const _EnumCategories>(m_eCategoryID) >= CAT_PREDEFINED)
#else
	if (const_cast<CPartFile*>(this)->m_eCategoryID >= CAT_PREDEFINED)
#endif
		return CAT_NONE;
	else
		return m_eCategoryID;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::SetCatID(EnumCategories eCatID)
{
	m_eCategoryID = eCatID;

//	Set new prio
	if (IsPartFile())
	{
		int	iPriority = 0;

		if (eCatID != CAT_NONE)
			iPriority = CCat::GetCatByID(GetCatID())->GetPriority();

		switch (iPriority)
		{
			case 1:
				SetAutoPriority(false);
				SetPriority(PR_LOW, false);
				break;

			case 2:
				SetAutoPriority(false);
				SetPriority(PR_NORMAL, false);
				break;

			case 3:
				SetAutoPriority(false);
				SetPriority(PR_HIGH, false);
				break;

			case 4:
				SetAutoPriority(true);
				SetPriority(PR_HIGH, false);
			case 0:
				break;
		}

		if (IsPartFile() && !m_strTempDir.IsEmpty())
			SavePartFile();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::SetStatus(EnumPartFileStatuses in)
{
	m_eStatus = in;

	UpdateGUIAfterStateChange();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::UpdateGUIAfterStateChange()
{
#ifndef NEW_SOCKETS_ENGINE
//	Function can be called from CPartFile destructor on shutdown at that time GUI has been already destroyed
	if (g_App.m_pMDlg == NULL)
		return;

	EnumCategories	eCurCat = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetCurTabCat();

//	Changes in file status can affect whether the file belongs to a predefined category or not
	if (eCurCat >= CAT_PREDEFINED)
		g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.ChangeCategoryByID(eCurCat);
	else
		UpdateDisplayedInfo();

//	Update file counts in the tabs to reflect status changes
	g_App.m_pMDlg->m_wndTransfer.UpdateCatTabTitles();
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetRealFileSize() returns real file size on disk with respect to NTFS compression and/or NTFS sparse files
uint64 CPartFile::GetRealFileSize()
{
	return ::GetDiskFileSize(GetFilePath());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsStalled() performs stall check
bool CPartFile::IsStalled() const
{
	bool	bIsStalled = false;

	CTimeSpan	ts = CTime::GetCurrentTime() - GetLastDownTransfer();

//	If WARN_PERIOD_OF_NO_PROGRESS days have gone by without a single download...
//	(??? or maybe sooner if there are no needed parts available?)
	if (ts.GetTotalHours() >= 24 * WARN_PERIOD_OF_NO_PROGRESS)
		bIsStalled = true;

	return bIsStalled;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AllocateNeededSpace() is the preallocate function used to allocate the space needed by a file.
//	It uses a thread to let eMule still work and not drop sources while generating the file.
void CPartFile::AllocateNeededSpace()
{
	m_bIsPreallocated = true;

	AfxBeginThread(AllocateNeededSpaceProc, this, THREAD_PRIORITY_BELOW_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(), 0, 0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	AllocateNeededSpaceProc() is the thread created by AllocateNeededSpace().
//	It receives a pointer to 'm_hPartFileWrite' and the filesize-1 (where it has to write the bogus data to allocate space.
UINT CPartFile::AllocateNeededSpaceProc(LPVOID lpParameter)
{
	CPartFile	*pPartFile = reinterpret_cast<CPartFile*>(lpParameter);

	g_App.m_pPrefs->InitThreadLocale();

	try
	{
		pPartFile->m_hPartFileWrite.Seek(pPartFile->GetFileSize() - 1ui64, CFile::begin);
		pPartFile->m_hPartFileWrite.Write("1", 1);
		pPartFile->m_hPartFileWrite.Flush();

		pPartFile->SaveSettingsFile();
	}
	catch (CFileException *error)
	{
		AddLogLine( LOG_FL_SBAR | LOG_RGB_ERROR, IDS_FAILED_PREALLOCATION,
						 pPartFile->GetFileName(), GetErrorMessage(error) );

		pPartFile->m_bIsPreallocated = false;
		error->Delete();
	}

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	IsLastBlockComplete() returns status of last block of file (if downloaded the file was already allocated).
bool CPartFile::IsLastBlockComplete()
{
	return IsComplete(GetFileSize() - static_cast<uint64>(GetLastBlockSize()), GetFileSize() - 1ui64);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ClosePartFile() closes all .part file handles
void CPartFile::ClosePartFile()
{
	if (m_hPartFileWrite.m_hFile != INVALID_HANDLE_VALUE)
	{
		m_hPartFileRead.Close();
		m_hPartFileWrite.Close();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ReadFileForUpload() opens known file and read information.
//		Params:
//			qwOffset      - file offset to start reading from;
//			dwBytesToRead - number of bytes to read;
//			pbyteBuffer   - buffer to receive data.
//		Return:
//			< 0 in case of error, > 0 - information was read from a part file, else 0.
int CPartFile::ReadFileForUpload(uint64 qwOffset, uint32 dwBytesToRead, byte *pbyteBuffer)
{
	int	iRc = -2;

	EMULE_TRY

//	Synchronization with completion thread
//	will be unlocked on exit
	CSingleLock lockComplete(&m_csFileCompletion, TRUE);

	if (m_eStatus != PS_COMPLETE)
	{
	//	This file isn't complete yet
		m_hPartFileRead.Seek(qwOffset, CFile::begin);
		if (m_hPartFileRead.Read(pbyteBuffer, dwBytesToRead) == dwBytesToRead)
			iRc = 1;
	}
	else
	{
	//	This file is complete and is located in destination directory
		iRc = CKnownFile::ReadFileForUpload(qwOffset, dwBytesToRead, pbyteBuffer);
	}

	EMULE_CATCH

	return iRc;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetFirstLastChunk4Preview() sets Movie Preview Mode by checking media type and needed index size (last 1% of file)
void CPartFile::GetFirstLastChunk4Preview()
{
	EMULE_TRY

	if (GetMovieMode())
		SetMovieMode(0);
	else
	{
		if (IsAviKindMovie())
			SetMovieMode((GetLastPartSize() < static_cast<uint32>(GetFileSize() / 100ui64)) ? 7 : 1);
		else if (IsMpgMovie())
		{
			if (GetFileSize() < 209715200ui64)
				SetMovieMode(4);
			else
				SetMovieMode(5);
		}
		else if (IsArchivePreviewable())	// allow 1st chunk for better recovery
			SetMovieMode(4);
		else
			SetMovieMode(0);
	}
	SaveSettingsFile();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetGapListCopy() returns a protected copy of the gap list
void CPartFile::GetGapListCopy(CArray<Gap_Struct, Gap_Struct> *pGapArray)
{
	Gap_Struct	*pGap;

	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on the exit

	pGapArray->SetSize(gaplist.GetCount(), 0);
	pGap = pGapArray->GetData();

	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
		*pGap++ = *gaplist.GetNext(pos);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::SetFileName(const CString& NewName, bool bClearName)
{
//	Set the name & extension
	CKnownFile::SetFileName(NewName, bClearName);

	CString strExt = GetFileExtension();
	static const TCHAR s_apcPreviewableExt[][4] =
	{
		_T("zip"), _T("rar"), _T("cbz"), _T("cbr")
	};
	static const TCHAR s_apcAviMovieExt[][5] =
	{
		_T("avi"), _T("divx"), _T("xvid")
	};
	static const TCHAR s_apcAviKindMovieExt[][4] =
	{
		_T("ogm"), _T("mkv"), _T("wmv"), _T("mp4")
	};
	static const TCHAR s_apcMpgMovieExt[][5] =
	{
		_T("mpg"), _T("mpeg"), _T("vob"), _T("asf"), _T("rm"), _T("bin"), _T("mpe"), _T("dat")
	};
	static const TCHAR s_apcMpgAudioExt[][4] =
	{
		_T("mp3"), _T("mp2"), _T("mpa")
	};

//	Check previewable status
	m_bIsPreviewableArchive = false;
	for (unsigned ui = 0; ui < ARRSIZE(s_apcPreviewableExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcPreviewableExt[ui])) == 0)
		{
			m_bIsPreviewableArchive = true;
			break;
		}
	}

//	Check movie status
	m_cIsMovie = (ED2KFT_VIDEO == GetFileType() || strExt == _T("bin")) ? -1 : 0;

//	Check AVI movie status
	for (unsigned ui = 0; ui < ARRSIZE(s_apcAviMovieExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcAviMovieExt[ui])) == 0)
		{
			m_cIsMovie = 1;
			break;
		}
	}

//	Check AVI kind movie status
	for (unsigned ui = 0; ui < ARRSIZE(s_apcAviKindMovieExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcAviKindMovieExt[ui])) == 0)
		{
			m_cIsMovie = 2;
			break;
		}
	}

//	Check MPG movie status
	m_bIsMpgMovie = false;
	for (unsigned ui = 0; ui < ARRSIZE(s_apcMpgMovieExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcMpgMovieExt[ui])) == 0)
		{
			m_bIsMpgMovie = true;
			break;
		}
	}

//	Check MPG movie status
	m_bIsMpgAudio = false;
	for (unsigned ui = 0; ui < ARRSIZE(s_apcMpgAudioExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcMpgAudioExt[ui])) == 0)
		{
			m_bIsMpgAudio = true;
			break;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddRxCorruptedAmount(uint32 dwBadBytes)
{
	m_qwLostDueToCorruption += dwBadBytes;
	g_App.m_pPrefs->Add2LostFromCorruption(dwBadBytes);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::GetCopySourceList(EnumDLQState eClientDS, ClientList *pCopy, bool bClearSourceList /*= false*/)
{
	if (!pCopy->empty())
		pCopy->clear();

	if ((eClientDS < DS_LAST_QUEUED_STATE) && !m_SourceLists[eClientDS].empty())
	{
		EnterCriticalSection(&m_csSourceLists);

		if (bClearSourceList)
			pCopy->splice(pCopy->end(), m_SourceLists[eClientDS]);
		else
			pCopy->insert(pCopy->begin(), m_SourceLists[eClientDS].begin(), m_SourceLists[eClientDS].end());

		LeaveCriticalSection(&m_csSourceLists);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::GetCopySourceLists(uint32 dwListsMask, ClientList *pCopy, bool bClearSourceLists /*= false*/)
{
	if (!pCopy->empty())
		pCopy->clear();

	EnterCriticalSection(&m_csSourceLists);
	for (EnumDLQState eDS = DS_DOWNLOADING; eDS < DS_LAST_QUEUED_STATE; ++eDS, dwListsMask >>= 1)
	{
		if (((dwListsMask & 1) != 0) && !m_SourceLists[eDS].empty())
		{
			if (bClearSourceLists)
				pCopy->splice(pCopy->end(), m_SourceLists[eDS]);
			else
				pCopy->insert(pCopy->end(), m_SourceLists[eDS].begin(), m_SourceLists[eDS].end());
		}
	}
	LeaveCriticalSection(&m_csSourceLists);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::RemoveClientFromDLSourceList(CUpDownClient *pClient)
{
	EnumDLQState	eDS = pClient->GetDownloadState();

	if (eDS < DS_LAST_QUEUED_STATE)
	{
		uint32	dwListSizeBefore, dwListSizeAfter;

		EnterCriticalSection(&m_csSourceLists);

		dwListSizeBefore = m_SourceLists[eDS].size();
		m_SourceLists[eDS].remove(pClient);
		dwListSizeAfter = m_SourceLists[eDS].size();

		LeaveCriticalSection(&m_csSourceLists);

	//	Update availability information if a client was removed
		if (dwListSizeAfter != dwListSizeBefore)
		{
			NewSrcPartsInfo();
			return true;
		}
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddClientToSourceList(CUpDownClient *pClient, EnumDLQState eClientDS)
{
	if (pClient == NULL)
		return;

	if (eClientDS < DS_LAST_QUEUED_STATE)
	{
		EnterCriticalSection(&m_csSourceLists);

		if (find(m_SourceLists[eClientDS].begin(), m_SourceLists[eClientDS].end(), pClient) == m_SourceLists[eClientDS].end())
			m_SourceLists[eClientDS].push_back(pClient);

		LeaveCriticalSection(&m_csSourceLists);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsClientInSourceList(CUpDownClient *pClient)
{
	bool			bResult = false;
	EnumDLQState	eDS = pClient->GetDownloadState();

	if ((eDS < DS_LAST_QUEUED_STATE) && !m_SourceLists[eDS].empty())
	{
		EnterCriticalSection(&m_csSourceLists);
		ClientList::iterator itResult = find(m_SourceLists[eDS].begin(), m_SourceLists[eDS].end(), pClient);
		bResult = (itResult != m_SourceLists[eDS].end());
		LeaveCriticalSection(&m_csSourceLists);
	}
	return bResult;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::ClearSourceLists()
{
	EnterCriticalSection(&m_csSourceLists);
	for (EnumDLQState eDS = DS_DOWNLOADING; eDS < DS_LAST_QUEUED_STATE; ++eDS)
		m_SourceLists[eDS].clear();
	LeaveCriticalSection(&m_csSourceLists);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::SwapClientBetweenSourceLists(CUpDownClient *pClient, EnumDLQState eSourceDS, EnumDLQState eTargetDS)
{
//	Speed up swapping (i.e. don't call the related functions if client is outside the lists)

//	Check if we need to remove the client
	if (eSourceDS < DS_LAST_QUEUED_STATE)
	{
		EnterCriticalSection(&m_csSourceLists);
		m_SourceLists[eSourceDS].remove(pClient);
		pClient->ChangeDownloadState(eTargetDS);
	//	Check if we need to add client to another queue
		if (eTargetDS < DS_LAST_QUEUED_STATE)
		{
			m_SourceLists[eTargetDS].push_back(pClient);
			LeaveCriticalSection(&m_csSourceLists);
		}
		else
		{
			LeaveCriticalSection(&m_csSourceLists);

		//	Update file status information if client was removed from the queue
			NewSrcPartsInfo();
		}
	}
	else
	{
	//	Check if we need to add client to another queue
		if (eTargetDS < DS_LAST_QUEUED_STATE)
		{
			EnumPartFileStatuses eStatus = GetStatus();

		//	Don't attach the sources if a file is complete or stopped
			if ((eStatus != PS_COMPLETE) && (eStatus != PS_COMPLETING) && (eStatus != PS_STOPPED))
			{
				EnterCriticalSection(&m_csSourceLists);
				pClient->ChangeDownloadState(eTargetDS);
				m_SourceLists[eTargetDS].push_back(pClient);
				LeaveCriticalSection(&m_csSourceLists);
			}
		}
		else
			pClient->ChangeDownloadState(eTargetDS);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::AddClientToA4AFSourceList(CUpDownClient *pClient)
{
	if (pClient == NULL)
		return;

	EnterCriticalSection(&m_csSourceLists);

	if (find(m_A4AFSourceLists.begin(), m_A4AFSourceLists.end(), pClient) == m_A4AFSourceLists.end())
		m_A4AFSourceLists.push_back(pClient);

	LeaveCriticalSection(&m_csSourceLists);

//	As Process() isn't called for paused files, update A4AF count to display it properly
	m_uSrcA4AF = static_cast<uint16>(m_A4AFSourceLists.size());
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemoveClientFromA4AFSourceList(CUpDownClient *pClient)
{
	if (!m_A4AFSourceLists.empty())
	{
		EnterCriticalSection(&m_csSourceLists);

		m_A4AFSourceLists.remove(pClient);

		LeaveCriticalSection(&m_csSourceLists);

	//	As Process() isn't called for paused files, update A4AF count to display it properly
		m_uSrcA4AF = static_cast<uint16>(m_A4AFSourceLists.size());
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::GetCopyA4AFSourceList(ClientList *pCopy, bool bClearSourceList /*=false*/)
{
	if (!pCopy->empty())
		pCopy->clear();

	if (!m_A4AFSourceLists.empty())
	{
		EnterCriticalSection(&m_csSourceLists);

		if (bClearSourceList)
			pCopy->splice(pCopy->begin(), m_A4AFSourceLists);
		else
			pCopy->insert(pCopy->begin(), m_A4AFSourceLists.begin(), m_A4AFSourceLists.end());

		LeaveCriticalSection(&m_csSourceLists);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::ClearA4AFSourceList()
{
	EnterCriticalSection(&m_csSourceLists);
	m_A4AFSourceLists.clear();
	LeaveCriticalSection(&m_csSourceLists);
}
@


1.763
log
@Reduced H-file dependency.
@
text
@d988 2
a989 2
	CFile		file;
	CMemFile	MFile(8 * 1024);
a1129 1
	void	*pBufBeg, *pBufEnd;
a1149 1
	MFile.SeekToBegin();
d1161 1
a1161 2
		dwTmp = MFile.GetBufferPtr(CMemFile::bufferRead, ~0u, &pBufBeg, &pBufEnd);
		file.Write(pBufBeg, dwTmp);
@


1.762
log
@Fixed part file publishing on the server after rehashing issues on start (when corrupted parts were detected, file wasn't published on server until next restart, on top of that file paused state was lost);
Keep less part file gaps to achieve faster processing (before under some conditions like corruptions, consecutive gaps weren't merged together);
Avoided gap reallocation when exactly the same gap is added again;
Sped up gap list manipulations.
@
text
@d41 3
@


1.761
log
@Do auto clear completed on file completion only for the particular file instead on the whole download list (this should be more efficient);
Reduced H-file dependency.
@
text
@d1209 1
a1209 1
	uint32 dwCount = static_cast<uint32>(m_partHashArray.GetSize());
d1233 2
d1251 2
d1256 15
a1270 5
		SetStatus(PS_READY);
		SavePartFile();
	//	If a file is "ready" it can't be paused
		m_bPaused = false;
		return;
a1271 2
	SetStatus(PS_READY);
	SavePartFile();
d1274 1
a1274 1
#endif //NEW_SOCKETS_ENGINE
d1291 20
a1310 22
		if ((pGap->qwStartOffset >= qwStart) && (pGap->qwEndOffset <= qwEnd))
		{ // this gap is inside the new gap - delete
			gaplist.RemoveAt(pos2);
			m_qwGapsSum -= pGap->qwEndOffset - pGap->qwStartOffset + 1ui64;
			FillGapInParts(pGap->qwStartOffset, pGap->qwEndOffset);
			delete pGap;
		}
		else if ((pGap->qwStartOffset >= qwStart) && (pGap->qwStartOffset <= qwEnd))
		{ // a part of this gap is in the new gap - extend limit and delete
			qwEnd = pGap->qwEndOffset;
			gaplist.RemoveAt(pos2);
			m_qwGapsSum -= qwEnd - pGap->qwStartOffset + 1ui64;
			FillGapInParts(pGap->qwStartOffset, qwEnd);
			delete pGap;
		}
		else if ((pGap->qwEndOffset <= qwEnd) && (pGap->qwEndOffset >= qwStart))
		{ // a part of this gap is in the new gap - extend limit and delete
			qwStart = pGap->qwStartOffset;
			gaplist.RemoveAt(pos2);
			m_qwGapsSum -= pGap->qwEndOffset - qwStart + 1ui64;
			FillGapInParts(qwStart, pGap->qwEndOffset);
			delete pGap;
d1312 12
a1323 3
		else if ((qwStart >= pGap->qwStartOffset) && (qwEnd <= pGap->qwEndOffset))
		{ // new gap is already inside this gap - return
			return;
d1513 1
a1513 1
	for (pos1 = gaplist.GetHeadPosition(); (pos2 = pos1) != NULL; )
d1517 40
a1556 31
		if ((pGap->qwStartOffset >= qwStart) && (pGap->qwEndOffset <= qwEnd))
		{ // our part fills this gap completely
			gaplist.RemoveAt(pos2);
			m_qwGapsSum -= pGap->qwEndOffset - pGap->qwStartOffset + 1ui64;
			FillGapInParts(pGap->qwStartOffset, pGap->qwEndOffset);
			delete pGap;
		}
		else if ((pGap->qwStartOffset >= qwStart) && (pGap->qwStartOffset <= qwEnd))
		{ // a part of this gap is in the part - set limit
			m_qwGapsSum -= qwEnd - pGap->qwStartOffset + 1ui64;
			FillGapInParts(pGap->qwStartOffset, qwEnd);
			pGap->qwStartOffset = qwEnd + 1ui64;
		}
		else if ((pGap->qwEndOffset <= qwEnd) && (pGap->qwEndOffset >= qwStart))
		{ // a part of this gap is in the part - set limit
			m_qwGapsSum -= pGap->qwEndOffset - qwStart + 1ui64;
			FillGapInParts(qwStart, pGap->qwEndOffset);
			pGap->qwEndOffset = qwStart - 1ui64;
		}
		else if ((qwStart >= pGap->qwStartOffset) && (qwEnd <= pGap->qwEndOffset))
		{
			uint64 qwTmp = pGap->qwEndOffset;

			pGap->qwEndOffset = qwStart - 1;
			pGap = new Gap_Struct;
			pGap->qwStartOffset = qwEnd + 1;
			pGap->qwEndOffset = qwTmp;
			m_qwGapsSum -= qwEnd - qwStart + 1ui64;
			FillGapInParts(qwStart, qwEnd);
			gaplist.InsertAfter(pos1, pGap);
			break;
@


1.760
log
@Ability to add known LowID source through remote client shared files list; Fast byte swap for ntohl and ntohs.
@
text
@d39 2
d1376 1
a1376 1
//	IsPartFull() returns true if all data of the was received.
d3182 1
a3182 1
		g_App.m_pDownloadList->ClearCompleted(CAT_ALL);
@


1.759
log
@Added A4AF sources while creating a file link with sources (append some A4AF sources at the end if less than 20 normal sources available).
@
text
@d2348 1
a2348 1
			dwUserIDHyb = IsLowID(dwUserID) ? dwUserID : ntohl(dwUserID);
d4157 1
a4157 1
			source.dwSrcIDHybrid = ntohl(source.dwSrcIDHybrid);
d4956 1
a4956 1
void CPartFile::AddClientSource(CClientSource *pSource, int iSource, bool bExchanged, byte byteSourceExchangeVersion)
d4973 1
a4973 1
			(ntohl(g_App.m_pServerConnect->GetLocalIP()) == pSource->dwSrcIDHybrid) )
d4979 1
a4979 1
		(ntohl(g_App.m_pServerConnect->GetClientID()) == pSource->dwSrcIDHybrid) )
d4987 3
a4989 1
		return;
d4997 2
a4998 2
		CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, pSource->dwSrcIDHybrid, pSource->sourcePort, pSource->serverIP, pSource->serverPort, pSource->achUserHash);
		if (bExchanged && pNewSource)
d5003 1
a5003 1
			if (byteSourceExchangeVersion > 1)
@


1.758
log
@Fixed Source Exchange replies after file completion (no sources were provided for requests until application restart).
@
text
@d4029 1
a4029 1
				if (byteUsedVer >= 4)	// CryptSettings - SourceExchange V4
d4031 2
a4032 1
					// 5 Reserved
d4956 1
a4956 1
void CPartFile::AddClientSource(CClientSource* pSource, int iSource, bool bExchanged, byte byteSourceExchangeVersion)
a5056 1
		{
d5058 1
a5058 3
			continue;
		}
		if ((iSourceCnt == 0) || (newSourceList.GetCount() < iSourceCnt) || (pSource->GetAvailablePartCount() > newSourceList.GetTail()->GetAvailablePartCount()))
a5062 2
			ASSERT(newSourceList.GetCount() < iSourceCnt);

d5080 15
@


1.757
log
@Don't save DownCompletedFiles statistics value to the disk after every file completion (do it together with other preferences.ini values).
@
text
@d3915 2
a3916 2
	if (GetSourceCount() == 0)
		return NULL;
@


1.756
log
@Removed duplicated attempts to close ini file (directly by the call and indirectly by destructor).
@
text
@a3163 1
	g_App.m_pPrefs->SaveCompletedDownloadsStat();		// Saves cumDownCompletedFiles to INI
@


1.755
log
@Removed smooth migration of .part.dir files.
@
text
@d4373 1
a4373 1
	CIni filesettings(strIniFile, INI_MODE_READONLY | INI_MODE_ANSIONLY);
a4383 2
	filesettings.CloseWithoutSave();

@


1.754
log
@Reduced H-file dependency.
@
text
@a664 17
#if 1	//code left for smooth migration, delete in v1.2f

		if (m_strAlternativePath.IsEmpty())
		{
		CStdioFile	f;
		CString		strPath(m_strFilePath);

		strPath += _T(".dir");
		if (f.Open(strPath, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
		{
			f.ReadString(m_strAlternativePath);
			f.Close();
		}
		if (!m_strAlternativePath.IsEmpty())	//	resave old setting to the new location
			SaveSettingsFile();
		}
#endif
a3100 7
#if 1	//code left for smooth migration, delete in v1.2f

//	Remove .dir file
	strFileToRemove = strFullPartFileName + _T(".dir");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);
#endif
a3330 7
#if 1	//code left for smooth migration, delete in v1.2f

//	Remove .dir file
	strFileToRemove = strFilePath + _T(".dir");
	if (_tremove(strFileToRemove) && errno != ENOENT)
		AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strFileToRemove);
#endif
@


1.753
log
@Corrected error message issued while saving part.met file (error message was totally wrong).
@
text
@d20 1
a25 1
	#include "SafeFile.h"
@


1.752
log
@Changed preview mode for mp4 files to be similar to avi instead of mpg.
@
text
@d1170 1
a1170 1
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_DELETEFAILED, strTempName);
@


1.751
log
@Added get first chunk option for .mp4 files {muleteer}.
@
text
@d5810 1
a5810 1
		_T("ogm"), _T("mkv"), _T("wmv")
d5814 1
a5814 1
		_T("mpg"), _T("mpeg"), _T("vob"), _T("mp4"), _T("asf"), _T("rm"), _T("bin"), _T("mpe"), _T("dat")
@


1.750
log
@Fixed A4AF source count display for paused files.
@
text
@d5814 1
a5814 1
		_T("mpg"), _T("mpeg"), _T("vob"), _T("asf"), _T("rm"), _T("bin"), _T("mpe"), _T("dat")
@


1.749
log
@Minor Unicode correction.
@
text
@d6042 3
d6056 3
@


1.748
log
@WebServer: improved download progress bar representation for large files {DonGato}.
@
text
@d2838 1
a2838 1
	if (fname.Right(1) == ')')
d2841 1
a2841 1
		int ob = fname.ReverseFind( '(' );
@


1.747
log
@Pass an output string as a parameter for WS progress bar generation.
@
text
@d5385 1
a5385 13
	const TCHAR crProgress = _T('0');										// Green
	const TCHAR crHave = _T('1');											// Black
	const TCHAR crPending = _T('2');											// Yellow
	const TCHAR crMissing = _T('3');											// Red
	static const TCHAR crWaiting[6] = { _T('4'), _T('5'), _T('6'), _T('7'), _T('8'), _T('9')};	// Differents blue

	for (uint32 i = 0; i < dwSize; i++)
		pstrChunkBar->AppendChar(crHave);

	double dFileSz = static_cast<double>(GetFileSize());
	double unit = static_cast<double>(dwSize) / dFileSz;

	POSITION				pos;
d5389 4
a5392 1
		CharFillRange(pstrChunkBar, 0, dFileSz * unit, crProgress);
d5395 16
a5410 9
	//	Red gaps
	//	Will be unlocked on block exit
		CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);

		for (pos = gaplist.GetHeadPosition(); pos != NULL;)
		{
			Gap_Struct	   *pGap = gaplist.GetNext(pos);
			uint64			qwGapBeg = pGap->qwStartOffset;
			uint64			qwGapEnd = pGap->qwEndOffset + 1ui64;
d5416 2
d5422 1
a5422 4
				TCHAR	color;
				uint32	dwFreq;

				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && ((dwFreq = m_srcPartFrequencies[i]) != 0))
d5427 1
a5427 1
						color = (dwFreq < 10) ? crWaiting[dwFreq / 2] : crWaiting[5];
d5432 1
a5432 1
				CharFillRange(pstrChunkBar, static_cast<double>(qwGapBeg) * unit, static_cast<double>(qwGapEnd) * unit, color);
d5440 1
a5440 1
	//	m_csGapListAndPartStatus is released here
a5445 8
void CPartFile::CharFillRange(CString* buffer, double start, double dblEnd, TCHAR cColor)
{
	uint32	dwEnd = static_cast<uint32>(dblEnd);

	for (uint32 i = static_cast<uint32>(start); i <= dwEnd; i++)
		buffer->SetAt(i, cColor);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.746
log
@Simplified logging system implementation.
@
text
@d5380 2
a5381 2
//	Ornis: Creating progressive presentation of the partfilestatuses - for webdisplay
CString CPartFile::GetProgressString(uint32 dwSize)
a5389 1
	CString	strChunkBar;
d5391 2
a5392 2
	for (uint32 i = 0; i <= (dwSize + 1); i++)
		strChunkBar.AppendChar(crHave);	// One more for safety
d5401 1
a5401 1
		CharFillRange(&strChunkBar, 0, dFileSz * unit, crProgress);
d5435 1
a5435 1
				CharFillRange(&strChunkBar, static_cast<double>(qwGapBeg) * unit, static_cast<double>(qwGapEnd) * unit, color);
a5445 2
	return strChunkBar;

a5446 2

	return _T("");
@


1.745
log
@Reduced H-file dependency.
@
text
@d156 1
a156 1
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_INVALIDLINK), error);
d184 2
a185 2
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_SKIPZEROLENGTHFILE), m_strFileName);
#endif //NEW_SOCKETS_ENGINE
d212 2
a213 2
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_INVALIDLINK), error);
#endif //NEW_SOCKETS_ENGINE
d360 1
a360 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), GetFileName(), GetResString(dwResStrId));
d388 1
a388 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_CREATEPARTFILE));
d394 1
a394 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_CREATEPARTFILE));
d464 1
a464 1
			AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_OPENMET), m_strPartMetFileName, m_strFileName);
d466 1
a466 1
#endif //NEW_SOCKETS_ENGINE
d475 1
a475 1
			AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_BADMETVERSION), m_strPartMetFileName, m_strFileName);
d477 1
a477 1
#endif //NEW_SOCKETS_ENGINE
d484 2
a485 2
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_HASHSETCORR), in_filename);
#endif //NEW_SOCKETS_ENGINE
d503 1
a503 1
						AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_METCORRUPT), m_strPartMetFileName, m_strFileName);
d688 1
a688 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_METCORRUPT), m_strPartMetFileName, m_strFileName);
d690 1
a690 3
		{
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEERROR), m_strPartMetFileName, m_strFileName, GetErrorMessage(error));
		}
d749 1
a749 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), m_strFilePath, GetResString(dwResStrId));
d796 2
a797 2
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), m_strFilePath, m_strFileName);
#endif //NEW_SOCKETS_ENGINE
d804 2
a805 2
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), m_strFilePath, m_strFileName);
#endif //NEW_SOCKETS_ENGINE
d877 1
a877 1
			AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_REHASH), m_strFileName);
d921 1
a921 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to rename part.met file '%s' to '%s' - %s"), m_strFullName, strTempName, _tcserror(errno));
d927 2
a928 2
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to copy .bak file '%s' to '%s'"), strTempName, m_strFullName);
		AddLogLine(false, RGB_LOG_ERROR_TXT + GetResString(IDS_TRYTORECOVER_FAIL), m_strFullName);
d932 1
a932 1
	AddLogLine(false, IDS_TRYTORECOVER, m_strFullName);
d937 1
a937 1
		AddLogLine(false, RGB_LOG_SUCCESS + GetResString(IDS_RECOVERED_PARTMET), GetFileName());
d939 1
a939 1
		AddLogLine(false, RGB_LOG_ERROR_TXT + GetResString(IDS_TRYTORECOVER_FAIL), m_strFullName);
d975 2
a976 2
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_SAVEMET), GetResString(IDS_ERR_PART_FNF), m_strPartMetFileName, m_strFileName);
#endif //NEW_SOCKETS_ENGINE
d1170 1
a1170 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strTempName);
d1185 2
a1186 2
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_SAVEMET), GetErrorMessage(error), m_strPartMetFileName, m_strFileName);
#endif //NEW_SOCKETS_ENGINE
d1197 1
a1197 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to remove '%s' - %s"), m_strFullName, _tcserror(errno));
d1201 1
a1201 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to move temporary part.met file '%s' to '%s' - %s"), strTempName, m_strFullName, _tcserror(errno));
d1238 2
a1239 2
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_FOUNDCORRUPTION), i, GetFileName());
#endif //NEW_SOCKETS_ENGINE
d1262 2
a1263 2
			AddLogLine(false, IDS_HASHINGDONE, GetFileName());
#endif //NEW_SOCKETS_ENGINE
d2472 1
a2472 1
//		AddDebugLogLine(_T("Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2664 1
a2664 1
//		AddDebugLogLine(_T("Priority 1 (Preview part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2677 1
a2677 1
//			AddDebugLogLine(_T("Priority 2 (Rarest unfinished part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2707 1
a2707 1
//			AddDebugLogLine(_T("Priority 3 (Rarest unrequested part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2716 1
a2716 1
//		AddDebugLogLine(_T("Priority 4 (Widespread unfinished part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2726 1
a2726 1
//		AddDebugLogLine(_T("Priority 5 (Widespread unrequested part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2742 1
a2742 1
	AddDebugLogLine(strDebug);
d2886 1
a2886 1
				AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Couldn't delete fakes.rar (%s)"), strFakesFile);
d2896 1
a2896 1
					AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Couldn't delete fakes.rar (%s)"), strFakesFile);
d3010 1
a3010 1
				AddDebugLogLine(_T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
d3019 1
a3019 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_OUTMEM));
d3024 1
a3024 1
			AddLogLine(true, RGB_LOG_ERROR + str);
d3034 1
a3034 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), GetErrorMessage(error));
d3048 1
a3048 1
				AddDebugLogLine(_T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
d3059 1
a3059 1
			AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_COMPLETIONFAILED2));
d3077 1
a3077 1
			AddDebugLogLine(_T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
d3090 2
a3091 2
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), _tcserror(errno));
			AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_COMPLETIONFAILED2));
d3115 1
a3115 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strTempFullName);
d3123 1
a3123 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3129 1
a3129 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3134 1
a3134 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3139 1
a3139 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3144 1
a3144 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3149 1
a3149 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3163 1
a3163 1
	AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_DOWNLOADDONE), GetFileName(), strCategory);
d3171 1
a3171 1
		AddLogLine(true, IDS_DOWNLOADRENAMED, _tcsrchr(newname, _T('\\')) + 1);
d3233 1
a3233 1
			g_App.AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_FAKE_SUCCESS_UPDATE), g_App.m_pPrefs->GetFakesDatVersion(), g_App.m_pPrefs->GetDLingFakeListVersion());
d3340 1
a3340 1
	AddLogLine(false, strFileToRemove, GetFileName());
d3349 1
a3349 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), m_strFullName);
d3352 1
a3352 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), m_strFilePath);
d3360 1
a3360 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3366 1
a3366 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3371 1
a3371 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3376 1
a3376 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3381 1
a3381 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3386 1
a3386 1
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strFileToRemove);
d3430 1
a3430 1
	AddLogLine(true, RGB_LOG_WARNING + GetResString(dwResErrStrID), GetFileName());
d4147 1
a4147 1
			g_App.m_pMDlg->AddDebugLogLine(_T("Received invalid SX2 packet (v%u) from %s for %s"),
d4175 1
a4175 1
		g_App.m_pMDlg->AddDebugLogLine(_T("Received invalid SX%c packet (v%u) of data size %u (%u) from %s for %s"),
d4273 1
a4273 4
		CString	strTmp(RGB_LOG_ERROR);

		strTmp.AppendFormat(GetResString(IDS_TRAFFICDAT_CORRUPT), GetStatsFullPath());
		AddLogLine(true, strTmp);
d4469 1
a4469 1
		AddDebugLogLine(_T("File '%s' has already been written from %I64u to %I64u size %u"), GetFileName(), qwStart, qwEnd, dwDataLen);
d4642 2
a4643 2
					AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_PARTCORRUPT), iPartNum, GetFileName());
#endif //NEW_SOCKETS_ENGINE
d4689 2
a4690 2
					AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_ICHWORKED), iPartNum, m_strFileName, CastItoXBytes(dwSaved));
#endif //NEW_SOCKETS_ENGINE
d4741 2
a4742 2
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
			AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_DWTOT_FS), strTemp);
d4753 2
a4754 2
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetErrorMessage(error));
#endif //NEW_SOCKETS_ENGINE
d4765 2
a4766 2
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetResString(IDS_UNKNOWN));
#endif //NEW_SOCKETS_ENGINE
d5123 1
a5123 1
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_SOURCELINKFAILED));
d5150 1
a5150 1
	AddDebugLogLine(_T("Generated ed2k link with %u sources for file '%s' (part count %u)"), newSourceList.GetCount(), GetFileName(), GetPartCount());
d5155 1
a5155 1
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("| User: %s - Available part count: %u"), pSource->GetUserName(), pSource->GetAvailablePartCount());
d5707 1
a5707 1
		AddLogLine( true, RGB_LOG_ERROR + GetResString(IDS_FAILED_PREALLOCATION),
@


1.744
log
@More efficient ini string reading; Formatting.
@
text
@d32 1
a2814 1
		{
a2815 1
		}
@


1.743
log
@Corrected reporting of corrupted part traffic data files (no multiple reports for traffic.dat corruption; report actual corrupted file name for .part.stats corruptions) {Vladimir (SV)}.
@
text
@d1 2
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
d3414 1
a3414 1
	else if ((dwPartCnt != 1) && !GetPartHash(dwPartNum))
d4419 1
a4419 1
	m_strAlternativePath = filesettings.GetString(_T("AltDestDir"), _T(""));
@


1.742
log
@Unified way to prepare link;
Corrected an issue when uft8 conversion wasn't used for a link with sources (thanks eklmn for confirmation).
@
text
@d4272 1
a4272 1
	if (LoadFromFileTraffic(fh, version) == false)
d4274 7
@


1.741
log
@Removed meaningless set/restore brush around FillRect (drawing of flat part file bar).
@
text
@d5135 1
a5135 5
	CString	strLink;

	strLink.Format( _T("ed2k://|file|%s|%I64u|%s|/"),
		g_App.StripInvalidFilenameChars(GetFileName(), false),  // Spaces to dots
		GetFileSize(), HashToString(GetFileHash()) );
@


1.740
log
@H-file reorganization.
@
text
@a1741 1
		CBrush	   *pOldBrush;
a1745 1
		pOldBrush = dc->SelectObject(&pr_Brush);
a1751 1
		dc->SelectObject(&pe_Brush);
a1757 1
		dc->SelectObject(&rgb_Brush);
a1758 2

		dc->SelectObject(pOldBrush);
@


1.739
log
@Suppressed warning introduced by other changes.
@
text
@d36 1
@


1.738
log
@changed the intialization of thread locale
@
text
@d2317 1
a2317 1
	int iSourceCountPlusNew = GetSourceCount() + byteCount;
d2319 1
a2319 1
	if ( iSourceCountPlusNew > g_App.m_pPrefs->GetMaxSourcePerFile()
d2322 1
a2322 1
		RemoveNoNeededSources(iSourceCountPlusNew - g_App.m_pPrefs->GetMaxSourcePerFile());
@


1.737
log
@Proper share mode for open files (before other applications could write to a file while we were reading).
@
text
@a4345 2
	EMULE_TRY

d4351 3
a4353 2
	if (g_App.m_pPrefs->IsNTBased())
		SetThreadLocale(g_App.m_pPrefs->GetLanguageID());
d5702 2
@


1.736
log
@Added Video Player parameters {glaskrug/Lastwebpage} -- at this moment only manual configuration in preferences.ini "VideoPlayerArgs".
@
text
@d33 1
d4251 1
a4251 1
	FILE	*fh = _tfopen(GetStatsFullPath(), _T("rb"));
d4303 1
a4303 1
	FILE *fh = _tfopen(GetStatsFullPath(), _T("wb"));
@


1.735
log
@Rolled back incorrect modification applied recently.
@
text
@d3807 1
a3807 1
		CString strPlayer = g_App.m_pPrefs->GetVideoPlayer();
d3817 1
a3817 1
			CString strPlayerPath;
d3822 4
a3825 1
			ShellExecute(NULL, _T("open"), strPlayer, strLine, strPlayerPath, SW_SHOWNORMAL);
@


1.734
log
@fixed possible access with NULL pointer
@
text
@d5604 1
a5604 1
		if (GetCatID() != CAT_NONE)
@


1.733
log
@Fixed 'improved comment processing' which screwed comment processing big time.
@
text
@d5604 1
a5604 1
		if (eCatID != CAT_NONE)
@


1.732
log
@improved comment processing
@
text
@d4968 1
a4968 1
	return static_cast<EnumPartFileRating>(dwNum);	//0 returned if no ratings found
@


1.731
log
@Formatting.
@
text
@d4968 1
a4968 1
	return static_cast<_EnumPartFileRating>(dwNum);	//0 returned if no ratings found
@


1.730
log
@Preparation to add player parameters; Proper passing player parameters to a thread;
Better compatibility to run default system preview application (original) -- when player is not specified.
@
text
@d598 1
a598 1
						statistic.alltimetransferred = (statistic.alltimetransferred & (0xFFFFFFFFi64 << 32)) | newtag->GetIntValue();
d603 1
a603 1
						statistic.alltimetransferred = (statistic.alltimetransferred & 0xFFFFFFFF) |
d609 1
a609 1
						statistic.alltimerequested = newtag->GetIntValue();
d614 1
a614 1
						statistic.alltimeaccepted = newtag->GetIntValue();
@


1.729
log
@Increased upper range for 'File Buffer Size', setting was made compatible with original (setting name was changed from "FileBufferSizePref" to "FileBufferSize", smooth migration is in place with slight deviation of values; Bigger File Buffer Size is recommended for higher speeds to stabilize and slightly improve downloading speed; New configuration is done with different granuality);
Preparations for comprehensive exception handling.
@
text
@d3801 1
a3801 1
		pThread->SetValues(this, g_App.m_pPrefs->GetVideoPlayer());
a3810 1
		{
a3811 1
		}
d3814 1
a3814 3
		{
			ShellExecute(NULL, _T("open"), strLine, NULL, NULL, SW_SHOWNORMAL);
		}
@


1.728
log
@added Unicode support for met-files
@
text
@d1915 2
a1916 2
	if (m_bDataFlushReq
		|| (m_nTotalBufferData > (static_cast<uint32>(g_App.m_pPrefs->GetFileBufferSize()) * 30000))
d4348 5
@


1.727
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d1023 5
@


1.726
log
@Recover my work, overwrote by Fuxie - DK.
@
text
@d4398 1
a4398 1
	CIni filesettings(strIniFile, true);
d4423 1
a4423 1
	CIni filesettings(strIniFile);
@


1.725
log
@Data type converted into 32bit from 16; Suppressed compiler warnings [Aw3].
@
text
@d2537 1
a2537 1
	uint32		dwMostCompletedRarePartIdx, dwMostCompletedPartIdx;
d3941 2
a5681 2
	HANDLE	lTh;
	DWORD	lThID;
d5684 1
a5684 2
	lTh = CreateThread(NULL, 0L, AllocateNeededSpaceProc, this, 0, &lThID);
	CloseHandle(lTh);
d5689 1
a5689 1
DWORD WINAPI CPartFile::AllocateNeededSpaceProc(LPVOID lpParameter)
@


1.724
log
@Use AfxBeginThread function for thread creation to become CRT friendly.
Suppressed level 4 warnings
@
text
@d540 1
a540 1
						if ((priority = newtag->GetIntValue()) == PR_AUTO)
d556 1
a556 1
						m_bPaused = newtag->GetIntValue();
d633 1
a633 1
							uint16 gapkey = atoi(&pcTagName[1]);
d853 1
a853 1
	bool	bIsGapListEmpty = gaplist.IsEmpty();
d868 1
a868 1
		uint32	dwFileDate = m_timeLastDownTransfer.GetTime();
d983 1
a983 1
	m_timetLastWriteDate = lwtime.GetTime();
d1009 1
a1009 1
	uint16 uParts = m_partHashArray.GetCount();
d1081 1
a1081 1
		tagWr.WriteToFile(FT_LASTSEENCOMPLETE, lastseencomplete.GetTime(), MFile);
d1768 4
a1771 4
	uint16 parts = GetED2KPartCount();
	file->Write(&parts, 2);
	uint16 done = 0;
	while (done != parts)
d1777 2
a1778 2
			if ( ((done == (parts - 1)) && (parts != GetPartCount())) ||
				(IsPartShared(done) && IsPartComplete(done)) )
d1781 1
a1781 1
			if (++done == parts)
d1941 1
a1941 1
	m_uNumTransferringSrcs = m_SourceLists[DS_DOWNLOADING].size();
d1947 1
a1947 1
		m_uSrcConnecting = m_SourceLists[DS_CONNECTING].size();
d1983 1
a1983 1
		m_uSrcConnViaServer = m_SourceLists[DS_WAITCALLBACK].size();
d2014 1
a2014 1
		m_uSrcConnected = m_SourceLists[DS_CONNECTED].size();
d2059 1
a2059 1
		m_uSrcNNP = m_SourceLists[DS_NONEEDEDPARTS].size();
d2083 1
a2083 1
			m_uSrcOnQueue = m_SourceLists[DS_ONQUEUE].size();
d2124 1
a2124 1
		m_uSrcLowIDOnOtherServer = m_SourceLists[DS_LOWID_ON_OTHER_SERVER].size();
d2137 1
a2137 1
		m_uSrcWaitForFileReq = m_SourceLists[DS_WAIT_FOR_FILE_REQUEST].size();
d2173 1
a2173 1
		m_uSrcLowToLow = m_SourceLists[DS_LOWTOLOWID].size();
d2181 1
a2181 1
		bool bIsNNS;
d2234 1
a2234 1
						bIsNNS = pSource->m_otherNoNeededMap.Lookup(this,dwLastNoNeededCheckTime);
d2243 1
a2243 1
		m_uSrcA4AF = m_A4AFSourceLists.size();
d2472 1
a2472 1
		return dwGoodPart;
d2537 1
a2537 1
	uint32		dwMostCompletedRarePartIdx = 0, dwMostCompletedPartIdx = 0;
d2744 1
a2744 1
	return dwGoodPart;
d3756 1
a3756 2
		if (m_eStatus == PS_COMPLETING || m_eStatus == PS_COMPLETE)
		{
a3757 1
		}
d3765 1
a3765 1
		uint32	iSeconds = timeSpan.GetTotalSeconds();
d3767 2
a3768 2
		if (iSeconds > 10)
			m_AvgDataRate = static_cast<uint32>((GetSessionTransferred() /*+ GetDataRate()*/) / static_cast<uint64>(iSeconds /*+ 1*/));
a3940 2
	NOPRM(uRequestedOpt);	// We don't support any special SX2 options yet, reserved for later use

d4120 1
a4120 1
		dwDataSize = packetStream->GetLength() - packetStream->GetPosition();
d4153 1
a4153 1
		dwDataSize = packetStream->GetLength() - packetStream->GetPosition();
d4391 2
a4392 1
	CString strIniFile(m_strFilePath);
d4399 4
a4402 5
	byte Mode = filesettings.GetInt(_T("MoviePreviewMode"), 0);

	if ((Mode > 7) || ((Mode & 6) == 2) || (Mode == 6))	// Check for valid values 0, 1, 4, 5, 7
		Mode = 0;
	CKnownFile::SetMovieMode(Mode);
d4785 1
a4785 1
	bool finished = gaplist.IsEmpty();	//	no need to crash on the empty list...
d4907 1
a4907 4
	int num, tot, iRate;

	num = tot = 0;

d4915 2
a4916 2
		iRate = pSource->GetFileRating();
		if (iRate > 0)
d4918 1
a4918 1
			num++;
d4920 2
a4921 2
			if (iRate == PF_RATING_GOOD || iRate == PF_RATING_FAIR)
				iRate = (iRate == PF_RATING_GOOD) ? 4 : 3;
d4923 1
a4923 1
			tot += iRate;
d4929 1
a4929 1
		iRate = m_pastCommentList.GetNext(pos).GetRating();
d4931 1
a4931 1
		if (iRate > 0)
d4933 1
a4933 1
			num++;
d4935 2
a4936 2
			if (iRate == PF_RATING_GOOD || iRate == PF_RATING_FAIR)
				iRate = (iRate == PF_RATING_GOOD) ? 4 : 3;
d4938 1
a4938 1
			tot += iRate;
d4942 2
a4943 2
	iRate = GetFileRating();
	if (iRate > 0)
d4945 4
a4948 4
			num++;
		//	Bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
			if (iRate == PF_RATING_GOOD || iRate == PF_RATING_FAIR)
				iRate = (iRate == PF_RATING_GOOD) ? 4 : 3;
d4950 1
a4950 1
			tot += iRate;
d4953 1
a4953 1
	if (num > 0)
d4955 1
a4955 1
		num = static_cast<double>(tot) / num + .5;	//Cax2 - get the average of all the ratings
d4957 2
a4958 2
		if (num == 3 || num == 4)
			num = (num == 3) ? PF_RATING_FAIR : PF_RATING_GOOD;
d4960 1
a4960 1
	return static_cast<_EnumPartFileRating>(num);	//Cax2 - if no ratings found, will return 0!
d5377 1
a5377 1
CString CPartFile::GetProgressString(uint16 size)
d5388 1
a5388 1
	for (uint16 i = 0; i <= (size + 1); i++)
d5392 1
a5392 1
	double unit = static_cast<double>(size) / dFileSz;
d5454 1
a5454 1
	for (uint32 i = start; i <= dwEnd; i++)
d5680 2
d5684 2
a5685 1
	AfxBeginThread(AllocateNeededSpaceProc, this, THREAD_PRIORITY_BELOW_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(), 0, 0);
d5690 1
a5690 1
UINT CPartFile::AllocateNeededSpaceProc(LPVOID lpParameter)
@


1.723
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d2537 1
a2537 1
	uint32		dwMostCompletedRarePartIdx, dwMostCompletedPartIdx;
d3943 2
a5686 2
	HANDLE	lTh;
	DWORD	lThID;
d5689 1
a5689 2
	lTh = CreateThread(NULL, 0L, AllocateNeededSpaceProc, this, 0, &lThID);
	CloseHandle(lTh);
d5694 1
a5694 1
DWORD WINAPI CPartFile::AllocateNeededSpaceProc(LPVOID lpParameter)
@


1.722
log
@Extended INI interface to allow opening only in read-only mode (this way file isn't created when it didn't exist before) [Aw3];
Eliminated extra disk I/O while reading .met.settings files [Aw3].
@
text
@d832 1
a832 1
	INT_PTR iSize = m_partHashArray.GetCount();
d834 1
a834 1
	if (iSize != GetED2KPartHashCount())
d1111 1
a1111 1
	uint32	j;
d1126 3
a1128 2
	dwTagCount += m_tagArray.GetCount();
	for (j = 0; j != m_tagArray.GetCount(); j++)
@


1.721
log
@Fixed corruption of .part.met files when disk is full [Aw3].
@
text
@a4394 3
	if (PathFileExists(strIniFile))
	{
		CIni filesettings(strIniFile);
d4396 4
a4399 2
		filesettings.SetDefaultCategory(_T("Settings"));
		byte Mode = filesettings.GetInt(_T("MoviePreviewMode"), 0);
d4401 6
a4406 6
		if ((Mode > 7) || ((Mode & 6) == 2) || (Mode == 6))	// Check for valid values 0, 1, 4, 5, 7
			Mode = 0;
		CKnownFile::SetMovieMode(Mode);
		m_bStopped = filesettings.GetBool(_T("StoppedStatus"), m_bStopped);
		m_bIsPreallocated = filesettings.GetBool(_T("Preallocated"), m_bIsPreallocated);
		m_strAlternativePath = filesettings.GetString(_T("AltDestDir"), _T(""));
d4408 1
a4408 2
		filesettings.CloseWithoutSave();
	}
@


1.720
log
@Generate less code for some logging; Clean-up [Aw3].
@
text
@a990 6
	if (_tremove(strTempName) && errno != ENOENT)
#ifndef NEW_SOCKETS_ENGINE
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strTempName);
#else
		;
#endif //NEW_SOCKETS_ENGINE
d992 15
a1006 1
	CStdioFile file;
d1008 6
a1013 4
	try
	{
	//	Open the file
		file.Open(strTempName, CFile::modeWrite|CFile::modeCreate|CFile::typeBinary);
d1015 4
a1018 2
		bool	bLargeFile = IsLargeFile();
		byte	byteVer = (bLargeFile) ? PARTFILE_VERSION_LARGEFILE : PARTFILE_VERSION;
d1020 2
a1021 15
		file.Write(&byteVer, 1);	//	Version
		file.Write(&m_timetLastWriteDate, 4);	//	Date
		file.Write(&m_fileHash, 16);	//	Hash

		CSingleLock Lock(&m_csHashList, TRUE);
		uint16 uParts = m_partHashArray.GetCount();
		file.Write(&uParts, 2);
		for (int x = 0; x != uParts; x++)
			file.Write(m_partHashArray[x], 16);
		Lock.Unlock();

	//	Tags
		CArray<Gap_Struct, Gap_Struct> aGaps;
		CWrTag	tagWr;
		uint32	dwTmp, dwTagFilePos, dwTagCount = 0;
d1023 7
a1029 4
		dwTagFilePos = static_cast<uint32>(file.GetPosition());
		file.Write(&dwTagCount, 4);

		tagWr.WriteToFile(FT_FILENAME, GetFileName(), file);
d1031 14
a1044 23
		tagWr.WriteToFile(FT_FILESIZE, GetFileSize(), file, bLargeFile);
		dwTagCount++;
		if (m_qwBytesTransferred != 0)
		{
			tagWr.WriteToFile(FT_TRANSFERRED, m_qwBytesTransferred, file, bLargeFile);
			dwTagCount++;
		}
	//	Compression gain can be negative in case of disconnection in the middle of
	//	compressed stream, but we're not going to save it for compatibility purposes
		if (static_cast<sint64>(m_qwGainDueToCompression) > 0)
		{
			for (;;)
			{
				if (m_qwGainDueToCompression <= 0xFFFFFFFFui64)
					dwTmp = static_cast<uint32>(m_qwGainDueToCompression);
				else if (!bLargeFile)
					dwTmp = 0xFFFFFFFF;
				else
				{
					tagWr.WriteToFile(FT_COMPRESSION, m_qwGainDueToCompression, file, true);
					break;
				}
				tagWr.WriteToFile(FT_COMPRESSION, dwTmp, file);
d1047 2
a1048 1
			dwTagCount++;
d1050 5
a1054 1
		if (m_qwLostDueToCorruption != 0)
d1056 5
a1060 1
			for (;;)
d1062 1
a1062 10
				if (m_qwLostDueToCorruption <= 0xFFFFFFFFui64)
					dwTmp = static_cast<uint32>(m_qwLostDueToCorruption);
				else if (!bLargeFile)
					dwTmp = 0xFFFFFFFF;
				else
				{
					tagWr.WriteToFile(FT_CORRUPTED, m_qwLostDueToCorruption, file, true);
					break;
				}
				tagWr.WriteToFile(FT_CORRUPTED, dwTmp, file);
d1065 2
a1066 1
			dwTagCount++;
d1068 25
a1092 1
		if (m_bPaused)
d1094 1
a1094 1
			tagWr.WriteToFile(FT_STATUS, 1, file);
a1096 1
		tagWr.WriteToFile(FT_DLPRIORITY, (IsAutoPrioritized()) ? PR_AUTO : priority, file);
d1098 9
a1106 1
		tagWr.WriteToFile(FT_ULPRIORITY, (IsULAutoPrioritized()) ? PR_AUTO : GetULPriority(), file);
d1108 4
a1111 33
		if (static_cast<uint32>(lastseencomplete.GetTime()) != 0)
		{
			tagWr.WriteToFile(FT_LASTSEENCOMPLETE, lastseencomplete.GetTime(), file);
			dwTagCount++;
		}
		if (m_eCategoryID != CAT_NONE)
		{
			tagWr.WriteToFile(FT_CATEGORY, static_cast<uint32>(m_eCategoryID), file);
			dwTagCount++;
		}
		if (statistic.GetAllTimeTransferred() != 0)
		{
			tagWr.WriteToFile(FT_ATTRANSFERRED, static_cast<uint32>(statistic.GetAllTimeTransferred()), file);
			if ((dwTmp = static_cast<uint32>(statistic.GetAllTimeTransferred() >> 32)) != 0)
			{
				tagWr.WriteToFile(FT_ATTRANSFERREDHI, dwTmp, file);
				dwTagCount++;
			}
			dwTagCount++;
		}
		if (statistic.GetAllTimeRequests() != 0)
		{
			tagWr.WriteToFile(FT_ATREQUESTED, statistic.GetAllTimeRequests(), file);
			dwTagCount++;
		}
		if (statistic.GetAllTimeAccepts() != 0)
		{
			tagWr.WriteToFile(FT_ATACCEPTED, statistic.GetAllTimeAccepts(), file);
			dwTagCount++;
		}
	//	Store corrupted part numbers
		CString	strCorruptedParts;
		uint32	j;
d1113 8
a1120 11
		for (j = 0; j < GetPartCount(); j++)
		{
			if (IsCorruptedPart(j))
				strCorruptedParts.AppendFormat((strCorruptedParts.IsEmpty()) ? _T("%u") : _T(",%u"), j);
		}
		if (!strCorruptedParts.IsEmpty())
		{
			tagWr.WriteToFile(FT_CORRUPTEDPARTS, strCorruptedParts, file);
			dwTagCount++;
		}
		tagWr.WriteToFile(FT_PERMISSIONS, GetPermissions(), file);
d1122 3
d1126 3
a1128 3
		dwTagCount += m_tagArray.GetCount();
		for (j = 0; j != m_tagArray.GetCount(); j++)
			m_tagArray[j]->WriteToFile(file);
d1130 2
a1131 2
	//	Make a gap list copy to avoid synchronization object allocation for a long time
		GetGapListCopy(&aGaps);
d1133 3
a1135 2
		char	acNameBuffer[16];
		uint32	dwPos = 0;
d1137 2
a1138 2
		Gap_Struct	*pGap = aGaps.GetData();
		Gap_Struct	*pGapMax = pGap + aGaps.GetCount();
d1140 20
a1159 2
		dwTagCount += 2 * aGaps.GetCount();
		for (; pGap < pGapMax; pGap++)
d1161 4
a1164 7
			itoa(dwPos++, &acNameBuffer[1], 10);
			acNameBuffer[0] = FT_GAPSTART;
			tagWr.WriteToFile(acNameBuffer, pGap->qwStartOffset, file, bLargeFile);
		//	gap start = first missing byte but gap ends = first non-missing byte in edonkey
		//	but I think its easier to user the real limits
			acNameBuffer[0] = FT_GAPEND;
			tagWr.WriteToFile(acNameBuffer, pGap->qwEndOffset + 1ui64, file, bLargeFile);
d1166 4
d1171 1
a1171 4
	//	Save valid tag count
		file.Seek(dwTagFilePos, CFile::begin);
		file.Write(&dwTagCount, 4);
		file.SeekToEnd();
d1173 1
a1173 1
	catch(CFileException* error)
d1180 2
a1181 1
		file.Close();
d1183 1
a1183 1
 		_tremove(strTempName);
a1186 3
	_commit(_fileno(file.m_pStream));
	file.Close();

@


1.719
log
@Fixed missed stalled status for active files without a hashset [DoubleT/Aw3] (waiting time was also wrong for all paused/stopped and active files without hashset);
Fixed messed waiting for hash and hashing file statuses in GUI and WebServer {Fuxie - DK} [Aw3];
Formatting and stricter prototypes.
@
text
@d930 1
a930 1
	AddLogLine(false, GetResString(IDS_TRYTORECOVER), m_strFullName);
@


1.718
log
@Fixed source selection for p2p source exchange (for downloading files: full and A4AF sources weren't spreaded; some sources were sent with a delay -- issue introduced in v1l file revision 1.450).
@
text
@d228 3
a230 3
	m_iNumTransferringSrcs = 0;
	m_iSrcNNP = 0;
	m_iSrcOnQueue = 0;
d232 1
a232 1
	m_iSrcConnecting = 0;
d234 2
a235 2
	m_iSrcConnected = 0;
	m_iSrcConnViaServer = 0;
d238 2
a239 2
	m_iSrcQueueFull = 0;
	m_iSrcA4AF = 0;
d821 9
a850 9
	UpdateCompletedInfos();
//	Smoothed "remaining time" calculation
	m_qwSessionStartSize = m_qwCompletedSize;

	FILETIME	ftModify;

	if (::GetFileTime(m_hPartFileWrite, NULL, NULL, &ftModify))
		m_timeLastDownTransfer = CTime(ftModify);

d881 1
a881 1
			addfilethread->SetValues(0, GetPath(), m_hPartFileWrite.GetFileName().GetBuffer(), this);
d958 1
a958 1
		return false;
d1191 7
a1197 1
void CPartFile::PartFileHashFinished(CKnownFile* pKnownFile)
d1929 1
a1929 1
	m_iNumTransferringSrcs = m_SourceLists[DS_DOWNLOADING].size();
d1935 1
a1935 1
		m_iSrcConnecting = m_SourceLists[DS_CONNECTING].size();
d1971 1
a1971 1
		m_iSrcConnViaServer = m_SourceLists[DS_WAITCALLBACK].size();
d2002 1
a2002 1
		m_iSrcConnected = m_SourceLists[DS_CONNECTED].size();
d2047 1
a2047 1
		m_iSrcNNP = m_SourceLists[DS_NONEEDEDPARTS].size();
d2069 1
a2069 1
			m_iSrcQueueFull = uSrcQueueFull;
d2071 1
a2071 1
			m_iSrcOnQueue = m_SourceLists[DS_ONQUEUE].size();
d2075 1
a2075 1
			m_iSrcOnQueue = m_iSrcQueueFull = m_uSrcHighQR = 0;
d2231 1
a2231 1
		m_iSrcA4AF = m_A4AFSourceLists.size();
d2791 1
a2791 1
		addFileThread->SetValues(0, m_strTempDir, partFileNameBase, this);
d2984 1
a2984 1
			m_iSrcA4AF = 0;
d3090 1
a3090 1
		m_iSrcA4AF = 0;
d3301 3
a3303 3
	m_iNumTransferringSrcs = 0;
	m_iSrcNNP = 0;
	m_iSrcOnQueue = 0;
d3305 1
a3305 1
	m_iSrcConnecting = 0;
d3307 2
a3308 2
	m_iSrcConnected = 0;
	m_iSrcConnViaServer = 0;
d3311 2
a3312 2
	m_iSrcQueueFull = 0;
	m_iSrcA4AF = 0;
d3546 1
a3546 1
	m_iNumTransferringSrcs = 0;
a3620 1
	{
a3621 1
	}
a3622 1
	{
a3623 1
	}
d3655 1
a3655 1
int CPartFile::GetPartFileStatusID()
d3659 1
a3659 1
	int	ipfStatus = 0;
d3662 1
a3662 3
	{
		ipfStatus = PS_DOWNLOADING;
	}
d3664 1
a3664 6
	{
		if (!IsStalled())
			ipfStatus = PS_WAITINGFORSOURCE;
		else
			ipfStatus = PS_STALLED;
	}
d3666 2
a3667 1
	switch (GetStatus())
a3670 2
			ipfStatus = PS_HASHING;
			break;
d3676 1
a3676 1
			ipfStatus = GetStatus();
d3679 1
a3679 1
	return ipfStatus;
d3690 1
a3690 1
//	Sort order is Complete - Completing - Downloading - Waiting - Stalled - Paused - Errors
d3693 2
a3694 6
	{
		if (!IsStalled())
			status = 3;
		else
			status = 4;
	}
d5656 1
a5656 1
//	IsStalled() performs obaldin's stall check
@


1.717
log
@Fixed source selection for p2p source exchange (for downloading files: not SX replied were sent unless one chunk was downloaded).
@
text
@a3982 3
		if (md4cmp(pPotentialSource->m_reqFileHash, pForClient->m_reqFileHash) != 0)
			continue;

@


1.716
log
@Enabled get first chunk for reviewable archives to allow better recovery {muleteer};
Enabled get first chunk option for .rm files {muleteer};
Split  IsArchive into 2 functions to avoid useless checks.
@
text
@d4011 1
a4011 1
		if (pPotentialSource->GetAvailUpPartCount() == 0)
d4017 1
a4017 1
		if (uPartCount != pPotentialSource->GetUpPartCount())
@


1.715
log
@Fixed selection of not the best sources while creating a file link with source (introduced by optimization in 1.354 v1j; Come on, guys, debug lines were in the log showing parts sources have...).
@
text
@d3424 1
a3424 2
// Allow to preview zip/rar files
bool CPartFile::IsArchive(bool bOnlyPreviewable)
a3425 3
	if (bOnlyPreviewable)
		return m_bIsPreviewableArchive;

d3782 1
a3782 1
	if (IsArchive(true))
d3841 1
a3841 1
	if (IsArchive(true))
d3923 1
a3923 1
	if (!IsMovie() || (GetPartCount() < 3))
a5782 1
		{
a5783 1
		}
d5791 2
d5835 1
a5835 1
		_T("mpg"), _T("mpeg"), _T("vob"), _T("asf"), _T("bin"), _T("mpe"), _T("dat")
d5844 1
a5844 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcPreviewableExt); ui++)
d5857 1
a5857 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcAviMovieExt); ui++)
d5867 1
a5867 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcAviKindMovieExt); ui++)
d5878 1
a5878 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcMpgMovieExt); ui++)
d5889 1
a5889 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcMpgAudioExt); ui++)
@


1.714
log
@Removed double #include; Stricter pointer declaration;
m_bHasClientNeededParts replaced with m_uNeededParts (target functionality is not fully implemented though).
@
text
@d5105 2
a5106 1
			bool	bInserted = false;
d5108 1
a5108 1
			for (POSITION pos = newSourceList.GetTailPosition(); pos != NULL;)
d5112 1
a5112 1
					newSourceList.InsertAfter(pos, pSource);
@


1.713
log
@Reduced #include depedency.
@
text
@a26 1
#include <math.h>
d1945 1
a1945 1
				//	A new source (which was never contacted) has HasClientNeededParts() = false;
d1947 1
a1947 1
						pSource->HasClientNeededParts() ) &&
d3976 1
a3976 1
	byte			*pbyteForClientPartStatus, *pbytePotentialClientPartStatus;
@


1.712
log
@Encryption preparations;
Not all received over UDP server sources might be added under some rare conditions
(while some file completion or when too many source are available for some files -- adapted from original).
@
text
@d28 1
@


1.711
log
@Encryption preparations.
@
text
@d2283 6
a2288 8

	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE
		|| eFileStatus == PS_COMPLETING || eFileStatus == PS_ERROR)
	{
		return;
	}

	byte byteCount;
a2300 4
	CUpDownClient	*pNewSource;
	uint32			dwUserID, dwUserIDHyb;
	uint16			uUserPort;

d2306 12
d2319 1
a2319 1
	//	Don't add the sources if we are not connected to server
d2352 4
a2355 1
			break;
@


1.710
log
@Added Source Exchange 2 support (adapted from original 0.48a).
@
text
@d2276 1
a2276 1
void CPartFile::AddServerSources(CMemFile &pSources, uint32 dwSrvIP, uint16 uSrvPort)
d5046 1
a5046 1
		CClientSource * source = (CClientSource*)sources->GetAt(pos);
d5048 1
a5048 1
		if (source->sourceType != ED2KLINK_SOURCE_IP)
d5058 2
a5059 2
		AddClientSource(source);
		delete source;
@


1.709
log
@Updated Source Exchange Protocol to version 4 (ability to spread encryption capabilities);
Preparation to support Source Exchange 2 (0.48a).
@
text
@d3948 1
a3948 1
	bool		bNeededPart, bIsSX2Packet = false;
d3950 12
a3961 1
	byteUsedVer = pForClient->GetSourceExchangeVersion();
d4097 1
a4097 1
void CPartFile::AddClientSources(CMemFile *packetStream, byte byteSXVer, bool bSX2)
d4110 1
a4110 1
	uint32		dwNumSources = 0, dwPktSXVer = 0, dwDataSize;
d4112 7
a4118 1
	packetStream->Read(&dwNumSources, 2);
d4120 18
a4137 12
//	Check if the data size matches the number of sources and eventually correct the source
//	exchange version while reading the packet data. Otherwise we could experience a higher
//	chance in dealing with wrong source data, user hashes and finally duplicate sources
	dwDataSize = packetStream->GetLength() - packetStream->GetPosition();

//	If a newer version inserts additional data (like v2), the below code will correctly filter those packets.
//	If it appends additional data after <count>(<Sources>)[count], we are in trouble with the
//	below code. Thus a client which doesn't understand newer version should never receive such a packet.
	if (dwNumSources * (4u + 2u + 4u + 2u + 16u + 1u) == dwDataSize)	//	Check for v4 packet
	{
		if (byteSXVer >= 4)
			dwPktSXVer = 4;
d4139 1
a4139 2
	else
	if (dwNumSources * (4u + 2u + 4u + 2u + 16u) == dwDataSize)	//	Check for v2/v3 packet
d4141 28
a4168 7
		if (byteSXVer >= 2)
			dwPktSXVer = (byteSXVer == 2) ? 2 : 3;
	}
	else if (dwNumSources * (4u + 2u + 4u + 2u) == dwDataSize)	//	Check for v1 packet
	{
		if (byteSXVer >= 1)
			dwPktSXVer = 1;
d4173 3
a4175 2
		g_App.m_pMDlg->AddDebugLogLine(_T("Received invalid SX packet (v%u) of data size %u (%u) for %s"),
			byteSXVer, dwDataSize, dwNumSources, GetFileName());
@


1.708
log
@Removed unused parameter.
@
text
@d3934 1
a3934 1
Packet*	CPartFile::CreateSrcInfoPacket(CUpDownClient *pForClient)
d3946 5
a3950 1
	uint16		uCount = 0;
d3953 1
a3953 1
	packetStream.Write(&uCount, 2);
a3955 1
	bool 			bNeededPart;
d3957 2
a3958 2
	uint32			dwID, dwServerIP, dwRes;
	uint16			uPort, uServerPort;
d4028 1
a4028 1
			if (pForClient->GetSourceExchangeVersion() >= 3)
d4038 2
a4039 2
			dwServerIP = pPotentialSource->GetServerIP();
			uServerPort = pPotentialSource->GetServerPort();
d4043 4
a4046 3
			packetStream.Write(&dwServerIP, 4);
			packetStream.Write(&uServerPort, 2);
			if (pForClient->GetSourceExchangeVersion() > 1)
d4048 12
a4059 1
			if (++uCount > 500)
d4064 1
a4064 1
	if (uCount == 0)
d4067 2
a4068 2
	packetStream.Seek(16, 0);
	packetStream.Write(&uCount, 2);
d4072 2
a4073 2
	pPacket->m_eOpcode = OP_ANSWERSOURCES;
// 16+2+501*(4+2+4+2+16+1) = 14547 bytes max.
d4086 1
a4086 1
void CPartFile::AddClientSources(CMemFile *packetStream, byte byteSXVer/*=1*/)
a4110 1
#ifdef _CRYPT_READY
a4116 1
#endif
d4149 6
a4156 1
		{
a4157 1
		}
@


1.707
log
@Dropped generation of .dir files (importing is still supported).
@
text
@d3780 1
a3780 1
			CArchiveRecovery::recover(this, true);
d4058 1
d4134 1
d4136 1
d4138 1
d4140 1
@


1.706
log
@Preallocation error message was moved to the main log {muleteer}.
@
text
@a1182 26
#if 1//temp migration of prev.setting -- remove in v1.2c

	CStdioFile	fDir;
	CString		strPath(m_strFilePath);

	strPath += _T(".dir");
	try
	{
	//	ChangeDir
		if (!m_strAlternativePath.IsEmpty())
		{
			if (fDir.Open(strPath, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::typeText))
			{
				fDir.WriteString((LPCTSTR)m_strAlternativePath);
				fDir.Close();
			}
		}
	}
	catch(CFileException* error)
	{
		OUTPUT_DEBUG_TRACE();
		AddLogLine(false, RGB_LOG_ERROR_TXT _T("Error saving %s - %s"), strPath, GetErrorMessage(error));
		error->Delete();
		fDir.Close();
	}
#endif
@


1.705
log
@Newly added stuff was renamed according to the original for easier reference;
Reverted and extended logic to parse SX packets;
Fixed an issue introduced by SX update -- user hash erasing was missed for v1 packets, it could cause wrong client identification in very rare cases;
Fixed an issue introduced by SX update -- sources from the link couldn't be added if no server connection;
Some optimization to reduce overhead cause by IP conversion; Formatting.
@
text
@d5666 1
a5666 1
		AddDebugLogLine( RGB_LOG_ERROR_TXT _T("Preallocate for file %s: error %s"),
@


1.704
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d2053 1
a2053 1
				//	it doesn't contact us at that time, so we need to send reask in the same session
d2123 1
a2123 1
			//	it doesn't contact us at that time, so we need to send reask in the same session
d2172 1
a2172 1
			//	it doesn't contact us at that time, so we need to send reask in the same session
d2329 3
a2331 4
	uint32	dwUserID;
	uint32	dwHybridUserID;
	CUpDownClient* pNewSource;
	uint16	uUserPort;
d2341 1
a2341 1
			return;
d2366 2
a2367 2
			dwHybridUserID = IsLowID(dwUserID) ? dwUserID : ntohl(dwUserID);
			pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, dwHybridUserID, uUserPort, dwSrvIP, uSrvPort, NULL);
d3999 2
a4000 2
		//	Don't send a client use a hash that was identified for another client because he could be a hash stealer 
		if (pPotentialSource->m_pCredits != NULL 
d4052 2
a4053 2
				dwID = pPotentialSource->GetHybridUserID();
			else
a4054 1
			//	use the old ed2k user id convention for LowID sources on same server 
d4056 1
a4056 1
					dwID = pPotentialSource->GetHybridUserID();
d4096 1
a4096 1
void CPartFile::AddClientSources(CMemFile *packetStream, byte byteSourceExchangeVersion)
d4109 7
a4115 17
	uint32		dwDataSize;
	uint16		uNumSources;
	byte		byteSXversion;
	bool		bValidSXPacket = false;

	packetStream->Read(&uNumSources, 2);

//	Detect the source exchange version:
//	1) If the remote client supports our (see SOURCEEXCHANGE_VER in opcodes.h) or next source exchange 
//		version, then he must to send the packet in our version.
//	2) if the remote client has older source exchange version, then he will send a packet with a maximal
//		version that is available for him  
	byteSXversion = min(SOURCEEXCHANGE_VER, byteSourceExchangeVersion);

//	Check if the data size matches the 'uNumSources' for the appropriate source exchange version
//	Otherwise we could experience a higher chance in dealing with wrong source data, userhashs 
//	and incorrect sources.
d4118 12
a4129 1
	switch (byteSXversion)
d4131 7
a4137 15
		case 1:
			if (uNumSources * (4u + 2u + 4u + 2u) == dwDataSize)
				bValidSXPacket = true;
			break;
		case 2:
		case 3:
			if (uNumSources * (4u + 2u + 4u + 2u + 16u) == dwDataSize)
				bValidSXPacket = true;
			break;
		case 4:
			if (uNumSources * (4u + 2u + 4u + 2u + 16u + 1u) == dwDataSize)
				bValidSXPacket = true;
		default:
		//	Keep default "false" value
			break;
d4140 1
a4140 1
	if (!bValidSXPacket)
d4143 1
a4143 4
										byteSourceExchangeVersion,
										dwDataSize,
										uNumSources,
										GetFileName());
d4149 1
a4149 1
	for (int i = 0; i != uNumSources; i++)
d4151 1
a4151 1
		packetStream->Read(&source.dwHybridSourceID, 4);
d4153 2
a4154 2
		if (byteSourceExchangeVersion < 3 && !IsLowID(source.dwHybridSourceID))
			source.dwHybridSourceID = ntohl(source.dwHybridSourceID);
d4158 1
a4158 1
		if (byteSourceExchangeVersion > 1)
d4160 3
a4162 1
		AddClientSource(&source, i, true, byteSourceExchangeVersion);
a4948 3
//	Don't add the sources if we are not connected to server
	if (!g_App.m_pServerConnect->IsConnected())
		return;
d4950 1
a4950 1
	else if (g_App.m_pServerConnect->IsLowID())
d4952 1
a4952 1
		if ( g_App.m_pServerConnect->GetClientID() == pSource->dwHybridSourceID &&
d4960 2
a4961 2
		if ( ntohl(g_App.m_pServerConnect->GetLocalIP()) == pSource->dwHybridSourceID &&
			 g_App.m_pPrefs->GetPort() == pSource->sourcePort )
d4966 2
a4967 2
	else if ( ntohl(g_App.m_pServerConnect->GetClientID()) == pSource->dwHybridSourceID &&
			  g_App.m_pPrefs->GetPort() == pSource->sourcePort )
d4971 2
a4972 2
//	Use lowID source only if it's on the same server as us
	else if ( IsLowID(pSource->dwHybridSourceID) &&
d4983 1
a4983 1
		CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, pSource->dwHybridSourceID, pSource->sourcePort, pSource->serverIP, pSource->serverPort, pSource->achUserHash);
@


1.703
log
@by SX don't spread a client use a hash that was identified for another client because he could be a hash stealer
@
text
@d2302 1
a2302 1
void CPartFile::AddSources(CMemFile &pSources, uint32 dwSrvIP, uint16 uSrvPort)
d2330 2
d2340 3
a2342 1

d2344 1
a2344 1
		if (g_App.m_pServerConnect->GetClientID() < 0x1000000 && g_App.m_pServerConnect->IsConnected())
d2358 1
a2358 1
		else if ( dwUserID < 0x1000000 &&
d2367 3
a2369 2
			CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, dwUserID, uUserPort, dwSrvIP, uSrvPort, NULL);
			if (pNewSource)
d4052 10
a4061 1
			dwID = pPotentialSource->GetUserID();
d4111 1
d4113 3
d4118 30
a4147 4
//	Check if the data size matches the 'uNumSources' for v1 or v2 and eventually correct the source
//	exchange version while reading the packet data. Otherwise we could experience a higher
//	chance in dealing with wrong source data, userhashs and finally duplicate sources.
	UINT		uDataSize = packetStream->GetLength() - packetStream->GetPosition();
d4149 7
a4155 16
//	Checks if v1 packet has the correct size
	if (uNumSources * (4u + 2u + 4u + 2u) == uDataSize)
	{
		byteSourceExchangeVersion = 1;
	}
//	Checks if v2 packet has the correct size
	else if (uNumSources * (4u + 2u + 4u + 2u + 16u) == uDataSize)
	{
		byteSourceExchangeVersion = 2;
	}
	else
	{
	//	If v3 inserts additional data (like v2), the above code will correctly filter those packets.
	//	If v3 appends additional data after <count>(<Sources>)[count], we are in trouble with the
	//	above code. Though a client which does not understand v3+ should never receive such a packet.
		g_App.m_pMDlg->AddDebugLogLine(_T("Received invalid source exchange packet (v%u) of data size %u for %s"), byteSourceExchangeVersion, uDataSize, GetFileName());
d4159 2
d4163 4
a4166 3
		CClientSource		source;

		packetStream->Read(&source.sourceID, 4);
d4958 4
d4963 1
a4963 2
#ifdef OLD_SOCKETS_ENABLED
	if (g_App.m_pServerConnect->GetClientID() < 0x1000000 && g_App.m_pServerConnect->IsConnected())
d4965 1
a4965 1
		if ( g_App.m_pServerConnect->GetClientID() == pSource->sourceID &&
d4973 1
a4973 1
		if ( g_App.m_pServerConnect->GetLocalIP() == pSource->sourceID &&
d4979 1
a4979 1
	else if ( g_App.m_pServerConnect->GetClientID() == pSource->sourceID &&
d4985 1
a4985 1
	else if ( pSource->sourceID < 0x1000000 &&
d4996 1
a4996 1
		CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, pSource->sourceID, pSource->sourcePort, pSource->serverIP, pSource->serverPort, pSource->achUserHash);
d5118 1
a5118 1
	if (dwID >= 0x1000000)
@


1.702
log
@Removed unused code; Formatting.
@
text
@d3992 1
a3992 1
	//	Don't send a client to itself as a source (part 2)
a3993 7
		{
		//	Actually if function 'CClientList::AttachToAlreadyKnown()' is working properly, then we should never see this message
			AddDebugLogLine( RGB_BLUE_VIOLET_TXT _T("Found same client during SX c1=(%s,%s), c2=(%s,%s)"), 
							pPotentialSource->GetClientNameWithSoftware(),
							HashToString(pPotentialSource->GetUserHash()),
							pForClient->GetClientNameWithSoftware(),
							HashToString(pForClient->GetUserHash()) );
d3995 4
a3998 1
		}
@


1.701
log
@Delete stray .part.met.bad on file completion and cancelation.
@
text
@d2302 1
a2302 1
void CPartFile::AddSources(CMemFile& pSources, uint32 iServerIP, uint16 iServerPort)
a2316 2
	byte byteLowIDDropped = 0;
	byte bytePossibleSources = 0;
d2329 2
a2330 2
	uint32 dwUserID;
	uint16 iUserPort;
d2334 2
a2335 2
		pSources.Read(&dwUserID,4);
		pSources.Read(&iUserPort,2);
d2343 2
a2344 2
				 g_App.m_pPrefs->GetPort() == iUserPort &&
				 inet_addr(g_App.m_pServerConnect->GetCurrentServer()->GetFullIP()) == iServerIP )
d2350 1
a2350 1
				  g_App.m_pPrefs->GetPort() == iUserPort )
d2355 1
a2355 1
				  !g_App.m_pServerConnect->IsLocalServer(iServerIP, iServerPort) )
a2356 1
			byteLowIDDropped++;
d2363 1
a2363 2
			bytePossibleSources++;
			CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this, dwUserID, iUserPort, iServerIP, iServerPort, NULL);
@


1.700
log
@Fixed constant rehashing of files with some weird date {mamamia}.
@
text
@d3131 5
d3368 5
@


1.699
log
@fix constant rehashing of some big files [Aw3/KuSh]
@
text
@d3110 1
a3110 1
//	if we don't update the file date here (after commiting the file and before adding the record to known.met),
d3112 1
a3112 6
	struct _stat st;
	if (_tstat(newname, &st) == 0)
	{
		m_timetLastWriteDate = st.st_mtime;
		AdjustNTFSDaylightFileTime(&m_timetLastWriteDate, newname);
	}
@


1.698
log
@Fixed part file loading assigned to the not existing category (file is becoming uncategorized) -- the more you work with Fuxie - DK the more weird bugs can be discovered...
@
text
@d846 1
a846 1
	CFileStatus filestatus;
d848 2
a849 3
//	"...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are...
	m_hPartFileWrite.GetStatus(filestatus);
	m_timeLastDownTransfer = filestatus.m_mtime;
d868 1
a868 1
		uint32	dwFileDate = filestatus.m_mtime.GetTime();
@


1.697
log
@Fixed stopping of a file paused due to lack of disk space {muleteer}.
@
text
@d584 1
d586 3
a5534 1
		{
d5536 1
a5536 1
		}
a5538 4
			case 0:
			{
				break;
			}
a5539 1
			{
d5543 1
a5543 1
			}
a5544 1
			{
d5548 1
a5548 1
			}
a5549 1
			{
d5553 1
a5553 1
			}
a5554 1
			{
d5557 1
a5558 1
			}
@


1.696
log
@Alternative file destination directory was moved to .part.settings (.part.dir is kept for a while for smooth up/downgrade) {Fuxie - DK};
Improved string processing.
@
text
@d3120 1
d3126 1
d3352 1
d3358 1
d4681 3
a4683 1
		PauseFile();
@


1.695
log
@Configuration of default file permission {conman} [Aw3/DarkSoul].
@
text
@d428 1
a428 3
	{
		SetFileName(CleanupFilename(GetFileName()).GetBuffer());
	}
d657 1
d659 2
d670 4
d1180 1
d1205 1
d4332 1
d4355 1
a5093 2
	EMULE_TRY

a5095 2

	EMULE_CATCH
@


1.694
log
@Large file size support (max file size 512 GB - 1 = 549,755,813,887);
Fixed exception on closure when no disk space for buffered file data;
Simplified obtaining of chunk size in HashSinglePart();
Added missed log line for failed file completion.
@
text
@d1119 2
a1120 5
		if (GetPermissions() != PERM_ALL)
		{
			tagWr.WriteToFile(FT_PERMISSIONS, GetPermissions(), file);
			dwTagCount++;
		}
a2228 1
					{
a2229 1
					}
@


1.693
log
@Large file size support preparations.
@
text
@d343 19
d725 18
d2928 9
d3054 1
d3388 1
a3388 1
	CFile	*pPartFile = NULL;
a3395 1
	{
d3397 1
a3397 3
	}
	else if (!GetPartHash(dwPartNum) && (dwPartCnt != 1))
	{
a3398 1
	}
d3402 1
d3404 2
a3405 5
		pPartFile = m_hPartFileRead.Duplicate();

		pPartFile->Seek((LONGLONG)PARTSIZE * dwPartNum, CFile::begin);

		uint32 length = PARTSZ32;
d3407 1
a3407 6
		if ((ULONGLONG)PARTSIZE * (dwPartNum + 1) > pPartFile->GetLength())
		{
			length = (pPartFile->GetLength() - ((ULONGLONG)PARTSIZE * dwPartNum));
		}
		ASSERT(length <= PARTSZ32);
		CreateHashFromFile(pPartFile, length, hashresult);
d3410 2
a3411 2
		delete pPartFile;
		pPartFile = NULL;
d3422 1
a3422 1
	delete pPartFile;
d5107 1
a5107 1
	if (GetCatID() != 0)
d5575 4
@


1.692
log
@More efficient Rx file data caching to reduce disk access (before in some cases
small amount of data could be saved on disk, besides that it will reduce number of
disconnections due to timeout when client flushing big file portion on disk after receiving just a little).
@
text
@d73 1
a73 2
				if (pTag->IsInt())
					SetFileSize(pTag->GetIntValue());
a2382 1
	{
a2383 1
	}
@


1.691
log
@Large file size support preparations.
@
text
@a1880 1
		{
a1881 1
		}
d4376 1
a4376 1
		while (pos != NULL)
d4378 3
a4380 1
			POSITION posNext = pos;
d4382 8
a4389 7
			queueItem = m_BufferedData_list.GetPrev(pos);
			if (item->qwEndOffset > queueItem->qwEndOffset)
			{
				added = true;
				m_BufferedData_list.InsertAfter(posNext, item);
				break;
			}
d4391 4
@


1.690
log
@Added 64bit tag support; Simplified arguments passing to preallocation thread.
@
text
@d610 1
a610 1
						if (newtag->IsInt())
d623 1
a623 1
								gap->qwStartOffset = newtag->GetIntValue();
d625 4
a628 1
								gap->qwEndOffset = newtag->GetIntValue() - 1;
d960 8
a967 7
	//	Version
		byte uVersion = PARTFILE_VERSION;
		file.Write(&uVersion, 1);
	//	Date
		file.Write(&m_timetLastWriteDate, 4);
	//	Hash
		file.Write(&m_fileHash, 16);
d985 1
a985 1
		tagWr.WriteToFile(FT_FILESIZE, GetFileSize(), file);
d989 1
a989 1
			tagWr.WriteToFile(FT_TRANSFERRED, m_qwBytesTransferred, file);
d996 14
a1009 2
			tagWr.WriteToFile(FT_COMPRESSION,
				(m_qwGainDueToCompression > 0xFFFFFFFF) ? 0xFFFFFFFF : static_cast<uint32>(m_qwGainDueToCompression), file);
d1014 14
a1027 2
			tagWr.WriteToFile(FT_CORRUPTED,
				(m_qwLostDueToCorruption > 0xFFFFFFFF) ? 0xFFFFFFFF : static_cast<uint32>(m_qwLostDueToCorruption), file);
d1107 1
a1107 1
			tagWr.WriteToFile(acNameBuffer, pGap->qwStartOffset, file, false);
d1111 1
a1111 1
			tagWr.WriteToFile(acNameBuffer, pGap->qwEndOffset + 1ui64, file, false);
@


1.689
log
@Delete client objects when a file is stopped/cancelled/completed not to accumulate unused sources in the known file list.
@
text
@d451 1
a451 1
		if (version != PARTFILE_VERSION)
d502 2
a503 2
					if (newtag->IsInt())
						SetFileSize(newtag->GetIntValue());
d507 2
a508 2
					if (newtag->IsInt())
						m_qwBytesTransferred = newtag->GetIntValue();
d512 2
a513 2
					if (newtag->IsInt())
						m_qwGainDueToCompression = newtag->GetIntValue();
d517 2
a518 2
					if (newtag->IsInt())
						m_qwLostDueToCorruption = newtag->GetIntValue();
d1079 1
a1079 1
			tagWr.WriteToFile(acNameBuffer, pGap->qwStartOffset, file);
d1083 1
a1083 1
			tagWr.WriteToFile(acNameBuffer, pGap->qwEndOffset + 1ui64, file);
d5551 1
a5551 6
	PAThreadParam *tp = new PAThreadParam;

	tp->cPartFile = this;
	tp->iPosition = GetFileSize() - 1;

	lTh = CreateThread(NULL, 0L, AllocateNeededSpaceProc, tp, 0, &lThID);
a5552 1

d5559 1
a5559 1
	PAThreadParam * tp = (PAThreadParam*)lpParameter;
d5563 3
a5565 3
		tp->cPartFile->m_hPartFileWrite.Seek(tp->iPosition, CFile::begin);
		tp->cPartFile->m_hPartFileWrite.Write("1", 1);
		tp->cPartFile->m_hPartFileWrite.Flush();
d5567 1
a5567 1
		tp->cPartFile->SaveSettingsFile();
d5572 1
a5572 1
						 tp->cPartFile->GetFileName(), GetErrorMessage(error) );
d5574 1
a5574 1
		tp->cPartFile->m_bIsPreallocated = false;
a5577 1
	delete tp;
a5670 1
	{
a5671 1
	}
a5932 1

@


1.688
log
@UDP reasks shouldn't have been sent to NNS as our client isn't in remote queue
(problem introduced in v1.1g).
@
text
@d3211 4
a3214 1
			g_App.m_pDownloadQueue->RemoveSource(pRemoveSrc);
@


1.687
log
@Removed unused parameter; Formatting.
@
text
@d1995 1
a1995 1
					pSource->SendReask();
@


1.686
log
@@@Fuxie - DK, sorry I couldn't join your brunch this time, so here is the present:
fixed file Last Reception time for files complete on startup {Fuxie - DK}.
@
text
@d3188 1
a3188 1
void CPartFile::RemoveAllSources(bool bTryToSwap)
d3193 1
a3193 2
//	TODO transfer sources to other downloading files if possible
	CUpDownClient	*pRemoveSource;
d3205 1
a3205 1
		pRemoveSource = *cIt;
d3207 2
a3208 1
		if (bTryToSwap)
d3210 2
a3211 10
			if (!pRemoveSource->SwapToAnotherFile(NULL, A4AF_REMOVE))
			{
			//	If the switching wasn't successful we remove the source from the download queue
				g_App.m_pDownloadQueue->RemoveSource(pRemoveSource);
			}
			else
			{
			//	If the switching was successful we need to remove the entry from graphical list
				g_App.m_pDownloadList->RemoveSource(pRemoveSource, this);
			}
d3215 2
a3216 2
		//	We weren't asked to swap so we remove it
			g_App.m_pDownloadQueue->RemoveSource(pRemoveSource);
d3226 3
a3228 3
			pRemoveSource = *cIt;
			g_App.m_pDownloadList->RemoveSource(pRemoveSource, this);
			pRemoveSource->RemoveRequestForAnotherFile(this);
d3423 1
a3423 1
	RemoveAllSources(true);
@


1.685
log
@Fixed source reasking when too many connections threshold reached (UDP connections
shouldn't be blocked by too many TCP socket connections; we should send TCP reasks when threshold is reached and there's already a socket connection with a source).
@
text
@d798 6
a820 7
	//	Check date of .part file - if it's wrong, rehash file
		CFileStatus filestatus;

	//	"...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are...
		m_hPartFileWrite.GetStatus(filestatus);
		m_timeLastDownTransfer = filestatus.m_mtime;

d823 1
@


1.684
log
@Don't hash and share part files without complete chunks on startup after improper closure;
Corrected total file speed calculation for displaying of the completed size for erroneous files on startup {Fuxie - DK};
Removed preliminary check for socket connection initiation while processing NNS
as for some clients already existing connection can be utilized;
Added crash protection (could be possible after server connection loss).
@
text
@a1993 4
			//	Process waiting sources unless it is allowed to open a new connection
				if (g_App.m_pListenSocket->TooManySockets())
					break;

d2004 5
a2008 1
			if (!g_App.m_pListenSocket->TooManySockets())
d2010 1
a2010 2
				uint16	uSrcQueueFull = 0;
				uint16	uSrcHighQR = 0;
d2012 4
a2015 9
				GetCopySourceList(DS_ONQUEUE, &sourceListCopy);
				for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
				{
				//	Process waiting sources unless it is allowed to open a new connection
					if (g_App.m_pListenSocket->TooManySockets())
					{
						uSrcQueueFull = 0xFFFF;
						break;
					}
d2017 2
a2018 15
					pSource = *cIt;

					if (pSource->IsRemoteQueueFull())
						uSrcQueueFull++;
					else if (pSource->GetRemoteQueueRank() > QUEUERANK_HIGH)
						uSrcHighQR++;

					if (dwCurTick > pSource->GetNextFileReaskTime())
						pSource->SendReask();
				}
				if (uSrcQueueFull != 0xFFFF)
				{
					m_iSrcQueueFull = uSrcQueueFull;
					m_uSrcHighQR = uSrcHighQR;
				}
d2020 2
d2067 1
a2067 2
		if (!m_SourceLists[DS_WAIT_FOR_FILE_REQUEST].empty()
			&& !g_App.m_pListenSocket->TooManySockets())
a2071 4
			//	Process waiting sources unless it is allowed to open a new connection
				if (g_App.m_pListenSocket->TooManySockets())
					break;

@


1.683
log
@Fixed displaying of the completed size for erroneous files on startup {Fuxie - DK}.
@
text
@d795 2
d811 6
a816 2
//	Check date of .part file - if it's wrong, rehash file
	CFileStatus filestatus;
d818 3
a820 3
//	"...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are...
	m_hPartFileWrite.GetStatus(filestatus);
	m_timeLastDownTransfer = filestatus.m_mtime;
d822 1
a822 1
	uint32	dwFileDate = filestatus.m_mtime.GetTime();
d824 3
a826 3
	AdjustNTFSDaylightFileTime(&dwFileDate, m_strFilePath);
	if (m_timetLastWriteDate != dwFileDate)
	{
d828 4
a831 4
		AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_REHASH), m_strFileName);
#endif //NEW_SOCKETS_ENGINE
	//	Rehash
		SetStatus(PS_WAITINGFORHASH);
d833 5
a837 4
		CHashFileThread* addfilethread = (CHashFileThread*) AfxBeginThread(RUNTIME_CLASS(CHashFileThread), THREAD_PRIORITY_NORMAL + g_App.m_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
		addfilethread->SetValues(0, GetPath(), m_hPartFileWrite.GetFileName().GetBuffer(), this);
		addfilethread->ResumeThread();
#endif //NEW_SOCKETS_ENGINE
a839 2
//	Smoothed "remaining time" calculation
	m_qwSessionStartSize = m_qwCompletedSize;
d1957 1
a1957 2
		if (!m_SourceLists[DS_NONEEDEDPARTS].empty()
			&& !g_App.m_pListenSocket->TooManySockets())
d1959 2
a1960 1
			uint32	dwLocalSrvIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
@


1.682
log
@Don't show Media Info tab for formats which can't be examined {Fuxie - DK};
Slightly reduced memory usage.
@
text
@d794 1
a832 2
	UpdateCompletedInfos();

@


1.681
log
@Corrected dropping of inactive LowID sources (there was a change that a good source could be removed);
Fixed a rare remote queue position loss due to missed reask for downloading remote LowID;
Drop some buggy ed2k clients from upload queue as such remote LowID can't be contacted;
Drop without delay some kind of inactive remote LowID sources in upload queue to free space for good sources
(before timeout was checked from time to time - now we drop inactive remote LowID which are also in download list right after timeout);
Remote LowID purged from the download queue weren't deleted from known client list if they weren't in our upload queue.
@
text
@d285 1
a285 2
	m_bIsMovie = false;
	m_bIsAviMovie = false;
d3829 1
a3829 1
		if (IsAviMovie())
d3902 1
a3902 1
		if (IsAviMovie())
d5671 1
a5671 1
		if (IsAviMovie())
d5718 5
a5722 1
		_T("avi"), _T("ogm"), _T("mkv"), _T("wmv"), _T("divx"), _T("xvid")
d5745 1
a5745 1
	m_bIsMovie = (ED2KFT_VIDEO == GetFileType() || strExt == _T("bin"));
a5747 1
	m_bIsAviMovie = false;
d5752 11
a5762 1
			m_bIsAviMovie = true;
d5768 1
a5768 1
	m_bIsMpgMovie= false;
@


1.680
log
@Added missed timeout processing for local LowID clients [eklmn].
@
text
@d1882 1
a1882 1
	//	Count connecting souces
d1893 4
a1896 3
			//	If the request socket still doesn't exist & we are wainting more then 60 sec 
				if ((pSource->m_pRequestSocket == NULL) 
					&& (dwCurTick - pSource->GetLastAskedTime() > CONNECTION_TIMEOUT + 20000))
d1898 17
a1914 1
					pSource->UpdateDownloadStateAfterFileReask();
d1964 1
a1964 1
			//	Since we can't connect to a remote LowID client, it can be kept in the list only if it keeps to requesting our files
d1967 1
a1967 2
					if ( (pSource->m_pRequestSocket == NULL) &&
						((dwCurTick - pSource->GetEnteredConnectedState()) > MAX_PURGEQUEUETIME) )
d1969 18
a1986 1
						g_App.m_pDownloadQueue->RemoveSource(pSource);
d2052 3
a2054 4
			//	Since we can't connect to the client we can keep it in the list only if it keeps to request the file(s) from us
				if ( (pSource->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER) &&
					(pSource->m_pRequestSocket == NULL) &&
					((dwCurTick - pSource->GetEnteredConnectedState()) > MAX_PURGEQUEUETIME) )
d2056 18
a2073 1
					g_App.m_pDownloadQueue->RemoveSource(pSource);
d2106 3
a2108 4
			//	Since we can't connect to the client we can keep it in the list only if it keeps to request the file(s) from us
				if ( (pSource->GetDownloadState() == DS_LOWTOLOWID) &&
					(pSource->m_pRequestSocket == NULL) &&
					((dwCurTick - pSource->GetEnteredConnectedState()) > MAX_PURGEQUEUETIME) )
d2110 18
a2127 1
					g_App.m_pDownloadQueue->RemoveSource(pSource);
@


1.679
log
@Fixed rare creation of wrong .stats file in the destination directory {Fuxie - DK};
Minor Unicode correction.
@
text
@d1879 25
a1903 3
//	Count connecting souces
	m_iSrcConnecting = m_SourceLists[DS_CONNECTING].size();
	m_iSrcConnViaServer = m_SourceLists[DS_WAITCALLBACK].size();
@


1.678
log
@Fixed recently changes for download state of remote LowID NNS (as a result fixed broken:
source exchange because number of valid sources was incorrect, A4AF swap, sorting of NNS, NNS statistics, etc.).
@
text
@d3026 1
a3026 1
		AddLogLine(true, IDS_DOWNLOADRENAMED, _tcsrchr(newname, '\\') + 1);
d4092 6
d4100 1
a4100 1
//	If we cant open this file you lose the stats
@


1.677
log
@Large file size support preparations.
@
text
@d1918 2
d1923 13
a1939 2
				pSource = *cIt;

@


1.676
log
@Fixed disappearing muleteer... (processing of remote LowID NNS) {muleteer/Fuxie - DK}.
@
text
@d227 1
a227 1
	m_dwBytesTransferred = 0;
d429 1
a429 1
	m_dwBytesTransferred = 0;
d509 1
a509 1
						m_dwBytesTransferred = newtag->GetIntValue();
d980 1
a980 1
		if (m_dwBytesTransferred != 0)
d982 1
a982 1
			tagWr.WriteToFile(FT_TRANSFERRED, m_dwBytesTransferred, file);
@


1.675
log
@Corrected preview free disk space check {Vladimir (SV)};
More accurate estimation of the required free disk space for archive preview.
@
text
@d1985 3
a1987 2
				if (pSource->GetDownloadState() == DS_LOWID_ON_OTHER_SERVER
					&& ((dwCurTick - pSource->GetLastUpRequest()) > MAX_PURGEQUEUETIME))
d2023 3
a2025 2
				if (pSource->GetDownloadState() == DS_LOWTOLOWID
					&& ((dwCurTick - pSource->GetLastUpRequest()) > MAX_PURGEQUEUETIME))
@


1.674
log
@Large file size support preparations.
@
text
@d3713 8
a3720 5
		if ( (GetFileSize() > 1024ui64) && (GetCompletedSize() > 1024ui64) && !m_bRecoveringArchive
			&& ((GetFreeDiskSpaceX(m_strTempDir) + 100000000) > (2 * GetFileSize())) )
			return true;
		else
			return false;
d3738 1
a3738 1
				&& ((GetFreeDiskSpaceX(m_strTempDir) + 100000000) >= GetFileSize()) );
@


1.673
log
@Simplified/speeded up processing of partfile status.
@
text
@d246 1
a246 1
	m_dwCompletedSize = 0;
d262 1
a262 1
	m_SessionStartSize = 0;
d389 1
a389 1
	AddGap(0, GetFileSize() - 1);
a405 1
	{
a406 1
	}
d836 1
a836 1
	m_SessionStartSize = m_dwCompletedSize;
d1550 2
a1551 2
		m_dblPercentCompleted = (1.0 - static_cast<double>(m_qwGapsSum) / GetFileSize()) * 100;
		m_dwCompletedSize = GetFileSize() - m_qwGapsSum;
d1556 1
a1556 1
		m_dwCompletedSize = GetFileSize();
d1594 1
a1594 1
		m_dwCompletedSize = GetFileSize();
d1660 1
a1660 1
		CBarShader	s_LoadBar(PROGRESS_HEIGHT, wp, crPending, m_dwCompletedSize);
d2776 1
a2776 1
		(m_strFilePath[1] == _T(':') && newname[1] == _T(':')) && (GetFileSize() > 1024*1024) )
d3609 1
a3609 1
	iTimeRemaining = ((dwDataRate != 0) ? (GetFileSize() - GetCompletedSize()) / dwDataRate : -1);
d3638 1
a3638 1
			m_AvgDataRate = ((GetSessionTransferred() /*+ GetDataRate()*/) / (iSeconds /*+ 1*/));
d3713 1
a3713 1
		if ( (GetFileSize() > 1024) && (GetCompletedSize() > 1024) && !m_bRecoveringArchive
d3726 1
a3726 1
			byteMovieMode = (GetLastPartSize() < (GetFileSize() / 100)) ? 7 : 1;
d3761 1
a3761 1
				if (GetCompletedSize() < 16 * 1024)
d3799 1
a3799 1
			byteMovieMode = (GetLastPartSize() < (GetFileSize() / 100)) ? 7 : 1;
d4587 1
a4587 1
			qwBestEnd = GetFileSize() - 1;
d4902 1
a4902 1
	strLink.Format( _T("ed2k://|file|%s|%u|%s|/"),
d4904 1
a4904 2
		GetFileSize(),
		HashToString(GetFileHash()) );
d5085 12
a5096 12
							 GetFileName(), strFileSz,
	             GetResString(IDS_STATUS), GetPartFileStatus(),
	             GetResString(IDS_FILEHASH), HashToString(GetFileHash()),
							 GetResString(IDS_DL_FILENAME), m_strFilePath,
	             GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), dblAvailability,
	             static_cast<int>(GetPercentCompleted()),
							 CastItoXBytes(GetCompletedSize()), strFileSz, GetTransferringSrcCount(),
	             GetResString(IDS_LASTSEENCOMPLETE), strLastSeenComplete,
	             GetResString(IDS_LASTRECEPTION), strLastProgress,
				 GetResString(IDS_DLCOL_REMAININGTIME), strTimeLeft,
	             GetOnQueueSrcCount(), GetQueueFullSrcCount(), GetNoNeededPartsSrcCount(),
	             GetSrcA4AFCount(), GetConnectingSrcCount() );
d5128 16
a5143 16
	             + GetResString(IDS_TT_STATUS2) + _T("<br><b>%s:<t></b>%s"),
	             GetFileName(), strFileSz, CastItoThousands(GetFileSize()), GetResString(IDS_BYTES),
	             static_cast<int>(GetPercentCompleted()), GetResString(IDS_PROCDONE), CastItoXBytes(GetCompletedSize()), strFileSz, strTransferSrcCount,
	             GetResString(IDS_STATUS), GetPartFileStatus(),
	             GetResString(IDS_FILEHASH), HashToString(GetFileHash()),
				 GetResString(IDS_DL_FILENAME), m_strFilePath,
				 GetResString(IDS_FD_OUTPUT), GetOutputDir(),
	             GetResString(IDS_UP_PARTS), GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), dblAvailability,
	             GetResString(IDS_LASTSEENCOMPLETE), strLastSeenComplete,
				 GetResString(IDS_LASTRECEPTION), strLastProgress,
	             GetResString(IDS_DL_SOURCES), GetOnQueueSrcCount(),
	             GetQueueFullSrcCount(),
	             GetNoNeededPartsSrcCount(),
	             GetSrcA4AFCount(),
	             GetConnectingSrcCount(),
                 GetResString(IDS_SIZE_ON_DISK), CastItoXBytes(GetRealFileSize()) );
d5166 2
a5167 2
	uint32 m_nFileSize = GetFileSize();
	double unit = static_cast<double>(size) / static_cast<double>(m_nFileSize);
d5173 1
a5173 3
	{
		CharFillRange(&strChunkBar, 0, static_cast<double>(m_nFileSize) * unit, crProgress);
	}
d5563 1
a5563 1
			SetMovieMode((GetLastPartSize() < (GetFileSize() / 100)) ? 7 : 1);
d5567 1
a5567 1
			if (GetFileSize() < 209715200)
@


1.672
log
@Large file size support preparations;
Removed function reading file in a circular way as such possibility was removed long time ago.
@
text
@d1775 1
a1775 1
EnumPartFileStatuses CPartFile::GetStatus(bool bIgnorePause)
d1777 1
a1777 1
	if (!m_bPaused || m_eStatus == PS_ERROR || m_eStatus == PS_COMPLETING || m_eStatus == PS_COMPLETE || bIgnorePause)
d2086 1
a2086 1
							&& GetStatus(false) == PS_PAUSED)) )
d5809 1
a5809 1
			EnumPartFileStatuses eStatus = GetStatus(false);
@


1.671
log
@Large file size support preparations.
@
text
@d5522 1
a5522 1
//	ReadFileForUpload() opens known file and read information in circular way.
d5524 1
a5524 1
//			dwOffset      - file offset to start reading from;
d5529 1
a5529 1
int CPartFile::ReadFileForUpload(uint32 dwOffset, uint32 dwBytesToRead, byte *pbyteBuffer)
d5542 3
a5544 8
		m_hPartFileRead.Seek(dwOffset, CFile::begin);

		if (uint32 dwDone = m_hPartFileRead.Read(pbyteBuffer, dwBytesToRead) != dwBytesToRead)
		{
			m_hPartFileRead.SeekToBegin();
			m_hPartFileRead.Read(pbyteBuffer + dwDone, dwBytesToRead - dwDone);
		}
		iRc = 1;
d5549 1
a5549 1
		iRc = (::CircularFileRead(m_strFilePath, dwOffset, dwBytesToRead, pbyteBuffer)) ? 0 : -1;
@


1.670
log
@Large file size support preparations;
Faster calculation of part end to slightly compensate 64bit calculations overhead (this can be used now as we don't have 32bit limits anymore).
@
text
@d1334 1
a1334 1
		if (dwPart == (pReqBlock->m_dwStartOffset / PARTSIZE))
d1351 1
a1351 1
		if ((qwStart <= cur_block->m_dwEndOffset) && (qwEnd >= cur_block->m_dwStartOffset))
d1410 2
a1411 2
					block->m_dwStartOffset = qwStartOffset;
					block->m_dwEndOffset = qwEndOffset;
d2353 1
a2353 1
		dwTmp = pReqBlock->m_dwStartOffset / PARTSIZE;
d2604 1
a2604 1
void CPartFile::RemoveBlockFromList(uint32 start, uint32 dwEnd)
d2611 3
a2613 1
		if (requestedblocks_list.GetNext(pos1)->m_dwStartOffset <= start && requestedblocks_list.GetAt(pos2)->m_dwEndOffset >= dwEnd)
@


1.669
log
@Large file size support preparations; Renamed DS_LOWTOLOWIP -> DS_LOWTOLOWID.
@
text
@d275 1
a275 1
	m_dwCompletedPartsSize = 0;
d733 1
a733 1
		uint32 dwStart, dwEnd;
d735 2
a736 4
		if (IsPartComplete(i, &dwStart, &dwEnd))
		{
			m_dwCompletedPartsSize += dwEnd - dwStart + 1;
		}
d1160 1
a1160 1
		uint32 dwPartStart, dwPartEnd;
d1162 1
a1162 1
		if (IsPartComplete(i, &dwPartStart, &dwPartEnd))
d1169 1
a1169 1
				AddGap(dwPartStart, dwPartEnd);
d1174 1
a1174 1
				AddRxCorruptedAmount(dwPartEnd - dwPartStart + 1);
d1307 3
a1309 3
//			pdwStart - pointer to get part start offset;
//			pdwEnd   - pointer to get part end offset (inclusive).
bool CPartFile::IsPartComplete(uint32 dwPart, uint32 *pdwStart, uint32 *pdwEnd) const
d1311 2
a1312 2
	uint32 dwStart = dwPart * PARTSIZE;
	uint32 dwEnd = ((GetFileSize() - dwStart) > PARTSIZE) ? (dwStart + PARTSIZE - 1) : (GetFileSize() - 1);
d1314 2
a1315 2
	*pdwStart = dwStart;
	*pdwEnd = dwEnd;
d1664 1
a1664 1
		s_LoadBar.FillRange(0, m_dwCompletedPartsSize, crProgress);
d1669 1
a1669 1
		uint32		wc = (uint32)(static_cast<double>(m_dwCompletedPartsSize) / GetFileSize() * w + 0.5);
d4430 1
a4430 1
					m_dwCompletedPartsSize += (partRange + 1);
d4468 1
a4468 1
					m_dwCompletedPartsSize += (partRange + 1);
@


1.668
log
@Recommitment after repository crash -- Fixed file hashing in case of file read error {Fuxie - DK};
Large file size support preparations;
Faster calculation of part end to slightly compensate 64bit calculations overhead
(this can be used now as we don't have 32bit limits anymore);
Removed unrequired/unused code.
@
text
@d1345 1
a1345 1
bool CPartFile::IsAlreadyRequested(uint32 start, uint32 dwEnd)
d1351 3
a1353 2
		Requested_Block_Struct * cur_block = requestedblocks_list.GetNext(pos);
		if ((start <= cur_block->m_dwEndOffset) && (dwEnd >= cur_block->m_dwStartOffset))
d1364 3
a1366 3
//			numPart    - a part to examine;
//			newblocks  - output array for allocated request blocks (can be NULL to check for block allocation);
//			dwCount    - number of blocks to allocate.
d1369 1
a1369 1
uint32 CPartFile::GetGapsInPart(uint16 uPartNum, Requested_Block_Struct** ppNewBlocks, uint32 dwCount)
d1376 2
a1377 2
	const uint32 uPartStart = uPartNum * PARTSIZE;
	const uint32 uPartEnd = ((GetFileSize() - uPartStart) > PARTSIZE) ? (uPartStart + PARTSIZE - 1) : (GetFileSize() - 1);
d1387 1
a1387 1
		if ((pGap->qwStartOffset > uPartEnd) || (pGap->qwEndOffset < uPartStart))
d1391 2
a1392 2
		uint32 uGapStart = (pGap->qwStartOffset < uPartStart) ? uPartStart : pGap->qwStartOffset;
		const uint32 uGapEnd = (pGap->qwEndOffset > uPartEnd) ? uPartEnd : pGap->qwEndOffset;
d1395 1
a1395 1
		while ((uGapEnd >= uGapStart) && (dwNewBlockCount < dwCount))
d1398 2
a1399 2
			const uint32 startOffset = uGapStart;
			const uint32 endOffset = ((uGapStart + EMBLOCKSIZE - 1) >= uGapEnd) ? uGapEnd : ((uGapStart + EMBLOCKSIZE - 1) - (uGapStart % EMBLOCKSIZE));
d1402 1
a1402 1
			uGapStart = endOffset + 1;
d1405 1
a1405 1
			if (!IsAlreadyRequested(startOffset, endOffset))
d1410 4
a1413 3
					Requested_Block_Struct * block = new Requested_Block_Struct;
					block->m_dwStartOffset = startOffset;
					block->m_dwEndOffset = endOffset;
d2018 1
a2018 1
		if (!m_SourceLists[DS_LOWTOLOWIP].empty())
d2020 1
a2020 1
			GetCopySourceList(DS_LOWTOLOWIP, &sourceListCopy);
d2026 1
a2026 1
				if (pSource->GetDownloadState() == DS_LOWTOLOWIP
d2033 1
a2033 1
		m_uSrcLowToLow = m_SourceLists[DS_LOWTOLOWIP].size();
@


1.667
log
@Large file size support preparations.
@
text
@d1611 2
a1612 2
		uint32 dwGapBeg = pGap->qwStartOffset;
		uint32 dwGapEnd = pGap->qwEndOffset + 1ui64;
d1614 1
a1614 1
		for (uint32 i = (dwGapBeg / PARTSIZE); i < GetPartCount(); i++)
d1616 2
a1617 2
			const uint32 dwPartStart = i * PARTSIZE;
			const uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE) : GetFileSize();
d1619 2
a1620 2
			if (dwGapEnd > dwPartEnd)
				dwGapEnd = dwPartEnd;	// The rest is in the next part
d1640 1
a1640 1
			s_ChunkBar.FillRange(dwGapBeg, dwGapEnd, color);
d1642 3
a1644 3
			dwGapBeg = dwGapEnd;
			dwGapEnd = pGap->qwEndOffset + 1ui64;
			if (dwGapBeg == dwGapEnd)	// Finished?
a1784 26
//	Inserted by Vorlost for load rarest parts first, code by Denominator
uint16 CPartFile::GetRemainingBlocksInPart(uint16 partnumber)
{
	EMULE_TRY

	uint16		uNumRemainingBlocks = 0;
	for (uint32 i = 0; i < ((PARTSIZE + EMBLOCKSIZE - 1) / EMBLOCKSIZE); i++)
	{
		uint32 start = (PARTSIZE * partnumber) + i * EMBLOCKSIZE;
		uint32 dwEnd = (PARTSIZE * partnumber) + ((i + 1) * EMBLOCKSIZE) - 1;
		if (dwEnd >= PARTSIZE * ((uint32)partnumber + 1))
			dwEnd = (PARTSIZE * (partnumber + 1)) - 1;
		if (start >= GetFileSize())
			break;
		if (dwEnd >= GetFileSize())
			dwEnd = GetFileSize() - 1;
		if (!IsComplete(start, dwEnd) && !IsAlreadyRequested(start, dwEnd))
			uNumRemainingBlocks++;
	}
	return uNumRemainingBlocks;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a2603 11
uint32 CPartFile::GetPartFilledSize(uint32 dwPartNum) const
{
	uint32 dwStart = dwPartNum * PARTSIZE;
	uint32 dwEnd = ((GetFileSize() - dwStart) > PARTSIZE) ? (dwStart + PARTSIZE - 1) : (GetFileSize() - 1);

	uint32 dwLeftSize = (dwEnd - dwStart + 1) - GetPartLeftToDLSize(dwPartNum);

	ASSERT(dwLeftSize <= PARTSZ32);
	return dwLeftSize;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3240 2
d3259 1
a3259 1
		CFile	*pPartFile = m_hPartFileRead.Duplicate();
d3274 1
d3285 1
d4383 1
d4396 2
d4399 1
a4399 1
			if (IsComplete(PARTSIZE * iPartNum, PARTSIZE * static_cast<uint64>(iPartNum) + static_cast<uint64>(partRange)))
d4407 1
a4407 1
					AddGap(PARTSIZE * iPartNum, (PARTSIZE * iPartNum + partRange));
d4449 2
a4450 2
					FillGap(PARTSIZE * iPartNum, (PARTSIZE * iPartNum + partRange));
					RemoveBlockFromList(PARTSIZE * iPartNum, (PARTSIZE * iPartNum + partRange));
d4546 1
a4546 2
	Gap_Struct	*gap;
	Gap_Struct	*best = NULL;
d4548 1
a4548 2
	uint32		start = 0;
	uint32		bestEnd;
d4560 1
a4560 1
		bestEnd = GetFileSize();
d4565 1
a4565 1
			if ((gap->qwStartOffset > start) && (gap->qwEndOffset < bestEnd))
d4568 1
a4568 1
				bestEnd = best->qwEndOffset;
d4577 1
a4577 1
			gap->qwStartOffset = start;
d4579 1
a4579 1
			start = best->qwEndOffset + 1ui64;
d4587 2
a4588 2
			bestEnd = GetFileSize() - 1;
			if (best->qwEndOffset < bestEnd)	//	Don't add anything beyond file size
d4592 1
a4592 1
				gap->qwEndOffset = bestEnd;
d5186 2
a5187 2
			uint32			dwGapBeg = pGap->qwStartOffset;
			uint32			dwGapEnd = pGap->qwEndOffset + 1ui64;
d5189 1
a5189 1
			for (uint32 i = (dwGapBeg / PARTSIZE); i < GetPartCount(); i++)
d5191 2
a5192 2
				const uint32 dwPartStart = i * PARTSIZE;
				const uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE) : GetFileSize();
d5194 2
a5195 2
				if (dwGapEnd > dwPartEnd)
					dwGapEnd = dwPartEnd;	// The rest is in the next part
d5210 1
a5210 1
				CharFillRange(&strChunkBar, static_cast<double>(dwGapBeg) * unit, static_cast<double>(dwGapEnd) * unit, color);
d5212 3
a5214 3
				dwGapBeg = dwGapEnd;
				dwGapEnd = pGap->qwEndOffset + 1ui64;
				if (dwGapBeg == dwGapEnd) // finished?
d5274 5
a5278 2
	byte * result = new byte[GetPartCount() + 1];
	for (int i = 0; i < GetPartCount(); i++)
d5280 3
a5282 5
		result[i] = 0;
		if (IsPartComplete(i))
		{
			result[i] = 1;
		}
d5285 12
a5296 12
			if (IsComplete(i * PARTSIZE + (0 * (PARTSIZE / 3)), ((i * PARTSIZE) + (1 * (PARTSIZE / 3))) - 1))
				result[i] += 2;
			if (IsComplete(i * PARTSIZE + (1 * (PARTSIZE / 3)), ((i * PARTSIZE) + (2 * (PARTSIZE / 3))) - 1))
				result[i] += 4;
			if (IsComplete(i * PARTSIZE + (2 * (PARTSIZE / 3)), ((i * PARTSIZE) + (3 * (PARTSIZE / 3))) - 1))
				result[i] += 8;
			byte freq = (byte)m_srcPartFrequencies[i];
			if (freq > 44)
				freq = 44;
			freq = (freq + 2) / 3;
			freq <<= 4;
			result[i] += freq;
d5298 1
@


1.666
log
@Large file size support preparations; Unicode corrections.
@
text
@d1267 2
a1268 2
//	IsComplete() returns false if there are gaps in the range 'start' to 'dwEnd' (inclusive).
bool CPartFile::IsComplete(uint32 start, uint32 dwEnd)
d1272 2
a1273 2
	if (dwEnd >= GetFileSize())
		dwEnd = GetFileSize() - 1;
d1284 4
a1287 4
		if ( (pGap->qwStartOffset >= start && pGap->qwEndOffset <= dwEnd)			// gap is inside range (this check is unnecessary)
		     || (pGap->qwStartOffset >= start && pGap->qwStartOffset <= dwEnd)	// gap starts inside range
		     || (pGap->qwEndOffset <= dwEnd && pGap->qwEndOffset >= start)		// gap ends inside range
		     || (start >= pGap->qwStartOffset && dwEnd <= pGap->qwEndOffset) )	// range is inside gap
d4429 1
a4429 1
			if (IsComplete(PARTSIZE * iPartNum, (PARTSIZE * (iPartNum + 1)) - 1))
d5537 1
a5537 1
	return IsComplete(GetFileSize() - GetLastBlockSize(), GetFileSize() - 1);
@


1.665
log
@Removed unused code.
@
text
@a315 1
	{
a316 1
	}
d622 2
a623 2
								gap->m_dwStartOffset = ~0u;
								gap->m_dwEndOffset = ~0u;
d626 1
a626 1
								gap->m_dwStartOffset = newtag->GetIntValue();
d628 1
a628 1
								gap->m_dwEndOffset = newtag->GetIntValue() - 1;
d697 2
a698 1
		if (gap->m_dwStartOffset != -1 && gap->m_dwEndOffset != -1 && gap->m_dwStartOffset <= gap->m_dwEndOffset && gap->m_dwStartOffset < GetFileSize())
d700 3
a702 3
			if (gap->m_dwEndOffset >= GetFileSize())
				gap->m_dwEndOffset = GetFileSize() - 1; 		// Clipping
			AddGap(gap->m_dwStartOffset, gap->m_dwEndOffset); 	// All tags accounted for, use safe adding
d767 1
a767 1
		AddGap(static_cast<uint32>(qwFileSz), GetFileSize() - 1);
d1080 1
a1080 1
			tagWr.WriteToFile(acNameBuffer, pGap->m_dwStartOffset, file);
d1084 1
a1084 1
			tagWr.WriteToFile(acNameBuffer, pGap->m_dwEndOffset + 1, file);
d1223 3
a1225 2
		Gap_Struct* cur_gap = gaplist.GetNext(pos1);
		if (cur_gap->m_dwStartOffset >= qwStart && cur_gap->m_dwEndOffset <= qwEnd)
d1228 3
a1230 3
			m_qwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset + 1;
			FillGapInParts(cur_gap->m_dwStartOffset, cur_gap->m_dwEndOffset);
			delete cur_gap;
d1232 1
a1232 1
		else if (cur_gap->m_dwStartOffset >= qwStart && cur_gap->m_dwStartOffset <= qwEnd)
d1234 1
a1234 1
			qwEnd = cur_gap->m_dwEndOffset;
d1236 3
a1238 3
			m_qwGapsSum -= qwEnd - cur_gap->m_dwStartOffset + 1;
			FillGapInParts(cur_gap->m_dwStartOffset, qwEnd);
			delete cur_gap;
d1240 1
a1240 1
		else if (cur_gap->m_dwEndOffset <= qwEnd && cur_gap->m_dwEndOffset >= qwStart)
d1242 1
a1242 1
			qwStart = cur_gap->m_dwStartOffset;
d1244 3
a1246 3
			m_qwGapsSum -= cur_gap->m_dwEndOffset - qwStart + 1;
			FillGapInParts(qwStart, cur_gap->m_dwEndOffset);
			delete cur_gap;
d1248 1
a1248 1
		else if (qwStart >= cur_gap->m_dwStartOffset && qwEnd <= cur_gap->m_dwEndOffset)
d1254 2
a1255 2
	new_gap->m_dwStartOffset = qwStart;
	new_gap->m_dwEndOffset = qwEnd;
d1282 1
a1282 1
		Gap_Struct * cur_gap = gaplist.GetNext(pos);
d1284 4
a1287 4
		if ( (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= dwEnd)			// gap is inside range (this check is unnecessary)
		     || (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwStartOffset <= dwEnd)	// gap starts inside range
		     || (cur_gap->m_dwEndOffset <= dwEnd && cur_gap->m_dwEndOffset >= start)		// gap ends inside range
		     || (start >= cur_gap->m_dwStartOffset && dwEnd <= cur_gap->m_dwEndOffset) )	// range is inside gap
d1383 1
a1383 1
		Gap_Struct *CurGap = gaplist.GetNext(pos);
d1386 1
a1386 1
		if (CurGap->m_dwStartOffset > uPartEnd || CurGap->m_dwEndOffset < uPartStart)
d1390 2
a1391 2
		uint32 uGapStart = (CurGap->m_dwStartOffset < uPartStart) ? uPartStart : CurGap->m_dwStartOffset;
		const uint32 uGapEnd = (CurGap->m_dwEndOffset > uPartEnd) ? uPartEnd : CurGap->m_dwEndOffset;
d1440 3
a1442 2
		Gap_Struct* cur_gap = gaplist.GetNext(pos1);
		if (cur_gap->m_dwStartOffset >= qwStart && cur_gap->m_dwEndOffset <= qwEnd)
d1445 3
a1447 3
			m_qwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset + 1;
			FillGapInParts(cur_gap->m_dwStartOffset, cur_gap->m_dwEndOffset);
			delete cur_gap;
d1449 1
a1449 1
		else if (cur_gap->m_dwStartOffset >= qwStart && cur_gap->m_dwStartOffset <= qwEnd)
d1451 3
a1453 3
			m_qwGapsSum -= qwEnd - cur_gap->m_dwStartOffset + 1;
			FillGapInParts(cur_gap->m_dwStartOffset, qwEnd);
			cur_gap->m_dwStartOffset = qwEnd + 1;
d1455 1
a1455 1
		else if (cur_gap->m_dwEndOffset <= qwEnd && cur_gap->m_dwEndOffset >= qwStart)
d1457 12
a1468 12
			m_qwGapsSum -= cur_gap->m_dwEndOffset - qwStart + 1;
			FillGapInParts(qwStart, cur_gap->m_dwEndOffset);
			cur_gap->m_dwEndOffset = qwStart - 1;
		}
		else if (qwStart >= cur_gap->m_dwStartOffset && qwEnd <= cur_gap->m_dwEndOffset)
		{
			uint32 dwTmp = cur_gap->m_dwEndOffset;

			cur_gap->m_dwEndOffset = qwStart - 1;
			cur_gap = new Gap_Struct;
			cur_gap->m_dwStartOffset = qwEnd + 1;
			cur_gap->m_dwEndOffset = dwTmp;
d1471 1
a1471 1
			gaplist.InsertAfter(pos1, cur_gap);
d1611 2
a1612 2
		uint32 dwGapBeg = pGap->m_dwStartOffset;
		uint32 dwGapEnd = pGap->m_dwEndOffset + 1;
d1643 1
a1643 1
			dwGapEnd = pGap->m_dwEndOffset + 1;
d4597 1
a4597 1
			if ((gap->m_dwStartOffset > start) && (gap->m_dwEndOffset < bestEnd))
d4600 1
a4600 1
				bestEnd = best->m_dwEndOffset;
d4609 3
a4611 3
			gap->m_dwStartOffset = start;
			gap->m_dwEndOffset = best->m_dwStartOffset - 1;
			start = best->m_dwEndOffset + 1;
d4620 1
a4620 1
			if (best->m_dwEndOffset < bestEnd)	//	Don't add anything beyond file size
d4623 2
a4624 2
				gap->m_dwStartOffset = best->m_dwEndOffset + 1;
				gap->m_dwEndOffset = bestEnd;
d5189 6
a5194 7
	const char crProgress = '0';										// Green
	const char crHave = '1';											// Black
	const char crPending = '2';											// Yellow
	const char crMissing = '3';											// Red
	static const char crWaiting[6] = { '4', '5', '6', '7', '8', '9'};	// Differents blue

	CString	my_ChunkBar;
d5197 1
a5197 1
		my_ChunkBar.AppendChar(crHave);	// One more for safety
d5207 1
a5207 1
		CharFillRange(&my_ChunkBar, 0, static_cast<double>(m_nFileSize) * unit, crProgress);
d5218 2
a5219 2
			uint32			dwGapBeg = pGap->m_dwStartOffset;
			uint32			dwGapEnd = pGap->m_dwEndOffset + 1;
d5229 1
a5229 1
				byte	color;
d5242 1
a5242 1
				CharFillRange(&my_ChunkBar, static_cast<double>(dwGapBeg) * unit, static_cast<double>(dwGapEnd) * unit, color);
d5245 1
a5245 1
				dwGapEnd = pGap->m_dwEndOffset + 1;
d5253 1
a5253 1
	return my_ChunkBar;
d5260 1
a5260 1
void CPartFile::CharFillRange(CString* buffer, double start, double dblEnd, char color)
d5265 1
a5265 1
		buffer->SetAt(i, color);
@


1.664
log
@Large file size support preparations;
Faster calculation of part end to slightly compensate 64bit calculations overhead
(this can be used now as we don't have 32bit limits anymore).
@
text
@a1944 3
			uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_App.m_pServerConnect->IsLowID();

a1965 2
				uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
				bool	bIsLowId = g_App.m_pServerConnect->IsLowID();
a2005 3
			uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_App.m_pServerConnect->IsLowID();

a2015 1
					continue;
a2042 3
			uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_App.m_pServerConnect->IsLowID();

a2052 1
					continue;
@


1.663
log
@Large file size support preparations.
@
text
@d273 1
a273 1
	m_dwGapsSum = 0;
d1214 1
a1214 1
void CPartFile::AddGap(uint32 dwStart, uint32 dwEnd)
d1225 1
a1225 1
		if (cur_gap->m_dwStartOffset >= dwStart && cur_gap->m_dwEndOffset <= dwEnd)
d1228 1
a1228 1
			m_dwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset + 1;
d1232 1
a1232 1
		else if (cur_gap->m_dwStartOffset >= dwStart && cur_gap->m_dwStartOffset <= dwEnd)
d1234 1
a1234 1
			dwEnd = cur_gap->m_dwEndOffset;
d1236 2
a1237 2
			m_dwGapsSum -= dwEnd - cur_gap->m_dwStartOffset + 1;
			FillGapInParts(cur_gap->m_dwStartOffset, dwEnd);
d1240 1
a1240 1
		else if (cur_gap->m_dwEndOffset <= dwEnd && cur_gap->m_dwEndOffset >= dwStart)
d1242 1
a1242 1
			dwStart = cur_gap->m_dwStartOffset;
d1244 2
a1245 2
			m_dwGapsSum -= cur_gap->m_dwEndOffset - dwStart + 1;
			FillGapInParts(dwStart, cur_gap->m_dwEndOffset);
d1248 1
a1248 1
		else if (dwStart >= cur_gap->m_dwStartOffset && dwEnd <= cur_gap->m_dwEndOffset)
d1254 4
a1257 4
	new_gap->m_dwStartOffset = dwStart;
	new_gap->m_dwEndOffset = dwEnd;
	m_dwGapsSum += dwEnd - dwStart + 1;
	AddGapToParts(dwStart, dwEnd);
d1444 1
a1444 1
			m_dwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset + 1;
d1450 1
a1450 1
			m_dwGapsSum -= qwEnd - cur_gap->m_dwStartOffset + 1;
d1456 1
a1456 1
			m_dwGapsSum -= cur_gap->m_dwEndOffset - qwStart + 1;
d1468 1
a1468 1
			m_dwGapsSum -= qwEnd - qwStart + 1;
d1492 1
a1492 1
		uint64 qwPartEnd = ((GetFileSize() - qwPartStart) > PARTSIZE) ? (qwPartStart + PARTSIZE - 1ui64) : (GetFileSize() - 1ui64);
d1523 1
a1523 1
		uint64 qwPartEnd = ((GetFileSize() - qwPartStart) > PARTSIZE) ? (qwPartStart + PARTSIZE - 1ui64) : (GetFileSize() - 1ui64);
d1549 1
a1549 1
	if ((m_dwGapsSum != 0) || (requestedblocks_list.GetCount() != 0))
d1551 2
a1552 2
		m_dblPercentCompleted = (1.0 - static_cast<double>(m_dwGapsSum) / GetFileSize()) * 100;
		m_dwCompletedSize = GetFileSize() - m_dwGapsSum;
@


1.662
log
@Large file size support preparations.
@
text
@d1484 1
a1484 1
void CPartFile::FillGapInParts(uint32 dwGapStart, uint32 dwGapEnd)
d1486 5
a1490 1
	for (uint32 dwPart = (dwGapStart / PARTSIZE); dwPart <= (dwGapEnd / PARTSIZE); dwPart++)
d1492 1
a1492 2
		uint32 dwPartStart = dwPart * PARTSIZE;
		uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE - 1) : (GetFileSize() - 1);
d1495 1
a1495 1
		if (dwGapStart <= dwPartStart)
d1497 1
a1497 1
			if (dwGapEnd >= dwPartEnd)	//	[Gs (Ps Pe) Ge]
d1500 1
a1500 1
				dwPartFilledSize -= dwGapEnd - dwPartStart + 1;
d1504 3
a1506 3
			if (dwGapEnd < dwPartEnd)	//	(Ps [Gs Ge] Pe) else (Ps [Gs Pe) Ge]
				dwPartEnd = dwGapEnd;
			dwPartFilledSize -= dwPartEnd - dwGapStart + 1;
d1515 1
a1515 1
void CPartFile::AddGapToParts(uint32 dwGapStart, uint32 dwGapEnd)
d1517 5
a1521 1
	for (uint32 dwPart = (dwGapStart / PARTSIZE); dwPart <= (dwGapEnd / PARTSIZE); dwPart++)
d1523 1
a1523 2
		uint32 dwPartStart = dwPart * PARTSIZE;
		uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE - 1) : (GetFileSize() - 1);
d1526 1
a1526 1
		if (dwGapStart <= dwPartStart)
d1528 2
a1529 2
			if (dwGapEnd >= dwPartEnd)	//	[Gs (Ps Pe) Ge]
				dwPartFilledSize = dwPartEnd - dwPartStart + 1;
d1531 1
a1531 1
				dwPartFilledSize += dwGapEnd - dwPartStart + 1;
d1535 3
a1537 3
			if (dwGapEnd < dwPartEnd)	//	(Ps [Gs Ge] Pe) else (Ps [Gs Pe) Ge]
				dwPartEnd = dwGapEnd;
			dwPartFilledSize += dwPartEnd - dwGapStart + 1;
@


1.661
log
@Large file size support preparations;
Reduced H-file dependency.
@
text
@d1430 1
a1430 1
void CPartFile::FillGap(uint32 dwStart, uint32 dwEnd)
d1441 1
a1441 1
		if (cur_gap->m_dwStartOffset >= dwStart && cur_gap->m_dwEndOffset <= dwEnd)
d1448 1
a1448 1
		else if (cur_gap->m_dwStartOffset >= dwStart && cur_gap->m_dwStartOffset <= dwEnd)
d1450 3
a1452 3
			m_dwGapsSum -= dwEnd - cur_gap->m_dwStartOffset + 1;
			FillGapInParts(cur_gap->m_dwStartOffset, dwEnd);
			cur_gap->m_dwStartOffset = dwEnd + 1;
d1454 1
a1454 1
		else if (cur_gap->m_dwEndOffset <= dwEnd && cur_gap->m_dwEndOffset >= dwStart)
d1456 3
a1458 3
			m_dwGapsSum -= cur_gap->m_dwEndOffset - dwStart + 1;
			FillGapInParts(dwStart, cur_gap->m_dwEndOffset);
			cur_gap->m_dwEndOffset = dwStart - 1;
d1460 1
a1460 1
		else if (dwStart >= cur_gap->m_dwStartOffset && dwEnd <= cur_gap->m_dwEndOffset)
d1464 1
a1464 1
			cur_gap->m_dwEndOffset = dwStart - 1;
d1466 1
a1466 1
			cur_gap->m_dwStartOffset = dwEnd + 1;
d1468 2
a1469 2
			m_dwGapsSum -= dwEnd - dwStart + 1;
			FillGapInParts(dwStart, dwEnd);
@


1.660
log
@Large file size support preparations.
@
text
@d20 1
a4263 3
#if 1//temp
	uint32 dwStart = (uint32)qwStart, dwEnd = (uint32)qwEnd;
#endif
d4266 1
a4266 1
	uint32	dwDataLen = dwEnd - dwStart + 1;
d4271 1
a4271 1
		m_qwGainDueToCompression += static_cast<uint64>(iComprGain);
d4276 1
a4276 1
	if (IsComplete(dwStart, dwEnd))
d4285 2
a4286 2
		item->m_dwStartOffset = dwStart;
		item->m_dwEndOffset = dwEnd;
d4296 1
a4296 1
		item->m_pbyteBuffer = data;
d4307 1
a4307 1
			if (item->m_dwEndOffset > queueItem->m_dwEndOffset)
d4321 1
a4321 1
		FillGap(item->m_dwStartOffset, item->m_dwEndOffset);
d4323 1
a4323 1
		uint32 dwPartNum = dwStart / PARTSIZE;
d4370 1
a4370 1
	uint32	dwPartCount = GetPartCount();
a4376 1
		{
a4377 1
		}
d4383 2
a4384 2
		if (m_hPartFileWrite.GetLength() <= item->m_dwEndOffset)
			m_hPartFileWrite.SetLength(item->m_dwEndOffset + 1);
d4393 4
a4396 2
			for (uint32 curPart = item->m_dwStartOffset / PARTSIZE; curPart <= item->m_dwEndOffset / PARTSIZE; curPart++)
				changedPart[curPart] = true;
d4399 1
a4399 1
			m_hPartFileWrite.Seek(item->m_dwStartOffset, CFile::begin);
d4401 1
a4401 1
			uint32 lenData = item->m_dwEndOffset - item->m_dwStartOffset + 1;
d4405 1
a4405 1
			m_hPartFileWrite.Write(item->m_pbyteBuffer, lenData);
d4408 1
a4408 1
			delete [] item->m_pbyteBuffer;
@


1.659
log
@Preparations to process 64bit data packets.
@
text
@d118 1
a118 1
//	Don't ask for a hashset, if there is none.
d183 1
a183 1
			return ;
d1094 1
a1094 1
		OUTPUT_DEBUG_TRACE	();
d2422 2
a2423 2
	uint32		dwMostCompletedRarePartSz = PARTSIZE, dwMoviePartsCnt = 0;
	uint32		dwMostCompletedPartSz = (bShortestToComplete) ? PARTSIZE : 0;
d2436 1
a2436 1
				if (PartsFilledSizeVector[i] == PARTSIZE || ((i == dwPartCnt1) && PartsFilledSizeVector[i] == dwLastPartSize))
d2501 1
a2501 1
			if (PartsFilledSizeVector[i] == PARTSIZE || ((i == dwPartCnt1) && PartsFilledSizeVector[i] == dwLastPartSize))
d2596 1
a2596 1
	else if ((dwMostCompletedPartSz != PARTSIZE) && (dwMostCompletedPartSz != 0))
d2642 1
a2642 1
	ASSERT(dwLeftSize <= PARTSIZE);
d3303 1
a3303 1
		uint32 length = PARTSIZE;
d3309 1
a3309 1
		ASSERT(length <= PARTSIZE);
d4268 1
a4268 2
//	This is needed a few times
	uint32 lenData = dwEnd - dwStart + 1;
d4280 1
a4280 1
		AddDebugLogLine(_T("File '%s' has already been written from %lu to %lu size %lu"), GetFileName(), dwStart, dwEnd, lenData);
d4293 1
a4293 1
			BYTE *buffer = new BYTE[lenData];
d4295 1
a4295 1
			memcpy2(buffer, data, lenData);
d4320 1
a4320 1
		m_nTotalBufferData += lenData;
d4343 1
a4343 1
		return lenData;
d4349 1
a4349 1
		delete [] data;
d4432 1
a4432 1
				partRange = PARTSIZE - 1;
d4510 1
a4510 1
			partRange = PARTSIZE - 1;
@


1.658
log
@update the state for LowID clients only after server change
@
text
@d4252 6
a4257 6
//			iCompressionGain - number of bytes saved by compression (it can be negative
//			                   after connection loss in the middle of compressed block);
//			data             - pointer to data buffer;
//			dwStart          - data start offset;
//			dwEnd            - data end offset (inclusive);
//			iFlags           - additional flags.
d4261 1
a4261 1
uint32 CPartFile::WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 dwStart, uint32 dwEnd, int iFlags)
d4263 3
d4271 1
a4271 1
	if (iCompressionGain != 0)
d4274 2
a4275 2
		m_qwGainDueToCompression += static_cast<uint64>(iCompressionGain);
		g_App.m_pPrefs->Add2SavedFromCompression(iCompressionGain);
@


1.657
log
@roll back the changes that lead to performance drop
@
text
@a1949 15
			//	Manage the state only if client is not connected
				if (pSource->HasLowID() && (pSource->m_pRequestSocket == NULL))
				{
					if (bIsLowId)
					{
						pSource->SetDownloadState(DS_LOWTOLOWIP);
						continue;
					}
					else if (pSource->GetServerIP() != dwLocalServerIP)
					{
						pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
						continue;
					}
				}

a1978 15
				//	Manage the state only if client is not connected
					if (pSource->HasLowID() && (pSource->m_pRequestSocket == NULL))
					{
						if (bIsLowId)
						{
							pSource->SetDownloadState(DS_LOWTOLOWIP);
							continue;
						}
						else if (pSource->GetServerIP() != dwLocalServerIP)
						{
							pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
							continue;
						}
					}

a2018 23

			//	Manage the state only if client is not connected
				if (pSource->m_pRequestSocket != NULL)
					continue;

				if (bIsLowId)
				{
					pSource->SetDownloadState(DS_LOWTOLOWIP);
					continue;
				}

			//	Check if a local or remote client changes a server
				if (pSource->GetServerIP() == dwLocalServerIP)
				{
					if (pSource->HasClientNeededParts())
						pSource->SetDownloadState(DS_ONQUEUE);
					else
						pSource->SetDownloadState(DS_NONEEDEDPARTS);
#if 0
					AddDebugLogLine( RGB_BLUE_VIOLET_TXT _T("LowID client %s is on again the same server (%s)"),
									pSource->GetClientNameWithSoftware(), this->GetFileName() );
#endif
				}
a2059 15

			//	Manage the state only if client is not connected
				if (pSource->m_pRequestSocket != NULL)
					continue;

			//	Check local LowID status
				if (!bIsLowId)
				{
					if (pSource->GetServerIP() != dwLocalServerIP)
						pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
					else if (pSource->HasClientNeededParts())
						pSource->SetDownloadState(DS_ONQUEUE);
					else
						pSource->SetDownloadState(DS_NONEEDEDPARTS);
				}
@


1.656
log
@new email notifier code (adapted from original) - fully UNICODE ready;
option to send email notification messages in subject
@
text
@d1914 15
a1928 1
				(*cIt)->DownloadProcess(dwReduceDownload);;
d1938 3
d1948 19
a1966 1
				(*cIt)->DownloadProcess(dwReduceDownload);
d1977 2
d1994 15
d2014 2
a2015 1
					pSource->DownloadProcess(dwReduceDownload);
d2034 3
d2040 32
a2071 1
				(*cIt)->DownloadProcess(dwReduceDownload);
d2088 2
a2089 1
				(*cIt)->DownloadProcess(dwReduceDownload);
d2098 3
d2104 24
a2127 1
				(*cIt)->DownloadProcess(dwReduceDownload);
@


1.655
log
@Simplified calculations in GetTimeRemaining().
@
text
@a32 1
#include "Smtp.h"
d2871 1
a2871 1
			g_App.m_pSMTPConnection->SendMail(MessageText, g_App.m_pPrefs->GetNotifierPopOnImportantError(), g_App.m_pPrefs->IsSMTPWarningEnabled());
d2926 1
a2926 1
			g_App.m_pSMTPConnection->SendMail(MessageText, g_App.m_pPrefs->GetNotifierPopOnImportantError(), g_App.m_pPrefs->IsSMTPWarningEnabled());
d3004 1
a3004 1
	g_App.m_pSMTPConnection->SendMail(MessageText, g_App.m_pPrefs->GetUseDownloadNotifier(), g_App.m_pPrefs->IsSMTPInfoEnabled());
d4499 1
a4499 1
			g_App.m_pSMTPConnection->SendMail(MessageText, g_App.m_pPrefs->GetNotifierPopOnImportantError(), g_App.m_pPrefs->IsSMTPWarningEnabled());
@


1.654
log
@rare incorrect setting of NNS state by download
@
text
@d3599 2
a3600 4
	EMULE_TRY

	uint32	iDataRate = 0;
	sint32	iTimeRemaining = -1;
d3602 1
a3602 5
	if (bAverage)
		iDataRate = GetAvgDataRate();
	else
		iDataRate = GetDataRate();
	iTimeRemaining = (iDataRate > 0 ? (GetFileSize() - GetCompletedSize()) / iDataRate : -1);
a3603 4

	EMULE_CATCH

	return -1;
@


1.653
log
@Fixed archive preview recovery for some boundary conditions (some files inside archive couldn't be recovered);
Fixed processing of incorrect data while recovering for archive preview.
@
text
@d1915 1
a1915 17
				pSource = *cIt;

#ifdef OLD_SOCKETS_ENABLED
			//	If the request socket doesn't exist or isn't connected
				if ((pSource->m_pRequestSocket == NULL) || !pSource->m_pRequestSocket->IsConnected())
				{
					pSource->SetDownloadState(DS_ERROR);
					pSource->Disconnected();
				}
				else if (dwCurTick - pSource->GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000)
				{
					if (pSource->HasClientNeededParts())
						pSource->SetDownloadState(DS_ONQUEUE);
					else
						pSource->SetDownloadState(DS_NONEEDEDPARTS);
				}
#endif //OLD_SOCKETS_ENABLED
a1924 3
			uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_App.m_pServerConnect->IsLowID();

d1932 1
a1932 18
				pSource = *cIt;

				if (pSource->HasLowID())
				{
					if (bIsLowId)
					{
						pSource->SetDownloadState(DS_LOWTOLOWIP);
						continue;
					}
					else if (pSource->GetServerIP() != dwLocalServerIP)
					{
						pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
						continue;
					}
				}

				if (dwCurTick > pSource->GetNextFileReaskTime())
					pSource->SendReask();
a1942 2
				uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
				bool	bIsLowId = g_App.m_pServerConnect->IsLowID();
a1957 14
					if (pSource->HasLowID())
					{
						if (bIsLowId)
						{
							pSource->SetDownloadState(DS_LOWTOLOWIP);
							continue;
						}
						else if (pSource->GetServerIP() != dwLocalServerIP)
						{
							pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
							continue;
						}
					}

d1963 1
a1963 2
					if (dwCurTick > pSource->GetNextFileReaskTime())
						pSource->SendReask();
a1981 3
			uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_App.m_pServerConnect->IsLowID();

d1985 1
a1985 27
				pSource = *cIt;

			//	Since we can't connect to the client we can keep it in the list only if it keeps to request the file(s) from us
				if ((dwCurTick - pSource->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
				{
					g_App.m_pDownloadQueue->RemoveSource(pSource);
					continue;
				}

				if (bIsLowId)
				{
					pSource->SetDownloadState(DS_LOWTOLOWIP);
					continue;
				}

			//	Check if a local or remote client changes a server
				if (pSource->GetServerIP() == dwLocalServerIP)
				{
					if (pSource->HasClientNeededParts())
						pSource->SetDownloadState(DS_ONQUEUE);
					else
						pSource->SetDownloadState(DS_NONEEDEDPARTS);
#if 0
					AddDebugLogLine( RGB_BLUE_VIOLET_TXT _T("LowID client %s is on again the same server (%s)"),
									pSource->GetClientNameWithSoftware(), this->GetFileName() );
#endif
				}
d2002 1
a2002 2
			//	The first request is always TCP request
				(*cIt)->AskForDownload();
a2010 3
			uint32	dwLocalServerIP = g_App.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_App.m_pServerConnect->IsLowID();

d2014 1
a2014 19
				pSource = *cIt;

			//	Since we can't connect to the client we can keep it in the list only if it keeps to request the file(s) from us
				if ((dwCurTick - pSource->GetLastUpRequest()) > MAX_PURGEQUEUETIME)
				{
					g_App.m_pDownloadQueue->RemoveSource(pSource);
					continue;
				}

			//	Check local LowID status
				if (!bIsLowId)
				{
					if (pSource->GetServerIP() != dwLocalServerIP)
						pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
					else if (pSource->HasClientNeededParts())
						pSource->SetDownloadState(DS_ONQUEUE);
					else
						pSource->SetDownloadState(DS_NONEEDEDPARTS);
				}
@


1.652
log
@Fixed copying of completing file instead of moving for case sensitive paths {glaskrug}
(the bug was more than 3 years old...).
@
text
@d4646 1
d4651 5
a4655 5
	Gap_Struct * gap = NULL;
	Gap_Struct *best = NULL;
	POSITION pos;
	uint32 start = 0;
	uint32 bestEnd = 0;
d4661 1
a4661 1
	bool finished = false;
a4668 1
		best = gaplist.GetHead();
d4689 1
a4689 1
		else if (best->m_dwEndOffset < GetFileSize())
d4691 11
a4701 4
			gap = new Gap_Struct;
			gap->m_dwStartOffset = best->m_dwEndOffset + 1;
			gap->m_dwEndOffset = GetFileSize();
			filled->AddTail(gap);
@


1.651
log
@method declaration update due to SourceSaver changes; optimizations; formattings
@
text
@d2876 1
a2876 1
	if ( (_toupper(m_strFilePath[0]) != _toupper(newname[0])) &&
@


1.650
log
@Avoided rare double publishing of a just completed file {muleteer}
(file publishing is sligtly delayed on reception of the first file chunk).
@
text
@d4938 1
a4938 1
CString CPartFile::CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bIsSourceSaver /*=false*/)
d4943 3
a4945 3
	CTypedPtrList<CPtrList, CUpDownClient*> srcstoadd;
	POSITION	pos2;
	ClientList	clientListCopy;
d4950 1
a4950 2
		CUpDownClient	*pSource = *cIt;

d4953 1
a4953 1
		if (srcstoadd.IsEmpty())
d4955 1
a4955 1
			srcstoadd.AddHead(pSource);
d4958 1
a4958 1
		if ((sourcenum == 0) || (srcstoadd.GetCount() < sourcenum) || (pSource->GetAvailablePartCount() > srcstoadd.GetTail()->GetAvailablePartCount()))
d4960 8
a4967 5
			if ((sourcenum != 0) && (srcstoadd.GetCount() == sourcenum))
				srcstoadd.RemoveTail();
			ASSERT(srcstoadd.GetCount() < sourcenum);
			bool bInserted = false;
			for (pos2 = srcstoadd.GetTailPosition(); pos2 != NULL;)
d4969 1
a4969 2
				CUpDownClient * cur_srctoadd = srcstoadd.GetPrev(pos2);
				if (cur_srctoadd->GetAvailablePartCount() > pSource->GetAvailablePartCount())
d4971 1
a4971 1
					srcstoadd.InsertAfter(pos2, pSource);
d4977 1
a4977 1
				srcstoadd.AddHead(pSource);
d4981 1
a4981 12
	uint32 dwID = 0;
#ifdef OLD_SOCKETS_ENABLED
	dwID = g_App.m_pServerConnect->GetClientID();
#endif //OLD_SOCKETS_ENABLED

	CString strLink;
	strLink.Format( _T("ed2k://|file|%s|%u|%s|/"),
			g_App.StripInvalidFilenameChars(GetFileName(), false),  // Spaces to dots
			GetFileSize(),
			HashToString(GetFileHash()) );

	if (srcstoadd.IsEmpty())
a4982 2
		if (bIsSourceSaver)
			return strLink;
d4984 1
a4984 2
	//	!g_App.m_pServerConnect->IsConnected() is not really needed since we give an ip but ...
		else if (!g_App.m_pServerConnect->IsConnected() || g_App.m_pServerConnect->IsLowID())
d4989 2
d4994 13
a5006 1
//	Is the expiration date is handle in other eMule mods ? a bIsSourceSaver is perhaps needed ...
d5008 1
a5008 1
	if (expirein != 0)
d5010 3
a5012 5
		COleDateTime expirationDate = COleDateTime::GetCurrentTime();
		COleDateTimeSpan timediff;
		timediff.SetDateTimeSpan(expirein, 0, 0, 0);
		expirationDate += timediff;
		strLink.AppendFormat(_T("@@%02u%02u%02u"), (expirationDate.GetYear() % 100), expirationDate.GetMonth(), expirationDate.GetDay());
d5015 1
a5015 1
	if (!bIsSourceSaver && dwID >= 0x1000000)
d5018 1
a5018 2
	if (!bIsSourceSaver)
		AddDebugLogLine(_T("Generated ed2k link with %i sources for file '%s' (part count %u)"), (int)srcstoadd.GetCount(), GetFileName(), GetPartCount());
d5020 1
a5020 1
	while (!srcstoadd.IsEmpty())
d5022 2
a5023 3
		CUpDownClient * pSource = srcstoadd.RemoveHead();
		if (!bIsSourceSaver)
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("| User: %s - Available part count: %u"), pSource->GetUserName(), (int)pSource->GetAvailablePartCount());
d5027 1
a5027 1
	strLink.Append(_T("|/"));
@


1.649
log
@A correction for the previous change.
@
text
@d3132 1
a3132 1
	g_App.m_pSharedFilesList->RepublishFile(this);
d4530 2
a4531 1
						g_App.m_pSharedFilesList->SafeAddKnownFile(this);
d4569 2
a4570 1
						g_App.m_pSharedFilesList->SafeAddKnownFile(this);
@


1.648
log
@used splice function instead insert+clear
@
text
@a5808 1

a5812 3

			if (bClearSourceLists)
				m_SourceLists[eDS].clear();
@


1.647
log
@Don't add any tag to the partfile to avoid problems.
@
text
@a5789 2
		pCopy->insert(pCopy->begin(), m_SourceLists[eClientDS].begin(), m_SourceLists[eClientDS].end());

d5791 3
a5793 1
			m_SourceLists[eClientDS].clear();
d5809 5
a5813 1
			pCopy->insert(pCopy->end(), m_SourceLists[eDS].begin(), m_SourceLists[eDS].end());
a5966 2
		pCopy->insert(pCopy->begin(), m_A4AFSourceLists.begin(), m_A4AFSourceLists.end());

d5968 3
a5970 1
			m_A4AFSourceLists.clear();
@


1.646
log
@improved the source removement
@
text
@a76 5
			case FT_SOURCES:
			case FT_COMPLETE_SOURCES:
			case FT_LASTSEENCOMPLETE:
				break;

d79 37
a115 3
				CTag	*pNewTag = new CTag(*pTag);
				m_tagArray.Add(pNewTag);
				break;
d611 1
a611 1
					if ((newtag->GetTagID() == TAGTYPE_NONE) && (pcTagName == NULL))
a2164 1
		//	Use a two-pointer loop to prevent exception due to swaping (delete)
@


1.645
log
@safe A4AF switch
@
text
@d3187 1
a3187 3
	GetCopySourceLists(SLM_ALL, &clientListCopy);

	ClearSourceLists();
d3221 1
a3221 2
		GetCopyA4AFSourceList(&clientListCopy);
		ClearA4AFSourceList();
d3400 1
a3400 1
	GetCopySourceList(DS_DOWNLOADING, &DownloadingListCopy);
d3458 1
a3458 1
	GetCopySourceList(DS_DOWNLOADING, &clientListCopy);
d5753 1
a5753 1
void CPartFile::GetCopySourceList(EnumDLQState eClientDS, ClientList *pCopy)
d5764 3
d5771 1
a5771 1
void CPartFile::GetCopySourceLists(uint32 dwListsMask, ClientList *pCopy)
d5782 3
d5926 1
a5926 1
void CPartFile::GetCopyA4AFSourceList(ClientList *pCopy)
d5937 3
@


1.644
log
@Changed the sequence of conditions -- more probable first.
@
text
@a1827 1
	POSITION		pos1;
d2134 1
a2134 1
		if (g_App.m_pDownloadQueue->GetA4AFAutoFile() == this && !m_A4AFsrcList.IsEmpty())
d2137 2
a2138 1
			for (pos1 = m_A4AFsrcList.GetHeadPosition(); pos1 != NULL;)
d2140 1
a2140 1
				pSource = m_A4AFsrcList.GetNext(pos1);
d2165 1
a2165 1
		m_iSrcA4AF = m_A4AFsrcList.GetCount();
d3221 1
a3221 1
	if (!m_A4AFsrcList.IsEmpty())
d3223 3
a3225 1
		for (POSITION pos = m_A4AFsrcList.GetHeadPosition(); pos != NULL;)
d3227 1
a3227 1
			pRemoveSource = m_A4AFsrcList.GetNext(pos);
d3233 13
a3422 13
	m_iNumTransferringSrcs = 0;
	m_iSrcNNP = 0;
	m_iSrcOnQueue = 0;
	m_uSrcHighQR = 0;
	m_iSrcConnecting = 0;
	m_uSrcWaitForFileReq = 0;
	m_iSrcConnected = 0;
	m_iSrcConnViaServer = 0;
	m_uSrcLowToLow = 0;
	m_uSrcLowIDOnOtherServer = 0;
	m_iSrcQueueFull = 0;
	m_iSrcA4AF = 0;
	m_A4AFsrcList.RemoveAll();
d5319 1
a5319 1
	for (POSITION pos = m_A4AFsrcList.GetHeadPosition(); pos != NULL; )
d5321 5
a5325 1
		if(bSameCat)
d5327 9
a5335 2
			CUpDownClient* pClient = m_A4AFsrcList.GetNext(pos);
			if (pClient->m_pReqPartFile->GetCatID() == GetCatID())
d5337 1
a5338 5
		else
		{
			m_A4AFsrcList.GetNext(pos)->SwapToAnotherFile(this);
		}

d5897 47
@


1.643
log
@fixed the source freq. update on file stop
@
text
@d2302 1
a2302 1
	if ((eStatus == PS_COMPLETING) || (eStatus == PS_COMPLETE) || (eStatus == PS_STOPPED))
@


1.642
log
@Renamed IDS_LASTCHANGE into IDS_LASTRECEPTION;
Removed duplicate string IDS_FD_LASTCHANGE & IDS_LASTSEENCOMPL.
@
text
@d2299 4
a2302 2
//	Update the sources only if it's required
	if ((m_eStatus != PS_READY) && (m_eStatus != PS_EMPTY))
d3191 5
@


1.641
log
@Minor formatting.
@
text
@d5160 2
a5161 2
	             GetResString(IDS_LASTSEENCOMPL), strLastSeenComplete,
	             GetResString(IDS_FD_LASTCHANGE), strLastProgress,
d5205 1
a5205 1
				 GetResString(IDS_LASTCHANGE), strLastProgress,
@


1.640
log
@fixed processing of the connected sources if file was stopped
@
text
@d5866 2
a5867 2
		
		// don't attach the sources if file is completed or stopped
@


1.639
log
@Removed unused code; Use base class instead of safe one.
@
text
@d5865 4
a5868 2
		// don't attach the sources if file is completed
			if ((m_eStatus != PS_COMPLETE) && (m_eStatus != PS_COMPLETING))
@


1.638
log
@Compatibility with VC2005 [brengarne].
@
text
@d3890 2
a3891 2
	CSafeMemFile	packetStream(1024);
	uint16			uCount = 0;
a3973 1
			uCount++;
d3985 1
a3985 1
			if (uCount > 500)
a4089 8
//	Making this function return a higher when more sources have the extended
//	protocol will force you to ask a larger variety of people for sources
uint32 CPartFile::GetCommonFilePenalty()
{
//	TODO: implement, but never return less than MINCOMMONPENALTY!
	return MINCOMMONPENALTY;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.637
log
@file reask by LowID client was skipped if client is on same server
@
text
@d1016 1
d1018 1
a1018 1
		for (uint32 j = 0; j < GetPartCount(); j++)
d2391 1
a2391 1
	uint32				dwNumPartiallyBlockedParts = 0;
d2394 1
a2394 1
	for (uint32 i = 0; i < dwPartCnt; i++)
d2457 1
a2457 1
	for (uint32 i = 0; i < dwPartCnt; i++)
d4865 1
a4865 1
		CUpDownClient* pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(this,pSource->sourceID,pSource->sourcePort, pSource->serverIP, pSource->serverPort, pSource->achUserHash);
@


1.636
log
@fixed source attachmet to the complete file
@
text
@d1927 1
d1929 2
d1932 1
d1934 2
a1935 1
					continue;
d1970 1
d1972 2
d1975 1
d1977 2
a1978 1
						continue;
@


1.635
log
@fixed bug noted by 'Araldo'
@
text
@d5863 8
a5870 4
			EnterCriticalSection(&m_csSourceLists);
			pClient->ChangeDownloadState(eTargetDS);
			m_SourceLists[eTargetDS].push_back(pClient);
			LeaveCriticalSection(&m_csSourceLists);
@


1.634
log
@Formatting.
@
text
@d1726 1
a1726 1
		if ((iDS != DS_ONQUEUE) && (iDS != DS_DOWNLOADING))
@


1.633
log
@Disable debug message due to the amount.
@
text
@d3782 1
a3782 1
	byte	bytedwMovieMode = GetMovieMode();
d3784 1
a3784 1
	if (bytedwMovieMode == 0)
d3788 1
a3788 1
			bytedwMovieMode = (GetLastPartSize() < (GetFileSize() / 100)) ? 7 : 1;
d3795 2
a3796 2
				&& (((bytedwMovieMode != 1) && (bytedwMovieMode != 7)) || IsPartComplete(GetPartCount() - 1))
				&& ((bytedwMovieMode != 7) || IsPartComplete(GetPartCount() - 2))
d3839 2
a3840 2
					&& (((bytedwMovieMode != 1) && (bytedwMovieMode != 7)) || IsPartComplete(GetPartCount() - 1))
					&& ((bytedwMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) );
d3855 1
a3855 1
	byte	bytedwMovieMode = GetMovieMode();
d3857 1
a3857 1
	if (bytedwMovieMode == 0)
d3861 1
a3861 1
			bytedwMovieMode = (GetLastPartSize() < (GetFileSize() / 100)) ? 7 : 1;
d3864 2
a3865 2
				&& (((bytedwMovieMode != 1) && (bytedwMovieMode != 7)) || IsPartComplete(GetPartCount() - 1))
				&& ((bytedwMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) );
@


1.632
log
@AFAF fixes (see change log)
@
text
@d2024 1
d2027 1
@


1.631
log
@allow A4AF switch only for clients with static states with one exception "DS_WAIT_FOR_FILE_REQUEST" for paused files
@
text
@d3182 1
a3182 1
			if (!pRemoveSource->SwapToAnotherFile(NULL, true, true))
d3451 1
a3451 1
		pSource->SwapToAnotherFile(NULL);
@


1.630
log
@Fixed session statistics 'Parts Saved Due To ICH' {Fuxie - DK}.
@
text
@d2128 8
a2135 2
				if ( (pSource != NULL) &&
					(pSource->GetDownloadState() == DS_ONQUEUE || pSource->GetDownloadState() == DS_NONEEDEDPARTS) )
@


1.629
log
@Renaming in comments.
@
text
@d4503 3
a4526 4
#ifndef NEW_SOCKETS_ENGINE
					g_App.m_pPrefs->Add2SessionPartsSavedByICH();
#endif //NEW_SOCKETS_ENGINE

@


1.628
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d4951 1
a4951 1
	//	!g_eMuleApp.m_pServerConnect->IsConnected() is not really needed since we give an ip but ...
@


1.627
log
@renamed 3 variables
@
text
@d249 1
a249 1
	if (g_App.g_pPrefs->IsDAPEnabled())
d301 1
a301 1
	m_strTempDir = g_App.g_pPrefs->GetTempDir();
d368 1
a368 1
	if (g_App.g_pPrefs->IsUAPEnabled())
d385 1
a385 1
	if (g_App.g_pPrefs->GetAutoFilenameCleanup())
d803 1
a803 1
		CHashFileThread* addfilethread = (CHashFileThread*) AfxBeginThread(RUNTIME_CLASS(CHashFileThread), THREAD_PRIORITY_NORMAL + g_App.g_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
d1837 1
a1837 1
		|| (m_nTotalBufferData > (static_cast<uint32>(g_App.g_pPrefs->GetFileBufferSize()) * 30000))
d2153 1
a2153 1
			&& g_App.g_pPrefs->GetMaxSourcePerFileSoft() > uSourceNumber )
d2162 1
a2162 1
		if (g_App.g_pPrefs->SLSEnable() && m_SourceLists[DS_DOWNLOADING].empty() && g_App.m_pServerConnect->IsConnected())
d2164 1
a2164 1
			m_sourcesaver.Process(this, g_App.g_pPrefs->SLSMaxSourcesPerFile());
d2220 1
a2220 1
	if ( iSourceCountPlusNew > g_App.g_pPrefs->GetMaxSourcePerFile()
d2223 1
a2223 1
		RemoveNoNeededSources(iSourceCountPlusNew - g_App.g_pPrefs->GetMaxSourcePerFile());
d2240 1
a2240 1
				 g_App.g_pPrefs->GetPort() == iUserPort &&
d2247 1
a2247 1
				  g_App.g_pPrefs->GetPort() == iUserPort )
d2259 1
a2259 1
		if (g_App.g_pPrefs->GetMaxSourcePerFile() > GetSourceCount())
d2703 1
a2703 1
		                THREAD_PRIORITY_BELOW_NORMAL + g_App.g_pPrefs->GetMainProcessPriority(),
d2712 1
a2712 1
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC)CompleteThreadProc, this, THREAD_PRIORITY_BELOW_NORMAL + g_App.g_pPrefs->GetMainProcessPriority(), 0, 0);
d2787 1
a2787 1
		strFakesFile.Format(_T("%s\\fakes.rar"), g_App.g_pPrefs->GetIncomingDir());
d2793 1
a2793 1
		g_App.g_pPrefs->SharedDirListCopy(&strSharedDirsList);
d2852 1
a2852 1
			int		iBlockSize = g_App.g_pPrefs->SlowCompleteBlockSize() * 1024;
d2927 2
a2928 2
			g_App.m_pSMTPConnection->SendMail(MessageText, g_App.g_pPrefs->GetNotifierPopOnImportantError(), g_App.g_pPrefs->IsSMTPWarningEnabled());
			g_App.m_pMDlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_App.g_pPrefs->GetNotifierPopOnImportantError());
d2982 2
a2983 2
			g_App.m_pSMTPConnection->SendMail(MessageText, g_App.g_pPrefs->GetNotifierPopOnImportantError(), g_App.g_pPrefs->IsSMTPWarningEnabled());
			g_App.m_pMDlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_App.g_pPrefs->GetNotifierPopOnImportantError());
d3044 1
a3044 1
	if (IsULAutoPrioritized() && !g_App.g_pPrefs->IsUAPEnabled())
d3060 2
a3061 2
	g_App.m_pSMTPConnection->SendMail(MessageText, g_App.g_pPrefs->GetUseDownloadNotifier(), g_App.g_pPrefs->IsSMTPInfoEnabled());
	g_App.m_pMDlg->ShowNotifier(MessageText, TBN_DLOAD, false, g_App.g_pPrefs->GetUseDownloadNotifier());
d3073 1
a3073 1
	if (g_App.g_pPrefs->DownloadPausedOnComplete() && !IsFakesDotRar())
d3078 3
a3080 3
	g_App.g_pPrefs->Add2DownCompletedFiles();			// Increments cumDownCompletedFiles in prefs struct
	g_App.g_pPrefs->Add2DownSessionCompletedFiles(); 	// Increments sesDownCompletedFiles in prefs struct
	g_App.g_pPrefs->SaveCompletedDownloadsStat();		// Saves cumDownCompletedFiles to INI
d3085 1
a3085 1
	if (GetPath() != g_App.g_pPrefs->GetIncomingDir())
d3087 1
a3087 1
		if (g_App.g_pPrefs->SharedDirListCheckAndAdd(GetPath(), true))
d3094 1
a3094 1
	if (g_App.g_pPrefs->IsAutoClearCompleted())
d3104 2
a3105 2
	if (g_App.g_pPrefs->IsAVEnabled() &&
		g_App.g_pPrefs->IsAVScanCompleted() && !g_App.g_pPrefs->GetAVPath().IsEmpty())
d3107 2
a3108 2
		strTempFullName.Format(_T("%s \"%s\""), g_App.g_pPrefs->GetAVParams(), m_strFilePath);
		ShellExecute(NULL, _T("open"), g_App.g_pPrefs->GetAVPath(), strTempFullName, NULL, SW_SHOW);
d3115 1
a3115 1
		CString		strFakesDotDatPath = g_App.g_pPrefs->GetConfigDir() + _T("fakes.dat");
d3123 1
a3123 1
		if (pFakeCheck->ExtractRARArchive(m_strFilePath, g_App.g_pPrefs->GetConfigDir()))
d3125 4
a3128 4
			g_App.AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_FAKE_SUCCESS_UPDATE), g_App.g_pPrefs->GetFakesDatVersion(), g_App.g_pPrefs->GetDLingFakeListVersion());
			g_App.g_pPrefs->SetFakesDatVersion(g_App.g_pPrefs->GetDLingFakeListVersion());
			g_App.g_pPrefs->SetDLingFakeListVersion(0);
			g_App.g_pPrefs->SetDLingFakeListLink(_T(""));
d3716 1
a3716 1
	if (g_App.g_pPrefs->BackupPreview())
d3719 2
a3720 2
		CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL + g_App.g_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
		pThread->SetValues(this, g_App.g_pPrefs->GetVideoPlayer());
d3726 1
a3726 1
		CString strPlayer = g_App.g_pPrefs->GetVideoPlayer();
d3783 1
a3783 1
	if (g_App.g_pPrefs->BackupPreview())
d3794 1
a3794 1
		_tsplitpath(g_App.g_pPrefs->GetVideoPlayer(), NULL, NULL, szVideoPlayerFileName, NULL);
d3798 1
a3798 1
		if (g_App.g_pPrefs->GetPreviewSmallBlocks() || !_tcsicmp(szVideoPlayerFileName, _T("vlc")))
d4060 1
a4060 1
		if (iValidSources < g_App.g_pPrefs->PriorityHigh() && priority != PR_HIGH)
d4062 1
a4062 1
		else if (iValidSources >= g_App.g_pPrefs->PriorityHigh() && iValidSources < g_App.g_pPrefs->PriorityLow() && priority != PR_NORMAL)
d4064 1
a4064 1
		else if (iValidSources >= g_App.g_pPrefs->PriorityLow() && priority != PR_LOW)
d4182 2
a4183 2
	if (g_App.g_pPrefs->IsNTBased())
		SetThreadLocale(g_App.g_pPrefs->GetLanguageID());
d4297 1
a4297 1
		g_App.g_pPrefs->Add2SavedFromCompression(iCompressionGain);
d4514 1
a4514 1
					g_App.g_pPrefs->SubLostFromCorruption(dwSaved);
d4525 1
a4525 1
					g_App.g_pPrefs->Add2SessionPartsSavedByICH();
d4553 1
a4553 1
		if (g_App.g_pPrefs->IsErrorBeepEnabled())
d4569 2
a4570 2
			g_App.m_pSMTPConnection->SendMail(MessageText, g_App.g_pPrefs->GetNotifierPopOnImportantError(), g_App.g_pPrefs->IsSMTPWarningEnabled());
			g_App.m_pMDlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_App.g_pPrefs->GetNotifierPopOnImportantError());
d4817 1
a4817 1
			 g_App.g_pPrefs->GetPort() == pSource->sourcePort )
d4825 1
a4825 1
			 g_App.g_pPrefs->GetPort() == pSource->sourcePort )
d4831 1
a4831 1
			  g_App.g_pPrefs->GetPort() == pSource->sourcePort )
d4844 2
a4845 2
	if ( g_App.g_pPrefs->GetMaxSourcePerFile() > GetSourceCount()
	     && iSource < static_cast<int>(g_App.g_pPrefs->GetMaxSourcePerFileSoft()) )
d4972 1
a4972 1
		strLink.AppendFormat(_T(",%u.%u.%u.%u:%u"), (byte)dwID, (byte)(dwID >> 8), (byte)(dwID >> 16), (byte)(dwID >> 24), g_App.g_pPrefs->GetPort());
d5010 1
a5010 1
	CString	strRetPath = g_App.g_pPrefs->GetIncomingDir();
d5085 1
a5085 1
				if (g_App.g_pPrefs->SharedDirListCheckAndAdd(strDir, true))
d5728 1
a5728 1
	g_App.g_pPrefs->Add2LostFromCorruption(dwBadBytes);
@


1.626
log
@Formatting.
@
text
@d96 1
a96 1
		g_eMuleApp.m_pDownloadQueue->SetAutoCat(this);
d162 1
a162 1
		if (!g_eMuleApp.m_pDownloadQueue->FileExists(m_fileHash))
d166 1
a166 1
				g_eMuleApp.m_pDownloadQueue->SetAutoCat(this);
d249 1
a249 1
	if (g_eMuleApp.m_pGlobPrefs->IsDAPEnabled())
d301 1
a301 1
	m_strTempDir = g_eMuleApp.m_pGlobPrefs->GetTempDir();
d368 1
a368 1
	if (g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
d385 1
a385 1
	if (g_eMuleApp.m_pGlobPrefs->GetAutoFilenameCleanup())
d421 1
a421 1
			g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d432 1
a432 1
			g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d461 1
a461 1
						g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d645 1
a645 1
		g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d803 1
a803 1
		CHashFileThread* addfilethread = (CHashFileThread*) AfxBeginThread(RUNTIME_CLASS(CHashFileThread), THREAD_PRIORITY_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
d1178 1
a1178 1
	g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(this);
d1789 1
a1789 1
		g_eMuleApp.m_pDownloadQueue->RemoveSource(*cIt++);
d1804 1
a1804 1
				g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
d1837 1
a1837 1
		|| (m_nTotalBufferData > (static_cast<uint32>(g_eMuleApp.m_pGlobPrefs->GetFileBufferSize()) * 30000))
d1875 1
a1875 1
	if ((g_eMuleApp.m_pServerConnect == NULL) || !g_eMuleApp.m_pServerConnect->IsConnected())
d1910 1
a1910 1
			&& !g_eMuleApp.m_pListenSocket->TooManySockets())
d1912 2
a1913 2
			uint32	dwLocalServerIP = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_eMuleApp.m_pServerConnect->IsLowID();
d1919 1
a1919 1
				if (g_eMuleApp.m_pListenSocket->TooManySockets())
d1943 1
a1943 1
			if (!g_eMuleApp.m_pListenSocket->TooManySockets())
d1945 2
a1946 2
				uint32	dwLocalServerIP = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP();
				bool	bIsLowId = g_eMuleApp.m_pServerConnect->IsLowID();
d1954 1
a1954 1
					if (g_eMuleApp.m_pListenSocket->TooManySockets())
d1996 2
a1997 2
			uint32	dwLocalServerIP = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_eMuleApp.m_pServerConnect->IsLowID();
d2007 1
a2007 1
					g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
d2034 1
a2034 1
			&& !g_eMuleApp.m_pListenSocket->TooManySockets())
d2040 1
a2040 1
				if (g_eMuleApp.m_pListenSocket->TooManySockets())
d2053 2
a2054 2
			uint32	dwLocalServerIP = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_eMuleApp.m_pServerConnect->IsLowID();
d2064 1
a2064 1
					g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
d2098 1
a2098 1
				if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == NULL)
d2101 1
a2101 1
				else if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() != this)
d2106 1
a2106 1
						pSource->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
d2110 1
a2110 1
						bIsNNS = pSource->m_otherNoNeededMap.Lookup(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile(), dwLastNoNeededCheckTime);
d2113 1
a2113 1
							pSource->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
d2122 1
a2122 1
		if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == this && !m_A4AFsrcList.IsEmpty())
d2153 1
a2153 1
			&& g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > uSourceNumber )
d2157 1
a2157 1
			g_eMuleApp.m_pDownloadQueue->SetRequiredSourcesRefresh(this);
d2162 1
a2162 1
		if (g_eMuleApp.m_pGlobPrefs->SLSEnable() && m_SourceLists[DS_DOWNLOADING].empty() && g_eMuleApp.m_pServerConnect->IsConnected())
d2164 1
a2164 1
			m_sourcesaver.Process(this, g_eMuleApp.m_pGlobPrefs->SLSMaxSourcesPerFile());
d2220 1
a2220 1
	if ( iSourceCountPlusNew > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
d2223 1
a2223 1
		RemoveNoNeededSources(iSourceCountPlusNew - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
d2237 1
a2237 1
		if (g_eMuleApp.m_pServerConnect->GetClientID() < 0x1000000 && g_eMuleApp.m_pServerConnect->IsConnected())
d2239 3
a2241 3
			if ( g_eMuleApp.m_pServerConnect->GetClientID() == dwUserID &&
				 g_eMuleApp.m_pGlobPrefs->GetPort() == iUserPort &&
				 inet_addr(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetFullIP()) == iServerIP )
d2246 2
a2247 2
		else if ( g_eMuleApp.m_pServerConnect->GetClientID() == dwUserID &&
				  g_eMuleApp.m_pGlobPrefs->GetPort() == iUserPort )
d2252 1
a2252 1
				  !g_eMuleApp.m_pServerConnect->IsLocalServer(iServerIP, iServerPort) )
d2259 1
a2259 1
		if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > GetSourceCount())
d2262 1
a2262 1
			CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this, dwUserID, iUserPort, iServerIP, iServerPort, NULL);
d2689 1
a2689 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d2703 1
a2703 1
		                THREAD_PRIORITY_BELOW_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(),
d2712 1
a2712 1
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC)CompleteThreadProc, this, THREAD_PRIORITY_BELOW_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(), 0, 0);
d2721 1
a2721 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d2787 1
a2787 1
		strFakesFile.Format(_T("%s\\fakes.rar"), g_eMuleApp.m_pGlobPrefs->GetIncomingDir());
d2793 1
a2793 1
		g_eMuleApp.m_pGlobPrefs->SharedDirListCopy(&strSharedDirsList);
d2810 1
a2810 1
	newname.Format(_T("%s\\%s"), strOutputDir, g_eMuleApp.StripInvalidFilenameChars(GetFileName()));
d2852 1
a2852 1
			int		iBlockSize = g_eMuleApp.m_pGlobPrefs->SlowCompleteBlockSize() * 1024;
d2857 1
a2857 1
			CSingleLock Lock(&g_eMuleApp.m_csPreventExtensiveHDAccess, TRUE);
d2927 2
a2928 2
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnImportantError(), g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnImportantError());
d2982 2
a2983 2
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnImportantError(), g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnImportantError());
d3044 1
a3044 1
	if (IsULAutoPrioritized() && !g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
d3060 2
a3061 2
	g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetUseDownloadNotifier(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
	g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_DLOAD, false, g_eMuleApp.m_pGlobPrefs->GetUseDownloadNotifier());
d3064 2
a3065 2
	g_eMuleApp.m_pKnownFilesList->SafeAddKnownFile(this);
	g_eMuleApp.m_pDownloadQueue->RemoveFile(this);
d3069 1
a3069 1
	g_eMuleApp.m_pMMServer->AddFinishedFile(this);
d3073 1
a3073 1
	if (g_eMuleApp.m_pGlobPrefs->DownloadPausedOnComplete() && !IsFakesDotRar())
d3075 1
a3075 1
		g_eMuleApp.m_pDownloadQueue->StartNextFile(eCatID);
d3078 3
a3080 3
	g_eMuleApp.m_pGlobPrefs->Add2DownCompletedFiles();			// Increments cumDownCompletedFiles in prefs struct
	g_eMuleApp.m_pGlobPrefs->Add2DownSessionCompletedFiles(); 	// Increments sesDownCompletedFiles in prefs struct
	g_eMuleApp.m_pGlobPrefs->SaveCompletedDownloadsStat();		// Saves cumDownCompletedFiles to INI
d3083 1
a3083 1
	g_eMuleApp.m_pSharedFilesList->RepublishFile(this);
d3085 1
a3085 1
	if (GetPath() != g_eMuleApp.m_pGlobPrefs->GetIncomingDir())
d3087 1
a3087 1
		if (g_eMuleApp.m_pGlobPrefs->SharedDirListCheckAndAdd(GetPath(), true))
d3090 1
a3090 1
			g_eMuleApp.m_pSharedFilesList->Reload();
d3094 1
a3094 1
	if (g_eMuleApp.m_pGlobPrefs->IsAutoClearCompleted())
d3096 3
a3098 3
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.SetRedraw(false);
		g_eMuleApp.m_pDownloadList->ClearCompleted(CAT_ALL);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.SetRedraw(true);
d3101 1
a3101 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d3104 2
a3105 2
	if (g_eMuleApp.m_pGlobPrefs->IsAVEnabled() &&
		g_eMuleApp.m_pGlobPrefs->IsAVScanCompleted() && !g_eMuleApp.m_pGlobPrefs->GetAVPath().IsEmpty())
d3107 2
a3108 2
		strTempFullName.Format(_T("%s \"%s\""), g_eMuleApp.m_pGlobPrefs->GetAVParams(), m_strFilePath);
		ShellExecute(NULL, _T("open"), g_eMuleApp.m_pGlobPrefs->GetAVPath(), strTempFullName, NULL, SW_SHOW);
d3114 2
a3115 2
		CFakeCheck	*pFakeCheck = g_eMuleApp.m_pFakeCheck;
		CString		strFakesDotDatPath = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + _T("fakes.dat");
d3123 1
a3123 1
		if (pFakeCheck->ExtractRARArchive(m_strFilePath, g_eMuleApp.m_pGlobPrefs->GetConfigDir()))
d3125 4
a3128 4
			g_eMuleApp.AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_FAKE_SUCCESS_UPDATE), g_eMuleApp.m_pGlobPrefs->GetFakesDatVersion(), g_eMuleApp.m_pGlobPrefs->GetDLingFakeListVersion());
			g_eMuleApp.m_pGlobPrefs->SetFakesDatVersion(g_eMuleApp.m_pGlobPrefs->GetDLingFakeListVersion());
			g_eMuleApp.m_pGlobPrefs->SetDLingFakeListVersion(0);
			g_eMuleApp.m_pGlobPrefs->SetDLingFakeListLink(_T(""));
d3139 1
a3139 1
		CKnownFile	*pThisFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(GetFileHash());
d3145 1
a3145 1
			g_eMuleApp.m_pSharedFilesList->Reload();
d3179 1
a3179 1
				g_eMuleApp.m_pDownloadQueue->RemoveSource(pRemoveSource);
d3184 1
a3184 1
				g_eMuleApp.m_pDownloadList->RemoveSource(pRemoveSource, this);
d3190 1
a3190 1
			g_eMuleApp.m_pDownloadQueue->RemoveSource(pRemoveSource);
d3200 1
a3200 1
			g_eMuleApp.m_pDownloadList->RemoveSource(pRemoveSource, this);
d3262 3
a3264 3
	g_eMuleApp.m_pSharedFilesList->RemoveFile(this);
	g_eMuleApp.m_pDownloadQueue->RemoveFile(this);
	g_eMuleApp.m_pDownloadList->RemoveFile(this);
d3336 1
a3336 1
	g_eMuleApp.m_pDownloadQueue->SortByPriority();
d3374 1
a3374 1
	if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == this)
d3376 1
a3376 1
		g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(NULL);
d3408 1
a3408 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d3427 1
a3427 1
	if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == this)
d3429 1
a3429 1
		g_eMuleApp.m_pDownloadQueue->SetA4AFAutoFile(NULL);
d3502 1
a3502 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d3716 1
a3716 1
	if (g_eMuleApp.m_pGlobPrefs->BackupPreview())
d3719 2
a3720 2
		CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
		pThread->SetValues(this, g_eMuleApp.m_pGlobPrefs->GetVideoPlayer());
d3726 1
a3726 1
		CString strPlayer = g_eMuleApp.m_pGlobPrefs->GetVideoPlayer();
d3783 1
a3783 1
	if (g_eMuleApp.m_pGlobPrefs->BackupPreview())
d3794 1
a3794 1
		_tsplitpath(g_eMuleApp.m_pGlobPrefs->GetVideoPlayer(), NULL, NULL, szVideoPlayerFileName, NULL);
d3798 1
a3798 1
		if (g_eMuleApp.m_pGlobPrefs->GetPreviewSmallBlocks() || !_tcsicmp(szVideoPlayerFileName, _T("vlc")))
d4029 1
a4029 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(_T("Received invalid source exchange packet (v%u) of data size %u for %s"), byteSourceExchangeVersion, uDataSize, GetFileName());
d4060 1
a4060 1
		if (iValidSources < g_eMuleApp.m_pGlobPrefs->PriorityHigh() && priority != PR_HIGH)
d4062 1
a4062 1
		else if (iValidSources >= g_eMuleApp.m_pGlobPrefs->PriorityHigh() && iValidSources < g_eMuleApp.m_pGlobPrefs->PriorityLow() && priority != PR_NORMAL)
d4064 1
a4064 1
		else if (iValidSources >= g_eMuleApp.m_pGlobPrefs->PriorityLow() && priority != PR_LOW)
d4182 2
a4183 2
	if (g_eMuleApp.m_pGlobPrefs->IsNTBased())
		SetThreadLocale(g_eMuleApp.m_pGlobPrefs->GetLanguageID());
d4297 1
a4297 1
		g_eMuleApp.m_pGlobPrefs->Add2SavedFromCompression(iCompressionGain);
d4486 1
a4486 1
						g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(this);
d4514 1
a4514 1
					g_eMuleApp.m_pGlobPrefs->SubLostFromCorruption(dwSaved);
d4521 1
a4521 1
						g_eMuleApp.m_pSharedFilesList->SafeAddKnownFile(this);
d4525 1
a4525 1
					g_eMuleApp.m_pGlobPrefs->Add2SessionPartsSavedByICH();
d4553 1
a4553 1
		if (g_eMuleApp.m_pGlobPrefs->IsErrorBeepEnabled())
d4569 2
a4570 2
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnImportantError(), g_eMuleApp.m_pGlobPrefs->IsSMTPWarningEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopOnImportantError());
d4801 1
a4801 1
	g_eMuleApp.m_pDownloadList->UpdateFile(this);
d4814 1
a4814 1
	if (g_eMuleApp.m_pServerConnect->GetClientID() < 0x1000000 && g_eMuleApp.m_pServerConnect->IsConnected())
d4816 2
a4817 2
		if ( g_eMuleApp.m_pServerConnect->GetClientID() == pSource->sourceID &&
			 g_eMuleApp.m_pGlobPrefs->GetPort() == pSource->sourcePort )
d4824 2
a4825 2
		if ( g_eMuleApp.m_pServerConnect->GetLocalIP() == pSource->sourceID &&
			 g_eMuleApp.m_pGlobPrefs->GetPort() == pSource->sourcePort )
d4830 2
a4831 2
	else if ( g_eMuleApp.m_pServerConnect->GetClientID() == pSource->sourceID &&
			  g_eMuleApp.m_pGlobPrefs->GetPort() == pSource->sourcePort )
d4837 1
a4837 1
			  !g_eMuleApp.m_pServerConnect->IsLocalServer(pSource->serverIP, pSource->serverPort) )
d4844 2
a4845 2
	if ( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > GetSourceCount()
	     && iSource < static_cast<int>(g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft()) )
d4847 1
a4847 1
		CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this,pSource->sourceID,pSource->sourcePort, pSource->serverIP, pSource->serverPort, pSource->achUserHash);
d4886 1
a4886 1
	g_eMuleApp.m_pDownloadQueue->AddClientHostnameToResolve(sources);
d4937 1
a4937 1
	dwID = g_eMuleApp.m_pServerConnect->GetClientID();
d4942 1
a4942 1
			g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),  // Spaces to dots
d4952 1
a4952 1
		else if (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID())
d4972 1
a4972 1
		strLink.AppendFormat(_T(",%u.%u.%u.%u:%u"), (byte)dwID, (byte)(dwID >> 8), (byte)(dwID >> 16), (byte)(dwID >> 24), g_eMuleApp.m_pGlobPrefs->GetPort());
d5010 1
a5010 1
	CString	strRetPath = g_eMuleApp.m_pGlobPrefs->GetIncomingDir();
d5085 1
a5085 1
				if (g_eMuleApp.m_pGlobPrefs->SharedDirListCheckAndAdd(strDir, true))
d5088 1
a5088 1
					g_eMuleApp.m_pSharedFilesList->Reload();
d5475 1
a5475 1
	EnumCategories	eCurCat = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.GetCurTabCat();
d5479 1
a5479 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.ChangeCategoryByID(eCurCat);
d5484 1
a5484 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d5728 1
a5728 1
	g_eMuleApp.m_pGlobPrefs->Add2LostFromCorruption(dwBadBytes);
@


1.625
log
@fixed output of HighQR & QueueFull Sources; removed the comment from SendReask(); fixed function GetValidSources()
@
text
@d1700 1
a1700 1
	uint32 dwListsMask = SLM_VALID_SOURCES;
d1939 1
a1939 1
	else if (dwIteration == 3)
a1940 1
	// process the sources on the queue
d1947 2
a1948 2
				uint16 uSrcQueueFull = 0;
				uint16 uSrcHighQR = 0;
@


1.624
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d1700 1
d1703 1
a1703 1
	for (EnumDLQState eDS = DS_DOWNLOADING; eDS < DS_LAST_QUEUED_STATE; ++eDS)
d1705 1
a1705 1
		if ((eDS != DS_ONQUEUE) && (eDS != DS_NONEEDEDPARTS) && (eDS != DS_DOWNLOADING))
d1939 1
a1939 1
	else if (dwIteration == 3)	// process the sources on the queue
d1941 2
a1942 5
		uint16	uSrcQueueFull = 0;
		uint16	uSrcHighQR = 0;

		if (!m_SourceLists[DS_ONQUEUE].empty()
			&& !g_eMuleApp.m_pListenSocket->TooManySockets())
d1944 6
a1949 2
			uint32	dwLocalServerIP = g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP();
			bool	bIsLowId = g_eMuleApp.m_pServerConnect->IsLowID();
d1951 2
a1952 5
			GetCopySourceList(DS_ONQUEUE, &sourceListCopy);
			for (ClientList::const_iterator cIt = sourceListCopy.begin(); cIt != sourceListCopy.end(); cIt++)
			{
			//	Process waiting sources unless it is allowed to open a new connection
				if (g_eMuleApp.m_pListenSocket->TooManySockets())
d1954 17
a1970 3
					uSrcQueueFull = 0xFFFF;
					break;
				}
d1972 4
a1975 1
				pSource = *cIt;
d1977 4
a1980 1
				if (pSource->HasLowID())
d1982 2
a1983 5
					if (bIsLowId)
						pSource->SetDownloadState(DS_LOWTOLOWIP);
					else if (pSource->GetServerIP() != dwLocalServerIP)
						pSource->SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
					continue;
a1984 8

				if (pSource->IsRemoteQueueFull())
					uSrcQueueFull++;
				else if (pSource->GetRemoteQueueRank() > QUEUERANK_HIGH)
					uSrcHighQR++;

				if (dwCurTick > pSource->GetNextFileReaskTime())
					pSource->SendReask();
d1986 1
d1988 1
a1988 2
		m_iSrcOnQueue = m_SourceLists[DS_ONQUEUE].size();
		if (uSrcQueueFull != 0xFFFF)
d1990 1
a1990 2
			m_iSrcQueueFull = uSrcQueueFull;
			m_uSrcHighQR = uSrcHighQR;
@


1.623
log
@Unicode corrections.
@
text
@d203 1
a203 1
	m_iSrcHighQR = 0;
a206 1
	m_iSrcTimeout = 0;
a207 2
	m_iSrcUnknown = 0;
	m_iSrcRecHash = 0;
a260 1
	InvalidateRemoteQueueRankingStats();
a1700 1
	POSITION pos;
d1702 6
a1707 9
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
		if (!m_srcLists[sl].IsEmpty())
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
			{
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
				if ( pSource->GetDownloadState() != DS_ONQUEUE && pSource->GetDownloadState() != DS_DOWNLOADING &&
				     pSource->GetDownloadState() != DS_NONEEDEDPARTS )
					dwCounter++;
			}
d1723 6
a1728 9
	POSITION pos;
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
		if (!m_srcLists[sl].IsEmpty())
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
			{
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
				if (pSource->GetDownloadState() != DS_ONQUEUE && pSource->GetDownloadState() != DS_DOWNLOADING)
					dwCounter++;
			}
d1821 1
d1826 1
a1826 4
	bool			bSocketsUsageIsHigh = false;
	bool			bReaskDownload;
	POSITION		pos1, pos2;
	ClientList		sourceListCopy;
d1846 27
a1872 3
#ifdef OLD_SOCKETS_ENABLED
	bSocketsUsageIsHigh = g_eMuleApp.m_pListenSocket->GetNumOpenSockets() > (g_eMuleApp.m_pGlobPrefs->GetMaxConnections() * 0.75);
#endif //OLD_SOCKETS_ENABLED
d1874 2
a1875 1
	uint32	dwNumTransferringSrcs = 0;
d1877 2
a1878 3
//	Always process the transferring sources
//	Note: in case of disconnection sources will be put back to queue after download timeout
	if (!m_downloadingSourceList.IsEmpty())
d1880 6
a1885 3
		EnterCriticalSection(&m_csSourceLists);
		POSITION posHeadList = m_downloadingSourceList.GetHeadPosition();
		LeaveCriticalSection(&m_csSourceLists);
d1887 23
a1909 1
		for (pos1 = posHeadList; (pos2 = pos1) != NULL;)
d1911 5
a1915 4
			EnterCriticalSection(&m_csSourceLists);
			pSource = m_downloadingSourceList.GetNext(pos1);
			LeaveCriticalSection(&m_csSourceLists);
			if (pSource)
d1917 7
a1923 2
			//	If new client has non DL state, then remove him
				if (pSource->GetDownloadState() != DS_DOWNLOADING)
d1925 4
a1928 4
					AddDebugLogLine(_T(__FUNCTION__) _T(": corruption of m_downloadingSourceList"));
					EnterCriticalSection(&m_csSourceLists);
					m_downloadingSourceList.RemoveAt(pos2);
					LeaveCriticalSection(&m_csSourceLists);
a1930 1
				dwCurrentDataRate = pSource->DownloadProcess(dwReduceDownload);
d1932 2
a1933 5
			//	Since client can be dropped due timeout we need to check the state again
				if (pSource->GetDownloadState() != DS_DOWNLOADING)
					continue;
				dwNumTransferringSrcs++;
				dwDataRate += dwCurrentDataRate;
d1936 1
d1938 1
a1938 4
	m_iNumTransferringSrcs = dwNumTransferringSrcs;
	m_dwDataRate = dwDataRate;

	if (dwIteration == 10)
d1940 2
a1941 15
	//	Initialize temp variables only if we need it
		bool	bAlreadyCounted = false;
		uint16	uNNPSrcCount = 0;
		uint16	uOnQueueSrcCount = 0;
		uint16	uHighQRSrcCount = 0;
		uint16	uConnectingSrcCount = 0;
		uint16	uTooManyConnsSrcCount = 0;
		uint16	uConnectedSrcCount = 0;
		uint16	uTimeoutSrcCount = 0;
		uint16	uConnViaServerSrcCount = 0;
		uint16	uUnknownSrcCount = 0;
		uint16	uReqHashSrcCount = 0;
		uint16	uLowToLowIDSrcCount = 0;
		uint16	uQueueFullSrcCount = 0;
		uint16	uHighestQR = 0;
d1943 5
a1947 3
	//	Cache number of sources
		uint16	uSourceNumber = GetSourceCount();
		uint16	uMaxSources = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile();
d1949 2
a1950 27
	//	In case of timeout all sources are dropped every round without restrictions.
	//	Preferred droppingorder by state is: Low2Low, NNP, QueueFull, HighQR.
	//	Set the maximal number of sources to drop this round dynamicly by demand.
		uint16	uDropLimit = 0;
		if ((m_dwLastPurgeTime + PURGE_TIME) < dwCurTick)
		{
		//	Drop more sources if slots are >105% overcrowded
			if (uSourceNumber > uMaxSources * 1.05)
				uDropLimit = 10;
		//	Drop few sources if >95% slots full
			else if (uSourceNumber > uMaxSources * 0.95)
				uDropLimit = 3;
		//	Drop only one source if >85% slots full
			else if (uSourceNumber > uMaxSources * 0.85)
				uDropLimit = 1;
		}

	//	Count how many sources are dropped
		uint16	uDroppedTotal = 0;
		uint16	uDroppedLowToLowID = 0;
		uint16	uDroppedNNP = 0;
		uint16	uDroppedQueueFull = 0;
		uint16	uDroppedHighQR = 0;

		for (uint32 dwSlotIndex = 0; dwSlotIndex < SOURCESSLOTS; dwSlotIndex++)
		{
			if (!m_srcLists[dwSlotIndex].IsEmpty())
d1952 2
a1953 1
				for (pos1 = m_srcLists[dwSlotIndex].GetHeadPosition();pos1 != NULL;)
d1955 3
a1957 1
					pSource = m_srcLists[dwSlotIndex].GetNext(pos1);
d1959 1
a1959 2
					if (pSource == NULL)
						continue;
d1961 8
a1968 3
					bAlreadyCounted = false;
					bReaskDownload = false;
					uint32	dwFileReaskTime = FILEREASKTIME;
d1970 4
a1973 4
					switch (pSource->GetDownloadState())
					{
						case DS_DOWNLOADING:
							break;
d1975 17
a1991 28
						case DS_ERROR:
						{
							if (!bAlreadyCounted)
							{
								bAlreadyCounted = true;
							}
						//	Formerly this was executed only if the source was not already counted (inside if-clause above).
							pSource->Disconnected();
							break;
						}
						case DS_CONNECTED:
						{
#ifdef OLD_SOCKETS_ENABLED
						//	If the request socket doesn't exist or isn't connected
							if (!(pSource->m_pRequestSocket && pSource->m_pRequestSocket->IsConnected()))
							{
							//	It was DS_NONE before but that keeps for some time problematic clients.
							//	There is no need to do that as there will be no change (from our experience).
								pSource->SetDownloadState(DS_ERROR);

								if (!bAlreadyCounted)
								{
									uUnknownSrcCount++;
									bAlreadyCounted = true;
								}
								break;
							}
#endif //OLD_SOCKETS_ENABLED
d1993 4
a1996 65
							if (dwCurTick - pSource->GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000)
							{
								if (!bAlreadyCounted)
								{
								//	Actually this is a bit wrong because ALL timed out sources are dropped so there are none left afterwards.
								//	Logical this counter represents the number of sources which had timed out since the last processing.
									uTimeoutSrcCount++;
									bAlreadyCounted = true;
								}
								g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
								uSourceNumber--;
								break;
							}
							if (!bAlreadyCounted)
							{
								uConnectedSrcCount++;
								bAlreadyCounted = true;
							}
							bReaskDownload = true;
							break;
						}
						case DS_LOWTOLOWIP:
						{
							if (uDroppedTotal < uDropLimit)
							//	Prefere to drop these Low2Low before all other
							{
								g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
								uSourceNumber--;
								uDroppedTotal++;
								uDroppedLowToLowID++;
								break;
							}
							if (!bAlreadyCounted)
							{
								uLowToLowIDSrcCount++;
								bAlreadyCounted = true;
							}
#ifdef OLD_SOCKETS_ENABLED
					 	//	If we now have a high ip we can ask
							if (g_eMuleApp.m_pServerConnect->IsLowID())
							{
								break;
							}
#endif //OLD_SOCKETS_ENABLED
						}
						case DS_NONEEDEDPARTS:
						{
							if (uDroppedTotal < uDropLimit
							//	Prefere to drop Low2Low before NNP
								&& m_uSrcLowToLow == uDroppedLowToLowID )
							{
								if (!pSource->SwapToAnotherFile(NULL))
								{
									g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
									uSourceNumber--;
									uDroppedTotal++;
									uDroppedNNP++;
									break;
								}
							}
							if (!bAlreadyCounted)
							{
								uNNPSrcCount++;
								bAlreadyCounted = true;
							}
d1998 6
a2003 4
						//	Doubled reasktime for no needed parts - save connections and traffic
						//	NNP sources will be checked filereasktime*4 when 3/4 of max. sockets are open
							if (bSocketsUsageIsHigh)
								dwFileReaskTime = FILEREASKTIME * 2;
d2005 5
a2009 6
							if (!((!pSource->GetLastAskedTime()) || (dwCurTick - pSource->GetLastAskedTime()) > dwFileReaskTime * 2))
								break;
						}
						case DS_ONQUEUE:
						{
							uint16	uQueueRank = pSource->GetRemoteQueueRank();
d2011 25
a2035 51
						// the remote queue is still full & we waited at least 3*FILEREASKTIME to enter into the queue
							if (pSource->IsRemoteQueueFull() && pSource->GetAskedCountDown() > 3)
							{
								if (uDroppedTotal < uDropLimit
								//	Prefere to drop Low2Low and NNP before QueueFull
									&& m_uSrcLowToLow == uDroppedLowToLowID
									&& m_iSrcNNP == uDroppedNNP )
								{
									g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
									uSourceNumber--;
									uDroppedTotal++;
									uDroppedQueueFull++;
									break;
								}
								if (!bAlreadyCounted)
								{
									uQueueFullSrcCount++;
									bAlreadyCounted = true;
								}
							}
							else
							{
							//	Check remote queue position (HighQR)
								if (uQueueRank > QUEUERANK_HIGH)
								{
									if (uDroppedTotal < uDropLimit
										&& g_eMuleApp.m_pGlobPrefs->GetDropHighestQREnabled()
									//	Prefere to drop Low2Low and NNP before HighQR
										&& m_uSrcLowToLow == uDroppedLowToLowID
										&& m_iSrcNNP == uDroppedNNP
									//	Drop if the source has worst QR
										&& uQueueRank == m_uHighestRemoteQueueRank )
									{
										g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
										uSourceNumber--;
										uDroppedTotal++;
										uDroppedHighQR++;
										break;
									}
									if (!bAlreadyCounted)
									{
										uHighQRSrcCount++;
										bAlreadyCounted = true;
									}
								}
								else if (!bAlreadyCounted)
								{
									uOnQueueSrcCount++;
									bAlreadyCounted = true;
								}
							}
d2037 12
a2048 14
							if (uQueueRank != 0)
							{
							//	Adjust reasktime when many connections used: QR<250 = 43:20 min, QR>250 = 54:10 min
								if (bSocketsUsageIsHigh)
								{
									if (uQueueRank > QUEUERANK_LOW)
										dwFileReaskTime = FILEREASKTIME * 2.5;
									else
										dwFileReaskTime = FILEREASKTIME * 2;
								}
							//	Findout best and worst QR
								if (uQueueRank > uHighestQR)
									uHighestQR = uQueueRank;
							}
d2050 4
a2053 20
						//	LANCAST (moosetea) - We reask much faster if lancast user, UDP happens in 10 seconds
							if (pSource->IsOnLAN())
							{
								if ( (!pSource->GetLastAskedTime())
								     || (dwCurTick - pSource->GetLastAskedTime()) > LANCASTFILEREASKTIMEUDP )
								{
									pSource->UDPReaskForDownload();
								}
							}
							else
							{
#ifdef OLD_SOCKETS_ENABLED
								if ( g_eMuleApp.m_pServerConnect->IsConnected()
								     && ( (!pSource->GetLastAskedTime())
								          || (dwCurTick - pSource->GetLastAskedTime()) > dwFileReaskTime - 20000 ) )
								{
									pSource->UDPReaskForDownload();
								}
#endif
							}
d2055 6
a2060 63
#ifdef OLD_SOCKETS_ENABLED
						//	Emulates a "Connecting via server..." without request socket timeout
							if ( g_eMuleApp.m_pServerConnect->IsConnected()
							     && (pSource->GetLastAskedTime())
							     && ((dwCurTick - pSource->GetLastAskedTime()) > (FILEREASKTIME - L2HAC_PREPARE_PRECEDE))
							     && pSource->HasLowID()
							     && pSource->GetL2HACTime()
							     && !g_eMuleApp.m_pServerConnect->IsLowID() )
							{
								pSource->SetDownloadState(DS_WAITCALLBACK);
							}
#endif
						}
						case DS_CONNECTING:
						{
							if (!bAlreadyCounted)
							{
								uConnectingSrcCount++;
								bAlreadyCounted = true;
							}
						}
						case DS_TOOMANYCONNS:
						{
							if (!bAlreadyCounted)
							{
								uTooManyConnsSrcCount++;
								bAlreadyCounted = true;
							}
						}
						case DS_NONE:
						{
							if (!bAlreadyCounted)
							{
								bAlreadyCounted = true;
							}
						}
						case DS_WAITCALLBACK:
						{
							if (!bAlreadyCounted)
							{
								uConnViaServerSrcCount++;
								bAlreadyCounted = true;
							}
							bReaskDownload = true;
							break;
						}
						case DS_REQHASHSET:
						{
							uReqHashSrcCount++;
							break;
						}
						default:
						{
							uUnknownSrcCount++;
						}
					}
#ifdef OLD_SOCKETS_ENABLED
					if (bReaskDownload && g_eMuleApp.m_pServerConnect->IsConnected())
					{
					//	LANCAST (moosetea) - Because reask much faster if lancast user ie we may reask as soon as we get disconnected,
					//	we only use TCP on a LAN, because emule may try to send a TCP request and UDP request at the same time!
						if (pSource->IsOnLAN())
							dwFileReaskTime = LANCASTFILEREASKTIMETCP;
d2062 9
a2070 5
						if (!pSource->GetLastAskedTime() || (dwCurTick - pSource->GetLastAskedTime()) > dwFileReaskTime)
							pSource->AskForDownload();
					}
#endif
					pSource = NULL;
d2074 5
a2078 34
	//	Check if at least 1 source has been dropped this time
		if (uDroppedTotal != 0)
		{
		//	Need to ensure that next dropping is properly delayed in every case.
			m_dwLastPurgeTime = dwCurTick;
/*
		//	Producing many lines - so uncomment it only if u want to look into details
			AddDebugLogLine( RGB_LOG_DIMMED + _T("Dropped %u/%u sources from file '%s': %u/%u L2L, %u/%u NNP, %u/%u QF, %u/%u HQR(%u) [QR < %u]")
				, uDroppedTotal, (uSourceNumber + uDroppedTotal), GetFileName()
				, uDroppedLowToLowID, (uLowToLowIDSrcCount + uDroppedLowToLowID)
				, uDroppedNNP, (uNNPSrcCount + uDroppedNNP)
				, uDroppedQueueFull, (uQueueFullSrcCount + uDroppedQueueFull)
				, uDroppedHighQR, (uHighQRSrcCount + uDroppedHighQR)
				, m_uHighestRemoteQueueRank, uHighestQR );
*/
		}

	//	Set the members using temp vars.  We have to use temporary vars so that the disp counts don't get
	//	screwed up during processing.  We don't need to count this, cause we can get a transferring
	//	sources over m_downloadingSourceList.GetCount()
		m_iSrcNNP = uNNPSrcCount;
		m_iSrcOnQueue = uOnQueueSrcCount;
		m_iSrcHighQR = uHighQRSrcCount;
		m_iSrcConnecting = uConnectingSrcCount;
		m_uSrcWaitForFileReq = uTooManyConnsSrcCount;
		m_iSrcConnected = uConnectedSrcCount;
		m_iSrcTimeout = uTimeoutSrcCount;
		m_iSrcConnViaServer = uConnViaServerSrcCount;
		m_iSrcUnknown = uUnknownSrcCount;
		m_iSrcRecHash = uReqHashSrcCount;
		m_uSrcLowToLow = uLowToLowIDSrcCount;
		m_uSrcLowIDOnOtherServer = 0;
		m_iSrcQueueFull = uQueueFullSrcCount;
		m_uHighestRemoteQueueRank = uHighestQR;
d2115 1
a2115 1
	//	then check A4AF list and swap source to "this", if souce isn't NNS
d2122 2
a2123 1
				if (pSource != NULL)
d2156 1
a2156 1
		if (g_eMuleApp.m_pGlobPrefs->SLSEnable() && m_downloadingSourceList.IsEmpty() && g_eMuleApp.m_pServerConnect->IsConnected())
d2274 4
a3344 1
	{
d3346 2
a3347 1
	}
d3350 1
a3350 1
//	unpredictable behaviour	during the source remove
d3356 4
a3359 5
	CUpDownClient* pSource;

	EnterCriticalSection(&m_csSourceLists);
	POSITION posHeadList = m_downloadingSourceList.GetHeadPosition();
	LeaveCriticalSection(&m_csSourceLists);
a3360 5
	for (POSITION pos = posHeadList; pos != NULL;)
	{
		EnterCriticalSection(&m_csSourceLists);
		pSource = m_downloadingSourceList.GetNext(pos);
		LeaveCriticalSection(&m_csSourceLists);
d3362 2
a3363 5
		if (pSource != NULL)
		{
			pSource->SendCancelTransfer();
			pSource->SetDownloadState(DS_ONQUEUE);
		}
d3379 1
a3379 1
	m_iSrcHighQR = 0;
a3382 1
	m_iSrcTimeout = 0;
a3383 2
	m_iSrcUnknown = 0;
	m_iSrcRecHash = 0;
a3388 1
	InvalidateRemoteQueueRankingStats();
d3414 1
a3414 1
	if (m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING)
a3418 1
	POSITION pos;
d3427 2
a3428 5
	EnterCriticalSection(&m_csSourceLists);
	POSITION posHeadList = m_downloadingSourceList.GetHeadPosition();
	LeaveCriticalSection(&m_csSourceLists);

	for (pos = posHeadList; pos != NULL;)
d3430 3
a3432 9
		EnterCriticalSection(&m_csSourceLists);
		pSource = m_downloadingSourceList.GetNext(pos);
		LeaveCriticalSection(&m_csSourceLists);

		if (pSource != NULL)
		{
			pSource->SendCancelTransfer();
			pSource->SetDownloadState(DS_ONQUEUE);
		}
a3924 11
	//	Don't send incomplete established connections. to avoid sending no valid sources
		switch (pPotentialSource->GetDownloadState())
		{
			case DS_NONE:
			case DS_CONNECTING:
			case DS_ERROR:
			case DS_TOOMANYCONNS:
			continue;
			break;
		}

d4712 3
a4714 3
	for (int i = 0; i < SOURCESSLOTS; i++)
		dwCount += m_srcLists[i].GetCount();
	return dwCount;
a5313 37
// 1. CS method to prevent a problem by removing(adding) in the list
// 2. since the CS allows us to add clients safely, it's better to add the client to the head
// this will speed up first respose to DL invitation
void CPartFile::AddDownloadingSource(CUpDownClient* client)
{
	EMULE_TRY

	EnterCriticalSection(&m_csSourceLists);

	POSITION pos = m_downloadingSourceList.Find(client);

	if (pos == NULL)
	{
		m_downloadingSourceList.AddHead(client);
	}
	LeaveCriticalSection(&m_csSourceLists);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemoveDownloadingSource(CUpDownClient* client)
{
	EMULE_TRY

	EnterCriticalSection(&m_csSourceLists);

	POSITION pos = m_downloadingSourceList.Find(client);

	if (pos != NULL)
	{
		m_downloadingSourceList.RemoveAt(pos);
	}
	LeaveCriticalSection(&m_csSourceLists);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d5725 1
a5725 1
void CPartFile::GetCopySourceList(uint32 dwDS, ClientList *pCopy)
a5726 2
	POSITION			pos;

d5730 1
a5730 1
	for (int sl = 0; sl < SOURCESSLOTS; sl++)
d5732 3
a5734 5
		if (!m_srcLists[sl].IsEmpty())
		{
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL;)
			{
				CUpDownClient	*pClient = m_srcLists[sl].GetNext(pos);
d5736 1
a5736 4
				if (pClient->GetDownloadState() == dwDS)
					pCopy->push_back(pClient);
			}
		}
a5741 2
	POSITION			pos;

d5745 2
a5746 1
	for (int sl = 0; sl < SOURCESSLOTS; sl++)
d5748 1
a5748 1
		if (!m_srcLists[sl].IsEmpty())
d5750 1
a5750 7
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL;)
			{
				CUpDownClient *pClient = m_srcLists[sl].GetNext(pos);
				if (pClient == NULL)
					continue;
				pCopy->push_back(pClient);
			}
d5753 1
d5758 1
a5758 2
//	Find current file position in sourceslots
	POSITION	cur_FilePos = m_srcLists[pClient->m_iSourcesSlot].Find(pClient);
d5760 1
a5760 2
//	Remove current file
	if (cur_FilePos != NULL)
d5762 33
a5794 3
		m_srcLists[pClient->m_iSourcesSlot].RemoveAt(cur_FilePos);
	//	Let's update current information for the removed file
		NewSrcPartsInfo();
a5795 1
	return (cur_FilePos != NULL);
d5800 11
a5810 1
	return (m_srcLists[pClient->m_iSourcesSlot].Find(pClient) != NULL);
d5815 4
a5818 5
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
	{
		if (!m_srcLists[sl].IsEmpty())
			m_srcLists[sl].RemoveAll();
	}
@


1.622
log
@1) name corrections
2) fixed the DL session cancel if remote client delays with sending of the first data block
3) added the "m_SourceLists" in header file
@
text
@d849 1
a849 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to rename part.met file '%s' to '%s' - %s"), m_strFullName, strTempName, strerror(errno));
d1089 1
a1089 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to move temporary part.met file '%s' to '%s' - %s"), strTempName, m_strFullName, strerror(errno));
d1883 1
a1883 1
					AddDebugLogLine(_T("%s: corruption of m_downloadingSourceList"), __FUNCTION__);
d4874 1
a4874 1
		return ;
d5611 1
a5611 1
		return ;
d5614 1
a5614 1
		return ;
@


1.621
log
@Fixed comment status update while swapping A4AF [eklmn];
Unified handling of file comments.
@
text
@d232 2
a233 2
	hasRating = false;
	hasComment = false;
d4876 1
a4876 1
	bool prev = (hasComment || hasRating);
d4878 2
a4879 2
	hasComment = false;
	hasRating = false;
d4889 1
a4889 1
			hasComment = true;
d4891 2
a4892 2
			hasRating = true;
		if (hasComment && hasRating)
d4896 1
a4896 1
	if ((!hasComment) || (!hasRating))
d4902 1
a4902 1
				hasComment = true;
d4904 2
a4905 2
				hasRating = true;
			if (hasComment && hasRating)
d4910 1
a4910 1
	if ((!hasComment) || (!hasRating))
d4915 1
a4915 1
			hasComment = true;
d4917 1
a4917 1
			hasRating = true;
d4920 1
a4920 1
	if (prev != (hasComment || hasRating))
d4941 1
a4941 1
	if (!hasRating)
d5607 1
a5607 1
void CPartFile::AddPastComment(CUpDownClient *pClient)
@


1.620
log
@Faster processing of file comments; One more step to integrate eklmn's SSDQ.
@
text
@a4911 1
		CString			strTmp = GetFileComment();
d4914 1
a4914 1
		if (!strTmp.IsEmpty())
a5606 1
//	#zegzav:pastcomment
d5610 1
a5610 3
	EMULE_TRY

	if ((pClient == NULL) || (pClient->m_pReqPartFile != this))
d5613 1
a5613 1
	if (pClient->IsFileCommentEmpty() && (pClient->GetFileRating() == PF_RATING_NONE))
d5617 1
a5617 2

	EMULE_CATCH
@


1.619
log
@Fixed broken by recent changes periodic source saving to a file;
Removed unused or redundant code.
@
text
@d265 1
a265 1
	::InitializeCriticalSection(&m_csDownloadingSourceList);
d295 1
a295 1
	::DeleteCriticalSection(&m_csDownloadingSourceList);
d1869 1
a1869 1
		EnterCriticalSection(&m_csDownloadingSourceList);
d1871 1
a1871 1
		LeaveCriticalSection(&m_csDownloadingSourceList);
d1875 1
a1875 1
			EnterCriticalSection(&m_csDownloadingSourceList);
d1877 1
a1877 1
			LeaveCriticalSection(&m_csDownloadingSourceList);
d1884 1
a1884 1
					EnterCriticalSection(&m_csDownloadingSourceList);
d1886 1
a1886 1
					LeaveCriticalSection(&m_csDownloadingSourceList);
d3543 1
a3543 1
	EnterCriticalSection(&m_csDownloadingSourceList);
d3545 1
a3545 1
	LeaveCriticalSection(&m_csDownloadingSourceList);
d3549 1
a3549 1
		EnterCriticalSection(&m_csDownloadingSourceList);
d3551 1
a3551 1
		LeaveCriticalSection(&m_csDownloadingSourceList);
d3626 1
a3626 1
	EnterCriticalSection(&m_csDownloadingSourceList);
d3628 1
a3628 1
	LeaveCriticalSection(&m_csDownloadingSourceList);
d3632 1
a3632 1
		EnterCriticalSection(&m_csDownloadingSourceList);
d3634 1
a3634 1
		LeaveCriticalSection(&m_csDownloadingSourceList);
d4888 1
a4888 1
		if (pSource->GetFileComment().GetLength() > 0)
d5541 1
a5541 1
	EnterCriticalSection(&m_csDownloadingSourceList);
d5549 1
a5549 1
	LeaveCriticalSection(&m_csDownloadingSourceList);
d5558 1
a5558 1
	EnterCriticalSection(&m_csDownloadingSourceList);
d5566 1
a5566 1
	LeaveCriticalSection(&m_csDownloadingSourceList);
d5614 1
a5614 1
	if ((!pClient) || (pClient->m_pReqPartFile != this))
d5617 1
a5617 1
	if ((pClient->GetFileComment().IsEmpty()) && (pClient->GetFileRating() == PF_RATING_NONE))
d5640 1
a5640 1
		     && (pClient->GetFileComment().IsEmpty())
d6058 40
@


1.618
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1811 1
a1811 1
		//	2) the remote queue is still full & we waited at least 3*FILEREASKTIME to enter into the queue
d1837 1
a1837 2
	bool			bIsClientConnected = false;
	bool			bReaskDownload = false;
a1917 1
		uint16	uLowestQR = 0xFFFF;
a1959 1
					bIsClientConnected = true;
d2076 1
a2076 1
							if ( pSource->IsRemoteQueueFull() && pSource->GetAskedCountDown() > 3)
d2081 1
a2081 3
									&& m_iSrcNNP == uDroppedNNP
								//	QueueFull sources get a second chance
									&& pSource->GetAskedCountDown() > 1 )
a2139 2
								if (uQueueRank < uLowestQR)
									uLowestQR = uQueueRank;
a2197 1
							bReaskDownload = true;
d2228 1
a2228 1
							bIsClientConnected = pSource->AskForDownload();
d2242 1
a2242 1
			AddDebugLogLine( RGB_LOG_DIMMED + _T("Dropped %u/%u sources from file '%s': %u/%u L2L, %u/%u NNP, %u/%u QF, %u/%u HQR(%u) [%u < QR < %u]")
d2248 1
a2248 1
				, m_uHighestRemoteQueueRank, uLowestQR, uHighestQR );
a2268 1
		m_uLowestRemoteQueueRank = uLowestQR;
d2345 1
a2345 1
		if ((dwIteration == 1) && g_eMuleApp.m_pGlobPrefs->SLSEnable() && m_downloadingSourceList.IsEmpty() && g_eMuleApp.m_pServerConnect->IsConnected())
@


1.617
log
@One more step to integrate eklmn's SSDQ.
@
text
@a213 3
	m_iSrcNoUpload = 0;
	m_iSrcBanned = 0;
	m_iSrcError = 0;
a1918 3
		uint16	uNoUploadSrcCount = 0;
		uint16	uBannedSrcCount = 0;
		uint16	uErrorSrcCount = 0;
a1970 9
						case DS_BANNED:
						{
							if (!bAlreadyCounted)
							{
								uBannedSrcCount++;
								bAlreadyCounted = true;
							}
							break;
						}
a1974 1
								uErrorSrcCount++;
a2202 1
								uNoUploadSrcCount++;
a2275 3
		m_iSrcNoUpload = uNoUploadSrcCount;
		m_iSrcBanned = uBannedSrcCount;
		m_iSrcError = uErrorSrcCount;
d3355 3
a3592 3
	m_iSrcNoUpload = 0;
	m_iSrcBanned = 0;
	m_iSrcError = 0;
@


1.616
log
@One more step to integrate eklmn's SSDQ.
@
text
@d211 2
a212 1
	m_iSrcLowToLow = 0;
d2065 1
a2065 1
								&& m_iSrcLowToLow == uDroppedLowToLowID )
d2099 1
a2099 1
									&& m_iSrcLowToLow == uDroppedLowToLowID
d2124 1
a2124 1
										&& m_iSrcLowToLow == uDroppedLowToLowID
d2290 2
a2291 1
		m_iSrcLowToLow = uLowToLowIDSrcCount;
d3607 2
a3608 1
	m_iSrcLowToLow = 0;
@


1.615
log
@Fixed uploading of completed file after file movement {xalbux};
Unified processing of part and temporary file names.
@
text
@d1868 3
a1870 3
//	Calculate data rate, set limit, etc.
//	9 iterations for download & 1 iteration for other files
	if (dwIteration < 10 && !m_downloadingSourceList.IsEmpty())
a1900 2
		m_iNumTransferringSrcs = dwNumTransferringSrcs;
		m_dwDataRate = dwDataRate;
d1902 4
a1905 1
	else
a1973 9
						{
							dwCurrentDataRate = pSource->DownloadProcess(dwReduceDownload);
						//	Since client can be dropped due timeout we need to check the state
							if (pSource->GetDownloadState() != DS_DOWNLOADING)
								break;
						//	Needed to update the source count
						//	GetTransferringSrcCount() isn't updated inside this function.
							dwNumTransferringSrcs++;
							dwDataRate += dwCurrentDataRate;
d1975 1
a1975 1
						}
a2293 1
		m_iNumTransferringSrcs = dwNumTransferringSrcs;
a2295 1
		m_dwDataRate = dwDataRate;
@


1.614
log
@fixed source SX. thanks glaskrug
@
text
@d327 1
a327 1
	CString strFileName;
d331 1
a331 2
		iPartNumber++;
		strFileName.Format(_T("%s\\%03i.part"), m_strTempDir, iPartNumber);
d333 1
a333 1
	while (PathFileExists(strFileName));
d335 3
a337 2
	m_strPartMetFileName.Format(_T("%03i.part.met"), iPartNumber);
	m_strFullName.Format(_T("%s\\%s"), m_strTempDir, m_strPartMetFileName);
d344 1
a344 5
	CString partfull = m_strFullName.Left(m_strFullName.GetLength() - 4);

	SetFilePath(partfull);

	if (!m_hPartFileWrite.Open(partfull, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
d349 1
a349 1
	if (!m_hPartFileRead.Open(partfull, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
d417 2
a418 1
	m_strFullName.Format(_T("%s\\%s"), GetPath(), m_strPartMetFileName);
d622 1
a622 1
		CString		strPath = RemoveFileExtension(m_strFullName);
d726 1
a726 3
	CString strSearchPath = m_strFullName.Left(m_strFullName.GetLength() - 4);

	if (!m_hPartFileWrite.Open(strSearchPath, CFile::modeWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
d729 1
a729 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), strSearchPath, m_strFileName);
d733 1
a733 1
	if (!m_hPartFileRead.Open(strSearchPath, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
d737 1
a737 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), strSearchPath, m_strFileName);
a740 1
	SetFilePath(strSearchPath);
d800 1
a800 1
	AdjustNTFSDaylightFileTime(&dwFileDate, strSearchPath);
d845 2
a846 1
	m_strFullName.Format(_T("%s\\%s"), GetPath(), m_strPartMetFileName);
d899 1
a899 2
	CString strSearchPath = m_strFullName.Left(m_strFullName.GetLength() - 4);
	bool bEnd = !ff.FindFile(strSearchPath, 0);
d1094 1
a1094 1
	CString		strPath = RemoveFileExtension(m_strFullName);
d3023 1
a3023 1
	CString partfilename = m_strFullName.Left(m_strFullName.GetLength() - 4);
d3043 2
a3044 2
	if ( (_toupper(partfilename[0]) != _toupper(newname[0])) &&
		(partfilename[1] == _T(':') && newname[1] == _T(':')) && (GetFileSize() > 1024*1024) )
d3055 1
a3055 1
			if ( !fInputFile.Open( partfilename, CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary
d3059 1
a3059 1
				throw CString(_T("can't open file for reading (") + partfilename + _T(')'));
a3101 1
			m_strFullName = newname;
d3103 1
a3103 1
			SetFilePath(m_strFullName);
d3124 1
a3124 1
			::DeleteFile(partfilename);
d3191 1
a3191 1
		if (_trename(partfilename, newname))
a3206 1
		m_strFullName = newname;
d3208 1
a3208 1
		SetFilePath(m_strFullName);
a3232 1
	CString	strFilePath = RemoveFileExtension(strTempFullName);
d3235 1
a3235 1
	strFileToRemove = strFilePath + _T(".dir");
d3245 1
a3245 1
	strFileToRemove = strFilePath + _T(".settings");
d3250 1
a3250 1
	strFileToRemove = strFilePath + _T(".txtsrc");
d3255 1
a3255 1
	strFileToRemove = strFilePath + _T(".stats");
d3323 1
a3323 1
		strTempFullName.Format(_T("%s \"%s\""), g_eMuleApp.m_pGlobPrefs->GetAVParams(), m_strFullName);
d3339 1
a3339 1
		if (pFakeCheck->ExtractRARArchive(GetFilePath(), g_eMuleApp.m_pGlobPrefs->GetConfigDir()))
d3444 2
a3445 3
	CString partfilename = m_strFullName.Left(m_strFullName.GetLength() - 4);
	if (_tremove(partfilename))
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), partfilename);
d3963 2
a3964 3
		CString strLine = this->GetFullName();
		CString player = g_eMuleApp.m_pGlobPrefs->GetVideoPlayer();
		strLine.Replace(_T(".met"), _T(""));
d3967 1
a3967 1
		if (strLine.Find(_T(' ')) != -1)
d3972 1
a3972 1
		if (player.IsEmpty())
d3978 6
a3983 4
			CString strPlayerPath = player;
			int i = strPlayerPath.ReverseFind('\\');
			strPlayerPath = (i >= 0) ? strPlayerPath.Left(i + 1) : _T("");
			ShellExecute(NULL, _T("open"), player, strLine, strPlayerPath, SW_SHOWNORMAL);
d4331 1
a4331 1
	return RemoveFileExtension(m_strFullName) + _T(".stats");
d4481 1
a4481 1
	CString strIniFile = RemoveFileExtension(m_strFullName);
d4508 1
a4508 1
	CString strIniFile = RemoveFileExtension(m_strFullName);
d5397 1
a5397 1
							 GetResString(IDS_DL_FILENAME), GetFullName(),
d5442 1
a5442 1
				 GetResString(IDS_DL_FILENAME), GetFullName(),
d5893 1
a5893 1
		iRc = (::CircularFileRead(m_strFullName, dwOffset, dwBytesToRead, pbyteBuffer)) ? 0 : -1;
d5947 1
a5947 1
//	set the name & extension
a5948 2
	if (!IsPartFile())
		m_strFullName = GetFilePath();
@


1.613
log
@Some eklmn's modifications.
@
text
@d4161 1
a4161 1
			if (pPotentialSource->GetServerIP() != 0 || pPotentialSource->GetServerPort() != 0)
d4165 1
a4165 1
				&& pPotentialSource->GetServerPort() != pForClient->GetServerPort() )
@


1.612
log
@One more step to integrate eklmn's SSDQ; Formatting;
Changed return type of GetNotCurrentSourcesCount and GetValidSourcesCount.
@
text
@d205 1
a205 1
	m_iSrcTooManyConns = 0;
d2297 1
a2297 1
		m_iSrcTooManyConns = uTooManyConnsSrcCount;
d3619 1
a3619 1
	m_iSrcTooManyConns = 0;
@


1.611
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1707 1
a1707 1
int CPartFile::GetValidSourcesCount()
d1712 1
a1712 1
	int counter = 0;
d1714 1
d1722 1
a1722 1
					counter++;
d1724 1
a1724 1
	return counter;
d1732 1
a1732 1
uint16 CPartFile::GetNotCurrentSourcesCount()
d1737 1
a1737 1
	uint16 counter = 0;
d1746 1
a1746 1
					counter++;
d1748 1
a1748 1
	return counter;
a1901 1
				{
a1902 1
				}
d3258 1
a3258 1
//	Remove .txtscr file
d3474 1
a3474 1
//	Remove .txtscr file
d4126 3
a4128 7
	byte		   *pbyteForClientPartStatus;
	byte		   *pbytePotentialClientPartStatus;

	uint32			dwID;
	uint16			uPort;
	uint32			dwServerIP;
	uint16			uServerPort;
d4144 1
a4144 1
		if (pForClient->Compare(pPotentialSource) != 0)
a4974 2
	EMULE_TRY

a4979 4

	EMULE_CATCH

	return 0;
@


1.610
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1792 2
a1793 2
//	[In] number_sources_to_remove: Number of sources to be removed from list or 0xffffffff if we want all removed
void CPartFile::RemoveNoNeededSources(uint32 number_sources_to_remove)
d1798 22
a1819 5
	POSITION pos;
	uint32 removed = 0;
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
		if (!m_srcLists[sl].IsEmpty())
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL && removed < number_sources_to_remove;)
d1821 3
a1823 12
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
			//	The sources will be dropped in 2 cases:
			//	1) the remote client does not have required parts
			//	2) the remote queue is still full & we waited at least 3*FILEREASKTIME to enter into the queue
				if ( (pSource->GetDownloadState() == DS_NONEEDEDPARTS)
					|| ( (pSource->GetDownloadState() == DS_ONQUEUE)
						&& pSource->IsRemoteQueueFull()
						&& (pSource->GetAskedCountDown() > 3) ) )
				{
					g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
					removed ++;
				}
d1825 2
d1847 1
d2321 2
a2322 1
			for (int sl = 0; sl < SOURCESSLOTS; sl++)
d2324 6
a2329 1
				if (!m_srcLists[sl].IsEmpty())
d2331 6
a2336 1
					for (pos1 = m_srcLists[sl].GetHeadPosition(); pos1 != NULL;)
d2338 2
a2339 4
						pSource = m_srcLists[sl].GetNext(pos1);
						bIsNNS = false;
					//	Check if current source has a part for this file
						if (pSource->GetDownloadState() == DS_NONEEDEDPARTS)
d2341 1
a2341 20
						//	Check if A4AF Auto file is enable
							if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == NULL)
							//	A4AF auto is disable => switch to any file
								pSource->SwapToAnotherFile(NULL);
							else if (g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() != this)
							{
							//	A4AF auto is enable & isn't current file => switch to A4AF auto file
								if (pSource->m_otherNoNeededMap.IsEmpty())
								{
									pSource->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
								}
								else
								{
									bIsNNS = pSource->m_otherNoNeededMap.Lookup(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile(), dwLastNoNeededCheckTime);
									if (!bIsNNS || (dwCurTick - dwLastNoNeededCheckTime) > FILEREASKTIME)
									{
										pSource->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
									}
								}
							}
a2372 1

d2386 1
d4229 1
a4229 1
			    packetStream.Write(pPotentialSource->GetUserHash(),16);
d6044 22
@


1.609
log
@One more step to integrate eklmn's SSDQ;
Fixed switching of all A4AF sources after pausing a file [eklmn].
@
text
@d4133 1
a4133 2

	POSITION		pos;
d4136 2
a4137 1
	for (uint32 sl = 0; sl < SOURCESSLOTS; sl++)
d4139 1
a4139 5
		if (!m_srcLists[sl].IsEmpty())
		{
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL; )
			{
				pPotentialSource = m_srcLists[sl].GetNext(pos);
d4141 2
a4142 2
				if (md4cmp(pPotentialSource->m_reqFileHash, pForClient->m_reqFileHash) != 0)
					continue;
d4144 37
a4180 37
			//	Don't send a client to itself as a source (part 1)
				if (pForClient == pPotentialSource)
					continue;
			//	Don't send a client to itself as a source (part 2)
				if (pForClient->Compare(pPotentialSource) != 0)
				{
				//	Actually if function 'CClientList::AttachToAlreadyKnown()' is working properly, then we should never see this message
					AddDebugLogLine( RGB_BLUE_VIOLET_TXT _T("Found same client during SX c1=(%s,%s), c2=(%s,%s)"), 
									pPotentialSource->GetClientNameWithSoftware(),
									HashToString(pPotentialSource->GetUserHash()),
									pForClient->GetClientNameWithSoftware(),
									HashToString(pForClient->GetUserHash()) );
					continue;
				}
			//	Check LowID status
				if (pPotentialSource->HasLowID())
				{
				//	Don't send a LowID client to LowID as they will not able to connect
					if (pForClient->HasLowID())
						continue;
				//	Don't send a LowID client if server IP & server port are unknown
					if (pPotentialSource->GetServerIP() != 0 || pPotentialSource->GetServerPort() != 0)
						continue;
				//	Don't send a LowID client to HighID if client on different server
					if ( pPotentialSource->GetServerIP() != pForClient->GetServerIP()
						&& pPotentialSource->GetServerPort() != pForClient->GetServerPort() )
						continue;
				}
			//	Don't send clients that have no parts available
				if (pPotentialSource->GetAvailUpPartCount() == 0)
					continue;
			//	Don't share Lan clients sources as they are private ips/userids
				if (pPotentialSource->IsOnLAN())
					continue;
			//	don't send erroneous or fake sources
				if (uPartCount != pPotentialSource->GetUpPartCount())
					continue;
d4182 10
a4191 10
			//	Don't send incomplete established connections. to avoid sending no valid sources
				switch (pPotentialSource->GetDownloadState())
				{
					case DS_NONE:
					case DS_CONNECTING:
					case DS_ERROR:
					case DS_TOOMANYCONNS:
					continue;
					break;
				}
d4193 1
a4193 1
				bNeededPart = false;
d4195 3
a4197 3
			//	Only send source which have needed parts for this client if possible
				pbyteForClientPartStatus = pForClient->GetPartStatus();
				pbytePotentialClientPartStatus = pPotentialSource->GetPartStatus();
d4199 6
a4204 2
			//	Both clients support part statuses so we try to find needed clients
				if (pbyteForClientPartStatus != NULL && pbytePotentialClientPartStatus != NULL)
a4205 11
					for (uint32 i = 0; i < uPartCount; i++)
					{
						if (pbytePotentialClientPartStatus[i] && !pbyteForClientPartStatus[i])
						{
							bNeededPart = true;
							break;
						}
					}
				}
			//	If not we give a sources with at least one part (for files that have more than one part)
				else
d4207 1
a4207 17

				if (bNeededPart)
				{
					uCount++;
					dwID = pPotentialSource->GetUserID();
					uPort = pPotentialSource->GetUserPort();
					dwServerIP = pPotentialSource->GetServerIP();
					uServerPort = pPotentialSource->GetServerPort();

					packetStream.Write(&dwID, 4);
					packetStream.Write(&uPort, 2);
					packetStream.Write(&dwServerIP, 4);
					packetStream.Write(&uServerPort, 2);
					if (pForClient->GetSourceExchangeVersion() > 1)
			    		packetStream.Write(pPotentialSource->GetUserHash(),16);
					if (uCount > 500)
						break;
d4211 21
@


1.608
log
@fixed indefication of the client IP identiifcatio has more higher priority as Userhash.
@
text
@d2509 1
a2509 2
	CUpDownClient*			pSource;
	POSITION				pos;
d2512 1
d2516 2
a2517 1
	for (int sl = 0; sl < SOURCESSLOTS; ++sl)
d2519 5
a2523 1
		if (!m_srcLists[sl].IsEmpty())
d2525 1
a2525 1
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL;)
d2527 2
a2528 20
				pSource = m_srcLists[sl].GetNext(pos);
				if (pSource)
				{
					uint32		dwSourcePartsCounter = 0;
				//	Count available parts from source
					for (uint32 i = 0; i < dwPartCount; i++)
					{
						if (pSource->IsPartAvailable(i))
						{
							PartFrequencyArray[i]++;
							dwSourcePartsCounter++;
						}
					}
				//	Count full sources
					if (dwSourcePartsCounter == dwPartCount)
					{
//						ASSERT(pSource->IsCompleteSource());
						uNewCompleteSrcCount++;
					}
				}
d2531 3
d3388 2
a3389 1
	CUpDownClient* pRemoveSource;
d3391 2
a3392 1
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
d3394 3
a3396 1
		while (!m_srcLists[sl].IsEmpty())
d3398 1
a3398 2
			pRemoveSource = m_srcLists[sl].GetHead();
			if (bTryToSwap)
d3400 2
a3401 10
				if (!pRemoveSource->SwapToAnotherFile(NULL, true, true))
				{
				//	If the switching wasn't succesfull we remove the source from the downloadqueue
					g_eMuleApp.m_pDownloadQueue->RemoveSource(pRemoveSource);
				}
				else
				{
				//	If the switching was succesfull we need to remove the entry from graphical list
					g_eMuleApp.m_pDownloadList->RemoveSource(pRemoveSource, this);
				}
d3405 2
a3406 2
			//	We weren't asked to swap so we remove it
				g_eMuleApp.m_pDownloadQueue->RemoveSource(pRemoveSource);
d3409 5
d3661 2
a3662 1
	CUpDownClient* pSource;
d3689 2
a3690 1
	for (int sl = 0; sl < SOURCESSLOTS; sl++)
d3692 2
a3693 12
		if (!m_srcLists[sl].IsEmpty())
		{
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL;)
			{
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
			//	Swap source to any other file
				if (pSource->GetDownloadState() == DS_ONQUEUE)
				{
					pSource->SwapToAnotherFile(NULL);
				}
			}
		}
d4936 14
a4949 13
	POSITION pos;
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
		if (!m_srcLists[sl].IsEmpty())
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
			{
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
				if (pSource->GetFileComment().GetLength() > 0)
					hasComment = true;
				if (pSource->GetFileRating() != PF_RATING_NONE)
					hasRating = true;
				if (hasComment && hasRating)
					break;
			}
d4953 1
a4953 1
		for (pos = m_pastCommentList.GetHeadPosition(); pos != NULL;)
d5006 1
a5006 1
	int num, tot, fRate;
d5010 1
a5010 1
	POSITION pos;
d5012 2
a5013 2
//	For each source slot...
	for (int sl = 0; sl < SOURCESSLOTS; sl++)
d5015 4
a5018 2
	//	If the slot isn't empty...
		if (!m_srcLists[sl].IsEmpty())
d5020 4
a5023 9
			for (pos = m_srcLists[sl].GetHeadPosition(); pos != NULL;)
			{
				fRate = m_srcLists[sl].GetNext(pos)->GetFileRating();
				if (fRate > 0)
				{
					num++;
				//	Bugfix: for some $%#ing reason fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
					if (fRate == PF_RATING_GOOD || fRate == PF_RATING_FAIR)
						fRate = (fRate == PF_RATING_GOOD) ? 4 : 3;
d5025 1
a5025 3
					tot += fRate;
				}
			}
d5029 1
a5029 1
	for (pos = m_pastCommentList.GetHeadPosition(); pos != NULL;)
d5031 1
a5031 1
		fRate = m_pastCommentList.GetNext(pos).GetRating();
d5033 1
a5033 1
		if (fRate > 0)
d5037 2
a5038 2
			if (fRate == PF_RATING_GOOD || fRate == PF_RATING_FAIR)
				fRate = (fRate == PF_RATING_GOOD) ? 4 : 3;
d5040 1
a5040 1
			tot += fRate;
d5044 2
a5045 2
	fRate = GetFileRating();
	if (fRate > 0)
d5049 2
a5050 2
			if (fRate == PF_RATING_GOOD || fRate == PF_RATING_FAIR)
				fRate = (fRate == PF_RATING_GOOD) ? 4 : 3;
d5052 1
a5052 1
			tot += fRate;
d5174 22
a5195 4
	POSITION pos1, pos2;
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
		if (!m_srcLists[sl].IsEmpty())
			for (pos1 = m_srcLists[sl].GetHeadPosition();pos1 != NULL;)
d5197 2
a5198 4
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos1);
				if (pSource->HasLowID())
					continue;
				if (srcstoadd.IsEmpty())
d5200 3
a5202 21
					srcstoadd.AddHead(pSource);
					continue;
				}
				if ((sourcenum == 0) || (srcstoadd.GetCount() < sourcenum) || (pSource->GetAvailablePartCount() > srcstoadd.GetTail()->GetAvailablePartCount()))
				{
					if ((sourcenum != 0) && (srcstoadd.GetCount() == sourcenum))
						srcstoadd.RemoveTail();
					ASSERT(srcstoadd.GetCount() < sourcenum);
					bool bInserted = false;
					for (pos2 = srcstoadd.GetTailPosition();pos2 != 0;)
					{
						CUpDownClient * cur_srctoadd = srcstoadd.GetPrev(pos2);
						if (cur_srctoadd->GetAvailablePartCount() > pSource->GetAvailablePartCount())
						{
							srcstoadd.InsertAfter(pos2, pSource);
							bInserted = true;
							break;
						}
					}
					if (!bInserted)
						srcstoadd.AddHead(pSource);
d5205 4
d5857 1
a5857 1
	catch (CFileException * error)
d6061 6
a6066 1
				pCopy->push_back(m_srcLists[sl].GetNext(pos));
@


1.607
log
@The second step to integrate eklmn's SSDQ;
Removed unrequired array cleanup, as it is done anyway in destructor.
@
text
@d4170 1
a4170 1
				if (pForClient->Compare(pPotentialSource))
@


1.606
log
@Corrections for SSDQ integration.
@
text
@a2577 1
	PartFrequencyArray.RemoveAll();
d6085 29
@


1.605
log
@Rolled back one "improvement" of SX to avoid spreding of wrong sources.
@
text
@d6070 1
a6070 1
void CPartFile::GetCopySourceList(uint32 dwDSBeg, uint32 dwDSEnd, ClientList *pCopy)
@


1.604
log
@Formatting.
@
text
@d4164 3
@


1.603
log
@improved LowID check by SX (part 2)
@
text
@d1805 5
a1809 5
			// the sources will be droped in 2 cases:
			// 1) the remote client does not have required parts
			// 2) the remote queue is still full & we waited at least 3*FILEREASKTIME to enter into the queue
				if (pSource->GetDownloadState() == DS_NONEEDEDPARTS
					|| (pSource->GetDownloadState() == DS_ONQUEUE 
d1811 1
a1811 1
						&& pSource->GetAskedCountDown() > 3))
d4164 1
a4164 1
			//	Don't send a client to himself as a source (part 1)
d4167 1
a4167 1
			//	Don't send a client to himself as a source (part 2)
d4170 2
a4171 2
				// actually if function 'CClientList::AttachToAlreadyKnown()' is working properly, then we should never see this message
					AddDebugLogLine(RGB_BLUE_VIOLET + _T("Found same client during SX c1=('%s', %s), c2=('%s',%s)"), 
d4175 1
a4175 2
									HashToString(pForClient->GetUserHash())
									);
d4178 2
a4179 2
			//	check LowID status
				if ( pPotentialSource->HasLowID())
d4181 1
a4181 1
				//	Don't send a LowID client to LowID they are will not able to connect
d4184 1
a4184 1
				//	Don't send a LowID client if server IP & server port are unknow
d4188 1
a4188 1
					if (pPotentialSource->GetServerIP() != pForClient->GetServerIP()
d4198 2
a4199 2
			//	don't send errorneus or fake sources
				if (uPartCount != pPotentialSource->GetUpPartCount() )
@


1.602
log
@improved LowID check by SX
@
text
@d2488 1
a2488 1
			CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this, dwUserID, iUserPort, iServerIP, iServerPort);
d5143 1
a5143 1
		CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this,pSource->sourceID,pSource->sourcePort, pSource->serverIP, pSource->serverPort);
@


1.601
log
@indefication of the client by connection
@
text
@d4179 14
a4192 5
			//	Only send sources with LowID that are in same sever that client who is requesting sources
				if ( pPotentialSource->HasLowID()
						     && ( pPotentialSource->GetServerIP() != pForClient->GetServerIP()
						          || pPotentialSource->GetServerPort() != pForClient->GetServerPort() ) )
					continue;
@


1.600
log
@new way of queue handling
@
text
@d4164 15
a4178 1
			//	Don't send a client to himself as a source
d4180 4
d4185 2
d4188 4
a4191 8
				if ( md4cmp(pPotentialSource->m_reqFileHash, pForClient->m_reqFileHash) != 0
						|| pForClient == pPotentialSource || pForClient->Compare(pPotentialSource)
						|| ( pPotentialSource->HasLowID()
						     && ( pPotentialSource->GetServerIP() != pForClient->GetServerIP()
						          || pPotentialSource->GetServerPort() != pForClient->GetServerPort() ) )
						|| pPotentialSource->GetAvailUpPartCount() == 0
						|| pPotentialSource->IsOnLAN()
						|| uPartCount != pPotentialSource->GetUpPartCount() )
@


1.599
log
@Log line "Cancel the file: ..." is substituted with "Cancelled: ...".
@
text
@d1805 7
a1811 3
				if ((pSource->GetDownloadState() == DS_NONEEDEDPARTS) 
					|| (pSource->IsQueueRankReceived() && pSource->IsRemoteQueueFull())
					|| (!pSource->IsQueueRankReceived() && pSource->IsEmuleClient()) )  //netwolf: katsyonak change
d2097 2
a2098 2
							if ( (pSource->IsQueueRankReceived() && pSource->IsRemoteQueueFull()) 
								|| (!pSource->IsQueueRankReceived() && pSource->IsEmuleClient()))
@


1.598
log
@Simplified transition to eklmn's SSDQ.
@
text
@d3447 2
a3448 2
	GetResString(&strFileToRemove, IDS_TREE_DL_CANCEL);
	strFileToRemove += _T(" %s");
@


1.597
log
@1. QR highlighting
2. output "Queue Full" if eMule client did not send QR
3. possible download abort
@
text
@d6038 17
@


1.596
log
@An attempt to add preview support for .cbr and .cbz {purgossu}.
@
text
@d1805 3
a1807 1
				if ((pSource->GetDownloadState() == DS_NONEEDEDPARTS) || (pSource->IsRemoteQueueFull()))  //netwolf: katsyonak change
d2093 2
a2094 1
							if (pSource->IsRemoteQueueFull())
@


1.595
log
@Slightly cleaned a mess of including one H-file into another.
@
text
@d5967 1
a5967 1
		_T("zip"), _T("rar")
@


1.594
log
@Fixed saving and display of "Gained Due To Compression" global statistics.
@
text
@d34 1
@


1.593
log
@Renaming.
@
text
@a231 1
	m_qwSessionGainDueToCompression = 0;
d4549 1
a4549 1
		m_qwSessionGainDueToCompression += static_cast<uint64>(iCompressionGain);
@


1.592
log
@Units are added to the saved number.
@
text
@d763 1
a763 1
	CSingleLock Lock(&m_mutexHashList, TRUE);
d949 1
a949 1
		CSingleLock Lock(&m_mutexHashList, TRUE);
d1136 1
a1136 1
	CSingleLock Lock(&m_mutexHashList, TRUE);
@


1.591
log
@Corrected calculation of corruption loss size (subtraction of actually saved data was required);
Cumulative statistics of lost due to corruption was always zero after restart {muleteer}.
@
text
@d4762 1
a4762 1
					AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_ICHWORKED), iPartNum, m_strFileName, dwSaved);
@


1.590
log
@Improved files publishing algorithm on the server; Improved string processing.
@
text
@a232 1
	m_qwSessionLostDueToCorruption = 0;
d1159 1
a1159 2
				m_qwLostDueToCorruption += (dwPartEnd - dwPartStart + 1);
				m_qwSessionLostDueToCorruption += (dwPartEnd - dwPartStart + 1);
d3337 1
a3337 1
		ShellExecute(NULL, "open", g_eMuleApp.m_pGlobPrefs->GetAVPath(), strTempFullName, NULL, SW_SHOW);
a4302 5
void CPartFile::GetSizeToTransfer(uint32& pui32SizeToTransfer)
{
	pui32SizeToTransfer = m_dwGapsSum;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d4726 1
a4726 2
					m_qwLostDueToCorruption += (partRange + 1);
					m_qwSessionLostDueToCorruption += (partRange + 1);
d4756 3
d4762 1
a4762 1
					AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_ICHWORKED), iPartNum, GetFileName());
d4764 5
d6029 6
@


1.589
log
@Added possibility to get preview parts for .asf files {DonGato};
Removed some unused code.
@
text
@d3313 3
d3347 3
a3349 1
		CString		strBackupFilePath = strFakesDotDatPath + _T(".bak");
@


1.588
log
@Log canceled files.
@
text
@a3544 125
bool CPartFile::IsMovieChunk(byte mode, uint16 chunk)
{
	EMULE_TRY

	uint32 lastblock = (PARTSIZE + EMBLOCKSIZE - 1) / EMBLOCKSIZE, dwEnd;
	if (chunk == GetPartCount() - 2)
		dwEnd = (PARTSIZE * chunk) + (lastblock * EMBLOCKSIZE) - 1; // End address from 1 chunk before the last chunk

	switch (mode)
	{
		case 0:  //Mode 0: No Preview
		return false;
		break;
		case 1:  //Mode 1: 1F,1L(2L) AVI
		if (chunk == 0)
			return true; //1F
		if (chunk == GetPartCount() - 1)
			return true; //1L is a moviechunk ?
		if (chunk == (GetPartCount() - 2) && (((GetFileSize() - 1) - MINLASTMOVIESIZE) <= dwEnd))
			return true; //2L is a Part of 1/8L at the end of the file
		break;
		case 2:  //Mode 2: 1F,2F,1L(2L) Long AVI
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == GetPartCount() - 1)
			return true; //1L is a moviechunk ?
		if (chunk == (GetPartCount() - 2) && (((GetFileSize() - 1) - MINLASTMOVIESIZE) <= dwEnd))
			return true; //2L is a Part of 1/8L at the end of the file
		break;
		case 3:  //Mode 3: 1F,2F,3F,1L(2L) Longest AVI
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == 2)
			return true; //3F
		if (chunk == GetPartCount() - 1)
			return true; //1L is a moviechunk
		if (chunk == (GetPartCount() - 2) && (((GetFileSize() - 1) - MINLASTMOVIESIZE) <= dwEnd))
			return true; //2L is a Part of 1/8L at the end of the file
		break;
		case 4:  //Mode 4: 1F MPG
		if (chunk == 0)
			return true; //1F
		break;
		case 5:  //Mode 5: 1F,2F Long MPG
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		break;
		case 6:  //Mode 6: 1F,2F,3F Longest MPG
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == 2)
			return true; //3F
		break;
		case 7:  //Mode 7: 1F,2F,1L,2L AVI/MPG normal
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == GetPartCount() - 1)
			return true; //1L is a moviechunk ?
		if (chunk == GetPartCount() - 2)
			return true; //2L is a moviechunk ?
		break;
		default:
		return false;
		break;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsBetterMovieChunk(uint16 oldchunk, uint16 newchunk)
{
	EMULE_TRY

//	The routine is based on that both old & new-chunk are moviechunks
	if (oldchunk == 0) //Chunk = 1F
	{
	//	1/8F & !1/8L & (newchunk=1L | 2L)
		if ( IsComplete(0, (MINFIRSTMOVIESIZE) - 1) 										// first 1/8 chunk present
		     && !IsComplete((GetFileSize() - 1) - (MINLASTMOVIESIZE) , GetFileSize() - 1) 	// last 1/8 chunk not present
		     && ( newchunk == GetPartCount() - 1  											// better chunk could be 1L
		          || (newchunk == GetPartCount() - 2) ) ) 									// better chunk could be 2L
			return true;
	}
	else if (oldchunk == GetPartCount() - 1 || oldchunk == GetPartCount() - 2) //Chunk = 1L | 2L
	{
	//	(1/8L & !1/8F) | (1/8L & 1/8F)
		if ( ( ( !IsComplete(0, (MINFIRSTMOVIESIZE) - 1) 											// first 1/8 chunk not present
		         && IsComplete((GetFileSize() - 1) - (MINLASTMOVIESIZE) , GetFileSize() - 1) ) 		// last 1/8 chunk present
		       || ( IsComplete(0, (MINFIRSTMOVIESIZE) - 1) 											// first 1/8 chunk present
		            && IsComplete((GetFileSize() - 1) - (MINLASTMOVIESIZE) , GetFileSize() - 1) ) 	// last 1/8 chunk present
		       && newchunk == 0 ) )  																// better chunk could be 1F
			return true;
	}
	else if (oldchunk == 1) //Chunk = 2F
	{
	//	1F | 1L
		if (newchunk == 0 || newchunk == GetPartCount() - 1)
			return true;
	}
	else if (oldchunk == 2) //Chunk = 3F
	{
	//	1F | 1L otherwise 2F
		if (newchunk == 0 || newchunk == GetPartCount() - 1)
			return true;
		else if (newchunk == 1)
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d5970 1
a5970 1
		_T("mpg"), _T("mpeg"), _T("vob"), _T("bin"), _T("mpe"), _T("dat")
@


1.587
log
@Chunk found corrupted on file completion wasn't marked as corrupted to make recovery faster;
Corruption loss statistics wasn't updated when chunk is found corrupted on file completion.
@
text
@d3439 6
a3457 1
	CString	strFileToRemove;
@


1.586
log
@Rollback of the previous change -- file type detection WAS case insensitive.
@
text
@d1156 6
d1187 1
a1187 1
		return ;
@


1.585
log
@file type detection wasnt case insensitive
@
text
@d6073 1
a6073 1
	CString strExt = GetFileExtension().MakeLower();
@


1.584
log
@Store corrupted part list in .part.met to continue recovering after restart;
Removed conversion/reading of old category tag; Minor optimization; Renaming.
@
text
@d6073 1
a6073 1
	CString strExt = GetFileExtension();
@


1.583
log
@v2 - more upload logic
@
text
@d237 1
a237 1
	m_nLastCompleteSrcCount = 0;
d413 1
d455 4
a458 3
		uint32 tagcount;
		file.Read(&tagcount, 4);
		for (uint32 j = 0; j < tagcount; j++)
a551 3
#if 1
				case 0x20:	//previously used value left in v1.1c for smooth upgrade, must be removed in v1.1d
#endif
d583 5
d689 23
d1027 13
d1047 1
a1047 1
		for (uint32 j = 0; j != m_tagArray.GetCount(); j++)
d2535 1
a2535 1
	m_nLastCompleteSrcCount = uNewCompleteSrcCount;
d2543 1
a2543 1
	uint16	nNewMaxSrcPartFrequency = 0;
d2548 2
a2549 1
		m_srcPartFrequencies[i] = PartFrequencyArray[i];
d2551 1
a2551 1
		if (m_srcPartFrequencies[i] > 0)
d2554 2
a2555 5

			if (m_srcPartFrequencies[i] > nNewMaxSrcPartFrequency)
			{
				nNewMaxSrcPartFrequency = m_srcPartFrequencies[i];
			}
d2559 1
a2559 1
	m_MaxSrcPartFrequency = nNewMaxSrcPartFrequency;
d2647 1
a2647 1
	uint32		dwRarestPart = (m_MaxSrcPartFrequency > 11) ? 4 : (m_MaxSrcPartFrequency / 4 + 1);
@


1.582
log
@Reapply old category tag conversion as 1.1c isn't spread well yet.
@
text
@d24 1
a24 1
	#include "Preferences.h"
@


1.581
log
@Removed importing of previous file statistics (< v1.1c).
@
text
@d550 3
@


1.580
log
@Removed unused variable; Suppressed several warnings.
@
text
@a504 3
#if 1
				case 0x13:	//previously used value left in v1.1c for smooth upgrade, must be removed in v1.1d
#endif
a526 3
#if 1
				case 0x17:	//previously used value left in v1.1c for smooth upgrade, must be removed in v1.1d
#endif
a549 3
#if 1
				case 0x20:	//previously used value left in v1.1c for smooth upgrade, must be removed in v1.1d
#endif
a4432 29
#if 1		//previous method to keep part file statistics left in v1.1c for smooth upgrade, must be removed in v1.1d
	if (statistic.alltimerequested == 0 && statistic.alltimeaccepted == 0 && statistic.alltimetransferred == 0)
	{
		uint32 alltimerequested = 0;
		uint32 alltimeaccepted = 0;
		uint64 alltimetransferred = 0;

		if (fread(&alltimerequested, sizeof(alltimerequested), 1, fh) != 1)
		{
			fclose(fh);
			return false;
		}
		statistic.alltimerequested = alltimerequested;
		if (fread(&alltimeaccepted, sizeof(alltimeaccepted), 1, fh) != 1)
		{
			fclose(fh);
			return false;
		}
		statistic.alltimeaccepted = alltimeaccepted;
		if (fread(&alltimetransferred, sizeof(alltimetransferred), 1, fh) != 1)
		{
			fclose(fh);
			return false;
		}
		statistic.alltimetransferred = alltimetransferred;
	}
	else
	{
#endif
a4440 3
#if 1		//previous method to keep part file statistics left in v1.1c for smooth upgrade, must be removed in v1.1d
	}
#endif
@


1.579
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d2469 1
a2469 1
	PartFrequencyArray.SetSize(dwPartCount);
d2486 1
a2486 1
							PartFrequencyArray[i] += 1;
d2624 1
a2624 1
	uint32		dwRareRank = ~0, dwRandomRank = ~0, dwRareVirginCnt = 0;
d4555 1
a4555 1
		return -1;
d4564 1
a4564 1
	return -1;
d5403 2
a5404 2
	IShellFolder	*pDesktop	= NULL;
	ITEMIDLIST	*pList	= NULL;
d5410 1
a5410 2
		IShellFolder	* pFolder = NULL;
		ULONG	uAttrib	= SFGAO_FOLDER ; //we're going to look for the "folder" attribute
@


1.578
log
@Fixed weird issues caused by file renaming after completion (within current session) {DopeFish}.
@
text
@d24 1
a24 1
//	#include "SharedFileList.h"
d309 3
d377 1
d385 1
d394 1
d400 1
a403 1
#endif //NEW_SOCKETS_ENGINE
@


1.577
log
@Improved rare part selection when several rare sources are available for download {DopeFish}.
@
text
@d6065 2
@


1.576
log
@minor improvement, name formating
@
text
@d2613 1
d2618 1
a2618 1
	uint32		dwRareRank = ~0, dwRandomRank = ~0;
d2638 1
d2641 3
d2646 6
a2651 1
				else if (PartsFilledSizeVector[i] < dwMostCompletedRarePartSz)
d2653 1
d2747 5
a2751 2
	//	and there's a fresh part with only one source, start downloading of the unique fresh part
		if ((dwRareFilledRank != 0) && ((dwRareFilledRank == 1) || (dwRareRank != 1)))
d2762 21
a2782 1
				dwTmp = static_cast<uint32>(rand() * (dwRarePartCnt - 1) + RAND_MAX / 2) / RAND_MAX;
@


1.575
log
@More compatible way to save part file statistics: requests, accepted requests, transferred data
(saved in .part.met file like in official, before it was in .part.stats);
Save high dword of part and known file 'transferred data' statistics to .met files only
if it contains something (to reduce known.met and .part.met file sizes).
@
text
@d1306 1
a1306 1
uint32 CPartFile::GetGapsInPart(uint16 numPart, Requested_Block_Struct** newblocks, uint32 dwCount)
d1313 1
a1313 1
	const uint32 uPartStart = numPart * PARTSIZE;
d1344 1
a1344 1
				if (newblocks != NULL)
d1356 1
a1356 1
					newblocks[dwNewBlockCount] = block;
d2579 2
a2580 1
		if ((abyteBlockedParts[dwTmp] == PARTIALLY_BLOCKED) || (abyteBlockedParts[dwTmp] == FULLY_BLOCKED))
d2586 1
a2586 1
			if ((PartsFilledSizeVector[dwTmp] != 0) && (PartsFilledSizeVector[dwTmp] != NOT_AVAILABLE))
d2594 1
a2594 2
			if (PartsFilledSizeVector[dwTmp] != NOT_AVAILABLE)
				dwNumPartiallyBlockedParts++;
@


1.574
log
@Changed tag interface to avoid memory leaks which could be possible with
new tag object structure; Added tag type checks.
@
text
@d563 21
d933 1
a933 1
		uint32	dwTagFilePos, dwTagCount = 0;
d980 20
d4387 2
a4388 1
	FILE * fh = _tfopen(GetStatsFullPath(), _T("rb"));
d4402 6
a4407 3
	uint32 alltimerequested = 0;
	uint32 alltimeaccepted = 0;
	uint64 alltimetransferred = 0;
d4409 20
a4428 1
	if (fread(&alltimerequested, sizeof(alltimerequested), 1, fh) != 1)
d4430 5
a4434 4
		fclose(fh);
		return false;
	}
	if (fread(&alltimeaccepted, sizeof(alltimeaccepted), 1, fh) != 1)
d4439 1
a4439 4
	if (fread(&alltimetransferred, sizeof(alltimetransferred), 1, fh) != 1)
	{
		fclose(fh);
		return false;
d4441 1
a4441 2

	statistic.AddAll(alltimerequested, alltimeaccepted, alltimetransferred);
d4463 1
d4480 3
a4482 15
	uint32 alltimerequested = statistic.GetAllTimeRequests();
	uint32 alltimeaccepted = statistic.GetAllTimeAccepts();
	uint64 alltimetransferred = statistic.GetAllTimeTransferred();

	if (fwrite(&alltimerequested, sizeof(alltimerequested), 1, fh) != 1)
	{
		fclose(fh);
		return false;
	}
	if (fwrite(&alltimeaccepted, sizeof(alltimeaccepted), 1, fh) != 1)
	{
		fclose(fh);
		return false;
	}
	if (fwrite(&alltimetransferred, sizeof(alltimetransferred), 1, fh) != 1)
@


1.573
log
@Minor changes related to tag processing.
@
text
@d62 7
a68 1
				SetFileName(pTag->GetStringValue());
d72 2
a73 1
				SetFileSize(pTag->GetIntValue());
d452 1
a452 1
			CTag* newtag = new CTag(file);
d454 1
d571 4
a574 2
						Gap_Struct *gap;
						uint16 gapkey = atoi(&pcTagName[1]);
d576 11
a586 6
						if (!gap_map.Lookup(gapkey, gap))
						{
							gap = new Gap_Struct;
							gap_map.SetAt(gapkey, gap);
							gap->m_dwStartOffset = ~0u;
							gap->m_dwEndOffset = ~0u;
a587 4
						if (pcTagName[0] == FT_GAPSTART)
							gap->m_dwStartOffset = newtag->GetIntValue();
						if (pcTagName[0] == FT_GAPEND)
							gap->m_dwEndOffset = newtag->GetIntValue() - 1;
@


1.572
log
@Correctly set initial flush time to avoid file flush call right after load;
Removed unused variable.
@
text
@d55 1
a55 1
	for (int i = 0; i < searchresult->m_tagArray.GetCount();i++)
d57 3
a59 1
		switch (searchresult->m_tagArray[i]->GetTagID())
d62 1
a62 1
				SetFileName(searchresult->m_tagArray[i]->GetStringValue());
d66 1
a66 1
				SetFileSize(searchresult->m_tagArray[i]->GetIntValue());
d76 1
a76 1
				CFileTag	   *pNewTag = new CFileTag(*searchresult->m_tagArray[i]);
d330 2
a331 2
	CString buffer = m_strPartMetFileName.Left(m_strPartMetFileName.GetLength() - 4);
	CFileTag* partnametag = new CFileTag(FT_PARTFILENAME, buffer);
d333 1
a333 1
	m_tagArray.Add(partnametag);
d445 1
a445 1
			CTag* newtag = new CFileTag(file);
@


1.571
log
@Faster loading and saving of configuration files.
@
text
@d184 1
a184 1
	m_dwLastPurgeTime = ::GetTickCount();
a219 1
	m_nLastBufferFlushTime = 0;
d229 1
a229 2
	m_timeLastDownTransfer = CTime::GetCurrentTime();
	m_SessionStartTime = m_timeLastDownTransfer;
a235 2
//	We need to initialize this variable to prevent extra screen refreshing
	m_dwLastRefreshedDLDisplayTime = ::GetTickCount();
@


1.570
log
@Several file tag codes changed to be more compatible (UL/DL priorities and category);
Check possible values during parameters loading from known.met and .part.met;
Better way (robust) to process wrong tags.
@
text
@d401 1
a401 1
	CSafeFile file;
d415 1
a415 1
		if (!file.Open(m_strFullName, CFile::modeRead | CFile::shareDenyWrite))
d427 1
a427 2
			if (file.m_hFile != INVALID_HANDLE_VALUE)
				file.Close();
d589 1
a589 2
		if (file.m_hFile != INVALID_HANDLE_VALUE)
			file.Close();
d692 4
a695 2
	if (m_hPartFileWrite.GetLength() < GetFileSize())
		AddGap(m_hPartFileWrite.GetLength(), GetFileSize() - 1);
d698 1
a698 1
	if (m_hPartFileWrite.GetLength() > GetFileSize())
d700 1
a700 1
		TRACE("Partfile \"%s\" is too large! Truncating %I64u bytes.\n", GetFileName(), m_hPartFileWrite.GetLength() - GetFileSize());
@


1.569
log
@Save part file corrupted size and compression gain to .part.met file
(before these values were estimated based on complete and transferred sizes;
Note: for current downloading files these values will be reset);
Don't save some tags with zero values to .part.met files; Variables renaming.
@
text
@d448 2
a449 1
			CFileTag* newtag = new CFileTag(file);
d453 1
a453 2
				{
					if (newtag->GetStringValue().IsEmpty())
d463 4
a466 1
					SetFileName(newtag->GetStringValue());
d468 1
a468 1
				}
d470 2
a471 2
				{
					lastseencomplete = newtag->GetIntValue();
d473 1
a473 1
				}
d475 2
a476 2
				{
					SetFileSize(newtag->GetIntValue());
d478 1
a478 1
				}
d480 2
a481 2
				{
					m_dwBytesTransferred = newtag->GetIntValue();
d483 1
a483 1
				}
d494 5
a498 6
				case FT_PRIORITY:
				{
					priority = newtag->GetIntValue();

					SetAutoPriority(false);
					if (priority == PR_AUTO)
d500 11
a510 2
						SetAutoPriority(true);
						priority = PR_HIGH;
d513 1
a513 1
				}
d515 2
a516 2
				{
					m_bPaused = newtag->GetIntValue();
d518 4
a521 1
				}
d523 1
a523 2
				{
					if ((byte)newtag->GetIntValue() == PR_AUTO)
d525 17
a541 7
						SetAutoULPriority(true);
						SetULPriority(PR_RELEASE);
					}
					else
					{
						SetAutoULPriority(false);
						SetULPriority((byte)newtag->GetIntValue());
d544 4
a547 1
				}
d549 2
a550 2
				{
					m_eCategoryID = static_cast<_EnumCategories>(newtag->GetIntValue());
d552 1
a552 1
				}
d554 2
a555 2
				{
					SetPermissions((byte)newtag->GetIntValue());
d557 1
a557 1
				}
d560 5
a564 2
					if ( (!newtag->GetTagID()) && ( newtag->GetTagName()[0] == FT_GAPSTART ||
					                                     newtag->GetTagName()[0] == FT_GAPEND ) )
d566 3
a568 4
						Gap_Struct * gap;
						CString s = newtag->GetTagName();
						s = s.Right(s.GetLength() - 1);
						uint16 gapkey = _tstoi(s);
d573 2
a574 2
							gap->m_dwStartOffset = -1;
							gap->m_dwEndOffset = -1;
d576 1
a576 1
						if (newtag->GetTagName()[0] == FT_GAPSTART)
d578 1
a578 1
						if (newtag->GetTagName()[0] == FT_GAPEND)
d936 1
a936 1
		tagWr.WriteToFile(FT_PRIORITY, (IsAutoPrioritized()) ? PR_AUTO : priority, file);
d2568 1
a2568 1
	uint32		dwRareFilledRand = 0, dwRarePartCnt = 0, dwRandomPartCnt = 0;
d2595 1
a2595 1
					dwRareFilledRand = dwTmp;
d2683 1
a2683 1
	else if ((dwRarePartCnt != 0) || (dwRareFilledRand != 0))
d2687 1
a2687 1
		if ((dwRareFilledRand != 0) && ((dwRareFilledRand == 1) || (dwRareRank != 1)))
@


1.568
log
@Removed several loadings of .part.dir files on startup;
Removed double loading of .part.settings file on startup;
Optimized tag object destruction.
@
text
@d222 1
a222 1
	m_iGainDueToCompression = 0;
d224 1
a224 1
	m_iSessionGainDueToCompression = 0;
d481 10
a737 4
	if (m_dwCompletedSize > m_dwBytesTransferred)
		m_iGainDueToCompression = m_dwCompletedSize - m_dwBytesTransferred;
	else if (m_dwCompletedSize != m_dwBytesTransferred)
		m_qwLostDueToCorruption = m_dwBytesTransferred - m_dwCompletedSize;
d884 24
a907 4
		tagWr.WriteToFile(FT_TRANSFERRED, m_dwBytesTransferred, file);
		dwTagCount++;
		tagWr.WriteToFile(FT_STATUS, (m_bPaused) ? 1 : 0, file);
		dwTagCount++;
d912 15
a926 6
		tagWr.WriteToFile(FT_LASTSEENCOMPLETE, lastseencomplete.GetTime(), file);
		dwTagCount++;
		tagWr.WriteToFile(FT_CATEGORY, static_cast<uint32>(m_eCategoryID), file);
		dwTagCount++;
		tagWr.WriteToFile(FT_PERMISSIONS, GetPermissions(), file);
		dwTagCount++;
a4424 1
	{
a4425 1
	}
d4427 1
a4427 2
	if (!pFile)
	{
a4428 1
	}
d4538 2
a4539 2
		m_iGainDueToCompression += static_cast<sint64>(iCompressionGain);
		m_iSessionGainDueToCompression += static_cast<sint64>(iCompressionGain);
@


1.567
log
@Optimized parameter tag processing (preparation and parsing).
@
text
@d446 1
a446 1
		for (uint32 j = 0; j != tagcount;j++)
a463 1
					delete newtag;
a468 1
					delete newtag;
a473 1
					delete newtag;
a478 1
					delete newtag;
a483 1
					delete newtag;
d485 1
a490 2
					else
						SetAutoPriority(false);
a495 2
					LoadSettingsFile();
					delete newtag;
a509 1
					delete newtag;
a514 1
					delete newtag;
a519 1
					delete newtag;
a523 1
				//	Start Changes by Slugfiller for better exception handling
a541 2
						delete newtag;
					//	End Changes by Slugfiller for better exception handling
d544 1
d546 2
a547 10
				}

				CStdioFile	f;
				CString		strPath = RemoveFileExtension(m_strFullName);

				strPath += _T(".dir");
				if (f.Open(strPath, CFile::modeRead | CFile::shareDenyWrite | CFile::typeText))
				{
					f.ReadString(m_strAlternativePath);
					f.Close();
d550 1
a550 1

d554 10
a1599 2
	EMULE_TRY

a1600 1
	{
a1601 1
	}
a1602 1
	{
a1603 1
	}
a1604 1
	{
a1605 5
	}

	EMULE_CATCH

	return PS_READY;
@


1.566
log
@More ifdefs for v2
@
text
@a844 1
	uint32 lsc = mktime(lastseencomplete.GetLocalTm());
d879 2
d882 1
a882 4
	//	Make a gap list copy to avoid synchronization object allocation for a long time
		GetGapListCopy(&aGaps);

		uint32 dwTagCount = m_tagArray.GetCount() + 9 + (aGaps.GetCount() * 2);
a883 17
		CFileTag nametag(FT_FILENAME, GetFileName());
		nametag.WriteToFile(file);
		CFileTag sizetag(FT_FILESIZE, GetFileSize());
		sizetag.WriteToFile(file);
		CFileTag transtag(FT_TRANSFERRED, m_dwBytesTransferred);
		transtag.WriteToFile(file);
		CFileTag statustag(FT_STATUS, (m_bPaused) ? 1 : 0);
		statustag.WriteToFile(file);

		CFileTag prioritytag(FT_PRIORITY, (IsAutoPrioritized()) ? PR_AUTO : priority);
		prioritytag.WriteToFile(file);

		CFileTag lsctag(FT_LASTSEENCOMPLETE, lsc);
		lsctag.WriteToFile(file);

		CFileTag ulprioritytag(FT_ULPRIORITY, (IsULAutoPrioritized()) ? PR_AUTO : GetULPriority());
		ulprioritytag.WriteToFile(file);
d885 18
a902 2
		CFileTag categorytag(FT_CATEGORY, static_cast<int>(m_eCategoryID));
		categorytag.WriteToFile(file);
d904 3
a906 2
		CFileTag permtag(FT_PERMISSIONS, GetPermissions());
		permtag.WriteToFile(file);
d908 2
a909 2
		for (uint32 j = 0; j != m_tagArray.GetCount();j++)
			m_tagArray[j]->WriteToFile(file);
d911 1
a911 2
	//	Gaps
		TCHAR	acNameBuffer[16];
d917 1
d920 1
a920 1
			_itot(dwPos++, &acNameBuffer[1], 10);
d922 1
a922 2
			CFileTag gapstarttag(acNameBuffer, pGap->m_dwStartOffset);
			gapstarttag.WriteToFile(file);
d926 1
a926 2
			CFileTag gapendtag(acNameBuffer, pGap->m_dwEndOffset + 1);
			gapendtag.WriteToFile(file);
d928 5
@


1.565
log
@Preparations and minor corrections for new tag processing.
@
text
@d19 7
a25 2
#include "emule.h"
#include "updownclient.h"
d51 1
a51 1

d92 1
d100 1
d118 1
d141 1
d143 1
d151 1
d163 1
d169 1
d171 1
d249 1
d253 1
d302 1
d392 1
d417 1
d420 1
d429 1
d432 1
d438 1
d440 1
d455 1
d459 1
d579 1
d586 1
d595 1
d597 1
d652 1
d654 1
d660 1
d662 1
d726 1
d728 1
d731 1
d735 1
d761 1
d800 1
d831 1
d833 1
d852 1
d854 3
d936 1
d938 1
d1009 1
d1011 1
d1027 1
d1030 1
d1042 1
d1044 1
d1394 1
d1525 1
d1562 1
d1580 1
d1586 1
d1603 1
d1660 1
d1680 1
d1685 1
d2276 1
d2283 1
d2355 1
d2361 1
d2442 1
d2740 1
d2784 1
d2837 1
d3209 1
d3216 1
d3260 1
d3265 1
d3319 1
d3324 1
d3367 1
d3507 1
d3517 1
d3522 1
d3602 1
d3607 1
d3672 1
d3677 1
d3713 1
d3731 1
d3771 1
d3911 1
d3957 1
d3962 1
d4044 1
d4069 1
d4189 1
d4196 1
d4248 1
d4259 1
d4275 1
d4408 1
d4426 1
d4433 1
d4455 3
d4698 1
d4700 1
d4719 1
d4721 1
d4739 1
d4741 1
d4746 1
d4748 1
d4750 1
d4752 1
d4778 1
d4781 1
d4789 1
d4797 1
d4801 1
d4803 1
d4811 1
d4813 1
d4883 1
d4937 1
d4957 1
d5027 1
d5037 1
d5039 1
d5080 1
d5094 1
d5122 1
d5124 1
d5132 1
d5224 1
d5242 1
d5348 1
d5355 1
d5394 3
d5402 1
d5441 3
d5534 1
d5553 1
d5633 1
d5645 1
d5650 1
d5674 1
d5751 1
d5762 1
@


1.564
log
@Reduced number of attempts to save sources (no need to do it so precise).
@
text
@d52 1
a52 1
		switch (searchresult->m_tagArray[i]->GetSpecialTag())
d425 1
a425 1
			switch (newtag->GetSpecialTag())
d510 1
a510 1
					if ( (!newtag->GetSpecialTag()) && ( newtag->GetTagName()[0] == FT_GAPSTART ||
@


1.563
log
@Simplied invalid link report.
@
text
@d2181 1
a2181 1
	//	Call SaveSources() only one time (in case there isn't DL)
d2183 1
a2183 1
		if (dwIteration && g_eMuleApp.m_pGlobPrefs->SLSEnable() && m_downloadingSourceList.IsEmpty() && g_eMuleApp.m_pServerConnect->IsConnected())
@


1.562
log
@Rollback of "Disable 'Preview' if there is no player available (revision 1.555)",
because if player isn't specified in preferences, the default system associated application is used for preview.
@
text
@d107 1
a107 3
		CString buffer;
		buffer.Format(GetResString(IDS_ERR_INVALIDLINK), error.GetBuffer());
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_LINKERROR), buffer);
d157 1
a157 3
		CString buffer;
		buffer.Format(GetResString(IDS_ERR_INVALIDLINK), error.GetBuffer());
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_LINKERROR), buffer);
@


1.561
log
@Disable starting of next download (if enabled) after fakes.rar completion {Prodoc};
Removed useless ShowCatTabInfo setting and all related processing;
Removed double item update in PauseFile; Rollback of some formatting.
@
text
@d3880 2
a3881 2
// 	No preview while completing or hashing or when file is already complete or if there is no player
	if (eFileStatus == PS_COMPLETING || eFileStatus == PS_COMPLETE || eFileStatus == PS_HASHING || g_eMuleApp.m_pGlobPrefs->GetVideoPlayer().IsEmpty())
@


1.560
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@a54 1
			{
d57 1
a57 1
			}
a58 1
			{
d61 1
a61 1
			}
a64 1
			{
d66 1
a66 1
			}
a1411 1
				{
a1412 1
				}
a1414 1
			{
a1415 1
			}
a2496 1
				{
a2507 1
						{
a2508 1
						}
d2511 1
a2511 1
				}
a2512 1
				{
d2516 1
a2516 1
				}
a2517 1
				{
a2519 1
				}
a2520 1
				{
a2522 1
				}
d2581 1
a2581 1
	//		and there's a fresh part with only one source, start downloading of the unique fresh part
d2600 1
a2600 1
//		it doesn't matter which one to download, if there are same filled parts.
d2683 1
a2683 2
	if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfo())
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d2715 1
a2715 2
	if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfo())
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d3068 1
a3068 1
	if (g_eMuleApp.m_pGlobPrefs->DownloadPausedOnComplete())
d3580 1
a3580 1
	SetStatus(m_eStatus);
a3591 2
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();

d5068 1
a5068 1
	if (expirein > 0)
d5613 2
a5614 3
//	If we're displaying file counts in the tabs, update them to reflect status changes
	if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfo())
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
@


1.559
log
@Updated to CFakeCheck
Code refactoring
@
text
@d3596 3
@


1.558
log
@Minor change in tooltips.
@
text
@d67 1
d69 1
d71 5
a75 2
				CFileTag* newtag = new CFileTag(*searchresult->m_tagArray[i]);
				m_tagArray.Add(newtag);
d354 1
a354 1
//	note: the gap should be initialized after parts status vector was filled
d579 1
a579 1
// at this point, the file size was defined. initialize related variables
d581 1
a581 1
	
d588 1
a588 1
		m_PartsStatusVector[i] = PART_VERIFIED;	//AddGap will reset this where required
d607 1
a607 1
//	calculate the size of completed parts
d671 1
a671 1
		}	
d1400 1
a1400 1
				dwGapEnd = dwPartEnd; //the rest is in the next part
d1410 1
a1410 1
						color = crPending;	//downloading part in yellow
d1415 1
d1417 1
d1420 1
d1422 1
d1428 1
a1428 1
			if (dwGapBeg == dwGapEnd) // finished?
d1446 2
a1447 1
		CBarShader s_LoadBar(PROGRESS_HEIGHT, wp, crPending, m_dwCompletedSize);
d1453 3
a1455 3
		uint32	wc = (uint32)(static_cast<double>(m_dwCompletedPartsSize) / GetFileSize() * w + 0.5);
		int	left = rect->left;
		CBrush *pOldBrush;
d1756 1
a1756 1
        
d1996 1
a1996 1
						//	emulates a "Connecting via server..." without request socket timeout
d2074 2
a2075 1
		/*	Producing many lines - so uncomment it only if u want to look into details
d2082 2
a2083 2
				, m_uHighestRemoteQueueRank, uLowestQR, uHighestQR );									
		*/
d2340 1
a2340 1
						//ASSERT(pSource->IsCompleteSource());
d2401 1
a2401 1
	//	AddDebugLogLine(_T("Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2405 4
a2408 4
	const uint32	dwPartCnt = GetPartCount();
	std::vector<uint32> PartsFilledSizeVector(dwPartCnt, NOT_AVAILABLE); // mark parts as not available to save CPU load
	uint32			dwNumAvailableNeededParts = 0;
	uint32			dwNumPartiallyBlockedParts = 0;
d2452 5
a2456 5
	std::vector<uint32>	adwRareParts(dwPartCnt);	// priority 2
	uint32				adwMovieParts[3];			// priority 1 => only first+last parts
	std::vector<uint32>	adwRandomParts(dwPartCnt);	// priority 4
	const uint32	dwPartCnt1 = dwPartCnt - 1, dwLastPartSize = GetLastPartSize();
	const uint32	dwPreviewMode = GetMovieMode();
d2464 1
a2464 1
	const bool bShortestToComplete = (dwNumAvailableNeededParts > dwNumPartiallyBlockedParts);
d2483 1
a2483 1
					if (dwTmp <= dwRareRank)	//select the rarest parts
d2503 2
a2504 1
				case 7:	//	AVI(1F,2L) downloading sequence: chunk 0, last, next to last
d2516 1
d2518 1
d2521 3
a2523 2

				case 5:	//	MPG(2F) downloading sequence: chunk 0, chunk 1
d2527 3
a2529 2

				case 1:	//	AVI(1F,1L) downloading sequence: chunk 0, last chunk
d2532 3
a2534 1
				case 4:	//	MPG(1F)
d2537 1
d2549 1
a2549 1
					if (dwTmp < dwRandomRank)	//select the rarest parts among them
d2589 2
a2590 2
		} while(++i < dwMoviePartsCnt);
	//	AddDebugLogLine(_T("Priority 1 (Preview part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2596 1
a2596 1
	//	and there's a fresh part with only one source, start downloading of the unique fresh part
d2615 1
a2615 1
//	it doesn't matter which one to download, if there are same filled parts.
d2619 1
a2619 1
	//	AddDebugLogLine(_T("Priority 4 (Widespread unfinished part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2629 1
a2629 1
	//	AddDebugLogLine(_T("Priority 5 (Widespread unrequested part). File: %s, Part: %u"), this->GetFileName(), dwGoodPart);
d2798 1
a2798 1
			if(!::DeleteFile(strFakesFile))
d2808 1
a2808 1
				if(!::DeleteFile(strFakesFile))
d3123 3
a3125 3
		CFakecheck* pFakeCheck = g_eMuleApp.m_pFakeCheck;
		CString strFakesDotDatPath = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + _T("fakes.dat");
		CString strBackupFilePath = strFakesDotDatPath + _T(".bak");
d3146 1
a3146 1
		CKnownFile* pThisFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(GetFileHash());
d3489 1
a3489 1
		if (pSource)
d3571 1
a3571 1
		if (pSource)
a3615 1
	{
a3616 1
	}
d3903 2
a3904 2
		if ( (GetFileSize() > 1024) && (GetCompletedSize() > 1024) && !m_bRecoveringArchive &&
			((GetFreeDiskSpaceX(m_strTempDir) + 100000000) > (2 * GetFileSize())) )
d3921 5
a3925 5
		return ( ((eFileStatus == PS_READY) || (eFileStatus == PS_PAUSED) || (eFileStatus == PS_STOPPED))
			&& !m_bPreviewing && (GetPartCount() > 2) && IsMovie() && IsPartComplete(0) &&
			(((bytedwMovieMode != 1) && (bytedwMovieMode != 7)) || IsPartComplete(GetPartCount() - 1)) &&
			((bytedwMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) &&
			((GetFreeDiskSpaceX(m_strTempDir) + 100000000) >= GetFileSize()) );
d3939 1
a3939 1
			if (!(eFileStatus == PS_READY || eFileStatus == PS_EMPTY || eFileStatus == PS_PAUSED || eFileStatus == PS_STOPPED))
d3942 3
a3944 2
			if (!(GetFileType() == ED2KFT_VIDEO || GetFileType() == ED2KFT_AUDIO || GetFileType() == ED2KFT_CDIMAGE))
			{
a3945 1
			}
d3965 4
a3968 4
			return ( ((eFileStatus == PS_READY) || (eFileStatus == PS_PAUSED) || (eFileStatus == PS_STOPPED))
				&& !m_bPreviewing && (GetPartCount() > 2) && IsMovie() && IsPartComplete(0) &&
				(((bytedwMovieMode != 1) && (bytedwMovieMode != 7)) || IsPartComplete(GetPartCount() - 1)) &&
				((bytedwMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) );
d3990 3
a3992 3
	return !( IsPartComplete(0) &&
		(((bytedwMovieMode != 1) && (bytedwMovieMode != 7)) || IsPartComplete(GetPartCount() - 1)) &&
		((bytedwMovieMode != 7) || IsPartComplete(GetPartCount() - 2)) );
d4068 1
a4068 1
						if(pbytePotentialClientPartStatus[i] && !pbyteForClientPartStatus[i])
d4353 2
a4354 1
	static const UINT		s_adwDayResId[] = {
d4391 1
a4391 1
		if ((Mode > 7) || ((Mode & 6) == 2) || (Mode == 6))	//check for valid values 0, 1, 4, 5, 7
d4426 1
a4426 1
//			iCompressionGain - number of bytes saved by compression (it can be negative 
d4499 1
a4499 1
	// Check that all data of the part is received
d4900 1
a4900 1
	
d5077 1
a5077 1
			return CString(_T(""));
d5084 1
a5084 1
	if (expirein != 0)
d5327 5
a5331 5
	const char crProgress = '0'; 	//green
	const char crHave = '1';		// black
	const char crPending = '2';	// yellow
	const char crMissing = '3';  	// red
	static const char crWaiting[6] = { '4', '5', '6', '7', '8', '9'};	// differents blue
d5333 1
a5333 1
	CString my_ChunkBar;
d5336 1
a5336 1
		my_ChunkBar.AppendChar(crHave);	// one more for safety
d5356 3
a5358 3
			Gap_Struct	*pGap = gaplist.GetNext(pos);
			uint32		dwGapBeg = pGap->m_dwStartOffset;
			uint32		dwGapEnd = pGap->m_dwEndOffset + 1;
d5366 1
a5366 1
					dwGapEnd = dwPartEnd; //the rest is in the next part
d5374 1
a5374 1
						color = crPending;	//downloading part in yellow
@


1.557
log
@Enabled shared files view permission settings (all, friends only, noone).
(have been reminded of this forgotten column when I saw it in tooltips :))
@
text
@d5283 1
a5283 1
	strInfo.Format( _T("<t=2><b>%s</b><br><t=2>%s (%u %s)<br><t=2>%d%s (%s / %s) %s<br><hr=100%%><br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s<t></b>%s<br><b>%s:<t></b>%d, %s: %d (%.1f%%)<br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>")
d5285 1
a5285 1
	             GetFileName(), strFileSz, GetFileSize(), GetResString(IDS_BYTES),
@


1.556
log
@Added output folder to Downloadlist tooltips.
Added context menu indicator if alternative destination folder is used.
@
text
@d503 6
d840 1
a840 1
		uint32 dwTagCount = m_tagArray.GetCount() + 8 + (aGaps.GetCount() * 2);
d863 3
@


1.555
log
@Disable 'Preview' if there is no player available.
@
text
@d5274 1
a5274 1
	strInfo.Format( _T("<t=2><b>%s</b><br><t=2>%s (%u %s)<br><t=2>%d%s (%s / %s) %s<br><hr=100%%><br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>%d, %s: %d (%.1f%%)<br><b>%s:<t></b>%s<br><b>%s:<t></b>%s<br><b>%s:<t></b>")
d5281 1
@


1.554
log
@Corrected AVI preview parts request order
(when next to last part was already downloaded or wasn't available).
@
text
@d3870 2
a3871 2
// 	No preview while completing or hashing or when file is already complete
	if (eFileStatus == PS_COMPLETING || eFileStatus == PS_COMPLETE || eFileStatus == PS_HASHING)
@


1.553
log
@Highlight downloading chunks on download file progress bar {DopeFish};
Removed code which became useless.
@
text
@d2433 1
a2433 1
	CList<int>		moviePartsList(3);				// priority 1 => only first+last parts
d2447 1
a2447 1
	uint32		dwMostCompletedRarePartSz = PARTSIZE;
d2484 2
a2485 3
				{
					if (dwPartCnt > 2 && (i == dwPartCnt - 2))
						moviePartsList.AddHead(i);
d2487 10
a2496 3
						moviePartsList.InsertAfter(moviePartsList.GetHeadPosition(), i);
					if (i == 0)
						moviePartsList.AddHead(0);
d2498 1
a2498 1
				}
d2500 2
a2501 5
				{
					if (i == 1 && dwPartCnt > 1)
						moviePartsList.AddHead(1);
					if (i == 0)
						moviePartsList.AddHead(0);
d2503 1
a2503 1
				}
a2504 1
				{
d2506 1
a2506 2
						moviePartsList.AddHead(i);
				}
a2507 1
				{
d2509 1
a2509 2
						moviePartsList.AddHead(0);
				}
d2547 1
a2547 1
	if (!moviePartsList.IsEmpty())
d2550 1
a2550 1
		dwGoodPart = moviePartsList.GetTail();
d2552 1
d2555 1
a2555 1
			dwTmp = moviePartsList.RemoveTail();
d2561 1
a2561 1
		} while(!moviePartsList.IsEmpty());
@


1.552
log
@Removed unused code.
@
text
@a1185 1
					block->m_dwBytesTransferred = 0;
d1394 6
a1399 1
					color = RGB(0, ((210 - 8 * iFreq) < 0) ? 0 : (210 - 8 * iFreq), 255);
a1414 7
//	Yellow pending parts
	for (POSITION pos = requestedblocks_list.GetHeadPosition(); pos != NULL;)
	{
		Requested_Block_Struct * block = requestedblocks_list.GetNext(pos);
		s_ChunkBar.FillRange((block->m_dwStartOffset + block->m_dwBytesTransferred), block->m_dwEndOffset, crPending);
	}

d3521 1
a3521 1
		return ;
d3550 1
a3550 1
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
a4403 1
//			pBlock           - Requested Block corresponding to rx data;
d4408 1
a4408 1
uint32 CPartFile::WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 dwStart, uint32 dwEnd, Requested_Block_Struct *pBlock, int iFlags)
a4469 9
	//	Update the flushed mark on the requested block
	//	The loop here is unfortunate but necessary to detect deleted blocks.
		pos = requestedblocks_list.GetHeadPosition();
		while (pos != NULL)
		{
			if (requestedblocks_list.GetNext(pos) == pBlock)
				pBlock->m_dwBytesTransferred += lenData;
		}

d5344 6
a5349 1
					color = (dwFreq < 10) ? crWaiting[dwFreq / 2] : crWaiting[5];
a5363 7
//	Yellow pending parts
	for (pos = requestedblocks_list.GetHeadPosition();pos != NULL;)
	{
		Requested_Block_Struct * block = requestedblocks_list.GetNext(pos);
		CharFillRange(&my_ChunkBar, static_cast<double>(block->m_dwStartOffset + block->m_dwBytesTransferred) * unit, static_cast<double>(block->m_dwEndOffset) * unit, crPending);
	}

@


1.551
log
@Fixed Preview menu item availablity (it could be disabled when the preview
was possible and it could be enabled when it shouldn't);
Fixed 'Get first/last chunks for preview' menu item processing
(splitting from preview setting as they're not related).
@
text
@d2676 1
a2676 1
	UpdateDisplayedInfo(true);
d2709 1
a2709 1
	UpdateDisplayedInfo(true);
d3037 1
a3037 1
	UpdateDisplayedInfo(true);
d3429 1
a3429 1
	UpdateDisplayedInfo(true);
d3512 1
a3512 1
		UpdateDisplayedInfo(true);
d3573 1
a3573 1
	UpdateDisplayedInfo(true);
d3620 1
a3620 1
	UpdateDisplayedInfo(true);
d4913 1
a4913 2
//	'force' is true or if the redisplay timer has expired.
void CPartFile::UpdateDisplayedInfo(bool bForce)
d5614 1
a5614 1
		UpdateDisplayedInfo(true);
@


1.550
log
@Minor improvement.
@
text
@d3415 1
a3415 1
bool CPartFile::IsArchive(bool onlyPreviewable)
d3417 1
a3417 3
	EMULE_TRY

	if (onlyPreviewable)
a3420 4

	EMULE_CATCH

	return false;
d3826 1
a3826 1
		return ;
d3830 1
a3830 3
	{
		return ;
	}
a3876 2
	uint64 dwSpace = GetFreeDiskSpaceX(m_strTempDir);

d3880 2
a3881 1
		if (GetFileSize() > 1024 && GetCompletedSize() > 1024 && !m_bRecoveringArchive && ((dwSpace + 100000000) > (2 * GetFileSize())))
d3887 9
d3898 5
a3902 3
		return !( (eFileStatus != PS_READY && eFileStatus != PS_PAUSED && eFileStatus != PS_STOPPED)
		          || m_bPreviewing || GetPartCount() < 5 || !IsMovie() || (dwSpace + 100000000) < GetFileSize()
		          || (!IsPartComplete(0) || !IsPartComplete(GetPartCount() - ((GetMovieMode() == 7) ? 2 : 1))) );
d3942 4
a3945 3
			return !( (eFileStatus != PS_READY && eFileStatus != PS_PAUSED && eFileStatus != PS_STOPPED)
			          || m_bPreviewing || GetPartCount() < 2 || !IsMovie()
					  || (!IsPartComplete(0) || !IsPartComplete(GetPartCount() - ((GetMovieMode() == 7) ? 2 : 1))) );
d3954 18
a5749 1
	{
a5750 2
		SaveSettingsFile();
	}
a5765 2

		SaveSettingsFile();
d5767 1
d5842 1
a5842 1
			m_bIsMpgMovie= true;
@


1.549
log
@Fixed collisions caused attempt loss while downloading the same part from several sources
(as a result a download attempt was lost as well as the source became useless for a while).
@
text
@d5670 1
a5670 5
	long a = GetFileSize() % EMBLOCKSIZE;
	if (a == 0)
		a = EMBLOCKSIZE;

	return IsComplete(GetFileSize() - a, GetFileSize() - 1);
@


1.548
log
@Detailed file parts information.
@
text
@d1135 8
a1142 1
bool CPartFile::GetNextEmptyBlockInPart(uint16 uPartNumber, Requested_Block_Struct *pNextEmptyBlock)
d1144 1
a1144 33
	EMULE_TRY

	Gap_Struct	   *pFirstGap = NULL;
	Gap_Struct	   *pCurrentGap = NULL;
	uint32			dwEnd;
	uint32			dwBlockLimit;

//	Find start of this part
	uint32		partStart = (PARTSIZE * uPartNumber);
	uint32		start = partStart;

//	What is the end limit of this block, i.e. can't go outside part (or filesize)
	uint32 partEnd = ((GetFileSize() - partStart) > PARTSIZE) ? (partStart + PARTSIZE - 1) : (GetFileSize() - 1);

	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on exit

//	Loop until find a suitable gap and return true, or no more gaps and return false
	for (;;)
	{
		pFirstGap = NULL;

	//	Find the first gap from the start position
		for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
		{
			pCurrentGap = gaplist.GetNext(pos);
		//	Want gaps that overlap start<->partEnd
			if ((pCurrentGap->m_dwStartOffset <= partEnd) && (pCurrentGap->m_dwEndOffset >= start))
			{
			//	Is this the first gap?
				if ((pFirstGap == NULL) || (pCurrentGap->m_dwStartOffset < pFirstGap->m_dwStartOffset))
					pFirstGap = pCurrentGap;
			}
		}
a1145 52
	//	If no gaps after start, exit
		if (pFirstGap == NULL)
			break;

	//	Update start position if gap starts after current pos
		if (start < pFirstGap->m_dwStartOffset)
			start = pFirstGap->m_dwStartOffset;

	//	If this is not within part, exit
		if (start > partEnd)
			break;

	//	Find end, keeping within the max block size and the part limit
		dwEnd = pFirstGap->m_dwEndOffset;
		dwBlockLimit = partStart + (EMBLOCKSIZE * (((start - partStart) / EMBLOCKSIZE) + 1)) - 1;
		if (dwEnd > dwBlockLimit)
			dwEnd = dwBlockLimit;
		if (dwEnd > partEnd)
			dwEnd = partEnd;

	//	If this gap has not already been requested, we have found a valid entry
		if (!IsAlreadyRequested(start, dwEnd))
		{
		//	Was this block to be returned
			if (pNextEmptyBlock != NULL)
			{
				pNextEmptyBlock->m_dwStartOffset = start;
				pNextEmptyBlock->m_dwEndOffset = dwEnd;
				md4cpy(pNextEmptyBlock->m_fileHash, GetFileHash());
				pNextEmptyBlock->m_dwBytesTransferred = 0;
			}
			return true;
		}
		else
		{
		//	Reposition to end of that gap
			start = dwEnd + 1;
		}

	//	If tried all gaps then break out of the loop
		if (dwEnd == partEnd)
			break;
	}

	EMULE_CATCH

//	No suitable gap found
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::GetGapsInPart(CUpDownClient* pSource, uint16 numPart, Requested_Block_Struct** newblocks, uint16* count)
{
a1151 2
	int newblockcount = 0;

d1168 1
a1168 1
		while (uGapEnd >= uGapStart && newblockcount < *count)
d1178 1
a1178 1
			if (IsAlreadyRequested(startOffset, endOffset) == false)
d1180 8
a1187 6
			//	Create 1 request block
				Requested_Block_Struct * block = new Requested_Block_Struct;
				block->m_dwStartOffset = startOffset;
				block->m_dwEndOffset = endOffset;
				block->m_dwBytesTransferred = 0;
				md4cpy(block->m_fileHash, GetFileHash());
d1189 2
a1190 2
			//	Flag the block as 'requested'
				requestedblocks_list.AddTail(block);
d1192 4
a1195 3
			//	Return the block to the source
				newblocks[newblockcount] = block;
				newblockcount++;
a1198 3
	*count = newblockcount;

	return ;
d1202 1
a1202 1
	*count = 0;
d2382 1
a2382 1
	if ((dwGoodPart != 0xFFFF) && GetNextEmptyBlockInPart(dwGoodPart, NULL))
a2386 1
	pSource->SetLastDownPartAsked(0xFFFF);
a2406 1
	CUpDownClient		*pDownloadingSource;
d2409 1
a2409 5
	EnterCriticalSection(&m_csDownloadingSourceList);
	POSITION	pos = m_downloadingSourceList.GetHeadPosition();
	LeaveCriticalSection(&m_csDownloadingSourceList);

	for (;pos != NULL;)
d2411 1
a2411 3
		EnterCriticalSection(&m_csDownloadingSourceList);
		pDownloadingSource = m_downloadingSourceList.GetNext(pos);
		LeaveCriticalSection(&m_csDownloadingSourceList);
d2413 13
a2425 1
		if (pDownloadingSource && ((dwTmp = pDownloadingSource->GetLastDownPartAsked()) < dwPartCnt))
d2427 4
a2430 17
		//	Let's check if all gaps in part were already requested.
		// 	Note that second parameter is NULL, that should not lead to crash
		// 	due to pointer check in GetNextEmptyBlockInPart
			if (!GetNextEmptyBlockInPart(dwTmp, NULL))
			{
			//	No gaps found => fully blocked
				abyteBlockedParts[dwTmp] = FULLY_BLOCKED;
			}
			else
			{
			//	Count the blocked parts only in case if they are available & was not counted before
				if ((PartsFilledSizeVector[dwTmp] != NOT_AVAILABLE) && (abyteBlockedParts[dwTmp] == FREE_TO_DL))
				{
					dwNumPartiallyBlockedParts++;
				}
				abyteBlockedParts[dwTmp] = PARTIALLY_BLOCKED;
			}
a2622 1
	pSource->SetLastDownPartAsked(dwGoodPart);
@


1.547
log
@changes in part control; hidden & blocked statuses are merged
@
text
@d1102 17
@


1.546
log
@Improved BarShader constructor/destructor.
@
text
@d1543 1
a1543 1
				((GetPartStatus(done) == PR_PART_ON) && IsPartComplete(done)) )
@


1.545
log
@Fixed download file progress bar preparation for GUI and WebServer
(though before the correct progress bar was drawn, the wrong segments were
often generated which after that were overwritten by correct segments);
Faster preparation of download file progress bar for GUI and WebServer.
@
text
@a1398 11
	CBarShader s_ChunkBar(rect->bottom - rect->top, rect->right - rect->left, GetFileSize());

	if (m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING)
	{
		s_ChunkBar.Fill(crProgress);
		s_ChunkBar.Draw(dc, rect->left, rect->top, bFlat);
		m_dblPercentCompleted = 100.0;
		m_dwCompletedSize = GetFileSize();
		return;
	}

d1418 10
a1427 1
	s_ChunkBar.Fill(crHave);
d1493 1
a1493 2
		CBarShader s_LoadBar(PROGRESS_HEIGHT, wp, m_dwCompletedSize);
		s_LoadBar.Fill(crPending);
@


1.544
log
@Corrected progress bar color for inactive files with sources;
More progress bar gradations to better represent the number of sources;
Faster download file progress bar preparation; Improved BarShared constructor.
@
text
@d1442 4
a1445 4
		bool gapdone = false;
		uint32 gapstart = pGap->m_dwStartOffset;
		uint32 gapend = pGap->m_dwEndOffset;
		for (uint32 i = 0; i < GetPartCount(); i++)
d1450 5
a1454 11
			if (gapstart >= dwPartStart && gapstart <= dwPartEnd)
			{ // is in this part?
				if (gapend <= dwPartEnd)
					gapdone = true;
				else
				{
					gapend = dwPartEnd; // and next  part
				}
			//	paint
				COLORREF	color;
				int			iFreq;
d1456 4
a1459 7
				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && ((iFreq = m_srcPartFrequencies[i] - 1) >= 0))
				{
					if (bNotPaused)
						color = RGB(0, ((210 - 8 * iFreq) < 0) ? 0 : (210 - 8 * iFreq), 255);
					else
						color = RGB(100, ((210 - 8 * iFreq) < 0) ? 0 : (255 - 8 * iFreq), 255);
				}
d1461 4
a1464 1
					color = crMissing;
d1466 1
a1466 1
				s_ChunkBar.FillRange(gapstart, gapend + 1, color);
d1468 4
a1471 8
				if (gapdone) // finished?
					break;
				else
				{
					gapstart = gapend;
					gapend = pGap->m_dwEndOffset;
				}
			}
d5367 5
a5371 11
	char crProgress = '0'; 	//green
	char crHave = '1';		// black
	char crPending = '2';	// yellow
	char crMissing = '3';  	// red
	char crWaiting[6]; 		// differents blue
	crWaiting[0] = '4'; 	// blue few source
	crWaiting[1] = '5';
	crWaiting[2] = '6';
	crWaiting[3] = '7';
	crWaiting[4] = '8';
	crWaiting[5] = '9';
d5396 5
a5400 5
			Gap_Struct * cur_gap = gaplist.GetNext(pos);
			bool gapdone = false;
			uint32 gapstart = cur_gap->m_dwStartOffset;
			uint32 gapend = cur_gap->m_dwEndOffset;
			for (uint32 i = 0; i < GetPartCount(); i++)
d5405 10
a5414 14
				if (gapstart >= dwPartStart && gapstart <= dwPartEnd)
				{ // is in this part?
					if (gapend <= dwPartEnd)
						gapdone = true;
					else
					{
						gapend = dwPartEnd; // and next part
					}
				//	paint
					byte color;
					if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && m_srcPartFrequencies[static_cast<uint16>(i)])  // frequency?
						color = m_srcPartFrequencies[static_cast<uint16>(i)] < 10 ? crWaiting[m_srcPartFrequencies[static_cast<uint16>(i)] / 2] : crWaiting[5];
					else
						color = crMissing;
d5416 1
a5416 1
					CharFillRange(&my_ChunkBar, static_cast<double>(gapstart) * unit, static_cast<double>(gapend) * unit + 1, color);
d5418 4
a5421 8
					if (gapdone) // finished?
						break;
					else
					{
						gapstart = gapend;
						gapend = cur_gap->m_dwEndOffset;
					}
				}
d5443 3
a5445 2
	EMULE_TRY
	for (uint32 i = start;i <= dblEnd;i++)
a5446 1
	EMULE_CATCH
@


1.543
log
@Minor drawing speed-ups.
@
text
@d1399 1
a1399 3

	CBarShader s_ChunkBar(rect->bottom - rect->top, rect->right - rect->left);
	s_ChunkBar.SetFileSize(GetFileSize());
d1414 1
d1416 1
a1416 1
	if ((eFileStatus == PS_EMPTY) || (eFileStatus == PS_READY))
d1459 2
a1460 1
				COLORREF color;
d1462 1
a1462 1
				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && m_srcPartFrequencies[static_cast<uint16>(i)])  // frequency?
d1464 2
a1465 4
					if (m_eStatus == PS_EMPTY || m_eStatus == PS_READY)
						color = RGB( 0,
						             (210 - (22 * (m_srcPartFrequencies[(uint16)i] - 1)) < 0) ? 0 : 210 - (22 * (m_srcPartFrequencies[(uint16)i] - 1))
						             , 255 );
d1467 1
a1467 3
						color = RGB( 100,
						             (210 - (22 * (m_srcPartFrequencies[(uint16)i] - 1)) < 0) ? 0 : 255 - (22 * (m_srcPartFrequencies[(uint16)i] - 1))
						             , 255 );
d1505 1
a1505 3
		CBarShader s_LoadBar(PROGRESS_HEIGHT);
		s_LoadBar.SetWidth(wp);
		s_LoadBar.SetFileSize(m_dwCompletedSize);
@


1.542
log
@Improved ICR to better select rare chunks for download and use less resources;
Remove old unused code; Added possible preview values check on settings reading.
@
text
@d1399 14
a1412 3
	COLORREF crHave;
	COLORREF crPending;
	COLORREF crMissing;
a1429 12
	CBarShader s_ChunkBar(rect->bottom - rect->top, rect->right - rect->left);
	s_ChunkBar.SetFileSize(GetFileSize());

	if (m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING)
	{
		s_ChunkBar.Fill(crProgress);
		s_ChunkBar.Draw(dc, rect->left, rect->top, bFlat);
		m_dblPercentCompleted = 100.0;
		m_dwCompletedSize = GetFileSize();
		return;
	}

@


1.541
log
@Removed socket closure after sending cancel as it led to exceptions
(e.i. CClientReqSocket::PacketReceived: Unknown exception. Protocol=...).
@
text
@a269 1
	m_BlockedParts.RemoveAll();
d338 1
a338 1
	const uint32 iPartCount = GetPartCount();
d340 2
a341 3
	m_srcPartFrequencies.SetSize(iPartCount);
	m_BlockedParts.SetSize(iPartCount);
	m_PartsStatusVector.resize(iPartCount);
d343 1
a343 1
	for (uint32 i = 0; i < iPartCount;i++)
a345 1
		m_BlockedParts[i] = 0;
d569 1
a569 1
	const uint32 iPartCount = GetPartCount();
d571 2
a572 3
	m_srcPartFrequencies.SetSize(iPartCount);
	m_BlockedParts.SetSize(iPartCount);
	m_PartsStatusVector.resize(iPartCount);			//m_ReqParts.SetSize(iPartCount);
d574 1
a574 1
	for (uint32 i = 0; i < iPartCount; i++)
a576 1
		m_BlockedParts[i] = 0;
d2453 1
a2453 1
// Intelligent Chunk Request(ICR v2.13, 27.02.2004) for eMule Plus
d2462 3
a2464 15
//	Cache some values => speed improvement
	const int		iPartCount = GetPartCount();
	uint16			nNumAvailableNeededParts = 0;
	uint16			nNumPartiallyBlockedParts = 0;
	const byte		bytePreviewMode = GetMovieMode();
//	Mode 0=NoPreview,1=AVI(1F,1L),2=AVI(1F,1L),3=AVI(3F,1L)
//	Mode 4=MPG(1F),5=MPG(2F),6=MPG(3F),7=AVI/MPG(1F,2L) F=First,L=Last
	byte		   *pbytePartStatuses = pSource->GetPartStatus();
	uint16			nGoodPart = pSource->GetLastDownPartAsked();

	_Bvector		gettingParts;

//	Find out which parts the source currently has pending requests for
	pSource->ShowDownloadingParts(gettingParts);
	if ((nGoodPart != 0xFFFF) && GetNextEmptyBlockInPart(nGoodPart, NULL))
d2466 2
a2467 6
	//	AddDebugLogLine(_T("Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
		return nGoodPart;
	}
	else
	{
		pSource->SetLastDownPartAsked(0xFFFF);
d2469 1
d2471 4
a2474 1
	std::vector<uint32> PartsFilledSizeVector(iPartCount);
d2476 4
a2479 22
//	Construct Lists of block sorted by priority. Use number of parts to create limited lists and
//	keep data in list in same memory area (speed improvements)
//	All lists self-destruct in their destructors on return
//	CList<int>		rarestReqPartsList(iPartCount);	// priority 1 (highest)
	CList<int>		uniquePartsList(iPartCount);	// priority 2
	CList<int>		rarestPartsList(iPartCount);	// priority 4
	CList<int>		moviePartsList(5);				// priority 5 => only first+last parts
//	CList<int>		requestedPartsList(iPartCount);	// priority 6
	CList<int>		randomPartsList(iPartCount);	// priority 7
//----------------------------------------------------
	const uint32			dwLastPartSize = GetLastPartSize();

//	Scan for requested chunks in order to find how much they filled.
	for (int i = 0; i < iPartCount ; i++)
	{
		if (pSource->IsPartAvailable(i) == true)
		{
			PartsFilledSizeVector[i] = GetPartLeftToDLSize(i);
			if (PartsFilledSizeVector[i] != 0)
				nNumAvailableNeededParts++;
		}
		else
d2481 2
a2482 1
			PartsFilledSizeVector[i] = NOT_AVAILABLE; // mark parts as not available to save CPU load
a2483 2
	//	Fill the m_BlockedParts array with NULL
		m_BlockedParts[i] = FREE_TO_DL;
d2485 1
a2485 1
	if (nNumAvailableNeededParts == 0)
d2489 3
a2491 1
	CUpDownClient*		pDownloadingSource;
d2494 1
a2494 1
	POSITION	posHeadList = m_downloadingSourceList.GetHeadPosition();
d2497 1
a2497 1
	for (POSITION pos = posHeadList; pos != NULL;)
d2503 1
a2503 1
		if (pDownloadingSource && pDownloadingSource->GetLastDownPartAsked() < iPartCount)
d2508 1
a2508 1
			if (!GetNextEmptyBlockInPart(pDownloadingSource->GetLastDownPartAsked(), NULL))
d2511 1
a2511 1
				m_BlockedParts[pDownloadingSource->GetLastDownPartAsked()] = FULLY_BLOCKED;
d2516 1
a2516 2
				if (PartsFilledSizeVector[pDownloadingSource->GetLastDownPartAsked()] != NOT_AVAILABLE
					&& m_BlockedParts[pDownloadingSource->GetLastDownPartAsked()] == FREE_TO_DL)
d2518 1
a2518 1
					nNumPartiallyBlockedParts++;
d2520 1
a2520 1
				m_BlockedParts[pDownloadingSource->GetLastDownPartAsked()] = PARTIALLY_BLOCKED;
d2525 8
d2534 2
a2535 4
	uint16		uRarestPart = 4;

//	if (uRarestPart < 4)
//		uRarestPart = 4;
d2538 1
a2538 9
	const bool bShortestToComplete = (nNumAvailableNeededParts > nNumPartiallyBlockedParts);

//	Build lists
	uint16		uMostCompletedUniqueReqPart;
	uint16		uMostCompletedRarestReqPart;
	uint16		uMostCompletedReqPart;
	uint32		dwMostCompletedUniqueReqPart = PARTSIZE;
	uint32		dwMostCompletedRarestReqPart = PARTSIZE;
	uint32		dwRnd, dwMostCompletedReqPart;
d2540 5
a2544 4
	if (bShortestToComplete)
		dwMostCompletedReqPart = PARTSIZE;
	else
		dwMostCompletedReqPart = 0;
d2547 1
a2547 1
	for (int i = 0; i < iPartCount; i++)
d2550 1
a2550 1
		if (PartsFilledSizeVector[i] != NOT_AVAILABLE && m_BlockedParts[i] != FULLY_BLOCKED && PartsFilledSizeVector[i] != 0)
d2552 2
a2553 3
		//	If the part is only available from one source, try to download
		//	it first in order to prevent file disappearing)
			if (m_srcPartFrequencies[i] == 1)
d2555 1
a2555 6
			//	If the part is a full sized part...
				if (PartsFilledSizeVector[i] > (PARTSIZE - EMBLOCKSIZE) || (i == (iPartCount -1) && PartsFilledSizeVector[i] == dwLastPartSize)) // limit change to prevent consecutive download due overlaping
				{
					uniquePartsList.AddHead(i);
				}
				else
d2557 1
a2557 3
				//	If we've completed more of this part (or rather require less to complete it)
				//	than any other one-source part seen so far...
					if (PartsFilledSizeVector[i] < dwMostCompletedUniqueReqPart)
d2559 6
a2564 2
						uMostCompletedUniqueReqPart = i;
						dwMostCompletedUniqueReqPart = PartsFilledSizeVector[i];
d2567 1
a2567 5
			}
		//	------------------------ Rarest Parts -------------------------
			if (uRarestPart >= m_srcPartFrequencies[i])
			{
				if (PartsFilledSizeVector[i] == PARTSIZE || (i == (iPartCount -1) && PartsFilledSizeVector[i] == dwLastPartSize))
d2569 3
a2571 10
					for (int j = 0; j < (uRarestPart - m_srcPartFrequencies[i] + 1); j++)
						rarestPartsList.AddHead(i);
				}
				else
				{
					if (PartsFilledSizeVector[i] < dwMostCompletedRarestReqPart)
					{
						uMostCompletedRarestReqPart = i;
						dwMostCompletedRarestReqPart = PartsFilledSizeVector[i];
					}
d2575 1
a2575 1
			switch (bytePreviewMode)
d2577 1
a2577 1
				case 3:	//	AVI(3F,1L)
d2579 1
a2579 1
					if (iPartCount > 3 && (i == iPartCount - 1))
d2581 1
a2581 19
				}
				case 6:	//	MPG(3F)
				{
					if (i == 2 && iPartCount > 2)
						moviePartsList.AddHead(2);
					if (i == 1 && iPartCount > 1)
						moviePartsList.AddHead(1);
					if (i == 0)
						moviePartsList.AddHead(0);
					break;
				}
				case 7:	//	AVI/MPG(1F,2L) downloading sequence: chunk 0, last, next to last
				{
					if (iPartCount > 2 && (i == iPartCount - 2))
						moviePartsList.AddHead(i);
				}
				case 2:	//	AVI(1F,1L)
				{
					if (iPartCount > 2 && (i == iPartCount - 1))
d2589 1
a2589 1
					if (i == 1 && iPartCount > 1)
d2597 1
a2597 1
					if (iPartCount > 1 && (i == iPartCount - 1))
d2607 2
a2608 3
		//	Check blocked parts
			if (m_BlockedParts[i] == PARTIALLY_BLOCKED && nNumAvailableNeededParts > nNumPartiallyBlockedParts)
			{
d2610 2
a2611 2
			}
			if (PartsFilledSizeVector[i] == PARTSIZE || (i == (iPartCount -1) && PartsFilledSizeVector[i] == dwLastPartSize))
d2613 10
a2622 3
			//	Unstarted
				for (int j = 0; j < (m_MaxSrcPartFrequency - m_srcPartFrequencies[i] + 1); j++)
					randomPartsList.AddHead(i);
d2626 4
a2629 3
				bool bCodition;
			//	Invert condition shortest-to-complete condition if all parts are partially blocked
				if (bShortestToComplete)
d2631 2
a2632 10
					bCodition = (PartsFilledSizeVector[i] < dwMostCompletedReqPart);
				}
				else
				{
					bCodition = (PartsFilledSizeVector[i] > dwMostCompletedReqPart);
				}
				if (bCodition)
				{
					uMostCompletedReqPart	= i;
					dwMostCompletedReqPart = PartsFilledSizeVector[i];
d2644 4
a2647 16
		nGoodPart = moviePartsList.GetTail();
	//	AddDebugLogLine(_T("Priority 1 (Preview part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
	}
//	------------------------------ Unique & Requested --------------------------------------------------
//	Try to complete a UniquePart and MostDownloaded as soon as possible to become a new source
//	it doesn't matter which one download, if there are parts same filled.
	else if (dwMostCompletedUniqueReqPart != PARTSIZE)
	{
		nGoodPart = uMostCompletedUniqueReqPart;
	//	AddDebugLogLine(_T("Priority 2 (Unique unfinished part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
	}
//	------------------------------ Unique & Unrequested ------------------------------------------------
	else if (!uniquePartsList.IsEmpty())
	{
	//	If there is only one unique part, then take it, otherwise take it random.
		if (uniquePartsList.GetCount() == 1)
d2649 8
a2656 9
			nGoodPart = uniquePartsList.GetHead();
		}
		else
		{
			dwRnd = static_cast<uint32>(rand() * (uniquePartsList.GetCount() - 1) + RAND_MAX / 2) / RAND_MAX;

			nGoodPart = uniquePartsList.GetAt(uniquePartsList.FindIndex(dwRnd));
		}
	//	AddDebugLogLine(_T("Priority 3 (Unique unrequested part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2658 2
a2659 4
//	------------------------------ Rarest & Requested --------------------------------------------------
//	Try to complete a RarestPart and MostDownloaded as soon as possible to become a new source
//	it doesn't matter which one download, if there are parts same filled.
	else if (dwMostCompletedRarestReqPart != PARTSIZE)
d2661 3
a2663 8
		nGoodPart = uMostCompletedRarestReqPart;
	//	AddDebugLogLine(_T("Priority 4 (Rarest unfinished part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
	}
//	------------------------------ Rarest & Unrequested ------------------------------------------------
	else if (rarestPartsList.IsEmpty() == false)
	{
	//	If there is only one rarest part, then take it, otherwise take it random.
		if (rarestPartsList.GetCount() == 1)
d2665 2
a2666 1
			nGoodPart = rarestPartsList.GetHead();
d2670 7
a2676 3
			dwRnd = static_cast<uint32>(rand() * (rarestPartsList.GetCount() - 1) + RAND_MAX / 2) / RAND_MAX;

			nGoodPart = rarestPartsList.GetAt(rarestPartsList.FindIndex(dwRnd));
a2677 1
	//	AddDebugLogLine(_T("Priority 5 (Rarest unrequested part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2681 2
a2682 2
//	it doesn't matter which one download, if there are parts same filled.
	else if (dwMostCompletedReqPart != PARTSIZE &&  dwMostCompletedReqPart != 0)
d2684 2
a2685 2
		nGoodPart = uMostCompletedReqPart;
	//	AddDebugLogLine(_T("Priority 6 (Widespread unfinished part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2688 1
a2688 1
	else if (!randomPartsList.IsEmpty())
d2690 6
a2695 4
		dwRnd = static_cast<uint32>(rand() * (randomPartsList.GetCount() - 1) + RAND_MAX / 2) / RAND_MAX;

		nGoodPart = randomPartsList.GetAt(randomPartsList.FindIndex(dwRnd));
	//	AddDebugLogLine(_T("Priority 7 (Widespread unrequested part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2699 1
a2699 1
		nGoodPart = 0xFFFF;
d2706 2
a2707 2
						GetFileName(), nNumAvailableNeededParts, nNumPartiallyBlockedParts, nGoodPart);
	if (nGoodPart < iPartCount)
d2709 1
a2709 1
		strDebug.AppendFormat(_T(", P-Freq: %u, blocked %s"), m_srcPartFrequencies[static_cast<uint32>(nGoodPart)], ((m_BlockedParts[static_cast<uint32>(nGoodPart)] == PARTIALLY_BLOCKED)? _T("yes"):_T("no")));
d2714 2
a2715 2
	pSource->SetLastDownPartAsked(nGoodPart);
	return nGoodPart;
d4437 3
d4897 5
a4901 4
	uint16 count = 0;
	for (int i = 0;i < SOURCESSLOTS;i++)
		count += m_srcLists[i].GetCount();
	return count;
@


1.540
log
@improved socket usage (centralized cancel of the transfer)
@
text
@d3648 1
a3648 1
			pSource->SendCancelTransfer(true);
d3730 1
a3730 1
			pSource->SendCancelTransfer(true);
@


1.539
log
@Renamed string IDS_INFLST_FILE_LASTSEENCOMPLETE -> IDS_LASTSEENCOMPLETE.
@
text
@a3635 2
	Packet* packet = new Packet(OP_CANCELTRANSFER);

d3648 1
a3648 2
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
			pSource->m_pRequestSocket->SendPacket(packet, false, true);
a3652 1
	delete packet;
a3709 1
	Packet* packet = new Packet(OP_CANCELTRANSFER);
a3727 1
#ifdef OLD_SOCKETS_ENABLED
d3730 1
a3730 2
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
			pSource->m_pRequestSocket->SendPacket(packet, false, true);
a3732 1
#endif //OLD_SOCKETS_ENABLED
a3749 1
	delete packet;
@


1.538
log
@Don't write unrequired search tags to .part.met file.
@
text
@d5456 1
a5456 1
	             GetResString(IDS_INFLST_FILE_LASTSEENCOMPLETE), strLastSeenComplete,
@


1.537
log
@Changed the way we use backup files for .part.met (more user friendly)
Removed old code not needed.
@
text
@d64 4
d69 2
a70 2
			CFileTag* newtag = new CFileTag(*searchresult->m_tagArray[i]);
			m_tagArray.Add(newtag);
@


1.536
log
@Fixed rehashing on Daylight Saving Time change (official).
@
text
@a613 6
//	Check if this is a backup
	if (m_strFullName.Right(7).CompareNoCase(_T(".backup")) == 0)
	{
		m_strFullName.Truncate(m_strFullName.GetLength() - 7);
	}

d718 45
@


1.535
log
@Unified GUI strings for "file hash" (removed duplicate,
new full form is "File Hash" instead of "FileID").
@
text
@d689 5
a693 1
	if (m_timetLastWriteDate != mktime(filestatus.m_mtime.GetLocalTm()))
d758 2
a759 1
	m_timetLastWriteDate = mktime(lwtime.GetLocalTm());
d3127 1
d3129 2
@


1.534
log
@Fixed auto-assignment issue to category (represented by temporary directory for category).
@
text
@d5358 1
a5358 1
	strInfo.Format( _T("%s (%s)\n\n%s: %s\n\n%s %s\n") + GetResString(IDS_PARTINFOS),
d5361 1
a5361 1
	             GetResString(IDS_FD_HASH), HashToString(GetFileHash()),
d5402 1
a5402 1
	             GetResString(IDS_INFLST_FILE_HASH), HashToString(GetFileHash()),
@


1.533
log
@Corrected error report.
@
text
@d124 1
a124 2
	//	m_strFileName = CString(fileLink->GetName());
		SetFileName(CString(fileLink->GetName()));
d3554 1
a3554 1
void CPartFile::SetPriority(byte np)
d3558 1
a3558 1
	priority = np;
d3561 2
a3562 1
	SavePartFile();
d5695 1
a5695 1
				SetPriority(PR_LOW);
d5701 1
a5701 1
				SetPriority(PR_NORMAL);
d5707 1
a5707 1
				SetPriority(PR_HIGH);
d5713 1
a5713 1
				SetPriority(PR_HIGH);
@


1.532
log
@Minor improvements.
@
text
@d622 3
a624 2
	CString searchpath = m_strFullName.Left(m_strFullName.GetLength() - 4);
	if (!m_hPartFileWrite.Open(searchpath, CFile::modeWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
d626 1
a626 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), m_strFullName, m_strFileName);
d629 1
a629 1
	if (!m_hPartFileRead.Open(searchpath, CFile::modeRead | CFile::shareDenyNone | CFile::osSequentialScan))
d632 1
a632 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEOPEN), m_strFullName, m_strFileName);
d635 1
a635 1
	SetFilePath(searchpath);
@


1.531
log
@Changed the way we decide to save part.met on SetCatID call
@
text
@d17 1
a17 1
#include "StdAfx.h"
d288 1
a288 1
	if (GetCatID() != 0)
d291 1
a291 1
		if (strCatTempDir != "")
d5717 1
a5717 1
		if (IsPartFile() && m_strTempDir != _T(""))
@


1.530
log
@More fixes for temp_dir_cat
@
text
@d77 1
a77 1
		SetCatID(eCatID, true);
d144 1
a144 1
				SetCatID(eCatID, true);
d5672 1
a5672 1
void CPartFile::SetCatID(EnumCategories eCatID, bool bNoSave /*FALSE*/)
d5717 1
a5717 1
		if (IsPartFile() && !bNoSave)
@


1.529
log
@Customizable temporary directory for categories
@
text
@d73 1
a73 1
//	Set Category
d77 1
a77 1
		SetCatID(eCatID);
d140 1
a140 1
		//	Set Category
d144 1
a144 1
				SetCatID(eCatID);
d5672 1
a5672 1
void CPartFile::SetCatID(EnumCategories eCatID)
d5717 1
a5717 1
		if (IsPartFile())
@


1.528
log
@Fixed delayed download rate control.
@
text
@d43 1
a43 1
CPartFile::CPartFile(CSearchFile* searchresult)
d72 7
d84 1
a84 1
CPartFile::CPartFile(CString edonkeylink)
d96 1
a96 1
		InitializeFromLink(pFileLink);
d111 1
a111 1
CPartFile::CPartFile(CED2KFileLink* fileLink)
d113 1
a113 1
	InitializeFromLink(fileLink);
d116 1
a116 1
void CPartFile::InitializeFromLink(CED2KFileLink* fileLink)
d139 7
d147 1
d288 7
@


1.527
log
@Unified way to display label for part and complete files.
@
text
@d1668 1
a1668 1
	uint16	uNumTransferringSrcs = 0;
d1701 1
a1701 1
				uNumTransferringSrcs++;
d1705 2
d1784 1
a1784 1
							uNumTransferringSrcs++;
d2104 1
a2104 1
		m_iNumTransferringSrcs = uNumTransferringSrcs;
d2640 1
a2640 1
//	The preview parts have highest priority in oder to provide the user information about the file as soon as possible
@


1.526
log
@Faster file tooltips preparation.
@
text
@d5333 2
a5334 2
	strInfo.Format( _T("%s: %s (%s)\n\n%s: %s\n\n%s %s\n") + GetResString(IDS_PARTINFOS),
							 GetResString(IDS_DL_FILENAME), GetFileName(), strFileSz,
d5337 1
a5337 1
	             ConcatFullPath(GetTempDir(),GetPartMetFileName()),
d5378 1
a5378 1
				 GetResString(IDS_TT_PARTINFOS), ConcatFullPath(GetTempDir(), GetPartMetFileName()),
@


1.525
log
@Fixed directory creating [reported by Cheesy].
@
text
@d5310 1
a5310 1
	CString strInfo, strCompletedSize, strLastSeenComplete, strLastProgress, strTimeLeft;
a5312 2
	strCompletedSize.Format(_T("%s/%s"), CastItoXBytes(GetCompletedSize()), CastItoXBytes(GetFileSize()));

d5333 5
a5337 8
	strInfo.Format( GetResString(IDS_DL_FILENAME) + _T(": %s (%s)\n\n%s\n\n")
	             + GetResString(IDS_FD_HASH) + _T(" %s\n")
	             + GetResString(IDS_PARTINFOS)
	             + GetResString(IDS_PARTINFOS2) + _T("\n%s\n%s\n%s\n")
	             + GetResString(IDS_PARTINFOS3),
	             GetFileName(), CastItoXBytes(GetFileSize()),
	             GetResString(IDS_STATUS) + _T(": ") + GetPartFileStatus(),
	             HashToString(GetFileHash()), ConcatFullPath(GetTempDir(),GetPartMetFileName()),
d5339 7
a5345 9
	             static_cast<int>(GetPercentCompleted()), strCompletedSize, GetTransferringSrcCount(),
	             GetResString(IDS_LASTSEENCOMPL) + _T(" ") + strLastSeenComplete,
	             GetResString(IDS_FD_LASTCHANGE) + _T(" ") + strLastProgress,
				 GetResString(IDS_DLCOL_REMAININGTIME) + _T(": ") + strTimeLeft,
	             GetOnQueueSrcCount(),
	             GetQueueFullSrcCount(),
	             GetNoNeededPartsSrcCount(),
	             GetSrcA4AFCount(),
	             GetConnectingSrcCount() );
d5373 1
a5373 1
	             + GetResString(IDS_TT_STATUS2) + _T("<br><b>") + GetResString(IDS_SIZE_ON_DISK) + _T(":<t></b>%s"),
d5387 1
a5387 1
                 CastItoXBytes(GetRealFileSize()));
@


1.524
log
@Reduced system load caused by recovery of uncompressed RX stream
(unfortunately it increased amount of additional redownloaded data by I.C.H).
@
text
@d2900 2
a2901 2
	if (!PathFileExists(strOutputDir))
		::CreateDirectory(strOutputDir, 0);
@


1.523
log
@corrected source swap by file deletion & fixed competion hang up
@
text
@d4485 13
a4497 18
// Replaces BlockReceived()
//
// Originally this only wrote to disk when a full 180k block
// had been received from a client, and only asked for data in
// 180k blocks.
//
// This meant that on average 90k was lost for every connection
// to a client data source. That is a lot of wasted data.
//
// To reduce the lost data, packets are now written to a buffer
// and flushed to disk regularly regardless of size downloaded.
// This doesn't include compressed packets.
//
// Data is also requested only where gaps are, not in 180k blocks.
// The requests will still not exceed 180k, but may be smaller to
// fill a gap.
//
uint32 CPartFile::WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 dwStart, uint32 dwEnd, Requested_Block_Struct *pBlock, bool bFreeBuff)
d4524 1
a4524 1
		if (!bFreeBuff)
d4576 1
a4576 1
		else if (IsCorruptedPart(dwPartNum))
d4579 1
d4591 1
a4591 1
	if (bFreeBuff)
@


1.522
log
@final (at least i hope so) optimization for processing of file extension
@
text
@d3253 1
a3253 1
				if (!pRemoveSource->SwapToAnotherFile(NULL,true))
@


1.521
log
@Fixed several issues processing files with size = 0 modulo PARTSIZE
(processing file corruption, jumpstart, statistics, etc.);
Better chunk downloading order for 'Get first/last chunks for preview'
(order is changed to download the most informative parts first;
new sequences AVI: 0,Last; AVI: 0,Last,NextToLast; MPG: 0; MPG: 0,1);
Additional extra chunk was download while 'Get first/last chunks for preview'
(in case when next to last part was required for AVI,
part 1 was also downloaded by this feature in addition to part 0, next to last and last).
@
text
@d224 6
a3389 45
bool CPartFile::IsMovie()
{
	return (ED2KFT_VIDEO == GetFileType() || GetFileExtension() == _T("bin"));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsAviMovie()
{
	static const TCHAR s_apcExt[][5] =
	{
		_T("avi"), _T("ogm"), _T("mkv"), _T("wmv"), _T("divx"), _T("xvid")
	};
	CString	strExt = GetFileExtension();
	bool	bFound = false;

	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcExt[ui])) == 0)
		{
			bFound = true;
			break;
		}
	}
	return bFound;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CPartFile::IsMpgMovie()
{
	static const TCHAR s_apcExt[][5] =
	{
		_T("mpg"), _T("mpeg"), _T("vob"), _T("bin"), _T("mpe"), _T("dat")
	};
	CString	strExt = GetFileExtension();
	bool	bFound = false;

	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_apcExt); ui++)
	{
		if (strExt.Compare(reinterpret_cast<const TCHAR*>(&s_apcExt[ui])) == 0)
		{
			bFound = true;
			break;
		}
	}
	return bFound;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3521 1
a3521 1
		return (GetFileExtension() == _T("rar") || GetFileExtension() == _T("zip") );
d4032 1
a4032 5
			CString	strExt = GetFileExtension();
			bool	bMPEG =
				!strExt.IsEmpty() && (IsMpgMovie() || (strExt == _T("mp3")) || (strExt == _T("mp2")) || (strExt == _T("mpa")));

			if (bMPEG)
d5904 71
@


1.520
log
@simplified code and removed some unneeded checks, added dynamic droplimit, added not to drop queuefull until asked twice, added preferences option with import of old ini parameter
@
text
@d2394 1
a2394 1
//	Mode 0=NoPreview,1=AVI(1F,1L),2=AVI(2F,1L),3=AVI(3F,1L)
d2425 1
a2425 1
	const uint32			dwLastPartSize = GetFileSize() - ((iPartCount -1)*PARTSIZE);
d2550 1
a2550 1
				case 3:	//	3 = AVI(3F,1L)
d2555 1
a2555 1
				case 6:	//	6 = MPG(3F)
d2565 1
a2565 1
				case 7:	//	7 = AVI/MPG(1F,2L)
d2570 1
a2570 1
				case 2:	//	2 = AVI(2F,1L)
d2573 4
a2576 1
						moviePartsList.AddHead(i);
d2578 1
a2578 1
				case 5:	//	5 = MPG(2F)
d2586 1
a2586 1
				case 1:	//	1 = AVI(1F,1L)
d2591 1
a2591 1
				case 4:	//	4 = MPG(1F)
d2636 1
a2636 1
		nGoodPart = moviePartsList.GetHead();
d4713 1
a4713 1
		uint32	partRange = (GetFileSize() % PARTSIZE) - 1;
d5914 1
a5914 6
			int iPartCount = GetPartCount();

			if(GetPartSize(iPartCount-1) < (GetFileSize()*0.01))
				SetMovieMode(7);
			else
				SetMovieMode(1);
@


1.519
log
@reverted changes
@
text
@d1724 18
a1741 8
	//	Dont drop sources if sourcecount is lower than 90% (formerly 80%) of max. sources per file
		uint16	uDropLimit = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * 0.9;
	//	In case of timeout ALL sources are dropped without restrictions by uDropLimit or PURGE_TIME.
	//	Otherwise maximal PURGE_MAXCOUNT sources are dropped.
	//	Preferred droppingorder by state (max dropcount) is: TimeOut (all), Low2Low (5), NNP (3), QueueFull (3), HighQR (1).
	//	Formerly the state of the dropped source was rather random depending on whichever match came first in the lists.
	//	Formerly ALL HighQR sources could be dropped without restrictions by uDropLimit or PURGE_TIME.
	//	Formerly the sources were counted although they could get dropped. Now only undropped sources are counted.
a1744 1
		uint16	uDroppedTimeout = 0;
a1829 2
								uDroppedTotal++;
								uDroppedTimeout++;
d1842 2
a1843 3
							if (uDroppedTotal < PURGE_MAXCOUNT
								&& (dwCurTick - m_dwLastPurgeTime) > PURGE_TIME )
							//	Prefere to drop these Low2Low before all other without uDropLimit
a1848 3
							//	Allow to drop upto 5 sources
								if (uDroppedLowToLowID > 4)
									m_dwLastPurgeTime = dwCurTick;
d1866 1
a1866 3
							if (uDroppedTotal < PURGE_MAXCOUNT
								&& uSourceNumber > uDropLimit
								&& (dwCurTick - m_dwLastPurgeTime) > PURGE_TIME
a1875 3
								//	Allow to drop upto 3 sources
									if (uDroppedNNP > 2)
										m_dwLastPurgeTime = dwCurTick;
d1899 1
a1899 3
								if (uDroppedTotal < PURGE_MAXCOUNT
									&& uSourceNumber > uDropLimit
									&& (dwCurTick - m_dwLastPurgeTime) > PURGE_TIME
d1902 3
a1904 1
									&& m_iSrcNNP == uDroppedNNP )
a1909 3
								//	Allow to drop upto 3 sources
									if (uDroppedQueueFull > 2)
										m_dwLastPurgeTime = dwCurTick;
d1921 1
a1921 2
								if (g_eMuleApp.m_pGlobPrefs->UseRemoteQueueLimit()
									&& (uQueueRank > g_eMuleApp.m_pGlobPrefs->GetRemoteQueueLimit()) )
d1923 3
a1925 4
									if (uDroppedTotal < PURGE_MAXCOUNT
										&& uSourceNumber > uDropLimit
										&& (dwCurTick - m_dwLastPurgeTime) > PURGE_TIME
									//	Prefere to drop Low2Low and NNP and QueueFull before HighQR
d1928 2
a1929 3
										&& m_iSrcQueueFull == uDroppedQueueFull
									//	Drop the source with worst QR only (or in the *~impossible* case when the worst QR is unknown)
										&& (uQueueRank == m_uHighestRemoteQueueRank || m_uHighestRemoteQueueRank == 0) )
a1934 2
									//	Drop only 1 source (dont change that!)
										m_dwLastPurgeTime = dwCurTick;
d1945 2
a1946 2
										uOnQueueSrcCount++;
										bAlreadyCounted = true;
d1955 1
a1955 1
									if (uQueueRank > 250)
d2068 1
a2068 1
			AddDebugLogLine( RGB_LOG_DIMMED + _T("Dropped %u/%u sources from file '%s': %u/%u TO, %u/%u L2L, %u/%u NNP, %u/%u QF, %u/%u HQR (%u < QR < %u)")
a2069 1
				, uDroppedTimeout, uTimeoutSrcCount	//special case where dropped sources are counted
d2074 1
a2074 1
				, uLowestQR, uHighestQR );									
d2242 2
a2243 2
	if ( iSourceCountPlusNew > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() &&
		 (m_dwLastPurgeTime == 0 || (::GetTickCount() - m_dwLastPurgeTime > PURGE_TIME)) )
@


1.518
log
@correction in ICR (priview chunks have highest prio); fix for hang up during file completion
@
text
@d894 7
a900 1
		AddLogLine(false, IDS_HASHINGDONE, GetFileName());
@


1.517
log
@fixed switching between limited & limitless DL; improved bandwidth control for limited DL; fixed request of hashset
@
text
@d891 1
d894 1
a894 7
		if (m_eStatus == PS_COMPLETING)
		{
			CompleteFile(true);
			return;
		}
		else
			AddLogLine(false, IDS_HASHINGDONE, GetFileName());
d2633 8
d2644 1
a2644 1
	if (dwMostCompletedUniqueReqPart != PARTSIZE && moviePartsList.IsEmpty())
d2647 1
a2647 1
	//	AddDebugLogLine(_T("Priority 1 (Unique unfinished part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2650 1
a2650 1
	else if (!uniquePartsList.IsEmpty() && moviePartsList.IsEmpty())
d2663 1
a2663 1
	//	AddDebugLogLine(_T("Priority 2 (Unique unrequested part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2671 1
a2671 1
	//	AddDebugLogLine(_T("Priority 3 (Rarest unfinished part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
d2687 1
a2687 7
	//	AddDebugLogLine(_T("Priority 4 (Rarest unrequested part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
	}
//	---------------------------------- Movies Part  -----------------------------------------------------
	else if (!moviePartsList.IsEmpty())
	{
		nGoodPart = moviePartsList.GetHead();
	//	AddDebugLogLine(_T("Priority 5 (Preview part). File: %s, Part : %u"), this->GetFileName(), nGoodPart);
@


1.516
log
@Fixed very rare possibility to upload and report unverified chunks;
Fixed complete size calculation;
Fixed rare problems appeared as side effect after new part status algorithm
in case FileSize % PARTSIZE = 0;
Optimization of the new part status processing;
Improved 'file extension optimization' as it was even slower then before;
Removed unused code.
@
text
@a196 1
	m_nSavedReduceDownload = 0;
d1687 1
a1687 1
				dwCurrentDataRate = pSource->CalculateDownloadRate();
a1695 20
				if (dwReduceDownload)
				{
					uint32 limit = dwReduceDownload * dwCurrentDataRate / 1000;
					if (limit < 1000 && dwReduceDownload == 200)
						limit += 1000;
					else if (limit < 1)
						limit = 1;
#ifdef OLD_SOCKETS_ENABLED

					pSource->m_pRequestSocket->SetDownloadLimit(limit);
#endif OLD_SOCKETS_ENABLED
				}
#ifdef OLD_SOCKETS_ENABLED
				else if (m_nSavedReduceDownload != dwReduceDownload)
				{
					pSource->m_pRequestSocket->DisableDownloadLimit();
				}
#endif OLD_SOCKETS_ENABLED

				m_nSavedReduceDownload = dwReduceDownload;
d1760 1
a1760 1
							dwCurrentDataRate = pSource->CalculateDownloadRate();
a1767 19
							if (dwReduceDownload)
							{
								uint32	dwLimit = dwReduceDownload * dwCurrentDataRate / 1000;
								if (dwLimit < 1000 && dwReduceDownload == 200)
									dwLimit += 1000;
								else if (dwLimit < 1)
									dwLimit = 1;
#ifdef OLD_SOCKETS_ENABLED

								pSource->m_pRequestSocket->SetDownloadLimit(dwLimit);
#endif //OLD_SOCKETS_ENABLED

							}
#ifdef OLD_SOCKETS_ENABLED
							else if (m_nSavedReduceDownload != dwReduceDownload)
								pSource->m_pRequestSocket->DisableDownloadLimit();
#endif //OLD_SOCKETS_ENABLED

							m_nSavedReduceDownload = dwReduceDownload;
@


1.515
log
@logline correction - now im really done
@
text
@d319 1
a319 4
		if (i < (iPartCount -1))
			m_PartsStatusVector[i] = PARTSIZE;
		else
			m_PartsStatusVector[i] = GetFileSize() - i*PARTSIZE;
d552 1
a552 5
		//m_PartsFiledSizeVector[i] = RECALCULATION_REQUIRED;		//m_ReqParts[i] = 0;
		if (i < (iPartCount -1))
			m_PartsStatusVector[i] = PARTSIZE;
		else
			m_PartsStatusVector[i] = GetFileSize() - i*PARTSIZE;
a869 1
	uint32 dwHashSize = static_cast<uint32>(m_partHashArray.GetSize());
d871 6
a876 1
	for (uint32 i = 0; i < dwHashSize; i++)
d884 1
a884 1
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_FOUNDCORRUPTION), i + 1, GetFileName());
d931 2
a932 5
			m_dwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
			for (uint32 i = (cur_gap->m_dwStartOffset/PARTSIZE); i <= (cur_gap->m_dwEndOffset/PARTSIZE); i++)
			{
				FillGapInParts(i, cur_gap->m_dwStartOffset, cur_gap->m_dwEndOffset);
			}
d939 2
a940 5
			m_dwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
			for (uint32 i = (cur_gap->m_dwStartOffset/PARTSIZE); i <= (cur_gap->m_dwEndOffset/PARTSIZE); i++)
			{
				FillGapInParts(i, cur_gap->m_dwStartOffset, cur_gap->m_dwEndOffset);
			}
d947 2
a948 5
			m_dwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
			for (uint32 i = (cur_gap->m_dwStartOffset/PARTSIZE); i <= (cur_gap->m_dwEndOffset/PARTSIZE); i++)
			{
				FillGapInParts(i, cur_gap->m_dwStartOffset, cur_gap->m_dwEndOffset);
			}
d959 3
a961 5
	m_dwGapsSum += dwEnd - dwStart;
	for (uint32 i = (dwStart/PARTSIZE); i <= (dwEnd/PARTSIZE); i++)
	{
		AddGapToParts(i, dwStart, dwEnd);
	}
a962 1
	gaplist.AddTail(new_gap);
d1003 2
a1004 2
//	IsPartComplete() returns true if a part is complete.
bool CPartFile::IsPartComplete(uint32 dwPart)
d1006 1
a1006 11
	uint32 dwStart = dwPart * PARTSIZE;
	uint32 dwEnd = ((GetFileSize() - dwStart) > PARTSIZE) ? (dwStart + PARTSIZE - 1) : (GetFileSize() - 1);

	//return IsComplete(dwStart, dwEnd);
/*
	bool bICRes = IsComplete(dwStart, dwEnd);
	uint32 dwPartSize = GetPartFilledSize(dwPart);
	bool bGBPRes = (dwPartSize == (dwEnd - dwStart + 1));
	ASSERT( bICRes == bGBPRes);
*/
	return (GetPartFilledSize(dwPart) == (dwEnd - dwStart + 1));
d1009 1
a1009 1
//	IsPartComplete() returns true if a part is complete.
d1014 1
a1014 1
bool CPartFile::IsPartComplete(uint32 dwPart, uint32 *pdwStart, uint32 *pdwEnd)
d1022 7
a1028 8
	//return IsComplete(dwStart, dwEnd);
/*
	bool bICRes = IsComplete(dwStart, dwEnd);
	uint32 dwPartSize = GetPartFilledSize(dwPart);
	bool bGBPRes = (dwPartSize == (dwEnd - dwStart + 1));
	ASSERT( bICRes == bGBPRes);
*/
	return (GetPartFilledSize(dwPart) == (dwEnd - dwStart + 1));
d1208 1
a1208 1
		{ // our part fills this gap completly
d1210 2
a1211 5
			m_dwGapsSum -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
			for (uint32 i = (cur_gap->m_dwStartOffset/PARTSIZE); i <= (cur_gap->m_dwEndOffset/PARTSIZE); i++)
			{
				FillGapInParts(i, cur_gap->m_dwStartOffset, cur_gap->m_dwEndOffset);
			}
d1216 2
a1217 5
			m_dwGapsSum -= dwEnd - cur_gap->m_dwStartOffset;
			for (uint32 i = (cur_gap->m_dwStartOffset/PARTSIZE); i <= (dwEnd/PARTSIZE); i++)
			{
				FillGapInParts(i, cur_gap->m_dwStartOffset, dwEnd);
			}
d1222 2
a1223 5
			m_dwGapsSum -= cur_gap->m_dwEndOffset - dwStart;
			for (uint32 i = (dwStart/PARTSIZE); i <= (cur_gap->m_dwEndOffset/PARTSIZE); i++)
			{
				FillGapInParts(i, dwStart, cur_gap->m_dwEndOffset);
		}
d1228 2
a1229 1
			uint32 buffer = cur_gap->m_dwEndOffset;
d1233 3
a1235 6
			cur_gap->m_dwEndOffset = buffer;
			m_dwGapsSum -= dwEnd - dwStart;
			for (uint32 i = (dwStart/PARTSIZE); i <= (dwEnd/PARTSIZE); i++)
			{
				FillGapInParts(i, dwStart, dwEnd);
			}
d1248 23
a1270 6
// this function updates the part status vector based on gap information & part nubmer
void CPartFile::FillGapInParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd)
{
	uint32 dwPartStart = dwPart * PARTSIZE;
	uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE - 1) : (GetFileSize() - 1);
	uint32 dwPartFilledSize = GetPartFilledSize(dwPart);
d1272 1
a1272 11
	if (dwGapStart <= dwPartStart && dwGapEnd >= dwPartEnd)
	{
		dwPartFilledSize = dwPartEnd - dwPartStart + 1;
	}
	else if (dwGapStart <= dwPartStart && dwGapEnd < dwPartEnd)
	{
		dwPartFilledSize += dwGapEnd - dwPartStart + 1;
	}
	else if (dwGapStart >= dwPartStart && dwGapEnd <= dwPartEnd)
	{
		dwPartFilledSize += dwGapEnd - dwGapStart + 1;
a1273 6
	else if (dwGapStart > dwPartStart && dwGapEnd >= dwPartEnd)
	{
		dwPartFilledSize += dwPartEnd - dwGapStart + 1;
	}

	m_PartsStatusVector[dwPart] = (m_PartsStatusVector[dwPart] & 0xFF000000) | dwPartFilledSize;
d1276 3
a1278 2
// this function updates the part status vector based on gap information & part nubmer
void CPartFile::AddGapToParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd)
d1280 5
a1284 3
	uint32 dwPartStart = dwPart * PARTSIZE;
	uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE - 1) : (GetFileSize() - 1);
	uint32 dwPartFilledSize = GetPartFilledSize(dwPart);
d1286 16
a1301 15
	if (dwGapStart <= dwPartStart && dwGapEnd >= dwPartEnd)
	{
		dwPartFilledSize = 0;
	}
	else if (dwGapStart <= dwPartStart && dwGapEnd < dwPartEnd)
	{
		dwPartFilledSize -= dwGapEnd - dwPartStart + 1;
	}
	else if (dwGapStart >= dwPartStart && dwGapEnd <= dwPartEnd)
	{
		dwPartFilledSize -= dwGapEnd - dwGapStart + 1;
	}
	else if (dwGapStart > dwPartStart && dwGapEnd >= dwPartEnd)
	{
		dwPartFilledSize -= dwPartEnd - dwGapStart + 1;
a1302 2

	m_PartsStatusVector[dwPart] = (m_PartsStatusVector[dwPart] & 0xFF000000) | dwPartFilledSize;
d1311 2
a1312 2
		m_dblPercentCompleted = ((1.0 - static_cast<double>(m_dwGapsSum + 1) / GetFileSize())) * 100;
		m_dwCompletedSize = (GetFileSize() - m_dwGapsSum - 1);
d1490 3
a1492 1
			if (GetPartStatus(done) == PR_PART_ON && IsPartComplete(done))
d1495 1
a1495 2
			done++;
			if (done == parts)
a1503 16
bool CPartFile::HasParts()
{
	EMULE_TRY

	uint16 parts = GetPartCount();
	for (uint16 i = 0; i < parts; i++)
	{
		if (GetPartStatus(i) != PR_PART_OFF && IsPartComplete(i))
			return true;
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d2773 1
a2773 1
uint32 CPartFile::GetPartLeftToDLSize(uint32 dwPartNum)
d2778 1
a2778 1
	uint32 dwLeftSize = (dwEnd - dwStart + 1) - GetPartFilledSize(dwPartNum);
d2836 1
a2836 1
		return ;
d3436 6
a3441 1
	EMULE_TRY
d3443 9
a3451 10
	return ( GetFileExtension() == _T("avi") 
			|| GetFileExtension() == _T("ogm") 
			|| GetFileExtension() == _T("mkv")
			|| GetFileExtension() == _T("wmv")
			|| GetFileExtension() == _T("divx")
			|| GetFileExtension() == _T("xvid") );

	EMULE_CATCH

	return false;
d3456 6
a3461 1
	EMULE_TRY
d3463 9
a3471 10
	return (GetFileExtension() == _T("mpg")
			|| GetFileExtension() == _T("mpe") 
			|| GetFileExtension() == _T("mpeg") 
			|| GetFileExtension() == _T("bin")
			|| GetFileExtension() == _T("vob")
			|| GetFileExtension() == _T("dat"));

	EMULE_CATCH

	return false;
d4116 3
a4118 9
			bool bMPEG = false;

			if (!GetFileExtension().IsEmpty())
			{
				bMPEG = (IsMpgMovie() 
						|| GetFileExtension() == _T("mp3") 
						|| GetFileExtension() == _T("mp2") 
						|| GetFileExtension() == _T("mpa"));
			}
d4309 1
a4309 1
		return ;
a4329 2
	EMULE_TRY

a4330 2

	EMULE_CATCH
d4663 2
a4664 1
		if (IsPartComplete(dwPartNum))
d4700 1
a4700 1
		return ;
d4780 1
a4780 1
					m_PartsStatusVector[iPartNum] = m_PartsStatusVector[iPartNum] | PART_CORRUPTED;
d4788 4
d4807 4
@


1.514
log
@minor rephrase
@
text
@d2168 1
a2168 1
				, uDroppedTimeout, (uTimeoutSrcCount + uDroppedTimeout)
@


1.513
log
@optimization in processing of file extension
@
text
@d1955 1
a1955 1
								&& (m_iSrcLowToLow - uDroppedLowToLowID) == 0 )
d1993 2
a1994 2
									&& (m_iSrcLowToLow - uDroppedLowToLowID) == 0
									&& (m_iSrcNNP - uDroppedNNP) == 0 )
d2021 3
a2023 3
										&& (m_iSrcLowToLow - uDroppedLowToLowID) == 0
										&& (m_iSrcNNP - uDroppedNNP) == 0
										&& (m_iSrcQueueFull - uDroppedQueueFull) == 0
@


1.512
log
@oh, i let the debugline active - sorry.
@
text
@d3480 1
a3480 7
	CString fname = GetFileName();

	fname.MakeLower();

	bool bIsVCD = _tcsstr(fname, _T(".bin"));

	return (ED2KFT_VIDEO == GetFileType() || bIsVCD);
d3487 6
a3492 5
	CString fname = GetFileName();
	fname.MakeLower();

	return ( _tcsstr(fname, _T(".avi")) || _tcsstr(fname, _T(".ogm")) || _tcsstr(fname, _T(".mkv"))
			 || _tcsstr(fname, _T(".wmv")) || _tcsstr(fname, _T(".divx")) || _tcsstr(fname, _T(".xvid")));
d3503 6
a3508 5
	CString fname = GetFileName();
	fname.MakeLower();

	return ( _tcsstr(fname, _T(".mpg")) || _tcsstr(fname, _T(".mpe")) || _tcsstr(fname, _T(".bin"))
			 || _tcsstr(fname, _T(".vob")) || _tcsstr(fname, _T(".dat")));
a3644 2
	CString extension = CString(GetFileName()).Right(4);

d3646 1
a3646 1
		return ((extension.CompareNoCase(".rar") == 0) || (extension.CompareNoCase(".zip") == 0));
a4157 1
			LPCTSTR pszExt = _tcsrchr(GetFileName(), _T('.'));
d4159 1
a4159 1
			if (pszExt != NULL)
d4161 4
a4164 3
				CString strExt(pszExt);
				strExt.MakeLower();
				bMPEG = (IsMpgMovie() || strExt == _T(".mp3") || strExt == _T(".mp2") || strExt == _T(".mpa"));
@


1.511
log
@(final) improved dropping of sources
@
text
@d2165 1
a2165 1
		///*	Producing many lines - so uncomment it only if u want to look into details
d2174 1
a2174 1
		//*/
@


1.510
log
@improved dropping and counting of sources
@
text
@d154 1
a154 1
	dwLastPurgeTime = ::GetTickCount();
d177 1
a177 1
	m_dataRate = 0;
a182 1

a199 6

	if (g_eMuleApp.m_pGlobPrefs->IsDAPEnabled())
		m_bAutoPriority = true;
	else
		m_bAutoPriority = false;

a205 1

a208 1

a210 3

	::InitializeCriticalSection(&m_csDownloadingSourceList);

a212 1

d215 1
a215 1
//	set intial gaps sum to 0
d217 1
a217 1
//	set total size of completed parts to 0
d220 8
a680 1
	{
d682 2
a683 8
	}
	else
	{
		if (m_dwCompletedSize != m_dwBytesTransferred)
		{
			m_qwLostDueToCorruption = m_dwBytesTransferred - m_dwCompletedSize;
		}
	}
a687 1
	{
a688 1
	}
d1673 1
a1673 1
	dwLastPurgeTime = ::GetTickCount();
d1690 1
a1690 2

	m_dataRate = 0;
d1711 1
a1711 1
	m_iNumTransferringSrcs = 0;
d1744 2
a1745 2
				m_iNumTransferringSrcs++;
				m_dataRate += dwCurrentDataRate;
d1788 2
d1793 2
a1794 3
	//	Dont drop sources if sourcecount is lower than 80% of max. sources per file
		uint16	uDropLimit = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * 0.8;

d1796 2
a1797 2
	//	In all other cases ONLY 1 source is dropped from the file which is because of 'dwLastPurgeTime = dwCurTick;'
	//	Preferred order of dropping a source by state is: (TimeOut), Low2Low, NNP, QueueFull and then HighQR sources.
d1802 8
a1818 1
					{
a1819 1
					}
d1824 1
a1824 1
					uint32 usethisfilereasktime = FILEREASKTIME;
a1832 1
							{
a1833 1
							}
d1836 2
a1837 2
							m_iNumTransferringSrcs++;
							m_dataRate += dwCurrentDataRate;
a1841 1
								{
d1843 2
a1844 8
								}
								else
								{
									if (dwLimit < 1)
									{
										dwLimit = 1;
									}
								}
d1852 2
a1853 7
							else
							{
								if (m_nSavedReduceDownload != dwReduceDownload)
								{
									pSource->m_pRequestSocket->DisableDownloadLimit();
								}
							}
d1909 2
d1923 3
a1925 3
							if ( (dwCurTick - dwLastPurgeTime) > PURGE_TIME
								&& uSourceNumber > uDropLimit )
							//	Prefere to drop these Low2Low before all other
d1929 5
a1933 1
								dwLastPurgeTime = dwCurTick;
d1951 1
a1951 1
							if ( (dwCurTick - dwLastPurgeTime) > PURGE_TIME
d1953 1
d1955 1
a1955 1
								&& m_iSrcLowToLow == 0 )
d1961 5
a1965 1
									dwLastPurgeTime = dwCurTick;
d1978 1
a1978 3
							{
								usethisfilereasktime = FILEREASKTIME * 2;
							}
d1980 1
a1980 2
							if (!((!pSource->GetLastAskedTime()) || (dwCurTick - pSource->GetLastAskedTime()) > usethisfilereasktime * 2))
							{
a1981 1
							}
d1985 2
d1989 1
a1989 1
								if ( (dwCurTick - dwLastPurgeTime) > PURGE_TIME
d1991 1
d1993 2
a1994 2
									&& m_iSrcLowToLow == 0
									&& m_iSrcNNP == 0 )
d1998 5
a2002 1
									dwLastPurgeTime = dwCurTick;
d2014 2
a2015 2
								if ( g_eMuleApp.m_pGlobPrefs->UseRemoteQueueLimit()
									&& (pSource->GetRemoteQueueRank() > g_eMuleApp.m_pGlobPrefs->GetRemoteQueueLimit()) )
d2017 1
a2017 1
									if ( (dwCurTick - dwLastPurgeTime) > PURGE_TIME
d2019 1
d2021 5
a2025 3
										&& m_iSrcLowToLow == 0
										&& m_iSrcNNP == 0
										&& m_iSrcQueueFull == 0 )
d2029 4
a2032 1
										dwLastPurgeTime = dwCurTick;
d2041 1
a2041 1
								else
a2042 2
									if (!bAlreadyCounted)
									{
a2044 1
									}
d2048 1
a2048 1
							if (bSocketsUsageIsHigh && pSource->GetRemoteQueueRank() != 0)
d2050 2
a2051 5
								if (pSource->GetRemoteQueueRank() > 250)
								{
									usethisfilereasktime = FILEREASKTIME * 2.5 ; 	// QR>250 = 54:10 minutes
								}
								else
d2053 4
a2056 1
									usethisfilereasktime = FILEREASKTIME * 2; 		// QR<250 = 43:20 minutes
d2058 5
d2079 1
a2079 1
								          || (dwCurTick - pSource->GetLastAskedTime()) > usethisfilereasktime - 20000 ) )
d2083 1
a2083 2
#endif //OLD_SOCKETS_ENABLED

d2097 1
a2097 1
#endif //OLD_SOCKETS_ENABLED
d2150 1
a2150 3
						{
							usethisfilereasktime = LANCASTFILEREASKTIMETCP;
						}
d2152 1
a2152 2
						if (!pSource->GetLastAskedTime() || (dwCurTick - pSource->GetLastAskedTime()) > usethisfilereasktime)
						{
a2153 1
						}
d2155 1
a2155 1
#endif //OLD_SOCKETS_ENABLED
d2160 16
d2195 4
d2312 1
a2312 1
	return m_dataRate;
d2342 1
a2342 1
		 (dwLastPurgeTime == 0 || (::GetTickCount() - dwLastPurgeTime > PURGE_TIME)) )
d2431 1
a2431 1
						ASSERT(pSource->IsCompleteSource());
d2874 1
a2874 1
		m_dataRate = 0;
d3721 1
a3721 1
	m_dataRate = 0;
d3740 1
d3817 1
a3817 1
	m_dataRate = 0;
d4051 1
a4051 1
	//	Delay 1st calculation a bit & dont use m_dataRate for balancing (peak-stopper?)
@


1.509
log
@one more correction
@
text
@d154 1
a154 1
	lastpurgetime = ::GetTickCount();
d179 1
a179 1
	count = 0;
d182 1
a182 1
	completedsize = 0;
a191 1
	m_bPercentUpdated = false;
d685 11
a695 4
	if (completedsize > m_dwBytesTransferred)
		m_iGainDueToCompression = completedsize - m_dwBytesTransferred;
	else if (completedsize != m_dwBytesTransferred)
		m_qwLostDueToCorruption = m_dwBytesTransferred - completedsize;
d698 1
a698 1
	m_SessionStartSize = completedsize;
d700 1
d702 1
d1360 1
a1360 1
		completedsize = (GetFileSize() - m_dwGapsSum - 1);
d1365 1
a1365 1
		completedsize = GetFileSize();
d1404 1
a1404 1
		completedsize = GetFileSize();
d1489 1
a1489 1
		s_LoadBar.SetFileSize(completedsize);
d1687 1
a1687 1
	lastpurgetime = ::GetTickCount();
d1804 1
a1804 1
	// cache number of sources
d1806 9
d1824 2
a1825 1
					if (!pSource)
d1827 1
d1841 1
d1843 3
a1845 2
						// Needed to update the source count
						// GetTransferringSrcCount() isn't updated inside this function.
d1850 12
a1861 5
								uint32 limit = dwReduceDownload * dwCurrentDataRate / 1000;
								if (limit < 1000 && dwReduceDownload == 200)
									limit += 1000;
								else if (limit < 1)
									limit = 1;
d1864 1
a1864 1
								pSource->m_pRequestSocket->SetDownloadLimit(limit);
d1869 7
a1875 2
							else if (m_nSavedReduceDownload != dwReduceDownload)
								pSource->m_pRequestSocket->DisableDownloadLimit();
a1880 1

d1882 1
d1889 1
a1889 1

d1891 1
a1895 1
								pSource->Disconnected();
d1897 2
d1900 1
a1900 1

d1902 1
a1903 1

a1917 1

d1924 2
d1930 1
d1940 1
a1940 1

d1942 10
a1951 1
					 	//	If we now have a high ip we can ask
d1957 3
a1959 2
							if ( ((dwCurTick - lastpurgetime) > PURGE_TIME)
								&& (uSourceNumber >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
a1960 3
								g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
								uSourceNumber--;
								lastpurgetime = dwCurTick;
a1962 3
#ifdef OLD_SOCKETS_ENABLED
							if (g_eMuleApp.m_pServerConnect->IsLowID())
								break;
d1964 1
a1964 1

d1967 4
a1970 1
							if (!bAlreadyCounted)
a1971 5
								uNNPSrcCount++;
								bAlreadyCounted = true;
							}
							if ( ((dwCurTick - lastpurgetime) > 40000)
							     && (uSourceNumber >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
d1976 1
a1976 1
									lastpurgetime = dwCurTick;
d1979 6
d1987 1
a1987 1
						//	noneededparts-sources will be checked filereasktime*4 when 3/4 of max. sockets are open
d1989 1
d1991 1
d1994 1
d1996 1
d2002 5
a2006 7
								if (!bAlreadyCounted)
								{
									uQueueFullSrcCount++;
									bAlreadyCounted = true;
								}
								if ( ((dwCurTick - lastpurgetime) > 60000)
								     && (uSourceNumber >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
d2010 1
a2010 1
									lastpurgetime = dwCurTick;
a2012 5
							}
						//	Check Remote queue position (HighQR)
							else if ( g_eMuleApp.m_pGlobPrefs->UseRemoteQueueLimit()
							          && (pSource->GetRemoteQueueRank() > g_eMuleApp.m_pGlobPrefs->GetRemoteQueueLimit()) )
							{
d2015 1
a2015 1
									uHighQRSrcCount++;
a2017 2
								g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
								break;
d2019 1
a2019 1
							else if (!bAlreadyCounted)
d2021 30
a2050 2
								uOnQueueSrcCount++;
								bAlreadyCounted = true;
d2053 1
a2053 1
							if (pSource->GetRemoteQueueRank() && bSocketsUsageIsHigh)  	// QueueRank > 250
d2056 3
a2058 1
									usethisfilereasktime = FILEREASKTIME * 2.5 ; 		// 54:10 minutes
d2060 3
a2062 1
									usethisfilereasktime = FILEREASKTIME * 2; 			// (QR 1-250 = 43:20 minutes)
a2086 1
						//	(emulates a "Connecting via server..." without request socket timeout)
d2088 1
d2101 2
d2104 2
a2105 5
								if (!bAlreadyCounted)
								{
									uConnectingSrcCount++;
									bAlreadyCounted = true;
								}
d2107 1
d2109 2
d2112 2
a2113 5
								if (!bAlreadyCounted)
								{
									uTooManyConnsSrcCount++;
									bAlreadyCounted = true;
								}
d2115 1
d2117 2
d2120 2
a2121 6
								if (!bAlreadyCounted)
								{
									uNoUploadSrcCount++;
									bAlreadyCounted = true;
								}
								bReaskDownload = true;
d2123 2
d2126 2
d2129 2
a2130 6
								if (!bAlreadyCounted)
								{
									uConnViaServerSrcCount++;
									bAlreadyCounted = true;
								}
								bReaskDownload = true;
d2132 3
a2134 2
						break;

d2136 4
a2139 5
							{
								uReqHashSrcCount++;
								break;
							}

d2141 3
a2143 3
							{
								uUnknownSrcCount++;
							}
d2151 1
d2153 1
d2156 1
d2158 1
d2192 1
a2192 1
			for (int sl = 0;sl < SOURCESSLOTS;sl++)
d2276 3
a2278 3
	//	Calculate data rate, set limit etc. (every 5sec)
		count++;
		if (count == 5)
d2280 2
a2281 1
			count = 0;
a2282 3
			if (m_bPercentUpdated == false)
				UpdateCompletedInfos();
			m_bPercentUpdated = false;
d2327 1
a2327 1
		 (lastpurgetime == 0 || (::GetTickCount() - lastpurgetime > PURGE_TIME)) )
d2490 1
a2490 1
		return pSource->GetLastDownPartAsked();
@


1.508
log
@One more critical fix for the new code (caching of part size in part status vector).
@
text
@d1275 1
a1275 1
			for (uint32 i = (dwStart/PARTSIZE); i <= (dwStart/PARTSIZE); i++)
d1277 1
a1277 1
				FillGapInParts(i, dwStart, dwStart);
@


1.507
log
@1) corrected bug founded by SyruS
2) corrupted status will be stored in part status vector
@
text
@d1315 1
a1315 1
	m_PartsStatusVector[dwPart] = (m_PartsStatusVector[dwPart] & 0xFF000000) & dwPartFilledSize;
d1342 1
a1342 1
	m_PartsStatusVector[dwPart] = (m_PartsStatusVector[dwPart] & 0xFF000000) & dwPartFilledSize;
@


1.506
log
@minor correction
@
text
@d332 1
a332 7
	Gap_Struct* pGap = new Gap_Struct;

	pGap->m_dwStartOffset = 0;
	pGap->m_dwEndOffset = GetFileSize() - 1;
	m_dwGapsSum = pGap->m_dwEndOffset - pGap->m_dwStartOffset;
	gaplist.AddTail(pGap);

d3344 1
a3344 1
bool CPartFile::HashSinglePart(uint16 partnumber)
d3351 1
a3351 1
	if ((GetHashCount() <= partnumber) && (dwPartCnt > 1))
d3355 1
a3355 1
	else if (!GetPartHash(partnumber) && (dwPartCnt != 1))
d3365 1
a3365 1
		pPartFile->Seek((LONGLONG)PARTSIZE * partnumber, CFile::begin);
d3369 1
a3369 1
		if ((ULONGLONG)PARTSIZE * (partnumber + 1) > pPartFile->GetLength())
d3371 1
a3371 1
			length = (pPartFile->GetLength() - ((ULONGLONG)PARTSIZE * partnumber));
d3379 1
a3379 1
		return (md4cmp(hashresult, (GetFileSize() >= PARTSIZE) ? GetPartHash(partnumber) : m_fileHash) == 0) ? true : false;
a3390 11
bool CPartFile::IsCorruptedPart(uint16 uPartIndex)
{
	EMULE_TRY

	return corrupted_list.Find(uPartIndex);

	EMULE_CATCH

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a3556 56
// Movie1 disables (movie --> normal) & (movie --> worst movie)
/*
bool CPartFile::Movie1(byte mode, uint16 oldchunk, uint16 newchunk)
{
	EMULE_TRY

	if (IsMovie())
	{
		if (!IsMovieChunk(mode, newchunk) && IsMovieChunk(mode, oldchunk))
			return false;
		if (IsMovieChunk(mode, newchunk) && IsMovieChunk(mode, oldchunk))
		{
			if (!IsBetterMovieChunk(oldchunk, newchunk))
				return false;
		}
	}
	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Movie2 enables (normal --> movie) & (movie --> better movie)
bool CPartFile::Movie2(byte mode, byte raremovie, bool forcepreview, uint16 oldchunk, uint16 newchunk)
{
	EMULE_TRY

	if ( IsMovie() && ( ( m_srcPartFrequencies[oldchunk] > raremovie
	                      && m_srcPartFrequencies[newchunk] > raremovie )      					// old & new chunk are nonrare
	                    || (m_srcPartFrequencies[oldchunk] == m_srcPartFrequencies[newchunk]) 	// old & new chunk are same rare
	                    || forcepreview ) )            											// Load preview chunks first always
	{
	//	AddLogLine(true, CString("Movie2::Mode:%d old:%d new:%d rarem:%d - The new & old ones are nonrare,samerare or forced, now we decide if new is a better movie or could change to movie..."),mode,oldchunk,newchunk,raremovie);

		if (!IsMovieChunk(mode, oldchunk) && IsMovieChunk(mode, newchunk))
		{
			if (forcepreview)
				return true;
		}
		if (IsMovieChunk(mode, oldchunk) && IsMovieChunk(mode, newchunk))
		{
			if (IsBetterMovieChunk(oldchunk, newchunk))
			{
				if (forcepreview)
					return true;
			}
		}
	}

	EMULE_CATCH

	return false;
}
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d4675 2
a4676 2
	uint32	iPartCount = GetPartCount();
	bool *changedPart = new bool[iPartCount];
d4681 1
a4681 1
		for (int uPartNumber = 0; (uint32)uPartNumber < iPartCount; uPartNumber++)
d4683 1
a4683 1
			changedPart[uPartNumber] = false;
d4729 1
a4729 1
		for (int uPartNumber = iPartCount - 1; uPartNumber >= 0; uPartNumber--)
d4732 1
a4732 1
			if (changedPart[uPartNumber] == false)
d4740 1
a4740 1
			if (IsComplete(PARTSIZE * uPartNumber, (PARTSIZE * (uPartNumber + 1)) - 1))
d4743 1
a4743 1
				if (!HashSinglePart(uPartNumber))
d4745 5
a4749 3
					AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_PARTCORRUPT), uPartNumber, GetFileName());
					AddGap(PARTSIZE * uPartNumber, (PARTSIZE * uPartNumber + partRange));
					corrupted_list.AddTail(uPartNumber);
d4766 1
a4766 1
			else if (IsCorruptedPart(uPartNumber))
d4769 1
a4769 1
				if (HashSinglePart(uPartNumber))
d4772 3
a4774 3
					FillGap(PARTSIZE * uPartNumber, (PARTSIZE * uPartNumber + partRange));
					RemoveBlockFromList(PARTSIZE * uPartNumber, (PARTSIZE * uPartNumber + partRange));
					AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_ICHWORKED), uPartNumber, GetFileName());
@


1.505
log
@caching of part size in part status vector
@
text
@d1298 1
a1298 1
void __fastcall CPartFile::FillGapInParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd)
d1325 1
a1325 1
void __fastcall CPartFile::AddGapToParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd)
@


1.504
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d252 1
a252 1
	m_ReqParts.RemoveAll();
a298 7
	Gap_Struct* gap = new Gap_Struct;

	gap->m_dwStartOffset = 0;
	gap->m_dwEndOffset = GetFileSize() - 1;
	m_dwGapsSum = gap->m_dwEndOffset - gap->m_dwStartOffset;
	gaplist.AddTail(gap);

d315 1
a315 1
	const uint16 iPartCount = GetPartCount();
d319 1
a319 1
	m_ReqParts.SetSize(iPartCount);
d325 4
a328 1
		m_ReqParts[i] = 0;
d331 9
d556 18
a637 10
	const uint16 iPartCount = GetPartCount();
	m_srcPartFrequencies.SetSize(iPartCount);
	m_BlockedParts.SetSize(iPartCount);
	m_ReqParts.SetSize(iPartCount);
	for (uint32 i = 0; i < iPartCount; i++)
	{
		m_srcPartFrequencies[i] = 0;
		m_BlockedParts[i] = 0;
		m_ReqParts[i] = 0;
	}
d932 1
a932 1
void CPartFile::AddGap(uint32 start, uint32 dwEnd)
d943 1
a943 1
		if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= dwEnd)
d947 4
d953 1
a953 1
		else if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwStartOffset <= dwEnd)
d958 4
d964 1
a964 1
		else if (cur_gap->m_dwEndOffset <= dwEnd && cur_gap->m_dwEndOffset >= start)
d966 1
a966 1
			start = cur_gap->m_dwStartOffset;
d969 4
d975 1
a975 1
		else if (start >= cur_gap->m_dwStartOffset && dwEnd <= cur_gap->m_dwEndOffset)
d981 1
a981 1
	new_gap->m_dwStartOffset = start;
d983 6
a988 1
	m_dwGapsSum += dwEnd - start;
a989 1

d1036 8
a1043 1
	return IsComplete(dwStart, dwEnd);
d1059 8
a1066 1
	return IsComplete(dwStart, dwEnd);
d1234 1
a1234 1
void CPartFile::FillGap(uint32 start, uint32 dwEnd)
d1245 1
a1245 1
		if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= dwEnd)
d1249 4
d1255 1
a1255 1
		else if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwStartOffset <= dwEnd)
d1258 4
d1264 1
a1264 1
		else if (cur_gap->m_dwEndOffset <= dwEnd && cur_gap->m_dwEndOffset >= start)
d1266 4
a1269 2
			m_dwGapsSum -= cur_gap->m_dwEndOffset - start;
			cur_gap->m_dwEndOffset = start - 1;
d1271 3
a1273 1
		else if (start >= cur_gap->m_dwStartOffset && dwEnd <= cur_gap->m_dwEndOffset)
d1276 1
a1276 1
			cur_gap->m_dwEndOffset = start - 1;
d1280 5
a1284 1
			m_dwGapsSum -= dwEnd - start;
d1297 54
a2400 6

#define NOT_AVAILABLE		0xFFFFFFFF
#define PARTIALLY_BLOCKED 	0xFFFFFFFE
#define FULLY_BLOCKED 		0xFFFFFFFD
#define FREE_TO_DL 			0x00000000

d2431 2
d2450 2
a2451 2
			m_ReqParts[i] = GetBytesInPart(i, true);
			if (m_ReqParts[i] != 0)
d2456 1
a2456 1
			m_ReqParts[i] = NOT_AVAILABLE; // mark parts as not available to save CPU load
d2490 1
a2490 1
				if (m_ReqParts[pDownloadingSource->GetLastDownPartAsked()] != NOT_AVAILABLE
d2526 1
a2526 1
		if (m_ReqParts[i] != NOT_AVAILABLE && m_BlockedParts[i] != FULLY_BLOCKED && m_ReqParts[i] != 0)
d2533 1
a2533 1
				if (m_ReqParts[i] > (PARTSIZE - EMBLOCKSIZE) || (i == (iPartCount -1) && m_ReqParts[i] == dwLastPartSize)) // limit change to prevent consecutive download due overlaping
d2541 1
a2541 1
					if (m_ReqParts[i] < dwMostCompletedUniqueReqPart)
d2544 1
a2544 1
						dwMostCompletedUniqueReqPart = m_ReqParts[i];
d2551 1
a2551 1
				if (m_ReqParts[i] == PARTSIZE || (i == (iPartCount -1) && m_ReqParts[i] == dwLastPartSize))
d2558 1
a2558 1
					if (m_ReqParts[i] < dwMostCompletedRarestReqPart)
d2561 1
a2561 1
						dwMostCompletedRarestReqPart = m_ReqParts[i];
d2618 1
a2618 1
			if (m_ReqParts[i] == PARTSIZE || (i == (iPartCount -1) && m_ReqParts[i] == dwLastPartSize))
d2630 1
a2630 1
					bCodition = (m_ReqParts[i] < dwMostCompletedReqPart);
d2634 1
a2634 1
					bCodition = (m_ReqParts[i] > dwMostCompletedReqPart);
d2639 1
a2639 1
					dwMostCompletedReqPart = m_ReqParts[i];
d2721 11
a2731 5
	/*
	AddDebugLogLine( _T("ICR-Test: File: %s, A-parts : %u, BP-Parts %u. Choosen Part: %u, P-Freq: %u, blocked %s"),
					 GetFileName(), nNumAvailableNeededParts, nNumPartiallyBlockedParts, nGoodPart,
					 m_srcPartFrequencies[nGoodPart], ((m_BlockedParts[nGoodPart] == PARTIALLY_BLOCKED)? _T("yes"):_T("no")) );
	*/
d2741 1
a2741 1
uint32 CPartFile::GetBytesInPart(uint16 partnumber, bool left2DL, bool dontRecalculate)
d2743 2
a2744 56
	EMULE_TRY

	if (partnumber >= GetPartCount())
		return (left2DL ? 0 : 0xFFFFFFFF);

	uint32 PartSize;
	uint32 left2DLSize;

	const uint32 uStart = partnumber * PARTSIZE;
	const uint32 uEnd = ((GetFileSize() - uStart) > PARTSIZE) ? (uStart + PARTSIZE - 1) : (GetFileSize() - 1);

	if (dontRecalculate)
	{
		PartSize = m_ReqParts[partnumber];
		left2DLSize = (uEnd - uStart + 1) - PartSize;
	}
	else
	{
	//	Set part size to fullfilled
		PartSize = left2DLSize = uEnd - uStart + 1;

		CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on block exit

		for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
		{
			Gap_Struct * cur_gap = gaplist.GetNext(pos);
		//	Check if Gap is into the limit
			if (cur_gap->m_dwEndOffset < uStart || cur_gap->m_dwStartOffset > uEnd)
				continue;
			if (cur_gap->m_dwStartOffset <= uStart && cur_gap->m_dwEndOffset > uStart && cur_gap->m_dwEndOffset < uEnd)
			{
				PartSize -= cur_gap->m_dwEndOffset - uStart;
				continue;
			}
			if (cur_gap->m_dwStartOffset >= uStart && cur_gap->m_dwEndOffset <= uEnd)
			{
				PartSize -= cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
				continue;
			}
			if (cur_gap->m_dwStartOffset <= uStart && cur_gap->m_dwEndOffset >= uEnd)
			{
				PartSize = 0;
				continue;
			}
			if (cur_gap->m_dwStartOffset > uStart && cur_gap->m_dwStartOffset < uEnd && cur_gap->m_dwEndOffset >= uEnd)
			{
				PartSize -= uEnd - cur_gap->m_dwStartOffset;
			}
		}
		left2DLSize -= PartSize;
	//	m_csGapListAndPartStatus is released here
	}

	return (left2DL) ? left2DLSize : PartSize;

	EMULE_CATCH
d2746 1
a2746 1
	return (left2DL ? 0 : 0xFFFFFFFF);
d2748 2
a4707 1
			m_ReqParts[dwPartNum] = PARTSIZE;
@


1.503
log
@SSWQ
@
text
@d772 1
a772 1
		CFileTag nametag(FT_FILENAME, m_strFileName);
d3353 1
a3353 1
	return (ED2KFT_VIDEO == GetED2KFileTypeID(GetFileName()) || bIsVCD);
d3577 1
a3577 1
	return (ED2KFT_ARCHIVE == GetED2KFileTypeID(GetFileName()));
d4079 1
a4079 3
			EED2KFileType eFileType = GetED2KFileTypeID(GetFileName());

			if (!(eFileType == ED2KFT_VIDEO || eFileType == ED2KFT_AUDIO || eFileType == ED2KFT_CDIMAGE))
@


1.502
log
@Improved several basic calculations.
@
text
@d340 2
a341 2
		CKnownFile::SetAutoPriority(true);
		CKnownFile::SetPriority(PR_RELEASE);
d469 2
a470 2
						CKnownFile::SetAutoPriority(true);
						CKnownFile::SetPriority(PR_RELEASE);
d474 2
a475 2
						CKnownFile::SetAutoPriority(false);
						CKnownFile::SetPriority((byte)newtag->GetIntValue());
d787 1
a787 1
		CFileTag ulprioritytag(FT_ULPRIORITY, (CKnownFile::IsAutoPrioritized()) ? PR_AUTO : m_iPriority);
d3076 1
a3076 1
	if (CKnownFile::IsAutoPrioritized() && !g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
d3078 2
a3079 2
		CKnownFile::SetAutoPriority(false);
		CKnownFile::SetPriority(PR_NORMAL);
d3170 2
a3171 2
			pThisFile->SetAutoPriority(false);
			pThisFile->SetPriority(PR_RELEASE);
@


1.501
log
@Removed unrequired list cleanups; Formatting.
@
text
@d2406 1
a2406 1
	uint32		dwMostCompletedReqPart;
d2555 1
a2555 1
			const uint16		uRandomness = static_cast<uint16>(ROUND((static_cast<double>(rand()) / RAND_MAX) * (uniquePartsList.GetCount() - 1)));
d2557 1
a2557 1
			nGoodPart = uniquePartsList.GetAt(uniquePartsList.FindIndex(uRandomness));
d2579 1
a2579 1
			const uint16		uRandomness = static_cast<uint16>(ROUND((static_cast<double>(rand()) / RAND_MAX) * (rarestPartsList.GetCount() - 1)));
d2581 1
a2581 1
			nGoodPart = rarestPartsList.GetAt(rarestPartsList.FindIndex(uRandomness));
d2602 1
a2602 1
		const uint16		uRandomness = static_cast<uint16>(ROUND((static_cast<double>(rand()) / RAND_MAX) * (randomPartsList.GetCount() - 1)));
d2604 1
a2604 1
		nGoodPart = randomPartsList.GetAt(randomPartsList.FindIndex(uRandomness));
@


1.500
log
@Added IsPartComplete services to minimize number of not quite correct calculations,
to simplify sources and to make a fundament for future fixing of the old problem;
Corrected .part.met loading in case of FileSize % PARTSIZE = 0
(fortunately, buggy code produced correct final result).
@
text
@d2326 1
d2414 1
a2414 1
	for (int i = 0; i < iPartCount ; i++)
a2521 1

d2586 1
a2586 1
	else if (moviePartsList.IsEmpty() == false)
d2600 1
a2600 1
	else if (randomPartsList.IsEmpty() == false)
a2617 18
//	Clear lists
	if (!uniquePartsList.IsEmpty())
	{
		rarestPartsList.RemoveAll();
	}
	if (!rarestPartsList.IsEmpty())
	{
		rarestPartsList.RemoveAll();
	}
	if (!moviePartsList.IsEmpty())
	{
		moviePartsList.RemoveAll();
	}
	if (!randomPartsList.IsEmpty())
	{
		randomPartsList.RemoveAll();
	}

a5635 1
			continue;
@


1.499
log
@'Download from all A4AF sources (same category)' feature
@
text
@d570 1
a570 2
		const uint32 dwStart = i * PARTSIZE;
		const uint32 dwEnd = ((GetFileSize() - dwStart) > PARTSIZE) ? (dwStart + PARTSIZE - 1) : (GetFileSize() - 1);
d572 1
a572 1
		if (IsComplete(dwStart, dwEnd))
d639 1
a639 1
		for (int i = 0; i < iSize; i++)
d641 1
a641 1
			if (IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
d880 1
a880 2
		const uint32 dwPartStart = i * PARTSIZE;
		const uint32 dwPartEnd = ((GetFileSize() - dwPartStart) > PARTSIZE) ? (dwPartStart + PARTSIZE - 1) : (GetFileSize() - 1);
d882 1
a882 1
		if (IsComplete(dwPartStart, dwPartEnd))
d1001 25
d1423 1
a1423 1
			if (GetPartStatus(done) == PR_PART_ON && IsComplete(done * PARTSIZE, ((done + 1) * PARTSIZE) - 1))
d1443 1
a1443 1
		if (GetPartStatus(i) != PR_PART_OFF && IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
d3786 1
a3786 3
		uint32 uStart = ui * PARTSIZE;
		uint32 uEnd = ((GetFileSize() - uStart) > PARTSIZE) ? (uStart + PARTSIZE - 1) : (GetFileSize() - 1);
		if (IsComplete(uStart, uEnd) == true)
d4080 1
a4080 1
		          || (!IsComplete(0, PARTSIZE - 1) || !IsComplete(PARTSIZE * (GetPartCount() - (GetMovieMode() == 7 ? 2 : 1)), GetFileSize() - 1)) );
d4134 1
a4134 1
					  || (!IsComplete(0, PARTSIZE - 1) || !IsComplete(PARTSIZE * (GetPartCount() - (GetMovieMode() == 7 ? 2 : 1)), GetFileSize() - 1)) );
a4660 2
		const uint32 uStart = dwPartNum * PARTSIZE;
		const uint32 uEnd = ((GetFileSize() - uStart) > PARTSIZE) ? (uStart + PARTSIZE - 1) : (GetFileSize() - 1);
d4662 1
a4662 1
		if (IsComplete(uStart, uEnd))
d5651 1
a5651 1
		if (IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
@


1.498
log
@the removed function was used :O... some roll back
@
text
@d5563 1
a5563 1
void CPartFile::DownloadAllA4AF()
d5569 11
a5579 1
		m_A4AFsrcList.GetNext(pos)->SwapToAnotherFile(this);
@


1.497
log
@1) removed unused code
2) renamed the function
@
text
@d1501 26
@


1.496
log
@small correction (forgot to comment some functions)
@
text
@a1500 26
//	Inserted by Vorlost for load rarest parts first, code by Denominator
uint16 CPartFile::GetRemainingBlocksInPart(uint16 partnumber)
{
	EMULE_TRY

	uint16		uNumRemainingBlocks = 0;
	for (uint32 i = 0; i < ((PARTSIZE + EMBLOCKSIZE - 1) / EMBLOCKSIZE); i++)
	{
		uint32 start = (PARTSIZE * partnumber) + i * EMBLOCKSIZE;
		uint32 dwEnd = (PARTSIZE * partnumber) + ((i + 1) * EMBLOCKSIZE) - 1;
		if (dwEnd >= PARTSIZE * ((uint32)partnumber + 1))
			dwEnd = (PARTSIZE * (partnumber + 1)) - 1;
		if (start >= GetFileSize())
			break;
		if (dwEnd >= GetFileSize())
			dwEnd = GetFileSize() - 1;
		if (!IsComplete(start, dwEnd) && !IsAlreadyRequested(start, dwEnd))
			uNumRemainingBlocks++;
	}
	return uNumRemainingBlocks;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d2237 1
a2237 1
uint16 CPartFile::GetNextRequestedBlock(CUpDownClient *pSource)
@


1.495
log
@optimization in function ::Process
@
text
@d1782 1
a1782 1
								&& (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
d1785 1
d1802 1
a1802 1
							     && (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
d1806 1
d1829 1
a1829 1
								     && (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
d1832 1
d2058 1
a2058 1
			&& g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > GetSourceCount() )
d2084 5
a2088 2
//	For status category filters
	if ( GetTransferringSrcCount() != nOldTransSourceCount
d2092 1
a2092 11
		EnumCategories	curCat = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.GetCurTabCat();

	//	Changes in file status can affect whether the file belongs to a predefined category or not
		if (curCat >= CAT_PREDEFINED)
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.ChangeCategoryByID(curCat);
		else
			UpdateDisplayedInfo(true);

	//	If we're displaying file counts in the tabs, update them to reflect status changes
		if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfo())
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d3507 1
d3560 1
d5769 1
d5775 1
@


1.494
log
@Fixed rare issue when a requested upload block could be splitted into two requests
(2 requests were used when one was enough, that led to slight increase of
overhead traffic and to decrease of possible compression gain).
@
text
@d1666 3
@


1.493
log
@More correct calculations (preparations for 4 Gb file sharing/downloading);
Reduced number of consequent SetStatus due to it creates additional GUI load;
Unused service PrepareComparePart is removed.
@
text
@d1135 1
a1135 1
			const uint32 endOffset = ((uGapStart + EMBLOCKSIZE - 1) > uGapEnd) ? uGapEnd : ((uGapStart + EMBLOCKSIZE - 1) - (uGapStart % EMBLOCKSIZE));
@


1.492
log
@Significantly improved some simple calculations.
@
text
@d571 1
a571 1
		const uint32 dwEnd = ((GetFileSize() - 1) < (dwStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (dwStart + PARTSIZE - 1);
d882 1
a882 1
		const uint32 dwPartEnd = ((((i + 1) * PARTSIZE) - 1) >= GetFileSize()) ? GetFileSize() - 1 : ((i + 1) * PARTSIZE) - 1;
d1033 1
a1033 3
	uint32 partEnd = (PARTSIZE * (uPartNumber + 1)) - 1;
	if (partEnd >= GetFileSize())
		partEnd = GetFileSize() - 1;
d1111 1
a1111 1
	const uint32 uPartEnd = ((GetFileSize() - 1) < (uPartStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uPartStart + PARTSIZE - 1);
d1289 1
a1289 1
			const uint32 dwPartEnd = (GetFileSize() < (dwPartStart + PARTSIZE)) ? GetFileSize() : (dwPartStart + PARTSIZE);
d2633 1
a2633 1
	const uint32 uEnd = ((GetFileSize() - 1) < (uStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uStart + PARTSIZE - 1);
a3560 29
byte CPartFile::PrepareComparePart(uint16 chunk)
{
	EMULE_TRY

	byte addchunk = 0;

//	Is this the last chunk ?
	if (chunk == GetPartCount() - 1)
	{
		uint32 lastblock = (PARTSIZE + EMBLOCKSIZE - 1) / EMBLOCKSIZE;
		uint32 lastblockinpart = lastblock;
		uint32 start;
	//	Get last possible blocknumber
		for (lastblockinpart = 0; lastblockinpart != lastblock;lastblockinpart++)
		{
			start = (PARTSIZE * chunk) + lastblockinpart * EMBLOCKSIZE;
			if (start >= GetFileSize())
				break;
		}
		addchunk = lastblock - lastblockinpart;
	}

	return GetRemainingBlocksInPart(chunk) + addchunk;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d3758 1
a3758 1
	SetStatus(PS_EMPTY);
d3760 1
a3760 1
	for (int i = 0; i < GetPartCount(); i++)
d3762 2
a3763 2
		uint32 uStart = i * PARTSIZE;
		uint32 uEnd = ((GetFileSize() - 1) < (uStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uStart + PARTSIZE - 1);
d3766 1
a3766 1
			SetStatus(PS_READY);
d3770 1
d4640 1
a4640 1
		const uint32 uEnd = ((GetFileSize() - 1) < (uStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uStart + PARTSIZE - 1);
d5506 4
a5509 1
				if (gapstart >= i * PARTSIZE && gapstart <= (i + 1) * PARTSIZE)
d5511 1
a5511 1
					if (gapend <= (i + 1) * PARTSIZE)
d5515 1
a5515 1
						gapend = (i + 1) * PARTSIZE; // and next part
a5640 1

@


1.491
log
@Minimized time of synchronization object ownership during gap list processing.
@
text
@d1509 1
a1509 1
	for (uint32 i = 0; i < ceil((double)PARTSIZE / EMBLOCKSIZE);i++)
d3388 1
a3388 1
	uint32 lastblock = ceil(static_cast<double>(PARTSIZE) / EMBLOCKSIZE), dwEnd;
d3572 1
a3572 1
		uint32 lastblock = ceil(static_cast<double>(PARTSIZE) / EMBLOCKSIZE);
d5664 1
a5664 1
			freq = ceil(static_cast<double>(freq) / 3.0);
@


1.490
log
@Optimization and formatting.
@
text
@d766 4
a769 1
		CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on block exit
d771 1
a771 1
		uint32 dwTagCount = m_tagArray.GetCount() + 8 + (gaplist.GetCount() * 2);
d801 4
a804 1
		for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
d808 1
a808 1
			CFileTag gapstarttag(acNameBuffer, gaplist.GetAt(pos)->m_dwStartOffset);
d813 1
a813 1
			CFileTag gapendtag(acNameBuffer, (gaplist.GetNext(pos)->m_dwEndOffset) + 1);
a815 1
	//	m_csGapListAndPartStatus is released here
d1275 7
a1281 1
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);
d1283 1
a1283 1
	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
a1284 1
		Gap_Struct * cur_gap = gaplist.GetNext(pos);
d1286 2
a1287 2
		uint32 gapstart = cur_gap->m_dwStartOffset;
		uint32 gapend = cur_gap->m_dwEndOffset;
d1325 1
a1325 1
					gapend = cur_gap->m_dwEndOffset;
a1329 3
	bool	bIsGapListEmpty = gaplist.IsEmpty();

	lockGap.Unlock();
d5507 3
a5509 2
	CString my_ChunkBar = _T("");
	for (uint16 i = 0;i <= size + 1;i++)
d5966 17
a5982 1
}@


1.489
log
@Two more fixes for the previous change.
@
text
@a577 1
	m_dblPercentCompletedPartsSize = static_cast<double>(m_dwCompletedPartsSize) / GetFileSize() * 100.0;
a931 1
			continue;
a938 1
			continue;
a945 1
			continue;
d949 1
a949 1
			return ;
d955 1
a955 1
	m_dwGapsSum += dwEnd - start ;
a1180 1
			continue;
d1264 1
a1264 1
		return ;
a1339 1
	uint32	wc = (uint32)(m_dblPercentCompletedPartsSize / 100.0 * w + 0.5);
d1353 1
d1355 1
a1355 1
		CBrush* pOldBrush;
d1856 1
a1856 1
								     || (::GetTickCount() - pSource->GetLastAskedTime()) > LANCASTFILEREASKTIMEUDP )
a4795 1
					m_dblPercentCompletedPartsSize = static_cast<double>(m_dwCompletedPartsSize) / GetFileSize() * 100.0;
a4815 1
					m_dblPercentCompletedPartsSize = static_cast<double>(m_dwCompletedPartsSize) / GetFileSize() * 100.0;
@


1.488
log
@correction. thanks Aw3
@
text
@d233 1
a579 1

d4800 1
a4800 5
					if (uPartNumber == GetPartCount())
						m_dwCompletedPartsSize += GetFileSize() % PARTSIZE;
					else
						m_dwCompletedPartsSize += PARTSIZE;

d4820 3
@


1.487
log
@some optimization of StatusBar drawing
@
text
@d4800 5
a4804 1
					m_dwCompletedPartsSize += PARTSIZE;
@


1.486
log
@Reinstated part of the change
@
text
@d231 2
a232 1

d566 14
a1273 2
	uint32 allgaps = 0;

a1279 1
		allgaps += cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
d1285 4
a1288 1
			if (gapstart >= i * PARTSIZE && gapstart <= (i + 1) * PARTSIZE)
d1290 1
a1290 1
				if (gapend <= (i + 1) * PARTSIZE)
d1294 1
a1294 1
					gapend = (i + 1) * PARTSIZE; // and next  part
a1337 37
//	Confirmed download
	if (!bIsGapListEmpty || (requestedblocks_list.GetCount() != 0))
	{
	//	all this here should be done in the Process, not in the drawing!!! its a waste of cpu time, or maybe not :)
		confirmedsize = 0;
		for (uint32 i = 0; i < GetPartCount(); i++)
		{
			uint32	dwEnd = (i + 1) * PARTSIZE - 1;
			bool	lastChunk = false;
		//	Is this the last part
			if (dwEnd > GetFileSize())
			{
				dwEnd = GetFileSize();
				lastChunk = true;
			}

			if (IsComplete(i * PARTSIZE, dwEnd))
			{
				if (lastChunk == false)
					confirmedsize += PARTSIZE;
				else
					confirmedsize += GetFileSize() % PARTSIZE;
			}
		}

		completedsize = (GetFileSize() - allgaps - 1);

		m_dblPercentCompleted = static_cast<double>(completedsize) / GetFileSize() * 100.0;
		m_dblPercentConfirmed = static_cast<double>(confirmedsize) / GetFileSize() * 100.0;
	}
	else
	{
		m_dblPercentCompleted = 100.0;
		m_dblPercentConfirmed = 100.0;
		completedsize = GetFileSize();
	}

d1345 1
a1345 1
	uint32	wc = (uint32)(m_dblPercentConfirmed / 100.0 * w + 0.5);
d1354 1
a1354 1
		s_LoadBar.FillRange(0, confirmedsize, crProgress);
d1434 1
a1434 1

d4799 3
@


1.485
log
@Reverted some code and fixed another log line
@
text
@d2734 1
a2734 1
	StopFile();
d3641 1
a3641 1
void CPartFile::StopFile()
d3717 6
a3722 3
//	Update GUI information (if the file was paused for completing GUI will update in CompleteFile)
	UpdateDisplayedInfo(true);
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
a4103 4
//	If is not a movie file return false
	if (!IsMovie())
		return false;

d5105 1
a5105 1
void CPartFile::UpdateDisplayedInfo(boolean bForce)
@


1.484
log
@More file sharing corrections to allow read-only access for other applications (official).
@
text
@d2734 1
a2734 1
	StopFile(false);
d3641 1
a3641 1
void CPartFile::StopFile(bool bCancel /*=true*/)
d3673 2
a3674 5
			if (bCancel)
			{
				g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
				pSource->m_pRequestSocket->SendPacket(packet, false, true);
			}
d3718 2
a3719 5
	if (bCancel)
	{
		UpdateDisplayedInfo(true);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
	}
@


1.483
log
@correction :) thanks Aw3
@
text
@d380 1
a380 1
		if (!file.Open(m_strFullName, CFile::modeRead))
@


1.482
log
@optimization of gap sum calculation :)
@
text
@d1174 1
a1174 1
			m_dwGapsSum -= cur_gap->m_dwStartOffset - dwEnd;
d1179 1
a1179 1
			m_dwGapsSum -= start - cur_gap->m_dwEndOffset;
@


1.481
log
@WebServer: added Get First/Last chunk for Preview
@
text
@d229 2
d301 1
d916 1
d924 1
d932 1
d944 1
d1168 1
d1174 1
d1179 1
d1189 1
d1206 1
a1206 11
	uint32 allgaps = 0;

	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);
	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL; )
	{
		Gap_Struct * cur_gap = gaplist.GetNext(pos);
		allgaps += cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
	}
	lockGap.Unlock();

	if ((allgaps != 0) || (requestedblocks_list.GetCount() != 0))
d1208 2
a1209 2
		m_dblPercentCompleted = ((1.0 - static_cast<double>(allgaps + 1) / GetFileSize())) * 100;
		completedsize = (GetFileSize() - allgaps - 1);
d4362 1
a4362 7
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on exit

	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
	{
		Gap_Struct * cur_gap = gaplist.GetNext(pos);
		pui32SizeToTransfer += cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
	}
@


1.480
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d5958 36
@


1.479
log
@Some changes on PreviewAvailable function
@
text
@d811 1
a811 1
		AddDebugLogLine(false, RGB_LOG_ERROR_TXT _T("Failed to remove '%s' - %s"), m_strFullName, _tcserror(errno));
d815 1
a815 1
		AddDebugLogLine(false, RGB_LOG_ERROR_TXT _T("Failed to move temporary part.met file '%s' to '%s' - %s"), strTempName, m_strFullName, strerror(errno));
d1629 1
a1629 1
					AddDebugLogLine(false, _T("%s: corruption of m_downloadingSourceList"), __FUNCTION__);
d2315 1
a2315 1
	//	AddDebugLogLine(false, "Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2542 1
a2542 1
	//	AddDebugLogLine(false, "Priority 1 (Unique unfinished part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2558 1
a2558 1
	//	AddDebugLogLine(false, "Priority 2 (Unique unrequested part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2566 1
a2566 1
	//	AddDebugLogLine(false, "Priority 3 (Rarest unfinished part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2582 1
a2582 1
	//	AddDebugLogLine(false, "Priority 4 (Rarest unrequested part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2588 1
a2588 1
	//	AddDebugLogLine(false, "Priority 5 (Preview part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2596 1
a2596 1
	//	AddDebugLogLine(false, "Priority 6 (Widespread unfinished part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2604 1
a2604 1
	//	AddDebugLogLine(false, "Priority 7 (Widespread unrequested part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2612 3
a2614 3
	AddDebugLogLine(false, "ICR-Test: File: %s, A-parts : %u, BP-Parts %u. Choosen Part: %u, P-Freq: %u, blocked %s",
		GetFileName(), nNumAvailableNeededParts, nNumPartiallyBlockedParts, nGoodPart, m_srcPartFrequencies[nGoodPart],
		((m_BlockedParts[nGoodPart] == PARTIALLY_BLOCKED)? _T("yes"):_T("no")));
d2839 1
a2839 1
				AddDebugLogLine(false, RGB_LOG_ERROR_TXT _T("Couldn't delete fakes.rar (%s)"), strFakesFile);
d2849 1
a2849 1
					AddDebugLogLine(false, RGB_LOG_ERROR_TXT _T("Couldn't delete fakes.rar (%s)"), strFakesFile);
d2955 1
a2955 1
				AddDebugLogLine(false, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
d2993 1
a2993 1
				AddDebugLogLine(false, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
d3021 1
a3021 1
			AddDebugLogLine(false, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
d4337 1
a4337 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("Received invalid source exchange packet (v%u) of data size %u for %s"), byteSourceExchangeVersion, uDataSize, GetFileName());
d4646 1
a4646 1
		AddDebugLogLine(false, _T("File '%s' has already been written from %lu to %lu size %lu"), GetFileName(), dwStart, dwEnd, lenData);
d5287 1
a5287 1
		AddDebugLogLine(false, _T("Generated ed2k link with %i sources for file '%s' (part count %u)"), (int)srcstoadd.GetCount(), GetFileName(), GetPartCount());
d5293 1
a5293 1
			AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("| User: %s - Available part count: %u"), pSource->GetUserName(), (int)pSource->GetAvailablePartCount());
d5887 1
a5887 1
		AddDebugLogLine( false, RGB_LOG_ERROR_TXT _T("Preallocate for file %s: error %s"),
@


1.478
log
@Minor changes for movie preview
@
text
@d2305 1
a2305 1
//	Mode 4=MPG(1F),5=MPG(2F),6=MPG(3F),7=AVI/MPG(2F,2L) F=First,L=Last
d4095 1
a4095 1
	uint64 space = GetFreeDiskSpaceX(m_strTempDir);
d4100 1
a4100 1
		if (GetFileSize() > 1024 && GetCompletedSize() > 1024 && !m_bRecoveringArchive && ((space + 100000000) > (2 * GetFileSize())))
d4106 1
a4109 1
//	KuSh: if paused it is allowed but if stopped it isn't, is it a feature ?
d4111 5
a4115 3
		return !( (GetStatus() != PS_READY && GetStatus() != PS_PAUSED)
		          || m_bPreviewing || GetPartCount() < 5 || !IsMovie() || (space + 100000000) < GetFileSize()
		          || (!IsComplete(0, PARTSIZE - 1) || !IsComplete(PARTSIZE * (GetPartCount() - 1), GetFileSize() - 1)) );
d4128 1
a4128 2
			eFileStatus = GetStatus();
			if (!(eFileStatus == PS_READY || eFileStatus == PS_EMPTY || eFileStatus == PS_PAUSED))
d4132 1
d4141 1
d4146 1
a4146 1
				bMPEG = (strExt == _T(".mpg") || strExt == _T(".mpeg") || strExt == _T(".mpe") || strExt == _T(".mp3") || strExt == _T(".mp2") || strExt == _T(".mpa"));
d4166 3
a4168 3
			eFileStatus = GetStatus();
			return !( ((eFileStatus != PS_READY) && (eFileStatus != PS_PAUSED))
			          || m_bPreviewing || GetPartCount() < 2 || !IsMovie() || !IsComplete(0, PARTSIZE - 1) );
@


1.477
log
@Added some more movie formats to preview
@
text
@d2472 1
a2472 1
				case 7:	//	7 = AVI/MPG(2F,2L)
d2474 1
a2474 1
					if (iPartCount > 3 && (i == iPartCount - 2))
@


1.476
log
@minor changes.
@
text
@d3380 2
a3381 1
	return (_tcsstr(fname, _T(".avi")) || _tcsstr(fname, _T(".ogm")) || _tcsstr(fname, _T(".divx")));
d3395 2
a3396 1
	return (_tcsstr(fname, _T(".mpg")) || _tcsstr(fname, _T(".mpe")) || _tcsstr(fname, _T(".bin")));
@


1.475
log
@Removed debug log translations + minor additions + minor change
@
text
@d2960 1
a2960 1
	//	Check for exception that will be throw by "new"
@


1.474
log
@removed doubled code
@
text
@d88 1
a88 1
			throw GetResString(IDS_ERR_NOTAFILELINK);
d2766 1
a2766 1
			throw CString(_T("Error creating file complete thread"));
d2892 1
a2892 1
				throw CString(GetResString(IDS_ERR_SLOWREAD) + _T(" (") + partfilename + _T(')'));
d2898 1
a2898 1
				throw CString(GetResString(IDS_ERR_SLOWWRITE) + _T(" (") + strTempNew + _T(')'));
d2929 1
a2929 1
				throw CString(GetResString(IDS_ERR_RENFAIL));
@


1.473
log
@Added debug log line
@
text
@d1322 1
a1322 1
//--- xrmb:confirmeddownload ---
d1331 1
a1331 1
		//--- last part? ---
a1404 12
//--- :xrmb ---

	if (!bIsGapListEmpty || (requestedblocks_list.GetCount() != 0))
	{
		m_dblPercentCompleted = ((1.0 - static_cast<double>(allgaps + 1) / GetFileSize())) * 100;
		completedsize = (uint32)((GetFileSize() - (allgaps + 1)));
	}
	else
	{
		m_dblPercentCompleted = 100.0;
		completedsize = GetFileSize();
	}
@


1.472
log
@removed m_uMedian
@
text
@d2850 3
a2852 1
			::DeleteFile(strFakesFile);
d2860 2
a2861 1
				::DeleteFile(strFakesFile);
@


1.471
log
@Fixed presumable completion deadlocks created by the new completion algorithm;
Fixed automatical antivirus start even it antivirus is disabled;
Fixed passing incorrect file name for antivirus check in automatical mode;
Fixed passing of file name contained spaces to automatical antivirus check;
Provide parameters and then file names for antivirus applications should be more compatible;
(more antivirus issues than lines in the code).
@
text
@a186 1
	m_uMedian = 0;
a2217 3
//	Calculate a median position
	//uint32		dwIdxMedian = ((dwPartCount - 1) >> 1);
	//uint16		uNewMedian = 0;
a2235 1
					//uint32	j = 0;
a2242 7
							/*
							if (j == dwIdxMedian)
							{
								uNewMedian++;
							}
							j++;
							*/
a2256 1
	//m_uMedian = uNewMedian;
d2402 1
a2402 1
	uint16		uRarestPart = 4; //static_cast<uint16>(floor(0.2 * m_uMedian)); // 10% from median (20%)
a2449 1
		//	if (m_uMedian >= (uRarestPart + m_srcPartFrequencies[i]))
d2454 1
a2454 1
					for (int j = 0; j < (uRarestPart/*m_uMedian*/ - m_srcPartFrequencies[i] + 1); j++)
d2624 2
a2625 2
	AddDebugLogLine(false, "ICR-Test: File: %s, A-parts : %u, BP-Parts %u. Choosen Part: %u, median %u, P-Freq: %u, blocked %s",
		GetFileName(), nNumAvailableNeededParts, nNumPartiallyBlockedParts, nGoodPart, m_uMedian, m_srcPartFrequencies[nGoodPart],
@


1.470
log
@using temporary frequenzy array; commented out m_uMedian calculation
@
text
@d2881 2
a2882 2
	CString newname;
	newname.Format(_T("%s\\%s"), GetOutputDir(), g_eMuleApp.StripInvalidFilenameChars(GetFileName()));
d2884 2
a2885 2
	if (!PathFileExists(GetOutputDir()))
		::CreateDirectory(GetOutputDir(), 0);
d2891 1
a2891 1
		GenerateNewFileName(GetOutputDir(), newname);
d2959 1
a2959 1
			SetPath(GetOutputDir());
d2962 1
a2962 1
			SetStatus(PS_COMPLETE);
d2967 3
a3033 1
	//	will be unlocked on block exit
d3050 2
a3060 1
		//	m_csFileCompletion is released here
d3065 1
a3065 1
		SetPath(GetOutputDir());
d3068 1
a3068 1
		SetStatus(PS_COMPLETE);
d3070 5
a3074 1
	//	m_csFileCompletion is released here
d3173 2
a3174 1
	if (g_eMuleApp.m_pGlobPrefs->IsAVScanCompleted() && !g_eMuleApp.m_pGlobPrefs->GetAVPath().IsEmpty())
d3176 2
a3177 3
		CString strBuffer;
		strBuffer += GetPath() + ((bRenamed)?(newname): m_strFullName) + _T(" ") + g_eMuleApp.m_pGlobPrefs->GetAVParams();
		ShellExecute(NULL, "open", g_eMuleApp.m_pGlobPrefs->GetAVPath(), strBuffer, NULL, SW_SHOW);
d5834 5
@


1.469
log
@Temporary file wasn't deleted after failure of completion copy;
Initialization doesn't work after failure of completion copy
(this problem was created by new completion algorithm).
@
text
@d187 1
d2216 1
d2220 2
a2221 1
	uint32		dwIdxMedian = ((dwPartCount - 1) >> 1);
d2223 4
a2226 12
//	Increase size if necessary
	if (static_cast<uint32>(m_srcPartFrequencies.GetSize()) < dwPartCount)
	{
		m_srcPartFrequencies.SetSize(dwPartCount);
	}

//	Reset part counters & median
	for (uint32 i = 0; i < dwPartCount; i++)
	{
		m_srcPartFrequencies[i] = 0;
	}
	m_uMedian = 0;
d2228 1
a2228 3
	CUpDownClient*	pSource;
	POSITION		pos;
	uint16			nNewCompleteSrcCount = 0;
d2234 1
a2234 1
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
d2240 2
a2241 2
					uint32		j = 0;
				//	count available parts from source
d2246 3
d2251 1
a2251 1
								m_uMedian++;
d2254 1
a2254 2
							m_srcPartFrequencies[i] += 1;
							dwSourcePartsCounter++;
d2257 1
a2257 1
				//	count full sources
d2261 1
a2261 1
						nNewCompleteSrcCount++;
d2268 8
a2275 1
	m_nLastCompleteSrcCount = nNewCompleteSrcCount;
d2278 2
a2279 2
	uint32	dwAvailableParts = 0;
//	count available parts over all sources
d2282 2
d2286 1
a2286 1
			dwAvailableParts++;
d2296 1
a2296 1
	m_dwAvailablePartsCount = dwAvailableParts;
d2298 1
a2298 1
	if (dwAvailableParts == dwPartCount)
d2303 1
@


1.468
log
@BUGFIX: own file comments and ratings were not shown (and no rating symbol) until a second rating was received
@
text
@d2897 5
a2901 2
		CFile fInputFile;
		CFile fOutputFile;
d2904 1
a2904 4
			CString strTempNew = newname;
			strTempNew += _T(".$$$");

		//	We going to write everything into the temporary file at same place the newname located
a2914 1
				fInputFile.Close();
d2973 1
a2973 1
			CFile::Remove(partfilename);
a2977 3
			fInputFile.Close();
			fOutputFile.Close();

d2980 1
a2980 3
			m_bPaused = true;
			SetStatus(PS_ERROR);
			return FALSE;
d2985 1
a2985 3
			m_bPaused = true;
			SetStatus(PS_ERROR);
			return FALSE;
d2987 1
a2987 1
		catch (CException* error)
d2995 22
d3019 1
a3019 1
			error->Delete();
@


1.467
log
@:) forgot to remove some unneeded m_bUpdateCompleteSrcCount
@
text
@d673 3
d5001 11
d5081 11
@


1.466
log
@(showtopic=5819) cpu-optimized update of complete sources counter; corrected calculation of available parts counter
@
text
@a208 1
	m_bUpdateCompleteSrcCount = false;
@


1.465
log
@the fakelist wasn't reloaded after update
@
text
@a1509 21
uint16	CPartFile::GetCompleteSourcesCount()
{
	if (!m_bUpdateCompleteSrcCount)
		return m_nLastCompleteSrcCount;

	uint16 counter = 0;

	POSITION pos;
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
		if (!m_srcLists[sl].IsEmpty())
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
			{
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
				if (pSource->IsCompleteSource())
					counter++;
			}
	m_nLastCompleteSrcCount = counter;
	m_bUpdateCompleteSrcCount = false;
	return counter;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d2209 1
a2209 1
//	NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
a2216 1
	uint32		dwMaxAvailableParts = 0;
a2229 1
	CUpDownClient* pSource;
d2231 4
a2234 1
	POSITION pos;
d2244 1
a2244 1
					uint32		dwAvailablePartsCounter = 0;
d2246 1
a2246 1

d2252 1
d2254 1
d2257 1
a2257 1
							dwAvailablePartsCounter++;
d2260 6
a2265 2
					if (dwAvailablePartsCounter > dwMaxAvailableParts)
						dwMaxAvailableParts = dwAvailablePartsCounter;
d2271 5
a2275 1
	m_MaxSrcPartFrequency = 0;
d2277 4
a2280 2
		if (m_srcPartFrequencies[i] > m_MaxSrcPartFrequency)
			m_MaxSrcPartFrequency = m_srcPartFrequencies[i];
d2282 12
a2293 1
	if ((dwPartCount == dwMaxAvailableParts) && (m_dwAvailablePartsCount < dwPartCount))
d2295 1
a2295 2
	m_dwAvailablePartsCount = dwMaxAvailableParts;
	m_bUpdateCompleteSrcCount = true;
@


1.464
log
@another auto A4AF bugfix
@
text
@d3166 1
@


1.463
log
@Fixed new compression gain calculation (the issue was created in 1.460).
@
text
@d1851 1
a1851 1
								if (!pSource->SwapToAnotherFile(NULL, true))
d2048 1
a2048 1
								pSource->SwapToAnotherFile(NULL, true);
d2052 5
a2056 1
								if (!pSource->m_otherNoNeededMap.IsEmpty())
a2058 1

a2078 1
				bIsNNS = false;
d2081 5
a2085 1
					if (!pSource->m_otherNoNeededMap.IsEmpty())
d3206 1
a3206 1
				if (!pRemoveSource->SwapToAnotherFile(NULL))
@


1.462
log
@Fixed I.C.H. algorithm which redownloaded more data than required for recovery.
@
text
@d4610 1
a4610 1
uint32 CPartFile::WriteToBuffer(uint32 dwCompressionGain, BYTE *data, uint32 dwStart, uint32 dwEnd, Requested_Block_Struct *pBlock, bool bFreeBuff)
d4617 1
a4617 1
	if (dwCompressionGain != 0)
d4619 3
a4621 2
		m_iGainDueToCompression += dwCompressionGain;
		m_iSessionGainDueToCompression += dwCompressionGain;
@


1.461
log
@Fixed rx data sorting for better I/O performance (one entry was always not in order).
@
text
@d4686 7
a4692 1
			//	Prevent data flush during processesing of the data from the sockets
a4693 1
			m_ReqParts[dwPartNum] = PARTSIZE;
@


1.460
log
@Fixed processing of corrupted compressed packets;
Fixed file transferred amount calculation (compressed corrupted data and
data not associated with a request wasn't considered before);
Improved decompression memory handling and reduced amount of data recopyings;
Better strategy for rx data buffering (faster disk writing).
@
text
@d195 1
a195 1
	m_iLostDueToCorruption = 0;
d197 1
a197 1
	m_iSessionLostDueToCorruption = 0;
d667 1
a667 1
		m_iLostDueToCorruption = m_dwBytesTransferred - completedsize;
d4652 2
d4658 1
a4658 1
				m_BufferedData_list.InsertAfter(pos, item);
d4796 3
a4798 3
				//	Reduce transferred amount by corrupt amount
					this->m_iLostDueToCorruption += (partRange + 1);
					this->m_iSessionLostDueToCorruption += (partRange + 1);
@


1.459
log
@BUGFIX: permanently switching A4AF sources
@
text
@a1123 1
			//	block->m_dwPackedSize = 0;
d4604 1
a4604 1
// This includes compressed packets.
d4610 1
a4610 1
uint32 CPartFile::WriteToBuffer(uint32 transize, BYTE *data, uint32 dwStart, uint32 dwEnd, Requested_Block_Struct *block)
a4613 3
//	Increment transferred bytes counter for this file
	m_dwBytesTransferred += transize;

d4617 1
a4617 1
	if (lenData > transize)
d4619 2
a4620 2
		m_iGainDueToCompression += lenData - transize;
		m_iSessionGainDueToCompression += lenData - transize;
a4626 1
		return 0;
d4628 17
d4646 5
a4650 19
//	Create copy of data as new buffer
	BYTE *buffer = new BYTE[lenData];
	memcpy2(buffer, data, lenData);

//	Create a new buffered queue entry
	PartFileBufferedData *item = new PartFileBufferedData;
	item->m_pbyteBuffer = buffer;
	item->m_dwStartOffset = dwStart;
	item->m_dwEndOffset = dwEnd;
	item->block = block;

//	Add to the queue in the correct position (most likely the end)
	PartFileBufferedData *queueItem;
	bool added = false;
	POSITION pos = m_BufferedData_list.GetTailPosition();
	while (pos != NULL)
	{
		queueItem = m_BufferedData_list.GetPrev(pos);
		if (item->m_dwEndOffset > queueItem->m_dwEndOffset)
d4652 7
a4658 3
			added = true;
			m_BufferedData_list.InsertAfter(pos, item);
			break;
d4660 2
a4661 3
	}
	if (!added)
		m_BufferedData_list.AddHead(item);
d4663 2
a4664 2
//	Increment buffer size marker
	m_nTotalBufferData += lenData;
d4666 2
a4667 2
//	Mark this small section of the file as filled
	FillGap(item->m_dwStartOffset, item->m_dwEndOffset);
d4669 8
a4676 8
//	Update the flushed mark on the requested block
//	The loop here is unfortunate but necessary to detect deleted blocks.
	pos = requestedblocks_list.GetHeadPosition();
	while (pos != NULL)
	{
		if (requestedblocks_list.GetNext(pos) == item->block)
			item->block->m_dwBytesTransferred += lenData;
	}
d4678 3
a4680 3
	uint32 dwPartNum = dwStart / PARTSIZE;
	const uint32 uStart = dwPartNum * PARTSIZE;
	const uint32 uEnd = ((GetFileSize() - 1) < (uStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uStart + PARTSIZE - 1);
d4682 6
a4687 6
	if (IsComplete(uStart, uEnd))
	{
	//	Prevent data flush during processesing of the data from the sockets
		m_bDataFlushReq = true;
		m_ReqParts[dwPartNum] = PARTSIZE;
	}
d4689 1
a4689 1
	m_timeLastDownTransfer = CTime::GetCurrentTime();
d4691 3
a4693 2
//	Return the length of data written to the buffer
	return lenData;
d4697 3
d4710 1
a4710 1
	m_nLastBufferFlushTime = GetTickCount();
@


1.458
log
@Removed Drop SuperCompressed blocks feature from GUI
@
text
@d2032 1
a2032 1
		if (((!m_LastNoNeededCheck) || (dwCurTick - m_LastNoNeededCheck) > 10000))
d2054 1
d2057 4
a2060 3
								if (!bIsNNS || (dwCurTick - dwLastNoNeededCheckTime) > FILEREASKTIME)
								{
									pSource->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
d2081 1
d2083 4
a2086 3
					if (!bIsNNS || (dwCurTick - dwLastNoNeededCheckTime) > FILEREASKTIME)
					{
						pSource->SwapToAnotherFile(this);
@


1.457
log
@More DebugLog formating and changes
@
text
@a201 1
	m_bDiscardSuperCompressed = false;
d1669 1
a1669 1
			//	Since client can be droped due timeout we need to check the state again
d1740 1
a1740 1
						//	Since client can be droped due timeout we need to check the state
d4545 1
a4545 1
//	LoadSettingsFile() loads settings for partfiles (Movie Preview Mode, Stopped status, Discard SCB, Preallocation)
a4559 1
		m_bDiscardSuperCompressed = filesettings.GetBool(_T("DiscardSuperCompressed"), false);
d4569 1
a4569 1
//	SaveSettingsFile() save settings for partfiles (Movie Preview Mode, Stopped status, Discard SCB, Preallocation)
a4581 1
	filesettings.SetBool(_T("DiscardSuperCompressed"), m_bDiscardSuperCompressed);
@


1.456
log
@Fixed bugs with AV-support; reverted unneeded changes, removed redundant try/catch (thanks to Aw3 !)
@
text
@d36 1
a36 7

//	Barry - use this constant for both places
#define PROGRESS_HEIGHT 4	//netwolf 06.05.03 (was 3)
/*	Maella - removed mem leak
CBarShader CPartFile::s_LoadBar(PROGRESS_HEIGHT); // Barry - was 5
CBarShader CPartFile::s_ChunkBar(16);
*/
d117 1
a117 1
		//m_strFileName = CString(fileLink->GetName());
d120 1
a120 1
	//	Ultras: prevent to donload an empty file
d127 1
a127 1
	//	Don't ask for a hashset, if there is none.
a203 1
//	Tarod
d221 1
a221 1
//eklmn: it's need to initialize this variable to prevent extra screen refreshing
d226 1
a226 1
	//async data flush (i.e. only in process)
d229 2
a230 1
	m_bIsFakesDotRar = false;	// set to true for fakes.rar download
d253 2
a254 1
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on exit
d364 1
a364 1
	CMap<uint16, uint16, Gap_Struct*, Gap_Struct*> gap_map; // safe Load Gaps [SlugFiller]
d369 1
a369 1
	m_strTempDir = in_directory;	// added by InterCeptor (multiple tempdirs) 19.11.02
d371 1
a371 1
		m_strTempDir.Truncate(m_strTempDir.GetLength() - 1);	// added by InterCeptor (check for \\) 19.11.02
d548 1
a548 1
//	Now to flush the map into the list (Slugfiller)
d558 2
a559 2
				gap->m_dwEndOffset = GetFileSize() - 1; // Clipping
			AddGap(gap->m_dwStartOffset, gap->m_dwEndOffset); // All tags accounted for, use safe adding
d593 1
d612 1
d640 1
d648 1
a648 1
//	Check date of .part file - if its wrong, rehash file
d651 2
a652 1
	m_hPartFileWrite.GetStatus(filestatus); // this; "...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are... :)
d669 1
d696 2
a697 1
	CSingleLock sLock(&m_csSavePartFile, TRUE); // will be unlocked on exit
d720 1
a720 1
	//create a temporary file
a726 1
	//CFile file;
d800 2
a801 1
		_tremove(strTempName); // remove the partially written or otherwise damaged temporary file
d956 2
a957 1
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on exit
d963 1
a963 1
		if ( (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= dwEnd)	// gap is inside range (this check is unnecessary)
d1228 1
a1228 1
//	SLUGFILLER: grayPause - Colors by status
a1242 1
//	SLUGFILLER
d1260 1
a1260 1
//	red gaps
a1283 1
				//	SLUGFILLER: grayPause
a1293 1
			//	SLUGFILLER: grayPause
d1313 1
a1313 1
//	yellow pending parts
d1359 1
a1359 1
//	green progress
d1362 1
a1362 1
	gaprect.bottom = gaprect.top + PROGRESS_HEIGHT; // Barry - was 4
d1371 1
a1371 1
		CBarShader s_LoadBar(PROGRESS_HEIGHT); // No use of static element
d1383 1
a1383 1
	//	green
d1389 1
a1389 1
	//	yellow
d1396 1
a1396 1
	//draw gray progress only if flat
a1432 1
		//--- xrmb:partprio ---
a1433 1
			//--- :xrmb ---
a1461 1
//	netwolf: complete sources (zegzav) 03.05.03
a1511 1
//	netwolf: complete sources (zegzav)
d1597 1
a1597 1
					removed ++; // Count removed source
d1624 3
a1626 3
//	1) it was requested (at 19.03.2004 it is WriteToBuffer())
//	2) buffer size exceeds limit
//	3) data was not written within time limit
d1644 1
a1644 1
//	calculate data rate, set limit etc.
d1659 1
a1659 1
				//eklmn: if new client has non DL state, then remove him
d1662 1
a1662 1
					AddDebugLogLine(false, "-eklmn->: corruption of m_downloadingSourceList");
d1669 2
a1670 1
				//eklmn: since client can be droped due timeout it needs to check the state
d1741 1
a1741 1
						// eklmn: since client can be droped due timeout it needs to check the state
d1744 1
a1744 1
						// DonGato: needed to update the source count
a1787 1
					//	if the request socket doesn't exist or isn't connected
d1790 1
d1793 1
a1793 1
							//	DonGato: it was DS_NONE before but that keeps for some time problematic clients.
d1825 2
a1826 1
						case DS_LOWTOLOWIP: 	// if we now have a high ip we can ask
d1860 2
a1861 2
						//	doubled reasktime for no needed parts - save connections and traffic
						//	Vorlost, noneededparts-sources will be checked filereasktime*4 when 3/4 of max. sockets are open
d1903 1
a1903 1
							if (pSource->GetRemoteQueueRank() && bSocketsUsageIsHigh)  // Vorlost QueueRank > 250
d1906 1
a1906 1
									usethisfilereasktime = FILEREASKTIME * 2.5 ; // Vorlost 54:10 minutes
d1908 1
a1908 1
									usethisfilereasktime = FILEREASKTIME * 2; // Vorlost (QR 1-250 = 43:20 minutes)
a1932 1
						//	START enkeyDEV(th1) -L2HAC- highid side, "prepare" phase
d1992 1
a1992 1
					} // switch (state)
d1996 2
a1997 2
					//	LANCAST (moosetea) - Because reask much faster if lancast user ie we may reask as soon as we get disconnected
					//	, we only use TCP on a LAN, because emule may try to send a TCP request and UDP request at the same time!
d2010 2
a2011 2
	//	-khaos--+++> Set the members using temp vars.  We have to use temporary vars so that the disp counts
	//	don't get screwed up during processing.  We don't need to count this, cause we can get a transferring
d2029 2
a2030 4
	//	swap a source with NNS status if possible
	//	v:- eklmn: A4AF management
	//	Modified by Tarod -now handles A4AF too keeping usage of CPU less and do not forcing files
	//	that has No Needed Parts to download letting them swap to another file
d2044 1
a2044 1
					//	check if current source has a part for this file
d2047 1
a2047 1
						//	check if A4AF Auto file is enable
d2068 1
a2068 1
	//	if this "File" is A4AF auto & A4AF list isn't empty,
d2072 1
a2072 1
		//eklmn: use a two-pointer loop to prevent exception due to swaping (delete)
d2091 4
a2094 4
	//	check if we want new sources from server
	//	1) connection state will be checked in DL-queue manager, so we don't need to do it here
	//	2) we can call SetRequiredSourcesRefresh() so many time as we want, cause this function
	//	    check existency of the file.
d2098 1
a2098 1
		//	local server
d2110 1
a2110 1
	//	calculate data rate, set limit etc. (every 5sec)
d2129 1
a2129 3
	//
	//	Changes in file status can affect whether the file belongs to a predefined category
	//	or not.
d2135 1
a2135 1
	//	If we're displaying file counts in the tabs, update them to reflect status changes.
a2181 1
	//	check first if we are this source
d2185 1
d2222 1
a2222 1
//	v- eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d2229 1
a2229 1
	uint32		dwIdxMedian = ((dwPartCount - 1) >> 1);	// <- eklmn: feature(00): ICR
d2243 1
a2243 1
	m_uMedian = 0;     // <- eklmn: feature(00): ICR
d2257 1
a2257 1
					uint32		j = 0; // <- eklmn: feature(00): ICR v2
d2264 2
a2265 2
								m_uMedian++;       // <- eklmn: feature(00): ICR
							j++;                            // <- eklmn: feature(00): ICR
d2268 1
a2268 1
						} // end: IsPartAv...
d2277 1
a2277 1
	m_MaxSrcPartFrequency = 0;	// <- eklmn: feature(00): ICR
d2285 1
a2285 1
	m_bUpdateCompleteSrcCount = true;	// netwolf: zegzav:completesrc
d2292 1
a2292 1
//	v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.13, 27.02.2004) for eMule+
d2323 1
a2323 1
	//AddDebugLogLine(false, "Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2341 1
a2341 1
//
d2360 1
a2360 1
//
d2376 3
a2378 3
			//eklmn: let's check if all gaps in part were already requested
			// please note that second parameter is NULL, what should not lead to crash
			// due to pointer check in GetNextEmptyBlockInPart
d2381 1
a2381 1
				//eklmn: no gaps found => fully blocked
d2386 1
a2386 1
				//eklmn: count the blocked parts only in case if they are available & was not counted before
d2398 1
a2398 1
	uint16		uRarestPart = 4;//static_cast<uint16>(floor(0.2 * m_uMedian)); // 10% from median (20%)
d2400 2
a2401 1
	//if (uRarestPart < 4) uRarestPart = 4;
d2403 1
a2403 1
// define a shortest-to-complete condition, cause it will be inverted if all needed parts are downloaded
d2426 1
a2426 1
		//		it first in order to prevent file disappearing)
d2437 1
a2437 1
				//		than any other one-source part seen so far...
d2446 1
a2446 1
			//if (m_uMedian >= (uRarestPart + m_srcPartFrequencies[i]))
d2462 1
a2462 1
			} // end rarest
d2525 1
a2525 1
				//eklmn: invert condition shortest-to-complete condition if all parts are partially blocked
d2540 3
a2542 3
			} // end widespreaded
		} // end: if....
	} // end for
a2754 1
	//
d2799 2
a2800 1
//search for matching ()s and check if it contains a number inside
d2805 1
d2807 1
a2807 1
		{ //check for ) existence or () situation
d2810 2
a2811 1
			{	//check for digits inside brackets
a2838 1
//
d2921 2
a2922 1
				Sleep(0); // Release the CPU for other processes
d2935 1
a2935 1
			//	let catch to care about closing everything
d2964 2
a2965 1
		catch (CMemoryException * error)	//	Check for exception that will be thow by "new"
d3000 2
a3001 1
		CSingleLock lockComplete(&m_csFileCompletion, TRUE);	// will be unlocked on block exit
d3112 3
a3114 3
	g_eMuleApp.m_pGlobPrefs->Add2DownCompletedFiles();		// Increments cumDownCompletedFiles in prefs struct
	g_eMuleApp.m_pGlobPrefs->Add2DownSessionCompletedFiles(); // Increments sesDownCompletedFiles in prefs struct
	g_eMuleApp.m_pGlobPrefs->SaveCompletedDownloadsStat();	// Saves cumDownCompletedFiles to INI
d3141 1
a3141 1
//
d3278 1
a3278 1
//Cax2 - file properties get deleted inside one of these calls now...
d3391 1
a3391 1
		dwEnd = (PARTSIZE * chunk) + (lastblock * EMBLOCKSIZE) - 1; //Endadress from 1chunk before the last chunk
d3470 1
a3470 1
//The routine is based on that both old&new-chunk are moviechunks
d3474 4
a3477 4
		if ( IsComplete(0, (MINFIRSTMOVIESIZE) - 1) //first 1/8 chunk present
		     && !IsComplete((GetFileSize() - 1) - (MINLASTMOVIESIZE) , GetFileSize() - 1) //last 1/8 chunk not present
		     && ( newchunk == GetPartCount() - 1  //better chunk could be 1L
		          || (newchunk == GetPartCount() - 2) ) ) //better chunk could be 2L
d3483 5
a3487 5
		if ( ( ( !IsComplete(0, (MINFIRSTMOVIESIZE) - 1) //first 1/8 chunk not present
		         && IsComplete((GetFileSize() - 1) - (MINLASTMOVIESIZE) , GetFileSize() - 1) ) //last 1/8 chunk present
		       || ( IsComplete(0, (MINFIRSTMOVIESIZE) - 1) //first 1/8 chunk present
		            && IsComplete((GetFileSize() - 1) - (MINLASTMOVIESIZE) , GetFileSize() - 1) ) //last 1/8 chunk present
		       && newchunk == 0 ) )  //better chunk could be 1F
d3510 1
a3510 1
//Movie1 disables (movie --> normal) & (movie --> worst movie)
d3532 1
a3532 1
//Movie2 enables (normal --> movie) & (movie --> better movie)
d3538 3
a3540 3
	                      && m_srcPartFrequencies[newchunk] > raremovie )      //old & new chunk are nonrare
	                    || (m_srcPartFrequencies[oldchunk] == m_srcPartFrequencies[newchunk]) //old & new chunk are same rare
	                    || forcepreview ) )            //Load preview chunks first no matter of rareness
d3542 2
a3543 2
	//This Line just for debugging:
	//AddLogLine(true, CString("Movie2::Mode:%d old:%d new:%d rarem:%d - The new & old ones are nonrare,samerare or forced, now we decide if new is a better movie or could change to movie..."),mode,oldchunk,newchunk,raremovie);
d3593 1
a3593 1
//	Barry - Also want to preview zip/rar files
d4045 1
a4045 1
		// If path has spaces use quotes
d4073 2
a4074 1
	if (eFileStatus == PS_COMPLETING || eFileStatus == PS_COMPLETE || eFileStatus == PS_HASHING)		// no preview! :)
d4079 1
a4079 1
//	Barry - Allow preview of archives of any length > 1k
d4101 1
a4101 1
	//	enable the preview command if the according option is specified 'PreviewSmallBlocks'
d4371 1
a4371 1
//	making this function return a higher when more sources have the extended
d4391 1
a4391 1
//--- if we cant open this file... you lose the stats ---
d4395 1
a4395 1
//--- get version ---
d4425 3
a4427 3
//--- this is for the parttraffic ---
//--- i thought about explicit adding the traffic like for the other stats above ---
//--- but it doesnt make sense, because you'll no transfer if you reach this ---
d4449 1
a4449 1
//--- if we cant open this file... you lose the stats ---
d4453 1
a4453 1
//--- set version ---
d4481 1
a4481 1
//--- this is for the parttraffic ---
d4498 1
a4498 1
//	Used as separate thread to complete file [Lord KiRon]
d4593 1
a4593 1
// Barry - Replaces BlockReceived()
d4595 3
a4597 3
//         Originally this only wrote to disk when a full 180k block
//         had been received from a client, and only asked for data in
//         180k blocks.
d4599 2
a4600 2
//		   This meant that on average 90k was lost for every connection
//		   to a client data source. That is a lot of wasted data.
d4602 3
a4604 3
//		   To reduce the lost data, packets are now written to a buffer
//		   and flushed to disk regularly regardless of size downloaded.
//		   This includes compressed packets.
d4606 3
a4608 3
//		   Data is also requested only where gaps are, not in 180k blocks.
//		   The requests will still not exceed 180k, but may be smaller to
//		   fill a gap.
d4682 2
a4683 2
		//eklmn: prevent data flush during processesing of the data from the sockets
		m_bDataFlushReq = true;	//FlushBuffer();
d4712 1
a4712 1
	GetAvgDataRate(true);	//SyruS do update on flushing
a4717 2
//	AddDebugLogLine(false, "Flushing file %s - buffer size = %ld bytes (%ld queued items) transferred = %ld [time = %ld]\n", GetFileName(), m_nTotalBufferData, m_BufferedData_list.GetCount(), transferred, m_nLastBufferFlushTime);

a4719 1
	//
a4720 1
	//
d4731 1
a4731 1
			m_hPartFileWrite.SetLength(item->m_dwEndOffset + 1);	// netwolf: file should not be too large (taab)
d4757 2
a4758 2
	//	If the size of the part file is greater than the size of the target file, set it to the
	//	size of the target file.
d4811 1
a4811 1
					//	Successfully completed part, make it available for sharing
d4852 1
a4852 1
		//	Purity - Sending message for insufficient diskspace
d4880 2
a4881 2
//	Barry - This will invert the gap list, up to caller to delete gaps when done
//	'Gaps' returned are really the filled areas, and guaranteed to be in order
d4892 2
a4893 1
	CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on exit
a4961 1
//	#zegzav:pastcomment
d5021 1
a5021 1
				//	Cax2 - bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
a5030 1
//	#zegzav:pastcomment
d5038 1
a5038 1
		//Cax2 - bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
d5049 1
a5049 1
	//	Cax2 - bugfix: for some $%#ing reason good=3 & fair=4, breaking the progression from fake(1) to excellent(5)
d5071 1
a5071 2
//	enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
//v- eklmn: support Source Exchange v2
d5086 1
a5086 1
	//	although we are currently having a LowID, we could have had a HighID before, which
d5152 1
a5152 1
//	enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d5199 1
a5199 1
			g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),  // spaces to dots
d5208 1
a5208 1
		// !g_eMuleApp.m_pServerConnect->IsConnected() is not really needed since we give an ip but ...
d5217 1
a5217 1
	// is the expiration date is handle in other eMule mods ? a bIsSourceSaver is perhaps needed ...
a5249 1
//	START - enkeyDEV(Ottavio84) -ChangeDir-
d5278 1
a5278 1
			return strRetPath;	// Return the incoming dir.
d5339 1
a5339 1
			//
d5384 1
a5384 1
	if (GetTransferred() == 0 /*SyruS won't work: GetFileDate()==NULL*/)
d5468 2
a5469 2
	char crProgress = '0'; //green
	char crHave = '1';	// black
d5471 3
a5473 3
	char crMissing = '3';  // red
	char crWaiting[6]; // differents blue
	crWaiting[0] = '4'; // blue few source
d5496 3
a5498 2
	//	red gaps
		CSingleLock lockGap(&m_csGapListAndPartStatus, TRUE);	// will be unlocked on block exit
d5538 1
a5538 1
//	yellow pending parts
d5560 1
a5560 1
//vcf:- eklmn: A4AF management
a5564 2
//	AddDebugLogLine(false, _T("Total %u A4AF sources before swap"), m_A4AFsrcList.GetCount());

d5573 3
a5575 3
//eklmn: 1) CS method to prevent a problem by removing(adding) in the list
//		2) since the CS allows us to add client safe, it better to add client to head
//		this will speed up first respose to DL invitation
a5592 1
//v- eklmn: download fix
d5613 2
a5614 1
//	create partstatus + info in mobilemule protocol specs
d5643 1
d5645 1
d5653 1
d5661 1
a5664 1
//	#zegzav:pastcomment
d5668 1
d5670 1
a5670 1
		return ;
d5688 1
d5711 1
a5711 1
//	set new prio
d5872 2
a5873 1
	CSingleLock lockComplete(&m_csFileCompletion, TRUE);	// will be unlocked on exit
@


1.455
log
@minor changes, fixes and improvements
@
text
@d245 1
a245 1
	try
a248 5
	}
	catch(CFileException* error)
	{
		error->Delete();
	}
a249 2
	if (!m_bIsBeingDeleted && (m_hPartFileWrite.m_hFile != INVALID_HANDLE_VALUE))
	{
d620 1
a620 1
	if (iSize != GetED2KPartHashCount() && GetFileSize() >= PARTSIZE)
@


1.454
log
@code optimization (thanks to Aw3)
@
text
@d245 1
a245 1
	if (!m_bIsBeingDeleted && (m_hPartFileWrite.m_hFile != INVALID_HANDLE_VALUE))
d249 8
d622 1
a622 1
	SetStatus(PS_READY);
d627 1
a627 1
	if (iSize != GetED2KPartHashCount())
a628 1
		SetStatus(PS_EMPTY);
a634 1
		bool empty = true;
d638 5
a642 4
				empty = false;
		}
		if (empty)
			SetStatus(PS_EMPTY);
d1641 1
a1641 1
		|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)) ) //netwolf: increased FileBufferSize
d2166 1
a2166 1
//	If this part file is paused or complete/completing no sources needed any more
d2169 2
a2170 1
	if (eFileStatus == PS_STOPPED || eFileStatus == PS_COMPLETE || eFileStatus == PS_COMPLETING)
a2198 1
	//	MOD Note: Do not change this part - Merkur
a2221 1
	//	MOD Note - end
d2230 2
d2758 1
a2758 1
//Show completing instead of paused
a4289 1
//v- eklmn: support Source Exchange v2
d4294 1
a4294 1
//	If this part file is paused or complete/completing no sources needed any more.
d4297 3
a4299 2
	if ( (eFileStatus == PS_PAUSED) || (eFileStatus == PS_STOPPED) ||
		(eFileStatus == PS_COMPLETE) || (eFileStatus == PS_COMPLETING) )
@


1.453
log
@Tooltips string improvements
@
text
@d4196 1
d4198 2
a4199 2
			//	Don't send clients that have no parts available
				if ( pForClient == pPotentialSource || pForClient->Compare(pPotentialSource) || pPotentialSource->IsOnLAN()
d4203 3
a4205 3
						|| md4cmp(pPotentialSource->m_reqFileHash, pForClient->m_reqFileHash) != 0
						|| uPartCount != pPotentialSource->GetUpPartCount()
						|| pPotentialSource->GetAvailUpPartCount() == 0 )
@


1.452
log
@Fix for stopped files clearing of A4AF sources list
@
text
@d5450 2
a5451 10
	strInfo.Format( _T("<t=2><b>%s</b><br><t=2>%s (%u %s)<br>")
	             + GetResString(IDS_TT_PARTINFOS2)
	             + GetResString(IDS_TT_STATUS)
	             + GetResString(IDS_TT_HASH)
	             + GetResString(IDS_TT_PARTINFOS)
	             + GetResString(IDS_TT_PARTINFOS4)
	             + GetResString(IDS_TT_LASTSEENCOMPL)
	             + GetResString(IDS_TT_LASTCHANGE)
	             + GetResString(IDS_TT_STATUS2)
				 + GetResString(IDS_TT_SIZEONDISK),
d5453 8
a5460 6
	             static_cast<int>(GetPercentCompleted()), CastItoXBytes(GetCompletedSize()), strFileSz, strTransferSrcCount,
	             GetPartFileStatus(),
	             HashToString(GetFileHash()), ConcatFullPath(GetTempDir(), GetPartMetFileName()),
	             GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), dblAvailability,
	             strLastSeenComplete, strLastProgress,
	             GetOnQueueSrcCount(),
@


1.451
log
@corrected typo errors made in 1.450
@
text
@d3693 1
@


1.450
log
@Updated and corrected the CreateSrcInfoPacket function
Updated SourceExchange Protocol to v2
@
text
@d4248 1
a4248 1
					packetStream.Write(&nPort, 2);
d4250 2
a4251 2
					packetStream.Write(&nServerPort, 2);
					if (ppForClient->GetSourceExchangeVersion() > 1)
@


1.449
log
@Remove setvbuf 16384 for .part.met.tmp (default 4kb buffer is enough for .part.met);
Improved string processing.
@
text
@d2848 5
a2852 1
		CString strIncomingDir = g_eMuleApp.m_pGlobPrefs->GetIncomingDir();
a2853 3
		::PathAddBackslash(strIncomingDir.GetBuffer(MAX_PATH));
		strIncomingDir.ReleaseBuffer();
		::DeleteFile(strIncomingDir + _T("fakes.rar"));
d2855 1
d2858 3
a2860 1
			::DeleteFile(strSharedDirsList.GetNext(pos) + _T("fakes.rar"));
d4156 1
a4156 1
Packet*	CPartFile::CreateSrcInfoPacket(CUpDownClient* forClient)
d4160 1
a4160 1
	if (forClient->m_pReqPartFile != this)
d4166 5
a4170 5
	CMemFile data;
	uint16 nCount = 0;
	CUpDownClient* pSource;
	bool bNeeded;
	POSITION pos;
d4172 9
a4180 2
	data.Write(m_fileHash, 16);
	data.Write(&nCount, 2);
d4182 2
a4183 1
	const uint16 uPartCount = GetPartCount();
d4185 2
a4186 1
	for (int sl = 0;sl < SOURCESSLOTS;sl++)
d4188 2
a4189 1
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
d4191 1
a4191 15
				bNeeded = false;
				pSource = m_srcLists[sl].GetNext(pos);

			//	eklmn: don't send a client to himself as a source
				if (forClient == pSource)
					continue;

			//	Modified by Tarod -sends sources with LowID that are in same sever
			//	that client is requesting sources
				if ( pSource->HasLowID()
				     && ( pSource->GetServerIP() != forClient->GetServerIP()
				          || pSource->GetServerPort() != forClient->GetServerPort() ) )
				{
					continue;
				}
d4193 11
a4203 2
			//	LANCAST (moosetea) - We don't share Lan clients sources as they are private ips/userids
				if (pSource->IsOnLAN())
d4206 2
a4207 3
			//	Added by Tarod, do not send incomplete established conns. to avoid sending
			//	no valid sources
				switch (pSource->GetDownloadState())
d4217 8
a4224 4
			//	only send source which have needed parts for this client if possible
				byte* pReqStatus = forClient->GetPartStatus();
				byte* pSrcStatus = pSource->GetPartStatus();
				if (forClient->m_pReqPartFile == this && pReqStatus && pSrcStatus)
d4226 1
a4226 1
					for (int x = 0; x < uPartCount; x++)
d4228 1
a4228 1
						if (pSrcStatus[x] && !pReqStatus[x])
d4230 1
a4230 13
							bNeeded = true;
							break;
						}
					}
				}
				else if (pSource->GetPartStatus())
				{
					byte * srcstatus = pSource->GetPartStatus();
					for (int x = 0; x < uPartCount; x++)
					{
						if (srcstatus[x])
						{
							bNeeded = true;
d4235 3
d4239 1
a4239 1
				if (bNeeded)
d4241 13
a4253 10
					nCount++;
					uint32 dwID = pSource->GetUserID();
					uint16 nPort = pSource->GetUserPort();
					uint32 dwServerIP = pSource->GetServerIP();
					uint16 nServerPort = pSource->GetServerPort();
					data.Write(&dwID, 4);
					data.Write(&nPort, 2);
					data.Write(&dwServerIP, 4);
					data.Write(&nServerPort, 2);
					if (nCount > 500)
d4257 8
d4266 1
a4266 4
	if (!nCount)
		return 0;
	data.Seek(16, 0);
	data.Write(&nCount, 2);
a4267 1
	Packet* pPacket = new Packet(&data, OP_EMULEPROT);
d4269 1
a4269 1
	if (nCount > 28)
d4271 1
a4271 1
//	AddDebugLogLine(false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount);
@


1.448
log
@Always copy completing files by internal routine
(now slow completion is always working and by the way, it isn't slow :);
Internal copy routine now is used automatically when temporary and
destination directories are on different partitions.
@
text
@a732 1
		setvbuf(file.m_pStream, NULL, _IOFBF, 16384);
d809 1
a809 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to remove \"%s\" - %s"), m_strFullName, _tcserror(errno));
d813 1
a813 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to move temporary part.met file \"%s\" to \"%s\" - %s"), strTempName, m_strFullName, strerror(errno));
d834 1
a834 1
		AddLogLine(false, RGB_LOG_ERROR + _T("Error saving %s - %s"), strPath, GetErrorMessage(error));
d5233 1
a5233 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("| User: %s - Available part count: %u"), pSource->GetUserName(), (int)pSource->GetAvailablePartCount());
d5376 1
a5376 1
		strLastSeenComplete = GetResString(IDS_NEVER);
d5381 1
a5381 1
		strLastProgress = GetResString(IDS_NEVER);
d5424 1
a5424 1
		strLastSeenComplete = GetResString(IDS_NEVER);
d5429 1
a5429 1
		strLastProgress = GetResString(IDS_NEVER);
d5825 1
a5825 1
		AddDebugLogLine( false, RGB_LOG_ERROR + _T("Preallocate for file %s: error %s"),
@


1.447
log
@Updated SourceExchange Protocol to v2
@
text
@a2880 1
	BOOL	bSlowComplete = g_eMuleApp.m_pGlobPrefs->SlowComplete();
d2882 4
a2885 5
//	We do this only if SlowComplete enabled
//	AND the files are on the different HDs (paratitions) - check by the drive leter
//	AND any of path is not in URL/Network format (has : as second leter)
	if ( bSlowComplete && ( _toupper(partfilename[0]) != _toupper(newname[0]) && partfilename[1] == _T(':')
	                        && newname[1] == _T(':') ) )
@


1.446
log
@Support for external antivirus program + removed SUI preferences + minor changes
@
text
@d4293 1
d4298 1
@


1.445
log
@Formatting and some improvements in tooltips code
@
text
@d3135 7
@


1.444
log
@Tooltips alignment is now automatic;  Improved status bar tooltips
@
text
@d5364 4
a5367 2
	CString compl;
	compl.Format(_T("%s/%s"), CastItoXBytes(GetCompletedSize()), CastItoXBytes(GetFileSize()));
a5368 1
	CString lsc;
d5370 1
a5370 1
		lsc = GetResString(IDS_NEVER);
d5372 1
a5372 1
		lsc = LocalizeLastSeenComplete();
a5373 1
	CString lastprogr;
d5375 1
a5375 1
		lastprogr = GetResString(IDS_NEVER);
d5377 1
a5377 1
		lastprogr = LocalizeLastDownTransfer();
a5378 1
	double availability = 0.0;
d5380 1
a5380 3
	{
		availability = GetAvailablePartCount() * 100 / GetPartCount();
	}
a5381 1
	CString					timeleft;
d5385 1
a5385 3
	{
		timeleft = CastSecondsToHM(GetTimeRemaining());
	}
d5387 1
a5387 5
	{
		timeleft = _T("-");
	}

	CString sRet;
d5389 1
a5389 1
	sRet.Format( GetResString(IDS_DL_FILENAME) + _T(": %s (%s)\n\n%s\n\n")
d5397 5
a5401 5
	             GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), availability,
	             static_cast<int>(GetPercentCompleted()), compl, GetTransferringSrcCount(),
	             GetResString(IDS_LASTSEENCOMPL) + _T(" ") + lsc,
	             GetResString(IDS_FD_LASTCHANGE) + _T(" ") + lastprogr,
				 GetResString(IDS_DLCOL_REMAININGTIME) + _T(": ") + timeleft,
d5408 1
a5408 1
	return sRet;
d5414 3
a5416 1
	CString lsc;
d5418 1
a5418 1
		lsc = GetResString(IDS_NEVER);
d5420 1
a5420 1
		lsc = LocalizeLastSeenComplete();
a5421 1
	CString lastprogr;
d5423 1
a5423 1
		lastprogr = GetResString(IDS_NEVER);
d5425 1
a5425 1
		lastprogr = LocalizeLastDownTransfer();
a5426 1
	double availability = 0.0;
d5428 1
a5428 3
	{
		availability = GetAvailablePartCount() * 100 / GetPartCount();
	}
a5429 1
	CString sTransfSrcCount;
d5431 1
a5431 3
		sTransfSrcCount.Format(GetResString(IDS_TT_PARTINFOS3), GetTransferringSrcCount());

	CString strFileSz = CastItoXBytes(GetFileSize());
d5433 1
a5433 2
	CString sRet;
	sRet.Format( _T("<t=2><b>%s</b><br><t=2>%s (%u %s)<br>")
d5444 1
a5444 1
	             static_cast<int>(GetPercentCompleted()), CastItoXBytes(GetCompletedSize()), strFileSz, sTransfSrcCount,
d5447 2
a5448 2
	             GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), availability,
	             lsc, lastprogr,
d5454 1
a5454 1
                 CastItoXBytes(GetRealFileSize()) );
d5456 1
a5456 1
	return sRet;
@


1.443
log
@Added 'size on disk' info to tooltip.
@
text
@d5449 1
a5449 1
	sRet.Format( GetResString(IDS_TT_FILENAME)
@


1.442
log
@Fixed open of configuration files accessed for reading by other processes
<thanks Fuxie - DK for report and testing>.
@
text
@d5457 2
a5458 1
	             + GetResString(IDS_TT_STATUS2),
d5469 2
a5470 1
	             GetConnectingSrcCount() );
@


1.441
log
@Fixed completing files sort problem when 'Show paused and stopped files last' is enabled (Thx Aw3!)
@
text
@a514 1
			//	START - enkeyDEV(Ottavio84) -ChangeDir-
d519 1
a519 1
				if (f.Open(strPath, CFile::modeRead | CFile::typeText))
a523 1
			//	END - enkeyDEV(Ottavio84) -ChangeDir-
d670 1
a670 1
//	Smoothed "remaining time" calculation)
d825 1
a825 1
			if (fDir.Open(strPath, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
@


1.440
log
@new FakeCheck autoupdate system
@
text
@d2950 1
a2951 1
			m_bPaused = false;
d3036 1
a3037 1
		m_bPaused = false;
d3696 6
a3701 3
//	Update GUI information
	UpdateDisplayedInfo(true);
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
@


1.439
log
@Disable scheduled backup and backup on exit if a file corruption is detected on start + minor changes
@
text
@d236 2
d2846 17
d3137 36
@


1.438
log
@Fix for changes in 1.436 (eliminated error message caused by adding link of
previously downloaded file) <thanks SyruS for report>.
@
text
@d380 1
a380 1
	//	readfile data form part.met file
d384 1
d393 2
a394 1
			AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_BADMETVERSION), m_strPartMetFileName, m_strFileName);
d417 2
d534 1
a534 1
			AddLogLine(true, IDS_ERR_METCORRUPT, m_strPartMetFileName, m_strFileName);
d547 2
d558 1
a558 1
	//SyruS (0.29a) SLUGFILLER: SafeHash - revised code, and extra safety
a565 1
	//	SLUGFILLER: SafeHash
d569 1
a569 1
//--- xrmb:keepPartFileStats ---
d571 1
a571 1
//--- :xrmb ---
d574 1
a574 1
//check if this is a backup
a594 1
//SyruS (0.29a) SLUGFILLER: SafeHash - final safety, make sure any missing part of the file is gap
a602 1
//	SLUGFILLER: SafeHash
d606 2
a607 2
	m_BlockedParts.SetSize(iPartCount);	//eklmn: ICR2.9+
	m_ReqParts.SetSize(iPartCount); //eklmn: ICR 2.10
d615 1
a615 1
//	check hashcount, filesatus etc
d650 1
a650 1
//	check date of .part file - if its wrong, rehash file
d658 1
a658 1
	//	rehash
d670 1
a670 1
//bond006 (smoothed "remaining time" calculation)
d698 1
a698 1
	//get filedate
d731 1
a731 1
	//open the file
d734 1
a734 1
	//version
d737 1
a737 1
	//date
d739 1
a739 1
	//hash
d797 1
a797 1
		OUTPUT_DEBUG_TRACE();
d808 1
a808 1
	// delete an original ".met", after successfully writing the temporary part.met file...
d812 1
a812 1
	// rename a ".met.tmp" to ".met"
d822 1
a822 1
	//	enkeyDEV(Ottavio84) -ChangeDir-
@


1.437
log
@minor changes (Partfile --> PartFile...)
@
text
@d18 1
a18 1
#include "partfile.h"
d243 1
a243 1
	if (!m_bIsBeingDeleted)
d3247 1
a3247 1
		pPartFile->Seek((LONGLONG)PARTSIZE * partnumber, 0);
@


1.436
log
@Fixed loss of client uploading turn during part file flushing and single part hashing;
Reworked file completion algorithm to eliminate file locking in completing state;
Added multi-thread protection for gaplist; Removed unused class members.
@
text
@d3772 1
a3772 1
CString CPartFile::GetPartfileStatus()
d3816 1
a3816 1
int CPartFile::GetPartfileStatusID()
d3855 1
a3855 1
int CPartFile::getPartfileStatusRang()
d5346 1
a5346 1
	             GetResString(IDS_STATUS) + _T(": ") + GetPartfileStatus(),
d5401 1
a5401 1
	             GetPartfileStatus(),
@


1.435
log
@Removed unused stuff.
@
text
@a158 1
	newdate = true;
a215 1
	m_LastRemovedTime = 0;
a230 4
//eklmn: create a Completion Event
	m_hCompletionEvent = ::CreateEvent(NULL, TRUE, TRUE, NULL);
	m_dwNumUploadingClients = 0;

a242 1
//	Barry - Ensure all buffered data is written
d244 2
d247 1
a247 4

	if (m_hPartFile.m_hFile != INVALID_HANDLE_VALUE && !m_bIsBeingDeleted)
	{
		m_hPartFile.Close();
d255 3
a262 1
	::CloseHandle(m_hCompletionEvent);
d309 6
a314 1
	if (!m_hPartFile.Open(partfull, CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
d316 1
d575 1
a575 1
//	open permanent handle
d577 6
a582 1
	if (!m_hPartFile.Open(searchpath, CFile::modeReadWrite | CFile::shareDenyWrite | CFile::osSequentialScan))
d584 1
d591 2
a592 2
	if (m_hPartFile.GetLength() < GetFileSize())
		AddGap(m_hPartFile.GetLength(), GetFileSize() - 1);
d594 1
a594 1
	if (m_hPartFile.GetLength() > GetFileSize())
d596 2
a597 2
		TRACE("Partfile \"%s\" is too large! Truncating %I64u bytes.\n", GetFileName(), m_hPartFile.GetLength() - GetFileSize());
		m_hPartFile.SetLength(GetFileSize());
d635 8
a642 2
	if (gaplist.IsEmpty())
	{	// is this file complete already?
d649 2
a650 1
	m_hPartFile.GetStatus(filestatus); // this; "...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are... :)
d658 1
a658 1
		addfilethread->SetValues(0, GetPath(), m_hPartFile.GetFileName().GetBuffer(), this);
d692 2
a693 1
	CSingleLock sLock(&m_FileCompleteMutex, TRUE); // will be unlocked on exit
d744 4
a747 1
	//tags
d759 1
a759 6
		byte priority_value;
		if (IsAutoPrioritized())
			priority_value = PR_AUTO;
		else
			priority_value = priority;
		CFileTag prioritytag(FT_PRIORITY, priority_value);
d765 1
a765 6
		byte ulpriority_value;
		if (CKnownFile::IsAutoPrioritized())
			ulpriority_value = PR_AUTO;
		else
			ulpriority_value = m_iPriority;
		CFileTag ulprioritytag(FT_ULPRIORITY, ulpriority_value);
d773 2
a774 1
	//gaps
d790 1
d848 1
a848 1
	newdate = true;
a849 1
	bool	bErrorFound = false;
d899 2
d902 2
a903 1
	for (pos1 = gaplist.GetHeadPosition();(pos2 = pos1) != NULL;)
d935 3
a938 1
	newdate = true;
d950 5
d964 2
a965 1
			return false;
d968 1
a968 1
	return true;
d1009 2
d1012 1
a1012 1
	while (true)
d1031 1
a1031 1
			return false;
d1039 1
a1039 1
			return false;
d1089 2
d1148 3
d1179 1
a1182 1
	newdate = true;
d1193 1
d1199 1
d1201 1
a1201 1
	if ((gaplist.GetCount() || requestedblocks_list.GetCount()))
d1258 2
d1308 3
d1322 1
a1322 1
	if ((gaplist.GetCount() || requestedblocks_list.GetCount()))
d1406 1
a1406 1
	if ((gaplist.GetCount() || requestedblocks_list.GetCount()))
d2678 3
d2708 1
d2711 1
a2711 4
	if (left2DL)
		return left2DLSize;
	else
		return PartSize;
a2840 6
//	Wait until currently downloading remote client finish
	::WaitForSingleObject(m_hCompletionEvent, INFINITE);

//	Local file lock
	CSingleLock sLock(&m_FileCompleteMutex, TRUE); // Will be unlocked on exit

a2843 1

a2851 13
//	Close permanent handle
	try
	{
		if (m_hPartFile.m_hFile != INVALID_HANDLE_VALUE)
			m_hPartFile.Close();
	}
	catch (CFileException * error)
	{
		OUTPUT_DEBUG_TRACE();
		AddDebugLogLine(false, _T("Failed to close permanent handle %s - %s"), GetFileName(), GetErrorMessage(error));
		error->Delete();
	}

d2859 3
a2861 1
	BOOL bSlowComplete = g_eMuleApp.m_pGlobPrefs->SlowComplete();
d2876 3
a2878 3
		//	We going to write everithing into the temporary file at same place the newname located
		//	and after we finished - rename , this will take care of syncronization problem with SharedFiles
			if ( !fInputFile.Open( partfilename, CFile::modeRead | CFile::shareDenyWrite | CFile::typeBinary
d2921 24
d2981 15
d3007 1
d3010 8
a3022 1
	ASSERT(m_hPartFile.m_hFile == INVALID_HANDLE_VALUE); // the file must be closed/commited!
d3027 2
a3028 2
	if (_tremove(m_strFullName))
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), m_strFullName);
d3031 1
a3031 1
	CString	strFilePath = RemoveFileExtension(m_strFullName);
d3039 1
a3039 1
	strFileToRemove = m_strFullName + _T(".bak");
d3049 3
a3051 1
	m_sourcesaver.DeleteFile(this);
d3054 3
a3056 1
	RemovePartFileStats();
a3064 7
	m_strFullName = newname;
	SetPath(GetOutputDir());
	SetFilePath(m_strFullName);
	SetStatus(PS_COMPLETE);
	m_bPaused = false;
	m_iSrcA4AF = 0;

d3179 1
a3179 3
//	m_hPartFile isn't the handle to the file...
	if (m_hPartFile.m_hFile != INVALID_HANDLE_VALUE)
		m_hPartFile.Close();
d3207 3
a3209 1
	m_sourcesaver.DeleteFile(this);
d3212 3
a3214 1
	RemovePartFileStats();
d3243 3
a3245 1
		uchar hashresult[16];
d3247 1
a3247 1
		m_hPartFile.Seek((LONGLONG)PARTSIZE * partnumber, 0);
d3251 1
a3251 1
		if ((ULONGLONG)PARTSIZE * (partnumber + 1) > m_hPartFile.GetLength())
d3253 1
a3253 1
			length = (m_hPartFile.GetLength() - ((ULONGLONG)PARTSIZE * partnumber));
d3256 4
a3259 1
		CreateHashFromFile(&m_hPartFile, length, hashresult);
d4264 2
a4419 10
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CPartFile::RemovePartFileStats()
{
	EMULE_TRY

	if (_tremove(GetStatsFullPath()) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), GetStatsFullPath());

	EMULE_CATCH
}
a4633 2
	CSingleLock sLock(&m_FileCompleteMutex, TRUE); // will be unlocked on exit

d4658 2
a4659 2
		if (m_hPartFile.GetLength() <= item->m_dwEndOffset)
			m_hPartFile.SetLength(item->m_dwEndOffset + 1);	// netwolf: file should not be too large (taab)
d4672 1
a4672 1
			m_hPartFile.Seek(item->m_dwStartOffset, CFile::begin);
d4678 1
a4678 1
			m_hPartFile.Write(item->m_pbyteBuffer, lenData);
d4687 2
a4688 2
		if (m_hPartFile.GetLength() > GetFileSize())
			m_hPartFile.SetLength(GetFileSize());
d4691 1
a4691 1
		m_hPartFile.Flush();
d4756 7
a4762 1
		if (gaplist.IsEmpty() && !m_bHashSetNeeded) // SLUGFILLER: hashlistRecheck - can't complete without a hashset...
d4801 1
a4801 2
		if (m_hPartFile.m_hFile != INVALID_HANDLE_VALUE)
			m_hPartFile.Close();
d4820 2
d4824 1
d5448 2
d5485 1
d5759 1
a5759 1
//	It receives a pointer to 'm_hPartFile' and the filesize-1 (where it has to write the bogus data to allocate space.
d5766 3
a5768 3
		tp->cPartFile->m_hPartFile.Seek(tp->iPosition, CFile::begin);
		tp->cPartFile->m_hPartFile.Write("1", 1);
		tp->cPartFile->m_hPartFile.Flush();
d5795 2
a5796 1
void CPartFile::SetFileUpload(bool bActive)
d5798 1
a5798 1
	if (bActive)
d5800 32
a5831 2
		InterlockedIncrement(&m_dwNumUploadingClients);
		ResetEvent(m_hCompletionEvent);
d5835 2
a5836 2
		if (InterlockedDecrement(&m_dwNumUploadingClients) == 0)
			SetEvent(m_hCompletionEvent);
d5838 4
@


1.434
log
@Improved extensive hard drive access for simultaneous hashing and completion;
Synchronize only file copying during simultaneous completions.
@
text
@a955 20
bool CPartFile::IsPureGap(uint32 start, uint32 dwEnd)
{
	EMULE_TRY

	if (dwEnd >= GetFileSize())
		dwEnd = GetFileSize() - 1;
	for (POSITION pos = gaplist.GetHeadPosition(); pos != NULL;)
	{
		Gap_Struct * cur_gap = gaplist.GetNext(pos);
		if (start >= cur_gap->m_dwStartOffset && dwEnd <= cur_gap->m_dwEndOffset)
		{
			return true;
		}
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a1291 1
		uint32	completedParts = 0;
a1305 2
				completedParts++;

d5727 1
a5727 1
void CPartFile::SetFileUpload (bool bActive)
@


1.433
log
@minor drawing improvements
@
text
@a42 1
CMutex CPartFile::s_CompletingMutex;
a2832 3
//	Global lock to prevent a multiple file completion
	CSingleLock Lock(&s_CompletingMutex, TRUE); // Prevent of completing two files in same time

d2903 3
d2915 2
@


1.432
log
@Removed old incorrectly working code from SavePartFileStats();
Minor improvements; formatting.
@
text
@a1235 3
	s_ChunkBar.Fill(crHave);

	uint32 allgaps = 0;
d1239 1
a1239 1
		s_ChunkBar.FillRange(0, GetFileSize(), crProgress);
d1246 4
d1621 1
a1621 1
	if (m_bDataFlushReq 
d4981 1
a4981 1
	else if ( g_eMuleApp.m_pServerConnect->GetClientID() == pSource->sourceID && 
@


1.431
log
@Fixed potential crash which can be caused by specific debug message.
@
text
@d768 3
a770 3
		TCHAR namebuffer[10];
		TCHAR *number = &namebuffer[1];
		uint16 i_pos = 0;
d773 3
a775 3
			_itot(i_pos, number, 10);
			namebuffer[0] = FT_GAPSTART;
			CFileTag gapstarttag(namebuffer, gaplist.GetAt(pos)->m_dwStartOffset);
d779 2
a780 2
			namebuffer[0] = FT_GAPEND;
			CFileTag gapendtag(namebuffer, (gaplist.GetNext(pos)->m_dwEndOffset) + 1);
a781 1
			i_pos++;
a4322 4
	if (!m_strFullName || IsBadStringPtr(m_strFullName, MAX_PATH))
	{
		return false;
	}
d4496 1
a4496 1
uint32 CPartFile::WriteToBuffer(uint32 transize, BYTE *data, uint32 start, uint32 dwEnd, Requested_Block_Struct *block)
d4504 1
a4504 1
	uint32 lenData = dwEnd - start + 1;
d4513 1
a4513 1
	if (IsComplete(start, dwEnd))
d4515 1
a4515 1
		AddDebugLogLine(false, _T("File '%s' has already been written from %lu to %lu size %lu"), GetFileName(), start, dwEnd, lenData);
d4526 1
a4526 1
	item->m_dwStartOffset = start;
d4562 2
a4563 3
//	v- eklmn: bugfix(20): check last part in WriteToBuffer correct way
	uint16 partnumber = floor(start / static_cast<double>(PARTSIZE));
	const uint32 uStart = partnumber * PARTSIZE;
d4565 1
d4570 1
a4570 1
		m_ReqParts[partnumber] = PARTSIZE;
d4628 2
a4629 9
		//	Get top item
			item = m_BufferedData_list.GetHead();

		//	This is needed a few times
			uint32 lenData = item->m_dwEndOffset - item->m_dwStartOffset + 1;

		//SyruS (0.29a) SLUGFILLER: SafeHash - could be more than one part
			/*int curPart = item->m_dwStartOffset/PARTSIZE;
			changedPart[curPart] = true;*/
a4633 1
		//	SLUGFILLER: SafeHash
a4636 1
			m_hPartFile.Write(item->m_pbyteBuffer, lenData);
d4638 1
a4638 2
		//	Remove item from queue
			m_BufferedData_list.RemoveHead();
d4642 1
@


1.430
log
@Fix for A4AF problem...
@
text
@d534 1
a534 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_FILEERROR), m_strPartMetFileName, m_strFileName, error);
@


1.429
log
@Fixed shared directory list corruption caused by asynchronous access (bug #502);
Fixed shared directory list processing to eliminate double list entries (that can be caused by case sensitive compares, by the bug on file completion after file destination change, or by initial shareddir.dat values).
@
text
@d3092 1
d3099 2
d3102 1
d3104 2
a3105 1
				//eklmn: if switching was succesfull we need to remove the entry from graphical list
d3107 1
d3110 2
d3113 1
d3115 1
d3117 1
a3117 1
//eklmn: remove A4AF entry from graphical list & anotherRequestList
d5132 1
a5132 1
		AddDebugLogLine(false, _T("Generated ed2k link with %i sources for file '%s'"), (int)srcstoadd.GetCount(), GetFileName());
@


1.428
log
@Minor changes
@
text
@a3058 2
	bool	bAddNewSharedDir = true;

d3061 1
a3061 1
		for (POSITION pos = g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetHeadPosition(); pos != NULL; )
d3063 1
a3063 9
			if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) == (GetPath() + _T('\\')))
			{
				bAddNewSharedDir = false;
				break;
			}
		}
		if (bAddNewSharedDir)
		{
			g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(GetPath() + _T('\\'));
d5231 2
a5232 2
			//	If the destination directory is already shared, just return it.
				for ( POSITION pos = g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetHeadPosition(); pos != NULL;)
d5234 2
a5235 4
					if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) == strDir)
					{
						return m_strAlternativePath;
					}
a5236 4
			//
			//	Otherwise, add it to the shared directory list and share the directory
				g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(strDir);
				g_eMuleApp.m_pSharedFilesList->Reload();
@


1.427
log
@Modified Clear Completed
@
text
@d3520 3
a3522 1
		return ;
d3524 2
a3525 2
//	eklmn: change status so early as possible in order to prevent unpredicted behaviour
//	during the source remove
d3529 2
a3530 2
//	Barry - Need to tell any connected clients to stop sending the file
//	eklmn: send a downloading client a cancel
d3558 1
a3558 1
//eklmn: reset A4AF auto file
d3560 1
d3562 1
d3585 1
a3585 1
	//save info to disk
d3587 1
a3588 1
	if (!m_bIsBeingDeleted)
d3590 2
a3591 1
	SaveSettingsFile();
d3593 1
a3593 1
	//update GUI information
d3611 1
a3611 1
//eklmn: reset A4AF auto file
d3613 1
d3615 1
d3617 1
a3617 1
//eklmn: send a downloading client a cancel
d3637 1
a3637 1
//eklmn: at this point nobody is downloading, and we can try to swap sources
d3645 1
a3645 1
			//	eklmn: swap source to any other file
d3647 1
d3649 1
d3654 1
d3660 1
d3662 1
d3664 2
a3665 1
	SaveSettingsFile();
d3677 5
a3681 2
		return ;
//eklmn: check if chunks are availible & set status
d3683 1
d3696 2
a3697 1
	{	//SyruS needed for files which are paused after adding or loading
d3714 1
a3714 1
//	Added by Vorlost to load initial sources from Server after connect
d3734 1
d3736 1
d3738 1
d3740 1
d3778 1
d3780 1
a3814 1

@


1.426
log
@a change connected to LowID unfairness
@
text
@d279 2
a280 1
	m_strTempDir = g_eMuleApp.m_pGlobPrefs->GetTempDir();	// added by InterCeptor (multiple tempdirs) 19.11.02
d282 7
a288 3
		m_strTempDir.Truncate(m_strTempDir.GetLength() - 1);	// added by InterCeptor (check for \\) 19.11.02
	SetPath(m_strTempDir); // #zegzav:vdir4list (OP_ASKSHAREDFILESDIR)
	int i = 0;
d290 1
d293 2
a294 3
		i++;
		strFileName.Format(_T("%s\\%03i.part"), m_strTempDir, i);

d298 1
a298 1
	m_strPartMetFileName.Format(_T("%03i.part.met"), i);
d300 1
d303 1
d307 1
d313 1
d315 1
d323 1
d327 1
d334 1
d337 1
a337 1
//	Before we save file we need to stablish UAP by Tarod
a343 1
//	End Tarod
d348 1
d350 1
d352 1
a352 1
//SyruS: cleanup
d354 1
d356 1
d4748 4
@


1.425
log
@Changed adding server sources to allow same IP different port for testing purposes (thx DoubleT)
@
text
@d5455 3
a5457 1
//eklmn: CS method to prevent a problem by removing(adding) in the list
d5468 1
a5468 1
		m_downloadingSourceList.AddTail(client);
@


1.424
log
@Done some changes to allow transfers between clients on the same IP for testing purposes
@
text
@d2128 1
a2128 1
void CPartFile::AddSources(CMemFile& sources, uint32 serverip, uint16 serverport)
d2132 1
a2132 1
//if this part file is paused or complete/completing no sources needed any more (Cax2 + SyruS check)
d2136 1
d2138 1
d2141 4
a2144 2
	byte debug_lowiddropped = 0;
	byte debug_possiblesources = 0;
d2146 8
a2153 7
	sources.Read(&byteCount, 1);
	//	Added by Tarod - if there is needed place for more sources just remove NNS
	int source_count_plus_new = GetSourceCount() + byteCount;

	if ( source_count_plus_new > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
	     && ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME) )
		RemoveNoNeededSources(source_count_plus_new - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
d2156 1
a2156 1
	uint16 nPort;
d2160 2
a2161 2
		sources.Read(&dwUserID,4);
		sources.Read(&nPort,2);
d2166 1
d2169 4
a2172 2
			if ((g_eMuleApp.m_pServerConnect->GetClientID() == dwUserID)
				&& inet_addr(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetFullIP()) == serverip)
d2174 1
d2176 3
a2178 1
		else if (g_eMuleApp.m_pServerConnect->GetClientID() == dwUserID)
d2180 3
a2182 1
		else if (dwUserID < 0x1000000 && !g_eMuleApp.m_pServerConnect->IsLocalServer(serverip, serverport))
d2184 1
a2184 1
			debug_lowiddropped++;
d2192 2
a2193 2
			debug_possiblesources++;
			CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this,dwUserID,nPort,serverip,serverport);
a2197 1
//	AddDebugLogLine(false, "RCV: %i sources from server, %i low id dropped, %i possible sources",count,debug_lowiddropped,debug_possiblesources);
d4957 2
a4958 1
	else if (pSource->sourceID < 0x1000000 && !g_eMuleApp.m_pServerConnect->IsLocalServer(pSource->serverIP, pSource->serverPort))
@


1.423
log
@Fix for a fix... they are becoming usual things -_-;
@
text
@d4906 1
a4906 1
void CPartFile::UpdateDisplayedInfo(boolean force)
d4917 1
a4917 1
void CPartFile::AddClientSource(CClientSource* source, int i_Source, bool exchanged, byte sourceexchangeversion)
d4921 1
a4921 1
//	check first if we are this source
d4925 6
a4930 3
		if ((g_eMuleApp.m_pServerConnect->GetClientID() == source->sourceID)
			&& g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP() == source->serverIP)
			return ;
d4933 15
a4947 2
		if (source->sourceID == g_eMuleApp.m_pServerConnect->GetLocalIP())
			return ;
a4948 5
	else if (g_eMuleApp.m_pServerConnect->GetClientID() == source->sourceID)
		return ;
//	Modified by Tarod -use LowID source only if source is in our same server
	else if (source->sourceID < 0x1000000 && !g_eMuleApp.m_pServerConnect->IsLocalServer(source->serverIP, source->serverPort))
		return ;
d4952 1
a4952 1
	     && i_Source < (int)g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() ) // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
d4954 2
a4955 2
		CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this,source->sourceID,source->sourcePort, source->serverIP,source->serverPort);
		if (exchanged && pNewSource)
d4957 1
a4957 1
		//Cax2 - exchanged sources are named now
d4959 3
a4961 3
		//	check exchange version
			if (sourceexchangeversion > 1)
				pNewSource->SetUserHash(source->achUserHash);
@


1.422
log
@log line correction
@
text
@d3503 7
a3509 1
	if (bCancel)
a3510 2
		Packet* packet = new Packet(OP_CANCELTRANSFER);

d3512 1
a3512 1
		POSITION posHeadList = m_downloadingSourceList.GetHeadPosition();
d3514 2
a3515 2

		for (POSITION pos = posHeadList; pos != NULL;)
d3517 1
a3517 5
			EnterCriticalSection(&m_csDownloadingSourceList);
			pSource = m_downloadingSourceList.GetNext(pos);
			LeaveCriticalSection(&m_csDownloadingSourceList);
#ifdef OLD_SOCKETS_ENABLED
			if (pSource)
a3520 1
				pSource->SetDownloadState(DS_ONQUEUE);
d3522 2
a3524 2
		}
		delete packet;
d3526 1
@


1.421
log
@fixed upload auto priority changes during file completion
@
text
@d4144 1
a4144 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("Received invalid source exchange packet (v%u) of data size %u for %s\n"), byteSourceExchangeVersion, uDataSize, GetFileName());
@


1.420
log
@replaced  pos != 0 to pos != NULL
@
text
@d3494 5
a3533 2
	m_bPaused = true;
	m_bStopped = true;
d3552 2
a3555 1
	UpdateDisplayedInfo(true);
d3560 2
@


1.419
log
@Changed back...
@
text
@d264 4
a267 2
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
		delete gaplist.GetNext(pos);
d755 1
a755 1
		for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
d923 1
a923 1
	for (POSITION pos = gaplist.GetHeadPosition(); pos != 0;)
d948 1
a948 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
d966 1
a966 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos != 0;)
d1002 1
a1002 1
		for (POSITION pos = gaplist.GetHeadPosition(); pos != 0;)
d1235 1
a1235 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
d1285 1
a1285 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos != 0;)
d2641 1
a2641 1
		for (POSITION pos = gaplist.GetHeadPosition(); pos != 0;)
d4162 1
a4162 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
d4801 1
a4801 1
		for (pos = m_pastCommentList.GetHeadPosition(); pos != 0;)
d4869 1
a4869 1
	for (pos = m_pastCommentList.GetHeadPosition(); pos != 0;)
d5169 1
a5169 2
				for ( POSITION pos = g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetHeadPosition();
				      pos != 0; )
d5349 1
a5349 1

d5351 1
a5351 1
		for (pos = gaplist.GetHeadPosition();pos != 0;)
d5386 1
d5389 1
a5389 1
	for (pos = requestedblocks_list.GetHeadPosition();pos != 0;)
@


1.418
log
@Changed the Upload log... It seems I found something strange while doing this. :/
@
text
@a3494 1
	Packet* packet;
d3497 2
a3498 7
		packet = new Packet(OP_CANCELTRANSFER);
	else
		packet = new Packet(OP_END_OF_DOWNLOAD);

	EnterCriticalSection(&m_csDownloadingSourceList);
	POSITION posHeadList = m_downloadingSourceList.GetHeadPosition();
	LeaveCriticalSection(&m_csDownloadingSourceList);
a3499 2
	for (POSITION pos = posHeadList; pos != NULL;)
	{
d3501 1
a3501 1
		pSource = m_downloadingSourceList.GetNext(pos);
d3503 6
d3510 7
a3516 5
		if (pSource)
		{
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
			pSource->m_pRequestSocket->SendPacket(packet, false, true);
			pSource->SetDownloadState(DS_ONQUEUE);
d3518 1
a3518 1
#endif //OLD_SOCKETS_ENABLED
a3519 1
	delete packet;
@


1.417
log
@minor optimization for completion process
@
text
@d2706 1
a2706 1
	StopFile();
d3485 1
a3485 1
void CPartFile::StopFile()
d3495 6
a3500 1
	Packet* packet = new Packet(OP_CANCELTRANSFER);
@


1.416
log
@minor improvements
@
text
@d831 4
a834 1
		if (IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
d838 2
a839 2
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_FOUNDCORRUPTION), i + 1, m_strFileName);
				AddGap(i * PARTSIZE, ((((i + 1) * PARTSIZE) - 1) >= GetFileSize()) ? GetFileSize() - 1 : ((i + 1) * PARTSIZE) - 1);
d854 1
a854 1
			AddLogLine(false, IDS_HASHINGDONE, m_strFileName);
@


1.415
log
@Reverted eklmn changes (known.met corruption with >9Mb files)
@
text
@d1198 3
a1200 1
	if (GetStatus() == PS_EMPTY || GetStatus() == PS_READY)
d2128 4
a2131 4
	if ( GetStatus() == PS_STOPPED
	     || GetStatus() == PS_COMPLETE
	     || GetStatus() == PS_COMPLETING )
		return ;
d2192 1
a2192 1
	const int	idxMedian = (int)ceil(dwPartCount / 2.0) - 1;	// <- eklmn: feature(00): ICR
d2220 1
a2220 1
					int			j = 0; // <- eklmn: feature(00): ICR v2
d2226 1
a2226 1
							if (j == idxMedian)
d3894 1
a3894 1
	uint64 space = GetFreeDiskSpaceX(m_strTempDir);
d3896 1
a3896 1
	if (GetStatus() == PS_COMPLETING || GetStatus() == PS_COMPLETE || GetStatus() == PS_HASHING)		// no preview! :)
d3899 2
d3930 2
a3931 2
			byte uState = GetStatus();
			if (!(uState == PS_READY || uState == PS_EMPTY || uState == PS_PAUSED))
d3967 2
a3968 1
			return !( (GetStatus() != PS_READY && GetStatus() != PS_PAUSED)
d4102 5
a4106 5
	if ( GetStatus() == PS_PAUSED
	     || GetStatus() == PS_STOPPED
	     || GetStatus() == PS_COMPLETE
	     || GetStatus() == PS_COMPLETING )
		return ;
d5036 2
a5037 4
	CString strExpiration;
	if (expirein == 0)
		strExpiration = _T("");
	else
d5043 1
a5043 1
		strExpiration.Format(_T("@@%02i%02i%02i"), (expirationDate.GetYear() % 100), expirationDate.GetMonth(), expirationDate.GetDay());
a5044 1
	strLink.AppendFormat(_T("|sources%s"), strExpiration);
d5221 4
a5224 2
	CString timeleft;
	if (GetStatus() != PS_COMPLETING && GetStatus() != PS_COMPLETE)
d5333 2
a5334 1
	POSITION pos;
d5336 1
a5336 1
	if (GetStatus() == PS_COMPLETE || GetStatus() == PS_COMPLETING)
@


1.414
log
@setting value of a4af-sourcecount after processing, resetting a4af-sourcecount to 0 after completing
@
text
@d831 1
a831 4
		const uint32 dwPartStart = i * PARTSIZE;
		const uint32 dwPartEnd = ((((i + 1) * PARTSIZE) - 1) >= GetFileSize()) ? GetFileSize() - 1 : ((i + 1) * PARTSIZE) - 1;

		if (IsComplete(dwPartStart, dwPartEnd))
d835 2
a836 2
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_FOUNDCORRUPTION), i + 1, GetFileName());
				AddGap(dwPartStart, dwPartEnd);
d851 1
a851 1
			AddLogLine(false, IDS_HASHINGDONE, GetFileName());
@


1.413
log
@minor optimization to new hash code
@
text
@a2000 1
		m_iSrcA4AF = m_A4AFsrcList.GetCount();
d2064 2
d2993 1
@


1.412
log
@"SLUGFILLER:SafeHash" partialy replaced by code, that produce minimal lock & more rubust
@
text
@d831 4
a834 1
		if (IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
d838 2
a839 2
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_FOUNDCORRUPTION), i + 1, m_strFileName);
				AddGap(i * PARTSIZE, ((((i + 1) * PARTSIZE) - 1) >= GetFileSize()) ? GetFileSize() - 1 : ((i + 1) * PARTSIZE) - 1);
d854 1
a854 1
			AddLogLine(false, IDS_HASHINGDONE, m_strFileName);
@


1.411
log
@Improved string processing
@
text
@d68 1
a68 1
				m_lFileSize = searchresult->m_tagArray[i]->GetIntValue();
d77 1
a77 1
	if (m_lFileSize < PARTSIZE)
d126 1
a126 1
		m_lFileSize = fileLink->GetSize();
d128 1
a128 1
		if (!m_lFileSize)
d135 1
a135 1
		if (m_lFileSize < PARTSIZE)
a197 1
	m_strComment = _T("");
d280 1
a280 1
	directory = m_strTempDir;	// #zegzav:vdir4list (OP_ASKSHAREDFILESDIR)
d299 1
a299 1
	gap->m_dwEndOffset = m_lFileSize - 1;
d333 1
a333 1
	if (m_lFileSize < PARTSIZE)
a348 1
	m_strTempDir = in_directory;	// added by InterCeptor (multiple tempdirs) 19.11.02
d350 2
d354 6
a359 3
	directory = in_directory;
	if (directory.Right(1) == _T('\\'))
		directory.Truncate(directory.GetLength() - 1);	// added by InterCeptor (check for \\) 19.11.02
a360 2
	m_strFullName.Format(_T("%s\\%s"), directory, m_strPartMetFileName);
	CSafeFile file;
d412 1
a412 1
					m_lFileSize = newtag->GetIntValue();
d536 1
a536 1
		if (gap->m_dwStartOffset != -1 && gap->m_dwEndOffset != -1 && gap->m_dwStartOffset <= gap->m_dwEndOffset && gap->m_dwStartOffset < m_lFileSize)
d538 2
a539 2
			if (gap->m_dwEndOffset >= m_lFileSize)
				gap->m_dwEndOffset = m_lFileSize - 1; // Clipping
d568 2
a569 2
	if (m_hPartFile.GetLength() < m_lFileSize)
		AddGap(m_hPartFile.GetLength(), m_lFileSize - 1);
d571 1
a571 1
	if (m_hPartFile.GetLength() > m_lFileSize)
d573 2
a574 2
		TRACE("Partfile \"%s\" is too large! Truncating %I64u bytes.\n", GetFileName(), m_hPartFile.GetLength() - m_lFileSize);
		m_hPartFile.SetLength(m_lFileSize);
d628 1
a628 1
		addfilethread->SetValues(0, directory, m_hPartFile.GetFileName().GetBuffer(), this);
d718 1
a718 1
		CFileTag sizetag(FT_FILESIZE, m_lFileSize);
d836 1
a836 1
				AddGap(i * PARTSIZE, ((((i + 1) * PARTSIZE) - 1) >= m_lFileSize) ? m_lFileSize - 1 : ((i + 1) * PARTSIZE) - 1);
d916 2
a917 2
	if (dwEnd >= m_lFileSize)
		dwEnd = m_lFileSize - 1;
d941 2
a942 2
	if (dwEnd >= m_lFileSize)
		dwEnd = m_lFileSize - 1;
d1176 2
a1177 2
		m_dblPercentCompleted = ((1.0 - static_cast<double>(allgaps + 1) / m_lFileSize)) * 100;
		completedsize = (m_lFileSize - allgaps - 1);
d1182 1
a1182 1
		completedsize = m_lFileSize;
d1213 1
a1213 1
	s_ChunkBar.SetFileSize(m_lFileSize);
d1220 1
a1220 1
		s_ChunkBar.FillRange(0, m_lFileSize, crProgress);
d1223 1
a1223 1
		completedsize = m_lFileSize;
d1297 1
a1297 1
			if (dwEnd > m_lFileSize)
d1299 1
a1299 1
				dwEnd = m_lFileSize;
d1310 1
a1310 1
					confirmedsize += m_lFileSize % PARTSIZE;
d1314 1
a1314 1
		completedsize = (m_lFileSize - allgaps - 1);
d1316 2
a1317 2
		m_dblPercentCompleted = static_cast<double>(completedsize) / m_lFileSize * 100.0;
		m_dblPercentConfirmed = static_cast<double>(confirmedsize) / m_lFileSize * 100.0;
d1323 1
a1323 1
		completedsize = m_lFileSize;
d1376 2
a1377 2
		m_dblPercentCompleted = ((1.0 - static_cast<double>(allgaps + 1) / m_lFileSize)) * 100;
		completedsize = (uint32)((m_lFileSize - (allgaps + 1)));
d1382 1
a1382 1
		completedsize = m_lFileSize;
d2622 1
a2622 1
	const uint32 uEnd = ((m_lFileSize - 1) < (uStart + PARTSIZE - 1)) ? (m_lFileSize - 1) : (uStart + PARTSIZE - 1);
d2985 1
a2985 1
	directory = GetOutputDir();
d3024 1
a3024 1
	if (directory != g_eMuleApp.m_pGlobPrefs->GetIncomingDir())
d3028 1
a3028 1
			if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) == (directory + _T('\\')))
d3036 1
a3036 1
			g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(directory + _T('\\'));
d3179 1
a3179 1
		return (md4cmp(hashresult, (m_lFileSize >= PARTSIZE) ? GetPartHash(partnumber) : m_fileHash) == 0) ? true : false;
d3623 1
a3623 1
		uint32 uEnd = ((m_lFileSize - 1) < (uStart + PARTSIZE - 1)) ? (m_lFileSize - 1) : (uStart + PARTSIZE - 1);
d4497 1
a4497 1
	const uint32 uEnd = ((m_lFileSize - 1) < (uStart + PARTSIZE - 1)) ? (m_lFileSize - 1) : (uStart + PARTSIZE - 1);
d4592 2
a4593 2
		if (m_hPartFile.GetLength() > m_lFileSize)
			m_hPartFile.SetLength(m_lFileSize);
d4599 1
a4599 1
		uint32	partRange = (m_lFileSize % PARTSIZE) - 1;
d4722 1
a4722 1
		bestEnd = m_lFileSize;
d4745 1
a4745 1
		else if (best->m_dwEndOffset < m_lFileSize)
d4749 1
a4749 1
			gap->m_dwEndOffset = m_lFileSize;
d5633 1
a5633 1
	tp->iPosition = m_lFileSize - 1;
d5670 1
a5670 1
	long a = m_lFileSize % EMBLOCKSIZE;
d5674 1
a5674 1
	return IsComplete(m_lFileSize - a, m_lFileSize - 1);
@


1.410
log
@reverted upload Priority problems fix since it doesn't work like it should do
@
text
@a5252 3
	CString compl;
	compl.Format(_T("%s/%s"), CastItoXBytes(GetCompletedSize()), CastItoXBytes(GetFileSize()));

d5275 2
d5287 2
a5288 2
	             GetFileName(), CastItoXBytes(GetFileSize()), GetFileSize(), GetResString(IDS_BYTES),
	             static_cast<int>(GetPercentCompleted()), compl, sTransfSrcCount,
@


1.409
log
@Fixed display of Available Parts and Last Seen Complete for file size > 2.3 Gb.
@
text
@d2976 7
@


1.408
log
@indirect flush of data to the disk if chunk was complete
@
text
@d194 1
a194 1
	availablePartsCount = 0;
d2186 1
a2186 1
	const int iPartCount = GetPartCount();
d2188 2
a2189 3
	const int idxMedian = (int)ceil(iPartCount / 2.0) - 1;	// <- eklmn: feature(00): ICR
	byte uAvailablePartsCounter = 0;
	byte uMaxAvailableParts = 0;
d2192 1
a2192 1
	if (m_srcPartFrequencies.GetSize() < iPartCount)
d2194 1
a2194 1
		m_srcPartFrequencies.SetSize(iPartCount);
d2198 1
a2198 1
	for (int i = 0; i < iPartCount; i++)
d2215 4
a2218 3
					uAvailablePartsCounter = 0;
					int j = 0; // <- eklmn: feature(00): ICR v2
					for (int i = 0; i < iPartCount; i++)
d2226 1
a2226 1
							uAvailablePartsCounter++;
d2229 2
a2230 2
					if (uAvailablePartsCounter > uMaxAvailableParts)
						uMaxAvailableParts = uAvailablePartsCounter;
d2237 1
a2237 1
	for (int i = 0; i < iPartCount; i++)
d2241 1
a2241 1
	if (iPartCount == uMaxAvailableParts && availablePartsCount < iPartCount)
d2243 1
a2243 1
	availablePartsCount = uMaxAvailableParts;
@


1.407
log
@Upload Priority problems fix
@
text
@d241 3
d1593 7
a1599 3
//	If buffer size exceeds limit, or if not written within time limit, flush data
	if ( (m_nTotalBufferData > ((uint32)g_eMuleApp.m_pGlobPrefs->GetFileBufferSize()) * 30000)
	  || (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)) ) //netwolf: increased FileBufferSize
d1603 1
d1605 1
d4492 2
a4493 1
		FlushBuffer();
d4512 2
@


1.406
log
@fix for changes in 1.402
@
text
@d1122 1
a1122 1
	for (pos1 = gaplist.GetHeadPosition();(pos2 = pos1) != NULL;)
d1164 1
a1164 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
a2966 7
//	Change AutoPriority to NORMAL when UAP is disabled
	if (CKnownFile::IsAutoPrioritized() && !g_eMuleApp.m_pGlobPrefs->IsUAPEnabled())
	{
		CKnownFile::SetAutoPriority(false);
		CKnownFile::SetPriority(PR_NORMAL);
	}

@


1.405
log
@redone an Aw3 change that has been lost in a shitty diff (???)
@
text
@d4339 3
a4341 2
	int nDateSize = GetDateFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0);
	int nTimeSize = GetTimeFormat(LOCALE_USER_DEFAULT, 0, &st, NULL, NULL, 0);
a4342 1
	CString strDate;
a4345 1
	CString strTime;
d4349 1
a4349 1
	strDate.Format(_T("%s, %s, %s"),
d4351 1
a4351 1
	return strDate;
@


1.404
log
@fix for 'Auto-Clear completed files' option that not always works
@
text
@d2478 1
a2478 1
					
d2570 1
a2570 1
	AddDebugLogLine(false, "ICR-Test: File: %s, A-parts : %u, BP-Parts %u. Choosen Part: %u, median %u, P-Freq: %u, blocked %s", 
d3018 1
a3018 1
			if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) == (directory + _T("\\")))
d3026 1
a3026 1
			g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(directory + "\\");
d4350 1
a4350 1
	strDate.Format(_T("%s, %s, %s"), 
@


1.403
log
@Improved string processing
@
text
@d2780 1
a2780 1
//	Lord KiRon - using threads for file completion
d2791 2
a2792 2
//	local file lock
	CSingleLock sLock(&m_FileCompleteMutex, TRUE); // will be unlocked on exit
d2806 1
a2806 1
//	close permanent handle
d2819 1
a2819 1
	bool renamed = false;
d2822 1
a2822 1
		renamed = true;
d2828 1
a2828 1
//	we do this only if SlowComplete enabled
d2867 1
a2867 1
				Sleep(0); // release the CPU for other processes
d2883 1
a2883 1
		catch (CMemoryException * error)	//check for exception that will be thow by "new"
d2903 1
a2903 1
		//	Purity - Sending message for erroneous file
d2919 1
a2919 1
		//	Purity - Sending message for erroneous file
d2932 1
a2932 1
//	bluecow: to have the accurate date stored in known.met we have to update the 'date' of a just completed file.
d2943 17
a2959 14
//	enkeyDEV(Ottavio84) -ChangeDir-
	CString dirFile = CString(RemoveFileExtension(m_strFullName)) + CString(".dir");
	if (_tremove(dirFile) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), dirFile);

//	Tarod - erase .bak file
	CString bakFile = CString(m_strFullName) + CString(".bak");
	if (_tremove(bakFile) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), bakFile);

//	DonGato - remove .settings file
	CString strSettingsFile = CString(RemoveFileExtension(m_strFullName)) + CString(".settings");
	if (_tremove(strSettingsFile) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strSettingsFile);
d2961 1
a2961 1
//	netwolf - remove .txtscr file
d2964 1
a2964 2
//--- xrmb:keepPartFileStats ---
//--- remove the stats file ---
a2965 1
//--- :xrmb ---
d2987 1
a2987 1
//	Purity - Sending message for completed file
d2992 1
a2992 1
	if (renamed)
d3002 1
a3002 1
//	Added by Tarod (starts next paused file)
a3007 1
//	-khaos--+++> Extended Statistics Added 2-10-03
d3012 2
d3016 13
a3028 5
		for (POSITION pos = g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetHeadPosition();pos != 0;)
			if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) == (directory + _T('\\')))
				return TRUE;
		g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(directory + _T('\\'));
		g_eMuleApp.m_pSharedFilesList->Reload();
d3105 2
a3106 14
//	enkeyDEV(Ottavio84) -ChangeDir-
	CString dirFile = CString(RemoveFileExtension(m_strFullName)) + CString(".dir");
	if (_tremove(dirFile) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), dirFile);

//	Tarod - erase .bak file
	CString bakFile = CString(m_strFullName) + CString(".bak");
	if (_tremove(bakFile) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), bakFile);

//	DonGato - remove .settings file
	CString strSettingsFile = CString(RemoveFileExtension(m_strFullName)) + CString(".settings");
	if (_tremove(strSettingsFile) && errno != ENOENT)
		AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_DELETEFAILED), strSettingsFile);
d3108 16
a3123 1
//	netwolf - remove .txtscr file
d3126 1
a3126 2
//--- xrmb:keepPartFileStats ---
//--- remove the stats file ---
a3127 1
//--- :xrmb ---
@


1.402
log
@Improved string processing
@
text
@d5042 1
a5042 1
void CPartFile::SetAlternativeOutputDir(CString* path)
d5046 1
a5046 1
	path->TrimRight(_T("\\"));
d5163 1
a5163 1
	strRetPath.TrimRight(_T("\\"));
@


1.401
log
@fixed meassages by failed completion (thanks Aw3)
@
text
@d489 5
a493 3
				CString dfpath = CString(RemoveFileExtension(m_strFullName)) + CString(".dir");
				CStdioFile f;
				if (f.Open(dfpath, CFile::modeRead | CFile::typeText))
d672 2
a673 3
	// create a backup of ".met"
	CString strBakFile = CString(m_strFullName) + CString(".bak");
	::CopyFile(m_strFullName, strBakFile, FALSE);
d784 2
a785 2
	CString dfpath = CString(RemoveFileExtension(m_strFullName)) + CString(_T(".dir"));
	CStdioFile fDir;
d787 1
d793 1
a793 1
			if (fDir.Open(dfpath, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
d803 1
a803 1
		AddLogLine(false, RGB_LOG_ERROR + _T("Error saving %s - %s"), dfpath, GetErrorMessage(error));
d2708 1
a2708 1
		CHashFileThread	*addFileThread = NULL;
d2838 1
a2838 1
			CString strTempNew = CString(newname);
d2846 2
a2847 2
			//	let catch to care about closing everything
				throw CString(GetResString(IDS_ERR_SLOWREAD) + _T(" (") + partfilename + _T(")"));
d2853 2
a2854 2
			//	let catch to care about closing everything
				throw CString(GetResString(IDS_ERR_SLOWWRITE) + _T(" (") + strTempNew + _T(")"));
d3015 1
a3015 1
			if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) == (directory + "\\"))
d3017 1
a3017 1
		g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(directory + "\\");
d3645 1
a3645 1
	CString mybuffer = _T("");
d3648 1
a3648 1
		mybuffer = GetResString(IDS_DOWNLOADING);
d3650 1
a3650 6
	{
		if (!IsStalled())
			mybuffer = GetResString(IDS_WAITING);
		else
			mybuffer = GetResString(IDS_STALLED);
	}
d3656 1
a3656 1
			mybuffer = GetResString(IDS_HASHING);
d3659 1
a3659 1
			mybuffer = GetResString(IDS_COMPLETING);
d3662 1
a3662 1
			mybuffer = GetResString(IDS_COMPLETE);
d3665 1
a3665 1
			mybuffer = GetResString(IDS_PAUSED);
d3668 1
a3668 1
			mybuffer = GetResString(IDS_ERRORLIKE);
d3671 1
a3671 1
			mybuffer = GetResString(IDS_STOPPED);
d3674 1
a3674 1
	return mybuffer;
d4321 4
a4324 1

d4339 3
a4341 28
	CString strDay;
	switch (dt.GetDayOfWeek())
	{
		case 1:
		strDay = GetResString(IDS_SCH_EXCEPT_SUN);
		break;
		case 2:
		strDay = GetResString(IDS_SCH_EXCEPT_MON);
		break;
		case 3:
		strDay = GetResString(IDS_SCH_EXCEPT_TUE);
		break;
		case 4:
		strDay = GetResString(IDS_SCH_EXCEPT_WED);
		break;
		case 5:
		strDay = GetResString(IDS_SCH_EXCEPT_THU);
		break;
		case 6:
		strDay = GetResString(IDS_SCH_EXCEPT_FRI);
		break;
		case 7:
		strDay = GetResString(IDS_SCH_EXCEPT_SAT);
		break;
	}

	return strDay + _T(", ") + strDate + _T(", ") + strTime;

d4349 1
a4349 1
	CString strIniFile = CString(RemoveFileExtension(m_strFullName)) + CString(".settings");
d4351 1
d4374 3
a4376 1
	CString strIniFile = CString(RemoveFileExtension(m_strFullName)) + CString(".settings");
d4652 2
a4653 1
			strTemp.Format("%s (" + m_strTempDir + ")", strSpace);
d5020 1
a5020 1
		strLink.AppendFormat(_T(",%i.%i.%i.%i:%i"), (byte)dwID, (byte)(dwID >> 8), (byte)(dwID >> 16), (byte)(dwID >> 24), g_eMuleApp.m_pGlobPrefs->GetPort());
d5029 2
a5030 2
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("| User: %s - Available part count: %i"), pSource->GetUserName(), (int)pSource->GetAvailablePartCount());
		strLink.AppendFormat(_T(",%s:%i"), pSource->GetFullIP(), pSource->GetUserPort());
d5108 1
a5108 1
				strDir += _T("\\");
d5197 1
a5197 2
		sint32 restTime = GetTimeRemaining();
		timeleft.Format(_T("%s"), CastSecondsToHM(restTime));
d5269 1
a5269 1
	             HashToString(GetFileHash()), ConcatFullPath(GetTempDir(), GetPartMetFileName()), 
@


1.400
log
@changed concatenation of .met path and fname in tooltips to avoid missing or doubled backslashes when using multiple temp folders.
@
text
@d777 1
a777 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to remove \"%s\" - %s"), m_strFullName, strerror(errno));
d2899 1
a2899 1
		catch (...)
d2903 1
a2903 1
			MessageText.Format(GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName());
d2906 1
a2906 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName());
d2909 1
d2919 1
a2919 1
			MessageText.Format(GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName());
d2922 1
a2922 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), strerror(errno));
@


1.399
log
@dont allow read access to temporary file while completing
@
text
@a5225 3
//	BavarianSnail - added detailed source infos
	CString compl2;
	compl2.Format(_T("%s\\%s"), GetTempDir(), GetPartMetFileName());
d5234 2
a5235 2
	             HashToString(GetFileHash()),
	             compl2, GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), availability,
d5290 2
a5291 2
	             HashToString(GetFileHash()),
	             GetPartMetFileName(), GetPartCount(), GetResString(IDS_AVAIL), GetAvailablePartCount(), availability,
@


1.398
log
@fixed small bug
@
text
@d2847 1
a2847 1
			if ( !fOutputFile.Open( strTempNew, CFile::modeWrite | CFile::shareDenyWrite | CFile::osSequentialScan
@


1.397
log
@ICR update to 2.13
@
text
@d2647 1
a2649 2
	left2DLSize -= PartSize;

@


1.396
log
@formatting
@
text
@d2240 1
a2240 1
//	v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.11, 26.09.2003) for eMule+
a2287 1
	CList<uint16, uint16>	curBlockedPartsList;
d2306 2
d2329 1
a2329 1
				//eklmn: no gaps found => full block
d2334 6
a2339 1
				//eklmn: some blocks left
a2340 1
				nNumPartiallyBlockedParts++;
a2341 1
			//m_BlockedParts[pDownloadingSource->GetLastDownPartAsked()] = pDownloadingSource;
d2346 3
a2348 1
	uint16		uRarestPart = static_cast<uint16>(floor(0.1 * m_uMedian)); // 10% from median
d2350 2
a2351 2
	if (uRarestPart < 3)
		uRarestPart = 3;
d2359 6
a2364 1
	uint32		dwMostCompletedReqPart = PARTSIZE;
d2393 2
a2394 1
			if (m_uMedian >= (uRarestPart + m_srcPartFrequencies[i]))
d2398 1
a2398 1
					for (int j = 0; j < (m_uMedian - m_srcPartFrequencies[i] + 1); j++)
d2471 12
a2482 1
				if (m_ReqParts[i] < dwMostCompletedReqPart)
d2549 1
a2549 1
	else if (dwMostCompletedReqPart != PARTSIZE)
a2551 1
	//	m_BlockedParts[nGoodPart] = pSource;
a2559 1
	//	m_BlockedParts[nGoodPart] = pSource;
d2567 5
a2571 1
//	AddDebugLogLine(false, "ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), nNumAvailableNeededParts, curBlockedPartsList.GetCount(),nGoodPart);
a2589 4
	if (!curBlockedPartsList.IsEmpty())
	{
		curBlockedPartsList.RemoveAll();
	}
@


1.395
log
@Fixed memory leak when impossible open file(s) during slow completion; slight optimization
@
text
@d3638 2
a3639 2
		mybuffer = GetResString(IDS_HASHING);
		break;
d3641 2
a3642 2
		mybuffer = GetResString(IDS_COMPLETING);
		break;
d3644 2
a3645 2
		mybuffer = GetResString(IDS_COMPLETE);
		break;
d3647 2
a3648 2
		mybuffer = GetResString(IDS_PAUSED);
		break;
d3650 2
a3651 2
		mybuffer = GetResString(IDS_ERRORLIKE);
		break;
d3653 2
a3654 2
		mybuffer = GetResString(IDS_STOPPED);
		break;
d3683 2
a3684 2
		ipfStatus = PS_HASHING;
		break;
d3690 2
a3691 2
		ipfStatus = GetStatus();
		break;
d3718 2
a3719 2
		status = 6;
		break;
d3721 2
a3722 2
		status = 1;
		break;
d3724 2
a3725 2
		status = 0;
		break;
d3727 2
a3728 2
		status = 5;
		break;
d3730 2
a3731 2
		status = 7;
		break;
d3733 2
a3734 2
		status = 8;
		break;
d3868 1
@


1.394
log
@Now if you click over the File Type icon the file details dialog is shown
@
text
@a2804 1
	int BlockSize = g_eMuleApp.m_pGlobPrefs->SlowCompleteBlockSize() * 1024;
a2815 2
			char *buffer = new char[BlockSize];
			DWORD dwRead = 0;
d2835 4
d2843 2
a2844 2
				dwRead = fInputFile.Read(buffer, BlockSize);
				fOutputFile.Write(buffer, dwRead);
d2848 1
a2848 1
			delete []buffer;
d2863 3
@


1.393
log
@formatting, removed some ending space and minor changes
removed some menus memleak in sharedctrl
fixed new 'LATER' code
changed new paused/stopped file sorting
removed a space not meant to be there in french.rcu
update changelog
@
text
@d3511 4
@


1.392
log
@Improved hash to string conversion
@
text
@d88 1
a88 1
	CED2KLink* pLink = 0;
d92 1
a92 1
		_ASSERT(pLink != 0);
d94 1
a94 1
		if (pFileLink == 0)
d159 1
a159 1
	m_strTempDir = "";
d189 1
a189 1
	m_strPartMetFileName = "";
d198 1
a198 1
	m_strComment = "";
d276 1
a276 1
	if (m_strTempDir.Right(1) == '\\')
d352 1
a352 1
	if (directory.Right(1) == '\\')
d5058 1
a5058 1
		if (strCatPath != "")
@


1.391
log
@formatting; minor changes; something was missed in last commit (Aw3 ???); always keep paused and stopped files at bottom in downloadlist
@
text
@d4980 1
a4980 1
			EncodeBase16(GetFileHash(),16) );
a5196 1
	CString strHash = EncodeBase16(GetFileHash(), 16);
d5208 1
a5208 1
	             strHash,
a5250 4
	CString strHash = EncodeBase16(GetFileHash(), 16);
	;
	CTime t(GetFileDate());

d5264 1
a5264 1
	             strHash,
@


1.390
log
@Processing files with size = 0 modulo PARTSIZE (as a result impossible to receive hashset, impossible to complete such file, incorrect average speed report, etc.); code optimization
@
text
@d1502 2
a1503 1
	if (!m_bPaused || m_eStatus == PS_STOPPED || m_eStatus == PS_ERROR || m_eStatus == PS_COMPLETING || m_eStatus == PS_COMPLETE || bIgnorePause)
d1505 5
d1512 1
a1512 4
		if (m_bStopped)
			return PS_STOPPED;
		else
			return PS_PAUSED;
@


1.389
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d236 1
a236 1
	m_hCompletionEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
d239 1
a239 1
	InitializeCriticalSection(&m_csDownloadingSourceList);
d265 2
a266 2
	CloseHandle(m_hCompletionEvent);
	DeleteCriticalSection(&m_csDownloadingSourceList);
d329 3
a331 2
//	SLUGFILLER: hashlistRecheck
	if (m_lFileSize <= PARTSIZE)
a332 1
//	SLUGFILLER: hashlistRecheck
d587 1
a587 1
	if (iSize < GetPartCount() && GetFileSize() >= PARTSIZE)
d821 1
a821 1
	INT_PTR hashSize = m_partHashArray.GetSize();
d823 1
a823 1
	for (uint32 i = 0; i != hashSize; i++)
d827 1
a827 1
			if (!(pKnownFile->GetPartHash(i) && !md4cmp(pKnownFile->GetPartHash(i), GetPartHash(i))))
d1386 1
a1386 1
	uint16 parts = GetPartCount();
d2695 1
a2695 1
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC)CompleteThreadProc, this, THREAD_PRIORITY_BELOW_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
d2697 1
a2697 5
		if (pThread)
		{
			pThread->ResumeThread();
		}
		else
d2761 1
a2761 1
	WaitForSingleObject(m_hCompletionEvent, INFINITE);
d3102 4
a3105 1
	if ((GetHashCount() <= partnumber) && (GetPartCount() > 1))
d3107 1
a3107 3
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_HASHERRORWARNING), GetFileName());
		this->m_bHashSetNeeded = true;
		return true;
d3109 1
a3109 1
	else if (!GetPartHash(partnumber) && GetPartCount() != 1)
d3111 1
a3111 3
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_INCOMPLETEHASH), GetFileName());
		this->m_bHashSetNeeded = true;
		return true;
d3128 1
a3128 14
		if (GetPartCount() > 1 || GetFileSize() == PARTSIZE)
		{
			if (md4cmp(hashresult, GetPartHash(partnumber)))
				return false;
			else
				return true;
		}
		else
		{
			if (md4cmp(hashresult, m_fileHash))
				return false;
			else
				return true;
		}
d3131 4
@


1.388
log
@final fix for excessive resizing on column resize bug + few optimisations and formatting
@
text
@d365 1
a365 1
		uint8 version;
d441 1
a441 1
					if ((uint8)newtag->GetIntValue() == PR_AUTO)
d449 1
a449 1
						CKnownFile::SetPriority((uint8)newtag->GetIntValue());
d696 1
a696 1
		uint8 uVersion = PARTFILE_VERSION;
d720 1
a720 1
		uint8 priority_value;
d731 1
a731 1
		uint8 ulpriority_value;
d1391 1
a1391 1
		uint8 towrite = 0;
d2115 3
a2117 3
	uint8 byteCount;
	uint8 debug_lowiddropped = 0;
	uint8 debug_possiblesources = 0;
d2175 2
a2176 2
	uint8 uAvailablePartsCounter = 0;
	uint8 uMaxAvailableParts = 0;
d2254 3
a2256 3
	int16			nNumAvailableNeededParts = 0;
	int16			nNumPartiallyBlockedParts = 0;
	const uint8		bytePreviewMode = GetMovieMode();
d2259 1
a2259 1
	uint8		   *pbytePartStatuses = pSource->GetPartStatus();
d3204 1
a3204 1
bool CPartFile::IsMovieChunk(uint8 mode, uint16 chunk)
d3330 1
a3330 1
bool CPartFile::Movie1(uint8 mode, uint16 oldchunk, uint16 newchunk)
d3352 1
a3352 1
bool CPartFile::Movie2(uint8 mode, uint8 raremovie, bool forcepreview, uint16 oldchunk, uint16 newchunk)
d3383 1
a3383 1
uint8 CPartFile::PrepareComparePart(uint16 chunk)
d3387 1
a3387 1
	uint8 addchunk = 0;
d3429 1
a3429 1
void CPartFile::SetPriority(uint8 np)
d3887 1
a3887 1
			uint8 uState = GetStatus();
d3992 2
a3993 2
				uint8* pReqStatus = forClient->GetPartStatus();
				uint8* pSrcStatus = pSource->GetPartStatus();
d4007 1
a4007 1
					uint8 * srcstatus = pSource->GetPartStatus();
d4053 1
a4053 1
void CPartFile::AddClientSources(CMemFile *packetStream, uint8 byteSourceExchangeVersion)
d4163 1
a4163 1
	uint8	version = 0;
d4225 1
a4225 1
	uint8	version = 2;
d4362 1
a4362 1
		uint8 Mode = filesettings.GetInt(_T("MoviePreviewMode"), 0);
d4874 1
a4874 1
void CPartFile::AddClientSource(CClientSource* source, int i_Source, bool exchanged, uint8 sourceexchangeversion)
d5022 1
a5022 1
		strLink.AppendFormat(_T(",%i.%i.%i.%i:%i"), (uint8)dwID, (uint8)(dwID >> 8), (uint8)(dwID >> 16), (uint8)(dwID >> 24), g_eMuleApp.m_pGlobPrefs->GetPort());
d5342 1
a5342 1
					uint8 color;
d5434 1
a5434 1
uint8* CPartFile::MMCreatePartStatus()
d5439 1
a5439 1
	uint8 * result = new uint8[GetPartCount() + 1];
d5456 1
a5456 1
			uint8 freq = (uint8)m_srcPartFrequencies[i];
@


1.387
log
@removed MOBILE_MULE and JUMPSTART defines + minor improvements (thx aw3)
@
text
@d2321 1
a2321 1
			// please note that second parameter is NULL, what should not lead to crash 
d5388 1
a5388 1
//AddDebugLogLine(false, _T("Total %u A4AF sources before swap"), m_A4AFsrcList.GetCount());
d5390 1
a5390 3
//	Make a list of sources
	CArray<CUpDownClient*, CUpDownClient*> SourcesList;
	for (POSITION pos = m_A4AFsrcList.GetHeadPosition(); pos != 0;)
d5392 1
a5392 1
		SourcesList.Add(m_A4AFsrcList.GetNext(pos));
a5394 4
//	Actually handover
	for (int i = 0; i < SourcesList.GetCount(); i++)
		SourcesList[i]->SwapToAnotherFile(this);

@


1.386
log
@Optimized hash processings
@
text
@a2971 1
#ifdef MOBILE_MULE
a2972 1
#endif //MOBILE_MULE
@


1.385
log
@Formatting, comments, and name changes.
Removed old #defines
@
text
@d137 1
a137 1
		memcpy2(m_fileHash, fileLink->GetHashKey(), sizeof(m_fileHash));
@


1.384
log
@ICR fix: prevent request of the part where does not left any empty block
@
text
@a1584 9
#ifdef LATER
#ifdef _DEBUG
	if (dwReduceDownload > 0)
	{
		AddLogLine(true, _T("Process: Throttling download to %ld%%"), dwReduceDownload);
	}
#endif
#endif LATER

@


1.383
log
@BUGFIX: decision whether to compress packets was case sensitive + added some more file extension + some other changes
@
text
@d315 1
a315 1
		m_BlockedParts[i] = NULL;
d579 2
a580 2
		m_BlockedParts[i] = NULL;
		m_ReqParts[i] = 0;		// ICR 2.10
d2249 6
d2264 1
a2264 1
	int16			nNumCurBlockedParts = 0;
d2308 1
a2308 1
			m_ReqParts[i] = 0xFFFFFFFF; // mark parts as not available to save CPU load
d2311 1
a2311 1
		m_BlockedParts[i] = NULL;
d2329 15
a2343 2
			m_BlockedParts[pDownloadingSource->GetLastDownPartAsked()] = pDownloadingSource;
			nNumCurBlockedParts++;
d2365 1
a2365 1
		if (m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != 0)
d2453 1
a2453 1
			if (m_BlockedParts[i] != NULL && nNumAvailableNeededParts > nNumCurBlockedParts)
@


1.382
log
@minor changes
@
text
@d801 1
a801 1
		AddLogLine(false, RGB_LOG_ERROR + _T("Error by saving %s - %s"), dfpath, GetErrorMessage(error));
@


1.381
log
@forgotten destructor calls
@
text
@d2353 1
a2353 1
				if (m_ReqParts[i] > (PARTSIZE - EMBLOCKSIZE) || (i ==( iPartCount -1) && m_ReqParts[i] == dwLastPartSize)) // limit change to prevent consecutive download due overlaping
d2371 1
a2371 1
				if (m_ReqParts[i] == PARTSIZE || (i ==( iPartCount -1) && m_ReqParts[i] == dwLastPartSize))
d2438 1
a2438 1
			if (m_ReqParts[i] == PARTSIZE || (i ==( iPartCount -1) && m_ReqParts[i] == dwLastPartSize))
@


1.380
log
@If you want to set default as high and change old behavior do it as an option.
@
text
@d265 2
a266 1
//	CloseHandle(m_hCompletionEvent);
@


1.379
log
@upload auto priority sets very well spread files to low prio + minor changes + cleanup
@
text
@d167 1
a167 1
	priority = PR_HIGH;
@


1.378
log
@Formatting, comments, and name changes.
@
text
@d323 1
a323 1
		CKnownFile::SetPriority(PR_VERYHIGH);
d443 1
a443 1
						CKnownFile::SetPriority(PR_VERYHIGH);
d1170 1
a1170 1
		completedsize = (uint32)((m_lFileSize - (allgaps + 1)));
d1307 1
a1307 1
		completedsize = (uint32)((m_lFileSize - (allgaps + 1)));
@


1.377
log
@stopped and paused files are not considered as partfile for upload auto priorities + some changes to avoid a bug with PR_AUTO in my last changes + minor changes about priorities
@
text
@d1751 1
a1751 1
					//	if m_pRequestSocket doesn't exist or isn't connected
d1896 1
a1896 1
						//	(emulates a "Connecting via server..." without m_pRequestSocket timeout)
@


1.376
log
@Formatting, comments, and name changes.
@
text
@d167 1
a167 1
	priority = PR_NORMAL;
d323 1
a323 1
		CKnownFile::UpdateUploadAutoPriority();
d423 1
d425 2
d443 1
a443 1
						CKnownFile::UpdateUploadAutoPriority();
d1615 1
a1615 1
	
d2319 1
a2319 1
		
d2765 1
a2765 1
	
d2988 1
a2988 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.SetRedraw(false);	
d4284 1
a4284 1
	
d5401 1
a5401 1
	
d5403 1
a5403 1
	
d5409 1
a5409 1
	
d5419 1
a5419 1
	
d5421 1
a5421 1
	
d5427 1
a5427 1
	
d5642 1
a5642 1
		AddDebugLogLine( false, RGB_LOG_ERROR + _T("Preallocate for file %s: error %s"), 
@


1.375
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d1571 1
a1571 1
	CUpDownClient	*pSource = NULL;
d2258 1
a2258 1
	uint8			*pbytePartStatuses = pSource->GetPartStatus();
@


1.374
log
@Formatting, comments, and name changes.
@
text
@d1571 1
a1571 1
	CUpDownClient  *pSource = NULL;
d1621 1
a1621 1
				if (pSource->GetDownloadState()!= DS_DOWNLOADING)
d1970 1
a1970 1
	//	-khaos--+++> Set the members using temp vars.  We have to use temporary vars so that the disp counts 
d2258 1
a2258 1
	uint8		   *pbytePartStatuses = pSource->GetPartStatus();
@


1.373
log
@missing reset of a4af sources counter on file stop (for the new display of a4af in source column)
@
text
@d4041 1
a4041 1
void CPartFile::AddClientSources(CMemFile* sources, uint8 sourceexchangeversion)
d4045 1
a4045 1
//if this part file is paused or complete/completing no sources needed any more (Cax2 + SyruS check)
d4052 2
a4053 2
	uint16 nCount;
	sources->Read(&nCount, 2);
d4055 1
a4055 1
//	Check if the data size matches the 'nCount' for v1 or v2 and eventually correct the source
d4058 10
a4067 5
	UINT uDataSize = sources->GetLength() - sources->GetPosition();
	if ((UINT)nCount * (4 + 2 + 4 + 2) == uDataSize)
		sourceexchangeversion = 1;
	else if ((UINT)nCount * (4 + 2 + 4 + 2 + 16) == uDataSize)
		sourceexchangeversion = 2;
d4073 1
a4073 1
		g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, _T("Received invalid source exchange packet (v%u) of data size %u for %s\n"), sourceexchangeversion, uDataSize, GetFileName());
d4077 1
a4077 1
	for (int i = 0;i != nCount;i++)
d4079 9
a4087 8
		CClientSource source;
		sources->Read(&source.sourceID, 4);
		sources->Read(&source.sourcePort, 2);
		sources->Read(&source.serverIP, 4);
		sources->Read(&source.serverPort, 2);
		if (sourceexchangeversion > 1)
			sources->Read(&source.achUserHash, 16);
		AddClientSource(&source, i, true, sourceexchangeversion);
@


1.372
log
@added category name to log, popup and email notifier (when a download is added or finished) [FR 359]
@
text
@d3486 1
@


1.371
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d2940 5
a2944 1
	AddLogLine(true, RGB_LOG_SUCCESS + GetResString(IDS_DOWNLOADDONE), GetFileName());
d2948 1
a2948 1
	MessageText.Format(GetResString(IDS_TBN_DOWNLOADDONE) + _T(" ") + GetFileName());
@


1.370
log
@Formatting, comments, and name changes.
@
text
@d1649 1
a1650 1
#ifdef OLD_SOCKETS_ENABLED
@


1.369
log
@minor changes to DebugLog and remove some marks
@
text
@d1647 1
a1647 1
#endif //OLD_SOCKETS_ENABLED
d1649 1
a1650 1
				else if (m_nSavedReduceDownload != dwReduceDownload)
d1654 1
a1654 1
#endif //OLD_SOCKETS_ENABLED
@


1.368
log
@some minor changes and optimizations
@
text
@d4407 1
a4407 1
		AddDebugLogLine(false, _T("File '%s' has already been written from %lu to %lu"), GetFileName(), start, dwEnd);
@


1.367
log
@added 'auto-clear completed files' option
@
text
@d1647 1
a1647 1
#endif OLD_SOCKETS_ENABLED
d1649 1
a1650 1
#ifdef OLD_SOCKETS_ENABLED
d1654 1
a1654 1
#endif OLD_SOCKETS_ENABLED
@


1.366
log
@safe handling of DL-file-queue
@
text
@d2979 7
@


1.365
log
@Formatting, comments, and name changes.
@
text
@d239 2
d1609 5
a1613 1
		for (pos1 = m_downloadingSourceList.GetHeadPosition(); (pos2 = pos1) != NULL;)
d1615 1
d1617 1
d1623 2
d1626 1
d2307 5
a2311 1
	for (POSITION pos = m_downloadingSourceList.GetHeadPosition(); pos != NULL;)
d2313 1
d2315 2
d3430 5
a3434 1
	for (POSITION pos = m_downloadingSourceList.GetHeadPosition();pos != NULL;)
d3436 1
d3438 1
a3438 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
d3440 6
a3445 2

		pSource->m_pRequestSocket->SendPacket(packet, false, true);
a3446 2

		pSource->SetDownloadState(DS_ONQUEUE);
d3499 5
a3503 1
	for (pos = m_downloadingSourceList.GetHeadPosition();pos != NULL;)
d3505 1
d3507 2
a3508 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
d3510 6
a3515 2

		pSource->m_pRequestSocket->SendPacket(packet, false, true);
a3516 2

		pSource->SetDownloadState(DS_ONQUEUE);
d5374 1
a5374 1
//v- eklmn: download fix
d5378 3
d5382 1
d5387 2
d5396 3
d5400 1
d5405 2
@


1.364
log
@recommit for "Completion Fix" with Aw3 correction
@
text
@d2079 3
a2081 1
	//	Changes in file status can affect whether the file belongs to a predefined category or not.
d2646 1
@


1.363
log
@fix for Scheduler shift on restart / fix for Preallocate handling of exceptions / eklmn fix for ICR
@
text
@d236 2
a237 2
//	m_hCompletionEvent = CreateEvent(NULL, TRUE, TRUE, _T("EPFileCompletionEvent"));
//	m_dwNumUploadingClients = 0;
d2730 7
a2736 1
//	WaitForSingleObject(m_hCompletionEvent, INFINITE);
d2741 1
a2741 1
	CSingleLock sLock(&m_FileCompleteMutex, TRUE); // will be unlocked on exit
d4227 1
a4227 1
	CSingleLock Lock(&s_CompletingMutex, TRUE); // Prevent of completing two files in same time
d4229 1
a5593 1
/*
a5606 1
*/
@


1.362
log
@Minor changes on PartFile
Fix for eMuleLight template ed2k box
Fix for CDownloadQueue::GetFileByID (wrong optmized code)
@
text
@d2272 1
a2272 1
	uint32			dwLastPartSize = 0;
d2329 1
a2329 1
				if (m_ReqParts[i] > (PARTSIZE - EMBLOCKSIZE)) // limit change to prevent consecutive download due overlaping
d2347 1
a2347 1
				if (m_ReqParts[i] == PARTSIZE)
d2414 1
a2414 1
			if (m_ReqParts[i] == PARTSIZE)
d5542 1
a5542 1
	tp->cPartFile = &m_hPartFile;
a5547 1
	SaveSettingsFile();
d5556 16
a5571 3
	tp->cPartFile->Seek(tp->iPosition, CFile::begin);
	tp->cPartFile->Write("1", 1);
	tp->cPartFile->Flush();
a5573 1

@


1.361
log
@final fixes for ed2k source links
@
text
@d52 2
a55 2
	EMULE_TRY

a85 2
	Init();

d111 5
d118 2
a121 2
	EMULE_TRY

a154 6
CPartFile::CPartFile(CED2KFileLink* fileLink)
{
	Init();
	InitializeFromLink(fileLink);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.360
log
@Some fixes for ed2k source links when used in .txtsrc files.
@
text
@d4873 1
a4873 1
CString CPartFile::CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bLog /*=true*/)
d4911 2
d4914 10
a4923 1
	if (srcstoadd.IsEmpty() && (!g_eMuleApp.m_pServerConnect->IsConnected() && bLog))
d4925 10
a4934 2
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_SOURCELINKFAILED));
		return CString("");
d4936 2
a4937 1
#endif //OLD_SOCKETS_ENABLED
d4940 1
a4940 1
		strExpiration = "";
d4949 1
a4949 2
	uint32 dwID = 0;
#ifdef OLD_SOCKETS_ENABLED
d4951 2
a4952 17
	dwID = g_eMuleApp.m_pServerConnect->GetClientID();
#endif //OLD_SOCKETS_ENABLED

	CString strLink;
	strLink.Format( _T("ed2k://|file|%s|%d|%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x|/|sources%s"),
	                g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false),  // spaces to dots
	                GetFileSize(),
	                GetFileHash()[0], GetFileHash()[1], GetFileHash()[2], GetFileHash()[3], GetFileHash()[4], GetFileHash()[5], GetFileHash()[6], GetFileHash()[7],
	                GetFileHash()[8], GetFileHash()[9], GetFileHash()[10], GetFileHash()[11], GetFileHash()[12], GetFileHash()[13], GetFileHash()[14], GetFileHash()[15],
	                strExpiration );

	CString newsource;
	if (dwID >= 0x1000000 && bLog)
	{
		newsource.Format(_T(",%i.%i.%i.%i:%i"), (uint8)dwID, (uint8)(dwID >> 8), (uint8)(dwID >> 16), (uint8)(dwID >> 24), g_eMuleApp.m_pGlobPrefs->GetPort());
		strLink.Append(newsource);
	}
d4954 1
a4954 1
	if (bLog)
d4960 1
a4960 1
		if (bLog)
d4962 1
a4962 2
		newsource.Format(_T(",%s:%i"), pSource->GetFullIP(), pSource->GetUserPort());
		strLink.Append(newsource);
@


1.359
log
@Reverted completion 'fix' by eklmn so we can release 1j this month
@
text
@d4912 1
a4912 1
	if (srcstoadd.IsEmpty() && (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID()))
d4942 1
d4944 1
a4944 1
	if (dwID >= 0x1000000)
d4949 1
d4951 3
d4955 2
a4956 4
		AddDebugLogLine(false, _T("Generated ed2k link with %i sources for file '%s'"), (int)srcstoadd.GetCount(), GetFileName());
		while (!srcstoadd.IsEmpty())
		{
			CUpDownClient * pSource = srcstoadd.RemoveHead();
d4958 2
a4959 3
			newsource.Format(_T(",%s:%i"), pSource->GetFullIP(), pSource->GetUserPort());
			strLink.Append(newsource);
		}
d4961 1
@


1.358
log
@Changes to Upload AutoPriority.
@
text
@a62 1
				//m_strFileName = searchresult->m_tagArray[i]->GetStringValue();
d83 1
a83 1

d112 1
a112 1

d151 1
a151 1

d157 1
a157 1

a171 1
//eklmn(khaos): reset a statistical variables
d223 1
a223 1
	m_nLastCompleteSrcCount = 0;			// netwolf: complete sources (zegzav) 13.05.03
a225 1
//bond006 (smoothed "remaining time" calculation) //SyruS
d239 2
a240 2
	m_hCompletionEvent = CreateEvent(NULL, TRUE, TRUE, _T("EPFileCompletionEvent"));
	m_dwNumUploadingClients = 0;
d244 1
a244 1

d252 1
a252 1
//taab BEGIN fix - minimize rehashing of files //netwolf 03.05.03 (dont know if we really need it)
d259 1
a259 1
//taab END fix
d266 1
a266 1
	CloseHandle(m_hCompletionEvent);
d270 1
a270 1

d310 2
a311 2
	m_BlockedParts.SetSize(iPartCount);	// eklmn: ICR 2.9
	m_ReqParts.SetSize(iPartCount);	//eklmn: ICR 2.10
d316 1
a316 1
		m_ReqParts[i] = 0;		// ICR 2.10
d370 1
a370 1
				file.Close();	//eklmn: bugfix(21): *.part.met was't closed after loading (aka "corrupted file problem")
d379 1
a379 1
		LoadSettingsFile(); // DonGato - Moview Preview Mode
a395 1
					//m_strFileName = newtag->GetStringValue();
a422 1
				//	Added by Tarod for auto-priority
d432 1
a432 1
					LoadSettingsFile(); //DonGato: stopped knowledge between sessions
d498 1
a498 1
			file.Close();	//eklmn: bugfix(21): *.part.met was't closed after loading (aka "corrupted file problem")
a526 4
		/*if (gap->m_dwStartOffset >= 0 && gap->m_dwEndOffset >=0 && gap->m_dwStartOffset <= gap->m_dwEndOffset)
		      		gaplist.AddTail(gap); // All tags accounted for
		  		else
			delete gap; // Some of the tags were missing*/
a538 1
//--- i hope that is a safe point to load the stats ---
d628 1
a628 1
//bond006 (smoothed "remaining time" calculation) //SyruS
d639 1
a639 1

a669 2
//	if (!::CopyFile(m_strFullName, strBakFile, FALSE))
//		AddDebugLogLine(false, RGB_LOG_ERROR + _T("Failed to create backup of %s (%s)"), m_strFullName, GetFileName());
d716 1
a716 1
	//	Modified by Tarod for DAP
d724 1
a724 1
	//	End by Tarod
a727 1
	//	Modified by Tarod for UAP
a738 1
	//	End by Tarod
d768 1
a768 2
//	eklmn: by shutdown force OS flush data direct to disk [SlugFiller]
//	if ( !g_eMuleApp.m_pdlgEmule->IsRunning() )
a779 1
	// dir stuff (eklmn: ??)
d785 1
a785 1
	//	START - enkeyDEV(Ottavio84) -ChangeDir-
a793 1
	//	END - enkeyDEV(Ottavio84) -ChangeDir-
d947 1
a947 1

d1050 1
a1050 1
void CPartFile::GetGapsInPart(CUpDownClient* pSource, uint16 numPart, Requested_Block_Struct** newblocks, uint16* count) 	//jicxicmic
d1111 1
a1111 1

d1142 1
a1142 1
			break;	// Lord KiRon
d1152 1
a1152 1

a1341 1
	//gaprect.left =  left;
d1344 1
a1344 1
		pOldBrush = dc->SelectObject(&pr_Brush);	//eklmn: select a new brush & remember old one
d1351 1
a1351 1
		dc->SelectObject(&pe_Brush);	//eklmn: select a new brush
d1358 1
a1358 1
		dc->SelectObject(&rgb_Brush);	//eklmn: select a new brush
d1361 1
a1361 1
		dc->SelectObject(pOldBrush);	//eklmn: recover an old brush
d1405 1
a1405 1
//	DbT:StartUploadReq
d1421 2
a1422 3
//	DbT:End

//	netwolf: complete sources (zegzav) 03.05.03 BEGIN
a1427 1
//	netwolf: complete sources (zegzav) 03.05.03 END
d1450 1
a1450 1

d1472 2
a1473 1
//	netwolf: complete sources (zegzav) - BEGIN
a1493 1
//	netwolf: complete sources (zegzav) - END
d1539 3
a1541 5
//End of code insertion by Vorlost for loading rarest parts first

//	Added by Tarod -remove no needed sources from download queue
//
//	[In]	number_sources_to_remove: Number of sources to be removed from list or 0xffffffff if we want all removed
a1579 1
//eklmn: initialize temp variables
a1679 1
				//	eklmn: check a NULL case
d1804 1
a1804 1
								if (!pSource->SwapToAnotherFile(NULL, true)) //eklmn: bugfix(08): A4AF switching
d1812 1
a1812 1
						//Vorlost, noneededparts-sources will be checked filereasktime*4 when 3/4 of max. sockets are open
a1814 1
						//End Vorlost for Expanded Filereasktime
a1815 1
						//	doubled reasktime for no needed parts - save connections and traffic
d1854 1
a1854 1
							if (pSource->GetRemoteQueueRank() && bSocketsUsageIsHigh)  //Vorlost QueueRank > 250
d1857 1
a1857 1
									usethisfilereasktime = FILEREASKTIME * 2.5 ; //Vorlost 54:10
d1859 1
a1859 1
									usethisfilereasktime = FILEREASKTIME * 2; //Vorlost (QR 1-250 = 43:20 minutes)
a1896 1
						//	END enkeyDEV(th1) -L2HAC-
d1957 8
a1964 10
					pSource = NULL;	// reset a variable
				} // end: pos = srclist...
			} //end: srclist.Empty
		} // for (slots)

	//	-khaos--+++> Set the members using temp vars.  We have
	//	to use temporary vars so that the disp counts
	//	don't get screwed up during processing.
	//	we don't need to count this, cause we can get a transferring sources over m_downloadingSourceList.GetCount()
	//m_iSrcTransferring=	i_TcntTransferring;
a1980 1
	//	<-----khaos-
d2005 1
a2005 1
								pSource->SwapToAnotherFile(NULL, true);	//eklmn: bugfix(08): A4AF switching
d2018 1
a2018 1
					} // end for (pos =
d2021 1
a2021 1
		} // end if
a2042 1
	//	^- eklmn: A4AF management
d2059 1
a2059 1
			m_sourcesaver.Process(this, g_eMuleApp.m_pGlobPrefs->SLSMaxSourcesPerFile()); //<<-- enkeyDEV(Ottavio84) -New SLS-
d2082 1
a2082 3
	//
	//	Changes in file status can affect whether the file belongs to a predefined category
	//	or not.
d2161 1
a2161 1

a2230 1
//	^- eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d2606 1
a2606 3
//	^- eklmn: feature(00): Intelligent Chunk Request(ICR v2.10, 3.07.2003) for eMule+


d2620 1
a2620 1

d2634 1
a2634 1
	StopFile();		//Cax2 - completing file bugfix....
a2646 1
	//
d2671 1
a2671 1
			throw CString(_T("Error creating file complete thread")); // move this to resources
d2674 1
a2674 1
	GetAvgDataRate(true);	//SyruS do update on completing files
d2685 1
a2685 1
	ASSERT(!newname.IsEmpty()); //name should never be 0
d2733 1
a2733 1
	WaitForSingleObject(m_hCompletionEvent, INFINITE);
a2766 1
//	Lord KiRon
a2807 1
			//	may be real sleep needed here , not sure
d2821 1
a2821 1
			CFile::Remove(partfilename); // This removes old Part file
a2866 1
//	Lord KiRon - end
a2874 1
//	bluecow [SyruS]
d2910 1
a2910 1
	directory = GetOutputDir(); // enkeyDEV(Ottavio84) -ChangeDir-
d2915 1
a2915 1
	UpdateDisplayedInfo(true);	//Cax2 - file completed bugfix
d2917 1
a2930 1
//	mobilemule
a2931 1
//	end mobilemule
d2940 1
a2940 1
//	Barry - Just in case
a2944 3
//	<-----khaos- End Statistics Modifications

//	m_dwBytesTransferred = m_lFileSize;
d2963 1
a2963 2


d2977 1
a2977 1
				if (!pRemoveSource->SwapToAnotherFile(NULL))	//eklmn: bugfix(08): A4AF switching
d3000 1
a3000 1

d3009 1
a3009 1
	StopFile();		//Cax2 bugfix: hanging sources when deleting file
d3080 1
a3080 1
		{ // netwolf: download bugfix for files > 2 GB (bluecow)
d3087 1
a3087 1
		{	// netwolf: special case if file size == part size
d3128 1
a3128 1

d3142 1
a3142 1

d3156 1
a3156 1

d3237 1
a3237 1

d3281 1
a3281 1

d3303 1
a3303 1

d3335 1
a3335 1

d3342 2
a3343 1
	if (chunk == GetPartCount() - 1) //Is this the last chunk ?
d3348 1
a3348 1
	//Get last possible blocknumber
d3364 1
a3364 2
//Vorlost for LoadRarestFinishedChunks Patch2 end

d3381 1
a3381 1

a3428 1
//	reset a statistical variables
d3449 1
a3449 1
	SaveSettingsFile(); //DonGato: stopped knowledge between sessions
a3455 1
//	v- eklmn: bugfix(02): file were paused not properly.... (who forgot the brackets?! :O)
d3501 1
a3501 1
	SaveSettingsFile(); //DonGato: stopped knowledge between sessions
d3507 1
a3507 1

d3514 1
a3514 1
//eklmn: check if chunks are availibla & set status
d3537 1
a3537 1
	SaveSettingsFile(); //DonGato: stopped knowledge between sessions
d3544 1
a3544 1

a3551 1
	//AddLogLine(true, CString("Resetting LastSearchTime:%d in Filename:%s"),m_dwLastFileSourcesRequestTime,GetFileName());
d3786 1
a3786 1

d3870 1
a3870 1

d3879 1
a3879 1
		return NULL;		//netwolf 07.05.03
d3942 1
a3942 1
				else if (pSource->GetPartStatus())	//netwolf 04.05.03
d3980 1
a3980 1
//AddDebugLogLine(false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount);
d4323 18
a4340 19
//	DonGato - Moview Preview Mode end

/* Barry - Replaces BlockReceived()

           Originally this only wrote to disk when a full 180k block
           had been received from a client, and only asked for data in
		   180k blocks.

		   This meant that on average 90k was lost for every connection
		   to a client data source. That is a lot of wasted data.

		   To reduce the lost data, packets are now written to a buffer
		   and flushed to disk regularly regardless of size downloaded.
		   This includes compressed packets.

		   Data is also requested only where gaps are, not in 180k blocks.
		   The requests will still not exceed 180k, but may be smaller to
		   fill a gap.
*/
a4407 1
//	if (gaplist.IsEmpty()) FlushBuffer();  //netwolf: another approach to avoid sharing of corrupted parts (trockenbeerenauslese)
a4415 1
//	^- eklmn: bugfix(20): check last part in WriteToBuffer correct way
d4432 1
a4432 1
	m_nLastBufferFlushTime = GetTickCount();  // obaldin
d4509 1
a4509 1
		uint32	partRange = (m_lFileSize % PARTSIZE) - 1;	//netwolf 03.05.03
d4633 1
a4633 1
		best = gaplist.GetHead();	//Cax2 - empty file bugfix
d4664 1
a4664 1

d4691 1
a4691 1
//	#zegzav:pastcomment (BEGIN)
a4693 1
	//	past comments
a4704 1
//	#zegzav:pastcomment (END)
d4711 1
a4711 1

d4725 1
a4725 1

d4761 1
a4761 1
//	#zegzav:pastcomment (BEGIN)
a4775 1
//	#zegzav:pastcomment (END)
d4802 1
a4802 1
//	START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d4843 1
a4843 2
//^- eklmn: support Source Exchange v2

d4871 2
a4872 3
//	END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-

//	START - enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d4966 1
a4966 2
//	END - enkeyDEV(Ottavio84) -Create source ed2k from downloads-

d5106 1
a5106 1
		lsc = LocalizeLastSeenComplete();	// netwolf 13.05.03 use local date/time format
d5112 1
a5112 1
		lastprogr = LocalizeLastDownTransfer();	// netwolf 13.05.03 use local date/time format
a5154 1
//	-BavarianSnail
d5158 2
a5159 2

//BEGIN Improved Tooltips
d5169 1
a5169 1
		lsc = LocalizeLastSeenComplete();	// netwolf 13.05.03 use local date/time format
d5175 1
a5175 1
		lastprogr = LocalizeLastDownTransfer();	// netwolf 13.05.03 use local date/time format
a5194 1
             //	+GetResString(IDS_TT_DATE)
d5200 1
a5200 1
	             + GetResString(IDS_TT_STATUS2),  //<= TEMPORARY
a5203 1
             //	t.Format("%A, %B %d, %Y"),
d5215 1
a5215 2
//END Improved Tooltips

a5223 1
//Ju1i3n Start - merged with eMulePlus by janes bong
a5231 1
//Ju1i3n End
d5298 1
a5298 1

d5306 1
a5306 1

d5327 1
a5327 1

d5332 1
a5332 1
	POSITION pos = m_downloadingSourceList.Find(client); // to be sure
d5339 2
a5340 1

d5344 1
a5344 1
	POSITION pos = m_downloadingSourceList.Find(client); // to be sure
a5350 2
//^- eklmn: download fix

d5388 1
a5388 1
//	#zegzav:pastcomment (BEGIN)
d5402 1
a5426 1
//	#zegzav:pastcomment (END)
d5573 1
d5587 2
a5588 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////@


1.357
log
@More Kush changes for localization, minor optimizations and fix for Upload AutoPriority.
@
text
@d2943 7
@


1.356
log
@added memory exception handling by slow completion
@
text
@d242 1
a242 1
	m_hCompletionEvent = CreateEvent(NULL, TRUE, TRUE, _T("EPFileCompletionEvent")); 
d2822 1
a2822 1
			
a2958 9

//	Added to change UAP to Normal after finished download of file by Tarod
//	if (CKnownFile::IsAutoPrioritized())
//	{
//		CKnownFile::SetAutoPriority(false);
//		CKnownFile::SetPriority(PR_NORMAL);
//	}
//	End Tarod

a3007 1
	POSITION pos;
d3029 1
a3029 1
		for (pos = m_A4AFsrcList.GetHeadPosition(); pos != NULL;)
a3441 1
	POSITION pos;
d3445 1
a3445 1
	for (pos = m_downloadingSourceList.GetHeadPosition();pos != NULL;)
d4928 1
a4928 1
	POSITION pos;
d4931 1
a4931 1
			for (pos = m_srcLists[sl].GetHeadPosition();pos != NULL;)
d4933 1
a4933 1
				CUpDownClient* pSource = m_srcLists[sl].GetNext(pos);
d4947 1
a4947 1
					for (POSITION pos2 = srcstoadd.GetTailPosition();pos2 != 0;)
d5297 2
d5306 1
a5306 1
		for (POSITION pos = gaplist.GetHeadPosition();pos != 0;)
d5343 1
a5343 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos != 0;)
d5644 1
a5644 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.355
log
@Some AW3 suggestions
@
text
@d2818 2
d2822 1
a2838 10
			DWORD dwRead = 0;
			char *buffer = new char[BlockSize];
			if (!buffer)
			{
				fOutputFile.Close();
				fInputFile.Close();
			//	let catch to care about closing everything
				throw CString(GetResString(IDS_ERR_OUTMEM));
			}

d2862 8
@


1.354
log
@Some minor changes by KuSh.
@
text
@d241 1
a241 1
//eklmn: create a Comletion Events
d2822 1
a2822 1
			if ( !fInputFile.Open( partfilename, CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary
d2828 2
a2829 1
			if (!fOutputFile.Open(strTempNew, CFile::modeWrite | CFile::shareExclusive | CFile::osSequentialScan | CFile::modeCreate))
d2840 2
d2860 1
a2865 1
				return FALSE;
@


1.353
log
@forgotten initialization of "m_dwNumUploadingClients"
@
text
@d38 1
a38 1
#define PROGRESS_HEIGHT 4	//netwolf 06.05.03 (was 3) 
d41 1
a41 1
CBarShader CPartFile::s_ChunkBar(16); 
d43 1
a43 1
CMutex CPartFile::s_ComplitingMutex;
d266 2
a267 2
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
		delete gaplist.GetAt(pos);
d759 1
a759 1
		for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
d768 1
a768 1
			CFileTag gapendtag(namebuffer, (gaplist.GetAt(pos)->m_dwEndOffset) + 1);
d799 1
a799 1
	try 
d926 1
a926 1
	for (POSITION pos = gaplist.GetHeadPosition(); pos != 0; gaplist.GetNext(pos))
d928 1
a928 1
		Gap_Struct * cur_gap = gaplist.GetAt(pos);
d951 1
a951 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
d953 1
a953 1
		Gap_Struct * cur_gap = gaplist.GetAt(pos);
d969 1
a969 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos != 0; requestedblocks_list.GetNext(pos))
d971 1
a971 1
		Requested_Block_Struct * cur_block = requestedblocks_list.GetAt(pos);
d1005 1
a1005 1
		for (POSITION pos = gaplist.GetHeadPosition(); pos != 0; gaplist.GetNext(pos))
d1007 1
a1007 1
			pCurrentGap = gaplist.GetAt(pos);
d1176 1
a1176 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
d1178 1
a1178 1
		Gap_Struct * cur_gap = gaplist.GetAt(pos);
d1236 1
a1236 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
d1238 1
a1238 1
		Gap_Struct * cur_gap = gaplist.GetAt(pos);
d1286 1
a1286 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos != 0;requestedblocks_list.GetNext(pos))
d1288 1
a1288 1
		Requested_Block_Struct * block = requestedblocks_list.GetAt(pos);
d1454 1
a1454 1
	POSITION pos1, pos2;
d1457 1
a1457 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d1459 1
a1459 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
d1477 1
a1477 1
	POSITION pos1, pos2;
d1480 1
a1480 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d1482 1
a1482 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
d1500 1
a1500 1
	POSITION pos1, pos2;
d1503 1
a1503 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d1505 1
a1505 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
d1568 1
a1568 1
	POSITION pos1, pos2;
d1572 1
a1572 1
			for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL && removed < number_sources_to_remove;)
d1574 1
a1574 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
d1645 1
a1645 1
				//eklmn: since client can be droped due timeout it needs to check the state 
d1699 1
a1699 1
				for (pos1 = m_srcLists[dwSlotIndex].GetHeadPosition();(pos2 = pos1) != NULL;)
d1701 1
a1701 2
					m_srcLists[dwSlotIndex].GetNext(pos1);
					pSource = m_srcLists[dwSlotIndex].GetAt(pos2);
d1717 1
a1717 1
						// eklmn: since client can be droped due timeout it needs to check the state 
d1745 1
a1745 1
						
d2017 1
a2017 1
	
d2025 1
a2025 1
					for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL;)
d2027 1
a2027 2
						m_srcLists[sl].GetNext(pos1);
						pSource = m_srcLists[sl].GetAt(pos2);
d2058 1
a2058 1
			for (pos1 = m_A4AFsrcList.GetHeadPosition(); (pos2 = pos1) != NULL;)
d2060 1
a2060 2
				m_A4AFsrcList.GetNext(pos1);
				pSource = m_A4AFsrcList.GetAt(pos2);
d2146 1
a2146 1
	
d2157 1
a2157 1
	
d2168 1
a2168 1
			if ((g_eMuleApp.m_pServerConnect->GetClientID() == dwUserID) 
d2211 1
a2211 1
	
d2220 1
a2220 1
	POSITION pos1, pos2;
d2225 1
a2225 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d2227 1
a2227 2
				m_srcLists[sl].GetNext(pos1);
				pSource = m_srcLists[sl].GetAt(pos2);
d2600 1
a2600 1
		for (POSITION pos = gaplist.GetHeadPosition(); pos != 0; gaplist.GetNext(pos))
d2602 1
a2602 1
			Gap_Struct * cur_gap = gaplist.GetAt(pos);
d2650 1
a2650 2
		requestedblocks_list.GetNext(pos1);
		if (requestedblocks_list.GetAt(pos2)->m_dwStartOffset <= start && requestedblocks_list.GetAt(pos2)->m_dwEndOffset >= dwEnd)
d2769 1
a2769 1
	//wait until currently downloading remote clients will finish
d2774 1
a2774 8
/*
//eklmn: wait until file will be free
	while (g_eMuleApp.m_pUploadQueue->IsFileUploading(this) == true)
	{
	//	do nothing, just wait
		Sleep(0); // release the CPU for other processes
	}
*/
a2826 1
				return FALSE;
a2832 1
				return FALSE;
a2840 1
				return FALSE;
d2944 1
a2944 1
	
d2991 2
a2992 2
		for (POSITION pos = g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetHeadPosition();pos != 0;g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos))
			if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetAt(pos) == (directory + "\\"))
d3013 1
a3013 1
	POSITION pos1, pos2;
d3035 1
a3035 1
		for (pos1 = m_A4AFsrcList.GetHeadPosition(); (pos2 = pos1) != NULL;)
d3037 1
a3037 2
			m_A4AFsrcList.GetNext(pos1);
			pRemoveSource = m_A4AFsrcList.GetAt(pos2);
d3934 1
a3934 1
	POSITION pos1, pos2;
d3943 1
a3943 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d3946 1
a3946 2
				m_srcLists[sl].GetNext(pos1);
				pSource = m_srcLists[sl].GetAt(pos2);
d4089 1
a4089 1
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
d4091 1
a4091 1
		Gap_Struct * cur_gap = gaplist.GetAt(pos);
d4273 1
a4273 1
	CSingleLock Lock(&s_ComplitingMutex, TRUE); // Prevent of compliting two files in same time
d4375 3
a4377 3
 
           Originally this only wrote to disk when a full 180k block 
           had been received from a client, and only asked for data in 
d4379 1
a4379 1
 
d4382 1
a4382 1
 
d4386 1
a4386 1
 
d4729 1
a4729 1
	POSITION pos1, pos2;
d4732 1
a4732 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d4734 1
a4734 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
d4747 1
a4747 1
		for (pos1 = m_pastCommentList.GetHeadPosition(); pos1 != 0;)
d4749 1
a4749 1
			CPastComment &pc = m_pastCommentList.GetNext(pos1);
d4791 1
a4791 1
	POSITION pos1, pos2;
d4799 1
a4799 1
			for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL;)
d4801 1
a4801 2
				m_srcLists[sl].GetNext(pos1);
				fRate = m_srcLists[sl].GetAt(pos2)->GetFileRating();
d4816 1
a4816 1
	for (pos1 = m_pastCommentList.GetHeadPosition(); pos1 != 0;)
d4818 1
a4818 1
		fRate = m_pastCommentList.GetNext(pos1).GetRating();
d4867 1
a4867 1
		if ((g_eMuleApp.m_pServerConnect->GetClientID() == source->sourceID) 
d4886 1
a4886 1
		if (exchanged && pNewSource) 
d4935 1
a4935 1
	POSITION pos1, pos2;
d4938 1
a4938 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d4940 1
a4940 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
d4954 1
a4954 1
					for (POSITION pos2 = srcstoadd.GetTailPosition();pos2 != 0;srcstoadd.GetPrev(pos2))
d4956 1
a4956 1
						CUpDownClient * cur_srctoadd = srcstoadd.GetAt(pos2);
d5118 1
a5118 2
				      pos != 0;
				      g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) )
d5120 1
a5120 1
					if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetAt(pos) == strDir)
d5311 1
a5311 1
		for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos))
d5313 1
a5313 1
			Gap_Struct * cur_gap = gaplist.GetAt(pos);
d5348 1
a5348 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos != 0;requestedblocks_list.GetNext(pos))
d5350 1
a5350 1
		Requested_Block_Struct * block = requestedblocks_list.GetAt(pos);
d5378 1
a5378 1
	for (POSITION pos = m_A4AFsrcList.GetHeadPosition(); pos != 0; m_A4AFsrcList.GetNext(pos))
d5380 1
a5380 1
		SourcesList.Add(m_A4AFsrcList.GetAt(pos));
d5649 1
a5649 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////@


1.352
log
@files weren't added to shared files if all blocks recovered by ICH
@
text
@d242 2
a243 1
	m_hCompletionEvent = CreateEvent(NULL, TRUE, TRUE, _T("CompletionEvent")); 
@


1.351
log
@new way of syncronization by file completion
@
text
@d4626 6
a4631 1
				//	BavarianSnail - add info to stats
@


1.350
log
@*** empty log message ***
@
text
@d241 3
d268 2
d2777 3
d2782 1
a2782 1

d2789 1
a2789 1

d5655 14
@


1.349
log
@uint16 -> uint32 in indexing loops (thx Aw3)
@
text
@d309 1
a309 1
	for (uint16 i = 0; i < iPartCount;i++)
d577 1
a577 1
	for (uint16 i = 0; i < iPartCount; i++)
d1294 1
a1294 1
		for (uint16 i = 0; i < GetPartCount(); i++)
@


1.348
log
@missing backslash in partfilename for webserver-fileinfo
@
text
@d57 1
a57 1
	for (int i = 0; i < searchresult->m_tagArray.GetCount(); i++)
d309 1
a309 1
	for (uint16 i = 0; i < iPartCount; i++)
d1401 1
a1401 1
		for (uint16 i = 0;i < 8;i++)
@


1.347
log
@some minor loop corrections
@
text
@d5204 1
a5204 1
	compl2.Format(_T("%s%s"), GetTempDir(), GetPartMetFileName());
@


1.346
log
@type fix (cast)
@
text
@d57 1
a57 1
	for (int i = 0; i != searchresult->m_tagArray.GetCount();i++)
d309 1
a309 1
	for (uint32 i = 0; i != iPartCount;i++)
d577 1
a577 1
	for (uint32 i = 0; i != iPartCount; i++)
d598 1
a598 1
		for (int i = 0; i != iSize; i++)
d1294 1
a1294 1
		for (uint32 i = 0; i != GetPartCount(); i++)
d1401 1
a1401 1
		for (uint32 i = 0;i != 8;i++)
d1537 1
a1537 1
	for (uint32 i = 0; i != ceil((double)PARTSIZE / EMBLOCKSIZE);i++)
d5432 1
a5432 1
	for (int i = 0; i != GetPartCount(); i++)
@


1.345
log
@Fixed debuglog problem with a SourceSaver change.
Reinstated removal of ? clients on queue.
@
text
@d1237 1
a1237 1
		for (uint32 i = 0; i != GetPartCount(); i++)
d1250 1
a1250 1
				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && m_srcPartFrequencies[i])  // frequency?
d5328 1
a5328 1
			for (uint32 i = 0; i != GetPartCount(); i++)
d5340 2
a5341 2
					if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && m_srcPartFrequencies[i])  // frequency?
						color = m_srcPartFrequencies[i] < 10 ? crWaiting[m_srcPartFrequencies[i] / 2] : crWaiting[5];	//Ju1i3n - merged with eMulePlus by janes bong
@


1.344
log
@bugfix to limit requests to block borders
@
text
@d4939 1
a4939 1
CString CPartFile::CreateED2KSourceLink(uint32 expirein, int sourcenum)
d5015 1
a5015 2
	AddDebugLogLine(false, _T("Generated ed2k link with %i sources for file '%s'"), (int)srcstoadd.GetCount(), GetFileName());
	while (!srcstoadd.IsEmpty())
d5017 8
a5024 4
		CUpDownClient * pSource = srcstoadd.RemoveHead();
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("| User: %s - Available part count: %i"), pSource->GetUserName(), (int)pSource->GetAvailablePartCount());
		newsource.Format(_T(",%s:%i"), pSource->GetFullIP(), pSource->GetUserPort());
		strLink.Append(newsource);
@


1.343
log
@Added Time Left to WebServer tooltip
@
text
@d1089 1
a1089 1
			const uint32 endOffset = ((uGapStart + EMBLOCKSIZE - 1) > uGapEnd) ? uGapEnd : (uGapStart + EMBLOCKSIZE - 1);
@


1.342
log
@Auto Upload Priority for completed files
@
text
@d5186 11
d5206 1
a5206 1
	             + GetResString(IDS_PARTINFOS2) + _T("\n%s\n%s\n")
d5215 1
@


1.341
log
@Reverted a change
@
text
@d2967 5
a2971 5
	if (CKnownFile::IsAutoPrioritized())
	{
		CKnownFile::SetAutoPriority(false);
		CKnownFile::SetPriority(PR_NORMAL);
	}
@


1.340
log
@Minor changes
@
text
@d1768 3
a1770 2
								pSource->SetDownloadState(DS_NONE);
								//pSource->SetDownloadState(DS_ERROR);
@


1.339
log
@Changed a log line.
@
text
@d1768 2
a1769 2
								//pSource->SetDownloadState(DS_NONE);
								pSource->SetDownloadState(DS_ERROR);
@


1.338
log
@Added some data for debug, changed some log lines.
@
text
@d5014 1
a5014 1
	AddDebugLogLine(false, _T("File: %s - Sources: %i"), GetFileName(), (int)srcstoadd.GetCount());
@


1.337
log
@Some changes (unknown sources and wrong edonkey tags)
@
text
@a1710 4
				// DonGato: to workaround the remaining unknown sources
					if(!pSource->m_pReqPartFile)
						pSource->m_pReqPartFile = this;

d5014 1
a5014 1
	AddDebugLogLine(false, _T("Sources: %i"), (int)srcstoadd.GetCount());
d5018 1
a5018 1
		AddDebugLogLine(false, _T("Available part count: %i"), (int)pSource->GetAvailablePartCount());
@


1.336
log
@final fix for a timeouted clients
@
text
@d1711 4
a1718 2
						//	DonGato: needed to update the source count
						//	GetTransferringSrcCount() isn't updated inside this function.
d1720 1
a1720 1
							//eklmn: since client can be droped due timeout it needs to check the state 
d1723 2
d1750 6
a1755 6
						if (!bAlreadyCounted)
						{
							uBannedSrcCount++;
							bAlreadyCounted = true;
						}
						break;
d1758 7
a1764 7
						if (!bAlreadyCounted)
						{
							uErrorSrcCount++;
							bAlreadyCounted = true;
							pSource->Disconnected();
						}
						break;
d1785 10
a1794 2
						if (dwCurTick - pSource->GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000)
						{
d1797 1
a1797 1
								uTimeoutSrcCount++;
d1800 1
a1800 1
							g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
a1801 8
						}
						if (!bAlreadyCounted)
						{
							uConnectedSrcCount++;
							bAlreadyCounted = true;
						}
						bReaskDownload = true;
						break;
d1804 12
a1815 12
						if (!bAlreadyCounted)
						{
							uLowToLowIDSrcCount++;
							bAlreadyCounted = true;
						}
						if ( ((dwCurTick - lastpurgetime) > PURGE_TIME)
						     && (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() * .8)) )
						{
							g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
							lastpurgetime = dwCurTick;
							break;
						}
d1817 2
a1818 2
						if (g_eMuleApp.m_pServerConnect->IsLowID())
							break;
@


1.335
log
@removed dispensible semicolon
@
text
@d1633 1
a1633 2
			m_downloadingSourceList.GetNext(pos1);
			pSource = m_downloadingSourceList.GetAt(pos2);
d1636 6
d1645 1
d1647 1
@


1.334
log
@Fixes (Log2File, ServerList static names, Stop/Pause files)
@
text
@d3457 1
a3457 1
		pSource = m_downloadingSourceList.GetNext(pos);;
@


1.333
log
@*** empty log message ***
@
text
@d3451 1
a3451 1
	POSITION pos1, pos2;
d3455 1
a3455 1
	for (pos1 = m_downloadingSourceList.GetHeadPosition();(pos2 = pos1) != NULL;)
d3457 1
a3457 2
		m_downloadingSourceList.GetNext(pos1);
		pSource = m_downloadingSourceList.GetAt(pos2);
d3515 1
a3515 1
	POSITION pos1, pos2;
d3519 1
a3519 1
	for (pos1 = m_downloadingSourceList.GetHeadPosition();(pos2 = pos1) != NULL;)
d3521 1
a3521 2
		m_downloadingSourceList.GetNext(pos1);
		pSource = m_downloadingSourceList.GetAt(pos2);
d3535 1
a3535 1
			for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL;)
d3537 1
a3537 2
				m_srcLists[sl].GetNext(pos1);
				CUpDownClient* pSource = m_srcLists[sl].GetAt(pos2);
@


1.332
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@a3448 3
//eklmn: set status to PS_STOPPED in order to prevent any action from other threads
//SetStatus(PS_STOPPED); <- DonGato: this is wrong, we break the sharing of incomplete files and make a bogus tag

d3453 1
a3454 1
	Packet* packet = new Packet(OP_CANCELTRANSFER);
a3458 1
		;
a3472 2
//	it is poitless to hide sources if they will be deleted
//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.HideSources(this); // cax2 closefile bugfix
a3473 1
	
a3514 4
//eklmn: set status to PS_PAUSED in order to prevent any action from other threads
//SetStatus(PS_PAUSED); <- DonGato: this is wrong, we break the sharing of incomplete files and make a bogus tag

	Packet* packet = new Packet(OP_CANCELTRANSFER);
d3517 1
a3523 1
		;
a3560 1
//	^- eklmn: bugfix(02): file were paused not properly.... (who forgot the brackets?! :O)
@


1.331
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d106 1
a106 1
		AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_LINKERROR), buffer);
d128 1
a128 1
			AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_SKIPZEROLENGTHFILE), m_strFileName);
d146 1
a146 1
		AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_LINKERROR), buffer);
d301 1
a301 1
		AddLogLine(false, RGB_RED + GetResString(IDS_ERR_CREATEPARTFILE));
d359 1
a359 1
			AddLogLine(false, RGB_RED + GetResString(IDS_ERR_OPENMET), m_strPartMetFileName, m_strFileName);
d368 1
a368 1
			AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_BADMETVERSION), m_strPartMetFileName, m_strFileName);
d374 1
a374 1
			AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_HASHSETCORR), in_filename);
d389 1
a389 1
						AddLogLine(true, RGB_RED + GetResString(IDS_ERR_METCORRUPT), m_strPartMetFileName, m_strFileName);
d506 1
a506 1
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_FILEERROR), m_strPartMetFileName, m_strFileName, error);
d557 1
a557 1
		AddLogLine(false, RGB_RED + GetResString(IDS_ERR_FILEOPEN), m_strFullName, m_strFileName);
d619 1
a619 1
		AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_REHASH), m_strFileName);
d667 1
a667 1
		AddLogLine(false, RGB_RED + GetResString(IDS_ERR_SAVEMET), GetResString(IDS_ERR_PART_FNF), m_strPartMetFileName, m_strFileName);
d675 1
a675 1
//		AddDebugLogLine(false, RGB_RED + _T("Failed to create backup of %s (%s)"), m_strFullName, GetFileName());
d688 1
a688 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), strTempName);
d770 1
a770 1
		AddLogLine(false, RGB_RED + GetResString(IDS_ERR_SAVEMET), GetErrorMessage(error), m_strPartMetFileName, m_strFileName);
d783 1
a783 1
		AddDebugLogLine(false, RGB_RED + _T("Failed to remove \"%s\" - %s"), m_strFullName, strerror(errno));
d787 1
a787 1
		AddDebugLogLine(false, RGB_RED + _T("Failed to move temporary part.met file \"%s\" to \"%s\" - %s"), strTempName, m_strFullName, strerror(errno));
d809 1
a809 1
		AddLogLine(false, RGB_RED + _T("Error by saving %s - %s"), dfpath, GetErrorMessage(error));
d837 1
a837 1
				AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_FOUNDCORRUPTION), i + 1, m_strFileName);
d2870 1
a2870 1
			AddLogLine(true, RGB_RED + str);
d2882 1
a2882 1
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName());
d2897 2
a2898 2
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), strerror(errno));
			AddLogLine(false, RGB_RED + GetResString(IDS_ERR_COMPLETIONFAILED2));
d2916 1
a2916 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), m_strFullName);
d2921 1
a2921 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), dirFile);
d2926 1
a2926 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), bakFile);
d2931 1
a2931 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), strSettingsFile);
d2948 1
a2948 1
	AddLogLine(true, RGB_SEA_GREEN + GetResString(IDS_DOWNLOADDONE), GetFileName());
d3064 1
a3064 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), m_strFullName);
d3068 1
a3068 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), partfilename);
d3073 1
a3073 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), dirFile);
d3078 1
a3078 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), bakFile);
d3083 1
a3083 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), strSettingsFile);
d3109 1
a3109 1
		AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_HASHERRORWARNING), GetFileName());
d3115 1
a3115 1
		AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_INCOMPLETEHASH), GetFileName());
d4272 1
a4272 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_DELETEFAILED), GetStatsFullPath());
d4599 1
a4599 1
					AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_PARTCORRUPT), uPartNumber, GetFileName());
d4624 1
a4624 1
					AddLogLine(true, RGB_SEA_GREEN + GetResString(IDS_ICHWORKED), uPartNumber, GetFileName());
d4652 2
a4653 2
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
			AddLogLine(false, RGB_RED + GetResString(IDS_DWTOT_FS), strTemp);
d4662 1
a4662 1
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetErrorMessage(error));
d4670 1
a4670 1
		AddLogLine(true, RGB_RED + GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetResString(IDS_UNKNOWN));
d4988 1
a4988 1
		AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_SOURCELINKFAILED));
@


1.330
log
@Added some colors to the logs...
@
text
@d106 1
a106 1
		AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_LINKERROR), buffer);
d128 1
a128 1
			AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_SKIPZEROLENGTHFILE), m_strFileName);
d146 1
a146 1
		AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_LINKERROR), buffer);
d301 1
a301 1
		AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_CREATEPARTFILE));
d359 1
a359 1
			AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_OPENMET), m_strPartMetFileName, m_strFileName);
d368 1
a368 1
			AddLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_BADMETVERSION), m_strPartMetFileName, m_strFileName);
d374 1
a374 1
			AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_HASHSETCORR), in_filename);
d389 1
a389 1
						AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_METCORRUPT), m_strPartMetFileName, m_strFileName);
d506 1
a506 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_FILEERROR), m_strPartMetFileName, m_strFileName, error);
d557 1
a557 1
		AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_FILEOPEN), m_strFullName, m_strFileName);
d619 1
a619 1
		AddLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_REHASH), m_strFileName);
d667 1
a667 1
		AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_SAVEMET), GetResString(IDS_ERR_PART_FNF), m_strPartMetFileName, m_strFileName);
d675 1
a675 1
//		AddDebugLogLine(false, "<COLOR=255,0,0>Failed to create backup of %s (%s)", m_strFullName, GetFileName());
d688 1
a688 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), strTempName);
d770 1
a770 1
		AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_SAVEMET), GetErrorMessage(error), m_strPartMetFileName, m_strFileName);
d783 1
a783 1
		AddDebugLogLine(false, _T("<COLOR=255,0,0>Failed to remove \"%s\" - %s"), m_strFullName, strerror(errno));
d787 1
a787 1
		AddDebugLogLine(false, _T("<COLOR=255,0,0>Failed to move temporary part.met file \"%s\" to \"%s\" - %s"), strTempName, m_strFullName, strerror(errno));
d809 1
a809 1
		AddLogLine(false, "<COLOR=255,0,0>Error by saving %s - %s", dfpath, GetErrorMessage(error));
d837 1
a837 1
				AddLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_FOUNDCORRUPTION), i + 1, m_strFileName);
d2183 1
a2183 1
//	AddDebugLogLine(false,"RCV: %i sources from server, %i low id dropped, %i possible sources",count,debug_lowiddropped,debug_possiblesources);
d2285 1
a2285 1
	//AddDebugLogLine(false,"Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2469 1
a2469 1
	//	AddDebugLogLine(false,"Priority 1 (Unique unfinished part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2485 1
a2485 1
	//	AddDebugLogLine(false,"Priority 2 (Unique unrequested part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2493 1
a2493 1
	//	AddDebugLogLine(false,"Priority 3 (Rarest unfinished part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2509 1
a2509 1
	//	AddDebugLogLine(false,"Priority 4 (Rarest unrequested part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2515 1
a2515 1
	//	AddDebugLogLine(false,"Priority 5 (Preview part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2524 1
a2524 1
	//	AddDebugLogLine(false,"Priority 6 (Widespread unfinished part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2533 1
a2533 1
	//	AddDebugLogLine(false,"Priority 7 (Widespread unrequested part). File: %s, Part : %u", this->GetFileName(), nGoodPart);
d2540 1
a2540 1
//	AddDebugLogLine(false,"ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), nNumAvailableNeededParts, curBlockedPartsList.GetCount(),nGoodPart);
d2870 1
a2870 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + str);
d2882 1
a2882 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName());
d2897 2
a2898 2
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_COMPLETIONFAILED), GetFileName(), strerror(errno));
			AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_COMPLETIONFAILED2));
d2916 1
a2916 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), m_strFullName);
d2921 1
a2921 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), dirFile);
d2926 1
a2926 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), bakFile);
d2931 1
a2931 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), strSettingsFile);
d2948 1
a2948 1
	AddLogLine(true, _T("<COLOR=51,153,102>") + GetResString(IDS_DOWNLOADDONE), GetFileName());
d3064 1
a3064 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), m_strFullName);
d3068 1
a3068 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), partfilename);
d3073 1
a3073 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), dirFile);
d3078 1
a3078 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), bakFile);
d3083 1
a3083 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), strSettingsFile);
d3109 1
a3109 1
		AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_HASHERRORWARNING), GetFileName());
d3115 1
a3115 1
		AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_INCOMPLETEHASH), GetFileName());
d3363 1
a3363 1
	//AddLogLine(true,false,CString("Movie2::Mode:%d old:%d new:%d rarem:%d - The new & old ones are nonrare,samerare or forced, now we decide if new is a better movie or could change to movie..."),mode,oldchunk,newchunk,raremovie);
d3618 1
a3618 1
	//AddLogLine(true,CString("Resetting LastSearchTime:%d in Filename:%s"),m_dwLastFileSourcesRequestTime,GetFileName());
d4272 1
a4272 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_DELETEFAILED), GetStatsFullPath());
d4599 1
a4599 1
					AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_PARTCORRUPT), uPartNumber, GetFileName());
d4624 1
a4624 1
					AddLogLine(true, _T("<COLOR=51,153,102>") + GetResString(IDS_ICHWORKED), uPartNumber, GetFileName());
d4652 2
a4653 2
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
			AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_DWTOT_FS), strTemp);
d4662 1
a4662 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetErrorMessage(error));
d4670 1
a4670 1
		AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetResString(IDS_UNKNOWN));
d4988 1
a4988 1
		AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_SOURCELINKFAILED));
@


1.329
log
@Minor changes
@
text
@d106 1
a106 1
		AddLogLine(true, IDS_ERR_LINKERROR, buffer);
d128 1
a128 1
			AddLogLine(true, IDS_SKIPZEROLENGTHFILE, m_strFileName);
d146 1
a146 1
		AddLogLine(true, IDS_ERR_LINKERROR, buffer);
d301 1
a301 1
		AddLogLine(false, IDS_ERR_CREATEPARTFILE);
d359 1
a359 1
			AddLogLine(false, IDS_ERR_OPENMET, m_strPartMetFileName, m_strFileName);
d368 1
a368 1
			AddLogLine(false, IDS_ERR_BADMETVERSION, m_strPartMetFileName, m_strFileName);
d374 1
a374 1
			AddLogLine(true, IDS_ERR_HASHSETCORR, in_filename);
d389 1
a389 1
						AddLogLine(true, IDS_ERR_METCORRUPT, m_strPartMetFileName, m_strFileName);
d506 1
a506 1
			AddLogLine(true, IDS_ERR_FILEERROR, m_strPartMetFileName, m_strFileName, error);
d557 1
a557 1
		AddLogLine(false, IDS_ERR_FILEOPEN, m_strFullName, m_strFileName);
d619 1
a619 1
		AddLogLine(false, IDS_ERR_REHASH, m_strFileName);
d667 1
a667 1
		AddLogLine(false, IDS_ERR_SAVEMET, GetResString(IDS_ERR_PART_FNF), m_strPartMetFileName, m_strFileName);
d675 1
a675 1
//		AddDebugLogLine(false, "Failed to create backup of %s (%s)", m_strFullName, GetFileName());
d688 1
a688 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, strTempName);
d770 1
a770 1
		AddLogLine(false, IDS_ERR_SAVEMET, GetErrorMessage(error), m_strPartMetFileName, m_strFileName);
d783 1
a783 1
		AddDebugLogLine(false, _T("Failed to remove \"%s\" - %s"), m_strFullName, strerror(errno));
d787 1
a787 1
		AddDebugLogLine(false, _T("Failed to move temporary part.met file \"%s\" to \"%s\" - %s"), strTempName, m_strFullName, strerror(errno));
d809 1
a809 1
		AddLogLine(false, "Error by saving %s - %s", dfpath, GetErrorMessage(error));
d837 1
a837 1
				AddLogLine(false, IDS_ERR_FOUNDCORRUPTION, i + 1, m_strFileName);
d2870 1
a2870 1
			AddLogLine(true, str);
d2882 1
a2882 1
			AddLogLine(true, IDS_ERR_COMPLETIONFAILED, GetFileName());
d2897 2
a2898 2
			AddLogLine(true, IDS_ERR_COMPLETIONFAILED, GetFileName(), strerror(errno));
			AddLogLine(false, IDS_ERR_COMPLETIONFAILED2);
d2916 1
a2916 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, m_strFullName);
d2921 1
a2921 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, dirFile);
d2926 1
a2926 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, bakFile);
d2931 1
a2931 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, strSettingsFile);
d2948 1
a2948 1
	AddLogLine(true, IDS_DOWNLOADDONE, GetFileName());
d3064 1
a3064 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, m_strFullName);
d3068 1
a3068 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, partfilename);
d3073 1
a3073 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, dirFile);
d3078 1
a3078 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, bakFile);
d3083 1
a3083 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, strSettingsFile);
d3109 1
a3109 1
		AddLogLine(true, IDS_ERR_HASHERRORWARNING, GetFileName());
d3115 1
a3115 1
		AddLogLine(true, IDS_ERR_INCOMPLETEHASH, GetFileName());
d4272 1
a4272 1
		AddLogLine(true, IDS_ERR_DELETEFAILED, GetStatsFullPath());
d4599 1
a4599 1
					AddLogLine(true, IDS_ERR_PARTCORRUPT, uPartNumber, GetFileName());
d4624 1
a4624 1
					AddLogLine(true, IDS_ICHWORKED, uPartNumber, GetFileName());
d4652 2
a4653 2
			AddLogLine(true, IDS_ERR_OUTOFSPACE, GetFileName());
			AddLogLine(false, IDS_DWTOT_FS, strTemp);
d4662 1
a4662 1
			AddLogLine(true, IDS_ERR_WRITEERROR, GetFileName(), GetErrorMessage(error));
d4670 1
a4670 1
		AddLogLine(true, IDS_ERR_WRITEERROR, GetFileName(), GetResString(IDS_UNKNOWN));
d4988 1
a4988 1
		AddLogLine(true, IDS_SOURCELINKFAILED);
@


1.328
log
@added Queue Full (QF) to sources information in tooltips
@
text
@d1598 1
a1598 1
	uint32			dwLastNoNeededCheckTime;
d2034 1
a2034 1
								if (!bIsNNS || (dwCurTick -dwLastNoNeededCheckTime) > FILEREASKTIME)
d2059 1
a2059 1
					if (!bIsNNS || (dwCurTick -dwLastNoNeededCheckTime) > FILEREASKTIME)
@


1.327
log
@he-he typing bug
@
text
@d5212 1
d5272 1
@


1.326
log
@fixed m_srcPartFrequencies[i] initialization
@
text
@d312 1
a312 1
		m_BlockedParts = NULL;
@


1.325
log
@Minor changes (until we find a better way)
@
text
@d311 2
a312 2
		m_srcPartFrequencies.Add(0);
		m_BlockedParts[i] = NULL;
d579 1
a579 1
		m_srcPartFrequencies.Add(0);
@


1.324
log
@Force update of status categories when files are paused, stopped, resumed or completed.
@
text
@d1761 2
a1762 1
								pSource->SetDownloadState(DS_NONE);
@


1.323
log
@minor tweaks in process of DL clients
@
text
@d2999 2
d3508 2
d3567 2
d3604 2
@


1.322
log
@fix in new behaviour after DL timeout
@
text
@d1637 4
a1641 1
				dwCurrentDataRate = pSource->CalculateDownloadRate();
d1710 4
a1714 1
							dwCurrentDataRate = pSource->CalculateDownloadRate();
d1716 1
a1716 1
							if (dwReduceDownload && pSource->GetDownloadState() == DS_DOWNLOADING)
@


1.321
log
@two-pointer loop for downloadingSourceList
@
text
@d1731 1
d1745 1
a1745 1
							g_eMuleApp.m_pDownloadQueue->RemoveSource(pSource);
d2000 2
d2013 1
d2024 3
a2026 1
								bool bIsNNS = pSource->m_otherNoNeededMap.Lookup(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile(), dwLastNoNeededCheckTime);
d2047 1
d2050 2
a2051 1
					bool bIsNNS = pSource->m_otherNoNeededMap.Lookup(this,dwLastNoNeededCheckTime);
@


1.320
log
@corrected handlilng of hello packet & behaviour after DL timeout
@
text
@d1631 1
a1631 1
		for (pos1 = m_downloadingSourceList.GetHeadPosition(); pos1 != NULL;)
d1633 2
a1634 1
			pSource = m_downloadingSourceList.GetNext(pos1);
@


1.319
log
@fixed FlushBuffer collision
@
text
@d1743 1
@


1.318
log
@1) remove file from m_otherRequestList in case Stop or Complete
2) handling of data blocks was slightly changed
@
text
@d4484 2
@


1.317
log
@perform CastItoXBytes on free disk space output
@
text
@d2997 1
a2997 1
	CUpDownClient* cur_source;
d3002 1
a3002 1
			cur_source = m_srcLists[sl].GetHead();
d3005 2
a3006 2
				if (!cur_source->SwapToAnotherFile(NULL))	//eklmn: bugfix(08): A4AF switching
					g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_source);
d3009 1
a3009 1
					g_eMuleApp.m_pDownloadList->RemoveSource(cur_source, this);
d3012 1
a3012 1
				g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_source);
d3015 1
a3015 1
//eklmn: remove A4AF entry from graphical list
d3021 3
a3023 2
			cur_source = m_A4AFsrcList.GetAt(pos2);
			g_eMuleApp.m_pDownloadList->RemoveSource(cur_source, this);
d3461 2
@


1.316
log
@removed GetResString from a log line
@
text
@d4619 1
a4619 1
			uint64 iSpace = GetFreeDiskSpaceX(m_strTempDir);
d4621 1
a4621 1
			strTemp.Format("%i (" + m_strTempDir + ")", iSpace);
d4623 1
a4623 1
			AddLogLine(true, IDS_DWTOT_FS, strTemp);
@


1.315
log
@typo fix
@
text
@d4569 1
a4569 1
					AddLogLine(true, GetResString(IDS_ERR_PARTCORRUPT), uPartNumber, GetFileName());
@


1.314
log
@name correction in GetNextRequestedBlock
@
text
@d2306 1
a2306 1
	CUpDownClient*		pDonwloadingSource;
d2310 2
a2311 2
		pDonwloadingSource = m_downloadingSourceList.GetNext(pos);
		if (pDonwloadingSource && pDonwloadingSource->GetLastDownPartAsked() < iPartCount)
d2313 1
a2313 1
			m_BlockedParts[pDonwloadingSource->GetLastDownPartAsked()] = pDonwloadingSource;
@


1.313
log
@Fixes
@
text
@d2306 1
a2306 1
	CUpDownClient		*pFoundSource;
d2310 2
a2311 2
		pFoundSource = m_downloadingSourceList.GetNext(pos);
		if (pFoundSource && pFoundSource->GetLastDownPartAsked() < iPartCount)
d2313 1
a2313 1
			m_BlockedParts[pFoundSource->GetLastDownPartAsked()] = pFoundSource;
@


1.312
log
@New sockets
@
text
@d2306 1
a2306 1
	CUpDownClient		*pSource;
d2310 2
a2311 2
		pSource = m_downloadingSourceList.GetNext(pos);
		if (pSource && pSource->GetLastDownPartAsked() < iPartCount)
d2313 1
a2313 1
			m_BlockedParts[pSource->GetLastDownPartAsked()] = pSource;
@


1.311
log
@minor changes
@
text
@d2246 1
d2551 1
a2551 1

@


1.310
log
@improved NNS handling in A4AF
@
text
@d4400 1
a4400 1
		AddDebugLogLine(false, _T("File '%s' has already been written from %ld to %ld"), GetFileName(), start, dwEnd);
d4485 1
a4485 1
	uint32	iPartCount = (m_lFileSize / PARTSIZE) + ((m_lFileSize % PARTSIZE) ? 1 : 0);
a4505 4
	//	If the size of the part file is greater than the size of the target file, set it to the
	//	size of the target file.
		if (m_hPartFile.GetLength() > m_lFileSize)
			m_hPartFile.SetLength(m_lFileSize);
d4540 5
d4568 1
a4568 1
					AddLogLine(true, IDS_ERR_PARTCORRUPT, uPartNumber, GetFileName());
@


1.309
log
@percent completed is now even more accurate
@
text
@d1598 1
a1598 1
	static			dwLastReduceDownload = 0;
d1993 1
a1993 1
	//	swap No needed partfiles if possible
d2016 1
d2018 6
a2023 1
								pSource->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
d2032 1
a2032 1
		if (!m_A4AFsrcList.IsEmpty() && g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == this)
d2039 8
a2046 2
				if (pSource != NULL && pSource->m_otherNoNeededList.Find(this) == 0)
					pSource->SwapToAnotherFile(this);
d2176 5
a2180 3
	uint16 iPartCount = GetPartCount();
	uint8 availablecounter = 0;
	uint8 MaxAvailableParts = 0;
d2187 1
a2195 3
//	Calculate a median position
	int M_pos = (int)ceil(iPartCount / 2.0) - 1;	// <- eklmn: feature(00): ICR

d2205 1
a2205 3
				int j = 0; // <- eklmn: feature(00): ICR v2
				availablecounter = 0;
				for (int i = 0; i < iPartCount; i++)
d2207 3
a2209 1
					if (pSource->IsPartAvailable(i))
d2211 11
a2221 6
						if (j == M_pos)
							m_uMedian++;       // <- eklmn: feature(00): ICR
						j++;                            // <- eklmn: feature(00): ICR
						m_srcPartFrequencies[i] += 1;
						availablecounter++;
					} // end: IsPartAv...
a2222 2
				if (availablecounter > MaxAvailableParts)
					MaxAvailableParts = availablecounter;
d2232 1
a2232 1
	if (iPartCount == MaxAvailableParts && availablePartsCount < iPartCount)
d2234 1
a2234 1
	availablePartsCount = MaxAvailableParts;
a2238 1

d3928 2
d3938 4
d3968 3
a3970 1
				if (forClient->m_pReqPartFile == this && forClient->GetPartStatus() && pSource->GetPartStatus())
d3972 1
a3972 3
					uint8 * reqstatus = forClient->GetPartStatus();
					uint8* srcstatus = pSource->GetPartStatus();
					for (int x = 0; x != GetPartCount(); x++)
d3974 1
a3974 1
						if (srcstatus[x] && !reqstatus[x])
d3984 1
a3984 1
					for (int x = 0; x < GetPartCount(); x++)
@


1.308
log
@preventing invalid filename-chars with SetFileName()
@
text
@d1377 11
@


1.307
log
@removed some unused code
@
text
@d63 2
a64 1
				m_strFileName = searchresult->m_tagArray[i]->GetStringValue();
d122 2
a123 1
		m_strFileName = CString(fileLink->GetName());
d393 2
a394 1
					m_strFileName = newtag->GetStringValue();
@


1.306
log
@Fixed the 2 bytes completed on newly added files problem
@
text
@a5237 1
	uint32 allgaps = 0;
a5248 1
			allgaps += cur_gap->m_dwEndOffset - cur_gap->m_dwStartOffset;
@


1.305
log
@percent completed is more accurate (from official)
@
text
@d1176 1
a1176 1
		completedsize = (uint32)((m_lFileSize - (allgaps - 1)));
d1289 1
a1289 1
		uint16	completedParts = 0;
@


1.304
log
@Fix for moving a cat to the last position
@
text
@d1175 2
a1176 2
		m_dblPercentCompleted = ((1.0 - static_cast<double>(allgaps) / m_lFileSize)) * 100;
		completedsize = (uint32)((m_lFileSize - (allgaps + 1)));
@


1.303
log
@some step to fix interim bug 0000437 (.bak files in incoming folder)
@
text
@d670 3
a672 2
	if (!::CopyFile(m_strFullName, strBakFile, FALSE))
		AddDebugLogLine(false, "Failed to create backup of %s (%s)", m_strFullName, GetFileName());
@


1.302
log
@Minor changes
@
text
@d285 1
a285 1
	fullname.Format(_T("%s\\%s"), m_strTempDir, m_strPartMetFileName);
d295 1
a295 1
	CString partfull = fullname.Left(fullname.GetLength() - 4);
d350 1
a350 1
	fullname.Format(_T("%s\\%s"), directory, m_strPartMetFileName);
d355 1
a355 1
		if (!file.Open(fullname, CFile::modeRead))
d482 1
a482 1
				CString dfpath = CString(RemoveFileExtension(fullname)) + CString(".dir");
d545 1
a545 1
	if (fullname.Right(7).CompareNoCase(_T(".backup")) == 0)
d547 1
a547 1
		fullname.Truncate(fullname.GetLength() - 7);
d551 1
a551 1
	CString searchpath = fullname.Left(fullname.GetLength() - 4);
d554 1
a554 1
		AddLogLine(false, IDS_ERR_FILEOPEN, fullname, m_strFileName);
d653 10
a662 2
	FILE* file = 0;
	try
d664 21
a684 3
	//backup part.met file
		CString strBakFile = CString(fullname) + CString(".bak");
		::CopyFile(fullname, strBakFile, FALSE);
d686 2
a687 19
	//get filedate
		CFileFind ff;
		CString searchpath = fullname.Left(fullname.GetLength() - 4);
		bool bEnd = !ff.FindFile(searchpath, 0);
		if (!bEnd)
			ff.FindNextFile();
		if (bEnd || ff.IsDirectory())
			throw GetResString(IDS_ERR_PART_FNF);
		CTime lwtime;
		ff.GetLastWriteTime(lwtime);
		m_timetLastWriteDate = mktime(lwtime.GetLocalTm());
		ff.Close();
		uint32 lsc = mktime(lastseencomplete.GetLocalTm());
		CString backupName(fullname);
		backupName.Append(_T(".backup"));

		if (_tremove(backupName) && errno != ENOENT)
			AddLogLine(true, IDS_ERR_DELETEFAILED, backupName);
		_trename(fullname, backupName);
d689 5
a693 4
	//	readfile data form part.met file
		file = _tfopen(fullname, _T("wbS"));
		if (!file)
			throw GetResString(IDS_ERR_OPENMETFILE);
d695 2
a696 2
		uint8 version = PARTFILE_VERSION;
		fwrite(&version, 1, 1, file);
d698 1
a698 1
		fwrite(&m_timetLastWriteDate, 4, 1, file);
d700 1
a700 1
		fwrite(&m_fileHash, 16, 1, file);
d702 4
a705 4
		uint16 parts = m_partHashArray.GetCount();
		fwrite(&parts, 2, 1, file);
		for (int x = 0; x != parts; x++)
			fwrite(m_partHashArray[x], 16, 1, file);
d708 2
a709 2
		uint32 tagcount = m_tagArray.GetCount() + 8 + (gaplist.GetCount() * 2);
		fwrite(&tagcount, 4, 1, file);
d762 26
d789 2
d794 1
a794 3
			CString dfpath = CString(RemoveFileExtension(fullname)) + CString(_T(".dir"));
			CStdioFile f;
			if (f.Open(dfpath, CFile::modeCreate | CFile::modeWrite | CFile::typeText))
d796 2
a797 2
				f.WriteString((LPCTSTR)m_strAlternativePath);
				f.Close();
a800 6

		if (ferror(file))
			throw CString(_T("unexpected write error"));

		if (_tremove(backupName) && errno != ENOENT)
			AddLogLine(true, IDS_ERR_DELETEFAILED, backupName);
d802 1
a802 1
	catch (char * error)
d805 3
a807 5
		if (file)
			fclose(file);
		AddLogLine(false, IDS_ERR_SAVEMET, error, m_strPartMetFileName, m_strFileName);
		delete [] error;
		return false;
d809 1
a809 12
	catch (CString error)
	{
		OUTPUT_DEBUG_TRACE();
		if (file)
			fclose(file);
		AddLogLine(false, IDS_ERR_SAVEMET, error.GetBuffer(), m_strPartMetFileName, m_strFileName);
		return false;
	}
//	v1:- eklmn: bugfix(27): by shutdown force OS flush data direct to disk [SlugFiller]
//	if ( !g_eMuleApp.m_pdlgEmule->IsRunning() )
	_commit(_fileno(file));
	fclose(file);
d2163 1
a2163 1
	median = 0;     // <- eklmn: feature(00): ICR
d2185 1
a2185 1
							median++;       // <- eklmn: feature(00): ICR
d2289 1
a2289 1
	uint16		uRarestPart = static_cast<uint16>(floor(0.1 * median)); // 10% from median
d2329 1
a2329 1
			if (median >= (uRarestPart + m_srcPartFrequencies[i]))
d2333 1
a2333 1
					for (int j = 0; j < (median - m_srcPartFrequencies[i] + 1); j++)
d2727 2
a2728 2
	CSingleLock(&m_FileCompleteMutex, TRUE); // will be unlocked on exit
	CString partfilename = fullname.Left(fullname.GetLength() - 4);
d2868 2
a2869 2
	if (_tremove(fullname))
		AddLogLine(true, IDS_ERR_DELETEFAILED, fullname);
d2872 1
a2872 1
	CString dirFile = CString(RemoveFileExtension(fullname)) + CString(".dir");
d2877 1
a2877 1
	CString bakFile = CString(fullname) + CString(".bak");
d2882 1
a2882 1
	CString strSettingsFile = CString(RemoveFileExtension(fullname)) + CString(".settings");
d2894 1
a2894 6
//	-khaos--+++> Save the lost/gain stats!
	g_eMuleApp.m_pGlobPrefs->Add2LostFromCorruption(m_iSessionLostDueToCorruption);
	g_eMuleApp.m_pGlobPrefs->Add2SavedFromCompression(m_iSessionGainDueToCompression);
//	<-----khaos-

	fullname = newname;
d2896 1
a2896 1
	SetFilePath(fullname);
d2899 1
d3013 2
a3014 2
	if (_tremove(fullname))
		AddLogLine(true, IDS_ERR_DELETEFAILED, fullname);
d3016 1
a3016 1
	CString partfilename = fullname.Left(fullname.GetLength() - 4);
d3021 1
a3021 1
	CString dirFile = CString(RemoveFileExtension(fullname)) + CString(".dir");
d3026 1
a3026 1
	CString bakFile = CString(fullname) + CString(".bak");
d3031 1
a3031 1
	CString strSettingsFile = CString(RemoveFileExtension(fullname)) + CString(".settings");
d3105 1
a3105 1
bool CPartFile::IsCorruptedPart(uint16 partnumber)
d3109 1
a3109 1
	return corrupted_list.Find(partnumber);
d3115 1
a3115 1

d4083 1
a4083 1
	return RemoveFileExtension(fullname) + _T(".stats");
d4149 1
a4149 1
	if (!fullname || IsBadStringPtr(fullname, MAX_PATH))
d4289 1
a4289 1
	CString strIniFile = CString(RemoveFileExtension(fullname)) + CString(".settings");
d4313 1
a4313 1
	CString strIniFile = CString(RemoveFileExtension(fullname)) + CString(".settings");
@


1.301
log
@Minor changes
@
text
@d1718 1
a1718 3
						if (pSource->m_pRequestSocket)
						{
							if (!pSource->m_pRequestSocket->IsConnected())
d1721 1
d1729 1
a1729 11
						}
						else
						{
							pSource->SetDownloadState(DS_NONE);
							if (!bAlreadyCounted)
							{
								uUnknownSrcCount++;
								bAlreadyCounted = true;
							}
							break;
						}
d1876 5
a1880 5
						if (!bAlreadyCounted)
						{
							uConnectingSrcCount++;
							bAlreadyCounted = true;
						}
d1884 5
a1888 5
						if (!bAlreadyCounted)
						{
							uTooManyConnsSrcCount++;
							bAlreadyCounted = true;
						}
d1892 6
a1897 5
						if (!bAlreadyCounted)
						{
							uNoUploadSrcCount++;
							bAlreadyCounted = true;
						}
d1901 6
a1906 6
						if (!bAlreadyCounted)
						{
							uConnViaServerSrcCount++;
							bAlreadyCounted = true;
						}
						bReaskDownload = true;
d1912 2
a1913 2
						uReqHashSrcCount++;
						break;
d1918 1
a1918 1
						uUnknownSrcCount++;
d1928 1
a1928 1
					//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open
@


1.300
log
@"Get first/last chunks for preview" is now working for .divx movies [n@@boleo]
@
text
@a2719 5
//	-khaos--+++> Save the lost/gain stats!
	g_eMuleApp.m_pGlobPrefs->Add2LostFromCorruption(m_iSessionLostDueToCorruption);
	g_eMuleApp.m_pGlobPrefs->Add2SavedFromCompression(m_iSessionGainDueToCompression);
//	<-----khaos-

d2886 5
@


1.299
log
@Another try to fix the .bak issue
@
text
@d3131 1
a3131 1
	return (_tcsstr(fname, _T(".avi")) || _tcsstr(fname, _T(".ogm")));
@


1.298
log
@Maybe we have a problem there...
@
text
@d650 1
a5568 1

@


1.297
log
@Various fixes for Interim beta2 reported bugs
@
text
@d5483 2
a5484 1
		SavePartFile();
@


1.296
log
@Fix for Video Player problem
@
text
@d3114 7
a3120 2
//	return (IsAviMovie()||IsMpgMovie());
	return (ED2KFT_VIDEO == GetED2KFileTypeID(GetFileName()));
a3126 1
//	DonGato, updated by Vorlost
a3140 1
//	DonGato, updated by Vorlost
d3144 1
a3144 1
	return (_tcsstr(fname, _T(".mpg")) || _tcsstr(fname, _T(".mpe")) || _tcsstr(fname, _T(".dat")) || _tcsstr(fname, _T(".bin")));
@


1.295
log
@Fix for corruption/compression gain problem
@
text
@d828 1
a828 1
			return ;
a1137 2
//	Barry - The met file is now updated in FlushBuffer()
//SavePartFile();
d3767 6
d3774 1
d3776 1
d3779 4
a3782 4
			CString runDir = player;
			int i = runDir.ReverseFind('\\');
			runDir = (i >= 0) ? runDir.Left(i + 1) : _T("");
			ShellExecute(NULL, _T("open"), player, strLine, runDir, SW_SHOWNORMAL);
@


1.294
log
@Formatting, comments, and name changes.
@
text
@d208 2
d2722 2
a2723 2
	g_eMuleApp.m_pGlobPrefs->Add2LostFromCorruption(m_iLostDueToCorruption);
	g_eMuleApp.m_pGlobPrefs->Add2SavedFromCompression(m_iGainDueToCompression);
d4344 1
d4346 2
d4524 1
@


1.293
log
@Formatting, comments, and name changes.
@
text
@d301 5
a305 5
	const uint16 partCount = GetPartCount();
	m_srcPartFrequencies.SetSize(partCount);
	m_BlockedParts.SetSize(partCount);	// eklmn: ICR 2.9
	m_ReqParts.SetSize(partCount);	//eklmn: ICR 2.10
	for (uint32 i = 0; i != partCount;i++)
d568 5
a572 5
	const uint16 partCount = GetPartCount();
	m_srcPartFrequencies.SetSize(partCount);
	m_BlockedParts.SetSize(partCount);	//eklmn: ICR2.9+
	m_ReqParts.SetSize(partCount); //eklmn: ICR 2.10
	for (uint32 i = 0; i != partCount; i++)
d660 2
a661 2
		bool end = !ff.FindFile(searchpath, 0);
		if (!end)
d663 1
a663 1
		if (end || ff.IsDirectory())
d797 1
a797 1
void CPartFile::PartFileHashFinished(CKnownFile* result)
d811 1
a811 1
			if (!(result->GetPartHash(i) && !md4cmp(result->GetPartHash(i), GetPartHash(i))))
d820 1
a820 1
	delete result;
d846 1
a846 1
void CPartFile::AddGap(uint32 start, uint32 end)
d854 1
a854 1
		if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= end)
d860 1
a860 1
		else if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwStartOffset <= end)
d862 1
a862 1
			end = cur_gap->m_dwEndOffset;
d867 1
a867 1
		else if (cur_gap->m_dwEndOffset <= end && cur_gap->m_dwEndOffset >= start)
d874 1
a874 1
		else if (start >= cur_gap->m_dwStartOffset && end <= cur_gap->m_dwEndOffset)
d881 1
a881 1
	new_gap->m_dwEndOffset = end;
d889 2
a890 2
//	IsComplete() returns false if there are gaps in the range 'start' to 'end' (inclusive).
bool CPartFile::IsComplete(uint32 start, uint32 end)
d894 2
a895 2
	if (end >= m_lFileSize)
		end = m_lFileSize - 1;
d900 4
a903 4
		if ( (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= end)	// gap is inside range (this check is unnecessary)
		     || (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwStartOffset <= end)	// gap starts inside range
		     || (cur_gap->m_dwEndOffset <= end && cur_gap->m_dwEndOffset >= start)		// gap ends inside range
		     || (start >= cur_gap->m_dwStartOffset && end <= cur_gap->m_dwEndOffset) )	// range is inside gap
d915 1
a915 1
bool CPartFile::IsPureGap(uint32 start, uint32 end)
d919 2
a920 2
	if (end >= m_lFileSize)
		end = m_lFileSize - 1;
d924 1
a924 1
		if (start >= cur_gap->m_dwStartOffset && end <= cur_gap->m_dwEndOffset)
d935 1
a935 1
bool CPartFile::IsAlreadyRequested(uint32 start, uint32 end)
d942 1
a942 1
		if ((start <= cur_block->m_dwEndOffset) && (end >= cur_block->m_dwStartOffset))
d950 2
a951 3


bool CPartFile::GetNextEmptyBlockInPart(uint16 partNumber, Requested_Block_Struct *result)
d955 4
a958 4
	Gap_Struct * firstGap;
	Gap_Struct *currentGap;
	uint32 end;
	uint32 blockLimit;
d961 2
a962 2
	uint32 partStart = (PARTSIZE * partNumber);
	uint32 start = partStart;
d965 1
a965 1
	uint32 partEnd = (PARTSIZE * (partNumber + 1)) - 1;
d972 1
a972 1
		firstGap = NULL;
d977 1
a977 1
			currentGap = gaplist.GetAt(pos);
d979 1
a979 1
			if ((currentGap->m_dwStartOffset <= partEnd) && (currentGap->m_dwEndOffset >= start))
d982 2
a983 2
				if ((firstGap == NULL) || (currentGap->m_dwStartOffset < firstGap->m_dwStartOffset))
					firstGap = currentGap;
d988 1
a988 1
		if (firstGap == NULL)
d992 2
a993 2
		if (start < firstGap->m_dwStartOffset)
			start = firstGap->m_dwStartOffset;
d1000 6
a1005 6
		end = firstGap->m_dwEndOffset;
		blockLimit = partStart + (EMBLOCKSIZE * (((start - partStart) / EMBLOCKSIZE) + 1)) - 1;
		if (end > blockLimit)
			end = blockLimit;
		if (end > partEnd)
			end = partEnd;
d1008 1
a1008 1
		if (!IsAlreadyRequested(start, end))
d1011 1
a1011 1
			if (result != NULL)
d1013 4
a1016 4
				result->m_dwStartOffset = start;
				result->m_dwEndOffset = end;
				md4cpy(result->m_fileHash, GetFileHash());
				result->m_dwBytesTransferred = 0;
d1023 1
a1023 1
			start = end + 1;
d1027 1
a1027 1
		if (end == partEnd)
d1036 2
a1037 3


void CPartFile::GetGapsInPart(CUpDownClient* sender, uint16 numPart, Requested_Block_Struct** newblocks, uint16* count) 	//jicxicmic
d1099 1
a1099 1
void CPartFile::FillGap(uint32 start, uint32 end)
d1107 1
a1107 1
		if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwEndOffset <= end)
d1113 1
a1113 1
		else if (cur_gap->m_dwStartOffset >= start && cur_gap->m_dwStartOffset <= end)
d1115 1
a1115 1
			cur_gap->m_dwStartOffset = end + 1;
d1117 1
a1117 1
		else if (cur_gap->m_dwEndOffset <= end && cur_gap->m_dwEndOffset >= start)
d1121 1
a1121 1
		else if (start >= cur_gap->m_dwStartOffset && end <= cur_gap->m_dwEndOffset)
d1126 1
a1126 1
			cur_gap->m_dwStartOffset = end + 1;
d1274 1
a1274 1
			uint32	end = (i + 1) * PARTSIZE - 1;
d1277 1
a1277 1
			if (end > m_lFileSize)
d1279 1
a1279 1
				end = m_lFileSize;
d1283 1
a1283 1
			if (IsComplete(i * PARTSIZE, end))
d1421 3
a1423 3
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
				if ( cur_src->GetDownloadState() != DS_ONQUEUE && cur_src->GetDownloadState() != DS_DOWNLOADING &&
				     cur_src->GetDownloadState() != DS_NONEEDEDPARTS )
d1445 2
a1446 2
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
				if (cur_src->GetDownloadState() != DS_ONQUEUE && cur_src->GetDownloadState() != DS_DOWNLOADING)
d1469 2
a1470 2
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
				if (cur_src->IsCompleteSource())
d1503 1
a1503 1
	uint16 result = 0;
d1507 3
a1509 3
		uint32 end = (PARTSIZE * partnumber) + ((i + 1) * EMBLOCKSIZE) - 1;
		if (end >= PARTSIZE * ((uint32)partnumber + 1))
			end = (PARTSIZE * (partnumber + 1)) - 1;
d1512 4
a1515 4
		if (end >= GetFileSize())
			end = GetFileSize() - 1;
		if (!IsComplete(start, end) && !IsAlreadyRequested(start, end))
			result++;
d1517 1
a1517 1
	return result;
d1539 2
a1540 2
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
				if ((cur_src->GetDownloadState() == DS_NONEEDEDPARTS) || (cur_src->IsRemoteQueueFull()))  //netwolf: katsyonak change
d1542 1
a1542 1
					g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
d2156 1
a2156 1
	CUpDownClient* cur_src;
d2169 1
a2169 1
				cur_src = m_srcLists[sl].GetAt(pos2);
d2174 1
a2174 1
					if (cur_src->IsPartAvailable(i))
d2205 1
a2205 1

d2207 1
a2207 1
uint16 CPartFile::GetNextRequestedBlock(CUpDownClient* sender)	//Cax2 - changed the type of function, left algorithm the same
d2211 1
a2211 1
	if (sender == NULL)
d2215 4
a2218 4
	const int partCount = GetPartCount();
	int16 i_AvailableNeededParts = 0;
	int16 i_CurBlockedParts = 0;
	const uint8 PreviewMode = GetMovieMode();
d2221 2
a2222 2
	uint8* partsav = sender->GetPartStatus();
	uint16 goodpart = sender->GetLastDownPartAsked();
d2224 5
a2228 3
	_Bvector gettingParts;
	sender->ShowDownloadingParts(gettingParts);
	if ((goodpart != 0xFFFF) && GetNextEmptyBlockInPart(goodpart, 0))
d2230 2
a2231 2
	//AddDebugLogLine(false,"Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u", this->GetFileName(), goodpart);
		return sender->GetLastDownPartAsked();
d2235 1
a2235 1
		sender->SetLastDownPartAsked(0xFFFF);
d2238 1
a2238 1
//	Cunstruct Lists of block sorted by priority. Use number of parts to create limited lists and
d2240 6
a2245 6
//CList<int> liRarestReqParts(partCount);	// priority 1 (highest)
	CList<int> liUniqueParts(partCount);    // priority 2
	CList<int> liRarestParts(partCount);	// priority 4
	CList<int> liMovieParts(5);            	// priority 5 => only first+last parts
//CList<int> liReqParts(partCount);	// priority 6
	CList<int> liRandomParts(partCount);	// priority 7
d2247 5
a2251 5
	CList<uint16, uint16> m_CurBlockedParts;
	uint32 LastPartSize = 0;

//	scaning for requsted chunks in order to find how much they filled.
	for (int i = 0; i < partCount ; i++)
d2253 1
a2253 1
		if (sender->IsPartAvailable(i) == true)
d2257 1
a2257 1
				i_AvailableNeededParts++;
d2260 1
d2262 2
a2263 1
	//	fill the m_BlockedParts array with NULL
d2265 4
a2268 1
	} // end: scanning (for ...)
a2269 2
//	scan DownloadList for Blocked parts
	CUpDownClient* cur_src;
d2272 2
a2273 2
		cur_src = m_downloadingSourceList.GetNext(pos);
		if (cur_src && cur_src->GetLastDownPartAsked() < partCount)
d2275 2
a2276 2
			m_BlockedParts[cur_src->GetLastDownPartAsked()] = cur_src;
			i_CurBlockedParts++;
d2280 3
a2282 2
//	define condition of rareness
	uint16 uRarestPart = (uint16)floor(0.1 * median); // 10% from median
d2287 9
a2295 5
	uint16 MostCompletedUniqueReqPart, MostCompletedRarestReqPart, MostCompletedReqPart;
	uint32 m_MostCompletedUniqueReqPart = PARTSIZE;
	uint32 m_MostCompletedRarestReqPart = PARTSIZE;
	uint32 m_MostCompletedReqPart = PARTSIZE;
	for (int i = 0; i < partCount ; i++)
d2297 1
d2300 2
a2301 2
		//	Unique part (only one part exist, try to download it first in order to prevent
		//	file disappearing)
d2304 1
d2306 3
a2308 1
					liUniqueParts.AddHead(i);
d2311 3
a2313 1
					if (m_ReqParts[i] < m_MostCompletedUniqueReqPart)
d2315 2
a2316 2
						MostCompletedUniqueReqPart = i;
						m_MostCompletedUniqueReqPart = m_ReqParts[i];
d2326 1
a2326 1
						liRarestParts.AddHead(i);
d2330 1
a2330 1
					if (m_ReqParts[i] < m_MostCompletedRarestReqPart)
d2332 2
a2333 2
						MostCompletedRarestReqPart = i;
						m_MostCompletedRarestReqPart = m_ReqParts[i];
d2338 1
a2338 1
			switch (PreviewMode)
d2340 43
a2382 29
				case 3:   // 3=AVI(3F,1L)
				if (partCount > 3 && (i == partCount - 1))
					liMovieParts.AddHead(i);
				case 6:  // 6=MPG(3F)
				if (i == 2 && partCount > 2)
					liMovieParts.AddHead(2);
				if (i == 1 && partCount > 1)
					liMovieParts.AddHead(1);
				if (i == 0)
					liMovieParts.AddHead(0);
				break;
				case 7:  // 7=AVI/MPG(2F,2L)
				if (partCount > 3 && (i == partCount - 2))
					liMovieParts.AddHead(i);
				case 2:  // 2=AVI(2F,1L)
				if (partCount > 2 && (i == partCount - 1))
					liMovieParts.AddHead(i);
				case 5:  // 5=MPG(2F)
				if (i == 1 && partCount > 1)
					liMovieParts.AddHead(1);
				if (i == 0)
					liMovieParts.AddHead(0);
				break;
				case 1:  // 1=AVI(1F,1L)
				if (partCount > 1 && (i == partCount - 1))
					liMovieParts.AddHead(i);
				case 4:  // 4=MPG(1F)
				if (i == 0)
					liMovieParts.AddHead(0);
d2385 3
a2387 2
		//	check blocked parts
			if (m_BlockedParts[i] != NULL && i_AvailableNeededParts > i_CurBlockedParts)
d2389 1
d2394 1
a2394 1
					liRandomParts.AddHead(i);
d2398 1
a2398 1
				if (m_ReqParts[i] < m_MostCompletedReqPart)
d2400 2
a2401 2
					MostCompletedReqPart	= i;
					m_MostCompletedReqPart = m_ReqParts[i];
d2408 1
a2408 1
//	------------------------------ Unique & Requesred --------------------------------------------------
d2411 1
a2411 1
	if (m_MostCompletedUniqueReqPart != PARTSIZE && liMovieParts.IsEmpty())
d2413 2
a2414 2
		goodpart = MostCompletedUniqueReqPart;
	//AddDebugLogLine(false,"Priority 1 (Unique unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2416 2
a2417 2
//	------------------------------ Unique & Unrequesred ------------------------------------------------
	else if (!liUniqueParts.IsEmpty() && liMovieParts.IsEmpty())
d2420 4
a2423 2
		if (liUniqueParts.GetCount() == 1)
			goodpart = liUniqueParts.GetHead();
d2426 3
a2428 2
			const uint16 randomness = static_cast<uint16>(ROUND((static_cast<double>(rand()) / RAND_MAX) * (liUniqueParts.GetCount() - 1)));
			goodpart = liUniqueParts.GetAt(liUniqueParts.FindIndex(randomness));
d2430 1
a2430 1
	//AddDebugLogLine(false,"Priority 2 (Unique unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2432 1
a2432 1
//	------------------------------ Rarest & Requesred --------------------------------------------------
d2435 1
a2435 1
	else if (m_MostCompletedRarestReqPart != PARTSIZE)
d2437 2
a2438 2
		goodpart = MostCompletedRarestReqPart;
	//AddDebugLogLine(false,"Priority 3 (Rarest unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2440 2
a2441 2
//	------------------------------ Rarest & Unrequesred ------------------------------------------------
	else if (liRarestParts.IsEmpty() == false)
d2444 4
a2447 2
		if (liRarestParts.GetCount() == 1)
			goodpart = liRarestParts.GetHead();
d2450 3
a2452 2
			const uint16 randomness = static_cast<uint16>(ROUND((static_cast<double>(rand()) / RAND_MAX) * (liRarestParts.GetCount() - 1)));
			goodpart = liRarestParts.GetAt(liRarestParts.FindIndex(randomness));
d2454 1
a2454 1
	//AddDebugLogLine(false,"Priority 4 (Rarest unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2457 1
a2457 1
	else if (liMovieParts.IsEmpty() == false)
d2459 2
a2460 2
		goodpart = liMovieParts.GetHead();
	//AddDebugLogLine(false,"Priority 5 (Preview part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2462 2
a2463 2
//	--------------------------------------- Requesred ----------------------------------------------------
//	Try to complete a UnfinishedPart and MostDownloaded as soon as possible to become a new source
d2465 8
a2472 1
	else if (m_MostCompletedReqPart != PARTSIZE)
d2474 5
a2478 11
		goodpart = MostCompletedReqPart;
	//m_BlockedParts[goodpart] = sender;
	//AddDebugLogLine(false,"Priority 6 (Widespread unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
	}
//	-------------------------------- Unrequesred & Random -------------------------------------------------
	else if (liRandomParts.IsEmpty() == false)
	{
		const uint16 randomness = static_cast<uint16>(ROUND((static_cast<double>(rand()) / RAND_MAX) * (liRandomParts.GetCount() - 1)));
		goodpart = liRandomParts.GetAt(liRandomParts.FindIndex(randomness));
	//m_BlockedParts[goodpart] = sender;
	//AddDebugLogLine(false,"Priority 7 (Widespread unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2481 3
a2483 1
		goodpart = 0xFFFF;
d2485 1
a2485 1
//AddDebugLogLine(false,"ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), i_AvailableNeededParts, m_CurBlockedParts.GetCount(),goodpart);
d2487 21
a2507 11
//	clear lists
	if (!liUniqueParts.IsEmpty())
		liRarestParts.RemoveAll();
	if (!liRarestParts.IsEmpty())
		liRarestParts.RemoveAll();
	if (!liMovieParts.IsEmpty())
		liMovieParts.RemoveAll();
	if (!liRandomParts.IsEmpty())
		liRandomParts.RemoveAll();
	if (!m_CurBlockedParts.IsEmpty())
		m_CurBlockedParts.RemoveAll();
d2509 2
a2510 2
	sender->SetLastDownPartAsked(goodpart);
	return goodpart;
d2516 1
a2516 1

d2582 1
a2582 1
void CPartFile::RemoveBlockFromList(uint32 start, uint32 end)
d2590 1
a2590 1
		if (requestedblocks_list.GetAt(pos2)->m_dwStartOffset <= start && requestedblocks_list.GetAt(pos2)->m_dwEndOffset >= end)
d3152 1
a3152 1
	uint32 lastblock = ceil(static_cast<double>(PARTSIZE) / EMBLOCKSIZE), end;
d3154 1
a3154 1
		end = (PARTSIZE * chunk) + (lastblock * EMBLOCKSIZE) - 1; //Endadress from 1chunk before the last chunk
d3166 1
a3166 1
		if (chunk == (GetPartCount() - 2) && (((GetFileSize() - 1) - MINLASTMOVIESIZE) <= end))
d3176 1
a3176 1
		if (chunk == (GetPartCount() - 2) && (((GetFileSize() - 1) - MINLASTMOVIESIZE) <= end))
d3188 1
a3188 1
		if (chunk == (GetPartCount() - 2) && (((GetFileSize() - 1) - MINLASTMOVIESIZE) <= end))
d3398 1
a3398 1
	CUpDownClient* cur_src;
d3404 1
a3404 1
		cur_src = m_downloadingSourceList.GetAt(pos2);
d3409 1
a3409 1
		cur_src->m_pRequestSocket->SendPacket(packet, false, true);
d3412 1
a3412 1
		cur_src->SetDownloadState(DS_ONQUEUE);
d3465 1
a3465 1
	CUpDownClient* cur_src;
d3472 1
a3472 1
		cur_src = m_downloadingSourceList.GetAt(pos2);
d3477 1
a3477 1
		cur_src->m_pRequestSocket->SendPacket(packet, false, true);
d3480 1
a3480 1
		cur_src->SetDownloadState(DS_ONQUEUE);
d3490 1
a3490 1
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
d3492 2
a3493 2
				if (cur_src->GetDownloadState() == DS_ONQUEUE)
					cur_src->SwapToAnotherFile(NULL);
d3877 1
a3877 1
	CUpDownClient* cur_src;
d3890 1
a3890 1
				cur_src = m_srcLists[sl].GetAt(pos2);
d3894 3
a3896 3
				if ( cur_src->HasLowID()
				     && ( cur_src->GetServerIP() != forClient->GetServerIP()
				          || cur_src->GetServerPort() != forClient->GetServerPort() ) )
d3902 1
a3902 1
				if (cur_src->IsOnLAN())
d3907 1
a3907 1
				switch (cur_src->GetDownloadState())
d3918 1
a3918 1
				if (forClient->m_pReqPartFile == this && forClient->GetPartStatus() && cur_src->GetPartStatus())
d3921 1
a3921 1
					uint8* srcstatus = cur_src->GetPartStatus();
d3931 1
a3931 1
				else if (cur_src->GetPartStatus())	//netwolf 04.05.03
d3933 1
a3933 1
					uint8 * srcstatus = cur_src->GetPartStatus();
d3942 1
a3942 1
				}								// netwolf end
d3947 4
a3950 4
					uint32 dwID = cur_src->GetUserID();
					uint16 nPort = cur_src->GetUserPort();
					uint32 dwServerIP = cur_src->GetServerIP();
					uint16 nServerPort = cur_src->GetServerPort();
d3965 2
a3966 2
	Packet* result = new Packet(&data, OP_EMULEPROT);
	result->m_eOpcode = OP_ANSWERSOURCES;
d3968 1
a3968 1
		result->PackPacket();
d3970 1
a3970 1
	return result;
d4331 1
a4331 1
uint32 CPartFile::WriteToBuffer(uint32 transize, BYTE *data, uint32 start, uint32 end, Requested_Block_Struct *block)
d4339 1
a4339 1
	uint32 lenData = end - start + 1;
d4345 1
a4345 1
	if (IsComplete(start, end))
d4347 1
a4347 1
		AddDebugLogLine(false, _T("File '%s' has already been written from %ld to %ld"), GetFileName(), start, end);
d4359 1
a4359 1
	item->m_dwEndOffset = end;
d4401 1
a4401 1
		FlushBuffer(); //netwolf end
d4432 2
a4433 2
	uint32	partCount = (m_lFileSize / PARTSIZE) + ((m_lFileSize % PARTSIZE) ? 1 : 0);
	bool *changedPart = new bool[partCount];
d4442 1
a4442 1
		for (int partNumber = 0; (uint32)partNumber < partCount; partNumber++)
d4444 1
a4444 1
			changedPart[partNumber] = false;
d4498 1
a4498 1
		for (int partNumber = partCount - 1; partNumber >= 0; partNumber--)
d4501 1
a4501 1
			if (changedPart[partNumber] == false)
d4509 1
a4509 1
			if (IsComplete(PARTSIZE * partNumber, (PARTSIZE * (partNumber + 1)) - 1))
d4512 1
a4512 1
				if (!HashSinglePart(partNumber))
d4514 3
a4516 3
					AddLogLine(true, IDS_ERR_PARTCORRUPT, partNumber, GetFileName());
					AddGap(PARTSIZE * partNumber, (PARTSIZE * partNumber + partRange));
					corrupted_list.AddTail(partNumber);
d4530 1
a4530 1
			else if (IsCorruptedPart(partNumber))
d4533 1
a4533 1
				if (HashSinglePart(partNumber))
d4536 3
a4538 3
					FillGap(PARTSIZE * partNumber, (PARTSIZE * partNumber + partRange));
					RemoveBlockFromList(PARTSIZE * partNumber, (PARTSIZE * partNumber + partRange));
					AddLogLine(true, IDS_ICHWORKED, partNumber, GetFileName());
d4663 2
a4664 2
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
				if (cur_src->GetFileComment().GetLength() > 0)
d4666 1
a4666 1
				if (cur_src->GetFileRating() != PF_RATING_NONE)
d4871 2
a4872 2
				CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
				if (cur_src->HasLowID())
d4876 1
a4876 1
					srcstoadd.AddHead(cur_src);
d4879 1
a4879 1
				if ((sourcenum == 0) || (srcstoadd.GetCount() < sourcenum) || (cur_src->GetAvailablePartCount() > srcstoadd.GetTail()->GetAvailablePartCount()))
d4888 1
a4888 1
						if (cur_srctoadd->GetAvailablePartCount() > cur_src->GetAvailablePartCount())
d4890 1
a4890 1
							srcstoadd.InsertAfter(pos2, cur_src);
d4896 1
a4896 1
						srcstoadd.AddHead(cur_src);
d4939 3
a4941 3
		CUpDownClient * cur_src = srcstoadd.RemoveHead();
		AddDebugLogLine(false, _T("Available part count: %i"), (int)cur_src->GetAvailablePartCount());
		newsource.Format(_T(",%s:%i"), cur_src->GetFullIP(), cur_src->GetUserPort());
d5278 1
a5278 1
void CPartFile::CharFillRange(CString* buffer, double start, double end, char color)
d5281 1
a5281 1
	for (uint32 i = start;i <= end;i++)
@


1.292
log
@Formatting, comments, and name changes.
@
text
@d168 1
a168 1
	transferred = 0;
d289 2
a290 2
	gap->start = 0;
	gap->end = m_lFileSize - 1;
d342 1
a342 1
	transferred = 0;
d407 1
a407 1
					transferred = newtag->GetIntValue();
d465 2
a466 2
							gap->start = -1;
							gap->end = -1;
d469 1
a469 1
							gap->start = newtag->GetIntValue();
d471 1
a471 1
							gap->end = newtag->GetIntValue() - 1;
d521 1
a521 1
		/*if (gap->start >= 0 && gap->end >=0 && gap->start <= gap->end)
d525 1
a525 1
		if (gap->start != -1 && gap->end != -1 && gap->start <= gap->end && gap->start < m_lFileSize)
d527 3
a529 3
			if (gap->end >= m_lFileSize)
				gap->end = m_lFileSize - 1; // Clipping
			AddGap(gap->start, gap->end); // All tags accounted for, use safe adding
d623 4
a626 4
	if (completedsize > transferred)
		m_iGainDueToCompression = completedsize - transferred;
	else if (completedsize != transferred)
		m_iLostDueToCorruption = transferred - completedsize;
d701 1
a701 1
		CFileTag transtag(FT_TRANSFERRED, transferred);
d740 1
a740 1
			CFileTag gapstarttag(namebuffer, gaplist.GetAt(pos)->start);
d745 1
a745 1
			CFileTag gapendtag(namebuffer, (gaplist.GetAt(pos)->end) + 1);
d854 1
a854 1
		if (cur_gap->start >= start && cur_gap->end <= end)
d860 1
a860 1
		else if (cur_gap->start >= start && cur_gap->start <= end)
d862 1
a862 1
			end = cur_gap->end;
d867 1
a867 1
		else if (cur_gap->end <= end && cur_gap->end >= start)
d869 1
a869 1
			start = cur_gap->start;
d874 1
a874 1
		else if (start >= cur_gap->start && end <= cur_gap->end)
d880 2
a881 2
	new_gap->start = start;
	new_gap->end = end;
d900 4
a903 4
		if ( (cur_gap->start >= start && cur_gap->end <= end)	// gap is inside range (this check is unnecessary)
		     || (cur_gap->start >= start && cur_gap->start <= end)	// gap starts inside range
		     || (cur_gap->end <= end && cur_gap->end >= start)		// gap ends inside range
		     || (start >= cur_gap->start && end <= cur_gap->end) )	// range is inside gap
d924 1
a924 1
		if (start >= cur_gap->start && end <= cur_gap->end)
d942 1
a942 1
		if ((start <= cur_block->EndOffset) && (end >= cur_block->StartOffset))
d980 1
a980 1
			if ((currentGap->start <= partEnd) && (currentGap->end >= start))
d983 1
a983 1
				if ((firstGap == NULL) || (currentGap->start < firstGap->start))
d993 2
a994 2
		if (start < firstGap->start)
			start = firstGap->start;
d1001 1
a1001 1
		end = firstGap->end;
d1014 4
a1017 4
				result->StartOffset = start;
				result->EndOffset = end;
				md4cpy(result->FileID, GetFileHash());
				result->transferred = 0;
d1055 1
a1055 1
		if (CurGap->start > uPartEnd || CurGap->end < uPartStart)
d1059 2
a1060 2
		uint32 uGapStart = (CurGap->start < uPartStart) ? uPartStart : CurGap->start;
		const uint32 uGapEnd = (CurGap->end > uPartEnd) ? uPartEnd : CurGap->end;
d1077 5
a1081 5
				block->StartOffset = startOffset;
				block->EndOffset = endOffset;
			//	block->packedsize = 0;
				block->transferred = 0;
				md4cpy(block->FileID, GetFileHash());
d1109 1
a1109 1
		if (cur_gap->start >= start && cur_gap->end <= end)
d1115 1
a1115 1
		else if (cur_gap->start >= start && cur_gap->start <= end)
d1117 1
a1117 1
			cur_gap->start = end + 1;
d1119 1
a1119 1
		else if (cur_gap->end <= end && cur_gap->end >= start)
d1121 1
a1121 1
			cur_gap->end = start - 1;
d1123 1
a1123 1
		else if (start >= cur_gap->start && end <= cur_gap->end)
d1125 2
a1126 2
			uint32 buffer = cur_gap->end;
			cur_gap->end = start - 1;
d1128 2
a1129 2
			cur_gap->start = end + 1;
			cur_gap->end = buffer;
d1153 1
a1153 1
		allgaps += cur_gap->end - cur_gap->start;
d1213 1
a1213 1
		allgaps += cur_gap->end - cur_gap->start;
d1215 2
a1216 2
		uint32 gapstart = cur_gap->start;
		uint32 gapend = cur_gap->end;
d1253 1
a1253 1
					gapend = cur_gap->end;
d1263 1
a1263 1
		s_ChunkBar.FillRange((block->StartOffset + block->transferred), block->EndOffset, crPending);
d2494 1
a2494 1
			if (cur_gap->end < uStart || cur_gap->start > uEnd)
d2496 1
a2496 1
			if (cur_gap->start <= uStart && cur_gap->end > uStart && cur_gap->end < uEnd)
d2498 1
a2498 1
				PartSize -= cur_gap->end - uStart;
d2501 1
a2501 1
			if (cur_gap->start >= uStart && cur_gap->end <= uEnd)
d2503 1
a2503 1
				PartSize -= cur_gap->end - cur_gap->start;
d2506 1
a2506 1
			if (cur_gap->start <= uStart && cur_gap->end >= uEnd)
d2511 1
a2511 1
			if (cur_gap->start > uStart && cur_gap->start < uEnd && cur_gap->end >= uEnd)
d2513 1
a2513 1
				PartSize -= uEnd - cur_gap->start;
d2541 1
a2541 1
		if (requestedblocks_list.GetAt(pos2)->StartOffset <= start && requestedblocks_list.GetAt(pos2)->EndOffset >= end)
d2889 1
a2889 1
//	transferred = m_lFileSize;
d3983 1
a3983 1
		pui32SizeToTransfer += cur_gap->end - cur_gap->start;
d4287 1
a4287 1
	transferred += transize;
d4308 3
a4310 3
	item->data = buffer;
	item->start = start;
	item->end = end;
d4320 1
a4320 1
		if (item->end > queueItem->end)
d4334 1
a4334 1
	FillGap(item->start, item->end);
d4342 1
a4342 1
			item->block->transferred += lenData;
d4402 2
a4403 2
		if (m_hPartFile.GetLength() <= item->end)
			m_hPartFile.SetLength(item->end + 1);	// netwolf: file should not be too large (taab)
d4416 1
a4416 1
			uint32 lenData = item->end - item->start + 1;
d4419 1
a4419 1
			/*int curPart = item->start/PARTSIZE;
d4423 1
a4423 1
			for (uint32 curPart = item->start / PARTSIZE; curPart <= item->end / PARTSIZE; curPart++)
d4428 2
a4429 2
			m_hPartFile.Seek(item->start, CFile::begin);
			m_hPartFile.Write(item->data, lenData);
d4438 1
a4438 1
			delete [] item->data;
d4568 1
a4568 1
			if ((gap->start > start) && (gap->end < bestEnd))
d4571 1
a4571 1
				bestEnd = best->end;
d4580 3
a4582 3
			gap->start = start;
			gap->end = best->start - 1;
			start = best->end + 1;
d4585 1
a4585 1
		else if (best->end < m_lFileSize)
d4588 2
a4589 2
			gap->start = best->end + 1;
			gap->end = m_lFileSize;
d5181 1
a5181 1
			allgaps += cur_gap->end - cur_gap->start;
d5183 2
a5184 2
			uint32 gapstart = cur_gap->start;
			uint32 gapend = cur_gap->end;
d5209 1
a5209 1
						gapend = cur_gap->end;
d5219 1
a5219 1
		CharFillRange(&my_ChunkBar, static_cast<double>(block->StartOffset + block->transferred) * unit, static_cast<double>(block->EndOffset) * unit, crPending);
@


1.291
log
@free disk space needed is now determined with respect to NTFS compression and/or sparse files
@
text
@d2017 2
a2018 1
	//	check if we want a new sources from server 
@


1.290
log
@Changed IDS_ERR_COMPLETIONFAILED and added IDS_ERR_COMPLETIONFAILED2
@
text
@d294 1
d555 1
d2843 1
d3975 1
a3975 1
void CPartFile::GetSizeToTransferAndNeededSpace(uint32& pui32SizeToTransfer, uint32& pui32NeededSpace)
a3982 2
		if (cur_gap->end == GetFileSize() - 1)
			pui32NeededSpace = cur_gap->end - cur_gap->start;
d5435 6
@


1.289
log
@Added second log line for completing errors with the OS error message
@
text
@d2795 2
a2796 2
			AddLogLine(true, IDS_ERR_COMPLETIONFAILED, GetFileName());
			AddLogLine(false, strerror(errno));
@


1.288
log
@quantized sources request from the server
@
text
@d2796 1
@


1.287
log
@removed stupid search in UpdateDownloadAutoPriority()
@
text
@d163 1
a163 1
	lastsearchtime = 0;
d2015 6
a2020 8

	//	check if we want new sources from server
	//uint16 test = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft();
#ifdef OLD_SOCKETS_ENABLED
		if ( ( (!lastsearchtime)
		       || (dwCurTick - lastsearchtime) > SERVERREASKTIME )
		     && g_eMuleApp.m_pServerConnect->IsConnected()
		     && g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > GetSourceCount() )
d2023 2
a2024 8
			lastsearchtime = dwCurTick;

			Packet		*packet = new Packet(OP_GETSOURCES, 16);

			md4cpy(packet->m_pcBuffer, m_fileHash);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->m_dwSize);
			g_eMuleApp.m_pServerConnect->SendPacket(packet, true);
		//	AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
a2025 2
#endif //OLD_SOCKETS_ENABLED

d3484 1
a3484 1
	lastsearchtime = 0;
d3497 1
a3497 1
	if (lastsearchtime > 0)
d3499 2
a3500 2
	//AddLogLine(true,CString("Resetting LastSearchTime:%d in Filename:%s"),lastsearchtime,GetFileName());
		lastsearchtime = 0;
@


1.286
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d3933 1
a3933 1

d3980 1
a3980 2
//^- eklmn: support Source Exchange v2

d3995 1
a3995 1

d4003 1
a4003 1
		CPartFile * partfile = g_eMuleApp.m_pDownloadQueue->GetFileByID(GetFileHash()) ;
d4005 6
a4010 10
		if (partfile != NULL && partfile->IsPartFile())
		{
			int valid_sources = partfile->GetSourceCount() - partfile->GetNotCurrentSourcesCount();
			if (valid_sources < g_eMuleApp.m_pGlobPrefs->PriorityHigh() && priority != PR_HIGH)
				SetPriority(PR_HIGH) ;
			else if (valid_sources >= g_eMuleApp.m_pGlobPrefs->PriorityHigh() && valid_sources < g_eMuleApp.m_pGlobPrefs->PriorityLow() && priority != PR_NORMAL)
				SetPriority(PR_NORMAL) ;
			else if (valid_sources >= g_eMuleApp.m_pGlobPrefs->PriorityLow() && priority != PR_LOW)
				SetPriority(PR_LOW) ;
		}
d4015 1
a4015 1

d4023 1
a4023 1

d4028 1
a4028 1

d4087 1
a4087 1

d4145 1
a4145 1

d4156 1
a4156 1

d4179 1
a4179 1

@


1.285
log
@stability improvements, i.e. delete a client (sorce) if addition to the client list was failed.
@
text
@d191 1
a191 1
	percentcompleted = 0;
d1156 1
a1156 1
		percentcompleted = ((1.0f - (float)allgaps / m_lFileSize)) * 100;
d1161 1
a1161 1
		percentcompleted = 100;
d1202 1
a1202 1
		percentcompleted = 100;
d1296 2
a1297 2
		percentcompleted = (float)completedsize / m_lFileSize * 100;
		percentconfirmed = (float)confirmedsize / m_lFileSize * 100;
d1301 2
a1302 2
		percentcompleted = 100;
		percentconfirmed = 100;
d1313 2
a1314 2
	uint32	wc = (uint32)(percentconfirmed / 100 * w + 0.5f);
	uint32	wp = (uint32)(percentcompleted / 100 * w + 0.5f);
d1504 1
a1504 1
	for (uint32 i = 0; i != ceil((float)PARTSIZE / EMBLOCKSIZE);i++)
d2010 1
a2010 1
				if (pSource && pSource->m_otherNoNeededList.Find(this) == 0)
d2093 1
a2093 1
	uint8 uCount;
d2097 1
a2097 1
	sources.Read(&uCount, 1);
d2099 1
a2099 1
	int source_count_plus_new = GetSourceCount() + uCount;
d2108 1
a2108 1
	for (int i = 0; i < (int)uCount; i++)
d2401 1
a2401 1
			const uint16 randomness = (uint16)ROUND(((float)rand() / RAND_MAX) * (liUniqueParts.GetCount() - 1));
d2422 1
a2422 1
			const uint16 randomness = (uint16)ROUND(((float)rand() / RAND_MAX) * (liRarestParts.GetCount() - 1));
d2445 1
a2445 1
		const uint16 randomness = (uint16)ROUND(((float)rand() / RAND_MAX) * (liRandomParts.GetCount() - 1));
d3108 1
a3108 1
	uint32 lastblock = ceil((float)PARTSIZE / EMBLOCKSIZE), end;
d3291 1
a3291 1
		uint32 lastblock = ceil((float)PARTSIZE / EMBLOCKSIZE);
d4727 1
a4727 1
		num = (float)tot / num + .5;	//Cax2 - get the average of all the ratings
d5064 1
a5064 1
	float availability = 0;
d5085 1
a5085 1
	             (int)GetPercentCompleted(), compl, GetTransferringSrcCount(),
d5115 1
a5115 1
	float availability = 0;
d5141 1
a5141 1
	             (int)GetPercentCompleted(), compl, sTransfSrcCount,
d5180 1
a5180 1
	float unit = (float)size / (float)m_nFileSize;
d5185 1
a5185 1
		CharFillRange(&my_ChunkBar, 0, (float)m_nFileSize * unit, crProgress);
d5214 1
a5214 1
					CharFillRange(&my_ChunkBar, (float)gapstart * unit, (float)gapend * unit + 1, color);
d5231 1
a5231 1
		CharFillRange(&my_ChunkBar, (float)(block->StartOffset + block->transferred) * unit, (float)block->EndOffset * unit, crPending);
d5241 1
a5241 1
void CPartFile::CharFillRange(CString* buffer, float start, float end, char color)
d5320 1
a5320 1
			freq = ceilf((float)freq / 3);
@


1.284
log
@Formatting, comments, and name changes.
@
text
@d2010 1
a2010 1
				if (pSource->m_otherNoNeededList.Find(this) == 0)
d2088 1
a2088 2
	if ( GetStatus() == PS_PAUSED
	     || GetStatus() == PS_STOPPED
d2093 1
a2093 1
	uint8 count;
d2096 2
a2097 1
	sources.Read(&count, 1);
d2099 2
a2100 1
	int source_count_plus_new = GetSourceCount() + count;
d2104 1
d2107 2
a2108 1
	for (int i = 0;i != count;i++)
d2118 2
a2119 1
			if ((g_eMuleApp.m_pServerConnect->GetClientID() == dwUserID) && inet_addr(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetFullIP()) == serverip)
d4760 2
a4761 1
		if ((g_eMuleApp.m_pServerConnect->GetClientID() == source->sourceID) && g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetIP() == source->serverIP)
a4774 1
//	eklmn: optimization: create source only if we need to do it
@


1.283
log
@Fixed file names (.part.met.bak and .part.dir)
@
text
@d615 1
a615 1
		CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_NORMAL + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
d839 1
a839 1
	g_eMuleApp.m_pSharedFilesList->SafeAddKFile(this);
d2582 1
a2582 1
		CAddFileThread	*addFileThread = NULL;
d2584 1
a2584 1
		addFileThread = (CAddFileThread*)AfxBeginThread( RUNTIME_CLASS(CAddFileThread),
d2857 1
a2857 1
	g_eMuleApp.m_pKnownFilesList->SafeAddKFile(this);
d2913 1
a2913 1
//TODO transfer sources to other downloading files if possible
d4021 1
a4021 1
//TODO: implement, but never return less than MINCOMMONPENALTY!
d4485 1
a4485 1
						g_eMuleApp.m_pSharedFilesList->SafeAddKFile(this);
@


1.282
log
@Fix for SLS change
@
text
@d479 1
a479 1
				CString dfpath = CString(fullname) + CString(".dir");
d652 1
a652 1
		CString strBakFile = CString(RemoveFileExtension(fullname)) + CString(".bak");
d751 1
a751 1
			CString dfpath = CString(fullname) + CString(_T(".dir"));
d2822 1
a2822 1
	CString dirFile = CString(fullname) + CString(".dir");
d2826 1
a2826 1
//	Tarod - erase .backup file
d2969 1
a2969 1
	CString dirFile = CString(fullname) + CString(".dir");
d2973 1
a2973 1
//	Tarod - erase .backup file
@


1.281
log
@Removed NNS feature and changed SLS
@
text
@a491 2

		m_sourcesaver.LoadSources(this); // DonGato - Load SLS sources on loading
@


1.280
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d492 2
a2099 2
//	if (g_eMuleApp.m_pGlobPrefs->IsRemoveNNSEnabled())
	{
d2101 4
a2104 5
		int source_count_plus_new = GetSourceCount() + count;
		if ( source_count_plus_new > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
		     && ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME) )
			RemoveNoNeededSources(source_count_plus_new - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
	}
a3946 12
	/*	if (g_eMuleApp.m_pGlobPrefs->IsRemoveNNSEnabled())  //Vorlost added prefs question
		{
		    // Added by Tarod - calculate if we need more space than what is disponible
		    // if so remove No Needed Sources
		    int source_count_plus_new = GetSourceCount() + nCount;
		    if (source_count_plus_new > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
			    && ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME)) {
	    
			    RemoveNoNeededSources(source_count_plus_new - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
		    }
		}
	*/ 
@


1.279
log
@new way of adding sources
@
text
@d1552 1
a1552 1
uint32 CPartFile::Process(uint32 reducedownload /*in percent*/, uint32 iteration)
d1556 10
a1565 9
	uint16	nOldTransSourceCount = GetTransferringSrcCount();  // DonGato: for category filters
	uint16	iOldSrcOnQueueCount = GetOnQueueSrcCount();
	DWORD	dwCurTick = ::GetTickCount();
	CUpDownClient *cur_src;
	bool	sockets_usage_high;
	bool	bIsClientConnected;
	bool	bReaskDownload;
	POSITION	pos1, pos2;
	uint32	cur_dataRate;
d1572 1
a1572 2

	if (reducedownload > 0)
d1574 1
a1574 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, _T("Process: Throttling download to %ld%%"), reducedownload);
d1581 1
a1581 1
	     || (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)) ) //netwolf: increased FileBufferSize
d1589 1
a1589 1
	sockets_usage_high = g_eMuleApp.m_pListenSocket->GetNumOpenSockets() > (g_eMuleApp.m_pGlobPrefs->GetMaxConnections() * 0.75);
d1595 2
a1596 2
//	9 iteration for download & 1 iteration for other files
	if (iteration < 10 && !m_downloadingSourceList.IsEmpty())
d1600 2
a1601 2
			cur_src = m_downloadingSourceList.GetNext(pos1);
			if (cur_src)
d1604 3
a1606 3
				cur_dataRate = cur_src->CalculateDownloadRate();
				m_dataRate += cur_dataRate;
				if (reducedownload)
d1608 2
a1609 2
					uint32 limit = reducedownload * cur_dataRate / 1000;
					if (limit < 1000 && reducedownload == 200)
d1615 2
a1616 3
					cur_src->m_pRequestSocket->SetDownloadLimit(limit);
#endif //OLD_SOCKETS_ENABLED

d1618 1
a1618 1
				else if (m_nSavedReduceDownload != reducedownload)
d1620 4
d1625 1
a1625 4
					cur_src->m_pRequestSocket->DisableDownloadLimit();
#endif //OLD_SOCKETS_ENABLED

				m_nSavedReduceDownload = reducedownload;
d1631 17
a1647 18
	//	eklmn (khaos): initialize temp variables only if we need it
		bool	alreadyCounted = false;
		uint16	i_TcntNNP = 0;
		uint16	i_TcntOnQueue = 0;
		uint16	i_TcntHighQR = 0;
		uint16	i_TcntConnecting = 0;
		uint16	i_TcntTooManyConns = 0;
		uint16	i_TcntConnected = 0;
		uint16	i_TcntTimeout = 0;
		uint16	i_TcntConnViaSrv = 0;
		uint16	i_TcntUnknown = 0;
		uint16	i_TcntRecHash = 0;
		uint16	i_TcntLowToLow = 0;
		uint16	i_TcntQueueFull = 0;
		uint16	i_TcntNoUpload = 0;
		uint16	i_TcntBanned = 0;
		uint16	i_TcntErr = 0;
	//	<-----khaos-
d1649 1
a1649 1
		for (uint32 sl = 0; sl < SOURCESSLOTS; sl++)
d1651 1
a1651 1
			if (!m_srcLists[sl].IsEmpty())
d1653 1
a1653 1
				for (pos1 = m_srcLists[sl].GetHeadPosition();(pos2 = pos1) != NULL;)
d1655 2
a1656 2
					m_srcLists[sl].GetNext(pos1);
					cur_src = m_srcLists[sl].GetAt(pos2);
d1659 1
a1659 1
					if (!cur_src)
d1662 1
a1662 1
					alreadyCounted = false;
d1667 1
a1667 1
					switch (cur_src->GetDownloadState())
d1674 3
a1676 3
							cur_dataRate = cur_src->CalculateDownloadRate();
							m_dataRate += cur_dataRate;
							if (reducedownload && cur_src->GetDownloadState() == DS_DOWNLOADING)
d1678 2
a1679 2
								uint32 limit = reducedownload * cur_dataRate / 1000;
								if (limit < 1000 && reducedownload == 200)
d1685 1
a1685 1
								cur_src->m_pRequestSocket->SetDownloadLimit(limit);
d1690 2
a1691 2
							else if (m_nSavedReduceDownload != reducedownload)
								cur_src->m_pRequestSocket->DisableDownloadLimit();
d1694 1
a1694 1
							m_nSavedReduceDownload = reducedownload;
d1698 1
a1698 1
						if (!alreadyCounted)
d1700 2
a1701 2
							i_TcntBanned++;
							alreadyCounted = true;
d1706 1
a1706 1
						if (!alreadyCounted)
d1708 2
a1709 2
							i_TcntErr++;
							alreadyCounted = true;
d1717 1
a1717 1
						if (cur_src->m_pRequestSocket)
d1719 1
a1719 1
							if (!cur_src->m_pRequestSocket->IsConnected())
d1721 2
a1722 2
								cur_src->SetDownloadState(DS_NONE);
								if (!alreadyCounted)
d1724 2
a1725 2
									i_TcntUnknown++;
									alreadyCounted = true;
d1732 2
a1733 2
							cur_src->SetDownloadState(DS_NONE);
							if (!alreadyCounted)
d1735 2
a1736 2
								i_TcntUnknown++;
								alreadyCounted = true;
d1742 1
a1742 1
						if (dwCurTick - cur_src->GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000)
d1744 1
a1744 1
							if (!alreadyCounted)
d1746 2
a1747 2
								i_TcntTimeout++;
								alreadyCounted = true;
d1749 1
a1749 1
							g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
d1752 1
a1752 1
						if (!alreadyCounted)
d1754 2
a1755 2
							i_TcntConnected++;
							alreadyCounted = true;
d1761 1
a1761 1
						if (!alreadyCounted)
d1763 2
a1764 2
							i_TcntLowToLow++;
							alreadyCounted = true;
d1769 1
a1769 1
							g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
d1780 1
a1780 1
							if (!alreadyCounted)
d1782 2
a1783 2
								i_TcntNNP++;
								alreadyCounted = true;
d1787 1
a1787 1
								if (!cur_src->SwapToAnotherFile(NULL, true)) //eklmn: bugfix(08): A4AF switching
d1789 1
a1789 1
									g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
d1796 1
a1796 1
							if (sockets_usage_high)
d1801 1
a1801 1
							if (!((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime * 2))
d1806 1
a1806 1
							if (cur_src->IsRemoteQueueFull())
d1808 1
a1808 1
								if (!alreadyCounted)
d1810 2
a1811 2
									i_TcntQueueFull++;
									alreadyCounted = true;
d1816 1
a1816 1
									g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
d1823 1
a1823 1
							          && (cur_src->GetRemoteQueueRank() > g_eMuleApp.m_pGlobPrefs->GetRemoteQueueLimit()) )
d1825 1
a1825 1
								if (!alreadyCounted)
d1827 2
a1828 2
									i_TcntHighQR++;
									alreadyCounted = true;
d1830 1
a1830 1
								g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
d1833 1
a1833 1
							else if (!alreadyCounted)
d1835 2
a1836 2
								i_TcntOnQueue++;
								alreadyCounted = true;
d1839 1
a1839 1
							if (cur_src->GetRemoteQueueRank() && sockets_usage_high)  //Vorlost QueueRank > 250 --> Filereasktime=45minutes
d1841 2
a1842 2
								if (cur_src->GetRemoteQueueRank() > 250)
									usethisfilereasktime = FILEREASKTIME * 2.5 ; //Vorlost
d1844 1
a1844 1
									usethisfilereasktime = FILEREASKTIME * 2; //Vorlost (QR 1-250 = 36minutes)
d1848 1
a1848 1
							if (cur_src->IsOnLAN())
d1850 2
a1851 2
								if ( (!cur_src->GetLastAskedTime())
								     || (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMEUDP )
d1853 1
a1853 1
									cur_src->UDPReaskForDownload();
d1860 2
a1861 2
								     && ( (!cur_src->GetLastAskedTime())
								          || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime - 20000 ) )
d1863 1
a1863 1
									cur_src->UDPReaskForDownload();
d1873 4
a1876 4
							     && (cur_src->GetLastAskedTime())
							     && ((dwCurTick - cur_src->GetLastAskedTime()) > (FILEREASKTIME - L2HAC_PREPARE_PRECEDE))
							     && cur_src->HasLowID()
							     && cur_src->GetL2HACTime()
d1879 1
a1879 1
								cur_src->SetDownloadState(DS_WAITCALLBACK);
d1885 2
a1886 1
						if (!alreadyCounted)
d1888 2
a1889 2
							i_TcntConnecting++;
							alreadyCounted = true;
d1891 1
d1893 2
a1894 1
						if (!alreadyCounted)
d1896 2
a1897 2
							i_TcntTooManyConns++;
							alreadyCounted = true;
d1899 1
d1901 2
a1902 1
						if (!alreadyCounted)
d1904 2
a1905 2
							i_TcntNoUpload++;
							alreadyCounted = true;
d1907 1
d1909 2
a1910 1
						if (!alreadyCounted)
d1912 2
a1913 2
							i_TcntConnViaSrv++;
							alreadyCounted = true;
d1916 1
d1920 2
a1921 1
						i_TcntRecHash++;
d1923 1
d1926 3
a1928 1
						i_TcntUnknown++;
d1935 1
a1935 1
						if (cur_src->IsOnLAN())
d1938 2
a1939 2
						if (!cur_src->GetLastAskedTime() || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime)
							bIsClientConnected = cur_src->AskForDownload();
d1942 1
a1942 1
					cur_src = NULL;	// reset a variable
d1952 15
a1966 15
		m_iSrcNNP = i_TcntNNP;
		m_iSrcOnQueue = i_TcntOnQueue;
		m_iSrcHighQR = i_TcntHighQR;
		m_iSrcConnecting = i_TcntConnecting;
		m_iSrcTooManyConns = i_TcntTooManyConns;
		m_iSrcConnected = i_TcntConnected;
		m_iSrcTimeout = i_TcntTimeout;
		m_iSrcConnViaServer = i_TcntConnViaSrv;
		m_iSrcUnknown = i_TcntUnknown;
		m_iSrcRecHash = i_TcntRecHash;
		m_iSrcLowToLow = i_TcntLowToLow;
		m_iSrcQueueFull = i_TcntQueueFull;
		m_iSrcNoUpload = i_TcntNoUpload;
		m_iSrcBanned = i_TcntBanned;
		m_iSrcError = i_TcntErr;
d1978 1
d1980 1
d1984 1
a1984 1
						cur_src = m_srcLists[sl].GetAt(pos2);
d1986 1
a1986 1
						if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS)
d1991 1
a1991 1
								cur_src->SwapToAnotherFile(NULL, true);	//eklmn: bugfix(08): A4AF switching
d1994 1
a1994 1
								cur_src->SwapToAnotherFile(g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile());
d1997 2
d2009 3
a2011 3
				cur_src = m_A4AFsrcList.GetAt(pos2);
				if (cur_src->m_otherNoNeededList.Find(this) == 0)
					cur_src->SwapToAnotherFile(this);
d2024 1
a2024 1
		//local server
d2026 3
a2028 1
			Packet* packet = new Packet(OP_GETSOURCES, 16);
d2032 1
a2032 1
		//AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
d2036 1
a2036 2
	//	eklmn: call SaveSources only one time (in case if there isn't DL)
	//	START enkeyDEV(kei-kun) -SLS preferences-
d2038 1
a2038 1
		if (iteration && g_eMuleApp.m_pGlobPrefs->SLSEnable() && m_downloadingSourceList.IsEmpty() && g_eMuleApp.m_pServerConnect->IsConnected())
a2042 1
	//	END enkeyDEV(kei-kun) -SLS preferences-
d2044 1
a2044 1
	//	calculate m_dataRate, set limit etc. (every 5sec)
d2220 1
a2220 1
		return 0xffff;
d2230 1
a2230 1
	uint16 goodpart = sender->GetLastDownPart();
d2234 1
a2234 1
	if ((goodpart != 0xffff) && GetNextEmptyBlockInPart(goodpart, 0))
d2237 1
a2237 1
		return sender->GetLastDownPart();
d2241 1
a2241 1
		sender->SetLastDownPart(0xffff);
d2276 1
a2276 1
		if (cur_src && cur_src->GetLastDownPart() < partCount)
d2278 1
a2278 1
			m_BlockedParts[cur_src->GetLastDownPart()] = cur_src;
d2466 1
a2466 1
	sender->SetLastDownPart(goodpart);
d2471 1
a2471 1
	return 0xffff;
@


1.278
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d2091 2
d2095 2
a2096 4
		uint32 userid;
		sources.Read(&userid, 4);
		uint16 port;
		sources.Read(&port, 2);
a2100 1

d2103 1
a2103 1
			if ((g_eMuleApp.m_pServerConnect->GetClientID() == userid) && inet_addr(g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetFullIP()) == serverip)
d2106 1
a2106 1
		else if (g_eMuleApp.m_pServerConnect->GetClientID() == userid)
d2108 1
a2108 1
		else if (userid < 0x1000000 && !g_eMuleApp.m_pServerConnect->IsLocalServer(serverip, serverport))
d2119 3
a2121 2
			CUpDownClient* newsource = new CUpDownClient(port, userid, serverip, serverport, this);
			g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this, newsource);
d4774 2
a4775 2
		CUpDownClient * newsource = new CUpDownClient(source->sourcePort, source->sourceID, source->serverIP, source->serverPort, this);
		if (exchanged)
d4778 1
a4778 1
			newsource->SetUserName(GetResString(IDS_EXCHANGEDSOURCE));
d4781 1
a4781 1
				newsource->SetUserHash(source->achUserHash);
a4782 1
		g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this, newsource);
@


1.277
log
@no message
@
text
@d235 1
a235 1
	m_lastRefreshedDLDisplay = ::GetTickCount();
d1849 1
a1849 1
							if (cur_src->isOnLAN())
d1924 1
a1924 1
						if (cur_src->isOnLAN())
d1995 1
a1995 1
				if (cur_src->m_OtherNoNeeded_list.Find(this) == 0)
d2102 1
a2102 1
		if (g_eMuleApp.m_pServerConnect->GetClientID() < 16777216 && g_eMuleApp.m_pServerConnect->IsConnected())
d2109 1
a2109 1
		else if (userid < 16777216 && !g_eMuleApp.m_pServerConnect->IsLocalServer(serverip, serverport))
d3809 1
a3809 1
	if (forClient->reqfile != this)
d3842 1
a3842 1
				if (cur_src->isOnLAN())
d3858 1
a3858 1
				if (forClient->reqfile == this && forClient->GetPartStatus() && cur_src->GetPartStatus())
d4754 1
a4754 1
	if (g_eMuleApp.m_pServerConnect->GetClientID() < 16777216 && g_eMuleApp.m_pServerConnect->IsConnected())
d4766 1
a4766 1
	else if (source->sourceID < 16777216 && !g_eMuleApp.m_pServerConnect->IsLocalServer(source->serverIP, source->serverPort))
d4891 1
a4891 1
	if (dwID >= 16777216)
d5332 1
a5332 1
	if ((!pClient) || (pClient->reqfile != this))
@


1.276
log
@More fixes for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@d1615 1
a1615 1
					cur_src->socket->SetDownloadLimit(limit);
d1622 1
a1622 1
					cur_src->socket->DisableDownloadLimit();
d1686 1
a1686 1
								cur_src->socket->SetDownloadLimit(limit);
d1692 1
a1692 1
								cur_src->socket->DisableDownloadLimit();
d1715 1
a1715 1
					//	if socket doesn't exist or isn't connected
d1718 1
a1718 1
						if (cur_src->socket)
d1720 1
a1720 1
							if (!cur_src->socket->IsConnected())
d1871 1
a1871 1
						//	(emulates a "Connecting via server..." without socket timeout)
d3349 1
a3349 1
		cur_src->socket->SendPacket(packet, false, true);
d3417 1
a3417 1
		cur_src->socket->SendPacket(packet, false, true);
a4740 12
#ifndef ASYNC_UI_UPDATES
	DWORD curTick = ::GetTickCount();

	if (force || curTick - m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE + (uint32)(rand() * 1000 / RAND_MAX))
	{
		if (g_eMuleApp.m_pdlgEmule != NULL)
		{
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateFileItem(this);
			m_lastRefreshedDLDisplay = curTick;
		}
	}
#else
a4741 1
#endif ASYNC_UI_UPDATES
@


1.275
log
@Fix for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@d4748 1
a4748 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateItem(this);
d5386 1
a5386 1
#ifdef VS2002 // In VS2002 the const cast operator causes an ambiguity
@


1.274
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d5386 1
d5388 3
@


1.273
log
@Formatting, comments, and name changes.
@
text
@d32 1
a32 1
static char THIS_FILE[]=__FILE__;
d37 2
a38 2
// Barry - use this constant for both places
#define PROGRESS_HEIGHT 4	//netwolf 06.05.03 (was 3)
d56 7
a62 4
	md4cpy(m_fileHash,searchresult->GetFileHash());
	for (int i = 0; i != searchresult->m_tagArray.GetCount();i++){
		switch (searchresult->m_tagArray[i]->GetSpecialTag()){
			case FT_FILENAME:{
d66 2
a67 1
			case FT_FILESIZE:{
d72 2
a73 2
				CFileTag* newtag = new CFileTag(*searchresult->m_tagArray[i]);
				m_tagArray.Add(newtag);
d76 1
a76 1
	// Don't ask for a hashset, if there is none.
d91 2
a92 1
	try {
d94 1
a94 1
		_ASSERT( pLink != 0 );
d96 1
a96 1
		if (pFileLink==0) 
d99 3
a101 1
	} catch (CString error) {
d104 1
a104 1
		buffer.Format(GetResString(IDS_ERR_INVALIDLINK),error.GetBuffer());
d119 3
a121 2
	try{
		m_strFileName = CString( fileLink->GetName() );
d123 4
a126 3
		// Ultras: prevent to donload an empty file
		if( !m_lFileSize ) {
			AddLogLine( true, IDS_SKIPZEROLENGTHFILE, m_strFileName );
d128 1
a128 1
			return;
d130 1
a130 1
		// Don't ask for a hashset, if there is none.
d133 1
a133 1
		memcpy2(m_fileHash,fileLink->GetHashKey(),sizeof(m_fileHash));
d138 3
a140 2
		}
	catch(CString error){
d143 1
a143 1
		buffer.Format(GetResString(IDS_ERR_INVALIDLINK),error.GetBuffer());
d161 1
a161 1
	m_strTempDir =	"";	
d171 3
a173 3
	//eklmn(khaos): reset a statistical variables
	m_iSrcNNP =	0;
	m_iSrcOnQueue =	0;
d180 1
a180 1
	m_iSrcUnknown =	0;
d182 1
a182 1
	m_iSrcLowToLow =	 0;
d193 1
a193 1
	completedsize=0;
d195 3
a197 3
	m_bPreviewing=false;
	lastseencomplete=NULL;
	availablePartsCount=0;
d201 1
a201 1
	m_strComment="";
d210 2
a211 2
	hasRating=false;
	hasComment=false;
d214 1
a214 1
	// Tarod
d221 2
a222 2
	m_nLastCompleteSrcCount= 0;			// netwolf: complete sources (zegzav) 13.05.03
	m_bUpdateCompleteSrcCount= false;
d224 1
a224 1
	//bond006 (smoothed "remaining time" calculation) //SyruS
d230 1
a230 1
	m_iCategoryID = 0; /*no category*/
d234 1
a234 1
	//eklmn: it's need to initialize this variable to prevent extra screen refreshing
d244 2
a245 2
	// Barry - Ensure all buffered data is written
	if(!m_bIsBeingDeleted)
d247 1
a247 1
	//taab BEGIN fix - minimize rehashing of files //netwolf 03.05.03 (dont know if we really need it)
d251 1
a251 1
		// Update met file
d254 1
a254 1
	//taab END fix	
d272 14
a285 13
  	int i = 0; 
	CString strFileName; 
	do 
	{ 
		i++; 
		strFileName.Format(_T("%s\\%03i.part"), m_strTempDir, i); 
	
	}while(PathFileExists(strFileName)); 
	
	m_strPartMetFileName.Format(_T("%03i.part.met"),i); 	
	fullname.Format(_T("%s\\%s"),m_strTempDir,m_strPartMetFileName);
	CString buffer = m_strPartMetFileName.Left(m_strPartMetFileName.GetLength() - 4);	
	CFileTag* partnametag = new CFileTag(FT_PARTFILENAME,buffer);	
d287 1
a287 1
	
d290 1
a290 1
	gap->end = m_lFileSize-1;
d294 2
a295 1
	if (!m_hPartFile.Open(partfull,CFile::modeCreate|CFile::modeReadWrite|CFile::shareDenyWrite|CFile::osSequentialScan)){
d303 3
a305 2
	m_ReqParts.SetSize(partCount);	//eklmn: ICR 2.10 
	for (uint32 i = 0; i != partCount;i++) {
d312 3
a314 2
	// Before we save file we need to stablish UAP by Tarod
	if (g_eMuleApp.m_pGlobPrefs->IsUAPEnabled()) {
d319 4
a322 4
	// End Tarod
	
	// SLUGFILLER: hashlistRecheck
	if(m_lFileSize <= PARTSIZE )
d324 1
a324 1
	// SLUGFILLER: hashlistRecheck
d326 1
a326 1
	//SyruS: cleanup
d335 1
a335 1
bool CPartFile::LoadPartFile(LPCTSTR in_directory,LPCTSTR in_filename)
d340 1
a340 1
    CMap<uint16,uint16,Gap_Struct*,Gap_Struct*> gap_map; // safe Load Gaps [SlugFiller]
d346 2
a347 2
	
	fullname.Format(_T("%s\\%s"),directory,m_strPartMetFileName);
d349 6
a354 4
	try{
		// readfile data form part.met file
		if (!file.Open(fullname,CFile::modeRead)){
			AddLogLine(false, IDS_ERR_OPENMET, m_strPartMetFileName,m_strFileName);
d358 6
a363 4
		file.Read(&version,1);
		if (version != PARTFILE_VERSION){
			if (file.m_hFile != INVALID_HANDLE_VALUE) file.Close();	//eklmn: bugfix(21): *.part.met was't closed after loading (aka "corrupted file problem")
			AddLogLine(false, IDS_ERR_BADMETVERSION,m_strPartMetFileName,m_strFileName);
d367 4
a370 3
        if(!LoadHashsetFromFile(file,false)) {
            AddLogLine(true,IDS_ERR_HASHSETCORR,in_filename);
        }
d374 3
a376 2
		file.Read(&tagcount,4);
		for (uint32 j = 0; j != tagcount;j++){
d378 7
a384 4
			switch(newtag->GetSpecialTag()){
				case FT_FILENAME:{
					if(newtag->GetStringValue().IsEmpty()) {
						AddLogLine(true, IDS_ERR_METCORRUPT, m_strPartMetFileName,m_strFileName);
d392 2
a393 1
				case FT_LASTSEENCOMPLETE: {
d398 2
a399 1
				case FT_FILESIZE:{
d404 2
a405 1
				case FT_TRANSFERRED:{
d410 2
a411 1
				case FT_PRIORITY:{
d415 1
a415 1
					// Added by Tarod for auto-priority
d422 2
a423 1
				case FT_STATUS:{
d429 4
a432 2
				case FT_ULPRIORITY: {
					if ((uint8)newtag->GetIntValue() == PR_AUTO) {
d435 3
a437 1
					} else {
d446 1
a446 1
					m_iCategoryID = newtag->GetIntValue();
d450 7
a456 5
				default:{
					// Start Changes by Slugfiller for better exception handling
					if ((!newtag->GetSpecialTag()) && (newtag->GetTagName()[0] == FT_GAPSTART ||
					     newtag->GetTagName()[0] == FT_GAPEND)){
						Gap_Struct* gap;
d458 1
a458 1
						s = s.Right(s.GetLength()-1);
d470 1
a470 1
							gap->end = newtag->GetIntValue()-1;
d472 1
a472 1
					// End Changes by Slugfiller for better exception handling
d477 2
a478 2
					
				// START - enkeyDEV(Ottavio84) -ChangeDir-
d481 2
a482 1
				if (f.Open(dfpath, CFile::modeRead | CFile::typeText)) {
d484 1
a484 1
					f.Close();			
d486 1
a486 1
				// END - enkeyDEV(Ottavio84) -ChangeDir-					
d490 2
a491 1
		if (file.m_hFile != INVALID_HANDLE_VALUE) file.Close();	//eklmn: bugfix(21): *.part.met was't closed after loading (aka "corrupted file problem")
d493 2
a494 1
	catch(CFileException* error){
d497 4
a500 3
			AddLogLine(true, IDS_ERR_METCORRUPT, m_strPartMetFileName,m_strFileName);
		else{			
			AddLogLine(true, IDS_ERR_FILEERROR,m_strPartMetFileName,m_strFileName,error);
d502 3
a504 2
		error->Delete();		
		for (POSITION pos = gap_map.GetStartPosition(); pos != NULL; ) {
d507 1
a507 1
 			gap_map.GetNextAssoc(pos, gapkey, gap);
d513 3
a515 2
	// Now to flush the map into the list (Slugfiller)
	for (POSITION pos = gap_map.GetStartPosition(); pos != NULL; ){
d518 2
a519 2
 		gap_map.GetNextAssoc(pos, gapkey, gap);
		//SyruS (0.29a) SLUGFILLER: SafeHash - revised code, and extra safety
d521 2
a522 2
        		gaplist.AddTail(gap); // All tags accounted for
    		else
d524 2
a525 1
		if (gap->start != -1 && gap->end != -1 && gap->start <= gap->end && gap->start < m_lFileSize){
d527 1
a527 1
				gap->end = m_lFileSize-1; // Clipping
d531 2
a532 2
		// SLUGFILLER: SafeHash
  }
d535 2
a536 2
	//--- xrmb:keepPartFileStats ---
	//--- i hope that is a safe point to load the stats ---
d538 1
a538 1
	//--- :xrmb ---
d541 4
a544 3
	//check if this is a backup
	if(fullname.Right(7).CompareNoCase(_T(".backup")) == 0) {
		fullname.Truncate(fullname.GetLength()-7);
d547 5
a551 4
	// open permanent handle
	CString searchpath = fullname.Left(fullname.GetLength() - 4);	
	if (!m_hPartFile.Open(searchpath,CFile::modeReadWrite|CFile::shareDenyWrite|CFile::osSequentialScan)){
		AddLogLine(false,IDS_ERR_FILEOPEN,fullname,m_strFileName);		
d553 1
a553 1
	}			
d555 1
a555 1
	//SyruS (0.29a) SLUGFILLER: SafeHash - final safety, make sure any missing part of the file is gap
d557 4
a560 3
		AddGap(m_hPartFile.GetLength(), m_lFileSize-1);
	// Goes both ways - Partfile should never be too large
	if (m_hPartFile.GetLength() > m_lFileSize){
d564 1
a564 1
	// SLUGFILLER: SafeHash
d570 2
a571 1
	for (uint32 i = 0; i != partCount; i++) {
d577 2
a578 2
	// check hashcount, filesatus etc
	CSingleLock Lock(&m_mutexHashList,TRUE);
d581 2
a582 1
	if ( iSize < GetPartCount() && GetFileSize() >= PARTSIZE){
d587 2
a588 1
	else {
d591 3
a593 2
		for (int i = 0; i != iSize; i++){
			if (IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1))
d600 2
a601 1
	if (gaplist.IsEmpty()){	// is this file complete already?
d606 1
a606 1
	// check date of .part file - if its wrong, rehash file
d609 10
a618 9
        m_timeLastDownTransfer = filestatus.m_mtime;
		if (m_timetLastWriteDate != mktime(filestatus.m_mtime.GetLocalTm())){
			AddLogLine(false,IDS_ERR_REHASH,m_strFileName);
			// rehash
			SetStatus(PS_WAITINGFORHASH);
		    CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
		    addfilethread->SetValues(0,directory,m_hPartFile.GetFileName().GetBuffer(),this);
		    addfilethread->ResumeThread();
		}
d621 1
a621 1
	if ( completedsize > transferred )
d623 1
a623 1
	else if ( completedsize != transferred )
d625 1
a625 1
	//bond006 (smoothed "remaining time" calculation) //SyruS
d627 2
a628 1
	if (m_bPaused) SetStartTimeReset(true);
d641 2
a642 1
	switch (m_eStatus){
d646 1
a646 1
			return false;
d649 3
a651 2
	try{
		//backup part.met file
d654 2
a655 2
		
		//get filedate
d657 2
a658 2
		CString searchpath = fullname.Left(fullname.GetLength() - 4);		
		bool end = !ff.FindFile(searchpath,0);		
d660 1
a660 1
				ff.FindNextFile();
d675 2
a676 2
		// readfile data form part.met file
		file = _tfopen(fullname,_T("wbS"));
d679 1
a679 1
		//version
d681 6
a686 6
		fwrite(&version,1,1,file);
		//date
		fwrite(&m_timetLastWriteDate,4,1,file);
		//hash
		fwrite(&m_fileHash,16,1,file);
		CSingleLock Lock(&m_mutexHashList,TRUE);
d688 1
a688 1
		fwrite(&parts,2,1,file);
d690 1
a690 1
			fwrite(m_partHashArray[x],16,1,file);
d692 12
a703 12
		//tags
		uint32 tagcount = m_tagArray.GetCount()+8+(gaplist.GetCount()*2);
		fwrite(&tagcount,4,1,file);
		CFileTag nametag(FT_FILENAME,m_strFileName);
		nametag.WriteToFile(file);		
		CFileTag sizetag(FT_FILESIZE,m_lFileSize);
		sizetag.WriteToFile(file);		
		CFileTag transtag(FT_TRANSFERRED,transferred);
		transtag.WriteToFile(file);		
		CFileTag statustag(FT_STATUS,(m_bPaused)? 1:0);
		statustag.WriteToFile(file);		
		// Modified by Tarod for DAP		
d707 1
a707 1
		else 
d709 5
a713 5
		CFileTag prioritytag(FT_PRIORITY,priority_value);
		prioritytag.WriteToFile(file);		
		// End by Tarod
		CFileTag lsctag(FT_LASTSEENCOMPLETE,lsc);
		lsctag.WriteToFile(file);		
d715 1
a715 1
		// Modified by Tarod for UAP		
d720 2
a721 2
			ulpriority_value = m_iPriority;		
		CFileTag ulprioritytag(FT_ULPRIORITY,ulpriority_value);
d724 1
a724 1
		CFileTag categorytag(FT_CATEGORY, m_iCategoryID);
d726 2
a727 2
	
		// End by Tarod
d730 1
a730 1
		//gaps
d734 3
a736 2
		for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos)){
			_itot(i_pos,number,10);
d738 1
a738 1
			CFileTag gapstarttag(namebuffer,gaplist.GetAt(pos)->start);
d740 2
a741 2
			// gap start = first missing byte but gap ends = first non-missing byte in edonkey
			// but I think its easier to user the real limits
d743 2
a744 2
			CFileTag gapendtag(namebuffer,(gaplist.GetAt(pos)->end)+1);
			gapendtag.WriteToFile(file);			
d748 3
a750 2
		// START - enkeyDEV(Ottavio84) -ChangeDir-
		if (!m_strAlternativePath.IsEmpty()) {
d753 2
a754 1
			if (f.Open(dfpath, CFile::modeCreate | CFile::modeWrite | CFile::typeText)) {
d756 1
a756 1
				f.Close();			
d759 1
a759 1
		// END - enkeyDEV(Ottavio84) -ChangeDir-
d766 3
a768 2
	}	
	catch(char* error){
d772 1
a772 1
		AddLogLine(false,IDS_ERR_SAVEMET,error,m_strPartMetFileName,m_strFileName);
d776 2
a777 1
	catch(CString error){
d781 1
a781 1
		AddLogLine(false,IDS_ERR_SAVEMET,error.GetBuffer(),m_strPartMetFileName,m_strFileName);
d784 1
a784 1
	// v1:- eklmn: bugfix(27): by shutdown force OS flush data direct to disk [SlugFiller]
d786 1
a786 1
		_commit(_fileno(file));
d801 2
a802 2
	bool			bErrorFound = false;
	CSingleLock Lock(&m_mutexHashList,TRUE);
d807 1
a807 1
		if (IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1))
d809 1
a809 1
			if (!(result->GetPartHash(i) && !md4cmp(result->GetPartHash(i),GetPartHash(i))))
d811 2
a812 2
				AddLogLine(false,IDS_ERR_FOUNDCORRUPTION,i+1,m_strFileName);		
				AddGap(i*PARTSIZE,((((i+1)*PARTSIZE)-1) >= m_lFileSize) ? m_lFileSize-1 : ((i+1)*PARTSIZE)-1);
d824 1
a824 1
			return;
d827 1
a827 1
			AddLogLine(false,IDS_HASHINGDONE,m_strFileName);
d835 1
a835 1
		return;
d849 2
a850 1
	for (pos1 = gaplist.GetHeadPosition();(pos2 = pos1) != NULL;){
d852 2
a853 1
		if (cur_gap->start >= start && cur_gap->end <= end){ // this gap is inside the new gap - delete
d858 2
a859 1
		else if (cur_gap->start >= start && cur_gap->start <= end){// a part of this gap is in the new gap - extend limit and delete
d865 2
a866 1
		else if (cur_gap->end <= end && cur_gap->end >= start){// a part of this gap is in the new gap - extend limit and delete
d872 3
a874 2
		else if (start >= cur_gap->start && end <= cur_gap->end){// new gap is already inside this gap - return
			return;
d893 1
a893 1
		end = m_lFileSize-1;
d896 1
a896 1
		Gap_Struct* cur_gap = gaplist.GetAt(pos);
d899 3
a901 3
		  || (cur_gap->start >= start && cur_gap->start <= end)	// gap starts inside range
		  || (cur_gap->end <= end && cur_gap->end >= start)		// gap ends inside range
		  || (start >= cur_gap->start && end <= cur_gap->end) )	// range is inside gap
d903 1
a903 1
			return false;	
d918 6
a923 4
		end = m_lFileSize-1;
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos)){
		Gap_Struct* cur_gap = gaplist.GetAt(pos);
		if (start >= cur_gap->start  && end <= cur_gap->end ){
d937 3
a939 2
	for (POSITION pos =  requestedblocks_list.GetHeadPosition();pos != 0; requestedblocks_list.GetNext(pos)){
		Requested_Block_Struct* cur_block =  requestedblocks_list.GetAt(pos);
d954 1
a954 1
	Gap_Struct *firstGap;
d959 1
a959 1
	// Find start of this part
d963 1
a963 1
	// What is the end limit of this block, i.e. can't go outside part (or filesize)
d968 1
a968 1
	// Loop until find a suitable gap and return true, or no more gaps and return false
d973 1
a973 1
		// Find the first gap from the start position
d977 1
a977 1
			// Want gaps that overlap start<->partEnd
d980 1
a980 1
				// Is this the first gap?
d986 1
a986 1
		// If no gaps after start, exit
d990 1
a990 1
		// Update start position if gap starts after current pos
d994 1
a994 1
		// If this is not within part, exit
d998 1
a998 1
		// Find end, keeping within the max block size and the part limit
d1005 2
a1006 2
    
		// If this gap has not already been requested, we have found a valid entry
d1009 1
a1009 1
			// Was this block to be returned
d1021 1
a1021 1
			// Reposition to end of that gap
d1025 1
a1025 1
		// If tried all gaps then break out of the loop
d1032 1
a1032 1
	// No suitable gap found
d1041 1
a1041 1
	// Calculate offsets of the Part
d1043 1
a1043 1
	const uint32 uPartEnd  = ((GetFileSize() - 1) < (uPartStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uPartStart + PARTSIZE - 1);
d1047 1
a1047 1
	// Retrieve Gap(s) matching the part
d1052 1
a1052 1
		// Check if Gap is inside the limit
d1056 1
a1056 1
		// Calculate offsets of the Gap within the part
d1060 1
a1060 1
		// Create n request block(s)
d1063 1
a1063 1
			// Calculate offsets of the block
d1065 1
a1065 1
			const uint32 endOffset = ((uGapStart + EMBLOCKSIZE - 1) > uGapEnd) ? uGapEnd : (uGapStart + EMBLOCKSIZE - 1); 
d1067 1
a1067 1
			// Prepare offset of next block
d1070 2
a1071 2
			// Check if block has already been requested
			if (IsAlreadyRequested(startOffset, endOffset) == false) 
d1073 2
a1074 2
				// Create 1 request block
				Requested_Block_Struct* block = new Requested_Block_Struct;
d1076 2
a1077 2
				block->EndOffset = endOffset;   
				// block->packedsize = 0;
d1081 1
a1081 1
				// Flag the block as 'requested'
d1084 1
a1084 1
				// Return the block to the source
d1092 1
a1092 1
	return;
d1104 2
a1105 1
	for (pos1 = gaplist.GetHeadPosition();(pos2 = pos1) != NULL;){
d1107 2
a1108 1
		if (cur_gap->start >= start && cur_gap->end <= end){ // our part fills this gap completly
d1113 7
a1119 2
		else if (cur_gap->start >= start && cur_gap->start <= end){// a part of this gap is in the part - set limit
			cur_gap->start = end+1;
d1121 2
a1122 4
		else if (cur_gap->end <= end && cur_gap->end >= start){// a part of this gap is in the part - set limit
			cur_gap->end = start-1;
		}
		else if (start >= cur_gap->start && end <= cur_gap->end){
d1124 1
a1124 1
			cur_gap->end = start-1;
d1126 1
a1126 1
			cur_gap->start = end+1;
d1128 1
a1128 1
			gaplist.InsertAfter(pos1,cur_gap);
d1136 2
a1137 2
	// Barry - The met file is now updated in FlushBuffer()
	//SavePartFile();
d1142 1
a1142 1
void CPartFile::UpdateCompletedInfos() 
d1146 1
a1146 1
   	uint32 allgaps = 0; 
d1148 3
a1150 2
	for (POSITION pos = gaplist.GetHeadPosition();pos !=  0;gaplist.GetNext(pos)){ 
		Gap_Struct* cur_gap = gaplist.GetAt(pos); 
d1155 6
a1160 4
	{ 
			percentcompleted = ((1.0f-(float)allgaps/m_lFileSize)) * 100; 
			completedsize = (uint32)((m_lFileSize-(allgaps+1))); 
	} else {
d1162 1
a1162 1
		completedsize=m_lFileSize;
d1172 1
a1172 1
	const COLORREF crProgress=(bFlat)?RGB(0, 150, 0):RGB(0, 192, 0);
d1177 2
a1178 2
	// SLUGFILLER: grayPause - Colors by status
	if(GetStatus() == PS_EMPTY || GetStatus() == PS_READY)
d1180 1
a1180 1
		crHave=(bFlat)?RGB(0, 0, 0):RGB(95, 95, 95);
d1183 4
a1186 2
	} else {
		crHave=(bFlat)?RGB(105, 105, 105):RGB(142, 142, 142);
d1190 1
a1190 1
	// SLUGFILLER
d1193 2
a1194 2
	s_ChunkBar.SetFileSize(m_lFileSize); 
	s_ChunkBar.Fill(crHave); 
d1198 4
a1201 3
	if(m_eStatus == PS_COMPLETE || m_eStatus == PS_COMPLETING) {
		s_ChunkBar.FillRange(0, m_lFileSize, crProgress); 
		s_ChunkBar.Draw(dc, rect->left, rect->top, bFlat); 
d1203 8
a1210 7
		completedsize=m_lFileSize;
		return; 
	} 

	// red gaps 
	for (POSITION pos = gaplist.GetHeadPosition();pos !=  0;gaplist.GetNext(pos)){ 
		Gap_Struct* cur_gap = gaplist.GetAt(pos); 
d1212 15
a1226 12
		bool gapdone = false; 
		uint32 gapstart = cur_gap->start; 
		uint32 gapend = cur_gap->end; 
		for (uint32 i = 0; i != GetPartCount(); i++){ 
			if (gapstart >= i*PARTSIZE && gapstart <=  (i+1)*PARTSIZE){ // is in this part? 
				if (gapend <= (i+1)*PARTSIZE) 
				gapdone = true; 
				else{ 
				gapend = (i+1)*PARTSIZE; // and next  part 
				} 
				// paint 
				COLORREF color; 
d1228 2
a1229 2
				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && m_srcPartFrequencies[i])  // frequency? 
				// SLUGFILLER: grayPause
d1231 8
a1238 8
					if(m_eStatus == PS_EMPTY || m_eStatus == PS_READY)
					    color = RGB(0,
								    (210-(22*(m_srcPartFrequencies[(uint16)i]-1)) <  0)? 0:210-(22*(m_srcPartFrequencies[(uint16)i]-1))
								    ,255);
				    else
						color = RGB(100,
									(210-(22*(m_srcPartFrequencies[(uint16)i]-1)) <  0)? 0:255-(22*(m_srcPartFrequencies[(uint16)i]-1))
									,255);
d1240 3
a1242 3
				// SLUGFILLER: grayPause
				else 
					color = crMissing; 
d1244 1
a1244 1
				s_ChunkBar.FillRange(gapstart, gapend + 1,  color); 
d1246 10
a1255 9
				if (gapdone) // finished? 
				break; 
				else{ 
				gapstart = gapend; 
				gapend = cur_gap->end; 
				} 
			} 
		} 
	} 
d1257 2
a1258 2
	// yellow pending parts 
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos !=  0;requestedblocks_list.GetNext(pos))
d1260 3
a1262 3
		Requested_Block_Struct* block =  requestedblocks_list.GetAt(pos); 
		s_ChunkBar.FillRange((block->StartOffset + block->transferred), block->EndOffset,  crPending);
	} 
d1264 1
a1264 1
	s_ChunkBar.Draw(dc, rect->left, rect->top, bFlat); 
d1266 2
a1267 2
	//--- xrmb:confirmeddownload ---
	if((gaplist.GetCount() || requestedblocks_list.GetCount()))
d1269 9
a1277 9
		// all this here should be done in the Process, not in the drawing!!! its a waste of cpu time, or maybe not :)
		uint16	completedParts=0;
		confirmedsize=0;
		for(uint32 i=0; i!=GetPartCount(); i++)
		{
			uint32	end=(i+1)*PARTSIZE-1;
			bool	lastChunk=false;
			//--- last part? ---
			if(end>m_lFileSize)
d1279 2
a1280 2
				end=m_lFileSize;
				lastChunk=true;
d1283 1
a1283 1
			if(IsComplete(i*PARTSIZE, end))
d1287 2
a1288 2
				if(lastChunk==false)
					confirmedsize+=PARTSIZE;
d1290 1
a1290 1
					confirmedsize+=m_lFileSize % PARTSIZE;
a1292 2
		
		completedsize = (uint32)((m_lFileSize-(allgaps+1)));
d1294 4
a1297 2
		percentcompleted = (float)completedsize/m_lFileSize*100;
		percentconfirmed = (float)confirmedsize/m_lFileSize*100;
d1299 1
a1299 1
	else 
d1303 1
a1303 1
		completedsize=m_lFileSize;
d1306 3
a1308 3
	// green progress 
	RECT gaprect; 
	gaprect.top = rect->top; 
d1310 1
a1310 1
	gaprect.left = rect->left; 
d1312 3
a1314 3
	uint32	w=rect->right-rect->left+1;
	uint32	wc=(uint32)(percentconfirmed/100*w+0.5f);
	uint32	wp=(uint32)(percentcompleted/100*w+0.5f);
d1316 1
a1316 1
	if(!bFlat) 
d1323 3
a1325 3
		s_LoadBar.Draw(dc, gaprect.left, gaprect.top, false); 
	} 
	else 
d1327 1
a1327 1
		int	left=rect->left;
d1330 3
a1332 3
		// green
		//gaprect.left =  left;
		gaprect.right = left+wc;
d1335 1
a1335 1
      		dc->FillRect(&gaprect, &pr_Brush); 
d1337 3
a1339 3
		// yellow
		gaprect.left = left+wc;
		gaprect.right = left+wp;
d1344 4
a1347 4
 		//draw gray progress only if flat 
		gaprect.left = left+wp;
		gaprect.right = left+w;
		CBrush rgb_Brush(RGB(224,224,224));
d1349 2
a1350 2
      		dc->FillRect(&gaprect, &rgb_Brush);
			
d1352 2
a1353 2
	} 
	//--- :xrmb ---
d1363 1
a1363 1
	file->Write(&parts,2);
d1365 2
a1366 1
	while (done != parts){
d1368 4
a1371 3
		for (uint32 i = 0;i != 8;i++){
			//--- xrmb:partprio ---
			if (GetPartStatus(done)==PR_PART_ON && IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
d1373 1
a1373 1
				towrite |= (1<<i);
d1379 1
a1379 1
		file->Write(&towrite,1);
d1384 1
a1384 1
// DbT:StartUploadReq
d1390 3
a1392 2
	for (uint16 i=0; i < parts; i++) {
		if(GetPartStatus(i)!=PR_PART_OFF && IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1))
d1400 1
a1400 1
// DbT:End
d1402 1
a1402 1
// netwolf: complete sources (zegzav) 03.05.03 BEGIN
d1404 5
a1408 5
	{
	uint16 completecount= GetCompleteSourcesCount();
	file->Write(&completecount,2);
	}
// netwolf: complete sources (zegzav) 03.05.03 END
d1410 1
a1410 1
int CPartFile::GetValidSourcesCount() 
d1414 12
a1425 9
	int counter=0;
	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!m_srcLists[sl].IsEmpty())
	for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		m_srcLists[sl].GetNext(pos1);
		CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
		if (cur_src->GetDownloadState()!=DS_ONQUEUE && cur_src->GetDownloadState()!=DS_DOWNLOADING &&
			cur_src->GetDownloadState()!=DS_NONEEDEDPARTS) counter++;
	}
d1437 1
a1437 1
	uint16 counter=0;
d1439 10
a1448 7
	POSITION pos1,pos2;
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!m_srcLists[sl].IsEmpty())
		for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			m_srcLists[sl].GetNext(pos1);
			CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
		if (cur_src->GetDownloadState()!=DS_ONQUEUE && cur_src->GetDownloadState()!=DS_DOWNLOADING) counter++;
	}
d1455 1
a1455 1
// netwolf: complete sources (zegzav) - BEGIN
d1461 1
a1461 1
	uint16 counter=0;
d1463 12
a1474 10
	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!m_srcLists[sl].IsEmpty())
	for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		m_srcLists[sl].GetNext(pos1);
		CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
		if (cur_src->IsCompleteSource())
			counter++;
	}
	m_nLastCompleteSrcCount= counter;
	m_bUpdateCompleteSrcCount= false;
d1477 1
a1477 1
// netwolf: complete sources (zegzav) - END
d1494 2
d1498 1
a1498 1
//Inserted by Vorlost for load rarest parts first, code by Denominator 
d1503 15
a1517 14
	uint16 result = 0; 
	for (uint32 i = 0; i != ceil((float)PARTSIZE/EMBLOCKSIZE);i++){ 
		uint32 start = (PARTSIZE*partnumber) + i*EMBLOCKSIZE; 
		uint32 end    = (PARTSIZE*partnumber) + ((i+1)*EMBLOCKSIZE)-1; 
		if (end >= PARTSIZE*((uint32)partnumber+1)) 
			end = (PARTSIZE*(partnumber+1))-1; 
		if (start >= GetFileSize()) 
			break; 
		if (end >= GetFileSize()) 
			end = GetFileSize()-1; 
		if ( !IsComplete(start,end) && !IsAlreadyRequested(start,end)) 
			result++; 
	} 
	return result; 
d1522 1
a1522 1
} 
d1525 1
a1525 1
// Added by Tarod -remove no needed sources from download queue
d1527 1
a1527 1
// [In]	number_sources_to_remove: Number of sources to be removed from list or 0xffffffff if we want all removed
d1534 12
a1545 10
    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!m_srcLists[sl].IsEmpty())
	for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL && removed < number_sources_to_remove;) {
		m_srcLists[sl].GetNext(pos1);
		CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
		if ((cur_src->GetDownloadState() == DS_NONEEDEDPARTS) || (cur_src->IsRemoteQueueFull()))  //netwolf: katsyonak change
		{
			g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
			removed ++; // Count removed source
		}
	}
d1552 1
a1552 1
uint32 CPartFile::Process(uint32 reducedownload/*in percent*/, uint32 iteration)
d1556 9
a1564 9
	uint16			nOldTransSourceCount = GetTransferringSrcCount();  // DonGato: for category filters
	uint16			iOldSrcOnQueueCount = GetOnQueueSrcCount();
	DWORD			dwCurTick = ::GetTickCount();
	CUpDownClient  *cur_src;
	bool			sockets_usage_high;
	bool			bIsClientConnected;
	bool			bReaskDownload;
	POSITION		pos1, pos2;
	uint32			cur_dataRate;
d1566 1
a1566 1
	//eklmn: initialize temp variables
d1571 1
d1574 1
a1574 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(true, _T("Process: Throttling download to %ld%%"),reducedownload);
d1579 3
a1581 3
	// If buffer size exceeds limit, or if not written within time limit, flush data
	if ((m_nTotalBufferData > ((uint32)g_eMuleApp.m_pGlobPrefs->GetFileBufferSize())*30000) 
		|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT))) //netwolf: increased FileBufferSize
d1583 1
a1583 1
		// Avoid flushing while copying preview file
d1589 1
a1589 1
	 sockets_usage_high = g_eMuleApp.m_pListenSocket->GetNumOpenSockets() > (g_eMuleApp.m_pGlobPrefs->GetMaxConnections() * 0.75);
d1592 1
a1592 1
	 m_iNumTransferringSrcs = 0;
d1594 2
a1595 2
	// calculate data rate, set limit etc.
	// 9 iteration for download & 1 iteration for other files
d1598 1
a1598 1
		for (pos1 = m_downloadingSourceList.GetHeadPosition(); pos1 !=NULL;)
d1605 2
a1606 2
				m_dataRate+=cur_dataRate;
				if(reducedownload)
d1608 4
a1611 4
					uint32 limit = reducedownload*cur_dataRate/1000;
					if(limit<1000 && reducedownload == 200)
						limit +=1000;
					else if(limit<1)
d1613 2
a1614 1
#ifdef OLD_SOCKETS_ENABLED					
d1617 1
d1619 3
a1621 2
				else if ( m_nSavedReduceDownload != reducedownload )
#ifdef OLD_SOCKETS_ENABLED					
d1623 3
a1625 2
#endif //OLD_SOCKETS_ENABLED			
				m_nSavedReduceDownload  = reducedownload;
d1629 1
a1629 1
	else 
d1631 19
a1649 19
		// eklmn (khaos): initialize temp variables only if we need it
		bool		alreadyCounted =		false;
		uint16	i_TcntNNP =				0;
		uint16	i_TcntOnQueue =			0;
		uint16	i_TcntHighQR =			0;
		uint16	i_TcntConnecting =		0;
		uint16	i_TcntTooManyConns =	0;
		uint16	i_TcntConnected =		0;
		uint16	i_TcntTimeout =			0;
		uint16	i_TcntConnViaSrv =		0;
		uint16	i_TcntUnknown =		0;
		uint16	i_TcntRecHash =			0;
		uint16	i_TcntLowToLow =		0;
		uint16	i_TcntQueueFull =		0;
		uint16	i_TcntNoUpload =		0;
		uint16	i_TcntBanned =			0;
		uint16	i_TcntErr =				0;
		// <-----khaos-
	
d1654 2
a1655 2
				for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
				{	
d1658 4
a1661 3
					
					// eklmn: check a NULL case
					if (!cur_src) continue;
d1667 1
a1667 1
					
d1672 3
a1674 3
							// DonGato: needed to update the source count 
							// GetTransferringSrcCount() isn't updated inside this function.
							m_iNumTransferringSrcs++; 
d1677 1
a1677 1
							if (reducedownload && cur_src->GetDownloadState() == DS_DOWNLOADING) 
d1679 1
a1679 1
								uint32 limit = reducedownload*cur_dataRate/1000;
d1685 1
d1688 1
d1691 1
a1691 1
							else if( m_nSavedReduceDownload != reducedownload )
d1694 2
a1695 1
							m_nSavedReduceDownload  = reducedownload;
d1699 6
a1704 2
							if(!alreadyCounted) {i_TcntBanned++; alreadyCounted = true;}
							break;
d1707 6
a1712 2
							if(!alreadyCounted) {i_TcntErr++; alreadyCounted = true;}
							break;
d1715 1
a1715 1
							// if socket doesn't exist or isn't connected
d1717 4
a1720 1
							if(cur_src->socket)
d1722 2
a1723 1
								if (!cur_src->socket->IsConnected())
d1725 2
a1726 3
									cur_src->SetDownloadState(DS_NONE);
									if (!alreadyCounted) { i_TcntUnknown++; alreadyCounted = true; }
									break;
d1728 1
d1730 5
a1734 1
							else
d1736 2
a1737 3
								cur_src->SetDownloadState(DS_NONE);
								if (!alreadyCounted) { i_TcntUnknown++; alreadyCounted = true; }
								break;
d1739 2
d1743 3
a1745 1
							if (dwCurTick - cur_src->GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000)
d1747 2
a1748 3
								if(!alreadyCounted) { i_TcntTimeout++; alreadyCounted = true; }
								g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
								break;
d1750 1
a1750 2
							if(!alreadyCounted) {i_TcntConnected++; alreadyCounted = true;}
							bReaskDownload = true;
d1752 8
d1761 13
a1773 9
						case DS_LOWTOLOWIP:	// if we now have a high ip we can ask
							if(!alreadyCounted) { i_TcntLowToLow++; alreadyCounted = true; }
							if( ((dwCurTick - lastpurgetime) > PURGE_TIME) 
								&& (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()*.8 )) )
							{
								g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_src);
								lastpurgetime = dwCurTick;
								break;
							}
d1775 2
a1776 2
							if (g_eMuleApp.m_pServerConnect->IsLowID())
								break;
d1778 1
d1780 9
a1788 5
						{ 
							if(!alreadyCounted) { i_TcntNNP++; alreadyCounted = true; }
							if ( ((dwCurTick - lastpurgetime) > 40000) 
								&& (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()*.8 )) )
								if( !cur_src->SwapToAnotherFile(NULL,true) ) //eklmn: bugfix(08): A4AF switching
d1792 1
a1792 1
									break; 
d1795 2
a1796 2
							// doubled reasktime for no needed parts - save connections and traffic
							//Vorlost, noneededparts-sources will be checked filereasktime*4 when 3/4 of max. sockets are open 
d1799 1
a1799 1
							//End Vorlost for Expanded Filereasktime 
d1801 2
a1802 2
							// doubled reasktime for no needed parts - save connections and traffic
							if (!((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime*2))
d1807 1
a1807 1
							if( cur_src->IsRemoteQueueFull() )
d1809 7
a1815 3
								if(!alreadyCounted) { i_TcntQueueFull++; alreadyCounted = true; }
								if( ((dwCurTick - lastpurgetime) > 60000) 
									&& (GetSourceCount() >= (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()*.8 )) )
d1817 1
a1817 1
									g_eMuleApp.m_pDownloadQueue->RemoveSource( cur_src );
d1822 3
a1824 3
							// Check Remote queue position (HighQR)
							else if (g_eMuleApp.m_pGlobPrefs->UseRemoteQueueLimit()
								&& (cur_src->GetRemoteQueueRank() > g_eMuleApp.m_pGlobPrefs->GetRemoteQueueLimit())) 
d1826 5
a1830 1
								if (!alreadyCounted) { i_TcntHighQR++; alreadyCounted = true; }
d1834 7
a1840 3
							else if (!alreadyCounted) { i_TcntOnQueue++; alreadyCounted = true; }
							
							if ( cur_src->GetRemoteQueueRank() && sockets_usage_high )  //Vorlost QueueRank > 250 --> Filereasktime=45minutes
d1842 1
a1842 1
								if ( cur_src->GetRemoteQueueRank() > 250 )
d1844 1
a1844 1
								else 
d1848 1
a1848 1
							// LANCAST (moosetea) - We reask much faster if lancast user, UDP happens in 10 seconds
d1851 2
a1852 2
								if ((!cur_src->GetLastAskedTime()) 
									|| (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMEUDP)
d1857 1
a1857 1
							else 
d1860 3
a1862 3
								if (g_eMuleApp.m_pServerConnect->IsConnected() 
									&& ((!cur_src->GetLastAskedTime()) 
									|| (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime-20000))
d1867 1
d1870 2
a1871 2
							// START enkeyDEV(th1) -L2HAC- highid side, "prepare" phase
							// (emulates a "Connecting via server..." without socket timeout)
d1873 6
a1878 6
							if (g_eMuleApp.m_pServerConnect->IsConnected()
								&& (cur_src->GetLastAskedTime())
								&& ((dwCurTick - cur_src->GetLastAskedTime()) > (FILEREASKTIME - L2HAC_PREPARE_PRECEDE))
								&& cur_src->HasLowID()
								&& cur_src->GetL2HACTime()
								&& !g_eMuleApp.m_pServerConnect->IsLowID())
d1883 1
a1883 1
							// END enkeyDEV(th1) -L2HAC-
d1886 5
a1890 1
							if(!alreadyCounted) { i_TcntConnecting++; alreadyCounted = true; }
d1892 5
a1896 1
							if(!alreadyCounted) { i_TcntTooManyConns++; alreadyCounted = true; }
d1898 5
a1902 1
							if(!alreadyCounted) { i_TcntNoUpload++; alreadyCounted = true; }
d1904 8
a1911 4
							if(!alreadyCounted) { i_TcntConnViaSrv++; alreadyCounted = true; }
							bReaskDownload = true;
							break;
							
d1913 3
a1915 3
							i_TcntRecHash++;	
							break;
							
d1917 2
a1918 2
							i_TcntUnknown++;
					}// switch (state)
d1922 2
a1923 2
						// LANCAST (moosetea) - Because reask much faster if lancast user ie we may reask as soon as we get disconnected
						// , we only use TCP on a LAN, because emule may try to send a TCP request and UDP request at the same time!
d1926 1
a1926 1
						//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
d1932 31
a1962 31
				}// end: pos = srclist...
			}//end: srclist.Empty
		}// for (slots)

		// -khaos--+++> Set the members using temp vars.  We have
		//				to use temporary vars so that the disp counts
		//				don't get screwed up during processing.
		// we don't need to count this, cause we can get a transferring sources over m_downloadingSourceList.GetCount()
		//m_iSrcTransferring=	i_TcntTransferring;
		m_iSrcNNP =				i_TcntNNP;
		m_iSrcOnQueue =			i_TcntOnQueue;
		m_iSrcHighQR =			i_TcntHighQR;
		m_iSrcConnecting =		i_TcntConnecting;
		m_iSrcTooManyConns =	i_TcntTooManyConns;
		m_iSrcConnected =		i_TcntConnected;
		m_iSrcTimeout = 		i_TcntTimeout;
		m_iSrcConnViaServer =	i_TcntConnViaSrv;
		m_iSrcUnknown =			i_TcntUnknown;
		m_iSrcRecHash =			i_TcntRecHash;
		m_iSrcLowToLow =		i_TcntLowToLow;
		m_iSrcQueueFull =		i_TcntQueueFull;
		m_iSrcNoUpload =		i_TcntNoUpload;
		m_iSrcBanned =			i_TcntBanned;
		m_iSrcError =			i_TcntErr;
		m_iSrcA4AF =			m_A4AFsrcList.GetCount();
		// <-----khaos-

		// swap No needed partfiles if possible
		// v:- eklmn: A4AF management
		// Modified by Tarod -now handles A4AF too keeping usage of CPU less and do not forcing files
		// that has No Needed Parts to download letting them swap to another file
d1966 1
a1966 1
			for (int sl=0;sl<SOURCESSLOTS;sl++) 
d1968 1
a1968 1
					for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1 ) != NULL;) 
d1972 2
a1973 2
						// check if current source has a part for this file
						if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS) 
d1975 1
a1975 1
							// check if A4AF Auto file is enable
d1977 2
a1978 2
								// A4AF auto is disable => switch to any file
								cur_src->SwapToAnotherFile(NULL,true);	//eklmn: bugfix(08): A4AF switching
d1980 1
a1980 1
								// A4AF auto is enable & isn't current file => switch to A4AF auto file
d1985 4
a1988 4
	
		// if this "File" is A4AF auto & A4AF list isn't empty,
		// then check A4AF list and swap source to "this", if souce isn't NNS
		if (!m_A4AFsrcList.IsEmpty() && g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == this) 
d1990 2
a1991 2
			//eklmn: use a two-pointer loop to prevent exception due to swaping (delete)
			for (pos1 = m_A4AFsrcList.GetHeadPosition(); (pos2 = pos1 ) != NULL;)
d1999 1
a1999 1
		// ^- eklmn: A4AF management
d2001 2
a2002 2
		// check if we want new sources from server
		//uint16 test = g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft();
d2004 4
a2007 4
		if (( (!lastsearchtime) 
			|| (dwCurTick - lastsearchtime) > SERVERREASKTIME) 
			&& g_eMuleApp.m_pServerConnect->IsConnected()
			&& g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > GetSourceCount() )
d2009 1
a2009 1
			//local server
d2011 2
a2012 2
			Packet* packet = new Packet(OP_GETSOURCES,16);
			md4cpy(packet->m_pcBuffer,m_fileHash);
d2014 2
a2015 2
			g_eMuleApp.m_pServerConnect->SendPacket(packet,true);
			//AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
d2019 2
a2020 2
		// eklmn: call SaveSources only one time (in case if there isn't DL)
		// START enkeyDEV(kei-kun) -SLS preferences-
d2022 1
a2022 1
		if (iteration && g_eMuleApp.m_pGlobPrefs->SLSEnable() && m_downloadingSourceList.IsEmpty() && g_eMuleApp.m_pServerConnect->IsConnected()) 
d2027 1
a2027 1
		// END enkeyDEV(kei-kun) -SLS preferences-
d2029 1
a2029 1
		// calculate m_dataRate, set limit etc. (every 5sec)
d2043 2
a2044 2
	  || (iOldSrcOnQueueCount == 0 && GetOnQueueSrcCount() != 0)
	  || (iOldSrcOnQueueCount != 0 && GetOnQueueSrcCount() == 0) )
d2046 1
a2046 1
		uint8		curCat = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.GetCurTabCat();
d2050 1
a2050 1
	//		or not.
d2052 1
a2052 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.ChangeCategoryByID(curCat); 
d2055 2
a2056 2
		
		//	If we're displaying file counts in the tabs, update them to reflect status changes.
d2060 1
a2060 1
	
d2068 1
a2068 1
void CPartFile::AddSources(CMemFile& sources,uint32 serverip, uint16 serverport)
d2071 8
a2078 8
	
	//if this part file is paused or complete/completing no sources needed any more (Cax2 + SyruS check)
	if (GetStatus() == PS_PAUSED 
		|| GetStatus() == PS_STOPPED
		|| GetStatus() == PS_COMPLETE
		|| GetStatus() == PS_COMPLETING) 
		return;
	
d2082 1
a2082 1
	sources.Read(&count,1);
d2084 6
a2089 6
    {
	    // Added by Tarod - if there is needed place for more sources just remove NNS
	    int source_count_plus_new = GetSourceCount() + count;
	    if (source_count_plus_new > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
		    && ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME))
		    RemoveNoNeededSources(source_count_plus_new - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
d2091 2
a2092 1
	for (int i = 0;i != count;i++){
d2094 1
a2094 1
		sources.Read(&userid,4);
d2096 2
a2097 2
		sources.Read(&port,2);
		// check first if we are this source
d2099 1
a2099 1
		// MOD Note: Do not change this part - Merkur
d2101 3
a2103 1
		if (g_eMuleApp.m_pServerConnect->GetClientID() < 16777216 && g_eMuleApp.m_pServerConnect->IsConnected()){
d2109 2
a2110 1
		else if (userid < 16777216 && !g_eMuleApp.m_pServerConnect->IsLocalServer(serverip,serverport)){
d2115 1
a2115 1
		// MOD Note - end
d2117 2
a2118 1
		if( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > GetSourceCount() ){
d2120 3
a2122 3
			CUpDownClient* newsource = new CUpDownClient(port,userid,serverip,serverport,this);
			g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this,newsource);
		} 
d2129 1
a2129 1
// v- eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d2133 1
a2133 1
	// Cache part count
d2138 3
a2140 2
	// Increase size if necessary
	if(m_srcPartFrequencies.GetSize() < iPartCount){
d2143 3
a2145 2
	// Reset part counters & median
	for(int i = 0; i < iPartCount; i++){
d2148 1
a2148 1
	median = 0;     // <- eklmn: feature(00): ICR 
d2151 2
a2152 2
	// Calculate a median position
	int M_pos = (int)ceil(iPartCount/2.0) - 1;	// <- eklmn: feature(00): ICR
d2154 7
a2160 4
	POSITION pos1,pos2;
	for(int sl=0; sl<SOURCESSLOTS; ++sl) {
		if (!m_srcLists[sl].IsEmpty()) {
			for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
d2165 6
a2170 3
				for (int i = 0; i < iPartCount; i++){
					if (cur_src->IsPartAvailable(i)) {
						if (j == M_pos) median++;       // <- eklmn: feature(00): ICR
d2172 1
a2172 1
						m_srcPartFrequencies[i] +=1;
d2176 2
a2177 1
				if (availablecounter>MaxAvailableParts) MaxAvailableParts = availablecounter;
d2183 3
a2185 2
	for(int i = 0; i < iPartCount; i++)
		if (m_srcPartFrequencies[i] > m_MaxSrcPartFrequency) m_MaxSrcPartFrequency = m_srcPartFrequencies[i];
d2190 2
a2191 2
	m_bUpdateCompleteSrcCount= true;	// netwolf: zegzav:completesrc
	
d2197 1
a2197 1
// ^- eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d2199 1
a2199 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.11, 26.09.2003) for eMule+
d2207 1
a2207 1
	// Cache some values => speed improvement
d2210 1
a2210 1
	int16 i_CurBlockedParts =0;
d2212 3
a2214 3
  	// Mode 0=NoPreview,1=AVI(1F,1L),2=AVI(2F,1L),3=AVI(3F,1L)
  	// Mode 4=MPG(1F),5=MPG(2F),6=MPG(3F),7=AVI/MPG(2F,2L) F=First,L=Last
  	uint8* partsav = sender->GetPartStatus();
d2219 4
a2222 3
	if((goodpart != 0xffff) && GetNextEmptyBlockInPart(goodpart,0)) {
		//AddDebugLogLine(false,"Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u", this->GetFileName(), goodpart);
	 	return sender->GetLastDownPart();
d2224 3
a2226 2
	 else {
	 	sender->SetLastDownPart(0xffff);
d2229 3
a2231 3
	// Cunstruct Lists of block sorted by priority. Use number of parts to create limited lists and
	// keep data in list in same memory area (speed improvements)
	//CList<int> liRarestReqParts(partCount);	// priority 1 (highest)
d2235 1
a2235 1
	//CList<int> liReqParts(partCount);	// priority 6
d2237 2
a2238 2
	//----------------------------------------------------
	CList<uint16,uint16> m_CurBlockedParts;
d2241 3
a2243 2
	// scaning for requsted chunks in order to find how much they filled.
	for (int i = 0; i < partCount ; i++) {
d2245 4
a2248 3
		{	
			m_ReqParts[i] = GetBytesInPart(i,true);
			if (m_ReqParts[i] != 0) i_AvailableNeededParts++;
d2252 2
a2253 2
		// fill the m_BlockedParts array with NULL
			m_BlockedParts[i] = NULL;
d2256 1
a2256 1
	// scan DownloadList for Blocked parts
d2258 1
a2258 1
	for (POSITION pos = m_downloadingSourceList.GetHeadPosition(); pos !=NULL;)
d2268 4
a2271 3
	// define condition of rareness
	uint16 uRarestPart = (uint16)floor(0.1*median); // 10% from median
	if (uRarestPart < 3) uRarestPart = 3;
d2273 1
a2273 1
	// Build lists
d2275 1
a2275 1
       uint32 m_MostCompletedUniqueReqPart = PARTSIZE;
d2278 3
a2280 2
	for (int i = 0; i < partCount ; i++) {
		if (m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != 0) 
d2282 4
a2285 3
		        // Unique part (only one part exist, try to download it first in order to prevent
                        // file disappearing)
			if (m_srcPartFrequencies[i] == 1) {
d2288 4
a2291 2
				else {
					if (m_ReqParts[i] < m_MostCompletedUniqueReqPart) {
d2297 7
a2303 4
			// ------------------------ Rarest Parts -------------------------
			if (median >= (uRarestPart + m_srcPartFrequencies[i]) ) {
				if (m_ReqParts[i] == PARTSIZE) {
					for (int j=0; j < (median-m_srcPartFrequencies[i]+1); j++)  liRarestParts.AddHead(i);
d2305 4
a2308 2
				else {
					if (m_ReqParts[i] < m_MostCompletedRarestReqPart) {
d2314 38
a2351 26
			// --------------------------- Movie or Archive ---------------------------
			switch (PreviewMode) {
				case 3:  // 3=AVI(3F,1L)
					if (partCount > 3 && (i == partCount - 1)) liMovieParts.AddHead(i);
				case 6: // 6=MPG(3F)
					if (i == 2 && partCount > 2) liMovieParts.AddHead(2);
					if (i == 1 && partCount > 1) liMovieParts.AddHead(1);
					if (i == 0) liMovieParts.AddHead(0);
					break;
				case 7: // 7=AVI/MPG(2F,2L)
					if (partCount > 3 && (i == partCount - 2)) liMovieParts.AddHead(i);
				case 2: // 2=AVI(2F,1L)
					if (partCount > 2 && (i == partCount - 1)) liMovieParts.AddHead(i);
				case 5: // 5=MPG(2F)
					if (i == 1 && partCount > 1) liMovieParts.AddHead(1);
					if (i == 0) liMovieParts.AddHead(0);
					break;
				case 1: // 1=AVI(1F,1L)
					if (partCount > 1 && (i == partCount - 1)) liMovieParts.AddHead(i);
				case 4: // 4=MPG(1F)
					if (i == 0) liMovieParts.AddHead(0);
			}
			// --------------------- widespreaded parts ---------------------
			// check blocked parts
			if (m_BlockedParts[i] != NULL && i_AvailableNeededParts>i_CurBlockedParts) continue;
			if (m_ReqParts[i] == PARTSIZE) 
d2353 2
a2354 2
				// Unstarted
				for (int j=0; j < (m_MaxSrcPartFrequency-m_srcPartFrequencies[i]+1); j++)
d2357 1
a2357 1
			else 
d2359 1
a2359 1
				if (m_ReqParts[i] < m_MostCompletedReqPart) 
d2368 34
a2401 34
	// Select final result
	// ------------------------------ Unique & Requesred --------------------------------------------------
	// Try to complete a UniquePart and MostDownloaded as soon as possible to become a new source
	// it doesn't matter which one download, if there are parts same filled.
        if (m_MostCompletedUniqueReqPart != PARTSIZE && liMovieParts.IsEmpty()) 
        {
            goodpart = MostCompletedUniqueReqPart;
            //AddDebugLogLine(false,"Priority 1 (Unique unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
        }
        // ------------------------------ Unique & Unrequesred ------------------------------------------------
        else if (!liUniqueParts.IsEmpty() && liMovieParts.IsEmpty()) 
        {
	  	// If there is only one unique part, then take it, otherwise take it random.
			if (liUniqueParts.GetCount() == 1)
            	goodpart = liUniqueParts.GetHead();
		else 
		{
				const uint16 randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(liUniqueParts.GetCount()-1));
				goodpart = liUniqueParts.GetAt(liUniqueParts.FindIndex(randomness));
        	}
	        //AddDebugLogLine(false,"Priority 2 (Unique unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
		}
		// ------------------------------ Rarest & Requesred --------------------------------------------------
		// Try to complete a RarestPart and MostDownloaded as soon as possible to become a new source
		// it doesn't matter which one download, if there are parts same filled.
       else if (m_MostCompletedRarestReqPart != PARTSIZE) 
       {
            goodpart = MostCompletedRarestReqPart;
            //AddDebugLogLine(false,"Priority 3 (Rarest unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
		}
        // ------------------------------ Rarest & Unrequesred ------------------------------------------------
        else if (liRarestParts.IsEmpty() == false) 
        {
	  	// If there is only one rarest part, then take it, otherwise take it random.
d2404 1
a2404 1
		else 
d2406 1
a2406 1
			const uint16 randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(liRarestParts.GetCount()-1));
d2409 25
a2433 25
                //AddDebugLogLine(false,"Priority 4 (Rarest unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
        }
        // ---------------------------------- Movies Part  -----------------------------------------------------
        else if (liMovieParts.IsEmpty() == false) 
        {
            goodpart = liMovieParts.GetHead();
            //AddDebugLogLine(false,"Priority 5 (Preview part). File: %s, Part : %u", this->GetFileName(), goodpart);
        }
        // --------------------------------------- Requesred ----------------------------------------------------
        // Try to complete a UnfinishedPart and MostDownloaded as soon as possible to become a new source
   	// it doesn't matter which one download, if there are parts same filled.
        else if (m_MostCompletedReqPart != PARTSIZE) 
        {
			goodpart = MostCompletedReqPart;
			//m_BlockedParts[goodpart] = sender;
            //AddDebugLogLine(false,"Priority 6 (Widespread unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
        }
        // -------------------------------- Unrequesred & Random -------------------------------------------------
        else if (liRandomParts.IsEmpty() == false) 
        {
	   		const uint16 randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(liRandomParts.GetCount()-1));
			goodpart = liRandomParts.GetAt(liRandomParts.FindIndex(randomness));
			//m_BlockedParts[goodpart] = sender;
			//AddDebugLogLine(false,"Priority 7 (Widespread unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
        }
d2437 1
a2437 1
	//AddDebugLogLine(false,"ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), i_AvailableNeededParts, m_CurBlockedParts.GetCount(),goodpart);
d2439 11
a2449 6
	// clear lists
	if (!liUniqueParts.IsEmpty()) liRarestParts.RemoveAll();
	if (!liRarestParts.IsEmpty()) liRarestParts.RemoveAll();
	if (!liMovieParts.IsEmpty()) liMovieParts.RemoveAll();
	if (!liRandomParts.IsEmpty()) liRandomParts.RemoveAll();
	if (!m_CurBlockedParts.IsEmpty()) m_CurBlockedParts.RemoveAll();
d2462 2
a2463 2
		
	if (partnumber >= GetPartCount()) 
d2465 1
a2465 1
		
d2468 3
a2470 3
	
	const uint32 uStart = partnumber* PARTSIZE;
	const uint32 uEnd   = ((m_lFileSize - 1) < (uStart + PARTSIZE - 1)) ? (m_lFileSize - 1) : (uStart + PARTSIZE - 1);
d2474 2
a2475 2
		PartSize =  m_ReqParts[partnumber];
		left2DLSize = (uEnd -uStart +1) - PartSize;
d2479 7
a2485 7
		// Set part size to fullfilled
		PartSize = left2DLSize= uEnd -uStart + 1;
		for (POSITION pos = gaplist.GetHeadPosition(); pos != 0; gaplist.GetNext(pos) ) 
		{
			Gap_Struct* cur_gap = gaplist.GetAt(pos);
			// Check if Gap is into the limit
			if (cur_gap->end < uStart || cur_gap->start > uEnd) 
d2487 1
a2487 1
			if (cur_gap->start <= uStart && cur_gap->end > uStart && cur_gap->end < uEnd) 
d2492 1
a2492 1
			if (cur_gap->start >= uStart && cur_gap->end <= uEnd) 
d2497 1
a2497 1
			if (cur_gap->start <= uStart && cur_gap->end >= uEnd) 
d2502 1
a2502 1
			if (cur_gap->start > uStart && cur_gap->start < uEnd && cur_gap->end >= uEnd) 
d2506 1
a2506 1
	}
d2509 1
a2509 1
	left2DLSize -= PartSize; 
d2515 1
a2515 1
	
d2517 1
a2517 1
		
d2519 1
a2519 1
	
d2521 1
a2521 1
// ^- eklmn: feature(00): Intelligent Chunk Request(ICR v2.10, 3.07.2003) for eMule+
d2524 1
a2524 1
void  CPartFile::RemoveBlockFromList(uint32 start,uint32 end)
d2528 4
a2531 3
	POSITION pos1,pos2;
	for (pos1 = requestedblocks_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
	   requestedblocks_list.GetNext(pos1);
d2554 1
a2554 1
	//Show completing instead of paused
d2561 1
a2561 1
	
d2569 1
a2569 1
		CString			partFileNameBase = m_strPartMetFileName.Left(m_strPartMetFileName.GetLength()-4);
d2573 6
a2578 6
														 THREAD_PRIORITY_BELOW_NORMAL+g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(),
														 0,
														 CREATE_SUSPENDED );
		addFileThread->SetValues(0,m_strTempDir,partFileNameBase,this);
		addFileThread->ResumeThread();	
		return;
d2582 1
a2582 1
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC )CompleteThreadProc,this, THREAD_PRIORITY_BELOW_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
d2614 3
a2616 2
	//search for matching ()s and check if it contains a number inside
	if (fname.Right(1) == ')') {
d2618 3
a2620 2
		int ob = fname.ReverseFind('(');		
		if (ob != -1 && ob + 2 != ll) { //check for ) existence or () situation
d2622 4
a2625 2
			for (int i = ob + 1; i < ll - 1; i++) {	//check for digits inside brackets			
				if (!_istdigit(fname[i])) {
d2630 2
a2631 1
			if (found) {				
d2637 1
a2637 1
		
d2639 5
a2643 5
	{ 
       	namecount++; 
		newname.Format(_T("%s\\%s(%d)%s"), outputDir, fname, namecount, fext); 
    }
    while(PathFileExists(newname));    
d2646 2
a2647 2
// Lord KiRon - using threads for file completion
BOOL CPartFile::PerformFileComplete(void) 
d2651 2
a2652 2
	// Get current category
	int catID = GetCatID();
d2654 1
a2654 1
	//eklmn: wait until file will be free
d2657 2
a2658 2
		// do nothing, just wait
		Sleep(0); // release the CPU for other processes 
d2661 1
a2661 1
	// -khaos--+++> Save the lost/gain stats!
d2664 1
a2664 1
	// <-----khaos-
d2666 1
a2666 1
	CSingleLock(&m_FileCompleteMutex,TRUE); // will be unlocked on exit
d2668 1
a2668 1
	
d2670 1
a2670 1
	newname.Format(_T("%s\\%s"),GetOutputDir(), g_eMuleApp.StripInvalidFilenameChars(GetFileName()));
d2673 1
a2673 1
		::CreateDirectory(GetOutputDir(),0);
d2675 3
a2677 2
	// close permanent handle
	try{
d2681 2
a2682 1
	catch(CFileException* error){
d2684 1
a2684 1
		AddDebugLogLine(false,_T("Failed to close permanent handle %s - %s"),GetFileName(),GetErrorMessage(error));
d2687 1
a2687 1
	
d2689 1
a2689 1
	if(PathFileExists(newname))
d2693 1
a2693 1
	} 
d2695 75
a2769 75
	// Lord KiRon
	BOOL bSlowComplete   =   g_eMuleApp.m_pGlobPrefs->SlowComplete();
	int  BlockSize   =   g_eMuleApp.m_pGlobPrefs->SlowCompleteBlockSize()*1024; 
       
    // we do this only if SlowComplete enabled 
    // AND the files are on the different HDs (paratitions) - check by the drive leter 
    // AND any of path is not in URL/Network format (has : as second leter) 
    if (bSlowComplete && (_toupper(partfilename[0]) != _toupper(newname[0]) && partfilename[1] == _T(':') 
         && newname[1] == _T(':'))) 
    {
    	CFile fInputFile; 
        CFile fOutputFile; 
        try 
        { 
      		CString strTempNew   =   CString(newname); 
            strTempNew += _T(".$$$"); 
            // We going to write everithing into the temporary file at same place the newname located 
            // and after we finished - rename , this will take care of syncronization problem with SharedFiles 
            if (!fInputFile.Open(partfilename,CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary 
                | CFile::osSequentialScan)) 
            { 
               	// let catch to care about closing everything 
               	throw CString(GetResString(IDS_ERR_SLOWREAD)+_T(" (")+partfilename+_T(")"));
               	return FALSE; 
            } 
            if (!fOutputFile.Open(strTempNew,CFile::modeWrite | CFile::shareExclusive | CFile::osSequentialScan | CFile::modeCreate)) 
            { 
            	fInputFile.Close(); 
            	// let catch to care about closing everything 
				throw CString(GetResString(IDS_ERR_SLOWWRITE)+_T(" (")+strTempNew+_T(")"));
               	return FALSE; 
            } 

            DWORD dwRead = 0; 
            char *buffer = new char[BlockSize]; 
            if (!buffer) 
            { 
               	// let catch to care about closing everything 
               	throw CString(GetResString(IDS_ERR_OUTMEM)); 
               	return FALSE; 
            } 

            // Most of the work done here 
            // just copy the file data from one to another 
            do 
            { 
            	dwRead = fInputFile.Read(buffer, BlockSize ); 
               	fOutputFile.Write(buffer, dwRead); 
               	Sleep(0); // release the CPU for other processes 
               	// may be real sleep needed here , not sure 
            } 
            while (dwRead > 0); 
            delete []buffer; 

            fInputFile.Close();
            fOutputFile.Close();
            // Rename temporary file back to normal name 
            if (_trename(strTempNew,newname))
            { 
            	// let catch to care about closing everything 
               	throw CString(GetResString(IDS_ERR_RENFAIL)); 
               	return FALSE; 
            }
            CFile::Remove(partfilename); // This removes old Part file
		} 
        catch(CString str) 
        {          	
            AddLogLine(true,str); 
            m_bPaused = true; 
            SetStatus(PS_ERROR); 
            return FALSE; 
        } 
        catch(...) 
        {             
			// Purity - Sending message for erroneous file
d2774 11
a2784 9
            AddLogLine(true,IDS_ERR_COMPLETIONFAILED,GetFileName()); 
            m_bPaused = true; 
            SetStatus(PS_ERROR); 
            return FALSE; 
        } 
	} else {
		if (_trename(partfilename,newname))
		{         	
			// Purity - Sending message for erroneous file
d2789 12
a2800 12
            AddLogLine(true,IDS_ERR_COMPLETIONFAILED,GetFileName()); 
            m_bPaused = true; 
            SetStatus(PS_ERROR); 
            return FALSE; 
        }
	} 
    // Lord KiRon - end
    
	// bluecow: to have the accurate date stored in known.met we have to update the 'date' of a just completed file.
	// if we don't update the file date here (after commiting the file and before adding the record to known.met), 
	// that file will be rehashed at next startup and there would also be a duplicate entry (hash+size) in known.met because of different file date!
	ASSERT( m_hPartFile.m_hFile == INVALID_HANDLE_VALUE ); // the file must be closed/commited!
d2804 1
a2804 1
	// bluecow [SyruS]
d2806 2
a2807 2
    if (_tremove(fullname)) 
    	AddLogLine(true,IDS_ERR_DELETEFAILED,fullname); 
d2809 1
a2809 1
	// enkeyDEV(Ottavio84) -ChangeDir-
d2814 1
a2814 1
	// Tarod - erase .backup file
d2819 1
a2819 1
	// DonGato - remove .settings file
d2824 1
a2824 1
	// netwolf - remove .txtscr file
d2827 2
a2828 2
	//--- xrmb:keepPartFileStats ---
	//--- remove the stats file ---
d2830 1
a2830 1
	//--- :xrmb ---	
d2832 1
a2832 1
    fullname = newname; 
d2834 2
a2835 2
    SetStatus(PS_COMPLETE);
    m_bPaused = false;
d2837 2
a2838 2
    AddLogLine(true, IDS_DOWNLOADDONE, GetFileName()); 
	// Purity - Sending message for completed file
d2842 4
a2845 12
    g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_DLOAD, false, g_eMuleApp.m_pGlobPrefs->GetUseDownloadNotifier()); 
    if (renamed)
    	AddLogLine(true, IDS_DOWNLOADRENAMED, _tcsrchr(newname, '\\') + 1); 
    g_eMuleApp.m_pKnownFilesList->SafeAddKFile(this); 

    // Added to change UAP to Normal after finished download of file by Tarod 
    if (CKnownFile::IsAutoPrioritized())
    { 
    	CKnownFile::SetAutoPriority(false); 
        CKnownFile::SetPriority(PR_NORMAL); 
    } 
    // End Tarod 
d2847 9
a2855 1
    g_eMuleApp.m_pDownloadQueue->RemoveFile(this); 
d2860 1
a2860 1
	// mobilemule
d2862 1
a2862 1
	// end mobilemule
d2866 7
a2872 7
    // Added by Tarod (starts next paused file) 
    if (g_eMuleApp.m_pGlobPrefs->DownloadPausedOnComplete())
    {
    	g_eMuleApp.m_pDownloadQueue->StartNextFile(catID); 
    }
	// Barry - Just in case
	// -khaos--+++> Extended Statistics Added 2-10-03
d2876 1
a2876 1
	// <-----khaos- End Statistics Modifications
d2879 1
a2879 1
	
d2889 1
a2889 1
   	return TRUE; 
d2893 2
a2894 2
   	return FALSE; 
} 
d2897 1
a2897 1
void  CPartFile::RemoveAllSources(bool bTryToSwap)
d2901 2
a2902 2
	//TODO transfer sources to other downloading files if possible
	POSITION pos1,pos2;
d2904 2
a2905 2
	
	for (int sl=0;sl<SOURCESSLOTS;sl++)
d2913 3
a2915 3
				else	
					//eklmn: if switching was succesfull we need to remove the entry from graphical list
					g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.RemoveSource(cur_source,this);
d2918 1
a2918 1
				g_eMuleApp.m_pDownloadQueue->RemoveSource(cur_source);		
d2921 2
a2922 2
	//eklmn: remove A4AF entry from graphical list
	if (!m_A4AFsrcList.IsEmpty()) 
d2924 1
a2924 1
		for (pos1 = m_A4AFsrcList.GetHeadPosition(); (pos2 = pos1 ) != NULL;)
d2928 1
a2928 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.RemoveSource(cur_source,this);
d2939 1
a2939 1
	ASSERT ( !m_bPreviewing );
d2945 1
a2945 1
	// m_hPartFile isn't the handle to the file...
d2952 1
a2952 1
	CString partfilename = fullname.Left(fullname.GetLength() - 4);	
d2956 1
a2956 1
	// enkeyDEV(Ottavio84) -ChangeDir-
d2961 1
a2961 1
	// Tarod - erase .backup file
d2966 1
a2966 1
	// DonGato - remove .settings file
d2971 1
a2971 1
	// netwolf - remove .txtscr file
d2974 2
a2975 2
	//--- xrmb:keepPartFileStats ---
	//--- remove the stats file ---
d2977 1
a2977 1
	//--- :xrmb ---	
d2979 1
a2979 1
	//Cax2 - file properties get deleted inside one of these calls now...
d2982 2
a2983 2
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.RemoveFile(this);
	
d3003 1
a3003 1
		return true;		
d3009 1
a3009 1
		m_hPartFile.Seek((LONGLONG)PARTSIZE*partnumber,0);
d3013 13
a3025 3
		if ((ULONGLONG)PARTSIZE*(partnumber+1) > m_hPartFile.GetLength())
		{// netwolf: download bugfix for files > 2 GB (bluecow)
			length = (m_hPartFile.GetLength()- ((ULONGLONG)PARTSIZE*partnumber));
d3027 3
a3029 5
			ASSERT( length <= PARTSIZE );
		CreateHashFromFile(&m_hPartFile,length,hashresult);

		if (GetPartCount() > 1 || GetFileSize()==PARTSIZE){	// netwolf: special case if file size == part size
			if (md4cmp(hashresult,GetPartHash(partnumber)))
a3033 6
		else{
			if (md4cmp(hashresult,m_fileHash))
					return false;
				else
					return true;
		}
d3062 1
a3062 1
	// DonGato, updated by Vorlost
d3066 1
a3066 1
	return (_tcsstr(fname,_T(".avi")) || _tcsstr(fname,_T(".ogm")));
d3077 1
a3077 1
	// DonGato, updated by Vorlost
d3081 1
a3081 1
	return (_tcsstr(fname,_T(".mpg")) || _tcsstr(fname,_T(".mpe")) || _tcsstr(fname,_T(".dat")) || _tcsstr(fname,_T(".bin")));
d3092 3
a3094 3
	uint32 lastblock = ceil((float)PARTSIZE/EMBLOCKSIZE),end;
	if (chunk == GetPartCount()-2)
		end = (PARTSIZE*chunk) + (lastblock*EMBLOCKSIZE)-1; //Endadress from 1chunk before the last chunk
d3098 64
a3161 64
 		case 0: //Mode 0: No Preview
			return false;
			break;
 		case 1: //Mode 1: 1F,1L(2L) AVI
  			if (chunk == 0)
				return true; //1F
  			if (chunk == GetPartCount()-1)
				return true; //1L is a moviechunk ?
  			if (chunk == (GetPartCount()-2) && (((GetFileSize()-1) - MINLASTMOVIESIZE ) <= end))
				return true; //2L is a Part of 1/8L at the end of the file
  			break;
 		case 2: //Mode 2: 1F,2F,1L(2L) Long AVI
  			if (chunk == 0)
				return true; //1F
  			if (chunk == 1)
				return true; //2F
  			if (chunk == GetPartCount()-1)
				return true; //1L is a moviechunk ?
  			if (chunk == (GetPartCount()-2) && (((GetFileSize()-1) - MINLASTMOVIESIZE ) <= end))
				return true; //2L is a Part of 1/8L at the end of the file
  				break;
 		case 3: //Mode 3: 1F,2F,3F,1L(2L) Longest AVI
  			if (chunk == 0)
				return true; //1F
  			if (chunk == 1)
				return true; //2F
  			if (chunk == 2)
				return true; //3F
  			if (chunk == GetPartCount()-1)
				return true; //1L is a moviechunk
  			if (chunk == (GetPartCount()-2) && (((GetFileSize()-1) - MINLASTMOVIESIZE ) <= end))
				return true; //2L is a Part of 1/8L at the end of the file
  				break;
 		case 4: //Mode 4: 1F MPG
  			if (chunk == 0)
				return true; //1F
  			break;
 		case 5: //Mode 5: 1F,2F Long MPG
  			if (chunk == 0)
				return true; //1F
  			if (chunk == 1)
				return true; //2F
  			break;
 		case 6: //Mode 6: 1F,2F,3F Longest MPG
  			if (chunk == 0)
				return true; //1F
  			if (chunk == 1)
				return true; //2F
  			if (chunk == 2)
				return true; //3F
  			break;
 		case 7: //Mode 7: 1F,2F,1L,2L AVI/MPG normal
  			if (chunk == 0)
				return true; //1F
  			if (chunk == 1)
				return true; //2F
  			if (chunk == GetPartCount()-1) 
				return true; //1L is a moviechunk ?
  			if (chunk == GetPartCount()-2)
				return true; //2L is a moviechunk ?
  			break;
 		default:
  			return false;
			break;
d3169 1
a3169 1
bool CPartFile::IsBetterMovieChunk(uint16 oldchunk,uint16 newchunk)
d3173 1
a3173 1
	//The routine is based on that both old&new-chunk are moviechunks
d3176 6
a3181 6
		// 1/8F & !1/8L & (newchunk=1L | 2L)
 		if (IsComplete(0,(MINFIRSTMOVIESIZE)-1) //first 1/8 chunk present
  			&& !IsComplete( (GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1) //last 1/8 chunk not present
  			&& (newchunk == GetPartCount()-1  //better chunk could be 1L
   			|| (newchunk == GetPartCount()-2))) //better chunk could be 2L
				return true;
d3183 1
a3183 1
	else if (oldchunk == GetPartCount()-1 || oldchunk == GetPartCount()-2) //Chunk = 1L | 2L
d3185 7
a3191 7
 		// (1/8L & !1/8F) | (1/8L & 1/8F)
 		if (((!IsComplete(0,(MINFIRSTMOVIESIZE)-1) //first 1/8 chunk not present
    		&& IsComplete( (GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1)) //last 1/8 chunk present
   			||(IsComplete(0,(MINFIRSTMOVIESIZE)-1) //first 1/8 chunk present
        	&& IsComplete( (GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1)) //last 1/8 chunk present
            && newchunk == 0))  //better chunk could be 1F
				return true;
d3195 2
a3196 2
 		// 1F | 1L
 		if (newchunk == 0 || newchunk == GetPartCount()-1)
d3201 2
a3202 2
 		// 1F | 1L otherwise 2F
 		if (newchunk == 0 || newchunk == GetPartCount()-1)
d3204 1
a3204 1
 		else if (newchunk == 1)
d3214 1
a3214 1
bool CPartFile::Movie1(uint8 mode,uint16 oldchunk,uint16 newchunk)
d3220 3
a3222 3
 		if (!IsMovieChunk(mode,newchunk) && IsMovieChunk(mode,oldchunk))
  			return false;
 		if (IsMovieChunk(mode,newchunk) && IsMovieChunk(mode,oldchunk))
d3224 2
a3225 2
  			if (!IsBetterMovieChunk(oldchunk,newchunk))
   				return false;
d3236 1
a3236 1
bool CPartFile::Movie2(uint8 mode,uint8 raremovie,bool forcepreview,uint16 oldchunk,uint16 newchunk)
d3240 4
a3243 4
	if (IsMovie() && ((m_srcPartFrequencies[oldchunk] > raremovie
    	&& m_srcPartFrequencies[newchunk] > raremovie)      //old & new chunk are nonrare
    	|| (m_srcPartFrequencies[oldchunk] == m_srcPartFrequencies[newchunk]) //old & new chunk are same rare
    	|| forcepreview))            //Load preview chunks first no matter of rareness
d3245 10
a3254 3
			//This Line just for debugging:
			//AddLogLine(true,false,CString("Movie2::Mode:%d old:%d new:%d rarem:%d - The new & old ones are nonrare,samerare or forced, now we decide if new is a better movie or could change to movie..."),mode,oldchunk,newchunk,raremovie);
 			if (!IsMovieChunk(mode,oldchunk) && IsMovieChunk(mode,newchunk))
d3256 1
a3256 1
  				if (forcepreview)
d3258 2
a3259 9
 			}
 			if (IsMovieChunk(mode,oldchunk) && IsMovieChunk(mode,newchunk))
			{
  				if (IsBetterMovieChunk(oldchunk,newchunk))
				{
   					if (forcepreview)
	 					return true;
  				}
 			}
d3273 1
a3273 1
	if (chunk == GetPartCount()-1) //Is this the last chunk ?
d3275 11
a3285 11
 		uint32 lastblock = ceil((float)PARTSIZE/EMBLOCKSIZE);
 		uint32 lastblockinpart = lastblock;
 		uint32 start;
    	//Get last possible blocknumber
 		for (lastblockinpart = 0; lastblockinpart != lastblock;lastblockinpart++)
		{
  			start = (PARTSIZE*chunk) + lastblockinpart*EMBLOCKSIZE;
  			if (start >= GetFileSize())
   				break;
 		}
 		addchunk = lastblock - lastblockinpart;
d3296 1
a3296 1
// Barry - Also want to preview zip/rar files
d3302 1
a3302 1
	
d3329 2
a3330 2
	if (m_eStatus==PS_COMPLETE || m_eStatus==PS_COMPLETING)
		return;
d3332 2
a3333 2
	//eklmn: set status to PS_STOPPED in order to prevent any action from other threads
	//SetStatus(PS_STOPPED); <- DonGato: this is wrong, we break the sharing of incomplete files and make a bogus tag
d3335 3
a3337 3
	// Barry - Need to tell any connected clients to stop sending the file
	// eklmn: send a downloading client a cancel
	POSITION pos1,pos2;
d3341 2
a3342 2
	for (pos1 = m_downloadingSourceList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
	{	
d3344 2
a3345 1
		cur_src = m_downloadingSourceList.GetAt(pos2);;
d3348 2
a3349 1
		cur_src->socket->SendPacket(packet,false,true);
d3351 2
a3352 1
		cur_src->SetDownloadState(DS_ONQUEUE);		
d3356 1
a3356 1
	//eklmn: reset A4AF auto file
d3359 3
a3361 3
	
	// it is poitless to hide sources if they will be deleted
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.HideSources(this); // cax2 closefile bugfix
d3367 3
a3369 3
	// reset a statistical variables
	m_iSrcNNP =	0;
	m_iSrcOnQueue =	0;
d3376 1
a3376 1
	m_iSrcUnknown =	0;
d3383 1
a3383 1
	if(!m_bIsBeingDeleted)
d3386 1
a3386 1
	if(!m_bIsBeingDeleted)
d3393 1
a3393 1
// v- eklmn: bugfix(02): file were paused not properly.... (who forgot the brackets?! :O)
d3398 5
a3402 2
	if (m_eStatus==PS_COMPLETE || m_eStatus==PS_COMPLETING)
		return;
a3403 3
	//eklmn: set status to PS_PAUSED in order to prevent any action from other threads
	//SetStatus(PS_PAUSED); <- DonGato: this is wrong, we break the sharing of incomplete files and make a bogus tag
	
d3406 1
a3406 1
	POSITION pos1,pos2;
d3408 3
a3410 3
	//eklmn: send a downloading client a cancel
	for (pos1 = m_downloadingSourceList.GetHeadPosition();( pos2 = pos1 ) != NULL;)
	{	
d3412 2
a3413 1
		cur_src = m_downloadingSourceList.GetAt(pos2);;
d3416 2
a3417 1
		cur_src->socket->SendPacket(packet,false,true);
d3419 2
a3420 1
		cur_src->SetDownloadState(DS_ONQUEUE);		
d3422 7
a3428 4
	//eklmn: at this point nobody is downloading, and we can try to swap sources
	for (int sl=0;sl<SOURCESSLOTS;sl++) {
		if (!m_srcLists[sl].IsEmpty()) {
			for( pos1 = m_srcLists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ) {
d3431 1
a3431 1
				// eklmn: swap source to any other file
d3443 1
a3443 1
	if(!m_bIsBeingDeleted)
d3449 1
a3449 1
// ^- eklmn: bugfix(02): file were paused not properly.... (who forgot the brackets?! :O)
d3455 3
a3457 2
	if (m_eStatus==PS_COMPLETE || m_eStatus==PS_COMPLETING) return;
	//eklmn: check if chunks are availibla & set status
d3459 1
a3459 1
	for (int i = 0; i < GetPartCount(); i++) 
d3461 3
a3463 3
		uint32 uStart = i* PARTSIZE;
		uint32 uEnd   = ((m_lFileSize - 1) < (uStart + PARTSIZE - 1)) ? (m_lFileSize - 1) : (uStart + PARTSIZE - 1);
		if (IsComplete(uStart,uEnd) == true)
d3469 1
a3469 1
	
d3475 1
a3475 1
	
d3486 1
a3486 1
// Added by Vorlost to load initial sources from Server after connect 
d3491 5
a3495 4
	if (lastsearchtime>0){ 
		//AddLogLine(true,CString("Resetting LastSearchTime:%d in Filename:%s"),lastsearchtime,GetFileName());
		lastsearchtime = 0; 
	} 
d3504 1
a3504 1
	CString mybuffer=_T(""); 
d3506 2
a3507 2
	if (GetTransferringSrcCount()>0)
		mybuffer=GetResString(IDS_DOWNLOADING);
d3511 1
a3511 1
			mybuffer=GetResString(IDS_WAITING); 
d3513 1
a3513 1
			mybuffer=GetResString(IDS_STALLED);
d3518 1
a3518 1
		case PS_HASHING: 
d3520 2
a3521 2
			mybuffer=GetResString(IDS_HASHING);
			break; 
d3523 2
a3524 2
			mybuffer=GetResString(IDS_COMPLETING);
			break; 
d3526 2
a3527 2
			mybuffer=GetResString(IDS_COMPLETE);
			break;
d3529 2
a3530 2
			mybuffer=GetResString(IDS_PAUSED);
			break; 
d3532 2
a3533 2
			mybuffer=GetResString(IDS_ERRORLIKE);
			break;
d3535 4
a3538 4
			mybuffer=GetResString(IDS_STOPPED);
			break;
	} 
	return mybuffer; 
d3543 1
a3543 1
} 
d3549 1
a3549 1
	int		ipfStatus = 0;
d3551 1
a3551 1
	if (GetTransferringSrcCount()>0)
d3556 1
a3556 1
			ipfStatus = PS_WAITINGFORSOURCE; 
d3563 1
a3563 1
		case PS_HASHING: 
d3565 2
a3566 2
			ipfStatus = PS_HASHING;
			break;
d3572 4
a3575 4
			ipfStatus = GetStatus();
			break;
	} 
	return ipfStatus; 
d3580 1
a3580 1
} 
d3584 1
a3584 1
	EMULE_TRY 
d3586 1
a3586 1
	// Sort order is Complete - Completing - Downloading - Waiting - Stalled - Paused - Errors
d3588 2
a3589 2
	int status=2;
	if (GetTransferringSrcCount()==0)
d3592 1
a3592 1
		status=3;
d3594 1
a3594 1
			status=4;
d3596 3
a3598 2
	switch (GetStatus()) {
		case PS_HASHING: 
d3600 2
a3601 2
			status=6;
			break; 
d3603 2
a3604 2
			status=1;
			break; 
d3606 2
a3607 2
			status=0;
			break; 
d3609 2
a3610 2
			status=5;
			break; 
d3612 2
a3613 2
			status=7;
			break;
d3615 3
a3617 3
			status=8;
			break;
	} 
d3623 1
a3623 1
} 
d3629 2
a3630 2
	uint32		iDataRate = 0;
	sint32		iTimeRemaining = -1;
d3636 1
a3636 1
	iTimeRemaining = (iDataRate > 0 ? (GetFileSize()-GetCompletedSize()) / iDataRate : -1);
d3642 1
a3642 1
} 
d3645 1
a3645 1
//		average in 'm_AvgDataRate' as well as returning it.
d3652 1
a3652 1
		CTimeSpan		timeSpan;
d3666 1
a3666 1
		uint32		iSeconds = timeSpan.GetTotalSeconds();
d3669 1
a3669 1
			m_AvgDataRate = ( (GetSessionTransferred() /*+ GetDataRate()*/) / (iSeconds /*+ 1*/) );
d3673 1
a3673 1
	
d3686 1
a3686 1
		return;
d3691 1
a3691 1
	 	return;
d3697 1
a3697 1
		CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
d3704 2
a3705 2
		CString player=g_eMuleApp.m_pGlobPrefs->GetVideoPlayer();
		strLine.Replace(_T(".met"),_T(""));
d3707 2
a3708 2
		if(player.IsEmpty())
			ShellExecute(NULL, _T("open"), strLine, NULL,NULL, SW_SHOWNORMAL);
d3711 3
a3713 3
			CString runDir=player;
			int i=runDir.ReverseFind('\\');
			runDir=(i>=0)?runDir.Left(i+1):_T("");
d3730 1
a3730 1
	// Barry - Allow preview of archives of any length > 1k
d3733 3
a3735 3
		if (GetFileSize()>1024 && GetCompletedSize()>1024 && !m_bRecoveringArchive && ((space + 100000000) > (2*GetFileSize())))
			return true; 
		else 
d3743 3
a3745 3
		return !((GetStatus() != PS_READY && GetStatus() != PS_PAUSED) 
			|| m_bPreviewing || GetPartCount() < 5 || !IsMovie() || (space + 100000000) < GetFileSize() 
			|| (!IsComplete(0,PARTSIZE-1) || !IsComplete(PARTSIZE*(GetPartCount()-1),GetFileSize()-1)));
d3751 2
a3752 2
		// enable the preview command if the according option is specified 'PreviewSmallBlocks' 
		// or if VideoLAN client is specified
d3755 2
a3756 2
		    if (m_bPreviewing)
			    return false;
d3758 3
a3760 3
		    uint8 uState = GetStatus();
		    if (!(uState == PS_READY || uState == PS_EMPTY || uState == PS_PAUSED))
			    return false;
d3765 1
a3765 1
				return false; 
d3768 4
a3771 4
		    // If it's an MPEG file, VLC is even capable of showing parts of the file if the beginning of the file is missing!
		    bool bMPEG = false;
		    LPCTSTR pszExt = _tcsrchr(GetFileName(), _T('.'));
		    if (pszExt != NULL)
d3773 3
a3775 3
			    CString strExt(pszExt);
			    strExt.MakeLower();
			    bMPEG = (strExt==_T(".mpg") || strExt==_T(".mpeg") || strExt==_T(".mpe") || strExt==_T(".mp3") || strExt==_T(".mp2") || strExt==_T(".mpa"));
d3778 1
a3778 1
		    if (bMPEG)
d3780 2
a3781 2
			    // TODO: search a block which is at least 16K (Audio) or 256K (Video)
			    if (GetCompletedSize() < 16*1024)
d3784 4
a3787 4
		    else
		    {
			    // For AVI files it depends on the used codec..
			    if (!IsComplete(0, 256*1024))
d3791 1
a3791 1
		    return true;
d3795 2
a3796 2
		    return !((GetStatus() != PS_READY && GetStatus() != PS_PAUSED) 
				    || m_bPreviewing || GetPartCount() < 2 || !IsMovie() || !IsComplete(0,PARTSIZE-1)); 
d3812 2
a3813 1
	if(GetSourceCount() == 0) return NULL;		//netwolf 07.05.03
d3821 4
a3824 4
	data.Write(m_fileHash,16);
	data.Write(&nCount,2);
	
	for (int sl=0;sl<SOURCESSLOTS;sl++) 
d3826 1
a3826 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d3832 5
a3836 5
				// Modified by Tarod -sends sources with LowID that are in same sever
				// that client is requesting sources
				if (cur_src->HasLowID() 
					&& (cur_src->GetServerIP() != forClient->GetServerIP() 
					|| cur_src->GetServerPort() != forClient->GetServerPort()))
d3841 3
a3843 2
				// LANCAST (moosetea) - We don't share Lan clients sources as they are private ips/userids
				if (cur_src->isOnLAN()) continue;
d3845 3
a3847 3
				// Added by Tarod, do not send incomplete established conns. to avoid sending
				// no valid sources
				switch (cur_src->GetDownloadState()) 
d3853 2
a3854 2
						continue;
						break;
d3857 1
a3857 1
				// only send source which have needed parts for this client if possible
d3860 1
a3860 1
					uint8* reqstatus = forClient->GetPartStatus();
d3873 1
a3873 1
					uint8* srcstatus = cur_src->GetPartStatus();
d3884 1
a3884 1
				if( bNeeded )
d3891 4
a3894 4
					data.Write(&dwID,4);
					data.Write(&nPort,2);
					data.Write(&dwServerIP,4);
					data.Write(&nServerPort,2);
d3899 1
a3899 1
			
d3902 2
a3903 2
	data.Seek(16,0);
	data.Write(&nCount,2);
d3905 1
a3905 1
	Packet* result = new Packet(&data,OP_EMULEPROT);
d3909 1
a3909 1
	//AddDebugLogLine(false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount);
d3923 7
a3929 7
	//if this part file is paused or complete/completing no sources needed any more (Cax2 + SyruS check)
	if (GetStatus() == PS_PAUSED 
		|| GetStatus() == PS_STOPPED
		|| GetStatus() == PS_COMPLETE
		|| GetStatus() == PS_COMPLETING) 
		return;
	
d3931 1
a3931 1
	sources->Read(&nCount,2);
d3933 15
a3947 15
/*	if (g_eMuleApp.m_pGlobPrefs->IsRemoveNNSEnabled())  //Vorlost added prefs question
	{
	    // Added by Tarod - calculate if we need more space than what is disponible
	    // if so remove No Needed Sources
	    int source_count_plus_new = GetSourceCount() + nCount;
	    if (source_count_plus_new > g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile()
		    && ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME)) {
    
		    RemoveNoNeededSources(source_count_plus_new - g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile());
	    }
	}
*/
	// Check if the data size matches the 'nCount' for v1 or v2 and eventually correct the source
	// exchange version while reading the packet data. Otherwise we could experience a higher
	// chance in dealing with wrong source data, userhashs and finally duplicate sources.
d3949 1
a3949 1
	if ((UINT)nCount*(4+2+4+2) == uDataSize)
d3951 1
a3951 1
	else if ((UINT)nCount*(4+2+4+2+16) == uDataSize)
d3953 5
a3957 4
	else{
		// If v3 inserts additional data (like v2), the above code will correctly filter those packets.
		// If v3 appends additional data after <count>(<Sources>)[count], we are in trouble with the 
		// above code. Though a client which does not understand v3+ should never receive such a packet.
d3959 1
a3959 1
		return;
d3962 2
a3963 1
	for (int i = 0;i != nCount;i++){
d3965 4
a3968 4
		sources->Read(&source.sourceID,4);
		sources->Read(&source.sourcePort,2);
		sources->Read(&source.serverIP,4);
		sources->Read(&source.serverPort,2);		
d3970 2
a3971 2
			sources->Read(&source.achUserHash,16);
		AddClientSource(&source, i,true,sourceexchangeversion);
d3978 1
a3978 1
void CPartFile::GetSizeToTransferAndNeededSpace(uint32& pui32SizeToTransfer, uint32& pui32NeededSpace) 
d3982 3
a3984 2
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos)){
		Gap_Struct* cur_gap = gaplist.GetAt(pos);
d3986 1
a3986 1
		if(cur_gap->end == GetFileSize()-1)
d3993 1
a3993 1
// Updates priority of file if autopriority is activated
d3998 6
a4003 4
	if (IsAutoPrioritized()) {
		CPartFile* partfile = g_eMuleApp.m_pDownloadQueue->GetFileByID(GetFileHash()) ;
		
		if (partfile != NULL && partfile->IsPartFile()) {
d4011 1
a4011 1
		} 
d4017 5
a4021 4
// making this function return a higher when more sources have the extended
// protocol will force you to ask a larger variety of people for sources
uint32 CPartFile::GetCommonFilePenalty() {
	//TODO: implement, but never return less than MINCOMMONPENALTY!
d4026 2
a4027 2
{	
	return RemoveFileExtension(fullname) + _T(".stats");	
d4034 27
a4060 5
	
	FILE *fh = _tfopen(GetStatsFullPath(), _T("rb"));
	
	//--- if we cant open this file... you lose the stats ---
	if(fh==NULL)
d4062 6
a4067 12
	
	//--- get version ---
	uint8	version=0;
	if(fread(&version, sizeof(version), 1, fh)!=1) { fclose(fh); return false; }

	uint32 alltimerequested=0;
	uint32 alltimeaccepted=0;
	uint64 alltimetransferred=0;

	if(fread(&alltimerequested,		sizeof(alltimerequested),	1, fh)!=1) { fclose(fh); return false; }
	if(fread(&alltimeaccepted,		sizeof(alltimeaccepted),	1, fh)!=1) { fclose(fh); return false; }
	if(fread(&alltimetransferred,	sizeof(alltimetransferred),	1, fh)!=1) { fclose(fh); return false; }
d4071 8
a4078 4
	//--- this is for the parttraffic ---
	//--- i thought about explicit adding the traffic like for the other stats above ---
	//--- but it doesnt make sense, because you'll no transfer if you reach this ---
	if(LoadFromFileTraffic(fh, version)==false) { fclose(fh); return false;	}
d4092 2
a4093 2
	
	if (!fullname || IsBadStringPtr(fullname,MAX_PATH))
d4096 1
a4096 1
	}	
d4098 30
a4127 3
	
	//--- if we cant open this file... you lose the stats ---
	if(fh==NULL)
d4129 1
a4129 12
	
	//--- set version ---
	uint8	version=2;
	if(fwrite(&version, sizeof(version), 1, fh)!=1) { fclose(fh); return false; }

	uint32 alltimerequested=statistic.GetAllTimeRequests();
	uint32 alltimeaccepted=statistic.GetAllTimeAccepts();
	uint64 alltimetransferred=statistic.GetAllTimeTransferred();

	if(fwrite(&alltimerequested,	sizeof(alltimerequested),	1, fh)!=1) { fclose(fh); return false; }
	if(fwrite(&alltimeaccepted,		sizeof(alltimeaccepted),	1, fh)!=1) { fclose(fh); return false; }
	if(fwrite(&alltimetransferred,	sizeof(alltimetransferred),	1, fh)!=1) { fclose(fh); return false; }
d4131 6
a4136 2
	//--- this is for the parttraffic ---
	if(SaveToFileTraffic(fh)==false) { fclose(fh); return false; }
d4158 3
a4160 3
// Used as separate thread to complete file [Lord KiRon]
UINT CPartFile::CompleteThreadProc(CPartFile* pFile) 
{ 
d4163 1
a4163 1
	if ( g_eMuleApp.m_pGlobPrefs->IsNTBased() )
d4168 7
a4174 7
	if ( !pFile ) 
   	{ 
    	return -1; 
   	} 
	CSingleLock Lock(&s_ComplitingMutex,TRUE); // Prevent of compliting two files in same time
   	pFile->PerformFileComplete(); 
   	return 0; 
d4178 1
a4178 1
   	return -1; 
d4181 2
a4182 1
CString CPartFile::DtLocale(CTime dt){
d4185 1
a4185 1
	dt.GetAsSystemTime(st); 
d4194 2
a4195 2
	CString strTime; 
	GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, strTime.GetBuffer(nTimeSize), nTimeSize); 
d4199 8
a4206 8
    switch ( dt.GetDayOfWeek() )
      {
         case 1:
			 strDay = GetResString(IDS_SCH_EXCEPT_SUN);
            break;
         case 2:
			 strDay = GetResString(IDS_SCH_EXCEPT_MON);
            break;
d4208 2
a4209 2
			strDay = GetResString(IDS_SCH_EXCEPT_TUE);
            break;
d4211 2
a4212 2
			strDay = GetResString(IDS_SCH_EXCEPT_WED);
            break;
d4214 2
a4215 2
			strDay = GetResString(IDS_SCH_EXCEPT_THU);
            break;
d4217 2
a4218 2
			strDay = GetResString(IDS_SCH_EXCEPT_FRI);
            break;
d4220 3
a4222 3
			strDay = GetResString(IDS_SCH_EXCEPT_SAT);
            break;
      }
d4224 1
a4224 1
	return 	strDay + _T(", ") + strDate + _T(", ") +  strTime; 
d4230 1
a4230 1
{ 
d4235 1
a4235 1
	if(PathFileExists(strIniFile))
d4237 1
a4237 1
   		CIni filesettings(strIniFile);
d4240 1
a4240 1
   		uint8 Mode = filesettings.GetInt(_T("MoviePreviewMode"), 0); 
d4242 3
a4244 3
		m_bDiscardSuperCompressed = filesettings.GetBool(_T("DiscardSuperCompressed"),false);
		m_bStopped = filesettings.GetBool(_T("StoppedStatus"),m_bStopped);
		m_bIsPreallocated = filesettings.GetBool(_T("Preallocated"),m_bIsPreallocated);
d4259 1
a4259 1
   	CIni filesettings(strIniFile);
d4262 4
a4265 4
	filesettings.SetInt(_T("MoviePreviewMode"), ((CKnownFile*)this)->GetMovieMode()); 
    filesettings.SetBool(_T("DiscardSuperCompressed"),m_bDiscardSuperCompressed);
    filesettings.SetBool(_T("StoppedStatus"),m_bStopped);
    filesettings.SetBool(_T("Preallocated"),m_bIsPreallocated);
d4271 1
a4271 3
// DonGato - Moview Preview Mode end

/* Barry - Replaces BlockReceived() 
d4273 2
d4278 1
a4278 1

d4281 1
a4281 1

d4285 1
a4285 1

d4294 1
a4294 1
	// Increment transferred bytes counter for this file
d4297 1
a4297 1
	// This is needed a few times
d4300 2
a4301 2
	if( lenData > transize )
		m_iGainDueToCompression += lenData-transize;
d4303 1
a4303 1
	// Occasionally packets are duplicated, no point writing it twice
d4310 1
a4310 1
	// Create copy of data as new buffer
d4314 1
a4314 1
	// Create a new buffered queue entry
d4321 1
a4321 1
	// Add to the queue in the correct position (most likely the end)
d4326 1
a4326 1
	{	
d4338 1
a4338 1
	// Increment buffer size marker
d4341 1
a4341 1
	// Mark this small section of the file as filled
d4344 2
a4345 2
	// Update the flushed mark on the requested block 
	// The loop here is unfortunate but necessary to detect deleted blocks.
d4348 1
a4348 1
	{	
d4353 3
a4355 3
	// v- eklmn: bugfix(20): check last part in WriteToBuffer correct way
	// if (gaplist.IsEmpty()) FlushBuffer();  //netwolf: another approach to avoid sharing of corrupted parts (trockenbeerenauslese)
	uint16 partnumber = floor(start/static_cast<double>(PARTSIZE));
d4357 1
a4357 1
	const uint32 uEnd   = ((m_lFileSize- 1) < (uStart + PARTSIZE - 1)) ? (m_lFileSize- 1) : (uStart + PARTSIZE - 1);
d4363 1
a4363 1
	// ^- eklmn: bugfix(20): check last part in WriteToBuffer correct way
d4367 1
a4367 1
	// Return the length of data written to the buffer
d4384 1
a4384 1
		return;
d4391 1
a4391 1
	uint32		partCount = (m_lFileSize/PARTSIZE)+((m_lFileSize%PARTSIZE)? 1 : 0);
d4399 1
a4399 1
	// Remember which parts need to be checked at the end of the flush
d4401 1
a4401 1
		for (int partNumber=0; (uint32)partNumber<partCount; partNumber++)
d4406 1
a4406 1
		// Ensure file is big enough to write data to (the last item will be the furthest from the start)
d4413 1
a4413 1
	//		size of the target file.
d4418 1
a4418 1
		for (int i = m_BufferedData_list.GetCount(); i>0; i--)
d4420 1
a4420 1
			// Get top item
d4423 1
a4423 1
			// This is needed a few times
d4426 1
a4426 1
			//SyruS (0.29a) SLUGFILLER: SafeHash - could be more than one part
d4431 1
a4431 1
			for (uint32 curPart = item->start/PARTSIZE; curPart <= item->end/PARTSIZE; curPart++)
d4433 1
a4433 1
			// SLUGFILLER: SafeHash
d4435 1
a4435 1
			// Go to the correct position in file and write block of data
d4439 1
a4439 1
			// Remove item from queue
d4442 1
a4442 1
			// Decrease buffer size
d4445 1
a4445 1
			// Release memory used by this item
d4450 1
a4450 1
		// Flush to disk
d4453 2
a4454 2
		// Check each part of the file
		uint32		partRange = (m_lFileSize % PARTSIZE) - 1;	//netwolf 03.05.03
d4457 1
a4457 1
		for (int partNumber = partCount-1; partNumber >= 0; partNumber--)
d4462 1
a4462 1
				// Any parts other than last must be full size
d4467 2
a4468 2
			// Is this 9MB part complete
			if ( IsComplete(PARTSIZE * partNumber, (PARTSIZE * (partNumber + 1)) - 1 ) )
d4470 1
a4470 1
				// Is part corrupt
d4474 1
a4474 1
					AddGap(PARTSIZE*partNumber, (PARTSIZE*partNumber + partRange));
d4476 1
a4476 1
					// Reduce transferred amount by corrupt amount
d4489 1
a4489 1
			else if ( IsCorruptedPart(partNumber))
d4491 1
a4491 1
				// Try to recover with minimal loss
d4495 4
a4498 4
					FillGap(PARTSIZE*partNumber,(PARTSIZE*partNumber+partRange));
					RemoveBlockFromList(PARTSIZE*partNumber,(PARTSIZE*partNumber + partRange));
					AddLogLine(true, IDS_ICHWORKED, partNumber,GetFileName());
					// BavarianSnail - add info to stats
d4502 1
a4502 1
			// Any parts other than last must be full size
d4506 1
a4506 1
		// Update met file
d4509 1
a4509 1
		// Is this file finished?
d4513 1
a4513 1
	catch (CFileException* error)
d4518 1
a4518 1
			Beep(800,200);
d4527 1
a4527 1
			// Purity - Sending message for insufficient diskspace
d4538 1
a4538 1
        PauseFile();
d4541 1
a4541 1
	catch(...)
d4552 2
a4553 2
// Barry - This will invert the gap list, up to caller to delete gaps when done
// 'Gaps' returned are really the filled areas, and guaranteed to be in order
d4558 2
a4559 2
	Gap_Struct *gap = NULL;
	Gap_Struct *best=NULL;
d4564 1
a4564 1
	// Loop until done
d4569 1
a4569 1
		// Find first gap after current start pos
d4586 1
a4586 1
			// Invert this gap
d4604 2
a4605 1
void CPartFile::UpdateFileRatingCommentAvail() {
d4608 2
a4609 1
	if (!this) return;
d4611 1
a4611 1
	bool prev=(hasComment || hasRating);
d4613 2
a4614 2
	hasComment=false;
	hasRating=false;
d4616 2
a4617 2
	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) 
d4619 1
a4619 1
			for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d4623 5
a4627 5
				if (cur_src->GetFileComment().GetLength()>0) 
					hasComment=true;
				if (cur_src->GetFileRating() != PF_RATING_NONE) 
					hasRating=true;
				if (hasComment && hasRating) 
d4631 1
a4631 1
	// #zegzav:pastcomment (BEGIN)
d4634 2
a4635 2
		// past comments
		for (pos1= m_pastCommentList.GetHeadPosition(); pos1 != 0;)
d4637 1
a4637 1
			CPastComment &pc= m_pastCommentList.GetNext(pos1);
d4639 1
a4639 1
				hasComment=true;
d4641 1
a4641 1
				hasRating=true;
d4646 1
a4646 1
	// #zegzav:pastcomment (END)
d4648 1
a4648 1
	if (prev != (hasComment || hasRating)) 
d4654 2
a4655 1
uint16 CPartFile::GetSourceCount() {
d4658 3
a4660 2
	uint16 count=0;
	for (int i=0;i<SOURCESSLOTS;i++) count+=m_srcLists[i].GetCount();
d4675 1
a4675 1
     int num,tot,fRate;  
d4677 1
a4677 1
     num=tot=0;  
d4679 1
a4679 1
     POSITION pos1,pos2;  
d4687 3
a4689 3
			for (pos1 = m_srcLists[sl].GetHeadPosition(); (pos2 = pos1) != NULL; )
			{  
				m_srcLists[sl].GetNext(pos1);  
d4691 1
a4691 1
				if (fRate>0)   
d4698 2
a4699 2
					tot+=fRate;
				}  
d4705 1
a4705 1
	for (pos1= m_pastCommentList.GetHeadPosition(); pos1 != 0;)	
d4707 1
a4707 1
		fRate= m_pastCommentList.GetNext(pos1).GetRating();
d4709 2
a4710 2
		if (fRate>0)   
		{  
d4712 1
a4712 1
               //Cax2 - bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
d4716 2
a4717 2
			tot+=fRate;  
		}  
d4723 1
a4723 1
		num = (float)tot/num+.5;	//Cax2 - get the average of all the ratings
d4727 2
a4728 2
	 }
     return static_cast<_EnumPartFileRating>(num);	//Cax2 - if no ratings found, will return 0!
d4730 1
a4730 1
	 EMULE_CATCH
d4732 1
a4732 1
	 return PF_RATING_NONE;
d4736 1
a4736 1
//		'force' is true or if the redisplay timer has expired.
d4742 1
a4742 1
    DWORD curTick = ::GetTickCount();
d4744 1
a4744 1
    if (force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX))
d4748 1
a4748 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d4751 1
a4751 1
    }
d4753 1
a4753 1
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.PostMessage(WM_DL_UPDATEFILEITEM,0,reinterpret_cast<LPARAM>(this));
d4759 1
a4759 1
// START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d4761 1
a4761 1
void CPartFile::AddClientSource(CClientSource* source, int i_Source, bool exchanged, uint8 sourceexchangeversion) 
d4765 1
a4765 1
	// check first if we are this source
d4767 2
a4768 1
	if (g_eMuleApp.m_pServerConnect->GetClientID() < 16777216 && g_eMuleApp.m_pServerConnect->IsConnected()) {
d4770 3
a4772 3
			return;
		// although we are currently having a LowID, we could have had a HighID before, which
		// that client is sending us now! seems unlikely ... it happend!
d4774 1
a4774 1
			return;
d4777 2
a4778 2
		return;
	// Modified by Tarod -use LowID source only if source is in our same server
d4780 1
a4780 1
		return;
d4782 9
a4790 8
	
	// eklmn: optimization: create source only if we need to do it
	if( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFile() > GetSourceCount()
		&& i_Source < (int)g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft()) // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
	{ 
		CUpDownClient* newsource = new CUpDownClient(source->sourcePort,source->sourceID,source->serverIP,source->serverPort,this);
		if (exchanged) {
			//Cax2 - exchanged sources are named now
d4792 1
a4792 1
			// check exchange version
d4796 2
a4797 2
		g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(this,newsource);
	} 
d4803 2
a4804 1
void CPartFile::AddClientSources(CTypedPtrList<CPtrList, CClientSource*>* sources){
d4808 4
a4811 3
	pos=sources->GetHeadPosition();
	while (pos!=NULL) {
		CClientSource* source=(CClientSource*)sources->GetAt(pos);  
d4813 2
a4814 1
		if (source->sourceType != ED2KLINK_SOURCE_IP) {
d4819 1
a4819 1
		POSITION removePos=pos;
d4830 1
a4830 1
// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d4832 1
a4832 1
// START - enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d4838 32
a4869 22
	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!m_srcLists[sl].IsEmpty())
		for (pos1 = m_srcLists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			m_srcLists[sl].GetNext(pos1);
			CUpDownClient* cur_src = m_srcLists[sl].GetAt(pos2);
		if (cur_src->HasLowID())
			continue;
		if (srcstoadd.IsEmpty()) {
			srcstoadd.AddHead(cur_src);
			continue;
		}
		if ((sourcenum == 0) || (srcstoadd.GetCount() < sourcenum) || (cur_src->GetAvailablePartCount() > srcstoadd.GetTail()->GetAvailablePartCount())) {
			if ((sourcenum != 0) && (srcstoadd.GetCount() == sourcenum))
				srcstoadd.RemoveTail();
			ASSERT(srcstoadd.GetCount() < sourcenum);
			bool bInserted = false;
			for (POSITION pos2 = srcstoadd.GetTailPosition();pos2 != 0;srcstoadd.GetPrev(pos2)){
				CUpDownClient* cur_srctoadd = srcstoadd.GetAt(pos2);
				if (cur_srctoadd->GetAvailablePartCount() > cur_src->GetAvailablePartCount()) {
					srcstoadd.InsertAfter(pos2, cur_src);
					bInserted = true;
					break;
a4871 4
			if (!bInserted)
				srcstoadd.AddHead(cur_src);
		}
	}
d4873 2
a4874 1
	if (srcstoadd.IsEmpty() && (!g_eMuleApp.m_pServerConnect->IsConnected() || g_eMuleApp.m_pServerConnect->IsLowID())){
d4882 2
a4883 1
	else {
d4889 1
a4889 1
	}  
d4892 1
d4895 1
d4897 6
a4902 6
	strLink.Format(_T("ed2k://|file|%s|%d|%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x|/|sources%s"),
		g_eMuleApp.StripInvalidFilenameChars(GetFileName(), false), // spaces to dots
		GetFileSize(),
		GetFileHash()[0],GetFileHash()[1],GetFileHash()[2],GetFileHash()[3],GetFileHash()[4],GetFileHash()[5],GetFileHash()[6],GetFileHash()[7],
		GetFileHash()[8],GetFileHash()[9],GetFileHash()[10],GetFileHash()[11],GetFileHash()[12],GetFileHash()[13],GetFileHash()[14],GetFileHash()[15],
		strExpiration);
d4904 3
a4906 2
	if (dwID >= 16777216) {
		newsource.Format(_T(",%i.%i.%i.%i:%i"),(uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), g_eMuleApp.m_pGlobPrefs->GetPort());
d4910 3
a4912 2
	while (!srcstoadd.IsEmpty()) {
		CUpDownClient* cur_src = srcstoadd.RemoveHead();
d4914 1
a4914 1
		newsource.Format(_T(",%s:%i"),cur_src->GetFullIP(), cur_src->GetUserPort());
d4924 1
a4924 1
// END - enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d4926 3
a4928 2
// START - enkeyDEV(Ottavio84) -ChangeDir-
void CPartFile::SetAlternativeOutputDir(CString* path) {
d4942 2
a4943 2
	CString		strRetPath = g_eMuleApp.m_pGlobPrefs->GetIncomingDir();
	CString		strCatPath;
d4959 2
a4960 2
//		with a single call to PathFileExists(). Somebody just thought they were more
//		clever than they were methinks.
d4963 4
a4966 4
//		of IShellFolder type and DeskTop always exists
	IShellFolder	*pDesktop	=	NULL;
	ITEMIDLIST		*pList	=	NULL;
	CString			strDir;
d4971 2
a4972 2
		IShellFolder	*pFolder = NULL;
		ULONG			uAttrib	=	SFGAO_FOLDER ; //we're going to look for the "folder" attribute
d4975 3
a4977 3
	//	"ParseDisplayName" uses UNICODE so BSTR will go 
	//		We have to remember to release it
		BSTR		pData	=	strDir.AllocSysString();
d4981 2
a4982 2
		//	'm_strAlternativePath' is always created without "\" but this was the way 
		//	the original code was, maybe it was for a reason :) , so I am going to leave 
d4986 1
a4986 1
			pDesktop->ParseDisplayName(NULL,NULL,pData,NULL,&pList,&uAttrib);
d4999 1
a4999 1
					uAttrib	=	SFGAO_FOLDER ;
d5001 1
a5001 1
					pDesktop->ParseDisplayName(NULL,NULL,pData,NULL,&pList,&uAttrib);
d5019 2
a5020 2
					  pos != 0;
					  g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos) )
d5048 1
a5048 1
//	Default return 
d5060 1
a5060 1
	compl.Format(_T("%s/%s"),CastItoXBytes(GetCompletedSize()),CastItoXBytes(GetFileSize()));
d5063 1
a5063 1
	if (lastseencomplete==NULL)
d5069 1
a5069 1
	if (GetTransferred()==0 /*SyruS won't work: GetFileDate()==NULL*/)
d5075 2
a5076 1
	if(GetPartCount() != 0) {
d5082 1
a5082 1
// BavarianSnail - added detailed source infos
d5084 19
a5102 19
	compl2.Format(_T("%s%s"),GetTempDir(),GetPartMetFileName());	
	
	sRet.Format(GetResString(IDS_DL_FILENAME)+_T(": %s (%s)\n\n%s\n\n")
		+GetResString(IDS_FD_HASH) +_T(" %s\n")
		+GetResString(IDS_PARTINFOS)
		+GetResString(IDS_PARTINFOS2)+_T("\n%s\n%s\n")
		+GetResString(IDS_PARTINFOS3),
		GetFileName(), CastItoXBytes(GetFileSize()),
				GetResString(IDS_STATUS)+_T(": ")+GetPartfileStatus(),
				strHash,
				compl2, GetPartCount(),GetResString(IDS_AVAIL),GetAvailablePartCount(),availability,
				(int)GetPercentCompleted(), compl, GetTransferringSrcCount(),
				GetResString(IDS_LASTSEENCOMPL)+_T(" ")+lsc,
                GetResString(IDS_FD_LASTCHANGE) +_T(" ")+lastprogr,
                GetOnQueueSrcCount(),
		GetNoNeededPartsSrcCount(),
		GetSrcA4AFCount(),
		GetConnectingSrcCount());
// -BavarianSnail          
d5111 1
a5111 1
	compl.Format(_T("%s/%s"),CastItoXBytes(GetCompletedSize()),CastItoXBytes(GetFileSize()));
d5114 1
a5114 1
	if (lastseencomplete==NULL)
d5120 1
a5120 1
	if (GetTransferred()==0)
d5126 2
a5127 1
	if(GetPartCount() != 0) {
d5130 1
a5130 1
	
d5132 5
a5136 4
	if(GetTransferringSrcCount() > 0)
		sTransfSrcCount.Format(GetResString(IDS_TT_PARTINFOS3),GetTransferringSrcCount());
	
	CString strHash = EncodeBase16(GetFileHash(), 16);;
d5140 21
a5160 21
	sRet.Format(GetResString(IDS_TT_FILENAME)
			+GetResString(IDS_TT_PARTINFOS2)
			+GetResString(IDS_TT_STATUS)
//			+GetResString(IDS_TT_DATE)
			+GetResString(IDS_TT_HASH)
			+GetResString(IDS_TT_PARTINFOS)
			+GetResString(IDS_TT_PARTINFOS4)
			+GetResString(IDS_TT_LASTSEENCOMPL)
			+GetResString(IDS_TT_LASTCHANGE)
			+GetResString(IDS_TT_STATUS2), //<= TEMPORARY
			GetFileName(),CastItoXBytes(GetFileSize()),GetFileSize(),GetResString(IDS_BYTES),
			(int)GetPercentCompleted(),	compl, sTransfSrcCount,
			GetPartfileStatus(),
//			t.Format("%A, %B %d, %Y"),
			strHash,
			GetPartMetFileName(),GetPartCount(),GetResString(IDS_AVAIL),GetAvailablePartCount(),availability,
			lsc,lastprogr,
			GetOnQueueSrcCount(),
			GetNoNeededPartsSrcCount(),
			GetSrcA4AFCount(),
			GetConnectingSrcCount() );
d5166 3
a5168 2
// Ornis: Creating progressive presentation of the partfilestatuses - for webdisplay
CString CPartFile::GetProgressString(uint16 size){
d5171 1
a5171 1
	char crProgress = '0';//green
d5173 3
a5175 3
	char crPending='2';	// yellow
	//Ju1i3n Start - merged with eMulePlus by janes bong
	char crMissing='3';  // red
d5177 11
a5187 7
	crWaiting[0]='4'; // blue few source
	crWaiting[1]='5';
	crWaiting[2]='6';
	crWaiting[3]='7';
	crWaiting[4]='8';
	crWaiting[5]='9';
	//Ju1i3n End
d5189 3
a5191 2
	CString my_ChunkBar=_T("");
	for (uint16 i=0;i<=size+1;i++) my_ChunkBar.AppendChar(crHave);	// one more for safety
d5193 5
a5197 3
	uint32 m_nFileSize=GetFileSize();
	float unit= (float)size/(float)m_nFileSize;
	uint32 allgaps = 0;
d5199 24
a5222 24
	if(GetStatus() == PS_COMPLETE || GetStatus() == PS_COMPLETING) {
		CharFillRange(&my_ChunkBar,0,(float)m_nFileSize*unit, crProgress);
	} else

	// red gaps
	for (POSITION pos = gaplist.GetHeadPosition();pos !=  0;gaplist.GetNext(pos)){
		Gap_Struct* cur_gap = gaplist.GetAt(pos);
		allgaps += cur_gap->end - cur_gap->start;
		bool gapdone = false;
		uint32 gapstart = cur_gap->start;
		uint32 gapend = cur_gap->end;
		for (uint32 i = 0; i != GetPartCount(); i++){
			if (gapstart >= i*PARTSIZE && gapstart <=  (i+1)*PARTSIZE){ // is in this part?
				if (gapend <= (i+1)*PARTSIZE)
					gapdone = true;
				else{
					gapend = (i+1)*PARTSIZE; // and next part
				}
				// paint
				uint8 color;
				if (m_srcPartFrequencies.GetCount() >= (INT_PTR)i && m_srcPartFrequencies[i])  // frequency?
					color = m_srcPartFrequencies[i] <  10 ? crWaiting[m_srcPartFrequencies[i]/2]:crWaiting[5];	//Ju1i3n - merged with eMulePlus by janes bong
				else
					color = crMissing;
d5224 1
a5224 1
				CharFillRange(&my_ChunkBar,(float)gapstart*unit, (float)gapend*unit + 1,  color);
d5226 7
a5232 5
				if (gapdone) // finished?
					break;
				else{
					gapstart = gapend;
					gapend = cur_gap->end;
a5235 1
	}
d5237 2
a5238 2
	// yellow pending parts
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos !=  0;requestedblocks_list.GetNext(pos))
d5240 2
a5241 2
		Requested_Block_Struct* block =  requestedblocks_list.GetAt(pos);
		CharFillRange(&my_ChunkBar, (float)(block->StartOffset + block->transferred)*unit, (float)block->EndOffset*unit,  crPending);
d5251 2
a5252 1
void CPartFile::CharFillRange(CString* buffer,float start, float end, char color) {
d5254 2
a5255 2
	for (uint32 i=start;i<=end;i++)
		buffer->SetAt(i,color);
d5264 1
a5264 1
	//AddDebugLogLine(false, _T("Total %u A4AF sources before swap"), m_A4AFsrcList.GetCount());
d5266 1
a5266 1
	// Make a list of sources
d5268 2
a5269 1
	for (POSITION pos =  m_A4AFsrcList.GetHeadPosition(); pos != 0; m_A4AFsrcList.GetNext(pos)) {
d5273 3
a5275 3
	// Actually handover
	for(int i = 0; i < SourcesList.GetCount(); i++)
		SourcesList[i]->SwapToAnotherFile(this);	
d5281 2
a5282 1
void CPartFile::AddDownloadingSource(CUpDownClient* client){
d5285 2
a5286 1
	if (pos == NULL){
d5292 2
a5293 1
void CPartFile::RemoveDownloadingSource(CUpDownClient* client){
d5296 2
a5297 1
	if(pos != NULL){
d5305 2
a5306 1
uint8* CPartFile::MMCreatePartStatus(){
d5308 5
a5312 4
	// create partstatus + info in mobilemule protocol specs
	// result needs to be deleted[] | slow, but not timecritical
	uint8* result = new uint8[GetPartCount()+1];
	for (int i = 0; i != GetPartCount(); i++){
d5314 2
a5315 1
		if (IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1)){
d5319 3
a5321 2
		else{
			if (IsComplete(i*PARTSIZE + (0*(PARTSIZE/3)), ((i*PARTSIZE)+(1*(PARTSIZE/3)))-1))
d5323 1
a5323 1
			if (IsComplete(i*PARTSIZE+ (1*(PARTSIZE/3)), ((i*PARTSIZE)+(2*(PARTSIZE/3)))-1))
d5325 1
a5325 1
			if (IsComplete(i*PARTSIZE+ (2*(PARTSIZE/3)), ((i*PARTSIZE)+(3*(PARTSIZE/3)))-1))
d5330 1
a5330 1
			freq = ceilf((float)freq/3);
d5341 1
a5341 1
// #zegzav:pastcomment (BEGIN)
d5346 1
a5346 1
		return;
d5349 1
a5349 1
		return;
d5359 1
a5359 1
		return;
d5363 2
a5364 2
		CString					strPastComment;
		EnumPartFileRating		ePastRating;
d5367 2
a5368 2
		  && (pClient->GetFileComment().IsEmpty())
		  && (pClient->GetFileRating() == PF_RATING_NONE) )
d5379 1
a5379 1
// #zegzav:pastcomment (END)
d5381 1
a5381 1
uint8 CPartFile::GetCatID() const
d5383 5
a5387 5
//	If catID is valid... (valid range is 1..CAT_PREDEFINED-1 but a 
//		real check would have to scan the category map. This isn't the
//		best place to do that.
	if (m_iCategoryID >= CAT_PREDEFINED)
		return 0;
d5389 1
a5389 1
		return m_iCategoryID;
d5392 1
a5392 1
void CPartFile::SetCatID(uint8 iCatID)
d5394 3
a5396 3
	m_iCategoryID = iCatID;
	
	// set new prio
d5399 1
a5399 1
		int		iPriority = 0;
d5401 1
a5401 1
		if (iCatID != 0)
d5407 28
a5434 18
		case 0:
			break;
		case 1:
			SetAutoPriority(false);
			SetPriority(PR_LOW);
			break;
		case 2:
			SetAutoPriority(false);
			SetPriority(PR_NORMAL);
			break;
		case 3:
			SetAutoPriority(false);
			SetPriority(PR_HIGH);
			break;
		case 4:
			SetAutoPriority(true);
			SetPriority(PR_HIGH);
			break;
d5443 1
a5443 1
	m_eStatus=in;
d5445 1
a5445 1
	uint8		curCat = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.GetCurTabCat();
d5447 2
a5448 2
	if (curCat >= CAT_PREDEFINED)
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.ChangeCategoryByID(curCat);
d5453 1
a5453 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateCatTabTitles();
d5463 2
a5464 2
	//	If WARN_PERIOD_OF_NO_PROGRESS days have gone by without a single download...
	//		(??? or maybe sooner if there are no needed parts available?)
d5472 1
a5472 1
//  It uses a thread to let eMule still work and not drop sources while generating the file.
d5491 1
a5491 1
//  It receives a pointer to 'm_hPartFile' and the filesize-1 (where it has to write the bogus data to allocate space.
d5494 1
a5494 1
	PAThreadParam *tp = (PAThreadParam*)lpParameter;
d5509 2
a5510 1
	if(a == 0) a = EMBLOCKSIZE;
@


1.272
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d190 1
a190 1
	m_iRate=0;
d590 1
a590 1
	switch (status){
d763 1
a763 1
		if (status == PS_COMPLETING)
d1122 1
a1122 1
	if(status == PS_COMPLETE || status == PS_COMPLETING) {
d1150 1
a1150 1
					if(status == PS_EMPTY || status == PS_READY)
d1386 1
a1386 1
uint8 CPartFile::GetStatus(bool ignorepause)
d1390 2
a1391 2
	if (!m_bPaused || status == PS_STOPPED || status == PS_ERROR || status == PS_COMPLETING || status == PS_COMPLETE || ignorepause)
		return status;
d3101 1
a3101 1
	if (status==PS_COMPLETE || status==PS_COMPLETING)
d3167 1
a3167 1
	if (status==PS_COMPLETE || status==PS_COMPLETING)
d3218 1
a3218 1
	if (status==PS_COMPLETE || status==PS_COMPLETING) return;
d3415 1
a3415 1
		if (status == PS_COMPLETING || status == PS_COMPLETE)
d4193 1
a4193 1
					if (status == PS_EMPTY)
d4334 1
a4334 1
				if (cur_src->GetFileRate()>0) 
d4349 1
a4349 1
			if (pc.GetRate() > 0)
d4397 1
a4397 1
				fRate =((CUpDownClient*) m_srcLists[sl].GetAt(pos2))->GetFileRate();  
d4414 1
a4414 1
		fRate= m_pastCommentList.GetNext(pos1).GetRate();
d4435 1
a4435 1
     return static_cast<EnumPartFileRating>(num);	//Cax2 - if no ratings found, will return 0!
d5015 1
a5015 1
	if ((pClient->GetFileComment().IsEmpty()) && (pClient->GetFileRate() == 0))
d5018 1
a5018 1
	m_pastCommentList.Add(pClient->GetUserHash(), pClient->GetUserName(), GetFileName(), pClient->GetFileComment(), pClient->GetFileRate());
d5030 6
a5035 4
		CString strPastComment;
		int8 nPastRate;
		if ((m_pastCommentList.GetCommentRate(pClient->GetUserHash(), &strPastComment, &nPastRate)) &&
			(pClient->GetFileComment().IsEmpty()) && (pClient->GetFileRate() == 0))
d5037 1
a5037 1
			// restore past comment
d5039 1
a5039 1
			pClient->SetFileRate(nPastRate);
d5098 1
a5098 1
void CPartFile::SetStatus(uint8 in)
d5100 1
a5100 1
	status=in;
@


1.271
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d303 1
a303 1
		g_eMuleApp.m_pdlgEmule->m_wndSharedFiles.sharedfilesctrl.UpdateItem((CKnownFile*)this);
d320 1
a320 1

a817 1
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
a1863 1
			//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
a1996 1
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d4358 1
a4358 1
		UpdateDisplayedInfo();//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d4448 1
d4459 3
@


1.270
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d3115 1
a3115 1
	Packet* packet = new Packet(OP_CANCELTRANSFER,0);
d3176 1
a3176 1
	Packet* packet = new Packet(OP_CANCELTRANSFER,0);
@


1.269
log
@Updates
@
text
@d68 1
a68 1
				CTag* newtag = new CTag(*searchresult->m_tagArray[i]);
d274 1
a274 1
	CTag* partnametag = new CTag(FT_PARTFILENAME,buffer);	
d357 1
a357 1
			CTag* newtag = new CTag(file);
d642 8
a649 8
		CTag nametag(FT_FILENAME,m_strFileName);
		nametag.WriteTagToFile(file);		
		CTag sizetag(FT_FILESIZE,m_lFileSize);
		sizetag.WriteTagToFile(file);		
		CTag transtag(FT_TRANSFERRED,transferred);
		transtag.WriteTagToFile(file);		
		CTag statustag(FT_STATUS,(m_bPaused)? 1:0);
		statustag.WriteTagToFile(file);		
d656 2
a657 2
		CTag prioritytag(FT_PRIORITY,priority_value);
		prioritytag.WriteTagToFile(file);		
d659 2
a660 2
		CTag lsctag(FT_LASTSEENCOMPLETE,lsc);
		lsctag.WriteTagToFile(file);		
d668 2
a669 2
		CTag ulprioritytag(FT_ULPRIORITY,ulpriority_value);
		ulprioritytag.WriteTagToFile(file);
d671 2
a672 2
		CTag categorytag(FT_CATEGORY, m_iCategoryID);
		categorytag.WriteTagToFile(file);
d676 1
a676 1
			m_tagArray[j]->WriteTagToFile(file);
d684 2
a685 2
			CTag gapstarttag(namebuffer,gaplist.GetAt(pos)->start);
			gapstarttag.WriteTagToFile(file);
d689 2
a690 2
			CTag gapendtag(namebuffer,(gaplist.GetAt(pos)->end)+1);
			gapendtag.WriteTagToFile(file);			
d1843 2
a1844 2
			md4cpy(packet->pBuffer,m_fileHash);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadServer(packet->size);
d3120 1
a3120 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d3185 1
a3185 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);
d3667 1
a3667 1
	result->opcode = OP_ANSWERSOURCES;
@


1.268
log
@Formatting, comments, and name changes.
@
text
@d599 2
a600 4
		CString bakname;
		CString strTempPath = RemoveFileExtension(fullname);
		bakname.Format(_T("%s\\%s.bak"), strTempPath, GetPartMetFileName());
		::CopyFile(fullname, bakname, FALSE);
d2597 3
a2599 3
	CString settingsFile = CString(RemoveFileExtension(fullname)) + CString(".settings");
	if (_tremove(settingsFile) && errno != ENOENT)
		AddLogLine(true, IDS_ERR_DELETEFAILED, settingsFile);
d2744 3
a2746 3
	CString settingsFile = CString(RemoveFileExtension(fullname)) + CString(".settings");
	if (_tremove(settingsFile) && errno != ENOENT)
		AddLogLine(true, IDS_ERR_DELETEFAILED, settingsFile);
d3947 1
a3947 1
	CString strIniPath = RemoveFileExtension(fullname);
d3949 1
a3949 1
	if(PathFileExists(strIniPath + CString(".settings")))
d3951 1
a3951 1
   		CIni filesettings(strIniPath + CString(".settings"));
d3971 1
a3971 1
	CString strIniPath = RemoveFileExtension(fullname);
d3973 1
a3973 1
   	CIni filesettings(strIniPath + CString(".settings"));
@


1.267
log
@added source details to webserver tooltips - asked by netwolf
@
text
@d74 1
a74 1
		hashsetneeded = false;
d123 1
a123 1
			hashsetneeded = false;
d179 1
a179 1
	hashsetneeded = true;
d213 1
a213 1
	m_LastDownTransfer = CTime::GetCurrentTime();
d215 1
a215 1
	m_SessionStartTime = m_LastDownTransfer;
d245 1
a245 1
	m_SrcpartFrequency.RemoveAll();
d289 1
a289 1
	m_SrcpartFrequency.SetSize(partCount);
d293 1
a293 1
		m_SrcpartFrequency.Add(0);
d309 1
a309 1
		hashsetneeded = false;
d523 1
a523 1
	m_SrcpartFrequency.SetSize(partCount);
d527 1
a527 1
		m_SrcpartFrequency.Add(0);
d538 1
a538 1
		hashsetneeded = true;
d542 1
a542 1
		hashsetneeded = false;
d560 1
a560 1
        m_LastDownTransfer = filestatus.m_mtime;
d1150 1
a1150 1
				if (m_SrcpartFrequency.GetCount() >= (INT_PTR)i && m_SrcpartFrequency[i])  // frequency? 
d1155 1
a1155 1
								    (210-(22*(m_SrcpartFrequency[(uint16)i]-1)) <  0)? 0:210-(22*(m_SrcpartFrequency[(uint16)i]-1))
d1159 1
a1159 1
									(210-(22*(m_SrcpartFrequency[(uint16)i]-1)) <  0)? 0:255-(22*(m_SrcpartFrequency[(uint16)i]-1))
d1334 4
a1337 4
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1355 4
a1358 4
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1376 4
a1379 4
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1441 4
a1444 4
    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition(); (pos2 = pos1) != NULL && removed < number_sources_to_remove;) {
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1493 1
a1493 1
	 sockets_usage_high = g_eMuleApp.m_pListenSocket->GetOpenSockets() > (g_eMuleApp.m_pGlobPrefs->GetMaxConnections() * 0.75);
d1552 1
a1552 1
			if (!srclists[sl].IsEmpty())
d1554 1
a1554 1
				for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d1556 2
a1557 2
					srclists[sl].GetNext(pos1);
					cur_src = srclists[sl].GetAt(pos2);
d1789 1
a1789 1
		m_iSrcA4AF =			A4AF_srclist.GetCount();
d1800 2
a1801 2
				if (!srclists[sl].IsEmpty())
					for (pos1 = srclists[sl].GetHeadPosition(); (pos2 = pos1 ) != NULL;) 
d1803 2
a1804 2
						srclists[sl].GetNext(pos1);
						cur_src = srclists[sl].GetAt(pos2);
d1821 1
a1821 1
		if (!A4AF_srclist.IsEmpty() && g_eMuleApp.m_pDownloadQueue->GetA4AFAutoFile() == this) 
d1824 1
a1824 1
			for (pos1 = A4AF_srclist.GetHeadPosition(); (pos2 = pos1 ) != NULL;)
d1826 2
a1827 2
				A4AF_srclist.GetNext(pos1);
				cur_src = A4AF_srclist.GetAt(pos2);
d1968 2
a1969 2
	if(m_SrcpartFrequency.GetSize() < iPartCount){
		m_SrcpartFrequency.SetSize(iPartCount);
d1973 1
a1973 1
		m_SrcpartFrequency[i] = 0;
d1983 4
a1986 4
		if (!srclists[sl].IsEmpty()) {
			for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
				srclists[sl].GetNext(pos1);
				cur_src = srclists[sl].GetAt(pos2);
d1993 1
a1993 1
						m_SrcpartFrequency[i] +=1;
d2005 1
a2005 1
		if (m_SrcpartFrequency[i] > m_MaxSrcPartFrequency) m_MaxSrcPartFrequency = m_SrcpartFrequency[i];
d2098 1
a2098 1
			if (m_SrcpartFrequency[i] == 1) {
d2109 1
a2109 1
			if (median >= (uRarestPart + m_SrcpartFrequency[i]) ) {
d2111 1
a2111 1
					for (int j=0; j < (median-m_SrcpartFrequency[i]+1); j++)  liRarestParts.AddHead(i);
d2148 1
a2148 1
				for (int j=0; j < (m_MaxSrcPartFrequency-m_SrcpartFrequency[i]+1); j++)
d2685 1
a2685 1
		while (!srclists[sl].IsEmpty())
d2687 1
a2687 1
			cur_source = srclists[sl].GetHead();
d2701 1
a2701 1
	if (!A4AF_srclist.IsEmpty()) 
d2703 1
a2703 1
		for (pos1 = A4AF_srclist.GetHeadPosition(); (pos2 = pos1 ) != NULL;)
d2705 2
a2706 2
			A4AF_srclist.GetNext(pos1);
			cur_source = A4AF_srclist.GetAt(pos2);
d2775 1
a2775 1
		this->hashsetneeded = true;
d2781 1
a2781 1
		this->hashsetneeded = true;
d3017 3
a3019 3
	if (IsMovie() && ((m_SrcpartFrequency[oldchunk] > raremovie
    	&& m_SrcpartFrequency[newchunk] > raremovie)      //old & new chunk are nonrare
    	|| (m_SrcpartFrequency[oldchunk] == m_SrcpartFrequency[newchunk]) //old & new chunk are same rare
d3195 4
a3198 4
		if (!srclists[sl].IsEmpty()) {
			for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ) {
				srclists[sl].GetNext(pos1);
				CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d3589 2
a3590 2
		if (!srclists[sl].IsEmpty())
			for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d3593 2
a3594 2
				srclists[sl].GetNext(pos1);
				cur_src = srclists[sl].GetAt(pos2);
d4081 1
a4081 1
	m_LastDownTransfer = CTime::GetCurrentTime();
d4103 1
a4103 1
	m_LastDownTransfer = CTime::GetCurrentTime();
d4226 1
a4226 1
		if (gaplist.IsEmpty() && !hashsetneeded) // SLUGFILLER: hashlistRecheck - can't complete without a hashset...
d4332 2
a4333 2
		if (!srclists[sl].IsEmpty())
			for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d4335 2
a4336 2
				srclists[sl].GetNext(pos1);
				CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d4349 1
a4349 1
		for (pos1= m_PastComment.GetHeadPosition(); pos1 != 0;)
d4351 1
a4351 1
			CPastComment &pc= m_PastComment.GetNext(pos1);
d4372 1
a4372 1
	for (int i=0;i<SOURCESSLOTS;i++) count+=srclists[i].GetCount();
d4397 1
a4397 1
		if (!srclists[sl].IsEmpty())
d4399 1
a4399 1
			for (pos1 = srclists[sl].GetHeadPosition(); (pos2 = pos1) != NULL; )
d4401 2
a4402 2
				srclists[sl].GetNext(pos1);  
				fRate =((CUpDownClient*) srclists[sl].GetAt(pos2))->GetFileRate();  
d4417 1
a4417 1
	for (pos1= m_PastComment.GetHeadPosition(); pos1 != 0;)	
d4419 1
a4419 1
		fRate= m_PastComment.GetNext(pos1).GetRate();
d4542 4
a4545 4
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d4898 2
a4899 2
				if (m_SrcpartFrequency.GetCount() >= (INT_PTR)i && m_SrcpartFrequency[i])  // frequency?
					color = m_SrcpartFrequency[i] <  10 ? crWaiting[m_SrcpartFrequency[i]/2]:crWaiting[5];	//Ju1i3n - merged with eMulePlus by janes bong
d4941 1
a4941 1
	//AddDebugLogLine(false, _T("Total %u A4AF sources before swap"), A4AF_srclist.GetCount());
d4945 2
a4946 2
	for (POSITION pos =  A4AF_srclist.GetHeadPosition(); pos != 0; A4AF_srclist.GetNext(pos)) {
		SourcesList.Add(A4AF_srclist.GetAt(pos));
d4995 1
a4995 1
			uint8 freq = (uint8)m_SrcpartFrequency[i];
d5019 1
a5019 1
	m_PastComment.Add(pClient->GetUserHash(), pClient->GetUserName(), GetFileName(), pClient->GetFileComment(), pClient->GetFileRate());
d5033 1
a5033 1
		if ((m_PastComment.GetCommentRate(pClient->GetUserHash(), &strPastComment, &nPastRate)) &&
d5042 1
a5042 1
	m_PastComment.Remove(pClient->GetUserHash());
@


1.266
log
@Localization and some fixes for new detail dialogs by FoRcHa
@
text
@d4771 3
d4777 3
a4779 2
		+GetResString(IDS_PARTINFOS)+
		GetResString(IDS_PARTINFOS2)+_T("\n%s\n%s"),
d4783 1
a4783 1
				GetPartMetFileName(), GetPartCount(),GetResString(IDS_AVAIL),GetAvailablePartCount(),availability,
d4786 6
a4791 1
                GetResString(IDS_FD_LASTCHANGE) +_T(" ")+lastprogr);
@


1.265
log
@Formatting, comments, and name changes.
@
text
@d600 2
a601 1
		bakname.Format(_T("%s\\%s.bak"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), GetPartMetFileName());
@


1.264
log
@Minor fix
@
text
@d5118 1
a5118 1
//  It uses a thread to let eMule still work and don't drop sources while generating the file.
d5136 2
a5137 2
//	AllocateNeededSpaceProc(LPVOID lpParameter) is the thread created by AllocateNeededSpace().
//  It receives a pointer to m_hPartFile and the filezise-1 (where it has to write the bogus data to allocate space.
d5160 1
@


1.263
log
@Code formatting and fixes for preallocation (statistics)
@
text
@d5157 1
a5157 1
	return IsComplete(m_lFileSize - 1 - a, m_lFileSize - 1);
@


1.262
log
@Minor fixes and new log message
@
text
@d222 1
d352 1
a352 1
		LoadFileSettings(); // DonGato - Moview Preview Mode
d397 1
a397 1
					LoadFileSettings(); //DonGato: stopped knowledge between sessions
d3161 1
a3161 1
	SaveFileSettings(); //DonGato: stopped knowledge between sessions
d3212 1
a3212 1
	SaveFileSettings(); //DonGato: stopped knowledge between sessions
d3246 1
a3246 1
	SaveFileSettings(); //DonGato: stopped knowledge between sessions
d3942 3
a3944 3

// DonGato - Movie Preview Mode
void CPartFile::LoadFileSettings()
d3948 1
a3948 1
	CString sIniPath = RemoveFileExtension(fullname);
d3950 1
a3950 1
	if(PathFileExists(sIniPath + CString(".settings")))
d3952 1
a3952 1
   		CIni filesettings(sIniPath + CString(".settings"));
d3959 1
d3966 3
a3968 2

void CPartFile::SaveFileSettings()
d3972 1
a3972 1
	CString sIniPath = RemoveFileExtension(fullname);
d3974 1
a3974 1
   	CIni filesettings(sIniPath + CString(".settings"));
d3980 1
d5117 2
a5118 1
//	AllocateNeededSpace() is the preallocate function used to allocate the space needed by a file
a5120 7
/*
	uint32 iPosition = m_lFileSize - 1;

	m_hPartFile.Seek(lenData, CFile::begin);
	m_hPartFile.Write("1", 1);
	m_hPartFile.Flush();
*/
d5123 1
d5132 2
d5136 2
a5137 1
//	AllocateNeededSpaceProc(LPVOID lpParameter) is the thread created by AllocateNeededSpace()
d5151 1
a5151 1
//	IsLastBlockComplete() returns status of last block of file (if downloaded all file was preallocated)
d5156 2
a5157 2
	
	return IsComplete(m_lFileSize - a, m_lFileSize);
a5159 1

@


1.261
log
@Formatting, comments, and name changes.
@
text
@d2550 1
a2550 1
			MessageText.Format(GetResString(IDS_ERR_COMPLETIONFAILED) + _T(" ") + GetFileName());
d2563 1
a2563 1
			MessageText.Format(GetResString(IDS_ERR_COMPLETIONFAILED) + _T(" ") + GetFileName());
d4233 3
d4237 1
d4240 1
a4240 1
			MessageText.Format(GetResString(IDS_ERR_OUTOFSPACE) + _T(" ") + GetFileName());
@


1.260
log
@Preallocate feature and Localization fixes
@
text
@d5153 2
@


1.259
log
@removal of previous code change
@
text
@d5109 44
@


1.258
log
@ace and xvid added.
@
text
@d3079 1
a3079 2
		return ((extension.CompareNoCase(".ace") == 0) || (extension.CompareNoCase(".rar") == 0)
				|| (extension.CompareNoCase(".zip") == 0));
@


1.257
log
@Final code merge from official for preview
@
text
@d3079 3
a3081 2
		return ((extension.CompareNoCase(".zip") == 0) || (extension.CompareNoCase(".rar") == 0));
	
@


1.256
log
@Fix for Category dir removal before complete

MSG: commit form before was for Initialize feature and first part of Preview update
@
text
@d841 2
a842 2
				return false;	
			}
d2829 2
a2830 2
	//Cax2 - simplified things a bit
	return (IsAviMovie()||IsMpgMovie());
d2856 1
a2856 6
	if(IsVLCInstalled())
	{
		return (_tcsstr(fname,_T(".mpg")) || _tcsstr(fname,_T(".mpe")) || _tcsstr(fname,_T(".dat")) || _tcsstr(fname,_T(".bin")));
	} else {
		return (_tcsstr(fname,_T(".mpg")) || _tcsstr(fname,_T(".mpe")) || _tcsstr(fname,_T(".dat")));
	}
d3072 1
a3072 1
bool CPartFile::IsArchive()
d3074 2
d3077 9
a3085 1
	return ((extension.CompareNoCase(_T(".zip")) == 0) || (extension.CompareNoCase(_T(".rar")) == 0));
d3445 1
a3445 1
	if (IsArchive())
a3453 1
		ASSERT( false );
d3457 2
a3458 1
	if (g_eMuleApp.m_pGlobPrefs->BackupPreview()) {
d3461 1
a3461 1
		pThread->SetValues(this);
d3463 3
a3465 1
	} else {
d3468 2
a3473 4
			if (player.Find(_T("vlc.exe")))
				strLine.Replace(_T(".met"),_T(""));
			TCHAR shortPath[512]; //Cax2 short path for vlc
			GetShortPathName(strLine,shortPath,512);
d3477 1
a3477 1
			ShellExecute(NULL, _T("open"),player, shortPath, runDir, SW_SHOWNORMAL);
a3483 8
bool CPartFile::FirstLastLoaded()
{
	bool first = (IsComplete(0,(MINFIRSTMOVIESIZE)-1));
	//Cax2 - we "have" the last chunk (i.e. we don't care about it) if we're previewing using vlc, or if we have an mpeg
	bool last = IsVLCInstalled() || IsMpgMovie() || (IsComplete((GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1 ));
	return (first && last);
}

d3487 2
a3488 14
	//Cax2 - this would stop people from previewing almost complete movies
	//if vlan is previewing the file, the file *will not* be transferred 
	//to the incoming directory on completion, and emule will display an error message.
	//commented it out, to let our users do as they please!!!
	/*
	if ( gaplist.GetCount() <= 1 )
	{
		return false;
	}
	*/
	uint64 buf1,buf2,space;
	space = 0;
	GetDiskFreeSpaceEx(m_strTempDir,(PULARGE_INTEGER)&space,(PULARGE_INTEGER)&buf1,(PULARGE_INTEGER)&buf2);
	// Barry - Allow preview of archives of any length > 1k
d3493 2
a3494 14
	if (IsArchive()) //before checking IsMovie!
		return (GetFileSize() > 1024 && !m_bRecoveringArchive && (space + 100000000) > (2*GetFileSize()));

	if (!IsMovie())
		return false;

	//Vorlost
	char buffer[200] = "";	//used for feedback in debug log
	bool first = (IsComplete(0,(MINFIRSTMOVIESIZE)-1));
	//Cax2 - we "have" the last chunk (i.e. we don't care about it) if we're previewing using vlc, or if we have an mpeg
	bool last = IsVLCInstalled() || IsMpgMovie() || (IsComplete((GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1 ));

	//let's build that string...
 	if (!first)
d3496 4
a3499 12
   		strcat(buffer,"first ");
   		if (!last)
			strcat(buffer,"& last ");
  	}
  	else if (!last)
		strcat(buffer," last ");

	if (!first || !last) //they sould "be" both there for a preview
	{
		strcat(buffer,"movie block(s) not downloaded yet");
		AddDebugLogLine(false,_T("Movie preview: %s"),buffer);
		return false; 
d3502 1
a3502 3
	if (space < (GetFileSize() + 100000000)  && g_eMuleApp.m_pGlobPrefs->BackupPreview())		//Cax2 - now the logic makes sense: allow for an extra 100mb on top of the film preview.
	{
		AddDebugLogLine(false,_T("Movie preview: too little space on disk to enable preview."));
a3503 1
	}
d3505 5
a3509 1
	if ( m_bPreviewing)
d3511 2
a3512 5
		AddDebugLogLine(false,_T("Movie preview: only one preview at a time!"));
		return false;
	}
	return true;
	//End of Patch by Vorlost 
d3514 10
a3523 1
	EMULE_CATCH
d3525 5
a3529 2
	return false;
}
d3531 9
a3539 3
/*
void CPartFile::UpdateAvailablePartsCount(){
	EMULE_TRY
d3541 11
a3551 13
	uint8 availablecounter = 0;
	bool breakflag = false;
	uint16 iPartCount = GetPartCount();
	for (uint32 ixPart = 0; ixPart < iPartCount; ixPart++){
		breakflag = false;
		for (uint32 sl = 0; sl < SOURCESSLOTS && !breakflag; sl++){
			if (!srclists[sl].IsEmpty()){
				for(POSITION pos = srclists[sl].GetHeadPosition(); pos && !breakflag; ){
					if (srclists[sl].GetNext(pos)->IsPartAvailable(ixPart)){ 
						availablecounter++; 
						breakflag = true;
					}
				}
d3553 7
a3561 4
	if (iPartCount == availablecounter && availablePartsCount < iPartCount)
		lastseencomplete = CTime::GetCurrentTime();
	availablePartsCount = availablecounter;
	m_bUpdateCompleteSrcCount= true;	// netwolf: zegzav:completesrc
d3564 2
a3566 1
*/
a3894 15

bool CPartFile::IsVLCInstalled() 
{ 
	EMULE_TRY
	CString player=g_eMuleApp.m_pGlobPrefs->GetVideoPlayer();
	if (player.Find(_T("vlc.exe"))>=0)
	{
		CFileFind ff;
		return ff.FindFile(player,0);
	}

	EMULE_CATCH

	return false;
}	
@


1.255
log
@Formatting, comments, and name changes.
@
text
@d2453 3
@


1.254
log
@Formatting, comments, and name changes.
@
text
@d125 1
a125 1
		if (!g_eMuleApp.m_pDownloadQueue->IsFileExisting(m_fileHash))
d2643 1
a2643 1
    	g_eMuleApp.m_pDownloadQueue->StartPausedDownload(catID); 
@


1.253
log
@1) an incorrect use of GDI resources (CBrush class)
2) ICR update to v2.11 (change the way of chunk blocking)
@
text
@d223 1
a223 1
	//eklmn: it's need to initialize this varibale to prevent extra screen refreshing
d447 1
a447 1
					f.ReadString(m_alternativepath);
d695 1
a695 1
		if (!m_alternativepath.IsEmpty()) {
d699 1
a699 1
				f.WriteString((LPCTSTR)m_alternativepath);
a2450 1
#ifndef LATER
a2451 22
#else
	CString		indir;

	indir = GetOutputDir();
	if (indir != "")
	{
		newname.Format(_T("%s\\%s"),indir, g_eMuleApp.StripInvalidFilenameChars(GetFileName()));
	}
	else
	{
		if (PathFileExists(CCat::GetCatByID(GetCatID())->GetPath()))
		{
			indir=CCat::GetCatByID(GetCatID())->GetPath();
			newname.Format(_T("%s\\%s"),indir,partfilename);
		}
		else
		{
			indir=g_eMuleApp.m_pGlobPrefs->GetIncomingDir();
			newname.Format(_T("%s\\%s"),indir,partfilename);
		}
	}
#endif LATER
d3379 2
a3380 2

sint32 CPartFile::GetTimeRemaining(bool bAvgerage /*=false*/)
d3384 5
a3388 4
	uint32 DataRate = 0;
	sint32 timeRemaining = -1;
	if (bAvgerage)
		DataRate = GetAvgDataRate();
d3390 3
a3392 3
		DataRate = GetDataRate();
	timeRemaining = (DataRate > 0 ? (GetFileSize()-GetCompletedSize()) / DataRate : -1);
	return ((timeRemaining > 0 && timeRemaining <= 8640000) ? timeRemaining : -1);
a3400 1
//bond006 (smoothed "remaining time" calculation) //SyruS
d3407 1
a3407 1
		CTimeSpan timespan;
d3411 3
a3413 1
			timespan = GetFlushTimeSpan();
d3415 4
a3418 1
			timespan = GetSessionTimeSpan();
d3421 1
a3421 1
		uint32 seconds = timespan.GetTotalSeconds();
d3423 2
a3424 2
		if (seconds > 10)
			m_AvgDataRate = ( (GetSessionTransferred() /*+ GetDataRate()*/) / (seconds /*+ 1*/) );
d4642 1
a4642 1
	m_alternativepath = *path;
d4646 4
a4649 2

CString CPartFile::GetOutputDir() {
d4652 2
a4653 2
	CString retpath = g_eMuleApp.m_pGlobPrefs->GetIncomingDir();
	CString catpath;
d4656 4
a4659 3
		catpath = CCat::GetCatByID(GetCatID())->GetPath();
	// If no alternative path defined
	if ( m_alternativepath.IsEmpty() )
d4662 2
a4663 2
		if(catpath != "")
			return catpath; // Return the category dir
d4665 1
a4665 1
			return retpath;	// Return the incoming dir.
a4666 19
	// we going to use desktop folder "static" functions , we need an object
	// of IShellFolder type and DeskTop always exists
	IShellFolder *pDesktop	=	NULL;
	ITEMIDLIST *pList	=	NULL;
	CString dir;
	// Try to create DeskTop folder object
	if ( SHGetDesktopFolder(&pDesktop) == NOERROR )
	{
		IShellFolder *pFolder = NULL;
		ULONG	uAttrib	=	SFGAO_FOLDER ; //we going to look for "folder" attribute
		dir = m_alternativepath;
		// "ParseDisplayName" uses UNICODE so BSTR will go 
		// We have not to forget to release it
		BSTR pData	=	dir.AllocSysString();
		if ( pData )
		{
			// The "alternativepath" always created without "\" but this was the way 
			// in original code , may be it was for a reason :) , so I am going to leave 
			// first check without addin "\" as well ...
d4668 28
a4695 1
			// So here we convert "display name" (path string) into ID list used by Shell
d4697 1
a4697 1
			// Release the BSTR
d4699 2
a4700 2
			// If list we got is null then no such object exists
			if ( !pList )
d4702 5
a4706 5
				// Add "\" to get folder name
				dir	 +=  _T("\\");
				// allocate new search BSTR
				pData	=	dir.AllocSysString();
				if ( pData )
d4708 1
a4708 1
					//we going to look for "folder" attribute
d4710 1
a4710 1
					// we convert "display name" (path string) into ID list used by Shell
d4712 1
a4712 1
					// Release the BSTR
d4716 2
a4717 2
			// If we found the object and it's "folder" type
			if ( pList  && (uAttrib	& SFGAO_FOLDER) )
d4719 3
a4721 2
				LPMALLOC ppMalloc;
				if(SHGetMalloc(&ppMalloc) == NOERROR)
d4726 14
a4739 5

				for (POSITION pos = g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetHeadPosition();pos != 0;g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetNext(pos))
					if (g_eMuleApp.m_pGlobPrefs->m_sharedDirList.GetAt(pos) == dir)
						return m_alternativepath;
				g_eMuleApp.m_pGlobPrefs->m_sharedDirList.AddTail(dir);
d4741 1
a4741 1
				return m_alternativepath;
d4743 1
a4743 1
			// Just in case the object is not folder we have to release memory
d4746 3
a4748 2
				LPMALLOC ppMalloc;
				if(SHGetMalloc(&ppMalloc) == NOERROR)
d4758 3
a4760 4
	// default return 

	retpath.TrimRight(_T("\\"));
	return retpath;
d4766 1
a4766 2
// END - enkeyDEV(Ottavio84) -ChangeDir-

@


1.252
log
@fix for errors on removing a file when no space on Temp disk (#0000284)
fix for queue filtering (forgot that the list is updated :P)
@
text
@d223 3
d1242 1
a1242 1
      	s_LoadBar.Draw(dc, gaprect.left, gaprect.top, false); 
d1247 1
d1252 3
a1254 1
      		dc->FillRect(&gaprect, &CBrush(crProgress)); 
d1259 3
a1261 1
		dc->FillRect(&gaprect, &CBrush(crPending));
d1266 5
a1270 1
      		dc->FillRect(&gaprect, &CBrush(RGB(224,224,224)));
d2017 1
a2017 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.10, 3.07.2003) for eMule+
d2066 1
a2066 4
		// scan for blocked part
		if (m_BlockedParts[i] != NULL && m_BlockedParts[i]->GetDownloadState() == DS_DOWNLOADING)
			i_CurBlockedParts++;
		else
d2070 12
d2215 1
a2215 1
			m_BlockedParts[goodpart] = sender;
d2223 1
a2223 1
			m_BlockedParts[goodpart] = sender;
@


1.251
log
@localized the new line in the tooltips
@
text
@d221 1
d231 2
a232 1
	FlushBuffer();
d234 1
a234 1
	if (m_hPartFile.m_hFile != INVALID_HANDLE_VALUE)
d309 2
a310 1
	if (g_eMuleApp.m_pGlobPrefs->GetAutoFilenameCleanup()) SetFileName( CleanupFilename(GetFileName()).GetBuffer() );
d615 2
a616 1
		_tremove(backupName);
d705 2
a706 1
		_tremove(backupName);
a1060 1
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d2585 4
a2588 5
	// START - enkeyDEV(Ottavio84) -ChangeDir-
	CString dirFile = CString(fullname) + CString(".dir") ;
	if (_tremove(dirFile)) if (errno != ENOENT)
		AddLogLine(true, IDS_ERROR_DELETE, dirFile);
	// END - enkeyDEV(Ottavio84) -ChangeDir-
a2589 3
	// netwolf - remove .txtscr file
	m_sourcesaver.DeleteFile(this); //<<-- enkeyDEV(Ottavio84) -New SLS-
	
d2591 3
a2593 1
 	CString srcName=_T("");
d2595 4
a2598 4
	srcName.Format(_T("%s\\%s.bak"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), GetPartMetFileName());
	if (_tremove(srcName))
		if (errno != ENOENT)
			AddLogLine(true, IDS_FAILDELETE,srcName);
d2600 2
a2601 5
	// DonGato - remove .settings file
	srcName.Format(_T("%s.settings"), RemoveFileExtension(fullname));
	if (_tremove(srcName))
		if (errno != ENOENT)
			AddLogLine(true, IDS_FAILDELETE,srcName);
d2606 2
a2607 2
	//--- :xrmb ---
    
d2609 1
a2609 4
    
	// START - enkeyDEV(Ottavio84) -ChangeDir-
	directory = GetOutputDir();
	// END - enkeyDEV(Ottavio84) -ChangeDir-
d2619 1
a2619 1
    if (renamed) 
d2717 2
d2721 3
a2723 1
	if (m_hPartFile.m_hFile != INVALID_HANDLE_VALUE) m_hPartFile.Close(); // m_hPartFile isn't the handle to the file...
d2726 2
a2727 1
		AddLogLine(true, IDS_ERR_DELETE, fullname);
d2730 1
a2730 1
		AddLogLine(true, IDS_ERR_DELETE, partfilename);
d2732 2
a2733 2
	// START - enkeyDEV(Ottavio84) -ChangeDir-
	CString dirFile = CString(fullname) + CString(".dir") ;
d2735 1
a2735 10
		AddLogLine(true, IDS_FAILDELETE, dirFile);
	// END - enkeyDEV(Ottavio84) -ChangeDir-

	// remove *.src file (thx to brotbuexe)
	CString srcName=_T("");
	/*
	srcName.Format(_T("%s\\%s.stsrc"),m_strTempDir,m_strPartMetFileName);
	if (_tremove(srcName) && errno != ENOENT) 
			AddLogLine(true, IDS_FAILDELETE, srcName);
	*/
d2738 3
a2740 3
	srcName.Format(_T("%s\\%s.bak"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), m_strPartMetFileName);
	if (_tremove(srcName) && errno != ENOENT)
			AddLogLine(true, IDS_FAILDELETE, srcName);
d2743 3
a2745 3
	srcName.Format(_T("%s.settings"), RemoveFileExtension(fullname));
	if (_tremove(srcName) && errno != ENOENT)
			AddLogLine(true, IDS_FAILDELETE, srcName);
d2748 1
a2748 1
	m_sourcesaver.DeleteFile(this); //<<-- enkeyDEV(Ottavio84) -New SLS-
d2754 1
a3087 1
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d3149 2
a3150 2
	FlushBuffer();
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d3152 2
a3153 1
	SavePartFile();
d3203 2
a3204 1
	SavePartFile();
a3239 1
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
d3873 1
a3873 1
int CPartFile::RemovePartFileStats()
d3875 5
a3879 2
	EMULE_TRY	
	return _tremove(GetStatsFullPath());
a3880 2

	return 0;
d4254 2
a4255 1
		if (g_eMuleApp.m_pGlobPrefs->IsErrorBeepEnabled()) Beep(800,200);
d4257 1
a4257 1
		if (error->m_cause == CFileException::diskFull) 
a4270 8
        /*
		m_bPaused = true;
		m_dataRate = 0;
		m_iNumTransferringSrcs = 0;
	
		//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
		UpdateDisplayedInfo();
        */
d4275 1
a4275 1
	{		
@


1.250
log
@Formatting, comments, and name changes.
@
text
@d4837 1
a4837 1
			+_T("<br><b>Sources:<t=5></b>On Queue: %3d, NNP: %3d, A4AF: %3d, Connecting: %3d"), //<= TEMPORARY
@


1.249
log
@Wrong file commited before. Sorry!
@
text
@d2753 1
a2753 1
			AddLogLine(true, IDS_FAILDELETE,srcName);
@


1.248
log
@Fixed user name on Chat tabs, localized times and fixed removal of .settings file
@
text
@d2599 1
a2599 1
	srcName.Format(_T("%s\\%s.settings"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), RemoveFileExtension(fullname));
d2751 1
a2751 1
	srcName.Format(_T("%s\\%s.settings"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), RemoveFileExtension(fullname));
@


1.247
log
@Formatting, comments, and name changes.
Hacked in source stats in the file tooltip.
@
text
@d2598 2
a2599 2
	// DonGato - remove .movie file
	srcName.Format(_T("%s\\%s.movie"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), GetPartMetFileName());
d2750 2
a2751 2
	// DonGato - remove .movie file
	srcName.Format(_T("%s\\%s.movie"), g_eMuleApp.m_pGlobPrefs->GetTempDir(), m_strPartMetFileName);
d2753 1
a2753 1
			AddLogLine(true, IDS_FAILDELETE, srcName);
@


1.246
log
@Fixed "Active status tab doesn't update properly."
Fixed a NEW_SOCKETS compiler warning.
@
text
@d1445 7
a1451 7
	DWORD dwCurTick = ::GetTickCount();
	CUpDownClient* cur_src;
	bool sockets_usage_high;
	bool bIsClientConnected;
	bool bReaskDownload;
	POSITION pos1, pos2;
	uint32 cur_dataRate;
d3984 1
a3984 1
	   	
d4004 1
a4004 1
   	
d4766 1
a4766 1
		lsc = localelastseencomplete();	// netwolf 13.05.03 use local date/time format
d4772 1
a4772 1
		lastprogr = localelastdowntransfer();	// netwolf 13.05.03 use local date/time format
d4807 1
a4807 1
		lsc = localelastseencomplete();	// netwolf 13.05.03 use local date/time format
d4813 1
a4813 1
		lastprogr = localelastdowntransfer();	// netwolf 13.05.03 use local date/time format
d4836 2
a4837 1
			+GetResString(IDS_TT_LASTCHANGE),
d4844 5
a4848 1
			lsc,lastprogr);
@


1.245
log
@fix for signed/unsigned mismatch
@
text
@d1444 1
d1857 4
a1860 2
	// DonGato: for category filters
	if (GetTransferringSrcCount() != nOldTransSourceCount)
d4615 1
a4615 1
	uint32 dwID;
@


1.244
log
@Changed .movie files to .settings and added stopped status knowledge
@
text
@d3790 1
a3790 1
int CPartFile::GetCommonFilePenalty() {
@


1.243
log
@Category rewrite with predefined status/media type categories.
@
text
@d345 1
a345 1
		LoadMovieMode(); // DonGato - Moview Preview Mode
d390 1
a390 1
					m_bStopped = m_bPaused;
d3158 1
d3203 1
d3208 1
d3242 1
d3972 1
a3972 1
void CPartFile::LoadMovieMode()
d3976 1
a3976 4
   	CIni pvmoviefile(CString(fullname) + CString(".movie"));
	pvmoviefile.SetDefaultCategory(_T("MoviePreview"));
   	uint8 Mode = pvmoviefile.GetInt(_T("Mode"), 0); 
	CKnownFile::SetMovieMode(Mode);
d3978 9
a3986 2
	pvmoviefile.SetDefaultCategory(_T("DownloadSettings"));
    m_bDiscardSuperCompressed = pvmoviefile.GetBool(_T("DiscardSuperCompressed"),false);
d3988 2
a3989 1
	pvmoviefile.CloseWithoutSave();
d3994 1
a3994 1
void CPartFile::SaveMovieMode()
d3998 1
a3998 3
   	CIni pvmoviefile(CString(fullname) + CString(".movie"));
	pvmoviefile.SetDefaultCategory(_T("MoviePreview"));
	pvmoviefile.SetInt(_T("Mode"), ((CKnownFile*)this)->GetMovieMode()); 
d4000 6
a4005 2
	pvmoviefile.SetDefaultCategory(_T("DownloadSettings"));
    pvmoviefile.SetBool(_T("DiscardSuperCompressed"),m_bDiscardSuperCompressed);
d4007 1
a4007 1
	pvmoviefile.SaveAndClose();
@


1.242
log
@Formatting, comments, and name changes.
Modified WriteToBuffer() to update the "last down time" every time data is written (not just when the buffer is flushed). Fixed a bug (that I introduced) into GetRating(). Fixed a bug in IsStalled() where it wasn't returning "true" until 7 days and 1 hr rather than at 7 days. (obaldin's bug).
@
text
@d219 2
a220 1
	m_iCategory = 0;
d407 1
a407 1
					m_iCategory = newtag->GetIntValue();
d664 1
a664 1
		CTag categorytag(FT_CATEGORY, m_iCategory);
d1859 7
a1865 2
		if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.m_nCurTab==0)
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.ChangeCategory(0); 
d1870 1
a1870 1
		if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfos())
d2314 4
d2353 1
a2353 1
	if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfos())
d2405 1
a2405 1
	int cat = GetCategory();
d2423 1
d2425 22
d2646 1
a2646 1
    	g_eMuleApp.m_pDownloadQueue->StartPausedDownload(cat); 
d4647 1
a4647 1
	CString catpath = g_eMuleApp.m_pGlobPrefs->GetCategory(GetCategory())->incomingpath;
d4649 2
d4654 1
d4658 1
a4658 1
			return retpath; // Return the incoming dir
d5028 2
a5029 2

int CPartFile::GetCategory()
d5031 7
a5037 4
	if(m_iCategory > g_eMuleApp.m_pGlobPrefs->GetCatCount()-1)
		m_iCategory = 0;

	return m_iCategory;
d5039 2
a5040 2

void CPartFile::SetCategory(int iCategory)
d5042 1
a5042 1
	m_iCategory = iCategory;
d5047 7
a5053 1
		switch (g_eMuleApp.m_pGlobPrefs->GetCategory(GetCategory())->prio)
d5083 8
a5090 6
		if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.m_nCurTab==0)
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.ChangeCategory(0); 
		else
			UpdateDisplayedInfo(true);
		
		if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfos())
@


1.241
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d57 2
a58 2
	for (int i = 0; i != searchresult->taglist.GetCount();i++){
		switch (searchresult->taglist[i]->GetSpecialTag()){
d60 1
a60 1
				m_strFileName = searchresult->taglist[i]->GetStringValue();
d64 1
a64 1
				m_lFileSize = searchresult->taglist[i]->GetIntValue();
d68 2
a69 2
				CTag* newtag = new CTag(*searchresult->taglist[i]);
				taglist.Add(newtag);
d268 1
a268 1
	taglist.Add(partnametag);
d433 1
a433 1
						taglist.Add(newtag);
d525 2
a526 2
	CSingleLock Lock(&m_hashlistMutex,TRUE);
	INT_PTR iSize = hashlist.GetCount();
d553 1
a553 1
		if (date != mktime(filestatus.m_mtime.GetLocalTm())){
d605 1
a605 1
		date = mktime(lwtime.GetLocalTm());
d622 1
a622 1
		fwrite(&date,4,1,file);
d625 2
a626 2
		CSingleLock Lock(&m_hashlistMutex,TRUE);
		uint16 parts = hashlist.GetCount();
d629 1
a629 1
			fwrite(hashlist[x],16,1,file);
d632 1
a632 1
		uint32 tagcount = taglist.GetCount()+8+(gaplist.GetCount()*2);
d667 2
a668 2
		for (uint32 j = 0; j != taglist.GetCount();j++)
			taglist[j]->WriteTagToFile(file);
d735 2
a736 2
	CSingleLock Lock(&m_hashlistMutex,TRUE);
	INT_PTR hashSize = hashlist.GetSize();
d2539 1
a2539 1
		date = st.st_mtime;
d4061 2
d4376 1
a4376 1
	//	For each source slot...
d4378 4
a4381 2
		//	If the slot isn't empty...
		if (!srclists[sl].IsEmpty())  
d4384 6
a4389 6
          srclists[sl].GetNext(pos1);  
          fRate =((CUpDownClient*) srclists[sl].GetAt(pos2))->GetFileRate();  
          if (fRate>0)   
          {  
               num++;
			   //Cax2 - bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
a4391 2
          }  
     }  
d4393 14
a4406 8
     // #zegzav:pastcomment (BEGIN)
     for (pos1= m_PastComment.GetHeadPosition(); pos1 != 0;)	
     {
          fRate= m_PastComment.GetNext(pos1).GetRate();

          if (fRate>0)   
          {  
               num++;
a4409 4
               tot+=fRate;  
          }  
     }
	// #zegzav:pastcomment (END)
d4411 9
a4419 4
	 if (num>0)
	 {
		 num=(float)tot/num+.5;	//Cax2 - get the average of all the ratings
	 	//Cax2 - bugfix: for some $%#ing reason good=3 & fair=4, breaking the progression from fake(1) to excellent(5)
d5056 1
a5056 1
	if (ts.GetTotalHours() > 24 * WARN_PERIOD_OF_NO_PROGRESS)
@


1.240
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d2626 2
a2627 2
		for (POSITION pos = g_eMuleApp.m_pGlobPrefs->shareddir_list.GetHeadPosition();pos != 0;g_eMuleApp.m_pGlobPrefs->shareddir_list.GetNext(pos))
			if (g_eMuleApp.m_pGlobPrefs->shareddir_list.GetAt(pos) == (directory + "\\"))
d2629 1
a2629 1
		g_eMuleApp.m_pGlobPrefs->shareddir_list.AddTail(directory + "\\");
d4666 2
a4667 2
				for (POSITION pos = g_eMuleApp.m_pGlobPrefs->shareddir_list.GetHeadPosition();pos != 0;g_eMuleApp.m_pGlobPrefs->shareddir_list.GetNext(pos))
					if (g_eMuleApp.m_pGlobPrefs->shareddir_list.GetAt(pos) == dir)
d4669 1
a4669 1
				g_eMuleApp.m_pGlobPrefs->shareddir_list.AddTail(dir);
@


1.239
log
@Reinstated the transferring source count => Bad download state detection. Refixed GetStatus() (my booboo). Removed 'srcsarevisible'.
@
text
@a55 1
	#ifndef AMD
a56 3
	#else
	memcpy_amd(m_fileHash,searchresult->GetFileHash(),16);
	#endif
d124 1
a124 5
		#ifndef AMD
		memcpy(m_fileHash,fileLink->GetHashKey(),sizeof(m_fileHash));
		#else
		memcpy_amd(m_fileHash,fileLink->GetHashKey(),sizeof(m_fileHash));
		#endif
a939 1
				#ifndef AMD
a940 3
				#else
				memcpy_amd(result->FileID, GetFileHash(), 16);
				#endif
a1004 1
				#ifndef AMD
a1005 3
				#else
				memcpy_amd(block->FileID, GetFileHash(), 16);
				#endif
a1824 1
			#ifndef AMD
a1825 3
			#else
			memcpy_amd(packet->pBuffer,m_fileHash,16);
			#endif
d4008 1
a4008 5
	#ifndef AMD
	memcpy(buffer, data, lenData);
	#else
	memcpy_amd(buffer, data, lenData);
	#endif
@


1.238
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d168 1
a168 1
	srcarevisible = false;
d1393 4
d1398 1
d1492 2
d1503 1
d3124 1
d3190 1
@


1.237
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d133 1
a133 1
		if (!theApp.downloadqueue->IsFileExisting(m_fileHash))
d213 1
a213 1
	if (theApp.glob_prefs->IsDAPEnabled())
d259 1
a259 1
	m_strTempDir = theApp.glob_prefs->GetTempDir();	// added by InterCeptor (multiple tempdirs) 19.11.02
d301 1
a301 1
	if (theApp.glob_prefs->IsUAPEnabled()) {
d304 1
a304 1
		theApp.emuledlg->sharedfileswnd.sharedfilesctrl.UpdateItem((CKnownFile*)this);
d314 1
a314 1
	if (theApp.glob_prefs->GetAutoFilenameCleanup()) SetFileName( CleanupFilename(GetFileName()).GetBuffer() );
d565 1
a565 1
		    CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
d600 1
a600 1
		bakname.Format(_T("%s\\%s.bak"), theApp.glob_prefs->GetTempDir(), GetPartMetFileName());
d726 1
a726 1
//	if ( !theApp.emuledlg->IsRunning() )
d780 1
a780 1
	theApp.sharedfiles->SafeAddKFile(this);
d817 1
a817 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d1071 1
a1071 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d1439 1
a1439 1
			theApp.downloadqueue->RemoveSource(cur_src);
d1465 1
d1469 1
a1469 1
		theApp.emuledlg->AddLogLine(true, _T("Process: Throttling download to %ld%%"),reducedownload);
d1472 1
d1475 1
a1475 1
	if ((m_nTotalBufferData > ((uint32)theApp.glob_prefs->GetFileBufferSize())*30000) 
d1484 1
a1484 1
	 sockets_usage_high = theApp.listensocket->GetOpenSockets() > (theApp.glob_prefs->GetMaxConnections() * 0.75);
d1613 1
a1613 1
								theApp.downloadqueue->RemoveSource(cur_src);
d1623 1
a1623 1
								&& (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) )
d1625 1
a1625 1
								theApp.downloadqueue->RemoveSource(cur_src);
d1630 1
a1630 1
							if (theApp.serverconnect->IsLowID())
d1637 1
a1637 1
								&& (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) )
d1640 1
a1640 1
									theApp.downloadqueue->RemoveSource(cur_src);
d1661 1
a1661 1
									&& (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) )
d1663 1
a1663 1
									theApp.downloadqueue->RemoveSource( cur_src );
d1669 2
a1670 2
							else if (theApp.glob_prefs->UseRemoteQueueLimit()
								&& (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetRemoteQueueLimit())) 
d1673 1
a1673 1
								theApp.downloadqueue->RemoveSource(cur_src);
d1698 1
a1698 1
								if (theApp.serverconnect->IsConnected() 
d1710 1
a1710 1
							if (theApp.serverconnect->IsConnected()
d1715 1
a1715 1
								&& !theApp.serverconnect->IsLowID())
d1741 1
a1741 1
					if (bReaskDownload && theApp.serverconnect->IsConnected())
d1797 1
a1797 1
							if (theApp.downloadqueue->GetA4AFAutoFile() == NULL)
d1800 1
a1800 1
							else if (theApp.downloadqueue->GetA4AFAutoFile() != this)
d1802 1
a1802 1
								cur_src->SwapToAnotherFile(theApp.downloadqueue->GetA4AFAutoFile());
d1809 1
a1809 1
		if (!A4AF_srclist.IsEmpty() && theApp.downloadqueue->GetA4AFAutoFile() == this) 
d1823 1
a1823 1
		//uint16 test = theApp.glob_prefs->GetMaxSourcePerFileSoft();
d1827 2
a1828 2
			&& theApp.serverconnect->IsConnected()
			&& theApp.glob_prefs->GetMaxSourcePerFileSoft() > GetSourceCount() )
d1838 2
a1839 2
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
			theApp.serverconnect->SendPacket(packet,true);
d1847 1
a1847 1
		if (iteration && theApp.glob_prefs->SLSEnable() && m_downloadingSourceList.IsEmpty() && theApp.serverconnect->IsConnected()) 
d1849 1
a1849 1
			m_sourcesaver.Process(this, theApp.glob_prefs->SLSMaxSourcesPerFile()); //<<-- enkeyDEV(Ottavio84) -New SLS-
d1859 1
a1859 1
			//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d1870 2
a1871 2
		if (theApp.emuledlg->transferwnd.m_wndDownloadList.m_nCurTab==0)
			theApp.emuledlg->transferwnd.m_wndDownloadList.ChangeCategory(0); 
d1876 2
a1877 2
		if (theApp.glob_prefs->ShowCatTabInfos())
			theApp.emuledlg->transferwnd.UpdateCatTabTitles();
d1902 1
a1902 1
//	if (theApp.glob_prefs->IsRemoveNNSEnabled())
d1906 1
a1906 1
	    if (source_count_plus_new > theApp.glob_prefs->GetMaxSourcePerFile()
d1908 1
a1908 1
		    RemoveNoNeededSources(source_count_plus_new - theApp.glob_prefs->GetMaxSourcePerFile());
d1919 2
a1920 2
		if (theApp.serverconnect->GetClientID() < 16777216 && theApp.serverconnect->IsConnected()){
			if ((theApp.serverconnect->GetClientID() == userid) && inet_addr(theApp.serverconnect->GetCurrentServer()->GetFullIP()) == serverip)
d1923 1
a1923 1
		else if (theApp.serverconnect->GetClientID() == userid)
d1925 1
a1925 1
		else if (userid < 16777216 && !theApp.serverconnect->IsLocalServer(serverip,serverport)){
d1932 1
a1932 1
		if( theApp.glob_prefs->GetMaxSourcePerFile() > GetSourceCount() ){
d1935 1
a1935 1
			theApp.downloadqueue->CheckAndAddSource(this,newsource);
d1986 1
a1986 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d2333 1
a2333 1
														 THREAD_PRIORITY_BELOW_NORMAL+theApp.glob_prefs->GetMainProcessPriority(),
d2342 1
a2342 1
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC )CompleteThreadProc,this, THREAD_PRIORITY_BELOW_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
d2355 2
a2356 2
	if (theApp.glob_prefs->ShowCatTabInfos())
		theApp.emuledlg->transferwnd.UpdateCatTabTitles();
d2410 1
a2410 1
	while (theApp.uploadqueue->IsFileUploading(this) == true)
d2417 2
a2418 2
	theApp.glob_prefs->Add2LostFromCorruption(m_iLostDueToCorruption);
	theApp.glob_prefs->Add2SavedFromCompression(m_iGainDueToCompression);
d2425 1
a2425 1
	newname.Format(_T("%s\\%s"),GetOutputDir(), theApp.StripInvalidFilenameChars(GetFileName()));
d2446 2
a2447 2
	BOOL bSlowComplete   =   theApp.glob_prefs->SlowComplete();
	int  BlockSize   =   theApp.glob_prefs->SlowCompleteBlockSize()*1024; 
d2522 2
a2523 2
			theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnImportantError(), theApp.glob_prefs->IsSMTPWarningEnabled());
			theApp.emuledlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, theApp.glob_prefs->GetNotifierPopOnImportantError());
d2535 2
a2536 2
			theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnImportantError(), theApp.glob_prefs->IsSMTPWarningEnabled());
			theApp.emuledlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, theApp.glob_prefs->GetNotifierPopOnImportantError());
d2569 1
a2569 1
	srcName.Format(_T("%s\\%s.bak"), theApp.glob_prefs->GetTempDir(), GetPartMetFileName());
d2575 1
a2575 1
	srcName.Format(_T("%s\\%s.movie"), theApp.glob_prefs->GetTempDir(), GetPartMetFileName());
d2597 2
a2598 2
	theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetUseDownloadNotifier(), theApp.glob_prefs->IsSMTPInfoEnabled());
    theApp.emuledlg->ShowNotifier(MessageText, TBN_DLOAD, false, theApp.glob_prefs->GetUseDownloadNotifier()); 
d2601 1
a2601 1
    theApp.knownfiles->SafeAddKFile(this); 
d2611 1
a2611 1
    theApp.downloadqueue->RemoveFile(this); 
d2617 1
a2617 1
	theApp.mmserver->AddFinishedFile(this);
d2623 1
a2623 1
    if (theApp.glob_prefs->DownloadPausedOnComplete())
d2625 1
a2625 1
    	theApp.downloadqueue->StartPausedDownload(cat); 
d2629 3
a2631 3
	theApp.glob_prefs->Add2DownCompletedFiles();		// Increments cumDownCompletedFiles in prefs struct
	theApp.glob_prefs->Add2DownSessionCompletedFiles(); // Increments sesDownCompletedFiles in prefs struct
	theApp.glob_prefs->SaveCompletedDownloadsStat();	// Saves cumDownCompletedFiles to INI
d2636 1
a2636 1
	if (directory != theApp.glob_prefs->GetIncomingDir())
d2638 2
a2639 2
		for (POSITION pos = theApp.glob_prefs->shareddir_list.GetHeadPosition();pos != 0;theApp.glob_prefs->shareddir_list.GetNext(pos))
			if (theApp.glob_prefs->shareddir_list.GetAt(pos) == (directory + "\\"))
d2641 2
a2642 2
		theApp.glob_prefs->shareddir_list.AddTail(directory + "\\");
		theApp.sharedfiles->Reload();
d2668 1
a2668 1
					theApp.downloadqueue->RemoveSource(cur_source);
d2671 1
a2671 1
					theApp.emuledlg->transferwnd.m_wndDownloadList.RemoveSource(cur_source,this);
d2674 1
a2674 1
				theApp.downloadqueue->RemoveSource(cur_source);		
d2684 1
a2684 1
			theApp.emuledlg->transferwnd.m_wndDownloadList.RemoveSource(cur_source,this);
d2722 1
a2722 1
	srcName.Format(_T("%s\\%s.bak"), theApp.glob_prefs->GetTempDir(), m_strPartMetFileName);
d2727 1
a2727 1
	srcName.Format(_T("%s\\%s.movie"), theApp.glob_prefs->GetTempDir(), m_strPartMetFileName);
d2739 3
a2741 3
	theApp.sharedfiles->RemoveFile(this);
	theApp.downloadqueue->RemoveFile(this);
	theApp.emuledlg->transferwnd.m_wndDownloadList.RemoveFile(this);
d3070 2
a3071 2
	theApp.downloadqueue->SortByPriority();
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d3098 1
a3098 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d3107 2
a3108 2
	if (theApp.downloadqueue->GetA4AFAutoFile() == this)
		theApp.downloadqueue->SetA4AFAutoFile(NULL);
d3111 1
a3111 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.HideSources(this); // cax2 closefile bugfix
d3133 1
a3133 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d3160 1
a3160 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
d3216 1
a3216 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d3424 1
a3424 1
	if (theApp.glob_prefs->BackupPreview()) {
d3426 1
a3426 1
		CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
d3431 1
a3431 1
		CString player=theApp.glob_prefs->GetVideoPlayer();
d3508 1
a3508 1
	if (space < (GetFileSize() + 100000000)  && theApp.glob_prefs->BackupPreview())		//Cax2 - now the logic makes sense: allow for an extra 100mb on top of the film preview.
d3682 1
a3682 1
/*	if (theApp.glob_prefs->IsRemoveNNSEnabled())  //Vorlost added prefs question
d3687 1
a3687 1
	    if (source_count_plus_new > theApp.glob_prefs->GetMaxSourcePerFile()
d3690 1
a3690 1
		    RemoveNoNeededSources(source_count_plus_new - theApp.glob_prefs->GetMaxSourcePerFile());
d3706 1
a3706 1
		theApp.emuledlg->AddDebugLogLine(false, _T("Received invalid source exchange packet (v%u) of data size %u for %s\n"), sourceexchangeversion, uDataSize, GetFileName());
d3745 1
a3745 1
		CPartFile* partfile = theApp.downloadqueue->GetFileByID(GetFileHash()) ;
d3749 1
a3749 1
			if (valid_sources < theApp.glob_prefs->PriorityHigh() && priority != PR_HIGH)
d3751 1
a3751 1
			else if (valid_sources >= theApp.glob_prefs->PriorityHigh() && valid_sources < theApp.glob_prefs->PriorityLow() && priority != PR_NORMAL)
d3753 1
a3753 1
			else if (valid_sources >= theApp.glob_prefs->PriorityLow() && priority != PR_LOW)
d3865 1
a3865 1
	if ( theApp.glob_prefs->IsNTBased() )
d3867 1
a3867 1
		SetThreadLocale(theApp.glob_prefs->GetLanguageID());
d3886 1
a3886 1
	CString player=theApp.glob_prefs->GetVideoPlayer();
d4193 1
a4193 1
						theApp.sharedfiles->SafeAddKFile(this);
d4207 1
a4207 1
					theApp.glob_prefs->Add2SessionPartsSavedByICH();
d4225 1
a4225 1
		if (theApp.glob_prefs->IsErrorBeepEnabled()) Beep(800,200);
d4233 2
a4234 2
			theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopOnImportantError(), theApp.glob_prefs->IsSMTPWarningEnabled());
			theApp.emuledlg->ShowNotifier(MessageText, TBN_IMPORTANTEVENT, false, theApp.glob_prefs->GetNotifierPopOnImportantError());
d4246 1
a4246 1
		//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d4358 1
a4358 1
		UpdateDisplayedInfo();//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d4445 1
a4445 1
		if (theApp.emuledlg != NULL)
d4447 1
a4447 1
			theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d4463 2
a4464 2
	if (theApp.serverconnect->GetClientID() < 16777216 && theApp.serverconnect->IsConnected()) {
		if ((theApp.serverconnect->GetClientID() == source->sourceID) && theApp.serverconnect->GetCurrentServer()->GetIP() == source->serverIP)
d4468 1
a4468 1
		if (source->sourceID == theApp.serverconnect->GetLocalIP())
d4471 1
a4471 1
	else if (theApp.serverconnect->GetClientID() == source->sourceID)
d4474 1
a4474 1
	else if (source->sourceID < 16777216 && !theApp.serverconnect->IsLocalServer(source->serverIP, source->serverPort))
d4479 2
a4480 2
	if( theApp.glob_prefs->GetMaxSourcePerFile() > GetSourceCount()
		&& i_Source < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()) // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
d4490 1
a4490 1
		theApp.downloadqueue->CheckAndAddSource(this,newsource);
d4517 1
a4517 1
	theApp.downloadqueue->AddClientHostnameToResolve(sources);
d4558 1
a4558 1
	if (srcstoadd.IsEmpty() && (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID())){
d4575 1
a4575 1
	dwID = theApp.serverconnect->GetClientID();
d4579 1
a4579 1
		theApp.StripInvalidFilenameChars(GetFileName(), false), // spaces to dots
d4586 1
a4586 1
		newsource.Format(_T(",%i.%i.%i.%i:%i"),(uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), theApp.glob_prefs->GetPort());
d4618 2
a4619 2
	CString retpath = theApp.glob_prefs->GetIncomingDir();
	CString catpath = theApp.glob_prefs->GetCategory(GetCategory())->incomingpath;
d4645 1
a4645 1
			// The "m_alternativepath" always created without "\" but this was the way 
d4680 2
a4681 2
				for (POSITION pos = theApp.glob_prefs->shareddir_list.GetHeadPosition();pos != 0;theApp.glob_prefs->shareddir_list.GetNext(pos))
					if (theApp.glob_prefs->shareddir_list.GetAt(pos) == dir)
d4683 2
a4684 2
				theApp.glob_prefs->shareddir_list.AddTail(dir);
				theApp.sharedfiles->Reload();
d5000 1
a5000 1
	if(m_iCategory > theApp.glob_prefs->GetCatCount()-1)
d5013 1
a5013 1
		switch (theApp.glob_prefs->GetCategory(GetCategory())->prio)
d5043 2
a5044 2
		if (theApp.emuledlg->transferwnd.m_wndDownloadList.m_nCurTab==0)
			theApp.emuledlg->transferwnd.m_wndDownloadList.ChangeCategory(0); 
d5048 2
a5049 2
		if (theApp.glob_prefs->ShowCatTabInfos())
			theApp.emuledlg->transferwnd.UpdateCatTabTitles();
@


1.236
log
@number of ICH rescued files wasn't saved to ini (stats)
@
text
@d57 1
a57 1
	md4cpy(filehash,searchresult->GetFileHash());
d59 1
a59 1
	memcpy_amd(filehash,searchresult->GetFileHash(),16);
d64 1
a64 1
				filename = searchresult->taglist[i]->GetStringValue();
d68 1
a68 1
				filesize = searchresult->taglist[i]->GetIntValue();
d77 1
a77 1
	if (filesize < PARTSIZE)
d117 2
a118 2
		filename = CString( fileLink->GetName() );
		filesize = fileLink->GetSize();
d120 2
a121 2
		if( !filesize ) {
			AddLogLine( true, IDS_SKIPZEROLENGTHFILE, filename );
d126 1
a126 1
		if (filesize < PARTSIZE)
d129 1
a129 1
		memcpy(filehash,fileLink->GetHashKey(),sizeof(filehash));
d131 1
a131 1
		memcpy_amd(filehash,fileLink->GetHashKey(),sizeof(filehash));
d133 1
a133 1
		if (!theApp.downloadqueue->IsFileExisting(filehash))
d159 1
a159 1
	tempdir	=	"";	
d163 2
a164 2
	paused = false;
	stopped = false;
d166 1
a166 1
	transfered = 0;
d186 1
a186 1
	datarate = 0;
d190 1
a190 1
	partmetfilename = "";
d239 1
a239 1
	if (m_hpartfile.m_hFile != INVALID_HANDLE_VALUE)
d241 1
a241 1
		m_hpartfile.Close();
d259 4
a262 4
	tempdir = theApp.glob_prefs->GetTempDir();	// added by InterCeptor (multiple tempdirs) 19.11.02
	if (tempdir.Right(1) == '\\')
		tempdir.Truncate(tempdir.GetLength() - 1);	// added by InterCeptor (check for \\) 19.11.02
	directory = tempdir;	// #zegzav:vdir4list (OP_ASKSHAREDFILESDIR)
d264 1
a264 1
	CString filename; 
d268 1
a268 1
		filename.Format(_T("%s\\%03i.part"), tempdir, i); 
d270 1
a270 1
	}while(PathFileExists(filename)); 
d272 3
a274 3
	partmetfilename.Format(_T("%03i.part.met"),i); 	
	fullname.Format(_T("%s\\%s"),tempdir,partmetfilename);
	CString buffer = partmetfilename.Left(partmetfilename.GetLength() - 4);	
d280 1
a280 1
	gap->end = filesize-1;
d284 1
a284 1
	if (!m_hpartfile.Open(partfull,CFile::modeCreate|CFile::modeReadWrite|CFile::shareDenyWrite|CFile::osSequentialScan)){
d298 1
a298 1
	paused = false;
d309 1
a309 1
	if(filesize <= PARTSIZE )
d325 1
a325 1
	tempdir = in_directory;	// added by InterCeptor (multiple tempdirs) 19.11.02
d327 2
a328 2
	transfered = 0;
	partmetfilename = in_filename;
d333 1
a333 1
	fullname.Format(_T("%s\\%s"),directory,partmetfilename);
d338 1
a338 1
			AddLogLine(false, IDS_ERR_OPENMET, partmetfilename,filename);
d345 1
a345 1
			AddLogLine(false, IDS_ERR_BADMETVERSION,partmetfilename,filename);
d361 1
a361 1
						AddLogLine(true, IDS_ERR_METCORRUPT, partmetfilename,filename);
d365 1
a365 1
					filename = newtag->GetStringValue();
d375 1
a375 1
					filesize = newtag->GetIntValue();
d379 2
a380 2
				case FT_TRANSFERED:{
					transfered = newtag->GetIntValue();
d396 2
a397 1
					paused = newtag->GetIntValue();
d460 1
a460 1
			AddLogLine(true, IDS_ERR_METCORRUPT, partmetfilename,filename);
d462 1
a462 1
			AddLogLine(true, IDS_ERR_FILEERROR,partmetfilename,filename,error);
d484 3
a486 3
		if (gap->start != -1 && gap->end != -1 && gap->start <= gap->end && gap->start < filesize){
			if (gap->end >= filesize)
				gap->end = filesize-1; // Clipping
d507 2
a508 2
	if (!m_hpartfile.Open(searchpath,CFile::modeReadWrite|CFile::shareDenyWrite|CFile::osSequentialScan)){
		AddLogLine(false,IDS_ERR_FILEOPEN,fullname,filename);		
d513 2
a514 2
	if (m_hpartfile.GetLength() < filesize)
		AddGap(m_hpartfile.GetLength(), filesize-1);
d516 3
a518 3
	if (m_hpartfile.GetLength() > filesize){
		TRACE("Partfile \"%s\" is too large! Truncating %I64u bytes.\n", GetFileName(), m_hpartfile.GetLength() - filesize);
		m_hpartfile.SetLength(filesize);
d559 1
a559 1
	m_hpartfile.GetStatus(filestatus); // this; "...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are... :)
d562 1
a562 1
			AddLogLine(false,IDS_ERR_REHASH,filename);
d566 1
a566 1
		    addfilethread->SetValues(0,directory,m_hpartfile.GetFileName().GetBuffer(),this);
d571 4
a574 4
	if ( completedsize > transfered )
		m_iGainDueToCompression = completedsize - transfered;
	else if ( completedsize != transfered )
		m_iLostDueToCorruption = transfered - completedsize;
d577 1
a577 1
	if (paused) SetStartTimeReset(true);
d632 1
a632 1
		fwrite(&filehash,16,1,file);
d642 1
a642 1
		CTag nametag(FT_FILENAME,filename);
d644 1
a644 1
		CTag sizetag(FT_FILESIZE,filesize);
d646 1
a646 1
		CTag transtag(FT_TRANSFERED,transfered);
d648 1
a648 1
		CTag statustag(FT_STATUS,(paused)? 1:0);
d714 1
a714 1
		AddLogLine(false,IDS_ERR_SAVEMET,error,partmetfilename,filename);
d722 1
a722 1
		AddLogLine(false,IDS_ERR_SAVEMET,error.GetBuffer(),partmetfilename,filename);
d726 2
a727 1
	if ( !theApp.emuledlg->IsRunning() ) _commit(_fileno(file));
d735 1
a735 1

d741 2
a742 1
	bool errorfound = false;
d745 10
a754 6
	for (uint32 i = 0; i != hashSize; i++){
		if (IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1)){
			if (!(result->GetPartHash(i) && !md4cmp(result->GetPartHash(i),GetPartHash(i)))){
				AddLogLine(false,IDS_ERR_FOUNDCORRUPTION,i+1,filename);		
				AddGap(i*PARTSIZE,((((i+1)*PARTSIZE)-1) >= filesize) ? filesize-1 : ((i+1)*PARTSIZE)-1);
				errorfound = true;
d760 4
a763 2
	if (!errorfound){
		if (status == PS_COMPLETING){
d768 1
a768 1
			AddLogLine(false,IDS_HASHINGDONE,filename);
d770 2
a771 1
	else{
d774 2
d784 1
a784 1

d823 2
a824 1

d829 4
a832 3
	if (end >= filesize)
		end = filesize-1;
	for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos)){
d834 6
a839 3
		if ((cur_gap->start >= start && cur_gap->end <= end)||(cur_gap->start >= start 
			&& cur_gap->start <= end)||(cur_gap->end <= end && cur_gap->end >= start)
			||(start >= cur_gap->start && end <= cur_gap->end)){
d849 1
a849 1

d854 2
a855 2
	if (end >= filesize)
		end = filesize-1;
d1093 2
a1094 2
			percentcompleted = ((1.0f-(float)allgaps/filesize)) * 100; 
			completedsize = (uint32)((filesize-(allgaps+1))); 
d1097 1
a1097 1
		completedsize=filesize;
d1102 1
a1102 1

d1126 1
a1126 1
	s_ChunkBar.SetFileSize(filesize); 
d1132 1
a1132 1
		s_ChunkBar.FillRange(0, filesize, crProgress); 
d1135 1
a1135 1
		completedsize=filesize;
d1155 1
d1204 1
a1204 1
			if(end>filesize)
d1206 1
a1206 1
				end=filesize;
d1217 1
a1217 1
					confirmedsize+=filesize % PARTSIZE;
d1221 1
a1221 1
		completedsize = (uint32)((filesize-(allgaps+1)));
d1223 2
a1224 2
		percentcompleted = (float)completedsize/filesize*100;
		percentconfirmed = (float)confirmedsize/filesize*100;
d1230 1
a1230 1
		completedsize=filesize;
d1275 1
a1275 1

d1385 1
a1385 2


d1390 1
a1390 1
	if (!paused || status == PS_ERROR || status == PS_COMPLETING || status == PS_COMPLETE || ignorepause)
a1392 4
	{
		if(stopped)
			return PS_STOPPED;
		else
a1393 1
	}
d1397 1
a1397 1

d1448 1
a1448 1

d1453 1
a1453 2
	uint16	i_TcntTransferring = GetTransferingSrcCount(); // DonGato: for category filters
	
d1460 2
a1461 1
	uint32 cur_datarate;
d1463 8
a1470 1
	datarate = 0;
d1485 1
a1485 1
	// calculate datarate, set limit etc.
d1494 2
a1495 2
				cur_datarate = cur_src->CalculateDownloadRate();
				datarate+=cur_datarate;
d1498 1
a1498 1
					uint32 limit = reducedownload*cur_datarate/1000;
d1558 4
a1561 4
							// GetTransferingSrcCount() isn't updated inside this function.
							i_TcntTransferring++; 
							cur_datarate = cur_src->CalculateDownloadRate();
							datarate += cur_datarate;
d1564 1
a1564 1
								uint32 limit = reducedownload*cur_datarate/1000;
a1630 1

d1758 1
a1758 1
		// we don't need to count this, cause we can get a transfering sources over m_downloadingSourceList.GetCount()
d1832 1
a1832 1
			md4cpy(packet->pBuffer,filehash);
d1834 1
a1834 1
			memcpy_amd(packet->pBuffer,filehash,16);
d1852 1
a1852 1
		// calculate datarate, set limit etc. (every 5sec)
d1866 1
a1866 1
	if (GetTransferingSrcCount() != i_TcntTransferring)
d1873 1
d1878 1
a1878 1
	return datarate;
d1884 1
a1884 1

d1962 1
a1962 1
	int M_pos = (int)ceil((float)iPartCount/2) - 1;	// <- eklmn: feature(00): ICR
d2233 1
a2233 1
	const uint32 uEnd   = ((filesize - 1) < (uStart + PARTSIZE - 1)) ? (filesize - 1) : (uStart + PARTSIZE - 1);
d2309 1
a2309 1

a2315 1
	//if( srcarevisible )  //Done in StopFile()
d2320 16
a2335 6
	if (!bIsHashingDone){
		datarate = 0;
		CString partfileb = partmetfilename.Left(partmetfilename.GetLength()-4);
		CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_BELOW_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
		addfilethread->SetValues(0,tempdir,partfileb,this);
		addfilethread->ResumeThread();	
d2338 2
a2339 1
	else {
d2341 1
d2345 3
a2347 1
		} else {
d2351 1
a2351 1
	GetAvgDatarate(true);	//SyruS do update on completing files
d2359 1
a2359 1

d2427 2
a2428 2
		if (m_hpartfile.m_hFile != INVALID_HANDLE_VALUE)
			m_hpartfile.Close();
d2511 1
a2511 1
            paused = true; 
d2523 1
a2523 1
            paused = true; 
d2536 1
a2536 1
            paused = true; 
d2546 1
a2546 1
	ASSERT( m_hpartfile.m_hFile == INVALID_HANDLE_VALUE ); // the file must be closed/commited!
d2559 1
d2566 1
d2587 1
a2587 1

d2589 1
a2589 1
    paused = false;
d2632 1
a2632 1
//	transfered = filesize;
d2697 1
a2697 1
	if (m_hpartfile.m_hFile != INVALID_HANDLE_VALUE) m_hpartfile.Close(); // m_hpartfile isn't the handle to the file...
d2714 1
a2714 1
	srcName.Format(_T("%s\\%s.stsrc"),tempdir,partmetfilename);
d2720 1
a2720 1
	srcName.Format(_T("%s\\%s.bak"), theApp.glob_prefs->GetTempDir(), partmetfilename);
d2725 1
a2725 1
	srcName.Format(_T("%s\\%s.movie"), theApp.glob_prefs->GetTempDir(), partmetfilename);
d2745 1
a2745 1

d2750 2
a2751 1
	if ((GetHashCount() <= partnumber) && (GetPartCount() > 1)){
d2756 2
a2757 1
	else if(!GetPartHash(partnumber) && GetPartCount() != 1){
d2762 2
a2763 1
	else{
d2765 3
a2767 1
		m_hpartfile.Seek((LONGLONG)PARTSIZE*partnumber,0);
d2769 5
a2773 2
		if ((ULONGLONG)PARTSIZE*(partnumber+1) > m_hpartfile.GetLength())	// netwolf: download bugfix for files > 2 GB (bluecow)
			length = (m_hpartfile.GetLength()- ((ULONGLONG)PARTSIZE*partnumber));
d2775 1
a2775 1
		CreateHashFromFile(&m_hpartfile,length,hashresult);
d2777 1
a2777 1
		if (GetPartCount() > 1 || GetFileSize()==PARTSIZE){	// netwolf: special case if filesize == partsize
d2784 1
a2784 1
			if (md4cmp(hashresult,filehash))
d2795 1
a2795 1

d3075 1
a3075 1

d3090 1
d3111 3
a3113 3
	paused = true;
	stopped = true;
	datarate = 0;
d3137 1
a3137 1

d3177 2
a3178 2
	paused = true;
	datarate = 0;
d3196 1
a3196 1
		uint32 uEnd   = ((filesize - 1) < (uStart + PARTSIZE - 1)) ? (filesize - 1) : (uStart + PARTSIZE - 1);
d3210 2
a3211 2
	paused = false;
	stopped = false;
d3232 1
a3232 1

d3238 13
a3250 2
	if (GetTransferingSrcCount()>0) mybuffer=GetResString(IDS_DOWNLOADING); else mybuffer=GetResString(IDS_WAITING); 
	switch (GetStatus()) {
d3277 32
d3310 5
d3319 1
a3319 1
	// Sort order is Complete - Completing - Downloading - Waiting - Paused - Errors
d3322 3
a3324 1
	if (GetTransferingSrcCount()==0)
d3326 3
d3332 1
a3332 1
			status=5;
d3341 1
a3341 1
			status=4;
d3344 1
a3344 1
			status=6;
d3347 1
a3347 1
			status=7;
d3364 1
a3364 1
		DataRate = GetAvgDatarate();
d3366 1
a3366 1
		DataRate = GetDatarate();
d3374 3
a3376 1

d3378 2
a3379 1
uint32 CPartFile::GetAvgDatarate(bool bUpdated /*=false*/) {
d3385 2
a3386 1
		//calc on last FlushBuffer() to keep sessionstats for completed files
d3391 2
a3392 1
		//delay 1st calculation a bit & dont use datarate for balancing (peak-stopper?)
d3394 1
d3396 1
a3396 1
			m_AvgDataRate = ( (GetSessionTransfered() /*+ GetDatarate()*/) / (seconds /*+ 1*/) );
d3404 1
a3404 1

d3460 1
a3460 1
	//if vlan is previewing the file, the file *will not* be transfered 
d3471 1
a3471 1
	GetDiskFreeSpaceEx(tempdir,(PULARGE_INTEGER)&space,(PULARGE_INTEGER)&buf1,(PULARGE_INTEGER)&buf2);
d3569 1
a3569 1
	data.Write(filehash,16);
d3788 1
a3788 1
	uint64 alltimetransfered=0;
d3792 1
a3792 1
	if(fread(&alltimetransfered,	sizeof(alltimetransfered),	1, fh)!=1) { fclose(fh); return false; }
d3794 1
a3794 1
	statistic.AddAll(alltimerequested, alltimeaccepted, alltimetransfered);
d3830 1
a3830 1
	uint64 alltimetransfered=statistic.GetAllTimeTransfered();
d3834 1
a3834 1
	if(fwrite(&alltimetransfered,	sizeof(alltimetransfered),	1, fh)!=1) { fclose(fh); return false; }
d3998 2
a3999 2
	// Increment transfered bytes counter for this file
	transfered += transize;
d4063 1
a4063 1
	uint16 partnumber = floor((float)start/PARTSIZE);
d4065 1
a4065 1
	const uint32 uEnd   = ((filesize- 1) < (uStart + PARTSIZE - 1)) ? (filesize- 1) : (uStart + PARTSIZE - 1);
d4080 2
a4081 1

d4087 2
d4092 1
d4094 4
a4097 3
	GetAvgDatarate(true);	//SyruS do update on flushing
	// there are a couple of ways of doing this, this is one... 
	uint32 partCount = (filesize/PARTSIZE)+((filesize%PARTSIZE)? 1 : 0);
d4100 1
a4100 1
//	AddDebugLogLine(false, "Flushing file %s - buffer size = %ld bytes (%ld queued items) transfered = %ld [time = %ld]\n", GetFileName(), m_nTotalBufferData, m_BufferedData_list.GetCount(), transfered, m_nLastBufferFlushTime);
d4104 3
a4106 1
		// Remember which parts need to be checked at the end of the flush
d4114 10
a4123 5
		if (m_hpartfile.GetLength() <= item->end)
			m_hpartfile.SetLength(item->end + 1);	// netwolf: file should not be too large (taab)
		if (m_hpartfile.GetLength()>filesize)
			m_hpartfile.SetLength(filesize);
		// Loop through queue
d4133 6
a4138 4
			/*int curpart = item->start/PARTSIZE;
			changedPart[curpart] = true;*/
			for (uint32 curpart = item->start/PARTSIZE; curpart <= item->end/PARTSIZE; curpart++)
			changedPart[curpart] = true;
d4142 2
a4143 2
			m_hpartfile.Seek(item->start, CFile::begin);
			m_hpartfile.Write(item->data, lenData);
d4157 1
a4157 1
		m_hpartfile.Flush();
d4160 3
a4162 1
		uint32 partRange = (filesize % PARTSIZE) - 1;	//netwolf 03.05.03
d4165 1
d4182 1
a4182 1
					// Reduce transfered amount by corrupt amount
d4187 1
a4187 1
					// Successfully completed part, make it available for sharing
d4240 3
a4242 3
		paused = true;
		datarate = 0;
		transferingsrc = 0;
d4260 1
a4260 1

d4279 1
a4279 1
		bestEnd = filesize;
d4302 1
a4302 1
		else if (best->end < filesize)
d4306 1
a4306 1
			gap->end = filesize;
d4373 2
a4374 1
int CPartFile::GetRating(){  
d4377 3
a4379 1
     if (!hasRating) return 0;  
d4381 1
d4383 1
d4385 7
a4391 2
     for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())  
     for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){  
d4398 2
a4399 2
			   if (fRate==3 || fRate==4) fRate=(fRate==3)?4:3;
               tot+=fRate;  
d4407 1
d4412 2
a4413 1
               if (fRate==3 || fRate==4) fRate=(fRate==3)?4:3;
d4423 2
a4424 1
		if (num==3 || num==4) num=(num==3)?4:3;
d4426 1
a4426 1
     return num;	//Cax2 - if no ratings found, will return 0!
d4430 1
a4430 1
	 return 0;
d4432 5
a4436 2

void CPartFile::UpdateDisplayedInfo(boolean force) {
d4441 4
a4444 2
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
		if (theApp.emuledlg != NULL) {
d4452 1
a4452 1

d4722 1
a4722 1
	if (GetTransfered()==0 /*SyruS won't work: GetFileDate()==NULL*/)
d4743 1
a4743 1
				(int)GetPercentCompleted(), compl, GetTransferingSrcCount(),
d4763 1
a4763 1
	if (GetTransfered()==0)
d4774 2
a4775 2
	if(GetTransferingSrcCount() > 0)
		sTransfSrcCount.Format(GetResString(IDS_TT_PARTINFOS3),GetTransferingSrcCount());
d4925 1
d4957 1
a4957 1

d4971 1
a4971 1

d5036 1
a5036 1

d5049 16
@


1.235
log
@Added + for A4AF only downloads to show that they are A4AF sources.
@
text
@d4085 2
@


1.234
log
@Minor fix
@
text
@d185 1
@


1.233
log
@Added again fix for filters, reverted a change in Shared Files and changed the browse dialog for categories (now it should support network drives).
@
text
@d3037 3
a3066 1
	SetStatus(PS_READY);
d3081 1
a3081 1
	m_iSrcLowToLow =	 0;
d3089 1
@


1.232
log
@More fixes (sharing of files, JS used with downloading files and other minor ones)
@
text
@d1537 3
d1747 1
a1747 1
		m_iSrcTimeout = 			i_TcntTimeout;
d1751 3
a1753 3
		m_iSrcLowToLow =			i_TcntLowToLow;
		m_iSrcQueueFull =			i_TcntQueueFull;
		m_iSrcNoUpload =			i_TcntNoUpload;
d1755 2
a1756 2
		m_iSrcError =				i_TcntErr;
		m_iSrcA4AF =				A4AF_srclist.GetCount();
@


1.231
log
@Fixed start paused files by category (when option set or by menu)
Removed Reset All Statistics (agreed with Eklmn that has no use and it brings problems)
Removed Mobile Mule profile
Localized 'All' tab when language changed
@
text
@d164 1
d1372 1
a1372 1
	if (!paused || status == PS_STOPPED || status == PS_ERROR || status == PS_COMPLETING || status == PS_COMPLETE || ignorepause)
d1375 6
a1380 1
		return PS_PAUSED;
d2636 1
a2636 18
/*			
		if (!srclists[sl].IsEmpty())
			for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
			{
				srclists[sl].GetNext(pos1);
				cur_source = srclists[sl].GetAt(pos2);
				if (bTryToSwap)
				{
					if (!cur_source->SwapToAnotherFile(NULL))	//eklmn: bugfix(08): A4AF switching
						theApp.downloadqueue->RemoveSource(cur_source);
					else	
						//eklmn: if switching was succesfull we need to remove the entry from graphical list
						theApp.emuledlg->transferwnd.m_wndDownloadList.RemoveSource(cur_source,this);
				}
				else
					theApp.downloadqueue->RemoveSource(cur_source);
			}
*/
a2646 1
	//UpdateFileRatingCommentAvail();
d3034 2
a3035 2
	//eklmn: set status to PS_STOPED in order to prevent any action from other threads
	SetStatus(PS_STOPPED);
a3052 1
	//PauseFile();
d3061 1
d3063 1
d3093 2
a3094 1
	if (status==PS_COMPLETE || status==PS_COMPLETING) return;
d3097 1
a3097 1
	SetStatus(PS_PAUSED);
a3122 9
				/*else if (cur_src->GetDownloadState() == DS_DOWNLOADING) 
				{
					theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
#ifdef OLD_SOCKETS_ENABLED
					cur_src->socket->SendPacket(packet,false,true);
#endif //OLD_SOCKETS_ENABLED
					cur_src->SetDownloadState(DS_ONQUEUE);
				}
				*/
a3128 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d3161 1
@


1.230
log
@Fixed problem with moving category tabs (beware of CPartFile::SetPriority as it rebuilds the download list so any function using that feature *should* make a copy of it before proceeding).
@
text
@d2362 3
d2578 3
a2580 3
    { 
    	theApp.downloadqueue->StartPausedDownload() ; 
    } 
@


1.229
log
@1) small changes in A4AF counting
2) Transfering sources were counting twice
@
text
@d225 1
d4865 8
d4878 4
a4881 1
	if (IsPartFile()) switch (theApp.glob_prefs->GetCategory(GetCategory())->prio) {
d4900 1
a4900 1
	}
a4901 1
	if (IsPartFile())
d4903 1
@


1.228
log
@bugfix: chosed unique chunks was replaced by rare chunks
@
text
@a1466 1
				i_TcntTransferring++;
a1506 1
		uint16	i_TcntA4AF =			0;
a1527 1
						
a1529 1
							i_TcntTransferring++; // -khaos--+++> Renamed var.
d1737 1
a1737 1
		m_iSrcTimeout = 		i_TcntTimeout;
d1741 3
a1743 3
		m_iSrcLowToLow =		i_TcntLowToLow;
		m_iSrcQueueFull =		i_TcntQueueFull;
		m_iSrcNoUpload =		i_TcntNoUpload;
d1745 2
a1746 2
		m_iSrcError =			i_TcntErr;
		m_iSrcA4AF =			i_TcntA4AF;
d1847 1
a1847 1

@


1.227
log
@Enforce of destination directory sharing
@
text
@d2135 1
a2135 1
       if (m_MostCompletedRarestReqPart != PARTSIZE) 
@


1.226
log
@Updated templates and improved GetOutputDir
@
text
@d2362 1
a2362 1
{ 
a2516 4
	// END - enkeyDEV(Ottavio84) -ChangeDir-

    //////////////////////////////// 
    //remove *.src file (thx to brotbuexe) 
d2521 1
a2522 8
	/*
 	srcName.Format(_T("%s\\%s.stsrc"),tempdir,GetPartMetFileName());
 	if (_tremove(srcName))
 	if (errno != ENOENT)
 		AddLogLine(true,IDS_FAILDELETE,srcName);
 	*/

	// Tarod - erase .backup file
d2542 2
a2543 2
	directory = GetOutputDir();		
	// END - enkeyDEV(Ottavio84) -ChangeDir-
d2566 1
a2566 3
    //theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this); 
		UpdateDisplayedInfo();
	//SHAddToRecentDocs(SHARD_PATH, fullname); // zegzav (added)
d2590 9
@


1.225
log
@Fixes regarding Category directory handling
@
text
@a2379 3
	CString tempfilename;
	tempfilename.Format(_T("%s"),theApp.StripInvalidFilenameChars(GetFileName()));

d2381 1
a2381 12
	CString indir;
	if (PathFileExists(theApp.glob_prefs->GetCategory(GetCategory())->incomingpath) &&
		m_alternativepath.IsEmpty())
	{
		indir = theApp.glob_prefs->GetCategory(GetCategory())->incomingpath;
		newname.Format("%s\\%s",indir,tempfilename);
	}
	else
	{
		indir = GetOutputDir();
		newname.Format("%s\\%s",indir,tempfilename);
	}
d2455 2
a2456 2
            fInputFile.Close(); 
            fOutputFile.Close(); 
d4494 2
d4499 4
a4502 2
		// just return the incoming dir.
		return retpath;
@


1.224
log
@Fixed realtime update of filters.
@
text
@d2313 4
d2380 3
d2384 12
a2395 1
	newname.Format(_T("%s\\%s"),GetOutputDir(), theApp.StripInvalidFilenameChars(GetFileName()));
@


1.223
log
@Fixed Category Autopriority
@
text
@d103 1
a103 1
		status = PS_ERROR;
d122 1
a122 1
			status = PS_ERROR;
d136 1
a136 1
			status = PS_ERROR;
d143 1
a143 1
		status = PS_ERROR;
d164 1
a164 1
	status = PS_EMPTY;
d283 1
a283 1
		status = PS_ERROR;
d527 1
a527 1
	status = PS_READY;
d533 1
a533 1
		status = PS_EMPTY;
d545 1
a545 1
			status = PS_EMPTY;
d560 1
a560 1
			status = PS_WAITINGFORHASH;
d759 1
a759 1
		status = PS_READY;
d763 1
a763 1
	status = PS_READY;
d1433 2
d1467 1
d1533 1
d1734 1
a1734 1
		//m_iSrcTransferring=		i_TcntTransferring;
d1741 1
a1741 1
		m_iSrcTimeout = 			i_TcntTimeout;
d1745 3
a1747 3
		m_iSrcLowToLow =			i_TcntLowToLow;
		m_iSrcQueueFull =			i_TcntQueueFull;
		m_iSrcNoUpload =			i_TcntNoUpload;
d1749 2
a1750 2
		m_iSrcError =				i_TcntErr;
		m_iSrcA4AF =				i_TcntA4AF;
d1839 13
a1851 1
	
d2292 1
a2292 1
	status = PS_COMPLETING;
d2466 1
a2466 1
            status = PS_ERROR; 
d2478 1
a2478 1
            status = PS_ERROR; 
d2491 1
a2491 1
            status = PS_ERROR; 
d2551 1
a2551 1
    status = PS_COMPLETE;
d3047 1
a3047 1
	status = PS_STOPPED;
d3107 1
a3107 1
	status = PS_PAUSED;
d3162 1
a3162 1
	status = PS_EMPTY;
d3169 1
a3169 1
			status = PS_READY;
d4083 1
a4083 1
						status = PS_READY;
d4128 1
a4128 1
			status = PS_ERROR;
d4144 1
a4144 1
		status = PS_ERROR;
d4892 13
@


1.222
log
@Fixed problem with exchanged sources names.
@
text
@d4848 29
@


1.221
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d4340 1
a4340 1
			newsource->SetUserName(GetResString(IDS_EXCHANGEDSOURCE).GetBuffer());
@


1.220
log
@category bugfix (part.met corruption)
@
text
@d914 1
a914 1
		blockLimit = partStart + (BLOCKSIZE * (((start - partStart) / BLOCKSIZE) + 1)) - 1;
d983 1
a983 1
			const uint32 endOffset = ((uGapStart + BLOCKSIZE - 1) > uGapEnd) ? uGapEnd : (uGapStart + BLOCKSIZE - 1); 
d1384 3
a1386 3
	for (uint32 i = 0; i != ceil((float)PARTSIZE/BLOCKSIZE);i++){ 
		uint32 start = (PARTSIZE*partnumber) + i*BLOCKSIZE; 
		uint32 end    = (PARTSIZE*partnumber) + ((i+1)*BLOCKSIZE)-1; 
d2031 1
a2031 1
				if (m_ReqParts[i] > (PARTSIZE - BLOCKSIZE)) // limit change to prevent consecutive download due overlaping
d2802 1
a2802 1
	uint32 lastblock = ceil((float)PARTSIZE/BLOCKSIZE),end;
d2804 1
a2804 1
		end = (PARTSIZE*chunk) + (lastblock*BLOCKSIZE)-1; //Endadress from 1chunk before the last chunk
d2985 1
a2985 1
 		uint32 lastblock = ceil((float)PARTSIZE/BLOCKSIZE);
d2991 1
a2991 1
  			start = (PARTSIZE*chunk) + lastblockinpart*BLOCKSIZE;
@


1.219
log
@added OP_ASKSHAREDDIRS protocol
@
text
@d636 1
a636 1
		uint32 tagcount = taglist.GetCount()+7+(gaplist.GetCount()*2);
@


1.218
log
@built in compiler switch for mobileMule
@
text
@d259 1
@


1.217
log
@New sockets
@
text
@d2561 1
d2565 1
@


1.216
log
@*** empty log message ***
@
text
@d2560 1
d2564 1
@


1.215
log
@Updates (Paused Progress Bar/Statistic)
@
text
@a406 1
			#ifdef __USE_CATEGORIES__
a412 1
			#endif
a665 1
	#ifdef __USE_CATEGORIES__
d668 1
a668 2
	#endif

d801 1
a801 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d1050 1
a1050 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d1827 1
a1827 1
			//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d1941 1
a1941 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d2556 1
a2556 1
    //theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this); 
d2604 1
a2604 1
					theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(cur_source,this);
d2621 1
a2621 1
						theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(cur_source,this);
d2634 1
a2634 1
			theApp.emuledlg->transferwnd.downloadlistctrl.RemoveSource(cur_source,this);
d2692 1
a2692 1
	theApp.emuledlg->transferwnd.downloadlistctrl.RemoveFile(this);
d3014 1
a3014 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d3051 1
a3051 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this); // cax2 closefile bugfix
d3072 1
a3072 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d3127 1
a3127 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d3162 1
a3162 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4114 1
a4114 1
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4226 1
a4226 1
		UpdateDisplayedInfo();//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4297 1
a4297 1
			theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
@


1.214
log
@Updates/Fixes
@
text
@d1095 1
d1102 3
a1104 3
		crHave=(bFlat)?RGB(64, 64, 64):RGB(130, 130, 130);
		crPending = RGB(202, 181, 96);
		crMissing = RGB(191, 64, 64);
d1106 1
d1139 12
a1150 3
				color = RGB(0, 
				(210-(22*(m_SrcpartFrequency[i]-1)) <  0)? 0:210-(22*(m_SrcpartFrequency[i]-1)) 
				,255); 
d1152 1
a1152 1
				color = crMissing; 
@


1.213
log
@latest mobile mule changes + some additional webserver stuff (see changelog)
@
text
@d1090 15
a1104 4
	const COLORREF crProgress=(bFlat)?RGB(0, 150, 0):RGB(0, 192, 0); 
	const COLORREF crHave=(bFlat)?RGB(0, 0, 0):RGB(95, 95, 95); //Cax2 - darker 'black'
	const COLORREF crPending = RGB(255, 208, 0);
	const COLORREF crMissing = RGB(255, 0, 0);
@


1.212
log
@Preparing for new sockets
@
text
@d2542 4
@


1.211
log
@added past comments
@
text
@d1541 1
d1557 1
d1796 1
d1801 1
@


1.210
log
@new statistic (khaos based)
@
text
@d4181 18
d4236 15
d4778 39
@


1.209
log
@Added STOP visual notification.
@
text
@d168 16
a183 1
	transferingsrc = 0;
d1416 3
d1420 3
a1432 1
	bool sockets_usage_high;
a1435 2
	transferingsrc = 0;
	datarate = 0;
d1441 2
a1442 1
		for (pos1 = m_downloadingSourceList.GetHeadPosition(); pos1 !=NULL;){
d1444 3
a1446 3
			if (cur_src){
				transferingsrc++;
				uint32 cur_datarate = cur_src->CalculateDownloadRate();
d1469 20
d1498 6
d1505 1
a1505 4
					/*
					if( (iteration!=0) && (cur_src->GetDownloadState() != DS_DOWNLOADING) )
						continue;
					*/
d1511 1
a1511 2
							transferingsrc++;
							uint32 cur_datarate = cur_src->CalculateDownloadRate();
d1532 3
d1536 29
d1566 1
d1568 1
d1580 1
d1583 1
d1606 4
a1609 1
								if( ((dwCurTick - lastpurgetime) > 60000) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) )
d1615 11
a1668 9

							// Check Remote queue position
							if ((theApp.glob_prefs->UseRemoteQueueLimit() 
								&& !cur_src->IsRemoteQueueFull())
								&& (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetRemoteQueueLimit())) 
							{
								theApp.downloadqueue->RemoveSource(cur_src);
								break;
							}
d1671 1
d1673 1
a1673 1
						case DS_CONNECTED:
d1675 1
d1677 11
a1687 13
							// LANCAST (moosetea) - Because reask much faster if lancast user ie we may reask as soon as we get disconnected
							// , we only use TCP on a LAN, because emule may try to send a TCP request and UDP request at the same time!
							if (cur_src->isOnLAN())
							{
								if ((!cur_src->GetLastAskedTime()) 
									|| (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMETCP)
								{
									cur_src->AskForDownload();
								}
							}
							else 
							{
								//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
d1689 10
a1698 6
								if (theApp.serverconnect->IsConnected() 
									&& ((!cur_src->GetLastAskedTime()) 
									|| (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime))
								{
									cur_src->AskForDownload();
								}
d1700 1
a1700 3
							}
							break;
					}// switch (state)
d1705 23
d2329 5
d2544 6
d2551 1
d3029 16
a3044 1
	transferingsrc = 0;
a3100 1
	transferingsrc = 0;
@


1.208
log
@*** empty log message ***
@
text
@d1336 1
a1336 1
	if (!paused || status == PS_ERROR || status == PS_COMPLETING || status == PS_COMPLETE || ignorepause)
d3038 1
a3038 1
			break; 
@


1.207
log
@eMailNotifier and PopUp CleanUp
@
text
@d392 8
d652 5
@


1.206
log
@Fix for loading of sources when not yet connected
@
text
@d2308 4
a2311 7
			if(theApp.glob_prefs->IsSMTPWarningEnabled())
			{
				CSMTPConnection mail;
				CString txt;
				txt.Format(GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName());
				mail.SendMuleMessage(txt);
			}
d2321 4
a2324 7
			if(theApp.glob_prefs->IsSMTPWarningEnabled())
			{
				CSMTPConnection mail;
				CString txt;
				txt.Format(GetResString(IDS_ERR_COMPLETIONFAILED)+_T("\n")+GetFileName());
				mail.SendMuleMessage(txt);
			}
d2392 4
a2395 8
	if(theApp.glob_prefs->IsSMTPInfoEnabled())
	{
		CSMTPConnection mail;
		CString txt;
		txt.Format(GetResString(IDS_TBN_DOWNLOADDONE)+_T("\n")+GetFileName(), TBN_DLOAD);
		mail.SendMuleMessage(txt);
	}
    theApp.emuledlg->ShowNotifier(GetResString(IDS_TBN_DOWNLOADDONE)+_T("\n")+GetFileName(), TBN_DLOAD); 
d3926 5
a3930 14
			if (theApp.glob_prefs->GetNotifierPopOnImportantError()) 
			{
				CString msg;
				msg.Format(GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
				// Purity - Sending message for insufficient diskspace
				if(theApp.glob_prefs->IsSMTPWarningEnabled())
				{
					CSMTPConnection mail;
					CString txt;
					txt.Format(GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
					mail.SendMuleMessage(txt);
				}
				theApp.emuledlg->ShowNotifier(msg, TBN_IMPORTANTEVENT, false);
			}
@


1.205
log
@Purity's changes
@
text
@d1674 1
a1674 1
		if (iteration && theApp.glob_prefs->SLSEnable() && m_downloadingSourceList.IsEmpty()) 
@


1.204
log
@CHANGE: now showing "never" instead of "unknown" for Last Reception [Andrerib]
@
text
@d28 1
d2307 8
d2323 8
d2397 8
d3940 8
d4569 1
d4574 1
d4578 1
d4583 1
d4586 32
@


1.203
log
@changed INI file interface + little bugfix
@
text
@d4352 1
a4352 1
		lastprogr = GetResString(IDS_UNKNOWN);
d4393 1
a4393 1
		lastprogr = GetResString(IDS_UNKNOWN);
@


1.202
log
@*** empty log message ***
@
text
@d3649 2
a3650 1
   	CIni pvmoviefile(CString(fullname) + CString(".movie"), _T("MoviePreview")); 
d3654 4
a3657 1
    m_bDiscardSuperCompressed = pvmoviefile.GetBool(_T("DiscardSuperCompressed"),false,_T("DownloadSettings"));
d3666 6
a3671 2
   	CIni pvmoviefile(CString(fullname) + CString(".movie"), _T("MoviePreview")); 
	pvmoviefile.WriteInt(_T("Mode"), ((CKnownFile*)this)->GetMovieMode()); 
d3673 1
a3673 1
    pvmoviefile.WriteBool(_T("DiscardSuperCompressed"),m_bDiscardSuperCompressed,_T("DownloadSettings"));
@


1.201
log
@1) added new filestate PS_STOPPED
2) StopFile() was rewritten
@
text
@d1776 1
a1776 1
	int M_pos = (int)ceil(iPartCount/2) - 1;	// <- eklmn: feature(00): ICR
d3757 1
a3757 1
	uint16 partnumber = floor(start/PARTSIZE);
@


1.200
log
@CHANGE: now showing "never" instead of "unknown" in Last Seen Complete column [Andrerib]
@
text
@d1703 5
a1707 2
	//if this part file is paused or complete/completing no sources needed any more
	if(GetStatus()==PS_PAUSED || GetStatus() > 7)		//Cax2 + SyruS check
d1709 1
a1709 1

d2128 2
a2134 3
	//	theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this);
	StopFile();		//Cax2 - completing file bugfix....
	
d2421 16
a2436 1
	for (int sl=0;sl<SOURCESSLOTS;sl++) 
d2453 11
d2852 3
d2896 3
d2953 13
d2971 1
d3017 3
d3051 3
d3055 1
a3055 1
			status=6;
d3372 7
a3378 4
	//if this part file is paused or complete/completing no sources needed any more
	//Cax2 + SyruS check
	if(GetStatus()==PS_PAUSED || GetStatus() > 7) return;

d3930 1
a3930 1
        PauseFile();
@


1.199
log
@by completing set status to "PS_COMPLETING" first and only then stop a file in order to prevent A4AF switching during completion
@
text
@d4281 1
a4281 1
		lsc = GetResString(IDS_UNKNOWN);
d4322 1
a4322 1
		lsc = GetResString(IDS_UNKNOWN);
@


1.198
log
@bugfix for files >2GB
@
text
@a2125 3
	//	theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this);
	StopFile();		//Cax2 - completing file bugfix....

d2129 3
@


1.197
log
@don't force display update when new sources are received
@
text
@d2516 3
a2518 2
		if (PARTSIZE*(partnumber+1) > m_hpartfile.GetLength())
			length = (m_hpartfile.GetLength()- (PARTSIZE*partnumber));
d2521 1
a2521 1
		if (GetPartCount() > 1){
@


1.196
log
@1) optimization in StopFile() & CompleteFile().
2) possible memleak in RemoveAllSources()
@
text
@d1806 1
a1806 1
	UpdateDisplayedInfo(true);
@


1.195
log
@speed optimization in StopFile()
@
text
@d1638 5
a1642 3
			for (POSITION pos = A4AF_srclist.GetHeadPosition(); pos != 0; A4AF_srclist.GetNext(pos)) 
			{	//SyruS exception-bugkiller: wrong getting client of srclists[sl] with pos made from A4AF_srclist!
				CUpDownClient* cur_src = A4AF_srclist.GetAt(pos);
d2128 2
d2131 2
a2132 1
	UpdateDisplayedInfo(true); //Show completing instead of paused
a2149 3
	if (theApp.downloadqueue->GetA4AFAutoFile() == this)
		theApp.downloadqueue->SetA4AFAutoFile(NULL);
	RemoveAllSources(true);	//eklmn: new A4AF engine (if file is complete, switch source to other files, otherwise just remove it)
d2211 1
a2211 1
	
d2213 9
a2221 2
	if (m_hpartfile.m_hFile != INVALID_HANDLE_VALUE)
		m_hpartfile.Close(); // m_hpartfile isn't the handle to the file...
d2418 4
a2421 6
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; )
		{
			srclists[sl].GetNext(pos1);
			cur_source = srclists[sl].GetAt(pos2);
			if (bTryToSwap)
d2423 11
a2433 1
				if (!cur_source->SwapToAnotherFile(NULL))	//eklmn: bugfix(08): A4AF switching
d2436 2
a2437 4
			else
				theApp.downloadqueue->RemoveSource(cur_source);
		}
	UpdateFileRatingCommentAvail();
d2841 4
d3942 15
a3956 9
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
		if (cur_src->GetFileComment().GetLength()>0) hasComment=true;
		if (cur_src->GetFileRate()>0) hasRating=true;
		if (hasComment && hasRating) break;
	}
	if (prev!=(hasComment || hasRating)) UpdateDisplayedInfo();//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
@


1.194
log
@1) removed a double source swaping in "Stop" & "Cancel"
2) correction in file completing
@
text
@d2809 16
a2824 1
	PauseFile();
d2828 1
a2828 2
	//RemoveAllSources(true);
	RemoveAllSources(false); //eklmn: don't switch source, cause they already has to be switched in PauseFile()
d2845 1
d2847 1
d2849 13
d2870 1
a2870 1
				else if (cur_src->GetDownloadState() == DS_DOWNLOADING) 
d2878 1
d2881 1
a2881 1
	}	
@


1.193
log
@1) completing bug (eMule cann't complete a file, if file is uploaded)
2) large CPU load in case of "Stop File" & "Cancel"
3) A4AF source on "Pause" will be switched to other files.
@
text
@d2201 1
d2813 2
a2814 1
	RemoveAllSources(true);
@


1.192
log
@1) SLS during DL is blocked now
2) old SLS completly removed
3) new DL client speed measurement system
4) optmization in RemoveAllSources()
@
text
@d2197 6
d2810 2
a2811 1
	theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this); // cax2 closefile bugfix
d2836 5
a2840 1
				if (cur_src->GetDownloadState() == DS_DOWNLOADING) {
@


1.191
log
@//SyruS exception-bugkiller: wrong getting client of srclists[sl] with pos made from A4AF_srclist!
i wonder how compiler let this do us? actually i thought "sl" wouldn't be in scope at that place - but it was always 100 (max_sourcesslots)
did auto-a4af somehow work before at all?
@
text
@a174 18
	/////////////////////////////////////
	//for saving sources:
	
#ifdef OLD_SLS_ENABLED
	m_bLoadedSourcesCompletely				= true;//do load sources only on a call of LoadAndAddSourceFromFile(...)
	m_iSourceIndex							= 0;
	m_iSourceIDIndex						= -1;
	m_bWasConnectedToServerLastTime			= false;
	m_iLastTimeSourcesLoaded				= ::GetTickCount();	//I'm not sure, maybe it should be 0
	m_iLastTimeSourcesSaved					= ::GetTickCount();	//I'm not sure, maybe it should be 0
	m_iLastTimeSourcesLoadedPartial			= ::GetTickCount();	//I'm not sure, maybe it should be 0
	m_iLoadSourcesAtOnceLimit				= RESTORE_SOURCES_AT_ONCE;
	m_iLoadingSourcesTimeInterval			= RESTORE_SOURCES_TIME;
	m_iLoadingSourcesPartialTimeInterval	= RESTORE_SOURCES_SLOWLY_TIME;
	m_iSavingSourcesTimeInterval			= STORE_SOURCES_TIME;
	m_stscrStoringSources					= NULL;
	m_bLoadSavedSources						= true;
#endif //OLD_SLS_ENABLED
d192 1
a192 1
    m_bDiscardSuperCompressed = false;
d228 2
d232 1
a232 8
	/////////////////////////////////////
	//for saving sources: mr fry
#ifdef OLD_SLS_ENABLED
	if(m_stscrStoringSources != NULL) {
		delete m_stscrStoringSources;
		m_stscrStoringSources = NULL;
	}
#endif //OLD_SLS_ENABLED
d1413 1
a1413 1
				uint32 cur_datarate = max(cur_src->CalculateDownloadRate(), 0);
a1435 22
		// check if we want new sources from server
		//uint16 test = theApp.glob_prefs->GetMaxSourcePerFileSoft();
#ifdef OLD_SOCKETS_ENABLED
		if (( (!lastsearchtime) 
			|| (dwCurTick - lastsearchtime) > SERVERREASKTIME) 
			&& theApp.serverconnect->IsConnected()
			&& theApp.glob_prefs->GetMaxSourcePerFileSoft() > GetSourceCount() )
		{
			//local server
			lastsearchtime = dwCurTick;
			Packet* packet = new Packet(OP_GETSOURCES,16);
			#ifndef AMD
			md4cpy(packet->pBuffer,filehash);
			#else
			memcpy_amd(packet->pBuffer,filehash,16);
			#endif
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
			theApp.serverconnect->SendPacket(packet,true);
			//AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
		}
#endif //OLD_SOCKETS_ENABLED
		
d1456 1
a1456 1
							uint32 cur_datarate = max(cur_src->CalculateDownloadRate(), 0);
d1647 23
d1671 1
a1671 1
		if (theApp.glob_prefs->SLSEnable()) 
d1673 1
a1673 1
			m_sourcesaver.Process(this, theApp.glob_prefs->SLSMaxSourcesPerFile()); //<<-- enkeyDEV(Ottavio84) -New SLS-			
a1688 32
	///////////////////////////////////////////////////////
	//for saving/reloading source to/from disk: mr fry
#ifdef OLD_SLS_ENABLED
	if(GetStatus() < 2 && theApp.downloadqueue->IsSourcesLoadingEnabled()){
		uint32 currentTime = ::GetTickCount();

#ifdef OLD_SOCKETS_ENABLED
		if(!m_bWasConnectedToServerLastTime && theApp.serverconnect->IsConnected()){
			//if connection-state has switch from: not connected -> connected...
#ifdef _DEBUG_SAVED_SOURCES
			TRACE("CPartFile::Process : slow loading of sources down if a connection is established (next time sources are loaded for %s: in %.1f sec)\n"
				,GetFileName(),(float(m_iLoadingSourcesPartialTimeInterval)/1000));
#endif
			m_iLastTimeSourcesLoadedPartial = ::GetTickCount();
		}
#endif //OLD_SOCKETS_ENABLED

		//load sources in slow mode (while they weren't completely loaded yet)?
#ifdef OLD_SOCKETS_ENABLED
		if(!m_bLoadedSourcesCompletely && theApp.serverconnect->IsConnected() && !theApp.downloadqueue->IsMaxClientsExceeded())
//			&& theApp.listensocket->GetOpenSockets() < theApp.glob_prefs->GetMaxConnections()-20-RESTORE_SOURCES_AT_ONCE) // Vorlost
		{  
			if(currentTime - m_iLastTimeSourcesLoadedPartial > m_iLoadingSourcesPartialTimeInterval)
			{
				// makes room for more loaded sources
				if (theApp.glob_prefs->IsRemoveNNSEnabled()) //Vorlost added prefs question
				{
					int source_count_plus_needed = GetSourceCount() + GetLoadSourcesAtOnceLimit();
					if (source_count_plus_needed > theApp.glob_prefs->GetMaxSourcePerFile()
					&& ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME))
						RemoveNoNeededSources(source_count_plus_needed - theApp.glob_prefs->GetMaxSourcePerFile());
				}
a1689 65
				//is a permanent opened CStoredSources-object for each part-file wanted?
				if(theApp.downloadqueue->KeepStoredSourcesOpen())
					AddFromStoredSources(m_stscrStoringSources,false,GetLoadSourcesAtOnceLimit());
				else
					LoadAndAddSources(false,false,GetLoadSourcesAtOnceLimit());
			}
		}
		//(re-) load sources?
		else if((currentTime - m_iLastTimeSourcesLoaded) > m_iLoadingSourcesTimeInterval  
				&& theApp.serverconnect->IsConnected()
//				&& theApp.listensocket->GetOpenSockets() < theApp.glob_prefs->GetMaxConnections()-20-RESTORE_SOURCES_AT_ONCE) // Vorlost
				&& !theApp.downloadqueue->IsMaxClientsExceeded()) // from 25b code. don't know if it's better
		{
#ifdef _DEBUG_SAVED_SOURCES
			TRACE("Reloading all sources for %s\n",GetFileName());
#endif
			// Added by Tarod -before reload purge outdated and no needed sources
			// remember that this only occurs first time -first group of loaded sources
			if(m_stscrStoringSources != NULL)
			{
				m_stscrStoringSources->DeleteOutdatedSources();
				m_stscrStoringSources->SortSourcesByPartsNDate();
				m_stscrStoringSources->ReduceSourcesTo(m_stscrStoringSources->GetMaxSourceEntries());
			}
			if (theApp.glob_prefs->IsRemoveNNSEnabled())  //Vorlost added prefs question
			{
			    int source_count_plus_needed = GetSourceCount() + GetLoadSourcesAtOnceLimit();
			    if (source_count_plus_needed > theApp.glob_prefs->GetMaxSourcePerFile())
				    RemoveNoNeededSources(source_count_plus_needed - theApp.glob_prefs->GetMaxSourcePerFile());
			}
			
			//is a permanent opened CStoredSources-object for each part-file wanted?
			if(theApp.downloadqueue->KeepStoredSourcesOpen()) {
				//as in the previous if(), but with AddFrom..(..,true); -> reset=true means, begin again to load all sources from stored-sources
				AddFromStoredSources(m_stscrStoringSources,false,GetLoadSourcesAtOnceLimit(),true);
			} else
				LoadAndAddSources(false,false,GetLoadSourcesAtOnceLimit(),true);
		}
		//save sources?
		if((currentTime - m_iLastTimeSourcesSaved) > m_iSavingSourcesTimeInterval
			&& m_bLoadedSourcesCompletely){

			//only save to disk now, if there is no permantent opened CStoredSources-object for this part-file
			if(!theApp.downloadqueue->KeepStoredSourcesOpen()){
#ifdef _DEBUG_SAVED_SOURCES
				TRACE("(automatically) saving sources for %s to disk\n",GetFileName());
#endif
				SaveSources(true);
			}
			else if(m_stscrStoringSources != NULL){//sort, so we get the best sources first, the next time they're loaded
				//if (!m_stscrStoringSources->IsRareFile()) m_stscrStoringSources->DeleteOutdatedSources();
				m_stscrStoringSources->SortSourcesByPartsNDate();
				SaveSources(false);
				//m_stscrStoringSources->ReduceSourcesTo(m_stscrStoringSources->GetMaxSourceEntries());
			}

			// Added by Tarod fixed bug of CPU usage (por fin, me cago en la puta hostia, joder!!!)
			m_iLastTimeSourcesSaved = ::GetTickCount();
		}
        
		m_bWasConnectedToServerLastTime = theApp.serverconnect->IsConnected();
#endif //OLD_SOCKETS_ENABLED
	}//end: if(status)
	////////////////////////////////////////////////////////
#endif //OLD_SLS_ENABLED
d2401 1
d2403 2
a2404 1
		for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
d2406 5
a2410 3
			if (bTryToSwap){
				if (!srclists[sl].GetAt(pos2)->SwapToAnotherFile(NULL))	//eklmn: bugfix(08): A4AF switching
					theApp.downloadqueue->RemoveSource(srclists[sl].GetAt(pos2));
d2413 1
a2413 1
				theApp.downloadqueue->RemoveSource(srclists[sl].GetAt(pos2));
a2414 1

d2460 1
a2460 1
    m_sourcesaver.DeleteFile(this); //<<-- enkeyDEV(Ottavio84) -New SLS-
a2865 3
#ifdef OLD_SLS_ENABLED
	SetLoadSourcesTimeInterval(2 * 60 * 1000) ; // Added by Tarod (to load exchanged sources)
#endif //OLD_SLS_ENABLED
a3318 595
///////////////////////////////////////////////////////////////////////////////////////
//Storing Sources:
#ifdef OLD_SLS_ENABLED
bool CPartFile::SaveSourcesToFile(CStoredSources* toSave, bool debug)
{
	EMULE_TRY

	//if this part-file is complete/completing no source saving is needed any more
	if(GetStatus() > 7)
		return false;

	//save the sources to disk
	if(toSave != NULL){
		CString temp=_T("");
		temp.Format(_T("%s\\%s.stsrc"),tempdir,GetPartMetFileName());
		CFile saveSources;
		if(saveSources.Open(temp,CFile::modeCreate|
								//CFile::modeNoTruncate|
								CFile::shareDenyWrite|
								CFile::modeWrite,NULL)){
			CArchive archive(&saveSources, CArchive::store);
			archive.SetStoreParams(sizeof(CSourceEntry)*toSave->GetCountSourceEntrys()/10,sizeof(CStoredSources));
			try{
				toSave->Serialize(archive);
			}catch(CArchiveException* err){
				err->Delete();
				archive.Close();
				saveSources.Close();
				return false;
			}
			archive.Close();
			saveSources.Close();
			if(debug) AddLogLine(false,_T("Sources for '%s' (%s) were found and saved"),GetPartMetFileName(),GetFileName());
#ifdef _DEBUG_SAVED_SOURCES
			TRACE("Saved sources for %s (%s.src)\n",storedSources->GetFileName(), storedSources->GetPartFileName());
#endif
		}
		else{
			TRACE("Could not open file for saving sources of %s (%s.stsrc)\n",toSave->GetFileName(), toSave->GetPartFileName());
			return false;
		}
	}
	else{
		if(debug) AddLogLine(false,_T("Due to the fact no sources were found for '%s', nothing was written"),GetPartMetFileName());
#ifdef _DEBUG_SAVED_SOURCES
		TRACE("No sources found for %s (%s)\n",toSave->GetFileName(), toSave->GetPartFileName());
#endif
	}

#ifdef _DEBUG_SAVED_SOURCES
	TRACE("Saving sources for %s: all sources were saved once again since %.02f min. ago\n"
					,GetFileName()
					,(float(::GetTickCount() - m_iLastTimeSourcesSaved)/60000));
#endif

	m_iLastTimeSourcesSaved = ::GetTickCount();

	return true;

	EMULE_CATCH
	
	return false;
}

CStoredSources*	CPartFile::LoadSourcesFromFile(bool debug)
{
	EMULE_TRY

	CString temp=_T("");
	temp.Format(_T("%s\\%s.stsrc"),tempdir,GetPartMetFileName());
	CFile loadSources;
	CStoredSources* toLoad = new CStoredSources(GetPartMetFileName()
												, GetFileName()
												, GetFileHash()
												, theApp.glob_prefs->GetMaxSourcePerFile());
	if(loadSources.Open(temp,CFile::modeRead|CFile::shareDenyWrite,NULL)){
		CArchive archive(&loadSources, CArchive::load);
		CFileStatus fileStatus;
		loadSources.GetStatus(fileStatus);
		long size = fileStatus.m_size;
		archive.SetLoadParams((2*size)/1000);
		try{
			toLoad->Serialize(archive);
		}catch(CException* err){			
			if(debug) AddLogLine(false,_T("Could not load *.stsrc file for %s (%s)\r\n\t(ErrorMessage: %s)"),GetFileName(),GetPartMetFileName(),GetErrorMessage(err));
			err->Delete();
			archive.Close();
			loadSources.Close();
			delete toLoad;
			return NULL;
		}
		if(debug) AddLogLine(false,_T("Found %i Sources for %s in %s.stsrc"),toLoad->GetCountSourceEntrys()
									,GetFileName(),toLoad->GetPartFileName());
		archive.Close();
		loadSources.Close();
	}
	else {
		if(debug) AddLogLine(false,_T("Could not open *.stsrc file for %s (%s)"),GetFileName(),GetPartMetFileName());
		delete toLoad;
		return NULL;
	}

	//set the stored-sources preferences from file
	m_iLoadingSourcesTimeInterval			= toLoad->GetLoadSourcesTime();
	m_iLoadingSourcesPartialTimeInterval	= toLoad->GetLoadSourcesSlowTime();
	m_iLoadSourcesAtOnceLimit				= toLoad->GetLoadSourcesLimit();
	m_iSavingSourcesTimeInterval			= toLoad->GetSaveSourcesTime();
	m_bLoadSavedSources					= toLoad->GetLoadSources();
	
	return toLoad;

	EMULE_CATCH

	return NULL;
}

bool CPartFile::AddFromStoredSources(CStoredSources* storedSources, bool sendUDPRequest
									, int limit, bool reset, bool debug)
{
	EMULE_TRY

	//if this part-file is complete/completing no source-loading is needed any more
	if(GetStatus() > 7|| GetStatus()==PS_PAUSED)		//Cax2 + SyruS check
		return false;

	if (limit>0)limit = RESTORE_SOURCES_AT_ONCE; // Vorlost (bypass the old value stored in each SLS File) 

	if(storedSources != NULL){
		
		//if limit == -1 (unlimited), the index should not set to 0, because
		//the sources from index 0 to m_iSourceIndex where already
		//'slow-loaded' a short time ago (so no need to to it again)
		if(reset){
			storedSources->SetSourceIndex(0);
			m_iSourceIndex	= 0;
		}
		else 
			storedSources->SetSourceIndex(m_iSourceIndex);

		CSourceEntry* sourceEntry = storedSources->GetNextSourceEntry();//storedSources->GetFirstSourceEntry();
		CServerEntry* serverEntry;
		int countAddedSources=0;//count the added Sources
		int countUDP=0;			//count how many UDP-Requests were send (for debugging)
		uint32 userID;			//temporal variable for a User-ID

		//if sourceEntry is valid and no-limit (for limit equal -1)
		//or loop-counter i < limit, do...
		for(int i=0 ; (sourceEntry != NULL) && ((limit == -1)||(i < limit)); i++){
			serverEntry = sourceEntry->GetLastServerEntry();
			//TRACE("CDownloadQueue::LoadAndAddSourcesFromFile(...): UDP-Source-Request is %s!\n",(sendUDPRequest == true? "ON":"OFF"));
			
			////ask the known servers (of this client/source) for new sources
			//if(sendUDPRequest){
			//	//limited UDP-Requests to 5
			//	for(int i=0; (i < 5) && serverEntry != NULL ; i++){
			//	//while(serverEntry != NULL){
			//		if(theApp.serverconnect->IsConnected()){
			//			if (!theApp.listensocket->TooManySockets()){
			//				//is the server (for the request) already existing?
			//				CServer* server;
			//				char* serverIP = serverEntry->GetFullServerIP();
			//				server = theApp.serverlist->GetServerByAddress(
			//									serverIP
			//									,serverEntry->GetServerPort());
			//				delete serverIP;
			//				
			//				if(server != NULL){
			//					//if not, add the server
			//					//server = new CServer(serverEntry->GetServerPort(),serverEntry->GetFullServerIP());
			//					//theApp.emuledlg->serverwnd.serverlistctrl.AddServer(server);
			//				
			//					Packet packet(OP_GLOBGETSOURCES,16);
			//					memcpy(packet.pBuffer,GetFileHash(),16);
			//					theApp.serverconnect->SendUDPPacket(&packet,server,false);
			//					if(debug) AddLogLine(false,"sended an UDP-Source-Request to %s for %s (%s)\n"
			//														,server->GetFullIP()
			//														,GetFileName()
			//														,GetPartMetFileName());
			//					countUDP++;
			//				}//end: if(server != NULL)
			//			}//end: if(TooManySockets)
			//		}//end: if(isConnected)
			//		serverEntry = sourceEntry->GetPreviousServerEntry();
			//	}//end for-loop
			//}//end: if(sendUDPRequest)
			
			//generate CUpDownClients for known sources
			serverEntry = sourceEntry->GetLastServerEntry();			
			if(serverEntry !=  NULL){//you need a server for creating a CUpDownClient
				userID=sourceEntry->GetFirstUserID();
				if(m_iSourceIDIndex > 0 && limit != -1){
					for(int j=0; j < m_iSourceIDIndex; j++)
						userID = sourceEntry->GetNextUserID();
				}
				else m_iSourceIDIndex = 1;
				//TRACE("(%s)first source-index: %s:%i (ID: %u)\n",GetFileName()
				//	,sourceEntry->GetUserName(),m_iSourceIDIndex,userID);

				while(userID > 0){
					//check, if the sources-per-file-limit (glob_prefs) is exceeded                    
					if(GetSourceCount() >= theApp.glob_prefs->GetMaxSourcePerFile()
						||  ((limit != -1)&&(countAddedSources > limit)) ){
						goto After_Loading;
					}
					
					// Added by Tarod (LS tweak)
					// HACK by Md5Chap 2002-11-26 (Moved to CUpDownClient::~CUpDownClient)
					//sourceEntry->IncrementFailedConnections();
					CUpDownClient* newSource = new CUpDownClient(sourceEntry->GetUserPort()
														, userID, serverEntry->GetServerIP()
														, serverEntry->GetServerPort(), this, sourceEntry);
					
					CString strUserName = sourceEntry->GetUserName() ;
					if (strUserName.Find(_T(EXCHANGEDSOURCEMARK)) == 0) {
						strUserName = GetResString(IDS_EXCHANGEDSOURCE) ;
					} else {
						strUserName = GetResString(IDS_LOADEDSOURCE) ;
					}
					newSource->SetUserName(strUserName);
					
					theApp.downloadqueue->CheckAndAddSource(this, newSource, false);
					//TRACE("(LoadNAdd) new source (count: %i, index: %i) for %s's sended to CheckNAdd\n"
					//		//, (newSource->GetUserName()!=NULL?newSource->GetUserName():NONAME)
					//		, countAddedSources
					//		, m_iSourceIDIndex++
					//		, GetFileName());
					countAddedSources++;
					m_iSourceIDIndex++;
					if(debug){ AddLogLine(false,_T("added Source (%i) of %i Sources for %s (%s)")
							,newSource->GetUserID()
							,storedSources->GetCountSourceEntrys(),GetFileName()
							,storedSources->GetFileID());
						AddLogLine(false,_T("The new Source is %s and the SourceEntry is %s"),(newSource == NULL ? _T("NULL") : _T("not NULL")),(sourceEntry == NULL ? _T("NULL") : _T("not NULL")));
						AddLogLine(false,_T("New source No. %i added for %s"),countAddedSources,GetFileName());
					}
					 userID = sourceEntry->GetNextUserID();
				}//end while-loop
			}//end if(serverEntry != NULL)
			sourceEntry = storedSources->GetNextSourceEntry();//limit);
			m_iSourceIDIndex = -1;
//#ifdef _DEBUG
//            if(sourceEntry != NULL) TRACE("(%s)last source-index: %s:%i (ID: %u)\n",GetFileName()
//					,sourceEntry->GetUserName(),m_iSourceIDIndex,userID);
//#endif
		}//end while-loop
#ifdef _DEBUG
		if(sendUDPRequest && countUDP > 0)TRACE("###############################################\n%i UDP-Source-Requests for %s were sended\n###############################################\n",countUDP,GetFileName());
#endif
	}//end if(storedSources != NULL)
After_Loading:
	//for 'slow-loading' the sources
	bool isCompletelyLoaded = true;
	if(storedSources != NULL){

		m_iSourceIndex = storedSources->GetSourceIndex();

		//are all sources from the CStoredSources-object loaded?
		if(m_iSourceIndex +1 >= storedSources->GetCountSourceEntrys())
			isCompletelyLoaded = true;
		else
			isCompletelyLoaded = false;

		m_bLoadedSourcesCompletely = isCompletelyLoaded;

		//TRACE("Added the next %i sources up to source-index %u for %s\n"
		//		, (limit != -1?limit: (-1))
		//		, m_iSourceIndex
		//		, GetFileName());
	}

	//set timers
	if(limit != -1){
#ifdef _DEBUG_SAVED_SOURCES
		if(storedSources != NULL) TRACE("Slow-loading %s (No. %u of %u): %u secs since last call\n"
				, GetFileName()
				, m_iSourceIndex
				, storedSources->GetCountSourceEntrys()
				,(::GetTickCount() - m_iLastTimeSourcesLoadedPartial)/1000);
#endif
		
		m_iLastTimeSourcesLoadedPartial = ::GetTickCount();
		if(isCompletelyLoaded){
#ifdef _DEBUG_SAVED_SOURCES
			if(storedSources != NULL) TRACE("Slow-loading %s: all sources (%u of %u) were loaded once again since %.02f min. ago\n"
					, GetFileName()
					, m_iSourceIndex
					, storedSources->GetCountSourceEntrys()
					, (float(::GetTickCount() - m_iLastTimeSourcesLoaded)/60000));
#endif
		
			m_iLastTimeSourcesLoaded = ::GetTickCount();
		}
	}
	else{
#ifdef _DEBUG_SAVED_SOURCES
		TRACE("Normal-loading %s: all sources (%u) were loaded once again since %.02f min. ago\n"
					, GetFileName()
					, m_iSourceIndex
					, (float(::GetTickCount() - m_iLastTimeSourcesLoaded)/60000));
#endif
		m_iLastTimeSourcesLoaded = ::GetTickCount();
	}
	
	//TRACE("End of trying to add sources from StoredSource (AddFromStoredSources)\n");
	if (isCompletelyLoaded) m_iLoadingSourcesTimeInterval = RESTORE_SOURCES_TIME ; // Added by Tarod

	return isCompletelyLoaded;

	EMULE_CATCH

	return false;
}

bool CPartFile::LoadAndAddSources(bool keepSourcesOpen, bool sendUDPRequest
									, int limit, bool reset, bool debug,bool addImmediately)
{
	EMULE_TRY

	//if this part file is paused or complete/completing no sources needed any more
	if(GetStatus()==PS_PAUSED || GetStatus() > 7)		//Cax2 + SyruS check
		return false;

	CStoredSources* storedSources = NULL;
	if((storedSources = LoadSourcesFromFile(debug)) == NULL){
		if(m_stscrStoringSources == NULL){
				m_stscrStoringSources = new CStoredSources(GetPartMetFileName()
													, GetFileName()
													, GetFileHash()
													, theApp.glob_prefs->GetMaxSourcePerFileSoft());
				//set the preferences for the StoredSources
				m_stscrStoringSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
												, m_iLoadSourcesAtOnceLimit
												, m_iLoadingSourcesTimeInterval
												, m_iLoadingSourcesPartialTimeInterval
												, m_iSavingSourcesTimeInterval);
		}
		return false;
	}
	//if successfully loaded:
	else{
		if(addImmediately)AddFromStoredSources(storedSources, sendUDPRequest, limit, reset, debug);

#ifdef _DEBUG_SAVED_SOURCES
		TRACE("There were %u sources loaded from disk for %s are %s\n"
				,storedSources->GetCountOfSources()
				,GetFileName()
				,((keepSourcesOpen&& theApp.downloadqueue->KeepStoredSourcesOpen())?"kept open!":"not kept open!"));
#endif
		if(keepSourcesOpen && theApp.downloadqueue->KeepStoredSourcesOpen()){
			if(m_stscrStoringSources == NULL){
				m_stscrStoringSources = new CStoredSources(GetPartMetFileName()
													, GetFileName()
													, GetFileHash()
													, theApp.glob_prefs->GetMaxSourcePerFileSoft());
				//set the preferences for the StoredSources
				m_stscrStoringSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
												, m_iLoadSourcesAtOnceLimit
												, m_iLoadingSourcesTimeInterval
												, m_iLoadingSourcesPartialTimeInterval
												, m_iSavingSourcesTimeInterval);
			}
			m_stscrStoringSources->UpdateSource(storedSources);
		}
		delete storedSources;
	}
    return true;

	EMULE_CATCH

	return false;
}

bool CPartFile::SaveToStoredSources(CUpDownClient* toSave)
{
	EMULE_TRY

	if(!theApp.downloadqueue->IsSourcesLoadingEnabled())
		return false;

	if(m_stscrStoringSources == NULL){
		m_stscrStoringSources = new CStoredSources(GetPartMetFileName()
											, GetFileName()
											, GetFileHash()
											, theApp.glob_prefs->GetMaxSourcePerFileSoft());
		//set the preferences for the StoredSources
		m_stscrStoringSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
										, m_iLoadSourcesAtOnceLimit
										, m_iLoadingSourcesTimeInterval
										, m_iLoadingSourcesPartialTimeInterval
										, m_iSavingSourcesTimeInterval);
	}
#ifdef _DEBUG_SAVED_SOURCES
	uint32 oldCount = m_stscrStoringSources->GetCountOfSources();
#endif
	uint16 partsCount = 0;
	CString userName;
	partsCount	= toSave->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
	// userName	= (toSave->GetUserName() != NULL ? toSave->GetUserName(): NONAME);//check, if the user-name of this user is set/known
	userName.Format(_T(LOADEDSOURCEMARK)_T("%u"), toSave->GetUserID());
	m_stscrStoringSources->UpdateSource(userName
													, toSave->GetUserPort()
													, toSave->GetUserID()
													, toSave->GetServerIP()
													, toSave->GetServerPort()
													, partsCount);
#ifdef _DEBUG_SAVED_SOURCES
	TRACE("CPartFile::SaveToStoredSources(...) : source was %s to %s's StoredSources (count (old/new): %u/%u\n\n"
		, (m_stscrStoringSources->FindSource(userName,toSave->GetServerPort())?"saved":"not saved")
		, GetFileName()
		, oldCount
		, m_stscrStoringSources->GetCountOfSources());
#endif
	return true;

	EMULE_CATCH

	return false;
}

bool CPartFile::SaveToStoredSources()
{
	EMULE_TRY

	if(!theApp.downloadqueue->KeepStoredSourcesOpen())
		return false;

	bool successful=false;
	if(m_stscrStoringSources == NULL){
		m_stscrStoringSources = new CStoredSources(GetPartMetFileName()
										, GetFileName()
										, GetFileHash()
										, theApp.glob_prefs->GetMaxSourcePerFileSoft());
		//set the preferences for the StoredSources
		m_stscrStoringSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
											, m_iLoadSourcesAtOnceLimit
											, m_iLoadingSourcesTimeInterval
											, m_iLoadingSourcesPartialTimeInterval
											, m_iSavingSourcesTimeInterval);
	}
#ifdef _DEBUG_SAVED_SOURCES
	uint32 oldCount = m_stscrStoringSources->GetCountOfSources();
#endif
	uint16 partsCount = 0;
	CString userName;
	CUpDownClient* source;
	successful = false;	//just to be sure
    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
    for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
		source = srclists[sl].GetNext(posOfSource);
		partsCount = source->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
		// userName = (source->GetUserName() != NULL ? source->GetUserName(): NONAME);//check, if the user-name of this user is set/known
		userName.Format(_T(LOADEDSOURCEMARK)_T("%u"), source->GetUserID());
		m_stscrStoringSources->UpdateSource(userName, source->GetUserPort(), 
									source->GetUserID(), source->GetServerIP(), 
									source->GetServerPort(), partsCount);
		successful=true;
	}
#ifdef _DEBUG_SAVED_SOURCES
	TRACE("CPartFile::SaveToStoredSources() : all current sources of %s were %s to its StoredSources (count (old/new): %u/%u\n\n"
		, GetFileName()
		, successful?"saved":"not saved"
		, oldCount
		, m_stscrStoringSources->GetCountOfSources());
#endif
	return successful;

	EMULE_CATCH

	return false;
}

bool CPartFile::SaveSources(bool loadSourcesFirst)
{
	EMULE_TRY

	if(m_stscrStoringSources == NULL)
		return false;

	bool successful=false;
	if(theApp.downloadqueue->KeepStoredSourcesOpen() && theApp.downloadqueue->IsSourcesLoadingEnabled())
	{
		if(!SaveToStoredSources() && m_stscrStoringSources->GetCountOfSources() < 1) 
			return false;

#ifdef _DEBUG_SAVED_SOURCES
		TRACE("%u sources for %s are about to be saved to disk\n"
				,m_stscrStoringSources->GetCountOfSources()
				,GetFileName());
#endif

		//no need to load the file again, because all its informations
		//are already in m_stscrStoringSources
		//no need to gather all sources from scrlist, because everytime
		//a source is added there, it is also added to m_stscrStoringSources
		//(see CDownloadQueue::CheckAndAdd[Known]Source(...))
		SaveSourcesToFile(m_stscrStoringSources);
		successful = true;
	}
	else if(theApp.downloadqueue->IsSourcesLoadingEnabled()){
		CStoredSources* storedSources = NULL;

		if(loadSourcesFirst){
			storedSources = LoadSourcesFromFile();
		}
		if(storedSources == NULL){
			storedSources = new CStoredSources(GetPartMetFileName()
											, GetFileName()
											, GetFileHash()
											, theApp.glob_prefs->GetMaxSourcePerFileSoft());
			//set the preferences for the StoredSources
			storedSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
												, m_iLoadSourcesAtOnceLimit
												, m_iLoadingSourcesTimeInterval
												, m_iLoadingSourcesPartialTimeInterval
												, m_iSavingSourcesTimeInterval);
		}
		uint16 partsCount = 0;
		CString userName;
		CUpDownClient* source;
		successful = false;	//just to be sure
        for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
			source = srclists[sl].GetNext(posOfSource);
			partsCount = source->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
			// userName = (source->GetUserName() != NULL ? source->GetUserName(): NONAME);//check, if the user-name of this user is set/known
			userName.Format(_T(LOADEDSOURCEMARK)_T("%u"), source->GetUserID());
			storedSources->UpdateSource(userName, source->GetUserPort(), 
										source->GetUserID(), source->GetServerIP(), 
										source->GetServerPort(), partsCount);
			successful=true;
		}
		
		//if(debug) AddLogLine(false,"All Sources of '%s' (%s) were gathered for saving to disk",GetFileName(),GetPartMetFileName());

		if(successful){
			SaveSourcesToFile(storedSources);
#ifdef _DEBUG_SAVED_SOURCES
			TRACE("%u sources for %s were saved to disk with no permanent open StoredSources-object\n"
					,storedSources->GetCountSourceEntrys()
					,GetFileName());
#endif
		}
		delete storedSources;
	}
	else if(!theApp.downloadqueue->IsSourcesLoadingEnabled()){
		CStoredSources* storedSources = LoadSourcesFromFile();

		if(storedSources == NULL){
			storedSources = new CStoredSources(GetPartMetFileName()
											, GetFileName()
											, GetFileHash()
											, theApp.glob_prefs->GetMaxSourcePerFileSoft());
			//set the preferences for the StoredSources
			storedSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
												, m_iLoadSourcesAtOnceLimit
												, m_iLoadingSourcesTimeInterval
												, m_iLoadingSourcesPartialTimeInterval
												, m_iSavingSourcesTimeInterval);
		}
		uint16 partsCount = 0;
		CString userName;
		CUpDownClient* source;
		successful = false;	//just to be sure
        for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
			source = srclists[sl].GetNext(posOfSource);
			partsCount = source->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
			// userName = (source->GetUserName() != NULL ? source->GetUserName(): NONAME);//check, if the user-name of this user is set/known
			userName.Format(_T(LOADEDSOURCEMARK)_T("%u"), source->GetUserID());
			storedSources->UpdateSource(userName, source->GetUserPort(), 
										source->GetUserID(), source->GetServerIP(), 
										source->GetServerPort(), partsCount);
			successful=true;
		}
		
		//if(debug) AddLogLine(false,"All Sources of '%s' (%s) were gathered for saving to disk",GetFileName(),GetPartMetFileName());

		if(successful){
			SaveSourcesToFile(storedSources);
#ifdef _DEBUG_SAVED_SOURCES
			TRACE("%u sources for %s were saved to disk while loading of sources is disabled\n"
					,storedSources->GetCountSourceEntrys()
					,GetFileName());
#endif
		}
		delete storedSources;
	}
	return successful;

	EMULE_CATCH

	return false;
}
#endif //OLD_SLS_ENABLED

d3977 2
a3978 1
	&& i_Source < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()){ // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
a3979 1
		if(newsource == NULL) 	return; //???
d3989 1
a3989 13
	else {
		if(theApp.downloadqueue->IsSourcesLoadingEnabled()) {
			CString strName;
			CUpDownClient* newsource = new CUpDownClient(source->sourcePort,source->sourceID,source->serverIP,source->serverPort,this);
			strName.Format(_T(EXCHANGEDSOURCEMARK)_T("%u"), source->sourceID);
#ifdef OLD_SLS_ENABLED
			if(m_stscrStoringSources != NULL)
				m_stscrStoringSources->UpdateSource(strName, source->sourcePort,source->sourceID,source->serverIP,source->serverPort, newsource->GetAvailableOfNeededPartsCount());
#endif //OLD_SLS_ENABLED
			delete newsource;
		}
	}
	
@


1.190
log
@Corrected problem with ' and JS in new WS context menu
Removed unused code for SLS
@
text
@d1684 2
a1685 2
			{
				CUpDownClient* cur_src = srclists[sl].GetAt(pos);
@


1.189
log
@A4AF fix (reset A4AF auto if file was completed)
@
text
@a219 1
	m_dwlastTimeActivated = 0;			//<<-- enkeyDEV(kei-kun) -SLS preferences-
d1695 1
a1695 2
			if (m_sourcesaver.Process(this, theApp.glob_prefs->SLSMaxSourcesPerFile())) //<<-- enkeyDEV(Ottavio84) -New SLS-			
				m_dwlastTimeActivated = ::GetTickCount();
@


1.188
log
@A4AF fix (switching if file was completed)
@
text
@d2266 2
@


1.187
log
@Removed debug log line for ICR-Test.
@
text
@d2265 2
a2266 1
	} 
@


1.186
log
@WebServer: corrected problem with priorities [BavarianSnail]
@
text
@d2135 1
a2135 1
	AddDebugLogLine(false,"ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), i_AvailableNeededParts, m_CurBlockedParts.GetCount(),goodpart);
@


1.185
log
@ *.part.met was't closed after loading (aka "corrupted file problem")
@
text
@d2447 1
d2451 3
a2453 2
 		AddLogLine(true,IDS_FAILDELETE,srcName); 
    
d2558 1
d2562 1
@


1.184
log
@fix in ICR 2.10
@
text
@d348 1
a348 1
			if (file!= INVALID_HANDLE_VALUE) file.Close();
@


1.183
log
@now using Ottavios SLS system [netwolf]
@
text
@d1974 1
a1974 1
		if (sender->IsPartAvailable(i) == true && (IsCorruptedPart(i) || GetBytesInPart(i,true,true) != 0)) // don't recalculte parts setted as full 
@


1.182
log
@ICR 2.10 (fixed bug zip-stream)
@
text
@d220 1
d1693 8
d1830 1
a1830 1
	if (theApp.glob_prefs->IsRemoveNNSEnabled())
d2442 4
d2570 3
d3376 1
a3376 1
	if (theApp.glob_prefs->IsRemoveNNSEnabled())  //Vorlost added prefs question
d3387 1
a3387 1

@


1.181
log
@sessiontime starts on resuming for initialy paused files (for avg datarate)
@
text
@d291 6
a296 4
	
	m_SrcpartFrequency.SetSize(GetPartCount());
	m_BlockedParts.SetSize(GetPartCount());	// eklmn: ICR 2.9
	for (uint32 i = 0; i != GetPartCount();i++) {
d299 1
d518 5
a522 3
	m_SrcpartFrequency.SetSize(GetPartCount());
	m_BlockedParts.SetSize(GetPartCount());
	for (uint32 i = 0; i != GetPartCount();i++) {
d525 1
d1923 1
a1923 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.9 1.07.2003) for eMule+
a1963 1
	m_ReqParts.SetSize(partCount);
d1965 4
a1968 27
		if (sender->IsPartAvailable(i) == true) {
			const uint32 uStart = i * PARTSIZE;
			const uint32 uEnd   = ((GetFileSize() - 1) < (uStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uStart + PARTSIZE - 1);
			m_ReqParts[i] = uEnd -uStart + 1;
			if (i == partCount-1) LastPartSize = m_ReqParts[i];
			for (POSITION pos = gaplist.GetHeadPosition(); pos != 0; gaplist.GetNext(pos) ) {
				Gap_Struct* cur_gap = gaplist.GetAt(pos);
				// Check if Gap is into the limit
				if (cur_gap->end < uStart || cur_gap->start > uEnd) continue;
				if (cur_gap->start <= uStart && cur_gap->end > uStart && cur_gap->end < uEnd) {
					m_ReqParts[i]-= cur_gap->end - uStart;
					continue;
				}
				if (cur_gap->start >= uStart && cur_gap->end <= uEnd) {
					m_ReqParts[i] -= cur_gap->end - cur_gap->start;
					continue;
				}
				if (cur_gap->start <= uStart && cur_gap->end >= uEnd) {
					m_ReqParts[i] = 0;
					continue;
				}
				if (cur_gap->start > uStart && cur_gap->start < uEnd && cur_gap->end >= uEnd) {
					m_ReqParts[i]-= uEnd - cur_gap->start;
				}
			}
			if ((i ==(partCount-1) && m_ReqParts[i] != LastPartSize) 
				|| (i !=(partCount-1) && m_ReqParts[i] != PARTSIZE)) i_AvailableNeededParts++;
d1985 3
a1987 3
       uint32 m_MostCompletedUniqueReqPart = 0;
	uint32 m_MostCompletedRarestReqPart = 0;
	uint32 m_MostCompletedReqPart = 0;
d1989 2
a1990 2
		if ( (i ==( partCount-1) && m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != LastPartSize)
			|| (i != ( partCount-1) && m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != PARTSIZE)) {
d1994 1
a1994 1
				if (m_ReqParts[i] < BLOCKSIZE) // limit change to prevent consecutive download due overlaping
d1997 1
a1997 1
					if (m_ReqParts[i] > m_MostCompletedUniqueReqPart) {
d2005 1
a2005 1
				if (m_ReqParts[i] == 0) {
d2009 1
a2009 1
					if (m_ReqParts[i] > m_MostCompletedRarestReqPart) {
d2040 2
a2041 1
			if (m_ReqParts[i] == 0) {
d2046 4
a2049 2
			else {
				if (m_ReqParts[i] > m_MostCompletedReqPart) {
d2061 2
a2062 1
        if (m_MostCompletedUniqueReqPart != 0 && liMovieParts.IsEmpty()) {
d2067 2
a2068 1
        else if (!liUniqueParts.IsEmpty() && liMovieParts.IsEmpty()) {
d2072 2
a2073 1
			else {
d2082 2
a2083 1
        if (m_MostCompletedRarestReqPart != 0) {
d2088 2
a2089 1
        else if (liRarestParts.IsEmpty() == false) {
d2093 2
a2094 1
		else {
d2101 2
a2102 1
        else if (liMovieParts.IsEmpty() == false) {
d2109 2
a2110 1
        else if (m_MostCompletedReqPart != 0) {
d2116 2
a2117 1
        else if (liRandomParts.IsEmpty() == false) {
d2126 1
a2126 6
	if (goodpart != 0xFFFF) 
		n_BlocksToDownloadInPart = (uint16)floor((PARTSIZE-m_ReqParts[goodpart])/BLOCKSIZE);
	else
		n_BlocksToDownloadInPart = 0;

	//AddDebugLogLine(false,"ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), i_AvailableNeededParts, m_CurBlockedParts.GetCount(),goodpart);
d2142 64
a2205 1
// ^- eklmn: feature(00): Intelligent Chunk Request(ICR v2.9 1.07.2003) for eMule+
a4327 1

d4330 3
a4332 2
	const uint32 uStart = floor(start/PARTSIZE)* PARTSIZE;
	const uint32 uEnd   = ((GetFileSize() - 1) < (uStart + PARTSIZE - 1)) ? (GetFileSize() - 1) : (uStart + PARTSIZE - 1);
d4334 1
d4336 2
@


1.180
log
@1) *.part.met was't closed after loading (aka "corrupted file problem")
2) improved DL
3) ICR 2.9 (1.07.2003
4) check last part in WriteToBuffer correct way
@
text
@d217 1
d221 1
a221 2

    m_lastDownTransfer = CTime::GetCurrentTime();
d223 4
a226 3
	starttime = m_lastDownTransfer;
	startsize = 0;
	avgdatarate = 0;
d550 1
a550 1
        m_lastDownTransfer = filestatus.m_mtime;
d566 2
a567 1
	startsize = completedsize;
d2205 1
a2205 1

a2474 1

d2483 1
a2483 1
        // START - enkeyDEV(Ottavio84) -ChangeDir-
d2899 5
d3019 1
a3019 1
		//SyruS calc on last FlushBuffer() to keep sessionstats for completed files
d3021 7
a3027 1
			timespan = GetFlushTimeSpan();	//m_lastDownTransfer - starttime;
d3029 1
a3029 2
			timespan = GetTotalTimeSpan();	//CTime::GetCurrentTime() - starttime;
		avgdatarate = ( (completedsize - startsize + datarate) / (timespan.GetTotalSeconds() + 1) );
d3033 1
a3033 1
	return avgdatarate;
d4301 2
a4302 1
    m_lastDownTransfer = CTime::GetCurrentTime();
@


1.179
log
@by shutdown force OS flush data direct to disk [Eklmn]&[SlugFiller]
@
text
@d447 1
a447 1
		if (file != INVALID_HANDLE_VALUE) file.Close();
d1424 2
a1425 3
		for (pos1 = m_downloadingSourceList.GetHeadPosition(); (pos2 = pos1) !=NULL;){
			m_downloadingSourceList.GetNext(pos1);
			cur_src = m_downloadingSourceList.GetAt(pos2);
d1489 1
d1684 1
a1684 1
		// calculate datarate, set limit etc.
d1686 1
a1686 1
		if (count == 30)
d1915 1
a1915 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.8 20.06.2003) for eMule+
a1994 18
	/*
	// build local blocked list	 
	for (POSITION pos = BlockedParts.GetHeadPosition(); pos != NULL; BlockedParts.GetNext(pos)){
		DownloadedParts Client_Part = BlockedParts.GetAt(pos);
		if ((srclists[Client_Part.sourcesslot].Find(Client_Part.Client) == 0) ||
			(Client_Part.Client->GetDownloadState() != DS_DOWNLOADING)) {	// if client doesn't exist, then delete it from the list						
			POSITION pos1 = pos;			
			BlockedParts.GetPrev(pos);
			BlockedParts.RemoveAt(pos1);
			if (pos == NULL) 
				break;	//Removed element was one and only
		} else {
			if (!m_CurBlockedParts.Find(Client_Part.part))
				m_CurBlockedParts.AddHead(Client_Part.part);
		}
	}
	*/

a2116 2
			/*DownloadedParts NewPart = {sender,goodpart, sender->sourcesslot};
			BlockedParts.AddHead(NewPart);*/
a2123 2
			// DownloadedParts NewPart = {sender,goodpart, sender->sourcesslot};
			// BlockedParts.AddHead(NewPart);
d2151 1
a2151 1
// ^- eklmn: feature(00): Intelligent Chunk Request(ICR v2.8 20.06.2003) for eMule+
d4265 2
d4268 5
a4272 4

		uint16 ps = start/PARTSIZE;
	if (IsComplete(ps*PARTSIZE, (ps+1)*PARTSIZE-1))
		FlushBuffer();	//netwolf end
d5041 1
a5041 1
	if(pos == NULL){
@


1.178
log
@1) fixed possible exception during a scan of srclist;
2) fixed download timeouts (::Process is rewritten)
3) ICR 2.9
@
text
@d27 1
d710 2
d1421 2
a1422 2
	// 8 iteration for download & 2 iteration for other files
	if (iteration < 9 && !m_downloadingSourceList.IsEmpty())
@


1.177
log
@FEATURE: show average sessionspeed and total sessiontime for completed files [SyruS]
final smoothed remaining time
@
text
@d291 2
a292 1
	for (uint32 i = 0; i != GetPartCount();i++)
d294 2
d514 2
a515 1
	for (uint32 i = 0; i != GetPartCount();i++)
d517 2
d1398 2
d1402 2
a1403 1
	if ((m_nTotalBufferData > ((uint32)theApp.glob_prefs->GetFileBufferSize())*30000) || (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT))) //netwolf: increased FileBufferSize
a1409 19
	// check if we want new sources from server
	//uint16 test = theApp.glob_prefs->GetMaxSourcePerFileSoft();
#ifdef OLD_SOCKETS_ENABLED
	if (( (!lastsearchtime) || (dwCurTick - lastsearchtime) > SERVERREASKTIME) && theApp.serverconnect->IsConnected()
		&& theApp.glob_prefs->GetMaxSourcePerFileSoft() > GetSourceCount() ){
		//local server
		lastsearchtime = dwCurTick;
		Packet* packet = new Packet(OP_GETSOURCES,16);
		#ifndef AMD
		md4cpy(packet->pBuffer,filehash);
		#else
		memcpy_amd(packet->pBuffer,filehash,16);
		#endif
		theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
		theApp.serverconnect->SendPacket(packet,true);
		//AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
	}
#endif //OLD_SOCKETS_ENABLED

d1416 32
a1447 2
	POSITION pos1, pos2;
	for (uint32 sl = 0; sl < SOURCESSLOTS; sl++)
d1449 23
a1471 1
		if (!srclists[sl].IsEmpty())
d1473 1
a1473 1
			for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
d1475 24
a1498 20
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);

        if( (iteration!=0) && (cur_src->GetDownloadState() != DS_DOWNLOADING) )
            continue;

        uint32 usethisfilereasktime = FILEREASKTIME;

        switch (cur_src->GetDownloadState())
		{
		case DS_DOWNLOADING:{
			transferingsrc++;
			uint32 cur_datarate = max(cur_src->CalculateDownloadRate(), 0);
			datarate += cur_datarate;
			if (reducedownload && cur_src->GetDownloadState() == DS_DOWNLOADING){
							uint32 limit = reducedownload*cur_datarate/1000; //(uint32)(((float)reducedownload/100)*cur_datarate)/10;		
					if (limit < 1000 && reducedownload == 200)
						limit += 1000;
					else if (limit < 1)
						limit = 1;
d1500 1
a1500 1
					cur_src->socket->SetDownloadLimit(limit);
d1502 1
a1502 1
			}
d1504 2
a1505 2
			else if( m_nSavedReduceDownload != reducedownload )
				cur_src->socket->DisableDownloadLimit();
d1507 5
a1511 11
			m_nSavedReduceDownload  = reducedownload;

			break;
		}
		case DS_BANNED:
		case DS_ERROR:
			break;
		case DS_LOWTOLOWIP:	// if we now have a high ip we can ask
			if( ((dwCurTick - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
				theApp.downloadqueue->RemoveSource(cur_src);
				lastpurgetime = dwCurTick;
d1513 8
a1520 1
			}
d1522 2
a1523 2
			if (theApp.serverconnect->IsLowID())
				break;
d1525 49
a1573 43
		case DS_NONEEDEDPARTS:{ 
			if( ((dwCurTick - lastpurgetime) > 40000) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) )
				if( !cur_src->SwapToAnotherFile(NULL,true) ){	//eklmn: bugfix(08): A4AF switching
					theApp.downloadqueue->RemoveSource(cur_src);
					lastpurgetime = dwCurTick;

					break; 
				}

			// doubled reasktime for no needed parts - save connections and traffic
			//Vorlost, noneededparts-sources will be checked filereasktime*4 when 3/4 of max. sockets are open 
			if (sockets_usage_high)
				usethisfilereasktime = FILEREASKTIME * 2;
			//End Vorlost for Expanded Filereasktime 

			// doubled reasktime for no needed parts - save connections and traffic
			if (!((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime*2))
				break;
		}
		case DS_ONQUEUE:{
			if( cur_src->IsRemoteQueueFull() )
				if( ((dwCurTick - lastpurgetime) > 60000) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
					theApp.downloadqueue->RemoveSource( cur_src );
					lastpurgetime = dwCurTick;
					break;
				}

			if ( cur_src->GetRemoteQueueRank()
		        && sockets_usage_high
		        ) { //Vorlost QueueRank > 250 --> Filereasktime=45minutes
		        if ( cur_src->GetRemoteQueueRank() > 250 )
			        usethisfilereasktime = FILEREASKTIME * 2.5 ; //Vorlost
		        else usethisfilereasktime = FILEREASKTIME * 2; //Vorlost (QR 1-250 = 36minutes)

	        }

			// LANCAST (moosetea) - We reask much faster if lancast user, UDP happens in 10 seconds
			if (cur_src->isOnLAN()){
				if ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMEUDP){
					cur_src->UDPReaskForDownload();
				}
			}
			else {
d1575 6
a1580 3
				if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime-20000)){
					cur_src->UDPReaskForDownload();
				}
d1582 1
a1582 1
			}
d1584 2
a1585 2
			// START enkeyDEV(th1) -L2HAC- highid side, "prepare" phase
			// (emulates a "Connecting via server..." without socket timeout)
d1587 9
a1595 9
			if (theApp.serverconnect->IsConnected()
				&& (cur_src->GetLastAskedTime())
				&& ((dwCurTick - cur_src->GetLastAskedTime()) > (FILEREASKTIME - L2HAC_PREPARE_PRECEDE))
				&& cur_src->HasLowID()
				&& cur_src->GetL2HACTime()
				&& !theApp.serverconnect->IsLowID())
			{
				cur_src->SetDownloadState(DS_WAITCALLBACK);
			}
d1597 29
a1625 23
			// END enkeyDEV(th1) -L2HAC-
			
			// Check Remote queue position
			if ((theApp.glob_prefs->UseRemoteQueueLimit() && !cur_src->IsRemoteQueueFull()) && (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetRemoteQueueLimit())) {
				theApp.downloadqueue->RemoveSource(cur_src);
                break;
			}
		}
		case DS_CONNECTING:
		case DS_TOOMANYCONNS:
		case DS_CONNECTED:
		case DS_NONE:
		case DS_WAITCALLBACK:

			// LANCAST (moosetea) - Because reask much faster if lancast user ie we may reask as soon as we get disconnected
			// , we only use TCP on a LAN, because emule may try to send a TCP request and UDP request at the same time!
			if (cur_src->isOnLAN()){
				if ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMETCP){
					cur_src->AskForDownload();
				}
			}
			else {
				//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
d1627 6
a1632 2
				if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime))
					cur_src->AskForDownload();
d1634 43
a1677 1
			break;
d1679 1
a1679 3
	}
        }
    }
d1681 10
a1690 31

	// swap No needed partfiles if possible
	// v:- eklmn: A4AF management
	// Modified by Tarod -now handles A4AF too keeping usage of CPU less and do not forcing files
	// that has No Needed Parts to download letting them swap to another file
	if (((!m_LastNoNeededCheck) || (dwCurTick - m_LastNoNeededCheck) > 10000)){
		m_LastNoNeededCheck = dwCurTick;
		for (int sl=0;sl<SOURCESSLOTS;sl++) 
			if (!srclists[sl].IsEmpty())
				for (POSITION pos = srclists[sl].GetHeadPosition(); pos != 0; srclists[sl].GetNext(pos)) {
					CUpDownClient* cur_src = srclists[sl].GetAt(pos);
					// check if current source has a part for this file
					if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS) {
						// check if A4AF Auto file is enable
						if (theApp.downloadqueue->GetA4AFAutoFile() == NULL)
							// A4AF auto is disable => switch to any file
							cur_src->SwapToAnotherFile(NULL,true);	//eklmn: bugfix(08): A4AF switching
						else if (theApp.downloadqueue->GetA4AFAutoFile() != this)
							// A4AF auto is enable & isn't current file => switch to A4AF auto file
							cur_src->SwapToAnotherFile(theApp.downloadqueue->GetA4AFAutoFile());
					}
				} // end for (pos =
	} // end if
	
	// if this "File" is A4AF auto & A4AF list isn't empty,
	// then check A4AF list and swap source to "this", if souce isn't NNS
	if (!A4AF_srclist.IsEmpty() && theApp.downloadqueue->GetA4AFAutoFile() == this) {
		for (POSITION pos = A4AF_srclist.GetHeadPosition(); pos != 0; A4AF_srclist.GetNext(pos)) {
			CUpDownClient* cur_src = srclists[sl].GetAt(pos);
			if (cur_src->m_OtherNoNeeded_list.Find(this) == 0)
				cur_src->SwapToAnotherFile(this);
a1692 12
	// ^- eklmn: A4AF management

	// calculate datarate, set limit etc.
	count++;
	if (count == 30){
		count = 0;
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		UpdateDisplayedInfo();
		if(m_bPercentUpdated == false)
			UpdateCompletedInfos();
		m_bPercentUpdated = false;
	}
d1874 1
d1877 3
a1879 2
			for (POSITION pos = srclists[sl].GetHeadPosition(); pos != 0; srclists[sl].GetNext(pos)){
				cur_src = srclists[sl].GetAt(pos);
d1917 1
a1917 1
	if(sender == NULL)
d1923 1
d1985 5
d1992 1
d2008 1
a2008 1
	
d2070 1
a2070 1
			if ( m_CurBlockedParts.Find(i) != 0 && i_AvailableNeededParts>m_CurBlockedParts.GetCount()) continue;
d2132 3
a2134 2
			DownloadedParts NewPart = {sender,goodpart, sender->sourcesslot};
			BlockedParts.AddHead(NewPart);
d2141 3
a2143 2
			DownloadedParts NewPart = {sender,goodpart, sender->sourcesslot};
			BlockedParts.AddHead(NewPart);
a3199 1
	int sl;
d3204 3
d3210 17
a3226 11
	bool bNeeded;
	for (sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;srclists[sl].GetNext(pos)){
		bNeeded = false;
		CUpDownClient* cur_src = srclists[sl].GetAt(pos);

		// Modified by Tarod -sends sources with LowID that are in same sever
		// that client is requesting sources
		if (cur_src->HasLowID() 
			&& (cur_src->GetServerIP() != forClient->GetServerIP() || cur_src->GetServerPort() != forClient->GetServerPort()))
			continue;
d3228 2
a3229 3
		// LANCAST (moosetea) - We don't share Lan clients sources as they are private ips/userids
		if (cur_src->isOnLAN())
			continue;
d3231 11
a3241 10
		// Added by Tarod, do not send incomplete established conns. to avoid sending
		// no valid sources
		switch (cur_src->GetDownloadState()) {
			case DS_NONE:
			case DS_CONNECTING:
			case DS_ERROR:
			case DS_TOOMANYCONNS:
			continue;
				break;
		}
d3243 13
a3255 8
		// only send source which have needed parts for this client if possible
		if (forClient->reqfile == this && forClient->GetPartStatus() && cur_src->GetPartStatus()){
			uint8* reqstatus = forClient->GetPartStatus();
			uint8* srcstatus = cur_src->GetPartStatus();
			for (int x = 0; x != GetPartCount(); x++){
				if (srcstatus[x] && !reqstatus[x]){
					bNeeded = true;
					break;
d3257 10
a3266 9
			}
		}
		
		else if (cur_src->GetPartStatus()){	//netwolf 04.05.03
				uint8* srcstatus = cur_src->GetPartStatus();
				for (int x = 0; x < GetPartCount(); x++){
				if (srcstatus[x]){
					bNeeded = true;
					break;
d3268 15
d3284 2
a3285 15
			}								// netwolf end
		if( bNeeded ){
                    nCount++;
                    uint32 dwID = cur_src->GetUserID();
                    uint16 nPort = cur_src->GetUserPort();
                    uint32 dwServerIP = cur_src->GetServerIP();
                    uint16 nServerPort = cur_src->GetServerPort();
                    data.Write(&dwID,4);
                    data.Write(&nPort,2);
                    data.Write(&dwServerIP,4);
                    data.Write(&nServerPort,2);
    		if (nCount > 500)
    			break;
            }
	}
d5039 1
a5039 1
	AddDebugLogLine(false, _T("Total %u A4AF sources before swap"), A4AF_srclist.GetCount());
d5054 15
@


1.176
log
@New A4AF mangement
@
text
@a2819 3
	//bond006 (smoothed "remaining time" calculation) //SyruS
	//starttime = m_lastDownTransfer;
	//startsize = completedsize;
a2832 5
	if (paused)
	{	//bond006 (smoothed "remaining time" calculation) //SyruS
		starttime = CTime::GetCurrentTime();
		startsize = completedsize;
	}
d2923 1
a2923 1
sint32 CPartFile::GetTimeRemaining(bool GetOldValue /*=true*/)
d2929 3
a2931 1
	if (GetOldValue)	//original calculation
a2932 3
	else	//bond006 (smoothed "remaining time" calculation) //SyruS
		DataRate = GetAvgDatarate();
	//common calculations
d2942 1
a2942 1
void CPartFile::UpdateAvgDatarate() {
d2945 1
a2945 1
	if (starttime < m_lastDownTransfer)	//SyruS startdelay - wait till first FlushBuffer()
d2947 6
a2952 1
		CTimeSpan timespan = CTime::GetCurrentTime() - starttime;
d2957 1
a4206 2
	UpdateAvgDatarate();	//bond006 (smoothed "remaining time" calculation) //SyruS
	//int partCount = filesize / PARTSIZE;
a4208 1
	
@


1.175
log
@unicode cleanup
@
text
@a206 1
	m_is_A4AF_auto = false;
d1577 1
d1582 24
a1605 18
		POSITION pos1,pos2;
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
			if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS)
				cur_src->SwapToAnotherFile(NULL,true);	//eklmn: bugfix(08): A4AF switching
			// if this file has activated A4AF auto just hang to another file if we can
			else if (IsA4AFAuto() && (cur_src->GetDownloadDatarate() == DS_ONQUEUE || cur_src->GetDownloadDatarate() == DS_LOWTOLOWIP)
				&& md4cmp(cur_src->reqfileid, GetFileHash()) != 0) {

					cur_src->SwapToAnotherFile(this);	//eklmn: bugfix(08): A4AF switching
			}
		}

		// Added by Tarod -if is A4AF auto then swith every A4AF source to this file
		if (IsA4AFAuto()) {
			theApp.emuledlg->transferwnd.downloadlistctrl.DownloadAllA4AF(this);
d1608 1
a1608 17

/*
	// Added by Tarod (remove no needed parts after FILEREASKTIME * 2 + 10000)
	if (theApp.glob_prefs->GetMaxSourcePerFileSoft() == GetSourceCount()
		&& theApp.glob_prefs->IsRemoveNNSEnabled() //Vorlost
	    && ((m_LastRemovedTime == 0) || (::GetTickCount() - m_LastRemovedTime) > FILEREASKTIME * 2 + 10000))
	{
		m_LastRemovedTime = ::GetTickCount();
		RemoveNoNeededSources();
	}
	else if (theApp.glob_prefs->IsRemoveNNSEnabled() 
	         && ((m_LastRemovedTime == 0) || (::GetTickCount() - m_LastRemovedTime) > FILEREASKTIME * 2 + 10000))
	{
		m_LastRemovedTime = ::GetTickCount();
		RemoveNoNeededSources();
	}
*/
a3869 27
// Sets this file as an A4AF auto
//
// [In]
//   in_A4AF_auto: true -> Set this file as A4AF auto
//                 false-> Unset this file as A4AF auto
//
// [Global]
//   in_A4AF_auto: true -> File hash is copied into prefs->A4AF_file_hash
//                 false-> "Null" hash is copied into prefs->A4AF_file_hash
void CPartFile::SetA4AFAuto(bool in_A4AF_auto)
{
	EMULE_TRY

	m_is_A4AF_auto = in_A4AF_auto;

	// Set file hash
	if (in_A4AF_auto) {
		theApp.glob_prefs->SetA4AFHash(GetFileHash());
	} else {
		// Set null hash
		uchar null_hash[16];
		memset(null_hash, 0, sizeof(null_hash));
		theApp.glob_prefs->SetA4AFHash(null_hash);
	}

	EMULE_CATCH
}
d4939 21
@


1.174
log
@last change reverted
@
text
@d657 2
a658 2
		char namebuffer[10];
		char *number = &namebuffer[1];
d661 1
a661 1
			itoa(i_pos,number,10);
d2309 1
a2309 1
	if (_stat(newname, &st) == 0)
d3009 1
a3009 1
			ShellExecute(NULL, "open",player, shortPath, runDir, SW_SHOWNORMAL);
d3253 1
a3253 1
		theApp.emuledlg->AddDebugLogLine(false, "Received invalid source exchange packet (v%u) of data size %u for %s\n", sourceexchangeversion, uDataSize, GetFileName());
d4022 1
a4022 1
	return remove(GetStatsFullPath());
@


1.173
log
@added GetStatsFullPath method
@
text
@d1998 1
a1998 1
			if ( m_CurBlockedParts.Find(i) != 0 && i_AvailableNeededParts>=m_CurBlockedParts.GetCount()) continue;
@


1.172
log
@ICR fix (thanks  netwolf for report)
@
text
@d3937 5
d3946 2
a3947 6

	TCHAR	fn[MAX_PATH];
	strcpy(fn, fullname);
	fn[strlen(fn)-4]=0;	// 4 = .met
	strcat(fn, ".stats");
	FILE	*fh=_tfopen(fn, _T("rb"));
d3984 1
a3984 2

	TCHAR	fn[MAX_PATH];
d3988 2
a3989 5
	}
	strcpy(fn, fullname);
	fn[strlen(fn)-4]=0;	// 4 = .met
	strcat(fn, ".stats");
	FILE	*fh=_tfopen(fn, _T("wb"));
d4021 2
a4022 9
	EMULE_TRY

	char	fn[MAX_PATH];
	strcpy(fn, fullname);
	fn[strlen(fn)-4]=0;	// 4 = .met
	strcat(fn, ".stats");
	
	return remove(fn);

@


1.171
log
@updated: smoothing time remaining & average downloadrate
@
text
@d1998 1
a1998 1
			if ( m_CurBlockedParts.Find(i) != 0 && i_AvailableNeededParts>m_CurBlockedParts.GetCount()) continue;
@


1.170
log
@CHANGE: added average downloadrate within brackets to speedcolumn [SyruS]
CHANGE: smoothed "remaining time" calculation by bond006 [SyruS]
@
text
@d225 1
d2831 2
a2832 2
	starttime = m_lastDownTransfer;
	startsize = completedsize;
d2846 5
a2855 3
	//bond006 (smoothed "remaining time" calculation) //SyruS
	starttime = CTime::GetCurrentTime();
	startsize = completedsize;
d2941 1
a2941 1
sint32 CPartFile::GetTimeRemaining()
d2945 9
a2953 9
	//if (GetDatarate()<=0) return -1;
	//return( (GetFileSize()-GetCompletedSize())/ GetDatarate());
	//bond006 (smoothed "remaining time" calculation) //SyruS
	uint32 avgRate = GetAvgDatarate();
	if (avgRate > 0)
	{
		sint32 timeRemaining = (GetFileSize()-GetCompletedSize()) / avgRate;
		return (timeRemaining <= 8640000 ? timeRemaining : -1);
	}
d2961 1
a2961 1
uint32 CPartFile::GetAvgDatarate() {
d2967 1
a2967 1
		return ( (completedsize - startsize + datarate) / (timespan.GetTotalSeconds() + 1) );
a2970 1
	return 0;
d4257 1
@


1.169
log
@ICR debug output switched off
@
text
@d222 3
d540 1
a540 1
		CFileStatus filestatus;
d557 2
d2829 3
d2850 3
a2852 1
	
d2942 9
a2950 3
	if (GetDatarate()<=0) return -1;
	
	return( (GetFileSize()-GetCompletedSize())/ GetDatarate());
d2957 14
a2986 1

@


1.168
log
@ICR fix (one bottle of beer go to DoubleT :) )
@
text
@d2074 1
a2074 1
	AddDebugLogLine(false,"ICR-Test: File: %s, A-parts : %u, B-Parts %u. Choosen Part: %u", this->GetFileName(), i_AvailableNeededParts, m_CurBlockedParts.GetCount(),goodpart);
@


1.167
log
@ICR fix (greetings to DoubleT)
@
text
@d1892 1
a1892 1
				if (cur_gap->start < uStart && cur_gap->end > uStart && cur_gap->end < uEnd) {
d1900 1
a1900 1
				if (cur_gap->start < uStart && cur_gap->end > uEnd) {
d1904 1
a1904 1
				if (cur_gap->start >= uStart && cur_gap->start < uEnd && cur_gap->end > uEnd) {
@


1.166
log
@added support for Source Exchange v2
@
text
@d1908 2
a1909 1
			if (m_ReqParts[i] != PARTSIZE || (i ==(partCount-1) && m_ReqParts[i] != LastPartSize)) i_AvailableNeededParts++;
d1943 1
a1943 1
			|| (m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != PARTSIZE)) {
@


1.165
log
@fix for fix (bah ;-) )
@
text
@d3184 3
a3186 1
void CPartFile::AddClientSources(CMemFile* sources)
d3191 2
a3192 2
	if(GetStatus()==PS_PAUSED || GetStatus() > 7)		//Cax2 + SyruS check
		return;
a3196 2
	//AddDebugLogLine(false, "RCV:Sources File(%s) Count(%i)", GetFileName(), nCount);

d3209 17
a3225 1
	for (int i = 0;i < nCount;i++){
d3230 4
a3233 2
		sources->Read(&source.serverPort,2);
		AddClientSource(&source, i,true);		// check first if we are this source //Cax2 - exchanged source
d3238 1
d4515 3
a4517 1
void CPartFile::AddClientSource(CClientSource* source, int i, bool exchanged) {
d4519 1
d4522 1
a4522 1
	if (theApp.serverconnect->GetClientID() < 16777216 && theApp.serverconnect->IsConnected()){
d4525 4
d4536 2
a4537 8

	CUpDownClient* newsource = new CUpDownClient(source->sourcePort,source->sourceID,source->serverIP,source->serverPort,this);
	if(newsource == NULL)
		return;
	//Cax2 - exchanged sources are named now
	if (exchanged)
		newsource->SetUserName(GetResString(IDS_EXCHANGEDSOURCE).GetBuffer());

d4539 10
a4548 1
	&& i < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()){ // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
d4550 3
a4552 3
	} else {
		if(theApp.downloadqueue->IsSourcesLoadingEnabled())
		{
d4554 1
d4560 1
d4562 2
a4563 2
		delete newsource;
	} 
d4566 1
@


1.164
log
@fix for crash
@
text
@d1915 5
a1919 9
	for (POSITION pos = BlockedParts.GetHeadPosition(); pos != NULL; ){
		DownloadedParts Client_Part = BlockedParts.GetNext(pos);
		if (srclists[Client_Part.sourcesslot].Find(Client_Part.Client) == 0) {	// if client doesn't exist, then delete it from the list
			POSITION pos1 = pos;
			BlockedParts.GetPrev(pos);
			BlockedParts.RemoveAt(pos1);			
		}
		else if (Client_Part.Client->GetDownloadState() != DS_DOWNLOADING) {
			POSITION pos1 = pos;
d1922 3
a1924 2
		}
		else {
@


1.163
log
@simplified...
@
text
@d1914 16
a1929 11
	// build local blocked list
	if (!BlockedParts.IsEmpty()) {
		DownloadedParts Client_Part;
		for (POSITION pos = BlockedParts.GetHeadPosition(); pos != 0; BlockedParts.GetNext(pos)){
			Client_Part = BlockedParts.GetAt(pos);
			if (srclists[Client_Part.sourcesslot].Find(Client_Part.Client) == 0)	// if client doesn't exist, then delete it from the list
				BlockedParts.RemoveAt(pos);
			else if (Client_Part.Client->GetDownloadState() != DS_DOWNLOADING) 
				BlockedParts.RemoveAt(pos);
			else
				if (!m_CurBlockedParts.Find(Client_Part.part)) m_CurBlockedParts.AddHead(Client_Part.part);
d1932 1
@


1.162
log
@ICR 2.8 fix
@
text
@d618 10
a627 14
		CTag* nametag = new CTag(FT_FILENAME,filename);
		nametag->WriteTagToFile(file);
		delete nametag;
		CTag* sizetag = new CTag(FT_FILESIZE,filesize);
		sizetag->WriteTagToFile(file);
		delete sizetag;
		CTag* transtag = new CTag(FT_TRANSFERED,transfered);
		transtag->WriteTagToFile(file);
		delete transtag;
		CTag* statustag = new CTag(FT_STATUS,(paused)? 1:0);
		statustag->WriteTagToFile(file);
		delete statustag;
		// Modified by Tarod for DAP
		CTag* prioritytag ;
d629 1
a629 1
			prioritytag = new CTag(FT_PRIORITY,(uint8)PR_AUTO);
d631 3
a633 3
			prioritytag = new CTag(FT_PRIORITY,priority);
		prioritytag->WriteTagToFile(file);
		delete prioritytag;
d635 2
a636 3
		CTag* lsctag = new CTag(FT_LASTSEENCOMPLETE,lsc);
		lsctag->WriteTagToFile(file);
		delete lsctag;
d638 2
a639 2
		// Modified by Tarod for UAP
		CTag* ulprioritytag;
d641 1
a641 1
			ulprioritytag = new CTag(FT_ULPRIORITY, PR_AUTO);
d643 4
a646 3
			ulprioritytag = new CTag(FT_ULPRIORITY,m_iPriority);
		ulprioritytag->WriteTagToFile(file);
		delete ulprioritytag;
d651 2
a652 2
		char* namebuffer = new char[10];
		char* number = &namebuffer[1];
d657 2
a658 2
			CTag* gapstarttag = new CTag(namebuffer,gaplist.GetAt(pos)->start);
			gapstarttag->WriteTagToFile(file);
d662 2
a663 4
			CTag* gapendtag = new CTag(namebuffer,(gaplist.GetAt(pos)->end)+1);
			gapendtag->WriteTagToFile(file);
			delete gapstarttag;
			delete gapendtag;
a665 1
		delete[] namebuffer;
d669 1
a669 1
			CString dfpath = CString(fullname) + CString(".dir");
d679 1
a679 1
			throw CString("unexpected write error");
d694 1
a694 1
	fclose(file);
@


1.161
log
@killed nstrdup function
@
text
@d1884 1
a1890 1
			i_AvailableNeededParts++;
d1915 1
d1921 13
d1994 11
a2004 6
			// choose part if it is not blocked or blocked but exactly same amount of parts is available
			if (m_BlockedParts.Find(i) == 0 ||(m_BlockedParts.Find(i) != 0 && i_AvailableNeededParts == m_BlockedParts.GetCount())) {
				if (m_ReqParts[i] == 0) {
					// Unstarted
					for (int j=0; j < (m_MaxSrcPartFrequency-m_SrcpartFrequency[i]+1); j++)
						liRandomParts.AddHead(i);
d2006 1
a2006 7
				else {
					if (m_ReqParts[i] > m_MostCompletedReqPart) {
						MostCompletedReqPart	= i;
						m_MostCompletedReqPart = m_ReqParts[i];
					}
				} // end widespreaded
			} // end m_BlockedPartsCondition
d2057 2
a2058 1
			if (m_BlockedParts.Find(goodpart)==0) m_BlockedParts.AddHead(goodpart);
d2065 2
a2066 1
			if (m_BlockedParts.Find(goodpart)==0) m_BlockedParts.AddHead(goodpart);
d2077 2
d2084 1
@


1.160
log
@char * to CString conversion
@
text
@a2329 1
	//directory = nstrdup(theApp.glob_prefs->GetIncomingDir());
@


1.159
log
@ICR 2.8
@
text
@d60 1
a60 1
		switch (searchresult->taglist[i]->specialtag){
d62 1
a62 1
				filename = CString(searchresult->taglist[i]->stringvalue);
d66 1
a66 1
				filesize = searchresult->taglist[i]->intvalue;
d350 1
a350 1
			switch(newtag->specialtag){
d352 1
a352 1
					if(newtag->stringvalue == NULL) {
d357 1
a357 1
					filename = CString(newtag->stringvalue);
d362 1
a362 1
					lastseencomplete = newtag->intvalue;
d367 1
a367 1
					filesize = newtag->intvalue;
d372 1
a372 1
					transfered = newtag->intvalue;
d377 1
a377 1
					priority = newtag->intvalue;
d388 1
a388 1
					paused = newtag->intvalue;
d393 1
a393 1
					if ((uint8)newtag->intvalue == PR_AUTO) {
d398 1
a398 1
						CKnownFile::SetPriority((uint8)newtag->intvalue);
d405 2
a406 2
					if ((!newtag->specialtag) && (newtag->tagname[0] == FT_GAPSTART ||
					     newtag->tagname[0] == FT_GAPEND)){
d408 3
a410 1
						uint16 gapkey = _tstoi(&newtag->tagname[1]);
d418 4
a421 4
						if (newtag->tagname[0] == FT_GAPSTART)
							gap->start = newtag->intvalue;
						if (newtag->tagname[0] == FT_GAPEND)
							gap->end = newtag->intvalue-1;
@


1.158
log
@simplified...
@
text
@d1846 1
a1846 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.5 11.06.2003) for eMule+
d1882 1
a1886 1
		m_ReqParts[i] = PARTSIZE;
d1888 1
d1891 2
a1922 3
	// check how many needed parts has the client
	for (int i = 0; i < partCount ; i++) if (m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != PARTSIZE) i_AvailableNeededParts++;

d1929 2
a1930 1
		if (m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != PARTSIZE) {
d2073 2
a2074 1
// ^- eklmn: feature(00): Intelligent Chunk Request(ICR v2.5 11.06.2003) for eMule+
@


1.157
log
@use helper method
@
text
@d3436 2
a3437 6
					char* pName = new char [strUserName.GetLength() + 2] ;
					memset(pName, '\0', (strUserName.GetLength() + 2)) ;
					strncpy(pName, strUserName.GetBuffer(), strUserName.GetLength()) ;
					newSource->SetUserName(pName);
					delete [] pName; // FoRcHa

@


1.156
log
@unicode cleanup
@
text
@d3417 2
a3418 5
					//check, if the sources-per-file-limit (glob_prefs) is exceeded
                    int srcsCount = 0;
                    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
                        srcsCount += srclists[sl].GetCount();
					if(srcsCount >= theApp.glob_prefs->GetMaxSourcePerFile()
@


1.155
log
@fixed crash at exit
@
text
@d266 1
a266 1
		filename.Format("%s\\%03i.part", tempdir, i); 
d270 2
a271 2
	partmetfilename.Format("%03i.part.met",i); 	
	fullname.Format("%s\\%s",tempdir,partmetfilename);
d313 1
a313 1
bool CPartFile::LoadPartFile(char* in_directory,char* in_filename)
d325 1
a325 1
	fullname.Format("%s\\%s",directory,partmetfilename);
d484 1
a484 1
	if(fullname.Right(7).CompareNoCase(".backup") == 0) {
d574 1
a574 1
		bakname.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), GetPartMetFileName());
d591 1
a591 1
		backupName.Append(".backup");
d593 2
a594 2
		remove(backupName);
		rename(fullname, backupName);
d597 1
a597 1
		file = _tfopen(fullname,"wbS");
d686 1
a686 1
		remove(backupName);
d2162 1
a2162 1
		newname.Format("%s\\%s(%d)%s", outputDir, fname, namecount, fext); 
d2176 1
a2176 1
	newname.Format("%s\\%s",GetOutputDir(), theApp.StripInvalidFilenameChars(GetFileName()));
d2211 1
a2211 1
               	throw CString(_T(GetResString(IDS_ERR_SLOWREAD)+" ("+partfilename+")"));
d2218 1
a2218 1
				throw CString(_T(GetResString(IDS_ERR_SLOWWRITE)+" ("+strTempNew+")"));
d2227 1
a2227 1
               	throw CString(_T(GetResString(IDS_ERR_OUTMEM))); 
d2246 1
a2246 1
            if (rename(strTempNew,newname))
d2249 1
a2249 1
               	throw CString(_T(GetResString(IDS_ERR_RENFAIL))); 
d2269 1
a2269 1
		if (rename(partfilename,newname))
d2288 1
a2288 1
    if (remove(fullname)) 
d2293 1
a2293 1
	if (remove(dirFile)) if (errno != ENOENT)
d2299 3
a2301 3
 	CString srcName="";
 	srcName.Format("%s\\%s.stsrc",tempdir,GetPartMetFileName());
 	if (remove(srcName))
d2306 2
a2307 2
	srcName.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), GetPartMetFileName());
	if (remove(srcName))
d2312 2
a2313 2
	srcName.Format("%s\\%s.movie", theApp.glob_prefs->GetTempDir(), GetPartMetFileName());
	if (remove(srcName))
d2332 1
a2332 1
    theApp.emuledlg->ShowNotifier(GetResString(IDS_TBN_DOWNLOADDONE)+"\n"+GetFileName(), TBN_DLOAD); 
d2334 1
a2334 1
    	AddLogLine(true, IDS_DOWNLOADRENAMED, strrchr(newname, '\\') + 1); 
d2397 1
a2397 1
	if (remove(fullname))
d2400 1
a2400 1
	if (remove(partfilename))
d2405 1
a2405 1
	if (remove(dirFile) && errno != ENOENT)
d2410 3
a2412 3
	CString srcName="";
	srcName.Format("%s\\%s.stsrc",tempdir,partmetfilename);
	if (remove(srcName) && errno != ENOENT) 
d2416 2
a2417 2
	srcName.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), partmetfilename);
	if (remove(srcName) && errno != ENOENT)
d2421 2
a2422 2
	srcName.Format("%s\\%s.movie", theApp.glob_prefs->GetTempDir(), partmetfilename);
	if (remove(srcName) && errno != ENOENT)
d2505 1
a2505 1
	return (strstr(fname,".avi") || strstr(fname,".ogm"));
d2522 1
a2522 1
		return (strstr(fname,".mpg") || strstr(fname,".mpe") || strstr(fname,".dat") || strstr(fname,".bin"));
d2524 1
a2524 1
		return (strstr(fname,".mpg") || strstr(fname,".mpe") || strstr(fname,".dat"));
d2744 1
a2744 1
	return ((extension.CompareNoCase(".zip") == 0) || (extension.CompareNoCase(".rar") == 0));
d2849 1
a2849 1
	CString mybuffer=""; 
d2873 1
a2873 1
	return "";
d2950 1
a2950 1
			ShellExecute(NULL, "open", strLine, NULL,NULL, SW_SHOWNORMAL);
d2953 3
a2955 3
			if (player.Find("vlc.exe"))
				strLine.Replace(".met","");
			char shortPath[512]; //Cax2 short path for vlc
d2959 1
a2959 1
			runDir=(i>=0)?runDir.Left(i+1):"";
d3021 1
a3021 1
		AddDebugLogLine(false,"Movie preview: %s",buffer);
d3027 1
a3027 1
		AddDebugLogLine(false,"Movie preview: too little space on disk to enable preview.");
d3033 1
a3033 1
		AddDebugLogLine(false,"Movie preview: only one preview at a time!");
d3231 2
a3232 2
		CString temp="";
		temp.Format("%s\\%s.stsrc",tempdir,GetPartMetFileName());
d3250 1
a3250 1
			if(debug) AddLogLine(false,"Sources for '%s' (%s) were found and saved",GetPartMetFileName(),GetFileName());
d3261 1
a3261 1
		if(debug) AddLogLine(false,"Due to the fact no sources were found for '%s', nothing was written",GetPartMetFileName());
d3286 2
a3287 2
	CString temp="";
	temp.Format("%s\\%s.stsrc",tempdir,GetPartMetFileName());
d3302 1
a3302 1
			if(debug) AddLogLine(false,"Could not load *.stsrc file for %s (%s)\r\n\t(ErrorMessage: %s)",GetFileName(),GetPartMetFileName(),GetErrorMessage(err));
d3309 1
a3309 1
		if(debug) AddLogLine(false,"Found %i Sources for %s in %s.stsrc",toLoad->GetCountSourceEntrys()
d3315 1
a3315 1
		if(debug) AddLogLine(false,"Could not open *.stsrc file for %s (%s)",GetFileName(),GetPartMetFileName());
d3434 1
a3434 1
					if (strUserName.Find(EXCHANGEDSOURCEMARK) == 0) {
d3453 1
a3453 1
					if(debug){ AddLogLine(false,"added Source (%i) of %i Sources for %s (%s)"
d3457 2
a3458 2
						AddLogLine(false,"The new Source is %s and the SourceEntry is %s",(newSource == NULL ? "NULL" : "not NULL"),(sourceEntry == NULL ? "NULL" : "not NULL"));
						AddLogLine(false,"New source No. %i added for %s",countAddedSources,GetFileName());
d3623 1
a3623 1
	userName.Format(LOADEDSOURCEMARK"%u", toSave->GetUserID());
d3676 1
a3676 1
		userName.Format(LOADEDSOURCEMARK"%u", source->GetUserID());
d3750 1
a3750 1
			userName.Format(LOADEDSOURCEMARK"%u", source->GetUserID());
d3793 1
a3793 1
			userName.Format(LOADEDSOURCEMARK"%u", source->GetUserID());
d3881 1
a3881 1
	char	fn[MAX_PATH];
d3885 1
a3885 1
	FILE	*fh=_tfopen(fn, "rb");
d3923 1
a3923 1
	char	fn[MAX_PATH];
d3931 1
a3931 1
	FILE	*fh=_tfopen(fn, "wb");
d4005 1
a4005 1
	if (player.Find("vlc.exe")>=0)
d4058 1
a4058 1
	return 	strDay + ", " + strDate + ", " +  strTime; 
d4067 2
a4068 2
   	CIni pvmoviefile(CString(fullname) + CString(".movie"), "MoviePreview"); 
   	uint8 Mode = pvmoviefile.GetInt("Mode", 0); 
d4071 1
a4071 1
    m_bDiscardSuperCompressed = pvmoviefile.GetBool("DiscardSuperCompressed",false,"DownloadSettings");
d4080 2
a4081 2
   	CIni pvmoviefile(CString(fullname) + CString(".movie"), "MoviePreview"); 
	pvmoviefile.WriteInt("Mode", ((CKnownFile*)this)->GetMovieMode()); 
d4083 1
a4083 1
    pvmoviefile.WriteBool("DiscardSuperCompressed",m_bDiscardSuperCompressed,"DownloadSettings");
d4122 1
a4122 1
		AddDebugLogLine(false, "File '%s' has already been written from %ld to %ld", GetFileName(), start, end);
d4515 1
a4515 1
			strName.Format(EXCHANGEDSOURCEMARK"%u", source->sourceID);
d4600 1
a4600 1
		strExpiration.Format("@@%02i%02i%02i", (expirationDate.GetYear() % 100), expirationDate.GetMonth(), expirationDate.GetDay());
d4607 1
a4607 1
	strLink.Format("ed2k://|file|%s|%d|%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x|/|sources%s",
d4615 1
a4615 1
		newsource.Format(",%i.%i.%i.%i:%i",(uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), theApp.glob_prefs->GetPort());
d4618 1
a4618 1
	AddDebugLogLine(false, "Sources: %i", (int)srcstoadd.GetCount());
d4621 2
a4622 2
		AddDebugLogLine(false, "Available part count: %i", (int)cur_src->GetAvailablePartCount());
		newsource.Format(",%s:%i",cur_src->GetFullIP(), cur_src->GetUserPort());
d4625 1
a4625 1
	strLink.Append("|/");
d4638 1
a4638 1
	path->TrimRight("\\");
d4728 1
a4728 1
	retpath.TrimRight("\\");
d4740 1
a4740 1
	compl.Format("%s/%s",CastItoXBytes(GetCompletedSize()),CastItoXBytes(GetFileSize()));
d4762 2
a4763 2
	sRet.Format(GetResString(IDS_DL_FILENAME)+": %s (%s)\n\n%s\n\n"
		+GetResString(IDS_FD_HASH) +" %s\n"
d4765 1
a4765 1
		GetResString(IDS_PARTINFOS2)+"\n%s\n%s",
d4767 1
a4767 1
				GetResString(IDS_STATUS)+": "+GetPartfileStatus(),
d4771 2
a4772 2
				GetResString(IDS_LASTSEENCOMPL)+" "+lsc,
                GetResString(IDS_FD_LASTCHANGE) +" "+lastprogr);
d4781 1
a4781 1
	compl.Format("%s/%s",CastItoXBytes(GetCompletedSize()),CastItoXBytes(GetFileSize()));
d4847 1
a4847 1
	CString my_ChunkBar="";
d4902 1
a4902 1
	return "";
@


1.154
log
@some optmization in NewSrcPartsInfo, fix in ICR 2.7
@
text
@d4476 4
a4479 2
	    theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
        m_lastRefreshedDLDisplay = curTick;
@


1.153
log
@Updates...
@
text
@a1804 1
	m_MaxSrcPartFrequency = 0;	// <- eklmn: feature(00): ICR 
a1820 2
						if (m_SrcpartFrequency[i] > m_MaxSrcPartFrequency)
							m_MaxSrcPartFrequency = m_SrcpartFrequency[i];
d1830 4
d2041 1
a2041 1
			m_BlockedParts.AddHead(goodpart);
d2048 1
a2048 1
			m_BlockedParts.AddHead(goodpart);
@


1.152
log
@Updates...
@
text
@d1813 2
a1814 2
			for (POSITION pos = srclists[sl].GetHeadPosition(); pos != 0; ){
				cur_src = srclists[sl].GetNext(pos);
@


1.151
log
@re-included eklmn hotfix and my dont-skip-headposition hotfix, too
@
text
@d1813 2
a1814 2
			for (POSITION pos = srclists[sl].GetHeadPosition(); pos != 0; srclists[sl].GetNext(pos)){
				cur_src = srclists[sl].GetAt(pos);
@


1.150
log
@some more localizations...
@
text
@d1813 2
a1814 2
			for (POSITION pos = srclists[sl].GetHeadPosition(); pos != 0; ){
				cur_src = srclists[sl].GetNext(pos);
d1833 1
a1833 1
	if (iPartCount == availablecounter && availablePartsCount < iPartCount)
d1835 1
a1835 1
	availablePartsCount = availablecounter;
@


1.149
log
@added some localizations (Lancast, corrupt hashset)
@
text
@d1833 1
a1833 1
	if (iPartCount == MaxAvailableParts && availablePartsCount < iPartCount)
d1835 1
a1835 1
	availablePartsCount = MaxAvailableParts;
d2293 1
a2293 1
		AddLogLine(true, "Failed to delete %s, you will need to do this by hand", dirFile);
@


1.148
log
@BUGFIX: available part count [eklmn]
@
text
@d342 1
a342 1
            AddLogLine(true,"Loaded hashset is corrupt! File: %s",in_filename);
@


1.147
log
@ICR 2.7 (new condition for widespread parts 1 client = 1 Part)
@
text
@d1833 1
a1833 1
	if (iPartCount == availablecounter && availablePartsCount < iPartCount)
d1835 1
a1835 1
	availablePartsCount = availablecounter;
@


1.146
log
@minor changes (use md4... instead of mem...)
@
text
@d1855 1
d1919 2
d1976 6
a1981 9
			if (m_ReqParts[i] == 0) {
				// Unstarted
				for (int j=0; j < (m_MaxSrcPartFrequency-m_SrcpartFrequency[i]+1); j++)
					liRandomParts.AddHead(i);
			}
			else {
				if (m_ReqParts[i] > m_MostCompletedReqPart) {
					MostCompletedReqPart	= i;
					m_MostCompletedReqPart = m_ReqParts[i];
d1983 7
a1989 1
			} // end widespreaded
d2040 1
d2047 1
@


1.145
log
@ICR v2.6 (fix for "widespreaded parts")
@
text
@d55 1
a55 1
	memcpy(filehash,searchresult->GetFileHash(),16);
d721 1
a721 1
			if (!(result->GetPartHash(i) && !memcmp(result->GetPartHash(i),GetPartHash(i),16))){
d909 1
a909 1
				memcpy(result->FileID, GetFileHash(), 16);
d978 1
a978 1
				memcpy(block->FileID, GetFileHash(), 16);
d1410 1
a1410 1
		memcpy(packet->pBuffer,filehash,16);
d1590 1
a1590 1
				&& memcmp(cur_src->reqfileid, GetFileHash(), 16) != 0) {
d2453 1
a2453 1
			if (memcmp(hashresult,GetPartHash(partnumber),16))
d2459 1
a2459 1
			if (memcmp(hashresult,filehash,16))
@


1.144
log
@Removed some Debug logs.
@
text
@d1805 1
d1822 2
d1975 1
a1975 1
				for (int j=0; j < (m_SrcpartFrequency[partCount-1]-m_SrcpartFrequency[i]+1); j++)
d2363 7
a2369 4
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclists[sl].GetNext(pos1);
		if (bTryToSwap){
			if (!srclists[sl].GetAt(pos2)->SwapToAnotherFile(NULL))	//eklmn: bugfix(08): A4AF switching
a2371 3
		else
			theApp.downloadqueue->RemoveSource(srclists[sl].GetAt(pos2));
	}
@


1.143
log
@init variable value
@
text
@d1861 1
a1861 1
		AddDebugLogLine(false,"Priority 0 (always choose currently downloaded part until it will be finished). File: %s, Part : %u", this->GetFileName(), goodpart);
d1989 2
a1990 2
                goodpart = MostCompletedUniqueReqPart;
                AddDebugLogLine(false,"Priority 1 (Unique unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
d1995 11
a2005 11
		if (liUniqueParts.GetCount() == 1)
                        goodpart = liUniqueParts.GetHead();
		else {
			const uint16 randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(liUniqueParts.GetCount()-1));
			goodpart = liUniqueParts.GetAt(liUniqueParts.FindIndex(randomness));
                }
	        AddDebugLogLine(false,"Priority 2 (Unique unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
	}
	// ------------------------------ Rarest & Requesred --------------------------------------------------
	// Try to complete a RarestPart and MostDownloaded as soon as possible to become a new source
	// it doesn't matter which one download, if there are parts same filled.
d2007 3
a2009 3
                goodpart = MostCompletedRarestReqPart;
                AddDebugLogLine(false,"Priority 3 (Rarest unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
	}
d2014 1
a2014 1
		       goodpart = liRarestParts.GetHead();
d2018 2
a2019 2
                }
                AddDebugLogLine(false,"Priority 4 (Rarest unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2023 2
a2024 2
                goodpart = liMovieParts.GetHead();
                AddDebugLogLine(false,"Priority 5 (Preview part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2030 2
a2031 2
                goodpart = MostCompletedReqPart;
                AddDebugLogLine(false,"Priority 6 (Widespread unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
d2035 3
a2037 3
	   	const uint16 randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(liRandomParts.GetCount()-1));
		goodpart = liRandomParts.GetAt(liRandomParts.FindIndex(randomness));
		AddDebugLogLine(false,"Priority 7 (Widespread unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
@


1.142
log
@unicode cleanup
@
text
@d1793 1
a1793 1
	uint8 availablecounter;
@


1.141
log
@two source function (NewSrcPartsInfo & UpdateAvailablePartsCount) werr merged (speed optimization)
@
text
@d408 1
a408 1
						uint16 gapkey = atoi(&newtag->tagname[1]);
d597 1
a597 1
		file = fopen(fullname,"wbS");
d3873 1
a3873 1
	FILE	*fh=fopen(fn, "rb");
d3919 1
a3919 1
	FILE	*fh=fopen(fn, "wb");
@


1.140
log
@A4AF switching
@
text
@d1787 1
d1792 3
a1794 1
	uint16 partcount = GetPartCount();
d1797 2
a1798 2
	if(m_SrcpartFrequency.GetSize() < partcount){
		m_SrcpartFrequency.SetSize(partcount);
d1801 1
a1801 1
	for(int i = 0; i < partcount; i++){
d1808 1
a1808 1
	int M_pos = (int)ceil(partcount/2) - 1;	// <- eklmn: feature(00): ICR
d1815 2
a1816 1
				for (int i = 0; i < partcount; i++){
d1821 1
d1824 1
d1829 6
d1837 1
d1840 1
d3032 1
d3059 1
@


1.139
log
@ICR fix to prevent consecutive download in Unique case due overlaping
@
text
@d1480 1
a1480 1
				if( !cur_src->SwapToAnotherFile(cur_src) ){
d1587 1
a1587 1
				cur_src->SwapToAnotherFile(false);
d1592 1
a1592 1
					cur_src->HandoverToAnotherFile(this);
d2349 1
a2349 1
			if (!srclists[sl].GetAt(pos2)->SwapToAnotherFile(true))
@


1.138
log
@ICR v2.5
memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@a26 1
#include "memcpy_amd.h"
d1904 1
a1904 1
        uint32 m_MostCompletedUniqueReqPart = 0;
d1912 1
a1912 1
				if (m_ReqParts[i] == 0)
@


1.137
log
@Preparing for new sockets
@
text
@d27 1
d55 1
d57 3
d127 1
d129 3
d909 1
d911 3
d978 1
d980 3
d1410 1
d1412 3
d1829 1
a1829 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR v2.3 04.06.2003) for eMule+
a1920 1
				continue;
a1932 1
				continue;
d1975 1
a1975 1
        if (m_MostCompletedUniqueReqPart != 0) {
d1980 1
a1980 1
        else if (!liUniqueParts.IsEmpty()) {
d2047 1
a2047 1
// ^- eklmn: feature(00): Intelligent Chunk Request(ICR v2.3 04.06.2003) for eMule+
d4101 1
d4103 3
@


1.136
log
@BUGFIX: included new SLUGFILLER: SafeHash (from 0.29a) [SyruS]
@
text
@d1387 1
d1398 1
d1400 1
d1402 1
a1402 1
	bool sockets_usage_high = theApp.listensocket->GetOpenSockets() > (theApp.glob_prefs->GetMaxConnections() * 0.75);
d1454 1
d1457 1
d1501 1
d1505 1
d1510 1
d1520 1
d1544 1
d1547 1
d1615 1
d1624 1
d1627 1
d1703 1
d1742 1
d1753 1
d4437 1
d4447 1
d4534 1
d4539 1
d4550 4
a4553 1
	uint32 dwID = theApp.serverconnect->GetClientID();
@


1.135
log
@Preparing for new sockets
@
text
@d454 2
a455 1
		if (gap->start >= 0 && gap->end >=0 && gap->start <= gap->end)
d458 9
a466 2
     			delete gap; // Some of the tags were missing
    	}
d487 10
d4160 4
a4163 1
			int curpart = item->start/PARTSIZE;
d4165 1
@


1.134
log
@ICR (bugfix)
@
text
@d1380 1
d1382 1
d1412 1
d1414 1
d1416 1
d1419 1
d2715 1
d2717 1
@


1.133
log
@converted to helper function GetErrorMessage
@
text
@d1882 1
a1882 1
					continue;
d1890 1
a1890 1
					continue;
a1894 1
					continue;
@


1.132
log
@converted to new logger methods
@
text
@d436 1
a436 3
		else{
			char buffer[150];
			error->GetErrorMessage(buffer,150);
d3213 2
a3214 4
		}catch(CException* err){
			char errorMsg[254];
			err->GetErrorMessage(errorMsg,254);
			if(debug) AddLogLine(false,"Could not load *.stsrc file for %s (%s)\r\n\t(ErrorMessage: %s)",GetFileName(),GetPartMetFileName(),errorMsg);
d4229 1
a4229 3
			char buffer[150];
			error->GetErrorMessage(buffer,150);
			AddLogLine(true, IDS_ERR_WRITEERROR, GetFileName(), buffer);
@


1.131
log
@ICR v2.4 small correction in DebugOutput
@
text
@d96 1
a96 1
		AddLogLine(true, GetResString(IDS_ERR_LINKERROR), buffer);
d115 1
a115 1
			AddLogLine( true, GetResString(IDS_SKIPZEROLENGTHFILE), filename );
d132 1
a132 1
		AddLogLine(true, GetResString(IDS_ERR_LINKERROR), buffer);
d275 1
a275 1
		AddLogLine(false,GetResString(IDS_ERR_CREATEPARTFILE));
d322 1
a322 1
			AddLogLine(false,GetResString(IDS_ERR_OPENMET),partmetfilename,filename);
d329 1
a329 1
			AddLogLine(false,GetResString(IDS_ERR_BADMETVERSION),partmetfilename,filename);
d345 1
a345 1
						AddLogLine(true,GetResString(IDS_ERR_METCORRUPT),partmetfilename,filename);
d435 1
a435 1
			AddLogLine(true,GetResString(IDS_ERR_METCORRUPT),partmetfilename,filename);
d439 1
a439 1
			AddLogLine(true,GetResString(IDS_ERR_FILEERROR),partmetfilename,filename,error);
d477 1
a477 1
		AddLogLine(false,GetResString(IDS_ERR_FILEOPEN),fullname,filename);		
d515 1
a515 1
			AddLogLine(false,GetResString(IDS_ERR_REHASH),filename);
d668 1
a668 1
		AddLogLine(false,GetResString(IDS_ERR_SAVEMET),error,partmetfilename,filename);
d676 1
a676 1
		AddLogLine(false,GetResString(IDS_ERR_SAVEMET),error.GetBuffer(),partmetfilename,filename);
d698 1
a698 1
				AddLogLine(false,GetResString(IDS_ERR_FOUNDCORRUPTION),i+1,filename);		
d712 1
a712 1
			AddLogLine(false,GetResString(IDS_HASHINGDONE),filename);
d2181 1
a2181 1
            AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
d2189 1
a2189 1
            AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
d2207 1
a2207 1
    	AddLogLine(true,GetResString(IDS_ERR_DELETEFAILED),fullname); 
d2221 1
a2221 1
 		AddLogLine(true,GetResString(IDS_FAILDELETE),srcName); 
d2227 1
a2227 1
			AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2233 1
a2233 1
			AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2249 1
a2249 1
    AddLogLine(true,GetResString(IDS_DOWNLOADDONE),GetFileName()); 
d2252 1
a2252 1
    	AddLogLine(true, GetResString(IDS_DOWNLOADRENAMED), strrchr(newname, '\\') + 1); 
d2316 1
a2316 1
		AddLogLine(true,GetResString(IDS_ERR_DELETE),fullname);
d2319 1
a2319 1
		AddLogLine(true,GetResString(IDS_ERR_DELETE),partfilename);
d2324 1
a2324 1
		AddLogLine(true, GetResString(IDS_FAILDELETE), dirFile);
d2331 1
a2331 1
			AddLogLine(true,GetResString(IDS_FAILDELETE),srcName);
d2336 1
a2336 1
			AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2341 1
a2341 1
			AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2362 1
a2362 1
		AddLogLine(true,GetResString(IDS_ERR_HASHERRORWARNING),GetFileName());
d2367 1
a2367 1
		AddLogLine(true,GetResString(IDS_ERR_INCOMPLETEHASH),GetFileName());
d4177 1
a4177 1
					AddLogLine(true, GetResString(IDS_ERR_PARTCORRUPT), partNumber, GetFileName());
d4201 1
a4201 1
					AddLogLine(true,GetResString(IDS_ICHWORKED),partNumber,GetFileName());
d4223 1
a4223 1
			AddLogLine(true, GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
d4235 1
a4235 1
			AddLogLine(true, GetResString(IDS_ERR_WRITEERROR), GetFileName(), buffer);
d4251 1
a4251 1
		AddLogLine(true, GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetResString(IDS_UNKNOWN));
d4493 1
a4493 1
		AddLogLine(true,GetResString(IDS_SOURCELINKFAILED));
@


1.130
log
@small fix in ICR 2.4 (DebugOutput)
@
text
@d1961 1
a1961 1
                AddDebugLogLine(false,"Priority 6 (Widespeaded unifinished part). File: %s, Part : %u", this->GetFileName(), goodpart);
d1967 1
a1967 1
		AddDebugLogLine(false,"Priority 7 (Widespeaded unrequested part). File: %s, Part : %u", this->GetFileName(), goodpart);
@


1.129
log
@ICR 2.4
@
text
@d1783 1
a1783 1
	uint16 goodpart = 0xffff; 
d1787 1
a1787 1
	if((sender->GetLastDownPart() != 0xffff) && GetNextEmptyBlockInPart(sender->GetLastDownPart(),0)) {
@


1.128
log
@code cleanup
@
text
@d1788 1
d1920 1
a1920 1
                AddDebugLogLine(false,"Priority 1 (Unique unifinished part). Part : %u",goodpart);
d1931 1
a1931 1
	        AddDebugLogLine(false,"Priority 2 (Unique unrequested part). Part : %u",goodpart);
d1938 1
a1938 1
                AddDebugLogLine(false,"Priority 3 (Rarest unifinished part). Part : %u",goodpart);
d1949 1
a1949 1
                AddDebugLogLine(false,"Priority 4 (Rarest unrequested part). Part : %u",goodpart);
d1954 1
a1954 1
                AddDebugLogLine(false,"Priority 5 (Preview part). Part : %u",goodpart);
d1961 1
a1961 1
                AddDebugLogLine(false,"Priority 6 (Widespeaded unifinished part). Part : %u",goodpart);
d1967 1
a1967 1
		AddDebugLogLine(false,"Priority 7 (Widespeaded unrequested part). Part : %u",goodpart);
d1971 5
@


1.127
log
@code cleanup
@
text
@d1677 1
a1677 1
void CPartFile::AddSources(CMemFile* sources,uint32 serverip, uint16 serverport)
d1688 1
a1688 1
	sources->Read(&count,1);
d1699 1
a1699 1
		sources->Read(&userid,4);
d1701 1
a1701 1
		sources->Read(&port,2);
@


1.126
log
@BUGFIX: bluecow's bugfix for completed files being rehashed and duplicate entry in known.met [SyruS]
@
text
@d332 2
a333 2
		LoadDateFromFile(&file);
        if(!LoadHashsetFromFile(&file,false)) {
d341 1
a341 1
			CTag* newtag = new CTag(&file);
@


1.125
log
@removed Tag_Struct usage from sources
@
text
@d26 1
d2190 10
a2199 1
       
@


1.124
log
@converted to standard copy constructor
@
text
@d55 1
a55 1
		switch (searchresult->taglist[i]->tag->specialtag){
d57 1
a57 1
				filename = CString(searchresult->taglist[i]->tag->stringvalue);
d61 1
a61 1
				filesize = searchresult->taglist[i]->tag->intvalue;
d341 1
a341 1
			switch(newtag->tag->specialtag){
d343 1
a343 1
					if(newtag->tag->stringvalue == NULL) {
d348 1
a348 1
					filename = CString(newtag->tag->stringvalue);
d353 1
a353 1
					lastseencomplete = newtag->tag->intvalue;
d358 1
a358 1
					filesize = newtag->tag->intvalue;
d363 1
a363 1
					transfered = newtag->tag->intvalue;
d368 1
a368 1
					priority = newtag->tag->intvalue;
d379 1
a379 1
					paused = newtag->tag->intvalue;
d384 1
a384 1
					if ((uint8)newtag->tag->intvalue == PR_AUTO) {
d389 1
a389 1
						CKnownFile::SetPriority((uint8)newtag->tag->intvalue);
d396 2
a397 2
					if ((!newtag->tag->specialtag) && (newtag->tag->tagname[0] == FT_GAPSTART ||
					     newtag->tag->tagname[0] == FT_GAPEND)){
d399 1
a399 1
						uint16 gapkey = atoi(&newtag->tag->tagname[1]);
d407 4
a410 4
						if (newtag->tag->tagname[0] == FT_GAPSTART)
							gap->start = newtag->tag->intvalue;
						if (newtag->tag->tagname[0] == FT_GAPEND)
							gap->end = newtag->tag->intvalue-1;
@


1.123
log
@changes reverted
@
text
@d65 1
a65 1
				CTag* newtag = new CTag(searchresult->taglist[i]->tag);
@


1.122
log
@DoubleT: bug #295 fixed (bypass part blocking on opcode StartUploadReq)
@
text
@d55 1
a55 1
		switch (searchresult->taglist[i]->specialtag){
d57 1
a57 1
				filename = CString(searchresult->taglist[i]->stringvalue);
d61 1
a61 1
				filesize = searchresult->taglist[i]->intvalue;
d65 1
a65 1
				CTag* newtag = new CTag(searchresult->taglist[i]);
d341 1
a341 1
			switch(newtag->specialtag){
d343 1
a343 1
					if(newtag->stringvalue == NULL) {
d348 1
a348 1
					filename = CString(newtag->stringvalue);
d353 1
a353 1
					lastseencomplete = newtag->intvalue;
d358 1
a358 1
					filesize = newtag->intvalue;
d363 1
a363 1
					transfered = newtag->intvalue;
d368 1
a368 1
					priority = newtag->intvalue;
d379 1
a379 1
					paused = newtag->intvalue;
d384 1
a384 1
					if ((uint8)newtag->intvalue == PR_AUTO) {
d389 1
a389 1
						CKnownFile::SetPriority((uint8)newtag->intvalue);
d396 2
a397 2
					if ((!newtag->specialtag) && (newtag->tagname[0] == FT_GAPSTART ||
					     newtag->tagname[0] == FT_GAPEND)){
d399 1
a399 1
						uint16 gapkey = atoi(&newtag->tagname[1]);
d407 4
a410 4
						if (newtag->tagname[0] == FT_GAPSTART)
							gap->start = newtag->intvalue;
						if (newtag->tagname[0] == FT_GAPEND)
							gap->end = newtag->intvalue-1;
@


1.121
log
@removed Tag_Struct usage from sources
@
text
@d1204 17
@


1.120
log
@ICR Update up to v2.3
@
text
@d55 1
a55 1
		switch (searchresult->taglist[i]->tag->specialtag){
d57 1
a57 1
				filename = CString(searchresult->taglist[i]->tag->stringvalue);
d61 1
a61 1
				filesize = searchresult->taglist[i]->tag->intvalue;
d65 1
a65 1
				CTag* newtag = new CTag(searchresult->taglist[i]->tag);
d341 1
a341 1
			switch(newtag->tag->specialtag){
d343 1
a343 1
					if(newtag->tag->stringvalue == NULL) {
d348 1
a348 1
					filename = CString(newtag->tag->stringvalue);
d353 1
a353 1
					lastseencomplete = newtag->tag->intvalue;
d358 1
a358 1
					filesize = newtag->tag->intvalue;
d363 1
a363 1
					transfered = newtag->tag->intvalue;
d368 1
a368 1
					priority = newtag->tag->intvalue;
d379 1
a379 1
					paused = newtag->tag->intvalue;
d384 1
a384 1
					if ((uint8)newtag->tag->intvalue == PR_AUTO) {
d389 1
a389 1
						CKnownFile::SetPriority((uint8)newtag->tag->intvalue);
d396 2
a397 2
					if ((!newtag->tag->specialtag) && (newtag->tag->tagname[0] == FT_GAPSTART ||
					     newtag->tag->tagname[0] == FT_GAPEND)){
d399 1
a399 1
						uint16 gapkey = atoi(&newtag->tag->tagname[1]);
d407 4
a410 4
						if (newtag->tag->tagname[0] == FT_GAPSTART)
							gap->start = newtag->tag->intvalue;
						if (newtag->tag->tagname[0] == FT_GAPEND)
							gap->end = newtag->tag->intvalue-1;
@


1.119
log
@WebServer: added different shades of blue (added by janes bong)
@
text
@d1751 1
a1751 1
// v- eklmn: feature(00): Intelligent Chunk Request(ICR) for eMule+
d1753 1
a1753 1
{ 
d1779 5
a1783 4
	CList<int> liRarestParts(partCount);	// priority 2
	CList<int> liMovieParts(5);            	// priority 3-4 => only first+last parts
	//CList<int> liReqParts(partCount);	// priority 5
	CList<int> liRandomParts(partCount);	// priority 6
d1785 1
a1785 1
	
d1825 2
a1826 1
	uint16 MostCompletedRarestReqPart, MostCompletedReqPart;
d1830 15
a1844 2
		if (m_ReqParts[i] != 0xFFFFFFFF && m_ReqParts[i] != PARTSIZE) { // eklmn: GetNextEmptyBlockInPart(i, NULL)
			// ------------------- Rarest Parts -----------------
d1896 18
d1915 5
a1919 4
    if (m_MostCompletedRarestReqPart != 0) {
		// Try to complete a RarestPart and MostDownloaded as soon as possible to become a new source
		// it doesn't matter which one download, if there are parts same filled.
		goodpart = MostCompletedRarestReqPart;
d1921 2
a1922 2
    // ------------------------------ Rarest & Unrequesred ------------------------------------------------
    else if (liRarestParts.IsEmpty() == false) {
d1924 1
a1924 1
		if (liRarestParts.GetCount() == 1) {
a1925 1
		}
d1929 17
a1945 14
	    }
	}
    // ---------------------------------- Movies Part  -----------------------------------------------------
    else if (liMovieParts.IsEmpty() == false) {
	   	goodpart = liMovieParts.GetHead();
    }
    // --------------------------------------- Requesred ----------------------------------------------------
    else if (m_MostCompletedReqPart != 0) {
	   	// Try to complete a UnfinishedPart and MostDownloaded as soon as possible to become a new source
	   	// it doesn't matter which one download, if there are parts same filled.
		goodpart = MostCompletedReqPart;
    }
    // -------------------------------- Unrequesred & Random -------------------------------------------------
    else if (liRandomParts.IsEmpty() == false) {	   	
d1948 3
a1950 2
    }
	else 
d1954 1
d1961 1
a1961 1
	
d1966 1
a1966 1
// ^- eklmn: feature(00): Intelligent Chunk Request(ICR) for eMule+
@


1.118
log
@file were paused not properly...
@
text
@d4666 10
a4675 2
	char crWaiting='3';	// blue
	char crMissing='4';  // red
d4705 1
a4705 1
					color = crWaiting;
@


1.117
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d2626 1
d2634 11
a2644 8
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
		if (cur_src->GetDownloadState() == DS_DOWNLOADING){
			theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
			cur_src->socket->SendPacket(packet,false,true);
			cur_src->SetDownloadState(DS_ONQUEUE);
d2657 1
@


1.116
log
@code cleanup
@
text
@d1713 2
d1716 13
a1728 1
    uint16 partcount = GetPartCount();
d1730 13
a1742 18
	if (m_SrcpartFrequency.GetCount() != partcount){
		m_SrcpartFrequency.RemoveAll();
		m_SrcpartFrequency.SetSize(0);
		for (int i = 0; i != partcount;i++)
			m_SrcpartFrequency.Add(0);
	}
	else{
		for (int i = 0; i != partcount;i++)
			m_SrcpartFrequency[i] = 0;
	}
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;){
        CUpDownClient* cur_src = srclists[sl].GetNext(pos);
        uint8* partstatus = cur_src->GetPartStatus();
        if(partstatus)
		    for (int i = 0; i != partcount; i++){
			    if (partstatus[i])
				m_SrcpartFrequency[i] +=1;
d1746 1
a1746 1
	UpdateDisplayedInfo();
d1751 1
a1751 1
//Vorlost for load rarest chunks first patch2
d1759 3
a1761 5
//	#define BLOCKCOUNT 3 

	uint8* partsav = sender->GetPartStatus(); 

  	uint8 mode = GetMovieMode();
d1764 2
a1765 4
  	uint8 rarechunk = 10; //Up to this value a chunk is very rare,if more we complete first
 	uint8 raremovie = 5; //Up to this value no moviechunks will be loaded first
    //, but could happen earlier if it doesnt make any difference(preview enabled), otherwise random
  	bool forcepreview = false; //true will ignore rare-chunks completely if a moviechunk is available
d1767 8
a1774 2
    _Bvector gettingParts;
    sender->ShowDownloadingParts(gettingParts);
d1776 125
a1900 2
    if((sender->GetLastDownPart() != 0xffff) && GetNextEmptyBlockInPart(sender->GetLastDownPart(),0)) {
        return sender->GetLastDownPart();
d1902 5
a1906 2
    else {
        sender->SetLastDownPart(0xffff);
d1908 7
d1916 8
a1923 65

	const uint16 PartCount = GetPartCount();
    CList<int,int> liGoodParts;
    CList<int,int> liPossibleParts;
	uint16 goodpart = 0xffff; 
	uint16 randomness = ROUND(((float)rand()/RAND_MAX)*(PartCount-1)); 
	for (uint16 i = 0;i != PartCount;i++)
	{ 
		if (partsav[randomness] && !IsComplete(randomness*PARTSIZE,((randomness+1)*PARTSIZE)-1))
		{ 
			// Begin of absolutely lowest availability gap by Vorlost inspired by Denominator 
           	if (GetNextEmptyBlockInPart(randomness,0)) //Search for next empty Block... 
			{
				if (goodpart != 0xffff) //One Part memorized yet ? 
				{
                    if(gettingParts[randomness]) {
                        goodpart = randomness;
                    } else
                    if(!gettingParts[goodpart] && m_SrcpartFrequency[goodpart] > rarechunk && m_SrcpartFrequency[randomness] > rarechunk) //Non-rare chunks found yet
					{
                    	if (PrepareComparePart(randomness) < PrepareComparePart(goodpart)) //and is this new chunk more completed ?
						{
     						if (Movie1(mode,goodpart,randomness)) goodpart = randomness;  //Then we want it ! 
                    	} 
     					else
						{
      						if (PrepareComparePart(randomness) == PrepareComparePart(goodpart) //Is the new chunk same complete
      							&& m_SrcpartFrequency[randomness] < m_SrcpartFrequency[goodpart]) //and rarer ?
							{
      								if (Movie1(mode,goodpart,randomness))
										goodpart = randomness;  //Then we want it ! If Movie1 allows us
							} 
     						else if (Movie2(mode,raremovie,forcepreview,goodpart,randomness))
								goodpart = randomness; //Normally we dont want it, what do you think Movie2 ?
						} 
					} 
               		else //The memorized or the new chunk is a very rare one
					{
                   		if (m_SrcpartFrequency[randomness] < m_SrcpartFrequency[goodpart]) //Is the new chunk rarer than the memorized ? 
							goodpart = randomness; //Then we want it ! 
                   		else if (m_SrcpartFrequency[randomness] == m_SrcpartFrequency[goodpart]) //old & new chunk are both same available ?
						{
                   			if (PrepareComparePart(randomness) < PrepareComparePart(goodpart)) //and is this new chunk more completed ?
							{
                       			if (Movie1(mode,goodpart,randomness))
									goodpart = randomness; //Then we want it ! If Movie1 allows us
							} 
  							else if (Movie2(mode,raremovie,forcepreview,goodpart,randomness))
								goodpart = randomness; //Normally we dont want it, what do you think Movie2 ?
						} 
					} 
				} else	                      //Theres no memorized Part yet... 
					goodpart = randomness;    //Then just take this one first...    
			} 
			// End of lowest availability gap by Vorlost / Denominator 
		} 
		randomness++; 
		if (randomness == PartCount) 
			randomness = 0;
	}

    sender->SetLastDownPart(goodpart);

    if (goodpart!=0xffff)
		return goodpart;
d1928 1
a1928 1
//End vorlost
@


1.115
log
@BUGFIX: "last reception" was never "unknown" - now it's unknown when transfered=0 [SyruS]
@
text
@d4477 2
a4478 1
	if(this == NULL) return "";
d4480 11
a4490 12
	CString sRet;
	CString strHash=EncodeBase16(GetFileHash(), 16);;

	char lsc[50]; char compl[50]; char lastprogr[50];

	sprintf(compl,"%s/%s",CastItoXBytes(GetCompletedSize()),CastItoXBytes(GetFileSize()));

	if (lastseencomplete==NULL) sprintf(lsc,GetResString(IDS_UNKNOWN)); else
		sprintf(lsc,localelastseencomplete());	// netwolf 13.05.03 use local date/time format

	if (GetTransfered()==0 /*SyruS won't work: GetFileDate()==NULL*/) sprintf(lastprogr,GetResString(IDS_UNKNOWN)); else
		sprintf(lastprogr,localelastdowntransfer());	// netwolf 13.05.03 use local date/time format
d4496 4
d4509 2
a4510 2
				GetResString(IDS_LASTSEENCOMPL)+" "+CString(lsc),
                GetResString(IDS_FD_LASTCHANGE) +" "+CString(lastprogr));
d4518 2
a4519 11
	EMULE_TRY
	if(this == NULL) return "";

	CString sRet;
	CString strHash=EncodeBase16(GetFileHash(), 16);;
	CTime t(GetFileDate());
	CString sTransfSrcCount;

	char lsc[50]; char compl[50]; char lastprogr[50];

	sprintf(compl,"%s/%s",CastItoXBytes(GetCompletedSize()),CastItoXBytes(GetFileSize()));
d4521 11
a4531 5
	if (lastseencomplete==NULL) sprintf(lsc,GetResString(IDS_UNKNOWN)); else
		sprintf(lsc,localelastseencomplete());	// netwolf 13.05.03 use local date/time format

	if (GetTransfered()==0) sprintf(lastprogr,GetResString(IDS_UNKNOWN)); else
		sprintf(lastprogr,localelastdowntransfer());	// netwolf 13.05.03 use local date/time format
d4537 3
a4539 3

	sTransfSrcCount.Empty();
	if(GetTransferingSrcCount()>0)
d4541 3
d4545 1
d4561 1
a4561 1
			CString(lsc),CString(lastprogr));
a4563 4

	EMULE_CATCH

	return "";
@


1.114
log
@simplified some code
@
text
@d4486 1
a4486 1
	if (lastseencomplete==NULL) sprintf(lsc,GetResString(IDS_UNKNOWN).MakeLower() ); else
d4489 1
a4489 1
	if (GetFileDate()==NULL) sprintf(lastprogr,GetResString(IDS_UNKNOWN)); else
d4526 1
a4526 1
	if (lastseencomplete==NULL) sprintf(lsc,GetResString(IDS_UNKNOWN).MakeLower() ); else
d4529 1
a4529 1
	if (GetFileDate()==NULL) sprintf(lastprogr,GetResString(IDS_UNKNOWN)); else
@


1.113
log
@coverted code from char * to CString
@
text
@d1897 39
a1943 2
	char* newfilename = nstrdup(GetFileName());
	strcpy(newfilename, (LPCTSTR)theApp.StripInvalidFilenameChars(newfilename));
d1945 1
a1945 1
	newname.Format("%s\\%s",GetOutputDir(),newfilename);
d1955 1
a1955 47
		int namecount = 0;
		
		size_t length = strlen(newfilename);
		ASSERT(length != 0); //name should never be 0
		
		//the file extension
		char *ext = strrchr(newfilename, '.');
		if(ext == NULL)
			ext = newfilename + length;
		
		char *last = ext;  //new end is the file name before extension
		last[0] = 0;  //truncate file name
		
		//search for matching ()s and check if it contains a number
		if((ext != newfilename) && (strrchr(newfilename, ')') + 1 == last))
		{
			char *first = strrchr(newfilename, '('); 
            
            if(first != NULL)
            {
            	first++;
            	bool found = true;
            	for(char *step = first; step < last - 1; step++)
            		if(*step < '0' || *step > '9')
            		{
            			found = false;
            			break;
            		}
            	if(found)
            	{
            		namecount = atoi(first);
            		last = first - 1;
            		last[0] = 0;  //truncate again
            	}
            }
		} 

		CString strTestName;
		do
		{ 
        	namecount++; 
			strTestName.Format("%s\\%s(%d).%s", GetOutputDir(),					//<<-- enkeyDEV(Ottavio84) -ChangeDir-
               				   newfilename, namecount, min(ext + 1, newfilename + length)); 
        }
        while(PathFileExists(strTestName));
        	
        newname = strTestName;
a1956 1
    delete newfilename; 
@


1.112
log
@coverted code from char * to CString
@
text
@d1903 2
a1904 2
	char* partfilename = nstrdup(fullname);
	partfilename[strlen(fullname)-4] = 0;
d2034 1
a2034 2
        { 
         	delete[] partfilename; 
d2041 1
a2041 2
        { 
            delete[] partfilename;             
d2049 1
a2049 2
		{ 
        	delete[] partfilename;             
d2091 1
a2091 2

    delete[] partfilename;     
@


1.111
log
@coverted code from char * to CString
@
text
@d263 2
a264 4
	char* buffer = nstrdup(partmetfilename);
	buffer[strlen(buffer)-4] = 0;
	CTag* partnametag = new CTag(FT_PARTFILENAME,buffer);
	delete[] buffer;
d272 1
a272 4
	char* partfull = nstrdup(fullname);
	partfull[strlen(partfull)-4] = 0;
	
	
d277 1
a277 1
	delete[] partfull;
d474 1
a474 2
	char* searchpath = nstrdup(fullname);
	searchpath[fullname.GetLength()-4] = 0;
d476 1
a476 2
		AddLogLine(false,GetResString(IDS_ERR_FILEOPEN),fullname,filename);
		delete[] searchpath;
d478 1
a478 3
	}
	delete[] searchpath;
			
d554 2
a555 4
		char* searchpath = nstrdup(fullname);
		searchpath[strlen(fullname)-4] = 0;
		bool end = !ff.FindFile(searchpath,0);
		delete[] searchpath;
d1877 1
a1877 2
		char* partfileb = nstrdup(partmetfilename);
		partfileb[partmetfilename.GetLength()-4] = 0;
a1880 1
		delete[] partfileb;
d2173 1
a2173 2
	char* partfilename = nstrdup(fullname);
	partfilename[strlen(fullname)-4] = 0;
d2202 1
a2202 2
	//--- :xrmb ---
	delete[] partfilename;
@


1.110
log
@coverted code from char * to CString
@
text
@d57 1
a57 1
				filename = nstrdup(searchresult->taglist[i]->tag->stringvalue);
d110 1
a110 1
		filename = nstrdup( fileLink->GetName() );
d148 1
a148 2
	tempdir	=	"";
	fullname = 0;
d230 1
a230 3
	//taab END fix
	if (fullname && !IsBadStringPtr(fullname,MAX_PATH))
		delete[] fullname;		
d261 2
a262 4
	partmetfilename.Format("%03i.part.met",i); 

	fullname = new char[tempdir.GetLength() + partmetfilename.GetLength()+MAX_PATH];
	sprintf(fullname,"%s\\%s",tempdir,partmetfilename);
d317 5
a321 5
	directory = nstrdup(in_directory);
	char* buffer = new char[strlen(directory)+partmetfilename.GetLength()+2];
	if (directory[strlen(directory)-1] == '\\') directory[strlen(directory)-1] = 0;	// added by InterCeptor (check for \\) 19.11.02
	sprintf(buffer,"%s\\%s",directory,partmetfilename);
	fullname = buffer;
d353 1
a353 1
					filename = nstrdup(newtag->tag->stringvalue);
d474 2
a475 4
	if(stricmp(strrchr(fullname, '.'), ".backup") == 0) {
		char *shorten = strrchr(fullname, '.');
		*shorten = 0;
		fullname = (char*)realloc(fullname, strlen(fullname) + 1);
d480 1
a480 1
	searchpath[strlen(fullname)-4] = 0;
d523 1
a523 1
			AddLogLine(false,GetResString(IDS_ERR_REHASH),buffer,filename);
d2108 3
a2110 4
    delete[] partfilename; 
    delete[] fullname; 
    fullname = nstrdup(newname); 
    delete[] directory; 
d2112 1
a2112 1
	directory = nstrdup((LPCTSTR)GetOutputDir());		
@


1.109
log
@coverted code from char * to CString
@
text
@d93 2
a94 2
		char buffer[200];
		sprintf(buffer,GetResString(IDS_ERR_INVALIDLINK),error.GetBuffer());
d129 2
a130 2
		char buffer[200];
		sprintf(buffer,GetResString(IDS_ERR_INVALIDLINK),error.GetBuffer());
d1927 2
a1928 2
	char* newname = new char[strlen(newfilename)+strlen(GetOutputDir())+MAX_PATH];
	sprintf(newname,"%s\\%s",GetOutputDir(),newfilename);
d1983 2
a1984 2
        	delete[] newname;
        newname = nstrdup(strTestName);
a2055 1
            delete[] newname; 
d2063 1
a2063 2
            delete[] partfilename; 
            delete[] newname; 
d2072 1
a2072 2
        	delete[] partfilename; 
            delete[] newname; 
d2117 1
a2117 1
    fullname = newname; 
@


1.108
log
@slowly drop queue full sources when softlimit is reached
@
text
@d148 1
a148 1
	tempdir	=	NULL;
d163 1
a163 1
	partmetfilename = 0;
d233 1
a233 5
		delete[] fullname;
	if (partmetfilename && !IsBadStringPtr(partmetfilename,MAX_PATH))
		delete[] partmetfilename;
	if(tempdir && !IsBadStringPtr(tempdir,MAX_PATH)) // FoRcHa
		delete[] tempdir;
d252 3
a254 2
	tempdir = nstrdup(theApp.glob_prefs->GetTempDir());	// added by InterCeptor (multiple tempdirs) 19.11.02
	if (tempdir[strlen(tempdir)-1] == '\\') tempdir[strlen(tempdir)-1] = 0;	// added by InterCeptor (check for \\) 19.11.02
d263 2
a264 2
	partmetfilename = new char[15]; 
	sprintf(partmetfilename,"%03i.part.met",i); 
d266 1
a266 1
	fullname = new char[strlen(tempdir)+strlen(partmetfilename)+MAX_PATH];
d318 1
a318 1
	tempdir = nstrdup(in_directory);	// added by InterCeptor (multiple tempdirs) 19.11.02
d321 1
a321 1
	partmetfilename = nstrdup(in_filename);
d323 1
a323 1
	char* buffer = new char[strlen(directory)+strlen(partmetfilename)+2];
d565 1
a565 1
		bakname.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
d1896 1
a1896 1
		partfileb[strlen(partmetfilename)-4] = 0;
d2102 1
a2102 1
	srcName.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
d2108 1
a2108 1
	srcName.Format("%s\\%s.movie", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
@


1.107
log
@minor fixes and improvements
@
text
@d1435 4
a1438 4
					if( ((dwCurTick - lastpurgetime) > PURGE_TIME) && (this->GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) )
						if( !cur_src->SwapToAnotherFile(cur_src) ){
							theApp.downloadqueue->RemoveSource(cur_src);
							lastpurgetime = dwCurTick;
d1440 2
a1441 2
							break; 
						}
d1454 8
a1461 1
	        if ( cur_src->GetRemoteQueueRank()
@


1.106
log
@complete sources column
@
text
@d1435 7
d1692 1
a1692 1
    }
d2610 1
@


1.105
log
@make "drop supercompressed blocks" a per-file setting
@
text
@d210 2
d1225 7
d1272 22
d2847 1
@


1.104
log
@slight download speedup in some cases
@
text
@d202 1
d3820 2
d3831 2
@


1.103
log
@fixed memory leak when invalid part file is processed
@
text
@d1740 8
d1807 4
a1810 1
	if (goodpart!=0xffff)
@


1.102
log
@*** empty log message ***
@
text
@d450 7
a456 1
		error->Delete();
@


1.101
log
@SyruS: customizable cleanup of filenames
@
text
@d680 1
@


1.100
log
@Tooltips fixes
@
text
@d306 3
@


1.99
log
@date/time in tooltips uses local format
@
text
@d4514 1
a4514 1
			+GetResString(IDS_TT_DATE)
d4523 1
a4523 1
			t.Format("%A, %B %d, %Y"),
@


1.98
log
@Fixes for tooltips
@
text
@d4457 1
a4457 1
		sprintf(lsc,lastseencomplete.Format(_T("%A, %x, %X")));
d4460 1
a4460 1
		sprintf(lastprogr,CTime(date).Format(_T("%A, %x, %X")));
d4497 1
a4497 1
		sprintf(lsc,lastseencomplete.Format(_T("%A, %x, %X")));
d4500 1
a4500 1
		sprintf(lastprogr,CTime(date).Format(_T("%A, %x, %X")));
@


1.97
log
@Enhanced tooltips by JoeyRamone
@
text
@d4517 1
@


1.96
log
@L2HAC by EnkeyDev
@
text
@d4481 54
@


1.95
log
@*** empty log message ***
@
text
@d1426 13
@


1.94
log
@More netwolf's changes
@
text
@d35 1
a35 1
#define PROGRESS_HEIGHT 3
d2793 1
a2793 3
	bool empty=true;
	for (sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty()) {empty=false;break;}
	if (empty) return 0;
d2838 10
@


1.93
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d221 8
a228 1

d3871 5
a3875 1
	if (gaplist.IsEmpty()) FlushBuffer();
d3913 3
a3915 2
			m_hpartfile.SetLength(item->end + 1);

d3947 1
a3947 1
		uint32 partRange = (m_hpartfile.GetLength() % PARTSIZE) - 1;
@


1.92
log
@netwolf's changes
@
text
@d294 5
d1316 1
a1316 1
	if ((m_nTotalBufferData > ((uint32)theApp.glob_prefs->GetFileBufferSize())*15000) || (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)))
d3986 1
a3986 1
		if (gaplist.IsEmpty())
@


1.91
log
@fixes by BavarianSnail/obaldin/kuchin. see changelog+
@
text
@d152 1
a152 1
	lastpurgetime = GetTickCount();
d1292 1
a1292 1
		if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS) 
d2777 3
d2781 3
a2783 1
	for (sl=0;sl<SOURCESSLOTS;sl++) if (srclists[sl].IsEmpty()) return 0;
d4035 2
a4036 2
	Gap_Struct *gap;
	Gap_Struct *best;
@


1.90
log
@Fixed a bug with not being able to set some folders as output folder (0000225)   (it was not only drives root but some "special" folders too). .
also fixed few COM/Shell related memory leaks.
@
text
@d1245 1
a1245 1
	if ((!paused) || status == PS_ERROR || ignorepause)
d1304 1
a1304 1
uint32 CPartFile::Process(uint32 reducedownload/*in percent*/)
d1344 3
d4423 1
a4423 1
	sRet.Format(GetResString(IDS_DL_FILENAME)+": %s (%s %s)\n\n%s\n\n"
d4427 1
a4427 1
		GetFileName(), CastItoXBytes(GetFileSize()),GetResString(IDS_BYTES),
@


1.89
log
@#0000258
bug, crash
0-byte file crash
@
text
@d4309 75
a4383 12
	CFileFind ff;
	if (!m_alternativepath.IsEmpty()) {
        ff.FindFile(m_alternativepath, 0);
		ff.FindNextFile();
		if (ff.IsDirectory()) {
			CString dir = m_alternativepath + "\\";
			for (POSITION pos = theApp.glob_prefs->shareddir_list.GetHeadPosition();pos != 0;theApp.glob_prefs->shareddir_list.GetNext(pos))
				if (theApp.glob_prefs->shareddir_list.GetAt(pos) == dir)
					return m_alternativepath;
            theApp.glob_prefs->shareddir_list.AddTail(dir);
			theApp.sharedfiles->Reload();
			return m_alternativepath;
d4385 1
d4387 3
a4389 1
	CString retpath = theApp.glob_prefs->GetIncomingDir();
@


1.88
log
@Fixed a crash if you add file that already exist in shared or queue thru    ED2K Link (Search window) , also fixed a bug that  variable was not 		initialized causing crashes on exit .
@
text
@d112 6
@


1.87
log
@*** empty log message ***
@
text
@d134 1
d142 1
d216 1
a216 1
	if (fullname)
d218 1
a218 1
	if (partmetfilename)
d220 1
a220 1
	if(tempdir) // FoRcHa
@


1.86
log
@Webserver from official 0.27c
@
text
@d3602 1
a3602 1
	if (!fullname)
@


1.85
log
@last seen complete dayofweek is now shown in the correct language aswell
@
text
@d4324 111
@


1.84
log
@last seen complete and last downloaded are displayed under locale settings
@
text
@d3710 27
a3736 1
	return 	dt.Format("%A, ") + strDate + ", " +  strTime; 
@


1.83
log
@Minor debug log message fix (removed extra carriage return).
@
text
@d3694 20
@


1.82
log
@Minor changes
@
text
@d3750 1
a3750 1
		AddDebugLogLine(false, "File '%s' has already been written from %ld to %ld\n", GetFileName(), start, end);
@


1.81
log
@Fixes to "destination directory"
@
text
@d1788 2
a1789 2
	if( srcarevisible )
		theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this);
d1792 1
@


1.80
log
@Fix
@
text
@d4264 1
@


1.79
log
@More try/catch
@
text
@a897 2
	*count = 0;

d949 2
d952 2
@


1.78
log
@bugfix: file stuck in 'completing' mode
@
text
@d896 4
d950 2
d1775 2
d1778 2
d3554 2
d3588 4
d3596 2
d3630 4
d3638 2
d3646 4
d4017 2
d4036 2
d4041 2
d4046 4
d4053 2
d4078 4
d4085 2
d4093 2
d4099 7
a4105 3
// check first if we are this source
if (theApp.serverconnect->GetClientID() < 16777216 && theApp.serverconnect->IsConnected()){
	if ((theApp.serverconnect->GetClientID() == source->sourceID) && theApp.serverconnect->GetCurrentServer()->GetIP() == source->serverIP)
d4107 19
a4125 22
}
else if (theApp.serverconnect->GetClientID() == source->sourceID)
return;
// Modified by Tarod -use LowID source only if source is in our same server
else if (source->sourceID < 16777216 && !theApp.serverconnect->IsLocalServer(source->serverIP, source->serverPort))
return;

CUpDownClient* newsource = new CUpDownClient(source->sourcePort,source->sourceID,source->serverIP,source->serverPort,this);
if(newsource == NULL)
	return;
//Cax2 - exchanged sources are named now
if (exchanged)
	newsource->SetUserName(GetResString(IDS_EXCHANGEDSOURCE).GetBuffer());

if( theApp.glob_prefs->GetMaxSourcePerFile() > GetSourceCount()
   && i < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()){ // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
	   theApp.downloadqueue->CheckAndAddSource(this,newsource);
   } else {
	   if(theApp.downloadqueue->IsSourcesLoadingEnabled())
	   {
		   CString strName;
		   strName.Format(EXCHANGEDSOURCEMARK"%u", source->sourceID);
d4127 2
a4128 2
		   if(m_stscrStoringSources != NULL)
			   m_stscrStoringSources->UpdateSource(strName, source->sourcePort,source->sourceID,source->serverIP,source->serverPort, newsource->GetAvailableOfNeededPartsCount());
d4130 4
a4133 3
	   }
	   delete newsource;
   } 
d4137 6
a4142 13
POSITION pos;
pos=sources->GetHeadPosition();
while (pos!=NULL) {
 CClientSource* source=(CClientSource*)sources->GetAt(pos);  

 if (source->sourceType != ED2KLINK_SOURCE_IP) {
  sources->GetNext(pos);
  continue;
 }

 POSITION removePos=pos;
 sources->GetNext(pos);
 sources->RemoveAt(removePos);
d4144 15
a4158 4
 AddClientSource(source);
 delete source;
}
theApp.downloadqueue->AddClientHostnameToResolve(sources);
d4165 2
d4232 4
d4241 2
d4245 2
d4250 2
d4268 4
@


1.78.2.1
log
@27a partial merge
@
text
@d53 1
a53 1
		memcpy(filehash,searchresult->GetFileHash(),16);
d59 1
a59 1
							 }
d63 1
a63 1
							 }
d83 1
a83 1
		CED2KLink* pLink = 0;
d109 10
a118 17
		try{
			filename = nstrdup( fileLink->GetName() );
			filesize = fileLink->GetSize();
			// Don't ask for a hashset, if there is none.
			if (filesize < PARTSIZE)
				hashsetneeded = false;
			memcpy(filehash,fileLink->GetHashKey(),sizeof(filehash));
			if (!theApp.downloadqueue->IsFileExisting(filehash))
				CreatePartFile();
			else
				status = PS_ERROR;
		}
		catch(CString error){
			OUTPUT_DEBUG_TRACE();
			char buffer[200];
			sprintf(buffer,GetResString(IDS_ERR_INVALIDLINK),error.GetBuffer());
			AddLogLine(true, GetResString(IDS_ERR_LINKERROR), buffer);
d121 7
d129 1
a129 1
		EMULE_CATCH
d141 1
a141 1
		fullname = 0;
a145 1
	stopped= false;
d160 1
a160 1

a200 1
	m_lastdatetimecheck=0;
d202 1
a202 1
	m_lastDownTransfer = CTime::GetCurrentTime();
d211 2
a212 2
		// Barry - Ensure all buffered data is written
		FlushBuffer();
d238 1
a238 1
		tempdir = nstrdup(theApp.glob_prefs->GetTempDir());	// added by InterCeptor (multiple tempdirs) 19.11.02
d240 1
a240 1
	int i = 0; 
d246 1
a246 1

d258 1
a258 1

d266 2
a267 2


d285 1
a285 1

d295 2
a296 2
		tempdir = nstrdup(in_directory);	// added by InterCeptor (multiple tempdirs) 19.11.02
	CMap<uint16,uint16,Gap_Struct*,Gap_Struct*> gap_map; // safe Load Gaps [SlugFiller]
d319 3
a321 3
		if(!LoadHashsetFromFile(&file,false)) {
			AddLogLine(true,"Loaded hashset is corrupt! File: %s",in_filename);
		}
d338 1
a338 1
								 }
d343 1
a343 1
										  }
d348 1
a348 1
								 }
d353 1
a353 1
								   }
d364 1
a364 1
								 }
a366 1
					stopped=paused;
d369 1
a369 1
							   }
d380 1
a380 1
									}
d384 9
a392 16
						newtag->tag->tagname[0] == FT_GAPEND)){
							Gap_Struct* gap;
							uint16 gapkey = atoi(&newtag->tag->tagname[1]);
							if (!gap_map.Lookup(gapkey, gap))
							{
								gap = new Gap_Struct;
								gap_map.SetAt(gapkey, gap);
								gap->start = -1;
								gap->end = -1;
							}
							if (newtag->tag->tagname[0] == FT_GAPSTART)
								gap->start = newtag->tag->intvalue;
							if (newtag->tag->tagname[0] == FT_GAPEND)
								gap->end = newtag->tag->intvalue-1;
							delete newtag;
							// End Changes by Slugfiller for better exception handling
d394 7
d403 10
a412 10
						}

						// START - enkeyDEV(Ottavio84) -ChangeDir-
						CString dfpath = CString(fullname) + CString(".dir");
						CStdioFile f;
						if (f.Open(dfpath, CFile::modeRead | CFile::typeText)) {
							f.ReadString(m_alternativepath);
							f.Close();			
						}
						// END - enkeyDEV(Ottavio84) -ChangeDir-					
d435 1
a435 1
		gap_map.GetNextAssoc(pos, gapkey, gap);
d437 4
a440 4
			gaplist.AddTail(gap); // All tags accounted for
		else
			delete gap; // Some of the tags were missing
	}
d443 3
a445 3
		//--- xrmb:keepPartFileStats ---
		//--- i hope that is a safe point to load the stats ---
		LoadPartFileStats();
d449 6
a454 6
		//check if this is a backup
		if(stricmp(strrchr(fullname, '.'), ".backup") == 0) {
			char *shorten = strrchr(fullname, '.');
			*shorten = 0;
			fullname = (char*)realloc(fullname, strlen(fullname) + 1);
		}
d456 5
a460 8
		// open permanent handle
		char* searchpath = nstrdup(fullname);
		searchpath[strlen(fullname)-4] = 0;
		if (!m_hpartfile.Open(searchpath,CFile::modeReadWrite|CFile::shareDenyWrite|CFile::osSequentialScan)){
			AddLogLine(false,GetResString(IDS_ERR_FILEOPEN),fullname,filename);
			delete[] searchpath;
			return false;
		}
d462 4
d467 9
a475 4

		m_SrcpartFrequency.SetSize(GetPartCount());
		for (uint32 i = 0; i != GetPartCount();i++)
			m_SrcpartFrequency.Add(0);
d477 11
a487 5
		// check hashcount, filesatus etc
		CSingleLock Lock(&m_hashlistMutex,TRUE);
		INT_PTR iSize = hashlist.GetCount();
		Lock.Unlock();
		if ( iSize < GetPartCount() && GetFileSize() >= PARTSIZE){
d489 1
a489 11
			hashsetneeded = true;
			return true;
		}
		else {
			hashsetneeded = false;
			bool empty = true;
			for (int i = 0; i != iSize; i++){
				if (IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1))
					status = PS_READY;
			}
		}
d491 4
a494 4
		if (gaplist.IsEmpty()){	// is this file complete already?
			CompleteFile(false);
			return true;
		}
d496 1
a496 1
		// check date of .part file - if its wrong, rehash file
d498 2
a499 2
		m_hpartfile.GetStatus(filestatus); // this; "...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are... :)
		m_lastDownTransfer = filestatus.m_mtime;
d504 3
a506 3
			CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
			addfilethread->SetValues(0,directory,m_hpartfile.GetFileName().GetBuffer(),this);
			addfilethread->ResumeThread();
d509 5
a513 5
		UpdateCompletedInfos();
		if ( completedsize > transfered )
			m_iGainDueToCompression = completedsize - transfered;
		else if ( completedsize != transfered )
			m_iLostDueToCorruption = transfered - completedsize;
d515 1
a515 1
		return true;
d517 1
a517 1
		EMULE_CATCH
d519 1
a519 1
			return false;
d526 1
a526 1
		switch (status){
d531 15
a545 15
		}
		FILE* file = 0;
		try{
			//backup part.met file
			CString bakname;
			bakname.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
			::CopyFile(fullname, bakname, FALSE);

			//get filedate
			CFileFind ff;
			char* searchpath = nstrdup(fullname);
			searchpath[strlen(fullname)-4] = 0;
			bool end = !ff.FindFile(searchpath,0);
			delete[] searchpath;
			if (!end)
d547 9
a555 88
			if (end || ff.IsDirectory())
				throw GetResString(IDS_ERR_PART_FNF);
			CTime lwtime;
			ff.GetLastWriteTime(lwtime);
			date = mktime(lwtime.GetLocalTm());
			ff.Close();
			uint32 lsc = mktime(lastseencomplete.GetLocalTm());
			CString backupName(fullname);
			backupName.Append(".backup");

			remove(backupName);
			rename(fullname, backupName);

			// readfile data form part.met file
			file = fopen(fullname,"wbS");
			if (!file)
				throw GetResString(IDS_ERR_OPENMETFILE);
			//version
			uint8 version = PARTFILE_VERSION;
			fwrite(&version,1,1,file);
			//date
			fwrite(&date,4,1,file);
			//hash
			fwrite(&filehash,16,1,file);
			CSingleLock Lock(&m_hashlistMutex,TRUE);
			uint16 parts = hashlist.GetCount();
			fwrite(&parts,2,1,file);
			for (int x = 0; x != parts; x++)
				fwrite(hashlist[x],16,1,file);
			Lock.Unlock();
			//tags
			uint32 tagcount = taglist.GetCount()+7+(gaplist.GetCount()*2);
			fwrite(&tagcount,4,1,file);
			CTag* nametag = new CTag(FT_FILENAME,filename);
			nametag->WriteTagToFile(file);
			delete nametag;
			CTag* sizetag = new CTag(FT_FILESIZE,filesize);
			sizetag->WriteTagToFile(file);
			delete sizetag;
			CTag* transtag = new CTag(FT_TRANSFERED,transfered);
			transtag->WriteTagToFile(file);
			delete transtag;
			CTag* statustag = new CTag(FT_STATUS,(paused)? 1:0);
			statustag->WriteTagToFile(file);
			delete statustag;
			// Modified by Tarod for DAP
			CTag* prioritytag ;
			if (IsAutoPrioritized())
				prioritytag = new CTag(FT_PRIORITY,(uint8)PR_AUTO);
			else 
				prioritytag = new CTag(FT_PRIORITY,priority);
			prioritytag->WriteTagToFile(file);
			delete prioritytag;
			// End by Tarod
			CTag* lsctag = new CTag(FT_LASTSEENCOMPLETE,lsc);
			lsctag->WriteTagToFile(file);
			delete lsctag;

			// Modified by Tarod for UAP
			CTag* ulprioritytag;
			if (CKnownFile::IsAutoPrioritized())
				ulprioritytag = new CTag(FT_ULPRIORITY, PR_AUTO);
			else
				ulprioritytag = new CTag(FT_ULPRIORITY,m_iPriority);
			ulprioritytag->WriteTagToFile(file);
			delete ulprioritytag;
			// End by Tarod
			for (uint32 j = 0; j != taglist.GetCount();j++)
				taglist[j]->WriteTagToFile(file);
			//gaps
			char* namebuffer = new char[10];
			char* number = &namebuffer[1];
			uint16 i_pos = 0;
			for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos)){
				itoa(i_pos,number,10);
				namebuffer[0] = FT_GAPSTART;
				CTag* gapstarttag = new CTag(namebuffer,gaplist.GetAt(pos)->start);
				gapstarttag->WriteTagToFile(file);
				// gap start = first missing byte but gap ends = first non-missing byte in edonkey
				// but I think its easier to user the real limits
				namebuffer[0] = FT_GAPEND;
				CTag* gapendtag = new CTag(namebuffer,(gaplist.GetAt(pos)->end)+1);
				gapendtag->WriteTagToFile(file);
				delete gapstarttag;
				delete gapendtag;
				i_pos++;
			}
			delete[] namebuffer;
d557 2
a558 10
			// START - enkeyDEV(Ottavio84) -ChangeDir-
			if (!m_alternativepath.IsEmpty()) {
				CString dfpath = CString(fullname) + CString(".dir");
				CStdioFile f;
				if (f.Open(dfpath, CFile::modeCreate | CFile::modeWrite | CFile::typeText)) {
					f.WriteString((LPCTSTR)m_alternativepath);
					f.Close();			
				}
			}
			// END - enkeyDEV(Ottavio84) -ChangeDir-
d560 108
a667 2
			if (ferror(file))
				throw CString("unexpected write error");
d669 1
a669 20
			remove(backupName);
		}	
		catch(char* error){
			OUTPUT_DEBUG_TRACE();
			if (file)
				fclose(file);
			AddLogLine(false,GetResString(IDS_ERR_SAVEMET),error,partmetfilename,filename);
			return false;
		}
		catch(CString error){
			OUTPUT_DEBUG_TRACE();
			if (file)
				fclose(file);
			AddLogLine(false,GetResString(IDS_ERR_SAVEMET),error.GetBuffer(),partmetfilename,filename);
			return false;
		}
		fclose(file);
		return true;

		EMULE_CATCH
d671 1
a671 1
			return false;
d678 1
a678 1
		newdate = true;
d717 1
a717 1
		POSITION pos1, pos2;
d756 2
a757 2
		if (end >= filesize)
			end = filesize-1;
d770 1
a770 1
		return false;
d777 2
a778 2
		if (end >= filesize)
			end = filesize-1;
d788 1
a788 1
		return false;
d795 5
a799 5
		for (POSITION pos =  requestedblocks_list.GetHeadPosition();pos != 0; requestedblocks_list.GetNext(pos)){
			Requested_Block_Struct* cur_block =  requestedblocks_list.GetAt(pos);
			if ((start <= cur_block->EndOffset) && (end >= cur_block->StartOffset))
				return true;
		}
d801 1
a801 1
		EMULE_CATCH
d803 1
a803 1
			return false;
d811 1
a811 1
		Gap_Struct *firstGap;
d862 1
a862 1

d889 2
a890 2
		// No suitable gap found
		return false;
d952 1
a952 1
		POSITION pos1, pos2;
d991 1
a991 1
		uint32 allgaps = 0; 
d1000 2
a1001 2
		percentcompleted = ((1.0f-(float)allgaps/filesize)) * 100; 
		completedsize = (uint32)((filesize-(allgaps+1))); 
d1014 1
a1014 1
		const COLORREF crProgress=(bFlat)?RGB(0, 150, 0):RGB(0, 192, 0); 
d1043 1
a1043 1
					gapdone = true; 
d1045 1
a1045 1
					gapend = (i+1)*PARTSIZE; // and next  part 
d1050 3
a1052 3
					color = RGB(0, 
					(210-(22*(m_SrcpartFrequency[i]-1)) <  0)? 0:210-(22*(m_SrcpartFrequency[i]-1)) 
					,255); 
d1054 1
a1054 1
					color = crMissing; 
d1059 1
a1059 1
					break; 
d1061 2
a1062 2
					gapstart = gapend; 
					gapend = cur_gap->end; 
d1104 1
a1104 1

d1134 1
a1134 1
		s_LoadBar.Draw(dc, gaprect.left, gaprect.top, false); 
d1143 1
a1143 1
		dc->FillRect(&gaprect, &CBrush(crProgress)); 
d1150 1
a1150 1
		//draw gray progress only if flat 
d1153 1
a1153 1
		dc->FillRect(&gaprect, &CBrush(RGB(224,224,224)));
d1164 1
a1164 1
		uint16 parts = GetPartCount();
d1172 1
a1172 1
				//--- :xrmb ---
d1189 1
a1189 1
		int counter=0;
d1192 7
a1198 7
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
			if (cur_src->GetDownloadState()!=DS_ONQUEUE && cur_src->GetDownloadState()!=DS_DOWNLOADING &&
				cur_src->GetDownloadState()!=DS_NONEEDEDPARTS) counter++;
		}
		return counter;
d1200 1
a1200 1
		EMULE_CATCH
d1202 1
a1202 1
			return 0;
d1209 1
a1209 1
		uint16 counter=0;
d1212 1
a1212 1
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
d1216 3
a1218 3
			if (cur_src->GetDownloadState()!=DS_ONQUEUE && cur_src->GetDownloadState()!=DS_DOWNLOADING) counter++;
		}
		return counter;
d1220 1
a1220 1
		EMULE_CATCH
d1222 1
a1222 1
			return 0;
d1229 4
a1232 4
		if ((!paused) || status == PS_ERROR || ignorepause)
			return status;
		else
			return PS_PAUSED;
d1242 1
a1242 1
		uint16 result = 0; 
d1259 1
a1259 1
		return 0;
d1270 1
a1270 1
		POSITION pos1, pos2;
d1272 8
a1279 9
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for (pos1 = srclists[sl].GetHeadPosition(); (pos2 = pos1) != NULL && removed < number_sources_to_remove;) {
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
			if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS) 
			{
				theApp.downloadqueue->RemoveSource(cur_src);
				removed ++; // Count removed source
			}
d1281 1
d1283 1
a1283 1
		EMULE_CATCH
d1285 1
a1285 1
			lastpurgetime = ::GetTickCount();
d1288 1
a1288 15
void CPartFile::AddDownloadingSource(CUpDownClient* client){
	POSITION pos = m_downloadingSourceList.Find(client); // to be sure
	if(pos == NULL){
		m_downloadingSourceList.AddTail(client);
	}
}

void CPartFile::RemoveDownloadingSource(CUpDownClient* client){
	POSITION pos = m_downloadingSourceList.Find(client); // to be sure
	if(pos != NULL){
		m_downloadingSourceList.RemoveAt(pos);
	}
}

uint32 CPartFile::Process(uint32 reducedownload, uint8 m_icounter/*in percent*/)
d1292 1
a1292 1
		DWORD dwCurTick = ::GetTickCount();
d1302 14
d1318 9
d1328 13
a1340 11
	if(m_icounter < 10){
		for(POSITION pos = m_downloadingSourceList.GetHeadPosition();pos!=0;){
			CUpDownClient* cur_src = m_downloadingSourceList.GetNext(pos);
			if(cur_src){
				uint32 cur_datarate = cur_src->CalculateDownloadRate();
				datarate+=cur_datarate;
				if(reducedownload){
					uint32 limit = reducedownload*cur_datarate/1000;
					if(limit<1000 && reducedownload == 200)
						limit +=1000;
					else if(limit<1)
a1342 1
				}
d1344 5
d1350 12
a1361 1
		transferingsrc = m_downloadingSourceList.GetCount();
d1363 5
a1367 11
	}
	else{
		POSITION pos1, pos2;
		for (uint32 sl = 0; sl < SOURCESSLOTS; sl++)
		{
			if (!srclists[sl].IsEmpty())
			{
				for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;)
				{
					srclists[sl].GetNext(pos1);
					CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1369 25
a1393 2
					uint32 usethisfilereasktime = FILEREASKTIME;
					bool sockets_usage_high = theApp.listensocket->GetOpenSockets() > (theApp.glob_prefs->GetMaxConnections() * 0.75);
d1395 17
a1411 90
					switch (cur_src->GetDownloadState())
					{
					case DS_DOWNLOADING:{
						transferingsrc++;
						uint32 cur_datarate = max(cur_src->CalculateDownloadRate(), 0);
						datarate += cur_datarate;
						if (reducedownload && cur_src->GetDownloadState() == DS_DOWNLOADING){
							uint32 limit = reducedownload*cur_datarate/1000; //(uint32)(((float)reducedownload/100)*cur_datarate)/10;		
							if (limit < 1000 && reducedownload == 200)
								limit += 1000;
							else if (limit < 1)
								limit = 1;
							cur_src->socket->SetDownloadLimit(limit);
						}
						else if( m_nSavedReduceDownload != reducedownload )
							cur_src->socket->DisableDownloadLimit();
						m_nSavedReduceDownload  = reducedownload;
						break;
										}
					case DS_BANNED:
					case DS_ERROR:
						break;
					case DS_LOWTOLOWIP:	// if we now have a high ip we can ask
						if( ((dwCurTick - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
							theApp.downloadqueue->RemoveSource(cur_src);
							lastpurgetime = dwCurTick;
							break;
						}
						if (theApp.serverconnect->IsLowID())
							break;
					case DS_NONEEDEDPARTS:{ 

						// doubled reasktime for no needed parts - save connections and traffic
						//Vorlost, noneededparts-sources will be checked filereasktime*4 when 3/4 of max. sockets are open 
						if (sockets_usage_high)
							usethisfilereasktime = FILEREASKTIME * 2;
						//End Vorlost for Expanded Filereasktime 

						// doubled reasktime for no needed parts - save connections and traffic
						if (!((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime*2))
							break;
										  }
					case DS_ONQUEUE:{
						if ( cur_src->GetRemoteQueueRank()
							&& sockets_usage_high
							) { //Vorlost QueueRank > 250 --> Filereasktime=45minutes
								if ( cur_src->GetRemoteQueueRank() > 250 )
									usethisfilereasktime = FILEREASKTIME * 2.5 ; //Vorlost
								else usethisfilereasktime = FILEREASKTIME * 2; //Vorlost (QR 1-250 = 36minutes)

							}

							// LANCAST (moosetea) - We reask much faster if lancast user, UDP happens in 10 seconds
							if (cur_src->isOnLAN()){
								if ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMEUDP){
									cur_src->UDPReaskForDownload();
								}
							}
							else {
								if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime-20000)){
									cur_src->UDPReaskForDownload();
								}
							}

							// Check Remote queue position
							if ((theApp.glob_prefs->UseRemoteQueueLimit() && !cur_src->IsRemoteQueueFull()) && (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetRemoteQueueLimit())) {
								theApp.downloadqueue->RemoveSource(cur_src);
								break;
							}
									}
					case DS_CONNECTING:
					case DS_TOOMANYCONNS:
					case DS_CONNECTED:
					case DS_NONE:
					case DS_WAITCALLBACK:

						// LANCAST (moosetea) - Because reask much faster if lancast user ie we may reask as soon as we get disconnected
						// , we only use TCP on a LAN, because emule may try to send a TCP request and UDP request at the same time!
						if (cur_src->isOnLAN()){
							if ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > LANCASTFILEREASKTIMETCP){
								cur_src->AskForDownload();
							}
						}
						else {
							//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
							if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime))
								cur_src->AskForDownload();
						}
						break;
					}
d1414 6
d1421 3
d1426 15
a1440 15
		// swap No needed partfiles if possible
		// Modified by Tarod -now handles A4AF too keeping usage of CPU less and do not forcing files
		// that has No Needed Parts to download letting them swap to another file
		if (((!m_LastNoNeededCheck) || (dwCurTick - m_LastNoNeededCheck) > 10000)){
			m_LastNoNeededCheck = dwCurTick;
			POSITION pos1,pos2;
			for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
				for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
					srclists[sl].GetNext(pos1);
					CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
					if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS)
						cur_src->SwapToAnotherFile(false);
					// if this file has activated A4AF auto just hang to another file if we can
					else if (IsA4AFAuto() && (cur_src->GetDownloadDatarate() == DS_ONQUEUE || cur_src->GetDownloadDatarate() == DS_LOWTOLOWIP)
						&& memcmp(cur_src->GetUploadFileID(), GetFileHash(), 16) != 0) {
d1442 3
a1444 3
							cur_src->HandoverToAnotherFile(this);
						}
				}
d1446 3
a1448 4
				// Added by Tarod -if is A4AF auto then swith every A4AF source to this file
				if (IsA4AFAuto()) {
					theApp.emuledlg->transferwnd.downloadlistctrl.DownloadAllA4AF(this);
				}
d1450 1
d1452 3
a1454 3
		/*
		// Added by Tarod (remove no needed parts after FILEREASKTIME * 2 + 10000)
		if (theApp.glob_prefs->GetMaxSourcePerFileSoft() == GetSourceCount()
d1456 2
a1457 2
		&& ((m_LastRemovedTime == 0) || (::GetTickCount() - m_LastRemovedTime) > FILEREASKTIME * 2 + 10000))
		{
d1460 4
a1463 4
		}
		else if (theApp.glob_prefs->IsRemoveNNSEnabled() 
		&& ((m_LastRemovedTime == 0) || (::GetTickCount() - m_LastRemovedTime) > FILEREASKTIME * 2 + 10000))
		{
d1466 2
a1467 2
		}
		*/
d1469 15
d1485 8
a1492 38
		// check if we want new sources from server
		//uint16 test = theApp.glob_prefs->GetMaxSourcePerFileSoft();
		if (( (!lastsearchtime) || (dwCurTick - lastsearchtime) > SERVERREASKTIME) && theApp.serverconnect->IsConnected()
			&& theApp.glob_prefs->GetMaxSourcePerFileSoft() > GetSourceCount() && !stopped )
		{
			//local server
			lastsearchtime = dwCurTick;
			Packet* packet = new Packet(OP_GETSOURCES,16);
			memcpy(packet->pBuffer,filehash,16);
			theApp.uploadqueue->AddUpDataOverheadServer(packet->size);
			theApp.serverconnect->SendPacket(packet,true);
			//AddDebugLogLine( false, "Send:Source Request Server File(%s)", GetFileName() );
		}

		count++;
		if (count == 3){
			count = 0;
			//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
			UpdateDisplayedInfo();
			if(m_bPercentUpdated == false)
				UpdateCompletedInfos();
			m_bPercentUpdated = false;
		}
		// calculate datarate, set limit etc.
		///////////////////////////////////////////////////////
		//for saving/reloading source to/from disk: mr fry
		#ifdef OLD_SLS_ENABLED
		if(GetStatus() < 2 && theApp.downloadqueue->IsSourcesLoadingEnabled()){
			uint32 currentTime = ::GetTickCount();

			if(!m_bWasConnectedToServerLastTime && theApp.serverconnect->IsConnected()){
				//if connection-state has switch from: not connected -> connected...
				#ifdef _DEBUG_SAVED_SOURCES
					TRACE("CPartFile::Process : slow loading of sources down if a connection is established (next time sources are loaded for %s: in %.1f sec)\n"
						,GetFileName(),(float(m_iLoadingSourcesPartialTimeInterval)/1000));
				#endif
				m_iLastTimeSourcesLoadedPartial = ::GetTickCount();
			}
d1494 8
a1501 5
			//load sources in slow mode (while they weren't completely loaded yet)?
			if(!m_bLoadedSourcesCompletely && theApp.serverconnect->IsConnected() && !theApp.downloadqueue->IsMaxClientsExceeded())
				//			&& theApp.listensocket->GetOpenSockets() < theApp.glob_prefs->GetMaxConnections()-20-RESTORE_SOURCES_AT_ONCE) // Vorlost
			{  
				if(currentTime - m_iLastTimeSourcesLoadedPartial > m_iLoadingSourcesPartialTimeInterval)
d1503 4
a1506 14
					// makes room for more loaded sources
					if (theApp.glob_prefs->IsRemoveNNSEnabled()) //Vorlost added prefs question
					{
						int source_count_plus_needed = GetSourceCount() + GetLoadSourcesAtOnceLimit();
						if (source_count_plus_needed > theApp.glob_prefs->GetMaxSourcePerFile()
							&& ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME))
							RemoveNoNeededSources(source_count_plus_needed - theApp.glob_prefs->GetMaxSourcePerFile());
					}

					//is a permanent opened CStoredSources-object for each part-file wanted?
					if(theApp.downloadqueue->KeepStoredSourcesOpen())
						AddFromStoredSources(m_stscrStoringSources,false,GetLoadSourcesAtOnceLimit());
					else
						LoadAndAddSources(false,false,GetLoadSourcesAtOnceLimit());
d1508 6
d1515 3
a1517 2
			//(re-) load sources?
			else if((currentTime - m_iLastTimeSourcesLoaded) > m_iLoadingSourcesTimeInterval  
d1519 1
a1519 1
				//				&& theApp.listensocket->GetOpenSockets() < theApp.glob_prefs->GetMaxConnections()-20-RESTORE_SOURCES_AT_ONCE) // Vorlost
d1521 13
d1535 15
a1549 17
				#ifdef _DEBUG_SAVED_SOURCES
					TRACE("Reloading all sources for %s\n",GetFileName());
				#endif
				// Added by Tarod -before reload purge outdated and no needed sources
				// remember that this only occurs first time -first group of loaded sources
				if(m_stscrStoringSources != NULL)
				{
					m_stscrStoringSources->DeleteOutdatedSources();
					m_stscrStoringSources->SortSourcesByPartsNDate();
					m_stscrStoringSources->ReduceSourcesTo(m_stscrStoringSources->GetMaxSourceEntries());
				}
				if (theApp.glob_prefs->IsRemoveNNSEnabled())  //Vorlost added prefs question
				{
					int source_count_plus_needed = GetSourceCount() + GetLoadSourcesAtOnceLimit();
					if (source_count_plus_needed > theApp.glob_prefs->GetMaxSourcePerFile())
						RemoveNoNeededSources(source_count_plus_needed - theApp.glob_prefs->GetMaxSourcePerFile());
				}
d1551 6
a1556 6
				//is a permanent opened CStoredSources-object for each part-file wanted?
				if(theApp.downloadqueue->KeepStoredSourcesOpen()) {
					//as in the previous if(), but with AddFrom..(..,true); -> reset=true means, begin again to load all sources from stored-sources
					AddFromStoredSources(m_stscrStoringSources,false,GetLoadSourcesAtOnceLimit(),true);
				} else
					LoadAndAddSources(false,false,GetLoadSourcesAtOnceLimit(),true);
d1558 15
a1572 27
			//save sources?
			if((currentTime - m_iLastTimeSourcesSaved) > m_iSavingSourcesTimeInterval
				&& m_bLoadedSourcesCompletely){

					//only save to disk now, if there is no permantent opened CStoredSources-object for this part-file
					if(!theApp.downloadqueue->KeepStoredSourcesOpen()){
						#ifdef _DEBUG_SAVED_SOURCES
							TRACE("(automatically) saving sources for %s to disk\n",GetFileName());
						#endif
						SaveSources(true);
					}
					else if(m_stscrStoringSources != NULL){//sort, so we get the best sources first, the next time they're loaded
						//if (!m_stscrStoringSources->IsRareFile()) m_stscrStoringSources->DeleteOutdatedSources();
						m_stscrStoringSources->SortSourcesByPartsNDate();
						SaveSources(false);
						//m_stscrStoringSources->ReduceSourcesTo(m_stscrStoringSources->GetMaxSourceEntries());
					}

					// Added by Tarod fixed bug of CPU usage (por fin, me cago en la puta hostia, joder!!!)
					m_iLastTimeSourcesSaved = ::GetTickCount();
				}

				m_bWasConnectedToServerLastTime = theApp.serverconnect->IsConnected();
		}//end: if(status)
		////////////////////////////////////////////////////////
		#endif //OLD_SLS_ENABLED
	}
d1577 1
a1577 1
		return 0;
d1583 4
a1586 4

		//if this part file is paused or complete/completing no sources needed any more
		if(GetStatus()==PS_PAUSED || GetStatus() > 7)		//Cax2 + SyruS check
			return;
d1593 7
a1599 7
	{
		// Added by Tarod - if there is needed place for more sources just remove NNS
		int source_count_plus_new = GetSourceCount() + count;
		if (source_count_plus_new > theApp.glob_prefs->GetMaxSourcePerFile()
			&& ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME))
			RemoveNoNeededSources(source_count_plus_new - theApp.glob_prefs->GetMaxSourcePerFile());
	}
d1626 1
a1626 1
	//	AddDebugLogLine(false,"RCV: %i sources from server, %i low id dropped, %i possible sources",count,debug_lowiddropped,debug_possiblesources);
d1635 1
a1635 1
		uint16 partcount = GetPartCount();
d1648 7
a1654 8
		for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;){
			CUpDownClient* cur_src = srclists[sl].GetNext(pos);
			uint8* partstatus = cur_src->GetPartStatus();
			if(partstatus)
				for (int i = 0; i != partcount; i++){
					if (partstatus[i])
						m_SrcpartFrequency[i] +=1;
				}
d1656 3
a1658 2
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		UpdateDisplayedInfo();
d1660 1
a1660 1
		EMULE_CATCH
d1668 2
a1669 2
		if(sender == NULL)
			return 0xffff;
d1671 1
a1671 1
	//	#define BLOCKCOUNT 3 
d1675 7
a1681 7
	uint8 mode = GetMovieMode();
	// Mode 0=NoPreview,1=AVI(1F,1L),2=AVI(2F,1L),3=AVI(3F,1L)
	// Mode 4=MPG(1F),5=MPG(2F),6=MPG(3F),7=AVI/MPG(2F,2L) F=First,L=Last
	uint8 rarechunk = 10; //Up to this value a chunk is very rare,if more we complete first
	uint8 raremovie = 5; //Up to this value no moviechunks will be loaded first
	//, but could happen earlier if it doesnt make any difference(preview enabled), otherwise random
	bool forcepreview = false; //true will ignore rare-chunks completely if a moviechunk is available
d1683 2
a1684 2
	_Bvector gettingParts;
	sender->ShowDownloadingParts(gettingParts);
d1687 2
a1688 2
	CList<int,int> liGoodParts;
	CList<int,int> liPossibleParts;
d1696 1
a1696 1
			if (GetNextEmptyBlockInPart(randomness,0)) //Search for next empty Block... 
d1700 10
a1709 4
					if(gettingParts[randomness]) {
						goodpart = randomness;
					} else
						if(!gettingParts[goodpart] && m_SrcpartFrequency[goodpart] > rarechunk && m_SrcpartFrequency[randomness] > rarechunk) //Non-rare chunks found yet
d1711 2
a1712 1
							if (PrepareComparePart(randomness) < PrepareComparePart(goodpart)) //and is this new chunk more completed ?
d1714 1
a1714 8
								if (Movie1(mode,goodpart,randomness)) goodpart = randomness;  //Then we want it ! 
							} 
							else
							{
								if (PrepareComparePart(randomness) == PrepareComparePart(goodpart) //Is the new chunk same complete
									&& m_SrcpartFrequency[randomness] < m_SrcpartFrequency[goodpart]) //and rarer ?
								{
									if (Movie1(mode,goodpart,randomness))
a1715 3
								} 
								else if (Movie2(mode,raremovie,forcepreview,goodpart,randomness))
									goodpart = randomness; //Normally we dont want it, what do you think Movie2 ?
d1717 2
d1720 6
a1725 1
						else //The memorized or the new chunk is a very rare one
d1727 1
a1727 3
							if (m_SrcpartFrequency[randomness] < m_SrcpartFrequency[goodpart]) //Is the new chunk rarer than the memorized ? 
								goodpart = randomness; //Then we want it ! 
							else if (m_SrcpartFrequency[randomness] == m_SrcpartFrequency[goodpart]) //old & new chunk are both same available ?
d1729 2
a1730 7
								if (PrepareComparePart(randomness) < PrepareComparePart(goodpart)) //and is this new chunk more completed ?
								{
									if (Movie1(mode,goodpart,randomness))
										goodpart = randomness; //Then we want it ! If Movie1 allows us
								} 
								else if (Movie2(mode,raremovie,forcepreview,goodpart,randomness))
									goodpart = randomness; //Normally we dont want it, what do you think Movie2 ?
d1732 2
d1735 1
d1749 1
a1749 1
		return 0xffff;
d1757 1
a1757 1
		POSITION pos1,pos2;
d1759 1
a1759 1
		requestedblocks_list.GetNext(pos1);
d1776 2
a1777 2
		if( srcarevisible )
			theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this);
d1809 1
a1809 1
		CSingleLock(&m_FileCompleteMutex,TRUE); // will be unlocked on exit
d1816 1
a1816 1

d1820 1
a1820 1

d1826 1
a1826 1

d1829 1
a1829 1

d1834 1
a1834 1

d1837 1
a1837 1

d1842 18
a1859 18

			if(first != NULL)
			{
				first++;
				bool found = true;
				for(char *step = first; step < last - 1; step++)
					if(*step < '0' || *step > '9')
					{
						found = false;
						break;
					}
					if(found)
					{
						namecount = atoi(first);
						last = first - 1;
						last[0] = 0;  //truncate again
					}
			}
d1865 1
a1865 1
			namecount++; 
d1867 5
a1871 5
				newfilename, namecount, min(ext + 1, newfilename + length)); 
		}
		while(PathFileExists(strTestName));
		delete[] newname;
		newname = nstrdup(strTestName);
d1873 1
a1873 1
	delete newfilename; 
d1878 26
a1903 26

	// we do this only if SlowComplete enabled 
	// AND the files are on the different HDs (paratitions) - check by the drive leter 
	// AND any of path is not in URL/Network format (has : as second leter) 
	if (bSlowComplete && (_toupper(partfilename[0]) != _toupper(newname[0]) && partfilename[1] == _T(':') 
		&& newname[1] == _T(':'))) 
	{
		CFile fInputFile; 
		CFile fOutputFile; 
		try 
		{ 
			CString strTempNew   =   CString(newname); 
			strTempNew += _T(".$$$"); 
			// We going to write everithing into the temporary file at same place the newname located 
			// and after we finished - rename , this will take care of syncronization problem with SharedFiles 
			if (!fInputFile.Open(partfilename,CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary 
				| CFile::osSequentialScan)) 
			{ 
				// let catch to care about closing everything 
				throw CString(_T(GetResString(IDS_ERR_SLOWREAD)+" ("+partfilename+")"));
				return FALSE; 
			} 
			if (!fOutputFile.Open(strTempNew,CFile::modeWrite | CFile::shareExclusive | CFile::osSequentialScan | CFile::modeCreate)) 
			{ 
				fInputFile.Close(); 
				// let catch to care about closing everything 
d1905 2
a1906 2
				return FALSE; 
			} 
d1908 31
a1938 50
			DWORD dwRead = 0; 
			char *buffer = new char[BlockSize]; 
			if (!buffer) 
			{ 
				// let catch to care about closing everything 
				throw CString(_T(GetResString(IDS_ERR_OUTMEM))); 
				return FALSE; 
			} 

			// Most of the work done here 
			// just copy the file data from one to another 
			do 
			{ 
				dwRead = fInputFile.Read(buffer, BlockSize ); 
				fOutputFile.Write(buffer, dwRead); 
				Sleep(0); // release the CPU for other processes 
				// may be real sleep needed here , not sure 
			} 
			while (dwRead > 0); 
			delete []buffer; 

			fInputFile.Close(); 
			fOutputFile.Close(); 
			// Rename temporary file back to normal name 
			if (rename(strTempNew,newname))
			{ 
				// let catch to care about closing everything 
				throw CString(_T(GetResString(IDS_ERR_RENFAIL))); 
				return FALSE; 
			}
			CFile::Remove(partfilename); // This removes old Part file
		} 
		catch(CString str) 
		{ 
			delete[] partfilename; 
			delete[] newname; 
			AddLogLine(true,str); 
			paused = true; 
			status = PS_ERROR; 
			return FALSE; 
		} 
		catch(...) 
		{ 
			delete[] partfilename; 
			delete[] newname; 
			if(this)
				AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
			paused = true; 
			status = PS_ERROR; 
			return FALSE; 
d1940 18
d1961 7
a1967 7
			delete[] partfilename; 
			delete[] newname; 
			AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
			paused = true; 
			status = PS_ERROR; 
			return FALSE; 
		}
d1969 4
a1972 4
	// Lord KiRon - end

	if (remove(fullname)) 
		AddLogLine(true,GetResString(IDS_ERR_DELETEFAILED),fullname); 
d1980 8
a1987 8
	//////////////////////////////// 
	//remove *.src file (thx to brotbuexe) 
	CString srcName="";
	srcName.Format("%s\\%s.stsrc",tempdir,GetPartMetFileName());
	if (remove(srcName))
		if (errno != ENOENT)
			AddLogLine(true,GetResString(IDS_FAILDELETE),srcName); 

d2005 4
a2008 4
	delete[] partfilename; 
	delete[] fullname; 
	fullname = newname; 
	delete[] directory; 
d2013 2
a2014 2
	status = PS_COMPLETE;
	paused = false;
d2016 13
a2028 5
	AddLogLine(true,GetResString(IDS_DOWNLOADDONE),GetFileName()); 
	theApp.emuledlg->ShowNotifier(GetResString(IDS_TBN_DOWNLOADDONE)+"\n"+GetFileName(), TBN_DLOAD); 
	if (renamed) 
		AddLogLine(true, GetResString(IDS_DOWNLOADRENAMED), strrchr(newname, '\\') + 1); 
	theApp.knownfiles->SafeAddKFile(this); 
d2030 3
a2032 11
	// Added to change UAP to Normal after finished download of file by Tarod 
	if (CKnownFile::IsAutoPrioritized())
	{ 
		CKnownFile::SetAutoPriority(false); 
		CKnownFile::SetPriority(PR_NORMAL); 
	} 
	// End Tarod 

	theApp.downloadqueue->RemoveFile(this); 
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this); 
	UpdateDisplayedInfo();
d2035 5
a2039 5
	// Added by Tarod (starts next paused file) 
	if (theApp.glob_prefs->DownloadPausedOnComplete())
	{ 
		theApp.downloadqueue->StartPausedDownload() ; 
	} 
d2041 2
a2042 2
	//	transfered = filesize;
	return TRUE; 
d2046 1
a2046 1
		return FALSE; 
d2054 2
a2055 2
		//TODO transfer sources to other downloading files if possible
		POSITION pos1,pos2;
d2057 4
a2060 7
		for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
			srclists[sl].GetNext(pos1);
			if (bTryToSwap){
				if (!srclists[sl].GetAt(pos2)->SwapToAnotherFile(true))
					theApp.downloadqueue->RemoveSource(srclists[sl].GetAt(pos2));
			}
			else
d2063 3
d2067 2
a2068 2
		UpdateFileRatingCommentAvail();
		EMULE_CATCH
d2075 1
a2075 1
		ASSERT ( !m_bPreviewing );
d2089 1
a2089 1
	// START - enkeyDEV(Ottavio84) -ChangeDir-
d2099 1
a2099 1
		AddLogLine(true,GetResString(IDS_FAILDELETE),srcName);
d2104 1
a2104 1
		AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2109 1
a2109 1
		AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2120 1
a2120 1

d2130 23
a2152 9
		if ((GetHashCount() <= partnumber) && (GetPartCount() > 1)){
			AddLogLine(true,GetResString(IDS_ERR_HASHERRORWARNING),GetFileName());
			this->hashsetneeded = true;
			return true;
		}
		else if(!GetPartHash(partnumber) && GetPartCount() != 1){
			AddLogLine(true,GetResString(IDS_ERR_INCOMPLETEHASH),GetFileName());
			this->hashsetneeded = true;
			return true;		
d2155 1
a2155 15
			uchar hashresult[16];
			m_hpartfile.Seek((LONGLONG)PARTSIZE*partnumber,0);
			uint32 length = PARTSIZE;
			if (PARTSIZE*(partnumber+1) > m_hpartfile.GetLength())
				length = (m_hpartfile.GetLength()- (PARTSIZE*partnumber));
			CreateHashFromFile(&m_hpartfile,length,hashresult);

			if (GetPartCount() > 1){
				if (memcmp(hashresult,GetPartHash(partnumber),16))
					return false;
				else
					return true;
			}
			else{
				if (memcmp(hashresult,filehash,16))
a2158 1
			}
d2160 1
d2162 1
a2162 1
		EMULE_CATCH
d2164 1
a2164 1
			return false;
d2171 1
a2171 1
		return corrupted_list.Find(partnumber);
d2175 1
a2175 1
		return true;
d2188 2
a2189 2
		// DonGato, updated by Vorlost
		CString fname = GetFileName();
d2196 1
a2196 1
		return false;
d2203 2
a2204 2
		// DonGato, updated by Vorlost
		CString fname = GetFileName();
d2216 1
a2216 1
		return false;
d2223 1
a2223 1
		uint32 lastblock = ceil((float)PARTSIZE/BLOCKSIZE),end;
d2229 64
a2292 64
	case 0: //Mode 0: No Preview
		return false;
		break;
	case 1: //Mode 1: 1F,1L(2L) AVI
		if (chunk == 0)
			return true; //1F
		if (chunk == GetPartCount()-1)
			return true; //1L is a moviechunk ?
		if (chunk == (GetPartCount()-2) && (((GetFileSize()-1) - MINLASTMOVIESIZE ) <= end))
			return true; //2L is a Part of 1/8L at the end of the file
		break;
	case 2: //Mode 2: 1F,2F,1L(2L) Long AVI
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == GetPartCount()-1)
			return true; //1L is a moviechunk ?
		if (chunk == (GetPartCount()-2) && (((GetFileSize()-1) - MINLASTMOVIESIZE ) <= end))
			return true; //2L is a Part of 1/8L at the end of the file
		break;
	case 3: //Mode 3: 1F,2F,3F,1L(2L) Longest AVI
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == 2)
			return true; //3F
		if (chunk == GetPartCount()-1)
			return true; //1L is a moviechunk
		if (chunk == (GetPartCount()-2) && (((GetFileSize()-1) - MINLASTMOVIESIZE ) <= end))
			return true; //2L is a Part of 1/8L at the end of the file
		break;
	case 4: //Mode 4: 1F MPG
		if (chunk == 0)
			return true; //1F
		break;
	case 5: //Mode 5: 1F,2F Long MPG
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		break;
	case 6: //Mode 6: 1F,2F,3F Longest MPG
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == 2)
			return true; //3F
		break;
	case 7: //Mode 7: 1F,2F,1L,2L AVI/MPG normal
		if (chunk == 0)
			return true; //1F
		if (chunk == 1)
			return true; //2F
		if (chunk == GetPartCount()-1) 
			return true; //1L is a moviechunk ?
		if (chunk == GetPartCount()-2)
			return true; //2L is a moviechunk ?
		break;
	default:
		return false;
		break;
d2297 1
a2297 1
		return false;
d2304 8
a2311 8
		//The routine is based on that both old&new-chunk are moviechunks
		if (oldchunk == 0) //Chunk = 1F
		{
			// 1/8F & !1/8L & (newchunk=1L | 2L)
			if (IsComplete(0,(MINFIRSTMOVIESIZE)-1) //first 1/8 chunk present
				&& !IsComplete( (GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1) //last 1/8 chunk not present
				&& (newchunk == GetPartCount()-1  //better chunk could be 1L
				|| (newchunk == GetPartCount()-2))) //better chunk could be 2L
d2313 9
a2321 9
		}
		else if (oldchunk == GetPartCount()-1 || oldchunk == GetPartCount()-2) //Chunk = 1L | 2L
		{
			// (1/8L & !1/8F) | (1/8L & 1/8F)
			if (((!IsComplete(0,(MINFIRSTMOVIESIZE)-1) //first 1/8 chunk not present
				&& IsComplete( (GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1)) //last 1/8 chunk present
				||(IsComplete(0,(MINFIRSTMOVIESIZE)-1) //first 1/8 chunk present
				&& IsComplete( (GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1)) //last 1/8 chunk present
				&& newchunk == 0))  //better chunk could be 1F
d2323 15
a2337 15
		}
		else if (oldchunk == 1) //Chunk = 2F
		{
			// 1F | 1L
			if (newchunk == 0 || newchunk == GetPartCount()-1)
				return true;
		}
		else if (oldchunk == 2) //Chunk = 3F
		{
			// 1F | 1L otherwise 2F
			if (newchunk == 0 || newchunk == GetPartCount()-1)
				return true;
			else if (newchunk == 1)
				return true;
		}
d2339 1
a2339 1
		EMULE_CATCH
d2341 1
a2341 1
			return false;
d2349 5
a2353 1
		if (IsMovie())
d2355 2
a2356 7
			if (!IsMovieChunk(mode,newchunk) && IsMovieChunk(mode,oldchunk))
				return false;
			if (IsMovieChunk(mode,newchunk) && IsMovieChunk(mode,oldchunk))
			{
				if (!IsBetterMovieChunk(oldchunk,newchunk))
					return false;
			}
d2358 2
a2359 1
		return true;
d2361 1
a2361 1
		EMULE_CATCH
d2363 1
a2363 1
			return false;
d2371 5
a2375 5
		if (IsMovie() && ((m_SrcpartFrequency[oldchunk] > raremovie
			&& m_SrcpartFrequency[newchunk] > raremovie)      //old & new chunk are nonrare
			|| (m_SrcpartFrequency[oldchunk] == m_SrcpartFrequency[newchunk]) //old & new chunk are same rare
			|| forcepreview))            //Load preview chunks first no matter of rareness
		{
d2378 1
a2378 1
			if (!IsMovieChunk(mode,oldchunk) && IsMovieChunk(mode,newchunk))
d2380 1
a2380 1
				if (forcepreview)
d2382 2
a2383 2
			}
			if (IsMovieChunk(mode,oldchunk) && IsMovieChunk(mode,newchunk))
d2385 1
a2385 1
				if (IsBetterMovieChunk(oldchunk,newchunk))
d2387 5
a2391 5
					if (forcepreview)
						return true;
				}
			}
		}
d2393 1
a2393 1
		EMULE_CATCH
d2395 1
a2395 1
			return false;
d2402 1
a2402 1
		uint8 addchunk = 0;
d2406 5
a2410 5
		uint32 lastblock = ceil((float)PARTSIZE/BLOCKSIZE);
		uint32 lastblockinpart = lastblock;
		uint32 start;
		//Get last possible blocknumber
		for (lastblockinpart = 0; lastblockinpart != lastblock;lastblockinpart++)
d2412 5
a2416 5
			start = (PARTSIZE*chunk) + lastblockinpart*BLOCKSIZE;
			if (start >= GetFileSize())
				break;
		}
		addchunk = lastblock - lastblockinpart;
d2423 1
a2423 1
		return 0;
d2438 1
a2438 1
		priority = np;
d2451 2
a2452 2
		// Barry - Need to tell any connected clients to stop sending the file
		PauseFile();
a2456 1
	stopped=true;
d2467 23
a2489 2
{
	EMULE_TRY
d2491 1
a2491 22
		if (status==PS_COMPLETE || status==PS_COMPLETING) return;
	Packet* packet = new Packet(OP_CANCELTRANSFER,0);
	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
			if (cur_src->GetDownloadState() == DS_DOWNLOADING){
				theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
				cur_src->socket->SendPacket(packet,false,true);
				cur_src->SetDownloadState(DS_ONQUEUE);
			}
		}	
		delete packet;
		paused = true;
		datarate = 0;
		transferingsrc = 0;
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		UpdateDisplayedInfo(true);
		SavePartFile();

		EMULE_CATCH
d2498 1
a2498 1
		if (status==PS_COMPLETE || status==PS_COMPLETING) return;
a2499 1
	stopped=false;
d2503 1
a2503 1

d2516 4
a2519 4
		if (lastsearchtime>0){ 
			//AddLogLine(true,CString("Resetting LastSearchTime:%d in Filename:%s"),lastsearchtime,GetFileName());
			lastsearchtime = 0; 
		} 
d2521 1
a2521 1
		EMULE_CATCH
d2528 3
a2530 1
		switch (GetStatus()) {
d2533 2
a2534 1
			return GetResString(IDS_HASHING);
d2536 2
a2537 1
			return GetResString(IDS_COMPLETING);
d2539 2
a2540 1
			return GetResString(IDS_COMPLETE);
d2542 2
a2543 1
			return GetResString(IDS_PAUSED);
d2545 4
a2548 6
			return GetResString(IDS_ERRORLIKE);
		} 
		if(GetTransferingSrcCount() > 0)
			return GetResString(IDS_DOWNLOADING);
		else
			return GetResString(IDS_WAITING);
d2550 1
a2550 1
		EMULE_CATCH
d2552 1
a2552 1
			return "";
d2559 1
a2559 1
		// Sort order is Complete - Completing - Downloading - Waiting - Paused - Errors
d2561 1
a2561 1
		int status=2;
d2586 1
a2586 1
		return 1;
d2593 2
a2594 2
		if (GetDatarate()<=0) return -1;

d2599 1
a2599 1
		return -1;
d2606 6
a2611 6
		if (IsArchive())
		{
			if ((!m_bRecoveringArchive) && (!m_bPreviewing))
				CArchiveRecovery::recover(this, true);
			return;
		}
d2613 5
a2617 5
		if (!PreviewAvailable())
		{
			ASSERT( false );
			return;
		}
d2620 20
a2639 21
		if (theApp.glob_prefs->BackupPreview()) {
			m_bPreviewing = true;
			CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(),0, CREATE_SUSPENDED);
			pThread->SetValues(this);
			pThread->ResumeThread();
		} else {
			CString strLine = this->GetFullName();
			CString player=theApp.glob_prefs->GetVideoPlayer();
			if(player.IsEmpty())
				ShellExecute(NULL, "open", strLine, NULL,NULL, SW_SHOWNORMAL);
			else
			{
				if (player.Find("vlc.exe"))
					strLine.Replace(".met","");
				char shortPath[512]; //Cax2 short path for vlc
				GetShortPathName(strLine,shortPath,512);
				CString runDir=player;
				int i=runDir.ReverseFind('\\');
				runDir=(i>=0)?runDir.Left(i+1):"";
				ShellExecute(NULL, "open",player, shortPath, runDir, SW_SHOWNORMAL);
			}
d2641 1
d2643 1
a2643 1
		EMULE_CATCH
d2657 7
a2663 7
		//Cax2 - this would stop people from previewing almost complete movies
		//if vlan is previewing the file, the file *will not* be transfered 
		//to the incoming directory on completion, and emule will display an error message.
		//commented it out, to let our users do as they please!!!
		/*
		if ( gaplist.GetCount() <= 1 )
		{
d2665 3
a2667 3
		}
		*/
		uint64 buf1,buf2,space;
d2688 1
a2688 1
	if (!first)
d2690 2
a2691 2
		strcat(buffer,"first ");
		if (!last)
d2693 2
a2694 2
	}
	else if (!last)
d2720 1
a2720 1
		return false;
d2726 1
a2726 1
		uint8 availablecounter = 0;
d2753 1
a2753 1
		int sl;
d2763 9
a2771 9
		for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;srclists[sl].GetNext(pos)){
			bNeeded = false;
			CUpDownClient* cur_src = srclists[sl].GetAt(pos);

			// Modified by Tarod -sends sources with LowID that are in same sever
			// that client is requesting sources
			if (cur_src->HasLowID() 
				&& (cur_src->GetServerIP() != forClient->GetServerIP() || cur_src->GetServerPort() != forClient->GetServerPort()))
				continue;
d2773 3
a2775 3
			// LANCAST (moosetea) - We don't share Lan clients sources as they are private ips/userids
			if (cur_src->isOnLAN())
				continue;
d2777 3
a2779 3
			// Added by Tarod, do not send incomplete established conns. to avoid sending
			// no valid sources
			switch (cur_src->GetDownloadState()) {
d2784 1
a2784 1
				continue;
d2786 1
a2786 1
			}
d2788 8
a2795 9
			// only send source which have needed parts for this client if possible
			if (forClient->reqfile == this && forClient->GetPartStatus() && cur_src->GetPartStatus()){
				uint8* reqstatus = forClient->GetPartStatus();
				uint8* srcstatus = cur_src->GetPartStatus();
				for (int x = 0; x != GetPartCount(); x++){
					if (srcstatus[x] && !reqstatus[x]){
						bNeeded = true;
						break;
					}
a2797 13
			if( bNeeded ){
				nCount++;
				uint32 dwID = cur_src->GetUserID();
				uint16 nPort = cur_src->GetUserPort();
				uint32 dwServerIP = cur_src->GetServerIP();
				uint16 nServerPort = cur_src->GetServerPort();
				data.Write(&dwID,4);
				data.Write(&nPort,2);
				data.Write(&dwServerIP,4);
				data.Write(&nServerPort,2);
				if (nCount > 500)
					break;
			}
d2799 25
a2823 11
		if (!nCount)
			return 0;
		data.Seek(16,0);
		data.Write(&nCount,2);

		Packet* result = new Packet(&data,OP_EMULEPROT);
		result->opcode = OP_ANSWERSOURCES;
		if (nCount > 28)
			result->PackPacket();
		//AddDebugLogLine(false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount);
		return result;
d2825 1
a2825 1
		EMULE_CATCH
d2827 1
a2827 1
			return NULL;
d2834 3
a2836 3
		//if this part file is paused or complete/completing no sources needed any more
		if(GetStatus()==PS_PAUSED || GetStatus() > 7)		//Cax2 + SyruS check
			return;
d2845 8
a2852 8
		// Added by Tarod - calculate if we need more space than what is disponible
		// if so remove No Needed Sources
		int source_count_plus_new = GetSourceCount() + nCount;
		if (source_count_plus_new > theApp.glob_prefs->GetMaxSourcePerFile()
			&& ((lastpurgetime == 0) || (::GetTickCount() - lastpurgetime) > PURGE_TIME)) {

				RemoveNoNeededSources(source_count_plus_new - theApp.glob_prefs->GetMaxSourcePerFile());
			}
d2871 6
a2876 6
		for (POSITION pos = gaplist.GetHeadPosition();pos != 0;gaplist.GetNext(pos)){
			Gap_Struct* cur_gap = gaplist.GetAt(pos);
			pui32SizeToTransfer += cur_gap->end - cur_gap->start;
			if(cur_gap->end == GetFileSize()-1)
				pui32NeededSpace = cur_gap->end - cur_gap->start;
		}
d2878 1
a2878 1
		EMULE_CATCH
d2888 3
a2890 3
		//if this part-file is complete/completing no source saving is needed any more
		if(GetStatus() > 7)
			return false;
d2898 9
a2906 13
			//CFile::modeNoTruncate|
			CFile::shareDenyWrite|
			CFile::modeWrite,NULL)){
				CArchive archive(&saveSources, CArchive::store);
				archive.SetStoreParams(sizeof(CSourceEntry)*toSave->GetCountSourceEntrys()/10,sizeof(CStoredSources));
				try{
					toSave->Serialize(archive);
				}catch(CArchiveException* err){
					err->Delete();
					archive.Close();
					saveSources.Close();
					return false;
				}
d2909 5
a2913 1
				if(debug) AddLogLine(false,"Sources for '%s' (%s) were found and saved",GetPartMetFileName(),GetFileName());
d2915 1
a2915 1
				TRACE("Saved sources for %s (%s.src)\n",storedSources->GetFileName(), storedSources->GetPartFileName());
d2917 1
a2917 1
			}
d2932 2
a2933 2
		,GetFileName()
		,(float(::GetTickCount() - m_iLastTimeSourcesSaved)/60000));
d2941 2
a2942 2

		return false;
d2949 1
a2949 1
		CString temp="";
d2953 3
a2955 3
		, GetFileName()
		, GetFileHash()
		, theApp.glob_prefs->GetMaxSourcePerFile());
d2975 1
a2975 1
			,GetFileName(),toLoad->GetPartFileName());
d2991 1
a2991 1

d2996 1
a2996 1
		return NULL;
d3000 1
a3000 1
									 , int limit, bool reset, bool debug)
d3004 3
a3006 3
		//if this part-file is complete/completing no source-loading is needed any more
		if(GetStatus() > 7|| GetStatus()==PS_PAUSED)		//Cax2 + SyruS check
			return false;
d3011 1
a3011 1

d3033 1
a3033 1

d3068 1
a3068 1

d3083 3
a3085 3
					int srcsCount = 0;
					for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
						srcsCount += srclists[sl].GetCount();
d3088 31
a3118 31
							goto After_Loading;
						}

						// Added by Tarod (LS tweak)
						// HACK by Md5Chap 2002-11-26 (Moved to CUpDownClient::~CUpDownClient)
						//sourceEntry->IncrementFailedConnections();
						CUpDownClient* newSource = new CUpDownClient(sourceEntry->GetUserPort()
							, userID, serverEntry->GetServerIP()
							, serverEntry->GetServerPort(), this, sourceEntry);

						CString strUserName = sourceEntry->GetUserName() ;
						if (strUserName.Find(EXCHANGEDSOURCEMARK) == 0) {
							strUserName = GetResString(IDS_EXCHANGEDSOURCE) ;
						} else {
							strUserName = GetResString(IDS_LOADEDSOURCE) ;
						}
						char* pName = new char [strUserName.GetLength() + 2] ;
						memset(pName, '\0', (strUserName.GetLength() + 2)) ;
						strncpy(pName, strUserName.GetBuffer(), strUserName.GetLength()) ;
						newSource->SetUserName(pName);
						delete [] pName; // FoRcHa

						theApp.downloadqueue->CheckAndAddSource(this, newSource, false);
						//TRACE("(LoadNAdd) new source (count: %i, index: %i) for %s's sended to CheckNAdd\n"
						//		//, (newSource->GetUserName()!=NULL?newSource->GetUserName():NONAME)
						//		, countAddedSources
						//		, m_iSourceIDIndex++
						//		, GetFileName());
						countAddedSources++;
						m_iSourceIDIndex++;
						if(debug){ AddLogLine(false,"added Source (%i) of %i Sources for %s (%s)"
d3124 2
a3125 2
						}
						userID = sourceEntry->GetNextUserID();
d3130 4
a3133 4
			//#ifdef _DEBUG
			//            if(sourceEntry != NULL) TRACE("(%s)last source-index: %s:%i (ID: %u)\n",GetFileName()
			//					,sourceEntry->GetUserName(),m_iSourceIDIndex,userID);
			//#endif
d3164 4
a3167 4
			, GetFileName()
			, m_iSourceIndex
			, storedSources->GetCountSourceEntrys()
			,(::GetTickCount() - m_iLastTimeSourcesLoadedPartial)/1000);
d3169 1
a3169 1

d3174 4
a3177 4
				, GetFileName()
				, m_iSourceIndex
				, storedSources->GetCountSourceEntrys()
				, (float(::GetTickCount() - m_iLastTimeSourcesLoaded)/60000));
d3179 1
a3179 1

d3186 3
a3188 3
			, GetFileName()
			, m_iSourceIndex
			, (float(::GetTickCount() - m_iLastTimeSourcesLoaded)/60000));
d3192 1
a3192 1

d3200 1
a3200 1
		return false;
d3204 1
a3204 1
								  , int limit, bool reset, bool debug,bool addImmediately)
d3208 3
a3210 3
		//if this part file is paused or complete/completing no sources needed any more
		if(GetStatus()==PS_PAUSED || GetStatus() > 7)		//Cax2 + SyruS check
			return false;
d3215 10
a3224 10
			m_stscrStoringSources = new CStoredSources(GetPartMetFileName()
				, GetFileName()
				, GetFileHash()
				, theApp.glob_prefs->GetMaxSourcePerFileSoft());
			//set the preferences for the StoredSources
			m_stscrStoringSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft()
				, m_iLoadSourcesAtOnceLimit
				, m_iLoadingSourcesTimeInterval
				, m_iLoadingSourcesPartialTimeInterval
				, m_iSavingSourcesTimeInterval);
d3234 3
a3236 3
			,storedSources->GetCountOfSources()
			,GetFileName()
			,((keepSourcesOpen&& theApp.downloadqueue->KeepStoredSourcesOpen())?"kept open!":"not kept open!"));
d3241 3
a3243 3
					, GetFileName()
					, GetFileHash()
					, theApp.glob_prefs->GetMaxSourcePerFileSoft());
d3246 4
a3249 4
					, m_iLoadSourcesAtOnceLimit
					, m_iLoadingSourcesTimeInterval
					, m_iLoadingSourcesPartialTimeInterval
					, m_iSavingSourcesTimeInterval);
d3255 1
a3255 1
	return true;
d3259 1
a3259 1
		return false;
d3266 2
a3267 2
		if(!theApp.downloadqueue->IsSourcesLoadingEnabled())
			return false;
d3271 3
a3273 3
			, GetFileName()
			, GetFileHash()
			, theApp.glob_prefs->GetMaxSourcePerFileSoft());
d3276 4
a3279 4
			, m_iLoadSourcesAtOnceLimit
			, m_iLoadingSourcesTimeInterval
			, m_iLoadingSourcesPartialTimeInterval
			, m_iSavingSourcesTimeInterval);
d3290 5
a3294 5
		, toSave->GetUserPort()
		, toSave->GetUserID()
		, toSave->GetServerIP()
		, toSave->GetServerPort()
		, partsCount);
d3306 1
a3306 1
		return false;
d3313 2
a3314 2
		if(!theApp.downloadqueue->KeepStoredSourcesOpen())
			return false;
d3319 3
a3321 3
			, GetFileName()
			, GetFileHash()
			, theApp.glob_prefs->GetMaxSourcePerFileSoft());
d3324 4
a3327 4
			, m_iLoadSourcesAtOnceLimit
			, m_iLoadingSourcesTimeInterval
			, m_iLoadingSourcesPartialTimeInterval
			, m_iSavingSourcesTimeInterval);
d3336 11
a3346 11
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
			source = srclists[sl].GetNext(posOfSource);
			partsCount = source->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
			// userName = (source->GetUserName() != NULL ? source->GetUserName(): NONAME);//check, if the user-name of this user is set/known
			userName.Format(LOADEDSOURCEMARK"%u", source->GetUserID());
			m_stscrStoringSources->UpdateSource(userName, source->GetUserPort(), 
				source->GetUserID(), source->GetServerIP(), 
				source->GetServerPort(), partsCount);
			successful=true;
		}
d3348 5
a3352 5
		TRACE("CPartFile::SaveToStoredSources() : all current sources of %s were %s to its StoredSources (count (old/new): %u/%u\n\n"
			, GetFileName()
			, successful?"saved":"not saved"
			, oldCount
			, m_stscrStoringSources->GetCountOfSources());
d3354 1
a3354 1
		return successful;
d3356 1
a3356 1
		EMULE_CATCH
d3358 1
a3358 1
			return false;
d3365 2
a3366 2
		if(m_stscrStoringSources == NULL)
			return false;
d3376 2
a3377 2
			,m_stscrStoringSources->GetCountOfSources()
			,GetFileName());
d3396 3
a3398 3
				, GetFileName()
				, GetFileHash()
				, theApp.glob_prefs->GetMaxSourcePerFileSoft());
d3401 4
a3404 4
				, m_iLoadSourcesAtOnceLimit
				, m_iLoadingSourcesTimeInterval
				, m_iLoadingSourcesPartialTimeInterval
				, m_iSavingSourcesTimeInterval);
d3410 13
a3422 13
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
			for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
				source = srclists[sl].GetNext(posOfSource);
				partsCount = source->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
				// userName = (source->GetUserName() != NULL ? source->GetUserName(): NONAME);//check, if the user-name of this user is set/known
				userName.Format(LOADEDSOURCEMARK"%u", source->GetUserID());
				storedSources->UpdateSource(userName, source->GetUserPort(), 
					source->GetUserID(), source->GetServerIP(), 
					source->GetServerPort(), partsCount);
				successful=true;
			}

			//if(debug) AddLogLine(false,"All Sources of '%s' (%s) were gathered for saving to disk",GetFileName(),GetPartMetFileName());
d3424 2
a3425 2
			if(successful){
				SaveSourcesToFile(storedSources);
d3427 1
a3427 1
				TRACE("%u sources for %s were saved to disk with no permanent open StoredSources-object\n"
d3431 2
a3432 2
			}
			delete storedSources;
d3439 3
a3441 3
				, GetFileName()
				, GetFileHash()
				, theApp.glob_prefs->GetMaxSourcePerFileSoft());
d3444 4
a3447 4
				, m_iLoadSourcesAtOnceLimit
				, m_iLoadingSourcesTimeInterval
				, m_iLoadingSourcesPartialTimeInterval
				, m_iSavingSourcesTimeInterval);
d3453 13
a3465 13
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
			for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
				source = srclists[sl].GetNext(posOfSource);
				partsCount = source->GetAvailableOfNeededPartsCount();	//get the count of parts, this user has and we want to download
				// userName = (source->GetUserName() != NULL ? source->GetUserName(): NONAME);//check, if the user-name of this user is set/known
				userName.Format(LOADEDSOURCEMARK"%u", source->GetUserID());
				storedSources->UpdateSource(userName, source->GetUserPort(), 
					source->GetUserID(), source->GetServerIP(), 
					source->GetServerPort(), partsCount);
				successful=true;
			}

			//if(debug) AddLogLine(false,"All Sources of '%s' (%s) were gathered for saving to disk",GetFileName(),GetPartMetFileName());
d3467 2
a3468 2
			if(successful){
				SaveSourcesToFile(storedSources);
d3470 1
a3470 1
				TRACE("%u sources for %s were saved to disk while loading of sources is disabled\n"
d3474 2
a3475 2
			}
			delete storedSources;
d3481 1
a3481 1
		return false;
d3497 1
a3497 1
		m_is_A4AF_auto = in_A4AF_auto;
d3517 13
a3529 2
		if (IsAutoPrioritized()) {
			CPartFile* partfile = theApp.downloadqueue->GetFileByID(GetFileHash()) ;
d3531 1
a3531 12
			if (partfile != NULL && partfile->IsPartFile()) {
				int valid_sources = partfile->GetSourceCount() - partfile->GetNotCurrentSourcesCount();
				if (valid_sources < theApp.glob_prefs->PriorityHigh() && priority != PR_HIGH)
					SetPriority(PR_HIGH) ;
				else if (valid_sources >= theApp.glob_prefs->PriorityHigh() && valid_sources < theApp.glob_prefs->PriorityLow() && priority != PR_NORMAL)
					SetPriority(PR_NORMAL) ;
				else if (valid_sources >= theApp.glob_prefs->PriorityLow() && priority != PR_LOW)
					SetPriority(PR_LOW) ;
			} 
		}

		EMULE_CATCH
d3549 1
a3549 1

d3553 1
a3553 1

d3589 1
a3589 1

d3593 1
a3593 1

d3620 1
a3620 1

d3630 4
a3633 4
		if ( theApp.glob_prefs->IsNTBased() )
		{
			SetThreadLocale(theApp.glob_prefs->GetLanguageID());
		}
d3635 7
a3641 7
		if ( !pFile ) 
		{ 
			return -1; 
		} 
		CSingleLock Lock(&s_ComplitingMutex,TRUE); // Prevent of compliting two files in same time
		pFile->PerformFileComplete(); 
		return 0; 
d3643 1
a3643 1
		EMULE_CATCH
d3645 1
a3645 1
			return -1; 
d3651 1
a3651 1
		CString player=theApp.glob_prefs->GetVideoPlayer();
d3660 1
a3660 1
		return false;
d3668 2
a3669 2
		CIni pvmoviefile(CString(fullname) + CString(".movie"), "MoviePreview"); 
	uint8 Mode = pvmoviefile.GetInt("Mode", 0); 
d3679 1
a3679 1
		CIni pvmoviefile(CString(fullname) + CString(".movie"), "MoviePreview"); 
d3688 14
a3701 14
Originally this only wrote to disk when a full 180k block 
had been received from a client, and only asked for data in 
180k blocks.

This meant that on average 90k was lost for every connection
to a client data source. That is a lot of wasted data.

To reduce the lost data, packets are now written to a buffer
and flushed to disk regularly regardless of size downloaded.
This includes compressed packets.

Data is also requested only where gaps are, not in 180k blocks.
The requests will still not exceed 180k, but may be smaller to
fill a gap.
d3707 2
a3708 2
		// Increment transfered bytes counter for this file
		transfered += transize;
d3773 1
a3773 1
		return 0;
d3780 1
a3780 1
		m_nLastBufferFlushTime = GetTickCount();  // obaldin
d3784 1
a3784 1
	m_lastDownTransfer = CTime::GetCurrentTime();
d3788 1
a3788 1

d3791 1
a3791 1
	//	AddDebugLogLine(false, "Flushing file %s - buffer size = %ld bytes (%ld queued items) transfered = %ld [time = %ld]\n", GetFileName(), m_nTotalBufferData, m_BufferedData_list.GetCount(), transfered, m_nLastBufferFlushTime);
d3914 1
a3914 1
		/*
d3918 1
a3918 1

d3921 2
a3922 2
		*/
		PauseFile();
d3929 1
a3929 1
		PauseFile();
d3942 1
a3942 1
		Gap_Struct *gap;
d3998 8
a4005 8
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
			if (cur_src->GetFileComment().GetLength()>0) hasComment=true;
			if (cur_src->GetFileRate()>0) hasRating=true;
			if (hasComment && hasRating) break;
		}
		if (prev!=(hasComment || hasRating)) UpdateDisplayedInfo();//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4015 23
a4037 23
	if (!hasRating) return 0;  
	int num,tot,fRate;  
	num=tot=0;  
	POSITION pos1,pos2;  
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())  
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){  
			srclists[sl].GetNext(pos1);  
			fRate =((CUpDownClient*) srclists[sl].GetAt(pos2))->GetFileRate();  
			if (fRate>0)   
			{  
				num++;
				//Cax2 - bugfix: for some $%#ing reason  fair=4 & good=3, breaking the progression from fake(1) to excellent(5)
				if (fRate==3 || fRate==4) fRate=(fRate==3)?4:3;
				tot+=fRate;  
			}  
		}  
		if (num>0)
		{
			num=(float)tot/num+.5;	//Cax2 - get the average of all the ratings
			//Cax2 - bugfix: for some $%#ing reason good=3 & fair=4, breaking the progression from fake(1) to excellent(5)
			if (num==3 || num==4) num=(num==3)?4:3;
		}
		return num;	//Cax2 - if no ratings found, will return 0!
d4041 1
a4041 1
	DWORD curTick = ::GetTickCount();
d4043 4
a4046 4
	if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		m_lastRefreshedDLDisplay = curTick;
	}
d4051 3
a4053 6
	// check first if we are this source
	if (theApp.serverconnect->GetClientID() < 16777216 && theApp.serverconnect->IsConnected()){
		if ((theApp.serverconnect->GetClientID() == source->sourceID) && theApp.serverconnect->GetCurrentServer()->GetIP() == source->serverIP)
			return;
	}
	else if (theApp.serverconnect->GetClientID() == source->sourceID)
d4055 22
a4076 19
	// Modified by Tarod -use LowID source only if source is in our same server
	else if (source->sourceID < 16777216 && !theApp.serverconnect->IsLocalServer(source->serverIP, source->serverPort))
		return;

	CUpDownClient* newsource = new CUpDownClient(source->sourcePort,source->sourceID,source->serverIP,source->serverPort,this);
	if(newsource == NULL)
		return;
	//Cax2 - exchanged sources are named now
	if (exchanged)
		newsource->SetUserName(GetResString(IDS_EXCHANGEDSOURCE).GetBuffer());

	if( theApp.glob_prefs->GetMaxSourcePerFile() > GetSourceCount()
		&& i < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()){ // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
			theApp.downloadqueue->CheckAndAddSource(this,newsource);
		} else {
			if(theApp.downloadqueue->IsSourcesLoadingEnabled())
			{
				CString strName;
				strName.Format(EXCHANGEDSOURCEMARK"%u", source->sourceID);
d4078 2
a4079 2
				if(m_stscrStoringSources != NULL)
					m_stscrStoringSources->UpdateSource(strName, source->sourcePort,source->sourceID,source->serverIP,source->serverPort, newsource->GetAvailableOfNeededPartsCount());
d4081 3
a4083 3
			}
			delete newsource;
		} 
d4087 13
a4099 4
	POSITION pos;
	pos=sources->GetHeadPosition();
	while (pos!=NULL) {
		CClientSource* source=(CClientSource*)sources->GetAt(pos);  
d4101 4
a4104 13
		if (source->sourceType != ED2KLINK_SOURCE_IP) {
			sources->GetNext(pos);
			continue;
		}

		POSITION removePos=pos;
		sources->GetNext(pos);
		sources->RemoveAt(removePos);

		AddClientSource(source);
		delete source;
	}
	theApp.downloadqueue->AddClientHostnameToResolve(sources);
d4117 17
a4133 18
			if (cur_src->HasLowID())
				continue;
			if (srcstoadd.IsEmpty()) {
				srcstoadd.AddHead(cur_src);
				continue;
			}
			if ((sourcenum == 0) || (srcstoadd.GetCount() < sourcenum) || (cur_src->GetAvailablePartCount() > srcstoadd.GetTail()->GetAvailablePartCount())) {
				if ((sourcenum != 0) && (srcstoadd.GetCount() == sourcenum))
					srcstoadd.RemoveTail();
				ASSERT(srcstoadd.GetCount() < sourcenum);
				bool bInserted = false;
				for (POSITION pos2 = srcstoadd.GetTailPosition();pos2 != 0;srcstoadd.GetPrev(pos2)){
					CUpDownClient* cur_srctoadd = srcstoadd.GetAt(pos2);
					if (cur_srctoadd->GetAvailablePartCount() > cur_src->GetAvailablePartCount()) {
						srcstoadd.InsertAfter(pos2, cur_src);
						bInserted = true;
						break;
					}
a4134 2
				if (!bInserted)
					srcstoadd.AddHead(cur_src);
d4136 2
d4139 37
a4175 36
		if (srcstoadd.IsEmpty() && (!theApp.serverconnect->IsConnected() || theApp.serverconnect->IsLowID())){
			AddLogLine(true,GetResString(IDS_SOURCELINKFAILED));
			return CString("");
		}
		CString strExpiration;
		if (expirein == 0)
			strExpiration = "";
		else {
			COleDateTime expirationDate = COleDateTime::GetCurrentTime();
			COleDateTimeSpan timediff;
			timediff.SetDateTimeSpan(expirein, 0, 0, 0);
			expirationDate += timediff;
			strExpiration.Format("@@%02i%02i%02i", (expirationDate.GetYear() % 100), expirationDate.GetMonth(), expirationDate.GetDay());
		}  
		uint32 dwID = theApp.serverconnect->GetClientID();
		CString strLink;
		strLink.Format("ed2k://|file|%s|%d|%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x|/|sources%s",
			theApp.StripInvalidFilenameChars(GetFileName(), false), // spaces to dots
			GetFileSize(),
			GetFileHash()[0],GetFileHash()[1],GetFileHash()[2],GetFileHash()[3],GetFileHash()[4],GetFileHash()[5],GetFileHash()[6],GetFileHash()[7],
			GetFileHash()[8],GetFileHash()[9],GetFileHash()[10],GetFileHash()[11],GetFileHash()[12],GetFileHash()[13],GetFileHash()[14],GetFileHash()[15],
			strExpiration);
		CString newsource;
		if (dwID >= 16777216) {
			newsource.Format(",%i.%i.%i.%i:%i",(uint8)dwID,(uint8)(dwID>>8),(uint8)(dwID>>16),(uint8)(dwID>>24), theApp.glob_prefs->GetPort());
			strLink.Append(newsource);
		}
		AddDebugLogLine(false, "Sources: %i", (int)srcstoadd.GetCount());
		while (!srcstoadd.IsEmpty()) {
			CUpDownClient* cur_src = srcstoadd.RemoveHead();
			AddDebugLogLine(false, "Available part count: %i", (int)cur_src->GetAvailablePartCount());
			newsource.Format(",%s:%i",cur_src->GetFullIP(), cur_src->GetUserPort());
			strLink.Append(newsource);
		}
		strLink.Append("|/");
		return strLink;
d4188 1
a4188 1
		ff.FindFile(m_alternativepath, 0);
d4195 1
a4195 1
			theApp.glob_prefs->shareddir_list.AddTail(dir);
a4203 11

CTime CPartFile::GetLastChangeDatetime(bool forcecheck){
	if ((::GetTickCount()-m_lastdatetimecheck)<60000 && !forcecheck) return m_lastdatecheckvalue;
	m_lastdatetimecheck=::GetTickCount();
	if (!PathFileExists(m_hpartfile.GetFilePath())) m_lastdatecheckvalue=NULL; else {
		CFileStatus filestatus;
		m_hpartfile.GetStatus(filestatus); // this; "...returns m_attribute without high-order flags" indicates a known MFC bug, wonder how many unknown there are... :)
		m_lastdatecheckvalue=filestatus.m_mtime;
	}
	return m_lastdatecheckvalue;
}
@


1.78.2.2
log
@27c
@
text
@d204 2
d500 1
d1307 1
a1307 2
	uint16 tempTS=0;
	DWORD dwCurTick = ::GetTickCount();
d1317 1
a1323 1
				tempTS++;
d1336 2
d1356 1
a1356 1
						tempTS++;
a1374 4
					case DS_CONNECTED:
						if(!cur_src->socket || !cur_src->socket->IsConnected())
								cur_src->SetDownloadState(DS_NONE);
						break;
d1425 1
d1446 1
a1446 1
		transferingsrc= tempTS;
d1696 3
a1698 3
		UpdateDisplayedInfo(true);
	
	EMULE_CATCH
a2541 1
	SavePartFile();
a2845 2
			if (forClient->GetSourceExchangeVersion() > 1)
				data.Write(cur_src->GetUserHash(),16);
d2867 1
a2867 1
void CPartFile::AddClientSources(CMemFile* sources, uint8 sourceexchangeversion)
a2897 2
		if (sourceexchangeversion > 1)
			sources->Read(&source.m_achUserHash,16);
d3821 1
a4101 2
	if (source->m_achUserHash[0]||source->m_achUserHash[1]||source->m_achUserHash[2]||source->m_achUserHash[3])
		newsource->SetUserHash(source->m_achUserHash);
d4240 12
a4251 1
// END - enkeyDEV(Ottavio84) -ChangeDir-@


1.77
log
@[fix] 2 Gb Limit by gabest
@
text
@d1778 1
a1790 1
		StopFile();
@


1.76
log
@last bugfixes!
@
text
@d2142 1
a2142 1
		m_hpartfile.Seek(PARTSIZE*partnumber,0);
@


1.75
log
@bugfixed 'cancel  file' & 'remove comment'
@
text
@d2116 1
a2116 1
	//Cax2 - something evil in these removefile procedures now.
@


1.74
log
@update for preview code
@
text
@d2078 1
a2078 4
	theApp.sharedfiles->RemoveFile(this);
	theApp.downloadqueue->RemoveFile(this);
	theApp.emuledlg->transferwnd.downloadlistctrl.RemoveFile(this);
	//RemoveAllSources(true);		//Cax2 bugfix: hanging sources when deleting file
d2091 2
a2092 2
	if (remove(dirFile)) if (errno != ENOENT)
		AddLogLine(true, "Failed to delete %s, you will need to do this by hand", dirFile);
d2097 2
a2098 3
	srcName.Format("%s\\%s.stsrc",tempdir,GetPartMetFileName());
	if (remove(srcName))
		if (errno != ENOENT) 
d2102 2
a2103 3
	srcName.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
	if (remove(srcName))
		if (errno != ENOENT)
d2107 2
a2108 3
	srcName.Format("%s\\%s.movie", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
	if (remove(srcName))
		if (errno != ENOENT)
a2114 1

d2116 5
@


1.73
log
@bugfixed bugfixes!
@
text
@d2659 5
a2663 1
	
d2668 1
@


1.72
log
@*** empty log message ***
@
text
@a681 1
	Lock.Unlock();
d691 1
@


1.71
log
@reinstate buffer flush on timeout
@
text
@d472 4
a475 1
	if (hashlist.GetCount() < GetPartCount() && GetFileSize() >= PARTSIZE){
d483 1
a483 1
		for (int i = 0; i != hashlist.GetSize(); i++){
d571 1
d576 1
d680 4
a683 1
	for (uint32 i = 0; i != hashlist.GetSize(); i++){
@


1.70
log
@ok, really last movie preview bugfix!
@
text
@d1287 1
a1287 1
	if ((m_nTotalBufferData > ((uint32)theApp.glob_prefs->GetFileBufferSize())*15000) /*|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT))*/)
@


1.69
log
@last change! bloody movie previews! :P
@
text
@d2693 1
a2693 1
	if (space < (GetFileSize() + 100000000)  && !theApp.glob_prefs->BackupPreview())		//Cax2 - now the logic makes sense: allow for an extra 100mb on top of the film preview.
@


1.68
log
@corrected menu options for non-vlc preview & low disk space
@
text
@d2693 1
a2693 1
	if (space < (GetFileSize() + 100000000)  && !IsVLCInstalled())		//Cax2 - bad logic corrected.
@


1.67
log
@bugfix: preview movies( bug #50)
@
text
@d2640 8
@


1.66
log
@changed official code using a CString!!! as a boolean vector
@
text
@d2174 2
a2175 18
	EMULE_TRY

	// DonGato
	CString fname = GetFileName();
	fname.MakeLower();

	if(IsVLCInstalled())
	{
		return (strstr(fname,".avi") || strstr(fname,".bin") || strstr(fname,".ogm") || strstr(fname,".mpg") 
				|| strstr(fname,".mpe") || strstr(fname,".dat"));
	} else {
		return (strstr(fname,".avi") || strstr(fname,".mpg") || strstr(fname,".ogm") || strstr(fname,".mpe")
				|| strstr(fname,".dat"));
	}

	EMULE_CATCH

	return false;
a2651 16
	if (IsArchive()) 
		if (GetStatus() != PS_COMPLETE &&  GetStatus() != PS_COMPLETING && ( GetFileSize() > 1024) && (!m_bRecoveringArchive) && ((space + 100000000) > (2*GetFileSize())))
			return true; else return false;

	//Vorlost for LoadRarestFinishedChunks Patch2
	bool first = false,last = false;

 	char buffer[200] = "";
 	if (IsMovie())
	{
  		//check if min. Movie-Blocks loaded
  		if (IsComplete(0,(MINFIRSTMOVIESIZE)-1))
			first = true; //first blocks present
  
		if (IsComplete((GetFileSize()-1) - (MINLASTMOVIESIZE) ,GetFileSize()-1 ))
			last = true; //last blocks present
d2653 2
a2654 12
  		if (first == false) //first present & last with avi
		{
   			strcat(buffer,", first ");
   			if (last == false && IsAviMovie())
				strcat(buffer,"& last ");
  		}
  		else if (last == false && IsAviMovie())
			strcat(buffer,", last ");

  		if (!first || (!last && IsAviMovie()))
			strcat(buffer,"Movieblocks not downloaded yet");
 	}
d2656 2
a2657 2
	if (!first || (!last && IsAviMovie()))
		return false; //Blocks missing to preview
d2662 15
a2676 2
	if (GetStatus() == PS_COMPLETING || GetStatus() == PS_COMPLETE)
		return false;
d2678 6
a2683 2
	if (GetStatus() == PS_HASHING)
		return false;
d2685 3
a2687 1
	if ((space + 100000000) < GetFileSize() && IsMovie() && !IsVLCInstalled())
d2689 1
d2691 3
a2693 1
	if ( m_bPreviewing && IsMovie())
d2695 1
a2695 1

@


1.65
log
@Hashset Request For Files < Partsize by bluecow
@
text
@d1675 2
a1676 2
    CString gettingParts; // obaldin: gosh, using a string of 'Y' and 'N' as a boolean vector!?!
    sender->ShowDownloadingParts(&gettingParts);
d1692 1
a1692 1
                    if(gettingParts.GetAt(randomness) == 'Y') {
d1695 1
a1695 4
                    if(gettingParts.GetAt(goodpart) == 'Y') {
                        // nothing, stay on the current one
                    } else
					if (m_SrcpartFrequency[goodpart] > rarechunk && m_SrcpartFrequency[randomness] > rarechunk) //Non-rare chunks found yet
@


1.64
log
@bugfix: should download better from .26 and above( bug 61)
@
text
@d69 3
d112 3
d472 1
a472 1
	if (hashlist.GetCount() < GetPartCount()){
@


1.63
log
@won't save part file if completing (bug #120)
@
text
@a791 86
/* rewritten
//Vorlost for LoadRarestFinishedChunks Patch2
bool CPartFile::GetNextEmptyBlockInPart(uint16 partnumber,Requested_Block_Struct* result)
{
	EMULE_TRY

	bool forward = true;
	uint32 lastblock = ceil((float)PARTSIZE/BLOCKSIZE);
	uint32 lastblockinpart = lastblock;
	uint32 start,end,i;
	char buffer[200] = "";

	//Choose FW or BW - Mode
	if (partnumber == GetPartCount()-2)
		end = (PARTSIZE*partnumber) + (lastblock*BLOCKSIZE)-1; //End address from 1chunk before the last chunk
	if (partnumber == GetPartCount()-1   //Is this the last chunk ?
		|| ((partnumber == GetPartCount()-2) //Or is this 1chunk before the last chunk ?
		&& (((GetFileSize()-1) - MINLASTMOVIESIZE) <= end )))  //Is 1/8 from fileend part of 1chunk before the last chunk ?
		forward = false;

	//Get last possible blocknumber
	// if ( !forward ){
	for (lastblockinpart = 0; lastblockinpart != lastblock;lastblockinpart++)
	{
		start = (PARTSIZE*partnumber) + lastblockinpart*BLOCKSIZE;
		if (start >= GetFileSize())
			break;
	}

	if ( forward )
	{
		for (i = 0; i != lastblock;i++)
		{
			start = (PARTSIZE*partnumber) + i*BLOCKSIZE;
			end  = (PARTSIZE*partnumber) + ((i+1)*BLOCKSIZE)-1;
			if (end >= (uint32)PARTSIZE*(partnumber+1))
				end = (PARTSIZE*(partnumber+1))-1;
			if (start >= GetFileSize())
				break;
			if (end >= GetFileSize())
				end = GetFileSize()-1;
			if ( (!IsComplete(start,end)) && !IsAlreadyRequested(start,end))
			{
				if (result)
				{
					result->StartOffset = start;
					result->EndOffset = end;
					memcpy(result->FileID,GetFileHash(),16);
				}
				return true;
			}
		}
		return false;
	}
	else
	{
		for (i = lastblockinpart-1; i != -1;i--)
		{
			start = (PARTSIZE*partnumber) + i*BLOCKSIZE;
			end  = (PARTSIZE*partnumber) + ((i+1)*BLOCKSIZE)-1;
			if (end >= (uint32)PARTSIZE*(partnumber+1))
				end = (PARTSIZE*(partnumber+1))-1;
			if (start >= GetFileSize())
				break;
			if (end >= GetFileSize())
				end = GetFileSize()-1;
			if ( (!IsComplete(start,end)) && !IsAlreadyRequested(start,end))
			{
				if (result)
				{
					result->StartOffset = start;
					result->EndOffset = end;
					memcpy(result->FileID,GetFileHash(),16);
				}
				return true;
			}
		}
		return false;
	}

	EMULE_CATCH

	return false;
}
// End Vorlost
*/
d879 55
d1621 1
a1621 3
    uint16 partcount;

    partcount = GetPartCount();
d1650 1
a1650 1
bool CPartFile::GetNextRequestedBlock(CUpDownClient* sender,Requested_Block_Struct** newblocks,uint16* count)
d1654 2
a1655 2
	if(sender == NULL || newblocks == NULL || count == NULL)
		return false;
a1658 2
	uint16 requestedCount = *count;
	uint16 newblockcount = 0; 
d1672 1
a1672 2
	*count = 0; 
    uint16 randomness;
d1675 3
a1677 2
	bool finished = false; 
	while (!finished)
d1679 1
a1679 3
		randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(GetPartCount()-1)); 
		uint16 goodpart = 0xFFFF; 
		for (uint16 i = 0;i != GetPartCount();i++)
d1681 4
a1684 4
			if (partsav[randomness] && !IsComplete(randomness*PARTSIZE,((randomness+1)*PARTSIZE)-1))
			{ 
				// Begin of absolutely lowest availability gap by Vorlost inspired by Denominator 
           		if (GetNextEmptyBlockInPart(randomness,0)) //Search for next empty Block... 
d1686 7
a1692 1
					if (goodpart != 0xFFFF) //One Part memorized yet ? 
d1694 5
a1698 7
                        if(gettingParts.GetAt(randomness) == 'Y') {
                            goodpart = randomness;
                        } else
                        if(gettingParts.GetAt(goodpart) == 'Y') {
                            // nothing, stay on the current one
                        } else
						if (m_SrcpartFrequency[goodpart] > rarechunk && m_SrcpartFrequency[randomness] > rarechunk) //Non-rare chunks found yet
d1700 2
a1701 1
                    		if (PrepareComparePart(randomness) < PrepareComparePart(goodpart)) //and is this new chunk more completed ?
d1703 2
a1704 12
     							if (Movie1(mode,goodpart,randomness)) goodpart = randomness;  //Then we want it ! 
                    		} 
     						else
							{
      							if (PrepareComparePart(randomness) == PrepareComparePart(goodpart) //Is the new chunk same complete
      								&& m_SrcpartFrequency[randomness] < m_SrcpartFrequency[goodpart]) //and rarer ?
								{
      									if (Movie1(mode,goodpart,randomness))
											goodpart = randomness;  //Then we want it ! If Movie1 allows us
								} 
     							else if (Movie2(mode,raremovie,forcepreview,goodpart,randomness))
									goodpart = randomness; //Normally we dont want it, what do you think Movie2 ?
d1706 2
d1709 6
a1714 1
               			else //The memorized or the new chunk is a very rare one
d1716 1
a1716 3
                   			if (m_SrcpartFrequency[randomness] < m_SrcpartFrequency[goodpart]) //Is the new chunk rarer than the memorized ? 
								goodpart = randomness; //Then we want it ! 
                   			else if (m_SrcpartFrequency[randomness] == m_SrcpartFrequency[goodpart]) //old & new chunk are both same available ?
d1718 2
a1719 7
                   				if (PrepareComparePart(randomness) < PrepareComparePart(goodpart)) //and is this new chunk more completed ?
								{
                       				if (Movie1(mode,goodpart,randomness))
										goodpart = randomness; //Then we want it ! If Movie1 allows us
								} 
  								else if (Movie2(mode,raremovie,forcepreview,goodpart,randomness))
									goodpart = randomness; //Normally we dont want it, what do you think Movie2 ?
d1721 2
d1724 3
a1726 4
					} else	                      //Theres no memorized Part yet... 
						goodpart = randomness;    //Then just take this one first...    
				} 
				// End of lowest availability gap by Vorlost / Denominator 
d1728 1
a1728 3
			randomness++; 
			if (randomness == GetPartCount()) 
				randomness = 0; 
d1730 6
a1735 134
		uint16 usedpart; 
		if (goodpart != 0xFFFF)
			usedpart = goodpart; 
		else
		{ 
			if (!newblockcount) 
				return false;
			else 
				break; 
		} 
		// Ende von Vorlosts Code 
/*
                // Need to empty lists to avoid infinite loop when file is smaller than 180k
                // Otherwise it would keep looping to find 3 blocks, there is only one and it is requested
                liGoodParts.RemoveAll();
                liPossibleParts.RemoveAll();
                // Barry - Top priority should be to continue downloading from current blocks (if anything left to download)
                bool foundPriorityPart = false;
                CString gettingParts;
                sender->ShowDownloadingParts(&gettingParts);
                
                for (int i=(gettingParts.GetLength()-1); i>=0; i--)
                {
                        if ((gettingParts.GetAt(i) == 'Y') && (GetNextEmptyBlockInPart(i, 0)))
                        {
                                liGoodParts.AddHead(i);
                                foundPriorityPart = true;
                        }
                }
                // Barry - Give priorty to end parts of archives and movies
                if ((!foundPriorityPart) && (IsArchive() || IsMovie()) && (GetMovieMode()>0)) // obaldin
                {
                        uint32 partCount = GetPartCount();
                        // First part
                        if (sender->IsPartAvailable(0) && GetNextEmptyBlockInPart(0, 0))
                        {
                                liGoodParts.AddHead(0);
                                foundPriorityPart = true;
                        }
                        else if ((partCount > 1))
                        {
                                // Last part
                                if (sender->IsPartAvailable(partCount-1) && GetNextEmptyBlockInPart(partCount-1, 0))
                                {
                                        liGoodParts.AddHead(partCount-1);
                                        foundPriorityPart = true;
                                }
                                // Barry - Better to get rarest than these, add to list, but do not exclude all others.
                                // These get priority over other parts with same availability.
                                else if (partCount > 2)
                                {
                                        // Second part
                                        if (sender->IsPartAvailable(1) && GetNextEmptyBlockInPart(1, 0))
                                                liGoodParts.AddHead(1);
                                        // Penultimate part
                                        else if (sender->IsPartAvailable(partCount-2) && GetNextEmptyBlockInPart(partCount-2, 0))
                                                liGoodParts.AddHead(partCount-2);
                                }
                        }
                }
                if (!foundPriorityPart)
                {
                        randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(GetPartCount()-1));
                        for (uint16 i = 0;i != GetPartCount();i++){
                                if (sender->IsPartAvailable(randomness))
                                {                                        
										if (partsav[randomness] && !IsComplete(randomness*PARTSIZE,((randomness+1)*PARTSIZE)-1)){
                                                //if (IsCorruptedPart(randomness)){
                                                //        if (GetNextEmptyBlockInPart(randomness,0)){
                                                //                goodpart = randomness;
                                                //                break;
                                                //        }
                                                //}
                                                //else * / 
                                                if (IsPureGap(randomness*PARTSIZE,((randomness+1)*PARTSIZE)-1))
                                                {
                                                        if (GetNextEmptyBlockInPart(randomness,0))
                                                                liPossibleParts.AddHead(randomness);
                                                }
                                                else if (GetNextEmptyBlockInPart(randomness,0))
                                                        liGoodParts.AddTail(randomness); // Barry - Add after archive/movie entries
                                        }
                                }
                                randomness++;
                                if (randomness == GetPartCount())
                                        randomness = 0;
                        }
                }
                CList<int,int>* usedlist;
                if (!liGoodParts.IsEmpty())
                        usedlist = &liGoodParts;
                else if (!liPossibleParts.IsEmpty())
                        usedlist = &liPossibleParts;
                else{
                        if (!newblockcount){
                                return false;
                        }
                        else
                                break;
                }
                uint16 nRarest = 0xFFFF;
                uint16 usedpart = usedlist->GetHead();
                for (POSITION pos = usedlist->GetHeadPosition();pos != 0;usedlist->GetNext(pos)){
                        if (m_SrcpartFrequency.GetCount() >= usedlist->GetAt(pos)
                        && m_SrcpartFrequency[usedlist->GetAt(pos)] < nRarest){
                                nRarest = m_SrcpartFrequency[usedlist->GetAt(pos)];
                                usedpart = usedlist->GetAt(pos);
                        }
                }
*/
		while (true)
		{ 
			Requested_Block_Struct* block = new Requested_Block_Struct; 
			if (GetNextEmptyBlockInPart(usedpart,block))
			{ 
				requestedblocks_list.AddTail(block); 
				newblocks[newblockcount] = block; 
				newblockcount++; 
				if (newblockcount == requestedCount)	//BLOCKCOUNT
				{ 
					finished = true; 
					break; 
				} 
			} 
			else 
			{ 
				delete block; 
				break; 
			} 
		} 
	} //wend 
	*count = newblockcount; 
	return true;

d1738 1
a1738 1
	return false;
@


1.62
log
@more logical sortorder: Complete-Completing-Downloading-Waiting-Paused-Errors
@
text
@d520 1
@


1.61
log
@sETtHREADlOCALE DOES NOT WORK ON NON-nt (WIN9X) BASED SYSTEMS
@
text
@d2736 1
a2736 1
	int status=0;
d2738 1
a2738 1
	int tempstatus=0;
d2740 1
a2740 1
		tempstatus=1;
d2744 1
a2744 1
			tempstatus=3;
d2747 1
a2747 1
			tempstatus=4;
d2750 1
a2750 1
			tempstatus=5;
d2753 1
a2753 1
			tempstatus=2;
d2756 1
a2756 1
			tempstatus=6;
d2759 1
a2759 1
	return tempstatus;
@


1.60
log
@converted to new logging method
@
text
@d3798 4
a3801 1
	SetThreadLocale(theApp.glob_prefs->GetLanguageID());
@


1.59
log
@bugfix: completed files displayed correctly (bug 41)
@
text
@d92 1
a92 1
		theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_LINKERROR), buffer);
d119 1
a119 1
		theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_LINKERROR), buffer);
d263 1
a263 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_CREATEPARTFILE));
d302 1
a302 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_OPENMET),partmetfilename,filename);
d309 1
a309 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_BADMETVERSION),partmetfilename,filename);
d314 1
a314 1
            theApp.emuledlg->AddLogLine(true,"Loaded hashset is corrupt! File: %s",in_filename);
d325 1
a325 1
						theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_METCORRUPT),partmetfilename,filename);
d415 1
a415 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_METCORRUPT),partmetfilename,filename);
d419 1
a419 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_FILEERROR),partmetfilename,filename,error);
d454 1
a454 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_FILEOPEN),fullname,filename);
d492 1
a492 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_REHASH),buffer,filename);
d644 1
a644 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_SAVEMET),error,partmetfilename,filename);
d651 1
a651 1
		theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_SAVEMET),error.GetBuffer(),partmetfilename,filename);
d671 1
a671 1
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_FOUNDCORRUPTION),i+1,filename);		
d684 1
a684 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_HASHINGDONE),filename);
d1328 1
a1328 1
		//theApp.emuledlg->AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
d1642 1
a1642 1
//	theApp.emuledlg->AddDebugLogLine(false,"RCV: %i sources from server, %i low id dropped, %i possible sources",count,debug_lowiddropped,debug_possiblesources);
d2103 1
a2103 1
            theApp.emuledlg->AddLogLine(true,str); 
d2112 1
a2112 1
            theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
d2122 1
a2122 1
            theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
d2131 1
a2131 1
    	theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_DELETEFAILED),fullname); 
d2136 1
a2136 1
		theApp.emuledlg->AddLogLine(true, "Failed to delete %s, you will need to do this by hand", dirFile);
d2145 1
a2145 1
 		theApp.emuledlg->AddLogLine(true,GetResString(IDS_FAILDELETE),srcName); 
d2151 1
a2151 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2157 1
a2157 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2175 1
a2175 1
    theApp.emuledlg->AddLogLine(true,GetResString(IDS_DOWNLOADDONE),GetFileName()); 
d2178 1
a2178 1
    	theApp.emuledlg->AddLogLine(true, GetResString(IDS_DOWNLOADRENAMED), strrchr(newname, '\\') + 1); 
d2245 1
a2245 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_DELETE),fullname);
d2249 1
a2249 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_DELETE),partfilename);
d2254 1
a2254 1
		theApp.emuledlg->AddLogLine(true, "Failed to delete %s, you will need to do this by hand", dirFile);
d2262 1
a2262 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_FAILDELETE),srcName);
d2268 1
a2268 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2274 1
a2274 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);
d2292 1
a2292 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_HASHERRORWARNING),GetFileName());
d2297 1
a2297 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_INCOMPLETEHASH),GetFileName());
d2554 1
a2554 1
			//theApp.emuledlg->AddLogLine(true,false,CString("Movie2::Mode:%d old:%d new:%d rarem:%d - The new & old ones are nonrare,samerare or forced, now we decide if new is a better movie or could change to movie..."),mode,oldchunk,newchunk,raremovie);
d2694 1
a2694 1
		// theApp.emuledlg->AddLogLine(true,CString("Resetting LastSearchTime:%d in Filename:%s"),lastsearchtime,GetFileName());
d2990 1
a2990 1
	//theApp.emuledlg->AddDebugLogLine(false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount);
d3009 1
a3009 1
	//theApp.emuledlg->AddDebugLogLine(false, "RCV:Sources File(%s) Count(%i)", GetFileName(), nCount);
d3081 1
a3081 1
			if(debug) theApp.emuledlg->AddLogLine(false,"Sources for '%s' (%s) were found and saved",GetPartMetFileName(),GetFileName());
d3092 1
a3092 1
		if(debug) theApp.emuledlg->AddLogLine(false,"Due to the fact no sources were found for '%s', nothing was written",GetPartMetFileName());
d3135 1
a3135 1
			if(debug) theApp.emuledlg->AddLogLine(false,"Could not load *.stsrc file for %s (%s)\r\n\t(ErrorMessage: %s)",GetFileName(),GetPartMetFileName(),errorMsg);
d3142 1
a3142 1
		if(debug) theApp.emuledlg->AddLogLine(false,"Found %i Sources for %s in %s.stsrc",toLoad->GetCountSourceEntrys()
d3148 1
a3148 1
		if(debug) theApp.emuledlg->AddLogLine(false,"Could not open *.stsrc file for %s (%s)",GetFileName(),GetPartMetFileName());
d3225 1
a3225 1
			//					if(debug) theApp.emuledlg->AddLogLine(false,"sended an UDP-Source-Request to %s for %s (%s)\n"
d3286 1
a3286 1
					if(debug){ theApp.emuledlg->AddLogLine(false,"added Source (%i) of %i Sources for %s (%s)"
d3290 2
a3291 2
						theApp.emuledlg->AddLogLine(false,"The new Source is %s and the SourceEntry is %s",(newSource == NULL ? "NULL" : "not NULL"),(sourceEntry == NULL ? "NULL" : "not NULL"));
						theApp.emuledlg->AddLogLine(false,"New source No. %i added for %s",countAddedSources,GetFileName());
d3590 1
a3590 1
		//if(debug) theApp.emuledlg->AddLogLine(false,"All Sources of '%s' (%s) were gathered for saving to disk",GetFileName(),GetPartMetFileName());
d3633 1
a3633 1
		//if(debug) theApp.emuledlg->AddLogLine(false,"All Sources of '%s' (%s) were gathered for saving to disk",GetFileName(),GetPartMetFileName());
d3884 1
a3884 1
		theApp.emuledlg->AddDebugLogLine(false, "File '%s' has already been written from %ld to %ld\n", GetFileName(), start, end);
d3956 1
a3956 1
//	theApp.emuledlg->AddDebugLogLine(false, "Flushing file %s - buffer size = %ld bytes (%ld queued items) transfered = %ld [time = %ld]\n", GetFileName(), m_nTotalBufferData, m_BufferedData_list.GetCount(), transfered, m_nLastBufferFlushTime);
d4018 1
a4018 1
					theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_PARTCORRUPT), partNumber, GetFileName());
d4042 1
a4042 1
					theApp.emuledlg->AddLogLine(true,GetResString(IDS_ICHWORKED),partNumber,GetFileName());
d4064 1
a4064 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_OUTOFSPACE), GetFileName());
d4076 1
a4076 1
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_WRITEERROR), GetFileName(), buffer);
d4091 2
a4092 2
	{
		theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_WRITEERROR), GetFileName(), GetResString(IDS_UNKNOWN));
d4306 1
a4306 1
		theApp.emuledlg->AddLogLine(true,GetResString(IDS_SOURCELINKFAILED));
d4332 1
a4332 1
	theApp.emuledlg->AddDebugLogLine(false, "Sources: %i", (int)srcstoadd.GetCount());
d4335 1
a4335 1
		theApp.emuledlg->AddDebugLogLine(false, "Available part count: %i", (int)cur_src->GetAvailablePartCount());
@


1.58
log
@bugfix: server connect timeout, averaged file rating
@
text
@d2172 3
a2174 2
    status = PS_COMPLETE; 
    paused = false; 
@


1.57
log
@Destination directory now working (BUG #0000024)
@
text
@d4189 3
a4191 1
               num++;  
d4195 7
a4201 3
     if (num>0)   
          return ((float)tot/num+.5);		//Cax2 - better average... :)
     return 0;
@


1.56
log
@bugfixed exchanged sources; removed unnecessary IDS_EXCHANGEDSOURCEMARK
@
text
@d1973 2
a1974 2
	char* newname = new char[strlen(newfilename)+strlen(theApp.glob_prefs->GetIncomingDir())+MAX_PATH];
	sprintf(newname,"%s\\%s",theApp.glob_prefs->GetIncomingDir(),newfilename);
d4336 1
@


1.55
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d3028 1
a3028 1
		AddClientSource(&source, i);		// check first if we are this source
d3266 1
a3266 1
					if (strUserName.Find(GetResString(IDS_EXCHANGEDSOURCEMARK)) == 0) {
d4208 1
a4208 1
void CPartFile::AddClientSource(CClientSource* source, int i) {
d4222 5
a4226 1
return;
@


1.54
log
@Bugfixes
@
text
@d399 8
d624 11
d2025 1
a2025 1
            strTestName.Format("%s\\%s(%d).%s", theApp.glob_prefs->GetIncomingDir(), 
d2133 6
d2168 4
a2171 1
    directory = nstrdup(theApp.glob_prefs->GetIncomingDir()); 
d2250 6
d4331 26
a4356 1
// END - enkeyDEV(Ottavio84) -Create source ed2k from downloads-@


1.53
log
@File buffer setting working
@
text
@d76 2
@


1.52
log
@Copy ed2k-link with sources logs to debug log now
@
text
@d1290 1
a1290 1
	if ((m_nTotalBufferData > theApp.glob_prefs->GetFileBufferSize()) /*|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT))*/)
@


1.51
log
@bugfix: status bar mem leak - Maella
@
text
@d4285 1
a4285 1
	theApp.emuledlg->AddLogLine(false, "Sources: %i", (int)srcstoadd.GetCount());
d4288 1
a4288 1
		theApp.emuledlg->AddLogLine(false, "Available part count: %i", (int)cur_src->GetAvailablePartCount());
@


1.50
log
@Protection from on-disk hashset corruption, proper check that we already have the data before sending
@
text
@d36 1
a36 1

d39 1
d1009 4
a1012 12
	COLORREF crProgress; 
	COLORREF crHave; 
	COLORREF crPending = RGB(255, 208, 0);
	COLORREF crMissing = RGB(255, 0, 0); 

	if(bFlat) { 
		crProgress = RGB(0, 150, 0); 
		crHave = RGB(0, 0, 0); 
	} else { 
		crProgress = RGB(0, 192, 0);	//Cax2 - same green used for files & clients
		crHave = RGB(95, 95, 95);		//Cax2 - darker 'black'...
	} 
d1014 1
a1014 2
	s_ChunkBar.SetHeight(rect->bottom - rect->top); 
	s_ChunkBar.SetWidth(rect->right - rect->left); 
d1124 1
@


1.49
log
@enkeydev stuff
@
text
@d310 3
a312 1
		LoadHashsetFromFile(&file,false);
@


1.48
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d2992 6
a2997 37
		uint32 dwID;
		uint16 nPort;
		uint32 dwServerIP;
		uint16 nServerPort;
		sources->Read(&dwID,4);
		sources->Read(&nPort,2);
		sources->Read(&dwServerIP,4);
		sources->Read(&nServerPort,2);
		// check first if we are this source
		if (theApp.serverconnect->GetClientID() < 16777216 && theApp.serverconnect->IsConnected()){
			if ((theApp.serverconnect->GetClientID() == dwID) && theApp.serverconnect->GetCurrentServer()->GetIP() == dwServerIP)
				continue;
		}
		else if (theApp.serverconnect->GetClientID() == dwID)
			continue;
		// Modified by Tarod -use LowID source only if source is in our same server
		else if (dwID < 16777216 && !theApp.serverconnect->IsLocalServer(dwServerIP, nServerPort))
			continue;

		CUpDownClient* newsource = new CUpDownClient(nPort,dwID,dwServerIP,nServerPort,this);
		if(newsource == NULL)
			continue;
		if( theApp.glob_prefs->GetMaxSourcePerFile() > GetSourceCount()
			&& i < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()){ // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
				theApp.downloadqueue->CheckAndAddSource(this,newsource);
		} else {
			if(theApp.downloadqueue->IsSourcesLoadingEnabled())
			{
				CString strName;
				strName.Format(EXCHANGEDSOURCEMARK"%u", dwID);
#ifdef OLD_SLS_ENABLED
				if(m_stscrStoringSources != NULL)
					m_stscrStoringSources->UpdateSource(strName, nPort, dwID, dwServerIP, nServerPort, newsource->GetAvailableOfNeededPartsCount());
#endif //OLD_SLS_ENABLED
			}
			delete newsource;
		} 
d4175 126
@


1.47
log
@*** empty log message ***
@
text
@d1334 1
a1334 1
						uint32 cur_datarate = max(cur_src->CalculateDownloadRate(), 0);
d1383 10
a1392 2
            if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime-20000)){
				cur_src->UDPReaskForDownload();
d1406 13
a1418 3
			//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime))
				cur_src->AskForDownload();
d2902 1
d2907 4
@


1.46
log
@minor bugfix
@
text
@d3725 4
@


1.45
log
@*** empty log message ***
@
text
@d4093 1
@


1.44
log
@Priority control
@
text
@d2776 5
a2780 1

@


1.43
log
@file buffer size, autotake ed2k links and some preferences reorganization.
@
text
@d482 1
a482 1
		    CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_NORMAL,0, CREATE_SUSPENDED);
d1908 1
a1908 1
		CAddFileThread* addfilethread = (CAddFileThread*) AfxBeginThread(RUNTIME_CLASS(CAddFileThread), THREAD_PRIORITY_BELOW_NORMAL,0, CREATE_SUSPENDED);
d1916 1
a1916 1
		CWinThread *pThread = AfxBeginThread((AFX_THREADPROC )CompleteThreadProc,this, THREAD_PRIORITY_BELOW_NORMAL,0, CREATE_SUSPENDED);
d2749 1
a2749 1
		CPreviewThread* pThread = (CPreviewThread*) AfxBeginThread(RUNTIME_CLASS(CPreviewThread), THREAD_PRIORITY_NORMAL,0, CREATE_SUSPENDED);
@


1.42
log
@simplified control panel,added remote queue limit as an otpion
@
text
@d1295 1
a1295 1
	if ((m_nTotalBufferData > BUFFER_SIZE_LIMIT) /*|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT))*/)
@


1.41
log
@Bogfix: rating average, and last 'unknown friends' bugfix... I hope
@
text
@d1388 1
a1388 1
			if ((theApp.glob_prefs->UseRemoteQueueLimit() && !cur_src->IsRemoteQueueFull()) && (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetQueueSize())) {
d2988 1
a2988 1
			&& i < (int)theApp.glob_prefs->GetMaxSourcesPerFileSoftValue()){ // DonGato - Using Max Sources per File (soft)
@


1.40
log
@bugfixed A4AF
@
text
@d4162 1
a4162 1
          return ceil(tot/num);  
@


1.39
log
@bugfix: should remove 'unknown friends' & some A4AF:null
@
text
@d1278 1
a1278 1
			theApp.downloadqueue->RemoveSource(cur_src, this);	//Cax2 - downloadlistcontrol bugfix
d1355 1
a1355 1
				theApp.downloadqueue->RemoveSource( cur_src );
@


1.38
log
@version displaying in messages, fixes in chunk selection
@
text
@d1278 1
a1278 1
			theApp.downloadqueue->RemoveSource(cur_src, true);
@


1.37
log
@minor graphic details bugfixed, now preview player selection same as official
@
text
@d1669 3
d1690 6
@


1.36
log
@Cax2 updates to GetRating function
@
text
@d2737 2
a2738 10
	if(IsVLCInstalled())
	{
		CString strLine = this->GetFullName();
		strLine.Replace(".met","");
		char shortPath[512]; //Cax2 short path for vlc
		GetShortPathName(strLine,shortPath,512);
		ShellExecute(NULL, "open", "vlc.exe", shortPath, theApp.glob_prefs->GetVlcDir(), SW_SHOWNORMAL);
		//delete[] &shortPath; //Cax2 oops, another unneded delete...
		//delete strLine; 
	} else {
d2743 16
d3775 2
a3776 11

	CFileFind ff;
	CString searchpath(theApp.glob_prefs->GetVlcDir());
	searchpath += "\\*";

	bool end = !ff.FindFile(searchpath,0);
	bool vlcfound = false;

	if (end)
	 	return false;
	while (!end)
d3778 2
a3779 9
	 	end = !ff.FindNextFile();
		if (ff.IsDirectory())
   			continue;
 	 	if (ff.GetFileName().Find("vlc.exe") != -1)
 	 	{
			ff.Close();
			vlcfound = true;
		} else
			continue;
a3780 6
	ff.Close();

	if(vlcfound)
		return true;
	else
		return false;
d3787 1
a3787 1
// DonGato - Moview Preview Mode
@


1.35
log
@now ratings are shown with more descriptive icons (THX->DrSiRiUs)
@
text
@d4151 18
a4168 11
int CPartFile::GetRating(){
	if (!hasRating) return 0;

	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
		return cur_src->GetFileRate();
	}
	return 0;
@


1.34
log
@minor bugfixes, refreshes sources display...
@
text
@d4151 2
a4152 2
bool CPartFile::HasBadRating(){
	if (!hasRating) return false;
d4159 1
a4159 1
		if (cur_src->GetFileRate()==1) return true;
d4161 1
a4161 1
	return false;
@


1.33
log
@SLS TRACEs only when needed
@
text
@d4167 1
a4167 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()/(RAND_MAX/1000))) {
@


1.32
log
@Removed upload slots configuration.
@
text
@d1469 1
d1472 1
d1504 1
d1506 1
a1506 1

d1535 1
d1537 1
d3037 3
a3039 1
			//TRACE("Saved sources for %s (%s.src)\n",storedSources->GetFileName(), storedSources->GetPartFileName());
d3048 1
d3050 1
d3053 1
d3057 1
d3285 1
a3285 1
#ifdef _DEBUG
d3295 1
a3295 1
#ifdef _DEBUG
d3307 1
d3312 1
a3312 1

d3355 1
d3360 1
d3497 1
d3501 1
d3549 1
d3553 1
d3592 1
d3596 1
@


1.32.2.1
log
@write the info on part senders
@
text
@d1278 1
a1278 1
			theApp.downloadqueue->RemoveSource(cur_src);
d1355 1
a1355 1
				theApp.downloadqueue->RemoveSource(cur_src);
a1468 1
#ifdef _DEBUG_SAVED_SOURCES
a1470 1
#endif
a1501 1
#ifdef _DEBUG_SAVED_SOURCES
d1503 1
a1503 1
#endif
a1531 1
#ifdef _DEBUG_SAVED_SOURCES
a1532 1
#endif
a1663 3
    CString gettingParts; // obaldin: gosh, using a string of 'Y' and 'N' as a boolean vector!?!
    sender->ShowDownloadingParts(&gettingParts);

a1681 6
                        if(gettingParts.GetAt(randomness) == 'Y') {
                            goodpart = randomness;
                        } else
                        if(gettingParts.GetAt(goodpart) == 'Y') {
                            // nothing, stay on the current one
                        } else
d2732 10
a2741 2

	if (theApp.glob_prefs->BackupPreview()) {
a2745 16
	} else {
		CString strLine = this->GetFullName();
		CString player=theApp.glob_prefs->GetVideoPlayer();
		if(player.IsEmpty())
			ShellExecute(NULL, "open", strLine, NULL,NULL, SW_SHOWNORMAL);
		else
		{
			if (player.Find("vlc.exe"))
				strLine.Replace(".met","");
			char shortPath[512]; //Cax2 short path for vlc
			GetShortPathName(strLine,shortPath,512);
			CString runDir=player;
			int i=runDir.ReverseFind('\\');
			runDir=(i>=0)?runDir.Left(i+1):"";
			ShellExecute(NULL, "open",player, shortPath, runDir, SW_SHOWNORMAL);
		}
d3032 1
a3032 3
#ifdef _DEBUG_SAVED_SOURCES
			TRACE("Saved sources for %s (%s.src)\n",storedSources->GetFileName(), storedSources->GetPartFileName());
#endif
a3040 1
#ifdef _DEBUG_SAVED_SOURCES
a3041 1
#endif
a3043 1
#ifdef _DEBUG_SAVED_SOURCES
a3046 1
#endif
d3274 1
a3274 1
#ifdef _DEBUG_SAVED_SOURCES
d3284 1
a3284 1
#ifdef _DEBUG_SAVED_SOURCES
a3295 1
#ifdef _DEBUG_SAVED_SOURCES
d3300 1
a3300 1
#endif
a3342 1
#ifdef _DEBUG_SAVED_SOURCES
a3346 1
#endif
a3482 1
#ifdef _DEBUG_SAVED_SOURCES
a3485 1
#endif
a3532 1
#ifdef _DEBUG_SAVED_SOURCES
a3535 1
#endif
a3573 1
#ifdef _DEBUG_SAVED_SOURCES
a3576 1
#endif
d3747 21
a3767 5
	CString player=theApp.glob_prefs->GetVideoPlayer();
	if (player.Find("vlc.exe")>=0)
	{
		CFileFind ff;
		return ff.FindFile(player,0);
d3769 6
d3781 1
a3781 1
// DonGato - Movie Preview Mode
d3821 1
a3821 3
uint32 CPartFile::WriteToBuffer(uint32 transize, BYTE *data, uint32 start, uint32 end, 
                                Requested_Block_Struct *block, 
                                const uchar *senderUserHash, uint32 senderIP)
a3850 2
    memcpy(item->senderhash,senderUserHash,16); // obaldin: save the sending user hash
    item->senderIP = senderIP;
a3935 12
            // store sender in the database
            char hash_part[20];
            memcpy(hash_part, filehash, 16);
            memcpy(hash_part+16, &curpart, 4);
            Dbt key(hash_part,20);

            char hash_ip[20];
            memcpy(hash_ip, item->senderhash, 16);
            memcpy(hash_ip+16, &item->senderIP, 4);
            Dbt val(hash_ip,20);
            theApp.emuledlg->pDbSenders->put(NULL,&key,&val,0);

d4131 11
a4141 18
int CPartFile::GetRating(){  
     if (!hasRating) return 0;  
     int num,tot,fRate;  
     num=tot=0;  
     POSITION pos1,pos2;  
     for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())  
     for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){  
          srclists[sl].GetNext(pos1);  
          fRate =((CUpDownClient*) srclists[sl].GetAt(pos2))->GetFileRate();  
          if (fRate>0)   
          {  
               num++;  
               tot+=fRate;  
          }  
     }  
     if (num>0)   
          return ((float)tot/num+.5);		//Cax2 - better average... :)
     return 0;
d4147 1
a4147 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
@


1.32.2.2
log
@keeping in sync with the main cvs line
@
text
@d1295 1
a1295 1
	if ((m_nTotalBufferData > theApp.glob_prefs->GetFileBufferSize()) /*|| (dwCurTick > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT))*/)
d1388 1
a1388 1
			if ((theApp.glob_prefs->UseRemoteQueueLimit() && !cur_src->IsRemoteQueueFull()) && (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetRemoteQueueLimit())) {
d2988 1
a2988 1
			&& i < (int)theApp.glob_prefs->GetMaxSourcePerFileSoft()){ // DonGato - Using Max Sources per File (soft)	//Cax2 - used new call
@


1.32.2.3
log
@process senders
@
text
@a4006 1
                    UpdateSendersScore(partNumber, true);
a4015 1
                    UpdateSendersScore(partNumber, false);
a4188 27
}

void CPartFile::UpdateSendersScore(uint32 partno, bool is_corrupt) {
    Dbc *dbcp;
    int res;

    theApp.emuledlg->pDbSenders->cursor(NULL, &dbcp, 0);

    char hash_part[20];
    memcpy(hash_part, filehash, 16);
    memcpy(hash_part+16, &partno, 4);
    Dbt key(hash_part,20);

    Dbt data;

    int count = 0;
    res = dbcp->get(&key,&data,DB_SET);
    while(res==0) {
        ASSERT(data.get_size() == 20);
        DWORD sender_ip;
        memcpy(&sender_ip, data.get_data(), 4);
        count++;

        res = dbcp->get(&key,&data,DB_NEXT_DUP);
    }
    theApp.emuledlg->AddDebugLogLine(false,CString("DEBUG: %d senders found"),count);
    dbcp->close();
@


1.31
log
@Banning Message, A4AF customization, AutoPriority fix, Static Servers fix, .dat/.bin Preview
@
text
@d1429 3
a1431 3
		// if (IsA4AFAuto()) {
		//	theApp.emuledlg->transferwnd.downloadlistctrl.DownloadAllA4AF(this);
		// }
@


1.30
log
@control panel limits, optimizations, bugfixes
@
text
@a344 1
					if ((priority==PR_AUTO)&&(!theApp.glob_prefs->IsUAPEnabled())) priority=PR_NORMAL;
d347 1
a348 1
					{ 
a349 2
						CKnownFile::UpdateUploadAutoPriority();
					}
a359 1
					if ((priority==PR_AUTO)&&(!theApp.glob_prefs->IsUAPEnabled())) priority=PR_NORMAL;
d372 1
a372 2
					if ((!newtag->tag->specialtag) &&
						 (newtag->tag->tagname[0] == FT_GAPSTART ||
d567 1
a567 1
		//UAP Hunter
d575 1
a575 1
		//end UAP
d781 1
a781 1
		end = (PARTSIZE*partnumber) + (lastblock*BLOCKSIZE)-1; //Endadress from 1chunk before the last chunk
d1429 3
a1431 3
		if (IsA4AFAuto()) {
			theApp.emuledlg->transferwnd.downloadlistctrl.DownloadAllA4AF(this);
		}
d2285 2
a2286 1
		return (strstr(fname,".avi") || strstr(fname,".bin") || strstr(fname,".ogm") || strstr(fname,".mpg") || strstr(fname,".mpe"));
d2288 2
a2289 1
		return (strstr(fname,".avi") || strstr(fname,".mpg") || strstr(fname,".ogm") || strstr(fname,".mpe"));
d2320 6
a2325 1
	return (strstr(fname,".mpg") || strstr(fname,".mpeg"));
d2551 1
a2551 6
	//UAP
	if (np == PR_AUTO)
		SetAutoPriority(true) ;
	else
		priority = np;
	//end UAP
@


1.29
log
@re-enabled chunk selection algorithm by vorlost
@
text
@d1393 1
a1393 1
			if ((!cur_src->IsRemoteQueueFull()) && (cur_src->GetRemoteQueueRank() > theApp.glob_prefs->GetRemoteQueueLimit())) {
@


1.28
log
@the famous zz upload system! :)
@
text
@d1676 1
a1676 2
/*
		uint16 randomness = (uint16)ROUND(((float)rand()/RAND_MAX)*(GetPartCount()-1)); 
d1740 1
a1740 1
*/
d1796 7
a1802 7
                                                /*if (IsCorruptedPart(randomness)){
                                                        if (GetNextEmptyBlockInPart(randomness,0)){
                                                                goodpart = randomness;
                                                                break;
                                                        }
                                                }
                                                else */ 
d1838 1
@


1.27
log
@Code clean up and double check wit official code.
@
text
@d1317 1
a1317 1
		theApp.emuledlg->AddDebugLogLine(false, "Send:Source Request Server File(%s)", GetFileName());
d1339 1
a1339 1
			uint32 cur_datarate = cur_src->CalculateDownloadRate();
d2709 1
a2709 1
	if (GetDatarate()==0) return -1;
d2912 1
a2912 1
	theApp.emuledlg->AddDebugLogLine(false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount);
d2931 1
a2931 1
	theApp.emuledlg->AddDebugLogLine(false, "RCV:Sources File(%s) Count(%i)", GetFileName(), nCount);
@


1.26
log
@minor updates & bugfixes
@
text
@d1000 2
a1001 1
		percentcompleted = 100; completedsize=filesize;
d1034 2
a1035 1
		percentcompleted = 100; completedsize=filesize;
d1317 1
a1456 1

d1934 2
a1935 1
	if (m_hpartfile.m_hFile != INVALID_HANDLE_VALUE) m_hpartfile.Close(); // m_hpartfile isn't the handle to the file...
d2673 2
d2677 3
a2679 3
	EMULE_TRY 

	if (GetTransferingSrcCount()==0) status=1;
d2683 1
a2683 1
			status=3;
d2686 1
a2686 1
			status=4;
d2689 1
a2689 1
			status=5;
d2692 1
a2692 1
			status=2;
d2695 1
a2695 1
			status=6;
d2698 1
d2702 1
a2702 1
	return status;
d2912 1
a2912 1
//	theApp.emuledlg->AddDebugLogLine( false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount );
d2931 1
a2931 1
//	theApp.emuledlg->AddDebugLogLine( false, "RCV:Sources File(%s) Count(%i)", GetFileName(), nCount );
a2975 15
				/* if(m_stscrStoringSources == NULL){ // i_a: added to fix bug related to adding sources by extended edonkey URL (with source IP) 
					m_stscrStoringSources = new CStoredSources(GetPartMetFileName()
															, GetFileName() 
	                                       					, GetFileHash() 
	                                       					, theApp.glob_prefs->GetMaxSourcePerFileSoft()); 
	            	//set the preferences for the StoredSources 
					if(m_stscrStoringSources != NULL)
					{
	            				m_stscrStoringSources->SetPreferences(theApp.glob_prefs->GetMaxSourcePerFileSoft() 
	            	                    							, m_iLoadSourcesAtOnceLimit 
	                                    							, m_iLoadingSourcesTimeInterval 
	                                    							, m_iLoadingSourcesPartialTimeInterval 
	                                    							, m_iSavingSourcesTimeInterval); 
	          		}
          		} */
a4049 7
        /*
		paused = true;
		datarate = 0;
		transferingsrc = 0;
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		UpdateDisplayedInfo();
        */
d4146 1
a4154 1

@


1.25
log
@New friends icons and OGM preview support (as AVI)...
@
text
@d1019 1
a1019 1
		crProgress = RGB(0, 224, 0); 
@


1.24
log
@minor improvements
@
text
@d2287 1
a2287 1
		return (strstr(fname,".avi") || strstr(fname,".bin") || strstr(fname,".mpg") || strstr(fname,".mpeg"));
d2289 1
a2289 1
		return (strstr(fname,".avi") || strstr(fname,".mpg") || strstr(fname,".mpeg"));
d2305 1
a2305 1
	return (strstr(fname,".avi"));
d4072 1
@


1.23
log
@Removed FLMC as a preferences option.
@
text
@d1020 1
a1020 1
		crHave = RGB(104, 104, 104); 
@


1.22
log
@menu rearrangements
@
text
@d2457 1
a2457 1
	if (theApp.glob_prefs->IsFirstLastMovieChunksEnabled() && IsMovie())
d2479 1
a2479 2
	if (theApp.glob_prefs->IsFirstLastMovieChunksEnabled() && IsMovie()//Moviechunks enabled & IsMovie
 		&& ((m_SrcpartFrequency[oldchunk] > raremovie
@


1.21
log
@Little fixes and Static Servers additions from 26d
@
text
@a192 1
	m_bIsPreviewChunksEnabled = false; // obaldin
d1758 1
a1758 1
                if ((!foundPriorityPart) && (IsArchive() || IsMovie()) && GetPreviewChunksEnabled()) // obaldin
a3802 3
   	bool preview_chunks = pvmoviefile.GetBool("PreviewChunks", false, "Chunks"); // obaldin
	SetPreviewChunksEnabled(preview_chunks);

a3811 2

	pvmoviefile.WriteBool("PreviewChunks", GetPreviewChunksEnabled(), "Chunks");  // obaldin
@


1.20
log
@Preparing for new SLS code
@
text
@d1432 3
a1434 3
		//if (IsA4AFAuto()) {
		//	theApp.emuledlg->transferwnd.downloadlistctrl.DownloadAllA4AF(this);
		//}
@


1.19
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d152 1
d166 1
a166 1

d217 1
d222 1
a222 1

d1467 1
a1467 1

d1553 1
a1553 1

d2619 1
d2621 1
d2987 1
d2990 1
d3015 1
a3015 1

d3600 1
a3600 1

@


1.18
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d180 1
d480 1
a480 1
		m_hpartfile.GetStatus(filestatus);
d1316 1
d1329 3
a1331 1
		switch (cur_src->GetDownloadState())
d1345 1
a1345 1
			else
d1347 2
d1358 1
d1363 1
a1363 1
/*
d1366 1
a1366 1
			if ( (theApp.listensocket->GetOpenSockets() > (theApp.glob_prefs->GetMaxConnections() * 0.75)) || theApp.downloadqueue->IsMaxClientsExceeded() )
a1367 2
			if (!((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > usethisfilereasktime*2)) 
				break;
d1369 1
a1369 9
*/
			// Commented by Tarod -handled in a different way... just when receiving sources
			//if( ((dwCurTick - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
			//	if( !cur_src->SwapToAnotherFile( cur_src ) ){
			//		theApp.downloadqueue->RemoveSource( cur_src );
			//		lastpurgetime = dwCurTick;
			//	}
			//}
						
d1371 1
a1371 1
			if (!((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > FILEREASKTIME*2))
d1375 10
a1384 10
/* MERGE26
			if( cur_src->IsRemoteQueueFull() )
			{
				if( ((dwCurTick - lastpurgetime) > 60000) && (this->GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
					theApp.downloadqueue->RemoveSource( cur_src );
					lastpurgetime = dwCurTick;
				}
			}
*/
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > FILEREASKTIME-20000)){
d1391 1
a1391 1
                                break;
d1399 1
a1399 1
/*			//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
a1400 2
*/
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (dwCurTick - cur_src->GetLastAskedTime()) > FILEREASKTIME))
d1913 1
d2555 1
d2602 1
d2810 1
a2810 2
void CPartFile::UpdateAvailablePartsCount()
{
d2813 14
a2826 59
	POSITION pos1,pos2;
	uint8 availablecounter=0;

	bool breakflag=false;

    /* 
	for (int ixPart=0;ixPart<GetPartCount();ixPart++) {
		breakflag=false;
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty() && !breakflag )
		for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL && !breakflag; ){
				srclists[sl].GetNext(pos1);
				if (srclists[sl].GetAt(pos2)->IsPartAvailable(ixPart)) { availablecounter++; breakflag=true;}
		}
	}
    */

    // obaldin: profiler showed that this is a bottleneck when
    // there's a lot of sources, so below is a faster version

    /* this is faster, but not fast enough
    int partCnt = GetPartCount();
    bool *partmask = new bool[partCnt];
    int i;
    for(i=0; i<partCnt; i++) 
        partmask[i]=false;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty() && !breakflag)
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL && !breakflag; ){
			srclists[sl].GetNext(pos1);
            for (int ixPart=0; ixPart<partCnt && !breakflag; ixPart++) {
                if(!partmask[ixPart])
                    if(srclists[sl].GetAt(pos2)->IsPartAvailable(ixPart)) {
                        partmask[ixPart] = true;
                        availablecounter++;
                        if(availablecounter == partCnt)
                            breakflag=true;
                    }
            }
	}
    delete[] partmask;
    */
    int partCnt = GetPartCount();
    bool *partmask = new bool[partCnt];
    uint8 *partstatus;
    for(int i=0; i<partCnt; i++) 
        partmask[i]=false;

	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty() && !breakflag)
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL && !breakflag; ){
			srclists[sl].GetNext(pos1);
            partstatus = srclists[sl].GetAt(pos2)->GetPartStatus();
            if(partstatus)
                for (int ixPart=0; ixPart<partCnt && !breakflag; ixPart++) {
                    if(!partmask[ixPart])
                        if(partstatus[ixPart]) {
                            partmask[ixPart] = true;
                            availablecounter++;
                            if(availablecounter == partCnt)
                                breakflag=true;
                        }
d2829 3
a2831 5
    delete[] partmask;

	if (GetPartCount()==availablecounter && availablePartsCount<GetPartCount())
		lastseencomplete=CTime::GetCurrentTime();
	availablePartsCount=availablecounter;
d2848 1
a2848 1

d2851 1
a2873 1
			bool bNeeded = false;
a2879 2
			if (!bNeeded)
				continue;
d2881 13
a2893 11
		nCount++;
		uint32 dwID = cur_src->GetUserID();
		uint16 nPort = cur_src->GetUserPort();
		uint32 dwServerIP = cur_src->GetServerIP();
		uint16 nServerPort = cur_src->GetServerPort();
		data.Write(&dwID,4);
		data.Write(&nPort,2);
		data.Write(&dwServerIP,4);
		data.Write(&nServerPort,2);
		if (nCount > 500)
			break;
d3988 2
a3989 1
					m_iLostDueToCorruption += (partRange + 1);				}
@


1.17
log
@Locale set in thread
@
text
@d27 7
@


1.16
log
@better out-of-disk-space handling
@
text
@d3780 2
@


1.15
log
@*** empty log message ***
@
text
@d4085 1
d4092 2
d4100 1
d4106 2
@


1.14
log
@more 26b merges
@
text
@d1603 1
a1603 1
	theApp.emuledlg->AddDebugLogLine(false,"RCV: %i sources from server, %i low id dropped, %i possible sources",count,debug_lowiddropped,debug_possiblesources);
d2947 1
a2947 1
	theApp.emuledlg->AddDebugLogLine( false, "Send:Source User(%s) File(%s) Count(%i)", forClient->GetUserName(), GetFileName(), nCount );
d2966 1
a2966 1
	theApp.emuledlg->AddDebugLogLine( false, "RCV:Sources File(%s) Count(%i)", GetFileName(), nCount );
@


1.13
log
@show last progress time on a file being downloaded
@
text
@d702 2
a703 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d966 2
a967 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d1282 1
a1282 1
uint32 CPartFile::Process(sint16 reducedownload/*in percent*/)
d1286 2
d1289 1
a1289 1
	if ((m_nTotalBufferData > BUFFER_SIZE_LIMIT) || (GetTickCount() > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)))
d1297 2
a1298 2
	uint16 test = theApp.glob_prefs->GetMaxSourcePerFileSoft();
	if (( (!lastsearchtime) || (::GetTickCount() - lastsearchtime) > SERVERREASKTIME) && theApp.serverconnect->IsConnected()
d1301 1
a1301 1
		lastsearchtime = ::GetTickCount();
d1304 1
a1304 1
		theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
d1310 7
a1316 3
	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
a1317 1

d1327 1
a1327 1
				uint32 limit = (uint32)(((float)reducedownload/100)*cur_datarate)/10;		
d1342 1
a1342 1
			if( ((GetTickCount() - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
d1344 1
a1344 1
				lastpurgetime = ::GetTickCount();
d1354 1
a1354 1
			if (!((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > usethisfilereasktime*2)) 
d1359 1
a1359 1
			//if( ((::GetTickCount() - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
d1362 1
a1362 1
			//		lastpurgetime = ::GetTickCount();
d1367 1
a1367 1
			if (!((!cur_src->GetLastAskedTime()) || (GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME*2))
d1374 1
a1374 1
				if( ((::GetTickCount() - lastpurgetime) > 60000) && (this->GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
d1376 1
a1376 1
					lastpurgetime = ::GetTickCount();
d1380 1
a1380 1
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME-20000)){
d1387 1
d1396 1
a1396 1
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > usethisfilereasktime))
d1398 1
a1398 1
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME))
d1403 3
d1410 2
a1411 2
	if (((!m_LastNoNeededCheck) || (::GetTickCount() - m_LastNoNeededCheck) > 10000)){
		m_LastNoNeededCheck = ::GetTickCount();
d1455 2
a1456 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d1636 2
a1637 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d1738 1
a1738 1
                // Otherwise it would keep looping to find 3 blocks, there is only one and it is requested 
a1927 1
	//if (m_hpartfile != INVALID_HANDLE_VALUE) m_hpartfile.Close();
d2130 3
a2132 2
    theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this); 
	SHAddToRecentDocs(SHARD_PATH, fullname); // zegzav (added)
d2140 1
a2140 1
	transfered = filesize;
a2181 1
	//if (m_hpartfile != INVALID_HANDLE_VALUE) m_hpartfile.Close();
d2227 1
d2232 1
d2550 2
a2551 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d2569 2
a2570 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d2587 1
a2587 1
			theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d2596 2
a2597 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d2609 2
a2610 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d3959 1
a3959 1
	int partCount = (filesize/PARTSIZE)+((filesize%PARTSIZE)? 1 : 0);
d3968 1
a3968 1
		for (int partNumber=0; partNumber<partCount; partNumber++)
d4089 2
a4090 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4100 2
a4101 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4175 1
a4175 1
	if (prev!=(hasComment || hasRating)) theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d4180 1
a4180 1
	for (int i=0;i<100;i++) count+=srclists[i].GetCount();
d4196 9
@


1.12
log
@merge with a branch fixes
@
text
@d185 1
d473 1
d3934 1
a3934 1
	m_nLastBufferFlushTime = GetTickCount();
d3938 1
@


1.11
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d2551 1
@


1.10
log
@stopped files bugfix & updated search dialog
@
text
@d174 2
d641 1
a641 1
				theApp.emuledlg->AddDebugLogLine(false,GetResString(IDS_ERR_FOUNDCORRUPTION),i+1,filename);		
a649 1
			theApp.emuledlg->AddLogLine(true,"DEBUG FCB: Completing file-hashing ok (%s)", GetFileName());
a657 1
		theApp.emuledlg->AddLogLine(true,"DEBUG FCB: Completing file-hashing Failed (%s)", GetFileName());
a660 1
	theApp.emuledlg->AddLogLine(true,"DEBUG FCB: Completing file-hashing (Should never have gotten here) (%s)", GetFileName());
d1154 1
a1154 1
	uint16 parts = hashlist.GetCount();
d1181 4
a1184 3
	for (pos1 = srclist.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclist.GetNext(pos1);
		CUpDownClient* cur_src = srclist.GetAt(pos2);
d1202 4
a1205 3
	for (pos1 = srclist.GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclist.GetNext(pos1);
		CUpDownClient* cur_src = srclist.GetAt(pos2);
d1262 4
a1265 3
	for (pos1 = srclist.GetHeadPosition(); (pos2 = pos1) != NULL && removed < number_sources_to_remove;) {
		srclist.GetNext(pos1);
		CUpDownClient* cur_src = srclist.GetAt(pos2);
d1298 1
d1305 3
a1307 9
	for (pos1 = srclist.GetHeadPosition();( pos2 = pos1 ) != NULL;)
	{
		srclist.GetNext(pos1);

		CUpDownClient* cur_src = srclist.GetAt(pos2);

/*		// let's try to disable it first
		if(cur_src == NULL)
			continue;
d1309 1
a1309 19
		//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
		uint32 usethisfilereasktime = FILEREASKTIME; //Vorlost 
		if ( (GetTickCount() - cur_src->GetLastAskedTime()) > usethisfilereasktime )
		{ 
			if ( ( 
				(theApp.listensocket->GetOpenSockets() > (theApp.glob_prefs->GetMaxConnections() * 0.75)) 
					|| theApp.downloadqueue->IsMaxClientsExceeded()) 
				&& (cur_src->GetRemoteQueueRank()) ) 
			{ //Vorlost QueueRank > 500 --> Filereasktime=45minutes 
				if ( cur_src->GetRemoteQueueRank() > 500 )
				{ 
					usethisfilereasktime = FILEREASKTIME * 2.5 ; //Vorlost 
//					theApp.emuledlg->AddLogLine(false,false,"New Filereasktime: %d)",usethisfilereasktime);
				} 
				else usethisfilereasktime = FILEREASKTIME * 2; //Vorlost (QR 1-500 = 36minutes) 
			} 
		} 
		//End Vorlost 
*/
d1362 9
d1400 4
a1403 3
		for (pos1 = srclist.GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclist.GetNext(pos1);
			CUpDownClient* cur_src = srclist.GetAt(pos2);
d1598 5
a1602 1
	if (m_SrcpartFrequency.GetCount() != GetPartCount()){
d1605 1
a1605 1
		for (int i = 0; i != GetPartCount();i++)
d1609 1
a1609 1
		for (int i = 0; i != GetPartCount();i++)
d1612 7
a1618 3
	for (POSITION pos = srclist.GetHeadPosition();pos != 0;srclist.GetNext(pos)){
		for (int i = 0; i != GetPartCount(); i++){
			if (srclist.GetAt(pos)->IsPartAvailable(i))
a1871 1
	theApp.emuledlg->AddLogLine(true,"DEBUG FCB: Starting to complete file. (Flag:%i) (%s)", bIsHashingDone, GetFileName());
d2140 3
a2142 2
	for( pos1 = srclist.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclist.GetNext(pos1);
d2144 2
a2145 2
			if (!srclist.GetAt(pos2)->SwapToAnotherFile(true))
				theApp.downloadqueue->RemoveSource(srclist.GetAt(pos2));
d2148 1
a2148 1
			theApp.downloadqueue->RemoveSource(srclist.GetAt(pos2));
d2151 1
d2563 4
a2566 3
	for( pos1 = srclist.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclist.GetNext(pos1);
		CUpDownClient* cur_src = srclist.GetAt(pos2);
d2568 1
d2791 3
d2795 52
a2846 3
		for( pos1 = srclist.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
				srclist.GetNext(pos1);
				if (srclist.GetAt(pos2)->IsPartAvailable(ixPart)) { availablecounter++; pos1=NULL;}
d2849 2
d2862 2
a2863 2
	if (srclist.IsEmpty())
		return 0;
d2871 3
a2873 2
	for (POSITION pos = srclist.GetHeadPosition();pos != 0;srclist.GetNext(pos)){
		CUpDownClient* cur_src = srclist.GetAt(pos);
d3225 4
a3228 1
					if(srclist.GetCount() >= theApp.glob_prefs->GetMaxSourcePerFile()
a3229 15
#ifdef _DEBUG
						if((srclist.GetCount() >= theApp.glob_prefs->GetMaxSourcePerFile())){
							TRACE("(LoadNAdd): break because of too many sources (\r\n\tsources for this file: %i, MaxSourcesPerFile: %u\n"
									,srclist.GetCount()
									,theApp.glob_prefs->GetMaxSourcePerFile()
							);
						}
						if(((limit != -1)&&(countAddedSources > limit))){
							TRACE("(LoadNAdd): break because of loaded all sources for one loop (->source-at-once-limit reached) (\r\n\tsources loaded %i, sources at once limit: %i\n"
									,countAddedSources
									,limit
							);
						}
#endif
						//break;
d3420 1
a3420 1
#ifdef _DEBUG
d3434 1
a3434 1
#ifdef _DEBUG
d3468 1
a3468 1
#ifdef _DEBUG
d3475 3
a3477 2
	for(POSITION posOfSource=srclist.GetHeadPosition() ; posOfSource != NULL;){
		source = srclist.GetNext(posOfSource);
d3486 1
a3486 1
#ifdef _DEBUG
d3547 3
a3549 2
		for(POSITION posOfSource=srclist.GetHeadPosition() ; posOfSource != NULL;){
			source = srclist.GetNext(posOfSource);
d3588 3
a3590 2
		for(POSITION posOfSource=srclist.GetHeadPosition() ; posOfSource != NULL;){
			source = srclist.GetNext(posOfSource);
a3857 3
	if( status == PS_COMPLETING || status == PS_COMPLETE )
		theApp.emuledlg->AddLogLine(true,"DEBUG FCB: Block received while/after completing (Writebuffer) (%s)", GetFileName());

a3934 3
	if( status == PS_COMPLETING || status == PS_COMPLETE )
		theApp.emuledlg->AddLogLine(true,"DEBUG FCB: Block received while/after completing (Flush buffer) (%s)", GetFileName());

d4003 1
a4003 1
					theApp.emuledlg->AddDebugLogLine(true, GetResString(IDS_ERR_PARTCORRUPT), partNumber, GetFileName());
d4131 31
d4163 8
a4170 1
	EMULE_CATCH
@


1.10.2.1
log
@initial upgrade to .26
@
text
@d34 2
a35 1
CPartFile::CPartFile(){
d39 2
a40 1
CPartFile::CPartFile(CSearchFile* searchresult){
d90 1
a90 2
void
CPartFile::InitializeFromLink(CED2KFileLink* fileLink)
d121 2
a122 1
void CPartFile::Init(){
d159 1
a159 1
	m_bPreviewing = false;
a173 2
	hasRating=false;
	hasComment=false;
d187 2
a188 1
CPartFile::~CPartFile(){
d213 2
a214 1
void CPartFile::CreatePartFile(){
d639 1
a639 1
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_FOUNDCORRUPTION),i+1,filename);		
d648 1
d657 1
d661 1
d669 2
a670 1
void CPartFile::AddGap(uint32 start, uint32 end){
d1151 2
a1152 1
void CPartFile::WritePartStatus(CFile* file){
d1155 1
a1155 1
	uint16 parts = GetPartCount();
d1176 2
a1177 1
int CPartFile::GetValidSourcesCount() {
d1182 3
a1184 4
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1195 2
a1196 1
uint16 CPartFile::GetNotCurrentSourcesCount(){
d1201 7
a1207 8
		POSITION pos1,pos2;
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
			if (cur_src->GetDownloadState()!=DS_ONQUEUE && cur_src->GetDownloadState()!=DS_DOWNLOADING) counter++;
		}
		return counter;
d1214 2
a1215 1
uint8 CPartFile::GetStatus(bool ignorepause){
d1261 3
a1263 4
    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition(); (pos2 = pos1) != NULL && removed < number_sources_to_remove;) {
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1276 2
a1277 1
uint32 CPartFile::Process(sint16 reducedownload/*in percent*/){
d1281 1
a1281 3
    // MERGE26 - have to add theApp.glob_prefs->GetFileBufferSize() to prefs
//	if ((m_nTotalBufferData > theApp.glob_prefs->GetFileBufferSize()) || (GetTickCount() > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)))
	if ((m_nTotalBufferData > 500000) || (GetTickCount() > (m_nLastBufferFlushTime + BUFFER_TIME_LIMIT)))
a1295 1
		theApp.uploadqueue->AddUpDataOverheadServer(packet->size, 0);
d1302 3
a1304 3
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
d1306 5
a1310 1
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1312 19
d1332 2
a1333 1
		switch (cur_src->GetDownloadState()){
a1382 8
/* MERGE26
						if( cur_src->IsRemoteQueueFull() ){
							if( ((::GetTickCount() - lastpurgetime) > 60000) && (this->GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
								theApp.downloadqueue->RemoveSource( cur_src );
								lastpurgetime = ::GetTickCount();
							}
						}
*/
d1400 1
a1400 1
			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME)){
a1401 1
			}
d1412 3
a1414 4
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
			srclists[sl].GetNext(pos1);
			CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
d1554 2
a1555 1
void CPartFile::AddSources(CMemFile* sources,uint32 serverip, uint16 serverport){
d1605 2
a1606 1
void CPartFile::NewSrcPartsInfo(){
d1619 1
a1619 2
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;srclists[sl].GetNext(pos)){
d1621 1
a1621 1
			if (srclists[sl].GetAt(pos)->IsPartAvailable(i))
d1871 2
a1872 1
void CPartFile::CompleteFile(bool bIsHashingDone){
d1875 1
d1904 2
a1905 1
BOOL CPartFile::PerformFileComplete(void) { 
d1921 2
a1922 1
	if(PathFileExists(newname)){
d1938 3
a1940 2
		if((ext != newfilename) && (strrchr(newfilename, ')') + 1 == last)) {
			char *first = strrchr(newfilename, '(');
d1947 2
a1948 1
            		if(*step < '0' || *step > '9') {
d1952 2
a1953 1
            	if(found) {
d2138 2
a2139 1
void  CPartFile::RemoveAllSources(bool bTryToSwap){
d2144 2
a2145 3
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclists[sl].GetNext(pos1);
d2147 2
a2148 2
			if (!srclists[sl].GetAt(pos2)->SwapToAnotherFile(true))
				theApp.downloadqueue->RemoveSource(srclists[sl].GetAt(pos2));
d2151 1
a2151 1
			theApp.downloadqueue->RemoveSource(srclists[sl].GetAt(pos2));
a2153 1
	UpdateFileRatingCommentAvail();
d2157 2
a2158 1
void CPartFile::DeleteFile(){
d2248 2
a2249 1
bool CPartFile::IsCorruptedPart(uint16 partnumber){
d2259 2
a2260 1
bool CPartFile::IsMovie(){
d2525 2
a2526 1
void CPartFile::SetPriority(uint8 np){
d2541 2
a2542 1
void CPartFile::StopFile(){
a2552 1
	FlushBuffer();
d2558 2
a2559 1
void CPartFile::PauseFile(){
d2565 3
a2567 4
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
a2568 1
			theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d2582 2
a2583 1
void CPartFile::ResumeFile(){
d2640 2
a2641 1
int CPartFile::getPartfileStatusRang(){
d2646 1
a2646 2
	int tempstatus=0;
	if (GetTransferingSrcCount()==0) tempstatus=1;
d2650 1
a2650 1
			tempstatus=3;
d2653 1
a2653 1
			tempstatus=4;
d2656 1
a2656 1
			tempstatus=5;
d2659 1
a2659 1
			tempstatus=2;
d2662 1
a2662 1
			tempstatus=6;
d2668 1
a2668 1
	return tempstatus;
d2684 2
a2685 1
void CPartFile::PreviewFile(){
d2695 2
a2696 1
	if (!PreviewAvailable()){
d2784 2
a2785 1
void CPartFile::UpdateAvailablePartsCount(){
a2789 1
	bool breakflag=false;
d2792 3
a2794 5
		breakflag=false;
		for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty() && !breakflag )
		for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL && !breakflag; ){
				srclists[sl].GetNext(pos1);
				if (srclists[sl].GetAt(pos2)->IsPartAvailable(ixPart)) { availablecounter++; /*pos1=NULL;*/breakflag=true;}
d2804 2
a2805 1
Packet*	CPartFile::CreateSrcInfoPacket(CUpDownClient* forClient){
d2808 2
a2809 2
	int sl;
	for (sl=0;sl<SOURCESSLOTS;sl++) if (srclists[sl].IsEmpty()) return 0;
d2817 2
a2818 3
	for (sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;srclists[sl].GetNext(pos)){
		CUpDownClient* cur_src = srclists[sl].GetAt(pos);
d2855 4
a2858 4
		data.Write(&dwID, 4);
		data.Write(&nPort, 2);
		data.Write(&dwServerIP, 4);
		data.Write(&nServerPort, 2);
d2864 2
a2865 2
	data.Seek(16, 0);
	data.Write(&nCount, 2);
d2867 1
a2867 1
	Packet* result = new Packet(&data, OP_EMULEPROT);
d2879 2
a2880 1
void CPartFile::AddClientSources(CMemFile* sources){
d3170 1
a3170 4
                    int srcsCount = 0;
                    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
                        srcsCount += srclists[sl].GetCount();
					if(srcsCount >= theApp.glob_prefs->GetMaxSourcePerFile()
d3172 15
d3432 2
a3433 3
    for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
    for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
		source = srclists[sl].GetNext(posOfSource);
d3503 2
a3504 3
        for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
			source = srclists[sl].GetNext(posOfSource);
d3543 2
a3544 3
        for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
		for(POSITION posOfSource=srclists[sl].GetHeadPosition() ; posOfSource != NULL;){
			source = srclists[sl].GetNext(posOfSource);
d3810 5
d3892 3
d3963 1
a3963 1
					theApp.emuledlg->AddLogLine(true, GetResString(IDS_ERR_PARTCORRUPT), partNumber, GetFileName());
d4091 1
a4092 39
}

void CPartFile::UpdateFileRatingCommentAvail() {
	if (!this) return;

	bool prev=(hasComment || hasRating);

	hasComment=false;
	hasRating=false;

	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
		if (cur_src->GetFileComment().GetLength()>0) hasComment=true;
		if (cur_src->GetFileRate()>0) hasRating=true;
		if (hasComment && hasRating) break;
	}
	if (prev!=(hasComment || hasRating)) theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
}

uint16 CPartFile::GetSourceCount() {
	uint16 count=0;
	for (int i=0;i<100;i++) count+=srclists[i].GetCount();
	return count;
}

bool CPartFile::HasBadRating(){
	if (!hasRating) return false;

	POSITION pos1,pos2;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty())
	for (pos1 = srclists[sl].GetHeadPosition();( pos2 = pos1 ) != NULL;){
		srclists[sl].GetNext(pos1);
		CUpDownClient* cur_src = srclists[sl].GetAt(pos2);
		if (cur_src->GetFileRate()==1) return true;
	}
	return false;
@


1.10.2.2
log
@speedup
@
text
@a2756 1

a2758 1
    /* 
d2764 1
a2764 1
				if (srclists[sl].GetAt(pos2)->IsPartAvailable(ixPart)) { availablecounter++; breakflag=true;}
a2766 24
    */
    // obaldin: profiler showed that this is a bottleneck when
    // there's a lot of sources, so below is a faster version
    int partCnt = GetPartCount();
    bool *partmask = new bool[partCnt];
    int i;
    for(i=0; i<partCnt; i++) 
        partmask[i]=false;
	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty() && !breakflag)
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL && !breakflag; ){
			srclists[sl].GetNext(pos1);
            for (int ixPart=0; ixPart<partCnt && !breakflag; ixPart++) {
                if(!partmask[ixPart])
                    if(srclists[sl].GetAt(pos2)->IsPartAvailable(ixPart)) {
                        partmask[ixPart] = true;
                        availablecounter++;
                        if(availablecounter == partCnt)
                            breakflag=true;
                    }
            }
	}
    delete[] partmask;


@


1.10.2.3
log
@more speedups
@
text
@a2769 1

a2771 2

    /*
a2790 23
    */
    int partCnt = GetPartCount();
    bool *partmask = new bool[partCnt];
    uint8 *partstatus;
    for(int i=0; i<partCnt; i++) 
        partmask[i]=false;

	for (int sl=0;sl<SOURCESSLOTS;sl++) if (!srclists[sl].IsEmpty() && !breakflag)
	for( pos1 = srclists[sl].GetHeadPosition(); ( pos2 = pos1 ) != NULL && !breakflag; ){
			srclists[sl].GetNext(pos1);
            partstatus = srclists[sl].GetAt(pos2)->GetPartStatus();
            if(partstatus)
                for (int ixPart=0; ixPart<partCnt && !breakflag; ixPart++) {
                    if(!partmask[ixPart])
                        if(partstatus[ixPart]) {
                            partmask[ixPart] = true;
                            availablecounter++;
                            if(availablecounter == partCnt)
                                breakflag=true;
                        }
                }
    }
    delete[] partmask;
d3360 1
a3360 1
#ifdef _DEBUG_SAVED_SOURCES
d3374 1
a3374 1
#ifdef _DEBUG_SAVED_SOURCES
d3408 1
a3408 1
#ifdef _DEBUG_SAVED_SOURCES
d3426 1
a3426 1
#ifdef _DEBUG_SAVED_SOURCES
@


1.10.2.4
log
@still more speedups
@
text
@d1588 1
a1588 5
    uint16 partcount;

    partcount = GetPartCount();

	if (m_SrcpartFrequency.GetCount() != partcount){
d1591 1
a1591 1
		for (int i = 0; i != partcount;i++)
d1595 1
a1595 1
		for (int i = 0; i != partcount;i++)
d1599 5
a1603 8
	for (POSITION pos = srclists[sl].GetHeadPosition();pos != 0;){
        CUpDownClient* cur_src = srclists[sl].GetNext(pos);
        uint8* partstatus = cur_src->GetPartStatus();
        if(partstatus)
		    for (int i = 0; i != partcount; i++){
			    if (partstatus[i])
				    m_SrcpartFrequency[i] +=1;
		    }
d2774 1
a2774 1
    /* this is faster, but not fast enough
@


1.10.2.5
log
@more fixes, more merging, try/catch balancing
@
text
@a2618 1
	int tempstatus=0;
d2622 1
a3828 2
	EMULE_TRY

@


1.9
log
@Get fist/last chunk is now a per-file setting
@
text
@d1557 4
d2883 4
a3090 2
	if (limit>0)limit = RESTORE_SOURCES_AT_ONCE; // Vorlost (bypass the old value stored in each SLS File) 

d3092 1
a3092 1
	if(GetStatus() > 7)
d3095 2
d3305 4
@


1.8
log
@bugfixes & control panel updates
@
text
@d182 2
d1739 1
a1739 1
                if ((!foundPriorityPart) && (IsArchive() || IsMovie()) && theApp.glob_prefs->GetPreviewPrio())
d3760 3
d3772 2
@


1.7
log
@Updates to Preferences (and enabling/disabling options in code because of that)
@
text
@d2157 1
a2157 3
	// Barry - Need to tell any connected clients to stop sending the file
	PauseFile();

d2161 1
a2161 1
	RemoveAllSources(true);
@


1.6
log
@merge fixes and minor optimizations
@
text
@d3961 1
a3961 1
			else if ( IsCorruptedPart(partNumber) && theApp.glob_prefs->IsICHEnabled())
@


1.5
log
@Added .movie and .stats removal when file is deleted.
@
text
@d998 1
a998 1
	COLORREF crPending;
a1003 1
		crPending = RGB(255,208,0);
a1006 1
			crPending = RGB(255, 208, 0);
a1106 1
	COLORREF crUnconfirmed = RGB(255, 210, 0);
a1107 1
	float blockpixel = (float)(rect->right -  rect->left)/((float)filesize);
d1121 1
a1121 1
		s_LoadBar.Fill(crProgress);
d1137 1
a1137 1
		dc->FillRect(&gaprect, &CBrush(crUnconfirmed));
a1145 6
	if (	   (gaplist.GetCount() || requestedblocks_list.GetCount())	   )
	{
		percentcompleted = ((1.0f-(float)allgaps/filesize)) * 100;
		completedsize = (uint32)((filesize-(allgaps+1)));
	} else {percentcompleted = 100; completedsize=filesize;}

d1312 1
a1312 1
		if ( (::GetTickCount() - cur_src->GetLastAskedTime()) > usethisfilereasktime )
d1352 1
a1352 1
			if( ((::GetTickCount() - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
d1447 1
a2058 1
			theApp.downloadqueue->StartNextFile();
a2123 1
	theApp.downloadqueue->StartNextFile();
@


1.5.2.1
log
@updating this branch...
@
text
@@


1.5.2.2
log
@merge bugfixes
@
text
@d998 1
a998 1
	COLORREF crPending = RGB(255, 208, 0);
d1003 2
a1004 1
		crHave = RGB(0, 0, 0);
d1008 1
d1109 1
d1111 1
d1125 1
a1125 1
		s_LoadBar.Fill(crPending);
d1141 1
a1141 1
		dc->FillRect(&gaprect, &CBrush(crPending));
d1150 6
d1322 1
a1322 1
		if ( (GetTickCount() - cur_src->GetLastAskedTime()) > usethisfilereasktime )
d1362 1
a1362 1
			if( ((GetTickCount() - lastpurgetime) > PURGE_TIME) && (GetSourceCount() >= (theApp.glob_prefs->GetMaxSourcePerFile()*.8 )) ){
a1456 1

d2068 1
d2134 1
@


1.5.2.3
log
@updated control panes, and assorted bugfixes
@
text
@d2157 3
a2159 1
	StopFile();		//Cax2 bugfix: hanging sources when deleting file
d2163 1
a2163 1
	//RemoveAllSources(true);		//Cax2 bugfix: hanging sources when deleting file
d3961 1
a3961 1
			else if ( IsCorruptedPart(partNumber))
@


1.4
log
@Preventing complition of more then one file at same time [Lord KiRon]
@
text
@d2091 6
d2199 11
a2210 5
/*	// why double removing???
	theApp.downloadqueue->RemoveFile(this);
	theApp.sharedfiles->RemoveFile(this);
	theApp.emuledlg->transferwnd.downloadlistctrl.RemoveFile(this);
*/
@


1.3
log
@final port to .25b!
@
text
@d32 1
d3704 1
@


1.2
log
@update to .25b codebase
@
text
@d1386 1
a1386 1
			if (!((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME*2))
@


1.1
log
@*** empty log message ***
@
text
@d25 1
d27 4
a30 1
CBarShader CPartFile::s_LoadBar(5); 
d104 1
a104 1
	catch(CString &error){
d127 1
d165 8
a179 1
	m_is_A4AF_auto = false;
d188 3
d258 1
d273 1
d330 1
d333 2
a334 2
					// Added by Tarod for auto-priority
					if (priority == PR_AUTO) 
d336 2
d348 1
d360 3
a362 2
					// safe Load Gaps [SlugFiller]
					if ((!newtag->tag->specialtag) && (newtag->tag->tagname[0] == FT_GAPSTART ||
d378 1
a381 1
					// safe Load Gaps end
d398 1
a398 1
		error->Delete();	//memleak fix
d401 2
a402 1
	// safe Load Gaps [SlugFiller] - Now to flush the map into the list
d407 1
a407 1
    		if (gap->start != -1 && gap->end != -1 && gap->start <= gap->end)
a411 1
	// safe Load Gaps end
d413 1
d418 1
d471 3
a473 1
			theApp.m_FilesHashing.AddToHash(0,directory,m_hpartfile.GetFileName().GetBuffer(),this); // Lord KiRon	
d476 6
d556 1
a556 1
		// Modified by Tarod for DAP
d564 1
a564 1
		// End by Tarod
d612 1
a612 1
	catch(CString &error){
d636 1
a636 1
				theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_FOUNDCORRUPTION),i+1,filename);		
d645 1
d654 1
d658 1
d749 1
a749 1
		if (cur_block->StartOffset == start && cur_block->EndOffset == end)
d758 1
d843 87
d963 3
a965 2
	SavePartFile();
	
d1003 1
a1003 1
			crPending = RGB(255,255,100);
d1060 2
a1061 1
	for (POSITION pos = requestedblocks_list.GetHeadPosition();pos !=  0;requestedblocks_list.GetNext(pos)){ 
d1063 1
a1063 1
		s_ChunkBar.FillRange(block->StartOffset, block->EndOffset,  crPending);
d1110 1
d1113 1
a1113 1
	gaprect.bottom = gaprect.top + 4; 
d1124 1
a1124 1
		s_LoadBar.Fill(crUnconfirmed);
d1149 6
d1260 3
a1262 1
void CPartFile::RemoveNoNeededSources(void)
d1267 2
a1268 1
	for (pos1 = srclist.GetHeadPosition(); (pos2 = pos1) != NULL;) {
d1271 2
a1272 1
		if (cur_src->GetDownloadState() == DS_NONEEDEDPARTS) {
d1274 1
d1279 2
d1287 8
d1315 1
d1337 1
d1361 4
d1367 3
a1369 1
		case DS_NONEEDEDPARTS:{ // doubled reasktime for no needed parts - save connections and traffic
a1372 1
//			if (!((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME*2))
d1376 12
d1393 5
d1404 1
a1404 2
//			if (theApp.serverconnect->IsConnected() && ((!cur_src->GetLastAskedTime()) || (::GetTickCount() - cur_src->GetLastAskedTime()) > FILEREASKTIME))
			//Vorlost for Expanded FILEREASKTIME if QR is known and 3/4 Sockets are open 
d1406 2
d1414 2
d1424 6
d1433 3
a1435 3
		if (IsA4AFAuto()) {
			theApp.emuledlg->transferwnd.downloadlistctrl.DownloadAllA4AF(this);
		}
d1438 1
d1453 1
d1460 3
d1478 2
a1479 2
		if(!m_bLoadedSourcesCompletely && theApp.serverconnect->IsConnected()
			&& theApp.listensocket->GetOpenSockets() < theApp.glob_prefs->GetMaxConnections()-20-RESTORE_SOURCES_AT_ONCE) // Vorlost
a1483 1
				//RemoveNoNeededSources();
d1485 6
a1490 1
					RemoveNoNeededSources();
d1502 2
a1503 1
				&& theApp.listensocket->GetOpenSockets() < theApp.glob_prefs->GetMaxConnections()-20-RESTORE_SOURCES_AT_ONCE) // Vorlost
d1516 5
a1520 1
				RemoveNoNeededSources();
d1541 1
d1568 8
d1602 1
a1602 1
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("Debug: %i sources received, %i low id dropped, %i possible sources"),count,debug_lowiddropped,debug_possiblesources));
d1637 4
a1640 1
	#define BLOCKCOUNT 3 
d1642 1
d1655 3
d1661 1
d1726 98
d1832 1
a1832 1
				if (newblockcount == BLOCKCOUNT)
d1868 1
a1868 1
void  CPartFile::BlockReceived(uint32 start,uint32 end, char* blockdata,uint32 transferedsize)
d1870 1
a1870 78
	EMULE_TRY

	// TODO buffer blocks to decrease hd access
	RemoveBlockFromList(start,end);
	if (IsComplete(start,end))
		return;
	try{

		if (m_hpartfile.GetLength() < end+1)
			m_hpartfile.SetLength(end+1);
		m_hpartfile.Seek(start,0);
		m_hpartfile.Write(blockdata,(end-start)+1);
		uint16 partnumber = (uint16)floor((float)start/PARTSIZE);		
		uint32 length = PARTSIZE;
		if (PARTSIZE*(partnumber+1) > m_hpartfile.GetLength())
			length = (m_hpartfile.GetLength()- (PARTSIZE*partnumber));		
		m_hpartfile.Flush(); // Enabled again by DonGato (Removed by Tarod)

		FillGap(start,end);

		if (transferedsize) 
			transfered += transferedsize;
		else
			 transfered += (end-start)+1;

		// if this part is complete or was corrupted check the hash

	
		if (IsComplete(PARTSIZE*partnumber,(PARTSIZE*(partnumber+1))-1)){
			if (!HashSinglePart(partnumber)){
				theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_PARTCORRUPT),partnumber,GetFileName());
				AddGap(PARTSIZE*partnumber,(PARTSIZE*partnumber+length)-1);
				corrupted_list.AddTail(partnumber);
			}
			else{
				if (status == PS_EMPTY){
					status = PS_READY;
					theApp.sharedfiles->SafeAddKFile(this);
				}
			}
		}
		else if (IsCorruptedPart(partnumber) && theApp.glob_prefs->IsICHEnabled()){
			if (HashSinglePart(partnumber)){
				FillGap(PARTSIZE*partnumber,(PARTSIZE*partnumber+length)-1);
				RemoveBlockFromList(PARTSIZE*partnumber,(PARTSIZE*partnumber+length)-1);
				theApp.emuledlg->AddLogLine(true,GetResString(IDS_ICHWORKED),partnumber,GetFileName());
			}
		}
		
		if (gaplist.IsEmpty())		//file complete
			CompleteFile(false);	
	}
	catch(CFileException* error){
		OUTPUT_DEBUG_TRACE();
		if(theApp.glob_prefs->IsErrorBeepEnabled()) Beep(800,200);

		if (error->m_cause == CFileException::diskFull) {
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_OUTOFSPACE),GetFileName());
			if (theApp.glob_prefs->GetNotifierPopOnImportantError()) {
				CString msg;
				msg.Format(GetResString(IDS_ERR_OUTOFSPACE),GetFileName());
				theApp.emuledlg->ShowNotifier(msg, TBN_IMPORTANTEVENT, false);
			}
		}else{
			char buffer[150];
			error->GetErrorMessage(buffer,150);
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_WRITEERROR),GetFileName(),buffer);
			status = PS_ERROR;
		}
		paused = true;
		datarate = 0;
		transferingsrc = 0;
	
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		error->Delete();
	}

	EMULE_CATCH
d1873 1
a1873 1
void CPartFile::CompleteFile(bool hashingdone) // Lord KiRon - using threads now
d1877 3
d1881 1
a1881 2
	if (!hashingdone)
	{
d1885 3
a1887 1
		theApp.m_FilesHashing.AddToHash(0,tempdir,partfileb,this); // Lord KiRon
d1890 3
a1892 2
	} else {
		StopFile(); // Cax2 minifix!
d1905 3
a1907 2
void  CPartFile::RemoveAllSources(bool bTryToSwap)
{
d1910 52
a1961 11
	//TODO transfer sources to other downloading files if possible
	POSITION pos1,pos2;
	for( pos1 = srclist.GetHeadPosition(); ( pos2 = pos1 ) != NULL; ){
		srclist.GetNext(pos1);
		if (bTryToSwap){
			if (!srclist.GetAt(pos2)->SwapToAnotherFile(true))
				theApp.downloadqueue->RemoveSource(srclist.GetAt(pos2));
		}
		else
			theApp.downloadqueue->RemoveSource(srclist.GetAt(pos2));
	}
d1963 12
a1974 2
	EMULE_CATCH
}
d1976 32
a2007 3
void CPartFile::DeleteFile()
{
	EMULE_TRY
d2009 8
a2016 3
	ASSERT ( !m_bPreviewing );
	theApp.emuledlg->transferwnd.downloadlistctrl.HideSources(this); // cax2 closefile bugfix
	RemoveAllSources(true);
d2018 153
a2170 1
	if (m_hpartfile != INVALID_HANDLE_VALUE) m_hpartfile.Close();
d2193 1
d2197 1
d2211 1
a2211 1
	else if(!GetPartHash(partnumber)){
d2512 7
d2523 6
a2528 1
	priority = np;
d2539 3
d2634 31
d2682 7
d2721 5
d2865 1
d2879 15
d3446 3
a3451 3
		if(m_stscrStoringSources == NULL) // i_a: re-enabled and relocated code. Needed badly here to prevent crash. 
			return false; // i_a: re-enabled & relocated. 

d3694 2
a3695 2
// Lord KiRon - using threads for file completion
BOOL CPartFile::PerformFileComplete(void) 
d3699 11
a3709 51
	CSingleLock(&m_FileCompleteMutex,TRUE); // will be unlocked on exit
	char* partfilename = nstrdup(fullname);
	partfilename[strlen(fullname)-4] = 0;
	char* newfilename = nstrdup(GetFileName());
	strcpy(newfilename, (LPCTSTR)theApp.StripInvalidFilenameChars(newfilename));
	char* newname = new char[strlen(newfilename)+strlen(theApp.glob_prefs->GetIncomingDir())+MAX_PATH];
	sprintf(newname,"%s\\%s",theApp.glob_prefs->GetIncomingDir(),newfilename);
	
	// close permanent handle
	if (m_hpartfile != INVALID_HANDLE_VALUE) m_hpartfile.Close();
	
	bool renamed = false;
	if(PathFileExists(newname))
	{
		renamed = true;
		int namecount = 0;
		
		size_t length = strlen(newfilename);
		ASSERT(length != 0); //name should never be 0
		
		//the file extension
		char *ext = strrchr(newfilename, '.');
		if(ext == NULL)
			ext = newfilename + length;
		
		char *last = ext;  //new end is the file name before extension
		last[0] = 0;  //truncate file name
		
		//search for matching ()s and check if it contains a number
		if((ext != newfilename) && (strrchr(newfilename, ')') + 1 == last))
		{
			char *first = strrchr(newfilename, '('); 
            
            if(first != NULL)
            {
            	first++;
            	bool found = true;
            	for(char *step = first; step < last - 1; step++)
            		if(*step < '0' || *step > '9')
            		{
            			found = false;
            			break;
            		}
            	if(found)
            	{
            		namecount = atoi(first);
            		last = first - 1;
            		last[0] = 0;  //truncate again
            	}
            }
		} 
d3711 3
a3713 12
		CString strTestName;
		do
		{ 
        	namecount++; 
            strTestName.Format("%s\\%s(%d).%s", theApp.glob_prefs->GetIncomingDir(), 
               				   newfilename, namecount, min(ext + 1, newfilename + length)); 
        }
        while(PathFileExists(strTestName));
        	delete[] newname;
        newname = nstrdup(strTestName);
	} 
    delete newfilename; 
d3715 2
a3716 177
	// Lord KiRon
	BOOL bSlowComplete   =   theApp.glob_prefs->SlowComplete();
	int  BlockSize   =   theApp.glob_prefs->SlowCompleteBlockSize()*1024; 
       
    // we do this only if SlowComplete enabled 
    // AND the files are on the different HDs (paratitions) - check by the drive leter 
    // AND any of path is not in URL/Network format (has : as second leter) 
    if (bSlowComplete && (_toupper(partfilename[0]) != _toupper(newname[0]) && partfilename[1] == _T(':') 
         && newname[1] == _T(':'))) 
    {
    	CFile fInputFile; 
        CFile fOutputFile; 
        try 
        { 
      		CString strTempNew   =   CString(newname); 
            strTempNew += _T(".$$$"); 
            // We going to write everithing into the temporary file at same place the newname located 
            // and after we finished - rename , this will take care of syncronization problem with SharedFiles 
            if (!fInputFile.Open(partfilename,CFile::modeRead | CFile::shareDenyNone | CFile::typeBinary 
                | CFile::osSequentialScan)) 
            { 
               	// let catch to care about closing everything 
               	throw CString(_T(GetResString(IDS_ERR_SLOWREAD)+" ("+partfilename+")"));
               	return FALSE; 
            } 
            if (!fOutputFile.Open(strTempNew,CFile::modeWrite | CFile::shareExclusive | CFile::osSequentialScan | CFile::modeCreate)) 
            { 
            	fInputFile.Close(); 
            	// let catch to care about closing everything 
				throw CString(_T(GetResString(IDS_ERR_SLOWWRITE)+" ("+strTempNew+")"));
               	return FALSE; 
            } 

            DWORD dwRead = 0; 
            char *buffer = new char[BlockSize]; 
            if (!buffer) 
            { 
               	// let catch to care about closing everything 
               	throw CString(_T(GetResString(IDS_ERR_OUTMEM))); 
               	return FALSE; 
            } 

            // Most of the work done here 
            // just copy the file data from one to another 
            do 
            { 
            	dwRead = fInputFile.Read(buffer, BlockSize ); 
               	fOutputFile.Write(buffer, dwRead); 
               	Sleep(0); // release the CPU for other processes 
               	// may be real sleep needed here , not sure 
            } 
            while (dwRead > 0); 
            delete []buffer; 

            fInputFile.Close(); 
            fOutputFile.Close(); 
            // Rename temporary file back to normal name 
            if (rename(strTempNew,newname))
            { 
            	// let catch to care about closing everything 
               	throw CString(_T(GetResString(IDS_ERR_RENFAIL))); 
               	return FALSE; 
            }
            CFile::Remove(partfilename); // This removes old Part file
		} 
        catch(CString &str) 
        { 
         	delete[] partfilename; 
            delete[] newname; 
            theApp.emuledlg->AddLogLine(true,str); 
            paused = true; 
            status = PS_ERROR; 
            return FALSE; 
        } 
        catch(...) 
        { 
            delete[] partfilename; 
            delete[] newname; 
            theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
            paused = true; 
            status = PS_ERROR; 
            return FALSE; 
        } 
	} else {
		if (rename(partfilename,newname))
		{ 
        	delete[] partfilename; 
            delete[] newname; 
            theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_COMPLETIONFAILED),GetFileName()); 
            paused = true; 
            status = PS_ERROR; 
            return FALSE; 
        }
	} 
    // Lord KiRon - end
       
    if (remove(fullname)) 
    	theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_DELETEFAILED),fullname); 

    //////////////////////////////// 
    //remove *.src file (thx to brotbuexe) 
 	CString srcName="";
 	srcName.Format("%s\\%s.stsrc",tempdir,GetPartMetFileName());
 	if (remove(srcName))
 	if (errno != ENOENT)
 		theApp.emuledlg->AddLogLine(true,GetResString(IDS_FAILDELETE),srcName); 
    
	// Tarod - erase .backup file
	srcName.Format("%s\\%s.bak", theApp.glob_prefs->GetTempDir(), this->GetPartMetFileName());
	if (remove(srcName))
		if (errno != ENOENT)
			theApp.emuledlg->AddLogLine(true, GetResString(IDS_FAILDELETE),srcName);

	//--- xrmb:keepPartFileStats ---
	//--- remove the stats file ---
	RemovePartFileStats();
	//--- :xrmb ---

    delete[] partfilename; 
    delete[] fullname; 
    fullname = newname; 
    delete[] directory; 
    directory = nstrdup(theApp.glob_prefs->GetIncomingDir()); 
    status = PS_COMPLETE; 
    paused = false; 
    theApp.emuledlg->AddLogLine(true,GetResString(IDS_DOWNLOADDONE),GetFileName()); 
    theApp.emuledlg->ShowNotifier(GetResString(IDS_TBN_DOWNLOADDONE)+"\n"+GetFileName(), TBN_DLOAD); 
    if (renamed) 
    	theApp.emuledlg->AddLogLine(true, GetResString(IDS_DOWNLOADRENAMED), strrchr(newname, '\\') + 1); 
    theApp.knownfiles->SafeAddKFile(this); 

    // Added to change UAP to Normal after finished download of file by Tarod 
    if (CKnownFile::IsAutoPrioritized())
    { 
    	CKnownFile::SetAutoPriority(false); 
        CKnownFile::SetPriority(PR_NORMAL); 
    } 
    // End Tarod 

    theApp.downloadqueue->RemoveFile(this); 
    theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this); 

    // Added by Tarod (starts next paused file) 
    if (theApp.glob_prefs->DownloadPausedOnComplete())
    { 
    	theApp.downloadqueue->StartPausedDownload() ; 
    } 
   	return TRUE; 

	EMULE_CATCH

   	return FALSE; 
} 

// Used as separate thread to complete file [Lord KiRon]
UINT CPartFile::CompleteThreadProc(CPartFile* pFile) 
{ 
	EMULE_TRY

	if ( !pFile ) 
   	{ 
    	return -1; 
   	} 
   	pFile->PerformFileComplete(); 
   	return 0; 

	EMULE_CATCH

   	return -1; 
}

bool CPartFile::IsVLCInstalled() 
{ 
	EMULE_TRY

	CFileFind ff;
	CString searchpath(theApp.glob_prefs->GetVlcDir());
d3751 2
d3755 3
a3757 1
	((CKnownFile*)this)->SetMovieMode(Mode);
d3762 2
d3766 2
d3770 304
@

