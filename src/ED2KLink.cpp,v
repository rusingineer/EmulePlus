head	1.36;
access;
symbols
	PublicRelease_1_2e:1.31
	Interim_Release_1-2e_RC1:1.31
	PublicRelease_1_2d:1.31
	Interim_Release_1-2d_RC1:1.31
	Interim_Release_1-2d_beta1:1.31
	PublicRelease_1_2c:1.28
	Interim_Release_1-2c_RC1:1.28
	Interim_Release_1-2c_beta1:1.27
	PublicRelease_1_2b:1.27
	Interim_Release_1-2b_RC1:1.27
	PublicRelease_1_2a:1.25
	Interim_Release_1-2a_RC1:1.25
	Interim_Release_1-2a_beta2:1.23
	Interim_Release_1-2a_beta1:1.23
	PublicRelease_1_2:1.23
	Interim_Release_1-2_RC1:1.23
	Interim_Release_1-2_beta1:1.23
	PublicRelease_1_1g:1.23
	Interim_Release_1-1g_RC3:1.23
	Interim_Release_1-1g_RC2:1.23
	Interim_Release_1-1g_RC1:1.23
	Interim_Release_1-1g_beta2:1.23
	Interim_Release_1-1g_beta1:1.22
	PublicRelease_1_1f:1.22
	Interim_Release_1-1f_RC1:1.22
	PublicRelease_1_1e:1.21
	Interim_Release_1-1e_RC2:1.21
	Interim_Release_1-1e_RC1:1.21
	Interim_Release_1-1e_beta1:1.21
	PublicRelease_1_1d:1.21
	Interim_Release_1-1d_RC1:1.21
	PublicRelease_1_1c:1.21
	Interim_Release_1-1c_RC1:1.21
	Interim_Release_1-1c_beta2:1.21
	Interim_Release_1-1c_beta1:1.21
	PublicRelease_1_1b:1.19
	Interim_Release_1-1b_RC1:1.19
	PublicRelease_1_1a:1.19
	Interim_Release_1-1a_RC2:1.19
	Interim_Release_1-1a_RC1:1.19
	Interim_Release_1-1a_beta2:1.19
	Interim_Release_1-1a_beta1:1.19
	PublicRelease_1_1:1.19
	Interim_Release_1-1_beta1:1.19
	PublicRelease_1o:1.19
	Interim_Release_1o_RC1:1.19
	Interim_Release_1o_beta1:1.19
	PublicRelease_1n:1.19
	Interim_Release_1n_RC2:1.19
	Interim_Release_1n_RC1:1.19
	Interim_Release_1n_beta2:1.19
	Interim_Release_1n_beta1:1.19
	PublicRelease_1m:1.19
	Interim_Release_1m_beta1:1.19
	PublicRelease_1l:1.19
	Interim_Release_1l_RC3:1.18
	Interim_Release_1l_RC2:1.18
	Interim_Release_1l_RC1:1.18
	Interim_Release_1l_beta2:1.18
	Interim_Release_1l_beta1:1.18
	PublicRelease_1k:1.18
	Interim_Release_1k_RC4:1.18
	Interim_1k_RC3:1.18
	Interim_1k_RC2:1.18
	Interim_Release_1k_RC1:1.18
	Interim_Release_1k_beta5:1.18
	Intrerim_Release_1k_beta4:1.18
	Interim_Release_1k_beta1:1.18
	PublicRelease_1j:1.16
	Interim_Release_1J_RC3:1.16
	Interim_Release_1j_RC3:1.16
	Interim_Release_1j_RC2:1.16
	Interim_Release_1j_RC1:1.16
	Interim_Release_1j_beta2:1.16
	Interim_Release_1j_beta1:1.16
	PublicRelease_1i:1.16
	Interim_Release_1i_RC6:1.16
	Interim_Release_1i_RC3:1.16
	Interim_Release_1i_RC2:1.16
	Interim_Release_1i_RC1:1.16
	Interim_Release_1i_beta3:1.16
	Interim_Release_1i_beta2:1.16
	Interim_Release_1i_beta1:1.15
	PublicRelease_1h:1.13
	Interim_Release_1h_rc2:1.13
	Interim_Release_1h_RC1:1.13
	Interim_Release_1h_beta2:1.13
	Interim_Release_1h_beta1_now:1.13
	Interim_Release_1h_beta1:1.13
	PublicRelease_1g:1.13
	Interim_Release_1g_RC6_Final:1.13
	Interim_Release_1g_RC6:1.13
	Interim_Release_1g_RC5:1.13
	Interim_Release_1g_RC4:1.13
	Interim_Release_1g_RC3:1.13
	Interim_Release_1g_beta2:1.9
	Interim_Release_1g_beta1:1.9
	Interim_Release_1f_RC4:1.8
	Interim_Release_1f_RC3:1.8
	Interim_Release_1f_RC2:1.8
	Interim_Release_1f_RC:1.8
	Interim_Release_1f_beta2:1.8
	Interim_Release_1f_beta1:1.7
	PublicRelease_1e:1.6
	Interim_Release_1e_RC2:1.6
	Interim_Release_1e_RC:1.6
	Interim_Release_1e_beta3:1.6
	Interim_Release_1e_beta2:1.6
	Interim_Release_1e_beta2_before_kuchin:1.6
	Interim_Release_1e_beta1:1.6
	PublicRelease_1c:1.6
	featurestest:1.6.0.2
	Interim_Release_1c_RC:1.6
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.4
	Interim_Release_1b_beta2:1.4
	Interim_Release_1b_beta1:1.4
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.36
date	2010.08.14.16.54.03;	author aw3;	state Exp;
branches;
next	1.35;

1.35
date	2010.08.11.04.39.39;	author aw3;	state Exp;
branches;
next	1.34;

1.34
date	2009.10.22.05.38.53;	author aw3;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2009.05.16.22.15.21;	author aw3;	state Exp;
branches;
next	1.31;

1.31
date	2007.12.19.21.03.46;	author aw3;	state Exp;
branches;
next	1.30;

1.30
date	2007.12.05.22.01.38;	author eklmn;	state Exp;
branches;
next	1.29;

1.29
date	2007.12.01.10.38.06;	author eklmn;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.27.06.21.19;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.17.07.48.14;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.25;

1.25
date	2006.09.05.01.10.46;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.09.05.41.18;	author aw3;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.26.04.31.24;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2005.07.13.04.15.10;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.27.17.48.21;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.26.21.23.22;	author syrus77;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.10.22.04.19;	author netwolf1;	state Exp;
branches;
next	1.18;

1.18
date	2004.02.14.21.35.25;	author kush_eplus;	state Exp;
branches;
next	1.17;

1.17
date	2004.02.13.02.00.14;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.20.13.19.59;	author morevit;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.24.20.44.22;	author double_t;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.28.08.30.17;	author partyckip;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.22.19.32.28;	author partyckip;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.15.09.09.28;	author partyckip;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.27.05.09.39;	author partyckip;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.08.17.08.25;	author netwolf1;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.30.11.37.54;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.22.10.57.55;	author cax2;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2003.03.22.10.22.23;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.05.11.23.43;	author recdvst;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.03.22.09.45;	author moosetea;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.05;	author cax2;	state Exp;
branches;
next	;

1.6.2.1
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Do some filtering for the string passed from the browser {eeeeh}.
@
text
@//this file is part of eMule
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#include "stdafx.h"
#include "otherfunctions.h"
#include "ED2KLink.h"
#include "emule.h"
#include "StringConversion.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


namespace {
	struct autoFree {
		autoFree(TCHAR* p) : m_p(p) {}
		~autoFree() { free(m_p); }
	private:
		TCHAR * m_p;
	};
}

CED2KLink::~CED2KLink()
{
}

/////////////////////////////////////////////
// CED2KServerListLink implementation
/////////////////////////////////////////////
CED2KServerListLink::CED2KServerListLink(const CString &strAddress) : m_strAddress(strAddress)
{
}

CED2KServerListLink::~CED2KServerListLink()
{
}

void CED2KServerListLink::GetLink(CString& lnk) const
{
	lnk.Format(_T("ed2k://|serverlist|%s|/"), m_strAddress);
}

CED2KServerListLink* CED2KServerListLink::GetServerListLink()
{
	return this;
}

CED2KLink::LinkType CED2KServerListLink::GetKind() const
{
	return kServerList;
}

/////////////////////////////////////////////
// CED2KServerLink implementation
/////////////////////////////////////////////
CED2KServerLink::CED2KServerLink(const CString &strAddr, const TCHAR *port) : m_strAddress(strAddr)
{
	unsigned long ul = _tcstoul(port, 0, 10);
	if ((ul > 0xFFFF) || (ul == 0))
		throw GetResString(IDS_ERR_BADPORT);
	m_uPort = static_cast<uint16>(ul);
	m_strDefName.Format(_T("Server %s:%s"), strAddr, port);
}

CED2KServerLink::~CED2KServerLink()
{
}

void CED2KServerLink::GetLink(CString& lnk) const
{
	lnk.Format(_T("ed2k://|server|%s|%u|/"), m_strAddress, m_uPort);
}

CED2KServerLink* CED2KServerLink::GetServerLink()
{
	return this;
}

CED2KLink::LinkType CED2KServerLink::GetKind() const
{
	return kServer;
}

///////////////////////////////////////////// 
// CED2KSearchLink implementation 
///////////////////////////////////////////// 
CED2KSearchLink::CED2KSearchLink(const CString &strSearchTerm) : m_strSearchTerm(strSearchTerm)
{
	m_strSearchTerm.Remove(_T('&'));
	m_strSearchTerm.Remove(_T('!'));
	m_strSearchTerm.Remove(_T('?'));
	m_strSearchTerm.Replace(_T('+'), _T(' '));
	m_strSearchTerm.Trim();
}

CED2KSearchLink::~CED2KSearchLink()
{
} 

void CED2KSearchLink::GetLink(CString& lnk) const
{
	lnk.Format(_T("ed2k://|search|%s|/"), Ed2kURIEncode(m_strSearchTerm));
}

CED2KSearchLink* CED2KSearchLink::GetSearchLink()
{
	return this;
}

CED2KLink::LinkType CED2KSearchLink::GetKind() const
{
	return (m_strSearchTerm.IsEmpty()) ? kInvalid : kSearch;
}

/////////////////////////////////////////////
// CED2KFileLink implementation
/////////////////////////////////////////////
CED2KFileLink::CED2KFileLink(const CString &strName, const TCHAR *pcSize, const CString &strHash, const CStringArray &astrParams, const TCHAR *pcSources)
: m_strName(strName)
{
	uint64	qwSz = _tstoi64(pcSize);

	if (qwSz > MAX_EMULE_FILE_SIZE)
		throw GetResString(IDS_ERR_TOOLARGEFILE);
	m_qwSize = qwSz;

	if (md4cmp0(StringToHash(strHash, m_hash)) == 0)
		throw GetResString(IDS_ERR_ILLFORMEDHASH);

	m_strName.Trim();
	if (m_strName.IsEmpty())
		throw GetResString(IDS_ERR_LINKERROR);

	ClientSourcesList = NULL;
	m_bAICHHashValid = false;

	for (int i = 0; i < astrParams.GetCount(); i++)
	{
		const CString	&strParam = astrParams.GetAt(i);
		int	iPos = strParam.Find(_T('='));
		const TCHAR	*pcHash;

		if (iPos < 0)
			continue;
		if ((iPos == CSTRLEN(_T("h"))) && (*strParam.GetString() == _T('h')))
		{
			pcHash = &strParam.GetString()[iPos + 1];
			if (*pcHash != 0)
			{
				if (DecodeBase32(pcHash, strParam.GetLength() - CSTRLEN(_T("h=")), m_abyteAICHHash, SHA_HASHSIZE) == SHA_HASHSIZE)
					m_bAICHHashValid = true;
			}
		}
	}

	if (pcSources)
	{
		TCHAR* pNewString = _tcsdup(pcSources);
		autoFree liberator(pNewString);
		TCHAR* pCh = pNewString;
		TCHAR* pEnd;
		TCHAR* pIP;
		TCHAR* pPort;

		bool bAllowSources;
		TCHAR date[3];
		COleDateTime expirationDate;
		int nYear, nMonth, nDay;

		uint32	dwIP, dwHybridID, dwCount = 0;
		uint16	uPort;
		unsigned long ul;

		int nInvalid = 0;

		pCh = stristr(pCh, _T("sources"));
		if (pCh != NULL)
		{
			pCh = pCh + CSTRLEN(_T("sources")); // point to char after "sources"
			pEnd = pCh;
			while (*pEnd != _T('\0'))
				pEnd++;	//	Make pEnd point to the terminating NULL

			bAllowSources = true;
			// if there's an expiration date...
			if( *pCh == _T('@@') && (pEnd-pCh) > 7 )
			{
				pCh++; // after '@@'
				date[2] = 0; // terminate the two character string
				date[0] = *(pCh++); date[1] = *(pCh++);
				nYear = _tcstol( date, 0, 10 ) + 2000;
				date[0] = *(pCh++); date[1] = *(pCh++);
				nMonth = _tcstol( date, 0, 10 );
				date[0] = *(pCh++); date[1] = *(pCh++);
				nDay = _tcstol( date, 0, 10 );
				bAllowSources = ( expirationDate.SetDate(nYear,nMonth,nDay) == 0 );
				if (bAllowSources)
					bAllowSources=(COleDateTime::GetCurrentTime() < expirationDate);
			}

			// increment pCh to point to the first "ip:port" or "address" and check for sources
			if ( bAllowSources && ++pCh < pEnd )
			{
				ClientSourcesList = new CTypedPtrList<CPtrList, CClientSource*>(); //<<-- enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
				// for each "ip:port"/"name:port" source string until the end
				// limit max number to protect against surprisingly long links
				while (*pCh != 0 && (dwCount < 512))
				{
					pIP = pCh;
					// find the end of this ip:port string & start of next ip:port string.
					if ((pCh = _tcschr(pCh, _T(','))) != NULL)
					{
						*pCh = 0; // terminate current "ip:port"/"name:port"
						pCh++;    // point to next "ip:port"/"name:port"
					}
					else
						pCh = pEnd;

					// if port is not present for this ip/name, go to the next ip/name.
					if( (pPort = _tcschr(pIP, _T(':'))) == NULL )
					{
						nInvalid++;	continue;
					}

					*pPort = 0;     // terminate ip/name string
					pPort++;	// point pPort to port string.

					dwIP = inet_addr( pIP );
					// START enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
					ul = _tcstoul( pPort, 0, 10 );
					uPort = static_cast<uint16>(ul);

					// skip bad ports
					if (ul > 0xFFFF || ul == 0)
					{
						nInvalid++;
						continue;
					}

					CClientSource* newsource = new CClientSource;
				//	could it be a hostname? We will assume this for later checking...
					if (dwIP == INADDR_NONE)
					{
						if (_tcslen(pIP) >= ARRSIZE(newsource->sourceHostname))
						{
							nInvalid++;
							delete newsource;
							continue;
						}
						newsource->sourceType = ED2KLINK_SOURCE_HOSTNAME;
						_tcscpy(newsource->sourceHostname, pIP);   //save hostname
					}
					else
					{
						dwHybridID = fast_ntohl(dwIP);
						if(IsLowID(dwHybridID))
						{
							nInvalid++;
							delete newsource;
							continue;
						}
						newsource->sourceType = ED2KLINK_SOURCE_IP;
						newsource->dwSrcIDHybrid = dwHybridID;
					}
					newsource->sourcePort = uPort; //save port
					md4cpy(newsource->filehashkey, m_hash); //save file hash

					ClientSourcesList->AddTail(newsource);
					dwCount++;
				}
				if (dwCount == 0)
				{
					delete ClientSourcesList;
					ClientSourcesList = NULL;
				}
				// END enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
			}
		}
	}
}


CED2KFileLink::~CED2KFileLink()
{
	delete ClientSourcesList;
	ClientSourcesList = NULL;
}

void CED2KFileLink::GetLink(CString& lnk) const
{
	TCHAR	acHashStr[MAX_HASHSTR_SIZE];

	lnk.Format(_T("ed2k://|file|%s|%I64u|%s|/"), Ed2kURIEncode(m_strName), m_qwSize, md4str(m_hash, acHashStr));
}

CED2KFileLink* CED2KFileLink::GetFileLink()
{
	return this;
}

CED2KLink::LinkType CED2KFileLink::GetKind() const
{
	return kFile;
}

CED2KLink* CED2KLink::CreateLinkFromUrl(const CString &strURI)
{
	CString strURIDecoded = URLDecode(strURI);
	int iPos = 0;
	CString strTok = strURIDecoded.Tokenize(_T("|"), iPos);

	if (strTok.CompareNoCase(_T("ed2k://")) == 0)
	{
		strTok = strURIDecoded.Tokenize(_T("|"), iPos);
		if (strTok.CompareNoCase(_T("file")) == 0)
		{
			CString	strName = strURIDecoded.Tokenize(_T("|"), iPos);
			if (!strName.IsEmpty())
			{
				CString	strSize = strURIDecoded.Tokenize(_T("|"), iPos);
				if (!strSize.IsEmpty())
				{
					CString	strHash = strURIDecoded.Tokenize(_T("|"), iPos);
					if (!strHash.IsEmpty())
					{
						CStringArray astrEd2kParams;
						bool bEmuleExt = false, bLastTokSlash = false;
						CString	strEmuleExt;

						for (;;)
						{
							strTok = strURIDecoded.Tokenize(_T("|"), iPos);
							if (strTok.IsEmpty())
								break;

							if (strTok == _T("/"))
							{
								bLastTokSlash = true;
								if (bEmuleExt)
									break;
								bEmuleExt = true;
							}
							else
							{
								bLastTokSlash = false;
								if (bEmuleExt)
								{
									if (!strEmuleExt.IsEmpty())
										strEmuleExt += _T('|');
									strEmuleExt += strTok;
								}
								else
									astrEd2kParams.Add(strTok);
							}
						}

						if (bLastTokSlash)
							return new CED2KFileLink(strName, strSize, strHash, astrEd2kParams, strEmuleExt.IsEmpty() ? (LPCTSTR)NULL : (LPCTSTR)strEmuleExt);
					}
				}
			}
		}
		else if (strTok.CompareNoCase(_T("serverlist")) == 0)
		{
			strTok = strURIDecoded.Tokenize(_T("|"), iPos);	//	URL
			if (!strTok.IsEmpty() && strURIDecoded.Tokenize(_T("|"), iPos) == _T("/"))
				return new CED2KServerListLink(strTok);
		}
		else if (strTok.CompareNoCase(_T("server")) == 0)
		{
			strTok = strURIDecoded.Tokenize(_T("|"), iPos);	//	Server
			if (!strTok.IsEmpty())
			{
				CString	strPort = strURIDecoded.Tokenize(_T("|"), iPos);
				if (!strPort.IsEmpty() && strURIDecoded.Tokenize(_T("|"), iPos) == _T("/"))
					return new CED2KServerLink(strTok, strPort);
			}
		}
		else if (strTok.CompareNoCase(_T("search")) == 0)
		{
			strTok = strURIDecoded.Tokenize(_T("|"), iPos);
			// might be extended with more parameters in future versions
			if (!strTok.IsEmpty() && !strURIDecoded.Tokenize(_T("|"), iPos).IsEmpty())
				return new CED2KSearchLink(strTok);
		}
	}

	throw GetResString(IDS_ERR_LINKERROR);
	return NULL;
}
@


1.35
log
@Added search ed2k link support (from original) {eeeeh}; Simplified class implementation.
@
text
@d104 5
@


1.34
log
@Renamed server link interface services -- IP replaced with address as it's not only IP for DynIP servers (similar to original).
@
text
@d53 1
a53 1
void CED2KServerListLink::GetLink(CString& lnk)
a62 10
CED2KServerLink* CED2KServerListLink::GetServerLink()
{
	return 0;
}

CED2KFileLink* CED2KServerListLink::GetFileLink()
{
	return 0;
}

d73 1
a73 1
	unsigned long ul = _tcstoul(port,0,10);
d84 1
a84 1
void CED2KServerLink::GetLink(CString& lnk)
d89 1
a89 1
CED2KServerListLink* CED2KServerLink::GetServerListLink()
d91 1
a91 1
	return 0;
d94 9
a102 1
CED2KServerLink* CED2KServerLink::GetServerLink()
a103 1
	return this;
d106 1
a106 1
CED2KFileLink* CED2KServerLink::GetFileLink()
d108 5
a112 1
	return 0;
d115 1
a115 1
CED2KLink::LinkType CED2KServerLink::GetKind() const
d117 1
a117 1
	return kServer;
d120 4
d299 1
a299 1
void CED2KFileLink::GetLink(CString& lnk)
a305 10
CED2KServerListLink* CED2KFileLink::GetServerListLink()
{
	return 0;
}

CED2KServerLink* CED2KFileLink::GetServerLink()
{
	return 0;
}

d389 7
@


1.33
log
@Fast byte swap for ntohl and ntohs.
@
text
@d81 1
a81 1
CED2KServerLink::CED2KServerLink(const CString &strIP, const TCHAR *port) : m_strIP(strIP)
d87 1
a87 1
	m_strDefName.Format(_T("Server %s:%s"), strIP, port);
d96 1
a96 1
	lnk.Format(_T("ed2k://|server|%s|%u|/"), m_strIP, m_uPort);
@


1.32
log
@Added AICH hash decoding from the link (just preparation for future - it's not used in anyway).
@
text
@d260 1
a260 1
						dwHybridID = ntohl(dwIP);
@


1.31
log
@Robust case insensitive ed2k link parsing {Avi-3k}.
@
text
@d123 1
a123 1
CED2KFileLink::CED2KFileLink(const CString &strName, const TCHAR *pcSize, const CString &strHash, const TCHAR *pcSources)
d127 1
d140 20
d209 1
a209 1
				ClientSourcesList=new CTypedPtrList<CPtrList, CClientSource*>(); //<<-- enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d373 1
a373 1
							return new CED2KFileLink(strName, strSize, strHash, strEmuleExt.IsEmpty() ? (LPCTSTR)NULL : (LPCTSTR)strEmuleExt);
@


1.30
log
@splited the functions for ed2k link and URL generation
@
text
@d160 2
a161 2
		pCh = _tcsstr( pCh, _T("sources") );
		if( pCh != NULL )
d163 1
a163 1
			pCh = pCh + 7; // point to char after "sources"
d165 4
a168 6
			while( *pEnd )
			{
			//	Make pEnd point to the terminating NULL
				pEnd++;
			}
			bAllowSources=true;
d306 1
a306 1
	if (strTok == _T("ed2k://"))
d309 1
a309 1
		if (strTok == _T("file"))
d357 1
a357 1
		else if (strTok == _T("serverlist"))
d363 1
a363 1
		else if (strTok == _T("server"))
@


1.29
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d279 1
a279 1
	lnk.Format(_T("ed2k://|file|%s|%I64u|%s|/"), URLEncode(m_strName), m_qwSize, md4str(m_hash, acHashStr));
@


1.28
log
@Suppressed level 4 warnings.
@
text
@d20 1
d279 1
a279 1
	lnk.Format(_T("ed2k://|file|%s|%I64u|%s|/"), m_strName, m_qwSize, md4str(m_hash, acHashStr));
a293 1
	m_strName.Replace(_T("%20"),_T(" "));
d304 1
d306 2
a307 1
	CString strTok = strURI.Tokenize(_T("|"), iPos);
d310 1
a310 1
		strTok = strURI.Tokenize(_T("|"), iPos);
d313 1
a313 1
			CString	strName = strURI.Tokenize(_T("|"), iPos);
d316 1
a316 1
				CString	strSize = strURI.Tokenize(_T("|"), iPos);
d319 1
a319 1
					CString	strHash = strURI.Tokenize(_T("|"), iPos);
d328 1
a328 1
							strTok = strURI.Tokenize(_T("|"), iPos);
d361 2
a362 2
			strTok = strURI.Tokenize(_T("|"), iPos);	//	URL
			if (!strTok.IsEmpty() && strURI.Tokenize(_T("|"), iPos) == _T("/"))
d367 1
a367 1
			strTok = strURI.Tokenize(_T("|"), iPos);	//	Server
d370 2
a371 2
				CString	strPort = strURI.Tokenize(_T("|"), iPos);
				if (!strPort.IsEmpty() && strURI.Tokenize(_T("|"), iPos) == _T("/"))
@


1.27
log
@Removed unrequired variable; More realistic limit for max sources in the link;
Fixed check for array boundary when hostname is provided in the link sources;
Renaming and formatting.
@
text
@d196 1
a196 1
					if( pCh = _tcschr(pCh, _T(',')) )
d229 1
a229 1
						if (_tcslen(pIP) >= ELEMENT_COUNT(newsource->sourceHostname))
@


1.26
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d151 1
a151 1
		int nYear,nMonth,nDay;
d153 2
a154 5
		uint16 nHostnameCount = 0; //<<-- enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
		uint16 nCount = 0;
		uint32 dwIP;
		uint32 dwHybridID;
		uint16 nPort;
d191 2
a192 2
				// limit to prevent overflow (uint16 due to CPartFile::AddClientSources)
				while( *pCh != 0 && nCount < MAXSHORT )
d216 1
a216 1
					nPort = static_cast<uint16>(ul);
d229 1
a229 1
						if (_tcslen(pIP) > 512 /*hostsource->hostname*/)
d235 1
a235 1
						newsource->sourceType=ED2KLINK_SOURCE_HOSTNAME;
a236 1
						nHostnameCount++;
d248 1
a248 1
						newsource->dwHybridSourceID = dwHybridID;
d250 1
a250 1
					newsource->sourcePort=nPort; //save port
d254 1
a254 1
					nCount++;
d256 1
a256 1
				if (nCount==0 && nHostnameCount==0)
@


1.25
log
@Large file size support (max file size 512 GB - 1 = 549,755,813,887).
@
text
@d155 2
a156 1
		uint32 dwID;
a157 2
		uint32 dwServerIP = 0;
		uint16 nServerPort = 0;
d216 1
a216 1
					dwID = inet_addr( pIP );
d230 1
a230 1
					if (dwID == INADDR_NONE)
d244 2
a245 2
					//	skip bad ips
						if(dwID < 0x1000000)
d251 2
a252 2
						newsource->sourceType=ED2KLINK_SOURCE_IP;
						newsource->sourceID=dwID; //save ID
a256 2
					newsource->serverIP=dwServerIP;
					newsource->serverPort=nServerPort;
@


1.24
log
@Large file size support preparations; Removed unused #include; Formatting.
@
text
@d126 1
a126 1
	if (qwSz >= static_cast<uint64>(4294967295))
d137 1
a137 1
	ClientSourcesList=NULL; //<<-- enkeyDEV(kei-kun) -hostname sources in ED2K superLink-
d266 1
a266 1
					ClientSourcesList=NULL;
d277 2
a278 2
	if (ClientSourcesList)
		delete ClientSourcesList;
@


1.23
log
@Hash to string conversion is ready for Unicode.
@
text
@d17 1
a18 1
#include "otherfunctions.h"
d80 1
a80 1
CED2KServerLink::CED2KServerLink(const CString &strIP, const TCHAR *port) : m_ip(strIP)
d85 2
a86 2
	m_port = static_cast<uint16>(ul);
	m_defaultName.Format(_T("Server %s:%s"), strIP, port);
d95 1
a95 1
	lnk.Format(_T("ed2k://|server|%s|%u|/"), m_ip, m_port);
d122 2
a123 2
CED2KFileLink::CED2KFileLink(const CString &strName, const TCHAR* size, const CString &strHash, const TCHAR* sources)
: m_name(strName)
d125 1
a125 1
	uint64	qwSz = _tstoi64(size);
d128 1
a128 2

	m_dwSize = static_cast<uint32>(qwSz);
d133 2
a134 2
	m_name.Trim();
	if (m_name.IsEmpty())
d139 1
a139 1
	if (sources)
d141 1
a141 1
		TCHAR* pNewString = _tcsdup(sources);
d285 1
a285 1
	lnk.Format(_T("ed2k://|file|%s|%u|%s|/"), m_name, m_dwSize, md4str(m_hash, acHashStr));
d297 1
d300 1
a300 1
	m_name.Replace(_T("%20"),_T(" "));
@


1.22
log
@Fixed eD2k link parsing when filename contains only spaces (original).
@
text
@d284 1
a284 1
	char hashStr[MAX_HASHSTR_SIZE];
d286 1
a286 2
	md4str(m_hash, hashStr);
	lnk.Format(_T("ed2k://|file|%s|%u|%s|/"), m_name, m_dwSize, hashStr);
@


1.21
log
@More robust ed2k link parser; Fixed localization of ed2k link parsing errors;
Improved string processing; Corrected whitespaces.
@
text
@d134 4
@


1.20
log
@parsing ed2k-links with AICH hash
@
text
@a34 27
	inline unsigned int FromHexDigit(TCHAR digit) {
		switch (digit) {
		case _T('0'): return 0;
		case _T('1'): return 1;
		case _T('2'): return 2;
		case _T('3'): return 3;
		case _T('4'): return 4;
		case _T('5'): return 5;
		case _T('6'): return 6;
		case _T('7'): return 7;
		case _T('8'): return 8;
		case _T('9'): return 9;
		case _T('A'): return 10;
		case _T('B'): return 11;
		case _T('C'): return 12;
		case _T('D'): return 13;
		case _T('E'): return 14;
		case _T('F'): return 15;
		case _T('a'): return 10;
		case _T('b'): return 11;
		case _T('c'): return 12;
		case _T('d'): return 13;
		case _T('e'): return 14;
		case _T('f'): return 15;
		default: throw CString(_T("ill-formed hash"));
		}
	}
d44 1
a44 1
CED2KServerListLink::CED2KServerListLink(const TCHAR* address)
a45 1
	m_address = address;
d54 1
a54 1
	lnk.Format(_T("ed2k://|serverlist|%s|/"), m_address);
d80 1
a80 1
CED2KServerLink::CED2KServerLink(const TCHAR* ip,const TCHAR* port)
a81 1
	m_ip = ip; // netwolf 07.05.03 support non-ip ed2k server link
d83 2
a84 2
	if ( ul > 0xFFFF )
		throw CString(_T("bad port number"));
d86 1
a86 1
	m_defaultName.Format(_T("Server %s:%s"), ip, port);
d95 1
a95 1
	lnk.Format(_T("ed2k://|server|%s|%d|/"), m_ip, static_cast<int>(m_port));
d122 2
a123 3
CED2KFileLink::CED2KFileLink(const TCHAR* name,const TCHAR* size, const TCHAR* hash, const TCHAR* sources)
: m_name(name)
, m_size(size)
d125 3
a127 2
	if ( _tcslen(hash) != 32 )
		throw CString(_T("ill-formed hash"));
d129 1
a129 2
	if (_tstoi64(size)>=4294967295)
		throw CString(_T("file larger than the supported size of the edonkey protocol (>=4GB)"));
d131 2
a132 5
	for ( int idx = 0 ; idx < 16 ; ++idx)
	{
		m_hash[idx] = FromHexDigit(*hash++)*16;
		m_hash[idx] += FromHexDigit(*hash++);
	}
a137 1

d283 1
a283 1
	lnk.Format(_T("ed2k://|file|%s|%s|%s|/"), m_name, m_size, hashStr);
d306 72
d379 3
a381 75
CED2KLink* CED2KLink::CreateLinkFromUrl( const CString& uri)
{
    CString strURI(uri);
    int iPos = 0;
    CString strTok = strURI.Tokenize(_T("|"), iPos);
    if (strTok == _T("ed2k://"))
    {
        strTok = strURI.Tokenize(_T("|"), iPos);
        if (strTok == _T("file"))
        {
            CString strName = strURI.Tokenize(_T("|"), iPos);
            if (!strName.IsEmpty())
            {
                CString strSize = strURI.Tokenize(_T("|"), iPos);
                if (!strSize.IsEmpty())
                {
                    CString strHash = strURI.Tokenize(_T("|"), iPos);
                    if (!strHash.IsEmpty())
                    {
                        CStringArray astrEd2kParams;
                        bool bEmuleExt = false;
                        CString strEmuleExt;

                        CString strLastTok;
                        strTok = strURI.Tokenize(_T("|"), iPos);
                        while (!strTok.IsEmpty())
                        {
                            strLastTok = strTok;
                            if (strTok == _T("/"))
                            {
                                if (bEmuleExt)
                                    break;
                                bEmuleExt = true;
                            }
                            else
                            {
                                if (bEmuleExt)
                                {
                                    if (!strEmuleExt.IsEmpty())
                                        strEmuleExt += _T('|');
                                    strEmuleExt += strTok;
                                }
                                else
                                    astrEd2kParams.Add(strTok);
                            }
                            strTok = strURI.Tokenize(_T("|"), iPos);
                        }

                        if (strLastTok == _T("/"))
                            return new CED2KFileLink(strName, strSize, strHash, strEmuleExt.IsEmpty() ? (LPCTSTR)NULL : (LPCTSTR)strEmuleExt);
                    }
                }
            }
        }
        else if (strTok == _T("serverlist"))
        {
            CString strURL = strURI.Tokenize(_T("|"), iPos);
            if (!strURL.IsEmpty() && strURI.Tokenize(_T("|"), iPos) == _T("/"))
                return new CED2KServerListLink(strURL);
        }
        else if (strTok == _T("server"))
        {
            CString strServer = strURI.Tokenize(_T("|"), iPos);
            if (!strServer.IsEmpty())
            {
                CString strPort = strURI.Tokenize(_T("|"), iPos);
                if (!strPort.IsEmpty() && strURI.Tokenize(_T("|"), iPos) == _T("/"))
                    return new CED2KServerLink(strServer, strPort);
            }
        }
    }

    throw CString(_T("not a well-formed ed2k link"));
    return NULL;
}@


1.19
log
@Removed debug log translations + minor additions + minor change
@
text
@a340 1
//static
d343 20
a362 2
	// Parse pseudo-URI
	const TCHAR* pChArray[7];
d364 24
a387 37
	TCHAR* pNewString = _tcsdup(uri);
	autoFree liberator(pNewString);
	TCHAR* pCh = pNewString;
	const TCHAR* pStart = pCh;
	int idx = 0;
	for (idx=0;idx<7;idx++) pChArray[idx]=NULL;
	idx = 0;
	while( idx <7 && ((pCh = _tcschr(pCh,_T('|'))) !=0) ) {
		pChArray[idx++] = pStart;
		*pCh = 0;
		++ pCh;
		pStart = pCh;
	}
	if ( *pStart != _T('/') ) {
		throw CString(_T("not a well-formed ed2k link"));
	}
	if (   idx < 3
		|| pChArray[0] == 0 
		|| pChArray[1] == 0 
		|| pChArray[2] == 0 
		//		|| pChArray[3] == 0 // This was preventing ed2k serverlist links from working.. 
		|| _tcscmp( _T("ed2k://") , pChArray[0]  ) != 0 
	) {
		throw CString(_T("not a well-formed ed2k link"));
	}
	if ( _tcscmp( _T("file") , pChArray[1]  ) == 0 && idx >=  5 && pChArray[4] != 0 ) {
		return new CED2KFileLink(pChArray[2],pChArray[3],pChArray[4],pChArray[6]);
	}
	else if ( _tcscmp( _T("serverlist") , pChArray[1] ) == 0 && idx == 3 ) {
		return new CED2KServerListLink(pChArray[2]);
	}
	else if ( _tcscmp( _T("server") , pChArray[1]  ) == 0 && idx == 4 ) {
		return new CED2KServerLink(pChArray[2],pChArray[3]);
	}
	else {
		throw CString(_T("not an ED2K server or file link"));
	}
d389 27
a415 2
	throw CString(_T("not a well-formed ed2k link"));
}
@


1.18
log
@few changes and formatting + corrected a previous change that is not working
@
text
@d59 1
a59 1
		default: throw GetResString(IDS_ERR_ILLFORMEDHASH);
d113 1
a113 1
		throw GetResString(IDS_ERR_BADPORT);
d156 1
a156 1
		throw GetResString(IDS_ERR_ILLFORMEDHASH);
d159 1
a159 1
		throw GetResString(IDS_ERR_TOOLARGEFILE);
d361 1
a361 1
		throw CString(GetResString(IDS_ERR_BADED2KLINK));
d370 1
a370 1
		throw GetResString(IDS_ERR_BADED2KLINK);
d382 1
a382 1
		throw GetResString(IDS_ERR_NOSLLINK);
d385 1
a385 1
	throw GetResString(IDS_ERR_BADED2KLINK);
@


1.17
log
@Improved string processing; Optimized hash processings; formatting
@
text
@d161 2
a162 1
	for ( int idx = 0 ; idx < 16 ; ++idx) {
d169 2
a170 1
	if (sources){
d195 2
a196 1
		if( pCh != NULL ) {
d199 5
a203 1
			while( *pEnd ) pEnd++; // make pEnd point to the terminating NULL
d217 2
a218 1
				if (bAllowSources) bAllowSources=(COleDateTime::GetCurrentTime() < expirationDate);
d222 2
a223 1
			if ( bAllowSources && ++pCh < pEnd ) {
d227 2
a228 1
				while( *pCh != 0 && nCount < MAXSHORT ) {
d231 2
a232 1
					if( pCh = _tcschr(pCh, _T(',')) ) {
d241 3
a243 1
					{	nInvalid++;	continue;	}
d254 2
a255 1
					if (ul > 0xFFFF || ul == 0) {
d261 5
a265 2
					if (dwID == INADDR_NONE) { // could it be a hostname? We will assume this for later checking...
						if (_tcslen(pIP) > 512 /*hostsource->hostname*/) {
d273 6
a278 3
					} else {
						// skip bad ips
						if(dwID < 0x1000000) {
d294 2
a295 1
				if (nCount==0 && nHostnameCount==0) {
@


1.16
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d68 3
a70 3
///////////////////////////////////////////// 
// CED2KServerListLink implementation 
///////////////////////////////////////////// 
d78 1
a78 1
} 
d80 1
a80 2
void
CED2KServerListLink::GetLink(CString& lnk)
d82 1
a82 3
	lnk = _T("ed2k://|serverlist|");
	lnk += m_address;
	lnk += _T("|/");
d85 1
a85 2
CED2KServerListLink*
CED2KServerListLink::GetServerListLink()
d90 1
a90 2
CED2KServerLink*
CED2KServerListLink::GetServerLink()
d95 1
a95 2
CED2KFileLink*
CED2KServerListLink::GetFileLink()
d100 1
a100 2
CED2KLink::LinkType
CED2KServerListLink::GetKind() const
d115 1
a115 4
	m_defaultName = "Server ";
	m_defaultName += ip;
	m_defaultName += ":";
	m_defaultName += port;
d122 2
a123 4

void 
CED2KServerLink::GetLink(CString& lnk)
{	
d127 3
a129 4
CED2KServerListLink*
CED2KServerLink::GetServerListLink() 
{ 
	return 0; 
d132 3
a134 4
CED2KServerLink* 
CED2KServerLink::GetServerLink() 
{ 
	return this; 
d137 3
a139 4
CED2KFileLink* 
CED2KServerLink::GetFileLink() 
{ 
	return 0; 
d142 1
a142 2
CED2KLink::LinkType 
CED2KServerLink::GetKind() const
d159 1
a159 1
			throw GetResString(IDS_ERR_TOOLARGEFILE);
d186 1
a186 1
		uint32 dwServerIP = 0; 
d244 1
a244 1
					}          
d251 1
a251 1
							continue;            
d256 1
a256 1
					} else {      
d261 1
a261 1
							continue;       
d267 1
a267 2
					for (int i=0; i<16; i++)       //
						newsource->filehashkey[i]=m_hash[i]; //save file hash 
d271 1
a271 1
					ClientSourcesList->AddTail(newsource); 
d277 1
a277 1
				}        
d291 1
a291 2
void 
CED2KFileLink::GetLink(CString& lnk)
d293 4
a296 12
	lnk = _T("ed2k://|file|");
	lnk += m_name;
	lnk += _T("|");
	lnk += m_size;
	lnk += _T("|");
	for (int idx=0; idx != 16 ; ++idx ) {
		unsigned int ui1 = m_hash[idx] / 16;
		unsigned int ui2 = m_hash[idx] % 16;
		lnk+= static_cast<TCHAR>( ui1 > 9 ? (_T('0')+ui1) : (_T('A')+(ui1-10)) );
		lnk+= static_cast<TCHAR>( ui2 > 9 ? (_T('0')+ui2) : (_T('A')+(ui2-10)) );
	}
	lnk += _T("|/");
d299 3
a301 4
CED2KServerListLink*
CED2KFileLink::GetServerListLink() 
{ 
	return 0; 
d304 3
a306 4
CED2KServerLink* 
CED2KFileLink::GetServerLink() 
{ 
	return 0; 
d308 2
a309 3
CED2KFileLink* 
CED2KFileLink::GetFileLink() 
{ 
d311 1
a311 1
	return this; 
d314 1
a314 2
CED2KLink::LinkType 
CED2KFileLink::GetKind() const
d320 2
a321 3
//static 
CED2KLink* 
CED2KLink::CreateLinkFromUrl( const CString& uri)
d365 1
a365 1
}@


1.15
log
@Fixed strings in ed2k serverlist links
@
text
@d274 1
a274 1
						if(dwID < 16777216) {
@


1.14
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d83 1
a83 1
	lnk = _T("ed2k://|m_pServerList|");
d377 1
a377 1
		//		|| pChArray[3] == 0 // This was preventing ed2k m_pServerList links from working.. 
d385 1
a385 1
	else if ( _tcscmp( _T("pServerList") , pChArray[1] ) == 0 && idx == 3 ) {
@


1.13
log
@unicode cleanup
@
text
@d83 1
a83 1
	lnk = _T("ed2k://|serverlist|");
d377 1
a377 1
		//		|| pChArray[3] == 0 // This was preventing ed2k serverlist links from working.. 
d385 1
a385 1
	else if ( _tcscmp( _T("serverlist") , pChArray[1] ) == 0 && idx == 3 ) {
@


1.12
log
@unicode cleanup
@
text
@d264 1
a264 1
						if (strlen(pIP) > 512 /*hostsource->hostname*/) {
d270 1
a270 1
						strcpy(newsource->sourceHostname, pIP);   //save hostname
@


1.11
log
@char * to CString conversion
@
text
@d339 1
a339 1
	m_name.Replace("%20"," ");
d371 1
a371 1
		throw CString(_T(GetResString(IDS_ERR_BADED2KLINK)));
@


1.10
log
@unicode cleanup
@
text
@d352 1
a352 1
CED2KLink::CreateLinkFromUrl( const TCHAR * uri)
d356 1
a356 2
	if (uri==0) 
		throw CString(_T("null ed2k link"));
@


1.9
log
@coverted code from char * to CString
@
text
@d174 1
a174 1
	if (_atoi64(size)>=4294967295)
@


1.8
log
@*** empty log message ***
@
text
@d135 2
a136 8
{
	char buffer[32];				// netwolf 07.05.03 support non-ip ed2k server link
	lnk = _T("ed2k://|server|");
	lnk += m_ip;					// netwolf
	lnk += _T("|");
	sprintf(buffer,"%d",static_cast<int>(m_port));
	lnk += buffer;
	lnk += _T("|/");
@


1.7
log
@netwolf's changes
@
text
@d117 1
a117 1
	m_ip = inet_addr(ip);
d136 1
a136 2
	in_addr adr;
	char buffer[32];
d138 1
a138 2
	adr.S_un.S_addr = m_ip;
	lnk += inet_ntoa(adr);
@


1.6
log
@oops
@
text
@d181 4
a361 2
	EMULE_TRY

d388 15
a402 23
		) {
			throw GetResString(IDS_ERR_BADED2KLINK);
		}
		if ( _tcscmp( _T("file") , pChArray[1]  ) == 0 && idx >=  5 && pChArray[4] != 0 ) {
			return new CED2KFileLink(pChArray[2],pChArray[3],pChArray[4],pChArray[6]);
		}
		else if ( _tcscmp( _T("serverlist") , pChArray[1] ) == 0 && idx == 3 ) {
			return new CED2KServerListLink(pChArray[2]);
		}
		else if ( _tcscmp( _T("server") , pChArray[1]  ) == 0 && idx == 4 ) {
			return new CED2KServerLink(pChArray[2],pChArray[3]);
		}
		else {
			throw GetResString(IDS_ERR_NOSLLINK);
		}

		EMULE_CATCH

#ifdef DEBUG
		return 0;
#else
        throw GetResString(IDS_ERR_BADED2KLINK);
#endif
d404 1
@


1.6.2.1
log
@27c
@
text
@a180 4

	if (_atoi64(size)>=4294967295)
			throw GetResString(IDS_ERR_TOOLARGEFILE);

@


1.5
log
@bugfix crash on link !
@
text
@d404 1
d406 4
@


1.4
log
@enkeydev stuff
@
text
@d358 2
d401 3
@


1.3
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d185 2
a186 1
	SourcesList=NULL;
d202 1
d233 1
a233 1
			// increment pCh to point to the first "ip:port" and check for sources
d235 2
a236 3
				SourcesList=new CMemFile();
				SourcesList->Write(&nCount,sizeof(nCount)); // init to 0, we'll fix this at the end.
				// for each "ip:port" source string until the end
d242 2
a243 2
						*pCh = 0; // terminate current "ip:port"
						pCh++; // point to next "ip:port"
d248 1
a248 1
					// if port is not present for this ip, go to the next ip.
d252 1
a252 1
					*pPort = 0;	// terminate ip string
d256 1
d260 33
a292 9
					// skip bad ips / ports
					if( dwID == INADDR_NONE || dwID < 16777216 || 
						ul > 0xFFFF || ul == 0 )
					{	nInvalid++;	continue;	}

					SourcesList->Write(&dwID,sizeof(dwID));
					SourcesList->Write(&nPort,sizeof(nPort));
					SourcesList->Write(&dwServerIP,sizeof(dwServerIP));
					SourcesList->Write(&nServerPort,sizeof(nServerPort));
d295 5
a299 7
				SourcesList->SeekToBegin();
				SourcesList->Write(&nCount,sizeof(nCount));
				SourcesList->SeekToBegin();
				if (nCount==0) {
					delete SourcesList;
					SourcesList=NULL;
				}
d308 2
a309 4
	if (SourcesList){
		delete SourcesList;
		SourcesList=NULL;
	}
d382 1
a382 1
//		|| pChArray[3] == 0 // This was preventing ed2k serverlist links from working.. 
d384 1
a384 1
	   ) {
d386 15
a400 15
	}
	if ( _tcscmp( _T("file") , pChArray[1]  ) == 0 && idx >=  5 && pChArray[4] != 0 ) {
		return new CED2KFileLink(pChArray[2],pChArray[3],pChArray[4],pChArray[6]);
	}
	else if ( _tcscmp( _T("serverlist") , pChArray[1] ) == 0 && idx == 3 ) {
		return new CED2KServerListLink(pChArray[2]);
	}
	else if ( _tcscmp( _T("server") , pChArray[1]  ) == 0 && idx == 4 ) {
		return new CED2KServerLink(pChArray[2],pChArray[3]);
	}
	else {
		throw GetResString(IDS_ERR_NOSLLINK);
	}
	return 0;
}
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@a16 1
#include <winsock2.h>
@


1.1
log
@*** empty log message ***
@
text
@d22 7
@


1.1.4.1
log
@updating this branch...
@
text
@@

