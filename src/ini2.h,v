head	1.17;
access;
symbols
	PublicRelease_1_2e:1.15
	Interim_Release_1-2e_RC1:1.15
	PublicRelease_1_2d:1.15
	Interim_Release_1-2d_RC1:1.15
	Interim_Release_1-2d_beta1:1.14
	PublicRelease_1_2c:1.9
	Interim_Release_1-2c_RC1:1.9
	Interim_Release_1-2c_beta1:1.9
	PublicRelease_1_2b:1.9
	Interim_Release_1-2b_RC1:1.9
	PublicRelease_1_2a:1.9
	Interim_Release_1-2a_RC1:1.9
	Interim_Release_1-2a_beta2:1.9
	Interim_Release_1-2a_beta1:1.9
	PublicRelease_1_2:1.9
	Interim_Release_1-2_RC1:1.9
	Interim_Release_1-2_beta1:1.9
	PublicRelease_1_1g:1.9
	Interim_Release_1-1g_RC3:1.9
	Interim_Release_1-1g_RC2:1.9
	Interim_Release_1-1g_RC1:1.9
	Interim_Release_1-1g_beta2:1.9
	Interim_Release_1-1g_beta1:1.9
	PublicRelease_1_1f:1.9
	Interim_Release_1-1f_RC1:1.9
	PublicRelease_1_1e:1.9
	Interim_Release_1-1e_RC2:1.9
	Interim_Release_1-1e_RC1:1.9
	Interim_Release_1-1e_beta1:1.9
	PublicRelease_1_1d:1.9
	Interim_Release_1-1d_RC1:1.9
	PublicRelease_1_1c:1.9
	Interim_Release_1-1c_RC1:1.9
	Interim_Release_1-1c_beta2:1.9
	Interim_Release_1-1c_beta1:1.9
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.9
	PublicRelease_1_1a:1.9
	Interim_Release_1-1a_RC2:1.9
	Interim_Release_1-1a_RC1:1.9
	Interim_Release_1-1a_beta2:1.9
	Interim_Release_1-1a_beta1:1.9
	PublicRelease_1_1:1.9
	Interim_Release_1-1_beta1:1.9
	PublicRelease_1o:1.9
	Interim_Release_1o_RC1:1.9
	Interim_Release_1o_beta1:1.9
	PublicRelease_1n:1.8
	Interim_Release_1n_RC2:1.8
	Interim_Release_1n_RC1:1.8
	Interim_Release_1n_beta2:1.8
	Interim_Release_1n_beta1:1.8
	PublicRelease_1m:1.8
	Interim_Release_1m_beta1:1.8
	PublicRelease_1l:1.8
	Interim_Release_1l_RC3:1.8
	Interim_Release_1l_RC2:1.8
	Interim_Release_1l_RC1:1.8
	Interim_Release_1l_beta2:1.8
	Interim_Release_1l_beta1:1.8
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.8
	Interim_Release_1J_RC3:1.8
	Interim_Release_1j_RC3:1.8
	Interim_Release_1j_RC2:1.8
	Interim_Release_1j_RC1:1.8
	Interim_Release_1j_beta2:1.8
	Interim_Release_1j_beta1:1.8
	PublicRelease_1i:1.8
	Interim_Release_1i_RC6:1.8
	Interim_Release_1i_RC3:1.8
	Interim_Release_1i_RC2:1.8
	Interim_Release_1i_RC1:1.8
	Interim_Release_1i_beta3:1.8
	Interim_Release_1i_beta2:1.8
	Interim_Release_1i_beta1:1.8
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.8
	Interim_Release_1h_RC1:1.8
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.7
	Interim_Release_1h_beta1:1.7
	PublicRelease_1g:1.5
	Interim_Release_1g_RC6_Final:1.5
	Interim_Release_1g_RC6:1.5
	Interim_Release_1g_RC5:1.5
	Interim_Release_1g_RC4:1.5
	Interim_Release_1g_RC3:1.5
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.2
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.17
date	2009.05.05.03.44.57;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2009.05.01.04.17.19;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2008.04.07.03.34.13;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2007.12.11.04.20.08;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.01.10.38.07;	author eklmn;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.12.23.50.27;	author fuxie-dk;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.31.18.27.42;	author fuxie-dk;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.18.14.48.33;	author fuxie-dk;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.20.07.14.55;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2003.08.24.22.40.36;	author bond006;	state Exp;
branches;
next	1.7;

1.7
date	2003.08.06.16.46.33;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.29.13.16.53;	author bond006;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.15.07.48.30;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.09.20.57.48;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.19.06.27.27;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.25;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.40;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Added default value to be used while reading byte array from ini file.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// Ini2.h: Ini-File-Interface by bond006 <rene.landgrebe@@gmx.de>
// ****************************************************************
// This new interface replaces the old interface which was too slow
#pragma once

#define INI_MODE_READONLY		0x01
#define INI_MODE_ANSIONLY		0x02

class CIni : public CFile
{
public:
	CIni(const CString &strFileName, int iMode = 0);
	~CIni();

	void		CloseWithoutSave(){CloseFile();}
	void		SaveAndClose();

	void		AddCategory(const CString& strCategoryName);
	void		SetDefaultCategory(const CString& strCategoryName);
	void		SetDefaultCategory(const TCHAR *pcCategoryName);
	void		DeleteCategory(const CString& strCategoryName);
	void		DeleteEntry(const CString& strCategoryName, const CString& strEntryName);

	__declspec(noinline) const CString&	GetString(const TCHAR *pcEntryName, const TCHAR *pcValue);
	__declspec(noinline) void		GetString(CString *pstrOut, const TCHAR *pcEntryName, const TCHAR *pcValue);
	__declspec(noinline) double		GetDouble(const TCHAR *pcEntryName, double defValue);
	__declspec(noinline) int		GetInt(const TCHAR *pcEntryName, int defValue);
	WORD		GetWORD(const TCHAR *pcEntryName, WORD defValue);
	uint32		GetUInt32(const TCHAR *pcEntryName, uint32 defValue);
	uint16		GetUInt16(const TCHAR *pcEntryName, int iDefVal);
	__declspec(noinline) uint64		GetUInt64(const TCHAR *pcEntryName, uint64 defValue);
	__declspec(noinline) bool		GetBool(const TCHAR *pcEntryName, bool defValue);
	void		SetString(const TCHAR *pcEntryName, const CString& strValue);
	void		SetDouble(const TCHAR *pcEntryName, double dValue);
	void		SetInt(const TCHAR *pcEntryName, int iValue);
	void		SetWORD(const TCHAR *pcEntryName, WORD wValue);
	void		SetUInt32(const TCHAR *pcEntryName, uint32 dwValue);
	void		SetUInt64(const TCHAR *pcEntryName, uint64 qwValue);
	void		SetBool(const TCHAR *pcEntryName, bool bValue);

	void		GetArray(CString *pToArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(double *pToArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(int *pToArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(WORD *pToArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(bool *pToArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(byte *pToArray, unsigned uiElements, const TCHAR *pcEntryName, const byte *pDefArray = NULL);
	void		SetArray(CString *pInArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const double *pInArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const int *pInArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const WORD *pInArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const bool *pInArray, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const byte *pInArray, unsigned uiElements, const TCHAR *pcEntryName);

	bool		CategoryExist(const CString& strCategoryName);
	bool		EntryExist(const CString &strCategoryName, const TCHAR *pcEntryName);
	bool		ValueExist(const CString& strCategoryName, const CString& strEntryName);

private:
	void		OpenFile(const CString &strFileName, int iMode);
	void		CloseFile();
	void		ReadData(int iMode);

	void		SetValue(const TCHAR *pcEntryName, const CString &strValue);
	void		GetValue(const TCHAR *pcEntryName, CString *pstrOut);

	CString m_strDefCategory;
	CString m_strFileBuffer;
//	Used as internal class exchange buffer to avoid numerous memory allocations
//	based on the fact that all requests are done consecutively from one thread
	CString m_strInternXchg;
	CString m_strDefCatBraces;		// default category in format "[Name]"
	CString m_strDefCatBracesCR;	// default category in format "\r\n[Name]"
};
@


1.16
log
@Added support for byte arrays; Removed duplicate H-file.
@
text
@d62 1
a62 1
	void		GetArray(byte *pToArray, unsigned uiElements, const TCHAR *pcEntryName);
@


1.15
log
@Added new service for uint16.
@
text
@a21 2
#include "types.h"

d57 12
a68 10
	void		GetArray(CString *pString, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(double *pDouble, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(int *pInt, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(WORD *pWord, unsigned uiElements, const TCHAR *pcEntryName);
	void		GetArray(bool *pBool, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(CString *pString, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const double *pDouble, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const int *pInt, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const WORD *pWord, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(const bool *pBool, unsigned uiElements, const TCHAR *pcEntryName);
@


1.14
log
@Optimized ini interface for reading string values to avoid unrequired memory reallocations.
@
text
@d48 1
@


1.13
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d43 1
d45 1
a45 1
	__declspec(noinline) int			GetInt(const TCHAR *pcEntryName, int defValue);
d79 1
a79 1
	void		GetValue(const TCHAR *pcEntryName);	// return value is in m_strInternXchg
@


1.12
log
@Removed unused float services; Const added for some prototypes [Aw3].
@
text
@d24 3
d30 1
a30 1
	CIni(const CString &strFileName, bool bReadOnly = false);
d73 1
a73 1
	void		OpenFile(const CString &strFileName, bool bReadOnly);
d75 1
a75 1
	void		ReadData();
@


1.11
log
@Optimized to reduce numerous memory allocations; Reorganized handling of the category name to avoid useless overhead; Disabled unrolling of some extensivaly used functions to save on space as our compiler seems to be stutid enough to unroll huge functions when global optimization is in use [Aw3].
@
text
@a40 1
	float		GetFloat(const TCHAR *pcEntryName, float defValue);
a47 1
	void		SetFloat(const TCHAR *pcEntryName, float fValue);
a55 1
	void		GetArray(float *pFloat, unsigned uiElements, const TCHAR *pcEntryName);
d60 4
a63 5
	void		SetArray(double *pDouble, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(float *pFloat, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(int *pInt, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(WORD *pWord, unsigned uiElements, const TCHAR *pcEntryName);
	void		SetArray(bool *pBool, unsigned uiElements, const TCHAR *pcEntryName);
@


1.10
log
@Extended INI interface to allow opening only in read-only mode (this way file isn't created when it didn't exist before) [Aw3].
@
text
@d1 1
a1 1
//	this file is part of eMule Plus
d39 2
a40 2
	CString		GetString(const TCHAR *pcEntryName, const CString& defValue);
	double		GetDouble(const TCHAR *pcEntryName, double defValue);
d42 1
a42 1
	int			GetInt(const TCHAR *pcEntryName, int defValue);
d45 2
a46 2
	uint64		GetUInt64(const TCHAR *pcEntryName, uint64 defValue);
	bool		GetBool(const TCHAR *pcEntryName, bool defValue);
d50 1
a50 1
	void		SetInt(const TCHAR *pcEntryName, int nValue);
d52 2
a53 2
	void		SetUInt32(const TCHAR *pcEntryName, uint32 nValue);
	void		SetUInt64(const TCHAR *pcEntryName, uint64 nValue);
d56 12
a67 12
	void		GetArray(CString* pString, int nElements, const TCHAR *pcEntryName);
	void		GetArray(double* pDouble, int nElements, const TCHAR *pcEntryName);
	void		GetArray(float* pFloat, int nElements, const TCHAR *pcEntryName);
	void		GetArray(int* pInt, int nElements, const TCHAR *pcEntryName);
	void		GetArray(WORD* pWord, int nElements, const TCHAR *pcEntryName);
	void		GetArray(bool* pBool, int nElements, const TCHAR *pcEntryName);
	void		SetArray(CString* pString, int nElements, const TCHAR *pcEntryName);
	void		SetArray(double* pDouble, int nElements, const TCHAR *pcEntryName);
	void		SetArray(float* pFloat, int nElements, const TCHAR *pcEntryName);
	void		SetArray(int* pInt, int nElements, const TCHAR *pcEntryName);
	void		SetArray(WORD* pWord, int nElements, const TCHAR *pcEntryName);
	void		SetArray(bool* pBool, int nElements, const TCHAR *pcEntryName);
d79 1
a79 1
	CString		GetValue(const TCHAR *pcEntryName);
d83 5
@


1.9
log
@Faster processing of ini-file settings and preferences values.
@
text
@d1 16
d20 1
a21 1
#pragma once
d27 1
a27 1
	CIni(const CString& strFileName);
d74 1
a74 1
	void		OpenFile(const CString& strFileName);
@


1.8
log
@code cleanup
@
text
@a3 1
// Last Update: 08/24/2003
d10 58
a67 58
	public:
		CIni(const CString& strFileName);
		~CIni();

		void		CloseWithoutSave(){CloseFile();}
		void		SaveAndClose();

		void		AddCategory(const CString& strCategoryName);
		void		SetDefaultCategory(const CString& strCategoryName);
		void		DeleteCategory(const CString& strCategoryName);
		void		DeleteEntry(const CString& strCategoryName, const CString& strEntryName);

		CString		GetString(const CString& strEntryName, const CString& defValue, const CString& strCategoryName=_T(""));
		double		GetDouble(const CString& strEntryName, double defValue, const CString& strCategoryName=_T(""));
		float		GetFloat(const CString& strEntryName, float defValue, const CString& strCategoryName=_T(""));
		int			GetInt(const CString& strEntryName, int defValue, const CString& strCategoryName=_T(""));
		WORD		GetWORD(const CString& strEntryName, WORD defValue, const CString& strCategoryName=_T(""));
		uint32		GetUInt32(const CString& strEntryName, uint32 defValue, const CString& strCategoryName=_T(""));
		uint64		GetUInt64(const CString& strEntryName, uint64 defValue, const CString& strCategoryName=_T(""));
		bool		GetBool(const CString& strEntryName, bool defValue, const CString& strCategoryName=_T(""));
		void		SetString(const CString& strEntryName, const CString& strValue, const CString& strCategoryName=_T(""));
		void		SetDouble(const CString& strEntryName, double dValue, const CString& strCategoryName=_T(""));
		void		SetFloat(const CString& strEntryName, float fValue, const CString& strCategoryName=_T(""));
		void		SetInt(const CString& strEntryName, int nValue, const CString& strCategoryName=_T(""));
		void		SetWORD(const CString& strEntryName, WORD wValue, const CString& strCategoryName=_T(""));
		void		SetUInt32(const CString& strEntryName, uint32 nValue, const CString& strCategoryName=_T(""));
		void		SetUInt64(const CString& strEntryName, uint64 nValue, const CString& strCategoryName=_T(""));
		void		SetBool(const CString& strEntryName, bool bValue, const CString& strCategoryName=_T(""));

		void		GetArray(CString* pString, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		GetArray(double* pDouble, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		GetArray(float* pFloat, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		GetArray(int* pInt, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		GetArray(WORD* pWord, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		GetArray(bool* pBool, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		SetArray(CString* pString, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		SetArray(double* pDouble, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		SetArray(float* pFloat, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		SetArray(int* pInt, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		SetArray(WORD* pWord, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));
		void		SetArray(bool* pBool, int nElements, const CString& strEntryName, const CString& strCategoryName=_T(""));

		bool		CategoryExist(const CString& strCategoryName);
		bool		EntryExist(const CString& strCategoryName, const CString& strEntryName);
		bool		ValueExist(const CString& strCategoryName, const CString& strEntryName);

	private:
		void		OpenFile();
		void		CloseFile();
		void		ReadData();

		void		SetValue(const CString& strCategoryName, const CString& strEntryName, const CString& strValue);
		CString		GetValue(const CString& strCategoryName, const CString& strEntryName);

		CString m_strDefCategory;
		CString m_strFileBuffer;
		CString m_strFileName;
};@


1.7
log
@added new types uint32 & uint64
@
text
@d2 1
a2 1
// **************************************************************
d4 1
a4 2
// It supports up to 256KByte large ini files at the moment!
// Date: 07/29/2003
d6 1
a8 2
#pragma once

d28 2
a29 2
		uint32	GetUInt32(const CString& strEntryName, uint32 defValue, const CString& strCategoryName=_T(""));
		uint64	GetUInt64(const CString& strEntryName, uint64 defValue, const CString& strCategoryName=_T(""));
@


1.6
log
@changed INI file interface + little bugfix
@
text
@d7 2
d30 2
d38 2
@


1.5
log
@unicode cleanup
@
text
@d1 5
a5 1
// Ini.h: Schnittstelle für die Klasse CIni.
a6 28
// Autor: Michael Schikora
// Mail:  schiko@@schikos.de
//
// If you found this code useful,
// please let me know
//
// How to use:
//
//
//void CMyClass::UpdateFromIni(BOOL bFromIni)
//{
//   CIni ini(m_strFileName,m_strSection);
//   ini.SER_GET(bFromIni,m_nValueXY); 
//   ini.SER_GET(bFromIni,m_strValue);
//   ini.SER_ARR(bFromIni,m_arValue,MAX_AR); 
//   ini.SER_ARR(bFromIni,m_ar3D,3);
//   //ore with default values 
//   ini.SER_GETD(bFromIni,m_nValueXY,5); 
//   ini.SER_GETD(bFromIni,m_strValue,"Hello");
//   ini.SER_ARRD(bFromIni,m_arValue,MAX_AR,10); 
//   ini.SER_ARRD(bFromIni,m_ar3D,3,5); 
//}


#if !defined(AFX_INI_H__EEBAF800_182A_11D3_B51F_00104B4A13B4__INCLUDED_)
#define AFX_INI_H__EEBAF800_182A_11D3_B51F_00104B4A13B4__INCLUDED_

#if _MSC_VER >= 1000
a7 2
#endif // _MSC_VER >= 1000

d9 1
a9 7
#define SER_GET(bGet,value) SerGet(bGet,value,#value)
#define SER_ARR(bGet,value,n) SerGet(bGet,value,n,#value)
#define SER_GETD(bGet,value,default) SerGet(bGet,value,#value,NULL,default)
#define SER_ARRD(bGet,value,n,default) SerGet(bGet,value,n,#value,default)


class CIni  
d11 54
a64 105
public:

#ifdef __NEVER_DEFINED__
   // MAKRO: SerGet(bGet,value,#value)
   int SER_GET(BOOL bGet,int value);
   // MAKRO: SerGet(bGet,value,n,#value)
   int SER_ARR(bGet,int* value,int n);
#endif
   // If the IniFilename contains no path,
   // the module-directory will be add to the FileName,
   // to avoid storing in the windows-directory
   // bModulPath=TRUE: ModulDir, bModulPath=FALSE: CurrentDir
   static void AddModulPath(CString& strFileName,BOOL bModulPath = TRUE);
   static CString GetDefaultSection();
   static CString GetDefaultIniFile(BOOL bModulPath = TRUE);

	CIni( BOOL bModulPath = TRUE);
	CIni(const CIni& Ini, BOOL bModulPath = TRUE);
	CIni(const CString& strFileName, BOOL bModulPath = TRUE);
	CIni(const CString& strFileName, const CString& strSection, BOOL bModulPath = TRUE);
	virtual ~CIni();

	void SetFileName(const CString& strFileName);
	void SetSection(const CString& strSection);
	CString GetFileName() const;
	CString GetSection() const;
private:
	void Init(LPCTSTR strIniFile, LPCTSTR strSection = NULL);
public:
	CString		GetString(const CString& strEntry,	LPCTSTR strDefault=NULL,					LPCTSTR strSection = NULL);
	double		GetDouble(const CString& strEntry,	double fDefault = 0.0,					LPCTSTR strSection = NULL);
	float		GetFloat(const CString& strEntry,	float fDefault = 0.0,					LPCTSTR strSection = NULL);
	int			GetInt(const CString& strEntry,	int nDefault = 0,						LPCTSTR strSection = NULL);
	WORD		GetWORD(const CString& strEntry,	WORD nDefault = 0,						LPCTSTR strSection = NULL);
	BOOL		GetBool(const CString& strEntry,	BOOL bDefault = FALSE,					LPCTSTR strSection = NULL);
	CPoint		GetPoint(const CString& strEntry,	CPoint ptDefault = CPoint(0,0),			LPCTSTR strSection = NULL);
	CRect		GetRect(const CString& strEntry,	CRect rectDefault = CRect(0,0,0,0),		LPCTSTR strSection = NULL);
	COLORREF	GetColRef(const CString& strEntry,	COLORREF crDefault = RGB(128,128,128),	LPCTSTR strSection = NULL);

	void		WriteString(const CString& strEntry,const CString&	str,		LPCTSTR strSection = NULL);
	void		WriteDouble(const CString& strEntry,double		f,			LPCTSTR strSection = NULL);
	void		WriteFloat(const CString& strEntry,float		f,			LPCTSTR strSection = NULL);
	void		WriteInt(const CString& strEntry,int			n,			LPCTSTR strSection = NULL);
	void		WriteWORD(const CString& strEntry,WORD		n,			LPCTSTR strSection = NULL);
	void		WriteBool(const CString& strEntry,BOOL			b,			LPCTSTR strSection = NULL);
	void		WritePoint(const CString& strEntry,const CPoint&		pt,			LPCTSTR strSection = NULL);
	void		WriteRect(const CString& strEntry,const CRect&		rect,		LPCTSTR strSection = NULL);
	void		WriteColRef(const CString& strEntry,COLORREF	cr,			LPCTSTR strSection = NULL);

	void		SerGetString(	BOOL bGet,CString	& str,	const CString& strEntry,	LPCTSTR strSection = NULL,	LPCTSTR strDefault=NULL);
	void		SerGetDouble(	BOOL bGet,double	& f,	const CString& strEntry,	LPCTSTR strSection = NULL,	double fDefault = 0.0);
	void		SerGetFloat(	BOOL bGet,float		& f,	const CString& strEntry,	LPCTSTR strSection = NULL,	float fDefault = 0.0);
	void		SerGetInt(		BOOL bGet,int		& n,	const CString& strEntry,	LPCTSTR strSection = NULL,	int nDefault = 0);
	void		SerGetDWORD(	BOOL bGet,DWORD		& n,	const CString& strEntry,	LPCTSTR strSection = NULL,	DWORD nDefault = 0);
	void		SerGetBool(		BOOL bGet,BOOL		& b,	const CString& strEntry,	LPCTSTR strSection = NULL,	BOOL bDefault = FALSE);
	void		SerGetPoint(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCTSTR strSection = NULL,	CPoint ptDefault = CPoint(0,0));
	void		SerGetRect(		BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCTSTR strSection = NULL,	CRect rectDefault = CRect(0,0,0,0));
	void		SerGetColRef(	BOOL bGet,COLORREF	& cr,	const CString& strEntry,	LPCTSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));

	void		SerGet(	BOOL bGet,CString	& str,	const CString& strEntry,	LPCTSTR strSection = NULL,	LPCTSTR strDefault=NULL);
	void		SerGet(	BOOL bGet,double	& f,	const CString& strEntry,	LPCTSTR strSection = NULL,	double fDefault = 0.0);
	void		SerGet(	BOOL bGet,float		& f,	const CString& strEntry,	LPCTSTR strSection = NULL,	float fDefault = 0.0);
	void		SerGet(	BOOL bGet,int		& n,	const CString& strEntry,	LPCTSTR strSection = NULL,	int nDefault = 0);
	void		SerGet(	BOOL bGet,short		& n,	const CString& strEntry,	LPCTSTR strSection = NULL,	int nDefault = 0);
	void		SerGet(	BOOL bGet,DWORD		& n,	const CString& strEntry,	LPCTSTR strSection = NULL,	DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,WORD		& n,	const CString& strEntry,	LPCTSTR strSection = NULL,	DWORD nDefault = 0);
//	void		SerGet(	BOOL bGet,BOOL		& b,	const CString& strEntry,	LPCTSTR strSection = NULL,	BOOL bDefault = FALSE);
	void		SerGet(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCTSTR strSection = NULL,	CPoint ptDefault = CPoint(0,0));
	void		SerGet(	BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCTSTR strSection = NULL,	CRect rectDefault = CRect(0,0,0,0));
//	void		SerGet(	BOOL bGet,COLORREF	& cr,	const CString& strEntry,	LPCTSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));
   
//ARRAYs
	void		SerGet(	BOOL bGet,CString	* str,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, LPCTSTR strDefault=NULL);
	void		SerGet(	BOOL bGet,double	* f,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, double fDefault = 0.0);
	void		SerGet(	BOOL bGet,float		* f,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, float fDefault = 0.0);
	void		SerGet(	BOOL bGet,unsigned char	* n,int nCount, const CString& strEntry, LPCTSTR strSection = NULL, unsigned char nDefault = 0);
	void		SerGet(	BOOL bGet,int		* n,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, int nDefault = 0);
	void		SerGet(	BOOL bGet,short		* n,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, int nDefault = 0);
	void		SerGet(	BOOL bGet,DWORD		* n,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,WORD		* n,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,CPoint	* pt,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, CPoint ptDefault = CPoint(0,0));
	void		SerGet(	BOOL bGet,CRect		* rect,	int nCount, const CString& strEntry, LPCTSTR strSection = NULL, CRect rectDefault = CRect(0,0,0,0));

	int			Parse(const CString& strIn, int nOffset, CString &strOut);
   //MAKRO :
   //SERGET(bGet,value) SerGet(bGet,value,#value)

private:
	char* GetLPCTSTR(const CString& strEntry,LPCTSTR strSection,LPCTSTR strDefault);
   BOOL  m_bModulPath;  //TRUE: Filenames without path take the Modulepath
                        //FALSE: Filenames without path take the CurrentDirectory

#define MAX_INI_BUFFER 256
	TCHAR	m_chBuffer[MAX_INI_BUFFER];
	CString m_strFileName;
	CString m_strSection;
//////////////////////////////////////////////////////////////////////
// statische Methoden
//////////////////////////////////////////////////////////////////////
public:
	static CString	Read( const CString& strFileName, const CString& strSection, const CString& strEntry, const CString& strDefault);
	static void		Write(const CString& strFileName, const CString& strSection, const CString& strEntry, const CString& strValue);
};

#endif // !defined(AFX_INI_H__EEBAF800_182A_11D3_B51F_00104B4A13B4__INCLUDED_)
@


1.4
log
@unicode cleanup
@
text
@d131 1
a131 1
	char* GetLPCSTR(const CString& strEntry,LPCTSTR strSection,LPCTSTR strDefault);
@


1.3
log
@unicode cleanup
@
text
@d136 1
a136 1
	char	m_chBuffer[MAX_INI_BUFFER];
@


1.2
log
@small code optimizations in parameters passing
@
text
@d70 1
a70 1
	void Init(LPCSTR strIniFile, LPCSTR strSection = NULL);
d72 9
a80 9
	CString		GetString(const CString& strEntry,	LPCSTR strDefault=NULL,					LPCSTR strSection = NULL);
	double		GetDouble(const CString& strEntry,	double fDefault = 0.0,					LPCSTR strSection = NULL);
	float		GetFloat(const CString& strEntry,	float fDefault = 0.0,					LPCSTR strSection = NULL);
	int			GetInt(const CString& strEntry,	int nDefault = 0,						LPCSTR strSection = NULL);
	WORD		GetWORD(const CString& strEntry,	WORD nDefault = 0,						LPCSTR strSection = NULL);
	BOOL		GetBool(const CString& strEntry,	BOOL bDefault = FALSE,					LPCSTR strSection = NULL);
	CPoint		GetPoint(const CString& strEntry,	CPoint ptDefault = CPoint(0,0),			LPCSTR strSection = NULL);
	CRect		GetRect(const CString& strEntry,	CRect rectDefault = CRect(0,0,0,0),		LPCSTR strSection = NULL);
	COLORREF	GetColRef(const CString& strEntry,	COLORREF crDefault = RGB(128,128,128),	LPCSTR strSection = NULL);
d82 9
a90 9
	void		WriteString(const CString& strEntry,const CString&	str,		LPCSTR strSection = NULL);
	void		WriteDouble(const CString& strEntry,double		f,			LPCSTR strSection = NULL);
	void		WriteFloat(const CString& strEntry,float		f,			LPCSTR strSection = NULL);
	void		WriteInt(const CString& strEntry,int			n,			LPCSTR strSection = NULL);
	void		WriteWORD(const CString& strEntry,WORD		n,			LPCSTR strSection = NULL);
	void		WriteBool(const CString& strEntry,BOOL			b,			LPCSTR strSection = NULL);
	void		WritePoint(const CString& strEntry,const CPoint&		pt,			LPCSTR strSection = NULL);
	void		WriteRect(const CString& strEntry,const CRect&		rect,		LPCSTR strSection = NULL);
	void		WriteColRef(const CString& strEntry,COLORREF	cr,			LPCSTR strSection = NULL);
d92 9
a100 9
	void		SerGetString(	BOOL bGet,CString	& str,	const CString& strEntry,	LPCSTR strSection = NULL,	LPCSTR strDefault=NULL);
	void		SerGetDouble(	BOOL bGet,double	& f,	const CString& strEntry,	LPCSTR strSection = NULL,	double fDefault = 0.0);
	void		SerGetFloat(	BOOL bGet,float		& f,	const CString& strEntry,	LPCSTR strSection = NULL,	float fDefault = 0.0);
	void		SerGetInt(		BOOL bGet,int		& n,	const CString& strEntry,	LPCSTR strSection = NULL,	int nDefault = 0);
	void		SerGetDWORD(	BOOL bGet,DWORD		& n,	const CString& strEntry,	LPCSTR strSection = NULL,	DWORD nDefault = 0);
	void		SerGetBool(		BOOL bGet,BOOL		& b,	const CString& strEntry,	LPCSTR strSection = NULL,	BOOL bDefault = FALSE);
	void		SerGetPoint(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCSTR strSection = NULL,	CPoint ptDefault = CPoint(0,0));
	void		SerGetRect(		BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCSTR strSection = NULL,	CRect rectDefault = CRect(0,0,0,0));
	void		SerGetColRef(	BOOL bGet,COLORREF	& cr,	const CString& strEntry,	LPCSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));
d102 11
a112 11
	void		SerGet(	BOOL bGet,CString	& str,	const CString& strEntry,	LPCSTR strSection = NULL,	LPCSTR strDefault=NULL);
	void		SerGet(	BOOL bGet,double	& f,	const CString& strEntry,	LPCSTR strSection = NULL,	double fDefault = 0.0);
	void		SerGet(	BOOL bGet,float		& f,	const CString& strEntry,	LPCSTR strSection = NULL,	float fDefault = 0.0);
	void		SerGet(	BOOL bGet,int		& n,	const CString& strEntry,	LPCSTR strSection = NULL,	int nDefault = 0);
	void		SerGet(	BOOL bGet,short		& n,	const CString& strEntry,	LPCSTR strSection = NULL,	int nDefault = 0);
	void		SerGet(	BOOL bGet,DWORD		& n,	const CString& strEntry,	LPCSTR strSection = NULL,	DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,WORD		& n,	const CString& strEntry,	LPCSTR strSection = NULL,	DWORD nDefault = 0);
//	void		SerGet(	BOOL bGet,BOOL		& b,	const CString& strEntry,	LPCSTR strSection = NULL,	BOOL bDefault = FALSE);
	void		SerGet(	BOOL bGet,CPoint	& pt,	const CString& strEntry,	LPCSTR strSection = NULL,	CPoint ptDefault = CPoint(0,0));
	void		SerGet(	BOOL bGet,CRect		& rect,	const CString& strEntry,	LPCSTR strSection = NULL,	CRect rectDefault = CRect(0,0,0,0));
//	void		SerGet(	BOOL bGet,COLORREF	& cr,	const CString& strEntry,	LPCSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));
d115 10
a124 10
	void		SerGet(	BOOL bGet,CString	* str,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, LPCSTR strDefault=NULL);
	void		SerGet(	BOOL bGet,double	* f,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, double fDefault = 0.0);
	void		SerGet(	BOOL bGet,float		* f,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, float fDefault = 0.0);
	void		SerGet(	BOOL bGet,unsigned char	* n,int nCount, const CString& strEntry, LPCSTR strSection = NULL, unsigned char nDefault = 0);
	void		SerGet(	BOOL bGet,int		* n,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, int nDefault = 0);
	void		SerGet(	BOOL bGet,short		* n,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, int nDefault = 0);
	void		SerGet(	BOOL bGet,DWORD		* n,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,WORD		* n,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,CPoint	* pt,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, CPoint ptDefault = CPoint(0,0));
	void		SerGet(	BOOL bGet,CRect		* rect,	int nCount, const CString& strEntry, LPCSTR strSection = NULL, CRect rectDefault = CRect(0,0,0,0));
d131 1
a131 1
	char* GetLPCSTR(const CString& strEntry,LPCSTR strSection,LPCSTR strDefault);
@


1.1
log
@*** empty log message ***
@
text
@d60 3
a62 3
	CIni(CIni const& Ini, BOOL bModulPath = TRUE);
	CIni(CString const& strFileName, BOOL bModulPath = TRUE);
	CIni(CString const& strFileName, CString const& strSection, BOOL bModulPath = TRUE);
d65 4
a68 4
	void SetFileName(CString const& strFileName);
	void SetSection(CString const& strSection);
	CString const& GetFileName() const;
	CString const& GetSection() const;
d72 41
a112 41
	CString		GetString(CString strEntry,	LPCSTR strDefault=NULL,					LPCSTR strSection = NULL);
	double		GetDouble(CString strEntry,	double fDefault = 0.0,					LPCSTR strSection = NULL);
	float		GetFloat(CString strEntry,	float fDefault = 0.0,					LPCSTR strSection = NULL);
	int			GetInt(CString strEntry,	int nDefault = 0,						LPCSTR strSection = NULL);
	WORD		GetWORD(CString strEntry,	WORD nDefault = 0,						LPCSTR strSection = NULL);
	BOOL		GetBool(CString strEntry,	BOOL bDefault = FALSE,					LPCSTR strSection = NULL);
	CPoint		GetPoint(CString strEntry,	CPoint ptDefault = CPoint(0,0),			LPCSTR strSection = NULL);
	CRect		GetRect(CString strEntry,	CRect rectDefault = CRect(0,0,0,0),		LPCSTR strSection = NULL);
	COLORREF	GetColRef(CString strEntry,	COLORREF crDefault = RGB(128,128,128),	LPCSTR strSection = NULL);

	void		WriteString(CString strEntry,CString	str,		LPCSTR strSection = NULL);
	void		WriteDouble(CString strEntry,double		f,			LPCSTR strSection = NULL);
	void		WriteFloat(CString strEntry,float		f,			LPCSTR strSection = NULL);
	void		WriteInt(CString strEntry,int			n,			LPCSTR strSection = NULL);
	void		WriteWORD(CString strEntry,WORD		n,			LPCSTR strSection = NULL);
	void		WriteBool(CString strEntry,BOOL			b,			LPCSTR strSection = NULL);
	void		WritePoint(CString strEntry,CPoint		pt,			LPCSTR strSection = NULL);
	void		WriteRect(CString strEntry,CRect		rect,		LPCSTR strSection = NULL);
	void		WriteColRef(CString strEntry,COLORREF	cr,			LPCSTR strSection = NULL);

	void		SerGetString(	BOOL bGet,CString	& str,	CString strEntry,	LPCSTR strSection = NULL,	LPCSTR strDefault=NULL);
	void		SerGetDouble(	BOOL bGet,double	& f,	CString strEntry,	LPCSTR strSection = NULL,	double fDefault = 0.0);
	void		SerGetFloat(	BOOL bGet,float		& f,	CString strEntry,	LPCSTR strSection = NULL,	float fDefault = 0.0);
	void		SerGetInt(		BOOL bGet,int		& n,	CString strEntry,	LPCSTR strSection = NULL,	int nDefault = 0);
	void		SerGetDWORD(	BOOL bGet,DWORD		& n,	CString strEntry,	LPCSTR strSection = NULL,	DWORD nDefault = 0);
	void		SerGetBool(		BOOL bGet,BOOL		& b,	CString strEntry,	LPCSTR strSection = NULL,	BOOL bDefault = FALSE);
	void		SerGetPoint(	BOOL bGet,CPoint	& pt,	CString strEntry,	LPCSTR strSection = NULL,	CPoint ptDefault = CPoint(0,0));
	void		SerGetRect(		BOOL bGet,CRect		& rect,	CString strEntry,	LPCSTR strSection = NULL,	CRect rectDefault = CRect(0,0,0,0));
	void		SerGetColRef(	BOOL bGet,COLORREF	& cr,	CString strEntry,	LPCSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));

	void		SerGet(	BOOL bGet,CString	& str,	CString strEntry,	LPCSTR strSection = NULL,	LPCSTR strDefault=NULL);
	void		SerGet(	BOOL bGet,double	& f,	CString strEntry,	LPCSTR strSection = NULL,	double fDefault = 0.0);
	void		SerGet(	BOOL bGet,float		& f,	CString strEntry,	LPCSTR strSection = NULL,	float fDefault = 0.0);
	void		SerGet(	BOOL bGet,int		& n,	CString strEntry,	LPCSTR strSection = NULL,	int nDefault = 0);
	void		SerGet(	BOOL bGet,short		& n,	CString strEntry,	LPCSTR strSection = NULL,	int nDefault = 0);
	void		SerGet(	BOOL bGet,DWORD		& n,	CString strEntry,	LPCSTR strSection = NULL,	DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,WORD		& n,	CString strEntry,	LPCSTR strSection = NULL,	DWORD nDefault = 0);
//	void		SerGet(	BOOL bGet,BOOL		& b,	CString strEntry,	LPCSTR strSection = NULL,	BOOL bDefault = FALSE);
	void		SerGet(	BOOL bGet,CPoint	& pt,	CString strEntry,	LPCSTR strSection = NULL,	CPoint ptDefault = CPoint(0,0));
	void		SerGet(	BOOL bGet,CRect		& rect,	CString strEntry,	LPCSTR strSection = NULL,	CRect rectDefault = CRect(0,0,0,0));
//	void		SerGet(	BOOL bGet,COLORREF	& cr,	CString strEntry,	LPCSTR strSection = NULL,	COLORREF crDefault = RGB(128,128,128));
d115 10
a124 10
	void		SerGet(	BOOL bGet,CString	* str,	int nCount, CString strEntry, LPCSTR strSection = NULL, LPCSTR strDefault=NULL);
	void		SerGet(	BOOL bGet,double	* f,	int nCount, CString strEntry, LPCSTR strSection = NULL, double fDefault = 0.0);
	void		SerGet(	BOOL bGet,float		* f,	int nCount, CString strEntry, LPCSTR strSection = NULL, float fDefault = 0.0);
	void		SerGet(	BOOL bGet,unsigned char	* n,int nCount, CString strEntry, LPCSTR strSection = NULL, unsigned char nDefault = 0);
	void		SerGet(	BOOL bGet,int		* n,	int nCount, CString strEntry, LPCSTR strSection = NULL, int nDefault = 0);
	void		SerGet(	BOOL bGet,short		* n,	int nCount, CString strEntry, LPCSTR strSection = NULL, int nDefault = 0);
	void		SerGet(	BOOL bGet,DWORD		* n,	int nCount, CString strEntry, LPCSTR strSection = NULL, DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,WORD		* n,	int nCount, CString strEntry, LPCSTR strSection = NULL, DWORD nDefault = 0);
	void		SerGet(	BOOL bGet,CPoint	* pt,	int nCount, CString strEntry, LPCSTR strSection = NULL, CPoint ptDefault = CPoint(0,0));
	void		SerGet(	BOOL bGet,CRect		* rect,	int nCount, CString strEntry, LPCSTR strSection = NULL, CRect rectDefault = CRect(0,0,0,0));
d126 1
a126 1
	int			Parse(CString &strIn, int nOffset, CString &strOut);
d131 1
a131 1
	char* GetLPCSTR(CString strEntry,LPCSTR strSection,LPCSTR strDefault);
d143 2
a144 2
	static CString	Read( CString const& strFileName, CString const& strSection, CString const& strEntry, CString const& strDefault);
	static void		Write(CString const& strFileName, CString const& strSection, CString const& strEntry, CString const& strValue);
@


1.1.4.1
log
@updating this branch...
@
text
@@

