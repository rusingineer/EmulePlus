head	1.180;
access;
symbols
	PublicRelease_1_2e:1.177
	Interim_Release_1-2e_RC1:1.176
	PublicRelease_1_2d:1.175
	Interim_Release_1-2d_RC1:1.175
	Interim_Release_1-2d_beta1:1.173
	PublicRelease_1_2c:1.168
	Interim_Release_1-2c_RC1:1.168
	Interim_Release_1-2c_beta1:1.166
	PublicRelease_1_2b:1.165
	Interim_Release_1-2b_RC1:1.165
	PublicRelease_1_2a:1.158
	Interim_Release_1-2a_RC1:1.157
	Interim_Release_1-2a_beta2:1.156
	Interim_Release_1-2a_beta1:1.154
	PublicRelease_1_2:1.151
	Interim_Release_1-2_RC1:1.151
	Interim_Release_1-2_beta1:1.151
	PublicRelease_1_1g:1.149
	Interim_Release_1-1g_RC3:1.149
	Interim_Release_1-1g_RC2:1.149
	Interim_Release_1-1g_RC1:1.148
	Interim_Release_1-1g_beta2:1.146
	Interim_Release_1-1g_beta1:1.141
	PublicRelease_1_1f:1.139
	Interim_Release_1-1f_RC1:1.139
	PublicRelease_1_1e:1.138
	Interim_Release_1-1e_RC2:1.138
	Interim_Release_1-1e_RC1:1.138
	Interim_Release_1-1e_beta1:1.135
	PublicRelease_1_1d:1.133
	Interim_Release_1-1d_RC1:1.133
	PublicRelease_1_1c:1.133
	Interim_Release_1-1c_RC1:1.133
	Interim_Release_1-1c_beta2:1.133
	Interim_Release_1-1c_beta1:1.132
	PublicRelease_1_1b:1.130
	Interim_Release_1-1b_RC1:1.130
	PublicRelease_1_1a:1.130
	Interim_Release_1-1a_RC2:1.130
	Interim_Release_1-1a_RC1:1.130
	Interim_Release_1-1a_beta2:1.130
	Interim_Release_1-1a_beta1:1.130
	PublicRelease_1_1:1.130
	Interim_Release_1-1_beta1:1.130
	PublicRelease_1o:1.129
	Interim_Release_1o_RC1:1.129
	Interim_Release_1o_beta1:1.129
	PublicRelease_1n:1.128
	Interim_Release_1n_RC2:1.128
	Interim_Release_1n_RC1:1.128
	Interim_Release_1n_beta2:1.128
	Interim_Release_1n_beta1:1.126
	PublicRelease_1m:1.126
	Interim_Release_1m_beta1:1.126
	PublicRelease_1l:1.122
	Interim_Release_1l_RC3:1.122
	Interim_Release_1l_RC2:1.122
	Interim_Release_1l_RC1:1.117
	Interim_Release_1l_beta2:1.113
	Interim_Release_1l_beta1:1.100
	PublicRelease_1k:1.92
	Interim_Release_1k_RC4:1.92
	Interim_1k_RC3:1.92
	Interim_1k_RC2:1.92
	Interim_Release_1k_RC1:1.92
	Interim_Release_1k_beta5:1.92
	Intrerim_Release_1k_beta4:1.92
	Interim_Release_1k_beta1:1.86
	PublicRelease_1j:1.81
	Interim_Release_1J_RC3:1.81
	Interim_Release_1j_RC3:1.81
	Interim_Release_1j_RC2:1.76
	Interim_Release_1j_RC1:1.74
	Interim_Release_1j_beta2:1.74
	Interim_Release_1j_beta1:1.74
	PublicRelease_1i:1.74
	Interim_Release_1i_RC6:1.74
	Interim_Release_1i_RC3:1.73
	Interim_Release_1i_RC2:1.73
	Interim_Release_1i_RC1:1.72
	Interim_Release_1i_beta3:1.71
	Interim_Release_1i_beta2:1.70
	Interim_Release_1i_beta1:1.62
	PublicRelease_1h:1.46
	Interim_Release_1h_rc2:1.46
	Interim_Release_1h_RC1:1.45
	Interim_Release_1h_beta2:1.35
	Interim_Release_1h_beta1_now:1.31
	Interim_Release_1h_beta1:1.31
	PublicRelease_1g:1.29
	Interim_Release_1g_RC6_Final:1.29
	Interim_Release_1g_RC6:1.29
	Interim_Release_1g_RC5:1.29
	Interim_Release_1g_RC4:1.29
	Interim_Release_1g_RC3:1.29
	Interim_Release_1g_beta2:1.25
	Interim_Release_1g_beta1:1.24
	Interim_Release_1f_RC4:1.22
	Interim_Release_1f_RC3:1.22
	Interim_Release_1f_RC2:1.21
	Interim_Release_1f_RC:1.18
	Interim_Release_1f_beta2:1.16
	Interim_Release_1f_beta1:1.16
	PublicRelease_1e:1.16
	Interim_Release_1e_RC2:1.16
	Interim_Release_1e_RC:1.16
	Interim_Release_1e_beta3:1.16
	Interim_Release_1e_beta2:1.16
	Interim_Release_1e_beta2_before_kuchin:1.16
	Interim_Release_1e_beta1:1.16
	PublicRelease_1c:1.14
	featurestest:1.14.0.2
	Interim_Release_1c_RC:1.14
	Interim_Release_1c_beta2:1.14
	Interim_Release_1c_beta1:1.13
	threaded_downloadqueue:1.13.0.2
	PublicRelease_1b:1.12
	Interim_Release_1b_beta2:1.12
	Interim_Release_1b_beta1:1.11
	proxydeadlake:1.11.0.4
	PublicRelease_1a:1.11
	Interim_Release_1a_beta2:1.11
	BerkeleyDb:1.11.0.2
	Interim_Release_1a_beta1:1.11
	PublicRelease_1:1.7
	goldfish:1.7
	eMulePlus_1_RC2:1.7
	eMulePlus_26b_1RC1:1.7
	PreRelease_26b_i0e:1.7
	before_26d_merge:1.7
	Interim_Release_26b_i0d:1.5
	Interim_Release_26b_i0c:1.4
	Interim_Release_26b_i0b:1.4
	Interim_Release_26b_i0a:1.4
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.180
date	2009.10.28.04.35.00;	author aw3;	state Exp;
branches;
next	1.179;

1.179
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.178;

1.178
date	2009.06.17.02.27.14;	author aw3;	state Exp;
branches;
next	1.177;

1.177
date	2009.04.08.04.05.38;	author aw3;	state Exp;
branches;
next	1.176;

1.176
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.175;

1.175
date	2008.03.05.02.40.05;	author aw3;	state Exp;
branches;
next	1.174;

1.174
date	2008.03.03.05.11.59;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2008.01.23.05.17.07;	author aw3;	state Exp;
branches;
next	1.172;

1.172
date	2007.12.26.04.10.12;	author aw3;	state Exp;
branches;
next	1.171;

1.171
date	2007.12.19.04.58.20;	author aw3;	state Exp;
branches;
next	1.170;

1.170
date	2007.12.16.21.38.00;	author aw3;	state Exp;
branches;
next	1.169;

1.169
date	2007.11.03.09.46.20;	author eklmn;	state Exp;
branches;
next	1.168;

1.168
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.167;

1.167
date	2007.02.28.09.25.14;	author kush_eplus;	state Exp;
branches;
next	1.166;

1.166
date	2007.02.20.00.07.08;	author kush_eplus;	state Exp;
branches;
next	1.165;

1.165
date	2007.01.17.07.40.13;	author aw3;	state Exp;
branches;
next	1.164;

1.164
date	2007.01.11.19.57.05;	author eklmn;	state Exp;
branches;
next	1.163;

1.163
date	2006.12.29.04.09.12;	author aw3;	state Exp;
branches;
next	1.162;

1.162
date	2006.12.26.11.04.27;	author eklmn;	state Exp;
branches;
next	1.161;

1.161
date	2006.12.23.08.54.18;	author eklmn;	state Exp;
branches;
next	1.160;

1.160
date	2006.11.17.05.26.12;	author aw3;	state Exp;
branches;
next	1.159;

1.159
date	2006.11.16.11.57.00;	author eklmn;	state Exp;
branches;
next	1.158;

1.158
date	2006.09.29.02.29.14;	author aw3;	state Exp;
branches;
next	1.157;

1.157
date	2006.09.05.00.46.59;	author aw3;	state Exp;
branches;
next	1.156;

1.156
date	2006.06.05.04.32.15;	author aw3;	state Exp;
branches;
next	1.155;

1.155
date	2006.05.22.03.45.00;	author aw3;	state Exp;
branches;
next	1.154;

1.154
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.153;

1.153
date	2006.04.16.04.14.58;	author aw3;	state Exp;
branches;
next	1.152;

1.152
date	2006.04.06.04.16.36;	author aw3;	state Exp;
branches;
next	1.151;

1.151
date	2006.01.29.00.31.52;	author aw3;	state Exp;
branches;
next	1.150;

1.150
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.149;

1.149
date	2005.12.06.05.51.23;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2005.11.27.22.11.50;	author eklmn;	state Exp;
branches;
next	1.147;

1.147
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.146;

1.146
date	2005.11.15.06.02.54;	author aw3;	state Exp;
branches;
next	1.145;

1.145
date	2005.11.06.00.58.44;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2005.09.23.10.56.08;	author eklmn;	state Exp;
branches;
next	1.143;

1.143
date	2005.09.19.22.14.59;	author eklmn;	state Exp;
branches;
next	1.142;

1.142
date	2005.09.09.03.56.07;	author aw3;	state Exp;
branches;
next	1.141;

1.141
date	2005.08.21.03.09.12;	author aw3;	state Exp;
branches;
next	1.140;

1.140
date	2005.08.14.22.04.23;	author aw3;	state Exp;
branches;
next	1.139;

1.139
date	2005.07.26.11.01.41;	author aw3;	state Exp;
branches;
next	1.138;

1.138
date	2005.06.19.05.09.53;	author aw3;	state Exp;
branches;
next	1.137;

1.137
date	2005.06.10.03.45.41;	author aw3;	state Exp;
branches;
next	1.136;

1.136
date	2005.06.09.18.08.11;	author katsyonak;	state Exp;
branches;
next	1.135;

1.135
date	2005.05.15.03.36.08;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2005.04.11.16.07.28;	author katsyonak;	state Exp;
branches;
next	1.133;

1.133
date	2005.02.15.13.54.00;	author katsyonak;	state Exp;
branches;
next	1.132;

1.132
date	2005.01.24.03.38.36;	author aw3;	state Exp;
branches;
next	1.131;

1.131
date	2005.01.17.18.34.55;	author katsyonak;	state Exp;
branches;
next	1.130;

1.130
date	2004.10.08.03.28.31;	author dongato;	state Exp;
branches;
next	1.129;

1.129
date	2004.09.13.04.31.51;	author aw3;	state Exp;
branches;
next	1.128;

1.128
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2004.07.24.06.58.33;	author aw3;	state Exp;
branches;
next	1.126;

1.126
date	2004.06.21.17.29.13;	author katsyonak;	state Exp;
branches;
next	1.125;

1.125
date	2004.06.17.12.41.39;	author netwolf1;	state Exp;
branches;
next	1.124;

1.124
date	2004.06.17.06.36.34;	author katsyonak;	state Exp;
branches;
next	1.123;

1.123
date	2004.06.15.05.05.47;	author katsyonak;	state Exp;
branches;
next	1.122;

1.122
date	2004.06.01.22.31.03;	author aw3;	state Exp;
branches;
next	1.121;

1.121
date	2004.05.27.09.47.16;	author katsyonak;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.27.09.24.17;	author katsyonak;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.27.07.40.43;	author katsyonak;	state Exp;
branches;
next	1.118;

1.118
date	2004.05.26.21.37.42;	author katsyonak;	state Exp;
branches;
next	1.117;

1.117
date	2004.05.24.10.42.37;	author katsyonak;	state Exp;
branches;
next	1.116;

1.116
date	2004.05.24.00.57.41;	author katsyonak;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.23.23.40.26;	author katsyonak;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.23.15.00.05;	author katsyonak;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.19.20.33.03;	author katsyonak;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.19.00.47.13;	author katsyonak;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.18.21.47.26;	author katsyonak;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.18.21.07.56;	author katsyonak;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.17.18.07.44;	author katsyonak;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.12.15.35.58;	author katsyonak;	state Exp;
branches;
next	1.107;

1.107
date	2004.05.12.08.10.56;	author netwolf1;	state Exp;
branches;
next	1.106;

1.106
date	2004.05.11.14.03.20;	author katsyonak;	state Exp;
branches;
next	1.105;

1.105
date	2004.05.11.02.56.03;	author aw3;	state Exp;
branches;
next	1.104;

1.104
date	2004.05.11.01.19.15;	author katsyonak;	state Exp;
branches;
next	1.103;

1.103
date	2004.05.10.04.28.39;	author katsyonak;	state Exp;
branches;
next	1.102;

1.102
date	2004.05.10.01.25.32;	author katsyonak;	state Exp;
branches;
next	1.101;

1.101
date	2004.05.07.05.01.41;	author aw3;	state Exp;
branches;
next	1.100;

1.100
date	2004.05.06.01.39.08;	author katsyonak;	state Exp;
branches;
next	1.99;

1.99
date	2004.05.05.15.45.30;	author netwolf1;	state Exp;
branches;
next	1.98;

1.98
date	2004.05.05.15.38.39;	author netwolf1;	state Exp;
branches;
next	1.97;

1.97
date	2004.05.05.02.22.51;	author netwolf1;	state Exp;
branches;
next	1.96;

1.96
date	2004.05.04.23.36.34;	author netwolf1;	state Exp;
branches;
next	1.95;

1.95
date	2004.04.26.14.08.33;	author katsyonak;	state Exp;
branches;
next	1.94;

1.94
date	2004.04.26.06.14.45;	author katsyonak;	state Exp;
branches;
next	1.93;

1.93
date	2004.04.23.22.13.55;	author katsyonak;	state Exp;
branches;
next	1.92;

1.92
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.91;

1.91
date	2004.03.18.15.52.17;	author aw3;	state Exp;
branches;
next	1.90;

1.90
date	2004.03.16.00.42.23;	author aw3;	state Exp;
branches;
next	1.89;

1.89
date	2004.03.15.10.45.27;	author bavariansnail;	state Exp;
branches;
next	1.88;

1.88
date	2004.03.14.20.09.13;	author aw3;	state Exp;
branches;
next	1.87;

1.87
date	2004.02.25.04.48.34;	author aw3;	state Exp;
branches;
next	1.86;

1.86
date	2004.02.15.11.55.58;	author morevit;	state Exp;
branches;
next	1.85;

1.85
date	2004.02.11.04.13.01;	author katsyonak;	state Exp;
branches;
next	1.84;

1.84
date	2004.02.08.22.48.49;	author kush_eplus;	state Exp;
branches;
next	1.83;

1.83
date	2004.02.05.00.00.02;	author kush_eplus;	state Exp;
branches;
next	1.82;

1.82
date	2004.01.31.07.24.00;	author eklmn;	state Exp;
branches;
next	1.81;

1.81
date	2004.01.21.23.20.46;	author dongato;	state Exp;
branches;
next	1.80;

1.80
date	2004.01.20.15.53.33;	author dongato;	state Exp;
branches;
next	1.79;

1.79
date	2004.01.18.13.58.12;	author dongato;	state Exp;
branches;
next	1.78;

1.78
date	2004.01.15.15.30.11;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2004.01.14.16.17.02;	author netwolf1;	state Exp;
branches;
next	1.76;

1.76
date	2004.01.11.14.43.01;	author dongato;	state Exp;
branches;
next	1.75;

1.75
date	2004.01.11.00.04.44;	author netwolf1;	state Exp;
branches;
next	1.74;

1.74
date	2003.11.27.13.57.18;	author eklmn;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.12.14.26.04;	author kuchin;	state Exp;
branches;
next	1.72;

1.72
date	2003.11.04.18.08.24;	author dongato;	state Exp;
branches;
next	1.71;

1.71
date	2003.10.26.14.00.50;	author morevit;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.20.13.20.03;	author morevit;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.13.15.19.04;	author morevit;	state Exp;
branches;
next	1.66;

1.66
date	2003.10.10.19.54.58;	author dongato;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.64;

1.64
date	2003.10.10.06.01.19;	author eklmn;	state Exp;
branches;
next	1.63;

1.63
date	2003.10.05.19.26.52;	author morevit;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.03.23.18.49;	author morevit;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.03.18.08.49;	author dongato;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.02.00.57.32;	author morevit;	state Exp;
branches;
next	1.59;

1.59
date	2003.09.28.13.55.07;	author dongato;	state Exp;
branches;
next	1.58;

1.58
date	2003.09.27.11.13.18;	author morevit;	state Exp;
branches;
next	1.57;

1.57
date	2003.09.26.23.33.54;	author morevit;	state Exp;
branches;
next	1.56;

1.56
date	2003.09.26.12.18.54;	author dongato;	state Exp;
branches;
next	1.55;

1.55
date	2003.09.25.15.50.51;	author morevit;	state Exp;
branches;
next	1.54;

1.54
date	2003.09.25.15.08.55;	author morevit;	state Exp;
branches;
next	1.53;

1.53
date	2003.09.25.13.08.10;	author morevit;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.24.20.37.30;	author dongato;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.24.16.54.47;	author morevit;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.23.16.52.50;	author morevit;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.19.00.13.38;	author morevit;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.13.01.06.06;	author dongato;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.09.16.21.59;	author dongato;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.07.15.02.15;	author kuchin;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.07.13.10.46;	author kuchin;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.07.12.51.12;	author dongato;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.06.19.57.12;	author kuchin;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.06.18.23.57;	author kuchin;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.06.02.19.24;	author dongato;	state Exp;
branches;
next	1.38;

1.38
date	2003.09.06.00.04.21;	author dongato;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.05.11.12.13;	author dongato;	state Exp;
branches;
next	1.36;

1.36
date	2003.09.05.01.02.52;	author dongato;	state Exp;
branches;
next	1.35;

1.35
date	2003.09.04.19.27.33;	author kuchin;	state Exp;
branches;
next	1.34;

1.34
date	2003.09.04.03.53.30;	author dongato;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.15.15.11.29;	author forcha;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.03.20.42.05;	author forcha;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.27.18.15.27;	author netwolf1;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.26.19.23.29;	author eklmn;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.19.09.20.32;	author eklmn;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.06.20.05.30;	author eklmn;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.01.08.59.03;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.27.04.39.51;	author partyckip;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.17.18.08.23;	author netwolf1;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.14.11.19.02;	author kuchin;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.14.09.01.20;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.13.18.59.50;	author moosetea;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.12.15.29.18;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.12.13.22.09;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.03.10.12.19;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.30.12.10.21;	author moosetea;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.16.18.22.56;	author cax2;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2003.03.10.20.10.10;	author cax2;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.08.17.33.33;	author dongato;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.24.16.01.34;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.24.11.10.20;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.23.18.21.18;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.21.12.46.55;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.16.22.01.50;	author lord_kiron;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.14.18.25.36;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.13.19.08.33;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.10.19.24.51;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.10.18.43.26;	author obaldin;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.24.22.07.50;	author maverick65;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.32;	author cax2;	state Exp;
branches;
next	;

1.14.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.180
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "updownclient.h"
#include "TransferWnd.h"
#include "otherfunctions.h"
#include "AddBuddy.h"
#include "CatDialog.h"
#include "IP2Country.h"
#include "TitleMenu.h"
#include "ServerList.h"
#include "UploadQueue.h"
#include "server.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define TRANS_ROLLUP		120
#define TRANS_DOWNLOADLIST	121
#define TRANS_UPLOADLIST	122
#define TRANS_QUEUELIST		123
#define TRANS_INFOLIST		124
#define TRANS_DOWNLOADTABS	125
#define TRANS_TABWINDOW		126
#define TRANS_CLIENTLIST	127
#define TRANS_DUMMY			130


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class CDummyForTabs : public CWnd
{
public:
	CDummyForTabs(){ m_pChild = NULL; }

	void SetChild(CWnd* pChild){ m_pChild = pChild;	}

	CWnd* GetChild(){ return m_pChild; }

	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
	{
		EMULE_TRY
		NMHDR* pNMHDR = (NMHDR*)lParam;
		switch(pNMHDR->code)
		{
		case LVN_ITEMACTIVATE:
		case LVN_COLUMNCLICK:
		case NM_CLICK:
		case NM_DBLCLK:
			break;
		default:
			*pResult = GetParent()->GetParent()->SendMessage(WM_NOTIFY, wParam, lParam);
			return TRUE;
		}
		EMULE_CATCH2
		return CWnd::OnNotify(wParam, lParam, pResult);
	}


	afx_msg void OnSize(UINT nType, int cx, int cy)
	{
		NOPRM(nType); NOPRM(cx); NOPRM(cy);
		EMULE_TRY
		if(m_pChild)
		{
			CRect r;
			GetClientRect(&r);
			r -= CSize(2, 2);
			m_pChild->SetWindowPos(NULL, 0,0, r.Width(), r.Height(), SWP_NOMOVE|SWP_NOZORDER);
		}
		EMULE_CATCH2
	}

	DECLARE_DYNCREATE(CDummyForTabs)
	DECLARE_MESSAGE_MAP()

private:
	CWnd* m_pChild;
};
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CCatTabs::DrawItem(CDC *pDC, int iItem)
{
#define COLORBARHEIGHT	2
#define TRIANGLESIZE	12
//#define TRIANGLESIZE	((rItem.bottom-rItem.top+1)/2)
	CTabs::DrawItem(pDC,iItem);

//	Draw the category color bar for user categories.
	if (iItem >= CCat::GetNumPredefinedCats() && iItem < CCat::GetNumCats())
	{
		CRect		rItem;
		CRect		rClient;
		COLORREF	cr;

		GetClientRect(rClient);
		GetItemRect(iItem, rItem);
#ifdef USE_BAR
#ifndef NEW_LOOK
		rItem.top = rClient.top;
		rItem.bottom = rItem.top + COLORBARHEIGHT;
		cr = CCat::GetCatColorByIndex(iItem);
		pDC->FillSolidRect(&rItem,cr);
#else
		if (iItem == GetCurSel())
		{
			rItem.top = rClient.top;
		}
		rItem.top++;
		rItem.bottom = rItem.top + COLORBARHEIGHT;
		cr = CCat::GetCatColorByIndex(iItem);

		CPen		*pOldPen,barPen;

		barPen.CreatePen(PS_SOLID,0,cr);
		pOldPen = pDC->SelectObject(&barPen);
		pDC->MoveTo(rItem.left+1,rItem.top);
		pDC->LineTo(rItem.right-1,rItem.top);
		pDC->MoveTo(rItem.left,rItem.top+1);
		pDC->LineTo(rItem.right,rItem.top+1);
		pDC->SelectObject(pOldPen);
//		pDC->FillSolidRect(&rItem,cr);
#endif NEW_LOOK

#else
		CBrush		*pOldBrush, newBrush;

		cr = CCat::GetCatColorByIndex(iItem);
		newBrush.CreateSolidBrush(cr);
		pOldBrush = pDC->SelectObject(&newBrush);
		rItem.top = rClient.top;
		pDC->BeginPath();
		pDC->MoveTo(rItem.left + 2, rItem.top + 1);
		pDC->LineTo(rItem.left + 2 + TRIANGLESIZE, rItem.top + 1);
		pDC->LineTo(rItem.left + 2, rItem.top + 1 + TRIANGLESIZE);
		pDC->EndPath();
		pDC->FillPath();
		pDC->SelectObject(pOldBrush);
#endif USE_BAR
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CDummyForTabs, CWnd)

BEGIN_MESSAGE_MAP(CDummyForTabs, CWnd)
	ON_WM_SIZE()
END_MESSAGE_MAP()

BEGIN_MESSAGE_MAP(CTransferWnd, CResizableDialog)
	ON_WM_DESTROY()	// eklmn: bugfix(00): resource cleanup due to CResizableDialog
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()

//	ON_NOTIFY(TCN_SELCHANGE, TRANS_DOWNLOADTABS, OnTcnSelchangeDltab)
//	ON_NOTIFY(NM_RCLICK, TRANS_DOWNLOADTABS, OnNMRClickDltab)
//	ON_NOTIFY(NM_TABMOVED, TRANS_DOWNLOADTABS, OnTabMovement)
// ON_NOTIFY(LVN_BEGINDRAG, TRANS_DOWNLOADLIST, OnLvnBeginDrag)

	ON_WM_LBUTTONDBLCLK()
END_MESSAGE_MAP()

// CTransferWnd dialog

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CTransferWnd, CDialog)
CTransferWnd::CTransferWnd(CWnd* pParent /*=NULL*/)
	: CResizableDialog(CTransferWnd::IDD, pParent)
{
	m_bIsDragging = false;
	m_pwndDummyForDownloadList = NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTransferWnd::~CTransferWnd()
{}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CTransferWnd::OnInitDialog()
{
	EMULE_TRY

	CResizableDialog::OnInitDialog();

	//	Create the Rollup control
	CRect		rRollupArea;

	GetClientRect(&rRollupArea);
	rRollupArea.DeflateRect(8, 5);

	m_ctlRollup.Create(NULL, NULL, WS_CHILD|WS_VISIBLE/*|WS_CLIPCHILDREN*/, rRollupArea, this, TRANS_ROLLUP);

	//	Create the Download-list control
	CWnd		*pParent = &m_ctlRollup;
	CRect		rItem = CRect(0, 0, 0, 0);
	DWORD		dwListStyle = WS_CHILD|WS_BORDER|WS_TABSTOP|LVS_REPORT|LVS_ALIGNLEFT|LVS_OWNERDRAWFIXED|LVS_SINGLESEL;
	DWORD		dwTabStyle = WS_CHILD|WS_VISIBLE|TCS_HOTTRACK|TCS_SINGLELINE|TCS_TOOLTIPS;

	m_pwndDummyForDownloadList = new CDummyForTabs();
	m_pwndDummyForDownloadList->Create(AfxRegisterWndClass(0), _T(""), WS_CHILD|WS_VISIBLE, rItem, pParent, TRANS_DUMMY);

	m_ctlDownloadList.Create(WS_VISIBLE | dwListStyle, rItem, m_pwndDummyForDownloadList, TRANS_DOWNLOADLIST);

	g_App.m_pDownloadList->SetDownloadListCtrl(&m_ctlDownloadList);
	m_ctlUploadList.Create(WS_VISIBLE | dwListStyle, rItem, pParent, TRANS_UPLOADLIST);
	m_ctlQueueList.Create(/*WS_VISIBLE |*/ dwListStyle, rItem, pParent, TRANS_QUEUELIST);
	m_ctlClientList.Create(/*WS_VISIBLE |*/ dwListStyle, rItem, pParent, TRANS_CLIENTLIST);

	g_App.m_pClientList->SetClientListCtrl(&m_ctlClientList);

	m_ctlInfoList.Create(WS_VISIBLE|WS_CHILD|WS_BORDER|WS_TABSTOP|LVS_REPORT|
							LVS_ALIGNLEFT|LVS_SINGLESEL, rItem, pParent, TRANS_INFOLIST);

	m_ctlDLTabs.Create(dwTabStyle, CRect(0, 0, 0, 20), pParent, TRANS_DOWNLOADTABS);
	m_ctlDLTabs.ModifyStyle(WS_CLIPSIBLINGS, 0);
	m_ctlDLTabs.SendMessage(WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT));
	m_ctlDLTabs.SetPadding(CSize(16, 0));

	m_pwndDummyForDownloadList->SetChild(&m_ctlDownloadList);

	AddBuddy(m_pwndDummyForDownloadList->m_hWnd, m_ctlDLTabs.m_hWnd, BDS_TOP);

	CString		strTmp;

	strTmp.Format(GetResString(IDS_RUP_DOWNINFO), g_App.m_pDownloadQueue->GetFileCount(),
						g_App.m_pDownloadQueue->GetActiveFileCount(),
						g_App.m_pDownloadQueue->GetPausedFileCount(),
						g_App.m_pDownloadQueue->GetStoppedFileCount(),
						g_App.m_pDownloadQueue->GetTransferringFiles(),
						static_cast<double>(g_App.m_pDownloadQueue->GetDataRate()) / 1024.0);
	m_ctlRollup.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strTmp, m_pwndDummyForDownloadList, 0, TRUE);

	strTmp.Format(GetResString(IDS_RUP_UPINFO), g_App.m_pUploadQueue->GetWaitingUserCount(),
					  g_App.m_pUploadQueue->GetUploadQueueLength(),
					  g_App.m_pUploadQueue->GetBanCount(),
					  static_cast<double>(g_App.m_pUploadQueue->GetDataRate()) / 1024.0);
	m_ctlRollup.InsertItem(GetResString(IDS_RUP_UPLOADS), strTmp, &m_ctlUploadList, 1, TRUE);
	m_ctlRollup.InsertItem(GetResString(IDS_RUP_INFO), _T(""), &m_ctlInfoList, 2, FALSE);

	AddAnchor(m_ctlRollup.m_hWnd, TOP_LEFT, BOTTOM_RIGHT);

	InitRollupItemHeights();

	m_ctlDownloadList.Init();
	m_ctlUploadList.Init();
	m_ctlQueueList.Init();
	m_ctlClientList.Init();

	m_ctlDownloadList.SetOwner(this);
	m_ctlUploadList.SetOwner(this);
	m_ctlQueueList.SetOwner(this);
	m_ctlClientList.SetOwner(this);
	m_ctlDLTabs.SetOwner(this);

	m_nActiveWnd = MPW_UPLOADLIST;
	m_iTabRightClickIndex = -1;

	//	Initialize the Category tabs
	for (int ix = 0; ix < CCat::GetNumCats(); ix++)
		m_ctlDLTabs.InsertItem(ix,CCat::GetCatByIndex(ix)->GetTitle());

	// List controls & Category tabs tooltips
	m_ttip.Create(this);
	m_ttip.SetDelayTime(TTDT_AUTOPOP, 15000);
	m_ttip.SetDelayTime(TTDT_INITIAL, g_App.m_pPrefs->GetToolTipDelay()*1000);
	m_ttip.SendMessage(TTM_SETMAXTIPWIDTH, 0, SHRT_MAX);
	m_ttip.SetBehaviour(PPTOOLTIP_MULTIPLE_SHOW);
	m_ttip.SetNotify(m_hWnd);
	m_ttip.AddTool(&m_ctlDownloadList, _T(""));
	m_ttip.AddTool(&m_ctlUploadList, _T(""));
	m_ttip.AddTool(&m_ctlQueueList, _T(""));
	m_ttip.AddTool(&m_ctlClientList, _T(""));
	m_ttip.AddTool(&m_ctlDLTabs, _T(""));

	EMULE_CATCH

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Resource cleanup due to CResizableDialog
void CTransferWnd::OnDestroy()
{
	if(m_pwndDummyForDownloadList)
	{
		m_pwndDummyForDownloadList->DestroyWindow();
		delete m_pwndDummyForDownloadList;
	}
	CResizableDialog::OnDestroy();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::DoDataExchange(CDataExchange* pDX)
{
	CResizableDialog::DoDataExchange(pDX);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// CTransferWnd message handlers
BOOL CTransferWnd::PreTranslateMessage(MSG* pMsg)
{
	if (g_App.m_pPrefs->GetToolTipDelay() != 0)
	{
		switch (pMsg->message)
		{
			case WM_LBUTTONDOWN:
			case WM_LBUTTONUP:
			case WM_RBUTTONDOWN:
			case WM_RBUTTONUP:
			case WM_MOUSEMOVE:
			case WM_MOUSEWHEEL:
			case WM_KEYDOWN:
			case WM_SYSKEYDOWN:
				m_ttip.RelayEvent(pMsg);
		}
	}

	if (pMsg->message == WM_LBUTTONDBLCLK)
	{
		if (pMsg->hwnd == m_ctlDLTabs.GetSafeHwnd())
		{
			POINT point;

			::GetCursorPos(&point);

			CPoint pt(point);

			if (GetTabUnderMouse(&pt) != -1)
			{
				OnDblClickDltab();
				return TRUE;
			}
		}
	}
	else if (pMsg->message == WM_MBUTTONUP)
	{
	//	If we are in Download list, display user or file details
		int iSel = GetItemUnderMouse(&m_ctlDownloadList);

		if (iSel != -1)
		{
			m_ctlDownloadList.ShowSelectedFileOrUserDetails();
		}
		else 
		{
			switch (m_nActiveWnd)
			{
				case MPW_UPLOADQUEUELIST:
					m_ctlQueueList.ShowSelectedUserDetails();
					break;

				case MPW_UPLOADLIST:
					m_ctlUploadList.ShowSelectedUserDetails();
					break;

				case MPW_UPLOADCLIENTLIST:
					m_ctlClientList.ShowSelectedUserDetails();
					break;
			}
		}
		return TRUE;
	}
	else if(pMsg->message == USRMSG_SWITCHUPLOADLIST)
		SwitchUploadList();

	return CResizableDialog::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void  CTransferWnd::GetInfo4ToolTip(NM_PPTOOLTIP_DISPLAY *pNotify)
{
	EMULE_TRY

	int						iControlId = CWnd::FromHandle(pNotify->ti->hWnd)->GetDlgCtrlID();

	if (iControlId == NULL)
		return;

	CString strInfo;

	switch (iControlId)
	{
		case TRANS_DOWNLOADTABS:
		{
			CPoint	ptLoc(*pNotify->pt);
			int		iIndex = GetTabUnderMouse(&ptLoc);

			if (iIndex < 0)
				return;

			uint32		dwCount = 0, dwTransferring = 0, dwPaused = 0, dwStopped = 0;
			double		dblSpeed = 0.0;
			uint64		qwSize = 0, qwCompletedSize = 0, qwRealSize = 0;
			CPartFile	*pPartFile;
			CString		strCatTitle;
			CCat		*pCat = CCat::GetCatByIndex(iIndex);

			if (iIndex != 0 || CCat::GetAllCatType() == CAT_ALL)
				strCatTitle = pCat->GetTitle();
			else
				strCatTitle = _T("[") + CCat::GetPredefinedCatTitle(CCat::GetAllCatType()) + _T("]");

			if (pCat->GetID() < CAT_PREDEFINED)
				strInfo.Format(_T("<cat=0x%06x>"), CCat::GetCatColorByIndex(iIndex));

			for (int i = 0; i < g_App.m_pDownloadQueue->GetFileCount(); i++)
			{
				pPartFile = g_App.m_pDownloadQueue->GetFileByIndex(i);

				if (pPartFile != NULL)
				{
					if (CCat::FileBelongsToGivenCat(pPartFile, CCat::GetCatIDByIndex(iIndex)))
					{
						dwCount++;
						if (pPartFile->GetTransferringSrcCount() > 0)
							dwTransferring++;
						if (pPartFile->IsPaused() && !pPartFile->IsStopped())
							dwPaused++;
						if (pPartFile->IsStopped())
							dwStopped++;
						dblSpeed += pPartFile->GetDataRate() / 1024.0f;
						qwSize += pPartFile->GetFileSize();
						qwCompletedSize += pPartFile->GetCompletedSize();
						qwRealSize += pPartFile->GetRealFileSize();
					}
				}
			}

			if (!pCat->GetComment().IsEmpty())
			{
				strCatTitle += _T(" (");
				strCatTitle += pCat->GetComment();
				strCatTitle += _T(")");
			}
			strCatTitle.Replace(_T("\n"), _T("<br>"));
			strCatTitle.Replace(_T("<"), _T("<<"));

			strInfo.AppendFormat(_T("<b>%s</b><br><hr=100%%><br><b>%s:</b><t>%u / %u<br><b>%s:</b><t>%u<br><b>%s:</b><t>%u<br><b>%s:</b><t>%.1f %s<br><b>%s:</b><t>%s / %s<br><b>%s:</b><t>%s<br><b>%s</b><t>%s<br><b>%s</b><t>%s"),
				strCatTitle,
				GetResString(IDS_DOWNLOADING), dwTransferring, (dwCount - dwPaused - dwStopped),
				GetResString(IDS_PAUSED), dwPaused, GetResString(IDS_STOPPED), dwStopped,
				GetResString(IDS_DL_SPEED), dblSpeed, GetResString(IDS_KBYTESEC),
				GetResString(IDS_DL_SIZE), CastItoXBytes(qwCompletedSize), CastItoXBytes(qwSize),
				GetResString(IDS_SIZE_ON_DISK), CastItoXBytes(qwRealSize),
				GetResString(IDS_PW_INCOMING), pCat->GetPath(),
				GetResString(IDS_PW_TEMP), pCat->GetTempPath());
			break;
		}
		case TRANS_DOWNLOADLIST:
		{
			if (m_ctlDownloadList.GetItemCount() < 1)
				return;

			int		iSel = GetItemUnderMouse(&m_ctlDownloadList);

			if (iSel < 0 || iSel == 65535)
				return;

			//	Build info text and display it
			CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(m_ctlDownloadList.GetItemData(iSel));
			CPartFileDLItem		*pPartFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
			CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);

			if (pPartFileItem != NULL)
			{
				CPartFile		*pPartFile = pPartFileItem->GetFile();
				SHFILEINFO		shfi;

				strInfo = pPartFile->GetDownloadFileInfo4Tooltips();
				memzero(&shfi, sizeof(shfi));
				SHGetFileInfo(pPartFile->GetFileName(),	FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi),	SHGFI_ICON | SHGFI_USEFILEATTRIBUTES);
				pNotify->ti->hIcon = shfi.hIcon;
			}
			else if (pSourceItem != NULL)
			{
#ifdef OLD_SOCKETS_ENABLED
				bool				bA4AF = pSourceItem->IsAskedForAnotherFile();
				CUpDownClient	    *pSource = pSourceItem->GetSource();
				CString				strTmp, strUserName = pSource->GetUserName();

				strUserName.Trim();
				strUserName.Replace(_T("\n"), _T("<br>"));
				strUserName.Replace(_T("<"), _T("<<"));

				if (g_App.m_pIP2Country->IsIP2Country())
					strTmp.Format(_T(" (<b>%s</b>)"), pSource->GetCountryName());

				strInfo.Format(_T("<t=1><b>%s</b><br><t=1>%s: %u%s<br><hr=100%%><br><b>%s:<t></b>%s:%u (<b>%s</b>)"),
					strUserName, GetResString(IDS_USERID), pSource->GetUserIDHybrid(), strTmp,
					GetResString(IDS_CLIENT), pSource->GetFullIP(), pSource->GetUserPort(), pSource->GetFullSoftVersionString());

				CServer *pCurSrv, *pSrv = g_App.m_pServerList->GetServerByIPTCP(pSource->GetServerIP(), pSource->GetServerPort());

				if (pSrv != NULL)
				{
					strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s:%u"), GetResString(IDS_SERVER), ipstr(pSource->GetServerIP()), pSource->GetServerPort());

					strTmp = pSrv->GetListName();
					strTmp.Replace(_T("<"), _T("<<"));
					strTmp.Replace(_T("\n"), _T("<br>"));
					if (!strTmp.IsEmpty())
					{
						strInfo += _T(" (<b>");
						strInfo += strTmp;
						strInfo += _T("</b>)");
					}
				}
				
				if (pSource->Credits() != NULL && pSource->Credits()->GetUploadedTotal() != pSource->GetTransferredUp())
					strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_DDATA), CastItoXBytes(pSource->GetTransferredUp()), CastItoXBytes(pSource->Credits()->GetUploadedTotal()));
				else if (pSource->GetTransferredUp() > 0)
					strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_DDATA), CastItoXBytes(pSource->GetTransferredUp()));

				if (pSource->Credits() != NULL && pSource->Credits()->GetDownloadedTotal() != pSource->GetTransferredDown())
					strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_UDATA), CastItoXBytes(pSource->GetTransferredDown()), CastItoXBytes(pSource->Credits()->GetDownloadedTotal()));
				else if (pSource->GetTransferredDown() > 0)
					strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_UDATA), CastItoXBytes(pSource->GetTransferredDown()));

				strInfo.AppendFormat(_T("<br><b>%s:<t></b>%d"),	GetResString(IDS_TT_ASKEDCOUNT), pSource->GetAskedCountDown());

				pCurSrv = g_App.m_pServerConnect->GetCurrentServer();
				if ( (pSource->GetDownloadState() == DS_ONQUEUE) || ( (pSource->GetDownloadState() == DS_NONEEDEDPARTS) && 
					(!pSource->HasLowID() || ((pCurSrv != NULL) && (pCurSrv->GetIP() == pSource->GetServerIP()))) ) )
				{
					if (pSource->IsUDPFileReqPending())
						strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_NEXT_ASK), GetResString(IDS_ASKING));
					else
					{
						uint32 	dwFileReaskTime = pSource->GetNextFileReaskTime();
						uint32 	dwCurTick = ::GetTickCount();

						if (dwCurTick <= dwFileReaskTime)
							strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_NEXT_ASK), CastSecondsToHM((dwFileReaskTime - dwCurTick) / 1000));
					}
				}

				strInfo.AppendFormat(_T("<br><b>%s:<t></b>%d"),	GetResString(IDS_TT_AVAILABLEPARTS), pSource->GetAvailablePartCount());

				if (!bA4AF)
				{
					if (!pSource->IsClientFilenameEmpty())
						strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_TT_CLIENTSOURCENAME), pSource->GetClientFilename());
				}
				else	//	If Asked For Another File...
				{
					try
					{
						strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_ASKED4ANOTHERFILE), pSource->m_pReqPartFile->GetFileName());
					}
					catch(...)
					{
					}
				}
				//-For File Comment-//
				try
				{
					if (!bA4AF)
					{
						if (!pSource->IsFileCommentEmpty())
							strInfo.AppendFormat(_T("<br><hr=100%%><br><b>%s</b><t>%s<br>"), GetResString(IDS_CMT_READ), pSource->GetFileComment());
						else
							strInfo.AppendFormat(_T("<br><hr=100%%><br>%s<br>"), GetResString(IDS_CMT_NONE));

						if (pSource->GetFileRating() == PF_RATING_NONE)
							strInfo += GetRatingString(pSource->GetFileRating());
						else
							strInfo.AppendFormat(_T("<b>%s:</b><t>%s"), GetResString(IDS_TT_CMT_RATING), GetRatingString(pSource->GetFileRating()));
					}
				}
				catch(...)
				{
					//Information not received = not connected or connecting
					strInfo.AppendFormat(_T("<br><hr=100%%><br>%s"), GetResString(IDS_CMT_NOTCONNECTED));
				}

			// Set the tooltip icon
				pNotify->ti->hIcon =
					g_App.m_pMDlg->m_clientImgLists[CLIENT_IMGLST_PLAIN].ExtractIcon(pSource->GetClientIconIndex());
#endif //OLD_SOCKETS_ENABLED
			}
			break;
		}
		case TRANS_UPLOADLIST:
		{
			if (m_ctlUploadList.GetItemCount() < 1)
				return;

			int		iSel = GetItemUnderMouse(&m_ctlUploadList);

			if (iSel < 0 || iSel == 65535)
				return;

			CUpDownClient *pSource = (CUpDownClient*)m_ctlUploadList.GetItemData(iSel);

			pNotify->ti->hIcon = pSource->GetClientInfo4Tooltips(strInfo, true);
			break;
		}
		case TRANS_QUEUELIST:
		{
			if (m_ctlQueueList.GetItemCount() < 1)
				return;

			int		iSel = GetItemUnderMouse(&m_ctlQueueList);

			if (iSel < 0 || iSel == 65535)
				return;

			CUpDownClient *pSource = (CUpDownClient*)m_ctlQueueList.GetItemData(iSel);

			pNotify->ti->hIcon = pSource->GetClientInfo4Tooltips(strInfo);
			break;
		}
		case TRANS_CLIENTLIST:
		{
			if (m_ctlClientList.GetItemCount() < 1)
				return;

			int		iSel = GetItemUnderMouse(&m_ctlClientList);

			if (iSel < 0 || iSel == 65535)
				return;

			CUpDownClient *pSource = (CUpDownClient*)m_ctlClientList.GetItemData(iSel);

			pNotify->ti->hIcon = pSource->GetClientInfo4Tooltips(strInfo);
			break;
		}
	}

	pNotify->ti->sTooltip = strInfo;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SwitchUploadList() toggles the visibility of the UploadList with the UploadQueueList
void CTransferWnd::SwitchUploadList()
{
	EMULE_TRY

	switch (m_nActiveWnd)
	{
		case MPW_UPLOADLIST:
		{
			m_nActiveWnd = MPW_UPLOADQUEUELIST;
			m_ctlRollup.SetText(1, GetResString(IDS_ONQUEUE), true);
			m_ctlUploadList.ShowWindow(SW_HIDE);
			m_ctlClientList.ShowWindow(SW_HIDE);
			m_ctlRollup.SetItemClient(1, &m_ctlQueueList);
			m_ctlRollup.Invalidate();
			UpdateQueueFilter();
			break;
		}
		case MPW_UPLOADQUEUELIST:
		{
			m_nActiveWnd = MPW_UPLOADCLIENTLIST;
			UpdateKnown();
			m_ctlUploadList.ShowWindow(SW_HIDE);
			m_ctlQueueList.ShowWindow(SW_HIDE);
			m_ctlRollup.SetItemClient(1, &m_ctlClientList);
			m_ctlRollup.Invalidate();
			break;
		}
		case MPW_UPLOADCLIENTLIST:
		{
			m_nActiveWnd = MPW_UPLOADLIST;
			m_ctlRollup.SetText(1, GetResString(IDS_RUP_UPLOADS), true);
			m_ctlQueueList.ShowWindow(SW_HIDE);
			m_ctlClientList.ShowWindow(SW_HIDE);
			m_ctlRollup.SetItemClient(1, &m_ctlUploadList);
			m_ctlRollup.Invalidate();
			break;
		}
		default:
			break;
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Update Known Clients on header when total number of known clients changed
void CTransferWnd::UpdateKnown()
{
	if(m_nActiveWnd == MPW_UPLOADCLIENTLIST)
	{
		CString	strBuf = GetResString(IDS_CLIENTLIST);

		strBuf.AppendFormat(_T(" (%u)"), m_ctlClientList.GetItemCount());
		m_ctlRollup.SetText(1, strBuf, true);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Update Applied Filter on header when filter changes (triggered in QueueListCtrl)
void CTransferWnd::UpdateQueueFilter()
{
	static const uint16 auResStr[] = {
		IDS_BANNED,		//CLI_FILTER_BANNED
		IDS_FRIENDS,	//CLI_FILTER_FRIEND
		IDS_WITHCREDITS	//CLI_FILTER_CREDIT
	};

	if (m_nActiveWnd == MPW_UPLOADQUEUELIST)
	{
		CString	strBuffer = GetResString(IDS_ONQUEUE);

		if (static_cast<unsigned>(m_ctlQueueList.m_iClientFilter - CLI_FILTER_BANNED) < ARRSIZE(auResStr))
			strBuffer.AppendFormat(_T(" (%s)"), GetResString(auResStr[m_ctlQueueList.m_iClientFilter - CLI_FILTER_BANNED]));

		m_ctlRollup.SetText(1, strBuffer, true);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Localize() loads localized text for the UI resources
void CTransferWnd::Localize()
{
	EMULE_TRY

	switch(m_nActiveWnd)
	{
		case MPW_UPLOADLIST:
			m_ctlRollup.SetText(1,GetResString(IDS_RUP_UPLOADS), true);
			break;
		case MPW_UPLOADQUEUELIST:
			UpdateQueueFilter();
			break;
		case MPW_UPLOADCLIENTLIST:
			UpdateKnown();
			break;
	}

//	Localize the rollup control
	m_ctlRollup.SetText(0, GetResString(IDS_RUP_DOWNLOADS), true);
	m_ctlRollup.SetText(2, GetResString(IDS_RUP_INFO), true);
	UpdateInfoHeader();

	m_ctlDownloadList.Localize();
	m_ctlUploadList.Localize();
	m_ctlQueueList.Localize();
	m_ctlClientList.Localize();
	m_ctlInfoList.Localize();

	CString  strCatTitle;

	for (byte i = 0; i < CCat::GetNumPredefinedCats(); i++)
	{
		if (i == 0)
		{
			_EnumCategories eCatID = CCat::GetAllCatType();

			strCatTitle = CCat::GetPredefinedCatTitle(eCatID);
			if (eCatID != CAT_ALL)
			{
				strCatTitle = _T('[') + strCatTitle;
				strCatTitle += _T(']');
			}
			CCat::GetCatByIndex(i)->SetTitle(GetResString(IDS_CAT_ALL));
		}
		else
		{
			strCatTitle = CCat::GetPredefinedCatTitle(CCat::GetCatIDByIndex(i));
			CCat::GetCatByIndex(i)->SetTitle(strCatTitle);
		}

		EditCatTabLabel(i, strCatTitle);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	UpdateDownloadHeader() updates the information displayed in the right side of the DownloadList rollup bar
void CTransferWnd::UpdateDownloadHeader()
{
	EMULE_TRY

	CString strBuffer;

	strBuffer.Format( GetResString(IDS_RUP_DOWNINFO),
					g_App.m_pDownloadQueue->GetFileCount(),
					g_App.m_pDownloadQueue->GetActiveFileCount(),
					g_App.m_pDownloadQueue->GetPausedFileCount(),
					g_App.m_pDownloadQueue->GetStoppedFileCount(),
					g_App.m_pDownloadQueue->GetTransferringFiles(),
					static_cast<double>(g_App.m_pDownloadQueue->GetDataRate())/1024.0 );
	m_ctlRollup.SetText(0, strBuffer);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	UpdateUploadHeader() updates the information displayed in the right side of the UploadList rollup bar
void CTransferWnd::UpdateUploadHeader()
{
	EMULE_TRY

	CString strBuffer;

	strBuffer.Format( GetResString(IDS_RUP_UPINFO),
					  g_App.m_pUploadQueue->GetWaitingUserCount(),
						g_App.m_pUploadQueue->GetUploadQueueLength(),
							g_App.m_pUploadQueue->GetBanCount(),
								static_cast<double>(g_App.m_pUploadQueue->GetDataRate())/1024.0);
	m_ctlRollup.SetText(1, strBuffer);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	UpdateInfoHeader() updates the information displayed in the right side of the InfoList rollup bar
void CTransferWnd::UpdateInfoHeader()
{
	EMULE_TRY

	CString strInfoHeader;

	switch (m_ctlInfoList.GetType())
	{
		case INFOLISTTYPE_SOURCE:
			strInfoHeader.Format(GetResString(IDS_RUP_INFOUSER), m_ctlInfoList.GetName());
			break;
		case INFOLISTTYPE_FILE:
			strInfoHeader.Format(GetResString(IDS_RUP_INFOFILE), m_ctlInfoList.GetName());
			break;
	}

	m_ctlRollup.SetText(2, strInfoHeader);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::InitRollupItemHeights()
{
	static const double s_adDefItemHeights[3][8] =
	{
		{ 0, 100, 0, 70, 0, 70, 0, 50 },
		{ 0, 0, 100, 30, 0, 0, 70, 25 },
		{ 0, 0, 0, 0, 100, 30, 30, 25 }
	};

	EMULE_TRY

	double	(*padItemHeights)[8] = (double(*)[8])g_App.m_pPrefs->GetRollupPosPtr();
	double	(*padHeights)[8];
	bool	*pbState, bZero, bUseDefault = false;

	for (int exp = 0; exp < 8; exp++)
	{
		double dTotHeight = 0.0;

		for (int i = 0; i < 3; i++)
		{
			bZero = (padItemHeights[i][exp] == 0);
		//	Protect against wrong values
			if (!bZero && (padItemHeights[i][exp] < 7))
			{
				bUseDefault = true;
				break;
			}
		//	Total up the percentages of expanded sub-panes, collapsed ones have to be zero
			if ((exp & (1 << i)) != 0)
				dTotHeight += padItemHeights[i][exp];
			else if (!bZero)
			{
				bUseDefault = true;
				break;
			}
		}
		if (bUseDefault)
			break;

	//	If the percentages don't total up to 100 (except 0 when all are disabled)...
		if ((dTotHeight <= 99 || dTotHeight >= 101) && (dTotHeight != 0 || exp != 0))
		{
			bUseDefault = true;
			break;
		}
	}

//	Restore the user's last expansion state
	if (!bUseDefault)
	{
		pbState = g_App.m_pPrefs->GetRollupStatePtr();
		for (int i = 0; i < 3; i++)
			m_ctlRollup.ExpandItem(i, pbState[i]);
	}

	padHeights = (bUseDefault) ? (double (*)[8])s_adDefItemHeights : padItemHeights;

	m_ctlRollup.SetItemHeights(0, padHeights[0], sizeof(*padHeights));
	m_ctlRollup.SetItemHeights(1, padHeights[1], sizeof(*padHeights));
	m_ctlRollup.SetItemHeights(2, padHeights[2], sizeof(*padHeights));

	m_ctlInfoList.SetColumn(g_App.m_pPrefs->GetDetailColumnWidth());

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::SaveRollupItemHeights()
{
	EMULE_TRY

//	Don't try to save if objects weren't created
	if (m_ctlRollup.GetCount() >= 3)
	{
		double	(*padItemHeights)[8] = (double(*)[8])g_App.m_pPrefs->GetRollupPosPtr();
		double	f1, f2, f3;

		for (int exp = 0; exp < 8; exp++)
		{
			f1 = m_ctlRollup.GetItem(0)->adSizes[exp];
			f2 = m_ctlRollup.GetItem(1)->adSizes[exp];
			f3 = m_ctlRollup.GetItem(2)->adSizes[exp];

			// get rid off some rounding errors
			if(f3)
				f3 = f1 ? (f2 ? (100 - f1 - f2) : (100 - f1)) : (100 - f2);
			else if(f2)
				f2 = 100 - f1;

			padItemHeights[0][exp] = f1;
			padItemHeights[1][exp] = f2;
			padItemHeights[2][exp] = f3;
		}
			
		bool	*pbState = g_App.m_pPrefs->GetRollupStatePtr();

		pbState[0] = m_ctlRollup.GetItem(0)->pHeader->IsExpanded();
		pbState[1] = m_ctlRollup.GetItem(1)->pHeader->IsExpanded();
		pbState[2] = m_ctlRollup.GetItem(2)->pHeader->IsExpanded();

		g_App.m_pPrefs->SetDetailColumnWidth(m_ctlInfoList.GetColumn());
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CTransferWnd::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (wParam >= MP_CAT_SET_0 && wParam <= MP_CAT_SET_LAST)
	{
		EnumCategories		eCatID = static_cast<_EnumCategories>(static_cast<int>(CAT_PREDEFINED) + (wParam - MP_CAT_SET_0));

		CCat::SetAllCatType(eCatID);
		m_ctlDLTabs.SetCurSel(0);
		m_ctlDownloadList.ChangeCategoryByIndex(0);
		if (eCatID == CAT_ALL)
			EditCatTabLabel(0, CCat::GetPredefinedCatTitle(CCat::GetAllCatType()));
		else
			EditCatTabLabel(0, _T("[")+CCat::GetPredefinedCatTitle(CCat::GetAllCatType())+_T("]"));
		return TRUE;
	}
	if (wParam >= MP_SHOWPREDEFINEDCAT_0 && wParam <= MP_SHOWPREDEFINEDCAT_LAST)
	{
		int					iCatPos = wParam - MP_SHOWPREDEFINEDCAT_0;
		EnumCategories		eCatID = static_cast<_EnumCategories>(iCatPos + CAT_PREDEFINED);
		int					iCatIndex = CCat::GetCatIndexByID(eCatID);

	//	If the predefined cat isn't in...
		if (iCatIndex == -1)
		{
			AddPredefinedCategory(eCatID);
			g_App.m_pPrefs->SaveCats();
		}
		else
		{
			CCat::RemoveCatByIndex(iCatIndex);
			m_ctlDLTabs.DeleteItem(iCatIndex);
			m_ctlDLTabs.SetCurSel(0);
			m_ctlDownloadList.ChangeCategoryByID(CAT_ALL);
			g_App.m_pPrefs->SaveCats();
		}
		UpdateCatTabTitles();
		return TRUE;
	}

	switch (wParam)
	{
		case USRMSG_SWITCHUPLOADLIST:
			SwitchUploadList();
			break;

		case USRMSG_CLEARCOMPLETED:
			g_App.m_pDownloadList->ClearCompleted(CAT_NONE);
			break;

		case MP_CAT_ADD:
		{
			int newindex = AddCategory(_T("?"), g_App.m_pPrefs->GetIncomingDir(), g_App.m_pPrefs->GetTempDir(), _T(""), _T(""), true);
			CCatDialog dialog(newindex);

			if (dialog.DoModal() == IDCANCEL)
			{
				CCat::RemoveCatByIndex(newindex);
				m_ctlDLTabs.DeleteItem(newindex);
				m_ctlDLTabs.SetCurSel(0);
				m_ctlDownloadList.ChangeCategoryByIndex(0);
				g_App.m_pPrefs->SaveCats();
				if (CCat::GetNumCats() == 1)
				{
					CCat::SetAllCatType(CAT_ALL);
				}
				g_App.m_pMDlg->m_dlgSearch.UpdateCatTabs();
			}
			else
			{
				g_App.m_pMDlg->m_dlgSearch.UpdateCatTabs();
				EditCatTabLabel(newindex, CCat::GetCatByIndex(newindex)->GetTitle());
				g_App.m_pPrefs->SaveCats();
			}
			break;
		}

		case MP_CAT_EDIT:
		{
			CCatDialog		dialog(m_iTabRightClickIndex);

			dialog.DoModal();

			CString csName = CCat::GetCatByIndex(m_iTabRightClickIndex)->GetTitle();

			EditCatTabLabel(m_iTabRightClickIndex, csName);
			g_App.m_pMDlg->m_dlgSearch.UpdateCatTabs();
			g_App.m_pPrefs->SaveCats();
			break;
		}
		case MP_CAT_REMOVE:
		{
			g_App.m_pDownloadQueue->ResetCatParts(m_iTabRightClickIndex);
			CCat::RemoveCatByIndex(m_iTabRightClickIndex);
			m_ctlDLTabs.DeleteItem(m_iTabRightClickIndex);
			m_ctlDLTabs.SetCurSel(0);
			m_ctlDownloadList.ChangeCategoryByID(CAT_ALL);
			g_App.m_pPrefs->SaveCats();
			if (CCat::GetNumCats() == 1)
			{
				CCat::SetAllCatType(CAT_ALL);
			}
			g_App.m_pMDlg->m_dlgSearch.UpdateCatTabs();
			break;
		}
		case MP_PRIOLOW:
			g_App.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_LOW);
			break;

		case MP_PRIONORMAL:
			g_App.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_NORMAL);
			break;

		case MP_PRIOHIGH:
			g_App.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_HIGH);
			break;

		case MP_PRIOAUTO:
			g_App.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_AUTO);
			break;

		case MP_PAUSE:
			g_App.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_PAUSE);
			break;

		case MP_STOP:
			g_App.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_STOP);
			break;

		case MP_CANCEL:
			if (AfxMessageBox(GetResString(IDS_Q_CANCELDL),MB_ICONQUESTION|MB_YESNO) == IDYES)
				g_App.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex, MP_CANCEL);
			break;

		case MP_RESUME:
			g_App.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_RESUME);
			break;

		case MP_RESUMENEXT:
			g_App.m_pDownloadQueue->StartNextFile(CCat::GetCatIDByIndex(m_iTabRightClickIndex));
			break;

		default:
			break;
	}

	return CResizableDialog::OnCommand(wParam, lParam);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetTabUnderMouse() returns the index of the category tab at point 'point' or -1 if there is none.
int CTransferWnd::GetTabUnderMouse(CPoint* point)
{
	TCHITTESTINFO hitinfo;
	CRect rect;

	m_ctlDLTabs.GetWindowRect(&rect);
	point->Offset(0-rect.left,0-rect.top);
	hitinfo.pt = *point;

	if(m_ctlDLTabs.GetItemRect( 0, &rect ))
	{
		if(hitinfo.pt.y< rect.top+30 && hitinfo.pt.y >rect.top-30)
		{
			hitinfo.pt.y = rect.top;
		}
	}

	// Find the destination tab...
	unsigned int		nTab = m_ctlDLTabs.HitTest(&hitinfo);

	if (hitinfo.flags != TCHT_NOWHERE)
		return nTab;
	else
		return -1;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	OnTcnSelchangeDltab() is the message handler for selection changes in the category tab
void CTransferWnd::OnTcnSelchangeDltab(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pNMHDR);

	m_ctlDownloadList.ChangeCategoryByIndex(m_ctlDLTabs.GetCurSel());
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	OnNMRClickDltab() is the right-click message handler for the tab control.
//	Popup menu for the category tabs
void CTransferWnd::OnNMRClickDltab(NMHDR *pNMHDR, LRESULT *pResult)
{
	static const uint16 s_auViewRes[] = {
		IDS_CAT_ALL,
		IDS_CAT_UNCATEGORIZED,
		0,
		IDS_CAT_INCOMPLETE,
		IDS_COMPLETE,
		IDS_WAITING,
		IDS_DOWNLOADING,
		IDS_ERRORLIKE,
		IDS_PAUSED,
		IDS_STOPPED,
		IDS_STALLED,
		IDS_ST_ACTIVE,
		IDS_ST_INACTIVE,
		0,
		IDS_VIDEO,
		IDS_AUDIO,
		IDS_SEARCH_ARC,
		IDS_SEARCH_CDIMG
	};
	CTitleMenu	menu;
	POINT		point;
	NOPRM(pNMHDR);

	::GetCursorPos(&point);

	CPoint		pt(point);
	CMenu		menuView, menuCat, menuPriority;

	menuPriority.CreateMenu();
	menuPriority.AppendMenu(MF_STRING, MP_PRIOLOW, GetResString(IDS_PRIOLOW));
	menuPriority.AppendMenu(MF_STRING, MP_PRIONORMAL, GetResString(IDS_PRIONORMAL));
	menuPriority.AppendMenu(MF_STRING, MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
	menuPriority.AppendMenu(MF_STRING, MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));

	menu.CreatePopupMenu();
	menu.AddMenuTitle(GetResString(IDS_CAT));

	m_iTabRightClickIndex = GetTabUnderMouse(&pt);

	if (m_iTabRightClickIndex == 0)
	{
		unsigned	ui, uiMenuID;
		CString		strRes;

		menuView.CreateMenu();
		for (uiMenuID = MP_CAT_SET_0, ui = 0; ui < ARRSIZE(s_auViewRes); ui++)
		{
			if (s_auViewRes[ui] != 0)
			{
				::GetResString(&strRes, s_auViewRes[ui]);
				menuView.AppendMenu(MF_STRING, uiMenuID++, strRes);
			}
			else
				menuView.AppendMenu(MF_SEPARATOR);
		}
		menuView.CheckMenuItem(MP_CAT_SET_0 + CCat::GetAllCatType() - CAT_PREDEFINED, MF_CHECKED | MF_BYCOMMAND);

		menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)menuView.m_hMenu, GetResString(IDS_CHANGECATVIEW));
	}

	int			iNumPredefinedCats = CCat::GetNumPredefinedCats();
	UINT		dwPredefinedCatActionFlag = (m_iTabRightClickIndex < iNumPredefinedCats) ? MF_GRAYED : MF_STRING;
	UINT		dwIsAllOrUserFlag = ((m_iTabRightClickIndex < iNumPredefinedCats) && !(m_iTabRightClickIndex == 0 && CCat::GetAllCatType() == CAT_ALL))? MF_GRAYED : MF_STRING;

	if (m_iTabRightClickIndex < iNumPredefinedCats)
	{
		menuCat.CreateMenu();
		for (int i = 0; i < CAT_TOTALPREDEFINEDCATS; i++)
		{
		//	Check to see if the cat has a tab and check the menu item if so
			int		catIndex = CCat::GetCatIndexByID(static_cast<_EnumCategories>(static_cast<int>(CAT_PREDEFINED) + i));
			UINT	checkFlag = (catIndex == -1) ? MF_UNCHECKED : MF_CHECKED;

			if (i == 0)
				checkFlag |= MF_GRAYED;

		//	Add the 'i'th predefined category title
			menuCat.AppendMenu( MF_STRING | checkFlag,
								  MP_SHOWPREDEFINEDCAT_0 + i,
								  CCat::GetPredefinedCatTitle(static_cast<_EnumCategories>(static_cast<int>(CAT_PREDEFINED) + i)) );

		//	Add a seperator after the last of the status categories.
			if (CAT_PREDEFINED + i == CAT_LASTSTATUSCAT)
			{
				menuCat.AppendMenu(MF_SEPARATOR);
			}
		}
		menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)menuCat.m_hMenu, GetResString(IDS_CAT_SHOWSTATUSTAB));
		menu.AppendMenu(MF_SEPARATOR);
	}

	menu.AppendMenu(MF_STRING,MP_CAT_ADD,GetResString(IDS_CAT_ADD));
	menu.AppendMenu(dwPredefinedCatActionFlag, MP_CAT_EDIT, GetResString(IDS_CAT_EDIT));
	menu.AppendMenu(dwPredefinedCatActionFlag, MP_CAT_REMOVE, GetResString(IDS_CAT_REMOVE));
	menu.AppendMenu(MF_SEPARATOR);
	menu.AppendMenu(dwIsAllOrUserFlag|MF_POPUP, (UINT_PTR)menuPriority.m_hMenu, GetResString(IDS_PRIORITY));

	menu.AppendMenu(MF_STRING,MP_CANCEL,GetResString(IDS_MAIN_BTN_CANCEL));
	menu.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_STOP_VERB));
	menu.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_PAUSE_VERB));
	menu.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_RESUME));
	menu.AppendMenu(MF_STRING,MP_RESUMENEXT, GetResString(IDS_DL_RESUMENEXT));

	menu.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);

//	Menu objects are destroyed in their destructor

	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::OnLvnBeginDrag(NMHDR *pNMHDR, LRESULT *pResult)
{
	int iSel = m_ctlDownloadList.GetSelectionMark();

	if (iSel == -1)
		return;

	CMuleCtrlItem	   *pItem = reinterpret_cast<CMuleCtrlItem*>(m_ctlDownloadList.GetItemData(iSel));
	CPartFileDLItem	   *pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

	if (pFileItem == NULL)
		return;

	m_bIsDragging = true;

	POINT pt;

	::GetCursorPos(&pt);

	LPNMLISTVIEW pNMLV = reinterpret_cast<LPNMLISTVIEW>(pNMHDR);

	m_pDragImage = m_ctlDownloadList.CreateDragImage(m_ctlDownloadList.GetSelectionMark(),&pt);
    m_pDragImage->BeginDrag(0, CPoint(0,0));
    m_pDragImage->DragEnter(GetDesktopWindow(), pNMLV->ptAction);
    SetCapture();
	m_nTabDropIndex = -1;

	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	if(!(nFlags & MK_LBUTTON))
		m_bIsDragging = false;

	if(m_bIsDragging)
	{
		CPoint pt(point);           //get our current mouse coordinates

		ClientToScreen(&pt);        //convert to screen coordinates

		m_nTabDropIndex = GetTabUnderMouse(&pt);
		m_ctlDLTabs.SetCurSel(m_nTabDropIndex);
		m_ctlDLTabs.Invalidate();

		::GetCursorPos(&pt);
		pt.y -= 10;

		m_pDragImage->DragMove(pt); //move the drag image to those coordinates
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::OnLButtonUp(UINT uiFlags, CPoint point)
{
	NOPRM(uiFlags); NOPRM(point);
	if (m_bIsDragging)
	{
		ReleaseCapture();
		m_bIsDragging = false;

		m_pDragImage->DragLeave(GetDesktopWindow());
		m_pDragImage->EndDrag();
		delete m_pDragImage;

	//	If the cursor is over a tab and the current tab is a predefined cat
		if ( m_nTabDropIndex >= CCat::GetNumPredefinedCats()
		 && ( m_ctlDownloadList.GetCurTabIndex() < CCat::GetNumPredefinedCats()
		   || ( m_ctlDownloadList.GetCurTabIndex() >= CCat::GetNumPredefinedCats()
		     && m_nTabDropIndex != m_ctlDownloadList.GetCurTabIndex()) ) )
		{
			CPartFile	   *pPartFile;
			int				index = -1;
			POSITION		pos = m_ctlDownloadList.GetFirstSelectedItemPosition();

			while (pos != NULL)
			{
				index = m_ctlDownloadList.GetNextSelectedItem(pos);
				if (index > -1)
				{
					CMuleCtrlItem	*pItem = reinterpret_cast<CMuleCtrlItem*>(m_ctlDownloadList.GetItemData(index));
					CPartFileDLItem	*pFileItem = dynamic_cast<CPartFileDLItem*>(pItem);

					if (pFileItem != NULL)
					{
						pPartFile = pFileItem->GetFile();
						pPartFile->SetCatID(CCat::GetCatIDByIndex(m_nTabDropIndex));
					}
				}
			}

			m_ctlDLTabs.SetCurSel(m_ctlDownloadList.GetCurTabIndex());

			//if (m_ctlDLTabs.GetCurSel() > CCat::GetNumPredefinedCats())
			m_ctlDownloadList.ChangeCategoryByIndex(m_ctlDLTabs.GetCurSel());

			UpdateCatTabTitles();
		}
		else
		{
			m_ctlDLTabs.SetCurSel(m_ctlDownloadList.GetCurTabIndex());
		}
		m_ctlDownloadList.Invalidate();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::OnDblClickDltab()
{
	CPoint	point;

	::GetCursorPos(&point);

	int		iTab = GetTabUnderMouse(&point);

	if (iTab >= CCat::GetNumPredefinedCats())
	{
		m_iTabRightClickIndex = iTab;
		OnCommand(MP_CAT_EDIT, 0);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	UpdateCatTabTitles() updates the tab text to reflect the current category titles and, incidentally,
//		updates the file count information displayed on the tab.
void CTransferWnd::UpdateCatTabTitles()
{
	if (!g_App.m_pMDlg->IsRunning())
		return;

	CString		strCatTitle;

//	For each tab...
	for (int i = 0; i < m_ctlDLTabs.GetItemCount(); i++)
	{
		if (i == 0)
		{
			EnumCategories		eCatID = CCat::GetAllCatType();

			strCatTitle = CCat::GetPredefinedCatTitle(eCatID);
			if (eCatID != CAT_ALL)
			{
				strCatTitle = _T('[') + strCatTitle;
				strCatTitle += _T(']');
			}
		}
		else
		{
			strCatTitle = CCat::GetCatByIndex(i)->GetTitle();
		}
	//	If it's the "All" tab change the title to reflect the current All category selection.
	//	If not, change the title to reflect the current category title
		EditCatTabLabel(i, strCatTitle);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	EditCatTabLabel() changes the label of tab 'index' to 'strNewLabel' (with additional file count info if the
//		"Show Category Tab Info" preference is set)
void CTransferWnd::EditCatTabLabel(int index, CString strNewLabel)
{
	TCITEM tabitem;

	tabitem.mask = TCIF_PARAM;
	m_ctlDLTabs.GetItem(index,&tabitem);
	tabitem.mask = TCIF_TEXT;

	CDownloadList::PartFileVector  *pvecPartFiles;
	uint32							dwTotalCount = 0;
	uint32							dwDownloading = 0;

//	Count the number of files in the DownloadQueue belonging to the
//	'index'th category and the number of those currently downloading
	if ((pvecPartFiles = g_App.m_pDownloadList->GetFiles()) != NULL)
	{
		for(unsigned int i = 0; i < pvecPartFiles->size(); i++)
		{
			CPartFile		*pPartFile = (*pvecPartFiles)[i];

			if (pPartFile == NULL)
				continue;

			if (CCat::FileBelongsToGivenCat(pPartFile,CCat::GetCatIDByIndex(index)))
			{
				dwTotalCount++;
				if(pPartFile->GetTransferringSrcCount() > 0)
					dwDownloading++;
			}
		}
	}

	delete pvecPartFiles;
	pvecPartFiles = NULL;

//	Append the appropriate information to the tab label

//	KuSh: what about not displaying dwDownloading if null ?
	if (!CCat::GetCatByIndex(index)->IsPredefined()/* && dwDownloading > 0*/)
	{
		strNewLabel.AppendFormat(_T(" %u/%u"), dwDownloading, dwTotalCount);
	}
	else
	{
	//	We don't really need a download count on predefined cats
		strNewLabel.AppendFormat(_T(" %u"), dwTotalCount);
	}

	tabitem.pszText = strNewLabel.LockBuffer();
	m_ctlDLTabs.SetItem(index,&tabitem);
	strNewLabel.UnlockBuffer();
	m_ctlDLTabs.Invalidate();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CTransferWnd::AddCategory( CString strNewTitle, CString strNewIncoming, CString strNewTemp, 
							   CString strNewComment, CString strNewAutoCatExt, bool bAddTab)
{
	CCat		*pNewCat = new CCat(strNewTitle, strNewIncoming, strNewTemp, strNewComment, strNewAutoCatExt);

	int		iIndex = CCat::AddCat(pNewCat);

	if (bAddTab)
		m_ctlDLTabs.InsertItem(iIndex,strNewTitle);

	m_ctlDLTabs.Invalidate();

	return iIndex;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CTransferWnd::AddPredefinedCategory(EnumCategories ePredefinedCatID, bool bAddTab/*=true*/)
{
	CCat	*pNewCat = new CCat(ePredefinedCatID);

	int		iIndex = CCat::AddPredefinedCat(pNewCat);

	if (bAddTab)
		m_ctlDLTabs.InsertItem(iIndex, pNewCat->GetTitle());

	m_ctlDLTabs.Invalidate();

	return iIndex;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::OnTabMovement(NMHDR *pNMHDR, LRESULT *pResult)
{
	UINT	from = m_ctlDLTabs.GetLastMovementSource();
	UINT	to = m_ctlDLTabs.GetLastMovementDestination();
	byte	iNumPredefinedCats = CCat::GetNumPredefinedCats();
	NOPRM(pNMHDR); NOPRM(pResult);

	if (from < iNumPredefinedCats || to < iNumPredefinedCats || from == to-1)
		return;
//
//	Do the reorder
//

//	Rearrange the cat-map
	if (!CCat::MoveCat(from, to))
		return;

//	Rearrange the tab control itself
	m_ctlDLTabs.ReorderTab(from, to);

	UpdateCatTabTitles();
	g_App.m_pMDlg->m_dlgSearch.UpdateCatTabs();

	if (to > from)
	{
		--to;
	}
	m_ctlDLTabs.SetCurSel(to);
	m_ctlDownloadList.ChangeCategoryByIndex(to);
	m_ctlDLTabs.Invalidate();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CTransferWnd::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult)
{
	NMHDR* pNMHDR = (NMHDR*)lParam;

	if (pNMHDR->hwndFrom == m_ctlDLTabs.GetSafeHwnd())
	{
		switch(pNMHDR->code)
		{
			case NM_RCLICK:
				OnNMRClickDltab(pNMHDR, pResult);
				break;
			case NM_DBLCLK:
			case WM_LBUTTONDBLCLK:
				OnDblClickDltab();
				break;
			case TCN_SELCHANGE:
				OnTcnSelchangeDltab(pNMHDR, pResult);
				break;
			case NM_TABMOVED:
				OnTabMovement(pNMHDR, pResult);
				break;
		}
	}
	else if(pNMHDR->hwndFrom == m_ctlDownloadList.GetSafeHwnd())
	{
		switch(pNMHDR->code)
		{
			case LVN_BEGINDRAG:
				OnLvnBeginDrag(pNMHDR, pResult);
				break;
		}
	}
	else
	{
		switch(pNMHDR->code)
		{
			case UDM_TOOLTIP_DISPLAY:
			{
				NM_PPTOOLTIP_DISPLAY *pNotify = (NM_PPTOOLTIP_DISPLAY*)lParam;

				GetInfo4ToolTip(pNotify);
				return TRUE;
			}
			case UDM_TOOLTIP_POP:
			{
				m_ttip.Pop();
				return TRUE;
			}
		}
	}

	return CResizableDialog::OnNotify(wParam, lParam, pResult);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.179
log
@Reduced H-file dependency.
@
text
@d30 3
@


1.178
log
@Updated server list search API for encryption implementation.
@
text
@d28 1
@


1.177
log
@Reduced H-file dependency.
@
text
@d506 1
a506 1
				CServer *pCurSrv, *pSrv = g_App.m_pServerList->GetServerByIP(pSource->GetServerIP(), pSource->GetServerPort());
@


1.176
log
@Reduced H-file dependency.
@
text
@d27 1
@


1.175
log
@Improved string processing.
@
text
@d20 1
@


1.174
log
@Corrected OnSize parameter type.
@
text
@d1130 1
a1130 1
// Ornis' download categories
d1133 20
a1152 1
//	Popup menu for the category tabs
d1175 3
d1179 10
a1188 19
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0,GetResString(IDS_CAT_ALL));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+1,GetResString(IDS_CAT_UNCATEGORIZED));
		menuView.AppendMenu(MF_SEPARATOR);
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+2,GetResString(IDS_CAT_INCOMPLETE));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+3,GetResString(IDS_COMPLETE));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+4,GetResString(IDS_WAITING));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+5,GetResString(IDS_DOWNLOADING));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+6,GetResString(IDS_ERRORLIKE));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+7,GetResString(IDS_PAUSED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+8,GetResString(IDS_STOPPED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+9,GetResString(IDS_STALLED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+10,GetResString(IDS_ST_ACTIVE));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+11,GetResString(IDS_ST_INACTIVE));
		menuView.AppendMenu(MF_SEPARATOR);
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+12,GetResString(IDS_VIDEO));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+13,GetResString(IDS_AUDIO));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+14,GetResString(IDS_SEARCH_ARC));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+15,GetResString(IDS_SEARCH_CDIMG));

@


1.173
log
@Fixed loading of InfoView column splitter (default value was used on every start);
Moved saving of InfoView column splitter to transfer window.
@
text
@d76 1
a76 1
	afx_msg void OnSize(uInt nType, int cx, int cy)
@


1.172
log
@Transfer window sub-pane state was moved to preferenes.ini (gui.dat is not used anymore) -- sub-pane state will be set to default on the first start;
More robust checks to load transfer window sub-pane state.
@
text
@a199 1
	m_bFirstShow = true;
a745 5
	if (m_bFirstShow)
	{
		m_bFirstShow = false;
		m_ctlInfoList.SetColumn(g_App.m_pPrefs->GetDetailColumnWidth());
	}
d901 2
d938 2
@


1.171
log
@Preparations to migrate from gui.dat configuration file to preferences.ini.
@
text
@d847 1
a847 1
	static const double s_afDefItemHeights[3][8] =
d856 3
a858 2
	double fItemHeights[3][8];
	double (*pafItemHeights)[8];
d860 1
a860 12
	FILE *f;
	CString fullpath;

	//
	//	Try to open the GUI settings save file
	fullpath.Format(_T("%sgui.dat"), g_App.m_pPrefs->GetConfigDir());
	f = _tfopen(fullpath, _T("rb"));

	bool bUseDefault = false;

	//	If we opened it...
	if(f)
d862 1
a862 3
		TCHAR cTemp[512];
		TCHAR *pToken;
		static const TCHAR s_acSeps[] = _T("|\n");
d864 1
a864 1
		for(int exp = 0; exp < 8; exp++)
d866 3
a868 2
		//	Try to read a line from the file. If we can't...
			if(!_fgetts(cTemp, 512, f))
d873 4
a876 34

			double fTotalHeight = 0.0;

			//	Look for the next seperator
			pToken = _tcstok(cTemp, s_acSeps);
			for(int i = 0; i < 3; i++)
			{
			//	If we couldn't find the expected seperator
				if(!pToken)
				{
					bUseDefault = true;
					break;
				}

			//	Extract the next percentage
				fItemHeights[i][exp] = _tstof(pToken);
//				TRACE("fItemHeights[%d][%d] = %f\r\n", i, exp, _tstof(pToken));
			//	Find the next seperator
				pToken = _tcstok(NULL, s_acSeps);

			//	If we somehow read a negative percentage...
				if(fItemHeights[i][exp] < 0)	// this should never happen
				{
					bUseDefault = true;
					break;
				}
			//	Total up the percentages for this expansion pattern
				fTotalHeight += fItemHeights[i][exp];
			}
			if (bUseDefault)
				break;

			//	If the percentages don't total up to 100 somehow...
			if(fTotalHeight >= 101 || fTotalHeight <= 99 && fTotalHeight != 0) // i'm very tolerant ;)
d882 2
d885 3
a887 6
	//
	//	Restore the user's last expansion state
	//

	//	Try to read the next line
		if(!_fgetts(cTemp, 512, f))
d889 1
a889 16

		if(!bUseDefault)
		{
			pToken = _tcstok(cTemp, s_acSeps);

			for(int i = 0; i < 3; i++)
			{
				if(!pToken)
				{
					bUseDefault = true;
					break;
				}

				m_ctlRollup.ExpandItem(i, (_tstoi(pToken)) ? true : false);
				pToken = _tcstok(NULL, s_acSeps);
			}
d891 1
d893 6
a898 1
		fclose(f);
a899 3
	//	If there are no saved GUI settings...
	else
		bUseDefault = true;
d901 1
a901 1
	pafItemHeights = (bUseDefault) ? (double (*)[8])s_afDefItemHeights : fItemHeights;
d903 3
a905 3
	m_ctlRollup.SetItemHeights(0, pafItemHeights[0], sizeof(*pafItemHeights));
	m_ctlRollup.SetItemHeights(1, pafItemHeights[1], sizeof(*pafItemHeights));
	m_ctlRollup.SetItemHeights(2, pafItemHeights[2], sizeof(*pafItemHeights));
d917 2
a918 5
		FILE *f;
		CString fullpath;

		fullpath.Format(_T("%sgui.dat"), g_App.m_pPrefs->GetConfigDir());
		f = _tfopen(fullpath, _T("wb"));
d920 1
a920 1
		if(f)
d922 20
a941 23
			for(int exp = 0; exp < 8; exp++)
			{
				double f1,f2,f3;

				f1 = m_ctlRollup.GetItem(0)->adSizes[exp];
				f2 = m_ctlRollup.GetItem(1)->adSizes[exp];
				f3 = m_ctlRollup.GetItem(2)->adSizes[exp];

				// get rid off some rounding errors: ///
				if(f3)
					f3 = f1 ? (f2 ? (100 - f1 - f2) : (100 - f1)) : (100 - f2);
				else if(f2)
					f2 = 100 - f1;
				////////////////////////////////////////

				fprintf(f, "%f|%f|%f\n", f1, f2, f3);
			}
			fprintf( f, "%u|%u|%u\n",
					m_ctlRollup.GetItem(0)->pHeader->IsExpanded(),
					m_ctlRollup.GetItem(1)->pHeader->IsExpanded(),
					m_ctlRollup.GetItem(2)->pHeader->IsExpanded() );
			fclose(f);
		}
@


1.170
log
@Suppressed level 4 warnings; Formatting.
@
text
@a17 2
// TransferWnd.cpp : implementation file

d193 1
a193 3
{
	SaveRollupItemHeights();
}
a200 1
	//Localize();
a209 1
	//
a210 1
	//
a290 1
//	m_ttip.SetFont(_T("Courier"), 9);
a558 1
					//	Cax2- get local file name
d957 3
a959 3
	m_ctlRollup.SetItemHeights(0, pafItemHeights[0], 8);
	m_ctlRollup.SetItemHeights(1, pafItemHeights[1], 8);
	m_ctlRollup.SetItemHeights(2, pafItemHeights[2], 8);
d983 3
a985 3
				f1 = m_ctlRollup.GetItem(0)->pSizes[exp];
				f2 = m_ctlRollup.GetItem(1)->pSizes[exp];
				f3 = m_ctlRollup.GetItem(2)->pSizes[exp];
@


1.169
log
@change the ANSI font to DEFAULT_GUI
@
text
@d80 1
d406 2
a407 1
			int			iIndex = GetTabUnderMouse(&CPoint(*pNotify->pt));
d727 1
a727 1
		if (static_cast<unsigned>(m_ctlQueueList.m_iClientFilter - CLI_FILTER_BANNED) < ELEMENT_COUNT(auResStr))
d953 1
a953 1
				m_ctlRollup.ExpandItem(i, _tstoi(pToken));
d1033 2
a1034 2
		byte				iCatPos = wParam - MP_SHOWPREDEFINEDCAT_0;
		EnumCategories		eCatID = static_cast<_EnumCategories>(iCatPos + static_cast<int>(CAT_PREDEFINED));
d1194 1
a1194 1
	byte		catIndex;
d1196 1
a1196 2
	catIndex = m_ctlDLTabs.GetCurSel();
	m_ctlDownloadList.ChangeCategoryByIndex(catIndex);
d1207 1
d1354 1
a1354 1
void CTransferWnd::OnLButtonUp(UINT iFlags, CPoint point)
d1356 1
d1545 1
d1554 1
a1554 1
	if (!CCat::MoveCat(from,to))
d1558 1
a1558 1
	m_ctlDLTabs.ReorderTab(from,to);
@


1.168
log
@Reduced #include depedency.
@
text
@d239 1
a239 1
	m_ctlDLTabs.SendMessage(WM_SETFONT, (WPARAM)GetStockObject(ANSI_VAR_FONT));
@


1.167
log
@Use of IDS_COMPLETE instead of IDS_SF_COMPLETED for category filters
@
text
@d28 1
@


1.166
log
@Remove use of IDS_CAT_COMPLETED
Remove use of aliases.
@
text
@d1229 1
a1229 1
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+3,GetResString(IDS_SF_COMPLETED));
@


1.165
log
@Newly added stuff was renamed according to the original for easier reference.
@
text
@d1229 9
a1237 9
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+3,GetResString(IDS_CAT_COMPLETED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+4,GetResString(IDS_CAT_WAITING));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+5,GetResString(IDS_CAT_DOWNLOADING));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+6,GetResString(IDS_CAT_ERRONEOUS));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+7,GetResString(IDS_CAT_PAUSED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+8,GetResString(IDS_CAT_STOPPED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+9,GetResString(IDS_CAT_STALLED));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+10,GetResString(IDS_CAT_ACTIVE));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+11,GetResString(IDS_CAT_INACTIVE));
d1239 4
a1242 4
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+12,GetResString(IDS_CAT_VIDEO));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+13,GetResString(IDS_CAT_AUDIO));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+14,GetResString(IDS_CAT_ARCHIVES));
		menuView.AppendMenu(MF_STRING,MP_CAT_SET_0+15,GetResString(IDS_CAT_CDIMAGES));
@


1.164
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d507 1
a507 1
					strUserName, GetResString(IDS_USERID), pSource->GetHybridUserID(), strTmp,
@


1.163
log
@Removed unrequired class member; Some formatting.
@
text
@d507 1
a507 1
					strUserName, GetResString(IDS_USERID), pSource->GetUserID(), strTmp,
@


1.162
log
@removed unused variables (thanks Aw3)
@
text
@d84 1
a84 1
			r -= CSize(2,2);
d303 1
a303 1
// v- eklmn: bugfix(00): resource cleanup due to CResizableDialog
a312 2

// ^- eklmn: bugfix(00): resource cleanup due to CResizableDialog
d562 1
a562 2
				//	If Asked For Another File...
				else
a1117 1
		{
d1120 1
a1120 1
		}
a1121 1
		{
d1124 1
a1124 1
		}
a1125 1
		{
d1128 1
a1128 1
		}
a1129 1
		{
d1132 1
a1132 1
		}
a1133 1
		{
d1136 1
a1136 1
		}
a1137 1
		{
d1140 1
a1140 1
		}
a1141 1
		{
d1143 1
a1143 3
			{
				g_App.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_CANCEL);
			}
d1145 1
a1145 1
		}
a1146 1
		{
d1149 1
a1149 1
		}
a1150 1
		{
d1153 1
a1153 1
		}
a1319 1
	m_nDragIndex = pNMLV->iItem;
a1333 1

@


1.161
log
@removed UpdateToolTips()-function since RelayEvent() is enough to upade the tooltip on moving
@
text
@a189 9

	m_pLastMousePoint.x = 0;
	m_pLastMousePoint.y = 0;

	m_iOldToolTipItemDownload = -1;
	m_iOldToolTipItemUpload = -1;
	m_iOldToolTipItemQueue = -1;
	m_iOldToolTipItemClients = -1;	
	m_nLastCatTT = -1;
a1022 1
		m_nLastCatTT = -1;
a1044 1
			m_nLastCatTT = -1;
a1066 1
			m_nLastCatTT = -1;
a1093 2
			m_nLastCatTT = -1;

a1106 1
			m_nLastCatTT = -1;
@


1.160
log
@Rolled back "don't process invisible GUI lists" - reason: current list positions and visible view regions are not preserved.
@
text
@a345 14
				if ((pMsg->message == WM_MOUSEMOVE) || (pMsg->message == WM_MOUSEWHEEL))
				{
					CPoint	point;

					::GetCursorPos(&point);

					if ((point.x != m_pLastMousePoint.x) || (point.y != m_pLastMousePoint.y))
					{
						m_pLastMousePoint = point;

					//	Handle tooltip updating, when mouse is moved from one item to another
						UpdateToolTips();
					}
				}
a399 91
void CTransferWnd::UpdateToolTips(void)
{
	EMULE_TRY

	// Update tooltips for Category tabs
	CPoint		point;
	bool		bPop = true;

	::GetCursorPos(&point);

	int iSel = GetTabUnderMouse(&point);

	if (iSel != -1)
	{
		bPop = false;
		if (iSel != m_nLastCatTT)
		{
			if (m_ttip.IsWindowVisible())
				m_ttip.UpdateData();
			m_nLastCatTT = iSel;
			return;
		}
	}

	// Update tooltips for Download List
	CListCtrl	*pListCtrl = &m_ctlDownloadList;

	iSel = GetItemUnderMouse(pListCtrl);	
	if (iSel != -1)
	{
		bPop = false;
		if (iSel != m_iOldToolTipItemDownload) 
		{
			if (m_ttip.IsWindowVisible())
				m_ttip.UpdateData();
			m_iOldToolTipItemDownload = iSel;
			return;
		}
	}

	//	Update tooltips for Upload List
	pListCtrl = &m_ctlUploadList;
	iSel = GetItemUnderMouse(pListCtrl);
	if (iSel != -1)
	{
		bPop = false;
		if (iSel != m_iOldToolTipItemUpload)
		{
			if (m_ttip.IsWindowVisible())
				m_ttip.UpdateData();
			m_iOldToolTipItemUpload = iSel;
			return;
		}
	}

	//	Update tooltips for Queue List
	pListCtrl = &m_ctlQueueList;
	iSel = GetItemUnderMouse(pListCtrl);
	if (iSel != -1)
	{
		bPop = false;
		if (iSel != m_iOldToolTipItemQueue)
		{
			if (m_ttip.IsWindowVisible())
				m_ttip.UpdateData();
			m_iOldToolTipItemQueue = iSel;
			return;
		}
	}

	//	Update tooltips for Clients List
	pListCtrl = &m_ctlClientList;
	iSel = GetItemUnderMouse(pListCtrl);
	if (iSel != -1)
	{
		bPop = false;
		if (iSel != m_iOldToolTipItemClients)
		{
			if (m_ttip.IsWindowVisible())
				m_ttip.UpdateData();
			m_iOldToolTipItemClients = iSel;
			return;
		}
	}

	if (bPop)
		m_ttip.Pop();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.159
log
@don't process invisible GUI lists
@
text
@a783 1
			m_ctlQueueList.ShowWindow(SW_SHOW);
a794 1
			m_ctlClientList.ShowWindow(SW_SHOW);
@


1.158
log
@Fixed Info View header localization after language switch {mamamia}.
@
text
@d784 1
d796 1
@


1.157
log
@Changed index variable type.
@
text
@d866 4
a869 3
	//Cax2 - localize the rollup control
	m_ctlRollup.SetText(0,GetResString(IDS_RUP_DOWNLOADS), true);
	m_ctlRollup.SetText(2,GetResString(IDS_RUP_INFO), true);
d951 1
a951 1
	CString strInfoHeader = _T("");
@


1.156
log
@Fixed recently changes for download state of remote LowID NNS (as a result fixed broken:
source exchange because number of valid sources was incorrect, A4AF swap, sorting of NNS, NNS statistics, etc.).
@
text
@d1563 1
a1563 1
	for (byte i = 0; i < m_ctlDLTabs.GetItemCount(); i++)
@


1.155
log
@Large file size support preparations.
@
text
@d626 1
a626 1
				CServer *pServer = g_App.m_pServerList->GetServerByIP(pSource->GetServerIP(), pSource->GetServerPort());
d628 1
a628 1
				if (pServer != NULL)
d632 1
a632 1
					strTmp = pServer->GetListName();
d655 3
a657 1
				if ((pSource->GetDownloadState() == DS_ONQUEUE) || (pSource->GetDownloadState() == DS_NONEEDEDPARTS))
@


1.154
log
@Reduced H-file dependency.
@
text
@d525 1
a525 1
			uint16		iCount = 0, iTransferring = 0, iPaused = 0, iStopped = 0;
d527 1
a527 1
			uint64		iSize = 0, iCompletedSize = 0, iRealSize = 0;
a537 1
			{
a538 1
			}
d548 1
a548 1
						iCount++;
d550 1
a550 1
							iTransferring++;
d552 1
a552 1
							iPaused++;
d554 1
a554 1
							iStopped++;
d556 3
a558 3
						iSize += pPartFile->GetFileSize();
						iCompletedSize += pPartFile->GetCompletedSize();
						iRealSize += pPartFile->GetRealFileSize();
d572 1
a572 1
			strInfo.AppendFormat(_T("<b>%s</b><br><hr=100%%><br><b>%s:</b><t>%i / %i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%.1f %s<br><b>%s:</b><t>%s / %s<br><b>%s:</b><t>%s<br><b>%s</b><t>%s<br><b>%s</b><t>%s"),
d574 2
a575 2
				GetResString(IDS_DOWNLOADING), iTransferring, (iCount - iPaused - iStopped),
				GetResString(IDS_PAUSED), iPaused, GetResString(IDS_STOPPED), iStopped,
d577 2
a578 2
				GetResString(IDS_DL_SIZE), CastItoXBytes(iCompletedSize), CastItoXBytes(iSize),
				GetResString(IDS_SIZE_ON_DISK), CastItoXBytes(iRealSize),
a580 1
			
@


1.153
log
@Unicode preparations.
@
text
@a17 1

a18 1
//
d27 1
@


1.152
log
@Optimized rating value checks.
@
text
@d634 1
a634 1
					in_addr			serverAddr;
a636 3
					serverAddr.S_un.S_addr = pSource->GetServerIP();
					strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s:%d"), GetResString(IDS_SERVER), inet_ntoa(serverAddr), pSource->GetServerPort());

@


1.151
log
@Faster message preprocess in transfer window.
@
text
@d705 2
a706 2
						if (GetRatingString(pSource->GetFileRating()) == GetResString(IDS_CMT_NOTRATED))
							strInfo += GetResString(IDS_CMT_NOTRATED);
a715 1
				//-End file comment-//
@


1.150
log
@UNICODE preparation (first shot)
@
text
@d347 3
a349 4
		}
		if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_MOUSEWHEEL)
		{
			CPoint	point;
d351 1
a351 1
			::GetCursorPos(&point);
d353 3
a355 3
			if ((point.x != m_pLastMousePoint.x) || (point.y != m_pLastMousePoint.y))
			{
				m_pLastMousePoint = point;
d357 4
a360 3
				//	Handle tooltip updating, when mouse is moved from one item to another
				UpdateToolTips();
			}
d364 1
a364 1
	if (pMsg->message == WM_LBUTTONDBLCLK && pMsg->hwnd == m_ctlDLTabs.GetSafeHwnd())
d366 3
a368 1
		POINT point;
d370 1
a370 1
		::GetCursorPos(&point);
d372 1
a372 1
		CPoint pt(point);
d374 5
a378 4
		if (GetTabUnderMouse(&pt) != -1)
		{
			OnDblClickDltab();
			return TRUE;
d381 1
a381 2

	if (pMsg->message == WM_MBUTTONUP) 
a394 1
				{
d397 1
a397 1
				}
a398 1
				{
d401 1
a401 1
				}
a402 1
				{
a404 1
				}
d409 1
a409 2

	if(pMsg->message == USRMSG_SWITCHUPLOADLIST)
@


1.149
log
@Fixed localization of the predefined categories after language switch {Vladimir (SV)}.
@
text
@d232 1
a232 1
	m_pwndDummyForDownloadList->Create(AfxRegisterWndClass(0), "", WS_CHILD|WS_VISIBLE, rItem, pParent, TRANS_DUMMY);
d832 1
a832 1
		strBuf.AppendFormat(" (%u)", m_ctlClientList.GetItemCount());
d1192 1
a1192 1
			int newindex = AddCategory("?", g_App.m_pPrefs->GetIncomingDir(), g_App.m_pPrefs->GetTempDir(), "", "", true);
@


1.148
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d904 1
d909 1
d1673 1
a1673 1
		m_ctlDLTabs.InsertItem(iIndex,pNewCat->GetTitle());
@


1.147
log
@renamed 3 variables
@
text
@d297 1
a297 1
	m_ttip.SetDelayTime(TTDT_INITIAL, g_App.g_pPrefs->GetToolTipDelay()*1000);
d334 1
a334 1
	if (g_App.g_pPrefs->GetToolTipDelay() != 0)
d881 1
a881 1
		m_ctlInfoList.SetColumn(g_App.g_pPrefs->GetDetailColumnWidth());
d993 1
a993 1
	fullpath.Format(_T("%sgui.dat"), g_App.g_pPrefs->GetConfigDir());
d1103 1
a1103 1
		fullpath.Format(_T("%sgui.dat"), g_App.g_pPrefs->GetConfigDir());
d1162 1
a1162 1
			g_App.g_pPrefs->SaveCats();
d1171 1
a1171 1
			g_App.g_pPrefs->SaveCats();
d1190 1
a1190 1
			int newindex = AddCategory("?", g_App.g_pPrefs->GetIncomingDir(), g_App.g_pPrefs->GetTempDir(), "", "", true);
d1199 1
a1199 1
				g_App.g_pPrefs->SaveCats();
d1210 1
a1210 1
				g_App.g_pPrefs->SaveCats();
d1227 1
a1227 1
			g_App.g_pPrefs->SaveCats();
d1238 1
a1238 1
			g_App.g_pPrefs->SaveCats();
@


1.146
log
@Faster processing of file comments.
@
text
@d236 1
a236 1
	g_eMuleApp.m_pDownloadList->SetDownloadListCtrl(&m_ctlDownloadList);
d241 1
a241 1
	g_eMuleApp.m_pClientList->SetClientListCtrl(&m_ctlClientList);
d257 6
a262 6
	strTmp.Format(GetResString(IDS_RUP_DOWNINFO), g_eMuleApp.m_pDownloadQueue->GetFileCount(),
						g_eMuleApp.m_pDownloadQueue->GetActiveFileCount(),
						g_eMuleApp.m_pDownloadQueue->GetPausedFileCount(),
						g_eMuleApp.m_pDownloadQueue->GetStoppedFileCount(),
						g_eMuleApp.m_pDownloadQueue->GetTransferringFiles(),
						static_cast<double>(g_eMuleApp.m_pDownloadQueue->GetDataRate()) / 1024.0);
d265 4
a268 4
	strTmp.Format(GetResString(IDS_RUP_UPINFO), g_eMuleApp.m_pUploadQueue->GetWaitingUserCount(),
					  g_eMuleApp.m_pUploadQueue->GetUploadQueueLength(),
					  g_eMuleApp.m_pUploadQueue->GetBanCount(),
					  static_cast<double>(g_eMuleApp.m_pUploadQueue->GetDataRate()) / 1024.0);
d297 1
a297 1
	m_ttip.SetDelayTime(TTDT_INITIAL, g_eMuleApp.m_pGlobPrefs->GetToolTipDelay()*1000);
d334 1
a334 1
	if (g_eMuleApp.m_pGlobPrefs->GetToolTipDelay() != 0)
d546 1
a546 1
			for (int i = 0; i < g_eMuleApp.m_pDownloadQueue->GetFileCount(); i++)
d548 1
a548 1
				pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByIndex(i);
d626 1
a626 1
				if (g_eMuleApp.m_pIP2Country->IsIP2Country())
d633 1
a633 1
				CServer *pServer = g_eMuleApp.m_pServerList->GetServerByIP(pSource->GetServerIP(), pSource->GetServerPort());
d723 1
a723 1
					g_eMuleApp.m_pdlgEmule->m_clientImgLists[CLIENT_IMGLST_PLAIN].ExtractIcon(pSource->GetClientIconIndex());
d881 1
a881 1
		m_ctlInfoList.SetColumn(g_eMuleApp.m_pGlobPrefs->GetDetailColumnWidth());
d924 6
a929 6
					g_eMuleApp.m_pDownloadQueue->GetFileCount(),
					g_eMuleApp.m_pDownloadQueue->GetActiveFileCount(),
					g_eMuleApp.m_pDownloadQueue->GetPausedFileCount(),
					g_eMuleApp.m_pDownloadQueue->GetStoppedFileCount(),
					g_eMuleApp.m_pDownloadQueue->GetTransferringFiles(),
					static_cast<double>(g_eMuleApp.m_pDownloadQueue->GetDataRate())/1024.0 );
d943 4
a946 4
					  g_eMuleApp.m_pUploadQueue->GetWaitingUserCount(),
						g_eMuleApp.m_pUploadQueue->GetUploadQueueLength(),
							g_eMuleApp.m_pUploadQueue->GetBanCount(),
								static_cast<double>(g_eMuleApp.m_pUploadQueue->GetDataRate())/1024.0);
d993 1
a993 1
	fullpath.Format(_T("%sgui.dat"), g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d1103 1
a1103 1
		fullpath.Format(_T("%sgui.dat"), g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d1162 1
a1162 1
			g_eMuleApp.m_pGlobPrefs->SaveCats();
d1171 1
a1171 1
			g_eMuleApp.m_pGlobPrefs->SaveCats();
d1184 1
a1184 1
			g_eMuleApp.m_pDownloadList->ClearCompleted(CAT_NONE);
d1190 1
a1190 1
			int newindex = AddCategory("?", g_eMuleApp.m_pGlobPrefs->GetIncomingDir(), g_eMuleApp.m_pGlobPrefs->GetTempDir(), "", "", true);
d1199 1
a1199 1
				g_eMuleApp.m_pGlobPrefs->SaveCats();
d1204 1
a1204 1
				g_eMuleApp.m_pdlgEmule->m_dlgSearch.UpdateCatTabs();
d1208 1
a1208 1
				g_eMuleApp.m_pdlgEmule->m_dlgSearch.UpdateCatTabs();
d1210 1
a1210 1
				g_eMuleApp.m_pGlobPrefs->SaveCats();
d1226 2
a1227 2
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.UpdateCatTabs();
			g_eMuleApp.m_pGlobPrefs->SaveCats();
d1233 1
a1233 1
			g_eMuleApp.m_pDownloadQueue->ResetCatParts(m_iTabRightClickIndex);
d1238 1
a1238 1
			g_eMuleApp.m_pGlobPrefs->SaveCats();
d1243 1
a1243 1
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.UpdateCatTabs();
d1248 1
a1248 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_LOW);
d1253 1
a1253 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_NORMAL);
d1258 1
a1258 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_HIGH);
d1263 1
a1263 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iTabRightClickIndex,PR_AUTO);
d1268 1
a1268 1
			g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_PAUSE);
d1273 1
a1273 1
			g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_STOP);
d1280 1
a1280 1
				g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_CANCEL);
d1286 1
a1286 1
			g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iTabRightClickIndex,MP_RESUME);
d1291 1
a1291 1
			g_eMuleApp.m_pDownloadQueue->StartNextFile(CCat::GetCatIDByIndex(m_iTabRightClickIndex));
d1564 1
a1564 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d1609 1
a1609 1
	if ((pvecPartFiles = g_eMuleApp.m_pDownloadList->GetFiles()) != NULL)
d1698 1
a1698 1
	g_eMuleApp.m_pdlgEmule->m_dlgSearch.UpdateCatTabs();
@


1.145
log
@One more step to integrate eklmn's SSDQ.
@
text
@d703 1
a703 2
						if (!pSource->GetFileComment().IsEmpty())
						{
a704 1
						}
a705 1
						{
d707 1
a707 1
						}
a708 1
						{
a709 1
						}
d711 1
a711 3
						{
							strInfo.AppendFormat(_T("<b>%s:</b><t>%s"), GetResString(IDS_TT_CMT_RATING), GetRatingString(pSource->GetFileRating()) );
						}
@


1.144
log
@correction for string processing by tooltip notify. thanks Aw3
@
text
@d667 2
a668 4
					uint32		dwTimeSpan, dwFileReaskTime;

					if (pSource->IsOnLAN())
						dwFileReaskTime = LANCASTFILEREASKTIMEUDP;
d671 2
a672 7
#ifdef OLD_SOCKETS_ENABLED
						bool		bSocketsUsageIsHigh = g_eMuleApp.m_pListenSocket->GetNumOpenSockets() > (g_eMuleApp.m_pGlobPrefs->GetMaxConnections() * 3u / 4u);	// 75%
#else
						bool		bSocketsUsageIsHigh = false;
#endif //OLD_SOCKETS_ENABLED

						dwFileReaskTime = FILEREASKTIME;
d674 2
a675 4
						if (pSource->GetDownloadState() == DS_NONEEDEDPARTS)
							dwFileReaskTime *= (bSocketsUsageIsHigh) ?  4 : 2;
						else if (bSocketsUsageIsHigh) // && (pSource->GetDownloadState() == DS_ONQUEUE)
							dwFileReaskTime = (dwFileReaskTime * ((pSource->GetRemoteQueueRank() > QUEUERANK_LOW) ? 5 : 4)) >> 1;
a676 2
					if ((dwTimeSpan = (::GetTickCount() - pSource->GetLastAskedTime())) < dwFileReaskTime)
						strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_NEXT_ASK), CastSecondsToHM((dwFileReaskTime - dwTimeSpan) / 1000));
@


1.143
log
@fixed hanging tooltip by focus switch; the "OnToolTipNotify" replaced over OnNotify because it works faster as using ON_NOTIFY_EX_RANGE(...)
@
text
@d509 1
a509 1
CString  CTransferWnd::GetInfo4ToolTip(NM_PPTOOLTIP_DISPLAY *pNotify)
a510 2
	CString strInfo(_T(""));

d516 3
a518 1
		return strInfo;
d527 1
a527 1
				return FALSE;
d593 1
a593 1
				return FALSE;
d598 1
a598 1
				return FALSE;
d749 1
a749 1
				return FALSE;
d754 1
a754 1
				return FALSE;
d764 1
a764 1
				return FALSE;
d769 1
a769 1
				return FALSE;
d779 1
a779 1
				return FALSE;
d784 1
a784 1
				return FALSE;
d793 2
a795 2

	return strInfo;
d1767 1
a1767 1
				pNotify->ti->sTooltip = GetInfo4ToolTip(pNotify);
@


1.142
log
@IDS_CW_FRIENDS renamed into IDS_FRIENDS.
@
text
@a168 4
	//BEGIN Improved Tooltips
	//ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT,0,0xFFFF,OnToolTipNotify)
	ON_NOTIFY_EX_RANGE(UDM_TOOLTIP_DISPLAY,0,0xFFFF,OnToolTipNotify)
	//END Improved Tooltips
d509 1
a509 1
BOOL CTransferWnd::OnToolTipNotify(UINT id, NMHDR *pNMH, LRESULT *pResult)
d511 2
a514 1
	NM_PPTOOLTIP_DISPLAY	*pNotify = (NM_PPTOOLTIP_DISPLAY*)pNMH;
d518 1
a518 3
		return FALSE;

	CString strInfo;
a791 1
	pNotify->ti->sTooltip = strInfo;
d795 1
a795 1
	return TRUE;
d1759 18
@


1.141
log
@IDS_DL_STOP renamed into IDS_STOP_VERB;
IDS_DL_PAUSE renamed into IDS_PAUSE_VERB;
IDS_DL_RESUME renamed into IDS_RESUME.
@
text
@d866 1
a866 1
		IDS_CW_FRIENDS,	//CLI_FILTER_FRIEND
@


1.140
log
@Slightly improved string processing; Update known clients header only in one place.
@
text
@d1451 3
a1453 3
	menu.AppendMenu(MF_STRING,MP_STOP, GetResString(IDS_DL_STOP));
	menu.AppendMenu(MF_STRING,MP_PAUSE, GetResString(IDS_DL_PAUSE));
	menu.AppendMenu(MF_STRING,MP_RESUME, GetResString(IDS_DL_RESUME));
@


1.139
log
@More space for info. fields in Transfer window.
@
text
@d825 1
a825 3
			CString buffer;
			buffer.Format(" (%i)", m_ctlClientList.GetItemCount());
			m_ctlRollup.SetText(1, GetResString(IDS_CLIENTLIST)+buffer, true);
d849 1
a849 1
//	Update Known Clients on header when total number of known clients change (triggered in ClientListCtrl)
d854 4
a857 3
		CString buffer;
		buffer.Format(" (%i)", m_ctlClientList.GetItemCount());
		m_ctlRollup.SetText(1, GetResString(IDS_CLIENTLIST)+buffer, true);
@


1.138
log
@Unified way to display client name and version.
@
text
@a218 1
	//
a219 1
	//
d223 1
a223 1
	rRollupArea.DeflateRect(11,11);
@


1.137
log
@Optimization of previous changes (sorry I couldn't resist :).
@
text
@d636 1
a636 1
				strInfo.Format(_T("<t=1><b>%s</b><br><t=1>%s: %u%s<br><hr=100%%><br><b>%s:<t></b>%s:%d (<b>%s</b>)"),
d638 1
a638 1
					GetResString(IDS_CLIENT), pSource->GetFullIP(), pSource->GetUserPort(), pSource->GetClientNameAndVersionString());
@


1.136
log
@Next client ask in download list tooltip should be more accurate.
@
text
@d674 1
a674 1
					DWORD		dwTick = ::GetTickCount(), dwLastAskedTime = pSource->GetLastAskedTime(), dwFileReaskTime;
d676 4
d681 1
a681 1
					bool		bSocketsUsageIsHigh = g_eMuleApp.m_pListenSocket->GetNumOpenSockets() > (g_eMuleApp.m_pGlobPrefs->GetMaxConnections() * 0.75);
d683 1
a683 1
					bool		bSocketsUsageIsHigh = false;
a685 4
					if (pSource->IsOnLAN())
						dwFileReaskTime = LANCASTFILEREASKTIMEUDP;
					else
					{
d689 1
a689 1
							(bSocketsUsageIsHigh) ? dwFileReaskTime *= 4 : dwFileReaskTime *= 2;
d691 1
a691 1
							(pSource->GetRemoteQueueRank() > QUEUERANK_LOW) ? dwFileReaskTime *= 2.5 : dwFileReaskTime *= 2;
d693 2
a694 3
				
					if (dwTick - dwLastAskedTime < dwFileReaskTime)
						strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_NEXT_ASK), CastSecondsToHM((dwFileReaskTime - (dwTick - dwLastAskedTime)) / 1000));
@


1.135
log
@Improved string processing.
@
text
@d672 9
a680 1
				DWORD		dwTick = ::GetTickCount(), dwLastAskedTime = pSource->GetLastAskedTime();
d682 15
a696 2
				if (dwTick - dwLastAskedTime < FILEREASKTIME)
					strInfo.AppendFormat(_T("<br><b>%s:<t></b>%s"), GetResString(IDS_NEXT_ASK), CastSecondsToHM((FILEREASKTIME - (dwTick - dwLastAskedTime)) / 1000));
@


1.134
log
@Show time remaining to client reask in download list client tooltip.
@
text
@d627 1
a627 1
				CString				strCountry, strDownloaded, strUploaded, strUserName = pSource->GetUserName();
d634 1
a634 1
					strCountry.Format(_T(" (<b>%s</b>)"), pSource->GetCountryName());
d637 1
a637 1
					strUserName, GetResString(IDS_USERID), pSource->GetUserID(), strCountry,
a643 1
					CString			strServerName = pServer->GetListName();
d646 1
d650 3
a652 3
					strServerName.Replace(_T("<"), _T("<<"));
					strServerName.Replace(_T("\n"), _T("<br>"));
					if (!strServerName.IsEmpty())
d655 1
a655 1
						strInfo += strServerName;
d661 1
a661 1
					strDownloaded.Format(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_DDATA), CastItoXBytes(pSource->GetTransferredUp()), CastItoXBytes(pSource->Credits()->GetUploadedTotal()));
d663 1
a663 2
					strDownloaded.Format(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_DDATA), CastItoXBytes(pSource->GetTransferredUp()));
				strInfo += strDownloaded;
d666 1
a666 1
					strUploaded.Format(_T("<br><b>%s:</b><t>%s (%s)"), GetResString(IDS_STATS_UDATA), CastItoXBytes(pSource->GetTransferredDown()), CastItoXBytes(pSource->Credits()->GetDownloadedTotal()));
d668 1
a668 2
					strUploaded.Format(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_STATS_UDATA), CastItoXBytes(pSource->GetTransferredDown()));
				strInfo += strUploaded;
d681 1
a681 2
					//	Normal client
					if (!pSource->GetClientFilename().IsEmpty())
@


1.133
log
@Show Incoming and Temp folders in category tabs tooltips {DopeFish}.
@
text
@d672 8
a679 3
				strInfo.AppendFormat(_T("<br><b>%s:<t></b>%d<br><b>%s:<t></b>%d"),
					GetResString(IDS_TT_ASKEDCOUNT), pSource->GetAskedCountDown(),
					GetResString(IDS_TT_AVAILABLEPARTS), pSource->GetAvailablePartCount());
@


1.132
log
@Removed useless ShowCatTabInfo setting and all related processing.
@
text
@d541 1
d544 1
a544 1
				strCatTitle = CCat::GetCatByIndex(iIndex)->GetTitle();
d548 1
a548 1
			if (CCat::GetCatByIndex(iIndex)->GetID() < CAT_PREDEFINED)
d576 1
a576 1
			if (!CCat::GetCatByIndex(iIndex)->GetComment().IsEmpty())
d579 1
a579 1
				strCatTitle += CCat::GetCatByIndex(iIndex)->GetComment();
d585 1
a585 1
			strInfo.AppendFormat(_T("<b>%s</b><br><hr=100%%><br><b>%s:</b><t>%i / %i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%.1f %s<br><b>%s:</b><t>%s / %s<br><b>%s:</b><t>%s"),
d591 3
a593 1
				GetResString(IDS_SIZE_ON_DISK), CastItoXBytes(iRealSize));
@


1.131
log
@Moved GetItemUnderMouse to otherfunctions.
@
text
@d1605 7
a1611 1
	if (g_eMuleApp.m_pGlobPrefs->ShowCatTabInfo())
d1613 1
a1613 8
		CDownloadList::PartFileVector  *pvecPartFiles;
		uint32							dwTotalCount = 0;
		uint32							dwDownloading = 0;

	//	Count the number of files in the DownloadQueue belonging to the
	//		'index'th category and the number of those currently downloading.
	//
		if ((pvecPartFiles = g_eMuleApp.m_pDownloadList->GetFiles()) != NULL)
d1615 1
a1615 3
			for(unsigned int i = 0; i < pvecPartFiles->size(); i++)
			{
				CPartFile		*pPartFile = (*pvecPartFiles)[i];
d1617 2
a1618 2
				if (pPartFile == NULL)
					continue;
d1620 5
a1624 6
				if (CCat::FileBelongsToGivenCat(pPartFile,CCat::GetCatIDByIndex(index)))
				{
					dwTotalCount++;
					if(pPartFile->GetTransferringSrcCount() > 0)
						dwDownloading++;
				}
d1627 1
d1629 2
a1630 2
		delete pvecPartFiles;
		pvecPartFiles = NULL;
d1632 1
a1632 1
	//	Append the appropriate information to the tab label
d1634 9
a1642 10
	//	KuSh: what about not displaying dwDownloading if null ?
		if (!CCat::GetCatByIndex(index)->IsPredefined()/* && dwDownloading > 0*/)
		{
			strNewLabel.AppendFormat(_T(" %u/%u"), dwDownloading, dwTotalCount);
		}
		else
		{
		//	We don't really need a download count on predefined cats.
			strNewLabel.AppendFormat(_T(" %u"), dwTotalCount);
		}
@


1.130
log
@Customizable temporary directory for categories
@
text
@a514 28
int CTransferWnd::GetItemUnderMouse(CListCtrl* ctrl)
{
	EMULE_TRY

	CPoint pt;

	::GetCursorPos(&pt);
	ctrl->ScreenToClient(&pt);

	LVHITTESTINFO hit, subhit;

	hit.pt = pt;
	subhit.pt = pt;
	ctrl->SubItemHitTest(&subhit);

	int sel = ctrl->HitTest(&hit);

	if (sel != LB_ERR && (hit.flags & LVHT_ONITEM))
	{
		if (subhit.iSubItem == 0)
			return sel;
	}

	EMULE_CATCH

	return LB_ERR;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.129
log
@Improve string processing.
@
text
@d1220 1
a1220 1
			int newindex = AddCategory("?", g_eMuleApp.m_pGlobPrefs->GetIncomingDir(), "", "", true);
d1683 2
a1684 2
int CTransferWnd::AddCategory( CString strNewTitle,CString strNewIncoming,CString strNewComment,
							   CString strNewAutoCatExt, bool bAddTab)
d1686 1
a1686 1
	CCat		*pNewCat = new CCat(strNewTitle,strNewIncoming,strNewComment,strNewAutoCatExt);
@


1.128
log
@Preparations for new client version report code.
@
text
@d261 1
a261 1
	CString		strDownloads, strUploads;
d263 1
a263 1
	strDownloads.Format(GetResString(IDS_RUP_DOWNINFO), g_eMuleApp.m_pDownloadQueue->GetFileCount(),
d269 1
d271 1
a271 1
	strUploads.Format(GetResString(IDS_RUP_UPINFO), g_eMuleApp.m_pUploadQueue->GetWaitingUserCount(),
d274 2
a275 4
					  static_cast<double>(g_eMuleApp.m_pUploadQueue->GetDataRate())/1024.0);

	m_ctlRollup.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strDownloads, m_pwndDummyForDownloadList, 0, TRUE);
	m_ctlRollup.InsertItem(GetResString(IDS_RUP_UPLOADS), strUploads, &m_ctlUploadList, 1, TRUE);
d870 7
a876 1
	if(m_nActiveWnd == MPW_UPLOADQUEUELIST)
d878 4
a881 7
		CString buffer = "";
		if(m_ctlQueueList.m_iClientFilter == 1)
			buffer.Format(" (%s)", GetResString(IDS_BANNED));
		else if(m_ctlQueueList.m_iClientFilter == 2)
			buffer.Format(" (%s)", GetResString(IDS_CW_FRIENDS));
		else if(m_ctlQueueList.m_iClientFilter == 3)
			buffer.Format(" (%s)", GetResString(IDS_WITHCREDITS));
d883 1
a883 1
		m_ctlRollup.SetText(1, GetResString(IDS_ONQUEUE)+buffer, true);
a1593 2
	CString		strCatTitle;

d1597 2
@


1.127
log
@Unified processing of client icon images.
@
text
@d664 1
a664 1
					GetResString(IDS_CLIENT), pSource->GetFullIP(), pSource->GetUserPort(), GetClientNameAndVersionString(pSource));
@


1.126
log
@minor change
@
text
@d750 3
a752 32
				//Set the tooltip icon - Hehe with new icons this time :P
				switch(pSource->GetClientSoft())
				{
				case SO_AMULE:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_AMULE);
					break;
				case SO_LMULE:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_LMULE);
					break;
				case SO_SHAREAZA:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_SHAREAZA);
					break;
				case SO_EDONKEYHYBRID:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_EDONKEYHYBRID);
					break;
				case SO_MLDONKEY:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_MLDONKEY);
					break;
				case SO_EMULE:
				case SO_OLDEMULE:
					if(pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
						pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_SECUREHASH);
					else
						pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_COMPROT);
					break;
				case SO_EDONKEY:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_NORMAL);
					break;
				default:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_UNKNOWN);
					break;
				}
@


1.125
log
@Added active, paused and stopped files counters to download list header.
@
text
@a620 1
			m_ctlDLTabs.SetFocus();
a783 1
			m_ctlDownloadList.SetFocus();
a798 1
			m_ctlUploadList.SetFocus();
a813 1
			m_ctlQueueList.SetFocus();
a828 1
			m_ctlClientList.SetFocus();
@


1.124
log
@Fixed a crash on exit + minor change
@
text
@d264 3
d986 6
a991 3
					  g_eMuleApp.m_pDownloadQueue->GetFileCount(),
					  g_eMuleApp.m_pDownloadQueue->GetTransferringFiles(),
					  static_cast<double>(g_eMuleApp.m_pDownloadQueue->GetDataRate())/1024.0 );
@


1.123
log
@IRC channel messages now supports background color coded messages (Thanks SyruS!);
Added a Word Wrap context menu option to logs, IRC & messages;
Fixed category tabs padding (Mantis bug #0000415);
Improved logs, IRC & messages code + formatting & name changes
@
text
@d1622 3
@


1.122
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d102 2
a103 2
//#define TRIANGLESIZE	15
#define TRIANGLESIZE	((rItem.bottom-rItem.top+1)/2)
d143 1
a143 1
		CBrush		*pOldBrush,newBrush;
d150 3
a152 3
		pDC->MoveTo(rItem.left+2,rItem.top+1);
		pDC->LineTo(rItem.left+2+TRIANGLESIZE,rItem.top+1);
		pDC->LineTo(rItem.left+2,rItem.top+1+TRIANGLESIZE);
d216 1
a216 1
	m_bFirstShow=true;
d222 1
a222 1
	CRect rRollupArea;
d232 4
a235 6
	CWnd *pParent = &m_ctlRollup;
	CRect rItem = CRect(0,0,0,0);

	DWORD dwListStyle = WS_CHILD|WS_BORDER|WS_TABSTOP|LVS_REPORT|LVS_ALIGNLEFT|
						LVS_OWNERDRAWFIXED|LVS_SINGLESEL;
	DWORD dwTabStyle = WS_CHILD|WS_VISIBLE|TCS_HOTTRACK|TCS_SINGLELINE|TCS_TOOLTIPS;
a250 1
	m_ctlDLTabs.Create(dwTabStyle, CRect(0,0,0,20), pParent, TRANS_DOWNLOADTABS);
d252 1
d254 2
d261 2
a262 1
	CString strDownloads;
d266 1
a266 1
	CString strUploads;
@


1.121
log
@small correction
@
text
@d750 2
a751 2
				case SO_CDONKEY:
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_CDONKEY);
@


1.120
log
@a better way to disable tooltips
@
text
@d351 14
a381 15
	if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_MOUSEWHEEL)
	{
		CPoint	point;

		::GetCursorPos(&point);

		if ((point.x != m_pLastMousePoint.x) || (point.y != m_pLastMousePoint.y))
		{
			m_pLastMousePoint = point;

		//	Handle tooltip updating, when mouse is moved from one item to another
			UpdateToolTips();
		}
	}

@


1.119
log
@small correction
@
text
@d337 1
a337 1
	switch (pMsg->message)
d339 12
a350 9
		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_RBUTTONDOWN:
		case WM_RBUTTONUP:
		case WM_MOUSEMOVE:
		case WM_MOUSEWHEEL:
		case WM_KEYDOWN:
		case WM_SYSKEYDOWN:
			m_ttip.RelayEvent(pMsg);
a544 3
	if (g_eMuleApp.m_pGlobPrefs->GetToolTipDelay() == 0)
		return FALSE;

@


1.118
log
@Tooltip delay of zero is now used to disable tooltips
@
text
@d300 2
a301 2
	m_ttip.SetDelayTime(TTDT_INITIAL, g_eMuleApp.m_pGlobPrefs->GetToolTipDelay()*1000+25);	//netwolf: avoid jitter when delay is set to 0
	m_ttip.SendMessage(TTM_SETMAXTIPWIDTH, 0, SHRT_MAX); // recognize \n chars
@


1.117
log
@Optimization of category title in tooltips by KuSh
@
text
@d542 3
@


1.116
log
@minor correction
@
text
@d565 2
a566 14
			if (iIndex < CCat::GetNumPredefinedCats())
			{
				if (iIndex == 0)
				{
					strCatTitle = CCat::GetPredefinedCatTitle(CCat::GetAllCatType());
					if (CCat::GetAllCatType() != CAT_ALL)
					{
						strCatTitle.Insert(0, _T("["));
						strCatTitle += _T("]");
					}
				}
				else
					strCatTitle = CCat::GetPredefinedCatTitle(CCat::GetCatIDByIndex(iIndex));
			}
d568 3
a571 1
				strCatTitle = CCat::GetCatByIndex(iIndex)->GetTitle();
@


1.115
log
@Category tooltip title now have the same look as it's owner (hope you like it better now KuSh :-) )
@
text
@d542 2
a543 2
	NM_PPTOOLTIP_DISPLAY * pNotify = (NM_PPTOOLTIP_DISPLAY*)pNMH;
	int iControlId = CWnd::FromHandle(pNotify->ti->hWnd)->GetDlgCtrlID();
d564 2
a565 2
			
			if (iIndex == 0)
d567 1
a567 3
				strCatTitle = CCat::GetPredefinedCatTitle(CCat::GetAllCatType());

				if  (CCat::GetAllCatType() != CAT_ALL)
d569 6
a574 2
					strCatTitle.Insert(0, _T("["));
					strCatTitle += _T("]");
d576 2
d585 1
a585 1
			for(int i=0;i<g_eMuleApp.m_pDownloadQueue->GetFileCount();i++)
@


1.114
log
@Advanced Log tooltip on status bar;
Tooltip width should be now correct
@
text
@d563 1
a563 2
			CString		strCatTitle = CCat::GetCatByIndex(iIndex)->GetTitle();
			COLORREF	crCatColor = CCat::GetCatColorByIndex(iIndex);
d565 2
a566 1
			if (iIndex == 0 && CCat::GetAllCatType() != CAT_ALL)
d569 12
a603 3
			if (crCatColor == GetSysColor(COLOR_INFOBK))
				crCatColor = GetSysColor(COLOR_INFOTEXT);

d613 2
a614 2
			strInfo.Format(_T("<cat=0x%06x><b>%s</b><br><hr=100%%><br><b>%s:</b><t>%i / %i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%.1f %s<br><b>%s:</b><t>%s / %s<br><b>%s:</b><t>%s"),
				crCatColor, strCatTitle,
@


1.113
log
@better way to indicate category color in tooltips
@
text
@a301 1

a541 2
	//TOOLTIPTEXT *pText = (TOOLTIPTEXT *)pNMH;
	//int control_id = ::GetDlgCtrlID((HWND)pNMH->idFrom);
@


1.112
log
@Removed a duplicate string (Thx Aw3) + Minor change
@
text
@d607 2
a608 2
			strInfo.Format(_T("<ct=0x%06x><hr=100%%><ct><br><al_c><b>%s</b><al><br><ct=0x%06x><hr=100%%><ct><br><b>%s:</b><t>%i / %i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%i<br><b>%s:</b><t>%.1f %s<br><b>%s:</b><t>%s / %s<br><b>%s:</b><t>%s"),
				crCatColor, strCatTitle, crCatColor,
@


1.111
log
@Correctly show category title when a view filter is set (Thx KuSh!)
@
text
@d730 1
a730 1
							strInfo += GetResString(IDS_TT_CMT_NOTRATED);
@


1.110
log
@Tooltips string improvements
@
text
@d568 3
@


1.109
log
@Improved category tabs tooltips; Reduced tooltips visiblity time; some tooltips related fixes
@
text
@d611 2
a638 1
				m_ctlDownloadList.SetFocus();
d645 1
a645 1
				CString				strCountry, strDownloaded, strUploaded, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = pSource->GetUserName();
d654 3
a656 2
				strUserInfo += GetResString(IDS_TT_CLIENT);
				strUserInfo.Insert(strUserInfo.GetLength() - 4, _T(" (<b>") + GetClientNameAndVersionString(pSource) + _T("</b>)"));
d662 2
a663 2
					CString strServerLine, strServerName = pServer->GetListName();
					in_addr				serverAddr;
d666 2
a669 1
					strServerLine.Format(GetResString(IDS_TT_SERVER), inet_ntoa(serverAddr), pSource->GetServerPort());
d671 5
a675 2
						strServerLine.Insert(strServerLine.GetLength() - 4, _T(" (<b>") + strServerName + _T("</b>)"));
					strUserInfo += strServerLine;
d679 1
a679 1
					strDownloaded.Format(_T("<b>%s:</b><t>%s (%s)<br>"), GetResString(IDS_STATS_DDATA), CastItoXBytes(pSource->GetTransferredUp()), CastItoXBytes(pSource->Credits()->GetUploadedTotal()));
d681 2
a682 2
					strDownloaded.Format(_T("<b>%s:</b><t>%s<br>"), GetResString(IDS_STATS_DDATA), CastItoXBytes(pSource->GetTransferredUp()));
				strUserInfo += strDownloaded;
d685 1
a685 1
					strUploaded.Format(_T("<b>%s:</b><t>%s (%s)<br>"), GetResString(IDS_STATS_UDATA), CastItoXBytes(pSource->GetTransferredDown()), CastItoXBytes(pSource->Credits()->GetDownloadedTotal()));
d687 2
a688 2
					strUploaded.Format(_T("<b>%s:</b><t>%s<br>"), GetResString(IDS_STATS_UDATA), CastItoXBytes(pSource->GetTransferredDown()));
				strUserInfo += strUploaded;
d690 3
a692 5
				strUserInfo += GetResString(IDS_TT_SOURCEINFO);
				strUserInfo += GetResString(IDS_TT_SOURCEINFO2);
				strInfo.Format(strUserInfo, strUserName, pSource->GetUserID(), strCountry, 
					pSource->GetFullIP(), pSource->GetUserPort(),
					pSource->GetAskedCountDown(), pSource->GetAvailablePartCount());
d698 1
a698 1
						strInfo.AppendFormat(GetResString(IDS_TT_CLIENTSOURCENAME), pSource->GetClientFilename());
d706 1
a706 2
						strInfo.AppendFormat( GetResString(IDS_TT_ASKEDFAF),
							pSource->m_pReqPartFile->GetFileName() );
d719 1
a719 1
							strInfo.AppendFormat(GetResString(IDS_TT_CMT_READ), pSource->GetFileComment());
d723 1
a723 2
							//	No comment entered
							strInfo += GetResString(IDS_TT_CMT_NONE);
a724 2
						//
						//	File rating
d731 1
a731 2
							strInfo.AppendFormat( GetResString(IDS_TT_CMT_RATING),
								GetRatingString(pSource->GetFileRating()) );
d738 1
a738 1
					strInfo += GetResString(IDS_TT_CMT_NOTCONNECTED);
a739 2
				strInfo.TrimRight(_T("<br>"));

d776 1
a778 1

@


1.108
log
@double clicking the status bar's session time switches to statistics dialog;
added session time tooltip;
added uploaded/downloaded data to clients tooltips
@
text
@a194 1
	m_pttDlTabToolTips = NULL;
d199 5
a203 1
	m_nLastCatTT = -1;	//none
a207 2
	if (m_pttDlTabToolTips != NULL)
		m_pttDlTabToolTips->DestroyToolTipCtrl();
d293 5
a297 1
	// create tooltip
d299 1
a299 1
	m_ttip.SetDelayTime(TTDT_AUTOPOP, 20000);
d301 1
a301 1
	m_ttip.SendMessage(TTM_SETMAXTIPWIDTH, 0, SHRT_MAX); // recognize \n chars!
a302 1
	//BEGIN Improved Tooltips
d309 1
a310 19
	//END Improved Tooltips

	//
	//	Initialize the Category tabs
	//
	for (int ix = 0; ix < CCat::GetNumCats(); ix++)
		m_ctlDLTabs.InsertItem(ix,CCat::GetCatByIndex(ix)->GetTitle() );
	m_pttDlTabToolTips= new CToolTipCtrl;
	m_pttDlTabToolTips->Create(this, TTS_NOPREFIX);
	m_ctlDLTabs.SetToolTips(m_pttDlTabToolTips);
	UpdateTabToolTips();
	m_pttDlTabToolTips->SendMessage(TTM_SETMAXTIPWIDTH, 0, SHRT_MAX); // recognize \n chars!
	m_pttDlTabToolTips->SetDelayTime(TTDT_AUTOPOP, 20000);
	m_pttDlTabToolTips->SetDelayTime(TTDT_INITIAL, 0);
	m_pttDlTabToolTips->Activate(TRUE);

	m_iOldToolTipItemDown = -1;
	m_iOldToolTipItemUp = -1;
	m_iOldToolTipItemQueue = -1;
d338 1
a338 5
	// eklmn: bugfix(07): Update tooltip only in case corresponding WM_MESSAGE
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONUP
		|| pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_RBUTTONUP
		|| pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_MOUSEWHEEL
		|| pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN )
d340 9
a348 1
		m_ttip.RelayEvent(pMsg);
d350 2
a351 1
	if (pMsg->message== WM_LBUTTONDBLCLK && pMsg->hwnd == m_ctlDLTabs.GetSafeHwnd())
d365 1
d371 1
a377 9

			m_nTabDropIndex = GetTabUnderMouse(&point);

			if (m_nTabDropIndex != m_nLastCatTT)
			{
				m_nLastCatTT = m_nTabDropIndex;
				if (m_nTabDropIndex != -1)
					UpdateTabToolTips(m_nTabDropIndex);
			}
d380 1
d384 3
a386 2
		int sel = GetItemUnderMouse(&m_ctlDownloadList);
		if (sel != -1)
d392 1
a392 1
			switch(m_nActiveWnd)
d424 35
a458 4
	//
	//	Update tooltips for DownloadList
	CListCtrl	*pListCtrl = &m_ctlDownloadList;	//(CListCtrl*)m_ctlRollup.GetItemClient(0);
	int			sel = GetItemUnderMouse(pListCtrl);	// this is a quick fix,
d460 4
a463 1
	if (sel != -1)							// we should find a better solution
d465 2
a466 1
		if (sel != m_iOldToolTipItemDown)
a468 3
			{
				//BEGIN Improved Tooltips
				//m_ttip.Update();
d470 1
a470 3
				//END Improved Tooltips
			}
			m_iOldToolTipItemDown = sel;
d475 14
a488 3
	//
	//	Update tooltips for UploadList
	int sel2 = GetItemUnderMouse((CListCtrl*)m_ctlRollup.GetItemClient(1));	// see above
d490 4
a493 1
	if (sel2 != -1)
d495 2
a496 1
		if (sel2 != m_iOldToolTipItemUp)
d498 1
a498 3
			if(m_ttip.IsWindowVisible())
			{
				// Improved Tooltips
d500 1
a500 2
			}
			m_iOldToolTipItemUp = sel2;
d505 1
a505 5
	//
	//	Update tooltips for InfoList
/* no tooltips needed ATM
*/
	if (sel == -1 && sel2 == -1 /*&& sel3 != -1*/)
d555 58
a1380 67
void CTransferWnd::UpdateTabToolTips(int tab)
{
	byte i;

	if (tab == -1)
	{
		for (i=0;i<m_pttDlTabToolTips->GetToolCount();i++)
			m_pttDlTabToolTips->DelTool(&m_ctlDLTabs,i+1);

		for (i = 0; i < m_ctlDLTabs.GetItemCount(); i++)
		{
			CRect r;
			m_ctlDLTabs.GetItemRect(i, &r);
			VERIFY(m_pttDlTabToolTips->AddTool(&m_ctlDLTabs, GetTabStatistic(i), &r, i+1));
		}
	}
	else
	{
		CRect r;
		m_ctlDLTabs.GetItemRect(tab, &r);

		m_pttDlTabToolTips->DelTool(&m_ctlDLTabs,tab+1);
		VERIFY(m_pttDlTabToolTips->AddTool(&m_ctlDLTabs, GetTabStatistic(tab), &r, tab+1));
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CString CTransferWnd::GetTabStatistic(byte tab)
{
	uint16 count = 0,dwl = 0, paused = 0, stopped = 0;
	double speed = 0.0;
	uint64 size = 0, trsize = 0, realsize = 0;
	CPartFile* cur_file;

	for(int i=0;i<g_eMuleApp.m_pDownloadQueue->GetFileCount();i++)
	{
		cur_file=g_eMuleApp.m_pDownloadQueue->GetFileByIndex(i);

		if(cur_file != 0)
		{
			if(CCat::FileBelongsToGivenCat(cur_file, CCat::GetCatIDByIndex(tab)))
			{
				count++;
				if(cur_file->GetTransferringSrcCount() > 0)
					dwl++;
				if(cur_file->IsPaused() && !cur_file->IsStopped())
					paused++;
				if(cur_file->IsStopped())
					stopped++;
				speed += cur_file->GetDataRate() / 1024.0f;
				size += cur_file->GetFileSize();
				trsize += cur_file->GetCompletedSize();
				realsize += cur_file->GetRealFileSize();
			}
		}
	}

	CString strTitle;
	strTitle.Format("%s: %i/%i\n%s: %i\n%s: %i\n%s: %.1f %s\n%s: %s/%s\n%s: %s",
		GetResString(IDS_DOWNLOADING), dwl, (count - paused - stopped),
		GetResString(IDS_PAUSED), paused,
		GetResString(IDS_STOPPED), stopped,
		GetResString(IDS_DL_SPEED) ,speed,GetResString(IDS_KBYTESEC),
		GetResString(IDS_DL_SIZE),CastItoXBytes(trsize),CastItoXBytes(size),
		GetResString(IDS_SIZE_ON_DISK), CastItoXBytes(realsize) );
	return strTitle;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a1640 1
	UpdateTabToolTips();
@


1.107
log
@Fix for Edit Category dialog opening on downloadlist header double click.
@
text
@d528 1
d562 1
a562 2
				in_addr				serverAddr;
				CString				strCountry, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = pSource->GetUserName();
a563 1
				serverAddr.S_un.S_addr = pSource->GetServerIP();
d573 1
a573 1
				strUserInfo += GetResString(IDS_TT_SERVER);
d578 4
a581 1
					CString strServerName = pServer->GetListName();
d584 4
a587 1
					strUserInfo.Insert(strUserInfo.GetLength() - 4, _T(" (<b>") + strServerName + _T("</b>)"));
d589 13
d605 1
a605 1
					pSource->GetFullIP(), pSource->GetUserPort(), inet_ntoa(serverAddr), pSource->GetServerPort(),
@


1.106
log
@Formatting and some improvements in tooltips code
@
text
@d360 1
a360 1
	if (pMsg->message== WM_LBUTTONDBLCLK)
d367 1
@


1.105
log
@Fixed corrupted gui.dat data processing;
Fixed exception during gui.dat saving after failed startup
(before gui.dat was reset to zero size); Minor optimization.
@
text
@d521 1
a521 1
	int control_id = CWnd::FromHandle(pNotify->ti->hWnd)->GetDlgCtrlID();
d523 1
a523 1
	if (!control_id)
d526 2
a527 2
	CString info;
	switch(control_id)
d534 3
a536 2
			int sel = GetItemUnderMouse(&m_ctlDownloadList);
			if (sel < 0 || sel == 65535)
d540 1
a540 1
			CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(m_ctlDownloadList.GetItemData(sel));
a546 3

				info = pPartFile->GetDownloadFileInfo4Tooltips();

d549 1
d551 1
a551 3
				SHGetFileInfo( pPartFile->GetFileName(),
					FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi),
					SHGFI_ICON|SHGFI_USEFILEATTRIBUTES );
a552 1

d559 1
a559 1
				CUpDownClient	   *pSource = pSourceItem->GetSource();
d561 1
a561 1
				CString strCountry, strUserInfo = GetResString(IDS_TT_USERINFO), strUserName = pSource->GetUserName();
d574 1
a574 1
				CServer* pServer = g_eMuleApp.m_pServerList->GetServerByIP(pSource->GetServerIP(), pSource->GetServerPort());
d576 1
a576 1
				if (pServer)
d585 1
a585 1
				info.Format(strUserInfo, strUserName, pSource->GetUserID(), strCountry, 
d593 1
a593 1
						info.AppendFormat(GetResString(IDS_TT_CLIENTSOURCENAME), pSource->GetClientFilename());
d601 1
a601 1
						info.AppendFormat( GetResString(IDS_TT_ASKEDFAF),
d615 1
a615 1
							info.AppendFormat(GetResString(IDS_TT_CMT_READ), pSource->GetFileComment());
d620 1
a620 1
							info += GetResString(IDS_TT_CMT_NONE);
d626 1
a626 1
							info += GetResString(IDS_TT_CMT_NOTRATED);
d630 1
a630 1
							info.AppendFormat( GetResString(IDS_TT_CMT_RATING),
d638 1
a638 1
					info += GetResString(IDS_TT_CMT_NOTCONNECTED);
d640 1
a640 1
				info.TrimRight(_T("<br>"));
d686 1
a686 1
			int				sel = GetItemUnderMouse(&m_ctlUploadList);
d688 1
a688 1
			if (sel < 0 || sel == 65535)
d691 1
a691 3
			CUpDownClient*	pSource = (CUpDownClient*)m_ctlUploadList.GetItemData(sel);

			info = pSource->GetUploadFileInfo4Tooltips();
d693 1
a693 31
			switch(pSource->GetClientSoft())
			{
			case SO_CDONKEY:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_CDONKEY);
				break;
			case SO_LMULE:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_LMULE);
				break;
			case SO_SHAREAZA:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_SHAREAZA);
				break;
			case SO_EDONKEYHYBRID:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_EDONKEYHYBRID);
				break;
			case SO_MLDONKEY:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_MLDONKEY);
				break;
			case SO_EMULE:
			case SO_OLDEMULE:
				if(pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_SECUREHASH);
				else
					pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_COMPROT);
				break;
			case SO_EDONKEY:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_NORMAL);
				break;
			default:
				pNotify->ti->hIcon = m_ctlUploadList.m_imageList.ExtractIcon(UL_ICON_UNKNOWN);
				break;
			}
a696 1

d702 1
a702 1
			int				sel = GetItemUnderMouse(&m_ctlQueueList);
d704 1
a704 1
			if (sel < 0 || sel == 65535)
d707 1
a707 3
			CUpDownClient*	pSource = (CUpDownClient*)m_ctlQueueList.GetItemData(sel);

			info = pSource->GetClientInfo4Tooltips();
d709 1
a709 31
			switch(pSource->GetClientSoft())
			{
			case SO_CDONKEY:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_CDONKEY);
				break;
			case SO_LMULE:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_LMULE);
				break;
			case SO_SHAREAZA:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_SHAREAZA);
				break;
			case SO_EDONKEYHYBRID:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_EDONKEYHYBRID);
				break;
			case SO_MLDONKEY:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_MLDONKEY);
				break;
			case SO_EMULE:
			case SO_OLDEMULE:
				if(pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
					pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_SECUREHASH);
				else
					pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_COMPROT);
				break;
			case SO_EDONKEY:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_NORMAL);
				break;
			default:
				pNotify->ti->hIcon = m_ctlQueueList.m_imageList.ExtractIcon(UL_ICON_UNKNOWN);
				break;
			}
a712 1

d718 1
a718 1
			int				sel = GetItemUnderMouse(&m_ctlClientList);
d720 1
a720 1
			if (sel < 0 || sel == 65535)
d723 1
a723 1
			CUpDownClient*	pSource = (CUpDownClient*)m_ctlClientList.GetItemData(sel);
d725 1
a725 33
			info = pSource->GetClientInfo4Tooltips();

			switch(pSource->GetClientSoft())
			{
			case SO_CDONKEY:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_CDONKEY);
				break;
			case SO_LMULE:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_LMULE);
				break;
			case SO_SHAREAZA:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_SHAREAZA);
				break;
			case SO_EDONKEYHYBRID:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_EDONKEYHYBRID);
				break;
			case SO_MLDONKEY:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_MLDONKEY);
				break;
			case SO_EMULE:
			case SO_OLDEMULE:
				if(pSource->m_pCredits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
					pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_SECUREHASH);
				else
					pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_COMPROT);
				break;
			case SO_EDONKEY:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_NORMAL);
				break;
			default:
				pNotify->ti->hIcon = m_ctlClientList.m_imageList.ExtractIcon(UL_ICON_UNKNOWN);
				break;
			}
d730 1
a730 1
	pNotify->ti->sTooltip = info;
@


1.104
log
@Display client version and server name in tooltips
@
text
@d605 2
a606 2
						info.AppendFormat(GetResString(IDS_TT_ASKEDFAF),
							pSource->m_pReqPartFile->GetFileName());
d1030 7
d1040 1
d1057 1
a1057 1
        TCHAR seps[] = _T("|\n");
d1071 1
a1071 1
			pToken = _tcstok(cTemp, seps);
a1077 2
					//	Terminate the outer loop
					exp = 8;
d1085 1
a1085 1
				pToken = _tcstok(NULL, seps);
d1091 1
a1091 3
					//	Terminate both the inner and outer loops
					exp = 8;
					i = 3;
d1096 2
d1103 1
a1103 2
				//	Terminate the outer loop
				exp = 8;
d1117 1
a1117 1
			pToken = _tcstok(cTemp, seps);
d1124 1
a1124 1
					i = 3;
d1128 1
a1128 1
				pToken = _tcstok(NULL, seps);
d1138 1
a1138 3
	if(bUseDefault)
	{
		BYTE bExpandedItems;
d1140 3
a1142 44
		bExpandedItems = 0x00;
		fItemHeights[0][bExpandedItems] = 0;
		fItemHeights[1][bExpandedItems] = 0;
		fItemHeights[2][bExpandedItems] = 0;

		bExpandedItems = 0x01;
		fItemHeights[0][bExpandedItems] = 100;
		fItemHeights[1][bExpandedItems] = 0;
		fItemHeights[2][bExpandedItems] = 0;

		bExpandedItems = 0x02;
		fItemHeights[0][bExpandedItems] = 0;
		fItemHeights[1][bExpandedItems] = 100;
		fItemHeights[2][bExpandedItems] = 0;

		bExpandedItems = 0x03;
		fItemHeights[0][bExpandedItems] = 70;
		fItemHeights[1][bExpandedItems] = 30;
		fItemHeights[2][bExpandedItems] = 0;

		bExpandedItems = 0x04;
		fItemHeights[0][bExpandedItems] = 0;
		fItemHeights[1][bExpandedItems] = 0;
		fItemHeights[2][bExpandedItems] = 100;

		bExpandedItems = 0x05;
		fItemHeights[0][bExpandedItems] = 70;
		fItemHeights[1][bExpandedItems] = 0;
		fItemHeights[2][bExpandedItems] = 30;

		bExpandedItems = 0x06;
		fItemHeights[0][bExpandedItems] = 0;
		fItemHeights[1][bExpandedItems] = 70;
		fItemHeights[2][bExpandedItems] = 30;

		bExpandedItems = 0x07;
		fItemHeights[0][bExpandedItems] = 50;
		fItemHeights[1][bExpandedItems] = 25;
		fItemHeights[2][bExpandedItems] = 25;
	}

	m_ctlRollup.SetItemHeights(0, fItemHeights[0], 8);
	m_ctlRollup.SetItemHeights(1, fItemHeights[1], 8);
	m_ctlRollup.SetItemHeights(2, fItemHeights[2], 8);
d1151 5
a1155 2
	FILE *f;
	CString fullpath; // i_a
d1157 2
a1158 2
	fullpath.Format(_T("%sgui.dat"), g_eMuleApp.m_pGlobPrefs->GetConfigDir());
	f = _tfopen(fullpath, _T("wb"));
d1160 1
a1160 3
	if(f)
	{
		for(int exp = 0; exp < 8; exp++)
d1162 3
a1164 1
			double f1,f2,f3;
d1166 19
a1184 18
			f1 = m_ctlRollup.GetItem(0)->pSizes[exp];
			f2 = m_ctlRollup.GetItem(1)->pSizes[exp];
			f3 = m_ctlRollup.GetItem(2)->pSizes[exp];

			// get rid off some rounding errors: ///
			if(f3)
				f3 = f1 ? (f2 ? (100 - f1 - f2) : (100 - f1)) : (100 - f2);
			else if(f2)
				f2 = 100 - f1;
			////////////////////////////////////////

			fprintf(f, "%f|%f|%f\n", f1, f2, f3);
		}
		fprintf( f, "%d|%d|%d\n",
				 m_ctlRollup.GetItem(0)->pHeader->IsExpanded(),
				 m_ctlRollup.GetItem(1)->pHeader->IsExpanded(),
				 m_ctlRollup.GetItem(2)->pHeader->IsExpanded() );
		fclose(f);
@


1.103
log
@minor changes
@
text
@d565 1
d568 3
a570 2

				CString strCountry, strUserName = pSource->GetUserName();
d575 16
a590 11
				strUserName.Trim();
				strUserName.Replace(_T("\n"), _T("<br>"));
				strUserName.Replace(_T("<"), _T("<<"));
				info.Format( GetResString(IDS_TT_USERINFO)
					+ GetResString(IDS_TT_CLIENT)
					+ GetResString(IDS_TT_SERVER)
					+ GetResString(IDS_TT_SOURCEINFO)
					+ GetResString(IDS_TT_SOURCEINFO2),
					strUserName, pSource->GetUserID(), strCountry,
					pSource->GetFullIP(), pSource->GetUserPort(),
					inet_ntoa(serverAddr), pSource->GetServerPort(),
@


1.102
log
@Tooltips alignment is now automatic;  Improved status bar tooltips
@
text
@d568 1
a568 1
				CString strCountry;
d572 4
d581 1
a581 1
					pSource->GetUserName(), pSource->GetUserID(), strCountry,
d589 2
a590 1
					info.AppendFormat(GetResString(IDS_TT_CLIENTSOURCENAME), pSource->GetClientFilename());
d598 2
a599 2
						info.AppendFormat( GetResString(IDS_TT_ASKEDFAF),
							pSource->m_pReqPartFile->GetFileName() );
d610 1
a610 1
						if (pSource->GetFileComment() != "")
d637 2
@


1.101
log
@Corrected availability check of country name (more correct if flags weren't loaded).
@
text
@d568 1
a568 1
				CString strCountry, strUserInfo = GetResString(IDS_TT_USERINFO);
a569 1
				strUserInfo.Replace(_T("%u"), _T("%u%s"));
d572 1
a572 1
				info.Format( strUserInfo
@


1.100
log
@added tooltips to the Server list
@
text
@d571 1
a571 1
				if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
@


1.99
log
@Double-click on category tab opens 'Edit category' dialog
@
text
@d527 1
a527 1
	if (control_id == TRANS_DOWNLOADLIST)
d529 4
a532 2
		if (m_ctlDownloadList.GetItemCount() < 1)
			return FALSE;
d534 3
a536 3
		int sel = GetItemUnderMouse(&m_ctlDownloadList);
		if (sel < 0 || sel == 65535)
			return FALSE;
d538 4
a541 4
	//	Build info text and display it
		CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(m_ctlDownloadList.GetItemData(sel));
		CPartFileDLItem		*pPartFileItem = dynamic_cast<CPartFileDLItem*>(pItem);
		CSourceDLItem		*pSourceItem = dynamic_cast<CSourceDLItem*>(pItem);
d543 3
a545 3
		if (pPartFileItem != NULL)
		{
			CPartFile		*pPartFile = pPartFileItem->GetFile();
d547 1
a547 1
			info = pPartFile->GetDownloadFileInfo4Tooltips();
d549 1
a549 1
			SHFILEINFO		shfi;
d551 5
a555 5
			memzero(&shfi, sizeof(shfi));
			SHGetFileInfo( pPartFile->GetFileName(),
						   FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi),
						   SHGFI_ICON|SHGFI_USEFILEATTRIBUTES );
			pNotify->ti->hIcon = shfi.hIcon;
d557 4
a560 4
			m_ctlDownloadList.SetFocus();
		}
		else if (pSourceItem != NULL)
		{
d562 20
a581 20
			bool				bA4AF = pSourceItem->IsAskedForAnotherFile();
			CUpDownClient	   *pSource = pSourceItem->GetSource();
			in_addr				serverAddr;

			serverAddr.S_un.S_addr = pSource->GetServerIP();

			CString strCountry, strUserInfo = GetResString(IDS_TT_USERINFO);

			strUserInfo.Replace(_T("%u"), _T("%u%s"));
			if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
				 strCountry.Format(_T(" (<b>%s</b>)"), pSource->GetCountryName());
			info.Format( strUserInfo
					   + GetResString(IDS_TT_CLIENT)
					   + GetResString(IDS_TT_SERVER)
					   + GetResString(IDS_TT_SOURCEINFO)
					   + GetResString(IDS_TT_SOURCEINFO2),
					   pSource->GetUserName(), pSource->GetUserID(), strCountry,
					   pSource->GetFullIP(), pSource->GetUserPort(),
					   inet_ntoa(serverAddr), pSource->GetServerPort(),
					   pSource->GetAskedCountDown(), pSource->GetAvailablePartCount());
d583 1
a583 10
			if (!bA4AF)
			{
			//	Normal client
				info.AppendFormat(GetResString(IDS_TT_CLIENTSOURCENAME), pSource->GetClientFilename());
			}
		//	If Asked For Another File...
			else
			{
			//	Cax2- get local file name
				try
d585 2
a586 2
					info.AppendFormat( GetResString(IDS_TT_ASKEDFAF),
											pSource->m_pReqPartFile->GetFileName() );
d588 2
a589 8
				catch(...)
				{
				}
			}
         //-For File Comment-//
			try
			{
				if (!bA4AF)
d591 2
a592 1
					if (pSource->GetFileComment() != "")
d594 2
a595 1
						info.AppendFormat(GetResString(IDS_TT_CMT_READ), pSource->GetFileComment());
d597 1
a597 1
					else
a598 2
					//	No comment entered
						info += GetResString(IDS_TT_CMT_NONE);
d600 5
a604 3
				//
				//	File rating
					if (GetRatingString(pSource->GetFileRating()) == GetResString(IDS_CMT_NOTRATED))
d606 20
a625 6
						info += GetResString(IDS_TT_CMT_NOTRATED);
					}
					else
					{
						info.AppendFormat( GetResString(IDS_TT_CMT_RATING),
										  GetRatingString(pSource->GetFileRating()) );
d628 6
a633 7
			}
			catch(...)
			{
				//Information not received = not connected or connecting
				info += GetResString(IDS_TT_CMT_NOTCONNECTED);
			}
			//-End file comment-//
d635 3
a637 3
			//Set the tooltip icon - Hehe with new icons this time :P
			switch(pSource->GetClientSoft())
			{
d666 2
d669 1
a669 1
#endif //OLD_SOCKETS_ENABLED
a670 5
	}
	else if (control_id == TRANS_UPLOADLIST)
	{
		if (m_ctlUploadList.GetItemCount() < 1)
			return FALSE;
d672 6
a677 1
		int				sel = GetItemUnderMouse(&m_ctlUploadList);
d679 2
a680 2
		if (sel < 0 || sel == 65535)
			return FALSE;
d682 1
a682 1
		CUpDownClient*	pSource = (CUpDownClient*)m_ctlUploadList.GetItemData(sel);
d684 1
a684 1
		info = pSource->GetUploadFileInfo4Tooltips();
d686 2
a687 2
		switch(pSource->GetClientSoft())
		{
d716 3
a719 6
		m_ctlUploadList.SetFocus();
	}
	else if (control_id == TRANS_QUEUELIST)
	{
		if (m_ctlQueueList.GetItemCount() < 1)
			return FALSE;
d721 6
a726 1
		int				sel = GetItemUnderMouse(&m_ctlQueueList);
d728 2
a729 2
		if (sel < 0 || sel == 65535)
			return FALSE;
d731 1
a731 1
		CUpDownClient*	pSource = (CUpDownClient*)m_ctlQueueList.GetItemData(sel);
d733 1
a733 1
		info = pSource->GetClientInfo4Tooltips();
d735 2
a736 2
		switch(pSource->GetClientSoft())
		{
d765 3
a768 6
		m_ctlQueueList.SetFocus();
	}
	else if (control_id == TRANS_CLIENTLIST)
	{
		if (m_ctlClientList.GetItemCount() < 1)
			return FALSE;
d770 6
a775 1
		int				sel = GetItemUnderMouse(&m_ctlClientList);
d777 2
a778 2
		if (sel < 0 || sel == 65535)
			return FALSE;
d780 1
a780 1
		CUpDownClient*	pSource = (CUpDownClient*)m_ctlClientList.GetItemData(sel);
d782 1
a782 1
		info = pSource->GetClientInfo4Tooltips();
d784 2
a785 2
		switch(pSource->GetClientSoft())
		{
d814 3
a817 1
		m_ctlClientList.SetFocus();
@


1.98
log
@Middle mouse button click opens details of selected client or file
@
text
@d360 5
d366 7
@


1.97
log
@Added 'filesize on disk' info to details pane, file details, category tooltips and statistics
@
text
@d383 31
@


1.96
log
@Added paused and stopped files counter to category tooltip |
Downloading files are counted against active files now
@
text
@d1380 1
a1380 1
	uint64 size = 0, trsize = 0;
d1401 1
d1407 1
a1407 1
	strTitle.Format("%s: %i/%i\n%s: %i\n%s: %i\n%s: %.1f %s\n%s: %s/%s",
d1412 2
a1413 1
		GetResString(IDS_DL_SIZE),CastItoXBytes(trsize),CastItoXBytes(size) );
@


1.95
log
@added tooltips in On Queue & Known Clients lists
@
text
@d1378 1
a1378 2
	uint16 count,dwl;
	count= dwl = 0;
d1380 1
a1380 2
	uint64 size = 0;
	uint64 trsize = 0;
d1394 4
d1406 5
a1410 2
	strTitle.Format("%s: %i/%i\n%s: %.1f %s\n%s: %s/%s",
		GetResString(IDS_DOWNLOADING), dwl, count,GetResString(IDS_DL_SPEED) ,speed,GetResString(IDS_KBYTESEC),
@


1.94
log
@no longer loading mid size names + some small changes
@
text
@d303 2
a474 1
	//BEGIN Improved Tooltips
a478 1
	//END Improved Tooltips
a501 1
		//	BEGIN Improved Tooltips
a512 1
		//	END Improved Tooltips
a522 1
		//	BEGIN Improved Tooltips
a621 1
			//END Improved Tooltips
a638 1
		//Set the tooltip icon - Hehe with new icons this time :P
a669 1

a670 1
		//END Improved Tooltips
d682 48
a729 3
		// build info text and display it
		CUpDownClient*	pSource = (CUpDownClient*)m_ctlUploadList.GetItemData(sel);
		in_addr			server;
d731 1
a731 1
		server.S_un.S_addr = pSource->GetServerIP();
d733 32
a764 8
		info.Format(_T("Nickname: %s (UserID: %u)\n")
					_T("Client %s:%u\n")
					_T("Server %s:%u\n")
					_T("AskedCount: %u - AvailablePartCount: %u"),
					pSource->GetUserName(), pSource->GetUserID(),
					pSource->GetFullIP(), pSource->GetUserPort(),
					inet_ntoa(server), pSource->GetServerPort(),
					pSource->GetAskedCount(), pSource->GetAvailablePartCount());
@


1.93
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d530 1
a530 1
				 strCountry.Format(_T(" (<b>%s</b>)"), pSource->GetCountryName(true));
@


1.92
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d28 1
d526 6
a531 1
			info.Format( GetResString(IDS_TT_USERINFO)
d536 1
a536 1
					   pSource->GetUserName(), pSource->GetUserID(),
@


1.91
log
@Improved string processing
@
text
@d1446 1
a1446 1
	menu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.90
log
@Remake for display '&' on info pane; now also all fields can show '&' correctly;
Improved string processing.
@
text
@d538 1
a538 5
				CString		strClientSrcName;

				strClientSrcName.Format( GetResString(IDS_TT_CLIENTSOURCENAME),
										 CString(pSource->GetClientFilename()) );
				info += strClientSrcName;
d546 1
a546 3
					CString		strA4AFFileName;

					strA4AFFileName.Format( GetResString(IDS_TT_ASKEDFAF),
a547 1
					info += strA4AFFileName;
d560 1
a560 5
						CString		strFileComment;

						strFileComment.Format( GetResString(IDS_TT_CMT_READ),
											   CString(pSource->GetFileComment()) );
						info += strFileComment;
d575 1
a575 3
						CString		strRating;

						strRating.Format( GetResString(IDS_TT_CMT_RATING),
a576 1
						info += strRating;
d690 3
a692 3
					_T("Client %s:%d\n")
					_T("Server %s:%d\n")
					_T("AskedCount: %d - AvailablePartCount: %d"),
a696 1

d1605 1
a1605 1
//	EditCatTabLabel() changes the label of tab 'index' to 'newlabel' (with additional file count info if the
d1607 1
a1607 1
void CTransferWnd::EditCatTabLabel(int index,CString newlabel)
d1618 2
a1619 3
		CPartFile					   *pPartFile;
		uint16							iTotalCount = 0;
		uint16							iDownloading = 0;
d1624 1
a1624 1
		if (pvecPartFiles = g_eMuleApp.m_pDownloadList->GetFiles())
d1628 1
a1628 1
				pPartFile = (*pvecPartFiles)[i];
d1635 1
a1635 1
					iTotalCount++;
d1637 1
a1637 1
						iDownloading++;
a1645 2
	//
		CString strTitle=newlabel;
d1647 2
a1648 2
	//	KuSh: what about not displaying iDownloading if null ?
		if (!CCat::GetCatByIndex(index)->IsPredefined()/* && iDownloading > 0*/)
d1650 1
a1650 1
			newlabel.Format(_T("%s %i/%i"),strTitle,iDownloading,iTotalCount);
d1655 1
a1655 1
			newlabel.Format(_T("%s %i"),strTitle,iTotalCount);
d1659 1
a1659 1
	tabitem.pszText = newlabel.LockBuffer();
d1661 1
a1661 1
	newlabel.UnlockBuffer();
@


1.89
log
@display fix for & chars in filename for infolist pane
@
text
@d828 1
a828 1
	CString  strCatTitle = "";
d835 1
a836 1

d838 4
a841 1
				strCatTitle = _T("[") + strCatTitle + _T("]");
d900 1
a900 4
			strInfoHeader.Format(GetResString(IDS_RUP_INFOFILE), MakeStringEscaped(m_ctlInfoList.GetName()));
			break;
		default:
			strInfoHeader = "";
d1593 2
a1597 2
		CString		strCatTitle;

d1600 1
a1600 1
			byte		iCatID = CCat::GetAllCatType();
d1602 6
a1607 3
			strCatTitle = CCat::GetPredefinedCatTitle(CCat::GetAllCatType());
			if (iCatID != CAT_ALL)
				strCatTitle = _T("[") + strCatTitle + _T("]");
@


1.88
log
@minor optimization; formatting
@
text
@d897 1
a897 1
			strInfoHeader.Format(GetResString(IDS_RUP_INFOFILE), m_ctlInfoList.GetName());
@


1.87
log
@Improved context menu creation
@
text
@d360 2
a361 1
		POINT point;
d363 1
a363 1
		if (point.x!=m_pLastMousePoint.x || point.y!=m_pLastMousePoint.y)
d365 1
a365 1
			m_pLastMousePoint=point;
a367 1
			if (pMsg->message == WM_MOUSEMOVE || pMsg->message == WM_MOUSEWHEEL)
d370 1
a370 2
			CPoint pt(point);
			m_nTabDropIndex=GetTabUnderMouse(&pt);
d372 1
a372 1
			if (m_nTabDropIndex!=m_nLastCatTT)
d374 2
a375 2
				m_nLastCatTT=m_nTabDropIndex;
				if (m_nTabDropIndex!=-1)
d1192 1
a1192 1
			CString csName;
d1194 1
a1194 2
			csName.Format("%s", CCat::GetCatByIndex(m_iTabRightClickIndex)->GetTitle());
			EditCatTabLabel(m_iTabRightClickIndex,csName);
d1372 2
a1373 2
	CTitleMenu menu;
	POINT point;
d1377 1
a1377 2
	CPoint pt(point);

d1576 1
a1576 1
	POINT point;
d1580 1
a1580 2
	CPoint pt(point);
	int tab = GetTabUnderMouse(&pt);
d1582 5
a1586 4
	if (tab < CCat::GetNumPredefinedCats())
		return;
	m_iTabRightClickIndex = tab;
	OnCommand(MP_CAT_EDIT,0);
@


1.86
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d1381 1
a1381 16
	m_iTabRightClickIndex = GetTabUnderMouse(&pt);

	UINT		iPredefinedCatActionFlag;
	UINT		iIsAllOrUserFlag;
	int			iNumPredefinedCats = CCat::GetNumPredefinedCats();

	iPredefinedCatActionFlag = (m_iTabRightClickIndex < iNumPredefinedCats) ? MF_GRAYED : MF_STRING;
	iIsAllOrUserFlag = ((m_iTabRightClickIndex < iNumPredefinedCats) && !(m_iTabRightClickIndex == 0 && CCat::GetAllCatType() == CAT_ALL))? MF_GRAYED : MF_STRING;

	CMenu		m_viewMenu;

	m_viewMenu.CreateMenu();

	CMenu		m_catMenu;

	m_catMenu.CreateMenu();
d1383 5
a1387 7
	CMenu		m_priorityMenu;

	m_priorityMenu.CreateMenu();
	m_priorityMenu.AppendMenu(MF_STRING,MP_PRIOLOW,GetResString(IDS_PRIOLOW));
	m_priorityMenu.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
	m_priorityMenu.AppendMenu(MF_STRING,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
	m_priorityMenu.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));
d1392 2
d1396 19
a1414 18
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0,GetResString(IDS_CAT_ALL));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+1,GetResString(IDS_CAT_UNCATEGORIZED));
		m_viewMenu.AppendMenu(MF_SEPARATOR);
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+2,GetResString(IDS_CAT_INCOMPLETE));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+3,GetResString(IDS_CAT_COMPLETED));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+4,GetResString(IDS_CAT_WAITING));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+5,GetResString(IDS_CAT_DOWNLOADING));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+6,GetResString(IDS_CAT_ERRONEOUS));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+7,GetResString(IDS_CAT_PAUSED));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+8,GetResString(IDS_CAT_STOPPED));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+9,GetResString(IDS_CAT_STALLED));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+10,GetResString(IDS_CAT_ACTIVE));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+11,GetResString(IDS_CAT_INACTIVE));
		m_viewMenu.AppendMenu(MF_SEPARATOR);
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+12,GetResString(IDS_CAT_VIDEO));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+13,GetResString(IDS_CAT_AUDIO));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+14,GetResString(IDS_CAT_ARCHIVES));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+15,GetResString(IDS_CAT_CDIMAGES));
d1416 1
a1416 1
		m_viewMenu.CheckMenuItem(MP_CAT_SET_0 + CCat::GetAllCatType() - CAT_PREDEFINED, MF_CHECKED | MF_BYCOMMAND);
d1418 1
a1418 1
		menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_viewMenu.m_hMenu, GetResString(IDS_CHANGECATVIEW));
d1421 4
d1427 1
d1432 1
a1432 1
			UINT	checkFlag = 0;
a1433 1
			checkFlag = (catIndex == -1) ? MF_UNCHECKED : MF_CHECKED;
d1438 1
a1438 1
			m_catMenu.AppendMenu( MF_STRING | checkFlag,
d1445 1
a1445 1
				m_catMenu.AppendMenu(MF_SEPARATOR);
d1448 1
a1448 2

		menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_catMenu.m_hMenu, GetResString(IDS_CAT_SHOWSTATUSTAB));
d1453 2
a1454 2
	menu.AppendMenu(iPredefinedCatActionFlag,MP_CAT_EDIT,GetResString(IDS_CAT_EDIT));
	menu.AppendMenu(iPredefinedCatActionFlag,MP_CAT_REMOVE, GetResString(IDS_CAT_REMOVE));
d1456 1
a1456 1
	menu.AppendMenu(iIsAllOrUserFlag|MF_POPUP,(UINT_PTR)m_priorityMenu.m_hMenu, GetResString(IDS_PRIORITY) );
d1464 3
a1466 4
	menu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
	VERIFY( m_priorityMenu.DestroyMenu() );
	VERIFY( m_catMenu.DestroyMenu() );
	VERIFY(menu.DestroyMenu());
@


1.85
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d831 1
a831 1
	for (uint8 i = 0; i < CCat::GetNumPredefinedCats(); i++)
d1124 1
a1124 1
		uint8				iCatPos = wParam - MP_SHOWPREDEFINEDCAT_0;
d1301 1
a1301 1
	uint8 i;
d1325 1
a1325 1
CString CTransferWnd::GetTabStatistic(uint8 tab)
d1362 1
a1362 1
	uint8		catIndex;
d1609 1
a1609 1
	for (uint8 i = 0; i < m_ctlDLTabs.GetItemCount(); i++)
d1615 1
a1615 1
			uint8		iCatID = CCat::GetAllCatType();
d1728 1
a1728 1
	uint8	iNumPredefinedCats = CCat::GetNumPredefinedCats();
@


1.84
log
@minor changes
@
text
@d507 1
a507 1
			memset2(&shfi,0,sizeof(shfi));
@


1.83
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d1487 1
a1487 1
	if (iSel == -1) 
d1644 4
a1647 4
		CDownloadList::PartFileVector	*pvecPartFiles;
		CPartFile* pPartFile;
		uint16	iTotalCount = 0;
		uint16	iDownloading = 0;
d1677 2
a1678 1
		if (!CCat::GetCatByIndex(index)->IsPredefined())
d1680 1
a1680 1
			newlabel.Format("%s %i/%i",strTitle,iDownloading,iTotalCount);
d1685 1
a1685 1
			newlabel.Format("%s %i",strTitle,iTotalCount);
@


1.82
log
@fix for "+" & "-" keys, that were working in background
@
text
@d175 1
a175 1
	
d191 1
a191 1
{	
d199 1
a199 1
	m_nLastCatTT = -1;	//none 
d203 1
a203 1
{	
d210 1
a210 1
{	
d224 1
a224 1
	
d232 1
a232 1
	
d251 1
a251 1
	m_ctlDLTabs.Create(dwTabStyle, CRect(0,0,0,20), pParent, TRANS_DOWNLOADTABS);	
d263 1
a263 1
	CString strUploads;	
d265 1
a265 1
					  g_eMuleApp.m_pUploadQueue->GetUploadQueueLength(), 
d268 1
a268 1
	
d274 1
a274 1
	
d287 1
a287 1
		
d290 1
a290 1
	
d322 1
a322 1
		
d330 1
a330 1
{	
d342 1
a342 1
{	
d350 2
a351 2
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message == WM_LBUTTONUP 
		|| pMsg->message == WM_RBUTTONDOWN || pMsg->message == WM_RBUTTONUP 
d389 1
a389 1
{	
d394 2
a395 2
	CListCtrl *pListCtrl = &m_ctlDownloadList;//(CListCtrl*)m_ctlRollup.GetItemClient(0);
	int sel = GetItemUnderMouse(pListCtrl);	// this is a quick fix,
d401 2
a402 2
			if(m_ttip.IsWindowVisible())
			{	
d422 1
a422 1
			{	
d442 1
a442 1
{	
d470 1
a470 1
{	
d560 4
a563 4
            }
         //-For File Comment-// 
			try 
			{ 
d567 1
a567 1
					{ 
d572 7
a578 7
						info += strFileComment; 
					} 
					else 
					{ 
					//	No comment entered 
						info += GetResString(IDS_TT_CMT_NONE); 
					} 
d592 1
a592 1
					} 
d594 7
a600 7
			} 
			catch(...) 
			{ 
				//Information not received = not connected or connecting 
				info += GetResString(IDS_TT_CMT_NOTCONNECTED); 
			} 
	         //-End file comment-//
d603 1
a603 1
			switch(pSource->GetClientSoft()) 
d643 2
a644 1
		int sel = GetItemUnderMouse(&m_ctlUploadList);
d648 1
a648 1
		CUpDownClient* pSource = (CUpDownClient*)m_ctlUploadList.GetItemData(sel);
d693 2
a694 1
		int sel = GetItemUnderMouse(&m_ctlQueueList);
d699 3
a701 2
		CUpDownClient* pSource = (CUpDownClient*)m_ctlUploadList.GetItemData(sel);
		in_addr server;
d709 1
a709 1
					pSource->GetFullIP(), pSource->GetUserPort(), 
d723 1
a723 1
{	
d798 1
a798 1
{	
d817 1
a817 1
	if(m_bFirstShow)
d837 1
a837 1
	
d854 1
a854 1
{	
d870 1
a870 1
{	
d877 1
a877 1
						g_eMuleApp.m_pUploadQueue->GetUploadQueueLength(), 
d887 1
a887 1
{		
d893 3
a895 3
	{	
		case INFOLISTTYPE_SOURCE: 
			strInfoHeader.Format(GetResString(IDS_RUP_INFOUSER), m_ctlInfoList.GetName()); 
d897 2
a898 2
		case INFOLISTTYPE_FILE: 
			strInfoHeader.Format(GetResString(IDS_RUP_INFOFILE), m_ctlInfoList.GetName()); 
d900 1
a900 1
		default: 
d904 1
a904 1
	
d911 1
a911 1
{	
d915 1
a915 1
		
d922 2
a923 2
	f = _tfopen(fullpath, _T("rb"));	
	
d974 1
a974 1
			
d982 1
a982 1
		}	
d995 1
a995 1
			
d1008 1
a1008 1
		
d1014 1
a1014 1
	
d1017 1
a1017 1
		BYTE bExpandedItems; 
d1068 1
a1068 1
{	
d1075 1
a1075 1
	f = _tfopen(fullpath, _T("wb"));	
d1080 1
a1080 1
		{	
d1086 1
a1086 1
	
d1091 1
a1091 1
				f2 = 100 - f1;				
d1107 2
a1108 2
{	
	if (wParam >= MP_CAT_SET_0 && wParam <= MP_CAT_SET_LAST) 
d1170 1
a1170 1
				if (CCat::GetNumCats() == 1) 
d1210 1
a1210 1
			if (CCat::GetNumCats() == 1) 
d1250 1
a1250 1
			{	
d1265 1
a1265 1
		default: 
d1268 1
a1268 1
	
d1273 2
a1274 2
int CTransferWnd::GetTabUnderMouse(CPoint* point) 
{	
d1285 1
a1285 1
		{	
d1293 1
a1293 1
	if(hitinfo.flags != TCHT_NOWHERE)
d1295 1
a1295 1
	else 
d1299 2
a1300 2
void CTransferWnd::UpdateTabToolTips(int tab) 
{	
d1303 1
a1303 1
	if(tab==-1) 
d1314 2
a1315 2
	} 
	else 
d1325 2
a1326 2
CString CTransferWnd::GetTabStatistic(uint8 tab) 
{	
d1334 1
a1334 1
	for(int i=0;i<g_eMuleApp.m_pDownloadQueue->GetFileCount();i++) 
d1337 2
a1338 2
		
		if(cur_file != 0) 
d1340 1
a1340 1
			if(CCat::FileBelongsToGivenCat(cur_file, CCat::GetCatIDByIndex(tab))) 
d1343 1
a1343 1
				if(cur_file->GetTransferringSrcCount() > 0) 
d1361 1
a1361 1
{	
d1429 1
a1429 1
		
d1446 1
a1446 1
		
d1458 1
a1458 1
		
d1474 1
a1474 1
	
d1484 1
a1484 1
{	
d1487 1
a1487 1
	if(iSel==-1) 
d1495 1
a1495 1
	
d1501 1
a1501 1
	
d1515 2
a1516 2
{	
	if(!(nFlags & MK_LBUTTON)) 
d1525 1
a1525 1
		
d1529 1
a1529 1
	
d1538 1
a1538 1
{	
d1547 1
a1547 1
		
d1555 2
a1556 2
			int				index = -1; 
			POSITION		pos = m_ctlDownloadList.GetFirstSelectedItemPosition(); 
d1558 4
a1561 4
			while (pos != NULL) 
			{ 
				index = m_ctlDownloadList.GetNextSelectedItem(pos); 
				if (index > -1) 
d1571 1
a1571 1
				} 
d1580 1
a1580 1
		} 
d1590 1
a1590 1
{	
d1606 2
a1607 2
void CTransferWnd::UpdateCatTabTitles() 
{	
d1610 1
a1610 1
	{	
d1634 2
a1635 2
void CTransferWnd::EditCatTabLabel(int index,CString newlabel) 
{	
d1644 1
a1644 1
		CDownloadList::PartFileVector	*pvecPartFiles; 
d1654 1
a1654 1
			for(unsigned int i = 0; i < pvecPartFiles->size(); i++) 
d1664 1
a1664 1
					if(pPartFile->GetTransferringSrcCount() > 0) 
d1694 1
a1694 1
int CTransferWnd::AddCategory( CString strNewTitle,CString strNewIncoming,CString strNewComment, 
d1701 1
a1701 1
	if (bAddTab) 
d1715 1
a1715 1
	if (bAddTab) 
d1723 2
a1724 2
void CTransferWnd::OnTabMovement(NMHDR *pNMHDR, LRESULT *pResult) 
{	
d1745 1
a1745 1
	if (to > from) 
d1789 1
a1789 1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
@


1.81
log
@More Kush changes for localization, minor optimizations and fix for Upload AutoPriority.
@
text
@a384 18
	if (m_ctlDownloadList.GetSelectionMark() != -1) 
	{
		EnumExpandType expandtype = EXPAND_COLLAPSE;

		if (GetAsyncKeyState(VK_ADD) < 0)
		{
			expandtype = EXPAND_ONLY;
		}
		else if (GetAsyncKeyState(VK_SUBTRACT) < 0) 
		{		
			expandtype = COLLAPSE_ONLY;
		}
		if (expandtype < EXPAND_COLLAPSE) 
		{
			m_ctlDownloadList.ExpandCollapseItem(m_ctlDownloadList.GetSelectionMark(), expandtype, true);
		}
	}

@


1.80
log
@KuSh localization fix for filter tabs.
@
text
@a843 1
	// KuSh: localisation of Status Tabs
@


1.79
log
@Fixed memleak (it was me! :P)
@
text
@d844 21
@


1.78
log
@wrong values in categories because completed files weren't counted
@
text
@d1665 3
@


1.77
log
@possible fix for 'mysterious sound' when expanding/collapsing using +/-
@
text
@d1639 13
a1651 2
		CPartFile* cur_file;
		uint16 count,dwl;
d1653 2
a1654 1
		count = dwl = 0;
d1656 6
a1661 18
		//
		//	Count the number of files in the DownloadQueue belonging to the
		//		'index'th category and the number of those currently downloading.
		//
		for(int i = 0; i < g_eMuleApp.m_pDownloadQueue->GetFileCount(); i++) 
		{
			cur_file=g_eMuleApp.m_pDownloadQueue->GetFileByIndex(i);
			if (cur_file == NULL)
				continue;
			if (CCat::FileBelongsToGivenCat(cur_file,CCat::GetCatIDByIndex(index)))
			{
				count++;
				if(cur_file->GetTransferringSrcCount() > 0) 
					dwl++;

//				speed+=cur_file->GetDataRate()/1024.0f;
//				size+=cur_file->GetFileSize();
//				trsize+=cur_file->GetCompletedSize();
d1664 4
a1667 4
		//
		//	Append the appropriate information to the tab label
		//
		CString title=newlabel;
d1671 1
a1671 1
			newlabel.Format("%s %i/%i",title,dwl,count);
d1676 1
a1676 1
			newlabel.Format("%s %i",title,count);
@


1.76
log
@Removed <> file collapsing
@
text
@a181 1
	ON_NOTIFY(LVN_KEYDOWN, TRANS_DOWNLOADLIST, OnLvnKeydownDownloadlist)
d385 18
a1781 22
void CTransferWnd::OnLvnKeydownDownloadlist(NMHDR *pNMHDR, LRESULT *pResult)
{
	LPNMLVKEYDOWN pLVKeyDown = reinterpret_cast<LPNMLVKEYDOWN>(pNMHDR);
	if (m_ctlDownloadList.GetSelectionMark()!=-1) 
	{
		EnumExpandType expandtype = EXPAND_COLLAPSE;

		if (pLVKeyDown->wVKey == VK_ADD ) 
		{
			expandtype = EXPAND_ONLY;
		}
		else if ( pLVKeyDown->wVKey == VK_SUBTRACT ) 
		{		
			expandtype = COLLAPSE_ONLY;
		}
		if (expandtype < EXPAND_COLLAPSE) 
		{
			m_ctlDownloadList.ExpandCollapseItem(m_ctlDownloadList.GetSelectionMark(),expandtype,true);
		}
	}
	*pResult = 0;
}@


1.75
log
@expand/collpase sources using +/- or right/left keys
@
text
@d1772 1
a1772 1
		if (pLVKeyDown->wVKey == VK_ADD || pLVKeyDown->wVKey == VK_RIGHT) 
d1776 1
a1776 1
		else if ( pLVKeyDown->wVKey == VK_SUBTRACT || pLVKeyDown->wVKey == VK_LEFT ) 
@


1.74
log
@proper InfoList handling
@
text
@d182 1
d1764 23
a1786 1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// @


1.73
log
@New sockets
@
text
@d1763 1
a1763 9
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTransferWnd::ClearInfoHeader()
{
//	TODO: Make this asynchronous
	m_ctlInfoList.SwitchToFile(NULL);
	UpdateInfoHeader();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

@


1.72
log
@Fix for category drag & drop
@
text
@d518 1
d635 1
@


1.71
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d1551 2
a1552 2
			if (m_ctlDLTabs.GetCurSel() > CCat::GetNumPredefinedCats())
				m_ctlDownloadList.ChangeCategoryByIndex(m_ctlDLTabs.GetCurSel());
@


1.70
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d262 1
a262 1
						(float)g_eMuleApp.m_pDownloadQueue->GetDataRate() / 1024);
d267 1
a267 1
					  (float)g_eMuleApp.m_pUploadQueue->GetDataRate()/1024);
d854 1
a854 1
								(float)g_eMuleApp.m_pUploadQueue->GetDataRate()/1024);
d889 1
a889 1
	float fItemHeights[3][8];
d917 1
a917 1
			float fTotalHeight = 0;
d1056 1
a1056 1
			float f1,f2,f3;
d1304 1
a1304 1
	float speed = 0;
@


1.69
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d553 1
a553 1
											pSource->reqfile->GetFileName() );
d621 1
a621 1
					if(pSource->credits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
d669 1
a669 1
				if(pSource->credits->GetCurrentIdentState(pSource->GetIP()) != IS_IDENTIFIED)
@


1.68
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d225 1
a225 1
	m_wndRollup.Create(NULL, NULL, WS_CHILD|WS_VISIBLE/*|WS_CLIPCHILDREN*/, rRollupArea, this, TRANS_ROLLUP);
d230 1
a230 1
	CWnd *pParent = &m_wndRollup;
d240 9
a248 4
	m_wndDownloadList.Create(WS_VISIBLE | dwListStyle, rItem, m_pwndDummyForDownloadList, TRANS_DOWNLOADLIST);
	m_wndUploadList.Create(WS_VISIBLE | dwListStyle, rItem, pParent, TRANS_UPLOADLIST);
	m_wndQueueList.Create(/*WS_VISIBLE |*/ dwListStyle, rItem, pParent, TRANS_QUEUELIST);
	m_wndClientList.Create(/*WS_VISIBLE |*/ dwListStyle, rItem, pParent, TRANS_CLIENTLIST);
d251 1
a251 1
	m_wndDLTabs.Create(dwTabStyle, CRect(0,0,0,20), pParent, TRANS_DOWNLOADTABS);	
d253 1
a253 1
	m_wndDLTabs.ModifyStyle(WS_CLIPSIBLINGS, 0);
d255 1
a255 1
	m_pwndDummyForDownloadList->SetChild(&m_wndDownloadList);
d257 1
a257 1
	AddBuddy(m_pwndDummyForDownloadList->m_hWnd, m_wndDLTabs.m_hWnd, BDS_TOP);
d269 3
a271 3
	m_wndRollup.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strDownloads, m_pwndDummyForDownloadList, 0, TRUE);
	m_wndRollup.InsertItem(GetResString(IDS_RUP_UPLOADS), strUploads, &m_wndUploadList, 1, TRUE);
	m_wndRollup.InsertItem(GetResString(IDS_RUP_INFO), _T(""), &m_ctlInfoList, 2, FALSE);
d273 1
a273 1
	AddAnchor(m_wndRollup.m_hWnd, TOP_LEFT, BOTTOM_RIGHT);
d277 10
a286 10
	m_wndDownloadList.Init();
	m_wndUploadList.Init();
	m_wndQueueList.Init();
	m_wndClientList.Init();

	m_wndDownloadList.SetOwner(this);
	m_wndUploadList.SetOwner(this);
	m_wndQueueList.SetOwner(this);
	m_wndClientList.SetOwner(this);
	m_wndDLTabs.SetOwner(this);
d300 2
a301 2
	m_ttip.AddTool(&m_wndDownloadList, _T(""));
	m_ttip.AddTool(&m_wndUploadList, _T(""));
d309 1
a309 1
		m_wndDLTabs.InsertItem(ix,CCat::GetCatByIndex(ix)->GetTitle() );
d312 1
a312 1
	m_wndDLTabs.SetToolTips(m_pttDlTabToolTips);
d394 1
a394 1
	CListCtrl *pListCtrl = &m_wndDownloadList;//(CListCtrl*)m_wndRollup.GetItemClient(0);
d415 1
a415 1
	int sel2 = GetItemUnderMouse((CListCtrl*)m_wndRollup.GetItemClient(1));	// see above
d486 1
a486 1
		if (m_wndDownloadList.GetItemCount() < 1)
d489 1
a489 1
		int sel = GetItemUnderMouse(&m_wndDownloadList);
d494 1
a494 1
		CMuleCtrlItem		*pItem = reinterpret_cast<CMuleCtrlItem*>(m_wndDownloadList.GetItemData(sel));
d513 1
a513 1
			m_wndDownloadList.SetFocus();
d605 1
a605 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_CDONKEY);
d608 1
a608 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_LMULE);
d611 1
a611 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_SHAREAZA);
d614 1
a614 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_EDONKEYHYBRID);
d617 1
a617 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_MLDONKEY);
d622 1
a622 1
						pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_SECUREHASH);
d624 1
a624 1
						pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_COMPROT);
d627 1
a627 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_NORMAL);
d630 1
a630 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_UNKNOWN);
d638 1
a638 1
		if (m_wndUploadList.GetItemCount() < 1)
d641 1
a641 1
		int sel = GetItemUnderMouse(&m_wndUploadList);
d645 1
a645 1
		CUpDownClient* pSource = (CUpDownClient*)m_wndUploadList.GetItemData(sel);
d653 1
a653 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_CDONKEY);
d656 1
a656 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_LMULE);
d659 1
a659 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_SHAREAZA);
d662 1
a662 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_EDONKEYHYBRID);
d665 1
a665 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_MLDONKEY);
d670 1
a670 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_SECUREHASH);
d672 1
a672 1
					pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_COMPROT);
d675 1
a675 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_NORMAL);
d678 1
a678 1
				pNotify->ti->hIcon = m_wndUploadList.m_imageList.ExtractIcon(UL_ICON_UNKNOWN);
d682 1
a682 1
		m_wndUploadList.SetFocus();
d687 1
a687 1
		if (m_wndQueueList.GetItemCount() < 1)
d690 1
a690 1
		int sel = GetItemUnderMouse(&m_wndQueueList);
d695 1
a695 1
		CUpDownClient* pSource = (CUpDownClient*)m_wndUploadList.GetItemData(sel);
d726 5
a730 5
			m_wndRollup.SetText(1, GetResString(IDS_ONQUEUE), true);
			m_wndUploadList.ShowWindow(SW_HIDE);
			m_wndClientList.ShowWindow(SW_HIDE);
			m_wndRollup.SetItemClient(1, &m_wndQueueList);
			m_wndRollup.Invalidate();
d738 6
a743 6
			buffer.Format(" (%i)", m_wndClientList.GetItemCount());
			m_wndRollup.SetText(1, GetResString(IDS_CLIENTLIST)+buffer, true);
			m_wndUploadList.ShowWindow(SW_HIDE);
			m_wndQueueList.ShowWindow(SW_HIDE);
			m_wndRollup.SetItemClient(1, &m_wndClientList);
			m_wndRollup.Invalidate();
d749 5
a753 5
			m_wndRollup.SetText(1, GetResString(IDS_RUP_UPLOADS), true);
			m_wndQueueList.ShowWindow(SW_HIDE);
			m_wndClientList.ShowWindow(SW_HIDE);
			m_wndRollup.SetItemClient(1, &m_wndUploadList);
			m_wndRollup.Invalidate();
d769 2
a770 2
		buffer.Format(" (%i)", m_wndClientList.GetItemCount());
		m_wndRollup.SetText(1, GetResString(IDS_CLIENTLIST)+buffer, true);
d780 1
a780 1
		if(m_wndQueueList.m_iClientFilter == 1)
d782 1
a782 1
		else if(m_wndQueueList.m_iClientFilter == 2)
d784 1
a784 1
		else if(m_wndQueueList.m_iClientFilter == 3)
d787 1
a787 1
		m_wndRollup.SetText(1, GetResString(IDS_ONQUEUE)+buffer, true);
d799 1
a799 1
			m_wndRollup.SetText(1,GetResString(IDS_RUP_UPLOADS), true);
d810 2
a811 2
	m_wndRollup.SetText(0,GetResString(IDS_RUP_DOWNLOADS), true);
	m_wndRollup.SetText(2,GetResString(IDS_RUP_INFO), true);
d818 4
a821 4
	m_wndDownloadList.Localize();
	m_wndUploadList.Localize();
	m_wndQueueList.Localize();
	m_wndClientList.Localize();
d836 3
a838 3
						g_eMuleApp.m_pDownloadQueue->GetTransferringFiles(),
							(float)g_eMuleApp.m_pDownloadQueue->GetDataRate()/1024);
	m_wndRollup.SetText(0, strBuffer);
d855 1
a855 1
	m_wndRollup.SetText(1, strBuffer);
d880 1
a880 1
	m_wndRollup.SetText(2, strInfoHeader);
d979 1
a979 1
				m_wndRollup.ExpandItem(i, _tstoi(pToken));
d1035 3
a1037 3
	m_wndRollup.SetItemHeights(0, fItemHeights[0], 8);
	m_wndRollup.SetItemHeights(1, fItemHeights[1], 8);
	m_wndRollup.SetItemHeights(2, fItemHeights[2], 8);
d1058 3
a1060 3
			f1 = m_wndRollup.GetItem(0)->pSizes[exp];
			f2 = m_wndRollup.GetItem(1)->pSizes[exp];
			f3 = m_wndRollup.GetItem(2)->pSizes[exp];
d1072 3
a1074 3
				 m_wndRollup.GetItem(0)->pHeader->IsExpanded(),
				 m_wndRollup.GetItem(1)->pHeader->IsExpanded(),
				 m_wndRollup.GetItem(2)->pHeader->IsExpanded() );
d1085 1
a1085 1
		uint8		iCatID = CAT_PREDEFINED + (wParam - MP_CAT_SET_0);
d1087 1
a1087 1
		CCat::SetAllCatType(iCatID);
d1089 3
a1091 3
		m_wndDLTabs.SetCurSel(0);
		m_wndDownloadList.ChangeCategoryByIndex(0);
		if (iCatID == CAT_ALL)
d1099 3
a1101 3
		uint8		iCatPos = wParam - MP_SHOWPREDEFINEDCAT_0;
		uint8		iCatID = iCatPos + CAT_PREDEFINED;
		int			iCatIndex = CCat::GetCatIndexByID(iCatID);
d1106 1
a1106 1
			AddPredefinedCategory(iCatID);
d1113 3
a1115 3
			m_wndDLTabs.DeleteItem(iCatIndex);
			m_wndDLTabs.SetCurSel(0);
			m_wndDownloadList.ChangeCategoryByID(CAT_ALL);
d1129 1
a1129 1
			m_wndDownloadList.ClearCompleted();
d1141 3
a1143 3
				m_wndDLTabs.DeleteItem(newindex);
				m_wndDLTabs.SetCurSel(0);
				m_wndDownloadList.ChangeCategoryByIndex(0);
d1181 3
a1183 3
			m_wndDLTabs.DeleteItem(m_iTabRightClickIndex);
			m_wndDLTabs.SetCurSel(0);
			m_wndDownloadList.ChangeCategoryByID(CAT_ALL);
d1253 1
a1253 1
	m_wndDLTabs.GetWindowRect(&rect);
d1257 1
a1257 1
	if(m_wndDLTabs.GetItemRect( 0, &rect ))
d1266 1
a1266 1
	unsigned int		nTab = m_wndDLTabs.HitTest(&hitinfo);
d1281 1
a1281 1
			m_pttDlTabToolTips->DelTool(&m_wndDLTabs,i+1);
d1283 1
a1283 1
		for (i = 0; i < m_wndDLTabs.GetItemCount(); i++)
d1286 2
a1287 2
			m_wndDLTabs.GetItemRect(i, &r);
			VERIFY(m_pttDlTabToolTips->AddTool(&m_wndDLTabs, GetTabStatistic(i), &r, i+1));
d1293 1
a1293 1
		m_wndDLTabs.GetItemRect(tab, &r);
d1295 2
a1296 2
		m_pttDlTabToolTips->DelTool(&m_wndDLTabs,tab+1);
		VERIFY(m_pttDlTabToolTips->AddTool(&m_wndDLTabs, GetTabStatistic(tab), &r, tab+1));
d1339 2
a1340 2
	catIndex = m_wndDLTabs.GetCurSel();
	m_wndDownloadList.ChangeCategoryByIndex(catIndex);
d1415 1
a1415 1
			int		catIndex = CCat::GetCatIndexByID(CAT_PREDEFINED + i);
d1425 1
a1425 1
								  CCat::GetPredefinedCatTitle(CAT_PREDEFINED + i) );
d1460 1
a1460 1
	int iSel = m_wndDownloadList.GetSelectionMark();
d1465 1
a1465 1
	CMuleCtrlItem	   *pItem = reinterpret_cast<CMuleCtrlItem*>(m_wndDownloadList.GetItemData(iSel));
d1480 1
a1480 1
	m_pDragImage = m_wndDownloadList.CreateDragImage(m_wndDownloadList.GetSelectionMark(),&pt);
d1502 2
a1503 2
		m_wndDLTabs.SetCurSel(m_nTabDropIndex);
		m_wndDLTabs.Invalidate();
d1525 3
a1527 3
		 && ( m_wndDownloadList.GetCurTabIndex() < CCat::GetNumPredefinedCats()
		   || ( m_wndDownloadList.GetCurTabIndex() >= CCat::GetNumPredefinedCats()
		     && m_nTabDropIndex != m_wndDownloadList.GetCurTabIndex()) ) )
d1531 1
a1531 1
			POSITION		pos = m_wndDownloadList.GetFirstSelectedItemPosition(); 
d1535 1
a1535 1
				index = m_wndDownloadList.GetNextSelectedItem(pos); 
d1538 1
a1538 1
					CMuleCtrlItem	*pItem = reinterpret_cast<CMuleCtrlItem*>(m_wndDownloadList.GetItemData(index));
d1549 1
a1549 1
			m_wndDLTabs.SetCurSel(m_wndDownloadList.GetCurTabIndex());
d1551 2
a1552 2
			if (m_wndDLTabs.GetCurSel() > CCat::GetNumPredefinedCats())
				m_wndDownloadList.ChangeCategoryByIndex(m_wndDLTabs.GetCurSel());
d1558 1
a1558 1
			m_wndDLTabs.SetCurSel(m_wndDownloadList.GetCurTabIndex());
d1560 1
a1560 1
		m_wndDownloadList.Invalidate();
d1584 1
a1584 1
	for (uint8 i = 0; i < m_wndDLTabs.GetItemCount(); i++)
d1614 1
a1614 1
	m_wndDLTabs.GetItem(index,&tabitem);
d1661 1
a1661 1
	m_wndDLTabs.SetItem(index,&tabitem);
d1663 1
a1663 1
	m_wndDLTabs.Invalidate();
d1674 1
a1674 1
		m_wndDLTabs.InsertItem(iIndex,strNewTitle);
d1676 1
a1676 1
	m_wndDLTabs.Invalidate();
d1681 1
a1681 1
int CTransferWnd::AddPredefinedCategory(uint8 iPredefinedCatID, bool bAddTab/*=true*/)
d1683 1
a1683 1
	CCat	*pNewCat = new CCat(iPredefinedCatID);
d1688 1
a1688 1
		m_wndDLTabs.InsertItem(iIndex,pNewCat->GetTitle());
d1690 1
a1690 1
	m_wndDLTabs.Invalidate();
d1697 2
a1698 2
	UINT	from = m_wndDLTabs.GetLastMovementSource();
	UINT	to = m_wndDLTabs.GetLastMovementDestination();
d1712 1
a1712 1
	m_wndDLTabs.ReorderTab(from,to);
d1721 3
a1723 3
	m_wndDLTabs.SetCurSel(to);
	m_wndDownloadList.ChangeCategoryByIndex(to);
	m_wndDLTabs.Invalidate();
d1730 1
a1730 1
	if (pNMHDR->hwndFrom == m_wndDLTabs.GetSafeHwnd())
d1749 1
a1749 1
	else if(pNMHDR->hwndFrom == m_wndDownloadList.GetSafeHwnd())
d1760 7
@


1.67
log
@Modified to accomodate changes in Download List.
@
text
@d502 1
a502 1
			memset(&shfi,0,sizeof(shfi));
@


1.66
log
@Current code doesn't compile (hope these changes are right)
@
text
@d488 6
a493 3
		// build info text and display it
		CMuleCtrlItem* pContent = (CMuleCtrlItem*)m_wndDownloadList.GetItemData(sel);
		if (pContent->IsFile()) // for downloading files
d495 1
a495 1
			CPartFile* partfile = pContent->GetFile();
d497 4
a500 2
			//BEGIN Improved Tooltips
			info = partfile->GetDownloadFileInfo4Tooltips();
a501 1
			SHFILEINFO shfi;
d503 3
a505 3
			SHGetFileInfo(partfile->GetFileName(),
				FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi),
				SHGFI_ICON|SHGFI_USEFILEATTRIBUTES);
d509 1
a509 1
			//END Improved Tooltips
d511 1
a511 1
		else if (pContent->IsSource()) // for sources
d513 17
a529 15
			bool bA4AF = pContent->IsAskedForAnotherFile();
			CUpDownClient* client = pContent->GetSource();
			in_addr server;
			server.S_un.S_addr = client->GetServerIP();

			//BEGIN Improved Tooltips
			info.Format(GetResString(IDS_TT_USERINFO)
				+GetResString(IDS_TT_CLIENT)
				+GetResString(IDS_TT_SERVER)
				+GetResString(IDS_TT_SOURCEINFO)
				+GetResString(IDS_TT_SOURCEINFO2),
						client->GetUserName(), client->GetUserID(),
						client->GetFullIP(), client->GetUserPort(), 
						inet_ntoa(server), client->GetServerPort(),
						client->GetAskedCountDown(), client->GetAvailablePartCount());	//eklmn: bugfix(15): show values for download asked
d531 7
a537 5
			{	// normal client
				CString sClientSrcName;
				sClientSrcName.Format(GetResString(IDS_TT_CLIENTSOURCENAME),
					CString(client->GetClientFilename()));
				info += sClientSrcName;
d539 1
d542 1
a542 1
				//Cax2- get local file name
d545 8
a552 4
					CString sA4AFFileName;
					sA4AFFileName.Format(GetResString(IDS_TT_ASKEDFAF),
						client->reqfile->GetFileName());
					info += sA4AFFileName;
a553 1
				catch(...){}
d556 2
a557 2
		     try 
			 { 
d560 1
a560 1
					if (client->GetFileComment() != "")
d562 5
a566 4
						CString sFileComment;
						sFileComment.Format(GetResString(IDS_TT_CMT_READ),
											CString(client->GetFileComment()));
						info += sFileComment; 
d573 4
a576 1
					if (GetRatingString(client->GetFileRating())==GetResString(IDS_CMT_NOTRATED))
d578 1
d584 1
a584 1
										  GetRatingString(client->GetFileRating()) );
d597 1
a597 1
			switch(client->GetClientSoft()) 
d616 1
a616 1
					if(client->credits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED)
d640 1
a640 1
		CUpDownClient* client = (CUpDownClient*)m_wndUploadList.GetItemData(sel);
d642 1
a642 1
		info = client->GetUploadFileInfo4Tooltips();
d645 1
a645 1
		switch(client->GetClientSoft())
d664 1
a664 1
				if(client->credits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED)
d690 1
a690 1
		CUpDownClient* client = (CUpDownClient*)m_wndUploadList.GetItemData(sel);
d692 1
a692 1
		server.S_un.S_addr = client->GetServerIP();
d698 4
a701 4
					client->GetUserName(), client->GetUserID(),
					client->GetFullIP(), client->GetUserPort(), 
					inet_ntoa(server), client->GetServerPort(),
					client->GetAskedCount(), client->GetAvailablePartCount());
d1459 5
a1463 1
	if (!((CMuleCtrlItem*)m_wndDownloadList.GetItemData(iSel))->IsFile())
d1507 1
a1507 1
void CTransferWnd::OnLButtonUp(UINT nFlags, CPoint point)
d1524 1
a1524 1
			CPartFile	   *file;
d1533 2
a1534 1
					CMuleCtrlItem *pListItem = (CMuleCtrlItem*)m_wndDownloadList.GetItemData(index);
d1536 1
a1536 1
					if(pListItem != NULL && pListItem->IsFile())
d1538 2
a1539 2
						file = pListItem->GetFile();
						file->SetCatID(CCat::GetCatIDByIndex(m_nTabDropIndex));
@


1.65
log
@Formatting, comments, and name changes.
@
text
@d560 1
a560 1
					if (GetRateString(client->GetFileRate())==GetResString(IDS_CMT_NOTRATED))
d567 1
a567 1
										  GetRatingString(pSource->GetFileRating()) );
@


1.64
log
@init some variables in constructor
@
text
@d564 5
a568 4
						CString sRate;
						sRate.Format(GetResString(IDS_TT_CMT_RATING),
								GetRateString(client->GetFileRate()));
						info += sRate;
@


1.63
log
@Fixed crash on canceling "Add category".
@
text
@d195 5
@


1.62
log
@Formatting, comments, and name changes.
@
text
@d1123 6
a1128 3
			g_eMuleApp.m_pdlgEmule->m_dlgSearch.UpdateCatTabs();
			EditCatTabLabel(newindex, CCat::GetCatByIndex(newindex)->GetTitle());
			g_eMuleApp.m_pGlobPrefs->SaveCats();
@


1.61
log
@Localization fixes.
@
text
@d577 1
a577 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(8);
d580 1
a580 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(9);
d583 1
a583 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(10);
d586 1
a586 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(3);
d589 1
a589 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(2);
d594 1
a594 1
						pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(11);
d596 1
a596 1
						pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(1);
d599 1
a599 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(0);
d602 1
a602 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(7);
d625 1
a625 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(8);
d628 1
a628 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(9);
d631 1
a631 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(10);
d634 1
a634 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(3);
d637 1
a637 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(2);
d642 1
a642 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(11);
d644 1
a644 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(1);
d647 1
a647 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(0);
d650 1
a650 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(7);
@


1.60
log
@Fixed a bug in "resume next".
@
text
@d768 12
a779 5
	m_wndDownloadList.Localize();
	m_wndUploadList.Localize();
	m_wndQueueList.Localize();
	m_wndClientList.Localize();
	m_ctlInfoList.Localize();
a782 1
	m_wndRollup.SetText(1,GetResString((m_nActiveWnd == MPW_UPLOADLIST) ? IDS_RUP_UPLOADS : IDS_ONQUEUE), true);
d789 6
@


1.59
log
@Fix for forced sharing (root dirs)
Added filtering to GUI queue
@
text
@d1194 1
a1194 1
			g_eMuleApp.m_pDownloadQueue->StartPausedDownload(m_iTabRightClickIndex);
@


1.58
log
@Fixed bug "eMule doesn't remember added predefined categories."
@
text
@d290 1
a290 1
	m_ttip.AddTool(&m_wndDownloadList, _T(""));	
d703 1
d735 1
a735 1
//	Update Known Clients on header
d743 17
@


1.57
log
@Added "Inactive" status filter.
@
text
@d1049 1
@


1.56
log
@Minor GUI/functionality fix (do not apply priority to filters, because doesn't work)
@
text
@d1336 1
d1338 4
a1341 4
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+11,GetResString(IDS_CAT_VIDEO));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+12,GetResString(IDS_CAT_AUDIO));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+13,GetResString(IDS_CAT_ARCHIVES));
		m_viewMenu.AppendMenu(MF_STRING,MP_CAT_SET_0+14,GetResString(IDS_CAT_CDIMAGES));
@


1.55
log
@Modified CCatTabs::DrawItem() to draw a corner triange instead of a bar.
@
text
@d1297 1
d1301 1
a1344 1
//		menu.AppendMenu(MF_SEPARATOR);
d1379 1
a1379 1
	menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_priorityMenu.m_hMenu, GetResString(IDS_PRIORITY) );
@


1.54
log
@Changed the #ifdefs to use a single switch. Put NEW_LOOK into your preprocessor defines for the new look.
@
text
@d101 2
d114 1
d140 16
@


1.53
log
@An attempt to adjust the category tab color bar for the new look.
@
text
@d112 1
a112 1
#ifdef OLD
d136 1
a136 1
#endif OLD
@


1.52
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d112 1
d117 20
@


1.51
log
@Re-added the view filter menu. Removed the parentheses from the file counts in the tabs. Overrode the DrawItem() method in CTabs to add the category color bars.
@
text
@d42 1
d170 1
a170 1
	Localize();
d198 1
d230 1
d235 1
d656 1
a656 1
		{	
d660 1
d666 13
a678 1
		{	
d682 1
d687 2
a688 1
		default: break;
d694 11
d713 1
@


1.50
log
@Category rewrite with predefined status/media type categories.
@
text
@d46 1
d96 23
d954 14
d989 1
d1008 1
a1008 1
			if(dialog.DoModal() == IDCANCEL)
d1015 4
a1018 4
//				if(CCat::GetNumCats() == 1) 
//				{
//					g_eMuleApp.m_pGlobPrefs->SetAllCatType(0);
//				}
d1052 4
a1055 4
//			if (CCat::GetNumCats() == 1) 
//			{
//				g_eMuleApp.m_pGlobPrefs->SetAllCatType(0);
//			}
d1230 4
d1249 26
d1446 14
d1462 1
a1462 3
		EditCatTabLabel( i, (i == 0)
					   ? CCat::GetPredefinedCatTitle(CCat::GetAllCatType())
						 : CCat::GetCatByIndex(i)->GetTitle()  );
d1511 1
a1511 1
			newlabel.Format("%s (%i/%i)",title,dwl,count);
d1516 1
a1516 1
			newlabel.Format("%s (%i)",title,count);
@


1.49
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d45 1
d94 1
d112 1
a112 1
//	ON_NOTIFY(NM_RCLICK, TRANS_DOWNLOADTABS, OnNMRclickDltab)
d114 1
a114 1
// ON_NOTIFY(LVN_BEGINDRAG, TRANS_DOWNLOADLIST, OnLvnBegindrag)
d122 1
d129 1
d134 2
a135 1
	m_pttDlTabToolTips->DestroyToolTipCtrl();
d175 1
a175 1
	m_wndDlTabs.Create(dwTabStyle, CRect(0,0,0,20), pParent, TRANS_DOWNLOADTABS);	
d177 1
a177 1
	m_wndDlTabs.ModifyStyle(WS_CLIPSIBLINGS, 0);
d181 1
a181 1
	AddBuddy(m_pwndDummyForDownloadList->m_hWnd, m_wndDlTabs.m_hWnd, BDS_TOP);
d208 1
a208 1
	m_wndDlTabs.SetOwner(this);
d211 1
a211 1
	m_iRightClickIndex = -1;
d230 2
a231 5
  	sprintf(g_eMuleApp.m_pGlobPrefs->GetCategory(0)->title, GetCatTitle(g_eMuleApp.m_pGlobPrefs->GetAllcatType()) );

	sprintf(g_eMuleApp.m_pGlobPrefs->GetCategory(0)->incomingpath,g_eMuleApp.m_pGlobPrefs->GetIncomingDir());
	for (int ix=0;ix<g_eMuleApp.m_pGlobPrefs->GetCatCount();ix++)
		m_wndDlTabs.InsertItem(ix,g_eMuleApp.m_pGlobPrefs->GetCategory(ix)->title );
d234 1
a234 1
	m_wndDlTabs.SetToolTips(m_pttDlTabToolTips);
d293 1
a293 1
			m_nDropIndex=GetTabUnderMouse(&pt);
d295 1
a295 1
			if (m_nDropIndex!=m_nLastCatTT)
d297 3
a299 3
				m_nLastCatTT=m_nDropIndex;
				if (m_nDropIndex!=-1)
					UpdateTabToolTips(m_nDropIndex);
d930 1
a930 1
	if (wParam >= MP_CAT_SET0 && wParam<=MP_CAT_SET0+20) 
d932 19
a950 5
		g_eMuleApp.m_pGlobPrefs->SetAllcatType(wParam-MP_CAT_SET0);
		m_nLastCatTT=-1;
		m_wndDlTabs.SetCurSel(0);
		m_wndDownloadList.ChangeCategory(0);
		EditCatTabLabel(0, GetCatTitle(g_eMuleApp.m_pGlobPrefs->GetAllcatType()));
d971 4
a974 4
				g_eMuleApp.m_pGlobPrefs->RemoveCat(newindex);
				m_wndDlTabs.DeleteItem(newindex);
				m_wndDlTabs.SetCurSel(0);
				m_wndDownloadList.ChangeCategory(0);
d976 4
a979 4
				if(g_eMuleApp.m_pGlobPrefs->GetCatCount() == 1) 
				{
					g_eMuleApp.m_pGlobPrefs->SetAllcatType(0);
				}
d983 1
a983 1
			EditCatTabLabel(newindex, g_eMuleApp.m_pGlobPrefs->GetCategory(newindex)->title);
d991 3
a993 1
			CCatDialog dialog(m_iRightClickIndex);
d997 3
a999 2
			csName.Format("%s", g_eMuleApp.m_pGlobPrefs->GetCategory(m_iRightClickIndex)->title );
			EditCatTabLabel(m_iRightClickIndex,csName);
d1007 5
a1011 5
			g_eMuleApp.m_pDownloadQueue->ResetCatParts(m_iRightClickIndex);
			g_eMuleApp.m_pGlobPrefs->RemoveCat(m_iRightClickIndex);
			m_wndDlTabs.DeleteItem(m_iRightClickIndex);
			m_wndDlTabs.SetCurSel(0);
			m_wndDownloadList.ChangeCategory(0);
d1013 4
a1016 4
			if(g_eMuleApp.m_pGlobPrefs->GetCatCount() == 1) 
			{
				g_eMuleApp.m_pGlobPrefs->SetAllcatType(0);
			}
d1022 1
a1022 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iRightClickIndex,PR_LOW);
d1027 1
a1027 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iRightClickIndex,PR_NORMAL);
d1032 1
a1032 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iRightClickIndex,PR_HIGH);
d1037 1
a1037 1
			g_eMuleApp.m_pDownloadQueue->SetCatPrio(m_iRightClickIndex,PR_AUTO);
d1042 1
a1042 1
			g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iRightClickIndex,MP_PAUSE);
d1047 1
a1047 1
			g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iRightClickIndex,MP_STOP);
d1054 1
a1054 1
				g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iRightClickIndex,MP_CANCEL);
d1060 1
a1060 1
			g_eMuleApp.m_pDownloadQueue->SetCatStatus(m_iRightClickIndex,MP_RESUME);
d1065 1
a1065 1
			g_eMuleApp.m_pDownloadQueue->StartPausedDownload(m_iRightClickIndex);
d1081 1
a1081 1
	m_wndDlTabs.GetWindowRect(&rect);
d1085 1
a1085 1
	if(m_wndDlTabs.GetItemRect(0, &rect))
d1094 1
a1094 1
	unsigned int nTab = m_wndDlTabs.HitTest(&hitinfo);
d1109 1
a1109 1
			m_pttDlTabToolTips->DelTool(&m_wndDlTabs,i+1);
d1111 1
a1111 1
		for (i = 0; i < m_wndDlTabs.GetItemCount(); i++)
d1114 2
a1115 2
			m_wndDlTabs.GetItemRect(i, &r);
			VERIFY(m_pttDlTabToolTips->AddTool(&m_wndDlTabs, GetTabStatistic(i), &r, i+1));
d1121 1
a1121 1
		m_wndDlTabs.GetItemRect(tab, &r);
d1123 2
a1124 2
		m_pttDlTabToolTips->DelTool(&m_wndDlTabs,tab+1);
		VERIFY(m_pttDlTabToolTips->AddTool(&m_wndDlTabs, GetTabStatistic(tab), &r, tab+1));
d1143 1
a1143 1
			if(CheckShowItemInGivenCat(cur_file, tab)) 
d1165 4
a1168 1
	m_wndDownloadList.ChangeCategory(m_wndDlTabs.GetCurSel());
d1174 1
a1174 1
void CTransferWnd::OnNMRclickDltab(NMHDR *pNMHDR, LRESULT *pResult)
a1182 1
	m_iRightClickIndex = GetTabUnderMouse(&pt);
d1184 8
a1191 2
	UINT flag;
	flag = (m_iRightClickIndex == 0) ? MF_GRAYED : MF_STRING;
d1193 1
a1193 2
	CMenu m_CatMenu;
	m_CatMenu.CreateMenu();
d1195 7
a1201 6
	CMenu m_PrioMenu;
	m_PrioMenu.CreateMenu();
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOLOW,GetResString(IDS_PRIOLOW));
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
	m_PrioMenu.AppendMenu(MF_STRING,MP_PRIOAUTO, GetResString(IDS_PRIOAUTO));
d1206 1
a1206 1
	if(m_iRightClickIndex == 0)
d1208 9
a1216 15
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0,GetResString(IDS_ALL));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+1,GetResString(IDS_ALLOTHERS));
		m_CatMenu.AppendMenu(MF_SEPARATOR);
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+2,GetResString(IDS_STATUS_NOTCOMPLETED));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+3,GetResString(IDS_DL_TRANSFCOMPL));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+4,GetResString(IDS_WAITING));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+5,GetResString(IDS_DOWNLOADING));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+6,GetResString(IDS_ERRORLIKE));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+7,GetResString(IDS_PAUSED));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+8,GetResString(IDS_STOPPED));
		m_CatMenu.AppendMenu(MF_SEPARATOR);
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+10,GetResString(IDS_VIDEO));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+11,GetResString(IDS_AUDIO));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+12,GetResString(IDS_SEARCH_ARC));
		m_CatMenu.AppendMenu(MF_STRING,MP_CAT_SET0+13,GetResString(IDS_SEARCH_CDIMG));
d1218 4
a1221 1
		m_CatMenu.CheckMenuItem( MP_CAT_SET0+g_eMuleApp.m_pGlobPrefs->GetAllcatType() ,MF_CHECKED | MF_BYCOMMAND);
d1223 8
a1230 1
		menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_CatMenu.m_hMenu, GetResString(IDS_CHANGECATVIEW));
d1235 2
a1236 2
	menu.AppendMenu(flag,MP_CAT_EDIT,GetResString(IDS_CAT_EDIT));
	menu.AppendMenu(flag,MP_CAT_REMOVE, GetResString(IDS_CAT_REMOVE));
d1238 1
a1238 1
	menu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_PrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
d1247 2
a1248 2
	VERIFY(m_PrioMenu.DestroyMenu());
	VERIFY(m_CatMenu.DestroyMenu());
d1254 1
a1254 1
void CTransferWnd::OnLvnBegindrag(NMHDR *pNMHDR, LRESULT *pResult)
d1276 1
a1276 1
	m_nDropIndex = -1;
d1293 3
a1295 3
		m_nDropIndex=GetTabUnderMouse(&pt);
		m_wndDlTabs.SetCurSel(m_nDropIndex);
		m_wndDlTabs.Invalidate();
d1306 1
a1306 1
	if(m_bIsDragging)
d1315 9
a1323 7
		if(m_nDropIndex>-1 && (m_wndDownloadList.m_nCurTab == 0 ||
			(m_wndDownloadList.m_nCurTab > 0 && 
				m_nDropIndex != m_wndDownloadList.m_nCurTab))) 
		{
			CPartFile* file;
			int index = -1; 
			POSITION pos = m_wndDownloadList.GetFirstSelectedItemPosition(); 
d1325 1
a1325 1
			while(pos != NULL) 
d1328 1
a1328 1
				if(index > -1) 
d1335 1
a1335 1
						file->SetCategory(m_nDropIndex);
d1339 6
a1344 7
			m_wndDlTabs.SetCurSel(m_wndDownloadList.m_nCurTab);
			if(m_wndDlTabs.GetCurSel() > 0 || 
				(g_eMuleApp.m_pGlobPrefs->GetAllcatType() == 1 && 
					m_wndDlTabs.GetCurSel()==0))
			{
				m_wndDownloadList.ChangeCategory(m_wndDlTabs.GetCurSel());
			}
d1347 4
a1350 3
		else 
			m_wndDlTabs.SetCurSel(m_wndDownloadList.m_nCurTab);

d1355 1
a1355 1
void CTransferWnd::OnDblclickDltab()
d1363 2
a1364 1
	if(tab < 1) 
d1366 1
a1366 2

	m_iRightClickIndex = tab;
d1374 2
a1375 1
	for(uint8 i=0; i<m_wndDlTabs.GetItemCount(); i++)
d1379 3
a1381 2
		EditCatTabLabel(i, (i == 0) ? GetCatTitle(g_eMuleApp.m_pGlobPrefs->GetAllcatType()) : 
						g_eMuleApp.m_pGlobPrefs->GetCategory(i)->title);
d1393 1
a1393 1
	m_wndDlTabs.GetItem(index,&tabitem);
d1396 1
a1396 1
	if(g_eMuleApp.m_pGlobPrefs->ShowCatTabInfos()) 
d1412 1
a1412 2

			if(CheckShowItemInGivenCat(cur_file,index)) 
d1427 10
a1436 1
		newlabel.Format("%s (%i/%i)",title,dwl,count);
d1440 1
a1440 1
	m_wndDlTabs.SetItem(index,&tabitem);
d1442 16
a1457 1
	m_wndDlTabs.Invalidate();
d1460 1
a1460 2
int CTransferWnd::AddCategory(CString newtitle,CString newincoming,CString newcomment, 
								CString newautocat, bool addTab)
d1462 1
a1462 1
	Category_Struct* newcat = new Category_Struct;
d1464 1
a1464 5
	sprintf(newcat->title, newtitle);
	newcat->prio = 0;
	sprintf(newcat->incomingpath, newincoming);
	sprintf(newcat->comment, newcomment);
	sprintf(newcat->autocat, newautocat);
d1466 2
a1467 3
	int index = g_eMuleApp.m_pGlobPrefs->AddCat(newcat);
	if(addTab) 
		m_wndDlTabs.InsertItem(index,newtitle);
d1469 1
a1469 1
	m_wndDlTabs.Invalidate();
d1471 1
a1471 1
	return index;
d1476 3
a1478 2
	UINT from=m_wndDlTabs.GetLastMovementSource();
	UINT to=m_wndDlTabs.GetLastMovementDestination();
d1480 1
a1480 1
	if (from==0 || to==0 || from==to-1) 
d1482 3
d1486 2
a1487 4
	// do the reorder

	// rearrange the cat-map
	if (!g_eMuleApp.m_pGlobPrefs->MoveCat(from,to)) 
d1490 2
a1491 8
	// update partfile-stored assignment
	g_eMuleApp.m_pDownloadQueue->MoveCat((uint8)from,(uint8)to);

	// move category of completed files
	m_wndDownloadList.MoveCompletedfilesCat((uint8)from,(uint8)to);

	// of the tabcontrol itself
	m_wndDlTabs.ReorderTab(from,to);
d1500 3
a1502 3
	m_wndDlTabs.SetCurSel(to);
	m_wndDownloadList.ChangeCategory(to);
	m_wndDlTabs.Invalidate();
d1508 2
a1509 1
	if(pNMHDR->hwndFrom == m_wndDlTabs.GetSafeHwnd())
d1514 1
a1514 1
				OnNMRclickDltab(pNMHDR, pResult);
d1518 1
a1518 1
				OnDblclickDltab();
d1533 1
a1533 1
				OnLvnBegindrag(pNMHDR, pResult);
@


1.48
log
@Second batch of name changes
@
text
@a99 17

// CTransferWnd dialog

IMPLEMENT_DYNAMIC(CTransferWnd, CDialog)
CTransferWnd::CTransferWnd(CWnd* pParent /*=NULL*/)
	: CResizableDialog(CTransferWnd::IDD, pParent)
{	
	m_bIsDragging = FALSE;
	m_pwndDummyForDownloadList = NULL;
}

CTransferWnd::~CTransferWnd()
{	
	m_pttDlTabToolTips->DestroyToolTipCtrl();
	SaveRollupItemHeights();
}

d117 1
d119 15
d168 1
a168 1
	m_wndInfoList.Create(WS_VISIBLE|WS_CHILD|WS_BORDER|WS_TABSTOP|LVS_REPORT|
d179 3
a181 3
	strDownloads.Format(GetResString(IDS_RUP_DOWNINFO), theApp.downloadqueue->GetFileCount(),
						theApp.downloadqueue->GetTransferringFiles(),
						(float)theApp.downloadqueue->GetDataRate() / 1024);
d183 4
a186 4
	strUploads.Format(GetResString(IDS_RUP_UPINFO), theApp.uploadqueue->GetWaitingUserCount(),
					  theApp.uploadqueue->GetUploadQueueLength(), 
					  theApp.uploadqueue->GetBanCount(),
					  (float)theApp.uploadqueue->GetDataRate()/1024);
d190 1
a190 1
	m_wndRollup.InsertItem(GetResString(IDS_RUP_INFO), _T(""), &m_wndInfoList, 2, FALSE);
d211 1
a211 1
	m_ttip.SetDelayTime(TTDT_INITIAL, theApp.glob_prefs->GetToolTipDelay()*1000+25);	//netwolf: avoid jitter when delay is set to 0
d222 4
a225 2
	// show & cat-tabs
  	sprintf(theApp.glob_prefs->GetCategory(0)->title, GetCatTitle(theApp.glob_prefs->GetAllcatType()) );
d227 3
a229 3
	sprintf(theApp.glob_prefs->GetCategory(0)->incomingpath,theApp.glob_prefs->GetIncomingDir());
	for (int ix=0;ix<theApp.glob_prefs->GetCatCount();ix++)
		m_wndDlTabs.InsertItem(ix,theApp.glob_prefs->GetCategory(ix)->title );
d414 2
a415 2
		ST_CTRLITEM* pContent = (ST_CTRLITEM*)m_wndDownloadList.GetItemData(sel);
		if(pContent->eType == FILE_TYPE)	// for downloading files
d417 1
a417 1
			CPartFile* partfile = (CPartFile*)pContent->pValue;
d424 3
a426 1
			SHGetFileInfo(partfile->GetFileName(), FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi), SHGFI_ICON|SHGFI_USEFILEATTRIBUTES);
d432 1
a432 1
		else if (pContent->eType == AVAILABLE_SOURCE || pContent->eType == UNAVAILABLE_SOURCE) // for sources
d434 2
a435 2
			bool bA4AF = IsAskedForAnotherFile(pContent);
			CUpDownClient* client = (CUpDownClient*)pContent->pValue;
d623 1
a623 1
	switch(m_nActiveWnd)
d657 1
a657 1
	m_wndInfoList.Localize();
d666 1
a666 1
		m_wndInfoList.SetColumn(theApp.glob_prefs->GetDetailColumnWidth());
d680 3
a682 3
					  theApp.downloadqueue->GetFileCount(),
						theApp.downloadqueue->GetTransferringFiles(),
							(float)theApp.downloadqueue->GetDataRate()/1024);
d696 4
a699 4
					  theApp.uploadqueue->GetWaitingUserCount(),
						theApp.uploadqueue->GetUploadQueueLength(), 
							theApp.uploadqueue->GetBanCount(),
								(float)theApp.uploadqueue->GetDataRate()/1024);
d712 1
a712 1
	switch(m_wndInfoList.GetType())
d714 2
a715 2
		case 1: 
			strInfoHeader.Format(GetResString(IDS_RUP_INFOUSER), m_wndInfoList.GetName()); 
d717 2
a718 2
		case 2: 
			strInfoHeader.Format(GetResString(IDS_RUP_INFOFILE), m_wndInfoList.GetName()); 
d720 1
a720 1
		default : 
d741 1
a741 1
	fullpath.Format(_T("%sgui.dat"), theApp.glob_prefs->GetConfigDir());
d894 1
a894 1
	fullpath.Format(_T("%sgui.dat"), theApp.glob_prefs->GetConfigDir());
d930 1
a930 1
		theApp.glob_prefs->SetAllcatType(wParam-MP_CAT_SET0);
d934 1
a934 1
		EditCatTabLabel(0, GetCatTitle(theApp.glob_prefs->GetAllcatType()));
d950 1
a950 1
			int newindex = AddCategory("?", theApp.glob_prefs->GetIncomingDir(), "", "", true);
d955 1
a955 1
				theApp.glob_prefs->RemoveCat(newindex);
d959 2
a960 2
				theApp.glob_prefs->SaveCats();
				if(theApp.glob_prefs->GetCatCount() == 1) 
d962 1
a962 1
					theApp.glob_prefs->SetAllcatType(0);
d964 1
a964 1
				theApp.emuledlg->searchwnd.UpdateCatTabs();
d966 3
a968 3
			theApp.emuledlg->searchwnd.UpdateCatTabs();
			EditCatTabLabel(newindex, theApp.glob_prefs->GetCategory(newindex)->title);
			theApp.glob_prefs->SaveCats();
d979 1
a979 1
			csName.Format("%s", theApp.glob_prefs->GetCategory(m_iRightClickIndex)->title );
d981 2
a982 2
			theApp.emuledlg->searchwnd.UpdateCatTabs();
			theApp.glob_prefs->SaveCats();
d988 2
a989 2
			theApp.downloadqueue->ResetCatParts(m_iRightClickIndex);
			theApp.glob_prefs->RemoveCat(m_iRightClickIndex);
d993 2
a994 2
			theApp.glob_prefs->SaveCats();
			if(theApp.glob_prefs->GetCatCount() == 1) 
d996 1
a996 1
				theApp.glob_prefs->SetAllcatType(0);
d998 1
a998 1
			theApp.emuledlg->searchwnd.UpdateCatTabs();
d1003 1
a1003 1
			theApp.downloadqueue->SetCatPrio(m_iRightClickIndex,PR_LOW);
d1008 1
a1008 1
			theApp.downloadqueue->SetCatPrio(m_iRightClickIndex,PR_NORMAL);
d1013 1
a1013 1
			theApp.downloadqueue->SetCatPrio(m_iRightClickIndex,PR_HIGH);
d1018 1
a1018 1
			theApp.downloadqueue->SetCatPrio(m_iRightClickIndex,PR_AUTO);
d1023 1
a1023 1
			theApp.downloadqueue->SetCatStatus(m_iRightClickIndex,MP_PAUSE);
d1028 1
a1028 1
			theApp.downloadqueue->SetCatStatus(m_iRightClickIndex,MP_STOP);
d1035 1
a1035 1
				theApp.downloadqueue->SetCatStatus(m_iRightClickIndex,MP_CANCEL);
d1041 1
a1041 1
			theApp.downloadqueue->SetCatStatus(m_iRightClickIndex,MP_RESUME);
d1046 1
a1046 1
			theApp.downloadqueue->StartPausedDownload(m_iRightClickIndex);
d1118 1
a1118 1
	for(int i=0;i<theApp.downloadqueue->GetFileCount();i++) 
d1120 1
a1120 1
		cur_file=theApp.downloadqueue->GetFileByIndex(i);
d1149 3
a1151 1

d1197 1
a1197 1
		m_CatMenu.CheckMenuItem( MP_CAT_SET0+theApp.glob_prefs->GetAllcatType() ,MF_CHECKED | MF_BYCOMMAND);
a1214 1

d1222 1
a1222 1

d1226 1
d1229 1
a1229 6
	
	ST_CTRLITEM *pListItem = (ST_CTRLITEM*)m_wndDownloadList.GetItemData(iSel);
	if(pListItem == NULL)
		return;

	if(pListItem->eType != FILE_TYPE)
d1297 3
a1299 2
					ST_CTRLITEM *pListItem = (ST_CTRLITEM*)m_wndDownloadList.GetItemData(index);
					if(pListItem != NULL)
d1301 2
a1302 5
						if(pListItem->eType == FILE_TYPE)
						{
							file = (CPartFile*)pListItem->pValue;
							file->SetCategory(m_nDropIndex);
						}
d1308 1
a1308 1
				(theApp.glob_prefs->GetAllcatType() == 1 && 
d1343 4
a1346 2
		EditCatTabLabel(i, (i == 0) ? GetCatTitle(theApp.glob_prefs->GetAllcatType()) : 
						theApp.glob_prefs->GetCategory(i)->title);
d1350 3
a1352 1

d1361 1
a1361 1
	if(theApp.glob_prefs->ShowCatTabInfos()) 
d1372 1
a1372 1
		for(int i = 0; i < theApp.downloadqueue->GetFileCount(); i++) 
d1374 1
a1374 1
			cur_file=theApp.downloadqueue->GetFileByIndex(i);
d1413 1
a1413 1
	int index = theApp.glob_prefs->AddCat(newcat);
d1433 1
a1433 1
	if (!theApp.glob_prefs->MoveCat(from,to)) 
d1437 1
a1437 1
	theApp.downloadqueue->MoveCat((uint8)from,(uint8)to);
d1446 1
a1446 1
	theApp.emuledlg->searchwnd.UpdateCatTabs();
@


1.47
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@a27 1
#include ".\transferwnd.h"
d114 1
a114 1
	SafeRollupItemHeights();
d143 3
d147 1
d153 3
d206 1
a206 1
	m_nActiveWnd = 0;
d246 1
a246 1

d259 1
a259 1

d264 1
a264 1

d285 2
a286 1
			// handle tooltip updating, when mouse is moved from one item to another
d306 1
a306 1

d311 2
d315 1
d332 2
d335 1
d349 6
a354 1
	if (sel == -1 && sel2 == -1)
d359 1
a359 1

d365 1
d368 1
d370 1
d374 1
d376 1
d378 1
d381 1
d387 1
a387 1

d473 2
a474 1
						sFileComment.Format(GetResString(IDS_TT_CMT_READ), CString(client->GetFileComment()));
d478 4
a481 2
						info += GetResString(IDS_TT_CMT_NONE); // No comment entered

d614 2
a615 1

d622 1
a622 1
		case 0:
d624 1
a624 1
			m_nActiveWnd = 1;
d631 1
a631 1
		case 1:
d633 1
a633 1
			m_nActiveWnd = 0;
d645 2
a646 1

d658 1
a658 1
	m_wndRollup.SetText(1,GetResString((m_nActiveWnd==0)?IDS_RUP_UPLOADS:IDS_ONQUEUE), true);
d668 2
a669 1

d675 3
a677 1
	strBuffer.Format(GetResString(IDS_RUP_DOWNINFO), theApp.downloadqueue->GetFileCount(),
d684 2
a685 1

d691 3
a693 1
	strBuffer.Format(GetResString(IDS_RUP_UPINFO), theApp.uploadqueue->GetWaitingUserCount(),
d701 2
a702 1

d726 1
a726 1

d735 3
d743 1
d752 1
d760 2
d765 1
d769 1
d774 1
d777 1
d780 1
d784 1
d788 1
d792 1
a792 1
			// this should also never happen
d796 1
d801 5
d828 1
d883 2
a884 2

void CTransferWnd::SafeRollupItemHeights()
d890 1
d899 1
d913 4
a916 2
		fprintf(f, "%d|%d|%d\n", m_wndRollup.GetItem(0)->pHeader->IsExpanded(),
					m_wndRollup.GetItem(1)->pHeader->IsExpanded(), m_wndRollup.GetItem(2)->pHeader->IsExpanded());
d922 1
a922 1

d949 1
d1046 2
d1052 2
a1053 1

d1058 1
d1073 1
d1079 1
a1079 1

d1105 1
a1105 1

d1139 2
a1140 1

d1149 1
a1149 1
	// Menu for category
d1152 1
d1235 1
d1239 1
d1249 1
a1249 1

d1255 1
d1259 1
d1272 1
a1272 1

d1279 1
d1291 1
d1323 1
a1323 1

d1327 1
d1329 1
d1338 3
a1340 1

d1354 1
d1363 1
d1365 5
d1373 1
a1373 2
			if(cur_file == 0) 

d1387 3
d1399 1
a1399 1

d1419 1
a1419 1

d1423 1
a1423 1
	UINT to=m_wndDlTabs.GetLastMovementDestionation();
d1454 1
a1454 1

d1489 2
@


1.46
log
@Fixed TabTooltip update and Preferences vertical scroolbar
@
text
@d175 2
a176 2
						theApp.downloadqueue->GetTransferingFiles(),
						(float)theApp.downloadqueue->GetDatarate() / 1024);
d181 1
a181 1
					  (float)theApp.uploadqueue->GetDatarate()/1024);
d645 2
a646 2
						theApp.downloadqueue->GetTransferingFiles(),
							(float)theApp.downloadqueue->GetDatarate()/1024);
d660 1
a660 1
								(float)theApp.uploadqueue->GetDatarate()/1024);
d1056 1
a1056 1
				if(cur_file->GetTransferingSrcCount() > 0) 
d1058 1
a1058 1
				speed += cur_file->GetDatarate() / 1024.0f;
d1293 1
a1293 1
				if(cur_file->GetTransferingSrcCount() > 0) 
d1296 1
a1296 1
//				speed+=cur_file->GetDatarate()/1024.0f;
@


1.45
log
@Fixed start paused files by category (when option set or by menu)
Removed Reset All Statistics (agreed with Eklmn that has no use and it brings problems)
Removed Mobile Mule profile
Localized 'All' tab when language changed
@
text
@a270 1
	// handle tooltip updating, when mouse is moved from one item to another
d272 21
a292 1
		UpdateToolTips();
@


1.44
log
@Fix for disappearing scroll buttons in tabs
@
text
@d606 1
d863 1
a863 1
		case MP_CAT_ADD: 
d887 1
a887 1
		case MP_CAT_EDIT: 
d900 1
a900 1
		case MP_CAT_REMOVE: 
d916 1
a916 1
		case MP_PRIOLOW: 
d921 1
a921 1
		case MP_PRIONORMAL: 
d926 1
a926 1
		case MP_PRIOHIGH: 
d931 1
a931 1
		case MP_PRIOAUTO: 
d936 1
a936 1
		case MP_PAUSE: 
d941 1
a941 1
		case MP_STOP : 
d946 1
a946 1
		case MP_CANCEL: 
d954 1
a954 1
		case MP_RESUME: 
d957 5
@


1.43
log
@Fix for tooltips
@
text
@d1283 1
d1301 2
d1338 1
@


1.42
log
@Fixed minor display/string issues
@
text
@d53 2
d57 1
d67 2
a68 1
			GetParent()->SendMessage(WM_NOTIFY, wParam, lParam);
d70 1
a70 1

a73 6
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam)
	{
		GetParent()->PostMessage(WM_COMMAND, wParam, lParam);

		return CWnd::OnCommand(wParam, lParam);
	}
d77 1
d82 1
d85 1
a85 20
	}

	void OnMouseMove(UINT nFlags, CPoint point)
	{
		GetParent()->PostMessage(WM_MOUSEMOVE, nFlags, MAKELPARAM(point.x, point.y));
	}

	void OnLButtonUp(UINT nFlags, CPoint point)
	{
		GetParent()->PostMessage(WM_LBUTTONUP, nFlags, MAKELPARAM(point.x, point.y));
	}

	void OnLButtonDown(UINT nFlags, CPoint point)
	{
		GetParent()->PostMessage(WM_LBUTTONDOWN, nFlags, MAKELPARAM(point.x, point.y));
	}
	
	void OnLButtonDblClk(UINT nFlags, CPoint point)
	{
		GetParent()->PostMessage(WM_LBUTTONDBLCLK, nFlags, MAKELPARAM(point.x, point.y));
a98 4
	ON_WM_LBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_MOUSEMOVE()
d158 1
a158 1
	m_pwndDummyForDownloadList->Create(AfxRegisterWndClass(0), "", WS_CHILD, rItem, pParent, TRANS_DUMMY);
d285 1
a285 1
	CListCtrl *pListCtrl = (CListCtrl*)m_wndRollup.GetItemClient(0);
@


1.41
log
@Third try to fix :(
@
text
@d476 1
a476 1
			//set the tooltip icon - Hehe with new icons this time :P
d480 1
a480 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(9);
d483 1
a483 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(10);
d486 1
a486 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(11);
d496 4
a499 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(1);
d505 1
a505 1
					pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(8);
d524 2
a525 2
		//Display the client icon - with new icons this time :P
		switch(client->GetClientSoft()) 
d528 1
a528 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(9);
d531 1
a531 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(10);
d534 1
a534 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(11);
d544 4
a547 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(1);
d553 1
a553 1
				pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(8);
@


1.40
log
@Second try to fix glitches in transfer download list
@
text
@d55 11
a65 1
		GetParent()->SendMessage(WM_NOTIFY, wParam, lParam);
d72 1
a72 1
		GetParent()->SendMessage(WM_COMMAND, wParam, lParam);
d83 1
a83 1
			m_pChild->MoveWindow(r);
d89 1
a89 1
		GetParent()->SendMessage(WM_MOUSEMOVE, nFlags, MAKELPARAM(point.x, point.y));
d94 11
a104 1
		GetParent()->SendMessage(WM_LBUTTONUP, nFlags, MAKELPARAM(point.x, point.y));
d119 2
@


1.39
log
@Removed DoubleClick option (now is default).
Added cancel for Categories Dialog (now no more ? cats after cancel)
@
text
@d43 59
d110 1
d158 4
a161 1
	m_wndDownloadList.Create(WS_VISIBLE | dwListStyle, rItem, pParent, TRANS_DOWNLOADLIST);
d169 4
a172 1
	AddBuddy(m_wndDownloadList.m_hWnd, m_wndDlTabs.m_hWnd, BDS_TOP);
d184 1
a184 1
	m_wndRollup.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strDownloads, &m_wndDownloadList, 0, TRUE);
d245 5
@


1.38
log
@Fixed autocategory (and crashes)
@
text
@d791 13
a803 1
			dialog.DoModal();
@


1.37
log
@Added Category missing feature in Search Window.
@
text
@d1206 1
a1206 1
	newcat->autocat = newautocat;
@


1.36
log
@Reverted TnasferWnd changes until we fix them to have a testable beta 2 refresh
@
text
@a117 1

a137 1
	
d193 4
a196 4
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message== WM_LBUTTONUP 
		|| pMsg->message == WM_RBUTTONDOWN || pMsg->message== WM_RBUTTONUP 
		|| pMsg->message== WM_MOUSEMOVE
		|| pMsg->message== WM_KEYDOWN || pMsg->message==WM_SYSKEYDOWN )
d202 1
a202 2
	if (pMsg->message == WM_MOUSEMOVE)
	{	
a203 1
	}
a205 1
	{	
a206 1
	}
d232 1
d240 1
a240 2
				//BEGIN Improved Tooltips
				//m_ttip.Update();
a241 1
				//END Improved Tooltips
d247 1
a247 14
/* no tooltips needed ATM
	int sel3 = GetItemUnderMouse(&m_wndQueueList);
	if (sel3 != -1)
	{
		if (sel3 != m_iOldToolTipItemQueue)
		{
			if (m_ttip.IsWindowVisible())
				m_ttip.Update();
			m_iOldToolTipItemQueue = sel3;
		}
	}
*/
	if (sel == -1 && sel2 == -1 /*&& sel3 != -1*/)
	{	
a248 1
	}
a265 1
	{
a266 1
		{	
a267 2
		}
	}
a285 1
	{	
a286 1
	}
a291 1
		{	
d293 1
a293 1
		}
a295 1
		{	
a296 1
		}
d309 1
a309 3
			SHGetFileInfo(partfile->GetFileName(),
				FILE_ATTRIBUTE_NORMAL, &shfi, sizeof(shfi),
				SHGFI_ICON|SHGFI_USEFILEATTRIBUTES);
d315 1
a315 2
		else if (pContent->eType == AVAILABLE_SOURCE || 
				 pContent->eType == UNAVAILABLE_SOURCE) // for sources
d348 2
a349 1
				}catch(...){}
d354 4
a357 2
				if (!bA4AF){
					if (client->GetFileComment() != "") { 
d359 1
a359 2
						sFileComment.Format(GetResString(IDS_TT_CMT_READ),
							CString(client->GetFileComment()));
d363 2
a364 4
					{ 
						//No comment entered 
						info += GetResString(IDS_TT_CMT_NONE); 
					} 
a365 1
					{	
a366 1
					}
a417 1
		{	
d419 1
a419 1
		}
a421 1
		{	
a422 1
		}
a425 13
		//BEGIN Improved Tooltips
		/*
		info = client->GetUploadFileInfo4Tooltips();
	    if(client->GetClientSoft() == SO_EDONKEYHYBRID)
			pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(3);
		else if (client->GetClientSoft() == SO_MLDONKEY)
			pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(2);
		else if (client->GetClientSoft()==SO_EMULE || client->GetClientSoft()==SO_OLDEMULE)
			pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(1);
		else
			pNotify->ti->hIcon = m_wndUploadList.imagelist.ExtractIcon(0);
		*/

a460 1
///*	no tooltips needed ATM
a463 1
		{	
d465 1
a465 1
		}
a467 1
		{	
a468 1
		}
a484 4
//*/
//	m_strToolTip.ReleaseBuffer(); // release old used buffer
//	m_strToolTip = info;
	//BEGIN Improved Tooltips
a485 4
	//pText->lpszText = m_strToolTip.GetBuffer(1);
	//pText->hinst = NULL; // we are not using a resource
	//PostMessage(WM_ACTIVATE);
	//END Improved Tooltips
d555 1
d569 1
d655 1
a655 1
//		TRACE("lastline = %s", cTemp);
a675 1
	{	
a676 1
	}
a749 1
			{	
a750 1
			}
a751 1
			{	
a752 1
			}
d792 1
a792 1
//			theApp.emuledlg->searchwnd.UpdateCatTabs();	// ToDo
d807 1
a807 2
		
//			theApp.emuledlg->searchwnd.UpdateCatTabs();	// ToDo
d824 1
a824 1
//			theApp.emuledlg->searchwnd.UpdateCatTabs();	// ToDo
a893 1
	{	
a894 1
	}
a895 1
	{	
a896 1
	}
a905 1
		{	
a906 1
		}
a921 9

//		if(tab>=m_pttDlTabToolTips->GetToolCount()) 
//		{
//			VERIFY(m_pttDlTabToolTips->AddTool(&m_wndDlTabs, GetTabStatistic(tab), &r, tab+1));
//		}	
//		else 
//		{
//			m_pttDlTabToolTips->UpdateTipText(GetTabStatistic(tab),&m_wndDlTabs, tab+1);
//		}
a943 1
				{
a944 1
				}
a1039 1
	{	
a1040 1
	}
a1043 1
	{	
d1045 1
a1045 1
	}
a1046 1
	{	
a1047 1
	}
a1067 1
	{	
a1068 1
	}
a1126 1

a1128 1
		{	
d1130 1
a1130 1
		}
a1141 1
	{	
d1143 1
a1143 1
	}
d1174 1
a1174 1
			{	
d1176 1
a1176 1
			}
a1180 1
				{	
d1182 1
a1182 1
				}				
a1209 1
	{
d1211 1
a1211 1
	}
a1220 1
	{
a1221 1
	}
d1224 1
a1224 1
	
a1226 1
	{
a1227 1
	}
d1239 1
a1239 1
//	theApp.emuledlg->searchwnd.UpdateCatTabs();
@


1.35
log
@Fix for two bugs in transfer download window. If it makes any problems - revert changes
@
text
@a42 33
#define TRANS_DUMMY			130


class CDummyForTabs : public CWnd
{
public:
	CDummyForTabs(){ m_pChild = NULL; }

	void SetChild(CWnd* pChild){ m_pChild = pChild;	}

	afx_msg void OnSize(uInt nType, int cx, int cy)
	{
		if(m_pChild)
		{
			CRect r;
			GetClientRect(&r);
			m_pChild->MoveWindow(r);
		}
	}

	DECLARE_DYNCREATE(CDummyForTabs)
	DECLARE_MESSAGE_MAP()

private:
	CWnd* m_pChild;
};

IMPLEMENT_DYNAMIC(CDummyForTabs, CWnd)

BEGIN_MESSAGE_MAP(CDummyForTabs, CWnd)
	ON_WM_SIZE()
END_MESSAGE_MAP()

d98 1
a98 4
	m_pwndDummyForDownloadList = new CDummyForTabs();
	m_pwndDummyForDownloadList->Create(AfxRegisterWndClass(0), "", WS_CHILD, rItem, pParent, TRANS_DUMMY);

	m_wndDownloadList.Create(WS_VISIBLE | dwListStyle, rItem, m_pwndDummyForDownloadList, TRANS_DOWNLOADLIST);
d106 1
a106 4

	m_pwndDummyForDownloadList->SetChild(&m_wndDownloadList);

	AddBuddy(m_pwndDummyForDownloadList->m_hWnd, m_wndDlTabs.m_hWnd, BDS_TOP);
d119 1
a119 1
	m_wndRollup.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strDownloads, m_pwndDummyForDownloadList, 0, TRUE);
a180 5
	if(m_pwndDummyForDownloadList)
	{
		m_pwndDummyForDownloadList->DestroyWindow();
		delete m_pwndDummyForDownloadList;
	}
@


1.34
log
@Fixes and updates (read forum to know)
@
text
@d43 33
d131 4
a134 1
	m_wndDownloadList.Create(WS_VISIBLE | dwListStyle, rItem, pParent, TRANS_DOWNLOADLIST);
d142 4
a145 1
	AddBuddy(m_wndDownloadList.m_hWnd, m_wndDlTabs.m_hWnd, BDS_TOP);
d158 1
a158 1
	m_wndRollup.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strDownloads, &m_wndDownloadList, 0, TRUE);
d220 5
@


1.33
log
@Implemented ConfigDir
@
text
@d856 1
a856 1
			int newindex = AddCategorie("?", theApp.glob_prefs->GetIncomingDir(), "", "", true);
d1293 1
a1293 1
int CTransferWnd::AddCategorie(CString newtitle,CString newincoming,CString newcomment, 
@


1.32
log
@*** empty log message ***
@
text
@d663 1
a663 1
	fullpath.Format(_T("%sgui.dat"), theApp.glob_prefs->GetAppDir());
d799 1
a799 1
	fullpath.Format(_T("%sgui.dat"), theApp.glob_prefs->GetAppDir());
@


1.31
log
@*** empty log message ***
@
text
@d25 4
d36 7
a42 3
#ifdef __USE_CATEGORIES__
#define TABLIST_TABID 12345
#endif
d49 2
a50 1
{
d54 1
a54 2
{
#ifdef __USE_CATEGORIES__
a55 1
#endif
a64 6

#ifdef __USE_CATEGORIES__
#ifndef _PRESENTATION_
	ON_NOTIFY(TCN_SELCHANGE, TABLIST_TABID, OnTcnSelchangeDltab)
	ON_NOTIFY(NM_RCLICK, TABLIST_TABID, OnNMRclickDltab)
	ON_NOTIFY(LVN_BEGINDRAG, IDC_DOWNLOADLIST, OnLvnBegindrag)
d67 7
a73 3
	ON_NOTIFY(NM_TABMOVED, TABLIST_TABID, OnTabMovement)
#endif
#endif
d78 1
a78 1
{
d87 3
a89 1
	rRollupArea.DeflateRect(11,11); // (7,7)
d91 2
a92 1
	rollupctrl.Create(NULL, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN, rRollupArea, this, 123);
d94 10
a103 11
	CRect rItem = rRollupArea;
	rItem.top += 22;
	rItem.bottom = rItem.top + (rRollupArea.Height() - 3 * 22) / 2;
	downloadlistctrl.Create(WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | LVS_REPORT | LVS_ALIGNLEFT | 
							LVS_NOLABELWRAP | LVS_OWNERDRAWFIXED | LVS_SINGLESEL, rItem, &rollupctrl, IDC_DOWNLOADLIST);
	downloadlistctrl.Init();
	downloadlistctrl.SetOwner(this);
		
#ifdef __USE_CATEGORIES__
	m_ctrlDlTabs.Create(WS_CHILD|WS_VISIBLE|WS_BORDER/*|TCS_BOTTOM*/, CRect(0,0,0,0), &rollupctrl, TABLIST_TABID);
	m_ctrlDlTabs.SetOwner(this);
d105 2
a106 26
	//cats
	rightclickindex=-1;
	
	m_wndTabList.m_pTabs = &m_ctrlDlTabs;
	m_wndTabList.m_pListCtrl = &downloadlistctrl;
	m_wndTabList.Create(NULL, NULL, WS_CHILD, rItem, &rollupctrl, 124);
#endif
		
	rItem.top = rItem.bottom + 22;
	rItem.bottom = rItem.top + (rRollupArea.Height() - 3 * 22) / 4;
	uploadlistctrl.Create(WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | LVS_REPORT | LVS_ALIGNLEFT | LVS_SINGLESEL | LVS_OWNERDRAWFIXED,
							rItem, &rollupctrl, IDC_UPLOADLIST);
	uploadlistctrl.Init();
	uploadlistctrl.SetOwner(this);

	queuelistctrl.Create(/*WS_VISIBLE |*/ WS_CHILD | WS_BORDER | WS_TABSTOP | LVS_REPORT | LVS_ALIGNLEFT | LVS_SINGLESEL | LVS_OWNERDRAWFIXED,
							rItem, &rollupctrl, IDC_QUEUELIST);
	queuelistctrl.Init();
	queuelistctrl.SetOwner(this);

    m_nActiveWnd = 0;

	rItem.top = rItem.bottom + 22;
	rItem.bottom = rItem.top + (rRollupArea.Height() - 3 * 22) / 4;
	infolistctrl.Create(WS_VISIBLE | WS_CHILD | WS_BORDER | WS_TABSTOP | LVS_REPORT | LVS_ALIGNLEFT | LVS_SINGLESEL,
							rItem, &rollupctrl, 127);
d108 2
a109 2
	CString strBuffer;
	strBuffer.Format(GetResString(IDS_RUP_DOWNINFO), theApp.downloadqueue->GetFileCount(),
d111 7
a117 6
							(float)theApp.downloadqueue->GetDatarate() / 1024);
#ifdef __USE_CATEGORIES__	
	rollupctrl.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strBuffer, &m_wndTabList, 0, TRUE);
#else
	rollupctrl.InsertItem(GetResString(IDS_RUP_DOWNLOADS), strBuffer, &downloadlistctrl, 0, TRUE);
#endif
d119 3
a121 8
	strBuffer.Format(GetResString(IDS_RUP_UPINFO), theApp.uploadqueue->GetWaitingUserCount(),
						theApp.uploadqueue->GetUploadQueueLength(), 
							theApp.uploadqueue->GetBanCount(),
								(float)theApp.uploadqueue->GetDatarate()/1024);
	rollupctrl.InsertItem(GetResString(IDS_RUP_UPLOADS), strBuffer, &uploadlistctrl, 1, TRUE);
		
	rollupctrl.InsertItem(GetResString(IDS_RUP_INFO), _T(""), &infolistctrl, 2, FALSE);
//	rollupctrl.SetHeaderColor(2, 0, GetSysColor(COLOR_3DSHADOW));
d123 2
a124 1
	AddAnchor(rollupctrl.m_hWnd, TOP_LEFT, BOTTOM_RIGHT);
d127 13
d149 2
a150 2
	m_ttip.AddTool(&downloadlistctrl, _T(""));	
	m_ttip.AddTool(&uploadlistctrl, _T(""));
a153 1
#ifdef __USE_CATEGORIES__	
d159 1
a159 1
		m_ctrlDlTabs.InsertItem(ix,theApp.glob_prefs->GetCategory(ix)->title );
d162 1
a162 1
	m_ctrlDlTabs.SetToolTips(m_pttDlTabToolTips);
a167 1
#endif
d172 1
a172 5
	
	downloadlistctrl.SetOwner(this);
	uploadlistctrl.SetOwner(this);
	queuelistctrl.SetOwner(this);

d180 1
a180 1
{
d187 1
a187 1
{
d204 3
a206 23
	if (pMsg->message==WM_MOUSEMOVE) 
	{
		POINT point;
		::GetCursorPos(&point);
	
		if (point.x != m_pLastMousePoint.x || point.y != m_pLastMousePoint.y) 
		{
			m_pLastMousePoint=point;
			// handle tooltip updating, when mouse is moved from one item to another
			UpdateToolTips();

		#ifdef __USE_CATEGORIES__
			CPoint pt(point);
			m_nDropIndex=GetTabUnderMouse(&pt);
			if (m_nDropIndex!=m_nLastCatTT) 
			{
				m_nLastCatTT=m_nDropIndex;
				if (m_nDropIndex!=-1) UpdateTabToolTips(m_nDropIndex);
				m_pttDlTabToolTips->Update();
				//m_pttDlTabToolTips->Pop();
			}
		#endif
		}
d210 1
d212 1
d221 3
a223 2
	int sel = GetItemUnderMouse((CListCtrl*)rollupctrl.GetItemClient(0));	// this is a quick fix,
	if (sel != -1)															// we should find a better solution
d228 1
d233 1
d238 1
a238 1
	int sel2 = GetItemUnderMouse((CListCtrl*)rollupctrl.GetItemClient(1));	// see above
d243 2
a244 1
			if (m_ttip.IsWindowVisible())
d249 1
d255 1
a255 1
	int sel3 = GetItemUnderMouse(&queuelistctrl);
d267 1
d269 1
d275 1
a275 1
{
d289 1
d291 1
d300 1
a300 1
{
d311 1
d313 2
d316 1
a316 1
	if (control_id == IDC_DOWNLOADLIST)
d318 2
a319 1
		if (downloadlistctrl.GetItemCount() < 1)
d321 2
a322 1
		int sel = GetItemUnderMouse(&downloadlistctrl);
d324 1
d326 1
d329 2
a330 2
		CMuleCtrlItem* content = (CMuleCtrlItem*)downloadlistctrl.GetItemData(sel);
		if (content->IsFile()) // for downloading files
d332 1
a332 1
			CPartFile* partfile = content->GetFile();
d344 1
a344 1
			downloadlistctrl.SetFocus();
d347 2
a348 1
		else if (content->IsSource()) // for sources
d350 2
a351 2
			bool bA4AF = content->IsAskedForAnotherFile();
			CUpDownClient* client = content->GetSource();
d375 2
a376 1
				try{
d384 2
a385 1
		     try { 
d393 2
a394 1
					else { 
d399 1
d401 1
d410 3
a412 1
			} catch(...) { 
d419 2
a420 1
			switch(client->GetClientSoft()) {
d422 1
a422 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(9);
d425 1
a425 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(10);
d428 1
a428 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(11);
d431 1
a431 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(3);
d434 1
a434 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(2);
d438 1
a438 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(1);
d441 1
a441 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(0);
d444 1
a444 1
					pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(8);
d450 1
a450 1
	else if (control_id == IDC_UPLOADLIST)
d452 2
a453 1
		if (uploadlistctrl.GetItemCount() < 1)
d455 2
a456 1
		int sel = GetItemUnderMouse(&uploadlistctrl);
d458 1
d460 1
d462 1
a462 1
		CUpDownClient* client = (CUpDownClient*)uploadlistctrl.GetItemData(sel);
d468 1
a468 1
			pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(3);
d470 1
a470 1
			pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(2);
d472 1
a472 1
			pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(1);
d474 1
a474 1
			pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(0);
d480 2
a481 1
		switch(client->GetClientSoft()) {
d483 1
a483 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(9);
d486 1
a486 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(10);
d489 1
a489 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(11);
d492 1
a492 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(3);
d495 1
a495 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(2);
d499 1
a499 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(1);
d502 1
a502 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(0);
d505 1
a505 1
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(8);
d509 1
a509 1
		uploadlistctrl.SetFocus();
d513 1
a513 1
	else if (control_id == IDC_QUEUELIST)
d515 2
a516 1
		if (queuelistctrl.GetItemCount() < 1)
d518 2
a519 1
		int sel = GetItemUnderMouse(&queuelistctrl);
d521 1
d523 1
d526 1
a526 1
		CUpDownClient* client = (CUpDownClient*)uploadlistctrl.GetItemData(sel);
d556 1
a556 1
{
d564 4
a567 4
			rollupctrl.SetText(1, GetResString(IDS_ONQUEUE), true);
			uploadlistctrl.ShowWindow(SW_HIDE);
			rollupctrl.SetItemClient(1, &queuelistctrl);
			rollupctrl.Invalidate();
d573 4
a576 4
			rollupctrl.SetText(1, GetResString(IDS_RUP_UPLOADS), true);
			queuelistctrl.ShowWindow(SW_HIDE);
			rollupctrl.SetItemClient(1, &uploadlistctrl);
			rollupctrl.Invalidate();
d586 1
a586 1
{
d589 4
a592 4
	downloadlistctrl.Localize();
	uploadlistctrl.Localize();
	queuelistctrl.Localize();
	infolistctrl.Localize();
d594 3
a596 3
	rollupctrl.SetText(0,GetResString(IDS_RUP_DOWNLOADS), true);
	rollupctrl.SetText(1,GetResString((m_nActiveWnd==0)?IDS_RUP_UPLOADS:IDS_ONQUEUE), true);
	rollupctrl.SetText(2,GetResString(IDS_RUP_INFO), true);
d600 1
a600 1
		infolistctrl.SetColumn(theApp.glob_prefs->GetDetailColumnWidth());
d607 1
a607 1
{
d614 1
a614 1
	rollupctrl.SetText(0, strBuffer);
d619 1
a619 1
{
d627 1
a627 1
	rollupctrl.SetText(1, strBuffer);
d637 1
a637 1
	switch(infolistctrl.GetType())
d640 1
a640 1
			strInfoHeader.Format(GetResString(IDS_RUP_INFOUSER), infolistctrl.GetName()); 
d643 1
a643 1
			strInfoHeader.Format(GetResString(IDS_RUP_INFOFILE), infolistctrl.GetName()); 
d650 1
a650 1
	rollupctrl.SetText(2, strInfoHeader);
d656 1
a656 1
{
d729 1
a729 1
				rollupctrl.ExpandItem(i, _tstoi(pToken));
d737 1
d739 1
d743 1
a743 1
	BYTE bExpandedItems; 
d745 44
a788 44
	bExpandedItems = 0x00;
	fItemHeights[0][bExpandedItems] = 0;
	fItemHeights[1][bExpandedItems] = 0;
	fItemHeights[2][bExpandedItems] = 0;

	bExpandedItems = 0x01;
	fItemHeights[0][bExpandedItems] = 100;
	fItemHeights[1][bExpandedItems] = 0;
	fItemHeights[2][bExpandedItems] = 0;

	bExpandedItems = 0x02;
	fItemHeights[0][bExpandedItems] = 0;
	fItemHeights[1][bExpandedItems] = 100;
	fItemHeights[2][bExpandedItems] = 0;

	bExpandedItems = 0x03;
	fItemHeights[0][bExpandedItems] = 70;
	fItemHeights[1][bExpandedItems] = 30;
	fItemHeights[2][bExpandedItems] = 0;

	bExpandedItems = 0x04;
	fItemHeights[0][bExpandedItems] = 0;
	fItemHeights[1][bExpandedItems] = 0;
	fItemHeights[2][bExpandedItems] = 100;

	bExpandedItems = 0x05;
	fItemHeights[0][bExpandedItems] = 70;
	fItemHeights[1][bExpandedItems] = 0;
	fItemHeights[2][bExpandedItems] = 30;

	bExpandedItems = 0x06;
	fItemHeights[0][bExpandedItems] = 0;
	fItemHeights[1][bExpandedItems] = 70;
	fItemHeights[2][bExpandedItems] = 30;

	bExpandedItems = 0x07;
	fItemHeights[0][bExpandedItems] = 50;
	fItemHeights[1][bExpandedItems] = 25;
	fItemHeights[2][bExpandedItems] = 25;
	}

	rollupctrl.SetItemHeights(0, fItemHeights[0], 8);
	rollupctrl.SetItemHeights(1, fItemHeights[1], 8);
	rollupctrl.SetItemHeights(2, fItemHeights[2], 8);
d794 1
a794 1
{
d807 3
a809 3
			f1 = rollupctrl.GetItem(0)->pSizes[exp];
			f2 = rollupctrl.GetItem(1)->pSizes[exp];
			f3 = rollupctrl.GetItem(2)->pSizes[exp];
d813 1
d815 1
d817 1
d819 1
d824 2
a825 2
		fprintf(f, "%d|%d|%d\n", rollupctrl.GetItem(0)->pHeader->IsExpanded(),
					rollupctrl.GetItem(1)->pHeader->IsExpanded(), rollupctrl.GetItem(2)->pHeader->IsExpanded());
d833 11
a843 2
{
	switch(wParam)
d848 29
a876 1
		default: 
d878 60
a942 1
#ifdef __USE_CATEGORIES__
d944 1
a944 1
{
d947 1
a947 1
	m_ctrlDlTabs.GetWindowRect(&rect);
d951 1
a951 1
	if(m_ctrlDlTabs.GetItemRect(0, &rect))
d960 1
a960 1
	unsigned int nTab = m_ctrlDlTabs.HitTest(&hitinfo);
d972 1
a972 1
{
d979 1
a979 1
			m_pttDlTabToolTips->DelTool(&m_ctrlDlTabs,i+1);
d982 1
a982 1
		for (i = 0; i < m_ctrlDlTabs.GetItemCount(); i++)
d985 2
a986 2
			m_ctrlDlTabs.GetItemRect(i, &r);
			VERIFY(m_pttDlTabToolTips->AddTool(&m_ctrlDlTabs, GetTabStatistic(i), &r, i+1));
d992 1
a992 1
		m_ctrlDlTabs.GetItemRect(tab, &r);
d994 2
a995 2
		m_pttDlTabToolTips->DelTool(&m_ctrlDlTabs,tab+1);
		VERIFY(m_pttDlTabToolTips->AddTool(&m_ctrlDlTabs, GetTabStatistic(tab), &r, tab+1));
d999 1
a999 1
//			VERIFY(m_pttDlTabToolTips->AddTool(&m_dlTab, GetTabStatistic(tab), &r, tab+1));
d1003 1
a1003 1
//			m_pttDlTabToolTips->UpdateTipText(GetTabStatistic(tab),&m_dlTab, tab+1);
d1009 1
a1009 1
{
a1043 1
#ifndef _PRESENTATION_
d1045 2
a1046 2
{
	downloadlistctrl.ChangeCategory(m_ctrlDlTabs.GetCurSel());
d1058 1
a1058 1
	rightclickindex = GetTabUnderMouse(&pt);
d1061 1
a1061 1
	flag = (rightclickindex == 0) ? MF_GRAYED : MF_STRING;
d1076 1
a1076 1
	if(rightclickindex == 0)
d1122 2
a1123 2
{
	int iSel = downloadlistctrl.GetSelectionMark();
d1125 7
d1133 3
a1135 2

	if(((CtrlItem_Struct*)downloadlistctrl.GetItemData(iSel))->type != FILE_TYPE) 
d1137 1
d1143 1
a1143 4
	int nOffset = 10;
    pt.x += nOffset;
    pt.y += nOffset;

d1146 2
a1147 2
	m_pDragImage = downloadlistctrl.CreateDragImage(downloadlistctrl.GetSelectionMark(),&pt);
    m_pDragImage->BeginDrag(0, CPoint(0,-70));
d1156 1
a1156 1
{
d1158 1
d1160 1
d1166 1
d1168 5
a1173 3
		//// Move the drag image
		m_ctrlDlTabs.SetCurSel(m_nDropIndex);
		m_ctrlDlTabs.Invalidate();
d1179 1
a1179 1
{
d1188 3
a1190 3
		if(m_nDropIndex>-1 && (downloadlistctrl.curTab == 0 ||
			(downloadlistctrl.curTab > 0 && 
				m_nDropIndex != downloadlistctrl.curTab))) 
d1194 1
a1194 1
			POSITION pos = downloadlistctrl.GetFirstSelectedItemPosition(); 
d1197 1
a1197 1
				index = downloadlistctrl.GetNextSelectedItem(pos); 
d1200 2
a1201 1
					if(((CtrlItem_Struct*)downloadlistctrl.GetItemData(index))->type == FILE_TYPE) 
d1203 5
a1207 2
						file=(CPartFile*)((CtrlItem_Struct*)downloadlistctrl.GetItemData(index))->value;
						file->SetCategory(m_nDropIndex);
d1211 2
a1212 2
			m_ctrlDlTabs.SetCurSel(downloadlistctrl.curTab);
			if(m_ctrlDlTabs.GetCurSel() > 0 || 
d1214 1
a1214 1
					m_ctrlDlTabs.GetCurSel()==0))
d1216 1
a1216 1
				downloadlistctrl.ChangeCategory(m_ctrlDlTabs.GetCurSel());
d1223 1
a1223 1
			m_ctrlDlTabs.SetCurSel(downloadlistctrl.curTab);
d1225 1
a1225 1
		downloadlistctrl.Invalidate();
d1230 1
a1230 1
{
d1236 1
d1238 2
a1239 1
	rightclickindex = tab;
d1244 6
a1249 3
{
	for(uint8 i=0; i<m_ctrlDlTabs.GetItemCount(); i++)
		EditCatTabLabel(i, (i==0) ? GetCatTitle(theApp.glob_prefs->GetAllcatType()) : theApp.glob_prefs->GetCategory(i)->title);
d1254 1
a1254 1
{
d1257 1
a1257 1
	m_ctrlDlTabs.GetItem(index,&tabitem);
d1264 2
a1265 2
		count=dwl=0;
		for(int i=0;i<theApp.downloadqueue->GetFileCount();i++) 
d1268 2
a1269 1
			if(cur_file==0) 
d1271 1
d1276 1
d1278 1
d1289 1
a1289 1
	m_ctrlDlTabs.SetItem(index,&tabitem);
d1293 2
a1294 2
int CTransferWnd::AddCategorie(CString newtitle,CString newincoming,
								CString newcomment,bool addTab)
d1296 1
a1296 1
	Category_Struct* newcat=new Category_Struct;
d1298 7
a1304 6
	sprintf(newcat->title,newtitle);
	newcat->prio=0;
	sprintf(newcat->incomingpath,newincoming);
	sprintf(newcat->comment,newcomment);
	int index=theApp.glob_prefs->AddCat(newcat);
	
d1306 3
a1308 1
		m_ctrlDlTabs.InsertItem(index,newtitle);
a1310 2
#endif
#endif
d1312 72
@


1.30
log
@*** empty log message ***
@
text
@d46 3
a100 15
	m_ctrlDlTabs.InsertItem(0, "All");
	m_ctrlDlTabs.InsertItem(1, "Movies");
	m_ctrlDlTabs.InsertItem(2, "Music");
	m_ctrlDlTabs.InsertItem(3, "Programs");
	m_ctrlDlTabs.InsertItem(4, "Games");
	m_ctrlDlTabs.InsertItem(5, "X-Box");

	char sz[10];
	for(int i = 6; i < 100; i++)
	{
		sprintf(sz, "Item %02d", i);
		m_ctrlDlTabs.InsertItem(i, sz);
	}


d161 17
d217 24
a240 3
	if (pMsg->message == WM_MOUSEMOVE)
		UpdateToolTips();

d838 101
d1019 1
a1019 1
    int iSel = downloadlistctrl.GetSelectionMark();
d1022 1
a1107 20
}

int CTransferWnd::GetTabUnderMouse(CPoint* point) 
{
	TCHITTESTINFO hitinfo;
	CRect rect;
	m_ctrlDlTabs.GetWindowRect(&rect);
	point->Offset(0-rect.left,0-rect.top);
	hitinfo.pt = *point;

	if(m_ctrlDlTabs.GetItemRect(0, &rect))
		if(hitinfo.pt.y< rect.top+30 && hitinfo.pt.y >rect.top-30)
			hitinfo.pt.y = rect.top;

	// Find the destination tab...
	unsigned int nTab = m_ctrlDlTabs.HitTest(&hitinfo);
	if(hitinfo.flags != TCHT_NOWHERE)
		return nTab;
	else 
		return -1;
@


1.29
log
@CHANGE: WebServer: separated upload queue into friends, banned clients, high credit clients and other client queues [Purity]
@
text
@d32 3
d55 11
d91 27
d141 3
d145 1
a145 1

d810 265
@


1.28
log
@Update tooltip only in case corresponding WM_MESSAGE ()
@
text
@d491 1
a491 1
			rollupctrl.SetText(1, GetResString(IDS_RUP_ONQUEUE), true);
d522 1
a522 1
	rollupctrl.SetText(1,GetResString((m_nActiveWnd==0)?IDS_RUP_UPLOADS:IDS_RUP_ONQUEUE), true);
@


1.27
log
@in DownloadQueue show values for download asked
@
text
@d158 6
a163 3
	// eklmn: bugfix(07): Update tooltip only in case connected WM_MESSAGE
	// relay mouse events to tooltip control
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message== WM_LBUTTONUP || pMsg->message== WM_MOUSEMOVE)
d165 1
@


1.26
log
@unicode cleanup
@
text
@d304 1
a304 1
						client->GetAskedCount(), client->GetAvailablePartCount());
@


1.25
log
@Update tooltip only in case corresponding WM_MESSAGE
@
text
@d109 1
a109 1
	rollupctrl.InsertItem(GetResString(IDS_RUP_INFO), "", &infolistctrl, 2, FALSE);
d453 4
a456 4
		info.Format("Nickname: %s (UserID: %u)\n"
					"Client %s:%d\n"
					"Server %s:%d\n"
					"AskedCount: %d - AvailablePartCount: %d",
d558 1
a558 1
	CString strInfoHeader = "";
d586 2
a587 2
	fullpath.Format("%sgui.dat", theApp.glob_prefs->GetAppDir());
	f = fopen(fullpath, "rb");	
d593 3
a595 3
		char cTemp[512];
		char *pToken;
        char seps[] = "|\n";
d599 1
a599 1
			if(!fgets(cTemp, 512, f))
d606 1
a606 1
			pToken = strtok(cTemp, seps);
d616 3
a618 3
				fItemHeights[i][exp] = atof(pToken);
//				TRACE("fItemHeights[%d][%d] = %f\r\n", i, exp, atof(pToken));
				pToken = strtok(NULL, seps);
d637 1
a637 1
		if(!fgets(cTemp, 512, f))
d642 1
a642 1
			pToken = strtok(cTemp, seps);
d652 2
a653 2
				rollupctrl.ExpandItem(i, atoi(pToken));
				pToken = strtok(NULL, seps);
d720 2
a721 2
	fullpath.Format("%sgui.dat", theApp.glob_prefs->GetAppDir());
	f = fopen(fullpath, "wb");	
@


1.24
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d158 5
a166 5
	// relay mouse events to tooltip control
	//BEGIN Improved Tooltips
	//if (pMsg->message == WM_LBUTTONDOWN || pMsg->message== WM_LBUTTONUP || pMsg->message== WM_MOUSEMOVE)
		m_ttip.RelayEvent(pMsg);
	//END Improved Tooltips
@


1.23
log
@coverted code from char * to CString
@
text
@d51 1
d141 8
@


1.22
log
@avoid jitter when delay is set to 0
@
text
@d576 3
a578 4
	char* fullpath = new char[strlen(theApp.glob_prefs->GetAppDir())+MAX_PATH]; // i_a
	sprintf(fullpath,"%sgui.dat", theApp.glob_prefs->GetAppDir());
	f = fopen(fullpath, "rb");
	delete [] fullpath;
d710 3
a712 4
	char* fullpath = new char[strlen(theApp.glob_prefs->GetAppDir())+MAX_PATH]; // i_a
	sprintf(fullpath,"%sgui.dat", theApp.glob_prefs->GetAppDir());
	f = fopen(fullpath, "wb");
	delete [] fullpath;
@


1.21
log
@Tooltips fixes
@
text
@d117 1
a117 1
	m_ttip.SetDelayTime(TTDT_INITIAL, theApp.glob_prefs->GetToolTipDelay()*1000);
@


1.20
log
@Tooltips fixes
@
text
@d295 1
a295 1
						/*client->GetAskedCount()*/0, client->GetAvailablePartCount());
@


1.19
log
@Added the New icons on the new tooltips :), a case of two things being added at the same time
@
text
@d125 1
a125 1
	m_ttip.SetFont(_T("Courier"), 9);
a425 4




@


1.18
log
@Fixes for tooltips
@
text
@d342 28
a369 9
			//Set tooltip icon
			if(client->GetClientSoft() == SO_EDONKEYHYBRID)
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(3);
			else if (client->GetClientSoft() == SO_MLDONKEY)
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(2);
			else if (client->GetClientSoft()==SO_EMULE || client->GetClientSoft()==SO_OLDEMULE)
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(1);
			else
				pNotify->ti->hIcon = uploadlistctrl.imagelist.ExtractIcon(0);
d384 1
d394 36
@


1.17
log
@Enhanced tooltips by JoeyRamone
@
text
@d125 1
d290 2
a291 1
				+GetResString(IDS_TT_SOURCEINFO),
@


1.16
log
@Webserver from official 0.27c
@
text
@d47 4
a50 1
	ON_NOTIFY_EX_RANGE(TTN_NEEDTEXT,0,0xFFFF,OnToolTipNotify)
d119 8
a126 2
	m_ttip.AddTool(&downloadlistctrl);
	m_ttip.AddTool(&uploadlistctrl);
d153 2
a154 1
	if (pMsg->message == WM_LBUTTONDOWN || pMsg->message== WM_LBUTTONUP || pMsg->message== WM_MOUSEMOVE)
d156 1
d174 4
a177 1
				m_ttip.Update();
d188 4
a191 1
				m_ttip.Update();
d241 7
a247 2
	TOOLTIPTEXT *pText = (TOOLTIPTEXT *)pNMH;
	int control_id = ::GetDlgCtrlID((HWND)pNMH->idFrom);
d264 13
a276 1
			info = partfile->GetDownloadFileInfo();	// kuchin
d285 5
a289 4
			info.Format(GetResString(IDS_NICKNAME)+" %s ("+GetResString(IDS_USERID)+": %u)\n"
				+GetResString(IDS_CLIENT)+" %s:%d\n"
				+GetResString(IDS_SERVER)+" %s:%d\n"
				+GetResString(IDS_SOURCEINFO),
d296 4
a299 1
				info += GetResString(IDS_CLIENTSOURCENAME) + CString(client->GetClientFilename());
d305 4
a308 1
					info += GetResString(IDS_ASKEDFAF) + ": " + client->reqfile->GetFileName();
d315 4
a318 1
						info += "\n" + GetResString(IDS_CMT_READ)  + " " + CString(client->GetFileComment()); 
d322 10
a331 1
						info += "\n" + GetResString(IDS_CMT_NONE); 
a332 1
					info += "\n" + GetRateString(client->GetFileRate());
d336 1
a336 1
				info += "\n" + GetResString(IDS_CMT_NOTCONNECTED); 
d339 11
d361 14
a374 1
		info = client->GetUploadFileInfo();
d401 8
a408 5
	m_strToolTip.ReleaseBuffer(); // release old used buffer
	m_strToolTip = info;
	pText->lpszText = m_strToolTip.GetBuffer(1);
	pText->hinst = NULL; // we are not using a resource
	PostMessage(WM_ACTIVATE);
@


1.15
log
@last seen complete and last downloaded are displayed under locale settings
@
text
@d242 1
a242 1
			info = GetDownloadFileInfo(partfile);	// kuchin
d298 1
a298 1
		info = GetUploadFileInfo(client);
a621 83

// kuchin
CString CTransferWnd::GetDownloadFileInfo(CPartFile *partfile)
{
	EMULE_TRY

	if(partfile == NULL)
		return "";
	CString sRet;
	CString strHash;
	strHash.Format("%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",
	partfile->GetFileHash()[0],partfile->GetFileHash()[1],partfile->GetFileHash()[2],partfile->GetFileHash()[3],partfile->GetFileHash()[4],partfile->GetFileHash()[5],partfile->GetFileHash()[6],partfile->GetFileHash()[7],
	partfile->GetFileHash()[8],partfile->GetFileHash()[9],partfile->GetFileHash()[10],partfile->GetFileHash()[11],partfile->GetFileHash()[12],partfile->GetFileHash()[13],partfile->GetFileHash()[14],partfile->GetFileHash()[15]);

	CTime t(partfile->GetFileDate());

	char lsc[50]; char compl[50]; char lastprogr[50];

	
	sprintf(compl,"%s/%s",CastItoXBytes(partfile->GetCompletedSize()),CastItoXBytes(partfile->GetFileSize()));

	if (partfile->lastseencomplete==NULL) sprintf(lsc,GetResString(IDS_UNKNOWN).MakeLower() ); else
		sprintf(lsc,partfile->localelastseencomplete());
	//sprintf(lsc,partfile->lastseencomplete.Format( "%A, %x, %X"));

	if (partfile->GetCompletedSize()==0) sprintf(lastprogr,GetResString(IDS_UNKNOWN).MakeLower() ); else
		sprintf(lastprogr,partfile->localelastdowntransfer());
		
		//sprintf(lastprogr,partfile->GetLastDownTransfer().Format("%A, %x, %X"));

	float availability = 0;
	if(partfile->GetPartCount() != 0) {
		availability = partfile->GetAvailablePartCount() * 100 / partfile->GetPartCount();
	}
	sRet.Format(GetResString(IDS_DL_FILENAME)+": %s (%d %s)\n"
		+GetResString(IDS_DATE)+": %s - "+ GetResString(IDS_FD_HASH) +" %s\n"
		+GetResString(IDS_PARTINFOS)+
		GetResString(IDS_PARTINFOS2)+"\n%s\n%s",
				partfile->GetFileName(), partfile->GetFileSize(),GetResString(IDS_BYTES),
				t.Format("%A, %B %d, %Y"), strHash,
				partfile->GetPartMetFileName(), partfile->GetPartCount(),GetResString(IDS_AVAIL),partfile->GetAvailablePartCount(),availability,
				(int)partfile->GetPercentCompleted(), compl, partfile->GetTransferingSrcCount(),
				GetResString(IDS_LASTSEENCOMPL)+" "+CString(lsc),
                GetResString(IDS_LAST_FILE_PROGRESS) +" "+CString(lastprogr));

	return sRet;

	EMULE_CATCH

	return "";

}

// kuchin
CString CTransferWnd::GetUploadFileInfo(CUpDownClient *client)
{
	EMULE_TRY

	if(client == NULL)
		return "";
	CString sRet;
	CKnownFile* file = theApp.sharedfiles->GetFileByID(client->reqfileid);
	// build info text and display it
	sRet.Format(GetResString(IDS_USERINFO), client->GetUserName(), client->GetUserID());
	if (file)
	{
		sRet += GetResString(IDS_SF_REQUESTED) + CString(file->GetFileName()) + "\n";
		CString stat;
		stat.Format(GetResString(IDS_FILESTATS_SESSION)+GetResString(IDS_FILESTATS_TOTAL),
					file->statistic.GetAccepts(), file->statistic.GetRequests(), file->statistic.GetTransfered(),
					file->statistic.GetAllTimeAccepts(), file->statistic.GetAllTimeRequests(), file->statistic.GetAllTimeTransfered());
		sRet += stat;
	}
	else
	{
		sRet += GetResString(IDS_REQ_UNKNOWNFILE);
	}
	return sRet;

	EMULE_CATCH
	
	return "";
}@


1.14
log
@proper update of vcproject, and minor localization bugfix
@
text
@d644 2
a645 1
	sprintf(lsc,partfile->lastseencomplete.Format( "%A, %x, %X"));
d648 3
a650 1
	sprintf(lastprogr,partfile->GetLastDownTransfer().Format("%A, %x, %X"));
@


1.14.2.1
log
@27a partial merge
@
text
@d644 1
a644 1
	sprintf(lsc,partfile->lastseencomplete.Format(theApp.glob_prefs->GetDateTimeFormat()));
d647 1
a647 1
	sprintf(lastprogr,partfile->GetLastDownTransfer().Format(theApp.glob_prefs->GetDateTimeFormat()));
d680 1
a680 1
	CKnownFile* file = theApp.sharedfiles->GetFileByID(client->GetUploadFileID());
@


1.14.2.2
log
@27c
@
text
@d636 2
d639 1
d646 2
a647 4
	if (partfile->GetCFileDate()!=NULL)
		sprintf(lastprogr,partfile->GetCFileDate().Format( theApp.glob_prefs->GetDateTimeFormat()));
	else
		 sprintf(lastprogr,GetResString(IDS_UNKNOWN).MakeLower());
d657 2
a658 2
				partfile->GetFileName(), CastItoXBytes(partfile->GetFileSize()),GetResString(IDS_BYTES),
						strHash,
@


1.13
log
@bugfix a4af local name
@
text
@d374 4
@


1.12
log
@Updates to reCDVst changes (missing strings) and some changes to the context menu (lost an hour for a f****** define). Added standard web services.
@
text
@d264 5
a268 11
			{	// client asked twice
				/*
				// Lord KiRon 
				CKnownFile* file = theApp.sharedfiles->GetFileByID(client->reqfileid);
				if (file)
					info += GetResString(IDS_ASKEDFAF) + ": " + file->GetFileName();
				else
					info += GetResString(IDS_ASKEDFAF) + ": " + client->GetClientFilename();
				// Lord KiRon - end
				*/
				info += GetResString(IDS_ASKEDFAF) + ": " + client->GetClientFilename();
@


1.11
log
@Exception handling
@
text
@a375 1
	downloadlistctrl.CreateMenues();
@


1.10
log
@3rd rewrite - multimap rulez
@
text
@d53 2
d126 1
a126 2


d155 2
d194 1
d199 2
d214 3
d222 2
d246 1
d259 1
a259 1
			if (!content->IsAskedForAnotherFile())
d278 1
a278 1
				if (!content->IsAskedForAnotherFile()){
d336 3
d344 2
d368 2
d374 2
d386 2
d392 2
d399 2
d404 2
d412 2
d417 2
d435 2
d441 2
d479 1
a479 1
				TRACE("fItemHeights[%d][%d] = %f\r\n", i, exp, atof(pToken));
d501 1
a501 1
		TRACE("lastline = %s", cTemp);
d525 1
a525 1
{
d572 2
d578 2
d608 2
@


1.9
log
@listcontent rewrite - second try
@
text
@d230 1
a230 1
			CPartFile* partfile = content->GetFile()->GetFile();
d235 1
a235 1
			CUpDownClient* client = content->GetSource()->GetSource();
@


1.8
log
@Rewrite of listcontent
@
text
@d230 1
a230 1
			CPartFile* partfile = content->GetFile();
d235 1
a235 1
			CUpDownClient* client = content->GetSource();
@


1.7
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d227 2
a228 2
		CtrlItem_Struct* content = (CtrlItem_Struct*)downloadlistctrl.GetItemData(sel);
		if (content->type == 1) // for downloading files
d230 1
a230 1
			CPartFile* partfile = (CPartFile*)content->value;
d233 1
a233 1
		else if (content->type == 3 || content->type == 2) // for sources
d235 1
a235 1
			CUpDownClient* client = (CUpDownClient*)content->value;
d247 1
a247 1
			if (content->type == 2)
d265 16
a280 16
         try { 
			 if (content->type==2){
				if (client->GetFileComment() != "") { 
					info += "\n" + GetResString(IDS_CMT_READ)  + " " + CString(client->GetFileComment()); 
				} 
				else { 
					//No comment entered 
					info += "\n" + GetResString(IDS_CMT_NONE); 
				} 
				info += "\n" + GetRateString(client->GetFileRate());
			 }
         } catch(...) { 
            //Information not received = not connected or connecting 
            info += "\n" + GetResString(IDS_CMT_NOTCONNECTED); 
         } 
         //-End file comment-//
@


1.6
log
@Vorlost patch for invalid port + 2 bugfixes
@
text
@d26 5
@


1.5
log
@minor preferences update...
@
text
@d49 1
d118 4
a347 1

d355 5
a359 1
	infolistctrl.GetColumn();
@


1.4
log
@.26b port
@
text
@d351 1
@


1.3
log
@show last progress time on a file being downloaded
@
text
@a582 2
	char lsc[50]; char compl[50]; char buffer[20];
    char lastprogr[50];
d584 4
a587 3
	CastItoXBytes(partfile->GetCompletedSize(),lsc);
	CastItoXBytes(partfile->GetFileSize() ,buffer);
	sprintf(compl,"%s/%s",lsc,buffer);
@


1.2
log
@updated to .25b codebase
@
text
@d584 1
d593 3
d603 1
a603 1
		GetResString(IDS_PARTINFOS2)+"\n%s",
d608 2
a609 1
				GetResString(IDS_LASTSEENCOMPL)+" "+CString(lsc));
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d317 26
a554 25
void CTransferWnd::SwitchUploadList()
{
	switch(m_nActiveWnd)
	{
		case 0:
		{	
			m_nActiveWnd = 1;
			rollupctrl.SetText(1, GetResString(IDS_RUP_ONQUEUE), true);
			uploadlistctrl.ShowWindow(SW_HIDE);
			rollupctrl.SetItemClient(1, &queuelistctrl);
			rollupctrl.Invalidate();
			break;
		}
		case 1:
		{	
			m_nActiveWnd = 0;
			rollupctrl.SetText(1, GetResString(IDS_RUP_UPLOADS), true);
			queuelistctrl.ShowWindow(SW_HIDE);
			rollupctrl.SetItemClient(1, &uploadlistctrl);
			rollupctrl.Invalidate();
			break;
		}
		default: break;
	}
}
@

