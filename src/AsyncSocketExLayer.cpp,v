head	1.12;
access;
symbols
	PublicRelease_1_2e:1.11
	Interim_Release_1-2e_RC1:1.11
	PublicRelease_1_2d:1.9
	Interim_Release_1-2d_RC1:1.9
	Interim_Release_1-2d_beta1:1.9
	PublicRelease_1_2c:1.9
	Interim_Release_1-2c_RC1:1.9
	Interim_Release_1-2c_beta1:1.9
	PublicRelease_1_2b:1.9
	Interim_Release_1-2b_RC1:1.9
	PublicRelease_1_2a:1.9
	Interim_Release_1-2a_RC1:1.9
	Interim_Release_1-2a_beta2:1.9
	Interim_Release_1-2a_beta1:1.9
	PublicRelease_1_2:1.8
	Interim_Release_1-2_RC1:1.8
	Interim_Release_1-2_beta1:1.7
	PublicRelease_1_1g:1.7
	Interim_Release_1-1g_RC3:1.7
	Interim_Release_1-1g_RC2:1.7
	Interim_Release_1-1g_RC1:1.7
	Interim_Release_1-1g_beta2:1.7
	Interim_Release_1-1g_beta1:1.7
	PublicRelease_1_1f:1.7
	Interim_Release_1-1f_RC1:1.7
	PublicRelease_1_1e:1.7
	Interim_Release_1-1e_RC2:1.7
	Interim_Release_1-1e_RC1:1.7
	Interim_Release_1-1e_beta1:1.7
	PublicRelease_1_1d:1.7
	Interim_Release_1-1d_RC1:1.7
	PublicRelease_1_1c:1.7
	Interim_Release_1-1c_RC1:1.7
	Interim_Release_1-1c_beta2:1.7
	Interim_Release_1-1c_beta1:1.7
	PublicRelease_1_1b:1.7
	Interim_Release_1-1b_RC1:1.7
	PublicRelease_1_1a:1.7
	Interim_Release_1-1a_RC2:1.7
	Interim_Release_1-1a_RC1:1.7
	Interim_Release_1-1a_beta2:1.7
	Interim_Release_1-1a_beta1:1.7
	PublicRelease_1_1:1.7
	Interim_Release_1-1_beta1:1.7
	PublicRelease_1o:1.7
	Interim_Release_1o_RC1:1.7
	Interim_Release_1o_beta1:1.7
	PublicRelease_1n:1.7
	Interim_Release_1n_RC2:1.7
	Interim_Release_1n_RC1:1.7
	Interim_Release_1n_beta2:1.7
	Interim_Release_1n_beta1:1.7
	PublicRelease_1m:1.7
	Interim_Release_1m_beta1:1.7
	PublicRelease_1l:1.7
	Interim_Release_1l_RC3:1.7
	Interim_Release_1l_RC2:1.7
	Interim_Release_1l_RC1:1.7
	Interim_Release_1l_beta2:1.7
	Interim_Release_1l_beta1:1.7
	PublicRelease_1k:1.7
	Interim_Release_1k_RC4:1.7
	Interim_1k_RC3:1.7
	Interim_1k_RC2:1.7
	Interim_Release_1k_RC1:1.7
	Interim_Release_1k_beta5:1.7
	Intrerim_Release_1k_beta4:1.7
	Interim_Release_1k_beta1:1.7
	PublicRelease_1j:1.6
	Interim_Release_1J_RC3:1.6
	Interim_Release_1j_RC3:1.6
	Interim_Release_1j_RC2:1.6
	Interim_Release_1j_RC1:1.6
	Interim_Release_1j_beta2:1.6
	Interim_Release_1j_beta1:1.6
	PublicRelease_1i:1.6
	Interim_Release_1i_RC6:1.6
	Interim_Release_1i_RC3:1.6
	Interim_Release_1i_RC2:1.6
	Interim_Release_1i_RC1:1.6
	Interim_Release_1i_beta3:1.6
	Interim_Release_1i_beta2:1.6
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.14
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.12
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.10
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.8
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.1
	proxytest:1.1.2.1.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@// @;


1.12
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2008.10.17.04.53.54;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2008.07.17.05.01.22;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.16.04.14.58;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2006.02.15.05.29.47;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.11.04.12.59;	author katsyonak;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.12.22.39.04;	author dongato;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.30.10.20.52;	author dongato;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.22.16.32.03;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.15.36.57;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Fast byte swap for ntohl and ntohs.
@
text
@/*CAsyncSocketEx by Tim Kosse (Tim.Kosse@@gmx.de)
            Version 1.1 (2002-11-01)
--------------------------------------------------------

Introduction:
-------------

CAsyncSocketEx is a replacement for the MFC class CAsyncSocket.
This class was written because CAsyncSocket is not the fastest WinSock
wrapper and it's very hard to add new functionality to CAsyncSocket
derived classes. This class offers the same functionality as CAsyncSocket.
Also, CAsyncSocketEx offers some enhancements which were not possible with
CAsyncSocket without some tricks.

How do I use it?
----------------
Basically exactly like CAsyncSocket.
To use CAsyncSocketEx, just replace all occurrences of CAsyncSocket in your
code with CAsyncSocketEx, if you did not enhance CAsyncSocket yourself in
any way, you won't have to change anything else in your code.

Why is CAsyncSocketEx faster?
-----------------------------

CAsyncSocketEx is slightly faster when dispatching notification event messages.
First have a look at the way CAsyncSocket works. For each thread that uses
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with
the handle of that window. Until here, CAsyncSocketEx works the same way.
But CAsyncSocket uses only one window message (WM_SOCKET_NOTIFY) for all
sockets within one thread. When the window receive WM_SOCKET_NOTIFY, wParam
contains the socket handle and the window looks up an CAsyncSocket instance
using a map. CAsyncSocketEx works differently. It's helper window uses a
wide range of different window messages (WM_USER through 0xBFFF) and passes
a different message to WSAAsyncSelect for each socket. When a message in
the specified range is received, CAsyncSocketEx looks up the pointer to a
CAsyncSocketEx instance in an Array using the index of message - WM_USER.
As you can see, CAsyncSocketEx uses the helper window in a more efficient
way, as it don't have to use the slow maps to lookup it's own instance.
Still, speed increase is not very much, but it may be noticeable when using
a lot of sockets at the same time.
Please note that the changes do not affect the raw data throughput rate,
CAsyncSocketEx only dispatches the notification messages faster.

What else does CAsyncSocketEx offer?
------------------------------------

CAsyncSocketEx offers a flexible layer system. One example is the proxy layer.
Just create an instance of the proxy layer, configure it and add it to the layer
chain of your CAsyncSocketEx instance. After that, you can connect through
proxies.
Benefit: You don't have to change much to use the layer system.
Another layer that is currently in development is the SSL layer to establish
SSL encrypted connections.

License
-------

Feel free to use this class, as long as you don't claim that you wrote it
and this copyright notice stays intact in the source files.
If you use this class in commercial applications, please send a short message
to tim.kosse@@gmx.de
*/
#include "stdafx.h"
#include "AsyncSocketExLayer.h"
#include "AsyncSocketEx.h"
#include "otherfunctions.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


//////////////////////////////////////////////////////////////////////
// Konstruktion/Destruktion
//////////////////////////////////////////////////////////////////////

CAsyncSocketExLayer::CAsyncSocketExLayer()
{
	m_pOwnerSocket = NULL;
	m_pNextLayer = NULL;
	m_pPrevLayer = NULL;

	m_nLayerState = LAYERSTATE_NOTSOCK;
	m_nCriticalError = 0;
}

CAsyncSocketExLayer::~CAsyncSocketExLayer()
{
}

CAsyncSocketExLayer *CAsyncSocketExLayer::AddLayer(CAsyncSocketExLayer *pLayer, CAsyncSocketEx *pOwnerSocket)
{
	ASSERT(pLayer);
	ASSERT(pOwnerSocket);
	if (m_pNextLayer)
	{
		return m_pNextLayer->AddLayer(pLayer, pOwnerSocket);
	}
	else
	{
		ASSERT(m_pOwnerSocket==pOwnerSocket);
		pLayer->Init(this, m_pOwnerSocket);
		m_pNextLayer=pLayer;
	}
	return m_pNextLayer;
}

int CAsyncSocketExLayer::Receive(void* lpBuf, int nBufLen, int nFlags /*=0*/)
{
	return ReceiveNext(lpBuf, nBufLen, nFlags);
}

int CAsyncSocketExLayer::Send(const void* lpBuf, int nBufLen, int nFlags /*=0*/)
{
	return SendNext(lpBuf, nBufLen, nFlags);
}

void CAsyncSocketExLayer::OnReceive(int nErrorCode)
{
	if (m_pPrevLayer)
		m_pPrevLayer->OnReceive(nErrorCode);
	else
		if (m_pOwnerSocket->m_lEvent&FD_READ)
			m_pOwnerSocket->OnReceive(nErrorCode);
}

void CAsyncSocketExLayer::OnSend(int nErrorCode)
{
	if (m_pPrevLayer)
		m_pPrevLayer->OnSend(nErrorCode);
	else
		if (m_pOwnerSocket->m_lEvent&FD_WRITE)
			m_pOwnerSocket->OnSend(nErrorCode);
}

void CAsyncSocketExLayer::OnConnect(int nErrorCode)
{
	if (m_pPrevLayer)
		m_pPrevLayer->OnConnect(nErrorCode);
	else
		if (m_pOwnerSocket->m_lEvent&FD_CONNECT)
			m_pOwnerSocket->OnConnect(nErrorCode);
}

void CAsyncSocketExLayer::OnAccept(int nErrorCode)
{
	if (m_pPrevLayer)
		m_pPrevLayer->OnAccept(nErrorCode);
	else
		if (m_pOwnerSocket->m_lEvent&FD_ACCEPT)
			m_pOwnerSocket->OnAccept(nErrorCode);
}

void CAsyncSocketExLayer::OnClose(int nErrorCode)
{
	if (m_pPrevLayer)
		m_pPrevLayer->OnClose(nErrorCode);
	else
		if (m_pOwnerSocket->m_lEvent&FD_CLOSE)
			m_pOwnerSocket->OnClose(nErrorCode);
}

BOOL CAsyncSocketExLayer::TriggerEvent(long lEvent, int nErrorCode, BOOL bPassThrough /*=FALSE*/ )
{
	ASSERT(m_pOwnerSocket);
	if (m_pOwnerSocket->m_SocketData.hSocket == INVALID_SOCKET)
		return FALSE;

	if (lEvent & FD_CONNECT)
	{
		ASSERT(bPassThrough);
		if (nErrorCode == 0)
			ASSERT(bPassThrough && GetLayerState() == LAYERSTATE_CONNECTED);
		else
		{
			SetLayerState(LAYERSTATE_ABORTED);
			m_nCriticalError = nErrorCode;
		}
	}
	else if (lEvent & FD_CLOSE && nErrorCode == 0)
	{
		SetLayerState(LAYERSTATE_CLOSED);
	}
	else if (lEvent & FD_CLOSE && nErrorCode != 0)
	{
		SetLayerState(LAYERSTATE_ABORTED);
		m_nCriticalError = nErrorCode;
	}
	ASSERT(m_pOwnerSocket->m_pLocalAsyncSocketExThreadData);
	ASSERT(m_pOwnerSocket->m_pLocalAsyncSocketExThreadData->m_pHelperWindow);
	ASSERT(m_pOwnerSocket->m_SocketData.nSocketIndex != -1);
	t_LayerNotifyMsg *pMsg = new t_LayerNotifyMsg;
	pMsg->lEvent = (lEvent & 0xFFFF) + (nErrorCode << 16);
	pMsg->pLayer = bPassThrough ? m_pPrevLayer : this;
	BOOL res = PostMessage(m_pOwnerSocket->GetHelperWindowHandle(), WM_SOCKETEX_TRIGGER, (WPARAM)m_pOwnerSocket, (LPARAM)pMsg);
	if (!res)
		delete pMsg;
	return res;
}

void CAsyncSocketExLayer::Close()
{
	CloseNext();
}

void CAsyncSocketExLayer::CloseNext()
{
	SetLayerState(LAYERSTATE_NOTSOCK);
	if (m_pNextLayer)
		m_pNextLayer->Close();
}

BOOL CAsyncSocketExLayer::Connect(LPCSTR lpszHostAddress, UINT nHostPort)
{
	return ConnectNext(lpszHostAddress, nHostPort);
}

BOOL CAsyncSocketExLayer::Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	return ConnectNext(lpSockAddr, nSockAddrLen);
}

int CAsyncSocketExLayer::SendNext(const void *lpBuf, int nBufLen, int nFlags /*=0*/)
{
	if (m_nCriticalError)
	{
		WSASetLastError(m_nCriticalError);
		return SOCKET_ERROR;
	}
	else if (GetLayerState()==LAYERSTATE_NOTSOCK)
	{
		WSASetLastError(WSAENOTSOCK);
		return SOCKET_ERROR;
	}
	else if (GetLayerState()==LAYERSTATE_UNCONNECTED || GetLayerState()==LAYERSTATE_CONNECTING || GetLayerState()==LAYERSTATE_LISTENING)
	{
		WSASetLastError(WSAENOTCONN);
		return SOCKET_ERROR;
	}

	if (!m_pNextLayer)
	{
		ASSERT(m_pOwnerSocket);
		return send(m_pOwnerSocket->GetSocketHandle(), (LPSTR)lpBuf, nBufLen, nFlags);
	}
	else
		return m_pNextLayer->Send(lpBuf, nBufLen, nFlags);
}

int CAsyncSocketExLayer::ReceiveNext(void *lpBuf, int nBufLen, int nFlags /*=0*/)
{
	if (m_nCriticalError)
	{
		WSASetLastError(m_nCriticalError);
		return SOCKET_ERROR;
	}
	else if (GetLayerState()==LAYERSTATE_NOTSOCK)
	{
		WSASetLastError(WSAENOTSOCK);
		return SOCKET_ERROR;
	}
	else if (GetLayerState()==LAYERSTATE_UNCONNECTED || GetLayerState()==LAYERSTATE_CONNECTING || GetLayerState()==LAYERSTATE_LISTENING)
	{
		WSASetLastError(WSAENOTCONN);
		return SOCKET_ERROR;
	}

	if (!m_pNextLayer)
	{
		ASSERT(m_pOwnerSocket);
		return recv(m_pOwnerSocket->GetSocketHandle(), (LPSTR)lpBuf, nBufLen, nFlags);
	}
	else
		return m_pNextLayer->Receive(lpBuf, nBufLen, nFlags);
}

BOOL CAsyncSocketExLayer::ConnectNext(LPCSTR lpszHostAddress, UINT nHostPort)
{
	ASSERT(lpszHostAddress != NULL);
	ASSERT(GetLayerState() == LAYERSTATE_UNCONNECTED);
	ASSERT(m_pOwnerSocket);

	BOOL res;
	if (m_pNextLayer)
		res = m_pNextLayer->Connect(lpszHostAddress, nHostPort);
	else
	{
		SOCKADDR_IN sockAddr = {0};

		sockAddr.sin_addr.s_addr = inet_addr(lpszHostAddress);
		if (sockAddr.sin_addr.s_addr == INADDR_NONE)
		{
			LPHOSTENT lphost = gethostbyname(lpszHostAddress);

			if (lphost == NULL)
			{
				WSASetLastError(WSAEINVAL);
				return FALSE;
			}
			sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
		}
		sockAddr.sin_family = AF_INET;
		sockAddr.sin_port = fast_htons((u_short)nHostPort);
		res = (connect(m_pOwnerSocket->GetSocketHandle(), (SOCKADDR*)&sockAddr, sizeof(sockAddr)) != SOCKET_ERROR);
	}

	if (res || WSAGetLastError() == WSAEWOULDBLOCK)
		SetLayerState(LAYERSTATE_CONNECTING);

	return res;
}

BOOL CAsyncSocketExLayer::ConnectNext(const SOCKADDR* lpSockAddr, int nSockAddrLen)
{
	ASSERT(GetLayerState() == LAYERSTATE_UNCONNECTED);
	ASSERT(m_pOwnerSocket);

	BOOL res;
	if (m_pNextLayer)
		res = m_pNextLayer->Connect(lpSockAddr, nSockAddrLen);
	else
		res = (connect(m_pOwnerSocket->GetSocketHandle(), lpSockAddr, nSockAddrLen) != SOCKET_ERROR);

	if (res || WSAGetLastError() == WSAEWOULDBLOCK)
		SetLayerState(LAYERSTATE_CONNECTING);

	return res;
}

//Gets the address of the peer socket to which the socket is connected
#ifdef _AFX

BOOL CAsyncSocketExLayer::GetPeerName(CString& rPeerAddress, UINT& rPeerPort)
{
	return GetPeerNameNext(rPeerAddress, rPeerPort);
}

BOOL CAsyncSocketExLayer::GetPeerNameNext(CString& rPeerAddress, UINT& rPeerPort)
{
	if (m_pNextLayer)
		return m_pNextLayer->GetPeerName(rPeerAddress, rPeerPort);
	else
	{
		ASSERT(m_pOwnerSocket);
		SOCKADDR_IN sockAddr = {0};

		int nSockAddrLen = sizeof(sockAddr);

		if (!getpeername(m_pOwnerSocket->GetSocketHandle(), (SOCKADDR*)&sockAddr, &nSockAddrLen))
		{
			rPeerPort = fast_ntohs(sockAddr.sin_port);
			ipstr(&rPeerAddress, sockAddr.sin_addr);
			return TRUE;
		}
		else
			return FALSE;
	}
}

#endif //_AFX

BOOL CAsyncSocketExLayer::GetPeerName( SOCKADDR* lpSockAddr, int* lpSockAddrLen )
{
	return GetPeerNameNext(lpSockAddr, lpSockAddrLen);
}

BOOL CAsyncSocketExLayer::GetPeerNameNext( SOCKADDR* lpSockAddr, int* lpSockAddrLen )
{
	if (m_pNextLayer)
		return m_pNextLayer->GetPeerName(lpSockAddr, lpSockAddrLen);
	else
	{
		ASSERT(m_pOwnerSocket);
		if ( !getpeername(m_pOwnerSocket->GetSocketHandle(), lpSockAddr, lpSockAddrLen) )
			return TRUE;
		else
			return FALSE;
	}
}

void CAsyncSocketExLayer::Init(CAsyncSocketExLayer *pPrevLayer, CAsyncSocketEx *pOwnerSocket)
{
	ASSERT(pOwnerSocket);
	m_pPrevLayer=pPrevLayer;
	m_pOwnerSocket=pOwnerSocket;
	m_pNextLayer=0;
}

int CAsyncSocketExLayer::GetLayerState()
{
	return m_nLayerState;
}

void CAsyncSocketExLayer::CallEvent(int nEvent, int nErrorCode)
{
	if (m_nCriticalError)
		return;
	m_nCriticalError=nErrorCode;
	switch (nEvent)
	{
	case FD_READ:
	case FD_FORCEREAD:
		if (GetLayerState()==LAYERSTATE_CONNECTED)
		{
			if (nErrorCode)
				SetLayerState(LAYERSTATE_ABORTED);
			OnReceive(nErrorCode);
		}
		break;
	case FD_WRITE:
		if (GetLayerState()==LAYERSTATE_CONNECTED)
		{
			if (nErrorCode)
				SetLayerState(LAYERSTATE_ABORTED);
			OnSend(nErrorCode);
		}
		break;
	case FD_CONNECT:
		if (GetLayerState()==LAYERSTATE_CONNECTING)
		{
			if (!nErrorCode)
				SetLayerState(LAYERSTATE_CONNECTED);
			else
				SetLayerState(LAYERSTATE_ABORTED);
			OnConnect(nErrorCode);
		}
		break;
	case FD_ACCEPT:
		if (GetLayerState()==LAYERSTATE_LISTENING)
		{
			if (!nErrorCode)
				SetLayerState(LAYERSTATE_CONNECTED);
			else
				SetLayerState(LAYERSTATE_ABORTED);
			OnAccept(nErrorCode);
		}
		break;
	case FD_CLOSE:
		if (GetLayerState()==LAYERSTATE_CONNECTED)
		{
			if (nErrorCode)
				SetLayerState(LAYERSTATE_ABORTED);
			else
				SetLayerState(LAYERSTATE_CLOSED);
			OnClose(nErrorCode);
		}
		break;
	}
}

BOOL CAsyncSocketExLayer::Create(UINT nSocketPort, int nSocketType, long lEvent, LPCSTR lpszSocketAddress)
{
	return CreateNext(nSocketPort, nSocketType, lEvent, lpszSocketAddress);
}

BOOL CAsyncSocketExLayer::CreateNext(UINT nSocketPort, int nSocketType, long lEvent, LPCSTR lpszSocketAddress)
{
	ASSERT(GetLayerState() == LAYERSTATE_NOTSOCK);
	BOOL res = FALSE;
	if (m_pNextLayer)
		res = m_pNextLayer->Create(nSocketPort, nSocketType, lEvent, lpszSocketAddress);
	else
	{
		SOCKET hSocket=socket(AF_INET, nSocketType, 0);
		if (hSocket==INVALID_SOCKET)
			res=FALSE;
		m_pOwnerSocket->m_SocketData.hSocket=hSocket;
		m_pOwnerSocket->AttachHandle(hSocket);
		if (!m_pOwnerSocket->AsyncSelect(lEvent))
		{
			m_pOwnerSocket->Close();
			res=FALSE;
		}
		if (m_pOwnerSocket->m_pFirstLayer)
		{
			if (WSAAsyncSelect(m_pOwnerSocket->m_SocketData.hSocket, m_pOwnerSocket->GetHelperWindowHandle(), m_pOwnerSocket->m_SocketData.nSocketIndex+WM_SOCKETEX_NOTIFY, FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE) )
			{
				m_pOwnerSocket->Close();
				res=FALSE;
			}
		}
		if (!m_pOwnerSocket->Bind(nSocketPort, lpszSocketAddress))
		{
			m_pOwnerSocket->Close();
			res=FALSE;
		}
		res=TRUE;
	}
	if (res)
		SetLayerState(LAYERSTATE_UNCONNECTED);
	return res;
}

void CAsyncSocketExLayer::SetLayerState(int nLayerState)
{
	ASSERT(m_pOwnerSocket);
	int nOldLayerState = GetLayerState();
	m_nLayerState = nLayerState;
	if (nOldLayerState != nLayerState)
		DoLayerCallback(LAYERCALLBACK_STATECHANGE, GetLayerState(), nOldLayerState);
}

int CAsyncSocketExLayer::DoLayerCallback(int nType, int nCode, WPARAM wParam, LPARAM lParam)
{
	ASSERT(m_pOwnerSocket);

	int nError = WSAGetLastError();
	int res = m_pOwnerSocket->OnLayerCallback(this, nType, nCode, wParam, lParam);

	WSASetLastError(nError);

	return res;
}

BOOL CAsyncSocketExLayer::Listen(int nConnectionBacklog)
{
	return ListenNext( nConnectionBacklog);
}

BOOL CAsyncSocketExLayer::ListenNext(int nConnectionBacklog)
{
	ASSERT(GetLayerState() == LAYERSTATE_UNCONNECTED);
	BOOL res;
	if (m_pNextLayer)
		res=m_pNextLayer->Listen(nConnectionBacklog);
	else
		res=listen(m_pOwnerSocket->GetSocketHandle(), nConnectionBacklog);
	if (res)
	{
		SetLayerState(LAYERSTATE_LISTENING);
	}
	return res;
}

BOOL CAsyncSocketExLayer::Accept( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr /*=NULL*/, int* lpSockAddrLen /*=NULL*/ )
{
	return AcceptNext(rConnectedSocket, lpSockAddr, lpSockAddrLen);
}

BOOL CAsyncSocketExLayer::AcceptNext( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr /*=NULL*/, int* lpSockAddrLen /*=NULL*/ )
{
	ASSERT(GetLayerState()==LAYERSTATE_LISTENING);
	BOOL res;
	if (m_pNextLayer)
		res=m_pNextLayer->Accept(rConnectedSocket, lpSockAddr, lpSockAddrLen);
	else
	{
		SOCKET hTemp = accept(m_pOwnerSocket->m_SocketData.hSocket, lpSockAddr, lpSockAddrLen);

		if (hTemp == INVALID_SOCKET)
			return FALSE;
		VERIFY(rConnectedSocket.InitAsyncSocketExInstance());
		rConnectedSocket.m_SocketData.hSocket=hTemp;
		rConnectedSocket.AttachHandle(hTemp);
	}
	return TRUE;
}

BOOL CAsyncSocketExLayer::ShutDown(int nHow /*=sends*/)
{
	return ShutDownNext(nHow);
}

BOOL CAsyncSocketExLayer::ShutDownNext(int nHow /*=sends*/)
{
	if (m_nCriticalError)
	{
		WSASetLastError(m_nCriticalError);
		return FALSE;
	}
	else if (GetLayerState()==LAYERSTATE_NOTSOCK)
	{
		WSASetLastError(WSAENOTSOCK);
		return FALSE;
	}
	else if (GetLayerState()==LAYERSTATE_UNCONNECTED || GetLayerState()==LAYERSTATE_CONNECTING || GetLayerState()==LAYERSTATE_LISTENING)
	{
		WSASetLastError(WSAENOTCONN);
		return FALSE;
	}

	if (!m_pNextLayer)
	{
		ASSERT(m_pOwnerSocket);
		return shutdown(m_pOwnerSocket->GetSocketHandle(), nHow);
	}
	else
		return m_pNextLayer->ShutDownNext(nHow);
}@


1.11
log
@Fixed missed initialization for m_pPrevLayer member -- hard to say how severe it was.
@
text
@d353 1
a353 1
			rPeerPort = ntohs(sockAddr.sin_port);
@


1.10
log
@Faster (intrinsic) htonl and htons implementation.
@
text
@d81 3
a83 2
	m_pOwnerSocket=0;
	m_pNextLayer=0;
d85 2
a86 2
	m_nLayerState=LAYERSTATE_NOTSOCK;
	m_nCriticalError=0;
@


1.9
log
@Unicode preparations.
@
text
@d304 1
a304 1
		sockAddr.sin_port = htons((u_short)nHostPort);
@


1.8
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues.
@
text
@d353 1
a353 1
			rPeerAddress = inet_ntoa(sockAddr.sin_addr);
@


1.7
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d30 1
a30 1
sockets within one thread. When the window recieve WM_SOCKET_NOTIFY, wParam
a118 1

d167 1
a167 1
	if (m_pOwnerSocket->m_SocketData.hSocket==INVALID_SOCKET)
d170 1
a170 1
	if ( lEvent&FD_CONNECT)
d173 3
a175 3
		if (!nErrorCode)
			ASSERT(bPassThrough && GetLayerState()==LAYERSTATE_CONNECTED);
		else if (nErrorCode)
d178 1
a178 1
			m_nCriticalError=nErrorCode;
d181 1
a181 1
	else if ( lEvent&FD_CLOSE && !nErrorCode)
d185 1
a185 1
	else if ( lEvent&FD_CLOSE && nErrorCode)
d188 1
a188 1
		m_nCriticalError=nErrorCode;
d192 5
a196 5
	ASSERT(m_pOwnerSocket->m_SocketData.nSocketIndex!=-1);
	t_LayerNotifyMsg *pMsg=new t_LayerNotifyMsg;
	pMsg->lEvent = ( lEvent % 0xFFFF ) + ( nErrorCode << 16);
	pMsg->pLayer=bPassThrough?m_pPrevLayer:this;
	BOOL res=PostMessage(m_pOwnerSocket->GetHelperWindowHandle(), WM_SOCKETEX_TRIGGER, (WPARAM)m_pOwnerSocket, (LPARAM)pMsg);
d214 1
a214 1
BOOL CAsyncSocketExLayer::Connect(LPCTSTR lpszHostAddress, UINT nHostPort)
d219 1
a219 1
BOOL CAsyncSocketExLayer::Connect( const SOCKADDR* lpSockAddr, int nSockAddrLen )
d278 1
a278 1
BOOL CAsyncSocketExLayer::ConnectNext(LPCTSTR lpszHostAddress, UINT nHostPort)
d280 2
a281 1
	ASSERT(GetLayerState()==LAYERSTATE_UNCONNECTED);
d283 1
d289 1
a289 10
		USES_CONVERSION;

		ASSERT(lpszHostAddress != NULL);

		SOCKADDR_IN sockAddr;
		memzero(&sockAddr, sizeof(sockAddr));

		LPSTR lpszAscii = T2A((LPTSTR)lpszHostAddress);
		sockAddr.sin_family = AF_INET;
		sockAddr.sin_addr.s_addr = inet_addr(lpszAscii);
d291 1
d294 3
a296 5
			LPHOSTENT lphost;
			lphost = gethostbyname(lpszAscii);
			if (lphost != NULL)
				sockAddr.sin_addr.s_addr = ((LPIN_ADDR)lphost->h_addr)->s_addr;
			else
d299 1
a299 1
				res = FALSE;
d301 1
d303 1
a303 1

d305 1
a305 2

		res = ( SOCKET_ERROR!=connect(m_pOwnerSocket->GetSocketHandle(), (SOCKADDR*)&sockAddr, sizeof(sockAddr)) );
d308 1
a308 2
	if (res || WSAGetLastError()==WSAEWOULDBLOCK)
	{
d310 1
a310 1
	}
d314 1
a314 1
BOOL CAsyncSocketExLayer::ConnectNext( const SOCKADDR* lpSockAddr, int nSockAddrLen )
d316 1
a316 1
	ASSERT(GetLayerState()==LAYERSTATE_UNCONNECTED);
d318 1
d321 1
a321 1
		res=m_pNextLayer->Connect(lpSockAddr, nSockAddrLen);
d323 1
a323 1
		res = (SOCKET_ERROR!=connect(m_pOwnerSocket->GetSocketHandle(), lpSockAddr, nSockAddrLen));
d325 1
a325 1
	if (res || WSAGetLastError()==WSAEWOULDBLOCK)
d327 1
d334 1
a334 1
BOOL CAsyncSocketExLayer::GetPeerName( CString& rPeerAddress, UINT& rPeerPort )
d339 1
a339 1
BOOL CAsyncSocketExLayer::GetPeerNameNext( CString& rPeerAddress, UINT& rPeerPort )
d346 1
a346 2
		SOCKADDR_IN sockAddr;
		memzero(&sockAddr, sizeof(sockAddr));
d452 1
a452 3
//Creates a socket
BOOL CAsyncSocketExLayer::Create(UINT nSocketPort, int nSocketType,
			long lEvent, LPCTSTR lpszSocketAddress)
d457 1
a457 1
BOOL CAsyncSocketExLayer::CreateNext(UINT nSocketPort, int nSocketType, long lEvent, LPCTSTR lpszSocketAddress)
d459 2
a460 2
	ASSERT(GetLayerState()==LAYERSTATE_NOTSOCK);
	BOOL res=FALSE;
d462 1
a462 1
		res=m_pNextLayer->Create(nSocketPort, nSocketType, lEvent, lpszSocketAddress);
d498 3
a500 3
	int nOldLayerState=GetLayerState();
	m_nLayerState=nLayerState;
	if (nOldLayerState!=nLayerState)
d504 1
a504 1
int CAsyncSocketExLayer::DoLayerCallback(int nType, int nParam1, int nParam2)
d508 2
a509 3
	int nError=WSAGetLastError();

	int res = m_pOwnerSocket->OnLayerCallback(this, nType, nParam1, nParam2);
a513 1

d516 1
a516 1
BOOL CAsyncSocketExLayer::Listen( int nConnectionBacklog)
d521 1
a521 1
BOOL CAsyncSocketExLayer::ListenNext( int nConnectionBacklog)
d523 1
a523 1
	ASSERT(GetLayerState()==LAYERSTATE_UNCONNECTED);
@


1.6
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d293 1
a293 1
		memset2(&sockAddr,0,sizeof(sockAddr));
d355 1
a355 1
		memset2(&sockAddr, 0, sizeof(sockAddr));
@


1.5
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d195 1
a195 1
	pMsg->lEvent = ( lEvent % 0xffff ) + ( nErrorCode << 16);
@


1.4
log
@Katsyonak update
@
text
@a64 1

d66 1
d293 1
a293 1
		memset(&sockAddr,0,sizeof(sockAddr));
d355 1
a355 1
		memset(&sockAddr, 0, sizeof(sockAddr));
@


1.3
log
@Official code merge (katsyonak)
@
text
@d8 3
a10 3
CAsyncSocketEx is a replacement for the MFC class CAsyncSocket. 
This class was written because CAsyncSocket is not the fastest WinSock 
wrapper and it's very hard to add new functionality to CAsyncSocket 
d27 1
a27 1
CAsyncSocket, a window is created. CAsyncSocket calls WSAAsyncSelect with 
d34 1
a34 1
a different message to WSAAsyncSelect for each socket. When a message in 
d37 1
a37 1
As you can see, CAsyncSocketEx uses the helper window in a more efficient 
d41 1
a41 1
Please note that the changes do not affect the raw data throughput rate, 
d170 1
a170 1
	
d197 1
a197 1
	BOOL res=PostMessage(m_pOwnerSocket->GetHelperWindowHandle(), WM_USER, (WPARAM)m_pOwnerSocket, (LPARAM)pMsg);
d289 1
a289 1
		
d291 1
a291 1
		
d294 1
a294 1
		
d298 1
a298 1
		
d311 1
a311 1
		
d313 1
a313 1
		
d316 1
a316 1
	
d320 1
a320 1
	}	
d356 1
a356 1
		
d426 1
a426 1
			}
d450 1
a450 1
		{	
d518 1
a518 1
	
d520 3
a522 3
	
	int res=m_pOwnerSocket->OnLayerCallback(this, nType, nParam1, nParam2);
	
d524 1
a524 1
	
d526 1
a526 1
	
d563 1
a563 1
	
@


1.2
log
@Formatting, comments, and name changes.
@
text
@d62 2
a63 1
*/#include "stdafx.h"
a73 2
#define WM_SOCKETEX_NOTIFY (WM_USER+1)

a346 5
BOOL CAsyncSocketExLayer::GetPeerName( ULONG& rPeerIP, UINT& rPeerPort )
{
	return GetPeerNameNext(rPeerIP, rPeerPort);
}

a369 23
BOOL CAsyncSocketExLayer::GetPeerNameNext( ULONG& rPeerIP, UINT& rPeerPort )
{
	if (m_pNextLayer)
		return m_pNextLayer->GetPeerName(rPeerIP, rPeerPort);
	else
	{
		ASSERT(m_pOwnerSocket);
		SOCKADDR_IN sockAddr;
		memset(&sockAddr, 0, sizeof(sockAddr));
		
		int nSockAddrLen = sizeof(sockAddr);

		if (!getpeername(m_pOwnerSocket->GetSocketHandle(), (SOCKADDR*)&sockAddr, &nSockAddrLen))
		{
			rPeerPort = ntohs(sockAddr.sin_port);
			rPeerIP = sockAddr.sin_addr.S_un.S_addr;
			return TRUE;
		}
		else
			return FALSE;
	}
}

a423 1
			{
d425 1
a425 1
				OnSend(nErrorCode);
a426 1
		}
d571 32
@


1.1
log
@Maverick's proxy support
@
text
@d85 1
a85 1
	m_nLayerState=notsock;
d176 1
a176 1
			ASSERT(bPassThrough && GetLayerState()==connected);
d179 1
a179 1
			SetLayerState(aborted);
d185 1
a185 1
		SetLayerState(closed);
d189 1
a189 1
		SetLayerState(aborted);
d211 1
a211 1
	SetLayerState(notsock);
d233 1
a233 1
	else if (GetLayerState()==notsock)
d238 1
a238 1
	else if (GetLayerState()==unconnected || GetLayerState()==connecting || GetLayerState()==listening)
d260 1
a260 1
	else if (GetLayerState()==notsock)
d265 1
a265 1
	else if (GetLayerState()==unconnected || GetLayerState()==connecting || GetLayerState()==listening)
d282 1
a282 1
	ASSERT(GetLayerState()==unconnected);
d320 1
a320 1
		SetLayerState(connecting);
d327 1
a327 1
	ASSERT(GetLayerState()==unconnected);
d336 1
a336 1
		SetLayerState(connecting);
d442 1
a442 1
		if (GetLayerState()==connected)
d445 1
a445 1
				SetLayerState(aborted);
d450 1
a450 1
		if (GetLayerState()==connected)
d454 1
a454 1
				SetLayerState(aborted);
d460 1
a460 1
		if (GetLayerState()==connecting)
d463 1
a463 1
				SetLayerState(connected);
d465 1
a465 1
				SetLayerState(aborted);
d470 1
a470 1
		if (GetLayerState()==listening)
d473 1
a473 1
				SetLayerState(connected);
d475 1
a475 1
				SetLayerState(aborted);
d480 1
a480 1
		if (GetLayerState()==connected)
d483 1
a483 1
				SetLayerState(aborted);
d485 1
a485 1
				SetLayerState(closed);
d501 1
a501 1
	ASSERT(GetLayerState()==notsock);
d533 1
a533 1
		SetLayerState(unconnected);
d567 1
a567 1
	ASSERT(GetLayerState()==unconnected);
d575 1
a575 1
		SetLayerState(listening);
d587 1
a587 1
	ASSERT(GetLayerState()==listening);
@


1.1.2.1
log
@updating this branch...
@
text
@@

