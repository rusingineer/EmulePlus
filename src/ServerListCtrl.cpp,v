head	1.153;
access;
symbols
	PublicRelease_1_2e:1.148
	Interim_Release_1-2e_RC1:1.147
	PublicRelease_1_2d:1.141
	Interim_Release_1-2d_RC1:1.140
	Interim_Release_1-2d_beta1:1.137
	PublicRelease_1_2c:1.132
	Interim_Release_1-2c_RC1:1.132
	Interim_Release_1-2c_beta1:1.130
	PublicRelease_1_2b:1.130
	Interim_Release_1-2b_RC1:1.130
	PublicRelease_1_2a:1.130
	Interim_Release_1-2a_RC1:1.130
	Interim_Release_1-2a_beta2:1.128
	Interim_Release_1-2a_beta1:1.128
	PublicRelease_1_2:1.127
	Interim_Release_1-2_RC1:1.127
	Interim_Release_1-2_beta1:1.127
	PublicRelease_1_1g:1.126
	Interim_Release_1-1g_RC3:1.126
	Interim_Release_1-1g_RC2:1.126
	Interim_Release_1-1g_RC1:1.126
	Interim_Release_1-1g_beta2:1.124
	Interim_Release_1-1g_beta1:1.123
	PublicRelease_1_1f:1.121
	Interim_Release_1-1f_RC1:1.121
	PublicRelease_1_1e:1.121
	Interim_Release_1-1e_RC2:1.121
	Interim_Release_1-1e_RC1:1.121
	Interim_Release_1-1e_beta1:1.120
	PublicRelease_1_1d:1.120
	Interim_Release_1-1d_RC1:1.120
	PublicRelease_1_1c:1.119
	Interim_Release_1-1c_RC1:1.118
	Interim_Release_1-1c_beta2:1.117
	Interim_Release_1-1c_beta1:1.115
	PublicRelease_1_1b:1.112
	Interim_Release_1-1b_RC1:1.112
	PublicRelease_1_1a:1.110
	Interim_Release_1-1a_RC2:1.110
	Interim_Release_1-1a_RC1:1.110
	Interim_Release_1-1a_beta2:1.110
	Interim_Release_1-1a_beta1:1.110
	PublicRelease_1_1:1.109
	Interim_Release_1-1_beta1:1.109
	PublicRelease_1o:1.108
	Interim_Release_1o_RC1:1.108
	Interim_Release_1o_beta1:1.108
	PublicRelease_1n:1.107
	Interim_Release_1n_RC2:1.107
	Interim_Release_1n_RC1:1.107
	Interim_Release_1n_beta2:1.107
	Interim_Release_1n_beta1:1.106
	PublicRelease_1m:1.106
	Interim_Release_1m_beta1:1.106
	PublicRelease_1l:1.105
	Interim_Release_1l_RC3:1.105
	Interim_Release_1l_RC2:1.104
	Interim_Release_1l_RC1:1.103
	Interim_Release_1l_beta2:1.99
	Interim_Release_1l_beta1:1.97
	PublicRelease_1k:1.81
	Interim_Release_1k_RC4:1.81
	Interim_1k_RC3:1.81
	Interim_1k_RC2:1.81
	Interim_Release_1k_RC1:1.78
	Interim_Release_1k_beta5:1.77
	Intrerim_Release_1k_beta4:1.77
	Interim_Release_1k_beta1:1.74
	PublicRelease_1j:1.70
	Interim_Release_1J_RC3:1.70
	Interim_Release_1j_RC3:1.70
	Interim_Release_1j_RC2:1.68
	Interim_Release_1j_RC1:1.68
	Interim_Release_1j_beta2:1.68
	Interim_Release_1j_beta1:1.68
	PublicRelease_1i:1.63
	Interim_Release_1i_RC6:1.63
	Interim_Release_1i_RC3:1.63
	Interim_Release_1i_RC2:1.63
	Interim_Release_1i_RC1:1.62
	Interim_Release_1i_beta3:1.61
	Interim_Release_1i_beta2:1.54
	Interim_Release_1i_beta1:1.46
	PublicRelease_1h:1.41
	Interim_Release_1h_rc2:1.40
	Interim_Release_1h_RC1:1.40
	Interim_Release_1h_beta2:1.39
	Interim_Release_1h_beta1_now:1.36
	Interim_Release_1h_beta1:1.36
	PublicRelease_1g:1.34
	Interim_Release_1g_RC6_Final:1.34
	Interim_Release_1g_RC6:1.33
	Interim_Release_1g_RC5:1.32
	Interim_Release_1g_RC4:1.32
	Interim_Release_1g_RC3:1.32
	Interim_Release_1g_beta2:1.29
	Interim_Release_1g_beta1:1.25
	Interim_Release_1f_RC4:1.23
	Interim_Release_1f_RC3:1.23
	Interim_Release_1f_RC2:1.22
	Interim_Release_1f_RC:1.21
	Interim_Release_1f_beta2:1.20
	Interim_Release_1f_beta1:1.19
	PublicRelease_1e:1.19
	Interim_Release_1e_RC2:1.19
	Interim_Release_1e_RC:1.19
	Interim_Release_1e_beta3:1.19
	Interim_Release_1e_beta2:1.19
	Interim_Release_1e_beta2_before_kuchin:1.19
	Interim_Release_1e_beta1:1.18
	PublicRelease_1c:1.17
	featurestest:1.17.0.2
	Interim_Release_1c_RC:1.17
	Interim_Release_1c_beta2:1.17
	Interim_Release_1c_beta1:1.17
	threaded_downloadqueue:1.16.0.2
	PublicRelease_1b:1.13
	Interim_Release_1b_beta2:1.13
	Interim_Release_1b_beta1:1.13
	proxydeadlake:1.13.0.2
	PublicRelease_1a:1.12
	Interim_Release_1a_beta2:1.12
	BerkeleyDb:1.10.0.2
	Interim_Release_1a_beta1:1.8
	PublicRelease_1:1.8
	goldfish:1.8
	eMulePlus_1_RC2:1.7
	eMulePlus_26b_1RC1:1.7
	PreRelease_26b_i0e:1.7
	before_26d_merge:1.5
	Interim_Release_26b_i0d:1.4
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.153
date	2009.10.30.01.59.03;	author aw3;	state Exp;
branches;
next	1.152;

1.152
date	2009.10.28.03.27.25;	author aw3;	state Exp;
branches;
next	1.151;

1.151
date	2009.10.22.05.36.24;	author aw3;	state Exp;
branches;
next	1.150;

1.150
date	2009.06.28.04.21.11;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2009.05.14.03.14.15;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2009.04.07.03.57.24;	author aw3;	state Exp;
branches;
next	1.147;

1.147
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.146;

1.146
date	2008.11.03.05.06.39;	author aw3;	state Exp;
branches;
next	1.145;

1.145
date	2008.09.02.02.46.12;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2008.07.17.05.01.22;	author aw3;	state Exp;
branches;
next	1.143;

1.143
date	2008.05.29.03.00.37;	author aw3;	state Exp;
branches;
next	1.142;

1.142
date	2008.05.25.02.00.56;	author aw3;	state Exp;
branches;
next	1.141;

1.141
date	2008.05.14.18.50.13;	author eklmn;	state Exp;
branches;
next	1.140;

1.140
date	2008.04.05.20.22.50;	author eklmn;	state Exp;
branches;
next	1.139;

1.139
date	2008.04.05.09.49.09;	author eklmn;	state Exp;
branches;
next	1.138;

1.138
date	2008.03.14.01.02.07;	author aw3;	state Exp;
branches;
next	1.137;

1.137
date	2008.01.23.05.10.47;	author aw3;	state Exp;
branches;
next	1.136;

1.136
date	2008.01.01.10.34.33;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2007.12.29.05.49.50;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2007.12.28.22.13.53;	author eklmn;	state Exp;
branches;
next	1.133;

1.133
date	2007.10.24.19.08.33;	author fuxie-dk;	state Exp;
branches;
next	1.132;

1.132
date	2007.07.01.05.30.34;	author aw3;	state Exp;
branches;
next	1.131;

1.131
date	2007.04.18.00.23.36;	author aw3;	state Exp;
branches;
next	1.130;

1.130
date	2006.08.06.13.56.12;	author aw3;	state Exp;
branches;
next	1.129;

1.129
date	2006.07.16.23.15.55;	author kush_eplus;	state Exp;
branches;
next	1.128;

1.128
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.126;

1.126
date	2005.11.27.22.11.50;	author eklmn;	state Exp;
branches;
next	1.125;

1.125
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.124;

1.124
date	2005.11.07.02.19.07;	author aw3;	state Exp;
branches;
next	1.123;

1.123
date	2005.08.21.03.03.51;	author aw3;	state Exp;
branches;
next	1.122;

1.122
date	2005.08.20.04.28.34;	author aw3;	state Exp;
branches;
next	1.121;

1.121
date	2005.06.13.04.12.54;	author aw3;	state Exp;
branches;
next	1.120;

1.120
date	2005.03.07.03.30.09;	author aw3;	state Exp;
branches;
next	1.119;

1.119
date	2005.02.26.22.41.55;	author aw3;	state Exp;
branches;
next	1.118;

1.118
date	2005.02.22.22.30.24;	author netwolf1;	state Exp;
branches;
next	1.117;

1.117
date	2005.02.02.23.44.52;	author aw3;	state Exp;
branches;
next	1.116;

1.116
date	2005.02.02.07.05.57;	author aw3;	state Exp;
branches;
next	1.115;

1.115
date	2005.01.22.18.23.37;	author aw3;	state Exp;
branches;
next	1.114;

1.114
date	2005.01.19.21.10.50;	author netwolf1;	state Exp;
branches;
next	1.113;

1.113
date	2005.01.14.14.33.42;	author kush_eplus;	state Exp;
branches;
next	1.112;

1.112
date	2004.12.16.21.06.23;	author aw3;	state Exp;
branches;
next	1.111;

1.111
date	2004.12.16.19.34.16;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2004.10.26.21.14.14;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2004.10.06.19.18.30;	author aw3;	state Exp;
branches;
next	1.108;

1.108
date	2004.09.13.04.34.40;	author aw3;	state Exp;
branches;
next	1.107;

1.107
date	2004.07.22.23.45.17;	author aw3;	state Exp;
branches;
next	1.106;

1.106
date	2004.06.17.23.46.14;	author aw3;	state Exp;
branches;
next	1.105;

1.105
date	2004.06.03.05.20.53;	author aw3;	state Exp;
branches;
next	1.104;

1.104
date	2004.05.27.14.12.36;	author katsyonak;	state Exp;
branches;
next	1.103;

1.103
date	2004.05.26.13.37.36;	author dongato;	state Exp;
branches;
next	1.102;

1.102
date	2004.05.25.18.41.07;	author dongato;	state Exp;
branches;
next	1.101;

1.101
date	2004.05.25.10.28.43;	author dongato;	state Exp;
branches;
next	1.100;

1.100
date	2004.05.24.21.12.16;	author katsyonak;	state Exp;
branches;
next	1.99;

1.99
date	2004.05.19.10.14.29;	author netwolf1;	state Exp;
branches;
next	1.98;

1.98
date	2004.05.07.10.42.52;	author dongato;	state Exp;
branches;
next	1.97;

1.97
date	2004.05.06.01.39.08;	author katsyonak;	state Exp;
branches;
next	1.96;

1.96
date	2004.05.05.17.17.43;	author netwolf1;	state Exp;
branches;
next	1.95;

1.95
date	2004.05.05.14.39.27;	author katsyonak;	state Exp;
branches;
next	1.94;

1.94
date	2004.05.05.13.48.03;	author katsyonak;	state Exp;
branches;
next	1.93;

1.93
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.92;

1.92
date	2004.05.04.06.04.22;	author aw3;	state Exp;
branches;
next	1.91;

1.91
date	2004.04.29.10.58.41;	author netwolf1;	state Exp;
branches;
next	1.90;

1.90
date	2004.04.25.11.58.00;	author katsyonak;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.25.08.33.01;	author dongato;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.24.12.26.31;	author katsyonak;	state Exp;
branches;
next	1.87;

1.87
date	2004.04.24.03.10.27;	author aw3;	state Exp;
branches;
next	1.86;

1.86
date	2004.04.23.22.13.54;	author katsyonak;	state Exp;
branches;
next	1.85;

1.85
date	2004.04.16.20.16.41;	author aw3;	state Exp;
branches;
next	1.84;

1.84
date	2004.04.12.00.33.59;	author aw3;	state Exp;
branches;
next	1.83;

1.83
date	2004.04.11.11.45.59;	author eklmn;	state Exp;
branches;
next	1.82;

1.82
date	2004.04.09.13.47.31;	author eklmn;	state Exp;
branches;
next	1.81;

1.81
date	2004.03.31.22.26.56;	author dropf;	state Exp;
branches;
next	1.80;

1.80
date	2004.03.30.21.03.20;	author aw3;	state Exp;
branches;
next	1.79;

1.79
date	2004.03.30.16.13.34;	author eklmn;	state Exp;
branches;
next	1.78;

1.78
date	2004.03.27.19.36.34;	author aw3;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.76;

1.76
date	2004.03.16.08.35.08;	author eklmn;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.23.03.33.17;	author aw3;	state Exp;
branches;
next	1.74;

1.74
date	2004.02.20.10.32.11;	author dongato;	state Exp;
branches;
next	1.73;

1.73
date	2004.02.19.18.27.56;	author dongato;	state Exp;
branches;
next	1.72;

1.72
date	2004.02.11.04.13.01;	author katsyonak;	state Exp;
branches;
next	1.71;

1.71
date	2004.01.26.18.10.58;	author dongato;	state Exp;
branches;
next	1.70;

1.70
date	2004.01.23.05.25.34;	author kush_eplus;	state Exp;
branches;
next	1.69;

1.69
date	2004.01.21.23.20.46;	author dongato;	state Exp;
branches;
next	1.68;

1.68
date	2003.12.16.18.19.55;	author kuchin;	state Exp;
branches;
next	1.67;

1.67
date	2003.12.16.14.02.46;	author dongato;	state Exp;
branches;
next	1.66;

1.66
date	2003.12.16.12.30.13;	author morevit;	state Exp;
branches;
next	1.65;

1.65
date	2003.12.11.10.44.40;	author kuchin;	state Exp;
branches;
next	1.64;

1.64
date	2003.12.10.17.14.14;	author kuchin;	state Exp;
branches;
next	1.63;

1.63
date	2003.11.06.08.00.48;	author eklmn;	state Exp;
branches;
next	1.62;

1.62
date	2003.11.04.18.48.47;	author eklmn;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.28.21.40.00;	author morevit;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.28.17.03.43;	author eklmn;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.28.11.56.13;	author eklmn;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.27.21.43.07;	author eklmn;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.26.16.45.11;	author kuchin;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.25.12.20.34;	author dongato;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.52;

1.52
date	2003.10.20.13.20.02;	author morevit;	state Exp;
branches;
next	1.51;

1.51
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.50;

1.50
date	2003.10.08.12.56.34;	author morevit;	state Exp;
branches;
next	1.49;

1.49
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.48;

1.48
date	2003.10.06.18.54.14;	author dongato;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.46;

1.46
date	2003.10.04.22.21.34;	author morevit;	state Exp;
branches;
next	1.45;

1.45
date	2003.10.03.23.18.49;	author morevit;	state Exp;
branches;
next	1.44;

1.44
date	2003.10.03.13.04.36;	author morevit;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.42;

1.42
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.41;

1.41
date	2003.09.16.16.34.38;	author kuchin;	state Exp;
branches;
next	1.40;

1.40
date	2003.09.08.17.55.36;	author kuchin;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.04.11.19.25;	author kuchin;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.31.16.49.55;	author dongato;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.27.09.27.12;	author kuchin;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.31.07.27.43;	author dongato;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.30.22.56.00;	author zegzav;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.20.12.11.24;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2003.07.13.09.39.18;	author eklmn;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.15.13.41.14;	author partyckip;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.15.09.09.28;	author partyckip;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.10.09.36.46;	author kuchin;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.09.11.57.42;	author kuchin;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.05.20.59.40;	author syrus77;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.04.19.57.48;	author partyckip;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.01.08.59.02;	author kuchin;	state Exp;
branches;
next	1.24;

1.24
date	2003.05.30.20.35.19;	author partyckip;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.20.20.46.32;	author netwolf1;	state Exp;
branches;
next	1.22;

1.22
date	2003.05.13.17.59.38;	author lord_kiron;	state Exp;
branches;
next	1.21;

1.21
date	2003.05.11.19.25.47;	author lord_kiron;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.08.16.22.20;	author partyckip;	state Exp;
branches;
next	1.19;

1.19
date	2003.04.19.09.59.59;	author partyckip;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.24.22.55.35;	author dongato;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.15.08.07.17;	author kuchin;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2003.03.14.18.13.14;	author cax2;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.14.16.24.21;	author partyckip;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.13.11.29.43;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.28.00.53.24;	author dongato;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.26.21.12.34;	author cax2;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.25.18.08.01;	author cax2;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.25.02.34.37;	author dongato;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2003.02.24.20.09.50;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.20.15.58.11;	author dongato;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.17.19.17.20;	author dongato;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.16.22.01.48;	author lord_kiron;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.13.18.43.15;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.26.20.51.20;	author pooz;	state Exp;
branches
	1.2.2.1
	1.2.4.1;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.25;	author cax2;	state Exp;
branches;
next	;

1.2.4.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.10.2.1
date	2003.02.28.22.44.56;	author obaldin;	state Exp;
branches;
next	;

1.17.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2003.03.23.07.41.48;	author recdvst;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.153
log
@Fixed a bunch of DynIP server related issues.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "ServerListCtrl.h"
#include "ServerList.h"
#include "server.h"
#include "TitleMenu.h"
#include "otherfunctions.h"
#include "IP2Country.h"
#include "NewServerDlg.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif
#include <share.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNAMIC(CServerListCtrl, CMuleListCtrl)

BEGIN_MESSAGE_MAP(CServerListCtrl, CMuleListCtrl)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMLdblclk)
	ON_WM_CONTEXTMENU()
	ON_WM_DESTROY()
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServerListCtrl::CServerListCtrl()
{
	SetGeneralPurposeFind(true);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerListCtrl::Init()
{
	static const uint16 s_auIconResID[] =
	{
		IDI_SMALLSERVER,
		IDI_SMALLSERVERSTATIC,
		IDI_SERVERCONNECTED,
		IDI_SERVERCONNECTEDSTATIC,
		IDI_SERVERCONNECTEDFAILED,
		IDI_SERVERCONNECTEDFAILEDSTATIC,
		IDI_SERVERFAILED,
		IDI_SERVERFAILEDSTATIC
	};
	static const uint16 s_auColHdr[][2] =
	{
		{ LVCFMT_LEFT,  150 },	// SRVCOL_SERVERNAME
		{ LVCFMT_LEFT,  140 },	// SRVCOL_SERVERIP
		{ LVCFMT_LEFT,  150 },	// SRVCOL_DESCRIPTION
		{ LVCFMT_RIGHT,  50 },	// SRVCOL_PING
		{ LVCFMT_RIGHT,  50 },	// SRVCOL_NUMUSERS
		{ LVCFMT_RIGHT,  50 },	// SRVCOL_NUMFILES
		{ LVCFMT_LEFT,   60 },	// SRVCOL_PRIORITY
		{ LVCFMT_RIGHT,  50 },	// SRVCOL_FAILEDCOUNT
		{ LVCFMT_LEFT,   50 },	// SRVCOL_STATIC
		{ LVCFMT_RIGHT, 100 },	// SRVCOL_FILELIMIT
		{ LVCFMT_LEFT,  150 },	// SRVCOL_SOFTWAREVER
		{ LVCFMT_LEFT,  150 },	// SRVCOL_COUNTRY
		{ LVCFMT_RIGHT,  60 }	// SRVCOL_LOWIDUSERS
	};

	ModifyStyle(LVS_SINGLESEL, 0);

//	Set Imagelist
	m_imageList.Create(16, 16, g_App.m_iDfltImageListColorFlags | ILC_MASK, ARRSIZE(s_auIconResID), 0);
	m_imageList.SetBkColor(CLR_NONE);
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ARRSIZE(s_auIconResID));
	SetImageList(&m_imageList, LVSIL_SMALL);

	SetExtendedStyle(LVS_EX_FULLROWSELECT);

	for (unsigned ui = 0; ui < ARRSIZE(s_auColHdr); ui++)
		InsertColumn(ui, _T(""), static_cast<int>(s_auColHdr[ui][0]), static_cast<int>(s_auColHdr[ui][1]));

	LoadSettings(CPreferences::TABLE_SERVER);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServerListCtrl::~CServerListCtrl()
{}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::OnDestroy()
{
	m_imageList.DeleteImageList();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SortFirstInit() starts initial sorting after all initial information is added w/o sorting.
//	This is faster than adding every item with sorting rules.
void CServerListCtrl::SortFirstInit()
{
	static const int s_aiDoubleLevelCols[] = { SRVCOL_NUMUSERS, SRVCOL_FILELIMIT };

	SetSortProcedure(SortProc);
	SetDoubleLayerSort(s_aiDoubleLevelCols, ARRSIZE(s_aiDoubleLevelCols));
	if (g_App.m_pPrefs->DoUseSort())
		SortInit(g_App.m_pPrefs->GetServerSortCol());
	else
		SortInit(g_App.m_pPrefs->GetColumnSortCode(CPreferences::TABLE_SERVER));
	ShowFilesCount();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::Localize()
{
	static const uint16 s_auResTbl[] =
	{
		IDS_SL_SERVERNAME,			//SRVCOL_SERVERNAME
		IDS_IP,						//SRVCOL_SERVERIP
		IDS_DESCRIPTION,			//SRVCOL_DESCRIPTION
		IDS_PING,					//SRVCOL_PING
		IDS_UUSERS,					//SRVCOL_NUMUSERS
		IDS_FILES,					//SRVCOL_NUMFILES
		IDS_PRIORITY,				//SRVCOL_PRIORITY
		IDS_UFAILED,				//SRVCOL_FAILEDCOUNT
		IDS_STATICSERVER,			//SRVCOL_STATIC
		IDS_SERVER_SOFTHARDLIMIT,	//SRVCOL_FILELIMIT
		IDS_SERVER_VERSION,			//SRVCOL_SOFTWAREVER
		IDS_COUNTRY,				//SRVCOL_COUNTRY
		IDS_LOWIDUSERS				//SRVCOL_LOWIDUSERS
	};

	if (GetSafeHwnd())
	{
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
		CString		strRes;
		HDITEM		hdi;

		hdi.mask = HDI_TEXT;

		for (unsigned ui = 0; ui < ARRSIZE(s_auResTbl); ui++)
		{
			::GetResString(&strRes, static_cast<UINT>(s_auResTbl[ui]));
			if (ui == SRVCOL_NUMUSERS)
				strRes.AppendFormat(_T(" (%s)"), GetResString(IDS_MAXUSERS));
			hdi.pszText = const_cast<LPTSTR>(strRes.GetString());
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
		}

		for (POSITION pos = g_App.m_pServerList->m_serverList.GetHeadPosition(); pos != NULL;)
		{
			CServer*	pServer = g_App.m_pServerList->m_serverList.GetNext(pos);
			int			iIndex = FindIndex(pServer);

			if (iIndex != -1)
				RefreshServerDesc(iIndex, *pServer);
		}
		ShowFilesCount();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CServerListCtrl::FindIndex(const CServer *pServer) const
{
	LVFINDINFO	find;

	memzero(&find, sizeof(LVFINDINFO));
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pServer;

	return FindItem(&find);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	RefreshServerDesc() refreshes the server description for the 'iIndex'th server from 'server'.
void CServerListCtrl::RefreshServerDesc(int iIndex, const CServer &server)
{
	CServer		*cur_srv;
	int			iImageIndex = 0;
	CString		strTemp;
	UINT		dwResStrId, iItemState = 0;

//	Disable list sorting, position will be updated either by 'resort' or by last SetItemText()
	SetSortProcedure(NULL);

	if ( g_App.m_pServerConnect->IsConnected()
		&& (cur_srv = g_App.m_pServerConnect->GetCurrentServer()) != NULL
		&& cur_srv->GetPort() == server.GetPort()
		&& _tcsicmp(cur_srv->GetAddress(), server.GetAddress()) == 0 )
	{
		iImageIndex = (server.GetFailedCount() == 0) ? 2 : 4;
		iItemState |= LVIS_GLOW;
	}
	else if (server.GetFailedCount() > 0)
	{
		iImageIndex = 6;
		if (!server.IsStaticMember())
			iItemState |= LVIS_CUT;
	}

	if (server.IsStaticMember())
		iImageIndex++;

	SetItem( iIndex, SRVCOL_SERVERNAME, LVIF_TEXT | LVIF_IMAGE | LVIF_STATE,
		server.GetListName(), iImageIndex, iItemState, LVIS_GLOW | LVIS_CUT, 0, 0 );

	if (server.GetAuxPort() != 0)
		strTemp.Format(_T("%s:%u (%u)"), server.GetAddress(), server.GetPort(), server.GetAuxPort());
	else
		strTemp.Format(_T("%s:%u"), server.GetAddress(), server.GetPort());
	SetItemText(iIndex, SRVCOL_SERVERIP, strTemp);

	SetItemText(iIndex, SRVCOL_DESCRIPTION, server.GetDescription());

	if (server.GetPing() != 0)
	{
		strTemp.Format(_T("%u"), server.GetPing());
		SetItemText(iIndex, SRVCOL_PING, strTemp);
	}
	else
		SetItemText(iIndex, SRVCOL_PING, _T(""));

	if (server.GetNumUsers() != 0)
		strTemp.Format(_T("%u"), server.GetNumUsers());
	else
		strTemp = _T("");

	if (server.GetMaxUsers())
		strTemp.AppendFormat(_T(" (%u)"), server.GetMaxUsers());
	SetItemText(iIndex, SRVCOL_NUMUSERS, strTemp);

	if (server.GetFiles() != 0)
	{
		strTemp.Format(_T("%u"), server.GetFiles());
		SetItemText(iIndex, SRVCOL_NUMFILES, strTemp);
	}
	else
		SetItemText(iIndex, SRVCOL_NUMFILES, _T(""));

	switch (server.GetPreferences())
	{
		case PR_LOW:
			dwResStrId = IDS_PRIOLOW;
			break;
		case PR_NORMAL:
			dwResStrId = IDS_PRIONORMAL;
			break;
		case PR_HIGH:
			dwResStrId = IDS_PRIOHIGH;
			break;
		default:
			dwResStrId = IDS_PRIONOPREF;
	}
	GetResString(&strTemp, dwResStrId);
	SetItemText(iIndex, SRVCOL_PRIORITY, strTemp);

	strTemp.Format(_T("%u"), server.GetFailedCount());
	SetItemText(iIndex, SRVCOL_FAILEDCOUNT, strTemp);

	SetItemText(iIndex, SRVCOL_STATIC, YesNoStr(server.IsStaticMember()));

	if (server.GetHardMaxFiles() != 0)
	{
		if (server.GetSoftMaxFiles() != 0)
			strTemp.Format(_T("%u (%u)"), server.GetSoftMaxFiles(), server.GetHardMaxFiles());
		else
			strTemp.Format(_T("(%u)"), server.GetHardMaxFiles());
		SetItemText(iIndex, SRVCOL_FILELIMIT, strTemp);
	}
	else
		SetItemText(iIndex, SRVCOL_FILELIMIT, _T(""));

	SetItemText(iIndex, SRVCOL_SOFTWAREVER, server.GetVersion());
	SetItemText(iIndex, SRVCOL_COUNTRY, server.GetCountryName());

	SetSortProcedure(SortProc);	//	Enable list sorting

	if (server.GetLowIDUsers() != 0)
	{
		strTemp.Format(_T("%u"), server.GetLowIDUsers());
		SetItemText(iIndex, SRVCOL_LOWIDUSERS, strTemp);
	}
	else
		SetItemText(iIndex, SRVCOL_LOWIDUSERS, _T(""));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::RefreshAllServer()
{
	for(POSITION pos = g_App.m_pServerList->m_serverList.GetHeadPosition(); pos != NULL;)
	{
		CServer	*pServer = g_App.m_pServerList->m_serverList.GetAt(pos);

		RefreshServer(*pServer);
		g_App.m_pServerList->m_serverList.GetNext(pos);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::RemoveServer(CServer *pServer)
{
	int	iIndex = FindIndex(pServer);

	if (iIndex != -1)
	{
		g_App.m_pServerList->RemoveServer(GetServerAt(iIndex));
		DeleteItem(iIndex);
	}
	ShowFilesCount();
	return;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Remove Dead Servers
void CServerListCtrl::RemoveDeadServer()
{
	if (g_App.m_pPrefs->DeadServer())
	{
		SetRedraw(FALSE);

		for (POSITION pos = g_App.m_pServerList->m_serverList.GetHeadPosition(); pos != NULL; g_App.m_pServerList->m_serverList.GetNext(pos))
		{
			CServer	* pServer = g_App.m_pServerList->m_serverList.GetAt(pos);

			if ( pServer->GetFailedCount() >= g_App.m_pPrefs->GetDeadserverRetries()
				&& !pServer->IsStaticMember() )
			{
				RemoveServer(pServer);
				pos = g_App.m_pServerList->m_serverList.GetHeadPosition();
			}
		}
		SetRedraw(TRUE);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::AppendServer(CServer *pServer)
{
	if (::IsWindow(GetSafeHwnd()))
	{
		int	iNumServers = GetItemCount();
		int	iIndex = 0;

		iIndex = InsertItem(LVIF_PARAM, iNumServers, NULL, 0, 0, 1, reinterpret_cast<LPARAM>(pServer));
		RefreshServerDesc(iIndex, *pServer);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerListCtrl::AddServer(CServer *pServer, bool bAddToList, bool bBulkLoad, bool bChangeServerInfo/* = false*/)
{
	if (pServer == NULL)
		return false;

	if (!g_App.m_pServerList->AddServer(pServer, bChangeServerInfo))
		return false;

	if (bAddToList && !bChangeServerInfo)
		AppendServer(pServer);
	if (!bBulkLoad)
		ShowFilesCount();
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::RefreshServer(CServer &server)
{
	if (!g_App.m_pMDlg->IsRunning())
		return;

	if (!::IsWindow(m_hWnd))
		return;

	int	iIndex = FindIndex(&server);

	if (iIndex == -1)
		return;
	RefreshServerDesc(iIndex, server);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//	CServerListCtrl message handlers

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
//	On right click, we also want to change the current selection like the left click does
	CPoint	p = point;
	NOPRM(pWnd);

	ScreenToClient(&p);

	int	iIndex = HitTest(p);

	if (iIndex != -1)
		SetSelectionMark(iIndex);

//	Create up-to-date popupmenu
	UINT	iMenuFlags;
	CTitleMenu	m_ServerMenu;
	CMenu	m_ServerPrioMenu;

	int			iSelectionMark = GetSelectionMark();
	CServer		*pServer = (iSelectionMark != -1) ? GetSelectedServer() : NULL;
	UINT		dwSelectedCount = GetSelectedCount();
	bool		bSelectedSrv = (dwSelectedCount > 0) && (pServer != NULL);

//	Set state of selection-dependent menuitems
	iMenuFlags = MF_STRING | (((iSelectionMark != -1) && bSelectedSrv) ? 0 : MF_GRAYED);

	m_ServerPrioMenu.CreateMenu();

	bool		bJustOne = (dwSelectedCount == 1);

	m_ServerPrioMenu.AppendMenu( MF_STRING |
		((bJustOne && pServer->GetPreferences() == PR_LOW) ? MF_CHECKED : MF_UNCHECKED),
		MP_PRIOLOW, GetResString(IDS_PRIOLOW) );
	m_ServerPrioMenu.AppendMenu( MF_STRING |
		((bJustOne && pServer->GetPreferences() == PR_NORMAL) ? MF_CHECKED : MF_UNCHECKED),
		MP_PRIONORMAL, GetResString(IDS_PRIONORMAL) );
	m_ServerPrioMenu.AppendMenu( MF_STRING |
		((bJustOne && pServer->GetPreferences() == PR_HIGH) ? MF_CHECKED : MF_UNCHECKED),
		MP_PRIOHIGH, GetResString(IDS_PRIOHIGH) );

	m_ServerMenu.CreatePopupMenu();
	m_ServerMenu.AddMenuTitle(GetResString(IDS_SERVERS));
	m_ServerMenu.AppendMenu(iMenuFlags, MP_CONNECTTO, GetResString(IDS_CONNECTTHIS));
	m_ServerMenu.AppendMenu(iMenuFlags | MF_POPUP, (UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));

//	Hide greyed-out "add /remove from static server"
	if (bSelectedSrv)
	{
		if (pServer->IsStaticMember())
			m_ServerMenu.AppendMenu(iMenuFlags, MP_REMOVEFROMSTATIC, GetResString(IDS_REMOVEFROMSTATIC));
		else
			m_ServerMenu.AppendMenu(iMenuFlags, MP_ADDTOSTATIC, GetResString(IDS_ADDTOSTATIC));
	}

	m_ServerMenu.AppendMenu(MF_SEPARATOR);
	m_ServerMenu.AppendMenu( iMenuFlags |
		(((dwSelectedCount != 1) || pServer->IsStaticMember()) ? MF_GRAYED : MF_ENABLED),
		MP_EDIT, GetResString(IDS_FNCEDIT) );
	m_ServerMenu.AppendMenu(iMenuFlags, MP_REMOVE, GetResString(IDS_REMOVETHIS));
	m_ServerMenu.AppendMenu(MF_SEPARATOR);
	m_ServerMenu.AppendMenu(iMenuFlags, MP_GETED2KLINK, GetStringFromShortcutCode(IDS_DL_LINK1, SCUT_LINK, SSP_TAB_PREFIX));

	m_ServerMenu.SetDefaultItem(MP_CONNECTTO);
	m_ServerMenu.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);

//	Menu objects are destroyed in their destructor
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CServerListCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	int	iIndex = GetSelectionMark();
	NOPRM(lParam);

	if (iIndex != -1)
	{
		if (GetSelectedServer() != NULL)
		{
			switch (wParam)
			{
				case MP_CONNECTTO:
				{
					if (GetSelectedCount() > 1)
					{
						CServer	*pServer;
#ifdef OLD_SOCKETS_ENABLED

						g_App.m_pServerConnect->Disconnect();
#endif

						POSITION	pos = GetFirstSelectedItemPosition();

					//	Move selected servers to the start of the list, to connect them first
						while (pos != NULL)
						{
							if ((iIndex = GetNextSelectedItem(pos)) >= 0)
							{
								pServer = GetServerAt(iIndex);
								g_App.m_pServerList->MoveServerDown(pServer);
							}
						}
#ifdef OLD_SOCKETS_ENABLED
						g_App.m_pServerConnect->ConnectToAnyServer(g_App.m_pServerList->GetServerCount() - GetSelectedCount(), false);
#else
						g_App.m_pEngine->ConnectToAnyServer();
#endif
					}
					else
					{
#ifdef OLD_SOCKETS_ENABLED
						if (g_App.m_pServerConnect->IsConnected())
						{
							if ( !_tcscmp( GetSelectedServer()->GetAddress(),
								g_App.m_pServerConnect->GetCurrentServer()->GetAddress() ) )
							{
								AddLogLine(0, IDS_ALREADYCONNECTED, GetSelectedServer()->GetListName());
								break;
							}
						}
						g_App.m_pServerConnect->ConnectToServer(GetSelectedServer(), false);
#endif
#ifdef NEW_SOCKETS
						CServer	*pServer = GetSelectedServer();

						if (pServer != NULL)
							g_App.m_pEngine->ConnectToServer(pServer);
#endif
					}
					g_App.m_pMDlg->ShowConnectionState(false);
					break;
				}
				case MP_EDIT:
				{
					CServer	*pServer = GetSelectedServer();
					CNewServerDlg dlgEditServer;
					CString strPort;
					CString strAuxPort;

					dlgEditServer.SetParent(&g_App.m_pMDlg->m_wndServer);
					dlgEditServer.SetServerEditMode();
					strPort.Format(_T("%u"), pServer->GetPort());
					strAuxPort.Format(_T("%u"), pServer->GetAuxPort());
					dlgEditServer.SetLabels(pServer->GetAddress(), strPort, pServer->GetListName(), strAuxPort);
					if (dlgEditServer.DoModal() == IDOK)
					{
						RefreshServer(*pServer);
					}
					break;
				}
				case MP_REMOVE:
				{
					SetRedraw(FALSE);

					POSITION	pos;

					while (GetFirstSelectedItemPosition() != NULL)
					{
						pos = GetFirstSelectedItemPosition();
						iIndex = GetNextSelectedItem(pos);
						g_App.m_pServerList->RemoveServer(GetServerAt(iIndex));
						DeleteItem(iIndex);
					}
					ShowFilesCount();
					SetRedraw(TRUE);
					break;
				}
				case MP_ADDTOSTATIC:
				{
					POSITION	pos = GetFirstSelectedItemPosition();

					while (pos != NULL)
					{
						CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

						if (!StaticServerFileAppend(pServer))
							return false;
					}
					break;
				}
				case MP_REMOVEFROMSTATIC:
				{
					POSITION	pos = GetFirstSelectedItemPosition();

					while (pos != NULL)
					{
						CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

						if (!StaticServerFileRemove(pServer))
							return false;
					}
					break;
				}
				case MP_PRIOLOW:
					SetSelectedServersPriority(PR_LOW);
					break;

				case MP_PRIONORMAL:
					SetSelectedServersPriority(PR_NORMAL);
					break;

				case MP_PRIOHIGH:
					SetSelectedServersPriority(PR_HIGH);
					break;

				case MP_GETED2KLINK:
				{
					POSITION	pos = GetFirstSelectedItemPosition();
					CString	strBuffer, strLink;

					while (pos != NULL)
					{
						CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

						strBuffer.Format(_T("ed2k://|server|%s|%u|/"), pServer->GetAddress(), pServer->GetPort());
						if (strLink.GetLength() > 0)
							strLink += _T("\r\n");
						strLink += strBuffer;
					}
					g_App.CopyTextToClipboard(strLink);
					break;
				}
			}
		}
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::SetSelectedServersPriority(unsigned uiPriority)
{
	POSITION	pos = GetFirstSelectedItemPosition();

	while (pos != NULL)
	{
		CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

		pServer->SetPreference(static_cast<byte>(uiPriority));
		if (pServer->IsStaticMember())
			StaticServerFileAppend(pServer);	// RefreshServer is called inside
		else
			RefreshServer(*pServer);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	OnNMLdblclk() is the left-double-click message handler
void CServerListCtrl::OnNMLdblclk(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pNMHDR); NOPRM(pResult);
	if (GetSelectionMark() != -1)
	{
#ifdef OLD_SOCKETS_ENABLED
		if (g_App.m_pServerConnect->IsConnected())
		{
			if ( !_tcscmp( GetSelectedServer()->GetAddress(),
				(g_App.m_pServerConnect->GetCurrentServer())->GetAddress() ) )
			{
				AddLogLine(0, IDS_ALREADYCONNECTED, GetSelectedServer()->GetListName());
				return;
			}
		}
		g_App.m_pServerConnect->ConnectToServer(GetSelectedServer(), false);
#endif //OLD_SOCKETS_ENABLED
#ifdef NEW_SOCKETS

		CServer	*pServer = GetSelectedServer();

		if (pServer != NULL)
			g_App.m_pEngine->ConnectToServer(pServer);
#else
		g_App.m_pMDlg->ShowConnectionState(false);
#endif //NEW_SOCKETS
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CServerListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CServer	*pServer1 = reinterpret_cast<CServer*>(lParam1);
	CServer	*pServer2 = reinterpret_cast<CServer*>(lParam2);

	if (pServer1 == NULL || pServer2 == NULL)
		return 0;

	uint32	dwVal1, dwVal2;
	int		iCompare = 0;
	int		iSortColumn = (lParamSort & MLC_COLUMNMASK);
	int		iSortAltFlag = (lParamSort & MLC_SORTALT);
	int		iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 1 : -1;

	for (;;)
	{
		switch (iSortColumn)
		{
			case SRVCOL_SERVERNAME:
			{
				bool	bServerHasNoName1 = !pServer1->HasServerName();
				bool	bServerHasNoName2 = !pServer2->HasServerName();

				if (!bServerHasNoName1 && !bServerHasNoName2)
					iCompare = _tcsicmp(pServer1->GetListName(), pServer2->GetListName());
				else
					iCompare = bServerHasNoName1 ? (bServerHasNoName2 ? 0 : 1) : -1;

				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERIP;
					continue;
				}
				break;
			}

			case SRVCOL_SERVERIP:
			{
				if (pServer1->HasDynIP() && pServer2->HasDynIP())	//	both are dynamic IP...
					iCompare = _tcsicmp(pServer1->GetDynIP(), pServer2->GetDynIP());
				else if (pServer1->HasDynIP())	//	only the first is dynamic IP...
					iCompare = -1;
				else if (pServer2->HasDynIP())	//	only the second is dynamic IP...
					iCompare = 1;
				else	//	both have static IPs...
				{
					dwVal1 = fast_htonl(pServer1->GetIP());
					dwVal2 = fast_htonl(pServer2->GetIP());
					if (dwVal1 < dwVal2)
						iCompare = -1;
					else if (dwVal1 > dwVal2)
						iCompare = 1;
					else
						iCompare = pServer1->GetPort() - pServer2->GetPort();
				}
				break;
			}

			case SRVCOL_DESCRIPTION:
			{
				{	//	required to optimize string destructors
					CString strServerDescription1 = pServer1->GetDescription();
					CString strServerDescription2 = pServer2->GetDescription();

					if (!strServerDescription1.IsEmpty() && !strServerDescription2.IsEmpty())
						iCompare = _tcsicmp(strServerDescription1, strServerDescription2);
					else
					{
						iCompare = strServerDescription1.IsEmpty() ? (strServerDescription2.IsEmpty() ? 0 : 1) : -1;
						iSortMod = 1;		//empty entries at the bottom in any case
					}
				}

				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_PING:
			{
				iCompare = pServer1->GetPing() - pServer2->GetPing();
				if (!pServer1->GetPing() || !pServer2->GetPing())
					iSortMod = -1;
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_NUMUSERS:
			{
				if (iSortAltFlag == 0)
				{
					dwVal1 = pServer1->GetNumUsers();
					dwVal2 = pServer2->GetNumUsers();
				}
				else	//	max. users
				{
					dwVal1 = pServer1->GetMaxUsers();
					dwVal2 = pServer2->GetMaxUsers();
				}
				iCompare = dwVal1 - dwVal2;
				if ((dwVal1 == 0) || (dwVal2 == 0))
					iSortMod = -1;
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_NUMFILES:
			{
				iCompare = pServer1->GetFiles() - pServer2->GetFiles();
				if (!pServer1->GetFiles() || !pServer2->GetFiles())
					iSortMod = -1;
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_PRIORITY:
			{
				iCompare = pServer1->GetPreferences() - pServer2->GetPreferences();
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_FAILEDCOUNT:
			{
				iCompare = pServer1->GetFailedCount() - pServer2->GetFailedCount();
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_STATIC:
			{
				iCompare = pServer1->IsStaticMember() - pServer2->IsStaticMember();
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_FILELIMIT:
			{
				if (iSortAltFlag == 0)
				{
					dwVal1 = pServer1->GetSoftMaxFiles();
					dwVal2 = pServer2->GetSoftMaxFiles();
				}
				else	//	hard files
				{
					dwVal1 = pServer1->GetHardMaxFiles();
					dwVal2 = pServer2->GetHardMaxFiles();
				}
				iCompare = dwVal1 - dwVal2;
				if ((dwVal1 == 0) || (dwVal2 == 0))
					iSortMod = -1;
				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_SOFTWAREVER:
			{
				{	//	required to optimize string destructors
					CString strServerVersion1 = pServer1->GetVersion();
					CString strServerVersion2 = pServer2->GetVersion();

					if (!strServerVersion1.IsEmpty() && !strServerVersion2.IsEmpty())
						iCompare = _tcsicmp(strServerVersion1, strServerVersion2);
					else
					{
						iCompare = strServerVersion1.IsEmpty() ? (strServerVersion2.IsEmpty() ? 0 : 1) : -1;
						iSortMod = 1;		//empty entries at the bottom in any case
					}
				}

				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//	sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_COUNTRY:
			{
				{	//	required to optimize string destructors
					CString strServerCountry1 = pServer1->GetCountryName();
					CString strServerCountry2 = pServer2->GetCountryName();

					if (!strServerCountry1.IsEmpty() && !strServerCountry2.IsEmpty())
						iCompare = _tcsicmp(strServerCountry1, strServerCountry2);
					else
					{
						iCompare = strServerCountry1.IsEmpty() ? (strServerCountry2.IsEmpty() ? 0 : 1) : -1;
						iSortMod = 1;		//empty entries at the bottom in any case
					}
				}

				if (iCompare == 0)
				{
					iSortColumn = SRVCOL_SERVERNAME;
					iSortMod = 1;		//sort always in ascending order
					continue;
				}
				break;
			}

			case SRVCOL_LOWIDUSERS:
				iCompare = pServer1->GetLowIDUsers() - pServer2->GetLowIDUsers();
				if ((pServer1->GetLowIDUsers() == 0) || (pServer2->GetLowIDUsers() == 0))
					iSortMod = -1;
				break;
		}
		break;
	}

	return iCompare * iSortMod;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	StaticServerFileAppend() - save a server as a static one
//	Note: this function can be also called for already static servers to preserve
//	changed properties in the configuration file
bool CServerListCtrl::StaticServerFileAppend(CServer *pServer)
{
	bool	bStatic = pServer->IsStaticMember();

	pServer->SetIsStaticMember(true);

	if (!g_App.m_pServerList->SaveServersToTextFile())
	{
		if (!bStatic)	// revert to the previous state only 
			pServer->SetIsStaticMember(false);
		AddLogLine(LOG_RGB_ERROR, IDS_ERROR_SAVEFILE, CFGFILE_STATICSERVERS);
		return false;
	}

	AddLogLine(0, _T("'%s:%u,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_ADDED2SSF));
	RefreshServer(*pServer);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServerListCtrl::StaticServerFileRemove(CServer *pServer)
{
	if (!pServer->IsStaticMember())
		return true;

	pServer->SetIsStaticMember(false);

	if (!g_App.m_pServerList->SaveServersToTextFile())
	{
		pServer->SetIsStaticMember(true);
		AddLogLine(LOG_RGB_ERROR, IDS_ERROR_SAVEFILE, CFGFILE_STATICSERVERS);
		return false;
	}

	AddLogLine(0, _T("'%s:%u,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_REMOVEDFROMSSF));
	RefreshServer(*pServer);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::ShowFilesCount()
{
	CString	strTitle;

	strTitle.Format(_T("%s (%u)"), GetResString(IDS_SERVERS), GetItemCount());
	g_App.m_pMDlg->m_wndServer.SetDlgItemText(IDC_SERVLIST_TEXT, strTitle);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CServerListCtrl::PreTranslateMessage(MSG *pMsg)
{
	if ((pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_SYSKEYDOWN))
	{
		POSITION	posSelClient = GetFirstSelectedItemPosition();

		if (posSelClient != NULL)
		{
			int		iMessage = 0;
			short	nCode = GetCodeFromPressedKeys(pMsg);

			if (nCode == g_App.m_pPrefs->GetShortcutCode(SCUT_LINK))
				iMessage = MP_GETED2KLINK;

			if (iMessage > 0)
			{
				PostMessage(WM_COMMAND, static_cast<WPARAM>(iMessage));
				return TRUE;
			}
		}
	}

	return CMuleListCtrl::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.152
log
@Resolved recently introduced compiler warning; Reduced H-file dependecy.
@
text
@d599 1
a599 1
						strBuffer.Format(_T("ed2k://|server|%s|%u|/"), pServer->GetFullIP(), pServer->GetPort());
@


1.151
log
@Introduce a function to change server priority (similar to original).
@
text
@d27 3
d621 1
a621 1
		pServer->SetPreference(uiPriority);
@


1.150
log
@Removed meaningless code doing nothing.
@
text
@d485 1
a485 1
						g_App.m_pServerConnect->ConnectToAnyServer((g_App.m_pServerList->GetServerCount() - GetSelectedCount()), false);
d576 2
a577 2
				{
					POSITION	pos = GetFirstSelectedItemPosition();
d579 2
a580 10
					while (pos != NULL)
					{
						CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

						pServer->SetPreference(PR_LOW);
						if (pServer->IsStaticMember())
							StaticServerFileAppend(pServer);	// RefreshServer is called inside
						else
							RefreshServer(*pServer);
					}
a581 4
				}
				case MP_PRIONORMAL:
				{
					POSITION	pos = GetFirstSelectedItemPosition();
d583 2
a584 10
					while (pos != NULL)
					{
						CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

						pServer->SetPreference(PR_NORMAL);
						if (pServer->IsStaticMember())
							StaticServerFileAppend(pServer);	// RefreshServer is called inside
						else
							RefreshServer(*pServer);
					}
a585 4
				}
				case MP_PRIOHIGH:
				{
					POSITION	pos = GetFirstSelectedItemPosition();
a586 12
					while (pos != NULL)
					{
						CServer	*pServer = GetServerAt(GetNextSelectedItem(pos));

						pServer->SetPreference(PR_HIGH);
						if (pServer->IsStaticMember())
							StaticServerFileAppend(pServer);	// RefreshServer is called inside
						else
							RefreshServer(*pServer);
					}
					break;
				}
d610 16
@


1.149
log
@Save sorting directions for all GUI lists; Unified list sort initialization and click processing;
Simplified list arrow configuration interface; Unified list column definitions.
@
text
@a345 2
		if (pServer->GetFailedCount() < 0)
			pServer->ResetFailedCount();
a376 3

	if (server.GetFailedCount() < 0)
		server.ResetFailedCount();
@


1.148
log
@Corrected error message regarding saving to staticservers.dat (more accurate message; removed duplicated report for every error message).
@
text
@d38 2
a39 3
//	ON_NOTIFY_REFLECT(NM_RCLICK, OnNMRclickServlist)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnclickServlist)
	ON_NOTIFY_REFLECT (NM_DBLCLK, OnNMLdblclk)
a46 1
	memset(&m_bSortAscending, true, sizeof(m_bSortAscending));
d65 13
a77 13
		{ LVCFMT_LEFT,  150 },	// SL_COLUMN_SERVERNAME
		{ LVCFMT_LEFT,  140 },	// SL_COLUMN_SERVERIP
		{ LVCFMT_LEFT,  150 },	// SL_COLUMN_DESCRIPTION
		{ LVCFMT_RIGHT,  50 },	// SL_COLUMN_PING
		{ LVCFMT_RIGHT,  50 },	// SL_COLUMN_NUMUSERS
		{ LVCFMT_RIGHT,  50 },	// SL_COLUMN_NUMFILES
		{ LVCFMT_LEFT,   60 },	// SL_COLUMN_PREFERENCES
		{ LVCFMT_RIGHT,  50 },	// SL_COLUMN_FAILEDCOUNT
		{ LVCFMT_LEFT,   50 },	// SL_COLUMN_STATIC
		{ LVCFMT_RIGHT, 100 },	// SL_COLUMN_SOFTFILELIMIT
		{ LVCFMT_LEFT,  150 },	// SL_COLUMN_SOFTWAREVER
		{ LVCFMT_LEFT,  150 },	// SL_COLUMN_COUNTRY
		{ LVCFMT_RIGHT,  60 }	// SL_COLUMN_LOWIDUSERS
d80 1
a80 1
	ModifyStyle(LVS_SINGLESEL,0);
a92 6
	m_bSortAscending[SL_COLUMN_NUMUSERS] = false;
	m_bSortAscending[SL_COLUMN_NUMFILES] = false;
	m_bSortAscending[SL_COLUMN_FAILEDCOUNT] = false;
	m_bSortAscending[SL_COLUMN_SOFTFILELIMIT] = false;
	m_bSortAscending[SL_COLUMN_SOFTWAREVER] = false;

d110 4
a114 1
	{
a115 1
	}
d117 1
a117 6
	{
		int	iSortColumn = g_App.m_pPrefs->GetColumnSortItem(CPreferences::TABLE_SERVER);
		bool	bSortAscending = g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_SERVER);

		SortInit(iSortColumn | ((bSortAscending) ? MLC_SORTASC : MLC_SORTDESC));
	}
a120 29
void CServerListCtrl::SortInit(int iSortCode)
{
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);			// The sort column
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;	// The sort order
	int		iSortAltFlag = (iSortCode & MLC_SORTALT);			// The alternate sort

	if ((iSortColumn != SL_COLUMN_NUMUSERS) && (iSortColumn != SL_COLUMN_SOFTFILELIMIT))
		iSortAltFlag = 0;

	m_bSortAscending[iSortColumn] = bSortAscending;
	if (iSortAltFlag == 0)
	{
		if (iSortColumn == SL_COLUMN_NUMUSERS)
			m_bSortAscending[SL_COLUMN_NUMCOLUMNS] = true;
		if (iSortColumn == SL_COLUMN_SOFTFILELIMIT)
			m_bSortAscending[SL_COLUMN_NUMCOLUMNS + 1] = true;
		SetSortArrow(iSortColumn, bSortAscending);
	}
	else
	{
		if (iSortColumn == SL_COLUMN_NUMUSERS)
			m_bSortAscending[SL_COLUMN_NUMCOLUMNS] = false;
		if (iSortColumn == SL_COLUMN_SOFTFILELIMIT)
			m_bSortAscending[SL_COLUMN_NUMCOLUMNS + 1] = false;
		SetSortArrow(iSortColumn, (bSortAscending) ? arrowDoubleUp : arrowDoubleDown);
	}
	SortItems(SortProc, iSortCode);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d125 13
a137 13
		IDS_SL_SERVERNAME,			//SL_COLUMN_SERVERNAME
		IDS_IP,						//SL_COLUMN_SERVERIP
		IDS_DESCRIPTION,			//SL_COLUMN_DESCRIPTION
		IDS_PING,					//SL_COLUMN_PING
		IDS_UUSERS,					//SL_COLUMN_NUMUSERS
		IDS_FILES,					//SL_COLUMN_NUMFILES
		IDS_PRIORITY,				//SL_COLUMN_PREFERENCES
		IDS_UFAILED,				//SL_COLUMN_FAILEDCOUNT
		IDS_STATICSERVER,			//SL_COLUMN_STATIC
		IDS_SERVER_SOFTHARDLIMIT,	//SL_COLUMN_SOFTFILELIMIT
		IDS_SERVER_VERSION,			//SL_COLUMN_SOFTWAREVER
		IDS_COUNTRY,				//SL_COLUMN_COUNTRY
		IDS_LOWIDUSERS				//SL_COLUMN_LOWIDUSERS
d151 1
a151 1
			if (ui == SL_COLUMN_NUMUSERS)
d209 1
a209 1
	SetItem( iIndex, SL_COLUMN_SERVERNAME, LVIF_TEXT | LVIF_IMAGE | LVIF_STATE,
d216 1
a216 1
	SetItemText(iIndex, SL_COLUMN_SERVERIP, strTemp);
d218 1
a218 1
	SetItemText(iIndex, SL_COLUMN_DESCRIPTION, server.GetDescription());
d223 1
a223 1
		SetItemText(iIndex, SL_COLUMN_PING, strTemp);
d226 1
a226 1
		SetItemText(iIndex, SL_COLUMN_PING, _T(""));
d235 1
a235 1
	SetItemText(iIndex, SL_COLUMN_NUMUSERS, strTemp);
d240 1
a240 1
		SetItemText(iIndex, SL_COLUMN_NUMFILES, strTemp);
d243 1
a243 1
		SetItemText(iIndex, SL_COLUMN_NUMFILES, _T(""));
d260 1
a260 1
	SetItemText(iIndex, SL_COLUMN_PREFERENCES, strTemp);
d263 1
a263 1
	SetItemText(iIndex, SL_COLUMN_FAILEDCOUNT, strTemp);
d265 1
a265 1
	SetItemText(iIndex, SL_COLUMN_STATIC, YesNoStr(server.IsStaticMember()));
d273 1
a273 1
		SetItemText(iIndex, SL_COLUMN_SOFTFILELIMIT, strTemp);
d276 1
a276 1
		SetItemText(iIndex, SL_COLUMN_SOFTFILELIMIT, _T(""));
d278 2
a279 2
	SetItemText(iIndex, SL_COLUMN_SOFTWAREVER, server.GetVersion());
	SetItemText(iIndex, SL_COLUMN_COUNTRY, server.GetCountryName());
d286 1
a286 1
		SetItemText(iIndex, SL_COLUMN_LOWIDUSERS, strTemp);
d289 1
a289 1
		SetItemText(iIndex, SL_COLUMN_LOWIDUSERS, _T(""));
a680 38
//	OnLvnColumnclickServlist() is the column header click message handler
void CServerListCtrl::OnLvnColumnclickServlist(NMHDR *pNMHDR, LRESULT *pResult)
{
	NM_LISTVIEW	*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);
	int			iFlags = 0, iSubItem = pNMListView->iSubItem;
	bool		bSortOrder = m_bSortAscending[iSubItem];

//	For the two double columns, toggle the Alt column flag when the arrow is facing up
	if (iSubItem == SL_COLUMN_NUMUSERS)
	{
		if ((static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem) && bSortOrder)
			m_bSortAscending[SL_COLUMN_NUMCOLUMNS] = !m_bSortAscending[SL_COLUMN_NUMCOLUMNS];
		iFlags = m_bSortAscending[SL_COLUMN_NUMCOLUMNS] ? 0 : MLC_SORTALT;
	}
	if (iSubItem == SL_COLUMN_SOFTFILELIMIT)
	{
		if ((static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem) && bSortOrder)
			m_bSortAscending[SL_COLUMN_NUMCOLUMNS + 1] = !m_bSortAscending[SL_COLUMN_NUMCOLUMNS + 1];
		iFlags = m_bSortAscending[SL_COLUMN_NUMCOLUMNS + 1] ? 0 : MLC_SORTALT;
	}

// Reverse sorting direction for the same column and keep the same if column was changed
	if (static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
		m_bSortAscending[iSubItem] = bSortOrder = !bSortOrder;

	if (iFlags == 0)
		SetSortArrow(iSubItem, bSortOrder);
	else
		SetSortArrow(iSubItem, (bSortOrder) ? arrowDoubleUp : arrowDoubleDown);
	SortItems(SortProc, iSubItem | iFlags | ((bSortOrder) ? MLC_SORTASC : MLC_SORTDESC));

	g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, iSubItem | iFlags);	// Allow to save alternate criterion
	g_App.m_pPrefs->SetColumnSortAscending(CPreferences::TABLE_SERVER, bSortOrder);

	Invalidate();
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d699 1
a699 1
			case SL_COLUMN_SERVERNAME:
d711 1
a711 1
					iSortColumn = SL_COLUMN_SERVERIP;
d717 1
a717 1
			case SL_COLUMN_SERVERIP:
d739 1
a739 1
			case SL_COLUMN_DESCRIPTION:
d756 1
a756 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d763 1
a763 1
			case SL_COLUMN_PING:
d770 1
a770 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d777 1
a777 1
			case SL_COLUMN_NUMUSERS:
d794 1
a794 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d801 1
a801 1
			case SL_COLUMN_NUMFILES:
d808 1
a808 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d815 1
a815 1
			case SL_COLUMN_PREFERENCES:
d820 1
a820 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d827 1
a827 1
			case SL_COLUMN_FAILEDCOUNT:
d832 1
a832 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d839 1
a839 1
			case SL_COLUMN_STATIC:
d844 1
a844 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d851 1
a851 1
			case SL_COLUMN_SOFTFILELIMIT:
d868 1
a868 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d875 1
a875 1
			case SL_COLUMN_SOFTWAREVER:
d892 1
a892 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d899 1
a899 1
			case SL_COLUMN_COUNTRY:
d916 1
a916 1
					iSortColumn = SL_COLUMN_SERVERNAME;
d923 1
a923 1
			case SL_COLUMN_LOWIDUSERS:
@


1.147
log
@Simplified logging system implementation.
@
text
@d1026 1
a1026 1
		AddLogLine(0, IDS_ERROR_SSF);
d1046 1
a1046 1
		AddLogLine(0, IDS_ERROR_SSF);
@


1.146
log
@Speeded up list update by combining several window messages into one request.
@
text
@d543 1
a543 1
								AddLogLine(false, IDS_ALREADYCONNECTED, GetSelectedServer()->GetListName());
d703 1
a703 1
				AddLogLine(false, IDS_ALREADYCONNECTED, GetSelectedServer()->GetListName());
d1026 1
a1026 1
		AddLogLine(false, IDS_ERROR_SSF);
d1030 1
a1030 1
	AddLogLine(false, _T("'%s:%u,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_ADDED2SSF));
d1046 1
a1046 1
		AddLogLine(false, IDS_ERROR_SSF);
d1050 1
a1050 1
	AddLogLine(false, _T("'%s:%u,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_REMOVEDFROMSSF));
@


1.145
log
@Avoid setting twice server name while adding server to the list (RefreshServerDesc updates server name -- no point to pass it on insertion);
Disable extensive server list sorting on information update -- do it once per row instead of sorting once per list field update.
@
text
@d236 1
a236 1
		(server.GetFailedCount() == 0) ? iImageIndex = 2 : iImageIndex = 4;
d249 2
a250 4
	SetItemState(iIndex, iItemState, LVIS_GLOW | LVIS_CUT);
	SetItem(iIndex, 0, LVIF_IMAGE, 0, iImageIndex, 0, 0, 0, 0);

	SetItemText(iIndex, SL_COLUMN_SERVERNAME, server.GetListName());
@


1.144
log
@Faster (intrinsic) htonl and htons implementation.
@
text
@a34 2
//	CServerListCtrl

d228 3
d323 2
d387 1
a387 2
		iIndex = InsertItem( LVIF_TEXT | LVIF_PARAM, iNumServers, pServer->GetListName(), 0, 0, 1,
							reinterpret_cast<LPARAM>(pServer) );
@


1.143
log
@Fixed static server priority change {Unknown} (was broken right before 1.2d release).
@
text
@d805 2
a806 2
					dwVal1 = htonl(pServer1->GetIP());
					dwVal2 = htonl(pServer2->GetIP());
@


1.142
log
@Reduced H-file dependency.
@
text
@d1013 3
d1018 1
a1018 2
	if (pServer->IsStaticMember())
		return true;
d1024 2
a1025 1
		pServer->SetIsStaticMember(false);
@


1.141
log
@change unicode support for "staticsevers.dat" to be compatible with official eMule
@
text
@d26 1
@


1.140
log
@rolled back last changes.
@
text
@d1014 2
a1015 12
	try
	{
	//	Remove any entry before writing to avoid duplicates
		StaticServerFileRemove(pServer);

		FILE	*pStaticServersFile = _tfsopen(g_App.m_pPrefs->GetConfigDir() + _T("staticservers.dat"), _T("a"), _SH_DENYWR);

		if (pStaticServersFile == NULL)
		{
			AddLogLine(false, IDS_ERROR_SSF);
			return false;
		}
d1017 1
a1017 2
		CString strEntry;
		CStringA strUTF8;
d1019 1
a1019 17
		strEntry.Format(_T("%s:%u,%u,%s\n"),
			pServer->GetAddress(),
			pServer->GetPort(),
			pServer->GetPreferences(),
			pServer->GetListName());

		Str2MB(cfUTF8, &strUTF8, strEntry);
		if (fwrite(strUTF8, strUTF8.GetLength(), 1, pStaticServersFile) != 0)
		{
			if (!pServer->IsStaticMember())
				AddLogLine(false, _T("'%s:%u,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_ADDED2SSF));
			pServer->SetIsStaticMember(true);
			RefreshServer(*pServer);
		}
		fclose(pStaticServersFile);
	}
	catch (...)
d1021 2
d1025 4
d1034 2
a1035 27
	try
	{
		if (!pServer->IsStaticMember())
			return true;

		int		iPos;
		CString	strStaticFilePath = g_App.m_pPrefs->GetConfigDir();
		CString strStaticTempPath = g_App.m_pPrefs->GetConfigDir();

		strStaticFilePath += _T("staticservers.dat");
		strStaticTempPath += _T("statictemp.dat");

		FILE	*pStaticServersFile = _tfsopen(strStaticFilePath, _T("r"), _SH_DENYWR);
		FILE	*pStaticTempFile = _tfsopen(strStaticTempPath, _T("w"), _SH_DENYWR);

		if ((pStaticServersFile == NULL) || (pStaticTempFile == NULL))
		{
			if (pStaticServersFile != NULL)
				fclose(pStaticServersFile);
			if (pStaticTempFile != NULL)
				fclose(pStaticTempFile);
			AddLogLine(false, IDS_ERROR_SSF);
			return false;
		}

		CStringA	strLine, strTest(pServer->GetAddress());
		const char	*pcLine;
d1037 1
a1037 17
	//	Create test string that contains host and port from given pServer in ANSI format
		strTest.AppendFormat(":%u", pServer->GetPort());

		while (!feof(pStaticServersFile))
		{
			if (fgets(strLine.GetBuffer(1024), 1024, pStaticServersFile) == NULL)
				break;

			strLine.ReleaseBuffer();
			pcLine = strLine.GetString();

		//	Ignore comments or invalid lines
			if (*pcLine == '#' || *pcLine == '/' || strLine.GetLength() < 5)
			{
				fprintf(pStaticTempFile, "%s", pcLine);
				continue;
			}
d1039 1
a1039 22
		//	Only interested in "host:port"
			iPos = strLine.Find(_T(','));
			if (iPos < 0)
				continue;

		//	Compare, if not the same pServer write original line to temp file
			if (strLine.Left(iPos) != strTest)
				fprintf(pStaticTempFile, "%s", pcLine);
		}

		fclose(pStaticServersFile);
		fclose(pStaticTempFile);

	//	All ok, remove the existing file and replace with the new one
		CFile::Remove(strStaticFilePath);
		CFile::Rename(strStaticTempPath, strStaticFilePath);

		AddLogLine(false, _T("'%s:%u,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_REMOVEDFROMSSF));
		pServer->SetIsStaticMember(false);
		RefreshServer(*pServer);
	}
	catch (...)
d1041 2
d1045 4
@


1.139
log
@changed the handlig of embedded GUI list header
@
text
@a95 2
	InitHeader();

d183 1
d195 1
a195 1
			m_pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
@


1.138
log
@Fixed vulnerability in staticservers.dat processing (file containing % codes could cause some issues while removing server from the static list).
@
text
@d96 2
a184 1
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
d196 1
a196 1
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
@


1.137
log
@Proper share mode for open files (before other applications could write to a file while we were reading).
@
text
@d1097 1
a1097 1
				fprintf(pStaticTempFile, pcLine);
d1108 1
a1108 1
				fprintf(pStaticTempFile, pcLine);
@


1.136
log
@Happy New Year!
changed the mode for staticsrever.dat after review.
@
text
@d26 1
d1019 1
a1019 1
		FILE	*pStaticServersFile = _tfopen(g_App.m_pPrefs->GetConfigDir() + _T("staticservers.dat"), _T("at"));
d1067 2
a1068 2
		FILE	*pStaticServersFile = _tfopen(strStaticFilePath, _T("r"));
		FILE	*pStaticTempFile = _tfopen(strStaticTempPath, _T("w"));
@


1.135
log
@Optimized string shortcut representation; Some improvements and correction for the recent changes.
@
text
@d1018 1
a1018 1
		FILE	*pStaticServersFile = _tfopen(g_App.m_pPrefs->GetConfigDir() + _T("staticservers.dat"), _T("ab"));
d1029 1
a1029 1
		strEntry.Format(_T("%s:%u,%u,%s\r\n"),
@


1.134
log
@added Unicode support for staticservers.dat
@
text
@d487 1
a487 1
	m_ServerMenu.AppendMenu(iMenuFlags, MP_GETED2KLINK, GetResString(IDS_DL_LINK1) + GetStringFromShortcutCode(SCUT_LINK, SSP_TAB_PREFIX));
d1036 1
a1036 1
		if (fwrite(strUTF8, sizeof(char), strUTF8.GetLength(), pStaticServersFile) == strUTF8.GetLength())
d1079 1
a1079 1
		CStringA	strLine, strTest;
a1082 1
		strTest = pServer->GetAddress();
d1094 1
a1094 1
			if (*pcLine == '#' || *pcLine == '/' || strLine.GetLength() < 7)
@


1.133
log
@Suppressed level 4 warnings; Formatting [Aw3];
Removed old code [Aw3].
@
text
@d1018 1
a1018 1
		FILE	*pStaticServersFile = _tfopen(g_App.m_pPrefs->GetConfigDir() + _T("staticservers.dat"), _T("a"));
d1026 4
a1029 1
		if ( _ftprintf( pStaticServersFile, _T("%s:%u,%u,%s\n"),
d1033 4
a1036 1
			pServer->GetListName() ) != EOF )
a1042 1

d1079 2
a1080 2
		CString		strLine, strTest;
		const TCHAR	*pcLine;
d1082 3
a1084 2
	//	Get host and port from given pServer
		strTest.Format(_T("%s:%u"), pServer->GetAddress(), pServer->GetPort());
d1088 1
a1088 1
			if (_fgetts(strLine.GetBuffer(1024), 1024, pStaticServersFile) == NULL)
d1095 1
a1095 1
			if (*pcLine == _T('#') || *pcLine == _T('/') || strLine.GetLength() < 5)
d1097 1
a1097 1
				_ftprintf(pStaticTempFile, pcLine);
d1108 1
a1108 1
				_ftprintf(pStaticTempFile, pcLine);
@


1.132
log
@Encryption preparations; Code clean-up and simplification.
@
text
@d85 1
a85 1
	m_imageList.Create(16, 16, g_App.m_iDfltImageListColorFlags | ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
d87 1
a87 1
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ELEMENT_COUNT(s_auIconResID));
d92 1
a92 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auColHdr); ui++)
d188 1
a188 1
		for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auResTbl); ui++)
d340 1
a340 1
void CServerListCtrl::RemoveServer(CServer *pServer, bool bDelToList)
d431 1
d498 1
d692 1
d729 1
a729 1
		if (((m_dwParamSort & MLC_COLUMNMASK) == iSubItem) && bSortOrder)
d735 1
a735 1
		if (((m_dwParamSort & MLC_COLUMNMASK) == iSubItem) && bSortOrder)
d741 1
a741 1
	if ((m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
@


1.131
log
@Code restructuring, update and formatting.
@
text
@a17 2
//	ServerListCtrl.cpp : implementation file

d508 1
a508 1
						CServer	* pServer;
d512 1
a512 1
#endif OLD_SOCKETS_ENABLED
d527 1
a527 2
#else OLD_SOCKETS_ENABLED

d529 1
a529 2
#endif OLD_SOCKETS_ENABLED

d543 2
a544 2
						g_App.m_pServerConnect->ConnectToServer(*GetSelectedServer());
#endif OLD_SOCKETS_ENABLED
a545 1

d550 1
a550 2
#endif NEW_SOCKETS

d702 1
a702 1
		g_App.m_pServerConnect->ConnectToServer(*GetSelectedServer());
@


1.130
log
@Fixed recently introduced issue with removal from the static server list.
@
text
@d23 2
a50 1
	m_pServerList = 0;
d54 1
a54 1
bool CServerListCtrl::Init(CServerList *pServerList)
a86 1
	m_pServerList = pServerList;
d199 1
a199 1
		for (POSITION pos = m_pServerList->m_serverList.GetHeadPosition(); pos != NULL;)
d201 1
a201 1
			CServer*	pServer = m_pServerList->m_serverList.GetNext(pos);
d333 1
a333 1
	for(POSITION pos = m_pServerList->m_serverList.GetHeadPosition(); pos != NULL;)
d335 2
a336 1
		CServer	* pServer = m_pServerList->m_serverList.GetAt(pos);
d338 1
a338 1
		m_pServerList->m_serverList.GetNext(pos);
d348 1
a348 1
		m_pServerList->RemoveServer(GetServerAt(iIndex));
d362 1
a362 1
		for (POSITION pos = m_pServerList->m_serverList.GetHeadPosition(); pos != NULL; m_pServerList->m_serverList.GetNext(pos))
d364 1
a364 1
			CServer	* pServer = m_pServerList->m_serverList.GetAt(pos);
d370 1
a370 1
				pos = m_pServerList->m_serverList.GetHeadPosition();
d397 1
a397 1
	if (!m_pServerList->AddServer(pServer, bChangeServerInfo))
d589 1
a589 1
						m_pServerList->RemoveServer(GetServerAt(iIndex));
@


1.129
log
@UNICODE preparations
@
text
@d1099 1
a1099 1
			if (iPos == -1)
a1101 1
			strLine.Truncate(iPos);
d1103 1
a1103 1
			if (strLine != strTest)
@


1.128
log
@Reduced H-file dependency.
@
text
@d35 1
a35 1
IMPLEMENT_DYNAMIC(CServerListCtrl, CMuleListCtrl /*CTreeCtrl*/)
d37 1
a37 2
//#region message map
BEGIN_MESSAGE_MAP(CServerListCtrl, CMuleListCtrl /*CTreeCtrl*/)
a43 1
//#endregion
d366 1
a366 1
			     && !pServer->IsStaticMember() )
a504 1
			//#region Connect To Server
d540 1
a540 1
							               g_App.m_pServerConnect->GetCurrentServer()->GetAddress() ) )
a559 2
			//#endregion
			//#region Rename Server
a577 2
			//#endregion
			//#region Remove Server
a594 2
			//#endregion
			//#region Add to Static Server List
d601 1
a601 1
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));
a607 2
			//#endregion
			//#region Remove from Static Server List
d614 1
a614 1
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));
a620 2
			//#endregion
			//#region Set Server Priority to "Low"
a636 2
			//#endregion
			//#region Set Server Priority to "Normal"
a652 2
			//#endregion
			//#region Set Server Priority to "High"
a668 2
			//#endregion
			//#region Get ED2K Link for Server
d676 1
a676 1
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));
a685 1
			//#endregion
d695 1
a695 1
	if (GetSelectionMark() != ( -1))
d701 1
a701 1
			               (g_App.m_pServerConnect->GetCurrentServer())->GetAddress() ) )
d1020 1
a1020 1
		FILE	*pStaticServersFile = _tfopen(g_App.m_pPrefs->GetConfigDir() + CString(_T("staticservers.dat")), _T("a"));
d1028 5
a1032 5
		if ( fprintf( pStaticServersFile, "%s:%u,%u,%s\n",
		              pServer->GetAddress(),
		              pServer->GetPort(),
		              pServer->GetPreferences(),
		              pServer->GetListName() ) != EOF )
d1056 9
a1064 7
		char		arrcBuffer[1024];
		int			iBufLen = 1024;
		int			iPos;
		CString		strStaticFilePath = g_App.m_pPrefs->GetConfigDir() + CString("staticservers.dat");
		CString		strStaticTempPath = g_App.m_pPrefs->GetConfigDir() + CString("statictemp.dat");
		FILE	   *pStaticServersFile = _tfopen(strStaticFilePath, _T("r"));
		FILE	   *pStaticTempFile = _tfopen(strStaticTempPath, _T("w"));
d1068 4
d1077 1
d1079 1
d1084 1
a1084 1
			if (fgets(arrcBuffer, iBufLen, pStaticServersFile) == 0)
d1087 2
a1088 1
			strLine = arrcBuffer;
d1091 1
a1091 1
			if (strLine.GetAt(0) == '#' || strLine.GetAt(0) == '/')
d1093 1
a1093 6
				fprintf(pStaticTempFile, arrcBuffer);
				continue;
			}
			if (strLine.GetLength() < 5)
			{
				fprintf(pStaticTempFile, arrcBuffer);
d1098 1
a1098 1
			iPos = strLine.Find(',');
a1100 3
			strLine = strLine.Left(iPos);

		//	Get host and port from given pServer
d1102 1
d1104 2
a1105 2
			if (strLine.Compare(strTest) != 0)
				fprintf(pStaticTempFile, arrcBuffer);
d1128 1
a1128 1
	CString		strTitle;
@


1.127
log
@UNICODE preparation (first shot)
@
text
@a17 1

d23 1
a23 1
//#include "Sockets/EmEngine.h"
@


1.126
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d198 1
a198 1
			hdi.pszText = (LPSTR)strRes.GetString();
d233 1
a233 1
	if (g_App.m_pServerConnect->IsConnected()
d236 1
a236 1
		&& stricmp(cur_srv->GetAddress(), server.GetAddress()) == 0)
@


1.125
log
@renamed 3 variables
@
text
@d123 1
a123 1
	if (g_App.g_pPrefs->DoUseSort())
d125 1
a125 1
		SortInit(g_App.g_pPrefs->GetServerSortCol());
d129 2
a130 2
		int	iSortColumn = g_App.g_pPrefs->GetColumnSortItem(CPreferences::TABLE_SERVER);
		bool	bSortAscending = g_App.g_pPrefs->GetColumnSortAscending(CPreferences::TABLE_SERVER);
d360 1
a360 1
	if (g_App.g_pPrefs->DeadServer())
d368 1
a368 1
			if ( pServer->GetFailedCount() >= g_App.g_pPrefs->GetDeadserverRetries()
d773 2
a774 2
	g_App.g_pPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, iSubItem | iFlags);	// Allow to save alternate criterion
	g_App.g_pPrefs->SetColumnSortAscending(CPreferences::TABLE_SERVER, bSortOrder);
d1041 1
a1041 1
		FILE	*pStaticServersFile = _tfopen(g_App.g_pPrefs->GetConfigDir() + CString(_T("staticservers.dat")), _T("a"));
d1080 2
a1081 2
		CString		strStaticFilePath = g_App.g_pPrefs->GetConfigDir() + CString("staticservers.dat");
		CString		strStaticTempPath = g_App.g_pPrefs->GetConfigDir() + CString("statictemp.dat");
d1164 1
a1164 1
			if (nCode == g_App.g_pPrefs->GetShortcutCode(SCUT_LINK))
@


1.124
log
@Corrected condition to check for dead servers it should be great or equal (instead
of great), as preferences option is called 'Remove dead server after # retries";
Removed unused code.
@
text
@d90 1
a90 1
	m_imageList.Create(16, 16, g_eMuleApp.m_iDfltImageListColorFlags | ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
d123 1
a123 1
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())
d125 1
a125 1
		SortInit(g_eMuleApp.m_pGlobPrefs->GetServerSortCol());
d129 2
a130 2
		int	iSortColumn = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_SERVER);
		bool	bSortAscending = g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_SERVER);
d233 2
a234 2
	if (g_eMuleApp.m_pServerConnect->IsConnected()
		&& (cur_srv = g_eMuleApp.m_pServerConnect->GetCurrentServer()) != NULL
d360 1
a360 1
	if (g_eMuleApp.m_pGlobPrefs->DeadServer())
d368 1
a368 1
			if ( pServer->GetFailedCount() >= g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries()
d411 1
a411 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d516 1
a516 1
						g_eMuleApp.m_pServerConnect->Disconnect();
d527 1
a527 1
								g_eMuleApp.m_pServerList->MoveServerDown(pServer);
d531 1
a531 1
						g_eMuleApp.m_pServerConnect->ConnectToAnyServer((g_eMuleApp.m_pServerList->GetServerCount() - GetSelectedCount()), false);
d534 1
a534 1
						g_eMuleApp.m_pEngine->ConnectToAnyServer();
d541 1
a541 1
						if (g_eMuleApp.m_pServerConnect->IsConnected())
d544 1
a544 1
							               g_eMuleApp.m_pServerConnect->GetCurrentServer()->GetAddress() ) )
d550 1
a550 1
						g_eMuleApp.m_pServerConnect->ConnectToServer(*GetSelectedServer());
d557 1
a557 1
							g_eMuleApp.m_pEngine->ConnectToServer(pServer);
d561 1
a561 1
					g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
d573 1
a573 1
					dlgEditServer.SetParent(&g_eMuleApp.m_pdlgEmule->m_wndServer);
d703 1
a703 1
					g_eMuleApp.CopyTextToClipboard(strLink);
d719 1
a719 1
		if (g_eMuleApp.m_pServerConnect->IsConnected())
d722 1
a722 1
			               (g_eMuleApp.m_pServerConnect->GetCurrentServer())->GetAddress() ) )
d728 1
a728 1
		g_eMuleApp.m_pServerConnect->ConnectToServer(*GetSelectedServer());
d735 1
a735 1
			g_eMuleApp.m_pEngine->ConnectToServer(pServer);
d737 1
a737 1
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
d773 2
a774 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, iSubItem | iFlags);	// Allow to save alternate criterion
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SERVER, bSortOrder);
d1041 1
a1041 1
		FILE	*pStaticServersFile = _tfopen(g_eMuleApp.m_pGlobPrefs->GetConfigDir() + CString(_T("staticservers.dat")), _T("a"));
d1080 2
a1081 2
		CString		strStaticFilePath = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + CString("staticservers.dat");
		CString		strStaticTempPath = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + CString("statictemp.dat");
d1150 1
a1150 1
	g_eMuleApp.m_pdlgEmule->m_wndServer.SetDlgItemText(IDC_SERVLIST_TEXT, strTitle);
d1164 1
a1164 1
			if (nCode == g_eMuleApp.m_pGlobPrefs->GetShortcutCode(SCUT_LINK))
@


1.123
log
@Label "Serverlist" -> "Servers".
@
text
@a363 2
#ifndef USE_SAFE_ARRAY

d368 1
a368 1
			if ( pServer->GetFailedCount() > g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries()
a374 13
#else
		for (INT_PTR pos = 0; pos < m_pServerList->array.GetCount(); pos++)
		{
			CServer	*pServer = m_pServerList->GetServerAt(pos);

			if ( pServer->GetFailedCount() > g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries()
				 && !pServer->IsStaticMember() )
			{
				RemoveServer(pServer);
				pos = 0;
			}
		}
#endif
@


1.122
log
@IDS_EM_SERVER renamed into IDS_SERVERS.
@
text
@d1164 1
a1164 1
	strTitle.Format(_T("%s (%u)"), GetResString(IDS_SV_SERVERLIST), GetItemCount());
@


1.121
log
@ED2K link shortcuts for Server and Search lists.
@
text
@d486 1
a486 1
	m_ServerMenu.AddMenuTitle(GetResString(IDS_EM_SERVER));
@


1.120
log
@Rollback of one my server list sorting improvement as it doesn't work in 100% cases.
@
text
@d505 1
a505 1
	m_ServerMenu.AppendMenu(iMenuFlags, MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
d539 1
a539 2
							iIndex = GetNextSelectedItem(pos);
							if (iIndex > -1)
d1168 25
@


1.119
log
@Rollback of "more user friendly display of Users and Files values in Server list"
(according to forum discussion); Display IP:port without spaces (like in other places).
@
text
@d808 1
a808 1
	int		iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 0 : SIGN_BIT;
d865 1
a865 1
						iSortMod = 0;		//empty entries at the bottom in any case
d872 1
a872 1
					iSortMod = 0;		//	sort always in ascending order
d882 1
a882 1
					iSortMod = SIGN_BIT;
d886 1
a886 1
					iSortMod = 0;		//	sort always in ascending order
d906 1
a906 1
					iSortMod = SIGN_BIT;
d910 1
a910 1
					iSortMod = 0;		//	sort always in ascending order
d920 1
a920 1
					iSortMod = SIGN_BIT;
d924 1
a924 1
					iSortMod = 0;		//	sort always in ascending order
d936 1
a936 1
					iSortMod = 0;		//	sort always in ascending order
d948 1
a948 1
					iSortMod = 0;		//	sort always in ascending order
d960 1
a960 1
					iSortMod = 0;		//	sort always in ascending order
d980 1
a980 1
					iSortMod = SIGN_BIT;
d984 1
a984 1
					iSortMod = 0;		//	sort always in ascending order
d1001 1
a1001 1
						iSortMod = 0;		//empty entries at the bottom in any case
d1008 1
a1008 1
					iSortMod = 0;		//	sort always in ascending order
d1025 1
a1025 1
						iSortMod = 0;		//empty entries at the bottom in any case
d1032 1
a1032 1
					iSortMod = 0;		//sort always in ascending order
d1041 1
a1041 1
					iSortMod = SIGN_BIT;
d1047 1
a1047 1
	return iCompare ^ iSortMod;
@


1.118
log
@More user friendly display of Files and User values in
 Server list + minor changes.
@
text
@d257 1
a257 1
		strTemp.Format(_T("%s : %u (%u)"), server.GetAddress(), server.GetPort(), server.GetAuxPort());
d259 1
a259 1
		strTemp.Format(_T("%s : %u"), server.GetAddress(), server.GetPort());
d273 1
a273 1
		strTemp.Format(_T("%s"), CastItoThousands(server.GetNumUsers()));
d278 1
a278 1
		strTemp.AppendFormat(_T(" (%s)"), CastItoThousands(server.GetMaxUsers()));
d283 1
a283 1
		strTemp.Format(_T("%s"), CastItoThousands(server.GetFiles()));
@


1.117
log
@Fixed server list sorting by IP (4th number of IP wasn't compared);
Fixed display of Max. Users in the server list (a number wasn't displayed when number of Users = 0);
Optimized server list sorting.
@
text
@d273 1
a273 1
		strTemp.Format(_T("%u"), server.GetNumUsers());
d276 1
d278 1
a278 1
		strTemp.AppendFormat(_T(" (%u)"), server.GetMaxUsers());
d283 1
a283 1
		strTemp.Format(_T("%u"), server.GetFiles());
@


1.116
log
@Server LowID users statistics; Unified processing of server priorities;
Fixed update of server list values (when a parameter changes from some value to zero).
@
text
@d273 1
a273 7
	{
		if (server.GetMaxUsers())
			strTemp.Format(_T("%u (%u)"), server.GetNumUsers(), server.GetMaxUsers());
		else
			strTemp.Format(_T("%u"), server.GetNumUsers());
		SetItemText(iIndex, SL_COLUMN_NUMUSERS, strTemp);
	}
d275 4
a278 1
		SetItemText(iIndex, SL_COLUMN_NUMUSERS, _T(""));
d803 1
a803 3
	int		iTemp = 0;
	int		iCounter1;
	int		iCounter2;
d807 1
a807 1
	int		iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 1 : -1;
d809 1
a809 1
	switch (iSortColumn + iSortAltFlag)
d811 1
a811 1
		case SL_COLUMN_SERVERNAME:
d813 4
a816 2
			bool	bServerHasNoName1 = _tcsstr(pServer1->GetListName(), pServer1->GetFullIP());
			bool	bServerHasNoName2 = _tcsstr(pServer2->GetListName(), pServer2->GetFullIP());
d818 4
a821 4
			if (!bServerHasNoName1 && !bServerHasNoName2)
				iCompare = _tcsicmp(pServer1->GetListName(), pServer2->GetListName());
			else
				iCompare = bServerHasNoName1 ? (bServerHasNoName2 ? 0 : 1) : -1;
d823 7
a829 4
			if (iCompare == 0)
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERIP);
			break;
		}
d831 1
a831 4
		case SL_COLUMN_SERVERIP:
		{
		//	If both are dynamic IP...
			if (pServer1->HasDynIP() && pServer2->HasDynIP())
d833 18
a850 2
				//iCompare = CString(pServer1->GetDynIP()).CompareNoCase(pServer2->GetDynIP());
				iCompare = _tcsicmp(pServer1->GetDynIP(), pServer2->GetDynIP());
d852 2
a853 12
		//	If only the first is dynamic IP...
			else if (pServer1->HasDynIP())
			{
				iCompare = -1;
			}
		//	If only the second is dynamic IP...
			else if (pServer2->HasDynIP())
			{
				iCompare = 1;
			}
		//	If both have static IPs...
			else
d855 3
a857 1
				CString		sIP1, sIP2, sTemp1, sTemp2;
d859 3
a861 15
				iCounter1 = iCounter2 = iTemp = 0;
				sIP1 = pServer2->GetFullIP();
				sIP2 = pServer1->GetFullIP();
				for (int i = 0; iTemp == 0 ; i++)
				{
					sTemp1 = sIP1.Tokenize(_T("."), iCounter1);
					sTemp2 = sIP2.Tokenize(_T("."), iCounter2);
					iTemp = _tstoi(sTemp2) - _tstoi(sTemp1);
				//	If the IPs are the same...
					if (i > 2)
					{
						iCompare = pServer1->GetPort() - pServer2->GetPort();
						break;
					}
					else if (iTemp != 0)
d863 2
a864 1
						iCompare = iTemp;
a866 3
			}
			break;
		}
d868 7
a874 11
		case SL_COLUMN_DESCRIPTION:
		{
			CString strServerDescription1 = pServer1->GetDescription();
			CString strServerDescription2 = pServer2->GetDescription();

			if (!strServerDescription1.IsEmpty() && !strServerDescription2.IsEmpty())
				iCompare = _tcsicmp(strServerDescription1, strServerDescription2);
			else
			{
				iCompare = strServerDescription1.IsEmpty() ? (strServerDescription2.IsEmpty() ? 0 : 1) : -1;
				iSortMod = 1;		//empty entries at the bottom in any case
d877 1
a877 1
			if (iCompare == 0)
d879 10
a888 2
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a889 2
			break;
		}
d891 1
a891 6
		case SL_COLUMN_PING:
		{
			iCompare = pServer1->GetPing() - pServer2->GetPing();
			if (!pServer1->GetPing() || !pServer2->GetPing())
				iSortMod = -1;
			if (iCompare == 0)
d893 20
a912 2
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a913 2
			break;
		}
d915 1
a915 6
		case SL_COLUMN_NUMUSERS:
		{
			iCompare = pServer1->GetNumUsers() - pServer2->GetNumUsers();
			if (!pServer1->GetNumUsers() || !pServer2->GetNumUsers())
				iSortMod = -1;
			if (iCompare == 0)
d917 10
a926 14
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//	sort always in ascending order
			}
			break;
		}
		case SL_COLUMN_NUMUSERS + MLC_SORTALT:    //max. users
		{
			iCompare = pServer1->GetMaxUsers() - pServer2->GetMaxUsers();
			if (!pServer1->GetMaxUsers() || !pServer2->GetMaxUsers())
				iSortMod = -1;
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a927 2
			break;
		}
d929 1
a929 6
		case SL_COLUMN_NUMFILES:
		{
			iCompare = pServer1->GetFiles() - pServer2->GetFiles();
			if (!pServer1->GetFiles() || !pServer2->GetFiles())
				iSortMod = -1;
			if (iCompare == 0)
d931 8
a938 2
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a939 2
			break;
		}
d941 1
a941 4
		case SL_COLUMN_PREFERENCES:
		{
			iCompare = pServer1->GetPreferences() - pServer2->GetPreferences();
			if (iCompare == 0)
d943 8
a950 2
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a951 2
			break;
		}
d953 1
a953 4
		case SL_COLUMN_FAILEDCOUNT:
		{
			iCompare = pServer1->GetFailedCount() - pServer2->GetFailedCount();
			if (iCompare == 0)
d955 8
a962 2
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a963 8
			break;
		}

		case SL_COLUMN_STATIC:
		{
			//	If both are static...
			int iStatic1 = pServer1->IsStaticMember() ? 1:0;
			int iStatic2 = pServer2->IsStaticMember() ? 1:0;
d965 1
a965 2
			iCompare = iStatic1 - iStatic2;
			if (iCompare == 0)
d967 20
a986 2
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
a987 2
			break;
		}
d989 1
a989 18
		case SL_COLUMN_SOFTFILELIMIT:
		{
			iCompare = pServer1->GetSoftMaxFiles() - pServer2->GetSoftMaxFiles();
			if (!pServer1->GetSoftMaxFiles() || !pServer2->GetSoftMaxFiles())
				iSortMod = -1;
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
			break;
		}
		case SL_COLUMN_SOFTFILELIMIT + MLC_SORTALT:    //Hard files asc
		{
			iCompare = pServer1->GetHardMaxFiles() - pServer2->GetHardMaxFiles();
			if (!pServer1->GetHardMaxFiles() || !pServer2->GetHardMaxFiles())
				iSortMod = -1;
			if (iCompare == 0)
d991 3
a993 5
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
			break;
		}
d995 8
a1002 4
		case SL_COLUMN_SOFTWAREVER:
		{
			CString strServerVersion1 = pServer1->GetVersion();
			CString strServerVersion2 = pServer2->GetVersion();
d1004 7
a1010 6
			if (!strServerVersion1.IsEmpty() && !strServerVersion2.IsEmpty())
				iCompare = _tcsicmp(strServerVersion1, strServerVersion2);
			else
			{
				iCompare = strServerVersion1.IsEmpty() ? (strServerVersion2.IsEmpty() ? 0 : 1) : -1;
				iSortMod = 1;		//empty entries at the bottom in any case
d1013 1
a1013 1
			if (iCompare == 0)
d1015 3
a1017 5
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
			break;
		}
d1019 8
a1026 4
		case SL_COLUMN_COUNTRY:
		{
			CString strServerCountry1 = pServer1->GetCountryName();
			CString strServerCountry2 = pServer2->GetCountryName();
d1028 7
a1034 6
			if (!strServerCountry1.IsEmpty() && !strServerCountry2.IsEmpty())
				iCompare = _tcsicmp(strServerCountry1, strServerCountry2);
			else
			{
				iCompare = strServerCountry1.IsEmpty() ? (strServerCountry2.IsEmpty() ? 0 : 1) : -1;
				iSortMod = 1;		//empty entries at the bottom in any case
d1037 5
a1041 6
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//sort always in ascending order
			}
			break;
d1043 1
a1043 9

		case SL_COLUMN_LOWIDUSERS:
			iCompare = pServer1->GetLowIDUsers() - pServer2->GetLowIDUsers();
			if ((pServer1->GetLowIDUsers() == 0) || (pServer2->GetLowIDUsers() == 0))
				iSortMod = -1;
			break;
		
		default:
			iCompare = 0;
d1046 1
a1046 1
	return iCompare * iSortMod;
@


1.115
log
@Rollbacked memset changes.
@
text
@a19 1
//
d82 2
a83 1
		{ LVCFMT_LEFT,  150 }	// SL_COLUMN_COUNTRY
d181 2
a182 1
		IDS_COUNTRY					//SL_COLUMN_COUNTRY
d254 1
a254 4
	if (server.GetListName())
	{
		SetItemText(iIndex, SL_COLUMN_SERVERNAME, server.GetListName());
	}
a256 1
	{
a257 1
	}
a258 1
	{
a259 1
	}
d262 1
a262 4
	if (server.GetDescription())
	{
		SetItemText(iIndex, SL_COLUMN_DESCRIPTION, server.GetDescription());
	}
d264 1
a264 1
	if (server.GetPing())
d266 1
a266 1
		strTemp.Format(_T("%i"), server.GetPing());
d269 2
d272 1
a272 1
	if (server.GetNumUsers())
d275 1
a275 1
			strTemp.Format(_T("%i (%i)"), server.GetNumUsers(), server.GetMaxUsers());
d277 1
a277 1
			strTemp.Format(_T("%i"), server.GetNumUsers());
d280 2
d283 1
a283 1
	if (server.GetFiles())
d285 1
a285 1
		strTemp.Format(_T("%i"), server.GetFiles());
d288 2
a293 1
		{
a295 1
		}
a296 1
		{
a298 1
		}
a299 1
		{
a301 1
		}
a302 1
		{
a303 1
		}
d308 1
a308 1
	strTemp.Format(_T("%i"), server.GetFailedCount());
d313 1
a313 1
	if (server.GetHardMaxFiles())
d315 2
a316 2
		if (server.GetSoftMaxFiles())
			strTemp.Format(_T("%i (%i)"), server.GetSoftMaxFiles(), server.GetHardMaxFiles());
d318 1
a318 1
			strTemp.Format(_T("(%i)"), server.GetHardMaxFiles());
d321 2
d325 1
d327 7
a333 1
	SetItemText(iIndex, SL_COLUMN_COUNTRY, server.GetCountryName());
d661 1
a661 1
						pServer->SetPreference(CServer::SERVERPRIORITY_LOW);
d679 1
a679 1
						pServer->SetPreference(CServer::SERVERPRIORITY_NORMAL);
d697 1
a697 1
						pServer->SetPreference(CServer::SERVERPRIORITY_HIGH);
a815 1
		//#region Server Name
d830 1
a830 2
		//#endregion
		//#region Server IP
d876 1
a876 2
		//#endregion
		//#region Description
d897 1
a897 2
		//#endregion
		//#region Ping
d910 1
a910 2
		//#endregion
		//#region Num Users / Max Users
d919 1
a919 1
				iSortMod = 1;		//eklmn: sort allways in ascending order
d935 1
a935 2
		//#endregion
		//#region Number of Files
d948 1
a948 2
		//#endregion
		//#region Preferences
d959 1
a959 2
		//#endregion
		//#region Failed Count
d970 1
a970 2
		//#endregion
		//#region Static
d985 1
a985 2
		//#endregion
		//#region Soft File Limit / Hard File Limit
d1010 1
a1010 2
		//#endregion
		//#region Software Version
d1031 1
a1031 2
		//#endregion
		//#region Country
d1048 1
a1048 1
				iSortMod = 1;		//sort allways in ascending order
d1052 7
a1058 1
		//#endregion
a1059 1
		{
a1060 1
		}
@


1.114
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d52 1
a52 1
	memset2(&m_bSortAscending, true, sizeof(m_bSortAscending));
d132 1
a132 1
		SortInit(iSortColumn | (bSortAscending ? MLC_SORTASC : MLC_SORTDESC));
d504 3
a506 3
	m_ServerMenu.AppendMenu( iMenuFlags
								| (((dwSelectedCount != 1) || pServer->IsStaticMember()) ? MF_GRAYED : MF_ENABLED),
							MP_EDIT, GetResString(IDS_FNCEDIT) );
@


1.113
log
@Use of CPU optimised memset2 function
Code refactoring
@
text
@d90 1
a90 1
	m_imageList.Create(16, 16, ILC_COLOR32 | ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
@


1.112
log
@Simplified way to display list labels with count.
@
text
@d52 1
a52 1
	memset(&m_bSortAscending, true, sizeof(m_bSortAscending));
d72 12
a83 12
		{ LVCFMT_LEFT,  150 },	//SL_COLUMN_SERVERNAME
		{ LVCFMT_LEFT,  140 },	//SL_COLUMN_SERVERIP
		{ LVCFMT_LEFT,  150 },	//SL_COLUMN_DESCRIPTION
		{ LVCFMT_RIGHT,  50 },	//SL_COLUMN_PING
		{ LVCFMT_RIGHT,  50 },	//SL_COLUMN_NUMUSERS
		{ LVCFMT_RIGHT,  50 },	//SL_COLUMN_NUMFILES
		{ LVCFMT_LEFT,   60 },	//SL_COLUMN_PREFERENCES
		{ LVCFMT_RIGHT,  50 },	//SL_COLUMN_FAILEDCOUNT
		{ LVCFMT_LEFT,   50 },	//SL_COLUMN_STATIC
		{ LVCFMT_RIGHT, 100 },	//SL_COLUMN_SOFTFILELIMIT
		{ LVCFMT_LEFT,  150 },	//SL_COLUMN_SOFTWAREVER
		{ LVCFMT_LEFT,  150 }	//SL_COLUMN_COUNTRY
d132 1
a132 1
		SortInit(iSortColumn | ((bSortAscending) ? MLC_SORTASC : MLC_SORTDESC));
d139 3
a141 3
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);			//the sort column
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;	//the sort order
	int		iSortAltFlag = (iSortCode & MLC_SORTALT);			//the alternate sort
d504 3
a506 3
	m_ServerMenu.AppendMenu( iMenuFlags |
		(((dwSelectedCount != 1) || pServer->IsStaticMember()) ? MF_GRAYED : MF_ENABLED),
		MP_EDIT, GetResString(IDS_FNCEDIT) );
d665 1
a665 1
							StaticServerFileAppend(pServer);	//RefreshServer is called inside
d683 1
a683 1
							StaticServerFileAppend(pServer);	//RefreshServer is called inside
d701 1
a701 1
							StaticServerFileAppend(pServer);	//RefreshServer is called inside
d793 1
a793 1
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, iSubItem | iFlags);	//allow to save alternate criterion
@


1.111
log
@Removed 'Remove all Servers' menu item;
Minor correction for double-level sorting order in the server list;
Allow to save double-level sorting state for the server list
when default sorting setting are not in use.
@
text
@d209 1
a209 2
		if (GetItemCount() != 0)
			ShowFilesCount();
@


1.110
log
@Faster image lists icon loading; reduced memory usage.
@
text
@d132 1
a132 1
		SortInit(iSortColumn | (bSortAscending ? MLC_SORTASC : MLC_SORTDESC));
d139 3
a141 2
//	Get the sort column
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);
d143 2
a144 4
//	Get the sort order
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
//	Get the alternate sort
	int		iSortAltFlag = (iSortCode & MLC_SORTALT);
d148 5
d154 1
d157 5
a161 1
		SetSortArrow(iSortColumn, bSortAscending ? arrowDoubleUp : arrowDoubleDown);
d504 1
a504 1
	m_ServerMenu.AppendMenu(MF_STRING | MF_SEPARATOR);
a508 1
	m_ServerMenu.AppendMenu(MF_STRING, MP_REMOVEALL, GetResString(IDS_REMOVEALL));
a519 19
	if (wParam == MP_REMOVEALL)
	{
#ifdef OLD_SOCKETS_ENABLED
		if (g_eMuleApp.m_pServerConnect->IsConnecting())
		{
			g_eMuleApp.m_pDownloadQueue->StopUDPRequests();
			g_eMuleApp.m_pServerConnect->StopConnectionTry();
			g_eMuleApp.m_pServerConnect->Disconnect();
			g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
		}
#endif //OLD_SOCKETS_ENABLED
		SetRedraw(FALSE);
		m_pServerList->RemoveAllServers();
		DeleteAllItems();
		SetRedraw(TRUE);
		ShowFilesCount();
		return true;
	}

d792 1
a792 1
	SortItems(SortProc, iSubItem + iFlags + ((bSortOrder) ? MLC_SORTASC : MLC_SORTDESC));
d794 1
a794 1
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, iSubItem);
@


1.109
log
@Fixed loading of incorrect sorting settings {DonGato}.
@
text
@d90 1
a90 1
	m_imageList.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 10);
@


1.108
log
@Reduced number of list updates after change of some server settings;
Improve string processing; Call local methods as local methods.
@
text
@a141 4
//	Check max. column in case of configuration file corruption
	if (static_cast<uint32>(iSortColumn) >= SL_COLUMN_NUMCOLUMNS)
		iSortCode = iSortColumn = SL_COLUMN_SERVERNAME;

@


1.107
log
@Unified list column creature; Improved string processing;
Set list column labels only in one place to avoid future incorrections.
@
text
@d616 1
a616 1
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
a650 2
						pServer->SetIsStaticMember(true);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
a665 2
						pServer->SetIsStaticMember(false);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d677 1
a677 1
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));
d681 3
a683 2
							StaticServerFileAppend(pServer);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d695 1
a695 1
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));
d699 3
a701 2
							StaticServerFileAppend(pServer);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d713 1
a713 1
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));
d717 3
a719 2
							StaticServerFileAppend(pServer);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
d1107 1
a1107 2
		if ( fprintf( pStaticServersFile,
		              "%s:%i,%i,%s\n",
d1114 1
a1114 1
				AddLogLine(false, _T("'%s:%i,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_ADDED2SSF));
d1116 1
a1116 1
			g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
a1134 2
		CString		strLine;
		CString		strTest;
d1140 2
a1141 2
		FILE	   *pStaticServersFile = _tfopen(strStaticFilePath , _T("r"));
		FILE	   *pStaticTempFile = _tfopen(strStaticTempPath , _T("w"));
d1149 4
a1178 1
			strTest.Format(_T("%s:%i"), pServer->GetAddress(), pServer->GetPort());
d1192 1
a1192 1
		AddLogLine(false, _T("'%s:%i,%s' %s"), pServer->GetAddress(), pServer->GetPort(), pServer->GetListName(), GetResString(IDS_REMOVEDFROMSSF));
d1194 1
a1194 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*pServer);
@


1.106
log
@Faster list header localizations.
@
text
@d70 15
d97 2
a98 16
	InsertColumn(SL_COLUMN_SERVERNAME, GetResString(IDS_SL_SERVERNAME), LVCFMT_LEFT, 150);
	InsertColumn(SL_COLUMN_SERVERIP, GetResString(IDS_IP), LVCFMT_LEFT, 140);
	InsertColumn(SL_COLUMN_DESCRIPTION, GetResString(IDS_DESCRIPTION) , LVCFMT_LEFT, 150);
	InsertColumn(SL_COLUMN_PING, GetResString(IDS_PING), LVCFMT_RIGHT, 50);

	CString	strTemp;

	strTemp.Format(_T("%s (%s)"), GetResString(IDS_UUSERS), GetResString(IDS_MAXUSERS));
	InsertColumn(SL_COLUMN_NUMUSERS, strTemp, LVCFMT_RIGHT, 50);
	InsertColumn(SL_COLUMN_NUMFILES, GetResString(IDS_FILES) , LVCFMT_RIGHT, 50);
	InsertColumn(SL_COLUMN_PREFERENCES, GetResString(IDS_PRIORITY), LVCFMT_LEFT, 60);
	InsertColumn(SL_COLUMN_FAILEDCOUNT, GetResString(IDS_UFAILED), LVCFMT_RIGHT, 50);
	InsertColumn(SL_COLUMN_STATIC, GetResString(IDS_STATICSERVER), LVCFMT_LEFT, 50);
	InsertColumn(SL_COLUMN_SOFTFILELIMIT, GetResString(IDS_SERVER_SOFTHARDLIMIT), LVCFMT_RIGHT, 100);
	InsertColumn(SL_COLUMN_SOFTWAREVER, GetResString(IDS_SERVER_VERSION), LVCFMT_LEFT, 150);
	InsertColumn(SL_COLUMN_COUNTRY, GetResString(IDS_COUNTRY) , LVCFMT_LEFT, 150);
d226 1
a226 1
	UINT		iItemState = 0;
d294 1
a294 1
			SetItemText(iIndex, SL_COLUMN_PREFERENCES, GetResString(IDS_PRIOLOW));
d299 1
a299 1
			SetItemText(iIndex, SL_COLUMN_PREFERENCES, GetResString(IDS_PRIONORMAL));
d304 1
a304 1
			SetItemText(iIndex, SL_COLUMN_PREFERENCES, GetResString(IDS_PRIOHIGH));
d309 1
a309 1
			SetItemText(iIndex, SL_COLUMN_PREFERENCES, GetResString(IDS_PRIONOPREF));
d312 2
@


1.105
log
@Fixed list sorting direction while switching <thanks xrmb>; minor optimization.
@
text
@d162 16
d180 3
a182 2
		CHeaderCtrl	* pHeaderCtrl = GetHeaderCtrl();
		HDITEM	hdi;
d186 8
a193 61
		CString	strRes;

		strRes = GetResString(IDS_SL_SERVERNAME);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_SERVERNAME, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_IP);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_SERVERIP, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_DESCRIPTION);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_DESCRIPTION, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_PING);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_PING, &hdi);
		strRes.ReleaseBuffer();

		strRes.Format(_T("%s (%s)"), GetResString(IDS_UUSERS), GetResString(IDS_MAXUSERS));
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_NUMUSERS, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_FILES);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_NUMFILES, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_PRIORITY);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_PREFERENCES, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_UFAILED);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_FAILEDCOUNT, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_STATICSERVER);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_STATIC, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_SERVER_SOFTHARDLIMIT);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_SOFTFILELIMIT, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_SERVER_VERSION);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_SOFTWAREVER, &hdi);
		strRes.ReleaseBuffer();

		strRes = GetResString(IDS_COUNTRY);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_COUNTRY, &hdi);
		strRes.ReleaseBuffer();
@


1.104
log
@Added "connected server failed" server status
@
text
@d52 1
a52 1
	memzero(&m_bSortAscending, sizeof(m_bSortAscending));
d99 5
a103 5
	m_bSortAscending[SL_COLUMN_NUMUSERS] = true;
	m_bSortAscending[SL_COLUMN_NUMFILES] = true;
	m_bSortAscending[SL_COLUMN_FAILEDCOUNT] = true;
	m_bSortAscending[SL_COLUMN_SOFTFILELIMIT] = true;
	m_bSortAscending[SL_COLUMN_SOFTWAREVER] = true;
d815 3
a817 1
	NM_LISTVIEW	* pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);
a818 2
	int	iFlags = 0;
//
d820 1
a820 1
	if (pNMListView->iSubItem == SL_COLUMN_NUMUSERS)
d822 1
a822 1
		if (m_bSortAscending[SL_COLUMN_NUMUSERS])
d826 1
a826 1
	if (pNMListView->iSubItem == SL_COLUMN_SOFTFILELIMIT)
d828 1
a828 1
		if (m_bSortAscending[SL_COLUMN_SOFTFILELIMIT])
d832 5
a836 3
//	if it's a second click on the same column then reverse the sort order,
//	otherwise sort the new column in ascending order.
	m_bSortAscending[pNMListView->iSubItem] = !m_bSortAscending[pNMListView->iSubItem];
d838 1
a838 1
		SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem]);
d840 2
a841 2
		SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem] ? arrowDoubleUp : arrowDoubleDown);
	SortItems(SortProc, pNMListView->iSubItem + iFlags + ((m_bSortAscending[pNMListView->iSubItem]) ? MLC_SORTASC : MLC_SORTDESC)); // double arrows
d843 2
a844 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, pNMListView->iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SERVER, m_bSortAscending[pNMListView->iSubItem]);
@


1.103
log
@Minor fixes
@
text
@d65 2
d268 1
a268 1
		iImageIndex = 2;
d271 1
a271 2

	if (server.GetFailedCount() > 0 && !g_eMuleApp.m_pServerConnect->IsConnected())
d273 1
a273 1
		iImageIndex = 4;
@


1.102
log
@...
@
text
@d270 1
a270 1
	if (server.GetFailedCount() > 0)
@


1.101
log
@Minor changes and hopefully fixed the problem with disconnected servers highlighting not being removed
@
text
@d270 1
a270 1
	if (server.GetFailedCount() > 0 && !server.IsStaticMember())
d273 2
a274 1
		iItemState |= LVIS_CUT;
@


1.100
log
@Dim servers that has failed once or more ( with DonGato's approval :-) )
@
text
@d270 1
a270 1
	if (server.GetFailedCount() > 0)
@


1.99
log
@minor changes, fixes and improvements
@
text
@d259 1
a265 1
		SetItemState(iIndex, LVIS_GLOW, LVIS_GLOW);
d267 1
a268 2
	else
		SetItemState(iIndex, 0, LVIS_GLOW);
d271 1
d273 2
d279 1
@


1.98
log
@Readded a code removed by an over-optimization
@
text
@d454 3
@


1.97
log
@added tooltips to the Server list
@
text
@d69 2
@


1.96
log
@Find in lists
@
text
@d344 1
a344 4
	if (server.IsStaticMember())
		SetItemText(iIndex, SL_COLUMN_STATIC, GetResString(IDS_YES));
	else
		SetItemText(iIndex, SL_COLUMN_STATIC, GetResString(IDS_NO));
@


1.95
log
@added icon indication in server list for static servers
@
text
@d54 1
@


1.94
log
@Connected server and failed servers icon indication in server list
@
text
@d61 1
d63 3
a65 1
		IDI_SERVERFAILED
d263 1
a263 1
		iImageIndex++;
d267 1
d269 5
a273 1
		iImageIndex = 2;
@


1.93
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d58 6
a63 1
	static const uint16 s_auIconResID[] = { IDI_SMALLSERVER };
a182 1

d250 3
a252 1
	CServer *cur_srv;
d258 1
d260 2
d264 3
a266 2

	CString	strTemp;
@


1.92
log
@Removed erroneous ModifyStyle; Improve image list filling;
Removed valid ModifyStyle because it is implemented in the base class.
@
text
@d236 1
a236 1
	::ZeroMemory(&find, sizeof(LVFINDINFO));
d246 10
a345 1

@


1.91
log
@added priority indicators (context menu)
@
text
@d58 2
a59 1
	ModifyStyle(0, TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS);
d64 2
a65 2
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SMALLSERVER), 16, 16));
	LoadImgLstIcon(NULL, 0, 0);
a66 2
	SetImageList(&m_imageList, LVSIL_SMALL); //TVSIL_NORMAL);
	ModifyStyle(LVS_SINGLESEL | LVS_LIST | LVS_ICON | LVS_SMALLICON, LVS_REPORT); //here the CListCtrl is set to report-style
@


1.90
log
@minor changes
@
text
@d471 12
a482 3
	m_ServerPrioMenu.AppendMenu(MF_STRING, MP_PRIOLOW, GetResString(IDS_PRIOLOW));
	m_ServerPrioMenu.AppendMenu(MF_STRING, MP_PRIONORMAL, GetResString(IDS_PRIONORMAL));
	m_ServerPrioMenu.AppendMenu(MF_STRING, MP_PRIOHIGH, GetResString(IDS_PRIOHIGH));
@


1.89
log
@Please, DO NOT alter column order. This messes with users column customization and don't bring a standard as people likings are different.
@
text
@d332 1
a332 4
	if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
	{
		SetItemText(iIndex, SL_COLUMN_COUNTRY, server.GetCountryName());
	}
@


1.88
log
@added Country column in server list
@
text
@a71 1
	InsertColumn(SL_COLUMN_COUNTRY, GetResString(IDS_COUNTRY) , LVCFMT_LEFT, 150);
d85 1
a168 5
		strRes = GetResString(IDS_COUNTRY);
		hdi.pszText = strRes.GetBuffer();
		pHeaderCtrl->SetItem(SL_COLUMN_COUNTRY, &hdi);
		strRes.ReleaseBuffer();

d215 5
a263 5
	if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
	{
		SetItemText(iIndex, SL_COLUMN_COUNTRY, server.GetCountryName());
	}

d331 5
a888 22
		//#region Country
		case SL_COLUMN_COUNTRY:
		{
			CString strServerCountry1 = pServer1->GetCountryName();
			CString strServerCountry2 = pServer2->GetCountryName();

			if (!strServerCountry1.IsEmpty() && !strServerCountry2.IsEmpty())
				iCompare = _tcsicmp(strServerCountry1, strServerCountry2);
			else
			{
				iCompare = strServerCountry1.IsEmpty() ? (strServerCountry2.IsEmpty() ? 0 : 1) : -1;
				iSortMod = 1;		//empty entries at the bottom in any case
			}

			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2,SL_COLUMN_SERVERNAME);
				iSortMod = 1;		//sort allways in ascending order
			}
			break;
		}
		//#endregion
d1053 22
@


1.87
log
@List hide/show is changed into redraw disable/enable to eliminate graphical blinks.
@
text
@d70 5
a74 4
	InsertColumn(0, GetResString(IDS_SL_SERVERNAME), LVCFMT_LEFT, 150);
	InsertColumn(1, GetResString(IDS_IP), LVCFMT_LEFT, 140);
	InsertColumn(2, GetResString(IDS_DESCRIPTION) , LVCFMT_LEFT, 150);
	InsertColumn(3, GetResString(IDS_PING), LVCFMT_RIGHT, 50);
d79 13
a91 13
	InsertColumn(4, strTemp, LVCFMT_RIGHT, 50);
	InsertColumn(5, GetResString(IDS_FILES) , LVCFMT_RIGHT, 50);
	InsertColumn(6, GetResString(IDS_PRIORITY), LVCFMT_LEFT, 60);
	InsertColumn(7, GetResString(IDS_UFAILED), LVCFMT_RIGHT, 50);
	InsertColumn(8, GetResString(IDS_STATICSERVER), LVCFMT_LEFT, 50);
	InsertColumn(9, GetResString(IDS_SERVER_SOFTHARDLIMIT), LVCFMT_RIGHT, 100);
	InsertColumn(10, GetResString(IDS_SERVER_VERSION), LVCFMT_LEFT, 150);

	m_bSortAscending[4] = true;
	m_bSortAscending[5] = true;
	m_bSortAscending[7] = true;
	m_bSortAscending[9] = true;
	m_bSortAscending[10] = true;
d161 1
a161 1
		pHeaderCtrl->SetItem(0, &hdi);
d166 6
a171 1
		pHeaderCtrl->SetItem(1, &hdi);
d176 1
a176 1
		pHeaderCtrl->SetItem(2, &hdi);
d181 1
a181 1
		pHeaderCtrl->SetItem(3, &hdi);
d187 1
a187 1
		pHeaderCtrl->SetItem(4, &hdi);
d192 1
a192 1
		pHeaderCtrl->SetItem(5, &hdi);
d197 1
a197 1
		pHeaderCtrl->SetItem(6, &hdi);
d202 1
a202 1
		pHeaderCtrl->SetItem(7, &hdi);
d207 1
a207 1
		pHeaderCtrl->SetItem(8, &hdi);
d212 1
a212 1
		pHeaderCtrl->SetItem(9, &hdi);
d217 1
a217 1
		pHeaderCtrl->SetItem(10, &hdi);
d247 1
a247 1
	CString	strTemp, strCountry;
d249 4
a252 2
	if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
		 strCountry.Format(_T(" (%s)"), server.GetCountryName());
d256 1
a256 1
		strTemp.Format(_T("%s : %u (%u)%s"), server.GetAddress(), server.GetPort(), server.GetAuxPort(), strCountry);
d260 1
a260 1
		strTemp.Format(_T("%s : %u%s"), server.GetAddress(), server.GetPort(), strCountry);
d262 3
a264 2
	SetItemText(iIndex, 1, strTemp);
	if (server.GetListName())
d266 1
a266 1
		SetItemText(iIndex, 0, server.GetListName());
d268 1
d271 1
a271 1
		SetItemText(iIndex, 2, server.GetDescription());
d273 1
d277 1
a277 1
		SetItemText(iIndex, 3, strTemp);
d279 1
d286 1
a286 1
		SetItemText(iIndex, 4, strTemp);
d288 1
d292 1
a292 1
		SetItemText(iIndex, 5, strTemp);
d294 1
d299 1
a299 1
			SetItemText(iIndex, 6, GetResString(IDS_PRIOLOW));
d304 1
a304 1
			SetItemText(iIndex, 6, GetResString(IDS_PRIONORMAL));
d309 1
a309 1
			SetItemText(iIndex, 6, GetResString(IDS_PRIOHIGH));
d314 1
a314 1
			SetItemText(iIndex, 6, GetResString(IDS_PRIONOPREF));
d319 1
a319 1
	SetItemText(iIndex, 7, strTemp);
d322 1
a322 1
		SetItemText(iIndex, 8, GetResString(IDS_YES));
d324 1
a324 1
		SetItemText(iIndex, 8, GetResString(IDS_NO));
d332 1
a332 1
		SetItemText(iIndex, 9, strTemp);
d335 1
a335 1
	SetItemText(iIndex, 10, server.GetVersion());
d780 1
a780 1
	if (pNMListView->iSubItem == 4)
d782 3
a784 3
		if (m_bSortAscending[4])
			m_bSortAscending[11] = !m_bSortAscending[11];
		iFlags = m_bSortAscending[11] ? 0 : MLC_SORTALT;
d786 1
a786 1
	if (pNMListView->iSubItem == 9)
d788 3
a790 3
		if (m_bSortAscending[9])
			m_bSortAscending[12] = !m_bSortAscending[12];
		iFlags = m_bSortAscending[12] ? 0 : MLC_SORTALT;
d889 22
@


1.86
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d353 1
a353 1
		ShowWindow(SW_HIDE);
d381 1
a381 1
		ShowWindow(SW_SHOW);
d603 1
a603 1
					ShowWindow(SW_HIDE);
d615 1
a615 1
					ShowWindow(SW_SHOW);
@


1.85
log
@List hide/show is changed into redraw disable/enable to eliminate graphical blink;
Old stuff removal.
@
text
@d27 1
d241 4
a244 1
	CString	strTemp;
d248 1
a248 1
		strTemp.Format(_T("%s : %u (%u)"), server.GetAddress(), server.GetPort(), server.GetAuxPort());
d252 1
a252 1
		strTemp.Format(_T("%s : %u"), server.GetAddress(), server.GetPort());
d324 11
@


1.84
log
@Unrequired #include removal.
@
text
@a479 2
	int	iIndex = GetSelectionMark();

d491 1
a491 1
		ShowWindow(SW_HIDE);
d494 1
a494 1
		ShowWindow(SW_SHOW);
d499 2
a707 19
			//#region IRC Set Send Link
				case Irc_SetSendLink:
				{
					POSITION	pos = GetFirstSelectedItemPosition();
					CString	strBuffer, strLink;

					while (pos != NULL)
					{
						CServer	* pServer = GetServerAt(GetNextSelectedItem(pos));

						strBuffer.Format(_T("ed2k://|server|%s|%d|/"), pServer->GetFullIP(), pServer->GetPort());
						if (strLink.GetLength() > 0)
							strBuffer = _T("\n") + strBuffer;
						strLink += strBuffer;
					}
					g_eMuleApp.m_pdlgEmule->m_wndIRC.SetSendFileString(strLink);
					break;
				}
			//#endregion
@


1.83
log
@optimization of sorting over SetRedraw
@
text
@a26 1
#include "InputBox.h"
@


1.82
log
@corrected use of SetRedraw
@
text
@a136 3
// No redraw until list is sorted
	SetRedraw(false);

a144 3

	//	Draw filled and sorted list
	SetRedraw(true);
@


1.81
log
@added auxiliary port support from KuSh (commited with eklmn's authorization)
@
text
@a93 3
// No redraw until list is filled
	SetRedraw(false);

a120 2
//	Draw filled and sorted list
	SetRedraw(true);
d137 3
d148 3
@


1.80
log
@Fixed initial sorting of server list by Static criteria;
Added protection against incorrect configuration parameter;
Faster initial sorting of server list.
@
text
@d248 8
a255 1
	strTemp.Format(_T("%s : %i"), server.GetAddress(), server.GetPort());
d391 1
a391 1
bool CServerListCtrl::AddServer(CServer *pServer, bool bAddToList, bool bBulkLoad)
d396 1
a396 1
	if (!m_pServerList->AddServer(pServer))
d399 1
a399 1
	if (bAddToList)
d472 1
a472 1
		MP_RENAME, GetResString(IDS_RENAME) );
d572 1
a572 1
				case MP_RENAME:
d575 10
a584 8
					InputBox inputbox;

					inputbox.SetLabels(GetResString(IDS_RENAME),pServer->GetListName());
					inputbox.DoModal();

					CString strNewName = inputbox.GetInput();

					if (!inputbox.WasCancelled() && strNewName.GetLength()>0)
a585 1
						pServer->SetListName(strNewName);
@


1.79
log
@corrected Server addition in ServerList
@
text
@d52 1
a52 1
	memzero(&m_bSortAscending, 13);
d94 18
d123 3
a125 10

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServerListCtrl::~CServerListCtrl()
{}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CServerListCtrl::OnDestroy()
{
	m_imageList.DeleteImageList();
d131 6
a136 1
	const int		iSortColumn = (iSortCode & MLC_COLUMNMASK);
d138 1
a138 1
	bool		bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
a146 1
		m_bSortAscending[iSortColumn] = bSortAscending;
d149 1
a149 1
	SortItems(&SortProc, iSortCode);
d787 1
a787 1
	SortItems(&SortProc, pNMListView->iSubItem + iFlags + ((m_bSortAscending[pNMListView->iSubItem]) ? MLC_SORTASC : MLC_SORTDESC)); // double arrows
d798 1
a798 1
	CServer	* pServer1 = reinterpret_cast<CServer*>(lParam1);
a807 1
	bool	bSortAscending = (lParamSort & MLC_SORTDESC) == 0;
d810 1
a810 1
	int		iSortMod = bSortAscending ? 1 : -1;
@


1.78
log
@Corrected update of list title after language change (number of servers in the list was lost).
@
text
@a744 12
bool CServerListCtrl::AddServerMetToList(CString strFile)
{
	SetRedraw(false);

	bool	bSucceeded = m_pServerList->AddServerMetToList(strFile);

	RemoveDeadServer();
	ShowFilesCount();
	SetRedraw(true);
	return bSucceeded;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.77
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d212 2
a218 1

a230 1

a355 1

d1161 1
a1161 1
	CString		strCount;
d1163 2
a1164 2
	strCount.Format(_T(" (%i)"), GetItemCount());
	g_eMuleApp.m_pdlgEmule->m_wndServer.GetDlgItem(IDC_SERVLIST_TEXT)->SetWindowText(GetResString(IDS_SV_SERVERLIST) + strCount);
@


1.76
log
@fixed intial sorting in advanced mode
@
text
@d458 1
a458 1
	m_ServerMenu.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.75
log
@Improved context menu creation;
Multiple link copy to clipboard is more compatible.
@
text
@d120 1
a120 1
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);
d122 1
a122 1
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
d130 4
a133 1
		SetSortArrow(iSortColumn, m_bSortAscending[iSortColumn] ? arrowDoubleUp : arrowDoubleDown);
@


1.74
log
@Minor change over one of my changes :P
@
text
@a416 1
	CServer	*pServer = NULL;
d418 4
a421 2
	if (GetSelectionMark() != -1)
		pServer = GetSelectedServer();
d424 1
a424 6
	iMenuFlags = MF_STRING || MF_DISABLED;
	if (GetSelectionMark() != ( -1) && GetSelectedCount() > 0)
	{
		if (pServer != NULL)
			iMenuFlags = MF_STRING;
	}
d437 1
a437 1
	if (pServer != NULL && GetSelectedCount() > 0)
d446 3
a448 2
	m_ServerMenu.AppendMenu(iMenuFlags, MP_RENAME, GetResString(IDS_RENAME));
	m_ServerMenu.EnableMenuItem(MP_RENAME,((GetSelectedCount() != 1 || pServer->IsStaticMember()) ? MF_GRAYED:MF_ENABLED));
d457 1
a457 2
	m_ServerPrioMenu.DestroyMenu();
	m_ServerMenu.DestroyMenu();
d680 1
a680 1
						strBuffer.Format(_T("ed2k://|server|%s|%d|/"), pServer->GetFullIP(), pServer->GetPort());
d682 1
a682 1
							strBuffer = _T("\n") + strBuffer;
@


1.73
log
@Added rename option to serverlist context menu
@
text
@d451 1
a451 1
	m_ServerMenu.EnableMenuItem(MP_RENAME,((GetSelectedCount() == 1 && pServer->IsStaticMember()) ? MF_GRAYED:MF_ENABLED));
@


1.72
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d27 1
d450 2
d551 19
@


1.71
log
@*** empty log message ***
@
text
@d51 1
a51 1
	memset2(&m_bSortAscending, 0, 13);
@


1.70
log
@better sort Proc, unknow things are kept at the end of the list
@
text
@d765 4
a770 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, pNMListView->iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SERVER, m_bSortAscending[pNMListView->iSubItem]);
@


1.69
log
@More Kush changes for localization, minor optimizations and fix for Upload AutoPriority.
@
text
@d879 2
d893 2
d905 2
d919 2
d973 2
d985 2
@


1.68
log
@Compilation fix
@
text
@d199 9
d864 1
a864 1
				iSortMod = 1;		//empty entries at the bottom in any case 
d866 1
a866 1
			
d994 1
a994 1
				iSortMod = 1;		//empty entries at the bottom in any case 
d996 1
a996 1
			
@


1.67
log
@Fix for serverlist sort & reverted a change that rendered the dyndns connection unusable
@
text
@d25 1
a25 1
#include "Sockets/EmEngine.h"
@


1.66
log
@Fixed alt sorts (hopefully)
@
text
@d121 3
a123 1
	bool		bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
d125 5
a129 1
	SetSortArrow(iSortColumn, bSortAscending);
a130 1
	m_bSortAscending[iSortColumn] = bSortAscending;
@


1.65
log
@Separating engine and GUI
@
text
@d25 1
d501 3
d521 8
d699 7
d707 1
d771 1
d774 1
a774 1
	switch (iSortColumn)
@


1.64
log
@Separating engine and GUI
@
text
@a499 3
#else OLD_SOCKETS_ENABLED

						g_eMuleApp.m_pEngine->ConnectToAnyServer();
a516 8
#ifdef NEW_SOCKETS

						CServer	*pServer = GetSelectedServer();

						if (pServer != NULL)
							g_eMuleApp.m_pEngine->ConnectToServer(pServer);
#endif NEW_SOCKETS

a686 7
#ifdef NEW_SOCKETS

		CServer	*pServer = GetSelectedServer();

		if (pServer != NULL)
			g_eMuleApp.m_pEngine->ConnectToServer(pServer);
#else
a687 1
#endif //NEW_SOCKETS
@


1.63
log
@sorting fix: empty entry are always at the bottom
@
text
@a24 1
#include "Sockets/EmEngine.h"
@


1.62
log
@double-click issue
@
text
@d847 1
d849 2
d977 1
d979 2
@


1.61
log
@Formatting, comments, and name changes.
@
text
@d119 1
a119 1
	int			iSortColumn = (iSortCode & MLC_COLUMNMASK);
d125 1
@


1.60
log
@new sorting (additional column is allways in ascending order)
@
text
@d95 1
a95 1
		SortInit((int)g_eMuleApp.m_pGlobPrefs->GetServerSortCol());
d118 3
a120 3
	//get a column
	int		iSortColumn = (iSortCode & MLC_COLUMNMASK);
	//get an order
d768 1
a768 2
	
	bool		bSortAscending = (lParamSort & MLC_SORTDESC) == 0;
@


1.59
log
@sort arrows sometimes doesn't show up
@
text
@d121 1
a121 1
	bool	bSortAscending = (iSortCode & MLC_SORTDESC) == 0;
d850 1
d852 2
d862 1
d864 2
d874 1
d876 2
d884 1
d886 2
d896 1
d898 2
d908 1
d910 2
d920 1
d922 2
a934 1

d936 1
d938 2
d948 1
d950 2
d958 1
d960 2
d972 1
a972 1
				iCompare = (int)_tcsicmp(strServerVersion1, strServerVersion2);
d977 1
d979 2
@


1.58
log
@fixed sorting in serverlist
@
text
@d95 1
a95 1
		SortInit(g_eMuleApp.m_pGlobPrefs->GetServerSortCol());
d118 4
a121 2
	bool	bSortDesc = (iSortCode & MLC_SORTDESC) == 0;
	int	iCurrentSortItem = !bSortDesc ? iSortCode : iSortCode - MLC_SORTDESC;
d123 1
a123 1
	SetSortArrow(iCurrentSortItem, !bSortDesc);
d910 2
a911 2
			int iStatic1 = pServer1->IsStaticMember() ? 0:1;
			int iStatic2 = pServer2->IsStaticMember() ? 0:1;
d943 1
a943 1
				iCompare = (int)_tcsicmp(strServerVersion1, strServerVersion2)*(-1);
@


1.57
log
@New sockets - minor progress :(
@
text
@d766 2
a767 1
	bool	bSortAscending = (lParamSort & MLC_SORTDESC) == 0;
d795 2
a796 1
				iCompare = CString(pServer1->GetDynIP()).CompareNoCase(pServer2->GetDynIP());
d839 10
a848 1
			iCompare = pServer1->GetDescription().CompareNoCase(pServer2->GetDescription());
d851 1
a851 1
	//#endregion
d855 3
a857 4
			if (pServer1->GetPing() > 0 && pServer2->GetPing() > 0)
				iCompare = pServer1->GetPing() - pServer2->GetPing();
			else
				iCompare = (pServer2->GetPing() > 0) ? 1 : ((pServer1->GetPing() > 0) ? 0 : -1);
d864 3
a866 4
			if (pServer1->GetNumUsers() > 0 && pServer2->GetNumUsers() > 0)
				iCompare = pServer1->GetNumUsers() - pServer2->GetNumUsers();
			else
				iCompare = (pServer2->GetNumUsers() > 0) ? 2 : ((pServer1->GetNumUsers() > 0) ? 0 : -1);
d871 3
a873 8
			if (pServer1->GetMaxUsers() == pServer2->GetMaxUsers())
				iCompare = 0;
			else if (pServer1->GetMaxUsers() == 0)
				iCompare = 1;
			else if (pServer2->GetMaxUsers() == 0)
				iCompare = -1;
			else
				iCompare = pServer1->GetMaxUsers() - pServer2->GetMaxUsers();
d880 3
a882 4
			if (pServer1->GetFiles() > 0 && pServer2->GetFiles() > 0)
				iCompare = pServer1->GetFiles() - pServer2->GetFiles();
			else
				iCompare = (pServer2->GetFiles() > 0) ? 1 : ((pServer1->GetFiles() > 0) ? 0 : -1);
d890 2
d899 2
d907 5
a911 6
		//	If both are static...
			if ( (pServer2->IsStaticMember() && pServer1->IsStaticMember())
			  || (!pServer2->IsStaticMember() && !pServer1->IsStaticMember()) )
			{
				bool	bServerHasNoName1 = _tcsstr(pServer1->GetListName(), pServer1->GetFullIP());
				bool	bServerHasNoName2 = _tcsstr(pServer2->GetListName(), pServer2->GetFullIP());
d913 2
a914 15
				if (!bServerHasNoName1 && !bServerHasNoName2)
					iCompare = _tcsicmp(pServer1->GetListName(), pServer2->GetListName()) * iSortMod;
				else
					iCompare = bServerHasNoName1 ? (bServerHasNoName2 ? 0 : 1) : -1;
			}
		//	If only the first is static...
			else if (pServer1->IsStaticMember())
			{
				iCompare = -1;
			}
		//	If only the second is static...
			else if (pServer2->IsStaticMember())
			{
				iCompare = 1;
			}
d921 3
a923 4
			if ((pServer1->GetSoftMaxFiles() > 0 && pServer2->GetSoftMaxFiles() > 0) || (pServer1->GetHardMaxFiles() > 0 && pServer2->GetHardMaxFiles() > 0))
				iCompare = pServer1->GetSoftMaxFiles() - pServer2->GetSoftMaxFiles();
			else
				iCompare = (pServer2->GetSoftMaxFiles() > 0) ? 1 : ((pServer1->GetSoftMaxFiles() > 0) ? 0 : -1);
d928 3
a930 4
			if (pServer1->GetHardMaxFiles() > 0 && pServer2->GetHardMaxFiles() > 0)
				iCompare = pServer1->GetHardMaxFiles() - pServer2->GetHardMaxFiles();
			else
				iCompare = (pServer2->GetHardMaxFiles() > 0) ? 1 : ((pServer1->GetHardMaxFiles() > 0) ? 0 : -1);
d937 10
a946 1
			iCompare = pServer1->GetVersion().CompareNoCase(pServer2->GetVersion());
@


1.56
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d702 2
a704 2

		g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
@


1.55
log
@Fix for server list sorting (returned to old style)
@
text
@d336 4
a339 2
	int	iNumServers = GetItemCount();
	int	iIndex = 0;
d341 6
a346 5
	iIndex = InsertItem( LVIF_TEXT | LVIF_PARAM, iNumServers, pServer->GetListName(), 0, 0, 1,
	                     reinterpret_cast<LPARAM>(pServer) );
	if (pServer->GetFailedCount() < 0)
		pServer->ResetFailedCount();
	RefreshServerDesc(iIndex, *pServer);
@


1.54
log
@Formatting, comments, and name changes.
@
text
@d844 1
a844 1
				iCompare = (pServer2->GetPing() > 0) ? 1 : ((pServer1->GetPing() > 0) ? -1 : 0);
d854 1
a854 1
				iCompare = (pServer2->GetNumUsers() > 0) ? 2 : ((pServer1->GetNumUsers() > 0) ? -1 : 0);
d876 1
a876 1
				iCompare = (pServer2->GetFiles() > 0) ? 1 : ((pServer1->GetFiles() > 0) ? -1 : 0);
d928 1
a928 1
				iCompare = (pServer2->GetSoftMaxFiles() > 0) ? 1 : ((pServer1->GetSoftMaxFiles() > 0) ? -1 : 0);
d936 1
a936 1
				iCompare = (pServer2->GetHardMaxFiles() > 0) ? 1 : ((pServer1->GetHardMaxFiles() > 0) ? -1 : 0);
@


1.53
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@a33 1

d37 12
d52 1
a52 1
	server_list = 0; // i_a
d54 2
a55 2

bool CServerListCtrl::Init(CServerList* in_list)
d59 5
a63 5
	server_list = in_list;
	imagelist.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 10); // changed by FoRcHa + Cax2 - highlight bugfix
	imagelist.SetBkColor(CLR_NONE);		//Cax2 - highlight bugfix
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SMALLSERVER), 16, 16)); // changed by FoRcHa
	LoadImgLstIcon(NULL, 0, 0); // delete temp-icon
d65 1
a65 1
	SetImageList(&imagelist, LVSIL_SMALL); //TVSIL_NORMAL);
d73 5
a77 3
	CString temp;
	temp.Format(_T("%s (%s)"), GetResString(IDS_UUSERS), GetResString(IDS_MAXUSERS));
	InsertColumn(4, temp, LVCFMT_RIGHT, 50);
d87 1
a87 1
	m_bSortAscending[7] = true; // Changed by Cax2
d94 3
a96 1
		SortInit(g_eMuleApp.m_pGlobPrefs->GetServerSortCol()); //Cax2 sortdlg
d98 7
a104 1
		SortInit(3);
d107 4
a110 1

d113 1
a113 1
	imagelist.DeleteImageList();
d115 2
a116 2

CServerListCtrl::~CServerListCtrl()
d118 2
a119 6
}

void CServerListCtrl::SortInit(int sortCode)
{
	bool	bSortDesc = (sortCode & MLC_SORTDESC) == 0;
	int		iCurrentSortItem = !bSortDesc ? sortCode : sortCode - MLC_SORTDESC;
d122 1
a122 1
	SortItems(&SortProc, sortCode);
d124 1
a124 1

d129 3
a131 2
		CHeaderCtrl * pHeaderCtrl = GetHeaderCtrl();
		HDITEM hdi;
d133 2
a134 1
		CString strRes;
d193 3
d197 1
a197 15
/*void CServerListCtrl::ShowServers(){
   DeleteAllItems(); 
   int i=0; 
   CString temp; 
   for(POSITION pos = server_list->m_serverList.GetHeadPosition(); pos != NULL;server_list->m_serverList.GetNext(pos)) { 
      CServer* cur_server = server_list->m_serverList.GetAt(pos); 
      InsertItem(LVIF_TEXT|LVIF_PARAM,i,cur_server->GetListName(),0,0,0,(LPARAM)cur_server);
	  RefreshServer( cur_server );
      i++; 
   } 
}
*/

int CServerListCtrl::FindIndex(const CServer* server) const
{
a198 1
	LVFINDINFO find;
d201 2
a202 1
	find.lParam = (LPARAM)server;
d205 4
d210 1
d212 2
a213 6
void CServerListCtrl::RefreshServerDesc(int itemnr, const CServer& server)
{

	CString temp;
	temp.Format(_T("%s : %i"), server.GetAddress(), server.GetPort());
	SetItemText(itemnr, 1, temp);
d216 1
a216 1
		SetItemText(itemnr, 0, server.GetListName());
d220 1
a220 1
		SetItemText(itemnr, 2, server.GetDescription());
d224 2
a225 2
		temp.Format(_T("%i"), server.GetPing());
		SetItemText(itemnr, 3, temp);
d230 1
a230 1
			temp.Format(_T("%i (%i)"), server.GetNumUsers(), server.GetMaxUsers());
d232 2
a233 2
			temp.Format(_T("%i"), server.GetNumUsers());
		SetItemText(itemnr, 4, temp);
d237 2
a238 2
		temp.Format(_T("%i"), server.GetFiles());
		SetItemText(itemnr, 5, temp);
d243 4
a246 2
		SetItemText(itemnr, 6, GetResString(IDS_PRIOLOW));
		break;
d248 4
a251 2
		SetItemText(itemnr, 6, GetResString(IDS_PRIONORMAL));
		break;
d253 4
a256 2
		SetItemText(itemnr, 6, GetResString(IDS_PRIOHIGH));
		break;
d258 3
a260 1
		SetItemText(itemnr, 6, GetResString(IDS_PRIONOPREF));
d263 2
a264 2
	temp.Format(_T("%i"), server.GetFailedCount());
	SetItemText(itemnr, 7, temp);
d267 1
a267 1
		SetItemText(itemnr, 8, GetResString(IDS_YES));
d269 1
a269 1
		SetItemText(itemnr, 8, GetResString(IDS_NO));
d274 1
a274 1
			temp.Format(_T("%i (%i)"), server.GetSoftMaxFiles(), server.GetHardMaxFiles());
d276 2
a277 2
			temp.Format(_T("(%i)"), server.GetHardMaxFiles());
		SetItemText(itemnr, 9, temp);
d280 1
a280 1
	SetItemText(itemnr, 10, server.GetVersion());
d282 2
a283 2

void CServerListCtrl::RemoveServer(CServer* todel, bool bDelToList)
d285 1
d287 1
a287 3
	int result = FindIndex(todel);

	if (result != -1)
d289 2
a290 2
		server_list->RemoveServer((CServer*)GetItemData(result));
		DeleteItem(result);
d295 1
a295 1

d302 1
d305 1
a305 1
		for (POSITION pos = server_list->m_serverList.GetHeadPosition(); pos != NULL;server_list->m_serverList.GetNext(pos))
d307 4
a310 3
			CServer * cur_server = server_list->m_serverList.GetAt(pos);
			if ( cur_server->GetFailedCount() > g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries() &&
			     !cur_server->IsStaticMember() )
d312 2
a313 2
				RemoveServer(cur_server);
				pos = server_list->m_serverList.GetHeadPosition();
d317 1
a317 1
		for (INT_PTR pos = 0; pos < server_list->array.GetCount(); pos++)
d319 4
a322 3
			CServer* cur_server = server_list->GetServerAt(pos);
			if ( cur_server->GetFailedCount() > g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries() &&
				 !cur_server->IsStaticMember() )
d324 1
a324 1
				RemoveServer(cur_server);
d332 3
d336 2
a337 2
void CServerListCtrl::AppendServer(CServer* server)
{
d339 5
a343 5
	int itemnr = GetItemCount();
	itemnr = InsertItem(LVIF_TEXT | LVIF_PARAM, itemnr, server->GetListName(), 0, 0, 1, (LPARAM)server);
	if (server->GetFailedCount() < 0)
		server->ResetFailedCount();
	RefreshServerDesc(itemnr, *server);
d345 2
a346 2

bool CServerListCtrl::AddServer(CServer* toadd, bool bAddToList, bool bulkLoad)
d348 2
a349 2
	if (toadd == NULL)
		return false;	//eklmn: check NULL case at server addition
d351 1
a351 1
	if (!server_list->AddServer(toadd))
d355 2
a356 2
		AppendServer(toadd);
	if (!bulkLoad)
d360 2
a361 3


void CServerListCtrl::RefreshServer(CServer& server)
a362 1

d366 3
a368 2
	int itemnr = FindIndex(&server);
	if (itemnr == -1)
d373 1
a373 1
	RefreshServerDesc(itemnr, server);
d375 1
a375 8

BEGIN_MESSAGE_MAP(CServerListCtrl, CMuleListCtrl /*CTreeCtrl*/)
//	ON_NOTIFY_REFLECT(NM_RCLICK, OnNMRclickServlist)
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnclickServlist)
	ON_NOTIFY_REFLECT (NM_DBLCLK, OnNMLdblclk) //<-- mod bb 27.09.02
	ON_WM_CONTEXTMENU()
	ON_WM_DESTROY()	// eklmn: bugfix(01): resource cleanup due to ImageLists recreation
END_MESSAGE_MAP()
d379 2
a380 1
void CServerListCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
d382 2
a383 2
//	POINT point;
//	::GetCursorPos(&point);
a384 3
//	tecxx 0609 2002
//	fix - on right click, we also want to change the current selection like the left click does
	CPoint p = point;
d386 5
a390 4
	int it = HitTest(p);
	if (it != -1)
		SetSelectionMark(it);   // display selection mark correctly!
//	fix end
d393 4
a396 3
	UINT flags;	//,flagSSL1,flagSSL2;
	CTitleMenu m_ServerMenu;
	CMenu m_ServerPrioMenu;
a397 1
	CServer* test = NULL;
d399 1
a399 1
		test = (CServer*)GetItemData(GetSelectionMark());
d401 2
a402 2
//	set state of selection-dependent menuitems
	flags = MF_STRING || MF_DISABLED;
d404 4
a407 6
		if (test != NULL)
			flags = MF_STRING;
//	flagSSL1=MF_STRING || MF_DISABLED;
//	flagSSL2=MF_STRING || MF_DISABLED;
//	if (test != NULL && GetSelectedCount()>0)
//	if (test->IsStaticMember()) flagSSL2=MF_STRING; else flagSSL1=MF_STRING;
d416 2
a417 2
	m_ServerMenu.AppendMenu(flags, MP_CONNECTTO, GetResString(IDS_CONNECTTHIS));
	m_ServerMenu.AppendMenu(flags | MF_POPUP, (UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
d419 5
a423 4
//	SyruS hide greyed-out "add /remove from static server"
	if (test != NULL && GetSelectedCount() > 0)
		if (test->IsStaticMember())
			m_ServerMenu.AppendMenu(flags, MP_REMOVEFROMSTATIC, GetResString(IDS_REMOVEFROMSTATIC));
d425 2
a426 1
			m_ServerMenu.AppendMenu(flags, MP_ADDTOSTATIC, GetResString(IDS_ADDTOSTATIC));
d429 1
a429 1
	m_ServerMenu.AppendMenu(flags, MP_REMOVE, GetResString(IDS_REMOVETHIS));
d432 1
a432 2
	m_ServerMenu.AppendMenu(flags, MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
//	m_ServerMenu.AppendMenu(MF_STRING,Irc_SetSendLink, GetResString(IDS_IRC_ADDLINKTOIRC));
d437 1
a437 1
	m_ServerPrioMenu.DestroyMenu(); // Added by Tarod -leak fix
a438 2

//	*pResult = 0;
d440 1
a440 1

d443 1
a443 1
	int item = GetSelectionMark();
d457 1
a457 1
		server_list->RemoveAllServers();
d464 1
a464 1
	if (item != -1)
d466 1
a466 1
		if (((CServer*)GetItemData(GetSelectionMark())) != NULL)
a467 1

d470 1
d475 1
a475 3
						CServer * aServer;
						uint32 newPosition = 0;

d479 3
a481 1
#endif //OLD_SOCKETS_ENABLED
d483 1
a483 2
						POSITION pos = GetFirstSelectedItemPosition();
					//	Move selected servers to the liststart, to connect them first
d486 2
a487 2
							item = GetNextSelectedItem(pos);
							if (item > -1)
d489 2
a490 2
								aServer = (CServer*)this->GetItemData(item);
								g_eMuleApp.m_pServerList->MoveServerDown(aServer);
d495 1
a495 1
#else
d498 1
a498 1
#endif //OLD_SOCKETS_ENABLED
a502 1
					//	DonGato - 25/10/2002
d506 2
a507 1
							if (!_tcscmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (g_eMuleApp.m_pServerConnect->GetCurrentServer())->GetAddress()))
d509 1
a509 1
								AddLogLine(false, IDS_ALREADYCONNECTED, ((CServer*)GetItemData(GetSelectionMark()))->GetListName());
d513 2
a514 3
					//
						g_eMuleApp.m_pServerConnect->ConnectToServer(*(CServer*)GetItemData(GetSelectionMark()));
#endif //OLD_SOCKETS_ENABLED
d517 3
a519 2
						CServer *pServer = (CServer*)GetItemData(GetSelectionMark());
						if (pServer)
d521 1
a521 1
#endif //NEW_SOCKETS
d527 2
d532 4
a535 2
					POSITION pos;
					while (GetFirstSelectedItemPosition() != NULL) //(pos != NULL)
d538 3
a540 3
						item = GetNextSelectedItem(pos);
						server_list->RemoveServer((CServer*)GetItemData(item));
						DeleteItem(item);
d546 2
d550 2
a551 1
					POSITION pos = GetFirstSelectedItemPosition();
d554 3
a556 2
						CServer * change = (CServer*)GetItemData(this->GetNextSelectedItem(pos));
						if (!StaticServerFileAppend(change))
d558 2
a559 2
						change->SetIsStaticMember(true);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
d563 2
a564 1
			//	Remove Static Servers [Barry]
d567 2
a568 1
					POSITION pos = GetFirstSelectedItemPosition();
d571 3
a573 2
						CServer * change = (CServer*)GetItemData(this->GetNextSelectedItem(pos));
						if (!StaticServerFileRemove(change))
d575 2
a576 2
						change->SetIsStaticMember(false);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
d580 2
d584 2
a585 1
					POSITION pos = GetFirstSelectedItemPosition();
d588 6
a593 6
						CServer * change = (CServer*)this->GetItemData(this->GetNextSelectedItem(pos));
						change->SetPreference(CServer::SERVERPRIORITY_LOW);
						if (change->IsStaticMember())
							StaticServerFileAppend(change);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
						POSITION pos = this->GetFirstSelectedItemPosition();
d597 2
d601 2
a602 1
					POSITION pos = GetFirstSelectedItemPosition();
d605 6
a610 6
						CServer * change = (CServer*)this->GetItemData(this->GetNextSelectedItem(pos));
						change->SetPreference(CServer::SERVERPRIORITY_NORMAL);
						if (change->IsStaticMember())
							StaticServerFileAppend(change);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
						POSITION pos = this->GetFirstSelectedItemPosition();
d614 2
d618 2
a619 1
					POSITION pos = GetFirstSelectedItemPosition();
d622 6
a627 6
						CServer * change = (CServer*)this->GetItemData(this->GetNextSelectedItem(pos));
						change->SetPreference(CServer::SERVERPRIORITY_HIGH);
						if (change->IsStaticMember())
							StaticServerFileAppend(change);
						g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
						POSITION pos = this->GetFirstSelectedItemPosition();
d631 2
d635 3
a637 2
					POSITION pos = GetFirstSelectedItemPosition();
					CString buffer, link;
d640 6
a645 6
						CServer * change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
						buffer.Format(_T("ed2k://|server|%s|%d|/"), change->GetFullIP(), change->GetPort());
						if (link.GetLength() > 0)
							buffer = _T("\n") + buffer;
						link += buffer;
						POSITION pos = GetFirstSelectedItemPosition();
d647 1
a647 1
					g_eMuleApp.CopyTextToClipboard(link);
d650 2
d654 3
a656 2
					POSITION pos = GetFirstSelectedItemPosition();
					CString buffer, link;
d659 6
a664 6
						CServer * change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
						buffer.Format(_T("ed2k://|server|%s|%d|/"), change->GetFullIP(), change->GetPort());
						if (link.GetLength() > 0)
							buffer = _T("\n") + buffer;
						link += buffer;
						POSITION pos = GetFirstSelectedItemPosition();
d666 1
a666 1
					g_eMuleApp.m_pdlgEmule->m_wndIRC.SetSendFileString(link);
d669 1
a669 1

d675 2
a676 2

//	DonGato - 25/10/2002
d684 2
a685 1
			if (!_tcscmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (g_eMuleApp.m_pServerConnect->GetCurrentServer())->GetAddress()))
d687 1
a687 1
				AddLogLine(false, IDS_ALREADYCONNECTED, ((CServer*)GetItemData(GetSelectionMark()))->GetListName());
d691 1
a691 1
		g_eMuleApp.m_pServerConnect->ConnectToServer(*(CServer*)GetItemData(GetSelectionMark()));
d695 3
a697 2
		CServer *pServer = (CServer*)GetItemData(GetSelectionMark());
		if (pServer)
d704 2
a705 2

bool CServerListCtrl::AddServermetToList(CString strFile)
d708 3
a710 1
	bool flag = server_list->AddServermetToList(strFile);
d714 1
a714 1
	return flag;
d716 2
a717 1

d720 5
a724 2
	NM_LISTVIEW * pNMListView = (NM_LISTVIEW*)pNMHDR;
	int adder = 0; //Cax2 - adapted from double arrows code in shared files control...
d729 1
a729 1
		adder = m_bSortAscending[11] ? 0 : MLC_SORTALT;
d735 1
a735 1
		adder = m_bSortAscending[12] ? 0 : MLC_SORTALT;
d740 2
a741 2
	if (adder == 0)
		SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem]); //Cax2 double arrows
d743 2
a744 2
		SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem] ? arrowDoubleUp : arrowDoubleDown); // double arrows
	SortItems(&SortProc, pNMListView->iSubItem + adder + ((m_bSortAscending[pNMListView->iSubItem]) ? MLC_SORTASC : MLC_SORTDESC)); // double arrows
d747 2
a748 2
    g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_SERVER, pNMListView->iSubItem);
    g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_SERVER, m_bSortAscending[pNMListView->iSubItem]);
d753 2
a754 2
	CServer	* item1 = reinterpret_cast<CServer*>(lParam1);
	CServer	*item2 = reinterpret_cast<CServer*>(lParam2);
d756 1
a756 1
	if ((item1 == NULL) || (item2 == NULL))
d759 12
a770 12
	int	iTemp = 0;
	int	counter1;
	int	counter2;
	int	iCompare = 0;

	int mod = 1; //<<--New by Cax2 03/11/02
//most of this switch satement modified by Cax2 21/12/02
	switch (lParamSort)
	{
		case 0+MLC_SORTDESC:  //Server-name desc
			mod = -1;
		case 0: 	//(List) Server-name asc
d772 2
a773 2
			bool	noname1 = _tcsstr(item1->GetListName(), item1->GetFullIP());
			bool	noname2 = _tcsstr(item2->GetListName(), item2->GetFullIP());
d775 2
a776 2
			if (!noname1 && !noname2)
				iCompare = _tcsicmp(item1->GetListName(), item2->GetListName()) * mod;
d778 1
a778 4
				iCompare = noname1 ? (noname2 ? 0 : 2) : -1;

			if (iCompare != 0)
				return iCompare;
d780 3
a782 2
		//	Fall through to the IP sort
			mod *= -1;
d784 3
a786 3
		case 1+MLC_SORTDESC:
			mod *= -1;
		case 1:  //IP asc //corrected by Cax2 12/12/02 - dynIp put before 1.1.1.1
d789 1
a789 1
			if (item1->HasDynIP() && item2->HasDynIP())
d791 1
a791 1
				iCompare = CString(item1->GetDynIP()).CompareNoCase(item2->GetDynIP());
d794 1
a794 1
			else if (item1->HasDynIP())
d799 1
a799 1
			else if (item2->HasDynIP())
d806 1
a806 1
				CString	sIP1, sIP2, sTemp1, sTemp2;
d808 3
a810 3
				counter1 = counter2 = iTemp = 0;
				sIP1 = item2->GetFullIP();
				sIP2 = item1->GetFullIP();
d813 2
a814 2
					sTemp1 = sIP1.Tokenize(_T("."), counter1);
					sTemp2 = sIP2.Tokenize(_T("."), counter2);
d819 1
a819 1
						iCompare = item1->GetPort() - item2->GetPort();
d828 18
a845 1
			return iCompare * mod;
d847 6
a852 31
		case 2:  //Description asc //corrected by Cax2
			return item1->GetDescription().CompareNoCase(item2->GetDescription());
		case 2+MLC_SORTDESC:  //Desciption desc
			return CString(item2->GetDescription()).CompareNoCase(item1->GetDescription());
		case 3:  //Ping asc
		if (item1->GetPing() > 0 && item2->GetPing() > 0)
			return item1->GetPing() - item2->GetPing();
		else
			return(item2->GetPing() > 0) ? 2 : ((item1->GetPing() > 0) ? -1 : 0);
		case 3+MLC_SORTDESC:  //Ping desc
		return item2->GetPing() - item1->GetPing();
		case 4:  //Users asc
		if (item1->GetNumUsers() > 0 && item2->GetNumUsers() > 0)
			return item1->GetNumUsers() - item2->GetNumUsers();
		else
			return(item2->GetNumUsers() > 0) ? 2 : ((item1->GetNumUsers() > 0) ? -1 : 0);
		case 4+MLC_SORTDESC:  //Users desc
		return item2->GetNumUsers() - item1->GetNumUsers();
		case 4+MLC_SORTALT:  //max. users
			if (item1->GetMaxUsers() == item2->GetMaxUsers())
				return 0;
			if (item1->GetMaxUsers() == 0)
				return 1;
			if (item2->GetMaxUsers() == 0)
				return -1;
			return item1->GetMaxUsers() - item2->GetMaxUsers();
		case 4+MLC_SORTALT+MLC_SORTDESC:
			return item2->GetMaxUsers() - item1->GetMaxUsers();
		case 5:  //Files asc
			if (item1->GetFiles() > 0 && item2->GetFiles() > 0)
				return item1->GetFiles() - item2->GetFiles();
d854 4
a857 13
				return(item2->GetFiles() > 0) ? 2 : ((item1->GetFiles() > 0) ? -1 : 0);
		case 5+MLC_SORTDESC:  //Files desc
			return item2->GetFiles() - item1->GetFiles();
	//end Cax2 modifications
		case 6:  //Preferences asc
			return item1->GetPreferences() - item2->GetPreferences();
		case 6+MLC_SORTDESC:  //Preferences desc
			return item2->GetPreferences() - item1->GetPreferences();
		case 7:  //failed asc
			return item1->GetFailedCount() - item2->GetFailedCount();
		case 7+MLC_SORTDESC:  //failed desc
			return item2->GetFailedCount() - item1->GetFailedCount();
		case 8:  //staticservers
d859 5
a863 15
		//	If both are static...
			if ( (item2->IsStaticMember() && item1->IsStaticMember()) ||
			     (!item2->IsStaticMember() && !item1->IsStaticMember()) )
			{
				bool	noname1 = _tcsstr(item1->GetListName(), item1->GetFullIP());
				bool	noname2 = _tcsstr(item2->GetListName(), item2->GetFullIP());

				if (!noname1 && !noname2)
					iCompare = _tcsicmp(item1->GetListName(), item2->GetListName()) * mod;
				else
					iCompare = noname1 ? (noname2 ? 0 : 2) : -1;
			}
		//	If only the first is static...
			else if (item1->IsStaticMember())
			{
d865 27
a891 8
			}
		//	If only the second is static...
			else if (item2->IsStaticMember())
			{
				iCompare = 1;
			}
			return iCompare;
		//return item2->IsStaticMember() - item1->IsStaticMember();
d893 3
a895 1
		case 8+MLC_SORTDESC:  //staticservers-
d898 2
a899 2
			if ( (item1->IsStaticMember() && item2->IsStaticMember()) ||
			     (!item1->IsStaticMember() && !item2->IsStaticMember()) )
d901 2
a902 2
				bool	noname1 = _tcsstr(item1->GetListName(), item1->GetFullIP());
				bool	noname2 = _tcsstr(item2->GetListName(), item2->GetFullIP());
d904 2
a905 2
				if (!noname1 && !noname2)
					iCompare = _tcsicmp(item2->GetListName(), item1->GetListName()) * mod;
d907 1
a907 1
					iCompare = noname2 ? (noname1 ? 0 : 2) : -1;
d910 1
a910 1
			else if (item2->IsStaticMember())
d915 1
a915 1
			else if (item1->IsStaticMember())
d919 1
a919 2
			return iCompare;
		//return item1->IsStaticMember() - item2->IsStaticMember();
d921 6
a926 3
		case 9:  //Soft files asc
			if ((item1->GetSoftMaxFiles() > 0 && item2->GetSoftMaxFiles() > 0) || (item1->GetHardMaxFiles() > 0 && item2->GetHardMaxFiles() > 0))
				return item1->GetSoftMaxFiles() - item2->GetSoftMaxFiles();
d928 7
a934 6
				return(item2->GetSoftMaxFiles() > 0) ? 2 : ((item1->GetSoftMaxFiles() > 0) ? -1 : 0);
		case 9+MLC_SORTDESC:  //Soft files desc
			return item2->GetSoftMaxFiles() - item1->GetSoftMaxFiles();
		case 9+MLC_SORTALT:  //Hard files asc
			if (item1->GetHardMaxFiles() > 0 && item2->GetHardMaxFiles() > 0)
				return item1->GetHardMaxFiles() - item2->GetHardMaxFiles();
d936 11
a946 7
				return(item2->GetHardMaxFiles() > 0) ? 2 : ((item1->GetHardMaxFiles() > 0) ? -1 : 0);
		case 9+MLC_SORTALT+MLC_SORTDESC:  //Hard files desc
			return item2->GetHardMaxFiles() - item1->GetHardMaxFiles();
		case 10:  //Version asc
			return item1->GetVersion().CompareNoCase(item2->GetVersion());
		case 10+MLC_SORTDESC:  //Version desc
			return item2->GetVersion().CompareNoCase(item1->GetVersion());
d948 3
a950 1
			return 0;
d952 2
d955 2
a956 2

bool CServerListCtrl::StaticServerFileAppend(CServer *server)
d961 1
a961 1
		StaticServerFileRemove(server);
d963 3
a965 2
		FILE* staticservers = _tfopen(g_eMuleApp.m_pGlobPrefs->GetConfigDir() + CString(_T("staticservers.dat")), _T("a"));
		if (staticservers == NULL)
d971 1
a971 1
		if ( fprintf( staticservers,
d973 9
a981 9
		              server->GetAddress(),
		              server->GetPort(),
		              server->GetPreferences(),
		              server->GetListName() ) != EOF )
		{
			if (!server->IsStaticMember()) // DonGato
				AddLogLine(false, _T("'%s:%i,%s' %s"), server->GetAddress(), server->GetPort(), server->GetListName(), GetResString(IDS_ADDED2SSF));
			server->SetIsStaticMember(true);
			g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*server);
d984 1
a984 1
		fclose(staticservers);
d992 2
a993 2

bool CServerListCtrl::StaticServerFileRemove(CServer *server)
d997 1
a997 1
		if (!server->IsStaticMember())
d1000 9
a1008 9
		CString strLine;
		CString strTest;
		char buffer[1024];
		int lenBuf = 1024;
		int pos;
		CString StaticFilePath = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + CString("staticservers.dat");
		CString StaticTempPath = g_eMuleApp.m_pGlobPrefs->GetConfigDir() + CString("statictemp.dat");
		FILE* staticservers = _tfopen(StaticFilePath , _T("r"));
		FILE* statictemp = _tfopen(StaticTempPath , _T("w"));
d1010 1
a1010 1
		if ((staticservers == NULL) || (statictemp == NULL))
d1016 1
a1016 1
		while (!feof(staticservers))
d1018 1
a1018 1
			if (fgets(buffer, lenBuf, staticservers) == 0)
d1021 1
a1021 1
			strLine = buffer;
d1023 1
a1023 1
		//	ignore comments or invalid lines
d1026 1
a1026 1
				fprintf(statictemp, buffer);
d1031 1
a1031 1
				fprintf(statictemp, buffer);
d1036 2
a1037 2
			pos = strLine.Find(',');
			if (pos == -1)
d1039 1
a1039 1
			strLine = strLine.Left(pos);
d1041 2
a1042 2
		//	Get host and port from given server
			strTest.Format(_T("%s:%i"), server->GetAddress(), server->GetPort());
d1044 1
a1044 1
		//	Compare, if not the same server write original line to temp file
d1046 1
a1046 1
				fprintf(statictemp, buffer);
d1049 2
a1050 2
		fclose(staticservers);
		fclose(statictemp);
d1053 2
a1054 2
		CFile::Remove(StaticFilePath);
		CFile::Rename(StaticTempPath, StaticFilePath);
d1056 3
a1058 4
	//purity
		AddLogLine(false, _T("'%s:%i,%s' %s"), server->GetAddress(), server->GetPort(), server->GetListName(), GetResString(IDS_REMOVEDFROMSSF));
		server->SetIsStaticMember(false);
		g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*server);
d1066 1
a1066 1

d1069 1
a1069 1
	CString counter;
d1071 2
a1072 2
	counter.Format(_T(" (%i)"), GetItemCount());
	g_eMuleApp.m_pdlgEmule->m_wndServer.GetDlgItem(IDC_SERVLIST_TEXT)->SetWindowText(GetResString(IDS_SV_SERVERLIST) + counter);
d1074 1
@


1.52
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d98 2
a99 8
	int m_iCurrentSortItem = (sortCode < 100) ? sortCode : sortCode - 100;

	if (sortCode == 54 || sortCode == 154)
		SetSortArrow(4, (sortCode == 54) ? arrowDoubleUp : arrowDoubleDown);
	else if (sortCode == 59 || sortCode == 159)
		SetSortArrow(9, (sortCode == 59) ? arrowDoubleUp : arrowDoubleDown);
	else
		SetSortArrow(m_iCurrentSortItem, (sortCode < 100));
d101 1
d683 1
a683 1
		adder = m_bSortAscending[11] ? 0 : 50;
d689 1
a689 1
		adder = m_bSortAscending[12] ? 0 : 50;
d698 1
a698 1
	SortItems(&SortProc, pNMListView->iSubItem + adder + ((m_bSortAscending[pNMListView->iSubItem]) ? 0 : 100)); // double arrows
d722 2
a723 2
		case 100:  //Server-name desc
		mod = -1;
d740 2
a741 2
		case 101:
		mod *= -1;
d787 3
a789 3
		return item1->GetDescription().CompareNoCase(item2->GetDescription());
		case 102:  //Desciption desc
		return CString(item2->GetDescription()).CompareNoCase(item1->GetDescription());
d795 1
a795 1
		case 103:  //Ping desc
d802 1
a802 1
		case 104:  //Users desc
d804 10
a813 10
		case 54:  //max. users
		if (item1->GetMaxUsers() == item2->GetMaxUsers())
			return 0;
		if (item1->GetMaxUsers() == 0)
			return 1;
		if (item2->GetMaxUsers() == 0)
			return -1;
		return item1->GetMaxUsers() - item2->GetMaxUsers();
		case 154:  //Cax2 patch 21/12/02
		return item2->GetMaxUsers() - item1->GetMaxUsers();
d815 6
a820 6
		if (item1->GetFiles() > 0 && item2->GetFiles() > 0)
			return item1->GetFiles() - item2->GetFiles();
		else
			return(item2->GetFiles() > 0) ? 2 : ((item1->GetFiles() > 0) ? -1 : 0);
		case 105:  //Files desc
		return item2->GetFiles() - item1->GetFiles();
d823 3
a825 3
		return item1->GetPreferences() - item2->GetPreferences();
		case 106:  //Preferences desc
		return item2->GetPreferences() - item1->GetPreferences();
d827 3
a829 3
		return item1->GetFailedCount() - item2->GetFailedCount();
		case 107:  //failed desc
		return item2->GetFailedCount() - item1->GetFailedCount();
d857 1
a857 1
		case 108:  //staticservers-
d885 13
a897 13
		if ((item1->GetSoftMaxFiles() > 0 && item2->GetSoftMaxFiles() > 0) || (item1->GetHardMaxFiles() > 0 && item2->GetHardMaxFiles() > 0))
			return item1->GetSoftMaxFiles() - item2->GetSoftMaxFiles();
		else
			return(item2->GetSoftMaxFiles() > 0) ? 2 : ((item1->GetSoftMaxFiles() > 0) ? -1 : 0);
		case 109:  //Soft files desc
		return item2->GetSoftMaxFiles() - item1->GetSoftMaxFiles();
		case 59:  //Hard files asc
		if (item1->GetHardMaxFiles() > 0 && item2->GetHardMaxFiles() > 0)
			return item1->GetHardMaxFiles() - item2->GetHardMaxFiles();
		else
			return(item2->GetHardMaxFiles() > 0) ? 2 : ((item1->GetHardMaxFiles() > 0) ? -1 : 0);
		case 159:  //Hard files desc
		return item2->GetHardMaxFiles() - item1->GetHardMaxFiles();
d899 3
a901 3
		return item1->GetVersion().CompareNoCase(item2->GetVersion());
		case 110:  //Version desc
		return item2->GetVersion().CompareNoCase(item1->GetVersion());
d903 1
a903 1
		return 0;
@


1.51
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d19 1
a19 1
// ServerListCtrl.cpp : implementation file
d30 1
a30 1
static char THIS_FILE[]=__FILE__;
d35 1
a35 1
// CServerListCtrl
d37 5
a41 4
IMPLEMENT_DYNAMIC(CServerListCtrl, CMuleListCtrl/*CTreeCtrl*/)
CServerListCtrl::CServerListCtrl(){
	memset2(&m_bSortAscending,0,13);
	server_list = 0; // i_a 
d44 4
a47 3
bool CServerListCtrl::Init(CServerList* in_list){ 
	ModifyStyle(0,TVS_HASLINES|TVS_LINESATROOT|TVS_HASBUTTONS);
	// Set Imagelist
d49 1
a49 1
	imagelist.Create(16,16,ILC_COLOR32|ILC_MASK,0,10); // changed by FoRcHa + Cax2 - highlight bugfix
d51 2
a52 2
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SMALLSERVER),16,16)); // changed by FoRcHa 
	LoadImgLstIcon(NULL,0,0); // delete temp-icon
d54 2
a55 2
	SetImageList(&imagelist,LVSIL_SMALL);//TVSIL_NORMAL);
	ModifyStyle(LVS_SINGLESEL|LVS_LIST|LVS_ICON|LVS_SMALLICON,LVS_REPORT); //here the CListCtrl is set to report-style
d58 4
a61 4
	InsertColumn(0,GetResString(IDS_SL_SERVERNAME),LVCFMT_LEFT, 150);
	InsertColumn(1,GetResString(IDS_IP),LVCFMT_LEFT, 140);
	InsertColumn(2,GetResString(IDS_DESCRIPTION) ,LVCFMT_LEFT, 150);
	InsertColumn(3,GetResString(IDS_PING),LVCFMT_RIGHT, 50);
d64 13
a76 7
	InsertColumn(4,temp,LVCFMT_RIGHT, 50);
	InsertColumn(5,GetResString(IDS_FILES) ,LVCFMT_RIGHT, 50);
	InsertColumn(6,GetResString(IDS_PRIORITY),LVCFMT_LEFT, 60);
	InsertColumn(7,GetResString(IDS_UFAILED),LVCFMT_RIGHT, 50);
	InsertColumn(8,GetResString(IDS_STATICSERVER),LVCFMT_LEFT, 50);
	InsertColumn(9,GetResString(IDS_SERVER_SOFTHARDLIMIT),LVCFMT_RIGHT, 100);
	InsertColumn(10,GetResString(IDS_SERVER_VERSION),LVCFMT_LEFT, 150);
d78 1
a78 2
	m_bSortAscending[4]=true;m_bSortAscending[5]=true;m_bSortAscending[7]=true;// Changed by Cax2 
	m_bSortAscending[9]=true;m_bSortAscending[10]=true;
d80 4
a83 4
	LoadSettings(CPreferences::TABLE_SERVER);
	//sortdlg Cax2
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())	SortInit(g_eMuleApp.m_pGlobPrefs->GetServerSortCol());//Cax2 sortdlg
	else SortInit(3);
d85 1
a85 1
} 
d87 2
a88 2
// v- eklmn: bugfix(01): resource cleanup due to ImageLists recreation
void CServerListCtrl::OnDestroy() {
a90 1
// ^- eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d92 2
a93 1
CServerListCtrl::~CServerListCtrl() {
d96 10
a105 7
void CServerListCtrl::SortInit(int sortCode){	//Cax2 sortdlg
	int m_iCurrentSortItem=(sortCode<100)?sortCode:sortCode-100;
	if (sortCode==54||sortCode==154)
		SetSortArrow(4,(sortCode==54)? arrowDoubleUp:arrowDoubleDown);
	else if (sortCode==59||sortCode==159)
		SetSortArrow(9,(sortCode==59)? arrowDoubleUp:arrowDoubleDown);
	else SetSortArrow(m_iCurrentSortItem,(sortCode<100));
d110 1
a110 1
void CServerListCtrl::Localize() 
d112 1
a112 1
	if(GetSafeHwnd())
d114 60
a173 60
	CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
	HDITEM hdi;
	hdi.mask = HDI_TEXT;
	CString strRes;

	strRes = GetResString(IDS_SL_SERVERNAME);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(0, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_IP);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(1, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_DESCRIPTION);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(2, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_PING);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(3, &hdi);
	strRes.ReleaseBuffer();

 
	strRes.Format(_T("%s (%s)"), GetResString(IDS_UUSERS), GetResString(IDS_MAXUSERS));
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(4, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_FILES);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(5, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_PRIORITY);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(6, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_UFAILED);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(7, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_STATICSERVER);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(8, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_SERVER_SOFTHARDLIMIT);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(9, &hdi);
	strRes.ReleaseBuffer();

	strRes = GetResString(IDS_SERVER_VERSION);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(10, &hdi);
	strRes.ReleaseBuffer();
d177 1
a177 1
/*void CServerListCtrl::ShowServers(){ 
d190 3
a192 2
int CServerListCtrl::FindIndex(const CServer* server) const {
	
d194 1
a194 1
	::ZeroMemory(&find,sizeof(LVFINDINFO));
d201 2
a202 1
void CServerListCtrl::RefreshServerDesc(int itemnr, const CServer& server ){
d205 1
a205 1
	temp.Format(_T("%s : %i"),server.GetAddress(),server.GetPort());
d207 2
a208 1
	if(server.GetListName()){
d211 8
a218 2
	if(server.GetDescription()){
		SetItemText(itemnr,2,server.GetDescription());
d220 4
a223 7
	if(server.GetPing()){
		temp.Format(_T("%i"),server.GetPing()); 
		SetItemText(itemnr,3,temp);
	}
	if(server.GetNumUsers()){
		if( server.GetMaxUsers() )
			temp.Format(_T("%i (%i)"),server.GetNumUsers(),server.GetMaxUsers());
d225 2
a226 2
		temp.Format(_T("%i"),server.GetNumUsers()); 
		SetItemText(itemnr,4,temp);
d228 4
a231 3
	if(server.GetFiles()){
		temp.Format(_T("%i"),server.GetFiles()); 
		SetItemText(itemnr,5,temp);
d233 2
a234 1
	switch(server.GetPreferences()){
d236 2
a237 2
			SetItemText(itemnr,6,GetResString(IDS_PRIOLOW));
			break;
d239 2
a240 2
			SetItemText(itemnr,6,GetResString(IDS_PRIONORMAL));
			break;
d242 2
a243 2
			SetItemText(itemnr,6,GetResString(IDS_PRIOHIGH));
			break;
d245 1
a245 1
			SetItemText(itemnr,6,GetResString(IDS_PRIONOPREF));
d247 4
a250 4
	
	temp.Format(_T("%i"),server.GetFailedCount()); 
	SetItemText(itemnr,7,temp);
	
d252 1
a252 1
		SetItemText(itemnr,8,GetResString(IDS_YES)); 
d254 1
a254 1
		SetItemText(itemnr,8,GetResString(IDS_NO));
d262 1
a262 1
		SetItemText(itemnr,9,temp);
d265 1
a265 1
	SetItemText(itemnr,10,server.GetVersion());
d268 3
a270 2
void CServerListCtrl::RemoveServer(CServer* todel,bool bDelToList){
	
d272 3
a274 2
	
	if (result != -1 ){
d276 1
a276 1
		DeleteItem(result); 
d282 6
a287 4
// Remove Dead Servers
void CServerListCtrl::RemoveDeadServer(){
	if( g_eMuleApp.m_pGlobPrefs->DeadServer() ){
	   ShowWindow(SW_HIDE); 
d289 7
a295 4
		for(POSITION pos = server_list->m_serverList.GetHeadPosition(); pos != NULL;server_list->m_serverList.GetNext(pos)) { 
			CServer* cur_server = server_list->m_serverList.GetAt(pos); 
			if( cur_server->GetFailedCount() > g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries() &&
				!cur_server->IsStaticMember()){
d301 6
a306 5
	   for ( INT_PTR pos = 0; pos < server_list->array.GetCount(); pos++ )
	   {
			CServer* cur_server = server_list->GetServerAt(pos); 
			if( cur_server->GetFailedCount() > g_eMuleApp.m_pGlobPrefs->GetDeadserverRetries() &&
				!cur_server->IsStaticMember()){
d310 1
a310 1
	   }
d312 1
a312 1
	   ShowWindow(SW_SHOW); 
d316 3
a318 2
void CServerListCtrl::AppendServer(CServer* server) {
	
d320 2
a321 2
	itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,server->GetListName(),0,0,1,(LPARAM)server);
	if( server->GetFailedCount() < 0 )
d326 1
a326 1
bool CServerListCtrl::AddServer(CServer* toadd,bool bAddToList, bool bulkLoad)
d328 2
a329 1
	if (toadd == NULL) return false;	//eklmn: check NULL case at server addition
d331 2
a332 1
	if (!server_list->AddServer(toadd)) return false;
d334 5
a338 5
   if (bAddToList)    
	   AppendServer(toadd);	   
   if (!bulkLoad)
	   ShowFilesCount();
   return true; 
d342 2
a343 1
void CServerListCtrl::RefreshServer(CServer& server ){
d347 1
a347 1
	
d352 1
a352 1
	if( server.GetFailedCount() < 0 )
d357 6
a362 6
BEGIN_MESSAGE_MAP(CServerListCtrl, CMuleListCtrl/*CTreeCtrl*/) 
  // ON_NOTIFY_REFLECT(NM_RCLICK, OnNMRclickServlist) 
   ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnclickServlist) 
   ON_NOTIFY_REFLECT (NM_DBLCLK, OnNMLdblclk) //<-- mod bb 27.09.02 
   ON_WM_CONTEXTMENU()
   ON_WM_DESTROY()	// eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d365 1
a365 1
// CServerListCtrl message handlers
d368 12
a379 12
{ 
//	POINT point; 
//	::GetCursorPos(&point); 

	// tecxx 0609 2002 
	// fix - on right click, we also want to change the current selection like the left click does 
	CPoint p = point; 
	ScreenToClient(&p); 
	int it = HitTest(p); 
	if (it != -1) 
		SetSelectionMark(it);   // display selection mark correctly! 
	// fix end 
d381 1
a381 1
	// Create up-to-date popupmenu
d386 13
a398 2
	CServer* test=NULL;
	if (GetSelectionMark() != -1) test=(CServer*)GetItemData(GetSelectionMark());
a399 10
	// set state of selection-dependent menuitems
	flags=MF_STRING || MF_DISABLED;
	if (GetSelectionMark() != (-1) && GetSelectedCount()>0)
		if (test != NULL)
			flags=MF_STRING;
	//flagSSL1=MF_STRING || MF_DISABLED;
	//flagSSL2=MF_STRING || MF_DISABLED;
	//if (test != NULL && GetSelectedCount()>0) 
	//	if (test->IsStaticMember()) flagSSL2=MF_STRING; else flagSSL1=MF_STRING;
	   
d401 3
a403 3
	m_ServerPrioMenu.AppendMenu(MF_STRING,MP_PRIOLOW,GetResString(IDS_PRIOLOW));
	m_ServerPrioMenu.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
	m_ServerPrioMenu.AppendMenu(MF_STRING,MP_PRIOHIGH,GetResString(IDS_PRIOHIGH));
d405 1
a405 1
	m_ServerMenu.CreatePopupMenu(); 
d407 2
a408 2
	m_ServerMenu.AppendMenu(flags,MP_CONNECTTO, GetResString(IDS_CONNECTTHIS)); 
	m_ServerMenu.AppendMenu(flags|MF_POPUP,(UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
d410 4
a413 4
	//SyruS hide greyed-out "add /remove from static server"
	if (test != NULL && GetSelectedCount()>0)
		if (test->IsStaticMember()) 
			m_ServerMenu.AppendMenu(flags,MP_REMOVEFROMSTATIC, GetResString(IDS_REMOVEFROMSTATIC));
d415 1
a415 1
			m_ServerMenu.AppendMenu(flags,MP_ADDTOSTATIC, GetResString(IDS_ADDTOSTATIC));
d417 6
a422 6
	m_ServerMenu.AppendMenu(MF_STRING|MF_SEPARATOR);	
	m_ServerMenu.AppendMenu(flags,MP_REMOVE, GetResString(IDS_REMOVETHIS)); 
	m_ServerMenu.AppendMenu(MF_STRING,MP_REMOVEALL, GetResString(IDS_REMOVEALL));
	m_ServerMenu.AppendMenu(MF_SEPARATOR); 
	m_ServerMenu.AppendMenu(flags,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
	// m_ServerMenu.AppendMenu(MF_STRING,Irc_SetSendLink, GetResString(IDS_IRC_ADDLINKTOIRC)); 
d425 1
a425 1
	m_ServerMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this); 
d430 1
a430 1
//	*pResult = 0; 
d433 3
a435 2
BOOL CServerListCtrl::OnCommand(WPARAM wParam,LPARAM lParam ){ 
   int item= GetSelectionMark(); 
d437 2
a438 2
   if (wParam==MP_REMOVEALL)
   { 
d440 14
a453 6
	if( g_eMuleApp.m_pServerConnect->IsConnecting() )
	{
	   	g_eMuleApp.m_pDownloadQueue->StopUDPRequests(); 
		g_eMuleApp.m_pServerConnect->StopConnectionTry();
		g_eMuleApp.m_pServerConnect->Disconnect();
		g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
a454 8
#endif //OLD_SOCKETS_ENABLED
	ShowWindow(SW_HIDE);
	server_list->RemoveAllServers(); 
	DeleteAllItems();
	ShowWindow(SW_SHOW);
	   ShowFilesCount();
	return true;
   }
d456 4
a459 2
   if (item != -1){ 
      if (((CServer*)GetItemData(GetSelectionMark())) != NULL){ 
d461 1
a461 2
		  switch (wParam){ 
            case MP_CONNECTTO: 
d463 6
a468 3
				if ( GetSelectedCount()>1 ) {
					CServer* aServer;
					uint32   newPosition=0;
d471 2
a472 1
					g_eMuleApp.m_pServerConnect->Disconnect();
d474 11
a484 8
					POSITION pos=GetFirstSelectedItemPosition();
					// Move selected servers to the liststart, to connect them first
					while (pos!=NULL )
					{ 
						item = GetNextSelectedItem(pos); 
						if (item>-1) {
							aServer=(CServer*)this->GetItemData(item);
							g_eMuleApp.m_pServerList->MoveServerDown(aServer);
a485 1
					} 
d487 1
a487 1
					g_eMuleApp.m_pServerConnect->ConnectToAnyServer( (g_eMuleApp.m_pServerList->GetServerCount() - GetSelectedCount()), false);
d489 2
a490 1
					g_eMuleApp.m_pEngine->ConnectToAnyServer();
d492 5
a496 2
				} else {
					// DonGato - 25/10/2002 
d498 10
a507 8
					if (g_eMuleApp.m_pServerConnect->IsConnected()){       
						if (!_tcscmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (g_eMuleApp.m_pServerConnect->GetCurrentServer())->GetAddress())){ 
							AddLogLine( false, IDS_ALREADYCONNECTED, ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
							break; 
						} 
					}                       
					// 
					g_eMuleApp.m_pServerConnect->ConnectToServer(*(CServer*)GetItemData(GetSelectionMark()));
d510 4
a513 3
					CServer *pServer = (CServer*)GetItemData(GetSelectionMark());
					if(pServer)
						g_eMuleApp.m_pEngine->ConnectToServer(pServer);
d515 19
d535 12
a546 13
				g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
			    break; 
			}			
    		        case MP_REMOVE: 
            		{ 
				ShowWindow(SW_HIDE); 
				POSITION pos;
				while (GetFirstSelectedItemPosition()!=NULL) //(pos != NULL) 
				{ 
					pos=GetFirstSelectedItemPosition();
					item = GetNextSelectedItem(pos); 
					server_list->RemoveServer((CServer*)GetItemData(item));
					DeleteItem(item);
d548 27
a574 12
				ShowFilesCount();
				ShowWindow(SW_SHOW); 
				break; 
		        }
			case MP_ADDTOSTATIC:{
				POSITION pos=GetFirstSelectedItemPosition();
				while( pos != NULL ){
					CServer* change = (CServer*)GetItemData(this->GetNextSelectedItem(pos));
					if (!StaticServerFileAppend(change))
						return false;
					change->SetIsStaticMember(true);
					g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
d576 1
a576 4
				break;
			}
			// Remove Static Servers [Barry]
			case MP_REMOVEFROMSTATIC:
d578 11
a588 7
				POSITION pos=GetFirstSelectedItemPosition();
				while( pos != NULL ){
					CServer* change = (CServer*)GetItemData(this->GetNextSelectedItem(pos));
					if (!StaticServerFileRemove(change))
						return false;
					change->SetIsStaticMember(false);
					g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
d590 13
a602 12
				break;
			}
			case MP_PRIOLOW:
			{
				POSITION pos = GetFirstSelectedItemPosition();
				while( pos != NULL ){
					CServer* change = (CServer*)this->GetItemData(this->GetNextSelectedItem(pos));
					change->SetPreference(CServer::SERVERPRIORITY_LOW);
					if (change->IsStaticMember())
						StaticServerFileAppend(change);
					g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
					POSITION pos = this->GetFirstSelectedItemPosition();
d604 15
a618 12
				break;
			}
			case MP_PRIONORMAL:
			{
				POSITION pos = GetFirstSelectedItemPosition();
				while( pos != NULL ){
					CServer* change = (CServer*)this->GetItemData(this->GetNextSelectedItem(pos));
					change->SetPreference(CServer::SERVERPRIORITY_NORMAL);
					if (change->IsStaticMember())
						StaticServerFileAppend(change);
					g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
					POSITION pos = this->GetFirstSelectedItemPosition();
d620 15
a634 12
				break;
			}
			case MP_PRIOHIGH:
			{
				POSITION pos = GetFirstSelectedItemPosition();
				while( pos != NULL ){
					CServer* change = (CServer*)this->GetItemData(this->GetNextSelectedItem(pos));
					change->SetPreference(CServer::SERVERPRIORITY_HIGH);
					if (change->IsStaticMember())
						StaticServerFileAppend(change);
					g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.RefreshServer(*change);
					POSITION pos = this->GetFirstSelectedItemPosition();
d636 1
a636 1
				break;
d638 3
a640 33
			case MP_GETED2KLINK: 
			{ 
				POSITION pos = GetFirstSelectedItemPosition(); 
				CString buffer, link; 
				while( pos != NULL ){ 
					CServer* change = (CServer*)this->GetItemData(GetNextSelectedItem(pos)); 
					buffer.Format(_T("ed2k://|server|%s|%d|/"), change->GetFullIP(), change->GetPort()); 
					if (link.GetLength()>0) buffer=_T("\n")+buffer;
					link += buffer; 
					POSITION pos = GetFirstSelectedItemPosition(); 
				} 
				g_eMuleApp.CopyTextToClipboard(link); 
				break; 
			}
			case Irc_SetSendLink:
			{
				POSITION pos = GetFirstSelectedItemPosition(); 
				CString buffer, link; 
				while( pos != NULL ){ 
					CServer* change = (CServer*)this->GetItemData(GetNextSelectedItem(pos)); 
					buffer.Format(_T("ed2k://|server|%s|%d|/"), change->GetFullIP(), change->GetPort()); 
					if (link.GetLength()>0) buffer=_T("\n")+buffer;
					link += buffer; 
					POSITION pos = GetFirstSelectedItemPosition(); 
         			} 
				g_eMuleApp.m_pdlgEmule->m_wndIRC.SetSendFileString(link);
				break;
      			} 

         } 
      } 
   } 
   return true; 
d643 4
a646 3
// DonGato - 25/10/2002 
void CServerListCtrl::OnNMLdblclk(NMHDR *pNMHDR, LRESULT *pResult){ 
	if (GetSelectionMark() != (-1))
d649 2
a650 2
      	if (g_eMuleApp.m_pServerConnect->IsConnected())
		{     
d652 6
a657 6
			{ 
            		AddLogLine( false, IDS_ALREADYCONNECTED, ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
            		return; 
			} 
		} 
		g_eMuleApp.m_pServerConnect->ConnectToServer(*(CServer*)GetItemData(GetSelectionMark())); 
d660 4
a663 3
	CServer *pServer = (CServer*)GetItemData(GetSelectionMark());
	if(pServer)
		g_eMuleApp.m_pEngine->ConnectToServer(pServer);
d665 2
a666 1
	   	g_eMuleApp.m_pdlgEmule->ShowConnectionState(false);
d670 39
a708 31
bool CServerListCtrl::AddServermetToList(CString strFile) 
{ 
   SetRedraw(false);
   bool flag=server_list->AddServermetToList(strFile);
   RemoveDeadServer();
   ShowFilesCount();
   SetRedraw(true);
   return flag;
}

void CServerListCtrl::OnLvnColumnclickServlist(NMHDR *pNMHDR, LRESULT *pResult) 
{ 
   NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR; 
   int adder=0; //Cax2 - adapted from double arrows code in shared files control...
   if (pNMListView->iSubItem==4){
		if(m_bSortAscending[4]) m_bSortAscending[11]=!m_bSortAscending[11];
		adder= m_bSortAscending[11]?0:50;
   }
   if (pNMListView->iSubItem==9){
		if(m_bSortAscending[9]) m_bSortAscending[12]=!m_bSortAscending[12];
		adder= m_bSortAscending[12]?0:50;
   }
   // if it's a second click on the same column then reverse the sort order, 
   // otherwise sort the new column in ascending order. 
   m_bSortAscending[pNMListView->iSubItem] = !m_bSortAscending[pNMListView->iSubItem]; 
   if (adder==0) SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem]);//Cax2 double arrows
   else SetSortArrow(pNMListView->iSubItem,m_bSortAscending[pNMListView->iSubItem] ? arrowDoubleUp:arrowDoubleDown);// double arrows
   SortItems(&SortProc,pNMListView->iSubItem+adder+((m_bSortAscending[pNMListView->iSubItem])? 0:100)); // double arrows
   Invalidate(); 
   *pResult = 0; 
} 
d712 5
a716 2
   CServer		*item1 = reinterpret_cast<CServer*>(lParam1);
   CServer		*item2 = reinterpret_cast<CServer*>(lParam2);
d718 4
a721 2
   if ((item1 == NULL) || (item2 == NULL))
	   return 0;
d723 2
a724 7
   int			iTemp=0; 
   int			counter1; 
   int			counter2;
   int			iCompare = 0;
    
   int mod=1; //<<--New by Cax2 03/11/02 
   //most of this switch satement modified by Cax2 21/12/02
d727 3
a729 3
		case 100: //Server-name desc 
			mod=-1; 
		case 0:	//(List) Server-name asc
d731 2
a732 2
			bool	noname1=_tcsstr(item1->GetListName(),item1->GetFullIP()); 
			bool	noname2=_tcsstr(item2->GetListName(),item2->GetFullIP());
d735 1
a735 1
				iCompare = _tcsicmp(item1->GetListName(),item2->GetListName())*mod;
d744 1
a744 1
		} 
d746 2
a747 2
			mod *= -1;
		case 1: //IP asc //corrected by Cax2 12/12/02 - dynIp put before 1.1.1.1
d767 1
a767 1
				CString		sIP1, sIP2, sTemp1, sTemp2;
d769 3
a771 3
				counter1 = counter2 = iTemp = 0; 
				sIP1 = item2->GetFullIP(); 
				sIP2 = item1->GetFullIP(); 
d774 2
a775 2
					sTemp1 = sIP1.Tokenize(_T("."),counter1);
					sTemp2 = sIP2.Tokenize(_T("."),counter2);
d780 1
a780 1
						iCompare = item1->GetPort()-item2->GetPort();
d791 1
a791 1
      case 2: //Description asc //corrected by Cax2		    
d793 1
a793 1
      case 102: //Desciption desc 
d795 13
a807 11
	  case 3: //Ping asc 
		if (item1->GetPing()>0 && item2->GetPing()>0) 
			return item1->GetPing() - item2->GetPing(); 
		else return(item2->GetPing()>0)?2:((item1->GetPing()>0)?-1:0); 
	  case 103: //Ping desc 
		return item2->GetPing() - item1->GetPing(); 
      case 4: //Users asc 
		if (item1->GetNumUsers()>0 && item2->GetNumUsers()>0) 
			return item1->GetNumUsers() - item2->GetNumUsers(); 
		else return(item2->GetNumUsers()>0)?2:((item1->GetNumUsers()>0)?-1:0);
      case 104: //Users desc 
d809 17
a825 16
      case 54: //max. users
		  if(item1->GetMaxUsers() == item2->GetMaxUsers())
			  return 0;
		  if(item1->GetMaxUsers() == 0)
			  return 1;
		  if(item2->GetMaxUsers() == 0)
			  return -1;
		  return item1->GetMaxUsers() - item2->GetMaxUsers(); 
	  case 154: //Cax2 patch 21/12/02
		 return item2->GetMaxUsers() - item1->GetMaxUsers();
	  case 5: //Files asc 
		if (item1->GetFiles()>0 && item2->GetFiles()>0) 
			return item1->GetFiles() - item2->GetFiles(); 
		else return(item2->GetFiles()>0)?2:((item1->GetFiles()>0)?-1:0); 
      case 105: //Files desc 
		return item2->GetFiles() - item1->GetFiles(); 
d827 10
a836 10
		case 6: //Preferences asc 
		  return item1->GetPreferences() - item2->GetPreferences(); 
      case 106: //Preferences desc 
         return item2->GetPreferences() - item1->GetPreferences(); 
      case 7: //failed asc 
         return item1->GetFailedCount() - item2->GetFailedCount(); 
      case 107: //failed desc 
		  return item2->GetFailedCount() - item1->GetFailedCount(); 
      case 8: //staticservers
      {
d838 2
a839 2
			if ((item2->IsStaticMember() && item1->IsStaticMember()) ||
				(!item2->IsStaticMember() && !item1->IsStaticMember()))
d841 2
a842 2
				bool	noname1=_tcsstr(item1->GetListName(),item1->GetFullIP()); 
				bool	noname2=_tcsstr(item2->GetListName(),item2->GetFullIP());
d845 1
a845 1
					iCompare = _tcsicmp(item1->GetListName(),item2->GetListName())*mod;
d860 1
a860 1
		  //return item2->IsStaticMember() - item1->IsStaticMember();
d862 1
a862 1
		case 108: //staticservers-
d865 2
a866 2
			if ((item1->IsStaticMember() && item2->IsStaticMember()) ||
				(!item1->IsStaticMember() && !item2->IsStaticMember()))
d868 2
a869 2
				bool	noname1=_tcsstr(item1->GetListName(),item1->GetFullIP()); 
				bool	noname2=_tcsstr(item2->GetListName(),item2->GetFullIP());
d872 1
a872 1
					iCompare = _tcsicmp(item2->GetListName(),item1->GetListName())*mod;
d887 1
a887 1
		  //return item1->IsStaticMember() - item2->IsStaticMember();
d889 6
a894 5
      case 9: //Soft files asc 
		if ((item1->GetSoftMaxFiles()>0 && item2->GetSoftMaxFiles()>0) || (item1->GetHardMaxFiles()>0 && item2->GetHardMaxFiles()>0))
			return item1->GetSoftMaxFiles() - item2->GetSoftMaxFiles(); 
		else return(item2->GetSoftMaxFiles()>0)?2:((item1->GetSoftMaxFiles()>0)?-1:0);
      case 109: //Soft files desc 
d896 6
a901 5
      case 59: //Hard files asc 
		if (item1->GetHardMaxFiles()>0 && item2->GetHardMaxFiles()>0) 
			return item1->GetHardMaxFiles() - item2->GetHardMaxFiles(); 
		else return(item2->GetHardMaxFiles()>0)?2:((item1->GetHardMaxFiles()>0)?-1:0);
      case 159: //Hard files desc 
d903 1
a903 1
      case 10: //Version asc 
d905 1
a905 1
      case 110: //Version desc 
d907 3
a909 3
      default: 
         return 0; 
   } 
d916 1
a916 1
		// Remove any entry before writing to avoid duplicates
d920 1
a920 1
		if (staticservers==NULL) 
d922 1
a922 1
			AddLogLine( false, IDS_ERROR_SSF);
d925 7
a931 7
		
		if (fprintf(staticservers,
					"%s:%i,%i,%s\n",
					server->GetAddress(),
					server->GetPort(), 
					server->GetPreferences(),
					server->GetListName()) != EOF) 
d967 1
a967 1
			AddLogLine( false, IDS_ERROR_SSF);
d978 1
a978 1
			// ignore comments or invalid lines
d990 1
a990 1
			// Only interested in "host:port"
d996 1
a996 1
			// Get host and port from given server
d999 1
a999 1
			// Compare, if not the same server write original line to temp file
d1007 3
a1009 3
		// All ok, remove the existing file and replace with the new one
		CFile::Remove( StaticFilePath );
		CFile::Rename( StaticTempPath, StaticFilePath );
d1011 1
a1011 1
		//purity
d1023 2
a1024 1
void CServerListCtrl::ShowFilesCount() {
d1028 1
a1028 1
	g_eMuleApp.m_pdlgEmule->m_wndServer.GetDlgItem(IDC_SERVLIST_TEXT)->SetWindowText(GetResString(IDS_SV_SERVERLIST)+counter  );
@


1.50
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d26 1
d39 1
a39 1
	memset(&m_bSortAscending,0,13);
@


1.49
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d237 1
a237 1
	if (server.GetHardFiles())
d239 2
a240 2
		if (server.GetSoftFiles())
			temp.Format(_T("%i (%i)"), server.GetSoftFiles(), server.GetHardFiles());
d242 1
a242 1
			temp.Format(_T("(%i)"), server.GetHardFiles());
d818 3
a820 3
		if ((item1->GetSoftFiles()>0 && item2->GetSoftFiles()>0) || (item1->GetHardFiles()>0 && item2->GetHardFiles()>0))
			return item1->GetSoftFiles() - item2->GetSoftFiles(); 
		else return(item2->GetSoftFiles()>0)?2:((item1->GetSoftFiles()>0)?-1:0);
d822 1
a822 1
		return item2->GetSoftFiles() - item1->GetSoftFiles();
d824 3
a826 3
		if (item1->GetHardFiles()>0 && item2->GetHardFiles()>0) 
			return item1->GetHardFiles() - item2->GetHardFiles(); 
		else return(item2->GetHardFiles()>0)?2:((item1->GetHardFiles()>0)?-1:0);
d828 1
a828 1
		return item2->GetHardFiles() - item1->GetHardFiles();
@


1.48
log
@Additional sorting when sorted by static
@
text
@d204 1
a204 1
	if(server.GetUsers()){
d206 1
a206 1
			temp.Format(_T("%i (%i)"),server.GetUsers(),server.GetMaxUsers());
d208 1
a208 1
		temp.Format(_T("%i"),server.GetUsers()); 
d733 3
a735 3
		if (item1->GetUsers()>0 && item2->GetUsers()>0) 
			return item1->GetUsers() - item2->GetUsers(); 
		else return(item2->GetUsers()>0)?2:((item1->GetUsers()>0)?-1:0);
d737 1
a737 1
		return item2->GetUsers() - item1->GetUsers();
@


1.47
log
@Formatting, comments, and name changes.
@
text
@d763 54
a816 4
      case 8: //staticservers 
		  return item2->IsStaticMember() - item1->IsStaticMember(); 
      case 108: //staticservers-
		  return item1->IsStaticMember() - item2->IsStaticMember(); 
@


1.46
log
@Fixed "IPs not sorted in server name column when sorting by server name".
@
text
@d170 2
a171 2
   for(POSITION pos = server_list->list.GetHeadPosition(); pos != NULL;server_list->list.GetNext(pos)) { 
      CServer* cur_server = server_list->list.GetAt(pos); 
d266 2
a267 2
		for(POSITION pos = server_list->list.GetHeadPosition(); pos != NULL;server_list->list.GetNext(pos)) { 
			CServer* cur_server = server_list->list.GetAt(pos); 
d271 1
a271 1
				pos = server_list->list.GetHeadPosition();
d494 1
a494 1
					g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*change);
d507 1
a507 1
					g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*change);
d516 1
a516 1
					change->SetPreference(CServer::ePR_LOW);
d519 1
a519 1
					g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*change);
d529 1
a529 1
					change->SetPreference(CServer::ePR_NORMAL);
d532 1
a532 1
					g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*change);
d542 1
a542 1
					change->SetPreference(CServer::ePR_HIGH);
d545 1
a545 1
					g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*change);
d812 1
a812 1
			g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*server);
d890 1
a890 1
		g_eMuleApp.m_pdlgEmule->m_wndServer.serverlistctrl.RefreshServer(*server);
@


1.45
log
@Formatting, comments, and name changes.
@
text
@d640 5
d646 7
a652 7
int CServerListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){ 
   CServer* item1 = (CServer*)lParam1; 
   CServer* item2 = (CServer*)lParam2; 
   if((item1 == NULL) || (item2 == NULL)) return 0; 
   int iTemp=0; 
   int counter1; 
   int counter2; 
d656 19
a674 24
   switch(lParamSort){ 
     case 100: //Server-name desc 
        mod=-1; 
     case 0: {//(List) Server-name asc { 
        bool noname1=_tcsstr(item1->GetListName(),item1->GetFullIP()); 
        bool noname2=_tcsstr(item2->GetListName(),item2->GetFullIP()); 
        if(!noname1 && !noname2)                
         return _tcsicmp(item1->GetListName(),item2->GetListName())*mod;    
      else return noname1?(noname2?0:2):-1; 
           } 
      case 1:{ //IP asc //corrected by Cax2 12/12/02 - dynIp put before 1.1.1.1
		if( item1->HasDynIP() && item2->HasDynIP() )
			return CString(item1->GetDynIP()).CompareNoCase(item2->GetDynIP());
		if(item1->HasDynIP()) return -1;
		if(item2->HasDynIP()) return 1;
		CString sIP1, sIP2, sTemp1, sTemp2; 
		counter1 = counter2 = iTemp = 0; 
		sIP1 = item2->GetFullIP(); 
		sIP2 = item1->GetFullIP(); 
		for(int i=0; iTemp == 0 ; i++){ 
			sTemp1 = sIP1.Tokenize(_T("."),counter1);
			sTemp2 = sIP2.Tokenize(_T("."),counter2);
			iTemp = _tstoi(sTemp2) - _tstoi(sTemp1);
			if(i>2)	return item1->GetPort()-item2->GetPort(); 
d676 45
a720 16
		return iTemp; 
	  }
      case 101:{ //IP desc 
		if( item1->HasDynIP() && item2->HasDynIP() )
			return CString(item2->GetDynIP()).CompareNoCase(item1->GetDynIP());
		if(item1->HasDynIP()) return 1;
		if(item2->HasDynIP()) return -1;
		CString s2IP1, s2IP2, s2Temp1, s2Temp2; 
		counter1 = counter2 = iTemp = 0; 
		s2IP1 = item2->GetFullIP(); 
		s2IP2 = item1->GetFullIP(); 
		for(int i=0; iTemp == 0 ; i++){ 
			s2Temp1 = s2IP1.Tokenize(_T("."),counter1);
			s2Temp2 = s2IP2.Tokenize(_T("."),counter2); 
			iTemp = _tstoi(s2Temp1) - _tstoi(s2Temp2); 
			if(i>2) return item2->GetPort() - item1->GetPort(); 
a721 2
		return iTemp; 
	  }
@


1.44
log
@Formatting, comments, and name changes.
@
text
@d38 1
a38 1
	memset(&asc_sort,0,13);
d69 2
a70 2
	asc_sort[4]=true;asc_sort[5]=true;asc_sort[7]=true;// Changed by Cax2 
	asc_sort[9]=true;asc_sort[10]=true;
d624 2
a625 2
		if(asc_sort[4]) asc_sort[11]=!asc_sort[11];
		adder= asc_sort[11]?0:50;
d628 2
a629 2
		if(asc_sort[9]) asc_sort[12]=!asc_sort[12];
		adder= asc_sort[12]?0:50;
d633 4
a636 4
   asc_sort[pNMListView->iSubItem] = !asc_sort[pNMListView->iSubItem]; 
   if (adder==0) SetSortArrow(pNMListView->iSubItem, asc_sort[pNMListView->iSubItem]);//Cax2 double arrows
   else SetSortArrow(pNMListView->iSubItem,asc_sort[pNMListView->iSubItem] ? arrowDoubleUp:arrowDoubleDown);// double arrows
   SortItems(&SortProc,pNMListView->iSubItem+adder+((asc_sort[pNMListView->iSubItem])? 0:100)); // double arrows
@


1.43
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d89 1
a89 1
	int m_CurrentSortItem=(sortCode<100)?sortCode:sortCode-100;
d94 1
a94 1
	else SetSortArrow(m_CurrentSortItem,(sortCode<100));
@


1.42
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d72 1
a72 1
	LoadSettings(CPreferences::tableServer);
@


1.41
log
@New sockets
@
text
@d74 1
a74 1
	if (theApp.glob_prefs->DoUseSort())	SortInit(theApp.glob_prefs->GetServerSortCol());//Cax2 sortdlg
d263 1
a263 1
	if( theApp.glob_prefs->DeadServer() ){
d268 1
a268 1
			if( cur_server->GetFailedCount() > theApp.glob_prefs->GetDeadserverRetries() &&
d278 1
a278 1
			if( cur_server->GetFailedCount() > theApp.glob_prefs->GetDeadserverRetries() &&
d407 1
a407 1
	if( theApp.serverconnect->IsConnecting() )
d409 4
a412 4
	   	theApp.downloadqueue->StopUDPRequests(); 
		theApp.serverconnect->StopConnectionTry();
		theApp.serverconnect->Disconnect();
		theApp.emuledlg->ShowConnectionState(false);
d434 1
a434 1
					theApp.serverconnect->Disconnect();
d443 1
a443 1
							theApp.serverlist->MoveServerDown(aServer);
d447 1
a447 1
					theApp.serverconnect->ConnectToAnyServer( (theApp.serverlist->GetServerCount() - GetSelectedCount()), false);
d449 1
a449 1
					theApp.pEngine->ConnectToAnyServer();
d454 2
a455 2
					if (theApp.serverconnect->IsConnected()){       
						if (!_tcscmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (theApp.serverconnect->GetCurrentServer())->GetAddress())){ 
d461 1
a461 1
					theApp.serverconnect->ConnectToServer(*(CServer*)GetItemData(GetSelectionMark()));
d466 1
a466 1
						theApp.pEngine->ConnectToServer(pServer);
d469 1
a469 1
				theApp.emuledlg->ShowConnectionState(false);
d494 1
a494 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*change);
d507 1
a507 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*change);
d519 1
a519 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*change);
d532 1
a532 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*change);
d545 1
a545 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*change);
d561 1
a561 1
				theApp.CopyTextToClipboard(link); 
d575 1
a575 1
				theApp.emuledlg->ircwnd.SetSendFileString(link);
d590 1
a590 1
      	if (theApp.serverconnect->IsConnected())
d592 1
a592 1
			if (!_tcscmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (theApp.serverconnect->GetCurrentServer())->GetAddress()))
d598 1
a598 1
		theApp.serverconnect->ConnectToServer(*(CServer*)GetItemData(GetSelectionMark())); 
d603 1
a603 1
		theApp.pEngine->ConnectToServer(pServer);
d605 1
a605 1
	   	theApp.emuledlg->ShowConnectionState(false);
d768 1
a768 1
		FILE* staticservers = _tfopen(theApp.glob_prefs->GetConfigDir() + CString(_T("staticservers.dat")), _T("a"));
d785 1
a785 1
			theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*server);
d809 2
a810 2
		CString StaticFilePath = theApp.glob_prefs->GetConfigDir() + CString("staticservers.dat");
		CString StaticTempPath = theApp.glob_prefs->GetConfigDir() + CString("statictemp.dat");
d863 1
a863 1
		theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(*server);
d876 1
a876 1
	theApp.emuledlg->serverwnd.GetDlgItem(IDC_SERVLIST_TEXT)->SetWindowText(GetResString(IDS_SV_SERVERLIST)+counter  );
@


1.40
log
@New sockets - more server logic
@
text
@d448 2
@


1.39
log
@New sockets
@
text
@d464 1
a464 4
						theApp.pEngine->ConnectToServer(
							pServer->GetAddress(), 
							pServer->GetPort(), 
							pServer->GetListName());
d601 1
a601 4
		theApp.pEngine->ConnectToServer(
			pServer->GetAddress(),
			pServer->GetPort(),
			pServer->GetListName());
@


1.38
log
@Implemented ConfigDir
@
text
@d25 1
d464 1
a464 1
						theApp.stEngine.ConnectToServer(
d604 1
a604 1
		theApp.stEngine.ConnectToServer(
@


1.37
log
@New sockets. Connecting to server from server list
@
text
@d771 1
a771 1
		FILE* staticservers = _tfopen(theApp.glob_prefs->GetAppDir() + CString(_T("staticservers.dat")), _T("a"));
d812 2
a813 2
		CString StaticFilePath = theApp.glob_prefs->GetAppDir() + CString("staticservers.dat");
		CString StaticTempPath = theApp.glob_prefs->GetAppDir() + CString("statictemp.dat");
@


1.36
log
@Separated debug log
@
text
@d460 8
d600 8
@


1.35
log
@added columns Soft/Hard Files Limit and Version in server window (merge from official)
@
text
@d65 1
a65 1
	InsertColumn(9,GetResString(IDS_SERVER_SOFTHARDLIMIT),LVCFMT_LEFT, 100);
@


1.34
log
@futher change of ConnectToAnyServer()
@
text
@d37 1
a37 1
	memset(&asc_sort,0,9);
d65 2
d69 1
d88 6
a93 4
	int m_CurrentSortItem=(sortCode<10)?sortCode:sortCode-10;
	if (sortCode==9||sortCode==19)
		SetSortArrow(4,(sortCode==9)? arrowDoubleUp:arrowDoubleDown);
	else SetSortArrow(m_CurrentSortItem,(sortCode<10));
d152 10
d235 11
d611 6
a616 2
		if(asc_sort[4]) asc_sort[9]=!asc_sort[9];
		adder= asc_sort[9]?0:5;
d623 1
a623 1
   SortItems(&SortProc,pNMListView->iSubItem+adder+((asc_sort[pNMListView->iSubItem])? 0:10)); // double arrows
d639 1
a639 1
     case 10: //Server-name desc 
d665 1
a665 1
      case 11:{ //IP desc 
d684 1
a684 1
      case 12: //Desciption desc 
d690 1
a690 1
	  case 13: //Ping desc 
d696 1
a696 1
      case 14: //Users desc 
d698 10
d712 1
a712 1
      case 15: //Files desc 
d717 1
a717 1
      case 16: //Preferences desc 
d721 1
a721 1
      case 17: //failed desc 
d725 1
a725 1
      case 18: //staticservers-
d727 16
a742 10
      case 9: //max. users
		  if(item1->GetMaxUsers() == item2->GetMaxUsers())
			  return 0;
		  if(item1->GetMaxUsers() == 0)
			  return 1;
		  if(item2->GetMaxUsers() == 0)
			  return -1;
		  return item1->GetMaxUsers() - item2->GetMaxUsers(); 
	  case 19: //Cax2 patch 21/12/02
		 return item2->GetMaxUsers() - item1->GetMaxUsers();
@


1.33
log
@check NULL case in AddServer() function
@
text
@d420 1
a420 1
					theApp.serverconnect->ConnectToAnyServer( theApp.serverlist->GetServerCount() - GetSelectedCount() );
@


1.32
log
@unicode cleanup
@
text
@d271 6
a276 3
bool CServerListCtrl::AddServer(CServer* toadd,bool bAddToList, bool bulkLoad){ 
   if (!server_list->AddServer(toadd)) 
      return false; 
@


1.31
log
@unicode cleanup
@
text
@d59 1
a59 1
	temp.Format( "%s (%s)", GetResString(IDS_UUSERS), GetResString(IDS_MAXUSERS));
d123 1
a123 1
	strRes.Format( "%s (%s)", GetResString(IDS_UUSERS), GetResString(IDS_MAXUSERS));
d176 1
a176 1
	temp.Format( "%s : %i",server.GetAddress(),server.GetPort());
d185 1
a185 1
		temp.Format( "%i",server.GetPing()); 
d190 1
a190 1
			temp.Format( "%i (%i)",server.GetUsers(),server.GetMaxUsers());
d192 1
a192 1
		temp.Format( "%i",server.GetUsers()); 
d196 1
a196 1
		temp.Format( "%i",server.GetFiles()); 
d213 1
a213 1
	temp.Format( "%i",server.GetFailedCount()); 
d423 1
a423 1
						if (!strcmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (theApp.serverconnect->GetCurrentServer())->GetAddress())){ 
d519 2
a520 2
					buffer.Format("ed2k://|server|%s|%d|/", change->GetFullIP(), change->GetPort()); 
					if (link.GetLength()>0) buffer="\n"+buffer;
d533 2
a534 2
					buffer.Format("ed2k://|server|%s|%d|/", change->GetFullIP(), change->GetPort()); 
					if (link.GetLength()>0) buffer="\n"+buffer;
d555 1
a555 1
			if (!strcmp(((CServer*)GetItemData(GetSelectionMark()))->GetAddress(), (theApp.serverconnect->GetCurrentServer())->GetAddress()))
d609 2
a610 2
        bool noname1=strstr(item1->GetListName(),item1->GetFullIP()); 
        bool noname2=strstr(item2->GetListName(),item2->GetFullIP()); 
d612 1
a612 1
         return _stricmp(item1->GetListName(),item2->GetListName())*mod;    
d625 2
a626 2
			sTemp1 = sIP1.Tokenize(".",counter1);
			sTemp2 = sIP2.Tokenize(".",counter2);
d642 2
a643 2
			s2Temp1 = s2IP1.Tokenize(".",counter1);
			s2Temp2 = s2IP2.Tokenize(".",counter2); 
d706 1
a706 1
		FILE* staticservers = _tfopen(theApp.glob_prefs->GetAppDir() + CString("staticservers.dat"), "a");
d721 1
a721 1
				AddLogLine(false, "'%s:%i,%s' %s", server->GetAddress(), server->GetPort(), server->GetListName(), GetResString(IDS_ADDED2SSF));
d749 2
a750 2
		FILE* staticservers = _tfopen(StaticFilePath , "r");
		FILE* statictemp = _tfopen(StaticTempPath , "w");
d784 1
a784 1
			strTest.Format("%s:%i", server->GetAddress(), server->GetPort());
d799 1
a799 1
		AddLogLine(false, "'%s:%i,%s' %s", server->GetAddress(), server->GetPort(), server->GetListName(), GetResString(IDS_REMOVEDFROMSSF));
d813 1
a813 1
	counter.Format(" (%i)", GetItemCount());
@


1.30
log
@Preparing for new sockets
@
text
@d627 1
a627 1
			iTemp = atoi(sTemp2) - atoi(sTemp1);
d644 1
a644 1
			iTemp = atoi(s2Temp1) - atoi(s2Temp2); 
d706 1
a706 1
		FILE* staticservers = fopen(theApp.glob_prefs->GetAppDir() + CString("staticservers.dat"), "a");
d749 2
a750 2
		FILE* staticservers = fopen(StaticFilePath , "r");
		FILE* statictemp = fopen(StaticTempPath , "w");
@


1.29
log
@Purity's webserver changes. Mostly.
@
text
@d376 1
d384 1
d403 1
d405 1
d416 1
d418 1
d421 1
d430 1
d552 1
d562 1
@


1.28
log
@converted to new logger methods
@
text
@d787 5
@


1.27
log
@CHANGE: hide greyed-out "add / remove from static server" in serverlist [SyruS]
@
text
@d417 1
a417 1
							AddLogLine( false, GetResString(IDS_ALREADYCONNECTED), ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
d548 1
a548 1
            		AddLogLine( false, GetResString(IDS_ALREADYCONNECTED), ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
d699 1
a699 1
			AddLogLine( false, GetResString(IDS_ERROR_SSF));
d744 1
a744 1
			AddLogLine( false, GetResString(IDS_ERROR_SSF));
@


1.26
log
@small optimisations in server list handling
@
text
@d321 1
a321 1
	UINT flags,flagSSL1,flagSSL2;
d333 4
a336 5
	flagSSL1=MF_STRING || MF_DISABLED;
	flagSSL2=MF_STRING || MF_DISABLED;

	if (test != NULL && GetSelectedCount()>0) 
		if (test->IsStaticMember()) flagSSL2=MF_STRING; else flagSSL1=MF_STRING;
d348 6
a353 2
	m_ServerMenu.AppendMenu(flagSSL1,MP_ADDTOSTATIC, GetResString(IDS_ADDTOSTATIC));
	m_ServerMenu.AppendMenu(flagSSL2,MP_REMOVEFROMSTATIC, GetResString(IDS_REMOVEFROMSTATIC));
@


1.25
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d163 2
a164 1
void CServerListCtrl::RemoveServer(CServer* todel,bool bDelToList){
d168 61
a228 5
	find.lParam = (LPARAM)todel;
	sint32 result = FindItem(&find);
	if (result != (-1) ){
	server_list->RemoveServer((CServer*)GetItemData(result));
	DeleteItem(result); 
d262 10
a271 1
bool CServerListCtrl::AddServer(CServer* toadd,bool bAddToList){ 
d274 4
a277 7
   if (bAddToList) 
   {
	   uint32 itemnr = GetItemCount();
	   InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,toadd->GetListName(),0,0,1,(LPARAM)toadd);
	   RefreshServer( toadd );
   } 
   ShowFilesCount();
d282 1
a282 1
void CServerListCtrl::RefreshServer( CServer* server ){
d286 4
d291 3
a293 55
	LVFINDINFO find;
	::ZeroMemory(&find,sizeof(LVFINDINFO));
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)server;
	sint32 itemnr = FindItem(&find);
	if (itemnr == (-1))
		return;
	CString temp;
	if( !server )
		return;
	temp.Format( "%s : %i",server->GetAddress(),server->GetPort());
	SetItemText(itemnr,1,(LPCTSTR)temp);
	if(server->GetListName()){
		SetItemText(itemnr,0,server->GetListName());
	}
	if(server->GetDescription()){
		SetItemText(itemnr,2,server->GetDescription());
	}
	if(server->GetPing()){
		temp.Format( "%i",server->GetPing()); 
		SetItemText(itemnr,3,(LPCTSTR)temp);
	}
	if(server->GetUsers()){
		if( server->GetMaxUsers() )
			temp.Format( "%i (%i)",server->GetUsers(),server->GetMaxUsers());
		else
		temp.Format( "%i",server->GetUsers()); 
		SetItemText(itemnr,4,(LPCTSTR)temp);
	}
	if(server->GetFiles()){
		temp.Format( "%i",server->GetFiles()); 
		SetItemText(itemnr,5,(LPCTSTR)temp);
	}
	switch(server->GetPreferences()){
		case PR_LOW:
			SetItemText(itemnr,6,(LPCTSTR)GetResString(IDS_PRIOLOW));
			break;
		case PR_NORMAL:
			SetItemText(itemnr,6,(LPCTSTR)GetResString(IDS_PRIONORMAL));
			break;
		case PR_HIGH:
			SetItemText(itemnr,6,(LPCTSTR)GetResString(IDS_PRIOHIGH));
			break;
		default:
			SetItemText(itemnr,6,(LPCTSTR)GetResString(IDS_PRIONOPREF));
	}
	if( server->GetFailedCount() < 0 )
		server->ResetFailedCount();
	temp.Format( "%i",server->GetFailedCount()); 
	SetItemText(itemnr,7,(LPCTSTR)temp);
	
	if (server->IsStaticMember())
		SetItemText(itemnr,8,GetResString(IDS_YES)); 
	else
		SetItemText(itemnr,8,GetResString(IDS_NO));
d446 1
a446 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
d459 1
a459 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
d471 1
a471 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
d484 1
a484 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
d497 1
a497 1
					theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
d710 1
a710 1
			theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(server);
@


1.24
log
@code cleanup
@
text
@d75 6
d286 1
@


1.23
log
@minor fixes and improvements
@
text
@d397 1
a397 1
					theApp.serverconnect->ConnectToServer((CServer*)GetItemData(GetSelectionMark()));
d527 1
a527 1
		theApp.serverconnect->ConnectToServer((CServer*)GetItemData(GetSelectionMark())); 
@


1.22
log
@Some code housekeeping changes
@
text
@d276 1
a276 1
   ON_NOTIFY_REFLECT(NM_RCLICK, OnNMRclickServlist) 
d279 1
d284 1
a284 1
void CServerListCtrl::OnNMRclickServlist(NMHDR *pNMHDR, LRESULT *pResult) 
d286 2
a287 2
	POINT point; 
	::GetCursorPos(&point); 
d343 1
a343 1
	*pResult = 0; 
@


1.21
log
@CServerList moved to use new CSafe array , suppouse to work faster , safer  and to be the step to the virtual list controls .
@
text
@d445 1
a445 1
					change->SetPreference(PR_LOW);
d458 1
a458 1
					change->SetPreference(PR_NORMAL);
d471 1
a471 1
					change->SetPreference(PR_HIGH);
@


1.20
log
@code cleanup
@
text
@d175 1
d184 11
@


1.19
log
@fixed crash at exit
@
text
@d601 2
a602 5
      case 2: //Description asc //corrected by Cax2
		    //the 'if' is necessary, because Description can be null
         if(item1->GetDescription()!=NULL && item2->GetDescription()!=NULL) 
			return CString(item1->GetDescription()).CompareNoCase(item2->GetDescription());
		 return (item1->GetDescription()!=NULL)?-1:((item2->GetDescription()!=NULL)?2:0);
d604 1
a604 3
         if(item1->GetDescription()!=NULL && item2->GetDescription()!=NULL)
			return CString(item2->GetDescription()).CompareNoCase(item1->GetDescription());
		 return (item1->GetDescription()!=NULL)?-1:((item2->GetDescription()!=NULL)?2:0);
@


1.18
log
@Check for server connected on doubleclick now by IP (BUG #0000173)
@
text
@d203 3
@


1.17
log
@Fixed bug #130
@
text
@d503 1
a503 1
      		if (theApp.serverconnect->IsConnected())
d505 1
a505 1
         		if (!strcmp(((CServer*)GetItemData(GetSelectionMark()))->GetListName(), (theApp.serverconnect->GetCurrentServer())->GetListName()))
d507 2
a508 2
            			AddLogLine( false, GetResString(IDS_ALREADYCONNECTED), ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
            			return; 
@


1.17.2.1
log
@27a partial merge
@
text
@d58 7
a64 6
	InsertColumn(4, GetResString(IDS_UUSERS), LVCFMT_RIGHT, 50);
	InsertColumn(5, GetResString(IDS_MAXUSERS), LVCFMT_RIGHT, 50);
	InsertColumn(6,GetResString(IDS_FILES) ,LVCFMT_RIGHT, 50);
	InsertColumn(7,GetResString(IDS_PRIORITY),LVCFMT_LEFT, 60);
	InsertColumn(8,GetResString(IDS_UFAILED),LVCFMT_RIGHT, 50);
	InsertColumn(9,GetResString(IDS_STATICSERVER),LVCFMT_LEFT, 50);
d116 2
a117 1
	strRes = GetResString(IDS_UUSERS);
a120 5
 
	strRes = GetResString(IDS_MAXUSERS);
	hdi.pszText = strRes.GetBuffer();
	pHeaderCtrl->SetItem(5, &hdi);
	strRes.ReleaseBuffer();
d124 1
a124 1
	pHeaderCtrl->SetItem(6, &hdi);
d129 1
a129 1
	pHeaderCtrl->SetItem(7, &hdi);
d134 1
a134 1
	pHeaderCtrl->SetItem(8, &hdi);
d139 1
a139 1
	pHeaderCtrl->SetItem(9, &hdi);
d226 3
a231 4
	if(server->GetMaxUsers()){
		temp.Format( "%i",server->GetMaxUsers()); 
		SetItemText(itemnr,5,(LPCTSTR)temp);
	}
d234 1
a234 1
		SetItemText(itemnr,6,(LPCTSTR)temp);
d238 1
a238 1
			SetItemText(itemnr,7,(LPCTSTR)GetResString(IDS_PRIOLOW));
d241 1
a241 1
			SetItemText(itemnr,7,(LPCTSTR)GetResString(IDS_PRIONORMAL));
d244 1
a244 1
			SetItemText(itemnr,7,(LPCTSTR)GetResString(IDS_PRIOHIGH));
d247 1
a247 1
			SetItemText(itemnr,7,(LPCTSTR)GetResString(IDS_PRIONOPREF));
d252 1
a252 1
	SetItemText(itemnr,8,(LPCTSTR)temp);
d255 1
a255 1
		SetItemText(itemnr,9,GetResString(IDS_YES)); 
d257 1
a257 1
		SetItemText(itemnr,9,GetResString(IDS_NO));
d619 1
a619 11
      case 5: //Max Users asc 
		  if(item1->GetMaxUsers() == item2->GetMaxUsers())
			  return 0;
		  if(item1->GetMaxUsers() == 0)
			  return 1;
		  if(item2->GetMaxUsers() == 0)
			  return -1;
		  return item1->GetMaxUsers() - item2->GetMaxUsers(); 
      case 15: //Max Users desc 
		 return item2->GetMaxUsers() - item1->GetMaxUsers();
	  case 6: //Files asc 
d623 1
a623 1
      case 16: //Files desc 
d626 1
a626 1
		case 7: //Preferences asc 
d628 1
a628 1
      case 17: //Preferences desc 
d630 1
a630 1
      case 8: //failed asc 
d632 1
a632 1
      case 18: //failed desc 
d634 1
a634 1
      case 9: //staticservers 
d636 1
a636 1
      case 19: //staticservers-
d638 10
@


1.17.2.2
log
@*** empty log message ***
@
text
@d533 5
d541 4
a544 2
   SetSortArrow(pNMListView->iSubItem, asc_sort[pNMListView->iSubItem]);
   SortItems(&SortProc,pNMListView->iSubItem+((asc_sort[pNMListView->iSubItem])? 0:10));
@


1.17.2.3
log
@27c
@
text
@d265 1
a267 1
   ON_WM_CONTEXTMENU()
d272 1
a272 1
void CServerListCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
d274 3
d330 2
@


1.16
log
@bugifx: bug #10
@
text
@d177 2
a178 1
			if( cur_server->GetFailedCount() > theApp.glob_prefs->GetDeadserverRetries() ){	// MAX_SERVERFAILCOUNT 
@


1.15
log
@converted to new logging method
@
text
@d62 1
a62 1
	InsertColumn(6,GetResString(IDS_PREFERENCE),LVCFMT_LEFT, 60);
d127 1
a127 1
	strRes = GetResString(IDS_PREFERENCE);
d625 3
a627 1
      case 6: //Preferences asc 
a628 2
      case 16: //Preferences desc 
		  return item1->GetPreferences() - item2->GetPreferences(); 
@


1.14
log
@Updated statics server management (BUG #0000110)
@
text
@d375 1
a375 1
							theApp.emuledlg->AddLogLine( false, GetResString(IDS_ALREADYCONNECTED), ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
d506 1
a506 1
            			theApp.emuledlg->AddLogLine( false, GetResString(IDS_ALREADYCONNECTED), ((CServer*)GetItemData(GetSelectionMark()))->GetListName()); 
d662 1
a662 1
			theApp.emuledlg->AddLogLine( false, GetResString(IDS_ERROR_SSF));
d674 1
a674 1
				theApp.emuledlg->AddLogLine(false, "'%s:%i,%s' %s", server->GetAddress(), server->GetPort(), server->GetListName(), GetResString(IDS_ADDED2SSF));
d707 1
a707 1
			theApp.emuledlg->AddLogLine( false, GetResString(IDS_ERROR_SSF));
@


1.13
log
@Messages friend details working & solved context menu problems (Damn! we need a redesign of that). Now version 1b beta 1.
@
text
@d673 2
a674 1
			theApp.emuledlg->AddLogLine(false, "'%s:%i,%s' %s", server->GetAddress(), server->GetPort(), server->GetListName(), GetResString(IDS_ADDED2SSF));
d720 2
d723 1
d725 2
d728 1
@


1.12
log
@minor graphic details bugfixed, now preview player selection same as official
@
text
@d291 3
a293 1
	if (GetSelectionMark() != -1) if (test != NULL) flags=MF_STRING;
d297 1
a297 1
	if (test != NULL) 
a303 1

@


1.11
log
@minor bugfixes, refreshes sources display...
@
text
@d45 2
a46 2
	imagelist.Create(16,16,ILC_COLOR32,0,10); // changed by FoRcHa
	imagelist.SetBkColor(GetBkColor());		//Cax2 - for non-white backgrounds...
@


1.10
log
@Updated conetext menus.
@
text
@d46 1
a46 1
	imagelist.SetBkColor(RGB(255,255,255));
@


1.10.2.1
log
@v1a upgrade
@
text
@d45 2
a46 2
	imagelist.Create(16,16,ILC_COLOR32|ILC_MASK,0,10); // changed by FoRcHa + Cax2 - highlight bugfix
	imagelist.SetBkColor(CLR_NONE);		//Cax2 - highlight bugfix
d291 1
a291 3
	if (GetSelectionMark() != (-1) && GetSelectedCount()>0)
		if (test != NULL)
			flags=MF_STRING;
d295 1
a295 1
	if (test != NULL && GetSelectedCount()>0) 
d302 1
@


1.9
log
@Banning Message, A4AF customization, AutoPriority fix, Static Servers fix, .dat/.bin Preview
@
text
@d316 1
a316 1
	m_ServerMenu.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
d318 1
a318 1
	   
@


1.8
log
@Crashfix for bug with empty server list.
@
text
@d307 1
a307 5
	if (test != NULL) 
		if (!test->IsStaticMember())
			m_ServerMenu.AppendMenu(flags|MF_POPUP,(UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
		else
			m_ServerMenu.AppendMenu(MF_GRAYED|MF_POPUP,(UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
d429 2
d442 2
d455 2
@


1.7
log
@Little fixes and Static Servers additions from 26d
@
text
@d307 5
a311 4
	if (!test->IsStaticMember())
		m_ServerMenu.AppendMenu(flags|MF_POPUP,(UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
	else
		m_ServerMenu.AppendMenu(MF_GRAYED|MF_POPUP,(UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));
@


1.6
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d269 2
a270 2
   POINT point; 
   ::GetCursorPos(&point); 
d272 52
a323 49
   // tecxx 0609 2002 
   // fix - on right click, we also want to change the current selection like the left click does 
   CPoint p = point; 
   ScreenToClient(&p); 
   int it = HitTest(p); 
   if (it != -1) 
      SetSelectionMark(it);   // display selection mark correctly! 
   // fix end 

   // Create up-to-date popupmenu
   UINT flags,flagSSL1,flagSSL2;
   CTitleMenu m_ServerMenu;
   CMenu m_ServerPrioMenu;

   CServer* test=NULL;
   if (GetSelectionMark() != -1) test=(CServer*)GetItemData(GetSelectionMark());

   // set state of selection-dependent menuitems
   flags=MF_STRING || MF_DISABLED;
   if (GetSelectionMark() != -1) if (test != NULL) flags=MF_STRING;
   flagSSL1=MF_STRING || MF_DISABLED;
   flagSSL2=MF_STRING || MF_DISABLED;

   if (test != NULL) 
	   if (test->IsStaticMember()) flagSSL2=MF_STRING; else flagSSL1=MF_STRING;
   
   // add priority switcher
   m_ServerPrioMenu.CreateMenu();
   m_ServerPrioMenu.AppendMenu(MF_STRING,MP_PRIOLOW,GetResString(IDS_PRIOLOW));
   m_ServerPrioMenu.AppendMenu(MF_STRING,MP_PRIONORMAL,GetResString(IDS_PRIONORMAL));
   m_ServerPrioMenu.AppendMenu(MF_STRING,MP_PRIOHIGH,GetResString(IDS_PRIOHIGH));

   m_ServerMenu.CreatePopupMenu(); 
   m_ServerMenu.AddMenuTitle(GetResString(IDS_EM_SERVER));
   m_ServerMenu.AppendMenu(flags,MP_CONNECTTO, GetResString(IDS_CONNECTTHIS)); 
   m_ServerMenu.AppendMenu(flags|MF_POPUP,(UINT_PTR)m_ServerPrioMenu.m_hMenu, GetResString(IDS_PRIORITY));

   m_ServerMenu.AppendMenu(flagSSL1,MP_ADDTOSTATIC, GetResString(IDS_ADDTOSTATIC));
   m_ServerMenu.AppendMenu(flagSSL2,MP_REMOVEFROMSTATIC, GetResString(IDS_REMOVEFROMSTATIC));

   m_ServerMenu.AppendMenu(MF_STRING|MF_SEPARATOR);	
   m_ServerMenu.AppendMenu(flags,MP_REMOVE, GetResString(IDS_REMOVETHIS)); 
   m_ServerMenu.AppendMenu(MF_STRING,MP_REMOVEALL, GetResString(IDS_REMOVEALL));
   m_ServerMenu.AppendMenu(MF_SEPARATOR); 
   m_ServerMenu.AppendMenu(MF_STRING,MP_GETED2KLINK, GetResString(IDS_DL_LINK1));
   // m_ServerMenu.AppendMenu(MF_STRING,Irc_SetSendLink, GetResString(IDS_IRC_ADDLINKTOIRC)); 
   
   m_ServerMenu.SetDefaultItem(MP_CONNECTTO);
   m_ServerMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this); 
d325 2
a326 2
   m_ServerPrioMenu.DestroyMenu(); // Added by Tarod -leak fix
   m_ServerMenu.DestroyMenu();
d328 1
a328 1
   *pResult = 0; 
d395 1
a395 1
					server_list->RemoveServer( (CServer*)GetItemData(item));
d402 1
a402 7
			case MP_ADDTOSTATIC:
				{
				FILE* staticservers = fopen(theApp.glob_prefs->GetAppDir() + CString("staticservers.dat"), "a");
				if (staticservers==NULL) {
					theApp.emuledlg->AddLogLine( false, GetResString(IDS_ERROR_SSF));
					return false;
				}
d405 5
a409 10
					CServer* change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
					if (!change->IsStaticMember()) {
						if (EOF!=fprintf(staticservers,"%s:%i,%s\n",
							change->GetAddress(),change->GetPort(),change->GetListName())) {
							theApp.emuledlg->AddLogLine( false, "'%s:%i,%s' %s",
								change->GetAddress(),change->GetPort(),change->GetListName(),GetResString(IDS_ADDED2SSF));
							change->SetIsStaticMember(true);
							theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
						}
					}
a410 1
				fclose(staticservers);
d413 1
a413 1
			// Remove Static Servers [DonGato]
d416 7
a422 34
				CString StaticFilePath = theApp.glob_prefs->GetAppDir() + CString("staticservers.dat");
				CString StaticTempPath = theApp.glob_prefs->GetAppDir() + CString("statictemp.dat");
				FILE* staticservers = fopen(StaticFilePath , "r");
				FILE* statictemp = fopen(StaticTempPath , "w");
				if (staticservers==NULL) {
					theApp.emuledlg->AddLogLine( false, GetResString(IDS_ERROR_SSF));
					return false;
				}
				char buffer[200];
				CServer* change;
				CString text1;
				CString text2;
				bool erased;

				while(fgets(buffer, 99, staticservers)!=NULL){ 
					POSITION pos=GetFirstSelectedItemPosition();
					erased = false;
					while( pos != NULL ){
					  change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
					  //if (change->IsStaticMember()){
						text1.Format("%s:%i,%s\n",change->GetAddress(),change->GetPort(),change->GetListName());
						text2.Format("%s,%i,%s\n",change->GetAddress(),change->GetPort(),change->GetListName());
						if(!text1.Compare(buffer) || !text2.Compare(buffer)) {
								theApp.emuledlg->AddLogLine(false, "'%s:%i,%s' %s",change->GetAddress(),change->GetPort(),
								change->GetListName(),GetResString(IDS_REMOVEFROMSTOK));
								change->SetIsStaticMember(false);
								theApp.emuledlg->serverwnd.serverlistctrl.RefreshServer(change);
								erased = true;
								break;
							}
					  //}
					}
					if (!erased)
						fprintf(statictemp, buffer);
a423 4
				fclose(staticservers);
				fclose(statictemp);
				CFile::Remove( StaticFilePath );
				CFile::Rename( StaticTempPath, StaticFilePath );
d430 2
a431 2
					CServer* change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
					change->SetPreference( PR_LOW);
d433 1
a433 1
					POSITION pos = GetFirstSelectedItemPosition();
d441 2
a442 2
					CServer* change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
					change->SetPreference( PR_NORMAL );
d444 1
a444 1
					POSITION pos = GetFirstSelectedItemPosition();
d452 2
a453 2
					CServer* change = (CServer*)this->GetItemData(GetNextSelectedItem(pos));
					change->SetPreference( PR_HIGH );
d455 1
a455 1
					POSITION pos = GetFirstSelectedItemPosition();
d647 100
a752 1

@


1.5
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d344 1
d395 1
d556 1
@


1.4
log
@*** empty log message ***
@
text
@d26 7
@


1.3
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d152 1
d196 1
@


1.2
log
@Fixed a problem with server list control that malformed server name or description could cause a crash.
@
text
@d159 1
d187 1
d542 1
d545 1
d674 8
a681 1
}@


1.2.4.1
log
@initial upgrade to .26
@
text
@a158 1
	ShowFilesCount();
d185 1
a185 2
   }
   ShowFilesCount();
a539 1
   SetRedraw(false);
a541 1
   SetRedraw(true);
d670 1
a670 9
}

void CServerListCtrl::ShowFilesCount() {
	CString counter;

	counter.Format(" (%i)", GetItemCount());
	theApp.emuledlg->serverwnd.GetDlgItem(IDC_SERVLIST_TEXT)->SetWindowText(GetResString(IDS_SV_SERVERLIST)+counter  );
}

@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d204 1
a204 2
		temp.Format( server->GetListName());
		SetItemText(itemnr,0,(LPCTSTR)temp);
d207 1
a207 2
		temp.Format( server->GetDescription());
		SetItemText(itemnr,2,(LPCTSTR)temp);
d226 1
a226 2
			temp.Format(GetResString(IDS_PRIOLOW));
			SetItemText(itemnr,6,(LPCTSTR)temp);
d229 1
a229 2
			temp.Format(GetResString(IDS_PRIONORMAL));
			SetItemText(itemnr,6,(LPCTSTR)temp);
d232 1
a232 2
			temp.Format(GetResString(IDS_PRIOHIGH));
			SetItemText(itemnr,6,(LPCTSTR)temp);
d235 1
a235 2
			temp.Format(GetResString(IDS_PRIONOPREF));
			SetItemText(itemnr,6,(LPCTSTR)temp);
@

