head	1.2;
access;
symbols
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.8
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.6
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.4
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.2;
locks; strict;
comment	@ * @;


1.2
date	2003.04.29.16.12.56;	author kuchin;	state dead;
branches;
next	1.1;

1.1
date	2003.02.25.10.54.18;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.02.25.13.42.20;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.2
log
@*** empty log message ***
@
text
@/*-
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 2001-2002
 *	Sleepycat Software.  All rights reserved.
 */

#include "db_config.h"

#ifndef lint
static const char revid[] = "$Id: db_idspace.c,v 1.1 2003/02/25 10:54:18 kuchin Exp $";
#endif /* not lint */

#ifndef NO_SYSTEM_INCLUDES
#include <sys/types.h>

#include <stdlib.h>
#endif

#include "db_int.h"

static int __db_idcmp __P((const void *, const void *));

static int
__db_idcmp(a, b)
	const void *a;
	const void *b;
{
	u_int32_t i, j;

	i = *(u_int32_t *)a;
	j = *(u_int32_t *)b;

	if (i < j)
		return (-1);
	else if (i > j)
		return (1);
	else
		return (0);
}

/*
 * __db_idspace --
 *
 * On input, minp and maxp contain the minimum and maximum valid values for
 * the name space and on return, they contain the minimum and maximum ids
 * available (by finding the biggest gap).
 *
 * PUBLIC: void __db_idspace __P((u_int32_t *, int, u_int32_t *, u_int32_t *));
 */
void
__db_idspace(inuse, n, minp, maxp)
	u_int32_t *inuse;
	int n;
	u_int32_t *minp, *maxp;
{
	int i, low;
	u_int32_t gap, t;

	/* A single locker ID is a special case. */
	if (n == 1) {
		/*
		 * If the single item in use is the last one in the range,
		 * then we've got to perform wrap which means that we set
		 * the min to the minimum ID, which is what we came in with,
		 * so we don't do anything.
		 */
		if (inuse[0] != *maxp)
			*minp = inuse[0];
		*maxp = inuse[0] - 1;
		return;
	}

	gap = 0;
	low = 0;
	qsort(inuse, n, sizeof(u_int32_t), __db_idcmp);
	for (i = 0; i < n - 1; i++)
		if ((t = (inuse[i + 1] - inuse[i])) > gap) {
			gap = t;
			low = i;
		}

	/* Check for largest gap at the end of the space. */
	if ((*maxp - inuse[n - 1]) + (inuse[0] - *minp) > gap) {
		/* Do same check as we do in the n == 1 case. */
		if (inuse[n - 1] != *maxp)
			*minp = inuse[n - 1];
		*maxp = inuse[0];
	} else {
		*minp = inuse[low];
		*maxp = inuse[low + 1];
	}
}
@


1.1
log
@*** empty log message ***
@
text
@d11 1
a11 1
static const char revid[] = "$Id: db_idspace.c,v 1.5 2002/02/01 18:15:29 bostic Exp $";
@


1.1.2.1
log
@*** empty log message ***
@
text
@d11 1
a11 1
static const char revid[] = "$Id: db_idspace.c,v 1.1 2003/02/25 10:54:18 kuchin Exp $";
@

