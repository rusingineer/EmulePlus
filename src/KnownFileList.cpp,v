head	1.79;
access;
symbols
	PublicRelease_1_2e:1.79
	Interim_Release_1-2e_RC1:1.79
	PublicRelease_1_2d:1.78
	Interim_Release_1-2d_RC1:1.77
	Interim_Release_1-2d_beta1:1.77
	PublicRelease_1_2c:1.74
	Interim_Release_1-2c_RC1:1.74
	Interim_Release_1-2c_beta1:1.73
	PublicRelease_1_2b:1.73
	Interim_Release_1-2b_RC1:1.73
	PublicRelease_1_2a:1.73
	Interim_Release_1-2a_RC1:1.73
	Interim_Release_1-2a_beta2:1.70
	Interim_Release_1-2a_beta1:1.69
	PublicRelease_1_2:1.68
	Interim_Release_1-2_RC1:1.68
	Interim_Release_1-2_beta1:1.68
	PublicRelease_1_1g:1.68
	Interim_Release_1-1g_RC3:1.68
	Interim_Release_1-1g_RC2:1.68
	Interim_Release_1-1g_RC1:1.68
	Interim_Release_1-1g_beta2:1.67
	Interim_Release_1-1g_beta1:1.67
	PublicRelease_1_1f:1.67
	Interim_Release_1-1f_RC1:1.67
	PublicRelease_1_1e:1.67
	Interim_Release_1-1e_RC2:1.67
	Interim_Release_1-1e_RC1:1.67
	Interim_Release_1-1e_beta1:1.67
	PublicRelease_1_1d:1.66
	Interim_Release_1-1d_RC1:1.66
	PublicRelease_1_1c:1.66
	Interim_Release_1-1c_RC1:1.66
	Interim_Release_1-1c_beta2:1.66
	Interim_Release_1-1c_beta1:1.63
	PublicRelease_1_1b:1.63
	Interim_Release_1-1b_RC1:1.63
	PublicRelease_1_1a:1.63
	Interim_Release_1-1a_RC2:1.63
	Interim_Release_1-1a_RC1:1.63
	Interim_Release_1-1a_beta2:1.63
	Interim_Release_1-1a_beta1:1.62
	PublicRelease_1_1:1.62
	Interim_Release_1-1_beta1:1.62
	PublicRelease_1o:1.62
	Interim_Release_1o_RC1:1.62
	Interim_Release_1o_beta1:1.62
	PublicRelease_1n:1.62
	Interim_Release_1n_RC2:1.62
	Interim_Release_1n_RC1:1.62
	Interim_Release_1n_beta2:1.62
	Interim_Release_1n_beta1:1.61
	PublicRelease_1m:1.58
	Interim_Release_1m_beta1:1.58
	PublicRelease_1l:1.57
	Interim_Release_1l_RC3:1.56
	Interim_Release_1l_RC2:1.56
	Interim_Release_1l_RC1:1.56
	Interim_Release_1l_beta2:1.55
	Interim_Release_1l_beta1:1.53
	PublicRelease_1k:1.49
	Interim_Release_1k_RC4:1.49
	Interim_1k_RC3:1.49
	Interim_1k_RC2:1.48
	Interim_Release_1k_RC1:1.48
	Interim_Release_1k_beta5:1.46
	Intrerim_Release_1k_beta4:1.46
	Interim_Release_1k_beta1:1.45
	PublicRelease_1j:1.42
	Interim_Release_1J_RC3:1.42
	Interim_Release_1j_RC3:1.42
	Interim_Release_1j_RC2:1.42
	Interim_Release_1j_RC1:1.42
	Interim_Release_1j_beta2:1.42
	Interim_Release_1j_beta1:1.42
	PublicRelease_1i:1.39
	Interim_Release_1i_RC6:1.39
	Interim_Release_1i_RC3:1.39
	Interim_Release_1i_RC2:1.39
	Interim_Release_1i_RC1:1.37
	Interim_Release_1i_beta3:1.37
	Interim_Release_1i_beta2:1.36
	Interim_Release_1i_beta1:1.32
	PublicRelease_1h:1.28
	Interim_Release_1h_rc2:1.28
	Interim_Release_1h_RC1:1.28
	Interim_Release_1h_beta2:1.28
	Interim_Release_1h_beta1_now:1.28
	Interim_Release_1h_beta1:1.28
	PublicRelease_1g:1.27
	Interim_Release_1g_RC6_Final:1.27
	Interim_Release_1g_RC6:1.27
	Interim_Release_1g_RC5:1.27
	Interim_Release_1g_RC4:1.27
	Interim_Release_1g_RC3:1.27
	Interim_Release_1g_beta2:1.21
	Interim_Release_1g_beta1:1.16
	Interim_Release_1f_RC4:1.16
	Interim_Release_1f_RC3:1.16
	Interim_Release_1f_RC2:1.15
	Interim_Release_1f_RC:1.15
	Interim_Release_1f_beta2:1.15
	Interim_Release_1f_beta1:1.14
	PublicRelease_1e:1.14
	Interim_Release_1e_RC2:1.14
	Interim_Release_1e_RC:1.14
	Interim_Release_1e_beta3:1.14
	Interim_Release_1e_beta2:1.14
	Interim_Release_1e_beta2_before_kuchin:1.14
	Interim_Release_1e_beta1:1.14
	PublicRelease_1c:1.13
	featurestest:1.13.0.2
	Interim_Release_1c_RC:1.13
	Interim_Release_1c_beta2:1.13
	Interim_Release_1c_beta1:1.12
	threaded_downloadqueue:1.12.0.2
	PublicRelease_1b:1.8
	Interim_Release_1b_beta2:1.8
	Interim_Release_1b_beta1:1.8
	proxydeadlake:1.7.0.4
	PublicRelease_1a:1.7
	Interim_Release_1a_beta2:1.7
	BerkeleyDb:1.7.0.2
	Interim_Release_1a_beta1:1.7
	PublicRelease_1:1.7
	goldfish:1.7
	eMulePlus_1_RC2:1.6
	eMulePlus_26b_1RC1:1.6
	PreRelease_26b_i0e:1.6
	before_26d_merge:1.5
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.79
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.22.03.24.20;	author aw3;	state Exp;
branches;
next	1.77;

1.77
date	2008.01.23.05.10.47;	author aw3;	state Exp;
branches;
next	1.76;

1.76
date	2008.01.14.01.17.10;	author aw3;	state Exp;
branches;
next	1.75;

1.75
date	2007.12.16.21.38.00;	author aw3;	state Exp;
branches;
next	1.74;

1.74
date	2007.07.23.03.45.19;	author aw3;	state Exp;
branches;
next	1.73;

1.73
date	2006.09.03.19.35.52;	author aw3;	state Exp;
branches;
next	1.72;

1.72
date	2006.08.20.14.54.44;	author aw3;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.22.03.54.46;	author aw3;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.69;

1.69
date	2006.04.16.23.52.29;	author kush_eplus;	state Exp;
branches;
next	1.68;

1.68
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.67;

1.67
date	2005.06.05.19.52.52;	author aw3;	state Exp;
branches;
next	1.66;

1.66
date	2005.02.12.21.46.43;	author aw3;	state Exp;
branches;
next	1.65;

1.65
date	2005.02.12.00.47.00;	author aw3;	state Exp;
branches;
next	1.64;

1.64
date	2005.02.04.09.38.19;	author kuchin;	state Exp;
branches;
next	1.63;

1.63
date	2004.11.20.07.16.07;	author eklmn;	state Exp;
branches;
next	1.62;

1.62
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.61;

1.61
date	2004.07.07.05.14.39;	author aw3;	state Exp;
branches;
next	1.60;

1.60
date	2004.07.05.04.12.52;	author aw3;	state Exp;
branches;
next	1.59;

1.59
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.58;

1.58
date	2004.06.20.06.51.01;	author dongato;	state Exp;
branches;
next	1.57;

1.57
date	2004.06.10.10.22.21;	author dongato;	state Exp;
branches;
next	1.56;

1.56
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.55;

1.55
date	2004.05.21.15.50.01;	author dongato;	state Exp;
branches;
next	1.54;

1.54
date	2004.05.19.10.14.28;	author netwolf1;	state Exp;
branches;
next	1.53;

1.53
date	2004.05.04.09.45.35;	author netwolf1;	state Exp;
branches;
next	1.52;

1.52
date	2004.04.29.17.28.38;	author dongato;	state Exp;
branches;
next	1.51;

1.51
date	2004.04.19.02.10.00;	author aw3;	state Exp;
branches;
next	1.50;

1.50
date	2004.04.16.17.53.10;	author aw3;	state Exp;
branches;
next	1.49;

1.49
date	2004.04.04.08.30.11;	author eklmn;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.27.17.23.03;	author aw3;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.27.07.09.39;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2004.02.27.06.24.26;	author aw3;	state Exp;
branches;
next	1.45;

1.45
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.44;

1.44
date	2004.02.09.02.31.48;	author netwolf1;	state Exp;
branches;
next	1.43;

1.43
date	2004.02.06.17.47.01;	author netwolf1;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.09.14.37.28;	author dongato;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.07.21.07.32;	author eklmn;	state Exp;
branches;
next	1.37;

1.37
date	2003.10.29.22.01.18;	author double_t;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.24.01.21.19;	author morevit;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.09.09.25.17;	author morevit;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.08.22.17.31;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.08.15.43.05;	author eklmn;	state Exp;
branches;
next	1.32;

1.32
date	2003.09.29.13.32.11;	author dongato;	state Exp;
branches;
next	1.31;

1.31
date	2003.09.22.16.07.38;	author morevit;	state Exp;
branches;
next	1.30;

1.30
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.29;

1.29
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.17.13.15.04;	author puritynn666;	state Exp;
branches;
next	1.27;

1.27
date	2003.06.30.17.44.36;	author eklmn;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.28.08.30.17;	author partyckip;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.25.22.43.32;	author partyckip;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.17.16.35.03;	author netwolf1;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.16.15.37.42;	author netwolf1;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.15.09.09.28;	author partyckip;	state Exp;
branches;
next	1.21;

1.21
date	2003.06.08.18.06.18;	author partyckip;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.06.19.56.46;	author partyckip;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.06.00.42.42;	author syrus77;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.05.20.49.51;	author syrus77;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.20.20.46.27;	author netwolf1;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.06.21.17.14;	author partyckip;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.09.19.10.29;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.20.18.24.52;	author lord_kiron;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2003.03.14.16.24.18;	author partyckip;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.14.10.16.00;	author cax2;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.13.17.34.01;	author lord_kiron;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.10.22.46.23;	author dongato;	state Exp;
branches;
next	1.8;

1.8
date	2003.03.01.14.46.56;	author dongato;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.20.14.29.02;	author dongato;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.15.15.44.49;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.15.15.36.24;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.23.18.41.42;	author lord_kiron;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.20;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.14;	author cax2;	state Exp;
branches;
next	;

1.7.2.1
date	2003.03.01.20.59.35;	author obaldin;	state Exp;
branches;
next	;

1.13.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.79
log
@Simplified logging system implementation.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "KnownFileList.h"
#include "opcodes.h"
#ifndef NEW_SOCKETS_ENGINE
	#include "emule.h"
#else
	#include "otherfunctions.h"
#endif //NEW_SOCKETS_ENGINE
#include "SafeFile.h"
#include <share.h>
#include <io.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CKnownFileList::CKnownFileList(const CString& in_appdir)
{
	m_strFilesPath.Format(_T("%sknown.met"), in_appdir);
	m_strTrafficPath.Format(_T("%straffic.dat"), in_appdir);
	m_strPartPermissionsPath.Format(_T("%spartperm.dat"), in_appdir);
	m_iNumAccepted = 0;
	m_iNumRequested = 0;
	m_qwNumTransferred = 0;
	m_bInSave	=	false;
	Init();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CKnownFileList::~CKnownFileList()
{
	Clear();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFileList::Init()
{
	EMULE_TRY

	if (!PathFileExists(m_strFilesPath))
		Save();

	if (!Load())
		return false;
	
	LoadPartTraffic();

//	Restore the hidden/blocked settings
	LoadPartPrio();

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFileList::Load()
{
	CSafeBufferedFile	file;
	CKnownFile			*pKnownFile = NULL;

	try
	{
		//	Try to open the "Known Files" .met. If we fail...
		if (!file.Open(m_strFilesPath, CFile::modeRead | CFile::typeBinary | CFile::shareDenyWrite))
		{
			return false;
		}
		
		byte	byteFileHdr;

		setvbuf(file.m_pStream, NULL, _IOFBF, 16*1024);
		file.Read(&byteFileHdr, 1);

		if ((byteFileHdr != MET_HEADER) && (byteFileHdr != MET_HEADER_I64TAGS))
		{
			file.Close();
			return false;
		}

		CSingleLock		sLock(&m_mutexList, true); // to make sure that its thread-safe
		uint32			dwNumKnownFiles;

		file.Read(&dwNumKnownFiles, 4);				// <count:DWORD>

		for (uint32 i = 0; i < dwNumKnownFiles; i++)
		{
			try
			{
				pKnownFile = new CKnownFile();
				if (pKnownFile != NULL)
				{
					if (pKnownFile->LoadFromFile(file))
						Add(pKnownFile);
					else
						safe_delete(pKnownFile);
				}
			}
			catch (CMemoryException *pError)
			{
				OUTPUT_DEBUG_TRACE();
				AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Error by KnownFileList init %s"), GetErrorMessage(pError));
				pError->Delete();
			}
		}

		file.Close();
		sLock.Unlock();
	}
	catch (CFileException *pError)
	{
		OUTPUT_DEBUG_TRACE();
#ifndef NEW_SOCKETS_ENGINE
		if (pError->m_cause == CFileException::endOfFile)
			AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_ERR_KNOWNMET_BAD);
		else
			AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_KNOWNMET_UNKNOWN, GetErrorMessage(pError));
		g_App.m_pMDlg->DisableAutoBackup();
#endif //NEW_SOCKETS_ENGINE
		pError->Delete();

		return false;
	}
	
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFileList::Save()
{
	// to avoid situation when sources are saved every 30 min and on exit
	// eklmn: in order to save CPU load must be checked first
	if (m_bInSave)
		return;

//	We need to do it thread safe because now it's called under CUploadQueue::RemoveFromUploadQueue()
//	Also now it's called from separate thread every 30 minutes
	CSingleLock sLock(&m_mutexList, true);

	EMULE_TRY

	try
	{
		CStdioFile	file;
		CKnownFile	*pKnownFile;
		byte		abyteBuf[5];

		if (!file.Open(m_strFilesPath, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite | CFile::typeBinary))
			return;

		// file was opened successfully, set save flag
		m_bInSave = true;

		//get a list number
		uint32	dwOldRecordsNumber = GetCount();
		uint32	dwNewRecordsNumber = dwOldRecordsNumber;
		byte	byteActualFileHdr = MET_HEADER;

	//	Save a header
		abyteBuf[0] = byteActualFileHdr;
		POKE_DWORD(&abyteBuf[1], dwOldRecordsNumber);
		file.Write(abyteBuf, sizeof(abyteBuf));

		// This routine was changed to take in account possible NULL pointers
		// I think is not needed anymore because now is thread safe
		uint32 i = 0;
		while (i < dwNewRecordsNumber)
		{
			pKnownFile = ElementAt(i);
			if (pKnownFile == NULL) // if NULL, remove it!
			{
				dwNewRecordsNumber--;
				RemoveAt(i);
			}
			else // element is not NULL, write it and go for next one
			{
				pKnownFile->WriteToFile(file);
				if (pKnownFile->IsLargeFile())
					byteActualFileHdr = MET_HEADER_I64TAGS;
				i++;
			}
		}

	//	Update file header and number of records
		abyteBuf[0] = byteActualFileHdr;
		POKE_DWORD(&abyteBuf[1], dwNewRecordsNumber);
		file.SeekToBegin();
		file.Write(abyteBuf, sizeof(abyteBuf));

		//eklmn: by shutdown force OS flush data direct to disk [SlugFiller]
#ifndef NEW_SOCKETS_ENGINE
		if ( !g_App.m_pMDlg->IsRunning() )
			_commit(_fileno(file.m_pStream));
#endif //NEW_SOCKETS_ENGINE

		file.Close();

		//--- xrmb:parttraffic ---
		SavePartTraffic();

		//--- xrmb:partprio ---
		SavePartPrio();
	}
	catch (CFileException *error)
	{
		OUTPUT_DEBUG_TRACE();
		AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to save %s - %s"), m_strFilesPath, GetErrorMessage(error));
		error->Delete();
	}
	EMULE_CATCH

	sLock.Unlock();
	m_bInSave	=	false;
}
 ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFileList::Clear()
{
	EMULE_TRY

	for (int i = 0; i < GetCount();i++)
		safe_delete(ElementAt(i));
	RemoveAll();
	SetSize(0);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CKnownFile* CKnownFileList::FindKnownFile(const CString &strFileName, uint32 dwDate, uint64 qwSize)
{
	EMULE_TRY

	for (int i = 0; i < GetCount(); i++)
	{
		CKnownFile* pKnownFile = ElementAt(i);
	
		if ( (pKnownFile != NULL) && (pKnownFile->GetFileDate() == dwDate) &&
			(pKnownFile->GetFileSize() == qwSize) && (strFileName == pKnownFile->GetFileName()) )
		{
			return pKnownFile;
		}
	}

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//SyruS show completed files (0.28b)
CKnownFile* CKnownFileList::FindKnownFileByID(const uchar* hash)
{
	EMULE_TRY

	for (int i=0; i < GetCount(); i++)
	{
		CKnownFile* pCurKnownFile = ElementAt(i);
		if (!md4cmp(pCurKnownFile->GetFileHash(), hash))
			return pCurKnownFile;
	}
	return NULL;

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CKnownFileList::SafeAddKnownFile(CKnownFile* pKnownFileToAdd)
{
	if (!pKnownFileToAdd)
		return;

	CSingleLock sLock(&m_mutexList,true);
	Add(pKnownFileToAdd);
	sLock.Unlock();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFileList::merge()
{
	EMULE_TRY

	CSingleLock sLock(&m_mutexList,true);

	int totalcnt=0;
	int items=GetCount();

//	Go through all the items
	for(int i=0; i<items; i++)
	{
		int cnt=0;

	//	Compare with all other items
		for (int j = (i + 1); j < items; j++)
		{
		//	Same size and file hash...
			if(	(ElementAt(i)->GetFileSize() == ElementAt(j)->GetFileSize()) &&
				(md4cmp(ElementAt(i)->GetFileHash(), ElementAt(j)->GetFileHash()) == 0) )
			{
#ifndef NEW_SOCKETS_ENGINE
				AddLogLine(0, IDS_MERGE, ElementAt(i)->GetFileName(), ElementAt(j)->GetFileName());
#endif

			//	If one file is shared the other should be known
				if (ElementAt(j)->GetSharedFile())
				{
					if (ElementAt(i)->GetSharedFile())
					{
					//	Duplicate shared files are found, throw a warning and continue merging
#ifndef NEW_SOCKETS_ENGINE
						AddLogLine(LOG_RGB_WARNING, IDS_MERGE_WARNING);
#endif
						continue;
					}

					CKnownFile *t=ElementAt(i);
					SetAt(i, ElementAt(j));
					SetAt(j, t);
				}

			//	Merge into first item
				if(ElementAt(i)->statistic.merge(&ElementAt(j)->statistic) == false)
				{
					sLock.Unlock();
#ifndef NEW_SOCKETS_ENGINE
					AddLogLine(LOG_RGB_ERROR, IDS_MERGE_FAILED);
#endif //NEW_SOCKETS_ENGINE
					return false;
				}

			//	Get original file Priority and set it to the merged file
				ElementAt(i)->SetULPriority(ElementAt(j)->GetULPriority());

			//	Remove second item
				CKnownFile	*d=ElementAt(j);
				RemoveAt(j);
			//	Try to clear file from download list if it's where as complete file not to crash
			//	during download list update, because file object will be destroyed now.
				g_App.m_pDownloadList->ClearCompleted(d->GetFileHash());
				safe_delete(d);
				items--;
				j--;

				cnt++;
				totalcnt++;
			}
		}

		if(cnt > 1)
		{
#ifndef NEW_SOCKETS_ENGINE
			AddLogLine(0, IDS_MERGE_CNT, i, cnt);
#endif
		}
	}

	sLock.Unlock();
#ifndef NEW_SOCKETS_ENGINE
	AddLogLine(0, IDS_MERGE_TOTAL, totalcnt);
#endif

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFileList::RemoveFile(CKnownFile* toRemove)
{
	EMULE_TRY

	CSingleLock sLock(&m_mutexList, true);

	//--- go thru all items ---
	for(int i=0; i<GetCount(); i++)
	{
		if(ElementAt(i)==toRemove)
		{
			RemoveAt(i);
			delete toRemove;
		
			sLock.Unlock();
			return true;
		}
	}

	sLock.Unlock();

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--- xrmb:partprio ---
bool CKnownFileList::LoadPartPrio()
{
//	Save the part permission
	FILE	*file = _tfsopen(m_strPartPermissionsPath, _T("rb"), _SH_DENYWR);
	if(file == NULL)
		return false;

	byte version = 1;
	fread(&version, sizeof(version), 1, file);

	uint32	RecordsNumber=0;
	fread(&RecordsNumber, sizeof(RecordsNumber), 1, file);

	CKnownFile	*kf;
	uchar		hash[16];
	uint64		qwFileSz = 0;
	uint32		fpos, dwFileSzLen = (version == 1) ? 4 : 8;
	for (uint32 i = 0; i < RecordsNumber; i++) 
	{
		fread(hash, 16, 1, file);	// read hash
		fread(&qwFileSz, dwFileSzLen, 1, file);	//read file size

		fpos = ftell(file);	// save file pos

	//	Search for a file in the list
		for (int j = 0; j < GetCount(); j++)
		{
			kf = ElementAt(j);
		//	Right file?
			if ((kf->GetFileSize() == qwFileSz) && (md4cmp(kf->GetFileHash(), hash) == 0))
			{
				fseek(file, fpos, SEEK_SET);
				fread(kf->GetPartStatusArr(), kf->GetPartCount() * sizeof(byte), 1, file);
			}
		}
	}
	fclose(file);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SavePartPrio() is called under m_mutexList protection
bool CKnownFileList::SavePartPrio()
{
	//--- save the part-permission ---
	FILE	*file = _tfsopen(m_strPartPermissionsPath, _T("wb"), _SH_DENYWR);
	if(file == NULL)
		return false;

//	ver.1 -- 32bit file size
//	ver.2 (starting from v1.2a) -- 64bit file size
	byte version = 2;
	fwrite(&version, sizeof(version), 1, file);

	//--- preserve the space for the recordnumers ---
	CKnownFile	*kf;
	uint32	RecordsNumber=0;
	uint32	rnpos=ftell(file);
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);
	for (int i = 0; i < GetCount(); i++)
	{
		kf = ElementAt(i);
	//	Save files only with hidden parts
		if(kf->HasHiddenParts())
		{
			fwrite(kf->GetFileHash(), 16, 1, file);	// write hash

			uint64 fs = kf->GetFileSize();
			fwrite(&fs, sizeof(fs), 1, file);	// write file size
		//	Save prio
			fwrite(kf->GetPartStatusArr(), kf->GetPartCount() * sizeof(byte), 1, file);

			RecordsNumber++;
		}
	}

	//--- save the number of stored records ---
	fseek(file, rnpos, SEEK_SET);
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);

	fclose(file);

	return true;
}
//--- :xrmb/partprio ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--- xrmb:parttraffic ---
bool CKnownFileList::LoadPartTraffic()
{
//	Load collected traffic data
	FILE	*fh = _tfsopen(m_strTrafficPath, _T("rb"), _SH_DENYWR);

	if (fh == NULL)
		return false;

	setvbuf(fh, NULL, _IOFBF, 64*1024);

	CSingleLock		sLock(&m_mutexList,true); // to make sure that its thread-safe

	byte	version=0;
	fread(&version, sizeof(version), 1, fh);

	uint32	records;
	fread(&records, sizeof(records), 1, fh);

	uchar	abyteFileHash[16];
	uint64	qwFileSz = 0;
	uint32	dwFileSzLen = (version < 3) ? 4 : 8;

	for (uint32 i = 0; i < records; i++) 
	{
		byte hasData=0;
		fread(&hasData, sizeof(hasData), 1, fh);

		if(hasData)
		{
			fread(abyteFileHash, 16, 1, fh);
			fread(&qwFileSz, dwFileSzLen, 1, fh);
			if ( (qwFileSz == ElementAt(i)->GetFileSize()) &&
				(md4cmp(abyteFileHash, ElementAt(i)->GetFileHash()) == 0) )
			{
				if (!ElementAt(i)->LoadFromFileTraffic(fh, version))
				{
#ifndef NEW_SOCKETS_ENGINE
					AddLogLine(LOG_FL_SBAR | LOG_RGB_ERROR, IDS_TRAFFICDAT_CORRUPT, _T("traffic.dat"));
					g_App.m_pMDlg->DisableAutoBackup();
#endif
					break;
				}
			}
			else
			{
#ifndef NEW_SOCKETS_ENGINE
				AddLogLine(LOG_RGB_WARNING, IDS_TRAFFIC_KNOWN_ASYNC, i);
				g_App.m_pMDlg->DisableAutoBackup();
#endif
				break;
			}
		}
	}
	fclose(fh);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CKnownFileList::SavePartTraffic()
{
	//--- save traffic data to our file ---
	FILE	*file = _tfsopen(m_strTrafficPath, _T("wb"), _SH_DENYWR);

	if (file == NULL)
		return false;

	setvbuf(file, NULL, _IOFBF, 64*1024);

//	ver.1 -- initial version
//	ver.2 -- introduced part-accepted counter statistics
//	ver.3 (starting from v1.2a) -- 64bit file size
	byte	version = 3;
	fwrite(&version, sizeof(version), 1, file);	

	uint32	RecordsNumber=GetCount();
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);
	for(uint32 i=0; i<RecordsNumber; i++) 
	{
		// only save for known-files with traffic
		if(ElementAt(i)->statistic.partTraffic)
		{
			byte hasData=1;
			fwrite(&hasData, sizeof(hasData), 1, file);

			//--- write hash ---
			fwrite(ElementAt(i)->GetFileHash(), 16, 1, file);

			//--- write filesize ---
			uint64 fs = ElementAt(i)->GetFileSize();
			fwrite(&fs, sizeof(fs), 1, file);
			
			//--- write part/block traffic ---
			ElementAt(i)->SaveToFileTraffic(file);
		}
		else
		{
			byte hasData=0;
			fwrite(&hasData, sizeof(hasData), 1, file);
		}
	}

	fclose(file);

	return true;
}
//--- :xrmb/parttraffic ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.78
log
@Corrected reporting of corrupted part traffic data files (no multiple reports for traffic.dat corruption; report actual corrupted file name for .part.stats corruptions) {Vladimir (SV)}.
@
text
@d119 1
a119 1
				AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Error by KnownFileList init %s"), GetErrorMessage(pError));
d132 1
a132 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_KNOWNMET_BAD));
d134 1
a134 1
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_KNOWNMET_UNKNOWN), GetErrorMessage(pError));
d223 1
a223 1
		AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to save %s - %s"), m_strFilesPath, GetErrorMessage(error));
d314 2
a315 2
				AddLogLine(false, IDS_MERGE, ElementAt(i)->GetFileName(), ElementAt(j)->GetFileName());
#endif //NEW_SOCKETS_ENGINE
d324 2
a325 2
						AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_MERGE_WARNING));
#endif //NEW_SOCKETS_ENGINE
d339 1
a339 1
					AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_MERGE_FAILED));
d365 2
a366 2
			AddLogLine(false, IDS_MERGE_CNT, i, cnt);
#endif //NEW_SOCKETS_ENGINE
d372 2
a373 2
	AddLogLine(false, IDS_MERGE_TOTAL, totalcnt);
#endif //NEW_SOCKETS_ENGINE
d533 1
a533 4
					CString	strTmp(RGB_LOG_ERROR);

					strTmp.AppendFormat(GetResString(IDS_TRAFFICDAT_CORRUPT), _T("traffic.dat"));
					AddLogLine(true, strTmp);
d542 1
a542 1
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_TRAFFIC_KNOWN_ASYNC), i);
d544 1
a544 1
#endif //NEW_SOCKETS_ENGINE
@


1.77
log
@Proper share mode for open files (before other applications could write to a file while we were reading).
@
text
@d530 11
a540 1
				ElementAt(i)->LoadFromFileTraffic(fh, version);
@


1.76
log
@Fixed crash caused by shared files list merging after file completion and outside renaming (renaming outside with reloading following by merge when complete file is still in the download list) {DonGato}.
@
text
@d27 1
d412 1
a412 1
	FILE	*file = _tfopen(m_strPartPermissionsPath, _T("rb"));
d454 1
a454 1
	FILE	*file = _tfopen(m_strPartPermissionsPath, _T("wb"));
d499 3
a501 2
	FILE	*fh=_tfopen(m_strTrafficPath, _T("rb"));
	if(!fh)
d550 1
d552 1
a552 2
	FILE	*file=_tfopen(m_strTrafficPath, _T("wb"));
	if(file==NULL)
@


1.75
log
@Suppressed level 4 warnings; Formatting.
@
text
@d349 3
@


1.74
log
@Reduced #include dependency.
@
text
@d43 1
a43 1
	m_iNumTransferred = 0;
@


1.73
log
@Changed format of traffic.dat to support large file sizes (no backward compatibility).
@
text
@a24 1
	#include "SafeFile.h"
d26 1
@


1.72
log
@Large file support to load/save known.met.
@
text
@d405 1
a405 1
bool	CKnownFileList::LoadPartPrio()
d447 1
a447 1
bool	CKnownFileList::SavePartPrio()
d509 5
a513 3
	uchar tmp_filehash[16];
	uint32 fs=0;
	for(uint32 i=0; i < records; i++) 
d520 5
a524 3
			fread(tmp_filehash, 16, 1, fh);
			fread(&fs, sizeof(fs), 1, fh);
			if(fs==ElementAt(i)->GetFileSize() && md4cmp(tmp_filehash, ElementAt(i)->GetFileHash())==0)
d526 1
a532 1

d552 4
a555 1
	byte	version=2;
d572 1
a572 1
			uint32 fs=ElementAt(i)->GetFileSize();
@


1.71
log
@Changed format of partperm.dat, smooth upgrade provided,
hidden part setting loss on downgrade if there're files with hidden parts;
Faster load/save information about hidden parts; Formatting.
@
text
@d86 1
a86 1
		byte	uFileHeader;
d89 1
a89 1
		file.Read(&uFileHeader,1);
d91 1
a91 1
		if (uFileHeader != MET_HEADER)
d97 2
a98 2
		CSingleLock		sLock(&m_mutexList,true); // to make sure that its thread-safe
		uint32			iNumKnownFiles;
d100 1
a100 1
		file.Read(&iNumKnownFiles,4);				// <count:DWORD>
d102 1
a102 1
		for (uint32 i = 0; i < iNumKnownFiles; i++)
a143 1
// Tarod - Now thread-safe
d146 1
a146 1
	// to avoid situation when sources saved both  each 30 min and on exit
d170 3
a172 2
		uint32 dwOldRecordsNumber = GetCount();
		uint32 dwNewRecordsNumber = dwOldRecordsNumber;
d175 1
a175 1
		abyteBuf[0] = MET_HEADER;
d185 1
a185 1
			if (pKnownFile == NULL) // if is NULL is unuseful so we remove it!
d193 2
d199 5
a203 6
		// Maybe we have less records than before, rewrite number of records
		if (dwNewRecordsNumber != dwOldRecordsNumber)
		{
			file.Seek(1, CFile::begin);
			file.Write(&dwNewRecordsNumber, 4);
		}
@


1.70
log
@Large file size support preparations.
@
text
@d106 1
a106 1
				pKnownFile =  new CKnownFile();
d406 3
a408 3
	//--- save the part-permission ---
	FILE	*file=_tfopen(m_strPartPermissionsPath, _T("rb"));
	if(file==NULL)
d411 2
a412 2
	byte version=1;
	fread(&version, sizeof(version), 1, file);	
d420 1
a420 1
	uint32		fpos;
d423 2
a424 2
		//--- read hash ---
		fread(hash, 16, 1, file);
d426 1
a426 2
		//--- read filesize ---
		fread(&qwFileSz, sizeof(uint32), 1, file);
d428 1
a428 4
		//--- save pos ---
		fpos = ftell(file);
		
		//--- find all these files ---
d432 1
a432 2

			//--- right file? ---
d436 1
a436 7

				for(uint16 part=0; part<kf->GetPartCount(); part++)
				{
					byte state = 0;
					fread(&state, sizeof(state), 1, file);
					kf->SetPartStatus(part, state);
				}
d449 2
a450 2
	FILE	*file=_tfopen(m_strPartPermissionsPath, _T("wb"));
	if(file==NULL)
d453 3
a455 1
	byte version=1;
d463 1
a463 1
	for(int i=0; i<GetCount(); i++) 
d465 2
a466 3
		kf=ElementAt(i);

		// only save for known-files with traffic
d469 1
a469 2
			//--- write hash ---
			fwrite(kf->GetFileHash(), 16, 1, file);
d471 4
a474 10
			//--- write filesize ---
			uint32 fs=kf->GetFileSize();
			fwrite(&fs, sizeof(fs), 1, file);
			
			//--- save prio ---
			for(uint16 part=0; part<kf->GetPartCount(); part++)
			{
				byte	state=kf->GetPartStatus(part);
				fwrite(&state, sizeof(state), 1, file);
			}
@


1.69
log
@Improved string processing.
@
text
@a213 1
		//--- :xrmb ---
a216 1
		//--- :xrmb ---
d242 1
a242 1
CKnownFile* CKnownFileList::FindKnownFile(const CString& filename,uint32 in_date,uint32 in_size)
d246 1
a246 1
	for (int i = 0;i < GetCount();i++)
d250 2
a251 1
		if (pKnownFile && pKnownFile->GetFileDate() == in_date && pKnownFile->GetFileSize() == in_size && (filename == pKnownFile->GetFileName()))
a256 2
	return NULL;

d419 1
a419 1
	uint32		filesize;
d421 1
a421 1
	for(uint32 i=0; i<RecordsNumber; i++) 
d427 1
a427 1
		fread(&filesize, sizeof(filesize), 1, file);
d430 1
a430 1
		fpos=ftell(file);
d433 1
a433 1
		for(int j=0; j<GetCount(); j++)
d435 1
a435 1
			kf=ElementAt(j);
d438 1
a438 1
			if(kf->GetFileSize()==filesize && md4cmp(kf->GetFileHash(), hash)==0)
@


1.68
log
@renamed 3 variables
@
text
@d107 1
a107 1
				if (pKnownFile)
d109 1
a109 2
					if (pKnownFile->LoadFromFile(file))	// (known file)[count]
					{
a110 1
					}
a111 1
					{
a112 1
					}
d115 1
a115 1
			catch (CMemoryException* error)
d118 2
a119 2
				AddDebugLogLine(RGB_LOG_ERROR + _T("Error by KnownFileList init %s"), GetErrorMessage(error));
				error->Delete();
d126 1
a126 1
	catch (CFileException* error)
d130 1
a130 1
		if (error->m_cause == CFileException::endOfFile)
d133 1
a133 3
		{
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_KNOWNMET_UNKNOWN), GetErrorMessage(error));
		}
d136 1
a136 1
		error->Delete();
@


1.67
log
@Removed unused code.
@
text
@d140 1
a140 1
		g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d212 1
a212 1
		if ( !g_eMuleApp.m_pdlgEmule->IsRunning() )
d551 1
a551 1
				g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
@


1.66
log
@Faster loading and saving of configuration files.
@
text
@a608 8
bool CKnownFileList::IsKnownFile(void* pToTest){
	for (int i = 0; i < GetCount(); i++){
		if (ElementAt(i) == pToTest)
			return true;
	}
	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.65
log
@Changed writing method to known.met.
@
text
@d18 2
a19 2
#include "StdAfx.h"
#include "knownfilelist.h"
d37 2
a38 2
{	
	m_strFilesPath.Format(_T("%sknown.met"), in_appdir);	
a44 3
	//--- xrmb:statsautosave ---
	//lastsaved=GetTickCount();
	//--- :xrmb ---
d75 2
a76 2
	CSafeFile file;
	CKnownFile	*pKnownFile = NULL; 
d81 1
a81 1
		if (!file.Open(m_strFilesPath,CFile::modeRead|CFile::osSequentialScan|CFile::shareDenyWrite))
d88 1
d90 1
a90 1
			
d96 1
a96 1
			
d101 1
a101 1
			
d215 1
a215 1
		
d517 1
a517 1
bool	CKnownFileList::LoadPartTraffic()
d519 1
a519 1
	//--- load collected traffic data in our file ---
d524 2
d536 1
a536 1
	for(uint32 i=0; i<records; i++) 
d563 1
a563 1
bool	CKnownFileList::SavePartTraffic()
d571 2
@


1.64
log
@More ifdefs for v2
@
text
@a159 2
	EMULE_TRY

d164 1
a164 5
	FILE* file = NULL; 	
	if (!(file = _tfopen(m_strFilesPath, _T("wb"))))
	{		
		return;
	}	
d166 1
a166 17
	// file was opened successfully, set save flag
	m_bInSave = true;

	CKnownFile*	pKnownFile = NULL;

	//get a list number
	uint32 dwOldRecordsNumber = GetCount();
	uint32 dwNewRecordsNumber = dwOldRecordsNumber;

  	//save a header
	fputc(MET_HEADER,file);
	fwrite(&dwOldRecordsNumber,4,1,file); 
  
	// This routine was changed to take in account possible NULL pointers
	// I think is not needed anymore because now is thread safe
	uint32 i = 0;
	while (i < dwNewRecordsNumber)
d168 23
a190 7
		pKnownFile = ElementAt(i);
		if (pKnownFile == NULL) // if is NULL is unuseful so we remove it!
		{
			dwNewRecordsNumber--;
			RemoveAt(i);
		} 
		else // element is not NULL, write it an go for next one
d192 2
a193 2
			// check the result of write process
			if (pKnownFile->WriteToFile(file))
d195 2
a196 1
				i++;
d198 1
a198 1
			else		// if we were unable to write just decrease a number of written files
d200 2
a201 1
				dwNewRecordsNumber--;
a202 2
			pKnownFile = NULL;
			
a203 1
	} 
d205 8
a212 8
	// Maybe we have less records than before, rewrite number of records
	if (dwNewRecordsNumber != dwOldRecordsNumber)
	{
		fseek(file, 1L, SEEK_SET);
		fwrite(&dwNewRecordsNumber, 4, 1, file);
	}
  
	//eklmn: by shutdown force OS flush data direct to disk [SlugFiller]
d214 2
a215 2
	if ( !g_eMuleApp.m_pdlgEmule->IsRunning() ) 
		_commit(_fileno(file));
d217 2
a218 2
	
	fclose(file); 
d220 15
a234 7
	//--- xrmb:parttraffic ---
	SavePartTraffic();
	//--- :xrmb ---

	//--- xrmb:partprio ---
	SavePartPrio();
	//--- :xrmb ---
a237 6

	EMULE_CATCH

//	MOREVIT - ? Seeing as how our code isn't written with exceptions
//		in mind, this exception should be prevented, not kludged around.
	m_bInSave	=	false;	//in case of exception for one file, we also need to free SAVE PROCESS
@


1.63
log
@changes in part control; hidden & blocked statuses are merged
@
text
@d21 6
a26 1
#include "emule.h"
d135 1
d142 2
a144 1
		g_eMuleApp.m_pdlgEmule->DisableAutoBackup();
d220 1
d223 1
d327 1
d329 1
d337 1
d339 1
d352 1
d354 1
d375 1
d377 1
d382 1
d384 1
d554 1
d557 1
@


1.62
log
@SSWQ
@
text
@d441 1
a441 1
					byte	state=PR_PART_ON;
@


1.61
log
@More file sharing corrections to allow read-only access for other applications (official).
@
text
@d344 1
a344 1
				ElementAt(i)->SetPriority(ElementAt(j)->GetPriority());
@


1.60
log
@Resource string IDS_MERGE_SWAP removal.
@
text
@d79 1
a79 1
		if (!file.Open(m_strFilesPath,CFile::modeRead|CFile::osSequentialScan))
@


1.59
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a328 1
				//	AddLogLine(false, IDS_MERGE_SWAP);
@


1.58
log
@Minor changes...
@
text
@d119 1
a119 1
				AddDebugLogLine(false, RGB_LOG_ERROR + _T("Error by KnownFileList init %s"), GetErrorMessage(error));
@


1.57
log
@Minor changes
@
text
@d329 1
a329 1
					AddLogLine(false, IDS_MERGE_SWAP);
d340 1
a340 1
					AddLogLine(false, IDS_MERGE_FAILED);
d359 1
a359 1
		if(cnt)
@


1.56
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d226 2
a227 2
	sLock.Unlock(); // free mutex
	m_bInSave	=	false;		//Cax2 - bugfix for all those problems!!! :P
d262 2
d280 1
@


1.55
log
@More DebugLog formating and changes
@
text
@d119 1
a119 1
				AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Error by KnownFileList init %s"), __FUNCTION__, GetErrorMessage(error));
@


1.54
log
@minor changes, fixes and improvements
@
text
@d119 1
a119 1
				AddDebugLogLine(false, RGB_LOG_ERROR + _T("-eklmn-> Error by KnownFileList init %s"), GetErrorMessage(error));
@


1.53
log
@Disable scheduled backup and backup on exit if a file corruption is detected on start + minor changes
@
text
@a60 1
	//--- xrmb:parttraffic ---
a61 1
	//--- :xrmb ---
d63 1
a63 2
	//--- xrmb:partprio ---
	//--- restore the hidden/blocked settings ---
a64 1
	//--- :xrmb ---
@


1.52
log
@When a file is merged the file priority from the old file is used
@
text
@d135 1
a135 1
			AddLogLine(true, RGB_LOG_ERROR + GetResString(IDS_ERR_SERVERMET_BAD));
d138 1
a138 1
			AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_SERVERMET_UNKNOWN), GetErrorMessage(error));
d140 3
a142 1
		error->Delete();	//memleak fix
d538 2
@


1.51
log
@Slightly corrected known file merging in case of similar shared files.
@
text
@d305 1
a305 1
	//--- go thru all items ---
d310 1
a310 1
		//--- compare with all other items ---
d324 1
a324 1
				//	Duplicate shared files are found, throw a warning and continue merging
d335 2
a336 2
				//--- merge into first item ---
				if(ElementAt(i)->statistic.merge(&ElementAt(j)->statistic)==false)
d343 4
a346 1
				//--- remove second item ---
@


1.50
log
@Resource lock time reduced.
@
text
@d311 1
a311 1
		for(int j=i+1; j<items; j++)
d313 3
a315 3
			//--- same id? and same size... maybe we should compare the hashsets too? ---
			if(	ElementAt(i)->GetFileSize()==ElementAt(j)->GetFileSize() &&
				md4cmp(ElementAt(i)->GetFileHash(), ElementAt(j)->GetFileHash()) == 0 )
d319 2
a320 10
				//--- one file can be shared ---
				if(ElementAt(i)->GetSharedFile() && ElementAt(j)->GetSharedFile())
				{
					sLock.Unlock();
					AddLogLine(false, IDS_MERGE_ABORT);
					return false;
				}

				//--- if second file is shared, swap them ---
				if(ElementAt(j)->GetSharedFile())
d322 6
@


1.49
log
@corrected crash by "merge" over roll back :) added couple SetRedraw
@
text
@d315 1
a315 2
				md4cmp(ElementAt(i)->GetFileHash(), ElementAt(j)->GetFileHash())==0
				)
d322 1
a323 1
					sLock.Unlock();
d340 1
a341 1
					sLock.Unlock();
d359 1
a359 1
			AddLogLine(false,IDS_MERGE_CNT , i, cnt);
d363 1
a365 1
	sLock.Unlock();
@


1.48
log
@Comment correction.
@
text
@a303 2
	CKnownFile* pKnownFileIdx1;
	CKnownFile* pKnownFileIdx2;
a308 1
		pKnownFileIdx1 = ElementAt(i);
d310 2
a311 1
		if (pKnownFileIdx1)
d313 4
a316 2
			//--- compare with all other items ---
			for(int j=i+1; j<items; j++)
d318 1
a318 1
				pKnownFileIdx2 = ElementAt(j);
d320 2
a321 1
				if (pKnownFileIdx2)
d323 3
a325 41
					//--- same id? and same size... maybe we should compare the hashsets too? ---
					if(pKnownFileIdx1->GetFileSize() == pKnownFileIdx2->GetFileSize() &&
						md4cmp(pKnownFileIdx1->GetFileHash(), pKnownFileIdx2->GetFileHash())==0
						)
					{
						AddLogLine(false, IDS_MERGE, pKnownFileIdx1->GetFileName(), pKnownFileIdx2->GetFileName());

						//--- one file can be shared ---
						if(pKnownFileIdx1->GetSharedFile() && pKnownFileIdx2->GetSharedFile())
						{
							AddLogLine(false, IDS_MERGE_ABORT);
							sLock.Unlock();
							return false;
						}

						//--- if second file is shared, swap them ---
						if(pKnownFileIdx2->GetSharedFile())
						{
							AddLogLine(false, IDS_MERGE_SWAP);

							SetAt(i, pKnownFileIdx2);
							SetAt(j, pKnownFileIdx1);
						}

						//--- merge into first item ---
						if(pKnownFileIdx1->statistic.merge(&pKnownFileIdx2->statistic)==false)
						{
							AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_MERGE_FAILED));
							sLock.Unlock();
							return false;
						}

						//--- remove second item ---
						RemoveAt(j);
						delete pKnownFileIdx2;
						items--;
						j--;

						cnt++;
						totalcnt++;
					}
d327 28
a354 1
				pKnownFileIdx2 = NULL;
d356 1
d358 3
a360 4
			if(cnt)
			{
				AddLogLine(false, IDS_MERGE_CNT , i, cnt);
			}
a361 1
		pKnownFileIdx1 = NULL;
@


1.47
log
@minor correction & improvements of "known.met" save process
@
text
@d198 1
a198 1
			else		// if we were unable to wite just dercease a number of writen files
@


1.46
log
@Nested mutex protection is removed
@
text
@d193 9
a201 1
			pKnownFile->WriteToFile(file);
d203 1
a203 1
			i++;
d256 6
a261 2
		if (ElementAt(i)->GetFileDate() == in_date && ElementAt(i)->GetFileSize() == in_size && (filename == ElementAt(i)->GetFileName()))
			return ElementAt(i);
d266 1
a266 1
	return 0;
d274 2
a275 1
	for (int i=0; i<GetCount(); i++){
d283 1
a283 1
	return 0;
d304 2
d311 1
d313 1
a313 2
		//--- compare with all other items ---
		for(int j=i+1; j<items; j++)
d315 2
a316 4
			//--- same id? and same size... maybe we should compare the hashsets too? ---
			if(	ElementAt(i)->GetFileSize()==ElementAt(j)->GetFileSize() &&
				md4cmp(ElementAt(i)->GetFileHash(), ElementAt(j)->GetFileHash())==0
				)
d318 1
a318 1
				AddLogLine(false, IDS_MERGE, ElementAt(i)->GetFileName(), ElementAt(j)->GetFileName());
d320 1
a320 2
				//--- one file can be shared ---
				if(ElementAt(i)->GetSharedFile() && ElementAt(j)->GetSharedFile())
d322 41
a362 3
					AddLogLine(false, IDS_MERGE_ABORT);
					sLock.Unlock();
					return false;
d364 2
d367 3
a369 27
				//--- if second file is shared, swap them ---
				if(ElementAt(j)->GetSharedFile())
				{
					AddLogLine(false, IDS_MERGE_SWAP);

					CKnownFile *t=ElementAt(i);
					SetAt(i, ElementAt(j));
					SetAt(j, t);
				}

				//--- merge into first item ---
				if(ElementAt(i)->statistic.merge(&ElementAt(j)->statistic)==false)
				{
					AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_MERGE_FAILED));
					sLock.Unlock();
					return false;
				}

				//--- remove second item ---
				CKnownFile	*d=ElementAt(j);
				RemoveAt(j);
				delete d;
				items--;
				j--;

				cnt++;
				totalcnt++;
d372 1
a372 5

		if(cnt)
		{
			AddLogLine(false, IDS_MERGE_CNT , i, cnt);
		}
@


1.45
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d157 2
a158 2
	// We need to do it thread safe because now is called under CUploadQueue::RemoveFromUploadQueue()
	// Also no called from separate thread each 30 min
d440 1
a450 2
	CSingleLock		sLock(&m_mutexList,true); // to make sure that its thread-safe

@


1.44
log
@BUGFIX: proper display of auto priorized Jumpstart files + FEATURE: display known unshared files in different color (in Search window)
@
text
@d88 1
a88 1
		uint8	uFileHeader;
d395 1
a395 1
	uint8 version=1;
d428 1
a428 1
					uint8	state=PR_PART_ON;
d447 1
a447 1
	uint8 version=1;
d474 1
a474 1
				uint8	state=kf->GetPartStatus(part);
d502 1
a502 1
	uint8	version=0;
d512 1
a512 1
		uint8 hasData=0;
d541 1
a541 1
	uint8	version=2;
d551 1
a551 1
			uint8 hasData=1;
d566 1
a566 1
			uint8 hasData=0;
@


1.43
log
@show remaining files to be hashed counter in shared files window + appropriate string change if Known files are shown + minor cleanup
@
text
@d258 1
a258 1
CKnownFile* CKnownFileList::FindKnownFileByID(uchar* hash)
@


1.42
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@a282 13
//--- xrmb:statsautosave ---
//Cax2 - totally unnecessary now that save is  called from a thread every 30 minutes!!!!
void CKnownFileList::Process()
{
	EMULE_TRY

		Save();

	EMULE_CATCH
}
//--- :xrmb ---
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--- xrmb:allyaknow ---
@


1.41
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d123 1
a123 1
				AddDebugLogLine(false, RGB_RED + _T("-eklmn-> Error by KnownFileList init %s"), GetErrorMessage(error));
d135 1
a135 1
			AddLogLine(true, RGB_RED + GetResString(IDS_ERR_SERVERMET_BAD));
d138 1
a138 1
			AddLogLine(true, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_SERVERMET_UNKNOWN), GetErrorMessage(error));
d341 1
a341 1
					AddLogLine(false, RGB_RED + GetResString(IDS_MERGE_FAILED));
d536 1
a536 1
				AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_TRAFFIC_KNOWN_ASYNC), i);
@


1.40
log
@Added some colors to the logs...
@
text
@d123 1
a123 1
				AddDebugLogLine(false, "<COLOR=255,0,0>-eklmn-> Error by KnownFileList init %s", GetErrorMessage(error));
d135 1
a135 1
			AddLogLine(true, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_SERVERMET_BAD));
d138 1
a138 1
			AddLogLine(true, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_SERVERMET_UNKNOWN), GetErrorMessage(error));
d341 1
a341 1
					AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_MERGE_FAILED));
d360 1
a360 1
			AddLogLine(false,IDS_MERGE_CNT , i, cnt);
d536 1
a536 1
				AddLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_TRAFFIC_KNOWN_ASYNC), i);
@


1.39
log
@Fixes
- saving of newly hashed files :P
- tab order on comments
@
text
@d123 1
a123 1
				AddDebugLogLine(false, "-eklmn-> Error by KnownFileList init %s", GetErrorMessage(error));
d135 1
a135 1
			AddLogLine(true, IDS_ERR_SERVERMET_BAD);
d138 1
a138 1
			AddLogLine(true, IDS_ERR_SERVERMET_UNKNOWN, GetErrorMessage(error));
d341 1
a341 1
					AddLogLine(false, IDS_MERGE_FAILED);
d536 1
a536 1
				AddLogLine(false, IDS_TRAFFIC_KNOWN_ASYNC, i);
@


1.38
log
@some steps to improve stability by loading of "known.met"
@
text
@d275 1
a275 1
	if (pKnownFileToAdd)
d277 1
a277 1
	
@


1.37
log
@minor PartPrio bugfix
@
text
@d55 24
a78 2
	CKnownFile		*pKnownFile = NULL; 
	CSafeFile		file;
d82 1
a82 4
		if (!PathFileExists(m_strFilesPath))
			Save();
	
	//	Try to open the "Known Files" .met. If we fail...
d86 3
a88 2
		}		
		uint8		header;
d90 3
a92 2
		file.Read(&header,1);
		if (header != MET_HEADER)
d97 1
d102 1
d105 1
a105 2
			pKnownFile =  new CKnownFile();
			if (pKnownFile)
d107 2
a108 1
				if (pKnownFile->LoadFromFile(file))	// (known file)[count]
d110 8
a117 5
					Add(pKnownFile);
				}
				else
				{
					delete pKnownFile;
d119 6
a127 1
		//--- xrmb:parttraffic ---
a128 7
		LoadPartTraffic();
		//sLock.Unlock();
		//--- :xrmb ---

		//--- xrmb:partprio ---
		//--- restore the hidden/blocked settings ---
		LoadPartPrio();
a129 3
		//--- :xrmb ---

		return true;
d143 2
a144 4

	EMULE_CATCH

	return false;
a149 2
	EMULE_TRY

a152 1
	{
d154 2
a155 1
	}
d169 8
a176 1
  
d178 1
a178 7
	uint32 RecordsNumber = GetCount();
	fwrite(&RecordsNumber,4,1,file); 
  
	// Old write routine
	//for (uint32 i = 0; i < RecordsNumber; i++) {
	// ElementAt(i)->WriteToFile(file);
	//} 
d183 1
a183 1
	while (i < RecordsNumber)
d185 2
a186 1
		if (ElementAt(i) == NULL) // if is NULL is unuseful so we remove it!
d188 1
a188 1
			RecordsNumber--;
d190 5
a194 2
		} else { // element is not NULL, write it an go for next one
			((CKnownFile*)ElementAt(i))->WriteToFile(file);
d198 1
a198 1
  
d200 5
a204 2
	fseek(file, 1L, SEEK_SET);
	fwrite(&RecordsNumber, 4, 1, file); 
d206 4
a209 2
	// v1:- eklmn: bugfix(19): by shutdown force OS flush data direct to disk [SlugFiller]
	if ( !g_eMuleApp.m_pdlgEmule->IsRunning() ) _commit(_fileno(file));
a211 2
	sLock.Unlock(); // free mutex

d219 2
a220 1
	
d229 1
a229 1
 
d241 1
a241 1

d246 2
a247 1
	for (int i = 0;i < GetCount();i++){
d256 1
a256 1

d272 2
a273 2

void CKnownFileList::SafeAddKnownFile(CKnownFile* toadd)
d275 3
d279 1
a279 1
	Add(toadd);
d282 1
a282 1

d294 1
a294 1

d373 1
a373 1

d399 1
a399 1

d452 1
a452 1

d461 3
a463 1
	fwrite(&version, sizeof(version), 1, file);	
d504 1
a504 1

d513 2
d545 1
a545 1

d589 1
a589 1

d597 1
@


1.36
log
@Formatting, comments, and name changes.
@
text
@d434 1
d440 1
a440 1
		CKnownFile	*kf=ElementAt(i);
@


1.35
log
@Formatting, comments, and name changes.
@
text
@d246 1
a246 1
void CKnownFileList::SafeAddKFile(CKnownFile* toadd)
@


1.34
log
@fix for my fix :S
@
text
@d55 1
a55 1
	CKnownFile	*pKnownFile = 0; 
d63 1
a63 1
		//	Try to open the "Known Files" .dat. If we fail...
d79 1
a79 1
		file.Read(&iNumKnownFiles,4);
d85 1
a85 1
				if (pKnownFile->LoadFromFile(file))
d135 4
a138 1
	if ( m_bInSave ) return;
d150 1
a150 1
	// file was opened succesfull, set save flag
d185 1
a185 1
	sLock.Unlock(); // free mutex before closing
d198 3
a200 1
		
@


1.33
log
@some fixes in save of  known.met
@
text
@a79 2
		//eklmn: set size of array to prevent memory fragmentation
		SetSize(iNumKnownFiles);
@


1.32
log
@Fixed when first start without an existing known.met files to be hashed weren't added
@
text
@d55 1
a55 1
	CKnownFile		*pKnownFile = 0; 
d80 2
d135 4
a142 8
	// to avoid situation when sources saved both  each 30 min and on exit
	if ( m_bInSave )
	{
		return;
	}

	m_bInSave	=	true;

d148 3
a179 2
	sLock.Unlock(); // free mutex before closing

d184 2
d193 1
d195 1
d197 2
@


1.31
log
@Formatting, comments, and name changes.
@
text
@d60 4
a63 1
	//	Try to open the "Known Files" .dat. If we fail...
@


1.30
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d30 1
d33 6
a38 6
	filesFilePath.Format(_T("%sknown.met"), in_appdir);	
	trafficFilePath.Format(_T("%straffic.dat"), in_appdir);
	partPermissionFilePath.Format(_T("%spartperm.dat"), in_appdir);
	accepted = 0;
	requested = 0;
	transferred = 0;
d45 3
a47 2

CKnownFileList::~CKnownFileList(){
d50 1
a50 2


d55 8
a62 4
	CKnownFile* Record = 0; 
	CSafeFile file;
	try {		
		if (!file.Open(filesFilePath,CFile::modeRead|CFile::osSequentialScan)){			
d65 2
a66 1
		uint8 header;
d68 2
a69 1
		if (header != MET_HEADER){
d73 8
a80 6
		CSingleLock sLock(&list_mut,true); // to make sure that its thread-safe
		uint32 RecordsNumber;
		file.Read(&RecordsNumber,4);
		for (uint32 i = 0; i < RecordsNumber; i++) {
			Record =  new CKnownFile();
			if ( Record )
d82 1
a82 1
				if ( Record->LoadFromFile(file) )
d84 1
a84 1
					Add(Record);
d88 1
a88 1
					delete Record;
d107 2
a108 1
	catch(CFileException* error){
d112 2
a113 1
		else{
d124 1
a124 1

d132 1
a132 1
	CSingleLock sLock(&list_mut, true);
d143 1
a143 1
	if (!(file = _tfopen(filesFilePath, _T("wb"))))
d237 1
a237 1
	CSingleLock sLock(&list_mut,true);
d259 1
a259 1
	CSingleLock sLock(&list_mut,true);
d337 1
a337 1
	CSingleLock sLock(&list_mut, true);
d363 1
a363 1
	FILE	*file=_tfopen(partPermissionFilePath, _T("rb"));
d415 1
a415 1
	FILE	*file=_tfopen(partPermissionFilePath, _T("wb"));
d465 1
a465 1
	FILE	*fh=_tfopen(trafficFilePath, _T("rb"));
d504 1
a504 1
	FILE	*file=_tfopen(trafficFilePath, _T("wb"));
@


1.29
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d168 1
a168 1
	if ( !theApp.emuledlg->IsRunning() ) _commit(_fileno(file));
@


1.28
log
@latest mobile mule changes + some additional webserver stuff (see changelog)
@
text
@d37 1
a37 1
	transfered = 0;
@


1.27
log
@by shutdown force OS flush data direct to disk [Eklmn]&[SlugFiller]
@
text
@d532 8
@


1.26
log
@unicode cleanup
@
text
@d22 1
d165 4
a168 1
	sLock.Unlock(); // free mutex before closing 
@


1.25
log
@unicode cleanup
@
text
@d31 3
a33 3
	filesFilePath.Format("%sknown.met", in_appdir);	
	trafficFilePath.Format("%straffic.dat", in_appdir);
	partPermissionFilePath.Format("%spartperm.dat", in_appdir);
d131 1
a131 1
	if (!(file = _tfopen(filesFilePath, "wb")))
d348 1
a348 1
	FILE	*file=_tfopen(partPermissionFilePath, "rb");
d400 1
a400 1
	FILE	*file=_tfopen(partPermissionFilePath, "wb");
d450 1
a450 1
	FILE	*fh=_tfopen(trafficFilePath, "rb");
d489 1
a489 1
	FILE	*file=_tfopen(trafficFilePath, "wb");
@


1.24
log
@some more localizations...
@
text
@d190 1
a190 1
CKnownFile* CKnownFileList::FindKnownFile(char* filename,uint32 in_date,uint32 in_size)
d195 1
a195 1
		if (ElementAt(i)->GetFileDate() == in_date && ElementAt(i)->GetFileSize() == in_size && (!strcmp(filename,ElementAt(i)->GetFileName())))
@


1.23
log
@minor changes (use md4... instead of mem...)
@
text
@d262 1
a262 1
				AddLogLine(false, "merge: '%s' and '%s'.", ElementAt(i)->GetFileName(), ElementAt(j)->GetFileName());
d267 1
a267 1
					AddLogLine(false, "merge: you share the same file twice? abort merging.");
d275 1
a275 1
					AddLogLine(false, "merge: swapping files.");
d285 1
a285 1
					AddLogLine(false, "merge: failed.");
d304 1
a304 1
			AddLogLine(false, "merge: item %i merged with %i other items.", i, cnt);
d308 1
a308 1
	AddLogLine(false, "merge: %i items merged in total.", totalcnt);
d475 1
a475 1
				AddLogLine(false, "'traffic.dat' and 'known.met' aren't synchronous after %d datasets.", i);
@


1.22
log
@unicode cleanup
@
text
@d259 1
a259 1
				memcmp(ElementAt(i)->GetFileHash(), ElementAt(j)->GetFileHash(), 16)==0
d379 1
a379 1
			if(kf->GetFileSize()==filesize && memcmp(kf->GetFileHash(), hash, 16)==0)
d471 1
a471 1
			if(fs==ElementAt(i)->GetFileSize() && memcmp(tmp_filehash, ElementAt(i)->GetFileHash(), 16)==0)
@


1.21
log
@converted to helper function GetErrorMessage
@
text
@d131 1
a131 1
	if (!(file = fopen(filesFilePath, "wb")))
d348 1
a348 1
	FILE	*file=fopen(partPermissionFilePath, "rb");
d400 1
a400 1
	FILE	*file=fopen(partPermissionFilePath, "wb");
d450 1
a450 1
	FILE	*fh=fopen(trafficFilePath, "rb");
d489 1
a489 1
	FILE	*file=fopen(trafficFilePath, "wb");
@


1.20
log
@converted to new logger methods
@
text
@d102 1
a102 3
			char buffer[150];
			error->GetErrorMessage(buffer,150);
			AddLogLine(true, IDS_ERR_SERVERMET_UNKNOWN,buffer);
@


1.19
log
@code cleanup
@
text
@d100 1
a100 1
			AddLogLine(true,GetResString(IDS_ERR_SERVERMET_BAD));
d104 1
a104 1
			AddLogLine(true,GetResString(IDS_ERR_SERVERMET_UNKNOWN),buffer);
@


1.18
log
@WebServer: clear all or single completed files [SyruS]
@
text
@d72 1
a72 1
				if ( Record->LoadFromFile(&file) )
@


1.17
log
@WebServer: show completed files (0.28b) [SuruS]
@
text
@d206 1
a206 1
//SuruS show completed files (0.28b)
@


1.16
log
@minor fixes and improvements
@
text
@d206 16
@


1.15
log
@code cleanup
@
text
@d68 1
a68 1
		for (uint32 i = 0; i != RecordsNumber; i++) {
d196 1
a196 1
	for (int i = 0;i != GetCount();i++){
@


1.14
log
@Updated version to 1e, removed DonkeyDoctor broken support and added again TwoBottleMOD code with a fix.
@
text
@d29 5
a33 3
CKnownFileList::CKnownFileList(char* in_appdir)
{
	appdir = in_appdir;
d48 1
d55 2
a56 7
	try {
		char* fullpath = new char[strlen(appdir)+MAX_PATH];
		strcpy(fullpath,appdir);
		strcat(fullpath,"known.met");
		if (!file.Open(fullpath,CFile::modeRead|CFile::osSequentialScan)){
			delete[] fullpath;
			fullpath=NULL;
d58 1
a58 3
		}
		delete[] fullpath;
		fullpath=NULL;
d132 3
a134 8
	FILE* file = NULL; 
	char* fullpath = new char[strlen(appdir)+MAX_PATH];
	strcpy(fullpath,appdir);
	strcat(fullpath,"known.met");
	if (!(file = fopen(fullpath, "wb")))
	{
		delete[] fullpath;
		fullpath=NULL;
d136 1
a136 3
	}
	delete[] fullpath; 
	fullpath=NULL;
d334 1
a334 5
	char	fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "partperm.dat");

	FILE	*file=fopen(fullpath, "rb");
d386 1
a386 5
	char	fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "partperm.dat");

	FILE	*file=fopen(fullpath, "wb");
d436 1
a436 5
	char	fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "traffic.dat");

	FILE	*fh=fopen(fullpath, "rb");
a473 3
	char fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "traffic.dat");
d475 1
a475 1
	FILE	*file=fopen(fullpath, "wb");
@


1.13
log
@*** empty log message ***
@
text
@d217 1
a217 2
// DonkeyDoctor
void CKnownFileList::SafeAddKFile(CKnownFile* toadd, bool updateKnownMet)
a218 2
	EMULE_TRY

d221 1
a221 39
	if (updateKnownMet)
	{
		FILE* file;
		char* fullpath = new char[strlen(appdir)+MAX_PATH];
		strcpy(fullpath,appdir);
		strcat(fullpath,"known.met"); 
		if ((file = fopen(fullpath, "a+b")) != NULL)
		{
			if(!fseek(file, 0, SEEK_END))
			{ 
	        		if(!toadd->WriteToFile(file))
	        		{
					if(!fseek(file, 1, SEEK_SET))
					{
						uint32 nRecords;
						if(fread(&nRecords, sizeof(uint32), 1, file) == 1)
						{
							nRecords++;
							fflush(file);
							if(fwrite(&nRecords, sizeof(uint32), 1, file) != 1)
							{
								// Error writting to Known.met 
							} 
	                  			}
	                  			// else Error reading from known.met 
	               			}
					// else Error moving file pointer 
	 			}
	 			// else Error writting to known.met 
	         	}
	         	// else Error moving file pointer
	         	fclose(file);
	        }
	        // else Error opening known.met
	        delete[] fullpath;
	} 
	sLock.Unlock(); 

	EMULE_CATCH
@


1.13.2.1
log
@27a partial merge
@
text
@d34 1
a34 1
	transferred = 0;
@


1.12
log
@converted to new logging method
@
text
@d74 11
a84 2
			Record->LoadFromFile(&file);
			Add(Record);
@


1.11
log
@bugfix for bugs 47, 53, & 62 ! :P
@
text
@d95 1
a95 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_SERVERMET_BAD));
d99 1
a99 1
			theApp.emuledlg->AddLogLine(true,GetResString(IDS_ERR_SERVERMET_UNKNOWN),buffer);
d291 1
a291 1
				theApp.emuledlg->AddLogLine(false, "merge: '%s' and '%s'.", ElementAt(i)->GetFileName(), ElementAt(j)->GetFileName());
d296 1
a296 1
					theApp.emuledlg->AddLogLine(false, "merge: you share the same file twice? abort merging.");
d304 1
a304 1
					theApp.emuledlg->AddLogLine(false, "merge: swapping files.");
d314 1
a314 1
					theApp.emuledlg->AddLogLine(false, "merge: failed.");
d333 1
a333 1
			theApp.emuledlg->AddLogLine(false, "merge: item %i merged with %i other items.", i, cnt);
d337 1
a337 1
	theApp.emuledlg->AddLogLine(false, "merge: %i items merged in total.", totalcnt);
d516 1
a516 1
				theApp.emuledlg->AddLogLine(false, "'traffic.dat' and 'known.met' aren't synchronous after %d datasets.", i);
@


1.10
log
@*** empty log message ***
@
text
@d111 1
a111 1
void CKnownFileList::Save() 
d178 1
a178 1

d257 1
a261 3
	//if(GetTickCount() - lastsaved > 30*60*1000) // 30min
	//{
	//	lastsaved=GetTickCount();
a262 1
	//}
@


1.9
log
@xrmb:statsautosave fix
@
text
@d186 1
a186 1
	for (int i = 0; i != GetSize();i++)
@


1.8
log
@xrmb updated code for Part Traffic (not the last one).
@
text
@d261 3
a263 3
/*	if(GetTickCount() - lastsaved > 30*60*1000) // 30min
	{
		lastsaved=GetTickCount();
d265 1
a265 2
	}
*/
@


1.7
log
@Code clean up and double check wit official code.
@
text
@d37 1
a37 1
//	lastsaved=GetTickCount();
d80 3
d84 3
a86 38
		//--- load collected traffic data in our file ---
		fullpath = new char[MAX_PATH];
		strcpy(fullpath, appdir);
		strcat(fullpath, "traffic.dat");
		FILE	*fh=fopen(fullpath, "rb");
		delete[] fullpath;
		if(!fh)
			return false;

		uint8	version=0;
		fread(&version, sizeof(version), 1, fh);
		uint32	records;
		fread(&records, sizeof(records), 1, fh);

		uchar tmp_filehash[16];
		uint32 fs=0;
		// [Lord KiRon]
		for(uint32 i=0; i<records,i < (uint32)GetCount() ; i++) 
		//for(uint32 i=0; i<records ; i++) 
		// [/Lord KiRon]
		{
			uint8 hasData=0;
			fread(&hasData, sizeof(hasData), 1, fh);

			if(hasData)
			{
				fread(tmp_filehash, 16, 1, fh);
				fread(&fs, sizeof(fs), 1, fh);
				if(fs==ElementAt(i)->GetFileSize() && memcmp(tmp_filehash, ElementAt(i)->GetFileHash(), 16)==0)
					ElementAt(i)->LoadFromFileTraffic(fh, version);
				else
				{
					theApp.emuledlg->AddLogLine(false, "'traffic.dat' and 'known.met' aren't synchronous after %d datasets.", i);
					break;
				}
			}
		}
		fclose(fh);
d172 2
a173 39
	//--- load collected traffic data in our file ---
	fullpath=new char[MAX_PATH];
	strcpy(fullpath,appdir);
	strcat(fullpath,"traffic.dat");
	if (!(file = fopen(fullpath, "wb")))
	{
		delete[] fullpath;	
		return;
	}
	delete[] fullpath;
	uint8	version=2;
	fwrite(&version, sizeof(version), 1, file);	
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);
	for(uint32 i = 0; i < RecordsNumber; i++) 
	{
		// only save for known-files with traffic
		if(ElementAt(i)->statistic.partTraffic)
		{
			uint8 hasData=1;
			fwrite(&hasData, sizeof(hasData), 1, file);

			//--- write hash ---
			fwrite(ElementAt(i)->GetFileHash(), 16, 1, file);

			//--- write filesize ---
			uint32 fs=ElementAt(i)->GetFileSize();
			fwrite(&fs, sizeof(fs), 1, file);
			
			//--- write part/block traffic ---
			ElementAt(i)->SaveToFileTraffic(file);
		}
		else
		{
			uint8 hasData=0;
			fwrite(&hasData, sizeof(hasData), 1, file);
		}
	}

	fclose(file);
d175 2
a176 1
	m_bInSave	=	false;
d263 1
a263 1
		lastsaved=GetTickCount();*/
d265 2
a266 1
//	}
d377 37
d415 161
a575 1
//--- :xrmb ---
@


1.7.2.1
log
@keeping in sync with the main cvs line
@
text
@d37 1
a37 1
	//lastsaved=GetTickCount();
a79 3
		LoadPartTraffic();
		//sLock.Unlock();
		//--- :xrmb ---
d81 38
a118 3
		//--- xrmb:partprio ---
		//--- restore the hidden/blocked settings ---
		LoadPartPrio();
d204 39
a242 2
	SavePartTraffic();
	//--- :xrmb ---
d244 1
a244 2
	//--- xrmb:partprio ---
	SavePartPrio();
d331 1
a331 1
		lastsaved=GetTickCount();
d333 1
a333 2
	}
*/
a443 11
//--- xrmb:partprio ---
bool	CKnownFileList::LoadPartPrio()
{
	//--- save the part-permission ---
	char	fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "partperm.dat");

	FILE	*file=fopen(fullpath, "rb");
	if(file==NULL)
		return false;
d445 1
a445 187
	uint8 version=1;
	fread(&version, sizeof(version), 1, file);	

	uint32	RecordsNumber=0;
	fread(&RecordsNumber, sizeof(RecordsNumber), 1, file);

	CKnownFile	*kf;
	uchar		hash[16];
	uint32		filesize;
	uint32		fpos;
	for(uint32 i=0; i<RecordsNumber; i++) 
	{
		//--- read hash ---
		fread(hash, 16, 1, file);

		//--- read filesize ---
		fread(&filesize, sizeof(filesize), 1, file);

		//--- save pos ---
		fpos=ftell(file);
		
		//--- find all these files ---
		for(int j=0; j<GetCount(); j++)
		{
			kf=ElementAt(j);

			//--- right file? ---
			if(kf->GetFileSize()==filesize && memcmp(kf->GetFileHash(), hash, 16)==0)
			{
				fseek(file, fpos, SEEK_SET);

				for(uint16 part=0; part<kf->GetPartCount(); part++)
				{
					uint8	state=PR_PART_ON;
					fread(&state, sizeof(state), 1, file);
					kf->SetPartStatus(part, state);
				}
			}
		}
	}
	fclose(file);

	return true;
}

bool	CKnownFileList::SavePartPrio()
{
	//--- save the part-permission ---
	char	fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "partperm.dat");

	FILE	*file=fopen(fullpath, "wb");
	if(file==NULL)
		return false;

	uint8 version=1;
	fwrite(&version, sizeof(version), 1, file);	

	//--- preserve the space for the recordnumers ---
	uint32	RecordsNumber=0;
	uint32	rnpos=ftell(file);
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);
	for(int i=0; i<GetCount(); i++) 
	{
		CKnownFile	*kf=ElementAt(i);

		// only save for known-files with traffic
		if(kf->HasHiddenParts())
		{
			//--- write hash ---
			fwrite(kf->GetFileHash(), 16, 1, file);

			//--- write filesize ---
			uint32 fs=kf->GetFileSize();
			fwrite(&fs, sizeof(fs), 1, file);
			
			//--- save prio ---
			for(uint16 part=0; part<kf->GetPartCount(); part++)
			{
				uint8	state=kf->GetPartStatus(part);
				fwrite(&state, sizeof(state), 1, file);
			}

			RecordsNumber++;
		}
	}

	//--- save the number of stored records ---
	fseek(file, rnpos, SEEK_SET);
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);

	fclose(file);

	return true;
}
//--- :xrmb/partprio ---

//--- xrmb:parttraffic ---
bool	CKnownFileList::LoadPartTraffic()
{
	//--- load collected traffic data in our file ---
	char	fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "traffic.dat");

	FILE	*fh=fopen(fullpath, "rb");
	if(!fh)
		return false;

	uint8	version=0;
	fread(&version, sizeof(version), 1, fh);

	uint32	records;
	fread(&records, sizeof(records), 1, fh);

	uchar tmp_filehash[16];
	uint32 fs=0;
	for(uint32 i=0; i<records; i++) 
	{
		uint8 hasData=0;
		fread(&hasData, sizeof(hasData), 1, fh);

		if(hasData)
		{
			fread(tmp_filehash, 16, 1, fh);
			fread(&fs, sizeof(fs), 1, fh);
			if(fs==ElementAt(i)->GetFileSize() && memcmp(tmp_filehash, ElementAt(i)->GetFileHash(), 16)==0)
				ElementAt(i)->LoadFromFileTraffic(fh, version);
			else
			{
				theApp.emuledlg->AddLogLine(false, "'traffic.dat' and 'known.met' aren't synchronous after %d datasets.", i);
				break;
			}
		}
	}
	fclose(fh);

	return true;
}

bool	CKnownFileList::SavePartTraffic()
{
	//--- save traffic data to our file ---
	char fullpath[MAX_PATH];
	strcpy(fullpath, appdir);
	strcat(fullpath, "traffic.dat");

	FILE	*file=fopen(fullpath, "wb");
	if(file==NULL)
		return false;

	uint8	version=2;
	fwrite(&version, sizeof(version), 1, file);	

	uint32	RecordsNumber=GetCount();
	fwrite(&RecordsNumber, sizeof(RecordsNumber), 1, file);
	for(uint32 i=0; i<RecordsNumber; i++) 
	{
		// only save for known-files with traffic
		if(ElementAt(i)->statistic.partTraffic)
		{
			uint8 hasData=1;
			fwrite(&hasData, sizeof(hasData), 1, file);

			//--- write hash ---
			fwrite(ElementAt(i)->GetFileHash(), 16, 1, file);

			//--- write filesize ---
			uint32 fs=ElementAt(i)->GetFileSize();
			fwrite(&fs, sizeof(fs), 1, file);
			
			//--- write part/block traffic ---
			ElementAt(i)->SaveToFileTraffic(file);
		}
		else
		{
			uint8 hasData=0;
			fwrite(&hasData, sizeof(hasData), 1, file);
		}
	}

	fclose(file);

	return true;
}
//--- :xrmb/parttraffic ---
@


1.6
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@a17 1

a27 1

@


1.5
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d60 1
d64 1
a64 1
		
d168 1
d172 1
@


1.4
log
@*** empty log message ***
@
text
@d24 7
@


1.3
log
@*** empty log message ***
@
text
@d30 1
d141 12
a163 3
	// We need to do it thread safe because now is called under CUploadQueue::RemoveFromUploadQueue()
	CSingleLock sLock(&list_mut, true);

d235 2
@


1.2
log
@Fixed the crash in bool CKnownFileList::Init() code
when traffic.dat and known.met contain different number of records
[Lord KiRon]
@
text
@d31 1
a31 1
	lastsaved=GetTickCount();
d309 1
a309 1
	if(GetTickCount() - lastsaved > 30*60*1000) // 30min
d311 1
a311 1
		lastsaved=GetTickCount();
d313 1
a313 1
	}
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d90 4
a93 1
		for(uint32 i=0; i<records; i++) 
@

