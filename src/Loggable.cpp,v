head	1.27;
access;
symbols
	PublicRelease_1_2e:1.27
	Interim_Release_1-2e_RC1:1.27
	PublicRelease_1_2d:1.26
	Interim_Release_1-2d_RC1:1.26
	Interim_Release_1-2d_beta1:1.26
	PublicRelease_1_2c:1.25
	Interim_Release_1-2c_RC1:1.25
	Interim_Release_1-2c_beta1:1.25
	PublicRelease_1_2b:1.25
	Interim_Release_1-2b_RC1:1.25
	PublicRelease_1_2a:1.25
	Interim_Release_1-2a_RC1:1.25
	Interim_Release_1-2a_beta2:1.25
	Interim_Release_1-2a_beta1:1.25
	PublicRelease_1_2:1.25
	Interim_Release_1-2_RC1:1.25
	Interim_Release_1-2_beta1:1.25
	PublicRelease_1_1g:1.24
	Interim_Release_1-1g_RC3:1.24
	Interim_Release_1-1g_RC2:1.24
	Interim_Release_1-1g_RC1:1.24
	Interim_Release_1-1g_beta2:1.22
	Interim_Release_1-1g_beta1:1.22
	PublicRelease_1_1f:1.22
	Interim_Release_1-1f_RC1:1.22
	PublicRelease_1_1e:1.22
	Interim_Release_1-1e_RC2:1.22
	Interim_Release_1-1e_RC1:1.22
	Interim_Release_1-1e_beta1:1.22
	PublicRelease_1_1d:1.19
	Interim_Release_1-1d_RC1:1.19
	PublicRelease_1_1c:1.19
	Interim_Release_1-1c_RC1:1.19
	Interim_Release_1-1c_beta2:1.18
	Interim_Release_1-1c_beta1:1.17
	PublicRelease_1_1b:1.14
	Interim_Release_1-1b_RC1:1.14
	PublicRelease_1_1a:1.14
	Interim_Release_1-1a_RC2:1.14
	Interim_Release_1-1a_RC1:1.14
	Interim_Release_1-1a_beta2:1.14
	Interim_Release_1-1a_beta1:1.14
	PublicRelease_1_1:1.14
	Interim_Release_1-1_beta1:1.14
	PublicRelease_1o:1.14
	Interim_Release_1o_RC1:1.14
	Interim_Release_1o_beta1:1.14
	PublicRelease_1n:1.14
	Interim_Release_1n_RC2:1.14
	Interim_Release_1n_RC1:1.14
	Interim_Release_1n_beta2:1.14
	Interim_Release_1n_beta1:1.14
	PublicRelease_1m:1.13
	Interim_Release_1m_beta1:1.13
	PublicRelease_1l:1.13
	Interim_Release_1l_RC3:1.13
	Interim_Release_1l_RC2:1.13
	Interim_Release_1l_RC1:1.13
	Interim_Release_1l_beta2:1.13
	Interim_Release_1l_beta1:1.13
	PublicRelease_1k:1.13
	Interim_Release_1k_RC4:1.13
	Interim_1k_RC3:1.13
	Interim_1k_RC2:1.13
	Interim_Release_1k_RC1:1.13
	Interim_Release_1k_beta5:1.13
	Intrerim_Release_1k_beta4:1.13
	Interim_Release_1k_beta1:1.13
	PublicRelease_1j:1.12
	Interim_Release_1J_RC3:1.12
	Interim_Release_1j_RC3:1.12
	Interim_Release_1j_RC2:1.12
	Interim_Release_1j_RC1:1.12
	Interim_Release_1j_beta2:1.12
	Interim_Release_1j_beta1:1.12
	PublicRelease_1i:1.11
	Interim_Release_1i_RC6:1.11
	Interim_Release_1i_RC3:1.10
	Interim_Release_1i_RC2:1.10
	Interim_Release_1i_RC1:1.10
	Interim_Release_1i_beta3:1.10
	Interim_Release_1i_beta2:1.10
	Interim_Release_1i_beta1:1.9
	PublicRelease_1h:1.6
	Interim_Release_1h_rc2:1.6
	Interim_Release_1h_RC1:1.6
	Interim_Release_1h_beta2:1.6
	Interim_Release_1h_beta1_now:1.6
	Interim_Release_1h_beta1:1.6
	PublicRelease_1g:1.6
	Interim_Release_1g_RC6_Final:1.6
	Interim_Release_1g_RC6:1.6
	Interim_Release_1g_RC5:1.5
	Interim_Release_1g_RC4:1.5
	Interim_Release_1g_RC3:1.5
	Interim_Release_1g_beta2:1.4
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.2
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.2
	threaded_downloadqueue:1.1.0.2;
locks; strict;
comment	@// @;


1.27
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.11.18.09.45;	author fuxie-dk;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.15.17.41.10;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.11.16.32.38;	author kuchin;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.08.14.16.36;	author kuchin;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.05.05.49.07;	author kuchin;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.18.18.03.29;	author kuchin;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.03.16.12.39;	author kuchin;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.29.14.55.02;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.29.13.34.52;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.28.20.13.53;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.12.11.14.32.47;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.04.06.50.52;	author eklmn;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.13.15.11.04;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.22.22.21.49;	author eklmn;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.15.20.22.47;	author syrus77;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.06.09.01.15.46;	author syrus77;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.07.11.59.18;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.15.00.54.08;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.14.11.55.40;	author partyckip;	state Exp;
branches;
next	;


desc
@@


1.27
log
@Simplified logging system implementation.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#ifndef NEW_SOCKETS_ENGINE
	#include "emule.h"
#else
	#define GetResString(id)  _T("NOT IMPLEMENTED YET")
#endif //NEW_SOCKETS_ENGINE
#include "Loggable.h"

void CLoggable::AddLogLine(int iMode, UINT nID, ...)
{
	va_list argptr;
	va_start(argptr, nID);
	AddLogText(iMode, GetResString(nID), argptr);
	va_end(argptr);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CLoggable::AddLogLine(int iMode, LPCTSTR line, ...)
{
	ASSERT(line != NULL);

	va_list argptr;
	va_start(argptr, line);
	AddLogText(iMode, line, argptr);
	va_end(argptr);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CLoggable::AddLogText(int iMode, LPCTSTR line, va_list argptr)
{
	ASSERT(line != NULL);

	EMULE_TRY

#ifndef NEW_SOCKETS_ENGINE
	if (((iMode & LOG_FL_DBG) != 0) && !g_App.m_pPrefs->GetVerbose())
		return;
#endif

	CString sBuffer;

	sBuffer.FormatV(line, argptr);

#ifndef NEW_SOCKETS_ENGINE
	#ifdef _DEBUG
		//SyruS (0.29c) view the log messages while shutting down at least in the debugger
		if (g_App.m_app_state != g_App.APP_STATE_RUNNING)
			TRACE("App Log: %s\n", sBuffer);
	#endif

	if (g_App.m_pMDlg)
		g_App.m_pMDlg->AddLogText(iMode, sBuffer);
#else
	g_stEngine.AddLog((iMode & LOG_FL_DBG) ? LOG_DEBUG : LOG_WARNING, sBuffer);
#endif //NEW_SOCKETS_ENGINE

#ifdef _DEBUG
	if ((iMode & LOG_FL_DBG) != 0)
		::OutputDebugString(sBuffer + _T("\n"));
#endif

	EMULE_CATCH2
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.26
log
@Dropped unused functionality [Aw3].
@
text
@d25 1
a25 1
void CLoggable::AddLogLine(bool addtostatusbar, UINT nID, ...)
d29 1
a29 1
	AddLogText(false, addtostatusbar, GetResString(nID), argptr);
a31 11

void CLoggable::AddLogLine(bool addtostatusbar, LPCTSTR line, ...)
{
	ASSERT(line != NULL);

	va_list argptr;
	va_start(argptr, line);
	AddLogText(false, addtostatusbar, line, argptr);
	va_end(argptr);
}

d33 1
a33 1
void CLoggable::AddDebugLogLine(LPCTSTR line, ...)
d39 1
a39 1
	AddLogText(true, false, line, argptr);
a41 1

d43 1
a43 1
void CLoggable::AddLogText(bool debug, bool addtostatusbar, LPCTSTR line, va_list argptr)
d50 1
a50 1
	if (debug && !g_App.m_pPrefs->GetVerbose())
d52 1
a52 1
#endif //NEW_SOCKETS_ENGINE
d63 1
a64 1
	#endif
d66 3
a68 3
		g_App.m_pMDlg->AddLogText(addtostatusbar, sBuffer, debug);	// debug log and normal log handled by the same subroutine now
#else //NEW_SOCKETS_ENGINE
	g_stEngine.AddLog(debug ? LOG_DEBUG : LOG_WARNING, sBuffer);
d72 1
a72 1
	if (debug)
@


1.25
log
@Removed unused code.
@
text
@d1 16
d20 1
a20 1
#else //NEW_SOCKETS_ENGINE
a43 9
void CLoggable::AddDebugLogLine(UINT nID, ...)
{
	va_list argptr;
	va_start(argptr, nID);
	AddLogText(true, false, GetResString(nID), argptr);
	va_end(argptr);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.24
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1 1
a1 1
#include "StdAfx.h"
d7 1
a7 1
#include "loggable.h"
a10 1

a18 1

a29 1

a38 1

d56 1
a56 1
		return ;
d71 1
a71 1
		g_App.m_pMDlg->AddLogText(addtostatusbar, sBuffer, debug);	//Cax2 - debug log and normal log handled by the same subroutine now
a76 1

a78 1

a83 35
void CLoggable::PacketToDebugLogLine(LPCTSTR info, char * packet, uint32 size, byte opcode) const
{
#ifndef NEW_SOCKETS_ENGINE

	CString strBuffer;
	uint32 dwMaxSize = 100;

	strBuffer.Format(_T("%s: %02x, size=%u, data=["), info, opcode, size);
	for (uint32 i = 0; (i < size && i < dwMaxSize); i++)
	{
		strBuffer.AppendFormat(_T("%02x "), (byte)packet[i]);
	}

	strBuffer += ((size < dwMaxSize) ? _T("]") : _T("..]"));
	g_App.m_pMDlg->AddDebugLogLine(strBuffer);
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CLoggable::TagToDebugLogLine(LPCTSTR info, LPCTSTR tag, uint32 size, byte opcode) const
{
#ifndef NEW_SOCKETS_ENGINE
	CString strBuffer;
	uint32 dwMaxSize = 100;
	
	strBuffer.Format(_T("%s: %02x, size=%u, data=["), info, opcode, size);
	for (uint32 i = 0; (i < size && i < dwMaxSize); i++)
	{
		strBuffer.AppendFormat(_T("%02x "), (byte)tag[i]);
	}

	strBuffer += ((size < dwMaxSize) ? _T("]") : _T("..]"));
	g_App.m_pMDlg->AddDebugLogLine(strBuffer);
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.23
log
@renamed 3 variables
@
text
@d59 1
a59 1
	if (debug && !g_App.g_pPrefs->GetVerbose())
@


1.22
log
@v2 - logging subsystem
@
text
@d59 1
a59 1
	if (debug && !g_eMuleApp.m_pGlobPrefs->GetVerbose())
d70 1
a70 1
		if (g_eMuleApp.m_app_state != g_eMuleApp.APP_STATE_RUNNING)
d74 2
a75 2
	if (g_eMuleApp.m_pdlgEmule)
		g_eMuleApp.m_pdlgEmule->AddLogText(addtostatusbar, sBuffer, debug);	//Cax2 - debug log and normal log handled by the same subroutine now
d104 1
a104 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(strBuffer);
d121 1
a121 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(strBuffer);
@


1.21
log
@v2 - more abstraction + logic
@
text
@a4 1
	#include "Engine/Database/TaskProcessorDB.h"
d77 1
a77 4
	#ifdef USE_BERKELEY_DB
		CTask_AddToLog *pTask = new CTask_AddToLog(g_stEngine.m_pDbProcessor->m_pDbEnv, g_stEngine.m_pDbProcessor->m_pDbLogs, debug, sBuffer);
		g_stEngine.DB.Push(pTask);
	#endif //USE_BERKELEY_DB
@


1.20
log
@v2 - more upload logic, light configuration (without BerkeleyDb)
@
text
@a4 3
	#ifndef NEW_SOCKETS_TRAY
		#include "otherfunctions.h"
	#endif //NEW_SOCKETS_TRAY
d6 1
@


1.19
log
@v2 - minor rearrangements, fixes for EngineTray compilation
@
text
@d80 1
a80 1
	#ifndef NEW_SOCKETS_TRAY
d83 1
a83 1
	#endif //NEW_SOCKETS_TRAY
@


1.18
log
@Many ifdefs for v2
@
text
@d5 3
a7 1
	#include "otherfunctions.h"
d82 1
a82 1
		g_stEngine.PushToDB(pTask);
@


1.17
log
@Xml and database functionality
@
text
@d3 1
a3 1
#include "emule.h"
d5 2
a6 1
#include "Engine/Database/TaskProcessorDB.h"
@


1.16
log
@Corrected v2 defines again
@
text
@d78 1
a78 1
		CTask_AddToLog *pTask = new CTask_AddToLog(g_stEngine.m_pDbProcessor->m_pDbEnv, g_stEngine.m_pDbProcessor->m_pDbLogs, debug, line);
@


1.15
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@d5 1
a5 1
#include "Engine/EmEngine.h"
d68 4
a71 6
#ifdef _DEBUG
	//SyruS (0.29c) view the log messages while shutting down at least in the debugger
	if (g_eMuleApp.m_app_state != g_eMuleApp.APP_STATE_RUNNING)
		TRACE("App Log: %s\n", sBuffer);

#endif
d73 1
d77 4
a80 2
	CTask_AddToLog *pTask = new CTask_AddToLog(g_stEngine.m_stDBTP.m_pDbEnv, g_stEngine.m_stDBTP.m_pDbLogs, debug, line);
	g_stEngine.PushToDB(pTask);
@


1.14
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d4 2
d77 3
@


1.13
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d28 1
a28 1
void CLoggable::AddDebugLogLine(bool addtostatusbar, UINT nID, ...)
d33 1
a33 1
	AddLogText(true, addtostatusbar, GetResString(nID), argptr);
d38 1
a38 1
void CLoggable::AddDebugLogLine(bool addtostatusbar, LPCTSTR line, ...)
d45 1
a45 1
	AddLogText(true, addtostatusbar, line, argptr);
d101 1
a101 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, strBuffer);
d118 1
a118 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, strBuffer);
@


1.12
log
@New engine
@
text
@d87 1
a87 1
void CLoggable::PacketToDebugLogLine(LPCTSTR info, char * packet, uint32 size, uint8 opcode) const
d97 1
a97 1
		strBuffer.AppendFormat(_T("%02x "), (uint8)packet[i]);
d105 1
a105 1
void CLoggable::TagToDebugLogLine(LPCTSTR info, LPCTSTR tag, uint32 size, uint8 opcode) const
d114 1
a114 1
		strBuffer.AppendFormat(_T("%02x "), (uint8)tag[i]);
@


1.11
log
@small optimization
@
text
@d2 1
d4 1
d56 1
d59 1
d65 1
d75 1
d89 3
a91 1
		CString strBuffer;
d102 1
d107 1
d119 1
@


1.10
log
@Formatting, comments, and name changes.
@
text
@a79 1

a80 1
// DbT:Logging
d83 2
a84 4
	CString buffer;
	buffer.Format(_T("%s: %02x, size=%u"), info, opcode, size);
	buffer += _T(", data=[");
	uint32 maxsize = 100;
d86 2
a87 1
	for (uint32 i = 0; i < size && i < maxsize; i++)
d89 1
a89 2
		buffer.AppendFormat(_T("%02x"), (uint8)packet[i]);
		buffer += _T(" ");
d92 2
a93 2
	buffer += ((size < maxsize) ? _T("]") : _T("..]"));
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, buffer);
d95 1
a95 1

d98 5
a102 6
	CString buffer;
	buffer.Format(_T("%s: %02x, size=%u"), info, opcode, size);
	buffer += _T(", data=[");
	uint32 maxsize = 100;

	for (uint32 i = 0; i < size && i < maxsize; i++)
d104 1
a104 2
		buffer.AppendFormat(_T("%02x"), (uint8)tag[i]);
		buffer += _T(" ");
d107 2
a108 2
	buffer += ((size < maxsize) ? _T("]") : _T("..]"));
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, buffer);
d110 1
a110 2

// DbT:End
@


1.9
log
@TCHAR buffer replaced over CString
@
text
@d5 3
a7 2
void CLoggable::AddLogLine(bool addtostatusbar, UINT nID, ...) {
		
d9 3
a11 3
	va_start(argptr, nID);	
	AddLogText(false, addtostatusbar, GetResString(nID), argptr);	
	va_end(argptr);	
d14 4
a17 3
void CLoggable::AddLogLine(bool addtostatusbar, LPCTSTR line, ...) {
	
	ASSERT(line != NULL);	
d20 2
a21 2
	va_start(argptr, line);	
	AddLogText(false, addtostatusbar, line, argptr);	
d24 1
d26 2
a27 1
void CLoggable::AddDebugLogLine(bool addtostatusbar, UINT nID, ...) {
d30 3
a32 3
	va_start(argptr, nID);	
	AddLogText(true, addtostatusbar, GetResString(nID), argptr);			
	va_end(argptr);	
d34 1
d36 3
a38 2
void CLoggable::AddDebugLogLine(bool addtostatusbar, LPCTSTR line, ...) {
	
d43 2
a44 2
	AddLogText(true, addtostatusbar, line, argptr);	
	va_end(argptr);	
d46 1
d48 1
a48 1
void CLoggable::AddLogText(bool debug, bool addtostatusbar,LPCTSTR line, va_list argptr)
d51 1
a51 1
	
d55 1
a55 1
		return;	
d58 1
d60 1
a60 1
	
d65 1
d68 1
a68 1
	if (g_eMuleApp.m_pdlgEmule)	
d72 1
d74 2
a75 1
		::OutputDebugString(sBuffer);
d80 1
d83 3
a85 2
void CLoggable::PacketToDebugLogLine(LPCTSTR info, char * packet, uint32 size, uint8 opcode) const {
	CString buffer; 
d89 3
a91 1
	for(uint32 i = 0; i < size && i < maxsize; i++){		
d95 1
d97 1
a97 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, buffer); 
d100 3
a102 2
void CLoggable::TagToDebugLogLine(LPCTSTR info, LPCTSTR tag, uint32 size, uint8 opcode) const {
	CString buffer; 
d106 3
a108 1
	for(uint32 i = 0; i < size && i < maxsize; i++){		
d112 1
d114 1
a114 1
	g_eMuleApp.m_pdlgEmule->AddDebugLogLine(false, buffer); 
d116 1
@


1.8
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d50 2
a51 4
	const size_t bufferSize = 1000;
	TCHAR bufferline[bufferSize];	
	if (_vsntprintf(bufferline, bufferSize, line, argptr) == -1)
		bufferline[bufferSize - 1] = _T('\0');
d56 1
a56 1
		TRACE("App Log: %s\n", bufferline);
d60 1
a60 1
		g_eMuleApp.m_pdlgEmule->AddLogText(addtostatusbar, bufferline, debug);	//Cax2 - debug log and normal log handled by the same subroutine now
d64 1
a64 1
		::OutputDebugString(bufferline);
@


1.7
log
@Second batch of name changes
@
text
@d47 1
a47 1
	if (debug && !theApp.glob_prefs->GetVerbose())
d57 1
a57 1
	if (theApp.m_app_state != theApp.APP_STATE_RUNNING)
d61 2
a62 2
	if (theApp.emuledlg)	
		theApp.emuledlg->AddLogText(addtostatusbar, bufferline, debug);	//Cax2 - debug log and normal log handled by the same subroutine now
d83 1
a83 1
	theApp.emuledlg->AddDebugLogLine(false, buffer); 
d96 1
a96 1
	theApp.emuledlg->AddDebugLogLine(false, buffer); 
@


1.6
log
@tracing loglines in debugger when shutting down
@
text
@d22 1
a22 1

d30 1
a30 1

d40 3
a42 3

void CLoggable::AddLogText(bool debug, bool addtostatusbar,LPCTSTR line, va_list argptr) {
	
d64 5
d71 1
a71 1

@


1.5
log
@unicode cleanup
@
text
@d55 6
@


1.4
log
@FEATURE: data logging of unknown tags and packets [DoubleT]
@
text
@d62 1
a62 1
void CLoggable::PacketToDebugLogLine(const char* info, const char* packet, uint32 size, uint8 opcode) const {
d65 1
a65 1
	buffer += ", data=[";
d67 3
a69 5
	for(uint32 i = 0; i < size && i < maxsize; i++){
		char temp[3];
		sprintf(temp, "%02x", (uint8)packet[i]);
		buffer += temp;
		buffer += " ";
d71 1
a71 1
	buffer += (const char*)((size < maxsize) ? "]" : "..]");
d75 1
a75 1
void CLoggable::TagToDebugLogLine(const char* info, const char* tag, uint32 size, uint8 opcode) const {
d78 1
a78 1
	buffer += ", data=[";
d80 3
a82 5
	for(uint32 i = 0; i < size && i < maxsize; i++){
		char temp[3];
		sprintf(temp, "%02x", (uint8)tag[i]);
		buffer += temp;
		buffer += " ";
d84 1
a84 1
	buffer += (const char*)((size < maxsize) ? "]" : "..]");
@


1.3
log
@new helper methods
@
text
@d59 33
a91 1
}@


1.2
log
@further updated the addlog function + minor bugfix!
@
text
@d5 7
d13 1
a13 5
void CLoggable::AddLogLine(bool addtostatusbar,CString line,...) {
	
	EMULE_TRY
	
	char bufferline[1000];
d15 2
d18 2
a19 2
	va_start(argptr, line);
	_vsnprintf(bufferline, 1000, line, argptr);
d21 9
d31 3
a33 2
	if (theApp.emuledlg)
		theApp.emuledlg->AddLogText(addtostatusbar,bufferline);
d35 4
a38 1
	EMULE_CATCH2
d41 4
a44 1
void CLoggable::AddDebugLogLine(bool addtostatusbar,CString line,...) {
d47 1
a47 1
	if( !theApp.glob_prefs->GetVerbose() )
d49 6
a54 7
	char bufferline[1000];
 	
	va_list argptr;
	va_start(argptr, line);
	_vsnprintf(bufferline, 1000, line, argptr);
	va_end(argptr);
	//AfxMessageBox(bufferline);
d56 1
a56 1
		theApp.emuledlg->AddLogText(addtostatusbar, bufferline,true);	//Cax2 - debug log and normal log handled by the same subroutine now
@


1.1
log
@mixin class for adding logging functionality to other classes
@
text
@d36 1
a36 1
		theApp.emuledlg->AddDebugLogText(addtostatusbar, bufferline);
@

