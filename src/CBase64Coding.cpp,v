head	1.3;
access;
symbols
	PublicRelease_1_2e:1.3
	Interim_Release_1-2e_RC1:1.3
	PublicRelease_1_2d:1.3
	Interim_Release_1-2d_RC1:1.3
	Interim_Release_1-2d_beta1:1.3
	PublicRelease_1_2c:1.2
	Interim_Release_1-2c_RC1:1.2
	Interim_Release_1-2c_beta1:1.2
	PublicRelease_1_2b:1.2
	Interim_Release_1-2b_RC1:1.2
	PublicRelease_1_2a:1.2
	Interim_Release_1-2a_RC1:1.2
	Interim_Release_1-2a_beta2:1.2
	Interim_Release_1-2a_beta1:1.2
	PublicRelease_1_2:1.2
	Interim_Release_1-2_RC1:1.2
	Interim_Release_1-2_beta1:1.2
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	Interim_Release_1n_beta2:1.2
	Interim_Release_1n_beta1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.14
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.12
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.10
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.8
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.3
	proxytest:1.1.2.2.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@// @;


1.3
date	2008.02.12.04.37.04;	author aw3;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.25.01.09.10;	author dongato;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.15.36.57;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.01.28.22.27.07;	author maverick65;	state Exp;
branches
	1.1.2.2.2.1;
next	1.1.2.3;

1.1.2.3
date	2003.01.29.10.36.29;	author cax2;	state Exp;
branches;
next	;

1.1.2.2.2.1
date	2003.01.28.23.51.14;	author maverick65;	state Exp;
branches;
next	1.1.2.2.2.2;

1.1.2.2.2.2
date	2003.01.29.00.10.35;	author maverick65;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Corrected Unicode related warning.
@
text
@#include "stdafx.h"
#include "CBase64Coding.hpp"
#pragma hdrstop

#define CARRIAGE_RETURN (13)
#define LINE_FEED       (10)

/*
** Author: Samuel R. Blackburn
** Internet: wfc@@pobox.com
**
** You can use it any way you like as long as you don't try to sell it.
**
** Any attempt to sell WFC in source code form must have the permission
** of the original author. You can produce commercial executables with
** WFC but you can't sell WFC.
**
** Copyright, 2000, Samuel R. Blackburn
**
** $Workfile: CBase64Coding.cpp $
** $Revision: 1.2 $
** $Modtime: 5/12/00 3:39p $
** $Reuse Tracing Code: 1 $
*/

//Modified for use with CAsyncProxySocket, removed tracing code

#if defined( _DEBUG ) && ! defined( WFC_STL )
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define END_OF_BASE64_ENCODED_DATA           ('=')
#define BASE64_END_OF_BUFFER                 (0xFD)
#define BASE64_IGNORABLE_CHARACTER           (0xFE)
#define BASE64_UNKNOWN_VALUE                 (0xFF)
#define BASE64_NUMBER_OF_CHARACTERS_PER_LINE (72)

static inline BYTE __get_character( const BYTE * buffer, const BYTE * decoder_table, int& index, int size_of_buffer )
{
   BYTE return_value = 0;

   do
   {
      if ( index >= size_of_buffer )
      {
         return( BASE64_END_OF_BUFFER );
      }

      return_value = buffer[ index ];
      index++;
   }
   while( return_value != END_OF_BASE64_ENCODED_DATA &&
          decoder_table[ return_value ] == BASE64_IGNORABLE_CHARACTER );

   return( return_value );
}

CBase64Coding::CBase64Coding()
{
}

CBase64Coding::~CBase64Coding()
{
}

BOOL CBase64Coding::Encode( const char * source, int len, char * destination_string )
{

   const char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

   int loop_index                = 0;
   int number_of_bytes_to_encode = len;

   BYTE byte_to_add = 0;
   BYTE byte_1      = 0;
   BYTE byte_2      = 0;
   BYTE byte_3      = 0;

   DWORD number_of_bytes_encoded = (DWORD) ( (double) number_of_bytes_to_encode / (double) 0.75 ) + 1;

   // Now add in the CR/LF pairs, each line is truncated at 72 characters

   // 2000-05-12
   // Thanks go to Ilia Golubev (ilia@@varicom.co.il) for finding a bug here.
   // I was using number_of_bytes_to_encode rather than number_of_bytes_encoded.

   number_of_bytes_encoded += (DWORD)( ( ( number_of_bytes_encoded / BASE64_NUMBER_OF_CHARACTERS_PER_LINE ) + 1 ) * 2 );

   char * destination = destination_string;

   number_of_bytes_encoded = 0;

   while( loop_index < number_of_bytes_to_encode )
   {
      // Output the first byte

      byte_1 = source[ loop_index ];
      byte_to_add = alphabet[ ( byte_1 >> 2 ) ];

      destination[ number_of_bytes_encoded ] = static_cast< char >( byte_to_add );
      number_of_bytes_encoded++;

      loop_index++;

      if ( loop_index >= number_of_bytes_to_encode )
      {
         // We're at the end of the data to encode

         byte_2 = 0;
         byte_to_add = alphabet[ ( ( ( byte_1 & 0x03 ) << 4 ) | ( ( byte_2 & 0xF0 ) >> 4 ) ) ];

         destination[ number_of_bytes_encoded ] = byte_to_add;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] =  END_OF_BASE64_ENCODED_DATA;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] =  END_OF_BASE64_ENCODED_DATA;

         // 1999-09-01
         // Thanks go to Yurong Lin (ylin@@dial.pipex.com) for finding a bug here.
         // We must NULL terminate the string before letting CString have the buffer back.

         destination[ number_of_bytes_encoded + 1 ] = 0;

         return( TRUE );
      }
      else
      {
         byte_2 = source[ loop_index ];
      }

      byte_to_add = alphabet[ ( ( ( byte_1 & 0x03 ) << 4 ) | ( ( byte_2 & 0xF0 ) >> 4 ) ) ];

      destination[ number_of_bytes_encoded ] = byte_to_add;
      number_of_bytes_encoded++;

      loop_index++;

      if ( loop_index >= number_of_bytes_to_encode )
      {
         // We ran out of bytes, we need to add the last half of byte_2 and pad
         byte_3 = 0;

         byte_to_add = alphabet[ ( ( ( byte_2 & 0x0F ) << 2 ) | ( ( byte_3 & 0xC0 ) >> 6 ) ) ];

         destination[ number_of_bytes_encoded ] = byte_to_add;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] = END_OF_BASE64_ENCODED_DATA;

         // 1999-09-01
         // Thanks go to Yurong Lin (ylin@@dial.pipex.com) for finding a bug here.
         // We must NULL terminate the string before letting CString have the buffer back.

         destination[ number_of_bytes_encoded + 1 ] = 0;

         return( TRUE );
      }
      else
      {
         byte_3 = source[ loop_index ];
      }

      loop_index++;

      byte_to_add = alphabet[ ( ( ( byte_2 & 0x0F ) << 2 ) | ( ( byte_3 & 0xC0 ) >> 6 ) ) ];

      destination[ number_of_bytes_encoded ] = byte_to_add;
      number_of_bytes_encoded++;

      byte_to_add = alphabet[ ( byte_3 & 0x3F ) ];

      destination[ number_of_bytes_encoded ] = byte_to_add;
      number_of_bytes_encoded++;

      if ( ( number_of_bytes_encoded % BASE64_NUMBER_OF_CHARACTERS_PER_LINE ) == 0 )
      {
         destination[ number_of_bytes_encoded ] = CARRIAGE_RETURN;
         number_of_bytes_encoded++;

         destination[ number_of_bytes_encoded ] = LINE_FEED;
         number_of_bytes_encoded++;
      }
   }

   destination[ number_of_bytes_encoded ] = END_OF_BASE64_ENCODED_DATA;

   // 1999-09-01
   // Thanks go to Yurong Lin (ylin@@dial.pipex.com) for finding a bug here.
   // We must NULL terminate the string before letting CString have the buffer back.

   destination[ number_of_bytes_encoded + 1 ] = 0;

   return( TRUE );
}

// End of source

#if 0
<HTML>

<HEAD>
<TITLE>WFC - CBase64Coding</TITLE>
<META name="keywords" content="WFC, MFC extension library, freeware class library, Win32, MIME encoding, base 64, source code">
<META name="description" content="This C++ class let's you MIME encode bytes to text using base64.">
</HEAD>

<BODY>

<H1>CBase64Coding</H1>

$Revision: 1.2 $<BR><HR>

<H2>Description</H2>

This class gives you the ability to encode/decode data using base64.

<H2>Constructors</H2>

<DL COMPACT>

<DT><PRE><B>CBase64Coding</B>()<DD>
Constructs this object.

</DL>

<H2>Methods</H2>

<DL COMPACT>

<DT><PRE>BOOL <B><A NAME="Decode">Decode</A></B>( const CByteArray&amp; source, CByteArray&amp; destination )
BOOL <B>Decode</B>( const CString&amp;    source, CByteArray&amp; destination )</PRE><DD>
This method takes base64 encoded text and produces the bytes. It decodes
the base64 encoding.

<DT><PRE>BOOL <B><A NAME="Encode">Encode</A></B>( const CByteArray&amp; source, CByteArray&amp; destination )
BOOL <B>Encode</B>( const CByteArray&amp; source, CString&amp;    destination )</PRE><DD>
This method takes bytes and turns them into base64 text.

</DL>

<H2>Example</H2>
<PRE><CODE>#include &lt;wfc.h&gt;

int _tmain( int number_of_command_line_arguments, LPCTSTR command_line_arguments[] )
{
   <A HREF="WfcTrace.htm">WFCTRACEINIT</A>( TEXT( &quot;_tmain()&quot; ) );

   CByteArray bytes;

   get_file_contents( command_line_arguments[ 0 ], bytes );

   <B>CBase64Coding</B> encoder;

   CString encoded_data;

   if ( encoder.Encode( bytes, encoded_data ) != FALSE )
   {
      _tprintf( TEXT( &quot;%s\n&quot;, (LPCTSTR) encoded_data );
   }
}</CODE></PRE>
<HR><I>Copyright, 2000, <A HREF="mailto:wfc@@pobox.com">Samuel R. Blackburn</A></I><BR>
$Workfile: CBase64Coding.cpp $<BR>
$Modtime: 5/12/00 3:39p $
</BODY>

</HTML>
#endif
@


1.2
log
@Empy Incoming dir for category fix, Official fix [Katsyonak], WS templates updated for file status icons.
@
text
@d21 1
a21 1
** $Revision: 14 $
d30 1
a30 1
static char THIS_FILE[] = __FILE__;
d32 1
a32 1
#endif // _DEBUG
d102 1
a102 1
      destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( byte_to_add );
d215 1
a215 1
$Revision: 14 $<BR><HR>
@


1.1
log
@Maverick's proxy support
@
text
@a61 1
   m_DecoderTable[ 0 ] = 0x00;
d68 1
a68 486
void CBase64Coding::m_InitializeDecoderTable( void )
{

   // Fill the table with an invalid value. If the decoder receives
   // this value as a result of a lookup, it knows that the input
   // character must have been an invalid one.

   ::memset( m_DecoderTable, BASE64_UNKNOWN_VALUE, sizeof( m_DecoderTable ) );

   // Now let's fill the table with translatable values
   // The table is loaded with table[ ASCII_VALUE ] = TRANSLATED_VALUE

    m_DecoderTable[  43 ] = 62;
    m_DecoderTable[  47 ] = 63;
    m_DecoderTable[  48 ] = 52;
    m_DecoderTable[  49 ] = 53;
    m_DecoderTable[  50 ] = 54;
    m_DecoderTable[  51 ] = 55;
    m_DecoderTable[  52 ] = 56;
    m_DecoderTable[  53 ] = 57;
    m_DecoderTable[  54 ] = 58;
    m_DecoderTable[  55 ] = 59;
    m_DecoderTable[  56 ] = 60;
    m_DecoderTable[  57 ] = 61;
    m_DecoderTable[  65 ] = 0;
    m_DecoderTable[  66 ] = 1;
    m_DecoderTable[  67 ] = 2;
    m_DecoderTable[  68 ] = 3;
    m_DecoderTable[  69 ] = 4;
    m_DecoderTable[  70 ] = 5;
    m_DecoderTable[  71 ] = 6;
    m_DecoderTable[  72 ] = 7;
    m_DecoderTable[  73 ] = 8;
    m_DecoderTable[  74 ] = 9;
    m_DecoderTable[  75 ] = 10;
    m_DecoderTable[  76 ] = 11;
    m_DecoderTable[  77 ] = 12;
    m_DecoderTable[  78 ] = 13;
    m_DecoderTable[  79 ] = 14;
    m_DecoderTable[  80 ] = 15;
    m_DecoderTable[  81 ] = 16;
    m_DecoderTable[  82 ] = 17;
    m_DecoderTable[  83 ] = 18;
    m_DecoderTable[  84 ] = 19;
    m_DecoderTable[  85 ] = 20;
    m_DecoderTable[  86 ] = 21;
    m_DecoderTable[  87 ] = 22;
    m_DecoderTable[  88 ] = 23;
    m_DecoderTable[  89 ] = 24;
    m_DecoderTable[  90 ] = 25;
    m_DecoderTable[  97 ] = 26;
    m_DecoderTable[  98 ] = 27;
    m_DecoderTable[  99 ] = 28;
    m_DecoderTable[ 100 ] = 29;
    m_DecoderTable[ 101 ] = 30;
    m_DecoderTable[ 102 ] = 31;
    m_DecoderTable[ 103 ] = 32;
    m_DecoderTable[ 104 ] = 33;
    m_DecoderTable[ 105 ] = 34;
    m_DecoderTable[ 106 ] = 35;
    m_DecoderTable[ 107 ] = 36;
    m_DecoderTable[ 108 ] = 37;
    m_DecoderTable[ 109 ] = 38;
    m_DecoderTable[ 110 ] = 39;
    m_DecoderTable[ 111 ] = 40;
    m_DecoderTable[ 112 ] = 41;
    m_DecoderTable[ 113 ] = 42;
    m_DecoderTable[ 114 ] = 43;
    m_DecoderTable[ 115 ] = 44;
    m_DecoderTable[ 116 ] = 45;
    m_DecoderTable[ 117 ] = 46;
    m_DecoderTable[ 118 ] = 47;
    m_DecoderTable[ 119 ] = 48;
    m_DecoderTable[ 120 ] = 49;
    m_DecoderTable[ 121 ] = 50;
    m_DecoderTable[ 122 ] = 51;

    // OK, there's our translation table, now let's be a little
    // forgiving about end-of-lines, tabs, spaces, etc.

    m_DecoderTable[ 9               ] = BASE64_IGNORABLE_CHARACTER; // TAB character (Tabs suck!)
    m_DecoderTable[ 32              ] = BASE64_IGNORABLE_CHARACTER; // Space character
    m_DecoderTable[ CARRIAGE_RETURN ] = BASE64_IGNORABLE_CHARACTER;
    m_DecoderTable[ LINE_FEED       ] = BASE64_IGNORABLE_CHARACTER;
}

BOOL CBase64Coding::Decode( const CByteArray& source, CByteArray& destination )
{

   if ( m_DecoderTable[ 0 ] == 0x00 )
   {
      m_InitializeDecoderTable();
   }

   BOOL return_value = FALSE;

   BYTE byte_to_add = 0;
   BYTE character_1 = 0;
   BYTE character_2 = 0;
   BYTE character_3 = 0;
   BYTE character_4 = 0;

   int index                     = 0;
   int number_of_bytes_to_decode = source.GetSize();

   DWORD add_index = (DWORD) ( (double) number_of_bytes_to_decode * (double) 0.75 ) + 1;

   destination.SetSize( add_index );
   add_index = 0;

   // Since we're decoding, we are most likely in a performance-minded
   // part of an application, let's go for a speedy method for accessing
   // the source data.

   const BYTE * input_buffer = source.GetData();

   while( index < number_of_bytes_to_decode )
   {
      character_1 = __get_character( input_buffer, m_DecoderTable, index, number_of_bytes_to_decode );

      if ( character_1 != END_OF_BASE64_ENCODED_DATA )
      {
         if ( m_DecoderTable[ character_1 ] == BASE64_UNKNOWN_VALUE )
         {
            destination.RemoveAll();
            return( FALSE );
         }

         character_2 = __get_character( input_buffer, m_DecoderTable, index, number_of_bytes_to_decode );

         if ( character_2 != END_OF_BASE64_ENCODED_DATA )
         {
            if ( m_DecoderTable[ character_2 ] == BASE64_UNKNOWN_VALUE )
            {
               destination.RemoveAll();
               return( FALSE );
            }

            character_3 = __get_character( input_buffer, m_DecoderTable, index, number_of_bytes_to_decode );

            if ( character_3 != END_OF_BASE64_ENCODED_DATA )
            {
               if ( m_DecoderTable[ character_3 ] == BASE64_UNKNOWN_VALUE )
               {
                  destination.RemoveAll();
                  return( FALSE );
               }

               character_4 = __get_character( input_buffer, m_DecoderTable, index, number_of_bytes_to_decode );

               if ( character_4 != END_OF_BASE64_ENCODED_DATA )
               {
                  if ( m_DecoderTable[ character_4 ] == BASE64_UNKNOWN_VALUE )
                  {
                     destination.RemoveAll();
                     return( FALSE );
                  }
               }

               if ( character_2 == BASE64_END_OF_BUFFER ||
                    character_3 == BASE64_END_OF_BUFFER ||
                    character_4 == BASE64_END_OF_BUFFER )
               { 
                  destination.RemoveAll();
                  return( FALSE );
               }
            }
            else
            {
               character_4 = END_OF_BASE64_ENCODED_DATA;
            }
         }
         else
         {
            character_3 = END_OF_BASE64_ENCODED_DATA;
            character_4 = END_OF_BASE64_ENCODED_DATA;
         }
      }
      else
      {
         character_2 = END_OF_BASE64_ENCODED_DATA;
         character_3 = END_OF_BASE64_ENCODED_DATA;
         character_4 = END_OF_BASE64_ENCODED_DATA;
      }

      if ( character_1 == END_OF_BASE64_ENCODED_DATA ||
           character_2 == END_OF_BASE64_ENCODED_DATA )
      {
         destination.SetSize( add_index );
         return( TRUE );
      }

      character_1 = m_DecoderTable[ character_1 ];
      character_2 = m_DecoderTable[ character_2 ];

      byte_to_add = static_cast< BYTE>( ( ( character_1 << 2 ) | ( ( character_2 & 0x30 ) >> 4 ) ) );

      destination.SetAt( add_index, byte_to_add );
      add_index++;

      if ( character_3 == END_OF_BASE64_ENCODED_DATA )
      {
         destination.SetSize( add_index );
         return( TRUE );
      }

      character_3 = m_DecoderTable[ character_3 ];

      byte_to_add = static_cast< BYTE >( ( ( ( ( character_2 & 0x0F ) << 4 ) | ( ( character_3 & 0x3C ) >> 2 ) ) ) );

      destination.SetAt( add_index, byte_to_add );
      add_index++;

      if ( character_4 == END_OF_BASE64_ENCODED_DATA )
      {
         destination.SetSize( add_index );
         return( TRUE );
      }

      character_4 = m_DecoderTable[ character_4 ];

      byte_to_add = static_cast< BYTE >( ( ( ( character_3 & 0x03 ) << 6 ) | character_4 ) );

      destination.SetAt( add_index, byte_to_add );
      add_index++;
   }

   destination.SetSize( add_index );

   return( return_value );
}

BOOL CBase64Coding::Decode( const CString& source, CByteArray& destination )
{

   if ( m_DecoderTable[ 0 ] == 0x00 )
   {
      m_InitializeDecoderTable();
   }

   BOOL return_value = FALSE;

   BYTE byte_to_add = 0;
   BYTE character_1 = 0;
   BYTE character_2 = 0;
   BYTE character_3 = 0;
   BYTE character_4 = 0;

   int index                     = 0;
   int number_of_bytes_to_decode = source.GetLength();

   DWORD add_index = (DWORD) ( (double) number_of_bytes_to_decode * (double) 0.75 ) + 1;

   destination.SetSize( add_index );
   add_index = 0;

   // Since we're decoding, we are most likely in a performance-minded
   // part of an application, let's go for a speedy method for accessing
   // the source data.

   LPCTSTR input_buffer = source;

   while( index < number_of_bytes_to_decode )
   {
      character_1 = __get_character( reinterpret_cast< const BYTE * >( input_buffer ), m_DecoderTable, index, number_of_bytes_to_decode );

      if ( character_1 != END_OF_BASE64_ENCODED_DATA )
      {
         if ( m_DecoderTable[ character_1 ] == BASE64_UNKNOWN_VALUE )
         {
            destination.RemoveAll();
            return( FALSE );
         }

         character_2 = __get_character( reinterpret_cast< const BYTE * >( input_buffer ), m_DecoderTable, index, number_of_bytes_to_decode );

         if ( character_2 != END_OF_BASE64_ENCODED_DATA )
         {
            if ( m_DecoderTable[ character_2 ] == BASE64_UNKNOWN_VALUE )
            {
               destination.RemoveAll();
               return( FALSE );
            }

            character_3 = __get_character( reinterpret_cast< const BYTE * >( input_buffer ), m_DecoderTable, index, number_of_bytes_to_decode );

            if ( character_3 != END_OF_BASE64_ENCODED_DATA )
            {
               if ( m_DecoderTable[ character_3 ] == BASE64_UNKNOWN_VALUE )
               {
                  destination.RemoveAll();
                  return( FALSE );
               }

               character_4 = __get_character( reinterpret_cast< const BYTE * >( input_buffer ), m_DecoderTable, index, number_of_bytes_to_decode );

               if ( character_4 != END_OF_BASE64_ENCODED_DATA )
               {
                  if ( m_DecoderTable[ character_4 ] == BASE64_UNKNOWN_VALUE )
                  {
                     destination.RemoveAll();
                     return( FALSE );
                  }
               }

               if ( character_2 == BASE64_END_OF_BUFFER ||
                    character_3 == BASE64_END_OF_BUFFER ||
                    character_4 == BASE64_END_OF_BUFFER )
               { 
                  destination.RemoveAll();
                  return( FALSE );
               }
            }
            else
            {
               character_4 = END_OF_BASE64_ENCODED_DATA;
            }
         }
         else
         {
            character_3 = END_OF_BASE64_ENCODED_DATA;
            character_4 = END_OF_BASE64_ENCODED_DATA;
         }
      }
      else
      {
         character_2 = END_OF_BASE64_ENCODED_DATA;
         character_3 = END_OF_BASE64_ENCODED_DATA;
         character_4 = END_OF_BASE64_ENCODED_DATA;
      }

      if ( character_1 == END_OF_BASE64_ENCODED_DATA ||
           character_2 == END_OF_BASE64_ENCODED_DATA )
      {
         destination.SetSize( add_index );
         return( TRUE );
      }

      character_1 = m_DecoderTable[ character_1 ];
      character_2 = m_DecoderTable[ character_2 ];

      byte_to_add = static_cast< BYTE>( ( ( character_1 << 2 ) | ( ( character_2 & 0x30 ) >> 4 ) ) );

      destination.SetAt( add_index, byte_to_add );
      add_index++;

      if ( character_3 == END_OF_BASE64_ENCODED_DATA )
      {
         destination.SetSize( add_index );
         return( TRUE );
      }

      character_3 = m_DecoderTable[ character_3 ];

      byte_to_add = static_cast< BYTE >( ( ( ( ( character_2 & 0x0F ) << 4 ) | ( ( character_3 & 0x3C ) >> 2 ) ) ) );

      destination.SetAt( add_index, byte_to_add );
      add_index++;

      if ( character_4 == END_OF_BASE64_ENCODED_DATA )
      {
         destination.SetSize( add_index );
         return( TRUE );
      }

      character_4 = m_DecoderTable[ character_4 ];

      byte_to_add = static_cast< BYTE >( ( ( ( character_3 & 0x03 ) << 6 ) | character_4 ) );

      destination.SetAt( add_index, byte_to_add );
      add_index++;
   }

   destination.SetSize( add_index );

   return( return_value );
}

BOOL CBase64Coding::Encode( const CByteArray& source, CByteArray& destination )
{

   // We don't want to make this static so we can reduce our
   // footprint in the library

   const char alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

   int source_index              = 0;
   int number_of_bytes_to_encode = source.GetSize();
   
   BYTE byte_to_add = 0;
   BYTE byte_1      = 0;
   BYTE byte_2      = 0;
   BYTE byte_3      = 0;

   const BYTE * input_buffer = source.GetData();

   DWORD add_index = (DWORD) ( (double) number_of_bytes_to_encode / (double) 0.75 ) + 1;
   add_index += ( ( number_of_bytes_to_encode % 3 ) + 1 );

   destination.SetSize( add_index );
   add_index = 0;

   while( source_index < number_of_bytes_to_encode )
   {
      // Output the first byte

      byte_1 = input_buffer[ source_index ];
      byte_to_add = alphabet[ ( byte_1 >> 2 ) ];

      destination.SetAt( add_index, byte_to_add );
      add_index++;

      source_index++;

      if ( source_index >= number_of_bytes_to_encode )
      {
         // We're at the end of the data to encode

         byte_2 = 0;
         byte_to_add = alphabet[ ( ( ( byte_1 & 0x03 ) << 4 ) | ( ( byte_2 & 0xF0 ) >> 4 ) ) ];

         destination.SetAt( add_index, byte_to_add );
         add_index++;

         destination.SetAt( add_index, END_OF_BASE64_ENCODED_DATA );
         add_index++;

         destination.SetAt( add_index, END_OF_BASE64_ENCODED_DATA );
         add_index++;

         destination.SetSize( add_index );
         return( TRUE );
      }
      else
      {
         byte_2 = input_buffer[ source_index ];
      }

      byte_to_add = alphabet[ ( ( ( byte_1 & 0x03 ) << 4 ) | ( ( byte_2 & 0xF0 ) >> 4 ) ) ];
      destination.SetAt( add_index, byte_to_add );
      add_index++;

      source_index++;

      if ( source_index >= number_of_bytes_to_encode )
      {
         // We ran out of bytes, we need to add the last half of byte_2 and pad
         byte_3 = 0;

         byte_to_add = alphabet[ ( ( ( byte_2 & 0x0F ) << 2 ) | ( ( byte_3 & 0xC0 ) >> 6 ) ) ];

         destination.SetAt( add_index, byte_to_add );
         add_index++;

         destination.SetAt( add_index, END_OF_BASE64_ENCODED_DATA );
         add_index++;

         destination.SetSize( add_index );
         return( TRUE );
      }
      else
      {
         byte_3 = input_buffer[ source_index ];
      }

      source_index++;

      byte_to_add = alphabet[ ( ( ( byte_2 & 0x0F ) << 2 ) | ( ( byte_3 & 0xC0 ) >> 6 ) ) ];

      destination.SetAt( add_index, byte_to_add );
      add_index++;

      byte_to_add = alphabet[ ( byte_3 & 0x3F ) ];

      destination.SetAt( add_index, byte_to_add );
      add_index++;
   }

   destination.SetAt( add_index, END_OF_BASE64_ENCODED_DATA );
   add_index++;

   destination.SetSize( add_index );
   return( TRUE );
}

BOOL CBase64Coding::Encode( const CByteArray& source, CString& destination_string )
d74 1
a74 1
   int number_of_bytes_to_encode = source.GetSize();
a80 2
   const BYTE * input_buffer = source.GetData();

d91 1
a91 1
   LPTSTR destination = destination_string.GetBuffer( number_of_bytes_encoded );
d99 1
a99 1
      byte_1 = input_buffer[ loop_index ];
d114 1
a114 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( byte_to_add );
d117 1
a117 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( END_OF_BASE64_ENCODED_DATA );
d120 1
a120 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( END_OF_BASE64_ENCODED_DATA );
a127 2
         destination_string.ReleaseBuffer( -1 );

d132 1
a132 1
         byte_2 = input_buffer[ loop_index ];
d137 1
a137 1
      destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( byte_to_add );
d149 1
a149 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( byte_to_add );
d152 1
a152 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( END_OF_BASE64_ENCODED_DATA );
a159 2
         destination_string.ReleaseBuffer( -1 );

d164 1
a164 1
         byte_3 = input_buffer[ loop_index ];
d171 1
a171 1
      destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( byte_to_add );
d176 1
a176 1
      destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( byte_to_add );
d181 1
a181 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( CARRIAGE_RETURN );
d184 1
a184 1
         destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( LINE_FEED );
d189 1
a189 1
   destination[ number_of_bytes_encoded ] = static_cast< TCHAR >( END_OF_BASE64_ENCODED_DATA );
a195 2

   destination_string.ReleaseBuffer( -1 );
@


1.1.2.1
log
@updating this branch...
@
text
@d21 1
a21 1
** $Revision: 1.1 $
d709 1
a709 1
$Revision: 1.1 $<BR><HR>
@


1.1.2.2
log
@Merges from main thread
@
text
@@


1.1.2.3
log
@Restored obaldin's version. NO MERGE on these files!!!!!!!
@
text
@d21 1
a21 1
** $Revision: 1.1.2.1 $
d709 1
a709 1
$Revision: 1.1.2.1 $<BR><HR>
@


1.1.2.2.2.1
log
@Merged Proxy code
@
text
@@


1.1.2.2.2.2
log
@Merged Proxy
@
text
@@


