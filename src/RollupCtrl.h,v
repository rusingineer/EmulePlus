head	1.9;
access;
symbols
	PublicRelease_1_2e:1.9
	Interim_Release_1-2e_RC1:1.9
	PublicRelease_1_2d:1.9
	Interim_Release_1-2d_RC1:1.9
	Interim_Release_1-2d_beta1:1.9
	PublicRelease_1_2c:1.8
	Interim_Release_1-2c_RC1:1.8
	Interim_Release_1-2c_beta1:1.8
	PublicRelease_1_2b:1.8
	Interim_Release_1-2b_RC1:1.8
	PublicRelease_1_2a:1.5
	Interim_Release_1-2a_RC1:1.5
	Interim_Release_1-2a_beta2:1.5
	Interim_Release_1-2a_beta1:1.5
	PublicRelease_1_2:1.5
	Interim_Release_1-2_RC1:1.5
	Interim_Release_1-2_beta1:1.5
	PublicRelease_1_1g:1.5
	Interim_Release_1-1g_RC3:1.5
	Interim_Release_1-1g_RC2:1.5
	Interim_Release_1-1g_RC1:1.5
	Interim_Release_1-1g_beta2:1.5
	Interim_Release_1-1g_beta1:1.5
	PublicRelease_1_1f:1.5
	Interim_Release_1-1f_RC1:1.5
	PublicRelease_1_1e:1.5
	Interim_Release_1-1e_RC2:1.5
	Interim_Release_1-1e_RC1:1.5
	Interim_Release_1-1e_beta1:1.5
	PublicRelease_1_1d:1.5
	Interim_Release_1-1d_RC1:1.5
	PublicRelease_1_1c:1.5
	Interim_Release_1-1c_RC1:1.5
	Interim_Release_1-1c_beta2:1.5
	Interim_Release_1-1c_beta1:1.5
	PublicRelease_1_1b:1.5
	Interim_Release_1-1b_RC1:1.5
	PublicRelease_1_1a:1.5
	Interim_Release_1-1a_RC2:1.5
	Interim_Release_1-1a_RC1:1.5
	Interim_Release_1-1a_beta2:1.5
	Interim_Release_1-1a_beta1:1.5
	PublicRelease_1_1:1.5
	Interim_Release_1-1_beta1:1.5
	PublicRelease_1o:1.5
	Interim_Release_1o_RC1:1.5
	Interim_Release_1o_beta1:1.5
	PublicRelease_1n:1.5
	Interim_Release_1n_RC2:1.5
	Interim_Release_1n_RC1:1.5
	Interim_Release_1n_beta2:1.5
	Interim_Release_1n_beta1:1.5
	PublicRelease_1m:1.5
	Interim_Release_1m_beta1:1.5
	PublicRelease_1l:1.5
	Interim_Release_1l_RC3:1.5
	Interim_Release_1l_RC2:1.5
	Interim_Release_1l_RC1:1.5
	Interim_Release_1l_beta2:1.5
	Interim_Release_1l_beta1:1.4
	PublicRelease_1k:1.4
	Interim_Release_1k_RC4:1.4
	Interim_1k_RC3:1.4
	Interim_1k_RC2:1.4
	Interim_Release_1k_RC1:1.4
	Interim_Release_1k_beta5:1.4
	Intrerim_Release_1k_beta4:1.4
	Interim_Release_1k_beta1:1.4
	PublicRelease_1j:1.4
	Interim_Release_1J_RC3:1.4
	Interim_Release_1j_RC3:1.4
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.4
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.4
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.3
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.9
date	2007.12.19.04.53.43;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2007.01.08.00.01.59;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2007.01.07.20.31.47;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.06.19.59.16;	author eklmn;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.11.02.47.55;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Reduced H-file dependency; Formatting and clean-up;
Slightly better memory allocation strategy; Some generic optimization.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// CRollupCtrl & CRollupHeader
// (c) 2002 by FoRcHa (a.k.a. NO)  [seppforcher38@@hotmail.com]
//
// I would appreciate a notification of any bugs or bug fixes to help the control grow.
///////////////////////////////////////////////////////////////////////////////////////////
#pragma once

#define USRMSG_STATECHANGED		WM_USER + 1
#define USRMSG_RIGHTCLICK		WM_USER + 3

#define RUP_HEADERHEIGHT	22
#define RUP_BORDERSIZES		 7
#define RUP_ENTRYMINHEIGHT	40

class CRollupGripper;

/////////////////////////////////////////////////////////////////////////////
// CRollupHeader window
class CRollupHeader : public CWnd
{
public:
	CRollupHeader();
	virtual ~CRollupHeader();

	bool IsExpanded() const
	{
		return m_bExpanded;
	}
	void Expand(bool bExpand = false, bool bInvalidate = true)
	{
		m_bExpanded = bExpand;
		if(m_hWnd && bInvalidate)
			Invalidate();
	}
	void SetLeftText(const CString &strLeftText)
	{
		m_strLeftText = strLeftText;
		if(m_hWnd)
			Invalidate();
	}
	void SetRightText(const CString &strRightText)
	{
		m_strRightText = strRightText;
		if(m_hWnd)
			Invalidate();
	}
	void SetHeight(int iHeight)
	{
		m_iHeight = iHeight;
	}
	void SetBackColor(COLORREF crBackColor)
	{
		m_crBackColor = crBackColor;
	}
	void SetTextColor(COLORREF crTextColor)
	{
		m_crTextColor = crTextColor;
	}
	void SetBorderColor(COLORREF crBorderColor)
	{
		m_crBorderColor = crBorderColor;
	}

protected:
	COLORREF m_crBackColor;
	COLORREF m_crTextColor;
	COLORREF m_crBorderColor;

	CFont	m_cfTextFont;
	CPen	m_cpBorderPen;
	CPen	m_cpArrowPen;

	CString	m_strLeftText;
	CString	m_strRightText;

	CDC		m_MemDC;
	CBitmap	m_MemBMP;
	CBitmap	*m_pOldMemBMP;

	CRect	m_rClientRect;
	CRect	m_rTextRect;
	CRect	m_rArrowRect;
	CPoint	m_cpArrowPoint;

	int		m_iHeight;
	bool	m_bInit;
	bool	m_bExpanded;

	void CreateMemDC(CDC *pDC, const CRect *pRect)
	{
		if(m_pOldMemBMP && m_MemDC.m_hDC)
		{
			m_MemDC.SelectObject(m_pOldMemBMP);
			m_pOldMemBMP = NULL;
		}
		if(m_MemDC.m_hDC)
			m_MemDC.DeleteDC();
		m_MemDC.CreateCompatibleDC(pDC);
		if(m_MemBMP.m_hObject)
			m_MemBMP.DeleteObject();
		m_MemBMP.CreateCompatibleBitmap(pDC, pRect->Width(), pRect->Height());
		m_pOldMemBMP = m_MemDC.SelectObject(&m_MemBMP);
	}

	void DrawArrow(CDC* pDC, const CPoint* pTopLeft, bool bDown);

	afx_msg void OnPaint();
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnSysColorChange();
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);

	DECLARE_MESSAGE_MAP()
};

typedef struct
{
	double			adSizes[8];
	CRollupHeader	*pHeader;
	CRollupGripper	*pGripper;
	CWnd			*pClient;
	int				iMinHeight;
} RollupEntry;

/////////////////////////////////////////////////////////////////////////////
// CRollupCtrl window
class CRollupCtrl : public CWnd
{
public:
	CRollupCtrl();
	virtual ~CRollupCtrl();

	int InsertItem(LPCTSTR strLeft, LPCTSTR strRight, CWnd *pClient,
					int iIndex = -1, bool bExpanded = FALSE);

	int SetItemHeights(int iItem, double *pHeights, unsigned uiSize);
	int SetText(int iItem, const CString &strText, bool bLeft = FALSE);
	int SetHeaderColor(int iItem, int iColor, COLORREF crColor);
	int SetItemClient(int iItem, CWnd *pClient);
	int ExpandItem(int iItem, bool bExpand = TRUE);

	int Recalc(HWND hWnd);
	CWnd* GetItemClient(int iItem);
	RollupEntry* GetItem(int iItem);
	unsigned GetCount() const { return m_List.GetCount(); }

protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	void ChildStateChanged(HWND hChild, bool bInvalidate = true);

	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);

	DECLARE_MESSAGE_MAP()

protected:
	CArray<RollupEntry*, RollupEntry*> m_List;
	int m_iExpandedItems;
	int m_iHeaderHeight;
	int m_iExpandedMsk;	// max. 8 items
};
@


1.8
log
@Some minor correction.
@
text
@d1 16
a21 5

#if !defined(AFX_ROLLUPCTRL_H__D92916B0_C46D_4257_8B0E_2BDB4D420BEE__INCLUDED_)
#define AFX_ROLLUPCTRL_H__D92916B0_C46D_4257_8B0E_2BDB4D420BEE__INCLUDED_

#if _MSC_VER > 1000
a22 5
#endif // _MSC_VER > 1000
// RollupCtrl.h : header file
//

#include "RollupGripper.h"
d31 2
a34 1

a36 1
// Construction
a38 14

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRollupHeader)
	//}}AFX_VIRTUAL

// Implementation
public:
a79 2

	// Generated message map functions
d89 2
a90 2
	CString m_strLeftText;
	CString m_strRightText;
d93 2
a94 2
	CBitmap m_MemBMP;
	CBitmap *m_pOldMemBMP;
a122 1
	//{{AFX_MSG(CRollupHeader)
a125 3
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
public:
d130 2
d134 1
a134 1
typedef struct ROLLUP_STRUCT
d136 1
a139 1
	double			*pSizes;
d141 1
a141 2

}RollupEntry;
a144 1

a146 2

// Construction
d149 1
a150 5
// Attributes
public:

// Operations
public:
d154 1
a154 11
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRollupCtrl)
	public:
	protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	int SetItemHeights(int iItem, double *pHeights, int iCount);
a158 1
	virtual ~CRollupCtrl();
d166 3
a168 4
	CArray<RollupEntry*,RollupEntry*> m_List;
	int m_iExpandedItems;
	int m_iHeaderHeight;
	BYTE m_bExpandedItems;	// max. 8 items
a169 1
	//{{AFX_MSG(CRollupCtrl)
d173 1
a173 1
	//}}AFX_MSG
d175 1
d177 4
a180 2
	void ChildStateChanged(HWND hChild, bool bInvalidate = true);
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
a181 8

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ROLLUPCTRL_H__D92916B0_C46D_4257_8B0E_2BDB4D420BEE__INCLUDED_)
// (p) 2002 by FoRcHa (a.k.a. NO)  [seppforcher38@@hotmail.com]
@


1.7
log
@minor correction for previous changes (thk Aw3) & futher formating
@
text
@d194 1
a194 1
	int GetCount() const { return m_List.GetCount(); }
@


1.6
log
@some optimization & formatting
@
text
@d185 1
a185 1
	int SetText(int iItem, const CString&  strText, bool bLeft = FALSE);
d209 1
a209 1
	void ChildStateChanged(const HWND hChild, bool bInvalidate = true);
@


1.5
log
@Fixed exception during gui.dat saving after failed startup
(before gui.dat was reset to zero size);
Reduced memory used by rollup controls; Minor optimization.
@
text
@d49 1
a49 1
	bool IsExpanded()
d53 1
a53 1
	void Expand(bool bExpand = FALSE, bool bInvalidate = true)
d59 1
a59 1
	void SetLeftText(CString strLeftText)
d65 1
a65 1
	void SetRightText(CString strRightText)
d115 1
a115 1
	void CreateMemDC(CDC *pDC, CRect *pRect)
a119 1
#ifdef _DEBUG
a120 1
#endif
d131 1
a131 1
	void DrawArrow(CDC* pDC, CPoint* pTopLeft, bool bDown);
d184 5
a188 5
	int SetItemHeights(unsigned uiItem, double *pHeights, int iCount);
	int SetText(unsigned uiItem, CString strText, bool bLeft = FALSE);
	int SetHeaderColor(unsigned uiItem, int iColor, COLORREF crColor);
	int SetItemClient(unsigned uiItem, CWnd *pClient);
	int ExpandItem(unsigned uiItem, bool bExpand = TRUE);
d192 3
a194 3
	CWnd* GetItemClient(unsigned uiItem);
	RollupEntry* GetItem(unsigned uiItem);
	unsigned GetCount() const { return m_List.GetCount(); }
d209 1
a209 1
	void ChildStateChanged(HWND hChild, bool bInvalidate = true);
@


1.4
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d94 1
a94 1
		
d98 1
a98 1
	    
d116 1
a116 1
	{		
d118 1
a118 1
		{	
d132 1
a132 1
	
d173 1
a173 1
	int InsertItem(LPCTSTR strLeft, LPCTSTR strRight, CWnd *pClient, 
d186 5
a190 5
	int SetItemHeights(int iItem, double *pHeights, int iCount);
	int SetText(int iItem, CString strText, bool bLeft = FALSE);
	int SetHeaderColor(int iItem, int iColor, COLORREF crColor);
	int SetItemClient(int iItem, CWnd *pClient);
	int ExpandItem(int iItem, bool bExpand = TRUE);
d193 5
a197 1
	// Generated message map functions
d201 1
a202 1
	int m_iHeaderHeight;
a209 4
public:
	int Recalc(HWND hWnd);
	CWnd* GetItemClient(int iItem);
	RollupEntry* GetItem(int iItem);
@


1.3
log
@*** empty log message ***
@
text
@d153 1
a153 1
	float			*pSizes;
d186 1
a186 1
	int SetItemHeights(int iItem, float *pHeights, int iCount);
@


1.2
log
@unicode cleanup
@
text
@d18 2
a19 2
#define USRMSG_STATECHANGED	WM_USER + 1
#define USRMSG_RIGHTCLICK	WM_USER + 3
d145 1
d210 1
a210 2
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
private:
d212 1
@


1.1
log
@*** empty log message ***
@
text
@d172 1
a172 1
	int InsertItem(LPCSTR strLeft, LPCSTR strRight, CWnd *pClient, 
@


1.1.4.1
log
@updating this branch...
@
text
@@

