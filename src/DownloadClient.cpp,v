head	1.399;
access;
symbols
	PublicRelease_1_2e:1.393
	Interim_Release_1-2e_RC1:1.389
	PublicRelease_1_2d:1.382
	Interim_Release_1-2d_RC1:1.382
	Interim_Release_1-2d_beta1:1.381
	PublicRelease_1_2c:1.372
	Interim_Release_1-2c_RC1:1.372
	Interim_Release_1-2c_beta1:1.366
	PublicRelease_1_2b:1.365
	Interim_Release_1-2b_RC1:1.364
	PublicRelease_1_2a:1.357
	Interim_Release_1-2a_RC1:1.357
	Interim_Release_1-2a_beta2:1.349
	Interim_Release_1-2a_beta1:1.340
	PublicRelease_1_2:1.329
	Interim_Release_1-2_RC1:1.329
	Interim_Release_1-2_beta1:1.326
	PublicRelease_1_1g:1.321
	Interim_Release_1-1g_RC3:1.320
	Interim_Release_1-1g_RC2:1.319
	Interim_Release_1-1g_RC1:1.317
	Interim_Release_1-1g_beta2:1.314
	Interim_Release_1-1g_beta1:1.293
	PublicRelease_1_1f:1.287
	Interim_Release_1-1f_RC1:1.287
	PublicRelease_1_1e:1.287
	Interim_Release_1-1e_RC2:1.287
	Interim_Release_1-1e_RC1:1.286
	Interim_Release_1-1e_beta1:1.281
	PublicRelease_1_1d:1.281
	Interim_Release_1-1d_RC1:1.281
	PublicRelease_1_1c:1.281
	Interim_Release_1-1c_RC1:1.281
	Interim_Release_1-1c_beta2:1.281
	Interim_Release_1-1c_beta1:1.281
	PublicRelease_1_1b:1.278
	Interim_Release_1-1b_RC1:1.278
	PublicRelease_1_1a:1.276
	Interim_Release_1-1a_RC2:1.276
	Interim_Release_1-1a_RC1:1.274
	Interim_Release_1-1a_beta2:1.274
	Interim_Release_1-1a_beta1:1.267
	PublicRelease_1_1:1.264
	Interim_Release_1-1_beta1:1.264
	PublicRelease_1o:1.262
	Interim_Release_1o_RC1:1.262
	Interim_Release_1o_beta1:1.261
	PublicRelease_1n:1.259
	Interim_Release_1n_RC2:1.259
	Interim_Release_1n_RC1:1.253
	Interim_Release_1n_beta2:1.239
	Interim_Release_1n_beta1:1.230
	PublicRelease_1m:1.225
	Interim_Release_1m_beta1:1.225
	PublicRelease_1l:1.222
	Interim_Release_1l_RC3:1.221
	Interim_Release_1l_RC2:1.220
	Interim_Release_1l_RC1:1.215
	Interim_Release_1l_beta2:1.209
	Interim_Release_1l_beta1:1.193
	PublicRelease_1k:1.187
	Interim_Release_1k_RC4:1.187
	Interim_1k_RC3:1.186
	Interim_1k_RC2:1.183
	Interim_Release_1k_RC1:1.182
	Interim_Release_1k_beta5:1.178
	Intrerim_Release_1k_beta4:1.178
	Interim_Release_1k_beta1:1.177
	PublicRelease_1j:1.159
	Interim_Release_1J_RC3:1.159
	Interim_Release_1j_RC3:1.159
	Interim_Release_1j_RC2:1.155
	Interim_Release_1j_RC1:1.155
	Interim_Release_1j_beta2:1.155
	Interim_Release_1j_beta1:1.150
	PublicRelease_1i:1.143
	Interim_Release_1i_RC6:1.141
	Interim_Release_1i_RC3:1.137
	Interim_Release_1i_RC2:1.136
	Interim_Release_1i_RC1:1.134
	Interim_Release_1i_beta3:1.133
	Interim_Release_1i_beta2:1.129
	Interim_Release_1i_beta1:1.114
	PublicRelease_1h:1.105
	Interim_Release_1h_rc2:1.105
	Interim_Release_1h_RC1:1.104
	Interim_Release_1h_beta2:1.103
	Interim_Release_1h_beta1_now:1.100
	Interim_Release_1h_beta1:1.100
	PublicRelease_1g:1.94
	Interim_Release_1g_RC6_Final:1.94
	Interim_Release_1g_RC6:1.90
	Interim_Release_1g_RC5:1.87
	Interim_Release_1g_RC4:1.86
	Interim_Release_1g_RC3:1.84
	Interim_Release_1g_beta2:1.66
	Interim_Release_1g_beta1:1.57
	Interim_Release_1f_RC4:1.56
	Interim_Release_1f_RC3:1.55
	Interim_Release_1f_RC2:1.51
	Interim_Release_1f_RC:1.51
	Interim_Release_1f_beta2:1.51
	Interim_Release_1f_beta1:1.48
	PublicRelease_1e:1.47
	Interim_Release_1e_RC2:1.47
	Interim_Release_1e_RC:1.47
	Interim_Release_1e_beta3:1.47
	Interim_Release_1e_beta2:1.46
	Interim_Release_1e_beta2_before_kuchin:1.45
	Interim_Release_1e_beta1:1.45
	PublicRelease_1c:1.38
	featurestest:1.38.0.2
	Interim_Release_1c_RC:1.38
	Interim_Release_1c_beta2:1.37
	Interim_Release_1c_beta1:1.32
	threaded_downloadqueue:1.32.0.2
	PublicRelease_1b:1.29
	Interim_Release_1b_beta2:1.29
	Interim_Release_1b_beta1:1.28
	proxydeadlake:1.24.0.2
	PublicRelease_1a:1.24
	Interim_Release_1a_beta2:1.22
	BerkeleyDb:1.19.0.2
	Interim_Release_1a_beta1:1.19
	PublicRelease_1:1.16
	goldfish:1.16
	eMulePlus_1_RC2:1.15
	eMulePlus_26b_1RC1:1.14
	PreRelease_26b_i0e:1.14
	before_26d_merge:1.13
	Interim_Release_26b_i0d:1.12
	Interim_Release_26b_i0c:1.10
	Interim_Release_26b_i0b:1.10
	Interim_Release_26b_i0a:1.10
	systraydlg:1.9.0.6
	plus26based:1.9.0.4
	Interim_Release_25b_i0b:1.9
	Proxy_Dev:1.9
	Interim_Release_25b_i0a:1.9.2.1
	proxytest:1.9.2.1.0.2
	official_sockets:1.9.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.399
date	2009.10.28.04.34.58;	author aw3;	state Exp;
branches;
next	1.398;

1.398
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.397;

1.397
date	2009.07.15.02.23.05;	author aw3;	state Exp;
branches;
next	1.396;

1.396
date	2009.07.03.04.18.01;	author aw3;	state Exp;
branches;
next	1.395;

1.395
date	2009.06.20.14.26.32;	author aw3;	state Exp;
branches;
next	1.394;

1.394
date	2009.06.14.19.13.17;	author aw3;	state Exp;
branches;
next	1.393;

1.393
date	2009.04.17.05.44.00;	author aw3;	state Exp;
branches;
next	1.392;

1.392
date	2009.04.16.04.11.00;	author aw3;	state Exp;
branches;
next	1.391;

1.391
date	2009.04.15.03.45.21;	author aw3;	state Exp;
branches;
next	1.390;

1.390
date	2009.04.10.03.37.49;	author aw3;	state Exp;
branches;
next	1.389;

1.389
date	2009.03.21.22.47.43;	author aw3;	state Exp;
branches;
next	1.388;

1.388
date	2009.03.01.05.50.14;	author aw3;	state Exp;
branches;
next	1.387;

1.387
date	2009.02.14.03.01.30;	author aw3;	state Exp;
branches;
next	1.386;

1.386
date	2009.01.25.15.09.53;	author aw3;	state Exp;
branches;
next	1.385;

1.385
date	2009.01.18.02.12.15;	author aw3;	state Exp;
branches;
next	1.384;

1.384
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.383;

1.383
date	2008.07.23.04.08.23;	author aw3;	state Exp;
branches;
next	1.382;

1.382
date	2008.03.03.05.25.41;	author aw3;	state Exp;
branches;
next	1.381;

1.381
date	2008.01.23.05.10.47;	author aw3;	state Exp;
branches;
next	1.380;

1.380
date	2007.12.28.04.02.41;	author aw3;	state Exp;
branches;
next	1.379;

1.379
date	2007.12.19.03.17.58;	author aw3;	state Exp;
branches;
next	1.378;

1.378
date	2007.12.16.21.58.23;	author aw3;	state Exp;
branches;
next	1.377;

1.377
date	2007.12.15.13.19.12;	author eklmn;	state Exp;
branches;
next	1.376;

1.376
date	2007.12.12.20.15.31;	author eklmn;	state Exp;
branches;
next	1.375;

1.375
date	2007.12.01.10.38.05;	author eklmn;	state Exp;
branches;
next	1.374;

1.374
date	2007.11.25.18.54.38;	author aw3;	state Exp;
branches;
next	1.373;

1.373
date	2007.10.24.19.09.35;	author fuxie-dk;	state Exp;
branches;
next	1.372;

1.372
date	2007.07.23.12.27.31;	author aw3;	state Exp;
branches;
next	1.371;

1.371
date	2007.07.23.04.35.21;	author aw3;	state Exp;
branches;
next	1.370;

1.370
date	2007.07.08.22.31.18;	author kush_eplus;	state Exp;
branches;
next	1.369;

1.369
date	2007.07.07.04.07.37;	author aw3;	state Exp;
branches;
next	1.368;

1.368
date	2007.06.01.04.49.25;	author aw3;	state Exp;
branches;
next	1.367;

1.367
date	2007.05.27.21.53.03;	author aw3;	state Exp;
branches;
next	1.366;

1.366
date	2007.02.18.16.00.49;	author eklmn;	state Exp;
branches;
next	1.365;

1.365
date	2007.01.30.06.06.16;	author aw3;	state Exp;
branches;
next	1.364;

1.364
date	2007.01.17.07.43.45;	author aw3;	state Exp;
branches;
next	1.363;

1.363
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.362;

1.362
date	2007.01.08.06.01.16;	author aw3;	state Exp;
branches;
next	1.361;

1.361
date	2006.12.02.08.44.00;	author eklmn;	state Exp;
branches;
next	1.360;

1.360
date	2006.11.27.19.59.14;	author eklmn;	state Exp;
branches;
next	1.359;

1.359
date	2006.11.16.05.51.46;	author aw3;	state Exp;
branches;
next	1.358;

1.358
date	2006.11.11.12.17.39;	author eklmn;	state Exp;
branches;
next	1.357;

1.357
date	2006.09.09.19.44.18;	author aw3;	state Exp;
branches;
next	1.356;

1.356
date	2006.08.08.05.49.58;	author aw3;	state Exp;
branches;
next	1.355;

1.355
date	2006.07.28.02.58.48;	author aw3;	state Exp;
branches;
next	1.354;

1.354
date	2006.07.23.00.29.15;	author aw3;	state Exp;
branches;
next	1.353;

1.353
date	2006.07.16.03.51.40;	author aw3;	state Exp;
branches;
next	1.352;

1.352
date	2006.07.13.12.07.27;	author aw3;	state Exp;
branches;
next	1.351;

1.351
date	2006.07.10.19.56.05;	author kush_eplus;	state Exp;
branches;
next	1.350;

1.350
date	2006.07.09.05.39.03;	author aw3;	state Exp;
branches;
next	1.349;

1.349
date	2006.06.19.04.12.56;	author aw3;	state Exp;
branches;
next	1.348;

1.348
date	2006.06.05.04.38.18;	author aw3;	state Exp;
branches;
next	1.347;

1.347
date	2006.06.05.04.32.15;	author aw3;	state Exp;
branches;
next	1.346;

1.346
date	2006.05.22.03.44.59;	author aw3;	state Exp;
branches;
next	1.345;

1.345
date	2006.05.21.06.14.29;	author aw3;	state Exp;
branches;
next	1.344;

1.344
date	2006.05.15.05.57.18;	author aw3;	state Exp;
branches;
next	1.343;

1.343
date	2006.05.14.03.37.04;	author aw3;	state Exp;
branches;
next	1.342;

1.342
date	2006.05.13.04.40.28;	author aw3;	state Exp;
branches;
next	1.341;

1.341
date	2006.05.04.03.28.59;	author aw3;	state Exp;
branches;
next	1.340;

1.340
date	2006.05.01.01.25.46;	author aw3;	state Exp;
branches;
next	1.339;

1.339
date	2006.04.26.20.31.52;	author eklmn;	state Exp;
branches;
next	1.338;

1.338
date	2006.04.26.03.21.22;	author aw3;	state Exp;
branches;
next	1.337;

1.337
date	2006.04.22.15.49.13;	author aw3;	state Exp;
branches;
next	1.336;

1.336
date	2006.04.22.15.19.36;	author eklmn;	state Exp;
branches;
next	1.335;

1.335
date	2006.04.16.23.52.29;	author kush_eplus;	state Exp;
branches;
next	1.334;

1.334
date	2006.04.15.18.00.48;	author eklmn;	state Exp;
branches;
next	1.333;

1.333
date	2006.04.09.15.18.10;	author kush_eplus;	state Exp;
branches;
next	1.332;

1.332
date	2006.04.08.07.44.10;	author eklmn;	state Exp;
branches;
next	1.331;

1.331
date	2006.03.21.21.51.27;	author eklmn;	state Exp;
branches;
next	1.330;

1.330
date	2006.03.19.23.50.21;	author aw3;	state Exp;
branches;
next	1.329;

1.329
date	2006.02.14.15.52.16;	author aw3;	state Exp;
branches;
next	1.328;

1.328
date	2006.02.10.17.09.41;	author eklmn;	state Exp;
branches;
next	1.327;

1.327
date	2006.02.07.05.32.01;	author aw3;	state Exp;
branches;
next	1.326;

1.326
date	2006.01.15.07.15.29;	author aw3;	state Exp;
branches;
next	1.325;

1.325
date	2006.01.03.04.40.12;	author aw3;	state Exp;
branches;
next	1.324;

1.324
date	2005.12.28.22.00.52;	author eklmn;	state Exp;
branches;
next	1.323;

1.323
date	2005.12.23.21.59.48;	author eklmn;	state Exp;
branches;
next	1.322;

1.322
date	2005.12.22.21.27.06;	author eklmn;	state Exp;
branches;
next	1.321;

1.321
date	2005.12.20.06.41.53;	author eklmn;	state Exp;
branches;
next	1.320;

1.320
date	2005.12.14.05.10.20;	author aw3;	state Exp;
branches;
next	1.319;

1.319
date	2005.12.03.14.08.38;	author aw3;	state Exp;
branches;
next	1.318;

1.318
date	2005.12.03.07.57.57;	author eklmn;	state Exp;
branches;
next	1.317;

1.317
date	2005.11.30.06.50.46;	author eklmn;	state Exp;
branches;
next	1.316;

1.316
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.315;

1.315
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.314;

1.314
date	2005.11.26.08.48.32;	author eklmn;	state Exp;
branches;
next	1.313;

1.313
date	2005.11.25.05.11.43;	author aw3;	state Exp;
branches;
next	1.312;

1.312
date	2005.11.23.04.00.31;	author aw3;	state Exp;
branches;
next	1.311;

1.311
date	2005.11.16.20.55.30;	author eklmn;	state Exp;
branches;
next	1.310;

1.310
date	2005.11.16.05.57.42;	author aw3;	state Exp;
branches;
next	1.309;

1.309
date	2005.11.15.06.05.48;	author aw3;	state Exp;
branches;
next	1.308;

1.308
date	2005.11.11.05.41.39;	author aw3;	state Exp;
branches;
next	1.307;

1.307
date	2005.11.07.02.56.34;	author aw3;	state Exp;
branches;
next	1.306;

1.306
date	2005.11.06.00.58.44;	author aw3;	state Exp;
branches;
next	1.305;

1.305
date	2005.11.04.05.27.58;	author aw3;	state Exp;
branches;
next	1.304;

1.304
date	2005.11.02.18.10.56;	author eklmn;	state Exp;
branches;
next	1.303;

1.303
date	2005.10.29.04.54.13;	author aw3;	state Exp;
branches;
next	1.302;

1.302
date	2005.10.20.02.29.20;	author aw3;	state Exp;
branches;
next	1.301;

1.301
date	2005.09.30.04.46.24;	author aw3;	state Exp;
branches;
next	1.300;

1.300
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.299;

1.299
date	2005.09.13.05.59.18;	author aw3;	state Exp;
branches;
next	1.298;

1.298
date	2005.09.05.21.43.14;	author aw3;	state Exp;
branches;
next	1.297;

1.297
date	2005.09.02.05.15.42;	author aw3;	state Exp;
branches;
next	1.296;

1.296
date	2005.08.29.17.40.19;	author eklmn;	state Exp;
branches;
next	1.295;

1.295
date	2005.08.28.08.28.56;	author eklmn;	state Exp;
branches;
next	1.294;

1.294
date	2005.08.27.15.08.17;	author aw3;	state Exp;
branches;
next	1.293;

1.293
date	2005.08.18.19.08.22;	author eklmn;	state Exp;
branches;
next	1.292;

1.292
date	2005.08.17.18.49.43;	author eklmn;	state Exp;
branches;
next	1.291;

1.291
date	2005.08.17.04.03.16;	author aw3;	state Exp;
branches;
next	1.290;

1.290
date	2005.08.12.12.55.49;	author eklmn;	state Exp;
branches;
next	1.289;

1.289
date	2005.08.11.21.03.52;	author eklmn;	state Exp;
branches;
next	1.288;

1.288
date	2005.08.10.05.20.40;	author eklmn;	state Exp;
branches;
next	1.287;

1.287
date	2005.07.02.00.43.56;	author aw3;	state Exp;
branches;
next	1.286;

1.286
date	2005.06.20.04.34.36;	author aw3;	state Exp;
branches;
next	1.285;

1.285
date	2005.06.19.05.09.53;	author aw3;	state Exp;
branches;
next	1.284;

1.284
date	2005.06.17.12.14.15;	author eklmn;	state Exp;
branches;
next	1.283;

1.283
date	2005.06.15.05.09.10;	author eklmn;	state Exp;
branches;
next	1.282;

1.282
date	2005.06.12.13.53.36;	author eklmn;	state Exp;
branches;
next	1.281;

1.281
date	2005.01.24.17.19.50;	author aw3;	state Exp;
branches;
next	1.280;

1.280
date	2005.01.20.16.27.34;	author kush_eplus;	state Exp;
branches;
next	1.279;

1.279
date	2004.12.27.19.34.34;	author aw3;	state Exp;
branches;
next	1.278;

1.278
date	2004.12.15.00.17.13;	author aw3;	state Exp;
branches;
next	1.277;

1.277
date	2004.12.13.05.25.08;	author aw3;	state Exp;
branches;
next	1.276;

1.276
date	2004.12.06.03.29.08;	author aw3;	state Exp;
branches;
next	1.275;

1.275
date	2004.12.02.07.21.19;	author aw3;	state Exp;
branches;
next	1.274;

1.274
date	2004.11.20.23.51.31;	author eklmn;	state Exp;
branches;
next	1.273;

1.273
date	2004.11.19.15.31.02;	author eklmn;	state Exp;
branches;
next	1.272;

1.272
date	2004.11.18.06.57.49;	author aw3;	state Exp;
branches;
next	1.271;

1.271
date	2004.11.17.05.46.58;	author aw3;	state Exp;
branches;
next	1.270;

1.270
date	2004.11.15.19.07.32;	author aw3;	state Exp;
branches;
next	1.269;

1.269
date	2004.11.15.05.57.12;	author aw3;	state Exp;
branches;
next	1.268;

1.268
date	2004.11.10.17.24.33;	author aw3;	state Exp;
branches;
next	1.267;

1.267
date	2004.11.07.12.28.54;	author eklmn;	state Exp;
branches;
next	1.266;

1.266
date	2004.11.06.04.46.12;	author aw3;	state Exp;
branches;
next	1.265;

1.265
date	2004.10.31.20.07.52;	author aw3;	state Exp;
branches;
next	1.264;

1.264
date	2004.10.18.18.11.28;	author aw3;	state Exp;
branches;
next	1.263;

1.263
date	2004.10.02.15.20.05;	author eklmn;	state Exp;
branches;
next	1.262;

1.262
date	2004.09.26.04.06.42;	author aw3;	state Exp;
branches;
next	1.261;

1.261
date	2004.09.24.03.24.43;	author aw3;	state Exp;
branches;
next	1.260;

1.260
date	2004.09.17.20.50.39;	author aw3;	state Exp;
branches;
next	1.259;

1.259
date	2004.09.05.22.13.40;	author aw3;	state Exp;
branches;
next	1.258;

1.258
date	2004.09.01.19.20.50;	author eklmn;	state Exp;
branches;
next	1.257;

1.257
date	2004.09.01.05.27.27;	author eklmn;	state Exp;
branches;
next	1.256;

1.256
date	2004.08.31.11.50.54;	author eklmn;	state Exp;
branches;
next	1.255;

1.255
date	2004.08.31.05.18.05;	author eklmn;	state Exp;
branches;
next	1.254;

1.254
date	2004.08.30.19.30.02;	author eklmn;	state Exp;
branches;
next	1.253;

1.253
date	2004.08.24.09.54.33;	author eklmn;	state Exp;
branches;
next	1.252;

1.252
date	2004.08.23.14.46.21;	author eklmn;	state Exp;
branches;
next	1.251;

1.251
date	2004.08.23.13.21.39;	author eklmn;	state Exp;
branches;
next	1.250;

1.250
date	2004.08.23.12.45.34;	author eklmn;	state Exp;
branches;
next	1.249;

1.249
date	2004.08.22.08.01.38;	author eklmn;	state Exp;
branches;
next	1.248;

1.248
date	2004.08.21.07.58.54;	author aw3;	state Exp;
branches;
next	1.247;

1.247
date	2004.08.20.15.42.16;	author eklmn;	state Exp;
branches;
next	1.246;

1.246
date	2004.08.18.23.42.00;	author aw3;	state Exp;
branches;
next	1.245;

1.245
date	2004.08.17.16.55.01;	author aw3;	state Exp;
branches;
next	1.244;

1.244
date	2004.08.15.08.12.25;	author eklmn;	state Exp;
branches;
next	1.243;

1.243
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.242;

1.242
date	2004.08.10.12.43.39;	author eklmn;	state Exp;
branches;
next	1.241;

1.241
date	2004.08.07.17.40.08;	author eklmn;	state Exp;
branches;
next	1.240;

1.240
date	2004.08.07.17.37.50;	author eklmn;	state Exp;
branches;
next	1.239;

1.239
date	2004.08.07.08.51.52;	author eklmn;	state Exp;
branches;
next	1.238;

1.238
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.237;

1.237
date	2004.08.05.21.38.11;	author aw3;	state Exp;
branches;
next	1.236;

1.236
date	2004.07.29.18.56.59;	author dongato;	state Exp;
branches;
next	1.235;

1.235
date	2004.07.29.04.45.14;	author aw3;	state Exp;
branches;
next	1.234;

1.234
date	2004.07.26.13.38.27;	author dongato;	state Exp;
branches;
next	1.233;

1.233
date	2004.07.26.01.46.22;	author dongato;	state Exp;
branches;
next	1.232;

1.232
date	2004.07.25.15.00.26;	author dongato;	state Exp;
branches;
next	1.231;

1.231
date	2004.07.25.02.00.11;	author dongato;	state Exp;
branches;
next	1.230;

1.230
date	2004.07.15.17.58.14;	author eklmn;	state Exp;
branches;
next	1.229;

1.229
date	2004.07.07.12.32.50;	author dongato;	state Exp;
branches;
next	1.228;

1.228
date	2004.07.07.10.57.56;	author dongato;	state Exp;
branches;
next	1.227;

1.227
date	2004.07.04.04.22.41;	author dongato;	state Exp;
branches;
next	1.226;

1.226
date	2004.06.30.13.38.40;	author dongato;	state Exp;
branches;
next	1.225;

1.225
date	2004.06.18.09.45.10;	author netwolf1;	state Exp;
branches;
next	1.224;

1.224
date	2004.06.17.12.23.06;	author netwolf1;	state Exp;
branches;
next	1.223;

1.223
date	2004.06.16.16.29.45;	author dongato;	state Exp;
branches;
next	1.222;

1.222
date	2004.06.10.22.04.19;	author netwolf1;	state Exp;
branches;
next	1.221;

1.221
date	2004.06.07.13.48.39;	author netwolf1;	state Exp;
branches;
next	1.220;

1.220
date	2004.06.02.08.44.43;	author dongato;	state Exp;
branches;
next	1.219;

1.219
date	2004.05.30.04.57.36;	author aw3;	state Exp;
branches;
next	1.218;

1.218
date	2004.05.29.21.07.43;	author bavariansnail;	state Exp;
branches;
next	1.217;

1.217
date	2004.05.29.08.39.48;	author bavariansnail;	state Exp;
branches;
next	1.216;

1.216
date	2004.05.27.01.52.17;	author aw3;	state Exp;
branches;
next	1.215;

1.215
date	2004.05.26.06.32.10;	author aw3;	state Exp;
branches;
next	1.214;

1.214
date	2004.05.25.19.11.17;	author bavariansnail;	state Exp;
branches;
next	1.213;

1.213
date	2004.05.25.10.28.43;	author dongato;	state Exp;
branches;
next	1.212;

1.212
date	2004.05.24.19.52.35;	author dongato;	state Exp;
branches;
next	1.211;

1.211
date	2004.05.23.10.11.58;	author dongato;	state Exp;
branches;
next	1.210;

1.210
date	2004.05.22.13.01.02;	author dongato;	state Exp;
branches;
next	1.209;

1.209
date	2004.05.21.06.15.37;	author dongato;	state Exp;
branches;
next	1.208;

1.208
date	2004.05.21.04.36.16;	author aw3;	state Exp;
branches;
next	1.207;

1.207
date	2004.05.19.10.34.22;	author netwolf1;	state Exp;
branches;
next	1.206;

1.206
date	2004.05.19.05.59.51;	author dongato;	state Exp;
branches;
next	1.205;

1.205
date	2004.05.18.19.50.42;	author kush_eplus;	state Exp;
branches;
next	1.204;

1.204
date	2004.05.18.03.28.57;	author kush_eplus;	state Exp;
branches;
next	1.203;

1.203
date	2004.05.18.01.00.30;	author kush_eplus;	state Exp;
branches;
next	1.202;

1.202
date	2004.05.17.19.22.47;	author kush_eplus;	state Exp;
branches;
next	1.201;

1.201
date	2004.05.15.00.52.50;	author aw3;	state Exp;
branches;
next	1.200;

1.200
date	2004.05.14.13.29.46;	author kush_eplus;	state Exp;
branches;
next	1.199;

1.199
date	2004.05.14.09.28.57;	author dongato;	state Exp;
branches;
next	1.198;

1.198
date	2004.05.13.05.38.33;	author kush_eplus;	state Exp;
branches;
next	1.197;

1.197
date	2004.05.13.03.30.03;	author kush_eplus;	state Exp;
branches;
next	1.196;

1.196
date	2004.05.13.03.21.04;	author kush_eplus;	state Exp;
branches;
next	1.195;

1.195
date	2004.05.12.23.28.44;	author kush_eplus;	state Exp;
branches;
next	1.194;

1.194
date	2004.05.12.14.31.24;	author dongato;	state Exp;
branches;
next	1.193;

1.193
date	2004.04.24.03.05.58;	author aw3;	state Exp;
branches;
next	1.192;

1.192
date	2004.04.16.15.19.38;	author dongato;	state Exp;
branches;
next	1.191;

1.191
date	2004.04.16.08.43.28;	author dongato;	state Exp;
branches;
next	1.190;

1.190
date	2004.04.16.07.16.10;	author dongato;	state Exp;
branches;
next	1.189;

1.189
date	2004.04.15.14.54.10;	author katsyonak;	state Exp;
branches;
next	1.188;

1.188
date	2004.04.14.07.54.25;	author dongato;	state Exp;
branches;
next	1.187;

1.187
date	2004.04.06.17.33.40;	author eklmn;	state Exp;
branches;
next	1.186;

1.186
date	2004.04.05.12.47.33;	author dongato;	state Exp;
branches;
next	1.185;

1.185
date	2004.04.05.06.54.50;	author aw3;	state Exp;
branches;
next	1.184;

1.184
date	2004.04.01.13.08.55;	author eklmn;	state Exp;
branches;
next	1.183;

1.183
date	2004.04.01.05.15.04;	author eklmn;	state Exp;
branches;
next	1.182;

1.182
date	2004.03.27.22.41.49;	author dongato;	state Exp;
branches;
next	1.181;

1.181
date	2004.03.27.19.25.18;	author aw3;	state Exp;
branches;
next	1.180;

1.180
date	2004.03.27.16.58.57;	author eklmn;	state Exp;
branches;
next	1.179;

1.179
date	2004.03.26.21.03.49;	author eklmn;	state Exp;
branches;
next	1.178;

1.178
date	2004.02.26.06.18.13;	author eklmn;	state Exp;
branches;
next	1.177;

1.177
date	2004.02.18.13.48.45;	author kush_eplus;	state Exp;
branches;
next	1.176;

1.176
date	2004.02.17.22.00.23;	author aw3;	state Exp;
branches;
next	1.175;

1.175
date	2004.02.17.01.58.30;	author kush_eplus;	state Exp;
branches;
next	1.174;

1.174
date	2004.02.16.23.29.15;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2004.02.16.17.31.08;	author eklmn;	state Exp;
branches;
next	1.172;

1.172
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.171;

1.171
date	2004.02.15.03.41.59;	author kush_eplus;	state Exp;
branches;
next	1.170;

1.170
date	2004.02.14.21.35.25;	author kush_eplus;	state Exp;
branches;
next	1.169;

1.169
date	2004.02.13.01.52.16;	author aw3;	state Exp;
branches;
next	1.168;

1.168
date	2004.02.08.23.13.50;	author kush_eplus;	state Exp;
branches;
next	1.167;

1.167
date	2004.02.04.23.59.58;	author kush_eplus;	state Exp;
branches;
next	1.166;

1.166
date	2004.02.04.19.05.42;	author morevit;	state Exp;
branches;
next	1.165;

1.165
date	2004.02.03.14.28.05;	author kush_eplus;	state Exp;
branches;
next	1.164;

1.164
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.163;

1.163
date	2004.02.03.01.20.30;	author double_t;	state Exp;
branches;
next	1.162;

1.162
date	2004.02.02.16.08.00;	author kush_eplus;	state Exp;
branches;
next	1.161;

1.161
date	2004.01.31.13.08.02;	author syrus77;	state Exp;
branches;
next	1.160;

1.160
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.159;

1.159
date	2004.01.23.05.22.05;	author kush_eplus;	state Exp;
branches;
next	1.158;

1.158
date	2004.01.22.19.48.25;	author dongato;	state Exp;
branches;
next	1.157;

1.157
date	2004.01.14.22.30.31;	author netwolf1;	state Exp;
branches;
next	1.156;

1.156
date	2004.01.14.17.47.53;	author netwolf1;	state Exp;
branches;
next	1.155;

1.155
date	2004.01.07.15.41.49;	author dongato;	state Exp;
branches;
next	1.154;

1.154
date	2004.01.06.00.54.25;	author dongato;	state Exp;
branches;
next	1.153;

1.153
date	2004.01.05.03.33.04;	author dongato;	state Exp;
branches;
next	1.152;

1.152
date	2004.01.04.15.13.17;	author dongato;	state Exp;
branches;
next	1.151;

1.151
date	2004.01.02.02.57.37;	author dongato;	state Exp;
branches;
next	1.150;

1.150
date	2003.12.29.15.23.55;	author eklmn;	state Exp;
branches;
next	1.149;

1.149
date	2003.12.29.13.05.15;	author eklmn;	state Exp;
branches;
next	1.148;

1.148
date	2003.12.24.01.21.13;	author katsyonak;	state Exp;
branches;
next	1.147;

1.147
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.146;

1.146
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.145;

1.145
date	2003.12.22.13.16.54;	author dongato;	state Exp;
branches;
next	1.144;

1.144
date	2003.12.19.09.26.12;	author eklmn;	state Exp;
branches;
next	1.143;

1.143
date	2003.12.09.10.51.22;	author kuchin;	state Exp;
branches;
next	1.142;

1.142
date	2003.12.08.22.04.10;	author eklmn;	state Exp;
branches;
next	1.141;

1.141
date	2003.12.08.06.18.38;	author eklmn;	state Exp;
branches;
next	1.140;

1.140
date	2003.12.06.12.28.19;	author eklmn;	state Exp;
branches;
next	1.139;

1.139
date	2003.12.04.06.52.08;	author eklmn;	state Exp;
branches;
next	1.138;

1.138
date	2003.11.30.17.58.57;	author eklmn;	state Exp;
branches;
next	1.137;

1.137
date	2003.11.18.19.58.01;	author katsyonak;	state Exp;
branches;
next	1.136;

1.136
date	2003.11.17.17.20.58;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2003.11.10.21.30.23;	author eklmn;	state Exp;
branches;
next	1.134;

1.134
date	2003.10.31.19.42.42;	author morevit;	state Exp;
branches;
next	1.133;

1.133
date	2003.10.29.14.14.17;	author morevit;	state Exp;
branches;
next	1.132;

1.132
date	2003.10.28.21.29.25;	author morevit;	state Exp;
branches;
next	1.131;

1.131
date	2003.10.28.10.09.29;	author katsyonak;	state Exp;
branches;
next	1.130;

1.130
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.129;

1.129
date	2003.10.21.10.41.24;	author morevit;	state Exp;
branches;
next	1.128;

1.128
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.127;

1.127
date	2003.10.20.13.19.58;	author morevit;	state Exp;
branches;
next	1.126;

1.126
date	2003.10.19.16.01.42;	author kuchin;	state Exp;
branches;
next	1.125;

1.125
date	2003.10.17.14.13.31;	author morevit;	state Exp;
branches;
next	1.124;

1.124
date	2003.10.17.10.29.05;	author morevit;	state Exp;
branches;
next	1.123;

1.123
date	2003.10.15.14.15.32;	author morevit;	state Exp;
branches;
next	1.122;

1.122
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.121;

1.121
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.13.15.04.49;	author morevit;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.08.15.39.47;	author morevit;	state Exp;
branches;
next	1.117;

1.117
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.116;

1.116
date	2003.10.08.01.53.31;	author morevit;	state Exp;
branches;
next	1.115;

1.115
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.114;

1.114
date	2003.10.04.22.51.45;	author morevit;	state Exp;
branches;
next	1.113;

1.113
date	2003.10.02.00.58.14;	author morevit;	state Exp;
branches;
next	1.112;

1.112
date	2003.09.24.20.37.29;	author dongato;	state Exp;
branches;
next	1.111;

1.111
date	2003.09.24.10.10.49;	author dongato;	state Exp;
branches;
next	1.110;

1.110
date	2003.09.24.07.10.11;	author dongato;	state Exp;
branches;
next	1.109;

1.109
date	2003.09.22.22.33.30;	author eklmn;	state Exp;
branches;
next	1.108;

1.108
date	2003.09.21.22.05.14;	author morevit;	state Exp;
branches;
next	1.107;

1.107
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.106;

1.106
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.105;

1.105
date	2003.09.14.13.42.36;	author kuchin;	state Exp;
branches;
next	1.104;

1.104
date	2003.09.09.20.30.56;	author eklmn;	state Exp;
branches;
next	1.103;

1.103
date	2003.08.30.11.23.25;	author emoulari;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.30.08.19.58;	author zegzav;	state Exp;
branches;
next	1.101;

1.101
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.100;

1.100
date	2003.08.18.11.49.33;	author dongato;	state Exp;
branches;
next	1.99;

1.99
date	2003.08.17.16.11.54;	author dongato;	state Exp;
branches;
next	1.98;

1.98
date	2003.08.16.17.57.38;	author eklmn;	state Exp;
branches;
next	1.97;

1.97
date	2003.08.10.14.12.51;	author zegzav;	state Exp;
branches;
next	1.96;

1.96
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.95;

1.95
date	2003.08.02.07.33.48;	author partyckip;	state Exp;
branches;
next	1.94;

1.94
date	2003.07.25.05.11.45;	author partyckip;	state Exp;
branches;
next	1.93;

1.93
date	2003.07.24.20.09.42;	author eklmn;	state Exp;
branches;
next	1.92;

1.92
date	2003.07.24.17.17.17;	author eklmn;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.22.16.38.33;	author eklmn;	state Exp;
branches;
next	1.90;

1.90
date	2003.07.18.05.15.48;	author eklmn;	state Exp;
branches;
next	1.89;

1.89
date	2003.07.18.05.14.56;	author eklmn;	state Exp;
branches;
next	1.88;

1.88
date	2003.07.16.22.38.21;	author syrus77;	state Exp;
branches;
next	1.87;

1.87
date	2003.07.12.06.15.29;	author eklmn;	state Exp;
branches;
next	1.86;

1.86
date	2003.07.05.16.19.02;	author eklmn;	state Exp;
branches;
next	1.85;

1.85
date	2003.07.04.05.37.13;	author eklmn;	state Exp;
branches;
next	1.84;

1.84
date	2003.07.02.15.53.44;	author eklmn;	state Exp;
branches;
next	1.83;

1.83
date	2003.06.30.16.46.11;	author eklmn;	state Exp;
branches;
next	1.82;

1.82
date	2003.06.29.01.15.08;	author eklmn;	state Exp;
branches;
next	1.81;

1.81
date	2003.06.28.18.17.24;	author eklmn;	state Exp;
branches;
next	1.80;

1.80
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.79;

1.79
date	2003.06.24.18.49.02;	author eklmn;	state Exp;
branches;
next	1.78;

1.78
date	2003.06.22.09.34.13;	author eklmn;	state Exp;
branches;
next	1.77;

1.77
date	2003.06.19.22.02.17;	author eklmn;	state Exp;
branches;
next	1.76;

1.76
date	2003.06.18.21.42.25;	author eklmn;	state Exp;
branches;
next	1.75;

1.75
date	2003.06.16.19.29.38;	author eklmn;	state Exp;
branches;
next	1.74;

1.74
date	2003.06.15.09.10.04;	author partyckip;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.15.07.41.35;	author eklmn;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.13.17.15.54;	author eklmn;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.13.05.35.54;	author eklmn;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.11.18.27.06;	author eklmn;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.10.09.36.44;	author kuchin;	state Exp;
branches;
next	1.68;

1.68
date	2003.06.09.23.45.23;	author syrus77;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.09.15.14.37;	author kuchin;	state Exp;
branches;
next	1.66;

1.66
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.07.18.20.55;	author partyckip;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.07.12.03.11;	author eklmn;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.06.20.10.03;	author eklmn;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.06.19.56.46;	author partyckip;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.05.19.20.47;	author partyckip;	state Exp;
branches;
next	1.60;

1.60
date	2003.06.05.19.18.45;	author partyckip;	state Exp;
branches;
next	1.59;

1.59
date	2003.06.04.22.35.47;	author netwolf1;	state Exp;
branches;
next	1.58;

1.58
date	2003.06.02.22.18.48;	author partyckip;	state Exp;
branches;
next	1.57;

1.57
date	2003.06.01.08.59.01;	author kuchin;	state Exp;
branches;
next	1.56;

1.56
date	2003.05.23.18.00.41;	author netwolf1;	state Exp;
branches;
next	1.55;

1.55
date	2003.05.22.01.51.02;	author netwolf1;	state Exp;
branches;
next	1.54;

1.54
date	2003.05.20.20.46.25;	author netwolf1;	state Exp;
branches;
next	1.53;

1.53
date	2003.05.20.16.30.40;	author netwolf1;	state Exp;
branches;
next	1.52;

1.52
date	2003.05.18.11.40.31;	author obaldin;	state Exp;
branches;
next	1.51;

1.51
date	2003.05.09.11.57.05;	author kuchin;	state Exp;
branches;
next	1.50;

1.50
date	2003.05.08.17.08.24;	author netwolf1;	state Exp;
branches;
next	1.49;

1.49
date	2003.05.07.09.00.34;	author partyckip;	state Exp;
branches;
next	1.48;

1.48
date	2003.05.04.14.13.23;	author kuchin;	state Exp;
branches;
next	1.47;

1.47
date	2003.04.24.15.36.45;	author kuchin;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.22.12.41.51;	author kuchin;	state Exp;
branches;
next	1.45;

1.45
date	2003.04.09.19.10.27;	author dongato;	state Exp;
branches;
next	1.44;

1.44
date	2003.04.09.15.26.15;	author partyckip;	state Exp;
branches;
next	1.43;

1.43
date	2003.04.05.09.35.17;	author dongato;	state Exp;
branches;
next	1.42;

1.42
date	2003.04.01.19.44.01;	author obaldin;	state Exp;
branches;
next	1.41;

1.41
date	2003.03.28.07.38.42;	author partyckip;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.28.06.29.15;	author partyckip;	state Exp;
branches;
next	1.39;

1.39
date	2003.03.25.12.39.32;	author cax2;	state Exp;
branches;
next	1.38;

1.38
date	2003.03.22.01.13.59;	author cax2;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2003.03.21.00.30.28;	author cax2;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.20.18.09.29;	author cax2;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.20.13.43.52;	author lord_kiron;	state Exp;
branches;
next	1.34;

1.34
date	2003.03.19.00.35.55;	author recdvst;	state Exp;
branches;
next	1.33;

1.33
date	2003.03.16.06.09.31;	author cax2;	state Exp;
branches;
next	1.32;

1.32
date	2003.03.14.16.24.16;	author partyckip;	state Exp;
branches;
next	1.31;

1.31
date	2003.03.13.20.27.32;	author partyckip;	state Exp;
branches;
next	1.30;

1.30
date	2003.03.10.20.10.07;	author cax2;	state Exp;
branches;
next	1.29;

1.29
date	2003.03.05.23.17.38;	author cax2;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.05.19.05.04;	author cax2;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.05.18.22.37;	author cax2;	state Exp;
branches;
next	1.26;

1.26
date	2003.03.01.00.30.15;	author dongato;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.28.16.53.20;	author cax2;	state Exp;
branches;
next	1.24;

1.24
date	2003.02.27.20.53.33;	author cax2;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.27.19.15.47;	author cax2;	state Exp;
branches;
next	1.22;

1.22
date	2003.02.26.03.26.50;	author cax2;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.25.19.54.19;	author cax2;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.25.18.07.59;	author cax2;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.23.19.16.12;	author cax2;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.21.23.17.25;	author kuchin;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.14.29.00;	author dongato;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.20.07.25.21;	author cax2;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.12.22.26.02;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.12.20.18.21;	author obaldin;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.09.18.39.41;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.26.21.36.59;	author cax2;	state Exp;
branches
	1.9.2.1
	1.9.4.1;
next	1.8;

1.8
date	2003.01.24.22.07.47;	author maverick65;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.24.12.47.31;	author obaldin;	state Exp;
branches;
next	1.6;

1.6
date	2003.01.24.12.26.43;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.23.17.00.44;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.23.01.42.30;	author cax2;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.22.17.56.06;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches;
next	;

1.9.2.1
date	2003.01.28.16.54.03;	author cax2;	state Exp;
branches;
next	;

1.9.4.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.02.06.15.56.14;	author obaldin;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2003.02.08.13.37.04;	author obaldin;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2003.02.08.22.16.20;	author obaldin;	state Exp;
branches;
next	;

1.19.2.1
date	2003.03.01.11.25.55;	author obaldin;	state Exp;
branches;
next	1.19.2.2;

1.19.2.2
date	2003.03.01.20.59.35;	author obaldin;	state Exp;
branches;
next	1.19.2.3;

1.19.2.3
date	2003.03.04.14.10.21;	author obaldin;	state Exp;
branches;
next	;

1.38.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.399
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "zlib/zlib.h"
#include "updownclient.h"
#include "PartFile.h"
#include "server.h"
#include "opcodes.h"
#include "packets.h"
#include "emule.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#include "ClientUDPSocket.h"
#endif
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "ListenSocket.h"
#include "UploadQueue.h"
#include "IPFilter.h"
#include "SafeFile.h"
#include <share.h>
#include <io.h>

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

struct Pending_Block_Struct
{
	Requested_Block_Struct	*pReqBlock;		// requested block
	z_stream				*pZStream;		// zlib context
	BYTE					*pbyteRxDate;	// buffer with buffered rx data
	uint32					dwReceived;		// bytes received for requested block
	int						iZStreamErr;
};

//	members of CUpDownClient
//	which are mainly used for downloading functions

void CUpDownClient::DrawStatusBar(CDC* dc, RECT* rect, bool bOnlyGreyRect, bool bFlat)
{
	EMULE_TRY

	const COLORREF crPending = RGB(222, 160, 0);
	const COLORREF crToDo = RGB(255, 208, 0);
	const COLORREF crNextPending = RGB(255, 255, 100);
	const COLORREF crMeOnly = RGB(190, 190, 255);
	COLORREF crBoth, crNeither, crClientOnly;

	if (bFlat)
	{
		crBoth = RGB(0, 150, 0);
		crNeither = RGB(224, 224, 224);
		crClientOnly = RGB(0, 0, 0);
	}
	else
	{
		crBoth = RGB(0, 192, 0);
		crNeither = RGB(240, 240, 240);
		crClientOnly = RGB(95, 95, 95);
	}

	uint64		qwFileSz = (m_pReqPartFile != NULL) ? m_pReqPartFile->GetFileSize() : 1ui64;
	CBarShader	statusBar(rect->bottom - rect->top, rect->right - rect->left, crNeither, qwFileSz);

	if (!bOnlyGreyRect && (m_pReqPartFile != NULL) && m_pbytePartStatuses)
	{
		_Bvector gettingParts;
		bool isDLing = (m_eDownloadState == DS_DOWNLOADING);

		if (isDLing)
			ShowDownloadingParts(gettingParts);

		uint64 qwStart, qwEnd;

		for (uint32 i = 0; i < m_uPartCount; i++)
		{
			bool bIsComplete = m_pReqPartFile->IsPartComplete(i, &qwStart, &qwEnd);

			qwEnd++;

		//	They have this part. Do I have it?
			if (m_pbytePartStatuses[i])
			{ 
				if (bIsComplete)
					statusBar.FillRange(qwStart, qwEnd, crBoth);
				else if (isDLing && (m_qwLastBlockOffset < qwEnd) && (m_qwLastBlockOffset >= qwStart))
				{
					statusBar.FillRange(qwStart, m_qwLastBlockOffset, crPending);
					statusBar.FillRange(m_qwLastBlockOffset, qwEnd, crToDo);
				}
				else if (isDLing && gettingParts[i])
					statusBar.FillRange(qwStart, qwEnd, crNextPending);
				else
					statusBar.FillRange(qwStart, qwEnd, crClientOnly);
			}
		//	They don't have a part. Do I have it?
			else if (bIsComplete)
				statusBar.FillRange(qwStart, qwEnd, crMeOnly);
		}
	}

	statusBar.Draw(dc, rect->left, rect->top, bFlat);

	EMULE_CATCH
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUpDownClient::Compare(CUpDownClient* pClient) const
{
	uint32 dwResult = 0;

	EMULE_TRY

	if (GetIP() != 0 && pClient->GetIP() != 0)
	{
		if (GetIP() == pClient->GetIP() && GetUserPort() == pClient->GetUserPort())
			dwResult |= CLIENT_COMPARE_SAME_IP;
	}
	else if ((GetUserIDHybrid() != 0) && (GetUserIDHybrid() == pClient->GetUserIDHybrid()))
	{
		if (HasLowID())
		{
			if ( (GetServerIP() != 0) && (GetServerIP() == pClient->GetServerIP()) &&
				(GetServerPort() != 0) && (GetServerPort() == pClient->GetServerPort()) )
			{
				dwResult |= CLIENT_COMPARE_SAME_ID;
			}
		}
		else if (GetUserPort() == pClient->GetUserPort())
			dwResult |= CLIENT_COMPARE_SAME_ID;
	}

	if ((md4cmp(GetUserHash(), pClient->GetUserHash()) == 0) && HasValidHash())
		dwResult |= CLIENT_COMPARE_SAME_HASH;

	EMULE_CATCH

	return dwResult;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
// Return TRUE if client still connected, otherwise return FALSE
bool CUpDownClient::AskForDownload()
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
//	Continue anyway when socket connection already exists
//	(even if opened connection threshold was reached)
	if ( g_App.m_pListenSocket->TooManySockets() && ( (m_pRequestSocket == NULL) ||
		!(m_pRequestSocket->IsConnected() || m_pRequestSocket->IsConnecting()) ) )
	{
		return false;
	}
#endif
	m_bUDPPending = false;

	SetLastAskedTime();
	SetDownloadState(DS_CONNECTING);

	return TryToConnect();

	EMULE_CATCH

	return false;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::IsSourceRequestAllowed()
{
	EMULE_TRY

//	Avoid source request if ...
//	... remote client does not support eMule protocol
	if (!ExtProtocolAvailable())
		return false;
//	... remote client doesn't support correct SX version
	if (!SupportsSourceExchange2() && GetSourceExchange1Version() == 0)
		return false;
//	... source exchange was disabled by the user
	if (g_App.m_pPrefs->IsDisabledXS())
		return false;

	uint32	dwSources = m_pReqPartFile->GetSourceCount();

//	... source exchange for popular file was disabled by the user
	if (g_App.m_pPrefs->DisableXSUpTo() && g_App.m_pPrefs->XSUpTo() < dwSources)
		return false;

	uint32	dwCurrentTick = ::GetTickCount();

//	... we have lot of sources and source drop is not allowed
	if (g_App.m_pPrefs->GetMaxSourcePerFileSoft() <= dwSources &&
			(m_pReqPartFile->GetLastPurgeTime() + PURGE_TIME) >= dwCurrentTick)
		return false;

	uint32	dwTickCount = dwCurrentTick + CONNECTION_LATENCY;
	uint32	dwTimePassedClient = dwTickCount - GetLastSrcAnswerTime();
	uint32	dwTimePassedFile = dwTickCount - m_pReqPartFile->GetLastAnsweredTime();
	bool	bNeverAskedBefore = GetLastSrcReqTime() == 0;

	return (
	//	source is not complete and file is rare, allow once every 10 minutes
		( !IsCompleteSource()
			&& (dwSources <= RARE_FILE * 2
				|| m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4 )
			&& (bNeverAskedBefore || dwTimePassedClient > SOURCECLIENTREASK) )
	//	otherwise, allow every 90 minutes, but only if we haven't
	//	asked someone else in last 10 minutes
		|| ( (bNeverAskedBefore || dwTimePassedClient > (unsigned)(SOURCECLIENTREASK * MINCOMMONPENALTY)) &&
			(dwTimePassedFile > SOURCECLIENTREASK) )
	);

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendFileRequest()
{
	EMULE_TRY

	if (m_pReqPartFile == NULL)
		return;

	AddAskedCountDown();

	CMemFile	pckStrm(512);

	pckStrm.Write(m_pReqPartFile->GetFileHash(), 16);

	if (m_fSupportsMultiPacket == 1)
	{
		byte	abyteData[8];
	
		if (m_fSupportsExtMultiPacket == 1)
		{
			POKE_QWORD(abyteData, m_pReqPartFile->GetFileSize());
			pckStrm.Write(abyteData, sizeof(uint64));
		}

		abyteData[0] = OP_REQUESTFILENAME;
		pckStrm.Write(abyteData, sizeof(byte));
		if (GetExtendedRequestsVersion() > 0)
		{
			m_pReqPartFile->WritePartStatus(&pckStrm);
			if (GetExtendedRequestsVersion() > 1)
				m_pReqPartFile->WriteCompleteSourcesCount(&pckStrm);
		}

	//	Don't request file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
	//	if the remote client answers OP_REQUESTFILENAME with OP_REQFILENAMEANSWER the file is shared by the remote client. if we
	//	know that the file is shared, we know also that the file is complete and don't need to request the file status.
		if (m_pReqPartFile->GetPartCount() > 1)
		{
			abyteData[0] = OP_SETREQFILEID;
			pckStrm.Write(abyteData, sizeof(byte));
		}

		if (IsSourceRequestAllowed())
		{
			m_pReqPartFile->SetLastAnsweredTimeTimeout();

			if (SupportsSourceExchange2())
			{
				static const byte	s_abyteSx2Req[] = { OP_REQUESTSOURCES2, SOURCEEXCHANGE2_VERSION, 0, 0 };	//last 2: Options (Reserved)

				pckStrm.Write(s_abyteSx2Req, sizeof(s_abyteSx2Req));
			}
			else
			{
				abyteData[0] = OP_REQUESTSOURCES;
				pckStrm.Write(abyteData, sizeof(byte));
			}
		}

		Packet		*pPacket = new Packet(&pckStrm, OP_EMULEPROT);

		pPacket->m_eOpcode = (m_fSupportsExtMultiPacket == 1) ? OP_MULTIPACKET_EXT : OP_MULTIPACKET;
		g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif
	}
	else
	{
		if (GetExtendedRequestsVersion() > 0)
		{
			m_pReqPartFile->WritePartStatus(&pckStrm);
			if (GetExtendedRequestsVersion() > 1)
				m_pReqPartFile->WriteCompleteSourcesCount(&pckStrm);
		}

		Packet		*pPacket = new Packet(&pckStrm);

		pPacket->m_eOpcode = OP_REQUESTFILENAME;
		g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		m_pRequestSocket->SendPacket(pPacket, true);
#endif //OLD_SOCKETS_ENABLED

	//	Don't request file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
	//	if the remote client answers OP_REQUESTFILENAME with OP_REQFILENAMEANSWER the file is shared by the remote client. if we
	//	know that the file is shared, we know also that the file is complete and don't need to request the file status.
		if (m_pReqPartFile->GetPartCount() > 1)
		{
			pPacket = new Packet(OP_SETREQFILEID, 16);

			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true);
#endif //OLD_SOCKETS_ENABLED
		}

		if (IsSourceRequestAllowed())
		{
			char	*pcPktPos;

			m_pReqPartFile->SetLastAnsweredTimeTimeout();

			if (SupportsSourceExchange2())
			{
				pPacket = new Packet(OP_REQUESTSOURCES2, 19, OP_EMULEPROT);

				pPacket->m_pcBuffer[0] = SOURCEEXCHANGE2_VERSION;
				POKE_WORD(&pPacket->m_pcBuffer[1], 0);	// Options (Reserved)
				pcPktPos = &pPacket->m_pcBuffer[3];
			}
			else
			{
				pPacket = new Packet(OP_REQUESTSOURCES, 16, OP_EMULEPROT);
				pcPktPos = pPacket->m_pcBuffer;
			}
			md4cpy(pcPktPos, m_pReqPartFile->GetFileHash());
			g_App.m_pUploadQueue->AddUpDataOverheadSourceExchange(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Extract file hash from packet stream and find associated file object
bool CUpDownClient::ProcessFileHash(CSafeMemFile &packetStream)
{
	CPartFile	*pPartFile;
	uchar		fileHash[16];

	packetStream.Read(fileHash, sizeof(fileHash));
	if (m_pReqPartFile == NULL)
	{
	//	There still can be some communitation going at file completion time
	//	(after sources were already detached from a file); Make graceful termination
	//	here without response to their requests instead of throwing exception which
	//	will kill the source, what will result in upload queue position loss
	//	or the current uploading loss
		CKnownFile	*pKFile = g_App.m_pSharedFilesList->GetFileByID(fileHash);

		if ((pKFile != NULL) && pKFile->IsPartFile())
			return false;	//	stop packet processing without responding
		throw CString(_T("no requested file stated"));
	}

//	Verify incoming file hash through our download list
	if ((pPartFile = g_App.m_pDownloadQueue->GetFileByID(fileHash)) == NULL)
		throw CString(_T("offered file not found in DL list, hash: ")) + HashToString(fileHash);

	if (md4cmp(fileHash, m_pReqPartFile->GetFileHash()) != 0)
	{
		CString	strErr;

		strErr.Format(_T("offered file not requested (offered: %s (%s) | requested: %s (%s))"),
			pPartFile->GetFileName(), HashToString(pPartFile->GetFileHash()),
			m_pReqPartFile->GetFileName(), HashToString(m_pReqPartFile->GetFileHash()));
		throw strErr;
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	ProcessFileInfo() processes the contents of a File Request Answer packet
void CUpDownClient::ProcessFileInfo(CSafeMemFile &packetStream)
{
	EMULE_TRY

	SetLastAskedTime();

	uint16	uNameLength;

	packetStream.Read(&uNameLength, sizeof(uint16));
	ReadMB2Str(m_eStrCodingFormat, &m_strClientFilename, packetStream, uNameLength);
//	Shrink class member, as allocated container of returned string can be larger than string length
	m_strClientFilename.FreeExtra();

//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//	if the remote client answers OP_REQUESTFILENAME with OP_REQFILENAMEANSWER the file is shared by the remote client. if we
//	know that the file is shared, we know also that the file is complete and don't need to request the file status.

	if (m_pReqPartFile->GetPartCount() == 1)
	{
		m_uAvailPartCount = 0;	// keep it zero while doing preparation
		delete[] m_pbytePartStatuses;
		m_pbytePartStatuses = NULL;
		m_pbytePartStatuses = new byte[1];
		memset(m_pbytePartStatuses, 1, 1);
		m_uPartCount = m_uAvailPartCount = m_uNeededParts = 1;

	//	even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
		if (m_pReqPartFile->m_bHashSetNeeded)
			SendHashsetRequest();
		else if (GetDownloadState() != DS_DOWNLOADING) 
			SendStartUploadRequest();

		UpdateDownloadStateAfterFileReask();

		m_pReqPartFile->NewSrcPartsInfo();
		UpdateDisplayedInfo();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessFileStatus(CSafeMemFile &packetStream, bool bUDPPacket/*=false*/)
{
	EMULE_TRY

	uint16 uED2KPartCount;

	packetStream.Read(&uED2KPartCount, 2);

	m_uAvailPartCount = 0;
	if (m_pbytePartStatuses != NULL)
	{
		delete[] m_pbytePartStatuses;
		m_pbytePartStatuses = NULL;
	}

	m_uPartCount = m_pReqPartFile->GetPartCount();
	if (uED2KPartCount == 0)
	{
		m_pbytePartStatuses = new byte[m_uPartCount];
		memset2(m_pbytePartStatuses, 1, m_uPartCount);
		m_uAvailPartCount = m_uNeededParts = m_uPartCount;
	}
	else
	{
		m_uNeededParts = 0;
		if (m_pReqPartFile->GetED2KPartCount() != uED2KPartCount)
		{
			m_uPartCount = 0;
			CString strTemp;

			strTemp.Format( _T("wrong part number, file: %s ED2KParts/Parts: %u/%u %s %s %s:%u"),
				m_pReqPartFile->GetFileName(), m_pReqPartFile->GetED2KPartCount(), uED2KPartCount,
				GetClientNameWithSoftware(), HashToString(m_userHash), m_strFullUserIP, m_uUserPort );
			throw strTemp;
		}

		m_pbytePartStatuses = new byte[m_uPartCount];

		uint32	dwNeeded = 0, dwCompleteParts = 0, dwDone = 0;
		uint32	dwPartCnt = static_cast<uint32>(m_uPartCount);
		byte	byteToRead;

		while (dwDone < dwPartCnt)
		{
			packetStream.Read(&byteToRead, 1);
			for (unsigned ui = 0; ui < 8; ui++)
			{
				m_pbytePartStatuses[dwDone] = static_cast<byte>((byteToRead >> ui) & 1);
				if (m_pbytePartStatuses[dwDone])
				{
					dwCompleteParts++;
					if (!m_pReqPartFile->IsPartComplete(dwDone))
						dwNeeded++;
				}
				if (++dwDone == dwPartCnt)
					break;
			}
		}

		m_uAvailPartCount = static_cast<uint16>(dwCompleteParts);
		m_uNeededParts = static_cast<uint16>(dwNeeded);
	}

//	if it is TCP connection & we don't download, we can send something back
	if (!bUDPPacket)
	{
		if (m_pReqPartFile->m_bHashSetNeeded)
			SendHashsetRequest();
	//	Request the file & enter to the queue only if we required a file from remote client
		else if ((GetDownloadState() != DS_DOWNLOADING) && (m_uNeededParts != 0))
			SendStartUploadRequest();
	}

	UpdateDownloadStateAfterFileReask();

	m_pReqPartFile->NewSrcPartsInfo();
	UpdateDisplayedInfo();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::UpdateDownloadStateAfterFileReask()
{
//	If our client sent the file request at the same time when remote client invited us to download,
//	then an addition check of the download state is required to prevent download abort.
	if (GetDownloadState() == DS_DOWNLOADING || m_fRequestingHashSet == 1)
		return;
	UpdateOnqueueDownloadState();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::UpdateOnqueueDownloadState()
{
//	If remote client is lowID
	if (HasLowID())
	{
	//	Check LowID properties of local server connection if it exists,
	//	otherwise temporarily put client in active state. The proper state will be set in TryToConnect()
		if (g_App.m_pServerConnect->IsConnected())
		{
			if (g_App.m_pServerConnect->IsLowID())
			{
				SetDownloadState(DS_LOWTOLOWID);
				return;
			}
			else if (g_App.m_pServerConnect->GetCurrentServer()->GetIP() != GetServerIP())
			{
				if (m_uNeededParts != 0)
					SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
				else
					SetDownloadState(DS_NONEEDEDPARTS);
				return;
			}
		}
	}

	if (m_uNeededParts == 0)
		SetDownloadState(DS_NONEEDEDPARTS);
	else if (GetDownloadState() != DS_ONQUEUE)
		SetDownloadState(DS_ONQUEUE);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::AddRequestForAnotherFile(CPartFile* pPartFile)
{
	EMULE_TRY

	if (pPartFile == NULL)
		return false;

//	Check Other list
	if (m_otherRequestsList.Find(pPartFile) != NULL)
		return false;
	else
		m_otherRequestsList.AddTail(pPartFile);

	pPartFile->AddClientToA4AFSourceList(this);

	return true;

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::RemoveRequestForAnotherFile(CPartFile* pPartFile)
{
	EMULE_TRY

	if (pPartFile == NULL)
		return;

//	Check Other list
	POSITION posPartFile = m_otherRequestsList.Find(pPartFile);

	if (posPartFile != NULL)
	{
		m_otherRequestsList.RemoveAt(posPartFile);
	}

	m_otherNoNeededMap.RemoveKey(pPartFile);

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetDownloadState(EnumDLQState byNewState)
{
	EMULE_TRY

	if (m_eDownloadState != byNewState)
	{
	//	Clear variables before switching
		switch (m_eDownloadState)
		{
			case DS_DOWNLOADING:
			{
				uint32	dwCurTick = ::GetTickCount();
				uint32	dwSessionDuration = (dwCurTick - m_dwDownStartTime) / 1000;

			//	Update connection time not to drop sources accidently (we might transfer for hours)
			//	as this time is used to remove inactive LowID sources in PartFile:Process()
				m_dwEnteredConnectedState = dwCurTick;

				g_App.m_pPrefs->Add2DownSAvgTime(dwSessionDuration);

				ClearDownloadBlocksList();
				ClearPendingBlocksList();

				if (m_bTransferredDownMini && byNewState != DS_ERROR)
					g_App.m_pPrefs->Add2DownSuccessfulSessions();
				else
				{
					g_App.m_pPrefs->Add2DownFailedSessions();
					if (m_fBlocksWereRequested == 0)
					{
						AddLogLine(LOG_FL_DBG, _T("Failed download session with the NNS client %s%s"), GetClientNameWithSoftware(), HasLowID() ? _T(" LowID") : _T(""));
						g_App.m_pPrefs->Add2DownFailedSessionsNoRequiredData();
					}
				}

				if (g_App.m_pPrefs->LogDownloadToFile())
				{
					FILE	*pLogFile = _tfsopen(g_App.m_pPrefs->GetDownloadLogName(), _T("ab"), _SH_DENYWR);

					if (pLogFile != NULL)
					{
						COleDateTime	currentTime(COleDateTime::GetCurrentTime());
						CString			strLogLine;

						strLogLine.Format( _T("%s,\"%s\",%s,%s,\"%s\",%u,%u,%u,%s,%s,%s\r\n"),
											currentTime.Format(_T("%c")),
											GetUserName(),
											HashToString(m_userHash),
											GetFullSoftVersionString(),
											(m_pReqPartFile) ? m_pReqPartFile->GetFileName() : _T(""),
											m_dwSessionDownloadedData,
											GetLastDownPartAsked(),
											dwSessionDuration,
											HasLowID() ? _T("LowID") : _T("HighID"),
											YesNoStr(IsOnLAN()),
											GetResString((m_bTransferredDownMini) ? IDS_IDENTOK : IDS_FAILED).MakeLower() );

#ifdef _UNICODE
					//	Write the Unicode BOM in the beginning if file was created
						if (_filelength(_fileno(pLogFile)) == 0)
							fputwc(0xFEFF, pLogFile);
#endif
						_fputts(strLogLine, pLogFile);
						fclose(pLogFile);
					}
				}

				m_dwDownDataRate = 0;
				m_dwClientSumDLDataRateOverLastNMeasurements = 0;
				m_dwClientSumDLTickOverLastNMeasurements = 0;
				m_averageDLTickList.clear();
				m_averageDLDataRateList.clear();

				m_uLastPartAsked = 0xFFFF;

#ifdef OLD_SOCKETS_ENABLED

				if (m_pRequestSocket && byNewState != DS_ERROR)
					m_pRequestSocket->DisableDownloadLimit(true);
#endif //OLD_SOCKETS_ENABLED
				break;
			}
		}

	//	Note: it's required to update the variable used for timeout check before we set DS_DOWNLOADING,
	//	to prevent cancel of the session if DL-state-queue is processed before block is requested
		if (byNewState == DS_DOWNLOADING)
		{
			m_dwLastDataRateCalculationTime = m_dwDownStartTime = m_dwLastBlockReceived = ::GetTickCount();
		}

	//	Switch the state & update info
		if (m_pReqPartFile != NULL)
			m_pReqPartFile->SwapClientBetweenSourceLists(this, m_eDownloadState, byNewState);
		else
			m_eDownloadState = byNewState;

	//	Prepare variables for new state
	//	note: please remember that the value of member variable must be already updated.
		switch (m_eDownloadState)
		{
			case DS_DOWNLOADING:
				m_qwLastBlockOffset = ~0ui64;
				m_bTransferredDownMini = false;
				m_fBlocksWereRequested = 0;
				m_fSentCancelTransfer = 0;

				m_dwSessionDownloadedData = 0;

				SetAskedCountDown(0);
				SetRemoteQueueRank(0, false);
				break;

			case DS_CONNECTED:
				m_dwEnteredConnectedState = ::GetTickCount();
				break;

			case DS_ERROR:
			case DS_NONE:
				ClearPartStatuses();
			//	Update counters as a client left the download queue
				if (IsBanned())
					g_App.m_pClientList->UpdateBanCounters();
				break;
		}

		SetNextFileReaskTime();

		UpdateDisplayedInfo();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Returns download queue client status based as string
CString CUpDownClient::GetDownloadStateAsString()
{
#ifndef NEW_SOCKETS_ENGINE
	static const unsigned s_auiResTbl[] =
	{
		IDS_TRANSFERRING,			//DS_DOWNLOADING
		IDS_CONNECTING,				//DS_CONNECTING
		IDS_CONNVIASERVER,			//DS_WAITCALLBACK
		IDS_ASKING,					//DS_CONNECTED
		IDS_ONQUEUE,				//DS_ONQUEUE
		IDS_NONEEDEDPARTS,			//DS_NONEEDEDPARTS
		IDS_WAITFILEREQ,			//DS_WAIT_FOR_FILE_REQUEST
		IDS_ANOTHER_SERVER_LOWID,	//DS_LOWID_ON_OTHER_SERVER
		IDS_RECHASHSET,				//DS_REQHASHSET
		IDS_NOCONNECTLOW2LOW,		//DS_LOWTOLOWID
		IDS_UNKNOWN,				//DS_LAST_QUEUED_STATE
		IDS_ERROR_STATE,			//DS_ERROR
		IDS_UNKNOWN					//DS_NONE
	};
	unsigned	uiState = GetDownloadState();

	if (uiState >= ARRSIZE(s_auiResTbl))
		uiState = DS_NONE;
	return GetResString(s_auiResTbl[uiState]);
#else
	return _T("");
#endif //NEW_SOCKETS_ENGINE
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ProcessHashSet(byte *pbytePacket, uint32 size)
{
	EMULE_TRY

	if (!m_fRequestingHashSet)
		throw CString(_T("unwanted hashset received"));

	m_fRequestingHashSet = 0;

	if (m_pReqPartFile == NULL)
		throw CString(_T("wrong fileID sent, file: NULL"));

	if (md4cmp(pbytePacket, m_pReqPartFile->GetFileHash()))
	{
		m_pReqPartFile->m_bHashSetNeeded = true;
		throw CString(_T("wrong fileID sent, file: ") + m_pReqPartFile->GetFileName());
	}

	CSafeMemFile data1(pbytePacket, size);

	if (m_pReqPartFile->LoadHashsetFromFile(data1, true))
	{
		SendStartUploadRequest();
	}
	else
	{
		m_pReqPartFile->m_bHashSetNeeded = true;
		AddLogLine(LOG_FL_SBAR | LOG_RGB_WARNING, IDS_ERR_BADHASHSET, m_pReqPartFile->GetFileName());
	}

	UpdateDownloadStateAfterFileReask();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendBlockRequests()
{
	EMULE_TRY

	m_dwLastBlockReceived = ::GetTickCount();

	if (m_pReqPartFile == NULL)
		return;

//	Get blocks from the same chunk first
	if (m_downloadBlocksList.IsEmpty())
	{
	//	Get part for request. If actual part still has empty blocks, the we get that part,
	//	otherwise it will be a new part.
		m_uLastPartAsked = m_pReqPartFile->GetNextRequiredPart(this);

	//	Previous active part unknown
		if (m_uLastPartAsked != 0xFFFF)
		{
			Requested_Block_Struct	*apReqBlocksToAdd[3];
			uint32	dwCount, dwSavedCount;

			dwSavedCount = 3 - m_pendingBlocksList.GetCount();
			dwCount = m_pReqPartFile->GetGapsInPart(m_uLastPartAsked, apReqBlocksToAdd, dwSavedCount);

		//	Finished block (part ?)
			if (dwCount == 0)
			{
			//	Check if part was completed
				if ( m_pReqPartFile->IsPartFull(m_uLastPartAsked)
				  || m_pReqPartFile->IsCorruptedPart(m_uLastPartAsked) )
				{
					m_uLastPartAsked = 0xFFFF;
				}

			//	Get next part
				m_uLastPartAsked = m_pReqPartFile->GetNextRequiredPart(this);

			//	More parts ?
				if (m_uLastPartAsked != 0xFFFF)
					dwCount = m_pReqPartFile->GetGapsInPart(m_uLastPartAsked, apReqBlocksToAdd, dwSavedCount);
			}

			for (uint32 i = 0; i < dwCount; i++)
				m_downloadBlocksList.AddTail(apReqBlocksToAdd[i]);
		}
	}

//	Why are unfinished blocks requested again, not just new ones?
	while (m_pendingBlocksList.GetCount() < 3 && !m_downloadBlocksList.IsEmpty())
	{
		Pending_Block_Struct		*pPendingBlock = new Pending_Block_Struct;

		pPendingBlock->pReqBlock = m_downloadBlocksList.RemoveHead();
		pPendingBlock->pZStream = NULL;
		pPendingBlock->pbyteRxDate = NULL;
		pPendingBlock->dwReceived = 0;
		pPendingBlock->iZStreamErr = 0;
		m_pendingBlocksList.AddTail(pPendingBlock);
	}

	if (m_pendingBlocksList.IsEmpty())
	{
		EnumDLQState eOldDowloadState = GetDownloadState();

		SendCancelTransfer();

	//	Don't initiate file reask when file is almost completed to avoid protocol
	//	collisions and waste of traffic for nothing
		if (m_pReqPartFile->GetSizeToTransfer() == 0)
		{
			m_dwLastAskedTime = ::GetTickCount();	// No need to reask in the nearest future
		//	NextFileReaskTime is calculated inside after state change
			UpdateOnqueueDownloadState();
		}
		else
		{
			if ((GetTickCount() - GetLastAskedTime()) > FILEREASKTIME)
				AskForDownload();

			if (eOldDowloadState == GetDownloadState())
				SetDownloadState(DS_NONEEDEDPARTS);
		}
		return;
	}

	Packet		*pPacket;
	POSITION	pos = m_pendingBlocksList.GetHeadPosition();
	bool		bI64Offsets = false;
	Requested_Block_Struct	*pReqBlk;

	for (uint32 i = 0; i < 3; i++)
	{
		if (pos != NULL)
		{
			pReqBlk = m_pendingBlocksList.GetNext(pos)->pReqBlock;
		//	We use larger or equal condition to avoid wrap-around block requests (End < Start)
			if (pReqBlk->qwEndOffset >= 0xFFFFFFFFui64)		//	Start is always <= End
			{
				bI64Offsets = true;
				if (SupportsLargeFiles())
					break;
				SendCancelTransfer();
				SetDownloadState(DS_ERROR);
				return;
			}
		}
	}

	pos = m_pendingBlocksList.GetHeadPosition();
	if (bI64Offsets)
	{
		pPacket = new Packet(OP_REQUESTPARTS_I64, 64, OP_EMULEPROT);	// 64 = 16+(3*8)+(3*8)

		CMemFile	packetStream(reinterpret_cast<BYTE*>(pPacket->m_pcBuffer), 64);
		uint64	aqwStartEnd[6];

		packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
		for (uint32 i = 0; i < 3; i++)
		{
			if (pos != NULL)
			{
				pReqBlk = m_pendingBlocksList.GetNext(pos)->pReqBlock;
				aqwStartEnd[i] = pReqBlk->qwStartOffset;
				aqwStartEnd[i + ARRSIZE(aqwStartEnd) / 2] = pReqBlk->qwEndOffset + 1ui64;
			}
			else
			{
				aqwStartEnd[i] = 0;
				aqwStartEnd[i + ARRSIZE(aqwStartEnd) / 2] = 0;
			}
		}
		packetStream.Write(aqwStartEnd, sizeof(aqwStartEnd));
	}
	else
	{
		pPacket = new Packet(OP_REQUESTPARTS, 40);	// 40 = 16+(3*4)+(3*4)

		CMemFile	packetStream(reinterpret_cast<BYTE*>(pPacket->m_pcBuffer), 40);
		uint32	adwStartEnd[6];

		packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
		for (uint32 i = 0; i < 3; i++)
		{
			if (pos != NULL)
			{
				pReqBlk = m_pendingBlocksList.GetNext(pos)->pReqBlock;
				adwStartEnd[i] = static_cast<uint32>(pReqBlk->qwStartOffset);
				adwStartEnd[i + ARRSIZE(adwStartEnd) / 2] = static_cast<uint32>(pReqBlk->qwEndOffset) + 1;
			}
			else
			{
				adwStartEnd[i] = 0;
				adwStartEnd[i + ARRSIZE(adwStartEnd) / 2] = 0;
			}
		}
		packetStream.Write(adwStartEnd, sizeof(adwStartEnd));
	}

	g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED

	m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

	m_fBlocksWereRequested = 1;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/* Barry - Originally this only wrote to disk when a full 180k block
           had been received from a client, and only asked for data in
           180k blocks.

           This meant that on average 90k was lost for every connection
           to a client data source. That is a lot of wasted data.

           To reduce the lost data, packets are now written to a buffer
           and flushed to disk regularly regardless of size downloaded.
           This doesn't include compressed packets.

           Data is also requested only where gaps are, not in 180k blocks.
           The requests will still not exceed 180k, but may be smaller to
           fill a gap.
		Return:
			!= 0 - this client should be deleted by caller, else 0.
*/
int CUpDownClient::ProcessBlockPacket(byte *pbytePacket, uint32 dwPacketSize, bool bPacked, bool b64bOffsets)
{
	EMULE_TRY

//	Update timer (eklmn: don't remove this value cause it use to timeout check)
	m_dwLastBlockReceived = ::GetTickCount();

//	Read data from packet
	CSafeMemFile	packetStream(pbytePacket, dwPacketSize);
	uchar			fileHash[16];

	packetStream.Read(fileHash, sizeof(fileHash));				//<HASH>

//	Check that this data is for the correct file
	if (m_pReqPartFile == NULL || md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
	{
		throw CString(_T("wrong fileID sent, file: ") + ((m_pReqPartFile != NULL) ? m_pReqPartFile->GetFileName() : _T("NULL")));
	}

//	Find the start & end positions, and size of this chunk of data
	uint64			qwStartPos = 0, qwEndPos = 0;
	uint32			dwBlockSize = 0, dwHdrSz = 24;

	if (b64bOffsets)
	{
		packetStream.Read(&qwStartPos, sizeof(uint64));
		dwHdrSz += 4;
	}
	else
		packetStream.Read(&qwStartPos, sizeof(uint32));				//<BYTEOFFSET:DWORD> start position
	if (bPacked)
	{
		packetStream.Read(&dwBlockSize, sizeof(uint32));		//<BYTELENGTH:DWORD> packed block size
	}
	else
	{
		if (b64bOffsets)
		{
			packetStream.Read(&qwEndPos, sizeof(uint64));
			dwHdrSz += 4;
		}
		else
			packetStream.Read(&qwEndPos, sizeof(uint32));			//<BYTEOFFSET:DWORD> end position

	//	Check that packet size matches the declared packetStream packet + header size
		if (static_cast<uint64>(dwPacketSize) != (static_cast<uint64>(dwHdrSz) + qwEndPos - qwStartPos))
			throw CString(_T("corrupted or invalid data block received"));
	}
	const uint32	dwDataTransferdInPacket = dwPacketSize - dwHdrSz;

//	Protect from 0 data size, because it spoils statistics
	if (dwDataTransferdInPacket == 0)
		return 0;

//	Extended statistics information based on which client and remote port sent this data.
//	The new function adds the bytes to the grand total as well as the given client/port.
//	bFromPF is not relevant to downloaded data. It is purely an uploads statistic.
	g_App.m_pPrefs->Add2SessionDownTransferData(GetClientSoft(), dwDataTransferdInPacket);

	m_dwTransferredDown += dwDataTransferdInPacket;
	m_dwSessionDownloadedData += dwDataTransferdInPacket;
	m_dwTransferredInLastPeriod += dwDataTransferdInPacket;

//	Increment amount of data transferred for a file
	m_pReqPartFile->AddRxAmount(dwDataTransferdInPacket);

//	Loop through to find the reserved block that this is within
	Pending_Block_Struct	*cur_block;
	Requested_Block_Struct	*pReqBlk;

	POSITION pos1, pos2;

	for (pos1 = m_pendingBlocksList.GetHeadPosition(); (pos2 = pos1) != NULL; )
	{
		cur_block = m_pendingBlocksList.GetNext(pos1);
		pReqBlk = cur_block->pReqBlock;

		if ((pReqBlk->qwStartOffset <= qwStartPos) && (pReqBlk->qwEndOffset >= qwStartPos))
		{
		//	Found reserved block

			m_pCredits->AddDownloaded(dwDataTransferdInPacket, this->GetIP());

			if (cur_block->iZStreamErr != 0)
			{
			//	Increment file corruption statistics
				m_pReqPartFile->AddRxCorruptedAmount(dwDataTransferdInPacket);
			//	All data of corrupted block was received, delete the block to allow its reception on retransmission
				if ((cur_block->dwReceived += dwDataTransferdInPacket) >= dwBlockSize)
				{
				//	zstream is already deleted at that moment
					delete pReqBlk;
					delete cur_block;
					m_pendingBlocksList.RemoveAt(pos2);
				}
				break;
			}

		//	Remember this start pos, used to draw part downloading in list
			m_qwLastBlockOffset = qwStartPos;

		//	Occasionally packets are duplicated, no point writing it twice
		//	This will be 0 in these cases, or the length written otherwise
			uint32 lenWritten = 0;

		//	Handle differently depending on whether bPacked or not
			if (!bPacked)
			{
			//	Move end back one, should be inclusive
				qwEndPos--;
				cur_block->dwReceived += dwDataTransferdInPacket;

			//	Make sure only requested range is accepted to avoid corruptions
			//	Similar protection for compressed stream is done inside unzip() through
			//	output buffer size verification which is always not more than a block size
				if ( (qwEndPos > pReqBlk->qwEndOffset) ||
				//	Remove Hybrid, as it can generate such condition in rare cases
					( g_App.m_pPrefs->IsFakeRxDataFilterEnabled() &&
					(dwDataTransferdInPacket < 64) && (GetClientSoft() != SO_EDONKEYHYBRID) &&
					(static_cast<uint32>(pReqBlk->qwEndOffset - pReqBlk->qwStartOffset) > cur_block->dwReceived) ) )
				{
				//	Increment file corruption statistics
					m_pReqPartFile->AddRxCorruptedAmount(dwDataTransferdInPacket);
				//	Filter clients sending incorrect packets
					g_App.m_pIPFilter->AddTemporaryBannedIP(GetIP());
				//	If we're logging countermeasures...
					if (!g_App.m_pPrefs->IsCMNotLog())
						AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s (IP: %s) added to filtered clients due to bad data transmission"),
											GetClientNameWithSoftware(), GetFullIP() );
					return -1;	/*request deletion of this client by caller*/
				}

			//	Write to disk (will be buffered in part file class)
				lenWritten = m_pReqPartFile->WriteToBuffer( 0,
					pbytePacket + dwHdrSz, qwStartPos, qwEndPos,
					(qwEndPos >= pReqBlk->qwEndOffset) ? PF_WR2BUF_FL_ENDOFBLOCK : 0 );
#ifdef _DEBUG
				if (lenWritten == 0)
					AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Client %s"), GetClientNameWithSoftware());
#endif
			}
			else // Packed
			{
				uint32 lenUnzipped;

				cur_block->dwReceived += dwDataTransferdInPacket;

			//	Try to unzip
				int result = unzip(cur_block, pbytePacket + dwHdrSz, dwDataTransferdInPacket, &lenUnzipped);

				if (result == Z_OK)
				{
				//	Write any unzipped packetStream to disk
					if (lenUnzipped != 0)
					{
					//	Use the current start and end positions for the uncompressed packetStream
						qwStartPos = pReqBlk->qwStartOffset;
						qwEndPos = qwStartPos + static_cast<uint64>(lenUnzipped - 1);
					//	Write decompressed data to the file
						lenWritten = m_pReqPartFile->WriteToBuffer(
							lenUnzipped - cur_block->dwReceived, cur_block->pbyteRxDate,
							qwStartPos, qwEndPos, PF_WR2BUF_FL_FREEBUFFER | PF_WR2BUF_FL_ENDOFBLOCK );
					//	The buffer will be freed while flushing to the file
						cur_block->pbyteRxDate = NULL;
#ifdef _DEBUG
						if (lenWritten == 0)
							AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Client %s"), GetClientNameWithSoftware());
#endif
					//	Imitate end of block, if someone will send less data or more than one compression stream
						qwEndPos = pReqBlk->qwEndOffset;
					}
				}
				else
				{
					cur_block->iZStreamErr = result;
					AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Corrupted compressed packet for %s received (error %i)"), m_pReqPartFile->GetFileName(), result);
					m_pReqPartFile->RemoveBlockFromList(pReqBlk->qwStartOffset, pReqBlk->qwEndOffset);

				//	Release resources in case of decompression error
					if (cur_block->pZStream != NULL)
					{
						inflateEnd(cur_block->pZStream);
						delete cur_block->pZStream;
						cur_block->pZStream = NULL;
					}
					delete[] cur_block->pbyteRxDate;
					cur_block->pbyteRxDate = NULL;

				//	Increment file corruption statistics
					m_pReqPartFile->AddRxCorruptedAmount(cur_block->dwReceived);
				//	All data of corrupted block was received, delete the block to allow its reception on retransmission
					if (cur_block->dwReceived >= dwBlockSize)
					{
						delete pReqBlk;
						delete cur_block;
						m_pendingBlocksList.RemoveAt(pos2);
					}
					break;
				}
			}

		//	Check result of WriteToBuffer, if we save some bytes then
		//	this DL session can be counted as successful
			if (lenWritten > 0)
			{
			//	To determine whether the current download session was successful or not
				m_bTransferredDownMini = true;
			}

		//	We need to check "END of the block" condition every time, because if a remote client
		//	sends us data which was already written we will not delete the block & packet

			if (qwEndPos >= pReqBlk->qwEndOffset)
			{
				m_pReqPartFile->RemoveBlockFromList(pReqBlk->qwStartOffset, pReqBlk->qwEndOffset);
				delete pReqBlk;

			//	That should never happen
				if (cur_block->pZStream != NULL)
				{
					inflateEnd(cur_block->pZStream);
					delete cur_block->pZStream;
				}

				delete cur_block;
				m_pendingBlocksList.RemoveAt(pos2);

#if 0	// disable as newer versions were fixed
			//	MLdonkey messes up and sends data several times when standard request
			//	scheme with repeated block requests is in use, thus request only when
			//	there's no more pending requests to avoid transmission of useless data
				if ((GetClientSoft() != SO_MLDONKEY) || (m_pendingBlocksList.GetCount() == 0))
#endif
				SendBlockRequests();	//	Request next block
			}

		//	Stop looping and exit method
			break;
		}
	}

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CUpDownClient::unzip(Pending_Block_Struct *pPendingBlk, BYTE *pbyteZipped, uint32 dwLenZipped, uint32 *pdwLenUnzipped)
{
	int iErr = Z_MEM_ERROR;

	EMULE_TRY

	z_stream *zS = pPendingBlk->pZStream;

//	Is this the first time this block has been unzipped
	if (zS == NULL)
	{
	//	Allocate stream
		zS = pPendingBlk->pZStream = new z_stream;

	//	Initialize stream values
		zS->zalloc = (alloc_func)0;
		zS->zfree = (free_func)0;

	//	Allocate and initialize output buffer
		zS->avail_out = static_cast<unsigned>(pPendingBlk->pReqBlock->qwEndOffset - pPendingBlk->pReqBlock->qwStartOffset + 1);
		zS->next_out = pPendingBlk->pbyteRxDate = new BYTE[zS->avail_out];

	//	Initialise the z_stream
		iErr = inflateInit(zS);

		if (iErr != Z_OK)
			return iErr;
	}

//	Initialize input buffer
	zS->next_in = pbyteZipped;
	zS->avail_in = dwLenZipped;

//	Unzip the data
	iErr = inflate(zS, Z_SYNC_FLUSH);

	*pdwLenUnzipped = 0;
	if (iErr == Z_OK)
	{
		if (zS->avail_out == 0)
		{
		//	Output buffer is full, more than required data was sent or error occurred
			iErr = Z_BUF_ERROR;
		}
	}
//	Is zip finished reading all currently available input and writing all generated output
	else if (iErr == Z_STREAM_END)
	{
	//	Finish up
		inflateEnd(zS);
		pPendingBlk->pZStream = NULL;

		iErr = Z_OK;
	//	Got the good result, return unzipped amount
		*pdwLenUnzipped = zS->total_out;
		delete zS;
	}

	EMULE_CATCH

	return iErr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
uint32 CUpDownClient::DownloadProcess(uint32 dwReduceDownload /*in percent*/)
{
	EMULE_TRY

	uint32	dwCurTick = GetTickCount();

	if ((dwCurTick - m_dwLastBlockReceived) > DOWNLOADTIMEOUT)
	{
	//	Wait a little bit more for slow clients, what helps to save some downloads
		if ((m_dwDownDataRate == 0) || (m_dwDownDataRate > 1000) || ((dwCurTick - m_dwLastBlockReceived) >= 150000))
		{
			UpdateOnqueueDownloadState();
			SendCancelTransfer();
		}
	}
	else
	{
		uint32 time_diff_ms = dwCurTick - m_dwLastDataRateCalculationTime;
		uint32 dwLastTransferred = m_dwTransferredInLastPeriod;

	//	Update time & reset data transferred over last period
		m_dwTransferredInLastPeriod = 0;
		m_dwLastDataRateCalculationTime = dwCurTick;

	//	Update average sum
		m_dwClientSumDLDataRateOverLastNMeasurements += dwLastTransferred;
		m_dwClientSumDLTickOverLastNMeasurements += time_diff_ms;
	//	Update lists
		m_averageDLDataRateList.push_front(dwLastTransferred);
		m_averageDLTickList.push_front(time_diff_ms);

	//	Check lists size
		while (m_averageDLTickList.size() > (DOWNLOADTIMEOUT / 100))
		{
			m_dwClientSumDLDataRateOverLastNMeasurements -= m_averageDLDataRateList.back();
			m_averageDLDataRateList.pop_back();
			m_dwClientSumDLTickOverLastNMeasurements -= m_averageDLTickList.back();
			m_averageDLTickList.pop_back();
		}

		uint32 dwAverageTransferTimePeriod;

		if (m_dwClientSumDLTickOverLastNMeasurements != 0)
		{
		//	Calculate average time period between measuremets (ms)
			dwAverageTransferTimePeriod = m_dwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();

		//	Calculate a DL rate (b/s)
			m_dwDownDataRate = static_cast<uint32>((1000 * static_cast<uint64>(m_dwClientSumDLDataRateOverLastNMeasurements)) / static_cast<uint64>(m_dwClientSumDLTickOverLastNMeasurements));
		}
		else
		{
			dwAverageTransferTimePeriod = 100;
		//	Calculate a DL rate (b/s) assuming 100 ms interval
			m_dwDownDataRate = 10 * m_dwClientSumDLDataRateOverLastNMeasurements;
		}

	//	now based on measured speed we can control the bandwidth
		if (dwReduceDownload)
		{
			m_bLimitlessDL = false;
		//	the limit for next period is calculated as required DL per millisecond multiplicated by the time period.
		//		required DL (Byte/s) = percent * measured DL (Byte/s)
		//		required DL (Byte/ms) = required DL (Byte/s) / 1000
		//		Limit = required DL (Byte/ms) * sample period (ms)
		//	The previous formula assumed 100ms period between two speed calculations
		//		uint32 limit = dwReduceDownload * dwCurrentDataRate / 1000;
		//			where dwReduceDownload = percent * 100
		//	Since we are calculating the average period value, then we gonna use this value
			uint32 dwUpperLimit = (m_dwDownDataRate * dwAverageTransferTimePeriod) / 100 * dwReduceDownload / 1000;
			uint32 dwLowerLimit = (200 * dwAverageTransferTimePeriod)/1000;

			if (dwUpperLimit < 1000 && dwReduceDownload == 200)
				dwUpperLimit += 1000;
			else if (dwUpperLimit < dwLowerLimit)
				dwUpperLimit = dwLowerLimit;
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SetDownloadLimit(dwUpperLimit);
#endif
		}
#ifdef OLD_SOCKETS_ENABLED
		else if (!m_bLimitlessDL)
		{
			m_pRequestSocket->DisableDownloadLimit();
			m_bLimitlessDL = true;
		}
#endif
	}

	UpdateDisplayedInfo();

	return m_dwDownDataRate;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetRemoteQueueRank(uint16 nr, bool bUpdateGUI /*= true*/)
{
	EMULE_TRY

	m_iDeltaQueueRank = static_cast<int>(nr) - static_cast<int>(m_uRemoteQueueRank);
	if (m_iDeltaQueueRank != 0)
	{
		//	if client sent us an opcode with non-0 rank, that it means we are on his WQ
		//	so if we had 0 rank before just enter into his WQ
		if (m_uRemoteQueueRank == 0)
			StartDLQueueWaitTimer();

		m_uRemoteQueueRank = nr;
		if (bUpdateGUI)
			UpdateDisplayedInfo();
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A4AF switching
bool CUpDownClient::SwapToAnotherFile(CPartFile* SwapTo, uint32 dwOptions /*= 0*/)
{
	EMULE_TRY

//	Check if we are downloading something from client
	if (GetDownloadState() == DS_DOWNLOADING)
		return false;

//	Check: does client have another file?
	if (!m_otherRequestsList.IsEmpty())
	{
		CPartFile	*pPausedPartFile = NULL;
		POSITION	PausedFilePos = 0;
		POSITION	SwapToPos = 0;
		uint32		dwCurTick = ::GetTickCount();
		uint32		dwLastNNSCheckedTime = dwCurTick;
		bool		bIsFileReaskAllowed = true;
		BOOL		bNNS;
	
	//	Check: target file is specified? if is not, then find another one...
		if (!SwapTo)
		{
		//	Try to find a file in the same category
			CPartFile		*pCurFile;
			POSITION		cur_FilePos;
			POSITION		pos;
			uint32			dwA4AFRating;
			uint32			dwBestA4AFRating = 0;
			bool		bFoundInSameCat = false;

			for (pos = m_otherRequestsList.GetHeadPosition(); pos != NULL;)
			{
				pCurFile = m_otherRequestsList.GetNext(pos);
				if (CCat::FileBelongsToGivenCat(pCurFile, m_pReqPartFile->GetCatID()))
				{
					bFoundInSameCat = true;
					break;
				}
			}

		//	Find a file to switch to (now taking in account alphabetic order inside categories
		//	Do not change the way it's done (for loop and pCurFile assignment) because, I don't know why,
		//	it produces unexpected results. :(
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != 0;m_otherRequestsList.GetNext(cur_FilePos))
			{
				pCurFile = m_otherRequestsList.GetAt(cur_FilePos);

			//	Get first high priority files
				if (pCurFile != m_pReqPartFile && g_App.m_pDownloadQueue->IsInDLQueue(pCurFile))
				{
					EnumPartFileStatuses eStatus = pCurFile->GetStatus();

				//	allow switch to files with active status with 
					if (eStatus == PS_READY || eStatus == PS_EMPTY)
					{
					//	Check: is new file in NNS-Map?
						bNNS = m_otherNoNeededMap.Lookup(pCurFile, dwLastNNSCheckedTime);

					//	Calculate A4AF rating
						if (bNNS)
						{
							dwA4AFRating = (pCurFile->GetPriority() + 1) +
											((dwCurTick - dwLastNNSCheckedTime) / FILEREASKTIME);
							bIsFileReaskAllowed = (dwCurTick - dwLastNNSCheckedTime) > FILEREASKTIME;
						}
						else
						{
							dwA4AFRating = (pCurFile->GetPriority() + 1) * 3;
							bIsFileReaskAllowed = true;
						}

						if ((dwA4AFRating >= dwBestA4AFRating) 
							&& (bIsFileReaskAllowed || (dwOptions & A4AF_IGNORE_TIME_LIMIT)))
						{
							if((SwapTo == NULL) || !bFoundInSameCat || (SwapTo->GetFileName() > pCurFile->GetFileName()))
							{
								SwapTo = pCurFile;
								SwapToPos = cur_FilePos;
								dwBestA4AFRating = dwA4AFRating;
							}
						}
					}
					else if ((eStatus == PS_PAUSED) && (dwOptions & A4AF_TO_PAUSED))
					{
						pPausedPartFile = pCurFile;
						PausedFilePos = cur_FilePos;
					}
				}
			}
		}
		else if (SwapTo->GetStatus() == PS_READY || SwapTo->GetStatus() == PS_EMPTY)
		{
			bNNS = m_otherNoNeededMap.Lookup(SwapTo, dwLastNNSCheckedTime);

			if (bNNS)
			{
				bIsFileReaskAllowed = (dwCurTick - dwLastNNSCheckedTime) > FILEREASKTIME;
			}
			if (!bNNS || bIsFileReaskAllowed || (dwOptions & A4AF_IGNORE_TIME_LIMIT))
			{
				SwapToPos = m_otherRequestsList.Find(SwapTo);
			}
		}

	// if after one way swap only paused files exist, switch to the paused files
		if ((dwOptions & A4AF_TO_PAUSED) && (SwapTo == NULL) && (pPausedPartFile != NULL))
		{
			SwapTo = pPausedPartFile;
			SwapToPos = PausedFilePos;
		}

	//	Now let's swap the file to another
		if ((SwapTo != NULL) && (SwapTo != m_pReqPartFile) && (SwapToPos != 0))
		{
		//	Remove new file from OtherRequests list
			m_otherRequestsList.RemoveAt(SwapToPos);

		//	To prevent loop swapping remove a choosen part from NNS-Map
			m_otherNoNeededMap.RemoveKey(SwapTo);

		//	Remove current source from A4AF list in new file
			SwapTo->RemoveClientFromA4AFSourceList(this);

		//	To prevent loop swapping remember NNS-Part & time when it was switched
			if (dwOptions & A4AF_ONE_WAY)
				m_otherNoNeededMap.RemoveKey(m_pReqPartFile);
			else if ( m_pReqPartFile != NULL /* && GetDownloadState() == DS_NONEEDEDPARTS */ )
			{
				m_otherNoNeededMap[m_pReqPartFile] = dwCurTick;
			}

			ClearPartStatuses();
		//	Reset the filename to prevent the user misinformation in case of delayed request (for example LowID)
			m_strClientFilename.Empty();

			ResetLastAskedTime();
			m_uLastPartAsked = 0xFFFF;

			if (m_pReqPartFile != NULL)
			{
			//	Add to past comment
				m_pReqPartFile->CheckAndAddPastComment(this);
				m_eRating = PF_RATING_NONE;
				m_strComment.Empty();

			//	Remove current file
				m_pReqPartFile->RemoveClientFromDLSourceList(this);

			// add the client to the list if it's not required to remove him
				if (!(dwOptions & A4AF_ONE_WAY))
				{
				//	Add them in A4AF list
					m_pReqPartFile->AddClientToA4AFSourceList(this);

				//	Add old file to m_otherRequestsList
					if (!m_otherRequestsList.Find(m_pReqPartFile))
						m_otherRequestsList.AddTail(m_pReqPartFile);
				}

			//	Update download list (old file update)
				m_pReqPartFile->UpdateDisplayedInfo();
			}

		//	Actual switch
			SetDLRequiredFile(SwapTo);

		//	Add to the source list
		//	Note: don't change the state if a client is in connection state,
		//	in order to prevent the second connection to the same client
			if (GetDownloadState() == DS_CONNECTING
				|| GetDownloadState() == DS_WAITCALLBACK
				|| GetDownloadState() == DS_WAIT_FOR_FILE_REQUEST)
			{
				SwapTo->AddClientToSourceList(this, GetDownloadState());
			}
			else
			{
			//	The client will be added indirectly, but only in case if m_pReqPartFile was defined
				SetDownloadState(DS_WAIT_FOR_FILE_REQUEST);
			}

		//	Remove from past comment
			SwapTo->RemovePastComment(this);

		//	Update download list (new file update)
			SwapTo->UpdateDisplayedInfo();

		//	Now update the client item
			UpdateDisplayedInfo();

			return (m_pReqPartFile != NULL);
		}
	}

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::UDPReaskACK(uint16 nNewQR)
{
	EMULE_TRY

	m_bUDPPending = false;
	m_byteNumUDPPendingReqs = 0;
	SetRemoteQueueRank(nNewQR);
	SetLastAskedTime();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::UDPReaskFNF()
{
	EMULE_TRY

	m_bUDPPending = false;
	m_byteNumUDPPendingReqs = 0;

	if (GetDownloadState() != DS_DOWNLOADING)
	{
	//	Copy the current value as SwapToAnotherFile will change it
		CPartFile	*pPartFile = m_pReqPartFile;

	//	Try to swap the source to another file before removing it from DL-queue
		if (!SwapToAnotherFile(NULL, A4AF_REMOVE))
		{
#ifdef OLD_SOCKETS_ENABLED
		//	if client have socket or was not removed indirectly over disconnection, remove him from DLQ
			if ((m_pRequestSocket == NULL) && !Disconnected())
			{
				if (m_eUploadState == US_NONE)
					delete this;
				else
					g_App.m_pDownloadQueue->RemoveSource(this, true);
			}
#endif //OLD_SOCKETS_ENABLED
		}
		else
			g_App.m_pDownloadList->RemoveSource(this, pPartFile);
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::UDPReaskForDownload()
{
	EMULE_TRY

#ifdef OLD_SOCKETS_ENABLED
	uint32 dwCurTick = ::GetTickCount();

	m_bUDPPending = true;
	m_byteNumUDPPendingReqs++;
	m_dwNextFileReaskTime = dwCurTick + ((IsOnLAN()) ? LANCASTFILEREASKTIME : UDPFILEREASKTIMEOUT);

	CSafeMemFile	packetStream(128);

	packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
	if (GetUDPVersion() > 3)
	{
		if (m_pReqPartFile->IsPartFile())
			((CPartFile*)m_pReqPartFile)->WritePartStatus(&packetStream);
		else
		{
			uint16	uNull = 0;

			packetStream.Write(&uNull, 2);
		}
	}
	if (GetUDPVersion() > 2)
	{
		uint16	uCompleteSourcesCount = m_pReqPartFile->GetCompleteSourcesCount();
		packetStream.Write(&uCompleteSourcesCount, 2);
	}

	Packet		*pPacket = new Packet(&packetStream, OP_EMULEPROT);

	pPacket->m_eOpcode = OP_REASKFILEPING;

	g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
	g_App.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort(), ShouldReceiveCryptUDPPackets(), GetUserHash(), false, 0);

	AddAskedCountDown();

	return true;
#endif //OLD_SOCKETS_ENABLED

	EMULE_CATCH

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Sets the vector of bool 'parts' to show the pending status of each part.
void CUpDownClient::ShowDownloadingParts(_Bvector& parts)
{
	EMULE_TRY

	parts.resize(m_uPartCount);

	for (POSITION pos = m_pendingBlocksList.GetHeadPosition(); pos != NULL; )
		parts[static_cast<uint32>(m_pendingBlocksList.GetNext(pos)->pReqBlock->qwStartOffset / PARTSIZE)] = true;

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::UpdateDisplayedInfo()
{
	g_App.m_pDownloadList->UpdateSource(this);
	g_App.m_pMDlg->m_wndTransfer.m_ctlClientList.UpdateClient(this);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ClearPendingBlocksList(void)
{
	EMULE_TRY

	Pending_Block_Struct*		pPendingBlock;

	while (!m_pendingBlocksList.IsEmpty() )
	{
		pPendingBlock = m_pendingBlocksList.RemoveHead();

		if (pPendingBlock != NULL)
		{
			CPartFile *pReqFile = g_App.m_pDownloadQueue->GetFileByID(pPendingBlock->pReqBlock->m_fileHash);

			if (pPendingBlock->pZStream != NULL)
			{
				uint32	dwTotalOut;

				if ((dwTotalOut = pPendingBlock->pZStream->total_out) != 0)
				{
				//	Some data was decompressed

				//	Force file write of partly received compressed block
				//	The data buffer will be freed while flushing to the file
					if ( pReqFile->WriteToBuffer( dwTotalOut - pPendingBlock->pZStream->total_in,
						pPendingBlock->pbyteRxDate, pPendingBlock->pReqBlock->qwStartOffset,
						pPendingBlock->pReqBlock->qwStartOffset + static_cast<uint64>(dwTotalOut - 1),
						PF_WR2BUF_FL_FREEBUFFER | PF_WR2BUF_FL_ENDOFBLOCK ) != 0 )
					{
					//	As we save some bytes then this DL session can be counted as successful
						m_bTransferredDownMini = true;
					}
				}
				inflateEnd(pPendingBlock->pZStream);
				delete pPendingBlock->pZStream;
			}
			pReqFile->RemoveBlockFromList(pPendingBlock->pReqBlock->qwStartOffset,
										pPendingBlock->pReqBlock->qwEndOffset);
			delete pPendingBlock->pReqBlock;
			delete pPendingBlock;
		}
	}

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	If downloadBlocks are existing free block reserved in pPartFile
void CUpDownClient::ClearDownloadBlocksList(void)
{
	while (!m_downloadBlocksList.IsEmpty())
	{
		Requested_Block_Struct	*pDLBlock = m_downloadBlocksList.RemoveHead();

		if (pDLBlock != NULL)
		{
			CPartFile* pReqFile = g_App.m_pDownloadQueue->GetFileByID(pDLBlock->m_fileHash);

			pReqFile->RemoveBlockFromList(pDLBlock->qwStartOffset, pDLBlock->qwEndOffset);
			delete pDLBlock;
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendStartUploadRequest()
{
	Packet	*pPacket = NULL;

	try
	{
		if (m_pReqPartFile != NULL && m_pRequestSocket != NULL)
		{
			pPacket = new Packet(OP_STARTUPLOADREQ, 16);

			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

			SetLastAskedTime();
		}
	}
	catch (CException *error)
	{
		safe_delete(pPacket);
		g_App.m_pMDlg->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
		error->Delete();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendHashsetRequest()
{
	Packet	*pPacket = NULL;

	try
	{
		if (m_pReqPartFile != NULL)
		{
			pPacket = new Packet(OP_HASHSETREQUEST, 16);

			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

			SetDownloadState(DS_REQHASHSET);
			m_pReqPartFile->m_bHashSetNeeded = false;
			m_fRequestingHashSet = 1;

			AddLogLine(LOG_FL_DBG, _T("Sent hashset request with filehash %s to client %s"), HashToString(m_pReqPartFile->GetFileHash()), GetClientNameWithSoftware());
		}
	}
	catch (CException *error)
	{
		safe_delete(pPacket);
		g_App.m_pMDlg->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
		error->Delete();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// return the remainig download time for the current chunk in seconds
uint32 CUpDownClient::GetRemainingTimeForCurrentPart()
{
	uint32	dwDownloadingPart, dwSecond = 0;

	if ( (m_pReqPartFile != NULL) && (m_eDownloadState == DS_DOWNLOADING) &&
		!m_pendingBlocksList.IsEmpty() && (m_dwDownDataRate != 0) )
	{
		dwDownloadingPart = static_cast<uint32>(m_pendingBlocksList.GetHead()->pReqBlock->qwStartOffset / PARTSIZE);
		dwSecond = m_pReqPartFile->GetPartLeftToDLSize(dwDownloadingPart) / m_dwDownDataRate;
	}

	return dwSecond;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// return the remainig download size for the current chunk in bytes as well as currently downloading part
uint32 CUpDownClient::GetRemainingSizeForCurrentPart(uint32 *pdwDownloadingPart)
{
	uint32 dwSize = 0;

	if ((m_pReqPartFile != NULL) && (m_eDownloadState == DS_DOWNLOADING) && !m_pendingBlocksList.IsEmpty())
	{
		*pdwDownloadingPart = static_cast<uint32>(m_pendingBlocksList.GetHead()->pReqBlock->qwStartOffset / PARTSIZE);
		dwSize = m_pReqPartFile->GetPartLeftToDLSize(*pdwDownloadingPart);
	}

	return dwSize;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendCancelTransfer()
{
	if (m_pRequestSocket != NULL)
	{
		Packet	*pPacket = NULL;

		if (m_fSentCancelTransfer)
			return;
		try
		{
			pPacket = new Packet(OP_CANCELTRANSFER, 0);

			g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);

#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif
			m_fSentCancelTransfer = 1;
		}
		catch (CException *error)
		{
			safe_delete(pPacket);
			g_App.m_pMDlg->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
			error->Delete();
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::ClearPartStatuses()
{
	delete[] m_pbytePartStatuses;
	m_pbytePartStatuses = NULL;
	m_uPartCount = m_uAvailPartCount = m_uNeededParts = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetLastAskedTime()
{
	m_dwLastAskedTime = ::GetTickCount();

	SetNextFileReaskTime();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SetNextFileReaskTime()
{
	if (IsOnLAN())
	{
		m_dwNextFileReaskTime = m_dwLastAskedTime + LANCASTFILEREASKTIME;
		return;
	}

	m_dwNextFileReaskTime = m_dwLastAskedTime + FILEREASKTIME;

	if (GetDownloadState() == DS_ONQUEUE)
	{
		uint32	dwQueueRank = static_cast<uint32>(GetRemoteQueueRank());

	//	Increase the interval if remote queue is full or we have a low rank
	//	In case when rank is unknown (dwQueueRank = 0), normal reask period is used
		if (dwQueueRank > QUEUERANK_LOW)
			m_dwNextFileReaskTime += g_App.m_pServerConnect->IsLowID() ? (FILEREASKTIME / 4) : (FILEREASKTIME / 2);
	//	Increase reask time to LowID clients to give the remote client a chance to connect first
		else if (HasLowID() && !g_App.m_pServerConnect->IsLowID())
			m_dwNextFileReaskTime += HIGH2LOW_REASKDELAY;
	}
	else if (GetDownloadState() == DS_NONEEDEDPARTS)
	{
		m_dwNextFileReaskTime += FILEREASKTIME / 2;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CUpDownClient::IsUDPRequestAllowed()
{
//	Disable UDP...
//	...if we have more than 3 pending UDP requests in a row (UDP is blocked)
	if (m_bUDPPending || (m_byteNumUDPPendingReqs > 3))
		return false;
//	...for old versions
	if (m_byteEmuleVersion < 0x23)
		return false;
//	...in case of wrong UDP port settings
	if ((m_uUDPPort == 0) || (g_App.m_pPrefs->GetUDPPort() == 0))
		return false;
//	...if local client is already connected to remote client over TCP
	if ((m_pRequestSocket != NULL) && (m_pRequestSocket->IsConnected() || m_pRequestSocket->IsConnecting()))
		return false;
//	...if one of clients has LowID
	if (g_App.m_pServerConnect->IsLowID() || HasLowID())
		return false;
//	...when connecting to a PROXY
	if (g_App.m_pPrefs->GetProxySettings().m_bUseProxy)
		return false;

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CUpDownClient::SendReask()
{
//	Try to request the file status over UDP before TCP request
	if (IsUDPRequestAllowed() && !IsSourceRequestAllowed())
		UDPReaskForDownload();
	else
		AskForDownload();
}
@


1.398
log
@Reduced H-file dependency.
@
text
@d27 1
@


1.397
log
@Encryption preparations.
@
text
@d31 1
@


1.396
log
@Don't initiate file reasks to the uploading source on file completion to avoid protocol collisions (and save on traffic).
@
text
@d31 1
d1695 1
a1695 1
	g_App.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort());
@


1.395
log
@Fixed a loss of the connected source on file completion (A4AF source or remote source will lose position in our queue; this was introduced in v1.2e with code restructoring similar to original) {glaskrug}.
@
text
@d866 3
a868 3
	//	If we have nothing to request from a full source, then probably all blocks were
	//	already requested (file will be complete soon), thus no need to send any reasks
		if (IsCompleteSource())
@


1.394
log
@Reduced H-file dependency.
@
text
@d29 1
d359 1
a359 1
void CUpDownClient::ProcessFileHash(CSafeMemFile &packetStream)
d364 1
d366 10
d377 1
a377 2

	packetStream.Read(fileHash, sizeof(fileHash));
d392 1
@


1.393
log
@Fixed log message formatting.
@
text
@d26 3
@


1.392
log
@Clarifying comment.
@
text
@d374 2
a375 2
			pPartFile->GetFileName(), pPartFile->GetFileHash(),
			m_pReqPartFile->GetFileName(), m_pReqPartFile->GetFileHash());
@


1.391
log
@Fixed potential corruption of already received and veryfied data.
@
text
@d1084 2
@


1.390
log
@Reduced H-file dependency.
@
text
@d1083 4
a1086 2
			//	Remove Hybrid, as it can generate such condition in rare cases
				if ( g_App.m_pPrefs->IsFakeRxDataFilterEnabled() &&
d1088 1
a1088 1
					(static_cast<uint32>(pReqBlk->qwEndOffset - pReqBlk->qwStartOffset) > cur_block->dwReceived) )
d1096 1
a1096 1
						AddLogLine( LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s (IP: %s) added to filtered clients due to bad data"),
d1154 1
a1154 1
					delete [] cur_block->pbyteRxDate;
@


1.389
log
@Reduced #include dependency.
@
text
@d28 1
@


1.388
log
@Added multipacket encoding support (helps to combine several packets together for p2p handshaking, as a result slightly reduces overhead and handshaking time) [eklmn/Aw3].
@
text
@d27 1
@


1.387
log
@Removed special downloading improvement against old MLdonkey clients (this issue was fixed in MLdonkey long time ago, so we drop special downloading logic used as a workaround).
@
text
@d238 54
d352 26
d383 1
a383 1
	uchar		fileHash[16];
d385 1
a385 1
	packetStream.Read(fileHash, sizeof(fileHash));
d387 4
a390 1
	SetLastAskedTime();
d392 3
a394 5
//	Patch 'fix disappearing m_pReqPartFile'
	if (m_pReqPartFile == NULL)
	{
	//	try to find the file with given hash in our DL list
		SetDLRequiredFile(g_App.m_pDownloadQueue->GetFileByID(fileHash));
d396 1
a396 11
	//	if the search was not succesfull, then we don't need this file anymore (perhaps it was canceled)
		if (m_pReqPartFile == NULL)
		{
			m_strClientFilename.Empty();
			AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s: offered file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(fileHash));
			return;
		}
	}
	
//	report about difference in requested & accepted hash
	if (md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
d398 6
a403 1
		CPartFile	*pReqFileDownloading = g_App.m_pDownloadQueue->GetFileByID(fileHash);
d405 5
a409 9
		if (pReqFileDownloading)
			AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s: offered file was not requested (offered: %s | requested: %s)"), GetClientNameWithSoftware(), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
		else
			AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s: offered file was not requested (offered hash: %s | requested file: %s)"), GetClientNameWithSoftware(), HashToString(fileHash), m_pReqPartFile->GetFileName());
	}
//	otherwise process the rest of the packet 
	else
	{
		uint16	uNameLength;
d411 1
a411 4
		packetStream.Read(&uNameLength, sizeof(uint16));
		ReadMB2Str(m_eStrCodingFormat, &m_strClientFilename, packetStream, uNameLength);
	//	Shrink class member, as allocated container of returned string can be larger than string length
		m_strClientFilename.FreeExtra();
d413 2
a414 24
	//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
	//	if the remote client answers OP_REQUESTFILENAME with OP_REQFILENAMEANSWER the file is shared by the remote client. if we
	//	know that the file is shared, we know also that the file is complete and don't need to request the file status.

		if (m_pReqPartFile->GetPartCount() == 1)
		{
			m_uAvailPartCount = 0;	// keep it zero while doing preparation
			delete[] m_pbytePartStatuses;
			m_pbytePartStatuses = NULL;
			m_pbytePartStatuses = new byte[1];
			memset(m_pbytePartStatuses, 1, 1);
			m_uPartCount = m_uAvailPartCount = m_uNeededParts = 1;

		//	even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
			if (m_pReqPartFile->m_bHashSetNeeded)
				SendHashsetRequest();
			else if (GetDownloadState() != DS_DOWNLOADING) 
				SendStartUploadRequest();

			UpdateDownloadStateAfterFileReask();

			m_pReqPartFile->NewSrcPartsInfo();
			UpdateDisplayedInfo();
		}
d420 1
a420 1
void CUpDownClient::ProcessFileStatus(CSafeMemFile *packetStream, CPartFile *pReqPartFile, bool bUDPPacket/*=false*/)
a423 19
	if (m_pReqPartFile == NULL)
	{
		SetDLRequiredFile(pReqPartFile);

		if (m_pReqPartFile == NULL)
		{
//		This line not needed as mostly paired with other error stating just something similar
//			AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s: no file stated"), GetClientNameWithSoftware());
			return;
		}
	}
	else if (m_pReqPartFile != pReqPartFile)
	{
//		This line not needed as mostly paired with other error stating just something similar
//		AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Client %s: wrong file stated (%s)"), GetClientNameWithSoftware(),
//						 pReqPartFile ? pReqPartFile->GetFileName() : _T("NULL") );
		return;
	}

d426 1
a426 1
	packetStream->Read(&uED2KPartCount, 2);
d464 1
a464 1
			packetStream->Read(&byteToRead, 1);
@


1.386
log
@Preparation to added extended multipacket encoding support [eklmn/Aw3];
Slightly unified and reorganized IsSourceRequestAllowed [eklmn/Aw3].
@
text
@d1164 1
d1169 2
a1170 1
					SendBlockRequests();	//	Request next block
@


1.385
log
@Fixed A4AF sources attached to complete file, plus sometimes incorrect A4AF source count {DonGato/DopeFish/muleteer/Vladimir (SV)/glaskrug}.
@
text
@d179 17
d197 7
a203 1
	uint32	dwTickCount =  dwCurrentTick + CONNECTION_LATENCY;
a206 1
	uint32	dwSources = m_pReqPartFile->GetSourceCount();
a207 2
//	Original client return false if client's SourceExchange Version is less or equal than 1
//	but I think we need to keep compatibility with old ePlus versions
d209 10
a218 20
			//	If client has the correct extended protocol
				ExtProtocolAvailable() && (SupportsSourceExchange2() || (GetSourceExchange1Version() >= 1)) &&
			//	AND if we can send sources
				!g_App.m_pPrefs->IsDisabledXS() &&
			//	AND if we need more sources or is allowed to drop sources
				(g_App.m_pPrefs->GetMaxSourcePerFileSoft() > dwSources ||
					(m_pReqPartFile->GetLastPurgeTime() + PURGE_TIME) < dwCurrentTick) &&
			//	AND if...
				(
				//	source is not complete and file is rare, allow once every 10 minutes
					( !IsCompleteSource()
						&& (dwSources <= RARE_FILE * 2
							|| m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4 )
						&& (bNeverAskedBefore || dwTimePassedClient > SOURCECLIENTREASK) )
				//	otherwise, allow every 90 minutes, but only if we haven't
				//	asked someone else in last 10 minutes
					|| ( (bNeverAskedBefore || dwTimePassedClient > (unsigned)(SOURCECLIENTREASK * MINCOMMONPENALTY)) &&
						(dwTimePassedFile > SOURCECLIENTREASK) )
				)
			);
a228 2
	ASSERT(m_pReqPartFile != NULL);

d234 1
a234 1
	CMemFile	pckStrm(16 + 3 + 58 + 2);	// enough for 4GB without reallocation
a237 1
	if (GetExtendedRequestsVersion() > 0)
d239 6
a244 4
		m_pReqPartFile->WritePartStatus(&pckStrm);
		if (GetExtendedRequestsVersion() > 1)
			m_pReqPartFile->WriteCompleteSourcesCount(&pckStrm);
	}
d246 1
a246 1
	Packet		*pPacket = new Packet(&pckStrm);
d248 2
a249 2
	pPacket->m_eOpcode = OP_REQUESTFILENAME;
	g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d251 1
a251 1
	m_pRequestSocket->SendPacket(pPacket, true);
d254 6
a259 6
//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//	if the remote client answers OP_REQUESTFILENAME with OP_REQFILENAMEANSWER the file is shared by the remote client. if we
//	know that the file is shared, we know also that the file is complete and don't need to request the file status.
	if (m_pReqPartFile->GetPartCount() > 1)
	{
		pPacket = new Packet(OP_SETREQFILEID, 16);
d261 2
a262 2
		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_App.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d264 1
a264 1
		m_pRequestSocket->SendPacket(pPacket, true);
d266 1
a266 1
	}
d268 3
a270 11
	if ( g_App.m_pPrefs->GetMaxSourcePerFileSoft() < m_pReqPartFile->GetSourceCount()
		|| g_App.m_pPrefs->IsDisabledXS() )
	{
		return;
	}
//	Disable XS for up to X sources
	if ( g_App.m_pPrefs->DisableXSUpTo()
		&& g_App.m_pPrefs->XSUpTo() < m_pReqPartFile->GetSourceCount() )
	{
		return;
	}
d272 1
a272 3
	if (IsSourceRequestAllowed())
	{
		char	*pcPktPos;
d274 3
a276 1
		m_pReqPartFile->SetLastAnsweredTimeTimeout();
d278 11
a288 15
		if (SupportsSourceExchange2())
		{
			pPacket = new Packet(OP_REQUESTSOURCES2, 19, OP_EMULEPROT);

			pPacket->m_pcBuffer[0] = SOURCEEXCHANGE2_VERSION;
			POKE_WORD(&pPacket->m_pcBuffer[1], 0);	// Options (Reserved)
			pcPktPos = &pPacket->m_pcBuffer[3];
		}
		else
		{
			pPacket = new Packet(OP_REQUESTSOURCES, 16, OP_EMULEPROT);
			pcPktPos = pPacket->m_pcBuffer;
		}
		md4cpy(pcPktPos, m_pReqPartFile->GetFileHash());
		g_App.m_pUploadQueue->AddUpDataOverheadSourceExchange(pPacket->m_dwSize);
d290 1
a290 1
		m_pRequestSocket->SendPacket(pPacket, true, true);
d292 1
@


1.384
log
@Simplified logging system implementation.
@
text
@d523 1
a523 1
	if (m_otherRequestsList.Find(pPartFile) != 0)
d1482 1
a1482 1
		//	To prevent loop swaping remove a choosen part from NNS-Map
d1488 1
a1488 1
		//	To prevent loop swaping remember NNS-Part & time when it was switched
a1502 1
		//	Add to past comment
d1505 1
d1585 3
d1602 2
@


1.383
log
@Added multipacket support preparation [eklmn].
@
text
@d321 1
a321 1
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s: offered file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(fileHash));
d332 1
a332 1
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s: offered file was not requested (offered: %s | requested: %s)"), GetClientNameWithSoftware(), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
d334 1
a334 1
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s: offered file was not requested (offered hash: %s | requested file: %s)"), GetClientNameWithSoftware(), HashToString(fileHash), m_pReqPartFile->GetFileName());
d386 1
a386 1
//			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s: no file stated"), GetClientNameWithSoftware());
d393 1
a393 1
//		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Client %s: wrong file stated (%s)"), GetClientNameWithSoftware(),
d587 1
a587 1
						AddDebugLogLine(_T("Failed download session with the NNS client %s%s"), GetClientNameWithSoftware(), HasLowID() ? _T(" LowID") : _T(""));
d748 1
a748 1
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_BADHASHSET), m_pReqPartFile->GetFileName());
d1066 1
a1066 1
						AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client %s (IP: %s) added to filtered clients due to bad data"),
d1077 1
a1077 1
					AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Client %s"), GetClientNameWithSoftware());
d1105 1
a1105 1
							AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Client %s"), GetClientNameWithSoftware());
d1114 1
a1114 1
					AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Corrupted compressed packet for %s received (error %i)"), m_pReqPartFile->GetFileName(), result);
d1781 1
a1781 1
			AddDebugLogLine(_T("Sent hashset request with filehash %s to client %s"), HashToString(m_pReqPartFile->GetFileHash()), GetClientNameWithSoftware());
@


1.382
log
@Pending_Block_Struct moved to client implementation from otherstructs.h.
@
text
@d301 1
a301 1
void CUpDownClient::ProcessFileInfo(byte *pbytePacket, uint32 dwPacketSize)
a304 3
//	Create a memory stream from the packet and read its contents
	CSafeMemFile		packetStream(pbytePacket, dwPacketSize);

@


1.381
log
@Proper share mode for open files (before other applications could write to a file while we were reading).
@
text
@d36 9
@


1.380
log
@Simplified transfer statistics gathering; Suppressed compiler warnings.
@
text
@d27 1
d588 1
a588 1
					FILE	*pLogFile = _tfopen(g_App.m_pPrefs->GetDownloadLogName(), _T("ab"));
@


1.379
log
@Slightly better way of shrinking string size (thanks eklmn).
@
text
@d368 1
a368 1
void CUpDownClient::ProcessFileStatus(CSafeMemFile *packetStream, CPartFile *pReqPartFile, bool bUDPPacket/* = false*/)
d993 1
a993 1
	g_App.m_pPrefs->Add2SessionTransferData(GetClientSoft(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket, false, m_pReqPartFile->GetPriority());
d1287 1
a1287 1
			m_dwDownDataRate = (1000 * static_cast<uint64>(m_dwClientSumDLDataRateOverLastNMeasurements)) / m_dwClientSumDLTickOverLastNMeasurements;
d1375 1
a1375 1
		bool		bNNS  = false;
d1653 1
a1653 1
		parts[m_pendingBlocksList.GetNext(pos)->pReqBlock->qwStartOffset / PARTSIZE] = true;
@


1.378
log
@Avoided extra memory usage which can be caused by Unicode conversion.
@
text
@a331 1
		CString	strTmp;
d335 3
a337 3
		ReadMB2Str(m_eStrCodingFormat, &strTmp, packetStream, uNameLength);
	//	Recopy to class member, as allocated container of returned string can be larger than string length
		m_strClientFilename = strTmp;
@


1.377
log
@correction after review
@
text
@d330 1
a330 1
	else	
d332 2
a333 1
		uint16		uNameLength;
d336 3
a338 1
		ReadMB2Str(m_eStrCodingFormat, &m_strClientFilename, packetStream, uNameLength);
@


1.376
log
@added unicode support for log files (emule, debug, upload, download, status, backup)
@
text
@d606 1
a606 1
					//	Write the Unicode BOM at the begining if file was created
@


1.375
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d27 1
d585 1
a585 1
					FILE	*pLogFile = _tfopen(g_App.m_pPrefs->GetDownloadLogName(), _T("a"));
d592 1
a592 1
						strLogLine.Format( _T("%s,\"%s\",%s,%s,\"%s\",%u,%u,%u,%s,%s,%s\n"),
d604 6
@


1.374
log
@Fixed sending double cancel requests in some rare cases (happened when a file was canceled while downloading from some fast source).
@
text
@d334 1
a334 3

		packetStream.Read(m_strClientFilename.GetBuffer(uNameLength), uNameLength);
		m_strClientFilename.ReleaseBuffer(uNameLength);
@


1.373
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d1813 2
@


1.372
log
@Corrected merge issue (thanks Fuxie - DK).
@
text
@a591 1
						uint32			iPartNum = GetCurrentlyUploadingPart();
d699 1
a699 1
	if (uiState >= ELEMENT_COUNT(s_auiResTbl))
d866 1
a866 1
				aqwStartEnd[i + ELEMENT_COUNT(aqwStartEnd) / 2] = pReqBlk->qwEndOffset + 1ui64;
d871 1
a871 1
				aqwStartEnd[i + ELEMENT_COUNT(aqwStartEnd) / 2] = 0;
d890 1
a890 1
				adwStartEnd[i + ELEMENT_COUNT(adwStartEnd) / 2] = static_cast<uint32>(pReqBlk->qwEndOffset) + 1;
d895 1
a895 1
				adwStartEnd[i + ELEMENT_COUNT(adwStartEnd) / 2] = 0;
@


1.371
log
@Improved calculation of available remote client parts;
Removed some unrequired checks; Minor loop optimization;
_bHasClientNeededParts replaced with m_uNeededParts (target functionality is not fully implemented though).
@
text
@a421 2
		m_bCompleteSource = false;
		uint16 nCompleteSourcePart = 0;
a422 1
		uint16 done = 0;
@


1.370
log
@fix time disappearing at midnight
@
text
@d188 3
a190 3
					( !m_bCompleteSource
						&& (m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4
							|| dwSources <= RARE_FILE * 2 )
d344 6
a349 11
			if (m_pbytePartStatuses != NULL)
			{
				delete[] m_pbytePartStatuses;
				m_pbytePartStatuses = NULL;
			}

			m_uPartCount = m_pReqPartFile->GetPartCount();
			m_pbytePartStatuses = new byte[m_uPartCount];
			memset2(m_pbytePartStatuses, 1, m_uPartCount);
			m_bCompleteSource = true;
			m_bHasClientNeededParts = true;
d394 1
d406 1
a406 2
		m_bHasClientNeededParts = true;
		m_bCompleteSource = true;
d410 1
a410 1
		m_bHasClientNeededParts = false;
d427 5
a431 1
		while (done != m_uPartCount)
d433 2
a434 4
			byte toread;
			packetStream->Read(&toread, 1);

			for (sint32 i = 0;i != 8;i++)
d436 2
a437 2
				m_pbytePartStatuses[done] = ((toread >> i) & 1) ? 1 : 0;
				if (m_pbytePartStatuses[done])
d439 3
a441 3
					nCompleteSourcePart++;
					if (!m_pReqPartFile->IsPartComplete(done))
						m_bHasClientNeededParts = true;
d443 1
a443 3
				done++;

				if (done == m_uPartCount)
d448 2
a449 2
		if (nCompleteSourcePart == m_uPartCount)
			m_bCompleteSource = true;
d457 2
a458 2
	//	request the file & enter to the queue only if we required a file from remote client
		else if (GetDownloadState() != DS_DOWNLOADING && m_bHasClientNeededParts)
d495 1
a495 1
				if (m_bHasClientNeededParts)
d504 1
a504 1
	if (!m_bHasClientNeededParts)
d815 1
a815 1
		if (m_bCompleteSource)
a1333 19
uint16 CUpDownClient::GetAvailablePartCount()
{
	EMULE_TRY

	uint16 result = 0;

	for (int i = 0;i < m_uPartCount;i++)
	{
		if (IsPartAvailable(i))
			result++;
	}

	return result;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d1839 1
a1839 2
	if (m_pbytePartStatuses != NULL)
		delete[] m_pbytePartStatuses;
d1841 1
a1841 3
	m_bCompleteSource = false;
	m_bHasClientNeededParts = false;
	m_uPartCount = 0;
@


1.369
log
@Reduced #include depedency.
@
text
@d603 1
a603 1
											currentTime.Format(),
@


1.368
log
@Added Source Exchange 2 support (adapted from original 0.48a).
@
text
@d22 1
@


1.367
log
@Fixed compilation {Fuxie - DK}.
@
text
@d178 1
a178 1
				ExtProtocolAvailable() && GetSourceExchangeVersion() >= 1 &&
d214 1
a214 1
	CMemFile	pckStrm(16 + 58 + 2);	// enough for 4GB without reallocation
d219 1
d221 3
a223 3

	if (GetExtendedRequestsVersion() > 1)
		m_pReqPartFile->WriteCompleteSourcesCount(&pckStrm);
a227 1

a228 1

d238 1
a238 1
		Packet 	*pPacket = new Packet(OP_SETREQFILEID, 16);
a241 1

a242 1

a243 1

d248 1
a248 1
	  || g_App.m_pPrefs->IsDisabledXS() )
d254 1
a254 1
	  && g_App.m_pPrefs->XSUpTo() < m_pReqPartFile->GetSourceCount() )
d261 2
d265 3
a267 1
		Packet		*pPacket = new Packet(OP_REQUESTSOURCES, 16, OP_EMULEPROT);
d269 10
a278 1
		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
@


1.366
log
@removed the port statistic (part 2)
@
text
@d104 1
a104 1
uint32 CUpDownClient::Compare(CUpDownClient* pClient)
a987 1

a988 1

@


1.365
log
@Optimized client comparison; Formatting.
@
text
@d985 1
a985 1
	g_App.m_pPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket, false, m_pReqPartFile->GetPriority());
@


1.364
log
@Newly added stuff was renamed according to the original for easier reference.
@
text
@d115 1
a115 1
	else
d117 1
a117 1
		if (GetUserIDHybrid() != 0)
d119 2
a120 10
			if (HasLowID())
			{
				if ( GetUserIDHybrid() == pClient->GetUserIDHybrid()
					&& GetServerIP() != 0 
					&& GetServerIP() == pClient->GetServerIP()
					&& GetServerPort() !=0
					&& GetServerPort() == pClient->GetServerPort())
					dwResult |= CLIENT_COMPARE_SAME_ID;
			}
			else
d122 1
a122 2
				if (GetUserIDHybrid() == pClient->GetUserIDHybrid() && GetUserPort() == pClient->GetUserPort())
					dwResult |= CLIENT_COMPARE_SAME_ID;
d125 2
d129 1
a129 1
	if (HasValidHash() && md4cmp(GetUserHash(), pClient->GetUserHash()) == 0)
@


1.363
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d117 1
a117 1
		if (GetHybridUserID() != 0)
d121 1
a121 1
				if ( GetHybridUserID() == pClient->GetHybridUserID()
d130 1
a130 1
				if (GetHybridUserID() == pClient->GetHybridUserID() && GetUserPort() == pClient->GetUserPort())
@


1.362
log
@Fixed source loss at the time of unexpected downloading disconnection {muleteer};
Corrected wrong #ifdef statement.
@
text
@d117 1
a117 1
		if (GetUserID() != 0)
d121 1
a121 1
				if ( GetUserID() == pClient->GetUserID()
d130 1
a130 1
				if (GetUserID() == pClient->GetUserID() && GetUserPort() == pClient->GetUserPort())
@


1.361
log
@prevent collision between manual & automatic switch (Aw3 case)
@
text
@d654 1
d1836 3
a1838 1
	Packet	*pPacket = NULL;
d1840 1
a1840 3
	try
	{
		if (m_pRequestSocket)
d1848 8
a1856 7
#endif //OLD_SOCKETS_ENABLED	
	}
	catch (CException *error)
	{
		safe_delete(pPacket);
		g_App.m_pMDlg->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
		error->Delete();
@


1.360
log
@fixed A4AF switch for the clients in "Waiting request" state
@
text
@d1489 1
a1489 1
		if (SwapTo != NULL && SwapToPos != 0)
@


1.359
log
@Modified constructors to avoid potential compiling issue due to type collision.
@
text
@d1547 2
a1548 1
				|| GetDownloadState() == DS_WAITCALLBACK)
@


1.358
log
@Reset the filename by A4AF swap to prevent the user misinformation in case of delayed request (thanks to AraldoL)
@
text
@d1137 1
a1137 1
			//	For determining whether the current download session was a success or not
d1840 1
a1840 1
			pPacket = new Packet(OP_CANCELTRANSFER);
@


1.357
log
@Fixed large file block request packet {xalbux/Fuxie - DK}.
@
text
@d1509 2
@


1.356
log
@Delete client object on file-not-found not to accumulate unused sources in the known file list.
@
text
@d859 1
a859 1
		pPacket = new Packet(OP_REQUESTPARTS_I64, 64);	// 64 = 16+(3*8)+(3*8)
@


1.355
log
@Simplified check to send large file block request.
@
text
@d1599 7
a1605 2
			if (!m_pRequestSocket && !Disconnected())
				g_App.m_pDownloadQueue->RemoveSource(this, true);
@


1.354
log
@Unified packet buffer type.
@
text
@d843 2
a844 2
		//	We use larger or equal condition to avoid wrap-around block requests when End < Start
			if ((pReqBlk->qwEndOffset >= 0xFFFFFFFFui64) || (pReqBlk->qwStartOffset > 0xFFFFFFFFui64))
@


1.353
log
@Added file request preparation for large file size support.
@
text
@d287 1
a287 1
void CUpDownClient::ProcessFileInfo(char *pcPacketBuf, uint32 dwPacketSize)
d292 1
a292 1
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d712 1
a712 1
void CUpDownClient::ProcessHashSet(char* pPacket, uint32 size)
d724 1
a724 1
	if (md4cmp(pPacket, m_pReqPartFile->GetFileHash()))
d730 1
a730 1
	CSafeMemFile data1((BYTE*)pPacket, size);
d934 1
a934 1
int CUpDownClient::ProcessBlockPacket(char *pcPacketBuf, uint32 dwPacketSize, bool bPacked, bool b64bOffsets)
d942 1
a942 1
	CSafeMemFile	packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d1066 1
a1066 1
					(BYTE *) (pcPacketBuf + dwHdrSz), qwStartPos, qwEndPos,
d1079 2
a1080 2
			//	Try to unzip the pcPacketBuf
				int result = unzip(cur_block, (BYTE *)(pcPacketBuf + dwHdrSz), dwDataTransferdInPacket, &lenUnzipped);
d1361 1
a1361 1
	if (m_uRemoteQueueRank != nr)
@


1.352
log
@Fixed source reasking when too many connections threshold reached (UDP connections
shouldn't be blocked by too many TCP socket connections; we should send TCP reasks when threshold is reached and there's already a socket connection with a source).
@
text
@d833 3
a835 9
	Packet		*pPacket = new Packet(OP_REQUESTPARTS, 40);	// 40 = 16+(3*4)+(3*4)

	CMemFile		packetStream(reinterpret_cast<BYTE*>(pPacket->m_pcBuffer), 40);

	packetStream.Write(m_pReqPartFile->GetFileHash(), 16);

	POSITION		pos = m_pendingBlocksList.GetHeadPosition();
	uint32			adwStartEnd[6];

d843 10
a852 2
			adwStartEnd[i] = pReqBlk->qwStartOffset;
			adwStartEnd[i + ELEMENT_COUNT(adwStartEnd) / 2] = pReqBlk->qwEndOffset + 1ui64;
d854 36
a889 1
		else
d891 11
a901 2
			adwStartEnd[i] = 0;
			adwStartEnd[i + ELEMENT_COUNT(adwStartEnd) / 2] = 0;
d903 1
a904 1
	packetStream.Write(adwStartEnd, sizeof(adwStartEnd));
@


1.351
log
@Improved string processing
@
text
@d149 9
@


1.350
log
@Minor addition to make even better the previous change "don't send reask to a full source before file completion to save traffic";
Added IP and port to "wrong part number" log message; Formatting.
@
text
@d309 1
a309 1
		CPartFile		*pReqFileDownloading = g_App.m_pDownloadQueue->GetFileByID(fileHash);
d312 1
a312 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client %s: offered file was not requested (offered: %s | requested: %s)"), GetClientNameWithSoftware(), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
d314 1
a314 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client %s: offered file was not requested (offered hash: %s | requested file: %s)"), GetClientNameWithSoftware(), HashToString(fileHash), m_pReqPartFile->GetFileName());
@


1.349
log
@Corrected dropping of inactive LowID sources
(there was a change that a good source could be removed);
Don't send reask to a full source before file completion to save traffic
(pretty rare case but happens, so we can avoid sending a couple of useless packets).
@
text
@d409 3
a411 1
			strTemp.Format(_T("wrong part number, file: %s ED2KParts/Parts: %u/%u %s %s"), m_pReqPartFile->GetFileName(), m_pReqPartFile->GetED2KPartCount(), uED2KPartCount, GetClientNameWithSoftware(), HashToString(m_userHash));
d808 3
d812 1
d1868 2
a1869 7
	if (IsUDPRequestAllowed())
	{
		if (IsSourceRequestAllowed())
			AskForDownload();
		else
			UDPReaskForDownload();
	}
@


1.348
log
@Corrected download state change for remote LowID sources.
@
text
@d554 6
a559 1
				uint32 dwSessionDuration = (::GetTickCount() - m_dwDownStartTime) / 1000;
d803 8
a810 5
		if ((GetTickCount() - GetLastAskedTime()) > FILEREASKTIME)
			AskForDownload();

		if (eOldDowloadState == GetDownloadState())
			SetDownloadState(DS_NONEEDEDPARTS);
d812 3
@


1.347
log
@Fixed recently changes for download state of remote LowID NNS (as a result fixed broken:
source exchange because number of valid sources was incorrect, A4AF swap, sorting of NNS, NNS statistics, etc.).
@
text
@d467 6
a472 2

 //	If remote client is lowID
d1178 1
a1178 1
			SetDownloadState(DS_ONQUEUE);
@


1.346
log
@Large file size support preparations.
@
text
@d468 1
a468 1
//	If remote client is lowID
d482 4
a485 1
				SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
@


1.345
log
@Simplified/speeded up processing of partfile status.
@
text
@d59 2
a60 2
	uint32		filesize = (m_pReqPartFile) ? m_pReqPartFile->GetFileSize() : 1;
	CBarShader	statusBar(rect->bottom - rect->top, rect->right - rect->left, crNeither, filesize);
@


1.344
log
@Large file size support preparations; Renaming;
Removed temporary memory allocation to improve performance and avoid memory leakage.
@
text
@d1348 1
a1348 1
					EnumPartFileStatuses eStatus = pCurFile->GetStatus(false);
d1388 1
a1388 1
		else if (SwapTo->GetStatus(false) == PS_READY || SwapTo->GetStatus(false) == PS_EMPTY)
@


1.343
log
@Large file size support preparations.
@
text
@d743 1
d747 1
a747 4

			Requested_Block_Struct	**ppRequestedBlocksToAdd = new Requested_Block_Struct * [dwSavedCount];

			dwCount = m_pReqPartFile->GetGapsInPart(m_uLastPartAsked, ppRequestedBlocksToAdd, dwSavedCount);
d759 1
a759 1
			 //	Get next part
d764 1
a764 3
				{
					dwCount = m_pReqPartFile->GetGapsInPart(m_uLastPartAsked, ppRequestedBlocksToAdd, dwSavedCount);
				}
d768 1
a768 3
				m_downloadBlocksList.AddTail(ppRequestedBlocksToAdd[i]);

			delete[] ppRequestedBlocksToAdd;
d777 1
a777 1
		pPendingBlock->m_pRequestedBlock = m_downloadBlocksList.RemoveHead();
d809 1
a809 1
	Requested_Block_Struct	*pRequestedBlock;
d815 3
a817 3
			pRequestedBlock = m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock;
			adwStartEnd[i] = pRequestedBlock->m_dwStartOffset;
			adwStartEnd[i + ELEMENT_COUNT(adwStartEnd) / 2] = pRequestedBlock->m_dwEndOffset + 1;
d932 1
a932 1
		pReqBlk = cur_block->m_pRequestedBlock;
d934 1
a934 1
		if ((pReqBlk->m_dwStartOffset <= qwStartPos) && (pReqBlk->m_dwEndOffset >= qwStartPos))
d972 1
a972 1
					((pReqBlk->m_dwEndOffset - pReqBlk->m_dwStartOffset) > cur_block->dwReceived) )
d988 1
a988 1
					(qwEndPos >= pReqBlk->m_dwEndOffset) ? PF_WR2BUF_FL_ENDOFBLOCK : 0 );
d1009 2
a1010 2
						qwStartPos = pReqBlk->m_dwStartOffset;
						qwEndPos = qwStartPos + lenUnzipped - 1;
d1022 1
a1022 1
						qwEndPos = pReqBlk->m_dwEndOffset;
d1029 1
a1029 1
					m_pReqPartFile->RemoveBlockFromList(pReqBlk->m_dwStartOffset, pReqBlk->m_dwEndOffset);
d1065 1
a1065 1
			if (qwEndPos >= pReqBlk->m_dwEndOffset)
d1067 1
a1067 1
				m_pReqPartFile->RemoveBlockFromList(pReqBlk->m_dwStartOffset, pReqBlk->m_dwEndOffset);
d1116 1
a1116 1
		zS->avail_out = pPendingBlk->m_pRequestedBlock->m_dwEndOffset - pPendingBlk->m_pRequestedBlock->m_dwStartOffset + 1;
d1585 1
a1585 1
		parts[m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock->m_dwStartOffset / PARTSIZE] = true;
d1608 1
a1608 1
			CPartFile *pReqFile = g_App.m_pDownloadQueue->GetFileByID(pPendingBlock->m_pRequestedBlock->m_fileHash);
d1621 2
a1622 2
						pPendingBlock->pbyteRxDate, pPendingBlock->m_pRequestedBlock->m_dwStartOffset,
						pPendingBlock->m_pRequestedBlock->m_dwStartOffset + dwTotalOut - 1,
d1632 3
a1634 3
			pReqFile->RemoveBlockFromList(pPendingBlock->m_pRequestedBlock->m_dwStartOffset,
										pPendingBlock->m_pRequestedBlock->m_dwEndOffset);
			delete pPendingBlock->m_pRequestedBlock;
d1647 3
a1649 2
		Requested_Block_Struct* pDLBlock =  m_downloadBlocksList.RemoveHead();
		if (pDLBlock)
d1653 1
a1653 1
			pReqFile->RemoveBlockFromList(pDLBlock->m_dwStartOffset, pDLBlock->m_dwEndOffset);
d1725 1
a1725 1
		dwDownloadingPart = m_pendingBlocksList.GetHead()->m_pRequestedBlock->m_dwStartOffset / PARTSIZE;
d1739 1
a1739 1
		*pdwDownloadingPart = m_pendingBlocksList.GetHead()->m_pRequestedBlock->m_dwStartOffset / PARTSIZE;
@


1.342
log
@Renamed DS_LOWTOLOWIP -> DS_LOWTOLOWID.
@
text
@d70 1
a70 1
		uint32 dwStart, dwEnd;
d74 1
a74 1
			bool bIsComplete = m_pReqPartFile->IsPartComplete(i, &dwStart, &dwEnd);
d76 1
a76 1
			dwEnd++;
d82 2
a83 2
					statusBar.FillRange(dwStart, dwEnd, crBoth);
				else if (isDLing && (m_qwLastBlockOffset < dwEnd) && (m_qwLastBlockOffset >= dwStart))
d85 2
a86 2
					statusBar.FillRange(dwStart, m_qwLastBlockOffset, crPending);
					statusBar.FillRange(m_qwLastBlockOffset, dwEnd, crToDo);
d89 1
a89 1
					statusBar.FillRange(dwStart, dwEnd, crNextPending);
d91 1
a91 1
					statusBar.FillRange(dwStart, dwEnd, crClientOnly);
d95 1
a95 1
				statusBar.FillRange(dwStart, dwEnd, crMeOnly);
@


1.341
log
@Fixed completely wrong LowID processing {Fuxie - DK/muleteer} (beta 1 is broken).
@
text
@d477 1
a477 1
				SetDownloadState(DS_LOWTOLOWIP);
d674 1
a674 1
		IDS_NOCONNECTLOW2LOW,		//DS_LOWTOLOWIP
@


1.340
log
@Formatting.
@
text
@d480 1
a480 1
			else if (g_App.m_pServerConnect->GetLocalIP() != GetServerIP())
@


1.339
log
@change the detection of local LowID; added OnConnect()
@
text
@a352 1

a455 1

a491 1

d1848 5
a1852 8
	//	Try to request the file status over UDP before TCP request
		if (IsUDPRequestAllowed())
		{
			if (IsSourceRequestAllowed())
				AskForDownload();
			else
				UDPReaskForDownload();
		}
d1854 4
a1857 1
			AskForDownload();
@


1.338
log
@Large file size support preparations.
@
text
@a210 1
	SetLastAskedTime();
@


1.337
log
@Preparations to process 64bit data packets.
@
text
@d83 1
a83 1
				else if (isDLing && (m_dwLastBlockOffset < dwEnd) && (m_dwLastBlockOffset >= dwStart))
d85 2
a86 2
					statusBar.FillRange(dwStart, m_dwLastBlockOffset, crPending);
					statusBar.FillRange(m_dwLastBlockOffset, dwEnd, crToDo);
d632 1
a632 1
				m_dwLastBlockOffset = ~0;
d966 1
a966 1
			m_dwLastBlockOffset = qwStartPos;
@


1.336
log
@1) last LowID check, i.e. put LowID client in proper state in TryToConnect();
2) added CONNECTING state
3) force request by A4AF swap for LowID clients (the proper state will set inTryToConnect() )
@
text
@a868 2
	const int		HEADER_SIZE = 24;

d873 2
a874 3
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);

	uchar		fileHash[16];
d885 2
a886 6
	uint32			dwStartPos = 0;
	uint32			dwEndPos = 0;
	uint32			dwBlockSize = 0;
	const uint32 	dwDataTransferdInPacket = dwPacketSize - HEADER_SIZE;

	packetStream.Read(&dwStartPos, sizeof(uint32));				//<BYTEOFFSET:DWORD> start position
d888 7
d901 7
a907 1
		packetStream.Read(&dwEndPos, sizeof(uint32));			//<BYTEOFFSET:DWORD> end position
d909 2
a910 3
	//	Check that packet size matches the declared packetStream packet + header size (24)
		if (dwDataTransferdInPacket != (dwEndPos - dwStartPos))
		{
a911 1
		}
d913 1
a916 1
	{
a917 1
	}
d921 1
a921 1
//	bFromPF is not relevant to downloaded data.  It is purely an uploads statistic.
d944 1
a944 1
		if ((pReqBlk->m_dwStartOffset <= dwStartPos) && (pReqBlk->m_dwEndOffset >= dwStartPos))
d966 1
a966 1
			m_dwLastBlockOffset = dwStartPos;
d976 1
a976 1
				dwEndPos--;
d997 2
a998 2
					(BYTE *) (pcPacketBuf + HEADER_SIZE), dwStartPos, dwEndPos,
					(dwEndPos >= pReqBlk->m_dwEndOffset) ? PF_WR2BUF_FL_ENDOFBLOCK : 0 );
d1011 1
a1011 1
				int result = unzip(cur_block, (BYTE *)(pcPacketBuf + HEADER_SIZE), dwDataTransferdInPacket, &lenUnzipped);
d1019 2
a1020 2
						dwStartPos = pReqBlk->m_dwStartOffset;
						dwEndPos = dwStartPos + lenUnzipped - 1;
d1024 1
a1024 1
							dwStartPos, dwEndPos, PF_WR2BUF_FL_FREEBUFFER | PF_WR2BUF_FL_ENDOFBLOCK );
d1032 1
a1032 1
						dwEndPos = pReqBlk->m_dwEndOffset;
d1075 1
a1075 1
			if (dwEndPos >= pReqBlk->m_dwEndOffset)
d1248 1
a1248 1
#endif //OLD_SOCKETS_ENABLED
d1256 1
a1256 1
#endif //OLD_SOCKETS_ENABLED
@


1.335
log
@Improved string processing.
@
text
@d211 1
d1472 2
a1473 4
			if (GetDownloadState() == DS_LOWID_ON_OTHER_SERVER
				|| GetDownloadState() == DS_CONNECTING
				|| GetDownloadState() == DS_WAITCALLBACK
				|| GetDownloadState() == DS_LOWTOLOWIP)
d1835 1
a1835 1
	if ((m_pRequestSocket != NULL) && m_pRequestSocket->IsConnected())
@


1.334
log
@1) refixed state change on file status processing (thanks Aw3)
2) fixed flaw in hashset request that prevent e+ to get hashset during one session
@
text
@d301 1
a301 1
			AddDebugLogLine(RGB_LOG_DIMMED + _T("Client %s: offered file not found (hash: %s)"), GetClientNameWithSoftware(), HashToString(fileHash));
d372 1
a372 1
//			AddDebugLogLine(RGB_LOG_DIMMED + _T("Client %s: no file stated"), GetClientNameWithSoftware());
d379 1
a379 1
//		AddDebugLogLine(RGB_LOG_DIMMED + _T("Client %s: wrong file stated (%s)"), GetClientNameWithSoftware(),
@


1.333
log
@UNICODE preparations
@
text
@d347 1
a347 1
			else 
d444 1
a444 1
//	if it is TCP connection, we can send something back
d450 1
a450 1
		else if (m_bHasClientNeededParts)
d466 2
a467 2
//	then an addition check of the download state is required to prevent download abort
	if (GetDownloadState() == DS_DOWNLOADING)
d482 1
a482 1
			else if (!g_App.m_pServerConnect->IsLocalServer(m_dwServerIP, m_uServerPort))
d699 10
a708 2
	if ((!m_pReqPartFile) || md4cmp(pPacket, m_pReqPartFile->GetFileHash()))
		throw CString(_T("wrong fileID sent, file: ") + ((m_pReqPartFile != NULL) ? m_pReqPartFile->GetFileName() : _T("NULL")));
a713 2
		m_fRequestingHashSet = 0;

d722 2
@


1.332
log
@roll back the changes that lead to performance drop
@
text
@d571 1
a571 1
					FILE *LogFile = _tfopen(g_App.m_pPrefs->GetDownloadLogName(), "a");
d573 1
a573 1
					if (LogFile != NULL)
a578 1

d591 2
a592 2
						_fputts(strLogLine, LogFile);
						fclose(LogFile);
d985 2
a986 2
				             (BYTE *) (pcPacketBuf + HEADER_SIZE), dwStartPos, dwEndPos,
										 (dwEndPos >= pReqBlk->m_dwEndOffset) ? PF_WR2BUF_FL_ENDOFBLOCK : 0 );
@


1.331
log
@rare incorrect setting of NNS state by download
@
text
@d470 1
d473 3
a475 2
	// if remote client is lowID
		if (g_App.m_pServerConnect->IsLowID())
d477 10
a486 7
			SetDownloadState(DS_LOWTOLOWIP);
			return;
		}
		else if (GetServerIP() != g_App.m_pServerConnect->GetCurrentServer()->GetIP())
		{
			SetDownloadState(DS_LOWID_ON_OTHER_SERVER);
			return;
d1165 10
a1174 1
	switch (m_eDownloadState)
d1176 2
a1177 14
		case DS_DOWNLOADING:
			if ((dwCurTick - m_dwLastBlockReceived) > DOWNLOADTIMEOUT)
			{
			//	Wait a little bit more for slow clients, what helps to save some downloads
				if ((m_dwDownDataRate == 0) || (m_dwDownDataRate > 1000) || ((dwCurTick - m_dwLastBlockReceived) >= 150000))
				{
					SetDownloadState(DS_ONQUEUE);
					SendCancelTransfer();
				}
			}
			else
			{
				uint32 time_diff_ms = dwCurTick - m_dwLastDataRateCalculationTime;
				uint32 dwLastTransferred = m_dwTransferredInLastPeriod;
d1179 3
a1181 10
			//	Update time & reset data transferred over last period
				m_dwTransferredInLastPeriod = 0;
				m_dwLastDataRateCalculationTime = dwCurTick;

			//	Update average sum
				m_dwClientSumDLDataRateOverLastNMeasurements += dwLastTransferred;
				m_dwClientSumDLTickOverLastNMeasurements += time_diff_ms;
			//	Update lists
				m_averageDLDataRateList.push_front(dwLastTransferred);
				m_averageDLTickList.push_front(time_diff_ms);
d1183 6
a1188 8
			//	Check lists size
				while (m_averageDLTickList.size() > (DOWNLOADTIMEOUT / 100))
				{
					m_dwClientSumDLDataRateOverLastNMeasurements -= m_averageDLDataRateList.back();
					m_averageDLDataRateList.pop_back();
					m_dwClientSumDLTickOverLastNMeasurements -= m_averageDLTickList.back();
					m_averageDLTickList.pop_back();
				}
d1190 8
a1197 1
				uint32 dwAverageTransferTimePeriod;
d1199 1
a1199 4
				if (m_dwClientSumDLTickOverLastNMeasurements != 0)
				{
				//	Calculate average time period between measuremets (ms)
					dwAverageTransferTimePeriod = m_dwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();
d1201 4
a1204 9
				//	Calculate a DL rate (b/s)
					m_dwDownDataRate = (1000 * static_cast<uint64>(m_dwClientSumDLDataRateOverLastNMeasurements)) / m_dwClientSumDLTickOverLastNMeasurements;
				}
				else
				{
					dwAverageTransferTimePeriod = 100;
				//	Calculate a DL rate (b/s) assuming 100 ms interval
					m_dwDownDataRate = 10 * m_dwClientSumDLDataRateOverLastNMeasurements;
				}
d1206 29
a1234 19
			//	now based on measured speed we can control the bandwidth
				if (dwReduceDownload)
				{
					m_bLimitlessDL = false;
				//	the limit for next period is calculated as required DL per millisecond multiplicated by the time period.
				//		required DL (Byte/s) = percent * measured DL (Byte/s)
				//		required DL (Byte/ms) = required DL (Byte/s) / 1000
				//		Limit = required DL (Byte/ms) * sample period (ms)
				//	The previous formula assumed 100ms period between two speed calculations
				//		uint32 limit = dwReduceDownload * dwCurrentDataRate / 1000;
				//			where dwReduceDownload = percent * 100
				//	Since we are calculating the average period value, then we gonna use this value
					uint32 dwUpperLimit = (m_dwDownDataRate * dwAverageTransferTimePeriod) / 100 * dwReduceDownload / 1000;
					uint32 dwLowerLimit = (200 * dwAverageTransferTimePeriod)/1000;

					if (dwUpperLimit < 1000 && dwReduceDownload == 200)
						dwUpperLimit += 1000;
					else if (dwUpperLimit < dwLowerLimit)
						dwUpperLimit = dwLowerLimit;
d1236 1
a1236 1
					m_pRequestSocket->SetDownloadLimit(dwUpperLimit);
d1238 1
a1238 1
				}
d1240 5
a1244 21
				else if (!m_bLimitlessDL)
				{
					m_pRequestSocket->DisableDownloadLimit();
					m_bLimitlessDL = true;
				}
#endif //OLD_SOCKETS_ENABLED
			}
			break;

		case DS_CONNECTED:
#ifdef OLD_SOCKETS_ENABLED
		//	If the request socket doesn't exist or isn't connected
			if ((m_pRequestSocket == NULL) || !m_pRequestSocket->IsConnected())
			{
				SetDownloadState(DS_ERROR);
				Disconnected();
			}
			else if (dwCurTick - GetEnteredConnectedState() > CONNECTION_TIMEOUT + 20000)
			{
				UpdateDownloadStateAfterFileReask();
			}
a1245 22
			break;

		case DS_ONQUEUE:
		case DS_NONEEDEDPARTS:
			if (dwCurTick > GetNextFileReaskTime())
				SendReask();
			break;

		case DS_LOWTOLOWIP:
		case DS_LOWID_ON_OTHER_SERVER:
		//	Since we can't connect to the client we can keep it in the list 
		//	only if it keeps to request the file(s) from us
			if ((dwCurTick - GetLastUpRequest()) > MAX_PURGEQUEUETIME)
			{
				g_App.m_pDownloadQueue->RemoveSource(this);
			}
			break;

		case DS_WAIT_FOR_FILE_REQUEST:
		//	The first request is always TCP request
			AskForDownload();
			break;
@


1.330
log
@Ranamed GetProxy into GetProxySettings; Optimization.
@
text
@d342 1
d350 2
d353 1
d447 5
a451 20
	//	If our client sent the file request at the same time when remote client invited us to download,
	//	then an addition check of the download state is required to prevent download abort
		if (GetDownloadState() != DS_DOWNLOADING)
		{
			if (m_pReqPartFile->m_bHashSetNeeded)
				SendHashsetRequest();
		//	request the file & enter to the queue only if we required a file from remote client
			else if (m_bHasClientNeededParts)
				SendStartUploadRequest();
			else
				SetDownloadState(DS_NONEEDEDPARTS);
		}
	}
//	if it was the UDP client than we have them on the queue
	else
	{
		if (!m_bHasClientNeededParts)
			SetDownloadState(DS_NONEEDEDPARTS);
		else if (GetDownloadState() != DS_ONQUEUE)
			SetDownloadState(DS_ONQUEUE);
d453 2
d457 1
d463 29
d1160 1
a1160 1
	if ((dwCurTick - m_dwLastBlockReceived) > DOWNLOADTIMEOUT)
d1162 14
a1175 11
	//	Wait a little bit more for slow clients, what helps to save some downloads
		if ((m_dwDownDataRate == 0) || (m_dwDownDataRate > 1000) || ((dwCurTick - m_dwLastBlockReceived) >= 150000))
		{
			SetDownloadState(DS_ONQUEUE);
			SendCancelTransfer();
		}
	}
	else
	{
		uint32 time_diff_ms = dwCurTick - m_dwLastDataRateCalculationTime;
		uint32 dwLastTransferred = m_dwTransferredInLastPeriod;
d1177 10
a1186 3
	//	Update time & reset data transferred over last period
		m_dwTransferredInLastPeriod = 0;
		m_dwLastDataRateCalculationTime = dwCurTick;
d1188 8
a1195 6
	//	Update average sum
		m_dwClientSumDLDataRateOverLastNMeasurements += dwLastTransferred;
		m_dwClientSumDLTickOverLastNMeasurements += time_diff_ms;
	//	Update lists
		m_averageDLDataRateList.push_front(dwLastTransferred);
		m_averageDLTickList.push_front(time_diff_ms);
d1197 1
a1197 8
	//	Check lists size
		while (m_averageDLTickList.size() > (DOWNLOADTIMEOUT / 100))
		{
			m_dwClientSumDLDataRateOverLastNMeasurements -= m_averageDLDataRateList.back();
			m_averageDLDataRateList.pop_back();
			m_dwClientSumDLTickOverLastNMeasurements -= m_averageDLTickList.back();
			m_averageDLTickList.pop_back();
		}
d1199 4
a1202 1
		uint32 dwAverageTransferTimePeriod;
d1204 9
a1212 4
		if (m_dwClientSumDLTickOverLastNMeasurements != 0)
		{
		//	Calculate average time period between measuremets (ms)
			dwAverageTransferTimePeriod = m_dwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();
d1214 23
a1236 29
		//	Calculate a DL rate (b/s)
			m_dwDownDataRate = (1000 * static_cast<uint64>(m_dwClientSumDLDataRateOverLastNMeasurements)) / m_dwClientSumDLTickOverLastNMeasurements;
		}
		else
		{
			dwAverageTransferTimePeriod = 100;
		//	Calculate a DL rate (b/s) assuming 100 ms interval
			m_dwDownDataRate = 10 * m_dwClientSumDLDataRateOverLastNMeasurements;
		}

	//	now based on measured speed we can control the bandwidth
		if (dwReduceDownload)
		{
			m_bLimitlessDL = false;
		//	the limit for next period is calculated as required DL per millisecond multiplicated by the time period.
		//		required DL (Byte/s) = percent * measured DL (Byte/s)
		//		required DL (Byte/ms) = required DL (Byte/s) / 1000
		//		Limit = required DL (Byte/ms) * sample period (ms)
		//	The previous formula assumed 100ms period between two speed calculations
		//		uint32 limit = dwReduceDownload * dwCurrentDataRate / 1000;
		//			where dwReduceDownload = percent * 100
		//	Since we are calculating the average period value, then we gonna use this value
			uint32 dwUpperLimit = (m_dwDownDataRate * dwAverageTransferTimePeriod) / 100 * dwReduceDownload / 1000;
			uint32 dwLowerLimit = (200 * dwAverageTransferTimePeriod)/1000;

			if (dwUpperLimit < 1000 && dwReduceDownload == 200)
				dwUpperLimit += 1000;
			else if (dwUpperLimit < dwLowerLimit)
				dwUpperLimit = dwLowerLimit;
d1238 10
a1247 3
			m_pRequestSocket->SetDownloadLimit(dwUpperLimit);
#endif OLD_SOCKETS_ENABLED
		}
d1249 33
a1281 6
		else if (!m_bLimitlessDL)
		{
			m_pRequestSocket->DisableDownloadLimit();
			m_bLimitlessDL = true;
		}
#endif OLD_SOCKETS_ENABLED
a1710 3
		//	don't switch the status in case of NNS if we already have the part status array
			if (GetDownloadState() != DS_NONEEDEDPARTS || m_pbytePartStatuses == NULL)
				SetDownloadState(DS_ONQUEUE);
@


1.329
log
@Minor preparations for 64bit file support.
@
text
@d1812 1
a1812 2
	ProxySettings proxy = g_App.m_pPrefs->GetProxy();
	if (proxy.m_bUseProxy)
@


1.328
log
@safe A4AF switch
@
text
@d831 1
a831 1
int CUpDownClient::ProcessBlockPacket(char *pcPacketBuf, uint32 dwPacketSize, bool bPacked/*=false*/)
a1431 1

@


1.327
log
@Faster download state to string conversion.
@
text
@d471 1
a471 1
bool CUpDownClient::AddRequestForAnotherFile(CPartFile* file)
d475 1
a475 1
	if (file == NULL)
d479 1
a479 1
	if (m_otherRequestsList.Find(file) != 0)
d482 1
a482 1
		m_otherRequestsList.AddTail(file);
d484 1
a484 2
	if (!file->m_A4AFsrcList.Find(this))
		file->m_A4AFsrcList.AddTail(this);
d1385 9
d1421 1
a1421 2
					if (!m_pReqPartFile->m_A4AFsrcList.Find(this))
						m_pReqPartFile->m_A4AFsrcList.AddTail(this);
d1432 1
a1451 12
		//	Remove new file from OtherRequests list
			m_otherRequestsList.RemoveAt(SwapToPos);

		//	Remove current source from A4AF list in new file
			POSITION	pos_A4AF = SwapTo->m_A4AFsrcList.Find(this);

			if (pos_A4AF != NULL)
				SwapTo->m_A4AFsrcList.RemoveAt(pos_A4AF);

		//	To prevent loop swaping remove a choosen part from NNS-Map
			m_otherNoNeededMap.RemoveKey(SwapTo);

@


1.326
log
@Significantly improved downloading from MLdonkey clients -- a solution to overcome
incorrect processing of data block requests by MLdonkey
(eliminated waste data, which could be up to 50% of all transfers).
@
text
@d638 30
@


1.325
log
@Removed unused code.
@
text
@d1024 5
a1028 2
			//	Request next block
				SendBlockRequests();
@


1.324
log
@formating correction
@
text
@d191 1
a191 1
					|| ( (bNeverAskedBefore || dwTimePassedClient > (unsigned)(SOURCECLIENTREASK * m_pReqPartFile->GetCommonFilePenalty())) &&
d1755 1
a1755 1
	//	increase reask time to LowID clients to give the remote client a chance connect us first
@


1.323
log
@small corrections noted in forum
@
text
@d482 1
a482 1
	m_otherRequestsList.AddTail(file);
@


1.322
log
@file reask on incomming connection from LowID clients
@
text
@a1754 1

d1756 1
a1756 1
		if (HasLowID() && !g_App.m_pServerConnect->IsLowID())
@


1.321
log
@fixed source attachmet to the complete file
@
text
@d1751 8
a1758 4
		//	Increase the interval if remote queue is full or we have a low rank
		//	In case when rank is unknown (dwQueueRank = 0), normal reask period is used
			if (dwQueueRank > QUEUERANK_LOW)
				m_dwNextFileReaskTime += g_App.m_pServerConnect->IsLowID() ? (FILEREASKTIME / 4) : (FILEREASKTIME / 2);
@


1.320
log
@Removed not working recent code, which is always false/true, to avoid confusion;
Changed initial stream size to avoid reallocation;
Use standard stream class as safe one isn't required here.
@
text
@d603 2
a604 1
		switch (byNewState)
@


1.319
log
@Minor formatting (please make comparison with whitespaces).
@
text
@d212 1
a212 1
	CSafeMemFile		packetStream1(16 + 16);
d214 1
a214 1
	packetStream1.Write(m_pReqPartFile->GetFileHash(), 16);
d217 1
a217 1
		m_pReqPartFile->WritePartStatus(&packetStream1);
d220 1
a220 1
		m_pReqPartFile->WriteCompleteSourcesCount(&packetStream1); //netwolf: complete sources (zegzav) 13.05.03
d222 1
a222 1
	Packet		*pPacket = new Packet(&packetStream1);
d445 1
a445 9
		if (GetDownloadState() == DS_DOWNLOADING)
		{
			if (m_pendingBlocksList.IsEmpty())
			{
				SetLastDownPartAsked(0xFFFF);
				SendBlockRequests();
			}
		}
		else
d461 1
a461 1
		else if (GetDownloadState() != DS_ONQUEUE && GetDownloadState() != DS_DOWNLOADING)
@


1.318
log
@AFAF fixes (see change log)
@
text
@d1294 1
a1294 1
				if ( pCurFile != m_pReqPartFile && g_App.m_pDownloadQueue->IsInDLQueue(pCurFile))
d1351 1
a1351 1
		if ((dwOptions & A4AF_TO_PAUSED) && (SwapTo == NULL) && (pPausedPartFile != NULL) )
@


1.317
log
@refresh "Known Clients List" after client info was updated
@
text
@d1246 1
a1246 1
bool CUpDownClient::SwapToAnotherFile(CPartFile* SwapTo, bool bOneWaySwap /*false*/, bool bIgnoreReasktime /*false*/)
a1253 10
	POSITION		SwapToPos = 0;
	POSITION		cur_FilePos;
	CPartFile	   *pCurFile;
	uint32			dwLastNNSCheckedTime = ::GetTickCount();
	const uint16	uPriorityFactorsArray[3] = {1,2,3};
	uint16			uA4AFRating;
	uint16			uBestA4AFRating = 0;
	bool			bIsFileReaskAllowed = true;
	bool			bNNS  = false;

d1257 8
d1269 5
a1273 2
			CPartFile	*pTempPartFile;
			POSITION	pos;
d1278 2
a1279 2
				pTempPartFile = m_otherRequestsList.GetNext(pos);
				if (CCat::FileBelongsToGivenCat(pTempPartFile, m_pReqPartFile->GetCatID()))
d1294 1
a1294 2
				if ( pCurFile != m_pReqPartFile && g_App.m_pDownloadQueue->IsInDLQueue(pCurFile)
				     && (pCurFile->GetStatus(false) == PS_READY || pCurFile->GetStatus(false) == PS_EMPTY) )
d1296 1
a1296 2
				//	Check: is new file in NNS-Map?
					bNNS = m_otherNoNeededMap.Lookup(pCurFile, dwLastNNSCheckedTime);
d1298 2
a1299 2
				//	Calculate A4AF rating
					if (bNNS)
d1301 15
a1315 9
						uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()]
							+ static_cast<uint16>((::GetTickCount() - dwLastNNSCheckedTime)/FILEREASKTIME);
						bIsFileReaskAllowed = (::GetTickCount() - dwLastNNSCheckedTime) > FILEREASKTIME;
					}
					else
					{
						uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()] * 3;
						bIsFileReaskAllowed = true;
					}
d1317 2
a1318 3
					if ((uA4AFRating >= uBestA4AFRating) && (bIsFileReaskAllowed || bIgnoreReasktime))
					{
						if(!SwapTo || !bFoundInSameCat || (SwapTo->GetFileName() > pCurFile->GetFileName()))
d1320 6
a1325 3
							SwapTo = pCurFile;
							SwapToPos = cur_FilePos;
							uBestA4AFRating = uA4AFRating;
d1328 5
d1342 1
a1342 1
				bIsFileReaskAllowed = (::GetTickCount() - dwLastNNSCheckedTime) > FILEREASKTIME;
d1344 1
a1344 1
			if (!bNNS || bIsFileReaskAllowed || bIgnoreReasktime)
d1350 7
d1361 1
a1361 1
			if (bOneWaySwap)
d1365 1
a1365 1
				m_otherNoNeededMap[m_pReqPartFile] = ::GetTickCount();
d1383 11
a1393 7
			//	Add them in A4AF list
				if (!bOneWaySwap && !m_pReqPartFile->m_A4AFsrcList.Find(this))
					m_pReqPartFile->m_A4AFsrcList.AddTail(this);

			//	Add old file to m_otherRequestsList
				if (!bOneWaySwap && !m_otherRequestsList.Find(m_pReqPartFile))
					m_otherRequestsList.AddTail(m_pReqPartFile);
d1470 1
a1470 1
		if (!SwapToAnotherFile(NULL, true))
@


1.316
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1524 1
@


1.315
log
@renamed 3 variables
@
text
@d178 1
a178 1
				!g_App.g_pPrefs->IsDisabledXS() &&
d180 1
a180 1
				(g_App.g_pPrefs->GetMaxSourcePerFileSoft() > dwSources ||
d249 2
a250 2
	if ( g_App.g_pPrefs->GetMaxSourcePerFileSoft() < m_pReqPartFile->GetSourceCount()
	  || g_App.g_pPrefs->IsDisabledXS() )
d255 2
a256 2
	if ( g_App.g_pPrefs->DisableXSUpTo()
	  && g_App.g_pPrefs->XSUpTo() < m_pReqPartFile->GetSourceCount() )
d535 1
a535 1
				g_App.g_pPrefs->Add2DownSAvgTime(dwSessionDuration);
d541 1
a541 1
					g_App.g_pPrefs->Add2DownSuccessfulSessions();
d544 1
a544 1
					g_App.g_pPrefs->Add2DownFailedSessions();
d548 1
a548 1
						g_App.g_pPrefs->Add2DownFailedSessionsNoRequiredData();
d552 1
a552 1
				if (g_App.g_pPrefs->LogDownloadToFile())
d554 1
a554 1
					FILE *LogFile = _tfopen(g_App.g_pPrefs->GetDownloadLogName(), "a");
d863 1
a863 1
	g_App.g_pPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket, false, m_pReqPartFile->GetPriority());
d921 1
a921 1
				if ( g_App.g_pPrefs->IsFakeRxDataFilterEnabled() &&
d930 1
a930 1
					if (!g_App.g_pPrefs->IsCMNotLog())
d1755 1
a1755 1
	if ((m_uUDPPort == 0) || (g_App.g_pPrefs->GetUDPPort() == 0))
d1764 1
a1764 1
	ProxySettings proxy = g_App.g_pPrefs->GetProxy();
@


1.314
log
@fixed output of HighQR & QueueFull Sources; removed the comment from SendReask(); fixed function GetValidSources()
@
text
@d178 1
a178 1
				!g_eMuleApp.m_pGlobPrefs->IsDisabledXS() &&
d180 1
a180 1
				(g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > dwSources ||
d226 1
a226 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d240 1
a240 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d249 2
a250 2
	if ( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() < m_pReqPartFile->GetSourceCount()
	  || g_eMuleApp.m_pGlobPrefs->IsDisabledXS() )
d255 2
a256 2
	if ( g_eMuleApp.m_pGlobPrefs->DisableXSUpTo()
	  && g_eMuleApp.m_pGlobPrefs->XSUpTo() < m_pReqPartFile->GetSourceCount() )
d268 1
a268 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(pPacket->m_dwSize);
d295 1
a295 1
		SetDLRequiredFile(g_eMuleApp.m_pDownloadQueue->GetFileByID(fileHash));
d309 1
a309 1
		CPartFile		*pReqFileDownloading = g_eMuleApp.m_pDownloadQueue->GetFileByID(fileHash);
d535 1
a535 1
				g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime(dwSessionDuration);
d541 1
a541 1
					g_eMuleApp.m_pGlobPrefs->Add2DownSuccessfulSessions();
d544 1
a544 1
					g_eMuleApp.m_pGlobPrefs->Add2DownFailedSessions();
d548 1
a548 1
						g_eMuleApp.m_pGlobPrefs->Add2DownFailedSessionsNoRequiredData();
d552 1
a552 1
				if (g_eMuleApp.m_pGlobPrefs->LogDownloadToFile())
d554 1
a554 1
					FILE *LogFile = _tfopen(g_eMuleApp.m_pGlobPrefs->GetDownloadLogName(), "a");
d633 1
a633 1
					g_eMuleApp.m_pClientList->UpdateBanCounters();
d781 1
a781 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d863 1
a863 1
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket, false, m_pReqPartFile->GetPriority());
d921 1
a921 1
				if ( g_eMuleApp.m_pGlobPrefs->IsFakeRxDataFilterEnabled() &&
d928 1
a928 1
					g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(GetIP());
d930 1
a930 1
					if (!g_eMuleApp.m_pGlobPrefs->IsCMNotLog())
d1293 1
a1293 1
				if ( pCurFile != m_pReqPartFile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(pCurFile)
d1452 1
a1452 1
				g_eMuleApp.m_pDownloadQueue->RemoveSource(this, true);
d1495 2
a1496 2
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
	g_eMuleApp.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort());
d1523 1
a1523 1
	g_eMuleApp.m_pDownloadList->UpdateSource(this);
d1538 1
a1538 1
			CPartFile *pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pPendingBlock->m_pRequestedBlock->m_fileHash);
d1580 1
a1580 1
			CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pDLBlock->m_fileHash);
d1599 1
a1599 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1613 1
a1613 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
d1629 1
a1629 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1644 1
a1644 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
d1688 1
a1688 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1698 1
a1698 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(_T(__FUNCTION__), _T(__FILE__), __LINE__, GetErrorMessage(error));
d1737 1
a1737 1
				m_dwNextFileReaskTime += g_eMuleApp.m_pServerConnect->IsLowID() ? (FILEREASKTIME / 4) : (FILEREASKTIME / 2);
d1755 1
a1755 1
	if ((m_uUDPPort == 0) || (g_eMuleApp.m_pGlobPrefs->GetUDPPort() == 0))
d1761 1
a1761 1
	if (g_eMuleApp.m_pServerConnect->IsLowID() || HasLowID())
d1764 1
a1764 1
	ProxySettings proxy = g_eMuleApp.m_pGlobPrefs->GetProxy();
@


1.313
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@d186 1
a186 1
						&& ( dwSources - m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4
a1775 1
		//	If it's allowed to do a source request then do it 2 min earlier
@


1.312
log
@Unicode corrections {KuSh}.
@
text
@a148 18
#ifdef OLD_SOCKETS_ENABLED

	if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
	{
		if (GetDownloadState() != DS_TOOMANYCONNS && GetDownloadState() != DS_DOWNLOADING)
			SetDownloadState(DS_TOOMANYCONNS);

	//	Asking time random only at the beginning for each new source
		if (m_dwLastAskedTime == 0)
		{
			m_dwLastAskedTime = GetTickCount() - FILEREASKTIME + static_cast<uint32>(ROUND((static_cast<double>(rand()) / RAND_MAX) * 300000.0));
		}

		return true;
	}

#endif //OLD_SOCKETS_ENABLED

a532 3
				if (m_pReqPartFile)
					m_pReqPartFile->RemoveDownloadingSource(this);

a536 3
			//	Prevent any action from the client
				m_eDownloadState = byNewState;

a585 5
				if (byNewState == DS_NONE)
				{
					ClearPartStatuses();
				}

d595 1
d597 5
a601 2
			case DS_ERROR:
				return;
d605 4
a608 1
		m_eDownloadState = byNewState;
a613 3
			//	Update statistical variables (start time of DL & minimal amount)
				m_dwLastDataRateCalculationTime = m_dwDownStartTime = ::GetTickCount();
				m_dwLastBlockReceived = ::GetTickCount();
a619 2
				m_pReqPartFile->AddDownloadingSource(this);

a620 1

d622 1
a623 1
				break;
d627 8
a1348 3
		//	Switch state to NONE
			SetDownloadState(DS_NONE);

d1379 16
a1406 4
		//	Add to souceslots
			if (!SwapTo->m_srcLists[m_iSourcesSlot].Find(this))
				SwapTo->m_srcLists[m_iSourcesSlot].AddTail(this);

d1467 3
a1469 5
	if (IsUDPRequestAllowed())
	{
		m_bUDPPending = true;
		m_byteNumUDPPendingReqs++;
		m_dwNextFileReaskTime = dwCurTick + ((IsOnLAN()) ? LANCASTFILEREASKTIME : UDPFILEREASKTIMEOUT);
d1471 1
a1471 1
		CSafeMemFile	packetStream(128);
d1473 6
a1478 2
		packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
		if (GetUDPVersion() > 3)
d1480 1
a1480 5
			if (m_pReqPartFile->IsPartFile())
				((CPartFile*)m_pReqPartFile)->WritePartStatus(&packetStream);
			else
			{
				uint16	uNull = 0;
d1482 1
a1482 7
				packetStream.Write(&uNull, 2);
			}
		}
		if (GetUDPVersion() > 2)
		{
			uint16	uCompleteSourcesCount = m_pReqPartFile->GetCompleteSourcesCount();
			packetStream.Write(&uCompleteSourcesCount, 2);
d1484 6
d1491 1
a1491 1
		Packet		*pPacket = new Packet(&packetStream, OP_EMULEPROT);
d1493 1
a1493 1
		pPacket->m_eOpcode = OP_REASKFILEPING;
d1495 2
a1496 2
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
		g_eMuleApp.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort());
d1498 1
a1498 1
		AddAskedCountDown();
d1500 1
a1500 2
		return true;
	}
a1767 6
#if 1
//	Don't use UDP to ask for sources
	if (IsSourceRequestAllowed())
		return false;
#endif

d1770 15
@


1.311
log
@1) name corrections
2) fixed the DL session cancel if remote client delays with sending of the first data block
3) added the "m_SourceLists" in header file
@
text
@d1624 1
a1624 1
	catch (CException * error)
d1627 1
a1627 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(error));
d1655 1
a1655 1
	catch (CException * error)
d1658 1
a1658 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(error));
d1709 1
a1709 1
	catch (CException * error)
d1712 1
a1712 1
		g_eMuleApp.m_pdlgEmule->AddBugReport(__FUNCTION__,__FILE__, __LINE__,GetErrorMessage(error));
@


1.310
log
@Release memory used by comment.
@
text
@d638 1
d1380 1
a1380 1
				m_pReqPartFile->AddPastComment(this);
a1420 3
		//	Update info for target file
			SwapTo->NewSrcPartsInfo();

@


1.309
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1381 1
a1381 1
				m_strComment = _T("");
@


1.308
log
@Tuned reask intervals to increase performace.
@
text
@d197 3
a199 2
			//	AND if we need more sources
				g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > m_pReqPartFile->GetSourceCount() &&
d1477 1
d1480 1
a1480 16
	ASSERT (m_pReqPartFile);

// if request file is undefined or we have more than 3 pending UDP requests
	if (!m_pReqPartFile || m_bUDPPending)
		return false;

//	Disable UDP when connecting to a PROXY
	ProxySettings proxy = g_eMuleApp.m_pGlobPrefs->GetProxy();

#ifdef OLD_SOCKETS_ENABLED
	if ( m_byteEmuleVersion >= 0x23
		&& m_uUDPPort != 0
		&& g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0
		&& (!g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() )
		&& !(m_pRequestSocket && m_pRequestSocket->IsConnected())
		&& (!proxy.m_bUseProxy) )
a1481 5

	//	Don't use UDP to ask for sources
		if (IsSourceRequestAllowed())
			return false;

d1514 1
d1761 31
@


1.307
log
@Use standard reask time for all clients with unknown QR and for the first reask to
all other clients (related to the new algorithm, which hasn't been enabled yet).
@
text
@d1770 1
a1770 1
				m_dwNextFileReaskTime = m_dwLastAskedTime + FILEREASKTIME * 3 / 2;	//1.5
d1774 1
a1774 1
		m_dwNextFileReaskTime = m_dwLastAskedTime + FILEREASKTIME * 2;
@


1.306
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1768 2
a1769 1
			if ((dwQueueRank == 0) || (dwQueueRank > QUEUERANK_LOW))
@


1.305
log
@One more step to integrate eklmn's SSDQ.
@
text
@d655 1
a655 1
		SetAllowFileReaskTime();
d1750 1
a1750 1
	SetAllowFileReaskTime();
d1753 1
a1753 1
void CUpDownClient::SetAllowFileReaskTime()
@


1.304
log
@renamed variable "m_dwAllowFileReaskTime"
@
text
@d1476 2
d1502 1
@


1.303
log
@One more step to integrate eklmn's SSDQ.
@
text
@d1754 1
a1754 1
		m_dwAllowFileReaskTime = m_dwLastAskedTime + LANCASTFILEREASKTIME;
d1758 1
a1758 1
	m_dwAllowFileReaskTime = m_dwLastAskedTime + FILEREASKTIME;
d1766 1
a1766 1
				m_dwAllowFileReaskTime = m_dwLastAskedTime + FILEREASKTIME * 3 / 2;	//1.5
d1770 1
a1770 1
		m_dwAllowFileReaskTime = m_dwLastAskedTime + FILEREASKTIME * 2;
@


1.302
log
@One more step to integrate eklmn's SSDQ.
@
text
@a169 2
	m_fIsLastDownloadRequestTCP = 1;

d183 6
a188 6
	DWORD			dwTickCount = GetTickCount() + CONNECTION_LATENCY;
	unsigned int	nTimePassedClient = dwTickCount - GetLastSrcAnswerTime();
	unsigned int	nTimePassedFile = dwTickCount - m_pReqPartFile->GetLastAnsweredTime();
	bool			bNeverAskedBefore = GetLastSrcReqTime() == 0;

	UINT			dwSources = m_pReqPartFile->GetSourceCount();
d191 1
a191 1
//	but i think we need to keep compatibility with old ePlus versions
d205 1
a205 1
						&& (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK) )
d208 2
a209 2
					|| ( (bNeverAskedBefore || nTimePassedClient > (unsigned)(SOURCECLIENTREASK * m_pReqPartFile->GetCommonFilePenalty())) &&
						(nTimePassedFile > SOURCECLIENTREASK) )
a1497 1
		m_fIsLastDownloadRequestTCP = 0;	//	switch the request type
d1754 1
a1754 2
		m_dwAllowFileReaskTime = m_dwLastAskedTime +
			(m_fIsLastDownloadRequestTCP == 1) ? LANCASTFILEREASKTIMEUDP : LANCASTFILEREASKTIMETCP;
@


1.301
log
@Increased data packet download timeout to keep some kind of slow downloads.
@
text
@d657 2
d1749 27
@


1.300
log
@Some eklmn's modifications.
@
text
@d1134 6
a1139 2
		SetDownloadState(DS_ONQUEUE);
		SendCancelTransfer();
d1158 1
a1158 1
		while (m_averageDLTickList.size() > 500)
@


1.299
log
@One more step to integrate eklmn's SSDQ.
@
text
@d174 1
a174 4
	if (TryToConnect())
		return true;
	else
		return false;
d1458 3
a1460 3
	//	if client have socket or was not removed indirectly over disconnection, remove him from DLQ
		if (!m_pRequestSocket && !Disconnected())
			g_eMuleApp.m_pDownloadQueue->RemoveSource(this, true);
@


1.298
log
@One more step to integrate eklmn's SSDQ.
@
text
@d170 1
d465 2
a466 2
	//	if our client sent the file request at the same time as remote client invited us to download, 
	//	then to prevent abort of the download required an addtion check of the download state
d1441 1
d1453 1
d1471 1
a1471 1
void CUpDownClient::UDPReaskForDownload()
d1477 1
d1479 1
a1479 1
		return;
a1484 1

d1495 1
a1495 1
			return;
d1497 1
d1499 1
a1525 1

d1529 1
a1530 1

d1534 2
d1743 5
@


1.297
log
@Corrected Failed Download Sessions statistics (value was greater than real one).
@
text
@a410 2
	bool bPartsNeeded = false;

d416 1
a416 1
		bPartsNeeded = true;
d421 1
d427 1
a427 1
			strTemp.Format(_T("wrong part number, file: %s (ED2KParts/Parts: %u/%u"), m_pReqPartFile->GetFileName(), m_pReqPartFile->GetED2KPartCount(), uED2KPartCount);
d448 1
a448 1
						bPartsNeeded = true;
d479 1
a479 1
			else if (bPartsNeeded)
d488 1
a488 1
		if (!bPartsNeeded)
d490 1
a490 1
		else if (bPartsNeeded && GetDownloadState() != DS_ONQUEUE && GetDownloadState() != DS_DOWNLOADING)
d1733 1
@


1.296
log
@added skipped SetDLRequiredFile() calls
@
text
@d558 10
a579 10
				uint32 dwSessionDuration = (::GetTickCount() - m_dwDownStartTime) / 1000;

				g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime(dwSessionDuration);

			//	Prevent any action from the client
				m_eDownloadState = byNewState;

				ClearDownloadBlocksList();
				ClearPendingBlocksList();

d1575 1
a1575 1
					pReqFile->WriteToBuffer( dwTotalOut - pPendingBlock->pZStream->total_in,
d1578 5
a1582 1
						PF_WR2BUF_FL_FREEBUFFER | PF_WR2BUF_FL_ENDOFBLOCK );
@


1.295
log
@fixed indefication of the client IP identiifcatio has more higher priority as Userhash.
@
text
@d316 1
a316 1
		m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(fileHash);
d1397 1
a1397 1
			m_pReqPartFile = SwapTo;
@


1.294
log
@The second step to integrate eklmn's SSDQ.
@
text
@d103 4
a107 2
bool CUpDownClient::Compare(CUpDownClient* tocomp)
{
d110 1
a110 1
	if (GetIP() != 0 && tocomp->GetIP() != 0)
d112 2
a113 2
		if (GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())
			return true;
d117 1
a117 1
		if (HasLowID())
d119 14
a132 11
			if ( GetUserID() == tocomp->GetUserID()
				&& GetServerIP() != 0 
				&& GetServerIP() == tocomp->GetServerIP()
				&& GetServerPort() !=0
				&& GetServerPort() == tocomp->GetServerPort())
				return true;
		}
		else
		{
			if (GetUserID() != 0 && GetUserID() == tocomp->GetUserID() && GetUserPort() == tocomp->GetUserPort())
				return true;
d136 2
a137 2
	if (HasValidHash() && tocomp->HasValidHash())
		return !md4cmp(GetUserHash(), tocomp->GetUserHash());
d141 1
a141 1
	return false;
d169 1
a169 1
	m_dwLastAskedTime = GetTickCount();
d310 1
a310 1
	m_dwLastAskedTime = ::GetTickCount();
d491 1
a491 1
		else if (bPartsNeeded && GetDownloadState() != DS_ONQUEUE)
d1442 1
a1442 1
	m_dwLastAskedTime = ::GetTickCount();
d1628 1
a1628 1
			m_dwLastAskedTime = ::GetTickCount();
@


1.293
log
@indefication of the client by connection
@
text
@d138 1
a138 1

d177 1
a177 1

d379 1
a379 1
		m_pReqPartFile = pReqPartFile;
a1374 2
			//	Find current file position in sourceslots
				cur_FilePos = m_pReqPartFile->m_srcLists[m_iSourcesSlot].Find(this);
d1376 2
a1377 3
 			//	Remove current file
				if (cur_FilePos)
					m_pReqPartFile->m_srcLists[m_iSourcesSlot].RemoveAt(cur_FilePos);
a1386 3
			//	Let's update current information for the removed file
				m_pReqPartFile->NewSrcPartsInfo();

@


1.292
log
@new way of queue handling
@
text
@d108 22
a129 2
	if (GetIP() && tocomp->GetIP() && GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())
		return true;
a133 5
	if (HasLowID())
		return((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()) && (GetUserPort() == tocomp->GetUserPort()));
	else
		return((GetUserID() == tocomp->GetUserID() && GetUserPort() == tocomp->GetUserPort()) || (GetIP() && (GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())));

@


1.291
log
@Call ClearPartStatuses only when it's required to reset everything;
Unconditional cleanup of other parameters in ClearPartStatuses (it's more correct).
@
text
@a624 1
				m_fReceivedQR = 0;
@


1.290
log
@improvement of download abort fix
@
text
@d18 1
a18 2

#include "StdAfx.h"
d333 5
a337 2
			if (m_pbytePartStatuses)
				ClearPartStatuses();
d385 5
a389 2
	if (m_pbytePartStatuses)
		ClearPartStatuses();
d596 1
a596 2
					if (m_pbytePartStatuses)
						ClearPartStatuses();
d1350 1
a1350 2
			if (m_pbytePartStatuses)
				ClearPartStatuses();
d1713 3
a1716 1

a1717 3

	delete[] m_pbytePartStatuses;
	m_pbytePartStatuses = NULL;
@


1.289
log
@download log (part1: without GUI)
@
text
@d442 9
a450 1
		if (GetDownloadState() != DS_DOWNLOADING)
@


1.288
log
@1. QR highlighting
2. output "Queue Full" if eMule client did not send QR
3. possible download abort
@
text
@d521 1
d537 3
a539 1
				g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime((::GetTickCount() - m_dwDownStartTime) / 1000);
d547 28
d595 1
a601 7
		if (m_pReqPartFile == NULL)
		{
			AddDebugLogLine(RGB_BLUE_VIOLET + _T("The download state switch from %u to %u without 'm_pReqPartFile' (%s)"), 
							m_eDownloadState,
							byNewState,
							GetClientNameWithSoftware());
		}
d613 3
d857 2
@


1.287
log
@Fixed overflow of download client bandwidth calculation if limit is in use and
uploader can feed it (for limits > 210 KBytes/s).
@
text
@a250 6
	if (IsEmuleClient())
	{
		SetRemoteQueueFull(true);
		SetRemoteQueueRank(0);
	}

d335 1
a335 4
			{
				delete[] m_pbytePartStatuses;
				m_pbytePartStatuses = NULL;
			}
d384 1
a384 4
	{
		delete[] m_pbytePartStatuses;
		m_pbytePartStatuses = NULL;
	}
d440 12
a451 7
		if (m_pReqPartFile->m_bHashSetNeeded)
			SendHashsetRequest();
	//	request the file & enter to the queue only if we required a file from remote client
		else if (bPartsNeeded)
			SendStartUploadRequest();
		else
			SetDownloadState(DS_NONEEDEDPARTS);
d553 1
a553 5
						delete[] m_pbytePartStatuses;

					m_pbytePartStatuses = 0;

					m_uPartCount = 0;
d570 7
a590 3
				if (IsEmuleClient())
					SetRemoteQueueFull(false);

d1309 1
a1309 4
			{
				delete[] m_pbytePartStatuses;
				m_pbytePartStatuses = 0;
			}
d1311 1
a1311 2
			m_uPartCount = 0;
			m_dwLastAskedTime = 0;
a1339 3

			//	Reset before delete m_pbytePartStatuses
				m_pReqPartFile = NULL;
d1670 10
@


1.286
log
@Fixed socket processing flaw causing exceptions at the end of downloading {muleteer}.
@
text
@d1140 1
a1140 1
			uint32 dwUpperLimit = (dwReduceDownload * m_dwDownDataRate * dwAverageTransferTimePeriod)/100000;
@


1.285
log
@Unified way to display client name and version.
@
text
@d572 1
a572 1
					m_pRequestSocket->DisableDownloadLimit();
@


1.284
log
@corrected misiplemented stats
@
text
@d309 1
a309 1
			AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s): offered file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(), HashToString(fileHash));
d320 1
a320 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered: %s | requested: %s)"), GetUserName(), GetClientNameAndVersionString(), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
d322 1
a322 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered hash: %s | requested file: %s)"), GetUserName(), GetClientNameAndVersionString(), HashToString(fileHash), m_pReqPartFile->GetFileName());
d376 1
a376 2
//			AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s): no file stated"), GetUserName(),
//							 GetClientNameAndVersionString() );
d383 2
a384 2
//		AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s): wrong file stated (%s)"), GetUserName(),
//						 GetClientNameAndVersionString(), pReqPartFile ? pReqPartFile->GetFileName() : _T("NULL") );
d538 1
a538 1
						AddDebugLogLine(_T("Failed download session with the NNS client '%s' (%s).%s"), GetUserName(), GetClientNameAndVersionString(), HasLowID() ? _T("LowID") : _T(""));
d898 2
a899 2
						AddDebugLogLine( RGB_LOG_DIMMED_TXT _T("Client '%s' (%s) (IP: %s) added to filtered clients due to bad data"),
											GetUserName(), GetClientNameAndVersionString(), GetFullIP() );
d909 1
a909 1
					AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Client '%s' (%s)"), GetUserName(), GetClientNameAndVersionString());
d937 1
a937 1
							AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Client '%s' (%s)"), GetUserName(), GetClientNameAndVersionString());
d1619 1
a1619 1
			AddDebugLogLine(_T("Sent hashset request with filehash %s to client '%s' (%s)"), HashToString(m_pReqPartFile->GetFileHash()), GetUserName(), GetClientNameAndVersionString());
@


1.283
log
@rewirite the statistic "failed download session"
@
text
@d537 1
a537 1
					if (m_fBlocksWereRequested == 1)
d539 1
a539 1
						AddDebugLogLine(_T("Failed download session by the NNS client '%s' (%s)."), GetUserName(), GetClientNameAndVersionString(), HasLowID() ? _T("LowID") : _T(""));
@


1.282
log
@added number of download failed sessions due to NNS sources to the statistic
@
text
@d537 3
a539 1
					if (m_downloadBlocksList.IsEmpty())
d541 1
d592 1
d757 2
@


1.281
log
@Corrected remaining chunk time and size display at the end of the chunk.
@
text
@d535 1
d537 3
@


1.280
log
@Renamed SendStartUploadRequest()
@
text
@d1621 1
a1621 1
// return the remainig download time for the current chunk in second
d1624 1
a1624 1
	uint32 dwSecond = 0;
d1626 2
a1627 4
	if (m_pReqPartFile != NULL
		&& m_eDownloadState ==  DS_DOWNLOADING
		&& m_uLastPartAsked != 0xFFFF 
		&& m_dwDownDataRate != 0)
d1629 2
a1630 3
		uint32 dwPartSize = m_pReqPartFile->GetPartLeftToDLSize(m_uLastPartAsked);
		
		dwSecond = dwPartSize / m_dwDownDataRate;
d1636 2
a1637 2
// return the remainig download size for the current chunk in bytes
uint32 CUpDownClient::GetRemainingSizeForCurrentPart()
d1641 1
a1641 3
	if (m_pReqPartFile != NULL
		&& m_eDownloadState ==  DS_DOWNLOADING
		&& m_uLastPartAsked != 0xFFFF)
d1643 2
a1644 1
		dwSize = m_pReqPartFile->GetPartLeftToDLSize(m_uLastPartAsked);
@


1.279
log
@Corrected packet creation {DoubleT}.
@
text
@d355 1
a355 1
				SendStartupLoadRequest();
d457 1
a457 1
			SendStartupLoadRequest();
d623 1
a623 1
		SendStartupLoadRequest();
d1560 1
a1560 1
void CUpDownClient::SendStartupLoadRequest()
@


1.278
log
@Removed code which became useless.
@
text
@d1568 1
a1568 1
			Packet 	*pPacket = new Packet(OP_STARTUPLOADREQ, 16);
@


1.277
log
@Removed unused code.
@
text
@d897 1
a897 1
										 pReqBlk, (dwEndPos >= pReqBlk->m_dwEndOffset) ? PF_WR2BUF_FL_ENDOFBLOCK : 0 );
d923 1
a923 1
							dwStartPos, dwEndPos, pReqBlk, PF_WR2BUF_FL_FREEBUFFER | PF_WR2BUF_FL_ENDOFBLOCK );
d1529 1
a1529 1
						pPendingBlock->m_pRequestedBlock, PF_WR2BUF_FL_FREEBUFFER | PF_WR2BUF_FL_ENDOFBLOCK );
@


1.276
log
@Fixed client download data rate calculation;
Fixed rare download attempt loss due to incorrect limit calculation.
@
text
@d601 1
a601 1
		UpdateDisplayedInfo(true);
d1376 1
a1376 1
			UpdateDisplayedInfo(true);
d1497 1
a1497 1
void CUpDownClient::UpdateDisplayedInfo(boolean force)
@


1.275
log
@Interface improvement.
@
text
@a542 1

d546 4
a1100 2
	//	Calculate average time period between measuremets (ms)
		uint32 dwAverageTransferTimePeriod = m_dwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();
d1102 8
a1109 2
	//	Calculate a DL rate (b/s)
		if (dwAverageTransferTimePeriod != 0)
d1111 1
d1114 3
a1116 2
			dwAverageTransferTimePeriod = 0;
			m_dwDownDataRate = 0;
@


1.274
log
@removed double variable set to 0
@
text
@d650 1
a650 1
			uint16		uCount, uSavedCount;
d652 1
a652 1
			uSavedCount = uCount = 3 - m_pendingBlocksList.GetCount();
d654 1
a654 1
			Requested_Block_Struct	**ppRequestedBlocksToAdd = new Requested_Block_Struct * [uCount];
d656 1
a656 1
			m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, ppRequestedBlocksToAdd, &uCount);
d659 1
a659 1
			if (uCount == 0)
d674 1
a674 2
					uCount = uSavedCount;
					m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, ppRequestedBlocksToAdd, &uCount);
d678 1
a678 2
			for (int i = 0; i < uCount; i++)
			{
a679 1
			}
@


1.273
log
@added exception handling; prevent memleaks
@
text
@a1074 1
		m_dwDownDataRate = 0;
@


1.272
log
@Improved BarShader constructor/destructor.
@
text
@a1073 2
	// at download timeout  force socket close.
		SendCancelTransfer();
d1076 1
d1557 3
a1559 1
	if (m_pReqPartFile != NULL && m_pRequestSocket != NULL)
d1561 3
a1563 1
		Packet 	*pPacket = new Packet(OP_STARTUPLOADREQ, 16);
d1565 2
a1566 2
		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1568 1
a1568 1
		m_pRequestSocket->SendPacket(pPacket, true, true);
d1571 11
a1581 4
	//	don't switch the status in case of NNS if we already have the part status array
		if (GetDownloadState() != DS_NONEEDEDPARTS || m_pbytePartStatuses == NULL)
			SetDownloadState(DS_ONQUEUE);
		m_dwLastAskedTime = ::GetTickCount();
d1587 3
a1589 1
	if (m_pReqPartFile != NULL)
d1591 3
a1593 1
		Packet * pPacket = new Packet(OP_HASHSETREQUEST, 16);
d1595 2
a1596 2
		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1598 1
a1598 1
		m_pRequestSocket->SendPacket(pPacket, true, true);
d1601 3
a1603 3
		SetDownloadState(DS_REQHASHSET);
		m_pReqPartFile->m_bHashSetNeeded = false;
		m_fRequestingHashSet = 1;
d1605 8
a1612 1
		AddDebugLogLine(_T("Sent hashset request with filehash %s to client '%s' (%s)"), HashToString(m_pReqPartFile->GetFileHash()), GetUserName(), GetClientNameAndVersionString());
d1651 3
a1653 1
	if (m_pRequestSocket)
d1655 3
a1657 1
		Packet		*pPacket = new Packet(OP_CANCELTRANSFER);
d1659 1
a1659 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1662 9
a1670 1
		m_pRequestSocket->SendPacket(pPacket, true, true);
a1671 1
#endif //OLD_SOCKETS_ENABLED	
@


1.271
log
@Removed some draft never used code.
@
text
@d61 1
a61 3
	CBarShader	statusBar(rect->bottom - rect->top, rect->right - rect->left, filesize);

	statusBar.Fill(crNeither);
@


1.270
log
@Improved BarShared constructor.
@
text
@a1499 20
#ifdef LATER
uint32 CUpDownClient::GetCurrentlyDownloadingPart()
{
	EMULE_TRY

	if (m_eDownloadState == DS_DOWNLOADING)
	{
		return		static_cast<uint32>(m_dwLastBlockOffset / PARTSIZE);
	}
	else
	{
		return 0xFFFF;
	}

	EMULE_CATCH

	return 0xFFFF;
}
#endif LATER
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.269
log
@Fixed incorrectly drawn part request on source progress bar after downloading start;
Minor drawing speed-ups.
@
text
@d60 2
a61 1
	uint32 filesize = (m_pReqPartFile) ? m_pReqPartFile->GetFileSize() : 1;
a62 2
	CBarShader statusBar(rect->bottom - rect->top, rect->right - rect->left);
	statusBar.SetFileSize(filesize);
@


1.268
log
@Removed socket closure after sending cancel as it led to exceptions
(e.i. CClientReqSocket::PacketReceived: Unknown exception. Protocol=...).
@
text
@d37 1
a37 1
void CUpDownClient::DrawStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool bFlat)
a40 3
	const COLORREF crBoth = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);
	const COLORREF crNeither = (bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240);
	const COLORREF crClientOnly = (bFlat) ? RGB(0, 0, 0) : RGB(95, 95, 95);
d45 14
d66 1
a66 1
	if (m_pReqPartFile != NULL)
d68 2
a69 4
		if (!onlygreyrect && m_pReqPartFile && m_pbytePartStatuses)
		{
			_Bvector gettingParts;
			bool isDLing = (m_eDownloadState == DS_DOWNLOADING);
d71 2
a72 2
			if (isDLing)
				ShowDownloadingParts(gettingParts);
d74 1
a74 1
			uint32 dwStart, dwEnd;
d76 3
a78 3
			for (uint32 i = 0; i < m_uPartCount; i++)
			{
				bool bIsComplete = m_pReqPartFile->IsPartComplete(i, &dwStart, &dwEnd);
d80 1
a80 1
				dwEnd++;
d82 9
a90 14
			//	They have this part. Do I have it?
				if (m_pbytePartStatuses[i])
				{ 
					if (bIsComplete)
						statusBar.FillRange(dwStart, dwEnd, crBoth);
					else if (isDLing && (m_dwLastBlockOffset < dwEnd) && (m_dwLastBlockOffset >= dwStart))
					{
						statusBar.FillRange(dwStart, m_dwLastBlockOffset, crPending);
						statusBar.FillRange(m_dwLastBlockOffset, dwEnd, crToDo);
					}
					else if (isDLing && gettingParts[i])
						statusBar.FillRange(dwStart, dwEnd, crNextPending);
					else
						statusBar.FillRange(dwStart, dwEnd, crClientOnly);
d92 2
a93 1
			//	They don't have a part. Do I have it?
d95 1
a95 4
				{
					if (bIsComplete)
						statusBar.FillRange(dwStart, dwEnd, crMeOnly);
				}
d97 3
d583 1
a583 1

@


1.267
log
@improved socket usage (centralized cancel of the transfer)
@
text
@d703 2
a705 3
		{
		// cancel download, but leave the socket open, for futher file request
			SendCancelTransfer(false);
a706 6
		}
		else
		{
		// cancel download & shutdown the socket 
			SendCancelTransfer(true);
		}
d1073 1
a1073 1
		SendCancelTransfer(true);
d1646 1
a1646 1
void CUpDownClient::SendCancelTransfer(bool bShutdownSocket)
a1655 6

		if (bShutdownSocket)
		{
			m_pRequestSocket->Safe_Delete();
			m_pRequestSocket = NULL;
		}
@


1.266
log
@Packed flag storage.
@
text
@a700 8
		Packet		*pPacket = new Packet(OP_CANCELTRANSFER);

		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED

		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

d704 3
d708 6
d1079 2
a1080 9
#ifdef OLD_SOCKETS_ENABLED
		if (m_pRequestSocket != NULL)
		{
			Packet * pPacket = new Packet(OP_CANCELTRANSFER);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
			m_pRequestSocket->SendPacket(pPacket, true, true);
		}
#endif //OLD_SOCKETS_ENABLED

d1652 8
d1661 12
@


1.265
log
@Fixed filtering of small fake RX packets (caused impossible file completion in some cases) {vendetta7}.
@
text
@d606 1
a606 1
	if (!m_bRequestingHashSet)
d616 1
a616 1
		m_bRequestingHashSet = false;
d1620 1
a1620 1
		m_bRequestingHashSet = true;
@


1.264
log
@Minimal upload limit is increased to 200 B/s as recent change it to 50 B/s could lead to unrequired disconnections.
@
text
@d880 1
@


1.263
log
@added sorting for remaining size & time; corrected DL limit
@
text
@d1138 1
a1138 3
		//	note: actually UL speed in ZZ are defined number of MAXFRAGSIZE packets which are sended 
		//		over MAXTIMESLOTISALLOWEDTOGOWITHOUTDATAMS period. Therefore minimal speed will be 511 B/s
			uint32 dwLowerLimit = (512 * dwAverageTransferTimePeriod)/10000;
@


1.262
log
@Optional filtering of small fake RX packets.
@
text
@d1138 3
a1140 1
			uint32 dwLowerLimit = (UPLOAD_LOW_CLIENT_DR * dwAverageTransferTimePeriod)/10000;
d1626 34
@


1.261
log
@Fixed minimal client download rate; Faster calculation;
More precise download rate calculation.
@
text
@d882 2
a883 1
				if ( (dwDataTransferdInPacket < 64) && (GetClientSoft() != SO_EDONKEYHYBRID) &&
@


1.260
log
@Services renaming according to the official.
@
text
@d1091 5
d1098 2
a1099 2
		m_qwClientSumDLDataRateOverLastNMeasurements += m_dwTransferredInLastPeriod;
		m_qwClientSumDLTickOverLastNMeasurements += time_diff_ms;
d1101 1
a1101 1
		m_averageDLDataRateList.push_front(m_dwTransferredInLastPeriod);
d1107 1
a1107 1
			m_qwClientSumDLDataRateOverLastNMeasurements -= m_averageDLDataRateList.back();
d1109 1
a1109 1
			m_qwClientSumDLTickOverLastNMeasurements -= m_averageDLTickList.back();
a1111 4

	//	Calculate average trasfered data (bytes)
		uint64 AverageTransferredData = m_qwClientSumDLDataRateOverLastNMeasurements / m_averageDLDataRateList.size();

d1113 1
a1113 1
		uint32 dwAverageTransferTimePeriod = static_cast<uint32>(m_qwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size());
d1117 1
a1117 1
			m_dwDownDataRate = 1000 * AverageTransferredData / dwAverageTransferTimePeriod;
d1120 1
a1120 1
			dwAverageTransferTimePeriod = 100; 
d1124 1
a1124 6
	//	Update time & reset data transferred over last period
		m_dwLastDataRateCalculationTime = dwCurTick;

		m_dwTransferredInLastPeriod = 0;

	//	now based on measured speed we can control the bandwith
d1128 1
a1128 1
		//	the limit for next period is calculated as required DL pro millisecond multiplicated by the period time.
d1134 2
a1135 2
		//			where dwReduceDownload = precent * 100
		//	Since we are calcualting the average period value, then we gonna use this value
d1137 1
a1137 1
			uint32 dwLowerLimit = (UPLOAD_LOW_CLIENT_DR * dwAverageTransferTimePeriod)/1000;
@


1.259
log
@Reduced system load caused by recovery of uncompressed RX stream
(unfortunately it increased amount of additional redownloaded data by I.C.H).
@
text
@d224 1
a224 1
	pPacket->m_eOpcode = OP_FILEREQUEST;
d233 1
a233 1
//	if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
d333 1
a333 1
	//	if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
@


1.258
log
@corrected double StartupLoad request (introduced by me)
@
text
@d899 1
a899 1
				             pReqBlk, false );
d925 1
a925 1
							dwStartPos, dwEndPos, pReqBlk, true );
d1558 1
a1558 1
						pPendingBlock->m_pRequestedBlock, true );
@


1.257
log
@correction remove of source after UDP FNF
@
text
@d349 6
a357 6

	//	even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
		if (m_pReqPartFile->m_bHashSetNeeded)
			SendHashsetRequest();
		else 
			SendStartupLoadRequest();
@


1.256
log
@removed debug messages
@
text
@d1419 2
a1420 3
		if (!m_pRequestSocket)
			Disconnected();			//	Note: client will be removed indirecty of disconnection
		else
@


1.255
log
@corrected source swap by file deletion & fixed competion hang up
@
text
@a1415 2
	//	Note: client will be removed indirecty of disconnection
		AddDebugLogLine(_T("Client '%s' (%s): answered file not found by UDP (trying to swap)"), GetUserName(), GetClientNameAndVersionString());
a1417 1
			AddDebugLogLine(_T("Client '%s' (%s): failed swap try (removing)"), GetUserName(), GetClientNameAndVersionString());
d1420 1
a1420 1
			Disconnected();
a1425 2
	else
		AddDebugLogLine(_T("Client '%s' (%s): answered file not found by UDP (not removed)"), GetUserName(), GetClientNameAndVersionString());
@


1.254
log
@corrected issue of NNS with OnQueue status (reported by DopeFish)
@
text
@d1209 1
a1209 1
bool CUpDownClient::SwapToAnotherFile(CPartFile* SwapTo, bool bIgnoreReasktime)
d1305 3
a1307 1
			if ( m_pReqPartFile != NULL /* && GetDownloadState() == DS_NONEEDEDPARTS */ )
d1339 1
a1339 1
				if (!m_pReqPartFile->m_A4AFsrcList.Find(this))
d1343 1
a1343 1
				if (!m_otherRequestsList.Find(m_pReqPartFile))
a1389 15
	else if (SwapTo && (m_pReqPartFile != SwapTo))
	{
	//	For debug only, to be removed on release
		AddDebugLogLine( _T("Switching to '%s' while no other requested file is available"), SwapTo->GetFileName());

		m_pReqPartFile = SwapTo;

		SwapTo->m_srcLists[this->m_iSourcesSlot].AddTail(this);
		SwapTo->RemovePastComment(this);
		g_eMuleApp.m_pDownloadList->AddSource(SwapTo, this, false);

		return (m_pReqPartFile != NULL);
	}

    return false;
d1416 1
a1416 3
		SetDownloadState(DS_NONEEDEDPARTS);
		SwapToAnotherFile(NULL);
/*
d1418 1
a1418 2

		if (!SwapToAnotherFile(NULL))
a1420 3
			g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
		}
*/
a1421 1

d1424 2
d1427 1
@


1.253
log
@correctected asked counter
@
text
@d1624 3
a1626 1
		SetDownloadState(DS_ONQUEUE);
@


1.252
log
@fixed hashset request for file with filesize = PARTSIZE; new function created
@
text
@d237 1
a237 7
		CSafeMemFile	packetStream2(16);

		packetStream2.Write(m_pReqPartFile->GetFileHash(), 16);

		pPacket = new Packet(&packetStream2);

		pPacket->m_eOpcode = OP_SETREQFILEID;
d239 1
d1507 2
@


1.251
log
@created new function with socket check
@
text
@d306 1
a306 1
		CPartFile		*m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(fileHash);
d360 1
a360 11
		{
			Packet * pPacket = new Packet(OP_HASHSETREQUEST, 16);
			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

			SetDownloadState(DS_REQHASHSET);
			m_pReqPartFile->m_bHashSetNeeded = false;
		}
d457 1
a457 13
		{
			Packet	*pPacket = new Packet(OP_HASHSETREQUEST, 16);

			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

			SetDownloadState(DS_REQHASHSET);
			m_bRequestingHashSet = true;
			m_pReqPartFile->m_bHashSetNeeded = false;
		}
d1631 20
a1650 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////@


1.250
log
@fixed switching between limited & limitless DL; improved bandwidth control for  limited DL; fixed request of hashset
@
text
@d371 2
a372 14
		else if (m_pRequestSocket != NULL)
		{
			SetDownloadState(DS_ONQUEUE);
			CSafeMemFile data1(16);
			data1.Write(m_pReqPartFile->GetFileHash(), 16);
			Packet* pPacket = new Packet(&data1);
			pPacket->m_eOpcode = OP_STARTUPLOADREQ;
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

			m_dwLastAskedTime = ::GetTickCount();
		}
d482 1
a482 12
		{
			Packet 	*pPacket = new Packet(OP_STARTUPLOADREQ, 16);

			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
			m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

			SetDownloadState(DS_ONQUEUE);
			m_dwLastAskedTime = ::GetTickCount();
		}
a483 1
		{
a484 1
		}
d628 1
a628 1

d645 1
a645 10
		Packet 	*pPacket = new Packet(OP_STARTUPLOADREQ, 16);

		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED

		SetDownloadState(DS_ONQUEUE);
		m_dwLastAskedTime = ::GetTickCount();
d1637 17
@


1.249
log
@some correction in processing of file name packet
@
text
@d475 2
a476 6
	m_pReqPartFile->NewSrcPartsInfo();
	UpdateDisplayedInfo();

	if (!bPartsNeeded)
		SetDownloadState(DS_NONEEDEDPARTS);
	else if (!bUDPPacket)
d492 2
a493 1
		else
d506 4
d511 11
a521 2
	else if (bPartsNeeded && GetDownloadState() != DS_ONQUEUE)
		SetDownloadState(DS_ONQUEUE);
d668 3
a670 1
		SetDownloadState(DS_ONQUEUE);
d672 2
a673 6
		m_bRequestingHashSet = false;
		CSafeMemFile data2(16);
		data2.Write(this->m_pReqPartFile->GetFileHash(), 16);
		Packet* opacket = new Packet(&data2);
		opacket->m_eOpcode = OP_STARTUPLOADREQ;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(opacket->m_dwSize);
d675 1
a675 2

		m_pRequestSocket->SendPacket(opacket, true, true);
d678 1
d1129 1
a1129 1
uint32 CUpDownClient::CalculateDownloadRate()
d1173 1
a1173 1
		uint64 AverageTransferTimePeriod = m_qwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();
d1176 2
a1177 2
		if (AverageTransferTimePeriod != 0)
			m_dwDownDataRate = 1000 * AverageTransferredData / AverageTransferTimePeriod;
d1179 2
d1182 1
d1188 31
@


1.248
log
@Corrected protection against bad RX data to avoid filtering of fair clients;
Fixed very rare possibility to upload and report unverified chunks;
Removed unused code.
@
text
@d337 4
a340 1
	//	set the status in case of one part
a356 1
	}
a357 7
//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//	if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
//	know that the file is shared, we know also that the file is complete and don't need to request the file status.

//	request the needed file (m_pReqPartFile) independently from which hash was accepted (correct or incorrect one)
	if (m_pReqPartFile->GetPartCount() == 1)
	{
@


1.247
log
@corrected processing of filename packet
@
text
@d718 1
a718 1
				if ( m_pReqPartFile->IsPartComplete(m_uLastPartAsked)
d941 1
a941 1
					((pReqBlk->m_dwEndOffset - pReqBlk->m_dwStartOffset) >= 63) )
a1555 20
uint16 CUpDownClient::GetAvailableOfNeededPartsCount()
{
	EMULE_TRY

	uint16 uCount = 0;

	if (m_pbytePartStatuses != NULL && m_uPartCount > 0)
	{
		for (int i = 0; i < m_uPartCount ; i++)
			if (m_pbytePartStatuses[i] && !m_pReqPartFile->IsPartComplete(i))
				uCount++;
	}

	return uCount;

	EMULE_CATCH

	return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.246
log
@Removed community check for statistics as we don't collect such download statistics.
@
text
@a299 7
	uint16		uNameLength;

	packetStream.Read(&uNameLength, sizeof(uint16));

	packetStream.Read(m_strClientFilename.GetBuffer(uNameLength), uNameLength);
	m_strClientFilename.ReleaseBuffer(uNameLength);

d305 2
a306 1
		CKnownFile		*pReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(fileHash);
d308 7
a314 2
		if (pReqFile != NULL && pReqFile->IsPartFile())
			m_pReqPartFile = dynamic_cast<CPartFile*>(pReqFile);
d316 2
a317 7

	if (m_pReqPartFile == NULL)
	{
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s): offered file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(), HashToString(fileHash));
		return;
	}

a319 1
		CKnownFile		*pReqFileKnown = g_eMuleApp.m_pSharedFilesList->GetFileByID(fileHash);
d322 1
a322 3
		if (pReqFileKnown)
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered: %s | requested: %s)"), GetUserName(), GetClientNameAndVersionString(), pReqFileKnown->GetFileName(), m_pReqPartFile->GetFileName());
		else if (pReqFileDownloading)
d327 28
d359 2
d363 1
a363 15
		if (m_pbytePartStatuses)
		{
			delete[] m_pbytePartStatuses;
			m_pbytePartStatuses = NULL;
		}

		m_uPartCount = m_pReqPartFile->GetPartCount();
		m_pbytePartStatuses = new byte[m_uPartCount];
		memset2(m_pbytePartStatuses, 1, m_uPartCount);
		m_bCompleteSource = true;

		m_pReqPartFile->NewSrcPartsInfo();
		UpdateDisplayedInfo();

	//	Even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
@


1.245
log
@Fixed exception caused by protection against bad RX data.
@
text
@d878 1
a878 1
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket, IsCommunity(), m_pReqPartFile->GetPriority());
@


1.244
log
@caching of part size in part status vector
@
text
@d821 2
d824 1
a824 1
void CUpDownClient::ProcessBlockPacket(char *pcPacketBuf, uint32 dwPacketSize, bool bPacked/*=false*/)
d872 1
a872 1
		return;
d944 1
a944 2
					delete this;
					break;
d1052 2
@


1.243
log
@rollback of old waiting queue
@
text
@d711 1
a711 1
				if ( m_pReqPartFile->GetBytesInPart(m_uLastPartAsked, true, true) == 0
@


1.242
log
@1) statistic for file priority
2) optimization in category processing
@
text
@a570 1
				{
a571 3
				//	if session was successful, then update position in waiting queue
					g_eMuleApp.m_pUploadQueue->UpdateClientInWaitingQueue(this);
				}
a1410 1
		//StartDLQueueWaitTimer();
@


1.241
log
@small correction
@
text
@d880 1
a880 1
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket, IsCommunity());
@


1.240
log
@unitialized variable created the problem by compilation under VS2002 (report & solution from DoubleT)
@
text
@d1242 1
a1242 1
	bool			bIsFileReaskAllowed = false;
@


1.239
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d1242 2
a1243 2
	bool			bIsFileReaskAllowed;
	bool			bNNS;
@


1.238
log
@SSWQ
@
text
@d1213 5
d1415 1
a1415 1
		StartQueueWaitTimer();
@


1.237
log
@Preparations for new client version report code; Corrected protection against bad RX data.
@
text
@d571 1
d573 3
@


1.236
log
@Reverted a change that seemed not harmful but it was. :-(
@
text
@d55 1
a55 1
	if (m_pReqPartFile)
d320 1
a320 1
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s): offered file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(fileHash));
d330 1
a330 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered: %s | requested: %s)"), GetUserName(), GetClientNameAndVersionString(this), pReqFileKnown->GetFileName(), m_pReqPartFile->GetFileName());
d332 1
a332 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered: %s | requested: %s)"), GetUserName(), GetClientNameAndVersionString(this), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
d334 1
a334 1
			AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered hash: %s | requested file: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(fileHash), m_pReqPartFile->GetFileName());
d400 1
a400 1
//							 GetClientNameAndVersionString(this) );
d408 1
a408 1
//						 GetClientNameAndVersionString(this), pReqPartFile ? pReqPartFile->GetFileName() : _T("NULL") );
d509 2
a510 1
			SetDownloadState(DS_ONQUEUE);
d930 3
a932 2
				if ((dwDataTransferdInPacket < 64) &&
					((pReqBlk->m_dwEndOffset - pReqBlk->m_dwStartOffset) >= 63))
d941 1
a941 1
											GetUserName(), GetClientNameAndVersionString(this), GetFullIP() );
d952 1
a952 1
					AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Client '%s', type '%s', mod '%s'"), GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d980 1
a980 1
							AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Client '%s', type '%s', mod: '%s'"), GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1442 1
a1442 1
		AddDebugLogLine(_T("Client '%s' (%s): answered file not found by UDP (trying to swap)"), GetUserName(), GetClientNameAndVersionString(this));
d1446 1
a1446 1
			AddDebugLogLine(_T("Client '%s' (%s): failed swap try (removing)"), GetUserName(), GetClientNameAndVersionString(this));
d1457 1
a1457 1
		AddDebugLogLine(_T("Client '%s' (%s): answered file not found by UDP (not removed)"), GetUserName(), GetClientNameAndVersionString(this));
@


1.235
log
@Protection against bad upload data;
Added IsPartComplete services to minimize number of not quite correct calculations,
to simplify sources and to make a fundament for future fixing of the old problem;
Pointer and other minor optimization.
@
text
@d1256 3
a1258 1
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != NULL;)
d1260 1
a1260 1
				pCurFile = m_otherRequestsList.GetNext(cur_FilePos);
@


1.234
log
@Hope this is the last time I change that code. :P
Don't know why we have this case but I think it should be handled as a known source but not in download list.
@
text
@d22 1
a22 1
#include "partfile.h"
d65 1
a65 1
			uint32 uEnd;
d67 1
a67 1
			for (uint32 i = 0;i < m_uPartCount;i++)
d69 1
a69 1
			//--- xrmb:seetheneed ---
d71 1
a71 4
				if (PARTSIZE * (i + 1) > filesize)
					uEnd = filesize;
				else
					uEnd = PARTSIZE * (i + 1);
d73 1
a73 1
			//	They have this part. Do i have it?
d76 3
a78 3
					if (m_pReqPartFile->IsComplete(PARTSIZE * i, PARTSIZE * (i + 1) - 1))
						statusBar.FillRange(PARTSIZE * i, uEnd, crBoth);
					else if (isDLing && m_dwLastBlockOffset < uEnd && m_dwLastBlockOffset >= PARTSIZE * i)
d80 2
a81 2
						statusBar.FillRange(PARTSIZE * i, m_dwLastBlockOffset, crPending);
						statusBar.FillRange(m_dwLastBlockOffset, uEnd, crToDo);
d84 1
a84 1
						statusBar.FillRange(PARTSIZE * i, uEnd, crNextPending);
d86 1
a86 1
						statusBar.FillRange(PARTSIZE * i, uEnd, crClientOnly);
d91 2
a92 2
					if (m_pReqPartFile->IsComplete(PARTSIZE * i, PARTSIZE * (i + 1) - 1))
						statusBar.FillRange(PARTSIZE * i, uEnd, crMeOnly);
a93 1
			//--- :xrmb ---
d459 1
a459 1
					if (!m_pReqPartFile->IsComplete(done * PARTSIZE, ((done + 1) * PARTSIZE) - 1))
d885 2
a886 1
	Pending_Block_Struct *cur_block;
d893 1
d895 1
a895 1
		if ((cur_block->m_pRequestedBlock->m_dwStartOffset <= dwStartPos) && (cur_block->m_pRequestedBlock->m_dwEndOffset >= dwStartPos))
d909 1
a909 1
					delete cur_block->m_pRequestedBlock;
d928 16
d947 1
a947 1
				             cur_block->m_pRequestedBlock, false );
d968 1
a968 1
						dwStartPos = cur_block->m_pRequestedBlock->m_dwStartOffset;
d973 1
a973 1
							dwStartPos, dwEndPos, cur_block->m_pRequestedBlock, true );
d981 1
a981 1
						dwEndPos = cur_block->m_pRequestedBlock->m_dwEndOffset;
d988 1
a988 1
					m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
d1005 1
a1005 1
						delete cur_block->m_pRequestedBlock;
d1024 1
a1024 1
			if (dwEndPos >= cur_block->m_pRequestedBlock->m_dwEndOffset)
d1026 2
a1027 2
				m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
				delete cur_block->m_pRequestedBlock;
d1547 1
a1547 1
			if (m_pbytePartStatuses[i] && !m_pReqPartFile->IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
@


1.233
log
@*** empty log message ***
@
text
@d1379 1
a1379 1
	else if (SwapTo != NULL)
d1382 1
a1382 1
		AddDebugLogLine( _T("Switching to a specific file while no other requested files are available"));
a1383 4
	//	Switch state to NONE
		SetDownloadState(DS_NONE);

	//	Actual switch
d1386 4
a1389 8
	//	Update info for target file
		SwapTo->NewSrcPartsInfo();

	//	Update download list
		SwapTo->UpdateDisplayedInfo();

	//	Now update the client item
		UpdateDisplayedInfo(true);
@


1.232
log
@Some changes for the Swap of sources attached to completed files.
@
text
@a1294 4
		//	For debug only, to be removed on release
			AddDebugLogLine( _T("Switching source '%s' from '%s' to '%s'"), GetUserName(), 
							 m_pReqPartFile->GetFileName(), SwapTo->GetFileName() );

a1386 41
		if (m_pbytePartStatuses)
		{
			delete[] m_pbytePartStatuses;
			m_pbytePartStatuses = 0;
		}

		m_uPartCount = 0;
		m_dwLastAskedTime = 0;
		m_uLastPartAsked = 0xFFFF;

	//	Add to past comment
		if (m_pReqPartFile != NULL)
		{
			m_pReqPartFile->AddPastComment(this);
			m_eRating = PF_RATING_NONE;
			m_strComment = _T("");
		//	Find current file position in sourceslots
			cur_FilePos = m_pReqPartFile->m_srcLists[m_iSourcesSlot].Find(this);

 		//	Remove current file
			if (cur_FilePos)
				m_pReqPartFile->m_srcLists[m_iSourcesSlot].RemoveAt(cur_FilePos);

		//	Add them in A4AF list
			if (!m_pReqPartFile->m_A4AFsrcList.Find(this))
				m_pReqPartFile->m_A4AFsrcList.AddTail(this);

		//	Add old file to m_otherRequestsList
			if (!m_otherRequestsList.Find(m_pReqPartFile))
				m_otherRequestsList.AddTail(m_pReqPartFile);

		//	Let's update current information for the removed file
			m_pReqPartFile->NewSrcPartsInfo();

		//	Update download list (old file update)
			m_pReqPartFile->UpdateDisplayedInfo();

		//	Reset before delete m_pbytePartStatuses
			m_pReqPartFile = NULL;
		}

a1388 7
		
	//	Add to souceslots
		if (!SwapTo->m_srcLists[m_iSourcesSlot].Find(this))
			SwapTo->m_srcLists[m_iSourcesSlot].AddTail(this);

	//	Remove from past comment
		SwapTo->RemovePastComment(this);
@


1.231
log
@Now when completing a file or switching NNP sources we take in account categories and its alphabetical order to switch to first episodes or first multi-part downloads. (a better explanation would be welcomed :P)
I have added a debug log line for people to test if it works as expected, this should be removed before next beta.
Removed two debug log lines that IMO are not useful as they are mostly paired with other.
@
text
@d1281 1
d1383 70
@


1.230
log
@1) removed unused code
2) renamed the function
@
text
@d402 3
a404 2
			AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s): no file stated"), GetUserName(),
							 GetClientNameAndVersionString(this) );
d410 3
a412 2
		AddDebugLogLine( RGB_LOG_DIMMED + _T("Client '%s' (%s): wrong file stated (%s)"), GetUserName(),
						 GetClientNameAndVersionString(this), pReqPartFile ? pReqPartFile->GetFileName() : _T("NULL") );
d1226 17
a1242 2
		//	Do not change this unless you want unpredictable results :P
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != 0;m_otherRequestsList.GetNext(cur_FilePos))
d1244 1
a1244 1
				pCurFile = m_otherRequestsList.GetAt(cur_FilePos);
d1268 6
a1273 3
						SwapTo = pCurFile;
						SwapToPos = cur_FilePos ;
						uBestA4AFRating = uA4AFRating;
d1294 3
@


1.229
log
@Reverted some code and fixed another log line
@
text
@d695 1
a695 1
		m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this);
d719 1
a719 1
				m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this);
@


1.228
log
@Fix for log line
@
text
@d651 1
a651 1
		throw CString(_T("wrong fileID sent, file: ") + (m_pReqPartFile != NULL) ? m_pReqPartFile->GetFileName() : _T("NULL"));
@


1.227
log
@Minor fix
@
text
@d842 1
a842 1
		throw CString(_T("wrong fileID sent, file: ") + (m_pReqPartFile != NULL) ? m_pReqPartFile->GetFileName() : _T("NULL"));
@


1.226
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d402 2
a403 1
			AddDebugLogLine(RGB_LOG_DIMMED + _T("Client '%s' (%s): no file stated"), GetUserName(), GetClientNameAndVersionString(this));
d409 2
a410 1
		AddDebugLogLine(RGB_LOG_DIMMED +  _T("Client '%s' (%s): wrong file stated (%s)"), GetUserName(), GetClientNameAndVersionString(this), pReqPartFile->GetFileName());
@


1.225
log
@removed debug log translation.
@
text
@d324 1
a324 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' (%s): offered file not found (hash: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(fileHash));
d334 1
a334 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered: %s | requested: %s)"), GetUserName(), GetClientNameAndVersionString(this), pReqFileKnown->GetFileName(), m_pReqPartFile->GetFileName());
d336 1
a336 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered: %s | requested: %s)"), GetUserName(), GetClientNameAndVersionString(this), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
d338 1
a338 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s' (%s): offered file was not requested (offered hash: %s | requested file: %s)"), GetUserName(), GetClientNameAndVersionString(this), HashToString(fileHash), m_pReqPartFile->GetFileName());
d402 1
a402 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s' (%s): no file stated"), GetUserName(), GetClientNameAndVersionString(this));
d408 1
a408 1
		AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s' (%s): wrong file stated (%s)"), GetUserName(), GetClientNameAndVersionString(this), pReqPartFile->GetFileName());
d932 1
a932 1
					AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d960 1
a960 1
							AddDebugLogLine(false, RGB_LOG_WARNING_TXT _T("client: %s, type: %s, mod: %s"), GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d969 1
a969 1
					AddDebugLogLine(false, RGB_LOG_WARNING_TXT _T("Corrupted compressed packet for %s received (error %i)"), m_pReqPartFile->GetFileName(), result);
d1388 1
a1388 1
		AddDebugLogLine(false, _T("Client '%s': answered file not found by UDP (trying to swap)"), GetUserName());
d1392 1
a1392 1
			AddDebugLogLine(false, _T("Client '%s': failed swap try (removing)"), GetUserName());
d1403 1
a1403 1
		AddDebugLogLine(false, _T("Client '%s' (%s): answered file not found by UDP (not removed)"), GetUserName(), GetClientNameAndVersionString(this));
@


1.224
log
@minor changes.
@
text
@d960 1
a960 1
							AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d969 1
a969 1
					AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), result);
@


1.223
log
@Community statistics
@
text
@d344 2
a345 1
	if (m_pReqPartFile->GetPartCount() == 1){
d373 1
a373 1
		else
d437 4
a440 1
			throw CString(_T("wrong part number, file: ") + m_pReqPartFile->GetFileName());
@


1.222
log
@Removed debug log translations + minor additions + minor change
@
text
@d871 1
a871 1
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket);
@


1.221
log
@Added client version info to debug log messages.
@
text
@d436 1
a436 1
			throw GetResString(IDS_ERR_WRONGPARTNUMBER);
d642 1
a642 1
		throw CString("unwanted hashset received");
d645 1
a645 1
		throw GetResString(IDS_ERR_WRONGFILEID)+_T(" (ProcessHashSet)");
d836 1
a836 1
		throw CString(CString(__FUNCTION__) + _T(": ") + GetResString(IDS_ERR_WRONGFILEID));
d858 1
a858 1
			throw CString(CString(__FUNCTION__ ": ") + GetResString(IDS_ERR_BADDATABLOCK));
@


1.220
log
@Minor update
@
text
@d324 1
a324 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s': offered file not found (hash: %s)"), GetUserName(), HashToString(fileHash));
d334 1
a334 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s': offered file was not requested (offered: %s | requested: %s)"), GetUserName(), pReqFileKnown->GetFileName(), m_pReqPartFile->GetFileName());
d336 1
a336 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s': offered file was not requested (offered: %s | requested: %s)"), GetUserName(), pReqFileDownloading->GetFileName(), m_pReqPartFile->GetFileName());
d338 1
a338 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s': offered file was not requested (offered hash: %s | requested file: %s)"), GetUserName(), HashToString(fileHash), m_pReqPartFile->GetFileName());
d401 1
a401 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s': no file stated"), GetUserName());
d407 1
a407 1
		AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s': wrong file stated (%s)"), GetUserName(), pReqPartFile->GetFileName());
d1399 1
a1399 1
		AddDebugLogLine(false, _T("Client '%s': answered file not found by UDP (not removed)"), GetUserName());
@


1.219
log
@Corrected downloaded data calculation.
@
text
@d330 2
a331 1
		CKnownFile		*pReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(fileHash);
d333 4
a336 2
		if (pReqFile)
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s': offered file was not requested (offered: %s | requested: %s)"), GetUserName(), pReqFile->GetFileName(), m_pReqPartFile->GetFileName());
@


1.218
log
@another check to avoid too early a4af switching
@
text
@a869 3
//	Move end back one, should be inclusive
	m_pCredits->AddDownloaded(dwDataTransferdInPacket, this->GetIP());

d890 2
d917 1
@


1.217
log
@another auto A4AF bugfix
@
text
@d1207 1
d1225 1
a1225 1
					bool	bNNS = m_otherNoNeededMap.Lookup(pCurFile, dwLastNNSCheckedTime);
d1251 9
a1259 1
			SwapToPos = m_otherRequestsList.Find(SwapTo);
d1267 1
a1267 1
			if ( m_pReqPartFile != NULL && GetDownloadState() == DS_NONEEDEDPARTS)
@


1.216
log
@Lost data calculation didn't take corrupted compressed packets into consideration.
@
text
@d1191 1
a1191 1
bool CUpDownClient::SwapToAnotherFile(CPartFile* SwapTo, bool bIgnoreNoNeeded)
d1239 1
a1239 1
					if ((uA4AFRating >= uBestA4AFRating) && bIsFileReaskAllowed)
d1370 1
a1370 1
		SwapToAnotherFile(NULL,true);
@


1.215
log
@Fixed processing of corrupted compressed packets;
Fixed file transferred amount calculation (compressed corrupted data and
data not associated with a request wasn't considered before);
Fixed the same data requests from multiple sources after corrupted compressed packet
(that might be in rare cases after corrupted packet if several uploading users
are available for a downloading file);
Improved decompression memory handling and reduced amount of data recopyings;
Better strategy for rx data buffering (faster disk writing);
Optimized OP_REQUESTPARTS packet creature;
Improved data packet processing.
@
text
@d895 2
d975 2
@


1.214
log
@BUGFIX: permanently switching A4AF sources
@
text
@d676 1
a676 1
	m_dwLastBlockReceived = GetTickCount();
d735 3
a737 1
		pPendingBlock->m_pZStream = NULL;
d765 1
a765 1
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pPacket->m_pcBuffer), 40);
d770 1
a770 16
	uint32			dwNull = 0;

	Requested_Block_Struct		*pRequestedBlock;

	for (uint32 i = 0; i < 3; i++)
	{
		if (pos != NULL)
		{
			pRequestedBlock = m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock;
			packetStream.Write(&pRequestedBlock->m_dwStartOffset, 4);
		}
		else
		{
			packetStream.Write(&dwNull, 4);
		}
	}
d772 1
a772 1
	pos = m_pendingBlocksList.GetHeadPosition();
d779 2
a780 4

			uint32		dwEndOffset = pRequestedBlock->m_dwEndOffset + 1;

			packetStream.Write(&dwEndOffset, 4);
d784 2
a785 1
			packetStream.Write(&dwNull, 4);
d788 1
d808 1
a808 1
           This includes compressed packets.
a846 1
		dwEndPos = dwStartPos + dwDataTransferdInPacket;
a850 1
	}
d852 5
a856 4
//	Check that packet size matches the declared packetStream packet + header size (24)
	if (dwPacketSize != ((dwEndPos - dwStartPos) + HEADER_SIZE))
	{
		throw CString(CString(__FUNCTION__ ": ") + GetResString(IDS_ERR_BADDATABLOCK));
a872 2
	dwEndPos--;

d877 3
d881 1
a881 1
	Pending_Block_Struct* cur_block;
d895 8
a902 1
				m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
a913 1

d916 1
d918 3
a920 5
				lenWritten = m_pReqPartFile->WriteToBuffer( dwDataTransferdInPacket,
				             (BYTE *) (pcPacketBuf + HEADER_SIZE),
				             dwStartPos,
				             dwEndPos,
				             cur_block->m_pRequestedBlock );
d928 1
a928 7
			//	Create space to store unzipped packetStream, the dwPacketSize is only an initial guess,
			//	will be resized in unzip() if not big enough
				uint32 lenUnzipped = (dwPacketSize * 2);

			//	Don't get too big
				if (lenUnzipped > (EMBLOCKSIZE + 300))
					lenUnzipped = (EMBLOCKSIZE + 300);
d930 1
a930 1
				BYTE *unzipped = new BYTE[lenUnzipped];
d933 1
a933 1
				int result = unzip(cur_block, (BYTE *)(pcPacketBuf + HEADER_SIZE), dwDataTransferdInPacket, &unzipped, &lenUnzipped);
d938 1
a938 2

					if (lenUnzipped > 0)
d941 8
a948 71
						dwStartPos = cur_block->m_pRequestedBlock->m_dwStartOffset + cur_block->m_dwTotalUnzipped - lenUnzipped;
						dwEndPos = cur_block->m_pRequestedBlock->m_dwStartOffset + cur_block->m_dwTotalUnzipped - 1;

						if (dwBlockSize * 25 < lenUnzipped)
						{
						//	ICR (reset choosen part in case of suspicious block)
							m_uLastPartAsked = 0xFFFF;

							AddDebugLogLine(true, RGB_LOG_DIMMED_TXT _T("Received suspicious block: file '%s', part %u, block %u, blocksize %u, comp. blocksize %u"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("username '%s', ip %u.%u.%u.%u:%u, hash %s"),
								m_strUserName, (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8),
								(byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24),
								GetUserPort(), HashToString(GetUserHash()));

/*							if (m_pReqPartFile->GetDiscardSuperCompressed())
							{
							//	(un)comment the block-dropping as you wish
								m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwStartOffset + 1);
								uint32 ip1 = 0;
								CString buf, temp;
								int counter = 0;
								buf.Format(_T("%u.%u.%u.%u"), (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24));

								for (int i = 0; i < 4; i++)
								{
									temp = buf.Tokenize(_T("."), counter);
									ip1 += _tstoi(temp) * pow(256, 3 - i);
								}
							//	Add to temporary(24h) banned
								g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(ip1);
							//	Set ERROR state, client will be removed & disconnected by PartFile::Process later on
								SetDownloadState(DS_ERROR);
								AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("block dropped & IP locked out!"));
							}
							else
							{
*/								if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
								{
									AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
									m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
								}
								else
								{
								//	Write uncompressed packetStream to file
									lenWritten = m_pReqPartFile->WriteToBuffer(dwDataTransferdInPacket,
									             unzipped,
									             dwStartPos,
									             dwEndPos,
									             cur_block->m_pRequestedBlock );
#ifdef _DEBUG
									if (lenWritten == 0)
										AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
#endif
								}
//							}
						}
						else
						{
							if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
							{
								AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
								m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
							}
							else
							{
							//	Write uncompressed packetStream to file
								lenWritten = m_pReqPartFile->WriteToBuffer( dwDataTransferdInPacket,
								             unzipped,
								             dwStartPos,
								             dwEndPos,
								             cur_block->m_pRequestedBlock );
d950 2
a951 2
								if (lenWritten == 0)
									AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d953 2
a954 2
							}
						}
d964 11
a974 1
					if (cur_block->m_pZStream != NULL)
d976 3
a978 3
						inflateEnd(cur_block->m_pZStream);
						delete cur_block->m_pZStream;
						cur_block->m_pZStream = NULL;
d980 1
a981 9

				try
				{
					if (unzipped)
				delete [] unzipped;
			}
				catch (...)
				{}

d992 2
a993 2
		//	We need to check "END of the block" condition every time, because if remote client
		//	send us a data that was already written we will not delete the block & packet
d995 1
a995 6
		//	If finished reserved block
		//	in this place because m_pReqPartFile->WriteToBuffer was called
		//	cur_block can be already deleted (if file was completed)
		//	so to avoid access violation here we will check
		//	m_pendingBlocksList for emptyness... possibly there is a better check
			if (!m_pendingBlocksList.IsEmpty() && dwEndPos == cur_block->m_pRequestedBlock->m_dwEndOffset)
d1000 2
a1001 2
			//	Not always allocated
				if (cur_block->m_pZStream)
d1003 2
a1004 2
					inflateEnd(cur_block->m_pZStream);
					delete cur_block->m_pZStream;
a1013 1

d1022 1
a1022 1
int CUpDownClient::unzip(Pending_Block_Struct *pRequestedBlock, BYTE *pbyteZipped, uint32 dwLenZipped, BYTE **ppbyteUzipped, uint32 *pdwLenUnzipped)
d1028 1
a1028 2
//	Save some typing
	z_stream *zS = pRequestedBlock->m_pZStream;
d1033 2
a1034 4
		pRequestedBlock->m_dwTotalUnzipped = 0;

	//	Create stream
		zS = pRequestedBlock->m_pZStream = new z_stream;
d1040 3
a1042 3
	//	Set output data streams, do this here to avoid overwriting on recursive calls
		zS->next_out = *ppbyteUzipped;
		zS->avail_out = *pdwLenUnzipped;
d1051 1
a1051 1
//	Use whatever input is provided
d1055 2
a1056 2
	zS->next_out = *ppbyteUzipped;
	zS->avail_out = *pdwLenUnzipped;
d1058 2
a1059 1
	for (;;)
d1061 1
a1061 4
	//	Unzip the data
		iErr = inflate(zS, Z_SYNC_FLUSH);

		if (iErr == Z_OK)
d1063 2
a1064 33
			if (zS->avail_in == 0)
			{
			//	All available input has been successfully processed.
			//	Set the size to the amount unzipped in this call.
				*pdwLenUnzipped = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
				pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
			}
			else if (zS->avail_out == 0)
			{
			//	Output buffer is full
			//	Increase output buffer size
				uint32		dwNewLen = (*pdwLenUnzipped << 1);

			//	Be ready for lack of memory
				iErr = Z_MEM_ERROR;

			//	Copy unzipped data to a new buffer
				BYTE		*pbyteNewBuff = new BYTE[dwNewLen];
				uint32		dwUnpackedSz = zS->total_out - pRequestedBlock->m_dwTotalUnzipped;

				memcpy2(pbyteNewBuff, *ppbyteUzipped, dwUnpackedSz);

				delete [] (*ppbyteUzipped);

				*ppbyteUzipped = pbyteNewBuff;
				*pdwLenUnzipped = dwNewLen;

			//	Set correct position inside a new output buffer
				zS->next_out = pbyteNewBuff + dwUnpackedSz;
				zS->avail_out = dwNewLen - dwUnpackedSz;
			//	Try again
				continue;
			}
d1066 7
a1072 6
	//	Is zip finished reading all currently available input and writing all generated output
		else if (iErr == Z_STREAM_END)
		{
		//	Finish up
			iErr = inflateEnd(zS);
			pRequestedBlock->m_pZStream = NULL;
d1074 4
a1077 15
			if (iErr == Z_OK)
			{
			//	Got the good result, set the size to the unzipped amount
				*pdwLenUnzipped = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
				pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
			}
			delete zS;
		}
		else
		{
		//	Should not get here unless input data is corrupted
			*pdwLenUnzipped = 0;
		//	Error will be logged by caller on return
		}
		break;
d1518 1
a1518 1
		if (pPendingBlock)
d1520 3
a1522 1
			if (pPendingBlock->m_pRequestedBlock)
d1524 1
a1524 1
				CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pPendingBlock->m_pRequestedBlock->m_fileHash);
d1526 3
a1528 4
				pReqFile->RemoveBlockFromList(pPendingBlock->m_pRequestedBlock->m_dwStartOffset,
											pPendingBlock->m_pRequestedBlock->m_dwEndOffset);
				delete pPendingBlock->m_pRequestedBlock;
			}
d1530 9
a1538 4
			if (pPendingBlock->m_pZStream)
			{
				inflateEnd(pPendingBlock->m_pZStream);
				delete pPendingBlock->m_pZStream;
d1540 3
a1544 1
		pPendingBlock = NULL;
@


1.213
log
@Minor changes and hopefully fixed the problem with disconnected servers highlighting not being removed
@
text
@d1330 1
d1352 1
d1355 2
d1358 1
d1360 2
d1363 1
a1363 1
					if (uA4AFRating >= uBestA4AFRating)
d1493 3
d1503 1
@


1.212
log
@Hope no more changes... :P
@
text
@d324 1
a324 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Client '%s': offered file not found (%s)"), GetUserName(), fileHash);
d335 1
a335 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Client '%s': offered file was not requested (offered hash: %s | requested file: %s)"), GetUserName(), fileHash, m_pReqPartFile->GetFileName());
@


1.211
log
@Removed Drop SuperCompressed blocks feature from GUI
@
text
@d324 1
a324 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Processing a file request answer from source %s: offered file not found (%s)"), GetUserName(), fileHash);
d333 1
a333 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Processing a file request answer from source %s: offered file was not requested (offered: %s | requested: %s)"), GetUserName(), pReqFile->GetFileName(), m_pReqPartFile->GetFileName());
d335 1
a335 1
			AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Processing a file request answer from source %s: offered file was not requested (offered hash: %s | requested file: %s)"), GetUserName(), fileHash, m_pReqPartFile->GetFileName());
d398 1
a398 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Processing a file status answer from source %s: no file stated"), GetUserName());
d404 1
a404 1
		AddDebugLogLine(false, RGB_LOG_DIMMED +  _T("Processing a file status answer from source %s: wrong file stated (%s)"), GetUserName(), pReqPartFile->GetFileName());
d1486 1
a1486 1
		AddDebugLogLine(false, _T("%s: answered file not found by UDP (trying to swap to another file)"), GetUserName());
d1490 1
a1490 1
			AddDebugLogLine(false, _T("%s: failed swap try (removing client)"), GetUserName());
d1500 1
a1500 1
		AddDebugLogLine(false, _T("%s: answered file not found by UDP (client not removed)"), GetUserName());
@


1.210
log
@Debug log change
@
text
@d970 1
a970 1
							if (m_pReqPartFile->GetDiscardSuperCompressed())
d992 1
a992 1
								if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
d1010 1
a1010 1
							}
@


1.209
log
@Formating changes
@
text
@a1484 1
		AddDebugLogLine(false, _T("UDP ANSWER FNF : %s"), GetUserName());
d1486 2
d1489 2
d1492 1
a1496 1

a1497 1

d1500 1
a1500 1
		AddDebugLogLine(false, _T("UDP ANSWER FNF : %s (client not removed)"), GetUserName());
@


1.208
log
@Removed unused code; Recovered whitespaces.
@
text
@a33 1

d41 1
a41 1
	const COLORREF crBoth = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);	//Cax2 - same green used for files & clients
d62 2
a63 2
			if (isDLing)	//Cax2 - no unneded calls to showdownloadingparts...
				ShowDownloadingParts(gettingParts);		// Barry - was only showing one part from client, even when reserved bits from 2 parts
d65 1
a65 1
			uint32 uEnd; //Cax2 less cpu usage
d69 1
a69 1
			//--- xrmb:seetheneed --- & Cax2 graphic glitch fix
d76 1
d78 1
a78 3
				{ //they have this part
				//	do i have it ?

d86 1
a86 1
					else if (isDLing && gettingParts[i])	//Cax2 - no more flashes of yellow across all clients...
d91 3
a93 1
				else //they don't have a part. Do I have it?
d96 2
a97 2

			//--- :xrmb --- & Cax2 graphic glitch fix
a106 1

d127 1
a127 1
//eklmn: return TRUE if client still connected, otherwise return false
d139 1
a139 2
	//	Added by Tarod [Dnowo]
	//	Vorlost halved the code: asking time random only at the beginning for each new source
d180 1
a180 1
			//	if client has the correct extended protocol
a235 2
//	AddDebugLogLine(false ,"File Status: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());

d269 1
a269 2
//
//	DonGato - Disable XS for up to X sources
a286 1
	//	AddDebugLogLine(false, "Send:Source Request User(%s) File(%s)", GetUserName(), m_pReqPartFile->GetFileName());
d296 1
a296 1
//
a297 1
//
d311 3
a313 3
	m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
//
//	Patch 'fix disappearing m_pReqPartFile' START (taab)
d324 1
a324 1
//		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
d327 1
a327 1
/*
d330 6
a335 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile != fileHash)"), __FUNCTION__);
a336 1
*/
d356 1
a356 1
	//	even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
d372 1
a372 1
			CSafeMemFile data1(16);	//TwoBottle Mod
d398 1
a398 1
//			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
d404 1
a404 1
//		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile!=pcFileHash)"), __FUNCTION__);
d437 1
a437 1
		uint16 nCompleteSourcePart = 0;	// zegzav:completesrc (add)
d466 1
a466 1
	m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
a468 2
	//CheckForUpPartsInfo(); // obaldin

d498 1
a498 2
			m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
		//AddDebugLogLine(false,"File Upload: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
d513 1
a513 1
//check Other list
d555 1
a555 1
		//clear variables before switching
d563 1
a563 1
					g_eMuleApp.m_pGlobPrefs->Add2DownSuccessfulSessions(); // Increment our counters for successful sessions (Cumulative AND Session)
d565 1
a565 1
					g_eMuleApp.m_pGlobPrefs->Add2DownFailedSessions(); // Increment our counters failed sessions (Cumulative AND Session)
d569 1
a569 1
				//prevet any action from the client
d585 1
a585 1
					m_uPartCount = 0;	//SyruS (0.29c)
d601 1
a601 1
	//	switch the state & update info
d604 1
a604 1
		//prepare variables for new state
d661 1
a661 1
		m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
d680 1
a680 1
//
d684 2
a685 2
		//eklmn: get part for request. if actual part still has empty blocks, the we get the actuall
		// part, otherwise it will be a new part
d688 2
a689 1
		if (m_uLastPartAsked != 0xFFFF)		//previous active part ?
a690 1
		//	Barry - instead of getting 3, just get how many is needed
d699 2
a700 1
			if (uCount == 0)		//finished block (part ?)
d702 1
a702 2
			//	check if part was completed

d706 1
a706 1
					m_uLastPartAsked = 0xFFFF; //ICR 2.10
d709 2
a710 1
				m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this); //get next part
d712 2
a713 1
				if (m_uLastPartAsked != 0xFFFF)		//more parts ?
d729 1
a729 1
//	Barry - Why are unfinished blocks requested again, not just new ones?
a757 2
//		AddDebugLogLine(false, "Cancel download from %s due empty block list", this->GetUserName());

d880 2
a881 2
//		The new function adds the bytes to the grand total as well as the given client/port.
//		bFromPF is not relevant to downloaded data.  It is purely an uploads statistic.
a900 1
	//	Cax2: I'm not happy with this whole if clause
d936 2
a937 1
			//	Create space to store unzipped packetStream, the dwPacketSize is only an initial guess, will be resized in unzip() if not big enough
d939 1
a940 1

d961 2
a962 1
							m_uLastPartAsked = 0xFFFF;	//eklmn: feature(00): ICR (reset choosen part in case suspicious block)
d972 1
a972 1
							//--- (un)comment the block-dropping as you wish---
d984 1
a984 1
								//eklmn: add to temporary(24h) banned
d986 1
a986 1
								// set an ERROR state, client will be removed & disconnected by PartFile::Process later on
a989 2

						//	BavarianSnail
a1010 2

						//- BavarianSnail
d1060 2
a1061 2
			//eklmn: check result of WriteToBuffer, if we save some byte, then this DL session can be
			// counted as succesful
d1064 2
a1065 1
				m_bTransferredDownMini = true;		// -khaos--+++> For determining whether the current download session was a success or not.
d1068 2
a1069 2
			// eklmn: it needs to check "END of the block" condition every time, cause
			//  if remote client will send us a data that already were written, we will not delete the block & delete a packet
d1071 5
a1075 6
			//	[TwoBottle Mod]: If finished reserved block
			//	in this place because m_pReqPartFile->WriteToBuffer was called
			//	cur_block can be already deleted (if file was completed)
			//	so to avoid access violation here we will check
			//	m_pendingBlocksList for emptyness....possibly there is
			//	better check
d1080 1
a1081 1

d1117 1
d1160 2
a1161 1
				uint32		dwNewLen = (*pdwLenUnzipped << 1);	//	increase output buffer size
d1163 2
a1164 1
				iErr = Z_MEM_ERROR;	//	be ready for lack of memory
d1180 2
a1181 1
				continue;	//	try again
a1231 5

//		if (this != NULL)
//		{
//			AddDebugLogLine(false, "Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
//		}
d1237 1
a1237 1
	//update average sum
d1240 1
a1240 1
	//	update a lists
a1242 1
	//	check lists size
d1244 1
d1253 1
a1253 1
	//	calculate average trasfered data (bytes)
d1256 1
a1256 1
	//	calculate average time period between measuremets (ms)
d1259 1
a1259 1
	//	calculate a DL rate (b/s)
d1265 1
a1265 1
	//update a time & reset data transferred over last period
d1331 1
a1331 1
	//	Check: does client have another file?
a1481 1
//SyruS (0.29a) avoid premature deletion of 'this' client
d1486 1
a1486 1
		//eklmn: try to swap the source to any file before remove them from DL-queue
d1512 1
a1512 1
//	Maverick Disable UDP when connecting to a PROXY
d1525 1
a1525 2
	//don't use udp to ask for sources

d1565 1
a1565 1
//	Barry - Sets the vector of bool 'parts' to show the pending status of each part.
a1582 1
//	New functions by Mr.Fry
a1593 2

	//TRACE("Counted %u Chunks (parts) that %s has and I need (to download)",uCount,GetUserName());
@


1.207
log
@Prevent unwanted clients from becoming friends;
Fix for possible crash due to corrupt comment packet;
Fix for delayed remote answer to hashset request.
@
text
@d35 2
a36 2
//  members of CUpDownClient
//  which are mainly used for downloading functions
d40 1
a40 1
    EMULE_TRY
d42 13
a54 59
    const COLORREF crBoth = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);  //Cax2 - same green used for files & clients
    const COLORREF crNeither = (bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240);
    const COLORREF crClientOnly = (bFlat) ? RGB(0, 0, 0) : RGB(95, 95, 95);
    const COLORREF crPending = RGB(222, 160, 0);
    const COLORREF crToDo = RGB(255, 208, 0);
    const COLORREF crNextPending = RGB(255, 255, 100);
    const COLORREF crMeOnly = RGB(190, 190, 255);

    uint32 filesize = (m_pReqPartFile) ? m_pReqPartFile->GetFileSize() : 1;

    CBarShader statusBar(rect->bottom - rect->top, rect->right - rect->left);
    statusBar.SetFileSize(filesize);
    statusBar.Fill(crNeither);

    if (m_pReqPartFile)
    {
        if (!onlygreyrect && m_pReqPartFile && m_pbytePartStatuses)
        {
            _Bvector gettingParts;
            bool isDLing = (m_eDownloadState == DS_DOWNLOADING);

            if (isDLing)    //Cax2 - no unneded calls to showdownloadingparts...
                ShowDownloadingParts(gettingParts);     // Barry - was only showing one part from client, even when reserved bits from 2 parts

            uint32 uEnd; //Cax2 less cpu usage

            for (uint32 i = 0;i < m_uPartCount;i++)
            {
            //--- xrmb:seetheneed --- & Cax2 graphic glitch fix

                if (PARTSIZE * (i + 1) > filesize)
                    uEnd = filesize;
                else
                    uEnd = PARTSIZE * (i + 1);

                if (m_pbytePartStatuses[i])
                { //they have this part
                //  do i have it ?

                    if (m_pReqPartFile->IsComplete(PARTSIZE * i, PARTSIZE * (i + 1) - 1))
                        statusBar.FillRange(PARTSIZE * i, uEnd, crBoth);
                    else if (isDLing && m_dwLastBlockOffset < uEnd && m_dwLastBlockOffset >= PARTSIZE * i)
                    {
                        statusBar.FillRange(PARTSIZE * i, m_dwLastBlockOffset, crPending);
                        statusBar.FillRange(m_dwLastBlockOffset, uEnd, crToDo);
                    }
                    else if (isDLing && gettingParts[i])    //Cax2 - no more flashes of yellow across all clients...
                        statusBar.FillRange(PARTSIZE * i, uEnd, crNextPending);
                    else
                        statusBar.FillRange(PARTSIZE * i, uEnd, crClientOnly);
                }
                else //they don't have a part. Do I have it?
                    if (m_pReqPartFile->IsComplete(PARTSIZE * i, PARTSIZE * (i + 1) - 1))
                        statusBar.FillRange(PARTSIZE * i, uEnd, crMeOnly);

            //--- :xrmb --- & Cax2 graphic glitch fix
            }
        }
    }
d56 40
a95 1
    statusBar.Draw(dc, rect->left, rect->top, bFlat);
d97 8
a104 1
    EMULE_CATCH
d110 1
a110 1
    EMULE_TRY
d112 2
a113 2
    if (GetIP() && tocomp->GetIP() && GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())
        return true;
d115 2
a116 2
    if (HasValidHash() && tocomp->HasValidHash())
        return !md4cmp(GetUserHash(), tocomp->GetUserHash());
d118 4
a121 4
    if (HasLowID())
        return((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()) && (GetUserPort() == tocomp->GetUserPort()));
    else
        return((GetUserID() == tocomp->GetUserID() && GetUserPort() == tocomp->GetUserPort()) || (GetIP() && (GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())));
d123 1
a123 1
    EMULE_CATCH
d125 1
a125 1
    return false;
d131 1
a131 1
    EMULE_TRY
d135 4
a138 11
    if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
    {
        if (GetDownloadState() != DS_TOOMANYCONNS && GetDownloadState() != DS_DOWNLOADING)
            SetDownloadState(DS_TOOMANYCONNS);

    //  Added by Tarod [Dnowo]
    //  Vorlost halved the code: asking time random only at the beginning for each new source
        if (m_dwLastAskedTime == 0)
        {
            m_dwLastAskedTime = GetTickCount() - FILEREASKTIME + static_cast<uint32>(ROUND((static_cast<double>(rand()) / RAND_MAX) * 300000.0));
        }
d140 9
a148 2
        return true;
    }
d152 1
a152 1
    m_bUDPPending = false;
d154 1
a154 1
    m_dwLastAskedTime = GetTickCount();
d156 1
a156 1
    SetDownloadState(DS_CONNECTING);
d158 4
a161 4
    if (TryToConnect())
        return true;
    else
        return false;
d163 1
a163 1
    EMULE_CATCH
d165 1
a165 1
    return false;
d170 1
a170 1
    EMULE_TRY
d172 29
a200 29
    DWORD           dwTickCount = GetTickCount() + CONNECTION_LATENCY;
    unsigned int    nTimePassedClient = dwTickCount - GetLastSrcAnswerTime();
    unsigned int    nTimePassedFile = dwTickCount - m_pReqPartFile->GetLastAnsweredTime();
    bool            bNeverAskedBefore = GetLastSrcReqTime() == 0;

    UINT            dwSources = m_pReqPartFile->GetSourceCount();

//  Original client return false if client's SourceExchange Version is less or equal than 1
//  but i think we need to keep compatibility with old ePlus versions
    return (
            //  if client has the correct extended protocol
                ExtProtocolAvailable() && GetSourceExchangeVersion() >= 1 &&
            //  AND if we can send sources
                !g_eMuleApp.m_pGlobPrefs->IsDisabledXS() &&
            //  AND if we need more sources
                g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > m_pReqPartFile->GetSourceCount() &&
            //  AND if...
                (
                //  source is not complete and file is rare, allow once every 10 minutes
                    ( !m_bCompleteSource
                        && ( dwSources - m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4
                            || dwSources <= RARE_FILE * 2 )
                        && (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK) )
                //  otherwise, allow every 90 minutes, but only if we haven't
                //  asked someone else in last 10 minutes
                    || ( (bNeverAskedBefore || nTimePassedClient > (unsigned)(SOURCECLIENTREASK * m_pReqPartFile->GetCommonFilePenalty())) &&
                        (nTimePassedFile > SOURCECLIENTREASK) )
                )
          );
d202 1
a202 1
    EMULE_CATCH
d204 1
a204 1
    return false;
d209 1
a209 1
    EMULE_TRY
d211 1
a211 1
    ASSERT(m_pReqPartFile != NULL);
d213 2
a214 2
    if (m_pReqPartFile == NULL)
        return;
d216 1
a216 1
    AddAskedCountDown();
d218 1
a218 1
    CSafeMemFile        packetStream1(16 + 16);
d220 1
a220 1
    packetStream1.Write(m_pReqPartFile->GetFileHash(), 16);
d222 2
a223 2
    if (GetExtendedRequestsVersion() > 0)
        m_pReqPartFile->WritePartStatus(&packetStream1);
d225 2
a226 2
    if (GetExtendedRequestsVersion() > 1)
        m_pReqPartFile->WriteCompleteSourcesCount(&packetStream1); //netwolf: complete sources (zegzav) 13.05.03
d228 1
a228 1
    Packet      *pPacket = new Packet(&packetStream1);
d230 1
a230 1
    pPacket->m_eOpcode = OP_FILEREQUEST;
d232 1
a232 1
    g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d235 1
a235 1
    m_pRequestSocket->SendPacket(pPacket, true);
d238 1
a238 1
//  AddDebugLogLine(false ,"File Status: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
d240 6
a245 6
//  Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//  if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
//  know that the file is shared, we know also that the file is complete and don't need to request the file status.
    if (m_pReqPartFile->GetPartCount() > 1)
    {
        CSafeMemFile    packetStream2(16);
d247 1
a247 1
        packetStream2.Write(m_pReqPartFile->GetFileHash(), 16);
d249 1
a249 1
        pPacket = new Packet(&packetStream2);
d251 1
a251 1
        pPacket->m_eOpcode = OP_SETREQFILEID;
d253 1
a253 1
        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d257 1
a257 1
        m_pRequestSocket->SendPacket(pPacket, true);
d260 1
a260 1
    }
d262 11
a272 11
    if (IsEmuleClient())
    {
        SetRemoteQueueFull(true);
        SetRemoteQueueRank(0);
    }

    if ( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() < m_pReqPartFile->GetSourceCount()
      || g_eMuleApp.m_pGlobPrefs->IsDisabledXS() )
    {
        return;
    }
d274 10
a283 10
//  DonGato - Disable XS for up to X sources
    if ( g_eMuleApp.m_pGlobPrefs->DisableXSUpTo()
      && g_eMuleApp.m_pGlobPrefs->XSUpTo() < m_pReqPartFile->GetSourceCount() )
    {
        return;
    }

    if (IsSourceRequestAllowed())
    {
        m_pReqPartFile->SetLastAnsweredTimeTimeout();
d285 1
a285 1
        Packet      *pPacket = new Packet(OP_REQUESTSOURCES, 16, OP_EMULEPROT);
d287 2
a288 2
        md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(pPacket->m_dwSize);
d290 1
a290 1
        m_pRequestSocket->SendPacket(pPacket, true, true);
d292 2
a293 2
    //  AddDebugLogLine(false, "Send:Source Request User(%s) File(%s)", GetUserName(), m_pReqPartFile->GetFileName());
    }
d295 1
a295 1
    EMULE_CATCH
d298 1
a298 1
//  ProcessFileInfo() processes the contents of a File Request Answer packet
d301 1
a301 1
    EMULE_TRY
d303 1
a303 1
//  Create a memory stream from the packet and read its contents
d305 1
a305 1
    CSafeMemFile        packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d307 1
a307 1
    uchar       fileHash[16];
d309 1
a309 1
    packetStream.Read(fileHash, sizeof(fileHash));
d311 1
a311 1
    uint16      uNameLength;
d313 1
a313 1
    packetStream.Read(&uNameLength, sizeof(uint16));
d315 2
a316 2
    packetStream.Read(m_strClientFilename.GetBuffer(uNameLength), uNameLength);
    m_strClientFilename.ReleaseBuffer(uNameLength);
d318 1
a318 1
    m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
d320 14
a333 14
//  Patch 'fix disappearing m_pReqPartFile' START (taab)
    if (m_pReqPartFile == NULL)
    {
        CKnownFile      *pReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(fileHash);

        if (pReqFile != NULL && pReqFile->IsPartFile())
            m_pReqPartFile = dynamic_cast<CPartFile*>(pReqFile);
    }

    if (m_pReqPartFile == NULL)
    {
//      AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
        return;
    }
d335 4
a338 4
    if (md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
    {
        AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile != fileHash)"), __FUNCTION__);
    }
d341 24
a364 24
//  Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//  if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
//  know that the file is shared, we know also that the file is complete and don't need to request the file status.
    if (m_pReqPartFile->GetPartCount() == 1){
        if (m_pbytePartStatuses)
        {
            delete[] m_pbytePartStatuses;
            m_pbytePartStatuses = NULL;
        }

        m_uPartCount = m_pReqPartFile->GetPartCount();
        m_pbytePartStatuses = new byte[m_uPartCount];
        memset2(m_pbytePartStatuses, 1, m_uPartCount);
        m_bCompleteSource = true;

        m_pReqPartFile->NewSrcPartsInfo();
        UpdateDisplayedInfo();

    //  even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
        if (m_pReqPartFile->m_bHashSetNeeded)
        {
            Packet * pPacket = new Packet(OP_HASHSETREQUEST, 16);
            md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
            g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d366 1
a366 1
            m_pRequestSocket->SendPacket(pPacket, true, true);
d369 11
a379 11
            SetDownloadState(DS_REQHASHSET);
            m_pReqPartFile->m_bHashSetNeeded = false;
        }
        else
        {
            SetDownloadState(DS_ONQUEUE);
            CSafeMemFile data1(16); //TwoBottle Mod
            data1.Write(m_pReqPartFile->GetFileHash(), 16);
            Packet* pPacket = new Packet(&data1);
            pPacket->m_eOpcode = OP_STARTUPLOADREQ;
            g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d381 1
a381 1
            m_pRequestSocket->SendPacket(pPacket, true, true);
d384 3
a386 3
            m_dwLastAskedTime = ::GetTickCount();
        }
    }
d388 1
a388 1
    EMULE_CATCH
d393 78
a470 1
    EMULE_TRY
d472 1
a472 86
    if (m_pReqPartFile == NULL)
    {
        m_pReqPartFile = pReqPartFile;

        if (m_pReqPartFile == NULL)
        {
//          AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
            return;
        }
    }
    else if (m_pReqPartFile != pReqPartFile)
    {
//      AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile!=pcFileHash)"), __FUNCTION__);
        return;
    }

    uint16 uED2KPartCount;

    packetStream->Read(&uED2KPartCount, 2);

    if (m_pbytePartStatuses)
    {
        delete[] m_pbytePartStatuses;
        m_pbytePartStatuses = NULL;
    }

    bool bPartsNeeded = false;

    m_uPartCount = m_pReqPartFile->GetPartCount();
    if (uED2KPartCount == 0)
    {
        m_pbytePartStatuses = new byte[m_uPartCount];
        memset2(m_pbytePartStatuses, 1, m_uPartCount);
        bPartsNeeded = true;
        m_bCompleteSource = true;
    }
    else
    {
        if (m_pReqPartFile->GetED2KPartCount() != uED2KPartCount)
        {
            m_uPartCount = 0;
            throw GetResString(IDS_ERR_WRONGPARTNUMBER);
        }

        m_bCompleteSource = false;
        uint16 nCompleteSourcePart = 0; // zegzav:completesrc (add)
        m_pbytePartStatuses = new byte[m_uPartCount];
        uint16 done = 0;

        while (done != m_uPartCount)
        {
            byte toread;
            packetStream->Read(&toread, 1);

            for (sint32 i = 0;i != 8;i++)
            {
                m_pbytePartStatuses[done] = ((toread >> i) & 1) ? 1 : 0;
                if (m_pbytePartStatuses[done])
                {
                    nCompleteSourcePart++;
                    if (!m_pReqPartFile->IsComplete(done * PARTSIZE, ((done + 1) * PARTSIZE) - 1))
                        bPartsNeeded = true;
                }
                done++;

                if (done == m_uPartCount)
                    break;
            }
        }

        if (nCompleteSourcePart == m_uPartCount)
            m_bCompleteSource = true;
    }

    m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
    UpdateDisplayedInfo();

    //CheckForUpPartsInfo(); // obaldin

    if (!bPartsNeeded)
        SetDownloadState(DS_NONEEDEDPARTS);
    else if (!bUDPPacket)
    {
        if (m_pReqPartFile->m_bHashSetNeeded)
        {
            Packet  *pPacket = new Packet(OP_HASHSETREQUEST, 16);
d474 10
a483 2
            md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
            g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d485 1
a485 1
            m_pRequestSocket->SendPacket(pPacket, true, true);
d496 2
a497 2
            md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
            g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d499 1
a499 1
            m_pRequestSocket->SendPacket(pPacket, true, true);
d502 8
a509 8
            SetDownloadState(DS_ONQUEUE);
            m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
        //AddDebugLogLine(false,"File Upload: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
        }
    }
    else if (bPartsNeeded && GetDownloadState() != DS_ONQUEUE)
            SetDownloadState(DS_ONQUEUE);
    EMULE_CATCH
d514 1
a514 1
    EMULE_TRY
d516 2
a517 2
    if (file == NULL)
        return false;
d520 4
a523 4
    if (m_otherRequestsList.Find(file) != 0)
        return false;
    else
    m_otherRequestsList.AddTail(file);
d525 2
a526 2
    if (!file->m_A4AFsrcList.Find(this))
        file->m_A4AFsrcList.AddTail(this);
d528 1
a528 1
    return true;
d530 1
a530 1
    EMULE_CATCH
d532 1
a532 1
    return false;
d537 1
a537 1
    EMULE_TRY
d539 2
a540 2
    if (pPartFile == NULL)
        return;
d542 2
a543 2
//  Check Other list
    POSITION posPartFile = m_otherRequestsList.Find(pPartFile);
d545 4
a548 4
    if (posPartFile != NULL)
    {
        m_otherRequestsList.RemoveAt(posPartFile);
    }
d550 1
a550 1
    m_otherNoNeededMap.RemoveKey(pPartFile);
d552 1
a552 1
    EMULE_CATCH
d557 1
a557 1
    EMULE_TRY
d559 8
a566 8
    if (m_eDownloadState != byNewState)
    {
        //clear variables before switching
        switch (m_eDownloadState)
        {
            case DS_DOWNLOADING:
                if (m_pReqPartFile)
                    m_pReqPartFile->RemoveDownloadingSource(this);
d568 4
a571 4
                if (m_bTransferredDownMini && byNewState != DS_ERROR)
                    g_eMuleApp.m_pGlobPrefs->Add2DownSuccessfulSessions(); // Increment our counters for successful sessions (Cumulative AND Session)
                else
                    g_eMuleApp.m_pGlobPrefs->Add2DownFailedSessions(); // Increment our counters failed sessions (Cumulative AND Session)
d573 1
a573 1
                g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime((::GetTickCount() - m_dwDownStartTime) / 1000);
d575 2
a576 2
                //prevet any action from the client
                m_eDownloadState = byNewState;
d578 1
a578 1
                ClearDownloadBlocksList();
d580 1
a580 1
                ClearPendingBlocksList();
d582 1
a582 1
                m_dwDownDataRate = 0;
d584 4
a587 4
                if (byNewState == DS_NONE)
                {
                    if (m_pbytePartStatuses)
                        delete[] m_pbytePartStatuses;
d589 1
a589 1
                    m_pbytePartStatuses = 0;
d591 2
a592 2
                    m_uPartCount = 0;   //SyruS (0.29c)
                }
d594 1
a594 1
                m_uLastPartAsked = 0xFFFF;
d598 2
a599 2
                if (m_pRequestSocket && byNewState != DS_ERROR)
                    m_pRequestSocket->DisableDownloadLimit();
d601 1
a601 1
                break;
d603 3
a605 3
            case DS_ERROR:
                return;
        }
d607 2
a608 2
    //  switch the state & update info
        m_eDownloadState = byNewState;
d610 6
a615 6
        //prepare variables for new state
        switch (byNewState)
        {
            case DS_DOWNLOADING:
            //  Update statistical variables (start time of DL & minimal amount)
                m_dwLastDataRateCalculationTime = m_dwDownStartTime = ::GetTickCount();
d617 1
a617 1
                m_bTransferredDownMini = false;
d619 1
a619 1
                m_pReqPartFile->AddDownloadingSource(this);
d621 2
a622 2
                if (IsEmuleClient())
                    SetRemoteQueueFull(false);
d624 1
a624 1
                SetAskedCountDown(0);
d626 1
a626 1
                SetRemoteQueueRank(0, false);
d628 5
a632 5
                break;
            case DS_CONNECTED:
                m_dwEnteredConnectedState = ::GetTickCount();
                break;
        }
d634 2
a635 2
        UpdateDisplayedInfo(true);
    }
d637 1
a637 1
    EMULE_CATCH
d642 1
a642 1
    EMULE_TRY
d650 1
a650 1
    CSafeMemFile data1((BYTE*)pPacket, size);
d664 1
a664 1
        m_pRequestSocket->SendPacket(opacket, true, true);
d667 7
a673 7
        m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
    }
    else
    {
        m_pReqPartFile->m_bHashSetNeeded = true;
        AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_BADHASHSET), m_pReqPartFile->GetFileName());
    }
d675 1
a675 1
    EMULE_CATCH
d680 1
a680 1
    EMULE_TRY
d682 1
a682 1
    m_dwLastBlockReceived = GetTickCount();
d684 2
a685 2
    if (m_pReqPartFile == NULL)
        return;
d687 13
a699 60
//  Get blocks from the same chunk first
    if (m_downloadBlocksList.IsEmpty())
    {
        //eklmn: get part for request. if actual part still has empty blocks, the we get the actuall
        // part, otherwise it will be a new part
        m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this);

        if (m_uLastPartAsked != 0xFFFF)     //previous active part ?
        {
        //  Barry - instead of getting 3, just get how many is needed
            uint16      uCount, uSavedCount;

            uSavedCount = uCount = 3 - m_pendingBlocksList.GetCount();

            Requested_Block_Struct  **ppRequestedBlocksToAdd = new Requested_Block_Struct * [uCount];

            m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, ppRequestedBlocksToAdd, &uCount);

            if (uCount == 0)        //finished block (part ?)
            {
            //  check if part was completed

                if ( m_pReqPartFile->GetBytesInPart(m_uLastPartAsked, true, true) == 0
                  || m_pReqPartFile->IsCorruptedPart(m_uLastPartAsked) )
                {
                    m_uLastPartAsked = 0xFFFF; //ICR 2.10
                }

                m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this); //get next part

                if (m_uLastPartAsked != 0xFFFF)     //more parts ?
                {
                    uCount = uSavedCount;
                    m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, ppRequestedBlocksToAdd, &uCount);
                }
            }

            for (int i = 0; i < uCount; i++)
            {
                m_downloadBlocksList.AddTail(ppRequestedBlocksToAdd[i]);
            }

            delete[] ppRequestedBlocksToAdd;
        }
    }

//  Barry - Why are unfinished blocks requested again, not just new ones?
    while (m_pendingBlocksList.GetCount() < 3 && !m_downloadBlocksList.IsEmpty())
    {
        Pending_Block_Struct        *pPendingBlock = new Pending_Block_Struct;

        pPendingBlock->m_pRequestedBlock = m_downloadBlocksList.RemoveHead();
        pPendingBlock->m_pZStream = NULL;
        pPendingBlock->iZStreamErr = 0;
        m_pendingBlocksList.AddTail(pPendingBlock);
    }

    if (m_pendingBlocksList.IsEmpty())
    {
        Packet      *pPacket = new Packet(OP_CANCELTRANSFER);
d701 48
a748 1
        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d751 1
a751 1
        m_pRequestSocket->SendPacket(pPacket, true, true);
d754 1
a754 1
        EnumDLQState eOldDowloadState = GetDownloadState();
d756 2
a757 2
        if ((GetTickCount() - GetLastAskedTime()) > FILEREASKTIME)
            AskForDownload();
d759 2
a760 2
        if (eOldDowloadState == GetDownloadState())
                SetDownloadState(DS_NONEEDEDPARTS);
d762 1
a762 1
//      AddDebugLogLine(false, "Cancel download from %s due empty block list", this->GetUserName());
d764 2
a765 2
        return;
    }
d767 1
a767 1
    Packet      *pPacket = new Packet(OP_REQUESTPARTS, 40);
d769 1
a769 1
    CSafeMemFile        packetStream(reinterpret_cast<BYTE*>(pPacket->m_pcBuffer), 40);
d771 1
a771 1
    packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
d773 2
a774 2
    POSITION        pos = m_pendingBlocksList.GetHeadPosition();
    uint32          dwNull = 0;
d776 1
a776 1
    Requested_Block_Struct      *pRequestedBlock;
d778 12
a789 12
    for (uint32 i = 0; i < 3; i++)
    {
        if (pos != NULL)
        {
            pRequestedBlock = m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock;
            packetStream.Write(&pRequestedBlock->m_dwStartOffset, 4);
        }
        else
        {
            packetStream.Write(&dwNull, 4);
        }
    }
d791 1
a791 1
    pos = m_pendingBlocksList.GetHeadPosition();
d793 5
a797 5
    for (uint32 i = 0; i < 3; i++)
    {
        if (pos != NULL)
        {
            pRequestedBlock = m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock;
d799 1
a799 1
            uint32      dwEndOffset = pRequestedBlock->m_dwEndOffset + 1;
d801 7
a807 7
            packetStream.Write(&dwEndOffset, 4);
        }
        else
        {
            packetStream.Write(&dwNull, 4);
        }
    }
d809 1
a809 1
    g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d812 1
a812 1
    m_pRequestSocket->SendPacket(pPacket, true, true);
d815 1
a815 1
    EMULE_CATCH
d835 3
a837 1
    EMULE_TRY
d839 2
a840 1
    const int       HEADER_SIZE = 24;
d842 12
a853 2
//  Update timer (eklmn: don't remove this value cause it use to timeout check)
    m_dwLastBlockReceived = ::GetTickCount();
d855 81
a935 95
//  Read data from packet
    CSafeMemFile        packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);

    uchar       fileHash[16];

    packetStream.Read(fileHash, sizeof(fileHash));              //<HASH>

//  Check that this data is for the correct file
    if (m_pReqPartFile == NULL || md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
    {
        throw CString(CString(__FUNCTION__) + _T(": ") + GetResString(IDS_ERR_WRONGFILEID));
    }

//  Find the start & end positions, and size of this chunk of data
    uint32          dwStartPos = 0;
    uint32          dwEndPos = 0;
    uint32          dwBlockSize = 0;
    const uint32    dwDataTransferdInPacket = dwPacketSize - HEADER_SIZE;

    packetStream.Read(&dwStartPos, sizeof(uint32));             //<BYTEOFFSET:DWORD> start position

    if (bPacked)
    {
        packetStream.Read(&dwBlockSize, sizeof(uint32));        //<BYTELENGTH:DWORD> packed block size
        dwEndPos = dwStartPos + dwDataTransferdInPacket;
        m_bUsedCompressionDown = true;
    }
    else
    {
        packetStream.Read(&dwEndPos, sizeof(uint32));           //<BYTEOFFSET:DWORD> end position
    }

//  Check that packet size matches the declared packetStream packet + header size (24)
    if (dwPacketSize != ((dwEndPos - dwStartPos) + HEADER_SIZE))
    {
        throw CString(CString(__FUNCTION__ ": ") + GetResString(IDS_ERR_BADDATABLOCK));
    }

//  Protect from 0 data size, because it spoils statistics
    if (dwDataTransferdInPacket == 0)
    {
        return;
    }

//  Extended statistics information based on which client and remote port sent this data.
//      The new function adds the bytes to the grand total as well as the given client/port.
//      bFromPF is not relevant to downloaded data.  It is purely an uploads statistic.
    g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket);

//  Move end back one, should be inclusive
    m_pCredits->AddDownloaded(dwDataTransferdInPacket, this->GetIP());

    dwEndPos--;

    m_dwTransferredDown += dwDataTransferdInPacket;

    m_dwTransferredInLastPeriod += dwDataTransferdInPacket;

//  Loop through to find the reserved block that this is within
    Pending_Block_Struct* cur_block;

    POSITION pos1, pos2;

    for (pos1 = m_pendingBlocksList.GetHeadPosition(); (pos2 = pos1) != NULL; )
    {
        cur_block = m_pendingBlocksList.GetNext(pos1);
    //  Cax2: I'm not happy with this whole if clause

        if ((cur_block->m_pRequestedBlock->m_dwStartOffset <= dwStartPos) && (cur_block->m_pRequestedBlock->m_dwEndOffset >= dwStartPos))
        {
        //  Found reserved block

            if (cur_block->iZStreamErr != 0)
            {
                m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
                break;
            }

        //  Remember this start pos, used to draw part downloading in list
            m_dwLastBlockOffset = dwStartPos;

        //  Occasionally packets are duplicated, no point writing it twice
        //  This will be 0 in these cases, or the length written otherwise
            uint32 lenWritten = 0;

        //  Handle differently depending on whether bPacked or not

            if (!bPacked)
            {
            //  Write to disk (will be buffered in part file class)
                lenWritten = m_pReqPartFile->WriteToBuffer( dwDataTransferdInPacket,
                             (BYTE *) (pcPacketBuf + HEADER_SIZE),
                             dwStartPos,
                             dwEndPos,
                             cur_block->m_pRequestedBlock );
d937 2
a938 2
                if (lenWritten == 0)
                    AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d940 72
a1011 72
            }
            else // Packed
            {
            //  Create space to store unzipped packetStream, the dwPacketSize is only an initial guess, will be resized in unzip() if not big enough
                uint32 lenUnzipped = (dwPacketSize * 2);
            //  Don't get too big

                if (lenUnzipped > (EMBLOCKSIZE + 300))
                    lenUnzipped = (EMBLOCKSIZE + 300);

                BYTE *unzipped = new BYTE[lenUnzipped];

            //  Try to unzip the pcPacketBuf
                int result = unzip(cur_block, (BYTE *)(pcPacketBuf + HEADER_SIZE), dwDataTransferdInPacket, &unzipped, &lenUnzipped);

                if (result == Z_OK)
                {
                //  Write any unzipped packetStream to disk

                    if (lenUnzipped > 0)
                    {
                    //  Use the current start and end positions for the uncompressed packetStream
                        dwStartPos = cur_block->m_pRequestedBlock->m_dwStartOffset + cur_block->m_dwTotalUnzipped - lenUnzipped;
                        dwEndPos = cur_block->m_pRequestedBlock->m_dwStartOffset + cur_block->m_dwTotalUnzipped - 1;

                        if (dwBlockSize * 25 < lenUnzipped)
                        {
                            m_uLastPartAsked = 0xFFFF;  //eklmn: feature(00): ICR (reset choosen part in case suspicious block)

                            AddDebugLogLine(true, RGB_LOG_DIMMED_TXT _T("Received suspicious block: file '%s', part %u, block %u, blocksize %u, comp. blocksize %u"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
                            AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("username '%s', ip %u.%u.%u.%u:%u, hash %s"),
                                m_strUserName, (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8),
                                (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24),
                                GetUserPort(), HashToString(GetUserHash()));

                            if (m_pReqPartFile->GetDiscardSuperCompressed())
                            {
                            //--- (un)comment the block-dropping as you wish---
                                m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwStartOffset + 1);
                                uint32 ip1 = 0;
                                CString buf, temp;
                                int counter = 0;
                                buf.Format(_T("%u.%u.%u.%u"), (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24));

                                for (int i = 0; i < 4; i++)
                                {
                                    temp = buf.Tokenize(_T("."), counter);
                                    ip1 += _tstoi(temp) * pow(256, 3 - i);
                                }
                                //eklmn: add to temporary(24h) banned
                                g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(ip1);
                                // set an ERROR state, client will be removed & disconnected by PartFile::Process later on
                                SetDownloadState(DS_ERROR);
                                AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("block dropped & IP locked out!"));
                            }

                        //  BavarianSnail
                            else
                            {
                                if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
                                {
                                    AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
                                    m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
                                }
                                else
                                {
                                //  Write uncompressed packetStream to file
                                    lenWritten = m_pReqPartFile->WriteToBuffer(dwDataTransferdInPacket,
                                                 unzipped,
                                                 dwStartPos,
                                                 dwEndPos,
                                                 cur_block->m_pRequestedBlock );
d1013 2
a1014 2
                                    if (lenWritten == 0)
                                        AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1016 2
a1017 2
                                }
                            }
d1019 17
a1035 17
                        //- BavarianSnail
                        }
                        else
                        {
                            if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
                            {
                                AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
                                m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
                            }
                            else
                            {
                            //  Write uncompressed packetStream to file
                                lenWritten = m_pReqPartFile->WriteToBuffer( dwDataTransferdInPacket,
                                             unzipped,
                                             dwStartPos,
                                             dwEndPos,
                                             cur_block->m_pRequestedBlock );
d1037 2
a1038 2
                                if (lenWritten == 0)
                                    AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1040 56
a1095 69
                            }
                        }
                    }
                }
                else
                {
                    cur_block->iZStreamErr = result;
                    AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), result);
                    m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);

                //  Release resources in case of decompression error
                    if (cur_block->m_pZStream != NULL)
                    {
                        inflateEnd(cur_block->m_pZStream);
                        delete cur_block->m_pZStream;
                        cur_block->m_pZStream = NULL;
                    }
                }

                try
                {
                    if (unzipped)
                delete [] unzipped;
            }
                catch (...)
                {}

            }

            //eklmn: check result of WriteToBuffer, if we save some byte, then this DL session can be
            // counted as succesful
            if (lenWritten > 0)
            {
                m_bTransferredDownMini = true;      // -khaos--+++> For determining whether the current download session was a success or not.
            }

            // eklmn: it needs to check "END of the block" condition every time, cause
            //  if remote client will send us a data that already were written, we will not delete the block & delete a packet

            //  [TwoBottle Mod]: If finished reserved block
            //  in this place because m_pReqPartFile->WriteToBuffer was called
            //  cur_block can be already deleted (if file was completed)
            //  so to avoid access violation here we will check
            //  m_pendingBlocksList for emptyness....possibly there is
            //  better check
            if (!m_pendingBlocksList.IsEmpty() && dwEndPos == cur_block->m_pRequestedBlock->m_dwEndOffset)
            {
                m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
                delete cur_block->m_pRequestedBlock;
            //  Not always allocated

                if (cur_block->m_pZStream)
                {
                    inflateEnd(cur_block->m_pZStream);
                    delete cur_block->m_pZStream;
                }

                delete cur_block;
                m_pendingBlocksList.RemoveAt(pos2);

            //  Request next block
                SendBlockRequests();
            }


        //  Stop looping and exit method
            break;
        }
    }
d1097 14
a1110 1
    EMULE_CATCH
d1115 32
a1146 1
    int iErr = Z_MEM_ERROR;
d1148 2
a1149 1
    EMULE_TRY
d1151 4
a1154 2
//  Save some typing
    z_stream *zS = pRequestedBlock->m_pZStream;
d1156 13
a1168 90
//  Is this the first time this block has been unzipped
    if (zS == NULL)
    {
        pRequestedBlock->m_dwTotalUnzipped = 0;
    //  Create stream
        zS = pRequestedBlock->m_pZStream = new z_stream;

    //  Initialize stream values
        zS->zalloc = (alloc_func)0;
        zS->zfree = (free_func)0;

    //  Set output data streams, do this here to avoid overwriting on recursive calls
        zS->next_out = *ppbyteUzipped;
        zS->avail_out = *pdwLenUnzipped;

    //  Initialise the z_stream
        iErr = inflateInit(zS);

        if (iErr != Z_OK)
            return iErr;
    }

//  Use whatever input is provided
    zS->next_in = pbyteZipped;
    zS->avail_in = dwLenZipped;

    zS->next_out = *ppbyteUzipped;
    zS->avail_out = *pdwLenUnzipped;

    for (;;)
    {
    //  Unzip the data
        iErr = inflate(zS, Z_SYNC_FLUSH);

        if (iErr == Z_OK)
        {
            if (zS->avail_in == 0)
            {
            //  All available input has been successfully processed.
            //  Set the size to the amount unzipped in this call.
                *pdwLenUnzipped = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
                pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
            }
            else if (zS->avail_out == 0)
            {
            //  Output buffer is full
                uint32      dwNewLen = (*pdwLenUnzipped << 1);  //  increase output buffer size

                iErr = Z_MEM_ERROR; //  be ready for lack of memory

            //  Copy unzipped data to a new buffer
                BYTE        *pbyteNewBuff = new BYTE[dwNewLen];
                uint32      dwUnpackedSz = zS->total_out - pRequestedBlock->m_dwTotalUnzipped;

                memcpy2(pbyteNewBuff, *ppbyteUzipped, dwUnpackedSz);

                delete [] (*ppbyteUzipped);

                *ppbyteUzipped = pbyteNewBuff;
                *pdwLenUnzipped = dwNewLen;

            //  Set correct position inside a new output buffer
                zS->next_out = pbyteNewBuff + dwUnpackedSz;
                zS->avail_out = dwNewLen - dwUnpackedSz;
                continue;   //  try again
            }
        }
    //  Is zip finished reading all currently available input and writing all generated output
        else if (iErr == Z_STREAM_END)
        {
        //  Finish up
            iErr = inflateEnd(zS);
            pRequestedBlock->m_pZStream = NULL;

            if (iErr == Z_OK)
            {
            //  Got the good result, set the size to the unzipped amount
                *pdwLenUnzipped = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
                pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
            }
            delete zS;
        }
        else
        {
        //  Should not get here unless input data is corrupted
            *pdwLenUnzipped = 0;
        //  Error will be logged by caller on return
        }
        break;
    }
d1170 1
a1170 1
    EMULE_CATCH
d1172 44
a1215 1
    return iErr;
d1220 1
a1220 1
    EMULE_TRY
d1222 1
a1222 1
    uint32  dwCurTick = GetTickCount();
d1224 2
a1225 2
    if ((dwCurTick - m_dwLastBlockReceived) > DOWNLOADTIMEOUT)
    {
d1227 6
a1232 6
        if (m_pRequestSocket != NULL)
        {
            Packet * pPacket = new Packet(OP_CANCELTRANSFER);
            g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
            m_pRequestSocket->SendPacket(pPacket, true, true);
        }
d1235 33
a1267 2
        SetDownloadState(DS_ONQUEUE);
        m_dwDownDataRate = 0;
d1269 8
a1276 42
//      if (this != NULL)
//      {
//          AddDebugLogLine(false, "Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
//      }
    }
    else
    {
        uint32 time_diff_ms = dwCurTick - m_dwLastDataRateCalculationTime;

    //update average sum
        m_qwClientSumDLDataRateOverLastNMeasurements += m_dwTransferredInLastPeriod;
        m_qwClientSumDLTickOverLastNMeasurements += time_diff_ms;
    //  update a lists
        m_averageDLDataRateList.push_front(m_dwTransferredInLastPeriod);
        m_averageDLTickList.push_front(time_diff_ms);
    //  check lists size

        while (m_averageDLTickList.size() > 500)
        {
            m_qwClientSumDLDataRateOverLastNMeasurements -= m_averageDLDataRateList.back();
            m_averageDLDataRateList.pop_back();
            m_qwClientSumDLTickOverLastNMeasurements -= m_averageDLTickList.back();
            m_averageDLTickList.pop_back();
        }

    //  calculate average trasfered data (bytes)
        uint64 AverageTransferredData = m_qwClientSumDLDataRateOverLastNMeasurements / m_averageDLDataRateList.size();

    //  calculate average time period between measuremets (ms)
        uint64 AverageTransferTimePeriod = m_qwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();

    //  calculate a DL rate (b/s)
        if (AverageTransferTimePeriod != 0)
            m_dwDownDataRate = 1000 * AverageTransferredData / AverageTransferTimePeriod;
        else
            m_dwDownDataRate = 0;

    //update a time & reset data transferred over last period
        m_dwLastDataRateCalculationTime = dwCurTick;

        m_dwTransferredInLastPeriod = 0;
    }
d1278 2
a1279 1
    UpdateDisplayedInfo();
d1281 1
a1281 1
    return m_dwDownDataRate;
d1283 1
a1283 1
    EMULE_CATCH
d1285 3
a1287 1
    return 0;
d1292 1
a1292 1
    EMULE_TRY
d1294 1
a1294 1
    uint16 result = 0;
d1296 5
a1300 5
    for (int i = 0;i < m_uPartCount;i++)
    {
        if (IsPartAvailable(i))
            result++;
    }
d1302 1
a1302 1
    return result;
d1304 1
a1304 1
    EMULE_CATCH
d1306 1
a1306 1
    return 0;
d1311 1
a1311 1
    EMULE_TRY
d1313 7
a1319 7
    m_iDeltaQueueRank = static_cast<int>(nr) - static_cast<int>(m_uRemoteQueueRank);
    if (m_uRemoteQueueRank != nr)
    {
        m_uRemoteQueueRank = nr;
        if (bUpdateGUI)
            UpdateDisplayedInfo();
    }
d1321 1
a1321 1
    EMULE_CATCH
d1327 1
a1327 1
    EMULE_TRY
d1341 1
a1341 1
    //  Check: does client have another file?
d1344 1
a1344 1
    //  Check: target file is specified? if is not, then find another one...
d1359 1
a1359 1
                //  Calculate A4AF rating
d1365 1
a1365 1
 
d1373 2
a1374 2
            } 
        }
d1377 1
a1377 1
            SwapToPos = m_otherRequestsList.Find(SwapTo);
d1380 1
a1380 1
    //  Now let's swap the file to another
d1384 1
a1384 1
        //  To prevent loop swaping remember NNS-Part & time when it was switched
d1390 1
a1390 1
        //  Switch state to NONE
d1403 1
a1403 1
        //  Add to past comment
d1408 2
a1409 2
                m_strComment = _T("");
            //  Find current file position in sourceslots
d1414 1
a1414 1
                    m_pReqPartFile->m_srcLists[m_iSourcesSlot].RemoveAt(cur_FilePos);
d1416 1
a1416 1
            //  Add them in A4AF list
d1420 1
a1420 1
            //  Add old file to m_otherRequestsList
d1424 1
a1424 1
            //  Let's update current information for the removed file
d1427 1
a1427 1
            //  Update download list (old file update)
d1431 1
a1431 1
                m_pReqPartFile = NULL; 
d1434 1
a1434 1
        //  Actual switch
d1437 1
a1437 1
        //  Remove new file from OtherRequests list
d1440 1
a1440 1
        //  Remove current source from A4AF list in new file
d1446 1
a1446 1
        //  To prevent loop swaping remove a choosen part from NNS-Map
d1449 1
a1449 1
        //  Add to souceslots
d1453 2
a1454 2
        //  Remove from past comment
            SwapTo->RemovePastComment(this);
d1457 1
a1457 1
            SwapTo->NewSrcPartsInfo();
d1459 1
a1459 1
        //  Update download list (new file update)
d1462 1
a1462 1
        //  Now update the client item
d1471 1
a1471 1
    EMULE_CATCH
d1473 1
a1473 1
    return false;
d1478 1
a1478 1
    EMULE_TRY
d1480 3
a1482 3
    m_bUDPPending = false;
    SetRemoteQueueRank(nNewQR);
    m_dwLastAskedTime = ::GetTickCount();
d1484 1
a1484 1
    EMULE_CATCH
d1489 1
a1489 1
    EMULE_TRY
d1491 1
a1491 1
    m_bUDPPending = false;
d1494 6
a1499 6
    if (GetDownloadState() != DS_DOWNLOADING)
    {
        AddDebugLogLine(false, _T("UDP ANSWER FNF : %s"), GetUserName());
        //eklmn: try to swap the source to any file before remove them from DL-queue
        if (!SwapToAnotherFile(NULL))
            g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d1502 2
a1503 2
        if (!m_pRequestSocket)
            Disconnected();
d1507 3
a1509 3
    }
    else
        AddDebugLogLine(false, _T("UDP ANSWER FNF : %s (client not removed)"), GetUserName());
d1511 1
a1511 1
    EMULE_CATCH
d1516 1
a1516 1
    EMULE_TRY
d1518 1
a1518 1
    ASSERT (m_pReqPartFile);
d1520 2
a1521 2
    if (!m_pReqPartFile || m_bUDPPending)
        return;
d1523 2
a1524 2
//  Maverick Disable UDP when connecting to a PROXY
    ProxySettings proxy = g_eMuleApp.m_pGlobPrefs->GetProxy();
d1528 34
a1561 34
    if ( m_byteEmuleVersion >= 0x23
        && m_uUDPPort != 0
        && g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0
        && (!g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() )
        && !(m_pRequestSocket && m_pRequestSocket->IsConnected())
        && (!proxy.m_bUseProxy) )
    {

    //don't use udp to ask for sources

        if (IsSourceRequestAllowed())
            return;

        m_bUDPPending = true;

        CSafeMemFile    packetStream(128);

        packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
        if (GetUDPVersion() > 3)
        {
            if (m_pReqPartFile->IsPartFile())
                ((CPartFile*)m_pReqPartFile)->WritePartStatus(&packetStream);
            else
            {
                uint16  uNull = 0;

                packetStream.Write(&uNull, 2);
            }
        }
        if (GetUDPVersion() > 2)
        {
            uint16  uCompleteSourcesCount = m_pReqPartFile->GetCompleteSourcesCount();
            packetStream.Write(&uCompleteSourcesCount, 2);
        }
d1563 1
a1563 1
        Packet      *pPacket = new Packet(&packetStream, OP_EMULEPROT);
d1565 1
a1565 1
        pPacket->m_eOpcode = OP_REASKFILEPING;
d1567 1
a1567 1
        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1569 2
a1570 2
        g_eMuleApp.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort());
    }
d1574 1
a1574 1
    EMULE_CATCH
d1577 1
a1577 1
//  Barry - Sets the vector of bool 'parts' to show the pending status of each part.
d1580 1
a1580 1
    EMULE_TRY
d1582 1
a1582 1
    parts.resize(m_uPartCount);
d1584 2
a1585 2
    for (POSITION pos = m_pendingBlocksList.GetHeadPosition(); pos != NULL; )
        parts[m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock->m_dwStartOffset / PARTSIZE] = true;
d1587 1
a1587 1
    EMULE_CATCH
d1592 1
a1592 1
    g_eMuleApp.m_pDownloadList->UpdateSource(this);
d1595 1
a1595 1
//  New functions by Mr.Fry
d1598 1
a1598 1
    EMULE_TRY
d1600 1
a1600 1
    uint16 uCount = 0;
d1602 5
a1606 5
    if (m_pbytePartStatuses != NULL && m_uPartCount > 0)
    {
        for (int i = 0; i < m_uPartCount ; i++)
            if (m_pbytePartStatuses[i] && !m_pReqPartFile->IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
                uCount++;
d1608 2
a1609 2
    //TRACE("Counted %u Chunks (parts) that %s has and I need (to download)",uCount,GetUserName());
    }
d1611 1
a1611 1
    return uCount;
d1613 1
a1613 1
    EMULE_CATCH
d1615 1
a1615 1
    return 0;
d1621 1
a1621 1
    EMULE_TRY
d1623 8
a1630 8
    if (m_eDownloadState == DS_DOWNLOADING)
    {
        return      static_cast<uint32>(m_dwLastBlockOffset / PARTSIZE);
    }
    else
    {
        return 0xFFFF;
    }
d1632 1
a1632 1
    EMULE_CATCH
d1634 1
a1634 1
    return 0xFFFF;
d1640 13
a1652 1
    EMULE_TRY
d1654 4
a1657 1
    Pending_Block_Struct*       pPendingBlock;
d1659 9
a1667 24
    while (!m_pendingBlocksList.IsEmpty() )
    {
        pPendingBlock = m_pendingBlocksList.RemoveHead();

        if (pPendingBlock)
        {
            if (pPendingBlock->m_pRequestedBlock)
            {
                CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pPendingBlock->m_pRequestedBlock->m_fileHash);

                pReqFile->RemoveBlockFromList(pPendingBlock->m_pRequestedBlock->m_dwStartOffset,
                                            pPendingBlock->m_pRequestedBlock->m_dwEndOffset);
                delete pPendingBlock->m_pRequestedBlock;
            }

            if (pPendingBlock->m_pZStream)
            {
                inflateEnd(pPendingBlock->m_pZStream);
                delete pPendingBlock->m_pZStream;
            }
            delete pPendingBlock;
        }
        pPendingBlock = NULL;
    }
d1669 1
a1669 1
    EMULE_CATCH
d1672 1
a1672 1
//  If downloadBlocks are existing free block reserved in pPartFile
d1675 11
a1685 11
    while (!m_downloadBlocksList.IsEmpty())
    {
        Requested_Block_Struct* pDLBlock =  m_downloadBlocksList.RemoveHead();
        if (pDLBlock)
        {
            CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pDLBlock->m_fileHash);

            pReqFile->RemoveBlockFromList(pDLBlock->m_dwStartOffset, pDLBlock->m_dwEndOffset);
            delete pDLBlock;
        }
    }
@


1.206
log
@Formatting and old code removal
@
text
@d488 7
a494 6
            SetDownloadState(DS_REQHASHSET);
            m_pReqPartFile->m_bHashSetNeeded = false;
        }
        else
        {
            Packet  *pPacket = new Packet(OP_STARTUPLOADREQ, 16);
d644 5
a648 2
    if ((!m_pReqPartFile) || md4cmp(pPacket, m_pReqPartFile->GetFileHash()))
        throw GetResString(IDS_ERR_WRONGFILEID);
d652 10
a661 9
    if (m_pReqPartFile->LoadHashsetFromFile(data1, true))
    {
        SetDownloadState(DS_ONQUEUE);

        CSafeMemFile data2(16);
        data2.Write(this->m_pReqPartFile->GetFileHash(), 16);
        Packet* opacket = new Packet(&data2);
        opacket->m_eOpcode = OP_STARTUPLOADREQ;
        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(opacket->m_dwSize);
d1330 11
a1340 11
//  Check if we are downloading something from client
    if (GetDownloadState() == DS_DOWNLOADING)
        return false;

    POSITION        SwapToPos = 0;
    POSITION        cur_FilePos;
    CPartFile      *pCurFile;
    uint32          dwLastNNSCheckedTime = ::GetTickCount();
    const uint16    uPriorityFactorsArray[3] = {1,2,3};
    uint16          uA4AFRating;
    uint16          uBestA4AFRating = 0;
d1343 2
a1344 2
    if (!m_otherRequestsList.IsEmpty())
    {
d1346 13
a1358 13
        if (!SwapTo)
        {
        //  Do not change this unless you want unpredictable results :P
            for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != 0;m_otherRequestsList.GetNext(cur_FilePos))
            {
                pCurFile = m_otherRequestsList.GetAt(cur_FilePos);

            //  Get first high priority files
                if ( pCurFile != m_pReqPartFile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(pCurFile)
                     && (pCurFile->GetStatus(false) == PS_READY || pCurFile->GetStatus(false) == PS_EMPTY) )
                {
                //  Check: is new file in NNS-Map?
                    bool    bNNS = m_otherNoNeededMap.Lookup(pCurFile, dwLastNNSCheckedTime);
d1361 5
a1365 5
                    if (bNNS)
                        uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()]
                            + static_cast<uint16>((::GetTickCount() - dwLastNNSCheckedTime)/FILEREASKTIME);
                    else
                        uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()] * 3;
d1367 7
a1373 7
                    if (uA4AFRating >= uBestA4AFRating)
                    {
                        SwapTo = pCurFile;
                        SwapToPos = cur_FilePos ;
                        uBestA4AFRating = uA4AFRating;
                    }
                }
d1376 2
a1377 2
        else if (SwapTo->GetStatus(false) == PS_READY || SwapTo->GetStatus(false) == PS_EMPTY)
        {
d1379 1
a1379 1
        }
d1382 2
a1383 2
        if (SwapTo != NULL && SwapToPos != 0)
        {
d1386 4
a1389 4
            if ( m_pReqPartFile != NULL && GetDownloadState() == DS_NONEEDEDPARTS)
            {
                m_otherNoNeededMap[m_pReqPartFile] = ::GetTickCount();
            }
d1392 1
a1392 1
            SetDownloadState(DS_NONE);
d1394 9
a1402 9
            if (m_pbytePartStatuses)
            {
                delete[] m_pbytePartStatuses;
                m_pbytePartStatuses = 0;
            }

            m_uPartCount = 0;
            m_dwLastAskedTime = 0;
            m_uLastPartAsked = 0xFFFF;
d1405 4
a1408 4
            if (m_pReqPartFile != NULL)
            {
                m_pReqPartFile->AddPastComment(this);
                m_eRating = PF_RATING_NONE;
d1411 1
a1411 1
                cur_FilePos = m_pReqPartFile->m_srcLists[m_iSourcesSlot].Find(this);
d1414 1
a1414 1
 	 			if (cur_FilePos)
d1418 2
a1419 2
                if (!m_pReqPartFile->m_A4AFsrcList.Find(this))
                    m_pReqPartFile->m_A4AFsrcList.AddTail(this);
d1422 2
a1423 2
                if (!m_otherRequestsList.Find(m_pReqPartFile))
                    m_otherRequestsList.AddTail(m_pReqPartFile);
d1426 1
a1426 1
                m_pReqPartFile->NewSrcPartsInfo();
d1429 1
a1429 1
                m_pReqPartFile->UpdateDisplayedInfo();
d1433 1
a1433 1
            }
d1436 1
a1436 1
            m_pReqPartFile = SwapTo;
d1439 1
a1439 1
            m_otherRequestsList.RemoveAt(SwapToPos);
d1442 1
a1442 1
            POSITION    pos_A4AF = SwapTo->m_A4AFsrcList.Find(this);
d1444 2
a1445 2
            if (pos_A4AF != NULL)
                SwapTo->m_A4AFsrcList.RemoveAt(pos_A4AF);
d1448 1
a1448 1
            m_otherNoNeededMap.RemoveKey(SwapTo);
d1451 2
a1452 2
            if (!SwapTo->m_srcLists[m_iSourcesSlot].Find(this))
                SwapTo->m_srcLists[m_iSourcesSlot].AddTail(this);
d1457 1
a1457 1
        //  Update info for target file
d1461 1
a1461 1
            SwapTo->UpdateDisplayedInfo();
d1464 1
a1464 1
            UpdateDisplayedInfo(true);
d1466 3
a1468 3
            return true;
        }
    }
@


1.205
log
@fixed CSafeMemFile write error bug due to NULL pointer arg
@
text
@d35 2
a36 2
//	members of CUpDownClient
//	which are mainly used for downloading functions
d40 1
a40 1
	EMULE_TRY
d42 59
a100 59
	const COLORREF crBoth = (bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);	//Cax2 - same green used for files & clients
	const COLORREF crNeither = (bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240);
	const COLORREF crClientOnly = (bFlat) ? RGB(0, 0, 0) : RGB(95, 95, 95);
	const COLORREF crPending = RGB(222, 160, 0);
	const COLORREF crToDo = RGB(255, 208, 0);
	const COLORREF crNextPending = RGB(255, 255, 100);
	const COLORREF crMeOnly = RGB(190, 190, 255);

	uint32 filesize = (m_pReqPartFile) ? m_pReqPartFile->GetFileSize() : 1;

	CBarShader statusBar(rect->bottom - rect->top, rect->right - rect->left);
	statusBar.SetFileSize(filesize);
	statusBar.Fill(crNeither);

	if (m_pReqPartFile)
	{
		if (!onlygreyrect && m_pReqPartFile && m_pbytePartStatuses)
		{
			_Bvector gettingParts;
			bool isDLing = (m_eDownloadState == DS_DOWNLOADING);

			if (isDLing)	//Cax2 - no unneded calls to showdownloadingparts...
				ShowDownloadingParts(gettingParts);		// Barry - was only showing one part from client, even when reserved bits from 2 parts

			uint32 uEnd; //Cax2 less cpu usage

			for (uint32 i = 0;i < m_uPartCount;i++)
			{
			//--- xrmb:seetheneed --- & Cax2 graphic glitch fix

				if (PARTSIZE * (i + 1) > filesize)
					uEnd = filesize;
				else
					uEnd = PARTSIZE * (i + 1);

				if (m_pbytePartStatuses[i])
				{ //they have this part
				//	do i have it ?

					if (m_pReqPartFile->IsComplete(PARTSIZE * i, PARTSIZE * (i + 1) - 1))
						statusBar.FillRange(PARTSIZE * i, uEnd, crBoth);
					else if (isDLing && m_dwLastBlockOffset < uEnd && m_dwLastBlockOffset >= PARTSIZE * i)
					{
						statusBar.FillRange(PARTSIZE * i, m_dwLastBlockOffset, crPending);
						statusBar.FillRange(m_dwLastBlockOffset, uEnd, crToDo);
					}
					else if (isDLing && gettingParts[i])	//Cax2 - no more flashes of yellow across all clients...
						statusBar.FillRange(PARTSIZE * i, uEnd, crNextPending);
					else
						statusBar.FillRange(PARTSIZE * i, uEnd, crClientOnly);
				}
				else //they don't have a part. Do I have it?
					if (m_pReqPartFile->IsComplete(PARTSIZE * i, PARTSIZE * (i + 1) - 1))
						statusBar.FillRange(PARTSIZE * i, uEnd, crMeOnly);

			//--- :xrmb --- & Cax2 graphic glitch fix
			}
		}
	}
d102 1
a102 1
	statusBar.Draw(dc, rect->left, rect->top, bFlat);
d104 1
a104 1
	EMULE_CATCH
d110 1
a110 1
	EMULE_TRY
d112 2
a113 2
	if (GetIP() && tocomp->GetIP() && GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())
		return true;
d115 2
a116 2
	if (HasValidHash() && tocomp->HasValidHash())
		return !md4cmp(GetUserHash(), tocomp->GetUserHash());
d118 4
a121 4
	if (HasLowID())
		return((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()) && (GetUserPort() == tocomp->GetUserPort()));
	else
		return((GetUserID() == tocomp->GetUserID() && GetUserPort() == tocomp->GetUserPort()) || (GetIP() && (GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())));
d123 1
a123 1
	EMULE_CATCH
d125 1
a125 1
	return false;
d131 1
a131 1
	EMULE_TRY
d135 11
a145 11
	if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()))
	{
		if (GetDownloadState() != DS_TOOMANYCONNS && GetDownloadState() != DS_DOWNLOADING)
			SetDownloadState(DS_TOOMANYCONNS);

	//	Added by Tarod [Dnowo]
	//	Vorlost halved the code: asking time random only at the beginning for each new source
		if (m_dwLastAskedTime == 0)
		{
			m_dwLastAskedTime = GetTickCount() - FILEREASKTIME + static_cast<uint32>(ROUND((static_cast<double>(rand()) / RAND_MAX) * 300000.0));
		}
d147 2
a148 2
		return true;
	}
d152 1
a152 1
	m_bUDPPending = false;
d154 1
a154 1
	m_dwLastAskedTime = GetTickCount();
d156 1
a156 1
	SetDownloadState(DS_CONNECTING);
d158 4
a161 4
	if (TryToConnect())
		return true;
	else
		return false;
d163 1
a163 1
	EMULE_CATCH
d165 1
a165 1
	return false;
d170 1
a170 1
	EMULE_TRY
d172 29
a200 29
	DWORD			dwTickCount = GetTickCount() + CONNECTION_LATENCY;
	unsigned int	nTimePassedClient = dwTickCount - GetLastSrcAnswerTime();
	unsigned int	nTimePassedFile = dwTickCount - m_pReqPartFile->GetLastAnsweredTime();
	bool			bNeverAskedBefore = GetLastSrcReqTime() == 0;

	UINT			dwSources = m_pReqPartFile->GetSourceCount();

//	Original client return false if client's SourceExchange Version is less or equal than 1
//	but i think we need to keep compatibility with old ePlus versions
	return (
			//	if client has the correct extended protocol
				ExtProtocolAvailable() && GetSourceExchangeVersion() >= 1 &&
			//	AND if we can send sources
				!g_eMuleApp.m_pGlobPrefs->IsDisabledXS() &&
			//	AND if we need more sources
				g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > m_pReqPartFile->GetSourceCount() &&
			//	AND if...
				(
				//	source is not complete and file is rare, allow once every 10 minutes
					( !m_bCompleteSource
						&& ( dwSources - m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4
							|| dwSources <= RARE_FILE * 2 )
						&& (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK) )
				//	otherwise, allow every 90 minutes, but only if we haven't
				//	asked someone else in last 10 minutes
					|| ( (bNeverAskedBefore || nTimePassedClient > (unsigned)(SOURCECLIENTREASK * m_pReqPartFile->GetCommonFilePenalty())) &&
						(nTimePassedFile > SOURCECLIENTREASK) )
				)
	      );
d202 1
a202 1
	EMULE_CATCH
d204 1
a204 1
	return false;
d209 1
a209 1
	EMULE_TRY
d211 1
a211 1
	ASSERT(m_pReqPartFile != NULL);
d213 2
a214 2
	if (m_pReqPartFile == NULL)
		return;
d216 1
a216 1
	AddAskedCountDown();
d218 1
a218 1
	CSafeMemFile		packetStream1(16 + 16);
d220 1
a220 1
	packetStream1.Write(m_pReqPartFile->GetFileHash(), 16);
d222 2
a223 2
	if (GetExtendedRequestsVersion() > 0)
		m_pReqPartFile->WritePartStatus(&packetStream1);
d225 2
a226 2
	if (GetExtendedRequestsVersion() > 1)
		m_pReqPartFile->WriteCompleteSourcesCount(&packetStream1); //netwolf: complete sources (zegzav) 13.05.03
d228 1
a228 1
	Packet		*pPacket = new Packet(&packetStream1);
d230 1
a230 1
	pPacket->m_eOpcode = OP_FILEREQUEST;
d232 1
a232 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d235 1
a235 1
	m_pRequestSocket->SendPacket(pPacket, true);
d238 1
a238 1
//	AddDebugLogLine(false ,"File Status: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
d240 6
a245 6
//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//	if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
//	know that the file is shared, we know also that the file is complete and don't need to request the file status.
	if (m_pReqPartFile->GetPartCount() > 1)
	{
		CSafeMemFile	packetStream2(16);
d247 1
a247 1
		packetStream2.Write(m_pReqPartFile->GetFileHash(), 16);
d249 1
a249 1
		pPacket = new Packet(&packetStream2);
d251 1
a251 1
		pPacket->m_eOpcode = OP_SETREQFILEID;
d253 1
a253 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d257 1
a257 1
		m_pRequestSocket->SendPacket(pPacket, true);
d260 1
a260 1
	}
d262 11
a272 11
	if (IsEmuleClient())
	{
		SetRemoteQueueFull(true);
		SetRemoteQueueRank(0);
	}

	if ( g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() < m_pReqPartFile->GetSourceCount()
	  || g_eMuleApp.m_pGlobPrefs->IsDisabledXS() )
	{
		return;
	}
d274 10
a283 10
//	DonGato - Disable XS for up to X sources
	if ( g_eMuleApp.m_pGlobPrefs->DisableXSUpTo()
	  && g_eMuleApp.m_pGlobPrefs->XSUpTo() < m_pReqPartFile->GetSourceCount() )
	{
		return;
	}

	if (IsSourceRequestAllowed())
	{
		m_pReqPartFile->SetLastAnsweredTimeTimeout();
d285 1
a285 1
		Packet		*pPacket = new Packet(OP_REQUESTSOURCES, 16, OP_EMULEPROT);
d287 2
a288 2
		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(pPacket->m_dwSize);
d290 1
a290 1
		m_pRequestSocket->SendPacket(pPacket, true, true);
d292 2
a293 2
	//	AddDebugLogLine(false, "Send:Source Request User(%s) File(%s)", GetUserName(), m_pReqPartFile->GetFileName());
	}
d295 1
a295 1
	EMULE_CATCH
d298 1
a298 1
//	ProcessFileInfo() processes the contents of a File Request Answer packet
d301 1
a301 1
	EMULE_TRY
d303 1
a303 1
//	Create a memory stream from the packet and read its contents
d305 1
a305 1
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);
d307 1
a307 1
	uchar		fileHash[16];
d309 1
a309 1
	packetStream.Read(fileHash, sizeof(fileHash));
d311 1
a311 1
	uint16		uNameLength;
d313 1
a313 1
	packetStream.Read(&uNameLength, sizeof(uint16));
d315 2
a316 2
	packetStream.Read(m_strClientFilename.GetBuffer(uNameLength), uNameLength);
	m_strClientFilename.ReleaseBuffer(uNameLength);
d318 1
a318 1
	m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
d320 14
a333 14
//	Patch 'fix disappearing m_pReqPartFile' START (taab)
	if (m_pReqPartFile == NULL)
	{
		CKnownFile		*pReqFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(fileHash);

		if (pReqFile != NULL && pReqFile->IsPartFile())
			m_pReqPartFile = dynamic_cast<CPartFile*>(pReqFile);
	}

	if (m_pReqPartFile == NULL)
	{
//		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
		return;
	}
d335 4
a338 4
	if (md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
	{
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile != fileHash)"), __FUNCTION__);
	}
d341 24
a364 24
//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
//	if the remote client answers the OP_FILEREQUEST with OP_FILEREQANSWER the file is shared by the remote client. if we
//	know that the file is shared, we know also that the file is complete and don't need to request the file status.
	if (m_pReqPartFile->GetPartCount() == 1){
		if (m_pbytePartStatuses)
		{
			delete[] m_pbytePartStatuses;
			m_pbytePartStatuses = NULL;
		}

		m_uPartCount = m_pReqPartFile->GetPartCount();
		m_pbytePartStatuses = new byte[m_uPartCount];
		memset2(m_pbytePartStatuses, 1, m_uPartCount);
		m_bCompleteSource = true;

		m_pReqPartFile->NewSrcPartsInfo();
		UpdateDisplayedInfo();

	//	even if the file is <= PARTSIZE, we _may_ need the hashset for that file (if the file size == PARTSIZE)
		if (m_pReqPartFile->m_bHashSetNeeded)
		{
			Packet * pPacket = new Packet(OP_HASHSETREQUEST, 16);
			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d366 1
a366 1
			m_pRequestSocket->SendPacket(pPacket, true, true);
d369 11
a379 11
			SetDownloadState(DS_REQHASHSET);
			m_pReqPartFile->m_bHashSetNeeded = false;
		}
		else
		{
			SetDownloadState(DS_ONQUEUE);
			CSafeMemFile data1(16);	//TwoBottle Mod
			data1.Write(m_pReqPartFile->GetFileHash(), 16);
			Packet* pPacket = new Packet(&data1);
			pPacket->m_eOpcode = OP_STARTUPLOADREQ;
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d381 1
a381 1
			m_pRequestSocket->SendPacket(pPacket, true, true);
d384 3
a386 3
			m_dwLastAskedTime = ::GetTickCount();
		}
	}
d388 1
a388 1
	EMULE_CATCH
d393 1
a393 1
	EMULE_TRY
d395 86
a480 86
	if (m_pReqPartFile == NULL)
	{
		m_pReqPartFile = pReqPartFile;

		if (m_pReqPartFile == NULL)
		{
//			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
			return;
		}
	}
	else if (m_pReqPartFile != pReqPartFile)
	{
//		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile!=pcFileHash)"), __FUNCTION__);
		return;
	}

	uint16 uED2KPartCount;

	packetStream->Read(&uED2KPartCount, 2);

	if (m_pbytePartStatuses)
	{
		delete[] m_pbytePartStatuses;
		m_pbytePartStatuses = NULL;
	}

	bool bPartsNeeded = false;

	m_uPartCount = m_pReqPartFile->GetPartCount();
	if (uED2KPartCount == 0)
	{
		m_pbytePartStatuses = new byte[m_uPartCount];
		memset2(m_pbytePartStatuses, 1, m_uPartCount);
		bPartsNeeded = true;
		m_bCompleteSource = true;
	}
	else
	{
		if (m_pReqPartFile->GetED2KPartCount() != uED2KPartCount)
		{
			m_uPartCount = 0;
			throw GetResString(IDS_ERR_WRONGPARTNUMBER);
		}

		m_bCompleteSource = false;
		uint16 nCompleteSourcePart = 0;	// zegzav:completesrc (add)
		m_pbytePartStatuses = new byte[m_uPartCount];
		uint16 done = 0;

		while (done != m_uPartCount)
		{
			byte toread;
			packetStream->Read(&toread, 1);

			for (sint32 i = 0;i != 8;i++)
			{
				m_pbytePartStatuses[done] = ((toread >> i) & 1) ? 1 : 0;
				if (m_pbytePartStatuses[done])
				{
					nCompleteSourcePart++;
					if (!m_pReqPartFile->IsComplete(done * PARTSIZE, ((done + 1) * PARTSIZE) - 1))
						bPartsNeeded = true;
				}
				done++;

				if (done == m_uPartCount)
					break;
			}
		}

		if (nCompleteSourcePart == m_uPartCount)
			m_bCompleteSource = true;
	}

	m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
	UpdateDisplayedInfo();

	//CheckForUpPartsInfo(); // obaldin

	if (!bPartsNeeded)
		SetDownloadState(DS_NONEEDEDPARTS);
	else if (!bUDPPacket)
	{
		if (m_pReqPartFile->m_bHashSetNeeded)
		{
			Packet	*pPacket = new Packet(OP_HASHSETREQUEST, 16);
d482 2
a483 2
			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d485 1
a485 1
			m_pRequestSocket->SendPacket(pPacket, true, true);
d488 6
a493 6
			SetDownloadState(DS_REQHASHSET);
			m_pReqPartFile->m_bHashSetNeeded = false;
		}
		else
		{
			Packet 	*pPacket = new Packet(OP_STARTUPLOADREQ, 16);
d495 2
a496 2
			md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d498 1
a498 1
			m_pRequestSocket->SendPacket(pPacket, true, true);
d501 8
a508 8
			SetDownloadState(DS_ONQUEUE);
			m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
		//AddDebugLogLine(false,"File Upload: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
		}
	}
	else if (bPartsNeeded && GetDownloadState() != DS_ONQUEUE)
			SetDownloadState(DS_ONQUEUE);
	EMULE_CATCH
d513 1
a513 1
	EMULE_TRY
d515 2
a516 2
	if (file == NULL)
		return false;
d519 4
a522 4
	if (m_otherRequestsList.Find(file) != 0)
		return false;
	else
	m_otherRequestsList.AddTail(file);
d524 2
a525 2
	if (!file->m_A4AFsrcList.Find(this))
		file->m_A4AFsrcList.AddTail(this);
d527 1
a527 1
	return true;
d529 1
a529 1
	EMULE_CATCH
d531 1
a531 1
	return false;
d536 1
a536 1
	EMULE_TRY
d538 2
a539 2
	if (pPartFile == NULL)
		return;
d541 2
a542 2
//	Check Other list
	POSITION posPartFile = m_otherRequestsList.Find(pPartFile);
d544 4
a547 4
	if (posPartFile != NULL)
	{
		m_otherRequestsList.RemoveAt(posPartFile);
	}
d549 1
a549 1
	m_otherNoNeededMap.RemoveKey(pPartFile);
d551 1
a551 1
	EMULE_CATCH
d556 1
a556 1
	EMULE_TRY
d558 8
a565 8
	if (m_eDownloadState != byNewState)
	{
		//clear variables before switching
		switch (m_eDownloadState)
		{
			case DS_DOWNLOADING:
				if (m_pReqPartFile)
					m_pReqPartFile->RemoveDownloadingSource(this);
d567 4
a570 4
				if (m_bTransferredDownMini && byNewState != DS_ERROR)
					g_eMuleApp.m_pGlobPrefs->Add2DownSuccessfulSessions(); // Increment our counters for successful sessions (Cumulative AND Session)
				else
					g_eMuleApp.m_pGlobPrefs->Add2DownFailedSessions(); // Increment our counters failed sessions (Cumulative AND Session)
d572 1
a572 1
				g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime((::GetTickCount() - m_dwDownStartTime) / 1000);
d574 2
a575 2
				//prevet any action from the client
				m_eDownloadState = byNewState;
d577 1
a577 1
				ClearDownloadBlocksList();
d579 1
a579 1
				ClearPendingBlocksList();
d581 1
a581 1
				m_dwDownDataRate = 0;
d583 4
a586 4
				if (byNewState == DS_NONE)
				{
					if (m_pbytePartStatuses)
						delete[] m_pbytePartStatuses;
d588 1
a588 1
					m_pbytePartStatuses = 0;
d590 2
a591 2
					m_uPartCount = 0;	//SyruS (0.29c)
				}
d593 1
a593 1
				m_uLastPartAsked = 0xFFFF;
d597 2
a598 2
				if (m_pRequestSocket && byNewState != DS_ERROR)
					m_pRequestSocket->DisableDownloadLimit();
d600 1
a600 1
				break;
d602 3
a604 3
			case DS_ERROR:
				return;
		}
d606 2
a607 2
	//	switch the state & update info
		m_eDownloadState = byNewState;
d609 6
a614 6
		//prepare variables for new state
		switch (byNewState)
		{
			case DS_DOWNLOADING:
			//	Update statistical variables (start time of DL & minimal amount)
				m_dwLastDataRateCalculationTime = m_dwDownStartTime = ::GetTickCount();
d616 1
a616 1
				m_bTransferredDownMini = false;
d618 1
a618 1
				m_pReqPartFile->AddDownloadingSource(this);
d620 2
a621 2
				if (IsEmuleClient())
					SetRemoteQueueFull(false);
d623 1
a623 1
				SetAskedCountDown(0);
d625 1
a625 1
				SetRemoteQueueRank(0, false);
d627 5
a631 5
				break;
			case DS_CONNECTED:
				m_dwEnteredConnectedState = ::GetTickCount();
				break;
		}
d633 2
a634 2
		UpdateDisplayedInfo(true);
	}
d636 1
a636 1
	EMULE_CATCH
d641 1
a641 1
	EMULE_TRY
d643 2
a644 2
	if ((!m_pReqPartFile) || md4cmp(pPacket, m_pReqPartFile->GetFileHash()))
		throw GetResString(IDS_ERR_WRONGFILEID);
d646 1
a646 1
	CSafeMemFile data1((BYTE*)pPacket, size);
d648 9
a656 9
	if (m_pReqPartFile->LoadHashsetFromFile(data1, true))
	{
		SetDownloadState(DS_ONQUEUE);

		CSafeMemFile data2(16);
		data2.Write(this->m_pReqPartFile->GetFileHash(), 16);
		Packet* opacket = new Packet(&data2);
		opacket->m_eOpcode = OP_STARTUPLOADREQ;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(opacket->m_dwSize);
d659 1
a659 1
		m_pRequestSocket->SendPacket(opacket, true, true);
d662 7
a668 7
		m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
	}
	else
	{
		m_pReqPartFile->m_bHashSetNeeded = true;
		AddLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_BADHASHSET), m_pReqPartFile->GetFileName());
	}
d670 1
a670 1
	EMULE_CATCH
d675 1
a675 1
	EMULE_TRY
d677 1
a677 1
	m_dwLastBlockReceived = GetTickCount();
d679 2
a680 2
	if (m_pReqPartFile == NULL)
		return;
d682 60
a741 60
//	Get blocks from the same chunk first
	if (m_downloadBlocksList.IsEmpty())
	{
		//eklmn: get part for request. if actual part still has empty blocks, the we get the actuall
		// part, otherwise it will be a new part
		m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this);

		if (m_uLastPartAsked != 0xFFFF)		//previous active part ?
		{
		//	Barry - instead of getting 3, just get how many is needed
			uint16		uCount, uSavedCount;

			uSavedCount = uCount = 3 - m_pendingBlocksList.GetCount();

			Requested_Block_Struct	**ppRequestedBlocksToAdd = new Requested_Block_Struct * [uCount];

			m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, ppRequestedBlocksToAdd, &uCount);

			if (uCount == 0)		//finished block (part ?)
			{
			//	check if part was completed

				if ( m_pReqPartFile->GetBytesInPart(m_uLastPartAsked, true, true) == 0
				  || m_pReqPartFile->IsCorruptedPart(m_uLastPartAsked) )
				{
					m_uLastPartAsked = 0xFFFF; //ICR 2.10
				}

				m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this); //get next part

				if (m_uLastPartAsked != 0xFFFF)		//more parts ?
				{
					uCount = uSavedCount;
					m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, ppRequestedBlocksToAdd, &uCount);
				}
			}

			for (int i = 0; i < uCount; i++)
			{
				m_downloadBlocksList.AddTail(ppRequestedBlocksToAdd[i]);
			}

			delete[] ppRequestedBlocksToAdd;
		}
	}

//	Barry - Why are unfinished blocks requested again, not just new ones?
	while (m_pendingBlocksList.GetCount() < 3 && !m_downloadBlocksList.IsEmpty())
	{
		Pending_Block_Struct		*pPendingBlock = new Pending_Block_Struct;

		pPendingBlock->m_pRequestedBlock = m_downloadBlocksList.RemoveHead();
		pPendingBlock->m_pZStream = NULL;
		pPendingBlock->iZStreamErr = 0;
		m_pendingBlocksList.AddTail(pPendingBlock);
	}

	if (m_pendingBlocksList.IsEmpty())
	{
		Packet		*pPacket = new Packet(OP_CANCELTRANSFER);
d743 1
a743 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d746 1
a746 1
		m_pRequestSocket->SendPacket(pPacket, true, true);
d749 1
a749 1
		EnumDLQState eOldDowloadState = GetDownloadState();
d751 2
a752 2
		if ((GetTickCount() - GetLastAskedTime()) > FILEREASKTIME)
			AskForDownload();
d754 2
a755 2
		if (eOldDowloadState == GetDownloadState())
				SetDownloadState(DS_NONEEDEDPARTS);
d757 1
a757 1
//		AddDebugLogLine(false, "Cancel download from %s due empty block list", this->GetUserName());
d759 2
a760 2
		return;
	}
d762 1
a762 1
	Packet		*pPacket = new Packet(OP_REQUESTPARTS, 40);
d764 1
a764 1
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pPacket->m_pcBuffer), 40);
d766 1
a766 1
	packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
d768 2
a769 2
	POSITION		pos = m_pendingBlocksList.GetHeadPosition();
	uint32			dwNull = 0;
d771 1
a771 1
	Requested_Block_Struct		*pRequestedBlock;
d773 12
a784 12
	for (uint32 i = 0; i < 3; i++)
	{
		if (pos != NULL)
		{
			pRequestedBlock = m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock;
			packetStream.Write(&pRequestedBlock->m_dwStartOffset, 4);
		}
		else
		{
			packetStream.Write(&dwNull, 4);
		}
	}
d786 1
a786 1
	pos = m_pendingBlocksList.GetHeadPosition();
d788 5
a792 5
	for (uint32 i = 0; i < 3; i++)
	{
		if (pos != NULL)
		{
			pRequestedBlock = m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock;
d794 1
a794 1
			uint32		dwEndOffset = pRequestedBlock->m_dwEndOffset + 1;
d796 7
a802 7
			packetStream.Write(&dwEndOffset, 4);
		}
		else
		{
			packetStream.Write(&dwNull, 4);
		}
	}
d804 1
a804 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d807 1
a807 1
	m_pRequestSocket->SendPacket(pPacket, true, true);
d810 1
a810 1
	EMULE_CATCH
d815 1
a815 1
		   180k blocks.
d817 2
a818 2
		   This meant that on average 90k was lost for every connection
		   to a client data source. That is a lot of wasted data.
d820 7
a826 7
		   To reduce the lost data, packets are now written to a buffer
		   and flushed to disk regularly regardless of size downloaded.
		   This includes compressed packets.

		   Data is also requested only where gaps are, not in 180k blocks.
		   The requests will still not exceed 180k, but may be smaller to
		   fill a gap.
d830 1
a830 1
	EMULE_TRY
d832 1
a832 1
	const int		HEADER_SIZE = 24;
d834 2
a835 2
//	Update timer (eklmn: don't remove this value cause it use to timeout check)
	m_dwLastBlockReceived = ::GetTickCount();
d837 95
a931 95
//	Read data from packet
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pcPacketBuf), dwPacketSize);

	uchar		fileHash[16];

	packetStream.Read(fileHash, sizeof(fileHash));				//<HASH>

//	Check that this data is for the correct file
	if (m_pReqPartFile == NULL || md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
	{
		throw CString(CString(__FUNCTION__) + _T(": ") + GetResString(IDS_ERR_WRONGFILEID));
	}

//	Find the start & end positions, and size of this chunk of data
	uint32			dwStartPos = 0;
	uint32			dwEndPos = 0;
	uint32			dwBlockSize = 0;
	const uint32 	dwDataTransferdInPacket = dwPacketSize - HEADER_SIZE;

	packetStream.Read(&dwStartPos, sizeof(uint32));				//<BYTEOFFSET:DWORD> start position

	if (bPacked)
	{
		packetStream.Read(&dwBlockSize, sizeof(uint32));		//<BYTELENGTH:DWORD> packed block size
		dwEndPos = dwStartPos + dwDataTransferdInPacket;
		m_bUsedCompressionDown = true;
	}
	else
	{
		packetStream.Read(&dwEndPos, sizeof(uint32));			//<BYTEOFFSET:DWORD> end position
	}

//	Check that packet size matches the declared packetStream packet + header size (24)
	if (dwPacketSize != ((dwEndPos - dwStartPos) + HEADER_SIZE))
	{
		throw CString(CString(__FUNCTION__ ": ") + GetResString(IDS_ERR_BADDATABLOCK));
	}

//	Protect from 0 data size, because it spoils statistics
	if (dwDataTransferdInPacket == 0)
	{
		return;
	}

//	Extended statistics information based on which client and remote port sent this data.
//		The new function adds the bytes to the grand total as well as the given client/port.
//		bFromPF is not relevant to downloaded data.  It is purely an uploads statistic.
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwDataTransferdInPacket);

//	Move end back one, should be inclusive
	m_pCredits->AddDownloaded(dwDataTransferdInPacket, this->GetIP());

	dwEndPos--;

	m_dwTransferredDown += dwDataTransferdInPacket;

	m_dwTransferredInLastPeriod += dwDataTransferdInPacket;

//	Loop through to find the reserved block that this is within
	Pending_Block_Struct* cur_block;

	POSITION pos1, pos2;

	for (pos1 = m_pendingBlocksList.GetHeadPosition(); (pos2 = pos1) != NULL; )
	{
		cur_block = m_pendingBlocksList.GetNext(pos1);
	//	Cax2: I'm not happy with this whole if clause

		if ((cur_block->m_pRequestedBlock->m_dwStartOffset <= dwStartPos) && (cur_block->m_pRequestedBlock->m_dwEndOffset >= dwStartPos))
		{
		//	Found reserved block

			if (cur_block->iZStreamErr != 0)
			{
				m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
				break;
			}

		//	Remember this start pos, used to draw part downloading in list
			m_dwLastBlockOffset = dwStartPos;

		//	Occasionally packets are duplicated, no point writing it twice
		//	This will be 0 in these cases, or the length written otherwise
			uint32 lenWritten = 0;

		//	Handle differently depending on whether bPacked or not

			if (!bPacked)
			{
			//	Write to disk (will be buffered in part file class)
				lenWritten = m_pReqPartFile->WriteToBuffer( dwDataTransferdInPacket,
				             (BYTE *) (pcPacketBuf + HEADER_SIZE),
				             dwStartPos,
				             dwEndPos,
				             cur_block->m_pRequestedBlock );
d933 2
a934 2
				if (lenWritten == 0)
					AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d936 72
a1007 72
			}
			else // Packed
			{
			//	Create space to store unzipped packetStream, the dwPacketSize is only an initial guess, will be resized in unzip() if not big enough
				uint32 lenUnzipped = (dwPacketSize * 2);
			//	Don't get too big

				if (lenUnzipped > (EMBLOCKSIZE + 300))
					lenUnzipped = (EMBLOCKSIZE + 300);

				BYTE *unzipped = new BYTE[lenUnzipped];

			//	Try to unzip the pcPacketBuf
				int result = unzip(cur_block, (BYTE *)(pcPacketBuf + HEADER_SIZE), dwDataTransferdInPacket, &unzipped, &lenUnzipped);

				if (result == Z_OK)
				{
				//	Write any unzipped packetStream to disk

					if (lenUnzipped > 0)
					{
					//	Use the current start and end positions for the uncompressed packetStream
						dwStartPos = cur_block->m_pRequestedBlock->m_dwStartOffset + cur_block->m_dwTotalUnzipped - lenUnzipped;
						dwEndPos = cur_block->m_pRequestedBlock->m_dwStartOffset + cur_block->m_dwTotalUnzipped - 1;

						if (dwBlockSize * 25 < lenUnzipped)
						{
							m_uLastPartAsked = 0xFFFF;	//eklmn: feature(00): ICR (reset choosen part in case suspicious block)

							AddDebugLogLine(true, RGB_LOG_DIMMED_TXT _T("Received suspicious block: file '%s', part %u, block %u, blocksize %u, comp. blocksize %u"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("username '%s', ip %u.%u.%u.%u:%u, hash %s"),
								m_strUserName, (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8),
								(byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24),
								GetUserPort(), HashToString(GetUserHash()));

							if (m_pReqPartFile->GetDiscardSuperCompressed())
							{
							//--- (un)comment the block-dropping as you wish---
								m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwStartOffset + 1);
								uint32 ip1 = 0;
								CString buf, temp;
								int counter = 0;
								buf.Format(_T("%u.%u.%u.%u"), (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24));

								for (int i = 0; i < 4; i++)
								{
									temp = buf.Tokenize(_T("."), counter);
									ip1 += _tstoi(temp) * pow(256, 3 - i);
								}
								//eklmn: add to temporary(24h) banned
								g_eMuleApp.m_pIPFilter->AddTemporaryBannedIP(ip1);
								// set an ERROR state, client will be removed & disconnected by PartFile::Process later on
								SetDownloadState(DS_ERROR);
								AddDebugLogLine(false, RGB_LOG_DIMMED_TXT _T("block dropped & IP locked out!"));
							}

						//	BavarianSnail
							else
							{
								if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
								{
									AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
									m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
								}
								else
								{
								//	Write uncompressed packetStream to file
									lenWritten = m_pReqPartFile->WriteToBuffer(dwDataTransferdInPacket,
									             unzipped,
									             dwStartPos,
									             dwEndPos,
									             cur_block->m_pRequestedBlock );
d1009 2
a1010 2
									if (lenWritten == 0)
										AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1012 2
a1013 2
								}
							}
d1015 17
a1031 17
						//- BavarianSnail
						}
						else
						{
							if (dwEndPos > cur_block->m_pRequestedBlock->m_dwEndOffset)
							{
								AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
								m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
							}
							else
							{
							//	Write uncompressed packetStream to file
								lenWritten = m_pReqPartFile->WriteToBuffer( dwDataTransferdInPacket,
								             unzipped,
								             dwStartPos,
								             dwEndPos,
								             cur_block->m_pRequestedBlock );
d1033 2
a1034 2
								if (lenWritten == 0)
									AddDebugLogLine(false, RGB_LOG_WARNING_TXT "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1036 69
a1104 69
							}
						}
					}
				}
				else
				{
					cur_block->iZStreamErr = result;
					AddDebugLogLine(false, RGB_LOG_WARNING + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), result);
					m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);

				//	Release resources in case of decompression error
					if (cur_block->m_pZStream != NULL)
					{
						inflateEnd(cur_block->m_pZStream);
						delete cur_block->m_pZStream;
						cur_block->m_pZStream = NULL;
					}
				}

				try
				{
					if (unzipped)
				delete [] unzipped;
			}
				catch (...)
				{}

			}

			//eklmn: check result of WriteToBuffer, if we save some byte, then this DL session can be
			// counted as succesful
			if (lenWritten > 0)
			{
				m_bTransferredDownMini = true;		// -khaos--+++> For determining whether the current download session was a success or not.
			}

			// eklmn: it needs to check "END of the block" condition every time, cause
			//  if remote client will send us a data that already were written, we will not delete the block & delete a packet

			//	[TwoBottle Mod]: If finished reserved block
			//	in this place because m_pReqPartFile->WriteToBuffer was called
			//	cur_block can be already deleted (if file was completed)
			//	so to avoid access violation here we will check
			//	m_pendingBlocksList for emptyness....possibly there is
			//	better check
			if (!m_pendingBlocksList.IsEmpty() && dwEndPos == cur_block->m_pRequestedBlock->m_dwEndOffset)
			{
				m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
				delete cur_block->m_pRequestedBlock;
			//	Not always allocated

				if (cur_block->m_pZStream)
				{
					inflateEnd(cur_block->m_pZStream);
					delete cur_block->m_pZStream;
				}

				delete cur_block;
				m_pendingBlocksList.RemoveAt(pos2);

			//	Request next block
				SendBlockRequests();
			}


		//	Stop looping and exit method
			break;
		}
	}
d1106 1
a1106 1
	EMULE_CATCH
d1111 1
a1111 1
	int iErr = Z_MEM_ERROR;
d1113 1
a1113 1
	EMULE_TRY
d1115 2
a1116 2
//	Save some typing
	z_stream *zS = pRequestedBlock->m_pZStream;
d1118 90
a1207 90
//	Is this the first time this block has been unzipped
	if (zS == NULL)
	{
		pRequestedBlock->m_dwTotalUnzipped = 0;
	//	Create stream
		zS = pRequestedBlock->m_pZStream = new z_stream;

	//	Initialize stream values
		zS->zalloc = (alloc_func)0;
		zS->zfree = (free_func)0;

	//	Set output data streams, do this here to avoid overwriting on recursive calls
		zS->next_out = *ppbyteUzipped;
		zS->avail_out = *pdwLenUnzipped;

	//	Initialise the z_stream
		iErr = inflateInit(zS);

		if (iErr != Z_OK)
			return iErr;
	}

//	Use whatever input is provided
	zS->next_in = pbyteZipped;
	zS->avail_in = dwLenZipped;

	zS->next_out = *ppbyteUzipped;
	zS->avail_out = *pdwLenUnzipped;

	for (;;)
	{
	//	Unzip the data
		iErr = inflate(zS, Z_SYNC_FLUSH);

		if (iErr == Z_OK)
		{
			if (zS->avail_in == 0)
			{
			//	All available input has been successfully processed.
			//	Set the size to the amount unzipped in this call.
				*pdwLenUnzipped = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
				pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
			}
			else if (zS->avail_out == 0)
			{
			//	Output buffer is full
				uint32		dwNewLen = (*pdwLenUnzipped << 1);	//	increase output buffer size

				iErr = Z_MEM_ERROR;	//	be ready for lack of memory

			//	Copy unzipped data to a new buffer
				BYTE		*pbyteNewBuff = new BYTE[dwNewLen];
				uint32		dwUnpackedSz = zS->total_out - pRequestedBlock->m_dwTotalUnzipped;

				memcpy2(pbyteNewBuff, *ppbyteUzipped, dwUnpackedSz);

				delete [] (*ppbyteUzipped);

				*ppbyteUzipped = pbyteNewBuff;
				*pdwLenUnzipped = dwNewLen;

			//	Set correct position inside a new output buffer
				zS->next_out = pbyteNewBuff + dwUnpackedSz;
				zS->avail_out = dwNewLen - dwUnpackedSz;
				continue;	//	try again
			}
		}
	//	Is zip finished reading all currently available input and writing all generated output
		else if (iErr == Z_STREAM_END)
		{
		//	Finish up
			iErr = inflateEnd(zS);
			pRequestedBlock->m_pZStream = NULL;

			if (iErr == Z_OK)
			{
			//	Got the good result, set the size to the unzipped amount
				*pdwLenUnzipped = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
				pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
			}
			delete zS;
		}
		else
		{
		//	Should not get here unless input data is corrupted
			*pdwLenUnzipped = 0;
		//	Error will be logged by caller on return
		}
		break;
	}
d1209 1
a1209 1
	EMULE_CATCH
d1211 1
a1211 1
	return iErr;
d1216 1
a1216 1
	EMULE_TRY
d1218 1
a1218 1
	uint32	dwCurTick = GetTickCount();
d1220 2
a1221 2
	if ((dwCurTick - m_dwLastBlockReceived) > DOWNLOADTIMEOUT)
	{
d1223 6
a1228 6
		if (m_pRequestSocket != NULL)
		{
			Packet * pPacket = new Packet(OP_CANCELTRANSFER);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
			m_pRequestSocket->SendPacket(pPacket, true, true);
		}
d1231 2
a1232 2
		SetDownloadState(DS_ONQUEUE);
		m_dwDownDataRate = 0;
d1234 42
a1275 42
//		if (this != NULL)
//		{
//			AddDebugLogLine(false, "Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
//		}
	}
	else
	{
		uint32 time_diff_ms = dwCurTick - m_dwLastDataRateCalculationTime;

	//update average sum
		m_qwClientSumDLDataRateOverLastNMeasurements += m_dwTransferredInLastPeriod;
		m_qwClientSumDLTickOverLastNMeasurements += time_diff_ms;
	//	update a lists
		m_averageDLDataRateList.push_front(m_dwTransferredInLastPeriod);
		m_averageDLTickList.push_front(time_diff_ms);
	//	check lists size

		while (m_averageDLTickList.size() > 500)
		{
			m_qwClientSumDLDataRateOverLastNMeasurements -= m_averageDLDataRateList.back();
			m_averageDLDataRateList.pop_back();
			m_qwClientSumDLTickOverLastNMeasurements -= m_averageDLTickList.back();
			m_averageDLTickList.pop_back();
		}

	//	calculate average trasfered data (bytes)
		uint64 AverageTransferredData = m_qwClientSumDLDataRateOverLastNMeasurements / m_averageDLDataRateList.size();

	//	calculate average time period between measuremets (ms)
		uint64 AverageTransferTimePeriod = m_qwClientSumDLTickOverLastNMeasurements / m_averageDLTickList.size();

	//	calculate a DL rate (b/s)
		if (AverageTransferTimePeriod != 0)
			m_dwDownDataRate = 1000 * AverageTransferredData / AverageTransferTimePeriod;
		else
			m_dwDownDataRate = 0;

	//update a time & reset data transferred over last period
		m_dwLastDataRateCalculationTime = dwCurTick;

		m_dwTransferredInLastPeriod = 0;
	}
d1277 1
a1277 1
	UpdateDisplayedInfo();
d1279 1
a1279 1
	return m_dwDownDataRate;
d1281 1
a1281 1
	EMULE_CATCH
d1283 1
a1283 1
	return 0;
d1288 1
a1288 1
	EMULE_TRY
d1290 1
a1290 1
	uint16 result = 0;
d1292 5
a1296 5
	for (int i = 0;i < m_uPartCount;i++)
	{
		if (IsPartAvailable(i))
			result++;
	}
d1298 1
a1298 1
	return result;
d1300 1
a1300 1
	EMULE_CATCH
d1302 1
a1302 1
	return 0;
d1307 1
a1307 1
	EMULE_TRY
d1309 7
a1315 7
	m_iDeltaQueueRank = static_cast<int>(nr) - static_cast<int>(m_uRemoteQueueRank);
	if (m_uRemoteQueueRank != nr)
	{
		m_uRemoteQueueRank = nr;
		if (bUpdateGUI)
			UpdateDisplayedInfo();
	}
d1317 1
a1317 1
	EMULE_CATCH
d1320 1
a1320 1
//eklmn: bugfix(08): A4AF switching
d1323 1
a1323 1
	EMULE_TRY
d1325 139
a1463 136
//	Check if we are downloading something from client
	if (GetDownloadState() == DS_DOWNLOADING)
		return false;

	POSITION		SwapToPos = 0;
	POSITION		cur_FilePos;
	CPartFile	   *pCurFile;
	uint32			dwLastNNSCheckedTime = ::GetTickCount();
	const uint16	uPriorityFactorsArray[3] = {1,2,3};
	uint16			uA4AFRating;
	uint16			uBestA4AFRating = 0;

	//	Check: does client have another files?
	if (!m_otherRequestsList.IsEmpty())
	{
	//	Check: target file is specified? if is not, then find another one
		if (!SwapTo)
		{
		//	Do not change this unless you want unpredictable results :P
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != 0;m_otherRequestsList.GetNext(cur_FilePos))
			{
				pCurFile = m_otherRequestsList.GetAt(cur_FilePos);

			//	Get first high priority files
				if ( pCurFile != m_pReqPartFile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(pCurFile)
				     && (pCurFile->GetStatus(false) == PS_READY || pCurFile->GetStatus(false) == PS_EMPTY) )
				{
				//	Check: is new file in NNS-Map?
					bool	bNNS = m_otherNoNeededMap.Lookup(pCurFile, dwLastNNSCheckedTime);

				//	Calculate an A4AF rating
					if (bNNS)
						uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()]
							+ static_cast<uint16>((::GetTickCount() - dwLastNNSCheckedTime)/FILEREASKTIME);
					else
						uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()] * 3;
					if (uA4AFRating >= uBestA4AFRating)
					{
						SwapTo = pCurFile;
						SwapToPos = cur_FilePos ;
						uBestA4AFRating = uA4AFRating;
					}
				}
			} // end for
		} // list check
		else if (SwapTo->GetStatus(false) == PS_READY || SwapTo->GetStatus(false) == PS_EMPTY)
		{
			SwapToPos = m_otherRequestsList.Find(SwapTo); // otherwise get position with .Find()
		}

	//	now let's swap the file to another
		if (SwapTo != NULL && SwapToPos != 0)
		{

		//	to prevent loop swaping remember NNS-Part & time when it was switched
			if ( m_pReqPartFile != NULL && GetDownloadState() == DS_NONEEDEDPARTS)
			{
				m_otherNoNeededMap[m_pReqPartFile] = ::GetTickCount();
			}

		//	switch state to NONE
			SetDownloadState(DS_NONE);

			if (m_pbytePartStatuses)
			{
				delete[] m_pbytePartStatuses;
				m_pbytePartStatuses = 0;
			}

			m_uPartCount = 0;
			m_dwLastAskedTime = 0;
			m_uLastPartAsked = 0xFFFF;

		//	add to past comment
			if (m_pReqPartFile != NULL)
			{
				m_pReqPartFile->AddPastComment(this);
				m_eRating = PF_RATING_NONE;
				m_strComment = _T("");
			//	find current file position in sourceslots
				cur_FilePos = m_pReqPartFile->m_srcLists[m_iSourcesSlot].Find(this);

				if (cur_FilePos)
					m_pReqPartFile->m_srcLists[m_iSourcesSlot].RemoveAt(cur_FilePos); // remove current file

			//	add them in A4AF list
				if (!m_pReqPartFile->m_A4AFsrcList.Find(this))
					m_pReqPartFile->m_A4AFsrcList.AddTail(this);

			//	add old file to m_otherRequestsList
				if (!m_otherRequestsList.Find(m_pReqPartFile))
					m_otherRequestsList.AddTail(m_pReqPartFile);

			//	let's update current information for the removed file
				m_pReqPartFile->NewSrcPartsInfo();

			//	update download list (old file update)
				m_pReqPartFile->UpdateDisplayedInfo();

				m_pReqPartFile = NULL;	//reset before delete m_pbytePartStatuses
			}

		//	actual switch
			m_pReqPartFile = SwapTo;

		//	remove new file from OtherRequests list
			m_otherRequestsList.RemoveAt(SwapToPos);

		//	remove current source from A4AF list in new file
			POSITION	pos_A4AF = SwapTo->m_A4AFsrcList.Find(this);

			if (pos_A4AF != NULL)
				SwapTo->m_A4AFsrcList.RemoveAt(pos_A4AF);

		//	to prevent loop swaping remove a choosen part from NNS-Map
			m_otherNoNeededMap.RemoveKey(SwapTo);

		//	add to souceslots
			if (!SwapTo->m_srcLists[m_iSourcesSlot].Find(this))
				SwapTo->m_srcLists[m_iSourcesSlot].AddTail(this);

		//	remove from past comment
			SwapTo->RemovePastComment(this);	// #zegzav:pastcomment

		//	Update info for target file
			SwapTo->NewSrcPartsInfo();	// eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)

		//	update download list (new file update)
			SwapTo->UpdateDisplayedInfo();

		//	now update the client item
			UpdateDisplayedInfo(true);

			return true;
		}
	}
d1465 1
a1465 1
	EMULE_CATCH
d1467 3
a1469 1
	return false;
a1470 1
//eklmn: bugfix(08): A4AF switching
d1474 1
a1474 1
	EMULE_TRY
d1476 3
a1478 3
	m_bUDPPending = false;
	SetRemoteQueueRank(nNewQR);
	m_dwLastAskedTime = ::GetTickCount();
d1480 1
a1480 1
	EMULE_CATCH
d1485 1
a1485 1
	EMULE_TRY
d1487 1
a1487 1
	m_bUDPPending = false;
d1490 6
a1495 6
	if (GetDownloadState() != DS_DOWNLOADING)
	{
		AddDebugLogLine(false, _T("UDP ANSWER FNF : %s"), GetUserName());
		//eklmn: try to swap the source to any file before remove them from DL-queue
		if (!SwapToAnotherFile(NULL))
			g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d1498 2
a1499 2
		if (!m_pRequestSocket)
			Disconnected();
d1503 3
a1505 3
	}
	else
		AddDebugLogLine(false, _T("UDP ANSWER FNF : %s (client not removed)"), GetUserName());
d1507 1
a1507 1
	EMULE_CATCH
d1512 1
a1512 1
	EMULE_TRY
d1514 1
a1514 1
	ASSERT (m_pReqPartFile);
d1516 2
a1517 2
	if (!m_pReqPartFile || m_bUDPPending)
		return;
d1519 2
a1520 2
//	Maverick Disable UDP when connecting to a PROXY
	ProxySettings proxy = g_eMuleApp.m_pGlobPrefs->GetProxy();
d1524 34
a1557 34
	if ( m_byteEmuleVersion >= 0x23
		&& m_uUDPPort != 0
		&& g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0
		&& (!g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() )
		&& !(m_pRequestSocket && m_pRequestSocket->IsConnected())
		&& (!proxy.m_bUseProxy) )
	{

	//don't use udp to ask for sources

		if (IsSourceRequestAllowed())
			return;

		m_bUDPPending = true;

		CSafeMemFile	packetStream(128);

		packetStream.Write(m_pReqPartFile->GetFileHash(), 16);
		if (GetUDPVersion() > 3)
		{
			if (m_pReqPartFile->IsPartFile())
				((CPartFile*)m_pReqPartFile)->WritePartStatus(&packetStream);
			else
			{
				uint16	uNull = 0;

				packetStream.Write(&uNull, 2);
			}
		}
		if (GetUDPVersion() > 2)
		{
			uint16	uCompleteSourcesCount = m_pReqPartFile->GetCompleteSourcesCount();
			packetStream.Write(&uCompleteSourcesCount, 2);
		}
d1559 1
a1559 1
		Packet		*pPacket = new Packet(&packetStream, OP_EMULEPROT);
d1561 1
a1561 1
		pPacket->m_eOpcode = OP_REASKFILEPING;
d1563 1
a1563 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d1565 2
a1566 2
		g_eMuleApp.m_pClientUDPSocket->SendPacket(pPacket, GetIP(), GetUDPPort());
	}
d1570 1
a1570 1
	EMULE_CATCH
d1573 1
a1573 1
//	Barry - Sets the vector of bool 'parts' to show the pending status of each part.
d1576 1
a1576 1
	EMULE_TRY
d1578 1
a1578 1
	parts.resize(m_uPartCount);
d1580 2
a1581 2
	for (POSITION pos = m_pendingBlocksList.GetHeadPosition(); pos != NULL; )
		parts[m_pendingBlocksList.GetNext(pos)->m_pRequestedBlock->m_dwStartOffset / PARTSIZE] = true;
d1583 1
a1583 1
	EMULE_CATCH
d1588 1
a1588 1
	g_eMuleApp.m_pDownloadList->UpdateSource(this);
d1591 1
a1591 1
//	New functions by Mr.Fry
d1594 1
a1594 1
	EMULE_TRY
d1596 1
a1596 1
	uint16 uCount = 0;
d1598 5
a1602 5
	if (m_pbytePartStatuses != NULL && m_uPartCount > 0)
	{
		for (int i = 0; i < m_uPartCount ; i++)
			if (m_pbytePartStatuses[i] && !m_pReqPartFile->IsComplete(i * PARTSIZE, ((i + 1) * PARTSIZE) - 1))
				uCount++;
d1604 2
a1605 2
	//TRACE("Counted %u Chunks (parts) that %s has and I need (to download)",uCount,GetUserName());
	}
d1607 1
a1607 1
	return uCount;
d1609 1
a1609 1
	EMULE_CATCH
d1611 1
a1611 1
	return 0;
d1617 1
a1617 1
	EMULE_TRY
d1619 8
a1626 8
	if (m_eDownloadState == DS_DOWNLOADING)
	{
		return		static_cast<uint32>(m_dwLastBlockOffset / PARTSIZE);
	}
	else
	{
		return 0xFFFF;
	}
d1628 1
a1628 1
	EMULE_CATCH
d1630 1
a1630 1
	return 0xFFFF;
d1636 1
a1636 1
	EMULE_TRY
d1638 1
a1638 1
	Pending_Block_Struct*		pPendingBlock;
d1640 24
a1663 24
	while (!m_pendingBlocksList.IsEmpty() )
	{
		pPendingBlock = m_pendingBlocksList.RemoveHead();

		if (pPendingBlock)
		{
			if (pPendingBlock->m_pRequestedBlock)
			{
				CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pPendingBlock->m_pRequestedBlock->m_fileHash);

				pReqFile->RemoveBlockFromList(pPendingBlock->m_pRequestedBlock->m_dwStartOffset,
											pPendingBlock->m_pRequestedBlock->m_dwEndOffset);
				delete pPendingBlock->m_pRequestedBlock;
			}

			if (pPendingBlock->m_pZStream)
			{
				inflateEnd(pPendingBlock->m_pZStream);
				delete pPendingBlock->m_pZStream;
			}
			delete pPendingBlock;
		}
		pPendingBlock = NULL;
	}
d1665 1
a1665 1
	EMULE_CATCH
d1668 1
a1668 1
//	If downloadBlocks are existing free block reserved in pPartFile
d1671 11
a1681 11
	while (!m_downloadBlocksList.IsEmpty())
	{
		Requested_Block_Struct* pDLBlock =  m_downloadBlocksList.RemoveHead();
		if (pDLBlock)
		{
			CPartFile* pReqFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pDLBlock->m_fileHash);

			pReqFile->RemoveBlockFromList(pDLBlock->m_dwStartOffset, pDLBlock->m_dwEndOffset);
			delete pDLBlock;
		}
	}
@


1.204
log
@minor optimization
@
text
@d1543 5
a1547 1
				packetStream.Write(0, 2);
@


1.203
log
@fixed my really incorrect and bugged way of processing StatusFile packets
@
text
@d480 2
a481 1
			Packet * pPacket = new Packet(OP_HASHSETREQUEST, 16);
d493 3
a495 5
			SetDownloadState(DS_ONQUEUE);
			CSafeMemFile data1(16);	//TwoBottle Mod
			data1.Write(m_pReqPartFile->GetFileHash(), 16);
			Packet* pPacket = new Packet(&data1);
			pPacket->m_eOpcode = OP_STARTUPLOADREQ;
a497 1

d501 1
@


1.202
log
@formatting (thanks to Aw3)
@
text
@d391 1
a391 1
void CUpDownClient::ProcessFileStatus(char* packet, uint32 size, bool bUDPPacket/* = false*/)
d395 1
a395 5
	CSafeMemFile packetStream((BYTE*)packet, size);	//TwoBottle Mod (exceptions!)
	uchar pcFileHash[16];
	packetStream.Read(pcFileHash, 16);

	if (!m_pReqPartFile)
d397 1
a397 1
		m_pReqPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pcFileHash);
d399 1
a399 1
		if (!m_pReqPartFile)
d405 1
a405 1
	if (md4cmp(pcFileHash, m_pReqPartFile->GetFileHash()))
d413 1
a413 1
	packetStream.Read(&uED2KPartCount, 2);
d447 1
a447 1
			packetStream.Read(&toread, 1);
@


1.201
log
@Improved string processing; Some trace is put in _DEBUG.
@
text
@d334 6
a339 4
//	if (md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
//	{
//		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile != fileHash)"), __FUNCTION__);
//	}
d487 1
a487 1
	#ifdef OLD_SOCKETS_ENABLED
d489 1
a489 1
	#endif //OLD_SOCKETS_ENABLED
d502 1
a502 1
	#ifdef OLD_SOCKETS_ENABLED
d505 1
a505 1
	#endif //OLD_SOCKETS_ENABLED
d754 1
a754 1
		EnumDLQState enumOldDowloadState = GetDownloadState();
d759 1
a759 1
		if (enumOldDowloadState == GetDownloadState())
@


1.200
log
@comments corrections (thanks to Aw3)
@
text
@d937 1
a937 1
					AddDebugLogLine(false, RGB_LOG_WARNING + "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d968 2
a969 2
							AddDebugLogLine(true, RGB_LOG_DIMMED + _T("Received suspicious block: file '%s', part %u, block %u, blocksize %u, comp. blocksize %u"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("username '%s', ip %u.%u.%u.%u:%u, hash %s"),
d992 1
a992 1
								AddDebugLogLine(false, RGB_LOG_DIMMED + _T("block dropped & IP locked out!"));
d1011 1
d1013 2
a1014 1
										AddDebugLogLine(false, RGB_LOG_WARNING + "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1035 1
d1037 2
a1038 1
									AddDebugLogLine(false, RGB_LOG_WARNING + "client: %s, type: %s, mod: %s", GetUserName(), GetClientNameString(GetClientSoft()), GetModVersion());
d1491 1
a1491 1
		AddDebugLogLine(false, CString("UDP ANSWER FNF : %s"), GetUserName());
d1504 1
a1504 1
		AddDebugLogLine(false, CString("UDP ANSWER FNF : %s (client not removed)"), GetUserName());
@


1.199
log
@Minor fix by xrmb
@
text
@d179 1
a179 1
//	Original client return false if client's SourceExchange Version is blow or equal to 1
@


1.198
log
@change the way my fix in 1.197 works to avoid multi downloadstate changes
@
text
@d1410 2
a1411 1
				m_pReqPartFile->m_A4AFsrcList.AddTail(this);
d1414 2
a1415 1
				m_otherRequestsList.AddTail(m_pReqPartFile);
d1418 1
a1418 1
				m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
@


1.197
log
@fix to decrease the number of NNP sources that are "in queue" can't understand why it was commented out
@
text
@d752 1
a752 1
		SetDownloadState(DS_NONEEDEDPARTS);
d757 3
@


1.196
log
@Updated SourceExchange Protocol to v2
@
text
@d751 2
a752 1
	//SetDownloadState(DS_NONEEDEDPARTS);
d755 1
a755 1
			AskForDownload(); //<<--enkeyDEV(Ottavio84) modified by lovelace - reask for file
@


1.195
log
@updated UDP Protocol to v4
@
text
@d179 2
d183 1
a183 1
				ExtProtocolAvailable() && m_byteSourceExchangeVer >= 1 &&
@


1.194
log
@Minor changes
@
text
@d387 1
a387 1
void CUpDownClient::ProcessFileStatus(char* packet, uint32 size)
d476 1
a476 1
	else if (m_pReqPartFile->m_bHashSetNeeded)
d478 8
a485 6
		Packet * pPacket = new Packet(OP_HASHSETREQUEST, 16);
		md4cpy(pPacket->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED
d487 12
a498 12
		SetDownloadState(DS_REQHASHSET);
		m_pReqPartFile->m_bHashSetNeeded = false;
	}
	else
	{
		SetDownloadState(DS_ONQUEUE);
		CSafeMemFile data1(16);	//TwoBottle Mod
		data1.Write(m_pReqPartFile->GetFileHash(), 16);
		Packet* pPacket = new Packet(&data1);
		pPacket->m_eOpcode = OP_STARTUPLOADREQ;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
d500 2
a501 2
		m_pRequestSocket->SendPacket(pPacket, true, true);
#endif //OLD_SOCKETS_ENABLED
d503 3
a505 2
		m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
	//AddDebugLogLine(false,"File Upload: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
d507 2
a508 1

d724 1
a724 1
			
d1526 1
a1526 2
	//	netwolf: complete sources UDP - BEGIN
		uint16 packetsize = 16;
d1528 13
a1540 2
		if (GetUDPVersion() >= 3)
			packetsize += 2;
d1542 1
a1542 2
	//	netwolf: complete sources UDP - END
		Packet		*response = new Packet(OP_REASKFILEPING, packetsize, OP_EMULEPROT);	// netwolf: complete sources UDP
d1544 1
a1544 1
		md4cpy(response->m_pcBuffer, m_pReqPartFile->GetFileHash());		// <filehash 16>
d1546 1
a1546 10
	//	netwolf: complete sources UDP - BEGIN
		if (GetUDPVersion() >= 3)
		{
			uint16		uNumCompleteSources = m_pReqPartFile->GetCompleteSourcesCount();

			memcpy2(response->m_pcBuffer + 16, &uNumCompleteSources, 2);	// <numcompletesources 2>
		}

	//	netwolf: complete sources UDP - END
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(response->m_dwSize);
d1548 1
a1548 1
		g_eMuleApp.m_pClientUDPSocket->SendPacket(response, GetIP(), GetUDPPort());
@


1.193
log
@minor improvements.
@
text
@d329 1
a329 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
d332 4
a335 4
	if (md4cmp(fileHash, m_pReqPartFile->GetFileHash()))
	{
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile != fileHash)"), __FUNCTION__);
	}
d401 1
a401 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__);
d407 1
a407 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile!=pcFileHash)"), __FUNCTION__);
@


1.192
log
@Fix for A4AF problem...
@
text
@d686 4
a689 2
	//	Barry - instead of getting 3, just get how many is needed
		uint16		uCount, uSavedCount;
d691 1
a691 1
		uSavedCount = uCount = 3 - m_pendingBlocksList.GetCount();
a692 2
		if (m_uLastPartAsked != 0xFFFF)		//previous active part ?
		{
a722 4
		else
		{
			uCount = 0;
		}
@


1.191
log
@Ops! That wasn't for CVS and not even right :P
@
text
@d1336 2
a1337 1
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition(); cur_FilePos != NULL; )
d1339 2
a1340 1
				pCurFile = m_otherRequestsList.GetNext(cur_FilePos);
a1341 1

@


1.190
log
@Fix for Clear All (completed)
@
text
@a542 3
		if (GetUserName().Find("Tuel") != -1)
			AddDebugLogLine(false, "--> DonGato: found %s in other requested list for %s PartFile, removing from it", GetUserName(), pPartFile->GetFileName());
	
a544 5
	else
	{
		if (GetUserName().Find("Tuel") != -1)
			AddDebugLogLine(false, "--> DonGato: didn't find %s in other requested list for %s PartFile", GetUserName(), pPartFile->GetFileName());
	}
a1366 5
		if (SwapTo == m_pReqPartFile)
		{
			AddLogLine(true, "--> DonGato: switching to the same file!");
		}

@


1.189
log
@xrmb fix for unused pixel in Upload/On Queue progress bar; xrmb different shades of yellow in progress bar for current transfer position and remaining
@
text
@d538 1
a538 1
//check Other list
d542 4
d547 6
d1361 1
a1361 1
					if (uA4AFRating > uBestA4AFRating)
d1375 5
@


1.188
log
@Minor log change (translated lines shouldn't be added to DebugLog)
@
text
@d45 2
a46 1
	const COLORREF crPending = RGB(255, 208, 0);
a47 1
//--- xrmb:seetheneed ---
a48 1
//--- :xrmb ---
d84 4
a87 1
						statusBar.FillRange(PARTSIZE * i, uEnd, crPending);
@


1.187
log
@corrected SetDownloadState (thanks Aw3)
optimized SetRemoteQueueRank
@
text
@d660 1
a660 1
		AddDebugLogLine(true, RGB_LOG_WARNING + GetResString(IDS_ERR_BADHASHSET), m_pReqPartFile->GetFileName());
@


1.186
log
@Sent a log to DEBUG only
@
text
@d599 3
d606 5
a615 2
				SetRemoteQueueRank(0);

d618 1
a618 2
			//	Update statistical variables (start time of DL & minimal amount)
				m_dwLastDataRateCalculationTime = m_dwDownStartTime = ::GetTickCount();
a619 1
				m_bTransferredDownMini = false;
a625 3
		//switch the state & update info
		m_eDownloadState = byNewState;

d1294 1
a1294 1
void CUpDownClient::SetRemoteQueueRank(uint16 nr)
d1299 6
a1304 2
	m_uRemoteQueueRank = nr;
	UpdateDisplayedInfo();
@


1.185
log
@Fixed processing of corrupted compression stream;
Fixed very rare decompression problem for highly compressed data;
Added protection againts packets with zero data size;
Removed initialization of 'opaque' zstream parameter (not required because external memory allocation procedures aren't provided);
Recursive calls are changed into a loop (faster).
@
text
@d924 1
d927 1
@


1.184
log
@removed my update for ICR
@
text
@d731 1
a731 1
		pPendingBlock->m_dwTotalUnzipped = 0;
d864 7
a870 1
		throw CString(CString(__FUNCTION__) + _T(": ") + GetResString(IDS_ERR_BADDATABLOCK));
d901 6
a952 1

d955 2
a956 2
							AddDebugLogLine(true, RGB_LOG_DIMMED + _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"),
d968 1
a968 1
								buf.Format(_T("%i.%i.%i.%i"), (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24));
d1028 1
d1031 8
d1088 1
a1088 1
			return;
d1095 1
a1095 1
int CUpDownClient::unzip(Pending_Block_Struct *pRequestedBlock, BYTE *zipped, uint32 lenZipped, BYTE **unzipped, uint32 *lenUnzipped, bool recursive)
d1097 1
a1097 1
	int err = Z_DATA_ERROR;
a1104 1

d1107 1
d1109 1
a1109 2
		pRequestedBlock->m_pZStream = new z_stream;
		zS = pRequestedBlock->m_pZStream;
d1111 1
a1111 1
	//	Initialise stream values
a1113 1
		zS->opaque = (voidpf)0;
d1116 2
a1117 2
		zS->next_out = (*unzipped);
		zS->avail_out = (*lenUnzipped);
d1120 1
a1120 1
		err = inflateInit(zS);
d1122 2
a1123 2
		if (err != Z_OK)
			return err;
d1127 2
a1128 10
	zS->next_in = zipped;

	zS->avail_in = lenZipped;

//	Only set the output if not being called recursively
	if (!recursive)
	{
		zS->next_out = (*unzipped);
		zS->avail_out = (*lenUnzipped);
	}
d1130 2
a1131 2
//	Try to unzip the data
	err = inflate(zS, Z_SYNC_FLUSH);
d1133 1
a1133 2
//	Is zip finished reading all currently available input and writing all generated output
	if (err == Z_STREAM_END)
d1135 2
a1136 3
	//	Finish up
		err = inflateEnd(zS);
		pRequestedBlock->m_pZStream = NULL;
d1138 1
a1138 1
		if (err != Z_OK)
d1140 11
a1150 6
			delete zS;
			return err;
		}

	//	Got a good result, set the size to the amount unzipped in this call (including all recursive calls)
		(*lenUnzipped) = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
d1152 1
a1152 1
		pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
d1154 3
a1156 1
		delete zS;
d1158 1
a1158 5
		zS = NULL; //just for future
	}
	else if ((err == Z_OK) && (zS->avail_out == 0))
	{
	//	Output array was not big enough, call recursively until there is enough space
d1160 1
a1160 2
	//	What size should we try next
		uint32 newLength = (*lenUnzipped) *= 2;
d1162 2
a1163 2
		if (newLength == 0)
			newLength = lenZipped * 2;
d1165 12
a1176 2
	//	Copy any data that was successfully unzipped to new array
		BYTE *temp = new BYTE[newLength];
d1178 15
a1192 15
		memcpy2(temp, (*unzipped), (zS->total_out - pRequestedBlock->m_dwTotalUnzipped));

		delete [] (*unzipped);

		(*unzipped) = temp;

		(*lenUnzipped) = newLength;

	//	Position stream output to correct place in new array
		zS->next_out = (*unzipped) + (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);

		zS->avail_out = (*lenUnzipped) - (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);

	//	Try again
		err = unzip(pRequestedBlock, zS->next_in, zS->avail_in, unzipped, lenUnzipped, true);
a1193 22
	else if ((err == Z_OK) && (zS->avail_in == 0))
	{
	//	All available input has been processed, everything ok.
	//	Set the size to the amount unzipped in this call (including all recursive calls)
		(*lenUnzipped) = (zS->total_out - pRequestedBlock->m_dwTotalUnzipped);
		pRequestedBlock->m_dwTotalUnzipped = zS->total_out;
	//Cax2 - not needed here, it stops downloads prematurely
	//inflateEnd(zS);
	}
	else
	{
		// Should not get here unless input data is corrupt
		AddDebugLogLine(false, RGB_LOG_WARNING + _T("Unexpected zip error in file '%s'"), m_pReqPartFile->GetFileName());
		//DebugBreak(); I removed this so that we could let the client run for more the five minutes.. Barry needs to see if there is or isn't a preoblem here..
		err = inflateEnd(zS);
		pRequestedBlock->m_pZStream = NULL;
		delete zS;
		zS = NULL; //just for future
	}

	if (err != Z_OK)
		(*lenUnzipped) = 0;
d1197 1
a1197 1
	return err;
@


1.183
log
@fixed bug from ICR 2.14
@
text
@a680 26
		// if it was the preparation for first request, we can still try to choose another file
		if (!m_bTransferredDownMini && m_uLastPartAsked == 0xFFFF)
		{
			for (POSITION pos = m_otherRequestsList.GetHeadPosition(); (pos != NULL);)
			{
				CPartFile* 	pOtherPartFile = m_otherRequestsList.GetNext(pos);
				uint16		uPartFreeForRequest;

				if (pOtherPartFile && pOtherPartFile->GetStatus(false) == PS_READY || pOtherPartFile->GetStatus(false) == PS_EMPTY)
				{
					uPartFreeForRequest = pOtherPartFile->GetNextRequestedBlock(this);
					if (uPartFreeForRequest != 0xFFFF)
					{
						//remove a client from DL queue
						m_pReqPartFile->RemoveDownloadingSource(this);
						//change a file
						m_pReqPartFile = pOtherPartFile;
						// add this source DL queue from another file
						m_pReqPartFile->AddDownloadingSource(this);
						m_uLastPartAsked = uPartFreeForRequest;
						break;
					}
				}
			}
		}

@


1.182
log
@Removed a misleading log line.
@
text
@d694 3
d698 2
@


1.181
log
@Add warning to debug log instead of throwing an exception.
@
text
@d770 1
a770 1
		AddDebugLogLine(false, "Cancel download from %s due empty block list", this->GetUserName());
@


1.180
log
@fixed DL break in case of slow speed
@
text
@d636 1
a636 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessHashSet)"));
a640 2
	{}
	else
d642 1
a642 5
		m_pReqPartFile->m_bHashSetNeeded = true;
		throw GetResString(IDS_ERR_BADHASHSET);
	}

	SetDownloadState(DS_ONQUEUE);
d644 5
a648 5
	CSafeMemFile data2(16);
	data2.Write(this->m_pReqPartFile->GetFileHash(), 16);
	Packet* opacket = new Packet(&data2);
	opacket->m_eOpcode = OP_STARTUPLOADREQ;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(opacket->m_dwSize);
d651 1
a651 1
	m_pRequestSocket->SendPacket(opacket, true, true);
d654 7
a660 1
	m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
@


1.179
log
@ICR update
@
text
@d847 2
a848 2
//	Update stats
//	m_dwLastBlockReceived = ::GetTickCount();
d933 2
d1008 2
d1030 2
@


1.178
log
@functional optimization
@
text
@d677 3
a679 1
	//	check if part was completed
d681 2
a682 2
		if ( m_pReqPartFile->GetBytesInPart(m_uLastPartAsked, true, true) == 0
		  || m_pReqPartFile->IsCorruptedPart(m_uLastPartAsked) )
d684 4
a687 2
			m_uLastPartAsked = 0xFFFF;
		}
d689 11
a699 4
	//	First time we've asked?
		if (m_uLastPartAsked == 0xFFFF)
		{
			m_uLastPartAsked = m_pReqPartFile->GetNextRequestedBlock(this);
a706 2
		Requested_Block_Struct	**ppRequestedBlocksToAdd = new Requested_Block_Struct * [uCount];

d709 2
d730 1
d732 3
d736 2
a737 1

a742 7

		for (int i = 0; i < uCount; i++)
		{
			m_downloadBlocksList.AddTail(ppRequestedBlocksToAdd[i]);
		}

		delete[] ppRequestedBlocksToAdd;
d1671 1
a1671 1
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////@


1.177
log
@formatting, removed some ending space and minor changes
removed some menus memleak in sharedctrl
fixed new 'LATER' code
changed new paused/stopped file sorting
removed a space not meant to be there in french.rcu
update changelog
@
text
@d570 1
a570 12
				for (POSITION pos = m_downloadBlocksList.GetHeadPosition(); pos != NULL; )
				{
					Requested_Block_Struct	   *cur_block = m_downloadBlocksList.GetNext(pos);

					m_pReqPartFile->RemoveBlockFromList(cur_block->m_dwStartOffset, cur_block->m_dwEndOffset);
					delete cur_block;
				}
				m_downloadBlocksList.RemoveAll();

				for (POSITION pos = m_pendingBlocksList.GetHeadPosition();pos != NULL; )
				{
					Pending_Block_Struct	   *pending = m_pendingBlocksList.GetNext(pos);
d572 1
a572 11
					if (m_pReqPartFile)
						m_pReqPartFile->RemoveBlockFromList(pending->m_pRequestedBlock->m_dwStartOffset, pending->m_pRequestedBlock->m_dwEndOffset);

					delete pending->m_pRequestedBlock;

				//	Not always allocated
					if (pending->m_pZStream)
					{
						inflateEnd(pending->m_pZStream);
						delete pending->m_pZStream;
					}
a573 3
					delete pending;
				}
				m_pendingBlocksList.RemoveAll();
d1647 16
@


1.176
log
@Minor optimization is back (this way shouldn't confuse anyone)
@
text
@d922 1
a922 1
	for (pos1 = m_pendingBlocksList.GetHeadPosition(); (pos2 = pos1) != NULL;)
d925 1
a925 1
	//Cax2: I'm not happy with this whole if clause
d1069 1
a1069 1
			//  if remote client will send us a data that already were wrtitten, we will not delete the block & delete a packet
d1072 1
a1072 1
			//	in this place becouse m_pReqPartFile->WriteToBuffer was called
d1624 1
a1624 1
		return		static_cast<uint32>(m_dwLastBlockReceived / PARTSIZE);
d1653 1
a1653 1
				pReqFile->RemoveBlockFromList(pPendingBlock->m_pRequestedBlock->m_dwStartOffset, 
@


1.175
log
@formatting; minor changes; something was missed in last commit (Aw3 ???); always keep paused and stopped files at bottom in downloadlist
@
text
@a635 1
				m_dwLastDataRateCalculationTime = ::GetTickCount();		//	new DL measurements system
d637 1
a637 1
				m_dwDownStartTime = ::GetTickCount();
@


1.174
log
@Processing files with size = 0 modulo PARTSIZE (as a result impossible to receive hashset, impossible to complete such file, incorrect average speed report, etc.); service name changed; minor optimization
@
text
@d170 26
a195 28
	DWORD dwTickCount = GetTickCount() + CONNECTION_LATENCY;
	unsigned int nTimePassedClient = dwTickCount - GetLastSrcAnswerTime();
	unsigned int nTimePassedFile = dwTickCount - m_pReqPartFile->GetLastAnsweredTime();
	bool bNeverAskedBefore = GetLastSrcReqTime() == 0;

	UINT dwSources = m_pReqPartFile->GetSourceCount();
	return(
          //if client has the correct extended protocol
	          ExtProtocolAvailable() && m_byteSourceExchangeVer >= 1 &&
          //AND if we can send sources
	          !g_eMuleApp.m_pGlobPrefs->IsDisabledXS() &&
          //AND if we need more sources
	          g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > m_pReqPartFile->GetSourceCount() &&
          //AND if...
	          (
              //source is not complete and file is rare, allow once every 10 minutes
	              ( !m_bCompleteSource &&
	                ( dwSources - m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4 ||
	                  dwSources <= RARE_FILE * 2
	                ) &&
	                (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK)
	              ) ||
              //	otherwise, allow every 90 minutes, but only if we haven't
              //	asked someone else in last 10 minutes
	              ( (bNeverAskedBefore || nTimePassedClient > (unsigned)(SOURCECLIENTREASK * m_pReqPartFile->GetCommonFilePenalty())) &&
	                (nTimePassedFile > SOURCECLIENTREASK)
	              )
	          )
d636 1
a636 1
				m_dwLastDataRateCalculationTime =			//	new DL measurements system
@


1.173
log
@prevent desyncronisation of requested blocks between local & remote client (fix for written from ... to ...)
@
text
@d411 3
a413 2
	//read number of parts
	packetStream.Read(&m_uPartCount, 2);
d423 2
a424 1
	if (!m_uPartCount)
a425 1
		m_uPartCount = m_pReqPartFile->GetPartCount();
d433 1
a433 1
		if (m_pReqPartFile->GetPartCount() != m_uPartCount)
d435 1
a435 1
			m_uPartCount = 0;	//SyruS (0.29c)
d638 2
a639 3
				m_dwLastDataRateCalculationTime = ::GetTickCount();	//eklmn: new DL measurements system

			//v2: eklmn(khaos): update stattistical variables (start time of DL & minimal amount)
d982 4
a985 1
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUserName, (byte)m_dwUserIP, (byte)(m_dwUserIP >> 8), (byte)(m_dwUserIP >> 16), (byte)(m_dwUserIP >> 24), GetUserPort(), md4str(GetUserHash()));
@


1.172
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d1593 1
a1593 1

d1635 35
a1670 1
#endif LATER
@


1.171
log
@final fix for excessive resizing on column resize bug + few optimisations and formatting
@
text
@d348 1
a348 1
		m_pbytePartStatuses = new uint8[m_uPartCount];
d425 1
a425 1
		m_pbytePartStatuses = new uint8[m_uPartCount];
d440 1
a440 1
		m_pbytePartStatuses = new uint8[m_uPartCount];
d445 1
a445 1
			uint8 toread;
d982 1
a982 1
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUserName, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), md4str(GetUserHash()));
d991 1
a991 1
								buf.Format(_T("%i.%i.%i.%i"), (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24));
d1624 1
a1624 1
		return		static_cast<uint32>(m_dwLastBlockReceived / PARTSIZE);;
@


1.170
log
@few changes and formatting + corrected a previous change that is not working
@
text
@d1339 1
a1339 1
//	check if we are downloading something from client
d1351 1
a1351 1
	//	check: does client have another files?
d1354 1
a1354 1
	//	check: target file is specified? if is not, then find another one
d1357 1
a1357 1
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != NULL; )
d1360 1
a1360 1
			//	get first high priority files
d1365 1
a1365 1
					// check: is new file in NNS-Map?
d1368 1
a1368 1
					// calculate a A4AF rating
d1416 1
a1416 1
				m_strComment = "";
@


1.169
log
@Optimized hash processings
@
text
@d876 1
a876 2
//	MOREVIT - We just read the file hash from the stream. Why are we messing with the raw buffer here?
	if (m_pReqPartFile == NULL || md4cmp(pcPacketBuf, m_pReqPartFile->GetFileHash()))
d882 3
a884 3
	uint32		dwStartPos = 0;
	uint32		dwEndPos = 0;
	uint32		dwBlockSize = 0;
d1616 21
@


1.168
log
@minor optimisations
@
text
@a981 9
							CString buffer;
							CString buffer2 = _T("");

							for (uint16 i = 0;i != 16;i++)
							{
								buffer.Format(_T("%02X"), GetUserHash()[i]);
								buffer2 += buffer;
							}

d983 1
a983 1
							AddDebugLogLine(false, RGB_LOG_DIMMED + _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUserName, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), buffer2);
@


1.167
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d540 1
a540 1
	if (posPartFile != 0)
d571 1
a571 1
				for (POSITION pos = m_downloadBlocksList.GetHeadPosition();pos != 0;m_downloadBlocksList.GetNext(pos))
d573 2
a574 1
					Requested_Block_Struct * cur_block = m_downloadBlocksList.GetAt(pos);
d576 1
a576 1
					delete m_downloadBlocksList.GetAt(pos);
d580 1
a580 1
				for (POSITION pos = m_pendingBlocksList.GetHeadPosition();pos != 0; m_pendingBlocksList.GetNext(pos))
d582 1
a582 1
					Pending_Block_Struct * pending = m_pendingBlocksList.GetAt(pos);
d808 1
a808 2
			pRequestedBlock = m_pendingBlocksList.GetAt(pos)->m_pRequestedBlock;
			m_pendingBlocksList.GetNext(pos);
d823 1
a823 2
			pRequestedBlock = m_pendingBlocksList.GetAt(pos)->m_pRequestedBlock;
			m_pendingBlocksList.GetNext(pos);
d1353 7
a1359 8
	POSITION SwapToPos = 0;
	POSITION cur_FilePos;
	POSITION cur_FileNNSPos = 0;
	CPartFile* pCurFile;
	uint32 dwLastNNSCheckedTime = ::GetTickCount();
	const uint16 uPriorityFactorsArray[3] = {1,2,3};
	uint16 uA4AFRating;
	uint16 uBestA4AFRating = 0;
d1367 1
a1367 1
			for (cur_FilePos = m_otherRequestsList.GetHeadPosition();cur_FilePos != 0;m_otherRequestsList.GetNext(cur_FilePos))
d1369 1
a1369 1
				pCurFile = m_otherRequestsList.GetAt(cur_FilePos);
d1376 2
a1377 1
					bool bNNS = m_otherNoNeededMap.Lookup(pCurFile, dwLastNNSCheckedTime);
d1455 1
a1455 1
			POSITION pos_A4AF = SwapTo->m_A4AFsrcList.Find(this);
d1457 1
a1457 1
			if (pos_A4AF)
d1593 1
a1593 1
	for (POSITION pos = m_pendingBlocksList.GetHeadPosition(); pos;)
@


1.166
log
@Formatting, comments, and name changes.
@
text
@d337 1
a337 1
//	removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
d560 1
a560 1
				
d622 1
a622 1
		
d846 1
a846 1
           had been received from a client, and only asked for data in 
d848 1
a848 1
 
d851 1
a851 1
 
d855 1
a855 1
 
d1081 1
a1081 1
			
d1087 1
a1087 1
			//	better check 
d1106 1
a1106 1
			
d1381 1
a1381 1
						uA4AFRating = uPriorityFactorsArray[pCurFile->GetPriority()] 
d1542 3
a1544 3
	if ( m_byteEmuleVersion >= 0x23 
		&& m_uUDPPort != 0 
		&& g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0 
d1546 1
a1546 1
		&& !(m_pRequestSocket && m_pRequestSocket->IsConnected()) 
@


1.165
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d216 1
a216 1
	CSafeMemFile		packetFile1(16 + 16);
d218 1
a218 1
	packetFile1.Write(m_pReqPartFile->GetFileHash(), 16);
d221 1
a221 1
		m_pReqPartFile->WritePartStatus(&packetFile1);
d224 1
a224 1
		m_pReqPartFile->WriteCompleteSourcesCount(&packetFile1); //netwolf: complete sources (zegzav) 13.05.03
d226 1
a226 1
	Packet		*pPacket = new Packet(&packetFile1);
a232 1

d234 1
a235 1
#endif //OLD_SOCKETS_ENABLED
d243 1
a243 1
		CSafeMemFile	packetFile2(16);
d245 1
a245 1
		packetFile2.Write(m_pReqPartFile->GetFileHash(), 16);
d247 1
a247 1
		pPacket = new Packet(&packetFile2);
d337 1
a337 1
//	Removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
@


1.164
log
@Formatting, comments, and name changes.
@
text
@d338 1
a338 1
//	removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
@


1.163
log
@minor changes to DebugLog and remove some marks
@
text
@d239 1
a239 2

//	removed requesting the file status for files <= PARTSIZE for better compatibility with ed2k protocol (eDonkeyHybrid).
a243 1

d1565 1
a1565 1
		Packet* response = new Packet(OP_REASKFILEPING, packetsize, OP_EMULEPROT);	// netwolf: complete sources UDP
d1567 1
a1567 1
		md4cpy(response->m_pcBuffer, m_pReqPartFile->GetFileHash());
d1572 3
a1574 2
			uint16 completecount = m_pReqPartFile->GetCompleteSourcesCount();
			memcpy2(response->m_pcBuffer + 16, &completecount, 2);
@


1.162
log
@from official: removed requesting the file status for files <= PARTSIZE
@
text
@d332 1
a332 2
		AddDebugLogLine( false, _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID)
							  + _T(" (m_pReqPartFile==NULL)"), __FUNCTION__ );
d337 1
a337 2
		AddDebugLogLine( false, _T("%s: ") + GetResString(IDS_ERR_WRONGFILEID)
							  + _T(" (m_pReqPartFile != fileHash)"), __FUNCTION__ );
d404 1
a404 2
			AddDebugLogLine( false, RGB_LOG_DIMMED + _T("CUpDownClient::ProcessFileStatus: ") + 
							GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile==NULL)") );
d410 1
a410 2
		AddDebugLogLine( false, RGB_LOG_DIMMED + _T("CUpDownClient::ProcessFileStatus: ") + 
						GetResString(IDS_ERR_WRONGFILEID) + _T(" (m_pReqPartFile!=pcFileHash)") );
@


1.161
log
@forgotten name changes :o) don't u compile b4 commit, morevit?
@
text
@a238 1
	CSafeMemFile	packetFile2(16);
d240 7
a246 1
	packetFile2.Write(m_pReqPartFile->GetFileHash(), 16);
d248 1
a248 1
	pPacket = new Packet(&packetFile2);
d250 1
a250 1
	pPacket->m_eOpcode = OP_SETREQFILEID;
d252 3
a254 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(pPacket->m_dwSize);
d258 1
a258 1
	m_pRequestSocket->SendPacket(pPacket, true);
d261 1
d342 47
@


1.160
log
@Formatting, comments, and name changes.
@
text
@d1290 1
a1290 1
	m_uDeltaQueueRank = (nr - m_uRemoteQueueRank);
@


1.159
log
@best QR variation calculation thX to Aw3
@
text
@d1290 1
a1290 1
	m_iDeltaQueueRank = static_cast<int>(nr) - static_cast<int>(m_uRemoteQueueRank);
@


1.158
log
@Minor updates (domain change)
@
text
@d1290 1
a1290 1
	m_uDeltaQueueRank = (nr - m_uRemoteQueueRank);
@


1.157
log
@uint16 -> uint32 in indexing loops (thx Aw3)
@
text
@d1215 4
a1218 4
		if (this != NULL)
		{
			AddDebugLogLine(false, "Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
		}
@


1.156
log
@some minor loop corrections
@
text
@d755 1
a755 1
	for (uint16 i = 0; i < 3; i++)
d771 1
a771 1
	for (uint16 i = 0; i < 3; i++)
@


1.155
log
@Removed debug code
@
text
@d755 1
a755 1
	for (uint32 i = 0; i != 3; i++)
d771 1
a771 1
	for (uint32 i = 0; i != 3; i++)
@


1.154
log
@*** empty log message ***
@
text
@a1397 2
				m_ReqPartResetList.AddTail(2); // DonGato: for testing purposes

@


1.153
log
@Minor changes
@
text
@d739 1
a739 1
		AddDebugLogLine(false, "-> Cancel download from %s due empty block list", this->GetUserName());
d1217 1
a1217 1
			AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
@


1.152
log
@Added some data for debug, changed some log lines.
@
text
@a156 1
	{
a157 1
	}
a158 1
	{
a159 1
	}
d162 1
d1071 1
d1073 1
d1191 1
d1438 1
a1439 1
	EMULE_CATCH
d1447 1
d1458 1
d1485 1
@


1.151
log
@Minor changes
@
text
@d354 2
a355 1
			AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; m_pReqPartFile==NULL)"));
d361 2
a362 1
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; m_pReqPartFile!=pcFileHash)"));
a1302 1

d1309 1
a1309 1
	CPartFile* pCurFile;		//Cax2 CPU optimization
a1342 9

					/*
					// eklmn: don't change and order of conditions, cause it using a compiler properties
					if (!bIgnoreNoNeeded || !bNNS || (::GetTickCount() - dwLastNNSCheckedTime) > FILEREASKTIME*3)
					{
						SwapTo = pCurFile;
						SwapToPos = cur_FilePos ;
					}
					*/
d1397 2
@


1.150
log
@A4AF support in UDPReaskFNF & small correction
@
text
@d84 1
a84 2
					else if ( isDLing && m_dwLastBlockOffset < uEnd &&
					          m_dwLastBlockOffset >= PARTSIZE * i )
d493 1
a493 1
	if ( posPartFile != 0)
d512 1
a512 1
				m_pReqPartFile->RemoveDownloadingSource(this);
a1197 1
//	static uint32	dwLastTimeoutMsgTime = 0;
a1203 5
			if (m_strUserName)
				AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", m_strUserName, GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
			else
				AddDebugLogLine(false, "-> Client without name (%s) was dropped due to timeout %u. Send him a CANCEL", m_strUserName, GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);

a1205 1

a1207 10
/*		else
		{
			//	No more than one message/10 sec
			if (dwCurTick > 10 * 1000 + dwLastTimeoutMsgTime)
			{
				AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u. No socket exist", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
				dwLastTimeoutMsgTime = dwCurTick;
			}
		}
*/
d1212 5
a1255 1
//Cax2 - the gain was minimal, not worth keeping that...
d1364 1
a1364 2
			if ( m_pReqPartFile != NULL 
				&& GetDownloadState() == DS_NONEEDEDPARTS)
a1582 1

@


1.149
log
@final fix for a timeouted clients
@
text
@d1484 3
a1486 1
		g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d1489 1
a1489 1
		if (!m_pRequestSocket != NULL)
@


1.148
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d512 1
d841 1
d848 1
a848 1
		dwEndPos = dwStartPos + (dwPacketSize - HEADER_SIZE);
d865 1
a865 1
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, TRANSFERTYPE_DOWNLOAD, dwPacketSize - HEADER_SIZE);
d868 1
a868 3
	uint32 DownDataRateMS = dwPacketSize - HEADER_SIZE;

	m_pCredits->AddDownloaded(dwPacketSize - HEADER_SIZE, this->GetIP());
d872 1
a872 1
	m_dwTransferredDown += DownDataRateMS;
d874 1
a874 1
	m_dwTransferredInLastPeriod += DownDataRateMS;
d902 1
a902 1
				lenWritten = m_pReqPartFile->WriteToBuffer( dwPacketSize - HEADER_SIZE,
d920 1
a920 1
				int result = unzip(cur_block, (BYTE *)(pcPacketBuf + HEADER_SIZE), (dwPacketSize - HEADER_SIZE), &unzipped, &lenUnzipped);
d963 4
a966 3

								g_eMuleApp.m_pIPFilter->AddBannedIPRange(ip1, ip1, 1, _T("autobanned"));
								g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d981 1
a981 1
									lenWritten = m_pReqPartFile->WriteToBuffer( dwPacketSize - HEADER_SIZE,
d1001 1
a1001 1
								lenWritten = m_pReqPartFile->WriteToBuffer( dwPacketSize - HEADER_SIZE,
d1206 4
a1209 1
			AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u. Send him a CANCEL", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
d1487 1
a1487 1
		if (m_pRequestSocket != NULL)
@


1.147
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d946 2
a947 2
							AddDebugLogLine(true, RGB_BLUE_GRAY + _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, RGB_BLUE_GRAY + _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUserName, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), buffer2);
d966 1
a966 1
								AddDebugLogLine(false, RGB_BLUE_GRAY + _T("block dropped & IP locked out!"));
d974 1
a974 1
									AddDebugLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
d994 1
a994 1
								AddDebugLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
d1011 1
a1011 1
					AddDebugLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), result);
d1178 1
a1178 1
		AddDebugLogLine(false, RGB_LIGHT_ORANGE + _T("Unexpected zip error in file '%s'"), m_pReqPartFile->GetFileName());
@


1.146
log
@Added some colors to the logs...
@
text
@d241 1
a241 1
//	AddDebugLogLine(false,"File Status: %s was requested from %s", m_pReqPartFile->GetFileName(), this->GetUserName());
d946 2
a947 2
							AddDebugLogLine(true, _T("<COLOR=102,102,153>Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, _T("<COLOR=102,102,153>username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUserName, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), buffer2);
d966 1
a966 1
								AddDebugLogLine(false, _T("<COLOR=102,102,153>block dropped & IP locked out!"));
d974 1
a974 1
									AddDebugLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
d994 1
a994 1
								AddDebugLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
d1011 1
a1011 1
					AddDebugLogLine(false, _T("<COLOR=255,102,0>") + GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), result);
d1178 1
a1178 1
		AddDebugLogLine(false, _T("<COLOR=255,102,0>Unexpected zip error in file '%s'"), m_pReqPartFile->GetFileName());
@


1.145
log
@Fixed server keep-alive
@
text
@d946 2
a947 2
							AddDebugLogLine(true, _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), m_pReqPartFile->GetFileName(), cur_block->m_pRequestedBlock->m_dwStartOffset / PARTSIZE, cur_block->m_pRequestedBlock->m_dwStartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUserName, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), buffer2);
d966 1
a966 1
								AddDebugLogLine(false, _T("block dropped & IP locked out!"));
d974 1
a974 1
									AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
d994 1
a994 1
								AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), 666);
d1011 1
a1011 1
					AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG), m_pReqPartFile->GetFileName(), result);
d1178 1
a1178 1
		AddDebugLogLine(false, _T("Unexpected zip error in file '%s'"), m_pReqPartFile->GetFileName());
@


1.144
log
@fixed the packet handling, since the packet was not removed  in some cases
@
text
@d1198 1
a1198 1
	static uint32	dwLastTimeoutMsgTime = 0;
d1212 1
a1212 1
		else
d1221 1
@


1.143
log
@1i public release preparations
@
text
@d1025 2
a1026 1
		//	These checks only need to be done if any packetStream was written
d1029 2
a1030 2
			//m_dwTransferredDown += lenWritten;
			m_bTransferredDownMini = true;		// -khaos--+++> For determining whether the current download session was a success or not.
d1032 4
a1035 1
			//	If finished reserved block
d1040 6
a1045 1
			//	better check [TwoBottle Mod]
d1047 1
a1047 1
				if (!m_pendingBlocksList.IsEmpty() && dwEndPos == cur_block->m_pRequestedBlock->m_dwEndOffset)
d1049 3
a1051 3
					m_pReqPartFile->RemoveBlockFromList(cur_block->m_pRequestedBlock->m_dwStartOffset, cur_block->m_pRequestedBlock->m_dwEndOffset);
					delete cur_block->m_pRequestedBlock;
				//	Not always allocated
d1053 2
a1054 5
					if (cur_block->m_pZStream)
					{
						inflateEnd(cur_block->m_pZStream);
						delete cur_block->m_pZStream;
					}
d1056 2
a1057 6
					delete cur_block;
					m_pendingBlocksList.RemoveAt(pos2);

				//	Request next block
					SendBlockRequests();
				}
d1059 1
@


1.142
log
@minor tweaks in process of DL clients
@
text
@d1195 1
a1195 1
//	static uint32	dwLastTimeoutMsgTime = 0;
d1210 8
a1217 1
			AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u. No socket exist", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
a1221 8

		//	No more than one message/10 sec

		/*if (dwCurTick > 10 * 1000 + dwLastTimeoutMsgTime)
		{
			AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u", GetUserName(), GetClientNameAndVersionString(this), dwCurTick - m_dwLastBlockReceived);
			dwLastTimeoutMsgTime = dwCurTick;
		}*/
@


1.141
log
@prevent generation of the jumping clients (part2)
@
text
@d512 2
a520 1
				m_pReqPartFile->RemoveDownloadingSource(this);
@


1.140
log
@corrected handlilng of hello packet & behaviour after DL timeout
@
text
@d508 68
a598 67
	
		if (m_eDownloadState == DS_DOWNLOADING)
		{
		//	-khaos--+++> Extended Statistics (Successful/Failed Download Sessions)
			if (m_bTransferredDownMini && byNewState != DS_ERROR)
				g_eMuleApp.m_pGlobPrefs->Add2DownSuccessfulSessions(); // Increment our counters for successful sessions (Cumulative AND Session)
			else
				g_eMuleApp.m_pGlobPrefs->Add2DownFailedSessions(); // Increment our counters failed sessions (Cumulative AND Session)

			g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime((::GetTickCount() - m_dwDownStartTime) / 1000);
		//	<-----khaos-

			m_pReqPartFile->RemoveDownloadingSource(this);

			m_eDownloadState = byNewState;

			for (POSITION pos = m_downloadBlocksList.GetHeadPosition();pos != 0;m_downloadBlocksList.GetNext(pos))
			{
				Requested_Block_Struct * cur_block = m_downloadBlocksList.GetAt(pos);
				m_pReqPartFile->RemoveBlockFromList(cur_block->m_dwStartOffset, cur_block->m_dwEndOffset);
				delete m_downloadBlocksList.GetAt(pos);
			}

			m_downloadBlocksList.RemoveAll();

			for (POSITION pos = m_pendingBlocksList.GetHeadPosition();pos != 0; m_pendingBlocksList.GetNext(pos))
			{
				Pending_Block_Struct * pending = m_pendingBlocksList.GetAt(pos);

				if (m_pReqPartFile)
					m_pReqPartFile->RemoveBlockFromList(pending->m_pRequestedBlock->m_dwStartOffset, pending->m_pRequestedBlock->m_dwEndOffset);

				delete pending->m_pRequestedBlock;

			//	Not always allocated
				if (pending->m_pZStream)
				{
					inflateEnd(pending->m_pZStream);
					delete pending->m_pZStream;
				}

				delete pending;
			}

			m_pendingBlocksList.RemoveAll();
			m_dwDownDataRate = 0;

			if (byNewState == DS_NONE)
			{
				if (m_pbytePartStatuses)
					delete[] m_pbytePartStatuses;

				m_pbytePartStatuses = 0;

				m_uPartCount = 0;	//SyruS (0.29c)
			}

			m_uLastPartAsked = 0xFFFF;

#ifdef OLD_SOCKETS_ENABLED

			if (m_pRequestSocket && byNewState != DS_ERROR)
				m_pRequestSocket->DisableDownloadLimit();

#endif //OLD_SOCKETS_ENABLED

		}
d600 1
a600 1
	//	switch the state & update info
@


1.139
log
@infinite cancel issue
@
text
@d1193 1
a1193 1
	static uint32	dwLastTimeoutMsgTime = 0;
d1200 2
d1207 2
a1212 1
	//	No more than one message/10 sec
d1214 3
a1216 1
		if (dwCurTick > 10 * 1000 + dwLastTimeoutMsgTime)
d1220 1
a1220 1
		}
@


1.138
log
@1) remove file from m_otherRequestList in case Stop or Complete
2) handling of data blocks was slightly changed
@
text
@d818 1
a818 1
	m_dwLastBlockReceived = ::GetTickCount();
a861 2

//	g_eMuleApp.UpdateReceivedBytes(dwPacketSize - HEADER_SIZE);
@


1.137
log
@minor changes
@
text
@d460 1
a460 1

d483 10
d494 8
a814 4
//	If no data is required, just ignore it and return
	if (!(GetDownloadState() == DS_DOWNLOADING || GetDownloadState() == DS_NONEEDEDPARTS))
		return;

a1205 1

@


1.136
log
@improved NNS handling in A4AF
@
text
@d960 1
a960 1
									AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG, m_pReqPartFile->GetFileName(), 666);
d980 1
a980 1
								AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG, m_pReqPartFile->GetFileName(), 666);
d997 1
a997 1
					AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG, m_pReqPartFile->GetFileName(), result);
d1004 2
a1005 2
						delete [] unzipped;
				}
d1015 1
a1015 1
				m_bTransferredDownMini = true;		// -khaos--+++> For determining whether the current download session was a success or not.
a1025 2
					m_pendingBlocksList.RemoveAt(pos2);

d1037 1
d1160 3
a1162 3
	//	Should not get here unless input data is corrupt
		AddDebugLogLine(false, _T("Unexpected zip error"));
	//DebugBreak(); I removed this so that we could let the client run for more the five minutes.. Barry needs to see if there is or isn't a preoblem here..
@


1.135
log
@corrected bug in the logic of SetDownloadState()
@
text
@d346 2
a347 3
	uchar cfilehash[16];
	packetStream.Read(cfilehash, 16);
//netwolf: patch 'fix disappearing m_pReqPartFile part2' START (taab)
d351 1
a351 1
		CKnownFile * locreqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(cfilehash);
d353 5
a357 2
		if (locreqfile && locreqfile->IsPartFile())
			m_pReqPartFile = (CPartFile *)locreqfile;
d359 1
a359 4

//newolf END

	if ((!m_pReqPartFile) || md4cmp(cfilehash, m_pReqPartFile->GetFileHash()))
d361 1
a361 7
	//delete packetStream;	//mf	//TwoBottle Mod

		if (m_pReqPartFile == NULL)	//SyruS (0.29c)
			AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; m_pReqPartFile==NULL)"));
		else
			AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; m_pReqPartFile!=cfilehash)"));

d365 1
a387 1
		//delete packetStream;	//mf	//TwoBottle Mod
a404 2
			//	netwolf: zegzav completesrc - BEGIN

a407 1

a410 2

			//	netwolf: zegzav completesrc - END
a417 1
	//	netwolf: zegzav completesrc - BEGIN
a419 2

	//	netwolf: zegzav completesrc - END
d422 1
a423 2
	m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
//m_pReqPartFile->UpdateAvailablePartsCount();
d425 1
a425 1
	CheckForUpPartsInfo(); // obaldin
a434 1

a443 1
	//delete packetStream;	//TwoBottle Mod
a457 2
//delete packetStream;	//TwoBottle Mod

a467 4
//	check NNS list
	if (m_otherNoNeededList.Find(file) != 0)
		return false;	// eklmn: optimization(01): search with Find

d470 2
a471 2
		return false;	// eklmn: optimization(01): search with Find

d474 2
a475 1
	file->m_A4AFsrcList.AddTail(this);	// add in A4AF file list
d1176 1
a1176 1

d1254 1
a1254 1

d1273 1
a1273 1

d1284 1
a1284 1

a1295 1

a1296 1

d1298 5
d1304 2
a1305 4
	CPartFile* cur_file;		//Cax2 CPU optimization

//	check: target file is specified? if is not, then find another one
	if (!SwapTo)
d1307 2
a1308 3
	//	check: does client have another files?

		if (!m_otherRequestsList.IsEmpty())
d1312 1
a1312 1
				cur_file = m_otherRequestsList.GetAt(cur_FilePos);
d1315 2
a1316 2
				if ( cur_file != m_pReqPartFile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(cur_file)
				     && (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) )
d1318 14
a1331 1
				//	check: is new file in NNS-list?
d1333 3
a1335 1
					if (!bIgnoreNoNeeded || m_otherNoNeededList.Find(cur_file) == 0)
d1337 1
a1337 1
						SwapTo = cur_file;
a1338 1
						break; // break for cycle, since  file was found
d1340 1
d1344 4
a1347 3
	}
	else if (SwapTo->GetStatus(false) == PS_READY || SwapTo->GetStatus(false) == PS_EMPTY)
		SwapToPos = m_otherRequestsList.Find(SwapTo); // otherwise get position with .Find()
d1349 3
a1351 3
//	now let's swap the file to another
	if (SwapTo != NULL && SwapToPos != 0)
	{
d1353 6
a1358 1
	//	to prevent loop swaping remember NNS-Part
d1360 2
a1361 2
		if (m_pReqPartFile != NULL && GetDownloadState() == DS_NONEEDEDPARTS && !m_otherNoNeededList.Find(m_pReqPartFile))
			m_otherNoNeededList.AddTail(m_pReqPartFile);
d1363 5
a1367 2
	//	switch state to NONE
		SetDownloadState(DS_NONE);
d1369 3
a1371 5
		if (m_pbytePartStatuses)
		{
			delete[] m_pbytePartStatuses;
			m_pbytePartStatuses = 0;
		}
d1373 8
a1380 3
		m_uPartCount = 0;
		m_dwLastAskedTime = 0;
		m_uLastPartAsked = 0xFFFF;
d1382 2
a1383 8
	//	add to past comment
		if (m_pReqPartFile != NULL)
		{
			m_pReqPartFile->AddPastComment(this);
			m_eRating = PF_RATING_NONE;
			m_strComment = "";
		//	find current file position in sourceslots
			cur_FilePos = m_pReqPartFile->m_srcLists[m_iSourcesSlot].Find(this);
d1385 2
a1386 2
			if (cur_FilePos)
				m_pReqPartFile->m_srcLists[m_iSourcesSlot].RemoveAt(cur_FilePos); // remove current file
d1388 2
a1389 2
		//	add them in A4AF list
			m_pReqPartFile->m_A4AFsrcList.AddTail(this);
d1391 2
a1392 2
		//	add old file to m_otherRequestsList
			m_otherRequestsList.AddTail(m_pReqPartFile);
d1394 2
a1395 2
		//	let's update current information for the removed file
			m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d1397 2
a1398 2
		//	update download list (old file update)
			m_pReqPartFile->UpdateDisplayedInfo();
d1400 2
a1401 2
			m_pReqPartFile = NULL;	//reset before delete m_pbytePartStatuses
		}
d1403 2
a1404 2
	//	actual switch
		m_pReqPartFile = SwapTo;
d1406 2
a1407 2
	//	remove new file from OtherRequests list
		m_otherRequestsList.RemoveAt(SwapToPos);
d1409 2
a1410 2
	//	remove current source from A4AF list in new file
		POSITION pos_A4AF = SwapTo->m_A4AFsrcList.Find(this);
d1412 2
a1413 2
		if (pos_A4AF)
			SwapTo->m_A4AFsrcList.RemoveAt(pos_A4AF);
d1415 3
a1417 2
	//	to prevent loop swaping remember NNS-Part
		cur_FileNNSPos = m_otherNoNeededList.Find(SwapTo);
d1419 2
a1420 2
		if (cur_FileNNSPos != 0)
			m_otherNoNeededList.RemoveAt(cur_FileNNSPos);
d1422 2
a1423 3
	//	add to souceslots
		if (!SwapTo->m_srcLists[m_iSourcesSlot].Find(this))
			SwapTo->m_srcLists[m_iSourcesSlot].AddTail(this);
d1425 2
a1426 2
	//	remove from past comment
		SwapTo->RemovePastComment(this);	// #zegzav:pastcomment
d1428 2
a1429 2
	//	Update info for target file
		SwapTo->NewSrcPartsInfo();	// eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d1431 3
a1433 2
	//	update download list (new file update)
		SwapTo->UpdateDisplayedInfo();
a1434 5
	//	now update the client item
		UpdateDisplayedInfo(true);

		return true;
	}
a1438 1

d1440 1
a1440 1

d1450 1
a1450 1

d1474 1
a1474 1

d1488 6
a1493 2
	if ( m_byteEmuleVersion >= 0x23 && m_uUDPPort != 0 && g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0 &&
	     !g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()) && (!proxy.m_bUseProxy) )
@


1.134
log
@Formatting, comments, and name changes.
@
text
@d513 1
a513 1
		if (byNewState == DS_DOWNLOADING)
d515 2
a516 1
			m_pReqPartFile->AddDownloadingSource(this);
d518 2
a519 2
			if (IsEmuleClient())
				SetRemoteQueueFull(false);
d521 1
a521 1
			SetRemoteQueueRank(0);
d523 1
a523 1
			SetAskedCountDown(0);
d525 1
a525 1
			m_dwLastDataRateCalculationTime = ::GetTickCount();	//eklmn: new DL measurements system
d527 2
a528 2
		//v2: eklmn(khaos): update stattistical variables (start time of DL & minimal amount)
			m_dwDownStartTime = ::GetTickCount();
d530 5
a534 1
			m_bTransferredDownMini = false;
d536 2
a537 3
		else if (byNewState == DS_CONNECTED)
			m_dwEnteredConnectedState = ::GetTickCount();
		else if (m_eDownloadState == DS_DOWNLOADING)
a539 1

a545 1

d561 1
a561 1
			for (POSITION pos = m_pendingBlocksList.GetHeadPosition();pos != 0;m_pendingBlocksList.GetNext(pos))
@


1.133
log
@Formatting, comments, and name changes.
@
text
@d345 1
a345 1
	CSafeMemFile data((BYTE*)packet, size);	//TwoBottle Mod (exceptions!)
d347 1
a347 1
	data.Read(cfilehash, 16);
d362 1
a362 1
	//delete data;	//mf	//TwoBottle Mod
d372 1
a372 1
	data.Read(&m_uPartCount, 2);
d394 1
a394 1
		//delete data;	//mf	//TwoBottle Mod
d407 1
a407 1
			data.Read(&toread, 1);
d447 3
a449 3
		Packet * packet = new Packet(OP_HASHSETREQUEST, 16);
		md4cpy(packet->m_pcBuffer, m_pReqPartFile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d452 1
a452 1
		m_pRequestSocket->SendPacket(packet, true, true);
d461 1
a461 1
	//delete data;	//TwoBottle Mod
d464 3
a466 3
		Packet* packet = new Packet(&data1);
		packet->m_eOpcode = OP_STARTUPLOADREQ;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d469 1
a469 1
		m_pRequestSocket->SendPacket(packet, true, true);
d476 1
a476 1
//delete data;	//TwoBottle Mod
d611 1
a611 1
void CUpDownClient::ProcessHashSet(char* packet, uint32 size)
d615 1
a615 1
	if ((!m_pReqPartFile) || md4cmp(packet, m_pReqPartFile->GetFileHash()))
d618 1
a618 1
	CSafeMemFile data1((BYTE*)packet, size);
d644 1
a644 1

d651 1
a651 1
	if (!m_pReqPartFile)
d672 1
a672 1
		uint16 count, savedcount;
d674 1
a674 1
		savedcount = count = 3 - m_pendingBlocksList.GetCount();
d676 1
a676 1
		Requested_Block_Struct	**toadd = new Requested_Block_Struct * [count];
d680 1
a680 1
			m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, toadd, &count);
d682 1
a682 1
			if (count == 0)		//finished block (part ?)
d687 2
a688 1
				     || m_pReqPartFile->IsCorruptedPart(m_uLastPartAsked) )
d690 1
d696 2
a697 2
					count = savedcount;
					m_pReqPartFile->GetGapsInPart(this, m_uLastPartAsked, toadd, &count);
d704 3
a706 1
			count = 0;
d708 1
a708 1
		for (int i = 0; i < count; i++)
d710 1
a710 1
			m_downloadBlocksList.AddTail(toadd[i]);
d713 1
a713 1
		delete[] toadd;
d719 6
a724 5
		Pending_Block_Struct * pblock = new Pending_Block_Struct;
		pblock->m_pRequestedBlock = m_downloadBlocksList.RemoveHead();
		pblock->m_pZStream = NULL;
		pblock->m_dwTotalUnzipped = 0;
		m_pendingBlocksList.AddTail(pblock);
d729 3
a731 2
		Packet * packet = new Packet(OP_CANCELTRANSFER);
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d734 1
a734 1
		m_pRequestSocket->SendPacket(packet, true, true);
d746 10
a755 6
	Packet* packet = new Packet(OP_REQUESTPARTS, 40);
	CSafeMemFile data((BYTE*)packet->m_pcBuffer, 40);
	data.Write(m_pReqPartFile->GetFileHash(), 16);
	POSITION pos = m_pendingBlocksList.GetHeadPosition();
	uint32 null = 0;
	Requested_Block_Struct* block;
d759 1
a759 1
		if (pos)
d761 1
a761 1
			block = m_pendingBlocksList.GetAt(pos)->m_pRequestedBlock;
d763 1
a763 1
			data.Write(&block->m_dwStartOffset, 4);
d766 3
a768 1
			data.Write(&null, 4);
d775 1
a775 1
		if (pos)
d777 1
a777 1
			block = m_pendingBlocksList.GetAt(pos)->m_pRequestedBlock;
d779 4
a782 2
			uint32 endpos = block->m_dwEndOffset + 1;
			data.Write(&endpos, 4);
d785 3
a787 1
			data.Write(&null, 4);
d790 1
a790 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d793 1
a793 1
	m_pRequestSocket->SendPacket(packet, true, true);
d1074 1
a1074 1
int CUpDownClient::unzip(Pending_Block_Struct *block, BYTE *zipped, uint32 lenZipped, BYTE **unzipped, uint32 *lenUnzipped, bool recursive)
d1079 1
a1079 1
	z_stream *zS = block->m_pZStream;
d1086 2
a1087 2
		block->m_pZStream = new z_stream;
		zS = block->m_pZStream;
d1125 1
a1125 1
		block->m_pZStream = NULL;
d1134 1
a1134 1
		(*lenUnzipped) = (zS->total_out - block->m_dwTotalUnzipped);
d1136 1
a1136 1
		block->m_dwTotalUnzipped = zS->total_out;
d1155 1
a1155 1
		memcpy2(temp, (*unzipped), (zS->total_out - block->m_dwTotalUnzipped));
d1164 1
a1164 1
		zS->next_out = (*unzipped) + (zS->total_out - block->m_dwTotalUnzipped);
d1166 1
a1166 1
		zS->avail_out = (*lenUnzipped) - (zS->total_out - block->m_dwTotalUnzipped);
d1169 1
a1169 1
		err = unzip(block, zS->next_in, zS->avail_in, unzipped, lenUnzipped, true);
d1175 2
a1176 2
		(*lenUnzipped) = (zS->total_out - block->m_dwTotalUnzipped);
		block->m_dwTotalUnzipped = zS->total_out;
d1186 1
a1186 1
		block->m_pZStream = NULL;
d1210 2
a1211 2
			Packet * packet = new Packet(OP_CANCELTRANSFER);
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d1213 1
a1213 1
			m_pRequestSocket->SendPacket(packet, true, true);
d1532 2
a1533 2

//	Barry - Sets string to show parts downloading, eg NNNYNNNNYYNYN
d1540 1
a1540 1
	for (POSITION pos = m_pendingBlocksList.GetHeadPosition();pos;)
d1545 1
a1545 1

d1556 1
a1556 1
	uint16 count = 0;
d1562 1
a1562 1
				count++;
d1564 1
a1564 1
	//TRACE("Counted %u Chunks (parts) that %s has and I need (to download)",count,GetUserName());
d1567 1
a1567 1
	return count;
@


1.132
log
@Formatting, comments, and name changes.
@
text
@d553 1
a553 1
				m_pReqPartFile->RemoveBlockFromList(cur_block->StartOffset, cur_block->EndOffset);
d564 1
a564 1
					m_pReqPartFile->RemoveBlockFromList(pending->block->StartOffset, pending->block->EndOffset);
d566 1
a566 1
				delete pending->block;
d569 1
a569 1
				if (pending->zStream)
d571 2
a572 2
					inflateEnd(pending->zStream);
					delete pending->zStream;
d716 3
a718 3
		pblock->block = m_downloadBlocksList.RemoveHead();
		pblock->zStream = NULL;
		pblock->totalUnzipped = 0;
d751 1
a751 1
			block = m_pendingBlocksList.GetAt(pos)->block;
d753 1
a753 1
			data.Write(&block->StartOffset, 4);
d765 1
a765 1
			block = m_pendingBlocksList.GetAt(pos)->block;
d767 1
a767 1
			uint32 endpos = block->EndOffset + 1;
d877 1
a877 1
		if ((cur_block->block->StartOffset <= dwStartPos) && (cur_block->block->EndOffset >= dwStartPos))
d897 1
a897 1
				             cur_block->block );
d920 2
a921 2
						dwStartPos = cur_block->block->StartOffset + cur_block->totalUnzipped - lenUnzipped;
						dwEndPos = cur_block->block->StartOffset + cur_block->totalUnzipped - 1;
d937 2
a938 2
							AddDebugLogLine(true, _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), m_pReqPartFile->GetFileName(), cur_block->block->StartOffset / PARTSIZE, cur_block->block->StartOffset / EMBLOCKSIZE, lenUnzipped, dwBlockSize);
							AddDebugLogLine(false, _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_strUsername, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), buffer2);
d943 1
a943 1
								m_pReqPartFile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->StartOffset + 1);
d963 1
a963 1
								if (dwEndPos > cur_block->block->EndOffset)
d966 1
a966 1
									m_pReqPartFile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d975 1
a975 1
									             cur_block->block );
d983 1
a983 1
							if (dwEndPos > cur_block->block->EndOffset)
d986 1
a986 1
								m_pReqPartFile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d995 1
a995 1
								             cur_block->block );
d1003 1
a1003 1
					m_pReqPartFile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d1029 1
a1029 1
				if (!m_pendingBlocksList.IsEmpty() && dwEndPos == cur_block->block->EndOffset)
d1033 2
a1034 2
					m_pReqPartFile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
					delete cur_block->block;
d1037 1
a1037 1
					if (cur_block->zStream)
d1039 2
a1040 2
						inflateEnd(cur_block->zStream);
						delete cur_block->zStream;
d1063 1
a1063 1
	z_stream *zS = block->zStream;
d1070 2
a1071 2
		block->zStream = new z_stream;
		zS = block->zStream;
d1109 1
a1109 1
		block->zStream = NULL;
d1118 1
a1118 1
		(*lenUnzipped) = (zS->total_out - block->totalUnzipped);
d1120 1
a1120 1
		block->totalUnzipped = zS->total_out;
d1139 1
a1139 1
		memcpy2(temp, (*unzipped), (zS->total_out - block->totalUnzipped));
d1148 1
a1148 1
		zS->next_out = (*unzipped) + (zS->total_out - block->totalUnzipped);
d1150 1
a1150 1
		zS->avail_out = (*lenUnzipped) - (zS->total_out - block->totalUnzipped);
d1159 2
a1160 2
		(*lenUnzipped) = (zS->total_out - block->totalUnzipped);
		block->totalUnzipped = zS->total_out;
d1170 1
a1170 1
		block->zStream = NULL;
d1525 1
a1525 1
		parts[m_pendingBlocksList.GetNext(pos)->block->StartOffset / PARTSIZE] = true;
@


1.131
log
@some updates from official
@
text
@d179 1
a179 1
	UINT uSources = m_pReqPartFile->GetSourceCount();
d191 2
a192 2
	                ( uSources - m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4 ||
	                  uSources <= RARE_FILE * 2
@


1.130
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d179 1
d191 2
a192 2
	                ( m_pReqPartFile->GetSourceCount() - m_pReqPartFile->GetValidSourcesCount() <= RARE_FILE / 4 ||
	                  m_pReqPartFile->GetSourceCount() <= RARE_FILE * 2
@


1.129
log
@Fixed (hopefully) a crash on "Swap all A4AF to this file (auto)". Got a source with a NULL requested file pointer in SwapToThisFile(). Don't think that's supposed to happen.
@
text
@d143 1
a143 1
			m_dwLastAskedTime = GetTickCount() - FILEREASKTIME + (uint32)ROUND(((float)rand() / RAND_MAX) * 300000);
@


1.128
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d1338 1
a1338 1
	if (SwapTo && SwapToPos != 0)
d1343 1
a1343 1
		if (GetDownloadState() == DS_NONEEDEDPARTS && !m_otherNoNeededList.Find(m_pReqPartFile))
d1360 7
a1366 5
		m_pReqPartFile->AddPastComment(this);
		m_eRating = PF_RATING_NONE;
		m_strComment = "";
	//	find current file position in sourceslots
		cur_FilePos = m_pReqPartFile->m_srcLists[m_iSourcesSlot].Find(this);
d1368 2
a1369 2
		if (cur_FilePos)
			m_pReqPartFile->m_srcLists[m_iSourcesSlot].RemoveAt(cur_FilePos); // remove current file
d1371 2
a1372 2
	//	add them in A4AF list
		m_pReqPartFile->m_A4AFsrcList.AddTail(this);
d1374 2
a1375 2
	//	add old file to m_otherRequestsList
		m_otherRequestsList.AddTail(m_pReqPartFile);
d1377 2
a1378 2
	//	let's update current information for the removed file
		m_pReqPartFile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d1380 2
a1381 2
	//	update download list (old file update)
		m_pReqPartFile->UpdateDisplayedInfo();
d1383 2
a1384 1
		m_pReqPartFile = 0;	//reset before delete m_pbytePartStatuses
@


1.127
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d142 1
d144 1
d158 1
d160 1
a162 1
	//g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d294 2
a295 1
void CUpDownClient::ProcessFileInfo(char* packet, uint32 size)
d298 4
d303 7
a309 8
	CSafeMemFile data((BYTE*)packet, size);
	uchar cfilehash[16];
	data.Read(cfilehash, 16);
	uint16 namelength;
	data.Read(&namelength, 2);
	data.Read(m_strClientFilename.GetBuffer(namelength), namelength);	//SyruS (0.29c)
	m_strClientFilename.ReleaseBuffer(namelength);
	m_dwLastAskedTime = ::GetTickCount(); //<<-- enkeyDEV(th1) -L2HAC- highid side
d311 2
a312 1
//netwolf: patch 'fix disappearing m_pReqPartFile' START (taab)
d314 4
a317 1
	if (!m_pReqPartFile)
d319 1
a319 1
		CKnownFile * locreqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(cfilehash);
d321 2
a322 2
		if (locreqfile && locreqfile->IsPartFile())
			m_pReqPartFile = (CPartFile *)locreqfile;
d325 1
a325 3
//netwolf END

	if (m_pReqPartFile == NULL)	//SyruS (0.29c)
d327 2
a328 1
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileInfo; m_pReqPartFile==NULL)"));
d331 5
a335 2
	if (md4cmp(cfilehash, m_pReqPartFile->GetFileHash()))
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileInfo; m_pReqPartFile!=cfilehash)"));
d339 1
a339 1

d590 1
a590 1
			m_uLastPartAsked = 0xffff; //jicxicmic
d652 2
a653 2

//jicxicmic - get blocks from the same chunk first
d659 4
a662 2
		     || m_pReqPartFile->IsCorruptedPart(m_uLastPartAsked) )
			m_uLastPartAsked = 0xffff; //ICR 2.10
d664 3
a666 2
	//first time we ask?
		if (m_uLastPartAsked == 0xffff)
d668 1
d675 1
a675 1
		Requested_Block_Struct** toadd = new Requested_Block_Struct * [count];
d677 1
a677 1
		if (m_uLastPartAsked != 0xffff)		//previous active part ?
d687 1
a687 1
					m_uLastPartAsked = 0xffff; //ICR 2.10
d691 1
a691 1
				if (m_uLastPartAsked != 0xffff)		//more parts ?
d781 1
a781 1

d797 1
a797 1
void CUpDownClient::ProcessBlockPacket(char* packet, uint32 size, bool packed)
d801 1
a801 2
//	Ignore if no data required

d805 1
a805 1
	const int HEADER_SIZE = 24;
d811 1
a811 1
	CSafeMemFile data((BYTE*)packet, size);
d813 1
a813 1
	uchar fileID[16];
d815 1
a815 1
	data.Read(fileID, 16);
d818 2
a819 1
	if ((!m_pReqPartFile) || md4cmp(packet, m_pReqPartFile->GetFileHash()))
d821 1
a821 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessBlockPacket)"));
d825 3
a827 3
	uint32 nStartPos;

	uint32 nEndPos;
d829 1
a829 1
	uint32 nBlockSize = 0;
d831 1
a831 3
	data.Read(&nStartPos, 4);

	if (packed)
d833 2
a834 2
		data.Read(&nBlockSize, 4);
		nEndPos = nStartPos + (size - HEADER_SIZE);
d838 3
a840 1
		data.Read(&nEndPos, 4);
d842 5
a846 3
//	Check that packet size matches the declared data size + header size (24)
	if (size != ((nEndPos - nStartPos) + HEADER_SIZE))
		throw CString(GetResString(IDS_ERR_BADDATABLOCK) + _T(" (ProcessBlockPacket)"));
a847 1
//	-khaos--+++>
d849 3
a851 3
//	The new function adds the bytes to the grand total as well as the given client/port.
//	bFromPF is not relevant to downloaded data.  It is purely an uploads statistic.
	g_eMuleApp.m_pGlobPrefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, Download, size - HEADER_SIZE);
d853 1
a853 2
//	g_eMuleApp.UpdateReceivedBytes(size - HEADER_SIZE);
//	<-----khaos-
d856 1
a856 1
	uint32 DownDataRateMS = size - HEADER_SIZE;
d858 1
a858 1
	m_pCredits->AddDownloaded(size - HEADER_SIZE, this->GetIP());
d860 1
a860 1
	nEndPos--;
d876 1
a876 1
		if ((cur_block->block->StartOffset <= nStartPos) && (cur_block->block->EndOffset >= nStartPos))
d881 1
a881 1
			m_dwLastBlockOffset = nStartPos;
d887 1
a887 1
		//	Handle differently depending on whether packed or not
d889 1
a889 1
			if (!packed)
d892 4
a895 4
				lenWritten = m_pReqPartFile->WriteToBuffer( size - HEADER_SIZE,
				             (BYTE *) (packet + HEADER_SIZE),
				             nStartPos,
				             nEndPos,
d900 2
a901 2
			//	Create space to store unzipped data, the size is only an initial guess, will be resized in unzip() if not big enough
				uint32 lenUnzipped = (size * 2);
d909 2
a910 2
			//	Try to unzip the packet
				int result = unzip(cur_block, (BYTE *)(packet + HEADER_SIZE), (size - HEADER_SIZE), &unzipped, &lenUnzipped);
d914 1
a914 1
				//	Write any unzipped data to disk
d918 3
a920 3
					//	Use the current start and end positions for the uncompressed data
						nStartPos = cur_block->block->StartOffset + cur_block->totalUnzipped - lenUnzipped;
						nEndPos = cur_block->block->StartOffset + cur_block->totalUnzipped - 1;
d922 1
a922 1
						if (nBlockSize * 25 < lenUnzipped)
d936 1
a936 1
							AddDebugLogLine(true, _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), m_pReqPartFile->GetFileName(), cur_block->block->StartOffset / PARTSIZE, cur_block->block->StartOffset / EMBLOCKSIZE, lenUnzipped, nBlockSize);
d962 1
a962 1
								if (nEndPos > cur_block->block->EndOffset)
d969 2
a970 2
								//	Write uncompressed data to file
									lenWritten = m_pReqPartFile->WriteToBuffer( size - HEADER_SIZE,
d972 2
a973 2
									             nStartPos,
									             nEndPos,
d982 1
a982 1
							if (nEndPos > cur_block->block->EndOffset)
d989 2
a990 2
							//	Write uncompressed data to file
								lenWritten = m_pReqPartFile->WriteToBuffer( size - HEADER_SIZE,
d992 2
a993 2
								             nStartPos,
								             nEndPos,
d1015 1
a1015 1
		//	These checks only need to be done if any data was written
d1028 1
a1028 1
				if (!m_pendingBlocksList.IsEmpty() && nEndPos == cur_block->block->EndOffset)
d1056 1
a1056 1

d1355 1
a1355 1
		m_uPartCount = 0;	//SyruS (0.29c)
d1357 1
a1357 1
		m_uLastPartAsked = 0xffff; //jicxicmic
a1358 1
	//	#zegzav:pastcomment (BEGIN)
d1363 1
a1363 2
	//	#zegzav:pastcomment (END)
	//	find current file position in sourceslosts
@


1.126
log
@Updated configurations, added VS2002 build config, continuing new sockets.
@
text
@d47 1
a47 1
	//--- xrmb:seetheneed ---
d49 1
a49 1
	//--- :xrmb ---
d51 1
a51 1
	uint32 filesize = (reqfile) ? reqfile->GetFileSize() : 1;
d57 1
a57 1
	if (reqfile)
d59 1
a59 1
		if (!onlygreyrect && reqfile && m_abyPartStatus)
d69 1
a69 1
			for (uint32 i = 0;i < m_nPartCount;i++)
d71 1
a71 1
				//--- xrmb:seetheneed --- & Cax2 graphic glitch fix
d73 1
a73 1
				if (PARTSIZE*(i + 1) > filesize)
d78 1
a78 1
				if (m_abyPartStatus[i])
d80 1
a80 1
					// do i have it ?
d82 5
a86 5
					if (reqfile->IsComplete(PARTSIZE*i, PARTSIZE*(i + 1) - 1))
						statusBar.FillRange(PARTSIZE*i, uEnd, crBoth);
					else if (isDLing && m_nLastBlockOffset < uEnd &&
					         m_nLastBlockOffset >= PARTSIZE*i)
						statusBar.FillRange(PARTSIZE*i, uEnd, crPending);
d88 1
a88 1
						statusBar.FillRange(PARTSIZE*i, uEnd, crNextPending);
d90 1
a90 1
						statusBar.FillRange(PARTSIZE*i, uEnd, crClientOnly);
d93 2
a94 2
					if (reqfile->IsComplete(PARTSIZE*i, PARTSIZE*(i + 1) - 1))
						statusBar.FillRange(PARTSIZE*i, uEnd, crMeOnly);
d96 1
a96 1
				//--- :xrmb --- & Cax2 graphic glitch fix
d118 1
a118 1
		return ((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()) && (GetUserPort() == tocomp->GetUserPort()));
d120 1
a120 1
		return ((GetUserID() == tocomp->GetUserID() && GetUserPort() == tocomp->GetUserPort()) || (GetIP() && (GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())) );
d134 1
a134 1
	if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()) )
d139 2
a140 2
		// Added by Tarod [Dnowo]
		// Vorlost halved the code: asking time random only at the beginning for each new source
d159 1
a159 1
		//g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
d173 1
a173 1
	unsigned int nTimePassedFile = dwTickCount - reqfile->GetLastAnsweredTime();
d176 23
a198 23
	return (
	           //if client has the correct extended protocol
	           ExtProtocolAvailable() && m_bySourceExchangeVer >= 1 &&
	           //AND if we can send sources
	           !g_eMuleApp.m_pGlobPrefs->IsDisabledXS() &&
	           //AND if we need more sources
	           g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > reqfile->GetSourceCount() &&
	           //AND if...
	           (
	               //source is not complete and file is rare, allow once every 10 minutes
	               ( !m_bCompleteSource &&
	                 ( reqfile->GetSourceCount() - reqfile->GetValidSourcesCount() <= RARE_FILE / 4 ||
	                   reqfile->GetSourceCount() <= RARE_FILE * 2
	                 ) &&
	                 (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK)
	               ) ||
	               // otherwise, allow every 90 minutes, but only if we haven't
	               //   asked someone else in last 10 minutes
	               ( (bNeverAskedBefore || nTimePassedClient > (unsigned)(SOURCECLIENTREASK * reqfile->GetCommonFilePenalty())) &&
	                 (nTimePassedFile > SOURCECLIENTREASK)
	               )
	           )
	       );
d204 1
a204 1

d209 1
a209 1
	ASSERT(reqfile != NULL);
d211 2
a212 2
	if (!reqfile)
		return ;
d216 1
a216 1
	CSafeMemFile data1(16 + 16);
d218 1
a218 1
	data1.Write(reqfile->GetFileHash(), 16);
d220 2
a221 2
	if ( GetExtendedRequestsVersion() > 0 )
		reqfile->WritePartStatus(&data1);
d223 2
a224 2
	if ( GetExtendedRequestsVersion() > 1 )
		reqfile->WriteCompleteSourcesCount(&data1); //netwolf: complete sources (zegzav) 13.05.03
d226 1
a226 1
	Packet* packet = new Packet(&data1);
d228 1
a228 1
	packet->m_eOpcode = OP_FILEREQUEST;
d230 1
a230 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d234 1
a234 1
	m_pRequestSocket->SendPacket(packet, true);
d237 1
a237 1
	//AddDebugLogLine(false,"File Status: %s was requested from %s", reqfile->GetFileName(), this->GetUserName());
d239 1
a239 1
	CSafeMemFile data2(16);
d241 1
a241 1
	data2.Write(reqfile->GetFileHash(), 16);
d243 1
a243 1
	packet = new Packet(&data2);
d245 1
a245 1
	packet->m_eOpcode = OP_SETREQFILEID;
d247 1
a247 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->m_dwSize);
d251 1
a251 1
	m_pRequestSocket->SendPacket(packet, true);
d255 1
a255 1
	if ( IsEmuleClient() )
d257 1
a257 1
		SetRemoteQueueFull( true );
d261 12
a272 5
	if (g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() < reqfile->GetSourceCount() || g_eMuleApp.m_pGlobPrefs->IsDisabledXS())
		return ;

	if (g_eMuleApp.m_pGlobPrefs->DisableXSUpTo() && g_eMuleApp.m_pGlobPrefs->XSUpTo() < reqfile->GetSourceCount()) // DonGato - Disable XS for up to X sources
		return ;
d276 6
a281 4
		reqfile->SetLastAnsweredTimeTimeout();
		Packet* packet = new Packet(OP_REQUESTSOURCES, 16, OP_EMULEPROT);
		md4cpy(packet->m_pcBuffer, reqfile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(packet->m_dwSize);
d283 1
a283 2

		m_pRequestSocket->SendPacket(packet, true, true);
d285 1
a285 1
		//AddDebugLogLine(false, "Send:Source Request User(%s) File(%s)", GetUserName(), reqfile->GetFileName());
d290 1
a290 1

d304 1
a304 1
	//netwolf: patch 'fix disappearing reqfile' START (taab)
d306 1
a306 1
	if (!reqfile)
d308 1
a308 1
		CKnownFile* locreqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(cfilehash);
d311 1
a311 1
			reqfile = (CPartFile *)locreqfile;
d314 1
a314 1
	//netwolf END
d316 1
a316 1
	if (reqfile == NULL)	//SyruS (0.29c)
d318 2
a319 2
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileInfo; reqfile==NULL)"));
		return ;
d321 2
a322 2
	if (md4cmp(cfilehash, reqfile->GetFileHash()))
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileInfo; reqfile!=cfilehash)"));
d334 1
a334 1
	//netwolf: patch 'fix disappearing reqfile part2' START (taab)
d336 1
a336 1
	if (!reqfile)
d338 1
a338 1
		CKnownFile* locreqfile = g_eMuleApp.m_pSharedFilesList->GetFileByID(cfilehash);
d341 1
a341 1
			reqfile = (CPartFile *)locreqfile;
d344 1
a344 1
	//newolf END
d346 1
a346 1
	if ( (!reqfile) || md4cmp(cfilehash, reqfile->GetFileHash()))
d348 1
a348 1
		//delete data;	//mf	//TwoBottle Mod
d350 2
a351 2
		if (reqfile == NULL)	//SyruS (0.29c)
			AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; reqfile==NULL)"));
d353 1
a353 1
			AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; reqfile!=cfilehash)"));
d355 1
a355 1
		return ;
d358 1
a358 1
	data.Read(&m_nPartCount, 2);
d360 1
a360 1
	if (m_abyPartStatus)
d362 2
a363 2
		delete[] m_abyPartStatus;
		m_abyPartStatus = NULL;
d368 1
a368 1
	if (!m_nPartCount)
d370 3
a372 3
		m_nPartCount = reqfile->GetPartCount();
		m_abyPartStatus = new uint8[m_nPartCount];
		memset2(m_abyPartStatus, 1, m_nPartCount);
d378 1
a378 1
		if (reqfile->GetPartCount() != m_nPartCount)
d380 2
a381 2
			//delete data;	//mf	//TwoBottle Mod
			m_nPartCount = 0;	//SyruS (0.29c)
d387 1
a387 1
		m_abyPartStatus = new uint8[m_nPartCount];
d390 1
a390 1
		while (done != m_nPartCount)
d397 2
a398 2
				m_abyPartStatus[done] = ((toread >> i) & 1) ? 1 : 0;
				// netwolf: zegzav completesrc - BEGIN
d400 1
a400 1
				if (m_abyPartStatus[done])
d404 1
a404 1
					if (!reqfile->IsComplete(done*PARTSIZE, ((done + 1)*PARTSIZE) - 1))
d408 1
a408 1
				// netwolf: zegzav completesrc - END
d411 1
a411 1
				if (done == m_nPartCount)
d416 2
a417 2
		// netwolf: zegzav completesrc - BEGIN
		if (nCompleteSourcePart == m_nPartCount)
d420 1
a420 1
		// netwolf: zegzav completesrc - END
d424 2
a425 2
	reqfile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
	//reqfile->UpdateAvailablePartsCount();
d431 1
a431 1
	else if (reqfile->m_bHashSetNeeded)
d433 2
a434 2
		Packet* packet = new Packet(OP_HASHSETREQUEST, 16);
		md4cpy(packet->m_pcBuffer, reqfile->GetFileHash());
d442 1
a442 1
		reqfile->m_bHashSetNeeded = false;
d447 1
a447 1
		//delete data;	//TwoBottle Mod
d449 1
a449 1
		data1.Write(reqfile->GetFileHash(), 16);
d459 1
a459 1
		//AddDebugLogLine(false,"File Upload: %s was requested from %s", reqfile->GetFileName(), this->GetUserName());
d462 1
a462 1
	//delete data;	//TwoBottle Mod
d474 2
a475 2
	// check NNS list
	if (m_OtherNoNeeded_list.Find(file) != 0)
d478 2
a479 2
	//check Other list
	if (m_OtherRequests_list.Find(file) != 0)
d482 1
a482 1
	m_OtherRequests_list.AddTail(file);
d501 1
a501 1
			reqfile->AddDownloadingSource(this);
d503 1
a503 1
			if ( IsEmuleClient() )
d510 1
a510 1
			m_dwLastTimeCalculatedDR = ::GetTickCount();	//eklmn: new DL measurements system
d512 1
a512 1
			//v2: eklmn(khaos): update stattistical variables (start time of DL & minimal amount)
d519 1
a519 1
		else if (m_eDownloadState == DS_DOWNLOADING )
d521 1
a521 1
			// -khaos--+++> Extended Statistics (Successful/Failed Download Sessions)
d523 1
a523 1
			if ( m_bTransferredDownMini && byNewState != DS_ERROR )
d530 1
a530 1
			// <-----khaos-
d532 1
a532 1
			reqfile->RemoveDownloadingSource(this);
d536 1
a536 1
			for (POSITION pos = m_DownloadBlocks_list.GetHeadPosition();pos != 0;m_DownloadBlocks_list.GetNext(pos))
d538 3
a540 3
				Requested_Block_Struct* cur_block = m_DownloadBlocks_list.GetAt(pos);
				reqfile->RemoveBlockFromList(cur_block->StartOffset, cur_block->EndOffset);
				delete m_DownloadBlocks_list.GetAt(pos);
d543 1
a543 1
			m_DownloadBlocks_list.RemoveAll();
d545 1
a545 1
			for (POSITION pos = m_PendingBlocks_list.GetHeadPosition();pos != 0;m_PendingBlocks_list.GetNext(pos))
d547 1
a547 1
				Pending_Block_Struct *pending = m_PendingBlocks_list.GetAt(pos);
d549 2
a550 2
				if (reqfile)
					reqfile->RemoveBlockFromList(pending->block->StartOffset, pending->block->EndOffset);
d554 1
a554 1
				// Not always allocated
d564 2
a565 2
			m_PendingBlocks_list.RemoveAll();
			m_nDownDataRate = 0;
d569 2
a570 2
				if (m_abyPartStatus)
					delete[] m_abyPartStatus;
d572 1
a572 1
				m_abyPartStatus = 0;
d574 1
a574 1
				m_nPartCount = 0;	//SyruS (0.29c)
d577 1
a577 1
			m_LastPartAsked = 0xffff; //jicxicmic
d588 1
a588 1
		// switch the state & update info
d601 1
a601 1
	if ( (!reqfile) || md4cmp(packet, reqfile->GetFileHash()))
d606 1
a606 1
	if (reqfile->LoadHashsetFromFile(data1, true))
d610 1
a610 1
		reqfile->m_bHashSetNeeded = true;
d617 1
a617 1
	data2.Write(this->reqfile->GetFileHash(), 16);
d637 2
a638 2
	if (!reqfile)
		return ;
d640 2
a641 2
	//jicxicmic - get blocks from the same chunk first
	if (m_DownloadBlocks_list.IsEmpty())
d643 1
a643 1
		// check if part was completed
d645 3
a647 3
		if (reqfile->GetBytesInPart(m_LastPartAsked, true, true) == 0
		    || reqfile->IsCorruptedPart(m_LastPartAsked))
			m_LastPartAsked = 0xffff; //ICR 2.10
d649 3
a651 3
		//first time we ask?
		if (m_LastPartAsked == 0xffff)
			m_LastPartAsked = reqfile->GetNextRequestedBlock(this);
d653 1
a653 1
		// Barry - instead of getting 3, just get how many is needed
d656 1
a656 1
		savedcount = count = 3 - m_PendingBlocks_list.GetCount();
d660 1
a660 1
		if (m_LastPartAsked != 0xffff)		//previous active part ?
d662 1
a662 1
			reqfile->GetGapsInPart(this, m_LastPartAsked, toadd, &count);
d666 1
a666 1
				// check if part was completed
d668 3
a670 3
				if (reqfile->GetBytesInPart(m_LastPartAsked, true, true) == 0
				    || reqfile->IsCorruptedPart(m_LastPartAsked))
					m_LastPartAsked = 0xffff; //ICR 2.10
d672 1
a672 1
				m_LastPartAsked = reqfile->GetNextRequestedBlock(this); //get next part
d674 1
a674 1
				if (m_LastPartAsked != 0xffff)		//more parts ?
d677 1
a677 1
					reqfile->GetGapsInPart(this, m_LastPartAsked, toadd, &count);
d688 1
a688 1
			m_DownloadBlocks_list.AddTail(toadd[i]);
d694 2
a695 2
	// Barry - Why are unfinished blocks requested again, not just new ones?
	while (m_PendingBlocks_list.GetCount() < 3 && !m_DownloadBlocks_list.IsEmpty())
d697 2
a698 2
		Pending_Block_Struct* pblock = new Pending_Block_Struct;
		pblock->block = m_DownloadBlocks_list.RemoveHead();
d701 1
a701 1
		m_PendingBlocks_list.AddTail(pblock);
d704 1
a704 1
	if (m_PendingBlocks_list.IsEmpty())
d706 1
a706 1
		Packet* packet = new Packet(OP_CANCELTRANSFER);
d712 1
a712 1
		//SetDownloadState(DS_NONEEDEDPARTS);
d719 1
a719 1
		return ;
d724 2
a725 2
	data.Write(reqfile->GetFileHash(), 16);
	POSITION pos = m_PendingBlocks_list.GetHeadPosition();
d733 2
a734 2
			block = m_PendingBlocks_list.GetAt(pos)->block;
			m_PendingBlocks_list.GetNext(pos);
d741 1
a741 1
	pos = m_PendingBlocks_list.GetHeadPosition();
d747 2
a748 2
			block = m_PendingBlocks_list.GetAt(pos)->block;
			m_PendingBlocks_list.GetNext(pos);
d784 1
a784 1
	// Ignore if no data required
d787 1
a787 1
		return ;
d791 1
a791 1
	// Update stats
d794 1
a794 1
	// Read data from packet
d801 2
a802 2
	// Check that this data is for the correct file
	if ( (!reqfile) || md4cmp(packet, reqfile->GetFileHash()))
d807 1
a807 1
	// Find the start & end positions, and size of this chunk of data
d820 1
a820 1
		usedcompressiondown = true;
d825 2
a826 2
	// Check that packet size matches the declared data size + header size (24)
	if ( size != ((nEndPos - nStartPos) + HEADER_SIZE))
d829 4
a832 4
	// -khaos--+++>
	// Extended statistics information based on which client and remote port sent this data.
	// The new function adds the bytes to the grand total as well as the given client/port.
	// bFromPF is not relevant to downloaded data.  It is purely an uploads statistic.
d835 2
a836 2
	// g_eMuleApp.UpdateReceivedBytes(size - HEADER_SIZE);
	// <-----khaos-
d838 1
a838 1
	// Move end back one, should be inclusive
d841 1
a841 1
	credits->AddDownloaded(size - HEADER_SIZE, this->GetIP());
d845 1
a845 1
	m_nTransferredDown += DownDataRateMS;
d847 1
a847 1
	m_TransferredInLastPeriod += DownDataRateMS;
d849 1
a849 1
	// Loop through to find the reserved block that this is within
d854 1
a854 1
	for (pos1 = m_PendingBlocks_list.GetHeadPosition(); ( pos2 = pos1 ) != NULL;)
d856 2
a857 2
		cur_block = m_PendingBlocks_list.GetNext( pos1 );
		//Cax2: I'm not happy with this whole if clause
d861 1
a861 1
			// Found reserved block
d863 2
a864 2
			// Remember this start pos, used to draw part downloading in list
			m_nLastBlockOffset = nStartPos;
d866 2
a867 2
			// Occasionally packets are duplicated, no point writing it twice
			// This will be 0 in these cases, or the length written otherwise
d870 1
a870 1
			// Handle differently depending on whether packed or not
d874 6
a879 6
				// Write to disk (will be buffered in part file class)
				lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
				                                    (BYTE *) (packet + HEADER_SIZE),
				                                    nStartPos,
				                                    nEndPos,
				                                    cur_block->block );
d883 1
a883 1
				// Create space to store unzipped data, the size is only an initial guess, will be resized in unzip() if not big enough
d885 1
a885 1
				// Don't get too big
d892 1
a892 1
				// Try to unzip the packet
d897 1
a897 1
					// Write any unzipped data to disk
d901 1
a901 1
						// Use the current start and end positions for the uncompressed data
d905 1
a905 1
						if (nBlockSize*25 < lenUnzipped)
d908 1
a908 1
							m_LastPartAsked = 0xFFFF;	//eklmn: feature(00): ICR (reset choosen part in case suspicious block)
d919 2
a920 2
							AddDebugLogLine(true, _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), reqfile->GetFileName(), cur_block->block->StartOffset / PARTSIZE, cur_block->block->StartOffset / EMBLOCKSIZE, lenUnzipped, nBlockSize);
							AddDebugLogLine(false, _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_pszUsername, (uint8)m_dwUserIP, (uint8)(m_dwUserIP >> 8), (uint8)(m_dwUserIP >> 16), (uint8)(m_dwUserIP >> 24), GetUserPort(), buffer2);
d922 1
a922 1
							if (reqfile->GetDiscardSuperCompressed())
d924 2
a925 2
								//--- (un)comment the block-dropping as you wish---
								reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->StartOffset + 1);
d942 1
a942 1
							// BavarianSnail
d947 2
a948 2
									AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG, reqfile->GetFileName(), 666);
									reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d952 6
a957 6
									// Write uncompressed data to file
									lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
									                                    unzipped,
									                                    nStartPos,
									                                    nEndPos,
									                                    cur_block->block);
d961 1
a961 1
							//- BavarianSnail
d965 1
a965 1
							if ( nEndPos > cur_block->block->EndOffset)
d967 2
a968 2
								AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG, reqfile->GetFileName(), 666);
								reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d972 6
a977 6
								// Write uncompressed data to file
								lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
								                                    unzipped,
								                                    nStartPos,
								                                    nEndPos,
								                                    cur_block->block );
d984 2
a985 2
					AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG, reqfile->GetFileName(), result);
					reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d998 1
a998 1
			// These checks only need to be done if any data was written
d1001 1
a1001 1
				//m_nTransferredDown += lenWritten;
d1004 6
a1009 6
				// If finished reserved block
				// in this place becouse reqfile->WriteToBuffer was called
				// cur_block can be already deleted (if file was completed)
				// so to avoid access violation here we will check
				// m_PendingBlocks_list for emptyness....possibly there is
				// better check [TwoBottle Mod]
d1011 1
a1011 1
				if (!m_PendingBlocks_list.IsEmpty() && nEndPos == cur_block->block->EndOffset)
d1013 1
a1013 1
					m_PendingBlocks_list.RemoveAt(pos2);
d1015 1
a1015 1
					reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
d1017 1
a1017 1
					// Not always allocated
d1027 1
a1027 1
					// Request next block
d1032 2
a1033 2
			// Stop looping and exit method
			return ;
d1044 1
a1044 1
	// Save some typing
d1047 1
a1047 1
	// Is this the first time this block has been unzipped
d1051 1
a1051 1
		// Create stream
d1055 1
a1055 1
		// Initialise stream values
d1060 1
a1060 1
		// Set output data streams, do this here to avoid overwriting on recursive calls
d1064 1
a1064 1
		// Initialise the z_stream
d1071 1
a1071 1
	// Use whatever input is provided
d1076 1
a1076 1
	// Only set the output if not being called recursively
d1083 1
a1083 1
	// Try to unzip the data
d1086 1
a1086 1
	// Is zip finished reading all currently available input and writing all generated output
d1089 1
a1089 1
		// Finish up
d1099 1
a1099 1
		// Got a good result, set the size to the amount unzipped in this call (including all recursive calls)
d1110 1
a1110 1
		// Output array was not big enough, call recursively until there is enough space
d1112 1
a1112 1
		// What size should we try next
d1118 1
a1118 1
		// Copy any data that was successfully unzipped to new array
d1129 1
a1129 1
		// Position stream output to correct place in new array
d1134 1
a1134 1
		// Try again
d1139 2
a1140 2
		// All available input has been processed, everything ok.
		// Set the size to the amount unzipped in this call (including all recursive calls)
d1143 2
a1144 2
		//Cax2 - not needed here, it stops downloads prematurely
		//inflateEnd(zS);
d1148 1
a1148 1
		// Should not get here unless input data is corrupt
d1150 1
a1150 1
		//DebugBreak(); I removed this so that we could let the client run for more the five minutes.. Barry needs to see if there is or isn't a preoblem here..
d1176 1
a1176 1
			Packet* packet = new Packet(OP_CANCELTRANSFER);
d1185 2
a1186 2
		m_nDownDataRate = 0;
		//	No more than one message/10 sec
d1196 1
a1196 1
		uint32 time_diff_ms = dwCurTick - m_dwLastTimeCalculatedDR;
d1198 7
a1204 7
		//update average sum
		m_Client_Sum_DL_DR_over_last_N_measurements += m_TransferredInLastPeriod;
		m_Client_Sum_DL_tick_over_last_N_measurements += time_diff_ms;
		// update a lists
		m_Average_DL_DR_list.push_front(m_TransferredInLastPeriod);
		m_Average_DL_tick_list.push_front(time_diff_ms);
		// check lists size
d1206 1
a1206 1
		while (m_Average_DL_tick_list.size() > 500)
d1208 4
a1211 4
			m_Client_Sum_DL_DR_over_last_N_measurements -= m_Average_DL_DR_list.back();
			m_Average_DL_DR_list.pop_back();
			m_Client_Sum_DL_tick_over_last_N_measurements -= m_Average_DL_tick_list.back();
			m_Average_DL_tick_list.pop_back();
d1214 2
a1215 2
		// calculate average trasfered data (bytes)
		uint64 AverageTransferredData = m_Client_Sum_DL_DR_over_last_N_measurements / m_Average_DL_DR_list.size();
d1217 2
a1218 2
		// calculate average time period between measuremets (ms)
		uint64 AverageTransferTimePeriod = m_Client_Sum_DL_tick_over_last_N_measurements / m_Average_DL_tick_list.size();
d1220 1
a1220 1
		// calculate a DL rate (b/s)
d1222 1
a1222 1
			m_nDownDataRate = 1000 * AverageTransferredData / AverageTransferTimePeriod;
d1224 1
a1224 1
			m_nDownDataRate = 0;
d1226 2
a1227 2
		//update a time & reset data transferred over last period
		m_dwLastTimeCalculatedDR = dwCurTick;
d1229 1
a1229 1
		m_TransferredInLastPeriod = 0;
d1232 1
a1232 1
	//Cax2 - the gain was minimal, not worth keeping that...
d1235 1
a1235 1
	return m_nDownDataRate;
d1248 1
a1248 1
	for (int i = 0;i < m_nPartCount;i++)
d1265 2
a1266 2
	m_nDifferenceQueueRank = (nr - m_nRemoteQueueRank); //cendre-eau
	m_nRemoteQueueRank = nr;
d1277 1
a1277 1
	// check if we are downloading something from client
d1290 1
a1290 1
	// check: target file is specified? if is not, then find another one
d1293 1
a1293 1
		// check: does client have another files?
d1295 1
a1295 1
		if (!m_OtherRequests_list.IsEmpty())
d1297 1
a1297 1
			for (cur_FilePos = m_OtherRequests_list.GetHeadPosition();cur_FilePos != 0;m_OtherRequests_list.GetNext(cur_FilePos))
d1299 2
a1300 2
				cur_file = m_OtherRequests_list.GetAt(cur_FilePos);
				// get first high priority files
d1302 2
a1303 2
				if (cur_file != reqfile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(cur_file)
				    && (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) )
d1305 1
a1305 1
					// check: is new file in NNS-list?
d1307 1
a1307 1
					if (!bIgnoreNoNeeded || m_OtherNoNeeded_list.Find(cur_file) == 0 )
d1318 1
a1318 1
		SwapToPos = m_OtherRequests_list.Find(SwapTo); // otherwise get position with .Find()
d1320 1
a1320 1
	// now let's swap the file to another
d1324 1
a1324 1
		// to prevent loop swaping remember NNS-Part
d1326 2
a1327 2
		if (GetDownloadState() == DS_NONEEDEDPARTS && !m_OtherNoNeeded_list.Find(reqfile))
			m_OtherNoNeeded_list.AddTail(reqfile);
d1329 1
a1329 1
		// switch state to NONE
d1332 1
a1332 1
		if (m_abyPartStatus)
d1334 2
a1335 2
			delete[] m_abyPartStatus;
			m_abyPartStatus = 0;
d1338 1
a1338 1
		m_nPartCount = 0;	//SyruS (0.29c)
d1340 1
a1340 1
		m_LastPartAsked = 0xffff; //jicxicmic
d1342 3
a1344 3
		// #zegzav:pastcomment (BEGIN)
		// add to past comment
		reqfile->AddPastComment(this);
d1347 3
a1349 3
		// #zegzav:pastcomment (END)
		// find current file position in sourceslosts
		cur_FilePos = reqfile->m_srcLists[sourcesslot].Find(this);
d1352 1
a1352 1
			reqfile->m_srcLists[sourcesslot].RemoveAt(cur_FilePos); // remove current file
d1354 2
a1355 2
		// add them in A4AF list
		reqfile->m_A4AFsrcList.AddTail(this);
d1357 2
a1358 2
		// add old file to m_OtherRequests_list
		m_OtherRequests_list.AddTail(reqfile);
d1360 2
a1361 2
		// let's update current information for the removed file
		reqfile->NewSrcPartsInfo(); // eklmn: changes(00): NewSrcPartsInfo & UpdateAvailablePartsCount merged (CPU load)
d1363 2
a1364 2
		// update download list (old file update)
		reqfile->UpdateDisplayedInfo();
d1366 1
a1366 1
		reqfile = 0;	//reset before delete m_abyPartStatus
d1368 2
a1369 2
		// actual switch
		reqfile = SwapTo;
d1371 2
a1372 2
		// remove new file from OtherRequests list
		m_OtherRequests_list.RemoveAt(SwapToPos);
d1374 1
a1374 1
		// remove current source from A4AF list in new file
d1380 2
a1381 2
		// to prevent loop swaping remember NNS-Part
		cur_FileNNSPos = m_OtherNoNeeded_list.Find(SwapTo);
d1384 1
a1384 1
			m_OtherNoNeeded_list.RemoveAt(cur_FileNNSPos);
d1386 3
a1388 3
		// add to souceslots
		if (!SwapTo->m_srcLists[sourcesslot].Find(this))
			SwapTo->m_srcLists[sourcesslot].AddTail(this);
d1390 1
a1390 1
		// remove from past comment
d1393 1
a1393 1
		// Update info for target file
d1396 1
a1396 1
		// update download list (new file update)
d1399 1
a1399 1
		// now update the client item
d1425 1
a1425 1
	//SyruS (0.29a) avoid premature deletion of 'this' client
d1448 1
a1448 1
	ASSERT ( reqfile );
d1450 2
a1451 2
	if (!reqfile || m_bUDPPending)
		return ;
d1453 1
a1453 1
	// Maverick Disable UDP when connecting to a PROXY
d1458 2
a1459 2
	if (m_byEmuleVersion >= 0x23 && m_nUDPPort != 0 && g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0 &&
	    !g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() && !(m_pRequestSocket && m_pRequestSocket->IsConnected()) && (!proxy.m_bUseProxy))
d1462 1
a1462 1
		//don't use udp to ask for sources
d1465 1
a1465 1
			return ;
d1469 1
a1469 1
		// netwolf: complete sources UDP - BEGIN
d1475 1
a1475 1
		// netwolf: complete sources UDP - END
d1478 1
a1478 1
		md4cpy(response->m_pcBuffer, reqfile->GetFileHash());
d1480 1
a1480 1
		// netwolf: complete sources UDP - BEGIN
d1483 1
a1483 1
			uint16 completecount = reqfile->GetCompleteSourcesCount();
d1487 1
a1487 1
		// netwolf: complete sources UDP - END
d1498 1
a1498 1
// Barry - Sets string to show parts downloading, eg NNNYNNNNYYNYN
d1503 1
a1503 1
	parts.resize(m_nPartCount);
d1505 2
a1506 2
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition();pos;)
		parts[m_PendingBlocks_list.GetNext(pos)->block->StartOffset / PARTSIZE] = true;
d1516 1
a1516 1
// New functions by Mr.Fry
d1523 1
a1523 1
	if (m_abyPartStatus != NULL && m_nPartCount > 0)
d1525 2
a1526 2
		for (int i = 0; i < m_nPartCount ; i++)
			if (m_abyPartStatus[i] && !reqfile->IsComplete(i*PARTSIZE, ((i + 1)*PARTSIZE) - 1))
d1529 1
a1529 1
		//TRACE("Counted %u Chunks (parts) that %s has and I need (to download)",count,GetUserName());
@


1.125
log
@no message
@
text
@d1165 1
a1169 1
#ifdef OLD_SOCKETS_ENABLED
a1171 1
#endif //OLD_SOCKETS_ENABLED
d1174 1
@


1.124
log
@no message
@
text
@d1425 1
a1425 1
		if (m_pRequestSocket)
@


1.123
log
@More fixes for a compiler bug in VS2002. Compile with -D VS2002 if you're using it.
@
text
@d62 1
a62 1
			bool isDLing = (m_nDownloadState == DS_DOWNLOADING);
d134 1
a134 1
	if (g_eMuleApp.m_pListenSocket->TooManySockets() && !(socket && socket->IsConnected()) )
d234 1
a234 1
	socket->SendPacket(packet, true);
d251 1
a251 1
	socket->SendPacket(packet, true);
d275 1
a275 1
		socket->SendPacket(packet, true, true);
d430 1
a430 1
		socket->SendPacket(packet, true, true);
d447 1
a447 1
		socket->SendPacket(packet, true, true);
d489 1
a489 1
	if (m_nDownloadState != byNewState)
d511 1
a511 1
		else if (m_nDownloadState == DS_DOWNLOADING )
d526 1
a526 1
			m_nDownloadState = byNewState;
d573 2
a574 2
			if (socket && byNewState != DS_ERROR)
				socket->DisableDownloadLimit();
d581 1
a581 1
		m_nDownloadState = byNewState;
d615 1
a615 1
	socket->SendPacket(opacket, true, true);
d702 1
a702 1
		socket->SendPacket(packet, true, true);
d751 1
a751 1
	socket->SendPacket(packet, true, true);
d1165 1
a1165 1
		if (socket != NULL)
d1171 1
a1171 1
			socket->SendPacket(packet, true, true);
d1425 1
a1425 1
		if (socket)
d1451 1
a1451 1
	    !g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() && !(socket && socket->IsConnected()) && (!proxy.m_bUseProxy))
a1504 11
#ifndef ASYNC_UI_UPDATES
	DWORD curTick = ::GetTickCount();

	if (force || curTick - m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE + (uint32)(rand()*1000 / RAND_MAX))
	{
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateSourceItem(this);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlClientList.UpdateClient(this);
		m_lastRefreshedDLDisplay = curTick;
	}

#else 
a1505 1
#endif ASYNC_UI_UPDATES
@


1.122
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d1510 1
a1510 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.UpdateItem(this);
@


1.121
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d1510 2
a1511 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.RefreshClient(this);
d1516 1
a1516 5
	//	MOREVIT - I'm betting we don't need the throttle if we use the message queue
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.PostMessage(WM_DL_UPDATESOURCEITEM, 0, reinterpret_cast<LPARAM>(this));

	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.PostMessage(WM_CL_REFRESHCLIENT, 0, reinterpret_cast<LPARAM>(this));

@


1.120
log
@Formatting, comments, and name changes.
@
text
@d364 1
a364 1
		memset(m_abyPartStatus, 1, m_nPartCount);
@


1.119
log
@Formatting, comments, and name changes.
@
text
@d30 1
a30 1
static char THIS_FILE[]=__FILE__;
d36 1
a36 1
//	which are mainly used for downloading functions 
d38 2
a39 2
void CUpDownClient::DrawStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool  bFlat)
{ 
d42 5
a46 5
	const COLORREF crBoth=(bFlat) ? RGB(0, 150, 0) : RGB(0, 192, 0);	//Cax2 - same green used for files & clients 
	const COLORREF crNeither=(bFlat) ? RGB(224, 224, 224) : RGB(240, 240, 240); 
	const COLORREF crClientOnly=(bFlat) ? RGB(0, 0, 0) : RGB(95, 95, 95); 
	const COLORREF crPending = RGB(255,208,0);
	const COLORREF crNextPending = RGB(255,255,100);
d48 1
a48 1
	const COLORREF crMeOnly = RGB(190,190,255); 
d50 2
a51 2
	
	uint32 filesize=(reqfile)? reqfile->GetFileSize():1;
d57 1
a57 1
	if(reqfile)
d59 2
a60 1
		if (!onlygreyrect && reqfile && m_abyPartStatus) { 
d62 2
a63 1
			bool isDLing=(m_nDownloadState == DS_DOWNLOADING);
d66 1
d68 1
d70 1
a70 1
			{ 	
d72 8
a79 5
				if (PARTSIZE*(i+1) > filesize) 
					uEnd = filesize; 
				else 
					uEnd = PARTSIZE*(i+1); 
				if (m_abyPartStatus[i]){ //they have this part
d81 6
a86 5
					if  (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))
						statusBar.FillRange(PARTSIZE*i,  uEnd, crBoth); 
					else if (isDLing && m_nLastBlockOffset < uEnd && 
														m_nLastBlockOffset >= PARTSIZE*i)
							statusBar.FillRange(PARTSIZE*i,  uEnd, crPending);      
d89 1
a89 1
	    			else
d93 3
a95 2
					if (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1)) 
						statusBar.FillRange(PARTSIZE*i,  uEnd, crMeOnly); 
d97 2
a98 2
			} 
   		} 
d100 2
a101 1
   	statusBar.Draw(dc, rect->left, rect->top, bFlat); 
d104 1
a104 1
} 
d107 2
a108 1
bool CUpDownClient::Compare(CUpDownClient* tocomp){
d113 2
a114 1
	if(HasValidHash() && tocomp->HasValidHash())
d116 1
d118 1
a118 1
		return ((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP())&& (GetUserPort() == tocomp->GetUserPort()));
d133 1
d136 1
a136 1
		if (GetDownloadState() != DS_TOOMANYCONNS &&  GetDownloadState() != DS_DOWNLOADING)
d139 4
a142 4
		// Added by Tarod [Dnowo] 
		// Vorlost halved the code: asking time random only at the beginning for each new source 
		if (m_dwLastAskedTime == 0) 
			m_dwLastAskedTime = GetTickCount() - FILEREASKTIME + (uint32)ROUND(((float)rand() / RAND_MAX) * 300000); 
d146 1
d150 1
d152 1
d167 1
a167 1
bool CUpDownClient::IsSourceRequestAllowed() 
d173 1
a173 1
	unsigned int nTimePassedFile   = dwTickCount - reqfile->GetLastAnsweredTime();
d177 20
a196 19
	         //if client has the correct extended protocol
	         ExtProtocolAvailable() && m_bySourceExchangeVer >= 1 &&
			 //AND if we can send sources
			 !g_eMuleApp.m_pGlobPrefs->IsDisabledXS() &&
	         //AND if we need more sources
	         g_eMuleApp.m_pGlobPrefs->GetMaxSourcePerFileSoft() > reqfile->GetSourceCount() &&
	         //AND if...
	         (
	           //source is not complete and file is rare, allow once every 10 minutes
	           ( !m_bCompleteSource &&
	             ( reqfile->GetSourceCount() - reqfile->GetValidSourcesCount() <= RARE_FILE / 4 ||
			       reqfile->GetSourceCount() <= RARE_FILE * 2
			     ) &&
	             (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK)
	           ) ||
	           // otherwise, allow every 90 minutes, but only if we haven't
	           //   asked someone else in last 10 minutes
			   ( (bNeverAskedBefore || nTimePassedClient > (unsigned)(SOURCECLIENTREASK * reqfile->GetCommonFilePenalty())) &&
		         (nTimePassedFile > SOURCECLIENTREASK)
a197 1
	         )
d210 4
a213 2
	if(!reqfile)
		return;
d216 5
a220 3
	CSafeMemFile data1(16+16);
	data1.Write(reqfile->GetFileHash(),16);
	if( GetExtendedRequestsVersion() > 0 )
d222 2
a223 1
	if( GetExtendedRequestsVersion() > 1 )
d225 1
d227 3
a229 1
	packet->m_eOpcode=OP_FILEREQUEST;
d231 1
d233 1
d235 1
d238 1
a238 1
	
d240 3
a242 1
	data2.Write(reqfile->GetFileHash(),16);
d244 1
d246 1
d248 1
d250 3
a252 1
	socket->SendPacket(packet, true);	
d254 3
a256 1
	if ( IsEmuleClient() ){
d258 3
a260 2
	SetRemoteQueueRank(0);
	}	
d262 2
a263 1
		return;
d265 4
a268 2
		return;
	if(IsSourceRequestAllowed()) {
d270 2
a271 2
		Packet* packet = new Packet(OP_REQUESTSOURCES,16,OP_EMULEPROT);
		md4cpy(packet->m_pcBuffer,reqfile->GetFileHash());
d274 2
a275 1
		socket->SendPacket(packet,true,true);
d283 1
a283 1
void CUpDownClient::ProcessFileInfo(char* packet,uint32 size)
d287 1
a287 1
	CSafeMemFile data((BYTE*)packet,size);
d289 1
a289 1
	data.Read(cfilehash,16);
d291 2
a292 2
	data.Read(&namelength,2);	
	data.Read(m_strClientFilename.GetBuffer(namelength),namelength);	//SyruS (0.29c)
d295 1
a295 1
	
d297 1
d301 1
d305 1
d307 2
a308 2
	
	if (reqfile==NULL)	//SyruS (0.29c)
d310 2
a311 2
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileInfo; reqfile==NULL)"));
		return;
d313 2
a314 2
	if (md4cmp(cfilehash,reqfile->GetFileHash()))
		AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileInfo; reqfile!=cfilehash)"));
d319 2
a320 1
void CUpDownClient::ProcessFileStatus(char* packet,uint32 size){
d323 1
a323 1
	CSafeMemFile data((BYTE*)packet,size);	//TwoBottle Mod (exceptions!)
d325 1
a325 1
	data.Read(cfilehash,16);	
d327 1
d331 1
d335 1
d337 3
a339 2
	
	if ( (!reqfile) || md4cmp(cfilehash,reqfile->GetFileHash())){
d341 2
a342 1
		if (reqfile==NULL)	//SyruS (0.29c)
d345 3
a347 2
			AddDebugLogLine(false, GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileStatus; reqfile!=cfilehash)"));
		return;
d349 5
a353 2
	data.Read(&m_nPartCount,2);
	if (m_abyPartStatus){
d356 2
a357 1
    }
d359 1
d364 1
a364 1
		memset(m_abyPartStatus,1,m_nPartCount);
d370 2
a371 1
		if (reqfile->GetPartCount() != m_nPartCount){
d375 2
a376 1
	}
d378 1
a378 1
		uint16 nCompleteSourcePart= 0;	// zegzav:completesrc (add)
d381 3
a383 1
		while (done != m_nPartCount){
d385 5
a389 3
			data.Read(&toread,1);
			for (sint32 i = 0;i != 8;i++){
				m_abyPartStatus[done] = ((toread>>i)&1)? 1:0; 	
d391 1
d395 3
a397 2
					if (!reqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
					bPartsNeeded = true;
d399 1
d402 1
d407 1
d409 3
a411 2
		if (nCompleteSourcePart == m_nPartCount)	
			m_bCompleteSource= true;		
d419 1
a419 1
    CheckForUpPartsInfo(); // obaldin
d423 4
a426 3
	else if (reqfile->m_bHashSetNeeded){
		Packet* packet = new Packet(OP_HASHSETREQUEST,16);
		md4cpy(packet->m_pcBuffer,reqfile->GetFileHash());
d429 1
d432 1
d441 1
a441 1
		data1.Write(reqfile->GetFileHash(),16);
d446 1
d449 1
d453 1
a453 1
		
d463 3
a465 2
	if (file == NULL) return false;
	
d467 2
a468 1
	if (m_OtherNoNeeded_list.Find(file) != 0) return false;	// eklmn: optimization(01): search with Find
d471 2
a472 1
	if (m_OtherRequests_list.Find(file) != 0) return false;	// eklmn: optimization(01): search with Find
d475 1
d477 1
a477 1
	
d491 1
a491 1
		if(byNewState == DS_DOWNLOADING)
d494 1
d497 1
d499 1
d501 1
d503 1
d506 2
a507 1
			m_bTransferredDownMini=false;
d514 1
d519 3
a521 1
			g_eMuleApp.m_pGlobPrefs->Add2DownSAvgTime((::GetTickCount() - m_dwDownStartTime)/1000);
d523 1
a523 1
			
d525 1
d527 3
a529 1
			for (POSITION pos = m_DownloadBlocks_list.GetHeadPosition();pos != 0;m_DownloadBlocks_list.GetNext(pos)){
d531 1
a531 1
				reqfile->RemoveBlockFromList(cur_block->StartOffset,cur_block->EndOffset);
d534 1
d540 1
d543 1
a543 1
				
d545 1
d547 2
a548 1
				if (pending->zStream) {
d552 1
d555 1
d558 3
a560 1
			if (byNewState == DS_NONE){
d563 1
d565 1
d568 1
d570 1
a570 1
			
d572 1
d574 2
a575 1
					socket->DisableDownloadLimit();
d577 1
d582 1
d589 1
a589 1
void CUpDownClient::ProcessHashSet(char* packet,uint32 size)
d593 10
a602 7
	if ( (!reqfile) || md4cmp(packet,reqfile->GetFileHash()))
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+_T(" (ProcessHashSet)"));	
	CSafeMemFile data1((BYTE*)packet,size);
	if (reqfile->LoadHashsetFromFile(data1,true)){
	}
	else{
		reqfile->m_bHashSetNeeded = true;		
d605 1
d607 1
a607 1
	
d609 1
a609 1
	data2.Write(this->reqfile->GetFileHash(),16);
d614 1
d617 1
d630 1
a630 1
		return;
d636 5
a640 3
		if (reqfile->GetBytesInPart(m_LastPartAsked, true, true) == 0 
			|| reqfile->IsCorruptedPart(m_LastPartAsked))  m_LastPartAsked = 0xffff; //ICR 2.10
		
d647 1
d649 3
a651 1
		Requested_Block_Struct** toadd = new Requested_Block_Struct*[count];
d655 1
d659 4
a662 2
				if (reqfile->GetBytesInPart(m_LastPartAsked, true, true) == 0 
					|| reqfile->IsCorruptedPart(m_LastPartAsked))  m_LastPartAsked = 0xffff; //ICR 2.10
d665 1
d671 1
d673 1
d676 1
a676 1
			count=0;
d678 2
a679 1
		for (int i = 0; i < count; i++) {
d682 1
d687 2
a688 1
	while (m_PendingBlocks_list.GetCount() < 3 && !m_DownloadBlocks_list.IsEmpty()){
d695 3
a697 1
	if (m_PendingBlocks_list.IsEmpty()){
d701 2
a702 1
		socket->SendPacket(packet,true,true);
d705 12
a716 8
		if ((GetTickCount()-GetLastAskedTime())>FILEREASKTIME) 
      		AskForDownload(); //<<--enkeyDEV(Ottavio84) modified by lovelace - reask for file 
      		AddDebugLogLine(false, "-> Cancel download from %s due empty block list", this->GetUserName());
		return;
	}
	Packet* packet = new Packet(OP_REQUESTPARTS,40);
	CSafeMemFile data((BYTE*)packet->m_pcBuffer,40);
	data.Write(reqfile->GetFileHash(),16);
d720 5
a724 2
	for (uint32 i = 0; i != 3; i++){
		if (pos){
d727 1
a727 1
			data.Write(&block->StartOffset,4);
d730 1
a730 1
			data.Write(&null,4);
d732 1
d734 5
a738 2
	for (uint32 i = 0; i != 3; i++){
		if (pos){
d741 2
a742 2
			uint32 endpos = block->EndOffset+1;
			data.Write(&endpos,4);
d745 1
a745 1
			data.Write(&null,4);
d747 1
d750 2
a751 1
	socket->SendPacket(packet,true,true);
d757 1
a757 1
/* Barry - Originally this only wrote to disk when a full 180k block 
d760 1
a760 1

d763 1
a763 1

d767 1
a767 1

d777 1
d779 1
a779 1
		return;
d788 1
d790 1
d796 1
a796 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+_T(" (ProcessBlockPacket)"));
d801 1
d803 1
d805 1
d807 1
d815 2
a816 2
		data.Read(&nEndPos,4);
		
d819 1
a819 1
		throw CString(GetResString(IDS_ERR_BADDATABLOCK)+_T(" (ProcessBlockPacket)"));
d826 1
d830 1
a830 1
	// Move end back one, should be inclusive 
d832 3
a834 1
	credits->AddDownloaded(size - HEADER_SIZE,this->GetIP());
d838 1
d840 1
a840 1
	
d843 1
d845 1
d850 1
d856 1
a856 1
			m_nLastBlockOffset = nStartPos;  
d863 1
d867 5
a871 5
				lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE, 
													(BYTE *) (packet + HEADER_SIZE),
													nStartPos,
													nEndPos,
													cur_block->block );
d876 1
a876 1
				uint32 lenUnzipped = (size * 2); 
d878 1
d881 1
d886 1
d890 1
d896 4
a899 3
					
						if(nBlockSize*25 < lenUnzipped) {
							
a900 7
								
				       		CString buffer;
				       		CString buffer2 = _T("");
				       		for (uint16 i = 0;i != 16;i++) {
								buffer.Format(_T("%02X"),GetUserHash()[i]);
								buffer2+=buffer;
				       		}
d902 11
a912 2
							AddDebugLogLine(true,  _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), reqfile->GetFileName(), cur_block->block->StartOffset/PARTSIZE, cur_block->block->StartOffset/EMBLOCKSIZE, lenUnzipped, nBlockSize);
       						AddDebugLogLine(false, _T("username '%s', ip %i.%i.%i.%i:%i, hash %s"), m_pszUsername, (uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), GetUserPort(), buffer2);
d914 2
a915 1
							if(reqfile->GetDiscardSuperCompressed()) {
d917 1
a917 1
								reqfile->RemoveBlockFromList(cur_block->block->StartOffset,cur_block->block->StartOffset+1);
d921 6
a926 4
								buf.Format(_T("%i.%i.%i.%i"), (uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24));
								for(int i=0; i<4; i++) { 
									temp = buf.Tokenize(_T("."),counter);
									ip1 += _tstoi(temp) * pow(256,3-i);
d929 1
a929 1
								g_eMuleApp.m_pIPFilter->AddBannedIPRange(ip1,ip1,1,_T("autobanned"));
d933 1
d935 4
a938 2
							else {
								if(nEndPos > cur_block->block->EndOffset) {
d942 2
a943 1
								else {
d946 4
a949 4
						                                                 unzipped,
						                                                 nStartPos,
						                                                 nEndPos,
						                                                 cur_block->block);
d952 1
d955 3
a957 2
						else {
							if( nEndPos > cur_block->block->EndOffset)
d959 1
a959 1
								AddDebugLogLine(false, IDS_ERR_CORRUPTCOMPRPKG,reqfile->GetFileName(),666);
d964 6
a969 6
						    	// Write uncompressed data to file
						    	lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
																    unzipped,
																    nStartPos,
															 	   nEndPos,
															 	   cur_block->block );
d979 4
a982 2
				try{
					if(unzipped)
d984 4
a987 1
				} catch(...){}
d995 1
a995 1
				
d1002 1
d1010 3
a1012 1
					if (cur_block->zStream) {
d1016 1
d1020 1
a1020 1
					SendBlockRequests();	
d1025 1
a1025 1
			return;
d1028 1
d1034 2
a1035 2
  int err = Z_DATA_ERROR;
  EMULE_TRY
d1040 1
d1058 1
d1064 2
a1065 1
	zS->next_in  = zipped;
d1084 3
a1086 2
				
		if (err != Z_OK) {
d1093 1
d1095 1
d1097 1
d1106 1
d1112 1
d1114 1
d1116 1
d1118 1
d1123 1
d1141 1
a1141 1
		AddDebugLogLine(false,_T("Unexpected zip error"));
d1143 1
a1143 1
		err=inflateEnd(zS);
d1151 3
a1153 2
  EMULE_CATCH
  return err;
d1160 1
a1160 1
	uint32			dwCurTick = GetTickCount();
d1165 2
a1166 1
		if (socket != NULL) {
d1170 2
a1171 1
			socket->SendPacket(packet,true,true);
d1173 1
d1175 1
d1178 2
a1179 1
	//	No more than one message/10 sec
d1182 1
a1182 1
			AddDebugLogLine(false, "-> Client %s (%s) was dropped due to timeout %u", GetUserName(), GetClientNameAndVersionString(this),dwCurTick - m_dwLastBlockReceived);
d1185 2
a1186 2
	} 
	else 
d1197 2
a1198 1
		while(m_Average_DL_tick_list.size() > 500) 
d1207 2
a1208 1
		uint64 AverageTransferredData = m_Client_Sum_DL_DR_over_last_N_measurements/m_Average_DL_DR_list.size();
d1210 2
a1211 2
		uint64 AverageTransferTimePeriod = m_Client_Sum_DL_tick_over_last_N_measurements/m_Average_DL_tick_list.size();
		
d1214 1
a1214 1
			m_nDownDataRate = 1000*AverageTransferredData/AverageTransferTimePeriod;
d1220 1
d1223 1
d1239 3
a1241 1
	for (int i = 0;i < m_nPartCount;i++){
d1245 1
d1257 1
a1257 1
	m_nDifferenceQueueRank = (nr-m_nRemoteQueueRank); //cendre-eau
d1270 1
d1275 1
d1277 1
d1279 1
d1281 4
a1284 3
	
	// check: target file is specified? if is not, then find another one 
	if (!SwapTo) {
d1286 5
a1290 2
		if (!m_OtherRequests_list.IsEmpty()){
			for (cur_FilePos = m_OtherRequests_list.GetHeadPosition();cur_FilePos != 0;m_OtherRequests_list.GetNext(cur_FilePos)){
d1293 12
a1304 8
				if (cur_file != reqfile && g_eMuleApp.m_pDownloadQueue->IsInDLQueue(cur_file) 
					&& (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) ) {
						// check: is new file in NNS-list?
						if (!bIgnoreNoNeeded || m_OtherNoNeeded_list.Find(cur_file) == 0 ) {
							SwapTo = cur_file;
							SwapToPos = cur_FilePos ;
							break; // break for cycle, since  file was found
						}
d1313 2
a1314 1
	if (SwapTo && SwapToPos != 0) {
d1317 2
a1318 1
		if (GetDownloadState() == DS_NONEEDEDPARTS && !m_OtherNoNeeded_list.Find(reqfile)) 
d1320 1
d1323 3
a1325 1
		if (m_abyPartStatus) {
d1329 1
d1333 1
a1333 1
		
d1338 1
a1338 1
		m_strComment="";
d1341 5
a1345 2
		cur_FilePos=reqfile->m_srcLists[sourcesslot].Find(this);
		if (cur_FilePos) reqfile->m_srcLists[sourcesslot].RemoveAt(cur_FilePos); // remove current file
d1348 2
a1349 1
		// add old file to m_OtherRequests_list 
d1351 1
d1354 1
d1357 1
a1357 1
		
d1359 1
d1365 1
d1368 4
a1371 1
		if (pos_A4AF) SwapTo->m_A4AFsrcList.RemoveAt(pos_A4AF);
d1374 4
a1377 1
		if (cur_FileNNSPos != 0) m_OtherNoNeeded_list.RemoveAt(cur_FileNNSPos);
d1379 3
a1381 1
		if (!SwapTo->m_srcLists[sourcesslot].Find(this))  SwapTo->m_srcLists[sourcesslot].AddTail(this);
d1384 1
d1387 1
d1393 1
d1396 1
a1396 1
		
d1400 1
d1418 1
d1420 2
a1421 2
	{ 
		AddDebugLogLine(false,CString("UDP ANSWER FNF : %s"),GetUserName());
d1424 1
d1427 1
d1429 5
a1433 3
	} 
	else 
		AddDebugLogLine(false,CString("UDP ANSWER FNF : %s (client not removed)"),GetUserName());
d1441 1
d1443 1
a1443 1
		return;
d1447 1
a1448 2
	if(m_byEmuleVersion >= 0x23 && m_nUDPPort != 0 && g_eMuleApp.m_pGlobPrefs->GetUDPPort() != 0 &&
	   !g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() && !(socket && socket->IsConnected()) && (!proxy.m_bUseProxy)) {
d1450 11
a1460 4
			//don't use udp to ask for sources
			if(IsSourceRequestAllowed())
				return;
			m_bUDPPending = true;
d1462 2
a1463 1
		uint16 packetsize= 16;
d1465 2
a1466 1
			packetsize+= 2;
d1468 4
a1471 2
		Packet* response = new Packet(OP_REASKFILEPING,packetsize,OP_EMULEPROT);	// netwolf: complete sources UDP
		md4cpy(response->m_pcBuffer,reqfile->GetFileHash());
d1475 2
a1476 2
			uint16 completecount= reqfile->GetCompleteSourcesCount();
			memcpy2(response->m_pcBuffer+16, &completecount, 2);
d1478 1
d1480 5
a1484 3
	        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(response->m_dwSize);
			g_eMuleApp.m_pClientUDPSocket->SendPacket(response,GetIP(),GetUDPPort());
		}
d1487 1
a1487 1
   EMULE_CATCH
d1496 1
d1498 1
a1498 1
		parts[m_PendingBlocks_list.GetNext(pos)->block->StartOffset / PARTSIZE]=true;
d1503 1
a1503 1
void CUpDownClient::UpdateDisplayedInfo(boolean force) 
d1507 2
a1508 1
	if (force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX))
d1514 7
a1520 4
#else
//	MOREVIT - I'm betting we don't need the throttle if we use the message queue
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.PostMessage(WM_DL_UPDATESOURCEITEM,0,reinterpret_cast<LPARAM>(this));
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndClientList.PostMessage(WM_CL_REFRESHCLIENT,0,reinterpret_cast<LPARAM>(this));
d1530 5
a1534 3
	if(m_abyPartStatus != NULL && m_nPartCount > 0){
		for(int i=0; i < m_nPartCount ; i++)
			if (m_abyPartStatus[i] && !reqfile->IsComplete(i*PARTSIZE,((i+1)*PARTSIZE)-1))
d1536 1
d1539 1
@


1.118
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@d1111 1
a1111 1
		m_iRate=0;
@


1.117
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@a345 1
	//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(this);
a1124 1
		//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(reqfile);
a1145 1
		//g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndDownloadList.UpdateItem(SwapTo);
d1239 1
d1247 5
@


1.116
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d26 1
a26 1
#include "memcpy_amd.h"
d572 1
a572 1
		Packet* packet = new Packet(OP_CANCELTRANSFER,0);
d971 1
a971 1
			Packet* packet = new Packet(OP_CANCELTRANSFER,0);
@


1.115
log
@Formatting, comments, and name changes.
@
text
@d204 2
a205 2
	packet->opcode=OP_FILEREQUEST;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d214 2
a215 2
	packet->opcode = OP_SETREQFILEID;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d230 2
a231 2
		md4cpy(packet->pBuffer,reqfile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadSourceExchange(packet->size);
d357 2
a358 2
		md4cpy(packet->pBuffer,reqfile->GetFileHash());
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d372 2
a373 2
		packet->opcode = OP_STARTUPLOADREQ;
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d503 2
a504 2
	opacket->opcode = OP_STARTUPLOADREQ;
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(opacket->size);
d573 1
a573 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d584 1
a584 1
	CSafeMemFile data((BYTE*)packet->pBuffer,40);
d609 1
a609 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d972 1
a972 1
			g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(packet->size);
d1212 1
a1212 1
		md4cpy(response->pBuffer,reqfile->GetFileHash());
d1217 1
a1217 1
			memcpy2(response->pBuffer+16, &completecount, 2);
d1220 1
a1220 1
	        g_eMuleApp.m_pUploadQueue->AddUpDataOverheadFileRequest(response->size);
@


1.114
log
@Kludged a fix to the client timeout message spam.
@
text
@d355 1
a355 1
	else if (reqfile->hashsetneeded){
d363 1
a363 1
		reqfile->hashsetneeded = false;
d399 1
a399 1
	file->A4AF_srclist.AddTail(this);	// add in A4AF file list
d495 1
a495 1
		reqfile->hashsetneeded = true;		
d1116 2
a1117 2
		cur_FilePos=reqfile->srclists[sourcesslot].Find(this);
		if (cur_FilePos) reqfile->srclists[sourcesslot].RemoveAt(cur_FilePos); // remove current file
d1119 1
a1119 1
		reqfile->A4AF_srclist.AddTail(this);
d1135 2
a1136 2
		POSITION pos_A4AF = SwapTo->A4AF_srclist.Find(this);
		if (pos_A4AF) SwapTo->A4AF_srclist.RemoveAt(pos_A4AF);
d1141 1
a1141 1
		if (!SwapTo->srclists[sourcesslot].Find(this))  SwapTo->srclists[sourcesslot].AddTail(this);
d1200 1
a1200 1
	   !g_eMuleApp.m_pServerConnect->IsLowID() && !HasLowID() && !(socket && socket->IsConnected()) && (!proxy.UseProxy)) {
@


1.113
log
@Formatting, comments, and name changes.
@
text
@d965 2
a966 1
	uint32 curTick = GetTickCount();
d968 1
a968 1
	if ((curTick- m_dwLastBlockReceived) > DOWNLOADTIMEOUT)
d979 6
a984 1
		AddDebugLogLine(false, "-> Client %s (%s) was dropped due timeout %u", GetUserName(), GetClientNameAndVersionString(this),curTick - m_dwLastBlockReceived);
d988 1
a988 1
		uint32 time_diff_ms = curTick - m_dwLastTimeCalculatedDR;
d1017 1
a1017 1
		m_dwLastTimeCalculatedDR = curTick;
@


1.112
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d1072 1
a1072 1
				if (cur_file != reqfile && g_eMuleApp.m_pDownloadQueue->IsPartFile(cur_file) 
@


1.111
log
@Official fix [Katsyonak]
@
text
@d1240 1
@


1.110
log
@Official fix [Katsyonak]
@
text
@d177 1
a177 1
			   ( (bNeverAskedBefore || nTimePassedClient > SOURCECLIENTREASK * reqfile->GetCommonFilePenalty()) &&
@


1.109
log
@change a way that filterd clients will be diconnected
@
text
@d155 2
a156 2
	int nTimePassedClient = dwTickCount - GetLastSrcAnswerTime();
	int nTimePassedFile   = dwTickCount - reqfile->GetLastAnsweredTime();
@


1.108
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d142 1
a142 1
		g_eMuleApp.m_pDownloadQueue->RemoveSource(this);
@


1.107
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d923 1
a923 5
		#ifndef AMD		
		memcpy(temp, (*unzipped), (zS->total_out - block->totalUnzipped));
		#else
		memcpy_amd(temp, (*unzipped), (zS->total_out - block->totalUnzipped));
		#endif
d1211 1
a1211 5
			#ifndef AMD
			memcpy(response->pBuffer+16, &completecount, 2);
			#else
			memcpy_amd(response->pBuffer+16, &completecount, 2);
			#endif
@


1.106
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d120 1
a120 1
	if (theApp.listensocket->TooManySockets() && !(socket && socket->IsConnected()) )
d142 1
a142 1
		theApp.downloadqueue->RemoveSource(this);
d163 1
a163 1
			 !theApp.glob_prefs->IsDisabledXS() &&
d165 1
a165 1
	         theApp.glob_prefs->GetMaxSourcePerFileSoft() > reqfile->GetSourceCount() &&
d205 1
a205 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d215 1
a215 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d223 1
a223 1
	if (theApp.glob_prefs->GetMaxSourcePerFileSoft() < reqfile->GetSourceCount() || theApp.glob_prefs->IsDisabledXS())
d225 1
a225 1
	if (theApp.glob_prefs->DisableXSUpTo() && theApp.glob_prefs->XSUpTo() < reqfile->GetSourceCount()) // DonGato - Disable XS for up to X sources
d231 1
a231 1
		theApp.uploadqueue->AddUpDataOverheadSourceExchange(packet->size);
d257 1
a257 1
		CKnownFile* locreqfile = theApp.sharedfiles->GetFileByID(cfilehash);
d283 1
a283 1
		CKnownFile* locreqfile = theApp.sharedfiles->GetFileByID(cfilehash);
d346 1
a346 1
	//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
d358 1
a358 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d373 1
a373 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d408 1
a408 1
void CUpDownClient::SetDownloadState(eDLQState byNewState)
d432 1
a432 1
				theApp.glob_prefs->Add2DownSuccessfulSessions(); // Increment our counters for successful sessions (Cumulative AND Session)
d434 2
a435 2
				theApp.glob_prefs->Add2DownFailedSessions(); // Increment our counters failed sessions (Cumulative AND Session)
			theApp.glob_prefs->Add2DownSAvgTime((::GetTickCount() - m_dwDownStartTime)/1000);
d504 1
a504 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(opacket->size);
d573 1
a573 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d609 1
a609 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d678 2
a679 2
	theApp.glob_prefs->Add2SessionTransferData(GetClientSoft(), GetUserPort(), false, Download, size - HEADER_SIZE);
	// theApp.UpdateReceivedBytes(size - HEADER_SIZE);
d764 2
a765 2
								theApp.ipfilter->AddBannedIPRange(ip1,ip1,1,_T("autobanned"));
								theApp.downloadqueue->RemoveSource(this);
d975 1
a975 1
			theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d1076 1
a1076 1
				if (cur_file != reqfile && theApp.downloadqueue->IsPartFile(cur_file) 
d1124 1
a1124 1
		//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(reqfile);
d1146 1
a1146 1
		//theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(SwapTo);
d1176 1
a1176 1
		theApp.downloadqueue->RemoveSource(this);
d1195 1
a1195 1
	ProxySettings proxy = theApp.glob_prefs->GetProxy();
d1197 2
a1198 2
	if(m_byEmuleVersion >= 0x23 && m_nUDPPort != 0 && theApp.glob_prefs->GetUDPPort() != 0 &&
	   !theApp.serverconnect->IsLowID() && !HasLowID() && !(socket && socket->IsConnected()) && (!proxy.UseProxy)) {
d1222 2
a1223 2
	        theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size);
			theApp.clientudp->SendPacket(response,GetIP(),GetUDPPort());
d1247 1
a1247 1
		theApp.emuledlg->transferwnd.m_wndDownloadList.UpdateItem(this);
@


1.105
log
@Small change for debug logging
@
text
@d462 1
a462 1
			m_nDownDatarate = 0;
d687 2
a688 2
	m_nTransferedDown += DownDataRateMS;
	m_TransferedInLastPeriod += DownDataRateMS;
d817 1
a817 1
				//m_nTransferedDown += lenWritten;
d981 1
a981 1
		m_nDownDatarate = 0;
d989 1
a989 1
		m_Client_Sum_DL_DR_over_last_N_measurements += m_TransferedInLastPeriod;
d992 1
a992 1
		m_Average_DL_DR_list.push_front(m_TransferedInLastPeriod);
d1004 1
a1004 1
		uint64 AverageTransferedData = m_Client_Sum_DL_DR_over_last_N_measurements/m_Average_DL_DR_list.size();
d1010 1
a1010 1
			m_nDownDatarate = 1000*AverageTransferedData/AverageTransferTimePeriod;
d1012 1
a1012 1
			m_nDownDatarate = 0;
d1014 1
a1014 1
		//update a time & reset data transfered over last period
d1016 1
a1016 1
		m_TransferedInLastPeriod = 0;
d1021 1
a1021 1
	return m_nDownDatarate;
@


1.104
log
@speed optimization in outgoing filtering
@
text
@d264 4
a267 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileInfo; reqfile==NULL)"));
d269 1
a269 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileInfo; reqfile!=cfilehash)"));
d292 4
a295 2
			throw CString(GetResString(IDS_ERR_WRONGFILEID) + _T(" (ProcessFileStatus; reqfile==NULL)"));
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileStatus; reqfile!=cfilehash)"));
@


1.103
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d138 7
a144 1
	return TryToConnect();
@


1.102
log
@updated complete sources (compatibility with future official)
@
text
@d673 1
a673 1
	credits->AddDownloaded(size - HEADER_SIZE);
d712 2
a713 2
				if (lenUnzipped > (BLOCKSIZE + 300))
					lenUnzipped = (BLOCKSIZE + 300);
d738 1
a738 1
							AddDebugLogLine(true,  _T("Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)"), reqfile->GetFileName(), cur_block->block->StartOffset/PARTSIZE, cur_block->block->StartOffset/BLOCKSIZE, lenUnzipped, nBlockSize);
@


1.101
log
@*** empty log message ***
@
text
@a193 1
	{
d195 1
a196 1
	}
@


1.100
log
@Updates to QR code by cendre-eau and other changes.
@
text
@d336 1
a336 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d398 1
a398 1
void CUpDownClient::SetDownloadState(uint8 byNewState)
d1114 1
a1114 1
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(reqfile);
d1136 1
a1136 1
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(SwapTo);
d1237 1
a1237 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
@


1.99
log
@remote queue progress is now shown and color coded [cendre-eau]
now you can set multiple files to Drop supercompressed blocks
Some fixes to images and installer profile
@
text
@d1038 1
a1038 1
	m_nDifferenceQueueRank = (m_nRemoteQueueRank - nr); //cendre-eau
@


1.98
log
@extended Upload Session statistic
@
text
@d1038 1
a1039 1
	//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
@


1.97
log
@added past comments
@
text
@d122 1
a122 1
		if (GetDownloadState() != DS_TOOMANYCONNS)
@


1.96
log
@new statistic (khaos based)
@
text
@d1095 5
d1102 1
a1102 2
		m_LastPartAsked = 0xffff; //jicxicmic
		
d1130 2
@


1.95
log
@fixed NULL pointer access
@
text
@d114 2
a115 1
void CUpDownClient::AskForDownload()
d130 1
a130 1
		return;
d137 2
a138 1
	TryToConnect();
d141 1
d402 2
a403 1
	if (m_nDownloadState != byNewState){
d411 4
a414 1
			m_dwLastTimeCalculatedDR = GetTickCount();	//eklmn: new DL measurements system
d416 2
d420 8
d460 1
d466 1
a468 1
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d664 8
a672 1
	theApp.UpdateReceivedBytes(size - HEADER_SIZE);
d808 1
@


1.94
log
@fixed division by 0 exception
@
text
@d937 3
a939 2
		Packet* packet = new Packet(OP_CANCELTRANSFER,0);
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size);
d941 1
a941 1
		socket->SendPacket(packet,true,true);
d943 1
d946 1
a946 1
		AddDebugLogLine(false, "-> Client %s (%s) was dropped due timeout %u", this->GetUserName(), GetClientNameAndVersionString(this),curTick - m_dwLastBlockReceived);
@


1.93
log
@small fix in SwapToAnotherFile
@
text
@d969 1
d971 4
a974 1
		m_nDownDatarate = 1000*AverageTransferedData/AverageTransferTimePeriod;
@


1.92
log
@added new file state PS_STOPPED
@
text
@d1077 2
a1078 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(reqfile);
d1097 2
a1098 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(SwapTo);
@


1.91
log
@fix in SwapToAnotherFile() (by specified target file check filestatus as well)
@
text
@d1076 1
a1076 1
		// update download list
d1079 1
a1079 1
		//reqfile = 0;	//reset before delete m_abyPartStatus
d1095 1
a1095 1
		// update download list
d1098 2
a1099 1
		//UpdateDisplayedInfo(true);
d1192 8
a1199 7
void CUpDownClient::UpdateDisplayedInfo(boolean force) {
    DWORD curTick = ::GetTickCount();

    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
	    theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
        m_lastRefreshedDLDisplay = curTick;
    }
@


1.90
log
@small fix indebug output
@
text
@d1046 1
a1046 1
	else
@


1.89
log
@DL go to 0 after "UDP ANSWER FNF"
@
text
@d552 1
a552 1
      		AddDebugLogLine(false, "-> Cance download from %s due empty block list", this->GetUserName());
@


1.88
log
@reseting m_nPartCount = 0 on diffrent locations //SyruS (0.29c)
more precise IDS_ERR_WRONGFILEID logging (null or diff.hash)
@
text
@d1127 1
a1127 1
		if (!socket)
@


1.87
log
@new DL client speed measurement system
@
text
@d242 2
a243 3
	data.Read(m_strClientFilename,namelength);	// TODO why does this overwrite the end of the buffer 
							//- because sizeof(uint16) is always 2 
	
d255 4
a258 2
	if ( (!reqfile) || md4cmp(cfilehash,reqfile->GetFileHash()))
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileInfo)"));
d280 3
a282 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ _T(" (ProcessFileStatus)"));	
d302 1
d440 1
d1061 1
@


1.86
log
@fix in ICR 2.10
@
text
@d403 1
d648 2
a649 13

    DWORD curTick = GetTickCount();
	if(m_Average_DL_tick_list.empty() || curTick - m_Average_DL_tick_list.front()>= 500)	//Cax2 - update no faster than every .5 sec
	{
		m_AverageDDR_list.push_front(m_nTransferedDown);
		m_Average_DL_tick_list.push_front(curTick);

		// don't save more than 40 secs of data
		while(curTick-m_Average_DL_tick_list.back() > 40000) {
   			m_AverageDDR_list.pop_back();
			m_Average_DL_tick_list.pop_back();
		}
	}
d924 1
a924 1
sint32 CUpDownClient::CalculateDownloadRate()
d930 2
a931 1
	if ((curTick- m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
d943 1
a943 5
		if(curTick-m_lastCalculatedDownloadRate >= MINWAIT_BEFORE_CALCULATE_DL_RATE) 
		{
			m_lastCalculatedDownloadRate = curTick;

			// Calculate average datarate
d945 8
a952 11
			// Present this slot's speed as 0 unless there's a good chunk
			// of stored statistics for it. If there's to little data, the
			// speed will be far off, so we might as well hide it in those
			// cases.
			if(m_AverageDDR_list.size() >= 2) {
				m_nDownDatarate = (uint32)(((float)(m_AverageDDR_list.front()-m_AverageDDR_list.back()))*1000 / (m_Average_DL_tick_list.front()-m_Average_DL_tick_list.back()));
			} else {
				m_nDownDatarate = 0;
			}
		} 
		else 
d954 4
a957 1
			// uses cached m_nDownDatarate
d959 11
d1115 3
a1117 1
	if (GetDownloadState() != DS_DOWNLOADING){ //SyruS (0.29a) avoid premature deletion of 'this' client
d1124 3
a1126 1
	} else AddDebugLogLine(false,CString("UDP ANSWER FNF : %s (client not removed)"),GetUserName());
a1136 1

d1138 1
a1138 1
    ProxySettings proxy = theApp.glob_prefs->GetProxy();
@


1.85
log
@ICR 2.10 (fixed bug zip-stream)
@
text
@a504 3
			// check if part was completed
			if (reqfile->GetBytesInPart(m_LastPartAsked, true, true) == 0 
				|| reqfile->IsCorruptedPart(m_LastPartAsked))  m_LastPartAsked = 0xffff; //ICR 2.10
d508 4
@


1.84
log
@fixed A4AF (incorrect SwapTo...), some optimization in SetDownloadState()
@
text
@d487 1
a487 1
	
d491 4
a498 1

d505 3
a523 1
			if (reqfile->GetBlocksToDownloadInPart() != 0) reqfile->DecBlocksToDownloadInPart();
a525 3
		if (reqfile->GetBlocksToDownloadInPart() == 0 ) {
			m_LastPartAsked = 0xffff; //eklmn: ICR v2.4
		}
@


1.83
log
@1) fixed possible exception during a scan of srclist;
2) fixed download timeouts
@
text
@d187 2
a188 1
	CMemFile data1;
d190 2
a191 1
	if( GetExtendedRequestsVersion() > 0 ){
d194 1
a194 1
			}
d201 1
d203 1
a203 1
	CMemFile data2;
d211 1
a211 1
	if( IsEmuleClient() ){
d287 2
a288 1
	if (!m_nPartCount){
d295 2
a296 1
	else{
d300 1
a300 1
		}
d348 2
a349 1
	else{
d361 1
d376 1
a376 1
	// if (m_OtherNoNeeded_list.Find(file) != 0) return false;	// eklmn: optimization(01): search with Find
d399 4
d442 1
a443 6
		if( GetDownloadState() == DS_DOWNLOADING ){
			if ( IsEmuleClient() )
			SetRemoteQueueFull(false);
			SetRemoteQueueRank(0);
			SetAskedCountDown(0);
		}
d1049 11
d1071 4
a1074 8
		reqfile = 0;	//reset before delete m_abyPartStatus
		if (m_abyPartStatus) {
			delete[] m_abyPartStatus;
			m_abyPartStatus = 0;
		}
		m_dwLastAskedTime = 0;
		m_iRate=0;
		m_strComment="";
a1090 3
		// actual switch
		reqfile = SwapTo;

a1091 1
		//theApp.emuledlg->transferwnd.downloadlistctrl.RefreshInfo(); //eklmn: bugfix(12): refresh whole list
@


1.82
log
@major bug in Download
@
text
@d100 1
a100 1
	if (GetIP() && GetIP() == tocomp->GetIP() && GetUserPort() == tocomp->GetUserPort())
d389 7
a395 1
		if (m_nDownloadState == DS_DOWNLOADING ){
d476 3
a478 1
	
d481 1
a518 3
	//jicxicmic - get blocks from the same chunk first

	m_dwLastBlockReceived = GetTickCount();
a520 1

d537 1
d925 2
a926 1
sint32 CUpDownClient::CalculateDownloadRate(){
d928 4
a931 1
    if ((GetTickCount() - m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
d938 10
d949 15
a963 22
        m_nDownDatarate = 0;
    } else {
        DWORD curTick = GetTickCount();

        if(curTick-m_lastCalculatedDownloadRate >= MINWAIT_BEFORE_CALCULATE_DL_RATE) {
            m_lastCalculatedDownloadRate = curTick;

            // Calculate average datarate

            // Present this slot's speed as 0 unless there's a good chunk
            // of stored statistics for it. If there's to little data, the
            // speed will be far off, so we might as well hide it in those
            // cases.
            if(m_AverageDDR_list.size() >= 2) {
	            m_nDownDatarate = (uint32)(((float)(m_AverageDDR_list.front()-m_AverageDDR_list.back()))*1000 / (m_Average_DL_tick_list.front()-m_Average_DL_tick_list.back()));
            } else {
                m_nDownDatarate = 0;
            }
        } else {
            // uses cached m_nDownDatarate
        }
    }
d966 2
a967 1
    return m_nDownDatarate;
@


1.81
log
@New A4AF mangement
@
text
@d470 1
a470 2

	m_dwLastBlockReceived = GetTickCount();
a506 1
			//reqfile->RemovePartFromBlockedList(m_LastPartAsked);
a508 1
		//if (count == 0)	m_LastPartAsked = 0xffff; //eklmn: ICR v2.4
d512 1
a512 1

@


1.80
log
@unicode cleanup
@
text
@d369 1
a369 1
	if (m_OtherNoNeeded_list.Find(file) != 0) return false;	// eklmn: optimization(01): search with Find
d375 1
a1028 2
		//CSingleLock sLock(&theApp.knownfiles->list_mut,true);		//Cax2 - proteceted!

d1030 2
a1031 1
		if (GetDownloadState() == DS_NONEEDEDPARTS) m_OtherNoNeeded_list.AddHead(reqfile);
d1035 4
a1050 9
		// don't show this user in file-queue
		//theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(reqfile,this,true);
		
		
		// add him to otherRequestsList
		m_OtherRequests_list.AddHead(this->reqfile);

		// actual switch
		reqfile = SwapTo;
d1052 1
d1054 3
d1059 1
a1059 1
		if (cur_FileNNSPos != 0) m_OtherNoNeeded_list.RemoveAt(SwapToPos);
a1065 2
		// show user in new part-queue
		// theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(SwapTo,this,false);
d1067 3
a1069 1
		//sLock.Unlock();	// unlock
@


1.79
log
@ICR fix, reset choosen part in case of suspicious block
@
text
@d254 1
a254 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileInfo)");
d276 1
a276 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileStatus)");	
d443 1
a443 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+" (ProcessHashSet)");	
d606 1
a606 1
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+" (ProcessBlockPacket)");
d625 1
a625 1
		throw CString(GetResString(IDS_ERR_BADDATABLOCK)+" (ProcessBlockPacket)");
d700 1
a700 1
				       		CString buffer2 = "";
d702 1
a702 1
								buffer.Format("%02X",GetUserHash()[i]);
d706 2
a707 2
							AddDebugLogLine(true,  "Received suspicious block: file '%s', part %i, block %i, blocksize %i, comp. blocksize %i)", reqfile->GetFileName(), cur_block->block->StartOffset/PARTSIZE, cur_block->block->StartOffset/BLOCKSIZE, lenUnzipped, nBlockSize);
       						AddDebugLogLine(false, "username '%s', ip %i.%i.%i.%i:%i, hash %s", m_pszUsername, (uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24), GetUserPort(), buffer2);
d715 1
a715 1
								buf.Format("%i.%i.%i.%i", (uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24));
d717 1
a717 1
									temp = buf.Tokenize(".",counter);
d721 1
a721 1
								theApp.ipfilter->AddBannedIPRange(ip1,ip1,1,"autobanned");
d723 1
a723 1
								AddDebugLogLine(false, "block dropped & IP locked out!");
d907 1
a907 1
		AddDebugLogLine(false,"Unexpected zip error");
@


1.78
log
@ICR 2.8 fix, in Compare() added check over IP + Port
@
text
@d695 4
a698 2
						if(nBlockSize*25 < lenUnzipped)
				      	{
d701 3
a703 4
				       		for (uint16 i = 0;i != 16;i++)
							{
				        		buffer.Format("%02X",GetUserHash()[i]);
				        		buffer2+=buffer;
d709 11
a719 12
                            if(reqfile->GetDiscardSuperCompressed()) {
							    //--- (un)comment the block-dropping as you wish---
       						    reqfile->RemoveBlockFromList(cur_block->block->StartOffset,cur_block->block->StartOffset+1);
					       	    uint32 ip1 = 0;
					       	    CString buf, temp;
					       	    int counter = 0;
					       	    buf.Format("%i.%i.%i.%i", (uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24));
					       	    for(int i=0; i<4; i++)
							    { 
        						    temp = buf.Tokenize(".",counter);
						            ip1 += _tstoi(temp) * pow(256,3-i);
       						    }
d721 7
a727 9
							    theApp.ipfilter->AddBannedIPRange(ip1,ip1,1,"autobanned");
					       	    theApp.downloadqueue->RemoveSource(this);
       						    AddDebugLogLine(false, "block dropped & IP locked out!");
                            }
                            // BavarianSnail
							else
							{
								if(nEndPos > cur_block->block->EndOffset)
								{
d731 1
a731 2
								else
								{
d741 2
a742 3
      					}
						else
						{
d757 1
a757 1
                        }
@


1.77
log
@A4AF switching v2
@
text
@d100 2
d103 1
a103 1
	    return !md4cmp(GetUserHash(), tocomp->GetUserHash());
d507 1
a507 1
			reqfile->RemovePartFromBlockedList(m_LastPartAsked);
@


1.76
log
@some optimization in AddRequestForAnotherFile()
@
text
@d1039 2
a1040 1
		//reqfile->UpdateAvailablePartsCount();
d1052 1
d1067 2
a1068 1
		//SwapTo->UpdateAvailablePartsCount();
d1074 1
a1074 1
		theApp.emuledlg->transferwnd.downloadlistctrl.RefreshInfo(); //eklmn: bugfix(12): refresh whole list
@


1.75
log
@ICR 2.7 (new condition for widespread parts 1 client = 1 Part)
@
text
@d364 7
a370 2
	if(file == NULL)
		return false;
a371 8
	for (POSITION pos = m_OtherNoNeeded_list.GetHeadPosition();pos != 0;m_OtherNoNeeded_list.GetNext(pos)){
		if (m_OtherNoNeeded_list.GetAt(pos) == file)
			return false;
	}
	for (POSITION pos = m_OtherRequests_list.GetHeadPosition();pos != 0;m_OtherRequests_list.GetNext(pos)){
		if (m_OtherRequests_list.GetAt(pos) == file)
			return false;
	}
d373 1
@


1.74
log
@unicode cleanup
@
text
@d506 4
a509 1
		if (reqfile->GetBlocksToDownloadInPart() == 0 ) m_LastPartAsked = 0xffff; //eklmn: ICR v2.4
@


1.73
log
@two source function (NewSrcPartsInfo & UpdateAvailablePartsCount) werr merged (speed optimization)
@
text
@d715 1
a715 1
						            ip1 += atoi(temp) * pow(256,3-i);
@


1.72
log
@refresh whole downloadlist after souce update
A4AF switching
@
text
@d324 2
a325 1
	reqfile->UpdateAvailablePartsCount();
a354 1
	reqfile->NewSrcPartsInfo();
d1037 2
a1038 2
		reqfile->NewSrcPartsInfo();
		reqfile->UpdateAvailablePartsCount();
d1063 2
a1064 2
		SwapTo->NewSrcPartsInfo();
		SwapTo->UpdateAvailablePartsCount();
@


1.71
log
@some changes in HandoverTo... removed
@
text
@d990 2
a991 1
bool CUpDownClient::SwapToAnotherFile(bool bIgnoreNoNeeded, bool bManualChange)
d994 2
a998 1
	// Modified by Tarod (get first high priority files)
d1000 2
a1001 1
	CPartFile* SwapTo = NULL;
d1003 16
a1018 8
	if (!m_OtherRequests_list.IsEmpty()){
		for (POSITION pos = m_OtherRequests_list.GetHeadPosition();pos != 0;m_OtherRequests_list.GetNext(pos)){
			cur_file = m_OtherRequests_list.GetAt(pos);
			if (cur_file != reqfile && theApp.downloadqueue->IsPartFile(cur_file) && (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) ){
				if (!SwapTo || (!bManualChange && SwapTo->GetPriority() < cur_file->GetPriority()))
				{
					SwapTo = cur_file;
					SwapToPos = pos ;
d1020 2
a1021 3
			}
		}
		if (SwapToPos != 0) m_OtherRequests_list.RemoveAt(SwapToPos);
d1023 18
a1040 19
	// Modified by Tarod (get first high priority files)
	if (!SwapTo && bIgnoreNoNeeded){
		for (POSITION pos = m_OtherNoNeeded_list.GetHeadPosition();pos != 0;m_OtherNoNeeded_list.GetNext(pos)){
			cur_file = m_OtherNoNeeded_list.GetAt(pos);
			if (cur_file != reqfile && theApp.downloadqueue->IsPartFile(cur_file) && (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) ){
				if (!SwapTo || (!bManualChange && SwapTo->GetPriority() < cur_file->GetPriority()))
				{
					SwapTo = cur_file;
					SwapToPos = pos ;
				}
			}
		}
		if (SwapToPos != 0) m_OtherNoNeeded_list.RemoveAt(SwapToPos);
	}
	if (SwapTo){
		m_OtherNoNeeded_list.AddHead(reqfile);
		theApp.downloadqueue->RemoveSource(this);
		m_nRemoteQueueRank = 0;
		if (m_abyPartStatus){
a1043 1
		//m_nPartCount = 0;	// netwolf 05.05.03 //16.05.03 commented out for complete sources
d1047 25
a1071 10
		// Lord KiRon A4AF bugfix + Cax2 bugfix: hanging sources!
      	if (bManualChange)
		{
			if(!theApp.downloadqueue->CheckAndAddKnownSource(SwapTo,this)) 
				return false;
		}else{
			theApp.downloadqueue->CheckAndAddKnownSource(SwapTo,this);
		}
      	// Lord KiRon - end
      	return true;
d1073 1
d1077 1
a1187 51
// v- eklmn: bugfix(08): Incorret switching in HandoverToAnotherFile()
// Amdribant
void CUpDownClient::HandoverToAnotherFile(CPartFile* h2file)		//Cax2 - bugfixed A4AF
{ 
	EMULE_TRY

	if(h2file == NULL||GetDownloadState() == DS_DOWNLOADING) return;

	CSingleLock sLock(&theApp.knownfiles->list_mut,true);		//Cax2 - proteceted!
	//Cax2 - downloadlist bugfix - removed unnecessary code...

	// find current file
	POSITION pos=this->reqfile->srclists[this->sourcesslot].Find(this);
	if (pos) this->reqfile->srclists[sourcesslot].RemoveAt(pos); // remove current file
	// let's update current information for the removed file
	this->reqfile->NewSrcPartsInfo();
	this->reqfile->UpdateAvailablePartsCount();
	this->SetDownloadState(DS_NONE);
	this->reqfile = 0;	//reset before delete m_abyPartStatus
	if (this->m_abyPartStatus) {
		delete[] this->m_abyPartStatus;
		this->m_abyPartStatus = 0;
	}
	this->m_nPartCount = 0; //added by sivka [Maella: was missing...]
	this->m_dwLastAskedTime = 0;
	this->m_iRate=0;
	this->m_strComment="";
	// don't show this user in file-queue 
	//theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(this->reqfile,this,true);
	// add him to otherRequestsList
	m_OtherRequests_list.AddHead(this->reqfile);


	// fine target file in otherfile list
	pos = m_OtherRequests_list.Find(h2file);
	if (pos) this->m_OtherRequests_list.RemoveAt(pos);


	this->reqfile = h2file;
	if (!h2file->srclists[this->sourcesslot].Find(this)) h2file->srclists[this->sourcesslot].AddTail(this);
	// Update info for target file
	h2file->NewSrcPartsInfo();
	h2file->UpdateAvailablePartsCount();
	// show user in new part-queue
	//theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(h2file,this,false);

	UpdateDisplayedInfo(true);

	EMULE_CATCH
 } 
// ^- eklmn: bugfix(08): Incorret switching in HandoverToAnotherFile()
@


1.70
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d1191 1
a1191 1
	theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(this->reqfile,this,true);
d1207 1
a1207 1
	theApp.emuledlg->transferwnd.downloadlistctrl.AddSource(h2file,this,false);
@


1.69
log
@Preparing for new sockets
@
text
@d26 1
d880 1
d882 3
d1108 1
d1110 3
d1213 1
a1213 1
// ^- eklmn: bugfix(08): Incorret switching in HandoverToAnotherFile()@


1.68
log
@small bugfix from 0.29a in UDPReaskFNF
@
text
@d1084 1
d1086 1
a1086 5
	   !theApp.serverconnect->IsLowID() && !HasLowID()
#ifdef OLD_SOCKETS_ENABLED
	   && !(socket && socket->IsConnected())
#endif //OLD_SOCKETS_ENABLED
	    && (!proxy.UseProxy)) {
d1109 1
@


1.67
log
@Preparing for new sockets
@
text
@d1063 3
a1065 2
	AddDebugLogLine(false,CString("UDP ANSWER FNF : %s"),GetUserName());
	theApp.downloadqueue->RemoveSource(this);
d1067 2
a1068 2
	if (!socket)
		Disconnected();
d1070 1
@


1.66
log
@converted to new logger methods
@
text
@d115 1
d128 1
d193 1
d195 1
d202 1
d204 1
d218 1
d220 1
d333 1
d335 1
d347 1
d349 1
d418 1
d421 1
d457 1
d459 1
d524 1
d526 1
d559 1
d561 1
d922 1
d924 1
d1065 1
d1068 1
d1083 5
a1087 1
	   !theApp.serverconnect->IsLowID() && !HasLowID() && !(socket && socket->IsConnected()) && (!proxy.UseProxy)) {
@


1.65
log
@fixed access violation after file completion
@
text
@d706 1
a706 1
									AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG), reqfile->GetFileName(), 666);
d725 1
a725 1
								AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG),reqfile->GetFileName(),666);
d742 1
a742 1
					AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG), reqfile->GetFileName(), result);
@


1.64
log
@ICR 2.4
@
text
@d755 1
a755 1

d757 6
a762 1
				if (nEndPos == cur_block->block->EndOffset)
@


1.63
log
@Incorret switching in HandoverToAnotherFile()
@
text
@d471 1
a471 1
			if (count == 0)		//finished part ?
d484 1
a484 1
		for (int i = 0; i < count; i++)
d486 2
a487 1

d489 2
a490 2
		if (count == 0)
			m_LastPartAsked = 0xffff;
@


1.62
log
@code cleanup
@
text
@d1120 1
d1122 1
a1122 1
void CUpDownClient::HandoverToAnotherFile(CPartFile* file)		//Cax2 - bugfixed A4AF
d1126 2
a1127 2
	if(file == NULL||GetDownloadState() == DS_DOWNLOADING)
		return;
d1129 13
a1141 18
	 //Cax2 - downloadlist bugfix - removed unnecessary code...
	POSITION pos = m_OtherRequests_list.Find(file); 
	if (pos) { 
      		m_OtherRequests_list.RemoveAt(pos); 
	} 

	//Cax2 - attach them properly
	pos=reqfile->srclists[sourcesslot].Find(this);
	if (pos)
			reqfile->srclists[sourcesslot].RemoveAt(pos);
	CPartFile* cur_file=(CPartFile*) &reqfile;
	m_OtherRequests_list.AddHead(cur_file);
	reqfile=file;
//	cur_file->UpdateAvailablePartsCount();
	if (m_abyPartStatus)
	{
		delete[] m_abyPartStatus;
		m_abyPartStatus = 0;
d1143 22
d1167 1
a1167 8
	
	if (!file->srclists[sourcesslot].Find(this))
		file->srclists[sourcesslot].AddTail(this);

	m_iRate=0;
	m_strComment="";
	m_dwLastAskedTime = 0;
//	file->UpdateAvailablePartsCount();
d1170 1
@


1.61
log
@fixed null pointer access
@
text
@d429 2
a430 2
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
	if (reqfile->LoadHashsetFromFile(data,true)){
d433 1
a433 2
		reqfile->hashsetneeded = true;
		delete data;	//mf
d437 4
a440 4
	delete data;
	data = new CSafeMemFile(16);
	data->Write(this->reqfile->GetFileHash(),16);
	Packet* opacket = new Packet(data);
a444 1
	delete data;
@


1.60
log
@fixed null pointer access
@
text
@d237 1
a237 1
		if (locreqfile->IsPartFile())
@


1.59
log
@complete sources update (UDP)
@
text
@d258 1
a258 1
		if (locreqfile->IsPartFile())
@


1.58
log
@code cleanup
@
text
@d1061 6
a1066 1
			Packet* response = new Packet(OP_REASKFILEPING,16,OP_EMULEPROT);
d1068 7
@


1.57
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d227 2
a228 6
	data.Read(&namelength,2);
	if (m_pszClientFilename)
		delete[] m_pszClientFilename;
	m_pszClientFilename = new char[namelength+1];
	memset(m_pszClientFilename, 0, namelength+1);
	data.Read(m_pszClientFilename,namelength);	// TODO why does this overwrite the end of the buffer 
@


1.56
log
@*** empty log message ***
@
text
@d706 19
@


1.55
log
@minor changes
@
text
@d520 2
a521 2
	CMemFile* data = new CMemFile((BYTE*)packet->pBuffer,40);
	data->Write(reqfile->GetFileHash(),16);
d529 1
a529 1
			data->Write(&block->StartOffset,4);
d532 1
a532 1
			data->Write(&null,4);
d540 1
a540 1
			data->Write(&endpos,4);
d543 1
a543 1
			data->Write(&null,4);
a544 1
	delete data;
d580 1
a580 1
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
d582 1
a582 1
	data->Read(fileID, 16);
a586 1
		delete data;
d594 1
a594 1
	data->Read(&nStartPos,4);
d597 1
a597 1
		data->Read(&nBlockSize,4);
d602 1
a602 2
		data->Read(&nEndPos,4);
	delete data;
@


1.54
log
@minor fixes and improvements
@
text
@d223 1
a223 1
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
d225 1
a225 1
	data->Read(cfilehash,16);
d227 1
a227 1
	data->Read(&namelength,2);
d232 1
a232 1
	data->Read(m_pszClientFilename,namelength);	// TODO why does this overwrite the end of the buffer 
a233 1
	delete data;
@


1.53
log
@complete sources column
@
text
@d64 1
a64 1
			for (uint32 i = 0;i != m_nPartCount;i++)
d102 1
a102 1
		return ((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()));
d432 1
a432 1
	if ( (!reqfile) || memcmp(packet,reqfile->GetFileHash(),16))
d491 1
a491 1
		for (int i = 0; i != count; i++)
d926 1
a926 1
	for (int i = 0;i != m_nPartCount;i++){
@


1.52
log
@make "drop supercompressed blocks" a per-file setting
@
text
@d186 2
a187 1
	}
d291 1
d299 5
a303 1
				if (m_abyPartStatus[done] && !reqfile->IsComplete(done*PARTSIZE,((done+1)*PARTSIZE)-1))
d305 2
d312 4
d993 1
a993 1
		m_nPartCount = 0;	// netwolf 05.05.03
@


1.51
log
@L2HAC by EnkeyDev
@
text
@d681 12
a692 11
							//--- (un)comment the block-dropping as you wish---
       						reqfile->RemoveBlockFromList(cur_block->block->StartOffset,cur_block->block->StartOffset+1);
					       	uint32 ip1 = 0;
					       	CString buf, temp;
					       	int counter = 0;
					       	buf.Format("%i.%i.%i.%i", (uint8)m_dwUserIP, (uint8)(m_dwUserIP>>8), (uint8)(m_dwUserIP>>16),(uint8)(m_dwUserIP>>24));
					       	for(int i=0; i<4; i++)
							{ 
        						temp = buf.Tokenize(".",counter);
						        ip1 += atoi(temp) * pow(256,3-i);
       						}
d694 4
a697 3
							theApp.ipfilter->AddBannedIPRange(ip1,ip1,1,"autobanned");
					       	theApp.downloadqueue->RemoveSource(this);
       						AddDebugLogLine(false, "block dropped & IP locked out!");
@


1.50
log
@*** empty log message ***
@
text
@d234 3
d331 1
d438 1
@


1.49
log
@code cleanup
@
text
@d974 1
@


1.48
log
@More netwolf's changes
@
text
@d182 2
a183 2
	CMemFile* data = new CMemFile();
	data->Write(reqfile->GetFileHash(),16);
d185 1
a185 1
		reqfile->WritePartStatus(data);
d187 1
a187 1
	Packet* packet = new Packet(data);
d191 4
a194 4
	delete data;
	data = new CMemFile();
	data->Write(reqfile->GetFileHash(),16);
	packet = new Packet(data);
d197 1
a197 2
	socket->SendPacket(packet, true);
	delete data;
@


1.47
log
@Various fixes (see changelog+)
@
text
@d235 9
d256 9
@


1.46
log
@Upgrade to 0.28a
@
text
@d699 4
a702 1
				delete [] unzipped;
d1083 1
a1083 1
	cur_file->UpdateAvailablePartsCount();
d1098 1
a1098 1
	file->UpdateAvailablePartsCount();
@


1.45
log
@Updated version to 1e, removed DonkeyDoctor broken support and added again TwoBottleMOD code with a fix.
@
text
@d100 1
a100 1
		return !memcmp(this->GetUserHash(), tocomp->GetUserHash(), 16);
d102 1
a102 1
		return ((this->GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()));
d104 1
a104 1
		return (this->GetUserID() == tocomp->GetUserID() || (this->GetIP() && this->GetIP() == tocomp->GetIP()) );
a173 16
/*
void CUpDownClient::SendFileRequestForUpload(){
	Packet* packet = new Packet(OP_FILEREQUEST,16);
	memcpy(packet->pBuffer,reqfileid,16);
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
	socket->SendPacket(packet,false);

	packet->opcode = OP_SETREQFILEID;
	socket->SendPacket(packet,true);

	if (GetDownloadState() != DS_NONE) {
		SendFileRequest();
	}
}
*/

d199 1
a199 1
	if( IsEmuleClient() )
d202 1
a202 1
	
d210 1
a210 1
		memcpy(packet->pBuffer,reqfile->GetFileHash(),16);
d235 1
a235 1
	if ( (!reqfile) || memcmp(cfilehash,reqfile->GetFileHash(),16))
d247 1
a247 1
	if ( (!reqfile) || memcmp(cfilehash,reqfile->GetFileHash(),16)){
d296 1
a296 1
		memcpy(packet->pBuffer,reqfile->GetFileHash(),16);
d306 1
a306 1
		data1.Write(this->reqfile->GetFileHash(),16);
d385 1
a385 1
			SetRemoteQueueRank(1);
d482 2
a483 1
		AskForDownload(); //<<--enkeyDEV(Ottavio84) - reask for file
d553 1
a553 1
	if ( (!reqfile) || memcmp(packet,reqfile->GetFileHash(),16))
d1011 1
a1011 1
			memcpy(response->pBuffer,reqfile->GetFileHash(),16);
@


1.44
log
@missing initialization
@
text
@d380 2
a381 3
				if (pending->zStream)
				//{  // DonGato commented out
					//inflateEnd(pending->zStream); // DonGato commented out
d383 1
a383 1
				//} // DonGato commented out
d418 1
a418 3
	if (reqfile->LoadHashsetFromFile(data,true))
	{
		theApp.knownfiles->SafeAddKFile(reqfile, true);   // DonkeyDoctor 
d730 2
a731 2
					if (cur_block->zStream) //{ // DonGato commented out
						//inflateEnd(cur_block->zStream); // DonGato commented out
d733 1
a733 1
					//} // DonGato commented out
d796 4
a799 4
		//block->zStream = NULL; // DonGato commented out
		if (err != Z_OK)
		//if (err == Z_OK) { // DonGato commented out
		//	delete zS; // DonGato commented out
d801 1
a801 1
		//} // DonGato commented out
d806 2
a807 2
		//delete zS; // DonGato commented out
		//zS = NULL; //just for future // DonGato commented out
d847 3
a849 3
		//block->zStream = NULL; // DonGato commented out
		//delete zS; // DonGato commented out
		//zS = NULL; //just for future // DonGato commented out
@


1.43
log
@Updates to HTTPD Template, DownloadClient and Web Server panel.
@
text
@d679 1
a679 1
					       	uint32 ip1;
@


1.42
log
@additional check for the size of compressed packet
@
text
@d380 3
a382 2
				if (pending->zStream) {
					inflateEnd(pending->zStream);
d384 1
a384 1
				}
d664 45
a708 11
						if( nEndPos > cur_block->block->EndOffset){
							theApp.emuledlg->AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG),reqfile->GetFileName(),666);
							reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
						}
						else{
						    // Write uncompressed data to file
						    lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
															    unzipped,
															    nStartPos,
															    nEndPos,
															    cur_block->block );
d733 2
a734 2
					if (cur_block->zStream) {
						inflateEnd(cur_block->zStream);
d736 1
a736 1
					}
d799 4
a802 4
		block->zStream = NULL;
				
		if (err == Z_OK) {
			delete zS;
d804 1
a804 1
		}
d809 2
a810 2
		delete zS;
		zS = NULL; //just for future
d850 3
a852 3
		block->zStream = NULL;
		delete zS;
		zS = NULL; //just for future
@


1.41
log
@fix mem leak (missing inflateEnd)
@
text
@d663 12
a674 6
						// Write uncompressed data to file
						lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
															unzipped,
															nStartPos,
															nEndPos,
															cur_block->block );
@


1.40
log
@converted to safe iteration (becouse of RemoveAt)
@
text
@d380 4
a383 1
				if (pending->zStream) delete pending->zStream;
d692 4
a695 1
					if (cur_block->zStream) delete cur_block->zStream;
d758 4
a761 1
		if (err != Z_OK)
d763 1
d768 2
d809 3
@


1.39
log
@bugfix: sort column doesn't change when not in advanced sort mode. lower memory usage
@
text
@d614 2
a615 1
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition(); pos != NULL; m_PendingBlocks_list.GetNext(pos))
d617 1
a617 1
		cur_block = m_PendingBlocks_list.GetAt(pos);
d684 2
a690 1
					m_PendingBlocks_list.RemoveAt(pos);
@


1.38
log
@last bugfixes!
@
text
@d601 1
a601 1
	if(m_avarage_DL_tick_list.IsEmpty() || curTick >= m_avarage_DL_tick_list.GetTail()+500)	//Cax2 - update no faster than every .5 sec
d603 2
a604 2
		m_AvarageDDR_list.AddTail(m_nTransferedDown);
		m_avarage_DL_tick_list.AddTail(curTick);
d607 3
a609 3
		while(curTick-m_avarage_DL_tick_list.GetHead() > 40000) {
   			m_AvarageDDR_list.RemoveHead();
			m_avarage_DL_tick_list.RemoveHead();
d824 2
a825 2
            if(m_AvarageDDR_list.GetSize() >= 2) {
	            m_nDownDatarate = (uint32)(((float)(m_AvarageDDR_list.GetTail()-m_AvarageDDR_list.GetHead()))*1000 / (m_avarage_DL_tick_list.GetTail()-m_avarage_DL_tick_list.GetHead()));
@


1.38.2.1
log
@27a partial merge
@
text
@d215 1
a215 1
	if( IsEmuleClient() ){
d217 1
a217 2
		SetRemoteQueueRank(0);
	}	
a362 6
		if(byNewState == DS_DOWNLOADING){
			reqfile->AddDownloadingSource(this);
		}
		else if(m_nDownloadState == DS_DOWNLOADING){
			reqfile->RemoveDownloadingSource(this);
		}
d398 1
a398 1
			SetRemoteQueueRank(0);
d882 1
a882 1
			if (cur_file != reqfile && theApp.downloadqueue->IsPartFile(cur_file) && !cur_file->IsStopped() && (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) ){
d896 1
a896 1
			if (cur_file != reqfile && theApp.downloadqueue->IsPartFile(cur_file) && !cur_file->IsStopped() && (cur_file->GetStatus(false) == PS_READY || cur_file->GetStatus(false) == PS_EMPTY) ){
@


1.38.2.2
log
@27c
@
text
@d102 1
a102 1
		return ((this->GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()) && (this->GetUserPort() == tocomp->GetUserPort()));
d104 1
a104 1
		return ((this->GetUserID() == tocomp->GetUserID() && this->GetUserPort() == tocomp->GetUserPort()) || (this->GetIP() && (this->GetIP() == tocomp->GetIP() && this->GetUserPort() == tocomp->GetUserPort())) );
d408 1
d666 7
a672 13
						if( nEndPos > cur_block->block->EndOffset){
							theApp.emuledlg->AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG),reqfile->GetFileName(),666);
							reqfile->RemoveBlockFromList(cur_block->block->StartOffset, cur_block->block->EndOffset);
						}
						else{
						    // Write uncompressed data to file
						    lenWritten = reqfile->WriteToBuffer(size - HEADER_SIZE,
															    unzipped,
															    nStartPos,
															    nEndPos,
															    cur_block->block );
					    }
				    }
@


1.37
log
@bugfixed bugfixes!
@
text
@d1026 1
@


1.36
log
@bugfix: less resource usage, fixed bug #131
@
text
@d786 2
a787 1
		inflateEnd(zS);
d794 1
a794 1
		inflateEnd(zS);
@


1.35
log
@*** empty log message ***
@
text
@d600 5
a604 9
    DWORD curTick = ::GetTickCount();
	m_AvarageDDR_list.AddTail(m_nTransferedDown);
    m_avarage_DL_tick_list.AddTail(curTick);

    // don't save more than 40 secs of data
    while(curTick-m_avarage_DL_tick_list.GetHead() > 40*1000) {
   	    m_AvarageDDR_list.RemoveHead();
        m_avarage_DL_tick_list.RemoveHead();
    }
d606 6
@


1.34
log
@changed official code using a CString!!! as a boolean vector
@
text
@d784 1
d791 1
@


1.33
log
@bugfix: should download better from .26 and above( bug 61)
@
text
@d59 1
a59 1
			CString gettingParts;
d62 1
a62 1
				ShowDownloadingParts(&gettingParts);		// Barry - was only showing one part from client, even when reserved bits from 2 parts
d78 1
a78 1
					else if (isDLing && gettingParts.GetAt(i) == 'Y')	//Cax2 - no more flashes of yellow across all clients...
d975 1
a975 1
void CUpDownClient::ShowDownloadingParts(CString *partsYN)
a977 2
	Requested_Block_Struct *cur_block;
	int x;
d979 3
a981 6
	// Initialise to all N's
	char *n = new char[m_nPartCount+1];
	_strnset(n, 'N', m_nPartCount);
	n[m_nPartCount] = 0;
	partsYN->SetString(n, m_nPartCount);
	delete [] n;
d983 1
a983 7
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition(); pos != 0; m_PendingBlocks_list.GetNext(pos))
	{
		cur_block = m_PendingBlocks_list.GetAt(pos)->block;
		x = (cur_block->StartOffset / PARTSIZE);
		partsYN->SetAt(x, 'Y');
	}
   EMULE_CATCH
@


1.32
log
@converted to new logging method
@
text
@d390 1
d444 1
d447 5
d453 2
a454 1
		uint16 count = 3 - m_PendingBlocks_list.GetCount();
d456 12
a467 3
		if (reqfile->GetNextRequestedBlock(this,toadd,&count)){
			for (int i = 0; i != count; i++)
				m_DownloadBlocks_list.AddTail(toadd[i]);			
d469 6
d476 2
d479 3
@


1.31
log
@fixed a memory leak when some invalid packet is received
@
text
@d229 1
a229 1
		//theApp.emuledlg->AddDebugLogLine(false, "Send:Source Request User(%s) File(%s)", GetUserName(), reqfile->GetFileName());
d639 1
a639 1
					theApp.emuledlg->AddDebugLogLine(false, GetResString(IDS_ERR_CORRUPTCOMPRPKG), reqfile->GetFileName(), result);
d760 1
a760 1
		theApp.emuledlg->AddDebugLogLine(false,"Unexpected zip error");
d913 1
a913 1
	theApp.emuledlg->AddDebugLogLine(false,CString("UDP ANSWER FNF : %s"),GetUserName());
@


1.30
log
@bugfix a4af local name
@
text
@d260 1
a260 1
	CSafeMemFile* data = new CSafeMemFile((BYTE*)packet,size);
d262 1
a262 1
	data->Read(cfilehash,16);
d264 1
a264 1
		delete data;	//mf
d267 1
a267 1
	data->Read(&m_nPartCount,2);
d282 1
a282 1
			delete data;	//mf
d290 1
a290 1
			data->Read(&toread,1);
d320 4
a323 4
		delete data;
		data = new CSafeMemFile(16);
		data->Write(this->reqfile->GetFileHash(),16);
		Packet* packet = new Packet(data);
d330 1
a330 1
	delete data;
@


1.29
log
@bugfix: status bar mem leak - Maella
@
text
@d1018 5
@


1.28
log
@...
@
text
@d36 1
a36 1
CBarShader CUpDownClient::s_StatusBar(16);
d41 5
a45 5
	COLORREF crBoth; 
	COLORREF crNeither; 
	COLORREF crClientOnly; 
	COLORREF crPending = RGB(255,208,0);
	COLORREF crNextPending = RGB(255,255,100);
d47 1
a47 1
	COLORREF crMeOnly = RGB(190,190,255); 
d49 2
d52 3
a54 9
	if(bFlat) { 
		crBoth = RGB(0, 150, 0); 
		crNeither = RGB(224, 224, 224);
		crClientOnly = RGB(0, 0, 0); 
	} else { 
		crBoth = RGB(0, 192, 0);	//Cax2 - same green used for files & clients
		crNeither = RGB(240, 240, 240); 
		crClientOnly = RGB(95, 95, 95); //Cax2 - darker 'black'...
	} 
a57 6
		uint32 filesize=reqfile->GetFileSize();
		s_StatusBar.SetFileSize(filesize); 
		s_StatusBar.SetHeight(rect->bottom - rect->top); 
		s_StatusBar.SetWidth(rect->right - rect->left); 
		s_StatusBar.Fill(crNeither); 

d60 2
a61 1
			if (m_nDownloadState == DS_DOWNLOADING)	//Cax2 - no unneded calls to showdownloadingparts...
d74 2
a75 2
						s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crBoth); 
					else if (m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && 
d77 3
a79 3
							s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crPending);      
					else if (m_nDownloadState == DS_DOWNLOADING && gettingParts.GetAt(i) == 'Y')	//Cax2 - no more flashes of yellow across all clients...
						s_StatusBar.FillRange(PARTSIZE*i, uEnd, crNextPending);
d81 1
a81 1
						s_StatusBar.FillRange(PARTSIZE*i, uEnd, crClientOnly);
d85 1
a85 1
						s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crMeOnly); 
d90 1
a90 1
   	s_StatusBar.Draw(dc, rect->left, rect->top, bFlat); 
@


1.27
log
@updated about dialog, proper A4AF management
@
text
@a1012 1
	CPartFile* cur_file=(CPartFile*) &reqfile;
d1018 6
d1026 2
d1029 3
a1031 7

	//Cax2 - attach them properly
	pos=cur_file->srclists[sourcesslot].Find(this);
	if (pos)
			cur_file->srclists[sourcesslot].RemoveAt(pos);		
	if (!reqfile->srclists[sourcesslot].Find(this))
		reqfile->srclists[sourcesslot].AddTail(this);
a1035 1
	cur_file->UpdateAvailablePartsCount();
@


1.26
log
@DonkeyDoctor support added again (needs some test but it was only a single line missing).
@
text
@d1021 9
d1034 1
a1034 2
	UpdateDisplayedInfo();

@


1.25
log
@A4AF bugfixes: shift+expand doesn't show A4AF anymore, the source count is updated....
@
text
@d423 3
a425 1
	if (reqfile->LoadHashsetFromFile(data,true)){
@


1.24
log
@proper Hybrid version nr!
@
text
@d1019 4
d1024 1
@


1.23
log
@bugfixed A4AF
@
text
@d1005 1
a1005 1
void CUpDownClient::HandoverToAnotherFile(CPartFile* file) 
@


1.22
log
@minimize to tray button v4a, updated connections control panel
@
text
@d852 1
d855 1
a855 1
			CPartFile* cur_file = m_OtherRequests_list.GetAt(pos);
d869 1
a869 1
			CPartFile* cur_file = m_OtherNoNeeded_list.GetAt(pos);
d1009 1
a1009 1
	if(file == NULL)
d1011 2
a1012 1

a1015 1
		m_OtherRequests_list.AddHead(file); 
d1017 3
a1019 2
	SwapToAnotherFile(false, true); 

@


1.21
log
@cpu optimization!!!
@
text
@a67 3
		// Barry - was only showing one part from client, even when reserved bits from 2 parts


d70 2
a71 2
			if (m_nDownloadState == DS_DOWNLOADING)	//Cax2 no unneded calls to showdownloadingparts...
				ShowDownloadingParts(&gettingParts);
d807 2
a808 5
	if ( m_nDownDatarate>0 || m_bHadDownData){		//Cax2 - less CPU usage
			m_bHadDownData=(m_nDownDatarate>0);	//Cax2 - if speed==0...
			UpdateDisplayedInfo(!m_bHadDownData);		//Cax2 - this is the last(forced) refresh... :)
	}

a810 25
//-
	//m_AvarageDDR_list.AddTail(m_nDownDataRateMS);
	//if (m_AvarageDDR_list.GetCount() > 300)
	//	m_AvarageDDR_list.RemoveAt(m_AvarageDDR_list.GetHeadPosition());
	//
	//m_nDownDatarate = 0;
	//m_nDownDataRateMS = 0;
	//for (POSITION pos = m_AvarageDDR_list.GetHeadPosition();pos != 0;m_AvarageDDR_list.GetNext(pos))
	//	m_nDownDatarate += m_AvarageDDR_list.GetAt(pos);

	//if(m_AvarageDDR_list.GetCount() > 10)
	//	m_nDownDatarate /= (m_AvarageDDR_list.GetCount()/10);
	//else
	//	m_nDownDatarate = 0;

	//UpdateDisplayedInfo();

 //   if ((::GetTickCount() - m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
	//	Packet* packet = new Packet(OP_CANCELTRANSFER,0);
	//	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
	//	socket->SendPacket(packet,true,true);
	//	SetDownloadState(DS_ONQUEUE);
	//}
	//	
	//return m_nDownDatarate;
@


1.20
log
@minor bugfixes, refreshes sources display...
@
text
@d782 1
a782 1
    if ((::GetTickCount() - m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
d790 1
a790 1
        DWORD curTick = ::GetTickCount();
d810 5
a814 1
	UpdateDisplayedInfo(true);
@


1.19
log
@control panel limits, optimizations, bugfixes
@
text
@d810 1
a810 1

d1005 1
a1005 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()/(RAND_MAX/1000))) {
@


1.19.2.1
log
@write the info on part senders
@
text
@d68 3
d73 2
a74 2
			if (m_nDownloadState == DS_DOWNLOADING)	//Cax2 - no unneded calls to showdownloadingparts...
				ShowDownloadingParts(&gettingParts);		// Barry - was only showing one part from client, even when reserved bits from 2 parts
d617 1
a617 2
													cur_block->block, 
                                                    GetUserHash(), GetIP());
d644 1
a644 2
															cur_block->block, 
                                                            GetUserHash(), GetIP() );
d782 1
a782 1
    if ((GetTickCount() - m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
d790 1
a790 1
        DWORD curTick = GetTickCount();
d810 1
a810 2
	//Cax2 - the gain was minimal, not worth keeping that...
	UpdateDisplayedInfo();
d813 25
a878 1
	CPartFile* cur_file;		//Cax2 CPU optimization
d881 1
a881 1
			cur_file = m_OtherRequests_list.GetAt(pos);
d895 1
a895 1
			cur_file = m_OtherNoNeeded_list.GetAt(pos);
d1005 1
a1005 1
    if(force || curTick-m_lastRefreshedDLDisplay > MINWAIT_BEFORE_DLDISPLAY_WINDOWUPDATE+(uint32)(rand()*1000/RAND_MAX)) {
d1031 1
a1031 1
void CUpDownClient::HandoverToAnotherFile(CPartFile* file)		//Cax2 - bugfixed A4AF
d1035 1
a1035 1
	if(file == NULL||GetDownloadState() == DS_DOWNLOADING)
d1037 1
a1037 2
	CPartFile* cur_file=(CPartFile*) &reqfile;
	 //Cax2 - downloadlist bugfix - removed unnecessary code...
d1041 1
d1043 2
a1044 3
	m_OtherRequests_list.AddHead(cur_file);
	reqfile=file;
	UpdateDisplayedInfo();
@


1.19.2.2
log
@keeping in sync with the main cvs line
@
text
@d423 1
a423 3
	if (reqfile->LoadHashsetFromFile(data,true))
	{
		theApp.knownfiles->SafeAddKFile(reqfile, true);   // DonkeyDoctor 
a1020 4
	m_iRate=0;
	m_strComment="";
	m_dwLastAskedTime = 0;
	cur_file->UpdateAvailablePartsCount();
a1021 1

@


1.19.2.3
log
@Transactional store
@
text
@a1030 37

bool CUpDownClient::IsBannedFromDownload(void) {
    EMULE_TRY
    try {
        uint32 sender_ip = GetIP();
        sint32 sender_score;
        Dbt key_sender_ip(&sender_ip, 4);

        Dbt data_sender_score(&sender_score,sizeof(sender_score));
        data_sender_score.set_ulen(sizeof(sender_score));
        data_sender_score.set_flags(DB_DBT_USERMEM);
        

        //DbTxn *tid;
        //theApp.emuledlg->pDbEnv->txn_begin(NULL, &tid, 0);

        int res = theApp.emuledlg->pDbSendersScore->get(NULL, &key_sender_ip, &data_sender_score,0);
        //tid->commit(0);

        if(res==DB_NOTFOUND) {
            sender_score = 0;
            theApp.emuledlg->AddDebugLogLine(false,CString("DEBUG: IsBannedFromDownload: ip: %s unknown yet"), GetFullIP());
        } else {
            ASSERT(data_sender_score.get_size() == sizeof(sender_score));
            theApp.emuledlg->AddDebugLogLine(false,CString("DEBUG: IsBannedFromDownload: ip: %s sender score: %d"), GetFullIP(), sender_score);
        }
        if(sender_score>=2)
            return true;   
        else // just easier on the eyes than   return (sender_score>=2);
            return false;
    } catch(DbException &dbe) {
		AfxMessageBox(dbe.what());
	}
    EMULE_CATCH
    return false;
}

@


1.18
log
@the famous zz upload system! :)
@
text
@d62 2
a63 1
		s_StatusBar.SetFileSize(reqfile->GetFileSize()); 
d69 1
a69 2
		CString gettingParts;
			ShowDownloadingParts(&gettingParts);
d72 4
a75 1
			uint32 filesize=reqfile->GetFileSize();
d77 1
a77 2
		{ 	
			uint32 uEnd; //Cax2 less cpu usage
a82 1
				
@


1.17
log
@Really small fix
@
text
@d240 1
a240 1
		theApp.emuledlg->AddDebugLogLine(false, "Send:Source Request User(%s) File(%s)", GetUserName(), reqfile->GetFileName());
d575 1
a575 1
	m_nDownDataRateMS += size - HEADER_SIZE;
d579 12
d657 1
a657 1
				m_nTransferedDown += lenWritten;
d779 1
a779 2
uint32 CUpDownClient::CalculateDownloadRate()
{
d781 1
a781 24

	// START - enkeyDEV(Ottavio84) -Accurate speed measurement-
	TransferredData newitem = {m_nDownDataRateMS, GetTickCount()};
	m_AvarageDDR_list.AddTail(newitem);
	sumavgddr += m_nDownDataRateMS;
	if (m_AvarageDDR_list.GetCount() > 200)
		sumavgddr -= m_AvarageDDR_list.RemoveHead().datalen;
	m_nDownDatarate = sumavgddr;
	m_nDownDataRateMS = 0;

	float deltat = (float)(m_AvarageDDR_list.GetTail().timestamp - m_AvarageDDR_list.GetHead().timestamp) / 1000.0;
	if (deltat > 0.0) 
        	m_nDownDatarate = (uint32)((float)sumavgddr / deltat);
	else
		m_nDownDatarate = 0;
	// END - enkeyDEV(Ottavio84) -Accurate speed measurement-

	m_cShowDR++;
	if (m_cShowDR == 30){
		m_cShowDR = 0;
		//theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
		UpdateDisplayedInfo();
	}
	if ((GetTickCount() - m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
a785 3
	}
		
	return m_nDownDatarate;
d787 50
@


1.16
log
@Code clean up and double check wit official code.
@
text
@d60 6
d67 3
a69 4
	s_StatusBar.SetFileSize(reqfile->GetFileSize()); 
	s_StatusBar.SetHeight(rect->bottom - rect->top); 
	s_StatusBar.SetWidth(rect->right - rect->left); 
	s_StatusBar.Fill(crNeither); 
d71 30
a100 33
	// Barry - was only showing one part from client, even when reserved bits from 2 parts
	CString gettingParts;
		ShowDownloadingParts(&gettingParts);

	if (!onlygreyrect && reqfile && m_abyPartStatus) { 
        uint32 filesize=reqfile->GetFileSize();
		for (uint32 i = 0;i != m_nPartCount;i++)
	{ 	
		uint32 uEnd; //Cax2 less cpu usage
			//--- xrmb:seetheneed --- & Cax2 graphic glitch fix
			if (PARTSIZE*(i+1) > filesize) 
				uEnd = filesize; 
			else 
				uEnd = PARTSIZE*(i+1); 
			
			if (m_abyPartStatus[i]){ //they have this part
				// do i have it ?
				if  (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))
					s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crBoth); 
				else if (m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && 
                                                     m_nLastBlockOffset >= PARTSIZE*i)
						s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crPending);      
				else if (m_nDownloadState == DS_DOWNLOADING && gettingParts.GetAt(i) == 'Y')	//Cax2 - no more flashes of yellow across all clients...
					s_StatusBar.FillRange(PARTSIZE*i, uEnd, crNextPending);
	    		else
					s_StatusBar.FillRange(PARTSIZE*i, uEnd, crClientOnly);
			}
			else //they don't have a part. Do I have it?
				if (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1)) 
					s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crMeOnly); 
			//--- :xrmb --- & Cax2 graphic glitch fix
		} 
   	} 
@


1.15
log
@minor updates & bugfixes
@
text
@a132 3
//      else 
//			m_dwLastAskedTime += (uint32)ROUND(((float)rand() / RAND_MAX) * 300000); 
//		// End by Tarod
d238 1
a238 1
//		theApp.emuledlg->AddDebugLogLine( false, "Send:Source Request User(%s) File(%s)", GetUserName(), reqfile->GetFileName() );
d476 1
a476 1
                AskForDownload(); //<<--enkeyDEV(Ottavio84) - reask for file
@


1.14
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d44 2
a45 2
	COLORREF crPending;
	COLORREF crNextPending;
d47 1
a47 1
	COLORREF crMeOnly; 
a53 2
		crPending = RGB(255,208,0);
		crNextPending = RGB(255,255,100);
d55 1
a55 1
		crBoth = RGB(0, 192, 0); 
d57 1
a57 3
		crClientOnly = RGB(104, 104, 104); 
		crPending = RGB(255,208,0);
		crNextPending = RGB(255,255,100);
a58 3
		//--- xrmb:seetheneed ---
		crMeOnly = RGB(190,190,255);
		//--- :xrmb --
d88 1
a88 1
				else if (gettingParts.GetAt(i) == 'Y')
@


1.13
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d287 1
a287 1
    if (m_abyPartStatus) {
d289 1
a289 1
        m_abyPartStatus = NULL; // obaldin: can't hurt!
d325 2
d420 1
a420 1
		UpdateDisplayedInfo();
@


1.12
log
@*** empty log message ***
@
text
@d27 6
@


1.11
log
@more 26b merges
@
text
@d242 1
a242 1
		theApp.emuledlg->AddDebugLogLine( false, "Send:Source Request User(%s) File(%s)", GetUserName(), reqfile->GetFileName() );
@


1.10
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d208 1
a208 1
	if (!reqfile)
a212 1
//	CKnownFile* tempreqfile = theApp.sharedfiles->GetFileByID(reqfileid);
d218 1
a218 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d225 2
a226 2
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
	socket->SendPacket(packet,true);
d240 1
a240 1
		theApp.uploadqueue->AddUpDataOverheadSourceExchange(packet->size, 0);
d314 3
a316 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d324 2
a325 2
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
		socket->SendPacket(packet,true,true);
a330 1
//		Packet* packet = new Packet(OP_STARTUPLOADREQ,0);
d336 2
a337 2
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
		socket->SendPacket(packet,true,true);
d411 2
a412 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
a432 1
//	Packet* opacket = new Packet(OP_STARTUPLOADREQ,0);
d438 2
a439 2
	theApp.uploadqueue->AddUpDataOverheadFileRequest(opacket->size, 0);
	socket->SendPacket(opacket,true,true);
d475 1
a475 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d508 1
a508 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d790 2
a791 1
		theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d795 1
a795 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d828 2
a829 1
	theApp.emuledlg->transferwnd.downloadlistctrl.UpdateItem(this);
d936 1
a936 1
	        theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size,0);
d964 9
@


1.9
log
@bugfix  in dislpaying other clients versions (v2B was shown as v31) minor sort bugfixes
@
text
@d31 1
a31 1
void CUpDownClient::DrawStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool  bFlat,bool bUpParts)
d48 2
a53 1
	} 
d56 1
a59 18
	// UUU
	uint16 nPartCount;
	uint32 filesize;
	uint8 *abyPartStatus;
	bool more_info;

	if( ((!bUpParts) || (m_nUpPartCount==65535)) && reqfile) {
		nPartCount = m_nPartCount;
		filesize = reqfile->GetFileSize();
		abyPartStatus = m_abyPartStatus;
		more_info = true;
	}
	else {
		nPartCount = m_nUpPartCount;
		filesize = PARTSIZE*m_nUpPartCount;
		abyPartStatus = m_abyUpPartStatus;
		more_info = false;
	}
d62 1
a62 1
	s_StatusBar.SetFileSize(filesize); 
a68 1
	if(!bUpParts) {
a69 1
	}
d71 3
a73 1
	if (!onlygreyrect && abyPartStatus)
a75 2
		for (uint32 i = 0;i != nPartCount;i++)
		{ 
d82 1
a82 1
			if (abyPartStatus[i]){ //they have this part
d84 1
a84 1
				if  (more_info && reqfile && reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))  //UUU
d86 2
a87 1
				else if (more_info && m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && m_nLastBlockOffset >= PARTSIZE*i)
d89 1
a89 1
				else if ((!bUpParts) && (gettingParts.GetAt(i) == 'Y'))
d95 1
a95 1
				if (more_info && reqfile && reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1)) 
d105 2
a106 2
bool CUpDownClient::Compare(CUpDownClient* tocomp)
{
d109 2
a110 16
	if(tocomp == NULL)
		return false;
	//Is this a bad check?  The possibility of two people with same hash is
	//  1 in 2^128
	//  or
	//  1 in 3.4028236692093846346337460743177e+38
	//
	//if(HasValidHash() && tocomp->HasValidHash())
	//	return memcmp(m_achUserHash, tocomp->GetUserHash(), 16);
	//
	// This wouldn't be bad if everyone went by the rules.. But they don't and
	// share ClientHashes.. So, we allow download clients with the same Hash, but
	// filter them out of the upload.. Now if some group is sharing a Hash we
	// can download from them all, but only one of them can be in our upload
	// queue at one time.

d140 1
d187 1
d193 1
a193 1
	/*
d196 1
a196 1
	*/
d201 1
d211 14
a224 4
	Packet* packet = new Packet(OP_FILEREQUEST,16);
	memcpy(packet->pBuffer,reqfile->GetFileHash(),16);
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
	socket->SendPacket(packet,false);
d226 1
a226 1
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d228 1
d241 1
a241 1
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
a257 19

	if ( (!reqfile) || memcmp(cfilehash,reqfile->GetFileHash(),16)) {
		// we are not downloading this file
		if (memcmp(cfilehash,reqfileid,16)) {
			// we are not uploading this neither.
			// possible reason - the client changed the requested
			// file before responding to our request
			delete data;
			//throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileInfo)");
			// should not hurt if we leave the client on?
			return;
		}
		else {
			// answer for reqfileid - no need to copy names
			delete data;
			return;
		}
	}

d265 2
d271 1
a271 31
uint16 CUpDownClient::GetUpPartCount() {
	return (m_nUpPartCount==65535)? m_nPartCount:m_nUpPartCount;
}

uint16 CUpDownClient::GetUpAvailPartCount() {
	uint16 part_count;
	uint8* part_status;

	if(m_nUpPartCount==65535) {
		// we are down- and up- loading the same file
		part_count = m_nPartCount;
		part_status = m_abyPartStatus;
	}
	else {
		part_count = m_nUpPartCount;
		part_status = m_abyUpPartStatus;
	}

	if (!part_status) {
		return 0;
	}
	int cnt = 0;
	for(int n=0; n<part_count; n++) {
		if (part_status[n]) cnt++;
	}
	return cnt;
}


void CUpDownClient::ProcessFileStatus(char* packet,uint32 size)
{
d278 2
a279 45
		// we are not downloading this file
		if (memcmp(cfilehash,reqfileid,16)) {
			// we are not uploading this neither.
			// possible reason - the client changed the requested
			// file before responding to our request
			delete data;
			// can it hurt if we leave the client on?
			//throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileStatus)");	
			return;
		}
		else {
			// answer for the uploading file only
			data->Read(&m_nUpPartCount,2);

			uint16 avail_count = 0;
			if (m_nUpPartCount) {
				uint16 done = 0;
				if (m_abyUpPartStatus)
					delete[] m_abyUpPartStatus;
				m_abyUpPartStatus = new uint8[m_nUpPartCount];
				while (done != m_nUpPartCount){
					uint8 toread;
					data->Read(&toread,1);
					for (sint32 i = 0;i != 8;i++){
						m_abyUpPartStatus[done] = ((toread>>i)&1)? 1:0;
						if(m_abyUpPartStatus[done]) 
							avail_count++;
						done++;
						if (done == m_nUpPartCount)
							break;
					}
				}
			}
			//theApp.emuledlg->AddLogLine(false,CString("UUU - ProcessFileStatus for Upload Client - parts:%d/%d"), avail_count, m_nUpPartCount);
			delete data;
			theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this, false, false);
			theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(this);
			return;
		}
	}
	// got here if it's an answer for the downloaded file, or for both
	if(!memcmp(reqfileid,reqfile->GetFileHash(),16)) {
		// both, mark as such
		m_nUpPartCount = 65535;
		//theApp.emuledlg->AddLogLine(false,CString("UUU - ProcessFileStatus bi-dir"));
d282 1
a282 1
	if (m_abyPartStatus)
d284 2
a313 1

a315 8

	if (theApp.glob_prefs->IsUploadPartsEnabled())
	{
		// Update 'upload parts' display
		theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this, false, false);
		theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(this);
	}

d323 1
a323 1
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d330 7
a336 2
		Packet* packet = new Packet(OP_STARTUPLOADREQ,0);
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d405 2
a406 1
		if( GetDownloadState() == DS_DOWNLOADING && IsEmuleClient() ){
d432 7
a438 2
	Packet* opacket = new Packet(OP_STARTUPLOADREQ,0);
	theApp.uploadqueue->AddUpDataRateMSOverhead(opacket->size, 160);
d475 1
a475 1
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d477 2
a478 1
		SetDownloadState(DS_NONEEDEDPARTS);
d508 1
a508 1
	theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d533 1
d537 3
a539 2
	theApp.uploadqueue->AddUpDataRateMSOverhead(24, 0);
	theApp.UpdateReceivedBytes(size);
a541 2
	const int HEADER_SIZE = 24;

d544 4
a547 2
	uchar fileid[16];
	data->Read(fileid,16);
d550 1
a550 1
		delete data;	//mf
d574 1
d579 1
d581 1
a581 1
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition();pos != 0;m_PendingBlocks_list.GetNext(pos))
d794 1
a794 1
		theApp.uploadqueue->AddUpDataRateMSOverhead(packet->size, 160);
d934 1
@


1.9.4.1
log
@initial upgrade to .26
@
text
@d31 2
a32 1
void CUpDownClient::DrawStatusBar(CDC* dc, RECT* rect, bool onlygreyrect, bool  bFlat){ 
d45 1
a45 1
		crBoth = RGB(0, 150, 0);
d47 6
a52 1
		crClientOnly = RGB(0, 0, 0);
a54 7
	} else { 
		crBoth = RGB(0, 192, 0);
		crNeither = RGB(240, 240, 240);
		crClientOnly = RGB(104, 104, 104);
		crPending = RGB(255, 208, 0);
		crNextPending = RGB(255,255,100);
	} 
d58 18
d78 1
a78 1
	s_StatusBar.SetFileSize(reqfile->GetFileSize()); 
d85 3
a87 1
	ShowDownloadingParts(&gettingParts);
d89 4
a92 3
	if (!onlygreyrect && reqfile && m_abyPartStatus) { 
uint32 filesize=reqfile->GetFileSize();
		for (uint32 i = 0;i != m_nPartCount;i++)
a93 1
		        uint32 uEnd; //Cax2 less cpu usage
d100 1
a100 1
			if (m_abyPartStatus[i]){ //they have this part
d102 1
a102 1
				if  (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))
d104 3
a106 4
				else if (m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && 
                                                     m_nLastBlockOffset >= PARTSIZE*i)
						s_StatusBar.FillRange(PARTSIZE*i, uEnd, crPending);
				else if (gettingParts.GetAt(i) == 'Y')
d112 1
a112 1
				if (reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1)) 
d122 19
a141 3
bool CUpDownClient::Compare(CUpDownClient* tocomp){
	if(HasValidHash() && tocomp->HasValidHash())
		return !memcmp(this->GetUserHash(), tocomp->GetUserHash(), 16);
d152 2
a153 1
void CUpDownClient::AskForDownload(){
d156 2
a157 1
	if (theApp.listensocket->TooManySockets() && !(socket && socket->IsConnected()) ){
a170 1

d179 2
a180 1
bool CUpDownClient::IsSourceRequestAllowed() {
a216 1
/*
d222 1
a222 1
	
d225 1
a225 1
	
a229 1
*/
d231 2
a232 1
void CUpDownClient::SendFileRequest(){
d236 1
a236 1
	if(!reqfile)
d239 4
a242 14
	CMemFile* data = new CMemFile();
	data->Write(reqfile->GetFileHash(),16);
//	CKnownFile* tempreqfile = theApp.sharedfiles->GetFileByID(reqfileid);
	if( GetExtendedRequestsVersion() > 0 ){
		reqfile->WritePartStatus(data);
	}
	Packet* packet = new Packet(data);
	packet->opcode=OP_FILEREQUEST;
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
	socket->SendPacket(packet, true);
	delete data;
	data = new CMemFile();
	data->Write(reqfile->GetFileHash(),16);
	packet = new Packet(data);
d244 1
a244 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
a245 1
	delete data;
d258 1
a258 1
		theApp.uploadqueue->AddUpDataOverheadSourceExchange(packet->size, 0);
d266 2
a267 1
void CUpDownClient::ProcessFileInfo(char* packet,uint32 size){
d275 19
a300 2
	if ( (!reqfile) || memcmp(cfilehash,reqfile->GetFileHash(),16))
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileInfo)");
d305 31
a335 1
void CUpDownClient::ProcessFileStatus(char* packet,uint32 size){
d342 45
a386 2
		delete data;	//mf
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileStatus)");	
d419 1
d422 8
d437 1
a437 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d444 2
a445 7
//		Packet* packet = new Packet(OP_STARTUPLOADREQ,0);
		delete data;
		data = new CSafeMemFile(16);
		data->Write(this->reqfile->GetFileHash(),16);
		Packet* packet = new Packet(data);
		packet->opcode = OP_STARTUPLOADREQ;
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d514 2
a515 3
		if( GetDownloadState() == DS_DOWNLOADING ){
			if ( IsEmuleClient() )
				SetRemoteQueueFull(false);
d540 2
a541 7
//	Packet* opacket = new Packet(OP_STARTUPLOADREQ,0);
	delete data;
	data = new CSafeMemFile(16);
	data->Write(this->reqfile->GetFileHash(),16);
	Packet* opacket = new Packet(data);
	opacket->opcode = OP_STARTUPLOADREQ;
	theApp.uploadqueue->AddUpDataOverheadFileRequest(opacket->size, 0);
d578 1
a578 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d610 1
a610 1
	theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
d631 1
a631 1
void CUpDownClient::ProcessBlockPacket(char *packet, uint32 size, bool packed)
a634 1
	// Ignore if no data required
d638 2
a639 3
	const int HEADER_SIZE = 24;

	// Update stats
d642 1
d645 4
a648 6
	CSafeMemFile *data = new CSafeMemFile((BYTE*)packet, size);
	uchar fileID[16];
	data->Read(fileID, 16);

	// Check that this data is for the correct file
	if ( (!reqfile) || memcmp(packet, reqfile->GetFileHash(), 16))
d650 2
a651 2
		delete data;
		throw CString(GetResString(IDS_ERR_WRONGFILEID) + " (ProcessBlockPacket)");
d658 1
a658 1
	data->Read(&nStartPos, 4);
d661 1
a661 1
		data->Read(&nBlockSize, 4);
a673 1
	theApp.UpdateReceivedBytes(size - HEADER_SIZE);
d678 2
a679 3
	// Loop through to find the reserved block that this is within
	Pending_Block_Struct *cur_block;
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition(); pos != NULL; m_PendingBlocks_list.GetNext(pos))
d723 1
a723 1

d856 1
a856 1
//		DebugBreak(); I removed this so that we could let the client run for more the five minutes.. Barry needs to see if there is or isn't a preoblem here..
d892 1
a892 1
		theApp.uploadqueue->AddUpDataOverheadFileRequest(packet->size, 0);
a1031 1
		        theApp.uploadqueue->AddUpDataOverheadFileRequest(response->size,0);
@


1.9.4.2
log
@further fixes
@
text
@d71 1
a71 1
        uint32 filesize=reqfile->GetFileSize();
@


1.9.4.3
log
@more fixes, more merging, try/catch balancing
@
text
@a105 2
    EMULE_TRY

d467 1
a467 2
		//SetDownloadState(DS_NONEEDEDPARTS);
                AskForDownload(); //<<--enkeyDEV(Ottavio84) - reask for file
@


1.9.4.4
log
@couple of 'can't hurt' crash protections
@
text
@d276 1
a276 1
    if (m_abyPartStatus) {
a277 2
        m_abyPartStatus = NULL; // obaldin: can't hurt!
    }
@


1.9.2.1
log
@updating this branch...
@
text
@@


1.8
log
@updated to .25b codebase
@
text
@d46 1
a46 1
		crNeither = RGB(224, 224, 224); 
a47 5
		crPending = RGB(255,208,0);
		crNextPending = RGB(255,255,100);
		//--- xrmb:seetheneed ---
		crMeOnly = RGB(200,200,255);
		//--- :xrmb ---
d52 2
a53 1
		crPending = RGB(255, 208, 0);
d56 2
a57 4
		crMeOnly = RGB(144,144,255);
		//--- :xrmb ---
	} 

d90 2
a91 1
	{ 
d94 1
a94 2
			//--- xrmb:seetheneed --- + cax graphic glitch fix
			uint32 uEnd; 
d100 1
a100 1
			if (abyPartStatus[i]){ //do they have a part?
d114 1
a114 1
			//--- :xrmb --- + cax graphic glitch fix
a121 1

d870 1
a870 1
	TransferredData newitem = {m_nDownDataRateMS, ::GetTickCount()};
a1059 1

@


1.7
log
@DrawStatusBar fix
@
text
@d70 1
a70 1
	if((!bUpParts || m_nUpPartCount==65535) && reqfile) {
d1005 1
a1005 1
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("UDP ANSWER received : %s"),GetUserName()));
d1013 1
a1013 1
	DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("UDP ANSWER FNF : %s"),GetUserName()));
a1035 1
			DEBUG_ONLY(theApp.emuledlg->AddLogLine(false,CString("UDP REASK SEND : %s"),GetUserName()));
d1041 1
@


1.6
log
@some variables got duplicated during merge
@
text
@d91 3
a93 1
	ShowDownloadingParts(&gettingParts);
d112 1
a112 1
				else if (gettingParts.GetAt(i) == 'Y')
@


1.5
log
@final port to .25b!
@
text
@d875 1
a875 1
	TransferredData newitem = {downdataratems, ::GetTickCount()};
d877 1
a877 1
	sumavgddr += downdataratems;
d881 1
a881 1
	downdataratems = 0;
@


1.4
log
@port to .25 b codebase...
@
text
@d70 1
a70 1
	if( ((!bUpParts) || (m_nUpPartCount==65535)) && reqfile) {
d88 5
d557 1
a557 1
	m_dwLastBlockReceived = ::GetTickCount();
a576 1
		pblock->buffer = new CMemFile(10240);
a775 1
  {
d861 1
a861 1
//		DebugBreak(); I removed this so that we could let the client run for more the five minutes.. Barry needs to see if there is or isn't a preoblem here..
d870 1
a870 1
uint32 CUpDownClient::CalculateDownloadRate(){
d895 1
a895 1
	if ((::GetTickCount() - m_dwLastBlockReceived) > DOWNLOADTIMEOUT){
d986 1
a986 1
				return false
@


1.3
log
@update to .25b codebase
@
text
@d980 7
a986 4
      	if (bManualChange && !theApp.downloadqueue->CheckAndAddKnownSource(SwapTo,this)) 
      	{ 
        	return false; 
      	} 
@


1.2
log
@*** empty log message ***
@
text
@d39 1
d48 2
a49 1
		crPending = RGB(255,255,100);
d58 1
d60 1
a60 1
		crMeOnly = RGB(104,104,180);
d92 1
a92 1
			//--- xrmb:seetheneed ---
d99 3
a101 5
			// do i have it ?
			if  (more_info && reqfile && reqfile->IsComplete(PARTSIZE*i,PARTSIZE*(i+1)-1))  //UUU
			{
				//does the other client have it?
				if (abyPartStatus[i])
d103 9
a111 1
				else 
d113 1
a113 9
			} 
			else
				//does the other client have it?
				if (abyPartStatus[i])
					if (more_info && m_nDownloadState == DS_DOWNLOADING && m_nLastBlockOffset < uEnd && m_nLastBlockOffset >= PARTSIZE*i)
						s_StatusBar.FillRange(PARTSIZE*i,  uEnd, crPending);      
	    				else
						s_StatusBar.FillRange(PARTSIZE*i, uEnd, crClientOnly);
			//--- :xrmb ---
d128 18
a146 21
	// Modified by Tarod (fixing of duplicated clients in download queue)
	// I think that check for a hash is enough because an user may
	// change his/her IP more often than his/her hash
	if (GetSourceEntry() == (CSourceEntry*)NULL && tocomp->GetSourceEntry() == (CSourceEntry*)NULL // No loaded source
			&& *((uint32*)GetUserHash()) != 0 && *((uint32*)tocomp->GetUserHash()) != 0) { // With hash (fast trick, only 4 bytes compared)
		if (HasLowID()) {
			return (((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()))
				|| (memcmp(GetUserHash(), tocomp->GetUserHash(), 16) == 0)
				|| (memcmp(theApp.glob_prefs->GetUserHash(), tocomp->GetUserHash(), 16) == 0));
		} else {
			return (GetUserID() == tocomp->GetUserID() || (GetIP() && GetIP() == tocomp->GetIP()) // No own client in queue
				|| (memcmp(GetUserHash(), tocomp->GetUserHash(), 16) == 0)
				|| (memcmp(theApp.glob_prefs->GetUserHash(), tocomp->GetUserHash(), 16) == 0));
}
	} else { // It is a loaded source (HasLowID is superfluous 'til new TTL implementation)
		if (HasLowID()) {
			return (((GetUserID() == tocomp->GetUserID()) && (GetServerIP() == tocomp->GetServerIP()))) ;
		} else { // Ain't a loaded source
			return (GetUserID() == tocomp->GetUserID() || (GetIP() && GetIP() == tocomp->GetIP())); // No own client in queue
		}
	}
d162 1
a162 2
		// Vorlost halfed the code in order to initially begin 
		// an randomly based source asking only at the beginning for each new source 
d164 1
a164 1
			m_dwLastAskedTime = ::GetTickCount() - FILEREASKTIME + (uint32)ROUND(((float)rand() / RAND_MAX) * 300000); 
d172 1
a172 1
	m_dwLastAskedTime = ::GetTickCount();
d183 1
a183 1
	DWORD dwTickCount = ::GetTickCount() + CONNECTION_LATENCY;
d189 2
a190 2
	         //if client has the extended protocol
	         ExtProtocolAvailable() &&
d220 1
a230 1

d238 1
d241 1
d244 1
d246 2
a254 1
		OutputDebugString("OP_REQUESTSOURCES\n");
d258 1
d260 1
a301 5
	/* check moved to the beginning of the function
	if ( (!reqfile) || memcmp(cfilehash,reqfile->GetFileHash(),16))
		throw CString(GetResString(IDS_ERR_WRONGFILEID)+ " (ProcessFileInfo)");
	*/

d423 6
a428 3
	// Update 'upload parts' display
	theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(this, false, false);
	theApp.emuledlg->transferwnd.uploadlistctrl.RefreshClient(this);
d437 1
d445 1
d492 3
a494 2
			for (POSITION pos = m_PendingBlocks_list.GetHeadPosition();pos != 0;m_PendingBlocks_list.GetNext(pos)){
				Requested_Block_Struct* cur_block = m_PendingBlocks_list.GetAt(pos)->block;
d496 6
a501 4
					reqfile->RemoveBlockFromList(cur_block->StartOffset,cur_block->EndOffset);
				delete m_PendingBlocks_list.GetAt(pos)->block;
				delete m_PendingBlocks_list.GetAt(pos)->buffer;
				delete m_PendingBlocks_list.GetAt(pos);
d514 5
d541 1
d555 5
a559 3
	if (m_DownloadBlocks_list.IsEmpty()){
		uint16 count;
		Requested_Block_Struct** toadd = new Requested_Block_Struct*[3];
d566 3
d573 2
d579 1
d611 1
d617 15
d639 1
d642 4
d649 2
a650 1
	if ( (!reqfile) || memcmp(packet,reqfile->GetFileHash(),16)){
d654 2
d660 2
a661 1
	if (packed){
d663 1
a663 1
		nEndPos = nStartPos + (size-24);
d668 1
d670 2
a671 2
	if ( size != (nEndPos-nStartPos)+24){
		delete data;	//mf
d673 4
a676 4
	}
	downdataratems += nEndPos-nStartPos;
	m_nTransferedDown += nEndPos-nStartPos;
	credits->AddDownloaded(nEndPos-nStartPos);
a677 1
	delete data;
d679 52
a730 9
	for (POSITION pos = m_PendingBlocks_list.GetHeadPosition();pos != 0;m_PendingBlocks_list.GetNext(pos)){
		Pending_Block_Struct* cur_block = m_PendingBlocks_list.GetAt(pos);
		if (cur_block->block->StartOffset <= nStartPos && cur_block->block->EndOffset >= nEndPos){
			cur_block->buffer->Write(packet+24,size-24);
			m_nLastBlockOffset = nStartPos;   // [Cax2]
			if (!packed){
				if (nEndPos == cur_block->block->EndOffset){
					if ((cur_block->block->EndOffset-cur_block->block->StartOffset)+1 != cur_block->buffer->GetLength()){
						theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_PACKAGEERROR),reqfile->GetFileName());
a731 11
					else{
						char* blockbuffer = (char*)cur_block->buffer->Detach();
						reqfile->BlockReceived(cur_block->block->StartOffset,cur_block->block->EndOffset,blockbuffer);
						free(blockbuffer);
					}
					delete cur_block->block;
					delete cur_block->buffer;
					delete cur_block;
					
					m_PendingBlocks_list.RemoveAt(pos);
					SendBlockRequests();	
d733 6
d740 10
a749 15
			else{
				if (nBlockSize == cur_block->buffer->GetLength()){
					BYTE* blockbuffer = cur_block->buffer->Detach();
					BYTE* unpack = new BYTE[BLOCKSIZE+300];
					uLongf unpackedsize = BLOCKSIZE+300;
					uint16 result = uncompress(unpack,&unpackedsize,blockbuffer,nBlockSize);
					if (result == Z_OK){
						reqfile->BlockReceived(cur_block->block->StartOffset,cur_block->block->StartOffset + (unpackedsize-1),(char*)unpack, nBlockSize);	
						
					}
					else{
						theApp.emuledlg->AddLogLine(false,GetResString(IDS_ERR_CORRUPTCOMPRPKG),reqfile->GetFileName(),result);
						reqfile->RemoveBlockFromList(cur_block->block->StartOffset,cur_block->block->StartOffset+1);
					}
					delete[] unpack;
d751 2
a752 1
					delete cur_block->buffer;
a753 1
					free(blockbuffer);
d755 2
d760 2
d765 95
d861 4
a864 1
	EMULE_CATCH
d867 1
a867 1
uint32 CUpDownClient::CalculateDownloadRate()
d894 1
a934 1

d939 1
a939 1
	POSITION   SwapToPos = (POSITION)NULL;
d945 2
a946 1
				if (SwapTo == (CPartFile*)NULL || (!bManualChange && SwapTo->GetPriority() < cur_file->GetPriority())) {
d952 1
a952 1
		if (SwapToPos != (POSITION)NULL) m_OtherRequests_list.RemoveAt(SwapToPos);
d959 2
a960 1
				if (SwapTo == (CPartFile*)NULL || (!bManualChange && SwapTo->GetPriority() < cur_file->GetPriority())) {
d966 1
a966 1
		if (SwapToPos != (POSITION)NULL) m_OtherNoNeeded_list.RemoveAt(SwapToPos);
d979 2
a980 2
		// Lord KiRon
      	if (!theApp.downloadqueue->CheckAndAddKnownSource(SwapTo,this)) 
a986 1

d988 1
a988 2

		return false;
a993 1

a997 1

a1003 1

a1008 1

a1014 1

d1019 1
a1027 1

a1028 1

d1034 2
d1037 20
d1059 1
@


1.1
log
@*** empty log message ***
@
text
@d844 2
d847 1
a847 1
	   !theApp.serverconnect->IsLowID() && !HasLowID() && !(socket && socket->IsConnected())) {
@

