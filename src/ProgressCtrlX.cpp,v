head	1.9;
access;
symbols
	PublicRelease_1_2e:1.9
	Interim_Release_1-2e_RC1:1.9
	PublicRelease_1_2d:1.9
	Interim_Release_1-2d_RC1:1.8
	Interim_Release_1-2d_beta1:1.8
	PublicRelease_1_2c:1.8
	Interim_Release_1-2c_RC1:1.8
	Interim_Release_1-2c_beta1:1.8
	PublicRelease_1_2b:1.8
	Interim_Release_1-2b_RC1:1.8
	PublicRelease_1_2a:1.8
	Interim_Release_1-2a_RC1:1.8
	Interim_Release_1-2a_beta2:1.8
	Interim_Release_1-2a_beta1:1.8
	PublicRelease_1_2:1.8
	Interim_Release_1-2_RC1:1.8
	Interim_Release_1-2_beta1:1.8
	PublicRelease_1_1g:1.8
	Interim_Release_1-1g_RC3:1.8
	Interim_Release_1-1g_RC2:1.8
	Interim_Release_1-1g_RC1:1.8
	Interim_Release_1-1g_beta2:1.7
	Interim_Release_1-1g_beta1:1.7
	PublicRelease_1_1f:1.7
	Interim_Release_1-1f_RC1:1.7
	PublicRelease_1_1e:1.7
	Interim_Release_1-1e_RC2:1.7
	Interim_Release_1-1e_RC1:1.7
	Interim_Release_1-1e_beta1:1.7
	PublicRelease_1_1d:1.6
	Interim_Release_1-1d_RC1:1.6
	PublicRelease_1_1c:1.6
	Interim_Release_1-1c_RC1:1.5
	Interim_Release_1-1c_beta2:1.5
	Interim_Release_1-1c_beta1:1.5
	PublicRelease_1_1b:1.5
	Interim_Release_1-1b_RC1:1.5
	PublicRelease_1_1a:1.5
	Interim_Release_1-1a_RC2:1.5
	Interim_Release_1-1a_RC1:1.5
	Interim_Release_1-1a_beta2:1.5
	Interim_Release_1-1a_beta1:1.5
	PublicRelease_1_1:1.5
	Interim_Release_1-1_beta1:1.5
	PublicRelease_1o:1.5
	Interim_Release_1o_RC1:1.5
	Interim_Release_1o_beta1:1.5
	PublicRelease_1n:1.5
	Interim_Release_1n_RC2:1.5
	Interim_Release_1n_RC1:1.5
	Interim_Release_1n_beta2:1.5
	Interim_Release_1n_beta1:1.5
	PublicRelease_1m:1.5
	Interim_Release_1m_beta1:1.5
	PublicRelease_1l:1.5
	Interim_Release_1l_RC3:1.5
	Interim_Release_1l_RC2:1.5
	Interim_Release_1l_RC1:1.5
	Interim_Release_1l_beta2:1.5
	Interim_Release_1l_beta1:1.5
	PublicRelease_1k:1.5
	Interim_Release_1k_RC4:1.5
	Interim_1k_RC3:1.5
	Interim_1k_RC2:1.5
	Interim_Release_1k_RC1:1.5
	Interim_Release_1k_beta5:1.5
	Intrerim_Release_1k_beta4:1.5
	Interim_Release_1k_beta1:1.5
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.5
	Interim_Release_1j_RC1:1.5
	Interim_Release_1j_beta2:1.5
	Interim_Release_1j_beta1:1.5
	PublicRelease_1i:1.5
	Interim_Release_1i_RC6:1.5
	Interim_Release_1i_RC3:1.5
	Interim_Release_1i_RC2:1.5
	Interim_Release_1i_RC1:1.5
	Interim_Release_1i_beta3:1.5
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.3
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.9
date	2008.04.24.04.42.18;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.21.20.09.57;	author aw3;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.01.02.26.49;	author katsyonak;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.15.13.41.13;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Suppressed compiler warnings; Removed meaningless brush set around FillRect.
@
text
@///////////////////////////////////////////////////////////////////////////////
// class CProgressCtrlX
//
// Author:  Yury Goltsman
// email:   ygprg@@go.to
// page:    http://go.to/ygprg
// Copyright © 2000, Yury Goltsman
//
// This code provided "AS IS," without warranty of any kind.
// You may freely use or modify this code provided this
// Copyright is included in all derived versions.
//
// version : 1.1
// Added multi-color gradient
// Added filling with brush for background and bar(overrides color settings)
// Added borders attribute
// Added vertical text support
// Added snake mode
// Added reverse mode
// Added dual color for text
// Added text formatting
// Added tied mode for text and rubber bar mode
// Added support for vertical oriented control(PBS_VERTICAL)
// 
// version : 1.0
//

#include "stdafx.h"
#include "ProgressCtrlX.h"
#include "emule.h"

#include "MemDC.h"
#include "DrawGdiX.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrlX

CProgressCtrlX::CProgressCtrlX()
	: m_rcBorders(0, 0, 0, 0)
{
	// Init colors
	m_clrBk = ::GetSysColor(COLOR_BTNFACE);
	m_clrTextOnBar = ::GetSysColor(COLOR_CAPTIONTEXT);
	m_clrTextOnBk = ::GetSysColor(COLOR_BTNTEXT);
	
	// set gradient colors
	COLORREF	clrStart, clrEnd =	clrStart = ::GetSysColor(COLOR_ACTIVECAPTION);

#if (WINVER >= 0x0500)
	BOOL	bGradientCaption = FALSE;

	if (SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, &bGradientCaption, 0) && bGradientCaption)
		clrEnd = ::GetSysColor(COLOR_GRADIENTACTIVECAPTION);
#endif /* WINVER >= 0x0500 */
	SetGradientColors(clrStart, clrEnd);

	m_nStep = 10;	// according msdn
	m_nTail = 0;
	m_nTailSize = 40;
	m_pbrBk = m_pbrBar = NULL;
}

BEGIN_MESSAGE_MAP(CProgressCtrlX, CProgressCtrl)
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	ON_MESSAGE(PBM_SETBARCOLOR, OnSetBarColor)
	ON_MESSAGE(PBM_SETBKCOLOR, OnSetBkColor)
	ON_MESSAGE(PBM_SETPOS, OnSetPos)
	ON_MESSAGE(PBM_DELTAPOS, OnDeltaPos)
	ON_MESSAGE(PBM_STEPIT, OnStepIt)
	ON_MESSAGE(PBM_SETSTEP, OnSetStep)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrlX message handlers

BOOL CProgressCtrlX::OnEraseBkgnd(CDC* pDC) 
{
	NOPRM(pDC);
	return TRUE; // erase in OnPaint()
}

void CProgressCtrlX::OnPaint() 
{
	CPaintDC	dc(this); // device context for painting
	CDrawInfo	info;
	RECT		Rect;

	GetClientRect(&info.rcClient);

	// retrieve current position and range
	info.nCurPos = GetPos();
	GetRange(info.nLower, info.nUpper);
	dc.GetClipBox(&Rect);
	
	// Draw to memory DC
	COLORREF	crBk = dc.GetBkColor();
	CMemDC		memDC(&dc, &Rect, crBk, crBk);

	info.pDC = &memDC;
	
	if (g_App.m_pMDlg->m_themeHelper.IsAppThemed())
	{
		memDC.DrawEdge(&info.rcClient, EDGE_SUNKEN, BF_RECT);
		info.rcClient.DeflateRect(1, 1);
	}

	// fill background 
	if (m_pbrBk != NULL)
		memDC.FillRect(&info.rcClient, m_pbrBk);
	else
		memDC.FillSolidRect(&info.rcClient, m_clrBk);

	// apply borders
	info.rcClient.DeflateRect(m_rcBorders);
		
	// if current pos is out of range return
	if (info.nCurPos < info.nLower || info.nCurPos > info.nUpper)
		return;

	info.dwStyle = GetStyle();

	BOOL		bVert = info.dwStyle&PBS_VERTICAL;
	BOOL		bSnake = info.dwStyle&PBS_SNAKE;
	BOOL		bRubberBar = info.dwStyle&PBS_RUBBER_BAR;

	// calculate visible gradient width
	CRect		rcBar(0, 0, 0, 0);
	CRect		rcMax(0, 0, 0, 0), rcTmp;

	rcMax.right = bVert ? info.rcClient.Height() : info.rcClient.Width();
	rcBar.right = static_cast<int>(static_cast<double>(info.nCurPos - info.nLower) * rcMax.right / ((info.nUpper - info.nLower == 0) ? 1 : info.nUpper - info.nLower));
	if (bSnake)
		rcBar.left = static_cast<int>(static_cast<double>(m_nTail - info.nLower) * rcMax.right / ((info.nUpper - info.nLower == 0) ? 1 : info.nUpper - info.nLower));
	
	// draw bar
	if (m_pbrBar != NULL)
		memDC.FillRect(ConvertToReal(rcTmp, info, rcBar), m_pbrBar);
	else
		DrawMultiGradient(info, bRubberBar ? rcBar : rcMax, rcBar);

	// Draw text
	DrawText(info, rcMax, rcBar);

	// Do not call CProgressCtrl::OnPaint() for painting messages
}

void CProgressCtrlX::DrawMultiGradient(const CDrawInfo& info, const CRect &rcGrad, const CRect &rcClip)
{
	int			nSteps = m_ardwGradColors.GetSize() - 1;
	double		nWidthPerStep = static_cast<double>(rcGrad.Width()) / nSteps;
	CRect		rcGradBand(rcGrad);

	for (int i = 0; i < nSteps; i++) 
	{
		rcGradBand.left = rcGrad.left + (int)(nWidthPerStep * i);
		rcGradBand.right = rcGrad.left + (int)(nWidthPerStep * (i + 1));
		if (i == nSteps - 1)	//last step (because of problems with double)
			rcGradBand.right = rcGrad.right;

		if (rcGradBand.right < rcClip.left)
			continue; // skip - band before cliping rect
		
		CRect	rcClipBand(rcGradBand);

		if (rcClipBand.left < rcClip.left)
			rcClipBand.left = rcClip.left;
		if (rcClipBand.right > rcClip.right)
			rcClipBand.right = rcClip.right;

		DrawGradient(info, rcGradBand, rcClipBand, m_ardwGradColors[i], m_ardwGradColors[i + 1]);

		if(rcClipBand.right == rcClip.right)
			break; // stop filling - next band is out of clipping rect
	}
}

void CProgressCtrlX::DrawGradient(const CDrawInfo& info, const CRect &rcGrad, const CRect &rcClip, COLORREF clrStart, COLORREF clrEnd)
{
	// Split colors to RGB chanels, find chanel with maximum difference 
	// between the start and end colors. This distance will determine 
	// number of steps of gradient
	int		r = (GetRValue(clrEnd) - GetRValue(clrStart));
	int		g = (GetGValue(clrEnd) - GetGValue(clrStart));
	int		b = (GetBValue(clrEnd) - GetBValue(clrStart));
	int		nSteps = max(abs(r), max(abs(g), abs(b)));

	// if number of pixels in gradient less than number of steps - 
	// use it as numberof steps
	int		nPixels = rcGrad.Width();

	nSteps = min(nPixels, nSteps);
	if (nSteps == 0)
		nSteps = 1;

	double	rStep = static_cast<double>(r) / nSteps;
	double	gStep = static_cast<double>(g) / nSteps;
	double	bStep = static_cast<double>(b) / nSteps;

	r = GetRValue(clrStart);
	g = GetGValue(clrStart);
	b = GetBValue(clrStart);

	BOOL	fLowColor = info.pDC->GetDeviceCaps(RASTERCAPS) & RC_PALETTE;

	if ((!fLowColor && nSteps > 1) && (info.pDC->GetDeviceCaps(BITSPIXEL) * info.pDC->GetDeviceCaps(PLANES) < 8))
		nSteps = 1; // for 16 colors no gradient

	double	nWidthPerStep = static_cast<double>(rcGrad.Width()) / nSteps;
	CRect	rcFill(rcGrad), rcTmp;

	// Start filling
	for (int i = 0; i < nSteps; i++) 
	{
		rcFill.left = rcGrad.left + (int)(nWidthPerStep * i);
		rcFill.right = rcGrad.left + (int)(nWidthPerStep * (i + 1));
		if(i == nSteps-1)	//last step (because of problems with double)
			rcFill.right = rcGrad.right;

		if (rcFill.right < rcClip.left)
			continue; // skip - band before cliping rect
		
		// clip it
		if (rcFill.left < rcClip.left)
			rcFill.left = rcClip.left;
		if (rcFill.right > rcClip.right)
			rcFill.right = rcClip.right;

		COLORREF	clrFill = RGB(r + (int)(i * rStep),
		                       g + (int)(i * gStep),
		                       b + (int)(i * bStep));
		if (fLowColor)
		{
			CBrush		br;

			br.CreateSolidBrush(clrFill);
			// CDC::FillSolidRect is faster, but it does not handle 8-bit color depth

			info.pDC->FillRect(ConvertToReal(rcTmp, info, rcFill), &br);
		}
		else
			info.pDC->FillSolidRect(ConvertToReal(rcTmp, info, rcFill), clrFill);
		if (rcFill.right >= rcClip.right)
			break; // stop filling if we reach current position
	}
}

void CProgressCtrlX::DrawText(const CDrawInfo& info, const CRect &rcMax, const CRect &rcBar)
{
	if (!(info.dwStyle&PBS_TEXTMASK))
		return;

	BOOL		fVert = info.dwStyle&PBS_VERTICAL;
	CDC			*pDC = info.pDC;
	int			nValue = 0;
	CString		sFormat;

	GetWindowText(sFormat);
	switch (info.dwStyle&PBS_TEXTMASK)
	{
		case PBS_SHOW_PERCENT:
			if(sFormat.IsEmpty())
				sFormat = _T("%d%%");
			// retrieve current position and range
			nValue = static_cast<int>(static_cast<double>(info.nCurPos - info.nLower) * 100 / ((info.nUpper - info.nLower == 0) ? 1 : info.nUpper - info.nLower));
			break;
		case PBS_SHOW_POSITION:
			if (sFormat.IsEmpty())
				sFormat = _T("%d");
			// retrieve current position
			nValue = info.nCurPos;
			break;
	}

	if (sFormat.IsEmpty())
		return;

	CFont			*pFont = GetFont();
	CSelFont		sf(pDC, pFont);
	CSelTextColor	tc(pDC, m_clrTextOnBar);
	CSelBkMode		bm(pDC, TRANSPARENT);
	CSelTextAlign	ta(pDC, TA_BOTTOM|TA_CENTER);
	CPoint			ptOrg = pDC->GetWindowOrg();
	CString			sText;

	sText.Format(sFormat, nValue);
	
	LONG			grad = 0;

	if (pFont)
	{
		LOGFONT		lf;

		pFont->GetLogFont(&lf);
		grad = lf.lfEscapement / 10;
	}
	int				x = 0, y = 0, dx = 0, dy = 0;
	CSize			sizText = pDC->GetTextExtent(sText);

	if (grad == 0)
	{
		x = sizText.cx;
		y = sizText.cy;
		dy = sizText.cy;
	}
	else if (grad == 90)
	{
		x = sizText.cy;
		y = sizText.cx;
		dx = sizText.cy;
	}
	else if (grad == 180)
	{
		x = sizText.cx;
		y = sizText.cy;
		dy = -sizText.cy;
	}
	else if (grad == 270)
	{
		x = sizText.cy;
		y = sizText.cx;
		dx = -sizText.cy;
	}
	else
		ASSERT(0); // angle not supported
#if 0
	// required "math.h"
	double		pi = 3.1415926535;
	double		rad = grad * pi / 180;

	dx = sz.cy * sin(rad);
	dy = sz.cy * cos(rad);
#endif
	CPoint		pt = pDC->GetViewportOrg();

	if (info.dwStyle&PBS_TIED_TEXT)
	{
		CRect	rcFill;

		ConvertToReal(rcFill, info, rcBar);
		if ((fVert ? y : x) <= rcBar.Width())
		{
			pDC->SetViewportOrg(rcFill.left + (rcFill.Width() + dx) / 2,
													rcFill.top + (rcFill.Height() + dy) / 2);
			DrawClippedText(info, rcBar, sText, ptOrg);
		}
	}
	else
	{
		pDC->SetViewportOrg(info.rcClient.left + (info.rcClient.Width() + dx) / 2,
												info.rcClient.top + (info.rcClient.Height() + dy) / 2);
		if (m_clrTextOnBar == m_clrTextOnBk)
			// if the same color for bar and background draw text once
			DrawClippedText(info, rcMax, sText, ptOrg);
		else
		{	
			// else, draw clipped parts of text
			
			// draw text on gradient
			if (rcBar.left != rcBar.right)
				DrawClippedText(info, rcBar, sText, ptOrg);

			// draw text out of gradient
			if (rcMax.right > rcBar.right)
			{
				tc.Select(m_clrTextOnBk);
				
				CRect		rc(rcMax);

				rc.left = rcBar.right;
				DrawClippedText(info, rc, sText, ptOrg);
			}
			if (rcMax.left < rcBar.left)
			{
				tc.Select(m_clrTextOnBk);

				CRect		rc(rcMax);

				rc.right = rcBar.left;
				DrawClippedText(info, rc, sText, ptOrg);
			}
		}
	}
	pDC->SetViewportOrg(pt);
}

void CProgressCtrlX::DrawClippedText(const CDrawInfo& info, const CRect& rcClip, CString& sText, const CPoint& ptWndOrg)
{
	CDC		*pDC = info.pDC;
	CRgn	rgn;
	CRect	rc;

	ConvertToReal(rc, info, rcClip);
	rc.OffsetRect(-ptWndOrg);
	rgn.CreateRectRgn(rc.left, rc.top, rc.right, rc.bottom);
	pDC->SelectClipRgn(&rgn);
	pDC->TextOut (0, 0, sText);
	rgn.DeleteObject();
}

LRESULT CProgressCtrlX::OnSetBarColor(WPARAM clrEnd, LPARAM clrStart)
{
	SetGradientColors(clrStart, clrEnd ? clrEnd : clrStart);

	return CLR_DEFAULT;
}

LRESULT CProgressCtrlX::OnSetBkColor(WPARAM, LPARAM clrBk)
{
	m_clrBk = clrBk;
	return CLR_DEFAULT;
}

LRESULT CProgressCtrlX::OnSetStep(WPARAM nStepInc, LPARAM)
{
	m_nStep = nStepInc;
	return Default();
}

LRESULT CProgressCtrlX::OnSetPos(WPARAM newPos, LPARAM)
{
	int		nOldPos;

	if (SetSnakePos(nOldPos, newPos))
		return nOldPos;

	return Default();
}

LRESULT CProgressCtrlX::OnDeltaPos(WPARAM nIncrement, LPARAM)
{
	int		nOldPos;

	if (SetSnakePos(nOldPos, nIncrement, TRUE))
		return nOldPos;

	return Default();
}

LRESULT CProgressCtrlX::OnStepIt(WPARAM, LPARAM)
{
	int		nOldPos;

	if (SetSnakePos(nOldPos, m_nStep, TRUE))
		return nOldPos;

	return Default();
}

/////////////////////////////////////////////////////////////////////////////
// CProgressCtrlX implementation

BOOL CProgressCtrlX::SetSnakePos(int& nOldPos, int nNewPos, BOOL fIncrement)
{
	DWORD	dwStyle = GetStyle();

	if (!(dwStyle&PBS_SNAKE))
		return FALSE;
	
	int		nLower, nUpper;

	GetRange(nLower, nUpper);
	if (fIncrement)
	{
		int		nCurPos = GetPos();

		if (nCurPos == nUpper && nCurPos - m_nTail < m_nTailSize)
			nCurPos = m_nTail + m_nTailSize;
		nNewPos = nCurPos + abs(nNewPos);
	}
	if (nNewPos > nUpper+m_nTailSize)
	{
		nNewPos -= nUpper-nLower + m_nTailSize;
		if (nNewPos > nUpper + m_nTailSize)
		{
			ASSERT(0); // too far - reset
			nNewPos = nUpper + m_nTailSize;
		}
		if (dwStyle&PBS_REVERSE)
			ModifyStyle(PBS_REVERSE, 0);
		else
			ModifyStyle(0, PBS_REVERSE);
	}
	else if (nNewPos >= nUpper)
		Invalidate();
	
	m_nTail = nNewPos - m_nTailSize;
	if (m_nTail < nLower)
		m_nTail = nLower;

	nOldPos = DefWindowProc(PBM_SETPOS, nNewPos, 0);
	return TRUE;
}

void CProgressCtrlX::SetTextFormat(LPCTSTR szFormat, DWORD ffFormat)
{
	ASSERT(::IsWindow(m_hWnd));
	
	if (!szFormat || !szFormat[0] || !ffFormat)
	{
		ModifyStyle(PBS_TEXTMASK, 0);
		SetWindowText(_T(""));
	}
	else
	{
		ModifyStyle(PBS_TEXTMASK, ffFormat);
		SetWindowText(szFormat);
	}
}

const CRect* CProgressCtrlX::ConvertToReal(CRect &rcRet, const CDrawInfo &info, const CRect &rcVirt)
{
	BOOL	bReverse = info.dwStyle&PBS_REVERSE;
	BOOL	bVert = info.dwStyle&PBS_VERTICAL;

	rcRet = info.rcClient;
	if (bVert)
	{
		rcRet.top = info.rcClient.top + 
		         (bReverse ? rcVirt.left : (info.rcClient.Height() - rcVirt.right));
		rcRet.bottom = rcRet.top + rcVirt.Width();
	}
	else
	{
		rcRet.left = info.rcClient.left + 
		          (bReverse ? (info.rcClient.Width() - rcVirt.right) : rcVirt.left);
		rcRet.right = rcRet.left + rcVirt.Width();
	}
	return &rcRet;
}

void CProgressCtrlX::SetGradientColorsX(int nCount, COLORREF clrFirst, COLORREF clrNext, ...)
{ 
	m_ardwGradColors.SetSize(nCount); 
	
	m_ardwGradColors.SetAt(0, clrFirst); 
	m_ardwGradColors.SetAt(1, clrNext);  

	va_list		pArgs;

	va_start(pArgs, clrNext);
	for (int i = 2; i < nCount; i++)
		m_ardwGradColors.SetAt(i, va_arg(pArgs, COLORREF));
	va_end(pArgs);
}
@


1.8
log
@renamed 3 variables
@
text
@a69 1
	//{{AFX_MSG_MAP(CProgressCtrlX)
a77 1
	//}}AFX_MSG_MAP
d85 1
d135 1
a135 1
	CRect		rcMax(0, 0, 0, 0);
d144 1
a144 1
		memDC.FillRect(&ConvertToReal(info, rcBar), m_pbrBar);
d216 1
a216 1
	CRect	rcFill(rcGrad);
a243 1
			CBrush		*pOldBrush = info.pDC->SelectObject(&br);
d245 1
a245 3
			info.pDC->FillRect(&ConvertToReal(info, rcFill), &br);
			info.pDC->SelectObject(pOldBrush);
			br.DeleteObject();
d248 1
a248 1
			info.pDC->FillSolidRect(&ConvertToReal(info, rcFill), clrFill);
d344 1
a344 1
		CRect	rcFill(ConvertToReal(info, rcBar));
d346 1
d397 1
a397 1
	CRect	rc = ConvertToReal(info, rcClip);
d399 1
d517 1
a517 1
CRect CProgressCtrlX::ConvertToReal(const CDrawInfo& info, const CRect& rcVirt)
a520 1
	CRect	rc(info.rcClient);
d522 1
d525 1
a525 1
		rc.top = info.rcClient.top + 
d527 1
a527 1
		rc.bottom = rc.top + rcVirt.Width();
d531 1
a531 1
		rc.left = info.rcClient.left + 
d533 1
a533 1
		rc.right = rc.left + rcVirt.Width();
d535 1
a535 1
	return rc;
@


1.7
log
@Changed interface for CMemDC.
@
text
@d109 1
a109 1
	if (g_eMuleApp.m_pdlgEmule->m_themeHelper.IsAppThemed())
@


1.6
log
@Fixed Shared Files progress indicators borders in a themed Windows environment + Formatting.
@
text
@d94 1
d101 1
d104 2
a105 1
	CMemDC		memDC(&dc);
@


1.5
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d30 1
d45 1
a45 1
	: m_rcBorders(0,0,0,0)
d48 1
a48 1
	m_clrBk = ::GetSysColor(COLOR_3DFACE);
d53 6
a58 6
	COLORREF clrStart, clrEnd;
	clrStart = clrEnd = ::GetSysColor(COLOR_ACTIVECAPTION);
#if(WINVER >= 0x0500)
	BOOL fGradientCaption = FALSE;
	if(SystemParametersInfo(SPI_GETGRADIENTCAPTIONS, 0, &fGradientCaption, 0) &&
	   fGradientCaption)
d92 2
a93 1
	CPaintDC dc(this); // device context for painting
a94 1
	CDrawInfo info;
d102 2
a103 1
	CMemDC memDC(&dc);
d106 6
d113 1
a113 1
	if(m_pbrBk)
d126 4
a129 3
	BOOL fVert = info.dwStyle&PBS_VERTICAL;
	BOOL fSnake = info.dwStyle&PBS_SNAKE;
	BOOL fRubberBar = info.dwStyle&PBS_RUBBER_BAR;
d132 7
a138 6
	CRect rcBar(0,0,0,0);
	CRect rcMax(0,0,0,0);
	rcMax.right = fVert ? info.rcClient.Height() : info.rcClient.Width();
	rcBar.right = static_cast<int>(static_cast<double>(info.nCurPos-info.nLower) * rcMax.right / ((info.nUpper-info.nLower == 0) ? 1 : info.nUpper-info.nLower));
	if(fSnake)
		rcBar.left = static_cast<int>(static_cast<double>(m_nTail-info.nLower) * rcMax.right / ((info.nUpper-info.nLower == 0) ? 1 : info.nUpper-info.nLower));
d141 1
a141 1
	if(m_pbrBar)
d144 1
a144 1
		DrawMultiGradient(info, fRubberBar ? rcBar : rcMax, rcBar);
d154 4
a157 3
	int nSteps = m_ardwGradColors.GetSize()-1;
	double nWidthPerStep = static_cast<double>(rcGrad.Width()) / nSteps;
	CRect rcGradBand(rcGrad);
d161 2
a162 2
		rcGradBand.right = rcGrad.left + (int)(nWidthPerStep * (i+1));
		if(i == nSteps-1)	//last step (because of problems with double)
d165 1
a165 1
		if(rcGradBand.right < rcClip.left)
d168 3
a170 2
		CRect rcClipBand(rcGradBand);
		if(rcClipBand.left < rcClip.left)
d172 1
a172 1
		if(rcClipBand.right > rcClip.right)
d175 1
a175 1
		DrawGradient(info, rcGradBand, rcClipBand, m_ardwGradColors[i], m_ardwGradColors[i+1]);
d187 5
a191 4
	int r = (GetRValue(clrEnd) - GetRValue(clrStart));
	int g = (GetGValue(clrEnd) - GetGValue(clrStart));
	int b = (GetBValue(clrEnd) - GetBValue(clrStart));
	int nSteps = max(abs(r), max(abs(g), abs(b)));
d194 2
a195 1
	int nPixels = rcGrad.Width();
d197 2
a198 1
	if(nSteps == 0) nSteps = 1;
d200 3
a202 3
	double rStep = static_cast<double>(r)/nSteps;
	double gStep = static_cast<double>(g)/nSteps;
	double bStep = static_cast<double>(b)/nSteps;
d208 7
a214 4
	BOOL fLowColor = info.pDC->GetDeviceCaps(RASTERCAPS) & RC_PALETTE;
	if(!fLowColor && nSteps > 1)
		if(info.pDC->GetDeviceCaps(BITSPIXEL)*info.pDC->GetDeviceCaps(PLANES) < 8)
			nSteps = 1; // for 16 colors no gradient
a215 2
	double nWidthPerStep = static_cast<double>(rcGrad.Width()) / nSteps;
	CRect rcFill(rcGrad);
d220 1
a220 1
		rcFill.right = rcGrad.left + (int)(nWidthPerStep * (i+1));
d224 1
a224 1
		if(rcFill.right < rcClip.left)
d228 1
a228 1
		if(rcFill.left < rcClip.left)
d230 1
a230 1
		if(rcFill.right > rcClip.right)
d233 1
a233 1
		COLORREF clrFill = RGB(r + (int)(i * rStep),
d236 1
a236 1
		if(fLowColor)
d238 2
a239 1
			CBrush br;
d242 2
a243 1
			CBrush* pOldBrush = info.pDC->SelectObject(&br);	//eklmn: select a new brush
d245 1
a245 1
			info.pDC->SelectObject(pOldBrush);	//eklmn: recover an old brush
d250 1
a250 1
		if(rcFill.right >= rcClip.right)
d257 1
a257 1
	if(!(info.dwStyle&PBS_TEXTMASK))
d259 6
a264 4
	BOOL fVert = info.dwStyle&PBS_VERTICAL;
	CDC *pDC = info.pDC;
	int nValue = 0;
	CString sFormat;
d266 1
a266 1
	switch(info.dwStyle&PBS_TEXTMASK)
d270 1
a270 1
				sFormat = "%d%%";
d272 1
a272 1
			nValue = static_cast<int>(static_cast<double>(info.nCurPos-info.nLower) * 100 / ((info.nUpper-info.nLower == 0) ? 1 : info.nUpper-info.nLower));
d275 2
a276 2
			if(sFormat.IsEmpty())
				sFormat = "%d";
d285 4
a288 4
	CFont* pFont = GetFont();
	CSelFont sf(pDC, pFont);
	CSelTextColor tc(pDC, m_clrTextOnBar);
	CSelBkMode bm(pDC, TRANSPARENT);
d290 3
a292 2
  CPoint ptOrg = pDC->GetWindowOrg();
	CString sText;
d295 3
a297 2
	LONG grad = 0;
	if(pFont)
d299 2
a300 1
		LOGFONT lf;
d302 1
a302 1
		grad = lf.lfEscapement/10;
d304 29
a332 7
	int x = 0, y = 0, dx = 0, dy = 0;
	CSize sizText = pDC->GetTextExtent(sText);
	if(grad == 0)         {	x = sizText.cx; y = sizText.cy; dx = 0; dy = sizText.cy;}
	else if(grad == 90)   {	x = sizText.cy; y = sizText.cx; dx = sizText.cy; dy = 0;}
	else if(grad == 180)  {	x = sizText.cx; y = sizText.cy; dx = 0; dy = -sizText.cy;}
	else if(grad == 270)  {	x = sizText.cy; y = sizText.cx; dx = -sizText.cy; dy = 0;}
	else ASSERT(0); // angle not supported
d335 5
a339 4
	double pi = 3.1415926535;
	double rad = grad*pi/180;
	dx = sz.cy*sin(rad);
	dy = sz.cy*cos(rad);
d341 3
a343 2
	CPoint pt = pDC->GetViewportOrg();
	if(info.dwStyle&PBS_TIED_TEXT)
d345 3
a347 2
		CRect rcFill(ConvertToReal(info, rcBar));
		if((fVert ? y : x) <= rcBar.Width())
d349 2
a350 2
			pDC->SetViewportOrg(rcFill.left + (rcFill.Width() + dx)/2, 
													rcFill.top + (rcFill.Height() + dy)/2);
d356 3
a358 3
		pDC->SetViewportOrg(info.rcClient.left + (info.rcClient.Width() + dx)/2, 
												info.rcClient.top + (info.rcClient.Height() + dy)/2);
		if(m_clrTextOnBar == m_clrTextOnBk)
d366 1
a366 1
			if(rcBar.left != rcBar.right)
d370 1
a370 1
			if(rcMax.right > rcBar.right)
d373 3
a375 1
				CRect rc(rcMax);
d379 1
a379 1
			if(rcMax.left < rcBar.left)
d382 3
a384 1
				CRect rc(rcMax);
d395 4
a398 3
	CDC *pDC = info.pDC;
	CRgn rgn;
	CRect rc = ConvertToReal(info, rcClip);
d427 3
a429 2
	int nOldPos;
	if(SetSnakePos(nOldPos, newPos))
d437 3
a439 2
	int nOldPos;
	if(SetSnakePos(nOldPos, nIncrement, TRUE))
d447 3
a449 2
	int nOldPos;
	if(SetSnakePos(nOldPos, m_nStep, TRUE))
d460 3
a462 2
	DWORD dwStyle = GetStyle();
	if(!(dwStyle&PBS_SNAKE))
d465 2
a466 1
	int nLower, nUpper;
d468 1
a468 1
	if(fIncrement)
d470 3
a472 2
		int nCurPos = GetPos();
		if(nCurPos == nUpper && nCurPos - m_nTail < m_nTailSize )
d476 1
a476 1
	if(nNewPos > nUpper+m_nTailSize)
d479 1
a479 1
		if(nNewPos > nUpper + m_nTailSize)
d484 1
a484 1
		if(dwStyle&PBS_REVERSE)
d489 1
a489 1
	else if(nNewPos >= nUpper)
d493 1
a493 1
	if(m_nTail < nLower)
d504 1
a504 1
	if(!szFormat || !szFormat[0] || !ffFormat)
d518 3
a520 2
	BOOL fReverse = info.dwStyle&PBS_REVERSE;
	BOOL fVert = info.dwStyle&PBS_VERTICAL;
d522 1
a522 2
	CRect rc(info.rcClient);
	if(fVert)
d525 1
a525 1
		         (fReverse ? rcVirt.left : (info.rcClient.Height() - rcVirt.right));
d531 1
a531 1
		          (fReverse ? (info.rcClient.Width() - rcVirt.right) : rcVirt.left);
d544 4
a547 3
  va_list pArgs;
  va_start(pArgs, clrNext);
	for(int i = 2; i < nCount; i++)
d549 1
a549 1
	va_end( pArgs );
@


1.4
log
@Formatting, comments, and name changes.
@
text
@d126 1
a126 1
	rcBar.right = (int)((float)(info.nCurPos-info.nLower) * rcMax.right / ((info.nUpper-info.nLower == 0) ? 1 : info.nUpper-info.nLower));
d128 1
a128 1
		rcBar.left = (int)((float)(m_nTail-info.nLower) * rcMax.right / ((info.nUpper-info.nLower == 0) ? 1 : info.nUpper-info.nLower));
d145 1
a145 1
	float nWidthPerStep = (float)rcGrad.Width() / nSteps;
d151 1
a151 1
		if(i == nSteps-1)	//last step (because of problems with float)
d185 3
a187 3
	float rStep = (float)r/nSteps;
	float gStep = (float)g/nSteps;
	float bStep = (float)b/nSteps;
d198 1
a198 1
	float nWidthPerStep = (float)rcGrad.Width() / nSteps;
d205 1
a205 1
		if(i == nSteps-1)	//last step (because of problems with float)
d252 1
a252 1
			nValue = (int)((float)(info.nCurPos-info.nLower) * 100 / ((info.nUpper-info.nLower == 0) ? 1 : info.nUpper-info.nLower));
@


1.3
log
@an incorrect use of GDI resources (CBrush class)
@
text
@a85 1
	// TODO: Add your message handler code here and/or call default
a92 1
	// TODO: Add your message handler code here
@


1.2
log
@unicode cleanup
@
text
@a201 1
	CBrush br;
d224 1
d227 1
d229 1
@


1.1
log
@*** empty log message ***
@
text
@d448 1
a448 1
		SetWindowText("");
@


1.1.4.1
log
@updating this branch...
@
text
@@

