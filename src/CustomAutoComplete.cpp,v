head	1.5;
access;
symbols
	PublicRelease_1_2e:1.5
	Interim_Release_1-2e_RC1:1.5
	PublicRelease_1_2d:1.5
	Interim_Release_1-2d_RC1:1.5
	Interim_Release_1-2d_beta1:1.5
	PublicRelease_1_2c:1.5
	Interim_Release_1-2c_RC1:1.5
	Interim_Release_1-2c_beta1:1.5
	PublicRelease_1_2b:1.5
	Interim_Release_1-2b_RC1:1.5
	PublicRelease_1_2a:1.5
	Interim_Release_1-2a_RC1:1.5
	Interim_Release_1-2a_beta2:1.5
	Interim_Release_1-2a_beta1:1.5
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.3
	Interim_Release_1-1g_RC3:1.3
	Interim_Release_1-1g_RC2:1.3
	Interim_Release_1-1g_RC1:1.3
	Interim_Release_1-1g_beta2:1.3
	Interim_Release_1-1g_beta1:1.3
	PublicRelease_1_1f:1.3
	Interim_Release_1-1f_RC1:1.3
	PublicRelease_1_1e:1.3
	Interim_Release_1-1e_RC2:1.3
	Interim_Release_1-1e_RC1:1.3
	Interim_Release_1-1e_beta1:1.3
	PublicRelease_1_1d:1.3
	Interim_Release_1-1d_RC1:1.3
	PublicRelease_1_1c:1.3
	Interim_Release_1-1c_RC1:1.3
	Interim_Release_1-1c_beta2:1.3
	Interim_Release_1-1c_beta1:1.3
	PublicRelease_1_1b:1.3
	Interim_Release_1-1b_RC1:1.3
	PublicRelease_1_1a:1.3
	Interim_Release_1-1a_RC2:1.3
	Interim_Release_1-1a_RC1:1.3
	Interim_Release_1-1a_beta2:1.3
	Interim_Release_1-1a_beta1:1.3
	PublicRelease_1_1:1.3
	Interim_Release_1-1_beta1:1.3
	PublicRelease_1o:1.3
	Interim_Release_1o_RC1:1.3
	Interim_Release_1o_beta1:1.3
	PublicRelease_1n:1.3
	Interim_Release_1n_RC2:1.3
	Interim_Release_1n_RC1:1.3
	Interim_Release_1n_beta2:1.3
	Interim_Release_1n_beta1:1.3
	PublicRelease_1m:1.3
	Interim_Release_1m_beta1:1.3
	PublicRelease_1l:1.3
	Interim_Release_1l_RC3:1.3
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1;
locks; strict;
comment	@// @;


1.5
date	2006.04.17.00.11.13;	author kush_eplus;	state Exp;
branches;
next	1.4;

1.4
date	2005.12.29.05.34.52;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2004.06.08.06.26.49;	author katsyonak;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.18.11.12.51;	author katsyonak;	state Exp;
branches;
next	1.1;

1.1
date	2003.11.04.16.09.18;	author katsyonak;	state Exp;
branches;
next	;


desc
@@


1.5
log
@UNICODE preparations; optimizations; formattings.
@
text
@//--------------------------------------------------------------------------------------------
//  Name:           CCustomAutoComplete (CCUSTOMAUTOCOMPLETE.H)
//  Type:           Wrapper class
//  Description:    Matches IAutoComplete, IEnumString and the registry (optional) to provide
//					custom auto-complete functionality for EDIT controls - including those in
//					combo boxes - in WTL projects.
//
//  Author:         Klaus H. Probst [kprobst@@vbbox.com]
//  URL:            http://www.vbbox.com/
//  Copyright:      This work is copyright © 2002, Klaus H. Probst
//  Usage:          You may use this code as you see fit, provided that you assume all
//                  responsibilities for doing so.
//  Distribution:   Distribute freely as long as you maintain this notice as part of the
//					file header.
//
//
//  Updates:        09-Mai-2003 [bluecow]:
//						- changed original string list code to deal with a LRU list
//						  and auto cleanup of list entries according 'iMaxItemCount'.
//						- splitted original code into cpp/h file
//						- removed registry stuff
//						- added file stuff
//					15-Jan-2004 [Ornis]:
//						- changed adding strings to replace existing ones on a new position
//
//
//  Notes:
//
//
//  Dependencies:
//
//					The usual ATL/WTL headers for a normal EXE, plus <atlmisc.h>
//
//--------------------------------------------------------------------------------------------
#include "stdafx.h"
#include "CustomAutoComplete.h"
#include <share.h>
#include <fcntl.h>
#include <io.h>
#include "otherfunctions.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CCustomAutoComplete::CCustomAutoComplete()
{
	InternalInit();
}

CCustomAutoComplete::CCustomAutoComplete(const CStringArray &astrItemList)
{
	InternalInit();
	SetList(astrItemList);
}

CCustomAutoComplete::~CCustomAutoComplete()
{
	if (m_pac != NULL)
		m_pac.Release();
}

BOOL CCustomAutoComplete::Bind(HWND hWndEdit, DWORD dwOptions, LPCTSTR pcFormatString)
{
	ATLASSERT(::IsWindow(hWndEdit));

	if (m_bBound || m_pac != NULL)
		return FALSE;

	if (SUCCEEDED(m_pac.CoCreateInstance(CLSID_AutoComplete)))
	{
		if (dwOptions != 0)
		{
			CComQIPtr<IAutoComplete2> pAC2(m_pac);

			if (pAC2 != NULL)
			{
				pAC2->SetOptions(dwOptions);
				pAC2.Release();
			}
		}

		USES_CONVERSION;
		if (SUCCEEDED(m_pac->Init(hWndEdit, this, NULL, CT2CW(pcFormatString))))
		{
			m_bBound = TRUE;

			return TRUE;
		}
	}

	return FALSE;
}

VOID CCustomAutoComplete::Unbind()
{
	if (!m_bBound)
		return;

	if (m_pac != NULL)
	{
		m_pac.Release();
		m_bBound = FALSE;
	}
}

BOOL CCustomAutoComplete::SetList(const CStringArray &astrItemList)
{
	ATLASSERT(astrItemList.GetSize() != 0);

	Clear();
	m_asList.Append(astrItemList);

	return TRUE;
}

int CCustomAutoComplete::FindItem(const CString &strItem)
{
	for (int i = 0; i < m_asList.GetCount(); i++)
		if (m_asList[i].Compare(strItem) == 0)
			return i;
	return -1;
}

BOOL CCustomAutoComplete::AddItem(const CString &strItem, int iPos)
{
	if (!strItem.IsEmpty())
	{
		int	iOldPos = FindItem(strItem);

		if (iOldPos == -1)
		{
		//	Use a LRU list
			if (iPos == -1)
				m_asList.Add(strItem);
			else
				m_asList.InsertAt(iPos, strItem);

			while (m_asList.GetSize() > m_iMaxItemCount)
				m_asList.RemoveAt(m_asList.GetSize() - 1);

			return TRUE;
		}
		else if (iPos != -1)
		{
			m_asList.RemoveAt(iOldPos);
			if (iOldPos < iPos)
				--iPos;
			m_asList.InsertAt(iPos, strItem);

			while (m_asList.GetSize() > m_iMaxItemCount)
				m_asList.RemoveAt(m_asList.GetSize() - 1);

			return TRUE;
		}
	}
	return FALSE;
}

int CCustomAutoComplete::GetItemCount()
{
	return static_cast<int>(m_asList.GetCount());
}

BOOL CCustomAutoComplete::RemoveItem(const CString &strItem)
{
	if (!strItem.IsEmpty())
	{
		int	iPos = FindItem(strItem);

		if (iPos != -1)
		{
			m_asList.RemoveAt(iPos);
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CCustomAutoComplete::Clear()
{
	if (!m_asList.IsEmpty())
	{
		m_asList.RemoveAll();

		return TRUE;
	}

	return FALSE;
}

BOOL CCustomAutoComplete::Disable()
{
	if (m_pac == NULL || !m_bBound)
		return FALSE;

	return SUCCEEDED(EnDisable(FALSE));
}

BOOL CCustomAutoComplete::Enable(VOID)
{
	if (m_pac == NULL || m_bBound)
		return FALSE;

	return SUCCEEDED(EnDisable(TRUE));
}

const CStringArray& CCustomAutoComplete::GetList() const
{
	return m_asList;
}

STDMETHODIMP_(ULONG) CCustomAutoComplete::AddRef()
{
	ULONG	uiCount = ::InterlockedIncrement(reinterpret_cast<LONG*>(&m_uiRefCount));

	return uiCount;
}

STDMETHODIMP_(ULONG) CCustomAutoComplete::Release()
{
	ULONG	uiCount = static_cast<ULONG>(::InterlockedDecrement(reinterpret_cast<LONG*>(&m_uiRefCount)));

	if (uiCount == 0)
		delete this;

	return uiCount;
}

STDMETHODIMP CCustomAutoComplete::QueryInterface(REFIID riid, void **ppvObject)
{
	HRESULT	hr = E_NOINTERFACE;

	if (ppvObject != NULL)
	{
		*ppvObject = NULL;

		if (IID_IUnknown == riid)
			*ppvObject = static_cast<IUnknown*>(this);
		else if (IID_IEnumString == riid)
			*ppvObject = static_cast<IEnumString*>(this);
		if (*ppvObject != NULL)
		{
			hr = S_OK;
			static_cast<LPUNKNOWN>(*ppvObject)->AddRef();
		}
	}
	else
		hr = E_POINTER;

	return hr;
}

STDMETHODIMP CCustomAutoComplete::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
	USES_CONVERSION;

	HRESULT	hr = S_FALSE;
	ULONG	ui;

	if (celt == 0)
		celt = 1;

	for (ui = 0; ui < celt; ui++)
	{
		if (m_uiCurrentElement == static_cast<ULONG>(m_asList.GetSize()))
			break;

		rgelt[ui] = (LPWSTR)::CoTaskMemAlloc((ULONG) sizeof(WCHAR) * (m_asList[m_uiCurrentElement].GetLength() + 1));
		wcscpy(rgelt[ui], T2CW(m_asList[m_uiCurrentElement]));

		if (pceltFetched != NULL)
			*pceltFetched++;

		m_uiCurrentElement++;
	}

	if (ui == celt)
		hr = S_OK;

	return hr;
}

STDMETHODIMP CCustomAutoComplete::Skip(ULONG celt)
{
	m_uiCurrentElement += celt;

	if (m_uiCurrentElement > static_cast<ULONG>(m_asList.GetSize()))
		m_uiCurrentElement = 0;

	return S_OK;
}

STDMETHODIMP CCustomAutoComplete::Reset(void)
{
	m_uiCurrentElement = 0;

	return S_OK;
}

STDMETHODIMP CCustomAutoComplete::Clone(IEnumString **ppenum)
{
	if (ppenum == NULL)
		return E_POINTER;

	CCustomAutoComplete	*pnew = new CCustomAutoComplete();

	pnew->AddRef();
	*ppenum = pnew;

	return S_OK;
}

void CCustomAutoComplete::InternalInit()
{
	m_uiCurrentElement = 0;
	m_uiRefCount = 0;
	m_bBound = FALSE;
	m_iMaxItemCount = 30;
}

HRESULT CCustomAutoComplete::EnDisable(BOOL bEnable)
{
	ATLASSERT(m_pac);

	HRESULT	hr = m_pac->Enable(bEnable);

	if (SUCCEEDED(hr))
		m_bBound = bEnable;

	return hr;
}

BOOL CCustomAutoComplete::LoadList(LPCTSTR pcFileName)
{
#ifdef _UNICODE
	FILE	*fp = _tfsopen(pcFileName, _T("rb"), _SH_DENYWR);
#else
	FILE	*fp = _tfsopen(pcFileName, _T("r"), _SH_DENYWR);
#endif

	if (fp == NULL)
		return FALSE;

#ifdef _UNICODE
//	Verify Unicode byte-order mark 0xFEFF
	WORD	wBOM = fgetwc(fp);

//	If not UNICODE file, set reading to ASCII mode
	if (wBOM != 0xFEFF)
	{
		_setmode(_fileno(fp), _O_TEXT);
		fseek(fp, 0, SEEK_SET);
	}

#endif
	CString strItem;

	while (_fgetts(strItem.GetBufferSetLength(256), 256, fp) != NULL)
	{
		strItem.ReleaseBuffer();
		strItem.Trim(_T(" \r\n"));
		AddItem(strItem, -1);
	}

	fclose(fp);

	return TRUE;
}

BOOL CCustomAutoComplete::SaveList(LPCTSTR pcFileName)
{
#ifdef _UNICODE
	FILE	*fp = _tfsopen(pcFileName, _T("wb"), _SH_DENYWR);
#else
	FILE	*fp = _tfsopen(pcFileName, _T("w"), _SH_DENYWR);
#endif

	if (fp == NULL)
		return FALSE;

#ifdef _UNICODE
//	Write Unicode byte-order mark 0xFEFF
	fputwc(0xFEFF, fp);

#endif
	for (int i = 0; i < m_asList.GetCount(); i++)
#ifdef _UNICODE
		_ftprintf(fp, _T("%s\r\n"), m_asList[i]);
#else
		_ftprintf(fp, _T("%s\n"), m_asList[i]);
#endif
	fclose(fp);

	return (ferror(fp) == 0);
}

CString CCustomAutoComplete::GetItem(int iPos)
{
	return (iPos < m_asList.GetCount()) ? m_asList.GetAt(iPos) : NULL;
}@


1.4
log
@Compatibility with VC2005 [brengarne].
@
text
@d17 1
a17 1
//  Updates:        09-Mai-2003 [bluecow]: 
d27 1
a27 1
//  Notes:			
d37 3
d53 1
a53 1
CCustomAutoComplete::CCustomAutoComplete(const CStringArray& p_sItemList)
d56 1
a56 1
	SetList(p_sItemList);
d61 1
a61 1
	if (m_pac)
d65 1
a65 1
BOOL CCustomAutoComplete::Bind(HWND p_hWndEdit, DWORD p_dwOptions, LPCTSTR p_lpszFormatString)
d67 3
a69 2
	ATLASSERT(::IsWindow(p_hWndEdit));
	if ((m_fBound) || (m_pac))
d72 1
a72 3
	HRESULT		hr = m_pac.CoCreateInstance(CLSID_AutoComplete);

	if (SUCCEEDED(hr))
d74 1
a74 1
		if (p_dwOptions)
d77 2
a78 1
			if (pAC2)
d80 1
a80 1
				pAC2->SetOptions(p_dwOptions);
d86 1
a86 1
		if (SUCCEEDED(hr = m_pac->Init(p_hWndEdit, this, NULL, T2W(p_lpszFormatString))))
d88 1
a88 1
			m_fBound = TRUE;
d99 1
a99 1
	if (!m_fBound)
d102 1
a102 1
	if (m_pac)
d105 1
a105 1
		m_fBound = FALSE;
d109 1
a109 1
BOOL CCustomAutoComplete::SetList(const CStringArray& p_sItemList)
d111 2
a112 1
	ATLASSERT(p_sItemList.GetSize() != 0);
d114 1
a114 1
	m_asList.Append(p_sItemList);
d119 1
a119 1
int CCustomAutoComplete::FindItem(const CString& rstr)
d122 1
a122 1
		if (m_asList[i].Compare(rstr) == 0)
d127 1
a127 1
BOOL CCustomAutoComplete::AddItem(const CString& p_sItem, int iPos)
d129 1
a129 1
	if (p_sItem.GetLength() != 0)
d131 1
a131 1
		int		iOldPos = FindItem(p_sItem);
d135 1
a135 1
			// use a LRU list
d137 1
a137 1
				m_asList.Add(p_sItem);
d139 1
a139 1
				m_asList.InsertAt(iPos, p_sItem);
d151 1
a151 1
			m_asList.InsertAt(iPos, p_sItem);
d164 1
a164 1
	return (int)m_asList.GetCount();
d167 1
a167 1
BOOL CCustomAutoComplete::RemoveItem(const CString& p_sItem)
d169 1
a169 1
	if (p_sItem.GetLength() != 0)
d171 1
a171 1
		int		iPos = FindItem(p_sItem);
d186 1
a186 1
	if (m_asList.GetSize() != 0)
d198 1
a198 1
	if ((!m_pac) || (!m_fBound))
d206 1
a206 1
	if ((!m_pac) || (m_fBound))
a216 3
//
//	IUnknown implementation
//
d219 1
a219 1
	ULONG		nCount = ::InterlockedIncrement(reinterpret_cast<LONG*>(&m_nRefCount));
d221 1
a221 1
	return nCount;
d226 1
a226 1
	ULONG		nCount = (ULONG)::InterlockedDecrement(reinterpret_cast<LONG*>(&m_nRefCount));
d228 1
a228 1
	if (nCount == 0)
d231 1
a231 1
	return nCount;
d234 1
a234 1
STDMETHODIMP CCustomAutoComplete::QueryInterface(REFIID riid, void** ppvObject)
d236 1
a236 1
	HRESULT		hr = E_NOINTERFACE;
d249 1
a249 1
			((LPUNKNOWN)*ppvObject)->AddRef();
d258 1
a258 4
//
//	IEnumString implementation
//
STDMETHODIMP CCustomAutoComplete::Next(ULONG celt, LPOLESTR* rgelt, ULONG* pceltFetched)
a260 2
	HRESULT		hr = S_FALSE;
	ULONG		i;
d262 4
a265 1
	if (!celt)
d268 1
a268 1
	for (i = 0; i < celt; i++)
d270 1
a270 1
		if (m_nCurrentElement == (ULONG)m_asList.GetSize())
d273 2
a274 2
		rgelt[i] = (LPWSTR)::CoTaskMemAlloc((ULONG) sizeof(WCHAR) * (m_asList[m_nCurrentElement].GetLength() + 1));
		wcscpy(rgelt[i], T2W(m_asList[m_nCurrentElement]));
d276 1
a276 1
		if (pceltFetched)
d278 2
a279 2
		
		m_nCurrentElement++;
d282 1
a282 1
	if (i == celt)
d290 1
a290 1
	m_nCurrentElement += celt;
d292 2
a293 2
	if (m_nCurrentElement > (ULONG)m_asList.GetSize())
		m_nCurrentElement = 0;
d300 1
a300 1
	m_nCurrentElement = 0;
d305 1
a305 1
STDMETHODIMP CCustomAutoComplete::Clone(IEnumString** ppenum)
d307 1
a307 1
	if (!ppenum)
d309 2
a310 2
	
	CCustomAutoComplete		*pnew = new CCustomAutoComplete();
d320 3
a322 3
	m_nCurrentElement = 0;
	m_nRefCount = 0;
	m_fBound = FALSE;
d326 1
a326 1
HRESULT CCustomAutoComplete::EnDisable(BOOL p_fEnable)
d330 1
a330 1
	HRESULT		hr = m_pac->Enable(p_fEnable);
d333 1
a333 1
		m_fBound = p_fEnable;
d338 1
a338 1
BOOL CCustomAutoComplete::LoadList(LPCTSTR pszFileName)
d340 5
a344 1
	FILE	*fp = _tfopen(pszFileName, _T("rt"));
d349 3
a351 1
	TCHAR	szItem[256];
d353 2
a354 1
	while (fgets(szItem, ARRSIZE(szItem), fp) != NULL)
d356 6
a361 1
		CString		strItem(szItem);
d363 3
d369 1
d375 1
a375 1
BOOL CCustomAutoComplete::SaveList(LPCTSTR pszFileName)
d377 5
a381 1
	FILE	*fp = _tfopen(pszFileName, _T("wt"));
d386 5
d392 5
a396 1
		fprintf(fp, _T("%s\n"), m_asList[i]);
d399 1
a399 1
	return !ferror(fp);
d402 1
a402 1
CString CCustomAutoComplete::GetItem(int pos)
d404 1
a404 4
	if (pos>=m_asList.GetCount())
		return NULL; 
	else
		return m_asList.GetAt(pos);
@


1.3
log
@minor update
@
text
@d264 1
d269 1
a269 1
	for (ULONG i = 0; i < celt; i++)
@


1.2
log
@minor changes
@
text
@d23 2
d68 2
a69 1
	HRESULT hr = m_pac.CoCreateInstance(CLSID_AutoComplete);
d86 1
d90 1
d98 1
d111 1
d123 1
a123 1
BOOL CCustomAutoComplete::AddItem(CString& p_sItem, int iPos)
d127 3
a129 1
		if (FindItem(p_sItem) == -1)
d135 13
a147 1
				m_asList.InsertAt(0, p_sItem);
d163 1
a163 1
BOOL CCustomAutoComplete::RemoveItem(CString& p_sItem)
d167 2
a168 1
		int iPos = FindItem(p_sItem);
d175 1
d185 1
d188 1
d196 1
d204 1
d218 2
a219 1
	ULONG nCount = ::InterlockedIncrement(reinterpret_cast<LONG*>(&m_nRefCount));
d225 2
a226 2
	ULONG nCount = 0;
	nCount = (ULONG) ::InterlockedDecrement(reinterpret_cast<LONG*>(&m_nRefCount));
d229 1
d235 2
a236 1
	HRESULT hr = E_NOINTERFACE;
d253 1
d263 1
a263 1
	HRESULT hr = S_FALSE;
d267 1
d291 1
d301 1
d310 2
a311 1
	CCustomAutoComplete* pnew = new CCustomAutoComplete();
d314 1
d330 2
a331 1
	HRESULT hr = m_pac->Enable(p_fEnable);
d334 1
d340 2
a341 1
	FILE* fp = _tfopen(pszFileName, _T("rt"));
d345 2
a346 1
	TCHAR szItem[256];
d349 2
a350 1
		CString strItem(szItem);
d355 1
d361 2
a362 1
	FILE* fp = _tfopen(pszFileName, _T("wt"));
d367 1
a367 1
		fprintf(fp, "%s\n", m_asList[i]);
d369 1
d372 8
@


1.1
log
@added auto-complete for search text (search history) from official v0.30c
@
text
@d35 1
a35 2

#define ARRSIZE(x)	(sizeof(x)/sizeof(x[0]))
d69 2
a70 1
		if (p_dwOptions){
d72 2
a73 1
			if (pAC2){
d93 2
a94 1
	if (m_pac){
a221 1
	{
a222 1
	}
d307 2
a308 1
	while (fgets(szItem, ARRSIZE(szItem), fp) != NULL){
@

