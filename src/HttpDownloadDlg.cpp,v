head	1.30;
access;
symbols
	PublicRelease_1_2e:1.30
	Interim_Release_1-2e_RC1:1.30
	PublicRelease_1_2d:1.28
	Interim_Release_1-2d_RC1:1.28
	Interim_Release_1-2d_beta1:1.24
	PublicRelease_1_2c:1.23
	Interim_Release_1-2c_RC1:1.23
	Interim_Release_1-2c_beta1:1.23
	PublicRelease_1_2b:1.23
	Interim_Release_1-2b_RC1:1.23
	PublicRelease_1_2a:1.23
	Interim_Release_1-2a_RC1:1.23
	Interim_Release_1-2a_beta2:1.22
	Interim_Release_1-2a_beta1:1.22
	PublicRelease_1_2:1.21
	Interim_Release_1-2_RC1:1.21
	Interim_Release_1-2_beta1:1.21
	PublicRelease_1_1g:1.21
	Interim_Release_1-1g_RC3:1.21
	Interim_Release_1-1g_RC2:1.20
	Interim_Release_1-1g_RC1:1.20
	Interim_Release_1-1g_beta2:1.18
	Interim_Release_1-1g_beta1:1.18
	PublicRelease_1_1f:1.18
	Interim_Release_1-1f_RC1:1.18
	PublicRelease_1_1e:1.18
	Interim_Release_1-1e_RC2:1.18
	Interim_Release_1-1e_RC1:1.18
	Interim_Release_1-1e_beta1:1.18
	PublicRelease_1_1d:1.18
	Interim_Release_1-1d_RC1:1.18
	PublicRelease_1_1c:1.18
	Interim_Release_1-1c_RC1:1.18
	Interim_Release_1-1c_beta2:1.18
	Interim_Release_1-1c_beta1:1.18
	PublicRelease_1_1b:1.18
	Interim_Release_1-1b_RC1:1.18
	PublicRelease_1_1a:1.18
	Interim_Release_1-1a_RC2:1.18
	Interim_Release_1-1a_RC1:1.18
	Interim_Release_1-1a_beta2:1.18
	Interim_Release_1-1a_beta1:1.18
	PublicRelease_1_1:1.16
	Interim_Release_1-1_beta1:1.16
	PublicRelease_1o:1.15
	Interim_Release_1o_RC1:1.15
	Interim_Release_1o_beta1:1.15
	PublicRelease_1n:1.15
	Interim_Release_1n_RC2:1.15
	Interim_Release_1n_RC1:1.15
	Interim_Release_1n_beta2:1.15
	Interim_Release_1n_beta1:1.15
	PublicRelease_1m:1.15
	Interim_Release_1m_beta1:1.15
	PublicRelease_1l:1.15
	Interim_Release_1l_RC3:1.15
	Interim_Release_1l_RC2:1.15
	Interim_Release_1l_RC1:1.15
	Interim_Release_1l_beta2:1.15
	Interim_Release_1l_beta1:1.14
	PublicRelease_1k:1.12
	Interim_Release_1k_RC4:1.12
	Interim_1k_RC3:1.12
	Interim_1k_RC2:1.12
	Interim_Release_1k_RC1:1.12
	Interim_Release_1k_beta5:1.12
	Intrerim_Release_1k_beta4:1.12
	Interim_Release_1k_beta1:1.11
	PublicRelease_1j:1.10
	Interim_Release_1J_RC3:1.10
	Interim_Release_1j_RC3:1.10
	Interim_Release_1j_RC2:1.10
	Interim_Release_1j_RC1:1.10
	Interim_Release_1j_beta2:1.10
	Interim_Release_1j_beta1:1.10
	PublicRelease_1i:1.10
	Interim_Release_1i_RC6:1.10
	Interim_Release_1i_RC3:1.10
	Interim_Release_1i_RC2:1.10
	Interim_Release_1i_RC1:1.10
	Interim_Release_1i_beta3:1.10
	Interim_Release_1i_beta2:1.9
	Interim_Release_1i_beta1:1.8
	PublicRelease_1h:1.7
	Interim_Release_1h_rc2:1.7
	Interim_Release_1h_RC1:1.7
	Interim_Release_1h_beta2:1.7
	Interim_Release_1h_beta1_now:1.7
	Interim_Release_1h_beta1:1.7
	PublicRelease_1g:1.7
	Interim_Release_1g_RC6_Final:1.7
	Interim_Release_1g_RC6:1.7
	Interim_Release_1g_RC5:1.7
	Interim_Release_1g_RC4:1.7
	Interim_Release_1g_RC3:1.7
	Interim_Release_1g_beta2:1.6
	Interim_Release_1g_beta1:1.6
	Interim_Release_1f_RC4:1.6
	Interim_Release_1f_RC3:1.6
	Interim_Release_1f_RC2:1.6
	Interim_Release_1f_RC:1.6
	Interim_Release_1f_beta2:1.6
	Interim_Release_1f_beta1:1.6
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.4
	Interim_Release_1e_beta2_before_kuchin:1.4
	Interim_Release_1e_beta1:1.4
	PublicRelease_1c:1.4
	featurestest:1.4.0.4
	Interim_Release_1c_RC:1.4
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.4
	Interim_Release_1b_beta2:1.4
	Interim_Release_1b_beta1:1.4
	proxydeadlake:1.3.0.10
	PublicRelease_1a:1.3
	Interim_Release_1a_beta2:1.3
	BerkeleyDb:1.3.0.8
	Interim_Release_1a_beta1:1.3
	PublicRelease_1:1.3
	goldfish:1.3
	eMulePlus_1_RC2:1.3
	eMulePlus_26b_1RC1:1.3
	PreRelease_26b_i0e:1.3
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.3
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.3.0.6
	plus26based:1.3.0.4
	Interim_Release_25b_i0b:1.3
	Proxy_Dev:1.3
	Interim_Release_25b_i0a:1.3.2.1
	proxytest:1.3.2.1.0.2
	official_sockets:1.3.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.30
date	2009.03.08.02.59.07;	author aw3;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.04.21.36.42;	author aw3;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.03.04.38.38;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2008.03.01.19.40.08;	author eklmn;	state Exp;
branches;
next	1.26;

1.26
date	2008.03.01.11.02.34;	author eklmn;	state Exp;
branches;
next	1.25;

1.25
date	2008.03.01.06.34.22;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.31.22.50.30;	author eklmn;	state Exp;
branches;
next	1.23;

1.23
date	2006.09.06.05.56.02;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2006.03.26.18.03.18;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.19.03.32.34;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.24.04.27.28;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2004.10.23.11.01.09;	author dongato;	state Exp;
branches;
next	1.16;

1.16
date	2004.10.07.04.36.27;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2004.05.19.10.14.24;	author netwolf1;	state Exp;
branches;
next	1.14;

1.14
date	2004.04.20.23.25.21;	author dropf;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.10.16.57.23;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.23.13.33.24;	author kush_eplus;	state Exp;
branches;
next	1.11;

1.11
date	2004.02.04.23.59.59;	author kush_eplus;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.06.21.57.05;	author puritynn666;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.19.07.47.47;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.04.14.13.24;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.24.15.36.45;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.02.18.29.41;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.24.22.07.48;	author maverick65;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.01.23.12.49.06;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.18;	author cax2;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.28.16.54.10;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Fixed garbled text on HTTP download status window for IE7 (from original) {muleteer}.
@
text
@/*
Module : HTTPDOWNLOADDLG.CPP
Purpose: Defines the implementation for an MFC dialog which performs HTTP downloads
         similiar to the Internet Explorer download dialog
Created: PJN / 14-11-1999
History: PJN / 25-01-2000 1. Fixed a problem where server authentication was not being detected correctly,
                          while proxy authentication was being handled.
                          2. Updated the way and periodicity certain UI controls are updated during the
                          HTTP download

Copyright (c) 1999 - 2000 by PJ Naughter.
All rights reserved.


*/

/////////////////////////////////  Includes  //////////////////////////////////
#include "stdafx.h"
#include "resource.h"
#include "HttpDownloadDlg.h"
#include "emule.h"

///////////////////////////////// Defines /////////////////////////////////////
#define HAS_ZLIB
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const UINT WM_HTTPDOWNLOAD_THREAD_FINISHED = WM_APP + 1;


////////////////////////////////////// gzip ///////////////////////////////////
//in the spirit of zlib, lets do something horrible with defines ;)
#ifdef HAS_ZLIB

#include "zlib/zlib.h"

static int const gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

static int get_byte(HINTERNET m_hHttpFile) {
	unsigned char c;
	DWORD dwBytesRead;
	BOOL b = ::InternetReadFile(m_hHttpFile, &c, 1, &dwBytesRead);
	if(!b)
		return EOF;
	else
		return c;
}

static int check_header(z_stream *stream, HINTERNET m_hHttpFile) {
	int method; /* method byte */
	int flags;  /* flags byte */
	uInt len;
	int c;

	/* Check the gzip magic header */
	for(len = 0; len < 2; len++) {
		c = get_byte(m_hHttpFile);
		if(c != gz_magic[len]) {
			if(len != 0) stream->avail_in++, stream->next_in--;
			if(c != EOF) {
				stream->avail_in++, stream->next_in--;
				//do not support transparent streams
				return stream->avail_in != 0 ? Z_DATA_ERROR : Z_STREAM_END;
			}
			return stream->avail_in != 0 ? Z_OK : Z_STREAM_END;
		}
	}
	method = get_byte(m_hHttpFile);
	flags = get_byte(m_hHttpFile);
	if(method != Z_DEFLATED || (flags & RESERVED) != 0)
		return Z_DATA_ERROR;

	/* Discard time, xflags and OS code: */
	for(len = 0; len < 6; len++) (void)get_byte(m_hHttpFile);

	if((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
		len  =  (uInt)get_byte(m_hHttpFile);
		len += ((uInt)get_byte(m_hHttpFile))<<8;
		/* len is garbage if EOF but the loop below will quit anyway */
		while(len-- != 0 && get_byte(m_hHttpFile) != EOF) ;
	}
	if((flags & ORIG_NAME) != 0) { /* skip the original file name */
		while((c = get_byte(m_hHttpFile)) != 0 && c != EOF) ;
	}
	if((flags & COMMENT) != 0) {   /* skip the .gz file comment */
		while((c = get_byte(m_hHttpFile)) != 0 && c != EOF) ;
	}
	if((flags & HEAD_CRC) != 0) {  /* skip the header crc */
		for(len = 0; len < 2; len++) (void)get_byte(m_hHttpFile);
	}
	//return Z_DATA_ERROR if we hit EOF?
	return Z_OK;
}

#define ACCEPT_ENCODING_HEADER _T("Accept-Encoding: gzip, x-gzip, identity, *;q=0\r\n")
#define ENCODING_CLEAN_UP      if(bEncodedWithGZIP) inflateEnd(&zs)

#define ENCODING_INIT          BOOL bEncodedWithGZIP = FALSE;               \
                               z_stream zs;                                 \
                               unsigned char cBufferGZIP[1024 * 8]

#define PREPARE_DECODER                                                     \
  if(bEncodedWithGZIP) {                                                    \
    zs.next_out = cBufferGZIP;                                              \
    zs.zalloc = (alloc_func)0;                                              \
    zs.zfree = (free_func)0;                                                \
    zs.opaque = (voidpf)0;                                                  \
    zs.next_in = (unsigned char*)szReadBuf;                                 \
    zs.next_out = Z_NULL;                                                   \
    zs.avail_in = 0;                                                        \
	zs.avail_out = sizeof(szReadBuf);                                       \
                                                                            \
    VERIFY(inflateInit2(&zs, -MAX_WBITS) == Z_OK);                          \
    int result = check_header(&zs, m_hHttpFile);                            \
    if(result != Z_OK) {                                                    \
      TRACE(_T("An exception occured while decoding the download file\n")); \
      HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE);      \
      inflateEnd(&zs);									                    \
    }                                                                       \
  }

#define DECODE_DATA(CFILE, DATA, LEN)                                       \
  if(bEncodedWithGZIP) {                                                    \
    zs.next_in = (unsigned char*)DATA;                                      \
    zs.avail_in = LEN;                                                      \
    int iResult;                                                            \
    do {                                                                    \
      zs.total_out = 0;                                                     \
      zs.next_out = cBufferGZIP;                                            \
      zs.avail_out = 1024;                                                  \
      iResult = inflate(&zs, Z_SYNC_FLUSH);                                 \
      CFILE.Write(cBufferGZIP, zs.total_out);                               \
      if(iResult == Z_STREAM_ERROR || iResult == Z_DATA_ERROR) {            \
        TRACE(_T("An exception occured while decoding the download file\n"));\
        HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE);    \
        ENCODING_CLEAN_UP;                                                  \
        return;                                                             \
      }                                                                     \
    } while(iResult == Z_OK && zs.avail_out == 0);                          \
  } else                                                                    \
    CFILE.Write(DATA, LEN)

#else

#define ACCEPT_ENCODING_HEADER _T("Accept-Encoding: identity, *;q=0\r\n")

#define ENCODING_CLEAN_UP ((void)0)

#define ENCODING_INIT ((void)0)

#define PREPARE_DECODER ((void)0)

#define DECODE_DATA(CFILE, DATA, LEN) CFILE.Write(DATA, LEN)

#endif


///////////////////////////////// Implementation //////////////////////////////
IMPLEMENT_DYNAMIC(CHttpDownloadDlg, CDialog);



CHttpDownloadDlg::CHttpDownloadDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CHttpDownloadDlg::IDD, pParent)
{
	m_hInternetSession = NULL;
	m_hHttpConnection = NULL;
	m_hHttpFile = NULL;
	m_bAbort = FALSE;
	m_bSafeToClose = FALSE;
	m_pThread = NULL;
	m_strInitializingTitle = _T("");
	m_nIDPercentage = IDS_HTTPDOWNLOAD_OF;
}

void CHttpDownloadDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Control(pDX, IDC_STATUS, m_ctrlStatus);
	DDX_Control(pDX, IDC_TRANSFER_RATE, m_ctrlTransferRate);
	DDX_Control(pDX, IDC_TIMELEFT, m_ctrlTimeLeft);
	DDX_Control(pDX, IDC_PROGRESS1, m_ctrlProgress);
	DDX_Control(pDX, IDC_FILESTATUS, m_ctrlFileStatus);
	DDX_Control(pDX, IDC_ANIMATE1, m_ctrlAnimate);
}

BEGIN_MESSAGE_MAP(CHttpDownloadDlg, CDialog)
	ON_WM_DESTROY()
	ON_WM_CLOSE()
	ON_MESSAGE(WM_HTTPDOWNLOAD_THREAD_FINISHED, OnThreadFinished)
END_MESSAGE_MAP()


LRESULT CHttpDownloadDlg::OnThreadFinished(WPARAM wParam, LPARAM /*lParam*/)
{
	//It's now safe to close since the thread has signaled us
	m_bSafeToClose = TRUE;

	//Stop the animation
	m_ctrlAnimate.Stop();
	Sleep(1000);
	//If an error occured display the message box
	if (m_bAbort)
		EndDialog(IDCANCEL);
	else if (wParam)
	{
		//AfxMessageBox(m_sError);
		EndDialog(IDCANCEL);
	}
	else
		EndDialog(IDOK);

	return 0L;
}

BOOL CHttpDownloadDlg::OnInitDialog()
{
	static const uint16 s_auResTbl[][2] =
	{
		{ IDCANCEL, IDS_CANCEL },
		{ IDC_STATIC_ESTTIME, IDS_DLCOL_REMAININGTIME },
		{ IDC_STATIC_TRATE, IDS_INFLST_USER_AVERAGEDOWNRATE }
	};
	CString	strTmp;

	for (unsigned ui = 0; ui < ARRSIZE(s_auResTbl); ui++)
		SetDlgItemText(s_auResTbl[ui][0], GetResString(s_auResTbl[ui][1]));
	SetWindowText(m_strInitializingTitle);

	//Let the parent class do its thing
	CDialog::OnInitDialog();

	//Setup the animation control
	m_ctrlAnimate.Open(IDR_HTTPDOWNLOAD_ANIMATION);

	//Validate the URL
	ASSERT(m_sURLToDownload.GetLength()); //Did you forget to specify the file to download
	if (!AfxParseURL(m_sURLToDownload, m_dwServiceType, m_sServer, m_sObject, m_uPort))
	{
		//Try sticking "http://" before it
		m_sURLToDownload = _T("http://") + m_sURLToDownload;
		if (!AfxParseURL(m_sURLToDownload, m_dwServiceType, m_sServer, m_sObject, m_uPort))
		{
			TRACE(_T("Failed to parse the URL: %s\n"), m_sURLToDownload);
			EndDialog(IDCANCEL);
			return TRUE;
		}
	}

	//Check to see if the file we are downloading to exists and if
	//it does, then ask the user if they were it overwritten
	CFileStatus fs;
	ASSERT(m_sFileToDownloadInto.GetLength());
	if (CFile::GetStatus(m_sFileToDownloadInto, fs))
	{
		strTmp.Format(GetResString(IDS_HTTPDOWNLOAD_OK_TO_OVERWRITE), m_sFileToDownloadInto);
		if (AfxMessageBox(strTmp, MB_YESNO) != IDYES)
		{
			TRACE(_T("Failed to confirm file overwrite, download aborted\n"));
			EndDialog(IDCANCEL);
			return TRUE;
		}
	}

	//Try and open the file we will download into
	if (!m_FileToWrite.Open(m_sFileToDownloadInto, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite))
	{
		TRACE(_T("Failed to open the file to download into, Error:%d\n"), GetLastError());
		strTmp.Format(GetResString(IDS_HTTPDOWNLOAD_FAIL_FILE_OPEN), ::GetLastError());
		AfxMessageBox(strTmp);
		EndDialog(IDCANCEL);
		return TRUE;
	}

	//Pull out just the filename component
	int nSlash = m_sObject.ReverseFind(_T('/'));
	if (nSlash == -1)
		nSlash = m_sObject.ReverseFind(_T('\\'));
	if (nSlash != -1 && m_sObject.GetLength() > 1)
		m_sFilename = m_sObject.Right(m_sObject.GetLength() - nSlash - 1);
	else
		m_sFilename = m_sObject;

	//Set the file status text
	strTmp.Format(GetResString(IDS_HTTPDOWNLOAD_OF), m_sFilename, m_sServer);
	m_ctrlFileStatus.SetWindowText(strTmp);

	//Spin off the background thread which will do the actual downloading
	m_pThread = AfxBeginThread(_DownloadThread, this, THREAD_PRIORITY_NORMAL+ g_App.m_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
	if (m_pThread == NULL)
	{
		TRACE(_T("Failed to create download thread, dialog is aborting\n"));
		EndDialog(IDCANCEL);
		return TRUE;
	}
	m_pThread->m_bAutoDelete = FALSE;
	m_pThread->ResumeThread();

	return TRUE;
}

UINT AFX_CDECL CHttpDownloadDlg::_DownloadThread(LPVOID pParam)
{
	//Convert from the SDK world to the C++ world
	CHttpDownloadDlg* pDlg = (CHttpDownloadDlg*) pParam;
	ASSERT(pDlg);
	ASSERT(pDlg->IsKindOf(RUNTIME_CLASS(CHttpDownloadDlg)));

	g_App.m_pPrefs->InitThreadLocale();

	pDlg->DownloadThread();
	return 0;
}

void CHttpDownloadDlg::SetPercentage(int nPercentage)
{
	//Change the progress control
	m_ctrlProgress.SetPos(nPercentage);

	//Change the caption text
	CString sPercentage;
	sPercentage.Format(_T("%d"), nPercentage);
	CString	strCaption;
	strCaption.Format(GetResString(m_nIDPercentage), sPercentage, m_sFilename);
	SetWindowText(strCaption);
}

void CHttpDownloadDlg::SetProgressRange(DWORD dwFileSize)
{
	m_ctrlProgress.SetRange(0, (short)((dwFileSize+512)/1024));
}

void CHttpDownloadDlg::SetProgress(DWORD dwBytesRead)
{
	m_ctrlProgress.SetPos(dwBytesRead/1024);
}

void CHttpDownloadDlg::SetTimeLeft(DWORD dwSecondsLeft, DWORD dwBytesRead, DWORD dwFileSize)
{
	CString	strTimeLeft;

	strTimeLeft.Format( GetResString(IDS_HTTPDOWNLOAD_TIMELEFT),
		CastSecondsToHM(dwSecondsLeft), CastItoXBytes(dwBytesRead), CastItoXBytes(dwFileSize) );
	m_ctrlTimeLeft.SetWindowText(strTimeLeft);
}

void CHttpDownloadDlg::SetStatus(const CString& sCaption)
{
	m_ctrlStatus.SetWindowText(sCaption);
}

void CHttpDownloadDlg::SetStatus(UINT nID)
{
	SetStatus(GetResString(nID));
}

void CHttpDownloadDlg::SetStatus(UINT nID, LPCTSTR lpsz1)
{
	CString strStatus;
	
	strStatus.Format(GetResString(nID), lpsz1);
	SetStatus(strStatus);
}

void CHttpDownloadDlg::SetTransferRate(double KbPerSecond)
{
	CString sRate;

	sRate.Format(_T("%.2f %s"), KbPerSecond, GetResString(IDS_KBYTESEC));
	m_ctrlTransferRate.SetWindowText(sRate);
}

void CHttpDownloadDlg::PlayAnimation()
{
	m_ctrlAnimate.Play(0, (UINT)-1, (UINT)-1);
}

void CHttpDownloadDlg::HandleThreadErrorWithLastError(UINT nIDError, DWORD dwLastError)
{
	//Form the error string to report
	m_sError.Format(GetResString(nIDError), (dwLastError != 0) ? dwLastError : ::GetLastError());

	//Delete the file being downloaded to if it is present
	m_FileToWrite.Close();
	::DeleteFile(m_sFileToDownloadInto);

	PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED, 1);
}

void CHttpDownloadDlg::HandleThreadError(UINT nIDError)
{
	GetResString(&m_sError, nIDError);
	PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED, 1);
}

void CHttpDownloadDlg::DownloadThread()
{
	ENCODING_INIT;
	//Create the Internet session handle
	ASSERT(m_hInternetSession == NULL);
	m_hInternetSession = ::InternetOpen(HTTP_USERAGENT, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (m_hInternetSession == NULL)
	{
		TRACE(_T("Failed in call to InternetOpen, Error:%d\n"), ::GetLastError());
		HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_GENERIC_ERROR);
		return;
	}

	//Should we exit the thread
	if (m_bAbort)
	{
		PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
		return;
	}

	//Setup the status callback function
	if (::InternetSetStatusCallback(m_hInternetSession, _OnStatusCallBack) == INTERNET_INVALID_STATUS_CALLBACK)
	{
		TRACE(_T("Failed in call to InternetSetStatusCallback, Error:%d\n"), ::GetLastError());
		HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_GENERIC_ERROR);
		return;
	}

	//Should we exit the thread
	if (m_bAbort)
	{
		PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
		return;
	}

	//Make the connection to the HTTP server
	ASSERT(m_hHttpConnection == NULL);
	if (m_sUserName.GetLength())
		m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_uPort, m_sUserName,
                                          m_sPassword, m_dwServiceType, 0, (DWORD) this);
	else
		m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_uPort, NULL,
                                          NULL, m_dwServiceType, 0, (DWORD) this);
	if (m_hHttpConnection == NULL)
	{
		TRACE(_T("Failed in call to InternetConnect, Error:%d\n"), ::GetLastError());
		HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_FAIL_CONNECT_SERVER);
		return;
	}

	//Should we exit the thread
	if (m_bAbort)
	{
		PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
		return;
	}

	//Start the animation to signify that the download is taking place
	PlayAnimation();

	//Issue the request to read the file
	LPCTSTR ppszAcceptTypes[2];
	ppszAcceptTypes[0] = _T("*/*");  //We support accepting any mime file type since this is a simple download of a file
	ppszAcceptTypes[1] = NULL;
	ASSERT(m_hHttpFile == NULL);
	m_hHttpFile = HttpOpenRequest(m_hHttpConnection, NULL, m_sObject, NULL, NULL, ppszAcceptTypes, INTERNET_FLAG_RELOAD |
								  INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION, (DWORD)this);
	if (m_hHttpFile == NULL)
	{
		TRACE(_T("Failed in call to HttpOpenRequest, Error:%d\n"), ::GetLastError());
		HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_FAIL_CONNECT_SERVER);
		return;
	}

	//Should we exit the thread
	if (m_bAbort)
	{
		PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
		return;
	}

	//fill in what encoding we support
	HttpAddRequestHeaders(m_hHttpFile, ACCEPT_ENCODING_HEADER, CSTRLEN(ACCEPT_ENCODING_HEADER), HTTP_ADDREQ_FLAG_ADD);

//label used to jump to if we need to resend the request
resend:

	//Issue the request
	BOOL bSend = ::HttpSendRequest(m_hHttpFile, NULL, 0, NULL, 0);
	if (!bSend)
	{
		TRACE(_T("Failed in call to HttpSendRequest, Error:%d\n"), ::GetLastError());
		HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_FAIL_CONNECT_SERVER);
		return;
	}

	//	Check the HTTP status code
	DWORD	dwStatusCode = 0, dwSz = sizeof(dwStatusCode);

	if (!HttpQueryInfo(m_hHttpFile, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &dwStatusCode, &dwSz, NULL))
	{
		TRACE(_T("Failed in call to HttpQueryInfo for HTTP query status code, Error:%d\n"), ::GetLastError());
		HandleThreadError(IDS_HTTPDOWNLOAD_INVALID_SERVER_RESPONSE);
		return;
	}
	else
	{
		//Handle any authentication errors
		if (dwStatusCode == HTTP_STATUS_PROXY_AUTH_REQ || dwStatusCode == HTTP_STATUS_DENIED)
		{
			// We have to read all outstanding data on the Internet handle
			// before we can resubmit request. Just discard the data.
			char szData[51];
			DWORD dwSize;
			do
			{
				::InternetReadFile(m_hHttpFile, (LPVOID)szData, 50, &dwSize);
			}
			while (dwSize != 0);

			//Bring up the standard authentication dialog
			if (::InternetErrorDlg(GetSafeHwnd(), m_hHttpFile, ERROR_INTERNET_INCORRECT_PASSWORD, FLAGS_ERROR_UI_FILTER_FOR_ERRORS |
                             FLAGS_ERROR_UI_FLAGS_GENERATE_DATA | FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS, NULL) == ERROR_INTERNET_FORCE_RETRY)
				goto resend;
		}
		else if (dwStatusCode != HTTP_STATUS_OK)
		{
			TRACE(_T("Failed to retrieve a HTTP 200 status, Status Code:%d\n"), dwStatusCode);
			HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_INVALID_HTTP_RESPONSE, dwStatusCode);
			return;
		}
	}

	//Check to see if any encodings are supported
	TCHAR szContentEncoding[32];
	DWORD dwEncodeStringSize = sizeof(szContentEncoding);
	if(::HttpQueryInfo(m_hHttpFile, HTTP_QUERY_CONTENT_ENCODING, szContentEncoding, &dwEncodeStringSize, NULL))
	{
		if(!_tcsicmp(szContentEncoding, _T("gzip")) || !_tcsicmp(szContentEncoding, _T("x-gzip")))
			bEncodedWithGZIP = TRUE;
	}

	//Update the status control to reflect that we are getting the file information
	SetStatus(IDS_HTTPDOWNLOAD_GETTING_FILE_INFORMATION);

	// Get the length of the file
	DWORD dwFileSize = 0;
	BOOL bGotFileSize = FALSE;

	dwSz = sizeof(dwFileSize);
	if ( ::HttpQueryInfo( m_hHttpFile, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER,
		&dwFileSize, &dwSz, NULL ) && (dwFileSize != 0) )
	{
		//	Set the progress control range
		bGotFileSize = TRUE;
		SetProgressRange(dwFileSize);
	}

	//Update the status to say that we are now downloading the file
	SetStatus(IDS_HTTPDOWNLOAD_RETREIVEING_FILE);

	//Now do the actual read of the file
	DWORD dwStartTicks = ::GetTickCount();
	DWORD dwCurrentTicks = dwStartTicks;
	DWORD dwBytesRead = 0;
	char szReadBuf[1024];
	DWORD dwBytesToRead = 1024;
	DWORD dwTotalBytesRead = 0;
	DWORD dwLastTotalBytes = 0;
	DWORD dwLastPercentage = 0;

	PREPARE_DECODER;
	do
	{
		if (!::InternetReadFile(m_hHttpFile, szReadBuf, dwBytesToRead, &dwBytesRead))
		{
			TRACE(_T("Failed in call to InternetReadFile, Error:%d\n"), ::GetLastError());
			HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE);
			ENCODING_CLEAN_UP;
			return;
		}
		else if (dwBytesRead && !m_bAbort)
		{
			//Write the data to file
			try
			{
				DECODE_DATA(m_FileToWrite, szReadBuf, dwBytesRead);
			}
			catch(CFileException *error)
			{
				TRACE(_T("An exception occured while writing to the download file\n"));
				HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE, error->m_lOsError);
				error->Delete();
				//clean up any encoding data before we return
				ENCODING_CLEAN_UP;
				return;
			}

			//Increment the total number of bytes read
			dwTotalBytesRead += dwBytesRead;

			UpdateControlsDuringTransfer(dwStartTicks, dwCurrentTicks, dwTotalBytesRead, dwLastTotalBytes,
                                     dwLastPercentage, bGotFileSize, dwFileSize);
		}
	}
	while (dwBytesRead && !m_bAbort);

	//clean up any encoding data before we return
	ENCODING_CLEAN_UP;

	//Delete the file being downloaded to if it is present and the download was aborted
	m_FileToWrite.Close();
	if (m_bAbort)
		::DeleteFile(m_sFileToDownloadInto);

	//We're finished
	PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
}

void CHttpDownloadDlg::UpdateControlsDuringTransfer(DWORD dwStartTicks, DWORD& dwCurrentTicks, DWORD dwTotalBytesRead, DWORD& dwLastTotalBytes,
                                                    DWORD& dwLastPercentage, BOOL bGotFileSize, DWORD dwFileSize)
{
	if (bGotFileSize)
	{
		//Update the percentage downloaded in the caption
		DWORD dwPercentage = (DWORD) (dwTotalBytesRead * 100.0 / dwFileSize);
		if (dwPercentage != dwLastPercentage)
		{
			SetPercentage(dwPercentage);
			dwLastPercentage = dwPercentage;

			//Update the progress control bar
			SetProgress(dwTotalBytesRead);
		}
	}

	//Update the transfer rate amd estimated time left every second
	DWORD dwNowTicks = GetTickCount();
	DWORD dwTimeTaken = dwNowTicks - dwCurrentTicks;
	if (dwTimeTaken > 1000)
	{
		double KbPerSecond = ((double)(dwTotalBytesRead) - (double)(dwLastTotalBytes)) / ((double)(dwTimeTaken));
		SetTransferRate(KbPerSecond);

		//Setup for the next time around the loop
		dwCurrentTicks = dwNowTicks;
		dwLastTotalBytes = dwTotalBytesRead;

		if (bGotFileSize)
		{
			//Update the estimated time left
			if (dwTotalBytesRead)
			{
				DWORD dwSecondsLeft = (DWORD) (((double)dwNowTicks - dwStartTicks) / dwTotalBytesRead *
					(dwFileSize - dwTotalBytesRead) / 1000);
				SetTimeLeft(dwSecondsLeft, dwTotalBytesRead, dwFileSize);
			}
		}
	}
}

void CALLBACK CHttpDownloadDlg::_OnStatusCallBack(HINTERNET hInternet, DWORD dwContext, DWORD dwInternetStatus,
                                                  LPVOID lpvStatusInformation, DWORD dwStatusInformationLength)
{
	CHttpDownloadDlg* pDlg = (CHttpDownloadDlg*) dwContext;
	ASSERT(pDlg);
	ASSERT(pDlg->IsKindOf(RUNTIME_CLASS(CHttpDownloadDlg)));
	pDlg->OnStatusCallBack(hInternet, dwInternetStatus, lpvStatusInformation, dwStatusInformationLength);
}

void CHttpDownloadDlg::OnStatusCallBack(HINTERNET /*hInternet*/, DWORD dwInternetStatus,
                                         LPVOID lpvStatusInformation, DWORD dwStatusInformationLength)
{
	UINT	dwResStrId = 0;

	switch (dwInternetStatus)
	{
		case INTERNET_STATUS_RESOLVING_NAME:
			dwResStrId = IDS_HTTPDOWNLOAD_RESOLVING_NAME;
			break;
		case INTERNET_STATUS_NAME_RESOLVED:
			dwResStrId = IDS_HTTPDOWNLOAD_RESOLVED_NAME;
			break;
		case INTERNET_STATUS_CONNECTING_TO_SERVER:
			dwResStrId = IDS_HTTPDOWNLOAD_CONNECTING;
			break;
		case INTERNET_STATUS_CONNECTED_TO_SERVER:
			dwResStrId = IDS_HTTPDOWNLOAD_CONNECTED;
			break;
		case INTERNET_STATUS_REDIRECT:
			dwResStrId = IDS_HTTPDOWNLOAD_REDIRECTING;
			break;
	}
	if (dwResStrId != 0)
	{
		const TCHAR	*pcStr = reinterpret_cast<LPCTSTR>(lpvStatusInformation);	// IE6
		INT			iFlags = IS_TEXT_UNICODE_UNICODE_MASK;
		CString		strBuf;

	// Try to figure out if it is ANSI or Unicode. IE is playing a strange game with that data...
	// In some cases the strings are even encoded as Unicode *with* a trailing NUL-byte, which
	// means that the nr. of bytes in the Unicode string is odd! Thus, the Windows API function
	// 'IsTextUnicode' must not be invoked with 'IS_TEXT_UNICODE_ODD_LENGTH', otherwise it will
	// again give false results.
	// For IE7+:
	// INTERNET_STATUS_RESOLVING_NAME		Unicode: server name
	// INTERNET_STATUS_NAME_RESOLVED		ANSI: IP address
	// INTERNET_STATUS_CONNECTING_TO_SERVER	ANSI: IP address
	// INTERNET_STATUS_CONNECTED_TO_SERVER	ANSI: IP address
		if (IsTextUnicode(lpvStatusInformation, dwStatusInformationLength, &iFlags) == 0)
		{
			strBuf = reinterpret_cast<LPCSTR>(lpvStatusInformation);
			pcStr = strBuf.GetString();
		}
		SetStatus(dwResStrId, pcStr);
	}
}

void CHttpDownloadDlg::OnDestroy()
{
	//Wait for the worker thread to exit
	if (m_pThread)
	{
		WaitForSingleObject(m_pThread->m_hThread, INFINITE);
		delete m_pThread;
		m_pThread = NULL;
	}

	//Free up the internet handles we may be using
	if (m_hHttpFile)
	{
		::InternetCloseHandle(m_hHttpFile);
		m_hHttpFile = NULL;
	}
	if (m_hHttpConnection)
	{
		::InternetCloseHandle(m_hHttpConnection);
		m_hHttpConnection = NULL;
	}
	if (m_hInternetSession)
	{
		::InternetCloseHandle(m_hInternetSession);
		m_hInternetSession = NULL;
	}

	//Let the parent class do its thing
	CDialog::OnDestroy();
}

void CHttpDownloadDlg::OnCancel()
{
	// Asynchronously free up the internet handles we may be using.
	// Otherwise we may get some kind of deadlock situation, because 'InternetConnect'
	// may not return for a very long time...
	if (m_hHttpFile)
	{
		::InternetCloseHandle(m_hHttpFile);
		m_hHttpFile = NULL;
	}
	if (m_hHttpConnection)
	{
		::InternetCloseHandle(m_hHttpConnection);
		m_hHttpConnection = NULL;
	}
	if (m_hInternetSession)
	{
		::InternetCloseHandle(m_hInternetSession);
		m_hInternetSession = NULL;
	}

	//Just set the abort flag to TRUE and
	//disable the cancel button
	m_bAbort = TRUE;
	GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
	SetStatus(IDS_HTTPDOWNLOAD_ABORTING_TRANSFER);
}

void CHttpDownloadDlg::OnClose()
{
	if (m_bSafeToClose)
		CDialog::OnClose();
	else
	{
		//Just set the abort flag to TRUE and
		//disable the cancel button
		m_bAbort = TRUE;
		GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
		SetStatus(IDS_HTTPDOWNLOAD_ABORTING_TRANSFER);
	}
}
@


1.29
log
@Fixed memory leak caused by failed gzipped HTTP download (from original);
Avoid string length calculation for constant string requesting gzip compression; Some formatting.
@
text
@a16 1

d40 1
a40 1
static int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */
d173 1
a189 1
	//{{AFX_DATA_MAP(CHttpDownloadDlg)
a195 1
	//}}AFX_DATA_MAP
a198 1
	//{{AFX_MSG_MAP(CHttpDownloadDlg)
a200 1
	//}}AFX_MSG_MAP
d678 1
a678 1
                                         LPVOID lpvStatusInformation, DWORD /*dwStatusInformationLength*/)
d680 2
d685 1
a685 1
			SetStatus(IDS_HTTPDOWNLOAD_RESOLVING_NAME, (LPCTSTR)lpvStatusInformation);
d688 1
a688 1
			SetStatus(IDS_HTTPDOWNLOAD_RESOLVED_NAME, (LPCTSTR)lpvStatusInformation);
d691 1
a691 1
			SetStatus(IDS_HTTPDOWNLOAD_CONNECTING, (LPCTSTR)lpvStatusInformation);
d694 1
a694 1
			SetStatus(IDS_HTTPDOWNLOAD_CONNECTED, (LPCTSTR)lpvStatusInformation);
d697 1
a697 1
			SetStatus(IDS_HTTPDOWNLOAD_REDIRECTING, (LPCTSTR)lpvStatusInformation);
d700 23
@


1.28
log
@ELEMENT_COUNT -> ARRSIZE.
@
text
@d157 1
a157 1
#define ACCEPT_ENCODING_HEADER "Accept-Encoding: identity, *;q=0\r\n"
d493 1
a493 1
	HttpAddRequestHeaders(m_hHttpFile, ACCEPT_ENCODING_HEADER, (DWORD)-1L, HTTP_ADDREQ_FLAG_ADD);
d589 1
d618 3
a625 3
	//clean up any encoding data before we return
	ENCODING_CLEAN_UP;

a674 1
	//Convert from the SDK C world to the C++ world
a686 1
		{
a688 1
		}
a689 1
		{
a691 1
		}
a692 1
		{
a694 1
		}
a695 1
		{
a697 1
		}
a698 1
		{
a700 5
		}
		default:
		{
			break;
		}
@


1.27
log
@roll back my previous changes
@
text
@d241 1
a241 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auResTbl); ui++)
@


1.26
log
@fixed status output in callback function {thanks to Aw3 & muleteer}
@
text
@d698 1
a698 4
			SOCKADDR *psSocketAddr = reinterpret_cast<SOCKADDR*>(lpvStatusInformation);
			CString strServerName(psSocketAddr->sa_data, sizeof(psSocketAddr->sa_data));

			SetStatus(IDS_HTTPDOWNLOAD_CONNECTING, strServerName.GetString());
d703 1
a703 4
			SOCKADDR *psSocketAddr = reinterpret_cast<SOCKADDR*>(lpvStatusInformation);
			CString strServerName(psSocketAddr->sa_data, sizeof(psSocketAddr->sa_data));

			SetStatus(IDS_HTTPDOWNLOAD_CONNECTED, strServerName.GetString());
@


1.25
log
@HTTP download dialog localization (some strings were loaded using default OS language, not the one specified in the preferences).
@
text
@d698 4
a701 1
			SetStatus(IDS_HTTPDOWNLOAD_CONNECTING, (LPCTSTR)lpvStatusInformation);
d706 4
a709 1
			SetStatus(IDS_HTTPDOWNLOAD_CONNECTED, (LPCTSTR)lpvStatusInformation);
@


1.24
log
@changed the intialization of thread locale
@
text
@d239 1
d271 2
a272 3
		CString sMsg;
		sMsg.Format(GetResString(IDS_HTTPDOWNLOAD_OK_TO_OVERWRITE), m_sFileToDownloadInto);
		if (AfxMessageBox(sMsg, MB_YESNO) != IDYES)
d284 2
a285 3
		CString sMsg;
		sMsg.Format(GetResString(IDS_HTTPDOWNLOAD_FAIL_FILE_OPEN), ::GetLastError());
		AfxMessageBox(sMsg);
d300 2
a301 5
	CString sFileStatus;
	ASSERT(m_sObject.GetLength());
	ASSERT(m_sServer.GetLength());
	AfxFormatString2(sFileStatus, IDS_HTTPDOWNLOAD_OF, m_sFilename, m_sServer);
	m_ctrlFileStatus.SetWindowText(sFileStatus);
d338 3
a340 3
	CString sCaption;
	AfxFormatString2(sCaption, m_nIDPercentage, sPercentage, m_sFilename);
	SetWindowText(sCaption);
@


1.23
log
@Use general user agent for HTTP requests (to hide identity to avoid any kind of blocking or filtering).
@
text
@d328 1
a328 2
	if (g_App.m_pPrefs->IsNTBased())
		SetThreadLocale(g_App.m_pPrefs->GetLanguageID());
@


1.22
log
@Simplified obtaining of HTTP response values;
Corrected the buffer size to obtain stream encoding (according to MSDN it should be in bytes);
Removed some unused code.
@
text
@d421 1
a421 1
	m_hInternetSession = ::InternetOpen(AfxGetAppName(), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
@


1.21
log
@Crash while HTTP downloading when there's no enough space on the drive {postmaster}.
@
text
@a113 13
#define ENCODING_QUERY {                                                    \
  /*check for gzip or x-gzip stream*/                                       \
  TCHAR szContentEncoding[32];                                              \
  DWORD dwEncodeStringSize = 32;                                            \
  if(::HttpQueryInfo(m_hHttpFile, HTTP_QUERY_CONTENT_ENCODING,              \
       szContentEncoding, &dwEncodeStringSize, NULL)) {                     \
    if(szContentEncoding[0] == 'x' && szContentEncoding[1] == '-')          \
      szContentEncoding += 2;                                               \
    if(!stricmp(szContentEncoding, "gzip")                                  \
      bEncodedWithGZIP = TRUE;                                              \
   }                                                                        \
  }

a162 2
#define ENCODING_QUERY ((void)0)

a176 2
	//{{AFX_DATA_INIT(CHttpDownloadDlg)
	//}}AFX_DATA_INIT
d512 4
a515 4
	//Check the HTTP status code
	TCHAR szStatusCode[32];
	DWORD dwInfoSize = 32;
	if (!HttpQueryInfo(m_hHttpFile, HTTP_QUERY_STATUS_CODE, szStatusCode, &dwInfoSize, NULL))
a522 2
		long nStatusCode = _ttol(szStatusCode);

d524 1
a524 1
		if (nStatusCode == HTTP_STATUS_PROXY_AUTH_REQ || nStatusCode == HTTP_STATUS_DENIED)
d541 1
a541 1
		else if (nStatusCode != HTTP_STATUS_OK)
d543 2
a544 2
			TRACE(_T("Failed to retrieve a HTTP 200 status, Status Code:%d\n"), nStatusCode);
			HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_INVALID_HTTP_RESPONSE, nStatusCode);
a549 1
	//  ENCODING_QUERY;
d551 1
a551 1
	DWORD dwEncodeStringSize = 32;
d561 1
a561 3
	// Get the length of the file.
	TCHAR szContentLength[32];
	dwInfoSize = 32;
d564 4
a567 1
	if (::HttpQueryInfo(m_hHttpFile, HTTP_QUERY_CONTENT_LENGTH, szContentLength, &dwInfoSize, NULL))
d569 1
a569 1
		//Set the progress control range
a570 1
		dwFileSize = (DWORD) _ttol(szContentLength);
@


1.20
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d619 1
a619 1
			TRY
d623 1
a623 1
			CATCH(CFileException, e);
d626 2
a627 2
				HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE, e->m_lOsError);
				e->Delete();
a631 1
			END_CATCH
@


1.19
log
@renamed 3 variables
@
text
@d325 1
a325 1
	m_pThread = AfxBeginThread(_DownloadThread, this, THREAD_PRIORITY_NORMAL+ g_App.g_pPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
d345 2
a346 2
	if (g_App.g_pPrefs->IsNTBased())
		SetThreadLocale(g_App.g_pPrefs->GetLanguageID());
@


1.18
log
@Reuse already exist strings instead of creating new ones.
@
text
@d325 1
a325 1
	m_pThread = AfxBeginThread(_DownloadThread, this, THREAD_PRIORITY_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
d345 2
a346 2
	if (g_eMuleApp.m_pGlobPrefs->IsNTBased())
		SetThreadLocale(g_eMuleApp.m_pGlobPrefs->GetLanguageID());
@


1.17
log
@Fixed some untranslated strings
@
text
@d250 9
a258 3
	SetDlgItemText(IDCANCEL, GetResString(IDS_CANCEL));
	SetDlgItemText(IDC_STATIC_ESTTIME, GetResString(IDS_ESTTIME));
	SetDlgItemText(IDC_STATIC_TRATE, GetResString(IDS_TRATE));
@


1.16
log
@Fixed localization of HTTP download dialog
(when current preferences language doesn't match current OS user settings);
Partly removed usage of AfxFormatStringX functions (as they don't provide secure
string loading when resource string doesn't exist);
Unified string operations; Improved string processing.
@
text
@d251 2
@


1.15
log
@minor changes, fixes and improvements
@
text
@d280 1
a280 1
		AfxFormatString1(sMsg, IDS_HTTPDOWNLOAD_OK_TO_OVERWRITE, m_sFileToDownloadInto);
a292 2
		CString sError;
		sError.Format(_T("%d"), ::GetLastError());
d294 1
a294 1
		AfxFormatString1(sMsg, IDS_HTTPDOWNLOAD_FAIL_FILE_OPEN, sError);
d336 4
d369 1
a369 42
	CString sCopied;
	if (dwBytesRead < 1024)
	{
		CString sBytes;
		sBytes.Format(_T("%d"), dwBytesRead);
		AfxFormatString1(sCopied, IDS_HTTPDOWNLOAD_BYTES, sBytes);
	}
	else if (dwBytesRead < 1048576)
	{
		CString sKiloBytes;
		sKiloBytes.Format(_T("%0.1f"), dwBytesRead/1024.0);
		AfxFormatString1(sCopied, IDS_HTTPDOWNLOAD_KILOBYTES, sKiloBytes);
	}
	else
	{
		CString sMegaBytes;
		sMegaBytes.Format(_T("%0.2f"), dwBytesRead/1048576.0);
		AfxFormatString1(sCopied, IDS_HTTPDOWNLOAD_MEGABYTES, sMegaBytes);
	}

	CString sTotal;
	if (dwFileSize < 1024)
	{
		CString sBytes;
		sBytes.Format(_T("%d"), dwFileSize);
		AfxFormatString1(sTotal, IDS_HTTPDOWNLOAD_BYTES, sBytes);
	}
	else if (dwFileSize < 1048576)
	{
		CString sKiloBytes;
		sKiloBytes.Format(_T("%0.1f"), dwFileSize/1024.0);
		AfxFormatString1(sTotal, IDS_HTTPDOWNLOAD_KILOBYTES, sKiloBytes);
	}
	else
	{
		CString sMegaBytes;
		sMegaBytes.Format(_T("%0.2f"), dwFileSize/1048576.0);
		AfxFormatString1(sTotal, IDS_HTTPDOWNLOAD_MEGABYTES, sMegaBytes);
	}

	CString sOf;
	AfxFormatString2(sOf, IDS_HTTPDOWNLOAD_OF, sCopied, sTotal);
d371 3
a373 24
	CString sTime;
	if (dwSecondsLeft < 60)
	{
		CString sSeconds;
		sSeconds.Format(_T("%d"), dwSecondsLeft);
		AfxFormatString1(sTime, IDS_HTTPDOWNLOAD_SECONDS, sSeconds);
	}
	else
	{
		DWORD dwMinutes = dwSecondsLeft / 60;
		DWORD dwSeconds = dwSecondsLeft % 60;
		CString sSeconds;
		sSeconds.Format(_T("%d"), dwSeconds);
		CString sMinutes;
		sMinutes.Format(_T("%d"), dwMinutes);
		if (dwSeconds == 0)
			AfxFormatString1(sTime, IDS_HTTPDOWNLOAD_MINUTES, sMinutes);
		else
			AfxFormatString2(sTime, IDS_HTTPDOWNLOAD_MINUTES_AND_SECONDS, sMinutes, sSeconds);
	}

	CString sTimeLeft;
	AfxFormatString2(sTimeLeft, IDS_HTTPDOWNLOAD_TIMELEFT, sTime, sOf);
	m_ctrlTimeLeft.SetWindowText(sTimeLeft);
d383 1
a383 3
	CString sCaption;
	sCaption.LoadString(nID);
	SetStatus(sCaption);
d386 1
a386 1
void CHttpDownloadDlg::SetStatus(UINT nID, const CString& lpsz1)
d388 4
a391 3
	CString sStatus;
	AfxFormatString1(sStatus, nID, lpsz1);
	SetStatus(sStatus);
d397 2
a398 18
	if (KbPerSecond < 1)
	{
		CString sBytesPerSecond;
		sBytesPerSecond.Format(_T("%0.0f"), KbPerSecond*1024);
		AfxFormatString1(sRate, IDS_HTTPDOWNLOAD_BYTESPERSECOND, sBytesPerSecond);
	}
	else if (KbPerSecond < 10)
	{
		CString sKiloBytesPerSecond;
		sKiloBytesPerSecond.Format(_T("%0.2f"), KbPerSecond);
		AfxFormatString1(sRate, IDS_HTTPDOWNLOAD_KILOBYTESPERSECOND, sKiloBytesPerSecond);
	}
	else
	{
		CString sKiloBytesPerSecond;
		sKiloBytesPerSecond.Format(_T("%0.0f"), KbPerSecond);
		AfxFormatString1(sRate, IDS_HTTPDOWNLOAD_KILOBYTESPERSECOND, sKiloBytesPerSecond);
	}
d410 1
a410 6
	CString sError;
	if (dwLastError)
		sError.Format(_T("%d"), dwLastError);
	else
		sError.Format(_T("%d"), ::GetLastError());
	AfxFormatString1(m_sError, nIDError, sError);
d421 1
a421 1
	m_sError.LoadString(nIDError);
d706 1
a706 1
			SetStatus(IDS_HTTPDOWNLOAD_RESOLVING_NAME, (LPCTSTR) lpvStatusInformation);
d711 1
a711 1
			SetStatus(IDS_HTTPDOWNLOAD_RESOLVED_NAME, (LPCTSTR) lpvStatusInformation);
d716 1
a716 1
			SetStatus(IDS_HTTPDOWNLOAD_CONNECTING, (LPCTSTR) lpvStatusInformation);
d721 1
a721 1
			SetStatus(IDS_HTTPDOWNLOAD_CONNECTED, (LPCTSTR) lpvStatusInformation);
d726 1
a726 1
			SetStatus(IDS_HTTPDOWNLOAD_REDIRECTING, (LPCTSTR) lpvStatusInformation);
@


1.14
log
@bugfix: wrong titles were displayed in HTTP download dialogs
@
text
@d108 1
a108 1
#define ENCODING_CLEAN_UP      if(bEncodedWithGZIP) inflateEnd(&zs)	//netwolf 03.05.03
d143 1
a143 1
      inflateEnd(&zs);	/* netwolf 03.05.03 */                              \
a163 2
      /*if(iResult == Z_STREAM_END) {*/                                     \
      /*}*/                                                                 \
@


1.13
log
@Minor improvements.
@
text
@d202 2
d252 2
a253 10
	CString cap;
	cap.LoadString(IDS_CANCEL);
	SetDlgItemText(IDCANCEL, cap);

	//FakeCheck
	if (StrStrI(m_sFileToDownloadInto,"fakes"))
		cap.LoadString(IDS_FAKE_HTTPCHECKCAPTION);
	else
		cap.LoadString(IDS_HTTP_CAPTION);
	SetWindowText(cap);
d317 1
a317 1
	AfxFormatString2(sFileStatus, IDS_HTTPDOWNLOAD_FILESTATUS, m_sFilename, m_sServer);
d353 1
a353 1
	AfxFormatString2(sCaption, IDS_HTTPDOWNLOAD_PERCENTAGE, sPercentage, m_sFilename);
@


1.12
log
@formatting;
optimzations in UploadQueue.cpp;
removing doubled ';'
@
text
@d252 1
a252 1
	GetDlgItem(IDCANCEL)->SetWindowText(cap);
@


1.11
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d731 1
a731 1
	ENCODING_CLEAN_UP;;
@


1.10
log
@Formatting, comments, and name changes.
@
text
@d8 1
a8 1
                          2. Updated the way and periodicity certain UI controls are updated during the 
d11 1
a11 1
Copyright (c) 1999 - 2000 by PJ Naughter.  
d248 1
a248 1
BOOL CHttpDownloadDlg::OnInitDialog() 
d258 1
a258 1
	cap.LoadString(IDS_HTTP_CAPTION);
d533 1
a533 1
	}  
d553 1
a553 1
		m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_uPort, m_sUserName, 
d556 1
a556 1
		m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_uPort, NULL, 
d580 1
a580 1
	m_hHttpFile = HttpOpenRequest(m_hHttpConnection, NULL, m_sObject, NULL, NULL, ppszAcceptTypes, INTERNET_FLAG_RELOAD | 
d717 1
a717 1
			dwTotalBytesRead += dwBytesRead;  
d719 1
a719 1
			UpdateControlsDuringTransfer(dwStartTicks, dwCurrentTicks, dwTotalBytesRead, dwLastTotalBytes, 
d737 1
a737 1
void CHttpDownloadDlg::UpdateControlsDuringTransfer(DWORD dwStartTicks, DWORD& dwCurrentTicks, DWORD dwTotalBytesRead, DWORD& dwLastTotalBytes, 
d771 1
a771 1
				DWORD dwSecondsLeft = (DWORD) (((double)dwNowTicks - dwStartTicks) / dwTotalBytesRead * 
d779 1
a779 1
void CALLBACK CHttpDownloadDlg::_OnStatusCallBack(HINTERNET hInternet, DWORD dwContext, DWORD dwInternetStatus, 
d789 1
a789 1
void CHttpDownloadDlg::OnStatusCallBack(HINTERNET /*hInternet*/, DWORD dwInternetStatus, 
d826 1
a826 1
void CHttpDownloadDlg::OnDestroy() 
d857 1
a857 1
void CHttpDownloadDlg::OnCancel() 
d880 1
a880 1
	m_bAbort = TRUE;	
d885 1
a885 1
void CHttpDownloadDlg::OnClose() 
d887 1
a887 1
	if (m_bSafeToClose)	
d893 1
a893 1
		m_bAbort = TRUE;	
@


1.9
log
@FakeCheck for Search Result and Download List (Check and Report ... made by milobac ... merged by DropF ... tested by n@@boleo and me)
@
text
@d269 1
a269 1
	if (!AfxParseURL(m_sURLToDownload, m_dwServiceType, m_sServer, m_sObject, m_nPort))
d273 1
a273 1
		if (!AfxParseURL(m_sURLToDownload, m_dwServiceType, m_sServer, m_sObject, m_nPort))
d553 1
a553 1
		m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_nPort, m_sUserName, 
d556 1
a556 1
		m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_nPort, NULL, 
@


1.8
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d254 4
@


1.7
log
@unicode cleanup
@
text
@d323 1
a323 1
	m_pThread = AfxBeginThread(_DownloadThread, this, THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority(), 0, CREATE_SUSPENDED);
@


1.6
log
@More netwolf's changes
@
text
@d107 1
a107 2
#define ACCEPT_ENCODING_HEADER "Accept-Encoding: gzip, x-gzip, identity, *;q=0\r\n"

d652 1
a652 1
		if(!stricmp(szContentEncoding, "gzip") || !stricmp(szContentEncoding, "x-gzip"))
@


1.5
log
@Various fixes (see changelog+)
@
text
@d109 1
a109 1
#define ENCODING_CLEAN_UP      if(bEncodedWithGZIP) deflateEnd(&zs)
d144 1
a144 1
      deflateEnd(&zs);                                                      \
@


1.4
log
@Priority control
@
text
@d856 19
@


1.3
log
@updated to .25b codebase
@
text
@d22 1
d324 1
a324 1
	m_pThread = AfxBeginThread(_DownloadThread, this, THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
@


1.3.2.1
log
@updating this branch...
@
text
@@


1.2
log
@port to .25 b codebase...
@
text
@d196 7
a202 7
  m_hInternetSession = NULL;
  m_hHttpConnection = NULL;
  m_hHttpFile = NULL;
  m_bAbort = FALSE;
  m_bSafeToClose = FALSE;
  m_pThread = NULL;
 }
d222 1
a222 1
  ON_MESSAGE(WM_HTTPDOWNLOAD_THREAD_FINISHED, OnThreadFinished)
d228 2
a229 2
  //It's now safe to close since the thread has signaled us
  m_bSafeToClose = TRUE;
d231 13
a243 13
  //Stop the animation
  m_ctrlAnimate.Stop();
  Sleep(1000);
  //If an error occured display the message box
  if (m_bAbort)
    EndDialog(IDCANCEL);
  else if (wParam)
  {
    //AfxMessageBox(m_sError);
    EndDialog(IDCANCEL);
  }
  else
    EndDialog(IDOK);
d245 1
a245 1
  return 0L;
d260 2
a261 2
  //Setup the animation control
  m_ctrlAnimate.Open(IDR_HTTPDOWNLOAD_ANIMATION);
d263 51
a313 51
  //Validate the URL
  ASSERT(m_sURLToDownload.GetLength()); //Did you forget to specify the file to download
  if (!AfxParseURL(m_sURLToDownload, m_dwServiceType, m_sServer, m_sObject, m_nPort))
  {
    //Try sticking "http://" before it
    m_sURLToDownload = _T("http://") + m_sURLToDownload;
    if (!AfxParseURL(m_sURLToDownload, m_dwServiceType, m_sServer, m_sObject, m_nPort))
    {
      TRACE(_T("Failed to parse the URL: %s\n"), m_sURLToDownload);
      EndDialog(IDCANCEL);
      return TRUE;
    }
  }

  //Check to see if the file we are downloading to exists and if
  //it does, then ask the user if they were it overwritten
  CFileStatus fs;
  ASSERT(m_sFileToDownloadInto.GetLength());
  if (CFile::GetStatus(m_sFileToDownloadInto, fs))
  {
    CString sMsg;
    AfxFormatString1(sMsg, IDS_HTTPDOWNLOAD_OK_TO_OVERWRITE, m_sFileToDownloadInto);
    if (AfxMessageBox(sMsg, MB_YESNO) != IDYES)
    {
      TRACE(_T("Failed to confirm file overwrite, download aborted\n"));
      EndDialog(IDCANCEL);
      return TRUE;
    }
  }

  //Try and open the file we will download into
  if (!m_FileToWrite.Open(m_sFileToDownloadInto, CFile::modeCreate | CFile::modeWrite | CFile::shareDenyWrite))
  {
    TRACE(_T("Failed to open the file to download into, Error:%d\n"), GetLastError());
    CString sError;
    sError.Format(_T("%d"), ::GetLastError());
    CString sMsg;
    AfxFormatString1(sMsg, IDS_HTTPDOWNLOAD_FAIL_FILE_OPEN, sError);
    AfxMessageBox(sMsg);
    EndDialog(IDCANCEL);
    return TRUE;
  }

  //Pull out just the filename component
  int nSlash = m_sObject.ReverseFind(_T('/'));
  if (nSlash == -1)
    nSlash = m_sObject.ReverseFind(_T('\\'));
  if (nSlash != -1 && m_sObject.GetLength() > 1)
    m_sFilename = m_sObject.Right(m_sObject.GetLength() - nSlash - 1);
  else
    m_sFilename = m_sObject;
d316 5
a320 5
  CString sFileStatus;
  ASSERT(m_sObject.GetLength());
  ASSERT(m_sServer.GetLength());
  AfxFormatString2(sFileStatus, IDS_HTTPDOWNLOAD_FILESTATUS, m_sFilename, m_sServer);
  m_ctrlFileStatus.SetWindowText(sFileStatus);
d322 1
a322 1
  //Spin off the background thread which will do the actual downloading
d324 9
a332 9
  if (m_pThread == NULL)
  {
    TRACE(_T("Failed to create download thread, dialog is aborting\n"));
    EndDialog(IDCANCEL);
    return TRUE;
  }
  m_pThread->m_bAutoDelete = FALSE;
  m_pThread->ResumeThread();
	
d338 6
a343 6
  //Convert from the SDK world to the C++ world
  CHttpDownloadDlg* pDlg = (CHttpDownloadDlg*) pParam;
  ASSERT(pDlg);
  ASSERT(pDlg->IsKindOf(RUNTIME_CLASS(CHttpDownloadDlg)));
  pDlg->DownloadThread();
  return 0;
d348 2
a349 2
  //Change the progress control
  m_ctrlProgress.SetPos(nPercentage);
d351 6
a356 6
  //Change the caption text
  CString sPercentage;
  sPercentage.Format(_T("%d"), nPercentage);
  CString sCaption;
  AfxFormatString2(sCaption, IDS_HTTPDOWNLOAD_PERCENTAGE, sPercentage, m_sFilename);
  SetWindowText(sCaption);
d361 1
a361 1
  m_ctrlProgress.SetRange(0, (short)((dwFileSize+512)/1024));
d366 1
a366 1
  m_ctrlProgress.SetPos(dwBytesRead/1024);
d371 67
a437 67
  CString sCopied;
  if (dwBytesRead < 1024)
  {
    CString sBytes;
    sBytes.Format(_T("%d"), dwBytesRead);
    AfxFormatString1(sCopied, IDS_HTTPDOWNLOAD_BYTES, sBytes);
  }
  else if (dwBytesRead < 1048576)
  {
    CString sKiloBytes;
    sKiloBytes.Format(_T("%0.1f"), dwBytesRead/1024.0);
    AfxFormatString1(sCopied, IDS_HTTPDOWNLOAD_KILOBYTES, sKiloBytes);
  }
  else
  {
    CString sMegaBytes;
    sMegaBytes.Format(_T("%0.2f"), dwBytesRead/1048576.0);
    AfxFormatString1(sCopied, IDS_HTTPDOWNLOAD_MEGABYTES, sMegaBytes);
  }

  CString sTotal;
  if (dwFileSize < 1024)
  {
    CString sBytes;
    sBytes.Format(_T("%d"), dwFileSize);
    AfxFormatString1(sTotal, IDS_HTTPDOWNLOAD_BYTES, sBytes);
  }
  else if (dwFileSize < 1048576)
  {
    CString sKiloBytes;
    sKiloBytes.Format(_T("%0.1f"), dwFileSize/1024.0);
    AfxFormatString1(sTotal, IDS_HTTPDOWNLOAD_KILOBYTES, sKiloBytes);
  }
  else
  {
    CString sMegaBytes;
    sMegaBytes.Format(_T("%0.2f"), dwFileSize/1048576.0);
    AfxFormatString1(sTotal, IDS_HTTPDOWNLOAD_MEGABYTES, sMegaBytes);
  }

  CString sOf;
  AfxFormatString2(sOf, IDS_HTTPDOWNLOAD_OF, sCopied, sTotal);

  CString sTime;
  if (dwSecondsLeft < 60)
  {
    CString sSeconds;
    sSeconds.Format(_T("%d"), dwSecondsLeft);
    AfxFormatString1(sTime, IDS_HTTPDOWNLOAD_SECONDS, sSeconds);
  }
  else
  {
    DWORD dwMinutes = dwSecondsLeft / 60;
    DWORD dwSeconds = dwSecondsLeft % 60;
    CString sSeconds;
    sSeconds.Format(_T("%d"), dwSeconds);
    CString sMinutes;
    sMinutes.Format(_T("%d"), dwMinutes);
    if (dwSeconds == 0)
      AfxFormatString1(sTime, IDS_HTTPDOWNLOAD_MINUTES, sMinutes);
    else
      AfxFormatString2(sTime, IDS_HTTPDOWNLOAD_MINUTES_AND_SECONDS, sMinutes, sSeconds);
  }

  CString sTimeLeft;
  AfxFormatString2(sTimeLeft, IDS_HTTPDOWNLOAD_TIMELEFT, sTime, sOf);
  m_ctrlTimeLeft.SetWindowText(sTimeLeft);
d442 1
a442 1
  m_ctrlStatus.SetWindowText(sCaption);
d447 3
a449 3
  CString sCaption;
  sCaption.LoadString(nID);
  SetStatus(sCaption);
d454 3
a456 3
  CString sStatus;
  AfxFormatString1(sStatus, nID, lpsz1);
  SetStatus(sStatus);
d461 20
a480 20
  CString sRate;
  if (KbPerSecond < 1)
  {
    CString sBytesPerSecond;
    sBytesPerSecond.Format(_T("%0.0f"), KbPerSecond*1024);
    AfxFormatString1(sRate, IDS_HTTPDOWNLOAD_BYTESPERSECOND, sBytesPerSecond);
  }
  else if (KbPerSecond < 10)
  {
    CString sKiloBytesPerSecond;
    sKiloBytesPerSecond.Format(_T("%0.2f"), KbPerSecond);
    AfxFormatString1(sRate, IDS_HTTPDOWNLOAD_KILOBYTESPERSECOND, sKiloBytesPerSecond);
  }
  else
  {
    CString sKiloBytesPerSecond;
    sKiloBytesPerSecond.Format(_T("%0.0f"), KbPerSecond);
    AfxFormatString1(sRate, IDS_HTTPDOWNLOAD_KILOBYTESPERSECOND, sKiloBytesPerSecond);
  }
  m_ctrlTransferRate.SetWindowText(sRate);
d485 1
a485 1
  m_ctrlAnimate.Play(0, (UINT)-1, (UINT)-1);
d490 11
a500 11
  //Form the error string to report
  CString sError;
  if (dwLastError)
    sError.Format(_T("%d"), dwLastError);
  else
    sError.Format(_T("%d"), ::GetLastError());
  AfxFormatString1(m_sError, nIDError, sError);

  //Delete the file being downloaded to if it is present
  m_FileToWrite.Close();
  ::DeleteFile(m_sFileToDownloadInto);
d502 1
a502 1
  PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED, 1);
d507 2
a508 2
  m_sError.LoadString(nIDError);
  PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED, 1);
d513 37
a549 37
  ENCODING_INIT;
  //Create the Internet session handle
  ASSERT(m_hInternetSession == NULL);
  m_hInternetSession = ::InternetOpen(AfxGetAppName(), INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
  if (m_hInternetSession == NULL)
  {
    TRACE(_T("Failed in call to InternetOpen, Error:%d\n"), ::GetLastError());
    HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_GENERIC_ERROR);
    return;
  }

  //Should we exit the thread
  if (m_bAbort)
  {
    PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
    return;
  }  

  //Setup the status callback function
  if (::InternetSetStatusCallback(m_hInternetSession, _OnStatusCallBack) == INTERNET_INVALID_STATUS_CALLBACK)
  {
    TRACE(_T("Failed in call to InternetSetStatusCallback, Error:%d\n"), ::GetLastError());
    HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_GENERIC_ERROR);
    return;
  }

  //Should we exit the thread
  if (m_bAbort)
  {
    PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
    return;
  }  

  //Make the connection to the HTTP server          
  ASSERT(m_hHttpConnection == NULL);
  if (m_sUserName.GetLength())
    m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_nPort, m_sUserName, 
d551 2
a552 2
  else
    m_hHttpConnection = ::InternetConnect(m_hInternetSession, m_sServer, m_nPort, NULL, 
d554 6
a559 37
  if (m_hHttpConnection == NULL)
  {
    TRACE(_T("Failed in call to InternetConnect, Error:%d\n"), ::GetLastError());
    HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_FAIL_CONNECT_SERVER);
    return;
  }

  //Should we exit the thread
  if (m_bAbort)
  {
    PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
    return;
  }  

  //Start the animation to signify that the download is taking place
  PlayAnimation();

  //Issue the request to read the file
  LPCTSTR ppszAcceptTypes[2];
  ppszAcceptTypes[0] = _T("*/*");  //We support accepting any mime file type since this is a simple download of a file
  ppszAcceptTypes[1] = NULL;
  ASSERT(m_hHttpFile == NULL);
  m_hHttpFile = HttpOpenRequest(m_hHttpConnection, NULL, m_sObject, NULL, NULL, ppszAcceptTypes, INTERNET_FLAG_RELOAD | 
                                INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_KEEP_CONNECTION, (DWORD) this);
  if (m_hHttpFile == NULL)
  {
    TRACE(_T("Failed in call to HttpOpenRequest, Error:%d\n"), ::GetLastError());
    HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_FAIL_CONNECT_SERVER);
    return;
  }

  //Should we exit the thread
  if (m_bAbort)
  {
    PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
    return;
  }  
d561 33
a593 2
  //fill in what encoding we support
  HttpAddRequestHeaders(m_hHttpFile, ACCEPT_ENCODING_HEADER, (DWORD)-1L, HTTP_ADDREQ_FLAG_ADD);
d598 8
a605 8
  //Issue the request
  BOOL bSend = ::HttpSendRequest(m_hHttpFile, NULL, 0, NULL, 0);
  if (!bSend)
  {
    TRACE(_T("Failed in call to HttpSendRequest, Error:%d\n"), ::GetLastError());
    HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_FAIL_CONNECT_SERVER);
    return;
  }
d607 1
a607 1
  //Check the HTTP status code
d611 21
a631 21
  {
    TRACE(_T("Failed in call to HttpQueryInfo for HTTP query status code, Error:%d\n"), ::GetLastError());
    HandleThreadError(IDS_HTTPDOWNLOAD_INVALID_SERVER_RESPONSE);
    return;
  }
  else
  {
    long nStatusCode = _ttol(szStatusCode);

    //Handle any authentication errors
    if (nStatusCode == HTTP_STATUS_PROXY_AUTH_REQ || nStatusCode == HTTP_STATUS_DENIED)
    {
      // We have to read all outstanding data on the Internet handle
      // before we can resubmit request. Just discard the data.
      char szData[51];
      DWORD dwSize;
      do
	    {
		    ::InternetReadFile(m_hHttpFile, (LPVOID)szData, 50, &dwSize);
	    }
	    while (dwSize != 0);
d633 2
a634 2
      //Bring up the standard authentication dialog
      if (::InternetErrorDlg(GetSafeHwnd(), m_hHttpFile, ERROR_INTERNET_INCORRECT_PASSWORD, FLAGS_ERROR_UI_FILTER_FOR_ERRORS |
d636 14
a649 14
        goto resend;
    }
  	else if (nStatusCode != HTTP_STATUS_OK)
    {
      TRACE(_T("Failed to retrieve a HTTP 200 status, Status Code:%d\n"), nStatusCode);
      HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_INVALID_HTTP_RESPONSE, nStatusCode);
      return;
    }
  }

  //Check to see if any encodings are supported
//  ENCODING_QUERY;
  TCHAR szContentEncoding[32];                                              
  DWORD dwEncodeStringSize = 32;                                            
d652 32
a683 59
    if(!stricmp(szContentEncoding, "gzip") || !stricmp(szContentEncoding, "x-gzip"))
      bEncodedWithGZIP = TRUE;                                              
   }                                                                        

  //Update the status control to reflect that we are getting the file information
  SetStatus(IDS_HTTPDOWNLOAD_GETTING_FILE_INFORMATION);

  // Get the length of the file.            
  TCHAR szContentLength[32];
  dwInfoSize = 32;
  DWORD dwFileSize = 0;
  BOOL bGotFileSize = FALSE;
  if (::HttpQueryInfo(m_hHttpFile, HTTP_QUERY_CONTENT_LENGTH, szContentLength, &dwInfoSize, NULL))
  {
    //Set the progress control range
    bGotFileSize = TRUE;
    dwFileSize = (DWORD) _ttol(szContentLength);
    SetProgressRange(dwFileSize);
  }

  //Update the status to say that we are now downloading the file
  SetStatus(IDS_HTTPDOWNLOAD_RETREIVEING_FILE);

  //Now do the actual read of the file
  DWORD dwStartTicks = ::GetTickCount();
  DWORD dwCurrentTicks = dwStartTicks;
  DWORD dwBytesRead = 0;
  char szReadBuf[1024];
  DWORD dwBytesToRead = 1024;
  DWORD dwTotalBytesRead = 0;
  DWORD dwLastTotalBytes = 0;
  DWORD dwLastPercentage = 0;

  PREPARE_DECODER;
  do
  {
    if (!::InternetReadFile(m_hHttpFile, szReadBuf, dwBytesToRead, &dwBytesRead))
    {
      TRACE(_T("Failed in call to InternetReadFile, Error:%d\n"), ::GetLastError());
      HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE);
      return;
    }
    else if (dwBytesRead && !m_bAbort)
    {
      //Write the data to file
      TRY
      {
        DECODE_DATA(m_FileToWrite, szReadBuf, dwBytesRead);
      }
      CATCH(CFileException, e);                                          
      {
        TRACE(_T("An exception occured while writing to the download file\n"));
        HandleThreadErrorWithLastError(IDS_HTTPDOWNLOAD_ERROR_READFILE, e->m_lOsError);
        e->Delete();
		//clean up any encoding data before we return
        ENCODING_CLEAN_UP;
        return;
      }
      END_CATCH
d685 29
a713 2
      //Increment the total number of bytes read
      dwTotalBytesRead += dwBytesRead;  
d715 1
a715 1
      UpdateControlsDuringTransfer(dwStartTicks, dwCurrentTicks, dwTotalBytesRead, dwLastTotalBytes, 
d717 8
a724 8
    }
  } 
  while (dwBytesRead && !m_bAbort);

  //Delete the file being downloaded to if it is present and the download was aborted
  m_FileToWrite.Close();
  if (m_bAbort)
    ::DeleteFile(m_sFileToDownloadInto);
d726 2
a727 2
  //clean up any encoding data before we return
  ENCODING_CLEAN_UP;;
d729 2
a730 2
  //We're finished
  PostMessage(WM_HTTPDOWNLOAD_THREAD_FINISHED);
d736 37
a772 37
  if (bGotFileSize)
  {
    //Update the percentage downloaded in the caption
    DWORD dwPercentage = (DWORD) (dwTotalBytesRead * 100.0 / dwFileSize);
    if (dwPercentage != dwLastPercentage)
    {
      SetPercentage(dwPercentage);
      dwLastPercentage = dwPercentage;

      //Update the progress control bar
      SetProgress(dwTotalBytesRead);
    }
  }

  //Update the transfer rate amd estimated time left every second
  DWORD dwNowTicks = GetTickCount();
  DWORD dwTimeTaken = dwNowTicks - dwCurrentTicks;
  if (dwTimeTaken > 1000)
  {
    double KbPerSecond = ((double)(dwTotalBytesRead) - (double)(dwLastTotalBytes)) / ((double)(dwTimeTaken));
    SetTransferRate(KbPerSecond);

    //Setup for the next time around the loop
    dwCurrentTicks = dwNowTicks;
    dwLastTotalBytes = dwTotalBytesRead;

    if (bGotFileSize)
    {
      //Update the estimated time left
      if (dwTotalBytesRead)
      {
        DWORD dwSecondsLeft = (DWORD) (((double)dwNowTicks - dwStartTicks) / dwTotalBytesRead * 
                                       (dwFileSize - dwTotalBytesRead) / 1000);
        SetTimeLeft(dwSecondsLeft, dwTotalBytesRead, dwFileSize);
      }
    }
  }
d778 5
a782 5
  //Convert from the SDK C world to the C++ world
  CHttpDownloadDlg* pDlg = (CHttpDownloadDlg*) dwContext;
  ASSERT(pDlg);
  ASSERT(pDlg->IsKindOf(RUNTIME_CLASS(CHttpDownloadDlg)));
  pDlg->OnStatusCallBack(hInternet, dwInternetStatus, lpvStatusInformation, dwStatusInformationLength);
d788 32
a819 32
  switch (dwInternetStatus)
  {
    case INTERNET_STATUS_RESOLVING_NAME:
    {
      SetStatus(IDS_HTTPDOWNLOAD_RESOLVING_NAME, (LPCTSTR) lpvStatusInformation);
      break;
    }
    case INTERNET_STATUS_NAME_RESOLVED:
    {
      SetStatus(IDS_HTTPDOWNLOAD_RESOLVED_NAME, (LPCTSTR) lpvStatusInformation);
      break;
    }
    case INTERNET_STATUS_CONNECTING_TO_SERVER:
    {
      SetStatus(IDS_HTTPDOWNLOAD_CONNECTING, (LPCTSTR) lpvStatusInformation);
      break;
    }
    case INTERNET_STATUS_CONNECTED_TO_SERVER:
    {
      SetStatus(IDS_HTTPDOWNLOAD_CONNECTED, (LPCTSTR) lpvStatusInformation);
      break;
    }
    case INTERNET_STATUS_REDIRECT:
    {
      SetStatus(IDS_HTTPDOWNLOAD_REDIRECTING, (LPCTSTR) lpvStatusInformation);
      break;
    }
    default:
    {
      break;
    }
  }
d824 7
a830 24
  //Wait for the worker thread to exit
  if (m_pThread)
  {
    WaitForSingleObject(m_pThread->m_hThread, INFINITE);
    delete m_pThread;
    m_pThread = NULL;
  }

  //Free up the internet handles we may be using
  if (m_hHttpFile)
  {
    ::InternetCloseHandle(m_hHttpFile);
    m_hHttpFile = NULL;
  }
  if (m_hHttpConnection)
  {
    ::InternetCloseHandle(m_hHttpConnection);
    m_hHttpConnection = NULL;
  }
  if (m_hInternetSession)
  {
    ::InternetCloseHandle(m_hInternetSession);
    m_hInternetSession = NULL;
  }
d832 18
a849 1
  //Let the parent class do its thing
d855 5
a859 5
  //Just set the abort flag to TRUE and
  //disable the cancel button
  m_bAbort = TRUE;	
  GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
  SetStatus(IDS_HTTPDOWNLOAD_ABORTING_TRANSFER);
d864 10
a873 10
  if (m_bSafeToClose)	
	  CDialog::OnClose();
  else
  {
    //Just set the abort flag to TRUE and
    //disable the cancel button
    m_bAbort = TRUE;	
    GetDlgItem(IDCANCEL)->EnableWindow(FALSE);
    SetStatus(IDS_HTTPDOWNLOAD_ABORTING_TRANSFER);
  }
@


1.1
log
@*** empty log message ***
@
text
@d323 1
a323 1
  m_pThread = AfxBeginThread(_DownloadThread, this, THREAD_PRIORITY_NORMAL, CREATE_SUSPENDED);
d650 2
a651 2
  if(::HttpQueryInfo(m_hHttpFile, HTTP_QUERY_CONTENT_ENCODING,              
       szContentEncoding, &dwEncodeStringSize, NULL)) {                     
@

