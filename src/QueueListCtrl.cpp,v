head	1.180;
access;
symbols
	PublicRelease_1_2e:1.178
	Interim_Release_1-2e_RC1:1.178
	PublicRelease_1_2d:1.172
	Interim_Release_1-2d_RC1:1.172
	Interim_Release_1-2d_beta1:1.165
	PublicRelease_1_2c:1.162
	Interim_Release_1-2c_RC1:1.162
	Interim_Release_1-2c_beta1:1.161
	PublicRelease_1_2b:1.159
	Interim_Release_1-2b_RC1:1.159
	PublicRelease_1_2a:1.157
	Interim_Release_1-2a_RC1:1.157
	Interim_Release_1-2a_beta2:1.157
	Interim_Release_1-2a_beta1:1.157
	PublicRelease_1_2:1.155
	Interim_Release_1-2_RC1:1.155
	Interim_Release_1-2_beta1:1.155
	PublicRelease_1_1g:1.154
	Interim_Release_1-1g_RC3:1.154
	Interim_Release_1-1g_RC2:1.154
	Interim_Release_1-1g_RC1:1.154
	Interim_Release_1-1g_beta2:1.152
	Interim_Release_1-1g_beta1:1.151
	PublicRelease_1_1f:1.151
	Interim_Release_1-1f_RC1:1.151
	PublicRelease_1_1e:1.151
	Interim_Release_1-1e_RC2:1.151
	Interim_Release_1-1e_RC1:1.151
	Interim_Release_1-1e_beta1:1.149
	PublicRelease_1_1d:1.147
	Interim_Release_1-1d_RC1:1.147
	PublicRelease_1_1c:1.146
	Interim_Release_1-1c_RC1:1.146
	Interim_Release_1-1c_beta2:1.146
	Interim_Release_1-1c_beta1:1.146
	PublicRelease_1_1b:1.143
	Interim_Release_1-1b_RC1:1.143
	PublicRelease_1_1a:1.143
	Interim_Release_1-1a_RC2:1.143
	Interim_Release_1-1a_RC1:1.143
	Interim_Release_1-1a_beta2:1.143
	Interim_Release_1-1a_beta1:1.143
	PublicRelease_1_1:1.141
	Interim_Release_1-1_beta1:1.141
	PublicRelease_1o:1.141
	Interim_Release_1o_RC1:1.141
	Interim_Release_1o_beta1:1.141
	PublicRelease_1n:1.140
	Interim_Release_1n_RC2:1.140
	Interim_Release_1n_RC1:1.140
	Interim_Release_1n_beta2:1.137
	Interim_Release_1n_beta1:1.131
	PublicRelease_1m:1.129
	Interim_Release_1m_beta1:1.129
	PublicRelease_1l:1.128
	Interim_Release_1l_RC3:1.128
	Interim_Release_1l_RC2:1.127
	Interim_Release_1l_RC1:1.126
	Interim_Release_1l_beta2:1.126
	Interim_Release_1l_beta1:1.122
	PublicRelease_1k:1.101
	Interim_Release_1k_RC4:1.101
	Interim_1k_RC3:1.101
	Interim_1k_RC2:1.101
	Interim_Release_1k_RC1:1.101
	Interim_Release_1k_beta5:1.101
	Intrerim_Release_1k_beta4:1.101
	Interim_Release_1k_beta1:1.96
	PublicRelease_1j:1.92
	Interim_Release_1J_RC3:1.92
	Interim_Release_1j_RC3:1.92
	Interim_Release_1j_RC2:1.86
	Interim_Release_1j_RC1:1.86
	Interim_Release_1j_beta2:1.86
	Interim_Release_1j_beta1:1.85
	PublicRelease_1i:1.80
	Interim_Release_1i_RC6:1.80
	Interim_Release_1i_RC3:1.75
	Interim_Release_1i_RC2:1.75
	Interim_Release_1i_RC1:1.70
	Interim_Release_1i_beta3:1.69
	Interim_Release_1i_beta2:1.66
	Interim_Release_1i_beta1:1.59
	PublicRelease_1h:1.46
	Interim_Release_1h_rc2:1.46
	Interim_Release_1h_RC1:1.45
	Interim_Release_1h_beta2:1.44
	Interim_Release_1h_beta1_now:1.40
	Interim_Release_1h_beta1:1.40
	PublicRelease_1g:1.37
	Interim_Release_1g_RC6_Final:1.37
	Interim_Release_1g_RC6:1.36
	Interim_Release_1g_RC5:1.36
	Interim_Release_1g_RC4:1.36
	Interim_Release_1g_RC3:1.36
	Interim_Release_1g_beta2:1.32
	Interim_Release_1g_beta1:1.31
	Interim_Release_1f_RC4:1.30
	Interim_Release_1f_RC3:1.30
	Interim_Release_1f_RC2:1.29
	Interim_Release_1f_RC:1.29
	Interim_Release_1f_beta2:1.28
	Interim_Release_1f_beta1:1.28
	PublicRelease_1e:1.28
	Interim_Release_1e_RC2:1.28
	Interim_Release_1e_RC:1.28
	Interim_Release_1e_beta3:1.28
	Interim_Release_1e_beta2:1.28
	Interim_Release_1e_beta2_before_kuchin:1.28
	Interim_Release_1e_beta1:1.28
	PublicRelease_1c:1.27
	featurestest:1.27.0.2
	Interim_Release_1c_RC:1.27
	Interim_Release_1c_beta2:1.27
	Interim_Release_1c_beta1:1.26
	threaded_downloadqueue:1.26.0.2
	PublicRelease_1b:1.20
	Interim_Release_1b_beta2:1.20
	Interim_Release_1b_beta1:1.20
	proxydeadlake:1.20.0.2
	PublicRelease_1a:1.19
	Interim_Release_1a_beta2:1.19
	BerkeleyDb:1.19.0.2
	Interim_Release_1a_beta1:1.18
	PublicRelease_1:1.17
	goldfish:1.17
	eMulePlus_1_RC2:1.16
	eMulePlus_26b_1RC1:1.14
	PreRelease_26b_i0e:1.14
	before_26d_merge:1.10
	Interim_Release_26b_i0d:1.9
	Interim_Release_26b_i0c:1.7
	Interim_Release_26b_i0b:1.6
	Interim_Release_26b_i0a:1.6
	systraydlg:1.3.0.4
	plus26based:1.3.0.2
	Interim_Release_25b_i0b:1.3
	Proxy_Dev:1.3
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.180
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.179;

1.179
date	2009.05.14.03.10.30;	author aw3;	state Exp;
branches;
next	1.178;

1.178
date	2008.11.07.05.30.24;	author aw3;	state Exp;
branches;
next	1.177;

1.177
date	2008.11.03.05.58.27;	author aw3;	state Exp;
branches;
next	1.176;

1.176
date	2008.10.29.03.37.16;	author aw3;	state Exp;
branches;
next	1.175;

1.175
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.174;

1.174
date	2008.09.02.02.49.55;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2008.08.13.13.21.11;	author kush_eplus;	state Exp;
branches;
next	1.172;

1.172
date	2008.04.16.19.44.17;	author eklmn;	state Exp;
branches;
next	1.171;

1.171
date	2008.04.10.01.41.31;	author aw3;	state Exp;
branches;
next	1.170;

1.170
date	2008.04.06.11.34.43;	author eklmn;	state Exp;
branches;
next	1.169;

1.169
date	2008.04.05.20.22.49;	author eklmn;	state Exp;
branches;
next	1.168;

1.168
date	2008.04.05.09.49.08;	author eklmn;	state Exp;
branches;
next	1.167;

1.167
date	2008.03.29.13.32.40;	author eklmn;	state Exp;
branches;
next	1.166;

1.166
date	2008.03.10.04.09.38;	author aw3;	state Exp;
branches;
next	1.165;

1.165
date	2007.12.29.05.48.24;	author aw3;	state Exp;
branches;
next	1.164;

1.164
date	2007.12.01.11.17.50;	author eklmn;	state Exp;
branches;
next	1.163;

1.163
date	2007.10.24.19.09.35;	author fuxie-dk;	state Exp;
branches;
next	1.162;

1.162
date	2007.07.08.00.11.57;	author aw3;	state Exp;
branches;
next	1.161;

1.161
date	2007.02.19.03.41.21;	author aw3;	state Exp;
branches;
next	1.160;

1.160
date	2007.02.17.05.48.45;	author aw3;	state Exp;
branches;
next	1.159;

1.159
date	2006.11.17.05.26.11;	author aw3;	state Exp;
branches;
next	1.158;

1.158
date	2006.11.16.11.57.00;	author eklmn;	state Exp;
branches;
next	1.157;

1.157
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.156;

1.156
date	2006.04.09.01.31.16;	author aw3;	state Exp;
branches;
next	1.155;

1.155
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.154;

1.154
date	2005.11.27.22.11.49;	author eklmn;	state Exp;
branches;
next	1.153;

1.153
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.152;

1.152
date	2005.11.04.06.50.58;	author aw3;	state Exp;
branches;
next	1.151;

1.151
date	2005.06.19.05.09.32;	author aw3;	state Exp;
branches;
next	1.150;

1.150
date	2005.06.11.14.38.37;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2005.05.21.20.13.53;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2005.05.10.04.01.32;	author aw3;	state Exp;
branches;
next	1.147;

1.147
date	2005.03.06.17.38.13;	author aw3;	state Exp;
branches;
next	1.146;

1.146
date	2005.01.20.16.25.53;	author kush_eplus;	state Exp;
branches;
next	1.145;

1.145
date	2005.01.19.21.10.48;	author netwolf1;	state Exp;
branches;
next	1.144;

1.144
date	2005.01.14.14.29.13;	author kush_eplus;	state Exp;
branches;
next	1.143;

1.143
date	2004.11.06.04.47.39;	author aw3;	state Exp;
branches;
next	1.142;

1.142
date	2004.10.28.15.24.23;	author aw3;	state Exp;
branches;
next	1.141;

1.141
date	2004.09.12.20.40.52;	author aw3;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.27.05.43.45;	author aw3;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.12.21.54.12;	author eklmn;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.07.15.25.03;	author eklmn;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.07.08.51.53;	author eklmn;	state Exp;
branches;
next	1.136;

1.136
date	2004.08.06.17.00.46;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2004.08.04.04.17.05;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.25.08.30.42;	author dongato;	state Exp;
branches;
next	1.133;

1.133
date	2004.07.24.06.57.22;	author aw3;	state Exp;
branches;
next	1.132;

1.132
date	2004.07.22.23.45.17;	author aw3;	state Exp;
branches;
next	1.131;

1.131
date	2004.07.18.12.20.31;	author eklmn;	state Exp;
branches;
next	1.130;

1.130
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.129;

1.129
date	2004.06.20.01.02.55;	author aw3;	state Exp;
branches;
next	1.128;

1.128
date	2004.06.03.05.22.08;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2004.06.01.22.31.03;	author aw3;	state Exp;
branches;
next	1.126;

1.126
date	2004.05.21.18.37.18;	author dongato;	state Exp;
branches;
next	1.125;

1.125
date	2004.05.19.10.14.29;	author netwolf1;	state Exp;
branches;
next	1.124;

1.124
date	2004.05.11.02.41.13;	author aw3;	state Exp;
branches;
next	1.123;

1.123
date	2004.05.07.04.56.18;	author aw3;	state Exp;
branches;
next	1.122;

1.122
date	2004.05.06.01.39.08;	author katsyonak;	state Exp;
branches;
next	1.121;

1.121
date	2004.05.05.17.17.43;	author netwolf1;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.05.15.38.39;	author netwolf1;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.04.06.09.33;	author aw3;	state Exp;
branches;
next	1.118;

1.118
date	2004.04.28.19.47.17;	author aw3;	state Exp;
branches;
next	1.117;

1.117
date	2004.04.27.03.04.05;	author kush_eplus;	state Exp;
branches;
next	1.116;

1.116
date	2004.04.26.14.23.39;	author katsyonak;	state Exp;
branches;
next	1.115;

1.115
date	2004.04.26.14.08.33;	author katsyonak;	state Exp;
branches;
next	1.114;

1.114
date	2004.04.26.07.45.02;	author katsyonak;	state Exp;
branches;
next	1.113;

1.113
date	2004.04.26.06.14.45;	author katsyonak;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.25.20.00.52;	author katsyonak;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.25.13.04.10;	author katsyonak;	state Exp;
branches;
next	1.110;

1.110
date	2004.04.25.12.11.39;	author katsyonak;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.25.11.58.00;	author katsyonak;	state Exp;
branches;
next	1.108;

1.108
date	2004.04.25.08.33.01;	author dongato;	state Exp;
branches;
next	1.107;

1.107
date	2004.04.25.06.03.19;	author katsyonak;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.23.22.13.52;	author katsyonak;	state Exp;
branches;
next	1.105;

1.105
date	2004.04.16.20.14.48;	author aw3;	state Exp;
branches;
next	1.104;

1.104
date	2004.04.15.14.54.11;	author katsyonak;	state Exp;
branches;
next	1.103;

1.103
date	2004.04.15.01.22.30;	author aw3;	state Exp;
branches;
next	1.102;

1.102
date	2004.04.12.00.47.18;	author aw3;	state Exp;
branches;
next	1.101;

1.101
date	2004.03.19.10.40.06;	author kush_eplus;	state Exp;
branches;
next	1.100;

1.100
date	2004.03.18.18.03.15;	author eklmn;	state Exp;
branches;
next	1.99;

1.99
date	2004.03.17.02.46.48;	author kush_eplus;	state Exp;
branches;
next	1.98;

1.98
date	2004.03.05.04.39.25;	author aw3;	state Exp;
branches;
next	1.97;

1.97
date	2004.02.25.04.50.55;	author aw3;	state Exp;
branches;
next	1.96;

1.96
date	2004.02.20.13.10.33;	author dongato;	state Exp;
branches;
next	1.95;

1.95
date	2004.02.11.04.13.00;	author katsyonak;	state Exp;
branches;
next	1.94;

1.94
date	2004.02.07.00.50.45;	author netwolf1;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.31.12.17.08;	author morevit;	state Exp;
branches;
next	1.92;

1.92
date	2004.01.19.21.21.54;	author eklmn;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.19.18.21.28;	author dropf;	state Exp;
branches;
next	1.90;

1.90
date	2004.01.16.22.03.10;	author eklmn;	state Exp;
branches;
next	1.89;

1.89
date	2004.01.16.12.25.53;	author dongato;	state Exp;
branches;
next	1.88;

1.88
date	2004.01.15.23.27.53;	author dongato;	state Exp;
branches;
next	1.87;

1.87
date	2004.01.14.23.13.26;	author eklmn;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.31.14.01.53;	author dongato;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.84;

1.84
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.83;

1.83
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.82;

1.82
date	2003.12.13.12.04.35;	author dongato;	state Exp;
branches;
next	1.81;

1.81
date	2003.12.10.23.57.29;	author dongato;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.30.17.52.44;	author eklmn;	state Exp;
branches;
next	1.79;

1.79
date	2003.11.27.13.57.18;	author eklmn;	state Exp;
branches;
next	1.78;

1.78
date	2003.11.23.13.33.37;	author katsyonak;	state Exp;
branches;
next	1.77;

1.77
date	2003.11.20.20.07.24;	author katsyonak;	state Exp;
branches;
next	1.76;

1.76
date	2003.11.20.09.56.46;	author katsyonak;	state Exp;
branches;
next	1.75;

1.75
date	2003.11.17.14.44.37;	author kuchin;	state Exp;
branches;
next	1.74;

1.74
date	2003.11.11.21.36.56;	author dropf;	state Exp;
branches;
next	1.73;

1.73
date	2003.11.10.13.18.40;	author eklmn;	state Exp;
branches;
next	1.72;

1.72
date	2003.11.09.16.24.37;	author eklmn;	state Exp;
branches;
next	1.71;

1.71
date	2003.11.05.01.07.20;	author katsyonak;	state Exp;
branches;
next	1.70;

1.70
date	2003.11.04.19.00.33;	author eklmn;	state Exp;
branches;
next	1.69;

1.69
date	2003.10.30.02.44.37;	author morevit;	state Exp;
branches;
next	1.68;

1.68
date	2003.10.29.22.13.33;	author dropf;	state Exp;
branches;
next	1.67;

1.67
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.66;

1.66
date	2003.10.21.02.16.52;	author morevit;	state Exp;
branches;
next	1.65;

1.65
date	2003.10.20.13.20.02;	author morevit;	state Exp;
branches;
next	1.64;

1.64
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.63;

1.63
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.62;

1.62
date	2003.10.10.04.12.21;	author dongato;	state Exp;
branches;
next	1.61;

1.61
date	2003.10.08.15.39.48;	author morevit;	state Exp;
branches;
next	1.60;

1.60
date	2003.10.08.12.56.34;	author morevit;	state Exp;
branches;
next	1.59;

1.59
date	2003.10.05.06.22.51;	author dongato;	state Exp;
branches;
next	1.58;

1.58
date	2003.10.04.22.19.55;	author morevit;	state Exp;
branches;
next	1.57;

1.57
date	2003.10.04.10.04.43;	author morevit;	state Exp;
branches;
next	1.56;

1.56
date	2003.10.04.00.48.21;	author morevit;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.03.23.18.21;	author morevit;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.03.13.04.36;	author morevit;	state Exp;
branches;
next	1.53;

1.53
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.52;

1.52
date	2003.09.29.02.57.43;	author dongato;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.28.13.55.07;	author dongato;	state Exp;
branches;
next	1.50;

1.50
date	2003.09.24.20.37.30;	author dongato;	state Exp;
branches;
next	1.49;

1.49
date	2003.09.22.00.17.22;	author morevit;	state Exp;
branches;
next	1.48;

1.48
date	2003.09.21.22.05.17;	author morevit;	state Exp;
branches;
next	1.47;

1.47
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.46;

1.46
date	2003.09.14.13.48.42;	author dongato;	state Exp;
branches;
next	1.45;

1.45
date	2003.09.07.12.51.12;	author dongato;	state Exp;
branches;
next	1.44;

1.44
date	2003.08.31.23.19.16;	author dongato;	state Exp;
branches;
next	1.43;

1.43
date	2003.08.31.13.20.46;	author emoulari;	state Exp;
branches;
next	1.42;

1.42
date	2003.08.30.11.23.26;	author emoulari;	state Exp;
branches;
next	1.41;

1.41
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.40;

1.40
date	2003.08.15.15.11.29;	author forcha;	state Exp;
branches;
next	1.39;

1.39
date	2003.08.13.15.50.57;	author eklmn;	state Exp;
branches;
next	1.38;

1.38
date	2003.07.27.23.16.08;	author dongato;	state Exp;
branches;
next	1.37;

1.37
date	2003.07.25.05.11.01;	author partyckip;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.27.18.53.23;	author eklmn;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.25.18.32.05;	author eklmn;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.16.04.44.44;	author partyckip;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.11.18.27.11;	author eklmn;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.08.07.36.57;	author partyckip;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.01.08.59.02;	author kuchin;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.20.20.46.31;	author netwolf1;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.13.16.55.41;	author moosetea;	state Exp;
branches;
next	1.28;

1.28
date	2003.03.27.08.02.35;	author partyckip;	state Exp;
branches;
next	1.27;

1.27
date	2003.03.17.05.59.30;	author recdvst;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2003.03.14.18.13.13;	author cax2;	state Exp;
branches;
next	1.25;

1.25
date	2003.03.14.16.24.20;	author partyckip;	state Exp;
branches;
next	1.24;

1.24
date	2003.03.14.12.03.06;	author lord_kiron;	state Exp;
branches;
next	1.23;

1.23
date	2003.03.14.09.45.23;	author lord_kiron;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.13.21.35.17;	author partyckip;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.10.23.04.18;	author cax2;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.28.00.53.24;	author dongato;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.25.02.34.37;	author dongato;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2003.02.22.16.22.35;	author obaldin;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.20.20.46.53;	author obaldin;	state Exp;
branches;
next	1.16;

1.16
date	2003.02.20.07.25.22;	author cax2;	state Exp;
branches;
next	1.15;

1.15
date	2003.02.19.00.47.02;	author dongato;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.18.14.52.39;	author dongato;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.17.19.29.54;	author cax2;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.17.09.15.15;	author cax2;	state Exp;
branches;
next	1.11;

1.11
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.16.22.01.48;	author lord_kiron;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.13.17.45.44;	author cax2;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.12.21.55.33;	author obaldin;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.11.17.52.18;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.10.19.24.49;	author cax2;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.09.22.04.26;	author obaldin;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.01.14.45.39;	author dongato;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.01.22.17.42.07;	author kuchin;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.02.02.02.36.27;	author cax2;	state Exp;
branches;
next	;

1.3.2.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2003.02.05.17.03.13;	author obaldin;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.02.06.15.56.14;	author obaldin;	state Exp;
branches;
next	;

1.19.2.1
date	2003.02.28.22.44.55;	author obaldin;	state Exp;
branches;
next	;

1.27.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2003.03.24.09.39.44;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.180
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "updownclient.h"
#include "QueueListCtrl.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "opcodes.h"
#include "Details\ClientDetails.h"
#include "UploadQueue.h"
#include "TitleMenu.h"
#include "IP2Country.h"
#include "MemDC.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

BEGIN_MESSAGE_MAP(CQueueListCtrl, CMuleListCtrl)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnLvnColumnClick)
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMDblclkQueuelist)
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
	ON_WM_KEYUP()
END_MESSAGE_MAP()

IMPLEMENT_DYNAMIC(CQueueListCtrl, CMuleListCtrl)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQueueListCtrl::CQueueListCtrl()
{
	SetGeneralPurposeFind(true);

	m_pvecDirtyClients = new ClientVector();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CQueueListCtrl::~CQueueListCtrl()
{
	safe_delete(m_pvecDirtyClients);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::Init()
{
	static const uint16 s_auColHdr[][2] =
	{
		{ LVCFMT_LEFT, 150 },	// QLCOL_USERNAME
		{ LVCFMT_LEFT, 275 },	// QLCOL_FILENAME
		{ LVCFMT_LEFT, 110 },	// QLCOL_FILEPRIORITY
		{ LVCFMT_LEFT, 110 },	// QLCOL_PARTS
		{ LVCFMT_LEFT, 110 },	// QLCOL_PROGRESS
		{ LVCFMT_LEFT,  60 },	// QLCOL_QLRATING
		{ LVCFMT_LEFT,  60 },	// QLCOL_SCORE
		{ LVCFMT_LEFT,  60 },	// QLCOL_SFRATIO
		{ LVCFMT_LEFT,  60 },	// QLCOL_RFRATIO
		{ LVCFMT_LEFT,  60 },	// QLCOL_TIMESASKED
		{ LVCFMT_LEFT, 110 },	// QLCOL_LASTSEEN
		{ LVCFMT_LEFT, 110 },	// QLCOL_ENTEREDQUEUE
		{ LVCFMT_LEFT,  60 },	// QLCOL_BANNED
		{ LVCFMT_LEFT, 150 }	// QLCOL_COUNTRY
	};
	CImageList		ilDummyImageList;

	ilDummyImageList.Create(1, 17,g_App.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
	SetImageList(&ilDummyImageList, LVSIL_SMALL);
	ilDummyImageList.Detach();

	m_iClientFilter = CLI_FILTER_NONE;

	memzero(m_iColumnMaxWidths, sizeof(m_iColumnMaxWidths));
//	Index of the column being measured. -1 for none.
	m_iMeasuringColumn = -1;

	SetExtendedStyle(LVS_EX_FULLROWSELECT);
	for (unsigned ui = 0; ui < ARRSIZE(s_auColHdr); ui++)
		InsertColumn(ui, _T(""), static_cast<int>(s_auColHdr[ui][0]), static_cast<int>(s_auColHdr[ui][1]), ui);

	Localize();

	LoadSettings(CPreferences::TABLE_QUEUE);
	SetSortProcedure(SortProc);
	if (g_App.m_pPrefs->DoUseSort())
		SortInit(g_App.m_pPrefs->GetQueueSortCol());
	else
		SortInit(g_App.m_pPrefs->GetColumnSortCode(CPreferences::TABLE_QUEUE));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::Localize()
{
	static const uint16 s_auResTbl[] =
	{
		IDS_QL_USERNAME,	// QLCOL_USERNAME
		IDS_FILE,			// QLCOL_FILENAME
		IDS_FILEPRIO,		// QLCOL_FILEPRIORITY
		IDS_UP_PARTS,		// QLCOL_PARTS
		IDS_DL_PROGRESS,	// QLCOL_PROGRESS
		IDS_RATING,			// QLCOL_QLRATING
		IDS_SCORE,			// QLCOL_SCORE
		IDS_SFRATIO,		// QLCOL_SFRATIO
		IDS_RFRATIO,		// QLCOL_RFRATIO
		IDS_ASKED,			// QLCOL_TIMESASKED
		IDS_LASTSEEN,		// QLCOL_LASTSEEN
		IDS_ENTERQUEUE,		// QLCOL_ENTEREDQUEUE
		IDS_BANNED,			// QLCOL_BANNED
		IDS_COUNTRY			// QLCOL_COUNTRY
	};

	if (GetSafeHwnd())
	{
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
		CString		strRes;
		HDITEM		hdi;

		hdi.mask = HDI_TEXT;

		for (unsigned ui = 0; ui < ARRSIZE(s_auResTbl); ui++)
		{
			::GetResString(&strRes, static_cast<UINT>(s_auResTbl[ui]));
			hdi.pszText = const_cast<LPTSTR>(strRes.GetString());
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::AddClient(CUpDownClient *pClient)
{
	if (!g_App.m_pMDlg->IsRunning())
		return;
	if (!pClient)
		return;

	if (m_iClientFilter != 0)
		if (m_iClientFilter != GetClientFilterType(pClient))
			return;

	uint32		iNumItems = GetItemCount();

	iNumItems = InsertItem(LVIF_TEXT|LVIF_PARAM,iNumItems,LPSTR_TEXTCALLBACK,0,0,1,reinterpret_cast<LPARAM>(pClient));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::RemoveClient(CUpDownClient* pClient)
{
	if (!g_App.m_pMDlg->IsRunning())
		return;
	if (pClient == NULL)
		return;

	if (g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE)
	{
		if (g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.GetClient() == pClient)
		{
 			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
		}
	}

	LVFINDINFO		find;
	int			iResult;

	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;

	iResult = FindItem(&find);
	if (iResult != (-1))
		DeleteItem(iResult);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::UpdateClient(CUpDownClient *pClient)
{
	if (pClient != NULL)
	{
		if (AddDirtyClient(pClient))
			PostUniqueMessage(WM_QL_REFRESH);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
#define LIST_CELL_PADDING	6		//should be even number
	if (!g_App.m_pMDlg->IsRunning() || !lpDrawItemStruct->itemData)
		return;

	CDC		*odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	BOOL	bCtrlFocused = ((GetFocus() == this) || (GetStyle() & LVS_SHOWSELALWAYS));
	COLORREF	crBk, crWinBk;

	crWinBk = crBk = GetBkColor();
	if (lpDrawItemStruct->itemState & ODS_SELECTED)
		crBk = (bCtrlFocused) ? m_crHighlight : m_crNoHighlight;

	CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(lpDrawItemStruct->itemData);
	CMemDC			dc(odc, &lpDrawItemStruct->rcItem, crWinBk, crBk);
	CFont			*pOldFont = dc.SelectObject(GetFont());
	COLORREF		crOldTextColor = dc->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
	int				iWidth, iColumn;
	bool			bMeasuring = (m_iMeasuringColumn >= 0);
	UINT			iCalcFlag = bMeasuring ? (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_NOCLIP|DT_CALCRECT) : (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_NOCLIP|DT_END_ELLIPSIS);

	if (IsRightToLeftLanguage())
		iCalcFlag |= DT_RTLREADING;

	RECT			r = lpDrawItemStruct->rcItem;
	CString			strBuffer;

	CKnownFile		*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pClient->m_reqFileHash);
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
	int				iNumColumns = pHeaderCtrl->GetItemCount();

	r.right = r.left - LIST_CELL_PADDING / 2;
	r.left += LIST_CELL_PADDING / 2;
	iWidth = LIST_CELL_PADDING;

	for (int iCurrent = 0; iCurrent < iNumColumns; iCurrent++)
	{
		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
		if (IsColumnHidden(iColumn) || (bMeasuring && iColumn != m_iMeasuringColumn))
			continue;

		r.right += CListCtrl::GetColumnWidth(iColumn);
		switch (iColumn)
		{
			case QLCOL_USERNAME:
			{
				if (!bMeasuring)
				{
					POINT		point = {r.left, r.top + 1};
					int			iImgLstIdx = CLIENT_IMGLST_PLAIN;

				//	Select corresponding image list depending on client properties
					if (pClient->IsBanned())
						iImgLstIdx = CLIENT_IMGLST_BANNED;
					else if (pClient->IsFriend())
						iImgLstIdx = CLIENT_IMGLST_FRIEND;
					else if (pClient->m_pCredits->HasHigherScoreRatio(pClient->GetIP()))
						iImgLstIdx = CLIENT_IMGLST_CREDITUP;

				//	Display Client icon
					g_App.m_pMDlg->m_clientImgLists[iImgLstIdx].Draw(dc, pClient->GetClientIconIndex(), point, ILD_NORMAL);

					r.left += 20;
					if (g_App.m_pIP2Country->ShowCountryFlag())
					{
						point.x += 20;
						point.y += 2;
						g_App.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryIndex(), point, ILD_NORMAL);
						r.left += 22;
					}
				}
				else
				{
					iWidth += 20;
					if (g_App.m_pIP2Country->ShowCountryFlag())
						iWidth += 22;
				}

				strBuffer = pClient->GetUserName();
				break;
			}
			case QLCOL_FILENAME:
				if (pKnownFile)
					strBuffer = pKnownFile->GetFileName();
				else
					strBuffer = _T("?");
				break;

			case QLCOL_FILEPRIORITY:
			{
				if (pKnownFile)
				{
					UINT		dwResStrId;

					switch (pKnownFile->GetULPriority())
					{
						case PR_RELEASE:
							dwResStrId = IDS_PRIORELEASE;
							break;
						case PR_HIGH:
							dwResStrId = IDS_PRIOHIGH;
							break;
						case PR_LOW:
							dwResStrId = IDS_PRIOLOW;
							break;
						case PR_VERYLOW:
							dwResStrId = IDS_PRIOVERYLOW;
							break;
						default:
							dwResStrId = IDS_PRIONORMAL;
							break;
					}
					GetResString(&strBuffer, dwResStrId);
				}
				else
					strBuffer = _T("?");
				break;
			}
			case QLCOL_PARTS:
				if (pClient->GetUpPartCount())
					strBuffer.Format(_T("%u/%u"), pClient->GetAvailUpPartCount(), pClient->GetUpPartCount());
				else
					strBuffer = _T("");
				break;

			case QLCOL_PROGRESS:
			{
				if (pClient->GetUpPartCount() && g_App.m_pPrefs->IsUploadPartsEnabled())
				{
					if (!bMeasuring)
					{
						RECT	r2;

						r2.bottom = r.bottom - 1;
						r2.top = r.top + 1;
						r2.right = r.right + LIST_CELL_PADDING / 2;
						r2.left = r.left - LIST_CELL_PADDING / 2;
						pClient->DrawUpStatusBar(dc, &r2, g_App.m_pPrefs->UseFlatBar());
					}
					iWidth = 300;
				}
				break;
			}
			case QLCOL_QLRATING:
				strBuffer.Format(_T("%u"), pClient->GetScore(true));
				break;

			case QLCOL_SCORE:
			//	Note: actually the client, which is downloading from us should be not in WaitingQueue
				if (pClient->IsDownloading())
					strBuffer = _T("-");
				else
					strBuffer.Format((pClient->IsAddNextConnect()) ? _T("%u*") : _T("%u"), pClient->GetScore());
				break;

			case QLCOL_SFRATIO:
				if (pKnownFile != NULL)
					strBuffer.Format(_T("%.2f"), pKnownFile->GetSizeRatio());
				else
					strBuffer = _T("-");
				break;

			case QLCOL_RFRATIO:
				if (pKnownFile != NULL)
					strBuffer.Format(_T("%.2f"), pKnownFile->GetPopularityRatio());
				else
					strBuffer = _T("-");
				break;

			case QLCOL_TIMESASKED:
				strBuffer.Format(_T("%u"), pClient->GetAskedCount());
				break;

			case QLCOL_LASTSEEN:
				strBuffer = CastSecondsToHM((GetTickCount() - pClient->GetLastUpRequest())/1000);
				break;

			case QLCOL_ENTEREDQUEUE:
				strBuffer = CastSecondsToHM((GetTickCount() - pClient->GetWaitStartTime())/1000);
				break;

			case QLCOL_BANNED:
				strBuffer = YesNoStr(pClient->IsBanned());
				break;

			case QLCOL_COUNTRY:
				strBuffer = pClient->GetCountryName();
				break;
		}
		if (iColumn != QLCOL_PROGRESS)
		{
			dc->DrawText(strBuffer, &r, iCalcFlag);
			if (bMeasuring && !strBuffer.IsEmpty())
				iWidth += r.right - r.left + 1;
		}
		r.left = r.right + LIST_CELL_PADDING;

		if (bMeasuring)
		{
		//	Pin the column widths at some reasonable value
			if (iWidth < 40)
				iWidth = 40;
			if (iWidth > m_iColumnMaxWidths[m_iMeasuringColumn])
				m_iColumnMaxWidths[m_iMeasuringColumn] = iWidth;
		}
	}
//	Draw rectangle around selected item(s)
	if (lpDrawItemStruct->itemState & ODS_SELECTED)
	{
		RECT	rOutline = lpDrawItemStruct->rcItem;
		CBrush	FrmBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine);

		rOutline.left++;
		rOutline.right--;
		dc->FrameRect(&rOutline, &FrmBrush);
	}
	if (pOldFont)
		dc.SelectObject(pOldFont);
	if (crOldTextColor)
		dc.SetTextColor(crOldTextColor);
#undef LIST_CELL_PADDING
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CQueueListCtrl::OnWndMsg(UINT iMessage,WPARAM wParam, LPARAM lParam, LRESULT *pResult)
{
	BOOL		bHandled = TRUE;

	EMULE_TRY

	switch (iMessage)
	{
		case WM_QL_REFRESH:
		{
			CQueueListCtrl::ClientVector	   *pvecDirtyClients = GetDirtyClients();

			if (pvecDirtyClients != NULL)
			{
				SetRedraw(FALSE);

				int		iNumDirtySources = pvecDirtyClients->size();

				for (int i = 0; i < iNumDirtySources; i++)
				{
					LVFINDINFO		find;
					int				iResult;

					find.flags = LVFI_PARAM;
					find.lParam = (LPARAM)(*pvecDirtyClients)[i];

					iResult = FindItem(&find);
					if (iResult != -1)
						Update(iResult);
				}

				delete pvecDirtyClients;

				SetRedraw(TRUE);
			}
			break;
		}
		default:
			bHandled = FALSE;
			break;
	}

	EMULE_CATCH

	if (!bHandled)
		bHandled = CMuleListCtrl::OnWndMsg(iMessage, wParam, lParam, pResult);

	return bHandled;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader)
{
	EMULE_TRY

	int		iColumn = pHeader->iItem;

	m_iColumnMaxWidths[iColumn] = 0;
	m_iMeasuringColumn = iColumn;
	Invalidate();
	UpdateWindow();
	m_iMeasuringColumn = -1;
	if (m_iColumnMaxWidths[iColumn] > 0)
		SetColumnWidth(iColumn, m_iColumnMaxWidths[iColumn]);
	else
		CMuleListCtrl::OnNMDividerDoubleClick(pHeader);
	Invalidate();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// CQueueListCtrl message handlers

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::OnContextMenu(CWnd *pWnd, CPoint point)
{
	NOPRM(pWnd);
	EMULE_TRY

	CTitleMenu		menuClient;
	CMenu			menuFilter;
	CUpDownClient	*pClient = NULL;
	POSITION		posSelClient = GetFirstSelectedItemPosition();
	UINT			dwFlags = MF_STRING | MF_GRAYED;

	if (posSelClient)
	{
		dwFlags = MF_STRING;
		pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

		if (pClient)
		{
			g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, pClient);
		}
	}

//	Show filtered list of clients
	menuFilter.CreateMenu();
	menuFilter.AppendMenu( MF_STRING | ((m_iClientFilter == CLI_FILTER_NONE) ? MF_CHECKED : MF_UNCHECKED),
		MP_FILTER_NONE, GetResString(IDS_CAT_REINVADD) );
//	menuFilter.AppendMenu( MF_STRING | ((m_iClientFilter == CLI_FILTER_BANNED) ? MF_CHECKED : MF_UNCHECKED),
//		MP_FILTER_BANNED, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_BANNED) );
	menuFilter.AppendMenu( MF_STRING | ((m_iClientFilter == CLI_FILTER_FRIEND) ? MF_CHECKED : MF_UNCHECKED),
		MP_FILTER_FRIEND, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_FRIEND) );
	menuFilter.AppendMenu( MF_STRING | ((m_iClientFilter == CLI_FILTER_CREDIT) ? MF_CHECKED : MF_UNCHECKED),
		MP_FILTER_CREDIT, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_CREDIT) );

	menuClient.CreatePopupMenu();
	menuClient.AddMenuTitle(GetResString(IDS_CLIENTS));
	menuClient.AppendMenu(dwFlags, MP_DETAIL, GetStringFromShortcutCode(IDS_SHOWDETAILS, SCUT_SRC_DETAILS, SSP_TAB_PREFIX));

	UINT_PTR	dwRes = MP_ADDFRIEND;
	UINT		dwResStrId = IDS_ADDFRIEND;

	if (pClient && pClient->IsFriend())
	{
		dwRes = MP_REMOVEFRIEND;
		dwResStrId = IDS_REMOVEFRIEND;
	}
	menuClient.AppendMenu(dwFlags, dwRes, GetStringFromShortcutCode(dwResStrId, SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwFlags,MP_MESSAGE, GetStringFromShortcutCode(IDS_SEND_MSG, SCUT_SRC_MSG, SSP_TAB_PREFIX));
	menuClient.AppendMenu( dwFlags | ((pClient != NULL && pClient->GetViewSharedFilesSupport()) ? MF_ENABLED : MF_GRAYED),
		MP_SHOWLIST, GetStringFromShortcutCode(IDS_VIEWFILES, SCUT_SRC_SHAREDFILES, SSP_TAB_PREFIX) );
	menuClient.AppendMenu(dwFlags | ((pClient && pClient->IsBanned()) ? MF_ENABLED : MF_GRAYED), MP_UNBAN, GetResString(IDS_UNBAN));

	menuClient.AppendMenu(MF_SEPARATOR);
	menuClient.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)menuFilter.m_hMenu, GetResString(IDS_QUEUEFILTER));

	menuClient.SetDefaultItem((g_App.m_pPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
	menuClient.TrackPopupMenuEx(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this, NULL);

//	Menu objects are destroyed in their destructor

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CQueueListCtrl::OnCommand(WPARAM wParam, LPARAM lParam)
{
	POSITION posSelClient = GetFirstSelectedItemPosition();
	NOPRM(lParam);

	if (posSelClient)
	{
		CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

		switch (wParam)
		{
			case MP_SHOWLIST:
				pClient->RequestSharedFileList();
				break;
			case MP_MESSAGE:
				g_App.m_pMDlg->m_wndChat.StartSession(pClient);
				break;
			case MP_ADDFRIEND:
				g_App.m_pFriendList->AddFriend(pClient);
				break;
			case MP_REMOVEFRIEND:
				g_App.m_pFriendList->RemoveFriend(pClient);
				break;
			case MP_UNBAN:
				if( pClient->IsBanned() )
					pClient->UnBan();
				break;
			case MP_DETAIL:
			{
				CClientDetails dialog(IDS_CD_TITLE, pClient, this, 0);
				dialog.DoModal();
				break;
			}
		}
	}
	switch(wParam)
	{
		case MP_FILTER_NONE:
		{
			m_iClientFilter = CLI_FILTER_NONE;
			ShowFilteredList();
			g_App.m_pMDlg->m_wndTransfer.UpdateQueueFilter();
			break;
		}
		case MP_FILTER_BANNED:
		{
			m_iClientFilter = CLI_FILTER_BANNED;
			ShowFilteredList();
			g_App.m_pMDlg->m_wndTransfer.UpdateQueueFilter();
			break;
		}
		case MP_FILTER_FRIEND:
		{
			m_iClientFilter = CLI_FILTER_FRIEND;
			ShowFilteredList();
			g_App.m_pMDlg->m_wndTransfer.UpdateQueueFilter();
			break;
		}
		case MP_FILTER_CREDIT:
		{
			m_iClientFilter = CLI_FILTER_CREDIT;
			ShowFilteredList();
			g_App.m_pMDlg->m_wndTransfer.UpdateQueueFilter();
			break;
		}
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CQueueListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	CUpDownClient* pClient1 = (CUpDownClient*)lParam1;
	CUpDownClient* pClient2 = (CUpDownClient*)lParam2;

	if (pClient1 == NULL || pClient2 == NULL)
		return 0;

	CKnownFile* pSharedFile1 = g_App.m_pSharedFilesList->GetFileByID(pClient1->m_reqFileHash);
	CKnownFile* pSharedFile2 = g_App.m_pSharedFilesList->GetFileByID(pClient2->m_reqFileHash);

	int	iCompare = 0;
	int	iSortMod = ((lParamSort & MLC_SORTDESC) == 0) ? 1 : -1;
	int	iSortColumn = (lParamSort & MLC_COLUMNMASK);

	switch(iSortColumn)
	{
		case QLCOL_USERNAME:
		{
			iCompare = pClient1->CmpUserNames(pClient2->GetUserName());
			break;
		}
		case QLCOL_COUNTRY:
		{
			CString strCountry1 = pClient1->GetCountryName();
			CString strCountry2 = pClient2->GetCountryName();

			if (!strCountry1.IsEmpty() && !strCountry2.IsEmpty())
				iCompare = _tcsicmp(strCountry1, strCountry2);
			else
			{
				iCompare = strCountry1.IsEmpty() ? (strCountry2.IsEmpty() ? 0 : 1) : -1;
				iSortMod = 1;		//empty entries at the bottom in any case
			}

			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2,QLCOL_USERNAME);
				iSortMod = 1;		//sort allways in ascending order
			}
			break;
		}
		case QLCOL_FILENAME:
			if ((pSharedFile1 != NULL) && (pSharedFile2 != NULL))
				iCompare = pSharedFile1->CmpFileNames(pSharedFile2->GetFileName());
			else
				iCompare = (pSharedFile1 == NULL) ? ((pSharedFile2 == NULL) ? 0 : 1) : -1;
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2, QLCOL_USERNAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
			break;
		case QLCOL_FILEPRIORITY:
			if(pSharedFile1 != NULL && pSharedFile2 != NULL)		//Cax2 - right priority sortig
			{
				if (pSharedFile1->GetULPriority() == PR_VERYLOW)
					iCompare = -1;
				else if (pSharedFile2->GetULPriority() == PR_VERYLOW)
					iCompare = 1;
				else
					iCompare = pSharedFile1->GetULPriority() - pSharedFile2->GetULPriority();
			}
			else
				iCompare = ( pSharedFile1 == NULL ) ? ((pSharedFile2 == NULL) ? 0 : 1) : -1;
			//eklmn: additional sorting by filename & username
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2, QLCOL_FILENAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
			break;
		case QLCOL_PARTS:
		case QLCOL_PROGRESS:
		{  // obaldin: sort by upload progress
			uint32 partcnt1 = pClient1->GetUpPartCount();
			uint32 partcnt2 = pClient2->GetUpPartCount();

			if((partcnt1!=0) && (partcnt2!=0))
			{
				double	dblProgress1 = static_cast<double>(pClient1->GetAvailUpPartCount())/static_cast<double>(partcnt1);
				double	dblProgress2 = static_cast<double>(pClient2->GetAvailUpPartCount())/static_cast<double>(partcnt2);

				iCompare = (dblProgress1 > dblProgress2) ? 1 : ((dblProgress1 < dblProgress2) ? -1: 0);
			}
			else
				iCompare = ( partcnt1 == 0 ) ? ((partcnt2 == 0) ? 0 : 1) : -1;
			break;
		}
		case QLCOL_QLRATING:
			iCompare = pClient1->GetScore(true) - pClient2->GetScore(true);
			break;
		case QLCOL_SCORE:
			iCompare =  pClient1->GetScore() - pClient2->GetScore();
			break;
		case QLCOL_SFRATIO: //small file  asc
			if( (pSharedFile1 != NULL) && (pSharedFile2 != NULL))
				iCompare = static_cast<int>(100.0*(pSharedFile1->GetSizeRatio() - pSharedFile2->GetSizeRatio()) );
			else
				iCompare = ( pSharedFile1 == NULL ) ? ((pSharedFile2 == NULL) ? 0 : 1) : -1;
			break;
		case QLCOL_RFRATIO: //rare file asc
			if( (pSharedFile1 != NULL) && (pSharedFile2 != NULL))
				iCompare = static_cast<int>(100.0 *(pSharedFile1->GetPopularityRatio() - pSharedFile2->GetPopularityRatio()) );
			else
				iCompare = ( pSharedFile1 == NULL ) ? ((pSharedFile2 == NULL) ? 0 : 1) : -1;
			break;
		case QLCOL_TIMESASKED:
			iCompare =  pClient1->GetAskedCount() - pClient2->GetAskedCount();
			break;
		case QLCOL_LASTSEEN:
			iCompare =  pClient2->GetLastUpRequest() - pClient1->GetLastUpRequest();
			break;
		case QLCOL_ENTEREDQUEUE:
			iCompare = pClient2->GetWaitStartTime() - pClient1->GetWaitStartTime();
			break;
		case QLCOL_BANNED:
			iCompare = pClient1->IsBanned() - pClient2->IsBanned();
			//eklmn: additional sorting by filename & username
			if (iCompare == 0)
			{
				iCompare = SortProc(lParam1,lParam2, QLCOL_FILENAME);
				iSortMod = 1;		//eklmn: sort allways in ascending order
			}
			break;
		default:
			iCompare =  0;
	}

	return iCompare*iSortMod;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::OnNMClick(NMHDR *pNMHDR, LRESULT *pResult)
{
//	Reset selection in DL list
	POSITION posSelClient = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetFirstSelectedItemPosition();
	NOPRM(pNMHDR);

	while (posSelClient != NULL)
	{
		int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetNextSelectedItem(posSelClient);
		g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, 0, LVIS_SELECTED);
	}

	RefreshInfo();
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::OnNMDblclkQueuelist(NMHDR *pNMHDR, LRESULT *pResult)
{
	POSITION posSelClient = GetFirstSelectedItemPosition();
	NOPRM(pNMHDR);

	if (posSelClient)
	{
		CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

		if (g_App.m_pPrefs->GetDetailsOnClick())
		{
			CClientDetails dialog(IDS_CD_TITLE, pClient, this, 0);
			dialog.DoModal();
		}
		else
		{
			g_App.m_pMDlg->m_wndChat.StartSession(pClient);
		}
	}
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::ShowSelectedUserDetails()
{
	POINT point;

	::GetCursorPos(&point);

	CPoint p = point;

    ScreenToClient(&p);

    int it = HitTest(p);

    if (it == -1)
	{
		return;
	}
	SetSelectionMark(it);

	CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetSelectionMark()));

	if (pClient != NULL)
	{
			CClientDetails dialog(IDS_CD_TITLE, pClient, this, 0);
			dialog.DoModal();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	RefreshInfo();
	CMuleListCtrl::OnKeyUp(nChar, nRepCnt, nFlags);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::RefreshInfo(void)
{
	if (GetFocus() == this)
	{
		POSITION		posSelClient = GetFirstSelectedItemPosition();

		if(posSelClient == 0)
		{
	 		g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
		}
		else
		{
			CUpDownClient		*pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

	 		g_App.m_pMDlg->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,pClient);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::OnGetDispInfo(NMHDR *pNMHDR, LRESULT *pResult)
{
	NMLVDISPINFO	*pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);

	if (g_App.m_pMDlg->IsRunning())
	{
		// Although we have an owner drawn listview control we store the text for the primary item in the listview, to be
		// capable of quick searching those items via the keyboard. Because our listview items may change their contents,
		// we do this via a text callback function. The listview control will send us the LVN_DISPINFO notification if
		// it needs to know the contents of the primary item.
		//
		// But, the listview control sends this notification all the time, even if we do not search for an item. At least
		// this notification is only sent for the visible items and not for all items in the list. Though, because this
		// function is invoked *very* often, no *NOT* put any time consuming code here in.

		if ((pDispInfo->item.mask & LVIF_TEXT) != 0)
		{
		//	Check for own search request, the rest of the flood comes from list control
		//	and isn't used as list is drawn by us
			if (pDispInfo->item.cchTextMax == ML_SEARCH_SZ)
			{
				CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);

				if (pClient != NULL)
				{
					switch (pDispInfo->item.iSubItem)
					{
						case QLCOL_USERNAME:
							_tcsncpy(pDispInfo->item.pszText, pClient->GetUserName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						case QLCOL_COUNTRY:
							_tcsncpy(pDispInfo->item.pszText, pClient->GetCountryName(), pDispInfo->item.cchTextMax);
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
							break;

						case QLCOL_FILENAME:
						{
							CKnownFile	*pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pClient->m_reqFileHash);

							if (pKnownFile != NULL)
							{
								_tcsncpy(pDispInfo->item.pszText, pKnownFile->GetFileName(), pDispInfo->item.cchTextMax);
								pDispInfo->item.pszText[pDispInfo->item.cchTextMax - 1] = _T('\0');
								break;
							}
						}
						default:
							pDispInfo->item.pszText[0] = _T('\0');
							break;
					}
				}
			}
			else if (pDispInfo->item.cchTextMax != 0)
				pDispInfo->item.pszText[0] = _T('\0');
		}
	}
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//DonGato: show filtered list of clients
void CQueueListCtrl::ShowFilteredList()
{
	CUpDownClient	   *pClient;

	SetRedraw(FALSE);
	DeleteAllItems();
	for (POSITION pos = g_App.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
	{
		pClient = g_App.m_pUploadQueue->GetNext(pos);
		if (pClient != NULL)
		{
			AddClient(pClient);
		}
	}
	SetRedraw(TRUE);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Show filtered list of clients
int CQueueListCtrl::GetClientFilterType(CUpDownClient* client)
{
	if (client->IsBanned())
		return 1;
	else if (client->IsFriend())
		return 2;
	else if (client->m_pCredits->HasHigherScoreRatio(client->GetIP()))
		return 3;
	else
		return 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CQueueListCtrl::PreTranslateMessage(MSG *pMsg)
{
	if ((pMsg->message == WM_KEYDOWN) || (pMsg->message == WM_SYSKEYDOWN))
	{
		int		 iMessage	  = 0;
		POSITION posSelClient = GetFirstSelectedItemPosition();

		if (posSelClient != NULL)
		{
			short			nCode = GetCodeFromPressedKeys(pMsg);
			CUpDownClient	*pSource = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));

			iMessage = GetClientListActionFromShortcutCode(nCode, pSource);

			if (iMessage > 0)
			{
				PostMessage(WM_COMMAND, static_cast<WPARAM>(iMessage));
				return TRUE;
			}
		}
	}

	return CMuleListCtrl::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CQueueListCtrl::AddDirtyClient(CUpDownClient* pClientItem)
{
	bool bResult = false;

//	If 'pClient' is not already in the dirty client list...
	if (m_pvecDirtyClients != NULL
		&& ::find(m_pvecDirtyClients->begin(),m_pvecDirtyClients->end(), pClientItem) == m_pvecDirtyClients->end())
	{
		m_pvecDirtyClients->push_back(pClientItem);
		bResult = true;
	}

	return bResult;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	GetDirtySources() detaches the current dirty source list and returns it to the caller (who's responsible
//		for destroying it). This allows the download list control to update without locking down the download list.
CQueueListCtrl::ClientVector* CQueueListCtrl::GetDirtyClients()
{
	ClientVector		*pDirtyClients = NULL;

	if (!m_pvecDirtyClients->empty())
	{
		pDirtyClients = m_pvecDirtyClients;
		m_pvecDirtyClients = new ClientVector();
	}

	return pDirtyClients;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.179
log
@Save sorting directions for all GUI lists; Unified list sort initialization and click processing;
Simplified list arrow configuration interface.
@
text
@d26 1
@


1.178
log
@Slightly more efficient GetColumnWidth to speed up list drawing.
@
text
@d38 1
a38 1
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
a49 2
	memset(&m_bSortAscending, true, sizeof(m_bSortAscending));

d98 1
a99 1
	{
a100 1
	}
d102 1
a102 18
	{
		int		iSortCode = g_App.m_pPrefs->GetColumnSortItem(CPreferences::TABLE_QUEUE);

		iSortCode |= g_App.m_pPrefs->GetColumnSortAscending(CPreferences::TABLE_QUEUE) ? MLC_SORTASC : MLC_SORTDESC;
		SortInit(iSortCode);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::SortInit(int iSortCode)
{
//	Get the sort column
	int iSortColumn = (iSortCode & MLC_COLUMNMASK);
//	Get the sort order
	bool bSortAscending = (iSortCode & MLC_SORTDESC) == 0;

	SetSortArrow(iSortColumn,bSortAscending);
	SortItems(SortProc, iSortCode);
	m_bSortAscending[iSortColumn] = bSortAscending;
a621 17
void CQueueListCtrl::OnColumnClick(NMHDR *pNMHDR, LRESULT *pResult)
{
	NM_LISTVIEW	*pNMListView = reinterpret_cast<NM_LISTVIEW*>(pNMHDR);
	int			iSubItem = pNMListView->iSubItem;
	bool		bSortOrder = m_bSortAscending[iSubItem];

// Reverse sorting direction for the same column and keep the same if column was changed
	if (static_cast<int>(m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
		m_bSortAscending[iSubItem] = bSortOrder = !bSortOrder;

	SetSortArrow(iSubItem, bSortOrder);
	SortItems(SortProc, iSubItem + ((bSortOrder) ? MLC_SORTASC : MLC_SORTDESC));
	g_App.m_pPrefs->SetColumnSortItem(CPreferences::TABLE_QUEUE, iSubItem);
	g_App.m_pPrefs->SetColumnSortAscending(CPreferences::TABLE_QUEUE, bSortOrder);
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.177
log
@Simplified column resize interface; Minor generic optimization; Reduced H-file dependency.
@
text
@d255 1
a255 1
		r.right += GetColumnWidth(iColumn);
@


1.176
log
@Optimized list drawing; Slightly reduced column margins (space between actual data).
@
text
@d22 1
d231 1
a231 1
	int				iWidth, iRight, iColumn;
a255 1
		iRight = r.right;
d409 1
a409 1
		r.left = iRight + LIST_CELL_PADDING;
d487 1
a487 1
BOOL CQueueListCtrl::OnNMDividerDoubleClick(NMHEADER *pHeader, LRESULT *pResult)
d499 1
a499 1
		SetColumnWidth(iColumn,m_iColumnMaxWidths[iColumn]);
d501 1
a501 1
		CMuleListCtrl::OnNMDividerDoubleClick(pHeader,pResult);
a504 2

	return *pResult = TRUE;
d793 1
a793 1
	//eklmn: reset selection in DL list
d797 1
a797 1
	if (posSelClient)
d799 2
a800 6
		while (posSelClient)
		{
			int iSelClientListIndex = g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.GetNextSelectedItem(posSelClient);
			g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, (UINT)~LVIS_SELECTED, LVIS_SELECTED);
		}

@


1.175
log
@Reduced H-file dependency.
@
text
@d214 2
a215 4
	if (!g_App.m_pMDlg->IsRunning())
		return;

	if (!lpDrawItemStruct->itemData)
d230 1
a230 1
	int				iWidth;
d244 3
a246 3
	r.right = r.left - 4;
	r.left += 4;
	iWidth = 8;
d250 3
a252 1
		int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
d254 3
a256 1
		if (!IsColumnHidden(iColumn) && !(bMeasuring && iColumn != m_iMeasuringColumn))
d258 1
a258 2
			r.right += GetColumnWidth(iColumn);
			switch (iColumn)
d260 1
a260 1
				case QLCOL_USERNAME:
d262 2
a263 6
					RECT			r2 = r;

					if (!bMeasuring)
					{
						POINT		point = {r2.left, r2.top + 1};
						int			iImgLstIdx = CLIENT_IMGLST_PLAIN;
d265 7
a271 7
					//	Select corresponding image list depending on client properties
						if (pClient->IsBanned())
							iImgLstIdx = CLIENT_IMGLST_BANNED;
						else if (pClient->IsFriend())
							iImgLstIdx = CLIENT_IMGLST_FRIEND;
						else if (pClient->m_pCredits->HasHigherScoreRatio(pClient->GetIP()))
							iImgLstIdx = CLIENT_IMGLST_CREDITUP;
d273 2
a274 2
					//	Display Client icon
						g_App.m_pMDlg->m_clientImgLists[iImgLstIdx].Draw(dc, pClient->GetClientIconIndex(), point, ILD_NORMAL);
d276 2
a277 10
						r2.left += 20;
						if (g_App.m_pIP2Country->ShowCountryFlag())
						{
							point.x += 20;
							point.y += 2;
							g_App.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryIndex(), point, ILD_NORMAL);
							r2.left += 22;
						}
					}
					else
d279 4
a282 3
						iWidth += 20;
						if (g_App.m_pIP2Country->ShowCountryFlag())
							iWidth += 22;
d284 7
d292 9
a300 2
					strBuffer = pClient->GetUserName();
					dc->DrawText(strBuffer, &r2, iCalcFlag);
d302 5
a306 2
					if (bMeasuring && strBuffer.GetLength() != 0)
						iWidth += (r2.right - r2.left + 1);
d308 1
a308 12
					break;
				}
				case QLCOL_FILENAME:
					if (pKnownFile)
						strBuffer = pKnownFile->GetFileName();
					else
						strBuffer = _T("?");
					break;

				case QLCOL_FILEPRIORITY:
				{
					if (pKnownFile)
d310 15
a324 21
						UINT		dwResStrId;

						switch (pKnownFile->GetULPriority())
						{
							case PR_RELEASE:
								dwResStrId = IDS_PRIORELEASE;
								break;
							case PR_HIGH:
								dwResStrId = IDS_PRIOHIGH;
								break;
							case PR_LOW:
								dwResStrId = IDS_PRIOLOW;
								break;
							case PR_VERYLOW:
								dwResStrId = IDS_PRIOVERYLOW;
								break;
							default:
								dwResStrId = IDS_PRIONORMAL;
								break;
						}
						GetResString(&strBuffer, dwResStrId);
d326 1
a326 3
					else
						strBuffer = _T("?");
					break;
d328 10
a337 6
				case QLCOL_PARTS:
					if (pClient->GetUpPartCount())
						strBuffer.Format(_T("%u/%u"), pClient->GetAvailUpPartCount(), pClient->GetUpPartCount());
					else
						strBuffer = _T("");
					break;
d339 3
a341 1
				case QLCOL_PROGRESS:
d343 1
a343 1
					if (pClient->GetUpPartCount() && g_App.m_pPrefs->IsUploadPartsEnabled())
d345 1
a345 3
						if (!bMeasuring)
						{
							RECT	r2;
d347 5
a351 7
							r2.bottom = r.bottom - 1;
							r2.top = r.top + 1;
							r2.right = r.right + 6;
							r2.left = r.left - 3;
							pClient->DrawUpStatusBar(dc, &r2, g_App.m_pPrefs->UseFlatBar());
						}
						iWidth = 300;
d353 1
a353 1
					break;
d355 1
a355 61
				case QLCOL_QLRATING:
					strBuffer.Format(_T("%u"), pClient->GetScore(true));
					break;

				case QLCOL_SCORE:
				//	Note: actually the client, which is downloading from us should be not in WaitingQueue
					if (pClient->IsDownloading())
						strBuffer = _T("-");
					else
						strBuffer.Format((pClient->IsAddNextConnect()) ? _T("%u*") : _T("%u"), pClient->GetScore());
					break;

				case QLCOL_SFRATIO:
					if (pKnownFile != NULL)
						strBuffer.Format(_T("%.2f"), pKnownFile->GetSizeRatio());
					else
						strBuffer = _T("-");
					break;

				case QLCOL_RFRATIO:
					if (pKnownFile != NULL)
						strBuffer.Format(_T("%.2f"), pKnownFile->GetPopularityRatio());
					else
						strBuffer = _T("-");
					break;

				case QLCOL_TIMESASKED:
					strBuffer.Format(_T("%u"), pClient->GetAskedCount());
					break;

				case QLCOL_LASTSEEN:
					strBuffer = CastSecondsToHM((GetTickCount() - pClient->GetLastUpRequest())/1000);
					break;

				case QLCOL_ENTEREDQUEUE:
					strBuffer = CastSecondsToHM((GetTickCount() - pClient->GetWaitStartTime())/1000);
					break;

				case QLCOL_BANNED:
					strBuffer = YesNoStr(pClient->IsBanned());
					break;

				case QLCOL_COUNTRY:
					strBuffer = pClient->GetCountryName();
					break;
			}
			if (iColumn != QLCOL_PROGRESS && iColumn != QLCOL_USERNAME)
			{
				dc->DrawText(strBuffer, &r, iCalcFlag);
				if (bMeasuring && !strBuffer.IsEmpty())
					iWidth += r.right - r.left + 1;
			}
			r.left += GetColumnWidth(iColumn);

			if (bMeasuring)
			{
			//	Pin the column widths at some reasonable value
				if (iWidth < 40 && iWidth != 0)
					iWidth = 40;
				if (iWidth > m_iColumnMaxWidths[m_iMeasuringColumn])
					m_iColumnMaxWidths[m_iMeasuringColumn] = iWidth;
d357 61
d434 1
@


1.174
log
@Allow search by file, hash, country and client software in source lists on transfer page (by client software in the download source list; by file and country in the upload and wait lists; by client software, hash and country in the known client list);
Fixed recently broken search in the transfer pane lists;
Increased transfer page list performance by not processing meaningless list control GetDispInfo requests.
@
text
@d20 1
@


1.173
log
@Fixed crash caused by invalid pointers casting {Nestor};
Minor code cleanup.
@
text
@a17 2
// QueueListCtrl.cpp : implementation file

a42 2
// CQueueListCtrl

d909 1
a909 1
		if ((pDispInfo->item.mask & (LVIF_TEXT | LVIF_PARAM)) == (LVIF_TEXT | LVIF_PARAM))
d911 5
a915 1
			CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);
d917 1
a917 3
			if (pClient != NULL)
			{
				switch (pDispInfo->item.iSubItem)
d919 3
a921 3
					case 0:
						if (!pClient->IsUserNameEmpty() && (pDispInfo->item.cchTextMax > 0))
						{
d924 17
d942 4
a945 5
						break;
					default:
						// shouldn't happen
						pDispInfo->item.pszText[0] = _T('\0');
						break;
d948 2
@


1.172
log
@removed duplicated GetuserName() method
@
text
@d900 1
a900 1
	NMLVDISPINFO *pDispInfo = reinterpret_cast<NMLVDISPINFO*>(pNMHDR);
d902 2
a903 1
	if (g_App.m_pMDlg->IsRunning()){
d913 8
a920 4
		if (pDispInfo->item.mask & LVIF_TEXT){
			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(pDispInfo->item.lParam);
			if (pClient != NULL){
				switch (pDispInfo->item.iSubItem){
@


1.171
log
@Rolled back recent change 'do not send an update messages if windows is not visible' as it broke proper list sorting.
@
text
@d298 1
a298 1
					pClient->GetUserName(&strBuffer);
@


1.170
log
@do not send an update messages if windows is not visible
@
text
@d208 1
a208 1
	if (IsWindowVisible() && pClient != NULL)
a210 1
		{
a211 1
		}
@


1.169
log
@rolled back last changes.
@
text
@d208 1
a208 1
	if (pClient != NULL)
@


1.168
log
@changed the handlig of embedded GUI list header
@
text
@a98 2
	InitHeader();

d149 1
d159 1
a159 1
			m_pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d248 2
a249 1
	int				iNumColumns = m_pHeaderCtrl->GetItemCount();
d257 1
a257 1
		int		iColumn = m_pHeaderCtrl->OrderToIndex(iCurrent);
@


1.167
log
@removed useless methods
@
text
@d99 2
a150 1
		CHeaderCtrl	*pHeaderCtrl = GetHeaderCtrl();
d160 1
a160 1
			pHeaderCtrl->SetItem(static_cast<int>(ui), &hdi);
d249 1
a249 2
	CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
	int				iNumColumns = pHeaderCtrl->GetItemCount();
d257 1
a257 1
		int		iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
@


1.166
log
@Optimized setting title for client details dialog.
@
text
@a42 1
	ON_WM_ERASEBKGND()
a899 12
// eklmn: let MuleListCtrl to do the job
BOOL CQueueListCtrl::OnEraseBkgnd(CDC* pDC)
{
	return CMuleListCtrl::OnEraseBkgnd(pDC);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// eklmn: let MuleListCtrl to do the job
BOOL CQueueListCtrl::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult)
{
	return CMuleListCtrl::OnChildNotify(message, wParam, lParam, pLResult);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.165
log
@Optimized string shortcut representation.
@
text
@d618 1
a618 1
				CClientDetails dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
d838 1
a838 1
			CClientDetails dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
d871 1
a871 1
			CClientDetails dialog(GetResString(IDS_CD_TITLE), pClient, this, 0);
@


1.164
log
@removed the set of ODA_SELECT action on item drawing
@
text
@d562 1
a562 1
	menuClient.AppendMenu(dwFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(SCUT_SRC_DETAILS, SSP_TAB_PREFIX));
d572 2
a573 2
	menuClient.AppendMenu(dwFlags, dwRes, GetResString(dwResStrId) + GetStringFromShortcutCode(SCUT_SRC_FRIEND, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(SCUT_SRC_MSG, SSP_TAB_PREFIX));
d575 1
a575 1
		MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(SCUT_SRC_SHAREDFILES, SSP_TAB_PREFIX) );
@


1.163
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d231 1
a231 1
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
d436 1
a436 1
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
@


1.162
log
@Simplified DrawText code -- no logic changed.
@
text
@d97 1
a97 1
	for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auColHdr); ui++)
d156 1
a156 1
		for (unsigned ui = 0; ui < ELEMENT_COUNT(s_auResTbl); ui++)
d438 2
a439 1
		RECT		rOutline = lpDrawItemStruct->rcItem;
d443 1
a443 1
		dc->FrameRect(&rOutline, &CBrush((bCtrlFocused) ? m_crFocusLine : m_crNoFocusLine));
d527 1
a527 1
void CQueueListCtrl::OnContextMenu(CWnd* pWnd, CPoint point)
d529 1
d589 1
a589 1
BOOL CQueueListCtrl::OnCommand(WPARAM wParam,LPARAM lParam )
d592 1
d665 1
a665 1
	if ((m_dwParamSort & MLC_COLUMNMASK) == iSubItem)
a808 1

d811 1
d818 1
a818 1
			g_App.m_pMDlg->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d830 1
@


1.161
log
@Fixed rare crash while processing client lists (score access when pClient->m_pCredits = NULL) {ompz};
Optimized score calculation and higher score status detection.
@
text
@d302 1
a302 1
					dc->DrawText(strBuffer, strBuffer.GetLength(), &r2, iCalcFlag);
d419 1
a419 1
				dc->DrawText(strBuffer,strBuffer.GetLength(),&r,iCalcFlag);
@


1.160
log
@Don't calculate score for downloading sources.
@
text
@d279 1
a279 1
						else if (pClient->m_pCredits->GetScoreRatio(pClient->GetIP()) > 1)
d963 1
a963 1
//DonGato: show filtered list of clients
d970 1
a970 1
	else if ((client->m_pCredits->GetScoreRatio(client->GetIP()) > 1))
@


1.159
log
@Rolled back "don't process invisible GUI lists" - reason: current list positions and visible view regions are not preserved.
@
text
@d372 1
a372 1
					strBuffer.Format(_T("%u"), pClient->GetScore(pClient->IsDownloading(), true));
d380 1
a380 1
						strBuffer.Format((pClient->IsAddNextConnect()) ? _T("%u*") : _T("%u"), pClient->GetScore(false));
d762 1
a762 1
			iCompare = pClient1->GetScore(false, true) - pClient2->GetScore(false, true);
d765 1
a765 1
			iCompare =  pClient1->GetScore(false) - pClient2->GetScore(false);
@


1.158
log
@don't process invisible GUI lists
@
text
@a57 2

	m_bIsVisible = false;
a164 16
BOOL CQueueListCtrl::ShowWindow(int iCmdShow)
{
	if (iCmdShow == SW_HIDE)
	{
		m_bIsVisible = false;
		DeleteAllItems();
	}
	else if(iCmdShow == SW_SHOW)
	{
		m_bIsVisible = true;
		ShowFilteredList();
	}

	return CMuleListCtrl::ShowWindow(iCmdShow);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d169 2
d172 3
a174 5
	if (m_bIsVisible && pClient != NULL)
	{
		if (m_iClientFilter != 0)
			if (m_iClientFilter != GetClientFilterType(pClient))
				return;
d176 1
a176 1
		uint32		iNumItems = GetItemCount();
d178 1
a178 2
		iNumItems = InsertItem(LVIF_TEXT|LVIF_PARAM,iNumItems,LPSTR_TEXTCALLBACK,0,0,1,reinterpret_cast<LPARAM>(pClient));
	}
d196 2
a197 7
	if (m_bIsVisible)
	{
		LVFINDINFO		find;
		int			iResult;

		find.flags = LVFI_PARAM;
		find.lParam = (LPARAM)pClient;
d199 2
a200 1
		iResult = FindItem(&find);
d202 3
a204 3
		if (iResult != (-1))
			DeleteItem(iResult);
	}
d209 1
a209 1
	if (m_bIsVisible && pClient != NULL)
d466 3
a468 1
				if (m_bIsVisible)
d470 2
a471 6
					int		iNumDirtySources = pvecDirtyClients->size();

					for (int i = 0; i < iNumDirtySources; i++)
					{
						LVFINDINFO		find;
						int				iResult;
d473 2
a474 2
						find.flags = LVFI_PARAM;
						find.lParam = (LPARAM)(*pvecDirtyClients)[i];
d476 3
a478 5
						iResult = FindItem(&find);

						if (iResult != -1)
							Update(iResult);
					}
@


1.157
log
@Reduced H-file dependency.
@
text
@d53 1
a53 1
	memset2(&m_bSortAscending, true, sizeof(m_bSortAscending));
d58 2
d167 16
a186 2
	if (!pClient)
		return;
d188 5
a192 3
	if (m_iClientFilter != 0)
		if (m_iClientFilter != GetClientFilterType(pClient))
			return;
d194 1
a194 1
	uint32		iNumItems = GetItemCount();
d196 2
a197 1
	iNumItems = InsertItem(LVIF_TEXT|LVIF_PARAM,iNumItems,LPSTR_TEXTCALLBACK,0,0,1,reinterpret_cast<LPARAM>(pClient));
d204 1
a204 1
	if (!pClient)
d215 4
a218 1
	LVFINDINFO		find;
d220 2
a221 2
	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;
d223 1
a223 1
	int		iResult = FindItem(&find);
d225 3
a227 2
	if (iResult != (-1))
		DeleteItem(iResult);
d232 1
a232 1
	if (pClient != NULL)
d489 3
a491 1
				int		iNumDirtySources = pvecDirtyClients->size();
d493 4
a496 3
				for (int i = 0; i < iNumDirtySources; i++)
				{
					LVFINDINFO		find;
d498 2
a499 2
					find.flags = LVFI_PARAM;
					find.lParam = (LPARAM)(*pvecDirtyClients)[i];
d501 1
a501 1
					int	iResult = FindItem(&find);
d503 3
a505 2
					if (iResult != -1)
						Update(iResult);
@


1.156
log
@Renamed IDS_QL_RATING into IDS_RATING.
@
text
@a18 1
//
d25 1
a25 1
#include ".\Details\ClientDetails.h"
d28 1
@


1.155
log
@UNICODE preparation (first shot)
@
text
@d137 1
a137 1
		IDS_QL_RATING,		// QLCOL_QLRATING
@


1.154
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d159 1
a159 1
			hdi.pszText = (LPSTR)strRes.GetString();
@


1.153
log
@renamed 3 variables
@
text
@d103 1
a103 1
	if (g_App.g_pPrefs->DoUseSort())
d105 1
a105 1
		SortInit(g_App.g_pPrefs->GetQueueSortCol());
d109 1
a109 1
		int		iSortCode = g_App.g_pPrefs->GetColumnSortItem(CPreferences::TABLE_QUEUE);
d111 1
a111 1
		iSortCode |= g_App.g_pPrefs->GetColumnSortAscending(CPreferences::TABLE_QUEUE) ? MLC_SORTASC : MLC_SORTDESC;
d355 1
a355 1
					if (pClient->GetUpPartCount() && g_App.g_pPrefs->IsUploadPartsEnabled())
d365 1
a365 1
							pClient->DrawUpStatusBar(dc, &r2, g_App.g_pPrefs->UseFlatBar());
d579 1
a579 1
	menuClient.SetDefaultItem((g_App.g_pPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
d667 2
a668 2
	g_App.g_pPrefs->SetColumnSortItem(CPreferences::TABLE_QUEUE, iSubItem);
	g_App.g_pPrefs->SetColumnSortAscending(CPreferences::TABLE_QUEUE, bSortOrder);
d832 1
a832 1
		if (g_App.g_pPrefs->GetDetailsOnClick())
@


1.152
log
@Improved LowID users handling in waiting queue to minimize unfare waiting time.
@
text
@d86 1
a86 1
	ilDummyImageList.Create(1, 17,g_eMuleApp.m_iDfltImageListColorFlags | ILC_MASK, 1, 1);
d103 1
a103 1
	if (g_eMuleApp.m_pGlobPrefs->DoUseSort())
d105 1
a105 1
		SortInit(g_eMuleApp.m_pGlobPrefs->GetQueueSortCol());
d109 1
a109 1
		int		iSortCode = g_eMuleApp.m_pGlobPrefs->GetColumnSortItem(CPreferences::TABLE_QUEUE);
d111 1
a111 1
		iSortCode |= g_eMuleApp.m_pGlobPrefs->GetColumnSortAscending(CPreferences::TABLE_QUEUE) ? MLC_SORTASC : MLC_SORTDESC;
d167 1
a167 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d183 1
a183 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d188 1
a188 1
	if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE)
d190 1
a190 1
		if (g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == pClient)
d192 1
a192 1
 			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d220 1
a220 1
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
d248 1
a248 1
	CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pClient->m_reqFileHash);
d283 1
a283 1
						g_eMuleApp.m_pdlgEmule->m_clientImgLists[iImgLstIdx].Draw(dc, pClient->GetClientIconIndex(), point, ILD_NORMAL);
d286 1
a286 1
						if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d290 1
a290 1
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryIndex(), point, ILD_NORMAL);
d297 1
a297 1
						if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d355 1
a355 1
					if (pClient->GetUpPartCount() && g_eMuleApp.m_pGlobPrefs->IsUploadPartsEnabled())
d365 1
a365 1
							pClient->DrawUpStatusBar(dc, &r2, g_eMuleApp.m_pGlobPrefs->UseFlatBar());
d543 1
a543 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE, pClient);
d579 1
a579 1
	menuClient.SetDefaultItem((g_eMuleApp.m_pGlobPrefs->GetDetailsOnClick()) ? MP_DETAIL : MP_MESSAGE);
d601 1
a601 1
				g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(pClient);
d604 1
a604 1
				g_eMuleApp.m_pFriendList->AddFriend(pClient);
d607 1
a607 1
				g_eMuleApp.m_pFriendList->RemoveFriend(pClient);
d627 1
a627 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateQueueFilter();
d634 1
a634 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateQueueFilter();
d641 1
a641 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateQueueFilter();
d648 1
a648 1
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateQueueFilter();
d667 2
a668 2
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_QUEUE, iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_QUEUE, bSortOrder);
d680 2
a681 2
	CKnownFile* pSharedFile1 = g_eMuleApp.m_pSharedFilesList->GetFileByID(pClient1->m_reqFileHash);
	CKnownFile* pSharedFile2 = g_eMuleApp.m_pSharedFilesList->GetFileByID(pClient2->m_reqFileHash);
d808 1
a808 1
	POSITION posSelClient = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.GetFirstSelectedItemPosition();
d814 2
a815 2
			int iSelClientListIndex = g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.GetNextSelectedItem(posSelClient);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlDownloadList.SetItemState(iSelClientListIndex, ~LVIS_SELECTED, LVIS_SELECTED);
d832 1
a832 1
		if (g_eMuleApp.m_pGlobPrefs->GetDetailsOnClick())
d839 1
a839 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(pClient);
d886 1
a886 1
	 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
d892 1
a892 1
	 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,pClient);
d913 1
a913 1
	if (g_eMuleApp.m_pdlgEmule->IsRunning()){
d952 1
a952 1
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
d954 1
a954 1
		pClient = g_eMuleApp.m_pUploadQueue->GetNext(pos);
@


1.151
log
@Faster remote client name handling.
@
text
@d380 1
a380 1
						strBuffer.Format(_T("%u"),pClient->GetScore(false));
@


1.150
log
@Unified and regrouped shortcuts.
@
text
@d301 2
a302 2
					strBuffer = pClient->GetUserName();
					dc->DrawText(strBuffer,strBuffer.GetLength(),&r2, iCalcFlag);
d691 1
a691 1
			iCompare = _tcsicmp(pClient1->GetUserName(), pClient2->GetUserName());
d928 2
a929 1
						if (!pClient->GetUserName().IsEmpty() && pDispInfo->item.cchTextMax > 0){
d931 1
a931 1
							pDispInfo->item.pszText[pDispInfo->item.cchTextMax-1] = _T('\0');
@


1.149
log
@Unified and slightly faster way to draw list cursor;
More space for data in upload pane lists (reduced column margins).
@
text
@d560 1
a560 1
	menuClient.AppendMenu(dwFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(IndexULDetails, SSP_TAB_PREFIX));
d570 2
a571 2
	menuClient.AppendMenu(dwFlags, dwRes, GetResString(dwResStrId) + GetStringFromShortcutCode(IndexULFriend, SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(IndexULMessage, SSP_TAB_PREFIX));
d573 1
a573 1
		MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(IndexULFiles, SSP_TAB_PREFIX) );
@


1.148
log
@Faster drawing of some list elements.
@
text
@d228 5
a232 4
	if (odc && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
		odc->SetBkColor((bCtrlFocused) ? m_crHighlight : m_crNoHighlight);
	else
		odc->SetBkColor(GetBkColor());
d235 1
a235 1
	CMemDC			dc(odc,&CRect(lpDrawItemStruct->rcItem));
d238 1
a238 1
	int				iWidth = 0;
d252 1
a252 1
	r.right = r.left - 8;
d254 1
a254 1
	iWidth = 12;
a309 1
				{
d315 1
a315 1
				}
a346 1
				{
a347 1
					{
a348 1
					}
d350 1
a350 3
					{
						strBuffer.Empty();
					}
d352 1
a352 1
				}
a371 1
				{
d374 1
a374 1
				}
a375 1
				{
d382 1
a382 1
				}
a383 1
				{
d389 1
a389 1
				}
a390 1
				{
d396 1
a396 1
				}
a397 1
				{
d400 1
a400 1
				}
a401 1
				{
d404 1
a404 1
				}
a405 1
				{
d408 1
a408 1
				}
a409 1
				{
d412 1
a412 1
				}
a413 1
				{
a415 1
				}
a439 1
		dc->FrameRect(&rOutline, &CBrush(GetBkColor()));
@


1.147
log
@Faster sorting by file name.
@
text
@d227 3
a229 7
	BOOL	bCtrlFocused = ((GetFocus() == this ) || (GetStyle() & LVS_SHOWSELALWAYS));
	if( odc && (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED )){
		if(bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	}
d455 1
a455 9
		rOutline.top--;
		rOutline.bottom++;

		CBrush gdiBrush(GetBkColor());
		CBrush *pOldBrush = dc->SelectObject(&gdiBrush);
		dc->FrameRect(&rOutline, &gdiBrush);
		dc->SelectObject(pOldBrush);
		rOutline.top++;
		rOutline.bottom--;
d458 1
a458 15

		if (bCtrlFocused)
		{
			CBrush fl_Brush(m_crFocusLine);
			dc->SelectObject(&fl_Brush);
			dc->FrameRect(&rOutline, &fl_Brush);
		}
		else
		{
			CBrush nfl_Brush(m_crNoFocusLine);
			dc->SelectObject(&nfl_Brush);
			dc->FrameRect(&rOutline, &nfl_Brush);
		}

		dc->SelectObject(pOldBrush);
@


1.146
log
@Removed GetScore unused parameter
@
text
@d757 2
a758 2
			if( (pSharedFile1 != NULL) && (pSharedFile2 != NULL))
				iCompare = _tcsicmp(pSharedFile1->GetFileName(),pSharedFile2->GetFileName());
d760 1
a760 1
				iCompare = ( pSharedFile1 == NULL ) ? ((pSharedFile2 == NULL) ? 0 : 1) : -1;
@


1.145
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d382 1
a382 1
					strBuffer.Format(_T("%u"),pClient->GetScore(false,pClient->IsDownloading(),true));
d804 1
a804 1
			iCompare = pClient1->GetScore(false,false,true) - pClient2->GetScore(false,false,true);
@


1.144
log
@Use of CPU optimised memset2 function
Code refactoring
@
text
@d86 1
a86 1
	ilDummyImageList.Create(1, 17,ILC_COLOR32 | ILC_MASK, 1, 1);
@


1.143
log
@Inform a remote client when 'See my share = No one' to save traffic (original).
@
text
@d53 1
a53 1
	memset(&m_bSortAscending, true, sizeof(m_bSortAscending));
d69 14
a82 14
		{ LVCFMT_LEFT, 150 },	//QLCOL_USERNAME
		{ LVCFMT_LEFT, 275 },	//QLCOL_FILENAME
		{ LVCFMT_LEFT, 110 },	//QLCOL_FILEPRIORITY
		{ LVCFMT_LEFT, 110 },	//QLCOL_PARTS
		{ LVCFMT_LEFT, 110 },	//QLCOL_PROGRESS
		{ LVCFMT_LEFT,  60 },	//QLCOL_QLRATING
		{ LVCFMT_LEFT,  60 },	//QLCOL_SCORE
		{ LVCFMT_LEFT,  60 },	//QLCOL_SFRATIO
		{ LVCFMT_LEFT,  60 },	//QLCOL_RFRATIO
		{ LVCFMT_LEFT,  60 },	//QLCOL_TIMESASKED
		{ LVCFMT_LEFT, 110 },	//QLCOL_LASTSEEN
		{ LVCFMT_LEFT, 110 },	//QLCOL_ENTEREDQUEUE
		{ LVCFMT_LEFT,  60 },	//QLCOL_BANNED
		{ LVCFMT_LEFT, 150 }	//QLCOL_COUNTRY
d132 14
a145 14
		IDS_QL_USERNAME,	//QLCOL_USERNAME
		IDS_FILE,			//QLCOL_FILENAME
		IDS_FILEPRIO,		//QLCOL_FILEPRIORITY
		IDS_UP_PARTS,		//QLCOL_PARTS
		IDS_DL_PROGRESS,	//QLCOL_PROGRESS
		IDS_QL_RATING,		//QLCOL_QLRATING
		IDS_SCORE,			//QLCOL_SCORE
		IDS_SFRATIO,		//QLCOL_SFRATIO
		IDS_RFRATIO,		//QLCOL_RFRATIO
		IDS_ASKED,			//QLCOL_TIMESASKED
		IDS_LASTSEEN,		//QLCOL_LASTSEEN
		IDS_ENTERQUEUE,		//QLCOL_ENTEREDQUEUE
		IDS_BANNED,			//QLCOL_BANNED
		IDS_COUNTRY			//QLCOL_COUNTRY
d277 1
a277 1
					// Select corresponding image list depending on client properties
d387 1
a387 1
				//note: actually the client, which is downloading from us should be not in WaitingQueue
d396 1
a396 1
					if (pKnownFile)
d404 1
a404 1
					if (pKnownFile)
d507 1
a507 1
				
d516 1
a516 1
						
d614 1
a614 1
	menuClient.AppendMenu( dwFlags | ((pClient && pClient->GetViewSharedFilesSupport()) ? MF_ENABLED : MF_GRAYED),
d732 1
d735 1
a735 1

d887 1
a887 1
void CQueueListCtrl::ShowSelectedUserDetails() 
d893 1
a893 1
	CPoint p = point; 
d895 1
a895 1
    ScreenToClient(&p); 
d897 1
a897 1
    int it = HitTest(p); 
d1047 1
a1047 1
	if (m_pvecDirtyClients != NULL 
@


1.142
log
@Probable solution for crashes reported by users crash dumps.
@
text
@d614 2
a615 1
	menuClient.AppendMenu(dwFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(IndexULFiles, SSP_TAB_PREFIX));
@


1.141
log
@Removed old unused code.
@
text
@d494 1
a494 1
	BOOL		bHandled = FALSE;
a526 1
			bHandled = true;
d529 3
d537 1
a537 3
	{
		bHandled = CMuleListCtrl::OnWndMsg(iMessage,wParam,lParam,pResult);
	}
@


1.140
log
@Corrected and improved sorting.
@
text
@a117 2
	m_dwSortTime = ::GetTickCount();

@


1.139
log
@rollback of old waiting queue
@
text
@d733 1
a733 4
			if (pClient1->GetUserName() && pClient2->GetUserName())
				iCompare = _tcsicmp(pClient1->GetUserName(),pClient2->GetUserName());
			else
				iCompare = (!pClient1->GetUserName()) ? ( (!pClient1->GetUserName())? 0:1 ) : -1;
d735 1
@


1.138
log
@prevent possible crash if file will not found
@
text
@d384 1
a384 1
					strBuffer.Format(_T("%u"),pClient->GetPosInWaitingQueue());
d393 1
a393 1
						strBuffer.Format(_T("%u"),pClient->GetWaitingScore());
d806 1
a806 10
			// 1) since rating values are permanetly updated for whole queue by every insert, remove & update operation
			//     the sorting by position in the queue will lead to unneeded call CMuleListCtrl::UpdateLocation()
			//     so we gonna sort by score, which is changed not so often, but gives same result
			// 2) use <> comparison to incease upper comparison limit to 4294967295 (0xFFFFFFFF) 
			if (pClient2->GetWaitingScore() > pClient1->GetWaitingScore())
				iCompare = 1;
			else if (pClient2->GetWaitingScore() < pClient1->GetWaitingScore())
				iCompare = -1;
			else
				iCompare = pClient1->GetPosInWaitingQueue() - pClient2->GetPosInWaitingQueue();
d809 1
a809 7
			// use <> comparison to incease upper comparison limit to 4294967295 (0xFFFFFFFF) 
			if (pClient1->GetWaitingScore() > pClient2->GetWaitingScore())
				iCompare = 1;
			else if (pClient1->GetWaitingScore() < pClient2->GetWaitingScore())
				iCompare = -1;
			else
				iCompare = 0;
d991 1
a991 1
	ClientList::iterator clientIt;
d995 1
a995 2
	
	for (clientIt = g_eMuleApp.m_pUploadQueue->m_waitingList.begin(); clientIt != g_eMuleApp.m_pUploadQueue->m_waitingList.end(); clientIt++)
d997 1
a997 2
		CUpDownClient* pClient = *clientIt;
		
@


1.137
log
@1) varios correction for SSWQ & Co
2) the file ratios moved to file class
3) corrected measurement of time on remote queue
@
text
@d398 4
a401 1
					strBuffer.Format(_T("%.2f"), pKnownFile->GetSizeRatio());
d406 4
a409 1
					strBuffer.Format(_T("%.2f"), pKnownFile->GetPopularityRatio());
d827 4
a830 1
			iCompare = static_cast<int>(100.0*(pSharedFile1->GetSizeRatio() - pSharedFile2->GetSizeRatio()) );
d833 4
a836 1
			iCompare = static_cast<int>(100.0 *(pSharedFile1->GetPopularityRatio() - pSharedFile2->GetPopularityRatio()) );
@


1.136
log
@SSWQ
@
text
@d391 1
a391 1
						strBuffer = CString(_T("-"));
d398 1
a398 1
					strBuffer.Format(_T("%.2f"),pClient->GetSmallFilePushRatio());
d403 1
a403 1
					strBuffer.Format(_T("%.2f"),pClient->GetRareFilePushRatio());
d800 4
a803 3
			// since rating values are permanetly updated for whole queue by every insert, remove & update operation
			// the sorting by position in the queue will lead to unneeded call CMuleListCtrl::UpdateLocation()
			// so we gonna sort by score, which is changed not so often, but gives same result
d812 1
a812 1
			// iCompare = pClient1->GetWaitingScore() - pClient2->GetWaitingScore();
d821 1
a821 1
			iCompare = static_cast<int>(pClient1->GetSmallFilePushRatio()*100 - pClient2->GetSmallFilePushRatio()*100);
d824 1
a824 1
			iCompare = static_cast<int>(pClient1->GetRareFilePushRatio()*100 - pClient2->GetRareFilePushRatio()*100);
@


1.135
log
@Faster shortcuts handling.
@
text
@a124 14
//	eklmn: update all clients, to prevent redrawing after every update, switch it off
	CUpDownClient	   *pClient;

	SetRedraw(FALSE);
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
	{
		pClient = g_eMuleApp.m_pUploadQueue->GetNext(pos);
		if (pClient != NULL)
		{
			UpdateClient(pClient);
		}
	}
	SetRedraw(TRUE);

d167 1
a167 1
void CQueueListCtrl::AddClient(CUpDownClient *pClient, bool reset)
a180 6

	if (reset == true)
	{
		pClient->SetWaitStartTime();
		pClient->SetAskedCount(1);
	}
d203 1
a203 1
	sint32		result = FindItem(&find);
d205 2
a206 2
	if (result != (-1))
		DeleteItem(result);
d213 4
a216 3
		AddDirtyClient(pClient);

		PostRefreshMessage();
d328 1
a328 1
						switch (pKnownFile->GetPriority())
d384 1
a384 1
					strBuffer.Format(_T("%u"),pClient->GetScore(false,pClient->IsDownloading(),true));
d389 5
a393 1
					strBuffer.Format(_T("%u"),pClient->GetScore(false));
d496 1
a496 1
		case WM_UL_REFRESH:
d513 1
a513 1
					sint16	result = FindItem(&find);
d515 2
a516 2
					if (result != -1)
						Update(result);
a693 13
	CUpDownClient	   *pClient;

	SetRedraw(FALSE);
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
	{
		pClient = g_eMuleApp.m_pUploadQueue->GetNext(pos);
		if (pClient != NULL)
		{
			UpdateClient(pClient);
		}
	}
	SetRedraw(TRUE);

d766 1
a766 1
				if (pSharedFile1->GetPriority() == PR_VERYLOW)
d768 1
a768 1
				else if (pSharedFile2->GetPriority() == PR_VERYLOW)
d771 1
a771 1
					iCompare = pSharedFile1->GetPriority() - pSharedFile2->GetPriority();
d800 9
a808 1
			iCompare = pClient1->GetScore(false,false,true) - pClient2->GetScore(false,false,true);
d811 7
a817 1
			iCompare =  pClient1->GetScore(false) - pClient2->GetScore(false);
d993 1
a993 1
	CUpDownClient	   *pClient;
d997 2
a998 1
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
d1000 2
a1001 1
		pClient = g_eMuleApp.m_pUploadQueue->GetNext(pos);
d1004 1
a1004 1
			AddClient(pClient, false);
d1048 1
a1048 3
//	PostRefreshMessage() puts a message into the list control's message queue telling it it needs to
//	refresh dirty sources and then immediately returns.
void CQueueListCtrl::PostRefreshMessage()
d1050 1
a1050 3
	if (::IsWindow(GetSafeHwnd()) && g_eMuleApp.m_app_state != CEmuleApp::APP_STATE_SHUTINGDOWN)
	{
		MSG		msg;
d1052 3
a1054 13
	//	If there's no refresh message already in the message queue... (don't want to flood it)
		if (!::PeekMessage(&msg,m_hWnd,WM_UL_REFRESH,WM_UL_REFRESH,false))
		{
		//	... then post one with the current time so we know how long the request has been pending when we get it.
			PostMessage(WM_UL_REFRESH,0,static_cast<LPARAM>(::GetCurrentTime()));
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CQueueListCtrl::AddDirtyClient(CUpDownClient* pClientItem)
{
//	If 'pSourceItem' is not already in the dirty source list...
	if (::find(m_pvecDirtyClients->begin(), m_pvecDirtyClients->end(), pClientItem) == m_pvecDirtyClients->end())
d1057 1
d1059 2
@


1.134
log
@Some changes and a string removal (UDP).
@
text
@d613 1
a613 1
	menuClient.AppendMenu(dwFlags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails),SSP_TAB_PREFIX));
d623 3
a625 3
	menuClient.AppendMenu(dwFlags, dwRes, GetResString(dwResStrId) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend), SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwFlags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage),SSP_TAB_PREFIX));
	menuClient.AppendMenu(dwFlags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles),SSP_TAB_PREFIX));
d1035 1
a1035 1
BOOL CQueueListCtrl::PreTranslateMessage(MSG* pMsg)
d1037 1
a1037 1
	if (pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN)
a1039 1
		short	 nCode		  = GetCodeFromPressedKeys(pMsg);
d1044 2
a1045 1
			CUpDownClient* pSource = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));
@


1.133
log
@Faster client icon drawing in the lists;
Unified processing of client icon images; Minor optimization.
@
text
@d258 1
a258 1
	CUpDownClient	*pClient = (CUpDownClient*)lpDrawItemStruct->itemData;
d261 1
a261 1
	COLORREF		crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
a325 3
					// EC - Use Dark Green for SUI Clients
					//if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) == IS_IDENTIFIED)
					//	crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));
a330 2
					//if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) == IS_IDENTIFIED)
					//	dc->SetTextColor(crOldTxtColor);
d385 1
a385 1
					if (pClient->GetUpPartCount() && g_eMuleApp.m_pGlobPrefs->IsUploadPartsEnabled())		//Cax2 re-enabled toggle for progress bars
d499 2
a500 2
	if (crOldTxtColor)
		dc.SetTextColor(crOldTxtColor);
@


1.132
log
@Unified list column creature; Improved string processing;
Set list column labels only in one place to avoid future incorrections.
@
text
@d26 1
a26 1
#include ".\\Details\\ClientDetails.h"
a61 1
	m_imageList.DeleteImageList();
a66 15
	static const uint16 s_auIconResID[] =
	{
		IDI_NORMAL,			// 0
		IDI_COMPROT,		// 1
		IDI_MLDONKEY,		// 2
		IDI_EDONKEYHYBRID,	// 3
		IDI_CREDIT_ONLY,	// 4
		IDI_FRIEND_ONLY,	// 5
		IDI_BANNED_ONLY,	// 6
		IDI_UNKNOWN,		// 7
		IDI_AMULE,			// 8
		IDI_LMULE,			// 9
		IDI_SHAREAZA,		// 10
		IDI_SECUREHASH		// 11
	};
a99 5
	m_imageList.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	m_imageList.SetBkColor(CLR_NONE);
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ELEMENT_COUNT(s_auIconResID));
	SetImageList(&m_imageList,LVSIL_SMALL);

d296 1
d298 1
a298 33
					//	Display client icon
						switch (pClient->GetClientSoft())
						{
							case SO_AMULE:
								m_imageList.Draw(dc, UL_ICON_AMULE, point, ILD_TRANSPARENT);
								break;
							case SO_LMULE:
								m_imageList.Draw(dc, UL_ICON_LMULE, point, ILD_TRANSPARENT);
								break;
							case SO_SHAREAZA:
								m_imageList.Draw(dc, UL_ICON_SHAREAZA, point, ILD_TRANSPARENT);
								break;
							case SO_EDONKEYHYBRID:
								m_imageList.Draw(dc, UL_ICON_EDONKEYHYBRID, point, ILD_TRANSPARENT);
								break;
							case SO_MLDONKEY:
								m_imageList.Draw(dc, UL_ICON_MLDONKEY, point, ILD_TRANSPARENT);
								break;
							case SO_EMULE:
							case SO_OLDEMULE:
								if (pClient->m_pCredits->GetCurrentIdentState(pClient->GetIP()) != IS_IDENTIFIED)
									m_imageList.Draw(dc, UL_ICON_SECUREHASH, point, ILD_TRANSPARENT);
								else
									m_imageList.Draw(dc, UL_ICON_COMPROT, point, ILD_TRANSPARENT);
								break;
							case SO_EDONKEY:
								m_imageList.Draw(dc, UL_ICON_NORMAL, point, ILD_TRANSPARENT);
								break;
							default:
								m_imageList.Draw(dc, UL_ICON_UNKNOWN, point, ILD_TRANSPARENT);
								break;
						}
						//	Display any Extra Overlay icons
d300 1
a300 1
							m_imageList.Draw(dc, 6, point, ILD_TRANSPARENT);
d302 1
a302 1
							m_imageList.Draw(dc, 5, point, ILD_TRANSPARENT);
d304 1
a304 1
							m_imageList.Draw(dc, 4, point, ILD_TRANSPARENT);
d306 4
d315 1
a315 1
							r2.left += 42;
a316 2
						else
							r2.left += 20;
d320 1
d322 1
a322 3
							iWidth += 42;
						else
							iWidth += 20;
a1105 1

@


1.131
log
@1) corrected default toolbar definition
2) improved processing of the username by anti-leecher feature
3) unified async GUI updade of Upload, Queue & Client lists
@
text
@d83 17
d113 2
a114 14
	InsertColumn(QLCOL_USERNAME,GetResString(IDS_QL_USERNAME),LVCFMT_LEFT,150,0);
	InsertColumn(QLCOL_FILENAME,GetResString(IDS_FILE),LVCFMT_LEFT,275,1);
	InsertColumn(QLCOL_FILEPRIORITY,GetResString(IDS_FILEPRIO),LVCFMT_LEFT,110,2);
	InsertColumn(QLCOL_PARTS,GetResString(IDS_UP_PARTS),LVCFMT_LEFT,110,3);
	InsertColumn(QLCOL_PROGRESS,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT,110,4);
	InsertColumn(QLCOL_QLRATING,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60,5);
	InsertColumn(QLCOL_SCORE,GetResString(IDS_SCORE),LVCFMT_LEFT,60,6);
	InsertColumn(QLCOL_SFRATIO,GetResString(IDS_SFRATIO),LVCFMT_LEFT,60,7);
	InsertColumn(QLCOL_RFRATIO,GetResString(IDS_RFRATIO),LVCFMT_LEFT,60,8);
	InsertColumn(QLCOL_TIMESASKED,GetResString(IDS_ASKED),LVCFMT_LEFT,60,9);
	InsertColumn(QLCOL_LASTSEEN,GetResString(IDS_LASTSEEN),LVCFMT_LEFT,110,10);
	InsertColumn(QLCOL_ENTEREDQUEUE,GetResString(IDS_ENTERQUEUE),LVCFMT_LEFT,110,11);
	InsertColumn(QLCOL_BANNED,GetResString(IDS_BANNED),LVCFMT_LEFT,60,12);
	InsertColumn(QLCOL_COUNTRY,GetResString(IDS_COUNTRY),LVCFMT_LEFT,150,13);
d421 1
a421 1
						strBuffer = GetResString(dwResStrId);
@


1.130
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d55 1
a55 7
	// Barry - Refresh the queue every 10 secs
	m_hTimer = ::SetTimer(NULL,				// Window to associate with
						NULL,				// ID of timer (ignored if window = null)
						30000,				// Time out duration
						(TIMERPROC)CQueueListCtrl::QueueUpdateTimer);	// Proc to run
	if (!m_hTimer)
		AddDebugLogLine(RGB_LOG_ERROR + _T("%s: Fatal Error, failed to create Timer"), __FUNCTION__);
d57 1
a57 1
	SetGeneralPurposeFind(true);
d63 1
a63 9
	// Barry - Kill the timer that was created
	try
	{
		if (m_hTimer)
			::KillTimer(NULL, m_hTimer);
	}
	catch (...)
	{
	}
d247 3
a249 5
//	Don't refresh during app shutdown [TwoBottle Mod]
	if (!g_eMuleApp.m_pdlgEmule->IsRunning())
		return;
	if (!pClient)
		return;
d251 2
a252 9
	LVFINDINFO		find;

	find.flags = LVFI_PARAM;
	find.lParam = (LPARAM)pClient;

	sint16		result = FindItem(&find);

	if (result != -1)
		Update(result);
d562 1
a562 1
		case WM_QL_REFRESHCLIENT:
d564 22
a585 1
			CUpDownClient	*pClient = reinterpret_cast<CUpDownClient*>(lParam);
d587 2
a588 1
			UpdateClient(pClient);
a679 3
	menuClient.AppendMenu( MF_STRING |
		((g_eMuleApp.m_pGlobPrefs->GetUpdateQueueList()) ? MF_CHECKED : MF_UNCHECKED),
		MP_UPDATEQQUEUE, GetResString(IDS_UPDATEQUEUE) );
a725 5
		case MP_UPDATEQQUEUE:
		{
			g_eMuleApp.m_pGlobPrefs->SetUpdateQueueList(!g_eMuleApp.m_pGlobPrefs->GetUpdateQueueList());
			break;
		}
a914 25
// Barry - Refresh the queue every 10 secs
void CALLBACK CQueueListCtrl::QueueUpdateTimer(HWND hwnd, UINT uiMsg, UINT idEvent, DWORD dwTime)
{
	// Don't do anything if the app is shutting down - can cause unhandled exceptions
	if ((g_eMuleApp.m_pUploadQueue == NULL) || !g_eMuleApp.m_pdlgEmule->IsRunning()
		|| !g_eMuleApp.m_pGlobPrefs->GetUpdateQueueList()
		|| g_eMuleApp.m_pdlgEmule->m_pdlgActive != &g_eMuleApp.m_pdlgEmule->m_wndTransfer)
	{
		return;
	}

	CUpDownClient	   *pClient;

	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.SetRedraw(FALSE);
	for (POSITION pos = g_eMuleApp.m_pUploadQueue->GetHeadPosition(); pos != NULL; )
	{
		pClient = g_eMuleApp.m_pUploadQueue->GetNext(pos);
		if (pClient != NULL)
		{
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(pClient);
		}
	}
	g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.SetRedraw(TRUE);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
d1111 42
@


1.129
log
@Faster list header localizations.
@
text
@d61 1
a61 1
		AddDebugLogLine(false, RGB_LOG_ERROR + _T("%s: Fatal Error, failed to create Timer"), __FUNCTION__);
@


1.128
log
@Fixed list sorting direction while switching <thanks xrmb>.
@
text
@d176 18
d196 3
a198 2
		CHeaderCtrl		*pHeaderCtrl = GetHeaderCtrl();
		HDITEM			hdi;
d202 1
a202 1
		if (pHeaderCtrl->GetItemCount() != 0)
d204 3
a206 71
			CString		strRes;

			strRes = GetResString(IDS_QL_USERNAME);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_USERNAME, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_FILE);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_FILENAME, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_FILEPRIO);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_FILEPRIORITY, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_UP_PARTS);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_PARTS, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_DL_PROGRESS);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_PROGRESS, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_QL_RATING);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_QLRATING, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_SCORE);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_SCORE, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_SFRATIO);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_SFRATIO, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_RFRATIO);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_RFRATIO, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_ASKED);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_TIMESASKED, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_LASTSEEN);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_LASTSEEN, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_ENTERQUEUE);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_ENTEREDQUEUE, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_BANNED);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_BANNED, &hdi);
			strRes.ReleaseBuffer();

			strRes = GetResString(IDS_COUNTRY);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_COUNTRY, &hdi);
			strRes.ReleaseBuffer();
@


1.127
log
@Add aMule client support;
CDonkey client support is eliminated.
@
text
@d53 1
a53 1
	memzero(&m_bSortAscending, sizeof(m_bSortAscending)); // i_a
d833 5
a837 1
	bool		bSortOrder;
a838 3
//	If it's a second click on the same column then reverse the sort order,
//	otherwise sort the new column in ascending order.
	m_bSortAscending[iSubItem] = bSortOrder = !m_bSortAscending[iSubItem];
@


1.126
log
@Final DebugLog formating and changes
@
text
@d92 1
a92 1
		IDI_CDONKEY,		// 8
d388 2
a389 2
							case SO_CDONKEY:
								m_imageList.Draw(dc, UL_ICON_CDONKEY, point, ILD_TRANSPARENT);
@


1.125
log
@minor changes, fixes and improvements
@
text
@d61 1
a61 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.124
log
@Show default context menu item in client lists (thanks xrmb for the idea).
@
text
@d976 4
a979 1
	if ((g_eMuleApp.m_pUploadQueue == NULL) || !g_eMuleApp.m_pdlgEmule->IsRunning() || !g_eMuleApp.m_pGlobPrefs->GetUpdateQueueList())
d981 1
@


1.123
log
@Totally reworked country information feature to minimaze memory usage.
@
text
@d735 1
@


1.122
log
@added tooltips to the Server list
@
text
@d429 1
a429 1
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->Draw(dc, pClient->GetCountryFlagIndex(), point, ILD_NORMAL);
@


1.121
log
@Find in lists
@
text
@d561 1
a561 1
					strBuffer = GetResString((pClient->IsBanned()) ? IDS_YES : IDS_NO);
@


1.120
log
@Middle mouse button click opens details of selected client or file
@
text
@d62 2
@


1.119
log
@Improve image list filling.
@
text
@d1031 27
@


1.118
log
@Deleted icon top & bottom transparent margins to save memory & speed up drawing;
Better drawing method.
@
text
@d80 15
d103 1
a103 4
	for (int i = 0; i < QLCOL_NUMCOLUMNS; i++)
	{
		m_iColumnMaxWidths[i] = 0;
	}
d125 1
a125 13
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));			// 0
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));			// 1
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));			// 2
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  	// 3
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));      // 4
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      // 5
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      // 6
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  		// 7
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  		// 8
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  			// 9
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  		// 10
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  		// 11
	LoadImgLstIcon(NULL,0,0);	// delete temp-icon
@


1.117
log
@upload progress bars fit their file's size; improved drawing of upload progress bar
@
text
@d426 2
a427 1
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
@


1.116
log
@minor changes
@
text
@d515 1
a515 1
							pClient->DrawUpStatusBar(dc, &r2, false, g_eMuleApp.m_pGlobPrefs->UseFlatBar());
@


1.115
log
@added tooltips in On Queue & Known Clients lists
@
text
@a421 1
						r2.left += 20;
d427 1
a427 1
							r2.left += 22;
d429 2
@


1.114
log
@increased icon/username spacing to 2 pixels + minor improvement
@
text
@a422 1
						point.x += 20;
d426 1
@


1.113
log
@no longer loading mid size names + some small changes
@
text
@d423 1
d427 2
a428 4
							POINT		point2 = {r2.left, r2.top + 1};

							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point2, CSize(18,16), CPoint(0,0), ILD_NORMAL);
							r2.left += 20;
d434 1
a434 1
							iWidth += 40;
d1085 1
a1085 1
						if (pClient->GetUserName() != "" && pDispInfo->item.cchTextMax > 0){
@


1.112
log
@reduced the space between flag and user name + minor fix in client details
@
text
@d563 1
a563 1
					strBuffer = pClient->GetCountryName(true);
@


1.111
log
@moved the country icon back near the client type icon
@
text
@d377 2
d381 1
a381 1
						POINT		point = {r.left, r.top+1};
d415 1
a415 2

					//	Display any Extra Overlay icons
d422 1
a422 2

						r.left += 20;
d426 1
a426 1
							POINT		point2 = {r.left, r.top + 1};
d429 1
a429 1
							r.left += 25;
d435 1
a435 1
							iWidth += 45;
d444 1
a444 2

					dc->DrawText(strBuffer,strBuffer.GetLength(),&r, iCalcFlag);
d447 1
a447 1
						iWidth += (r.right - r.left + 1);
a450 5

					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
						r.left -= 45;
					else
						r.left -= 20;
@


1.110
log
@minor changes
@
text
@d423 8
d433 6
a438 1
						iWidth += 20;
d453 4
a456 1
					r.left -= 20;
d569 1
a569 17
					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
					{
						if (!bMeasuring)
						{

							POINT point = {r.left,r.top + 1};
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
							strBuffer = pClient->GetCountryName(true);
							r.left += 25;
							dc->DrawText(strBuffer,strBuffer.GetLength(),&r, iCalcFlag);
							r.left -= 25;
						}
						else
							iWidth += 25;
					}
					else
						iWidth += r.right - r.left + 1;
d573 1
a573 1
			if (iColumn != QLCOL_PROGRESS && iColumn != QLCOL_USERNAME && iColumn != QLCOL_COUNTRY)
@


1.109
log
@minor changes
@
text
@d422 1
a422 1
						r.left +=20;
d569 1
a569 1
						iWidth += r.right-r.left+1;
d575 1
a575 3
				RECT		r2 = r;

				dc->DrawText(strBuffer,strBuffer.GetLength(),&r2,iCalcFlag);
d577 1
a577 1
					iWidth += r2.right - r2.left + 1;
@


1.108
log
@Please, DO NOT alter column order. This messes with users column customization and don't bring a standard as people likings are different.
@
text
@d97 13
a109 13
	InsertColumn(QLCOL_FILENAME,GetResString(IDS_FILE),LVCFMT_LEFT,275,2);
	InsertColumn(QLCOL_FILEPRIORITY,GetResString(IDS_FILEPRIO),LVCFMT_LEFT,110,3);
	InsertColumn(QLCOL_PARTS,GetResString(IDS_UP_PARTS),LVCFMT_LEFT,110,4);
	InsertColumn(QLCOL_PROGRESS,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT,110,5);
	InsertColumn(QLCOL_QLRATING,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60,6);
	InsertColumn(QLCOL_SCORE,GetResString(IDS_SCORE),LVCFMT_LEFT,60,7);
	InsertColumn(QLCOL_SFRATIO,GetResString(IDS_SFRATIO),LVCFMT_LEFT,60,8);
	InsertColumn(QLCOL_RFRATIO,GetResString(IDS_RFRATIO),LVCFMT_LEFT,60,9);
	InsertColumn(QLCOL_TIMESASKED,GetResString(IDS_ASKED),LVCFMT_LEFT,60,10);
	InsertColumn(QLCOL_LASTSEEN,GetResString(IDS_LASTSEEN),LVCFMT_LEFT,110,11);
	InsertColumn(QLCOL_ENTEREDQUEUE,GetResString(IDS_ENTERQUEUE),LVCFMT_LEFT,110,12);
	InsertColumn(QLCOL_BANNED,GetResString(IDS_BANNED),LVCFMT_LEFT,60,13);
	InsertColumn(QLCOL_COUNTRY,GetResString(IDS_COUNTRY),LVCFMT_LEFT,150,1);
@


1.107
log
@Added "Country" column in Uploads/On Queue/Known Clients lists
@
text
@a96 1
	InsertColumn(QLCOL_COUNTRY,GetResString(IDS_COUNTRY),LVCFMT_LEFT,150,1);
d109 1
a189 5
			strRes = GetResString(IDS_COUNTRY);
			hdi.pszText = strRes.GetBuffer();
			pHeaderCtrl->SetItem(QLCOL_COUNTRY, &hdi);
			strRes.ReleaseBuffer();

d249 5
a442 21
				case QLCOL_COUNTRY:
				{
					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
					{
						if (!bMeasuring)
						{

							POINT point = {r.left,r.top + 1};
							g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point, CSize(18,16), CPoint(0,0), ILD_NORMAL);
							strBuffer = pClient->GetCountryName(true);
							r.left += 25;
							dc->DrawText(strBuffer,strBuffer.GetLength(),&r, iCalcFlag);
							r.left -= 25;
						}
						else
							iWidth += 25;
					}
					else
						iWidth += r.right-r.left+1;
					break;
				}
d549 22
@


1.106
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d97 13
a109 12
	InsertColumn(QLCOL_FILENAME,GetResString(IDS_FILE),LVCFMT_LEFT,275,1);
	InsertColumn(QLCOL_FILEPRIORITY,GetResString(IDS_FILEPRIO),LVCFMT_LEFT,110,2);
	InsertColumn(QLCOL_PARTS,GetResString(IDS_UP_PARTS),LVCFMT_LEFT,110,3);
	InsertColumn(QLCOL_PROGRESS,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT,110,4);
	InsertColumn(QLCOL_QLRATING,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60,5);
	InsertColumn(QLCOL_SCORE,GetResString(IDS_SCORE),LVCFMT_LEFT,60,6);
	InsertColumn(QLCOL_SFRATIO,GetResString(IDS_SFRATIO),LVCFMT_LEFT,60,7);
	InsertColumn(QLCOL_RFRATIO,GetResString(IDS_RFRATIO),LVCFMT_LEFT,60,8);
	InsertColumn(QLCOL_TIMESASKED,GetResString(IDS_ASKED),LVCFMT_LEFT,60,9);
	InsertColumn(QLCOL_LASTSEEN,GetResString(IDS_LASTSEEN),LVCFMT_LEFT,110,10);
	InsertColumn(QLCOL_ENTEREDQUEUE,GetResString(IDS_ENTERQUEUE),LVCFMT_LEFT,110,11);
	InsertColumn(QLCOL_BANNED,GetResString(IDS_BANNED),LVCFMT_LEFT,60,12);
d190 5
a431 13
					SIZE TextSize;

					if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
					{
						POINT point2 = {r.left,r.top + 1};
						g_eMuleApp.m_pIP2Country->GetFlagImageList()->DrawIndirect(dc, pClient->GetCountryFlagIndex(), point2, CSize(18,16), CPoint(0,0), ILD_NORMAL);
						r.left += 20;
						GetTextExtentPoint32(dc, _T("N/A  "), 5, &TextSize);
						CString strBuffer2 = pClient->GetCountryName();
						strBuffer2 += _T("  ");
						dc->DrawText(strBuffer2,strBuffer2.GetLength(),&r, iCalcFlag);
						r.left += TextSize.cx;
					}
d440 5
d446 14
a459 1
						r.left -= (40 + TextSize.cx);
d461 1
a461 1
						r.left -= 20;
d572 1
a572 1
			if (iColumn != QLCOL_PROGRESS && iColumn != QLCOL_USERNAME)
d871 20
@


1.105
log
@Minor optimization.
@
text
@d28 1
d426 1
a426 1
					RECT	r2 = r;
d428 12
a439 1
					dc->DrawText(strBuffer,strBuffer.GetLength(),&r2,iCalcFlag);
d442 1
a442 1
						iWidth += (r2.right - r2.left + 1);
d447 4
a450 1
					r.left -=20;
@


1.104
log
@xrmb fix for unused pixel in Upload/On Queue progress bar; xrmb different shades of yellow in progress bar for current transfer position and remaining
@
text
@d494 7
a500 9
							r.bottom--;
							r.top++;
							r.right+=6;
							r.left-=3;
							pClient->DrawUpStatusBar(dc, &r, false, g_eMuleApp.m_pGlobPrefs->UseFlatBar());
							r.right-=6;
							r.left+=3;
							r.bottom++;
							r.top--;
@


1.103
log
@Fixed initial Queue list sort mode when sort settings aren't in use.
@
text
@d496 5
a500 1
							pClient->DrawUpStatusBar(dc,&r,false,g_eMuleApp.m_pGlobPrefs->UseFlatBar());
a503 1

@


1.102
log
@Improved string processing; slightly faster output mode.
@
text
@d126 1
a126 1
	Localize(); // i_a
d130 3
a132 1
		SortInit(g_eMuleApp.m_pGlobPrefs->GetQueueSortCol()); //sortdlg Cax2
d134 6
a139 1
		SortInit(105);	//Cax2 - changed 16/01/03
@


1.101
log
@fix a bug introduced by me in my latest changes (1.98)
@
text
@d336 1
a336 1
	UINT			iCalcFlag = bMeasuring ? (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_CALCRECT) : (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
d430 1
a430 1
	    		}
d436 1
a436 1
						strBuffer = "?";
d443 2
d448 1
a448 1
								strBuffer = GetResString(IDS_PRIORELEASE);
d451 1
a451 1
								strBuffer = GetResString(IDS_PRIOHIGH);
d454 1
a454 1
								strBuffer = GetResString(IDS_PRIOLOW);
d457 1
a457 1
								strBuffer = GetResString(IDS_PRIOVERYLOW);
d460 2
a461 2
								strBuffer = GetResString(IDS_PRIONORMAL);
							break;
d463 1
d466 1
a466 1
						strBuffer = "?";
d473 2
a474 2
						strBuffer.Format(_T("%d/%d"), pClient->GetAvailUpPartCount(), pClient->GetUpPartCount());
		            }
d477 3
a479 3
						strBuffer.Format(_T(""));
		            }
		            break;
a484 2
						r.bottom--;
						r.top++;
d486 3
d490 3
a492 2
						r.bottom++;
						r.top--;
a510 1

d520 1
a520 1
					strBuffer.Format(_T("%i"),pClient->GetAskedCount());
d535 1
a535 5
					if (pClient->IsBanned())
						strBuffer = GetResString(IDS_YES);
					else
						strBuffer = GetResString(IDS_NO);
					break;
d543 1
a543 1
				if (bMeasuring && strBuffer.GetLength() != 0)
@


1.100
log
@replaced TrackPopupMenu over TrackPopupMenuEx
@
text
@d1067 1
a1067 1
			UpdateClient(pClient);
@


1.99
log
@list processing optimization, reduce cpu load when updating or sorting the Waiting Queue
@
text
@d705 1
a705 1
	menuClient.TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y, this);
@


1.98
log
@Improved context menu creation;
SetMenu shouldn't be called for popup menu (removed).
@
text
@d81 1
a81 1
	ilDummyImageList.Create(1, 17,ILC_COLOR32 | ILC_MASK, 1, 1); 
d145 2
d148 1
a148 3
	CUpDownClient* pClient = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);

	while (pClient)
d150 5
a154 2
		UpdateClient(pClient);
		pClient = g_eMuleApp.m_pUploadQueue->GetNextClient(pClient);
d163 1
a163 1
void CQueueListCtrl::Localize() 
d172 1
a172 1
		if (pHeaderCtrl->GetItemCount() != 0) 
d250 1
a250 1
	
d259 1
a259 1
	if (reset == true) 
d272 1
a272 1
	
d280 1
a280 1
	
d366 1
a366 1
		
d416 1
a416 1
					//	crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));								
d426 1
a426 1
					//	dc->SetTextColor(crOldTxtColor);				
d448 1
a448 1
							case PR_HIGH: 
d450 2
a451 2
								break; 
							case PR_LOW: 
d453 1
a453 1
								break; 
d457 1
a457 1
							default: 
d459 1
a459 1
							break; 
d651 1
a651 1
{	
d664 1
a664 1
		
d706 1
a706 1
	
d783 1
a783 1
} 
d787 1
a787 1
	CUpDownClient* pUpdateClient = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);
d790 1
a790 1
	while(pUpdateClient)
d792 5
a796 2
		UpdateClient(pUpdateClient);
		pUpdateClient = g_eMuleApp.m_pUploadQueue->GetNextClient(pUpdateClient);
d821 1
a821 1
	
d831 1
a831 1
		case QLCOL_USERNAME: 
d837 1
a837 1
		case QLCOL_FILENAME: 
d848 1
a848 1
		case QLCOL_FILEPRIORITY: 
d851 1
a851 1
				if (pSharedFile1->GetPriority() == PR_VERYLOW) 
d887 1
a887 1
		case QLCOL_SCORE: 
d896 1
a896 1
		case QLCOL_TIMESASKED: 
d899 1
a899 1
		case QLCOL_LASTSEEN: 
d902 1
a902 1
		case QLCOL_ENTEREDQUEUE: 
d905 1
a905 1
		case QLCOL_BANNED: 
d927 5
a931 3
	
	CUpDownClient* update = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);
	while( update )
d933 5
a937 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlQueueList.UpdateClient(update);
		update = g_eMuleApp.m_pUploadQueue->GetNextClient(update);
d939 1
d955 1
a955 1
		
d969 1
a969 1
		
d974 2
a975 2
		} 
		else 
d994 1
a994 1
		
d1002 1
a1002 1
			
d1058 1
a1058 1
	SetRedraw(false);
d1060 1
d1062 1
a1062 3
	CUpDownClient* update = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);

	while(update)
d1064 5
a1068 2
		AddClient(update, false);
		update = g_eMuleApp.m_pUploadQueue->GetNextClient(update);
d1070 1
a1070 2

	SetRedraw(true);
d1097 1
a1097 1
			
@


1.97
log
@minor memory copy improvements; minor optimization
@
text
@a648 5
	UINT flags=MF_STRING|MF_GRAYED;
	CTitleMenu*	pMenuClient = NULL;
	CMenu*		pMenuFilter = NULL;
	CUpDownClient* pClient = NULL;

d651 5
a655 1
	POSITION posSelClient = GetFirstSelectedItemPosition();
d659 1
a665 1
		flags=MF_STRING;
d668 33
a700 31
	pMenuFilter = new CMenu();
	//DonGato: show filtered list of clients
	pMenuFilter->CreateMenu();
	pMenuFilter->AppendMenu(MF_STRING,MP_FILTER_NONE, GetResString(IDS_CAT_REINVADD));
//	pMenuFilter->AppendMenu(MF_STRING,MP_FILTER_BANNED, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_BANNED));
	pMenuFilter->AppendMenu(MF_STRING,MP_FILTER_FRIEND, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_FRIEND));
	pMenuFilter->AppendMenu(MF_STRING,MP_FILTER_CREDIT, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_CREDIT));

	pMenuClient = new CTitleMenu();
	pMenuClient->CreatePopupMenu();
	pMenuClient->AddMenuTitle(GetResString(IDS_CLIENTS));
	pMenuClient->AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails),SSP_TAB_PREFIX));
	if(pClient && pClient->IsFriend())
		pMenuClient->AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend),SSP_TAB_PREFIX));
	else
		pMenuClient->AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend),SSP_TAB_PREFIX));
	pMenuClient->AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage),SSP_TAB_PREFIX));
	pMenuClient->AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles),SSP_TAB_PREFIX));
	pMenuClient->AppendMenu(flags,MP_UNBAN, GetResString(IDS_UNBAN));
	if(pClient)
		pMenuClient->EnableMenuItem(MP_UNBAN,(pClient->IsBanned() ? MF_ENABLED:MF_GRAYED)); //fix by Maverick

	pMenuClient->AppendMenu(MF_SEPARATOR);
	pMenuClient->AppendMenu(MF_STRING,MP_UPDATEQQUEUE, GetResString(IDS_UPDATEQUEUE));
	pMenuClient->CheckMenuItem(MP_UPDATEQQUEUE,(g_eMuleApp.m_pGlobPrefs->GetUpdateQueueList() ? MF_CHECKED:MF_UNCHECKED));

	pMenuClient->AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)pMenuFilter->m_hMenu, GetResString(IDS_QUEUEFILTER));
	pMenuFilter->CheckMenuItem(MP_FILTER_NONE,(m_iClientFilter == CLI_FILTER_NONE)? MF_CHECKED:MF_UNCHECKED);
//	pMenuFilter->CheckMenuItem(MP_FILTER_BANNED,(m_iClientFilter == CLI_FILTER_BANNED)? MF_CHECKED:MF_UNCHECKED);
	pMenuFilter->CheckMenuItem(MP_FILTER_FRIEND,(m_iClientFilter == CLI_FILTER_FRIEND)? MF_CHECKED:MF_UNCHECKED);
	pMenuFilter->CheckMenuItem(MP_FILTER_CREDIT,(m_iClientFilter == CLI_FILTER_CREDIT)? MF_CHECKED:MF_UNCHECKED);
d702 1
a702 2
	SetMenu(reinterpret_cast<CMenu*>(pMenuClient));
	pMenuClient->TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
d704 1
a704 2
	pMenuFilter->DestroyMenu();
	pMenuClient->DestroyMenu();
a706 3

	safe_delete(pMenuFilter);
	safe_delete(pMenuClient);
@


1.96
log
@Removed Banned filter for queue list
@
text
@d155 2
a156 2
	SetSortArrow(iSortColumn,bSortAscending);	
	SortItems(&SortProc, iSortCode);
a330 1
	RECT			r;
d338 1
a338 2
	memcpy2(&r,&lpDrawItemStruct->rcItem,sizeof(RECT));

d410 2
a411 2
	                strBuffer = pClient->GetUserName();
	                // EC - Use Dark Green for SUI Clients
d558 1
a558 2
		RECT		rOutline;
		memcpy2(&rOutline,&lpDrawItemStruct->rcItem,sizeof(RECT));
d786 1
a786 1
void CQueueListCtrl::OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult)
d798 11
a808 8
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// if it's a second click on the same column then reverse the sort order,
	// otherwise sort the new column in ascending order.
	m_bSortAscending[pNMListView->iSubItem] = !m_bSortAscending[pNMListView->iSubItem];
	SetSortArrow(pNMListView->iSubItem, m_bSortAscending[pNMListView->iSubItem]);
	SortItems(&SortProc,pNMListView->iSubItem+ ((m_bSortAscending[pNMListView->iSubItem])? MLC_SORTASC : MLC_SORTDESC));
	g_eMuleApp.m_pGlobPrefs->SetColumnSortItem(CPreferences::TABLE_QUEUE, pNMListView->iSubItem);
	g_eMuleApp.m_pGlobPrefs->SetColumnSortAscending(CPreferences::TABLE_QUEUE, m_bSortAscending[pNMListView->iSubItem]);
@


1.95
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d676 1
a676 1
	pMenuFilter->AppendMenu(MF_STRING,MP_FILTER_BANNED, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_BANNED));
d700 1
a700 1
	pMenuFilter->CheckMenuItem(MP_FILTER_BANNED,(m_iClientFilter == CLI_FILTER_BANNED)? MF_CHECKED:MF_UNCHECKED);
@


1.94
log
@upload auto priority sets very well spread files to low prio + minor changes + cleanup
@
text
@d52 1
a52 1
	memset2(&m_bSortAscending, 0, sizeof(m_bSortAscending)); // i_a
@


1.93
log
@Formatting, comments, and name changes.
@
text
@d444 1
a444 1
							case PR_VERYHIGH:
@


1.92
log
@small corrections & some optimizations
@
text
@d985 1
a985 1
		POSITION posSelClient = GetFirstSelectedItemPosition();
d993 1
a993 1
			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(GetNextSelectedItem(posSelClient)));
@


1.91
log
@Some corrections in shortcut management code to keep new engine hierarchy (thanks to eklmn ;-))
@
text
@d1076 1
a1076 1

d1088 1
a1089 1
		}
d1091 5
a1095 4
		if (iMessage > 0)
		{
			PostMessage(WM_COMMAND, iMessage);
			return TRUE;
d1099 1
a1099 1
	return __super::PreTranslateMessage(pMsg);
@


1.90
log
@solution for selection & clicking (hopefuilly it will be final)
@
text
@d1076 24
@


1.89
log
@Some changes to fix blank infolist even while selecting a file and some GUI issues.
@
text
@d659 3
a661 3
	const int iClientListIndex = GetSelectionMark();
	
	if (iClientListIndex != -1)
d663 3
a665 3
		if(GetSelectedCount()>0)
			flags=MF_STRING;
		if(pClient = (CUpDownClient*)GetItemData(iClientListIndex))
d667 1
a667 1
 			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,const_cast<CUpDownClient*>(pClient));
d669 1
d718 1
a718 1
	const int iClientListIndex = GetSelectionMark();
d720 1
a720 1
	if (iClientListIndex != (-1))
d722 1
a722 1
		CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(iClientListIndex));
d936 14
d956 1
a956 2
	if(GetFirstSelectedItemPosition() == NULL)
		return;
d958 1
a958 1
	if (GetSelectionMark() != (-1))
d960 2
a961 1
		CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());
d964 1
a964 1
			CClientDetails dialog(GetResString(IDS_CD_TITLE), client, this, 0);
d969 1
a969 1
			g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(client);
d985 1
a985 1
		POSITION		pos = GetFirstSelectedItemPosition();
d987 2
a988 2
		if(pos == NULL)
		{			
d993 1
a993 3
			const int iSelClientListIndex = GetSelectionMark();

			CUpDownClient* pClient = reinterpret_cast<CUpDownClient*>(GetItemData(iSelClientListIndex));
@


1.88
log
@Minor fix on item selection and InfoList update
@
text
@a658 3
	if(GetFirstSelectedItemPosition() == NULL)
		return;

@


1.87
log
@refresh an InfoList only if ListCtrl is active
@
text
@d659 3
d944 3
d973 1
a973 1
		const int iSelClientListIndex = GetSelectionMark();
d975 1
a975 1
		if(iSelClientListIndex == -1)
d981 2
@


1.86
log
@Changed the way the preference for update of upload lists is handled
@
text
@d965 1
a965 6
	POSITION pos = GetFirstSelectedItemPosition();
	if(pos == NULL)
	{			
 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_NONE);
	}
	else
d967 1
a967 3
		const CUpDownClient* pClient = (CUpDownClient*)GetItemData(GetSelectionMark());

 		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SetList(INFOLISTTYPE_SOURCE,const_cast<CUpDownClient*>(pClient));
d969 11
a979 1
	}	
@


1.85
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d692 5
a696 1
	//DonGato: show filtered list of clients
d702 1
a702 3
//	pMenuClient->AppendMenu(MF_SEPARATOR);
//	pMenuClient->AppendMenu(MF_STRING,MP_SWITCHCTRL, GetResString(IDS_VIEWUPLOADS));
//	
d751 5
a755 1
		//DonGato: show filtered list of clients
d783 1
a783 5
/*		case MP_SWITCHCTRL:
		{
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.PostMessage(WM_COMMAND, USRMSG_SWITCHUPLOADLIST, (long)m_hWnd);
			break;
*/		}
@


1.84
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d60 1
a60 1
		AddLogLine(false, RGB_RED + GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.83
log
@Added some colors to the logs...
@
text
@d60 1
a60 1
		AddLogLine(false, _T("<COLOR=255,0,0>") + GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.82
log
@Fix for #486
@
text
@d60 1
a60 1
		AddLogLine(false, IDS_ERR_TIMERCREATEFAILED);
@


1.81
log
@Fix for queue filtering
@
text
@d504 2
a505 1
					strBuffer.Format(_T("%.1f"),(int)pClient->GetSmallFilePushRatio());		//Cax2 SF bugfix
d510 1
a510 1
					strBuffer.Format(_T("%.2f"),pClient->GetRareFilePushRatio());			//Cax2 RF bugfix
@


1.80
log
@fixed crash  due context menu, shortcut optimiation & update to UNICODE
@
text
@d1033 1
a1033 1
		AddClient(update);
@


1.79
log
@proper InfoList handling
@
text
@d651 5
d658 3
a660 3
	UINT flags=MF_STRING|MF_GRAYED;
	CUpDownClient* pClient = NULL;
	if (GetSelectionMark() != -1)
d664 1
a664 1
		if(pClient = (CUpDownClient*)GetItemData(GetSelectionMark()))
d670 1
a671 1
	CMenu *pMenuFilter = new CMenu();
d678 1
a678 2
	CTitleMenu *pMenuClient = new CTitleMenu();

d681 1
a681 1
	pMenuClient->AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails)));
d683 1
a683 1
		pMenuClient->AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
d685 3
a687 3
		pMenuClient->AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
	pMenuClient->AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage)));
	pMenuClient->AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles)));
d699 2
a700 1
	SetMenu(pMenuClient);
d702 1
a702 1
//	*pResult = 0;
d706 1
a706 2
	delete pMenuFilter;
	delete pMenuClient;
d708 2
a709 1
	EMULE_CATCH
d712 10
a721 4
BOOL CQueueListCtrl::OnCommand(WPARAM wParam,LPARAM lParam ){
	if (GetSelectionMark() != (-1)){
		CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());
		switch (wParam){
d723 1
a723 1
				client->RequestSharedFileList();
d726 1
a726 1
				g_eMuleApp.m_pdlgEmule->m_wndChat.StartSession(client);
d729 1
a729 1
				g_eMuleApp.m_pFriendList->AddFriend(client);
d732 1
a732 1
				g_eMuleApp.m_pFriendList->RemoveFriend(client);
d735 2
a736 2
				if( client->IsBanned() )
					client->UnBan();
d740 1
a740 1
				CClientDetails dialog(GetResString(IDS_CD_TITLE), client, this, 0);
@


1.78
log
@Correct localization of decimal point & thousands seperator + Correct encoding for Hebrew language in WebServer
@
text
@d274 1
a274 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d654 1
a654 1
	const CUpDownClient* client = NULL;
d659 1
a659 1
		if(client = (CUpDownClient*)GetItemData(GetSelectionMark()))
d661 1
a661 2
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser((CUpDownClient*)client);
			g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d678 1
a678 1
	if(client && client->IsFriend())
d685 2
a686 2
	if(client)
		pMenuClient->EnableMenuItem(MP_UNBAN,(client->IsBanned() ? MF_ENABLED:MF_GRAYED)); //fix by Maverick
d954 1
a954 2
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToFile(NULL);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
d958 4
a961 3
		const CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.SwitchToUser((CUpDownClient*) client);
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.UpdateInfoHeader();
@


1.77
log
@Added a function: bool IsRightToLeftLanguage(); + Fixed Hebrew text alignment in Shared Files list + Hebrew translation update
@
text
@d338 1
a338 1
		iCalcFlag = (iCalcFlag | DT_RTLREADING);
@


1.76
log
@Fixed Hebrew text alignment in Client, Downlod, Queue & Upload lists to Right-To-Left
@
text
@d337 1
a337 1
	if ( g_eMuleApp.m_pGlobPrefs->GetLanguageID() == 1037 )
@


1.75
log
@Fix for bug #459
Crash on right click
@
text
@d337 3
@


1.74
log
@Change to shortcut management code (it's easier to add an action now) / Added a lot of actions to shortcut management / Added some keys to shortcut management
@
text
@d27 1
d649 1
a649 2
//	POINT point;
//	::GetCursorPos(&point);	
d665 12
a676 9
	m_menuFilter.CreateMenu();
	m_menuFilter.AppendMenu(MF_STRING,MP_FILTER_NONE, GetResString(IDS_CAT_REINVADD));
	m_menuFilter.AppendMenu(MF_STRING,MP_FILTER_BANNED, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_BANNED));
	m_menuFilter.AppendMenu(MF_STRING,MP_FILTER_FRIEND, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_FRIEND));
	m_menuFilter.AppendMenu(MF_STRING,MP_FILTER_CREDIT, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_CREDIT));

	m_menuClient.CreatePopupMenu();
	m_menuClient.AddMenuTitle(GetResString(IDS_CLIENTS));
	m_menuClient.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULDetails)));
d678 1
a678 1
		m_menuClient.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
d680 4
a683 4
		m_menuClient.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFriend)));
	m_menuClient.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULMessage)));
	m_menuClient.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetShortcutCode(IndexULFiles)));
	m_menuClient.AppendMenu(flags,MP_UNBAN, GetResString(IDS_UNBAN));
d685 1
a685 1
		m_menuClient.EnableMenuItem(MP_UNBAN,(client->IsBanned() ? MF_ENABLED:MF_GRAYED)); //fix by Maverick
d687 9
a695 9
	m_menuClient.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_menuFilter.m_hMenu, GetResString(IDS_QUEUEFILTER));
	m_menuFilter.CheckMenuItem(MP_FILTER_NONE,(m_iClientFilter == CLI_FILTER_NONE)? MF_CHECKED:MF_UNCHECKED);
	m_menuFilter.CheckMenuItem(MP_FILTER_BANNED,(m_iClientFilter == CLI_FILTER_BANNED)? MF_CHECKED:MF_UNCHECKED);
	m_menuFilter.CheckMenuItem(MP_FILTER_FRIEND,(m_iClientFilter == CLI_FILTER_FRIEND)? MF_CHECKED:MF_UNCHECKED);
	m_menuFilter.CheckMenuItem(MP_FILTER_CREDIT,(m_iClientFilter == CLI_FILTER_CREDIT)? MF_CHECKED:MF_UNCHECKED);
//	m_menuClient.AppendMenu(MF_SEPARATOR);
//	m_menuClient.AppendMenu(MF_STRING,MP_SWITCHCTRL, GetResString(IDS_VIEWUPLOADS));
	SetMenu(&m_menuClient);
	m_menuClient.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
d697 7
a703 2
	m_menuFilter.DestroyMenu();
	m_menuClient.DestroyMenu();
@


1.73
log
@fixed convert bug in  DrawItem
@
text
@d673 1
a673 1
	m_menuClient.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientDetailsShortcutCode()));
d675 1
a675 1
		m_menuClient.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));
d677 3
a679 3
		m_menuClient.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));
	m_menuClient.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadSendMessageClientShortcutCode()));
	m_menuClient.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientFilesShortcutCode()));
@


1.72
log
@fixed sorting by "Rating"
@
text
@d113 8
a120 8
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  	// 3
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));      // 4
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      // 5
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      // 6
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  		// 7
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  		// 8
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  			// 9
    m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  		// 10
d286 1
a286 1
    	DeleteItem(result);
d491 1
a491 1
					strBuffer.Format(_T("%.1f"),static_cast<double>(pClient->GetScore(false,pClient->IsDownloading(),true)));
d496 1
a496 1
					strBuffer.Format(_T("%i"),pClient->GetScore(false));
d501 1
a501 1
					strBuffer.Format(_T("%i"),(int)pClient->GetSmallFilePushRatio());		//Cax2 SF bugfix
d765 3
a767 1
void CQueueListCtrl::OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult){
d769 5
a773 6
	//g_eMuleApp.m_pUploadQueue->ResetClientPos();
	CUpDownClient* update = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);

	while( update ){
		UpdateClient(update);
		update = g_eMuleApp.m_pUploadQueue->GetNextClient(update);
d775 1
a858 1
			//iCompare = static_cast<double>(pClient1->GetScore(false,false,true)) - static_cast<double>(pClient2->GetScore(false,false,true));
@


1.71
log
@Fixed selection background color on Uploads, On Queue & Known Clients lists and some other fixes
@
text
@d857 2
a858 1
			iCompare = static_cast<double>(pClient1->GetScore(false,false,true)) - static_cast<double>(pClient2->GetScore(false,false,true));
d864 1
a864 1
			iCompare = pClient1->GetSmallFilePushRatio()*100 - pClient2->GetSmallFilePushRatio()*100;
d867 1
a867 1
			iCompare = pClient1->GetRareFilePushRatio()*100 - pClient2->GetRareFilePushRatio()*100;
@


1.70
log
@1) sorting updated (credit sorting fixed)
2) double-click issue
3) OnEraseBkgnd & OnChildNotify replaced by same function in MuleListCtrl
@
text
@d310 3
d318 8
a325 2

	odc->SetBkColor(GetBkColor());
a330 1
    COLORREF		crOldBkColor = dc->GetBkColor();
d367 1
a367 1
								m_imageList.Draw(dc, UL_ICON_CDONKEY, point, ILD_NORMAL);
d370 1
a370 1
								m_imageList.Draw(dc, UL_ICON_LMULE, point, ILD_NORMAL);
d373 1
a373 1
								m_imageList.Draw(dc, UL_ICON_SHAREAZA, point, ILD_NORMAL);
d376 1
a376 1
								m_imageList.Draw(dc, UL_ICON_EDONKEYHYBRID, point, ILD_NORMAL);
d379 1
a379 1
								m_imageList.Draw(dc, UL_ICON_MLDONKEY, point, ILD_NORMAL);
d384 1
a384 1
									m_imageList.Draw(dc, UL_ICON_SECUREHASH, point, ILD_NORMAL);
d386 1
a386 1
									m_imageList.Draw(dc, UL_ICON_COMPROT, point, ILD_NORMAL);
d389 1
a389 1
								m_imageList.Draw(dc, UL_ICON_NORMAL, point, ILD_NORMAL);
d392 1
a392 1
								m_imageList.Draw(dc, UL_ICON_UNKNOWN, point, ILD_NORMAL);
a556 2
		CBrush		*pOldBrush;

d562 2
a563 3
		CBrush		gdiBrush(GetBkColor());

		pOldBrush = dc->SelectObject(&gdiBrush);	//eklmn: select a new brush
d565 1
d573 2
a574 3
			CBrush		fl_Brush(m_crFocusLine);

			dc->SelectObject(&fl_Brush);	//eklmn: select a new brush
a575 1
			//eklmn: recover of old brush will be done below
d579 2
a580 3
			CBrush		nfl_Brush(m_crNoFocusLine);

			dc->SelectObject(&nfl_Brush);	//eklmn: select a new brush
a581 1
			//eklmn: recover of old brush will be done below
d584 1
a584 1
		dc->SelectObject(pOldBrush);		//eklmn: recover an old brush
d586 4
a589 1
	dc.SelectObject(pOldFont);
@


1.69
log
@Formatting, comments, and name changes.
@
text
@d64 1
a64 1
	m_imageList.DeleteImageList();	//eklmn: bugfix(01): resource cleanup due to ImageLists recreation
d134 1
a134 1
void CQueueListCtrl::SortInit(int sortCode)
d138 4
a141 1
	int		iCurrentSortItem = (sortCode & MLC_SORTDESC) == 0 ? sortCode : sortCode - MLC_SORTDESC;
d143 3
a145 1
	SetSortArrow(iCurrentSortItem,(sortCode & MLC_SORTDESC) == 0);
d147 1
a147 3
	CUpDownClient		*update = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);

	while (update)
d149 2
a150 2
		UpdateClient(update);
		update = g_eMuleApp.m_pUploadQueue->GetNextClient(update);
d152 5
a156 1
	SortItems(&SortProc, sortCode);
d692 1
a692 1

d759 1
a759 1

d780 11
d792 9
a800 15
int CQueueListCtrl::SortProc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort){
	CUpDownClient* item1 = (CUpDownClient*)lParam1;
	CUpDownClient* item2 = (CUpDownClient*)lParam2;
	CKnownFile* file1 = g_eMuleApp.m_pSharedFilesList->GetFileByID(item1->m_reqFileHash);
	CKnownFile* file2 = g_eMuleApp.m_pSharedFilesList->GetFileByID(item2->m_reqFileHash);
		switch(lParamSort){
		case 0: 
			return CString(item1->GetUserName()).CompareNoCase(item2->GetUserName());
		case 0+MLC_SORTDESC:
			return CString(item2->GetUserName()).CompareNoCase(item1->GetUserName());
		case 1: 
			if( (file1 != NULL) && (file2 != NULL))
				return CString(file1->GetFileName()).CompareNoCase(file2->GetFileName());
			else if( file1 == NULL )
				return 1;
d802 5
a806 6
				return 0;
		case 1+MLC_SORTDESC:
			if( (file1 != NULL) && (file2 != NULL))
				return CString(file2->GetFileName()).CompareNoCase(file1->GetFileName());
			else if( file1 == NULL )
				return 1;
d808 2
a809 3
				return 0;
		case 2: 
			if(file1 != NULL && file2 != NULL)		//Cax2 - right priority sortig
d811 13
a823 5
				if(file1->GetPriority() ==PR_VERYLOW) 
					return -1;
				if(file2->GetPriority() ==PR_VERYLOW)
					return 1;
				return file1->GetPriority() - file2->GetPriority();
a824 2
			else if( file1 == NULL )
				return 1;
d826 3
a828 3
				return 0;
		case 2+MLC_SORTDESC:
			if( file1 != NULL && file2 != NULL)		//Cax2 - right priority sortig
d830 2
a831 5
				if(file1->GetPriority() ==PR_VERYLOW) 
					return 1;
				if(file2->GetPriority() ==PR_VERYLOW)
					return -1;
				return file2->GetPriority() - file1->GetPriority();
d833 6
a838 4
			else if( file1 == NULL )
				return 1;
			else
				return 0;
d840 4
a843 68
		case 3:
		case 3+MLC_SORTDESC:
		case 4:
		case 4+MLC_SORTDESC:
            {  // obaldin: sort by upload progress
                int res;
                uint32 partcnt1 = item1->GetUpPartCount();
                uint32 partcnt2 = item2->GetUpPartCount();
                if( (partcnt1==0) && (partcnt2==0))
                    res=0;
                else if(partcnt1==0)
                    res = -1;
                else if(partcnt2==0)
                    res = 1;
                else {
                    double progr1 = static_cast<double>(item1->GetAvailUpPartCount())/static_cast<double>(partcnt1);
                    double progr2 = static_cast<double>(item2->GetAvailUpPartCount())/static_cast<double>(partcnt2);
                    if(progr1<progr2)
                        res = -1;
                    else if(progr1>progr2)
                        res = 1;
                    else 
                        res = 0;
                }

                if ((lParamSort & MLC_SORTDESC) == 0)
                    return res;
                else 
                    return -res;
            }

        case 5: 
			return static_cast<double>(item1->GetScore(false,false,true)) - static_cast<double>(item2->GetScore(false,false,true));
		case 5+MLC_SORTDESC: 
			return static_cast<double>(item2->GetScore(false,false,true)) - static_cast<double>(item1->GetScore(false,false,true));

		case 6: 
			return item1->GetScore(false) - item2->GetScore(false);
		case 6+MLC_SORTDESC: 
			return item2->GetScore(false) - item1->GetScore(false);

		// Added by Tarod
		case 7: //small file  asc
			return (int)(item1->GetSmallFilePushRatio()*100 - item2->GetSmallFilePushRatio()*100);
		case 7+MLC_SORTDESC: //small file desc
			return (int)(item2->GetSmallFilePushRatio()*100 - item1->GetSmallFilePushRatio()*100);
		case 8: //rare file asc
			return (int)(item1->GetRareFilePushRatio()*100 - item2->GetRareFilePushRatio()*100);
		case 8+MLC_SORTDESC: //rare file desc
			return (int)(item2->GetRareFilePushRatio()*100 - item1->GetRareFilePushRatio()*100);
		// End by Tarod

		case 9: 
			return item1->GetAskedCount() - item2->GetAskedCount();
		case 9+MLC_SORTDESC: 
			return item2->GetAskedCount() - item1->GetAskedCount();
		case 10: 
			return item2->GetLastUpRequest() - item1->GetLastUpRequest();
		case 10+MLC_SORTDESC: 
			return item1->GetLastUpRequest() - item2->GetLastUpRequest();
		case 11: 
			return item2->GetWaitStartTime() - item1->GetWaitStartTime();
		case 11+MLC_SORTDESC: 
			return item1->GetWaitStartTime() - item2->GetWaitStartTime();
		case 12: 
			return item1->IsBanned() - item2->IsBanned();
		case 12+MLC_SORTDESC: 
			return item2->IsBanned() - item1->IsBanned();
d845 36
d882 1
a882 1
			return 0;
d884 2
d887 1
a887 1

d902 1
a902 1

d908 1
a908 1

d926 1
a926 1

d932 1
a932 1

d948 2
a949 1

d952 1
a952 1
	return CListCtrl::OnEraseBkgnd(pDC);
d954 2
a955 1

d958 1
a958 19
	if(message != WM_DRAWITEM) {
		//catch the prepaint and copy struct
		if(message == WM_NOTIFY && ((NMHDR*)lParam)->code == NM_CUSTOMDRAW &&
		  ((LPNMLVCUSTOMDRAW)lParam)->nmcd.dwDrawStage == CDDS_ITEMPREPAINT) {

			m_bCustomDraw = CListCtrl::OnChildNotify(message, wParam, lParam, pLResult);
			if(m_bCustomDraw)
				memcpy2(&m_lvcd, (void*)lParam, sizeof(NMLVCUSTOMDRAW));

			return m_bCustomDraw;
		}

		return CListCtrl::OnChildNotify(message, wParam, lParam, pLResult);
	}
	ASSERT(pLResult == NULL); // no return value expected
	UNUSED(pLResult);         // unused in release builds

	DrawItem((LPDRAWITEMSTRUCT)lParam);
	return TRUE;
d960 1
a960 1

d995 1
a995 1

d1012 1
a1012 1

d1025 1
@


1.68
log
@*** empty log message ***
@
text
@d661 1
a661 1
	m_menuClient.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientDetailsShortcutCode()));	// DropF - Keyboard Shortcuts
d663 1
a663 1
		m_menuClient.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));	// DropF - Keyboard Shortcuts
d665 3
a667 3
		m_menuClient.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadAddClientToFriendsShortcutCode()));	// DropF - Keyboard Shortcuts
	m_menuClient.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadSendMessageClientShortcutCode()));	// DropF - Keyboard Shortcuts
	m_menuClient.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES) + "\t" + GetStringFromShortcutCode(g_eMuleApp.m_pGlobPrefs->GetUploadViewClientFilesShortcutCode()));	// DropF - Keyboard Shortcuts
@


1.67
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d661 1
a661 1
	m_menuClient.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
d663 1
a663 1
		m_menuClient.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d665 3
a667 3
		m_menuClient.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
	m_menuClient.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG));
	m_menuClient.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
@


1.66
log
@Formatting, comments, and name changes.
Completion of download list sorting changes (for now).
Added missing sort on FakeCheck column in search window.
@
text
@d476 1
a476 1
					strBuffer.Format(_T("%.1f"),(float)pClient->GetScore(false,pClient->IsDownloading(),true));
d840 2
a841 2
                    float progr1 = float(item1->GetAvailUpPartCount())/float(partcnt1);
                    float progr2 = float(item2->GetAvailUpPartCount())/float(partcnt2);
d857 1
a857 1
			return (float)item1->GetScore(false,false,true) - (float)item2->GetScore(false,false,true);
d859 1
a859 1
			return (float)item2->GetScore(false,false,true) - (float)item1->GetScore(false,false,true);
@


1.65
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d138 1
a138 1
	int		m_iCurrentSortItem = (sortCode < 100) ? sortCode : sortCode - 100;
d140 1
a140 1
	SetSortArrow(m_iCurrentSortItem,(sortCode < 100));
d768 1
a768 1
	SortItems(&SortProc,pNMListView->iSubItem+ ((m_bSortAscending[pNMListView->iSubItem])? 0:100));
d782 1
a782 1
		case 100:
d791 1
a791 1
		case 101:
d811 1
a811 1
		case 102:
d826 1
a826 1
		case 103:
d828 1
a828 1
		case 104:
d850 1
a850 1
                if(lParamSort<100)
d858 1
a858 1
		case 105: 
d863 1
a863 1
		case 106: 
d869 1
a869 1
		case 107: //small file desc
d873 1
a873 1
		case 108: //rare file desc
d878 2
a879 2
		return item1->GetAskedCount() - item2->GetAskedCount();
		case 109: 
a880 2
		case 110: 
			return item1->GetLastUpRequest() - item2->GetLastUpRequest();
d883 2
a884 2
		case 111: 
			return item1->GetWaitStartTime() - item2->GetWaitStartTime();
d887 2
d891 1
a891 1
		case 112: 
@


1.64
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d325 1
a325 1
	CKnownFile		*pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pClient->reqfileid);
d368 1
a368 1
								if (pClient->credits->GetCurrentIdentState(pClient->GetIP()) != IS_IDENTIFIED)
d386 1
a386 1
						else if (pClient->credits->GetScoreRatio(pClient->GetIP()) > 1)
d396 1
a396 1
					//if (pClient->credits->GetCurrentIdentState(pClient->GetIP()) == IS_IDENTIFIED)
d406 1
a406 1
					//if (pClient->credits->GetCurrentIdentState(pClient->GetIP()) == IS_IDENTIFIED)
d777 2
a778 2
	CKnownFile* file1 = g_eMuleApp.m_pSharedFilesList->GetFileByID(item1->reqfileid);
	CKnownFile* file2 = g_eMuleApp.m_pSharedFilesList->GetFileByID(item2->reqfileid);
d1047 1
a1047 1
	else if ((client->credits->GetScoreRatio(client->GetIP()) > 1))
@


1.63
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d146 1
a146 1
		RefreshClient(update);
d282 1
a282 1
void CQueueListCtrl::RefreshClient(CUpDownClient *pClient)
d592 1
a592 1
			RefreshClient(pClient);
d759 1
a759 1
		RefreshClient( update);
d909 1
a909 1
		g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_wndQueueList.RefreshClient(update);
@


1.62
log
@Removed old details code, added more keyboard shortcuts (now with only Ctrl instead of all three keys)
@
text
@d51 1
a51 1
	memset(&m_bSortAscending, 0, sizeof(m_bSortAscending)); // i_a
@


1.61
log
@Formatting, comments, and name changes. Factored various UI update methods out and modified to use async. messaging instead of sync. call.
@
text
@a25 1
#ifdef _USE_NEW_DETAILS_
a26 3
#else
#include "ClientDetailDialog.h"
#endif
a707 1
			#if _USE_NEW_DETAILS_
a708 3
			#else
				CClientDetailDialog dialog(client);
			#endif
a926 1
		#if _USE_NEW_DETAILS_
a927 3
		#else
			CClientDetailDialog dialog(client);
		#endif
@


1.60
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d584 28
@


1.59
log
@Localization update
@
text
@a30 1
#include "memcpy_amd.h"
@


1.58
log
@Fixed "sort settings not saved".
@
text
@d686 1
a686 1
				CClientDetails dialog("Client Details", client, this, 0);
d909 1
a909 1
			CClientDetails dialog("Client Details", client, this, 0);
@


1.57
log
@Modified column resizing to resize to header text in empty columns.
@
text
@d750 2
@


1.56
log
@Fix for a bug in the column resizing fix.
@
text
@d536 1
a536 1
				if (iWidth < 40)
d596 4
a599 1
	SetColumnWidth(iColumn,m_iColumnMaxWidths[iColumn]);
@


1.55
log
@Formatting, comments, and name changes.
Fixed column resizing on double-click.
@
text
@d342 1
a342 1
		if (!IsColumnHidden(iColumn) && !(bMeasuring && iCurrent != m_iMeasuringColumn))
@


1.54
log
@Formatting, comments, and name changes.
@
text
@d39 10
d52 5
a56 2
CQueueListCtrl::CQueueListCtrl(){
	memset(&asc_sort, 0, sizeof(asc_sort)); // i_a
d66 18
a84 2
void CQueueListCtrl::Init(){
	CImageList ilDummyImageList;
d91 7
d99 28
a126 28
	InsertColumn(0,GetResString(IDS_QL_USERNAME),LVCFMT_LEFT,150,0);
	InsertColumn(1,GetResString(IDS_FILE),LVCFMT_LEFT,275,1);
	InsertColumn(2,GetResString(IDS_FILEPRIO),LVCFMT_LEFT,110,2);
	InsertColumn(3,GetResString(IDS_UP_PARTS),LVCFMT_LEFT,110,3);
	InsertColumn(4,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT,110,4);
	InsertColumn(5,GetResString(IDS_QL_RATING),LVCFMT_LEFT,60,5);
	InsertColumn(6,GetResString(IDS_SCORE),LVCFMT_LEFT,60,6);
	InsertColumn(7,GetResString(IDS_SFRATIO),LVCFMT_LEFT,60,7); // Tarod
	InsertColumn(8,GetResString(IDS_RFRATIO),LVCFMT_LEFT,60,8); // Tarod
	InsertColumn(9,GetResString(IDS_ASKED),LVCFMT_LEFT,60,9);
	InsertColumn(10,GetResString(IDS_LASTSEEN),LVCFMT_LEFT,110,10);
	InsertColumn(11,GetResString(IDS_ENTERQUEUE),LVCFMT_LEFT,110,11);
	InsertColumn(12,GetResString(IDS_BANNED),LVCFMT_LEFT,60,12);

	imagelist.Create(16,16,ILC_COLOR32|ILC_MASK,0,10);
	imagelist.SetBkColor(CLR_NONE);
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));			// 0
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));			// 1
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));			// 2
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  	// 3
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));      // 4
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));      // 5
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));      // 6
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  		// 7
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  		// 8
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  			// 9
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  		// 10
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SECUREHASH),16,16));  		// 11
d128 1
a128 1
	SetImageList(&imagelist,LVSIL_SMALL);
d138 10
d149 1
a149 5
CQueueListCtrl::~CQueueListCtrl()
{
	imagelist.DeleteImageList();	//eklmn: bugfix(01): resource cleanup due to ImageLists recreation
	// Barry - Kill the timer that was created
	try
d151 1
a151 12
		if (m_hTimer)
			::KillTimer(NULL, m_hTimer);
	} catch (...) {}
}

void CQueueListCtrl::SortInit(int sortCode){	//Cax2 sortdlg
	m_dwSortTime=::GetTickCount();
	int m_iCurrentSortItem=(sortCode<100)?sortCode:sortCode-100;
	SetSortArrow(m_iCurrentSortItem,(sortCode<100));
	CUpDownClient* update = g_eMuleApp.m_pUploadQueue->GetNextClient(NULL);
	while( update ){
		RefreshClient( update);
d156 1
a156 1

d159 1
a159 1
	if(GetSafeHwnd())
d161 3
a163 2
		CHeaderCtrl* pHeaderCtrl = GetHeaderCtrl();
		HDITEM hdi;
d166 1
a166 1
		if(pHeaderCtrl->GetItemCount() != 0) 
d168 1
a168 1
			CString strRes;
d172 1
a172 1
			pHeaderCtrl->SetItem(0, &hdi);
d177 1
a177 1
			pHeaderCtrl->SetItem(1, &hdi);
d182 1
a182 1
			pHeaderCtrl->SetItem(2, &hdi);
d187 1
a187 1
			pHeaderCtrl->SetItem(3, &hdi);
d192 1
a192 1
			pHeaderCtrl->SetItem(4, &hdi);
d197 1
a197 1
			pHeaderCtrl->SetItem(5, &hdi);
d202 1
a202 1
			pHeaderCtrl->SetItem(6, &hdi);
d207 1
a207 1
			pHeaderCtrl->SetItem(7, &hdi);
d212 1
a212 1
			pHeaderCtrl->SetItem(8, &hdi);
d217 1
a217 1
			pHeaderCtrl->SetItem(9, &hdi);
d222 1
a222 1
			pHeaderCtrl->SetItem(10, &hdi);
d227 1
a227 1
			pHeaderCtrl->SetItem(11, &hdi);
d232 1
a232 1
			pHeaderCtrl->SetItem(12, &hdi);
d237 2
a238 2

void CQueueListCtrl::AddClient(CUpDownClient* client, bool reset)
d240 4
a243 2
	if (!g_eMuleApp.m_pdlgEmule->IsRunning()) return;
	if (!client) return;	//check NULL case
d245 2
a246 2
	if(m_iClientFilter != 0)
		if(m_iClientFilter != GetClientFilterType(client))
d249 3
a251 2
	uint32 itemnr = GetItemCount();
	itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,LPSTR_TEXTCALLBACK,0,0,1,(LPARAM)client);
d253 1
a253 1
	if(reset == true) 
d255 2
a256 2
		client->SetWaitStartTime();
		client->SetAskedCount(1);
d259 2
a260 2

void CQueueListCtrl::RemoveClient(CUpDownClient* client)
d262 4
a265 2
	if (!g_eMuleApp.m_pdlgEmule->IsRunning()) return;
	if (!client) return;	//check NULL case
d267 1
a267 1
	if(g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetType() == INFOLISTTYPE_SOURCE)
d269 1
a269 1
		if(g_eMuleApp.m_pdlgEmule->m_wndTransfer.m_ctlInfoList.GetClient() == client)
d276 2
a277 1
	LVFINDINFO find;
d279 5
a283 3
	find.lParam = (LPARAM)client;
	sint32 result = FindItem(&find);
	if(result != (-1))
d286 8
d295 1
a295 5
void CQueueListCtrl::RefreshClient(CUpDownClient* client)
{
	//Don't refresh during app shutdown [TwoBottle Mod]
	if (!g_eMuleApp.m_pdlgEmule->IsRunning()) return;
	if (!client) return;	//check NULL case
a296 1
	LVFINDINFO find;
d298 5
a302 3
	find.lParam = (LPARAM)client;
	sint16 result = FindItem(&find);
	if(result != -1)
d305 1
a305 1

d310 4
a313 2
	CDC* odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	BOOL bCtrlFocused = ((GetFocus() == this ) || (GetStyle() & LVS_SHOWSELALWAYS));
a314 15
	CUpDownClient* client = (CUpDownClient*)lpDrawItemStruct->itemData;
	CMemDC dc(odc,&CRect(lpDrawItemStruct->rcItem));
	CFont *pOldFont = dc.SelectObject(GetFont());
	COLORREF crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
    COLORREF crOldBkColor = dc->GetBkColor();
	RECT cur_rec;
	memcpy2(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));

	CString Sbuffer;

	CKnownFile* file = g_eMuleApp.m_pSharedFilesList->GetFileByID(client->reqfileid);
	CHeaderCtrl *pHeaderCtrl = GetHeaderCtrl();
	int iCount = pHeaderCtrl->GetItemCount();
	cur_rec.right = cur_rec.left - 8;
	cur_rec.left += 4;
d316 23
a338 1
	for(int iCurrent = 0; iCurrent < iCount; iCurrent++)
d340 3
a342 2
		int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
		if(!IsColumnHidden(iColumn))
d344 2
a345 2
			cur_rec.right += GetColumnWidth(iColumn);
			switch(iColumn)
d347 3
a349 1
				case 0:
d351 1
a351 1
					    POINT point = {cur_rec.left, cur_rec.top+1};
d353 3
a355 2
						// Display client icon
						switch(client->GetClientSoft()) {
d357 1
a357 1
								imagelist.Draw(dc, 8, point, ILD_NORMAL);
d360 1
a360 1
								imagelist.Draw(dc, 9, point, ILD_NORMAL);
d363 1
a363 1
								imagelist.Draw(dc, 10, point, ILD_NORMAL);
d366 1
a366 1
								imagelist.Draw(dc, 3, point, ILD_NORMAL);
d369 1
a369 1
								imagelist.Draw(dc, 2, point, ILD_NORMAL);
d373 2
a374 2
								if (client->credits->GetCurrentIdentState(client->GetIP()) != IS_IDENTIFIED)
									imagelist.Draw(dc, 11, point, ILD_NORMAL);
d376 1
a376 1
									imagelist.Draw(dc, 1, point, ILD_NORMAL);
d379 1
a379 1
								imagelist.Draw(dc, 0, point, ILD_NORMAL);
d382 1
a382 1
								imagelist.Draw(dc, 7, point, ILD_NORMAL);
d386 140
a525 13
						// Display any Extra Overlay icons
	                    if (client->IsBanned())
	                        imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
	                    else if (client->IsFriend())
	                        imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
	                    else if (client->credits->GetScoreRatio(client->GetIP()) > 1)
	                        imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);

	                    Sbuffer = client->GetUserName();
						cur_rec.left +=20;
	                    // EC - Use Dark Green for SUI Clients
						//if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED)
						//	crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));								
d527 5
a531 1
						dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
d533 7
a539 79
						//if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED)
						//	dc->SetTextColor(crOldTxtColor);				
	
						cur_rec.left -=20;
						break;
	    			}
				case 1:
							if(file)
								Sbuffer = file->GetFileName();
							else
								Sbuffer = "?";
							break;
				case 2:
							if (file){
								switch(file->GetPriority()){ 
									case PR_VERYHIGH:
										Sbuffer = GetResString(IDS_PRIORELEASE);		//Cax2 in sync with m_pSharedFilesList now
										break;
									case PR_HIGH: 
										Sbuffer = GetResString(IDS_PRIOHIGH);
										break; 
									case PR_LOW: 
										Sbuffer = GetResString(IDS_PRIOLOW);
										break; 
									case PR_VERYLOW:
										Sbuffer = GetResString(IDS_PRIOVERYLOW);
										break;
									default: 
										Sbuffer = GetResString(IDS_PRIONORMAL);
									break; 
								}
							}
							else
								Sbuffer = "?";
							break;
				case 3:
							if( client->GetUpPartCount() ){
							    Sbuffer.Format(_T("%d/%d"), client->GetAvailUpPartCount(), client->GetUpPartCount());
		                    } else {
							    Sbuffer.Format(_T(""));
		                    }
		                    break;
				case 4:
					        if( client->GetUpPartCount() && g_eMuleApp.m_pGlobPrefs->IsUploadPartsEnabled())		//Cax2 re-enabled toggle for progress bars
					        {
						        cur_rec.bottom--;
						        cur_rec.top++;
						        client->DrawUpStatusBar(dc,&cur_rec,false,g_eMuleApp.m_pGlobPrefs->UseFlatBar());
						        cur_rec.bottom++;
						        cur_rec.top--;
					        }
					        break;
				case 5:
							Sbuffer.Format(_T("%.1f"),(float)client->GetScore(false,client->IsDownloading(),true));
							break;
				case 6:
							Sbuffer.Format(_T("%i"),client->GetScore(false));
							break;
				case 7:
							Sbuffer.Format(_T("%i"),(int)client->GetSmallFilePushRatio());		//Cax2 SF bugfix
							break;
				case 8:
							Sbuffer.Format(_T("%.2f"),client->GetRareFilePushRatio());			//Cax2 RF bugfix
							break;
				case 9:
							Sbuffer.Format(_T("%i"),client->GetAskedCount());
							break;
				case 10:
							Sbuffer = CastSecondsToHM((GetTickCount() - client->GetLastUpRequest())/1000);
							break;
				case 11:
							Sbuffer = CastSecondsToHM((GetTickCount() - client->GetWaitStartTime())/1000);
							break;
				case 12:
							if(client->IsBanned())
								Sbuffer = GetResString(IDS_YES);
							else
								Sbuffer = GetResString(IDS_NO);
							break;
a540 3
			if( iColumn != 4 && iColumn != 0)
				dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
			cur_rec.left += GetColumnWidth(iColumn);
d543 1
a543 1
	//draw rectangle around selected item(s)
d546 10
a555 7
		RECT outline_rec;
		CBrush* pOldBrush;
		memcpy2(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));

		outline_rec.top--;
		outline_rec.bottom++;
		CBrush gdiBrush(GetBkColor());
d557 5
a561 5
		dc->FrameRect(&outline_rec, &gdiBrush);
		outline_rec.top++;
		outline_rec.bottom--;
		outline_rec.left++;
		outline_rec.right--;
d563 1
a563 1
		if(bCtrlFocused)
d565 2
a566 1
			CBrush fl_Brush(m_crFocusLine);
d568 1
a568 1
			dc->FrameRect(&outline_rec, &fl_Brush);
d573 2
a574 1
			CBrush nfl_Brush(m_crNoFocusLine);
d576 1
a576 1
			dc->FrameRect(&outline_rec, &nfl_Brush);
d584 14
d599 5
a603 9
BEGIN_MESSAGE_MAP(CQueueListCtrl, CMuleListCtrl)
	ON_WM_CONTEXTMENU()
	ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
	ON_NOTIFY_REFLECT(NM_CLICK, OnNMClick)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnNMDblclkQueuelist)
	ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
	ON_WM_KEYUP()
	ON_WM_ERASEBKGND()
END_MESSAGE_MAP()
d606 2
d627 5
a631 5
	m_FilterMenu.CreateMenu();
	m_FilterMenu.AppendMenu(MF_STRING,MP_FILTER_NONE, GetResString(IDS_CAT_REINVADD));
	m_FilterMenu.AppendMenu(MF_STRING,MP_FILTER_BANNED, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_BANNED));
	m_FilterMenu.AppendMenu(MF_STRING,MP_FILTER_FRIEND, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_FRIEND));
	m_FilterMenu.AppendMenu(MF_STRING,MP_FILTER_CREDIT, GetResString(IDS_WEB_SHOW_UPLOAD_QUEUE_CREDIT));
d646 5
a650 5
	m_menuClient.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_FilterMenu.m_hMenu, GetResString(IDS_QUEUEFILTER));
	m_FilterMenu.CheckMenuItem(MP_FILTER_NONE,(m_iClientFilter == CLI_FILTER_NONE)? MF_CHECKED:MF_UNCHECKED);
	m_FilterMenu.CheckMenuItem(MP_FILTER_BANNED,(m_iClientFilter == CLI_FILTER_BANNED)? MF_CHECKED:MF_UNCHECKED);
	m_FilterMenu.CheckMenuItem(MP_FILTER_FRIEND,(m_iClientFilter == CLI_FILTER_FRIEND)? MF_CHECKED:MF_UNCHECKED);
	m_FilterMenu.CheckMenuItem(MP_FILTER_CREDIT,(m_iClientFilter == CLI_FILTER_CREDIT)? MF_CHECKED:MF_UNCHECKED);
d656 1
a656 1
	m_FilterMenu.DestroyMenu();
d744 3
a746 3
	asc_sort[pNMListView->iSubItem] = !asc_sort[pNMListView->iSubItem];
	SetSortArrow(pNMListView->iSubItem, asc_sort[pNMListView->iSubItem]);
	SortItems(&SortProc,pNMListView->iSubItem+ ((asc_sort[pNMListView->iSubItem])? 0:100));
@


1.53
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d115 3
a117 3
	m_sortTime=::GetTickCount();
	int m_CurrentSortItem=(sortCode<100)?sortCode:sortCode-100;
	SetSortArrow(m_CurrentSortItem,(sortCode<100));
d502 3
a504 3
	m_ClientMenu.CreatePopupMenu();
	m_ClientMenu.AddMenuTitle(GetResString(IDS_CLIENTS));
	m_ClientMenu.AppendMenu(flags,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
d506 1
a506 1
		m_ClientMenu.AppendMenu(flags,MP_REMOVEFRIEND, GetResString(IDS_REMOVEFRIEND));
d508 4
a511 4
		m_ClientMenu.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
	m_ClientMenu.AppendMenu(flags,MP_MESSAGE, GetResString(IDS_SEND_MSG));
	m_ClientMenu.AppendMenu(flags,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
	m_ClientMenu.AppendMenu(flags,MP_UNBAN, GetResString(IDS_UNBAN));
d513 1
a513 1
		m_ClientMenu.EnableMenuItem(MP_UNBAN,(client->IsBanned() ? MF_ENABLED:MF_GRAYED)); //fix by Maverick
d515 1
a515 1
	m_ClientMenu.AppendMenu(MF_STRING|MF_POPUP,(UINT_PTR)m_FilterMenu.m_hMenu, GetResString(IDS_QUEUEFILTER));
d520 4
a523 4
//	m_ClientMenu.AppendMenu(MF_SEPARATOR);
//	m_ClientMenu.AppendMenu(MF_STRING,MP_SWITCHCTRL, GetResString(IDS_VIEWUPLOADS));
	SetMenu(&m_ClientMenu);
	m_ClientMenu.TrackPopupMenu(TPM_LEFTALIGN |TPM_RIGHTBUTTON, point.x, point.y, this);
d526 1
a526 1
	m_ClientMenu.DestroyMenu();
@


1.52
log
@fix for errors on removing a file when no space on Temp disk (#0000284)
fix for queue filtering (forgot that the list is updated :P)
@
text
@d433 1
d438 3
a440 1
		dc->FrameRect(&outline_rec, &CBrush(GetBkColor()));
d447 6
a452 1
			dc->FrameRect(&outline_rec, &CBrush(m_crFocusLine));
d454 8
a461 1
			dc->FrameRect(&outline_rec, &CBrush(m_crNoFocusLine));
@


1.51
log
@Fix for forced sharing (root dirs)
Added filtering to GUI queue
@
text
@d211 4
a222 3
	//RefreshClient(client);
	//if (g_eMuleApp.m_pGlobPrefs->DoUseSort() && m_sortTime+10000<::GetTickCount())
	//	SortInit(g_eMuleApp.m_pGlobPrefs->GetQueueSortCol());
d867 1
a867 18
		if(m_iClientFilter == CLI_FILTER_BANNED)
		{
       		if (update->IsBanned())
				AddClient(update);
		}
		else if(m_iClientFilter == CLI_FILTER_FRIEND)
		{
       		if (update->IsFriend())
				AddClient(update);
		}
		else if(m_iClientFilter == CLI_FILTER_CREDIT)
		{
       		if ((update->credits->GetScoreRatio(update->GetIP()) > 1))
				AddClient(update);
		}
		else
			AddClient(update);

d872 14
a885 1
}@


1.50
log
@Added Known List to transfer window. Hope no major bug was introduced. Should be tested!
@
text
@d60 2
a333 2
	
						
d479 7
d498 6
d509 1
d545 1
a545 1
/*	switch(wParam)
d547 29
a575 1
		case MP_SWITCHCTRL:
d579 1
a579 1
		}
d581 1
a581 1
*/	return true;
d855 34
@


1.49
log
@A little more method factoring, a few name changes, no (intended) logic changes.
@
text
@d491 2
a492 2
	m_ClientMenu.AppendMenu(MF_SEPARATOR);
	m_ClientMenu.AppendMenu(MF_STRING,MP_SWITCHCTRL, GetResString(IDS_VIEWUPLOADS));
d531 1
a531 1
	switch(wParam)
d539 1
a539 1
	return true;
@


1.48
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d94 1
a94 1
	LoadSettings(CPreferences::tableQueue);
@


1.47
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d271 1
a271 5
	#ifndef AMD
	memcpy(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
	#else
	memcpy_amd(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
	#endif
d432 1
a432 5
		#ifndef AMD
		memcpy(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
		#else
		memcpy_amd(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));
		#endif
d765 1
a765 5
				#ifndef AMD
				memcpy(&m_lvcd, (void*)lParam, sizeof(NMLVCUSTOMDRAW));
				#else
				memcpy_amd(&m_lvcd, (void*)lParam, sizeof(NMLVCUSTOMDRAW));
				#endif
@


1.46
log
@Fix for lists navigation [from official]
@
text
@d95 2
a96 2
	if (theApp.glob_prefs->DoUseSort())
		SortInit(theApp.glob_prefs->GetQueueSortCol()); //sortdlg Cax2
d116 1
a116 1
	CUpDownClient* update = theApp.uploadqueue->GetNextClient(NULL);
d119 1
a119 1
		update = theApp.uploadqueue->GetNextClient(update);
d206 1
a206 1
	if (!theApp.emuledlg->IsRunning()) return;
d218 2
a219 2
	//if (theApp.glob_prefs->DoUseSort() && m_sortTime+10000<::GetTickCount())
	//	SortInit(theApp.glob_prefs->GetQueueSortCol());
d224 1
a224 1
	if (!theApp.emuledlg->IsRunning()) return;
d227 1
a227 1
	if(theApp.emuledlg->transferwnd.m_wndInfoList.GetType() == 1)
d229 1
a229 1
		if(theApp.emuledlg->transferwnd.m_wndInfoList.GetClient() == client)
d231 2
a232 2
			theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToFile(NULL);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
d247 1
a247 1
	if (!theApp.emuledlg->IsRunning()) return;
d279 1
a279 1
	CKnownFile* file = theApp.sharedfiles->GetFileByID(client->reqfileid);
d363 1
a363 1
										Sbuffer = GetResString(IDS_PRIORELEASE);		//Cax2 in sync with sharedfiles now
d390 1
a390 1
					        if( client->GetUpPartCount() && theApp.glob_prefs->IsUploadPartsEnabled())		//Cax2 re-enabled toggle for progress bars
d394 1
a394 1
						        client->DrawUpStatusBar(dc,&cur_rec,false,theApp.glob_prefs->UseFlatBar());
d482 2
a483 2
			theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToUser((CUpDownClient*)client);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
d515 1
a515 1
				theApp.emuledlg->chatwnd.StartSession(client);
d518 1
a518 1
				theApp.friendlist->AddFriend(client);
d521 1
a521 1
				theApp.friendlist->RemoveFriend(client);
d543 1
a543 1
			theApp.emuledlg->transferwnd.PostMessage(WM_COMMAND, USRMSG_SWITCHUPLOADLIST, (long)m_hWnd);
d552 2
a553 2
	//theApp.uploadqueue->ResetClientPos();
	CUpDownClient* update = theApp.uploadqueue->GetNextClient(NULL);
d557 1
a557 1
		update = theApp.uploadqueue->GetNextClient(update);
d572 2
a573 2
	CKnownFile* file1 = theApp.sharedfiles->GetFileByID(item1->reqfileid);
	CKnownFile* file2 = theApp.sharedfiles->GetFileByID(item2->reqfileid);
d698 1
a698 1
	if ((theApp.uploadqueue == NULL) || !theApp.emuledlg->IsRunning() || !theApp.glob_prefs->GetUpdateQueueList())
d701 1
a701 1
	CUpDownClient* update = theApp.uploadqueue->GetNextClient(NULL);
d704 2
a705 2
		theApp.emuledlg->transferwnd.m_wndQueueList.RefreshClient(update);
		update = theApp.uploadqueue->GetNextClient(update);
d720 1
a720 1
		if (theApp.glob_prefs->GetDetailsOnClick())
d731 1
a731 1
			theApp.emuledlg->chatwnd.StartSession(client);
d748 2
a749 2
		theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToFile(NULL);
		theApp.emuledlg->transferwnd.UpdateInfoHeader();
d754 2
a755 2
		theApp.emuledlg->transferwnd.m_wndInfoList.SwitchToUser((CUpDownClient*) client);
		theApp.emuledlg->transferwnd.UpdateInfoHeader();
d795 1
a795 1
	if (theApp.emuledlg->IsRunning()){
@


1.45
log
@Fixed minor display/string issues
@
text
@d210 2
a211 1
	itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,0,0,0,1,(LPARAM)client);
d463 1
d789 35
@


1.44
log
@Chnaged SUI again to icon based
@
text
@d388 10
a424 10
				case 4:
					        if( client->GetUpPartCount() && theApp.glob_prefs->IsUploadPartsEnabled())		//Cax2 re-enabled toggle for progress bars
					        {
						        cur_rec.bottom--;
						        cur_rec.top++;
						        client->DrawUpStatusBar(dc,&cur_rec,false,theApp.glob_prefs->UseFlatBar());
						        cur_rec.bottom++;
						        cur_rec.top--;
					        }
					        break;
@


1.43
log
@SUI Clients are shown with a green name now instead of a check in the icon
@
text
@d315 4
a318 1
								imagelist.Draw(dc, 1, point, ILD_NORMAL);
d341 2
a342 2
						if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED)
							crOldTxtColor = dc->SetTextColor((COLORREF)RGB(0,130,0));								
d346 2
a347 2
						if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED)
							dc->SetTextColor(crOldTxtColor);				
@


1.42
log
@SecureIdent Support Mainly
Too many changes to mention here
@
text
@d333 1
a333 2
	                    if (client->credits->GetCurrentIdentState(client->GetIP()) == IS_IDENTIFIED)
							imagelist.Draw(dc, 11, point, ILD_TRANSPARENT);
d337 4
d342 4
@


1.41
log
@*** empty log message ***
@
text
@d88 1
a88 1

d330 1
a330 1
	                    else if (client->credits->GetScoreRatio() > 1)
d333 3
@


1.40
log
@*** empty log message ***
@
text
@d226 1
a226 1
	if(theApp.emuledlg->transferwnd.infolistctrl.GetType() == 1)
d228 1
a228 1
		if(theApp.emuledlg->transferwnd.infolistctrl.GetClient() == client)
d230 1
a230 1
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
d467 1
a467 1
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToUser((CUpDownClient*)client);
d689 1
a689 1
		theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(update);
d733 1
a733 1
		theApp.emuledlg->transferwnd.infolistctrl.SwitchToFile(NULL);
d739 1
a739 1
		theApp.emuledlg->transferwnd.infolistctrl.SwitchToUser((CUpDownClient*) client);
@


1.39
log
@speed optimization
@
text
@d26 3
d30 1
d512 5
a516 1
			case MP_DETAIL:{
d518 1
d707 3
d711 1
d713 3
a715 1
		} else {
@


1.38
log
@updated GUI graphic information about file status [psy]
@
text
@d54 1
d200 5
a204 3
void CQueueListCtrl::AddClient(CUpDownClient* client, bool reset){
	if (!::IsWindow(m_hWnd))
		return;
d207 6
a212 5
    if(reset == true) {
	client->SetWaitStartTime();
	client->SetAskedCount(1);
    }
	RefreshClient(client);
d219 3
d239 5
a243 5
void CQueueListCtrl::RefreshClient(CUpDownClient* client){

//Don't refresh during app shutdown [TwoBottle Mod]
	if (!::IsWindow(m_hWnd))
		return;
a250 1
		return;
@


1.37
log
@fixed crash at exit
@
text
@d79 4
a82 5
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         	// 7
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_UNKNOWN),16,16));  		// 8
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CDONKEY),16,16));  		// 9
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_LMULE),16,16));  			// 10
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_SHAREAZA),16,16));  		// 11
d289 1
a289 1
								imagelist.Draw(dc, 9, point, ILD_NORMAL);
d292 1
a292 1
								imagelist.Draw(dc, 10, point, ILD_NORMAL);
d295 1
a295 1
								imagelist.Draw(dc, 11, point, ILD_NORMAL);
d311 1
a311 1
								imagelist.Draw(dc, 8, point, ILD_NORMAL);
d316 6
a321 49
	                        if (client->IsBanned())
	                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
	                        else if (client->IsFriend())
	                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
	                        else if (client->credits->GetScoreRatio() > 1)
	                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);


	                    /*if(client->GetClientSoft() == SO_EDONKEYHYBRID) {
	                        imagelist.Draw(dc, 3, point, ILD_NORMAL);
	                        if (client->IsBanned())
	                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
	                        else if (client->IsFriend())
	                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
	                        else if (client->credits->GetScoreRatio() > 1)
	                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
	                    }
			            else if (client->GetClientSoft() == SO_MLDONKEY) {
	                        imagelist.Draw(dc, 2, point, ILD_NORMAL);
	                        if (client->IsBanned())
	                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
	                        else if (client->IsFriend())
	                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
	                        else if (client->credits->GetScoreRatio() > 1)
	                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
			            }
			            else if (client->GetClientSoft()==SO_EMULE || client->GetClientSoft()==SO_OLDEMULE) {
	                        imagelist.Draw(dc, 1, point, ILD_NORMAL);
	                        if (client->IsBanned())
	                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
	                        else if (client->IsFriend())
	                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
	                        else if (client->credits->GetScoreRatio() > 1)
	                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
	                    }
					    else {
	                        imagelist.Draw(dc, 0, point, ILD_NORMAL);
	                        if (client->IsBanned())
	                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
	                        else if (client->IsFriend())
	                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
	                        else if (client->credits->GetScoreRatio() > 1)
	                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
						}
	
	                    //if((client->GetClientSoft()==SO_EMULE) && (client->GetMuleVersion()==0x26)) {
	                    //    imagelist.Draw(dc, 7, point, ILD_TRANSPARENT);
	                    //}
						*/
@


1.36
log
@minor correction with JS output in SharedList
@
text
@d712 1
a712 1
	if (!theApp.emuledlg->IsRunning() || !theApp.glob_prefs->GetUpdateQueueList())
d714 1
a714 1

@


1.35
log
@jumpstart support in SharedList (output, sorting...)
@
text
@a397 2
								if (file->GetJumpstartEnabled())
									Sbuffer = GetResString(IDS_PRIOJUMPSTART);
@


1.34
log
@unicode cleanup
@
text
@d380 1
a380 1
							if(file){
d398 2
@


1.33
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d404 1
a404 1
							    Sbuffer.Format("%d/%d", client->GetAvailUpPartCount(), client->GetUpPartCount());
d406 1
a406 1
							    Sbuffer.Format("");
d410 1
a410 1
							Sbuffer.Format("%.1f",(float)client->GetScore(false,client->IsDownloading(),true));
d413 1
a413 1
							Sbuffer.Format("%i",client->GetScore(false));
d416 1
a416 1
							Sbuffer.Format("%i",(int)client->GetSmallFilePushRatio());		//Cax2 SF bugfix
d419 1
a419 1
							Sbuffer.Format("%.2f",client->GetRareFilePushRatio());			//Cax2 RF bugfix
d422 1
a422 1
							Sbuffer.Format("%i",client->GetAskedCount());
@


1.32
log
@converted to new logger methods
@
text
@d27 1
d261 1
d263 3
d456 1
d458 3
d781 1
d783 3
@


1.31
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d46 1
a46 1
		AddLogLine(false, GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.30
log
@minor fixes and improvements
@
text
@d98 1
@


1.29
log
@New icons for unknown, lmule cdonkey and shareaza clients
@
text
@d361 1
a361 1
	                    Sbuffer.Format("%s", client->GetUserName());
d369 1
a369 1
								Sbuffer.Format("%s", file->GetFileName());
d377 1
a377 1
										Sbuffer.Format("%s",GetResString(IDS_PRIORELEASE));		//Cax2 in sync with sharedfiles now
d380 1
a380 1
										Sbuffer.Format("%s",GetResString(IDS_PRIOHIGH));
d383 1
a383 1
										Sbuffer.Format("%s",GetResString(IDS_PRIOLOW));
d386 1
a386 1
										Sbuffer.Format("%s",GetResString(IDS_PRIOVERYLOW));
d389 1
a389 1
										Sbuffer.Format("%s",GetResString(IDS_PRIONORMAL));
d426 1
a426 1
								Sbuffer.Format("%s",GetResString(IDS_YES));
d428 1
a428 1
								Sbuffer.Format("%s",GetResString(IDS_NO));
d469 1
a469 1
	ON_NOTIFY_REFLECT (NM_RCLICK, OnNMRclick)
d478 1
a478 1
void CQueueListCtrl::OnNMRclick(NMHDR *pNMHDR, LRESULT *pResult)
d480 2
a481 2
	POINT point;
	::GetCursorPos(&point);	
d512 1
a512 1
	*pResult = 0;
@


1.28
log
@fix crash at exit
@
text
@d79 4
d281 39
a319 1
	                    if(client->GetClientSoft() == SO_EDONKEYHYBRID) {
d359 1
@


1.27
log
@various bugfixes for "friends"
@
text
@d195 2
@


1.27.2.1
log
@27a partial merge
@
text
@d257 1
a257 1
	CKnownFile* file = theApp.sharedfiles->GetFileByID(client->GetUploadFileID());
a420 19
//draw rectangle around selected item(s)
	if ((lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED))
	{
		RECT outline_rec;
		memcpy(&outline_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));

		outline_rec.top--;
		outline_rec.bottom++;
		dc->FrameRect(&outline_rec, &CBrush(GetBkColor()));
		outline_rec.top++;
		outline_rec.bottom--;
		outline_rec.left++;
		outline_rec.right--;

		if(bCtrlFocused)
			dc->FrameRect(&outline_rec, &CBrush(m_crFocusLine));
		else
			dc->FrameRect(&outline_rec, &CBrush(m_crNoFocusLine));
	}
d531 2
a532 2
	CKnownFile* file1 = theApp.sharedfiles->GetFileByID(item1->GetUploadFileID());
	CKnownFile* file2 = theApp.sharedfiles->GetFileByID(item2->GetUploadFileID());
@


1.27.2.2
log
@27c
@
text
@d197 1
a197 1
    if(reset) {
d443 1
a443 1
	ON_WM_CONTEXTMENU()
d452 5
a456 1
void CQueueListCtrl::OnContextMenu(CWnd* pWnd, CPoint point){
d486 1
@


1.26
log
@bugifx: bug #10
@
text
@d438 12
a449 2
	UINT flags=MF_STRING || MF_DISABLED;
	if (GetSelectionMark() != -1 && GetSelectedCount()>0) flags=MF_STRING;
d454 4
a457 1
	m_ClientMenu.AppendMenu(flags,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
d461 2
a464 12

	if(GetSelectionMark() != (-1)) // added by FoRcHa
	{
		const CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark());
		if(client)
		{
			theApp.emuledlg->transferwnd.infolistctrl.SwitchToUser((CUpDownClient*)client);
			theApp.emuledlg->transferwnd.UpdateInfoHeader();
			m_ClientMenu.EnableMenuItem(MP_UNBAN,((((CUpDownClient*)client)->IsBanned()) ? MF_ENABLED:MF_GRAYED)); //fix by Maverick
		}
	}
	
d475 1
a475 1
			case MP_SHOWLIST:{
d478 1
a478 2
			}
			case MP_MESSAGE:{
d481 1
a481 2
			}
			case MP_ADDFRIEND:{
d484 4
a487 2
			}
			case MP_UNBAN:{
a490 1
			}
@


1.25
log
@converted to new logging method
@
text
@d633 2
a635 2
			return item1->GetLastUpRequest() - item2->GetLastUpRequest();
		case 110: 
d637 2
a639 2
			return item1->GetWaitStartTime() - item2->GetWaitStartTime();
		case 111: 
@


1.24
log
@eMule priority set higher by default
@
text
@d46 1
a46 1
		theApp.emuledlg->AddLogLine(false, GetResString(IDS_ERR_TIMERCREATEFAILED));
@


1.23
log
@*** empty log message ***
@
text
@a243 1

@


1.22
log
@fix for some problems during app shutdown
@
text
@d250 1
a250 1
	dc.SelectObject(GetFont());
d421 1
d430 1
d709 28
@


1.21
log
@some sorting bugfixes
@
text
@d226 5
@


1.20
log
@Messages friend details working & solved context menu problems (Damn! we need a redesign of that). Now version 1b beta 1.
@
text
@d545 6
a550 1
			if( (file1 != NULL) && (file2 != NULL))
d552 1
d558 6
a563 1
			if( (file1 != NULL) && (file2 != NULL))
d565 1
@


1.19
log
@Updated conetext menus.
@
text
@d433 1
a433 1
	if (GetSelectionMark() != -1) flags=MF_STRING;
@


1.19.2.1
log
@v1a upgrade
@
text
@d433 1
a433 1
	if (GetSelectionMark() != -1 && GetSelectedCount()>0) flags=MF_STRING;
@


1.18
log
@the famous zz upload system! :)
@
text
@a82 11
	m_ClientMenu.CreatePopupMenu();
	m_ClientMenu.AddMenuTitle(GetResString(IDS_CLIENTS));
	m_ClientMenu.AppendMenu(MF_STRING,MP_DETAIL, GetResString(IDS_SHOWDETAILS));
	m_ClientMenu.AppendMenu(MF_STRING,MP_ADDFRIEND, GetResString(IDS_ADDFRIEND));
	m_ClientMenu.AppendMenu(MF_STRING,MP_MESSAGE, GetResString(IDS_SEND_MSG));
	m_ClientMenu.AppendMenu(MF_STRING,MP_SHOWLIST, GetResString(IDS_VIEWFILES));
	m_ClientMenu.AppendMenu(MF_STRING,MP_UNBAN, GetResString(IDS_UNBAN));
	m_ClientMenu.AppendMenu(MF_SEPARATOR);
	m_ClientMenu.AppendMenu(MF_STRING,MP_SWITCHCTRL, GetResString(IDS_VIEWUPLOADS));
	SetMenu(&m_ClientMenu);

d429 16
d447 7
a453 4
		const CUpDownClient* client = (CUpDownClient*)GetItemData(GetSelectionMark()); //nullpointer fix
		theApp.emuledlg->transferwnd.infolistctrl.SwitchToUser((CUpDownClient*)client);
		theApp.emuledlg->transferwnd.UpdateInfoHeader();
		m_ClientMenu.EnableMenuItem(MP_UNBAN,((((CUpDownClient*)client)->IsBanned()) ? MF_ENABLED:MF_GRAYED)); //fix by Maverick
d456 1
a456 2
	POINT point;
	::GetCursorPos(&point);	
d459 1
@


1.17
log
@enable sorting by upload progress
@
text
@d205 1
a205 1
void CQueueListCtrl::AddClient(CUpDownClient* client){
d208 1
d211 1
@


1.16
log
@minor updates & bugfixes
@
text
@d549 32
a580 1
		case 5: 
@


1.15
log
@Removed .26 icon modification (debug purpose not needed anymore)
@
text
@d391 1
a391 1
					        if( client->GetUpPartCount())
@


1.14
log
@Updated ListCtrls to new icon management to be more tidy and practical. Hope didn't broke anything.
@
text
@d244 2
a245 1
void CQueueListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct){
d248 1
d268 2
a269 1
	for(int iCurrent = 0; iCurrent < iCount; iCurrent++){
d271 2
a272 1
		if( !IsColumnHidden(iColumn) ){
d274 1
a274 4
			switch(iColumn){
/*
		case 4:
			if(ASK_FOR_PARTS_ON_UPLOAD)
d276 39
a314 105
				cur_rec.bottom--;
				cur_rec.top++;

				// added
				int iWidth = cur_rec.right - cur_rec.left-4; 
				int iHeight = cur_rec.bottom - cur_rec.top;
				if(iWidth>0)
				{
					CDC cdcStatus; 
					cdcStatus.CreateCompatibleDC(&dc); 
					CBitmap status, *poldbmp;
					status.CreateCompatibleBitmap(&dc, iWidth, iHeight); 
					status.SetBitmapDimension(iWidth, iHeight); 
					poldbmp = cdcStatus.SelectObject(&status); 

					RECT rec_status; 
					rec_status.left = 0; 
					rec_status.top = 0; 
					rec_status.bottom = iHeight; 
					rec_status.right = iWidth; 

					client->DrawStatusBar(&cdcStatus,  &rec_status, false, theApp.glob_prefs->UseFlatBar(), true);
					dc->BitBlt(cur_rec.left, cur_rec.top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
					cdcStatus.SelectObject(poldbmp);
				}
				//added end
				cur_rec.bottom++;
				cur_rec.top--;
			}
			break;
*/
		case 0:{
				    POINT point = {cur_rec.left, cur_rec.top+1};

                    if(client->GetClientSoft() == SO_EDONKEYHYBRID) {
                        imagelist.Draw(dc, 3, point, ILD_NORMAL);
                        if (client->IsBanned())
                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
                        else if (client->IsFriend())
                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
                        else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
                    }
		            else if (client->GetClientSoft() == SO_MLDONKEY) {
                        imagelist.Draw(dc, 2, point, ILD_NORMAL);
                        if (client->IsBanned())
                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
                        else if (client->IsFriend())
                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
                        else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
		            }
		            else if (client->GetClientSoft()==SO_EMULE || client->GetClientSoft()==SO_OLDEMULE) {
                        imagelist.Draw(dc, 1, point, ILD_NORMAL);
                        if (client->IsBanned())
                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
                        else if (client->IsFriend())
                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
                        else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
                    }
				    else {
                        imagelist.Draw(dc, 0, point, ILD_NORMAL);
                        if (client->IsBanned())
                            imagelist.Draw(dc, 6, point, ILD_TRANSPARENT);
                        else if (client->IsFriend())
                            imagelist.Draw(dc, 5, point, ILD_TRANSPARENT);
                        else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 4, point, ILD_TRANSPARENT);
					}

                    if((client->GetClientSoft()==SO_EMULE) && (client->GetMuleVersion()==0x26)) {
                        imagelist.Draw(dc, 7, point, ILD_TRANSPARENT);
                    }

                    Sbuffer.Format("%s", client->GetUserName());
					cur_rec.left +=20;
					dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS);
					cur_rec.left -=20;
					break;
    			}
		case 1:
					if(file)
						Sbuffer.Format("%s", file->GetFileName());
					else
						Sbuffer = "?";
					break;
		case 2:
					if(file){
						switch(file->GetPriority()){ 
							case PR_VERYHIGH:
								Sbuffer.Format("%s",GetResString(IDS_PRIORELEASE));		//Cax2 in sync with sharedfiles now
								break;
							case PR_HIGH: 
								Sbuffer.Format("%s",GetResString(IDS_PRIOHIGH));
								break; 
							case PR_LOW: 
								Sbuffer.Format("%s",GetResString(IDS_PRIOLOW));
								break; 
							case PR_VERYLOW:
								Sbuffer.Format("%s",GetResString(IDS_PRIOVERYLOW));
								break;
							default: 
								Sbuffer.Format("%s",GetResString(IDS_PRIONORMAL));
							break; 
d316 84
a399 47
					}
					else
						Sbuffer = "?";
					break;
		case 3:
					if( client->GetUpPartCount() ){
					    Sbuffer.Format("%d/%d", client->GetAvailUpPartCount(), client->GetUpPartCount());
                    } else {
					    Sbuffer.Format("");
                    }
                    break;
		case 5:
					Sbuffer.Format("%.1f",(float)client->GetScore(false,client->IsDownloading(),true));
					break;
		case 6:
					Sbuffer.Format("%i",client->GetScore(false));
					break;
		case 7:
					Sbuffer.Format("%i",(int)client->GetSmallFilePushRatio());		//Cax2 SF bugfix
					break;
		case 8:
					Sbuffer.Format("%.2f",client->GetRareFilePushRatio());			//Cax2 RF bugfix
					break;
		case 9:
					Sbuffer.Format("%i",client->GetAskedCount());
					break;
		case 10:
					Sbuffer = CastSecondsToHM((GetTickCount() - client->GetLastUpRequest())/1000);
					break;
		case 11:
					Sbuffer = CastSecondsToHM((GetTickCount() - client->GetWaitStartTime())/1000);
					break;
		case 12:
					if(client->IsBanned())
						Sbuffer.Format("%s",GetResString(IDS_YES));
					else
						Sbuffer.Format("%s",GetResString(IDS_NO));
					break;
		case 4:
			        if( client->GetUpPartCount()){
				        cur_rec.bottom--;
				        cur_rec.top++;
				        client->DrawUpStatusBar(dc,&cur_rec,false,theApp.glob_prefs->UseFlatBar());
				        cur_rec.bottom++;
				        cur_rec.top--;
			        }
			        break;
d401 1
a401 1
				if( iColumn != 4 && iColumn != 0)
@


1.13
log
@minor bugfixes + aqua bars! :)
@
text
@a27 1

d71 8
a78 21
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_NORMAL),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_COMPROT),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_PLUS),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_PLUSCOMPROT),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_TAROD),16,16)); // Added by Tarod
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_TARODPLUS),16,16)); // Added by Tarod
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED),16,16));                                                  // [i_a]
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNEDCOMPROT),16,16));                                           // [i_a]
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIENDCOMPROT),16,16));
	// By Maverick
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEY),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEYPLUS),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEYFRIEND),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MLDONKEYBANNED),16,16));
	// END Maverick
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  // 14
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));         // 15
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));         // 16
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         // 17
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));         // 18
d308 1
d310 1
a310 5
                        imagelist.Draw(dc, 14, point, ILD_NORMAL);
                        if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 15, point, ILD_TRANSPARENT);
                        if (client->IsFriend())
                            imagelist.Draw(dc, 16, point, ILD_TRANSPARENT);
d312 5
a316 1
                            imagelist.Draw(dc, 18, point, ILD_TRANSPARENT);
d319 26
a344 41
			            if (client->IsBanned())
                            imagelist.Draw(dc, 13, point, ILD_NORMAL);
			            else if (client->IsFriend())
                            imagelist.Draw(dc, 12, point, ILD_NORMAL);
			            else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 11, point, ILD_NORMAL);
			            else
                            imagelist.Draw(dc, 10, point, ILD_NORMAL);
		            } 
                    else if (client->IsFriend() && !client->ExtProtocolAvailable())
                        imagelist.Draw(dc, 8, point, ILD_NORMAL);
				    else if (client->IsFriend() && client->ExtProtocolAvailable())
                        imagelist.Draw(dc, 9, point, ILD_NORMAL);
				    else if (client->ExtProtocolAvailable())
				    {
        				    if (client->IsBanned())                                                  // [i_a] show banned people by icon; suggested in emule-project forum somewhere
                                imagelist.Draw(dc, 7, point, ILD_NORMAL);
					    else if (client->credits->GetScoreRatio() > 1)
					    {
						    if (client->TarodVersion())
						    {
                                imagelist.Draw(dc, 5, point, ILD_NORMAL);
						    } else {
                                imagelist.Draw(dc, 3, point, ILD_NORMAL);
						    }
					    } else {
						    if (client->TarodVersion())
						    {
                                imagelist.Draw(dc, 4, point, ILD_NORMAL);
						    } else {
                                imagelist.Draw(dc, 1, point, ILD_NORMAL);
						    }
					    }
				    } else {
					    if (client->IsBanned()) 
                            imagelist.Draw(dc, 6, point, ILD_NORMAL);
					    else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 2, point, ILD_NORMAL);
					    else
                            imagelist.Draw(dc, 0, point, ILD_NORMAL);
				    }
d347 1
a347 1
                        imagelist.Draw(dc, 17, point, ILD_TRANSPARENT);
a454 112
/*
	uint8 image;
	// By Maverick
	// Add MlDonkeyPicture
	if (client->ExtProtocolAvailable())
	{
        if (client->IsBanned())                                                  // [i_a] show banned people by icon; suggested in emule-project forum somewhere
			image = 7;
		else if (client->IsFriend())
			image = 9;
		else if (client->credits->GetScoreRatio() > 1)
		{
			if (client->TarodVersion())
			{
				image = 5;
			} else {
				image = 3;
			}
		} else {
			if (client->TarodVersion())
			{
				image = 4;
			} else {
				image = 1;
			}
		}
	} else {
		if (client->GetClientSoft() == SO_MLDONKEY)
		{
			if (client->IsBanned())                                                  // [i_a]
				image = 13;
			else if (client->IsFriend())
				image = 12;
			else if (client->credits->GetScoreRatio() > 1)
				image = 11;
			else
				image = 10;
		} else {
			if (client->IsBanned())                                                  // [i_a]
				image = 6;
			else if (client->IsFriend())
				image = 8;
			if (client->credits->GetScoreRatio() > 1)
				image = 2;
			else
				image = 0;
		}
	}
	// End Maverick
	SetItem(itemnr,0,LVIF_IMAGE,0,image,0,0,0,0);

	CKnownFile* file = theApp.sharedfiles->GetFileByID(client->reqfileid);
	if (file)
		SetItemText(itemnr,1,file->GetFileName());
	else
		SetItemText(itemnr,1,"?");
	if(file){
		switch(file->GetPriority()){ 
					case PR_VERYHIGH:
						sprintf(buffer,GetResString(IDS_PRIORELEASE));
						break;
					case PR_HIGH: 
						sprintf(buffer,GetResString(IDS_PRIOHIGH));
						break; 
					case PR_LOW: 
						sprintf(buffer,GetResString(IDS_PRIOLOW));
						break; 
					case PR_VERYLOW:
						sprintf(buffer,GetResString(IDS_PRIOVERYLOW));
						break;
					default: 
						sprintf(buffer,GetResString(IDS_PRIONORMAL));
					break; 
		}
	}
	else
		sprintf(buffer,"?");
	SetItemText(itemnr,2,buffer);

	// UUU
	sprintf(buffer,"%d/%d", client->GetUpAvailPartCount(), client->GetUpPartCount());
	SetItemText(itemnr,3,buffer);

	sprintf(buffer,"%.1f",(float)client->GetScore(false,client->IsDownloading(),true));
	SetItemText(itemnr,5,buffer);
	sprintf(buffer,"%i",client->GetScore(false));
	SetItemText(itemnr,6,buffer);

	// Added by Tarod for push ratios
	sprintf(buffer, "%.1f", client->GetSmallFilePushRatio()) ;
	SetItemText(itemnr,7,buffer);
	sprintf(buffer, "%.1f", client->GetRareFilePushRatio()) ;
	SetItemText(itemnr, 8, buffer) ;
	// End added by Tarod

	if( newclient ){
		_strtime( ttmpbuf );
		_strdate( dtmpbuf );
		sprintf( buffer, "%s %s", dtmpbuf, ttmpbuf );
		SetItemText(itemnr,11,buffer);
	}
	if(client->IsBanned())
		sprintf(buffer,GetResString(IDS_YES));

	else
		sprintf(buffer,GetResString(IDS_NO));
	SetItemText(itemnr,12,buffer);
	client->SetUpStartTime();
}

*/

a462 1

d521 1
a521 1
//	theApp.uploadqueue->ResetClientPos();
@


1.12
log
@SF & RF ratios bugfixed, added 'type' options to filedonkey search
@
text
@d394 1
a394 1
								Sbuffer.Format("%s",GetResString(IDS_PRIOVERYHIGH));
@


1.11
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d427 1
a427 1
					Sbuffer.Format("%i",client->GetSmallFilePushRatio());
d430 1
a430 1
					Sbuffer.Format("%i",client->GetRareFilePushRatio());
d729 1
a729 1
		case 7: //speed asc
d731 1
a731 1
		case 107: //speed desc
d733 1
a733 1
		case 8: //speed asc
d735 1
a735 1
		case 108: //speed desc
@


1.10
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d380 1
a380 1
					dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER);
d458 1
a458 1
				dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER);
@


1.9
log
@bugifxes & improvements
@
text
@d28 7
@


1.8
log
@Show the number of remote client's parts
@
text
@d256 1
a256 8
	if( (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED )){
		if(bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
	}
	else
		odc->SetBkColor(GetBkColor());
d453 1
d455 18
d474 1
a474 1
	}
@


1.7
log
@Hotfixes.
@
text
@d414 5
a418 2
                    // MERGE26
                    Sbuffer = "N/A";
@


1.6
log
@.26b port
@
text
@d433 1
a433 1
					Sbuffer.Format("%s",CastSecondsToHM((GetTickCount() - client->GetLastUpRequest())/1000));
d436 1
a436 1
					Sbuffer.Format("%s", CastSecondsToHM((GetTickCount() - client->GetWaitStartTime())/1000));
@


1.5
log
@merge with a branch fixes
@
text
@a272 1
	char buffer[100];
d433 1
a433 2
					CastSecondsToHM((::GetTickCount() - client->GetLastUpRequest())/1000, buffer);
					Sbuffer.Format("%s", buffer );
d436 1
a436 2
					CastSecondsToHM((::GetTickCount() - client->GetWaitStartTime())/1000, buffer);
					Sbuffer.Format("%s", buffer );
@


1.4
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d52 2
a53 2
	InsertColumn(3,GetResString(IDS_UP_PARTS),LVCFMT_LEFT,110,3); // UUU
	InsertColumn(4,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT,110,4); // UUU
@


1.3
log
@Updates to Preferences (and enabling/disabling options in code because of that)
@
text
@d44 4
d64 1
a64 1
	imagelist.SetBkColor(RGB(255,255,255));
d81 6
d126 1
a126 1
		RefreshClient( update, false);
d214 1
a214 1
	itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,client->GetUserName(),0,0,1,(LPARAM)client);
d217 1
a217 1
	RefreshClient(client, true, true);
d241 1
a241 1
void CQueueListCtrl::RefreshClient(CUpDownClient* client, bool updatetime, bool newclient){
d245 8
a252 2
	sint32 itemnr = FindItem(&find);
	if (itemnr == (-1))
d254 19
d274 186
a459 9
	char dtmpbuf[128];
	char ttmpbuf[128];
	sprintf(buffer,"%i",client->GetAskedCount());
	SetItemText(itemnr,9,buffer);
	if( updatetime && !client->IsBanned()){
	    _strtime( ttmpbuf );
		_strdate( dtmpbuf );
		sprintf( buffer, "%s %s", dtmpbuf, ttmpbuf );
		SetItemText(itemnr,10,buffer);
a460 3
	else if( updatetime ){
		sprintf( buffer, "--" );
		SetItemText(itemnr,9,buffer);
a461 2
	else if( client->IsBanned()){
		return; //Now if you get a very bad client, it will only update the count.. Not everything else to save cpu.
d464 1
d574 2
a583 158
// UUU
#define DLC_DT_TEXT (DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_NOPREFIX|DT_END_ELLIPSIS)

void CQueueListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
	if (!lpDrawItemStruct->itemData)
		return;

	CUpDownClient* client=((CUpDownClient*)lpDrawItemStruct->itemData);

	CDC* odc = CDC::FromHandle(lpDrawItemStruct->hDC);

	// background
	BOOL bCtrlFocused = ((GetFocus() == this));

	COLORREF crOldBkColor;
	if((lpDrawItemStruct->itemAction | ODA_SELECT) &&
		(lpDrawItemStruct->itemState & ODS_SELECTED)) 
	{
		if(bCtrlFocused)
			crOldBkColor = odc->SetBkColor(m_crHighlight);
		else
			crOldBkColor = odc->SetBkColor(m_crNoHighlight);

	}  
	else
		crOldBkColor = odc->SetBkColor(GetBkColor());

	CMemDC dc(odc, &CRect(lpDrawItemStruct->rcItem));
	CFont *pOldFont = dc->SelectObject(GetFont());
	COLORREF crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));

	RECT cur_rec;
	memcpy(&cur_rec, &lpDrawItemStruct->rcItem, sizeof(RECT));

	//--- all 0.. columns ---
	for(int c=0; c<ColumnsTracked(); c++)
	{
		//--- get real column, may its moved ---
		int cc=GetColumnColumn(c);

		//--- if the column is hidden, dont do anything ---
		if(IsColumnHidden(cc))
			continue;

 		if(c)
			cur_rec.left = cur_rec.right;
		cur_rec.right = cur_rec.left + GetColumnWidth(cc);
		cur_rec.left += 4;

		//--- 0..8 are the emule classic columns ---
		switch(cc)
		{
		case 4:
			if(ASK_FOR_PARTS_ON_UPLOAD)
			{
				cur_rec.bottom--;
				cur_rec.top++;

				// added
				int iWidth = cur_rec.right - cur_rec.left-4; 
				int iHeight = cur_rec.bottom - cur_rec.top;
				if(iWidth>0)
				{
					CDC cdcStatus; 
					cdcStatus.CreateCompatibleDC(&dc); 
					CBitmap status, *poldbmp;
					status.CreateCompatibleBitmap(&dc, iWidth, iHeight); 
					status.SetBitmapDimension(iWidth, iHeight); 
					poldbmp = cdcStatus.SelectObject(&status); 

					RECT rec_status; 
					rec_status.left = 0; 
					rec_status.top = 0; 
					rec_status.bottom = iHeight; 
					rec_status.right = iWidth; 

					client->DrawStatusBar(&cdcStatus,  &rec_status, false, theApp.glob_prefs->UseFlatBar(), true);
					dc->BitBlt(cur_rec.left, cur_rec.top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
					cdcStatus.SelectObject(poldbmp);
				}
				//added end
				cur_rec.bottom++;
				cur_rec.top--;
			}
			break;
		case 0:
			{
				POINT point = {cur_rec.left, cur_rec.top+1};
				uint8 image;
				if (client->IsFriend() && !client->ExtProtocolAvailable())
					image = 8;
				else if (client->IsFriend() && client->ExtProtocolAvailable())
					image = 9;
				else if (client->ExtProtocolAvailable())
				{
        				if (client->IsBanned())                                                  // [i_a] show banned people by icon; suggested in emule-project forum somewhere
						image = 7;
					else if (client->credits->GetScoreRatio() > 1)
					{
						if (client->TarodVersion())
						{
							image = 5;
						} else {
							image = 3;
						}
					} else {
						if (client->TarodVersion())
						{
							image = 4;
						} else {
							image = 1;
						}
					}
				} else {
					if (client->IsBanned()) 
						image = 6;
					else if (client->credits->GetScoreRatio() > 1)
						image = 2;
					else
						image = 0;
				}
				imagelist.Draw(dc, image, point, ILD_NORMAL);
				cur_rec.left += 20;
			}
			// fall through !!!!!!!!!!!!
/*
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
		case 8:
*/
		default:
			dc->DrawText(GetItemText(lpDrawItemStruct->itemID, cc), -1, &cur_rec, DLC_DT_TEXT);
			break;
		}
	}

	//--- draw rectangle around selected item ---
	if(lpDrawItemStruct->itemState & ODS_FOCUS)
	{
		RECT focus_rec;
		focus_rec.top    = lpDrawItemStruct->rcItem.top;
		focus_rec.bottom = lpDrawItemStruct->rcItem.bottom;
		focus_rec.left   = lpDrawItemStruct->rcItem.left + 1;
		focus_rec.right  = lpDrawItemStruct->rcItem.right - 1;
		dc->FrameRect(&focus_rec, &CBrush(m_crNoFocusLine));
	}

	// restore the dc before destroying it:
	dc->SelectObject(pOldFont);			
	dc->SetTextColor(crOldTxtColor);
	dc->SetBkColor(crOldBkColor);
}

d647 1
a647 1
		RefreshClient( update, false);
@


1.3.2.1
log
@initial upgrade to .26
@
text
@a75 3

    //    imagelist.Add(theApp.LoadIcon(IDI_EDONKEYHYBRID)); // MERGE26

d116 1
a116 1
		RefreshClient( update);
d122 2
a123 1
void CQueueListCtrl::Localize() {
d204 1
a204 1
	itemnr = InsertItem(LVIF_TEXT|LVIF_PARAM,itemnr,0,0,0,1,(LPARAM)client);
d207 1
a207 1
	RefreshClient(client);
d212 2
a213 1
void CQueueListCtrl::RemoveClient(CUpDownClient* client){
d227 1
a227 1
	if (result != (-1) )
d231 1
a231 1
void CQueueListCtrl::RefreshClient(CUpDownClient* client){
d235 2
a236 8
	sint16 result = FindItem(&find);
	if(result != -1)
		Update(result);
        return;
}

void CQueueListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct){
	if (!lpDrawItemStruct->itemData)
d238 14
a251 7
	CDC* odc = CDC::FromHandle(lpDrawItemStruct->hDC);
	BOOL bCtrlFocused = ((GetFocus() == this ) || (GetStyle() & LVS_SHOWSELALWAYS));
	if( (lpDrawItemStruct->itemAction | ODA_SELECT) && (lpDrawItemStruct->itemState & ODS_SELECTED )){
		if(bCtrlFocused)
			odc->SetBkColor(m_crHighlight);
		else
			odc->SetBkColor(m_crNoHighlight);
d253 2
a254 170
	else
		odc->SetBkColor(GetBkColor());
	CUpDownClient* client = (CUpDownClient*)lpDrawItemStruct->itemData;
	CMemDC dc(CDC::FromHandle(lpDrawItemStruct->hDC),&CRect(lpDrawItemStruct->rcItem));
	dc.SelectObject(GetFont());
	COLORREF crOldTxtColor = dc->SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
        COLORREF crOldBkColor = dc->GetBkColor();
	RECT cur_rec;
	memcpy(&cur_rec,&lpDrawItemStruct->rcItem,sizeof(RECT));

	CString Sbuffer;
	char buffer[100];

	CKnownFile* file = theApp.sharedfiles->GetFileByID(client->reqfileid);
	CHeaderCtrl *pHeaderCtrl = GetHeaderCtrl();
	int iCount = pHeaderCtrl->GetItemCount();
	cur_rec.right = cur_rec.left - 8;
	cur_rec.left += 4;

	for(int iCurrent = 0; iCurrent < iCount; iCurrent++){
		int iColumn = pHeaderCtrl->OrderToIndex(iCurrent);
		if( !IsColumnHidden(iColumn) ){
			cur_rec.right += GetColumnWidth(iColumn);
			switch(iColumn){
/*
		case 4:
			if(ASK_FOR_PARTS_ON_UPLOAD)
			{
				cur_rec.bottom--;
				cur_rec.top++;

				// added
				int iWidth = cur_rec.right - cur_rec.left-4; 
				int iHeight = cur_rec.bottom - cur_rec.top;
				if(iWidth>0)
				{
					CDC cdcStatus; 
					cdcStatus.CreateCompatibleDC(&dc); 
					CBitmap status, *poldbmp;
					status.CreateCompatibleBitmap(&dc, iWidth, iHeight); 
					status.SetBitmapDimension(iWidth, iHeight); 
					poldbmp = cdcStatus.SelectObject(&status); 

					RECT rec_status; 
					rec_status.left = 0; 
					rec_status.top = 0; 
					rec_status.bottom = iHeight; 
					rec_status.right = iWidth; 

					client->DrawStatusBar(&cdcStatus,  &rec_status, false, theApp.glob_prefs->UseFlatBar(), true);
					dc->BitBlt(cur_rec.left, cur_rec.top, iWidth, iHeight,  &cdcStatus, 0, 0, SRCCOPY); 
					cdcStatus.SelectObject(poldbmp);
				}
				//added end
				cur_rec.bottom++;
				cur_rec.top--;
			}
			break;
*/
		case 0:{
				uint8 image;
				if (client->IsFriend() && !client->ExtProtocolAvailable())
					image = 8;
				else if (client->IsFriend() && client->ExtProtocolAvailable())
					image = 9;
				else if (client->ExtProtocolAvailable())
				{
        				if (client->IsBanned())                                                  // [i_a] show banned people by icon; suggested in emule-project forum somewhere
						image = 7;
					else if (client->credits->GetScoreRatio() > 1)
					{
						if (client->TarodVersion())
						{
							image = 5;
						} else {
							image = 3;
						}
					} else {
						if (client->TarodVersion())
						{
							image = 4;
						} else {
							image = 1;
						}
					}
				} else {
					if (client->IsBanned()) 
						image = 6;
					else if (client->credits->GetScoreRatio() > 1)
						image = 2;
					else
						image = 0;
				}
				POINT point = {cur_rec.left, cur_rec.top+1};
				imagelist.Draw(dc, image, point, ILD_NORMAL);
					Sbuffer.Format("%s", client->GetUserName());
					cur_rec.left +=20;
					dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER);
					cur_rec.left -=20;
					break;
			}
		case 1:
					if(file)
						Sbuffer.Format("%s", file->GetFileName());
					else
						Sbuffer = "?";
					break;
		case 2:
					if(file){
						switch(file->GetPriority()){ 
							case PR_VERYHIGH:
								Sbuffer.Format("%s",GetResString(IDS_PRIOVERYHIGH));
								break;
							case PR_HIGH: 
								Sbuffer.Format("%s",GetResString(IDS_PRIOHIGH));
								break; 
							case PR_LOW: 
								Sbuffer.Format("%s",GetResString(IDS_PRIOLOW));
								break; 
							case PR_VERYLOW:
								Sbuffer.Format("%s",GetResString(IDS_PRIOVERYLOW));
								break;
							default: 
								Sbuffer.Format("%s",GetResString(IDS_PRIONORMAL));
							break; 
						}
					}
					else
						Sbuffer = "?";
					break;
		case 3:
                      // MERGE26
                      break;
		case 5:
					Sbuffer.Format("%.1f",(float)client->GetScore(false,false,true));
					break;
		case 6:
					Sbuffer.Format("%i",client->GetScore(false));
					break;
		case 7:
					Sbuffer.Format("%i",client->GetAskedCount());
					break;
		case 8:
					CastSecondsToHM((::GetTickCount() - client->GetLastUpRequest())/1000, buffer);
					Sbuffer.Format("%s", buffer );
					break;
		case 9:
					CastSecondsToHM((::GetTickCount() - client->GetWaitStartTime())/1000, buffer);
					Sbuffer.Format("%s", buffer );
					break;
		case 10:
					if(client->IsBanned())
						Sbuffer.Format("%s",GetResString(IDS_YES));
					else
						Sbuffer.Format("%s",GetResString(IDS_NO));
					break;
				case 4:
					if( client->GetUpPartCount()){
						cur_rec.bottom--;
						cur_rec.top++;
						client->DrawUpStatusBar(dc,&cur_rec,false,false);
						cur_rec.bottom++;
						cur_rec.top--;
					}
					break;
					   }
				if( iColumn != 4 && iColumn != 0)
				dc->DrawText(Sbuffer,Sbuffer.GetLength(),&cur_rec,DT_LEFT|DT_SINGLELINE|DT_VCENTER);
			cur_rec.left += GetColumnWidth(iColumn);
		}
a255 1
}
a256 1
/*
a365 2
*/

d374 158
d534 2
a535 1
void CQueueListCtrl::OnNMRclick(NMHDR *pNMHDR, LRESULT *pResult){	
d595 1
a595 1
		RefreshClient( update);
@


1.3.2.2
log
@Fixing list controls, adding support for eDonkey Hybrid
@
text
@d44 1
a44 5
	CImageList ilDummyImageList;
	ilDummyImageList.Create(1, 17,ILC_COLOR32 | ILC_MASK, 1, 1); 
	SetImageList(&ilDummyImageList, LVSIL_SMALL);

    SetExtendedStyle(LVS_EX_FULLROWSELECT);
d48 2
a49 2
	InsertColumn(3,GetResString(IDS_UP_PARTS),LVCFMT_LEFT,110,3);
	InsertColumn(4,GetResString(IDS_DL_PROGRESS),LVCFMT_LEFT,110,4);
d60 1
a60 1
	imagelist.SetBkColor(CLR_NONE);
d76 3
d80 1
a80 7
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_EDONKEYHYBRID),16,16));  // 14
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CREDIT_ONLY),16,16));         // 15
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_FRIEND_ONLY),16,16));         // 16
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_26_ONLY),16,16));         // 17
    imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_BANNED_ONLY),16,16));         // 18

    LoadImgLstIcon(NULL,0,0);	// delete temp-icon
d256 1
a256 1
	CMemDC dc(odc,&CRect(lpDrawItemStruct->rcItem));
d259 1
a259 1
    COLORREF crOldBkColor = dc->GetBkColor();
d313 36
a348 58
				    POINT point = {cur_rec.left, cur_rec.top+1};
                    if(client->GetClientSoft() == SO_EDONKEYHYBRID) {
                        imagelist.Draw(dc, 14, point, ILD_NORMAL);
                        if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 15, point, ILD_TRANSPARENT);
                        if (client->IsFriend())
                            imagelist.Draw(dc, 16, point, ILD_TRANSPARENT);
                        if (client->IsBanned())
                            imagelist.Draw(dc, 18, point, ILD_TRANSPARENT);
                    }
		            else if (client->GetClientSoft() == SO_MLDONKEY) {
			            if (client->IsBanned())
                            imagelist.Draw(dc, 13, point, ILD_NORMAL);
			            else if (client->IsFriend())
                            imagelist.Draw(dc, 12, point, ILD_NORMAL);
			            else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 11, point, ILD_NORMAL);
			            else
                            imagelist.Draw(dc, 10, point, ILD_NORMAL);
		            } 
                    else if (client->IsFriend() && !client->ExtProtocolAvailable())
                        imagelist.Draw(dc, 8, point, ILD_NORMAL);
				    else if (client->IsFriend() && client->ExtProtocolAvailable())
                        imagelist.Draw(dc, 9, point, ILD_NORMAL);
				    else if (client->ExtProtocolAvailable())
				    {
        				    if (client->IsBanned())                                                  // [i_a] show banned people by icon; suggested in emule-project forum somewhere
                                imagelist.Draw(dc, 7, point, ILD_NORMAL);
					    else if (client->credits->GetScoreRatio() > 1)
					    {
						    if (client->TarodVersion())
						    {
                                imagelist.Draw(dc, 5, point, ILD_NORMAL);
						    } else {
                                imagelist.Draw(dc, 3, point, ILD_NORMAL);
						    }
					    } else {
						    if (client->TarodVersion())
						    {
                                imagelist.Draw(dc, 4, point, ILD_NORMAL);
						    } else {
                                imagelist.Draw(dc, 1, point, ILD_NORMAL);
						    }
					    }
				    } else {
					    if (client->IsBanned()) 
                            imagelist.Draw(dc, 6, point, ILD_NORMAL);
					    else if (client->credits->GetScoreRatio() > 1)
                            imagelist.Draw(dc, 2, point, ILD_NORMAL);
					    else
                            imagelist.Draw(dc, 0, point, ILD_NORMAL);
				    }

                    if((client->GetClientSoft()==SO_EMULE) && (client->GetMuleVersion()==0x26)) {
                        imagelist.Draw(dc, 17, point, ILD_TRANSPARENT);
                    }

                    Sbuffer.Format("%s", client->GetUserName());
d353 1
a353 1
    			}
d384 2
a385 3
                    // MERGE26
                    Sbuffer = "N/A";
                    break;
d409 10
a418 10
		case 4:
			        if( client->GetUpPartCount()){
				        cur_rec.bottom--;
				        cur_rec.top++;
				        client->DrawUpStatusBar(dc,&cur_rec,false,false);
				        cur_rec.bottom++;
				        cur_rec.top--;
			        }
			        break;
			}
@


1.3.2.3
log
@further fixes
@
text
@d417 1
a417 1
					Sbuffer.Format("%.1f",(float)client->GetScore(false,client->IsDownloading(),true));
d423 1
a423 1
					Sbuffer.Format("%i",client->GetSmallFilePushRatio());
a425 6
					Sbuffer.Format("%i",client->GetRareFilePushRatio());
					break;
		case 9:
					Sbuffer.Format("%i",client->GetAskedCount());
					break;
		case 10:
d429 1
a429 1
		case 11:
d433 1
a433 1
		case 12:
d443 1
a443 1
				        client->DrawUpStatusBar(dc,&cur_rec,false,theApp.glob_prefs->UseFlatBar());
@


1.2
log
@*** empty log message ***
@
text
@d33 8
d100 8
a107 1
CQueueListCtrl::~CQueueListCtrl(){
d689 16
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.2.2.2
log
@updated control panes, and assorted bugfixes
@
text
@a32 8

	// Barry - Refresh the queue every 10 secs
	m_hTimer = ::SetTimer(NULL,				// Window to associate with
						NULL,				// ID of timer (ignored if window = null)
						30000,				// Time out duration
						(TIMERPROC)CQueueListCtrl::QueueUpdateTimer);	// Proc to run
	if (!m_hTimer)
		theApp.emuledlg->AddLogLine(false, GetResString(IDS_ERR_TIMERCREATEFAILED));
d92 1
a92 8
CQueueListCtrl::~CQueueListCtrl()
{
	// Barry - Kill the timer that was created
	try
	{
		if (m_hTimer)
			::KillTimer(NULL, m_hTimer);
	} catch (...) {}
a673 16

// Barry - Refresh the queue every 10 secs
void CALLBACK CQueueListCtrl::QueueUpdateTimer(HWND hwnd, UINT uiMsg, UINT idEvent, DWORD dwTime)
{
	// Don't do anything if the app is shutting down - can cause unhandled exceptions
	if (!theApp.emuledlg->IsRunning() || !theApp.glob_prefs->GetUpdateQueueList())
		return;

	CUpDownClient* update = theApp.uploadqueue->GetNextClient(NULL);
	while( update )
	{
		theApp.emuledlg->transferwnd.queuelistctrl.RefreshClient(update);
		update = theApp.uploadqueue->GetNextClient(update);
	}
}

@


1.1
log
@*** empty log message ***
@
text
@d63 6
d243 3
a245 5
	if (client->IsFriend() && !client->ExtProtocolAvailable())
		image = 8;
	else if (client->IsFriend() && client->ExtProtocolAvailable())
		image = 9;
	else if (client->ExtProtocolAvailable())
d247 1
a247 1
        	if (client->IsBanned())                                                  // [i_a] show banned people by icon; suggested in emule-project forum somewhere
d249 2
d268 20
a287 6
		if (client->IsBanned())                                                  // [i_a]
			image = 6;
		else if (client->credits->GetScoreRatio() > 1)
			image = 2;
		else
			image = 0;
d289 1
@

