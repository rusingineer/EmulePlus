head	1.225;
access;
symbols
	PublicRelease_1_2e:1.224
	Interim_Release_1-2e_RC1:1.224
	PublicRelease_1_2d:1.222
	Interim_Release_1-2d_RC1:1.222
	Interim_Release_1-2d_beta1:1.221
	PublicRelease_1_2c:1.212
	Interim_Release_1-2c_RC1:1.212
	Interim_Release_1-2c_beta1:1.208
	PublicRelease_1_2b:1.208
	Interim_Release_1-2b_RC1:1.208
	PublicRelease_1_2a:1.206
	Interim_Release_1-2a_RC1:1.206
	Interim_Release_1-2a_beta2:1.202
	Interim_Release_1-2a_beta1:1.192
	PublicRelease_1_2:1.186
	Interim_Release_1-2_RC1:1.186
	Interim_Release_1-2_beta1:1.183
	PublicRelease_1_1g:1.182
	Interim_Release_1-1g_RC3:1.182
	Interim_Release_1-1g_RC2:1.182
	Interim_Release_1-1g_RC1:1.182
	Interim_Release_1-1g_beta2:1.182
	Interim_Release_1-1g_beta1:1.170
	PublicRelease_1_1f:1.169
	Interim_Release_1-1f_RC1:1.169
	PublicRelease_1_1e:1.168
	Interim_Release_1-1e_RC2:1.168
	Interim_Release_1-1e_RC1:1.167
	Interim_Release_1-1e_beta1:1.167
	PublicRelease_1_1d:1.165
	Interim_Release_1-1d_RC1:1.165
	PublicRelease_1_1c:1.165
	Interim_Release_1-1c_RC1:1.165
	Interim_Release_1-1c_beta2:1.164
	Interim_Release_1-1c_beta1:1.161
	PublicRelease_1_1b:1.160
	Interim_Release_1-1b_RC1:1.160
	PublicRelease_1_1a:1.158
	Interim_Release_1-1a_RC2:1.156
	Interim_Release_1-1a_RC1:1.155
	Interim_Release_1-1a_beta2:1.154
	Interim_Release_1-1a_beta1:1.152
	PublicRelease_1_1:1.149
	Interim_Release_1-1_beta1:1.149
	PublicRelease_1o:1.145
	Interim_Release_1o_RC1:1.145
	Interim_Release_1o_beta1:1.145
	PublicRelease_1n:1.145
	Interim_Release_1n_RC2:1.145
	Interim_Release_1n_RC1:1.144
	Interim_Release_1n_beta2:1.135
	Interim_Release_1n_beta1:1.134
	PublicRelease_1m:1.122
	Interim_Release_1m_beta1:1.122
	PublicRelease_1l:1.122
	Interim_Release_1l_RC3:1.122
	Interim_Release_1l_RC2:1.122
	Interim_Release_1l_RC1:1.116
	Interim_Release_1l_beta2:1.114
	Interim_Release_1l_beta1:1.114
	PublicRelease_1k:1.107
	Interim_Release_1k_RC4:1.106
	Interim_1k_RC3:1.105
	Interim_1k_RC2:1.105
	Interim_Release_1k_RC1:1.105
	Interim_Release_1k_beta5:1.104
	Intrerim_Release_1k_beta4:1.104
	Interim_Release_1k_beta1:1.102
	PublicRelease_1j:1.94
	Interim_Release_1J_RC3:1.94
	Interim_Release_1j_RC3:1.94
	Interim_Release_1j_RC2:1.91
	Interim_Release_1j_RC1:1.90
	Interim_Release_1j_beta2:1.90
	Interim_Release_1j_beta1:1.90
	PublicRelease_1i:1.90
	Interim_Release_1i_RC6:1.90
	Interim_Release_1i_RC3:1.90
	Interim_Release_1i_RC2:1.90
	Interim_Release_1i_RC1:1.89
	Interim_Release_1i_beta3:1.88
	Interim_Release_1i_beta2:1.83
	Interim_Release_1i_beta1:1.79
	PublicRelease_1h:1.66
	Interim_Release_1h_rc2:1.66
	Interim_Release_1h_RC1:1.66
	Interim_Release_1h_beta2:1.64
	Interim_Release_1h_beta1_now:1.61
	Interim_Release_1h_beta1:1.61
	PublicRelease_1g:1.56
	Interim_Release_1g_RC6_Final:1.56
	Interim_Release_1g_RC6:1.55
	Interim_Release_1g_RC5:1.54
	Interim_Release_1g_RC4:1.52
	Interim_Release_1g_RC3:1.49
	Interim_Release_1g_beta2:1.36
	Interim_Release_1g_beta1:1.32
	Interim_Release_1f_RC4:1.29
	Interim_Release_1f_RC3:1.29
	Interim_Release_1f_RC2:1.27
	Interim_Release_1f_RC:1.27
	Interim_Release_1f_beta2:1.26
	Interim_Release_1f_beta1:1.26
	PublicRelease_1e:1.23
	Interim_Release_1e_RC2:1.23
	Interim_Release_1e_RC:1.23
	Interim_Release_1e_beta3:1.23
	Interim_Release_1e_beta2:1.23
	Interim_Release_1e_beta2_before_kuchin:1.23
	Interim_Release_1e_beta1:1.23
	PublicRelease_1c:1.21
	featurestest:1.21.0.2
	Interim_Release_1c_RC:1.21
	Interim_Release_1c_beta2:1.21
	Interim_Release_1c_beta1:1.18
	threaded_downloadqueue:1.18.0.2
	PublicRelease_1b:1.15
	Interim_Release_1b_beta2:1.15
	Interim_Release_1b_beta1:1.14
	proxydeadlake:1.13.0.2
	PublicRelease_1a:1.13
	Interim_Release_1a_beta2:1.13
	BerkeleyDb:1.12.0.2
	Interim_Release_1a_beta1:1.12
	PublicRelease_1:1.12
	goldfish:1.12
	eMulePlus_1_RC2:1.12
	eMulePlus_26b_1RC1:1.12
	PreRelease_26b_i0e:1.12
	before_26d_merge:1.8
	Interim_Release_26b_i0d:1.8
	Interim_Release_26b_i0c:1.7
	Interim_Release_26b_i0b:1.7
	Interim_Release_26b_i0a:1.7
	systraydlg:1.4.0.4
	plus26based:1.4.0.2
	Interim_Release_25b_i0b:1.4
	Proxy_Dev:1.3
	Interim_Release_25b_i0a:1.3.2.1
	proxytest:1.3.2.1.0.2
	official_sockets:1.3.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.225
date	2009.06.02.02.19.55;	author aw3;	state Exp;
branches;
next	1.224;

1.224
date	2008.11.24.03.13.33;	author aw3;	state Exp;
branches;
next	1.223;

1.223
date	2008.11.19.13.59.29;	author aw3;	state Exp;
branches;
next	1.222;

1.222
date	2008.03.03.05.26.17;	author aw3;	state Exp;
branches;
next	1.221;

1.221
date	2007.11.13.22.12.39;	author kush_eplus;	state Exp;
branches;
next	1.220;

1.220
date	2007.11.12.23.49.44;	author fuxie-dk;	state Exp;
branches;
next	1.219;

1.219
date	2007.11.02.14.40.26;	author kush_eplus;	state Exp;
branches;
next	1.218;

1.218
date	2007.10.31.18.18.52;	author fuxie-dk;	state Exp;
branches;
next	1.217;

1.217
date	2007.10.15.18.36.52;	author fuxie-dk;	state Exp;
branches;
next	1.216;

1.216
date	2007.10.12.21.35.11;	author double_t;	state Exp;
branches;
next	1.215;

1.215
date	2007.10.11.18.09.07;	author fuxie-dk;	state Exp;
branches;
next	1.214;

1.214
date	2007.10.03.18.09.18;	author eklmn;	state Exp;
branches;
next	1.213;

1.213
date	2007.09.27.14.28.27;	author fuxie-dk;	state Exp;
branches;
next	1.212;

1.212
date	2007.08.04.01.21.32;	author aw3;	state Exp;
branches;
next	1.211;

1.211
date	2007.06.04.01.32.15;	author aw3;	state Exp;
branches;
next	1.210;

1.210
date	2007.06.01.04.49.26;	author aw3;	state Exp;
branches;
next	1.209;

1.209
date	2007.05.28.02.06.44;	author aw3;	state Exp;
branches;
next	1.208;

1.208
date	2007.01.17.07.42.41;	author aw3;	state Exp;
branches;
next	1.207;

1.207
date	2007.01.11.19.57.05;	author eklmn;	state Exp;
branches;
next	1.206;

1.206
date	2006.08.21.03.49.49;	author aw3;	state Exp;
branches;
next	1.205;

1.205
date	2006.08.14.02.18.03;	author aw3;	state Exp;
branches;
next	1.204;

1.204
date	2006.07.04.04.43.28;	author aw3;	state Exp;
branches;
next	1.203;

1.203
date	2006.06.27.04.40.22;	author aw3;	state Exp;
branches;
next	1.202;

1.202
date	2006.05.27.02.46.30;	author aw3;	state Exp;
branches;
next	1.201;

1.201
date	2006.05.22.03.45.00;	author aw3;	state Exp;
branches;
next	1.200;

1.200
date	2006.05.21.06.14.30;	author aw3;	state Exp;
branches;
next	1.199;

1.199
date	2006.05.17.03.51.58;	author aw3;	state Exp;
branches;
next	1.198;

1.198
date	2006.05.15.05.51.10;	author aw3;	state Exp;
branches;
next	1.197;

1.197
date	2006.05.14.03.37.04;	author aw3;	state Exp;
branches;
next	1.196;

1.196
date	2006.05.13.04.50.28;	author aw3;	state Exp;
branches;
next	1.195;

1.195
date	2006.05.13.01.41.06;	author aw3;	state Exp;
branches;
next	1.194;

1.194
date	2006.05.07.05.03.08;	author aw3;	state Exp;
branches;
next	1.193;

1.193
date	2006.05.05.11.55.30;	author aw3;	state Exp;
branches;
next	1.192;

1.192
date	2006.05.01.01.31.27;	author aw3;	state Exp;
branches;
next	1.191;

1.191
date	2006.04.30.14.02.01;	author aw3;	state Exp;
branches;
next	1.190;

1.190
date	2006.04.27.11.33.24;	author aw3;	state Exp;
branches;
next	1.189;

1.189
date	2006.04.26.11.56.28;	author aw3;	state Exp;
branches;
next	1.188;

1.188
date	2006.04.26.03.21.49;	author aw3;	state Exp;
branches;
next	1.187;

1.187
date	2006.04.22.15.46.05;	author aw3;	state Exp;
branches;
next	1.186;

1.186
date	2006.02.19.22.56.57;	author kush_eplus;	state Exp;
branches;
next	1.185;

1.185
date	2006.02.12.17.40.29;	author eklmn;	state Exp;
branches;
next	1.184;

1.184
date	2006.02.10.17.09.42;	author eklmn;	state Exp;
branches;
next	1.183;

1.183
date	2006.01.03.04.40.12;	author aw3;	state Exp;
branches;
next	1.182;

1.182
date	2005.11.25.05.11.44;	author aw3;	state Exp;
branches;
next	1.181;

1.181
date	2005.11.16.20.55.30;	author eklmn;	state Exp;
branches;
next	1.180;

1.180
date	2005.11.15.06.05.49;	author aw3;	state Exp;
branches;
next	1.179;

1.179
date	2005.11.11.05.57.36;	author aw3;	state Exp;
branches;
next	1.178;

1.178
date	2005.10.17.04.01.09;	author aw3;	state Exp;
branches;
next	1.177;

1.177
date	2005.10.04.03.27.25;	author aw3;	state Exp;
branches;
next	1.176;

1.176
date	2005.09.29.03.35.09;	author aw3;	state Exp;
branches;
next	1.175;

1.175
date	2005.09.17.03.43.09;	author aw3;	state Exp;
branches;
next	1.174;

1.174
date	2005.09.13.05.57.14;	author aw3;	state Exp;
branches;
next	1.173;

1.173
date	2005.09.05.21.30.46;	author aw3;	state Exp;
branches;
next	1.172;

1.172
date	2005.08.27.15.08.17;	author aw3;	state Exp;
branches;
next	1.171;

1.171
date	2005.08.25.11.57.47;	author aw3;	state Exp;
branches;
next	1.170;

1.170
date	2005.08.11.05.19.37;	author aw3;	state Exp;
branches;
next	1.169;

1.169
date	2005.07.25.03.40.19;	author aw3;	state Exp;
branches;
next	1.168;

1.168
date	2005.06.28.03.54.21;	author aw3;	state Exp;
branches;
next	1.167;

1.167
date	2005.05.23.19.44.47;	author aw3;	state Exp;
branches;
next	1.166;

1.166
date	2005.03.24.04.15.08;	author aw3;	state Exp;
branches;
next	1.165;

1.165
date	2005.02.19.09.56.40;	author eklmn;	state Exp;
branches;
next	1.164;

1.164
date	2005.02.13.19.41.47;	author aw3;	state Exp;
branches;
next	1.163;

1.163
date	2005.02.08.05.49.11;	author aw3;	state Exp;
branches;
next	1.162;

1.162
date	2005.02.03.19.48.07;	author kuchin;	state Exp;
branches;
next	1.161;

1.161
date	2005.01.07.03.43.01;	author netwolf1;	state Exp;
branches;
next	1.160;

1.160
date	2004.12.15.00.17.13;	author aw3;	state Exp;
branches;
next	1.159;

1.159
date	2004.12.13.05.25.08;	author aw3;	state Exp;
branches;
next	1.158;

1.158
date	2004.12.10.02.18.39;	author aw3;	state Exp;
branches;
next	1.157;

1.157
date	2004.12.10.00.40.16;	author aw3;	state Exp;
branches;
next	1.156;

1.156
date	2004.12.02.07.25.45;	author aw3;	state Exp;
branches;
next	1.155;

1.155
date	2004.11.26.18.59.51;	author aw3;	state Exp;
branches;
next	1.154;

1.154
date	2004.11.18.06.59.07;	author aw3;	state Exp;
branches;
next	1.153;

1.153
date	2004.11.14.23.36.19;	author aw3;	state Exp;
branches;
next	1.152;

1.152
date	2004.11.01.04.38.23;	author aw3;	state Exp;
branches;
next	1.151;

1.151
date	2004.10.31.11.18.36;	author dongato;	state Exp;
branches;
next	1.150;

1.150
date	2004.10.31.04.20.48;	author aw3;	state Exp;
branches;
next	1.149;

1.149
date	2004.10.17.20.03.52;	author aw3;	state Exp;
branches;
next	1.148;

1.148
date	2004.10.09.11.45.20;	author dongato;	state Exp;
branches;
next	1.147;

1.147
date	2004.10.08.15.46.47;	author dongato;	state Exp;
branches;
next	1.146;

1.146
date	2004.10.08.03.28.31;	author dongato;	state Exp;
branches;
next	1.145;

1.145
date	2004.09.05.22.13.40;	author aw3;	state Exp;
branches;
next	1.144;

1.144
date	2004.08.27.17.17.10;	author eklmn;	state Exp;
branches;
next	1.143;

1.143
date	2004.08.23.22.44.02;	author syrus77;	state Exp;
branches;
next	1.142;

1.142
date	2004.08.23.12.45.35;	author eklmn;	state Exp;
branches;
next	1.141;

1.141
date	2004.08.21.08.01.00;	author aw3;	state Exp;
branches;
next	1.140;

1.140
date	2004.08.20.02.32.03;	author syrus77;	state Exp;
branches;
next	1.139;

1.139
date	2004.08.19.00.33.08;	author syrus77;	state Exp;
branches;
next	1.138;

1.138
date	2004.08.16.13.36.13;	author eklmn;	state Exp;
branches;
next	1.137;

1.137
date	2004.08.15.20.55.41;	author eklmn;	state Exp;
branches;
next	1.136;

1.136
date	2004.08.15.08.12.25;	author eklmn;	state Exp;
branches;
next	1.135;

1.135
date	2004.07.29.04.47.00;	author aw3;	state Exp;
branches;
next	1.134;

1.134
date	2004.07.16.19.08.07;	author dongato;	state Exp;
branches;
next	1.133;

1.133
date	2004.07.15.18.18.27;	author eklmn;	state Exp;
branches;
next	1.132;

1.132
date	2004.07.15.17.58.14;	author eklmn;	state Exp;
branches;
next	1.131;

1.131
date	2004.07.14.15.05.51;	author eklmn;	state Exp;
branches;
next	1.130;

1.130
date	2004.07.13.04.01.28;	author aw3;	state Exp;
branches;
next	1.129;

1.129
date	2004.07.11.05.43.55;	author aw3;	state Exp;
branches;
next	1.128;

1.128
date	2004.07.09.22.43.18;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2004.07.09.17.35.02;	author eklmn;	state Exp;
branches;
next	1.126;

1.126
date	2004.07.07.16.19.05;	author dongato;	state Exp;
branches;
next	1.125;

1.125
date	2004.07.07.12.32.50;	author dongato;	state Exp;
branches;
next	1.124;

1.124
date	2004.07.06.16.54.44;	author eklmn;	state Exp;
branches;
next	1.123;

1.123
date	2004.07.05.20.50.57;	author dongato;	state Exp;
branches;
next	1.122;

1.122
date	2004.06.02.22.15.05;	author syrus77;	state Exp;
branches;
next	1.121;

1.121
date	2004.06.02.21.10.18;	author aw3;	state Exp;
branches;
next	1.120;

1.120
date	2004.05.29.19.25.23;	author syrus77;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.29.19.15.41;	author syrus77;	state Exp;
branches;
next	1.118;

1.118
date	2004.05.29.01.08.48;	author aw3;	state Exp;
branches;
next	1.117;

1.117
date	2004.05.27.01.52.36;	author aw3;	state Exp;
branches;
next	1.116;

1.116
date	2004.05.26.06.18.19;	author aw3;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.23.10.11.58;	author dongato;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.04.14.45.24;	author dropf;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.03.09.59.44;	author netwolf1;	state Exp;
branches;
next	1.112;

1.112
date	2004.05.01.05.49.21;	author aw3;	state Exp;
branches;
next	1.111;

1.111
date	2004.04.29.18.03.36;	author aw3;	state Exp;
branches;
next	1.110;

1.110
date	2004.04.24.23.01.06;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2004.04.09.20.57.17;	author dongato;	state Exp;
branches;
next	1.108;

1.108
date	2004.04.09.13.15.56;	author dongato;	state Exp;
branches;
next	1.107;

1.107
date	2004.04.08.00.26.41;	author aw3;	state Exp;
branches;
next	1.106;

1.106
date	2004.04.07.10.22.58;	author eklmn;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.27.21.20.31;	author dongato;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.20.01.44.03;	author aw3;	state Exp;
branches;
next	1.103;

1.103
date	2004.03.19.21.58.17;	author eklmn;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.20.02.29.54;	author kush_eplus;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.100;

1.100
date	2004.02.11.21.33.37;	author eklmn;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.05.00.00.01;	author kush_eplus;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.01.07.03.18;	author eklmn;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.30.20.33.57;	author eklmn;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.28.20.41.52;	author dongato;	state Exp;
branches;
next	1.95;

1.95
date	2004.01.26.21.25.21;	author kush_eplus;	state Exp;
branches;
next	1.94;

1.94
date	2004.01.23.13.38.39;	author dongato;	state Exp;
branches;
next	1.93;

1.93
date	2004.01.21.13.30.51;	author dongato;	state Exp;
branches;
next	1.92;

1.92
date	2004.01.16.19.46.50;	author eklmn;	state Exp;
branches;
next	1.91;

1.91
date	2004.01.11.05.09.57;	author dongato;	state Exp;
branches;
next	1.90;

1.90
date	2003.11.09.16.39.13;	author eklmn;	state Exp;
branches;
next	1.89;

1.89
date	2003.11.01.13.30.41;	author dongato;	state Exp;
branches;
next	1.88;

1.88
date	2003.10.30.16.57.38;	author kuchin;	state Exp;
branches;
next	1.87;

1.87
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.86;

1.86
date	2003.10.28.12.07.55;	author katsyonak;	state Exp;
branches;
next	1.85;

1.85
date	2003.10.27.17.25.09;	author eklmn;	state Exp;
branches;
next	1.84;

1.84
date	2003.10.26.13.50.16;	author morevit;	state Exp;
branches;
next	1.83;

1.83
date	2003.10.20.13.20.00;	author morevit;	state Exp;
branches;
next	1.82;

1.82
date	2003.10.15.03.51.45;	author morevit;	state Exp;
branches;
next	1.81;

1.81
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.80;

1.80
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.79;

1.79
date	2003.10.04.16.54.07;	author dongato;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.03.21.38.46;	author dongato;	state Exp;
branches;
next	1.77;

1.77
date	2003.10.02.14.26.00;	author dongato;	state Exp;
branches;
next	1.76;

1.76
date	2003.10.01.16.40.45;	author morevit;	state Exp;
branches;
next	1.75;

1.75
date	2003.09.29.02.57.43;	author dongato;	state Exp;
branches;
next	1.74;

1.74
date	2003.09.24.16.50.19;	author morevit;	state Exp;
branches;
next	1.73;

1.73
date	2003.09.24.09.28.06;	author netwolf1;	state Exp;
branches;
next	1.72;

1.72
date	2003.09.23.23.36.25;	author dongato;	state Exp;
branches;
next	1.71;

1.71
date	2003.09.23.16.52.49;	author morevit;	state Exp;
branches;
next	1.70;

1.70
date	2003.09.22.16.16.31;	author morevit;	state Exp;
branches;
next	1.69;

1.69
date	2003.09.21.12.58.02;	author morevit;	state Exp;
branches;
next	1.68;

1.68
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.67;

1.67
date	2003.09.19.00.13.38;	author morevit;	state Exp;
branches;
next	1.66;

1.66
date	2003.09.09.21.36.02;	author dongato;	state Exp;
branches;
next	1.65;

1.65
date	2003.09.09.01.16.58;	author dongato;	state Exp;
branches;
next	1.64;

1.64
date	2003.09.04.23.05.27;	author dongato;	state Exp;
branches;
next	1.63;

1.63
date	2003.09.03.19.44.21;	author dongato;	state Exp;
branches;
next	1.62;

1.62
date	2003.08.23.00.20.50;	author forcha;	state Exp;
branches;
next	1.61;

1.61
date	2003.08.10.14.12.52;	author zegzav;	state Exp;
branches;
next	1.60;

1.60
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.59;

1.59
date	2003.08.03.20.42.05;	author forcha;	state Exp;
branches;
next	1.58;

1.58
date	2003.07.30.12.29.31;	author kuchin;	state Exp;
branches;
next	1.57;

1.57
date	2003.07.26.11.27.01;	author zegzav;	state Exp;
branches;
next	1.56;

1.56
date	2003.07.24.17.17.17;	author eklmn;	state Exp;
branches;
next	1.55;

1.55
date	2003.07.15.21.48.45;	author syrus77;	state Exp;
branches;
next	1.54;

1.54
date	2003.07.12.06.17.50;	author eklmn;	state Exp;
branches;
next	1.53;

1.53
date	2003.07.09.16.17.26;	author dongato;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.05.11.53.08;	author dongato;	state Exp;
branches;
next	1.51;

1.51
date	2003.07.04.05.37.13;	author eklmn;	state Exp;
branches;
next	1.50;

1.50
date	2003.07.02.22.40.33;	author syrus77;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.30.16.44.51;	author eklmn;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.29.20.17.12;	author syrus77;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.28.18.17.24;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2003.06.28.09.05.33;	author partyckip;	state Exp;
branches;
next	1.45;

1.45
date	2003.06.27.12.35.36;	author syrus77;	state Exp;
branches;
next	1.44;

1.44
date	2003.06.27.01.23.59;	author syrus77;	state Exp;
branches;
next	1.43;

1.43
date	2003.06.24.18.14.47;	author eklmn;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.22.12.43.03;	author partyckip;	state Exp;
branches;
next	1.41;

1.41
date	2003.06.22.09.35.43;	author eklmn;	state Exp;
branches;
next	1.40;

1.40
date	2003.06.19.16.48.05;	author partyckip;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.16.19.29.38;	author eklmn;	state Exp;
branches;
next	1.38;

1.38
date	2003.06.15.19.32.06;	author eklmn;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.15.07.41.36;	author eklmn;	state Exp;
branches;
next	1.36;

1.36
date	2003.06.07.12.03.12;	author eklmn;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.06.20.37.18;	author partyckip;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.06.19.59.34;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.05.01.22.31;	author netwolf1;	state Exp;
branches;
next	1.32;

1.32
date	2003.06.01.08.59.02;	author kuchin;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.27.23.03.08;	author partyckip;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.26.21.46.11;	author partyckip;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.20.16.30.41;	author netwolf1;	state Exp;
branches;
next	1.28;

1.28
date	2003.05.18.11.40.32;	author obaldin;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.12.13.22.09;	author kuchin;	state Exp;
branches;
next	1.26;

1.26
date	2003.05.04.14.13.24;	author kuchin;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.04.10.05.33;	author kuchin;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.29.08.37.45;	author kuchin;	state Exp;
branches;
next	1.23;

1.23
date	2003.04.03.10.12.17;	author kuchin;	state Exp;
branches;
next	1.22;

1.22
date	2003.03.30.12.10.21;	author moosetea;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.20.13.42.54;	author obaldin;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.03.19.18.34.50;	author cax2;	state Exp;
branches;
next	1.19;

1.19
date	2003.03.16.06.09.31;	author cax2;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.14.16.10.54;	author partyckip;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.14.11.56.31;	author partyckip;	state Exp;
branches;
next	1.16;

1.16
date	2003.03.10.18.00.20;	author cax2;	state Exp;
branches;
next	1.15;

1.15
date	2003.03.08.12.09.42;	author recdvst;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.05.11.23.44;	author recdvst;	state Exp;
branches;
next	1.13;

1.13
date	2003.02.26.15.07.44;	author dongato;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.17.22.09.47;	author obaldin;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2003.02.17.19.17.12;	author dongato;	state Exp;
branches;
next	1.10;

1.10
date	2003.02.17.15.04.20;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.12.20.18.24;	author obaldin;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.10.18.43.26;	author obaldin;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.10.15.34.21;	author obaldin;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.09.18.39.42;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.02.14.58.53;	author obaldin;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.01.27.22.22.30;	author lord_kiron;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2003.01.22.15.05.39;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.21;	author cax2;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	;

1.4.2.1
date	2003.02.05.01.58.42;	author obaldin;	state Exp;
branches;
next	;

1.12.2.1
date	2003.03.01.11.25.56;	author obaldin;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2003.03.02.08.46.06;	author obaldin;	state Exp;
branches;
next	;

1.21.2.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2003.03.24.09.39.43;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.225
log
@Ability to add known LowID source through remote client shared files list.
@
text
@//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#pragma once

#include "KnownFile.h"
#include "opcodes.h"
#include "SourceSaver.h"
#include "PastComment.h"
#include "Category.h"

enum _EnumPartFileStatuses
{
	PS_READY			= 0,
	PS_EMPTY			= 1,
	PS_WAITINGFORHASH	= 2,
	PS_HASHING			= 3,
	PS_ERROR			= 4,
	PS_UNKNOWN			= 6,
	PS_PAUSED			= 7,
	PS_COMPLETING		= 8,
	PS_COMPLETE			= 9,
	PS_STOPPED			= 10,
	PS_DOWNLOADING		= 20,	//MOREVIT - Dummy status
	PS_WAITINGFORSOURCE	= 21,	//MOREVIT - Dummy status
	PS_STALLED			= 22	//MOREVIT - Dummy status
};
typedef EnumDomain<_EnumPartFileStatuses>	EnumPartFileStatuses;

//	The number of days without a transfer before a download is considered stalled
#define WARN_PERIOD_OF_NO_PROGRESS	7

#define BUFFER_TIME_LIMIT			MIN2MS(5)	// File data flush interval

// Defines for status of filled parts
#define PART_CORRUPTED				0x01000000
#define PART_VERIFIED				0x02000000
#define NOT_AVAILABLE				0x00FFFFFF

#define PARTIALLY_BLOCKED			0x01
#define FULLY_BLOCKED				0x02
#define FREE_TO_DL					0x00

//	Extra flags for source addition
#define ADDSRC_KNOWNSRC				0x01	// existing source (should be already known)

class CSearchFile;
class CUpDownClient;
class CClientSource;
struct Gap_Struct;
struct Requested_Block_Struct;

struct PartFileBufferedData
{
	BYTE				*pbyteBuffer;	// This is the data to be written
	uint64				qwStartOffset;	// This is the start offset of the data
	uint64				qwEndOffset;	// This is the end offset of the data
};

class CPartFile : public CKnownFile
{
public:
	CPartFile();
	CPartFile(CSearchFile* searchresult, EnumCategories eCatID);
	CPartFile(CString edonkeylink, EnumCategories eCatID);
	CPartFile(class CED2KFileLink* fileLink, EnumCategories eCatID);
	void	InitializeFromLink(CED2KFileLink* fileLink, EnumCategories eCatID);
	virtual	~CPartFile();

//	file status functions (get status)
	EnumPartFileStatuses	GetStatus() const;
	EnumPartFileStatuses	GetRawStatus() const { return m_eStatus; }
	void	SetStatus(EnumPartFileStatuses eNewStatus);
	int		GetPartFileStatusID() const;
	int		GetPartFileStatusRang();
	bool	IsPartFile()				{return !(m_eStatus == PS_COMPLETE);}
	bool	IsPaused() const			{return m_bPaused;}
	bool	IsStopped() const			{return m_bStopped;}
	bool	IsStalled() const;
	bool	IsCompleting() const		{return (m_eStatus == PS_COMPLETING);}
	bool	IsPreallocated() const		{ return m_bIsPreallocated; }
	bool	PreviewAvailable();
	bool	AllowGet1stLast();
	bool	IsArchive() const;
	bool	IsArchivePreviewable() const	{ return m_bIsPreviewableArchive; }
	bool	IsMovie() const				{ return (m_cIsMovie != 0); }
	bool	IsAviMovie() const			{ return (m_cIsMovie == 1); }
	bool	IsAviKindMovie() const		{ return (m_cIsMovie > 0); }
	bool	IsMpgMovie() const			{ return m_bIsMpgMovie; }
	bool	IsMpgAudio() const			{ return m_bIsMpgAudio; }

//	file status functions (set & change status)
	void	DeleteFile();
	void	StopFile(bool bUpdateDisplay = true);
	void	PauseFile();
	void	ResumeFile();
	void	PreviewFile();
	void	AllocateNeededSpace();

//	file property & statistic functions
	uint64	GetRealFileSize();
	uint64	GetSizeToTransfer() const				{ return m_qwGapsSum; }

//	file name & dirs related
	void	SetFileName(const CString& NewName, bool bClearName = true);
	const CString&	GetFullName() const						{return m_strFullName;}
	const CString&	GetPartMetFileName() const				{return m_strPartMetFileName;}
	const CString&	GetTempDir() const						{return m_strTempDir;}
	CString	GetOutputDir();
	void	SetAlternativeOutputDir(CString* path);
	bool	IsAlternativeOutputDir() const			{return !m_strAlternativePath.IsEmpty();}

//	file priority
	bool	IsAutoPrioritized() 					{ return m_bAutoPriority ; }
	void	SetAutoPriority(bool newAutoPriority) 	{ m_bAutoPriority = newAutoPriority ; }
	void	SetPriority(byte byteNewPriority, bool bSaveSettings = true);
	byte	GetPriority()							{return priority;}
	void	UpdateDownloadAutoPriority(void);

//	file comments
	bool	HasComment() const		{return m_bHasComment;}
	void	SetHasComment(bool in)			{m_bHasComment=in;}
	void	CheckAndAddPastComment(CUpDownClient *pClient);
	void	RemovePastComment(CUpDownClient *pClient, bool bRestore= true);
	CPastCommentList &GetPastCommentList()			{ return m_pastCommentList; }

//	file category
	EnumCategories	GetCatID() const;
	void			SetCatID(EnumCategories eCatID);

//	file rating
	EnumPartFileRating		GetRating();
	bool	HasRating() const			{return m_bHasRating;}
	void	SetHasRating(bool in)			{m_bHasRating=in;}
	void	UpdateFileRatingCommentAvail();


//	part status function (get functions)
	bool	IsComplete(uint64 qwStart, uint64 qwEnd);
	bool	IsPartComplete(uint32 dwPart) const;
	bool	IsPartComplete(uint32 dwPart, uint64 *pqwStart, uint64 *pqwEnd) const;
	bool	IsPartFull(uint32 dwPart) const;
	bool	IsPartDownloading(uint32 dwPart) const;
	bool	IsCorruptedPart(uint32 dwPartNum) const {return ((PART_CORRUPTED & m_PartsStatusVector[dwPartNum]) != 0);}

	uint32	GetPartLeftToDLSize(uint32 dwPartNum) const {return (0x00FFFFFF & m_PartsStatusVector[dwPartNum]);}

	uint16	GetNextRequiredPart(CUpDownClient* sender);
	uint16	GetSrcPartFrequency(uint32 part) { return m_srcPartFrequencies[part]; }
	uint32	GetAvailablePartCount() const	{return m_dwAvailablePartsCount;}
	void	GetFirstLastChunk4Preview();

//	part status functions (set & change status)
	void	FileRehashingStarted();
	void	PartFileHashFinished(CKnownFile *pKnownFile);
	bool	HashSinglePart(uint32 dwPartNum); // true = ok, false = corrupted
	void	NewSrcPartsInfo();

//	source functions
	void	AddClientSource(CClientSource *pSource, int iSource = 0, bool bExchanged = false, byte byteSXVer = 0, int iMode = 0);
	void	AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);
	void	AddClientSources(CMemFile *sources, byte byteSXVer, bool bSX2, const CUpDownClient *pClient = NULL);
	void	AddServerSources(CMemFile &pSources, uint32 dwSrvIP, uint16 uSrvPort, bool bWithObfuscationAndHash);
	virtual	Packet* CreateSrcInfoPacket(const CUpDownClient *pForClient, byte byteRequestedVer, uint16 uRequestedOpt);
	void	GetSourcesAfterServerConnect();
	void	RemoveNoNeededSources(uint32 dwNumberSources2Remove);
	void	RemoveAllSources();
	void	DownloadAllA4AF(bool bSameCat = false);
	void	GetCompleteSourcesRange(uint16 *lo, uint16 *hi)	{ *lo = *hi = GetCompleteSourcesCount(); }

	void	GetCopySourceList(EnumDLQState eClientDS, ClientList *pCopy, bool bClearSourceList = false);
	void	GetCopySourceLists(uint32 dwListsMask, ClientList *pCopy, bool bClearSourceLists = false);
	bool	RemoveClientFromDLSourceList(CUpDownClient *pClient);
	void	AddClientToSourceList(CUpDownClient *pClient, EnumDLQState eClientDS);
	bool	IsClientInSourceList(CUpDownClient *pClient);
	void	ClearSourceLists();
	void	SwapClientBetweenSourceLists(CUpDownClient *pClient, EnumDLQState eSourceDS, EnumDLQState eTargetDS);

	void	AddClientToA4AFSourceList(CUpDownClient *pClient);
	void	RemoveClientFromA4AFSourceList(CUpDownClient *pClient);
	void	GetCopyA4AFSourceList(ClientList *pCopy, bool bClearSourceList = false);
	void	ClearA4AFSourceList();

//	source statistic functions
	uint16	GetSourceCount();
	uint16	GetTransferringSrcCount() const			{ return m_uNumTransferringSrcs; }
	uint16	GetNoNeededPartsSrcCount() const		{ return m_uSrcNNP; }
	uint16	GetOnQueueSrcCount() const				{ return m_uSrcOnQueue; }
	uint16	GetHighQRSrcCount() const				{ return m_uSrcHighQR; }
	uint16	GetConnectingSrcCount() const			{ return m_uSrcConnecting; }
	uint16	GetWaitForFileReqSrcCount() const		{ return m_uSrcWaitForFileReq; }
	uint16	GetConnectedSrcCount() const			{ return m_uSrcConnected; }
	uint16	GetConnectingViaServerSrcCount() const	{ return m_uSrcConnViaServer; }
	uint16	GetLow2LowSrcCount() const				{ return m_uSrcLowToLow; }
	uint16	GetLowIDOnOtherServer() const			{ return m_uSrcLowIDOnOtherServer; }
	uint16	GetQueueFullSrcCount() const			{ return m_uSrcQueueFull; }
	uint16	GetSrcA4AFCount() const					{ return m_uSrcA4AF; }
	uint32	GetNotCurrentSourcesCount();
	uint32	GetValidSourcesCount();
	uint16	GetCompleteSourcesCount()				{return m_uLastCompleteSrcCount;}

//	gap functions
	void	AddGap(uint64 qwStart, uint64 qwEnd);
	void	FillGap(uint64 qwStart, uint64 qwEnd);
	uint32	GetGapsInPart(uint32 dwPartNum, Requested_Block_Struct **ppNewBlocks, uint32 dwCount);
	// Barry - This will invert the gap list, up to caller to delete gaps when done
	// 'Gaps' returned are really the filled areas, and guaranteed to be in order
	void	GetFilledList(CTypedPtrList<CPtrList, Gap_Struct*> *filled);

//	block functions
	bool	IsLastBlockComplete();
	void	RemoveBlockFromList(const uint64 &qwStart, const uint64 &qwEnd);
	// Barry - Added to prevent list containing deleted blocks on shutdown
	void	RemoveAllRequestedBlocks(void);

#define PF_WR2BUF_FL_FREEBUFFER		0x01
#define PF_WR2BUF_FL_ENDOFBLOCK		0x02
	uint32	WriteToBuffer(sint32 iComprGain, BYTE *data, uint64 qwStart, uint64 qwEnd, int iFlags);

//	time function
	void	SetStartTimeReset(bool bEnable)		{m_StartTimeReset = bEnable;}
	bool	GetStartTimeReset()					{return m_StartTimeReset;}
	CTimeSpan GetFlushTimeSpan()			{return (m_timeLastDownTransfer - m_SessionStartTime);}
	CTimeSpan GetSessionTimeSpan()			{return (CTime::GetCurrentTime() - m_SessionStartTime);}
	uint32	GetLastPurgeTime()					{ return m_dwLastPurgeTime; }
	sint32	GetTimeRemaining(bool bAvgerage = false);
	uint32	GetLastAnsweredTime()			{ return m_ClientSrcAnswered; }
	const CTime&	GetLastDownTransfer() const			{ return m_timeLastDownTransfer; }
	void	SetLastAnsweredTime()			{ m_ClientSrcAnswered = ::GetTickCount(); }
	void	SetLastAnsweredTimeTimeout()	{ m_ClientSrcAnswered = 2 * CONNECTION_LATENCY + ::GetTickCount() - SOURCECLIENTREASK; }

//	File statistics (session & cumulative)
	uint64	GetTransferred() const					{ return m_qwBytesTransferred; }
	uint64	GetCompletedSize() const				{ return m_qwCompletedSize; }
	uint32	GetDataRate()							{return m_dwDataRate;}
	void	AddRxAmount(uint32 dwRxBytes)			{ m_qwBytesTransferred += static_cast<uint64>(dwRxBytes); }
	void	AddRxCorruptedAmount(uint32 dwBadBytes);
	uint32	GetAvgDataRate(bool bUpdated = false);
	uint64	GetSessionTransferred()					{ return ((m_qwCompletedSize > m_qwSessionStartSize) ? (m_qwCompletedSize - m_qwSessionStartSize) : 0); }
	uint64	GetLostDueToCorruption() const			{return m_qwLostDueToCorruption;}
	uint64	GetGainDueToCompression() const			{return m_qwGainDueToCompression;}
	uint32	TotalPacketsSavedDueToICH() const		{return m_iTotalPacketsSavedDueToICH;}
	void	UpdateCompletedInfos();
	double	GetPercentCompleted() const				{return m_dblPercentCompleted;}
//	Don't return more than 99.99 for 2 digits display as it will be rounded to 100.00 during number to string conversion
	double	GetPercentCompleted2() const			{return ((m_dblPercentCompleted > 99.99) && (m_dblPercentCompleted < 100.0)) ? 99.99 : m_dblPercentCompleted;}

//	I/O functions
	void	FlushBuffer(void);
	CFile&	GetPartFileHandle()				{return m_hPartFileRead;}
	bool	LoadPartFile(LPCTSTR in_directory, LPCTSTR filename);
	bool	TryToRecoverPartFile(LPCTSTR in_directory, LPCTSTR in_filename);
	bool	SavePartFile();
	void	WritePartStatus(CFile* file);
	void	WriteCompleteSourcesCount(CFile* file);
	void	LoadSettingsFile();
	void	SaveSettingsFile();
	bool	SavePartFileStats();
	int	ReadFileForUpload(uint64 qwOffset, uint32 dwBytesToRead, byte *pbyteBuffer);


//	GUI related functions
	void	DrawStatusBar(CDC* dc, RECT* rect, bool bFlat);
	void	UpdateDisplayedInfo();
	CString	GetPartFileStatus();
	void	GetProgressString(CString *pstrChunkBar, uint32 dwSize);
	CString	GetDownloadFileInfo();
	CString	GetDownloadFileInfo4Tooltips();
	CString	LocalizeLastSeenComplete()	{return DtLocale(lastseencomplete);}
	CString	LocalizeLastDownTransfer()	{return DtLocale(m_timeLastDownTransfer);}

//	unsorted
	uint32	Process(uint32 dwReduceDownload, uint32 dwIteration);
	byte*	MMCreatePartStatus();
	static UINT AllocateNeededSpaceProc(LPVOID lpParameter);
	CString	CreateED2KSourceLink(uint32 dwExpireIn, int iSourceCnt);

	bool	IsFakesDotRar() const						{ return m_bIsFakesDotRar; }
	void	SetFakesDotRar(bool bIsFakesDotRar = true)	{ m_bIsFakesDotRar = bIsFakesDotRar; }

protected:
	bool	IsAlreadyRequested(uint64 qwStart, uint64 qwEnd);
	void	CompleteFile(bool hashingdone);
	void	CreatePartFile();
	void	Init();

private:
	CString	DtLocale(CTime dt);
	BOOL	PerformFileComplete();
	static UINT CompleteThreadProc(CPartFile* pFile);
	CString	GetStatsFullPath() const;
	bool	LoadPartFileStats();
	void	RemovePartFileStats();
	void	ClosePartFile();
	void	UpdateGUIAfterStateChange();
	void	GetGapListCopy(CArray<Gap_Struct, Gap_Struct> *pGapArray);
	void	FillGapInParts(uint64 qwGapStart, uint64 qwGapEnd);
	void	AddGapToParts(uint64 qwGapStart, uint64 qwGapEnd);

// --- variable sections ---

public:
	// Barry - Is archive recovery in progress
	volatile bool	m_bRecoveringArchive;
	volatile bool	m_bPreviewing;

	bool		m_bHashSetNeeded;
	CTime		lastseencomplete;

protected:
	CSourceSaver		m_sourcesaver;

private:
//	Separate read and write handles to eliminate I/O collisions
	CFile	m_hPartFileWrite;
	CFile	m_hPartFileRead;

	EnumCategories	m_eCategoryID;
	bool			m_bDataFlushReq;
	uint16			m_uProcessCounter;
//	Statistics
	uint16	m_uNumTransferringSrcs;
	uint16	m_uSrcNNP;
	uint16	m_uSrcOnQueue;
	uint16	m_uSrcHighQR;
	uint16	m_uSrcConnecting;
	uint16	m_uSrcWaitForFileReq;
	uint16	m_uSrcConnected;
	uint16	m_uSrcConnViaServer;
	uint16	m_uSrcLowToLow;
	uint16	m_uSrcLowIDOnOtherServer;
	uint16	m_uSrcQueueFull;
	uint16	m_uSrcA4AF;
	uint64	m_qwCompletedSize;
	uint64	m_qwLostDueToCorruption;
	uint64	m_qwGainDueToCompression;
	uint32	m_iTotalPacketsSavedDueToICH;
	uint32	m_dwDataRate;
	CString	m_strFullName;
	CString	m_strTempDir;
	CString	m_strPartMetFileName;
	uint64	m_qwBytesTransferred;
	bool	m_bPaused;
	bool	m_bStopped;
	byte	priority;
	EnumPartFileStatuses	m_eStatus;
	uint32	m_dwLastFileSourcesRequestTime;
	uint32	m_dwLastPurgeTime;
	uint32	m_LastNoNeededCheck;

	CTypedPtrList<CPtrList, Gap_Struct*> gaplist;
	CTypedPtrList<CPtrList, Requested_Block_Struct*> requestedblocks_list;
	CArray<uint16,uint16> m_srcPartFrequencies;
	uint16	m_uMaxSrcPartFrequency;
	std::vector<uint32> m_PartsStatusVector;
	CRITICAL_SECTION	m_csSourceLists;
	ClientList			m_SourceLists[DS_LAST_QUEUED_STATE];
	ClientList			m_A4AFSourceLists;
	double	m_dblPercentCompleted;
	uint32	m_dwAvailablePartsCount;
	uint32	m_ClientSrcAnswered;
	bool	m_bAutoPriority;
	bool	m_bIsBeingDeleted;
	bool	m_bIsPreallocated;

	CTime	m_SessionStartTime;
	uint64	m_qwSessionStartSize;
	uint32	m_AvgDataRate;
	uint64	m_qwCompletedPartsSize;
	bool	m_StartTimeReset;

	bool	m_bIsFakesDotRar;
	bool	m_bHasRating;
	bool	m_bHasComment;

	CTypedPtrList<CPtrList, PartFileBufferedData*> m_BufferedData_list;
	uint32	m_nTotalBufferData;
	uint32	m_nLastBufferFlushTime;
	uint16	m_uLastCompleteSrcCount;

	CCriticalSection	m_csSavePartFile;
	CCriticalSection	m_csGapListAndPartStatus;
	CCriticalSection	m_csFileCompletion;

	CTime	m_timeLastDownTransfer;
	CString	m_strAlternativePath;

	CPastCommentList m_pastCommentList;

	uint64	m_qwGapsSum;

	bool	m_bIsPreviewableArchive;
	char	m_cIsMovie;	// 0: non-video, 1: AVI, 2: AVI kind video, < 0: another format
	bool	m_bIsMpgMovie;
	bool	m_bIsMpgAudio;
};
@


1.224
log
@WebServer: improved download progress bar representation for large files {DonGato}.
@
text
@d56 3
d172 1
a172 1
	void	AddClientSource(CClientSource *pSource, int iSource=0, bool bExchanged=false, byte byteSXVer = 0);
@


1.223
log
@Pass an output string as a parameter for WS progress bar generation.
@
text
@a275 1
	void	CharFillRange(CString* buffer, double start, double end, TCHAR cColor);
@


1.222
log
@H-file reorganization.
@
text
@d275 1
a275 1
	CString	GetProgressString(uint32 dwSize);
@


1.221
log
@Recover my work, overwrote by Fuxie - DK.
@
text
@a18 1
#include "types.h"
d59 2
@


1.220
log
@Data type converted into 32bit from 16; Suppressed compiler warnings [Aw3].
@
text
@d284 1
a284 1
	static DWORD WINAPI AllocateNeededSpaceProc(LPVOID lpParameter);
@


1.219
log
@Use AfxBeginThread function for thread creation to become CRT friendly
@
text
@d274 1
a274 1
	CString	GetProgressString(uint16 size);
d284 1
a284 1
	static UINT AllocateNeededSpaceProc(LPVOID lpParameter);
@


1.218
log
@Suppressed compiler warnings [Aw3].
@
text
@d284 1
a284 1
	static DWORD WINAPI AllocateNeededSpaceProc(LPVOID lpParameter);
@


1.217
log
@Redid Aw3's change.
@
text
@d157 1
a157 1
	uint16	GetSrcPartFrequency(uint16 part) { return m_srcPartFrequencies[part]; }
@


1.216
log
@Changes from Eklmn restored.
They were accidentally overwritten by Fuxie - DK
@
text
@d80 1
a80 1
	const	EnumPartFileStatuses&	GetRawStatus() const { return m_eStatus; }
@


1.215
log
@Removed meaningless change [Aw3].
@
text
@d80 1
a80 1
	EnumPartFileStatuses	GetRawStatus() const { return m_eStatus; }
@


1.214
log
@improved the string handling
@
text
@d79 2
a80 2
	EnumPartFileStatuses		GetStatus() const;
	const EnumPartFileStatuses&	GetRawStatus() const { return m_eStatus; }
@


1.213
log
@Fixed messed waiting for hash and hashing file statuses in GUI and WebServer {Fuxie - DK} [Aw3];
Formatting and stricter prototypes.
@
text
@d79 2
a80 2
	EnumPartFileStatuses	GetStatus() const;
	EnumPartFileStatuses	GetRawStatus() const { return m_eStatus; }
d114 3
a116 3
	CString	GetFullName() const						{return m_strFullName;}
	CString	GetPartMetFileName() const				{return m_strPartMetFileName;}
	CString	GetTempDir() const						{return m_strTempDir;}
d236 1
a236 1
	CTime	GetLastDownTransfer() const			{ return m_timeLastDownTransfer; }
@


1.212
log
@Split  IsArchive into 2 functions to avoid useless checks.
@
text
@d36 1
a36 1
	PS_STOPPED			= 10,	//eklmn: added stop status
d39 1
a39 2
	PS_STALLED			= 22,	//MOREVIT - Dummy status
	PS_ACTIVE			= 23	//MOREVIT - Dummy status = Downloading || on queue
d82 1
a82 1
	int		GetPartFileStatusID();
d162 3
a164 2
	void	PartFileHashFinished(CKnownFile* result);
	bool	HashSinglePart(uint32 dwPartNum); // true = ok , false = corrupted
d194 3
a196 3
	uint16	GetTransferringSrcCount()				{ return m_iNumTransferringSrcs; }
	uint16	GetNoNeededPartsSrcCount()				{return m_iSrcNNP;}
	uint16	GetOnQueueSrcCount()					{return m_iSrcOnQueue;}
d198 1
a198 1
	uint16	GetConnectingSrcCount()					{return m_iSrcConnecting;}
d200 2
a201 2
	uint16	GetConnectedSrcCount()					{return m_iSrcConnected;}
	uint16	GetConnectingViaServerSrcCount()		{return m_iSrcConnViaServer;}
d204 2
a205 2
	uint16	GetQueueFullSrcCount()					{return m_iSrcQueueFull;}
	uint16	GetSrcA4AFCount()						{return m_iSrcA4AF;}
d331 3
a333 3
	uint16	m_iNumTransferringSrcs;
	uint16	m_iSrcNNP;
	uint16	m_iSrcOnQueue;
d335 1
a335 1
	uint16	m_iSrcConnecting;
d337 2
a338 2
	uint16	m_iSrcConnected;
	uint16	m_iSrcConnViaServer;
d341 2
a342 2
	uint16	m_iSrcQueueFull;
	uint16	m_iSrcA4AF;
@


1.211
log
@Encryption preparations.
@
text
@d93 2
a94 1
	bool	IsArchive(bool bOnlyPreviewable = false);
@


1.210
log
@Added Source Exchange 2 support (adapted from original 0.48a).
@
text
@d167 1
a167 1
	void	AddClientSource(CClientSource* pSource, int iSource=0, bool bExchanged=false, byte byteSourceExchangeVersion = 0);
d170 1
a170 1
	void	AddServerSources(CMemFile &pSources, uint32 dwSrvIP, uint16 uSrvPort);
@


1.209
log
@Preparation to support Source Exchange 2 (0.48a).
@
text
@d169 1
a169 1
	void	AddClientSources(CMemFile *sources, byte byteSXVer, bool bSX2);
@


1.208
log
@Ranaming and formatting.
@
text
@d169 1
a169 1
	void	AddClientSources(CMemFile *sources, byte byteSXVer = 1);
d171 1
a171 1
	virtual	Packet* CreateSrcInfoPacket(CUpDownClient* ForClient);
@


1.207
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d169 2
a170 2
	void	AddClientSources(CMemFile* sources, byte sourceexchangeversion = 1);
	void	AddServerSources(CMemFile& pSources, uint32 iServerIP, uint16 iServerPort);
d239 1
a239 1
//	File statistic (session & cumulative)
d257 1
a257 1
	CFile	&GetPartFileHandle()				{return m_hPartFileRead;}
@


1.206
log
@Simplified arguments passing to preallocation thread.
@
text
@d170 1
a170 1
	void	AddSources(CMemFile& pSources, uint32 iServerIP, uint16 iServerPort);
@


1.205
log
@Removed unused parameter; Formatting.
@
text
@a68 6
struct PAThreadParam
{
	uint32		iPosition;
	CPartFile*	cPartFile;
};

@


1.204
log
@Removed unused services.
@
text
@d180 1
a180 1
	void	RemoveAllSources(bool bTryToSwap);
d182 1
a182 1
	void	GetCompleteSourcesRange(uint16 *lo, uint16 *hi)	{*lo= *hi= GetCompleteSourcesCount();}
a244 1

@


1.203
log
@Don't show Media Info tab for formats which can't be examined {Fuxie - DK};
Slightly reduced memory usage.
@
text
@a264 2
	bool	LoadFromFile(FILE* file)						{return false;}
	bool	WriteToFile(FILE* file)							{return false;}
@


1.202
log
@Large file size support preparations.
@
text
@d100 3
a102 2
	bool	IsMovie() const				{ return m_bIsMovie; }
	bool	IsAviMovie() const			{ return m_bIsAviMovie; }
d410 1
a410 2
	bool	m_bIsMovie;
	bool	m_bIsAviMovie;
@


1.201
log
@Large file size support preparations.
@
text
@d246 1
a246 1
	uint32	GetTransferred() const					{ return m_dwBytesTransferred; }
d249 1
a249 1
	void	AddRxAmount(uint32 dwRxBytes)			{ m_dwBytesTransferred += dwRxBytes; }
d358 1
a358 1
	uint32	m_dwBytesTransferred;
@


1.200
log
@Simplified/speeded up processing of partfile status.
@
text
@d247 1
a247 1
	uint32	GetCompletedSize() const				{ return m_dwCompletedSize; }
d252 1
a252 1
	uint32	GetSessionTransferred()					{ return ((m_dwCompletedSize > m_SessionStartSize) ? (m_dwCompletedSize - m_SessionStartSize) : 0); }
d350 1
a350 1
	uint32	m_dwCompletedSize;
d383 1
a383 1
	uint32	m_SessionStartSize;
@


1.199
log
@Large file size support preparations.
@
text
@d86 2
a87 1
	EnumPartFileStatuses	GetStatus(bool ignorepause = false);
@


1.198
log
@Large file size support preparations.
@
text
@d273 1
a273 1
	int	ReadFileForUpload(uint32 dwOffset, uint32 dwBytesToRead, byte *pbyteBuffer);
@


1.197
log
@Large file size support preparations.
@
text
@d223 1
a223 1
	void	RemoveBlockFromList(uint32 start,uint32 end);
@


1.196
log
@Virtual function is not required for CreateFromFile (as it's used only for shared files);
Large file size support preparations.
@
text
@d153 1
a153 1
	bool	IsPartComplete(uint32 dwPart, uint32 *pdwStart, uint32 *pdwEnd) const;
d384 1
a384 1
	uint32	m_dwCompletedPartsSize;
@


1.195
log
@Removed unrequired/unused code.
@
text
@d216 1
a216 1
	uint32	GetGapsInPart(uint16 uPartNum, Requested_Block_Struct** ppNewBlocks, uint32 dwCount);
a262 1
	bool	CreateFromFile(char* directory,char* filename)	{return false;}
d297 1
a297 1
	bool	IsAlreadyRequested(uint32 start, uint32 end);
@


1.194
log
@Large file size support preparations.
@
text
@a157 1
	uint32	GetPartFilledSize(uint32 dwPartNum) const;
a161 1
	uint16	GetRemainingBlocksInPart(uint16 partnumber);
@


1.193
log
@Unicode corrections.
@
text
@d151 1
a151 1
	bool	IsComplete(uint32 start, uint32 end);
@


1.192
log
@Increased timeout (3->5 min) to flush buffered file data to reduce disk activity.
@
text
@d284 1
a284 1
	void	CharFillRange(CString* buffer,double start, double end, char color);
@


1.191
log
@Large file size support preparations.
@
text
@d45 1
a45 1
#define WARN_PERIOD_OF_NO_PROGRESS 7
d47 1
a47 1
#define BUFFER_TIME_LIMIT	180000   // Max milliseconds before forcing a flush // netwolf: increased to 3 minutes (be nice to your HDD :))
@


1.190
log
@Large file size support preparations.
@
text
@d114 1
a114 1
	uint32	GetSizeToTransfer() const				{ return m_dwGapsSum; }
d216 1
a216 1
	void	AddGap(uint32 start, uint32 end);
d306 1
a306 1
	CString DtLocale(CTime dt);
d309 1
a309 1
	CString GetStatsFullPath() const;
d408 1
a408 1
	uint32	m_dwGapsSum;
@


1.189
log
@Large file size support preparations.
@
text
@d315 2
a316 2
	void	FillGapInParts(uint32 dwGapStart, uint32 dwGapEnd);
	void	AddGapToParts(uint32 dwGapStart, uint32 dwGapEnd);
@


1.188
log
@Large file size support preparations;
Reduced H-file dependency.
@
text
@d217 1
a217 1
	void	FillGap(uint32 start, uint32 end);
@


1.187
log
@Preparations to process 64bit data packets.
@
text
@d16 1
a17 4
#pragma once
#ifndef NEW_SOCKETS_ENGINE
#include "stdafx.h"
#endif //NEW_SOCKETS_ENGINE
a20 3
#ifndef NEW_SOCKETS_ENGINE
#include "BarShader.h"
#endif //NEW_SOCKETS_ENGINE
d64 3
a66 3
	BYTE				*m_pbyteBuffer;		// This is the data to be written
	uint32				m_dwStartOffset;	// This is the start offset of the data
	uint32				m_dwEndOffset;		// This is the end offset of the data
@


1.186
log
@method declaration update due to SourceSaver changes; optimizations; formattings
@
text
@d237 1
a237 1
	uint32	WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 start, uint32 end, int iFlags);
@


1.185
log
@improved the source removement
@
text
@d300 1
a300 1
	CString	CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bIsSourceSaver = false);
@


1.184
log
@safe A4AF switch
@
text
@d190 2
a191 2
	void	GetCopySourceList(EnumDLQState eClientDS, ClientList *pCopy);
	void	GetCopySourceLists(uint32 dwListsMask, ClientList *pCopy);
d200 1
a200 1
	void	GetCopyA4AFSourceList(ClientList *pCopy);
@


1.183
log
@Removed unused code.
@
text
@d198 5
a326 2
	CTypedPtrList<CPtrList, CUpDownClient*> m_A4AFsrcList;

d382 1
@


1.182
log
@State Slotted Download Queue (SSDQ) [eklmn].
@
text
@a292 1
	uint32	GetCommonFilePenalty();
@


1.181
log
@1) name corrections
2) fixed the DL session cancel if remote client delays with sending of the first data block
3) added the "m_SourceLists" in header file
@
text
@a187 2
	void	AddDownloadingSource(CUpDownClient* client);
	void	RemoveDownloadingSource(CUpDownClient* client);
d190 1
a190 1
	void	GetCopySourceList(uint32 dwDS, ClientList *pCopy);
d193 1
d203 1
a203 1
	uint16	GetHighQRSrcCount()						{return m_iSrcHighQR;}
a318 1
	void	InvalidateRemoteQueueRankingStats()	{ m_uHighestRemoteQueueRank = 0; }
a322 1
	CTypedPtrList<CPtrList, CUpDownClient*> m_srcLists[SOURCESSLOTS];
a343 1
//	We don't need to count transferring sources, because we can get them over m_downloadingSourceList.GetCount()
d347 1
a347 1
	uint16	m_iSrcHighQR;
a350 1
	uint16	m_iSrcTimeout;
a351 2
	uint16	m_iSrcUnknown;
	uint16	m_iSrcRecHash;
d379 1
a379 2
	CTypedPtrList<CPtrList, CUpDownClient*> m_downloadingSourceList;
	ClientList m_SourceLists[DS_LAST_QUEUED_STATE];
a412 3
//	Highest QR (0=invalid) is used for precise source dropping
	uint16	m_uHighestRemoteQueueRank;

@


1.180
log
@One more step to integrate eklmn's SSDQ.
@
text
@d139 3
a141 3
	bool	HasComment() const		{return hasComment;}
	void	SetHasComment(bool in)			{hasComment=in;}
	void	AddPastComment(CUpDownClient *pClient);
d151 2
a152 2
	bool	HasRating() const			{return hasRating;}
	void	SetHasRating(bool in)			{hasRating=in;}
d387 1
d402 2
a403 2
	bool	hasRating;
	bool	hasComment;
@


1.179
log
@Removed some unrequired download queue statistics.
@
text
@d197 1
d385 1
a385 1
	CRITICAL_SECTION					m_csDownloadingSourceList;
@


1.178
log
@Removed unused or redundant code.
@
text
@a206 1
	uint16	GetTimeoutedSrcCount()					{return m_iSrcTimeout ;}
a207 2
	uint16	GetUnknownSrcCount()					{return m_iSrcUnknown;}
	uint16	GetRecHashsetSrcCount()					{return m_iSrcRecHash;}
@


1.177
log
@One more step to integrate eklmn's SSDQ.
@
text
@d320 3
a322 3
	void FillGapInParts(uint32 dwGapStart, uint32 dwGapEnd);
	void AddGapToParts(uint32 dwGapStart, uint32 dwGapEnd);
	void	InvalidateRemoteQueueRankingStats()	{ m_uHighestRemoteQueueRank = 0; m_uLowestRemoteQueueRank = 0xFFFF; }
a423 2
//	Lowest QR (0xFFFF=invalid) is currently only calculated but maybe used for the feature request #291 later
	uint16	m_uLowestRemoteQueueRank;
@


1.176
log
@One more step to integrate eklmn's SSDQ.
@
text
@a213 3
	uint16	GetNoUploadSrcCount()					{return m_iSrcNoUpload;}
	uint16	GetBannedSrcCount()						{return m_iSrcBanned;}
	uint16	GetErrorSrcCount()						{return m_iSrcError;}
a363 3
	uint16	m_iSrcBanned;
	uint16	m_iSrcNoUpload;
	uint16	m_iSrcError;
@


1.175
log
@Some eklmn's modifications.
@
text
@d211 2
a212 1
	uint16	GetLow2LowSrcCount()					{return m_iSrcLowToLow;}
d364 2
a365 1
	uint16	m_iSrcLowToLow;
@


1.174
log
@Changed return type of GetNotCurrentSourcesCount and GetValidSourcesCount.
@
text
@d205 1
a205 1
	uint16	GetTooManyConnsSrcCount()				{return m_iSrcTooManyConns;}
d357 1
a357 1
	uint16	m_iSrcTooManyConns;
@


1.173
log
@One more step to integrate eklmn's SSDQ.
@
text
@d217 2
a218 2
	uint16	GetNotCurrentSourcesCount();
	int		GetValidSourcesCount();
@


1.172
log
@The second step to integrate eklmn's SSDQ.
@
text
@d185 1
a185 1
	void	RemoveNoNeededSources(uint32 number_sources_to_remove = 0xffffffff);
d192 1
@


1.171
log
@Corrections for SSDQ integration.
@
text
@d193 3
@


1.170
log
@Simplified transition to eklmn's SSDQ.
@
text
@a30 4
//	TEMP - MOREVIT: I don't think the length of the download queue accurately gives the
//		number of transferring sources.
#define USE_TRANSFERRINGSRCCOUNT	1

d192 1
a192 1
	void	GetCopySourceList(uint32 dwDSBeg, uint32 dwDSEnd, ClientList *pCopy);
a195 1
#if USE_TRANSFERRINGSRCCOUNT
a196 3
#else
	uint16	GetTransferringSrcCount()				{return m_downloadingSourceList.GetCount();}
#endif
@


1.169
log
@Fixed saving and display of "Gained Due To Compression" global statistics.
@
text
@d196 2
@


1.168
log
@Cumulative statistics of lost due to corruption was always zero after restart {muleteer}.
@
text
@a263 1
	uint64	GetSessionGainDueToCompression() const	{return m_qwSessionGainDueToCompression;}
a373 1
	uint64	m_qwSessionGainDueToCompression;
@


1.167
log
@Removed some unused code.
@
text
@d124 1
a124 1
	void	GetSizeToTransfer(uint32& pui32SizeToTransfer);
d259 1
a259 1
	void	AddRxCorruptedAmount(uint32 dwBadBytes)	{m_qwLostDueToCorruption += dwBadBytes; m_qwSessionLostDueToCorruption += dwBadBytes;}
a263 1
	uint64	GetSessionLostDueToCorruption() const	{return m_qwSessionLostDueToCorruption;}
a374 1
	uint64	m_qwSessionLostDueToCorruption;
@


1.166
log
@Renaming.
@
text
@a166 2
	bool	IsMovieChunk(byte mode,uint16 chunk);
	bool	IsBetterMovieChunk(uint16 oldchunk,uint16 newchunk);
@


1.165
log
@minor improvement, name formating
@
text
@d223 1
a223 1
	uint16	GetCompleteSourcesCount()				{return m_nLastCompleteSrcCount;}
d397 1
a397 1
	uint16	m_MaxSrcPartFrequency;
d421 1
a421 1
	uint16	m_nLastCompleteSrcCount;
@


1.164
log
@Removed unused variable.
@
text
@d228 1
a228 1
	uint32	GetGapsInPart(uint16 numPart, Requested_Block_Struct** newblocks, uint32 dwCount);
@


1.163
log
@Variables renaming.
@
text
@d66 1
a66 1
#define FREE_TO_DL 					0x00
d74 3
a76 3
	BYTE				*m_pbyteBuffer;		// Barry - This is the data to be written
	uint32				m_dwStartOffset;	// Barry - This is the start offset of the data
	uint32				m_dwEndOffset;		// Barry - This is the end offset of the data
d186 1
a186 1
	void	AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);	//???
a187 1
	void	AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);	//???
d257 2
a258 2
	uint32	GetTransferred() const				{return m_dwBytesTransferred;}
	uint32	GetCompletedSize()						{ return m_dwCompletedSize; }
d339 2
a340 2
	volatile bool 	m_bRecoveringArchive;
	volatile bool 	m_bPreviewing;
d356 1
a356 1
//	Statistic
a416 1
	DWORD	m_dwLastRefreshedDLDisplayTime;
@


1.162
log
@More ifdefs for v2
@
text
@d266 1
a266 1
	uint64	GetGainDueToCompression() const			{return m_iGainDueToCompression;}
d268 1
a268 1
	uint64	GetSessionGainDueToCompression() const	{return m_iSessionGainDueToCompression;}
d378 1
a378 1
	uint64	m_iGainDueToCompression;
d380 1
a380 1
	uint64	m_iSessionGainDueToCompression;
@


1.161
log
@Added output folder to Downloadlist tooltips.
Added context menu indicator if alternative destination folder is used.
@
text
@d18 1
d20 1
d24 1
d26 1
@


1.160
log
@Removed code which became useless.
@
text
@d124 1
a124 1
	CString	GetFullName() const	{return m_strFullName;}
d126 1
a126 1
	CString	GetTempDir() const		{return m_strTempDir;}
d129 1
@


1.159
log
@Removed unused code.
@
text
@d237 1
a237 1
	uint32	WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 start, uint32 end, Requested_Block_Struct *block, int iFlags);
d338 1
a338 1
	bool 		m_bHashSetNeeded;
@


1.158
log
@It seems that I corrupted something by the previous commitment.
@
text
@d289 1
a289 1
	void	UpdateDisplayedInfo(bool bForce = false);
@


1.157
log
@Fixed 'Get first/last chunks for preview' menu item processing
(splitting from preview setting as they're not related).
@
text
@d96 1
a96 1
	bool	IsPartFile() const			{return !(m_eStatus == PS_COMPLETE);}
@


1.156
log
@Fixed collisions caused attempt loss while downloading the same part from several sources
(as a result a download attempt was lost as well as the source became useless for a while).
@
text
@d96 1
a96 1
	bool	IsPartFile()		{return !(m_eStatus == PS_COMPLETE);}
d101 1
a101 1
	bool	IsPreallocated() 			{ return m_bIsPreallocated; }
d103 6
a108 5
	bool	IsArchive(bool onlyPreviewable=false);
	bool	IsMovie() 				{ return m_bIsMovie; }
	bool	IsAviMovie() 				{ return m_bIsAviMovie; }
	bool	IsMpgMovie() 				{ return m_bIsMpgMovie; }
	bool	IsMpgAudio() 				{ return m_bIsMpgAudio; }
@


1.155
log
@Detailed file parts information.
@
text
@d223 1
a223 1
	void	GetGapsInPart(CUpDownClient* sender, uint16 numPart, Requested_Block_Struct** newblocks, uint16* count); //jicxicmic
d229 2
a230 2
	bool 	IsLastBlockComplete();
	void 	RemoveBlockFromList(uint32 start,uint32 end);
d232 1
a232 1
	void 	RemoveAllRequestedBlocks(void);
a307 1
	bool	GetNextEmptyBlockInPart(uint16 partnumber,Requested_Block_Struct* result);
@


1.154
log
@Removed some strange declarations (I guess they're old).
@
text
@d159 1
@


1.153
log
@Improved ICR to better select rare chunks for download and use less resources.
@
text
@a398 2
	static	CBarShader s_LoadBar;
	static	CBarShader s_ChunkBar;
@


1.152
log
@Correction to show 100% completion for completed files.
@
text
@a58 2
#define PARTIALLY_BLOCKED			0x00FFFFFE
#define FULLY_BLOCKED				0x00FFFFFD
d60 3
a62 1
#define FREE_TO_DL 					0x00000000
a393 1
	CArray<int,int> m_BlockedParts;
@


1.151
log
@Changed the way we use backup files for .part.met (more user friendly)
Removed old code not needed.
@
text
@d266 1
a266 1
	double	GetPercentCompleted2() const			{return (m_dblPercentCompleted > 99.99) ? 99.99 : m_dblPercentCompleted;}
@


1.150
log
@Don't report 100.00% completed for file with minor amount left to download {vendetta7}.
@
text
@d275 1
@


1.149
log
@Fixed auto-assignment issue to category (represented by temporary directory for category).
@
text
@d264 3
a266 1
	double	GetPercentCompleted()					{return m_dblPercentCompleted;}
@


1.148
log
@Changed the way we decide to save part.met on SetCatID call
@
text
@d59 2
a60 2
#define PARTIALLY_BLOCKED 			0x00FFFFFE
#define FULLY_BLOCKED 				0x00FFFFFD
d122 1
a122 1
	void 	SetFileName(const CString& NewName, bool bClearName = true);
d127 1
a127 1
	void 	SetAlternativeOutputDir(CString* path);
d132 1
a132 1
	void	SetPriority(byte np);
d167 4
a170 4
	uint16 	GetSrcPartFrequency(uint16 part) { return m_srcPartFrequencies[part]; }
	uint16 	GetRemainingBlocksInPart(uint16 partnumber);
	uint32 	GetAvailablePartCount() const	{return m_dwAvailablePartsCount;}
	void 	GetFirstLastChunk4Preview();
d173 3
a175 3
	void 	PartFileHashFinished(CKnownFile* result);
	bool 	HashSinglePart(uint32 dwPartNum); // true = ok , false = corrupted
	void 	NewSrcPartsInfo();
d178 5
a182 5
	void 	AddClientSource(CClientSource* pSource, int iSource=0, bool bExchanged=false, byte byteSourceExchangeVersion = 0);
	void 	AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);	//???
	void 	AddClientSources(CMemFile* sources, byte sourceexchangeversion = 1);
	void 	AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);	//???
	void 	AddSources(CMemFile& pSources, uint32 iServerIP, uint16 iServerPort);
d184 7
a190 7
	void 	GetSourcesAfterServerConnect();
	void 	RemoveNoNeededSources(uint32 number_sources_to_remove = 0xffffffff);
	void 	RemoveAllSources(bool bTryToSwap);
	void 	DownloadAllA4AF(bool bSameCat = false);
	void 	AddDownloadingSource(CUpDownClient* client);
	void 	RemoveDownloadingSource(CUpDownClient* client);
	void 	GetCompleteSourcesRange(uint16 *lo, uint16 *hi)	{*lo= *hi= GetCompleteSourcesCount();}
d238 2
a239 2
	void 	SetStartTimeReset(bool bEnable)		{m_StartTimeReset = bEnable;}
	bool 	GetStartTimeReset()					{return m_StartTimeReset;}
d246 2
a247 2
	void 	SetLastAnsweredTime()			{ m_ClientSrcAnswered = ::GetTickCount(); }
	void 	SetLastAnsweredTimeTimeout()	{ m_ClientSrcAnswered = 2 * CONNECTION_LATENCY + ::GetTickCount() - SOURCECLIENTREASK; }
d250 1
a250 1
//	file statistic (session & comulative)
d252 1
a252 1
	uint32	GetCompletedSize()   					{ return m_dwCompletedSize; }
d254 2
a255 2
	void 	AddRxAmount(uint32 dwRxBytes)			{ m_dwBytesTransferred += dwRxBytes; }
	void 	AddRxCorruptedAmount(uint32 dwBadBytes)	{m_qwLostDueToCorruption += dwBadBytes; m_qwSessionLostDueToCorruption += dwBadBytes;}
d263 1
a263 1
	void 	UpdateCompletedInfos();
d267 1
a267 1
	void 	FlushBuffer(void);
d269 10
a278 10
	bool 	CreateFromFile(char* directory,char* filename)	{return false;}
	bool 	LoadFromFile(FILE* file)						{return false;}
	bool 	WriteToFile(FILE* file)							{return false;}
	bool 	LoadPartFile(LPCTSTR in_directory, LPCTSTR filename);
	bool 	SavePartFile();
	void 	WritePartStatus(CFile* file);
	void 	WriteCompleteSourcesCount(CFile* file);
	void 	LoadSettingsFile();
	void 	SaveSettingsFile();
	bool 	SavePartFileStats();
d285 3
a287 3
	CString GetPartFileStatus();
	CString GetProgressString(uint16 size);
	void 	CharFillRange(CString* buffer,double start, double end, char color);
d435 5
a439 5
	bool 	m_bIsPreviewableArchive;
	bool 	m_bIsMovie;
	bool 	m_bIsAviMovie;
	bool 	m_bIsMpgMovie;
	bool 	m_bIsMpgAudio;
@


1.147
log
@More fixes for temp_dir_cat
@
text
@d145 1
a145 1
	void			SetCatID(EnumCategories eCatID, bool bNoSave = false);
a440 1

@


1.146
log
@Customizable temporary directory for categories
@
text
@d145 1
a145 1
	void			SetCatID(EnumCategories eCatID);
@


1.145
log
@Reduced system load caused by recovery of uncompressed RX stream
(unfortunately it increased amount of additional redownloaded data by I.C.H).
@
text
@d85 4
a88 4
	CPartFile(CSearchFile* searchresult);
	CPartFile(CString edonkeylink);
	CPartFile(class CED2KFileLink* fileLink);
	void	InitializeFromLink(CED2KFileLink* fileLink);
@


1.144
log
@final (at least i hope so) optimization for processing of file extension
@
text
@d232 4
a235 1
	uint32	WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 start, uint32 end, Requested_Block_Struct *block, bool bFreeBuff);
@


1.143
log
@simplified code and removed some unneeded checks, added dynamic droplimit, added not to drop queuefull until asked twice, added preferences option with import of old ini parameter
@
text
@d104 4
a107 3
	bool	IsMovie();
	bool	IsAviMovie();
	bool	IsMpgMovie();
d122 1
d431 6
@


1.142
log
@fixed switching between limited & limitless DL; improved bandwidth control for  limited DL; fixed request of hashset
@
text
@d425 1
a425 1
//	Highest QR (0=invalid) is used for precise source dropping when "leave remote queue if qr >" is enabled
@


1.141
log
@Fixed very rare possibility to upload and report unverified chunks;
Optimization of the new part status processing; Removed unused code.
@
text
@a391 1
	uint32	m_nSavedReduceDownload;
@


1.140
log
@(final) improved dropping of sources
@
text
@d46 1
a46 1
	PS_ACTIVE			= 23,	//MOREVIT - Dummy status = Downloading || on queue
d55 1
a55 1
// definens for status of filed parts
d57 5
a61 3
#define NOT_AVAILABLE				0xFFFFFFEF
#define PARTIALLY_BLOCKED 			0xFFFFFFEE
#define FULLY_BLOCKED 				0xFFFFFFED
d153 7
a159 7
	bool 	HasParts();
	bool 	IsComplete(uint32 start, uint32 end);
	bool 	IsPartComplete(uint32 dwPart);
	bool 	IsPartComplete(uint32 dwPart, uint32 *pdwStart, uint32 *pdwEnd);
	bool 	IsCorruptedPart(uint32 dwPartNum)		{return ((PART_CORRUPTED & m_PartsStatusVector[dwPartNum]) != 0);}
	bool 	IsMovieChunk(byte mode,uint16 chunk);
	bool 	IsBetterMovieChunk(uint16 oldchunk,uint16 newchunk);
d161 2
a162 2
	uint32	GetPartFilledSize(uint32 dwPartNum)	{return (0x00FFFFFF & m_PartsStatusVector[dwPartNum]);}
	uint32	GetPartLeftToDLSize(uint32 dwPartNum);
d315 2
a316 2
	void	FillGapInParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd);
	void	AddGapToParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd);
@


1.139
log
@improved dropping and counting of sources
@
text
@d235 1
a235 1
	uint32	GetLastPurgeTime()					{ return dwLastPurgeTime; }
d246 1
a246 1
	uint32	GetDataRate()							{return m_dataRate;}
d313 3
a315 3

	void FillGapInParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd);
	void AddGapToParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd);
a359 1

d366 1
a366 1
	uint32	m_dataRate;
d376 1
a376 1
	uint32	dwLastPurgeTime;
d424 4
@


1.138
log
@1) corrected bug founded by SyruS
2) corrupted status will be stored in part status vector
@
text
@d235 1
a235 1
	uint32	GetLastPurgeTime(){ return lastpurgetime; }
d238 1
a238 1
	CTime	GetLastDownTransfer() const {return m_timeLastDownTransfer;};
d245 1
a245 1
	uint32	GetCompletedSize()   				{return completedsize;}
d250 1
a250 1
	uint32	GetSessionTransferred()				{return (completedsize > m_SessionStartSize ? completedsize - m_SessionStartSize : 0);}
d287 1
a287 1
	uint32	Process(uint32 reducedownload, uint32 iteration);
d326 1
a327 1

d340 1
a340 1
	uint16		count;
d361 1
a361 1
	uint32	completedsize;
d377 1
a377 1
	uint32	lastpurgetime;
a391 1
	bool	m_bPercentUpdated;
@


1.137
log
@minor correction
@
text
@d56 1
a56 1
#define RECALCULATION_REQUIRED	0xFFFFFFFF
d155 1
a155 1
	bool 	IsCorruptedPart(uint16 partnumber);
d170 1
a170 1
	bool 	HashSinglePart(uint16 partnumber); // true = ok , false = corrupted
a292 5
//	are those function used???
	//bool	IsVLCInstalled();
	//bool 	Movie1(byte mode,uint16 oldchunk,uint16 newchunk);
	//bool 	Movie2(byte mode,byte raremovie,bool forcepreview,uint16 oldchunk,uint16 newchunk);

a388 1
	CList<uint16,uint16>	corrupted_list;
@


1.136
log
@caching of part size in part status vector
@
text
@d319 2
a320 2
	void __fastcall FillGapInParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd);
	void __fastcall AddGapToParts(uint32 dwPart, uint32 dwGapStart, uint32 dwGapEnd);
@


1.135
log
@Added IsPartComplete services to minimize number of not quite correct calculations,
to simplify sources and to make a fundament for future fixing of the old problem.
@
text
@d55 7
d159 3
a163 1
	uint32 	GetBytesInPart(uint16 partnumber, bool left2DL = false, bool dontRecalculate = false);
d319 3
d389 1
a389 1
	CArray<uint32,uint32> m_ReqParts;
@


1.134
log
@'Download from all A4AF sources (same category)' feature
@
text
@d23 1
a23 1
#include "sourcesaver.h"
d146 2
@


1.133
log
@the removed function was used :O... some roll back
@
text
@d172 1
a172 1
	void 	DownloadAllA4AF();
@


1.132
log
@1) removed unused code
2) renamed the function
@
text
@d153 1
@


1.131
log
@function & variables were splitted, functions were sorted
@
text
@d150 1
a212 2
	uint16	GetNextRequestedBlock(CUpDownClient* sender);
	uint16	GetRemainingBlocksInPart(uint16 partnumber);
@


1.130
log
@Unused service PrepareComparePart is removed.
@
text
@d61 9
a69 3
	BYTE					   *m_pbyteBuffer;		// Barry - This is the data to be written
	uint32						m_dwStartOffset;	// Barry - This is the start offset of the data
	uint32						m_dwEndOffset;		// Barry - This is the end offset of the data
d82 26
a107 9
	bool	CreateFromFile(char* directory,char* filename)	{return false;}
	bool	LoadFromFile(FILE* file)						{return false;}
	bool	WriteToFile(FILE* file)							{return false;}
	bool	IsPartFile()									{return !(m_eStatus == PS_COMPLETE);}
	uint32	Process(uint32 reducedownload, uint32 iteration);
	bool	LoadPartFile(LPCTSTR in_directory, LPCTSTR filename);
	bool	SavePartFile();
	void	PartFileHashFinished(CKnownFile* result);
	bool	HashSinglePart(uint16 partnumber); // true = ok , false = corrupted
d109 1
d111 10
a120 14
	void	AddGap(uint32 start, uint32 end);
	void	FillGap(uint32 start, uint32 end);
	void	DrawStatusBar(CDC* dc, RECT* rect, bool bFlat);
	bool	IsComplete(uint32 start, uint32 end);
	bool	IsCorruptedPart(uint16 partnumber);
	void	UpdateCompletedInfos();
	void	GetGapsInPart(CUpDownClient* sender, uint16 numPart, Requested_Block_Struct** newblocks, uint16* count); //jicxicmic
	uint16	GetNextRequestedBlock(CUpDownClient* sender);
	void	WritePartStatus(CFile* file);
	bool	HasParts();
	void	WriteCompleteSourcesCount(CFile* file);
	void	AddSources(CMemFile& pSources, uint32 iServerIP, uint16 iServerPort);
	EnumPartFileStatuses	GetStatus(bool ignorepause = false);
	void	NewSrcPartsInfo();
a121 4
	CString	GetPartMetFileName() const				{return m_strPartMetFileName;}
	uint32	GetTransferred() const					{return m_dwBytesTransferred;}
	void	AddRxAmount(uint32 dwRxBytes)			{ m_dwBytesTransferred += dwRxBytes; }
	void	AddRxCorruptedAmount(uint32 dwBadBytes)	{m_qwLostDueToCorruption += dwBadBytes; m_qwSessionLostDueToCorruption += dwBadBytes;}
d123 53
a175 2
	CString	GetFullName() const						{return m_strFullName;}
	CString	GetTempDir() const						{return m_strTempDir;}
a176 1
	uint32	GetDataRate()							{return m_dataRate;}
d198 1
a198 1
	uint16  GetNotCurrentSourcesCount();
d202 4
a205 27
	double	GetPercentCompleted()					{return m_dblPercentCompleted;}
	void	GetCompleteSourcesRange(uint16 *lo, uint16 *hi)	{*lo= *hi= GetCompleteSourcesCount();}
	bool	IsMovie();
	bool 	IsAviMovie();
	bool 	IsMpgMovie();
	bool 	IsMovieChunk(byte mode,uint16 chunk);
	bool 	IsBetterMovieChunk(uint16 oldchunk,uint16 newchunk);
	bool 	Movie1(byte mode,uint16 oldchunk,uint16 newchunk);
	bool 	Movie2(byte mode,byte raremovie,bool forcepreview,uint16 oldchunk,uint16 newchunk);
	void 	GetFirstLastChunk4Preview();
	bool	IsArchive(bool onlyPreviewable=false);
	CString GetPartFileStatus();
	int		GetPartFileStatusID();
	sint32	GetTimeRemaining(bool bAvgerage = false);
	CTime	lastseencomplete;
	int		GetPartFileStatusRang();
	void	SetStartTimeReset(bool bEnable)		{m_StartTimeReset = bEnable;}
	bool	GetStartTimeReset()					{return m_StartTimeReset;}
	uint32	GetAvgDataRate(bool bUpdated = false);
	uint32	GetSessionTransferred()				{return (completedsize > m_SessionStartSize ? completedsize - m_SessionStartSize : 0);}
	CTimeSpan GetFlushTimeSpan()				{return (m_timeLastDownTransfer - m_SessionStartTime);}
	CTimeSpan GetSessionTimeSpan()				{return (CTime::GetCurrentTime() - m_SessionStartTime);}
	CFile	&GetPartFileHandle()				{return m_hPartFileRead;}

	uint32	WriteToBuffer(sint32 iCompressionGain, BYTE *data, uint32 start, uint32 end, Requested_Block_Struct *block, bool bFreeBuff);
	void	FlushBuffer(void);

d210 5
a214 2
	// Barry - Is archive recovery in progress
	volatile bool m_bRecoveringArchive;
d216 2
a217 1
	void	RemoveAllRequestedBlocks(void);
d219 11
a229 12
	uint16  CPartFile::GetRemainingBlocksInPart(uint16 partnumber);
	void	RemoveBlockFromList(uint32 start,uint32 end);
	void	RemoveAllSources(bool bTryToSwap);
	void	DeleteFile();
	void	StopFile(bool bUpdateDisplay = true);
	bool	IsPaused() const				{return m_bPaused;}
	bool	IsStopped() const				{return m_bStopped;}
	bool	IsStalled() const;
	bool	IsCompleting() const			{return (m_eStatus == PS_COMPLETING);}
	void	PauseFile();
	void	ResumeFile();
	void	GetSourcesAfterServerConnect();
a230 2
	virtual	Packet* CreateSrcInfoPacket(CUpDownClient* ForClient);
	void	AddClientSources(CMemFile* sources, byte sourceexchangeversion = 1);
d232 8
a239 8
	void	PreviewFile();
	bool	PreviewAvailable();
	bool	IsVLCInstalled();
	uint32	GetAvailablePartCount() const	{return m_dwAvailablePartsCount;}

	uint32	GetLastAnsweredTime()			{ return m_ClientSrcAnswered; }
	void	SetLastAnsweredTime()			{ m_ClientSrcAnswered = ::GetTickCount(); }
	void	SetLastAnsweredTimeTimeout()	{ m_ClientSrcAnswered = 2 * CONNECTION_LATENCY + ::GetTickCount() - SOURCECLIENTREASK; }
d245 2
a246 6
	bool	HasComment() const						{return hasComment;}
	bool	HasRating() const						{return hasRating;}
	EnumPartFileRating		GetRating();
	void	SetHasComment(bool in)			{hasComment=in;}
	void	SetHasRating(bool in)			{hasRating=in;}
	void	UpdateFileRatingCommentAvail();
d248 14
a261 2
	uint32	GetCommonFilePenalty();
	void	UpdateDisplayedInfo(bool bForce = false);
a262 41
	void	GetSizeToTransfer(uint32& pui32SizeToTransfer);

	byte*	MMCreatePartStatus();

	volatile bool m_bPreviewing;

	uint16	GetSrcPartFrequency(uint16 part) { return m_srcPartFrequencies[part]; }

	void	UpdateDownloadAutoPriority(void);
	bool	IsAutoPrioritized() 					{ return m_bAutoPriority ; }
	void	SetAutoPriority(bool newAutoPriority) 	{ m_bAutoPriority = newAutoPriority ; }
	void	RemoveNoNeededSources(uint32 number_sources_to_remove = 0xffffffff);

	void	LoadSettingsFile();
	void	SaveSettingsFile();

	EnumCategories	GetCatID() const;
	void			SetCatID(EnumCategories eCatID);

	void	AllocateNeededSpace();
	bool	IsLastBlockComplete();
	bool	IsPreallocated() 						{ return m_bIsPreallocated; }
	static DWORD WINAPI AllocateNeededSpaceProc(LPVOID lpParameter);

	void	AddPastComment(CUpDownClient *pClient);
	void	RemovePastComment(CUpDownClient *pClient, bool bRestore= true);
	CPastCommentList &GetPastCommentList()			{ return m_pastCommentList; }
	int		ReadFileForUpload(uint32 dwOffset, uint32 dwBytesToRead, byte *pbyteBuffer);

	bool	SavePartFileStats();
	uint32	GetCompletedSize()   {return completedsize;}
	CTime	GetLastDownTransfer() const {return m_timeLastDownTransfer;};
	void	AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);
	void	AddClientSource(CClientSource* pSource, int iSource=0, bool bExchanged=false, byte byteSourceExchangeVersion = 0);
	void	AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);
	CString	CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bIsSourceSaver = false);
	void	SetAlternativeOutputDir(CString* path);
	CString	GetOutputDir();

	CString	LocalizeLastSeenComplete()	{return DtLocale(lastseencomplete);}
	CString	LocalizeLastDownTransfer()	{return DtLocale(m_timeLastDownTransfer);}
d264 4
d272 9
a280 5
	void 	DownloadAllA4AF();
	void	AddDownloadingSource(CUpDownClient* client);
	void	RemoveDownloadingSource(CUpDownClient* client);
	uint32 	GetBytesInPart(uint16 partnumber, bool left2DL = false, bool dontRecalculate = false);
	void	SetStatus(EnumPartFileStatuses eNewStatus);
d282 4
a285 1
	uint32	GetLastPurgeTime(){ return lastpurgetime; }
d297 25
d331 1
a331 1
	uint16			count;
a417 16
private:
	CString DtLocale(CTime dt);
	BOOL	PerformFileComplete();
	static UINT CompleteThreadProc(CPartFile* pFile);
	CString GetStatsFullPath() const;
	bool	LoadPartFileStats();
	void	RemovePartFileStats();
	void	ClosePartFile();
	void	UpdateGUIAfterStateChange();
	void	GetGapListCopy(CArray<Gap_Struct, Gap_Struct> *pGapArray);

public:
	CTypedPtrList<CPtrList, CUpDownClient*> m_srcLists[SOURCESSLOTS];
	CTypedPtrList<CPtrList, CUpDownClient*> m_A4AFsrcList;

	bool	m_bHashSetNeeded;
a419 5
struct PAThreadParam
{
	uint32		iPosition;
	CPartFile*	cPartFile;
};
@


1.129
log
@Minimized time of synchronization object ownership during gap list processing.
@
text
@a145 1
	byte 	PrepareComparePart(uint16 chunk);
@


1.128
log
@Optimization and formatting.
@
text
@d381 1
@


1.127
log
@some optimization of StatusBar drawing
@
text
@a347 1
	double	m_dblPercentCompletedPartsSize;
@


1.126
log
@Reinstated part of the change
@
text
@d348 2
a349 2
	double	m_dblPercentConfirmed;
	uint32	confirmedsize;
@


1.125
log
@Reverted some code and fixed another log line
@
text
@d177 1
a177 1
	void	StopFile();
d210 1
a210 1
	void	UpdateDisplayedInfo(boolean bForce=false);
@


1.124
log
@optimization of gap sum calculation :)
@
text
@d177 1
a177 1
	void	StopFile(bool bCancel = true);
@


1.123
log
@WebServer: added Get First/Last chunk for Preview
@
text
@d371 2
@


1.122
log
@removed m_uMedian
@
text
@d145 1
@


1.121
log
@Added UpdateGUIAfterStateChange service; minor reorganization.
@
text
@d283 1
a283 1
	bool				m_bDataFlushReq;
a326 1
	uint16	m_uMedian;
a328 1
	//CArray<CUpDownClient*, CUpDownClient*> m_BlockedParts;
d351 1
a351 1
	bool	m_bIsFakesDotRar;	// for Fakes.rar
@


1.120
log
@:) forgot to remove some unneeded m_bUpdateCompleteSrcCount
@
text
@d66 2
a67 1
class CPartFile : public CKnownFile {
d240 28
a275 1
	bool				m_bDataFlushReq;
d283 1
a348 1
	bool	m_StartTimeReset;
d351 1
d353 1
d372 1
d380 1
a382 3
	bool	SavePartFileStats();


a386 31

	uint32	GetCompletedSize()   {return completedsize;}

public:
	CTime	GetLastDownTransfer() const {return m_timeLastDownTransfer;};
	void	AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);
	void	AddClientSource(CClientSource* pSource, int iSource=0, bool bExchanged=false, byte byteSourceExchangeVersion = 0);
	void	AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);
	CString	CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bIsSourceSaver = false);
	void	SetAlternativeOutputDir(CString* path);
	CString	GetOutputDir();

	CString	LocalizeLastSeenComplete()	{return DtLocale(lastseencomplete);}
	CString	LocalizeLastDownTransfer()	{return DtLocale(m_timeLastDownTransfer);}

	CString GetProgressString(uint16 size);
	void 	CharFillRange(CString* buffer,double start, double end, char color);
	CString	GetDownloadFileInfo();
	CString	GetDownloadFileInfo4Tooltips();
	void 	DownloadAllA4AF();
	void	AddDownloadingSource(CUpDownClient* client);
	void	RemoveDownloadingSource(CUpDownClient* client);
	uint32 	GetBytesInPart(uint16 partnumber, bool left2DL = false, bool dontRecalculate = false);
	void	SetStatus(EnumPartFileStatuses eNewStatus);

	uint32	GetLastPurgeTime(){ return lastpurgetime; }

	bool	IsFakesDotRar() const						{ return m_bIsFakesDotRar; }
	void	SetFakesDotRar(bool bIsFakesDotRar = true)	{ m_bIsFakesDotRar = bIsFakesDotRar; }
private:
	bool	m_bIsFakesDotRar;	// for Fakes.rar
@


1.119
log
@(showtopic=5819) cpu-optimized update of complete sources counter; corrected calculation of available parts counter
@
text
@a331 1
	bool	m_bUpdateCompleteSrcCount;
@


1.118
log
@Fixed new compression gain calculation (the issue was created in 1.460).
@
text
@d133 1
a133 1
	uint16	GetCompleteSourcesCount();
@


1.117
log
@Lost data calculation didn't take corrupted compressed packets into consideration.
@
text
@d159 1
a159 1
	uint32	WriteToBuffer(uint32 dwCompressionGain, BYTE *data, uint32 start, uint32 end, Requested_Block_Struct *block, bool bFreeBuff);
@


1.116
log
@Fixed processing of corrupted compressed packets;
Fixed file transferred amount calculation; Removed unused members.
@
text
@d104 1
d195 7
a201 7
	uint64	GetLostDueToCorruption()		{return m_iLostDueToCorruption;}
	uint64	GetGainDueToCompression()		{return m_iGainDueToCompression;}
	uint64	GetSessionLostDueToCorruption()	{return m_iSessionLostDueToCorruption;}
	uint64	GetSessionGainDueToCompression(){return m_iSessionGainDueToCompression;}
	uint32	TotalPacketsSavedDueToICH()		{return m_iTotalPacketsSavedDueToICH;}
	bool	HasComment()					{return hasComment;}
	bool	HasRating()						{return hasRating;}
d277 1
a277 1
	uint64	m_iLostDueToCorruption;
d279 1
a279 1
	uint64	m_iSessionLostDueToCorruption;
@


1.115
log
@Removed Drop SuperCompressed blocks feature from GUI
@
text
@a63 1
	Requested_Block_Struct	   *block;				// Barry - This is the requested block that this data relates to
d102 2
a103 1
	uint32	GetTransferred()						{return m_dwBytesTransferred;}
d158 1
a158 2
	// Barry - Added as replacement for BlockReceived to buffer data before writing to disk
	uint32	WriteToBuffer(uint32 transize, BYTE *data, uint32 start, uint32 end, Requested_Block_Struct *block);
@


1.114
log
@new FakeCheck autoupdate system
@
text
@a236 4

	bool	GetDiscardSuperCompressed() {return m_bDiscardSuperCompressed;};
	void	SetDiscardSuperCompressed(bool discard_sc) {m_bDiscardSuperCompressed = discard_sc;};

a314 1
	bool	m_bDiscardSuperCompressed;
@


1.113
log
@minor changes (Partfile --> PartFile...)
@
text
@d390 5
@


1.112
log
@Fixed loss of client uploading turn during part file flushing and single part hashing;
Reworked file completion algorithm to eliminate file locking in completing state;
Added multi-thread protection for gaplist; Removed unused class members.
@
text
@d145 2
a146 2
	CString GetPartfileStatus();
	int		GetPartfileStatusID();
d149 1
a149 1
	int		getPartfileStatusRang();
@


1.111
log
@Removed unused stuff.
@
text
@d19 1
a19 1
#include "knownfile.h"
a52 1
// #define BUFFER_SIZE_LIMIT	500000 // Max bytes before forcing a flush
d156 1
a156 1
	CFile	&GetPartFileHandle()				{return m_hPartFile;}
a213 1
	CFile	m_hPartFile;
d218 1
a218 1
	void    UpdateDownloadAutoPriority(void);
d223 2
a224 2
	void   	LoadSettingsFile();
	void   	SaveSettingsFile();
d234 2
a235 2
	void AddPastComment(CUpDownClient *pClient);
	void RemovePastComment(CUpDownClient *pClient, bool bRestore= true);
d238 2
a239 5
public:
    bool	GetDiscardSuperCompressed() {return m_bDiscardSuperCompressed;};
    void	SetDiscardSuperCompressed(bool discard_sc) {m_bDiscardSuperCompressed = discard_sc;};

	void	SetFileUpload (bool bActive);
d241 1
a241 2
//	SyruS: moved from protected to public cause bugfix in CUpDownClient::CreateNextBlockPackage()
	CMutex 	m_FileCompleteMutex;
d254 4
a257 2
	HANDLE 	m_hCompletionEvent;
	LONG	m_dwNumUploadingClients;
d280 1
a280 1
	uint32  completedsize;
d285 1
a285 1
	uint32  m_iTotalPacketsSavedDueToICH;
a294 1
	bool	newdate;	// indicates if there was a writeaccess to the .part file
a317 1
	DWORD	m_LastRemovedTime;	//unused!
d319 1
a319 1
    bool	m_bDiscardSuperCompressed;
a321 1
	CString DtLocale(CTime dt);
d327 1
a327 1
	uint32  confirmedsize;
a330 2
	BOOL 	PerformFileComplete();
	static UINT CompleteThreadProc(CPartFile* pFile);
d334 2
a335 2
	uint32 	m_nTotalBufferData;
	uint32 	m_nLastBufferFlushTime;
d339 12
d354 1
a354 2

	CPastCommentList m_pastCommentList;
d365 1
a365 5
	uint32  GetCompletedSize()   {return completedsize;}

private:
    CTime   m_timeLastDownTransfer;
	CString m_strAlternativePath;
d368 5
a372 5
	CTime   GetLastDownTransfer() const {return m_timeLastDownTransfer;};
	void 	AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);
	void 	AddClientSource(CClientSource* pSource, int iSource=0, bool bExchanged=false, byte byteSourceExchangeVersion = 0);
	void 	AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);
	CString CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bIsSourceSaver = false);
d374 1
a374 1
	CString GetOutputDir();
d376 2
a377 2
	CString LocalizeLastSeenComplete()	{return DtLocale(lastseencomplete);}
	CString LocalizeLastDownTransfer()	{return DtLocale(m_timeLastDownTransfer);}
@


1.110
log
@Improved extensive hard drive access for simultaneous hashing and completion.
@
text
@a91 1
	bool	IsPureGap(uint32 start, uint32 end);
@


1.109
log
@Changed adding server soruces to allow same IP different port for testing purposes (thx DoubleT)
@
text
@a262 1
	static CMutex	s_CompletingMutex;
@


1.108
log
@Done some changes to allow transfers between clients on the same IP for testing purposes
@
text
@d23 2
a24 2
#include "sourcesaver.h" //<<-- enkeyDEV(Ottavio84) -New SLS-
#include "PastComment.h" // #zegzav:pastcomment
d62 1
a62 1
	BYTE					   *m_pbyteBuffer;				// Barry - This is the data to be written
d71 1
a71 1
	CPartFile(CSearchFile* searchresult);  //used when downloading a new file
d77 1
a77 1
	bool	CreateFromFile(char* directory,char* filename)	{return false;}// not supported in this class
d82 1
a82 1
	bool	LoadPartFile(LPCTSTR in_directory, LPCTSTR filename); //filename = *.part.met
d100 1
a100 1
	void	AddSources(CMemFile& sources,uint32 serverip, uint16 serverport);
d102 7
a108 7
	void		NewSrcPartsInfo();
	void		SetPriority(byte np);
	CString	GetPartMetFileName() const						{return m_strPartMetFileName;}
	uint32	GetTransferred()									{return m_dwBytesTransferred;}
	byte	GetPriority()									{return priority;}
	CString	GetFullName() const								{return m_strFullName;}
	CString	GetTempDir() const								{return m_strTempDir;}
d110 1
a110 1
	uint32	GetDataRate()									{return m_dataRate;}
d114 1
a114 1
	uint16	GetTransferringSrcCount()					{return m_downloadingSourceList.GetCount();}
d117 1
a117 1
	uint16	GetOnQueueSrcCount()						{return m_iSrcOnQueue;}
d121 4
a124 4
	uint16	GetConnectedSrcCount()						{return m_iSrcConnected;}
	uint16	GetTimeoutedSrcCount()						{return m_iSrcTimeout ;}
	uint16	GetConnectingViaServerSrcCount()			{return m_iSrcConnViaServer;}
	uint16	GetUnknownSrcCount()						{return m_iSrcUnknown;}
d126 3
a128 3
	uint16	GetLow2LowSrcCount()						{return m_iSrcLowToLow;}
	uint16	GetQueueFullSrcCount()						{return m_iSrcQueueFull;}
	uint16	GetNoUploadSrcCount()						{return m_iSrcNoUpload;}
d130 2
a131 2
	uint16	GetErrorSrcCount()							{return m_iSrcError;}
	uint16	GetSrcA4AFCount()							{return m_iSrcA4AF;}
d136 1
a136 1
	double	GetPercentCompleted()						{return m_dblPercentCompleted;}
d146 1
a146 1
	bool	IsArchive(bool onlyPreviewable=false); 				// Barry - Also want to preview archives
d152 2
a153 2
	void	SetStartTimeReset(bool bEnable)					{m_StartTimeReset = bEnable;}
	bool	GetStartTimeReset()								{return m_StartTimeReset;}
d155 4
a158 4
	uint32	GetSessionTransferred()	{return (completedsize > m_SessionStartSize ? completedsize - m_SessionStartSize : 0);}
	CTimeSpan GetFlushTimeSpan()	{return (m_timeLastDownTransfer - m_SessionStartTime);}
	CTimeSpan GetSessionTimeSpan()	{return (CTime::GetCurrentTime() - m_SessionStartTime);}
	CFile	&GetPartFileHandle()	{return m_hPartFile;}
d173 1
a173 1
	uint16  CPartFile::GetRemainingBlocksInPart(uint16 partnumber); //By Vorlost for load rarest chunks first
d212 1
a212 1
	void	GetSizeToTransfer(uint32& pui32SizeToTransfer);	// added by InterCeptor (xChipx: download statistics) 11.11.02
d216 1
a216 1
	CFile	m_hPartFile;	//permanent opened handle to avoid write conflicts
d221 1
a221 2
	// Added by Tarod
	void    UpdateDownloadAutoPriority(void);		// Added by Tarod for DAP
a224 1
	// End Tarod
a225 1
    // DonGato: storing settings for files
a231 1
	// DonGato: preallocate of space needed by a file
a236 1
	// #zegzav:pastcomment (BEGIN)
a239 1
	// #zegzav:pastcomment (END)
d247 2
a248 2
	//SyruS moved from protected to public cause bugfix in CUpDownClient::CreateNextBlockPackage()
	CMutex 	m_FileCompleteMutex; // Lord KiRon - Mutex for file completion
d257 1
a257 1
	CSourceSaver		m_sourcesaver; //<<-- enkeyDEV(Ottavio84) -New SLS-
d266 2
a267 2
	//statistic
	// we don't need to count a transferring sources, cause we can get them over m_downloadingSourceList.GetCount()
a284 1
	// <-----khaos-
d294 1
a294 1
	CString	m_strTempDir;	// InterCeptor (multiple tempdirs)
d341 1
a341 1
	static UINT CompleteThreadProc(CPartFile* pFile); // Lord KiRon - Used as separate thread to complete file
a343 1
	// Barry - Buffered data to be written
d376 1
a376 1
	CString CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bIsSourceSaver = false); //<<-- enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d390 1
a390 1
	uint32 	GetBytesInPart(uint16 partnumber, bool left2DL = false, bool dontRecalculate = false);	//eklmn: feature(00): ICR 2.10
@


1.107
log
@Final fix for download list crash after file deletion.
@
text
@d210 1
a210 1
	void	UpdateDisplayedInfo(boolean force=false);
d382 1
a382 1
	void 	AddClientSource(CClientSource* source, int i_Source=0, bool exchanged=false, byte sourceexchangeversion = 0);
@


1.106
log
@prevent call of KnowFile detructor for PartFile object (crash reported by Aw3)
@
text
@d80 1
a80 7
	bool	IsPartFile(bool bIgnoreCompleteStatus = false)
	{
		if (bIgnoreCompleteStatus)
			return true;
		else
			return !(m_eStatus == PS_COMPLETE);
	}
@


1.105
log
@Changed the Upload log... It seems I found something strange while doing this. :/
@
text
@d80 7
a86 1
	bool	IsPartFile()									{return !(m_eStatus == PS_COMPLETE);}
@


1.104
log
@Fixed display of Available Parts and Last Seen Complete for file size > 2.3 Gb.
@
text
@d177 1
a177 1
	void	StopFile();
@


1.103
log
@indirect flush of data to the disk if chunk was complete
@
text
@d192 1
a192 1
	byte   GetAvailablePartCount()			{return availablePartsCount;}
d325 1
a325 1
	byte	availablePartsCount;
@


1.102
log
@fix: upload auto priority isn't set to release anymore when completing file
@
text
@d263 2
a264 1
	CSourceSaver m_sourcesaver; //<<-- enkeyDEV(Ottavio84) -New SLS-
@


1.101
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d179 1
a179 1
	bool	IsStopped() const				{ return m_bStopped; }
d181 1
@


1.100
log
@ICR fix: prevent request of the part where does not left any empty block
@
text
@d103 1
a103 1
	void		SetPriority(uint8 np);
d106 1
a106 1
	uint8	GetPriority()									{return priority;}
d141 1
a141 1
	bool 	IsMovieChunk(uint8 mode,uint16 chunk);
d143 3
a145 3
	bool 	Movie1(uint8 mode,uint16 oldchunk,uint16 newchunk);
	bool 	Movie2(uint8 mode,uint8 raremovie,bool forcepreview,uint16 oldchunk,uint16 newchunk);
	uint8 	PrepareComparePart(uint16 chunk);
d186 1
a186 1
	void	AddClientSources(CMemFile* sources, uint8 sourceexchangeversion = 1);
d191 1
a191 1
	uint8   GetAvailablePartCount()			{return availablePartsCount;}
d213 1
a213 1
	uint8*	MMCreatePartStatus();
d304 1
a304 1
	uint8	priority;
d323 1
a323 1
	uint8	availablePartsCount;
d380 1
a380 1
	void 	AddClientSource(CClientSource* source, int i_Source=0, bool exchanged=false, uint8 sourceexchangeversion = 0);
@


1.99
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d317 2
a318 1
	CArray<CUpDownClient*, CUpDownClient*> m_BlockedParts;
@


1.98
log
@safe handling of DL-file-queue
@
text
@d76 1
a76 1
	
d85 1
a85 1
	bool	HashSinglePart(uint16 partnumber); // true = ok , false = corrupted	
d87 1
a87 1
	
d135 1
a135 1
	
d172 1
a172 1
	
d229 1
a229 1
	void   	SaveSettingsFile(); 
d254 1
a254 1
	
d296 1
a296 1
	uint32  m_iTotalPacketsSavedDueToICH; 
d326 1
a326 1
	static	CBarShader s_LoadBar; 
@


1.97
log
@recommit for "Completion Fix" with Aw3 correction
@
text
@d318 1
@


1.96
log
@fix for Scheduler shift on restart / fix for Preallocate handling of exceptions / eklmn fix for ICR
@
text
@d250 1
a250 1
//	void	SetFileUpload (bool bActive);
d265 2
a266 2
//	HANDLE 	m_hCompletionEvent;
//	LONG	m_dwNumUploadingClients;
@


1.95
log
@final fixes for ed2k source links
@
text
@a52 6
struct PAThreadParam
{
	uint32	iPosition;
	CFile*	cPartFile;
};

d399 6
@


1.94
log
@Reverted completion 'fix' by eklmn so we can release 1j this month
@
text
@d386 1
a386 1
	CString CreateED2KSourceLink(uint32 expirein, int sourcenum, bool bLog = true); //<<-- enkeyDEV(Ottavio84) -Create source ed2k from downloads-
@


1.93
log
@Some minor changes by KuSh.
@
text
@d256 1
a256 1
	void	SetFileUpload (bool bActive);
d271 2
a272 2
	HANDLE 	m_hCompletionEvent;
	LONG	m_dwNumUploadingClients;
@


1.92
log
@new way of syncronization by file completion
@
text
@d273 1
a273 1
	static CMutex	s_ComplitingMutex;
@


1.91
log
@Fixed debuglog problem with a SourceSaver change.
Reinstated removal of ? clients on queue.
@
text
@d256 2
d271 2
@


1.90
log
@some step to fix interim bug 0000437 (.bak files in incoming folder)
@
text
@d351 2
a352 2
	uint32 m_nTotalBufferData;
	uint32 m_nLastBufferFlushTime;
d379 4
a382 4
	void AddClientSources(CTypedPtrList<CPtrList, CClientSource*>*);
	void AddClientSource(CClientSource* source, int i_Source=0, bool exchanged=false, uint8 sourceexchangeversion = 0);
	void AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);
	CString CreateED2KSourceLink(uint32 expirein, int sourcenum); //<<-- enkeyDEV(Ottavio84) -Create source ed2k from downloads-
d390 1
a390 1
	void CharFillRange(CString* buffer,double start, double end, char color);
@


1.89
log
@Fix for corruption/compression gain problem
@
text
@d113 1
a113 1
	CString	GetFullName() const								{return fullname;}
d300 1
a300 1
	CString	fullname;
d316 1
a316 1
	uint16  median;
@


1.88
log
@New sockets - more server code
@
text
@d204 2
d296 2
@


1.87
log
@Formatting, comments, and name changes.
@
text
@d394 2
@


1.86
log
@free disk space needed is now determined with respect to NTFS compression and/or sparse files
@
text
@d68 4
a71 4
	BYTE	*data;						// Barry - This is the data to be written
	uint32	start;						// Barry - This is the start offset of the data
	uint32	end;						// Barry - This is the end offset of the data
	Requested_Block_Struct *block;		// Barry - This is the requested block that this data relates to
d111 1
a111 1
	uint32	GetTransferred()									{return transferred;}
d299 1
a299 1
	uint32	transferred;
@


1.85
log
@quantized sources request from the server
@
text
@d92 1
d215 1
a215 1
	void	GetSizeToTransferAndNeededSpace(uint32& pui32SizeToTransfer, uint32& pui32NeededSpace);	// added by InterCeptor (xChipx: download statistics) 11.11.02
@


1.84
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d304 1
a304 1
	uint32	lastsearchtime;
@


1.83
log
@Formatting, comments, and name changes.
... and a few bug fixes.
@
text
@d141 1
a141 1
	float	GetPercentCompleted()							{return percentcompleted;}
d316 1
a316 1
	float	percentcompleted;
d335 1
a335 1
	float	percentconfirmed;
d385 1
a385 1
	void CharFillRange(CString* buffer,float start, float end, char color);
@


1.82
log
@DownloadListCtrl rewrite.
Changed Category ID types to an enumeration.
More async update work.
The usual formatting, comments, and name changes.
@
text
@d342 1
a342 1
	DWORD	m_lastRefreshedDLDisplay;
@


1.81
log
@Formatting, comments, and name changes.
@
text
@d25 1
d234 2
a235 2
	uint8	GetCatID() const;
	void	SetCatID(uint8 catID);
d266 3
a268 3
	static	CMutex s_ComplitingMutex;
	uint8	m_iCategoryID;
	uint16	count;
@


1.80
log
@Formatting, comments, and name changes.
@
text
@d30 18
a47 14
#define PS_READY			0
#define PS_EMPTY			1
#define PS_WAITINGFORHASH	2
#define PS_HASHING			3
#define PS_ERROR			4
#define PS_UNKNOWN			6
#define PS_PAUSED			7
#define PS_COMPLETING		8
#define PS_COMPLETE			9
#define PS_STOPPED			10	//eklmn: added stop status
#define PS_DOWNLOADING		20	//MOREVIT - Dummy status
#define PS_WAITINGFORSOURCE	21	//MOREVIT - Dummy status
#define PS_STALLED			22	//MOREVIT - Dummy status
#define PS_ACTIVE			23	//MOREVIT - Dummy status = Downloading || on queue
a51 10
enum EnumPartFileRating
{
	PF_RATING_NONE = 0,
	PF_RATING_FAKE,
	PF_RATING_POOR,
	PF_RATING_GOOD,			//Fair and Good are reversed for some reason
	PF_RATING_FAIR,
	PF_RATING_EXCELLENT,
};

d85 1
a85 1
	bool	IsPartFile()									{return !(status == PS_COMPLETE);}
d105 1
a105 1
	uint8	GetStatus(bool ignorepause = false);
d301 1
a301 1
	uint8	status;
d391 1
a391 1
	void	SetStatus(uint8 in);
@


1.79
log
@Code formatting and fixes for preallocation (statistics)
@
text
@d106 1
a106 1
	uint16	GetNextRequestedBlock(CUpDownClient* sender);	//jicxicmic
d108 2
a109 2
	bool	HasParts(); // DbT:StartUploadReq
	void	WriteCompleteSourcesCount(CFile* file);	// netwolf: complete sources (zegzav) 13.05.03
d118 1
a118 1
	CString	GetTempDir() const								{return m_strTempDir;}	// added by InterCeptor (multiple tempdirs) 19.11.02
a119 1
	// statistical interface 
a120 1
	//sources
d144 1
a144 1
	uint16	GetCompleteSourcesCount();									// netwolf: complete sources (zegzav) 03.05.03
d146 1
a146 1
	float		GetPercentCompleted()							{return percentcompleted;}
d149 7
a155 7
	bool 	IsAviMovie(); 										//Vorlost for LoadRarestFinishedChunks Patch2
	bool 	IsMpgMovie(); 										//Vorlost for LoadRarestFinishedChunks Patch2
	bool 	IsMovieChunk(uint8 mode,uint16 chunk); 				//Vorlost for LoadRarestFinishedChunks Patch2
	bool 	IsBetterMovieChunk(uint16 oldchunk,uint16 newchunk);//Vorlost for LoadRarestFinishedChunks Patch2
	bool 	Movie1(uint8 mode,uint16 oldchunk,uint16 newchunk); //Vorlost for LoadRarestFinishedChunks Patch2
	bool 	Movie2(uint8 mode,uint8 raremovie,bool forcepreview,uint16 oldchunk,uint16 newchunk); //Vorlost for LoadRarestFinishedChunks Patch2
	uint8 	PrepareComparePart(uint16 chunk); 					//Vorlost for LoadRarestFinishedChunks Patch2
a161 1
	//bond006 (smoothed "remaining time" calculation) //SyruS
d166 1
a166 1
	CTimeSpan GetFlushTimeSpan()	{return (m_LastDownTransfer - m_SessionStartTime);}
d177 1
d193 1
a193 1
	void	GetSourcesAfterServerConnect(); // Added by Vorlost to load initial sources from Server after connect
a195 1
	//v1:- eklmn: support Source Exchange v2
d200 1
a200 1
	bool	IsVLCInstalled(); // DonGato
a201 1
	//void	UpdateAvailablePartsCount();
d226 1
a226 3
	//--- xrmb:sacrifice ---
	uint16	GetSrcpartFrequency(uint16 part) { return m_SrcpartFrequency[part]; }
	//--- :xrmb ---
d251 1
a251 1
	CPastCommentList &GetPastCommentList()			{ return m_PastComment; }
d315 1
a315 2
	CArray<uint16,uint16> m_SrcpartFrequency;
	//  v- eklmn: feature(00): ICR
a319 2
	//  ^- eklmn: feature(00): ICR
	// eklmn: download optimization
a328 1
	// Tarod 
a335 1
	//bond006 (smoothed "remaining time" calculation) //SyruS
a339 1
	//--- xrmb:confirmeddownload ---
a341 1
	//--- :xrmb ---
d345 1
a345 1
	BOOL 	PerformFileComplete(); // Lord KiRon
d353 1
a353 1
	uint16	m_nLastCompleteSrcCount;	// netwolf: complete sources (zegzav) 13.05.03
a355 1
	//--- xrmb:keepPartFileStats ---
a358 1
	//--- :xrmb ---
d360 1
a360 1
	CPastCommentList m_PastComment;		// #zegzav:pastcomment
d363 2
a364 3
	//--- xrmb:keepPartFileStats ---
	bool	SavePartFileStats();	// its called from the Download Queue/process
	//--- :xrmb ---
d366 2
d369 1
a369 3
	CTypedPtrList<CPtrList, CUpDownClient*> srclists[SOURCESSLOTS];
	// v1:- eklmn: A4AF management
	CTypedPtrList<CPtrList, CUpDownClient*> A4AF_srclist;
a370 1
	bool	hashsetneeded;							
d374 2
a375 2
    CTime   m_LastDownTransfer;   // obaldin
	CString m_strAlternativePath;	//<<-- enkeyDEV(Ottavio84) -ChangeDir-	
d378 1
a378 1
	CTime   GetLastDownTransfer() const {return m_LastDownTransfer;};// obaldin
a379 1
	//v1:- eklmn: support Source Exchange v2
a382 1
	// START - enkeyDEV(Ottavio84) -ChangeDir-
a384 1
	// END - enkeyDEV(Ottavio84 - -ChangeDir-
a385 1
	// Locale completed and downtimes
d387 1
a387 1
	CString LocalizeLastDownTransfer()	{return DtLocale(m_LastDownTransfer);}
@


1.78
log
@Preallocate feature and Localization fixes
@
text
@d242 2
a243 2
	void   	LoadFileSettings();
	void   	SaveFileSettings(); 
d251 1
a259 3
    // per-file control whether to drop supercompressed blocks [obaldin]
private:
    bool	m_bDiscardSuperCompressed;
d318 1
d342 3
a344 1
	
d393 1
@


1.77
log
@Final code merge from official for preview
@
text
@d58 6
d176 1
d248 5
d275 1
d277 1
a277 1
	
a416 1

@


1.76
log
@Formatting, comments, and name changes.
@
text
@a85 1
	bool	FirstLastLoaded();	//Cax2 - needed to disable the menu item
d152 1
a152 1
	bool	IsArchive();										// Barry - Also want to preview archives
@


1.75
log
@fix for errors on removing a file when no space on Temp disk (#0000284)
fix for queue filtering (forgot that the list is updated :P)
@
text
@d379 1
a379 1
	CString m_alternativepath;	//<<-- enkeyDEV(Ottavio84) -ChangeDir-	
@


1.74
log
@Formatting, comments, and name changes.
@
text
@d330 2
a331 1

d359 1
a359 1
	int		RemovePartFileStats();
@


1.73
log
@fix for signed/unsigned mismatch
@
text
@d392 2
a393 2
	CString localelastseencomplete()	{return DtLocale(lastseencomplete);}
	CString localelastdowntransfer()	{return DtLocale(m_LastDownTransfer);}
@


1.72
log
@Changed .movie files to .settings and added stopped status knowledge
@
text
@d214 1
a214 1
	int		GetCommonFilePenalty();
@


1.71
log
@Category rewrite with predefined status/media type categories.
@
text
@d235 3
a237 3
    // now used for other settings too, probably needs renaming [obaldin]
	void   	LoadMovieMode(); // DonGato 
	void   	SaveMovieMode(); // DonGato
@


1.70
log
@Formatting, comments, and name changes.
@
text
@d43 1
d239 2
a240 2
	int  GetCategory();
	void SetCategory(int iCategory);
d268 1
a268 1
	int		m_iCategory;
d365 1
a365 1
	bool	SavePartFileStats();	// its called from the m_pDownloadQueue/process
@


1.69
log
@Reinstated the transferring source count => Bad download state detection. Refixed GetStatus() (my booboo). Removed 'srcsarevisible'.
@
text
@a59 12
//--- xrmb:partprio ---
//--- moved to opcodes ---
/*
#define PR_VERYLOW			4 // I Had to change this because it didn't save negative number correctly.. Had to modify the sort function for this change..
#define PR_LOW				0 //*
#define PR_NORMAL			1 // Don't change this - needed for edonkey clients and server!
#define	PR_HIGH				2 //*
#define PR_VERYHIGH			3
#define PR_AUTO				5 // Added by Tarod
*/
//--- :xrmb ---

@


1.68
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d26 4
d129 3
d133 1
a383 1
	bool	srcarevisible; // used for m_wndDownloadList
@


1.67
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d368 1
a368 1
	bool	SavePartFileStats();	// its called from the downloadqueue/process
@


1.66
log
@More fixes (sharing of files, JS used with downloading files and other minor ones)
@
text
@d36 16
d116 2
a117 2
	CString	GetPartMetFileName() const						{return partmetfilename;}
	uint32	GetTransfered()									{return transfered;}
d120 1
a120 1
	CString	GetTempDir() const								{return tempdir;}	// added by InterCeptor (multiple tempdirs) 19.11.02
d123 1
a123 1
	uint32	GetDatarate()									{return datarate;}
d125 1
a125 1
	uint16	GetTransferingSrcCount()					{return m_downloadingSourceList.GetCount();}
d158 1
d165 2
a166 2
	uint32	GetAvgDatarate(bool bUpdated = false);
	uint32	GetSessionTransfered()	{return (completedsize > m_SessionStartSize ? completedsize - m_SessionStartSize : 0);}
d169 1
d187 3
a189 1
	bool	IsPaused()						{return paused;}
d212 1
a212 1
	int		GetRating();
d224 1
a224 1
	CFile	m_hpartfile;	//permanent opened handle to avoid write conflicts
d274 2
a275 2
	// we don't need to count a transfering sources, cause we can get them over m_downloadingSourceList.GetCount()
	//uint16 transferingsrc;
d298 1
a298 1
	uint32	datarate;
d300 5
a304 5
	CString	tempdir;	// InterCeptor (multiple tempdirs)
	CString	partmetfilename;
	uint32	transfered;
	bool	paused;
	bool	stopped;
d384 1
a384 1
	CTime   GetLastDownTransfer() {return m_LastDownTransfer;};// obaldin
d406 1
d408 1
a408 1
	uint32 	GetBytesInPart(uint16 partnumber, bool left2DL = false, bool dontRecalculate = false);	//eklmn: feature(00): ICR 2.10
@


1.65
log
@Fixed problem with moving category tabs (beware of CPartFile::SetPriority as it rebuilds the download list so any function using that feature *should* make a copy of it before proceeding).
@
text
@d284 1
@


1.64
log
@Fixed realtime update of filters.
@
text
@d222 1
a223 1
	int  GetCategory()								{ return m_iCategory; }
d251 1
a251 1
	int  m_iCategory;
@


1.63
log
@Fixed Category Autopriority
@
text
@d385 1
@


1.62
log
@*** empty log message ***
@
text
@d222 2
a223 2
	void SetCategory(int iCategory)	{ m_iCategory = iCategory;	}
	int  GetCategory()				{ return m_iCategory;		}
d228 1
a228 1
	CPastCommentList &GetPastCommentList()	{ return m_PastComment; }
@


1.61
log
@added past comments
@
text
@a221 1
#ifdef __USE_CATEGORIES__
a223 1
#endif
a250 1
#ifdef __USE_CATEGORIES__	
a251 1
#endif
d355 1
a355 1
	bool	srcarevisible; // used for downloadlistctrl
@


1.60
log
@new statistic (khaos based)
@
text
@d24 1
d227 6
d346 2
@


1.59
log
@*** empty log message ***
@
text
@d105 1
a105 1
	uint16	GetTransferingSrcCount()						{return transferingsrc;}
d107 18
a124 1
	float	GetPercentCompleted()							{return percentcompleted;}
d128 2
d250 21
a270 1
	uint16	transferingsrc;
@


1.58
log
@Purity's changes
@
text
@d202 5
d227 3
@


1.57
log
@updated complete sources (0.06b: display range of values)
@
text
@d182 2
@


1.56
log
@added new file state PS_STOPPED
@
text
@d111 1
a111 1
	uint8	GetCompleteSourcesAccuracy()					{return 0;}	// netwolf: complete sources (zegzav) 03.05.03
@


1.55
log
@SyruS (0.29c) bluecow: Fixed problem with completing file which was concurrently uploaded.
@
text
@d25 2
a26 2
#define	PS_READY			0
#define	PS_EMPTY			1
d30 1
a30 1
#define	PS_UNKNOWN			6
d34 1
@


1.54
log
@1) SLS during DL is blocked now
2) old SLS completly removed
3) new DL client speed measurement system
4) optmization in RemoveAllSources()
@
text
@d205 3
a214 1
	CMutex 	m_FileCompleteMutex; // Lord KiRon - Mutex for file completion
@


1.53
log
@Corrected problem with ' and JS in new WS context menu
Removed unused code for SLS
@
text
@a22 1
#include "StoredSources.h" //added mr fry
a94 64

	//////////////////////////////////////////////////
	//for saving sources: (by Mr.Fry)
#ifdef OLD_SLS_ENABLED
		//save a CStoredSources-object to disk (to [eMule Temp-Folder]\[this PartMetFile-Name].src)
		//this function should only be called by the other saving-functions
	bool	SaveSourcesToFile(CStoredSources* toSave, bool debug=false);
		//load all sources OF THIS part-file FROM DISK (from [eMule Temp-Folder]\[this PartMetFile-Name].src)
		//this function should only be called by the other loading-functions
		//returns NULL, if no file was found or could not be loaded
	CStoredSources*	LoadSourcesFromFile(bool debug=false);
		//load all sources OF THIS part-file from the CStoredSources-object
		//of this part-file
		//and add them as CUpDownClients to theApp.downloadqueue
		//
		//if (param) limit is not equal (default is -1) -1, then the count of sources
		//that are loaded at once is equally (param) limit
		//if (param) reset is true, the loaded-completely status is reset to false (-> load ALL sources again)
	bool	AddFromStoredSources(	  CStoredSources* storedSources
									, bool sendUDPRequest=false
									, int  limit=-1
									, bool reset=false
									, bool debug=false);
		//load all sources OF THIS part-file FROM DISK
		//and add them as CUpDownClients to theApp.downloadqueue
		//
		//if (param) limit is not equal (default is -1) -1, then the count of sources
		//that are loaded at once is equally (param) limit
		//if (param) reset is true, the loaded-completely status is reset to false (-> load ALL sources again)
	bool	LoadAndAddSources(	  bool keepSourcesOpen	= false
								, bool sendUDPRequest	= false
								, int  limit= -1
								, bool reset= false
								, bool debug= false
								, bool addImmediately	= true);
	//	//add all sources from (param) storedSources to the source-list of this part-file
	//bool	AddFromStoredSources(CStoredSources* storedSources, bool sendUDPRequest=false,int limit=-1,bool reset=false, bool debug=false);
		
	//save (param) toSave to the CStoredSources-object
	//m_stscrStoringSources
	bool	SaveToStoredSources(CUpDownClient* toSave);
	bool	SaveToStoredSources();
	//save all sources from Download-Queue and this' CStoredSources-object to disk
	bool	SaveSources(bool loadSourcesFirst=true);

	//get/set loading-(stored-)sources time-interval
	uint32	GetLoadSourcesTimeInterval()						{return m_iLoadingSourcesTimeInterval;};
	void	SetLoadSourcesTimeInterval(uint32 newInterval)		{m_iLoadingSourcesTimeInterval = newInterval;};
	//get/set loading-(stored-)sources partial (-> 'slow-loading') time-interval
	uint32	GetLoadSourcesSlowTimeInterval()					{return m_iLoadingSourcesPartialTimeInterval;};
	void	SetLoadSourcesSlowTimeInterval(uint32 newInterval)	{m_iLoadingSourcesPartialTimeInterval = newInterval;};
	//get/set time-interval for saving sources
	uint32	GetSaveSourcesTimeInterval()						{return m_iSavingSourcesTimeInterval;};
	void	SetSaveSourcesTimeInterval(uint32 newInterval)		{m_iSavingSourcesTimeInterval = newInterval;};
	//get/set size of a block that is loaded at once in 'slow-loading' mode
	uint16	GetLoadSourcesAtOnceLimit()							{return m_iLoadSourcesAtOnceLimit;};
	void	SetLoadSourcesAtOnceLimit(uint16 newLimit)			{m_iLoadSourcesAtOnceLimit = newLimit;};
	//get/set loaded-sources-completely-inidcator
	bool	GetLoadedSourcesCompletely()						{return m_bLoadedSourcesCompletely;};
	void	SetLoadedSourcesCompletely(bool setTo)				{m_bLoadedSourcesCompletely = setTo;};

	CStoredSources* GetStoredSources()							{return m_stscrStoringSources;};
	//////////////////////////////////////////////////
#endif //OLD_SLS_ENABLED
d96 2
a97 2
	void	NewSrcPartsInfo();
	void	SetPriority(uint8 np);
a268 39
	/////////////////////////////////////
	//for saving sources: (by Mr.Fry)
#ifdef OLD_SLS_ENABLED
	CStoredSources*	m_stscrStoringSources;
		//were the sources of this part-file loaded completely?
	bool	m_bLoadedSourcesCompletely;
		//index of the current source-entry (in CStoredSources)
	uint16	m_iSourceIndex;
		//indes of the User-ID of the current source-entry
		//
	int		m_iSourceIDIndex;
		//indicates, if eMule was connected to a server the last time
		//it processed this part-file (in CPartFile::Process(...))
	bool	m_bWasConnectedToServerLastTime;
		//the last time, sources of this part-file were saved to disk
		//(is set in  SaveSources())
	uint32	m_iLastTimeSourcesSaved;
		//the last time, sources of this part-file were loaded from disk AND
		//added to theApp.downloadqueue
		//(is set in  LoadAndAddSources())
	uint32	m_iLastTimeSourcesLoaded;
		//for 'slow-loading' of sources
	uint32	m_iLastTimeSourcesLoadedPartial;
		//time-interval for start loading sources
	uint32	m_iLoadingSourcesTimeInterval;
		//time-interval for loading seperate blocks (size of a block is defined by the
		//variable m_iLoadSourcesAtOnceLimit) in 'slow-loading' mode
	uint32	m_iLoadingSourcesPartialTimeInterval;
		//time-interval for saving sources
	uint32	m_iSavingSourcesTimeInterval;
		//size of a block that is loaded at once in 'slow-loading' mode
	uint16	m_iLoadSourcesAtOnceLimit;
		//tells the part-file, if it should load the saved sources from disk
		//(needs to load them one time in any case, because this information
		// is saved in the CStoredSources-objects)
	//TODO: implement this feature (if false, deactivate loading/saving sources for this part-file)
	bool	m_bLoadSavedSources;
	//////////////////////////////////////
#endif //OLD_SLS_ENABLED
@


1.52
log
@now using Ottavios SLS system [netwolf]
@
text
@a248 2
	uint32 m_dwlastTimeActivated; //<<-- enkeyDEV(kei-kun) -SLS preferences-

@


1.51
log
@ICR 2.10 (fixed bug zip-stream)
@
text
@d24 1
d249 2
d280 1
@


1.50
log
@sessiontime starts on resuming for initialy paused files (for avg datarate)
@
text
@d303 1
d305 1
a305 11
	CArray<CUpDownClient*, CUpDownClient*> m_BlockedParts;;
	uint16	n_BlocksToDownloadInPart;
	uint16	m_MaxSrcPartFrequency;
	// eklmn: feature(00): ICR 2.8+
	/*struct DownloadedParts {
		CUpDownClient* Client;
		uint16 part;
		int sourcesslot;
	};
	CList<DownloadedParts,DownloadedParts&> BlockedParts;
	*/
a412 4
	//  v- eklmn: feature(00): ICR
	uint16	GetBlocksToDownloadInPart()		{return n_BlocksToDownloadInPart;}
	void	DecBlocksToDownloadInPart()		{n_BlocksToDownloadInPart--;}
	//  ^- eklmn: feature(00): ICR
d430 1
@


1.49
log
@1) fixed possible exception during a scan of srclist;
2) fixed download timeouts (::Process is rewritten)
3) ICR 2.9
@
text
@d30 1
a30 1
#define	PS_UNKNOWN		6
d56 4
a59 4
	BYTE *data;						// Barry - This is the data to be written
	uint32 start;					// Barry - This is the start offset of the data
	uint32 end;						// Barry - This is the end offset of the data
	Requested_Block_Struct *block;	// Barry - This is the requested block that this data relates to
d68 2
a69 2
	void InitializeFromLink(CED2KFileLink* fileLink);
	virtual ~CPartFile();
d133 2
a134 2
		//save (param) toSave to the CStoredSources-object
		//m_stscrStoringSources
d137 1
a137 1
		//save all sources from Download-Queue and this' CStoredSources-object to disk
d140 11
a150 11
		//get/set loading-(stored-)sources time-interval
	uint32	GetLoadSourcesTimeInterval()					{return m_iLoadingSourcesTimeInterval;};
	void	SetLoadSourcesTimeInterval(uint32 newInterval)			{m_iLoadingSourcesTimeInterval = newInterval;};
		//get/set loading-(stored-)sources partial (-> 'slow-loading') time-interval
	uint32	GetLoadSourcesSlowTimeInterval()				{return m_iLoadingSourcesPartialTimeInterval;};
	void	SetLoadSourcesSlowTimeInterval(uint32 newInterval)		{m_iLoadingSourcesPartialTimeInterval = newInterval;};
		//get/set time-interval for saving sources
	uint32	GetSaveSourcesTimeInterval()					{return m_iSavingSourcesTimeInterval;};
	void	SetSaveSourcesTimeInterval(uint32 newInterval)			{m_iSavingSourcesTimeInterval = newInterval;};
		//get/set size of a block that is loaded at once in 'slow-loading' mode
	uint16	GetLoadSourcesAtOnceLimit()					{return m_iLoadSourcesAtOnceLimit;};
d152 2
a153 2
		//get/set loaded-sources-completely-inidcator
	bool	GetLoadedSourcesCompletely()					{return m_bLoadedSourcesCompletely;};
d156 1
a156 1
	CStoredSources* GetStoredSources()					{return m_stscrStoringSources;};
d162 1
a162 1
	CString	GetPartMetFileName() const							{return partmetfilename;}
d172 1
a172 1
	int	GetValidSourcesCount();
d183 1
a183 1
	bool	IsArchive(); // Barry - Also want to preview archives
d189 2
d192 3
a194 2
	CTimeSpan GetFlushTimeSpan()	{return (m_lastDownTransfer - starttime);}
	CTimeSpan GetTotalTimeSpan()	{return (CTime::GetCurrentTime() - starttime);}
a201 1

a203 1

d265 1
a265 1
    bool m_bDiscardSuperCompressed;
d267 2
a268 2
    bool GetDiscardSuperCompressed() {return m_bDiscardSuperCompressed;};
    void SetDiscardSuperCompressed(bool discard_sc) {m_bDiscardSuperCompressed = discard_sc;};
d279 1
a279 1
	static CMutex s_ComplitingMutex;
d306 1
a306 1
	uint16 m_MaxSrcPartFrequency;
d324 2
a325 2
	static CBarShader s_LoadBar; 
	static CBarShader s_ChunkBar;
d328 1
a328 1
	DWORD	m_LastRemovedTime; 
d332 4
a335 3
	CTime starttime;
	uint32 startsize;
	uint32 avgdatarate;
d414 1
a414 1
    CTime   m_lastDownTransfer;   // obaldin
d417 1
a417 1
	CTime   GetLastDownTransfer() {return m_lastDownTransfer;};// obaldin
d434 1
a434 1
	CString localelastdowntransfer()	{return DtLocale(m_lastDownTransfer);}
@


1.48
log
@FEATURE: show average sessionspeed and total sessiontime for completed files [SyruS]
final smoothed remaining time
@
text
@d303 1
d307 1
a307 1
	struct DownloadedParts {
d313 1
d315 2
d439 2
@


1.47
log
@New A4AF mangement
@
text
@d185 1
a185 1
	sint32	GetTimeRemaining(bool GetOldValue = true);
d189 3
a191 2
	uint32	GetAvgDatarate()								{return avgdatarate;}
	void	UpdateAvgDatarate();
@


1.46
log
@added GetStatsFullPath method
@
text
@a254 2
	bool	IsA4AFAuto() 							{ return m_is_A4AF_auto; }
	void	SetA4AFAuto(bool in_A4AF_auto);
a322 1
	bool	m_is_A4AF_auto;
d398 4
a401 1
	CTypedPtrList<CPtrList, CUpDownClient*> srclists[SOURCESSLOTS];;
d433 1
a433 6
	// v1:- eklmn: feature(00): ICR 2.7 (don't download widespread parts parallel)
	/*void RemovePartFromBlockedList(uint16 blocked_part)	{
		POSITION pos = m_BlockedParts.Find(blocked_part);
		if (pos!=0) m_BlockedParts.RemoveAt(pos);
		}
	*/
@


1.45
log
@updated: smoothing time remaining & average downloadrate
@
text
@d390 1
@


1.44
log
@CHANGE: added average downloadrate within brackets to speedcolumn [SyruS]
CHANGE: smoothed "remaining time" calculation by bond006 [SyruS]
@
text
@a169 1
	uint32	GetAvgDatarate();													//bond006 (smoothed "remaining time" calculation) //SyruS
d184 2
a185 2
	CString CPartFile::GetPartfileStatus();
	sint32	CPartFile::GetTimeRemaining();
d188 3
d331 1
@


1.43
log
@added support for Source Exchange v2
@
text
@d170 1
d326 3
a328 1

@


1.42
log
@fix for crash
@
text
@d213 2
a214 1
	void	AddClientSources(CMemFile* sources);
d403 1
a403 1
    CTime   GetLastDownTransfer() {return m_lastDownTransfer;};// obaldin
d405 2
a406 1
	void AddClientSource(CClientSource* source, int i=0,bool exchanged=false);   
@


1.41
log
@ICR 2.8 fix
@
text
@d308 1
a308 1
	CList<DownloadedParts,DownloadedParts> BlockedParts;
@


1.40
log
@unicode cleanup
@
text
@d302 7
a308 1
	CList<uint16,uint16>	m_BlockedParts;
d425 1
a425 1
	void RemovePartFromBlockedList(uint16 blocked_part)	{
d429 1
a429 1

@


1.39
log
@ICR 2.7 (new condition for widespread parts 1 client = 1 Part)
@
text
@d77 1
a77 1
	bool	LoadPartFile(char* in_directory, char* filename); //filename = *.part.met
@


1.38
log
@ICR v2.6 (fix for "widespreaded parts")
@
text
@d302 1
d418 7
a424 1
};@


1.37
log
@two source function (NewSrcPartsInfo & UpdateAvailablePartsCount) werr merged (speed optimization)
@
text
@d301 1
@


1.36
log
@ICR 2.4
@
text
@d219 1
a219 1
	void	UpdateAvailablePartsCount();
@


1.35
log
@code cleanup
@
text
@d30 1
a30 1
#define	PS_UNKNOWN			6
d300 1
d397 5
a401 1
	void    AddClientHostnameSources(CTypedPtrList<CPtrList, CClientSource*>);
@


1.34
log
@file were paused not properly... (add new function IsPaused, need for ListenSocket)
@
text
@d94 1
a94 1
	void	AddSources(CMemFile* sources,uint32 serverip, uint16 serverport);
@


1.33
log
@DoubleT: bug #295 fixed (bypass part blocking on opcode StartUploadReq)
@
text
@d207 1
@


1.32
log
@Eklmn and BavarianSnail changes. see changelog+
@
text
@d92 1
@


1.31
log
@coverted code from char * to CString
@
text
@d295 4
@


1.30
log
@coverted code from char * to CString
@
text
@d164 2
a165 2
	char*	GetFullName()									{return fullname;}
	CString	GetTempDir() const									{return tempdir;}	// added by InterCeptor (multiple tempdirs) 19.11.02
d281 1
a281 1
	char*	fullname;
@


1.29
log
@complete sources column
@
text
@d161 1
a161 1
	char*	GetPartMetFileName()							{return partmetfilename;}
d165 1
a165 1
	char*	GetTempDir()									{return tempdir;}	// added by InterCeptor (multiple tempdirs) 19.11.02
d282 2
a283 2
	char*	tempdir;	// InterCeptor (multiple tempdirs)
	char*	partmetfilename;
@


1.28
log
@make "drop supercompressed blocks" a per-file setting
@
text
@d92 1
d172 2
d364 2
@


1.27
log
@Enhanced tooltips by JoeyRamone
@
text
@d250 2
a251 1
	void   	LoadMovieMode(); // DonGato
d253 7
@


1.26
log
@More netwolf's changes
@
text
@d391 1
@


1.25
log
@netwolf/SyruS/katsyonak changes - see changelog+
@
text
@d36 1
a36 1
#define BUFFER_TIME_LIMIT	90000   // Max milliseconds before forcing a flush
@


1.24
log
@fixes by BavarianSnail/obaldin/kuchin. see changelog+
@
text
@d35 1
a35 1
#define BUFFER_SIZE_LIMIT	500000 // Max bytes before forcing a flush
@


1.23
log
@Webserver from official 0.27c
@
text
@d76 1
a76 1
	uint32	Process(uint32 reducedownload);
@


1.22
log
@last seen complete and last downloaded are displayed under locale settings
@
text
@d388 3
@


1.21
log
@reinstate buffer flush on timeout
@
text
@d297 2
d383 6
a388 1
};
@


1.21.2.1
log
@27a partial merge
@
text
@d76 1
a76 1
	uint32	Process(uint32 reducedownload,uint8 m_icounter );
a224 1
	bool	IsStopped()						{return stopped;}
a227 2
	void	AddDownloadingSource(CUpDownClient* client);
	void	RemoveDownloadingSource(CUpDownClient* client);
a230 1
	CTime	GetLastChangeDatetime(bool forcecheck=false);
a274 1
	bool	stopped;
a345 4
	DWORD   m_lastdatetimecheck;
	CTime	m_lastdatecheckvalue;
	CTypedPtrList<CPtrList, CUpDownClient*> m_downloadingSourceList;

@


1.21.2.2
log
@27c
@
text
@d208 1
a208 1
	void	AddClientSources(CMemFile* sources, uint8 sourceexchangeversion);
d234 1
d378 1
d381 1
@


1.20
log
@corrected menu options for non-vlc preview & low disk space
@
text
@d36 1
a36 1
#define BUFFER_TIME_LIMIT	5000   // Max milliseconds before forcing a flush
@


1.19
log
@bugfix: should download better from .26 and above( bug 61)
@
text
@d75 1
@


1.18
log
@converted to new logging method
@
text
@d80 1
a80 1

d88 2
a89 2

	bool	GetNextRequestedBlock(CUpDownClient* sender,Requested_Block_Struct** newblocks,uint16* count);
@


1.17
log
@converted to new logging method
@
text
@a23 1
#include "Loggable.h"
d62 1
a62 1
class CPartFile : public CKnownFile, CLoggable {
@


1.16
log
@bugfixed exchanged sources; removed unnecessary IDS_EXCHANGEDSOURCEMARK
@
text
@d24 1
d63 1
a63 1
class CPartFile : public CKnownFile {
@


1.15
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d373 1
a373 1
	void AddClientSource(CClientSource* source, int i=0);   
@


1.14
log
@enkeydev stuff
@
text
@d369 1
d376 4
@


1.13
log
@now ratings are shown with more descriptive icons (THX->DrSiRiUs)
@
text
@d52 1
d371 4
@


1.12
log
@menu rearrangements
@
text
@d222 1
a222 1
	bool	HasBadRating();
@


1.12.2.1
log
@write the info on part senders
@
text
@a58 2
    char senderhash[16]; // obaldin: store the userhash of the sending client
    uint32 senderIP;
d184 1
a184 2
	uint32	WriteToBuffer(uint32 transize, BYTE *data, uint32 start, uint32 end, 
        Requested_Block_Struct *block, const uchar *senderUserHash, uint32 senderIP);
d222 1
a222 1
	int		GetRating();
@


1.12.2.2
log
@process senders
@
text
@a372 3

private:
    void UpdateSendersScore(uint32 partno, bool is_corrupt);
@


1.11
log
@Little fixes and Static Servers additions from 26d
@
text
@a365 8
	// obaldin
public:
	bool    GetPreviewChunksEnabled() {return m_bIsPreviewChunksEnabled;};
	void    SetPreviewChunksEnabled(bool is_enabled) 
        {
            m_bIsPreviewChunksEnabled=is_enabled; 
            if(!m_iMoviePreviewMode) m_iMoviePreviewMode=1;
        };
a366 1
	bool	m_bIsPreviewChunksEnabled;
@


1.10
log
@Preparing for new SLS code
@
text
@a34 4
#define SRV_PR_LOW			2
#define SRV_PR_NORMAL		0
#define SRV_PR_HIGH			1

@


1.9
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d18 1
d98 1
a98 1

d158 1
a158 1

d306 1
a306 1

d342 1
@


1.8
log
@more 26b merges
@
text
@d289 1
@


1.7
log
@show last progress time on a file being downloaded
@
text
@d77 1
a77 1
	uint32	Process(sint16 reducedownload);
d231 1
d344 1
@


1.6
log
@preview menu rearrangement
@
text
@d375 3
@


1.5
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d368 5
a372 1
	void    SetPreviewChunksEnabled(bool is_enabled) {m_bIsPreviewChunksEnabled=is_enabled;};
@


1.4
log
@Get fist/last chunk is now a per-file setting
@
text
@d166 1
a166 1
	uint16	GetSourceCount()								{return srclist.GetCount();}
a199 1
	void	BlockReceived(uint32 start,uint32 end, char* blockdata, uint32 transferedsize = 0);
d223 7
a249 1
	BOOL 	PerformFileComplete(void); // Lord KiRon
d339 4
a358 1
	static UINT CompleteThreadProc(CPartFile* pFile); // Lord KiRon - Used as separate thread to complete file
d360 1
a360 1
	CTypedPtrList<CPtrList, CUpDownClient*> srclist;
@


1.4.2.1
log
@initial upgrade to .26
@
text
@d38 1
a38 1
//#define BUFFER_SIZE_LIMIT	500000 // Max bytes before forcing a flush
d166 1
a166 1
	uint16	GetSourceCount();
d200 1
a223 7
	bool	HasComment()					{return hasComment;}
	bool	HasRating()						{return hasRating;}
	bool	HasBadRating();
	void	SetHasComment(bool in)			{hasComment=in;}
	void	SetHasRating(bool in)			{hasRating=in;}
	void	UpdateFileRatingCommentAvail();

d244 1
a333 4
	bool	hasRating;
	bool	hasComment;
	BOOL 	PerformFileComplete(); // Lord KiRon
	static UINT CompleteThreadProc(CPartFile* pFile); // Lord KiRon - Used as separate thread to complete file
d350 1
d352 1
a352 1
	CTypedPtrList<CPtrList, CUpDownClient*> srclists[SOURCESSLOTS];;
d354 1
a354 1
	bool	hashsetneeded;
@


1.3
log
@Preventing complition of more then one file at same time [Lord KiRon]
@
text
@d356 7
@


1.3.2.1
log
@updating this branch...
@
text
@@


1.2
log
@update to .25b codebase
@
text
@d257 1
@


1.1
log
@*** empty log message ***
@
text
@d34 7
d56 8
d180 3
a182 2
	CString GetPartfileStatus();
	sint32	GetTimeRemaining();
d184 14
d221 4
a224 1
	int	GetCommonFilePenalty();
d239 1
a239 1
	void	RemoveNoNeededSources(void);
d260 3
d273 1
d282 1
d333 5
@

