head	1.10;
access;
symbols
	PublicRelease_1_2e:1.10
	Interim_Release_1-2e_RC1:1.10
	PublicRelease_1_2d:1.10
	Interim_Release_1-2d_RC1:1.10
	Interim_Release_1-2d_beta1:1.10
	PublicRelease_1_2c:1.10
	Interim_Release_1-2c_RC1:1.10
	Interim_Release_1-2c_beta1:1.10
	PublicRelease_1_2b:1.10
	Interim_Release_1-2b_RC1:1.10
	PublicRelease_1_2a:1.10
	Interim_Release_1-2a_RC1:1.10
	Interim_Release_1-2a_beta2:1.10
	Interim_Release_1-2a_beta1:1.10
	PublicRelease_1_2:1.10
	Interim_Release_1-2_RC1:1.10
	Interim_Release_1-2_beta1:1.10
	PublicRelease_1_1g:1.10
	Interim_Release_1-1g_RC3:1.10
	Interim_Release_1-1g_RC2:1.10
	Interim_Release_1-1g_RC1:1.10
	Interim_Release_1-1g_beta2:1.10
	Interim_Release_1-1g_beta1:1.10
	PublicRelease_1_1f:1.10
	Interim_Release_1-1f_RC1:1.10
	PublicRelease_1_1e:1.10
	Interim_Release_1-1e_RC2:1.10
	Interim_Release_1-1e_RC1:1.10
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.7
	Interim_Release_1-1d_RC1:1.7
	PublicRelease_1_1c:1.7
	Interim_Release_1-1c_RC1:1.5
	Interim_Release_1-1c_beta2:1.3
	Interim_Release_1-1c_beta1:1.2;
locks; strict;
comment	@// @;


1.10
date	2005.04.16.00.04.59;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.04.11.16.32.20;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2005.04.07.06.48.24;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.26.17.52.04;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.26.09.47.57;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.23.22.13.02;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.18.18.31.24;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.03.15.14.14;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.29.14.54.55;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.28.20.13.51;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.10
log
@v2 - Xml events and other improvements
@
text
@// Implementation of all virtual functions of WebServer class
// e.g. implementation of eMule Plus web-interface

#include "StdAfx.h"
#include "WebServerImpl.h"
#include "../../opcodes.h"
#include "../../Engine/Sockets/TasksSockets.h"
#include "../../Engine/XML/XML.h"
#include <time.h>

void CWebServerImpl::ProcessDynamicItem(XmlDoc spDoc, const CString sItem, const vector<CString> arrParams, const CString sArgs)
{
	CString sInternalCmd = ReadParam(sArgs, _T("internal_op"));
	if(!sInternalCmd.IsEmpty())
	{
		if(sInternalCmd == _T("connect"))
		{
			CString sAddr = ReadParam(sArgs, _T("addr"));
			UINT nPort = _ttol(ReadParam(sArgs, _T("port")));

			CXml_hello *pCompletionTask = new CXml_hello;
			pCompletionTask->m_sClient = _T("tray");
			CTask_Connect *pTask = new CTask_Connect(sAddr, nPort, T_CLIENT_XML, pCompletionTask);
			g_stEngine.Sockets.Push(pTask);
		}

		if(sInternalCmd == _T("exit"))
		{
			CXml_quit* pTask = new CXml_quit;
			pTask->SetClient(g_stEngine.m_pXmlClient);
			g_stEngine.Sockets.Push(pTask);
		}

		if(sInternalCmd == _T("shutdown"))
		{
			g_stEngine.CloseApp();
			return;
		}

		XmlSetAttribute(spDoc->documentElement, _T("refresh"), 1);

		return;
	}

	if(sItem == _T("header"))
	{
		XmlElement spHeader = XmlCreateElement(spDoc, spDoc->documentElement, _T("header"));
		XmlSetAttribute(spHeader, _T("version"), (long)CURRENT_PLUS_VERSION);
		XmlSetAttribute(spHeader, _T("version_text"), CURRENT_VERSION_LONG);
		return;
	}

	if(sItem == _T("logs"))
	{
		if(g_stEngine.GetXmlState() != XML_CONNECTED)
			return;

		DWORD dwLogMin, dwLogMax;
		if(arrParams.size() > 1)
		{
			if(arrParams[1] == _T("debug"))
			{
				dwLogMin = LOG_DEBUG;
				dwLogMax = LOG_END;
			}
			else // "all"
			{
				dwLogMin = LOG_START;
				dwLogMax = LOG_END;
			}
		}
		else
		{
			dwLogMin = LOG_START;
			dwLogMax = LOG_NORMAL_END;
		}


		XmlElement spLogs = XmlCreateElement(spDoc, spDoc->documentElement, _T("logs"));

		CXml_get_logs *pTask = new CXml_get_logs;
		if(pTask)
		{
			pTask->m_dwTypeMin = dwLogMin;
			pTask->m_dwTypeMax = dwLogMax;
			pTask->SetClient(g_stEngine.m_pXmlClient);
			ULONG ulId = pTask->GetId();
			g_stEngine.Sockets.Push(pTask);
			CString sXml = g_stEngine.m_XmlEvents.WaitForXmlResponse(ulId);
			XmlDoc spXmlDoc = XmlLoadDocumentFromStr(sXml);
			if(spXmlDoc != NULL)
			{
				XmlNodes spNodes = spXmlDoc->selectNodes(_T("//result/log"));
				for(int i = 0; i < spNodes->length; i++)
				{
					XmlElement spElem = spNodes->item[i];
					long lTime = XmlGetAttributeLong(spElem, _T("time"), 0);
					if(lTime > 0)
					{
						short nPrecision = XmlGetAttributeLong(spElem, _T("precision"), 0);
						TCHAR sTime[128], sOutTime[128];
						_tcsftime(sTime, 128, _T("%d/%m/%y %H:%M:%S"), localtime(&lTime));
						_stprintf(sOutTime, _T("%s.%03d"), sTime, nPrecision);
						XmlSetAttribute(spElem, _T("time_text"), sOutTime);
					}
					spLogs->appendChild(spElem);
				}
			}
		}
		return;
	}
	if(sItem == _T("debug"))
	{
		CString strCmd = ReadParam(sArgs, _T("debug_cmd"));
		if(!strCmd.IsEmpty())
		{
			CXmlTask* pTask = CXmlTask::ParseXml(strCmd);
			if(pTask)
			{
				pTask->SetReceived(false);
				pTask->SetClient(g_stEngine.m_pXmlClient);
				g_stEngine.Sockets.Push(pTask);		
			}
		}
		return;
	}
	if(sItem == _T("shared"))
	{
		if(g_stEngine.GetXmlState() != XML_CONNECTED)
			return;

		XmlElement spShared = XmlCreateElement(spDoc, spDoc->documentElement, _T("shared"));

		CXml_get_shared *pTask = new CXml_get_shared;
		if(pTask)
		{
			pTask->SetClient(g_stEngine.m_pXmlClient);
			ULONG ulId = pTask->GetId();
			g_stEngine.Sockets.Push(pTask);
			CString sXml = g_stEngine.m_XmlEvents.WaitForXmlResponse(ulId);
			XmlDoc spXmlDoc = XmlLoadDocumentFromStr(sXml);
			if(spXmlDoc != NULL)
			{
				XmlNodes spNodes = spXmlDoc->selectNodes(_T("//result/file"));
				for(int i = 0; i < spNodes->length; i++)
				{
					XmlElement spElem = spNodes->item[i];
					spShared->appendChild(spElem);
				}
			}
		}
		return;
	}
}

void CWebServerImpl::ProcessFinalize(XmlDoc spDoc, const vector<CString> arrParams, const CString sArgs)
{
	XmlSetAttribute(spDoc->documentElement, _T("connected"), g_stEngine.GetXmlState() == XML_CONNECTED);
	if(g_stEngine.GetXmlState() != XML_CONNECTED)
	{
		XmlSetAttribute(spDoc->documentElement, _T("def_addr"), (LPCTSTR)DEF_ADDR);
		XmlSetAttribute(spDoc->documentElement, _T("def_port"), DEF_PORT);
	}
#ifdef _DEBUG
	XmlSetAttribute(spDoc->documentElement, _T("debug"), true);
#endif //_DEBUG
}
@


1.9
log
@v2 - logging subsystem
@
text
@d89 1
a89 1
			CString sXml = g_stEngine.WaitForXmlResponse(ulId);
d140 1
a140 1
			CString sXml = g_stEngine.WaitForXmlResponse(ulId);
@


1.8
log
@v2 - more webserver logic
@
text
@d58 21
d84 2
d100 2
a101 1
						TCHAR sTime[128];
d103 2
a104 1
						XmlSetAttribute(spElem, _T("time_text"), sTime);
@


1.7
log
@v2 - upload already works, of course it has very poor implementation, without queues yet, but it works! Also webserver improvements - now you can enter commands through webinterface
@
text
@d13 32
d134 5
@


1.6
log
@v2 - opcodes handling improvement, webserver enhancement
@
text
@d23 3
d68 28
@


1.5
log
@v2 - minor improvements
@
text
@d11 1
a11 1
void CWebServerImpl::ProcessDynamicItem(XmlDoc spDoc, const CString sItem, const vector<CString> arrParams)
a49 1

d52 14
d68 1
a68 1
void CWebServerImpl::ProcessFinalize(XmlDoc spDoc, const vector<CString> arrParams)
d71 3
@


1.4
log
@v2 - more minor rearrangements
@
text
@d57 1
a57 1
	XmlSetAttribute(spDoc->documentElement, _T("connected"), true);
@


1.3
log
@Ideological switch (may be considered as temporary, but for long term) - ATL to MFC
Actually we don't need them both, but I want to work with our current KnownFile-based classes, which use MFC a lot
@
text
@d30 1
a30 1
			g_stEngine.PushToSocketsTP(pTask);
@


1.2
log
@Xml and database functionality
@
text
@d7 3
d18 34
@


1.1
log
@Corrected v2 defines, improved v2 webserver and database functionality
@
text
@d13 2
a14 2
		XmlSetAttribute(spHeader, _T("version"), (long)CURRENT_PLUS_VERSION_2);
		XmlSetAttribute(spHeader, _T("version_text"), CURRENT_VERSION_LONG_2);
@

