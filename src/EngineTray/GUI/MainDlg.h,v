head	1.12;
access;
symbols
	PublicRelease_1_2e:1.12
	Interim_Release_1-2e_RC1:1.12
	PublicRelease_1_2d:1.12
	Interim_Release_1-2d_RC1:1.12
	Interim_Release_1-2d_beta1:1.12
	PublicRelease_1_2c:1.12
	Interim_Release_1-2c_RC1:1.12
	Interim_Release_1-2c_beta1:1.12
	PublicRelease_1_2b:1.12
	Interim_Release_1-2b_RC1:1.12
	PublicRelease_1_2a:1.12
	Interim_Release_1-2a_RC1:1.12
	Interim_Release_1-2a_beta2:1.12
	Interim_Release_1-2a_beta1:1.12
	PublicRelease_1_2:1.12
	Interim_Release_1-2_RC1:1.12
	Interim_Release_1-2_beta1:1.12
	PublicRelease_1_1g:1.12
	Interim_Release_1-1g_RC3:1.12
	Interim_Release_1-1g_RC2:1.12
	Interim_Release_1-1g_RC1:1.12
	Interim_Release_1-1g_beta2:1.12
	Interim_Release_1-1g_beta1:1.12
	PublicRelease_1_1f:1.12
	Interim_Release_1-1f_RC1:1.12
	PublicRelease_1_1e:1.12
	Interim_Release_1-1e_RC2:1.12
	Interim_Release_1-1e_RC1:1.12
	Interim_Release_1-1e_beta1:1.12
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.9
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.3
	PublicRelease_1_1b:1.1;
locks; strict;
comment	@ * @;


1.12
date	2005.04.11.16.32.12;	author kuchin;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.07.06.48.24;	author kuchin;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.26.09.47.49;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.23.22.13.02;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.23.18.57.37;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.21.16.49.41;	author kush_eplus;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.19.20.40.29;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.18.18.31.24;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.03.15.14.14;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.04.13.21.27;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.29.16.04.21;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.26.06.50.32;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.12
log
@v2 - logging subsystem
@
text
@// MainDlg.h : interface of the CMainDlg class
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#include "TrayIconImpl.h"
#include "TrayMenuDlg.h"
#include "MeterIcon.h"
#include "../Engine/Sockets/TasksSockets.h"
#include "../Engine/XML/XML.h"

class CConnectDlg :
	 public CDialogImpl<CConnectDlg>
	,public CWinDataExchange<CConnectDlg>
{
public:
	enum { IDD = IDD_CONNECTDLG };
	CString	m_sAddr;
	int		m_nPort;

public:
	BEGIN_MSG_MAP(CConnectDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnOK)
		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
	END_MSG_MAP()

	BEGIN_DDX_MAP(CConnectDlg)
		DDX_TEXT(IDC_ADDR, m_sAddr)
		DDX_INT(IDC_PORT, m_nPort)
	END_DDX_MAP()

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		m_sAddr = DEF_ADDR;
		m_nPort = DEF_PORT;

		CenterWindow();

		// First DDX call, hooks up variables to controls.
		DoDataExchange(false);

		return TRUE;
	}

	LRESULT OnOK(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}

	LRESULT OnCancel(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		EndDialog(wID);
		return 0;
	}
	LRESULT OnBnClickedOk(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
};


class CMainDlg :
	public CDialogImpl<CMainDlg>,
	public CUpdateUI<CMainDlg>,
	public CMessageFilter,
	public CIdleHandler,
	public CTrayIconImpl<CMainDlg>
{
public:
	enum { IDD = IDD_MAINDLG };

protected:
	UINT	m_nTimerID;
	bool	m_bConnected;

public:
	virtual BOOL PreTranslateMessage(MSG* pMsg)
	{
		return IsDialogMessage(pMsg);
	}

	virtual BOOL OnIdle()
	{
		return FALSE;
	}

	BEGIN_UPDATE_UI_MAP(CMainDlg)
	END_UPDATE_UI_MAP()

	BEGIN_MSG_MAP(CMainDlg)
		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		COMMAND_ID_HANDLER(IDOK, OnOK)
		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
		COMMAND_ID_HANDLER(IDC_EXIT, OnCancel)
		COMMAND_ID_HANDLER(IDC_CONNECT, OnConnect)
		MESSAGE_HANDLER(WM_UI_STATE, OnUIState)
		MSG_WM_TIMER(OnTimer)	// for testing purpose only
		CHAIN_MSG_MAP(CTrayIconImpl<CMainDlg>)
	END_MSG_MAP()

// Handler prototypes (uncomment arguments if needed):
//	LRESULT MessageHandler(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
//	LRESULT CommandHandler(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
//	LRESULT NotifyHandler(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)

	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
	{
		EMULE_TRY

		if(!g_stEngine.Init(m_hWnd))
			return FALSE;

		g_stEngine.m_hMainWnd = m_hWnd;

		// center the dialog on the screen
		CenterWindow();

		// set icons
		HICON hIcon = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_MAINFRAME),
										 IMAGE_ICON, ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON),
										 LR_DEFAULTCOLOR);
		SetIcon(hIcon, TRUE);

		HICON hIconSmall = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_MAINFRAME),
												IMAGE_ICON, ::GetSystemMetrics(SM_CXSMICON),
												::GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);

		SetIcon(hIconSmall, FALSE);

		// register object for message filtering and idle updates
		CMessageLoop		*pLoop = _Module.GetMessageLoop();

		ATLASSERT(pLoop != NULL);
		pLoop->AddMessageFilter(this);
		pLoop->AddIdleHandler(this);

		UIAddChildWindowContainer(m_hWnd);

		// Install the tray icon
		HICON hIconTray = CreateMeterIcon(IDI_TRAYICON_DISCONNECTED, 16, 16, 10, 0, 0, 0);

		InstallTrayIcon(_T("eMule Plus"), hIconTray, NULL);

		m_bConnected = false;

		return TRUE;

		EMULE_CATCH
		return FALSE;
	}

	LRESULT OnOK(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CString		strXml;

		GetDlgItem(IDC_DEBUG_XML).GetWindowText(strXml.GetBuffer(1000), 1000);
		strXml.ReleaseBuffer();

		CXmlTask* pTask = CXmlTask::ParseXml(strXml);
		if(pTask)
		{
			pTask->SetReceived(false);
			pTask->SetClient(g_stEngine.m_pXmlClient);
			g_stEngine.Sockets.Push(pTask);		
		}
	//	Hide the dialog
		ShowWindow(SW_HIDE);
		return 0;
	}

	LRESULT OnCancel(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CloseDialog(wID);
		return 0;
	}

	LRESULT OnConnect(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
	{
		CConnectDlg dlg;
		if(dlg.DoModal() == IDOK)
		{
//			g_stEngine.AllocTcpConnect(inet_addr(dlg.m_sAddr), dlg.m_nPort, T_CLIENT_XML, NULL);
			CXml_hello *pCompletionTask = new CXml_hello;
			pCompletionTask->m_sClient = _T("tray");
			CTask_Connect *pTask = new CTask_Connect(dlg.m_sAddr, dlg.m_nPort, T_CLIENT_XML, pCompletionTask);
			g_stEngine.Sockets.Push(pTask);
		}

		return 0;
	}

	LRESULT OnUIState(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
	{
		bHandled = TRUE;
		switch(wParam)
		{
		case XML_CONNECTED:
			m_bConnected = true;
			// for testing purpose only
			m_nTimerID = SetTimer(1, 20);
			break;
		case XML_DISCONNECTED:
			m_bConnected = false;
			break;
		}

		return 0;
	}

	void CloseDialog(int nVal)
	{
		EMULE_TRY

		g_stEngine.Uninit();

		DestroyWindow();
		::PostQuitMessage(nVal);

		EMULE_CATCH
	}

	LRESULT TrayIconFct(UINT nMsg, UINT nHWP)
	{
		EMULE_TRY

		if (nMsg == WM_RBUTTONUP)
		{
			static bool bSingleInstance = true;
			if(bSingleInstance)
			{
				bSingleInstance = false;
				CPoint pos;
				GetCursorPos(&pos);
				if(m_bConnected)
				{
					CTrayMenuDlg dlg(pos, 16, 96, 8, 48);
					switch(dlg.DoModal(NULL))
					{
						case IDC_SPEED:			OnTraySpeed();		 break;
						case IDC_TOMAX:			OnTrayToMax();		 break;
						case IDC_TOMIN:			OnTrayToMin();		 break;
						case IDC_CONNECT:		OnTrayConnect();	 break;
						case IDC_DISCONNECT:	OnTrayDisconnect();	 break;
						case IDC_PREFERENCES:	OnTrayPreferences(); break;
						case IDC_ABOUT:			OnTrayAbout();		 break;
						case IDC_EXIT:			OnTrayExit();		 break;
						default:									 break;
					}
				}
				else
				{
					// Load the menu
					CMenu oMenu;
					if (!oMenu.LoadMenu(IDR_POPUP))
						return 0;
					// Get the sub-menu
					CMenuHandle oPopup(oMenu.GetSubMenu(0));
					// Prepare
					PrepareMenu(oPopup);
					// Get the menu position
					CPoint pos;
					GetCursorPos(&pos);
					// Make app the foreground
					SetForegroundWindow(m_hWnd);
					// Set the default menu item
/*					if (m_nDefault == 0)
						oPopup.SetMenuDefaultItem(0, TRUE);
					else
						oPopup.SetMenuDefaultItem(m_nDefault);*/
					// Track
					oPopup.TrackPopupMenu(TPM_LEFTALIGN, pos.x, pos.y, m_hWnd);
					// BUGFIX: See "PRB: Menus for Notification Icons Don't Work Correctly"
					PostMessage(WM_NULL);
					// Done
					oMenu.DestroyMenu();
				}
				bSingleInstance = true;
			}
		}
		else if (nMsg == WM_LBUTTONDBLCLK)
		{
			OnTrayAbout();
		}
		return 0;

		EMULE_CATCH
		return -1;
	}

	void OnTraySpeed()
	{
		::MessageBox(NULL, _T("Speed"), _T(""), MB_OK);
	}
	void OnTrayToMax()
	{
		::MessageBox(NULL, _T("ToMax"), _T(""), MB_OK);
	}
	void OnTrayToMin()
	{
		::MessageBox(NULL, _T("ToMin"), _T(""), MB_OK);
	}
	void OnTrayConnect()
	{
		CXml_connect* pTask = new CXml_connect;
		if(pTask)
		{
			pTask->SetClient(g_stEngine.m_pXmlClient);
			pTask->m_sAddr = _T("62.241.53.15");
			pTask->m_dwPort = 4242;
			g_stEngine.Sockets.Push(pTask);
		}
	}
	void OnTrayDisconnect()
	{
		CXml_disconnect* pTask = new CXml_disconnect;
		if(pTask)
		{
			pTask->SetClient(g_stEngine.m_pXmlClient);
			g_stEngine.Sockets.Push(pTask);
		}
	}
	void OnTrayPreferences()
	{
		::MessageBox(NULL, _T("Preferences"), _T(""), MB_OK);
	}
	void OnTrayAbout()
	{
		ShowWindow(SW_SHOW);
	}
	void OnTrayExit()
	{
		CXml_quit* pTask = new CXml_quit;
		pTask->SetClient(g_stEngine.m_pXmlClient);
		g_stEngine.Sockets.Push(pTask);
		m_bConnected = false;
//		CloseDialog(IDOK);
	}

	// for testing purpose only
	void OnTimer(UINT idEvent, TIMERPROC /*TimerProc*/)
	{
		if(idEvent == m_nTimerID)
		{
			if(!m_bConnected)
			{
				KillTimer(idEvent);
				HICON hIconTray = CreateMeterIcon(IDI_TRAYICON_DISCONNECTED, 16, 16, 10, 0, 0, 0);
				ChangeTrayIcon(hIconTray);
				return;
			}
			static int maxval = 32;
			static int val = 0;
			static int dir = 1;

			HICON hIcon = CreateMeterIcon(IDI_TRAYICON_STD, 16, 16,
										  maxval, val,
										  RGB(0,255,0), RGB(39,95,39));
			val += dir;
			if(val <= 0 || val >= maxval)
				dir = -dir;

			ChangeTrayIcon(hIcon);
			CString strTooltip;
			strTooltip.Format(_T("Up: %d.%02d (%d.%02d) | Down: %d.%02d (%d.%02d)"),
								rand()%33, rand()%100, rand()%2, rand()%100,
								val, rand()%100, rand()%2, rand()%100);
			SetTooltipText(strTooltip);
		}
		return;
	}
};
@


1.11
log
@v2 - more webserver logic
@
text
@d309 1
a309 1
			pTask->m_ulPort = 4242;
@


1.10
log
@v2 - opcodes handling improvement, webserver enhancement
@
text
@d36 2
a37 2
		m_sAddr = _T("127.0.0.1");
		m_nPort = 9090;
d113 2
@


1.9
log
@v2 - minor improvements
@
text
@d157 2
a158 3
		CXmlTask	   *pTask = CXmlTask::ParseXml(strXml);

		if (pTask != NULL)
@


1.8
log
@v2 - updated protocol, debug features, bugfix for completion task, revert to default struct byte alignment
@
text
@d196 1
a196 1
		case UI_CONNECTED:
d201 1
a201 1
		case UI_DISCONNECTED:
@


1.7
log
@added ability to send XML commands to engine
@
text
@d161 2
a162 2
			pTask->m_bReceived = false;
			pTask->m_pClient = g_stEngine.m_pXmlClient;
d314 6
a319 1
		::MessageBox(NULL, _T("Disconnect"), _T(""), MB_OK);
@


1.6
log
@v2 - connecting to server, updated protocol, bugfixes
@
text
@d13 1
a13 1
class CConnectDlg : 
d62 2
a63 2
class CMainDlg : 
	public CDialogImpl<CMainDlg>, 
d65 1
a65 1
	public CMessageFilter, 
d117 1
a117 1
		HICON hIcon = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_MAINFRAME), 
d122 1
a122 1
		HICON hIconSmall = (HICON)::LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_MAINFRAME), 
d141 1
a141 1
		
d145 1
a145 1
		
d152 6
a157 1
		CString		sXml;
d159 7
a165 3
		GetDlgItem(IDC_DEBUG_XML).GetWindowText(sXml.GetBuffer(1000), 1000);
		sXml.ReleaseBuffer();
		// Hide the dialog
d237 1
a237 1
					{					
d280 1
a280 1
		{			
d314 1
a314 1
		::MessageBox(NULL, _T("Disconnect"), _T(""), MB_OK);						
d318 1
a318 1
		::MessageBox(NULL, _T("Preferences"), _T(""), MB_OK);						
d349 2
a350 2
			HICON hIcon = CreateMeterIcon(IDI_TRAYICON_STD, 16, 16, 
										  maxval, val, 
d355 1
a355 1
			
d358 2
a359 2
			strTooltip.Format(_T("Up: %d.%02d (%d.%02d) | Down: %d.%02d (%d.%02d)"), 
								rand()%33, rand()%100, rand()%2, rand()%100, 
@


1.5
log
@v2 - more minor rearrangements
@
text
@d294 8
a301 1
		::MessageBox(NULL, _T("Connect"), _T(""), MB_OK);
@


1.4
log
@Ideological switch (may be considered as temporary, but for long term) - ATL to MFC
Actually we don't need them both, but I want to work with our current KnownFile-based classes, which use MFC a lot
@
text
@d176 1
a176 1
			g_stEngine.PushToSocketsTP(pTask);
d312 1
a312 1
		g_stEngine.PushToSocketsTP(pTask);
@


1.3
log
@XML connecting, tray app
@
text
@d311 1
a311 1
		pTask->m_pClient = g_stEngine.m_pXmlClient;
@


1.2
log
@There can be only one engine :-)
@
text
@d10 51
d73 2
a74 1
	UINT m_nTimerID;
d94 3
d110 3
d138 1
a138 1
		HICON hTrayIcon = CreateMeterIcon(IDI_TRAYICON_DISCONNECTED, 16, 16, 10, 0, 0, 0);
d140 1
a140 1
		InstallTrayIcon(_T("eMule Plus"), hTrayIcon, NULL);
d142 1
a142 2
		// for testing purpose only
//		m_nTimerID = SetTimer(1, 20);
d156 1
a156 3
//		if(!sXml.IsEmpty())
//			g_stEngine.ParseXmlCommand(sXml);
	//	Hide the dialog
d167 33
d202 4
d208 2
d224 42
a265 12
				CTrayMenuDlg dlg(pos, 16, 96, 8, 48);
				switch(dlg.DoModal(NULL))
				{					
					case IDC_SPEED:			OnTraySpeed();		 break;
					case IDC_TOMAX:			OnTrayToMax();		 break;
					case IDC_TOMIN:			OnTrayToMin();		 break;
					case IDC_CONNECT:		OnTrayConnect();	 break;
					case IDC_DISCONNECT:	OnTrayDisconnect();	 break;
					case IDC_PREFERENCES:	OnTrayPreferences(); break;
					case IDC_ABOUT:			OnTrayAbout();		 break;
					case IDC_EXIT:			OnTrayExit();		 break;
					default:									 break;
d310 5
a314 1
		CloseDialog(IDOK);
d322 7
@


1.1
log
@*** empty log message ***
@
text
@d80 1
a80 1
		HICON hTrayIcon = CreateMeterIcon(IDI_TRAYICON_STD, 16, 16, 10, 0, 0, 0);
d85 1
a85 1
		m_nTimerID = SetTimer(1, 20);
@

