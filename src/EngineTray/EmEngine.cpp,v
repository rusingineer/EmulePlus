head	1.7;
access;
symbols
	PublicRelease_1_2e:1.7
	Interim_Release_1-2e_RC1:1.7
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.7
	Interim_Release_1-2c_RC1:1.7
	Interim_Release_1-2c_beta1:1.7
	PublicRelease_1_2b:1.7
	Interim_Release_1-2b_RC1:1.7
	PublicRelease_1_2a:1.7
	Interim_Release_1-2a_RC1:1.7
	Interim_Release_1-2a_beta2:1.7
	Interim_Release_1-2a_beta1:1.7
	PublicRelease_1_2:1.7
	Interim_Release_1-2_RC1:1.7
	Interim_Release_1-2_beta1:1.7
	PublicRelease_1_1g:1.7
	Interim_Release_1-1g_RC3:1.7
	Interim_Release_1-1g_RC2:1.7
	Interim_Release_1-1g_RC1:1.7
	Interim_Release_1-1g_beta2:1.7
	Interim_Release_1-1g_beta1:1.7
	PublicRelease_1_1f:1.7
	Interim_Release_1-1f_RC1:1.7
	PublicRelease_1_1e:1.7
	Interim_Release_1-1e_RC2:1.7
	Interim_Release_1-1e_RC1:1.7
	Interim_Release_1-1e_beta1:1.7
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.1;
locks; strict;
comment	@// @;


1.7
date	2005.04.16.00.04.51;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.04.08.14.16.34;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.08.11.09.29;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.23.22.12.38;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.02.18.18.31.18;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.03.15.13.49;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.04.13.21.14;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.7
log
@v2 - Xml events and other improvements
@
text
@#include "stdafx.h"
#include "../Engine/Sockets/TaskProcessorSockets.h"

//////////////////////////////////////////////////////////////////////
// Constructor
CEmEngine::CEmEngine() 
	:m_hWndUI(NULL)
	,m_eXmlState(XML_DISCONNECTED)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CEmEngine::Init(HWND hWndUI)
{
	// Base class init
	if(!CEmEngineBase::Init())
		return false;

	m_hWndUI = hWndUI;

	m_XmlEvents.SetStopEvent(m_hStop);

	return true;
}

@


1.6
log
@v2 - more abstraction + logic
@
text
@d21 2
a25 29
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CEmEngine::SetXmlResponse(ULONG ulId, LPCTSTR sResponse)
{
//	CMutexLock stLock(m_mutexXmlResponses, true);
	m_stXmlResponses[ulId] = sResponse;
//	stLock.Unlock();
}

// This can be implemented better
CString CEmEngine::WaitForXmlResponse(ULONG ulId, DWORD dwTimeout)
{
	CPreciseTime tmStart = CPreciseTime::GetCurrentTime();
	while(CPreciseTime::GetCurrentTime() - tmStart < dwTimeout)
	{
		if(WaitForSingleObject(m_hStop, 100) != WAIT_TIMEOUT)
			return _T("");
//		CMutexLock stLock(m_mutexXmlResponses, true);
		XmlRespMap::iterator it = m_stXmlResponses.find(ulId);
		if(it != m_stXmlResponses.end())
		{
			CString sRes = m_stXmlResponses[ulId];
			m_stXmlResponses.erase(ulId);
//			stLock.Unlock();
			return sRes;
		}
//		stLock.Unlock();
	}
	return _T("");
}
@


1.5
log
@v2 - increased level of abstraction + minor improvements
@
text
@d35 2
a36 2
	DWORD dwStart = GetTickCount();
	while(GetTickCount() - dwStart < dwTimeout)
@


1.4
log
@v2 - minor improvements
@
text
@d7 1
a7 2
	:m_hStop(NULL)
	,m_hWndUI(NULL)
a12 1
// start
d15 2
a16 35
	m_hWndUI = hWndUI;
	//	Create an Event which can be asserted to stop the Engine. If successful...
	if (m_hStop = CreateEvent(NULL, TRUE, FALSE, NULL))
	{
		//	Initialize the Sockets TaskProcessor
		m_pSocketsProcessor = new CTaskProcessor_Sockets;
		if (m_pSocketsProcessor->Init())
		{
			//	Initialize the TCP "Engine".
			if (m_pSocketsProcessor->m_stTcp.Init())
			{
				// add relevant interfaces
				//m_stTcp.AddInterface(80, T_CLIENT_WEB);
				//m_stTcp.AddInterface(7821, T_CLIENT_PEER);
			}
			else
			{
				ASSERT(FALSE);
				AddDebugLogLine("Failed to initialize TCP engine");
				return false;
			}
		}
		else
		{
			ASSERT(FALSE);
			AddDebugLogLine("Failed to initialize sockets processor");
			return false;
		}

		return true;
	}
	else
	{
		ASSERT(FALSE);
		AddDebugLogLine("CreateEvent failed");
a17 13
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// stop
void CEmEngine::Uninit()
{
	if (m_hStop)
	{
		if (!SetEvent(m_hStop))
		{
			ASSERT(FALSE);
			AddDebugLogLine("SetEvent failed");
		}
d19 1
a19 2
		m_pSocketsProcessor->m_stTcp.Uninit(false);
		m_pSocketsProcessor->Uninit();
d21 1
a21 10
		m_pSocketsProcessor->m_stTcp.Uninit(); // final
		delete m_pSocketsProcessor;

		if (!CloseHandle(m_hStop))
		{
			ASSERT(FALSE);
			AddDebugLogLine("CloseHandle failed");
		}
		m_hStop = NULL;
	}
d24 1
@


1.3
log
@v2 - more minor rearrangements
@
text
@d6 4
a9 3
CEmEngine::CEmEngine() :
 m_hStop(NULL)
,m_hWndUI(NULL)
@


1.2
log
@Ideological switch (may be considered as temporary, but for long term) - ATL to MFC
Actually we don't need them both, but I want to work with our current KnownFile-based classes, which use MFC a lot
@
text
@d2 1
d21 2
a22 1
		if (m_stSocketsTP.Init())
d25 1
a25 1
			if (m_stSocketsTP.m_stTcp.Init())
d66 2
a67 2
		m_stSocketsTP.m_stTcp.Uninit(false);
		m_stSocketsTP.Uninit();
d69 2
a70 1
		m_stSocketsTP.m_stTcp.Uninit(); // final
@


1.1
log
@XML connecting, tray app
@
text
@d77 29
@

