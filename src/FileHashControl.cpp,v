head	1.15;
access;
symbols
	PublicRelease_1_2e:1.15
	Interim_Release_1-2e_RC1:1.15
	PublicRelease_1_2d:1.15
	Interim_Release_1-2d_RC1:1.15
	Interim_Release_1-2d_beta1:1.13
	PublicRelease_1_2c:1.12
	Interim_Release_1-2c_RC1:1.12
	Interim_Release_1-2c_beta1:1.12
	PublicRelease_1_2b:1.12
	Interim_Release_1-2b_RC1:1.12
	PublicRelease_1_2a:1.12
	Interim_Release_1-2a_RC1:1.12
	Interim_Release_1-2a_beta2:1.12
	Interim_Release_1-2a_beta1:1.12
	PublicRelease_1_2:1.12
	Interim_Release_1-2_RC1:1.12
	Interim_Release_1-2_beta1:1.12
	PublicRelease_1_1g:1.12
	Interim_Release_1-1g_RC3:1.12
	Interim_Release_1-1g_RC2:1.12
	Interim_Release_1-1g_RC1:1.12
	Interim_Release_1-1g_beta2:1.10
	Interim_Release_1-1g_beta1:1.10
	PublicRelease_1_1f:1.10
	Interim_Release_1-1f_RC1:1.10
	PublicRelease_1_1e:1.10
	Interim_Release_1-1e_RC2:1.10
	Interim_Release_1-1e_RC1:1.10
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.10
	Interim_Release_1-1c_beta2:1.9
	Interim_Release_1-1c_beta1:1.9
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.9
	PublicRelease_1_1a:1.9
	Interim_Release_1-1a_RC2:1.9
	Interim_Release_1-1a_RC1:1.9
	Interim_Release_1-1a_beta2:1.9
	Interim_Release_1-1a_beta1:1.9
	PublicRelease_1_1:1.9
	Interim_Release_1-1_beta1:1.9
	PublicRelease_1o:1.9
	Interim_Release_1o_RC1:1.9
	Interim_Release_1o_beta1:1.9
	PublicRelease_1n:1.9
	Interim_Release_1n_RC2:1.9
	Interim_Release_1n_RC1:1.9
	Interim_Release_1n_beta2:1.9
	Interim_Release_1n_beta1:1.9
	PublicRelease_1m:1.9
	Interim_Release_1m_beta1:1.9
	PublicRelease_1l:1.9
	Interim_Release_1l_RC3:1.9
	Interim_Release_1l_RC2:1.9
	Interim_Release_1l_RC1:1.9
	Interim_Release_1l_beta2:1.9
	Interim_Release_1l_beta1:1.9
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.8
	Interim_Release_1J_RC3:1.8
	Interim_Release_1j_RC3:1.8
	Interim_Release_1j_RC2:1.8
	Interim_Release_1j_RC1:1.8
	Interim_Release_1j_beta2:1.8
	Interim_Release_1j_beta1:1.8
	PublicRelease_1i:1.8
	Interim_Release_1i_RC6:1.8
	Interim_Release_1i_RC3:1.8
	Interim_Release_1i_RC2:1.8
	Interim_Release_1i_RC1:1.8
	Interim_Release_1i_beta3:1.8
	Interim_Release_1i_beta2:1.8
	Interim_Release_1i_beta1:1.8
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.5
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.5
	Interim_Release_1h_beta1:1.5
	PublicRelease_1g:1.5
	Interim_Release_1g_RC6_Final:1.5
	Interim_Release_1g_RC6:1.5
	Interim_Release_1g_RC5:1.5
	Interim_Release_1g_RC4:1.5
	Interim_Release_1g_RC3:1.5
	Interim_Release_1g_beta2:1.5
	Interim_Release_1g_beta1:1.5
	Interim_Release_1f_RC4:1.5
	Interim_Release_1f_RC3:1.5
	Interim_Release_1f_RC2:1.5
	Interim_Release_1f_RC:1.5
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.5
	featurestest:1.5.0.2
	Interim_Release_1c_RC:1.5
	Interim_Release_1c_beta2:1.5
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.2
	PublicRelease_1b:1.3
	Interim_Release_1b_beta2:1.3
	Interim_Release_1b_beta1:1.3
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.15
date	2008.04.16.04.27.22;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.25.12.29.07;	author eklmn;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.27.14.27.38;	author fuxie-dk;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.17.17.41.59;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.22.15.48.06;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.18.13.13.01;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.16.21.23.09;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.02.18.29.41;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.46;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.06;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Simplified shared files hashing thread [KuSh].
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "FileHashControl.h"
#include "ProcessingCmdThread.h"
#ifndef NEW_SOCKETS_ENGINE
	#include "emule.h"
#else
	#include "otherfunctions.h"
#endif //NEW_SOCKETS_ENGINE

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


CFileHashControl::CFileHashControl(void)
	: m_bInitialized(false)
{
	m_pProcessThread = NULL;
	m_iThreadPriority = THREAD_PRIORITY_BELOW_NORMAL;
}

CFileHashControl::~CFileHashControl(void)
{
	if (m_bInitialized)
		Destroy();
}

HRESULT CFileHashControl::Init(void)
{
	HRESULT	hr;

	if (m_bInitialized)
	//	Already initialized
		return S_FALSE;

	hr = CreateProcessingThread();
	if (FAILED(hr))
		return hr;

	m_bInitialized = true;
	return S_OK;
}

HRESULT CFileHashControl::Destroy(void)
{
	HRESULT	hr = S_OK;

	if (!m_bInitialized)
		return S_OK;

	if (m_pProcessThread == NULL)
		return S_FALSE;

//	Try to kill the thread 
	hr = KillThread();
//	Reset pointers
	m_bInitialized = false;
	m_pProcessThread = NULL;
	return hr;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Adds file to the hash thread queue to be hashed
HRESULT CFileHashControl::AddToHash(const CString &strInFolder, const CString &strFileName)
{
//	Check if the current state is OK
	if (!m_bInitialized)
		return E_UNEXPECTED;

//	Try to add file to the queue
	if (!m_pProcessThread->AddFileToHash(strInFolder, strFileName))
		return E_FAIL;

	return S_OK;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CFileHashControl::CreateProcessingThread(void)
{
	if (m_pProcessThread != NULL || m_bInitialized)
		return E_UNEXPECTED;

	m_pProcessThread = reinterpret_cast<CProcessingCmdThread*>(AfxBeginThread(RUNTIME_CLASS(CProcessingCmdThread), m_iThreadPriority, 0, 0));
	if (m_pProcessThread == NULL)
		return E_FAIL;

	return S_OK;
}

HRESULT CFileHashControl::KillThread(void)
{
	if (m_pProcessThread == NULL || !m_bInitialized)
	//	If thread isn't initialized or pointer is NULL return false success
		return S_FALSE;

//	Ask the thread to stop
	m_pProcessThread->StopThread();

//	Wait until thread exits
	DWORD	dwRet = ::WaitForSingleObject(m_pProcessThread->m_hThread, 1000000);

	return (dwRet == WAIT_OBJECT_0 || dwRet == WAIT_ABANDONED) ? S_OK : E_UNEXPECTED;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SetThreadPriority() sets the runtime priority of the Hashing Thread.
void CFileHashControl::SetThreadPriority(int iPriority)
{
#ifndef NEW_SOCKETS_ENGINE
	m_iThreadPriority = iPriority;

	if (m_pProcessThread != NULL && m_bInitialized)
		m_pProcessThread->SetThreadPriority(m_iThreadPriority + g_App.m_pPrefs->GetMainProcessPriority());
#endif //NEW_SOCKETS_ENGINE
}
@


1.14
log
@Suppressed compiler warning
@
text
@d34 1
a34 1
: m_bInitialized(false)
d36 2
a37 3
	m_hCommandPipe		=	NULL;
	m_pProcessthread	=	NULL;
	m_eThreadPriority	=	ePStandard;
d42 1
a42 2
	if ( m_bInitialized )
	{
a43 1
	}
d48 1
a48 1
	HRESULT hr;
d50 2
a51 3
	if ( m_bInitialized )
	{
		// already initialized
a52 1
	}
d54 2
a55 3
	hr	=	CreateProcessingThread();
	if ( FAILED(hr) )
	{
d57 2
a58 2
	}
	m_bInitialized	=	true;
d64 3
a66 3
	HRESULT hr	=	S_OK;
	if ( !m_bInitialized )
	{
d68 2
a69 8
	}
	if ( !m_hCommandPipe || !m_pProcessthread )
	{
		// something wrong with pointers but no need to release
		if ( m_hCommandPipe )
		{
			::CloseHandle(m_hCommandPipe);
		}
d71 6
a76 6
	}
	// try to kill the thread 
	hr	=	KillProcessCmdThread();
	// reset pointers
	m_bInitialized		=	false;
	m_pProcessthread	=	NULL;
d81 1
a81 1
HRESULT CFileHashControl::AddToHash(CSharedFileList *pOwner, CString strInFolder, CString strFileName)
d83 2
a84 2
	// Check if the current state is OK
	if (!m_hCommandPipe || !m_bInitialized)
d87 2
a88 2
	// Try to add file to the queue
	if (!m_pProcessthread->AddFileToHash(m_hCommandPipe, pOwner, strInFolder, strFileName))
d96 1
a96 3
	HRESULT hr	=	S_OK;
	if ( m_pProcessthread || m_bInitialized )
	{
d98 3
a100 4
	}
	m_pProcessthread = (CProcessingCmdThread*) AfxBeginThread(RUNTIME_CLASS(CProcessingCmdThread), m_eThreadPriority,0, CREATE_SUSPENDED);
	if ( !m_pProcessthread )
	{
d102 2
a103 48
	}
	// Allocate initializtion structure 
	PThread_Init_struct *pIStruct = new PThread_Init_struct;
	if ( !pIStruct )
	{
		hr	=	E_OUTOFMEMORY;
	}
	else
	{
		// Reset it to 0
		memzero(pIStruct,sizeof(PThread_Init_struct));

		// Create the security attribute needed
		SECURITY_ATTRIBUTES saAttr;
		saAttr.nLength = sizeof(SECURITY_ATTRIBUTES); 
		saAttr.bInheritHandle = TRUE; 
		saAttr.lpSecurityDescriptor = NULL; 

		// Create pipe for commands 
		BOOL bCreatePipe = ::CreatePipe(&(pIStruct->hCommandPipe),&m_hCommandPipe,
				&saAttr,1024*sizeof(Process_Cmd_struct*)// pipe saggested Size , needed relatively big
				);
		if ( !bCreatePipe ) // if failed to create
		{
			delete[] pIStruct;
			hr	=	E_FAIL;
		}
		else
		{
			// Set startup data to the thread
			if ( !m_pProcessthread->SetStartupData(pIStruct))
			{
				delete[] pIStruct;
				::CloseHandle(m_hCommandPipe);
				m_hCommandPipe	=	NULL;
				hr	=	E_FAIL;
			}
		}
	}
	// Resume thread (make it Run) , if the thread initialization failed it will suiside right away
	m_pProcessthread->ResumeThread();	
	// if we had error on the way - reinitialize the value 
	if ( FAILED(hr) )
	{
		m_pProcessthread	=	NULL;
	}
	// Finished , return the result
	return hr;
d106 1
a106 1
HRESULT CFileHashControl::KillProcessCmdThread(void)
d108 2
a109 3
	if ( ! m_pProcessthread || !m_bInitialized || !m_hCommandPipe )
	{
		// if thread not initialized of pointer is NULL return success but a bit different
a110 5
	}
	// set stop flag
	m_pProcessthread->SetThreadToStopProcessing();
	// send stop command
	m_pProcessthread->SendQuitCommand(m_hCommandPipe);
d112 2
a113 2
	// wait until thread exits - Cax2 - it was returning E_UNEXPECTED when it should have returned S_OK & viceversa...
	BOOL bExited = m_pProcessthread->m_QuitPCmdEvent.Lock(1000000);
d115 2
a116 2
	CloseHandle(m_hCommandPipe);
	m_hCommandPipe	=	NULL;
d118 1
a118 1
	return (bExited)? S_OK:E_UNEXPECTED;
d121 2
a122 2
//	SetProcessingPriority() sets the runtime priority of the Hashing Thread.
void CFileHashControl::SetProcessingPriority(ProcessThreadPriority ePriority)
d125 1
a125 1
	m_eThreadPriority = ePriority;
d127 2
a128 4
	if (m_pProcessthread && m_bInitialized)
	{
		m_pProcessthread->SetThreadPriority(m_eThreadPriority + g_App.m_pPrefs->GetMainProcessPriority());
	}
a130 5
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
ProcessThreadPriority CFileHashControl::GetProcessPriority(void)
{
	return m_eThreadPriority;
}
@


1.13
log
@Removed unused stuff; Clean-up and formatting.
@
text
@d178 1
d180 2
a181 1
	bool exited=m_pProcessthread->m_QuitPCmdEvent.Lock(1000000);
d184 2
a185 1
	return (exited)? S_OK:E_UNEXPECTED;
@


1.12
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d1 16
d18 1
a18 1
#include "filehashcontrol.h"
d93 1
a93 1
HRESULT CFileHashControl::AddToHash(CSharedFileList*  pOwner, CString strInFolder, CString strFileName, CPartFile* in_partfile_Owner)
d96 1
a96 2
	if ( !m_hCommandPipe || !m_bInitialized )
	{
d98 1
a98 1
	}
d100 1
a100 2
	if ( !m_pProcessthread->AddFileToHash(m_hCommandPipe,pOwner,strInFolder,strFileName,in_partfile_Owner) )
	{
d102 1
a102 1
	}
@


1.11
log
@renamed 3 variables
@
text
@d179 1
a179 1
		m_pProcessthread->SetThreadPriority(m_eThreadPriority + g_App.g_pPrefs->GetMainProcessPriority());
@


1.10
log
@v2 - shared files
@
text
@d179 1
a179 1
		m_pProcessthread->SetThreadPriority(m_eThreadPriority + g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority());
@


1.9
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d1 1
a1 1
#include "StdAfx.h"
d4 5
a8 1
#include "emule.h"
d174 1
d181 1
@


1.8
log
@Formatting and comments.
@
text
@d109 1
a109 1
		::ZeroMemory(pIStruct,sizeof(PThread_Init_struct));
@


1.7
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d166 2
a167 3



d170 3
a172 2
	m_eThreadPriority	=	ePriority;
	if ( m_pProcessthread && m_bInitialized )
d177 1
a177 1

@


1.6
log
@Second batch of name changes
@
text
@d174 1
a174 1
		m_pProcessthread->SetThreadPriority(m_eThreadPriority + theApp.glob_prefs->GetMainProcessPriority());
@


1.5
log
@bugfixed Lord Kiron's bugfix
@
text
@d71 1
a71 1

d87 1
a87 1

@


1.4
log
@*** empty log message ***
@
text
@d160 3
a162 15
	// wait until thread exits
	if ( m_pProcessthread->m_QuitPCmdEvent.Lock(1000000) )
	{
		::CloseHandle(m_hCommandPipe);
		m_hCommandPipe	=	NULL;
		// Problem , the thread did not exited on this huge timeout
		return E_UNEXPECTED;
	}
	/*CSingleLock QuitLock(&(m_pProcessthread->m_QuitPCmdEvent));
	if ( !QuitLock.Lock(1000000) )
	{
		// Problem , the thread did not exited on this huge timeout
		return E_UNEXPECTED;
	}*/
	::CloseHandle(m_hCommandPipe);
d164 1
a164 1
	return S_OK;
@


1.3
log
@Priority control
@
text
@d161 8
a168 1
	CSingleLock QuitLock(&(m_pProcessthread->m_QuitPCmdEvent));
d173 1
a173 1
	}
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d4 1
d179 1
a179 1
		m_pProcessthread->SetThreadPriority(m_eThreadPriority);
@


1.1
log
@*** empty log message ***
@
text
@d5 7
@


1.1.4.1
log
@updating this branch...
@
text
@@

