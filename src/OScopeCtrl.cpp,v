head	1.18;
access;
symbols
	PublicRelease_1_2e:1.18
	Interim_Release_1-2e_RC1:1.18
	PublicRelease_1_2d:1.18
	Interim_Release_1-2d_RC1:1.18
	Interim_Release_1-2d_beta1:1.18
	PublicRelease_1_2c:1.17
	Interim_Release_1-2c_RC1:1.17
	Interim_Release_1-2c_beta1:1.17
	PublicRelease_1_2b:1.17
	Interim_Release_1-2b_RC1:1.17
	PublicRelease_1_2a:1.16
	Interim_Release_1-2a_RC1:1.16
	Interim_Release_1-2a_beta2:1.16
	Interim_Release_1-2a_beta1:1.16
	PublicRelease_1_2:1.16
	Interim_Release_1-2_RC1:1.16
	Interim_Release_1-2_beta1:1.16
	PublicRelease_1_1g:1.16
	Interim_Release_1-1g_RC3:1.16
	Interim_Release_1-1g_RC2:1.16
	Interim_Release_1-1g_RC1:1.16
	Interim_Release_1-1g_beta2:1.15
	Interim_Release_1-1g_beta1:1.15
	PublicRelease_1_1f:1.15
	Interim_Release_1-1f_RC1:1.15
	PublicRelease_1_1e:1.15
	Interim_Release_1-1e_RC2:1.15
	Interim_Release_1-1e_RC1:1.15
	Interim_Release_1-1e_beta1:1.15
	PublicRelease_1_1d:1.15
	Interim_Release_1-1d_RC1:1.15
	PublicRelease_1_1c:1.15
	Interim_Release_1-1c_RC1:1.15
	Interim_Release_1-1c_beta2:1.15
	Interim_Release_1-1c_beta1:1.15
	PublicRelease_1_1b:1.14
	Interim_Release_1-1b_RC1:1.14
	PublicRelease_1_1a:1.14
	Interim_Release_1-1a_RC2:1.14
	Interim_Release_1-1a_RC1:1.14
	Interim_Release_1-1a_beta2:1.13
	Interim_Release_1-1a_beta1:1.13
	PublicRelease_1_1:1.13
	Interim_Release_1-1_beta1:1.13
	PublicRelease_1o:1.13
	Interim_Release_1o_RC1:1.13
	Interim_Release_1o_beta1:1.13
	PublicRelease_1n:1.13
	Interim_Release_1n_RC2:1.13
	Interim_Release_1n_RC1:1.12
	Interim_Release_1n_beta2:1.12
	Interim_Release_1n_beta1:1.12
	PublicRelease_1m:1.12
	Interim_Release_1m_beta1:1.12
	PublicRelease_1l:1.12
	Interim_Release_1l_RC3:1.12
	Interim_Release_1l_RC2:1.12
	Interim_Release_1l_RC1:1.12
	Interim_Release_1l_beta2:1.12
	Interim_Release_1l_beta1:1.12
	PublicRelease_1k:1.11
	Interim_Release_1k_RC4:1.11
	Interim_1k_RC3:1.11
	Interim_1k_RC2:1.11
	Interim_Release_1k_RC1:1.11
	Interim_Release_1k_beta5:1.11
	Intrerim_Release_1k_beta4:1.11
	Interim_Release_1k_beta1:1.11
	PublicRelease_1j:1.11
	Interim_Release_1J_RC3:1.11
	Interim_Release_1j_RC3:1.11
	Interim_Release_1j_RC2:1.11
	Interim_Release_1j_RC1:1.11
	Interim_Release_1j_beta2:1.11
	Interim_Release_1j_beta1:1.11
	PublicRelease_1i:1.11
	Interim_Release_1i_RC6:1.11
	Interim_Release_1i_RC3:1.11
	Interim_Release_1i_RC2:1.11
	Interim_Release_1i_RC1:1.11
	Interim_Release_1i_beta3:1.11
	Interim_Release_1i_beta2:1.11
	Interim_Release_1i_beta1:1.11
	PublicRelease_1h:1.8
	Interim_Release_1h_rc2:1.8
	Interim_Release_1h_RC1:1.8
	Interim_Release_1h_beta2:1.8
	Interim_Release_1h_beta1_now:1.8
	Interim_Release_1h_beta1:1.8
	PublicRelease_1g:1.8
	Interim_Release_1g_RC6_Final:1.8
	Interim_Release_1g_RC6:1.8
	Interim_Release_1g_RC5:1.8
	Interim_Release_1g_RC4:1.7
	Interim_Release_1g_RC3:1.7
	Interim_Release_1g_beta2:1.6
	Interim_Release_1g_beta1:1.6
	Interim_Release_1f_RC4:1.6
	Interim_Release_1f_RC3:1.6
	Interim_Release_1f_RC2:1.5
	Interim_Release_1f_RC:1.5
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.5
	featurestest:1.5.0.8
	Interim_Release_1c_RC:1.5
	Interim_Release_1c_beta2:1.5
	Interim_Release_1c_beta1:1.5
	threaded_downloadqueue:1.5.0.6
	PublicRelease_1b:1.5
	Interim_Release_1b_beta2:1.5
	Interim_Release_1b_beta1:1.5
	proxydeadlake:1.5.0.4
	PublicRelease_1a:1.5
	Interim_Release_1a_beta2:1.5
	BerkeleyDb:1.5.0.2
	Interim_Release_1a_beta1:1.5
	PublicRelease_1:1.5
	goldfish:1.5
	eMulePlus_1_RC2:1.5
	eMulePlus_26b_1RC1:1.4
	PreRelease_26b_i0e:1.4
	before_26d_merge:1.4
	Interim_Release_26b_i0d:1.3
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.18
date	2008.01.29.05.52.22;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2006.12.11.21.32.10;	author eklmn;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.28.05.02.44;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.23.23.47.17;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.31.18.04.34;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2004.04.14.01.21.54;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.03.13.53.43;	author eklmn;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.03.07.48.47;	author eklmn;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.8;

1.8
date	2003.07.09.16.14.21;	author netwolf1;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.15.13.41.13;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.20.20.46.28;	author netwolf1;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.19.13.14.47;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.14.19.11.46;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.11.18.26.48;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.11.09.59.01;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.20;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.18;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Redraw statistics plots without delay after window restore or size change (from original) {Vladimir (SV)};
Formatting.
@
text
@// OScopeCtrl.cpp : implementation file

#include "stdafx.h"
#include "emule.h"
#include "math.h"

#include "OScopeCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COScopeCtrl
COScopeCtrl::COScopeCtrl(int NTrends)
{
	EMULE_TRY

	int i;
	static const COLORREF aPresetColor[16] =
	{
		RGB(0xFF, 0x00, 0x00),
		RGB(0xFF, 0xC0, 0xC0),

		RGB(0xFF, 0xFF, 0x00),
		RGB(0xFF, 0xA0, 0x00),
		RGB(0xA0, 0x60, 0x00),

		RGB(0x00, 0xFF, 0x00),
		RGB(0x00, 0xA0, 0x00),

		RGB(0x00, 0x00, 0xFF),
		RGB(0x00, 0xA0, 0xFF),
		RGB(0x00, 0xFF, 0xFF),
		RGB(0x00, 0xA0, 0xA0),

		RGB(0xC0, 0xC0, 0xFF),
		RGB(0xFF, 0x00, 0xFF),
		RGB(0xA0, 0x00, 0xA0),

		RGB(0xFF, 0xFF, 0xFF),
		RGB(0x80, 0x80, 0x80)
	};
	// since plotting is based on a LineTo for each new point
	// we need a starting point (i.e. a "previous" point)
	// use 0.0 as the default first point.
	// these are public member variables, and can be changed outside
	// (after construction).
	// G.Hayduk: NTrends is the number of trends that will be drawn on
	// the plot. First 15 plots have predefined colors, but others will
	// be drawn with white, unless you call SetPlotColor
	m_PlotData = new PlotData_t[NTrends];
	m_NTrends = NTrends;

	for(i = 0; i < m_NTrends; i++)
	{
		if(i < 15)
			m_PlotData[i].crPlotColor = aPresetColor[i];  // see also SetPlotColor
		else
			m_PlotData[i].crPlotColor  = RGB(255, 255, 255);  // see also SetPlotColor
		m_PlotData[i].penPlot.CreatePen(PS_SOLID, 0, m_PlotData[i].crPlotColor);
		m_PlotData[i].dPreviousPosition = 0.0;
		m_PlotData[i].nPrevY = -1;
		m_PlotData[i].dLowerLimit = -10.0;
		m_PlotData[i].dUpperLimit =  10.0;
		m_PlotData[i].dRange      =   m_PlotData[i].dUpperLimit -
			m_PlotData[i].dLowerLimit;   // protected member variable
		m_PlotData[i].lstPoints.AddTail(0.0);
	}

	// public variable for the number of decimal places on the y axis
	// G.Hayduk: I've deleted the possibility of changing this parameter
	// in SetRange, so change it after constructing the plot
	m_nYDecimals = 1;

	// set some initial values for the scaling until "SetRange" is called.
	// these are protected varaibles and must be set with SetRange
	// in order to ensure that m_dRange is updated accordingly

	// m_nShiftPixels determines how much the plot shifts (in terms of pixels)
	// with the addition of a new data point
	autofitYscale = false;
	m_nShiftPixels = 1;
	m_nTrendPoints = 0;
	m_nMaxPointCnt = 600;
	CustShift.m_nPointsToDo = 0;
	// G.Hayduk: actually I needed an OScopeCtrl to draw specific number of
	// data samples and stretch them on the plot ctrl. Now, OScopeCtrl has
	// two modes of operation: fixed Shift (when m_nTrendPoints=0,
	// m_nShiftPixels is in use), or fixed number of Points in the plot width
	// (when m_nTrendPoints>0)
	// When m_nTrendPoints>0, CustShift structure is in use

	// background, grid and data colors
	// these are public variables and can be set directly
	m_crBackColor  = RGB(0,   0,   0);  // see also SetBackgroundColor
	m_crGridColor  = RGB(0, 255, 255);  // see also SetGridColor

	// public member variables, can be set directly
	m_str.XUnits.Format(_T("Samples"));  // can also be set with SetXUnits
	m_str.YUnits.Format(_T("Y units"));  // can also be set with SetYUnits

	// protected bitmaps to restore the memory DC's
	m_pbitmapOldGrid = NULL;
	m_pbitmapOldPlot = NULL;

	// G.Hayduk: configurable number of grids init
	// you are free to change those between contructing the object
	// and calling Create
	m_nXGrids = 6;
	m_nYGrids = 5;
	m_nTrendPoints = -1;

	m_bDoUpdate = true;
	m_nRedrawTimer = 0;

	m_oldcx = 0;
	m_oldcy = 0;

	EMULE_CATCH2
}  // COScopeCtrl

/////////////////////////////////////////////////////////////////////////////
COScopeCtrl::~COScopeCtrl()
{
	EMULE_TRY

	// just to be picky restore the bitmaps for the two memory dc's
	// (these dc's are being destroyed so there shouldn't be any leaks)
	if (m_pbitmapOldGrid != NULL)
		m_dcGrid.SelectObject(m_pbitmapOldGrid);
	if (m_pbitmapOldPlot != NULL)
		m_dcPlot.SelectObject(m_pbitmapOldPlot);
	delete[] m_PlotData;
	// G.Hayduk: If anyone notices that I'm not freeing or deleting
	// something, please let me know: hayduk@@hello.to

	EMULE_CATCH2
} // ~COScopeCtrl


BEGIN_MESSAGE_MAP(COScopeCtrl, CWnd)
	//{{AFX_MSG_MAP(COScopeCtrl)
	ON_WM_PAINT()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
	ON_WM_TIMER()
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// COScopeCtrl message handlers

/////////////////////////////////////////////////////////////////////////////
BOOL COScopeCtrl::Create(DWORD dwStyle, const RECT& rect,
		                     CWnd* pParentWnd, UINT nID)
{
	BOOL result;

	EMULE_TRY

	static CString className = AfxRegisterWndClass(CS_HREDRAW | CS_VREDRAW);

	result = CWnd::CreateEx(WS_EX_CLIENTEDGE | WS_EX_STATICEDGE,
		className, NULL, dwStyle,
		rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
		pParentWnd->GetSafeHwnd(), (HMENU)nID);
	if(result != 0)
		InvalidateCtrl();

	EMULE_CATCH

	return result;
} // Create

/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::SetRange(double dLower, double dUpper, int iTrend)
{
	EMULE_TRY

	ASSERT(dUpper > dLower);

	m_PlotData[iTrend].dLowerLimit     = dLower;
	m_PlotData[iTrend].dUpperLimit     = dUpper;
	m_PlotData[iTrend].dRange          = m_PlotData[iTrend].dUpperLimit - m_PlotData[iTrend].dLowerLimit;
	m_PlotData[iTrend].dVerticalFactor = (double)m_nPlotHeight / m_PlotData[iTrend].dRange;

	// clear out the existing garbage, re-start with a clean plot
	InvalidateCtrl();

	EMULE_CATCH
}  // SetRange

void COScopeCtrl::SetRanges(double dLower, double dUpper)
{
	EMULE_TRY

	int iTrend;
	ASSERT(dUpper > dLower);

	for(iTrend = 0; iTrend < m_NTrends; iTrend ++)
	{
		m_PlotData[iTrend].dLowerLimit     = dLower;
		m_PlotData[iTrend].dUpperLimit     = dUpper;
		m_PlotData[iTrend].dRange          = m_PlotData[iTrend].dUpperLimit - m_PlotData[iTrend].dLowerLimit;
		m_PlotData[iTrend].dVerticalFactor = (double)m_nPlotHeight / m_PlotData[iTrend].dRange;
	}

	// clear out the existing garbage, re-start with a clean plot
	InvalidateCtrl();

	EMULE_CATCH
}  // SetRange
/////////////////////////////////////////////////////////////////////////////
// G.Hayduk: Apart from setting title of axis, now you can optionally set
// the limits strings
// (string which will be placed on the left and right of axis)
void COScopeCtrl::SetXUnits(CString string, CString XMin, CString XMax)
{
	m_str.XUnits = string;
	m_str.XMin = XMin;
	m_str.XMax = XMax;

	InvalidateCtrl(false);
}  // SetXUnits


/////////////////////////////////////////////////////////////////////////////
// G.Hayduk: Apart from setting title of axis, now you can optionally set
// the limits strings
// (string which will be placed on the bottom and top of axis)
void COScopeCtrl::SetYUnits(CString string, CString YMin, CString YMax)
{
	m_str.YUnits = string;
	m_str.YMin = YMin;
	m_str.YMax = YMax;

	// clear out the existing garbage, re-start with a clean plot
	InvalidateCtrl();
}  // SetYUnits

/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::SetGridColor(COLORREF color)
{
	m_crGridColor = color;

	// clear out the existing garbage, re-start with a clean plot
	InvalidateCtrl();
}  // SetGridColor


/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::SetPlotColor(COLORREF color, int iTrend)
{
	EMULE_TRY

//	Black is used as a masked background, modify plot color if it's black
	if (color == RGB(0, 0, 0))
		color++;
	m_PlotData[iTrend].crPlotColor = color;

	m_PlotData[iTrend].penPlot.DeleteObject();
	m_PlotData[iTrend].penPlot.CreatePen(PS_SOLID, 0, m_PlotData[iTrend].crPlotColor);

	// clear out the existing garbage, re-start with a clean plot
	//	InvalidateCtrl() ;

	EMULE_CATCH
}  // SetPlotColor

COLORREF COScopeCtrl::GetPlotColor(int iTrend)
{
	EMULE_TRY

	return m_PlotData[iTrend].crPlotColor;

	EMULE_CATCH

	return RGB(0,0,0);
}  // GetPlotColor

/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::SetBackgroundColor(COLORREF color)
{
	m_crBackColor = color;

	// clear out the existing garbage, re-start with a clean plot
	InvalidateCtrl();
}  // SetBackgroundColor

/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::InvalidateCtrl(bool deleteGraph)
{
	EMULE_TRY

	// There is a lot of drawing going on here - particularly in terms of
	// drawing the grid.  Don't panic, this is all being drawn (only once)
	// to a bitmap.  The result is then BitBlt'd to the control whenever needed.
	int i, j, GridPos;
	int nCharacters;

	CPen *oldPen;
	CPen solidPen(PS_SOLID, 0, m_crGridColor);
	CFont axisFont, yUnitFont, *oldFont;
	CString strTemp;

	// in case we haven't established the memory dc's
	CClientDC dc(this);

	// if we don't have one yet, set up a memory dc for the grid
	if(m_dcGrid.GetSafeHdc() == NULL)
	{
		m_dcGrid.CreateCompatibleDC(&dc);
		m_bitmapGrid.DeleteObject();
		m_bitmapGrid.CreateCompatibleBitmap(&dc, m_nClientWidth, m_nClientHeight);
		m_pbitmapOldGrid = m_dcGrid.SelectObject(&m_bitmapGrid);
	}

//	Fill the grid background (background color, previously set using SetBkColor, is changed inside)
	m_dcGrid.FillSolidRect(m_rectClient, m_crBackColor);

	// draw the plot rectangle:
	// determine how wide the y axis scaling values are
	nCharacters = abs((int)log10(fabs(m_PlotData[0].dUpperLimit)));

	// add the units digit, decimal point and a minus sign, and an extra space
	// as well as the number of decimal places to display
	nCharacters = nCharacters + 4 + m_nYDecimals;

	// adjust the plot rectangle dimensions
	// assume 6 pixels per character (this may need to be adjusted)
	m_rectPlot.left = m_rectClient.left + 8*7+4;//(nCharacters) ; // DonGato 8 was 6
	m_nPlotWidth    = m_rectPlot.Width();

	// draw the plot rectangle
	oldPen = m_dcGrid.SelectObject(&solidPen);
	m_dcGrid.MoveTo(m_rectPlot.left, m_rectPlot.top);
	m_dcGrid.LineTo(m_rectPlot.right + 1, m_rectPlot.top);
	m_dcGrid.LineTo(m_rectPlot.right + 1, m_rectPlot.bottom + 1);
	m_dcGrid.LineTo(m_rectPlot.left, m_rectPlot.bottom + 1);
	m_dcGrid.LineTo(m_rectPlot.left, m_rectPlot.top);
	m_dcGrid.SelectObject(oldPen);

	// draw the dotted lines,
	// use SetPixel instead of a dotted pen - this allows for a
	// finer dotted line and a more "technical" look
	// G.Hayduk: added configurable number of grids
	for(j = 1; j < (m_nYGrids + 1); j++)
	{
		GridPos = m_rectPlot.Height()*j/ (m_nYGrids + 1) + m_rectPlot.top;
		for(i = m_rectPlot.left; i < m_rectPlot.right; i += 4)
			m_dcGrid.SetPixel(i, GridPos, m_crGridColor);
	}

	// create some fonts (horizontal and vertical)
	// use a height of 14 pixels and 300 weight
	// (these may need to be adjusted depending on the display)
	axisFont.CreateFont(14, 0, 0, 0, FW_LIGHT,
		FALSE, FALSE, 0, DEFAULT_CHARSET, // EC
		OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY,
		DEFAULT_PITCH | FF_SWISS, _T("Arial"));
	yUnitFont.CreateFont(14, 0, 900, 0, FW_LIGHT,
		FALSE, FALSE, 0, DEFAULT_CHARSET, // EC
		OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		DEFAULT_QUALITY,
		DEFAULT_PITCH | FF_SWISS, _T("Arial"));

	// grab the horizontal font
	oldFont = m_dcGrid.SelectObject(&axisFont);

	// y max
	m_dcGrid.SetTextColor(m_crGridColor);
	m_dcGrid.SetTextAlign(TA_RIGHT | TA_TOP);
	if(m_str.YMax.IsEmpty())
		strTemp.Format(_T("%.*lf"), m_nYDecimals, m_PlotData[0].dUpperLimit);
	else
		strTemp = m_str.YMax;
	m_dcGrid.TextOut(m_rectPlot.left - 4, m_rectPlot.top - 7, strTemp);

	// y/2
	strTemp.Format(_T("%.*lf"), m_nYDecimals, m_PlotData[0].dUpperLimit / 2);
	m_dcGrid.TextOut(m_rectPlot.left - 2, m_rectPlot.bottom+ ((m_rectPlot.top - m_rectPlot.bottom)/2) - 7 , strTemp);


	// y min
	m_dcGrid.SetTextAlign(TA_RIGHT | TA_BASELINE);
	if(m_str.YMin.IsEmpty())
		strTemp.Format(_T("%.*lf"), m_nYDecimals, m_PlotData[0].dLowerLimit);
	else
		strTemp = m_str.YMin;
	m_dcGrid.TextOut(m_rectPlot.left - 4, m_rectPlot.bottom, strTemp);
	/*
	// x min
	m_dcGrid.SetTextAlign(TA_LEFT | TA_TOP);
	if(m_str.XMin.IsEmpty())
	m_dcGrid.TextOut(m_rectPlot.left, m_rectPlot.bottom + 4, "0");
	else
	m_dcGrid.TextOut(m_rectPlot.left, m_rectPlot.bottom + 4, (LPCTSTR)m_str.XMin);

	  // x max
	  m_dcGrid.SetTextAlign(TA_RIGHT | TA_TOP);
	  if(m_str.XMax.IsEmpty())
	  {
	  if(m_nTrendPoints < 0)
	  strTemp.Format("%d", m_nPlotWidth/m_nShiftPixels);
	  else
	  strTemp.Format("%d", m_nTrendPoints - 1);
	  }
	  else
	  strTemp = m_str.XMax;
	  m_dcGrid.TextOut(m_rectPlot.right, m_rectPlot.bottom + 4, strTemp);
	*/
	// x units
	m_dcGrid.SetTextAlign(TA_CENTER | TA_TOP);
	m_dcGrid.TextOut((m_rectPlot.left + m_rectPlot.right)/2,
		m_rectPlot.bottom + 4, m_str.XUnits);

	// restore the font
	m_dcGrid.SelectObject(oldFont);

	// y units
	oldFont = m_dcGrid.SelectObject(&yUnitFont);
	m_dcGrid.SetTextAlign(TA_CENTER | TA_BASELINE);

	CRect rText(0,0,0,0);
	m_dcGrid.DrawText(m_str.YUnits, rText, DT_CALCRECT);
	m_dcGrid.TextOut((m_rectClient.left+m_rectPlot.left+4)/2-rText.Height() / 2,
		((m_rectPlot.bottom+m_rectPlot.top)/2)-rText.Height()/2, m_str.YUnits);
	m_dcGrid.SelectObject(oldFont);

	// at this point we are done filling the the grid bitmap,
	// no more drawing to this bitmap is needed until the setting are changed

	// if we don't have one yet, set up a memory dc for the plot
	if(m_dcPlot.GetSafeHdc() == NULL)
	{
		m_dcPlot.CreateCompatibleDC(&dc);
		m_bitmapPlot.DeleteObject();
		m_bitmapPlot.CreateCompatibleBitmap(&dc, m_nClientWidth, m_nClientHeight);
		m_pbitmapOldPlot = m_dcPlot.SelectObject(&m_bitmapPlot);
	//	Must be black to make possible fast bitmap masking
		m_dcPlot.SetBkColor(RGB(0, 0, 0));
	}

	// make sure the plot bitmap is cleared
	if(deleteGraph)
	{
	//	Fast way to fill a rectangular
		m_dcPlot.ExtTextOut(0, 0, ETO_OPAQUE, m_rectClient, NULL, 0, NULL);
	}

	int iNewSize = m_rectClient.Width() / m_nShiftPixels + 10;		// +10 just in case :)
	if(m_nMaxPointCnt < iNewSize)
		m_nMaxPointCnt = iNewSize;									// keep the bigest value
	m_bDoUpdate = false;

	if (g_App.m_pMDlg->IsRunning())
	{
		if (m_nRedrawTimer != 0)
			KillTimer(m_nRedrawTimer);
		m_nRedrawTimer = SetTimer(1612, 200, NULL);	// Reduce flickering
	}

	// finally, force the plot area to redraw
	InvalidateRect(m_rectClient);

	EMULE_CATCH
} // InvalidateCtrl


/////////////////////////////////////////////////////////////////////////////
// G.Hayduk: now, there are two methods: AppendPoints and AppendEmptyPoints
void COScopeCtrl::AppendPoints(double dNewPoint[], bool bInvalidate, bool bAdd2List)
{
	EMULE_TRY
	if (::IsWindow(m_hWnd)==false) return;
	int iTrend;

	// append a data point to the plot
	for(iTrend = 0; iTrend < m_NTrends; iTrend ++)
	{
		m_PlotData[iTrend].dCurrentPosition = dNewPoint[iTrend];
		if(bAdd2List)
		{
			m_PlotData[iTrend].lstPoints.AddTail(dNewPoint[iTrend]);
			while(m_PlotData[iTrend].lstPoints.GetCount() > m_nMaxPointCnt)
				m_PlotData[iTrend].lstPoints.RemoveHead();
		}
	}

	if(m_nTrendPoints > 0)
	{
		if(CustShift.m_nPointsToDo == 0)
		{
			CustShift.m_nPointsToDo = m_nTrendPoints - 1;
			CustShift.m_nWidthToDo = m_nPlotWidth;
			CustShift.m_nRmndr = 0;
		}

		// a little bit tricky setting m_nShiftPixels in "fixed number of points through plot width" mode
		m_nShiftPixels = (CustShift.m_nWidthToDo + CustShift.m_nRmndr) / CustShift.m_nPointsToDo;
		CustShift.m_nRmndr = (CustShift.m_nWidthToDo + CustShift.m_nRmndr) % CustShift.m_nPointsToDo;
		if(CustShift.m_nPointsToDo == 1)
			m_nShiftPixels = CustShift.m_nWidthToDo;
		CustShift.m_nWidthToDo -= m_nShiftPixels;
		CustShift.m_nPointsToDo--;
	}
	DrawPoint();

	if (bInvalidate && m_bDoUpdate && GetSafeHwnd())
		Invalidate();

	EMULE_CATCH
	return;
} // AppendPoint

/////////////////////////////////////////////////////////////////////////////
// G.Hayduk:
// AppendEmptyPoints adds a vector of data points, without drawing them
// (but shifting the plot), this way you can do a "hole" (space) in the plot
// i.e. indicating "no data here". When points are available, call AppendEmptyPoints
// for first valid vector of data points, and then call AppendPoints again and again
// for valid points

void COScopeCtrl::AppendEmptyPoints(double dNewPoint[], bool bInvalidate, bool bAdd2List)
{
	EMULE_TRY

	int iTrend, currY;
	// append a data point to the plot
	// return the previous point
	for(iTrend = 0; iTrend < m_NTrends; iTrend ++)
	{
		m_PlotData[iTrend].dCurrentPosition = dNewPoint[iTrend];
		if(bAdd2List)
			m_PlotData[iTrend].lstPoints.AddTail(dNewPoint[iTrend]);
	}
	if(m_nTrendPoints > 0)
	{
		if(CustShift.m_nPointsToDo == 0)
		{
			CustShift.m_nPointsToDo = m_nTrendPoints - 1;
			CustShift.m_nWidthToDo = m_nPlotWidth;
			CustShift.m_nRmndr = 0;
		}
		m_nShiftPixels = (CustShift.m_nWidthToDo + CustShift.m_nRmndr) / CustShift.m_nPointsToDo;
		CustShift.m_nRmndr = (CustShift.m_nWidthToDo + CustShift.m_nRmndr) % CustShift.m_nPointsToDo;
		if(CustShift.m_nPointsToDo == 1)
			m_nShiftPixels = CustShift.m_nWidthToDo;
		CustShift.m_nWidthToDo -= m_nShiftPixels;
		CustShift.m_nPointsToDo--;
	}

	// now comes DrawPoint's shift process

	if(m_dcPlot.GetSafeHdc() != NULL)
	{
		if (m_nShiftPixels > 0)
		{
			CRect	rectUpdatedRect = m_rectPlot;

			rectUpdatedRect.right++;
			m_dcPlot.ScrollDC(-m_nShiftPixels, 0, &rectUpdatedRect, &rectUpdatedRect, NULL, NULL);

		//	Establish a rectangle over the right side of plot
		//	which now needs to be cleaned up prior to adding the new point
			rectUpdatedRect.left = rectUpdatedRect.right - m_nShiftPixels;
		//	Fast way to fill the cleanup area with the background
			m_dcPlot.ExtTextOut(0, 0, ETO_OPAQUE, rectUpdatedRect, NULL, 0, NULL);
		}

		// draw the next line segment
		for(iTrend = 0; iTrend < m_NTrends; iTrend ++)
		{
			currY = m_rectPlot.bottom -
				(long)((m_PlotData[iTrend].dCurrentPosition - m_PlotData[iTrend].dLowerLimit) * m_PlotData[iTrend].dVerticalFactor);
			m_PlotData[iTrend].nPrevY = currY;

			// store the current point for connection to the next point
			m_PlotData[iTrend].dPreviousPosition = m_PlotData[iTrend].dCurrentPosition;
		}
	}

	// -----------------------------------------

	if(bInvalidate && m_bDoUpdate)
		Invalidate();

	EMULE_CATCH
	return;
} // AppendEmptyPoint

////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::OnPaint()
{
	EMULE_TRY

	CPaintDC dc(this);  // device context for painting
	CDC memDC, dcMask;
	CBitmap memBitmap, maskBitmap;
	CBitmap *oldBitmap, *pOldMaskBitmap;

	// no real plotting work is performed here,
	// just putting the existing bitmaps on the client

	// to avoid flicker, establish a memory dc, draw to it
	// and then BitBlt it to the client
	memDC.CreateCompatibleDC(&dc);
	memBitmap.CreateCompatibleBitmap(&dc, m_nClientWidth, m_nClientHeight);
	oldBitmap = (CBitmap *)memDC.SelectObject(&memBitmap);

	dcMask.CreateCompatibleDC(&dc);
//	Monochrome DC
	maskBitmap.CreateBitmap(m_nClientWidth, m_nClientHeight, 1, 1, NULL);
	pOldMaskBitmap = dcMask.SelectObject(&maskBitmap);

	if ((memDC.GetSafeHdc() != NULL) && (dcMask.GetSafeHdc() != NULL))
	{
	//	Create the object mask by performing BitBlt from the source bitmap to a monochrome bitmap
	//	The background is already set to transparent color (black)
		dcMask.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, &m_dcPlot, 0, 0, SRCCOPY);
	// First drop the grid on the memory dc
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, &m_dcGrid, 0, 0, SRCCOPY);
	//	Now add the plot on top as a "pattern"
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, &dcMask, 0, 0, SRCAND);
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, &m_dcPlot, 0, 0, SRCPAINT);
	//	Finally send the result to the display (only one on-screen copy to reduce flicker)
		dc.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, &memDC, 0, 0, SRCCOPY);
	}
	memDC.SelectObject(oldBitmap);
	dcMask.SelectObject(pOldMaskBitmap);
	memBitmap.DeleteObject();
	maskBitmap.DeleteObject();

	EMULE_CATCH
} // OnPaint

/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::DrawPoint()
{
	EMULE_TRY

	// this does the work of "scrolling" the plot to the left
	// and appending a new data point all of the plotting is
	// directed to the memory based bitmap associated with m_dcPlot
	// the will subsequently be BitBlt'd to the client in OnPaint

	if (m_dcPlot.GetSafeHdc() != NULL)
	{
		if (m_nShiftPixels > 0)
		{
			CRect	rectUpdatedRect = m_rectPlot;

			rectUpdatedRect.right++;
			rectUpdatedRect.left++;
			m_dcPlot.ScrollDC(-m_nShiftPixels, 0, &rectUpdatedRect, &rectUpdatedRect, NULL, NULL);

		//	Establish a rectangle over the right side of plot
		//	which now needs to be cleaned up prior to adding the new point
			rectUpdatedRect.left = rectUpdatedRect.right - m_nShiftPixels;
		//	Fast way to fill the cleanup area with the background
			m_dcPlot.ExtTextOut(0, 0, ETO_OPAQUE, rectUpdatedRect, NULL, 0, NULL);
		}

		CPen	   *pOldPen = m_dcPlot.GetCurrentPen();
		int			currX, prevX, currY, prevY, iTrend;

		// draw the next line segment
		for(iTrend = 0; iTrend < m_NTrends; iTrend ++)
		{
			// grab the plotting pen
			m_dcPlot.SelectObject(&m_PlotData[iTrend].penPlot);

			// move to the previous point
			prevX = m_rectPlot.right - m_nShiftPixels;
			if(m_PlotData[iTrend].nPrevY > 0)
			{
				prevY = m_PlotData[iTrend].nPrevY;
			}
			else
			{
				prevY = m_rectPlot.bottom -
				(long)((m_PlotData[iTrend].dPreviousPosition - m_PlotData[iTrend].dLowerLimit) * m_PlotData[iTrend].dVerticalFactor);
			}
			m_dcPlot.MoveTo(prevX, prevY);

			// draw to the current point
			currX = m_rectPlot.right;
			currY = m_rectPlot.bottom -
				(long)((m_PlotData[iTrend].dCurrentPosition - m_PlotData[iTrend].dLowerLimit) * m_PlotData[iTrend].dVerticalFactor);
			m_PlotData[iTrend].nPrevY = currY;

			if (abs(prevX - currX) > abs(prevY - currY))
			{
				currX += (prevX - currX > 0) ? -1 : 1;
			}
			else
			{
				currY += (prevY - currY > 0) ? -1 : 1;
			}
			m_dcPlot.LineTo(currX, currY);

			// if the data leaks over the upper or lower plot boundaries
			// fill the upper and lower leakage with the background
			// this will facilitate clipping on an as needed basis
			// as opposed to always calling IntersectClipRect
			if((prevY <= m_rectPlot.top) || (currY <= m_rectPlot.top))
				m_dcPlot.ExtTextOut( 0, 0, ETO_OPAQUE,
					CRect(prevX - 1, m_rectClient.top, currX + 5, m_rectPlot.top + 1), NULL, 0, NULL );
			if((prevY >= m_rectPlot.bottom) || (currY >= m_rectPlot.bottom))
				m_dcPlot.ExtTextOut( 0, 0, ETO_OPAQUE,
					CRect(prevX - 1, m_rectPlot.bottom + 1, currX + 5, m_rectClient.bottom + 1), NULL, 0, NULL );

			// store the current point for connection to the next point
			m_PlotData[iTrend].dPreviousPosition = m_PlotData[iTrend].dCurrentPosition;
		}
		// restore the pen
		m_dcPlot.SelectObject(pOldPen);
	}

	EMULE_CATCH
} // end DrawPoint

/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::OnSize(UINT nType, int cx, int cy)
{
	EMULE_TRY

	CWnd::OnSize(nType, cx, cy);
	if ((!cx && !cy) || (cx==m_oldcx && cy==m_oldcy)) return;
	m_oldcx=cx;m_oldcy=cy;

	int iTrend;

	// NOTE: OnSize automatically gets called during the setup of the control

	GetClientRect(m_rectClient);

	// set some member variables to avoid multiple function calls
	m_nClientHeight = m_rectClient.Height();
	m_nClientWidth  = m_rectClient.Width();

	// the "left" coordinate and "width" will be modified in
	// InvalidateCtrl to be based on the width of the y axis scaling
	m_rectPlot.left   = 20;
	m_rectPlot.top    = 10;
	m_rectPlot.right  = m_rectClient.right - 10;
	m_rectPlot.bottom = m_rectClient.bottom - 25;

	// set some member variables to avoid multiple function calls
	m_nPlotHeight = m_rectPlot.Height();
	m_nPlotWidth  = m_rectPlot.Width();

	// set the scaling factor for now, this can be adjusted
	// in the SetRange functions
	for(iTrend = 0; iTrend < m_NTrends; iTrend ++)
		m_PlotData[iTrend].dVerticalFactor = (double)m_nPlotHeight / m_PlotData[iTrend].dRange;

	// destroy and recreate the grid bitmap
	CClientDC dc(this);
	if(m_pbitmapOldGrid && m_bitmapGrid.GetSafeHandle() && m_dcGrid.GetSafeHdc())
	{
		m_dcGrid.SelectObject(m_pbitmapOldGrid);
		m_bitmapGrid.DeleteObject();
		m_bitmapGrid.CreateCompatibleBitmap(&dc, m_nClientWidth, m_nClientHeight);
		m_pbitmapOldGrid = m_dcGrid.SelectObject(&m_bitmapGrid);
	}

	// destroy and recreate the plot bitmap
	if(m_pbitmapOldPlot && m_bitmapPlot.GetSafeHandle() && m_dcPlot.GetSafeHdc())
	{
		m_dcPlot.SelectObject(m_pbitmapOldPlot);
		m_bitmapPlot.DeleteObject();
		m_bitmapPlot.CreateCompatibleBitmap(&dc, m_nClientWidth, m_nClientHeight);
		m_pbitmapOldPlot = m_dcPlot.SelectObject(&m_bitmapPlot);
	}

	InvalidateCtrl();

	EMULE_CATCH
} // OnSize


/////////////////////////////////////////////////////////////////////////////
void COScopeCtrl::Reset()
{
	// to clear the existing data (in the form of a bitmap)
	// simply invalidate the entire control
	InvalidateCtrl();
}

int COScopeCtrl::ReCreateGraph(void)
{
	EMULE_TRY

	int i;
	for(i = 0; i < m_NTrends; i++)
	{
		m_PlotData[i].dPreviousPosition = 0.0;
		m_PlotData[i].nPrevY = -1;
	}

	double *pAddPoints = new double[m_NTrends];

	int iCnt = m_PlotData[0].lstPoints.GetCount();
	for(i = 0; i < iCnt; i++)
	{
		for(int iTrend = 0; iTrend < m_NTrends; iTrend++)
		{
			POSITION pos = m_PlotData[iTrend].lstPoints.FindIndex(i);
			if(pos)
				pAddPoints[iTrend] = m_PlotData[iTrend].lstPoints.GetAt(pos);
			else
				pAddPoints[iTrend] = 0;
		}
		AppendPoints(pAddPoints, false, false);
	}

	delete[] pAddPoints;

	Invalidate();	// Draw the new graph without waiting for the next AppendPoints()

	EMULE_CATCH

	return 0;
}

void COScopeCtrl::ReSizePlot(int iTrend,double scale)		//Cax2 - Resize one line of the graph, don't touch the other lines...
{
	EMULE_TRY

	m_PlotData[iTrend].dPreviousPosition = 0.0;
	m_PlotData[iTrend].nPrevY = -1;

	int iCnt = m_PlotData[0].lstPoints.GetCount();
	for(int i = 0; i < iCnt; i++)
	{
		POSITION pos = m_PlotData[iTrend].lstPoints.FindIndex(i);
		if(pos)
			m_PlotData[iTrend].lstPoints.SetAt(pos,m_PlotData[iTrend].lstPoints.GetAt(pos)*scale);
	}

	EMULE_CATCH
}

void COScopeCtrl::OnTimer(UINT nIDEvent)
{
	if (nIDEvent == m_nRedrawTimer)
	{
		KillTimer(m_nRedrawTimer);
		m_nRedrawTimer = 0;
		m_bDoUpdate = true;
		ReCreateGraph();
	}

	CWnd::OnTimer(nIDEvent);
}
@


1.17
log
@remove useless max()-function
@
text
@a356 9
	/*
	for(j = 1; j < (m_nXGrids + 1); j++)
	{
	GridPos = m_rectPlot.Width()*j/ (m_nXGrids + 1) + m_rectPlot.left;
	for(i = m_rectPlot.top; i < m_rectPlot.bottom; i += 4)
	m_dcGrid.SetPixel(GridPos, i, m_crGridColor);
	}
	*/

d360 1
a360 2
	axisFont.CreateFont(14, 0, 0, 0, 300,
		//FALSE, FALSE, 0, ANSI_CHARSET,
d366 1
a366 2
	yUnitFont.CreateFont(14, 0, 900, 0, 300,
		//FALSE, FALSE, 0, ANSI_CHARSET,
d457 10
a466 13
	if(true)	// more to come *g*
	{
		int iNewSize = m_rectClient.Width() / m_nShiftPixels + 10;		// +10 just in case :)
		if(m_nMaxPointCnt < iNewSize)
			m_nMaxPointCnt = iNewSize;									// keep the bigest value
		m_bDoUpdate = false;

		if (g_App.m_pMDlg->IsRunning())
		{
			if (m_nRedrawTimer != 0)
				KillTimer(m_nRedrawTimer);
			m_nRedrawTimer = SetTimer(1612, 200, NULL);	// Reduce flickering
		}
d515 1
a515 1
	if(bInvalidate && m_bDoUpdate && GetSafeHwnd() )
d826 2
@


1.16
log
@renamed 3 variables
@
text
@a326 1
	nCharacters = max(nCharacters, abs((int)log10(fabs(m_PlotData[0].dLowerLimit))));
@


1.15
log
@Fixed minor statistics plot shift to the left.
@
text
@d476 1
a476 1
		if (g_eMuleApp.m_pdlgEmule->IsRunning())
@


1.14
log
@Formatting and minor optimization by KuSh.
@
text
@d675 1
d705 1
a705 1
			m_dcPlot.MoveTo(prevX - 1, prevY);
d721 1
a721 1
			m_dcPlot.LineTo(currX - 1, currY);
@


1.13
log
@Fixed display of dark statistics plots on light background [reported by muleteer];
Faster rectangular filling; Reduced number of used GDI objects;
Removed unused code; whitespace formatting.
@
text
@d50 1
a50 1
	// (after construction).  
d91 1
a91 1
	// two modes of operation: fixed Shift (when m_nTrendPoints=0, 
d101 1
a101 1
	// public member variables, can be set directly 
d110 1
a110 1
	// you are free to change those between contructing the object 
d132 1
a132 1
	if(m_pbitmapOldGrid != NULL)
d134 1
a134 1
	if(m_pbitmapOldPlot != NULL)
d184 1
a184 1
	
d188 1
a188 1
	m_PlotData[iTrend].dVerticalFactor = (double)m_nPlotHeight / m_PlotData[iTrend].dRange; 
d321 1
a321 1
// Fill the grid background (background color, previously set using SetBkColor, is changed inside)
d422 1
a422 1
	  strTemp.Format("%d", m_nPlotWidth/m_nShiftPixels); 
d424 1
a424 1
	  strTemp.Format("%d", m_nTrendPoints - 1); 
d448 1
a448 1
	// at this point we are done filling the the grid bitmap, 
d476 3
a478 2
		if (g_eMuleApp.m_pdlgEmule->IsRunning()) {
			if(m_nRedrawTimer)
d480 2
a481 3
			m_nRedrawTimer = SetTimer(1612, 200, NULL); // reduce flickering
			//ReCreateGraph();
			}
a549 1
	CRect ScrollRect, rectCleanUp;
d578 1
a578 1
		if(m_nShiftPixels > 0)
d580 8
a587 13
			ScrollRect.left = m_rectPlot.left;
			ScrollRect.top  = m_rectPlot.top + 1;
			ScrollRect.right  = m_rectPlot.left + m_nPlotWidth;
			ScrollRect.bottom = m_rectPlot.top + 1 + m_nPlotHeight;
			ScrollRect = m_rectPlot;
			ScrollRect.right++;
			m_dcPlot.ScrollDC(-m_nShiftPixels, 0, (LPCRECT)&ScrollRect, (LPCRECT)&ScrollRect, NULL, NULL);

			// establish a rectangle over the right side of plot
			// which now needs to be cleaned up prior to adding the new point
			rectCleanUp = m_rectPlot;
			rectCleanUp.left = rectCleanUp.right - m_nShiftPixels + 1;
			rectCleanUp.right++;
d589 1
a589 1
			m_dcPlot.ExtTextOut(0, 0, ETO_OPAQUE, rectCleanUp, NULL, 0, NULL);
d623 1
a623 1
	// no real plotting work is performed here, 
d664 1
a664 1
	// and appending a new data point all of the plotting is 
d668 5
a672 1
	int currX, prevX, currY, prevY, iTrend;
d674 2
a675 2
	CPen *oldPen;
	CRect ScrollRect, rectCleanUp;
d677 3
a679 22
	if(m_dcPlot.GetSafeHdc() != NULL)
	{
		//	BitBlt was replaced by call to ScrollDC
		//		m_dcPlot.BitBlt(m_rectPlot.left, m_rectPlot.top+1,
		//		                m_nPlotWidth, m_nPlotHeight, &m_dcPlot,
		//		                m_rectPlot.left+m_nShiftPixels, m_rectPlot.top+1,
		//		                SRCCOPY) ;
		if(m_nShiftPixels > 0)
		{
			ScrollRect.left = m_rectPlot.left;
			ScrollRect.top  = m_rectPlot.top + 1;
			ScrollRect.right  = m_rectPlot.left + m_nPlotWidth;
			ScrollRect.bottom = m_rectPlot.top + 1 + m_nPlotHeight;
			ScrollRect = m_rectPlot;
			ScrollRect.right ++;
			m_dcPlot.ScrollDC(-m_nShiftPixels, 0, (LPCRECT)&ScrollRect, (LPCRECT)&ScrollRect, NULL, NULL);

			// establish a rectangle over the right side of plot
			// which now needs to be cleaned up proir to adding the new point
			rectCleanUp = m_rectPlot;
			rectCleanUp.left = rectCleanUp.right - m_nShiftPixels + 1;
			rectCleanUp.right++;
d681 1
a681 1
			m_dcPlot.ExtTextOut(0, 0, ETO_OPAQUE, rectCleanUp, NULL, 0, NULL);
d684 3
d691 1
a691 1
			oldPen = m_dcPlot.SelectObject(&m_PlotData[iTrend].penPlot);
d701 1
a701 1
				prevY = m_rectPlot.bottom - 
d711 2
a712 1
			if(abs(prevX - currX) > abs(prevY - currY))
d714 1
a714 1
				currX += prevX - currX>0 ? -1 : 1;
d716 1
a716 1
			else 
d718 1
a718 1
				currY += prevY - currY>0 ? -1 : 1;
a721 3
			// restore the pen 
			m_dcPlot.SelectObject(oldPen);

d736 2
d779 1
a779 1
	CClientDC dc(this); 
d865 1
a865 1
	if(nIDEvent == m_nRedrawTimer)
@


1.12
log
@Dynamic array is transformed into constant; whitespace corrections.
@
text
@d1 1
a1 1
// OScopeCtrl.cpp : implementation file//
a83 1
	drawBars = false;
a100 3
	// protected variables
	m_brushBack.CreateSolidBrush(m_crBackColor);

d259 3
a288 3
	m_brushBack.DeleteObject();
	m_brushBack.CreateSolidBrush(m_crBackColor);

d321 2
a322 6
	m_dcGrid.SetBkColor(m_crBackColor);

	// fill the grid background
	pOldBrush = m_dcGrid.SelectObject(&m_brushBack);	//eklmn: select a new brush
	m_dcGrid.FillRect(m_rectClient, &m_brushBack);
	m_dcGrid.SelectObject(pOldBrush);// eklmn:recover an old brush
d444 1
a444 1
	m_dcGrid.TextOut ((m_rectClient.left+m_rectPlot.left+4)/2-rText.Height() / 2,
d458 2
d465 2
a466 4
		m_dcPlot.SetBkColor(m_crBackColor);
		pOldBrush = m_dcPlot.SelectObject(&m_brushBack);	//eklmn: select a new brush
		m_dcPlot.FillRect(m_rectClient, &m_brushBack);
		m_dcPlot.SelectObject(pOldBrush);// eklmn:recover an old brush
d482 1
a482 1
		}
d586 1
a586 1
			ScrollRect.right ++;
d590 1
a590 1
			// which now needs to be cleaned up proir to adding the new point
d592 4
a595 6
			rectCleanUp.left  = rectCleanUp.right - m_nShiftPixels + 1;
			rectCleanUp.right ++;
			// fill the cleanup area with the background
			pOldBrush = m_dcPlot.SelectObject(&m_brushBack);	//eklmn: select a new brush
			m_dcPlot.FillRect(rectCleanUp, &m_brushBack);
			m_dcPlot.SelectObject(pOldBrush);	//eklmn: recover an old brush
d625 3
a627 3
	CDC memDC;
	CBitmap memBitmap;
	CBitmap* oldBitmap; // bitmap originally found in CMemDC
d638 17
a654 12
	if(memDC.GetSafeHdc() != NULL)
	{
		// first drop the grid on the memory dc
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight,
			&m_dcGrid, 0, 0, SRCCOPY);
		// now add the plot on top as a "pattern" via SRCPAINT.
		// works well with dark background and a light plot
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight,
			&m_dcPlot, 0, 0, SRCPAINT);  // SRCPAINT
		// finally send the result to the display
		dc.BitBlt(0, 0, m_nClientWidth, m_nClientHeight,
		          &memDC, 0, 0, SRCCOPY);
d657 1
d659 1
d699 4
a702 6
			rectCleanUp.left  = rectCleanUp.right - m_nShiftPixels + 1;
			rectCleanUp.right ++;
			// fill the cleanup area with the background
			pOldBrush = m_dcPlot.SelectObject(&m_brushBack);	//eklmn: select a new brush
			m_dcPlot.FillRect(rectCleanUp, &m_brushBack);
			m_dcPlot.SelectObject(pOldBrush);	//eklmn: recover an old brush
a737 3
			if(drawBars)
				m_dcPlot.LineTo(currX - 1, m_rectPlot.bottom);
			// m_dcPlot.Rectangle(currX-1,currY,currX-1,m_rectPlot.bottom);
a745 1
			pOldBrush = m_dcPlot.SelectObject(&m_brushBack);	//eklmn: select a new brush
d747 2
a748 1
				m_dcPlot.FillRect(CRect(prevX - 1, m_rectClient.top, currX + 5, m_rectPlot.top + 1), &m_brushBack);
d750 2
a751 2
				m_dcPlot.FillRect(CRect(prevX - 1, m_rectPlot.bottom + 1, currX + 5, m_rectClient.bottom + 1), &m_brushBack);
			m_dcPlot.SelectObject(pOldBrush);	//eklmn: recover an old brush
@


1.11
log
@an incorrect use of
GDI resources (CBrush class)
@
text
@d22 1
a22 1
	COLORREF PresetColor[16] = 
d25 20
a44 20
			RGB(0xFF, 0xC0, 0xC0),
			
			RGB(0xFF, 0xFF, 0x00),
			RGB(0xFF, 0xA0, 0x00),
			RGB(0xA0, 0x60, 0x00),
			
			RGB(0x00, 0xFF, 0x00),
			RGB(0x00, 0xA0, 0x00),
			
			RGB(0x00, 0x00, 0xFF),
			RGB(0x00, 0xA0, 0xFF),
			RGB(0x00, 0xFF, 0xFF),
			RGB(0x00, 0xA0, 0xA0),
			
			RGB(0xC0, 0xC0, 0xFF),
			RGB(0xFF, 0x00, 0xFF),
			RGB(0xA0, 0x00, 0xA0),
			
			RGB(0xFF, 0xFF, 0xFF),
			RGB(0x80, 0x80, 0x80)
d56 1
a56 1
	
d60 1
a60 1
			m_PlotData[i].crPlotColor  = PresetColor[i];  // see also SetPlotColor
d68 1
a68 1
		m_PlotData[i].dRange      =   m_PlotData[i].dUpperLimit - 
d72 1
a72 1
	
d77 1
a77 1
	
d81 2
a82 2
	
	// m_nShiftPixels determines how much the plot shifts (in terms of pixels) 
d96 1
a96 1
	
d101 1
a101 1
	
d104 1
a104 1
	
d108 1
a108 1
	
d112 1
a112 1
	
d137 1
a137 1
		m_dcGrid.SelectObject(m_pbitmapOldGrid);  
d139 1
a139 1
		m_dcPlot.SelectObject(m_pbitmapOldPlot);  
d161 2
a162 2
BOOL COScopeCtrl::Create(DWORD dwStyle, const RECT& rect, 
		                     CWnd* pParentWnd, UINT nID) 
d169 3
a171 3
	
	result = CWnd::CreateEx(WS_EX_CLIENTEDGE | WS_EX_STATICEDGE, 
		className, NULL, dwStyle, 
d178 1
a178 1
	
d193 1
a193 1
	
d206 1
a206 1
	
d212 1
a212 1
		m_PlotData[iTrend].dVerticalFactor = (double)m_nPlotHeight / m_PlotData[iTrend].dRange; 
d214 1
a214 1
	
d221 1
a221 1
// G.Hayduk: Apart from setting title of axis, now you can optionally set 
d229 1
a229 1
	
d235 1
a235 1
// G.Hayduk: Apart from setting title of axis, now you can optionally set 
d243 1
a243 1
	
d252 1
a252 1
	
d264 1
a264 1
	
d267 1
a267 1
	
d289 1
a289 1
	
d292 1
a292 1
	
d302 1
a302 1
	// There is a lot of drawing going on here - particularly in terms of 
d307 1
a307 1
	
d312 1
a312 1
	
d314 2
a315 2
	CClientDC dc(this);  
	
d324 1
a324 1
	
d328 1
a328 1
	pOldBrush = m_dcGrid.SelectObject(&m_brushBack);	//eklmn: select a new brush	
d331 1
a331 1
	
d336 1
a336 1
	
d339 2
a340 2
	nCharacters = nCharacters + 4 + m_nYDecimals;  
	
d345 1
a345 1
	
d347 1
a347 1
	oldPen = m_dcGrid.SelectObject(&solidPen); 
d353 4
a356 4
	m_dcGrid.SelectObject(oldPen); 
	
	// draw the dotted lines, 
	// use SetPixel instead of a dotted pen - this allows for a 
d365 1
a365 1
	
d374 1
a374 1
	
d376 1
a376 1
	// use a height of 14 pixels and 300 weight 
d381 1
a381 1
		OUT_DEFAULT_PRECIS, 
d383 1
a383 1
		DEFAULT_QUALITY, 
d388 1
a388 1
		OUT_DEFAULT_PRECIS, 
d390 1
a390 1
		DEFAULT_QUALITY, 
d392 1
a392 1
	
d395 1
a395 1
	
d404 1
a404 1
	
d408 2
a409 2
	
	
d424 1
a424 1
	
d440 1
a440 1
	m_dcGrid.TextOut((m_rectPlot.left + m_rectPlot.right)/2, 
d442 1
a442 1
	
d445 1
a445 1
	
d449 1
a449 1
	
d452 2
a453 2
	m_dcGrid.TextOut ((m_rectClient.left+m_rectPlot.left+4)/2-rText.Height() / 2, 
		((m_rectPlot.bottom+m_rectPlot.top)/2)-rText.Height()/2, m_str.YUnits) ;
d455 1
a455 1
	
d458 1
a458 1
	
d467 1
a467 1
	
d472 1
a472 1
		pOldBrush = m_dcPlot.SelectObject(&m_brushBack);	//eklmn: select a new brush	
d506 1
a506 1
	
d518 1
a518 1
	
d527 1
a527 1
		
d537 1
a537 1
	
d550 1
a550 1
// for first valid vector of data points, and then call AppendPoints again and again 
d582 1
a582 1
	
d584 1
a584 1
	
d596 1
a596 1
			
d607 2
a608 2
		
		// draw the next line segement
d614 1
a614 1
			
d619 1
a619 1
	
d621 1
a621 1
	
d624 1
a624 1
	
d628 1
a628 1
 
d630 1
a630 1
void COScopeCtrl::OnPaint() 
d638 1
a638 1
	
d641 2
a642 2
	
	// to avoid flicker, establish a memory dc, draw to it 
d647 1
a647 1
	
d651 1
a651 1
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, 
d655 1
a655 1
		memDC.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, 
d658 1
a658 1
		dc.BitBlt(0, 0, m_nClientWidth, m_nClientHeight, 
d661 1
a661 1
	memDC.SelectObject(oldBitmap); // FoRcHa
d676 1
a676 1
	
d678 1
a678 1
	
d681 1
a681 1
	
d685 3
a687 3
		//		m_dcPlot.BitBlt(m_rectPlot.left, m_rectPlot.top+1, 
		//		                m_nPlotWidth, m_nPlotHeight, &m_dcPlot, 
		//		                m_rectPlot.left+m_nShiftPixels, m_rectPlot.top+1, 
d698 1
a698 1
			
d709 2
a710 2
		
		// draw the next line segement
d715 1
a715 1
			
d728 1
a728 1
			
d746 1
a746 1
			
d749 1
a749 1
			
d760 1
a760 1
			
d777 1
a777 1
	
d779 1
a779 1
	
d781 1
a781 1
	
d783 1
a783 1
	
d787 1
a787 1
	
d790 1
a790 1
	m_rectPlot.left   = 20; 
d794 1
a794 1
	
d798 1
a798 1
	
d803 1
a803 1
	
d813 1
a813 1
	
d822 1
a822 1
	
d847 1
a847 1
	
d849 1
a849 1
	
d852 1
a852 1
	{	
d863 1
a863 1
	
d871 1
a871 1
void COScopeCtrl::ReSizePlot(int iTrend,double scale)		//Cax2 - Resize one line of the graph, don't touch the other lines... 
d877 1
a877 1
		
d880 1
a880 1
	{	
@


1.10
log
@small fix for fix in OnSize
@
text
@d326 1
a326 1
	
d328 1
d330 1
d472 1
d474 1
d603 1
d605 1
d705 1
d707 1
d754 1
d759 1
@


1.9
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d123 3
a763 3
	if ((!cx && !cy) || (cx==m_oldcx && cy==m_oldcy))
		return;
	int iTrend;
d765 1
d767 2
@


1.8
log
@minor changes
@
text
@d477 1
a477 1
		if (theApp.emuledlg->IsRunning()) {
@


1.7
log
@unicode cleanup
@
text
@d712 1
d715 1
@


1.6
log
@minor fixes and improvements
@
text
@d106 2
a107 2
	m_str.XUnits.Format("Samples");  // can also be set with SetXUnits
	m_str.YUnits.Format("Y units");  // can also be set with SetYUnits
d379 1
a379 1
		DEFAULT_PITCH | FF_SWISS, "Arial");
d386 1
a386 1
		DEFAULT_PITCH | FF_SWISS, "Arial");
d395 1
a395 1
		strTemp.Format("%.*lf", m_nYDecimals, m_PlotData[0].dUpperLimit);
d401 1
a401 1
	strTemp.Format("%.*lf", m_nYDecimals, m_PlotData[0].dUpperLimit / 2);
d408 1
a408 1
		strTemp.Format("%.*lf", m_nYDecimals, m_PlotData[0].dLowerLimit);
@


1.5
log
@BUGFIX: updated statistics graphs because of a minor bug with KB/s text overlapping numbers [Cax2]
@
text
@d88 1
a88 1
	m_nMaxPointCnt = 1024;
d476 8
a483 6
		
		if(m_nRedrawTimer)
			KillTimer(m_nRedrawTimer);
		m_nRedrawTimer = SetTimer(1612, 100, NULL); // reduce flickering
		//ReCreateGraph();
	}
d497 1
a497 1

d533 1
a533 1
	
d535 1
d617 1
d759 1
a759 1
	if (!cx && !cy)
d763 1
@


1.4
log
@*** empty log message ***
@
text
@d338 1
a338 1
	m_rectPlot.left = m_rectClient.left + 6*7+4;//(nCharacters) ;
@


1.3
log
@*** empty log message ***
@
text
@d529 1
a529 1
	if(bInvalidate && m_bDoUpdate)
@


1.2
log
@Crash fixes
@
text
@d4 1
@


1.1
log
@*** empty log message ***
@
text
@d18 2
d121 2
d128 2
d139 2
d161 3
d172 2
d181 2
d192 2
d198 2
d213 2
d257 2
d266 2
d272 2
d275 4
d296 2
d484 2
d493 2
d531 1
a531 1
	return;
d544 2
d612 1
a612 1
	return;
d618 2
d649 2
d656 2
d745 2
d752 2
d803 2
d818 2
d845 2
d852 1
d865 1
@


1.1.4.1
log
@updating this branch...
@
text
@@

