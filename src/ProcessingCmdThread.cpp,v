head	1.23;
access;
symbols
	PublicRelease_1_2e:1.23
	Interim_Release_1-2e_RC1:1.23
	PublicRelease_1_2d:1.22
	Interim_Release_1-2d_RC1:1.22
	Interim_Release_1-2d_beta1:1.21
	PublicRelease_1_2c:1.20
	Interim_Release_1-2c_RC1:1.20
	Interim_Release_1-2c_beta1:1.20
	PublicRelease_1_2b:1.20
	Interim_Release_1-2b_RC1:1.20
	PublicRelease_1_2a:1.20
	Interim_Release_1-2a_RC1:1.20
	Interim_Release_1-2a_beta2:1.20
	Interim_Release_1-2a_beta1:1.19
	PublicRelease_1_2:1.19
	Interim_Release_1-2_RC1:1.19
	Interim_Release_1-2_beta1:1.19
	PublicRelease_1_1g:1.19
	Interim_Release_1-1g_RC3:1.19
	Interim_Release_1-1g_RC2:1.19
	Interim_Release_1-1g_RC1:1.19
	Interim_Release_1-1g_beta2:1.17
	Interim_Release_1-1g_beta1:1.17
	PublicRelease_1_1f:1.17
	Interim_Release_1-1f_RC1:1.17
	PublicRelease_1_1e:1.17
	Interim_Release_1-1e_RC2:1.17
	Interim_Release_1-1e_RC1:1.17
	Interim_Release_1-1e_beta1:1.17
	PublicRelease_1_1d:1.16
	Interim_Release_1-1d_RC1:1.16
	PublicRelease_1_1c:1.16
	Interim_Release_1-1c_RC1:1.16
	Interim_Release_1-1c_beta2:1.14
	Interim_Release_1-1c_beta1:1.14
	PublicRelease_1_1b:1.14
	Interim_Release_1-1b_RC1:1.14
	PublicRelease_1_1a:1.14
	Interim_Release_1-1a_RC2:1.14
	Interim_Release_1-1a_RC1:1.14
	Interim_Release_1-1a_beta2:1.14
	Interim_Release_1-1a_beta1:1.14
	PublicRelease_1_1:1.14
	Interim_Release_1-1_beta1:1.14
	PublicRelease_1o:1.14
	Interim_Release_1o_RC1:1.14
	Interim_Release_1o_beta1:1.14
	PublicRelease_1n:1.14
	Interim_Release_1n_RC2:1.14
	Interim_Release_1n_RC1:1.14
	Interim_Release_1n_beta2:1.14
	Interim_Release_1n_beta1:1.14
	PublicRelease_1m:1.14
	Interim_Release_1m_beta1:1.14
	PublicRelease_1l:1.14
	Interim_Release_1l_RC3:1.14
	Interim_Release_1l_RC2:1.14
	Interim_Release_1l_RC1:1.14
	Interim_Release_1l_beta2:1.14
	Interim_Release_1l_beta1:1.14
	PublicRelease_1k:1.13
	Interim_Release_1k_RC4:1.13
	Interim_1k_RC3:1.13
	Interim_1k_RC2:1.13
	Interim_Release_1k_RC1:1.13
	Interim_Release_1k_beta5:1.13
	Intrerim_Release_1k_beta4:1.13
	Interim_Release_1k_beta1:1.12
	PublicRelease_1j:1.12
	Interim_Release_1J_RC3:1.12
	Interim_Release_1j_RC3:1.12
	Interim_Release_1j_RC2:1.12
	Interim_Release_1j_RC1:1.12
	Interim_Release_1j_beta2:1.12
	Interim_Release_1j_beta1:1.12
	PublicRelease_1i:1.12
	Interim_Release_1i_RC6:1.12
	Interim_Release_1i_RC3:1.12
	Interim_Release_1i_RC2:1.12
	Interim_Release_1i_RC1:1.12
	Interim_Release_1i_beta3:1.12
	Interim_Release_1i_beta2:1.12
	Interim_Release_1i_beta1:1.11
	PublicRelease_1h:1.9
	Interim_Release_1h_rc2:1.9
	Interim_Release_1h_RC1:1.9
	Interim_Release_1h_beta2:1.9
	Interim_Release_1h_beta1_now:1.9
	Interim_Release_1h_beta1:1.9
	PublicRelease_1g:1.9
	Interim_Release_1g_RC6_Final:1.9
	Interim_Release_1g_RC6:1.9
	Interim_Release_1g_RC5:1.9
	Interim_Release_1g_RC4:1.9
	Interim_Release_1g_RC3:1.9
	Interim_Release_1g_beta2:1.5
	Interim_Release_1g_beta1:1.5
	Interim_Release_1f_RC4:1.5
	Interim_Release_1f_RC3:1.5
	Interim_Release_1f_RC2:1.5
	Interim_Release_1f_RC:1.5
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.5
	featurestest:1.5.0.2
	Interim_Release_1c_RC:1.5
	Interim_Release_1c_beta2:1.5
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.3
	Interim_Release_1b_beta2:1.3
	Interim_Release_1b_beta1:1.3
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.23
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2008.04.16.04.26.42;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.27.14.27.38;	author fuxie-dk;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.13.04.45.27;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.27.22.11.49;	author eklmn;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.17;

1.17
date	2005.06.06.04.41.11;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2005.02.18.16.19.50;	author kuchin;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.17.17.41.59;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.13;

1.13
date	2004.03.20.12.32.10;	author eklmn;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.24.01.21.20;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.20.15.39.31;	author morevit;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.28.10.26.30;	author partyckip;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.22.18.04.22;	author partyckip;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.21.18.49.03;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.21.18.37.57;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.16.13.39.22;	author recdvst;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.14.11.14.58;	author lord_kiron;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.02.18.29.42;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.48;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.22;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.24;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Reduced H-file dependency.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#ifndef NEW_SOCKETS_ENGINE
	#include "emule.h"
#else
	#include "otherfunctions.h"
	#include "Engine/Files/TaskProcessorFiles.h"
#endif //NEW_SOCKETS_ENGINE
#include "ProcessingCmdThread.h"
#include "SharedFileList.h"
#include "KnownFile.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

IMPLEMENT_DYNCREATE(CProcessingCmdThread, CWinThread)

BEGIN_MESSAGE_MAP(CProcessingCmdThread, CWinThread)
	ON_THREAD_MESSAGE(CMD_HASH, OnHash)
	ON_THREAD_MESSAGE(CMD_STOP, OnStop)
END_MESSAGE_MAP()

CProcessingCmdThread::CProcessingCmdThread()
{
}

BOOL CProcessingCmdThread::InitInstance()
{
#ifdef EP_SPIDERWEB
//	Setup Structured Exception handler for the this thread
	_set_se_translator(StructuredExceptionHandler);
#endif
	return TRUE;
}

//	Stop the thread
bool CProcessingCmdThread::StopThread()
{
	bool	bPosted = true;

	if (m_hThread != NULL && !IsThreadAboutToStop())
		bPosted = B2b(PostThreadMessage(CMD_STOP, 0, 0));

	return bPosted;
}

bool CProcessingCmdThread::IsThreadAboutToStop()
{
	MSG	msg;

	return B2b(::PeekMessage(&msg, reinterpret_cast<HWND>(-1), CMD_STOP, CMD_STOP, PM_NOREMOVE));
}

void CProcessingCmdThread::OnHash(WPARAM wParam, LPARAM lParam)
{
	NOPRM(wParam);
	UnknownFile_Struct	*pStruct = reinterpret_cast<UnknownFile_Struct*>(lParam);
	bool	bDelete = true;

	if (!IsThreadAboutToStop())
		bDelete = HashFile(pStruct);
	else if (GetThreadPriority() < g_App.m_pPrefs->GetMainProcessPriority())
	//	We need to boost priority to exit faster
		SetThreadPriority(g_App.m_pPrefs->GetMainProcessPriority() + THREAD_PRIORITY_NORMAL);

	if (bDelete)
		delete pStruct;
}

void CProcessingCmdThread::OnStop(WPARAM wParam, LPARAM lParam)
{
	NOPRM(wParam); NOPRM(lParam);
	MSG	msg;

//	Purge all messages
	while (::PeekMessage(&msg, reinterpret_cast<HWND>(-1), CMD_HASH, CMD_STOP, PM_REMOVE))
	{
	//	Free hashing informations
		if (msg.message == CMD_HASH)
			delete reinterpret_cast<UnknownFile_Struct*>(msg.lParam);
	}

	::PostQuitMessage(0);
}

// Performs actual hashing of the file
bool CProcessingCmdThread::HashFile(UnknownFile_Struct *pStruct)
{
	bool	bDelete = true;
	CKnownFile	*pNewFile = new CKnownFile();

	if (pNewFile != NULL)
	{
	//	Run creation of the hash data from file
		if (pNewFile->CreateFromFile(pStruct->m_strDirectory, pStruct->m_strFileName, false))
		{
#ifndef NEW_SOCKETS_ENGINE
		//	Notify main program about finished hashing
		//	It assumes that window getting this message will at some point release the buffer
		//	theoretically, in some border cases, it can cause small memory leak, but it's unlikely
			if ( IsThreadAboutToStop() || g_App.m_pMDlg == NULL || !g_App.m_pMDlg->IsRunning() || !::IsWindow(g_App.m_pMDlg->m_hWnd) ||
				!::PostMessage(g_App.m_pMDlg->m_hWnd, TM_FINISHEDHASHING, 0, reinterpret_cast<LPARAM>(pNewFile)) )
			{
				delete pNewFile;
			}
#else
			CTask_FileHashed	*pTask = new CTask_FileHashed(NULL, pNewFile);

			g_stEngine.Files.Push(pTask);
#endif //NEW_SOCKETS_ENGINE
		}
		else
		{
#ifndef NEW_SOCKETS_ENGINE
		//	Notify main program of hash failure
			if (g_App.m_pMDlg != NULL && g_App.m_pMDlg->IsRunning() && ::IsWindow(g_App.m_pMDlg->m_hWnd))
				bDelete = !::PostMessage(g_App.m_pMDlg->m_hWnd, TM_HASHFAILED, 0, reinterpret_cast<LPARAM>(pStruct));
#endif //NEW_SOCKETS_ENGINE
			delete pNewFile;
		}
	}

	return bDelete;
}

// Adds file to hashing queue
bool CProcessingCmdThread::AddFileToHash(const CString &strFolder, const CString &strFileName)
{
//	Check if we can add something
	if (m_hThread == NULL || IsThreadAboutToStop())
		return false;

	UnknownFile_Struct	*pStruct = new UnknownFile_Struct;

//	Fill transfer structure with processing data
	pStruct->m_strDirectory = strFolder;
	pStruct->m_strFileName = strFileName;

	bool	bPosted = B2b(PostThreadMessage(CMD_HASH, 0, reinterpret_cast<LPARAM>(pStruct)));

	if (!bPosted)
		delete pStruct;

	return bPosted;
}
@


1.22
log
@Simplified shared files hashing thread [KuSh];
Preparations for comprehensive exception handling [Aw3].
@
text
@d25 1
@


1.21
log
@Removed unused stuff; Clean-up and formatting.
@
text
@d33 1
d35 4
a38 2

IMPLEMENT_DYNCREATE(CProcessingCmdThread, CWinThread)
a41 11
	m_hCommandPipe	=	NULL;
	SetStopThread(false);
}

CProcessingCmdThread::~CProcessingCmdThread()
{
	if ( m_hCommandPipe )
	{
		CloseHandle(m_hCommandPipe);
		m_hCommandPipe = NULL;
	}
d46 4
a49 4
	if ( !m_hCommandPipe || m_bStopThread )
	{
		return FALSE;
	}
d53 2
a54 1
int CProcessingCmdThread::ExitInstance()
d56 1
a56 3
//	TODO:  perform any per-thread cleanup here
	return CWinThread::ExitInstance();
}
d58 2
a59 2
BEGIN_MESSAGE_MAP(CProcessingCmdThread, CWinThread)
END_MESSAGE_MAP()
d61 2
d64 3
a66 1
// CProcessingCmdThread message handlers
d68 1
a68 13
BOOL CProcessingCmdThread::SetStartupData(PThread_Init_struct* pInitStruct)
{
	if ( !pInitStruct )
	{
		return FALSE;
	}
	if ( pInitStruct->hCommandPipe == NULL )
	{
		return FALSE;
	}
	m_hCommandPipe	=	pInitStruct->hCommandPipe;
	delete[] pInitStruct;
	return TRUE;
d71 1
a71 1
int CProcessingCmdThread::Run()
d73 3
a75 4
	bool bReadPipeOK;
	DWORD dwBytesActuallyRead;
	bool bBustedPrioraty = false;
	bool bQuitCycle = false;
d77 5
a81 32
	if (!m_hCommandPipe)
		return -1;

	do
	{
		Process_Cmd_struct Struct;
		// Read From pipe , in case of now data it just waits on pipe 
		bReadPipeOK = ::ReadFile(m_hCommandPipe,(LPVOID)&Struct,(DWORD)sizeof(Process_Cmd_struct),&dwBytesActuallyRead,NULL);	
		// if pipe read OK 
		if(bReadPipeOK &&(dwBytesActuallyRead == sizeof(Process_Cmd_struct)) )
		{
			// if we started and found out that we should to exit soon
			// we shouldn't process any messages , just release the memory in the queue
			// until we get quit message , we need this to deallocate all string that was allocated in passed
			// Struct.cFileName and Struct.cFolder to avoid memory leaks
			if ( IsThreadAboutToStop()&& Struct.eCommand != PC_QUIT )
			{
				// we need to bust the prioraty to exit fast
				// and it's OK , since no processing is done here
				if ( !bBustedPrioraty )
				{
#ifndef NEW_SOCKETS_ENGINE
					SetThreadPriority(THREAD_PRIORITY_NORMAL+ g_App.m_pPrefs->GetMainProcessPriority());
#endif //NEW_SOCKETS_ENGINE
					// do it only once
					bBustedPrioraty = true;
				}
				// clear the memory used
				ReleaseHashStruct(&Struct);
				// and exit while (on next iteration)
				continue;
			}
d83 2
a84 36
			switch (Struct.eCommand)
			{
			// command to create file hash
			case PC_HASH:
				HashFile(Struct.pOwner, Struct.cFolder, Struct.cFileName);
				break;
			// command for thread to exit
			case PC_QUIT:
				// it's actually double check but just to be sure
				SetStopThread(true);
				// break the loop 
				bQuitCycle = true;
				break;
			default:
				TRACE(_T("Invalid command received"));
			};
		}
		else
		{
			// something wrong , we defenatly need to report it somehow
			TRACE(_T("Error reading from pipe or invalid data received"));
			Sleep(20); // let it sleep on it , maybe it will fix the problem
		}
		// Clear the memory used by structure
		ReleaseHashStruct(&Struct);
		Sleep(0);
	}
	while(!bQuitCycle);
	// signal that we finished here
	m_QuitPCmdEvent.SetEvent();
	if ( m_hCommandPipe )
	{
		CloseHandle(m_hCommandPipe);
		m_hCommandPipe	=	NULL;
	}
	return 0;
d87 1
a87 1
bool CProcessingCmdThread::SendQuitCommand(HANDLE hControlPipe)
d89 2
a90 2
	bool bWriteOK			=	false;
	DWORD dwBytesWritten	=	0;
d92 2
a93 1
	if ( !hControlPipe )
d95 3
a97 1
		return false;
d100 1
a100 16
	Process_Cmd_struct QuitCommandStrct;
	memzero(&QuitCommandStrct,sizeof(Process_Cmd_struct));
	QuitCommandStrct.lSize	=	sizeof(Process_Cmd_struct);
	QuitCommandStrct.eCommand	=	PC_QUIT;
	bWriteOK = WriteFile(hControlPipe,          // handle to file
					&QuitCommandStrct,              // data buffer
					sizeof(Process_Cmd_struct),     // number of bytes to write
					&dwBytesWritten,  // number of bytes written
					NULL        // overlapped buffer
					);
	if(!bWriteOK || (dwBytesWritten != sizeof(Process_Cmd_struct)))
	{
		bWriteOK = false;
	}

	return bWriteOK;
d103 2
a104 7
void CProcessingCmdThread::SetStopThread(bool bStop)
{
	CSingleLock (&m_StopLock,TRUE);
	m_bStopThread	=	bStop;
}

bool CProcessingCmdThread::IsThreadAboutToStop(void)
d106 2
a107 10
	CSingleLock (&m_StopLock,TRUE);
	return m_bStopThread;
}

// we want to allow only stop processing to be set from outside class
// thats why we use this public function
void CProcessingCmdThread::SetThreadToStopProcessing(void)
{
	SetStopThread(true);
}
d109 1
a109 7
// Performs actual hashing of the file
void CProcessingCmdThread::HashFile(CSharedFileList *pOwner, const CString &strFolder, const CString &strFileName)
{
	// Create new Known file object
	CKnownFile* newrecord = new CKnownFile();
	
	if (newrecord)
d111 2
a112 2
		// Run creation of the HASH data from file
		if (newrecord->CreateFromFile(strFolder, strFileName, false))
d115 5
a119 9
			// If main App window is exists and valid
			if (!IsThreadAboutToStop() && ::IsWindow(g_App.m_pMDlg->m_hWnd))
			{
				// post message ? - bit unsafe, it assumes that window getting this message will at some point
				// release the "newrecord" theoretically in some border cases it can cause small memory leak , but it's unlikly
				PostMessage(g_App.m_pMDlg->m_hWnd, TM_FINISHEDHASHING, NULL, (LPARAM)newrecord);
			}
			// if window is not valid
			else
d121 1
a121 1
				delete newrecord;	
d124 2
a125 1
			CTask_FileHashed* pTask = new CTask_FileHashed(NULL, newrecord);
d132 3
a134 9
			//	Notify main program of hash failure
			if (g_App.m_pMDlg && g_App.m_pMDlg->IsRunning())
			{
				UnknownFile_Struct	*pHashed = new UnknownFile_Struct;

				pHashed->m_strDirectory = strFolder;
				pHashed->m_strFileName = strFileName;
				PostMessage(g_App.m_pMDlg->m_hWnd, TM_HASHFAILED, 0, reinterpret_cast<LPARAM>(pHashed));
			}
d136 1
a136 1
			delete newrecord;
d139 2
d144 1
a144 1
bool CProcessingCmdThread::AddFileToHash(HANDLE hControlPipe, CSharedFileList *pOwner, const CString &strFolder, const CString &strFileName)
d146 5
a150 2
	bool	bWriteOK = false;
	DWORD	dwBytesWritten = 0;
d152 5
a156 3
	// Check if all internal structures are valid
	if (!hControlPipe)
		return false;
d158 2
a159 22
	Process_Cmd_struct SendCommandStrct;
	memzero(&SendCommandStrct,sizeof(Process_Cmd_struct));
	// Set the transffer structure with processing data
	SendCommandStrct.lSize					=	sizeof(Process_Cmd_struct);
	SendCommandStrct.eCommand				=	PC_HASH;
	SendCommandStrct.pOwner					=	pOwner;
	SendCommandStrct.cFileName				=	new TCHAR[strFileName.GetLength() + 1];
	_tcscpy(SendCommandStrct.cFileName, strFileName);
	SendCommandStrct.cFolder				=	new TCHAR[strFolder.GetLength() + 1];
	_tcscpy(SendCommandStrct.cFolder, strFolder);
	// Write the structure to pipe
	bWriteOK = WriteFile(hControlPipe,          // handle to file
					&SendCommandStrct,              // data buffer
					sizeof(Process_Cmd_struct),     // number of bytes to write
					&dwBytesWritten,  // number of bytes written
					NULL        // overlapped buffer
					);
	// Check if write completed successfully
	if(!bWriteOK || (dwBytesWritten != sizeof(Process_Cmd_struct)))
	{
		bWriteOK = false;
	}
d161 1
a161 14
	return bWriteOK;
}
void CProcessingCmdThread::ReleaseHashStruct(Process_Cmd_struct* pStruct)
{
	if (pStruct->cFileName)
	{
		delete[] pStruct->cFileName;
		pStruct->cFileName	=	NULL;
	}
	if ( pStruct->cFolder )
	{
		delete[] pStruct->cFolder;
		pStruct->cFolder	=	NULL;
	}
@


1.20
log
@Full path only for hashing log message of a partfile; Formatting.
@
text
@d1 1
a1 1
// ProcessingCmdThread.cpp : implementation file
d3 13
d19 1
a19 1
	#include "eMule.h"
d48 1
a48 1
		m_hCommandPipe	=	NULL;
d92 4
a95 4
	bool bBustedPrioraty	=	false;
	bool bQuitCycle	=	false;
	if ( !m_hCommandPipe  )
	{
a96 1
	}
d120 1
a120 1
					bBustedPrioraty	=	true;
d132 1
a132 1
				HashFile(Struct.pOwner,Struct.cFolder,Struct.cFileName,Struct.in_partfile_Owner);
d139 1
a139 1
				bQuitCycle	=	true;
d214 1
a214 1
void CProcessingCmdThread::HashFile(CSharedFileList* pOwner, const CString& strFolder, const CString& strFileName, CPartFile* pPartFileOwner)
d222 1
a222 1
		if (newrecord->CreateFromFile(strFolder, strFileName, (pOwner == NULL)))
d228 1
a228 1
				// post message ? - bit unsafe , it assumes that window getting this message will at some point
d230 1
a230 1
				PostMessage(g_App.m_pMDlg->m_hWnd,TM_FINISHEDHASHING,(pOwner ? 0:(WPARAM)pPartFileOwner),(LPARAM)newrecord);
d238 1
a238 1
			CTask_FileHashed* pTask = new CTask_FileHashed(pOwner ? NULL : pPartFileOwner, newrecord);
d246 1
a246 1
			if (pOwner && g_App.m_pMDlg && g_App.m_pMDlg->IsRunning())
d261 1
a261 1
bool CProcessingCmdThread::AddFileToHash(HANDLE hControlPipe,CSharedFileList* pOwner, const CString& strFolder, const CString& strFileName, CPartFile* pPartFileOwner)
a275 1
	SendCommandStrct.in_partfile_Owner		=	pPartFileOwner;
@


1.19
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d210 1
a210 1
		if (newrecord->CreateFromFile(strFolder, strFileName))
d214 1
a214 1
			if (!IsThreadAboutToStop() && ::IsWindow(g_App.m_pMDlg->m_hWnd) )
d251 2
a252 2
	bool bWriteOK			=	false;
	DWORD dwBytesWritten	=	0;
d255 1
a255 2
	if ( !hControlPipe)
	{
a256 1
	}
@


1.18
log
@renamed 3 variables
@
text
@d105 1
a105 1
					SetThreadPriority(THREAD_PRIORITY_NORMAL+ g_App.g_pPrefs->GetMainProcessPriority());
@


1.17
log
@Fixed shared files hashing issues when hashing stopped {Juokelis/GMGMGM/taltamir};
Removed useless loop to try hashing several times
(as nothing will change within microseconds).
@
text
@d105 1
a105 1
					SetThreadPriority(THREAD_PRIORITY_NORMAL+ g_eMuleApp.m_pGlobPrefs->GetMainProcessPriority());
d214 1
a214 1
			if (!IsThreadAboutToStop() && ::IsWindow(g_eMuleApp.m_pdlgEmule->m_hWnd) )
d218 1
a218 1
				PostMessage(g_eMuleApp.m_pdlgEmule->m_hWnd,TM_FINISHEDHASHING,(pOwner ? 0:(WPARAM)pPartFileOwner),(LPARAM)newrecord);
d234 1
a234 1
			if (pOwner && g_eMuleApp.m_pdlgEmule && g_eMuleApp.m_pdlgEmule->IsRunning())
d240 1
a240 1
				PostMessage(g_eMuleApp.m_pdlgEmule->m_hWnd, TM_HASHFAILED, 0, reinterpret_cast<LPARAM>(pHashed));
@


1.16
log
@v2 - shared files
@
text
@d205 3
a207 3
	// eklmn: since "new" can failed, we gonna try 3 times
	int iTry = 0;
	do
d209 2
a210 3
		CKnownFile* newrecord = new CKnownFile();
		
		if (newrecord )
d212 10
a221 2
			// Run creation of the HASH data from file
			if (newrecord->CreateFromFile(strFolder,strFileName))
d223 2
a224 13
#ifndef NEW_SOCKETS_ENGINE
				// If main App window is exists and valid
				if (!IsThreadAboutToStop() && ::IsWindow(g_eMuleApp.m_pdlgEmule->m_hWnd) )
				{
					// post message ? - bit unsafe , it assumes that window getting this message will at some point
					// release the "newrecord" theoretically in some border cases it can cause small memory leak , but it's unlikly
					PostMessage(g_eMuleApp.m_pdlgEmule->m_hWnd,TM_FINISHEDHASHING,(pOwner ? 0:(WPARAM)pPartFileOwner),(LPARAM)newrecord);
				}
				// if window is not valid
				else
				{
					delete newrecord;	
				}
d226 2
a227 2
				CTask_FileHashed* pTask = new CTask_FileHashed(pOwner ? NULL : pPartFileOwner, newrecord);
				g_stEngine.Files.Push(pTask);
d229 6
a234 3
			}
			// if failed to create hash
			else
d236 5
a240 1
				delete newrecord;
d242 2
a243 1
			return;
d245 1
a245 2
		iTry++;
	} while (iTry < 3);
@


1.15
log
@v2 - shared files
@
text
@d9 1
d229 3
@


1.14
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d5 5
a9 1
#include "eMule.h"
d11 1
a11 1
#include "knownfile.h"
d103 1
d105 1
d215 1
d228 1
a228 1
			
@


1.13
log
@handling of failed new's
@
text
@d158 1
a158 1
	::ZeroMemory(&QuitCommandStrct,sizeof(Process_Cmd_struct));
d247 1
a247 1
	::ZeroMemory(&SendCommandStrct,sizeof(Process_Cmd_struct));
@


1.12
log
@Formatting, comments, and name changes.
@
text
@d198 7
a204 17
	CKnownFile* newrecord = new CKnownFile();
	if ( !newrecord )
	{
		return;
	}
	// Run creation of the HASH data from file
	if (newrecord->CreateFromFile(strFolder,strFileName))
	{
		// If main App window is exists and valid
		if (!IsThreadAboutToStop() && ::IsWindow(g_eMuleApp.m_pdlgEmule->m_hWnd) )
		{
			// post message ? - bit unsafe , it assumes that window getting this message will at some point
			// release the "newrecord" theoretically in some border cases it can cause small memory leak , but it's unlikly
			PostMessage(g_eMuleApp.m_pdlgEmule->m_hWnd,TM_FINISHEDHASHING,(pOwner ? 0:(WPARAM)pPartFileOwner),(LPARAM)newrecord);
		}
		// if window is not valid
		else
d206 23
a228 1
			delete newrecord;	
d230 2
a231 7
	
	}
	// if failed to create hash
	else
	{
		delete newrecord;
	}
@


1.11
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d45 1
a45 1
	// TODO:  perform any per-thread cleanup here
@


1.10
log
@Second batch of name changes
@
text
@d99 1
a99 1
					SetThreadPriority(THREAD_PRIORITY_NORMAL+ theApp.glob_prefs->GetMainProcessPriority());
d207 1
a207 1
		if (!IsThreadAboutToStop() && ::IsWindow(theApp.emuledlg->m_hWnd) )
d211 1
a211 1
			PostMessage(theApp.emuledlg->m_hWnd,TM_FINISHEDHASHING,(pOwner ? 0:(WPARAM)pPartFileOwner),(LPARAM)newrecord);
@


1.9
log
@unicode cleanup
@
text
@d123 1
a123 1
				TRACE(_T("Invalid command recieved"));
d129 1
a129 1
			TRACE(_T("Error reading from pipe or invalid data recieved"));
@


1.8
log
@fixed crashes
@
text
@d246 4
a249 4
	SendCommandStrct.cFileName				=	new char[strFileName.GetLength() + 1];
	strcpy(SendCommandStrct.cFileName, strFileName);
	SendCommandStrct.cFolder				=	new char[strFolder.GetLength() + 1];
	strcpy(SendCommandStrct.cFolder, strFolder);
@


1.7
log
@char * to CString conversion
@
text
@d157 2
a158 3
	Process_Cmd_struct QuitCommandStrct;	
	QuitCommandStrct.pOwner = 0;
	QuitCommandStrct.in_partfile_Owner = 0;	
d228 1
a228 1
bool CProcessingCmdThread::AddFileToHash(HANDLE hControlPipe,CSharedFileList* pOwner, CString strFolder, CString strFileName, CPartFile* pPartFileOwner)
d246 4
a249 4
	SendCommandStrct.cFileName				=	strFileName;
	strFileName.ReleaseBuffer();
	SendCommandStrct.cFolder				=	strFolder;
	strFolder.ReleaseBuffer();
d266 11
a276 1
{	
@


1.6
log
@char * to CString conversion
@
text
@d157 3
a159 2
	Process_Cmd_struct QuitCommandStrct;
	::ZeroMemory(&QuitCommandStrct,sizeof(Process_Cmd_struct));
@


1.5
log
@Fixed bug #140
@
text
@d195 1
a195 1
void CProcessingCmdThread::HashFile(CSharedFileList* pOwner, CString strFolder, CString strFileName, CPartFile* pPartFileOwner)
d204 1
a204 1
	if (newrecord->CreateFromFile(strFolder.GetBuffer(),strFileName.GetBuffer()))
a224 3
	// it's better to release buffers in case someone whould use GetBuffer() again on thouse pointers
	strFileName.ReleaseBuffer();
	strFolder.ReleaseBuffer();
d246 1
a246 1
	SendCommandStrct.cFileName				=	nstrdup(strFileName.GetBuffer());
d248 1
a248 1
	SendCommandStrct.cFolder				=	nstrdup(strFolder.GetBuffer());
d266 1
a266 11
{
	if (pStruct->cFileName)
	{
		delete[] pStruct->cFileName;
		pStruct->cFileName	=	NULL;
	}
	if ( pStruct->cFolder )
	{
		delete[] pStruct->cFolder;
		pStruct->cFolder	=	NULL;
	}
@


1.4
log
@*** empty log message ***
@
text
@d207 1
a207 1
		if ( ::IsWindow(theApp.emuledlg->m_hWnd) )
@


1.3
log
@Priority control
@
text
@d27 5
d139 5
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d94 1
a94 1
					SetThreadPriority(THREAD_PRIORITY_NORMAL);
@


1.1
log
@*** empty log message ***
@
text
@d9 5
@


1.1.4.1
log
@updating this branch...
@
text
@@

