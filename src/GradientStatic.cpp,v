head	1.11;
access;
symbols
	PublicRelease_1_2e:1.11
	Interim_Release_1-2e_RC1:1.11
	PublicRelease_1_2d:1.9
	Interim_Release_1-2d_RC1:1.9
	Interim_Release_1-2d_beta1:1.9
	PublicRelease_1_2c:1.9
	Interim_Release_1-2c_RC1:1.9
	Interim_Release_1-2c_beta1:1.9
	PublicRelease_1_2b:1.9
	Interim_Release_1-2b_RC1:1.9
	PublicRelease_1_2a:1.9
	Interim_Release_1-2a_RC1:1.9
	Interim_Release_1-2a_beta2:1.9
	Interim_Release_1-2a_beta1:1.9
	PublicRelease_1_2:1.9
	Interim_Release_1-2_RC1:1.9
	Interim_Release_1-2_beta1:1.9
	PublicRelease_1_1g:1.9
	Interim_Release_1-1g_RC3:1.9
	Interim_Release_1-1g_RC2:1.9
	Interim_Release_1-1g_RC1:1.9
	Interim_Release_1-1g_beta2:1.9
	Interim_Release_1-1g_beta1:1.9
	PublicRelease_1_1f:1.9
	Interim_Release_1-1f_RC1:1.9
	PublicRelease_1_1e:1.9
	Interim_Release_1-1e_RC2:1.9
	Interim_Release_1-1e_RC1:1.9
	Interim_Release_1-1e_beta1:1.9
	PublicRelease_1_1d:1.7
	Interim_Release_1-1d_RC1:1.7
	PublicRelease_1_1c:1.7
	Interim_Release_1-1c_RC1:1.7
	Interim_Release_1-1c_beta2:1.7
	Interim_Release_1-1c_beta1:1.7
	PublicRelease_1_1b:1.7
	Interim_Release_1-1b_RC1:1.7
	PublicRelease_1_1a:1.7
	Interim_Release_1-1a_RC2:1.7
	Interim_Release_1-1a_RC1:1.7
	Interim_Release_1-1a_beta2:1.7
	Interim_Release_1-1a_beta1:1.7
	PublicRelease_1_1:1.7
	Interim_Release_1-1_beta1:1.7
	PublicRelease_1o:1.7
	Interim_Release_1o_RC1:1.7
	Interim_Release_1o_beta1:1.7
	PublicRelease_1n:1.7
	Interim_Release_1n_RC2:1.7
	Interim_Release_1n_RC1:1.7
	Interim_Release_1n_beta2:1.7
	Interim_Release_1n_beta1:1.7
	PublicRelease_1m:1.7
	Interim_Release_1m_beta1:1.7
	PublicRelease_1l:1.7
	Interim_Release_1l_RC3:1.7
	Interim_Release_1l_RC2:1.7
	Interim_Release_1l_RC1:1.7
	Interim_Release_1l_beta2:1.7
	Interim_Release_1l_beta1:1.7
	PublicRelease_1k:1.7
	Interim_Release_1k_RC4:1.7
	Interim_1k_RC3:1.6
	Interim_1k_RC2:1.6
	Interim_Release_1k_RC1:1.6
	Interim_Release_1k_beta5:1.6
	Intrerim_Release_1k_beta4:1.6
	Interim_Release_1k_beta1:1.5
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.5
	Interim_Release_1j_RC1:1.5
	Interim_Release_1j_beta2:1.5
	Interim_Release_1j_beta1:1.5
	PublicRelease_1i:1.5
	Interim_Release_1i_RC6:1.5
	Interim_Release_1i_RC3:1.5
	Interim_Release_1i_RC2:1.5
	Interim_Release_1i_RC1:1.5
	Interim_Release_1i_beta3:1.5
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.4
	PublicRelease_1h:1.3
	Interim_Release_1h_rc2:1.3
	Interim_Release_1h_RC1:1.3
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.2
	Interim_Release_1e_beta1:1.2
	PublicRelease_1c:1.2
	featurestest:1.2.0.8
	Interim_Release_1c_RC:1.2
	Interim_Release_1c_beta2:1.2
	Interim_Release_1c_beta1:1.2
	threaded_downloadqueue:1.2.0.6
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.2
	Interim_Release_1b_beta1:1.2
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.2
	systraydlg:1.1.0.2;
locks; strict;
comment	@// @;


1.11
date	2009.02.15.21.09.20;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.04.46.46;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.10.03.51.22;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.09.02.27.08;	author aw3;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.02.07.32;	author katsyonak;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.23.13.33.24;	author kush_eplus;	state Exp;
branches;
next	1.5;

1.5
date	2003.10.26.13.50.15;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.01.15.08.35;	author eklmn;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.19.07.47.47;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.12.17.06.28;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.05.23.16.42;	author forcha;	state dead;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.02.05.23.16.42;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Tiny update to in sync with original.
@
text
@// GradientStatic.cpp : implementation file
//

#include "stdafx.h"
#include "GradientStatic.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
CGradientStatic::CGradientStatic()
{
	m_bInit = TRUE;
	m_bHorizontal = TRUE;
	m_bInvert = FALSE;

	m_crColorLB = RGB(0,0,0);
	m_crColorRT = RGB(255,255,255);
	m_crTextColor = RGB(127,127,127);
}

CGradientStatic::~CGradientStatic()
{
	if(m_Mem.dc.GetSafeHdc() && m_Mem.pold)
		m_Mem.dc.SelectObject(m_Mem.pold);
	if(m_Mem.bmp.GetSafeHandle())
		m_Mem.bmp.DeleteObject();
	if(m_Mem.dc.GetSafeHdc())
		m_Mem.dc.DeleteDC();
}


BEGIN_MESSAGE_MAP(CGradientStatic, CStatic)
	ON_WM_PAINT()
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CGradientStatic::OnPaint()
{
	CPaintDC dc(this); // device context for painting

	CRect rClient;
	GetClientRect(rClient);

	if(m_bInit)
	{
		CreateGradient(&dc, &rClient);
		m_bInit = false;
	}

	dc.BitBlt(0,0,m_Mem.cx, m_Mem.cy, &m_Mem.dc, 0,0, SRCCOPY);
}

void CGradientStatic::CreateGradient(CDC *pDC, CRect *pRect)
{
	m_Mem.cx = pRect->Width();
	m_Mem.cy = pRect->Height();

	if(m_Mem.dc.GetSafeHdc())
	{
		if(m_Mem.bmp.GetSafeHandle() && m_Mem.pold)
			m_Mem.dc.SelectObject(m_Mem.pold);
		m_Mem.dc.DeleteDC();
	}
	m_Mem.dc.CreateCompatibleDC(pDC);

	if(m_Mem.bmp.GetSafeHandle())
		m_Mem.bmp.DeleteObject();
	m_Mem.bmp.CreateCompatibleBitmap(pDC, m_Mem.cx, m_Mem.cy);

	m_Mem.pold = m_Mem.dc.SelectObject(&m_Mem.bmp);

//-----------------------------------------------------------------

	if(m_bHorizontal)
	{
		DrawHorizontalGradient();
		DrawHorizontalText(pRect);
	}
	else
	{
		DrawVerticalGradient();
		DrawVerticalText(pRect);
	}
}

void CGradientStatic::DrawHorizontalGradient()
{
	double dblRstep = (GetRValue(m_crColorRT) - GetRValue(m_crColorLB)) / static_cast<double>(m_Mem.cx);
	double dblGstep = (GetGValue(m_crColorRT) - GetGValue(m_crColorLB)) / static_cast<double>(m_Mem.cx);
	double dblBstep = (GetBValue(m_crColorRT) - GetBValue(m_crColorLB)) / static_cast<double>(m_Mem.cx);
	double r = GetRValue(m_crColorLB);
	double g = GetGValue(m_crColorLB);
	double b = GetBValue(m_crColorLB);
	CPen	*pOldPen = m_Mem.dc.GetCurrentPen();

	for(int x = 0; x < m_Mem.cx; x++)
	{
		CPen Pen(PS_SOLID, 1, RGB(r,g,b));
		m_Mem.dc.SelectObject(&Pen);
		m_Mem.dc.MoveTo(x,0);
		m_Mem.dc.LineTo(x,m_Mem.cy);

		r += dblRstep;
		g += dblGstep;
		b += dblBstep;
	}
	m_Mem.dc.SelectObject(pOldPen);	// restore the previous pen
}

void CGradientStatic::DrawVerticalGradient()
{
	double dblRstep = (GetRValue(m_crColorLB) - GetRValue(m_crColorRT)) / static_cast<double>(m_Mem.cy);
	double dblGstep = (GetGValue(m_crColorLB) - GetGValue(m_crColorRT)) / static_cast<double>(m_Mem.cy);
	double dblBstep = (GetBValue(m_crColorLB) - GetBValue(m_crColorRT)) / static_cast<double>(m_Mem.cy);
	double r = GetRValue(m_crColorRT);
	double g = GetGValue(m_crColorRT);
	double b = GetBValue(m_crColorRT);
	CPen	*pOldPen = m_Mem.dc.GetCurrentPen();

	for(int y = 0; y < m_Mem.cy; y++)
	{
		CPen Pen(PS_SOLID, 1, RGB(r,g,b));
		m_Mem.dc.SelectObject(&Pen);
		m_Mem.dc.MoveTo(0,y);
		m_Mem.dc.LineTo(m_Mem.cx,y);

		r += dblRstep;
		g += dblGstep;
		b += dblBstep;
	}
	m_Mem.dc.SelectObject(pOldPen);	// restore the previous pen
}

void CGradientStatic::DrawHorizontalText(CRect *pRect)
{
	CFont *pOldFont = NULL;

	if(m_cfFont.GetSafeHandle())
		pOldFont = m_Mem.dc.SelectObject(&m_cfFont);

	CString strText;
	GetWindowText(strText);

	m_Mem.dc.SetTextColor(m_crTextColor);
	m_Mem.dc.SetBkMode(TRANSPARENT);
	m_Mem.dc.DrawText(strText, pRect, DT_VCENTER | DT_SINGLELINE | DT_END_ELLIPSIS);
	if (pOldFont)	
		m_Mem.dc.SelectObject(pOldFont);
}

static void DrawRotatedText(HDC hdc, LPCTSTR str, LPRECT rect, double angle, UINT nOptions = 0)
{
   // convert angle to radian
   double pi = 3.141592654;
   double radian = pi * 2 / 360 * angle;

   // get the center of a not-rotated text
   SIZE TextSize;
   GetTextExtentPoint32(hdc, str, _tcslen(str), &TextSize);

   POINT center;
   center.x = TextSize.cx / 2;
   center.y = TextSize.cy / 2;

   // now calculate the center of the rotated text
   POINT rcenter;
   rcenter.x = long(cos(radian) * center.x - sin(radian) * center.y);
   rcenter.y = long(sin(radian) * center.x + cos(radian) * center.y);

   // finally draw the text and move it to the center of the rectangle
   SetTextAlign(hdc, TA_BOTTOM);
   SetBkMode(hdc, TRANSPARENT);
   ExtTextOut(hdc, rect->left + (rect->right - rect->left) / 2 - rcenter.x,
              rect->bottom, nOptions, rect, str, _tcslen(str), NULL);
}

void CGradientStatic::DrawVerticalText(CRect *pRect)
{
	CFont *pOldFont = NULL;

	LOGFONT lfFont;
	if(m_cfFont.GetSafeHandle())
	{
		m_cfFont.GetLogFont(&lfFont);
	}
	else
	{
		CFont *pFont = GetFont();
		pFont->GetLogFont(&lfFont);
		_tcscpy(lfFont.lfFaceName, _T("Arial"));	// some fonts won't turn :(
	}
	lfFont.lfEscapement = 900;

	CFont Font;
	Font.CreateFontIndirect(&lfFont);
	pOldFont = m_Mem.dc.SelectObject(&Font);

	CString strText;
	GetWindowText(strText);

	m_Mem.dc.SetTextColor(m_crTextColor);
	m_Mem.dc.SetBkColor(TRANSPARENT);
	CRect rText = pRect;
	rText.bottom -= 5;
	DrawRotatedText(m_Mem.dc.m_hDC, strText, rText, 90);

	m_Mem.dc.SelectObject(pOldFont);
}

void CGradientStatic::SetFont(CFont *pFont)
{
	LOGFONT lfFont;
	pFont->GetLogFont(&lfFont);

	if(m_cfFont.GetSafeHandle())
		m_cfFont.DeleteObject();
	m_cfFont.CreateFontIndirect(&lfFont);
}
@


1.10
log
@Some local functions were made static; Removed duplicate include; Removed unused variable.
@
text
@d150 1
a150 1
	m_Mem.dc.DrawText(strText, pRect, DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_END_ELLIPSIS);
@


1.9
log
@Corrected compilation warnings.
@
text
@a5 1
#include <math.h>
a12 2
long l = 0;

a13 2
// CGradientStatic

a36 1
	//{{AFX_MSG_MAP(CGradientStatic)
a37 1
	//}}AFX_MSG_MAP
a40 2
// CGradientStatic message handlers

d155 1
a155 1
void DrawRotatedText(HDC hdc, LPCTSTR str, LPRECT rect, double angle, UINT nOptions = 0)
@


1.8
log
@Faster drawing.
@
text
@d135 1
a135 1
		CPen Pen(PS_SOLID, 1, RGB(r,g,b)), *pOld;
@


1.7
log
@minor changes
@
text
@d107 1
d112 1
a112 1
		CPen* pOld = m_Mem.dc.SelectObject(&Pen);
a114 1
		m_Mem.dc.SelectObject(pOld);
d120 1
d131 1
d136 1
a136 1
		pOld = m_Mem.dc.SelectObject(&Pen);
a138 1
		m_Mem.dc.SelectObject(pOld);
d144 1
@


1.6
log
@formatting;
optimzations in UploadQueue.cpp;
removing doubled ';'
@
text
@d147 1
a147 1
	CFont *pOldFont;
d158 2
a159 1
	m_Mem.dc.SelectObject(pOldFont);
@


1.5
log
@Formatting, comments, and name changes.
float => double conversion
@
text
@d50 1
a50 1
void CGradientStatic::OnPaint() 
d53 1
a53 1
	
d56 1
a56 1
	
d58 1
a58 1
	{		
d72 1
a72 1
	{	
d78 1
a78 1
	
d95 1
a95 1
		DrawVerticalText(pRect);		
d151 1
a151 1
	
d168 1
a168 1
   SIZE TextSize;;
d188 2
a189 2
{	
	CFont *pOldFont = NULL;;
d193 1
a193 1
	{	
d197 1
a197 1
	{	
d203 1
a203 1
	
d216 1
a216 1
	
d218 1
a218 1
}	
@


1.4
log
@an incorrect use of GDI resources (CBrush class)
@
text
@d101 6
a106 6
	float fRstep = (GetRValue(m_crColorRT) - GetRValue(m_crColorLB)) / (float)m_Mem.cx;
	float fGstep = (GetGValue(m_crColorRT) - GetGValue(m_crColorLB)) / (float)m_Mem.cx;
	float fBstep = (GetBValue(m_crColorRT) - GetBValue(m_crColorLB)) / (float)m_Mem.cx;
	float r = GetRValue(m_crColorLB);
	float g = GetGValue(m_crColorLB);
	float b = GetBValue(m_crColorLB);
d116 3
a118 3
		r += fRstep;
		g += fGstep;
		b += fBstep;
d124 6
a129 6
	float fRstep = (GetRValue(m_crColorLB) - GetRValue(m_crColorRT)) / (float)m_Mem.cy;
	float fGstep = (GetGValue(m_crColorLB) - GetGValue(m_crColorRT)) / (float)m_Mem.cy;
	float fBstep = (GetBValue(m_crColorLB) - GetBValue(m_crColorRT)) / (float)m_Mem.cy;
	float r = GetRValue(m_crColorRT);
	float g = GetGValue(m_crColorRT);
	float b = GetBValue(m_crColorRT);
d139 3
a141 3
		r += fRstep;
		g += fGstep;
		b += fBstep;
@


1.3
log
@unicode cleanup
@
text
@d110 2
a111 2
		CPen Pen(PS_SOLID, 1, RGB(r,g,b)), *pOld;
		pOld = m_Mem.dc.SelectObject(&Pen);
@


1.2
log
@new systray menu + small bugfix
@
text
@d161 1
a161 1
void DrawRotatedText(HDC hdc, char *str, LPRECT rect, double angle, UINT nOptions = 0)
d169 1
a169 1
   GetTextExtentPoint32(hdc, str, strlen(str), &TextSize);
d184 1
a184 1
              rect->bottom, nOptions, rect, str, strlen(str), NULL);
d200 1
a200 1
		strcpy(lfFont.lfFaceName, "Arial");	// some fonts won't turn :(
d215 1
a215 1
	DrawRotatedText(m_Mem.dc.m_hDC, (char*)strText.operator LPCTSTR(), rText, 90);
@


1.1
log
@file GradientStatic.cpp was initially added on branch systraydlg.
@
text
@d1 228
@


1.1.2.1
log
@*** empty log message ***
@
text
@a0 228
// GradientStatic.cpp : implementation file
//

#include "stdafx.h"
#include "GradientStatic.h"
#include <math.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

long l = 0;

/////////////////////////////////////////////////////////////////////////////
// CGradientStatic

CGradientStatic::CGradientStatic()
{
	m_bInit = TRUE;
	m_bHorizontal = TRUE;
	m_bInvert = FALSE;

	m_crColorLB = RGB(0,0,0);
	m_crColorRT = RGB(255,255,255);
	m_crTextColor = RGB(127,127,127);
}

CGradientStatic::~CGradientStatic()
{
	if(m_Mem.dc.GetSafeHdc() && m_Mem.pold)
		m_Mem.dc.SelectObject(m_Mem.pold);
	if(m_Mem.bmp.GetSafeHandle())
		m_Mem.bmp.DeleteObject();
	if(m_Mem.dc.GetSafeHdc())
		m_Mem.dc.DeleteDC();
}


BEGIN_MESSAGE_MAP(CGradientStatic, CStatic)
	//{{AFX_MSG_MAP(CGradientStatic)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGradientStatic message handlers

void CGradientStatic::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
	CRect rClient;
	GetClientRect(rClient);
	
	if(m_bInit)
	{		
		CreateGradient(&dc, &rClient);
		m_bInit = false;
	}

	dc.BitBlt(0,0,m_Mem.cx, m_Mem.cy, &m_Mem.dc, 0,0, SRCCOPY);
}

void CGradientStatic::CreateGradient(CDC *pDC, CRect *pRect)
{
	m_Mem.cx = pRect->Width();
	m_Mem.cy = pRect->Height();

	if(m_Mem.dc.GetSafeHdc())
	{	
		if(m_Mem.bmp.GetSafeHandle() && m_Mem.pold)
			m_Mem.dc.SelectObject(m_Mem.pold);
		m_Mem.dc.DeleteDC();
	}
	m_Mem.dc.CreateCompatibleDC(pDC);
	
	if(m_Mem.bmp.GetSafeHandle())
		m_Mem.bmp.DeleteObject();
	m_Mem.bmp.CreateCompatibleBitmap(pDC, m_Mem.cx, m_Mem.cy);

	m_Mem.pold = m_Mem.dc.SelectObject(&m_Mem.bmp);

//-----------------------------------------------------------------

	if(m_bHorizontal)
	{
		DrawHorizontalGradient();
		DrawHorizontalText(pRect);
	}
	else
	{
		DrawVerticalGradient();
		DrawVerticalText(pRect);		
	}
}

void CGradientStatic::DrawHorizontalGradient()
{
	float fRstep = (GetRValue(m_crColorRT) - GetRValue(m_crColorLB)) / (float)m_Mem.cx;
	float fGstep = (GetGValue(m_crColorRT) - GetGValue(m_crColorLB)) / (float)m_Mem.cx;
	float fBstep = (GetBValue(m_crColorRT) - GetBValue(m_crColorLB)) / (float)m_Mem.cx;
	float r = GetRValue(m_crColorLB);
	float g = GetGValue(m_crColorLB);
	float b = GetBValue(m_crColorLB);

	for(int x = 0; x < m_Mem.cx; x++)
	{
		CPen Pen(PS_SOLID, 1, RGB(r,g,b)), *pOld;
		pOld = m_Mem.dc.SelectObject(&Pen);
		m_Mem.dc.MoveTo(x,0);
		m_Mem.dc.LineTo(x,m_Mem.cy);
		m_Mem.dc.SelectObject(pOld);

		r += fRstep;
		g += fGstep;
		b += fBstep;
	}
}

void CGradientStatic::DrawVerticalGradient()
{
	float fRstep = (GetRValue(m_crColorLB) - GetRValue(m_crColorRT)) / (float)m_Mem.cy;
	float fGstep = (GetGValue(m_crColorLB) - GetGValue(m_crColorRT)) / (float)m_Mem.cy;
	float fBstep = (GetBValue(m_crColorLB) - GetBValue(m_crColorRT)) / (float)m_Mem.cy;
	float r = GetRValue(m_crColorRT);
	float g = GetGValue(m_crColorRT);
	float b = GetBValue(m_crColorRT);

	for(int y = 0; y < m_Mem.cy; y++)
	{
		CPen Pen(PS_SOLID, 1, RGB(r,g,b)), *pOld;
		pOld = m_Mem.dc.SelectObject(&Pen);
		m_Mem.dc.MoveTo(0,y);
		m_Mem.dc.LineTo(m_Mem.cx,y);
		m_Mem.dc.SelectObject(pOld);

		r += fRstep;
		g += fGstep;
		b += fBstep;
	}
}

void CGradientStatic::DrawHorizontalText(CRect *pRect)
{
	CFont *pOldFont;

	if(m_cfFont.GetSafeHandle())
		pOldFont = m_Mem.dc.SelectObject(&m_cfFont);
	
	CString strText;
	GetWindowText(strText);

	m_Mem.dc.SetTextColor(m_crTextColor);
	m_Mem.dc.SetBkMode(TRANSPARENT);
	m_Mem.dc.DrawText(strText, pRect, DT_LEFT|DT_SINGLELINE|DT_VCENTER|DT_END_ELLIPSIS);
	m_Mem.dc.SelectObject(pOldFont);
}

void DrawRotatedText(HDC hdc, char *str, LPRECT rect, double angle, UINT nOptions = 0)
{
   // convert angle to radian
   double pi = 3.141592654;
   double radian = pi * 2 / 360 * angle;

   // get the center of a not-rotated text
   SIZE TextSize;;
   GetTextExtentPoint32(hdc, str, strlen(str), &TextSize);

   POINT center;
   center.x = TextSize.cx / 2;
   center.y = TextSize.cy / 2;

   // now calculate the center of the rotated text
   POINT rcenter;
   rcenter.x = long(cos(radian) * center.x - sin(radian) * center.y);
   rcenter.y = long(sin(radian) * center.x + cos(radian) * center.y);

   // finally draw the text and move it to the center of the rectangle
   SetTextAlign(hdc, TA_BOTTOM);
   SetBkMode(hdc, TRANSPARENT);
   ExtTextOut(hdc, rect->left + (rect->right - rect->left) / 2 - rcenter.x,
              rect->bottom, nOptions, rect, str, strlen(str), NULL);
}

void CGradientStatic::DrawVerticalText(CRect *pRect)
{	
	CFont *pOldFont = NULL;;

	LOGFONT lfFont;
	if(m_cfFont.GetSafeHandle())
	{	
		m_cfFont.GetLogFont(&lfFont);
	}
	else
	{	
		CFont *pFont = GetFont();
		pFont->GetLogFont(&lfFont);
		strcpy(lfFont.lfFaceName, "Arial");	// some fonts won't turn :(
	}
	lfFont.lfEscapement = 900;
	
	CFont Font;
	Font.CreateFontIndirect(&lfFont);
	pOldFont = m_Mem.dc.SelectObject(&Font);

	CString strText;
	GetWindowText(strText);

	m_Mem.dc.SetTextColor(m_crTextColor);
	m_Mem.dc.SetBkColor(TRANSPARENT);
	CRect rText = pRect;
	rText.bottom -= 5;
	DrawRotatedText(m_Mem.dc.m_hDC, (char*)strText.operator LPCTSTR(), rText, 90);
	
	m_Mem.dc.SelectObject(pOldFont);
}	

void CGradientStatic::SetFont(CFont *pFont)
{
	LOGFONT lfFont;
	pFont->GetLogFont(&lfFont);

	if(m_cfFont.GetSafeHandle())
		m_cfFont.DeleteObject();
	m_cfFont.CreateFontIndirect(&lfFont);
}
@

