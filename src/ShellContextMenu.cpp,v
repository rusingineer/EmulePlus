head	1.23;
access;
symbols
	PublicRelease_1_2e:1.23
	Interim_Release_1-2e_RC1:1.23
	PublicRelease_1_2d:1.21
	Interim_Release_1-2d_RC1:1.21
	Interim_Release_1-2d_beta1:1.21
	PublicRelease_1_2c:1.19
	Interim_Release_1-2c_RC1:1.19
	Interim_Release_1-2c_beta1:1.19
	PublicRelease_1_2b:1.19
	Interim_Release_1-2b_RC1:1.19
	PublicRelease_1_2a:1.19
	Interim_Release_1-2a_RC1:1.19
	Interim_Release_1-2a_beta2:1.18
	Interim_Release_1-2a_beta1:1.17
	PublicRelease_1_2:1.17
	Interim_Release_1-2_RC1:1.17
	Interim_Release_1-2_beta1:1.17
	PublicRelease_1_1g:1.16
	Interim_Release_1-1g_RC3:1.16
	Interim_Release_1-1g_RC2:1.16
	Interim_Release_1-1g_RC1:1.16
	Interim_Release_1-1g_beta2:1.15
	Interim_Release_1-1g_beta1:1.15
	PublicRelease_1_1f:1.15
	Interim_Release_1-1f_RC1:1.15
	PublicRelease_1_1e:1.15
	Interim_Release_1-1e_RC2:1.15
	Interim_Release_1-1e_RC1:1.15
	Interim_Release_1-1e_beta1:1.15
	PublicRelease_1_1d:1.14
	Interim_Release_1-1d_RC1:1.14
	PublicRelease_1_1c:1.14
	Interim_Release_1-1c_RC1:1.14
	Interim_Release_1-1c_beta2:1.14
	Interim_Release_1-1c_beta1:1.14
	PublicRelease_1_1b:1.14
	Interim_Release_1-1b_RC1:1.14
	PublicRelease_1_1a:1.14
	Interim_Release_1-1a_RC2:1.14
	Interim_Release_1-1a_RC1:1.14
	Interim_Release_1-1a_beta2:1.14
	Interim_Release_1-1a_beta1:1.14
	PublicRelease_1_1:1.14
	Interim_Release_1-1_beta1:1.14
	PublicRelease_1o:1.14
	Interim_Release_1o_RC1:1.14
	Interim_Release_1o_beta1:1.14
	PublicRelease_1n:1.14
	Interim_Release_1n_RC2:1.14
	Interim_Release_1n_RC1:1.14
	Interim_Release_1n_beta2:1.14
	Interim_Release_1n_beta1:1.14
	PublicRelease_1m:1.14
	Interim_Release_1m_beta1:1.14
	PublicRelease_1l:1.14
	Interim_Release_1l_RC3:1.14
	Interim_Release_1l_RC2:1.14
	Interim_Release_1l_RC1:1.14
	Interim_Release_1l_beta2:1.14
	Interim_Release_1l_beta1:1.14
	PublicRelease_1k:1.13
	Interim_Release_1k_RC4:1.13
	Interim_1k_RC3:1.13
	Interim_1k_RC2:1.13
	Interim_Release_1k_RC1:1.13
	Interim_Release_1k_beta5:1.13
	Intrerim_Release_1k_beta4:1.13
	Interim_Release_1k_beta1:1.13
	PublicRelease_1j:1.13
	Interim_Release_1J_RC3:1.13
	Interim_Release_1j_RC3:1.13
	Interim_Release_1j_RC2:1.13
	Interim_Release_1j_RC1:1.12
	Interim_Release_1j_beta2:1.12
	Interim_Release_1j_beta1:1.12
	PublicRelease_1i:1.12
	Interim_Release_1i_RC6:1.12
	Interim_Release_1i_RC3:1.12
	Interim_Release_1i_RC2:1.12
	Interim_Release_1i_RC1:1.12
	Interim_Release_1i_beta3:1.12
	Interim_Release_1i_beta2:1.12
	Interim_Release_1i_beta1:1.12
	PublicRelease_1h:1.11
	Interim_Release_1h_rc2:1.11
	Interim_Release_1h_RC1:1.11
	Interim_Release_1h_beta2:1.11
	Interim_Release_1h_beta1_now:1.11
	Interim_Release_1h_beta1:1.11
	PublicRelease_1g:1.11
	Interim_Release_1g_RC6_Final:1.11
	Interim_Release_1g_RC6:1.11
	Interim_Release_1g_RC5:1.11
	Interim_Release_1g_RC4:1.11
	Interim_Release_1g_RC3:1.11
	Interim_Release_1g_beta2:1.8
	Interim_Release_1g_beta1:1.8
	Interim_Release_1f_RC4:1.8
	Interim_Release_1f_RC3:1.8
	Interim_Release_1f_RC2:1.8
	Interim_Release_1f_RC:1.8
	Interim_Release_1f_beta2:1.8
	Interim_Release_1f_beta1:1.8
	PublicRelease_1e:1.8
	Interim_Release_1e_RC2:1.8
	Interim_Release_1e_RC:1.8
	Interim_Release_1e_beta3:1.7
	Interim_Release_1e_beta2:1.7
	Interim_Release_1e_beta2_before_kuchin:1.7
	Interim_Release_1e_beta1:1.7
	PublicRelease_1c:1.3
	featurestest:1.3.0.4
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.2
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1;
locks; strict;
comment	@// @;


1.23
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.22;

1.22
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.20.05.20.20;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.24.19.09.36;	author fuxie-dk;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.24.02.40.21;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.05.10.48.54;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.05.19.53.49;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.13;

1.13
date	2004.01.11.16.27.35;	author syrus77;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.21.16.47.38;	author partyckip;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.21.16.46.30;	author partyckip;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.15.13.41.14;	author partyckip;	state Exp;
branches;
next	1.8;

1.8
date	2003.04.26.19.46.44;	author lord_kiron;	state Exp;
branches;
next	1.7;

1.7
date	2003.04.13.17.48.31;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.28.09.47.41;	author recdvst;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.27.11.55.21;	author recdvst;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.27.11.04.33;	author recdvst;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.13.07.05.46;	author recdvst;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.12.12.09.01;	author recdvst;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.08.12.09.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Simplified logging system implementation.
@
text
@#include "stdafx.h"
#include "emule.h"
#include "ShellContextMenu.h"
#include "SharedFileList.h"
#include "InputBox.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// global variables used for passing data to the subclassing wndProc
WNDPROC g_pOldWndProc; // regular window proc
LPCONTEXTMENU2 g_pIContext2; // active shell context menu

LRESULT CALLBACK HookWndProc(HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)
{
	EMULE_TRY
	static bool handle=false;
	switch (msg)
	{
		case WM_MENUSELECT:
			{
				UINT uItem = (UINT) LOWORD(wp);
				handle=(uItem >= 1 && uItem <=  10000)?true:false;
			}
			break;
		case WM_DRAWITEM:
		case WM_MEASUREITEM:
			if(wp) break; // not menu related
		case WM_INITMENUPOPUP:
			if(handle&&g_pIContext2->HandleMenuMsg(msg, wp, lp)==NOERROR)
				return (msg==WM_INITMENUPOPUP ? 0 : TRUE); // handled
			break;
		default:
			break;
	}
	return ::CallWindowProc(g_pOldWndProc, hWnd, msg, wp, lp);
	EMULE_CATCH2
	return 0;
}

CShellContextMenu::CShellContextMenu(HWND hWnd, const CString& sAbsPath) :
	m_hWnd(hWnd), m_sAbsPath(sAbsPath)
{
	m_lpcm = NULL;
}

CShellContextMenu::~CShellContextMenu()
{
	if (m_lpcm)
		m_lpcm->Release();
}

bool CShellContextMenu::IsMenuCommand(int iCmd) const
{
	return ((1 <= iCmd) && (iCmd <= 10000));
}

void CShellContextMenu::InvokeCommand(int iCmd, CKnownFile* file) const
{
	EMULE_TRY

	if (iCmd)
	{
		TCHAR pcBuf[128] = _T("");

		m_lpcm->GetCommandString(iCmd - 1, GCS_VERB, NULL, (LPSTR)pcBuf, ARRSIZE(pcBuf));

		if (!_tcscmp(pcBuf, _T("rename")))
		{
			InputBox namebox(GetResString(IDS_RENAME), file->GetFileName(), true);

			if (namebox.DoModal() == IDOK)
			{
				CString strNewName(namebox.GetInput());
				CString path(file->GetPath());

				if (path.Right(1) != _T('\\'))
					path += _T('\\');
				if (_trename(path + file->GetFileName(), path + strNewName) == 0)
				{
					file->SetFileName(strNewName);
					g_App.m_pSharedFilesList->UpdateItem(file, true);
				}
				else
					g_App.m_pMDlg->AddLogLine(LOG_FL_DBG | LOG_RGB_ERROR, _T("Failed to rename '%s' - %s"), file->GetFileName(), _tcserror(errno));
			}
			return;
		}

		CMINVOKECOMMANDINFO cmi;
		cmi.cbSize       = sizeof(cmi);
		cmi.fMask		 = 0;
		cmi.hwnd         = NULL;	//formerly m_hWnd, NULL brings windows like "open with" to front
		cmi.lpVerb       = (LPCSTR)MAKEINTRESOURCE(iCmd - 1);
		cmi.lpParameters = NULL;
		cmi.lpDirectory  = NULL;
		cmi.nShow        = SW_SHOWNORMAL;
		cmi.dwHotKey     = 0;
		cmi.hIcon        = NULL;
		m_lpcm->InvokeCommand(&cmi);
		g_App.m_pSharedFilesList->Reload();
	}
	EMULE_CATCH2
}

void CShellContextMenu::SetMenu(CMenu *pMenu)
{
	EMULE_TRY

	m_lpcm = NULL;
	g_pOldWndProc = NULL;

	if (m_sAbsPath.GetLength() == 0)
		return;

	LPMALLOC pMalloc;
	LPSHELLFOLDER psfFolder, psfNextFolder;
	LPITEMIDLIST pidlMain, pidlItem, pidlNextItem, *ppidl;
	ULONG ulCount, ulAttr;
	TCHAR tchPath[MAX_PATH];
	WCHAR wchPath[MAX_PATH];
	UINT nCount;

	//
	// Make sure the file name is fully qualified and in Unicode format.
	//
	GetFullPathName(m_sAbsPath, MAX_PATH, tchPath, NULL);
#ifdef _UNICODE
	lstrcpy(wchPath, tchPath);
#else
	MultiByteToWideChar(CP_ACP, 0, tchPath, -1, wchPath, MAX_PATH);
#endif

	if (SUCCEEDED (SHGetMalloc (&pMalloc)))
	{
		if (SUCCEEDED (SHGetDesktopFolder (&psfFolder)))
		{
			if (SUCCEEDED (psfFolder->ParseDisplayName (m_hWnd, NULL, wchPath, &ulCount, &pidlMain, &ulAttr)) && (pidlMain != NULL))
			{
				if ((nCount = GetItemCount(pidlMain)) != 0)
				{
					pidlItem = pidlMain;
					while (--nCount)
					{
						if ((pidlNextItem = DuplicateItem(pMalloc, pidlItem)) != NULL)
							if (SUCCEEDED (psfFolder->BindToObject (pidlNextItem, NULL, IID_IShellFolder, (void**)&psfNextFolder)))
							{
								psfFolder->Release();
								psfFolder = psfNextFolder;
								pMalloc->Free(pidlNextItem);
								pMalloc->Release();
								pidlItem = GetNextItem (pidlItem);
							}
							else
							{
								pMalloc->Free(pidlNextItem);
								pMalloc->Free (pidlMain);
								psfFolder->Release();
								pMalloc->Release();
								return;
							}
						else
						{
							pMalloc->Free (pidlMain);
							psfFolder->Release();
							pMalloc->Release();
							return;
						}
					}
					ppidl = &pidlItem;
					LPCONTEXTMENU pICv1 = NULL; // plain version
					if (SUCCEEDED (psfFolder->GetUIObjectOf (m_hWnd, 1, (const ITEMIDLIST**)ppidl, (const GUID)IID_IContextMenu, NULL, (void**)&pICv1)))
					{
						int cmType;
						if(pICv1)
						{ // try to obtain a higher level pointer, first 3 then 2
							if(pICv1->QueryInterface(IID_IContextMenu3, (void**)&m_lpcm)==NOERROR) cmType = 3;
							else {
								if(pICv1->QueryInterface(IID_IContextMenu2, (void**)&m_lpcm)==NOERROR) cmType = 2;
							}

							if(m_lpcm)
								pICv1->Release(); // free initial "v1.0" interface
							else
							{ // no higher version supported
								cmType = 1;
								m_lpcm = pICv1;
							}
						}
						if (SUCCEEDED (m_lpcm->QueryContextMenu (*pMenu, 0, 1, 10000, CMF_NORMAL|CMF_NODEFAULT|CMF_CANRENAME/*|CMF_EXPLORE|CMF_INCLUDESTATIC*/)))
						{
							// install the subclassing "hook", for versions 2 or 3
							if(cmType > 1)
							{
								g_pOldWndProc = (WNDPROC)
								SetWindowLong(m_hWnd, GWL_WNDPROC, (DWORD)HookWndProc);
								g_pIContext2 = (LPCONTEXTMENU2)m_lpcm; // cast ok for ICMv3
							}
							else
								g_pOldWndProc = NULL;
						}
					}
				}
			}
		}
	}
	pMalloc->Free(pidlMain);
	psfFolder->Release();
	pMalloc->Release();

	EMULE_CATCH2
}

UINT CShellContextMenu::GetItemCount (LPITEMIDLIST pidl)
{
	USHORT nLen;
	UINT nCount = 0;

	while ((nLen = pidl->mkid.cb) != 0)
	{
		pidl = GetNextItem (pidl);
		nCount++;
	}
	return nCount;
}

LPITEMIDLIST CShellContextMenu::GetNextItem (LPITEMIDLIST pidl)
{
	USHORT nLen;

	if ((nLen = pidl->mkid.cb) == 0)
		return NULL;

	return (LPITEMIDLIST) (((LPBYTE) pidl) + nLen);
}

LPITEMIDLIST CShellContextMenu::DuplicateItem (LPMALLOC pMalloc, LPITEMIDLIST pidl)
{
	USHORT nLen;
	LPITEMIDLIST pidlNew;

	nLen = pidl->mkid.cb;
	if (nLen == 0)
		return NULL;

	pidlNew = (LPITEMIDLIST) pMalloc->Alloc (nLen + sizeof (USHORT));
	if (pidlNew == NULL)
		return NULL;

	memcpy2(pidlNew, pidl, nLen);
	*((USHORT*) (((LPBYTE) pidlNew) + nLen)) = 0;

	return pidlNew;
}

void CShellContextMenu::CleanUp()
{
	if(g_pOldWndProc) // restore old wndProc
		SetWindowLong(m_hWnd, GWL_WNDPROC, (DWORD)g_pOldWndProc);
	g_pIContext2 = NULL; // prevents accidental use
}
@


1.22
log
@Reduced H-file dependency.
@
text
@d88 1
a88 1
					g_App.m_pMDlg->AddDebugLogLine(RGB_LOG_ERROR_TXT _T("Failed to rename '%s' - %s"), file->GetFileName(), _tcserror(errno));
@


1.21
log
@Unicode fix for shell context menu.
@
text
@d4 1
@


1.20
log
@Suppressed level 4 warnings; Formatting [Aw3].
@
text
@d66 1
a66 1
		char szBuf[100] = "";
d68 1
a68 1
		m_lpcm->GetCommandString(iCmd-1, GCS_VERB, NULL, szBuf, sizeof(szBuf) / sizeof(szBuf[0]));
d70 1
a70 1
		if (!strcmp(szBuf, "rename"))
a90 1
		USES_CONVERSION;
d96 1
a96 1
		cmi.lpVerb       = T2A(MAKEINTRESOURCE(iCmd - 1));
@


1.19
log
@Improved string processing.
@
text
@d143 1
a143 1
				if (nCount = GetItemCount (pidlMain))
d148 1
a148 1
						if (pidlNextItem = DuplicateItem (pMalloc, pidlItem))
d220 2
a221 2
	UINT nCount;
	nCount = 0;
@


1.18
log
@Added sanity checks for renaming through context menu {Prodoc};
Formatting; Unicode corrections.
@
text
@d72 3
a74 4
			InputBox namebox;
			namebox.SetLabels(GetResString(IDS_RENAME),file->GetFileName());
			namebox.SetEditFilenameMode();
			if(namebox.DoModal()==IDOK)
@


1.17
log
@UNICODE preparation (first shot)
@
text
@d44 1
a44 1
    m_hWnd(hWnd), m_sAbsPath(sAbsPath)
d46 1
a46 1
    m_lpcm = NULL;
d51 2
a52 1
    if (m_lpcm) m_lpcm->Release();
d57 1
a57 1
    return (1 <= iCmd  &&  iCmd <= 10000);
d63 2
a64 1
    if (iCmd)
d66 3
a68 2
		char szBuf[100]="";
		m_lpcm->GetCommandString(iCmd-1,GCS_VERB,NULL,szBuf,100);
d70 1
a70 1
		if(!strcmp(szBuf,"rename"))
d77 1
a77 1
				CString name=namebox.GetInput();
d79 10
a88 5
				if (path.Right(1)!='\\')
					path+='\\';
				_trename(path+file->GetFileName(),path+name);
				file->SetFileName(name);
				g_App.m_pSharedFilesList->UpdateItem(file, true);
d113 1
a117 1
	{
a118 1
	}
d131 1
a131 1
	GetFullPathName (m_sAbsPath, MAX_PATH, tchPath, NULL);
d133 1
a133 1
	lstrcpy (wchPath, tchPath);
d135 1
a135 1
	MultiByteToWideChar (CP_ACP, 0, tchPath, -1, wchPath, MAX_PATH);
d139 1
d141 1
d143 1
d208 4
a211 1
	pMalloc->Free (pidlMain);
d214 1
d259 1
d265 1
a265 1
}@


1.16
log
@renamed 3 variables
@
text
@d24 1
a24 1
				UINT uItem = (UINT) LOWORD(wp);   
d43 1
a43 1
CShellContextMenu::CShellContextMenu(HWND hWnd, const CString& sAbsPath) : 
d125 1
a125 1
#ifdef UNICODE	
@


1.15
log
@Don't republish shared file on the server after renaming (not so important to update).
@
text
@d80 1
a80 1
				g_eMuleApp.m_pSharedFilesList->UpdateItem(file, true);
d97 1
a97 1
		g_eMuleApp.m_pSharedFilesList->Reload();
@


1.14
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@d80 1
a80 1
				g_eMuleApp.m_pSharedFilesList->Reload();
@


1.13
log
@show cleanup-button for renaming shared files via shellmenu
@
text
@d240 1
a240 1
	CopyMemory (pidlNew, pidl, nLen);
@


1.12
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d71 1
@


1.11
log
@small typo
@
text
@d79 1
a79 1
				theApp.sharedfiles->Reload();
d96 1
a96 1
		theApp.sharedfiles->Reload();
@


1.10
log
@unicode cleanup
@
text
@d127 1
a127 1
	MultiByteToWideChar (CP_ACP, 0, tchPath, -1, wchPath, MAX_PATH));
@


1.9
log
@unicode cleanup
@
text
@d83 2
d89 1
a89 1
		cmi.lpVerb       = MAKEINTRESOURCE(iCmd - 1);
d123 6
a128 6
	GetFullPathName (m_sAbsPath, sizeof (tchPath) / sizeof (char), tchPath, NULL);
	if (IsTextUnicode (tchPath, lstrlen (tchPath), NULL))
		lstrcpy ((TCHAR *) wchPath, tchPath);
	else
		MultiByteToWideChar (CP_ACP, 0, tchPath, -1, wchPath,
		sizeof (wchPath) / sizeof (WCHAR));
@


1.8
log
@Fixed a bug with not being able to set some folders as output folder (0000225)   (it was not only drives root but some "special" folders too). .
also fixed few COM/Shell related memory leaks.
@
text
@d77 1
a77 1
				rename(path+file->GetFileName(),path+name);
d114 1
a114 1
	char tchPath[MAX_PATH];
d123 1
a123 1
		lstrcpy ((char *) wchPath, tchPath);
@


1.7
log
@More try/catch according to crash dumps
@
text
@d142 1
@


1.6
log
@fixed dumb mistake, and expanded rename dialog...
@
text
@d18 1
d39 2
d61 1
d96 1
d101 1
d197 1
@


1.5
log
@Fixed bugs #38 & #169
@
text
@d60 1
a60 1
		char szBuf[100];
d62 1
d66 1
a66 1
			namebox.SetLabels(GetResString(IDS_RENAME),GetResString(IDS_RENAME)+" \""+file->GetFileName()+"\":",file->GetFileName());
d74 1
a74 1
				file->SetFileName(path+name);
d81 2
a82 2
		cmi.fMask		 = SEE_MASK_FLAG_NO_UI;
		cmi.hwnd         = m_hWnd;
@


1.4
log
@Fixed bugs #38 & #169
@
text
@d61 1
a61 1
		m_lpcm->GetCommandString(iCmd-1,GCS_VERBA,NULL,szBuf,strlen(szBuf));
@


1.3
log
@readded a flag
@
text
@d2 1
d4 1
d56 1
a56 1
void CShellContextMenu::InvokeCommand(int iCmd) const
d60 18
d89 1
d173 1
a173 1
						if (SUCCEEDED (m_lpcm->QueryContextMenu (*pMenu, 0, 1, 10000, CMF_NORMAL|CMF_NODEFAULT/*|CMF_CANRENAME|CMF_EXPLORE|CMF_INCLUDESTATIC*/)))
@


1.2
log
@Shell Menu bugfixes (i hope!)
@
text
@d152 1
a152 1
						if (SUCCEEDED (m_lpcm->QueryContextMenu (*pMenu, 0, 1, 10000, CMF_NORMAL/*CMF_NODEFAULT | CMF_EXPLORE*/)))
@


1.1
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@a0 20
/***************************************************************************/
/* NOTE:                                                                   */
/* This document is copyright (c) by Oz Solomonovich, and is bound by the  */
/* MIT open source license (www.opensource.org/licenses/mit-license.html). */
/* See License.txt for more information.                                   */
/***************************************************************************/


// ShellContextMenu.cpp : implementation file
//
// Handles the creation of the shell context menu, including the "Send To..."
// sub-menu.  
// Personal note: I think that MS should have made the code to populate and
// handle the "Send To..." sub-menu a part of the shell context menu code.  
// But they didn't, so now we're forced to write a whole lot of spaghetti COM 
// code to do what should have been a trivial part of the OS.  See the code 
// below and judge for yourself.
//
// Additions/Fixes by Philip Oldaker (philip@@masmex.com)

a2 2
#include "PIDL.h"

d5 2
a7 2
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
d10 3
a12 14
// these are the menu id's for the "Send To" and "Open With" items
#define IDM_SENDTOID           20028
#define IDM_OPENWITHID_MIN     20099

// OpenWith menu registry keys
static LPCTSTR szAppKey = _T("Applications");
static LPCTSTR szOpenWithListKey = _T("OpenWithList");
static LPCTSTR szShellKey = _T("shell");
static LPCTSTR szCommandKey = _T("command");
static LPCTSTR szFileExtKey = _T("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts");
// OpenWith menu entries
static LPCTSTR szMRUListEntry = _T("MRUList");
static LPCTSTR szDisplayNameEntry = _T("FriendlyCache");

d14 1
a14 1
static class CShCMInitializer
d16 20
a35 46
public:
    CShCMInitializer();
    ~CShCMInitializer();

    static LPSHELLFOLDER   m_sfDesktop;
    static LPSHELLFOLDER   m_sfSendTo;
    static CImageList *    m_pShellImageList;
    static CPIDL           m_pidlSendTo;
} stat_data;

LPSHELLFOLDER CShCMInitializer::m_sfDesktop       = NULL;
LPSHELLFOLDER CShCMInitializer::m_sfSendTo        = NULL;
CImageList *  CShCMInitializer::m_pShellImageList = NULL;
CPIDL         CShCMInitializer::m_pidlSendTo;

CShCMInitializer::CShCMInitializer()
{
    HRESULT     hr;
    SHFILEINFO  sfi;

    SHGetDesktopFolder(&m_sfDesktop);

    hr = SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, m_pidlSendTo);
    if (SUCCEEDED(hr)) 
    {
        hr = m_sfDesktop->BindToObject(m_pidlSendTo, NULL, IID_IShellFolder, 
            (LPVOID *)&m_sfSendTo);
        if (!SUCCEEDED(hr)) 
        {
            m_sfSendTo = NULL;
        }
    } 
    else 
    {
        m_sfSendTo = NULL;
    }

    m_pShellImageList = CImageList::FromHandle((HIMAGELIST)
        SHGetFileInfo((LPCTSTR)_T("C:\\"), 0, &sfi, sizeof(SHFILEINFO), 
        SHGFI_SYSICONINDEX | SHGFI_SMALLICON));
}

CShCMInitializer::~CShCMInitializer()
{
    m_sfSendTo->Release();
    m_sfDesktop->Release();
a37 1

d39 1
a39 2
    m_hWnd(hWnd), m_sAbsPath(sAbsPath), m_iliFolder(-1), 
    m_bFirstSendToIsMenu(false)
a41 2
    m_ilSendToMenu.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 5);
    m_ilOpenWithMenu.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 5);
d51 1
a51 4
    return (
            (IDM_SENDTOFIRST   <= iCmd  &&  iCmd <= IDM_SENDTOLAST) ||
            (IDM_SHELLCTXFIRST <= iCmd  &&  iCmd <= IDM_SHELLCTXLAST)
           );
d56 14
a69 62
    if (!iCmd)
    {
        return;
    }

    if (IDM_SENDTOFIRST <= iCmd  &&  iCmd <= IDM_SENDTOLAST)
    {
        // "Send To..." item

        CPIDL        pidlFile(m_sAbsPath);
        LPDROPTARGET pDT;
        LPDATAOBJECT pDO;
        HRESULT hr;

        hr = pidlFile.GetUIObjectOf(IID_IDataObject, (LPVOID *)&pDO, 
            m_hWnd);
        if (SUCCEEDED(hr))
        {
            CPIDL pidlDrop;
            m_mapPIDLs.Lookup(iCmd, pidlDrop);
            hr = pidlDrop.GetUIObjectOf(IID_IDropTarget, 
                (LPVOID *)&pDT, m_hWnd);

            if (SUCCEEDED(hr))
            {
                // do the drop
                POINTL pt = { 0, 0 };
                DWORD dwEffect = 
                    DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK;
                hr = pDT->DragEnter(pDO, MK_LBUTTON, pt, &dwEffect);

                if (SUCCEEDED(hr) && dwEffect) 
                {
                    hr = pDT->Drop(pDO, MK_LBUTTON, pt, &dwEffect);
                } 
                else 
                {
                    hr = pDT->DragLeave();
                }

                pDT->Release();
            }

            pidlDrop.m_pidl = NULL;
        }
    }
    else
    {
        // Shell command

        CMINVOKECOMMANDINFO cmi;
        cmi.cbSize       = sizeof(cmi);
        cmi.fMask        = 0;
        cmi.hwnd         = m_hWnd;
        cmi.lpVerb       = MAKEINTRESOURCE(iCmd - IDM_SHELLCTXFIRST);
        cmi.lpParameters = NULL;
        cmi.lpDirectory  = NULL;
        cmi.nShow        = SW_SHOWNORMAL;
        cmi.dwHotKey     = 0;
        cmi.hIcon        = NULL;
        m_lpcm->InvokeCommand(&cmi);
    }
a71 2

// retrieves the shell context menu for a file
d74 2
a75 2
    HRESULT         hr;
    CPIDL           pidl;
d77 4
a80 1
    m_lpcm = NULL;
d82 87
a168 90
    if (m_sAbsPath.GetLength() == 0)
    {
        return;
    }

    if (SUCCEEDED(hr = pidl.Set(m_sAbsPath)))
    {
        hr = pidl.GetUIObjectOf(IID_IContextMenu, (LPVOID *)&m_lpcm, m_hWnd);
    }

    if (SUCCEEDED(hr))
    {
        pMenu->DeleteMenu(0, MF_BYPOSITION);
        hr = m_lpcm->QueryContextMenu(*pMenu, 0, IDM_SHELLCTXFIRST, 
            IDM_SHELLCTXLAST, CMF_NODEFAULT | CMF_EXPLORE);

        // try to find the "Send To"/"Open With..." submenus
        CMenu *pSubMenu;
        const int count = pMenu->GetMenuItemCount();
        UINT idmFirstInSubMenu, idm;
        CString str;
        for (int i = 0; i < count; i++)
        {
            pSubMenu = pMenu->GetSubMenu(i);
            if (pSubMenu  &&  pSubMenu->GetMenuItemCount() == 1)
            {
                pSubMenu->GetMenuString(0, str, MF_BYPOSITION);
                idmFirstInSubMenu = pSubMenu->GetMenuItemID(0);

                if (idmFirstInSubMenu >= IDM_OPENWITHID_MIN)
                {
                    // force population of "Open With..." submenu 
                    // (trick courtesy of Philip Oldaker (philip@@masmex.com))
                    IContextMenu2 *lpcm2 = NULL;
                    hr = m_lpcm->QueryInterface(IID_IContextMenu2, (LPVOID*)&lpcm2);
                    if (SUCCEEDED(hr))
                    {
                        hr = lpcm2->HandleMenuMsg(WM_INITMENUPOPUP,
                            (WPARAM)pSubMenu->GetSafeHmenu(), 0);
                    }
                    lpcm2->Release();
                }
/*                    IContextMenu2 *lpcm2 = NULL;
                    HRESULT hr = m_lpcm->QueryInterface(IID_IContextMenu2,
                        (LPVOID*)&lpcm2);
                    if (SUCCEEDED(hr))
                    {
                        hr = lpcm2->HandleMenuMsg(WM_INITMENUPOPUP,
                            (WPARAM)pSubMenu->GetSafeHmenu(), 0);
                        lpcm2->Release();
continue;                        
                        // We need the extension to search the registry for 
                        // valid applications.  If there is no extension then 
                        // there's nothing to do
                        CString sExt = GetExt(m_sAbsPath);
                        if (sExt.IsEmpty())
                            continue;
                        // populate "Open With" menu
                        idm = IDM_OPENWITHFIRST;
                        pSubMenu->DestroyMenu();
                        pSubMenu = CMenu::FromHandle(::CreatePopupMenu());
                        ASSERT_VALID(pSubMenu);
                        pMenu->ModifyMenu(i, MF_BYPOSITION | MF_POPUP, 
                        (UINT)pSubMenu->m_hMenu, str);

                        FillOpenWithMenu(pSubMenu, sExt, idm);
                        continue;
                    }
                    else
                    {
                        lpcm2->Release();
                    }
                } */
                else if (idmFirstInSubMenu == IDM_SENDTOID)
                {
                    // populate "Send To" menu
                    idm = IDM_SENDTOFIRST;
                    pSubMenu->DestroyMenu();
                    pSubMenu = CMenu::FromHandle(::CreatePopupMenu());
                    ASSERT_VALID(pSubMenu);
                    pMenu->ModifyMenu(i, MF_BYPOSITION | MF_POPUP, 
                        (UINT)pSubMenu->m_hMenu, str);
                    FillSendToMenu(pSubMenu, stat_data.m_sfSendTo, idm);
                    break;
                }
            }
        }
    }

    return;
d171 1
a171 5

/////////////////////////////
// Addition: Philip Oldaker
/////////////////////////////
CString CShellContextMenu::GetExt(const CString &sPath)
d173 9
a181 7
    TCHAR szDir[_MAX_PATH];
    TCHAR szDrive[_MAX_DRIVE];
    TCHAR szFileName[_MAX_FNAME];
    TCHAR szExt[_MAX_EXT];
    szDir[0] = szDrive[0] = szFileName[0] = szExt[0] = 0;
    _tsplitpath(sPath,szDrive,szDir,szFileName,szExt);
    return szExt;
d184 1
a184 4
// A bunch of registry nonsense to return all relevant details
// but especially the application icon
void CShellContextMenu::GetAppDetails(const CString& sAppName,
    CString& sDisplayName, CString& sCommand, HICON& hIconApp) const
d186 4
a189 76
    hIconApp = NULL;
    sDisplayName.Empty();
    sCommand.Empty();

    CString sAppKey(szAppKey);
    AddKey(sAppKey,sAppName);
    AddKey(sAppKey, szShellKey);
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT,sAppKey,0,KEY_READ,&hKey) != ERROR_SUCCESS)
        return;
    BYTE szDisplayName[_MAX_PATH];
    DWORD dwSize=sizeof(szDisplayName);
    DWORD dwType=REG_SZ;
    LONG nRet = RegQueryValueEx(hKey, szDisplayNameEntry, NULL, &dwType,
        szDisplayName,&dwSize);
    if (nRet != ERROR_SUCCESS)
    {
        RegCloseKey(hKey);
        return;
    }
    sDisplayName = szDisplayName;
    TCHAR szSubKey[_MAX_PATH];
    TCHAR szClass[_MAX_PATH];
    DWORD dwSizeSubKey = sizeof(szSubKey)-1;
    DWORD dwSizeClass = sizeof(szClass)-1;
    ZeroMemory(szSubKey,sizeof(szSubKey));
    ZeroMemory(szClass,sizeof(szClass));
    FILETIME ftLastWriteTime;
    HKEY hCmdKey=NULL;
    CString sCmdKey;
    // Search for a key that contains the "command" key as it may not be under "open"
    for(DWORD dwIndex=0;
        RegEnumKeyEx(hKey,dwIndex, 
                      szSubKey, 
                      &dwSizeSubKey,
                      NULL,
                      szClass,
                      &dwSizeClass,
                      &ftLastWriteTime) == ERROR_SUCCESS;dwIndex++)
    {
        sCmdKey = szSubKey;
        AddKey(sCmdKey, szCommandKey);
        if (RegOpenKeyEx(hKey, sCmdKey, 0, KEY_READ, &hCmdKey) == ERROR_SUCCESS)
        {
            break;
        }
        dwSizeSubKey = sizeof(szSubKey)-1;
        dwSizeClass = sizeof(szClass)-1;
    }
    RegCloseKey(hKey);
    hKey = NULL;
    if (hCmdKey == NULL)
        return;
    dwType=REG_SZ | REG_EXPAND_SZ;
    BYTE szCommand[_MAX_PATH];
    dwSize=sizeof(szCommand);
    nRet = RegQueryValueEx(hCmdKey,NULL,NULL,&dwType,szCommand,&dwSize);
    if (nRet != ERROR_SUCCESS)
        return;
    TCHAR szPath[MAX_PATH];
    sCommand = szCommand;
    if (ExpandEnvironmentStrings(sCommand,szPath,sizeof(szPath)))
        sCommand = szPath;
    CString sIconPath(sCommand);
    sIconPath.MakeLower();
    // Only extract icons from exe's at the moment
    int nPos = sIconPath.Find(_T(".exe"));
    if (nPos == -1)
        return;
    sIconPath = sIconPath.Left(nPos+4);
    // Remove auy quotes
    if (sIconPath.Left(1) == '\"')
        sIconPath = sIconPath.Right(sIconPath.GetLength()-1);
    if (sIconPath.Right(1) == '\"')
        sIconPath = sIconPath.Left(sIconPath.GetLength()-1);
    ExtractIconEx(sIconPath, 0, NULL, &hIconApp, 1);        
d191 1
a191 1
    RegCloseKey(hCmdKey);
d194 1
a194 2
// reg helper
void CShellContextMenu::AddKey(CString& sDestKey, const CString& sSrcKey) 
d196 2
a197 5
    if (sDestKey.Right(1) != '\\')
        sDestKey += '\\';
    sDestKey += sSrcKey;
}
////////////////////////////////////////
d199 3
d203 3
a205 29
////////////////////////////
// Additions: Philip Oldaker
// Scan the registry looking for a OpenWithList key in this format
// Entry MRUList contains the alphabetical order eg. afgrde for each entry
// each of these entries points to the application name which in turn
// has the command and display name
////////////////////////////
void CShellContextMenu::FillOpenWithMenu(CMenu *pMenu, const CString &sExt,
    UINT &idm)
{
	HKEY hKey;
	CString sFileExtKey(szFileExtKey);
	AddKey(sFileExtKey,sExt);
	AddKey(sFileExtKey,szOpenWithListKey);
	if (RegOpenKeyEx(HKEY_CURRENT_USER,sFileExtKey,0,KEY_READ,&hKey) != ERROR_SUCCESS)
		return;
	BYTE szMRUList[_MAX_PATH];
	szMRUList[0] = 0;
	DWORD dwSize=sizeof(szMRUList);
	DWORD dwType=REG_SZ;
	RegQueryValueEx(hKey,szMRUListEntry,NULL,&dwType,szMRUList,&dwSize);
	int nLen = _tcslen((LPCTSTR)szMRUList);
	TCHAR szOpenWithItemEntry[sizeof(TCHAR)*2];
	ZeroMemory(szOpenWithItemEntry,sizeof(szOpenWithItemEntry));
	BYTE szOpenWithItem[_MAX_PATH];
	CString sDisplayName;
	HICON hIconApp;
	CString sCommand;
	CString sMenuText;
d207 2
a208 28
	for(int i=0;i < nLen;i++)
	{
		szOpenWithItemEntry[0] = szMRUList[i];
		dwSize = sizeof(szOpenWithItem);
		RegQueryValueEx(hKey,szOpenWithItemEntry,NULL,&dwType,szOpenWithItem,&dwSize);
		GetAppDetails((LPCTSTR)szOpenWithItem, sDisplayName, sCommand, hIconApp);
		if (!sCommand.IsEmpty())
		{
            pMenu->AppendMenu(MF_STRING, idm, sDisplayName);
            m_ilOpenWithMenu.Add(hIconApp);
//            m_mapPIDLs[idm] = abspidl;
            idm++;
//            pMenu->
//			for(unsigned idm=0;idm < pMenu->GetMenuItemCount();idm++)
if(0)            
			{
				//pMenu->GetMenuString(idm,sMenuText,MF_BYPOSITION);
				//if (sMenuText == sDisplayName)
				{
//					g_CoolMenuManager.ConvertMenuItem(pMenu, idm);
//					CCoolMenuManager::SetItemIcon(*pMenu, hIconApp, idm, TRUE);
	//				break;
				}
			}
		}
	}
	RegCloseKey(hKey);
}
d210 1
a210 86
void CShellContextMenu::FillSendToMenu(CMenu *pMenu, LPSHELLFOLDER pSF, 
    UINT &idm)
{
    USES_CONVERSION;
    CPIDL           pidl, abspidl;
    LPENUMIDLIST    peidl;
    HRESULT         hr;
    STRRET          str;
    UINT            idmStart = idm;
    LPSHELLFOLDER   pSubSF;
    SHFILEINFO      sfi;

    if (pSF) 
    {
        int idx_folder = 0; // folder insertion index

        hr = pSF->EnumObjects(m_hWnd, 
            SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &peidl);

        if (SUCCEEDED(hr))
        {
            while (peidl->Next(1, pidl, NULL) == S_OK  &&
                   idm < IDM_SENDTOLAST) 
            {
                hr = pSF->GetDisplayNameOf(pidl, SHGDN_NORMAL, &str);
                if (SUCCEEDED(hr)) 
                {
                    ULONG ulAttrs = (unsigned)-1;
                    pSF->GetAttributesOf(1, pidl, &ulAttrs);
                    abspidl.MakeAbsPIDLOf(pSF, pidl);
                    SHGetFileInfo((LPCTSTR)abspidl.m_pidl, 0, &sfi, 
                        sizeof(sfi), 
                        SHGFI_PIDL | SHGFI_ICON | SHGFI_SMALLICON);
                    pidl.ExtractCStr(str);
                    if (ulAttrs & SFGAO_FOLDER) // folder?
                    {
                        // create new submenu & recurse
                        HMENU hSubMenu = ::CreateMenu();
                        pMenu->InsertMenu(idx_folder, 
                            MF_POPUP | MF_BYPOSITION | MF_STRING, 
                            (UINT)hSubMenu, str.cStr);
                        m_iliFolder = sfi.iIcon;
                        if (idm == IDM_SENDTOFIRST)
                        {
                            m_bFirstSendToIsMenu = true;
                            idm++;  // needed for IsFolderSubMenu() logic
                        }

                        idx_folder++;
                        hr = pSF->BindToObject(pidl, NULL, 
                            IID_IShellFolder, (LPVOID *)&pSubSF);
                        if (!SUCCEEDED(hr)) pSubSF = NULL;
                        FillSendToMenu(CMenu::FromHandle(hSubMenu), pSubSF, 
                            idm);
                        if (idm == IDM_SENDTOFIRST && m_bFirstSendToIsMenu)
                        {
                            m_bFirstSendToIsMenu = false;
                            idm--;
                        }
                        if (pSubSF) pSubSF->Release();
                        abspidl.Free();
                    }
                    else
                    {
                        pMenu->AppendMenu(MF_STRING, idm, str.cStr);
                        m_ilSendToMenu.Add(sfi.hIcon);
                        m_mapPIDLs[idm] = abspidl;
                        idm++;
                    }
                    abspidl.m_pidl = NULL;
                    pidl.Free();
                }
            }
            peidl->Release();
        }
    }

    // If the menu is still empty (the user has an empty SendTo folder),
    // then add a disabled "(empty)" item so we have at least something
    // to display.
    if (idm == idmStart) 
    {
        pMenu->AppendMenu(
            MF_GRAYED | MF_DISABLED | MF_STRING, IDM_SENDTOLAST, 
            _T("(empty)"));
    }
d212 1
a212 3

bool CShellContextMenu::GetCommandImage(int iCmd, bool bIsSubMenu,
    CImageList *&pil, int& index)
d214 4
a217 36
    if (bIsSubMenu)
    {
        if (m_iliFolder >= 0)
        {
            index = m_iliFolder;
            pil = stat_data.m_pShellImageList;
            return true;
        }
        else
        {
            index = -1;
            return false;
        }
    }

    if ((IDM_SENDTOFIRST <= iCmd  &&  iCmd < IDM_SENDTOLAST))
    {
        iCmd -= IDM_SENDTOFIRST;
        if (m_bFirstSendToIsMenu) iCmd--;
        pil = &m_ilSendToMenu;
        index = iCmd;
    }
    else if ((IDM_OPENWITHFIRST <= iCmd  &&  iCmd < IDM_OPENWITHLAST))
    {
        iCmd -= IDM_OPENWITHFIRST;
        pil = &m_ilSendToMenu;
        index = iCmd;
    }
    else
    {
        index = -1;
        return false;
    }

    return true;
}
@

