head	1.20;
access;
symbols
	PublicRelease_1_2e:1.20
	Interim_Release_1-2e_RC1:1.20
	PublicRelease_1_2d:1.17
	Interim_Release_1-2d_RC1:1.17
	Interim_Release_1-2d_beta1:1.17
	PublicRelease_1_2c:1.15
	Interim_Release_1-2c_RC1:1.15
	Interim_Release_1-2c_beta1:1.14
	PublicRelease_1_2b:1.14
	Interim_Release_1-2b_RC1:1.14
	PublicRelease_1_2a:1.14
	Interim_Release_1-2a_RC1:1.14
	Interim_Release_1-2a_beta2:1.13
	Interim_Release_1-2a_beta1:1.13
	PublicRelease_1_2:1.13
	Interim_Release_1-2_RC1:1.13
	Interim_Release_1-2_beta1:1.13
	PublicRelease_1_1g:1.12
	Interim_Release_1-1g_RC3:1.12
	Interim_Release_1-1g_RC2:1.12
	Interim_Release_1-1g_RC1:1.12
	Interim_Release_1-1g_beta2:1.10
	Interim_Release_1-1g_beta1:1.10
	PublicRelease_1_1f:1.10
	Interim_Release_1-1f_RC1:1.10
	PublicRelease_1_1e:1.10
	Interim_Release_1-1e_RC2:1.10
	Interim_Release_1-1e_RC1:1.10
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.7
	Interim_Release_1-1c_beta2:1.5
	Interim_Release_1-1c_beta1:1.3;
locks; strict;
comment	@// @;


1.20
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.04.03.34.48;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2007.12.01.23.20.58;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2007.12.01.10.38.05;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.27.06.11.25;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.06.05.56.01;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.11;

1.11
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.26.11.18.31;	author kuchin;	state Exp;
branches;
next	1.9;

1.9
date	2005.02.26.10.45.58;	author kuchin;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.24.14.18.52;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.18.16.11.34;	author kuchin;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.18.15.12.46;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.14.02.39.34;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2005.02.13.18.40.14;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.16.00.34.57;	author netwolf1;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.08.14.35.59;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2005.01.08.12.35.50;	author kuchin;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Simplified logging system implementation.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
/*
Sample configuration file
(autodl.ini in Config/ directory)
-----------------------------------
[General]
Count=1
[DL#1]
URL=http://yourdomain.com/file.xml
Interval=60
-----------------------------------

Sample file.xml at yourdomain.com
-----------------------------------
<autodl min_interval="1440">
	<item link="ed2k://|file|Filename1.avi|123|786AFC89F4748C83DF3488D246C337E7|/" category="Movies" />
	<item link="ed2k://|file|Filename2.avi|456|886AFC89F4748C83DF3488D246C337E7|/" category="Animation" />
</autodl>
-----------------------------------
*/

#include "stdafx.h"
#include "emule.h"
#include "ini2.h"
#include "Engine/Other/XMLhelper.h"
#include "AutoDL.h"
#include "ED2KLink.h"
#include "SharedFileList.h"
#include <wininet.h>

CAutoDL::CAutoDL()
	:m_hWorkerThread(NULL)
	,m_hFinish(NULL)
	,m_bUseIt(false)
{
	LoadPrefs();
	Start();
}

CAutoDL::~CAutoDL()
{
	SavePrefs();
	Finish();
}

void CAutoDL::GetConfigFilename(CString *pstrOut)
{
	EMULE_TRY
	pstrOut->Format(_T("%sautodl.ini"), g_App.m_pPrefs->GetConfigDir());
	return;
	EMULE_CATCH
	*pstrOut = _T("");
}

bool CAutoDL::LoadPrefs()
{
	EMULE_TRY
	// Can't load data in the middle of work
	if(m_hWorkerThread != NULL)
		return false;

	CString	strTmp;
	GetConfigFilename(&strTmp);

	// Check if file exists
	if(!PathFileExists(strTmp))
		return false;

	// Load data
	CIni dlini(strTmp, INI_MODE_ANSIONLY | INI_MODE_READONLY);
	dlini.SetDefaultCategory(_T("General"));
	m_bUseIt = dlini.GetBool(_T("UseIt"), false);

	int iCount = dlini.GetInt(_T("Count"), 0);

	for(int i = 1; i <= iCount; i++)
	{
		strTmp.Format(_T("DL#%u"), i);
		dlini.SetDefaultCategory(strTmp);

		CAutoDLData data;
 		_tcsncpy(data.acUrl, dlini.GetString(_T("URL"), _T("")), DLURLMAX);
		data.acUrl[DLURLMAX - 1] = _T('\0');
		data.ulInterval = max(dlini.GetUInt32(_T("Interval"), 0), 30);	// 30 minutes minimum
		data.lLastCheck = 0;

		m_UrlList.Add(data);
	}
	return true;
	EMULE_CATCH
	return false;
}

bool CAutoDL::SavePrefs()
{
	EMULE_TRY

	CString	strTmp;
	GetConfigFilename(&strTmp);

	// If we don't have anything to save, just delete the file
	DeleteFile(strTmp);
	if(m_UrlList.GetSize() == 0)
		return false;

	// Save data
	CIni dlini(strTmp, INI_MODE_ANSIONLY);
	dlini.SetDefaultCategory(_T("General"));
	dlini.SetBool(_T("UseIt"), m_bUseIt);
	dlini.SetInt(_T("Count"), m_UrlList.GetSize());
	for(int i = 0; i < m_UrlList.GetSize(); i++)
	{
		strTmp.Format(_T("DL#%u"), i + 1);
		dlini.SetDefaultCategory(strTmp);
		dlini.SetString(_T("URL"), m_UrlList[i].acUrl);
		dlini.SetUInt32(_T("Interval"), m_UrlList[i].ulInterval);
	}
	dlini.SaveAndClose();
	return true;
	EMULE_CATCH
	return false;
}

void CAutoDL::Start()
{
	// Close any previous work
	Finish();
	// If we have nothing to check, don't start
	if(m_UrlList.GetCount() == 0 || !m_bUseIt)
		return;
	m_hFinish = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_hWorkerThread = (HANDLE)_beginthread(WorkerThread, 0, reinterpret_cast<void*>(this));
}

void CAutoDL::Finish()
{
	EMULE_TRY
	if(m_hWorkerThread != NULL)
	{
		SetEvent(m_hFinish);
		// Wait 1 second for thread completion, then terminate it
		if(WaitForSingleObject(m_hWorkerThread, 1000) == WAIT_TIMEOUT)
		{
			if(!TerminateThread(m_hWorkerThread, 0))
				AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Can't terminate AutoDL thread!"));
		}
		m_hWorkerThread = NULL;
	}
	if (m_hFinish != NULL)
	{
		CloseHandle(m_hFinish);
		m_hFinish = NULL;
	}
	EMULE_CATCH
}

void CAutoDL::WorkerThread(void *pT)
{
	EMULE_TRY
	::CoInitialize(NULL);
	Sleep(5000);	// Wait until we load all things, etc
	CAutoDL* pThis = static_cast<CAutoDL*>(pT);
	while(WaitForSingleObject(pThis->m_hFinish, 1000) == WAIT_TIMEOUT)
	{
		for(int i = 0; i < pThis->m_UrlList.GetCount(); i++)
		{
			long lCurTime = time(NULL), lLastCheck = pThis->m_UrlList[i].lLastCheck;

			if ((lLastCheck == 0) || (lCurTime - lLastCheck) >= static_cast<long>(pThis->m_UrlList[i].ulInterval))
			{
				ULONG ulMinInterval = pThis->CheckUrl(pThis->m_UrlList[i].acUrl);
				if(ulMinInterval != 0 && ulMinInterval > pThis->m_UrlList[i].ulInterval)
					pThis->m_UrlList[i].ulInterval = ulMinInterval;
				pThis->m_UrlList[i].lLastCheck = lCurTime;
				// Check one URL at once
				break;
			}
		}
	}
	EMULE_CATCH
}

ULONG CAutoDL::CheckUrl(const TCHAR *pcUrl)
{
	ULONG ulMinInterval = 0;
	BYTE *pBuf = NULL;

	EMULE_TRY

	// Download file
	HINTERNET hOpen = InternetOpen(HTTP_USERAGENT, INTERNET_OPEN_TYPE_PRECONFIG , NULL, NULL, 0);
	if(hOpen)
	{
		HINTERNET hURL = InternetOpenUrl(hOpen, pcUrl, _T(""), NULL, INTERNET_FLAG_NO_CACHE_WRITE, NULL);
		if (hURL)
		{
			DWORD dwFileLen = 0, dwSize = sizeof(dwFileLen);
			HttpQueryInfo(hURL, HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER, &dwFileLen, &dwSize, NULL);
			DWORD dwRead;
			pBuf = new BYTE[dwFileLen + 1];
			if(InternetReadFile(hURL, pBuf, dwFileLen, &dwRead))
				pBuf[dwRead] = 0;
		}
	}
	if(pBuf == NULL)
		return 0;
	// Load XML
	XmlDoc spDoc = XmlLoadDocumentFromStr((LPCTSTR)pBuf);
	if(spDoc)
	{
		XmlElement spRoot = spDoc->documentElement;
		if(spRoot)
		{
			ulMinInterval = XmlGetAttributeLong(spRoot, _T("min_interval"), 0);
			for(int i = 0; i < spRoot->childNodes->length; i++)
			{
				XmlElement spElem = spRoot->childNodes->item[i];
				CString sLink = XmlGetAttributeStr(spElem, _T("link"));
				CString sCategory = XmlGetAttributeStr(spElem, _T("category"));
				DownloadLink(sLink, sCategory);
			}
		}
	}
	EMULE_CATCH

	delete[] pBuf;
	return ulMinInterval;
}

void CAutoDL::DownloadLink(CString sLink, CString sCategory)
{
	EMULE_TRY

	// Check if we already have that file
	bool bSkip = false;
	CED2KLink* pLink = CED2KLink::CreateLinkFromUrl(sLink);
	if(pLink)
	{
		if(pLink->GetKind() == CED2KLink::kFile)
		{
			CKnownFile		*pKnownFile;
			CED2KFileLink	*pFileLink = pLink->GetFileLink();

			if (pFileLink != NULL)
			{
				if ((pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pFileLink->GetHashKey())) != NULL)
					bSkip = true;
				else if ((pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pFileLink->GetHashKey())) != NULL)
					bSkip = true;
				delete pFileLink;
			}
			else
				delete pLink;
		}
		else
			delete pLink;
	}
	if(bSkip)
		return;

	// Find category
	EnumCategories eCatID = CAT_NONE;
	for (int i = 0; i < CCat::GetNumCats(); i++)
	{
		if (i >= CCat::GetNumPredefinedCats())
			if(sCategory == CCat::GetCatByIndex(i)->GetTitle())
				eCatID = CCat::GetCatByIndex(i)->GetID();
	}

	// Add link
	g_App.m_pMDlg->m_dlgSearch.AddEd2kLinksToDownload(sLink, eCatID);

	EMULE_CATCH
}

bool CAutoDL::get_UseIt()
{
	return m_bUseIt;
}

void CAutoDL::put_UseIt(bool bUseIt)
{
	m_bUseIt = bUseIt;
}

long CAutoDL::get_UrlCount()
{
	return m_UrlList.GetSize();
}

CAutoDLData CAutoDL::get_UrlItem(long nIndex)
{
	return m_UrlList[nIndex];
}

void CAutoDL::ClearUrlList()
{
	m_UrlList.RemoveAll();
}

void CAutoDL::AddUrlItem(CAutoDLData& data)
{
	m_UrlList.Add(data);
}
@


1.19
log
@Reduced H-file dependency.
@
text
@d159 1
a159 1
				AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Can't terminate AutoDL thread!"));
@


1.18
log
@Renaming; Proper protection for string buffer; Better way to avoid memory leak in case of exception.
@
text
@d42 1
@


1.17
log
@Use faster conversion on open for saving file as well.
@
text
@d95 2
a96 1
		_tcsncpy(data.sUrl, dlini.GetString(_T("URL"), _T("")), DLURLMAX);
d128 1
a128 1
		dlini.SetString(_T("URL"), m_UrlList[i].sUrl);
d184 1
a184 1
				ULONG ulMinInterval = pThis->CheckUrl(pThis->m_UrlList[i].sUrl);
d199 2
d202 1
a202 1
	BYTE *pBuf = NULL;
d218 1
a218 1
	if(!pBuf)
a236 2
	if(pBuf)
		delete[] pBuf;
d238 2
@


1.16
log
@unicode prepararions:
1) added the code for conversion
2) unicode support for ini files
3) unicode support for URL en(de)coding
4) statistic output in UTF8 format
@
text
@d119 1
a119 1
	CIni dlini(strTmp);
@


1.15
log
@Reduced #include dependency; Suppressed level 4 warnings.
@
text
@d83 1
a83 1
	CIni dlini(strTmp);
@


1.14
log
@Use general user agent for HTTP requests (to hide identity to avoid any kind of blocking or filtering).
@
text
@d42 1
d251 4
a254 2
			CED2KFileLink* pFileLink = pLink->GetFileLink();
			if(pFileLink)
d256 1
a256 1
				if(CKnownFile* pKnownFile = g_App.m_pSharedFilesList->GetFileByID(pFileLink->GetHashKey()))
d258 1
a258 1
				else if (pKnownFile = g_App.m_pDownloadQueue->GetFileByID(pFileLink->GetHashKey()))
@


1.13
log
@UNICODE preparation (first shot)
@
text
@d1 15
d200 1
a200 1
	HINTERNET hOpen = InternetOpen(_T("eMule"), INTERNET_OPEN_TYPE_PRECONFIG , NULL, NULL, 0);
@


1.12
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d68 1
a68 1
	dlini.SetDefaultCategory("General");
d104 1
a104 1
	dlini.SetDefaultCategory("General");
@


1.11
log
@renamed 3 variables
@
text
@d46 1
a46 1
	pstrOut->Format(_T("%sautodl.ini"), g_App.g_pPrefs->GetConfigDir());
@


1.10
log
@Possible memleak fix
@
text
@d46 1
a46 1
	pstrOut->Format(_T("%sautodl.ini"), g_eMuleApp.m_pGlobPrefs->GetConfigDir());
d238 1
a238 1
				if(CKnownFile* pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pFileLink->GetHashKey()))
d240 1
a240 1
				else if (pKnownFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pFileLink->GetHashKey()))
d263 1
a263 1
	g_eMuleApp.m_pdlgEmule->m_dlgSearch.AddEd2kLinksToDownload(sLink, eCatID);
@


1.9
log
@Allow to connect to 192.168.xx.xx servers in debug configuration,
AutoDL - do not add already downloaded/downloading files
@
text
@d231 1
a231 1
	if(pLink && pLink->GetKind() == CED2KLink::kFile)
d233 1
a233 2
		CED2KFileLink* pFileLink = pLink->GetFileLink();
		if(pFileLink)
d235 11
a245 5
			if(CKnownFile* pKnownFile = g_eMuleApp.m_pSharedFilesList->GetFileByID(pFileLink->GetHashKey()))
				bSkip = true;
			else if (pKnownFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(pFileLink->GetHashKey()))
				bSkip = true;
			delete pFileLink;
@


1.8
log
@Enabled/disabled fix
@
text
@d26 1
d227 23
a249 1
	EnumCategories eCatID = CAT_NONE;// : CCat::GetCatIDByUserIndex(cat);
d256 2
d259 1
@


1.7
log
@Better check for file existance
@
text
@d124 1
a124 1
	if(m_UrlList.GetCount() == 0)
@


1.6
log
@AutoDL - don't create autodl.ini when not used
@
text
@d62 1
a62 3
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind = FindFirstFile(strTmp, &FindFileData);
	if(hFind == INVALID_HANDLE_VALUE)
a63 2
	else
		FindClose(hFind);
@


1.5
log
@Improved string processing and other optimization.
@
text
@a58 1
	
d60 10
a97 1
	
d99 2
d102 4
@


1.4
log
@AutoDL - finalization, should work now, plus set smaller font in splash/about screens so debug version can be shown correctly
@
text
@d42 1
a42 1
CString	CAutoDL::GetConfigFilename()
d45 2
a46 3
	CString sFile;
	sFile.Format(_T("%sautodl.ini"), g_eMuleApp.m_pGlobPrefs->GetConfigDir());
	return sFile;
d48 1
a48 1
	return _T("");
d58 4
a61 1
	CIni dlini(GetConfigFilename());
d64 4
a67 3
	CString sDL;
	int nCount = dlini.GetInt(_T("Count"), 0);
	for(int i = 0; i < nCount; i++)
d69 2
a70 2
		sDL.Format(_T("DL#%i"), i + 1);
		dlini.SetDefaultCategory(sDL);
d87 6
a92 3
	CString sFile = GetConfigFilename();
	DeleteFile(sFile);
	CIni dlini(sFile);
d98 2
a99 2
		CString sDL; sDL.Format(_T("DL#%d"), i + 1);
		dlini.SetDefaultCategory(sDL);
d130 1
a130 1
				AddDebugLogLine(RGB_LOG_WARNING + _T("Can't terminate AutoDL thread!"));
d134 2
a135 1
	if(m_hFinish)
d137 2
a138 1
	m_hFinish = NULL;
d152 3
a154 2
			long lLastCheck = pThis->m_UrlList[i].lLastCheck;
			if(lLastCheck == 0 || (time(NULL) - lLastCheck) >= static_cast<long>(pThis->m_UrlList[i].ulInterval))
d159 1
a159 1
				pThis->m_UrlList[i].lLastCheck = time(NULL);
d168 1
a168 1
ULONG CAutoDL::CheckUrl(CString sUrl)
d177 1
a177 1
		HINTERNET hURL = InternetOpenUrl(hOpen, sUrl, _T(""), NULL, INTERNET_FLAG_NO_CACHE_WRITE, NULL);
@


1.3
log
@Add sources possibly received from global search (official).
Added missing translations in case countryflag.dll / ip-to-country.cvs is not found.
Notifier informs if a new version is available (not annoying, but still more likely
 to be noticed than just a log line).
Added 'Folder' column to Shared files window.
Prevent adding install/working dirs (\Webserver, \Db...) to Shared files.
+ some other minor changes/fixes.
@
text
@d30 1
d61 1
d70 1
a70 1
		data.sUrl = dlini.GetString(_T("URL"), _T(""));
d74 1
a74 1
		m_List.Add(data);
d83 1
a83 2
	return true;	// Later
/*	EMULE_TRY
d88 13
a100 2
	dlini.SetInt(_T("Count"), );
	EMULE_CATCH*/
d105 2
d108 1
a108 1
	if(m_List.GetCount() == 0)
d126 1
d142 1
a142 1
		for(int i = 0; i < pThis->m_List.GetCount(); i++)
d144 2
a145 2
			long lLastCheck = pThis->m_List[i].lLastCheck;
			if(lLastCheck == 0 || (time(NULL) - lLastCheck) >= static_cast<long>(pThis->m_List[i].ulInterval))
d147 4
a150 4
				ULONG ulMinInterval = pThis->CheckUrl(pThis->m_List[i].sUrl);
				if(ulMinInterval != 0 && ulMinInterval > pThis->m_List[i].ulInterval)
					pThis->m_List[i].ulInterval = ulMinInterval;
				pThis->m_List[i].lLastCheck = time(NULL);
d218 29
@


1.2
log
@AutoDL, second step - fully works, to do - add to prefs
@
text
@d130 1
a130 1
			if(lLastCheck == 0 || (time(NULL) - lLastCheck) >= pThis->m_List[i].ulInterval)
@


1.1
log
@AutoDL, first step
@
text
@d1 20
d122 2
d146 1
d148 20
a167 1
	XmlDoc spDoc = XmlLoadDocumentFromFile(sUrl);
d173 1
a173 1
			ULONG ulMinInterval = XmlGetAttributeLong(spRoot, _T("min_interval"), 0);
d176 4
a180 1
			return ulMinInterval;
d183 2
d186 1
a186 1
	return 0;
d188 15
@

