head	1.75;
access;
symbols
	PublicRelease_1_2e:1.74
	Interim_Release_1-2e_RC1:1.73
	PublicRelease_1_2d:1.73
	Interim_Release_1-2d_RC1:1.73
	Interim_Release_1-2d_beta1:1.73
	PublicRelease_1_2c:1.70
	Interim_Release_1-2c_RC1:1.70
	Interim_Release_1-2c_beta1:1.65
	PublicRelease_1_2b:1.65
	Interim_Release_1-2b_RC1:1.65
	PublicRelease_1_2a:1.65
	Interim_Release_1-2a_RC1:1.65
	Interim_Release_1-2a_beta2:1.64
	Interim_Release_1-2a_beta1:1.64
	PublicRelease_1_2:1.63
	Interim_Release_1-2_RC1:1.63
	Interim_Release_1-2_beta1:1.63
	PublicRelease_1_1g:1.62
	Interim_Release_1-1g_RC3:1.62
	Interim_Release_1-1g_RC2:1.62
	Interim_Release_1-1g_RC1:1.62
	Interim_Release_1-1g_beta2:1.60
	Interim_Release_1-1g_beta1:1.60
	PublicRelease_1_1f:1.59
	Interim_Release_1-1f_RC1:1.59
	PublicRelease_1_1e:1.59
	Interim_Release_1-1e_RC2:1.59
	Interim_Release_1-1e_RC1:1.59
	Interim_Release_1-1e_beta1:1.59
	PublicRelease_1_1d:1.59
	Interim_Release_1-1d_RC1:1.59
	PublicRelease_1_1c:1.58
	Interim_Release_1-1c_RC1:1.57
	Interim_Release_1-1c_beta2:1.57
	Interim_Release_1-1c_beta1:1.51
	PublicRelease_1_1b:1.51
	Interim_Release_1-1b_RC1:1.51
	PublicRelease_1_1a:1.51
	Interim_Release_1-1a_RC2:1.51
	Interim_Release_1-1a_RC1:1.51
	Interim_Release_1-1a_beta2:1.51
	Interim_Release_1-1a_beta1:1.51
	PublicRelease_1_1:1.50
	Interim_Release_1-1_beta1:1.50
	PublicRelease_1o:1.50
	Interim_Release_1o_RC1:1.50
	Interim_Release_1o_beta1:1.50
	PublicRelease_1n:1.50
	Interim_Release_1n_RC2:1.50
	Interim_Release_1n_RC1:1.50
	Interim_Release_1n_beta2:1.50
	Interim_Release_1n_beta1:1.50
	PublicRelease_1m:1.50
	Interim_Release_1m_beta1:1.50
	PublicRelease_1l:1.50
	Interim_Release_1l_RC3:1.50
	Interim_Release_1l_RC2:1.50
	Interim_Release_1l_RC1:1.49
	Interim_Release_1l_beta2:1.47
	Interim_Release_1l_beta1:1.39
	PublicRelease_1k:1.33
	Interim_Release_1k_RC4:1.33
	Interim_1k_RC3:1.33
	Interim_1k_RC2:1.33
	Interim_Release_1k_RC1:1.32
	Interim_Release_1k_beta5:1.32
	Intrerim_Release_1k_beta4:1.32
	Interim_Release_1k_beta1:1.31
	PublicRelease_1j:1.30
	Interim_Release_1J_RC3:1.29
	Interim_Release_1j_RC3:1.29
	Interim_Release_1j_RC2:1.29
	Interim_Release_1j_RC1:1.28
	Interim_Release_1j_beta2:1.28
	Interim_Release_1j_beta1:1.27
	PublicRelease_1i:1.27
	Interim_Release_1i_RC6:1.27
	Interim_Release_1i_RC3:1.27
	Interim_Release_1i_RC2:1.27
	Interim_Release_1i_RC1:1.27
	Interim_Release_1i_beta3:1.26
	Interim_Release_1i_beta2:1.24
	Interim_Release_1i_beta1:1.21
	PublicRelease_1h:1.20
	Interim_Release_1h_rc2:1.20
	Interim_Release_1h_RC1:1.20
	Interim_Release_1h_beta2:1.20
	Interim_Release_1h_beta1_now:1.20
	Interim_Release_1h_beta1:1.20
	PublicRelease_1g:1.19
	Interim_Release_1g_RC6_Final:1.19
	Interim_Release_1g_RC6:1.19
	Interim_Release_1g_RC5:1.19
	Interim_Release_1g_RC4:1.19
	Interim_Release_1g_RC3:1.19
	Interim_Release_1g_beta2:1.17
	Interim_Release_1g_beta1:1.10
	Interim_Release_1f_RC4:1.7
	Interim_Release_1f_RC3:1.7
	Interim_Release_1f_RC2:1.7
	Interim_Release_1f_RC:1.6
	Interim_Release_1f_beta2:1.6
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.5
	featurestest:1.5.0.8
	Interim_Release_1c_RC:1.5
	Interim_Release_1c_beta2:1.5
	Interim_Release_1c_beta1:1.5
	threaded_downloadqueue:1.5.0.6
	PublicRelease_1b:1.5
	Interim_Release_1b_beta2:1.5
	Interim_Release_1b_beta1:1.5
	proxydeadlake:1.5.0.4
	PublicRelease_1a:1.5
	Interim_Release_1a_beta2:1.5
	BerkeleyDb:1.5.0.2
	Interim_Release_1a_beta1:1.5
	PublicRelease_1:1.5
	goldfish:1.5
	eMulePlus_1_RC2:1.5
	eMulePlus_26b_1RC1:1.5
	PreRelease_26b_i0e:1.5
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.2
	Interim_Release_26b_i0c:1.2
	Interim_Release_26b_i0b:1.2
	Interim_Release_26b_i0a:1.2
	systraydlg:1.2.0.6
	plus26based:1.2.0.4
	Interim_Release_25b_i0b:1.2
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.1
	proxytest:1.2.2.1.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.75
date	2009.10.28.04.34.59;	author aw3;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.08.04.05.38;	author aw3;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.18.22.55.48;	author eklmn;	state Exp;
branches;
next	1.72;

1.72
date	2007.12.05.05.24.22;	author aw3;	state Exp;
branches;
next	1.71;

1.71
date	2007.11.22.20.46.02;	author eklmn;	state Exp;
branches;
next	1.70;

1.70
date	2007.07.14.20.34.57;	author aw3;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.08.22.31.19;	author kush_eplus;	state Exp;
branches;
next	1.68;

1.68
date	2007.07.01.05.27.45;	author aw3;	state Exp;
branches;
next	1.67;

1.67
date	2007.05.15.00.55.02;	author aw3;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.14.04.30.34;	author aw3;	state Exp;
branches;
next	1.65;

1.65
date	2006.09.09.01.11.15;	author aw3;	state Exp;
branches;
next	1.64;

1.64
date	2006.04.16.01.07.03;	author aw3;	state Exp;
branches;
next	1.63;

1.63
date	2006.01.06.20.05.56;	author kush_eplus;	state Exp;
branches;
next	1.62;

1.62
date	2005.11.27.22.11.52;	author eklmn;	state Exp;
branches;
next	1.61;

1.61
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.60;

1.60
date	2005.08.14.22.02.47;	author aw3;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.15.03.27.26;	author aw3;	state Exp;
branches;
next	1.58;

1.58
date	2005.02.26.10.45.58;	author kuchin;	state Exp;
branches;
next	1.57;

1.57
date	2005.02.16.04.57.05;	author aw3;	state Exp;
branches;
next	1.56;

1.56
date	2005.02.12.21.46.44;	author aw3;	state Exp;
branches;
next	1.55;

1.55
date	2005.02.12.00.42.57;	author aw3;	state Exp;
branches;
next	1.54;

1.54
date	2005.02.04.23.41.56;	author aw3;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.02.07.13.02;	author aw3;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.01.03.54.16;	author aw3;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.08.02.13.36;	author aw3;	state Exp;
branches;
next	1.50;

1.50
date	2004.05.27.14.12.40;	author katsyonak;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.25.01.22.36;	author katsyonak;	state Exp;
branches;
next	1.48;

1.48
date	2004.05.23.22.40.52;	author katsyonak;	state Exp;
branches;
next	1.47;

1.47
date	2004.05.18.21.07.56;	author katsyonak;	state Exp;
branches;
next	1.46;

1.46
date	2004.05.11.23.27.42;	author katsyonak;	state Exp;
branches;
next	1.45;

1.45
date	2004.05.11.14.03.21;	author katsyonak;	state Exp;
branches;
next	1.44;

1.44
date	2004.05.10.04.28.39;	author katsyonak;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.10.02.57.47;	author katsyonak;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.10.01.25.33;	author katsyonak;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.09.12.48.58;	author katsyonak;	state Exp;
branches;
next	1.40;

1.40
date	2004.05.07.04.56.18;	author aw3;	state Exp;
branches;
next	1.39;

1.39
date	2004.05.06.11.46.01;	author katsyonak;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.06.02.03.10;	author katsyonak;	state Exp;
branches;
next	1.37;

1.37
date	2004.05.06.01.56.09;	author katsyonak;	state Exp;
branches;
next	1.36;

1.36
date	2004.05.06.01.39.09;	author katsyonak;	state Exp;
branches;
next	1.35;

1.35
date	2004.04.26.06.14.45;	author katsyonak;	state Exp;
branches;
next	1.34;

1.34
date	2004.04.23.22.14.10;	author katsyonak;	state Exp;
branches;
next	1.33;

1.33
date	2004.03.31.22.26.56;	author dropf;	state Exp;
branches;
next	1.32;

1.32
date	2004.03.18.03.44.12;	author kush_eplus;	state Exp;
branches;
next	1.31;

1.31
date	2004.02.20.00.22.26;	author kush_eplus;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.24.20.13.46;	author dongato;	state Exp;
branches;
next	1.29;

1.29
date	2004.01.11.23.49.30;	author dongato;	state Exp;
branches;
next	1.28;

1.28
date	2004.01.01.06.00.27;	author dongato;	state Exp;
branches;
next	1.27;

1.27
date	2003.10.31.23.00.51;	author eklmn;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.31.06.47.00;	author eklmn;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.29.14.14.18;	author morevit;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.08.12.56.34;	author morevit;	state Exp;
branches;
next	1.23;

1.23
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.21;

1.21
date	2003.09.22.16.15.36;	author morevit;	state Exp;
branches;
next	1.20;

1.20
date	2003.07.30.22.56.00;	author zegzav;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.21.17.52.33;	author partyckip;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.14.18.08.22;	author partyckip;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.06.19.56.47;	author partyckip;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.05.19.57.17;	author partyckip;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.05.17.23.26;	author partyckip;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.05.05.51.21;	author partyckip;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.04.20.27.29;	author partyckip;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.03.19.37.51;	author partyckip;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.03.19.18.20;	author partyckip;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.31.16.45.18;	author partyckip;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.30.20.35.20;	author partyckip;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.29.19.01.46;	author partyckip;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.13.17.59.39;	author lord_kiron;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.08.16.22.20;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.17.19.17.24;	author dongato;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.16.22.01.52;	author lord_kiron;	state Exp;
branches;
next	1.2;

1.2
date	2003.01.24.22.07.53;	author maverick65;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.25;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.16.54.41;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.75
log
@Reduced H-file dependency.
@
text
@//this file is part of eMule
//Copyright (C)2002-2006 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "server.h"
#include "packets.h"
#include "opcodes.h"
#include "emule.h"
#include "ServerList.h"
#include "IP2Country.h"
#ifdef OLD_SOCKETS_ENABLED
#include "sockets.h"
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServer::CServer(ServerMet_Struct *pServerMet)
{
	m_uPort = pServerMet->m_uPort;
	m_uAuxPort = 0;
	m_dwIP = pServerMet->m_dwIP;
	ipstr(&m_strFullIP, m_dwIP);
	m_dwFiles = 0;
	m_dwNumUsers = 0;
	m_bytePreferences = PR_NORMAL;
	m_dwPingTime = 0;
	m_dwFailedCount = 0;
	lastpinged = 0;
	lastpingedtime = 0;
	lastdescpingedcount = 0;
	m_bIsStaticServerMember = false;
	m_dwMaxUsers=0;
	m_dwSoftMaxFiles = 0;
	m_dwHardMaxFiles = 0;
	m_dwTCPFlags = 0;
	m_dwUDPFlags = 0;
	m_dwDescReqChallenge = 0;
	m_dwLowIDUsers = 0;
	m_dwChallenge = 0;
	m_uServerCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwIP);
	m_dwServerKeyUDP = 0;
	m_bCryptPingReplyPending = false;
	m_dwIPServerKeyUDP = 0;
	m_uObfuscationPortTCP = 0;
	m_uObfuscationPortUDP = 0;
	m_dwRealLastPingedTime = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CServer::CServer(uint16 uPort, const CString &strAddr)
{
	m_uPort = uPort;
	m_uAuxPort = 0;
	if ((m_dwIP = inet_addr(strAddr)) == INADDR_NONE)
	{
		m_strDynIP = strAddr;
		m_dwIP = 0;
	}
	else
		m_strDynIP = _T("");
	ipstr(&m_strFullIP, m_dwIP);
	m_dwFiles = 0;
	m_dwNumUsers = 0;
	m_bytePreferences = PR_NORMAL;
	m_dwPingTime = 0;
	m_dwFailedCount = 0;
	lastpinged = 0;
	lastpingedtime = 0;
	lastdescpingedcount = 0;
	m_bIsStaticServerMember = false;
	m_dwMaxUsers=0;
	m_dwSoftMaxFiles = 0;
	m_dwHardMaxFiles = 0;
	m_dwTCPFlags = 0;
	m_dwUDPFlags = 0;
	m_dwDescReqChallenge = 0;
	m_dwLowIDUsers = 0;
	m_dwChallenge = 0;
	m_uServerCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwIP);
	m_dwServerKeyUDP = 0;
	m_bCryptPingReplyPending = false;
	m_dwIPServerKeyUDP = 0;
	m_uObfuscationPortTCP = 0;
	m_uObfuscationPortUDP = 0;
	m_dwRealLastPingedTime = 0;
}

CServer::CServer(const CServer *pOld)
{
	m_uPort = pOld->m_uPort;
	m_uAuxPort = pOld->m_uAuxPort;
	m_dwIP = pOld->m_dwIP;
	m_bIsStaticServerMember = pOld->IsStaticMember();
	m_strFullIP = pOld->m_strFullIP;
	m_dwFiles = pOld->m_dwFiles;
	m_dwNumUsers = pOld->m_dwNumUsers;
	m_bytePreferences = pOld->m_bytePreferences;
	m_dwPingTime = pOld->m_dwPingTime;
	m_dwFailedCount = pOld->m_dwFailedCount;
	lastpinged = pOld->lastpinged;
	lastpingedtime = pOld->lastpinged;
	lastdescpingedcount = pOld->lastdescpingedcount;
	m_dwMaxUsers = pOld->m_dwMaxUsers;
	m_strDescription = pOld->m_strDescription;
	m_strListName = pOld->m_strListName;
	m_strDynIP = pOld->m_strDynIP;
	m_dwSoftMaxFiles = pOld->m_dwSoftMaxFiles;
	m_dwHardMaxFiles = pOld->m_dwHardMaxFiles;
	m_strVersion = pOld->m_strVersion;
	m_dwTCPFlags = pOld->m_dwTCPFlags;
	m_dwUDPFlags = pOld->m_dwUDPFlags;
	m_dwDescReqChallenge = pOld->m_dwDescReqChallenge;
	m_dwLowIDUsers = pOld->m_dwLowIDUsers;
	m_dwChallenge = pOld->m_dwChallenge;
	m_uServerCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwIP);
	m_dwServerKeyUDP = pOld->m_dwServerKeyUDP;
	m_bCryptPingReplyPending = pOld->m_bCryptPingReplyPending;
	m_dwIPServerKeyUDP = pOld->m_dwIPServerKeyUDP;
	m_uObfuscationPortTCP = pOld->m_uObfuscationPortTCP;
	m_uObfuscationPortUDP = pOld->m_uObfuscationPortUDP;
	m_dwRealLastPingedTime = pOld->m_dwRealLastPingedTime;
}

CServer::~CServer()
{
}

bool CServer::AddTagFromFile(CFile &servermet)
{
	CTag	SrvTag;

	SrvTag.FillFromStream(servermet);
	switch (SrvTag.GetTagID())
	{
		case ST_SERVERNAME:
			if (SrvTag.IsStr())
			{
#ifdef _UNICODE
				if (!m_strListName.IsEmpty())
					break;
#endif
				SrvTag.GetStringValue(&m_strListName);
				m_strListName.Remove(_T('\b'));
				m_strListName.Remove(_T('\r'));
				m_strListName.Remove(_T('\t'));
				m_strListName.Trim();
			}
			break;
		case ST_DESCRIPTION:
			if (SrvTag.IsStr())
			{
#ifdef _UNICODE
				if (!m_strDescription.IsEmpty())
					break;
#endif
				SrvTag.GetStringValue(&m_strDescription);
				m_strDescription.Remove(_T('\b'));
				m_strDescription.Remove(_T('\r'));
				m_strDescription.Remove(_T('\t'));
				m_strDescription.Trim();
			}
			break;
		case ST_PREFERENCE:
		//	Import server preferences and translate it (for faster sorting)
			if (SrvTag.IsInt())
				m_bytePreferences = static_cast<byte>(ed2k2eMule(SrvTag.GetIntValue()));
			break;
		case ST_PING:
			if (SrvTag.IsInt())
				m_dwPingTime = SrvTag.GetIntValue();
			break;
		case ST_DYNIP:
			if (SrvTag.IsStr() && !SrvTag.IsStringValueEmpty())
			{
#ifdef _UNICODE
				if (!m_strDynIP.IsEmpty())
					break;
#endif
			//	Set dynIP and reset available (out-dated) IP
				SrvTag.GetStringValue(&m_strDynIP);
				SetIP(0);
			}
			break;
		case ST_FAIL:
			if (SrvTag.IsInt())
				m_dwFailedCount = SrvTag.GetIntValue();
			break;
		case ST_LASTPING:
			if (SrvTag.IsInt())
				m_dwRealLastPingedTime = lastpingedtime = SrvTag.GetIntValue();
			break;
		case ST_MAXUSERS:
			if (SrvTag.IsInt())
				m_dwMaxUsers = SrvTag.GetIntValue();
			break;
		case ST_SOFTFILES:
			if (SrvTag.IsInt())
				m_dwSoftMaxFiles = SrvTag.GetIntValue();
			break;
		case ST_HARDFILES:
			if (SrvTag.IsInt())
				m_dwHardMaxFiles = SrvTag.GetIntValue();
			break;
		case ST_VERSION:
			if (SrvTag.IsStr())
				SrvTag.GetStringValue(&m_strVersion);
			else if (SrvTag.IsInt())
				m_strVersion.Format(_T("%u.%02u"), SrvTag.GetIntValue() >> 16, SrvTag.GetIntValue() & 0xFFFF);
			break;
		case ST_UDPFLAGS:
			if (SrvTag.IsInt())
				m_dwUDPFlags = SrvTag.GetIntValue();
			break;
		case ST_LOWIDUSERS:
			if (SrvTag.IsInt())
				m_dwLowIDUsers = SrvTag.GetIntValue();
			break;
		case ST_UDPKEY:
			if (SrvTag.IsInt())
				m_dwServerKeyUDP = SrvTag.GetIntValue();
			break;
		case ST_UDPKEYIP:
			if (SrvTag.IsInt())
				m_dwIPServerKeyUDP = SrvTag.GetIntValue();
			break;
		case ST_TCPPORTOBFUSCATION:
			if (SrvTag.IsInt() && (SrvTag.GetIntValue() <= 0xFFFF))
				m_uObfuscationPortTCP = static_cast<uint16>(SrvTag.GetIntValue());
			break;
		case ST_UDPPORTOBFUSCATION:
			if (SrvTag.IsInt() && (SrvTag.GetIntValue() <= 0xFFFF))
				m_uObfuscationPortUDP = static_cast<uint16>(SrvTag.GetIntValue());
			break;
		default:
			if (SrvTag.GetTagName() == NULL)
				break;
			if (CmpED2KTagName(SrvTag.GetTagName(), "files") == 0)
			{
				if (SrvTag.IsInt())
					m_dwFiles = SrvTag.GetIntValue();
			}
			else if (CmpED2KTagName(SrvTag.GetTagName(), "users") == 0)
			{
				if (SrvTag.IsInt())
					m_dwNumUsers = SrvTag.GetIntValue();
			}
			else if (CmpED2KTagName(SrvTag.GetTagName(), "AuxPort") == 0)
			{
				if (SrvTag.IsInt())
					m_uAuxPort = static_cast<uint16>(SrvTag.GetIntValue());
			}
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const CString& CServer::GetAddress() const
{
	if (!m_strDynIP.IsEmpty())
		return m_strDynIP;
	else
		return m_strFullIP;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	SetIP() sets new IP address of the server
void CServer::SetIP(uint32 dwNewIP)
{
	ipstr(&m_strFullIP, m_dwIP = dwNewIP);
	m_uServerCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwIP);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CServer::HasSameAddress(const CServer& server, bool bCheckPort /*= true*/) const
{
	if ((m_dwIP == server.m_dwIP) && (!bCheckPort || m_uPort == server.m_uPort || m_uPort == 0 || server.m_uPort == 0))
	{
		if (m_dwIP != 0)
			return true;
		else if (m_strDynIP == server.m_strDynIP)
			return true;
	}
	return false;
}

/**
 * convert eDonkey pref values to eMule pref values
 * The correct server preferences (as used by eDonkey) are: Low=2, Normal=0, High=1
 * @@param dwSrvPref preference as found in server.met
 * @@return preference as used in eMule
 */
uint32 CServer::ed2k2eMule(uint32 dwSrvPref)
{
	return (++dwSrvPref > PR_HIGH) ? PR_LOW : dwSrvPref;
}

/**
 * convert eMule pref values to eDonkey pref values
 * The correct server preferences (as used by eDonkey) are: Low=2, Normal=0, High=1
 * @@param dwSrvPref preference as found in eMule
 * @@return preference as used in server.met
 */
uint32 CServer::eMule2ed2k(uint32 dwSrvPref)
{
	return (--dwSrvPref > SRV_PR_HIGH) ? SRV_PR_LOW : dwSrvPref;
}

bool CServer::HasPublicAddress() const
{
	in_addr host;

	host.S_un.S_addr = m_dwIP;

	int b1 = host.S_un.S_un_b.s_b1;
	int b2 = host.S_un.S_un_b.s_b2;

	if (b1 == 172 && (b2 >= 16 && b2 <= 31))
		return false;

#ifndef _DEBUG	// Let connect to local addresses (192.168.xx.xx) in debug
	if (b1 == 192 && b2 == 168)
		return false;
#endif //_DEBUG

	if (b1 == 0 || b1 == 10 || b1 == 127 || GetPort() == 0)
		return false;

	return true;
}

CString CServer::GetCountryName() const
{
	return g_App.m_pIP2Country->GetCountryNameByIndex(m_uServerCountryIdx);
}

void CServer::ResetIP2Country()
{
	m_uServerCountryIdx = g_App.m_pIP2Country->GetCountryFromIP(m_dwIP);
}

uint32 CServer::GetServerKeyUDP() const
{
	if ((m_dwIPServerKeyUDP != 0) && (m_dwIPServerKeyUDP == g_App.GetPublicIP()))
		return m_dwServerKeyUDP;
	else
		return 0;
}

void CServer::SetServerKeyUDP(uint32 dwServerKeyUDP)
{
	m_dwServerKeyUDP = dwServerKeyUDP;
	m_dwIPServerKeyUDP = g_App.GetPublicIP();
}

HICON CServer::GetServerInfo4Tooltips(CString &strInfo)
{
	EMULE_TRY

	if (this == NULL)
		return (HICON)NULL;

	CString		strServerCountry, strServerName = GetListName(), strServerDescription = GetDescription();
	CString		strUsers, strLastPing;
	int			iImageIndex = 0;
	CServer		*pCurServer;

	strServerName.Replace(_T("<"), _T("<<"));
	strServerName.Replace(_T("\n"), _T("<br>"));
	strServerDescription.Replace(_T("<"), _T("<<"));
	strServerDescription.Replace(_T("\n"), _T("<br>"));
	if (g_App.m_pIP2Country->ShowCountryFlag())
		strServerCountry.Format(_T(" (<b>%s</b>)"), GetCountryName());
	strInfo.Format(_T("<t=1><b>%s</b><br><t=1><b>%s</b><br><hr=100%%>"), strServerName, strServerDescription);
	if (!GetVersion().IsEmpty())
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_SERVER_VERSION), GetVersion());
	strUsers.Format(_T("%s (%s)"), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()));
	if (m_dwLowIDUsers != 0)
		strUsers.AppendFormat(_T("; <b>%s:</b> %s"), GetResString(IDS_LOWID), CastItoThousands(m_dwLowIDUsers));
	if (m_dwRealLastPingedTime == 0)
		GetResString(&strLastPing, IDS_NEVER);
	else
	{
		SYSTEMTIME		st;

		CTime(m_dwRealLastPingedTime).GetAsSystemTime(st);
		strLastPing = COleDateTime(st).Format(_T("%c"));
	}

	strInfo.AppendFormat( _T("<br><b>%s</b><t>%s:%u%s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%s - %s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%u<br><b>%s:</b><t>%s<br><hr=100%%><br><b>%s:</b><t>%#x"),
		GetResString(IDS_CD_UIP), GetFullIP(), GetPort(), strServerCountry,
		GetResString(IDS_FILES), CastItoThousands(GetFiles()),
		GetResString(IDS_SHAREDFILES), CastItoThousands(GetSoftMaxFiles()), CastItoThousands(GetHardMaxFiles()),
		GetResString(IDS_UUSERS), strUsers,
		GetResString(IDS_PING), GetPing(), GetResString(IDS_LASTPING), strLastPing,
		GetResString(IDS_TT_SRV_UDP1), GetUDPFlags() );

	if ( g_App.m_pServerConnect->IsConnected()
		&& (pCurServer = g_App.m_pServerConnect->GetCurrentServer()) != NULL
		&& pCurServer->GetPort() == GetPort()
		&& _tcsicmp(pCurServer->GetAddress(), GetAddress()) == 0 )
	{
		iImageIndex = (GetFailedCount() == 0) ? 2 : 4;
		strInfo.AppendFormat( _T("<br><b>%s:</b><t>%s<br><b>%s:</b><t>%s"),
			GetResString(IDS_TT_SRV_TCP), YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION),
			GetResString(IDS_OBFUSCATION), GetResString((g_App.m_pServerConnect->IsConnectedObfuscated()) ? IDS_ST_ACTIVE : IDS_ST_INACTIVE) );
	}
	else if (GetFailedCount() > 0)
		iImageIndex = 6;

	if (IsStaticMember())
		iImageIndex++;

	return g_App.m_pMDlg->m_wndServer.m_ctlServerList.m_imageList.ExtractIcon(iImageIndex);

	EMULE_CATCH

	return (HICON)NULL;
}

CString CServer::GetUsersInfo4Tooltips()
{
	EMULE_TRY

	if (this == NULL)
		return _T("");

	CString		strInfo, strMyName = g_App.m_pPrefs->GetUserNick(), strMyID;
	uint32		iTotalUsers = 0, iTotalFiles = 0;

	strMyName.Trim();
	strMyName.Replace(_T("\n"), _T("<br>"));
	strMyName.Replace(_T("<"), _T("<<"));
	strMyID = GetResString((g_App.m_pServerConnect->IsLowID()) ? IDS_PRIOLOW : IDS_PRIOHIGH);
	g_App.m_pServerList->GetUserFileStatus(iTotalUsers, iTotalFiles);

	strInfo.Format(_T("<t=1><b>%s</b><br><t=1>%s: %u (<b>%s</b>)<br><hr=100%%><br><b>%s:<t></b>%s (%s)<br><b>%s:<t></b>%s (%s)"),
		strMyName, GetResString(IDS_USERID), g_App.m_pServerConnect->GetClientID(), strMyID,
		GetResString(IDS_UUSERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()),
		GetResString(IDS_FILES), CastItoThousands(GetFiles()), CastItoThousands(iTotalFiles));

	return strInfo;

	EMULE_CATCH

	return _T("");
}
@


1.74
log
@Reduced H-file dependency.
@
text
@d25 3
@


1.73
log
@improved string processing
@
text
@d23 1
@


1.72
log
@Corrected Unicode downgrade capability; Suppressed compiler warning.
@
text
@d270 1
a270 1
CString CServer::GetAddress() const
@


1.71
log
@1) unicode preparation 2) variable rename
@
text
@d152 1
a152 1
#ifdef _UNICODE 
d155 1
a155 1
#endif			
d166 1
a166 1
#ifdef _UNICODE 
d169 1
a169 1
#endif			
d180 1
a180 1
				m_bytePreferences = ed2k2eMule(SrvTag.GetIntValue());
d189 7
a195 6
				if (m_strDynIP.IsEmpty())
				{
				//	Set dynIP and reset available (out-dated) IP
					SrvTag.GetStringValue(&m_strDynIP);
					SetIP(0);
				}
@


1.70
log
@Encryption preparations.
@
text
@d118 1
a118 1
	description = pOld->description;
d152 4
d166 9
a174 5
				SrvTag.GetStringValue(&description);
				description.Remove(_T('\b'));
				description.Remove(_T('\r'));
				description.Remove(_T('\t'));
				description.Trim();
@


1.69
log
@fix time disappearing at midnight
@
text
@d345 1
a345 2
#if 0	//!_CRYPT_READY
	if (m_dwIPServerKeyUDP != 0 && m_dwIPServerKeyUDP == theApp.GetPublicIP())
a348 3
#else
	return m_dwServerKeyUDP;
#endif
d354 1
a354 3
#if 0	//!_CRYPT_READY
	m_dwIPServerKeyUDP = theApp.GetPublicIP();
#endif
d405 3
a407 1
		strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_TT_SRV_TCP), YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION));
@


1.68
log
@Simplified interface -- pointer instead of a reference.
@
text
@d394 1
a394 1
		strLastPing = COleDateTime(st).Format();
@


1.67
log
@Corrected issues introduced by recent integration -- last ping time was incorrect in tooltips.
@
text
@d102 1
a102 1
CServer::CServer(const CServer& pOld)
d104 25
a128 25
	m_uPort = pOld.m_uPort;
	m_uAuxPort = pOld.m_uAuxPort;
	m_dwIP = pOld.m_dwIP;
	m_bIsStaticServerMember = pOld.IsStaticMember();
	m_strFullIP = pOld.m_strFullIP;
	m_dwFiles = pOld.m_dwFiles;
	m_dwNumUsers = pOld.m_dwNumUsers;
	m_bytePreferences = pOld.m_bytePreferences;
	m_dwPingTime = pOld.m_dwPingTime;
	m_dwFailedCount = pOld.m_dwFailedCount;
	lastpinged = pOld.lastpinged;
	lastpingedtime = pOld.lastpinged;
	lastdescpingedcount = pOld.lastdescpingedcount;
	m_dwMaxUsers = pOld.m_dwMaxUsers;
	description = pOld.description;
	m_strListName = pOld.m_strListName;
	m_strDynIP = pOld.m_strDynIP;
	m_dwSoftMaxFiles = pOld.m_dwSoftMaxFiles;
	m_dwHardMaxFiles = pOld.m_dwHardMaxFiles;
	m_strVersion = pOld.m_strVersion;
	m_dwTCPFlags = pOld.m_dwTCPFlags;
	m_dwUDPFlags = pOld.m_dwUDPFlags;
	m_dwDescReqChallenge = pOld.m_dwDescReqChallenge;
	m_dwLowIDUsers = pOld.m_dwLowIDUsers;
	m_dwChallenge = pOld.m_dwChallenge;
d130 6
a135 6
	m_dwServerKeyUDP = pOld.m_dwServerKeyUDP;
	m_bCryptPingReplyPending = pOld.m_bCryptPingReplyPending;
	m_dwIPServerKeyUDP = pOld.m_dwIPServerKeyUDP;
	m_uObfuscationPortTCP = pOld.m_uObfuscationPortTCP;
	m_uObfuscationPortUDP = pOld.m_uObfuscationPortUDP;
	m_dwRealLastPingedTime = pOld.m_dwRealLastPingedTime;
@


1.66
log
@Encryption preparations; Minor correction to load DynIP server name (from original);
Added leading zero while initial formatting of the decimal part of server version (original).
@
text
@d195 1
a195 1
				lastpingedtime = SrvTag.GetIntValue();
d387 1
a387 1
	if (lastpingedtime == 0)
d393 1
a393 1
		CTime(lastpingedtime).GetAsSystemTime(st);
@


1.65
log
@Show server UDP capabilities in the server list tooltips
(instead of detailed explanation of too old server features).
@
text
@d2 1
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
d20 1
d56 6
d94 6
a101 1
// copy constructor
d130 6
d147 1
a147 1
	switch(SrvTag.GetTagID())
d179 9
a187 2
			if (SrvTag.IsStr())
				SrvTag.GetStringValue(&m_strDynIP);
d213 1
a213 1
				m_strVersion.Format(_T("%u.%u"), SrvTag.GetIntValue() >> 16, SrvTag.GetIntValue() & 0xFFFF);
d223 16
d269 2
a270 2
//	SetID() sets the IP address of the Server to 'iNewIP'
void CServer::SetID(uint32 iNewIP)
d272 1
a272 1
	ipstr(&m_strFullIP, m_dwIP = iNewIP);
d343 20
d452 1
a452 1
}@


1.64
log
@Unicode preparations.
@
text
@d336 1
a336 1
	strInfo.AppendFormat(_T("<br><b>%s</b><t>%s:%u%s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%s - %s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%u<br><b>%s:</b><t>%s<br><hr=100%%>"),
d341 2
a342 1
		GetResString(IDS_PING), GetPing(), GetResString(IDS_LASTPING), strLastPing);
a357 4
	strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s<br><b>%s:</b><t>%s"),
		GetResString(IDS_TT_SRV_UDP1), YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES),
		GetResString(IDS_TT_SRV_UDP2), YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETFILES));

@


1.63
log
@UNICODE preparation (first shot)
@
text
@d36 1
a36 5

	in_addr		host;

	host.S_un.S_addr = m_dwIP;
	m_strFullIP = inet_ntoa(host);
d68 1
a68 4
	in_addr host;

	host.S_un.S_addr = m_dwIP;
	m_strFullIP = inet_ntoa(host);
d228 1
a228 1
//	SetID() sets the IP address of the Server to 'iNewIP'.
d231 1
a231 7
	m_dwIP = iNewIP;

//	Stringify the numerical IP using "." notation
	in_addr		host;

	host.S_un.S_addr = m_dwIP;
	m_strFullIP = inet_ntoa(host);
@


1.62
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d61 1
a61 1
CServer::CServer(uint16 in_port, const CString& i_addr)
d63 1
a63 1
	m_uPort = in_port;
d65 1
a65 1
	if (inet_addr(i_addr) == INADDR_NONE)
d67 1
a67 1
		m_strDynIP = i_addr;
a70 2
	{
		m_dwIP = inet_addr(i_addr);
a71 1
	}
d356 1
a356 1
	if (g_App.m_pServerConnect->IsConnected()
d359 1
a359 1
		&& stricmp(pCurServer->GetAddress(), GetAddress()) == 0)
@


1.61
log
@renamed 3 variables
@
text
@d391 1
a391 1
	CString		strInfo, strMyName = g_App.g_pPrefs->GetUserNick(), strMyID;
@


1.60
log
@Compacted code to display time.
@
text
@d58 1
a58 1
	m_uServerCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d96 1
a96 1
	m_uServerCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d127 1
a127 1
	m_uServerCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d248 1
a248 1
	m_uServerCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d310 1
a310 1
	return g_eMuleApp.m_pIP2Country->GetCountryNameByIndex(m_uServerCountryIdx);
d315 1
a315 1
	m_uServerCountryIdx = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d334 1
a334 1
	if (g_eMuleApp.m_pIP2Country->ShowCountryFlag())
d359 2
a360 2
	if (g_eMuleApp.m_pServerConnect->IsConnected()
		&& (pCurServer = g_eMuleApp.m_pServerConnect->GetCurrentServer()) != NULL
d377 1
a377 1
	return g_eMuleApp.m_pdlgEmule->m_wndServer.m_ctlServerList.m_imageList.ExtractIcon(iImageIndex);
d391 1
a391 1
	CString		strInfo, strMyName = g_eMuleApp.m_pGlobPrefs->GetUserNick(), strMyID;
d397 2
a398 2
	strMyID = GetResString((g_eMuleApp.m_pServerConnect->IsLowID()) ? IDS_PRIOLOW : IDS_PRIOHIGH);
	g_eMuleApp.m_pServerList->GetUserFileStatus(iTotalUsers, iTotalFiles);
d401 1
a401 1
		strMyName, GetResString(IDS_USERID), g_eMuleApp.m_pServerConnect->GetClientID(), strMyID,
@


1.59
log
@Corrected initialization of some server parameters.
@
text
@a345 1
		CTime			ctTime(lastpingedtime);
d348 2
a349 5
		ctTime.GetAsSystemTime(st);

		COleDateTime    odtTime(st);

		strLastPing = odtTime.Format();
@


1.58
log
@Allow to connect to 192.168.xx.xx servers in debug configuration,
AutoDL - do not add already downloaded/downloading files
@
text
@d55 1
d57 1
d93 1
d95 1
d124 1
d126 1
@


1.57
log
@Changed tag interface to avoid memory leaks which could be possible with
new tag object structure.
@
text
@d291 1
d294 1
@


1.56
log
@Faster loading and saving of configuration files.
@
text
@d130 1
a130 1
	CTag *pServerTag = new CTag(servermet);
d132 2
a133 1
	switch(pServerTag->GetTagID())
d136 1
a136 1
			if (pServerTag->IsStr())
d138 1
a138 1
				pServerTag->GetStringValue(&m_strListName);
d146 1
a146 1
			if (pServerTag->IsStr())
d148 1
a148 1
				pServerTag->GetStringValue(&description);
d157 2
a158 2
			if (pServerTag->IsInt())
				m_bytePreferences = ed2k2eMule(pServerTag->GetIntValue());
d161 2
a162 2
			if (pServerTag->IsInt())
				m_dwPingTime = pServerTag->GetIntValue();
d165 2
a166 2
			if (pServerTag->IsStr())
				pServerTag->GetStringValue(&m_strDynIP);
d169 2
a170 2
			if (pServerTag->IsInt())
				m_dwFailedCount = pServerTag->GetIntValue();
d173 2
a174 2
			if (pServerTag->IsInt())
				lastpingedtime = pServerTag->GetIntValue();
d177 2
a178 2
			if (pServerTag->IsInt())
				m_dwMaxUsers = pServerTag->GetIntValue();
d181 2
a182 2
			if (pServerTag->IsInt())
				m_dwSoftMaxFiles = pServerTag->GetIntValue();
d185 2
a186 2
			if (pServerTag->IsInt())
				m_dwHardMaxFiles = pServerTag->GetIntValue();
d189 4
a192 4
			if (pServerTag->IsStr())
				pServerTag->GetStringValue(&m_strVersion);
			else if (pServerTag->IsInt())
				m_strVersion.Format(_T("%u.%u"), pServerTag->GetIntValue() >> 16, pServerTag->GetIntValue() & 0xFFFF);
d195 2
a196 2
			if (pServerTag->IsInt())
				m_dwUDPFlags = pServerTag->GetIntValue();
d199 2
a200 2
			if (pServerTag->IsInt())
				m_dwLowIDUsers = pServerTag->GetIntValue();
d203 1
a203 1
			if (pServerTag->GetTagName() == NULL)
d205 1
a205 1
			if (CmpED2KTagName(pServerTag->GetTagName(), "files") == 0)
d207 2
a208 2
				if (pServerTag->IsInt())
					m_dwFiles = pServerTag->GetIntValue();
d210 1
a210 1
			else if (CmpED2KTagName(pServerTag->GetTagName(), "users") == 0)
d212 2
a213 2
				if (pServerTag->IsInt())
					m_dwNumUsers = pServerTag->GetIntValue();
d215 1
a215 1
			else if (CmpED2KTagName(pServerTag->GetTagName(), "AuxPort") == 0)
d217 2
a218 2
				if (pServerTag->IsInt())
					m_uAuxPort = static_cast<uint16>(pServerTag->GetIntValue());
a220 1
	delete pServerTag;
@


1.55
log
@Better way (robust) to process unknown tags.
@
text
@d128 1
a128 1
bool CServer::AddTagFromFile(CSafeFile& servermet)
@


1.54
log
@Optimized parameter tag processing (preparation and parsing).
@
text
@d202 2
@


1.53
log
@Server LowID users statistics; Show last ping time in server tooltips;
Fixed some server priority (server.met) incompatibility with the original eMule;
Removed unrequired variables; Sequent tag processing preparations.
@
text
@d130 1
a130 1
	CServerTag *pServerTag = new CServerTag(servermet);
d137 1
a137 1
				m_strListName = pServerTag->GetStringValue();
d147 1
a147 1
				description = pServerTag->GetStringValue();
d165 1
a165 1
				m_strDynIP = pServerTag->GetStringValue();
d189 1
a189 1
				m_strVersion = pServerTag->GetStringValue();
d202 1
a202 1
			if (pServerTag->GetTagName() == _T("files"))
d207 1
a207 1
			else if (pServerTag->GetTagName() == _T("users"))
d212 1
a212 1
			else if (pServerTag->GetTagName() == _T("AuxPort"))
a234 1
//
@


1.52
log
@Preparations and minor corrections for new tag processing; Removed unused code.
@
text
@a34 1
	m_dwTagCount = 0;
d43 1
a43 1
	m_ePreferences = SERVERPRIORITY_LOW;
d55 1
a62 1
	m_dwTagCount = 0;
d79 1
a79 1
	m_ePreferences = SERVERPRIORITY_LOW;
d91 1
a101 1
	m_dwTagCount = pOld.m_dwTagCount;
d105 1
a105 1
	m_ePreferences = pOld.m_ePreferences;
d120 1
d135 8
a142 5
			m_strListName = pServerTag->GetStringValue();
			m_strListName.Remove(_T('\b'));
			m_strListName.Remove(_T('\r'));
			m_strListName.Remove(_T('\t'));
			m_strListName.Trim();
d145 8
a152 5
			description = pServerTag->GetStringValue();
			description.Remove(_T('\b'));
			description.Remove(_T('\r'));
			description.Remove(_T('\t'));
			description.Trim();
d155 3
a157 2
			// Modified by Tarod [thx Hein] - import server preferences and translate it
			m_ePreferences = (EnumServerPriority)ed2k2eMule(pServerTag->GetIntValue());
d160 2
a161 1
			m_dwPingTime = pServerTag->GetIntValue();
d164 2
a165 1
			m_strDynIP = pServerTag->GetStringValue();
d168 2
a169 1
			m_dwFailedCount = pServerTag->GetIntValue();
d172 2
a173 1
			lastpingedtime = pServerTag->GetIntValue();
d176 2
a177 1
			m_dwMaxUsers = pServerTag->GetIntValue();
d180 2
a181 1
			m_dwSoftMaxFiles = pServerTag->GetIntValue();
d184 2
a185 1
			m_dwHardMaxFiles = pServerTag->GetIntValue();
d190 2
d197 4
d204 2
a205 1
				m_dwFiles = pServerTag->GetIntValue();
d209 2
a210 1
				m_dwNumUsers = pServerTag->GetIntValue();
d214 2
a215 1
				m_uAuxPort = static_cast<uint16>(pServerTag->GetIntValue());
d259 1
a259 1
 * @@param srvPref preference as found in server.met
d262 1
a262 1
uint32 CServer::ed2k2eMule(uint32 srvPref)
d264 1
a264 19
	uint32 mPref;

	switch (srvPref)
	{
	case 0:
		mPref = PR_NORMAL;
		break;
	case 1:
		mPref = PR_HIGH;
		break;
	case 2:
		mPref = PR_LOW;
		break;
	default:
		mPref = PR_LOW;
		break;
	}

	return mPref;
d270 1
a270 1
 * @@param srvPref preference as found in eMule
d273 1
a273 1
uint32 CServer::eMule2ed2k(uint32 srvPref)
d275 1
a275 19
	uint32 dPref;

	switch (srvPref)
	{
	case PR_NORMAL:
		dPref = 0;
		break;
	case PR_HIGH:
		dPref = 1;
		break;
	case PR_LOW:
		dPref = 2;
		break;
	default:
		dPref = 2;
		break;
	}

	return dPref;
d317 1
d330 13
d344 4
a347 1
	strInfo.AppendFormat(_T("<br><b>%s</b><t>%s:%u%s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%s - %s<br><b>%s:</b><t>%s (%s)<br><b>%s:</b><t>%u<br><hr=100%%>"),
d351 2
a352 2
		GetResString(IDS_UUSERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()),
		GetResString(IDS_PING), GetPing());
d359 2
a360 2
			(GetFailedCount() == 0) ? iImageIndex = 2 : iImageIndex = 4;
			strInfo.AppendFormat(_T("<br><b>%s:</b><t>%s"), GetResString(IDS_TT_SRV_TCP), YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION));
@


1.51
log
@Updated tag types.
@
text
@a97 4
	for (POSITION pos = pOld.m_tagList.GetHeadPosition(); pos != NULL;)
	{
		m_tagList.AddTail(new CServerTag(*pOld.m_tagList.GetNext(pos)));
	}
a125 3
	for (POSITION pos = m_tagList.GetHeadPosition(); pos != NULL;)
		delete m_tagList.GetNext(pos);
	m_tagList.RemoveAll();
d132 1
a132 1
	switch(pServerTag->GetSpecialTag())
a139 1
			delete pServerTag;
a146 1
			delete pServerTag;
a150 1
			delete pServerTag;
a153 1
			delete pServerTag;
a156 1
			delete pServerTag;
a159 1
			delete pServerTag;
a162 1
			delete pServerTag;
a165 1
			delete pServerTag;
a168 1
			delete pServerTag;
a171 1
			delete pServerTag;
d174 2
a175 3
			if (pServerTag->GetType() == TAGTYPE_STRING)
			m_strVersion = pServerTag->GetStringValue();
			delete pServerTag;
d178 2
a179 3
			if (pServerTag->GetType() == TAGTYPE_UINT32)
			m_dwUDPFlags = pServerTag->GetIntValue();
			delete pServerTag;
d182 1
a182 6
			if (pServerTag->GetSpecialTag())
			{
				pServerTag->SetTagName(_T("Unknown"));
				AddTag(pServerTag);
			}
			else if (pServerTag->GetTagName() == _T("files"))
a184 1
				delete pServerTag;
a188 1
				delete pServerTag;
a192 1
				delete pServerTag;
a193 2
			else
				AddTag(pServerTag);
d195 1
a197 47

void CServer::FillWindowTags(CTreeCtrl* wnd,HTREEITEM rootitem)
{
	POSITION pos;
	CString buffer;

	if (!description.IsEmpty())
	{
		buffer.Format(GetResString(IDS_DESC),description);
		wnd->InsertItem(buffer,-1,-1,rootitem);
	}
	buffer.Format(GetResString(IDS_IP)+_T(": %s"),m_strFullIP);
	wnd->InsertItem(buffer,-1,-1,rootitem);
	buffer.Format(GetResString(IDS_PORT)+_T(": %i"),m_uPort);
	wnd->InsertItem(buffer,-1,-1,rootitem);
	if (m_dwPingTime)
	{
		buffer.Format(GetResString(IDS_PING)+_T(": %i"),m_dwPingTime);
		wnd->InsertItem(buffer,-1,-1,rootitem);
	}
	if (m_dwNumUsers)
	{
		buffer.Format(GetResString(IDS_USERS),m_dwNumUsers);
		wnd->InsertItem(buffer,-1,-1,rootitem);
	}
	if (m_dwFiles)
	{
		buffer.Format(GetResString(IDS_FILES)+_T(": %i"),m_dwFiles);
		wnd->InsertItem(buffer,-1,-1,rootitem);
	}
	CServerTag *pCurServerTag;

	for(int i = 0; i != m_tagList.GetCount();i++)
	{
		pos = m_tagList.FindIndex(i);
		pCurServerTag = m_tagList.GetAt(pos);
		if (pCurServerTag->GetSpecialTag())
			continue;
		if (pCurServerTag->GetType() == 2)
			buffer.Format(_T("%s: %s"),pCurServerTag->GetTagName(),pCurServerTag->GetStringValue());
		else if (pCurServerTag->GetType() == 3)
			buffer.Format(_T("%s: %i"),pCurServerTag->GetTagName(),pCurServerTag->GetIntValue());
		else
			continue;
		wnd->InsertItem(buffer,-1,-1,rootitem);
   }
}
@


1.50
log
@Added "connected server failed" server status
@
text
@d196 1
a196 1
			if (pServerTag->GetType() == TAGTYPE_INT)
@


1.49
log
@minor change
@
text
@d430 1
a430 1
			iImageIndex = 2;
d433 3
a435 2
	if (GetFailedCount() > 0)
		iImageIndex = 4;
@


1.48
log
@Only show TCP compression in server tooltips for currently connected server (Thx KuSh)
@
text
@d418 1
a418 1
	strInfo.AppendFormat(_T("<br><b>%s</b><t>%s:%u%s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%u-%u<br><b>%s:</b><t>%s (%s)<br><b>%s:</b><t>%u<br><hr=100%%>"),
d421 1
a421 1
		GetResString(IDS_SHAREDFILES), GetSoftMaxFiles(), GetHardMaxFiles(),
@


1.47
log
@Tooltips string improvements
@
text
@d418 1
a418 1
	strInfo.AppendFormat(_T("<br><b>%s</b><t>%s:%u%s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%u-%u<br><b>%s:</b><t>%s (%s)<br><b>%s:</b><t>%u<br><hr=100%%><br><b>%s:</b><t>%s<br><b>%s:</b><t>%s<br><b>%s:</b><t>%s"),
d423 1
a423 4
		GetResString(IDS_PING), GetPing(),
		GetResString(IDS_TT_SRV_TCP), YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION),
		GetResString(IDS_TT_SRV_UDP1), YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES),
		GetResString(IDS_TT_SRV_UDP2), YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETFILES));
d429 1
d431 2
d438 4
@


1.46
log
@Double clicking on the messages/server pane in the status bar now switches to the according dialog; Formatting and name changes
@
text
@d414 1
a414 1
	strInfo.Format(_T("<t=1><b>%s</b><br><t=1><b>%s</b><br><hr=100%%><br>"), strServerName, strServerDescription);
d416 11
a426 9
		strInfo.AppendFormat(GetResString(IDS_TT_SRV_VERSION), GetVersion());
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_IP),GetFullIP(), GetPort(), strServerCountry);
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_FILES), CastItoThousands(GetFiles()));
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_LIMITS),GetSoftMaxFiles(), GetHardMaxFiles());
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_USERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()));
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_PING),GetPing());
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_TCP),YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION));
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_UDP1),YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES));
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_UDP2),YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETFILES));
d458 1
a458 3
	strMyID = _T(" (<b>");
	strMyID += GetResString((g_eMuleApp.m_pServerConnect->IsLowID()) ? IDS_PRIOLOW : IDS_PRIOHIGH);
	strMyID += _T("</b>)");
d460 5
a464 4
	strInfo.Format(GetResString(IDS_TT_USERINFO), strMyName, g_eMuleApp.m_pServerConnect->GetClientID(), strMyID);
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_USERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()) + _T(" (") + CastItoThousands(iTotalUsers) + _T(")"));
	strInfo.AppendFormat(GetResString(IDS_TT_SRV_FILES), CastItoThousands(GetFiles()) + _T(" (") + CastItoThousands(iTotalFiles) + _T(")"));
	strInfo.TrimRight(_T("<br>"));
@


1.45
log
@Formatting and some improvements in tooltips code
@
text
@d75 1
d98 1
a98 1
	for (POSITION pos = pOld.m_tagList.GetHeadPosition(); pos != NULL; )
d130 1
a130 1
	for (POSITION pos = m_tagList.GetHeadPosition(); pos != NULL; )
d137 3
a139 2
	CServerTag* tag = new CServerTag(servermet);
	switch(tag->GetSpecialTag())
d142 1
a142 1
			m_strListName = tag->GetStringValue();
d147 1
a147 1
			delete tag;
d150 1
a150 1
			description = tag->GetStringValue();
d155 1
a155 1
			delete tag;
d159 2
a160 2
			m_ePreferences = (EnumServerPriority)ed2k2eMule(tag->GetIntValue());
			delete tag;
d163 2
a164 2
			m_dwPingTime = tag->GetIntValue();
			delete tag;
d167 2
a168 2
			m_strDynIP = tag->GetStringValue();
			delete tag;
d171 2
a172 2
			m_dwFailedCount = tag->GetIntValue();
			delete tag;
d175 2
a176 2
			lastpingedtime = tag->GetIntValue();
			delete tag;
d179 2
a180 2
			m_dwMaxUsers = tag->GetIntValue();
			delete tag;
d183 2
a184 2
			m_dwSoftMaxFiles = tag->GetIntValue();
			delete tag;
d187 2
a188 2
			m_dwHardMaxFiles = tag->GetIntValue();
			delete tag;
d191 3
a193 3
			if (tag->GetType() == TAGTYPE_STRING)
			m_strVersion = tag->GetStringValue();
			delete tag;
d196 3
a198 3
			if (tag->GetType() == TAGTYPE_INT)
			m_dwUDPFlags  =  tag->GetIntValue();
			delete tag;
d201 1
a201 1
			if (tag->GetSpecialTag())
d203 2
a204 2
				tag->SetTagName(_T("Unknown"));
				AddTag(tag);
d206 1
a206 1
			else if (tag->GetTagName() == _T("files"))
d208 2
a209 2
				m_dwFiles = tag->GetIntValue();
				delete tag;
d211 1
a211 1
			else if (tag->GetTagName() == _T("users"))
d213 2
a214 2
				m_dwNumUsers = tag->GetIntValue();
				delete tag;
d216 1
a216 1
			else if (tag->GetTagName() == _T("AuxPort"))
d218 2
a219 2
				m_uAuxPort = static_cast<uint16>(tag->GetIntValue());
				delete tag;
d222 1
a222 1
				AddTag(tag);
d231 1
d256 2
a257 1
	CServerTag* cur_tag;
d261 2
a262 2
		cur_tag = m_tagList.GetAt(pos);
		if (cur_tag->GetSpecialTag())
d264 4
a267 4
		if (cur_tag->GetType() == 2)
			buffer.Format(_T("%s: %s"),cur_tag->GetTagName(),cur_tag->GetStringValue());
		else if (cur_tag->GetType() == 3)
			buffer.Format(_T("%s: %i"),cur_tag->GetTagName(),cur_tag->GetIntValue());
d317 1
d346 1
d369 1
d402 1
a402 1
		return NULL;
d440 1
a440 1
	return NULL;
d457 1
a457 4
	if (g_eMuleApp.m_pServerConnect->IsLowID())
	    strMyID += GetResString(IDS_PRIOLOW);
	else
	    strMyID += GetResString(IDS_PRIOHIGH);
@


1.44
log
@minor changes
@
text
@d390 1
a390 1
CString CServer::GetServerInfo4Tooltips()
d395 1
a395 1
		return _T("");
d397 3
a399 1
	CString		sRet, strServerCountry, strServerName = GetListName(), strServerDescription = GetDescription();
d407 1
a407 1
	sRet.Format(_T("<t=1><b>%s</b><br><t=1><b>%s</b><br><hr=100%%><br>"), strServerName, strServerDescription);
d409 19
a427 9
		sRet.AppendFormat(GetResString(IDS_TT_SRV_VERSION), GetVersion());
	sRet.AppendFormat(GetResString(IDS_TT_SRV_IP),GetFullIP(), GetPort(), strServerCountry);
	sRet.AppendFormat(GetResString(IDS_TT_SRV_FILES), CastItoThousands(GetFiles()));
	sRet.AppendFormat(GetResString(IDS_TT_SRV_LIMITS),GetSoftMaxFiles(), GetHardMaxFiles());
	sRet.AppendFormat(GetResString(IDS_TT_SRV_USERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()));
	sRet.AppendFormat(GetResString(IDS_TT_SRV_PING),GetPing());
	sRet.AppendFormat(GetResString(IDS_TT_SRV_TCP),YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION));
	sRet.AppendFormat(GetResString(IDS_TT_SRV_UDP1),YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES));
	sRet.AppendFormat(GetResString(IDS_TT_SRV_UDP2),YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETFILES));
d429 1
a429 1
	return sRet;
d433 1
a433 1
	return _T("");
d443 1
a443 1
	CString		sRet, strMyName = g_eMuleApp.m_pGlobPrefs->GetUserNick(), strMyID;
d456 4
a459 4
	sRet.Format(GetResString(IDS_TT_USERINFO), strMyName, g_eMuleApp.m_pServerConnect->GetClientID(), strMyID);
	sRet.AppendFormat(GetResString(IDS_TT_SRV_USERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()) + _T(" (") + CastItoThousands(iTotalUsers) + _T(")"));
	sRet.AppendFormat(GetResString(IDS_TT_SRV_FILES), CastItoThousands(GetFiles()) + _T(" (") + CastItoThousands(iTotalFiles) + _T(")"));
	sRet.TrimRight(_T("<br>"));
d461 1
a461 1
	return sRet;
@


1.43
log
@small correction
@
text
@d447 1
a447 4

	int iPos = sRet.ReverseFind(_T('<'));
	if (iPos != -1)
		sRet.Truncate(iPos);
@


1.42
log
@Tooltips alignment is now automatic;  Improved status bar tooltips
@
text
@d437 1
d439 1
a439 1
	    strMyID = GetResString(IDS_PRIOLOW);
d441 2
a442 1
	    strMyID = GetResString(IDS_PRIOHIGH);
@


1.41
log
@some fixes
@
text
@d423 33
@


1.40
log
@Totally reworked country information feature to minimaze memory usage.
@
text
@d397 1
a397 1
	CString		sRet, strServerCountry;
d399 4
d405 11
a415 12
	
	sRet.Format(_T("<t=1><b>%s</b><br><t=1><b>%s</b><br><hr=100%%><br>"), GetListName(), GetDescription());
	if(!GetVersion().IsEmpty())
		sRet.AppendFormat(GetResString(IDS_TT_SRV_VERSION),GetVersion());
		sRet.AppendFormat(GetResString(IDS_TT_SRV_IP),GetFullIP(), GetPort(), strServerCountry);
		sRet.AppendFormat(GetResString(IDS_TT_SRV_FILES), CastItoThousands(GetFiles()));
		sRet.AppendFormat(GetResString(IDS_TT_SRV_LIMITS),GetSoftMaxFiles(), GetHardMaxFiles());
		sRet.AppendFormat(GetResString(IDS_TT_SRV_USERS), CastItoThousands(GetNumUsers()), CastItoThousands(GetMaxUsers()));
		sRet.AppendFormat(GetResString(IDS_TT_SRV_PING),GetPing());
		sRet.AppendFormat(GetResString(IDS_TT_SRV_TCP),YesNoStr(GetTCPFlags() & SRV_TCPFLG_COMPRESSION));
		sRet.AppendFormat(GetResString(IDS_TT_SRV_UDP1),YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETSOURCES));
		sRet.AppendFormat(GetResString(IDS_TT_SRV_UDP2),YesNoStr(GetUDPFlags() & SRV_UDPFLG_EXT_GETFILES));
@


1.39
log
@Fixed potential crash which can be caused by control characters in server name and server description.
@
text
@d56 1
a56 1
	m_structServerCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d91 1
a91 1
	m_structServerCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d124 1
a124 1
	m_structServerCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d289 1
a289 1
	m_structServerCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
d380 1
a380 1
CString CServer::GetCountryName(bool bShortName) const
d382 1
a382 12
	if (!g_eMuleApp.m_pIP2Country->IsIP2Country())
		return _T("");

	if(bShortName)
		return m_structServerCountry->ShortCountryName;

	return m_structServerCountry->LongCountryName;
}

int CServer::GetCountryFlagIndex() const
{
	return m_structServerCountry->FlagIndex;
d387 1
a387 1
	m_structServerCountry = g_eMuleApp.m_pIP2Country->GetCountryFromIP(m_dwIP);
@


1.38
log
@minor change
@
text
@d141 4
d149 4
@


1.37
log
@removed unneeded string
@
text
@d405 1
a405 1
	sRet.Format(_T("<t=2><b>%s</b><br><t=2><b>%s</b><br><hr=100%%><br>"), GetListName(), GetDescription());
@


1.36
log
@added tooltips to the Server list
@
text
@d405 1
a405 1
	sRet.Format(GetResString(IDS_TT_SRV_NAME), GetListName(), GetDescription());
@


1.35
log
@no longer loading mid size names + some small changes
@
text
@d392 31
@


1.34
log
@added IP to Country from MorphXT (Please extract ip-to-country.rar in your config dir in order for this to work)
@
text
@d372 1
a372 1
CString CServer::GetCountryName() const
d374 1
a374 1
	if(g_eMuleApp.m_pIP2Country->IsIP2Country() == false)
d377 3
a380 16

	/*
	CString tempStr;
	switch(g_eMuleApp.m_pGlobPrefs.GetIP2CountryNameMode())
	{
		case IP2CountryName_SHORT:
			tempStr.Format("<%s>",m_structServerCountry->ShortCountryName);
			return tempStr;
		case IP2CountryName_MID:
			tempStr.Format("<%s>",m_structServerCountry->MidCountryName);
			return tempStr;
		case IP2CountryName_LONG:
			tempStr.Format("<%s>",m_structServerCountry->LongCountryName);
			return tempStr;
	}
	return _T("");*/
@


1.33
log
@added auxiliary port support from KuSh (commited with eklmn's authorization)
@
text
@d22 1
d56 1
d91 1
d124 1
d281 1
d371 34
@


1.32
log
@list processing optimization
@
text
@d33 1
d60 1
d99 1
d202 5
d279 1
a279 1
bool CServer::HasSameAddress(const CServer& server) const
d281 1
a281 2

	if ((m_dwIP == server.m_dwIP) && ((m_uPort == server.m_uPort) || m_uPort == 0 || server.m_uPort == 0))
@


1.31
log
@formatting;
little optimiZation of the DownloadList sorting code;
fixed sorting of ETA, AVG ETA, TimeRemaining, AvgTimeRemaining columns;
changed and fixed new option 'Show paused and stopped files last', it works and now with all column sort
@
text
@d92 1
a92 1
	for(POSITION pos = pOld.m_tagList.GetHeadPosition(); pos != NULL; pOld.m_tagList.GetNext(pos))
d94 1
a94 2
		CServerTag* pOldTag = pOld.m_tagList.GetAt(pos);
		m_tagList.AddTail(new CServerTag(*pOldTag));
d122 2
a123 2
	for(POSITION pos = m_tagList.GetHeadPosition(); pos != NULL; m_tagList.GetNext(pos))
		delete m_tagList.GetAt(pos);
@


1.30
log
@Minor changes
@
text
@d31 1
a31 1
{	
d44 1
a44 1
	m_dwFailedCount = 0; 
d56 2
a57 1
CServer::CServer(uint16 in_port, const CString& i_addr){	
d60 2
a61 1
	if (inet_addr(i_addr) == INADDR_NONE){
d65 2
a66 1
	else{
d68 1
a68 1
		m_strDynIP = "";
d76 2
a77 2
	m_dwPingTime = 0;	
	m_dwFailedCount = 0; 
d91 1
a91 1
{	
d98 1
a98 1
	m_dwIP = pOld.m_dwIP; 
d106 1
a106 1
	m_dwFailedCount = pOld.m_dwFailedCount; 
d110 2
a111 2
	m_dwMaxUsers = pOld.m_dwMaxUsers;	
	description = pOld.description;	
d113 1
a113 1
	m_strDynIP = pOld.m_strDynIP;	
d121 2
a122 1
CServer::~CServer(){		
d125 1
a125 1
	m_tagList.RemoveAll();	
d132 3
a134 3
	{		
		case ST_SERVERNAME:						
			m_strListName = tag->GetStringValue();						
d137 2
a138 2
		case ST_DESCRIPTION:						
			description = tag->GetStringValue();						
d150 2
a151 2
		case ST_DYNIP:						
			m_strDynIP = tag->GetStringValue();						
d206 2
a207 1
void CServer::FillWindowTags(CTreeCtrl* wnd,HTREEITEM rootitem){
d210 2
a211 1
	if (!description.IsEmpty()) {
d219 2
a220 1
	if (m_dwPingTime) {
d224 2
a225 1
	if (m_dwNumUsers) {
d229 2
a230 1
	if (m_dwFiles) {
d235 2
a236 1
	for(int i = 0; i != m_tagList.GetCount();i++) {
d272 2
a273 1
bool CServer::HasSameAddress(const CServer& server) const {
d287 1
a287 1
 * The correct server preferences (as used by eDonkey) are: Low=2, Normal=0, High=1 
d315 1
a315 1
 * The correct server preferences (as used by eDonkey) are: Low=2, Normal=0, High=1 
@


1.29
log
@Changed the filtering of 255.255.255.255 servers
@
text
@a329 1

a348 19

bool CServer::HasInvalidAddress() const
{
	in_addr host;
	host.S_un.S_addr = m_dwIP;

	int b1 = host.S_un.S_un_b.s_b1;
	int b2 = host.S_un.S_un_b.s_b2;
	int b3 = host.S_un.S_un_b.s_b3;
	int b4 = host.S_un.S_un_b.s_b4;

	if (b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0)
		return true;

	if (b1 == 255 && b2 == 255 && b3 == 255 && b4 == 255)
		return true;

	return false;
}
@


1.28
log
@Filtered server 255.255.255.255
@
text
@a337 2
	int b3 = host.S_un.S_un_b.s_b3;
	int b4 = host.S_un.S_un_b.s_b4;
d348 16
d365 1
a365 1
		return false;
d367 1
a367 1
	return true;
@


1.27
log
@problem with save & load of server list (not tested yet)
@
text
@d338 3
a340 1
		
d348 3
@


1.26
log
@1) compession support within communicatio client<->server
2) extended UDP file search support
@
text
@d82 2
d114 2
d124 2
a125 2
bool CServer::AddTagFromFile(CSafeFile& servermet){
	
d127 71
a197 62
	switch(tag->GetSpecialTag()){		
					case ST_SERVERNAME:						
						m_strListName = tag->GetStringValue();						
						delete tag;
						break;
					case ST_DESCRIPTION:						
						description = tag->GetStringValue();						
						delete tag;
						break;
					case ST_PREFERENCE:
						// Modified by Tarod [thx Hein] - import server preferences and translate it
						m_ePreferences = (EnumServerPriority)ed2k2eMule(tag->GetIntValue());
						delete tag;
						break;
					case ST_PING:
						m_dwPingTime = tag->GetIntValue();
						delete tag;
						break;
					case ST_DYNIP:						
						m_strDynIP = tag->GetStringValue();						
						delete tag;
						break;
					case ST_FAIL:
						m_dwFailedCount = tag->GetIntValue();
						delete tag;
						break;
					case ST_LASTPING:
						lastpingedtime = tag->GetIntValue();
						delete tag;
						break;
					case ST_MAXUSERS:
						m_dwMaxUsers = tag->GetIntValue();
						delete tag;
						break;
					case ST_SOFTFILES:
						m_dwSoftMaxFiles = tag->GetIntValue();
						delete tag;
						break;
					case ST_HARDFILES:
						m_dwHardMaxFiles = tag->GetIntValue();
						delete tag;
						break;
					case ST_VERSION:
						if (tag->GetType() == 2)
							m_strVersion = tag->GetStringValue();
						delete tag;
						break;
					default:
						if (tag->GetSpecialTag()){
							tag->SetTagName(_T("Unknown"));
							AddTag(tag);
						}
						else if (tag->GetTagName() == _T("files")){
							m_dwFiles = tag->GetIntValue();
							delete tag;
						}
						else if (tag->GetTagName() == _T("users")){
							m_dwNumUsers = tag->GetIntValue();
							delete tag;
						}
						else
							AddTag(tag);
d349 1
a349 1
}@


1.25
log
@Formatting, comments, and name changes.
@
text
@d52 2
@


1.24
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d32 1
a32 1
	m_nPort = pServerMet->m_nPort;
d34 1
a34 1
	m_iIP = pServerMet->m_iIP;
d38 1
a38 1
	host.S_un.S_addr = m_iIP;
d55 1
a55 1
	m_nPort = in_port;
d59 1
a59 1
		m_iIP = 0;
d62 1
a62 1
		m_iIP = inet_addr(i_addr);
d66 1
a66 1
	host.S_un.S_addr = m_iIP;
d90 2
a91 2
	m_nPort = pOld.m_nPort;
	m_iIP = pOld.m_iIP; 
d196 1
a196 1
	buffer.Format(GetResString(IDS_PORT)+_T(": %i"),m_nPort);
d237 1
a237 1
	m_iIP = iNewIP;
d243 1
a243 1
	host.S_un.S_addr = m_iIP;
d249 1
a249 1
	if ((m_iIP == server.m_iIP) && ((m_nPort == server.m_nPort) || m_nPort == 0 || server.m_nPort == 0))
d251 1
a251 1
		if (m_iIP != 0)
d319 1
a319 1
	host.S_un.S_addr = m_iIP;
@


1.23
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d48 1
a48 1
	staticservermember=0;
d50 2
a51 2
	softfiles = 0;
	hardfiles = 0;
d76 1
a76 1
	staticservermember=0;
d78 2
a79 2
	softfiles = 0;
	hardfiles = 0;
d92 1
a92 1
	staticservermember=pOld.IsStaticMember();
d107 2
a108 2
	softfiles = pOld.softfiles;
	hardfiles = pOld.hardfiles;
d156 1
a156 1
						softfiles = tag->GetIntValue();
d160 1
a160 1
						hardfiles = tag->GetIntValue();
@


1.22
log
@Formatting, comments, and name changes.
@
text
@d29 13
a41 9
CServer::CServer(ServerMet_Struct* in_data){	
	port = in_data->port;
	tagcount = 0;
	ip = in_data->ip;
	in_addr host;
	host.S_un.S_addr = ip;
	ipfull = inet_ntoa(host);
	files = 0;
	users = 0;
d43 2
a44 2
	ping = 0;
	failedcount = 0; 
d49 1
a49 1
	maxusers=0;
d53 1
a53 1

d55 2
a56 2
	port = in_port;
	tagcount = 0;
d58 2
a59 2
		dynip = i_addr;
		ip = 0;
d62 2
a63 2
		ip = inet_addr(i_addr);
		dynip = "";
d66 4
a69 4
	host.S_un.S_addr = ip;
	ipfull = inet_ntoa(host);
	files = 0;
	users = 0;
d71 2
a72 2
	ping = 0;	
	failedcount = 0; 
d77 1
a77 1
	maxusers=0;
d87 2
a88 2
		CTag* pOldTag = pOld.m_tagList.GetAt(pos);
		m_tagList.AddTail(new CTag(*pOldTag));
d90 2
a91 2
	port = pOld.port;
	ip = pOld.ip; 
d93 4
a96 4
	tagcount = pOld.tagcount;
	ipfull = pOld.ipfull;
	files = pOld.files;
	users = pOld.users;
d98 2
a99 2
	ping = pOld.ping;
	failedcount = pOld.failedcount; 
d103 1
a103 1
	maxusers = pOld.maxusers;	
d105 2
a106 2
	listname = pOld.listname;
	dynip = pOld.dynip;	
d120 1
a120 1
	CTag* tag = new CTag(servermet);
d123 1
a123 1
						listname = tag->GetStringValue();						
d136 1
a136 1
						ping = tag->GetIntValue();
d140 1
a140 1
						dynip = tag->GetStringValue();						
d144 1
a144 1
						failedcount = tag->GetIntValue();
d152 1
a152 1
						maxusers = tag->GetIntValue();
d174 1
a174 1
							files = tag->GetIntValue();
d178 1
a178 1
							users = tag->GetIntValue();
d194 1
a194 1
	buffer.Format(GetResString(IDS_IP)+_T(": %s"),ipfull);
d196 1
a196 1
	buffer.Format(GetResString(IDS_PORT)+_T(": %i"),port);
d198 2
a199 2
	if (ping) {
		buffer.Format(GetResString(IDS_PING)+_T(": %i"),ping);
d202 2
a203 2
	if (users) {
		buffer.Format(GetResString(IDS_USERS),users);
d206 2
a207 2
	if (files) {
		buffer.Format(GetResString(IDS_FILES)+_T(": %i"),files);
d210 1
a210 1
	CTag* cur_tag;
d225 5
a229 4

CString CServer::GetAddress() const {
	if (!dynip.IsEmpty())
		return dynip;
d231 1
a231 1
		return ipfull;
d233 9
d243 2
a244 5
void CServer::SetID(uint32 newip){
	ip = newip;
	in_addr host;
	host.S_un.S_addr = ip;
	ipfull = inet_ntoa(host);
d246 1
a246 1

d249 1
a249 1
	if ((ip == server.ip) && ((port == server.port) || port == 0 || server.port == 0))
d251 1
a251 1
		if (ip != 0)
d253 1
a253 1
		else if (dynip == server.dynip)
d319 1
a319 1
	host.S_un.S_addr = ip;
@


1.21
log
@Formatting, comments, and name changes.
@
text
@d38 1
a38 1
	m_ePreferences = ePR_LOW;
d66 1
a66 1
	m_ePreferences = ePR_LOW;
d128 1
a128 1
						m_ePreferences = (eServerPriority)ed2k2eMule(tag->GetIntValue());
@


1.20
log
@added columns Soft/Hard Files Limit and Version in server window (merge from official)
@
text
@d81 1
a81 1
	for(POSITION pos = pOld.taglist.GetHeadPosition(); pos != NULL; pOld.taglist.GetNext(pos))
d83 2
a84 2
		CTag* pOldTag = pOld.taglist.GetAt(pos);
		taglist.AddTail(new CTag(*pOldTag));
d109 3
a111 3
	for(POSITION pos = taglist.GetHeadPosition(); pos != NULL; taglist.GetNext(pos))
		delete taglist.GetAt(pos);
	taglist.RemoveAll();	
d207 3
a209 3
	for(int i = 0; i != taglist.GetCount();i++) {
		pos = taglist.FindIndex(i);
		cur_tag = taglist.GetAt(pos);
@


1.19
log
@char * to CString conversion
@
text
@d42 2
d46 2
d70 2
d74 2
d97 2
d103 3
d144 1
a144 1
						lastpinged = tag->GetIntValue();
d149 13
@


1.18
log
@unicode cleanup
@
text
@d104 3
a106 6
	switch(tag->specialtag){		
					case ST_SERVERNAME:
						if(tag->stringvalue)
						listname = tag->stringvalue;
						else
							listname = "";
d109 2
a110 5
					case ST_DESCRIPTION:
						if( tag->stringvalue )
							description = tag->stringvalue;
						else
							description = "";
d115 1
a115 1
						m_ePreferences = (eServerPriority)ed2k2eMule(tag->intvalue);
d119 1
a119 1
						ping = tag->intvalue;
d122 2
a123 5
					case ST_DYNIP:
						if ( tag->stringvalue )
						dynip = tag->stringvalue;
						else
							dynip = "";
d127 1
a127 1
						failedcount = tag->intvalue;
d131 1
a131 1
						lastpinged = tag->intvalue;
d135 1
a135 1
						maxusers = tag->intvalue;
d139 2
a140 2
						if (tag->specialtag){
							tag->tagname = nstrdup("Unknown");
d143 2
a144 2
						else if (!strcmp(tag->tagname,"files")){
							files = tag->intvalue;
d147 2
a148 2
						else if (!strcmp(tag->tagname,"users")){
							users = tag->intvalue;
d184 1
a184 1
		if (cur_tag->specialtag)
d186 4
a189 4
		if (cur_tag->type == 2)
			buffer.Format(_T("%s: %s"),cur_tag->tagname,cur_tag->stringvalue);
		else if (cur_tag->type == 3)
			buffer.Format(_T("%s: %i"),cur_tag->tagname,cur_tag->intvalue);
@


1.17
log
@code cleanup
@
text
@d173 1
a173 1
	buffer.Format(GetResString(IDS_IP)+": %s",ipfull);
d175 1
a175 1
	buffer.Format(GetResString(IDS_PORT)+": %i",port);
d178 1
a178 1
		buffer.Format(GetResString(IDS_PING)+": %i",ping);
d186 1
a186 1
		buffer.Format(GetResString(IDS_FILES)+": %i",files);
d196 1
a196 1
			buffer.Format("%s: %s",cur_tag->tagname,cur_tag->stringvalue);
d198 1
a198 1
			buffer.Format("%s: %i",cur_tag->tagname,cur_tag->intvalue);
@


1.16
log
@removed Tag_Struct usage from sources
@
text
@d101 2
a102 3
bool CServer::AddTagFromFile(CSafeFile* servermet){
	if (servermet == 0)
		return false;
@


1.15
log
@converted to standard copy constructor
@
text
@d105 1
a105 1
	switch(tag->tag->specialtag){		
d107 2
a108 2
						if(tag->tag->stringvalue)
						listname = tag->tag->stringvalue;
d114 2
a115 2
						if( tag->tag->stringvalue )
							description = tag->tag->stringvalue;
d122 1
a122 1
						m_ePreferences = (eServerPriority)ed2k2eMule(tag->tag->intvalue);
d126 1
a126 1
						ping = tag->tag->intvalue;
d130 2
a131 2
						if ( tag->tag->stringvalue )
						dynip = tag->tag->stringvalue;
d137 1
a137 1
						failedcount = tag->tag->intvalue;
d141 1
a141 1
						lastpinged = tag->tag->intvalue;
d145 1
a145 1
						maxusers = tag->tag->intvalue;
d149 2
a150 2
						if (tag->tag->specialtag){
							tag->tag->tagname = nstrdup("Unknown");
d153 2
a154 2
						else if (!strcmp(tag->tag->tagname,"files")){
							files = tag->tag->intvalue;
d157 2
a158 2
						else if (!strcmp(tag->tag->tagname,"users")){
							users = tag->tag->intvalue;
d194 1
a194 1
		if (cur_tag->tag->specialtag)
d196 4
a199 4
		if (cur_tag->tag->type == 2)
			buffer.Format("%s: %s",cur_tag->tag->tagname,cur_tag->tag->stringvalue);
		else if (cur_tag->tag->type == 3)
			buffer.Format("%s: %i",cur_tag->tag->tagname,cur_tag->tag->intvalue);
@


1.14
log
@changes reverted
@
text
@d76 1
a76 1
		taglist.AddTail(pOldTag->CloneTag());
@


1.13
log
@removed Tag_Struct usage from sources
@
text
@d105 1
a105 1
	switch(tag->specialtag){		
d107 2
a108 2
						if(tag->stringvalue)
						listname = tag->stringvalue;
d114 2
a115 2
						if( tag->stringvalue )
							description = tag->stringvalue;
d122 1
a122 1
						m_ePreferences = (eServerPriority)ed2k2eMule(tag->intvalue);
d126 1
a126 1
						ping = tag->intvalue;
d130 2
a131 2
						if ( tag->stringvalue )
						dynip = tag->stringvalue;
d137 1
a137 1
						failedcount = tag->intvalue;
d141 1
a141 1
						lastpinged = tag->intvalue;
d145 1
a145 1
						maxusers = tag->intvalue;
d149 2
a150 2
						if (tag->specialtag){
							tag->tagname = nstrdup("Unknown");
d153 2
a154 2
						else if (!strcmp(tag->tagname,"files")){
							files = tag->intvalue;
d157 2
a158 2
						else if (!strcmp(tag->tagname,"users")){
							users = tag->intvalue;
d194 1
a194 1
		if (cur_tag->specialtag)
d196 4
a199 4
		if (cur_tag->type == 2)
			buffer.Format("%s: %s",cur_tag->tagname,cur_tag->stringvalue);
		else if (cur_tag->type == 3)
			buffer.Format("%s: %i",cur_tag->tagname,cur_tag->intvalue);
@


1.12
log
@some special case when port is 0
@
text
@d105 1
a105 1
	switch(tag->tag->specialtag){		
d107 2
a108 2
						if(tag->tag->stringvalue)
						listname = tag->tag->stringvalue;
d114 2
a115 2
						if( tag->tag->stringvalue )
							description = tag->tag->stringvalue;
d122 1
a122 1
						m_ePreferences = (eServerPriority)ed2k2eMule(tag->tag->intvalue);
d126 1
a126 1
						ping = tag->tag->intvalue;
d130 2
a131 2
						if ( tag->tag->stringvalue )
						dynip = tag->tag->stringvalue;
d137 1
a137 1
						failedcount = tag->tag->intvalue;
d141 1
a141 1
						lastpinged = tag->tag->intvalue;
d145 1
a145 1
						maxusers = tag->tag->intvalue;
d149 2
a150 2
						if (tag->tag->specialtag){
							tag->tag->tagname = nstrdup("Unknown");
d153 2
a154 2
						else if (!strcmp(tag->tag->tagname,"files")){
							files = tag->tag->intvalue;
d157 2
a158 2
						else if (!strcmp(tag->tag->tagname,"users")){
							users = tag->tag->intvalue;
d194 1
a194 1
		if (cur_tag->tag->specialtag)
d196 4
a199 4
		if (cur_tag->tag->type == 2)
			buffer.Format("%s: %s",cur_tag->tag->tagname,cur_tag->tag->stringvalue);
		else if (cur_tag->tag->type == 3)
			buffer.Format("%s: %i",cur_tag->tag->tagname,cur_tag->tag->intvalue);
@


1.11
log
@helper method to compare servers by ip and port
@
text
@d222 1
a222 1
	if (ip == server.ip && port == server.port)
@


1.10
log
@code cleanup
@
text
@d220 12
@


1.9
log
@code cleanup
@
text
@d275 21
@


1.8
log
@coverted code from char * to CString
@
text
@d29 1
a29 2
CServer::CServer(ServerMet_Struct* in_data){
	taglist = new CTypedPtrList<CPtrList, CTag*>;
d46 1
a46 2
CServer::CServer(uint16 in_port, char* i_addr){
	taglist = new CTypedPtrList<CPtrList, CTag*>;
d71 3
a73 4
CServer::CServer(CServer* pOld)
{
	taglist = new CTypedPtrList<CPtrList, CTag*>;
	for(POSITION pos = pOld->taglist->GetHeadPosition(); pos != NULL; pOld->taglist->GetNext(pos))
d75 2
a76 2
		CTag* pOldTag = pOld->taglist->GetAt(pos);
		taglist->AddTail(pOldTag->CloneTag());
d78 15
a92 15
	port = pOld->port;
	ip = pOld->ip; 
	staticservermember=pOld->IsStaticMember();
	tagcount = pOld->tagcount;
	ipfull = pOld->ipfull;
	files = pOld->files;
	users = pOld->users;
	m_ePreferences = pOld->m_ePreferences;
	ping = pOld->ping;
	failedcount = pOld->failedcount; 
	lastpinged = pOld->lastpinged;
	maxusers = pOld->maxusers;	
	description = pOld->description;	
	listname = pOld->listname;
	dynip = pOld->dynip;	
d96 3
a98 4
	for(POSITION pos = taglist->GetHeadPosition(); pos != NULL; taglist->GetNext(pos))
		delete taglist->GetAt(pos);
	taglist->RemoveAll();
	delete taglist;
d169 1
a169 1
	char buffer[255];
d171 1
a171 1
		sprintf(buffer,GetResString(IDS_DESC),description);
d174 1
a174 1
	sprintf(buffer,GetResString(IDS_IP)+": %s",ipfull);
d176 1
a176 1
	sprintf(buffer,GetResString(IDS_PORT)+": %i",port);
d179 1
a179 1
		sprintf(buffer,GetResString(IDS_PING)+": %i",ping);
d183 1
a183 1
		sprintf(buffer,GetResString(IDS_USERS),users);
d187 1
a187 1
		sprintf(buffer,GetResString(IDS_FILES)+": %i",files);
d191 3
a193 3
	for(int i = 0; i != taglist->GetCount();i++) {
		pos = taglist->FindIndex(i);
		cur_tag = taglist->GetAt(pos);
d197 1
a197 1
			sprintf(buffer,"%s: %s",cur_tag->tag->tagname,cur_tag->tag->stringvalue);
d199 1
a199 1
			sprintf(buffer,"%s: %i",cur_tag->tag->tagname,cur_tag->tag->intvalue);
d206 1
a206 1
CString CServer::GetAddress(){
@


1.7
log
@Some code housekeeping changes
@
text
@d36 1
a36 1
	strcpy(ipfull,inet_ntoa(host));
d61 1
a61 1
	strcpy(ipfull,inet_ntoa(host));
d85 1
a85 1
	strcpy(ipfull,pOld->ipfull);
d221 1
a221 1
	strcpy(ipfull,inet_ntoa(host));
@


1.6
log
@code cleanup
@
text
@d39 1
a39 1
	preferences = 0;
d64 1
a64 1
	preferences = 0;
d88 1
a88 1
	preferences = pOld->preferences;
d126 1
a126 1
						preferences = ed2k2eMule(tag->tag->intvalue);
@


1.5
log
@Little fixes and Static Servers additions from 26d
@
text
@a40 3
	description = 0;
	listname = 0;
	dynip = 0;
d52 1
a52 1
		dynip = nstrdup(i_addr);
d57 1
a57 1
		dynip = 0;
d65 1
a65 3
	ping = 0;
	description = 0;
	listname = 0;
d92 4
a95 13
	maxusers = pOld->maxusers;
	if (pOld->description)
		description = nstrdup(pOld->description);
	else
		description = NULL;
	if (pOld->listname)
		listname = nstrdup(pOld->listname);
	else
		listname = NULL;
	if (pOld->dynip)
		dynip = nstrdup(pOld->dynip);
	else
		dynip = NULL;
d98 1
a98 7
CServer::~CServer(){
	if (description)
		delete[] description;
	if (listname)
		delete[] listname;
	if (dynip)
		delete[] dynip;
d112 1
a112 1
						listname = nstrdup(tag->tag->stringvalue);
d114 1
a114 1
							listname = NULL;
d119 1
a119 1
						description = nstrdup(tag->tag->stringvalue);
d121 1
a121 1
							description = NULL;
d135 1
a135 1
						dynip = nstrdup(tag->tag->stringvalue);
d137 1
a137 1
							dynip = NULL;
a170 18
void CServer::SetListName(char* newname){
	if (listname)
		delete[] listname;
	if (newname)
	listname = nstrdup(newname);
	else
		listname = NULL;
}

void CServer::SetDescription(char* newname){
	if (description)
		delete[] description;
	if( newname )
	description = nstrdup(newname);
	else
		description = NULL;
}

d174 1
a174 1
	if (description) {
d210 2
a211 2
char* CServer::GetAddress(){
	if (dynip)
a221 9
}

void CServer::SetDynIP(char* newdynip){
	if (dynip)
		delete[] dynip;
	if( newdynip )
	    dynip = nstrdup(newdynip);
	else
		dynip = NULL;
@


1.4
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@a17 1

a27 1

@


1.3
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d133 1
d135 2
d140 1
d142 2
d156 1
d158 2
d196 1
d198 2
d205 1
d207 2
d267 4
a270 1
	dynip = nstrdup(newdynip);
@


1.2
log
@updated to .25b codebase
@
text
@d24 6
@


1.2.2.1
log
@updating this branch...
@
text
@@


1.1
log
@*** empty log message ***
@
text
@d35 1
a35 1
	preferences = 1;
d63 1
a63 1
	preferences = 1;
@

