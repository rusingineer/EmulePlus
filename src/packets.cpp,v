head	1.49;
access;
symbols
	PublicRelease_1_2e:1.49
	Interim_Release_1-2e_RC1:1.49
	PublicRelease_1_2d:1.48
	Interim_Release_1-2d_RC1:1.48
	Interim_Release_1-2d_beta1:1.48
	PublicRelease_1_2c:1.45
	Interim_Release_1-2c_RC1:1.45
	Interim_Release_1-2c_beta1:1.44
	PublicRelease_1_2b:1.42
	Interim_Release_1-2b_RC1:1.42
	PublicRelease_1_2a:1.40
	Interim_Release_1-2a_RC1:1.40
	Interim_Release_1-2a_beta2:1.36
	Interim_Release_1-2a_beta1:1.36
	PublicRelease_1_2:1.36
	Interim_Release_1-2_RC1:1.36
	Interim_Release_1-2_beta1:1.36
	PublicRelease_1_1g:1.36
	Interim_Release_1-1g_RC3:1.36
	Interim_Release_1-1g_RC2:1.35
	Interim_Release_1-1g_RC1:1.35
	Interim_Release_1-1g_beta2:1.35
	Interim_Release_1-1g_beta1:1.35
	PublicRelease_1_1f:1.35
	Interim_Release_1-1f_RC1:1.35
	PublicRelease_1_1e:1.35
	Interim_Release_1-1e_RC2:1.35
	Interim_Release_1-1e_RC1:1.35
	Interim_Release_1-1e_beta1:1.35
	PublicRelease_1_1d:1.34
	Interim_Release_1-1d_RC1:1.34
	PublicRelease_1_1c:1.32
	Interim_Release_1-1c_RC1:1.32
	Interim_Release_1-1c_beta2:1.31
	Interim_Release_1-1c_beta1:1.26
	PublicRelease_1_1b:1.25
	Interim_Release_1-1b_RC1:1.25
	PublicRelease_1_1a:1.25
	Interim_Release_1-1a_RC2:1.25
	Interim_Release_1-1a_RC1:1.25
	Interim_Release_1-1a_beta2:1.25
	Interim_Release_1-1a_beta1:1.25
	PublicRelease_1_1:1.24
	Interim_Release_1-1_beta1:1.24
	PublicRelease_1o:1.24
	Interim_Release_1o_RC1:1.24
	Interim_Release_1o_beta1:1.24
	PublicRelease_1n:1.24
	Interim_Release_1n_RC2:1.24
	Interim_Release_1n_RC1:1.24
	Interim_Release_1n_beta2:1.22
	Interim_Release_1n_beta1:1.22
	PublicRelease_1m:1.22
	Interim_Release_1m_beta1:1.22
	PublicRelease_1l:1.22
	Interim_Release_1l_RC3:1.22
	Interim_Release_1l_RC2:1.22
	Interim_Release_1l_RC1:1.22
	Interim_Release_1l_beta2:1.22
	Interim_Release_1l_beta1:1.22
	PublicRelease_1k:1.22
	Interim_Release_1k_RC4:1.22
	Interim_1k_RC3:1.22
	Interim_1k_RC2:1.22
	Interim_Release_1k_RC1:1.22
	Interim_Release_1k_beta5:1.22
	Intrerim_Release_1k_beta4:1.22
	Interim_Release_1k_beta1:1.22
	PublicRelease_1j:1.21
	Interim_Release_1J_RC3:1.21
	Interim_Release_1j_RC3:1.21
	Interim_Release_1j_RC2:1.21
	Interim_Release_1j_RC1:1.21
	Interim_Release_1j_beta2:1.21
	Interim_Release_1j_beta1:1.21
	PublicRelease_1i:1.21
	Interim_Release_1i_RC6:1.21
	Interim_Release_1i_RC3:1.21
	Interim_Release_1i_RC2:1.21
	Interim_Release_1i_RC1:1.21
	Interim_Release_1i_beta3:1.21
	Interim_Release_1i_beta2:1.20
	Interim_Release_1i_beta1:1.17
	PublicRelease_1h:1.16
	Interim_Release_1h_rc2:1.16
	Interim_Release_1h_RC1:1.16
	Interim_Release_1h_beta2:1.16
	Interim_Release_1h_beta1_now:1.16
	Interim_Release_1h_beta1:1.16
	PublicRelease_1g:1.15
	Interim_Release_1g_RC6_Final:1.15
	Interim_Release_1g_RC6:1.15
	Interim_Release_1g_RC5:1.15
	Interim_Release_1g_RC4:1.15
	Interim_Release_1g_RC3:1.15
	Interim_Release_1g_beta2:1.12
	Interim_Release_1g_beta1:1.6
	Interim_Release_1f_RC4:1.6
	Interim_Release_1f_RC3:1.6
	Interim_Release_1f_RC2:1.6
	Interim_Release_1f_RC:1.6
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.4
	PublicRelease_1e:1.3
	Interim_Release_1e_RC2:1.3
	Interim_Release_1e_RC:1.3
	Interim_Release_1e_beta3:1.3
	Interim_Release_1e_beta2:1.3
	Interim_Release_1e_beta2_before_kuchin:1.3
	Interim_Release_1e_beta1:1.3
	PublicRelease_1c:1.3
	featurestest:1.3.0.8
	Interim_Release_1c_RC:1.3
	Interim_Release_1c_beta2:1.3
	Interim_Release_1c_beta1:1.3
	threaded_downloadqueue:1.3.0.6
	PublicRelease_1b:1.3
	Interim_Release_1b_beta2:1.3
	Interim_Release_1b_beta1:1.3
	proxydeadlake:1.3.0.4
	PublicRelease_1a:1.3
	Interim_Release_1a_beta2:1.3
	BerkeleyDb:1.3.0.2
	Interim_Release_1a_beta1:1.3
	PublicRelease_1:1.3
	goldfish:1.3
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.49
date	2008.09.29.22.52.05;	author aw3;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.17.02.27.14;	author aw3;	state Exp;
branches;
next	1.47;

1.47
date	2007.12.07.02.18.59;	author aw3;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.05.22.02.49;	author eklmn;	state Exp;
branches;
next	1.45;

1.45
date	2007.04.14.04.23.40;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.25.00.46.46;	author aw3;	state Exp;
branches;
next	1.43;

1.43
date	2007.02.11.02.10.29;	author aw3;	state Exp;
branches;
next	1.42;

1.42
date	2007.01.08.00.02.33;	author aw3;	state Exp;
branches;
next	1.41;

1.41
date	2006.11.16.05.47.18;	author aw3;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.21.03.48.04;	author aw3;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.07.23.49.17;	author aw3;	state Exp;
branches;
next	1.38;

1.38
date	2006.07.21.00.40.05;	author aw3;	state Exp;
branches;
next	1.37;

1.37
date	2006.07.04.04.42.38;	author aw3;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.14.04.00.28;	author aw3;	state Exp;
branches;
next	1.35;

1.35
date	2005.04.02.22.33.18;	author aw3;	state Exp;
branches;
next	1.34;

1.34
date	2005.03.11.04.46.58;	author aw3;	state Exp;
branches;
next	1.33;

1.33
date	2005.03.10.07.24.08;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2005.02.17.17.56.25;	author aw3;	state Exp;
branches;
next	1.31;

1.31
date	2005.02.16.05.05.51;	author aw3;	state Exp;
branches;
next	1.30;

1.30
date	2005.02.12.00.47.00;	author aw3;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.09.22.41.50;	author aw3;	state Exp;
branches;
next	1.28;

1.28
date	2005.02.04.23.41.56;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2005.02.01.03.52.18;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.19.21.10.54;	author netwolf1;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.08.03.08.30;	author aw3;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.12.13.02.03;	author eklmn;	state Exp;
branches;
next	1.23;

1.23
date	2004.08.10.12.43.40;	author eklmn;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.11.04.13.02;	author katsyonak;	state Exp;
branches;
next	1.21;

1.21
date	2003.10.31.06.47.00;	author eklmn;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.14.18.40.59;	author syrus77;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.08.12.56.33;	author morevit;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.21.22.05.20;	author morevit;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.10.04.42.50;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.22.10.38.05;	author partyckip;	state Exp;
branches;
next	1.14;

1.14
date	2003.06.21.17.52.33;	author partyckip;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.11.18.27.15;	author eklmn;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.06.20.37.18;	author partyckip;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.06.19.56.47;	author partyckip;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.05.19.57.16;	author partyckip;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.05.17.23.26;	author partyckip;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.05.05.51.21;	author partyckip;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.04.20.27.29;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.12.11.41.51;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.08.16.19.07;	author partyckip;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.29.08.37.54;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.02.20.14.29.04;	author dongato;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.52;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.25;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.41;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.49
log
@Removed bFromPF from one of constructors as it's only required for outgoing data packets; Removed default option for bFromPF parameter for another constructor for better verification.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "packets.h"
#include "otherfunctions.h"
#include "zlib/zlib.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet::Packet(byte byteProtocol)
{
	m_bSplit = false;
	m_bLastSplit = false;
	m_dwSize = 0;
	m_pcBuffer = NULL;
	m_pcCompleteBuffer = NULL;
	m_pcTempBuffer = NULL;
	m_byteProtocol = byteProtocol;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet::Packet(PacketHeader_Struct *pHeaderStruct)
{
	m_bSplit = false;
	m_bLastSplit = false;
	m_pcTempBuffer = NULL;
	m_pcBuffer = NULL;
	m_pcCompleteBuffer = NULL;
	m_dwSize = pHeaderStruct->dwPacketLength - 1;
	m_eOpcode = pHeaderStruct->eCommand;
	m_byteProtocol = pHeaderStruct->byteEDonkeyProtocol;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet::Packet(char *pcPacketPart, uint32 dwSize, bool bLast, byte byteFilePriority, bool bFromPF)
{
	m_byteFilePriority = byteFilePriority;
	m_bFromPF = bFromPF;
	m_bSplit = true;
	m_bLastSplit = bLast;
	m_pcTempBuffer = NULL;
	m_pcBuffer = NULL;
	m_pcCompleteBuffer = pcPacketPart;
	m_dwSize = dwSize - sizeof(PacketHeader_Struct);
	m_byteProtocol = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Packet(EnumOpCodes,uint32,eProtocol) constructs a Packet with the spec'd opcode, data size, and protocol.
Packet::Packet(EnumOpcodes eOpcode, uint32 dwSize/*=0*/, byte byteProtocol/*=OP_EDONKEYPROT*/)
{
	m_bSplit = false;
	m_bLastSplit = false;
	m_pcTempBuffer = NULL;
	if (dwSize)
	{
		m_pcCompleteBuffer = new char[dwSize + sizeof(PacketHeader_Struct)];
		m_pcBuffer = m_pcCompleteBuffer + sizeof(PacketHeader_Struct);
		memzero(m_pcCompleteBuffer, dwSize + sizeof(PacketHeader_Struct));
	}
	else
	{
		m_pcBuffer = NULL;
		m_pcCompleteBuffer = NULL;
	}
	m_eOpcode = eOpcode;
	m_dwSize = dwSize;
	m_byteProtocol = byteProtocol;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet::Packet(EnumOpcodes eOpcode, uint32 dwSize, byte byteProtocol, byte byteFilePriority, bool bFromPF)
{
	m_byteFilePriority = byteFilePriority;
//	'bFromPF' is only used to set the "from PartFile" state of the Packet. If 'm_bFromPF' = false then this
//	packet was formed from a complete shared file rather than a part file.
//	It is used only in the UploadClient to track transferred data stats.
	m_bFromPF = bFromPF;
	m_bSplit = false;
	m_bLastSplit = false;
	m_pcTempBuffer = NULL;
	if (dwSize)
	{
		m_pcCompleteBuffer = new char[dwSize + sizeof(PacketHeader_Struct)];
		m_pcBuffer = m_pcCompleteBuffer + sizeof(PacketHeader_Struct);
		memzero(m_pcCompleteBuffer, dwSize + sizeof(PacketHeader_Struct));
	}
	else
	{
		m_pcBuffer = NULL;
		m_pcCompleteBuffer = NULL;
	}
	m_eOpcode = eOpcode;
	m_dwSize = dwSize;
	m_byteProtocol = byteProtocol;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet::Packet(CMemFile *pDataFile, byte byteProtocol)
{
	m_bSplit = false;
	m_bLastSplit = false;
	m_dwSize = static_cast<uint32>(pDataFile->GetLength());
	m_pcCompleteBuffer = new char[m_dwSize + sizeof(PacketHeader_Struct)];
	m_pcBuffer = m_pcCompleteBuffer + sizeof(PacketHeader_Struct);

	BYTE	*pbyteBuffer = pDataFile->Detach();

	memcpy2(m_pcBuffer, pbyteBuffer, m_dwSize);
	free(pbyteBuffer);
	m_pcTempBuffer = NULL;
	m_byteProtocol = byteProtocol;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Packet::~Packet()
{
	if (m_pcCompleteBuffer != NULL)
		delete[] m_pcCompleteBuffer;
	else if (m_pcBuffer != NULL)
		delete[] m_pcBuffer;
	delete[] m_pcTempBuffer;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char *Packet::GetPacket()
{
	if (m_pcCompleteBuffer != NULL)
	{
		if (!m_bSplit)
			memcpy(m_pcCompleteBuffer, GetHeader(), sizeof(PacketHeader_Struct));

		return m_pcCompleteBuffer;
	}
	else
	{
		delete[] m_pcTempBuffer;
		m_pcTempBuffer = NULL;

		m_pcTempBuffer = new char[m_dwSize + sizeof(PacketHeader_Struct)];
		memcpy(m_pcTempBuffer, GetHeader(), sizeof(PacketHeader_Struct));
		memcpy2(m_pcTempBuffer + sizeof(PacketHeader_Struct), m_pcBuffer, m_dwSize);

		return m_pcTempBuffer;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char *Packet::DetachPacket()
{
	if (m_pcCompleteBuffer != NULL)
	{
		if (!m_bSplit)
			memcpy(m_pcCompleteBuffer, GetHeader(), sizeof(PacketHeader_Struct));

		char	*pcResult = m_pcCompleteBuffer;

		m_pcCompleteBuffer = NULL;
		m_pcBuffer = NULL;

		return pcResult;
	}
	else
	{
		delete[] m_pcTempBuffer;
		m_pcTempBuffer = NULL;

		m_pcTempBuffer = new char[m_dwSize + sizeof(PacketHeader_Struct)];
		memcpy(m_pcTempBuffer, GetHeader(), sizeof(PacketHeader_Struct));
		memcpy2(m_pcTempBuffer + sizeof(PacketHeader_Struct), m_pcBuffer, m_dwSize);

		char	*pcResult = m_pcTempBuffer;

		m_pcTempBuffer = NULL;
		return pcResult;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char *Packet::GetHeader()
{
	ASSERT(!m_bSplit);

	PacketHeader_Struct		*pHeaderStruct = reinterpret_cast<PacketHeader_Struct*>(m_arrcHead);

	pHeaderStruct->eCommand = m_eOpcode;
	pHeaderStruct->byteEDonkeyProtocol = m_byteProtocol;
	pHeaderStruct->dwPacketLength = m_dwSize + 1;
	return m_arrcHead;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
char *Packet::GetUDPHeader()
{
	ASSERT(!m_bSplit);

	UDP_Header_Struct	*pUDPHeader = reinterpret_cast<UDP_Header_Struct*>(m_arrcHead);

	pUDPHeader->eCommand = m_eOpcode;
	pUDPHeader->byteEDonkeyProtocol = m_byteProtocol;

	return m_arrcHead;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void Packet::PackPacket()
{
	ASSERT(!m_bSplit);

	uLongf	dwNewSize = m_dwSize + 300;
	BYTE	*pbyteOutput = new BYTE[dwNewSize];
//	Zip 'm_pcBuffer' to 'pbyteOutput'.
	int		iResult = compress2(pbyteOutput,&dwNewSize,reinterpret_cast<BYTE*>(m_pcBuffer),m_dwSize,9);

//	If the compressed buffer is actually larger than the original...
	if ((iResult != Z_OK) || (m_dwSize <= dwNewSize))
	{
		delete[] pbyteOutput;
		return;
	}
	m_byteProtocol = OP_PACKEDPROT;
	memcpy2(m_pcBuffer, pbyteOutput, m_dwSize = dwNewSize);
	delete[] pbyteOutput;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool Packet::UnpackPacket(uint32 dwMaxUnpackedSize /*= 0*/)
{
	ASSERT(m_byteProtocol == OP_PACKEDPROT);

	if (dwMaxUnpackedSize == 0)
		dwMaxUnpackedSize = m_dwSize * 10 + 300;
	
	uLongf	dwUnpackedSize = dwMaxUnpackedSize;
	BYTE	*pbyteUnpackBuffer = new BYTE[dwUnpackedSize];
	int		iResult = uncompress(pbyteUnpackBuffer, &dwUnpackedSize, reinterpret_cast<BYTE*>(m_pcBuffer), m_dwSize);

	if (iResult == Z_OK)
	{
		ASSERT(m_pcCompleteBuffer == NULL);
		ASSERT(m_pcBuffer != NULL);
		m_dwSize = dwUnpackedSize;
		delete[] m_pcBuffer;
		m_pcBuffer = reinterpret_cast<char*>(pbyteUnpackBuffer);
		m_byteProtocol = OP_EMULEPROT;
		return true;
	}
	delete[] pbyteUnpackBuffer;

	return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CTag
CTag::CTag(const char *pcName, uint32 dwValue)
{
	m_qwValue = static_cast<uint64>(dwValue);
	m_pcName = _strdup(pcName);
	m_byteTagType = TAGTYPE_UINT32;
	m_byteTagID = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag(byte byteTagID, uint32 dwValue)
{
	m_qwValue = static_cast<uint64>(dwValue);
	m_pcName = NULL;
	m_byteTagType = TAGTYPE_UINT32;
	m_byteTagID = byteTagID;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag(const char *pcName, const TCHAR *pcValue)
{
	m_pstrValue = new CString(pcValue);
	m_pcName = _strdup(pcName);
	m_byteTagType = TAGTYPE_STRING;
	m_byteTagID = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag(byte byteTagID, const TCHAR *pcValue)
{
	m_pstrValue = new CString(pcValue);
	m_pcName = NULL;
	m_byteTagType = TAGTYPE_STRING;
	m_byteTagID = byteTagID;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag(byte byteTagID, const byte *pbyteHash)
{
	m_pData = malloc(16);
	md4cpy(m_pData, pbyteHash);
	m_pcName = NULL;
	m_byteTagType = TAGTYPE_HASH;
	m_byteTagID = byteTagID;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag(byte byteTagID, uint32 dwSize, const byte *pbyteData)
{
	m_pData = malloc(dwSize);
	memcpy2(m_pData, pbyteData, m_dwBlobSize = dwSize);
	m_pcName = NULL;
	m_byteTagType = TAGTYPE_BLOB;
	m_byteTagID = byteTagID;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag()
{
	m_qwValue = 0;
	m_pcName = NULL;
	m_byteTagType = TAGTYPE_NONE;
	m_byteTagID = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::CTag(const CTag &Tag)
{
	m_byteTagType = Tag.m_byteTagType;
	m_byteTagID = Tag.m_byteTagID;
	m_pcName = (Tag.m_pcName != NULL) ? _strdup(Tag.m_pcName) : NULL;
	m_dwBlobSize = 0;
	if (Tag.IsStr())
		m_pstrValue = new CString(Tag.GetStringValue());
	else if (Tag.IsAnyInt())
		Tag.GetInt64Value(&m_qwValue);
	else if (Tag.IsFloat())
		m_fValue = Tag.GetFloatValue();
	else if (Tag.IsHash())
	{
		m_pData = malloc(16);
		md4cpy(m_pData, Tag.GetHashValue());
	}
	else if (Tag.IsBlob())
	{
		m_pData = malloc(m_dwBlobSize = Tag.GetBlobSize());
		memcpy(m_pData, Tag.GetBlobPtr(), m_dwBlobSize);
	}
	else
	{
		ASSERT(0);
		m_qwValue = 0;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Setup a tag from a CFile stream
//	(it shouldn't be a constructor to avoid memory leaks of dynamic members)
void CTag::FillFromStream(CFile &file, ECodingFormat eCF/*=cfLocalCodePage*/)
{
	uint32	dwLength;
	uint16	uTmp;
	byte	byteType, byteOctet;

	file.Read(&byteType, 1);
	if (byteType & 0x80)
	{
		byteType &= 0x7F;
		file.Read(&m_byteTagID, 1);
	}
	else
	{
		file.Read(&uTmp, 2);
	//	Read the tag identifier; Either a special tag code or a tag name
		if ((dwLength = uTmp) == 1)
			file.Read(&m_byteTagID, 1);
		else
		{
			m_pcName = reinterpret_cast<char*>(malloc(dwLength + 1));
			file.Read(m_pcName, dwLength);
			m_pcName[dwLength] = '\0';
		}
	}

	m_dwBlobSize = 0;

//	NOTE: It's very important that we read the *entire* packet data, even if we do not use each tag
	if (byteType == TAGTYPE_STRING)
	{
		file.Read(&uTmp, 2);
		dwLength = uTmp;
		m_pstrValue = new CString();
		m_byteTagType = TAGTYPE_STRING;	//	set type after allocation, but before reading to free memory on exception
		ReadMB2Str(eCF, m_pstrValue, file, dwLength);
	}
	else if (byteType == TAGTYPE_UINT32)
	{
		m_byteTagType = TAGTYPE_UINT32;
		file.Read(&dwLength, 4);
		m_qwValue = static_cast<uint64>(dwLength);
	}
	else if (byteType == TAGTYPE_UINT16)
	{
		m_byteTagType = TAGTYPE_UINT32;
		file.Read(&uTmp, 2);
		m_qwValue = static_cast<uint64>(uTmp);
	}
	else if (byteType == TAGTYPE_UINT8)
	{
		m_byteTagType = TAGTYPE_UINT32;
		file.Read(&byteOctet, 1);
		m_qwValue = static_cast<uint64>(byteOctet);
	}
	else if (byteType == TAGTYPE_UINT64)
	{
		m_byteTagType = TAGTYPE_UINT64;
		file.Read(&m_qwValue, 8);
	}
	else if ((byteType >= TAGTYPE_STR1) && (byteType <= TAGTYPE_STR16))
	{
		dwLength = byteType - TAGTYPE_STR1 + 1;
		m_pstrValue = new CString();
		m_byteTagType = TAGTYPE_STRING;	//	set type after allocation, but before reading to free memory on exception
		ReadMB2Str(eCF, m_pstrValue, file, dwLength);
	}
	else if (byteType == TAGTYPE_FLOAT32) // (used by Hybrid 0.48)
	{
		m_byteTagType = TAGTYPE_FLOAT32;
		file.Read(&m_fValue, 4);
	}
	else if (byteType == TAGTYPE_HASH)
	{
		m_pData = malloc(16);
		m_byteTagType = TAGTYPE_HASH;	//	set type after allocation, but before reading to free memory on exception
		file.Read(m_pData, 16);
	}
	else if (byteType == TAGTYPE_BOOL)
	{
		m_byteTagType = TAGTYPE_BOOL;
		file.Seek(1, CFile::current);
	}
	else if (byteType == TAGTYPE_BOOLARRAY)
	{
		m_byteTagType = TAGTYPE_BOOLARRAY;
		file.Read(&uTmp, 2);
		file.Seek((uTmp / 8) + 1, CFile::current);
	}
	else if (byteType == TAGTYPE_BLOB)
	{
		file.Read(&dwLength, 4);
		if (dwLength <= (file.GetLength() - file.GetPosition()))
		{
			m_pData = malloc(dwLength);
			m_byteTagType = TAGTYPE_BLOB;	//	set type after allocation, but before reading to free memory on exception
			file.Read(m_pData, m_dwBlobSize = dwLength);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CTag::~CTag()
{
	if (m_pcName != NULL)
		free(m_pcName);
	if (IsStr())
		delete m_pstrValue;
	else if ((IsHash() || IsBlob()) && (m_pData != NULL))
		free(m_pData);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTag::WriteNewEd2kTag(CFile &file, ECodingFormat eCF/*=cfLocalCodePage*/) const
{
	byte		byteType = m_byteTagType;
	uint32		dwVal, dwStrValLen = 0;
	CStringA	strValA;

	if (byteType == TAGTYPE_UINT64)
	{
		if (m_qwValue <= 0xFFFFFFFFui64)
			byteType = TAGTYPE_UINT32;
	}
	if (byteType == TAGTYPE_UINT32)
	{
		dwVal = static_cast<uint32>(m_qwValue);
		if (dwVal <= 0xFF)
			byteType = TAGTYPE_UINT8;
		else if (dwVal <= 0xFFFF)
			byteType = TAGTYPE_UINT16;
	}
	else if (byteType == TAGTYPE_STRING)
	{
		dwStrValLen = Str2MB(eCF, &strValA, *m_pstrValue);
		if ((dwStrValLen >= 1) && (dwStrValLen <= 16))
			byteType = static_cast<byte>(TAGTYPE_STR1 + dwStrValLen - 1);
	}

//	Write tag type/name
	if (m_pcName != NULL)
	{
		uint32	dwTagNameLen = strlen(m_pcName);

		file.Write(&byteType, 1);
		file.Write(&dwTagNameLen, 2);
		file.Write(m_pcName, dwTagNameLen);
	}
	else
	{
		byte	byteTmp = byteType | 0x80;

		file.Write(&byteTmp, 1);
		file.Write(&m_byteTagID, 1);
	}

//	Write tag data
	if (byteType == TAGTYPE_STRING)
	{
		file.Write(&dwStrValLen, 2);
		file.Write(strValA.GetString(), dwStrValLen);
	}
	else if ((byteType >= TAGTYPE_STR1) && (byteType <= TAGTYPE_STR16))
		file.Write(strValA.GetString(), dwStrValLen);
	else if (byteType == TAGTYPE_UINT32)
		file.Write(&m_qwValue, 4);
	else if (byteType == TAGTYPE_UINT16)
		file.Write(&m_qwValue, 2);
	else if (byteType == TAGTYPE_UINT8)
		file.Write(&m_qwValue, 1);
	else if (byteType == TAGTYPE_UINT64)
		file.Write(&m_qwValue, 8);
	else if (byteType == TAGTYPE_FLOAT32)
		file.Write(&m_fValue, 4);
	else if (byteType == TAGTYPE_HASH)
		file.Write(m_pData, 16);
	else if (byteType == TAGTYPE_BLOB)
	{
		file.Write(&m_dwBlobSize, 4);
		file.Write(m_pData, m_dwBlobSize);
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CTag::WriteToFile(CFile &file, ECodingFormat eCF/*=cfLocalCodePage*/) const
{
	uint16	uLength;

	file.Write(&m_byteTagType, 1);

//	Write the tag identifier; Either a special tag code or the tag name
	if (m_pcName != NULL)
	{
		uLength = static_cast<uint16>(strlen(m_pcName));
		file.Write(&uLength, 2);
		file.Write(m_pcName, uLength);
	}
	else
	{
		uLength = 1;
		file.Write(&uLength, 2);
		file.Write(&m_byteTagID, uLength);
	}

//	Write the tag data value
	if (IsStr())
	{
		CStringA	strValA;

		uLength = static_cast<uint16>(Str2MB(eCF, &strValA, *m_pstrValue));
		file.Write(&uLength, 2);
		file.Write(strValA.GetString(), strValA.GetLength());
	}
	else if (IsInt())
		file.Write(&m_qwValue, 4);
	else if (IsInt64())
		file.Write(&m_qwValue, 8);
	else if (IsFloat())
		file.Write(&m_fValue, 4);
	else if (IsBlob())
	{
		file.Write(&m_dwBlobSize, 4);
		file.Write(m_pData, m_dwBlobSize);
	}
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CTag::ChangeTagID(byte byteNewTagID)
{
	if (m_pcName != NULL)
	{
		free(m_pcName);
		m_pcName = NULL;
	}
	m_byteTagID = byteNewTagID;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CWrNumTag
CWrTag::CWrTag()
{}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteNewEd2kTag(byte byteTagID, uint32 dwValue, CFile &file) const
{
	uint32	dwSz;
	byte	abyteBuf[6];

	if (dwValue <= 0xFF)
	{
		abyteBuf[0] = TAGTYPE_UINT8 | 0x80;
		dwSz = 3;
	}
	else if (dwValue <= 0xFFFF)
	{
		abyteBuf[0] = TAGTYPE_UINT16 | 0x80;
		dwSz = 4;
	}
	else
	{
		abyteBuf[0] = TAGTYPE_UINT32 | 0x80;
		dwSz = 6;
	}
	abyteBuf[1] = byteTagID;
	POKE_DWORD(&abyteBuf[2], dwValue);

	file.Write(abyteBuf, dwSz);
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteNewEd2kTag(byte byteTagID, uint64 qwValue, CFile &file) const
{
	if (qwValue <= 0xFFFFFFFFui64)
		return WriteNewEd2kTag(byteTagID, static_cast<uint32>(qwValue), file);

	byte	abyteBuf[10];

	abyteBuf[0] = TAGTYPE_UINT64 | 0x80;
	abyteBuf[1] = byteTagID;
	POKE_QWORD(&abyteBuf[2], qwValue);

	file.Write(abyteBuf, sizeof(abyteBuf));
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteToFile(byte byteTagID, uint32 dwValue, CFile &file) const
{
	byte	abyteBuf[8];

	abyteBuf[0] = TAGTYPE_UINT32;
	POKE_WORD(&abyteBuf[1], 1);
	abyteBuf[3] = byteTagID;
	POKE_DWORD(&abyteBuf[4], dwValue);

	file.Write(abyteBuf, sizeof(abyteBuf));
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteToFile(byte byteTagID, uint64 qwValue, CFile &file, bool bInt64) const
{
	if (!bInt64)
		return WriteToFile(byteTagID, static_cast<uint32>(qwValue), file);

	byte	abyteBuf[12];

	abyteBuf[0] = TAGTYPE_UINT64;
	POKE_WORD(&abyteBuf[1], 1);
	abyteBuf[3] = byteTagID;
	POKE_QWORD(&abyteBuf[4], qwValue);

	file.Write(abyteBuf, sizeof(abyteBuf));
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteNewEd2kTag(LPCSTR strName, uint64 qwValue, CFile &file) const
{
	uint32	dwVal, dwSz, dwLen = strlen(strName);
	byte	abyteBuf[3];

	if (qwValue <= 0xFFFFFFFFui64)
	{
		dwVal = static_cast<uint32>(qwValue);
		if (dwVal <= 0xFF)
		{
			abyteBuf[0] = TAGTYPE_UINT8;
			dwSz = 1;
		}
		else if (dwVal <= 0xFFFF)
		{
			abyteBuf[0] = TAGTYPE_UINT16;
			dwSz = 2;
		}
		else
		{
			abyteBuf[0] = TAGTYPE_UINT32;
			dwSz = 4;
		}
	}
	else
	{
		abyteBuf[0] = TAGTYPE_UINT64;
		dwSz = 8;
	}
	POKE_WORD(&abyteBuf[1], static_cast<uint16>(dwLen));

	file.Write(abyteBuf, sizeof(abyteBuf));
	file.Write(strName, dwLen);
	file.Write(&qwValue, dwSz);
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteToFile(LPCSTR strName, uint64 qwValue, CFile &file, bool bInt64) const
{
	uint32	dwSz, dwLen = strlen(strName);
	byte	abyteBuf[3];

	if (bInt64)
	{
		abyteBuf[0] = TAGTYPE_UINT64;
		dwSz = 8;
	}
	else
	{
		abyteBuf[0] = TAGTYPE_UINT32;
		dwSz = 4;
	}
	POKE_WORD(&abyteBuf[1], static_cast<uint16>(dwLen));

	file.Write(abyteBuf, sizeof(abyteBuf));
	file.Write(strName, dwLen);
	file.Write(&qwValue, dwSz);
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteNewEd2kTag(byte byteTagID, const CString &strValue, CFile &file, ECodingFormat eCF/*=cfLocalCodePage*/) const
{
	byte	byteType, abyteBuf[4];
	uint32	dwSz, dwStrLen;
	CStringA	strMultiByteBuf;

	Str2MB(eCF, &strMultiByteBuf, strValue);
	dwStrLen = strMultiByteBuf.GetLength();

	byteType = static_cast<byte>(((dwStrLen >= 1) && (dwStrLen <= 16)) ? (TAGTYPE_STR1 + dwStrLen - 1) : TAGTYPE_STRING);

	abyteBuf[0] = byteType | 0x80;
	abyteBuf[1] = byteTagID;

	dwSz = 2;
	if (byteType == TAGTYPE_STRING)
	{
		dwSz = 4;
		POKE_WORD(&abyteBuf[2], static_cast<uint16>(dwStrLen));
	}
	file.Write(abyteBuf, dwSz);
	file.Write(strMultiByteBuf.GetString(), dwStrLen);

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CWrTag::WriteToFile(byte byteTagID, const CString &strValue, CFile &file, ECodingFormat eCF/*=cfLocalCodePage*/) const
{
	byte		abyteBuf[6];
	CStringA	strMultiByteBuf;

	Str2MB(eCF, &strMultiByteBuf, strValue);

	abyteBuf[0] = TAGTYPE_STRING;
	POKE_WORD(&abyteBuf[1], 1);
	abyteBuf[3] = byteTagID;
	POKE_WORD(&abyteBuf[4], static_cast<uint16>(strMultiByteBuf.GetLength()));

	file.Write(abyteBuf, sizeof(abyteBuf));
	file.Write(strMultiByteBuf.GetString(), strMultiByteBuf.GetLength());

	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.48
log
@Fixed saving some string tags to .met files when Unicode is enabled.
@
text
@d66 2
a67 5
//	Packet(EnumOpCodes,uint32,eProtocol,bool) constructs a Packet with the spec'd opcode, data size, and protocol.
//		'bFromPF' is only used to set the "from PartFile" state of the Packet. If 'm_bFromPF' = false then this
//		packet was formed from a complete shared file rather than a part file.
//		It is used only in the UploadClient to track transferred data stats.
Packet::Packet(EnumOpcodes eOpcode, uint32 dwSize/*=0*/, byte byteProtocol/*=OP_EDONKEYPROT*/, bool bFromPF/*=true*/)
a68 1
	m_bFromPF = bFromPF;
d80 2
a81 2
		m_pcBuffer = 0;
		m_pcCompleteBuffer = 0;
d91 3
d106 2
a107 2
		m_pcBuffer = 0;
		m_pcCompleteBuffer = 0;
d244 1
a244 1
	int		iResult = uncompress(pbyteUnpackBuffer,&dwUnpackedSize,reinterpret_cast<BYTE*>(m_pcBuffer),m_dwSize);
@


1.47
log
@Suppressed compiler warnings; Formatting.
@
text
@d464 1
a464 1
bool CTag::WriteNewEd2kTag(CFile &file) const
d468 1
a468 1
	const char	*pcValA = NULL;
d485 1
a485 5
#ifdef _UNICODE
#else
		dwStrValLen = m_pstrValue->GetLength();
		pcValA = *m_pstrValue;
#endif
d511 1
a511 1
		file.Write(pcValA, dwStrValLen);
d514 1
a514 1
		file.Write(pcValA, dwStrValLen);
d535 1
a535 1
bool CTag::WriteToFile(CFile &file) const
d558 3
a560 1
		uLength = static_cast<uint16>(m_pstrValue->GetLength());
d562 1
a562 1
		file.Write(m_pstrValue->GetString(), uLength);
@


1.46
log
@added Unicode support for met-files
@
text
@d119 1
a119 1
	m_dwSize = pDataFile->GetLength();
d353 1
a353 1
void CTag::FillFromStream(CFile &file, ECodingFormat eUTF8)
d388 1
a388 1
		ReadMB2Str(eUTF8, m_pstrValue, file, dwLength);
d418 1
a418 1
		ReadMB2Str(eUTF8, m_pstrValue, file, dwLength);
d548 1
a548 1
		uLength = strlen(m_pcName);
d562 1
a562 1
		uLength = m_pstrValue->GetLength();
d695 1
a695 1
	POKE_WORD(&abyteBuf[1], dwLen);
d718 1
a718 1
	POKE_WORD(&abyteBuf[1], dwLen);
d726 1
a726 1
bool CWrTag::WriteNewEd2kTag(byte byteTagID, const CString &strValue, CFile &file, ECodingFormat eCF) const
d744 1
a744 1
		POKE_WORD(&abyteBuf[2], dwStrLen);
d752 1
a752 1
bool CWrTag::WriteToFile(byte byteTagID, const CString &strValue, CFile &file, ECodingFormat eCF) const
d762 1
a762 1
	POKE_WORD(&abyteBuf[4], strMultiByteBuf.GetLength());
@


1.45
log
@#include was moved to C-file.
@
text
@d353 1
a353 1
void CTag::FillFromStream(CFile &file)
d388 1
a388 2
		file.Read(m_pstrValue->GetBuffer(dwLength), dwLength);
		m_pstrValue->ReleaseBuffer(dwLength);
d418 1
a418 2
		file.Read(m_pstrValue->GetBuffer(dwLength), dwLength);
		m_pstrValue->ReleaseBuffer(dwLength);
d726 1
a726 1
bool CWrTag::WriteNewEd2kTag(byte byteTagID, const CString &strValue, CFile &file) const
d729 5
a733 1
	uint32	dwSz, dwStrLen = strValue.GetLength();
d747 2
a748 1
	file.Write(strValue, dwStrLen);
d752 1
a752 1
bool CWrTag::WriteToFile(byte byteTagID, const CString &strValue, CFile &file) const
d754 4
a757 1
	byte	abyteBuf[6];
d762 1
a762 1
	POKE_WORD(&abyteBuf[4], strValue.GetLength());
d765 2
a766 1
	file.Write(strValue, strValue.GetLength());
@


1.44
log
@Packet length structure field was changed from signed to unsigned.
@
text
@d21 1
@


1.43
log
@Fixed overhead statistics for amount of data sent by auxiliary compressed packets (showed amount was higher than actual).
@
text
@d47 1
a47 1
	m_dwSize = pHeaderStruct->lPacketLength - 1;
d199 1
a199 1
	pHeaderStruct->lPacketLength = m_dwSize + 1;
@


1.42
log
@Removed unused variable.
@
text
@d231 1
a231 1
	memcpy2(m_pcBuffer, pbyteOutput, dwNewSize);
@


1.41
log
@Encryption preparations; Simplified processing of the protocol variable;
Modified contractors to avoid potential compiling issue due to type collision.
@
text
@a37 1
	m_bPacked = false;
a42 1
	m_bPacked = false;
a56 1
	m_bPacked = false;
a72 1
	m_bPacked = false;
a95 1
	m_bPacked = false;
a116 1
	m_bPacked = false;
a232 1
	m_bPacked = true;
@


1.40
log
@Added 64bit tag support; Formatting.
@
text
@d29 1
a29 1
Packet::Packet(EnumProtocols eProtocol)
d37 1
a37 1
	m_eProtocol = eProtocol;
d49 3
a51 3
	m_dwSize = pHeaderStruct->m_lPacketLength-1;
	m_eOpcode = pHeaderStruct->m_eCommand;
	m_eProtocol = pHeaderStruct->m_eEDonkeyProtocol;
d64 2
a65 1
	m_dwSize = dwSize-sizeof(PacketHeader_Struct);
d72 1
a72 1
Packet::Packet(EnumOpcodes eOpcode, uint32 dwSize/*=0*/,EnumProtocols eProtocol/*=OP_EDONKEYPROT*/, bool bFromPF/*=true*/)
d92 1
a92 1
	m_eProtocol = eProtocol;
d95 1
a95 1
Packet::Packet(EnumOpcodes eOpcode, uint32 dwSize, EnumProtocols eProtocol, byte byteFilePriority, bool bFromPF)
d116 1
a116 1
	m_eProtocol = eProtocol;
d119 1
a119 1
Packet::Packet(CMemFile *pDataFile, EnumProtocols eProtocol)
d133 1
a133 1
	m_eProtocol = eProtocol;
d203 3
a205 3
	pHeaderStruct->m_eCommand = m_eOpcode;
	pHeaderStruct->m_eEDonkeyProtocol =  m_eProtocol;
	pHeaderStruct->m_lPacketLength = m_dwSize+1;
d215 2
a216 2
	pUDPHeader->m_eCommand = m_eOpcode;
	pUDPHeader->m_eEDonkeyProtocol =  m_eProtocol;
d236 1
a236 1
	m_eProtocol = OP_PACKEDPROT;
d244 1
a244 1
	ASSERT(m_eProtocol == OP_PACKEDPROT);
d260 2
a261 2
		m_eProtocol =  OP_EMULEPROT;
		return true;				
@


1.39
log
@Allocate exact memory required for packets (without extra bytes).
@
text
@d140 2
a141 3
		delete [] m_pcBuffer;
	if (m_pcTempBuffer != NULL)
		delete[] m_pcTempBuffer;
d224 2
a225 2
	BYTE	*pbyteOutput = new BYTE[m_dwSize+300];
	uLongf	dwNewSize = m_dwSize+300;
d243 1
a243 1
	ASSERT(m_eProtocol == OP_PACKEDPROT); 
d246 1
a246 1
		dwMaxUnpackedSize = m_dwSize*10+300;
a247 1
	BYTE	*pbyteUnpackBuffer = new BYTE[dwMaxUnpackedSize];
d249 1
d271 1
a271 1
	m_dwValue = dwValue;
d279 1
a279 1
	m_dwValue = dwValue;
d321 1
a321 1
	m_dwValue = 0;
d335 2
a336 2
	else if (Tag.IsInt())
		m_dwValue = Tag.GetIntValue();
d352 1
a352 1
		m_dwValue = 0;
d362 1
a362 1
	byte	byteType;
d399 2
a400 1
		file.Read(&m_dwValue, 4);
d406 1
a406 1
		m_dwValue = uTmp;
a409 2
		byte	byteOctet;

d412 6
a417 1
		m_dwValue = byteOctet;
d474 1
a474 1
	uint32		dwStrValLen = 0;
d477 5
d484 2
a485 1
		if (m_dwValue <= 0xFF)
d487 1
a487 1
		else if (m_dwValue <= 0xFFFF)
d527 1
a527 1
		file.Write(&m_dwValue, 4);
d529 1
a529 1
		file.Write(&m_dwValue, 2);
d531 3
a533 1
		file.Write(&m_dwValue, 1);
d548 2
d555 3
a557 4
		uint16	uTagLength = strlen(m_pcName);

		file.Write(&uTagLength, 2);
		file.Write(m_pcName, uTagLength);
d561 3
a563 4
		uint16	uTagLength = 1;

		file.Write(&uTagLength, 2);
		file.Write(&m_byteTagID, uTagLength);
d569 3
a571 4
		uint16		uStrLength = m_pstrValue->GetLength();

		file.Write(&uStrLength, 2);
		file.Write(m_pstrValue->GetString(), uStrLength);
d574 3
a576 3
	{
		file.Write(&m_dwValue, 4);
	}
a577 1
	{
a578 1
	}
d629 15
d657 17
a673 1
bool CWrTag::WriteNewEd2kTag(LPCSTR strName, uint32 dwValue, CFile &file) const
d675 1
a675 1
	uint32	dwSz, dwLen = strlen(strName);
d678 1
a678 1
	if (dwValue <= 0xFF)
d680 16
a695 7
		abyteBuf[0] = TAGTYPE_UINT8;
		dwSz = 1;
	}
	else if (dwValue <= 0xFFFF)
	{
		abyteBuf[0] = TAGTYPE_UINT16;
		dwSz = 2;
d699 2
a700 2
		abyteBuf[0] = TAGTYPE_UINT32;
		dwSz = 4;
d706 1
a706 1
	file.Write(&dwValue, dwSz);
d710 1
a710 1
bool CWrTag::WriteToFile(LPCSTR strName, uint32 dwValue, CFile &file) const
d712 1
a712 1
	uint32	dwLen = strlen(strName);
d715 10
a724 1
	abyteBuf[0] = TAGTYPE_UINT32;
d729 1
a729 1
	file.Write(&dwValue, 4);
d738 1
a738 1
	byteType = ((dwStrLen >= 1) && (dwStrLen <= 16)) ? (TAGTYPE_STR1 + dwStrLen - 1) : TAGTYPE_STRING;
@


1.38
log
@Corrected packet memory allocation to allocate only exact required amount;
Proper type casting.
@
text
@d71 1
a71 1
Packet::Packet(EnumOpcodes eOpcode,uint32 dwSize/*=0*/,EnumProtocols eProtocol/*=OP_EDONKEYPROT*/,bool bFromPF/*=true*/)
d80 3
a82 3
		m_pcCompleteBuffer = new char[dwSize + 10];
		m_pcBuffer = m_pcCompleteBuffer+6;
		memzero(m_pcCompleteBuffer, dwSize + 10);
d104 3
a106 3
		m_pcCompleteBuffer = new char[dwSize + 10];
		m_pcBuffer = m_pcCompleteBuffer+6;
		memzero(m_pcCompleteBuffer, dwSize + 10);
d124 1
a124 1
	m_pcCompleteBuffer = new char[m_dwSize + 10];	//why 10?
@


1.37
log
@Corrected used return data type.
@
text
@d156 4
a159 6
		if (m_pcTempBuffer != NULL)
		{
			delete[] m_pcTempBuffer;
			m_pcTempBuffer = NULL;
		}
		m_pcTempBuffer = new char[m_dwSize+10];	// Why 10?
d183 2
a184 5
		if (m_pcTempBuffer != NULL)
		{
			delete[] m_pcTempBuffer;
			m_pcTempBuffer = NULL;
		}
d186 1
a186 1
		m_pcTempBuffer = new char[m_dwSize+10];	// Why 10?
d489 1
a489 1
			byteType = TAGTYPE_STR1 + dwStrValLen - 1;
@


1.36
log
@Teeny tiny optimization; Formatting.
@
text
@d230 2
a231 3
	BYTE		*pbyteOutput = new BYTE[m_dwSize+300];

	uLongf		dwNewSize = m_dwSize+300;
d233 1
a233 1
	uint16		nResult = compress2(pbyteOutput,&dwNewSize,reinterpret_cast<BYTE*>(m_pcBuffer),m_dwSize,9);
d236 1
a236 1
	if (nResult != Z_OK || m_dwSize <= dwNewSize)
d254 3
a256 4
	BYTE		*pbyteUnpackBuffer = new BYTE[dwMaxUnpackedSize];

	uLongf		dwUnpackedSize = dwMaxUnpackedSize;
	uint16		nResult = uncompress(pbyteUnpackBuffer,&dwUnpackedSize,reinterpret_cast<BYTE*>(m_pcBuffer),m_dwSize);
d258 1
a258 1
	if (nResult == Z_OK)
@


1.35
log
@Show media information (length, bitrate and codec) for search results.
@
text
@d118 1
a118 1
Packet::Packet(CMemFile *pDataFile,EnumProtocols eProtocol)
d124 2
a125 2
	m_pcCompleteBuffer = new char[pDataFile->GetLength()+10];	//why 10?
	m_pcBuffer = m_pcCompleteBuffer+sizeof(PacketHeader_Struct);
a254 2
	//uint32		nNewSize = m_dwSize*10+300;

@


1.34
log
@Fixed memory deallocation while processing wrong packets.
@
text
@d588 10
@


1.33
log
@Fixed tag processing what caused file writing issues and crashes after file was added from search.
@
text
@d372 1
d374 2
a375 2
	file.Read(&m_byteTagType, 1);
	if (m_byteTagType & 0x80)
d377 1
a377 1
		m_byteTagType &= 0x7F;
d397 1
a397 1
	if (m_byteTagType == TAGTYPE_STRING)
d402 1
d406 1
a406 1
	else if (m_byteTagType == TAGTYPE_UINT32)
d408 1
d411 1
a411 1
	else if (m_byteTagType == TAGTYPE_UINT16)
d413 1
a415 1
		m_byteTagType = TAGTYPE_UINT32;
d417 1
a417 1
	else if (m_byteTagType == TAGTYPE_UINT8)
d421 1
a423 1
		m_byteTagType = TAGTYPE_UINT32;
d425 1
a425 1
	else if ((m_byteTagType >= TAGTYPE_STR1) && (m_byteTagType <= TAGTYPE_STR16))
d427 1
a427 1
		dwLength = m_byteTagType - TAGTYPE_STR1 + 1;
d429 1
a431 1
		m_byteTagType = TAGTYPE_STRING;
d433 1
a433 1
	else if (m_byteTagType == TAGTYPE_FLOAT32) // (used by Hybrid 0.48)
d435 1
d438 1
a438 1
	else if (m_byteTagType == TAGTYPE_HASH)
d441 1
d444 1
a444 1
	else if (m_byteTagType == TAGTYPE_BOOL)
d446 1
d449 1
a449 1
	else if (m_byteTagType == TAGTYPE_BOOLARRAY)
d451 1
d455 1
a455 1
	else if (m_byteTagType == TAGTYPE_BLOB)
d461 1
@


1.32
log
@Fixed writing of string tag object
(a fix for revision 1.31; no big impact as it almost isn't used).
@
text
@d337 29
@


1.31
log
@Support new ed2k tag format (client<->server,
as well as used for shared list transfers to eMule v0.43a+ and eMule Plus v1.1a+);
Changed tag interface to avoid memory leaks which could be possible with
new tag object structure.
@
text
@d533 1
a533 1
		file.Write(m_pstrValue, uStrLength);
@


1.30
log
@Removed second file interface support for easier maintaining.
@
text
@d279 1
a279 1
CTag::CTag(LPCSTR strName, uint32 dwValue)
d282 1
a282 1
	m_strName = strName;
d290 1
d295 1
a295 1
CTag::CTag(LPCSTR strName, LPCTSTR strValue)
d297 2
a298 2
	m_strValue = strValue;
	m_strName = strName;
d303 1
a303 1
CTag::CTag(byte byteTagID, LPCTSTR strValue)
d305 2
a306 1
	m_strValue = strValue;
d313 3
a315 2
	m_pbyteData = new byte[16];
	md4cpy(m_pbyteData, pbyteHash);
d322 3
a324 2
	m_pbyteData = new byte[dwSize];
	memcpy2(m_pbyteData, pbyteData, m_dwBlobSize = dwSize);
d329 11
a339 2
//	Construct a tag from a CFile stream.
CTag::CTag(CFile &file)
a343 3
	m_dwValue = 0;
	m_fValue = 0.0f;

d358 3
a360 3
			m_byteTagID = 0;
			file.Read(m_strName.GetBuffer(dwLength), dwLength);
			m_strName.ReleaseBuffer(dwLength);
d364 2
d371 3
a373 2
		file.Read(m_strValue.GetBuffer(dwLength), dwLength);
		m_strValue.ReleaseBuffer(dwLength);
d396 3
a398 2
		file.Read(m_strValue.GetBuffer(dwLength), dwLength);
		m_strValue.ReleaseBuffer(dwLength);
d407 2
a408 1
		file.Seek(16, CFile::current);
d423 4
a426 1
			file.Seek(dwLength, CFile::current);
d432 6
d442 62
d512 1
a512 1
	if (!m_strName.IsEmpty())
d514 1
a514 1
		uint16		nTagLength = m_strName.GetLength();
d516 2
a517 2
		file.Write(&nTagLength,2);
		file.Write(m_strName,nTagLength);
d521 1
a521 1
		uint16		nTagLength = 1;
d523 2
a524 2
		file.Write(&nTagLength, 2);
		file.Write(&m_byteTagID, nTagLength);
d528 1
a528 1
	if (m_byteTagType == TAGTYPE_STRING)
d530 1
a530 1
		uint16		nStrLength = m_strValue.GetLength();
d532 2
a533 2
		file.Write(&nStrLength,2);
		file.Write(m_strValue,nStrLength);
d535 1
a535 1
	else if (m_byteTagType == TAGTYPE_UINT32)
d539 9
@


1.29
log
@Faster memcpy during packet processing.
@
text
@a455 34
bool CTag::WriteToFile(FILE *pFile)
{
	fputc(m_byteTagType, pFile);

//	Write the tag identifier; Either a special tag code or the tag name
	if (!m_strName.IsEmpty())
	{
		uint16		nTagLength = m_strName.GetLength();

		fwrite(&nTagLength,2,1,pFile);
		fwrite(m_strName,nTagLength,1,pFile);
	}
	else
	{
		uint16		nTagLength = 1;

		fwrite(&nTagLength,2,1,pFile);
		fwrite(&m_byteTagID, nTagLength ,1 , pFile);
	}
	if (m_byteTagType == TAGTYPE_STRING)
	{
		uint16		nStrLength = m_strValue.GetLength();

		fwrite(&nStrLength,2,1,pFile);
		fwrite(m_strValue,nStrLength,1,pFile);
	}
	else if (m_byteTagType == TAGTYPE_UINT32)
	{
		fwrite(&m_dwValue, 4, 1, pFile);
	}

	return ferror(pFile);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.28
log
@Optimized parameter tag processing (preparation and parsing).
@
text
@d129 1
a129 1
	memcpy2(m_pcBuffer,pbyteBuffer,m_dwSize);
d150 1
a150 1
			memcpy2(m_pcCompleteBuffer,GetHeader(),sizeof(PacketHeader_Struct));
d162 2
a163 2
		memcpy2(m_pcTempBuffer,GetHeader(),sizeof(PacketHeader_Struct));
		memcpy2(m_pcTempBuffer+sizeof(PacketHeader_Struct),m_pcBuffer,m_dwSize);
d174 1
a174 1
			memcpy2(m_pcCompleteBuffer,GetHeader(),sizeof(PacketHeader_Struct));
d192 2
a193 2
		memcpy2(m_pcTempBuffer,GetHeader(),sizeof(PacketHeader_Struct));
		memcpy2(m_pcTempBuffer+sizeof(PacketHeader_Struct),m_pcBuffer,m_dwSize);
a216 1
	memzero(m_arrcHead, sizeof(PacketHeader_Struct));
d243 1
a243 1
	memcpy2(m_pcBuffer,pbyteOutput,dwNewSize);
@


1.27
log
@Fixed saving of several server parameters to server.met (files, users and AuxPort).
@
text
@a55 1
// -khaos--+++> Slightly modified for our stats uses...
d280 1
a280 2

CTag::CTag(LPCTSTR strName, uint32 dwValue)
d282 1
a282 1
	m_fValue = 0.0f;
d285 1
a285 1
	m_dwValue = dwValue;
d290 1
a290 1
	m_fValue = 0.0f;
a291 1
	m_dwValue = dwValue;
d295 1
a295 1
CTag::CTag(LPCTSTR strName, LPCTSTR strValue)
d297 1
a297 2
	m_dwValue = 0;
	m_fValue = 0.0f;
d300 1
a300 1
	m_strValue = strValue;
d305 1
a305 2
	m_dwValue = 0;
	m_fValue = 0.0f;	
d307 16
a322 1
	m_strValue = strValue;
d327 1
a327 1
CTag::CTag(CFile& file)
d413 10
a422 1
bool CTag::WriteToFile(CFile &file)
d425 1
a425 1
//
d492 122
@


1.26
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d284 1
a284 1
	m_fltValue = 0.0f;
d292 1
a292 1
	m_fltValue = 0.0f;
d301 1
a301 1
	m_fltValue = 0.0f;
d310 1
a310 1
	m_fltValue = 0.0f;	
d323 1
a323 1
	m_fltValue = 0.0f;
d380 1
a380 1
		file.Read(&m_fltValue, 4);
d422 1
a422 1
//
d441 1
a441 1
//
d443 1
a443 1
	if (!m_strName.IsEmpty() && (m_byteTagID == 0))
@


1.25
log
@Add reception of new tags for client to client transmissions;
Updated tag types; Removed unused methods;
Removed all specific templates -- one class will keep everything.
@
text
@d158 1
d160 2
d187 1
d189 2
@


1.24
log
@some changes to make code looking better
@
text
@a273 1

d276 1
a276 12
//
//	Force the instantiation of the Tags template instances so we don't get linker errors.
template class CTag<EnumClientTags>;
template class CTag<EnumFriendTags>;
template class CTag<EnumEmuleTags>;
template class CTag<EnumFileTags>;
template class CTag<EnumServerTags>;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename TagType>
CTag<TagType>::CTag(LPCTSTR strName,uint32 iValue)
d280 2
a281 2
	m_eTagType = TAGTYPE_INT;
	m_iValue = iValue;
d284 1
a284 2
template <typename TagType>
CTag<TagType>::CTag(TagType eSpecialTag, uint32 iValue)
d287 3
a289 3
	m_eTagType = TAGTYPE_INT;
	m_iValue = iValue;
	m_eSpecialTag = eSpecialTag;
d292 1
a292 2
template <typename TagType>
CTag<TagType>::CTag(LPCTSTR strName,LPCTSTR strValue)
d294 1
a294 1
	m_iValue = 0;
d297 1
a297 1
	m_eTagType = TAGTYPE_STRING;
d301 1
a301 2
template <typename TagType>
CTag<TagType>::CTag(TagType eSpecialTag, LPCTSTR strValue)
d303 1
a303 1
	m_iValue = 0;
d305 1
a305 1
	m_eTagType = TAGTYPE_STRING;
d307 1
a307 1
	m_eSpecialTag = eSpecialTag;
d311 1
a311 2
template <typename TagType>
CTag<TagType>::CTag(CFile& file)
d313 4
a316 1
	m_iValue = 0;
a317 4
	file.Read(&m_eTagType,1);
//
//	Read the tag identifier; Either a special tag code or a tag name
	uint16		nLength;
d319 2
a320 2
	file.Read(&nLength,2);
	if (nLength == 1)
d322 2
a323 1
		file.Read(&m_eSpecialTag,1);
d327 10
a336 2
		file.Read(m_strName.GetBuffer(nLength+1),nLength);
		m_strName.ReleaseBuffer(nLength);
d338 3
a340 3
//
//	Read the tag data value
	if (m_eTagType == TAGTYPE_STRING)
d342 4
a345 3
		file.Read(&nLength,2);		
		file.Read(m_strValue.GetBuffer(nLength+1),nLength);
		m_strValue.ReleaseBuffer(nLength);
d347 1
a347 1
	else if (m_eTagType == TAGTYPE_INT)
d349 1
a349 1
		file.Read(&m_iValue,4);
d351 1
a351 1
	else if (m_eTagType == TAGTYPE_FLOAT) // (used by Hybrid 0.48)
d353 3
a355 1
		file.Read(&m_fltValue,4);
d357 3
a359 11
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename TagType>
CTag<TagType>::CTag(FILE *pFile)
{
	m_iValue = 0;
	m_fltValue = 0.0f;
	fread(&m_eTagType,1,1,pFile);
//
//	Read the tag identifier; Either a special tag code or a tag name
	uint16		nLength;
d361 5
a365 2
	fread(&nLength,2,1,pFile);
	if (nLength == 1)
d367 4
a370 1
		fread(&m_eSpecialTag,1,1,pFile);
d372 7
a378 4
	else
	{		
		fread(m_strName.GetBuffer(nLength+1),nLength,1,pFile);
		m_strName.ReleaseBuffer(nLength);
d380 1
a380 3
//
//	Read the tag data value
	if (m_eTagType == TAGTYPE_STRING)
d382 1
a382 3
		fread(&nLength,2,1,pFile);		
		fread(m_strValue.GetBuffer(nLength+1),nLength,1,pFile);
		m_strValue.ReleaseBuffer(nLength);
d384 1
a384 1
	else if (m_eTagType == TAGTYPE_INT)
d386 2
a387 1
		fread(&m_iValue,4,1,pFile);
d389 1
a389 1
	else if (m_eTagType == TAGTYPE_FLOAT)
d391 3
a393 1
		fread(&m_fltValue,4,1,pFile);
d397 1
a397 2
template <typename TagType>
bool CTag<TagType>::WriteToFile(CFile &file)
d399 1
a399 1
	file.Write(&m_eTagType,1);
a411 1
		BYTE		byteSpecialTag = m_eSpecialTag;
d413 2
a414 2
		file.Write(&nTagLength,2);
		file.Write(&byteSpecialTag,nTagLength);
d418 1
a418 1
	if (m_eTagType == TAGTYPE_STRING)
d425 1
a425 1
	else if (m_eTagType == TAGTYPE_INT)
d427 1
a427 1
		file.Write(&m_iValue,4);
d432 1
a432 2
template <typename TagType>
bool CTag<TagType>::WriteToFile(FILE *pFile)
d434 1
a434 1
	fputc(m_eTagType,pFile);
d437 1
a437 1
	if (!m_strName.IsEmpty() && m_eSpecialTag == 0)
a446 1
		BYTE		byteSpecialTag = m_eSpecialTag;
d449 1
a449 1
		fwrite(&byteSpecialTag,nTagLength,1,pFile);
d451 1
a451 1
	if (m_eTagType == TAGTYPE_STRING)
d458 1
a458 1
	else if (m_eTagType == TAGTYPE_INT)
d460 1
a460 1
		fwrite(&m_iValue,4,1,pFile);
@


1.23
log
@1) statistic for file priority
2) optimization in category processing
@
text
@d95 1
a95 1
Packet::Packet(EnumOpcodes eOpcode, uint32 dwSize, EnumProtocols eProtocol, bool bFromPF, byte byteFilePriority)
@


1.22
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d54 1
a54 1
Packet::Packet(char *pcPacketPart, uint32 dwSize, bool bLast, bool bFromPF)
d57 1
d95 24
@


1.21
log
@1) compession support within communicatio client<->server
2) extended UDP file search support
@
text
@d80 1
a80 1
		m_pcCompleteBuffer = new char[dwSize+10];
d82 1
a82 1
		memset2(m_pcCompleteBuffer,0,dwSize+10);
d187 1
a187 1
	memset2(m_arrcHead,0,sizeof(PacketHeader_Struct));
@


1.20
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d219 1
a219 1
bool Packet::UnpackPacket()
d223 4
a226 1
	uint32		nNewSize = m_dwSize*10+300;
d228 1
a228 2
	if (nNewSize > 50000)
		nNewSize = 50000;
d230 1
a230 3
	BYTE		*pbyteUnpackBuffer = new BYTE[nNewSize];

	uLongf		dwUnpackedSize = nNewSize;
@


1.19
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d82 1
a82 1
		memset(m_pcCompleteBuffer,0,dwSize+10);
d187 1
a187 1
	memset(m_arrcHead,0,sizeof(PacketHeader_Struct));
@


1.18
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@a20 1
#include "memcpy_amd.h"
d54 1
a54 1
Packet::Packet(char *pPacketPart, uint32 dwSize, bool bLast, bool bFromPF)
d63 1
a63 1
	m_pcCompleteBuffer = pPacketPart;
d67 5
a71 4
// -khaos--+++> Slightly modified for our stats uses...
//				If m_bFromPF = true then packet was formed from a partfile
//				If m_bFromPF = false then this packet was formed from a complete shared file.
Packet::Packet(EnumOpcodes eOpcode,uint32 dwSize,EnumProtocols eProtocol,bool bFromPF)
@


1.17
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d29 10
a38 8
Packet::Packet(uint8 protocol){
	m_bSplitted = false;
	m_bLastSplitted = false;
	size = 0;
	pBuffer = 0;
	completebuffer = 0;
	tempbuffer = 0;
	prot = protocol;
d41 4
a44 3

Packet::Packet(char* header){
	m_bSplitted = false;
d46 7
a52 8
	m_bLastSplitted = false;
	tempbuffer = 0;
	pBuffer = 0;
	completebuffer = 0;
	Header_Struct* head = (Header_Struct*) header;
	size = head->packetlength-1;
	opcode = head->command;
	prot = head->eDonkeyID;
d54 3
a56 1

a57 2
Packet::Packet(char* pPacketPart, uint32 nSize ,bool bLast, bool bFromPF)
{
d59 1
a59 1
	m_bSplitted = true;
d61 5
a65 5
	m_bLastSplitted = bLast;
	tempbuffer = 0;
	pBuffer = 0;
	completebuffer = pPacketPart;
	size = nSize-6;
d67 1
a67 1

d71 1
a71 1
Packet::Packet(int8 in_opcode,uint32 in_size,uint8 protocol,bool bFromPF)
d74 1
a74 1
	m_bSplitted = false;
d76 63
a138 6
	m_bLastSplitted = false;
	tempbuffer = 0;
	if (in_size){
		completebuffer = new char[in_size+10];
		pBuffer = completebuffer+6;
		memset(completebuffer,0,in_size+10);
d140 29
a168 3
	else{
		pBuffer = 0;
		completebuffer = 0;
a169 3
	opcode = in_opcode;
	size = in_size;
	prot = protocol;
d171 6
d178 7
a184 1
Packet::Packet(CMemFile* datafile,uint8 protocol)
d186 25
a210 84
	m_bSplitted = false;
	m_bPacked = false;
	m_bLastSplitted = false;
	size = datafile->GetLength();
	completebuffer = new char[datafile->GetLength()+10];
	pBuffer = completebuffer+6;
	BYTE* tmp = datafile->Detach();
	memcpy2(pBuffer,tmp,size);
	free(tmp);
	tempbuffer = 0;
	prot = protocol;
}

Packet::~Packet(){
	if (completebuffer)
		delete[] completebuffer;
	else if (pBuffer)
		delete [] pBuffer;
	if (tempbuffer)
		delete[] tempbuffer;
}

char* Packet::GetPacket(){
	if (completebuffer){
		if (!m_bSplitted)
			memcpy2(completebuffer,GetHeader(),6);
		return completebuffer;
	}
	else{
		if (tempbuffer)
			delete[] tempbuffer;
		tempbuffer = new char[size+10];
		memcpy2(tempbuffer,GetHeader(),6);
		memcpy2(tempbuffer+6,pBuffer,size);
		return tempbuffer;
	}
}

char* Packet::DetachPacket(){
	if (completebuffer){
		if (!m_bSplitted)
			memcpy2(completebuffer,GetHeader(),6);
		char* result = completebuffer;
		completebuffer = 0;
		pBuffer = 0;
		return result;
	}
	else{
		if (tempbuffer)
			delete[] tempbuffer;
		tempbuffer = new char[size+10];
		memcpy2(tempbuffer,GetHeader(),6);
		memcpy2(tempbuffer+6,pBuffer,size);
		char* result = tempbuffer;
		tempbuffer = 0;
		return result;
	}
}

char* Packet::GetHeader(){
	ASSERT ( !m_bSplitted );
	Header_Struct* header = (Header_Struct*) head;
	header->command = opcode;
	header->eDonkeyID =  prot;
	header->packetlength = size+1;
	return head;
}

char* Packet::GetUDPHeader(){
	ASSERT ( !m_bSplitted );
	memset(head,0,6);
	UDP_Header_Struct* header = (UDP_Header_Struct*) head;
	header->command = opcode;
	header->eDonkeyID =  prot;
	return head;
}

void Packet::PackPacket(){
	ASSERT (!m_bSplitted);
	BYTE* output = new BYTE[size+300];
	uLongf newsize = size+300;
	uint16 result = compress2(output,&newsize,(BYTE*)pBuffer,size,9);
	if (result != Z_OK || size <= newsize){
		delete[] output;
d213 3
a215 3
	prot = OP_PACKEDPROT;
	memcpy2(pBuffer,output,newsize);
	delete[] output;
d218 6
a224 3
bool Packet::UnPackPacket(){
	ASSERT ( prot == OP_PACKEDPROT); 
	uint32 nNewSize = size*10+300;
d227 14
a240 10
	BYTE* unpack = new BYTE[nNewSize];
	uLongf unpackedsize = nNewSize;
	uint16 result = uncompress(unpack,&unpackedsize,(BYTE*)pBuffer,size);
	if (result == Z_OK){
		ASSERT ( completebuffer == NULL );
		ASSERT ( pBuffer != NULL );
		size = unpackedsize;
		delete[] pBuffer;
		pBuffer = (char*)unpack;
		prot =  OP_EMULEPROT;
d243 2
a244 1
	delete[] unpack;
d247 2
d250 1
d252 158
a409 98
CTag::CTag(LPCTSTR name,uint32 i){	
	floatvalue = 0;
	specialtag = 0;	
	tagname = name;
	type = 3;
	intvalue = i;
}

CTag::CTag(int8 special, uint32 i){
	floatvalue = 0;
	specialtag = 0;
	type = 3;
	intvalue = i;
	specialtag = special;
}

CTag::CTag(LPCTSTR name,LPCTSTR strvalue){	
	intvalue = 0;
	floatvalue = 0;
	specialtag = 0;
	tagname = name;
	type = 2;
	stringvalue = strvalue;
}

CTag::CTag(int8 special, LPCTSTR strvalue){	
	intvalue = 0;
	floatvalue = 0;	
	type = 2;
	stringvalue = strvalue;
	specialtag = special;
}

CTag::CTag(CFile& in_data){	
	intvalue = 0;
	floatvalue = 0;
	specialtag = 0;
	in_data.Read(&type,1);
	uint16 length;
	in_data.Read(&length,2);
	if (length == 1)
		in_data.Read(&specialtag,1);
	else {				
		in_data.Read(tagname.GetBuffer(length+1),length);
		tagname.ReleaseBuffer(length);
	}
	if (type == 2){
		in_data.Read(&length,2);		
		in_data.Read(stringvalue.GetBuffer(length+1),length);
		stringvalue.ReleaseBuffer(length);
	}
	else if (type == 3)
		in_data.Read(&intvalue,4);
	else if (type == 4) // FLOAT (used by Hybrid 0.48)
		in_data.Read(&floatvalue,4);
		
}

CTag::CTag(FILE* in_data){	
	intvalue = 0;
	floatvalue = 0;
	specialtag = 0;
	fread(&type,1,1,in_data);
	uint16 length;
	fread(&length,2,1,in_data);
	if (length == 1)
		fread(&specialtag,1,1,in_data);
	else {		
		fread(tagname.GetBuffer(length+1),length,1,in_data);
		tagname.ReleaseBuffer(length);
	}
	if (type == 2){
		fread(&length,2,1,in_data);		
		fread(stringvalue.GetBuffer(length+1),length,1,in_data);
		stringvalue.ReleaseBuffer(length);
	}
	else if (type == 3)
		fread(&intvalue,4,1,in_data);
	else if (type == 4)
		fread(&floatvalue,4,1,in_data);
}

bool CTag::WriteTagToFile(CFile& file){
	file.Write(&type,1);
	if (!tagname.IsEmpty()){
		uint16 taglen = tagname.GetLength();
		file.Write(&taglen,2);
		file.Write(tagname,taglen);
	}
	else{
		uint16 taglen = 1;
		file.Write(&taglen,2);
		file.Write(&specialtag,taglen);
	}
	if (type == 2){
		uint16 len = stringvalue.GetLength();
		file.Write(&len,2);
		file.Write(stringvalue,len);
a410 2
	else if (type == 3)
		file.Write(&intvalue,4);
d413 25
d439 12
a450 21
bool CTag::WriteTagToFile(FILE* file){
	fputc(type,file);
	if (!tagname.IsEmpty() && (!specialtag)){
		uint16 taglen= tagname.GetLength();
		fwrite(&taglen,2,1,file);
		fwrite(tagname,taglen,1,file);
	}
	else{
		uint16 taglen = 1;
		fwrite(&taglen,2,1,file);
		fwrite(&specialtag,taglen,1,file);
	}
	if (type == 2){
		uint16 len = stringvalue.GetLength();
		fwrite(&len,2,1,file);
		fwrite(stringvalue,len,1,file);
	}
	else if (type == 3)
		fwrite(&intvalue,4,1,file);
	return ferror(file);
}@


1.16
log
@new statistic (khaos based)
@
text
@d99 1
a99 5
	#ifndef AMD
	memcpy(pBuffer,tmp,size);
	#else
	memcpy_amd(pBuffer,tmp,size);
	#endif
d117 1
a117 5
			#ifndef AMD
			memcpy(completebuffer,GetHeader(),6);
			#else
			memcpy_amd(completebuffer,GetHeader(),6);
			#endif
d124 2
a125 7
		#ifndef AMD
		memcpy(tempbuffer,GetHeader(),6);
		memcpy(tempbuffer+6,pBuffer,size);
		#else
		memcpy_amd(tempbuffer,GetHeader(),6);
		memcpy_amd(tempbuffer+6,pBuffer,size);
		#endif
d133 1
a133 5
			#ifndef AMD
			memcpy(completebuffer,GetHeader(),6);
			#else
			memcpy_amd(completebuffer,GetHeader(),6);
			#endif
d143 2
a144 7
		#ifndef AMD
		memcpy(tempbuffer,GetHeader(),6);
		memcpy(tempbuffer+6,pBuffer,size);
		#else
		memcpy_amd(tempbuffer,GetHeader(),6);
		memcpy_amd(tempbuffer+6,pBuffer,size);
		#endif
d179 1
a179 5
	#ifndef AMD
	memcpy(pBuffer,output,newsize);
	#else
	memcpy_amd(pBuffer,output,newsize);
	#endif
@


1.15
log
@simplified...
@
text
@d53 4
a56 1
Packet::Packet(char* pPacketPart, uint32 nSize ,bool bLast){// only used for splitted packets!
d66 6
a71 1
Packet::Packet(int8 in_opcode,uint32 in_size,uint8 protocol){
d90 2
a91 1
Packet::Packet(CMemFile* datafile,uint8 protocol){
@


1.14
log
@char * to CString conversion
@
text
@a231 2
	type = 0;	
	intvalue = 0;
d256 1
a256 12
CTag::CTag(const CTag& t){
	type = t.type;	
	intvalue = t.intvalue;
	floatvalue = t.floatvalue;
	specialtag = t.specialtag;		
	tagname = t.tagname;	
	stringvalue = t.stringvalue;
}

CTag::CTag(CFile& in_data){
	
	type = 0;		
d281 1
a281 2
CTag::CTag(FILE* in_data){
	type = 0;
a304 3
CTag::~CTag(){	
}

d347 1
a347 1
}
@


1.13
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d223 1
a223 5
CTag::CTag(const char* name,uint32 i){
	type = 0;
	tagname = 0;
	stringvalue = 0;	
	intvalue = 0;
d225 2
a226 3
	specialtag = 0;
	
	tagname = nstrdup(name);
d232 1
a232 3
	type = 0;
	tagname = 0;
	stringvalue = 0;	
d241 1
a241 4
CTag::CTag(const char* name,const char* strvalue){
	type = 0;
	tagname = 0;
	stringvalue = 0;	
d245 1
a245 1
	tagname = nstrdup(name);
d247 1
a247 1
	stringvalue = nstrdup(strvalue);
d250 1
a250 4
CTag::CTag(int8 special, const char* strvalue){
	type = 0;
	tagname = 0;
	stringvalue = 0;	
d252 1
a252 2
	floatvalue = 0;
	specialtag = 0;
d254 1
a254 1
	stringvalue = nstrdup(strvalue);
d259 1
a259 3
	type = t.type;
	tagname = 0;
	stringvalue = 0;	
d262 3
a264 5
	specialtag = t.specialtag;	
	if (t.tagname)
		tagname = nstrdup(t.tagname);
	if (t.stringvalue)
		stringvalue = nstrdup(t.stringvalue);
d268 18
a285 34
	try
	{
		type = 0;
		tagname = 0;
		stringvalue = 0;	
		intvalue = 0;
		floatvalue = 0;
		specialtag = 0;
		in_data.Read(&type,1);
		uint16 length;
		in_data.Read(&length,2);
		if (length == 1)
			in_data.Read(&specialtag,1);
		else {
			tagname = new char[length+1];
			in_data.Read(tagname,length);
			tagname[length] = 0;
		}
		if (type == 2){
			in_data.Read(&length,2);
			stringvalue = new char[length+1];
			in_data.Read(stringvalue,length);
			stringvalue[length] = 0;
		}
		else if (type == 3)
			in_data.Read(&intvalue,4);
		else if (type == 4) // FLOAT (used by Hybrid 0.48)
			in_data.Read(&floatvalue,4);
	}
	catch(...)	//clean when invalid file (mem leaks) [TwoBottle Mod]
	{
		delete[] tagname;		
		delete[] stringvalue;				
		throw;
d287 5
a295 2
	tagname = 0;
	stringvalue = 0;	
d304 3
a306 4
	else {
		tagname = new char[length+1];
		fread(tagname,length,1,in_data);
		tagname[length] = 0;
d309 3
a311 4
		fread(&length,2,1,in_data);
		stringvalue = new char[length+1];
		fread(stringvalue,length,1,in_data);
		stringvalue[length] = 0;
d319 1
a319 5
CTag::~CTag(){
	if (tagname)
		delete[] tagname;
	if (stringvalue)
		delete[] stringvalue;
d324 2
a325 2
	if (tagname){
		uint16 taglen= (uint16)strlen(tagname);
d335 1
a335 1
		uint16 len = (uint16)strlen(stringvalue);
d346 2
a347 2
	if (tagname && (!specialtag)){
		uint16 taglen= (uint16)strlen(tagname);
d357 1
a357 1
		uint16 len = (uint16)strlen(stringvalue);
@


1.12
log
@code cleanup
@
text
@d21 1
d89 2
a90 1
	BYTE* tmp = datafile->Detach();;
d92 3
d112 1
d114 3
d123 1
d126 4
d137 1
d139 3
d151 1
d154 4
d192 1
d194 3
d401 1
a401 1
}@


1.11
log
@code cleanup
@
text
@d332 2
a333 2
bool CTag::WriteTagToFile(CFile* file){
	file->Write(&type,1);
d336 2
a337 2
		file->Write(&taglen,2);
		file->Write(tagname,taglen);
d341 2
a342 2
		file->Write(&taglen,2);
		file->Write(&specialtag,taglen);
d346 2
a347 2
		file->Write(&len,2);
		file->Write(stringvalue,len);
d350 1
a350 1
		file->Write(&intvalue,4);
@


1.10
log
@removed Tag_Struct usage from sources
@
text
@d258 1
a258 1
CTag::CTag(CFile* in_data){
d267 1
a267 1
		in_data->Read(&type,1);
d269 1
a269 1
		in_data->Read(&length,2);
d271 1
a271 1
			in_data->Read(&specialtag,1);
d274 1
a274 1
			in_data->Read(tagname,length);
d278 1
a278 1
			in_data->Read(&length,2);
d280 1
a280 1
			in_data->Read(stringvalue,length);
d284 1
a284 1
			in_data->Read(&intvalue,4);
d286 1
a286 1
			in_data->Read(&floatvalue,4);
@


1.9
log
@converted to standard copy constructor
@
text
@d196 23
a218 14
CTag::CTag(const char* name,uint32 intvalue){
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->tagname = nstrdup(name);
	tag->type = 3;
	tag->intvalue = intvalue;
}

CTag::CTag(int8 special, uint32 intvalue){
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->type = 3;
	tag->intvalue = intvalue;
	tag->specialtag = special;
d222 9
a230 5
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->tagname = nstrdup(name);
	tag->type = 2;
	tag->stringvalue = nstrdup(strvalue);
d234 9
a242 5
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->type = 2;
	tag->stringvalue = nstrdup(strvalue);
	tag->specialtag = special;
d246 10
a255 7
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	memcpy(tag,t.tag,sizeof(Tag_Struct));
	if (t.tag->tagname)
		tag->tagname = nstrdup(t.tag->tagname);
	if (t.tag->stringvalue)
		tag->stringvalue = nstrdup(t.tag->stringvalue);
d261 7
a267 3
		tag = new Tag_Struct;
		memset(tag,0,sizeof(Tag_Struct));
		in_data->Read(&tag->type,1);
d271 1
a271 1
			in_data->Read(&tag->specialtag,1);
d273 3
a275 3
			tag->tagname = new char[length+1];
			in_data->Read(tag->tagname,length);
			tag->tagname[length] = 0;
d277 1
a277 1
		if (tag->type == 2){
d279 3
a281 3
			tag->stringvalue = new char[length+1];
			in_data->Read(tag->stringvalue,length);
			tag->stringvalue[length] = 0;
d283 4
a286 4
		else if (tag->type == 3)
			in_data->Read(&tag->intvalue,4);
		else if (tag->type == 4) // FLOAT (used by Hybrid 0.48)
			in_data->Read(&tag->floatvalue,4);
d290 2
a291 3
		delete[] tag->tagname;		
		delete[] tag->stringvalue;		
		delete tag;		
d297 7
a303 3
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	fread(&tag->type,1,1,in_data);
d307 1
a307 1
		fread(&tag->specialtag,1,1,in_data);
d309 3
a311 3
		tag->tagname = new char[length+1];
		fread(tag->tagname,length,1,in_data);
		tag->tagname[length] = 0;
d313 1
a313 1
	if (tag->type == 2){
d315 8
a322 8
		tag->stringvalue = new char[length+1];
		fread(tag->stringvalue,length,1,in_data);
		tag->stringvalue[length] = 0;
	}
	else if (tag->type == 3)
		fread(&tag->intvalue,4,1,in_data);
	else if (tag->type == 4)
		fread(&tag->floatvalue,4,1,in_data);
d326 4
a329 5
	if (tag->tagname)
		delete[] tag->tagname;
	if (tag->stringvalue)
		delete[] tag->stringvalue;
	delete tag;
d333 3
a335 3
	file->Write(&tag->type,1);
	if (tag->tagname){
		uint16 taglen= (uint16)strlen(tag->tagname);
d337 1
a337 1
		file->Write(tag->tagname,taglen);
d342 1
a342 1
		file->Write(&tag->specialtag,taglen);
d344 2
a345 2
	if (tag->type == 2){
		uint16 len = (uint16)strlen(tag->stringvalue);
d347 1
a347 1
		file->Write(tag->stringvalue,len);
d349 2
a350 2
	else if (tag->type == 3)
		file->Write(&tag->intvalue,4);
d355 3
a357 3
	fputc(tag->type,file);
	if (tag->tagname && (!tag->specialtag)){
		uint16 taglen= (uint16)strlen(tag->tagname);
d359 1
a359 1
		fwrite(tag->tagname,taglen,1,file);
d364 1
a364 1
		fwrite(&tag->specialtag,taglen,1,file);
d366 2
a367 2
	if (tag->type == 2){
		uint16 len = (uint16)strlen(tag->stringvalue);
d369 1
a369 1
		fwrite(tag->stringvalue,len,1,file);
d371 2
a372 2
	else if (tag->type == 3)
		fwrite(&tag->intvalue,4,1,file);
@


1.8
log
@changes reverted
@
text
@d228 1
a228 1
CTag::CTag(Tag_Struct* in_tag){
d231 5
a235 5
	memcpy(tag,in_tag,sizeof(Tag_Struct));
	if (in_tag->tagname)
		tag->tagname = nstrdup(in_tag->tagname);
	if (in_tag->stringvalue)
		tag->stringvalue = nstrdup(in_tag->stringvalue);
@


1.7
log
@removed Tag_Struct usage from sources
@
text
@d196 6
a201 7
CTag::CTag(const char* name,uint32 intvalue){	
	stringvalue = 0;		
	floatvalue = 0;	
	specialtag = 0;
	tagname = nstrdup(name);
	type = 3;
	intvalue = intvalue;
d205 5
a209 6
	tagname = 0;
	stringvalue = 0;		
	floatvalue = 0;	
	type = 3;
	intvalue = intvalue;
	specialtag = special;
d212 6
a217 7
CTag::CTag(const char* name,const char* strvalue){	
	intvalue = 0;
	floatvalue = 0;	
	specialtag = 0;
	tagname = nstrdup(name);
	type = 2;
	stringvalue = nstrdup(strvalue);
d221 5
a225 6
	tagname = 0;
	intvalue = 0;
	floatvalue = 0;	
	type = 2;
	stringvalue = nstrdup(strvalue);
	specialtag = special;
d228 4
a231 8

CTag::CTag(const CTag* in_tag){
	
	type = in_tag->type;	
	intvalue = in_tag->intvalue;
	floatvalue = in_tag->floatvalue;	
	specialtag = in_tag->specialtag;
	
d233 1
a233 1
		tagname = nstrdup(in_tag->tagname);
d235 1
a235 1
		stringvalue = nstrdup(in_tag->stringvalue);
d240 4
a243 8
	{		
		tagname = 0;
		stringvalue = 0;	
		intvalue = 0;
		floatvalue = 0;	
		specialtag = 0;

		in_data->Read(&type,1);
d247 1
a247 1
			in_data->Read(&specialtag,1);
d249 3
a251 3
			tagname = new char[length+1];
			in_data->Read(tagname,length);
			tagname[length] = 0;
d253 1
a253 1
		if (type == 2){
d255 3
a257 3
			stringvalue = new char[length+1];
			in_data->Read(stringvalue,length);
			stringvalue[length] = 0;
d259 4
a262 4
		else if (type == 3)
			in_data->Read(&intvalue,4);
		else if (type == 4) // FLOAT (used by Hybrid 0.48)
			in_data->Read(&floatvalue,4);
d266 3
a268 2
		delete[] tagname;		
		delete[] stringvalue;				
d274 3
a276 8
	
	tagname = 0;
	stringvalue = 0;	
	intvalue = 0;
	floatvalue = 0;	
	specialtag = 0;

	fread(&type,1,1,in_data);
d280 1
a280 1
		fread(&specialtag,1,1,in_data);
d282 3
a284 3
		tagname = new char[length+1];
		fread(tagname,length,1,in_data);
		tagname[length] = 0;
d286 1
a286 1
	if (type == 2){
d288 8
a295 8
		stringvalue = new char[length+1];
		fread(stringvalue,length,1,in_data);
		stringvalue[length] = 0;
	}
	else if (type == 3)
		fread(&intvalue,4,1,in_data);
	else if (type == 4)
		fread(&floatvalue,4,1,in_data);
d299 5
a303 4
	if (tagname)
		delete[] tagname;
	if (stringvalue)
		delete[] stringvalue;	
d307 3
a309 3
	file->Write(&type,1);
	if (tagname){
		uint16 taglen= (uint16)strlen(tagname);
d311 1
a311 1
		file->Write(tagname,taglen);
d316 1
a316 1
		file->Write(&specialtag,taglen);
d318 2
a319 2
	if (type == 2){
		uint16 len = (uint16)strlen(stringvalue);
d321 1
a321 1
		file->Write(stringvalue,len);
d323 2
a324 2
	else if (type == 3)
		file->Write(&intvalue,4);
d329 3
a331 3
	fputc(type,file);
	if (tagname && (!specialtag)){
		uint16 taglen= (uint16)strlen(tagname);
d333 1
a333 1
		fwrite(tagname,taglen,1,file);
d338 1
a338 1
		fwrite(&specialtag,taglen,1,file);
d340 2
a341 2
	if (type == 2){
		uint16 len = (uint16)strlen(stringvalue);
d343 1
a343 1
		fwrite(stringvalue,len,1,file);
d345 2
a346 2
	else if (type == 3)
		fwrite(&intvalue,4,1,file);
@


1.6
log
@clean when invalid file (mem leaks)
@
text
@d196 7
a202 6
CTag::CTag(const char* name,uint32 intvalue){
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->tagname = nstrdup(name);
	tag->type = 3;
	tag->intvalue = intvalue;
d206 6
a211 5
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->type = 3;
	tag->intvalue = intvalue;
	tag->specialtag = special;
d214 7
a220 6
CTag::CTag(const char* name,const char* strvalue){
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->tagname = nstrdup(name);
	tag->type = 2;
	tag->stringvalue = nstrdup(strvalue);
d224 6
a229 5
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	tag->type = 2;
	tag->stringvalue = nstrdup(strvalue);
	tag->specialtag = special;
d232 8
a239 4
CTag::CTag(Tag_Struct* in_tag){
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	memcpy(tag,in_tag,sizeof(Tag_Struct));
d241 1
a241 1
		tag->tagname = nstrdup(in_tag->tagname);
d243 1
a243 1
		tag->stringvalue = nstrdup(in_tag->stringvalue);
d248 8
a255 4
	{
		tag = new Tag_Struct;
		memset(tag,0,sizeof(Tag_Struct));
		in_data->Read(&tag->type,1);
d259 1
a259 1
			in_data->Read(&tag->specialtag,1);
d261 3
a263 3
			tag->tagname = new char[length+1];
			in_data->Read(tag->tagname,length);
			tag->tagname[length] = 0;
d265 1
a265 1
		if (tag->type == 2){
d267 3
a269 3
			tag->stringvalue = new char[length+1];
			in_data->Read(tag->stringvalue,length);
			tag->stringvalue[length] = 0;
d271 4
a274 4
		else if (tag->type == 3)
			in_data->Read(&tag->intvalue,4);
		else if (tag->type == 4) // FLOAT (used by Hybrid 0.48)
			in_data->Read(&tag->floatvalue,4);
d278 2
a279 3
		delete[] tag->tagname;		
		delete[] tag->stringvalue;		
		delete tag;		
d285 8
a292 3
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	fread(&tag->type,1,1,in_data);
d296 1
a296 1
		fread(&tag->specialtag,1,1,in_data);
d298 3
a300 3
		tag->tagname = new char[length+1];
		fread(tag->tagname,length,1,in_data);
		tag->tagname[length] = 0;
d302 1
a302 1
	if (tag->type == 2){
d304 8
a311 8
		tag->stringvalue = new char[length+1];
		fread(tag->stringvalue,length,1,in_data);
		tag->stringvalue[length] = 0;
	}
	else if (tag->type == 3)
		fread(&tag->intvalue,4,1,in_data);
	else if (tag->type == 4)
		fread(&tag->floatvalue,4,1,in_data);
d315 4
a318 5
	if (tag->tagname)
		delete[] tag->tagname;
	if (tag->stringvalue)
		delete[] tag->stringvalue;
	delete tag;
d322 3
a324 3
	file->Write(&tag->type,1);
	if (tag->tagname){
		uint16 taglen= (uint16)strlen(tag->tagname);
d326 1
a326 1
		file->Write(tag->tagname,taglen);
d331 1
a331 1
		file->Write(&tag->specialtag,taglen);
d333 2
a334 2
	if (tag->type == 2){
		uint16 len = (uint16)strlen(tag->stringvalue);
d336 1
a336 1
		file->Write(tag->stringvalue,len);
d338 2
a339 2
	else if (tag->type == 3)
		file->Write(&tag->intvalue,4);
d344 3
a346 3
	fputc(tag->type,file);
	if (tag->tagname && (!tag->specialtag)){
		uint16 taglen= (uint16)strlen(tag->tagname);
d348 1
a348 1
		fwrite(tag->tagname,taglen,1,file);
d353 1
a353 1
		fwrite(&tag->specialtag,taglen,1,file);
d355 2
a356 2
	if (tag->type == 2){
		uint16 len = (uint16)strlen(tag->stringvalue);
d358 1
a358 1
		fwrite(tag->stringvalue,len,1,file);
d360 2
a361 2
	else if (tag->type == 3)
		fwrite(&tag->intvalue,4,1,file);
@


1.5
log
@code cleanup
@
text
@d239 24
a262 11
	tag = new Tag_Struct;
	memset(tag,0,sizeof(Tag_Struct));
	in_data->Read(&tag->type,1);
	uint16 length;
	in_data->Read(&length,2);
	if (length == 1)
		in_data->Read(&tag->specialtag,1);
	else {
		tag->tagname = new char[length+1];
		in_data->Read(tag->tagname,length);
		tag->tagname[length] = 0;
d264 6
a269 5
	if (tag->type == 2){
		in_data->Read(&length,2);
		tag->stringvalue = new char[length+1];
		in_data->Read(tag->stringvalue,length);
		tag->stringvalue[length] = 0;
a270 4
	else if (tag->type == 3)
		in_data->Read(&tag->intvalue,4);
	else if (tag->type == 4) // FLOAT (used by Hybrid 0.48)
		in_data->Read(&tag->floatvalue,4);
@


1.4
log
@fixes by BavarianSnail/obaldin/kuchin. see changelog+
@
text
@d196 1
a196 1
CTag::CTag(char* name,uint32 intvalue){
d212 1
a212 1
CTag::CTag(char* name,char* strvalue){
d220 1
a220 1
CTag::CTag(int8 special, char* strvalue){
@


1.3
log
@Code clean up and double check wit official code.
@
text
@d259 2
d284 2
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@a17 1

a26 1

@


1.1
log
@*** empty log message ***
@
text
@d24 2
d28 1
@


1.1.4.1
log
@updating this branch...
@
text
@@

