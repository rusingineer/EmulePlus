head	1.134;
access;
symbols
	PublicRelease_1_2e:1.131
	Interim_Release_1-2e_RC1:1.131
	PublicRelease_1_2d:1.128
	Interim_Release_1-2d_RC1:1.128
	Interim_Release_1-2d_beta1:1.128
	PublicRelease_1_2c:1.123
	Interim_Release_1-2c_RC1:1.123
	Interim_Release_1-2c_beta1:1.119
	PublicRelease_1_2b:1.119
	Interim_Release_1-2b_RC1:1.119
	PublicRelease_1_2a:1.119
	Interim_Release_1-2a_RC1:1.119
	Interim_Release_1-2a_beta2:1.119
	Interim_Release_1-2a_beta1:1.119
	PublicRelease_1_2:1.116
	Interim_Release_1-2_RC1:1.116
	Interim_Release_1-2_beta1:1.116
	PublicRelease_1_1g:1.113
	Interim_Release_1-1g_RC3:1.113
	Interim_Release_1-1g_RC2:1.113
	Interim_Release_1-1g_RC1:1.112
	Interim_Release_1-1g_beta2:1.110
	Interim_Release_1-1g_beta1:1.108
	PublicRelease_1_1f:1.107
	Interim_Release_1-1f_RC1:1.107
	PublicRelease_1_1e:1.105
	Interim_Release_1-1e_RC2:1.105
	Interim_Release_1-1e_RC1:1.105
	Interim_Release_1-1e_beta1:1.103
	PublicRelease_1_1d:1.101
	Interim_Release_1-1d_RC1:1.101
	PublicRelease_1_1c:1.101
	Interim_Release_1-1c_RC1:1.101
	Interim_Release_1-1c_beta2:1.101
	Interim_Release_1-1c_beta1:1.101
	PublicRelease_1_1b:1.98
	Interim_Release_1-1b_RC1:1.98
	PublicRelease_1_1a:1.98
	Interim_Release_1-1a_RC2:1.98
	Interim_Release_1-1a_RC1:1.98
	Interim_Release_1-1a_beta2:1.98
	Interim_Release_1-1a_beta1:1.98
	PublicRelease_1_1:1.94
	Interim_Release_1-1_beta1:1.94
	PublicRelease_1o:1.93
	Interim_Release_1o_RC1:1.93
	Interim_Release_1o_beta1:1.93
	PublicRelease_1n:1.93
	Interim_Release_1n_RC2:1.93
	Interim_Release_1n_RC1:1.93
	Interim_Release_1n_beta2:1.93
	Interim_Release_1n_beta1:1.89
	PublicRelease_1m:1.85
	Interim_Release_1m_beta1:1.80
	PublicRelease_1l:1.75
	Interim_Release_1l_RC3:1.75
	Interim_Release_1l_RC2:1.75
	Interim_Release_1l_RC1:1.74
	Interim_Release_1l_beta2:1.73
	Interim_Release_1l_beta1:1.68
	PublicRelease_1k:1.63
	Interim_Release_1k_RC4:1.63
	Interim_1k_RC3:1.63
	Interim_1k_RC2:1.63
	Interim_Release_1k_RC1:1.63
	Interim_Release_1k_beta5:1.60
	Intrerim_Release_1k_beta4:1.60
	Interim_Release_1k_beta1:1.58
	PublicRelease_1j:1.53
	Interim_Release_1J_RC3:1.53
	Interim_Release_1j_RC3:1.53
	Interim_Release_1j_RC2:1.49
	Interim_Release_1j_RC1:1.47
	Interim_Release_1j_beta2:1.47
	Interim_Release_1j_beta1:1.46
	PublicRelease_1i:1.37
	Interim_Release_1i_RC6:1.37
	Interim_Release_1i_RC3:1.36
	Interim_Release_1i_RC2:1.36
	Interim_Release_1i_RC1:1.36
	Interim_Release_1i_beta3:1.36
	Interim_Release_1i_beta2:1.36
	Interim_Release_1i_beta1:1.29
	PublicRelease_1h:1.24
	Interim_Release_1h_rc2:1.24
	Interim_Release_1h_RC1:1.24
	Interim_Release_1h_beta2:1.24
	Interim_Release_1h_beta1_now:1.23
	Interim_Release_1h_beta1:1.23
	PublicRelease_1g:1.21
	Interim_Release_1g_RC6_Final:1.21
	Interim_Release_1g_RC6:1.21
	Interim_Release_1g_RC5:1.21
	Interim_Release_1g_RC4:1.20
	Interim_Release_1g_RC3:1.20
	Interim_Release_1g_beta2:1.14
	Interim_Release_1g_beta1:1.14
	Interim_Release_1f_RC4:1.13
	Interim_Release_1f_RC3:1.13
	Interim_Release_1f_RC2:1.12
	Interim_Release_1f_RC:1.12
	Interim_Release_1f_beta2:1.12
	Interim_Release_1f_beta1:1.11
	PublicRelease_1e:1.11
	Interim_Release_1e_RC2:1.11
	Interim_Release_1e_RC:1.11
	Interim_Release_1e_beta3:1.11
	Interim_Release_1e_beta2:1.11
	Interim_Release_1e_beta2_before_kuchin:1.11
	Interim_Release_1e_beta1:1.11
	PublicRelease_1c:1.10
	featurestest:1.10.0.4
	Interim_Release_1c_RC:1.10
	Interim_Release_1c_beta2:1.10
	Interim_Release_1c_beta1:1.10
	threaded_downloadqueue:1.10.0.2
	PublicRelease_1b:1.9
	Interim_Release_1b_beta2:1.9
	Interim_Release_1b_beta1:1.8
	proxydeadlake:1.8.0.4
	PublicRelease_1a:1.8
	Interim_Release_1a_beta2:1.8
	BerkeleyDb:1.8.0.2
	Interim_Release_1a_beta1:1.8
	PublicRelease_1:1.8
	goldfish:1.8
	eMulePlus_1_RC2:1.7
	eMulePlus_26b_1RC1:1.7
	PreRelease_26b_i0e:1.7
	before_26d_merge:1.6
	Interim_Release_26b_i0d:1.5
	Interim_Release_26b_i0c:1.4
	Interim_Release_26b_i0b:1.4
	Interim_Release_26b_i0a:1.4
	systraydlg:1.3.0.6
	plus26based:1.3.0.4
	Interim_Release_25b_i0b:1.3
	Proxy_Dev:1.3
	Interim_Release_25b_i0a:1.3.2.1
	proxytest:1.3.2.1.0.2
	official_sockets:1.3.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.134
date	2010.06.13.01.38.49;	author aw3;	state Exp;
branches;
next	1.133;

1.133
date	2009.07.30.03.50.48;	author aw3;	state Exp;
branches;
next	1.132;

1.132
date	2009.07.14.03.54.08;	author aw3;	state Exp;
branches;
next	1.131;

1.131
date	2008.12.15.22.39.31;	author aw3;	state Exp;
branches;
next	1.130;

1.130
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.129;

1.129
date	2008.10.28.02.42.18;	author aw3;	state Exp;
branches;
next	1.128;

1.128
date	2008.02.17.21.22.09;	author aw3;	state Exp;
branches;
next	1.127;

1.127
date	2008.01.05.20.42.17;	author aw3;	state Exp;
branches;
next	1.126;

1.126
date	2007.12.26.15.49.05;	author eklmn;	state Exp;
branches;
next	1.125;

1.125
date	2007.10.14.05.21.29;	author fuxie-dk;	state Exp;
branches;
next	1.124;

1.124
date	2007.10.03.18.09.18;	author eklmn;	state Exp;
branches;
next	1.123;

1.123
date	2007.07.14.04.10.18;	author aw3;	state Exp;
branches;
next	1.122;

1.122
date	2007.07.08.22.31.18;	author kush_eplus;	state Exp;
branches;
next	1.121;

1.121
date	2007.07.08.00.03.29;	author aw3;	state Exp;
branches;
next	1.120;

1.120
date	2007.03.04.22.48.41;	author kush_eplus;	state Exp;
branches;
next	1.119;

1.119
date	2006.04.29.21.59.57;	author eklmn;	state Exp;
branches;
next	1.118;

1.118
date	2006.04.23.04.06.57;	author aw3;	state Exp;
branches;
next	1.117;

1.117
date	2006.04.04.22.28.40;	author kush_eplus;	state Exp;
branches;
next	1.116;

1.116
date	2006.01.12.17.58.09;	author eklmn;	state Exp;
branches;
next	1.115;

1.115
date	2006.01.06.20.05.54;	author kush_eplus;	state Exp;
branches;
next	1.114;

1.114
date	2006.01.01.16.11.16;	author aw3;	state Exp;
branches;
next	1.113;

1.113
date	2005.12.08.05.50.21;	author aw3;	state Exp;
branches;
next	1.112;

1.112
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.111;

1.111
date	2005.11.27.20.31.04;	author eklmn;	state Exp;
branches;
next	1.110;

1.110
date	2005.11.15.05.43.19;	author aw3;	state Exp;
branches;
next	1.109;

1.109
date	2005.10.30.03.40.50;	author aw3;	state Exp;
branches;
next	1.108;

1.108
date	2005.08.20.04.33.13;	author aw3;	state Exp;
branches;
next	1.107;

1.107
date	2005.07.19.02.14.38;	author katsyonak;	state Exp;
branches;
next	1.106;

1.106
date	2005.07.17.23.50.38;	author aw3;	state Exp;
branches;
next	1.105;

1.105
date	2005.06.20.04.06.18;	author aw3;	state Exp;
branches;
next	1.104;

1.104
date	2005.06.19.05.09.53;	author aw3;	state Exp;
branches;
next	1.103;

1.103
date	2005.04.04.12.03.20;	author katsyonak;	state Exp;
branches;
next	1.102;

1.102
date	2005.03.28.02.53.00;	author aw3;	state Exp;
branches;
next	1.101;

1.101
date	2005.01.23.02.00.27;	author katsyonak;	state Exp;
branches;
next	1.100;

1.100
date	2005.01.18.16.28.50;	author katsyonak;	state Exp;
branches;
next	1.99;

1.99
date	2005.01.12.05.11.15;	author katsyonak;	state Exp;
branches;
next	1.98;

1.98
date	2004.10.31.05.51.28;	author aw3;	state Exp;
branches;
next	1.97;

1.97
date	2004.10.30.00.20.40;	author aw3;	state Exp;
branches;
next	1.96;

1.96
date	2004.10.29.03.24.50;	author aw3;	state Exp;
branches;
next	1.95;

1.95
date	2004.10.26.21.13.56;	author aw3;	state Exp;
branches;
next	1.94;

1.94
date	2004.10.01.17.52.55;	author aw3;	state Exp;
branches;
next	1.93;

1.93
date	2004.08.05.21.41.23;	author aw3;	state Exp;
branches;
next	1.92;

1.92
date	2004.07.29.14.02.32;	author katsyonak;	state Exp;
branches;
next	1.91;

1.91
date	2004.07.29.02.13.01;	author katsyonak;	state Exp;
branches;
next	1.90;

1.90
date	2004.07.26.02.29.41;	author katsyonak;	state Exp;
branches;
next	1.89;

1.89
date	2004.07.12.14.10.41;	author katsyonak;	state Exp;
branches;
next	1.88;

1.88
date	2004.06.30.13.38.39;	author dongato;	state Exp;
branches;
next	1.87;

1.87
date	2004.06.28.17.29.36;	author dongato;	state Exp;
branches;
next	1.86;

1.86
date	2004.06.28.02.31.29;	author katsyonak;	state Exp;
branches;
next	1.85;

1.85
date	2004.06.25.17.31.26;	author syrus77;	state Exp;
branches;
next	1.84;

1.84
date	2004.06.23.21.10.47;	author katsyonak;	state Exp;
branches;
next	1.83;

1.83
date	2004.06.23.18.11.24;	author katsyonak;	state Exp;
branches;
next	1.82;

1.82
date	2004.06.23.04.59.34;	author katsyonak;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.22.17.43.27;	author katsyonak;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.21.16.52.05;	author katsyonak;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.21.15.51.49;	author katsyonak;	state Exp;
branches;
next	1.78;

1.78
date	2004.06.21.13.41.14;	author katsyonak;	state Exp;
branches;
next	1.77;

1.77
date	2004.06.20.19.15.24;	author katsyonak;	state Exp;
branches;
next	1.76;

1.76
date	2004.06.15.05.05.47;	author katsyonak;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.31.20.02.33;	author aw3;	state Exp;
branches;
next	1.74;

1.74
date	2004.05.24.09.46.13;	author dongato;	state Exp;
branches;
next	1.73;

1.73
date	2004.05.21.14.37.56;	author dongato;	state Exp;
branches;
next	1.72;

1.72
date	2004.05.19.10.14.23;	author netwolf1;	state Exp;
branches;
next	1.71;

1.71
date	2004.05.17.01.45.15;	author dongato;	state Exp;
branches;
next	1.70;

1.70
date	2004.05.12.00.47.32;	author katsyonak;	state Exp;
branches;
next	1.69;

1.69
date	2004.05.11.14.56.06;	author katsyonak;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.04.11.28.00;	author netwolf1;	state Exp;
branches;
next	1.67;

1.67
date	2004.05.04.06.09.32;	author aw3;	state Exp;
branches;
next	1.66;

1.66
date	2004.04.13.17.37.38;	author aw3;	state Exp;
branches;
next	1.65;

1.65
date	2004.04.13.04.46.32;	author katsyonak;	state Exp;
branches;
next	1.64;

1.64
date	2004.04.10.06.21.06;	author dongato;	state Exp;
branches;
next	1.63;

1.63
date	2004.03.26.23.16.59;	author aw3;	state Exp;
branches;
next	1.62;

1.62
date	2004.03.26.08.55.19;	author eklmn;	state Exp;
branches;
next	1.61;

1.61
date	2004.03.26.02.59.13;	author aw3;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.20.01.41.15;	author aw3;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.14.21.10.04;	author aw3;	state Exp;
branches;
next	1.58;

1.58
date	2004.02.05.11.56.05;	author morevit;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.04.23.59.58;	author kush_eplus;	state Exp;
branches;
next	1.56;

1.56
date	2004.02.04.19.05.42;	author morevit;	state Exp;
branches;
next	1.55;

1.55
date	2004.02.03.14.28.05;	author kush_eplus;	state Exp;
branches;
next	1.54;

1.54
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.53;

1.53
date	2004.01.22.19.48.25;	author dongato;	state Exp;
branches;
next	1.52;

1.52
date	2004.01.13.17.58.25;	author dongato;	state Exp;
branches;
next	1.51;

1.51
date	2004.01.13.15.23.52;	author katsyonak;	state Exp;
branches;
next	1.50;

1.50
date	2004.01.13.13.19.42;	author katsyonak;	state Exp;
branches;
next	1.49;

1.49
date	2004.01.12.10.51.27;	author katsyonak;	state Exp;
branches;
next	1.48;

1.48
date	2004.01.12.10.40.08;	author katsyonak;	state Exp;
branches;
next	1.47;

1.47
date	2003.12.30.17.44.39;	author katsyonak;	state Exp;
branches;
next	1.46;

1.46
date	2003.12.25.14.17.57;	author katsyonak;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.24.01.21.13;	author katsyonak;	state Exp;
branches;
next	1.44;

1.44
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.43;

1.43
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.42;

1.42
date	2003.12.23.12.04.58;	author katsyonak;	state Exp;
branches;
next	1.41;

1.41
date	2003.12.22.22.41.31;	author katsyonak;	state Exp;
branches;
next	1.40;

1.40
date	2003.12.22.18.28.27;	author katsyonak;	state Exp;
branches;
next	1.39;

1.39
date	2003.12.19.11.05.30;	author katsyonak;	state Exp;
branches;
next	1.38;

1.38
date	2003.12.18.13.35.30;	author katsyonak;	state Exp;
branches;
next	1.37;

1.37
date	2003.11.26.23.54.50;	author katsyonak;	state Exp;
branches;
next	1.36;

1.36
date	2003.10.24.07.49.24;	author netwolf1;	state Exp;
branches;
next	1.35;

1.35
date	2003.10.24.01.21.19;	author morevit;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.23.13.14.32;	author dongato;	state Exp;
branches;
next	1.33;

1.33
date	2003.10.17.10.29.05;	author morevit;	state Exp;
branches;
next	1.32;

1.32
date	2003.10.08.12.56.32;	author morevit;	state Exp;
branches;
next	1.31;

1.31
date	2003.10.08.01.53.31;	author morevit;	state Exp;
branches;
next	1.30;

1.30
date	2003.10.07.13.30.45;	author dongato;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.04.02.25.50;	author dongato;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.27.14.59.37;	author dongato;	state Exp;
branches;
next	1.27;

1.27
date	2003.09.25.10.35.35;	author dongato;	state Exp;
branches;
next	1.26;

1.26
date	2003.09.21.22.05.13;	author morevit;	state Exp;
branches;
next	1.25;

1.25
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.24;

1.24
date	2003.08.23.16.28.38;	author bond006;	state Exp;
branches;
next	1.23;

1.23
date	2003.07.31.15.02.18;	author puritynn666;	state Exp;
branches;
next	1.22;

1.22
date	2003.07.30.12.29.31;	author kuchin;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.09.16.14.21;	author netwolf1;	state Exp;
branches;
next	1.20;

1.20
date	2003.06.24.23.18.07;	author syrus77;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.19.07.47.47;	author partyckip;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.17.02.15.18;	author dongato;	state Exp;
branches;
next	1.17;

1.17
date	2003.06.16.21.54.52;	author dongato;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.11.18.27.06;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.09.15.14.37;	author kuchin;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.26.17.26.34;	author partyckip;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.20.20.46.24;	author netwolf1;	state Exp;
branches;
next	1.12;

1.12
date	2003.05.06.21.59.12;	author partyckip;	state Exp;
branches;
next	1.11;

1.11
date	2003.03.27.09.40.25;	author recdvst;	state Exp;
branches;
next	1.10;

1.10
date	2003.03.14.16.24.16;	author partyckip;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2003.03.08.12.09.41;	author recdvst;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.20.14.28.56;	author dongato;	state Exp;
branches;
next	1.7;

1.7
date	2003.02.17.06.50.29;	author obaldin;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.16.22.01.45;	author lord_kiron;	state Exp;
branches;
next	1.5;

1.5
date	2003.02.12.20.18.21;	author obaldin;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.09.18.39.40;	author kuchin;	state Exp;
branches;
next	1.3;

1.3
date	2003.01.24.22.07.45;	author maverick65;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2003.01.22.14.14.22;	author cax2;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.17.59.09;	author cax2;	state Exp;
branches;
next	;

1.3.2.1
date	2003.01.28.16.53.58;	author cax2;	state Exp;
branches;
next	;

1.3.4.1
date	2003.02.05.01.58.41;	author obaldin;	state Exp;
branches;
next	;

1.10.4.1
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.134
log
@Another ban for spamming.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "emule.h"
#include "updownclient.h"
#include "ChatSelector.h"
#include "Friend.h"
#include "packets.h"
#include "UploadQueue.h"
#include "otherfunctions.h"
#include "ListenSocket.h"
#include "IP2Country.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif


CChatItem::CChatItem()
{
	m_pClient = NULL;
	m_pLog = NULL;
	m_strMessagePending.Empty();
	m_bNotify = false;
	m_iHistoryIndex = 0;
}

//	CChatSelector

IMPLEMENT_DYNAMIC(CChatSelector, CClosableTabCtrl)
CChatSelector::CChatSelector()
{
	lastemptyicon = false;
	blinkstate = false;
	m_Timer = 0;
}

CChatSelector::~CChatSelector()
{
}


BEGIN_MESSAGE_MAP(CChatSelector, CClosableTabCtrl)
	ON_WM_TIMER()
	ON_NOTIFY_REFLECT(TCN_SELCHANGE, OnTcnSelchangeChatsel)
	ON_WM_SIZE()
	ON_NOTIFY(EN_LINK, IDC_CHATOUT, OnEnLinkMessageBox)
	ON_WM_DESTROY()
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	CChatSelector message handlers
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::Init()
{
	CRect	rcRect;

	GetClientRect(&rcRect);
	AdjustRect(false, rcRect);
	rcRect.DeflateRect(7, 7);
	ModifyStyle(0, WS_CLIPCHILDREN);
	chatout.Create(WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rcRect, this, IDC_CHATOUT);
	chatout.ModifyStyleEx(0, WS_EX_STATICEDGE, SWP_FRAMECHANGED);
	chatout.SetFont(&g_App.m_pMDlg->m_fontDefault);
	chatout.SetTitle(GetResString(IDS_MESSAGES));
	chatout.m_dwFlags |= (HTC_ISLIMITED | HTC_ISWORDWRAP);
	chatout.AppendText(CLIENT_NAME, CSTRLEN(CLIENT_NAME), RGB(153,51,102), CLR_DEFAULT, HTC_LINK);
	chatout.AppendText(_T(" v") CURRENT_VERSION_LONG _T(" - ") + GetResString(IDS_CHAT_WELCOME) + _T('\n'), RGB(153,51,102), CLR_DEFAULT, HTC_HAVENOLINK);

	VERIFY((m_Timer = SetTimer(20, 1500, 0)));
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CChatItem* CChatSelector::StartSession(CUpDownClient* pClient, bool bForceFocus /* true */)
{
	if (pClient == NULL || !g_App.m_pMDlg->IsRunning())
		return NULL;

	EMULE_TRY

	if (GetTabByClient(pClient) != -1)
	{
		SetCurSel(GetTabByClient(pClient));
		if (bForceFocus)
			ShowChat();
		return NULL;
	}

	CChatItem	*pChatItem = new CChatItem();
	CRect		rcRect;

	pChatItem->m_pClient = pClient;
	pChatItem->m_pLog = new CHTRichEditCtrl;

	GetClientRect(&rcRect);
	AdjustRect(false, rcRect);
	rcRect.left += 3;
	rcRect.top += 4;
	rcRect.right -= 3;
	rcRect.bottom -= 3;

	if (GetItemCount() == 0)
		rcRect.top += 20;

	pChatItem->m_pLog->Create(WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rcRect, this, (UINT)-1);
	pChatItem->m_pLog->ModifyStyleEx(0, WS_EX_STATICEDGE, SWP_FRAMECHANGED);
	pChatItem->m_pLog->SendMessage(EM_SETMARGINS, EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELONG(3, 3));
	pChatItem->m_pLog->SetFont(&g_App.m_pMDlg->m_fontDefault);
	pChatItem->m_pLog->m_dwFlags |= HTC_ISWORDWRAP;
	pChatItem->m_pLog->SetTargetDevice(NULL, 0);

	COleDateTime	timelog(COleDateTime::GetCurrentTime());
	CString			strName = pClient->GetUserName(), strCountry, strTemp;

	if (g_App.m_pIP2Country->IsIP2Country())
		strCountry.Format(_T(" (%s)"), pClient->GetCountryName());
	strTemp.Format(_T("*** %s: %s (%s: %s:%u%s) - %s\n"), 
		GetResString(IDS_CHAT_START),
		strName,
		GetResString(IDS_IP), pClient->GetFullIP(), pClient->GetUserPort(), strCountry,
		timelog.Format(_T("%c")));
	pChatItem->m_pLog->AppendText(strTemp, RGB(255, 0, 0));
	pClient->SetChatState(MS_CHATTING);
	if (pClient->IsFriend())
		pClient->m_pFriend->m_dwLastChatted = time(NULL);

	if (strName.GetLength() > 30)
	{
		strName.Truncate(30);
		strName += _T("...");
	}
	else if (strName.IsEmpty())
		strName.Format(_T("[%s]"), GetResString(IDS_UNKNOWN));

	TCITEM	tcitem;

	tcitem.mask = TCIF_PARAM | TCIF_TEXT | TCIF_IMAGE;
	tcitem.lParam = (LPARAM)pChatItem;
	tcitem.pszText = (TCHAR*)strName.GetString();
	tcitem.iImage = 0;
	
	int	iResult = InsertItem(GetItemCount(), &tcitem);

	g_App.m_pMDlg->m_wndChat.m_ctlCloseButton.EnableWindow(true);
	g_App.m_pMDlg->m_wndChat.m_ctlSendButton.EnableWindow(true);

	if (iResult != -1 && IsWindowVisible())
	{
		SetCurSel(iResult);
		pChatItem->m_pLog->SetTitle(pClient->GetUserName());
		if (bForceFocus)
			ShowChat();
	}

	return pChatItem;

	EMULE_CATCH

	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int CChatSelector::GetTabByClient(CUpDownClient *pClient)
{
	TCITEM tcitem;

	for (int i = 0; i < GetItemCount(); i++)
	{
		tcitem.mask = TCIF_PARAM;
		if (GetItem(i, &tcitem) && ((CChatItem*)tcitem.lParam)->m_pClient == pClient)
			return i;
	}
	return -1;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CChatItem* CChatSelector::GetItemByClient(CUpDownClient* client)
{
	TCITEM	tcitem;

	for (int i = 0; i < GetItemCount(); i++)
	{
		tcitem.mask = TCIF_PARAM;
		if (GetItem(i, &tcitem) && ((CChatItem*)tcitem.lParam)->m_pClient == client)
			return(CChatItem*)tcitem.lParam;
	}
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::ProcessMessage(CUpDownClient* pSender, const CString &strIncomingMessage)
{
	static const TCHAR *s_apcMsgBanFilter[] =
	{	// Add new clowns on top; All strings in lower case
		_T("angelmule.com"),
		_T("tyrantmule"),
		_T("rocketmule"),
		_T("speedshare"),
		_T("emule fx"),
		_T("zambor"),
		_T("fastest emule ever"),
		_T("robot from riaa"),
		_T("ketamine"),
		_T("di-emule"),
		_T("http://www.chez.com/theworld/"),
		_T("http://fullspeed.to/mison")
	};
	CString	strMessage(strIncomingMessage);
	int		iCurPos = 0;

	strMessage.MakeLower();

//	Ban spammers
	if (g_App.m_pPrefs->IsCounterMeasures())
	{
		for (unsigned ui = 0; ui < ARRSIZE(s_apcMsgBanFilter); ui++)
		{
			if (strMessage.Find(s_apcMsgBanFilter[ui]) >= 0)
			{
				AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Anti-leecher: Client %s has been banned because of spamming"), pSender->GetClientNameWithSoftware());
				pSender->Ban(BAN_CLIENT_SPAMMING);
				return;
			}
		}
	}

	CString	strResToken, strFilter = g_App.m_pPrefs->GetMessageFilter();

	strFilter.MakeLower();
	for (;;)
	{
		strResToken = strFilter.Tokenize(_T("|"), iCurPos);
		if (strResToken.IsEmpty())
			break;
		if (strMessage.Find(strResToken) >= 0)
		{
			AddLogLine(LOG_FL_DBG | LOG_RGB_DIMMED, _T("Filtered message '%s' from client %s"), strIncomingMessage, pSender->GetClientNameWithSoftware());
			return;
		}
	}

	CChatItem	*pChatItem = GetItemByClient(pSender);
	bool		bIsNewChatWindow = false;

	if (pChatItem == NULL)
	{
		if (GetItemCount() >= 50)
		{
			AddLogLine(LOG_FL_DBG | LOG_RGB_WARNING, _T("Instant Messaging: Messages limit reached"));
			return;
		}

		if (g_App.m_pPrefs->GetAcceptMessagesFrom() == 4) //no messages
			return;

		if ((g_App.m_pPrefs->GetAcceptMessagesFrom() == 2) && !pSender->IsFriend()) //only friends
			return;

		if ((g_App.m_pPrefs->GetAcceptMessagesFrom() == 3) && !pSender->IsFriend()) //log non friends
		{
			AddLogLine(0, GetResString(IDS_IM_MSGFROMCHAT) + _T(" %s: %s"), pSender->GetUserName(), strIncomingMessage);
			pSender->SetChatState(MS_NONE);
			return;
		}

		pChatItem = StartSession(pSender);
		if (pChatItem == NULL)
			return;
		bIsNewChatWindow = true;
	}
	COleDateTime	timelog(COleDateTime::GetCurrentTime());

	strMessage.Format(_T("%s (%s): "), pSender->GetUserName(), timelog.Format(_T("%c")));
	pChatItem->m_pLog->AppendText(strMessage, RGB(50, 200, 250));
	pChatItem->m_pLog->AppendText(strIncomingMessage + _T('\n'));

	if (g_App.m_pPrefs->GetAwayState())
	{
		if ((::GetTickCount() - pChatItem->m_pClient->GetAwayMessageResendCount()) > 3000)
		{ //send again only if 3 secs from last away message
			SendAwayMessage(pChatItem);
			pChatItem->m_pClient->SetAwayMessageResendCount(::GetTickCount());
		}
	}

	if ((iCurPos = GetTabByClient(pSender)) != GetCurSel())
		SetItemState(iCurPos, TCIS_HIGHLIGHTED, TCIS_HIGHLIGHTED);
	if (!g_App.m_pPrefs->GetAwayState())
	{
		BOOL	bVisible = ::IsWindowVisible(::GetParent(m_hWnd));

	//	Show statusbar indicator if Messages window isn't active or our application isn't topmost one
		if (!bVisible || (g_App.m_pMDlg->m_hWnd != ::GetForegroundWindow()))
		{
			pChatItem->m_bNotify = true;
		//	Send Notification is required
			if ( ( g_App.m_pPrefs->GetUseChatNotifier() &&
				(bIsNewChatWindow || g_App.m_pPrefs->GetNotifierPopsEveryChatMsg()) ) )
			{
				strMessage.Format(_T("%s %s:'%s'\n"), GetResString(IDS_TBN_NEWCHATMSG), pSender->GetUserName(), strIncomingMessage);
				g_App.m_pMDlg->SendMail(strMessage, true, g_App.m_pPrefs->IsSMTPInfoEnabled());
				g_App.m_pMDlg->ShowNotifier(strMessage, TBN_CHAT, false, true);
			}
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CChatSelector::SendMessage(const CString& message)
{
	if (!g_App.m_pMDlg->IsRunning())
		return false;

	CChatItem	*pChatItem = GetCurrentChatItem();

	if (pChatItem == NULL || pChatItem->m_pClient == NULL)
		return false;

	if (pChatItem->m_strHistoryArray.GetCount() == g_App.m_pPrefs->GetMaxChatHistoryLines())
		pChatItem->m_strHistoryArray.RemoveAt(0);
	pChatItem->m_strHistoryArray.Add(CString(message));
	pChatItem->m_iHistoryIndex = pChatItem->m_strHistoryArray.GetCount();

	if (pChatItem->m_pClient->GetChatState() == MS_CONNECTING)
		return false;

#ifdef OLD_SOCKETS_ENABLED
	if (pChatItem->m_pClient->IsHandshakeFinished())
	{
		SendMessagePacket(*pChatItem, message);

		COleDateTime	timelog(COleDateTime::GetCurrentTime());
		CString			strTmp;

		strTmp.Format(_T("%s (%s): "), g_App.m_pPrefs->GetUserNick(), timelog.Format(_T("%c")));
		pChatItem->m_pLog->AppendText(strTmp, RGB(1, 180, 20));
		pChatItem->m_pLog->AppendText(message + _T('\n'));
	}
	else
	{
		pChatItem->m_pLog->AppendText(_T("*** ") + GetResString(IDS_CONNECTING), RGB(255, 0, 0), CLR_DEFAULT, HTC_HAVENOLINK);
		pChatItem->m_strMessagePending = message;
		pChatItem->m_pClient->SetChatState(MS_CONNECTING);
		pChatItem->m_pClient->TryToConnect();
	}
#endif //OLD_SOCKETS_ENABLED
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::ConnectingResult(CUpDownClient* sender, bool bSuccess)
{
	CChatItem	*pChatItem = GetItemByClient(sender);

	if (pChatItem == NULL || pChatItem->m_pClient == NULL)
		return;

	pChatItem->m_pClient->SetChatState(MS_CHATTING);

	if (!bSuccess)
	{
		if (!pChatItem->m_strMessagePending.IsEmpty())
		{
			pChatItem->m_pLog->AppendText(_T(' ') + GetResString(IDS_FAILED) + _T('\n'), RGB(255, 0, 0), CLR_DEFAULT, HTC_HAVENOLINK);
			pChatItem->m_strMessagePending.Empty();
		}
#ifdef _DEBUG
		else
			pChatItem->m_pLog->AppendText(GetResString(IDS_CHATDISCONNECTED) + _T('\n'), RGB(255, 0, 0), CLR_DEFAULT, HTC_HAVENOLINK);
#endif
	}
	else if (!pChatItem->m_strMessagePending.IsEmpty())
	{
		pChatItem->m_pLog->AppendText(_T(" ok\n"), CSTRLEN(_T(" ok\n")), RGB(255, 0, 0), CLR_DEFAULT, HTC_HAVENOLINK);
		SendMessagePacket(*pChatItem, pChatItem->m_strMessagePending);

		COleDateTime	timelog(COleDateTime::GetCurrentTime());
		CString			strTmp;

		strTmp.Format(_T("%s (%s): "), g_App.m_pPrefs->GetUserNick(), timelog.Format(_T("%c")));
		pChatItem->m_pLog->AppendText(strTmp, RGB(1, 180, 20));
		pChatItem->m_pLog->AppendText(pChatItem->m_strMessagePending + _T('\n'));
		pChatItem->m_strMessagePending.Empty();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::DeleteAllItems()
{
	TCITEM	tcitem;

	for (int i = 0; i < GetItemCount(); i++)
	{
		tcitem.mask = TCIF_PARAM;
		if (GetItem(i, &tcitem))
			delete (CChatItem*)tcitem.lParam;
	}
	chatout.ShowWindow(SW_SHOW);
	g_App.m_pMDlg->m_wndChat.m_ctlCloseButton.EnableWindow(false);
	g_App.m_pMDlg->m_wndChat.m_ctlSendButton.EnableWindow(false);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::OnTimer(UINT_PTR nIDEvent)
{
	NOPRM(nIDEvent);
	blinkstate = !blinkstate;

	bool	globalnotify = false;
	TCITEM	tcitem;

	for (int i = 0; i < GetItemCount(); i++)
	{
		tcitem.mask = TCIF_PARAM;
		if (!GetItem(i, &tcitem))
			break;

		if (((CChatItem*)tcitem.lParam)->m_bNotify)
		{
			globalnotify = true;
			break;
		}
	}
	if (globalnotify)
	{
		g_App.m_pMDlg->ShowMessageState(((blinkstate) ? 1 : 2));
		lastemptyicon = false;
	}
	else if (!lastemptyicon)
	{
		g_App.m_pMDlg->ShowMessageState(0);
		lastemptyicon = true;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CChatItem* CChatSelector::GetCurrentChatItem()
{
	int	iCurSel = GetCurSel();

	if (iCurSel == -1)
		return NULL;

	TCITEM	tcitem;

	tcitem.mask = TCIF_PARAM;
	if (!GetItem(iCurSel, &tcitem))
		return NULL;
	return (CChatItem*)tcitem.lParam;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::ShowChat()
{
	int	iCurSel = GetCurSel();

	if (iCurSel == -1)
		return;

	bool	bWasChanged = (GetItemState(iCurSel, TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED) ? true : false;

	SetItemState(iCurSel, TCIS_HIGHLIGHTED, NULL);

	CChatItem	*pChatItem = GetCurrentChatItem(), *pUpdateItem;

	if (pChatItem == NULL)
		return;

	pChatItem->m_pLog->SetRedraw(false);
	pChatItem->m_pLog->ShowWindow(SW_SHOW);
	if ((pChatItem->m_pLog->m_dwFlags & HTC_ISAUTOSCROLL) != 0 && bWasChanged)
		pChatItem->m_pLog->ScrollToLastLine();
	pChatItem->m_pLog->SetRedraw(true);

	TCITEM	tcitem;
	int		i = 0;

	tcitem.mask = TCIF_PARAM;
	while (GetItem(i++, &tcitem))
	{
		pUpdateItem = (CChatItem*)tcitem.lParam;
		if (pUpdateItem != pChatItem)
			pUpdateItem->m_pLog->ShowWindow(SW_HIDE);
	}

	pChatItem->m_pLog->SetTitle(pChatItem->m_pClient->GetUserName());
	pChatItem->m_bNotify = false;
	g_App.m_pMDlg->m_wndChat.m_ctlInputText.SetFocus();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::OnTcnSelchangeChatsel(NMHDR *pNMHDR, LRESULT *pResult)
{
	NOPRM(pNMHDR);
	ShowChat();
	*pResult = 0;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
INT	CChatSelector::InsertItem(int nItem, TCITEM* pTabCtrlItem)
{
	if (GetItemCount() == 0)
		chatout.ShowWindow(SW_HIDE);

	int	iResult = CClosableTabCtrl::InsertItem(nItem, pTabCtrlItem);

	RedrawWindow();
	return iResult;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CChatSelector::DeleteItem(int nItem)
{
	CClosableTabCtrl::DeleteItem(nItem);
	if (GetItemCount() == 0)
	{
		chatout.ShowWindow(SW_SHOW);
		g_App.m_pMDlg->m_wndChat.m_ctlCloseButton.EnableWindow(false);
		g_App.m_pMDlg->m_wndChat.m_ctlSendButton.EnableWindow(false);
	}
	RedrawWindow();
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::EndSession(CUpDownClient* client, bool bForceFocus /* true */)
{
	if (!g_App.m_pMDlg->IsRunning())
		return;

	int	iCurSel;

	if (client != NULL)
		iCurSel = GetTabByClient(client);
	else
		iCurSel = GetCurSel();

	if (iCurSel == -1)
		return;

	TCITEM	tcitem;
	
	tcitem.mask = TCIF_PARAM;

	if (!GetItem(iCurSel, &tcitem) || tcitem.lParam == 0)
		return;

	CChatItem	*pChatItem = (CChatItem*)tcitem.lParam;

	pChatItem->m_pClient->SetChatState(MS_NONE);

	DeleteItem(iCurSel);
	delete pChatItem;

	int	iTabItems = GetItemCount();

	if (iTabItems > 0)
	{
	//	Select next tab
		if (iCurSel >= iTabItems)
			iCurSel = iTabItems - 1;
		SetCurSel(iCurSel);				// Returns CB_ERR if error or no prev. selection(!)
		iCurSel = GetCurSel();			// get the real current selection
		if (iCurSel == CB_ERR)			// if still error
			iCurSel = SetCurSel(0);
		if (bForceFocus)
			ShowChat();
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::OnSize(UINT nType, int cx, int cy)
{
	CClosableTabCtrl::OnSize(nType, cx, cy);

	CRect	rcRect;

	GetClientRect(&rcRect);
	AdjustRect(false, rcRect);
	rcRect.left += 3;
	rcRect.top += 4;
	rcRect.right -= 3;
	rcRect.bottom -= 3;

	if (GetItemCount() > 0)
		rcRect.top -= 20;

	chatout.SetWindowPos(NULL, rcRect.left, rcRect.top, rcRect.Width(), rcRect.Height(), SWP_NOZORDER);

	TCITEM		tcitem;
	CChatItem	*pChatItem;
	int			i = 0;

	tcitem.mask = TCIF_PARAM;
	while (GetItem(i++, &tcitem))
	{
		pChatItem = (CChatItem*)tcitem.lParam;
		pChatItem->m_pLog->SetWindowPos(NULL, rcRect.left, rcRect.top + 20, rcRect.Width(), rcRect.Height() - 20, SWP_NOZORDER);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BOOL CChatSelector::PreTranslateMessage(MSG* pMsg)
{
	return CClosableTabCtrl::PreTranslateMessage(pMsg);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::UpdateFont()
{
	chatout.SetFont(&g_App.m_pMDlg->m_fontDefault);

	TCITEM		tcitem;
	CChatItem	*pChatItem;
	int			i = 0;
	
	tcitem.mask = TCIF_PARAM;
	while (GetItem(i++, &tcitem))
	{
		pChatItem = (CChatItem*)tcitem.lParam;
		pChatItem->m_pLog->SetFont(&g_App.m_pMDlg->m_fontDefault);
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::OnEnLinkMessageBox(NMHDR *pNMHDR, LRESULT *pResult)
{
	*pResult = 0;

	ENLINK	*pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);

	if (pEnLink && pEnLink->msg == WM_LBUTTONDOWN)
	{
		CString	strUrl;

		chatout.GetTextRange(pEnLink->chrg.cpMin, pEnLink->chrg.cpMax, strUrl);
		if (strUrl == CLIENT_NAME)
			ShellExecute(NULL, NULL, _T("http://emuleplus.info"), NULL, NULL, SW_SHOWDEFAULT);
		*pResult = 1;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::OnDestroy()
{
	if (m_Timer != NULL)
		KillTimer(m_Timer);
	CClosableTabCtrl::OnDestroy();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CChatSelector::SendAwayMessage(CChatItem* ci)
{
	if (ci == NULL  || ci->m_pClient == NULL || ci->m_pClient->GetChatState() == MS_CONNECTING) //send AwayMessage only if connected
		return false;

#ifdef OLD_SOCKETS_ENABLED
	if (ci->m_pClient->IsHandshakeFinished())
	{
		CString	strAwayMessage = _T("[AUTO REPLY:AWAY] ") + g_App.m_pPrefs->GetAwayStateMessage();

		SendMessagePacket(*ci, strAwayMessage);

		COleDateTime	timelog(COleDateTime::GetCurrentTime());
		CString			strTmp;

		strTmp.Format(_T("%s (%s): "), g_App.m_pPrefs->GetUserNick(), timelog.Format(_T("%c")));
		ci->m_pLog->AppendText(strTmp, RGB(1, 180, 20));
		ci->m_pLog->AppendText(strAwayMessage + _T('\n'));
	}
#endif //OLD_SOCKETS_ENABLED
	return true;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::SendMessagePacket(CChatItem &ci, const CString &strMessage)
{
	CStringA	strEncodedMsg;

	Str2MB(ci.m_pClient->GetStrCodingFormat(), &strEncodedMsg, strMessage);

	uint32		dwMsgLen = strEncodedMsg.GetLength();
	Packet		*pPacket = new Packet(OP_MESSAGE, dwMsgLen + 2);

	POKE_WORD(pPacket->m_pcBuffer, static_cast<uint16>(dwMsgLen));
	memcpy2(pPacket->m_pcBuffer + 2, strEncodedMsg.GetString(), dwMsgLen);
	g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
#ifdef OLD_SOCKETS_ENABLED
	ci.m_pClient->m_pRequestSocket->SendPacket(pPacket, true, true);
#endif
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.133
log
@Reduced H-file dependency.
@
text
@d208 1
@


1.132
log
@Reduced H-file dependency.
@
text
@d26 1
@


1.131
log
@Optimized link identification and output to RichEdit controls (logs, chats, IRC).
@
text
@d24 1
@


1.130
log
@Simplified logging system implementation.
@
text
@d82 2
a83 2
	chatout.AppendText(CLIENT_NAME, RGB(153,51,102), CLR_DEFAULT, HTC_LINK);
	chatout.AppendText(_T(" v") CURRENT_VERSION_LONG _T(" - ") + GetResString(IDS_CHAT_WELCOME) + _T('\n'), RGB(153,51,102));
d350 1
a350 1
		pChatItem->m_pLog->AppendText(_T("*** ") + GetResString(IDS_CONNECTING), RGB(255, 0, 0));
d372 1
a372 1
			pChatItem->m_pLog->AppendText(_T(' ') + GetResString(IDS_FAILED) + _T('\n'), RGB(255, 0, 0));
d377 1
a377 1
			pChatItem->m_pLog->AppendText(GetResString(IDS_CHATDISCONNECTED) + _T('\n'), RGB(255, 0, 0));
d382 1
a382 1
		pChatItem->m_pLog->AppendText(_T(" ok\n"), RGB(255, 0, 0));
@


1.129
log
@Reduced H-file dependency.
@
text
@d230 1
a230 1
				AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leecher: Client %s has been banned because of spamming"), pSender->GetClientNameWithSoftware());
d247 1
a247 1
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Filtered message '%s' from client %s"), strIncomingMessage, pSender->GetClientNameWithSoftware());
d259 1
a259 1
			AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Instant Messaging: Messages limit reached"));
d271 1
a271 1
			AddLogLine(false, GetResString(IDS_IM_MSGFROMCHAT) + _T(" %s: %s"), pSender->GetUserName(), strIncomingMessage);
@


1.128
log
@Ban for spamming.
@
text
@d20 1
@


1.127
log
@Extended spam filter; Suppressed compiler warnings.
@
text
@a17 2
//	ChatSelector.cpp : implementation file

d205 1
@


1.126
log
@Unicode preparations
@
text
@d96 1
a96 1
	if (GetTabByClient(pClient) != (uint16)-1)
d177 1
a177 1
uint16 CChatSelector::GetTabByClient(CUpDownClient* client)
d184 1
a184 1
		if (GetItem(i, &tcitem) && ((CChatItem*)tcitem.lParam)->m_pClient == client)
d187 1
a187 1
	return (uint16)-1;
d207 1
d412 1
d464 1
a464 1
	bool	bWasChanged = (GetItemState(iCurSel, TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED);
d497 1
d675 2
a676 2
	uint16		uMessageLen = strEncodedMsg.GetLength();
	Packet		*pPacket = new Packet(OP_MESSAGE, uMessageLen + 2);
d678 2
a679 2
	memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);								//<messagelen 2>
	memcpy2(pPacket->m_pcBuffer + 2, strEncodedMsg.GetString(), uMessageLen);	//(<messagechar 1>)*messagelen
d683 1
a683 1
#endif //OLD_SOCKETS_ENABLED
@


1.125
log
@Extended ban filter on spam message [Aw3];
Unlocalized "Version" string in chat window on start was replaced with "v" [Aw3].
@
text
@d668 1
a668 2
	uint16	uMessageLen = strMessage.GetLength();
	Packet	*pPacket = new Packet(OP_MESSAGE, uMessageLen + 2);
d670 7
a676 2
	memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);							//<messagelen 2>
	memcpy2(pPacket->m_pcBuffer + 2, strMessage.GetString(), uMessageLen);	//(<messagechar 1>)*messagelen
@


1.124
log
@improved the string handling
@
text
@d84 1
a84 1
	chatout.AppendText(_T(" Version ") CURRENT_VERSION_LONG _T(" - ") + GetResString(IDS_CHAT_WELCOME) + _T('\n'), RGB(153,51,102));
d205 13
a217 1
	CString	strMessage = strIncomingMessage;
d223 1
a223 9
	if ( g_App.m_pPrefs->IsCounterMeasures() &&
		( strMessage.Find(_T("di-emule")) >= 0
		|| strMessage.Find(_T("emule fx")) >= 0
		|| strMessage.Find(_T("zambor")) >= 0
		|| strMessage.Find(_T("fastest emule ever")) >= 0
		|| strMessage.Find(_T("robot from riaa")) >= 0
		|| strMessage.Find(_T("ketamine")) >= 0
		|| strMessage.Find(_T("http://www.chez.com/theworld/")) >= 0
		|| strMessage.Find(_T("http://fullspeed.to/mison")) >= 0 ) )
d225 9
a233 3
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client %s has been banned because of spamming"), pSender->GetClientNameWithSoftware());
		pSender->Ban(BAN_CLIENT_SPAMMING);
		return;
@


1.123
log
@Extended previous ban detection to cover several cases.
@
text
@d203 1
a203 1
void CChatSelector::ProcessMessage(CUpDownClient* sender, LPCTSTR message)
d205 1
a205 1
	CString	strMessage = message;
d221 2
a222 2
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client %s has been banned because of spamming"), sender->GetClientNameWithSoftware());
		sender->Ban(BAN_CLIENT_SPAMMING);
d236 1
a236 1
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Filtered message '%s' from client %s"), message, sender->GetClientNameWithSoftware());
d241 1
a241 1
	CChatItem	*pChatItem = GetItemByClient(sender);
d255 1
a255 1
		if ((g_App.m_pPrefs->GetAcceptMessagesFrom() == 2) && !sender->IsFriend()) //only friends
d258 1
a258 1
		if ((g_App.m_pPrefs->GetAcceptMessagesFrom() == 3) && !sender->IsFriend()) //log non friends
d260 2
a261 2
			AddLogLine(false, GetResString(IDS_IM_MSGFROMCHAT) + _T(" %s: %s"), sender->GetUserName(), message);
			sender->SetChatState(MS_NONE);
d265 1
a265 1
		pChatItem = StartSession(sender);
d272 1
a272 1
	strMessage.Format(_T("%s (%s): "), sender->GetUserName(), timelog.Format(_T("%c")));
d274 1
a274 1
	pChatItem->m_pLog->AppendText(CString(message) + _T('\n'));
d285 1
a285 1
	if ((iCurPos = GetTabByClient(sender)) != GetCurSel())
d299 1
a299 1
				strMessage.Format(_T("%s %s:'%s'\n"), GetResString(IDS_TBN_NEWCHATMSG), sender->GetUserName(), message);
a641 2
		uint16	uMessageLen = _tcslen(static_cast<LPCTSTR>(strAwayMessage));
		Packet	*pPacket = new Packet(OP_MESSAGE, uMessageLen + 2);
d643 1
a643 4
		memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);								// <messagelen 2>
		memcpy2(pPacket->m_pcBuffer + 2, strAwayMessage, uMessageLen);				// (<messagechar 1>)*messagelen
		g_App.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
		ci->m_pClient->m_pRequestSocket->SendPacket(pPacket, true, true);
@


1.122
log
@fix time disappearing at midnight
@
text
@d215 1
a215 1
		|| strMessage.Find(_T("hypermule")) >= 0
@


1.121
log
@Ban for spamming.
@
text
@d136 1
a136 1
		timelog.Format());
d272 1
a272 1
	strMessage.Format(_T("%s (%s): "), sender->GetUserName(), timelog.Format());
d333 1
a333 1
		strTmp.Format(_T("%s (%s): "), g_App.m_pPrefs->GetUserNick(), timelog.Format());
d377 1
a377 1
		strTmp.Format(_T("%s (%s): "), g_App.m_pPrefs->GetUserNick(), timelog.Format());
d653 1
a653 1
		strTmp.Format(_T("%s (%s): "), g_App.m_pPrefs->GetUserNick(), timelog.Format());
@


1.120
log
@Formatting and code cleanup; Disable sending messages and starting / closing sessions during application shutdown.
@
text
@d215 1
@


1.119
log
@send the packets only if handshaking is finished to prevent a connection drop
@
text
@d72 1
a72 1
	CRect		rcRect;
d91 1
a91 1
	if (pClient == NULL)
d104 2
a105 2
	CChatItem		*pChatItem = new CChatItem();
	CRect			rcRect;
d150 1
a150 1
	TCITEM		tcitem;
d157 1
a157 1
	int			iResult = InsertItem(GetItemCount(), &tcitem);
d205 2
a206 2
	CString		strMessage = message;
	int			iCurPos = 0;
d225 1
a225 1
	CString		strResToken, strFilter = g_App.m_pPrefs->GetMessageFilter();
d240 2
a241 2
	CChatItem		*pChatItem = GetItemByClient(sender);
	bool			bIsNewChatWindow = false;
d308 4
a311 1
	CChatItem		*pChatItem = GetCurrentChatItem();
d349 1
a349 1
	CChatItem		*pChatItem = GetItemByClient(sender);
a364 1
		{
a365 1
		}
d385 1
a385 1
	TCITEM		tcitem;
d402 2
a403 2
	bool		globalnotify = false;
	TCITEM		tcitem;
d431 1
a431 1
	int			iCurSel = GetCurSel();
d436 1
a436 1
	TCITEM		tcitem;
d446 1
a446 1
	int				iCurSel = GetCurSel();
d451 1
a451 1
	bool			bWasChanged = (GetItemState(iCurSel, TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED);
d455 1
a455 1
	CChatItem		*pChatItem = GetCurrentChatItem(), *pUpdateItem;
d466 2
a467 2
	TCITEM			tcitem;
	int				i = 0;
d493 1
a493 1
	int		iResult = CClosableTabCtrl::InsertItem(nItem, pTabCtrlItem);
d514 4
a517 1
	int		iCurSel;
d519 1
a519 1
	if (client)
d527 1
a527 1
	TCITEM		tcitem;
d534 1
a534 1
	CChatItem		*pChatItem = (CChatItem*)tcitem.lParam;
d541 1
a541 1
	int			iTabItems = GetItemCount();
d545 2
a546 4
		// select next tab
		if (iCurSel == CB_ERR)
			iCurSel = 0;
		else if (iCurSel >= iTabItems)
d548 3
a550 3
		(void)SetCurSel(iCurSel);				// returns CB_ERR if error or no prev. selection(!)
		iCurSel = GetCurSel();					// get the real current selection
		if (iCurSel == CB_ERR)					// if still error
a554 1

d561 1
a561 1
	CRect		rcRect;
d575 3
a577 3
	TCITEM			tcitem;
	CChatItem		*pChatItem;
	int				i = 0;
d612 1
a612 1
	ENLINK		*pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);
d616 1
a616 1
		CString			strUrl;
d619 1
a619 3
		CString sLangUrl = strUrl; // GetTextRange returns '?' for non-english chars :(
		sLangUrl.Remove('?'); sLangUrl.Remove(' ');
		if ((strUrl == CLIENT_NAME) || sLangUrl.IsEmpty())
d627 1
a627 1
	if (m_Timer)
d640 3
a642 3
		CString		strAwayMessage = _T("[AUTO REPLY:AWAY] ") + g_App.m_pPrefs->GetAwayStateMessage();
		uint16		uMessageLen = _tcslen(static_cast<LPCTSTR>(strAwayMessage));
		Packet		*pPacket = new Packet(OP_MESSAGE, uMessageLen + 2);
d649 2
a650 2
		COleDateTime		timelog(COleDateTime::GetCurrentTime());
		CString				strTmp;
d662 2
a663 2
	uint16		uMessageLen = strMessage.GetLength();
	Packet		*pPacket = new Packet(OP_MESSAGE, uMessageLen + 2);
@


1.118
log
@Reduced H-file dependency.
@
text
@d322 1
a322 1
	if (pChatItem->m_pClient->m_pRequestSocket && pChatItem->m_pClient->m_pRequestSocket->IsConnected())
d639 1
a639 1
	if (ci->m_pClient->m_pRequestSocket && ci->m_pClient->m_pRequestSocket->IsConnected())
@


1.117
log
@new email notifier code (adapted from original) - fully UNICODE ready;
option to send email notification messages in subject
@
text
@a18 1
//
d23 1
@


1.116
log
@1) keep ban reason information (part 1 - logic)
2) disable incoming FR for LowID if file was paused
@
text
@a25 1
#include "Smtp.h"
d299 1
a299 1
				g_App.m_pSMTPConnection->SendMail(strMessage, true, g_App.m_pPrefs->IsSMTPInfoEnabled());
@


1.115
log
@UNICODE preparation (first shot)
@
text
@d222 1
a222 1
		sender->Ban(_T("AUTOMATED MESSAGE: Your client is being banned for spamming and leeching!"), GetResString(IDS_BAN_LEECHERSPAM));
@


1.114
log
@Ban for spamming.
@
text
@d85 1
a85 1
	chatout.AppendText(CString(" Version " CURRENT_VERSION_LONG " - ") + GetResString(IDS_CHAT_WELCOME) + _T("\n"), RGB(153,51,102));
@


1.113
log
@Ban for spamming.
@
text
@d216 1
@


1.112
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@d213 2
a214 1
		( strMessage.Find(_T("emule fx")) >= 0
@


1.111
log
@renamed 3 variables
@
text
@d212 1
a212 1
	if ( g_App.g_pPrefs->IsCounterMeasures() &&
d224 1
a224 1
	CString		strResToken, strFilter = g_App.g_pPrefs->GetMessageFilter();
d250 1
a250 1
		if (g_App.g_pPrefs->GetAcceptMessagesFrom() == 4) //no messages
d253 1
a253 1
		if ((g_App.g_pPrefs->GetAcceptMessagesFrom() == 2) && !sender->IsFriend()) //only friends
d256 1
a256 1
		if ((g_App.g_pPrefs->GetAcceptMessagesFrom() == 3) && !sender->IsFriend()) //log non friends
d274 1
a274 1
	if (g_App.g_pPrefs->GetAwayState())
d285 1
a285 1
	if (!g_App.g_pPrefs->GetAwayState())
d294 2
a295 2
			if ( ( g_App.g_pPrefs->GetUseChatNotifier() &&
				(bIsNewChatWindow || g_App.g_pPrefs->GetNotifierPopsEveryChatMsg()) ) )
d298 1
a298 1
				g_App.m_pSMTPConnection->SendMail(strMessage, true, g_App.g_pPrefs->IsSMTPInfoEnabled());
d312 1
a312 1
	if (pChatItem->m_strHistoryArray.GetCount() == g_App.g_pPrefs->GetMaxChatHistoryLines())
d328 1
a328 1
		strTmp.Format(_T("%s (%s): "), g_App.g_pPrefs->GetUserNick(), timelog.Format());
d374 1
a374 1
		strTmp.Format(_T("%s (%s): "), g_App.g_pPrefs->GetUserNick(), timelog.Format());
d640 1
a640 1
		CString		strAwayMessage = _T("[AUTO REPLY:AWAY] ") + g_App.g_pPrefs->GetAwayStateMessage();
d652 1
a652 1
		strTmp.Format(_T("%s (%s): "), g_App.g_pPrefs->GetUserNick(), timelog.Format());
@


1.110
log
@Ban 'eMule FX' on spam message.
@
text
@d81 1
a81 1
	chatout.SetFont(&g_eMuleApp.m_pdlgEmule->m_fontDefault);
d124 1
a124 1
	pChatItem->m_pLog->SetFont(&g_eMuleApp.m_pdlgEmule->m_fontDefault);
d131 1
a131 1
	if (g_eMuleApp.m_pIP2Country->IsIP2Country())
d160 2
a161 2
	g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlCloseButton.EnableWindow(true);
	g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlSendButton.EnableWindow(true);
d212 1
a212 1
	if ( g_eMuleApp.m_pGlobPrefs->IsCounterMeasures() &&
d224 1
a224 1
	CString		strResToken, strFilter = g_eMuleApp.m_pGlobPrefs->GetMessageFilter();
d250 1
a250 1
		if (g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 4) //no messages
d253 1
a253 1
		if ((g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 2) && !sender->IsFriend()) //only friends
d256 1
a256 1
		if ((g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 3) && !sender->IsFriend()) //log non friends
d274 1
a274 1
	if (g_eMuleApp.m_pGlobPrefs->GetAwayState())
d285 1
a285 1
	if (!g_eMuleApp.m_pGlobPrefs->GetAwayState())
d290 1
a290 1
		if (!bVisible || (g_eMuleApp.m_pdlgEmule->m_hWnd != ::GetForegroundWindow()))
d294 2
a295 2
			if ( ( g_eMuleApp.m_pGlobPrefs->GetUseChatNotifier() &&
				(bIsNewChatWindow || g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg()) ) )
d298 2
a299 2
				g_eMuleApp.m_pSMTPConnection->SendMail(strMessage, true, g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
				g_eMuleApp.m_pdlgEmule->ShowNotifier(strMessage, TBN_CHAT, false, true);
d312 1
a312 1
	if (pChatItem->m_strHistoryArray.GetCount() == g_eMuleApp.m_pGlobPrefs->GetMaxChatHistoryLines())
d328 1
a328 1
		strTmp.Format(_T("%s (%s): "), g_eMuleApp.m_pGlobPrefs->GetUserNick(), timelog.Format());
d374 1
a374 1
		strTmp.Format(_T("%s (%s): "), g_eMuleApp.m_pGlobPrefs->GetUserNick(), timelog.Format());
d392 2
a393 2
	g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlCloseButton.EnableWindow(false);
	g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlSendButton.EnableWindow(false);
d417 1
a417 1
		g_eMuleApp.m_pdlgEmule->ShowMessageState(((blinkstate) ? 1 : 2));
d422 1
a422 1
		g_eMuleApp.m_pdlgEmule->ShowMessageState(0);
d477 1
a477 1
	g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlInputText.SetFocus();
d503 2
a504 2
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlCloseButton.EnableWindow(false);
		g_eMuleApp.m_pdlgEmule->m_wndChat.m_ctlSendButton.EnableWindow(false);
d592 1
a592 1
	chatout.SetFont(&g_eMuleApp.m_pdlgEmule->m_fontDefault);
d602 1
a602 1
		pChatItem->m_pLog->SetFont(&g_eMuleApp.m_pdlgEmule->m_fontDefault);
d640 1
a640 1
		CString		strAwayMessage = _T("[AUTO REPLY:AWAY] ") + g_eMuleApp.m_pGlobPrefs->GetAwayStateMessage();
d646 1
a646 1
		g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
d652 1
a652 1
		strTmp.Format(_T("%s (%s): "), g_eMuleApp.m_pGlobPrefs->GetUserNick(), timelog.Format());
d667 1
a667 1
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(pPacket->m_dwSize);
@


1.109
log
@Ban one more message spammer; Formatting.
@
text
@d213 2
a214 1
		( strMessage.Find(_T("zambor")) >= 0
@


1.108
log
@IDS_CW_MESSAGES renamed into IDS_MESSAGES.
@
text
@d206 1
a206 1
	CString		strResToken, strMessage = message;
d211 6
a216 5
	//filter me?
	if (g_eMuleApp.m_pGlobPrefs->IsCounterMeasures()
		&& (strMessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/")) != -1
		|| strMessage.Find(_T("http://fullspeed.to/mison")) != -1
		|| strMessage.Find(_T("ketamine")) != -1))
d223 1
a223 1
	CString		strFilter = g_eMuleApp.m_pGlobPrefs->GetMessageFilter();
d236 1
a236 1
	};
a237 1
//	continue
@


1.107
log
@Some control declarations to avoid conflicts [Aw3].
@
text
@d82 1
a82 1
	chatout.SetTitle(GetResString(IDS_CW_MESSAGES));
@


1.106
log
@More space for info. fields in Messages window.
@
text
@d64 1
a64 1
	ON_NOTIFY(EN_LINK, 124, OnEnLinkMessageBox)
d79 1
a79 1
	chatout.Create(WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rcRect, this, 124);
@


1.105
log
@Unified way to show source with empty name (like in download list).
@
text
@d113 4
a116 1
	rcRect.DeflateRect(7, 7);
d119 1
a119 1
		rcRect.top += 19;
d562 4
a565 1
	rcRect.DeflateRect(7, 7);
d568 1
a568 1
		rcRect.top -= 19;
d580 1
a580 1
		pChatItem->m_pLog->SetWindowPos(NULL, rcRect.left, rcRect.top + 19, rcRect.Width(), rcRect.Height() - 19, SWP_NOZORDER);
@


1.104
log
@Unified way to display client name and version.
@
text
@d146 1
a146 1
		strName.Format(_T("(%s)"), GetResString(IDS_UNKNOWN));
@


1.103
log
@Show client port and country at chat session start.
@
text
@d152 1
a152 1
	tcitem.pszText = strName.GetBuffer();
d214 1
a214 1
		AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Anti-leechermods: Client '%s' (%s) has been banned because of spamming"), sender->GetUserName(), sender->GetClientNameAndVersionString());
d229 1
a229 1
			AddDebugLogLine(RGB_LOG_DIMMED_TXT _T("Filtered message '%s' from client '%s' (%s)"), message, sender->GetUserName(), sender->GetClientNameAndVersionString());
@


1.102
log
@Show message taskbar indicator also when Message pane is active but eMule Plus isn't topmost;
Fixed disable of blinking new message taskbar indicator (when Message is current pane,
new message notifier popped up and user activated eMule Plus from systray by tray icon clicking).
@
text
@d27 1
d126 1
a126 1
	CString			strName = pClient->GetUserName();
d128 8
a135 1
	pChatItem->m_pLog->AppendText(GetResString(IDS_CHAT_START) + strName + _T(" (IP: ") + pClient->GetFullIP() + _T(") - ") + timelog.Format() + _T('\n'), RGB(255, 0, 0));
@


1.101
log
@A more strict Ketamine banning.
@
text
@d277 3
a279 2
	//	Show statusbar indicator if Messages window isn't active
		if (!bVisible)
d281 2
a282 3
	//	Send Notification if Messages window isn't active or our application isn't top most one
		if ( (!bVisible || (g_eMuleApp.m_pdlgEmule->m_hWnd != ::GetForegroundWindow())) &&
			( g_eMuleApp.m_pGlobPrefs->GetUseChatNotifier() &&
d284 5
a288 4
		{
			strMessage.Format(_T("%s %s:'%s'\n"), GetResString(IDS_TBN_NEWCHATMSG), sender->GetUserName(), message);
			g_eMuleApp.m_pSMTPConnection->SendMail(strMessage, true, g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(strMessage, TBN_CHAT, false, true);
@


1.100
log
@Ban Ketamine spammers.
@
text
@d204 1
a204 1
		|| strMessage.Find(_T("join the l33cher team and buy a ketamine")) != -1))
@


1.99
log
@Added tooltips to the Friends list.
@
text
@d201 4
a204 1
	if ((strMessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/")) != -1) || (strMessage.Find(_T("http://fullspeed.to/mison")) != -1) && (g_eMuleApp.m_pGlobPrefs->IsCounterMeasures()))
@


1.98
log
@Minor fix: don't send new 'A new chat message was received' notification
if 'A new chat session was started' notification is disabled;
Send new message notifications also when Messages window's active,
but eMulePlus isn't foreground application (Message window can be closed
by another application in this case and a user can miss a message) {DopeFish/muleteer}.
@
text
@a124 1

d129 2
@


1.97
log
@Notification 'A new chat session was started' didn't work at all;
No indication (statusbar & notification) of a message reception to inactive chat session;
Minor optimization.
@
text
@d269 1
a269 1
	if (!g_eMuleApp.m_pGlobPrefs->GetAwayState() && !GetParent()->IsWindowVisible())
d271 9
a279 3
		pChatItem->m_bNotify = true;
		if ( g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg() ||
			(bIsNewChatWindow && g_eMuleApp.m_pGlobPrefs->GetUseChatNotifier()) )
@


1.96
log
@Removed unused closable tab stuff to reduce used memory and GDI resources.
@
text
@d230 1
a230 1
			AddDebugLogLine(RGB_LOG_WARNING_TXT _T("Instant Messaging: Messages limit reached"));		
d237 1
a237 1
		if ((g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 2) && (!(sender->IsFriend()))) //only friends
d240 1
a240 1
		if ((g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 3) && (!(sender->IsFriend()))) //log non friends
d258 1
a258 1
	if (g_eMuleApp.m_pGlobPrefs->GetAwayState() == true)
d267 3
a269 3
	if (GetCurSel() != GetTabByClient(sender))
		SetItemState(GetTabByClient(sender), TCIS_HIGHLIGHTED, TCIS_HIGHLIGHTED);
	else if (g_eMuleApp.m_pGlobPrefs->GetAwayState() == false && !GetParent()->IsWindowVisible())
d272 2
a273 1
		if (bIsNewChatWindow || g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg())
d276 2
a277 2
			g_eMuleApp.m_pSMTPConnection->SendMail(strMessage, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(strMessage, TBN_CHAT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg());
@


1.95
log
@Faster image lists icon loading; reduced memory usage.
@
text
@a71 7
	static const uint16 s_auIconResID[] =
	{
		IDI_CHAT,
		IDI_MESSAGE,
		IDI_MPENDING
	};

a85 4
	m_imageList.Create(16, 16, ILC_COLOR32 | ILC_MASK, ELEMENT_COUNT(s_auIconResID), 0);
	FillImgLstWith16x16Icons(&m_imageList, s_auIconResID, ELEMENT_COUNT(s_auIconResID));
	SetImageList(&m_imageList);

a143 1
	tcitem.cchTextMax = strName.GetLength() + 1;
a384 1
		tcitem.mask = TCIF_IMAGE;
a386 2
			tcitem.iImage = (blinkstate) ? 1 : 2;
			SetItem(i, &tcitem);
d388 1
a388 5
		}
		else if (tcitem.iImage != 0)
		{
			tcitem.iImage = 0;
			SetItem(i, &tcitem);
a602 1
	m_imageList.DeleteImageList();
@


1.94
log
@Improved string processing of message filtering.
@
text
@d93 1
a93 1
	m_imageList.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 10);
@


1.93
log
@Preparations for new client version report code.
@
text
@d137 3
a139 1
	pChatItem->m_pLog->AppendText(GetResString(IDS_CHAT_START) + CString(pClient->GetUserName()) + _T(" (IP: ") + CString(pClient->GetFullIP()) + _T(") - ") + timelog.Format() + _T("\n"), RGB(255, 0, 0));
a141 2
	CString			strName = pClient->GetUserName();

d206 1
a206 2
	CString		strMessage = CString(message).MakeLower();
	CString		strResToken;
d209 2
d214 1
a214 1
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Anti-leechermods: Client '%s' (%s) has been banned because of spamming"), sender->GetUserName(), sender->GetClientNameAndVersionString());
d219 4
a222 2
	strResToken = g_eMuleApp.m_pGlobPrefs->GetMessageFilter().Tokenize(_T("|"), iCurPos);
	while (!strResToken.IsEmpty())
d224 4
a227 1
		if (strMessage.Find(strResToken.MakeLower()) != -1)
d229 1
a229 1
			AddDebugLogLine(RGB_LOG_DIMMED + _T("Filtered message %s from client '%s' (%s)"), message, sender->GetUserName(), sender->GetClientNameAndVersionString());
a231 1
		strResToken = g_eMuleApp.m_pGlobPrefs->GetMessageFilter().Tokenize(_T("|"), iCurPos);
@


1.92
log
@A more correct way to set the ENM_LINK event for the RichEdit control + Minor changes.
@
text
@d213 1
a213 1
		AddDebugLogLine(RGB_LOG_DIMMED + _T("Anti-leechermods: Client '%s' (%s) has been banned because of spamming"), sender->GetUserName(), GetClientNameAndVersionString(sender));
d223 1
a223 1
			AddDebugLogLine(RGB_LOG_DIMMED + _T("Filtered message %s from client '%s' (%s)"), message, sender->GetUserName(), GetClientNameAndVersionString(sender));
@


1.91
log
@Added an option in IRC to send Bold, Underline & Colored messages.
Small optimization in IRC and some minor changes/fixes.
@
text
@a86 1
	chatout.SetEventMask(chatout.GetEventMask() | ENM_LINK);
d90 1
a90 1
	chatout.AppendText(CLIENT_NAME, CLR_DEFAULT, CLR_DEFAULT, HTC_LINK);
a130 1
	pChatItem->m_pLog->SetEventMask(pChatItem->m_pLog->GetEventMask() | ENM_LINK);
@


1.90
log
@Small optimization + Removed unused code.
@
text
@d91 1
a91 1
	chatout.AppendText(CLIENT_NAME, 0x1000000, 0x1000000, HTC_LINK);
@


1.89
log
@Fixed a GUI glitch in Messages window when multiple tabs are open and windows is themed;
Name changes, formatting etc.
@
text
@d90 1
a90 1
	chatout.m_bLimited = true;
d134 1
a134 1
	pChatItem->m_pLog->m_bWordWrap = true;
d452 1
a452 1
	if (pChatItem->m_pLog->m_bAutoScroll && bWasChanged)
@


1.88
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@a48 3
	m_pCloseBtn = NULL;
	m_pMessageBox = NULL;
	m_pSendBtn = NULL;
a62 2
	ON_BN_CLICKED(IDC_CCLOSE, OnBnClickedCclose)
	ON_BN_CLICKED(IDC_CSEND, OnBnClickedCsend)
d79 1
a79 36
	CRect rect, rClose, rSend, rMessage, rChatOut;

	GetClientRect(&rect);
	AdjustRect(FALSE, rect);

	m_pCloseBtn = GetParent()->GetDlgItem(IDC_CCLOSE);
	m_pCloseBtn->SetParent(this);
	m_pCloseBtn->GetWindowRect(&rClose);
	m_pCloseBtn->SetWindowPos( NULL, rect.right - 7 - rClose.Width(), rect.bottom - 7 - rClose.Height(),
	                           rClose.Width(), rClose.Height(), SWP_NOZORDER );
	m_pCloseBtn->EnableWindow(false);

	m_pSendBtn = GetParent()->GetDlgItem(IDC_CSEND);
	m_pSendBtn->SetParent(this);
	m_pSendBtn->GetWindowRect(&rSend);
	m_pSendBtn->SetWindowPos( NULL, rect.right - 7 - rClose.Width() - 7 - rSend.Width(), rect.bottom - 7 - rSend.Height(),
	                          rSend.Width(), rSend.Height(), SWP_NOZORDER );
	m_pSendBtn->EnableWindow(false);

	m_pMessageBox = GetParent()->GetDlgItem(IDC_CMESSAGE);
	m_pMessageBox->SetParent(this);
	m_pMessageBox->GetWindowRect(&rMessage);
	m_pMessageBox->SetWindowPos( NULL, rect.left + 7, rect.bottom - 9 - rMessage.Height(),
	                             rect.right - 7 - rClose.Width() - 7 - rSend.Width() - 21,
	                             rMessage.Height(), SWP_NOZORDER );

	int iTop = rClose.Height() > rSend.Height() ? rClose.Height() : rSend.Height();

	if (iTop < rMessage.Height())
		iTop = rMessage.Height();

	rChatOut = rect;
	rChatOut.top += 7;
	rChatOut.left += 7;
	rChatOut.right -= 18;
	rChatOut.bottom -= 7 - iTop - 7;
d81 3
d85 1
a85 1
	chatout.Create(WS_VISIBLE | WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rChatOut, this, 124);
d90 1
d92 1
a92 1
	chatout.AppendText(CString(" Version " CURRENT_VERSION_LONG " - ") + GetResString(IDS_CHAT_WELCOME));
d108 1
a108 1
	if (GetTabByClient(pClient) != 0xFFFF)
d117 1
d122 3
a124 5
	CRect rcChat, rcClose, rcSend, rcMessage, rcClient;

	m_pCloseBtn->GetWindowRect(&rcClose);
	m_pSendBtn->GetWindowRect(&rcSend);
	m_pMessageBox->GetWindowRect(&rcMessage);
a125 11
	int iTop = rcClose.Height() > rcSend.Height() ? rcClose.Height() : rcSend.Height();

	if (iTop < rcMessage.Height())
		iTop = rcMessage.Height();
	
	GetClientRect(&rcClient);
	AdjustRect(false, rcClient);
	rcChat.left = rcClient.left + 7;
	rcChat.top = rcClient.top + 7;
	rcChat.right = rcChat.left + rcClient.right - 18;
	rcChat.bottom = rcChat.top + rcClient.Height() - 7 - iTop - 14;
d127 1
a127 1
		rcChat.top += 19;
d129 1
a129 1
	pChatItem->m_pLog->Create(WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rcChat, this, (UINT)-1);
d162 2
a163 2
	m_pCloseBtn->EnableWindow(true);
	m_pSendBtn->EnableWindow(true);
d377 2
a378 2
	m_pCloseBtn->EnableWindow(false);
	m_pSendBtn->EnableWindow(false);
d469 1
a469 1
	m_pMessageBox->SetFocus();
d495 2
a496 2
		m_pCloseBtn->EnableWindow(false);
		m_pSendBtn->EnableWindow(false);
d551 1
a551 1
	CRect		 rect, rClose, rSend, rMessage;
d553 3
a555 19
	GetClientRect(&rect);
	AdjustRect(FALSE, rect);

	m_pCloseBtn->GetWindowRect(&rClose);
	m_pCloseBtn->SetWindowPos( NULL, rect.right - 7 - rClose.Width(), rect.bottom - 7 - rClose.Height(),
	                           rClose.Width(), rClose.Height(), SWP_NOZORDER );
	m_pSendBtn->GetWindowRect(&rSend);
	m_pSendBtn->SetWindowPos( NULL, rect.right - 7 - rClose.Width() - 7 - rSend.Width(), rect.bottom - 7 - rSend.Height(),
	                          rSend.Width(), rSend.Height(), SWP_NOZORDER );

	m_pMessageBox->GetWindowRect(&rMessage);
	m_pMessageBox->SetWindowPos( NULL, rect.left + 7, rect.bottom - 9 - rMessage.Height(),
	                             rect.right - 7 - rClose.Width() - 7 - rSend.Width() - 21,
	                             rMessage.Height(), SWP_NOZORDER );

	int			iTop = rClose.Height() > rSend.Height() ? rClose.Height() : rSend.Height();

	if (iTop < rMessage.Height())
		iTop = rMessage.Height();
d558 1
a558 1
		rect.top -= 19;
d560 1
a560 1
	chatout.SetWindowPos(NULL, rect.left + 7, rect.top + 7, rect.right - 18, rect.Height() - 7 - iTop - 14, SWP_NOZORDER);
d570 1
a570 1
		pChatItem->m_pLog->SetWindowPos(NULL, rect.left + 7, rect.top + 7 + 19, rect.right - 18, rect.Height() - 7 - iTop - 14, SWP_NOZORDER);
a573 20
void CChatSelector::OnBnClickedCclose()
{
	EndSession();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CChatSelector::OnBnClickedCsend()
{
	EMULE_TRY

	CString			strNewMessage;

	m_pMessageBox->GetWindowText(strNewMessage);
	strNewMessage.Trim();
	if (!strNewMessage.IsEmpty() && SendMessage(strNewMessage))
		m_pMessageBox->SetWindowText(_T(""));
	m_pMessageBox->SetFocus();

	EMULE_CATCH
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
a575 16
	if (pMsg->message == WM_KEYDOWN)
	{

		if (pMsg->wParam == VK_RETURN)
		{
			if (pMsg->hwnd == m_pMessageBox->m_hWnd)
				OnBnClickedCsend();
		}

		if ( (pMsg->hwnd == GetDlgItem(IDC_CMESSAGE)->m_hWnd) &&
		     (pMsg->wParam == VK_UP || pMsg->wParam == VK_DOWN) )
		{
			g_eMuleApp.m_pdlgEmule->m_wndChat.ScrollHistory(pMsg->wParam == VK_DOWN);
			return TRUE;
		}
	}
a578 15
void CChatSelector::Localize(void)
{
	if (m_hWnd)
	{
		if (m_pSendBtn)
			m_pSendBtn->SetWindowText(GetResString(IDS_CW_SEND));
		else
			GetParent()->SetDlgItemText(IDC_CSEND, GetResString(IDS_CW_SEND));
		if (m_pCloseBtn)
			m_pCloseBtn->SetWindowText(GetResString(IDS_CW_CLOSE));
		else
			GetParent()->SetDlgItemText(IDC_CCLOSE, GetResString(IDS_CW_CLOSE));
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
@


1.87
log
@Some changes to fix the focus change issue
@
text
@d263 1
a263 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Anti-leechermods: Client '%s' (%s) has been banned because of spamming"), sender->GetUserName(), GetClientNameAndVersionString(sender));
d273 1
a273 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered message %s from client '%s' (%s)"), message, sender->GetUserName(), GetClientNameAndVersionString(sender));
d287 1
a287 1
			AddDebugLogLine(false, RGB_LOG_WARNING_TXT _T("Instant Messaging: Messages limit reached"));		
@


1.86
log
@some fixes/changes
@
text
@d137 1
a137 1
CChatItem* CChatSelector::StartSession(CUpDownClient* pClient)
d147 2
a148 1
		ShowChat();
d217 2
a218 1
		ShowChat();
d376 1
a376 1
void CChatSelector::ConnectingResult(CUpDownClient* sender, bool success)
d385 1
a385 1
	if (!success)
d550 1
a550 1
void CChatSelector::EndSession(CUpDownClient* client)
d589 2
a590 1
		ShowChat();
@


1.85
log
@#ifdef _DEBUG "disconnected" statuslines
@
text
@d731 1
@


1.84
log
@small improvement and some minor fixes
@
text
@d388 1
a388 1
			pChatItem->m_strMessagePending.Empty();	//SyruS i wish compiler would warn on this: delete[] ci->messagepending;
d390 1
d392 1
d394 2
@


1.83
log
@small fix
@
text
@d127 1
a127 1
	chatout.AppendHyperLink(_T(""), _T(""), CLIENT_NAME, _T(""));
@


1.82
log
@more fixes/changes
@
text
@d122 1
a122 1
	chatout.Create(WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rChatOut, this, 124);
@


1.81
log
@minor fix
@
text
@d122 1
a122 1
	chatout.Create(WS_VISIBLE | WS_CHILD | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY | ES_NOHIDESEL, rChatOut, this, 124);
d176 1
a176 1
	pChatItem->m_pLog->Create(WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | WS_VSCROLL | ES_MULTILINE | ES_READONLY, rcChat, this, (UINT)-1);
d192 4
a195 1
		strName = strName.Left(30) + _T("...");
@


1.80
log
@s'more fixes
@
text
@d480 2
d489 1
d491 3
@


1.79
log
@yet another fix
@
text
@d147 1
d189 1
a189 5
	CString			strName;

	if (!pClient->GetUserName().IsEmpty())
	{
		strName = pClient->GetUserName();
d191 3
a193 5
		if (strName.GetLength() > 30)
			strName = strName.Left(30) + _T("...");
	}
	else
	{
a194 1
	}
d256 1
a256 1
	if ((strMessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/")) > -1) || (strMessage.Find(_T("http://fullspeed.to/mison")) > -1) && (g_eMuleApp.m_pGlobPrefs->IsCounterMeasures()))
d264 1
a264 1
	while (strResToken != "")
d266 1
a266 1
		if (strMessage.Find(strResToken.MakeLower()) > -1)
a304 1
	CString			strTmp;
d306 2
a307 2
	strTmp.Format(_T("%s (%s): "), sender->GetUserName(), timelog.Format());
	pChatItem->m_pLog->AppendText(strTmp, RGB(50, 200, 250));
d318 1
d321 1
a321 1
	else if (g_eMuleApp.m_pGlobPrefs->GetAwayState() == false)
d326 3
a328 5
			CString		strMessageText;

			strMessageText.Format(_T("%s %s:'%s'\n"), GetResString(IDS_TBN_NEWCHATMSG), sender->GetUserName(), message);
			g_eMuleApp.m_pSMTPConnection->SendMail(strMessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(strMessageText, TBN_CHAT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg());
a329 1
		bIsNewChatWindow = false;
d390 1
a390 1
	else
a624 13

	int			iTotalTabs = GetItemCount();

	if (iTotalTabs != -1 && iTotalTabs > 0)
	{
		SetCurSel(iTotalTabs-1);
		ShowChat();
	}
	else if (iTotalTabs != -1 && iTotalTabs == 0)
	{
		SetCurSel(iTotalTabs);
		ShowChat();
	}
d637 1
d722 1
a722 1
	if (ci == NULL  || ci->m_pClient == NULL)
a724 3
	if (ci->m_pClient->GetChatState() == MS_CONNECTING)
		return false; //send AwayMessage only if connected

d728 1
a728 1
		CString		strAwayMessage = CString("[AUTO REPLY:AWAY] ") + CString(g_eMuleApp.m_pGlobPrefs->GetAwayStateMessage());
d742 1
a742 1
		ci->m_pLog->AppendText(CString(strAwayMessage) + _T('\n'));
@


1.78
log
@minor fixes
@
text
@d284 1
a284 1
	if (pChatItem != NULL)
@


1.77
log
@Removed CPreparedRTFText class
@
text
@d173 1
a173 1
		rcChat.top += 20;
d614 3
d621 1
a621 1
	int				i;
a623 1
	i = 0;
d627 1
a627 1
		pChatItem->m_pLog->SetWindowPos(NULL, rect.left + 7, rect.top + 27, rect.right - 18, rect.Height() - 7 - iTop - 14, SWP_NOZORDER);
d701 2
@


1.76
log
@IRC channel messages now supports background color coded messages (Thanks SyruS!);
Added a Word Wrap context menu option to logs, IRC & messages;
Fixed category tabs padding (Mantis bug #0000415);
Improved logs, IRC & messages code + formatting & name changes
@
text
@a123 2
	chatout.AppendHyperLink(_T(""), _T(""), CLIENT_NAME, _T(""));
	chatout.AppendText(CString(" Version " CURRENT_VERSION_LONG " - ") + GetResString(IDS_CHAT_WELCOME));
d127 2
a130 1
//	m_imageList.SetBkColor(RGB(255, 0, 255));
d132 1
a133 21
	SetImageList(&m_imageList);
/*
	
	CImageList imageList;
	CBitmap Bitmap, *pOldBitmap;
	CDC *pCtrlDC = GetDC(), TempDC;

	TempDC.CreateCompatibleDC(pCtrlDC);
	Bitmap.CreateCompatibleBitmap(pCtrlDC, 16 * 3, 16);
	pOldBitmap = TempDC.SelectObject(&Bitmap);
	m_imageList.Draw(&TempDC, 0, CPoint(0, 0), ILD_NORMAL);
	m_imageList.Draw(&TempDC, 1, CPoint(16, 0), ILD_NORMAL);
	m_imageList.Draw(&TempDC, 2, CPoint(32, 0), ILD_NORMAL);
	TempDC.SelectObject(pOldBitmap);
	imageList.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 10);
	imageList.Add(&Bitmap, RGB(255, 0, 255));
	SetImageList(&imageList);
	imageList.Detach();
	Bitmap.DeleteObject();
	ReleaseDC(pCtrlDC);
*/
a146 2
		chatout.SetHyperText(GetItemByClient(pClient)->m_pLog);
		chatout.SetTitle(pClient->GetUserName());
a151 1
	pChatItem->m_pLog = new CPreparedRTFText();
d153 29
d218 2
a219 2
		chatout.SetHyperText(pChatItem->m_pLog);
		chatout.SetTitle(pClient->GetUserName());
a221 3
	if (g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_wndChat)
		m_pMessageBox->SetFocus();

a326 2
	if (GetCurSel() == GetTabByClient(sender) && GetParent()->IsWindowVisible())
		chatout.SetHyperText(pChatItem->m_pLog);
a376 1
	chatout.SetHyperText(pChatItem->m_pLog);
a411 1
	chatout.SetHyperText(pChatItem->m_pLog);
d424 3
d484 3
a486 1
	if (GetCurSel() == -1)
a487 4
	/*
	TCITEM cur_item;
	cur_item.mask = TCIF_PARAM;
	GetItem(GetCurSel(),&cur_item);*/
d489 3
a491 1
	CChatItem	*pChatItem = GetCurrentChatItem();
d496 14
a509 2
	chatout.SetHyperText(pChatItem->m_pLog);
	chatout.SetTitle(pChatItem->m_pClient->GetUserName());
a511 1
	SetItemState(GetCurSel(), TCIS_HIGHLIGHTED, NULL);
d522 2
a523 8
	if (!GetItemCount())
	{
		WINDOWPLACEMENT		wp;

		chatout.GetWindowPlacement(&wp);
		wp.rcNormalPosition.top += 20;
		chatout.SetWindowPlacement(&wp);
	}
d536 1
a536 9
		WINDOWPLACEMENT		wp;

		chatout.GetWindowPlacement(&wp);
		wp.rcNormalPosition.top -= 20;
		chatout.SetWindowPlacement(&wp);
		chatout.Reset();
		chatout.AppendHyperLink(_T(""), _T(""), CLIENT_NAME, _T(""));
		chatout.AppendText(CString(" Version " CURRENT_VERSION_LONG " - ") + GetResString(IDS_CHAT_WELCOME));
		chatout.SetTitle(GetResString(IDS_CW_MESSAGES));
a567 2
	if (chatout.GetHyperText() == pChatItem->m_pLog)
		chatout.SetHyperText(0);
d615 12
d697 14
a764 1
	chatout.SetHyperText(ci->m_pLog);
@


1.75
log
@Unified definitions for client name.
@
text
@a169 2
		if ((chatout.m_bAutoScroll))
			chatout.ScrollToLastLine();
d173 2
a174 1
	CChatItem* pChatItem = new CChatItem();
d178 1
a178 2
	COleDateTime timelog(COleDateTime::GetCurrentTime());
	CString sessions = GetResString(IDS_CHAT_START) + CString(pClient->GetUserName()) + _T(" (IP: ") + CString(pClient->GetFullIP()) + _T(") - ") + timelog.Format() + _T("\n");
d180 1
a180 1
	pChatItem->m_pLog->AppendText(sessions, RGB(255, 0, 0));
d183 1
a183 1
	CString strName;
d197 1
a197 1
	TCITEM newitem;
d199 7
a205 6
	newitem.mask = TCIF_PARAM | TCIF_TEXT | TCIF_IMAGE;
	newitem.lParam = (LPARAM)pChatItem;
	newitem.pszText = strName.GetBuffer();
	newitem.cchTextMax = strName.GetLength() + 1;
	newitem.iImage = 0;
	uint16 itemnr = InsertItem(GetItemCount(), &newitem);
d210 1
a210 1
	if (IsWindowVisible())
d212 1
a212 1
		SetCurSel(itemnr);
a214 2
		if ((chatout.m_bAutoScroll))
			chatout.ScrollToLastLine();
d229 3
a231 1
	for (int i = 0; i < GetItemCount();i++)
d233 2
a234 4
		TCITEM cur_item;

		cur_item.mask = TCIF_PARAM;
		if (GetItem(i, &cur_item) && ((CChatItem*)cur_item.lParam)->m_pClient == client)
d242 3
a244 1
	for (int i = 0; i < GetItemCount();i++)
d246 3
a248 5
		TCITEM cur_item;

		cur_item.mask = TCIF_PARAM;
		if (GetItem(i, &cur_item) && ((CChatItem*)cur_item.lParam)->m_pClient == client)
			return(CChatItem*)cur_item.lParam;
d255 4
d260 1
a260 5
	CString Cmessage = CString(message).MakeLower();
	CString resToken;
	int curPos = 0;

	if ((Cmessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/")) > -1) || (Cmessage.Find(_T("http://fullspeed.to/mison")) > -1) && (g_eMuleApp.m_pGlobPrefs->IsCounterMeasures()))
d267 2
a268 2
	resToken = g_eMuleApp.m_pGlobPrefs->GetMessageFilter().Tokenize(_T("|"), curPos);
	while (resToken != "")
d270 1
a270 1
		if (Cmessage.Find(resToken.MakeLower()) > -1)
d275 1
a275 1
		resToken = g_eMuleApp.m_pGlobPrefs->GetMessageFilter().Tokenize(_T("|"), curPos);
d279 2
a280 2
	CChatItem* ci = GetItemByClient(sender);
	bool isNewChatWindow = false;
d282 1
a282 1
	if (!ci)
d293 2
a294 3
		if (g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 2) //only friends
			if (!(sender->IsFriend()))
				return;
d296 2
a297 2
		if ((g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom() == 3) && (!(sender->IsFriend())))
		{ //only friends
d303 2
a304 2
		ci = StartSession(sender);
		if (!ci)
d306 1
a306 1
		isNewChatWindow = true;
d312 2
a313 2
	ci->m_pLog->AppendText(strTmp, RGB(50, 200, 250));
	ci->m_pLog->AppendText(CString(message) + _T('\n'));
d317 1
a317 1
		if ((::GetTickCount() - ci->m_pClient->GetAwayMessageResendCount()) > 3000)
d319 2
a320 2
			SendAwayMessage(ci);
			ci->m_pClient->SetAwayMessageResendCount(::GetTickCount());
d326 1
a326 1
		chatout.SetHyperText(ci->m_pLog);
d329 2
a330 2
		ci->m_bNotify = true;
		if (isNewChatWindow || g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg())
d332 5
a336 4
			CString MessageText;
			MessageText.Format("%s %s:'%s'\n", GetResString(IDS_TBN_NEWCHATMSG), sender->GetUserName(), message);
			g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
			g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_CHAT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg());
d338 1
a338 1
		isNewChatWindow = false;
d344 1
a344 1
	CChatItem * ci = GetCurrentChatItem();
d346 1
a346 1
	if (ci == NULL || ci->m_pClient == NULL)
d349 4
a352 4
	if (ci->m_strHistoryArray.GetCount() == g_eMuleApp.m_pGlobPrefs->GetMaxChatHistoryLines())
		ci->m_strHistoryArray.RemoveAt(0);
	ci->m_strHistoryArray.Add(CString(message));
	ci->m_iHistoryIndex = ci->m_strHistoryArray.GetCount();
d354 1
a354 1
	if (ci->m_pClient->GetChatState() == MS_CONNECTING)
d356 1
d358 1
a358 1
	if (ci->m_pClient->m_pRequestSocket && ci->m_pClient->m_pRequestSocket->IsConnected())
d360 1
a360 1
		SendMessagePacket(*ci, message);
d366 2
a367 2
		ci->m_pLog->AppendText(strTmp, RGB(1, 180, 20));
		ci->m_pLog->AppendText(message + _T('\n'));
d371 4
a374 4
		ci->m_pLog->AppendText(_T("*** ") + GetResString(IDS_CONNECTING), RGB(255, 0, 0));
		ci->m_strMessagePending = message;
		ci->m_pClient->SetChatState(MS_CONNECTING);
		ci->m_pClient->TryToConnect();
d377 1
a377 2
	if (chatout.GetHyperText() == ci->m_pLog)
		chatout.UpdateSize();
d383 1
a383 1
	CChatItem * ci = GetItemByClient(sender);
d385 1
a385 1
	if (ci == NULL || ci->m_pClient == NULL)
d387 3
a389 1
	ci->m_pClient->SetChatState(MS_CHATTING);
d392 1
a392 1
		if (!ci->m_strMessagePending.IsEmpty())
d394 2
a395 2
			ci->m_pLog->AppendText(_T(' ') + GetResString(IDS_FAILED) + _T('\n'), RGB(255, 0, 0));
			ci->m_strMessagePending.Empty();	//SyruS i wish compiler would warn on this: delete[] ci->messagepending;
d398 1
a398 1
			ci->m_pLog->AppendText(GetResString(IDS_CHATDISCONNECTED) + _T('\n'), RGB(255, 0, 0));
d402 2
a403 2
		ci->m_pLog->AppendText(_T(" ok\n"), RGB(255, 0, 0));
		SendMessagePacket(*ci, ci->m_strMessagePending);
d409 3
a411 3
		ci->m_pLog->AppendText(strTmp, RGB(1, 180, 20));
		ci->m_pLog->AppendText(ci->m_strMessagePending + _T('\n'));
		ci->m_strMessagePending.Empty();
d413 1
a413 2
	if (chatout.GetHyperText() == ci->m_pLog)
		chatout.UpdateSize();
d418 3
a420 1
	for (int i = 0; i < GetItemCount();i++)
d422 3
a424 5
		TCITEM cur_item;

		cur_item.mask = TCIF_PARAM;
		if (GetItem(i, &cur_item))
			delete (CChatItem*)cur_item.lParam;
a430 1
	bool globalnotify = false;
d432 4
a435 1
	for (int i = 0; i < GetItemCount();i++)
d437 2
a438 4
		TCITEM cur_item;

		cur_item.mask = TCIF_PARAM;
		if (!GetItem(i, &cur_item))
d441 2
a442 2
		cur_item.mask = TCIF_IMAGE;
		if (((CChatItem*)cur_item.lParam)->m_bNotify)
d444 2
a445 2
			cur_item.iImage = (blinkstate) ? 1 : 2;
			SetItem(i, &cur_item);
d448 1
a448 1
		else if (cur_item.iImage != 0)
d450 2
a451 2
			cur_item.iImage = 0;
			SetItem(i, &cur_item);
d468 1
a468 1
	int iCurSel = GetCurSel();
d473 1
a473 1
	TCITEM cur_item;
d475 2
a476 2
	cur_item.mask = TCIF_PARAM;
	if (!GetItem(iCurSel, &cur_item))
d478 1
a478 1
	return (CChatItem*)cur_item.lParam;
d483 1
a483 1
	if (GetCurSel() == ( -1))
d490 3
a492 2
	CChatItem* ci = GetCurrentChatItem();
	if (!ci)
d495 3
a497 3
	chatout.SetHyperText(ci->m_pLog);
	chatout.SetTitle(ci->m_pClient->GetUserName());
	ci->m_bNotify = false;
a498 2
	if ((chatout.m_bAutoScroll) /*&& (GetItemState(GetCurSel(), TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED)*/)
		chatout.ScrollToLastLine();
d512 1
a512 1
		WINDOWPLACEMENT wp;
d518 2
a519 1
	int result = CClosableTabCtrl::InsertItem(nItem, pTabCtrlItem);
d522 1
a522 1
	return result;
d530 1
a530 1
		WINDOWPLACEMENT wp;
d548 1
a548 1
	int iCurSel;
d554 1
d558 1
a558 1
	TCITEM item;
d560 3
a562 2
	item.mask = TCIF_PARAM;
	if (!GetItem(iCurSel, &item) || item.lParam == 0)
d564 4
a567 2
	CChatItem* ci = (CChatItem*)item.lParam;
	ci->m_pClient->SetChatState(MS_NONE);
d570 1
a570 1
	if (chatout.GetHyperText() == ci->m_pLog)
d572 1
a572 1
	delete ci;
d574 1
a574 1
	int iTabItems = GetItemCount();
d596 2
a597 1
	CRect rect, rClose, rSend, rMessage;
d613 1
a613 1
	int iTop = rClose.Height() > rSend.Height() ? rClose.Height() : rSend.Height();
d625 1
a625 1
	int iTotalTabs = GetItemCount();
d627 1
a627 1
	if(iTotalTabs != -1 && iTotalTabs > 0)
d643 1
a643 1
	CString strNewMessage;
d692 2
a693 1
	ENLINK* pEnLink = reinterpret_cast<ENLINK *>(pNMHDR);
d697 1
a697 1
		CString strUrl;
d743 1
a743 2
	if (chatout.GetHyperText() == ci->m_pLog)
		chatout.UpdateSize();
@


1.74
log
@Reverted some __FUNCTION__ logs as they weren't useful for users and were taking too much log space. We can always resort to search for the string.
@
text
@d124 1
a124 1
	chatout.AppendHyperLink(_T(""),_T(""),_T("eMule Plus"),_T(""));
d538 1
a538 1
		chatout.AppendHyperLink(_T(""),_T(""),_T("eMule Plus"),_T(""));
d698 1
a698 1
		if (strUrl == _T("eMule Plus") || sLangUrl.IsEmpty())
@


1.73
log
@DebugLog formating and changes
@
text
@d265 1
a265 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Anti-leechermods: Client %s (%s) has been banned because of spamming"), __FUNCTION__, sender->GetUserName(), GetClientNameAndVersionString(sender));
d275 1
a275 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("%s: Filtered message %s from user %s (%s)"), __FUNCTION__, message, sender->GetUserName(), GetClientNameAndVersionString(sender));
d289 1
a289 1
			AddDebugLogLine(false, RGB_LOG_WARNING_TXT _T("%s: Instant Messaging: Messages limit reached"), __FUNCTION__);		
@


1.72
log
@minor changes, fixes and improvements
@
text
@d265 1
a265 1
		AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Anti-leechermods: Client %s (%s) has been banned because of spamming"), sender->GetUserName(), GetClientNameAndVersionString(sender));
d275 1
a275 1
			AddDebugLogLine(false, RGB_LOG_DIMMED + _T("Filtered message %s from user %s (%s)"), message, sender->GetUserName(), GetClientNameAndVersionString(sender));
d289 1
a289 1
			AddDebugLogLine(false, RGB_LOG_WARNING_TXT _T("Instant Messaging: Messages limit reached"));		
@


1.71
log
@Some changes to track the Ban Messages crashes
@
text
@d130 2
a131 2
	m_imageList.Create(16, 16, ILC_COLOR32, 0, 10);
	m_imageList.SetBkColor(RGB(255, 0, 255));
d134 3
d154 1
a154 1

@


1.70
log
@IRC/Messages "Close" & "Send" buttons are now disabled until there is an open closeable tab
@
text
@d155 1
a155 1
CChatItem* CChatSelector::StartSession(CUpDownClient* pClient, bool show)
d164 5
a168 8
		if (show)
		{
			SetCurSel(GetTabByClient(pClient));
			chatout.SetHyperText(GetItemByClient(pClient)->m_pLog);
			chatout.SetTitle(pClient->GetUserName());
			if ((chatout.m_bAutoScroll) /*&& (GetItemState(GetTabByClient(pClient), TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED)*/)
				chatout.ScrollToLastLine();
		}
d192 1
d194 1
d208 1
a208 1
	if (show || IsWindowVisible())
d213 1
a213 1
		if ((chatout.m_bAutoScroll) /*&& (GetItemState(itemnr, TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED)*/)
d217 1
a217 1
	if (show || g_eMuleApp.m_pdlgEmule->m_pdlgActive == &g_eMuleApp.m_pdlgEmule->m_wndChat)
d304 1
a304 1
		ci = StartSession(sender, false);
@


1.69
log
@xrmb fix for inability to receive instant messages
@
text
@d84 2
a85 1
	CRect rect;
a88 1
	CRect rClose;
d94 2
a95 1
	CRect rSend;
d101 1
a102 1
	CRect rMessage;
d111 1
d115 1
a115 1
	CRect rChatOut = rect;
d181 1
d185 2
a186 1
	CString name;
d189 1
a189 1
		name = pClient->GetUserName();
d191 2
a192 2
		if (name.GetLength() > 30)
			name = name.Left(30) + _T("...");
d195 1
a195 1
		name.Format(_T("(%s)"), GetResString(IDS_UNKNOWN));
d198 1
d201 2
a202 2
	newitem.pszText = name.GetBuffer();
	newitem.cchTextMax = name.GetLength() + 1;
d205 4
d233 1
d246 1
d282 1
d346 1
d385 1
d421 1
d432 1
d436 1
d468 2
a469 1
	int iCurSel = GetCurSel();	
d474 1
d514 1
d520 1
d528 1
a528 1
	if (!GetItemCount())
d531 1
d539 2
d549 1
d558 1
d571 3
a573 1
	if (iTabItems > 0){
d592 1
a592 1
	CRect rect;
a595 1
	CRect rClose;
a598 1
	CRect rSend;
a602 1
	CRect rMessage;
d609 1
a642 1
	{
a643 1
	}
d688 1
d692 1
@


1.68
log
@minor changes (function renamings, unused typedef removal)
@
text
@d273 3
a275 1
		if (GetItemCount() >= g_eMuleApp.m_pGlobPrefs->GetMsgSessionsMax())
d277 1
@


1.67
log
@Improve image list filling.
@
text
@d250 1
a250 1
	if ((Cmessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/")) > -1) || (Cmessage.Find(_T("http://fullspeed.to/mison")) > -1) && (g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM()))
@


1.66
log
@Improved string processing.
@
text
@d77 7
d130 2
a131 4
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CHAT), 16, 16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MESSAGE), 16, 16));
	m_imageList.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MPENDING), 16, 16));
	LoadImgLstIcon(NULL, 0, 0);
d135 1
@


1.65
log
@some changes
@
text
@d289 2
a290 1
	ci->m_pLog->AppendText(sender->GetUserName(), RGB(50, 200, 250));
d292 2
a293 4
	COleDateTime timelog(COleDateTime::GetCurrentTime());
	CString curtime;
	curtime.Format(_T(" (%s)"), timelog.Format());
	ci->m_pLog->AppendText(curtime + _T(": "), RGB(50, 200, 250));
d339 6
a344 5
		ci->m_pLog->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), RGB(1, 180, 20));
		COleDateTime timelog(COleDateTime::GetCurrentTime());
		CString curtime;
		curtime.Format(_T(" (%s)"), timelog.Format());
		ci->m_pLog->AppendText(curtime + _T(": "), RGB(1, 180, 20));
d380 6
a385 5
		ci->m_pLog->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), RGB(1, 180, 20));
		COleDateTime timelog(COleDateTime::GetCurrentTime());
		CString curtime;
		curtime.Format(_T(" (%s)"), timelog.Format());
		ci->m_pLog->AppendText(curtime + _T(": "), RGB(1, 180, 20));
d694 2
a695 1
		ci->m_pLog->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), RGB(1, 180, 20));
d697 2
a698 4
		COleDateTime		timelog(COleDateTime::GetCurrentTime());
		CString			strCurTime;
		strCurTime.Format(_T(" (%s)"), timelog.Format());
		ci->m_pLog->AppendText(strCurTime + _T(": "), RGB(1, 180, 20));
@


1.64
log
@Minor chat entry fix...
@
text
@d194 1
a194 1
	if (show)
d219 1
a219 2
		GetItem(i, &cur_item);
		if (((CChatItem*)cur_item.lParam)->m_pClient == client)
d222 1
a222 1
	return -1;
d231 1
a231 2
		GetItem(i, &cur_item);
		if (((CChatItem*)cur_item.lParam)->m_pClient == client)
d398 2
a399 2
		GetItem(i, &cur_item);
		delete (CChatItem*)cur_item.lParam;
d411 3
a413 1
		GetItem(i, &cur_item);
d441 2
a442 1
	if (GetCurSel() == ( -1))
d444 1
d447 3
a449 3
	GetItem(GetCurSel(), &cur_item);
	CChatItem* ci = (CChatItem*)cur_item.lParam;
	return ci;
d462 3
d514 1
a514 1
	sint16 usedtab;
d516 1
a516 1
		usedtab = GetTabByClient(client);
d518 2
a519 2
		usedtab = GetCurSel();
	if (usedtab == ( -1))
d521 1
d524 2
a525 1
	GetItem(usedtab, &item);
d529 1
a529 1
	DeleteItem(usedtab);
d533 15
a600 4
/*
	const uint16 uLength = m_pMessageBox->GetWindowTextLength() + 2;
	TCHAR* messagetosend = new TCHAR[uLength + 1];
	m_pMessageBox->GetWindowText(messagetosend, uLength);
a601 5
	if (SendMessage(messagetosend))
		m_pMessageBox->SetWindowText(_T(""));
	
	delete[] messagetosend;
*/
d605 1
a605 1

@


1.63
log
@minor improvements
@
text
@d382 5
a386 1
		ci->m_pLog->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick() + _T(": "), RGB(1, 180, 20));
@


1.62
log
@some measurements to increase stability + name change
@
text
@d625 1
a625 1
			GetParent()->GetDlgItem(IDC_CSEND)->SetWindowText(GetResString(IDS_CW_SEND));
d629 1
a629 1
			GetParent()->GetDlgItem(IDC_CCLOSE)->SetWindowText(GetResString(IDS_CW_CLOSE));
@


1.61
log
@Solved potential crash when username or message contain '%'.
@
text
@d37 5
a41 4
	log = 0;
	messagepending.Empty();
	notify = false;
	history_pos = 0;
d72 1
a72 1

d74 1
d146 5
d152 3
a154 3
CChatItem* CChatSelector::StartSession(CUpDownClient* client, bool show)
{
	if (GetTabByClient(client) != 0xFFFF)
d158 4
a161 4
			SetCurSel(GetTabByClient(client));
			chatout.SetHyperText(GetItemByClient(client)->log);
			chatout.SetTitle(client->GetUserName());
			if ((chatout.m_bAutoScroll) /*&& (GetItemState(GetTabByClient(client), TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED)*/)
d164 1
a164 1
		return 0;
d167 3
a169 3
	CChatItem* chatitem = new CChatItem();
	chatitem->client = client;
	chatitem->log = new CPreparedRTFText();
d172 3
a174 3
	CString sessions = GetResString(IDS_CHAT_START) + CString(client->GetUserName()) + _T(" (IP: ") + CString(client->GetFullIP()) + _T(") - ") + timelog.Format() + _T("\n");
	chatitem->log->AppendText(sessions, RGB(255, 0, 0));
	client->SetChatState(MS_CHATTING);
d177 1
a177 1
	if (!client->GetUserName().IsEmpty())
d179 1
a179 1
		name = client->GetUserName();
d189 1
a189 1
	newitem.lParam = (LPARAM)chatitem;
d197 2
a198 2
		chatout.SetHyperText(chatitem->log);
		chatout.SetTitle(client->GetUserName());
d206 5
a210 1
	return chatitem;
d212 1
a212 1

d220 1
a220 1
		if (((CChatItem*)cur_item.lParam)->client == client)
d225 1
a225 1

d233 1
a233 1
		if (((CChatItem*)cur_item.lParam)->client == client)
d236 1
a236 1
	return 0;
d238 1
a238 1

d291 1
a291 1
	ci->log->AppendText(sender->GetUserName(), RGB(50, 200, 250));
d296 2
a297 2
	ci->log->AppendText(curtime + _T(": "), RGB(50, 200, 250));
	ci->log->AppendText(CString(message) + _T('\n'));
d301 1
a301 1
		if ((::GetTickCount() - ci->client->GetAwayMessageResendCount()) > 3000)
d304 1
a304 1
			ci->client->SetAwayMessageResendCount(::GetTickCount());
d310 1
a310 1
		chatout.SetHyperText(ci->log);
d313 1
a313 1
		ci->notify = true;
d324 1
a324 1

d328 1
a328 1
	if (ci == NULL)
d331 4
a334 4
	if (ci->history.GetCount() == g_eMuleApp.m_pGlobPrefs->GetMaxChatHistoryLines())
		ci->history.RemoveAt(0);
	ci->history.Add(CString(message));
	ci->history_pos = ci->history.GetCount();
d336 1
a336 1
	if (ci->client->GetChatState() == MS_CONNECTING)
d339 1
a339 1
	if (ci->client->m_pRequestSocket && ci->client->m_pRequestSocket->IsConnected())
d342 1
a342 1
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), RGB(1, 180, 20));
d346 2
a347 2
		ci->log->AppendText(curtime + _T(": "), RGB(1, 180, 20));
		ci->log->AppendText(message + _T('\n'));
d351 4
a354 4
		ci->log->AppendText(_T("*** ") + GetResString(IDS_CONNECTING), RGB(255, 0, 0));
		ci->messagepending = message;
		ci->client->SetChatState(MS_CONNECTING);
		ci->client->TryToConnect();
d357 1
a357 1
	if (chatout.GetHyperText() == ci->log)
d361 1
a361 1

d365 1
a365 1
	if (!ci)
d367 1
a367 1
	ci->client->SetChatState(MS_CHATTING);
d370 1
a370 1
		if (!ci->messagepending.IsEmpty())
d372 2
a373 2
			ci->log->AppendText(_T(' ') + GetResString(IDS_FAILED) + _T('\n'), RGB(255, 0, 0));
			ci->messagepending.Empty();	//SyruS i wish compiler would warn on this: delete[] ci->messagepending;
d376 1
a376 1
			ci->log->AppendText(GetResString(IDS_CHATDISCONNECTED) + _T('\n'), RGB(255, 0, 0));
d380 5
a384 5
		ci->log->AppendText(_T(" ok\n"), RGB(255, 0, 0));
		SendMessagePacket(*ci, ci->messagepending);
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick() + _T(": "), RGB(1, 180, 20));
		ci->log->AppendText(ci->messagepending + _T('\n'));
		ci->messagepending.Empty();
d386 1
a386 1
	if (chatout.GetHyperText() == ci->log)
d389 1
a389 1

d400 1
a400 1

d411 1
a411 1
		if (((CChatItem*)cur_item.lParam)->notify)
d434 1
a434 1

d445 1
a445 1

d456 3
a458 3
	chatout.SetHyperText(ci->log);
	chatout.SetTitle(ci->client->GetUserName());
	ci->notify = false;
d464 1
a464 1

d470 1
a470 1

d484 1
a484 1

d502 1
a502 1

d516 1
a516 1
	ci->client->SetChatState(MS_NONE);
d519 1
a519 1
	if (chatout.GetHyperText() == ci->log)
d523 1
a523 1

d553 1
a553 1

d571 1
a571 1

d574 6
a579 3
	uint16 len = m_pMessageBox->GetWindowTextLength() + 2;
	TCHAR* messagetosend = new TCHAR[len + 1];
	m_pMessageBox->GetWindowText(messagetosend, len);
d582 1
d584 11
d596 1
a596 1

d617 1
a617 1

d632 1
a632 1

d648 1
a648 1

d658 1
a658 1
	if (!ci)
d660 2
a661 1
	if (ci->client->GetChatState() == MS_CONNECTING)
d663 1
d665 1
a665 1
	if (ci->client->m_pRequestSocket && ci->client->m_pRequestSocket->IsConnected())
d673 2
a674 1
		ci->client->m_pRequestSocket->SendPacket(pPacket, true, true);
d676 1
a676 1
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), RGB(1, 180, 20));
d679 4
a682 4
		CString				curtime;
		curtime.Format(_T(" (%s)"), timelog.Format());
		ci->log->AppendText(curtime + _T(": "), RGB(1, 180, 20));
		ci->log->AppendText(CString(strAwayMessage) + _T('\n'));
d685 1
a685 1
	if (chatout.GetHyperText() == ci->log)
d699 1
a699 1
	ci.client->m_pRequestSocket->SendPacket(pPacket, true, true);
@


1.60
log
@Improved string processing
@
text
@d306 1
a306 1
			MessageText.Format(GetResString(IDS_TBN_NEWCHATMSG) + CString(" ") + CString(sender->GetUserName()) + CString(":'") + CString(message) + CString("'\n"));
@


1.59
log
@Improved string processing
@
text
@d114 1
a114 1
	chatout.AppendText( CString(" Version ") + CString(CURRENT_VERSION_LONG) + CString(" - ") + GetResString(IDS_CHAT_WELCOME) );
d485 1
a485 1
		chatout.AppendText( CString(" Version ") + CString(CURRENT_VERSION_LONG) + CString(" - ") + GetResString(IDS_CHAT_WELCOME) );
@


1.58
log
@Formatting, comments, and name changes.
@
text
@d286 1
a286 1
	ci->log->AppendText(CString(message) + _T("\n"));
d336 1
a336 1
		ci->log->AppendText(message + _T("\n"));
d361 1
a361 1
			ci->log->AppendText(_T(" ") + GetResString(IDS_FAILED) + _T("\n"), RGB(255, 0, 0));
d365 1
a365 1
			ci->log->AppendText(GetResString(IDS_CHATDISCONNECTED) + _T("\n"), RGB(255, 0, 0));
d372 1
a372 1
		ci->log->AppendText(ci->messagepending + _T("\n"));
d653 1
a653 1
		ci->log->AppendText(CString(strAwayMessage) + _T("\n"));
@


1.57
log
@Formatting, name changes and deleting spaces and tabs at end of lines
@
text
@d643 1
a643 1
		memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);							// <messagelen 2>
@


1.56
log
@Formatting, comments, and name changes.
@
text
@d643 1
a643 1
		memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);								// <messagelen 2>
@


1.55
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d643 1
a643 1
		memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);						// <messagelen 2>
d650 1
a650 1
		CString			curtime;
@


1.54
log
@Formatting, comments, and name changes.
@
text
@d643 1
a643 1
		memcpy2(pPacket->m_pcBuffer, &uMessageLen, 2);								// <messagelen 2>
d650 1
a650 1
		CString				curtime;
a669 1

@


1.53
log
@Minor updates (domain change)
@
text
@d629 1
a629 1

d639 8
a646 6
		CString awm = CString("[AUTO REPLY:AWAY] ") + CString(g_eMuleApp.m_pGlobPrefs->GetAwayStateMessage());
		uint16 mlen = (uint16)_tcslen(LPCTSTR(awm));
		Packet* packet = new Packet(OP_MESSAGE, mlen + 2);
		memcpy2(packet->m_pcBuffer, &mlen, 2);
		memcpy2(packet->m_pcBuffer + 2, awm, mlen);
		ci->client->m_pRequestSocket->SendPacket(packet, true, true);
d648 3
a650 2
		COleDateTime timelog(COleDateTime::GetCurrentTime());
		CString curtime;
d653 1
a653 1
		ci->log->AppendText(CString(awm) + _T("\n"));
d660 5
d666 3
a668 7
void CChatSelector::SendMessagePacket(CChatItem& ci, const CString& msg)
{
	uint16 mlen = msg.GetLength();
	Packet* packet = new Packet(OP_MESSAGE, mlen + 2);
	memcpy2(packet->m_pcBuffer, &mlen, 2);
	memcpy2(packet->m_pcBuffer + 2, msg.GetString(), mlen);
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);
d671 1
a671 1
	ci.client->m_pRequestSocket->SendPacket(packet, true, true);
d674 1
@


1.52
log
@Close of chat by button now sets focus on the last tab (for multiple closing)
@
text
@d618 1
a618 1
			ShellExecute(NULL, NULL, _T("http://emuleplus.sourceforge.net"), NULL, NULL, SW_SHOWDEFAULT);
@


1.51
log
@reverted last commit for prepared rtf
@
text
@d546 13
@


1.50
log
@minor change
@
text
@d154 1
a154 1
			if ((chatout.m_bAutoScroll) && (GetItemState(GetTabByClient(client), TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED))
d192 1
a192 1
		if ((chatout.m_bAutoScroll) && (GetItemState(itemnr, TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED))
d449 1
a449 1
	if ((chatout.m_bAutoScroll) && (GetItemState(GetCurSel(), TCIS_HIGHLIGHTED) & TCIS_HIGHLIGHTED))
@


1.49
log
@invisible window scrolling fix
@
text
@d154 1
a154 1
			if (chatout.m_bAutoScroll)
d192 1
a192 1
		if (chatout.m_bAutoScroll)
d449 2
a451 2
	if (chatout.m_bAutoScroll)
		chatout.ScrollToLastLine();
@


1.48
log
@minor fixes & cleanup
@
text
@d154 2
d192 2
d450 2
@


1.47
log
@fixes/changes
@
text
@d281 2
a282 2
	ci->log->AppendText(curtime, RGB(50, 200, 250));
	ci->log->AppendText(CString(": ") + CString(message) + CString("\n"));
d331 1
a331 2
		ci->log->AppendText(curtime, RGB(1, 180, 20));
		ci->log->AppendText(CString(": "));
d343 1
a343 1
		chatout.UpdateSize(true);
d367 2
a368 3
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), RGB(1, 180, 20));
		ci->log->AppendText(CString(": "));
		ci->log->AppendText(ci->messagepending + CString("\n"));
d372 1
a372 1
		chatout.UpdateSize(true);
d630 2
a631 3
		ci->log->AppendText(curtime, RGB(1, 180, 20));
		ci->log->AppendText(CString(": "));
		ci->log->AppendText(CString(awm) + CString("\n"));
d635 1
a635 1
		chatout.UpdateSize(true);
@


1.46
log
@minor fix
@
text
@d117 1
d153 1
d189 1
d444 1
d482 1
@


1.45
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d111 1
a111 1
	chatout.Create(WS_VISIBLE | WS_CHILD | WS_HSCROLL | WS_VSCROLL | ES_MULTILINE | ES_READONLY, rChatOut, this, 124);
@


1.44
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d230 1
a230 1
		AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Anti-leechermods: Client %s (%s) has been banned because of spamming"), sender->GetUserName(), GetClientNameAndVersionString(sender));
d240 1
a240 1
			AddDebugLogLine(false, RGB_BLUE_GRAY + _T("Filtered message %s from user %s (%s)"), message, sender->GetUserName(), GetClientNameAndVersionString(sender));
@


1.43
log
@Added some colors to the logs...
@
text
@d230 1
a230 1
		AddDebugLogLine(false, _T("<COLOR=102,102,153>Anti-leechermods: Client %s (%s) has been banned because of spamming"), sender->GetUserName(), GetClientNameAndVersionString(sender));
d240 1
a240 1
			AddDebugLogLine(false,_T("<COLOR=102,102,153>Filtered message %s from user %s (%s)"), message, sender->GetUserName(), GetClientNameAndVersionString(sender));
@


1.42
log
@removed prepared RTF predefined colors (uses RGB(#, #, #) now) + some fixes
@
text
@d230 1
a230 1
		AddDebugLogLine(false, _T("Anti-leechermods: Client %s (%s) has been banned because of spamming"), sender->GetUserName(), GetClientNameAndVersionString(sender));
d240 1
a240 1
			AddDebugLogLine(false,_T("Filtered message %s from user %s (%s)"), message, sender->GetUserName(), GetClientNameAndVersionString(sender));
@


1.41
log
@more fixes/changes
@
text
@d113 1
a113 1
	chatout.AppendHyperLink(_T(""),_T(""),_T("eMule Plus"),_T(""),false);
d151 1
a151 1
			chatout.SetHyperText(GetItemByClient(client)->log, true);
d162 1
a162 1
	chatitem->log->AppendText(sessions, 17);
d186 1
a186 1
		chatout.SetHyperText(chatitem->log, true);
d273 1
a273 1
	ci->log->AppendText(sender->GetUserName(), 30);
d278 1
a278 1
	ci->log->AppendText(curtime, 30);
d292 1
a292 1
		chatout.SetHyperText(ci->log, true);
d324 1
a324 1
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 28);
d328 1
a328 1
		ci->log->AppendText(curtime, 28);
d334 1
a334 1
		ci->log->AppendText(_T("*** ") + GetResString(IDS_CONNECTING), 17);
d355 1
a355 1
			ci->log->AppendText(_T(" ") + GetResString(IDS_FAILED) + _T("\n"), 17);
d359 1
a359 1
			ci->log->AppendText(GetResString(IDS_CHATDISCONNECTED) + _T("\n"), 17);
d363 1
a363 1
		ci->log->AppendText(_T(" ok\n"), 17);
d365 1
a365 1
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 28);
d440 1
a440 1
	chatout.SetHyperText(ci->log, true);
d476 1
a476 1
		chatout.AppendHyperLink(_T(""),_T(""),_T("eMule Plus"),_T(""),false);
d623 1
a623 1
		ci->log->AppendText(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 28);
d627 1
a627 1
		ci->log->AppendText(curtime, 12);
@


1.40
log
@some more fixing + added more predefined colors to prepared rtf
@
text
@d162 1
a162 1
	chatitem->log->AppendKeyWord(sessions, 17);
d273 1
a273 1
	ci->log->AppendKeyWord(sender->GetUserName(), 30);
d278 1
a278 1
	ci->log->AppendKeyWord(curtime, 30);
d324 1
a324 1
		ci->log->AppendKeyWord(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 28);
d328 1
a328 1
		ci->log->AppendKeyWord(curtime, 28);
d334 1
a334 1
		ci->log->AppendKeyWord(_T("*** ") + GetResString(IDS_CONNECTING), 17);
d355 1
a355 1
			ci->log->AppendKeyWord(_T(" ") + GetResString(IDS_FAILED) + _T("\n"), 17);
d359 1
a359 1
			ci->log->AppendKeyWord(GetResString(IDS_CHATDISCONNECTED) + _T("\n"), 17);
d363 1
a363 1
		ci->log->AppendKeyWord(_T(" ok\n"), 17);
d365 1
a365 1
		ci->log->AppendKeyWord(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 28);
d623 1
a623 1
		ci->log->AppendKeyWord(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 28);
d627 1
a627 1
		ci->log->AppendKeyWord(curtime, 12);
@


1.39
log
@Got rid of LogEditCtrl + Some minor changes
@
text
@d162 1
a162 1
	chatitem->log->AppendKeyWord(sessions, 10);
d273 1
a273 1
	ci->log->AppendKeyWord(sender->GetUserName(), 15);
d278 1
a278 1
	ci->log->AppendKeyWord(curtime, 15);
d324 1
a324 1
		ci->log->AppendKeyWord(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 11);
d328 1
a328 1
		ci->log->AppendKeyWord(curtime, 11);
d334 1
a334 1
		ci->log->AppendKeyWord(_T("*** ") + GetResString(IDS_CONNECTING), 10);
d355 1
a355 1
			ci->log->AppendKeyWord(_T(" ") + GetResString(IDS_FAILED) + _T("\n"), 10);
d359 1
a359 1
			ci->log->AppendKeyWord(GetResString(IDS_CHATDISCONNECTED) + _T("\n"), 10);
d363 1
a363 1
		ci->log->AppendKeyWord(_T(" ok\n"), 10);
d365 1
a365 1
		ci->log->AppendKeyWord(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 11);
d623 1
a623 1
		ci->log->AppendKeyWord(g_eMuleApp.m_pGlobPrefs->GetUserNick(), 11);
d627 1
a627 1
		ci->log->AppendKeyWord(curtime, 3);
@


1.38
log
@Converted IRC/Messages to Rich Edit  (added copy text to clipboard & save logs with colors as RTF)
@
text
@d151 1
a151 1
			chatout.SetHyperText(GetItemByClient(client)->log);
d186 1
a186 1
		chatout.SetHyperText(chatitem->log);
a187 1
	//chatout.SendMessage(EM_AUTOURLDETECT, TRUE, 0);
a279 1
	chatout.UpdateSize(true);
d292 1
a292 1
		chatout.SetHyperText(ci->log);
a330 1
		chatout.UpdateSize(true);
d440 1
a440 1
	chatout.SetHyperText(ci->log);
a629 1
		chatout.UpdateSize(true);
@


1.37
log
@inactive IRC/Messages window receiving new text becomes hilighted until you select it
@
text
@d57 2
a58 1
{}
d67 1
a71 1

d107 1
a107 1
	rChatOut.right -= 18; // 7
d111 6
a116 4
	chatout.CreateEx(NULL /*WS_EX_STATICEDGE*/, 0, _T("ChatWnd"), WS_VISIBLE | WS_CHILD | WS_BORDER | HTC_WORDWRAP | HTC_AUTO_SCROLL_BARS | HTC_UNDERLINE_HOVER, rChatOut, this, 0);
	chatout.AppendHyperLink(CString("eMule Plus"), 0, CString("http://emuleplus.sourceforge.net"), 0, 0);
	chatout.AppendText( CString(" Version ") + CString(CURRENT_VERSION_LONG) + CString(" - ") +
	                    GetResString(IDS_CHAT_WELCOME) );
d123 1
a123 1
	LoadImgLstIcon(NULL, 0, 0); // delete temp-icon
d158 1
a158 1
	chatitem->log = new CPreparedHyperText();
d160 1
a160 1
	COleDateTime timelog(COleDateTime::GetCurrentTime()); // DonGato date-time localization
d162 1
a162 1
	chatitem->log->AppendKeyWord(sessions, RGB(255, 0, 0));
d188 1
a190 1
	{
a191 1
	}
d224 1
a224 2

//filter me?
a228 1
//katsyonak 16.06.03
a254 1
	//START enkeyDEV(kei-kun) -Messaging preferences-
a267 1
	//END enkeyDEV(kei-kun) -Messaging preferences-
d271 1
a271 1
			return;  //<<-- enkeyDEV(kei-kun) -Messaging preferences-
d274 1
a274 2
	ci->log->AppendKeyWord(CString(sender->GetUserName()), RGB(50, 200, 250));
//	START - enkeyDEV(Ottavio84) -View time in messages-
d276 1
a276 1
	COleDateTime timelog(COleDateTime::GetCurrentTime()); // DonGato date-time localization
d279 3
a281 4
	ci->log->AppendKeyWord(curtime, RGB(50, 200, 250));
//	END - enkeyDEV(Ottavio84) -View time in messages-
	ci->log->AppendText(CString(": "));
	ci->log->AppendText(CString(message) + CString("\n"));
a282 1
//START enkeyDEV(kei-kun) -Messaging preferences-
d284 1
a284 1
	{ //<<-- enkeyDEV(kei-kun) -Messaging preferences-
a290 1
//END enkeyDEV(kei-kun) -Messaging preferences-
d296 1
a296 1
	{ //<<-- enkeyDEV(kei-kun) -Messaging preferences-
d298 1
a298 2
	//START - enkeyDEV(kei-kun) -TaskbarNotifier-
		if (isNewChatWindow || g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg())  //<<-31/10/2002 (kei-kun)
a299 1
		//	Purity - Sending message when chat message received
a305 1
	//END - enkeyDEV(kei-kun) -TaskbarNotifier-
a320 1
	{
a321 1
	}
d326 2
a327 3
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()), RGB(1, 180, 20));
	//	START - enkeyDEV(Ottavio84) -View time in messages-
		COleDateTime timelog(COleDateTime::GetCurrentTime()); // DonGato date-time localization
d330 1
a330 2
		ci->log->AppendKeyWord(curtime, RGB(1, 180, 20));
	//	END - enkeyDEV(Ottavio84) -View time in messages-
d332 1
a332 1
		ci->log->AppendText(message + CString("\n"));
d337 1
a337 1
		ci->log->AppendKeyWord(CString("*** ") + GetResString(IDS_CONNECTING), RGB(255, 0, 0));
d358 1
a358 1
			ci->log->AppendKeyWord(CString(" ") + GetResString(IDS_FAILED) + CString("\n"), RGB(255, 0, 0));
d362 1
a362 1
			ci->log->AppendKeyWord(GetResString(IDS_CHATDISCONNECTED) + CString("\n"), RGB(255, 0, 0));
d366 1
a366 1
		ci->log->AppendKeyWord(CString(" ok\n"), RGB(255, 0, 0));
d368 1
a368 1
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()), RGB(1, 180, 20));
d478 3
a489 1
	{
a490 1
	}
a491 1
	{
a492 1
	}
d588 16
a610 1
//START enkeyDEV(kei-kun) -Messaging preferences-
a615 1
	{
a616 1
	}
d626 2
a627 3
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()), RGB(1, 180, 20));
	//	START - enkeyDEV(Ottavio84) -View time in messages-
		COleDateTime timelog(COleDateTime::GetCurrentTime()); // DonGato date-time localization
d630 1
a630 2
		ci->log->AppendKeyWord(curtime, RGB(1, 180, 20));
	//	END - enkeyDEV(Ottavio84) -View time in messages-
d634 1
a634 1
	} //send AwayMessage only if connected
a639 1
//END enkeyDEV(kei-kun) -Messaging preferences-
@


1.36
log
@log filtered messages
@
text
@d297 2
a298 1

d459 1
@


1.35
log
@Formatting, comments, and name changes.
@
text
@d241 1
@


1.34
log
@Trying to fix the SetFocus issue.
@
text
@d115 5
a119 5
	imagelist.Create(16, 16, ILC_COLOR32, 0, 10);
	imagelist.SetBkColor(RGB(255, 0, 255));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CHAT), 16, 16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MESSAGE), 16, 16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MPENDING), 16, 16));
d121 1
a121 1
	CImageList ImageList;
d127 3
a129 3
	imagelist.Draw(&TempDC, 0, CPoint(0, 0), ILD_NORMAL);
	imagelist.Draw(&TempDC, 1, CPoint(16, 0), ILD_NORMAL);
	imagelist.Draw(&TempDC, 2, CPoint(32, 0), ILD_NORMAL);
d131 4
a134 4
	ImageList.Create(16, 16, ILC_COLOR32 | ILC_MASK, 0, 10);
	ImageList.Add(&Bitmap, RGB(255, 0, 255));
	SetImageList(&ImageList);
	ImageList.Detach();
@


1.33
log
@no message
@
text
@d186 4
a189 1
	m_pMessageBox->SetFocus();
@


1.32
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d18 1
a18 1
// ChatSelector.cpp : implementation file
d30 1
a30 1
static char THIS_FILE[]=__FILE__;
d35 2
a36 1
CChatItem::CChatItem(){
d40 1
a40 1
	history_pos=0;
d43 1
a43 1
// CChatSelector
d51 1
a51 1
	lastemptyicon=false;
d56 2
a57 2
CChatSelector::~CChatSelector(){
}
d71 1
a71 1
// CChatSelector message handlers
d77 1
a77 1
	
d82 2
a83 2
	m_pCloseBtn->SetWindowPos(NULL, rect.right-7-rClose.Width(), rect.bottom-7-rClose.Height(),
								rClose.Width(), rClose.Height(), SWP_NOZORDER);
d88 3
a90 3
	m_pSendBtn->SetWindowPos(NULL, rect.right-7-rClose.Width()-7-rSend.Width(), rect.bottom-7-rSend.Height(),
								rSend.Width(), rSend.Height(), SWP_NOZORDER);
	
d95 3
a97 3
	m_pMessageBox->SetWindowPos(NULL, rect.left+7, rect.bottom-9-rMessage.Height(), 
									rect.right-7-rClose.Width()-7-rSend.Width()-21, 
										rMessage.Height(), SWP_NOZORDER);
d100 1
a100 1
	if(iTop < rMessage.Height())
d102 1
a102 1
	
d110 11
a120 11
	chatout.CreateEx(NULL/*WS_EX_STATICEDGE*/,0,_T("ChatWnd"),WS_VISIBLE | WS_CHILD | WS_BORDER | HTC_WORDWRAP |HTC_AUTO_SCROLL_BARS | HTC_UNDERLINE_HOVER,rChatOut,this,0);
	chatout.AppendHyperLink(CString("eMule Plus"),0,CString("http://emuleplus.sourceforge.net"),0,0);
	chatout.AppendText(CString(" Version ")+ CString(CURRENT_VERSION_LONG)+ CString(" - ")+
		GetResString(IDS_CHAT_WELCOME));

	imagelist.Create(16,16,ILC_COLOR32,0,10);
	imagelist.SetBkColor(RGB(255,0,255));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_CHAT),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MESSAGE),16,16));
	imagelist.Add(LoadImgLstIcon(MAKEINTRESOURCE(IDI_MPENDING),16,16));
	LoadImgLstIcon(NULL,0,0); // delete temp-icon
d127 3
a129 3
	imagelist.Draw(&TempDC, 0, CPoint( 0,0), ILD_NORMAL);
	imagelist.Draw(&TempDC, 1, CPoint(16,0), ILD_NORMAL);
	imagelist.Draw(&TempDC, 2, CPoint(32,0), ILD_NORMAL);
d132 1
a132 1
	ImageList.Add(&Bitmap, RGB(255,0,255));
d138 1
a138 1
	VERIFY( (m_Timer = SetTimer(20,1500,0)) );
d141 6
a146 3
CChatItem* CChatSelector::StartSession(CUpDownClient* client, bool show){
	if (GetTabByClient(client) != 0xFFFF){
		if (show){
d158 2
a159 2
	CString sessions = GetResString(IDS_CHAT_START)+CString(client->GetUserName()) + _T(" (IP: ") + CString(client->GetFullIP()) + _T(") - ") + timelog.Format()+ _T("\n");
	chatitem->log->AppendKeyWord(sessions,RGB(255,0,0));
d165 1
a165 1
		name=client->GetUserName();
d167 1
a167 1
		if(name.GetLength() > 30)
d171 1
a171 1
		name.Format(_T("(%s)"),GetResString(IDS_UNKNOWN));
d174 1
a174 1
	newitem.mask = TCIF_PARAM|TCIF_TEXT|TCIF_IMAGE;
d177 1
a177 1
	newitem.cchTextMax = name.GetLength()+1;
d179 3
a181 2
	uint16 itemnr = InsertItem(GetItemCount(),&newitem);
	if (show){
d191 4
a194 2
uint16 CChatSelector::GetTabByClient(CUpDownClient* client){
	for (int i = 0; i < GetItemCount();i++){
d197 1
a197 1
		GetItem(i,&cur_item);
d204 4
a207 2
CChatItem* CChatSelector::GetItemByClient(CUpDownClient* client){
	for (int i = 0; i < GetItemCount();i++){
d210 1
a210 1
		GetItem(i,&cur_item);
d212 1
a212 1
			return (CChatItem*)cur_item.lParam;
d217 5
a221 4
void CChatSelector::ProcessMessage(CUpDownClient* sender, LPCTSTR message){
	
	//filter me?
	CString Cmessage=CString(message).MakeLower();
d223 1
a223 1
	int curPos=0;
d225 4
a228 3
	//katsyonak 16.06.03
	if ((Cmessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/"))>-1) || (Cmessage.Find(_T("http://fullspeed.to/mison"))>-1) && (g_eMuleApp.m_pGlobPrefs->GetMlDonkeyCM())) {
		AddDebugLogLine(false,_T("Anti-leechermods: Client %s (%s) has been banned because of spamming"),sender->GetUserName(),GetClientNameAndVersionString(sender));
d233 1
a233 1
	resToken= g_eMuleApp.m_pGlobPrefs->GetMessageFilter().Tokenize(_T("|"),curPos);
d236 5
a240 2
		if (Cmessage.Find(resToken.MakeLower())>-1) {return;}
		resToken= g_eMuleApp.m_pGlobPrefs->GetMessageFilter().Tokenize(_T("|"),curPos);
d242 2
a243 2
	
	// continue
d246 8
a253 2
	if (!ci) {
		if (GetItemCount()>=g_eMuleApp.m_pGlobPrefs->GetMsgSessionsMax()) return;
d255 7
a261 9
		//START enkeyDEV(kei-kun) -Messaging preferences-
		if (g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom()==4) //no messages 
			return;	

		if (g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom()==2) //only friends
			if (!(sender->IsFriend())) return;		
			
		if ((g_eMuleApp.m_pGlobPrefs->GetAcceptMessagesFrom()==3) && (!(sender->IsFriend()))) { //only friends
			AddLogLine(false,GetResString(IDS_IM_MSGFROMCHAT)+_T(" %s: %s"),sender->GetUserName(),message);
d265 1
a265 1
		//END enkeyDEV(kei-kun) -Messaging preferences-
d267 4
a270 3
		ci = StartSession(sender,false);
		if (!ci) return;  //<<-- enkeyDEV(kei-kun) -Messaging preferences-
		isNewChatWindow = true; 
d272 2
a273 2
	ci->log->AppendKeyWord(CString(sender->GetUserName()),RGB(50,200,250));
	// START - enkeyDEV(Ottavio84) -View time in messages-
d278 2
a279 2
	ci->log->AppendKeyWord(curtime, RGB(50,200,250));
	// END - enkeyDEV(Ottavio84) -View time in messages-
d281 1
a281 1
	ci->log->AppendText(CString(message)+ CString("\n"));
d283 5
a287 3
	//START enkeyDEV(kei-kun) -Messaging preferences-
	if(g_eMuleApp.m_pGlobPrefs->GetAwayState()==true) {//<<-- enkeyDEV(kei-kun) -Messaging preferences-
		if ((::GetTickCount() - ci->client->GetAwayMessageResendCount()) > 3000) { //send again only if 3 secs from last away message
d292 1
a292 1
	//END enkeyDEV(kei-kun) -Messaging preferences-
d296 2
a297 1
	else if (g_eMuleApp.m_pGlobPrefs->GetAwayState()==false) { //<<-- enkeyDEV(kei-kun) -Messaging preferences-
d299 2
a300 2
		//START - enkeyDEV(kei-kun) -TaskbarNotifier- 	
        if (isNewChatWindow || g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg())  //<<-31/10/2002 (kei-kun)
d302 5
a306 5
   				// Purity - Sending message when chat message received
				CString MessageText;
				MessageText.Format(GetResString(IDS_TBN_NEWCHATMSG)+CString(" ")+CString(sender->GetUserName()) + CString(":'") + CString(message)+ CString("'\n"));
				g_eMuleApp.m_pSMTPConnection->SendMail(MessageText, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg(), g_eMuleApp.m_pGlobPrefs->IsSMTPInfoEnabled());
                g_eMuleApp.m_pdlgEmule->ShowNotifier(MessageText, TBN_CHAT, false, g_eMuleApp.m_pGlobPrefs->GetNotifierPopsEveryChatMsg());
d309 1
a309 1
		//END - enkeyDEV(kei-kun) -TaskbarNotifier-
d313 5
a317 3
bool CChatSelector::SendMessage(const CString& message){
	CChatItem* ci = GetCurrentChatItem();
	if (ci==NULL) return false;
d319 2
a320 1
	if (ci->history.GetCount()==g_eMuleApp.m_pGlobPrefs->GetMaxChatHistoryLines()) ci->history.RemoveAt(0);
d322 1
a322 1
	ci->history_pos=ci->history.GetCount();
d324 2
a325 1
	if (ci->client->GetChatState() == MS_CONNECTING){
d329 5
a333 4
	if (ci->client->socket && ci->client->socket->IsConnected()){
		SendMessagePacket(*ci, message);		
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()),RGB(1,180,20));
		// START - enkeyDEV(Ottavio84) -View time in messages-
d337 2
a338 2
		ci->log->AppendKeyWord(curtime, RGB(1,180,20));		
		// END - enkeyDEV(Ottavio84) -View time in messages-
d343 3
a345 2
	else{
		ci->log->AppendKeyWord(CString("*** ")+GetResString(IDS_CONNECTING),RGB(255,0,0));
d356 3
a358 2
void CChatSelector::ConnectingResult(CUpDownClient* sender,bool success){
	CChatItem* ci = GetItemByClient(sender);
d362 5
a366 3
	if (!success){
		if (!ci->messagepending.IsEmpty()){
			ci->log->AppendKeyWord(CString(" ")+GetResString(IDS_FAILED) +CString("\n"),RGB(255,0,0));			
d370 1
a370 1
			ci->log->AppendKeyWord(GetResString(IDS_CHATDISCONNECTED) +CString("\n"),RGB(255,0,0));		
d372 5
a376 4
	else{
		ci->log->AppendKeyWord(CString(" ok\n"),RGB(255,0,0));
		SendMessagePacket(*ci, ci->messagepending);		
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()),RGB(1,180,20));
d378 1
a378 1
		ci->log->AppendText(ci->messagepending+CString("\n"));
d385 4
a388 2
void CChatSelector::DeleteAllItems(){
	for (int i = 0; i < GetItemCount();i++){
d391 1
a391 1
		GetItem(i,&cur_item);
d396 2
a397 1
void CChatSelector::OnTimer(UINT_PTR nIDEvent){
d400 2
a401 1
	for (int i = 0; i < GetItemCount();i++){
d404 1
a404 1
		GetItem(i,&cur_item);
d406 4
a409 3
		if (((CChatItem*)cur_item.lParam)->notify){
			cur_item.iImage = (blinkstate)? 1:2;
			SetItem(i,&cur_item);
d412 2
a413 1
		else if (cur_item.iImage != 0){
d415 1
a415 1
			SetItem(i,&cur_item);
d418 9
a426 3
	if (globalnotify) {
		g_eMuleApp.m_pdlgEmule->ShowMessageState(((blinkstate)? 1:2));
		lastemptyicon=false;
a427 1
	else if (!lastemptyicon) {g_eMuleApp.m_pdlgEmule->ShowMessageState(0); lastemptyicon=true;}
d430 3
a432 2
CChatItem* CChatSelector::GetCurrentChatItem() {
	if (GetCurSel() == (-1))
d436 1
a436 1
	GetItem(GetCurSel(),&cur_item);
d441 3
a443 2
void CChatSelector::ShowChat(){
	if (GetCurSel() == (-1))
d456 2
a457 1
void CChatSelector::OnTcnSelchangeChatsel(NMHDR *pNMHDR, LRESULT *pResult){
d462 4
a465 2
INT	CChatSelector::InsertItem(int nItem,TCITEM* pTabCtrlItem){
	if (!GetItemCount()){
d468 1
a468 1
		wp.rcNormalPosition.top +=20;
d471 1
a471 1
	int result = CClosableTabCtrl::InsertItem(nItem,pTabCtrlItem);
d476 2
a477 1
BOOL CChatSelector::DeleteItem(int nItem){
d479 2
a480 1
	if (!GetItemCount()){
d483 1
a483 1
		wp.rcNormalPosition.top -=20;
d490 2
a491 1
void CChatSelector::EndSession(CUpDownClient* client){
d493 2
a494 1
	if (client){
d497 2
a498 1
	else{
d501 1
a501 1
	if (usedtab == (-1))
d505 1
a505 1
	GetItem(usedtab,&item);
d508 1
a508 1
	
d517 1
a517 1
	CClosableTabCtrl::OnSize(nType, cx, cy);	
d522 1
a522 1
		
d525 2
a526 2
	m_pCloseBtn->SetWindowPos(NULL, rect.right-7-rClose.Width(), rect.bottom-7-rClose.Height(),
								rClose.Width(), rClose.Height(), SWP_NOZORDER);
d529 3
a531 3
	m_pSendBtn->SetWindowPos(NULL, rect.right-7-rClose.Width()-7-rSend.Width(), rect.bottom-7-rSend.Height(),
								rSend.Width(), rSend.Height(), SWP_NOZORDER);
	
d534 3
a536 3
	m_pMessageBox->SetWindowPos(NULL, rect.left+7, rect.bottom-9-rMessage.Height(), 
									rect.right-7-rClose.Width()-7-rSend.Width()-21, 
										rMessage.Height(), SWP_NOZORDER);
d539 1
a539 1
	if(iTop < rMessage.Height())
d541 2
a542 2
	
	chatout.SetWindowPos(NULL, rect.left+7, rect.top+7, rect.right-18, rect.Height()-7-iTop-14, SWP_NOZORDER);
d545 2
a546 1
void CChatSelector::OnBnClickedCclose(){
d552 4
a555 4
	uint16 len = m_pMessageBox->GetWindowTextLength()+2;
	TCHAR* messagetosend = new TCHAR[len+1];
	m_pMessageBox->GetWindowText(messagetosend,len);
	if(SendMessage(messagetosend))
d562 5
a566 3
	if(pMsg->message == WM_KEYDOWN) {
		
		if (pMsg->wParam == VK_RETURN){
d571 3
a573 2
		if ((pMsg->hwnd == GetDlgItem(IDC_CMESSAGE)->m_hWnd) && 
		   (pMsg->wParam == VK_UP || pMsg->wParam == VK_DOWN)) {
d583 1
a583 1
	if(m_hWnd)
d585 1
a585 1
		if(m_pSendBtn)
d589 1
a589 1
		if(m_pCloseBtn)
d604 6
a609 3
bool CChatSelector::SendAwayMessage(CChatItem* ci) {
	if (!ci) return false;
	if (ci->client->GetChatState() == MS_CONNECTING){
d613 3
a615 2
	if (ci->client->socket && ci->client->socket->IsConnected()){ 
		CString awm = CString("[AUTO REPLY:AWAY] ")+CString(g_eMuleApp.m_pGlobPrefs->GetAwayStateMessage());
d617 6
a622 6
		Packet* packet = new Packet(OP_MESSAGE,mlen+2);
		memcpy2(packet->m_pcBuffer,&mlen,2);
		memcpy2(packet->m_pcBuffer+2,awm,mlen);
		ci->client->socket->SendPacket(packet,true,true);
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()),RGB(1,180,20));
		// START - enkeyDEV(Ottavio84) -View time in messages-
d626 2
a627 2
		ci->log->AppendKeyWord(curtime, RGB(1,180,20));		
		// END - enkeyDEV(Ottavio84) -View time in messages-
d629 1
a629 1
		ci->log->AppendText(CString(awm)+CString("\n"));
d635 1
a635 1
	return true;	
d644 2
a645 2
	memcpy2(packet->m_pcBuffer+2, msg.GetString(), mlen);
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->m_dwSize);	
d647 2
a648 1
	ci.client->socket->SendPacket(packet, true, true);
d650 1
a650 1
}		
@


1.31
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@a25 1
#include "memcpy_amd.h"
@


1.30
log
@Reduce username in Chat if it's more than 30 chars
@
text
@d558 2
a559 2
		memcpy2(packet->pBuffer,&mlen,2);
		memcpy2(packet->pBuffer+2,awm,mlen);
d583 3
a585 3
	memcpy2(packet->pBuffer, &mlen, 2);
	memcpy2(packet->pBuffer+2, msg.GetString(), mlen);
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);	
@


1.29
log
@Minor fix to set focus in text input on chat send.
@
text
@d161 1
d163 4
@


1.28
log
@Updated Chat & IRC code. Workaround for bug #0000322
@
text
@d176 3
d404 1
@


1.27
log
@Fixed user name on Chat tabs, localized times and fixed removal of .settings file
@
text
@d37 1
a37 1
	log = 0;	
d40 1
d45 1
a45 1
IMPLEMENT_DYNAMIC(CChatSelector, CTabCtrl)
d52 2
a56 1
	//KillTimer();
d60 1
a60 1
BEGIN_MESSAGE_MAP(CChatSelector, CTabCtrl)
d66 1
d138 1
a138 1
	m_Timer = SetTimer(20,1500,0);
a153 1
	//CTime theTime = CTime::GetCurrentTime();
d155 1
a155 1
	CString sessions = GetResString(IDS_CHAT_START)+CString(client->GetUserName()) + _T(" (IP: ") + CString(client->GetFullIP()) + _T(") - ") + timelog.Format()/*theTime.Format(_T("%c"))*/+ _T("\n");
a249 1
	//CTime theTime = CTime::GetCurrentTime();
d284 7
a290 32
//START enkeyDEV(kei-kun) -Messaging preferences-
bool CChatSelector::SendAwayMessage(CChatItem* ci) {
	if (!ci) return false;
	if (ci->client->GetChatState() == MS_CONNECTING){
		return false; //send AwayMessage only if connected
	}
#ifdef OLD_SOCKETS_ENABLED
	if (ci->client->socket && ci->client->socket->IsConnected()){ 
		CString awm = CString("[AUTO REPLY:AWAY] ")+CString(g_eMuleApp.m_pGlobPrefs->GetAwayStateMessage());
		uint16 mlen = (uint16)_tcslen(LPCTSTR(awm));
		Packet* packet = new Packet(OP_MESSAGE,mlen+2);
		memcpy2(packet->pBuffer,&mlen,2);
		memcpy2(packet->pBuffer+2,awm,mlen);
		ci->client->socket->SendPacket(packet,true,true);
		ci->log->AppendKeyWord(CString(g_eMuleApp.m_pGlobPrefs->GetUserNick()),RGB(1,180,20));
		// START - enkeyDEV(Ottavio84) -View time in messages-
		COleDateTime timelog(COleDateTime::GetCurrentTime()); // DonGato date-time localization
		//CTime theTime = CTime::GetCurrentTime();
		CString curtime;
		curtime.Format(_T(" (%s)"), timelog.Format());
		ci->log->AppendKeyWord(curtime, RGB(1,180,20));		
		// END - enkeyDEV(Ottavio84) -View time in messages-
		ci->log->AppendText(CString(": "));
		ci->log->AppendText(CString(awm)+CString("\n"));
		chatout.UpdateSize(true);
	} //send AwayMessage only if connected
#endif //OLD_SOCKETS_ENABLED
	if (chatout.GetHyperText() == ci->log)
		chatout.UpdateSize(true);
	return true;	
}
//END enkeyDEV(kei-kun) -Messaging preferences-
a291 9
bool CChatSelector::SendMessage(const CString& message){
	sint16 to = GetCurSel();
	if (to == (-1)){
		return false;
	}
	TCITEM item;
	item.mask = TCIF_PARAM;
	GetItem(to,&item);
	CChatItem* ci = (CChatItem*)item.lParam;
a300 1
		//CTime theTime = CTime::GetCurrentTime();
a320 12
void CChatSelector::SendMessagePacket(CChatItem& ci, const CString& msg)
{
	uint16 mlen = msg.GetLength();
	Packet* packet = new Packet(OP_MESSAGE, mlen + 2);
	memcpy2(packet->pBuffer, &mlen, 2);
	memcpy2(packet->pBuffer+2, msg.GetString(), mlen);
	g_eMuleApp.m_pUploadQueue->AddUpDataOverheadOther(packet->size);	
#ifdef OLD_SOCKETS_ENABLED
	ci.client->socket->SendPacket(packet, true, true);
#endif //OLD_SOCKETS_ENABLED
}		

d380 10
d393 1
d396 3
a398 2
	GetItem(GetCurSel(),&cur_item);
	CChatItem* ci = (CChatItem*)cur_item.lParam;
d415 1
a415 1
	int result = CTabCtrl::InsertItem(nItem,pTabCtrlItem);
d421 1
a421 1
	CTabCtrl::DeleteItem(nItem);
d456 1
a456 1
	CTabCtrl::OnSize(nType, cx, cy);	
d500 12
a511 4
	if((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == 13))
	{
		if (pMsg->hwnd == m_pMessageBox->m_hWnd)
			OnBnClickedCsend();
d513 1
a513 2

	return CTabCtrl::PreTranslateMessage(pMsg);
d530 51
@


1.26
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d151 3
a153 2
	CTime theTime = CTime::GetCurrentTime();
	CString sessions = GetResString(IDS_CHAT_START)+CString(client->GetUserName()) + _T(" (IP: ") + CString(client->GetFullIP()) + _T(") - ") + theTime.Format(_T("%c"))+ _T("\n");
d158 1
a158 1
	if (client->GetUserName().IsEmpty())
d246 3
a248 1
	CTime theTime = CTime::GetCurrentTime();
d250 1
a250 1
	curtime.Format(_T(" (%s)"), theTime.Format(_T("%X")));
d299 2
a300 1
		CTime theTime = CTime::GetCurrentTime();
d302 1
a302 1
		curtime.Format(_T(" (%s)"), theTime.Format("%X"));
d333 2
a334 1
		CTime theTime = CTime::GetCurrentTime();
d336 1
a336 1
		curtime.Format(_T(" (%s)"), theTime.Format(_T("%X")));
@


1.25
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d291 2
a292 7
		#ifndef AMD
		memcpy(packet->pBuffer,&mlen,2);
		memcpy(packet->pBuffer+2,awm,mlen);
		#else
		memcpy_amd(packet->pBuffer,&mlen,2);
		memcpy_amd(packet->pBuffer+2,awm,mlen);
		#endif
d354 2
a355 7
	#ifndef AMD
	memcpy(packet->pBuffer, &mlen, 2);
	memcpy(packet->pBuffer+2, msg.GetString(), mlen);
	#else
	memcpy_amd(packet->pBuffer, &mlen, 2);
	memcpy_amd(packet->pBuffer+2, msg.GetString(), mlen);
	#endif
@


1.24
log
@fixed security issues
@
text
@d206 1
a206 1
	if ((Cmessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/"))>-1) || (Cmessage.Find(_T("http://fullspeed.to/mison"))>-1) && (theApp.glob_prefs->GetMlDonkeyCM())) {
d212 1
a212 1
	resToken= theApp.glob_prefs->GetMessageFilter().Tokenize(_T("|"),curPos);
d216 1
a216 1
		resToken= theApp.glob_prefs->GetMessageFilter().Tokenize(_T("|"),curPos);
d223 1
a223 1
		if (GetItemCount()>=theApp.glob_prefs->GetMsgSessionsMax()) return;
d226 1
a226 1
		if (theApp.glob_prefs->GetAcceptMessagesFrom()==4) //no messages 
d229 1
a229 1
		if (theApp.glob_prefs->GetAcceptMessagesFrom()==2) //only friends
d232 1
a232 1
		if ((theApp.glob_prefs->GetAcceptMessagesFrom()==3) && (!(sender->IsFriend()))) { //only friends
d254 1
a254 1
	if(theApp.glob_prefs->GetAwayState()==true) {//<<-- enkeyDEV(kei-kun) -Messaging preferences-
d264 1
a264 1
	else if (theApp.glob_prefs->GetAwayState()==false) { //<<-- enkeyDEV(kei-kun) -Messaging preferences-
d267 1
a267 1
        if (isNewChatWindow || theApp.glob_prefs->GetNotifierPopsEveryChatMsg())  //<<-31/10/2002 (kei-kun)
d272 2
a273 2
				theApp.smtpconnection->SendMail(MessageText, theApp.glob_prefs->GetNotifierPopsEveryChatMsg(), theApp.glob_prefs->IsSMTPInfoEnabled());
                theApp.emuledlg->ShowNotifier(MessageText, TBN_CHAT, false, theApp.glob_prefs->GetNotifierPopsEveryChatMsg());
d288 1
a288 1
		CString awm = CString("[AUTO REPLY:AWAY] ")+CString(theApp.glob_prefs->GetAwayStateMessage());
d299 1
a299 1
		ci->log->AppendKeyWord(CString(theApp.glob_prefs->GetUserNick()),RGB(1,180,20));
d332 1
a332 1
		ci->log->AppendKeyWord(CString(theApp.glob_prefs->GetUserNick()),RGB(1,180,20));
d366 1
a366 1
	theApp.uploadqueue->AddUpDataOverheadOther(packet->size);	
d388 1
a388 1
		ci->log->AppendKeyWord(CString(theApp.glob_prefs->GetUserNick()),RGB(1,180,20));
d425 1
a425 1
		theApp.emuledlg->ShowMessageState(((blinkstate)? 1:2));
d428 1
a428 1
	else if (!lastemptyicon) {theApp.emuledlg->ShowMessageState(0); lastemptyicon=true;}
@


1.23
log
@eMailNotifier and PopUp CleanUp
@
text
@d198 1
a198 1
void CChatSelector::ProcessMessage(CUpDownClient* sender, char* message){
d233 1
a233 1
			AddLogLine(false,GetResString(IDS_IM_MSGFROMCHAT)+CString(" ")+CString(sender->GetUserName()) + CString(":'") + CString(message));
@


1.22
log
@Purity's changes
@
text
@d270 4
a273 8
				if(theApp.glob_prefs->IsSMTPInfoEnabled())
				{
					CSMTPConnection mail;
					CString txt;
					txt.Format(GetResString(IDS_TBN_NEWCHATMSG)+CString(" ")+CString(sender->GetUserName()) + CString(":'") + CString(message)+ CString("'\n"));
					mail.SendMuleMessage(txt);
				}
                theApp.emuledlg->ShowNotifier(GetResString(IDS_TBN_NEWCHATMSG)+CString(" ")+CString(sender->GetUserName()) + CString(":'") + CString(message)+ CString("'\n"), TBN_CHAT);
@


1.21
log
@minor changes
@
text
@d27 1
d268 9
d278 1
a278 1

@


1.20
log
@fixed exceptions after "delete [] messagepending" (CString)
@
text
@d205 1
a205 1
	if ((Cmessage.Find(_T("emule sans upload @@ http://www.chez.com/theworld/"))>-1) && (theApp.glob_prefs->GetMlDonkeyCM())) {
@


1.19
log
@unicode cleanup
@
text
@d37 1
d374 1
a374 1
			delete[] ci->messagepending;
d385 1
a385 1
		delete[] ci->messagepending;
@


1.18
log
@Updated Banning messages.
@
text
@d105 1
a105 1
	chatout.CreateEx(NULL/*WS_EX_STATICEDGE*/,0,"ChatWnd",WS_VISIBLE | WS_CHILD | WS_BORDER | HTC_WORDWRAP |HTC_AUTO_SCROLL_BARS | HTC_UNDERLINE_HOVER,rChatOut,this,0);
d150 1
a150 1
	CString sessions = GetResString(IDS_CHAT_START)+CString(client->GetUserName()) + " (IP: " + CString(client->GetFullIP()) + ") - " + theTime.Format("%c")+ "\n";
d158 1
a158 1
		name.Format("(%s)",GetResString(IDS_UNKNOWN));
d204 3
a206 3
	if ((Cmessage.Find("emule sans upload @@ http://www.chez.com/theworld/")>-1) && (theApp.glob_prefs->GetMlDonkeyCM())) {
		AddDebugLogLine(false,"Anti-leechermods: Client %s (%s) has been banned because of spamming",sender->GetUserName(),GetClientNameAndVersionString(sender));
		sender->Ban("AUTOMATED MESSAGE: Your client is being banned for spamming and leeching!", GetResString(IDS_BAN_LEECHERSPAM));
d210 1
a210 1
	resToken= theApp.glob_prefs->GetMessageFilter().Tokenize("|",curPos);
d214 1
a214 1
		resToken= theApp.glob_prefs->GetMessageFilter().Tokenize("|",curPos);
d245 1
a245 1
	curtime.Format(" (%s)", theTime.Format("%X"));
d282 1
a282 1
		uint16 mlen = (uint16)strlen(LPCTSTR(awm));
d296 1
a296 1
		curtime.Format(" (%s)", theTime.Format("%X"));
d329 1
a329 1
		curtime.Format(" (%s)", theTime.Format("%X"));
d523 1
a523 1
	char* messagetosend = new char[len+1];
d526 1
a526 1
		m_pMessageBox->SetWindowText("");
@


1.17
log
@xrmb countermeasures now use the option in preferences and some minor changes.
@
text
@d206 1
a206 1
		sender->Ban("AUTOMATED MESSAGE: Your client is being banned for spamming and leeching!");
@


1.16
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d203 7
@


1.15
log
@Preparing for new sockets
@
text
@d26 1
d277 1
d280 4
d345 1
d348 4
@


1.14
log
@coverted code from char * to CString
@
text
@d271 1
d290 1
a290 1

d309 1
d329 1
d342 1
d344 1
@


1.13
log
@minor fixes and improvements
@
text
@d154 4
a157 1
	if (client->GetUserName()!=NULL) name=client->GetUserName(); else name.Format("(%s)",GetResString(IDS_UNKNOWN));
@


1.12
log
@code cleanup
@
text
@d153 3
d159 2
a160 2
	newitem.pszText = client->GetUserName();
	newitem.cchTextMax = (int)strlen(client->GetUserName())+1;
d171 1
a171 1
	for (int i = 0; i != GetItemCount();i++){
d182 1
a182 1
	for (int i = 0; i != GetItemCount();i++){
d347 1
d357 2
a358 1
		ci->log->AppendText(ci->messagepending + CString("\n"));				
d365 1
a365 1
	for (int i = 0; i != GetItemCount();i++){
d376 1
a376 1
	for (int i = 0; i != GetItemCount();i++){
@


1.11
log
@Fixed bug #166
@
text
@d35 1
a35 2
	log = 0;
	messagepending = 0;
d290 1
a290 1
bool CChatSelector::SendMessage(char* message){
d303 1
a303 6
		uint16 mlen = (uint16)strlen(message);
		Packet* packet = new Packet(OP_MESSAGE,mlen+2);
		memcpy(packet->pBuffer,&mlen,2);
		memcpy(packet->pBuffer+2,message,mlen);
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
		ci->client->socket->SendPacket(packet,true,true);
d312 1
a312 1
		ci->log->AppendText(CString(message)+CString("\n"));
d317 1
a317 1
		ci->messagepending = nstrdup(message);
d326 10
d342 2
a343 3
		if (ci->messagepending){
			ci->log->AppendKeyWord(CString(" ")+GetResString(IDS_FAILED) +CString("\n"),RGB(255,0,0));
			delete[] ci->messagepending;
d346 1
a346 2
			ci->log->AppendKeyWord(GetResString(IDS_CHATDISCONNECTED) +CString("\n"),RGB(255,0,0));
		ci->messagepending = 0;
d350 1
a350 6
		uint16 mlen = (uint16)strlen(ci->messagepending);
		Packet* packet = new Packet(OP_MESSAGE,mlen+2);
		memcpy(packet->pBuffer,&mlen,2);
		memcpy(packet->pBuffer+2,ci->messagepending,mlen);
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size);
		ci->client->socket->SendPacket(packet,true,true);
d353 1
a353 3
		ci->log->AppendText(CString(ci->messagepending)+CString("\n"));
		delete[] ci->messagepending;
		ci->messagepending = 0;
@


1.10
log
@converted to new logging method
@
text
@d208 2
@


1.10.4.1
log
@27c
@
text
@a153 3
	CString name;
	if (client->GetUserName()!=NULL) name=client->GetUserName(); else name.Format("(%s)",GetResString(IDS_UNKNOWN));

d157 2
a158 2
	newitem.pszText = name.GetBuffer();
	newitem.cchTextMax = name.GetLength()+1;
a207 2
		if (GetItemCount()>=theApp.glob_prefs->GetMsgSessionsMax()) return;

@


1.9
log
@all my stable changes and some minor fixes (refer to changelog)
@
text
@d216 1
a216 1
			theApp.emuledlg->AddLogLine(false,GetResString(IDS_IM_MSGFROMCHAT)+CString(" ")+CString(sender->GetUserName()) + CString(":'") + CString(message));
@


1.8
log
@Code clean up and double check wit official code.
@
text
@d191 1
a191 1
	/* MERGE 26d
d203 1
a203 1
    */
d208 14
d223 1
d227 6
d235 10
d247 1
a247 1
	else { 
d258 31
d309 6
@


1.7
log
@upgrade to 26d, fixes, extended reask, more upload parts seen, more crash fixes
@
text
@d203 1
a203 1
        */
a327 2


a337 1

@


1.6
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d48 1
d191 14
d217 1
d321 1
a321 1
	if (globalnotify)
d323 3
a325 2
	else
		theApp.emuledlg->ShowMessageState(0);
@


1.5
log
@more 26b merges
@
text
@d27 7
@


1.4
log
@Merge from plus26based branch (without new sockets code yet)
@
text
@d221 1
a221 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
d259 1
a259 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
@


1.3
log
@updated to .25b codebase
@
text
@d221 1
d259 1
@


1.3.4.1
log
@initial upgrade to .26
@
text
@a220 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
a257 1
		theApp.uploadqueue->AddUpDataOverheadOther(packet->size, 0);
@


1.3.2.1
log
@updating this branch...
@
text
@@


1.2
log
@*** empty log message ***
@
text
@d86 1
a86 1
	int iTop = rSend.Height() > rClose.Height() ? rSend.Height() : rClose.Height();
d245 1
a245 1
		ci->log->AppendKeyWord(CString(" ")+GetResString(IDS_FAILED) +CString("\n"),RGB(255,0,0));
@


1.1
log
@*** empty log message ***
@
text
@d98 1
a98 1
	chatout.AppendHyperLink(CString("eMule Plus"),0,CString("http://www.emule-project.net"),0,0);
@

