head	1.50;
access;
symbols
	PublicRelease_1_2e:1.49
	Interim_Release_1-2e_RC1:1.49
	PublicRelease_1_2d:1.47
	Interim_Release_1-2d_RC1:1.47
	Interim_Release_1-2d_beta1:1.47
	PublicRelease_1_2c:1.44
	Interim_Release_1-2c_RC1:1.44
	Interim_Release_1-2c_beta1:1.42
	PublicRelease_1_2b:1.42
	Interim_Release_1-2b_RC1:1.42
	PublicRelease_1_2a:1.42
	Interim_Release_1-2a_RC1:1.42
	Interim_Release_1-2a_beta2:1.39
	Interim_Release_1-2a_beta1:1.39
	PublicRelease_1_2:1.38
	Interim_Release_1-2_RC1:1.38
	Interim_Release_1-2_beta1:1.28
	PublicRelease_1_1g:1.26
	Interim_Release_1-1g_RC3:1.26
	Interim_Release_1-1g_RC2:1.26
	Interim_Release_1-1g_RC1:1.26
	Interim_Release_1-1g_beta2:1.24
	Interim_Release_1-1g_beta1:1.24
	PublicRelease_1_1f:1.24
	Interim_Release_1-1f_RC1:1.24
	PublicRelease_1_1e:1.22
	Interim_Release_1-1e_RC2:1.22
	Interim_Release_1-1e_RC1:1.22
	Interim_Release_1-1e_beta1:1.22
	PublicRelease_1_1d:1.22
	Interim_Release_1-1d_RC1:1.22
	PublicRelease_1_1c:1.22
	Interim_Release_1-1c_RC1:1.22
	Interim_Release_1-1c_beta2:1.22
	Interim_Release_1-1c_beta1:1.22
	PublicRelease_1_1b:1.20
	Interim_Release_1-1b_RC1:1.20
	PublicRelease_1_1a:1.19
	Interim_Release_1-1a_RC2:1.19
	Interim_Release_1-1a_RC1:1.19
	Interim_Release_1-1a_beta2:1.19
	Interim_Release_1-1a_beta1:1.19
	PublicRelease_1_1:1.18
	Interim_Release_1-1_beta1:1.18
	PublicRelease_1o:1.18
	Interim_Release_1o_RC1:1.18
	Interim_Release_1o_beta1:1.18
	PublicRelease_1n:1.18
	Interim_Release_1n_RC2:1.18
	Interim_Release_1n_RC1:1.18
	Interim_Release_1n_beta2:1.18
	Interim_Release_1n_beta1:1.18
	PublicRelease_1m:1.17
	Interim_Release_1m_beta1:1.17
	PublicRelease_1l:1.17
	Interim_Release_1l_RC3:1.17
	Interim_Release_1l_RC2:1.17
	Interim_Release_1l_RC1:1.17
	Interim_Release_1l_beta2:1.17
	Interim_Release_1l_beta1:1.17
	PublicRelease_1k:1.16
	Interim_Release_1k_RC4:1.16
	Interim_1k_RC3:1.16
	Interim_1k_RC2:1.16
	Interim_Release_1k_RC1:1.16
	Interim_Release_1k_beta5:1.16
	Intrerim_Release_1k_beta4:1.16
	Interim_Release_1k_beta1:1.15
	PublicRelease_1j:1.15
	Interim_Release_1J_RC3:1.15
	Interim_Release_1j_RC3:1.15
	Interim_Release_1j_RC2:1.15
	Interim_Release_1j_RC1:1.15
	Interim_Release_1j_beta2:1.15
	Interim_Release_1j_beta1:1.15
	PublicRelease_1i:1.15
	Interim_Release_1i_RC6:1.15
	Interim_Release_1i_RC3:1.15
	Interim_Release_1i_RC2:1.15
	Interim_Release_1i_RC1:1.15
	Interim_Release_1i_beta3:1.15
	Interim_Release_1i_beta2:1.14
	Interim_Release_1i_beta1:1.13
	PublicRelease_1h:1.11
	Interim_Release_1h_rc2:1.11
	Interim_Release_1h_RC1:1.11
	Interim_Release_1h_beta2:1.11
	Interim_Release_1h_beta1_now:1.11
	Interim_Release_1h_beta1:1.11
	PublicRelease_1g:1.11
	Interim_Release_1g_RC6_Final:1.11
	Interim_Release_1g_RC6:1.10
	Interim_Release_1g_RC5:1.10
	Interim_Release_1g_RC4:1.10
	Interim_Release_1g_RC3:1.10
	Interim_Release_1g_beta2:1.6
	Interim_Release_1g_beta1:1.6
	Interim_Release_1f_RC4:1.6
	Interim_Release_1f_RC3:1.6
	Interim_Release_1f_RC2:1.6
	Interim_Release_1f_RC:1.6
	Interim_Release_1f_beta2:1.6
	Interim_Release_1f_beta1:1.6
	PublicRelease_1e:1.6
	Interim_Release_1e_RC2:1.6
	Interim_Release_1e_RC:1.6
	Interim_Release_1e_beta3:1.6
	Interim_Release_1e_beta2:1.6
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.4
	PublicRelease_1c:1.4
	featurestest:1.4.0.4
	Interim_Release_1c_RC:1.4
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.3
	Interim_Release_1b_beta2:1.3
	Interim_Release_1b_beta1:1.3
	proxydeadlake:1.2.0.4
	PublicRelease_1a:1.2
	Interim_Release_1a_beta2:1.2
	BerkeleyDb:1.2.0.2
	Interim_Release_1a_beta1:1.2
	PublicRelease_1:1.2
	goldfish:1.2
	eMulePlus_1_RC2:1.2
	eMulePlus_26b_1RC1:1.2
	PreRelease_26b_i0e:1.2
	before_26d_merge:1.2
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.50
date	2010.05.13.04.48.49;	author aw3;	state Exp;
branches;
next	1.49;

1.49
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.48;

1.48
date	2008.07.17.05.01.23;	author aw3;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.31.22.50.31;	author eklmn;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.27.21.03.13;	author aw3;	state Exp;
branches;
next	1.45;

1.45
date	2007.10.24.19.07.25;	author fuxie-dk;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.27.06.21.21;	author aw3;	state Exp;
branches;
next	1.43;

1.43
date	2007.03.19.19.39.03;	author kush_eplus;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.01.03.58.24;	author aw3;	state Exp;
branches;
next	1.41;

1.41
date	2006.07.27.01.58.52;	author aw3;	state Exp;
branches;
next	1.40;

1.40
date	2006.07.25.04.25.53;	author aw3;	state Exp;
branches;
next	1.39;

1.39
date	2006.04.26.11.57.28;	author aw3;	state Exp;
branches;
next	1.38;

1.38
date	2006.02.18.21.17.24;	author kush_eplus;	state Exp;
branches;
next	1.37;

1.37
date	2006.02.06.15.53.18;	author morphisthebrave;	state Exp;
branches;
next	1.36;

1.36
date	2006.02.05.17.53.34;	author aw3;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.05.10.20.43;	author morphisthebrave;	state Exp;
branches;
next	1.34;

1.34
date	2006.02.05.05.06.33;	author aw3;	state Exp;
branches;
next	1.33;

1.33
date	2006.02.04.23.08.48;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2006.02.04.08.49.05;	author morphisthebrave;	state Exp;
branches;
next	1.31;

1.31
date	2006.02.02.05.35.06;	author aw3;	state Exp;
branches;
next	1.30;

1.30
date	2006.02.01.21.09.29;	author morphisthebrave;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.30.08.49.48;	author morphisthebrave;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.21.20.28.51;	author aw3;	state Exp;
branches;
next	1.27;

1.27
date	2005.12.28.19.16.56;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2005.11.27.22.11.52;	author eklmn;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.24;

1.24
date	2005.07.27.22.23.23;	author syrus77;	state Exp;
branches;
next	1.23;

1.23
date	2005.07.14.01.08.18;	author syrus77;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.23.13.51.17;	author aw3;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.19.17.14.14;	author netwolf1;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.15.19.41.30;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.28.04.35.05;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.06.16.01.06;	author aw3;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.05.06.09.21;	author katsyonak;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.20.01.41.15;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.26.11.29.14;	author katsyonak;	state Exp;
branches;
next	1.14;

1.14
date	2003.10.23.17.36.43;	author kuchin;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.30.22.45.25;	author syrus77;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.20.15.39.32;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.07.24.17.14.41;	author eklmn;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.24.23.16.52;	author syrus77;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.22.22.51.29;	author netwolf1;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.15.09.10.05;	author partyckip;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.09.21.59.35;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.04.22.12.41.52;	author kuchin;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.19.07.17.00;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.14.16.24.23;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.03.22.09.52;	author moosetea;	state Exp;
branches;
next	1.2;

1.2
date	2003.02.16.22.01.51;	author lord_kiron;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.38;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Added an option to bind to specific network interface (from original) {Zom}.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#pragma comment(lib, "ws2_32.lib") 
#include "zlib/zlib.h"
#include "emule.h"
#include "WebSocket.h"
#include "WebServer.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

static HANDLE s_hTerminate = NULL;
static CWinThread* s_pSocketThread = NULL;

typedef struct
{
	void	*pThis;
	SOCKET	hSocket;
} SocketData;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//	Gmt2HttpStr() formats HTTP time string accordoing to RFC 1123.
//		Note: output example "Sun, 06 Nov 1994 08:49:37 GMT".
//		Format:
//			rfc1123-date = wkday "," SP date1 SP time SP "GMT"
//			date1        = 2DIGIT SP month SP 4DIGIT
//			               ; day month year (e.g. 02 Jun 1982)
//			time         = 2DIGIT ":" 2DIGIT ":" 2DIGIT
//			               ; 00:00:00 - 23:59:59
//			wkday        = "Mon" | "Tue" | "Wed" | "Thu" | "Fri" | "Sat" | "Sun"
//			month        = "Jan" | "Feb" | "Mar" | "Apr" | "May" | "Jun" | "Jul"
//			             | "Aug" | "Sep" | "Oct" | "Nov" | "Dec"
//		Params:
//			pcOut - buffer receiving formatted string (size of EP_MAX_HTTPGMTSTR).
//			pTm   - time to format
void Gmt2HttpStr(char *pcOut, const struct tm *pTm)
{
	static const char acWkday[7][4] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
	static const char acMonth[12][4] = {
		"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

	wsprintfA( pcOut, "%s, %02u %s %04u %02u:%02u:%02u GMT",
		acWkday[pTm->tm_wday], pTm->tm_mday, acMonth[pTm->tm_mon], pTm->tm_year + 1900,
		pTm->tm_hour, pTm->tm_min, pTm->tm_sec );
}

void CWebSocket::SetParent(CWebServer *pParent)
{
	m_pParent = pParent;
}

void CWebSocket::OnRequestReceived(char *pHeader, DWORD dwHeaderLen, char *pData, DWORD dwDataLen)
{
	EMULE_TRY

	CStringA	sHeader(pHeader, dwHeaderLen);
	CStringA	sURL;
	int			iIdx;
	bool		bFileReq = false;

	if (sHeader.Left(3) == "GET")
	{
		sURL = sHeader.TrimRight();
	}
	else if (sHeader.Left(4) == "POST")
	{
		CStringA		sData(pData, dwDataLen);

		sURL = '?';
		sURL += sData.Trim();	// '?' to imitate GET syntax for ParseURL
	}
	iIdx = sURL.Find(' ');
	if (iIdx >= 0)
		sURL = sURL.Mid(iIdx + 1);
	iIdx = sURL.Find(' ');
	if (iIdx >= 0)
		sURL = sURL.Left(iIdx);

	if (sURL.GetLength() > 4)
	{
		CStringA	strExt4 = sURL.Right(4).MakeLower();

		if (( (strExt4 == ".gif") || (strExt4 == ".jpg") || (strExt4 == ".png") ||
			(strExt4 == ".ico") || (strExt4 == ".css") || (sURL.Right(3).MakeLower() == ".js") ||
			(strExt4 == ".bmp") || (sURL.Right(5).MakeLower() == ".jpeg") || (strExt4 == ".xml") || (strExt4 == ".txt") )
			&& sURL.Find("..") < 0 )	// don't allow leaving the emule-webserver-folder for accessing files
		{
			bFileReq = true;
		}
	}

// HTTP header AcceptEncoding
	CStringA	strAcceptEncoding;
	iIdx = sHeader.Find("Accept-Encoding: ");
	if (iIdx >= 0)
	{
		int	iIdx2 = sHeader.Find("\r\n", iIdx += 17);

		strAcceptEncoding = sHeader.Mid(iIdx, iIdx2 - iIdx);
	}
// End AcceptEncoding

// HTTP header IfModifiedSince
	CStringA	strIfModifiedSince;
	iIdx = sHeader.Find("If-Modified-Since: ");
	if (iIdx >= 0)
	{
		int	iIdx2 = sHeader.Find("\r\n", iIdx += 19);

		strIfModifiedSince = sHeader.Mid(iIdx, iIdx2 - iIdx);
	}
// End IfModifiedSince

	ThreadData Data;

	Data.sURL = sURL;
	Data.pThis = m_pParent;
	Data.pSocket = this;
	Data.strAcceptEncoding = strAcceptEncoding;
	Data.strIfModifiedSince = strIfModifiedSince;

	if (!bFileReq)
		m_pParent->ProcessGeneralReq(Data);
	else
		m_pParent->ProcessFileReq(Data);

	Disconnect();

	EMULE_CATCH2
}

void CWebSocket::OnReceived(void* pData, DWORD dwSize)
{
	EMULE_TRY

	const UINT SIZE_PRESERVE = 0x1000;

	if (m_dwBufSize < dwSize + m_dwRecv)
	{
	//	Reallocate
		char	*pNewBuf = new char[m_dwBufSize = dwSize + m_dwRecv + SIZE_PRESERVE];

		if (pNewBuf == NULL)
		{
			m_bValid = false; //	Internal problem
			return;
		}

		if (m_pBuf != NULL)
		{
			memcpy2(pNewBuf, m_pBuf, m_dwRecv);
			delete[] m_pBuf;
		}

		m_pBuf = pNewBuf;
	}
	memcpy2(m_pBuf + m_dwRecv, pData, dwSize);
	m_dwRecv += dwSize;

//	Check if we have all that we want
	if (m_dwHttpHeaderLen == 0)
	{
	//	Try to find it
		bool	bPrevEndl = false;

		for (DWORD dwPos = 0; dwPos < m_dwRecv; dwPos++)
		{
			if ('\n' == m_pBuf[dwPos])
			{
				if (bPrevEndl)
				{
				//	We just found the end of the http header
				//	Now write the message's position into two first DWORDs of the buffer
					m_dwHttpHeaderLen = dwPos + 1;

				//	Try to find now the 'Content-Length' header
					for (dwPos = 0; dwPos < m_dwHttpHeaderLen;)
					{
						char	*pPtr = reinterpret_cast<char*>(memchr(m_pBuf + dwPos, '\n', m_dwHttpHeaderLen - dwPos));

						if (pPtr == NULL)
							break;

						DWORD	dwNextPos = pPtr - m_pBuf;

					//	Check this header
						static const char	acMatch[] = "content-length";

						if (strnicmp(m_pBuf + dwPos, acMatch, sizeof(acMatch) - 1) == 0)
						{
							dwPos += sizeof(acMatch) - 1;
							pPtr = reinterpret_cast<char *>(memchr(m_pBuf + dwPos, ':', m_dwHttpHeaderLen - dwPos));
							if (pPtr != NULL)
								m_dwHttpContentLen = atol(pPtr + 1);

							break;
						}
						dwPos = dwNextPos + 1;
					}
					break;
				}
				else
					bPrevEndl = true;
			}
			else if ('\r' != m_pBuf[dwPos])
				bPrevEndl = false;
		}
	}

	if ((m_dwHttpHeaderLen != 0) && !m_bCanRecv && (m_dwHttpContentLen == 0))
		m_dwHttpContentLen = m_dwRecv - m_dwHttpHeaderLen; // of course

	if ((m_dwHttpHeaderLen != 0) && (m_dwHttpContentLen < m_dwRecv) && ((m_dwHttpContentLen == 0) || (m_dwHttpHeaderLen + m_dwHttpContentLen <= m_dwRecv)))
	{
		OnRequestReceived(m_pBuf, m_dwHttpHeaderLen, m_pBuf + m_dwHttpHeaderLen, m_dwHttpContentLen);

		if (m_bCanRecv && (m_dwRecv > m_dwHttpHeaderLen + m_dwHttpContentLen))
		{
		//	Move our data
			m_dwRecv -= m_dwHttpHeaderLen + m_dwHttpContentLen;
			MoveMemory(m_pBuf, m_pBuf + m_dwHttpHeaderLen + m_dwHttpContentLen, m_dwRecv);
		}
		else
			m_dwRecv = 0;

		m_dwHttpHeaderLen = 0;
		m_dwHttpContentLen = 0;
	}
	EMULE_CATCH2
}

void CWebSocket::SendData(const void* pData, DWORD dwDataSize)
{
	EMULE_TRY

	ASSERT(pData);
	if (m_bValid && m_bCanSend)
	{
		if (!m_pHead)
		{
			// try to send it directly
			//-- remember: in "nRes" could be "-1" after "send" call
			int nRes = send(m_hSocket, (const char*) pData, dwDataSize, 0);

			if (((nRes < 0) || (nRes > (signed) dwDataSize)) && (WSAEWOULDBLOCK != WSAGetLastError()))
			{
				m_bValid = false;
			}
			else
			{
				//-- in nRes still could be "-1" (if WSAEWOULDBLOCK occured)
				//-- next to line should be like this:
				((const char*&) pData) += (nRes == -1 ? 0 : nRes);
				dwDataSize -= (nRes == -1 ? 0 : nRes);
				//-- ... and not like this:
				//-- ((const char*&) pData) += nRes;
				//-- dwDataSize -= nRes;
			}
		}

		if (dwDataSize && m_bValid)
		{
			// push it to our tails
			CChunk* pChunk = new CChunk;
			if (pChunk != NULL)
			{
				pChunk->m_pNext = NULL;
				pChunk->m_dwSize = dwDataSize;
				if ((pChunk->m_pData = new char[dwDataSize]) != NULL)
				{
					//-- data should be copied into "pChunk->m_pData" anyhow
					memcpy2(pChunk->m_pData, pData, dwDataSize);

					// push it to the end of our queue
					pChunk->m_pToSend = pChunk->m_pData;
					if (m_pTail)
						m_pTail->m_pNext = pChunk;
					else
						m_pHead = pChunk;
					m_pTail = pChunk;
				} else
					delete pChunk; // oops, no memory (???)
			}
		}
	}
	EMULE_CATCH2
}

void CWebSocket::SendReply(int iHTTPRespCode)
{
	char		acBuf[256], acGMT[EP_MAX_HTTPGMTSTR];
	const char	*pcHTTPStatus;
	CTime		timeCurrent = CTime::GetCurrentTime();
	struct tm	stTm = {0};

	acGMT[0] = '\0';
	if (timeCurrent.GetGmtTm(&stTm) != NULL)
		Gmt2HttpStr(acGMT, &stTm);

//	Convert HTTP status code into a HTTP status message
//	If an unknown status code is sent send "500 Internal Server Error"
	switch (iHTTPRespCode)
	{
		case 304:
			pcHTTPStatus = "304 Not Modified";
			break;
		case 404:
			pcHTTPStatus = "404 Not Found";
			break;
		default:
			pcHTTPStatus = "500 Internal Server Error";
			break;
	}

	int		iLen = wsprintfA( acBuf,
		"HTTP/1.1 %s\r\n"
		"Date: %s\r\n"						//	HTTP/1.x response header "Date:"
		"Server: " WS_SERVER_TOKEN "\r\n"	//	HTTP/1.x response header "Server:"
		"Connection: close\r\n\r\n",
		pcHTTPStatus,
		acGMT );
	ASSERT(iLen < ARRSIZE(acBuf));

	SendData(acBuf, iLen);
}

void CWebSocket::SendContent(LPCSTR szStdResponse, const void *pContent, DWORD dwContentSize)
{
	EMULE_TRY

	char		szBuf[2*1024], acGMT[EP_MAX_HTTPGMTSTR];
	CTime		timeCurrent = CTime::GetCurrentTime();
	struct tm	stTm = {0};

	acGMT[0] = '\0';
	if (timeCurrent.GetGmtTm(&stTm) != NULL)
		Gmt2HttpStr(acGMT, &stTm);

	int iLen = wsprintfA( szBuf,
		"HTTP/1.1 200 OK\r\n"
		"Date: %s\r\n"						//	HTTP/1.x response header "Date:"
		"Server: " WS_SERVER_TOKEN "\r\n"	//	HTTP/1.x response header "Server:"
		"%s"
		"Content-Length: %u\r\n"
		"Connection: close\r\n\r\n",
		acGMT,
		szStdResponse,
		dwContentSize );
	SendData(szBuf, iLen);
	SendData(pContent, dwContentSize);

	EMULE_CATCH2
}

void CWebSocket::Disconnect()
{
	EMULE_TRY

	if (m_bValid && m_bCanSend)
	{
		m_bCanSend = false;
		if (m_pTail)
		{
			// push it as a tail
			CChunk* pChunk = new CChunk;
			if (pChunk)
			{
				pChunk->m_dwSize = 0;
				pChunk->m_pData = NULL;
				pChunk->m_pToSend = NULL;
				pChunk->m_pNext = NULL;

				m_pTail->m_pNext = pChunk;
			}

		} else
			if (shutdown(m_hSocket, SD_SEND))
				m_bValid = false;
	}

	EMULE_CATCH2
}

UINT AFX_CDECL WebSocketAcceptedFunc(LPVOID pD)
{
#ifdef EP_SPIDERWEB
//	Setup Structured Exception handler for the this thread
	_set_se_translator(StructuredExceptionHandler);
#endif

	EMULE_TRY

	g_App.m_pPrefs->InitThreadLocale();

	SocketData *pData = (SocketData *)pD;
	SOCKET hSocket = pData->hSocket;
	CWebServer *pThis = (CWebServer *)pData->pThis;
	delete pData;

	ASSERT(INVALID_SOCKET != hSocket);


	HANDLE hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
	if (hEvent)
	{
		if (!WSAEventSelect(hSocket, hEvent, FD_READ | FD_CLOSE | FD_WRITE))
		{
			CWebSocket stWebSocket;
			stWebSocket.SetParent(pThis);
			stWebSocket.m_pHead = NULL;
			stWebSocket.m_pTail = NULL;
			stWebSocket.m_bValid = true;
			stWebSocket.m_bCanRecv = true;
			stWebSocket.m_bCanSend = true;
			stWebSocket.m_hSocket = hSocket;
			stWebSocket.m_pBuf = NULL;
			stWebSocket.m_dwRecv = 0;
			stWebSocket.m_dwBufSize = 0;
			stWebSocket.m_dwHttpHeaderLen = 0;
			stWebSocket.m_dwHttpContentLen = 0;

		//	In multithread environment every thread has its own random number generator
			srand(time(NULL));

			HANDLE pWait[] = { hEvent, s_hTerminate };

			while (WAIT_OBJECT_0 == WaitForMultipleObjects(2, pWait, FALSE, INFINITE))
			{
				while (stWebSocket.m_bValid)
				{
					WSANETWORKEVENTS stEvents;
					if (WSAEnumNetworkEvents(hSocket, NULL, &stEvents))
						stWebSocket.m_bValid = false;
					else
					{
						if (!stEvents.lNetworkEvents)
							break; //no more events till now

						if (FD_READ & stEvents.lNetworkEvents)
							for (;;)
							{
								char pBuf[0x1000];
								int nRes = recv(hSocket, pBuf, sizeof(pBuf), 0);
								if (nRes <= 0)
								{
									if (!nRes)
									{
										stWebSocket.m_bCanRecv = false;
										stWebSocket.OnReceived(NULL, 0);
									}
									else
										if (WSAEWOULDBLOCK != WSAGetLastError())
											stWebSocket.m_bValid = false;
									break;
								}
								stWebSocket.OnReceived(pBuf, nRes);
							}

						if (FD_CLOSE & stEvents.lNetworkEvents)
							stWebSocket.m_bCanRecv = false;

						if (FD_WRITE & stEvents.lNetworkEvents)
							// send what is left in our tails
							while (stWebSocket.m_pHead)
							{
								if (stWebSocket.m_pHead->m_pToSend)
								{
									int nRes = send(hSocket, stWebSocket.m_pHead->m_pToSend, stWebSocket.m_pHead->m_dwSize, 0);
									if (nRes != (signed) stWebSocket.m_pHead->m_dwSize)
									{
										if (nRes)
											if ((nRes > 0) && (nRes < (signed) stWebSocket.m_pHead->m_dwSize))
											{
												stWebSocket.m_pHead->m_pToSend += nRes;
												stWebSocket.m_pHead->m_dwSize -= nRes;

											} else
												if (WSAEWOULDBLOCK != WSAGetLastError())
													stWebSocket.m_bValid = false;
										break;
									}
								} else
									if (shutdown(hSocket, SD_SEND))
									{
										stWebSocket.m_bValid = false;
										break;
									}

								// erase this chunk
								CWebSocket::CChunk* pNext = stWebSocket.m_pHead->m_pNext;
								delete stWebSocket.m_pHead;
								if ((stWebSocket.m_pHead = pNext) == NULL)
									stWebSocket.m_pTail = NULL;
							}
					}
				}

				if (!stWebSocket.m_bValid || (!stWebSocket.m_bCanRecv && !stWebSocket.m_pHead))
					break;
			}

			while (stWebSocket.m_pHead)
			{
				CWebSocket::CChunk* pNext = stWebSocket.m_pHead->m_pNext;
				delete stWebSocket.m_pHead;
				stWebSocket.m_pHead = pNext;
			}
			delete[] stWebSocket.m_pBuf;
		}

		VERIFY(CloseHandle(hEvent));
	}

	VERIFY(!closesocket(hSocket));

	EMULE_CATCH2

	return 0;
}

UINT AFX_CDECL WebSocketListeningFunc(LPVOID pThis)
{
	EMULE_TRY

	g_App.m_pPrefs->InitThreadLocale();

	int		iRc = 0;

	SOCKET hSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
	if (INVALID_SOCKET != hSocket)
	{
		SOCKADDR_IN stAddr;
		stAddr.sin_family = AF_INET;
		stAddr.sin_port = fast_htons(g_App.m_pPrefs->GetWSPort());
		stAddr.sin_addr.S_un.S_addr = (g_App.m_pPrefs->GetBindAddrA() != NULL) ?
			inet_addr(g_App.m_pPrefs->GetBindAddrA()) : INADDR_ANY;

		if (!bind(hSocket, (sockaddr*)&stAddr, sizeof(stAddr)) &&
			!listen(hSocket, SOMAXCONN))
		{
			HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
			if (hEvent)
			{
				if (!WSAEventSelect(hSocket, hEvent, FD_ACCEPT))
				{
					CWebServer *pWebServer = (CWebServer*)pThis;//log intruder
					HANDLE pWait[] = { hEvent, s_hTerminate };
					while (WAIT_OBJECT_0 == WaitForMultipleObjects(2, pWait, FALSE, INFINITE))
						for (;;)
						{
							struct sockaddr_in their_addr;//log intruder
							int sin_size = sizeof(struct sockaddr_in);

							SOCKET hAccepted = accept(hSocket, (LPSOCKADDR)&their_addr, &sin_size);//log intruder

							if (INVALID_SOCKET == hAccepted)
								break;

							pWebServer->SetIP(their_addr.sin_addr.S_un.S_addr);//log intruder

							if(g_App.m_pPrefs->GetWSIsEnabled())
							{
								SocketData *pData = new SocketData;
								pData->hSocket = hAccepted;
								pData->pThis = pThis;
							//	Do NOT use Windows API 'CreateThread' to create a thread which uses MFC/CRT -> lots of mem leaks!
							//	'AfxBeginThread' could be used here, but creates a little too much overhead for our needs.
								CWinThread* pAcceptThread = new CWinThread(WebSocketAcceptedFunc, (LPVOID)pData);
								if (!pAcceptThread->CreateThread())
								{
									delete pAcceptThread;
									pAcceptThread = NULL;
									VERIFY( !closesocket(hSocket) );
								}
							}
							else
								VERIFY(!closesocket(hSocket));
						}
				}

				VERIFY(CloseHandle(hEvent));
			}
		}
		else
			iRc = WSAGetLastError();

		VERIFY(!closesocket(hSocket));
	}
	else
		iRc = WSAGetLastError();
	if (iRc != 0)
		g_App.m_pMDlg->AddLogLine(LOG_RGB_ERROR, IDS_WEB_SOCK_FAILED, iRc);

	EMULE_CATCH2

	return 0;
}


void StartSockets(CWebServer *pThis)
{
	ASSERT( s_hTerminate == NULL );
	ASSERT( s_pSocketThread == NULL );
	if ((s_hTerminate = CreateEvent(NULL, TRUE, FALSE, NULL)) != NULL)
	{
	//	Do NOT use Windows API 'CreateThread' to create a thread which uses MFC/CRT -> lot of mem leaks!
	//	because we want to wait on the thread handle we have to disable 'CWinThread::m_AutoDelete'
	//	-> can't use 'AfxBeginThread'
		s_pSocketThread = new CWinThread(WebSocketListeningFunc, (LPVOID)pThis);
		s_pSocketThread->m_bAutoDelete = FALSE;
		if (!s_pSocketThread->CreateThread())
		{
			CloseHandle(s_hTerminate);
			s_hTerminate = NULL;
			delete s_pSocketThread;
			s_pSocketThread = NULL;
		}
	}
}

void StopSockets()
{
	if (s_pSocketThread)
	{
		VERIFY( SetEvent(s_hTerminate) );

		if (s_pSocketThread->m_hThread)
		{
		//	Because we want to wait on the thread handle we must not use 'CWinThread::m_AutoDelete'.
		//	otherwise we may run into the situation that the CWinThread was already auto-deleted and
		//	the CWinThread::m_hThread is invalid.
			ASSERT( !s_pSocketThread->m_bAutoDelete );

			DWORD dwWaitRes = WaitForSingleObject(s_pSocketThread->m_hThread, 1300);
			if (dwWaitRes == WAIT_TIMEOUT)
			{
				TRACE("*** Failed to wait for websocket thread termination - Timeout\n");
				VERIFY( TerminateThread(s_pSocketThread->m_hThread, ~0ul) );
				VERIFY( CloseHandle(s_pSocketThread->m_hThread) );
			}
			else if (dwWaitRes == WAIT_FAILED)
			{
				TRACE("*** Failed to wait for websocket thread termination - Error %u\n", GetLastError());
				ASSERT(0); //	Probably invalid thread handle
			}
		}
		delete s_pSocketThread;
		s_pSocketThread = NULL;
	}
	if (s_hTerminate)
	{
		VERIFY( CloseHandle(s_hTerminate) );
		s_hTerminate = NULL;
	}
}
@


1.49
log
@Simplified logging system implementation.
@
text
@d553 2
a554 1
		stAddr.sin_addr.S_un.S_addr = INADDR_ANY;
d556 1
a556 1
		if (!bind(hSocket, (sockaddr*) &stAddr, sizeof(stAddr)) &&
@


1.48
log
@Faster (intrinsic) htonl and htons implementation.
@
text
@d609 1
a609 1
		g_App.m_pMDlg->AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_WEB_SOCK_FAILED), iRc);
@


1.47
log
@changed the intialization of thread locale
@
text
@d552 1
a552 1
		stAddr.sin_port = htons(g_App.m_pPrefs->GetWSPort());
@


1.46
log
@WebServer: fixed localization of the socket connection setup error;
WebServer: fixed application date format changed after WebServer usage {glaskrug} (previous solution based on setlocale was causing time format change from time to time);
Preparations for comprehensive exception handling;
Removed WSAStartup/WSACleanup which doesn't seem to be required.
@
text
@a403 2
	EMULE_TRY

d409 4
d543 1
a543 1
	::SetThreadLocale(g_App.m_pPrefs->GetLanguageID());
@


1.45
log
@Removed socket class friendship [Aw3].
@
text
@d39 26
d309 1
a309 1
	char		acBuf[256], acGMT[maxTimeBufferSize];
a312 1
	CString		strPrevLocale(_tsetlocale(LC_TIME, NULL));
d314 3
a316 7
	_tsetlocale(LC_TIME, _T("English"));
	if ( (timeCurrent.GetGmtTm(&stTm) == NULL) ||
		(strftime(acGMT, maxTimeBufferSize, "%a, %d %b %Y %H:%M:%S GMT", &stTm) == 0) )
	{
		acGMT[0] = '\0';
	}
	_tsetlocale(LC_TIME, strPrevLocale);
d349 1
a349 1
	char		szBuf[2*1024], acGMT[maxTimeBufferSize];
a351 1
	CString		strPrevLocale(_tsetlocale(LC_TIME, NULL));
d353 3
a355 7
	_tsetlocale(LC_TIME, _T("English"));
	if ( (timeCurrent.GetGmtTm(&stTm) == NULL) ||
		(strftime(acGMT, maxTimeBufferSize, "%a, %d %b %Y %H:%M:%S GMT", &stTm) == 0) )
	{
		acGMT[0] = '\0';
	}
	_tsetlocale(LC_TIME, strPrevLocale);
d406 5
d456 1
a456 1
							while (true)
d541 3
a543 2
	int		iRc;
	WSADATA	stData;
d545 2
a546 1
	if ((iRc = WSAStartup(MAKEWORD(2, 2), &stData)) == 0)
d548 7
a554 2
		SOCKET hSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
		if (INVALID_SOCKET != hSocket)
d556 2
a557 7
			SOCKADDR_IN stAddr;
			stAddr.sin_family = AF_INET;
			stAddr.sin_port = htons(g_App.m_pPrefs->GetWSPort());
			stAddr.sin_addr.S_un.S_addr = INADDR_ANY;

			if (!bind(hSocket, (sockaddr*) &stAddr, sizeof(stAddr)) &&
				!listen(hSocket, SOMAXCONN))
d559 1
a559 2
				HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
				if (hEvent)
d561 7
a567 9
					if (!WSAEventSelect(hSocket, hEvent, FD_ACCEPT))
					{
						CWebServer *pWebServer = (CWebServer*)pThis;//log intruder
						HANDLE pWait[] = { hEvent, s_hTerminate };
						while (WAIT_OBJECT_0 == WaitForMultipleObjects(2, pWait, FALSE, INFINITE))
							for (;;)
							{
								struct sockaddr_in their_addr;//log intruder
								int sin_size = sizeof(struct sockaddr_in);
d569 1
a569 1
								SOCKET hAccepted = accept(hSocket, (LPSOCKADDR)&their_addr, &sin_size);//log intruder
d571 2
a572 2
								if (INVALID_SOCKET == hAccepted)
									break;
d574 1
a574 1
								pWebServer->SetIP(their_addr.sin_addr.S_un.S_addr);//log intruder
d576 9
a584 1
								if(g_App.m_pPrefs->GetWSIsEnabled())
d586 3
a588 12
									SocketData *pData = new SocketData;
									pData->hSocket = hAccepted;
									pData->pThis = pThis;
								//	Do NOT use Windows API 'CreateThread' to create a thread which uses MFC/CRT -> lots of mem leaks!
								//	'AfxBeginThread' could be used here, but creates a little too much overhead for our needs.
									CWinThread* pAcceptThread = new CWinThread(WebSocketAcceptedFunc, (LPVOID)pData);
									if (!pAcceptThread->CreateThread())
									{
										delete pAcceptThread;
										pAcceptThread = NULL;
										VERIFY( !closesocket(hSocket) );
									}
a589 2
								else
									VERIFY(!closesocket(hSocket));
d591 4
a594 1
					}
d596 1
a596 2
					VERIFY(CloseHandle(hEvent));
				}
a597 4
			else
				iRc = WSAGetLastError();

			VERIFY(!closesocket(hSocket));
d602 1
a602 1
		VERIFY(!WSACleanup());
d604 2
@


1.44
log
@Suppressed level 4 warnings.
@
text
@d20 1
a22 1
#include "emule.h"
@


1.43
log
@fix compilation warnings under VC2005
@
text
@d1 1
a1 1
// ws2.cpp : Defines the entry point for the application.
d3 13
d257 1
a257 1
			if (pChunk)
d261 1
a261 1
				if (pChunk->m_pData = new char[dwDataSize])
a272 1

d487 1
a487 1
								if (!(stWebSocket.m_pHead = pNext))
d636 1
a636 1
				VERIFY( TerminateThread(s_pSocketThread->m_hThread, -1) );
@


1.42
log
@Fixed recently introduced bug related to random number generator.
@
text
@d274 1
a274 1
	struct tm*	ptm;
d278 2
a279 2
	if ( ((ptm = timeCurrent.GetGmtTm()) == NULL) ||
		(strftime(acGMT, maxTimeBufferSize, "%a, %d %b %Y %H:%M:%S GMT", ptm) == 0) )
d318 1
a318 1
	struct tm*	ptm;
d322 2
a323 2
	if ( ((ptm = timeCurrent.GetGmtTm()) == NULL) ||
		(strftime(acGMT, maxTimeBufferSize, "%a, %d %b %Y %H:%M:%S GMT", ptm) == 0) )
@


1.41
log
@Minor corrections and improvements (from original).
@
text
@d405 3
@


1.40
log
@Some renaming {Darklord}.
@
text
@d488 1
a488 2
			if (stWebSocket.m_pBuf)
				delete[] stWebSocket.m_pBuf;
@


1.39
log
@Reduced H-file dependency.
@
text
@d102 1
a102 1
		m_pParent->ProcessURL(Data);
d104 1
a104 1
		m_pParent->ProcessImgFileReq(Data);
@


1.38
log
@UNICODE preparation
@
text
@d4 1
a4 1
#include <stdafx.h> 
d6 1
a6 1

@


1.37
log
@WebServer: Added a new opcode for the "Server:" HTTP header
@
text
@d119 4
a122 3
		// reallocate
		TCHAR* pNewBuf = new TCHAR[m_dwBufSize = dwSize + m_dwRecv + SIZE_PRESERVE];
		if (!pNewBuf)
d124 1
a124 1
			m_bValid = false; // internal problem
d128 1
a128 1
		if (m_pBuf)
d139 2
a140 2
	// check if we have all that we want
	if (!m_dwHttpHeaderLen)
d142 3
a144 2
		// try to find it
		bool bPrevEndl = false;
d146 1
d148 1
d151 2
a152 2
					// We just found the end of the http header
					// Now write the message's position into two first DWORDs of the buffer
d155 2
a156 2
					// try to find now the 'Content-Length' header
					for (dwPos = 0; dwPos < m_dwHttpHeaderLen; )
d160 1
a160 1
						if (!pPtr)
a161 1
						DWORD dwNextPos = pPtr - m_pBuf;
d163 6
a168 3
						// check this header
						char szMatch[] = "content-length";
						if (!strnicmp(m_pBuf + dwPos, szMatch, sizeof(szMatch) - 1))
d170 3
a172 3
							dwPos += sizeof(szMatch) - 1;
							pPtr = reinterpret_cast<char*>(memchr(m_pBuf + dwPos, ':', m_dwHttpHeaderLen - dwPos));
							if (pPtr)
a178 1

a181 1
				{
d183 4
a186 4
				}
			else
				if ('\r' != m_pBuf[dwPos])
					bPrevEndl = false;
d189 1
a189 1
	if (m_dwHttpHeaderLen && !m_bCanRecv && !m_dwHttpContentLen)
d192 1
a192 1
	if ((m_dwHttpHeaderLen != 0) && (m_dwHttpContentLen < m_dwRecv) && (!m_dwHttpContentLen || (m_dwHttpHeaderLen + m_dwHttpContentLen <= m_dwRecv)))
d198 1
a198 1
			// move our data
d201 2
a202 1
		} else
@


1.36
log
@Fixed Unicode issues in processing of the socket streams;
Created a routine for sending simple replies.
@
text
@d298 1
a298 1
		"Server: " PLUS_VERSION_STR "\r\n"	//	HTTP/1.x response header "Server:"
d327 1
a327 1
		"Server: " PLUS_VERSION_STR "\r\n"	//	HTTP/1.x response header "Server:"
@


1.35
log
@WebServer: Added capturing of the HTTP header "If-Modified-Since:"
@
text
@d31 1
a31 1
void CWebSocket::OnRequestReceived(TCHAR* pHeader, DWORD dwHeaderLen, TCHAR* pData, DWORD dwDataLen)
d35 2
a36 2
	CString		sHeader(pHeader, dwHeaderLen);
	CString		sURL;
d46 1
a46 1
		CString		sData(pData, dwDataLen);
d48 1
a48 1
		sURL = _T('?');
d51 1
a51 1
	iIdx = sURL.Find(_T(' '));
d54 1
a54 1
	iIdx = sURL.Find(_T(' '));
d60 1
a60 1
		CString		strExt4 = sURL.Right(4).MakeLower();
d62 1
a62 1
		if (( (strExt4 == ".gif") || (strExt4 == ".jpg") || (strExt4 ==".png") ||
d65 1
a65 1
			&& sURL.Find(_T("..")) < 0 )	// don't allow leaving the emule-webserver-folder for accessing files
d67 1
a67 1
			bFileReq=true;
d72 2
a73 2
	CString		strAcceptEncoding;
	iIdx = sHeader.Find(_T("Accept-Encoding: "));
d76 1
a76 1
		int	iIdx2 = sHeader.Find(_T("\r\n"), iIdx += 17);
d83 3
a85 3
	CString		strIfModifiedSince;
	iIdx = sHeader.Find(_T("If-Modified-Since: "));
	if ( iIdx >= 0 )
d87 2
a88 1
		int    iIdx2 = sHeader.Find(_T("\r\n"), iIdx += 19);
d154 2
a155 1
						TCHAR* pPtr = reinterpret_cast<TCHAR*>(memchr(m_pBuf + dwPos, '\n', m_dwHttpHeaderLen - dwPos));
d161 2
a162 2
						TCHAR szMatch[] = _T("content-length");
						if (!_tcsncicmp(m_pBuf + dwPos, szMatch, sizeof(szMatch) - 1))
d165 1
a165 1
							pPtr = reinterpret_cast<TCHAR*>(memchr(m_pBuf + dwPos, ':', m_dwHttpHeaderLen - dwPos));
d167 1
a167 1
								m_dwHttpContentLen = _tstol(pPtr + 1);
d264 1
a264 1
void CWebSocket::SendContent(int iHTTPRespCode, LPCSTR szStdResponse, const void *pContent, DWORD dwContentSize)
d266 5
a270 1
	EMULE_TRY
d272 7
a278 1
	const char	*pcHTTPStatus;
a283 3
		case 200:
			pcHTTPStatus = "200 OK";
			break;
d295 16
d325 1
a325 1
		"HTTP/1.1 %s\r\n"
a330 1
		pcHTTPStatus,
@


1.34
log
@Rolled back recent changes in HTTP header date format {roytam1},
@
text
@d82 10
d98 1
@


1.33
log
@Finished corrections of Unicode issues related to HTTP response preparation;
Optimized string processing; Modified HTTP server name to use shorter form;
Reduce stack buffer size (4k=>2k), that big is not required.
@
text
@d278 1
d280 1
d286 2
@


1.32
log
@WebSocket: Added the ablity for SendContent() to send HTTP headers other than "200 OK"
@
text
@d74 1
a74 1
	if ( iIdx >= 0 )
d76 2
a77 1
		int    iIdx2 = sHeader.Find(_T("\r\n"), iIdx += 17);
d251 1
a251 1
void CWebSocket::SendContent(int iHTTPResponseCode, LPCSTR szStdResponse, const void *pContent, DWORD dwContentSize)
d255 2
d259 1
a259 2
	CString	strHTTPStatus;
	switch(iHTTPResponseCode)
d262 1
a262 1
			strHTTPStatus = _T("HTTP/1.1 200 OK\r\n");
d265 1
a265 1
			strHTTPStatus = _T("HTTP/1.1 304 Not Modified\r\n");
d268 1
a268 1
			strHTTPStatus = _T("HTTP/1.1 404 Not Found\r\n");
d271 1
a271 1
			strHTTPStatus = _T("HTTP/1.1 500 Internal Server Error\r\n");
d275 21
a295 10
//	HTTP/1.x response header "Date:"
//	HTTP/1.x response header "Server:"
	CTime	timeCurrent = CTime::GetCurrentTime();
	strHTTPStatus.AppendFormat(_T("Date: %s\r\nServer: %s/%s\r\n"),
			timeCurrent.FormatGmt("%a, %d %b %Y %H:%M:%S GMT"),
			CLIENT_NAME, CURRENT_VERSION);

	char szBuf[0x1000];
	int nLen = wsprintfA(szBuf, "%s%sContent-Length: %ld\r\nConnection: close\r\n\r\n", strHTTPStatus, szStdResponse, dwContentSize);
	SendData(szBuf, nLen);
@


1.31
log
@Unicode corrections.
@
text
@d250 1
a250 1
void CWebSocket::SendContent(LPCSTR szStdResponse, const void *pContent, DWORD dwContentSize)
d254 18
a271 1
	CString	strHTTPStatus = _T("HTTP/1.1 200 OK\r\n");//This is in readyness for outputing others.
d278 1
a278 1
			CLIENT_NAME, CURRENT_VERSION_LONG);
@


1.30
log
@Moved the HTTP headers "Connection: close" and "Server:" to CWebSocket::SendContent().
Added the HTTP header "Date:" to CWebSocket::SendContent().
Modified the HTTP header "Server:" its value is now "<App Name>/<Version>".
@
text
@d250 1
a250 1
void CWebSocket::SendContent(LPCTSTR szStdResponse, const void* pContent, DWORD dwContentSize)
@


1.29
log
@WebServer: Added support for the HTTP request header "Accept-Encoding".
Output of pages are now automatically gziped only if the browser supports it.
Hid the Preference controls in the templates for manually turning gzip on/off.
@
text
@d254 9
d264 1
a264 1
	int nLen = wsprintfA(szBuf, "HTTP/1.1 200 OK\r\n%sContent-Length: %ld\r\n\r\n", szStdResponse, dwContentSize);
@


1.28
log
@Minor optimization; Formatting.
@
text
@d71 10
d86 1
@


1.27
log
@Removed unused code.
@
text
@a6 2
#include <stdlib.h> // for _tstol function

d52 1
a52 1
	if (iIdx > -1)
d55 1
a55 1
	if (iIdx > -1)
d65 1
a65 1
			&& sURL.Find(_T("..")) == -1 )	// dont allow leaving the emule-webserver-folder for accessing files
@


1.26
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@a451 1
									DWORD dwThread = 0;
@


1.25
log
@renamed 3 variables
@
text
@d424 1
a424 1
			stAddr.sin_port = htons(g_App.g_pPrefs->GetWSPort());
d450 1
a450 1
								if(g_App.g_pPrefs->GetWSIsEnabled())
@


1.24
log
@WebServer: prevent file access outside webserver directory (original)
@
text
@d424 1
a424 1
			stAddr.sin_port = htons(g_eMuleApp.m_pGlobPrefs->GetWSPort());
d450 1
a450 1
								if(g_eMuleApp.m_pGlobPrefs->GetWSIsEnabled())
d485 1
a485 1
		g_eMuleApp.m_pdlgEmule->AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_WEB_SOCK_FAILED), iRc);
@


1.23
log
@WebServer: ability to host xml and txt files
@
text
@d64 1
a64 1
		if ( (strExt4 == ".gif") || (strExt4 == ".jpg") || (strExt4 ==".png") ||
d67 1
d193 1
a193 1
			//-- remember: in "nRes" could be "-1" after "send" call	//SyruS (0.30b)
d222 1
a222 1
					//-- data should be copied into "pChunk->m_pData" anyhow	//SyruS (0.30b)
@


1.22
log
@Use return code define instead of a number.
@
text
@d66 1
a66 1
			(strExt4 == ".bmp") || (sURL.Right(5).MakeLower()==".jpeg") )
@


1.21
log
@Fixed mem leak.
@
text
@d533 1
a533 1
			else if (dwWaitRes == -1)
@


1.20
log
@Fixed first wrong socket accept processing; Removed unrequired try/catch; Stop cleanup.
@
text
@d19 2
a20 2
HANDLE g_hTerminate = NULL;
HANDLE g_hSocketThread = NULL;
d131 1
a131 1
						PVOID pPtr = memchr(m_pBuf + dwPos, '\n', m_dwHttpHeaderLen - dwPos);
d134 1
a134 1
						DWORD dwNextPos = ((DWORD) pPtr) - ((DWORD) m_pBuf);
d141 1
a141 1
							pPtr = memchr(m_pBuf + dwPos, ':', m_dwHttpHeaderLen - dwPos);
d143 1
a143 1
								m_dwHttpContentLen = _tstol(((TCHAR*) pPtr) + 1);
d281 1
a281 1
DWORD WINAPI WebSocketAcceptedFunc(void *pD)
d312 1
a312 1
			HANDLE pWait[] = { hEvent, g_hTerminate };
d409 1
a409 1
DWORD WINAPI WebSocketListeningFunc(void *pThis)
d435 1
a435 1
						HANDLE pWait[] = { hEvent, g_hTerminate };
d455 9
a463 5
									HANDLE hThread = CreateThread(NULL, 0, WebSocketAcceptedFunc, (void *)pData, 0, &dwThread);
									if (hThread)
										VERIFY(CloseHandle(hThread));
									else
										VERIFY(!closesocket(hSocket));
d494 15
a508 9
	if (g_hTerminate = CreateEvent(NULL, TRUE, FALSE, NULL))
	{
		DWORD dwThread = 0;
		g_hSocketThread = CreateThread(NULL, 0, WebSocketListeningFunc, (void*)pThis, 0, &dwThread);
		if (!g_hSocketThread)
		{
			VERIFY(CloseHandle(g_hTerminate));
			g_hTerminate = NULL;
			g_hSocketThread = NULL;
d515 1
a515 1
	if (g_hSocketThread)
d517 8
a524 1
		VERIFY(SetEvent(g_hTerminate));
d526 15
a540 4
		if (WAIT_TIMEOUT == WaitForSingleObject(g_hSocketThread, 1300))
			VERIFY(TerminateThread(g_hSocketThread, -1));
		VERIFY(CloseHandle(g_hSocketThread));
		g_hSocketThread = 0;
d542 1
a542 1
	if (g_hTerminate)
d544 2
a545 2
		VERIFY(CloseHandle(g_hTerminate));
		g_hTerminate = 0;
@


1.19
log
@WebServer: added missed report of socket creation failure.
@
text
@d429 1
a429 1
				HANDLE hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
a487 1

a489 2
	EMULE_TRY

a500 2
	
	EMULE_CATCH2
a504 2
	EMULE_TRY

d512 1
d515 1
d517 2
a518 2

	EMULE_CATCH2
@


1.18
log
@Fixed webinterface exploit (official).
@
text
@d413 2
a414 2
	SOCKADDR_IN sin;//log intruder
	int sin_length = sizeof(sin);//log intruder
d416 1
a416 2
	WSADATA stData;
	if (!WSAStartup(MAKEWORD(2, 2), &stData))
d437 1
a437 1
							while (true)
d446 2
a447 2
								else
									pWebServer->SetIP(their_addr.sin_addr.S_un.S_addr);//log intruder
d469 2
d474 2
d479 2
@


1.17
log
@Connected server is now background highlighted; Aw3 fix for IP2Country constant DB/LIB loading from preferences; Replaced all ZeroMemory with memzero; Replaced all CopyMemory with memcpy2
@
text
@a158 1

d164 1
a164 1
	if (m_dwHttpHeaderLen && (!m_dwHttpContentLen || (m_dwHttpHeaderLen + m_dwHttpContentLen <= m_dwRecv)))
@


1.16
log
@Improved string processing
@
text
@d106 1
a106 1
			CopyMemory(pNewBuf, m_pBuf, m_dwRecv);
d112 1
a112 1
	CopyMemory(m_pBuf + m_dwRecv, pData, dwSize);
d223 1
a223 1
					CopyMemory(pChunk->m_pData, pData, dwDataSize);
@


1.15
log
@Updated to official v0.30c
@
text
@d37 4
a40 25
	CString sHeader(pHeader, dwHeaderLen);
	CString sData(pData, dwDataLen);
	CString sURL;
	bool filereq=false;

	if(sHeader.Left(3) == "GET")
		sURL = sHeader.Trim();

	else if(sHeader.Left(4) == "POST")
		sURL = _T("?") + sData.Trim();	// '?' to imitate GET syntax for ParseURL

		if(sURL.Find(_T(" ")) > -1)
			sURL = sURL.Mid(sURL.Find(_T(" "))+1, sURL.GetLength());
		if(sURL.Find(_T(" ")) > -1)
			sURL = sURL.Left(sURL.Find(_T(" ")));

	if (sURL.GetLength()>4 && sURL.Right(4).MakeLower()==".gif" || sURL.Right(4).MakeLower()==".jpg" || sURL.Right(4).MakeLower()==".png" ||
		sURL.Right(4).MakeLower()==".ico" ||sURL.Right(4).MakeLower()==".css" ||sURL.Right(3).MakeLower()==".js" || //(0.29b) 
		sURL.Right(4).MakeLower()==".bmp" ||sURL.Right(5).MakeLower()==".jpeg")
		filereq=true;

		ThreadData Data;
		Data.sURL = sURL;
		Data.pThis = m_pParent;
		Data.pSocket = this;
d42 40
a81 2
	if (!filereq) m_pParent->ProcessURL(Data);
		else m_pParent->ProcessImgFileReq(Data);
@


1.14
log
@More try/catch
@
text
@a154 1
			MoveMemory(m_pBuf, m_pBuf + m_dwHttpHeaderLen + m_dwHttpContentLen, m_dwRecv - m_dwHttpHeaderLen + m_dwHttpContentLen);
d156 1
@


1.13
log
@(0.30b) fixes for CWebSocket::SendData
@
text
@d35 2
d67 2
d73 2
d163 1
a163 1

d168 2
d221 1
a221 1

d226 2
d232 2
d238 2
d261 2
d388 1
a388 1
	EMULE_CATCH
d461 1
a461 1
	EMULE_CATCH
d484 1
a484 1
	EMULE_CATCH
d502 1
a502 1
	EMULE_CATCH
@


1.12
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d168 1
d172 1
d174 1
d177 7
a183 2
				((const char*&) pData) += nRes;
				dwDataSize -= nRes;
d197 3
@


1.11
log
@fixed crash if StopSocket() will be called before StartSocket()
@
text
@d381 1
a381 1
			stAddr.sin_port = htons(theApp.glob_prefs->GetWSPort());
d407 1
a407 1
								if(theApp.glob_prefs->GetWSIsEnabled())
@


1.10
log
@added couninitialize and additional filetypes from 0.29b
@
text
@d449 6
d472 2
a473 1
	VERIFY(CloseHandle(g_hTerminate));
@


1.9
log
@more Purity´s changes to WebServer (IP logging, split uploadqueue)
@
text
@d52 1
@


1.8
log
@unicode cleanup
@
text
@d369 3
d391 1
d396 5
a400 1
								SOCKET hAccepted = accept(hSocket, NULL, NULL);
d403 2
@


1.7
log
@unicode cleanup
@
text
@d7 1
a7 1
#include <stdlib.h> // for atol function
d33 1
a33 1
void CWebSocket::OnRequestReceived(char* pHeader, DWORD dwHeaderLen, char* pData, DWORD dwDataLen)
d73 1
a73 1
		char* pNewBuf = new char[m_dwBufSize = dwSize + m_dwRecv + SIZE_PRESERVE];
d113 2
a114 2
						char szMatch[] = "content-length";
						if (!strnicmp(m_pBuf + dwPos, szMatch, sizeof(szMatch) - 1))
d119 1
a119 1
								m_dwHttpContentLen = atol(((char*) pPtr) + 1);
@


1.6
log
@Upgrade to 0.28a
@
text
@d44 1
a44 1
		sURL = "?" + sData.Trim();	// '?' to imitate GET syntax for ParseURL
d46 4
a49 4
		if(sURL.Find(" ") > -1)
			sURL = sURL.Mid(sURL.Find(" ")+1, sURL.GetLength());
		if(sURL.Find(" ") > -1)
			sURL = sURL.Left(sURL.Find(" "));
d204 1
a204 1
void CWebSocket::SendContent(LPCSTR szStdResponse, const void* pContent, DWORD dwContentSize)
@


1.5
log
@Upgrade to webserver official 0.28a
@
text
@d377 1
a377 1
			stAddr.sin_port = htons(theApp.glob_prefs->GetHTTPPort());
d396 1
a396 1
								if(theApp.glob_prefs->GetHTTPIsEnabled())
d451 1
a451 1
		if (WAIT_TIMEOUT == WaitForSingleObject(g_hSocketThread, 300))
@


1.4
log
@converted to new logging method
@
text
@d37 2
d41 1
a41 6
	{
		CString sURL = sHeader.Trim();
		if(sURL.Find(" ") > -1)
			sURL = sURL.Mid(sURL.Find(" ")+1, sURL.GetLength());
		if(sURL.Find(" ") > -1)
			sURL = sURL.Left(sURL.Find(" "));
d43 2
a44 11
		ThreadData Data;
		Data.sURL = sURL;
		Data.pThis = m_pParent;
		Data.pSocket = this;

		m_pParent->ProcessURL(Data);
	}
	else
	if(sHeader.Left(4) == "POST")
	{
		CString sURL = "?" + sData.Trim();	// '?' to imitate GET syntax for ParseURL
d51 4
d60 3
a62 8
		m_pParent->ProcessURL(Data);
	}
/*	else
	{
		AddLogLine(false, "ReceivedHeader: " + sHeader);
		AddLogLine(false, "ReceivedData: " + sData);
	}
*/
@


1.3
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d72 2
a73 2
		theApp.emuledlg->AddLogLine(false, "ReceivedHeader: " + sHeader);
		theApp.emuledlg->AddLogLine(false, "ReceivedData: " + sData);
@


1.2
log
@Added instrumentation for debugging memory leaks :
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

To all .cpp files (I hope I didn't miss any one)
@
text
@d4 2
a5 3
#include "stdafx.h"
#pragma comment (lib, "ws2_32.lib")
#include <winsock2.h>
a17 1

@


1.1
log
@*** empty log message ***
@
text
@d14 7
@


1.1.4.1
log
@updating this branch...
@
text
@@

