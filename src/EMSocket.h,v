head	1.20;
access;
symbols
	PublicRelease_1_2e:1.18
	Interim_Release_1-2e_RC1:1.18
	PublicRelease_1_2d:1.17
	Interim_Release_1-2d_RC1:1.17
	Interim_Release_1-2d_beta1:1.17
	PublicRelease_1_2c:1.17
	Interim_Release_1-2c_RC1:1.17
	Interim_Release_1-2c_beta1:1.17
	PublicRelease_1_2b:1.17
	Interim_Release_1-2b_RC1:1.17
	PublicRelease_1_2a:1.16
	Interim_Release_1-2a_RC1:1.16
	Interim_Release_1-2a_beta2:1.16
	Interim_Release_1-2a_beta1:1.16
	PublicRelease_1_2:1.13
	Interim_Release_1-2_RC1:1.13
	Interim_Release_1-2_beta1:1.11
	PublicRelease_1_1g:1.11
	Interim_Release_1-1g_RC3:1.11
	Interim_Release_1-1g_RC2:1.11
	Interim_Release_1-1g_RC1:1.11
	Interim_Release_1-1g_beta2:1.11
	Interim_Release_1-1g_beta1:1.11
	PublicRelease_1_1f:1.11
	Interim_Release_1-1f_RC1:1.11
	PublicRelease_1_1e:1.11
	Interim_Release_1-1e_RC2:1.11
	Interim_Release_1-1e_RC1:1.11
	Interim_Release_1-1e_beta1:1.10
	PublicRelease_1_1d:1.10
	Interim_Release_1-1d_RC1:1.10
	PublicRelease_1_1c:1.10
	Interim_Release_1-1c_RC1:1.10
	Interim_Release_1-1c_beta2:1.10
	Interim_Release_1-1c_beta1:1.10
	PublicRelease_1_1b:1.9
	Interim_Release_1-1b_RC1:1.9
	PublicRelease_1_1a:1.9
	Interim_Release_1-1a_RC2:1.9
	Interim_Release_1-1a_RC1:1.9
	Interim_Release_1-1a_beta2:1.9
	Interim_Release_1-1a_beta1:1.9
	PublicRelease_1_1:1.9
	Interim_Release_1-1_beta1:1.9
	PublicRelease_1o:1.9
	Interim_Release_1o_RC1:1.9
	Interim_Release_1o_beta1:1.9
	PublicRelease_1n:1.9
	Interim_Release_1n_RC2:1.9
	Interim_Release_1n_RC1:1.9
	Interim_Release_1n_beta2:1.9
	Interim_Release_1n_beta1:1.9
	PublicRelease_1m:1.9
	Interim_Release_1m_beta1:1.9
	PublicRelease_1l:1.9
	Interim_Release_1l_RC3:1.9
	Interim_Release_1l_RC2:1.9
	Interim_Release_1l_RC1:1.9
	Interim_Release_1l_beta2:1.8
	Interim_Release_1l_beta1:1.8
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.8
	Interim_Release_1J_RC3:1.8
	Interim_Release_1j_RC3:1.8
	Interim_Release_1j_RC2:1.8
	Interim_Release_1j_RC1:1.8
	Interim_Release_1j_beta2:1.8
	Interim_Release_1j_beta1:1.8
	PublicRelease_1i:1.8
	Interim_Release_1i_RC6:1.8
	Interim_Release_1i_RC3:1.8
	Interim_Release_1i_RC2:1.8
	Interim_Release_1i_RC1:1.8
	Interim_Release_1i_beta3:1.8
	Interim_Release_1i_beta2:1.8
	Interim_Release_1i_beta1:1.6
	PublicRelease_1h:1.5
	Interim_Release_1h_rc2:1.5
	Interim_Release_1h_RC1:1.5
	Interim_Release_1h_beta2:1.5
	Interim_Release_1h_beta1_now:1.5
	Interim_Release_1h_beta1:1.5
	PublicRelease_1g:1.5
	Interim_Release_1g_RC6_Final:1.5
	Interim_Release_1g_RC6:1.5
	Interim_Release_1g_RC5:1.5
	Interim_Release_1g_RC4:1.5
	Interim_Release_1g_RC3:1.5
	Interim_Release_1g_beta2:1.5
	Interim_Release_1g_beta1:1.5
	Interim_Release_1f_RC4:1.5
	Interim_Release_1f_RC3:1.5
	Interim_Release_1f_RC2:1.5
	Interim_Release_1f_RC:1.5
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.4
	Interim_Release_1e_beta1:1.4
	PublicRelease_1c:1.4
	featurestest:1.4.0.4
	Interim_Release_1c_RC:1.4
	Interim_Release_1c_beta2:1.4
	Interim_Release_1c_beta1:1.4
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.4
	Interim_Release_1b_beta2:1.4
	Interim_Release_1b_beta1:1.4
	proxydeadlake:1.3.0.8
	PublicRelease_1a:1.3
	Interim_Release_1a_beta2:1.3
	BerkeleyDb:1.3.0.6
	Interim_Release_1a_beta1:1.3
	PublicRelease_1:1.3
	goldfish:1.3
	eMulePlus_1_RC2:1.3
	eMulePlus_26b_1RC1:1.3
	PreRelease_26b_i0e:1.3
	before_26d_merge:1.3
	Interim_Release_26b_i0d:1.3
	Interim_Release_26b_i0c:1.3
	Interim_Release_26b_i0b:1.3
	Interim_Release_26b_i0a:1.3
	systraydlg:1.3.0.4
	plus26based:1.3.0.2
	Interim_Release_25b_i0b:1.3
	Proxy_Dev:1.2
	Interim_Release_25b_i0a:1.2.2.3
	proxytest:1.2.2.2.0.2
	official_sockets:1.2.0.2
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@ * @;


1.20
date	2009.11.20.03.48.37;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.01.01.45.19;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2008.12.08.13.28.22;	author kush_eplus;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.08.06.02.31;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.25.05.09.56;	author aw3;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.22.15.19.36;	author eklmn;	state Exp;
branches;
next	1.14;

1.14
date	2006.04.16.00.17.31;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2006.02.15.05.23.03;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2006.02.06.03.06.28;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.20.04.34.36;	author aw3;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.19.21.10.46;	author netwolf1;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.25.02.24.34;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.08.01.53.31;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.05.17.53.56;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.5;

1.5
date	2003.04.22.12.41.51;	author kuchin;	state Exp;
branches;
next	1.4;

1.4
date	2003.02.28.18.43.41;	author dongato;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2003.02.02.10.47.20;	author cax2;	state Exp;
branches
	1.3.6.1
	1.3.8.1;
next	1.2;

1.2
date	2003.01.22.17.53.24;	author kuchin;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.01.21.18.21.17;	author cax2;	state Exp;
branches;
next	;

1.2.2.1
date	2003.01.28.14.55.42;	author obaldin;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2003.01.28.22.27.08;	author maverick65;	state Exp;
branches
	1.2.2.2.2.1;
next	1.2.2.3;

1.2.2.3
date	2003.01.29.10.36.29;	author cax2;	state Exp;
branches;
next	;

1.2.2.2.2.1
date	2003.01.28.23.51.14;	author maverick65;	state Exp;
branches;
next	;

1.3.6.1
date	2003.03.01.20.59.35;	author obaldin;	state Exp;
branches;
next	;

1.3.8.1
date	2003.02.28.10.48.30;	author dongato;	state Exp;
branches;
next	;

1.4.4.1
date	2003.03.23.06.22.02;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.20
log
@Encryption preparations.
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#pragma once
#include "EncryptedStreamSocket.h"

class CAsyncProxySocketLayer;
class Packet;

enum EnumConnectionStates
{
	ES_NOTCONNECTED	= 0x00,
	ES_CONNECTED	= 0x01,
	ES_CONNECTING	= 0x02,
	ES_DISCONNECTED	= 0xFF
};

#define PACKET_HEADER_SIZE	6

class CEMSocket : public CEncryptedStreamSocket
{
public:
			CEMSocket(void);
	virtual	~CEMSocket(void);
	virtual void	SendPacket(Packet *pPacket, bool bDeletePacket = true, bool bControlPacket = true);// controlpackets have a higher priority
	bool	IsBusy() const { return m_pcSendBuffer != NULL; }
	bool	IsConnected() const { return m_eConnectionState == ES_CONNECTED; }
	bool	IsConnecting() const { return m_eConnectionState == ES_CONNECTING; }
	void	SetDownloadLimit(uint32 dwLimit);
	void	DisableDownloadLimit(bool bAvoidRead = false);
	BOOL	AsyncSelect(long lEvent);

	virtual BOOL Connect(LPCSTR lpszHostAddress, UINT nHostPort);
	virtual BOOL Connect(SOCKADDR *pSockAddr, int iSockAddrLen);
	virtual void RemoveAllLayers();	//	Reset Layer Chain
	bool	TruncateQueues();

protected:
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nCode, WPARAM wParam, LPARAM lParam);
	virtual void	PacketReceived(Packet *pPacket) = 0;
	virtual void	OnError(int iErrorCode) = 0;
	virtual void	OnClose(int iErrorCode);
	virtual void	OnSend(int iErrorCode);
	virtual void	OnReceive(int iErrorCode);

	EnumConnectionStates	m_eConnectionState;
	bool	m_bProxyConnectFailed;
	CAsyncProxySocketLayer	*m_pProxyLayer;

private:
	void		ClearQueues();
	int			Send(char* lpBuf,int nBufLen,int nFlags = 0);
	virtual int	Receive(void* lpBuf, int nBufLen, int nFlags = 0);
	void		InitProxySupport();

//	Download (pseudo) rate control
	uint32		m_dwDownloadLimit;
	bool		m_bEnableDownloadLimit;
	bool		m_bPendingOnReceive;

//	Download partial header
	char			m_arrcPendingHeader[PACKET_HEADER_SIZE];
	uint32		m_dwPendingHeaderSize;

//	Download partial packet
	Packet	   *m_pPendingPacket;
	uint32		m_dwPendingPacketSize;

//	Upload control
	char	   *m_pcSendBuffer;
	uint32		m_dwSendBufLen;
	uint32		m_dwNumBytesSent;
	bool		m_bLinkedPackets;

	CTypedPtrList<CPtrList, Packet*> m_controlPacketQueue;
	CTypedPtrList<CPtrList, Packet*> m_standardPacketQueue;

	bool		m_bInPacketReceived;
};
@


1.19
log
@Reduced H-file dependency.
@
text
@d18 1
a18 5

#include "AsyncSocketEx.h" // deadlake PROXYSUPPORT Socketfiles

#define ERR_WRONGHEADER		0x01
#define ERR_TOOBIG			0x02
d33 1
a33 1
class CEMSocket : public CAsyncSocketEx // deadlake PROXYSUPPORT - changed to AsyncSocketEx
@


1.18
log
@Make base class destructors virtual.
@
text
@a18 3
#include "afxsock.h"
#include "types.h"
#include "packets.h"
a19 1
#include "AsyncProxySocketLayer.h" // deadlake PROXYSUPPORT Socketfiles
d24 3
d35 2
d79 1
a79 1
	char			m_arrcPendingHeader[sizeof(PacketHeader_Struct)];
@


1.17
log
@Fixed source loss at the time of unexpected downloading disconnection {muleteer};
Fixed ability to keep connection after cancel transfer reception; Formatting.
@
text
@d40 1
a40 1
		   ~CEMSocket(void);
@


1.16
log
@Removed unused code.
@
text
@d17 1
a18 1
#pragma once
d51 2
a52 2
//	Reset Layer Chain
	virtual void RemoveAllLayers();
d93 2
@


1.15
log
@1) last LowID check, i.e. put LowID client in proper state in TryToConnect();
2) added CONNECTING state
3) force request by A4AF swap for LowID clients (the proper state will set inTryToConnect() )
@
text
@a44 1
	EnumConnectionStates	GetConState() const { return m_eConnectionState; }
@


1.14
log
@Unicode preparations; Slightly faster socket creation to contact other sources.
@
text
@d32 1
d44 1
@


1.13
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues.
@
text
@d49 1
d68 2
a69 1
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);
@


1.12
log
@Fixed timeout processing for chat session (timeout only in case when both sides don't send anything).
@
text
@d48 1
a48 3
//	deadlake PROXYSUPPORT
//	By Maverick: Connection necessary initalizing calls are done by class itself and not anymore by the Owner
	BOOL	virtual Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
d53 1
a53 1
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	// deadlake PROXYSUPPORT
d61 1
a61 4

//	deadlake PROXYSUPPORT
	bool	m_ProxyConnectFailed;

@


1.11
log
@Fixed socket processing flaw causing exceptions at the end of downloading {muleteer}.
@
text
@d32 1
a32 1
	ES_DISCONNECTED = 0xFF,
d40 1
a40 1
	bool	SendPacket(Packet *pPacket, bool bDeletePacket = true,bool bControlPacket = true);// controlpackets have a higher priority
d59 1
a59 1
	virtual void	OnSend(int iErrorCode);	
d70 1
a70 1
	void		ClearQueues();	
d74 1
a74 1
//	Download (pseudo) rate control	
@


1.10
log
@Don't use 32 bit color resources if OS/comctl32.dll doesn't support it and some other minor changes/optimizations.
@
text
@d45 1
a45 1
	void	DisableDownloadLimit();
@


1.9
log
@Fixed variable declaration (reported on official forum).
@
text
@d52 1
a52 1
	virtual void CEMSocket::RemoveAllLayers();
@


1.8
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d80 1
a80 1
	char	   *m_arrcPendingHeader[sizeof(PacketHeader_Struct)];
@


1.7
log
@Formatting, comments, and name changes.
@
text
@a34 2
#define PACKET_HEADER_SIZE	6

d38 7
a44 7
	CEMSocket(void);
	~CEMSocket(void);
	bool	SendPacket(Packet* packet, bool delpacket = true,bool controlpacket = true);// controlpackets have a higher priority
	bool	IsBusy() const {return sendbuffer;}
	bool	IsConnected() const {return m_eConnectionState == ES_CONNECTED;}
	EnumConnectionStates	GetConState() const {return m_eConnectionState;}
	void	SetDownloadLimit(uint32 limit);
d48 2
a49 2
	// deadlake PROXYSUPPORT
	// By Maverick: Connection necessary initalizing calls are done by class itself and not anymore by the Owner
d51 1
a51 1
	// Reset Layer Chain
d55 6
a60 6
	virtual int	OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	// deadlake PROXYSUPPORT
	virtual void	PacketReceived(Packet* packet) = 0;
	virtual void	OnError(int nErrorCode) = 0;
	virtual void	OnClose(int nErrorCode);
	virtual void	OnSend(int nErrorCode);	
	virtual void	OnReceive(int nErrorCode);
d64 1
a64 1
	// deadlake PROXYSUPPORT
d66 2
a67 1
	CAsyncProxySocketLayer* m_pProxyLayer;
d70 2
a71 2
	void	ClearQueues();	
	int		Send(char* lpBuf,int nBufLen,int nFlags = 0);
d74 18
a91 18
	// Download (pseudo) rate control	
	uint32	downloadLimit;
	bool	downloadLimitEnable;
	bool	pendingOnReceive;

	// Download partial header
	char*	pendingHeader[PACKET_HEADER_SIZE];      
	uint32	pendingHeaderSize;

	// Download partial packet
	Packet* pendingPacket;
	uint32  pendingPacketSize;

	// Upload control
	char*	sendbuffer;
	uint32	sendblen;
	uint32	sent;
	bool	m_bLinkedPackets;
d93 2
a94 2
	CTypedPtrList<CPtrList, Packet*> controlpacket_queue;
	CTypedPtrList<CPtrList, Packet*> standardpacket_queue;
@


1.6
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d28 6
a33 3
#define	ES_DISCONNECTED		0xFF
#define	ES_NOTCONNECTED		0x00
#define	ES_CONNECTED		0x01
d44 2
a45 2
	bool	IsConnected() const {return byConnected == ES_CONNECTED;}
	uint8	GetConState() const {return byConnected;}
d63 2
a64 1
	uint8	byConnected;
@


1.5
log
@Upgrade to 0.28a
@
text
@d91 1
a91 1
	CTypedPtrList<CPtrList, Packet*> standartpacket_queue;
@


1.4
log
@Proxy Support (deadlake)
@
text
@d22 2
a23 2
#include "AsyncSocketEx.h" // deadlake ( Maverick )
#include "AsyncProxySocketLayer.h" // deadlake ( Maverick )
d32 3
a34 2
class CEMSocket :
	public CAsyncSocketEx // deadlake
d40 3
a42 3
	bool	IsBusy()	{return sendbuffer;}
	bool	IsConnected()	{return byConnected == ES_CONNECTED;}
	uint8	GetConState()	{return byConnected;}
d47 2
a48 3
	// deadlake
	// By Maverick: Connection necessary initalizing calls are done
	// by class itself and not anymore by the Owner
a51 1
	// end deadlake
d54 3
a56 3
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	// deadlake ( Maverick )
	virtual void	PacketReceived(Packet* packet)		{}
	virtual void	OnError(int nErrorCode)				{}
d62 1
a62 1
	// deadlake ( Maverick )
d71 14
a84 5
	uint32	downloadlimit;
	bool	limitenabled;
	char*	readbuf;			// temporary fragmented packet buffer
	uint32	readbuf_size;
	char	header[6];
@


1.4.4.1
log
@27a partial merge
@
text
@d32 2
a33 3
#define PACKET_HEADER_SIZE	6

class CEMSocket : public CAsyncSocketEx // deadlake
d38 4
a41 5

	bool	SendPacket(Packet* packet, bool delpacket = true, bool controlpacket = true);// controlpackets have a higher priority
	bool	IsBusy() const {return sendbuffer;}
	bool	IsConnected() const {return byConnected == ES_CONNECTED;}
	uint8	GetConState() const {return byConnected;}
d56 2
a57 2
	virtual void	PacketReceived(Packet* packet) = 0;
	virtual void	OnError(int nErrorCode) = 0;
d72 5
a76 14
	// Download (pseudo) rate control	
	uint32	downloadLimit;
	bool	downloadLimitEnable;
	bool	pendingOnReceive;

	// Download partial header
	char*	pendingHeader[PACKET_HEADER_SIZE];      
	uint32	pendingHeaderSize;

	// Download partial packet
	Packet* pendingPacket;
	uint32  pendingPacketSize;

	// Upload control
@


1.3
log
@Merge from official sockets
@
text
@d22 2
d33 1
a33 1
	public CAsyncSocket
d45 9
d55 1
d62 4
@


1.3.6.1
log
@keeping in sync with the main cvs line
@
text
@a21 2
#include "AsyncSocketEx.h" // deadlake ( Maverick )
#include "AsyncProxySocketLayer.h" // deadlake ( Maverick )
d31 1
a31 1
	public CAsyncSocketEx // deadlake
a42 9

	// deadlake
	// By Maverick: Connection necessary initalizing calls are done
	// by class itself and not anymore by the Owner
	BOOL	virtual Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	// Reset Layer Chain
	virtual void CEMSocket::RemoveAllLayers();
	// end deadlake

a43 1
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	// deadlake ( Maverick )
a49 4

	// deadlake ( Maverick )
	bool	m_ProxyConnectFailed;
	CAsyncProxySocketLayer* m_pProxyLayer;
@


1.3.8.1
log
@Proxy support fixes from deadlake.
@
text
@a21 2
#include "AsyncSocketEx.h" // deadlake ( Maverick )
#include "AsyncProxySocketLayer.h" // deadlake ( Maverick )
d31 1
a31 1
	public CAsyncSocketEx // deadlake
a42 9

	// deadlake
	// By Maverick: Connection necessary initalizing calls are done
	// by class itself and not anymore by the Owner
	BOOL	virtual Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	// Reset Layer Chain
	virtual void CEMSocket::RemoveAllLayers();
	// end deadlake

a43 1
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	// deadlake ( Maverick )
a49 4

	// deadlake ( Maverick )
	bool	m_ProxyConnectFailed;
	CAsyncProxySocketLayer* m_pProxyLayer;
@


1.2
log
@*** empty log message ***
@
text
@a21 2
#include "AsyncSocketEx.h"
#include "AsyncProxySocketLayer.h"
a29 4
// By Maverick Added CEMSocketBaseClass 
// to make it easier to change BaseSocket
#define CEMSocketBaseClass CAsyncSocketEx

d31 1
a31 1
	public CEMSocketBaseClass
a42 6
	// By Maverick: Connection necessary initalizing calls are done
	// by class itself and not anymore by the Owner
	BOOL	virtual Connect(LPCTSTR lpszHostAddress, UINT nHostPort);

	// Reset Layer Chain
	virtual void CEMSocket::RemoveAllLayers();
a43 1
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	
d45 1
a45 1
	virtual void	OnError(int nErrorCode)	{}
a48 1

a49 4
	bool	m_ProxyConnectFailed;

	// By Maverick: used for proxy connection
	CAsyncProxySocketLayer* m_pProxyLayer;
d58 2
a59 4
	char*	readbuffer;
	uint32	dataneeded;
	uint32	datawaiting;
	Packet* receivedpacket;
a64 1

@


1.2.2.1
log
@official sockets
@
text
@d22 2
d32 4
d37 1
a37 1
	public CAsyncSocket
d49 6
d56 1
d58 1
a58 1
	virtual void	OnError(int nErrorCode)				{}
d62 1
d64 4
d76 4
a79 2
	char*	readbuf;			// temporary fragmented packet buffer
	uint32	readbuf_size;
d85 1
@


1.2.2.2
log
@Merges from main thread
@
text
@a29 4
// By Maverick Added CEMSocketBaseClass 
// to make it easier to change BaseSocket
#define CEMSocketBaseClass CAsyncSocket

d31 1
a31 1
	public CEMSocketBaseClass
@


1.2.2.3
log
@Restored obaldin's version. NO MERGE on these files!!!!!!!
@
text
@d30 4
d35 1
a35 1
	public CAsyncSocket
@


1.2.2.2.2.1
log
@Merged Proxy code
@
text
@a21 2
#include "AsyncSocketEx.h"
#include "AsyncProxySocketLayer.h"
d32 1
a32 1
#define CEMSocketBaseClass CAsyncSocketEx
a46 6
	// By Maverick: Connection necessary initalizing calls are done
	// by class itself and not anymore by the Owner
	BOOL	virtual Connect(LPCTSTR lpszHostAddress, UINT nHostPort);

	// Reset Layer Chain
	virtual void CEMSocket::RemoveAllLayers();
a47 1
	virtual int		OnLayerCallback(const CAsyncSocketExLayer *pLayer, int nType, int nParam1, int nParam2);	
a52 1

a53 4
	bool	m_ProxyConnectFailed;

	// By Maverick: used for proxy connection
	CAsyncProxySocketLayer* m_pProxyLayer;
@


1.1
log
@*** empty log message ***
@
text
@d22 2
d32 4
d37 1
a37 1
	public CAsyncSocket
d49 6
d56 1
d58 1
a58 1
	virtual void	OnError(int nErrorCode)				{}
d62 1
d64 4
d85 1
@

