head	1.4;
access;
symbols
	PublicRelease_1_2e:1.4
	Interim_Release_1-2e_RC1:1.4
	PublicRelease_1_2d:1.3
	Interim_Release_1-2d_RC1:1.3
	Interim_Release_1-2d_beta1:1.3
	PublicRelease_1_2c:1.3
	Interim_Release_1-2c_RC1:1.3
	Interim_Release_1-2c_beta1:1.3
	PublicRelease_1_2b:1.3
	Interim_Release_1-2b_RC1:1.3
	PublicRelease_1_2a:1.3
	Interim_Release_1-2a_RC1:1.3
	Interim_Release_1-2a_beta2:1.3
	Interim_Release_1-2a_beta1:1.3
	PublicRelease_1_2:1.3
	Interim_Release_1-2_RC1:1.3
	Interim_Release_1-2_beta1:1.2
	PublicRelease_1_1g:1.2
	Interim_Release_1-1g_RC3:1.2
	Interim_Release_1-1g_RC2:1.2
	Interim_Release_1-1g_RC1:1.2
	Interim_Release_1-1g_beta2:1.2
	Interim_Release_1-1g_beta1:1.2
	PublicRelease_1_1f:1.2
	Interim_Release_1-1f_RC1:1.2
	PublicRelease_1_1e:1.2
	Interim_Release_1-1e_RC2:1.2
	Interim_Release_1-1e_RC1:1.2
	Interim_Release_1-1e_beta1:1.2
	PublicRelease_1_1d:1.2
	Interim_Release_1-1d_RC1:1.2
	PublicRelease_1_1c:1.2
	Interim_Release_1-1c_RC1:1.2
	Interim_Release_1-1c_beta2:1.2
	Interim_Release_1-1c_beta1:1.2
	PublicRelease_1_1b:1.2
	Interim_Release_1-1b_RC1:1.2
	PublicRelease_1_1a:1.2
	Interim_Release_1-1a_RC2:1.2
	Interim_Release_1-1a_RC1:1.2
	Interim_Release_1-1a_beta2:1.2
	Interim_Release_1-1a_beta1:1.2
	PublicRelease_1_1:1.2
	Interim_Release_1-1_beta1:1.2
	PublicRelease_1o:1.2
	Interim_Release_1o_RC1:1.2
	Interim_Release_1o_beta1:1.2
	PublicRelease_1n:1.2
	Interim_Release_1n_RC2:1.2
	Interim_Release_1n_RC1:1.2
	Interim_Release_1n_beta2:1.2
	Interim_Release_1n_beta1:1.2
	PublicRelease_1m:1.2
	Interim_Release_1m_beta1:1.2
	PublicRelease_1l:1.2
	Interim_Release_1l_RC3:1.2
	Interim_Release_1l_RC2:1.2
	Interim_Release_1l_RC1:1.2
	Interim_Release_1l_beta2:1.2
	Interim_Release_1l_beta1:1.2
	PublicRelease_1k:1.2
	Interim_Release_1k_RC4:1.2
	Interim_1k_RC3:1.2
	Interim_1k_RC2:1.2
	Interim_Release_1k_RC1:1.2
	Interim_Release_1k_beta5:1.2
	Intrerim_Release_1k_beta4:1.2
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1
	PublicRelease_1g:1.1
	Interim_Release_1g_RC6_Final:1.1
	Interim_Release_1g_RC6:1.1
	Interim_Release_1g_RC5:1.1
	Interim_Release_1g_RC4:1.1
	Interim_Release_1g_RC3:1.1
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.14
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.12
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.10
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.8
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.6
	plus26based:1.1.0.4
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.2.1
	proxytest:1.1.2.1.0.2
	official_sockets:1.1.0.2;
locks; strict;
comment	@ * @;


1.4
date	2008.05.18.18.29.04;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.15.05.25.53;	author aw3;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.25.01.09.10;	author dongato;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.22.15.36.56;	author kuchin;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2003.01.28.16.53.57;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Suppressed compiler warnings.
@
text
@/*CAsyncProxySocketLayer by Tim Kosse (Tim.Kosse@@gmx.de)
                 Version 1.6 (2003-03-26)
--------------------------------------------------------

Introduction:
-------------

This class is layer class for CAsyncSocketEx. With this class you
can connect through SOCKS4/5 and HTTP 1.1 proxies. This class works 
as semi-transparent layer between CAsyncSocketEx and the actual socket.
This class is used in FileZilla, a powerful open-source FTP client.
It can be found under http://sourceforge.net/projects/filezilla
For more information about SOCKS4/5 goto 
http://www.socks.nec.com/socksprot.html
For more information about HTTP 1.1 goto http://www.rfc-editor.org
and search for RFC2616

How to use?
-----------

You don't have to change much in you already existing code to use
CAsyncProxySocketLayer.

To use it, create an instance of CAsyncProxySocketLayer, call SetProxy
and attach it to a CAsyncSocketEx instance.

You have to process OnLayerCallback in you CAsyncSocketEx instance as it will
receive all layer nofications.

The following notifications are sent:

//Error codes
PROXYERROR_NOERROR			0
PROXYERROR_NOCONN			1 //Can't connect to proxy server, use GetLastError for more information
PROXYERROR_REQUESTFAILED	2 //Request failed, can't send data
PROXYERROR_AUTHREQUIRED		3 //Authentication required
PROXYERROR_AUTHTYPEUNKNOWN	4 //Authtype unknown or not supported
PROXYERROR_AUTHFAILED		5 //Authentication failed
PROXYERROR_AUTHNOLOGON		6
PROXYERROR_CANTRESOLVEHOST	7

//Status messages
PROXYSTATUS_LISTENSOCKETCREATED 8	//Called when a listen socket was created successfully. Unlike the normal listen function,
									//a socksified socket has to connect to the proxy to negotiate the details with the server
									//on which the listen socket will be created
									//The two parameters will contain the ip and port of the listen socket on the server.

If you want to use CAsyncProxySocketLayer to create a listen socket, you
have to use this overloaded function:
BOOL PrepareListen(unsigned long serverIp);
serverIP is the IP of the server you are already connected 
through the SOCKS proxy. You can't use listen sockets over a
SOCKS proxy without a primary connection. Listen sockets are only 
supported by SOCKS proxies, this won't work with HTTP proxies.
When the listen socket is created successfully, the PROXYSTATUS_LISTENSOCKETCREATED
notification is sent. The parameters  will tell you the ip and the port of the listen socket.
After it you have to handle the OnAccept message and accept the 
connection.
Be carful when calling Accept: rConnected socket will NOT be filled! Instead use the instance which created the
listen socket, it will handle the data connection.
If you want to accept more than one connection, you have to create a listing socket for each of them!

Description of important functions and their parameters:
--------------------------------------------------------

void SetProxy(int nProxyType);
void SetProxy(int nProxyType, const char * ProxyHost, int nProxyPort);
void SetProxy(int nProxyType, const char *, int nProxyPort, const char * ProxyUser, const char * ProxyPass);
	
Call one of this functions to set the proxy type.
Parametes:
- nProxyType specifies the Proxy Type.
- ProxyHost and nProxyPort specify the address of the proxy
- ProxyUser and ProxyPass are only available for SOCKS5 proxies.

supported proxy types:
PROXYTYPE_NOPROXY
PROXYTYPE_SOCKS4
PROXYTYPE_SOCKS4A
PROXYTYPE_SOCKS5
PROXYTYPE_HTTP11

There are also some other functions:

GetProxyPeerName
Like GetPeerName of CAsyncSocket, but returns the address of the
server connected through the proxy.	If using proxies, GetPeerName 
only returns the address of the proxy.

int GetProxyType();
Returns the used proxy

const int GetLastProxyError() const;
Returns the last proxy error

License
-------

Feel free to use this class, as long as you don't claim that you wrote it
and this copyright notice stays intact in the source files.
If you use this class in commercial applications, please send a short message
to tim.kosse@@gmx.de


Version history
---------------

- 1.6 got rid of MFC
- 1.5 released CAsyncSocketExLayer version
- 1.4 added Unicode support
- 1.3 added basic HTTP1.1 authentication
      fixed memory leak in SOCKS5 code
	  OnSocksOperationFailed will be called after Socket has been closed
      fixed some minor bugs
- 1.2 renamed into CAsyncProxySocketLayer
      added HTTP1.1 proxy support
- 1.1 fixes all known bugs, mostly with SOCKS5 authentication
- 1.0 initial release
*/
#pragma once

#include "AsyncSocketExLayer.h"

class CAsyncProxySocketLayer : public CAsyncSocketExLayer  
{
// Attribute
public:

// Operationen
public:
	CAsyncProxySocketLayer();
	virtual ~CAsyncProxySocketLayer();
	
public:
	virtual void Close();
	virtual BOOL Connect(LPCSTR lpHostAddress, UINT nHostPort);
	virtual BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual BOOL Listen(int nConnectionBacklog);
	
	void SetProxy(int nProxyType); //Only PROXYTYPE_NOPROXY
	void SetProxy(int nProxyType, const CStringA& strProxyHost, int ProxyPort); //May not be PROXYTYPE_NOPROXY
	void SetProxy(int nProxyType, const CStringA& strProxyHost, int ProxyPort, const CStringA& strProxyUser, const CStringA& strProxyPass); //Only SOCKS5 and HTTP1.1 proxies
	//Sets the proxy details. 
	//nProxyType - Type of the proxy. May be PROXYTYPE_NONE, PROXYTYPE_SOCKS4, PROXYTYPE_SOCKS5 or PROXYTYPE_HTTP11
	//ProxyHost - The address of the proxy. Can be either IP or URL
	//ProxyPort - The port of the proxy
	//ProxyUser - the username for SOCKS5 proxies
	//ProxyPass - the password for SOCKS5 proxies

	//Prepare listen
	BOOL PrepareListen(unsigned long ip);
	
	//Returns the type of the proxy
	int GetProxyType() const;

#ifdef _AFX
	virtual BOOL GetPeerName(CString& rPeerAddress, UINT& rPeerPort);
#endif
	virtual BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);
	
// Implementierung
protected:
	virtual BOOL Accept(CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual int Send(const void* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Receive(void* lpBuf, int nBufLen, int nFlags = 0);

	//Notification event handlers
	virtual void OnConnect(int nErrorCode);
	virtual void OnReceive(int nErrorCode);

private:
	void Reset();
	void ClearBuffer();		 //Clears the receive buffer

	char *m_pRecvBuffer;	 //The receive buffer
	int m_nRecvBufferPos;	 //Position within the receive buffer

	char *m_pStrBuffer;		//Recvbuffer needed by HTTP1.1 proxy

	int m_nProxyOpState;	 //State of an operation
	int m_nProxyOpID;		 //Currently active operation (0 if none)
	uint16 m_uProxyPeerPort; //Port of the server you are connected to, retrieve via GetPeerName
	ULONG m_nProxyPeerIP;	 //IP of the server you are connected to, retrieve via GetPeerName
	typedef struct
	{
		int			nProxyType;
		CStringA	strProxyHost;
		int			nProxyPort;
		CStringA	strProxyUser;
		CStringA	strProxyPass;
		bool		bUseLogon;
	} t_proxydata;			//This structure will be used to hold the proxy details
	t_proxydata m_ProxyData;//Structure to hold the data set by SetProxy
	LPSTR m_pProxyPeerHost;	//The host connected to
};

//Errorcodes
#define PROXYERROR_NOERROR			0
#define PROXYERROR_NOCONN			1 //Can't connect to proxy server, use GetLastError for more information
#define PROXYERROR_REQUESTFAILED	2 //Request failed, can't send data
#define PROXYERROR_AUTHREQUIRED		3 //Authentication required
#define PROXYERROR_AUTHTYPEUNKNOWN	4 //Authtype unknown or not supported
#define PROXYERROR_AUTHFAILED		5  //Authentication failed
#define PROXYERROR_AUTHNOLOGON		6
#define PROXYERROR_CANTRESOLVEHOST	7

//Status messages
#define PROXYSTATUS_LISTENSOCKETCREATED 8	//Called when a listen socket was created successfully. Unlike the normal listen function,
											//a socksified socket has to connect to the proxy to negotiate the details with the server
											//on which the listen socket will be created
											//The two parameters will contain the ip and port of the listen socket on the server.

CString GetProxyError(UINT nError);

struct t_ListenSocketCreatedStruct
{
	unsigned long ip;
	UINT nPort;
};

//Proxytypes
#define PROXYTYPE_NOPROXY	0
#define PROXYTYPE_SOCKS4	1
#define PROXYTYPE_SOCKS4A	2
#define PROXYTYPE_SOCKS5	3
#define PROXYTYPE_HTTP11	4

#define PROXYOP_CONNECT		1
#define PROXYOP_BIND		2
@


1.3
log
@Update socket layer code from original (formatting and minor changes);
Corrected Unicode issues.
@
text
@d182 1
a182 1
	int m_nProxyPeerPort;	 //Port of the server you are connected to, retrieve via GetPeerName
@


1.2
log
@Empy Incoming dir for category fix, Official fix [Katsyonak], WS templates updated for file status icons.
@
text
@d23 1
d26 1
d29 1
d33 8
a40 8
PROXYERROR_NOERROR 0
PROXYERROR_NOCONN 1 //Can't connect to proxy server, use GetLastError for more information
PROXYERROR_REQUESTFAILED 2 //Request failed, can't send data
PROXYERROR_AUTHREQUIRED 3 //Authentication required
PROXYERROR_AUTHTYPEUNKNOWN 4 //Authtype unknown or not supported
PROXYERROR_AUTHFAILED 5  //Authentication failed
PROXYERROR_AUTHNOLOGON 6
PROXYERROR_CANTRESOLVEHOST 7
d43 4
a46 4
PROXYSTATUS_LISTENSOCKETCREATED 8 //Called when a listen socket was created successfully. Unlike the normal listen function,
								//a socksified socket has to connect to the proxy to negotiate the details with the server
								//on which the listen socket will be created
								//The two parameters will contain the ip and port of the listen socket on the server.
d110 1
a110 1
- 1.4 added UNICODE support
a119 5

#if !defined(AFX_ASYNCPROXYSOCKETLAYER_H__6B19D281_F1D0_4EF2_984A_31639A038AE5__INCLUDED_)
#define AFX_ASYNCPROXYSOCKETLAYER_H__6B19D281_F1D0_4EF2_984A_31639A038AE5__INCLUDED_

#if _MSC_VER > 1000
a120 1
#endif // _MSC_VER > 1000
a122 1
#include "opcodes.h"
a133 2

// Überschreibungen
d136 3
a138 3
	virtual BOOL Connect( LPCTSTR lpHostAddress, UINT nHostPort );
	virtual BOOL Connect( const SOCKADDR* lpSockAddr, int nSockAddrLen );
	virtual BOOL Listen( int nConnectionBacklog);
d141 2
a142 2
	void SetProxy(int nProxyType, const char * pProxyHost, int ProxyPort); //May not be PROXYTYPE_NOPROXY
	void SetProxy(int nProxyType, const char * pProxyHost, int ProxyPort, const char * pProxyUser, const char * pProxyPass); //Only SOCKS5 and HTTP1.1 proxies
d153 1
a154 1
	//Returns the type of the proxy
d157 1
a157 1
	virtual BOOL GetPeerName( CString& rPeerAddress, UINT& rPeerPort );
d159 1
a159 5
	virtual BOOL GetPeerName( SOCKADDR* lpSockAddr, int* lpSockAddrLen );
	

	//Returns the address of the server behind the SOCKS proxy you are connected to
	
d163 1
a163 3
	virtual BOOL Accept( CAsyncSocketEx& rConnectedSocket, SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL );
	virtual void OnReceive(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
d167 4
d174 1
a175 1
	int m_nRecvBufferLen;	 //Length of the RecvBuffer
d177 1
d179 1
d183 1
a183 1
	ULONG m_nProxyPeerIp;	 //IP of the server you are connected to, retrieve via GetPeerName
d186 9
a194 10
		int nProxyType;
		LPTSTR pProxyHost;
		int nProxyPort;
		char * pProxyUser;
		char * pProxyPass;
		BOOL bUseLogon;
	} t_proxydata; //This structure will be used to hold the proxy details

	t_proxydata m_ProxyData; //Structure to hold the data set by SetProxy
	LPTSTR m_pProxyPeerHost; //The host connected to
d198 8
a205 8
#define PROXYERROR_NOERROR 0
#define PROXYERROR_NOCONN 1 //Can't connect to proxy server, use GetLastError for more information
#define PROXYERROR_REQUESTFAILED 2 //Request failed, can't send data
#define PROXYERROR_AUTHREQUIRED 3 //Authentication required
#define PROXYERROR_AUTHTYPEUNKNOWN 4 //Authtype unknown or not supported
#define PROXYERROR_AUTHFAILED 5  //Authentication failed
#define PROXYERROR_AUTHNOLOGON 6
#define PROXYERROR_CANTRESOLVEHOST 7
d208 4
a211 4
#define PROXYSTATUS_LISTENSOCKETCREATED 8 //Called when a listen socket was created successfully. Unlike the normal listen function,
										//a socksified socket has to connect to the proxy to negotiate the details with the server
										//on which the listen socket will be created
										//The two parameters will contain the ip and port of the listen socket on the server.
d222 5
a226 9
#define PROXYTYPE_NOPROXY 0
#define PROXYTYPE_SOCKS4 1
#define PROXYTYPE_SOCKS4A 2
#define PROXYTYPE_SOCKS5 3
#define PROXYTYPE_HTTP11 4

#define PROXYOP_CONNECT 1
#define PROXYOP_LISTEN 2

d228 2
a229 1
#endif // !defined(AFX_ASYNCPROXYSOCKETLAYER_H__6B19D281_F1D0_4EF2_984A_31639A038AE5__INCLUDED_)
@


1.1
log
@Maverick's proxy support
@
text
@d2 1
a2 1
                 Version 1.5 (2002-11-01)
d64 2
a65 2
void SetProxy(int nProxyType, CString ProxyHost, int nProxyPort);
void SetProxy(int nProxyType, CString ProxyHost, int nProxyPort,CString ProxyUser, CString ProxyPass);
d93 9
d105 1
d142 1
a142 1
	virtual BOOL Connect( LPCTSTR lpszHostAddress, UINT nHostPort );
d147 2
a148 2
	void SetProxy(int nProxyType, CString ProxyHost, int ProxyPort); //May not be PROXYTYPE_NOPROXY
	void SetProxy(int nProxyType, CString ProxyHost, int ProxyPort, CString ProxyUser, CString ProxyPass); //Only SOCKS5 and HTTP1.1 proxies
a163 1
	virtual BOOL GetPeerName( ULONG& rPeerIP, UINT& rPeerPort );
d185 1
a185 1
	CString m_strBuffer;	 //Recvbuffer needed by HTTP1.1 proxy
d193 1
a193 1
		CString ProxyHost;
d195 2
a196 1
		CString ProxyUser,ProxyPass;
d201 1
a201 1
	CString m_ProxyPeerHost; //The host connected to
d219 3
d228 6
@


1.1.2.1
log
@updating this branch...
@
text
@@

