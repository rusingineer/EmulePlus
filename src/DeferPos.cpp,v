head	1.1;
access;
symbols
	PublicRelease_1_2e:1.1
	Interim_Release_1-2e_RC1:1.1
	PublicRelease_1_2d:1.1
	Interim_Release_1-2d_RC1:1.1
	Interim_Release_1-2d_beta1:1.1
	PublicRelease_1_2c:1.1
	Interim_Release_1-2c_RC1:1.1
	Interim_Release_1-2c_beta1:1.1
	PublicRelease_1_2b:1.1
	Interim_Release_1-2b_RC1:1.1
	PublicRelease_1_2a:1.1
	Interim_Release_1-2a_RC1:1.1
	Interim_Release_1-2a_beta2:1.1
	Interim_Release_1-2a_beta1:1.1
	PublicRelease_1_2:1.1
	Interim_Release_1-2_RC1:1.1
	Interim_Release_1-2_beta1:1.1
	PublicRelease_1_1g:1.1
	Interim_Release_1-1g_RC3:1.1
	Interim_Release_1-1g_RC2:1.1
	Interim_Release_1-1g_RC1:1.1
	Interim_Release_1-1g_beta2:1.1
	Interim_Release_1-1g_beta1:1.1
	PublicRelease_1_1f:1.1
	Interim_Release_1-1f_RC1:1.1
	PublicRelease_1_1e:1.1
	Interim_Release_1-1e_RC2:1.1
	Interim_Release_1-1e_RC1:1.1
	Interim_Release_1-1e_beta1:1.1
	PublicRelease_1_1d:1.1
	Interim_Release_1-1d_RC1:1.1
	PublicRelease_1_1c:1.1
	Interim_Release_1-1c_RC1:1.1
	Interim_Release_1-1c_beta2:1.1
	Interim_Release_1-1c_beta1:1.1
	PublicRelease_1_1b:1.1
	Interim_Release_1-1b_RC1:1.1
	PublicRelease_1_1a:1.1
	Interim_Release_1-1a_RC2:1.1
	Interim_Release_1-1a_RC1:1.1
	Interim_Release_1-1a_beta2:1.1
	Interim_Release_1-1a_beta1:1.1
	PublicRelease_1_1:1.1
	Interim_Release_1-1_beta1:1.1
	PublicRelease_1o:1.1
	Interim_Release_1o_RC1:1.1
	Interim_Release_1o_beta1:1.1
	PublicRelease_1n:1.1
	Interim_Release_1n_RC2:1.1
	Interim_Release_1n_RC1:1.1
	Interim_Release_1n_beta2:1.1
	Interim_Release_1n_beta1:1.1
	PublicRelease_1m:1.1
	Interim_Release_1m_beta1:1.1
	PublicRelease_1l:1.1
	Interim_Release_1l_RC3:1.1
	Interim_Release_1l_RC2:1.1
	Interim_Release_1l_RC1:1.1
	Interim_Release_1l_beta2:1.1
	Interim_Release_1l_beta1:1.1
	PublicRelease_1k:1.1
	Interim_Release_1k_RC4:1.1
	Interim_1k_RC3:1.1
	Interim_1k_RC2:1.1
	Interim_Release_1k_RC1:1.1
	Interim_Release_1k_beta5:1.1
	Intrerim_Release_1k_beta4:1.1
	Interim_Release_1k_beta1:1.1
	PublicRelease_1j:1.1
	Interim_Release_1J_RC3:1.1
	Interim_Release_1j_RC3:1.1
	Interim_Release_1j_RC2:1.1
	Interim_Release_1j_RC1:1.1
	Interim_Release_1j_beta2:1.1
	Interim_Release_1j_beta1:1.1
	PublicRelease_1i:1.1
	Interim_Release_1i_RC6:1.1
	Interim_Release_1i_RC3:1.1
	Interim_Release_1i_RC2:1.1
	Interim_Release_1i_RC1:1.1
	Interim_Release_1i_beta3:1.1
	Interim_Release_1i_beta2:1.1
	Interim_Release_1i_beta1:1.1
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1;
locks; strict;
comment	@// @;


1.1
date	2003.08.23.00.20.51;	author forcha;	state Exp;
branches;
next	;


desc
@@


1.1
log
@*** empty log message ***
@
text
@#include "stdafx.h"
#include "DeferPos.h"

// Constructor
// This sets up the RAIA idiom by calling BeginDeferWindowPos. The number of windows
// can be passed as an argument to optimize memory management, although the API will
// grow the memory if needed at run time.

CDeferPos::CDeferPos(int nWindows)
{
	m_hdwp = BeginDeferWindowPos(nWindows);
}

// Destructor
// This concludes the RAIA idiom by ensuring EndDeferWindowPos is called.

CDeferPos::~CDeferPos()
{
	EndDeferWindowPos(m_hdwp);
}

// MoveWindow
// Emulates a call to ::MoveWindow but the actual call is delayed until
// the CDeferPos object is destroyed.  All delayed window positions are
// then done "at once", which can reduce flicker.

BOOL CDeferPos::MoveWindow(HWND hWnd, int x, int y, int nWidth, int nHeight,
						  BOOL bRepaint)
{
	UINT uFlags = SWP_NOACTIVATE|SWP_NOOWNERZORDER|SWP_NOZORDER;
	if (!bRepaint)
		uFlags |= SWP_NOREDRAW;
	return SetWindowPos(hWnd, 0, x, y, nWidth, nHeight, uFlags);
}

// SetWindowPos
// Emulates a call to ::SetWindowPos but the actual call is delayed until
// the CDeferPos object is destroyed.  All delayed window positions are
// then done "at once", which can reduce flicker.

BOOL CDeferPos::SetWindowPos(HWND hWnd, HWND hWndAfter, int x, int y, int nWidth,
							int nHeight, UINT uFlags)
{
	if (m_hdwp != 0)
	{
		m_hdwp = DeferWindowPos(m_hdwp, hWnd, hWndAfter, x, y, nWidth, nHeight,
			uFlags);
	}
	return m_hdwp != 0;
}

// MFC versions of the above.

#ifdef	_MFC_VER
BOOL CDeferPos::MoveWindow(CWnd* pWnd, int x, int y, int nWidth, int nHeight,
						   BOOL bRepaint)
{
	return MoveWindow(pWnd->GetSafeHwnd(), x, y, nWidth, nHeight, bRepaint);
}

BOOL CDeferPos::SetWindowPos(CWnd* pWnd, CWnd* pWndAfter, int x, int y, int nWidth,
							 int nHeight, UINT uFlags)
{
	return SetWindowPos(pWnd->GetSafeHwnd(), pWndAfter->GetSafeHwnd(), x, y, nWidth,
		nHeight, uFlags);
}
#endif
@
