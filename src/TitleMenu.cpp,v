head	1.7;
access;
symbols
	PublicRelease_1_2e:1.7
	Interim_Release_1-2e_RC1:1.7
	PublicRelease_1_2d:1.7
	Interim_Release_1-2d_RC1:1.7
	Interim_Release_1-2d_beta1:1.7
	PublicRelease_1_2c:1.6
	Interim_Release_1-2c_RC1:1.6
	Interim_Release_1-2c_beta1:1.4
	PublicRelease_1_2b:1.4
	Interim_Release_1-2b_RC1:1.4
	PublicRelease_1_2a:1.4
	Interim_Release_1-2a_RC1:1.4
	Interim_Release_1-2a_beta2:1.4
	Interim_Release_1-2a_beta1:1.4
	PublicRelease_1_2:1.4
	Interim_Release_1-2_RC1:1.4
	Interim_Release_1-2_beta1:1.4
	PublicRelease_1_1g:1.4
	Interim_Release_1-1g_RC3:1.4
	Interim_Release_1-1g_RC2:1.4
	Interim_Release_1-1g_RC1:1.4
	Interim_Release_1-1g_beta2:1.4
	Interim_Release_1-1g_beta1:1.4
	PublicRelease_1_1f:1.4
	Interim_Release_1-1f_RC1:1.4
	PublicRelease_1_1e:1.4
	Interim_Release_1-1e_RC2:1.4
	Interim_Release_1-1e_RC1:1.4
	Interim_Release_1-1e_beta1:1.4
	PublicRelease_1_1d:1.4
	Interim_Release_1-1d_RC1:1.4
	PublicRelease_1_1c:1.4
	Interim_Release_1-1c_RC1:1.4
	Interim_Release_1-1c_beta2:1.4
	Interim_Release_1-1c_beta1:1.4
	PublicRelease_1_1b:1.4
	Interim_Release_1-1b_RC1:1.4
	PublicRelease_1_1a:1.4
	Interim_Release_1-1a_RC2:1.4
	Interim_Release_1-1a_RC1:1.4
	Interim_Release_1-1a_beta2:1.4
	Interim_Release_1-1a_beta1:1.4
	PublicRelease_1_1:1.4
	Interim_Release_1-1_beta1:1.4
	PublicRelease_1o:1.4
	Interim_Release_1o_RC1:1.4
	Interim_Release_1o_beta1:1.4
	PublicRelease_1n:1.4
	Interim_Release_1n_RC2:1.4
	Interim_Release_1n_RC1:1.4
	Interim_Release_1n_beta2:1.4
	Interim_Release_1n_beta1:1.4
	PublicRelease_1m:1.4
	Interim_Release_1m_beta1:1.4
	PublicRelease_1l:1.4
	Interim_Release_1l_RC3:1.4
	Interim_Release_1l_RC2:1.4
	Interim_Release_1l_RC1:1.4
	Interim_Release_1l_beta2:1.4
	Interim_Release_1l_beta1:1.3
	PublicRelease_1k:1.3
	Interim_Release_1k_RC4:1.3
	Interim_1k_RC3:1.3
	Interim_1k_RC2:1.3
	Interim_Release_1k_RC1:1.3
	Interim_Release_1k_beta5:1.3
	Intrerim_Release_1k_beta4:1.3
	Interim_Release_1k_beta1:1.2
	PublicRelease_1j:1.2
	Interim_Release_1J_RC3:1.2
	Interim_Release_1j_RC3:1.2
	Interim_Release_1j_RC2:1.2
	Interim_Release_1j_RC1:1.2
	Interim_Release_1j_beta2:1.2
	Interim_Release_1j_beta1:1.2
	PublicRelease_1i:1.2
	Interim_Release_1i_RC6:1.2
	Interim_Release_1i_RC3:1.2
	Interim_Release_1i_RC2:1.2
	Interim_Release_1i_RC1:1.2
	Interim_Release_1i_beta3:1.2
	Interim_Release_1i_beta2:1.2
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.2
	Interim_Release_1h_rc2:1.2
	Interim_Release_1h_RC1:1.2
	Interim_Release_1h_beta2:1.2
	Interim_Release_1h_beta1_now:1.2
	Interim_Release_1h_beta1:1.2
	PublicRelease_1g:1.2
	Interim_Release_1g_RC6_Final:1.2
	Interim_Release_1g_RC6:1.2
	Interim_Release_1g_RC5:1.2
	Interim_Release_1g_RC4:1.2
	Interim_Release_1g_RC3:1.2
	Interim_Release_1g_beta2:1.1
	Interim_Release_1g_beta1:1.1
	Interim_Release_1f_RC4:1.1
	Interim_Release_1f_RC3:1.1
	Interim_Release_1f_RC2:1.1
	Interim_Release_1f_RC:1.1
	Interim_Release_1f_beta2:1.1
	Interim_Release_1f_beta1:1.1
	PublicRelease_1e:1.1
	Interim_Release_1e_RC2:1.1
	Interim_Release_1e_RC:1.1
	Interim_Release_1e_beta3:1.1
	Interim_Release_1e_beta2:1.1
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.16
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.14
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.12
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.10
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1
	Interim_Release_26b_i0d:1.1
	Interim_Release_26b_i0c:1.1
	Interim_Release_26b_i0b:1.1
	Interim_Release_26b_i0a:1.1
	systraydlg:1.1.0.8
	plus26based:1.1.0.6
	Interim_Release_25b_i0b:1.1
	Proxy_Dev:1.1
	Interim_Release_25b_i0a:1.1.4.1
	proxytest:1.1.4.1.0.2
	official_sockets:1.1.0.4
	eMulePlus_024b_5b:1.1.0.2;
locks; strict;
comment	@// @;


1.7
date	2007.11.03.09.46.20;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2007.07.08.00.15.48;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.27.03.18.15;	author aw3;	state Exp;
branches;
next	1.4;

1.4
date	2004.05.16.06.08.41;	author aw3;	state Exp;
branches;
next	1.3;

1.3
date	2004.02.23.03.22.23;	author aw3;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.15.13.41.14;	author partyckip;	state Exp;
branches;
next	1.1;

1.1
date	2003.01.21.18.21.24;	author cax2;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.01.28.16.54.32;	author cax2;	state Exp;
branches;
next	;


desc
@@


1.7
log
@change the ANSI font to DEFAULT_GUI
@
text
@//this file is part of eMule
//Copyright (C)2002-2007 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#include "TitleMenu.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////
CTitleMenu::CTitleMenu()
{
	HFONT hfont = CreatePopupMenuTitleFont();
	ASSERT(hfont);
	m_Font.Attach(hfont);
	clLeft=::GetSysColor(COLOR_ACTIVECAPTION);
	clRight=::GetSysColor(27);  //COLOR_GRADIENTACTIVECAPTION
	clText=::GetSysColor(COLOR_CAPTIONTEXT);
	
	hinst_msimg32 = LoadLibrary(_T("msimg32.dll"));
	m_bCanDoGradientFill = FALSE;
	
	if(hinst_msimg32)
	{
		m_bCanDoGradientFill = TRUE;
		dllfunc_GradientFill = ((LPFNDLLFUNC1) GetProcAddress( hinst_msimg32, "GradientFill" ));
	}
	bDrawEdge=false;
	flag_edge=BDR_SUNKENINNER;
}

CTitleMenu::~CTitleMenu()
{
	m_Font.DeleteObject();
	FreeLibrary( hinst_msimg32 );
}



/////////////////////////////////////////////////////////////////////////////
// CTitleMenu message handlers

HFONT CTitleMenu::CreatePopupMenuTitleFont()
{
	// start by getting the stock menu font
	HFONT hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
	if (hfont)
	{ 
		LOGFONT lf; //get the complete LOGFONT describing this font
		if (GetObject(hfont, sizeof(LOGFONT), &lf))
		{
			lf.lfWeight = FW_BOLD;	// set the weight to bold
			// recreate this font with just the weight changed
			return ::CreateFontIndirect(&lf);
		}
	}
	return NULL;
}


//
// This function adds a title entry to a popup menu
//
void CTitleMenu::AddMenuTitle(CString strTitle)
{
	// insert an empty owner-draw item at top to serve as the title
	// note: item is not selectable (disabled) but not grayed
	m_strTitle = strTitle;
	InsertMenu(0, MF_BYPOSITION | MF_OWNERDRAW | MF_STRING | MF_DISABLED, 0);
}


void CTitleMenu::MeasureItem(LPMEASUREITEMSTRUCT mi)
{
	// get the screen dc to use for retrieving size information
	CDC dc;
	dc.Attach(::GetDC(HWND_DESKTOP));
	// select the title font
	HFONT hfontOld = (HFONT)SelectObject(dc.m_hDC, (HFONT)m_Font);
	// compute the size of the title
	CSize size = dc.GetTextExtent(m_strTitle);
	// deselect the title font
	::SelectObject(dc.m_hDC, hfontOld);
	// add in the left margin for the menu item
	size.cx += GetSystemMetrics(SM_CXMENUCHECK)+8;


	//Return the width and height
	//+ include space for border
	const int nBorderSize = 2;
	mi->itemWidth = size.cx + nBorderSize;
	mi->itemHeight = size.cy + nBorderSize;

	// cleanup
	::ReleaseDC(NULL, dc.Detach());
}


void CTitleMenu::DrawItem(LPDRAWITEMSTRUCT di)
{
	COLORREF crOldBk = ::SetBkColor(di->hDC, clLeft);

	if(m_bCanDoGradientFill&&(clLeft!=clRight))
	{
		TRIVERTEX rcVertex[2];
		di->rcItem.right--; // exclude this point, like FillRect does 
		di->rcItem.bottom--;
		rcVertex[0].x=di->rcItem.left;
		rcVertex[0].y=di->rcItem.top;
		rcVertex[0].Red=GetRValue(clLeft)<<8;	// color values from 0x0000 to 0xff00 !!!!
		rcVertex[0].Green=GetGValue(clLeft)<<8;
		rcVertex[0].Blue=GetBValue(clLeft)<<8;
		rcVertex[0].Alpha=0x0000;
		rcVertex[1].x=di->rcItem.right; 
		rcVertex[1].y=di->rcItem.bottom;
		rcVertex[1].Red=GetRValue(clRight)<<8;
		rcVertex[1].Green=GetGValue(clRight)<<8;
		rcVertex[1].Blue=GetBValue(clRight)<<8;
		rcVertex[1].Alpha=0;
		GRADIENT_RECT rect;
		rect.UpperLeft=0;
		rect.LowerRight=1;

		// fill the area
		GradientFill( di->hDC,rcVertex,2,&rect,1,GRADIENT_FILL_RECT_H);
	}
	else
	{
		::ExtTextOut(di->hDC, 0, 0, ETO_OPAQUE, &di->rcItem, NULL, 0, NULL);
	}
	if(bDrawEdge)
		::DrawEdge(di->hDC, &di->rcItem, flag_edge, BF_RECT);


	int modeOld = ::SetBkMode(di->hDC, TRANSPARENT);
	COLORREF crOld = ::SetTextColor(di->hDC, clText);
	// select font into the dc
	HFONT hfontOld = (HFONT)SelectObject(di->hDC, (HFONT)m_Font);

	// add the menu margin offset
	di->rcItem.left += GetSystemMetrics(SM_CXMENUCHECK) + 8;

	// draw the text left aligned and vertically centered
	::DrawText(di->hDC, m_strTitle, m_strTitle.GetLength(), &di->rcItem, DT_SINGLELINE|DT_VCENTER|DT_LEFT|DT_NOPREFIX|DT_NOCLIP);

	//Restore font and colors...
	::SelectObject(di->hDC, hfontOld);
	::SetBkMode(di->hDC, modeOld);
	::SetBkColor(di->hDC, crOldBk);
	::SetTextColor(di->hDC, crOld);
}


BOOL CTitleMenu::GradientFill(HDC hdc, PTRIVERTEX pVertex, DWORD dwNumVertex, PVOID pMesh, DWORD dwNumMesh, DWORD dwMode)
{
	ASSERT(m_bCanDoGradientFill); 
	return dllfunc_GradientFill(hdc,pVertex,dwNumVertex,pMesh,dwNumMesh,dwMode); 
}
@


1.6
log
@Optimized DrawText -- no need recalculate string length.
@
text
@d65 1
a65 1
	HFONT hfont = (HFONT)GetStockObject(ANSI_VAR_FONT);
@


1.5
log
@Some clean-up.
@
text
@d160 1
a160 1
	di->rcItem.left += GetSystemMetrics(SM_CXMENUCHECK)+8;
d163 1
a163 1
	::DrawText(di->hDC, m_strTitle, -1, &di->rcItem, DT_SINGLELINE|DT_VCENTER|DT_LEFT|DT_NOPREFIX|DT_NOCLIP);
@


1.4
log
@Correctly display '&' in context menu title (if it is required in future).
@
text
@d1 2
a2 1
// TitleMenu.cpp: implementation of the CTitleMenu class.
d4 13
a16 1
//////////////////////////////////////////////////////////////////////
d39 1
a39 1
	hinst_msimg32 = LoadLibrary( _T("msimg32.dll") );
d44 1
a44 1
		m_bCanDoGradientFill = TRUE;		
d66 1
a66 1
	if (hfont) 
d68 2
a69 2
	    LOGFONT lf; //get the complete LOGFONT describing this font
	    if (GetObject(hfont, sizeof(LOGFONT), &lf)) 
d96 1
a96 1
	dc.Attach(::GetDC(NULL));
d112 1
a112 1
	
d121 1
a121 1
	
d124 1
a124 1
 		TRIVERTEX rcVertex[2];
d142 2
a143 2
		
		// fill the area 
d152 1
a152 1
 
@


1.3
log
@Improved context menu creation
@
text
@a45 1

a48 1

a78 1

d150 1
a150 1
	::DrawText(di->hDC, m_strTitle, -1, &di->rcItem, DT_SINGLELINE|DT_VCENTER|DT_LEFT);
@


1.2
log
@unicode cleanup
@
text
@d72 1
a72 1
void CTitleMenu::AddMenuTitle(LPCTSTR lpszTitle)
d76 1
a76 1
	m_strTitle=CString(lpszTitle);
@


1.1
log
@*** empty log message ***
@
text
@d26 1
a26 1
	hinst_msimg32 = LoadLibrary( "msimg32.dll" );
@


1.1.4.1
log
@updating this branch...
@
text
@@

