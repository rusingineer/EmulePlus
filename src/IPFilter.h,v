head	1.21;
access;
symbols
	PublicRelease_1_2e:1.21
	Interim_Release_1-2e_RC1:1.21
	PublicRelease_1_2d:1.17
	Interim_Release_1-2d_RC1:1.17
	Interim_Release_1-2d_beta1:1.16
	PublicRelease_1_2c:1.16
	Interim_Release_1-2c_RC1:1.16
	Interim_Release_1-2c_beta1:1.16
	PublicRelease_1_2b:1.16
	Interim_Release_1-2b_RC1:1.16
	PublicRelease_1_2a:1.15
	Interim_Release_1-2a_RC1:1.15
	Interim_Release_1-2a_beta2:1.15
	Interim_Release_1-2a_beta1:1.15
	PublicRelease_1_2:1.15
	Interim_Release_1-2_RC1:1.15
	Interim_Release_1-2_beta1:1.14
	PublicRelease_1_1g:1.14
	Interim_Release_1-1g_RC3:1.14
	Interim_Release_1-1g_RC2:1.13
	Interim_Release_1-1g_RC1:1.13
	Interim_Release_1-1g_beta2:1.13
	Interim_Release_1-1g_beta1:1.13
	PublicRelease_1_1f:1.13
	Interim_Release_1-1f_RC1:1.13
	PublicRelease_1_1e:1.13
	Interim_Release_1-1e_RC2:1.13
	Interim_Release_1-1e_RC1:1.13
	Interim_Release_1-1e_beta1:1.13
	PublicRelease_1_1d:1.13
	Interim_Release_1-1d_RC1:1.13
	PublicRelease_1_1c:1.13
	Interim_Release_1-1c_RC1:1.13
	Interim_Release_1-1c_beta2:1.13
	Interim_Release_1-1c_beta1:1.13
	PublicRelease_1_1b:1.13
	Interim_Release_1-1b_RC1:1.13
	PublicRelease_1_1a:1.13
	Interim_Release_1-1a_RC2:1.13
	Interim_Release_1-1a_RC1:1.13
	Interim_Release_1-1a_beta2:1.12
	Interim_Release_1-1a_beta1:1.12
	PublicRelease_1_1:1.12
	Interim_Release_1-1_beta1:1.12
	PublicRelease_1o:1.12
	Interim_Release_1o_RC1:1.12
	Interim_Release_1o_beta1:1.12
	PublicRelease_1n:1.11
	Interim_Release_1n_RC2:1.11
	Interim_Release_1n_RC1:1.11
	Interim_Release_1n_beta2:1.11
	Interim_Release_1n_beta1:1.11
	PublicRelease_1m:1.11
	Interim_Release_1m_beta1:1.11
	PublicRelease_1l:1.11
	Interim_Release_1l_RC3:1.11
	Interim_Release_1l_RC2:1.11
	Interim_Release_1l_RC1:1.11
	Interim_Release_1l_beta2:1.11
	Interim_Release_1l_beta1:1.11
	PublicRelease_1k:1.8
	Interim_Release_1k_RC4:1.8
	Interim_1k_RC3:1.8
	Interim_1k_RC2:1.8
	Interim_Release_1k_RC1:1.8
	Interim_Release_1k_beta5:1.8
	Intrerim_Release_1k_beta4:1.8
	Interim_Release_1k_beta1:1.8
	PublicRelease_1j:1.5
	Interim_Release_1J_RC3:1.5
	Interim_Release_1j_RC3:1.5
	Interim_Release_1j_RC2:1.5
	Interim_Release_1j_RC1:1.5
	Interim_Release_1j_beta2:1.5
	Interim_Release_1j_beta1:1.5
	PublicRelease_1i:1.5
	Interim_Release_1i_RC6:1.5
	Interim_Release_1i_RC3:1.5
	Interim_Release_1i_RC2:1.5
	Interim_Release_1i_RC1:1.5
	Interim_Release_1i_beta3:1.5
	Interim_Release_1i_beta2:1.5
	Interim_Release_1i_beta1:1.5
	PublicRelease_1h:1.4
	Interim_Release_1h_rc2:1.4
	Interim_Release_1h_RC1:1.4
	Interim_Release_1h_beta2:1.3
	Interim_Release_1h_beta1_now:1.3
	Interim_Release_1h_beta1:1.3
	PublicRelease_1g:1.3
	Interim_Release_1g_RC6_Final:1.3
	Interim_Release_1g_RC6:1.3
	Interim_Release_1g_RC5:1.3
	Interim_Release_1g_RC4:1.3
	Interim_Release_1g_RC3:1.3
	Interim_Release_1g_beta2:1.2
	Interim_Release_1g_beta1:1.2
	Interim_Release_1f_RC4:1.2
	Interim_Release_1f_RC3:1.2
	Interim_Release_1f_RC2:1.2
	Interim_Release_1f_RC:1.2
	Interim_Release_1f_beta2:1.2
	Interim_Release_1f_beta1:1.2
	PublicRelease_1e:1.2
	Interim_Release_1e_RC2:1.2
	Interim_Release_1e_RC:1.2
	Interim_Release_1e_beta3:1.2
	Interim_Release_1e_beta2:1.2
	Interim_Release_1e_beta2_before_kuchin:1.1
	Interim_Release_1e_beta1:1.1
	PublicRelease_1c:1.1
	featurestest:1.1.0.8
	Interim_Release_1c_RC:1.1
	Interim_Release_1c_beta2:1.1
	Interim_Release_1c_beta1:1.1
	threaded_downloadqueue:1.1.0.6
	PublicRelease_1b:1.1
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1
	proxydeadlake:1.1.0.4
	PublicRelease_1a:1.1
	Interim_Release_1a_beta2:1.1
	BerkeleyDb:1.1.0.2
	Interim_Release_1a_beta1:1.1
	PublicRelease_1:1.1
	goldfish:1.1
	eMulePlus_1_RC2:1.1
	eMulePlus_26b_1RC1:1.1
	PreRelease_26b_i0e:1.1
	before_26d_merge:1.1;
locks; strict;
comment	@ * @;


1.21
date	2009.03.25.04.00.06;	author aw3;	state Exp;
branches;
next	1.20;

1.20
date	2009.03.20.02.52.23;	author aw3;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.13.02.12.36;	author aw3;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.03.12.30.22;	author kush_eplus;	state Exp;
branches;
next	1.17;

1.17
date	2008.03.03.05.24.04;	author aw3;	state Exp;
branches;
next	1.16;

1.16
date	2006.11.05.18.20.54;	author eklmn;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.12.03.11.17;	author aw3;	state Exp;
branches;
next	1.14;

1.14
date	2005.12.10.06.16.05;	author aw3;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.27.04.52.12;	author aw3;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.14.16.56.24;	author aw3;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.23.14.02.51;	author dropf;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.22.11.50.35;	author syrus77;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.20.23.33.36;	author dropf;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.15.09.49.32;	author eklmn;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.11.06.58.28;	author eklmn;	state Exp;
branches;
next	1.5;

1.5
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.4;

1.4
date	2003.09.08.18.28.33;	author eklmn;	state Exp;
branches;
next	1.3;

1.3
date	2003.06.09.15.14.37;	author kuchin;	state Exp;
branches;
next	1.2;

1.2
date	2003.04.22.13.08.17;	author kuchin;	state Exp;
branches;
next	1.1;

1.1
date	2003.02.14.15.00.30;	author obaldin;	state Exp;
branches
	1.1.8.1;
next	;

1.1.8.1
date	2003.03.24.09.39.42;	author recdvst;	state Exp;
branches;
next	;


desc
@@


1.21
log
@IP filter optimization: faster loading while consuming less resources (generally speaking code is ready; some improvements are possible as memory consumption is higher than what I expected).
@
text
@//this file is part of eMule
//Copyright (C)2002-2008 Merkur ( strEmail.Format("%s@@%s", "devteam", "emule-project.net") / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#pragma once

#pragma warning(push)
#pragma warning(disable:4702) // unreachable code
#include <hash_map>
#pragma warning(pop)

#ifndef VS2002
using namespace stdext;
#endif

typedef struct
{
	uint32		dwStart;
	uint32		dwEnd;
// D0-D7 ( 8): level
// D8-D31(24): string index
	unsigned	uiPacked;
} SIPFilter;

#define	DFLT_IPFILTER_FILENAME	_T("IPFilter.dat")

typedef std::vector<SIPFilter> CIPFilterArray;

/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
class CIPFilter
{
public:
	CIPFilter();
	~CIPFilter();

	void	AddIPRange(uint32 dwIPFrom, uint32 dwIPTo, UINT uiLevel, const CStringA& rstrDesc);
	void	AddTemporaryBannedIP(uint32 dwIP) { m_TempIPList[dwIP] = ::GetTickCount(); }
	void	RemoveAllIPs();
	int		AddFromFile(LPCTSTR pstrFilePath, bool bShowResponse = true);
	int		LoadFromDefaultFile(bool bShowResponse = true);
	bool	DownloadIPFilter();

	bool	IsFiltered(uint32 dwIP);
	bool	IsFiltered(uint32 dwIP, UINT uiLevel);
	bool	IsCachedAndFiltered(uint32 dwIP);
	void	ResetCachedFilteredIP()					{m_dwLastFilteredIP = 0;}
	bool	IsTemporaryFiltered(uint32 dwIP);
	const char*	GetLastHit() const;

private:
	bool	ParseFilterLine1(const char *pcLine, unsigned uiLineLen, CStringA *pstrOut, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;
	bool	ParseFilterLine2(CStringA &rstrBuffer, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;

private:
	uint32					m_dwLastFilteredIP;
	const SIPFilter			*m_pLastHit;
	CIPFilterArray			m_IPArr;
	char					*m_pcDesc;	//combined description strings for all permanent ranges
	hash_map<uint32,uint32>	m_TempIPList;
	char					m_acTempLastHit[64];
};
/////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////
@


1.20
log
@Keep IP-filter description strings in ASCII to reduce memory usage.
@
text
@d28 1
a28 1
struct SIPFilter
d30 6
a35 5
   uint32	dwStart;
   uint32	dwEnd;
   UINT		uiLevel;
   CStringA	strDesc;
};
d39 1
a39 1
typedef CTypedPtrArray<CPtrArray, SIPFilter*> CIPFilterArray;
d64 1
a64 1
	bool	ParseFilterLine1(CStringA &rstrBuffer, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;
d70 1
a70 1
	CIPFilterArray			m_IPList;
d73 1
a73 1
	CStringA				m_strTemporaryLastHit;
@


1.19
log
@Minor preparation for the redesign; Do string preparsing in ASCII to gain some performance (similar to original).
@
text
@d33 1
a33 1
   CString	strDesc;
d48 1
a48 1
	void	AddIPRange(uint32 dwIPFrom, uint32 dwIPTo, UINT uiLevel, const CString& rstrDesc);
d60 1
a60 1
	LPCTSTR	GetLastHit() const;
d67 2
a68 2
	uint32				m_dwLastFilteredIP;
	const SIPFilter*		m_pLastHit;
d70 1
d72 1
a72 1
	CString					m_strTemporaryLastHit;
@


1.18
log
@Fix type mismatch.
@
text
@a33 3
#if 0
   UINT		uiHits;
#endif
a37 3
// 'CArray' would give us more cach hits, but would also be slow in array element creation 
// (because of the implicit ctor in 'SIPFilter'
//typedef CArray<SIPFilter, SIPFilter> CIPFilterArray; 
d49 1
a49 1
	void	AddTemporaryBannedIP(uint32 dwIP) { iplist_temporary[dwIP] = ::GetTickCount(); }
a50 1
	void	RemoveOldIPs();
d63 2
a64 2
	bool	ParseFilterLine1(CString &rstrBuffer, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;
	bool	ParseFilterLine2(CString &rstrBuffer, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;
d70 1
a70 1
	hash_map<uint32,uint32>	iplist_temporary;
@


1.17
log
@H-file reorganization.
@
text
@d2 1
a2 1
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
d11 1
a11 1
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
d60 1
a60 1
	BOOL	DownloadIPFilter();
@


1.16
log
@improved filtering of incomming connections (less traffic & CPU load)
@
text
@d19 2
a20 4
#ifdef OLD_SOCKETS_ENABLED
#include "ListenSocket.h"
#endif //OLD_SOCKETS_ENABLED

d22 1
@


1.15
log
@Faster IP filter parsing.
@
text
@d65 2
d71 5
a79 3

	bool	ParseFilterLine1(CString &rstrBuffer, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;
	bool	ParseFilterLine2(CString &rstrBuffer, uint32 &rdwIP1, uint32 &rdwIP2, UINT &ruiLevel) const;
@


1.14
log
@Removed unused code.
@
text
@d74 2
a75 2
	bool	ParseFilterLine1(const CString& rstrBuffer, uint32& rdwIP1, uint32& rdwIP2, UINT& ruiLevel, CString& rstrDesc) const;
	bool	ParseFilterLine2(const CString& rstrBuffer, uint32& rdwIP1, uint32& rdwIP2, UINT& ruiLevel, CString& rstrDesc) const;
@


1.13
log
@Reduced memory used by IP filter by disabling unused functionality.
@
text
@a67 3
	const CIPFilterArray& GetIPFilter() const;
	bool	RemoveIPFilter(const SIPFilter* pFilter);

@


1.12
log
@Removed unused code and unrequired class variable.
@
text
@d35 1
d37 1
@


1.11
log
@comments formatting / Update button for IPFilter is now disabled for 24h after a successfull update.
@
text
@a58 1
	void	SaveToDefaultFile();
a72 2
	uint32					m_dwTicksToBan;
	int						m_iFilterLevel;
@


1.10
log
@exception / overwrite fix http://emuleplus.info/forum/index.php?showtopic=5492
@
text
@d45 2
d81 2
@


1.9
log
@updated to v0.42e code (from official) which supports PeerGuardian-style filters. I tried to keep other dev's changes. Could all the devs who made changes (espcially eklmn) look at this to check if I made no mistake? ;-) Thank you.
@
text
@d74 1
@


1.8
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d11 1
a11 1
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
d17 1
a18 2
#pragma once
#include "types.h"
d22 1
a22 1
#include <map>
a24 1
using namespace std;
d26 1
a26 1
	using namespace stdext;
d29 7
a35 6
struct IPRange_Struct{
   uint32           IPstart;
   uint32           IPend;
   byte				filter;
   CString			description;
   ~IPRange_Struct() {  }
d38 7
d50 3
a52 2
	bool	AddBannedIPRange(uint32 IPfrom,uint32 IPto,byte filter, CString desc);
	void AddTemporaryBannedIP(uint32 IP) 		{ iplist_temporary[IP] = ::GetTickCount();}
d54 14
a67 11
	void RemoveOldIPs();
	
	int		LoadFromFile();
	void	SaveToFile();
	
	bool	IsFiltered(uint32 IP2test);
	bool	IsFiltered(uint32 IP2test,int level);
	bool IsTemporaryFiltered(uint32 IP2test);
	
	CString GetLastHit()				{ return lasthit;}
	uint16	BanCount()					{ return iplist.size(); }
d69 5
a73 4
	CString lasthit;
	//CMutex m_Mutex;
	map<uint32,IPRange_Struct*> 	iplist;
	hash_map<uint32,uint32>			iplist_temporary;
d75 2
a76 2
	uint32	m_dwTicksToBan;
	int		m_iFilterLevel;
@


1.7
log
@speed optimization for temporary filtered clients
@
text
@d34 1
a34 1
   uint8			filter;
d44 1
a44 1
	bool	AddBannedIPRange(uint32 IPfrom,uint32 IPto,uint8 filter, CString desc);
@


1.6
log
@speed optimization for TemporaryFiltered
@
text
@d24 1
d27 3
d61 2
a62 2
	std::map<uint32,IPRange_Struct*> iplist;
	std::map<uint32,uint32>			iplist_temporary;
@


1.5
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@d59 3
@


1.4
log
@extended functionality for antiscaning measures
@
text
@d21 1
a21 1
#include "listensocket.h"
@


1.3
log
@Preparing for new sockets
@
text
@d41 1
d43 2
d47 1
d50 2
d58 1
@


1.2
log
@Upgrade to 0.28a
@
text
@d20 1
d22 1
@


1.1
log
@*** empty log message ***
@
text
@d21 3
d38 1
a38 1
	void	AddBannedIPRange(uint32 IPfrom,uint32 IPto,uint8 filter, CString desc);
d43 1
d45 1
a45 1
	uint16	BanCount()					{ return iplist.GetCount(); }
d49 1
a49 1
	CArray<IPRange_Struct*,IPRange_Struct*> iplist;
@


1.1.8.1
log
@27c
@
text
@a20 3
#include <map>

using namespace std;
d41 1
a41 1
	uint16	BanCount()					{ return iplist.size(); }
d45 1
a45 1
	std::map<uint32,IPRange_Struct*> iplist;
@

