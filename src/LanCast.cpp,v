head	1.50;
access;
symbols
	PublicRelease_1_2e:1.48
	Interim_Release_1-2e_RC1:1.48
	PublicRelease_1_2d:1.44
	Interim_Release_1-2d_RC1:1.43
	Interim_Release_1-2d_beta1:1.43
	PublicRelease_1_2c:1.42
	Interim_Release_1-2c_RC1:1.42
	Interim_Release_1-2c_beta1:1.41
	PublicRelease_1_2b:1.40
	Interim_Release_1-2b_RC1:1.40
	PublicRelease_1_2a:1.36
	Interim_Release_1-2a_RC1:1.36
	Interim_Release_1-2a_beta2:1.35
	Interim_Release_1-2a_beta1:1.35
	PublicRelease_1_2:1.35
	Interim_Release_1-2_RC1:1.35
	Interim_Release_1-2_beta1:1.35
	PublicRelease_1_1g:1.35
	Interim_Release_1-1g_RC3:1.35
	Interim_Release_1-1g_RC2:1.35
	Interim_Release_1-1g_RC1:1.35
	Interim_Release_1-1g_beta2:1.33
	Interim_Release_1-1g_beta1:1.32
	PublicRelease_1_1f:1.30
	Interim_Release_1-1f_RC1:1.30
	PublicRelease_1_1e:1.30
	Interim_Release_1-1e_RC2:1.30
	Interim_Release_1-1e_RC1:1.30
	Interim_Release_1-1e_beta1:1.30
	PublicRelease_1_1d:1.30
	Interim_Release_1-1d_RC1:1.30
	PublicRelease_1_1c:1.30
	Interim_Release_1-1c_RC1:1.30
	Interim_Release_1-1c_beta2:1.30
	Interim_Release_1-1c_beta1:1.30
	PublicRelease_1_1b:1.30
	Interim_Release_1-1b_RC1:1.30
	PublicRelease_1_1a:1.30
	Interim_Release_1-1a_RC2:1.30
	Interim_Release_1-1a_RC1:1.30
	Interim_Release_1-1a_beta2:1.30
	Interim_Release_1-1a_beta1:1.29
	PublicRelease_1_1:1.29
	Interim_Release_1-1_beta1:1.29
	PublicRelease_1o:1.29
	Interim_Release_1o_RC1:1.29
	Interim_Release_1o_beta1:1.29
	PublicRelease_1n:1.29
	Interim_Release_1n_RC2:1.29
	Interim_Release_1n_RC1:1.29
	Interim_Release_1n_beta2:1.29
	Interim_Release_1n_beta1:1.29
	PublicRelease_1m:1.28
	Interim_Release_1m_beta1:1.28
	PublicRelease_1l:1.28
	Interim_Release_1l_RC3:1.28
	Interim_Release_1l_RC2:1.28
	Interim_Release_1l_RC1:1.28
	Interim_Release_1l_beta2:1.28
	Interim_Release_1l_beta1:1.27
	PublicRelease_1k:1.27
	Interim_Release_1k_RC4:1.27
	Interim_1k_RC3:1.27
	Interim_1k_RC2:1.27
	Interim_Release_1k_RC1:1.27
	Interim_Release_1k_beta5:1.27
	Intrerim_Release_1k_beta4:1.27
	Interim_Release_1k_beta1:1.27
	PublicRelease_1j:1.22
	Interim_Release_1J_RC3:1.22
	Interim_Release_1j_RC3:1.22
	Interim_Release_1j_RC2:1.22
	Interim_Release_1j_RC1:1.22
	Interim_Release_1j_beta2:1.22
	Interim_Release_1j_beta1:1.22
	PublicRelease_1i:1.19
	Interim_Release_1i_RC6:1.19
	Interim_Release_1i_RC3:1.19
	Interim_Release_1i_RC2:1.19
	Interim_Release_1i_RC1:1.19
	Interim_Release_1i_beta3:1.19
	Interim_Release_1i_beta2:1.19
	Interim_Release_1i_beta1:1.15
	PublicRelease_1h:1.11
	Interim_Release_1h_rc2:1.11
	Interim_Release_1h_RC1:1.11
	Interim_Release_1h_beta2:1.11
	Interim_Release_1h_beta1_now:1.11
	Interim_Release_1h_beta1:1.11
	PublicRelease_1g:1.11
	Interim_Release_1g_RC6_Final:1.11
	Interim_Release_1g_RC6:1.11
	Interim_Release_1g_RC5:1.11
	Interim_Release_1g_RC4:1.11
	Interim_Release_1g_RC3:1.11
	Interim_Release_1g_beta2:1.8
	Interim_Release_1g_beta1:1.7
	Interim_Release_1f_RC4:1.5
	Interim_Release_1f_RC3:1.5
	Interim_Release_1f_RC2:1.5
	Interim_Release_1f_RC:1.5
	Interim_Release_1f_beta2:1.5
	Interim_Release_1f_beta1:1.5
	PublicRelease_1e:1.5
	Interim_Release_1e_RC2:1.5
	Interim_Release_1e_RC:1.5
	Interim_Release_1e_beta3:1.5
	Interim_Release_1e_beta2:1.5
	Interim_Release_1e_beta2_before_kuchin:1.5
	Interim_Release_1e_beta1:1.5
	PublicRelease_1c:1.5
	featurestest:1.5.0.2
	Interim_Release_1c_RC:1.5
	Interim_Release_1c_beta2:1.5
	Interim_Release_1c_beta1:1.5
	threaded_downloadqueue:1.4.0.2
	PublicRelease_1b:1.2
	Interim_Release_1b_beta2:1.1
	Interim_Release_1b_beta1:1.1;
locks; strict;
comment	@// @;


1.50
date	2010.05.13.04.48.49;	author aw3;	state Exp;
branches;
next	1.49;

1.49
date	2009.06.02.02.10.08;	author aw3;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.12.03.52.08;	author aw3;	state Exp;
branches;
next	1.47;

1.47
date	2008.11.03.05.45.23;	author aw3;	state Exp;
branches;
next	1.46;

1.46
date	2008.10.28.02.41.52;	author aw3;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.17.05.02.53;	author aw3;	state Exp;
branches;
next	1.44;

1.44
date	2008.05.14.03.38.11;	author aw3;	state Exp;
branches;
next	1.43;

1.43
date	2008.01.12.10.32.10;	author eklmn;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.23.03.45.19;	author aw3;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.11.04.31.11;	author aw3;	state Exp;
branches;
next	1.40;

1.40
date	2007.01.17.07.42.41;	author aw3;	state Exp;
branches;
next	1.39;

1.39
date	2007.01.11.19.57.04;	author eklmn;	state Exp;
branches;
next	1.38;

1.38
date	2006.10.22.12.10.51;	author kush_eplus;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.16.21.56.10;	author kush_eplus;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.09.02.45.11;	author aw3;	state Exp;
branches;
next	1.35;

1.35
date	2005.11.27.22.11.47;	author eklmn;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.27.20.31.05;	author eklmn;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.05.05.36.02;	author aw3;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.21.21.26.41;	author eklmn;	state Exp;
branches;
next	1.31;

1.31
date	2005.08.04.03.25.20;	author aw3;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.09.15.07.35;	author aw3;	state Exp;
branches;
next	1.29;

1.29
date	2004.06.30.13.38.41;	author dongato;	state Exp;
branches;
next	1.28;

1.28
date	2004.05.21.15.50.01;	author dongato;	state Exp;
branches;
next	1.27;

1.27
date	2004.02.16.23.22.39;	author aw3;	state Exp;
branches;
next	1.26;

1.26
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.25;

1.25
date	2004.02.11.04.13.00;	author katsyonak;	state Exp;
branches;
next	1.24;

1.24
date	2004.02.03.14.28.06;	author kush_eplus;	state Exp;
branches;
next	1.23;

1.23
date	2004.02.03.12.53.48;	author morevit;	state Exp;
branches;
next	1.22;

1.22
date	2003.12.24.01.21.14;	author katsyonak;	state Exp;
branches;
next	1.21;

1.21
date	2003.12.23.19.03.21;	author katsyonak;	state Exp;
branches;
next	1.20;

1.20
date	2003.12.23.15.35.17;	author katsyonak;	state Exp;
branches;
next	1.19;

1.19
date	2003.10.20.15.49.35;	author eklmn;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.08.12.56.33;	author morevit;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.08.01.53.32;	author morevit;	state Exp;
branches;
next	1.15;

1.15
date	2003.09.21.22.05.16;	author morevit;	state Exp;
branches;
next	1.14;

1.14
date	2003.09.20.15.39.30;	author morevit;	state Exp;
branches;
next	1.13;

1.13
date	2003.09.19.14.42.46;	author morevit;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.19.00.13.37;	author morevit;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.19.16.48.04;	author partyckip;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.17.13.54.02;	author netwolf1;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.11.18.27.09;	author eklmn;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.06.20.37.17;	author partyckip;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.31.17.14.28;	author partyckip;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.31.08.50.54;	author partyckip;	state Exp;
branches;
next	1.5;

1.5
date	2003.03.15.16.35.57;	author cax2;	state Exp;
branches;
next	1.4;

1.4
date	2003.03.14.16.24.19;	author partyckip;	state Exp;
branches;
next	1.3;

1.3
date	2003.03.13.21.57.22;	author partyckip;	state Exp;
branches;
next	1.2;

1.2
date	2003.03.09.15.48.39;	author moosetea;	state Exp;
branches;
next	1.1;

1.1
date	2003.03.03.22.10.17;	author moosetea;	state Exp;
branches;
next	;


desc
@@


1.50
log
@Added an option to bind to specific network interface (from original) {Zom}.
@
text
@// This file is part of eMule Plus
//
// LANCAST
//
// Written by moosetea, enjoy
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either
// version 2 of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
// This allows lan clients to add each other as peers, it could be
// very buggy and needs alot more work.
//
// Thanks to codeproject for help with the multicast code,
// which works but is a bit of a shambles.

#include "stdafx.h"
#include "emule.h"
#include "updownclient.h"
#include "KnownFile.h"
#include "LanCast.h"
#include "packets.h"
#include "SharedFileList.h"
#include "otherfunctions.h"
#include "SafeFile.h"

CLanCast::CLanCast()
{
	bStarted = false;
	if (GetLancastEnabled())
	{
		udp_timer = SetTimer(0, 4329, 10000, CLanCast::UDPTimerProc);
		Start();
	}
}

bool CLanCast::SendPacket(Packet* packet)
{
	char	*pcSendBuffer = new char[packet->m_dwSize + 2];
	int		iRc;

//	Standard UDP Header
	memcpy(pcSendBuffer, packet->GetUDPHeader(), 2);
//	The packet Data
	memcpy2(pcSendBuffer + 2, packet->m_pcBuffer, packet->m_dwSize);

//	Send the LanCast packet
	iRc = m_SendSocket.SendTo(pcSendBuffer, packet->m_dwSize + 2, (SOCKADDR*)&m_saHostGroup, sizeof(SOCKADDR), 0);
	delete[] pcSendBuffer;
	return (iRc != SOCKET_ERROR);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CLanCast::BroadcastHash(CKnownFile *pKnownFile)
{
	if (GetLancastEnabled())
	{
		Start();

		CMemFile	packetStream(4 + 2 + 16);

		uint32		dwIP = GetLancastIP();
		uint16		uPort = g_App.m_pPrefs->GetPort();

		packetStream.Write(&dwIP, 4);						// <lancastip 4>
		packetStream.Write(&uPort, 2);						// <emuletcpport 2>
		packetStream.Write(pKnownFile->GetFileHash(), 16);	// <filehash 16>

		Packet		*pPacket = new Packet(&packetStream, OP_LANCASTPROT);
		pPacket->m_eOpcode = OP_HASH;

		SendPacket(pPacket);
		delete pPacket;
	}
	else
		Stop();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CLanCast::ReceiveHash(byte *pbytePacketBuf, uint32 dwSize)
{
	CSafeMemFile		packetStream(pbytePacketBuf, dwSize);

	uint32		dwIP = 0;
	uint16		uPort = 0;
	uchar		fileHash[16];

//	Read Hash Data
	packetStream.Read(&dwIP, 4);
	packetStream.Read(&uPort, 2);
	packetStream.Read(&fileHash, 16);

#ifdef _DEBUG
	CString		buffer = HashToString(fileHash);
	AddLogLine(LOG_FL_DBG, _T("Lancast: Just Received %s"), buffer);
#endif

	CPartFile		*pPartFile = g_App.m_pDownloadQueue->GetFileByID(fileHash);

	if (pPartFile != NULL)
	{
#ifdef _DEBUG
		AddLogLine(LOG_FL_DBG, _T("Lancast: Adding source for %s"), buffer);
#endif

	//	Create a new Updown client for this source (with no server info), userid is the LAN ip address
	//	Add this LAN uldl client to the download queue, this also will check for duplicate sockets and "merge" them
		CUpDownClient *pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile, fast_ntohl(dwIP), uPort, 0, 0, NULL);

		if (pNewSource != NULL)
		{
			pNewSource->SetUserName(GetResString(IDS_LANCAST_SOURCE));
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CLanCast::~CLanCast()
{
	Stop();
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CLanCast::OnReceive(int iErrorCode)
{
	byte		abyteBuffer[5000];
	SOCKADDR_IN	sockAddr = {0};
	int			iSockAddrLen = sizeof(sockAddr);
	int			iLength = ReceiveFrom(abyteBuffer, sizeof(abyteBuffer), (SOCKADDR*)&sockAddr, &iSockAddrLen);
	NOPRM(iErrorCode);

	if (iLength >= 2)	//SOCKET_ERROR = -1
	{
	//	If Lancast is enabled and this isn't a packet from ourselves
		if (GetLancastEnabled() && (sockAddr.sin_addr.s_addr != GetLancastIP()))
		{
			if (abyteBuffer[0] == OP_LANCASTPROT)
				ProcessPacket(abyteBuffer + 2, iLength - 2, abyteBuffer[1]);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CLanCast::ProcessPacket(byte *pbytePacketBuf, uint32 dwSize, byte byteOpcode)
{
	try
	{
		switch (byteOpcode)
		{
			case OP_HASH:
				ReceiveHash(pbytePacketBuf, dwSize);
				break;

			default:
				AddLogLine(LOG_RGB_WARNING, IDS_LANCAST_UNK_OPCODE);
				return false;
		}

		return true;
	}
	catch(...)
	{
		AddLogLine(LOG_RGB_ERROR, IDS_LANCAST_ERR_MULITC);
		return false;
	}
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void CALLBACK CLanCast::UDPTimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime)
{
	NOPRM(hwnd); NOPRM(uMsg); NOPRM(idEvent); NOPRM(dwTime);
	g_App.m_pSharedFilesList->NextLANBroadcast();
}
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// CLanCast Private member functions - MultiCast Network Code
bool CLanCast::CreateReceivingSocket(const char *pcGroupIP, uint32 dwGroupPort)
{
//	Create socket for receiving packets from multicast group
	if(!Create(dwGroupPort, SOCK_DGRAM, FD_READ, g_App.m_pPrefs->GetBindAddr()))
		return false;

//	Allow reuse of local port if needed
	BOOL bMultipleApps = TRUE;
	SetSockOpt(SO_REUSEADDR, (void*)&bMultipleApps, sizeof(BOOL), SOL_SOCKET);

//	Fill m_saHostGroup_in for sending datagrams
	memzero(&m_saHostGroup, sizeof(m_saHostGroup));
	m_saHostGroup.sin_family = AF_INET;
	m_saHostGroup.sin_addr.s_addr = inet_addr(pcGroupIP);
	m_saHostGroup.sin_port = fast_htons((USHORT)dwGroupPort);

//	Join the multicast group
	m_mrMReq.imr_multiaddr.s_addr = inet_addr(pcGroupIP);	// group addr
	m_mrMReq.imr_interface.s_addr = fast_htonl(INADDR_ANY);		// use default
	if(setsockopt(m_hSocket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (char FAR *)&m_mrMReq, sizeof(m_mrMReq)) < 0)
		return false;

	return true;
}

bool CLanCast::CreateSendingSocket(uint32 dwTTL, bool bLoopBack)
{
//	Create an unconnected UDP socket
	if(!m_SendSocket.Create(0, SOCK_DGRAM, 0, g_App.m_pPrefs->GetBindAddr()))
		return false;

//	Set Time to Live as specified by user
	if(!SetTTL(dwTTL))
		AddLogLine(LOG_RGB_ERROR, IDS_ERR_TTL);

	SetLoopBack(bLoopBack);

	return true;
}

void CLanCast::Start()
{
	if (!bStarted)
	{
		in_addr host;
		host.s_addr = GetLancastIP();

	//	Try and join the multicast group - 224.0.0.1, using the prefs port and no loopback
		if(!JoinGroup("224.0.0.1", GetLancastPort(), 50, false))
			AddLogLine(LOG_RGB_WARNING, IDS_JOIN_FAILED, host.s_net, host.s_host, host.s_lh, host.s_impno, GetLancastPort());
		else
			AddLogLine(0, IDS_JOIN_SUCCEEDED, host.s_net, host.s_host, host.s_lh, host.s_impno, GetLancastPort());
	}
}

void CLanCast::Stop()
{
	if (bStarted)
	{
		if(!LeaveGroup())
		{
			if (g_App.m_pMDlg)
				AddLogLine(LOG_RGB_WARNING, IDS_LEAVE_FAILED, GetLancastPort());
		}
		else if (g_App.m_pMDlg)
			AddLogLine(0, IDS_LEAVE_SUCCEEDED, GetLancastPort());
	}
}

bool CLanCast::JoinGroup(const char *pcGroupIP, uint32 dwGroupPort, uint32 dwTTL, bool bLoopback)
{
	bStarted = false;

//	Create Socket for receiving and join the host group
	if(!CreateReceivingSocket(pcGroupIP, dwGroupPort))
		return false;
//	Create Socket for sending
	if(!CreateSendingSocket(dwTTL, bLoopback))
		return false;

	bStarted = true;

	return true;
}

bool CLanCast::LeaveGroup()
{
	bStarted = false;

	if (setsockopt(m_hSocket, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char FAR *)&m_mrMReq, sizeof(m_mrMReq)) < 0)
		return false;

	m_SendSocket.Close();		// Close sending socket
	Close();					// Close receving socket
	return true;
}

bool CLanCast::SetTTL(uint32 dwTTL)
{
//	Set Time to Live to parameter TTL
	if(m_SendSocket.SetSockOpt(IP_MULTICAST_TTL, &dwTTL, sizeof(dwTTL), IPPROTO_IP) == 0)
		return false;		// Error Setting TTL
	else
		return true;		// else TTL set successfully
}

void CLanCast::SetLoopBack(bool bLoop)
{
//	Set LOOPBACK option to TRUE OR FALSE according to IsLoop parameter
	int nLoopBack = (int)bLoop;
//	Try to manually set the loopback, ie tell dozer to ignore packets from itself (if setloopback is false)
	m_SendSocket.SetSockOpt(IP_MULTICAST_LOOP, &nLoopBack, sizeof(nLoopBack), IPPROTO_IP);
}

bool CLanCast::GetLancastEnabled()
{
	return g_App.m_pPrefs->GetLancastEnabled();
}

uint32 CLanCast::GetLancastIP()
{
	return g_App.m_pPrefs->GetLancastIP();
}

uint16 CLanCast::GetLancastPort()
{
	return g_App.m_pPrefs->GetLancastPort();
}
@


1.49
log
@Fast byte swap for ntohl and ntohs.
@
text
@d183 1
a183 1
	if(!Create(dwGroupPort, SOCK_DGRAM, FD_READ))
d208 1
a208 1
	if(!m_SendSocket.Create(0, SOCK_DGRAM, 0))
@


1.48
log
@Simplified logging system implementation.
@
text
@d116 1
a116 1
		CUpDownClient *pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile, ntohl(dwIP), uPort, 0, 0, NULL);
@


1.47
log
@Reduced H-file dependency.
@
text
@d103 1
a103 1
	AddDebugLogLine(_T("Lancast : Just Received %s"), buffer);
d111 1
a111 1
		AddDebugLogLine(_T("Lancast : Adding source for %s"), buffer);
d160 1
a160 1
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_LANCAST_UNK_OPCODE));
d168 1
a168 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_LANCAST_ERR_MULITC));
d213 1
a213 1
		AddLogLine(false, RGB_LOG_ERROR + GetResString(IDS_ERR_TTL));
d229 1
a229 1
			AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_JOIN_FAILED), host.s_net, host.s_host, host.s_lh, host.s_impno, GetLancastPort());
d231 1
a231 1
			AddLogLine(false, IDS_JOIN_SUCCEEDED, host.s_net, host.s_host, host.s_lh, host.s_impno, GetLancastPort());
d242 1
a242 1
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_LEAVE_FAILED), GetLancastPort());
d245 1
a245 1
			AddLogLine(false, IDS_LEAVE_SUCCEEDED, GetLancastPort());
@


1.46
log
@Reduced H-file dependency.
@
text
@d33 1
@


1.45
log
@Faster (intrinsic) htonl and htons implementation;
Fixed m_mrMReq.imr_interface.s_addr assignment -- wrong value type was used although logically everything worked properly.
@
text
@d29 1
@


1.44
log
@Suppressed compiler warnings.
@
text
@d192 1
a192 1
	m_saHostGroup.sin_port = htons((USHORT)dwGroupPort);
d196 1
a196 1
	m_mrMReq.imr_interface.s_addr = htons(INADDR_ANY);		// use default
@


1.43
log
@checked for Unicode. minor corrections
@
text
@d134 1
d171 1
a171 1
void CALLBACK CLanCast::UDPTimerProc(HWND hwnd, UINT uMsg,UINT_PTR idEvent,DWORD dwTime)
d173 1
@


1.42
log
@Reduced #include dependency.
@
text
@d176 1
a176 1
bool CLanCast::CreateReceivingSocket(LPCSTR pcGroupIP, uint32 dwGroupPort)
d245 1
a245 1
bool CLanCast::JoinGroup(LPCSTR pcGroupIP, uint32 dwGroupPort, uint32 dwTTL, bool bLoopback)
d276 1
a276 1
	if(m_SendSocket.SetSockOpt(IP_MULTICAST_TTL, &dwTTL, sizeof(int), IPPROTO_IP) == 0)
d287 1
a287 1
	m_SendSocket.SetSockOpt(IP_MULTICAST_LOOP, &nLoopBack, sizeof(int), IPPROTO_IP);
@


1.41
log
@Fixed potential crash while sending Lancast packet (as well as more data than required was sent);
Formatting.
@
text
@d33 1
@


1.40
log
@Ranaming and formatting.
@
text
@d47 1
d55 3
a57 10
	if(m_SendSocket.SendTo(pcSendBuffer, packet->m_dwSize+10, (SOCKADDR*)&m_saHostGroup, sizeof(SOCKADDR), 0) == SOCKET_ERROR)
	{
		delete[] pcSendBuffer;
		return false;
	}
	else
	{
		delete[] pcSendBuffer;
		return true;
	}
d66 1
a66 1
		CMemFile	packetStream(52);
d71 3
a73 3
		packetStream.Write(&dwIP,4);						// <lancastip 4>
		packetStream.Write(&uPort,2);						// <emuletcpport 2>
		packetStream.Write(pKnownFile->GetFileHash(),16);	// <filehash 16>
d75 1
a75 1
		Packet		*pPacket = new Packet(&packetStream,OP_LANCASTPROT);
@


1.39
log
@1) updated source exchange protocol to ver.3
2) support of HighID clients with IP "x.x.x.0"  (see description in updownclient.h)
3) removed dublicated ip check for LowID clients in TryToConnect()
4) fixed a client name change by download start from remote client shared file list.
5) some formating
@
text
@d93 1
a93 1
	CSafeMemFile		packetStream(pbytePacketBuf,dwSize);
d100 3
a102 3
	packetStream.Read(&dwIP,4);
	packetStream.Read(&uPort,2);
	packetStream.Read(&fileHash,16);
d119 1
a119 1
		CUpDownClient *pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile,ntohl(dwIP),uPort,0,0, NULL);
@


1.38
log
@reverted last changes as try/catch isn't needed anymore
@
text
@d119 1
a119 1
		CUpDownClient *pNewSource = g_App.m_pDownloadQueue->CheckAndAddSource(pPartFile,dwIP,uPort,0,0, NULL);
@


1.37
log
@Another workaround for another crash - again an access to an unreadable address from a CKnownFile class member
@
text
@a67 2
	EMULE_TRY

a88 2

	EMULE_CATCH
@


1.36
log
@Removed unrequired #include.
@
text
@d24 1
a24 1
// Thanks to codeproject for help with the multicast code, 
d68 2
d71 1
a72 2
	else
		Stop();
a73 2
	if (GetLancastEnabled())
	{
d87 1
a87 1
		delete pPacket;	
d89 4
d100 1
a100 1
	uint16		uPort = 0; 
d115 1
a115 1
	if (pPartFile != NULL) 
d231 1
a231 1
		
@


1.35
log
@renamed g_pPrefs->m_pPrefs (f... paste & copy :( )
@
text
@a31 1
#include "ED2KLink.h"
d39 1
a39 1
		udp_timer = SetTimer(0,4329,10000,CLanCast::UDPTimerProc);
@


1.34
log
@renamed 3 variables
@
text
@d79 1
a79 1
		uint16		uPort = g_App.g_pPrefs->GetPort();
d299 1
a299 1
	return g_App.g_pPrefs->GetLancastEnabled();
d304 1
a304 1
	return g_App.g_pPrefs->GetLancastIP();
d309 1
a309 1
	return g_App.g_pPrefs->GetLancastPort();
@


1.33
log
@Applied some corrections for Unicode;
Changed a way to display IP address; Formatting.
@
text
@d79 1
a79 1
		uint16		uPort = g_eMuleApp.m_pGlobPrefs->GetPort();
d111 1
a111 1
	CPartFile		*pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID(fileHash);
d121 1
a121 1
		CUpDownClient *pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(pPartFile,dwIP,uPort,0,0, NULL);
d179 1
a179 1
	g_eMuleApp.m_pSharedFilesList->NextLANBroadcast();
d244 1
a244 1
			if (g_eMuleApp.m_pdlgEmule)
d247 1
a247 1
		else if (g_eMuleApp.m_pdlgEmule)
d299 1
a299 1
	return g_eMuleApp.m_pGlobPrefs->GetLancastEnabled();
d304 1
a304 1
	return g_eMuleApp.m_pGlobPrefs->GetLancastIP();
d309 1
a309 1
	return g_eMuleApp.m_pGlobPrefs->GetLancastPort();
@


1.32
log
@improved LowID check by SX (part 2)
@
text
@d29 1
d47 1
a47 1
	char* pcSendBuffer = new char[packet->m_dwSize + 2];
d58 1
a58 1
		return FALSE;
d63 1
a63 1
		return TRUE;
d135 1
a135 1
void CLanCast::OnReceive(int nErrorCode)
d138 3
a140 3
	CString		addressbuffer;
	UINT		uiPort;
	int			iLength = ReceiveFrom(abyteBuffer, sizeof(abyteBuffer), addressbuffer, uiPort);
d145 1
a145 1
		if (GetLancastEnabled() && (inet_addr(addressbuffer) != GetLancastIP()))
d160 1
a160 1
				ReceiveHash(pbytePacketBuf,dwSize);
d183 1
a183 1
BOOL CLanCast::CreateReceivingSocket(LPCTSTR strGroupIP, UINT nGroupPort)
d186 2
a187 2
	if(!Create(nGroupPort, SOCK_DGRAM, FD_READ))
		return FALSE;
d196 2
a197 2
	m_saHostGroup.sin_addr.s_addr = inet_addr(strGroupIP);
	m_saHostGroup.sin_port = htons((USHORT)nGroupPort);
d200 1
a200 1
	m_mrMReq.imr_multiaddr.s_addr = inet_addr(strGroupIP);	// group addr
d203 1
a203 1
		return FALSE;
d205 1
a205 1
	return TRUE;
d208 1
a208 1
BOOL CLanCast::CreateSendingSocket(UINT nTTL, BOOL bLoopBack)
d212 1
a212 1
		return FALSE;
d215 1
a215 1
	if(!SetTTL(nTTL))
d220 1
a220 1
	return TRUE;
d228 1
a228 2
		host.S_un.S_addr = GetLancastIP();
		CString strLanCastIP(inet_ntoa(host));
d231 4
a234 5
		if(!JoinGroup(_T("224.0.0.1"), GetLancastPort(), 50,false))
			AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_JOIN_FAILED), GetLancastIP(), strLanCastIP, GetLancastPort());
		else {
			AddLogLine(false, IDS_JOIN_SUCCEEDED, GetLancastIP(), strLanCastIP, GetLancastPort());
		}
d252 1
a252 2

BOOL CLanCast::JoinGroup(CString GroupIP, UINT nGroupPort, UINT nTTL, BOOL bLoopback)
d257 2
a258 2
	if(!CreateReceivingSocket(GroupIP, nGroupPort))
		return FALSE;
d260 2
a261 2
	if(!CreateSendingSocket(nTTL, bLoopback))
		return FALSE;
d265 1
a265 1
	return TRUE;
d268 1
a268 1
BOOL CLanCast::LeaveGroup()
d273 1
a273 1
		return FALSE;
d277 1
a277 1
	return TRUE;
d280 1
a280 1
BOOL CLanCast::SetTTL(UINT nTTL)
d283 2
a284 2
	if(m_SendSocket.SetSockOpt(IP_MULTICAST_TTL, &nTTL, sizeof(int), IPPROTO_IP) == 0)
		return FALSE;		// Error Setting TTL
d286 1
a286 1
		return TRUE;		// else TTL set successfully
d289 1
a289 1
void CLanCast::SetLoopBack(BOOL bLoop)
@


1.31
log
@Global preferences reference for LanCast {WiZaRd}.
@
text
@d120 1
a120 1
		CUpDownClient *pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(pPartFile,dwIP,uPort,0,0);
@


1.30
log
@Protection against short invalid packets.
@
text
@d27 1
a27 1
#include "StdAfx.h"
d34 1
a34 3
// CLanCast

CLanCast::CLanCast(CPreferences* in_prefs)
a35 1
	m_prefs = in_prefs;
d46 1
d48 4
a51 18
		char* pcSendBuffer = new char[packet->m_dwSize+2];

	//	Standard UDP Header
		memcpy2(pcSendBuffer,packet->GetUDPHeader(),2);
	//	The packet Data
		memcpy2(pcSendBuffer+2,packet->m_pcBuffer,packet->m_dwSize);

	//	Send the LanCast packet
		if(m_SendSocket.SendTo(pcSendBuffer, packet->m_dwSize+10, (SOCKADDR*)&m_saHostGroup, sizeof(SOCKADDR), 0) == SOCKET_ERROR)
		{
			delete[] pcSendBuffer;
			return FALSE;
		}
		else
		{
			delete[] pcSendBuffer;
			return TRUE;
		}
d53 11
d75 1
a75 1
		CMemFile	packetStream(100);
d78 1
a78 1
		uint16		uPort = GetEmulePort();
d114 1
a114 1
	#ifdef _DEBUG
d116 1
a116 1
	#endif
a158 1
			{	
d161 1
a161 1
			}
d224 2
a225 2
	if (!bStarted){

d228 1
a228 1
		CString t_strLanCastIP(inet_ntoa(host));
d231 2
a232 2
		if(!JoinGroup (_T("224.0.0.1"), GetLancastPort() , 50,false))
			AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_JOIN_FAILED),GetLancastIP(),t_strLanCastIP,GetLancastPort());
d234 1
a234 1
			AddLogLine(false, IDS_JOIN_SUCCEEDED,GetLancastIP(),t_strLanCastIP,GetLancastPort());
a236 1

d241 2
a242 1
	if (bStarted){
d244 1
d246 4
a249 4
				AddLogLine(false, RGB_LOG_WARNING + GetResString(IDS_LEAVE_FAILED),GetLancastPort());
		else
			if (g_eMuleApp.m_pdlgEmule)
				AddLogLine(false, IDS_LEAVE_SUCCEEDED,GetLancastPort());
a255 1

a271 1

d274 1
a274 1
	if(setsockopt (m_hSocket, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char FAR *)&m_mrMReq, sizeof(m_mrMReq)) < 0)
d298 15
@


1.29
log
@Removed AddDebugLogLine statusbar message option, added client transfer debug log option
@
text
@d141 1
a141 2

	byte		buffer[5000];
d144 1
a144 1
	uint32		dwLength = ReceiveFrom(buffer,5000,addressbuffer,uiPort);
d146 1
a146 2
//	If Lancast is enabled process
	if (GetLancastEnabled())
d148 2
a149 2
	//	If this isn't a packet from ourselves
		if (inet_addr(addressbuffer) != GetLancastIP())
d151 2
a152 2
			if (buffer[0] == OP_LANCASTPROT && dwLength != SOCKET_ERROR)
				ProcessPacket(buffer+2,dwLength-2,buffer[1]);
@


1.28
log
@More DebugLog formating and changes
@
text
@d112 1
a112 1
	AddDebugLogLine(false, _T("Lancast : Just Received %s"), buffer);
d120 1
a120 1
		AddDebugLogLine(false, _T("Lancast : Adding source for %s"), buffer);
@


1.27
log
@Improved hash to string conversion
@
text
@d1 1
a1 1
// This file is part of eMule 
d3 1
a3 1
///LANCAST
d7 4
a10 4
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
d12 4
a15 4
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
d17 3
a19 3
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
a26 1
// Base includes needed by this class (and every class)
a28 2

// We also need the class defintion, and specific includes
a37 1

a38 1

d52 1
a52 1
		// Standard UDP Header
d54 1
a54 1
		// The packet Data
d57 1
a57 1
		// Send the LanCast packet
a77 1

d110 2
a111 2
//	Debug Info for Devs - The following lines should be removed in release
	CString		buffer = HashToString(fileHash);	
d113 1
d119 1
a119 1
	//	Debug Info for Devs - the following lines can be removed in release
d121 1
a123 1

d125 1
a125 1
		CUpDownClient		*pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(pPartFile,dwIP,uPort,0,0);
d192 1
a192 1
	/* Create socket for receiving packets from multicast group */
d196 2
a197 1
	BOOL bMultipleApps = TRUE;		/* allow reuse of local port if needed */
d200 1
a200 1
	/* Fill m_saHostGroup_in for sending datagrams */
d206 3
a208 3
	/* Join the multicast group */
	m_mrMReq.imr_multiaddr.s_addr = inet_addr(strGroupIP);	/* group addr */ 
	m_mrMReq.imr_interface.s_addr = htons(INADDR_ANY);		/* use default */ 
d217 2
a218 1
	if(!m_SendSocket.Create(0, SOCK_DGRAM, 0))		// Create an unconnected UDP socket
d221 2
a222 1
	if(!SetTTL(nTTL))								// Set Time to Live as specified by user
d238 1
a238 1
		// Try and join the multicast group - 224.0.0.1, using the prefs port and no loopback
d252 1
a252 1
			if (g_eMuleApp.m_pdlgEmule)	//sometimes method is called in app shutdown [TwoBottle Mod]
d255 1
a255 1
			if (g_eMuleApp.m_pdlgEmule)	//sometimes method is called in app shutdown [TwoBottle Mod]
d266 2
a267 1
	if(!CreateReceivingSocket(GroupIP, nGroupPort))		/* Create Socket for receiving and join the host group */
d269 2
a270 1
	if(!CreateSendingSocket(nTTL, bLoopback))			/* Create Socket for sending */
d293 1
a293 1
	/* Set Time to Live to parameter TTL */
d295 1
a295 1
		return FALSE;		/* Error Setting TTL */
d297 1
a297 1
		return TRUE;		/* else TTL set successfully */
d302 1
a302 1
	/* Set LOOPBACK option to TRUE OR FALSE according to IsLoop parameter */
d304 1
a304 2

	// Try to manually set the loopback, ie tell dozer to ignlore packets from itself (if setloopback is false)
a305 1

@


1.26
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d117 1
a117 1
	CString		buffer = FileHashToString(fileHash);	
@


1.25
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d103 1
a103 1
void CLanCast::ReceiveHash(char *pcPacketBuffer, uint32 dwSize)
d105 1
a105 1
	CSafeMemFile		packetStream(reinterpret_cast<BYTE*>(pcPacketBuffer),dwSize);
d143 1
a143 1

d147 4
a150 3
	char buffer[5000];
	CString addressbuffer;
	uint32 port;
d152 4
a155 6
	int32 length = ReceiveFrom(buffer,5000,addressbuffer,port);

	// if lancast is enabled proccess
	if (GetLancastEnabled()){

		// If this isnt a packet from ourselves
d158 2
a159 4

			if ((uint8)buffer[0] == OP_LANCASTPROT && length != SOCKET_ERROR)
				ProcessPacket(buffer+2,length-2,buffer[1]);

a160 1

a161 1

d163 2
a164 2

bool CLanCast::ProcessPacket(char *pcPacketBuffer, uint32 dwSize, uint8 byteOpcode)
d172 1
a172 1
				ReceiveHash(pcPacketBuffer,dwSize);
@


1.24
log
@A4AF sources count is display in sources column + minor cosmetic changes
@
text
@d210 1
a210 1
	memset2(&m_saHostGroup, 0, sizeof(m_saHostGroup));
@


1.23
log
@Formatting, comments, and name changes.
@
text
@d86 1
a86 1
		CMemFile		packetStream(100);
d194 3
a196 2
void CALLBACK CLanCast::UDPTimerProc(HWND hwnd, UINT uMsg,UINT_PTR idEvent,DWORD dwTime){
		g_eMuleApp.m_pSharedFilesList->NextLANBroadcast();
a197 1

a199 1

@


1.22
log
@Added RGB_LOG_ERROR, RGB_LOG_WARNING, RGB_LOG_NOTICE, RGB_LOG_DIMMED & RGB_LOG_SUCCESS for easier changing of log colors
@
text
@d75 3
a77 4

void CLanCast::BroadcastHash(CKnownFile* cur_file){


d84 3
a86 1
	if (GetLancastEnabled()){
d88 2
a89 1
		CMemFile file(100);
d91 3
a93 2
		uint32 dwID = GetLancastIP();
		uint16 nPort = GetEmulePort();
d95 2
a96 3
		file.Write(&dwID,4);
		file.Write(&nPort,2);
		file.Write(cur_file->GetFileHash(),16);
d98 2
a99 5
		Packet* packet = new Packet(&file,OP_LANCASTPROT);
		packet->m_eOpcode = OP_HASH;

		SendPacket(packet);
		delete packet;	
d103 1
a103 1
void CLanCast::RecieveHash(char* pachPacket, uint32 nSize)
d105 1
a105 1
	CSafeMemFile offeredfiles((BYTE*)pachPacket,nSize);
d107 3
a109 3
	uint32 dwID = 0;
	uint16 nPort = 0; 
	uchar filehash[16];
d111 4
a114 4
	// Read Hash Data
	offeredfiles.Read(&dwID,4);
	offeredfiles.Read(&nPort,2);
	offeredfiles.Read(&filehash,16);
d116 2
a117 2
	 // Debug Info for Devs - The following lines should be removed in release
	CString buffer = FileHashToString(filehash);	
d120 1
a120 1
	CPartFile* pPartFile = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)filehash);
d122 1
a122 1
	if (pPartFile) 
d124 1
a124 1
		// Debug Info for Devs - the following lines can be removed in release
d127 4
a130 2
		// Create a new Updown client for this source (with no server info), userid is the LAN ip address
		//CUpDownClient* newsource = new CUpDownClient(nPort,dwID,0,0,file);
d132 2
a133 4
		// Add this LAN uldl client to the download queue, this also will check for duplicate sockets and "merge" them
		//g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(file,newsource);
		CUpDownClient* pNewSource = g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(pPartFile,dwID,nPort,0,0);
		if (pNewSource)
d135 1
d169 9
a177 8
bool CLanCast::ProcessPacket(char* packet, uint32 size, uint8 opcode){

	try{

		switch(opcode){
			case OP_HASH :{	
				
				RecieveHash(packet,size);
d187 2
a188 1
	catch(...){
d193 1
a193 1

@


1.21
log
@Changed to predefined colors  - thx DoubleT ;-)
@
text
@d180 1
a180 1
				AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_LANCAST_UNK_OPCODE));
d187 1
a187 1
		AddLogLine(false, RGB_RED + GetResString(IDS_LANCAST_ERR_MULITC));
d229 1
a229 1
		AddLogLine(false, RGB_RED + GetResString(IDS_ERR_TTL));
d246 1
a246 1
			AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_JOIN_FAILED),GetLancastIP(),t_strLanCastIP,GetLancastPort());
d259 1
a259 1
				AddLogLine(false, RGB_LIGHT_ORANGE + GetResString(IDS_LEAVE_FAILED),GetLancastPort());
@


1.20
log
@Added some colors to the logs...
@
text
@d119 1
a119 1
	AddDebugLogLine(false,_T("Lancast : Just Received %s"),buffer);
d126 1
a126 1
		AddDebugLogLine(false,_T("Lancast : Adding source for %s"),buffer);
d180 1
a180 1
				AddLogLine(false,_T("<COLOR=255,102,0>") + GetResString(IDS_LANCAST_UNK_OPCODE));
d187 1
a187 1
		AddLogLine(false,_T("<COLOR=255,0,0>") + GetResString(IDS_LANCAST_ERR_MULITC));
d229 1
a229 1
		AddLogLine(false,_T("<COLOR=255,0,0>") + GetResString(IDS_ERR_TTL));
d246 1
a246 1
			AddLogLine(false,_T("<COLOR=255,102,0>") + GetResString(IDS_JOIN_FAILED),GetLancastIP(),t_strLanCastIP,GetLancastPort());
d248 1
a248 1
			AddLogLine(false,IDS_JOIN_SUCCEEDED,GetLancastIP(),t_strLanCastIP,GetLancastPort());
d259 1
a259 1
				AddLogLine(false,_T("<COLOR=255,102,0>") + GetResString(IDS_LEAVE_FAILED),GetLancastPort());
d262 1
a262 1
				AddLogLine(false,IDS_LEAVE_SUCCEEDED,GetLancastPort());
@


1.19
log
@new way of adding sources
@
text
@d180 1
a180 1
				AddLogLine(false,IDS_LANCAST_UNK_OPCODE);
d187 1
a187 1
		AddLogLine(false,IDS_LANCAST_ERR_MULITC);
d229 1
a229 1
		AddLogLine(false,IDS_ERR_TTL);
d246 1
a246 1
			AddLogLine(false,IDS_JOIN_FAILED,GetLancastIP(),t_strLanCastIP,GetLancastPort());
d259 1
a259 1
				AddLogLine(false,IDS_LEAVE_FAILED,GetLancastPort());
@


1.18
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d103 3
a105 3

void CLanCast::RecieveHash(char* pachPacket, uint32 nSize){

d121 1
a121 1
	if (CPartFile* file = g_eMuleApp.m_pDownloadQueue->GetFileByID((uchar*)filehash)) {
d123 2
d129 1
a129 1
		CUpDownClient* newsource = new CUpDownClient(nPort,dwID,0,0,file);
d132 4
a135 2
		g_eMuleApp.m_pDownloadQueue->CheckAndAddSource(file,newsource);

d138 1
a138 2


@


1.17
log
@Formatting, comments, and name changes.
Removed #includes for "memcpy_amd.h".
@
text
@d206 1
a206 1
	memset(&m_saHostGroup, 0, sizeof(m_saHostGroup));
@


1.16
log
@Formatting, comments, and name changes.
Created distinct tag classes and typed enumerations for tags, opcodes, and protocols.
@
text
@d35 1
a35 1
#include "memcpy_amd.h"
@


1.15
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d55 1
a55 1
		char* sendbuffer = new char[packet->size+2];
d58 1
a58 1
		memcpy2(sendbuffer,packet->GetUDPHeader(),2);
d60 1
a60 1
		memcpy2(sendbuffer+2,packet->pBuffer,packet->size);
d63 1
a63 1
		if(m_SendSocket.SendTo(sendbuffer, packet->size+10, (SOCKADDR*)&m_saHostGroup, sizeof(SOCKADDR), 0) == SOCKET_ERROR)
d65 1
a65 1
			delete[] sendbuffer;
d70 1
a70 1
			delete[] sendbuffer;
d97 1
a97 1
		packet->opcode = OP_HASH;
@


1.14
log
@More name changes, reinstated CMuleCtrlItem class, moved srcsarevisible from CPartFile to CMuleCtrlItem (where it belongs), added "Show Full Status Icons" and "Show Gray Paused" features with corresponding preferences, modified "SmartOpen" code to make it sticky and to make it work with sources with changing states.
@
text
@a56 1
		#ifndef AMD
d58 1
a58 1
		memcpy(sendbuffer,packet->GetUDPHeader(),2);
d60 1
a60 7
		memcpy(sendbuffer+2,packet->pBuffer,packet->size);
		#else
		// Standard UDP Header
		memcpy_amd(sendbuffer,packet->GetUDPHeader(),2);
		// The packet Data
		memcpy_amd(sendbuffer+2,packet->pBuffer,packet->size);
		#endif
@


1.13
log
@Second batch of name changes
@
text
@d128 1
a128 1
	if (CPartFile* file = theApp.downloadqueue->GetFileByID((uchar*)filehash)) {
d137 1
a137 1
		theApp.downloadqueue->CheckAndAddSource(file,newsource);
d197 1
a197 1
		theApp.sharedfiles->NextLANBroadcast();
d262 1
a262 1
			if (theApp.emuledlg)	//sometimes method is called in app shutdown [TwoBottle Mod]
d265 1
a265 1
			if (theApp.emuledlg)	//sometimes method is called in app shutdown [TwoBottle Mod]
@


1.12
log
@First batch of the threatened name changes. Shouldn't be any logic changes here.
@
text
@d126 1
a126 1
	AddDebugLogLine(false,_T("Lancast : Just Recieved %s"),buffer);
d248 1
a248 1
		// Try and join the multicast group - 224.0.0.1, using the m_prefs port and no loopback
@


1.11
log
@unicode cleanup
@
text
@d42 1
a42 1
	prefs = in_prefs;
d248 1
a248 1
		// Try and join the multicast group - 224.0.0.1, using the prefs port and no loopback
@


1.10
log
@added some localizations (Lancast, corrupt hashset)
@
text
@d126 1
a126 1
	AddDebugLogLine(false,"Lancast : Just Recieved %s",buffer);
d131 1
a131 1
		AddDebugLogLine(false,"Lancast : Adding source for %s",buffer);
d246 1
a246 1
		CString t_strLanCastIP = inet_ntoa(host);
d249 1
a249 1
		if(!JoinGroup ("224.0.0.1", GetLancastPort() , 50,false))
@


1.9
log
@memcpy() optimized for AMD (faster in 2-2.5 times). AMD only. Compile with tag AMD
@
text
@d184 1
a184 1
				AddLogLine(false,"Lancast : Unknown OpCode");
d191 1
a191 1
		AddLogLine(false,"Lancast : Error receiving multicast data");
d233 1
a233 1
		AddLogLine(false,"Lancast : Warning, Error Setting Time to live");
d250 1
a250 1
			AddLogLine(false,"LanCast : Emule Lan Id has been set to %u (%s), Failed to Join LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastIP(),t_strLanCastIP,GetLancastPort());
d252 1
a252 1
			AddLogLine(false,"LanCast : Emule Lan Id has been set to %u (%s), Sucessfully Joined LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastIP(),t_strLanCastIP,GetLancastPort());
d263 1
a263 1
				AddLogLine(false,"Lancast : Failed to Leave LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
d266 1
a266 1
				AddLogLine(false,"Lancast : Sucessfully Left LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
@


1.8
log
@code cleanup
@
text
@d35 1
d57 1
a59 1

d62 6
d316 1
a316 1
}@


1.7
log
@code cleanup
@
text
@d87 1
a87 1
		CMemFile* file = new CMemFile(100);
d92 3
a94 3
		file->Write(&dwID,4);
		file->Write(&nPort,2);
		file->Write(cur_file->GetFileHash(),16);
d96 1
a96 1
		Packet* packet = new Packet(file,OP_LANCASTPROT);
d100 1
a100 3
		delete packet;
		delete file;
	
d106 1
a106 1
	CSafeMemFile* offeredfiles = new CSafeMemFile((BYTE*)pachPacket,nSize);
d113 3
a115 3
	offeredfiles->Read(&dwID,4);
	offeredfiles->Read(&nPort,2);
	offeredfiles->Read(&filehash,16);
a132 3

	delete offeredfiles;

@


1.6
log
@code cleanup
@
text
@d242 4
a245 3
		char t_strLanCastIP[17];
		sprintf(t_strLanCastIP,"%i.%i.%i.%i",(uint8)GetLancastIP(),(uint8)(GetLancastIP()>>8),(uint8)(GetLancastIP()>>16),(uint8)(GetLancastIP()>>24));

@


1.5
log
@more bugfixes!
@
text
@d120 1
a120 4
	char buffer[50];
	buffer[0] = 0;
	for (uint16 i = 0;i != 16;i++)
		sprintf(buffer,"%s%02X",buffer,filehash[i]);
@


1.4
log
@converted to new logging method
@
text
@a43 3

	udp_timer = SetTimer(0,4329,10000,CLanCast::UDPTimerProc);

d45 2
d48 1
a48 1

@


1.3
log
@fixed memory leak
@
text
@d125 1
a125 1
	theApp.emuledlg->AddDebugLogLine(false,"Lancast : Just Recieved %s",buffer);
d130 1
a130 1
		theApp.emuledlg->AddDebugLogLine(false,"Lancast : Adding source for %s",buffer);
d186 1
a186 1
				theApp.emuledlg->AddLogLine(false,"Lancast : Unknown OpCode");
d193 1
a193 1
		theApp.emuledlg->AddLogLine(false,"Lancast : Error receiving multicast data");
d235 1
a235 1
		theApp.emuledlg->AddLogLine(false,"Lancast : Warning, Error Setting Time to live");
d251 1
a251 1
			theApp.emuledlg->AddLogLine(false,"LanCast : Emule Lan Id has been set to %u (%s), Failed to Join LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastIP(),t_strLanCastIP,GetLancastPort());
d253 1
a253 1
			theApp.emuledlg->AddLogLine(false,"LanCast : Emule Lan Id has been set to %u (%s), Sucessfully Joined LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastIP(),t_strLanCastIP,GetLancastPort());
d264 1
a264 1
				theApp.emuledlg->AddLogLine(false,"Lancast : Failed to Leave LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
d267 1
a267 1
				theApp.emuledlg->AddLogLine(false,"Lancast : Sucessfully Left LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
@


1.2
log
@Lancast Tweak
@
text
@d263 2
a264 1
			theApp.emuledlg->AddLogLine(false,"Lancast : Failed to Leave LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
d266 2
a267 1
			theApp.emuledlg->AddLogLine(false,"Lancast : Sucessfully Left LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
@


1.1
log
@Lancast : Help other emules on your lan complete/download files quicker, saving bandwith.

1) UDP broadcasts your hashs over your lan
2) Listens for other clients sending broadcasts and adds them as sources
3) Clients on your lan bypass the queue, and have unlimited upload (download rate is still limited by emule downlaod speed)
@
text
@d45 2
d79 7
d244 4
a247 2
	char t_strLanCastIP[17];
	sprintf(t_strLanCastIP,"%i.%i.%i.%i",(uint8)GetLancastIP(),(uint8)(GetLancastIP()>>8),(uint8)(GetLancastIP()>>16),(uint8)(GetLancastIP()>>24));
d249 6
a254 5
	// Try and join the multicast group - 224.0.0.1, using the prefs port and no loopback
	if(!JoinGroup ("224.0.0.1", GetLancastPort() , 50,false))
		theApp.emuledlg->AddLogLine(false,"LanCast : Emule Lan Id has been set to %u (%s), Failed to Join LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastIP(),t_strLanCastIP,GetLancastPort());
	else {
		theApp.emuledlg->AddLogLine(false,"LanCast : Emule Lan Id has been set to %u (%s), Sucessfully Joined LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastIP(),t_strLanCastIP,GetLancastPort());
a256 2
	udp_timer = SetTimer(0,4329,10000,CLanCast::UDPTimerProc);

d261 6
a266 6

	if(!LeaveGroup())
		theApp.emuledlg->AddLogLine(false,"Lancast : Failed to Leave LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());
	else
		theApp.emuledlg->AddLogLine(false,"Lancast : Sucessfully Left LAN Broadcast Group ( 224.0.0.1 ) on port %i",GetLancastPort());

@

