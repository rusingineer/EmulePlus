head	1.10;
access;
symbols
	PublicRelease_1_2e:1.10
	Interim_Release_1-2e_RC1:1.10
	PublicRelease_1_2d:1.10
	Interim_Release_1-2d_RC1:1.10
	Interim_Release_1-2d_beta1:1.9
	PublicRelease_1_2c:1.9
	Interim_Release_1-2c_RC1:1.9
	Interim_Release_1-2c_beta1:1.8
	PublicRelease_1_2b:1.8
	Interim_Release_1-2b_RC1:1.8
	PublicRelease_1_2a:1.8
	Interim_Release_1-2a_RC1:1.8
	Interim_Release_1-2a_beta2:1.8
	Interim_Release_1-2a_beta1:1.8
	PublicRelease_1_2:1.8
	Interim_Release_1-2_RC1:1.8
	Interim_Release_1-2_beta1:1.8
	PublicRelease_1_1g:1.8
	Interim_Release_1-1g_RC3:1.8
	Interim_Release_1-1g_RC2:1.8
	Interim_Release_1-1g_RC1:1.8
	Interim_Release_1-1g_beta2:1.8
	Interim_Release_1-1g_beta1:1.8
	PublicRelease_1_1f:1.8
	Interim_Release_1-1f_RC1:1.8
	PublicRelease_1_1e:1.8
	Interim_Release_1-1e_RC2:1.8
	Interim_Release_1-1e_RC1:1.8
	Interim_Release_1-1e_beta1:1.8
	PublicRelease_1_1d:1.8
	Interim_Release_1-1d_RC1:1.8
	PublicRelease_1_1c:1.8
	Interim_Release_1-1c_RC1:1.8
	Interim_Release_1-1c_beta2:1.8
	Interim_Release_1-1c_beta1:1.7
	PublicRelease_1_1b:1.7
	Interim_Release_1-1b_RC1:1.7
	PublicRelease_1_1a:1.7
	Interim_Release_1-1a_RC2:1.7
	Interim_Release_1-1a_RC1:1.7
	Interim_Release_1-1a_beta2:1.7
	Interim_Release_1-1a_beta1:1.7
	PublicRelease_1_1:1.7
	Interim_Release_1-1_beta1:1.7
	PublicRelease_1o:1.7
	Interim_Release_1o_RC1:1.7
	Interim_Release_1o_beta1:1.7
	PublicRelease_1n:1.7
	Interim_Release_1n_RC2:1.7
	Interim_Release_1n_RC1:1.7
	Interim_Release_1n_beta2:1.7
	Interim_Release_1n_beta1:1.7
	PublicRelease_1m:1.7
	Interim_Release_1m_beta1:1.7
	PublicRelease_1l:1.7
	Interim_Release_1l_RC3:1.7
	Interim_Release_1l_RC2:1.7
	Interim_Release_1l_RC1:1.7
	Interim_Release_1l_beta2:1.7
	Interim_Release_1l_beta1:1.7
	PublicRelease_1k:1.7
	Interim_Release_1k_RC4:1.7
	Interim_1k_RC3:1.7
	Interim_1k_RC2:1.7
	Interim_Release_1k_RC1:1.7
	Interim_Release_1k_beta5:1.7
	Intrerim_Release_1k_beta4:1.7
	Interim_Release_1k_beta1:1.7
	PublicRelease_1j:1.4
	Interim_Release_1J_RC3:1.4
	Interim_Release_1j_RC3:1.4
	Interim_Release_1j_RC2:1.4
	Interim_Release_1j_RC1:1.4
	Interim_Release_1j_beta2:1.4
	Interim_Release_1j_beta1:1.4
	PublicRelease_1i:1.4
	Interim_Release_1i_RC6:1.4
	Interim_Release_1i_RC3:1.4
	Interim_Release_1i_RC2:1.4
	Interim_Release_1i_RC1:1.4
	Interim_Release_1i_beta3:1.4
	Interim_Release_1i_beta2:1.4
	Interim_Release_1i_beta1:1.2
	PublicRelease_1h:1.1
	Interim_Release_1h_rc2:1.1
	Interim_Release_1h_RC1:1.1
	Interim_Release_1h_beta2:1.1
	Interim_Release_1h_beta1_now:1.1
	Interim_Release_1h_beta1:1.1;
locks; strict;
comment	@// @;


1.10
date	2008.03.01.19.01.50;	author aw3;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.27.03.19.05;	author aw3;	state Exp;
branches;
next	1.8;

1.8
date	2005.02.03.19.48.07;	author kuchin;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.15.11.55.57;	author morevit;	state Exp;
branches;
next	1.6;

1.6
date	2004.02.13.01.47.11;	author aw3;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.11.04.13.00;	author katsyonak;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.14.18.40.58;	author syrus77;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.10.17.59.02;	author morevit;	state Exp;
branches;
next	1.2;

1.2
date	2003.09.21.22.05.17;	author morevit;	state Exp;
branches;
next	1.1;

1.1
date	2003.08.10.14.12.52;	author zegzav;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Reorganized inline code; Removed unused code; Faster comment search (eliminated extra class object creation)
Suppressed compiler warnings; Formatting.
@
text
@//	This file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#include "stdafx.h"
#ifndef NEW_SOCKETS_ENGINE
#include "emule.h"
#else
#include "opcodes.h"
#endif //NEW_SOCKETS_ENGINE
#include "PastComment.h"
#include "otherfunctions.h"

static const CString strPastCommentNul(_T(""));

CPastComment::CPastComment() : m_eRating(PF_RATING_NONE)
{
	md4clr(m_ClientHash);
}

CPastComment::CPastComment(const uchar client[16]) : m_eRating(PF_RATING_NONE)
{
	md4cpy(m_ClientHash, client);
}

CPastComment::CPastComment(const uchar client[16], const CString &strClientName, const CString &strFileName, const CString &strComment, EnumPartFileRating eRating)
	:  m_strClientName(strClientName), m_strFileName(strFileName), m_strComment(strComment), m_eRating(eRating)
{ 
	md4cpy(m_ClientHash, client);
}

bool CPastComment::operator==(const CPastComment &pc) const
{
	return (md4cmp(m_ClientHash, pc.m_ClientHash) == 0);
}

bool CPastCommentList::GetCommentRating(const uchar client[16], CString *pstrComment, EnumPartFileRating *peRate) const
{
	POSITION		pos;

	if ((pos = FindComment(client)) == NULL)
	{
		*pstrComment = _T("");
		*peRate = PF_RATING_NONE;
		return false;
	}
	CPastComment	pc = GetAt(pos);

	*pstrComment = pc.GetComment();
	*peRate = pc.GetRating();
	return true;
}

const CString& CPastCommentList::GetFileName(const uchar client[16])
{
	POSITION pos;
	if ((pos = FindComment(client)) == NULL)
		return strPastCommentNul;
	return GetAt(pos).GetFileName();
}

const CString& CPastCommentList::GetComment(const uchar client[16])
{
	POSITION pos;
	if ((pos = FindComment(client)) == NULL)
		return strPastCommentNul;
	return GetAt(pos).GetComment();
}

EnumPartFileRating CPastCommentList::GetRate(const uchar client[16])
{
	POSITION pos;
	if ((pos = FindComment(client)) == NULL)
		return PF_RATING_NONE;
	return GetAt(pos).GetRating();
}

void CPastCommentList::Add(const uchar client[16], const CString &strClientName, const CString &strFileName, const CString &strComment, EnumPartFileRating eRating)
{
	POSITION pos;
	CPastComment pc(client, strClientName, strFileName, strComment, eRating);
	if ((pos = Find(pc)) == NULL)
		AddTail(pc);
	else
		SetAt(pos, pc);
}

void CPastCommentList::Remove(const uchar client[16])
{
	POSITION pos;
	if ((pos = FindComment(client)) == NULL)
		return;
	RemoveAt(pos);
}

POSITION CPastCommentList::FindComment(const uchar client[16]) const
{
	CNode	*pNode = m_pNodeHead;

	for (; pNode != NULL; pNode = pNode->pNext)
		if (md4cmp(pNode->data.GetClientHash(), client) == 0)
			return (POSITION)pNode;
	return NULL;
}
@


1.9
log
@Stricter definitions of class methods.
@
text
@d1 15
a15 1
// #zegzav:pastcomment
a37 5
CPastComment::CPastComment(const uchar client[16], const CString &strClientName) : m_eRating(PF_RATING_NONE), m_strClientName(strClientName)
{
	md4cpy(m_ClientHash, client);
}

d53 1
a53 1
	if ((pos = Find(CPastComment(client))) == NULL)
d55 1
a55 1
		*pstrComment= _T("");
d66 1
a66 1
const CString &CPastCommentList::GetFileName(const uchar client[16])
d69 1
a69 1
	if ((pos= Find(CPastComment(client))) == NULL)
d74 1
a74 1
const CString &CPastCommentList::GetComment(const uchar client[16])
d77 1
a77 1
	if ((pos= Find(CPastComment(client))) == NULL)
d82 1
a82 1
byte CPastCommentList::GetRate(const uchar client[16])
d85 2
a86 2
	if ((pos= Find(CPastComment(client))) == NULL)
		return 0;
d94 1
a94 1
	if ((pos= Find(pc)) == NULL)
d103 1
a103 1
	if ((pos= Find(CPastComment(client))) == NULL)
d107 10
@


1.8
log
@More ifdefs for v2
@
text
@d19 1
a19 1
CPastComment::CPastComment(uchar client[16]) : m_eRating(PF_RATING_NONE)
d24 1
a24 1
CPastComment::CPastComment(uchar client[16], const CString &strClientName) : m_eRating(PF_RATING_NONE), m_strClientName(strClientName)
d29 1
a29 1
CPastComment::CPastComment(uchar client[16], const CString &strClientName, const CString &strFileName, const CString &strComment, EnumPartFileRating eRating)
d40 1
a40 1
bool CPastCommentList::GetCommentRating(uchar client[16], CString *pstrComment, EnumPartFileRating *peRate) const
d57 1
a57 1
const CString &CPastCommentList::GetFileName(uchar client[16])
d65 1
a65 1
const CString &CPastCommentList::GetComment(uchar client[16])
d73 1
a73 1
byte CPastCommentList::GetRate(uchar client[16])
d81 1
a81 1
void CPastCommentList::Add(uchar client[16], const CString &strClientName, const CString &strFileName, const CString &strComment, EnumPartFileRating eRating)
d91 1
a91 1
void CPastCommentList::Remove(uchar client[16])
@


1.7
log
@Changed uint32 to unsigned long from unsigned int and made necessary code changes. Got rid of _unsigned_ types int8,int16,int32,int64. Eliminated uint8 to avoid confusion. Use "byte".
@
text
@d4 1
d6 3
@


1.6
log
@Optimized hash processings
@
text
@d69 1
a69 1
int8 CPastCommentList::GetRate(uchar client[16])
@


1.5
log
@Replaced all zero filled memsets with optimized memzero (Thx Aw3 !) + some more Aw3 optimizations
@
text
@d12 1
a12 1
	memzero(m_ClientHash, 16);
a93 1

@


1.4
log
@Added MMX/AMD/SSE optimized memset [katsyonak]
@
text
@d12 1
a12 1
	memset2(m_ClientHash, 0, 16);
@


1.3
log
@Formatting, comments, and name changes.
@
text
@d6 1
d12 1
a12 1
	memset(m_ClientHash, 0, 16);
@


1.2
log
@Removed all #ifndef AMDs and consolidated CPU specific behavior in md4cpy() and new method memcpy2() (come up with a better name if you can :P ).
@
text
@d9 1
a9 1
CPastComment::CPastComment() : m_nRate(0)
d14 1
a14 1
CPastComment::CPastComment(uchar client[16]) : m_nRate(0)
d19 1
a19 1
CPastComment::CPastComment(uchar client[16], const CString &strClientName) : m_nRate(0), m_strClientName(strClientName)
d24 2
a25 2
CPastComment::CPastComment(uchar client[16], const CString &strClientName, const CString &strFileName, const CString &strComment, int8 nRate) : 
	m_strClientName(strClientName), m_strFileName(strFileName), m_strComment(strComment), m_nRate(nRate)
d35 1
a35 1
bool CPastCommentList::GetCommentRate(uchar client[16], CString *pstrComment, int8 *pnRate) const
d37 3
a39 2
	POSITION pos;
	if ((pos= Find(CPastComment(client))) == NULL)
d42 1
a42 1
		*pnRate= 0;
d45 4
a48 3
	CPastComment pc= GetAt(pos);
	*pstrComment= pc.GetComment();
	*pnRate= pc.GetRate();
d73 1
a73 1
	return GetAt(pos).GetRate();
d76 1
a76 1
void CPastCommentList::Add(uchar client[16], const CString &strClientName, const CString &strFileName, const CString &strComment, int8 nRate)
d79 1
a79 1
	CPastComment pc(client, strClientName, strFileName, strComment, nRate);
@


1.1
log
@added past comments
@
text
@a15 1
	#ifndef AMD
a16 3
	#else
	memcpy_amd(m_ClientHash, client, 16);
	#endif
a20 1
	#ifndef AMD
a21 3
	#else
	memcpy_amd(m_ClientHash, client, 16);
	#endif
a26 1
	#ifndef AMD
a27 3
	#else
	memcpy_amd(m_ClientHash, client, 16);
	#endif
@

