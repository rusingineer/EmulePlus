head	1.1;
branch	1.1.1;
access;
symbols
	arelease:1.1.1.2
	avendor:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2007.10.31.18.08.13;	author fuxie-dk;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.31.18.08.13;	author fuxie-dk;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.11.12.23.39.31;	author fuxie-dk;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@//this file is part of eMule
//Copyright (C)2002 Merkur ( merkur-@@users.sourceforge.net / http://www.emule-project.net )
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either
//version 2 of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

#pragma once

#include <map>
#include "types.h"
#include "opcodes.h"

//	MOREVIT - I'm abbreviating Category here to be consistent with the
//		method name abbreviations used throughout the code. These
//		methods often come in long chains and I decided to take
//		some mercy on my fellow teammembers by shortening it.
//		In this limited case it actually improves readability.

//	Predefined category IDs
enum _EnumCategories
{
	CAT_NONE = 0,
	CAT_FIRSTUSERCAT = 1,
	CAT_LASTUSERCAT = 99,

	CAT_PREDEFINED = 100,
	CAT_ALL = CAT_PREDEFINED,
	CAT_UNCATEGORIZED,
	CAT_INCOMPLETE,
	CAT_COMPLETED,
	CAT_WAITING,
	CAT_DOWNLOADING,
	CAT_ERRONEOUS,
	CAT_PAUSED,
	CAT_STOPPED,
	CAT_STALLED,
	CAT_ACTIVE,
	CAT_INACTIVE,

	CAT_LASTSTATUSCAT = CAT_INACTIVE,	// Update this if you add a new status category

	CAT_VIDEO,
	CAT_AUDIO,
	CAT_ARCHIVES,
	CAT_CDIMAGES,

	CAT_LASTPREDEFINEDCAT,
	CAT_TOTALPREDEFINEDCATS = CAT_LASTPREDEFINEDCAT-CAT_PREDEFINED, // NOTE: _total_ to distinguish it
																//		from _numPredefinedCats_ which would be
																//		the number visible

	CAT_MAXPREDEFINEDCATS = 155,
};
typedef EnumDomain<_EnumCategories>		EnumCategories;

class CPreferences;
class CCatDialog;
class CPartFile;

class CCat
{
//	Making these two classes friends means we don't have to put public
//		setters on this class which would make our data members writable
//		by classes which shouldn't be mucking with them.
friend class	CPreferences;
friend class	CCatDialog;

public:
				CCat();
				CCat( LPCTSTR strTitle,
					  LPCTSTR strSavePath=NULL,
					  LPCTSTR strTempPath=NULL,
					  LPCTSTR strComment=NULL,
					  LPCTSTR strAutoCatExt=NULL );
				CCat(EnumCategories ePredefinedCatID);

private:
	CString				m_strSavePath;
	CString				m_strTempPath;
	CString				m_strTitle;
	CString				m_strComment;
	CString				m_strAutoCatExt;
	COLORREF			m_crColor;
	byte				m_iPriority;
	bool				m_bIsPredefined;
	EnumCategories		m_eCatID;

	typedef CArray<CCat*,CCat*>				CCatArray;
	typedef std::map<EnumCategories,byte>	CCatIDMap;

	static EnumCategories	g_eAllCatType;
	static CCatArray		g_arrCat;
	static CCatIDMap		g_mapCatID;
	static byte				g_iNumPredefinedCats;

public:
//	Accessors
	const CString	&GetPath() const		{ return m_strSavePath; }
	const CString	&GetTempPath() const	{ return m_strTempPath; }
	const CString	&GetTitle() const		{ return m_strTitle; }
	void SetTitle(const CString &strVal)	{ m_strTitle = strVal; }
	const CString	&GetComment() const		{ return m_strComment; }
	COLORREF		GetColor() const		{ return m_crColor; }
	byte			GetPriority() const		{ return m_iPriority; }
	const CString	&GetAutoCatExt() const	{ return m_strAutoCatExt; }
	bool			IsPredefined() const	{ return m_bIsPredefined; }
	EnumCategories	GetID() const			{ return m_eCatID; }
//
//	NOTE: Category indices are:					0 .. GetNumCats()-1
//		  Indices for user categories are:		1 .. GetNumUserCats()
//		  IDs for user categories are:			1 .. CAT_PREDEFINED-1
//		  IDs for predefined categories are:	CAT_PREDEFINED .. CAT_PREDEFINED + GetNumPredefinedCats()-1
	static void				Finalize();
	static int				AddCat(CCat* pCat, bool bAssignNewID = true);
	static int				AddPredefinedCat(CCat *pCat);
	static bool				MoveCat(byte iFromIndex, byte iToIndex);
	static void				RemoveCatByIndex(int iIndex);
	static int				GetNumCats()		{ return g_arrCat.GetCount();}
	static int				GetNumUserCats()	{ return g_arrCat.GetCount() - g_iNumPredefinedCats; }
	static const TCHAR		*GetCatPathByIndex(byte index)	{ return g_arrCat[index]->m_strSavePath;}
	static byte				CatIndexToUserCatIndex(byte index) { return index - g_iNumPredefinedCats + 1; }
	static byte				UserCatIndexToCatIndex(byte userIndex) { return userIndex - 1 + g_iNumPredefinedCats; }
	static COLORREF			GetCatColorByIndex(byte index)	{ if (index >= static_cast<byte>(g_arrCat.GetCount())) return 0; else return g_arrCat[index]->m_crColor;}
	static COLORREF			GetCatColorByID(const EnumCategories &eCatID)	{ CCat* pCat = GetCatByID(eCatID); return pCat == NULL ? 0 : pCat->GetColor(); }
	static EnumCategories	GetAllCatType()	{ return g_eAllCatType;}
	static void				SetAllCatType(const EnumCategories &e)	{ g_eAllCatType = e; }
	static bool				CatIndexIsValid(int iIndex) { return (iIndex >= 0 && iIndex < g_arrCat.GetCount()); }
	static byte				GetNumPredefinedCats()	{ return g_iNumPredefinedCats; }
	static EnumCategories	GetCatIDByIndex(int index) { return GetCatByIndex(index)!=NULL ? GetCatByIndex(index)->m_eCatID : CAT_NONE; }
	static EnumCategories	GetCatIDByUserIndex(int iUserIndex) { byte index = UserCatIndexToCatIndex(iUserIndex); return GetCatIDByIndex(index); }
	static int				GetCatIndexByID(const EnumCategories &eCatID);
	static int				GetUserCatIndexByID(const EnumCategories &eCatID) { return CatIndexToUserCatIndex(GetCatIndexByID(eCatID)); }
	static CCat				*GetUserCatByIndex(int userIndex) { int index = UserCatIndexToCatIndex(userIndex); return(GetCatByIndex(index));}
	static CCat				*GetCatByIndex(int index) { if (CatIndexIsValid(index)) return g_arrCat[index]; else return NULL;}
	static CCat				*GetCatByUserIndex(int iUserIndex) { return GetCatByIndex(UserCatIndexToCatIndex(iUserIndex)); }
	static CCat				*GetCatByID(const EnumCategories &eCatID) { return GetCatByIndex(GetCatIndexByID(eCatID)); }
	static EnumCategories	GetNewCatID();
	static bool				FileBelongsToGivenCat(CPartFile *file,EnumCategories eCatID, bool bIgnoreViewFilter = false);
	static CString			GetPredefinedCatTitle(EnumCategories eCatID,int langID = 0);
};
@


1.1.1.1
log
@Backup files as per Aw3's request 
@
text
@@


1.1.1.2
log
@Backup files as per Aw3's request
@
text
@d1 2
a2 1
//	This file is part of eMule Plus
d4 4
a7 4
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
d9 4
a12 4
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
d14 4
a17 3
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
d22 7
d63 1
a63 1
	CAT_MAXPREDEFINEDCATS = 155
d119 1
a119 1

d129 6
a134 6
	static int				GetNumCats()						{ return g_arrCat.GetCount(); }
	static int				GetNumUserCats()					{ return g_arrCat.GetCount() - g_iNumPredefinedCats; }
	static const TCHAR*		GetCatPathByIndex(byte index)		{ return g_arrCat[index]->m_strSavePath; }
	static int				CatIndexToUserCatIndex(int index)	{ return index - g_iNumPredefinedCats + 1; }
	static int				UserCatIndexToCatIndex(int iUserIdx) { return iUserIdx - 1 + g_iNumPredefinedCats; }
	static COLORREF			GetCatColorByIndex(byte index)		{ if (index >= static_cast<byte>(g_arrCat.GetCount())) return 0; else return g_arrCat[index]->m_crColor; }
d136 1
a136 1
	static EnumCategories	GetAllCatType()						{ return g_eAllCatType; }
d138 4
a141 4
	static bool				CatIndexIsValid(int iIndex)			{ return (iIndex >= 0 && iIndex < g_arrCat.GetCount()); }
	static byte				GetNumPredefinedCats()				{ return g_iNumPredefinedCats; }
	static EnumCategories	GetCatIDByIndex(int index)			{ return GetCatByIndex(index)!=NULL ? GetCatByIndex(index)->m_eCatID : CAT_NONE; }
	static EnumCategories	GetCatIDByUserIndex(int iUserIdx)	{ return GetCatIDByIndex(UserCatIndexToCatIndex(iUserIdx)); }
d144 3
a146 2
	static CCat				*GetCatByIndex(int index)			{ if (CatIndexIsValid(index)) return g_arrCat[index]; else return NULL; }
	static CCat				*GetCatByUserIndex(int iUserIdx)	{ return GetCatByIndex(UserCatIndexToCatIndex(iUserIdx)); }
@

