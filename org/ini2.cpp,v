head	1.1;
branch	1.1.1;
access;
symbols
	arelease:1.1.1.3
	avendor:1.1.1;
locks; strict;
comment	@// @;


1.1
date	2007.10.18.14.44.12;	author fuxie-dk;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.10.18.14.44.12;	author fuxie-dk;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2007.10.31.18.08.18;	author fuxie-dk;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2007.11.12.23.39.36;	author fuxie-dk;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@// Ini2.cpp: Ini-File-Interface by bond006 <rene.landgrebe@@gmx.de>
// ****************************************************************
// This new interface replaces the old interface which was too slow

#include "stdafx.h"
#include "ini2.h"
#include "otherfunctions.h"

CIni::CIni(const CString &strFileName) : m_strDefCategory(_T(""))
{
	OpenFile(strFileName);
	ReadData();
}

CIni::~CIni()
{
	CloseFile();
}

void CIni::OpenFile(const CString& strFileName)
{
	if(m_hFile == CFile::hFileNull)
		Open(strFileName, CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyWrite);
}

void CIni::CloseFile()
{
	if(m_hFile!=CFile::hFileNull)
		Close();
}

void CIni::ReadData()
{
	if(m_hFile!=CFile::hFileNull)
	{
		char tempBuffer[131072]; // change this value to support larger files than 128KB
		memzero(tempBuffer, sizeof(tempBuffer));
		Read(tempBuffer, sizeof(tempBuffer));
		m_strFileBuffer = tempBuffer;

		// Cut off blank lines at the end of the file
		m_strFileBuffer.TrimRight(_T("\r\n"));
	}
}

void CIni::SaveAndClose()
{
	if(m_hFile!=CFile::hFileNull)
	{
		SetLength(0);
		m_strFileBuffer.TrimRight(_T("\r\n"));
		Write(m_strFileBuffer,m_strFileBuffer.GetLength());
	}

	CloseFile();
}

void CIni::AddCategory(const CString& strCategoryName)
{
	if(!CategoryExist(strCategoryName))
	{
		if(m_strFileBuffer.GetLength()!=0)
			m_strFileBuffer += _T("\r\n");

		m_strFileBuffer += _T('[');
		m_strFileBuffer += strCategoryName;
		m_strFileBuffer += _T(']');
	}
}

void CIni::SetDefaultCategory(const CString& strCategoryName)
{
	AddCategory(strCategoryName);

	m_strDefCategory = strCategoryName;
}

void CIni::SetDefaultCategory(const TCHAR *pcCategoryName)
{
	m_strDefCategory = pcCategoryName;

	AddCategory(m_strDefCategory);
}

void CIni::DeleteCategory(const CString& strCategoryName)
{
	if(CategoryExist(strCategoryName))
	{
		CString catSearchString = _T("[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

		// Check if the category is valid
		if(nCatFirstCharPos!=0)
		{
			catSearchString = _T("\r\n[");
			catSearchString += strCategoryName;
			catSearchString += _T(']');

			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		int nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() + 1));

		if (nCatLastCharPos < 0)
			nCatLastCharPos = m_strFileBuffer.GetLength();

		m_strFileBuffer.Delete(nCatFirstCharPos, (nCatLastCharPos - nCatFirstCharPos));
	}
}

void CIni::DeleteEntry(const CString& strCategoryName, const CString &strEntryName)
{
	if(EntryExist(strCategoryName,strEntryName))
	{
		CString catSearchString = _T("[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

		int nEntryFirstCharPos;
		int nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			catSearchString = _T("\r\n[");
			catSearchString += strCategoryName;
			catSearchString += _T(']');

			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		CString entrySearchString = _T("\r\n");
		entrySearchString += strEntryName;
		entrySearchString += _T('=');

		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() + 1));
		nEntryFirstCharPos += 2;

		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

		if (nEntryLastCharPos < 0)
			nEntryLastCharPos = m_strFileBuffer.GetLength();
		else
			nEntryLastCharPos += 2; // remove entry including "\r\n"

		m_strFileBuffer.Delete(nEntryFirstCharPos, (nEntryLastCharPos - nEntryFirstCharPos));
	}
}

CString CIni::GetString(const TCHAR *pcEntryName, const CString& defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return strTemp;
}

double CIni::GetDouble(const TCHAR *pcEntryName, double defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return _tstof(strTemp);
}

float CIni::GetFloat(const TCHAR *pcEntryName, float defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return (float)_tstof(strTemp);
}

int CIni::GetInt(const TCHAR *pcEntryName, int defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return _tstoi(strTemp);
}

uint32 CIni::GetUInt32(const TCHAR *pcEntryName, uint32 defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return _tstoi(strTemp);
}

uint64 CIni::GetUInt64(const TCHAR *pcEntryName, uint64 defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return _tstoi64(strTemp);
}

WORD CIni::GetWORD(const TCHAR *pcEntryName, WORD defValue)
{
	return static_cast<WORD>(GetUInt32(pcEntryName, defValue));
}

bool CIni::GetBool(const TCHAR *pcEntryName, bool defValue)
{
	CString strTemp = GetValue(pcEntryName);

	if (strTemp.IsEmpty() && !EntryExist(m_strDefCategory, pcEntryName))
		return defValue;
	else
		return (_tstoi(strTemp) != 0);
}

void CIni::SetString(const TCHAR *pcEntryName, const CString& strValue)
{
	SetValue(pcEntryName, strValue);
}

void CIni::SetDouble(const TCHAR *pcEntryName, double dValue)
{
	CString strValue;
	strValue.Format(_T("%g"),dValue);

	SetValue(pcEntryName, strValue);
}

void CIni::SetFloat(const TCHAR *pcEntryName, float fValue)
{
	CString strValue;
	strValue.Format(_T("%g"),fValue);

	SetValue(pcEntryName, strValue);
}

void CIni::SetInt(const TCHAR *pcEntryName, int nValue)
{
	CString strValue;
	strValue.Format(_T("%d"),nValue);

	SetValue(pcEntryName, strValue);
}

void CIni::SetUInt32(const TCHAR *pcEntryName, uint32 nValue)
{
	CString strValue;
	strValue.Format(_T("%u"), nValue);

	SetValue(pcEntryName, strValue);
}

void CIni::SetUInt64(const TCHAR *pcEntryName, uint64 nValue)
{
	CString strValue;
	strValue.Format(_T("%I64u"),nValue);

	SetValue(pcEntryName, strValue);
}

void CIni::SetWORD(const TCHAR *pcEntryName, WORD wValue)
{
	SetUInt32(pcEntryName, wValue);
}

void CIni::SetBool(const TCHAR *pcEntryName, bool bValue)
{
	CString strValue = (bValue) ? _T("1") : _T("0");

	SetValue(pcEntryName, strValue);
}

void CIni::GetArray(CString* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int nPos = 0;
	int nLastPos = 0;
	int nEscapePos = 0;

	// bugfix: using escape characters for "\" and "," in strings - 08/25/03
	if (temp.Find(_T('\\')) >= 0)
	{
		for(int i = 0; i < nElements; i++)
		{
			nLastPos = nPos;
			nPos = temp.Find(_T(','), nLastPos);
			nEscapePos = temp.Find(_T('\\'), nLastPos);

			if(nPos==(-2))
				pToArray[i] = _T("");

			if(nEscapePos==(-1) && nPos!=(-2))
			{
				if(nPos == (-1))
				{
					pToArray[i] = temp.Mid(nLastPos, (temp.GetLength() - nLastPos));
					nPos = -2;
				}
				else
				{
					pToArray[i] = (nPos >= 0) ? temp.Mid(nLastPos,(nPos - nLastPos)) : _T("");
					nPos++;
				}
			}
			else if(nEscapePos!=(-1) && nPos!=(-2))
			{
				if(nPos < nEscapePos)
				{
					if(nPos == (-1))
					{
						pToArray[i] = temp.Mid(nLastPos,(temp.GetLength() - nLastPos));
						nPos = -2;
					}
					else
					{
						pToArray[i] = (nPos >= 0) ? temp.Mid(nLastPos,(nPos - nLastPos)) : _T("");
						nPos++;
					}
				}
				else
				{
					int saveBegPos = nLastPos;

					while(nPos > nEscapePos && nEscapePos != (-1))
					{
						nLastPos = nEscapePos + 2;
						nPos = temp.Find(_T(','), nLastPos);
						nEscapePos = temp.Find(_T('\\'), nLastPos);
					}

					if(nPos == (-1))
					{
						pToArray[i] = temp.Mid(saveBegPos,(temp.GetLength() - saveBegPos));
						nPos = -2;
					}
					else
					{
						pToArray[i] = (nPos >= 0) ? temp.Mid(saveBegPos,(nPos - saveBegPos)) : _T("");
						nPos++;
					}
				}
			}

			pToArray[i].Replace(_T("\\,"),_T(","));
			pToArray[i].Replace(_T("\\\\"),_T("\\"));
		}
	}
	else
	{
		for(int i = 0; i < nElements; i++)
			pToArray[i] = (nPos >= 0) ? temp.Tokenize(_T(","), nPos) : _T("");
	}
}

void CIni::GetArray(double* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int nPos = 0;

	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? _tstof(temp.Tokenize(_T(","), nPos)) : 0.;
}

void CIni::GetArray(float* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int nPos = 0;

	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? (float)_tstof(temp.Tokenize(_T(","),nPos)) : 0.f;
}

void CIni::GetArray(int* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int nPos = 0;

	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? _tstoi(temp.Tokenize(_T(","),nPos)) : 0;
}

void CIni::GetArray(WORD* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int nPos = 0;

	for(int i=0;i<nElements;i++)
		pToArray[i] = (nPos >= 0) ? (WORD)_tstoi(temp.Tokenize(_T(","),nPos)) : 0;
}

void CIni::GetArray(bool* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp = GetString(pcEntryName, _T(""));

	int token, nPos = 0;

	for(int i=0;i<nElements;i++)
	{
		token = (nPos >= 0) ? _tstoi(temp.Tokenize(_T(","),nPos)) : 0;
		pToArray[i] = (token != 0);
	}
}

void CIni::SetArray(CString* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp;

	for(int i=0;i<nElements;i++)
	{
		// bugfix: using escape characters for "\" and "," in strings - 08/25/03
		pToArray[i].Replace(_T("\\"),_T("\\\\"));
		pToArray[i].Replace(_T(","),_T("\\,"));

		temp += pToArray[i];
		temp += _T(",");
	}

	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
}

void CIni::SetArray(double* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%g,"), pToArray[i]);

	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
}

void CIni::SetArray(float* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%g,"), pToArray[i]);

	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
}

void CIni::SetArray(int* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%d,"), pToArray[i]);

	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
}

void CIni::SetArray(WORD* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%u,"), pToArray[i]);

	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
}

void CIni::SetArray(bool* pToArray, int nElements, const TCHAR *pcEntryName)
{
	CString temp;

	for (int i = 0; i < nElements; i++)
		temp.AppendFormat(_T("%d,"), pToArray[i]);

	temp.TrimRight(_T(','));

	SetString(pcEntryName, temp);
}

void CIni::SetValue(const TCHAR *pcEntryName, const CString &strValue)
{
	CString	strEntryName = pcEntryName;

	if (EntryExist(m_strDefCategory, pcEntryName))
	{
		CString catSearchString = _T("[");
		catSearchString += m_strDefCategory;
		catSearchString += _T(']');

		int nValueFirstCharPos;
		int nEntryFirstCharPos;
		int nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			catSearchString = _T("\r\n[");
			catSearchString += m_strDefCategory;
			catSearchString += _T(']');

			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		CString entrySearchString = _T("\r\n");
		entrySearchString += strEntryName;
		entrySearchString += _T('=');

		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
		nEntryFirstCharPos += 2;
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

		if (nEntryLastCharPos < 0)
			nEntryLastCharPos = m_strFileBuffer.GetLength();

		nValueFirstCharPos = nEntryFirstCharPos + strEntryName.GetLength() + 1;

		// Delete an existing value and insert a new value
		m_strFileBuffer.Delete(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
		m_strFileBuffer.Insert(nValueFirstCharPos, strValue);
	}
	else
	{
		if(CategoryExist(m_strDefCategory))
		{
			CString catSearchString = _T("[");
			catSearchString += m_strDefCategory;
			catSearchString += _T(']');

			int nCatLastCharPos, nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

			// Check if the category is valid
			if (nCatFirstCharPos != 0)
			{
				catSearchString = _T("\r\n[");
				catSearchString += m_strDefCategory;
				catSearchString += _T(']');

				nCatFirstCharPos -= 2;
				nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
				nCatFirstCharPos += 2;
			}

			nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));

			CString entryString;

			strEntryName += _T('=');
			strEntryName += strValue;

			if (nCatLastCharPos < 0)
			{
				nCatLastCharPos = m_strFileBuffer.GetLength();
				entryString = _T("\r\n");
				entryString += strEntryName;
			}
			else
			{
				nCatLastCharPos += 2;
				entryString = strEntryName;
				entryString += _T("\r\n");
			}

			m_strFileBuffer.Insert(nCatLastCharPos, entryString);
		}
	}
}

CString CIni::GetValue(const TCHAR *pcEntryName)
{
	CString	strEntryName = pcEntryName;

	if (ValueExist(m_strDefCategory, strEntryName))
	{
		CString catSearchString = _T("[");
		catSearchString += m_strDefCategory;
		catSearchString += _T(']');

		int nValueFirstCharPos;
		int nEntryFirstCharPos;
		int nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(catSearchString);

		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			catSearchString = _T("\r\n[");
			catSearchString += m_strDefCategory;
			catSearchString += _T(']');

			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString,nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}

		CString entrySearchString = _T("\r\n");
		entrySearchString += strEntryName;
		entrySearchString += _T('=');

		nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
		nEntryFirstCharPos += 2;
		nEntryLastCharPos = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

		if (nEntryLastCharPos < 0)
			nEntryLastCharPos = m_strFileBuffer.GetLength();

		nValueFirstCharPos = nEntryFirstCharPos + strEntryName.GetLength() + 1;

		return m_strFileBuffer.Mid(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
	}
	else
		return _T("");
}

bool CIni::CategoryExist(const CString& strCategoryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');

	int nFindPos = m_strFileBuffer.Find(catSearchString);

	if (nFindPos < 0)
		return false;

	// Check if the category is valid
	if (nFindPos != 0)
	{
		catSearchString = _T("\r\n[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

		nFindPos -= 2;
		nFindPos = m_strFileBuffer.Find(catSearchString, nFindPos);

		if (nFindPos < 0)
			return false;
	}

	return true;
}

bool CIni::EntryExist(const CString &strCategoryName, const TCHAR *pcEntryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');

	int nEntryFirstCharPos;
	int nCatFirstCharPos;
	int nCatLastCharPos;

	if ((nCatFirstCharPos = m_strFileBuffer.Find(catSearchString)) < 0)
		// Category does not exist
		return false;

	// Check if the category is valid
	if (nCatFirstCharPos != 0)
	{
		catSearchString = _T("\r\n[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

		nCatFirstCharPos -= 2;
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);

		if (nCatFirstCharPos < 0)
			return false;

		nCatFirstCharPos += 2;
	}

	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() + 1));

	if (nCatLastCharPos < 0)
		// No following category exists - end of category is end of file
		nCatLastCharPos = m_strFileBuffer.GetLength();
	else
		nCatLastCharPos += 2;

	CString entrySearchString = _T("\r\n");
	entrySearchString += pcEntryName;
	entrySearchString += _T('=');

	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() + 1));
	
	if (nEntryFirstCharPos >= 0)
		nEntryFirstCharPos += 2;
	else
		return false;

	if (nEntryFirstCharPos < nCatFirstCharPos || nEntryFirstCharPos > nCatLastCharPos)
		// The entry we're searching for does not exist in the given category
		return false;

	return true;
}

bool CIni::ValueExist(const CString& strCategoryName, const CString& strEntryName)
{
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');

	int nEntryFirstCharPos;
	int nCatFirstCharPos;
	int nCatLastCharPos;

	if ((nCatFirstCharPos = m_strFileBuffer.Find(catSearchString)) < 0)
		return false;	// Category does not exist

	// Check if the category is valid
	if (nCatFirstCharPos != 0)
	{
		catSearchString = _T("\r\n[");
		catSearchString += strCategoryName;
		catSearchString += _T(']');

		nCatFirstCharPos -= 2;
		nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);

		if (nCatFirstCharPos < 0)
			return false;

		nCatFirstCharPos += 2;
	}

	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() + 1));

	if (nCatLastCharPos < 0)
		// No following category exists - end of category is end of file
		nCatLastCharPos = m_strFileBuffer.GetLength();
	else
		nCatLastCharPos += 2;

	CString entrySearchString = _T("\r\n");
	entrySearchString += strEntryName;
	entrySearchString += _T('=');

	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() + 1));

	if (nEntryFirstCharPos >= 0)
		nEntryFirstCharPos += 2;
	else
		return false;

	if(nEntryFirstCharPos < nCatFirstCharPos || nEntryFirstCharPos > nCatLastCharPos)
		// The entry we're searching for does not exist in the given category
		return false;

	int nEndOfLine = m_strFileBuffer.Find(_T("\r\n"), nEntryFirstCharPos);

	if (nEndOfLine < 0)
		nEndOfLine = m_strFileBuffer.GetLength();

	if ((nEntryFirstCharPos + strEntryName.GetLength() + 1) == nEndOfLine)
		return false;

	return true;
}
@


1.1.1.1
log
@Backup files as per Aw3's request 
@
text
@@


1.1.1.2
log
@Backup files as per Aw3's request
@
text
@a0 16
//	this file is part of eMule Plus
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License
//	as published by the Free Software Foundation; either
//	version 2 of the License, or (at your option) any later version.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//
d9 1
a9 2
CIni::CIni(const CString &strFileName, bool bReadOnly/*false*/)
	: m_strDefCategory(_T("")), m_strFileBuffer(_T(""))
d11 1
a11 1
	OpenFile(strFileName, bReadOnly);
d20 1
a20 1
void CIni::OpenFile(const CString &strFileName, bool bReadOnly)
d22 2
a23 3
	if (m_hFile == CFile::hFileNull)
		Open( strFileName, (bReadOnly) ? (CFile::modeRead | CFile::shareDenyWrite) :
			(CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyWrite) );
d28 1
a28 1
	if (m_hFile != CFile::hFileNull)
d34 1
a34 1
	if (m_hFile != CFile::hFileNull)
d48 1
a48 1
	if (m_hFile != CFile::hFileNull)
d52 1
a52 1
		Write(m_strFileBuffer, m_strFileBuffer.GetLength());
@


1.1.1.3
log
@Backup files as per Aw3's request
@
text
@d1 1
a1 1
//	This file is part of eMule Plus
a26 2
	, m_strDefCatBraces(_T("")), m_strDefCatBracesCR(_T(""))
	, m_strInternXchg(_T(""))
a29 1
	m_strInternXchg.Preallocate(128);
d76 3
a78 3
void CIni::AddCategory(const CString &strCategoryName)
{	//	strCategoryName is in "[Name]" format
	if (!CategoryExist(strCategoryName))
d80 1
a80 1
		if (!m_strFileBuffer.IsEmpty())
d82 2
d85 1
d91 2
a93 4
	m_strDefCatBraces.Format(_T("[%s]"), m_strDefCategory);
	m_strDefCatBracesCR.Format(_T("\r\n[%s]"), m_strDefCategory);

	AddCategory(m_strDefCatBraces);
a98 2
	m_strDefCatBraces.Format(_T("[%s]"), m_strDefCategory);
	m_strDefCatBracesCR.Format(_T("\r\n[%s]"), m_strDefCategory);
d100 1
a100 1
	AddCategory(m_strDefCatBraces);
d105 5
a109 3
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');
a110 2
	if (CategoryExist(catSearchString))
	{
d114 1
a114 1
		if (nCatFirstCharPos != 0)
d121 1
a121 1
			nCatFirstCharPos = m_strFileBuffer.Find(catSearchString, nCatFirstCharPos);
a128 2
		else
			nCatLastCharPos += 2;
d136 5
a140 3
	CString catSearchString = _T("[");
	catSearchString += strCategoryName;
	catSearchString += _T(']');
d142 2
a143 3
	if (EntryExist(catSearchString, strEntryName))
	{
		int nEntryFirstCharPos, nEntryLastCharPos;
d176 1
a176 1
__declspec(noinline) const CString& CIni::GetString(const TCHAR *pcEntryName, const TCHAR *pcValue)
d178 6
a183 4
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
		m_strInternXchg = pcValue;
	return m_strInternXchg;
d186 1
a186 1
__declspec(noinline) double CIni::GetDouble(const TCHAR *pcEntryName, double defValue)
d188 3
a190 2
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
d193 1
a193 1
		return _tstof(m_strInternXchg);
d198 3
a200 2
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
d203 1
a203 1
		return (float)_tstof(m_strInternXchg);
d206 1
a206 1
__declspec(noinline) int CIni::GetInt(const TCHAR *pcEntryName, int defValue)
d208 3
a210 2
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
d213 1
a213 1
		return _tstoi(m_strInternXchg);
d218 6
a223 1
	return static_cast<uint32>(GetInt(pcEntryName, defValue));
d226 1
a226 1
__declspec(noinline) uint64 CIni::GetUInt64(const TCHAR *pcEntryName, uint64 defValue)
d228 3
a230 2
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
d233 1
a233 1
		return _tstoi64(m_strInternXchg);
d241 1
a241 1
__declspec(noinline) bool CIni::GetBool(const TCHAR *pcEntryName, bool defValue)
d243 3
a245 2
	GetValue(pcEntryName);
	if (m_strInternXchg.IsEmpty() && !EntryExist(m_strDefCatBraces, pcEntryName))
d248 1
a248 1
		return (_tstoi(m_strInternXchg) != 0);
d258 4
a261 2
	m_strInternXchg.Format(_T("%g"), dValue);
	SetValue(pcEntryName, m_strInternXchg);
d266 4
a269 2
	m_strInternXchg.Format(_T("%g"),fValue);
	SetValue(pcEntryName, m_strInternXchg);
d272 1
a272 1
void CIni::SetInt(const TCHAR *pcEntryName, int iValue)
d274 4
a277 2
	m_strInternXchg.Format(_T("%d"), iValue);
	SetValue(pcEntryName, m_strInternXchg);
d280 1
a280 1
void CIni::SetUInt32(const TCHAR *pcEntryName, uint32 dwValue)
d282 4
a285 2
	m_strInternXchg.Format(_T("%u"), dwValue);
	SetValue(pcEntryName, m_strInternXchg);
d288 1
a288 1
void CIni::SetUInt64(const TCHAR *pcEntryName, uint64 qwValue)
d290 4
a293 2
	m_strInternXchg.Format(_T("%I64u"), qwValue);
	SetValue(pcEntryName, m_strInternXchg);
d303 3
a305 2
	m_strInternXchg = (bValue) ? _T("1") : _T("0");
	SetValue(pcEntryName, m_strInternXchg);
d308 1
a308 1
void CIni::GetArray(CString *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d319 1
a319 1
		for (unsigned ui = 0; ui < uiElements; ui++)
d326 1
a326 1
				pToArray[ui] = _T("");
d332 1
a332 1
					pToArray[ui] = temp.Mid(nLastPos, (temp.GetLength() - nLastPos));
d337 1
a337 1
					pToArray[ui] = (nPos >= 0) ? temp.Mid(nLastPos, (nPos - nLastPos)) : _T("");
d347 1
a347 1
						pToArray[ui] = temp.Mid(nLastPos, (temp.GetLength() - nLastPos));
d352 1
a352 1
						pToArray[ui] = (nPos >= 0) ? temp.Mid(nLastPos, (nPos - nLastPos)) : _T("");
d369 1
a369 1
						pToArray[ui] = temp.Mid(saveBegPos,(temp.GetLength() - saveBegPos));
d374 1
a374 1
						pToArray[ui] = (nPos >= 0) ? temp.Mid(saveBegPos,(nPos - saveBegPos)) : _T("");
d380 2
a381 2
			pToArray[ui].Replace(_T("\\,"), _T(","));
			pToArray[ui].Replace(_T("\\\\"), _T("\\"));
d386 2
a387 2
		for (unsigned ui = 0; ui < uiElements; ui++)
			pToArray[ui] = (nPos >= 0) ? temp.Tokenize(_T(","), nPos) : _T("");
d391 1
a391 1
void CIni::GetArray(double *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d395 1
a395 1
	int iPos = 0;
d397 2
a398 2
	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? _tstof(temp.Tokenize(_T(","), iPos)) : 0.;
d401 1
a401 1
void CIni::GetArray(float *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d405 1
a405 1
	int iPos = 0;
d407 2
a408 2
	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? (float)_tstof(temp.Tokenize(_T(","), iPos)) : 0.f;
d411 1
a411 1
void CIni::GetArray(int *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d415 1
a415 1
	int iPos = 0;
d417 2
a418 2
	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? _tstoi(temp.Tokenize(_T(","), iPos)) : 0;
d421 1
a421 1
void CIni::GetArray(WORD *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d425 1
a425 1
	int iPos = 0;
d427 2
a428 2
	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (iPos >= 0) ? (WORD)_tstoi(temp.Tokenize(_T(","), iPos)) : 0;
d431 1
a431 1
void CIni::GetArray(bool *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d435 1
a435 1
	int iPos = 0;
d437 5
a441 2
	for (unsigned ui = 0; ui < uiElements; ui++)
		pToArray[ui] = (((iPos >= 0) ? _tstoi(temp.Tokenize(_T(","), iPos)) : 0) != 0);
d444 1
a444 1
void CIni::SetArray(CString *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d446 3
a448 2
	m_strInternXchg = _T("");
	for (unsigned ui = 0; ui < uiElements; ui++)
d451 2
a452 2
		pToArray[ui].Replace(_T("\\"), _T("\\\\"));
		pToArray[ui].Replace(_T(","), _T("\\,"));
d454 2
a455 2
		m_strInternXchg += pToArray[ui];
		m_strInternXchg += _T(",");
a456 1
	m_strInternXchg.TrimRight(_T(','));
d458 3
a460 1
	SetString(pcEntryName, m_strInternXchg);
d463 1
a463 1
void CIni::SetArray(double *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d465 4
a468 1
	m_strInternXchg = _T("");
d470 1
a470 3
	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(_T("%g,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d472 1
a472 1
	SetString(pcEntryName, m_strInternXchg);
d475 1
a475 1
void CIni::SetArray(float *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d477 1
a477 1
	m_strInternXchg = _T("");
d479 2
a480 3
	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(_T("%g,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d482 3
a484 1
	SetString(pcEntryName, m_strInternXchg);
d487 1
a487 1
void CIni::SetArray(int *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d489 4
a492 1
	m_strInternXchg = _T("");
d494 1
a494 3
	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(_T("%d,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d496 1
a496 1
	SetString(pcEntryName, m_strInternXchg);
d499 1
a499 1
void CIni::SetArray(WORD *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d501 1
a501 1
	m_strInternXchg = _T("");
d503 2
a504 3
	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(_T("%u,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d506 3
a508 1
	SetString(pcEntryName, m_strInternXchg);
d511 1
a511 1
void CIni::SetArray(bool *pToArray, unsigned uiElements, const TCHAR *pcEntryName)
d513 4
a516 1
	m_strInternXchg = _T("");
d518 1
a518 3
	for (unsigned ui = 0; ui < uiElements; ui++)
		m_strInternXchg.AppendFormat(_T("%d,"), pToArray[ui]);
	m_strInternXchg.TrimRight(_T(','));
d520 1
a520 1
	SetString(pcEntryName, m_strInternXchg);
d525 1
a525 1
	CString	strEntryName(pcEntryName);
d527 1
a527 1
	if (EntryExist(m_strDefCatBraces, pcEntryName))
d529 8
a536 2
		int nValueFirstCharPos, nEntryFirstCharPos, nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBraces);
d541 4
d546 1
a546 1
			nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBracesCR, nCatFirstCharPos);
d567 1
a567 1
	else if (CategoryExist(m_strDefCatBraces))
d569 5
a573 1
		int nCatLastCharPos, nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBraces);
d575 15
a589 7
		// Check if the category is valid
		if (nCatFirstCharPos != 0)
		{
			nCatFirstCharPos -= 2;
			nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBracesCR, nCatFirstCharPos);
			nCatFirstCharPos += 2;
		}
d591 1
a591 1
		nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + m_strDefCategory.GetLength() + 1));
d593 2
a594 1
		CString entryString;
d596 12
a607 2
		strEntryName += _T('=');
		strEntryName += strValue;
d609 1
a609 5
		if (nCatLastCharPos < 0)
		{
			nCatLastCharPos = m_strFileBuffer.GetLength();
			entryString = _T("\r\n");
			entryString += strEntryName;
a610 8
		else
		{
			nCatLastCharPos += 2;
			entryString = strEntryName;
			entryString += _T("\r\n");
		}

		m_strFileBuffer.Insert(nCatLastCharPos, entryString);
d614 1
a614 1
void CIni::GetValue(const TCHAR *pcEntryName)
d616 1
a616 1
	CString	strEntryName(pcEntryName);
d618 1
a618 1
	if (ValueExist(m_strDefCatBraces, strEntryName))
d620 8
a627 2
		int nValueFirstCharPos, nEntryFirstCharPos, nEntryLastCharPos;
		int nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBraces);
d632 4
d637 1
a637 1
			nCatFirstCharPos = m_strFileBuffer.Find(m_strDefCatBracesCR, nCatFirstCharPos);
d654 1
a654 1
		m_strInternXchg = m_strFileBuffer.Mid(nValueFirstCharPos, (nEntryLastCharPos - nValueFirstCharPos));
d657 1
a657 1
		m_strInternXchg = _T("");
d660 7
a666 3
bool CIni::CategoryExist(const CString &strCategoryName)
{	//	strCategoryName is in "[Name]" format
	int iFindPos = m_strFileBuffer.Find(strCategoryName);
d668 1
a668 1
	if (iFindPos < 0)
d672 1
a672 1
	if (iFindPos != 0)
d674 3
a676 1
		CString	catSearchString(_T("\r\n"));
d678 2
a679 3
		catSearchString += strCategoryName;
		iFindPos -= 2;
		iFindPos = m_strFileBuffer.Find(catSearchString, iFindPos);
d681 1
a681 1
		if (iFindPos < 0)
d689 4
a692 2
{	//	strCategoryName is in "[Name]" format
	int nEntryFirstCharPos, nCatFirstCharPos, nCatLastCharPos;
d694 7
a700 2
	if ((nCatFirstCharPos = m_strFileBuffer.Find(strCategoryName)) < 0)
		return false;	// Category does not exist
d705 3
a707 1
		CString	catSearchString(_T("\r\n"));
a708 1
		catSearchString += strCategoryName;
d718 1
a718 1
	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() - 1));
d730 1
a730 1
	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() - 1));
d744 5
a748 3
bool CIni::ValueExist(const CString &strCategoryName, const CString& strEntryName)
{	//	strCategoryName is in "[Name]" format
	int nEntryFirstCharPos, nCatFirstCharPos, nCatLastCharPos;
d750 5
a754 1
	if ((nCatFirstCharPos = m_strFileBuffer.Find(strCategoryName)) < 0)
d760 3
a762 1
		CString	catSearchString(_T("\r\n"));
a763 1
		catSearchString += strCategoryName;
d773 1
a773 1
	nCatLastCharPos = m_strFileBuffer.Find(_T("\r\n["), (nCatFirstCharPos + strCategoryName.GetLength() - 1));
d785 1
a785 1
	nEntryFirstCharPos = m_strFileBuffer.Find(entrySearchString, (nCatFirstCharPos + strCategoryName.GetLength() - 1));
@


