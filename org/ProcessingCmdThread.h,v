head	1.1;
branch	1.1.1;
access;
symbols
	arelease:1.1.1.1
	avendor:1.1.1;
locks; strict;
comment	@ * @;


1.1
date	2007.09.27.14.23.01;	author fuxie-dk;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2007.09.27.14.23.01;	author fuxie-dk;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#pragma once

class CPartFile;
class CSharedFileList;

enum ProcCommand {PC_QUIT=0,PC_HASH};

struct Process_Cmd_struct // stucture to pass command
{
	long lSize; // size of the structure
	ProcCommand eCommand; // command passed
	CSharedFileList* pOwner;
	CPartFile* in_partfile_Owner;
	TCHAR *cFileName;
	TCHAR *cFolder;
};

struct PThread_Init_struct
{
	HANDLE hCommandPipe;
};

// CProcessingCmdThread

class CProcessingCmdThread : public CWinThread
{
	DECLARE_DYNCREATE(CProcessingCmdThread)

protected:
	CProcessingCmdThread();           // protected constructor used by dynamic creation
	virtual ~CProcessingCmdThread();
	void SetStopThread(bool bStop);
	bool IsThreadAboutToStop(void);

	HANDLE m_hCommandPipe;

public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
protected:
	CMutex m_StopLock;
	bool m_bStopThread;
	DECLARE_MESSAGE_MAP()
public:
	CEvent m_QuitPCmdEvent;
	BOOL SetStartupData(PThread_Init_struct* pInitStruct);
	virtual int Run();
	static bool SendQuitCommand(HANDLE hControlPipe);
	void SetThreadToStopProcessing(void);
	static bool AddFileToHash(HANDLE hControlPipe,CSharedFileList* pOwner, const CString& strFolder, const CString& strFileName, CPartFile* pPartFileOwner);
protected:
	// Performs actual hashing of the file
	void HashFile(CSharedFileList* pOwner, const CString& strFolder, const CString& strFileName, CPartFile* pPartFileOwner);
	void ReleaseHashStruct(Process_Cmd_struct* pStruct);
public:

};


@


1.1.1.1
log
@Backup files as per Aw3's request 
@
text
@@
